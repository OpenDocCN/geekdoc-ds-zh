- en: 5 Graph tables, add labels, make notes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 图表表格，添加标签，做笔记
- en: 原文：[https://socviz.co/workgeoms.html](https://socviz.co/workgeoms.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://socviz.co/workgeoms.html](https://socviz.co/workgeoms.html)
- en: This Chapter builds on the foundation we have laid down. Things will get a little
    more sophisticated in three ways. First, we will learn about how to transform
    data *before* we send it to ggplot to be turned into a figure. As we saw in Chapter
    [4](groupfacettx.html#groupfacettx), ggplot’s geoms will often summarize data
    for us. While convenient, this can sometimes be awkward or even a little opaque.
    Often, it’s better to get things into the right shape before we send anything
    to ggplot. This is a job for another tidyverse component, the `dplyr` library.
    We will learn how to use some of its “action verbs” to select, group, summarize
    and transform our data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章建立在我们已经奠定的基础之上。在三个方面，事情将变得更加复杂。首先，我们将学习在将数据发送到ggplot进行转换为图形之前如何转换数据。正如我们在第[4](groupfacettx.html#groupfacettx)章中看到的，ggplot的几何形状通常会为我们汇总数据。虽然方便，但有时可能会有些尴尬，甚至有些不透明。通常，在将任何内容发送到ggplot之前，将事物整理到正确的形状会更好。这是一项tidyverse组件`dplyr`的工作。我们将学习如何使用其中的一些“动作动词”来选择、分组、汇总和转换我们的数据。
- en: Second, we will expand the number of geoms we know about, and learn more about
    how to choose between them. The more we learn about ggplot’s geoms, the easier
    it will be to pick the right one given the data we have and the visualization
    we want. As we learn about new geoms, we will also get a little more adventurous
    and depart from some of ggplot’s default arguments and settings. We will learn
    how to reorder the variables displayed in our figures, and how to subset the data
    we use before we display it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们将扩展我们所知道的几何形状的数量，并学习更多关于如何在这之间进行选择。我们了解ggplot的几何形状越多，根据我们拥有的数据和想要的可视化选择正确的几何形状就越容易。随着我们了解新的几何形状，我们也将变得更加大胆，并偏离一些ggplot的默认参数和设置。我们将学习如何重新排列我们图表中显示的变量，以及在我们显示之前如何对使用的数据进行子集化。
- en: Third, this process of gradual customization will give us the opportunity to
    learn a little more about the scale, guide, and theme functions that we have mostly
    taken for granted until now. These will give us even more control over the content
    and appearance of our graphs. Together, these techniques can be used to make plots
    much more legible to readers. They allow us to present our data in a more structured
    and easily comprehensible way, and to pick out the elements of it that are of
    particular interest. We will begin to use these techniques to layer geoms on top
    of one another, a technique that will allow us to produce very sophisticated graphs
    in a systematic, comprehensible way.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，这个逐步定制的过程将给我们提供机会，让我们更多地了解我们至今为止大多视为理所当然的刻度、指南和主题函数。这些将给我们更多的控制权，以控制图表的内容和外观。这些技术共同使用可以使图表对读者来说更加易于阅读。它们允许我们以更结构化和易于理解的方式呈现我们的数据，并挑选出其中特别感兴趣的部分。我们将开始使用这些技术将几何形状叠加在一起，这种技术将使我们能够以系统化和可理解的方式制作非常复杂的图表。
- en: Our basic approach will not change. No matter how complex our plots get, or
    how many individual steps we take to layer and tweak their features, underneath
    we will always be doing the same thing. We want a table of tidy data, a mapping
    of variables to aesthetic elements, and a particular type of graph. If you can
    keep sight of this, it will make it easier to confidently approach the job of
    getting any particular graph to look just right.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本方法不会改变。无论我们的图表多么复杂，或者我们为了叠加和调整它们的特征而采取多少个单独的步骤，在底层我们始终在做同样的事情。我们想要一个整洁的数据表，一个变量到美学元素的映射，以及特定类型的图表。如果你能保持这一点，这将使你更有信心地处理任何特定图表看起来恰到好处的工作。
- en: 'Table 5.1: Column marginals. (Numbers in columns sum to 100.)'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1：列边际。 (列中的数字总和为100。)
- en: '|  | Protestant | Catholic | Jewish | None | Other | NA |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|  | 新教徒 | 天主教徒 | 犹太教徒 | 无 | 其他 | NA |'
- en: '| --- | --: | --: | --: | --: | --: | --: |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| --- | --: | --: | --: | --: | --: | --: |'
- en: '| Northeast | 12 | 25 | 53 | 18 | 18 | 6 |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 东北部 | 12 | 25 | 53 | 18 | 18 | 6 |'
- en: '| Midwest | 24 | 27 | 6 | 25 | 21 | 28 |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 中部 | 24 | 27 | 6 | 25 | 21 | 28 |'
- en: '| South | 47 | 25 | 22 | 27 | 31 | 61 |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 南部 | 47 | 25 | 22 | 27 | 31 | 61 |'
- en: '| West | 17 | 24 | 20 | 29 | 30 | 6 |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 西部 | 17 | 24 | 20 | 29 | 30 | 6 |'
- en: 5.1 Use pipes to summarize data
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 使用管道来汇总数据
- en: In Chapter [4](groupfacettx.html#groupfacettx) we began making plots of the
    distributions and relative frequencies of variables. Cross-classifying one measure
    by another is one of the basic descriptive tasks in data analysis. Tables [5.1](workgeoms.html#tab:relig1)
    and [5.2](workgeoms.html#tab:relig2) show two common ways of summarizing our GSS
    data on the distribution of religious affiliation and region. Table [5.1](workgeoms.html#tab:relig1)
    shows the column marginals, where the numbers sum to a hundred by column and show,
    e.g., the distribution of Protestants across regions. Meanwhile in Table [5.2](workgeoms.html#tab:relig2)
    the numbers sum to a hundred across the rows, showing for example the distribution
    of religious affiliations within any particular region.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在第[4](groupfacettx.html#groupfacettx)章中，我们开始绘制变量分布和相对频率的图表。通过一个度量值对另一个度量值进行交叉分类是数据分析中的基本描述性任务之一。表[5.1](workgeoms.html#tab:relig1)和[5.2](workgeoms.html#tab:relig2)展示了两种总结我们GSS数据中宗教归属和地区分布的常见方法。表[5.1](workgeoms.html#tab:relig1)显示了列边际，其中数字按列相加总和为一百，例如显示不同地区新教徒的分布。同时，在表[5.2](workgeoms.html#tab:relig2)中，数字按行相加总和为一百，例如显示任何特定地区内宗教归属的分布。
- en: We saw in Chapter [4](groupfacettx.html#groupfacettx) that `geom_bar()` can
    plot both counts and relative frequencies depending on what we asked of it. In
    practice, though, letting the geoms (and their `stat_` functions) do the work
    can sometimes get a little confusing. It is too easy to lose track of whether
    one has calculated row margins, column margins, or overall relative frequencies.
    The code to do the calculations on the fly ends up stuffed into the mapping function
    and can become hard to read. A better strategy is to calculate the frequency table
    you want first, and then plot that table. This has the benefit of allowing you
    do to some quick sanity checks on your tables, to make sure you haven’t made any
    errors.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第[4](groupfacettx.html#groupfacettx)章中看到，`geom_bar()`可以根据我们对其的要求绘制计数和相对频率。然而，在实践中，让几何图形（及其`stat_`函数）做工作有时可能会有些混乱。很容易失去对是否已经计算了行边际、列边际或整体相对频率的跟踪。实时计算的计算代码最终会被塞入映射函数中，变得难以阅读。更好的策略是首先计算你想要的频率表，然后绘制该表。这样做的好处是允许你快速检查你的表格，以确保你没有犯任何错误。
- en: 'Table 5.2: Row marginals. (Numbers in rows sum to 100.)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.2：行边际。（行中的数字总和为100。）
- en: '|  | Protestant | Catholic | Jewish | None | Other | NA |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|  | 新教徒 | 天主教徒 | 犹太教徒 | 无 | 其他 | NA |'
- en: '| --- | --: | --: | --: | --: | --: | --: |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| --- | --: | --: | --: | --: | --: | --: |'
- en: '| Northeast | 32 | 33 | 6 | 23 | 6 | 0 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 东北部 | 32 | 33 | 6 | 23 | 6 | 0 |'
- en: '| Midwest | 47 | 25 | 0 | 23 | 5 | 1 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 中部地区 | 47 | 25 | 0 | 23 | 5 | 1 |'
- en: '| South | 62 | 15 | 1 | 16 | 5 | 1 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 南部 | 62 | 15 | 1 | 16 | 5 | 1 |'
- en: '| West | 38 | 25 | 2 | 28 | 8 | 0 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 西部 | 38 | 25 | 2 | 28 | 8 | 0 |'
- en: Let’s say we want a plot of the row-marginals for religion within region. We
    will take the opportunity to do a little bit of data-munging in order to get from
    our underlying table of GSS data to the summary tabulation that we want to plot.
    To do this we will use the tools provided by `dplyr`, a component of the tidyverse
    library that provides functions for manipulating and reshaping tables of data
    on the fly. We start from our individual-level `gss_sm` data frame with its `bigregion`
    and `religion` variables. Our goal is a summary table with percentages of religious
    preferences grouped within region.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要绘制宗教在地区内的行边际图。我们将利用这个机会进行一些数据处理，以便从我们的GSS数据基础表到我们想要绘制的汇总表。为此，我们将使用`dplyr`提供的工具，它是tidyverse库的一个组成部分，它提供了实时操作和重塑数据表的功能。我们从包含`bigregion`和`religion`变量的个人级`gss_sm`数据框开始。我们的目标是创建一个汇总表，其中包含按地区分组的宗教偏好的百分比。
- en: '![How we want to transform the individual-level data.](../Images/c96fe64ed11c6cdbac73f2faf91c0a26.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![我们想要如何转换个人级数据。](../Images/c96fe64ed11c6cdbac73f2faf91c0a26.png)'
- en: 'Figure 5.1: How we want to transform the individual-level data.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：我们想要如何转换个人级数据。
- en: As shown schematically in Figure [5.1](workgeoms.html#fig:ch-05-dplyr-example),
    we will start with our individual-level table of about 2,500 GSS respondents.
    Then we want to summarize them into a new table that shows a count of each religious
    preference, grouped by region. Finally we will turn these within-region counts
    into percentages, where the denominator is the total number of respondents within
    each region. The `dplyr` library provides a few tools to make this easy and clear
    to read. We will use a special operator, `%>%`, to do our work. This is the *pipe*
    operator. It plays the role of the yellow triangle in Figure [5.1](workgeoms.html#fig:ch-05-dplyr-example),
    in that it helps us perform the actions that get us from one table to the next.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 [5.1](workgeoms.html#fig:ch-05-dplyr-example) 所示，我们将从大约 2,500 名 GSS 被调查者的个体级表格开始。然后我们想要将它们汇总到一个新的表格中，该表格显示了按地区分组的每种宗教偏好的计数。最后，我们将这些地区内的计数转换为百分比，分母是每个地区内受访者的总数。`dplyr`
    库提供了一些工具，使这个过程变得简单且易于阅读。我们将使用一个特殊操作符 `%>%` 来完成我们的工作。这是 *管道* 操作符。它在图 [5.1](workgeoms.html#fig:ch-05-dplyr-example)
    中的作用类似于黄色三角形，它帮助我们执行从一张表到另一张表的转换操作。
- en: 'We have being building our plots in an *additive* fashion, starting with a
    `ggplot` object and layering on new elements. By analogy, think of the `%>%` operator
    as allowing us to start with a data frame and perform a *sequence* or *pipeline*
    of operations to turn it into another, usually smaller and more aggregated table.
    Data goes in one side of the pipe, actions are performed via functions, and results
    come out the other. A pipeline is typically a series of operations that do one
    or more of four things:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在以 *累加* 的方式构建我们的图表，从一个 `ggplot` 对象开始，并添加新的元素。通过类比，将 `%>%` 操作符视为允许我们从数据框开始，执行一系列操作，将其转换成另一张表，通常是更小且更聚合的表。数据从管道的一侧进入，通过函数执行操作，结果从另一侧出来。管道通常是一系列操作，执行以下四件事情之一或多个：
- en: '*Group*`group_by()` the data into the nested structure we want for our summary,
    such as “Religion by Region” or “Authors by Publications by Year”.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分组* 使用 `group_by()` 将数据分组到我们想要的汇总的嵌套结构中，例如“按地区划分的宗教”或“按出版物划分的作者按年份”。'
- en: '*Filter*`filter()` rows; `select()` columns or *select* pieces of the data
    by row, column, or both. This gets us the piece of the table we want to work on.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*过滤* 使用 `filter()` 过滤行；`select()` 列或通过行、列或两者来 *选择* 数据的某些部分。这使我们能够得到我们想要工作的表格部分。'
- en: '*Mutate*`mutate()` the data by creating new variables at the *current* level
    of grouping. This adds new columns to the table without aggregating it.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*转换* 使用 `mutate()` 通过在 *当前* 分组级别创建新变量来转换数据。这会在不聚合表格的情况下向表格中添加新列。'
- en: '*Summarize*`summarize()` or aggregate the grouped data. This creates new variables
    at a *higher* level of grouping. For example we might calculate means with `mean()`
    or counts with `n()`. This results in a smaller, summary table, which we might
    do more things on if we want.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*汇总* 使用 `summarize()` 或聚合分组数据。这会在 *更高* 的分组级别创建新变量。例如，我们可能使用 `mean()` 计算平均值或使用
    `n()` 计算计数。这会产生一个更小、更汇总的表格，如果我们想进行更多操作，我们可以使用它。'
- en: We use the `dplyr` functions `group_by()`, `filter()`, `select()`, `mutate()`,
    and `summarize()` to carry out these tasks within our pipeline. They are written
    in a way that allows them to be easily piped. That is, they understand how to
    take inputs from the left side of a pipe operator and pass results along through
    the right side of one. The dplyr documentation has some useful vignettes that
    introduce these grouping, filtering, selection, and transformation functions.
    There is also a more detailed discussion of these tools, along with many more
    examples, in Wickham & Grolemund (2016).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `dplyr` 函数 `group_by()`、`filter()`、`select()`、`mutate()` 和 `summarize()`
    在管道中执行这些任务。它们被编写成易于管道化的方式。也就是说，它们理解如何从管道操作符的左侧获取输入，并通过右侧传递结果。dplyr 文档中包含一些有用的示例，介绍了这些分组、过滤、选择和转换函数。Wickham
    & Grolemund (2016) 中对这些工具进行了更详细的讨论，并提供了许多更多示例。
- en: 'We will create a new table called `rel_by_region`. Here’s the code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `rel_by_region` 的新表格。以下是代码：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What are these lines doing? First, we are creating an object as usual, with
    the familiar assignment operator, `<-`. Next, at the steps to the right. Read
    the objects and functions from left to right, with the pipe operator “`%>%`” connecting
    them together meaning “and then …”. Objects on the left hand side “pass through”
    the pipe, and whatever is specified on the right of the pipe gets done to that
    object. The resulting object then passes through to the right again, and so on
    down to the end of the pipeline.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行在做什么？首先，我们像往常一样使用熟悉的赋值运算符`<-`创建一个对象。接下来，在右侧的步骤中。从左到右读取对象和函数，使用管道运算符“`%>%`”将它们连接起来，意味着“然后……”。左侧的对象“通过”管道，管道右侧指定的内容被应用于该对象。然后结果对象再次通过管道，依此类推，直到管道的末端。
- en: 'Reading from the left, the code says this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右阅读代码，它表示：
- en: 'Create`rel_by_region <- gss_sm %>%` a new object, `rel_by_region`. It will
    get the result of the following sequence of actions: Start with the `gss_sm` data,
    and then'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`rel_by_region <- gss_sm %>%`一个新的对象`rel_by_region`。它将获取以下一系列操作的成果：从`gss_sm`数据开始，然后
- en: Group`group_by(bigregion, religion) %>%` the rows by `bigregion` and, within
    that, by `religion`.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`group_by(bigregion, religion) %>%`对行进行按`bigregion`分组，并在其中按`religion`分组。
- en: 'Summarize this table`summarize(N = n()) %>%` to create a new, much smaller
    table, with three columns: `bigregion`, `religion`, and a new summary variable,
    `N`, that is a count of the number of observations within each religious group
    for each region.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将此表`summarize(N = n()) %>%`汇总以创建一个新的、更小的表格，包含三列：`bigregion`、`religion`和一个新的汇总变量`N`，它是每个地区每个宗教群体内观测数的计数。
- en: 'With this new table, `mutate(freq = N / sum(N), pct = round((freq*100), 0))`
    use the `N` variable to calculate two new columns: the relative proportion (`freq`)
    and percentage (`pct`) for each religious category, still grouped by region. Round
    the results to the nearest percentage point.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这个新表格，`mutate(freq = N / sum(N), pct = round((freq*100), 0))`使用`N`变量计算两个新的列：每个宗教类别的相对比例（`freq`）和百分比（`pct`），仍然按地区分组。将结果四舍五入到最接近的百分点。
- en: In this way of doing things, objects passed along the pipeline and the functions
    acting on them carry some assumptions about their context. For one thing, you
    don’t have to keep specifying the name of the underlying data frame object you
    are working from. Everything is implicitly carried forward from `gss_sm`. Within
    the pipeline, the transient or implicit objects created from your summaries and
    other transformations are carried through, too.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种做事方式中，沿着管道传递的对象以及作用于它们的功能对其上下文有一些假设。首先，你不必始终指定你正在工作的底层数据框对象的名称。所有内容都隐式地从`gss_sm`传递而来。在管道内，从你的摘要和其他转换中创建的临时或隐式对象也会传递下去。
- en: Second, the `group_by()` function sets up how the grouped or nested data will
    be processed within the `summarize()` step. Any function used to create a new
    variable within `summarize()`, such as `mean()` or `sd()` or `n()`, will be applied
    to the *innermost* grouping level first. Grouping levels are named from left to
    right within `group_by()` from outermost to innermost. So the function call `summarize(N
    = n())` counts up the number of observations for each value of `religion` within
    `bigregion` and puts them in a new variable named `N`. As dplyr’s functions see
    things, summarizing actions “peel off” one grouping level at a time, so that the
    resulting summaries are at the next level up. In this case, we start with individual-level
    observations and group them by religion within region. The `summarize()` operation
    aggregates the individual observations to counts of the number of people affiliated
    with each religion, for each region.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，`group_by()`函数设置了在`summarize()`步骤中如何处理分组或嵌套数据。在`summarize()`内创建新变量的任何函数，如`mean()`、`sd()`或`n()`，将首先应用于最内层的分组级别。分组级别从`group_by()`的外层到内层按从左到右命名。因此，函数调用`summarize(N
    = n())`计算`bigregion`内每个`religion`值的观测数，并将它们放入一个名为`N`的新变量中。从dplyr函数的角度来看，汇总操作一次“剥离”一个分组级别，因此生成的汇总是在下一个级别上。在这种情况下，我们以个体级别的观测值开始，并在地区内按宗教进行分组。`summarize()`操作将个体观测值聚合为每个地区每个宗教群体的观察人数。
- en: Third, the `mutate()` step takes the `N` variable and uses it to create `freq`,
    the relative frequency for each subgroup within region, and finally `pct`, the
    relative frequency turned into a rounded percentage. These `mutate()` operations
    add or remove columns from tables, but do not change the grouping level.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，`mutate()`步骤使用`N`变量来创建`freq`，即每个区域内部子组的相对频率，最终转换为四舍五入的百分比`pct`。这些`mutate()`操作会在表中添加或删除列，但不会改变分组级别。
- en: Inside both `mutate()` and `summarize()`, we are able to create new variables
    in a way that we have not seen before. Usually, when we see something like `name
    = value` inside a function, the `name` is a general, named argument and the function
    is expecting information from us about the specific value it should take.As in
    the case of `aes(x = gdpPercap, y = lifeExp)`, for example. Normally if we give
    a function a named argument it doesn’t know about (`aes(chuckles = year)`) it
    will ignore it, complain, or break. With `summarize()` and `mutate()`, however,
    we can invent named arguments. We are still assigning specific values to `N`,
    `freq`, and `pct`, but we pick the names, too. They are the names that the newly-created
    variables in the summary table will have. The `summarize()` and `mutate()` functions
    do not need to know what they will be in advance.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mutate()`和`summarize()`内部，我们能够以我们之前未见过的这种方式创建新变量。通常，当我们在一个函数内部看到类似`name =
    value`的语句时，`name`是一个通用的命名参数，函数期望我们从它那里获取关于特定值的信息。例如，在`aes(x = gdpPercap, y = lifeExp)`的情况下。通常，如果我们给一个函数一个它不认识的命名参数（如`aes(chuckles
    = year)`），它将忽略它、抱怨或崩溃。然而，使用`summarize()`和`mutate()`，我们可以发明命名参数。我们仍然在将特定值分配给`N`、`freq`和`pct`，但我们也在选择名称。这些名称是新创建的汇总表变量的名称。`summarize()`和`mutate()`函数不需要提前知道它们将是什么。
- en: Finally, when we use `mutate()` to create the `freq` variable, not only can
    we make up that name within the function, `mutate()` is also clever enough to
    let us *use* that name right away, on the next line of the same function call,
    when we create the `pct` variable. This means we do not have to repeatedly write
    separate `mutate()` calls for every new variable we want to create.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们使用`mutate()`创建`freq`变量时，不仅可以在函数内部指定该名称，`mutate()`还足够聪明，允许我们在同一函数调用的下一行立即使用该名称来创建`pct`变量。这意味着我们不需要为每个新创建的变量重复编写单独的`mutate()`调用。
- en: 'Our pipeline takes the `gss_sm` data frame, which has 2867 rows and 32 columns,
    and transforms it into `rel_by_region`, a summary table with 24 rows and 5 columns
    that looks like this, in part:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的流程将`gss_sm`数据框（包含2867行和32列）转换成`rel_by_region`，这是一个包含24行和5列的汇总表，部分如下所示：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The variables specified in `group_by()` are retained in the new summary table;
    the variables created with `summarize()` and `mutate()` are added, and all the
    other variables in the original dataset are dropped.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`group_by()`中指定的变量保留在新汇总表中；使用`summarize()`和`mutate()`创建的变量被添加，而原始数据集中的所有其他变量都被删除。
- en: We said before that, when trying to grasp what each additive step in a `ggplot()`
    sequence does, it can be helpful to work backwards, removing one piece at a time
    to see what the plot looks like when that step is not included. In the same way,
    when looking at pipelined code it can be helpful to start from the end of the
    line, and then remove one “`%>%`” step at a time to see what the resulting intermediate
    object looks like. For instance, what if we remove the `mutate()` step from the
    code above? What does `rel_by_region` look like then? What if we remove the `summarize()`
    step? How big is the table returned at each step? What level of grouping is it
    at? What variables have been added or removed?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前说过，在尝试理解`ggplot()`序列中的每个附加步骤的作用时，逆向工作，一次移除一个部分，看看当该步骤不包括时图表看起来如何，可能会有所帮助。同样，在查看管道代码时，从行的末尾开始，一次移除一个“`%>%`”步骤，看看结果中间对象看起来如何，可能会有所帮助。例如，如果我们从上面的代码中移除`mutate()`步骤会怎样？`rel_by_region`看起来会怎样？如果我们移除`summarize()`步骤呢？每一步返回的表有多大？它处于什么分组级别？添加或删除了哪些变量？
- en: 'Plots that do not require sequential aggregation and transformation of the
    data before they are displayed are usually easy to write directly in ggplot, as
    the details of the layout are handled by a combination of mapping variables and
    layering geoms. One-step filtering or aggregation of the data (such as calculating
    a proportion, or a specific subset of observations) is also straightforward. But
    when the result we want to display is several steps removed from the data, and
    in particular when we want to group or aggregate a table and do some more calculations
    on the result before drawing anything, then it can make sense to use dplyr’s tools
    to produce these summary tables first. This is true even if would also be possible
    to do it within a `ggplot()` call. In addition to making our code easier to read,
    it lets us more easily perform sanity checks on our results, so that we are sure
    we have grouped and summarized things in the right order. For instance, if we
    have done things properly with `rel_by_region`, the `pct` values associated with
    `religion` should sum to 100 within each region, perhaps with a bit of rounding
    error. We can quickly check this using a very short pipeline, too:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要在对数据进行显示前的顺序聚合和转换的图表通常可以直接在ggplot中编写，因为布局的细节是由映射变量和层叠几何的组合来处理的。对数据进行一步过滤或聚合（如计算比例或特定观察子集）也很直接。但是，当我们想要显示的结果与数据相隔几个步骤，尤其是当我们想要对表格进行分组或聚合并在绘制任何内容之前进行一些计算时，使用dplyr的工具来首先生成这些汇总表是有意义的。即使也可以在`ggplot()`调用内完成，这也是正确的。除了使我们的代码更容易阅读外，它还让我们更容易对我们的结果进行合理性检查，以确保我们以正确的顺序对事物进行了分组和汇总。例如，如果我们正确地使用了`rel_by_region`，与`religion`相关的`pct`值在每个区域内应该总和为100，可能有一些舍入误差。我们可以使用一个非常短的管道快速检查这一点：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This looks good. As before, now that we are working directly with percentage
    values in a summary table, we can use `geom_col()` instead of `geom_bar()`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不错。像之前一样，现在我们直接在汇总表中使用百分比值，我们可以使用`geom_col()`而不是`geom_bar()`。
- en: '![Religious preferences by Region.](../Images/215092b752bc49a696e9556855685408.png)
    Figure 5.2: Religious preferences by Region.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![按地区划分的宗教偏好。](../Images/215092b752bc49a696e9556855685408.png) 图5.2：按地区划分的宗教偏好。'
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We use a different `position` argument here, `dodge2` instead of `dodge`. This
    puts the bars side by side. When dealing with pre-computed values in `geom_col()`,
    the default `position` is to make a proportionally stacked column chart. If you
    use `dodge` they will be stacked within columns but the result will read incorrectly.
    Using `dodge2` puts the sub-categories (religious affiliations) side-by-side within
    groups (regions).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了一个不同的`position`参数，`dodge2`而不是`dodge`。这使条形并排放置。当处理`geom_col()`中的预计算值时，默认的`position`是制作一个成比例堆叠的柱状图。如果你使用`dodge`，它们将在列内堆叠，但结果将读起来不正确。使用`dodge2`将子类别（宗教归属）在组（地区）内并排放置。
- en: The values in this bar chart are the percentage equivalents to the stacked counts
    in Figure [4.10](groupfacettx.html#fig:ch-04-gss-06). Religious affiliations sum
    to 100 percent within region. The trouble is, although we now know how to cleanly
    produce frequency tables, this is still a bad figure. It is too crowded, with
    too many bars side-by-side. We can do better.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此条形图中的数值是图[4.10](groupfacettx.html#fig:ch-04-gss-06)中堆叠计数百分比等价。宗教归属在区域内总和为100%。问题是，尽管我们现在知道如何干净地生成频率表，但这仍然是一个糟糕的图表。它太拥挤了，有很多条形并排在一起。我们可以做得更好。
- en: As a rule, dodged charts can be more cleanly expressed as faceted plots. This
    removes the need for a legend, and thus makes the chart simpler to read. We also
    introduce a new function. If we map religion to the x-axis, the labels will overlap
    and become illegible. It’s possible to manually adjust the tick mark labels so
    that they are printed at an angle, but that isn’t so easy to read, either. It
    makes more sense to put the religions on the y-axis and the percent scores on
    the x-axis. Because of the way `geom_bar()` works internally, simply swapping
    the `x` and `y` mapping will not work. (Try it and see what happens.) What we
    do instead is to transform the *coordinate system* that the results are plotted
    in, so that the x and y axes are flipped. We do this with `coord_flip()`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，跳过图表可以更清晰地表达为分面图。这样可以消除对图例的需求，从而使图表更易于阅读。我们还引入了一个新功能。如果我们把宗教映射到x轴，标签将重叠并变得难以辨认。手动调整刻度标签以使其以角度打印是可能的，但这也不容易阅读。将宗教放在y轴上，百分比得分放在x轴上更有意义。由于`geom_bar()`内部的工作方式，简单地交换`x`和`y`映射将不起作用。（试一试看看会发生什么。）我们采取的做法是转换结果所绘制的*坐标系*，使x轴和y轴颠倒。我们使用`coord_flip()`来实现这一点。
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Religious preferences by Region, faceted version.](../Images/004dec05a264c8e45176131cd621f9b9.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![按地区划分的宗教偏好，分面版本。](../Images/004dec05a264c8e45176131cd621f9b9.png)'
- en: 'Figure 5.3: Religious preferences by Region, faceted version.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：按地区划分的宗教偏好，分面版本。
- en: For most plots the coordinate system is cartesian, showing plots on a plane
    defined by an x-axis and a y-axis. The `coord_cartesian()` function manages this,
    but we don’t need to call it. The `coord_flip()` function switches the x and y
    axes after the plot is made. It does not remap variables to aesthetics. In this
    case, `religion` is still mapped to `x` and `pct` to `y`. Because the religion
    names do not need an axis label to be understood, we set `x = NULL` in the `labs()`
    call.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数图表，坐标系是笛卡尔坐标系，在由x轴和y轴定义的平面上显示图表。`coord_cartesian()`函数管理这一点，但我们不需要调用它。`coord_flip()`函数在绘制图表后切换x轴和y轴。它不会重新映射变量到美学。在这种情况下，`religion`仍然映射到`x`，`pct`映射到`y`。由于宗教名称不需要轴标签就能理解，我们在`labs()`调用中设置`x
    = NULL`。
- en: We will see more of what dplyr’s grouping and filtering operations can do later.
    It is a flexible and powerful framework. For now, think of it as a way to quickly
    summarize tables of data without having to write code in the body of our `ggplot()`
    or `geom_` functions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后看到dplyr的分组和过滤操作能做什么。它是一个灵活且强大的框架。现在，将其视为一种快速总结数据表的方法，而无需在我们的`ggplot()`或`geom_`函数的主体中编写代码。
- en: 5.2 Continuous variables by group or category
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 按组或类别划分的连续变量
- en: Let’s move to a new dataset, the `organdata` table. Like `gapminder`, it has
    a country-year structure. It contains a little more than a decade’s worth of information
    on the donation of organs for transplants in seventeen OECD countries. The organ
    procurement rate is a measure of the number of human organs obtained from cadaver
    organ donors for use in transplant operations. Along with this donation data,
    the dataset has a variety of numerical demographic measures, and several categorical
    measures of health and welfare policy and law. Unlike the `gapminder` data, some
    observations are missing. These are designated with a value of `NA`, R’s standard
    code for missing data. The `organdata` table is included in the `socviz` library.
    Load it up and take a quick look. Instead of using `head()`, for variety this
    time we will make a short pipeline to select the first six columns of the dataset,
    and then pick five rows at random using a function called `sample_n()`. This function
    takes two main arguments. First we provide the table of data we want to sample
    from. Because we are using a pipeline, this is implicitly passed down from the
    beginning of the pipe. Then we supply the number of draws we want to make.Using
    numbers this way in `select()` chooses the numbered columns of the data frame.
    You can also select variable names directly.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到一个新的数据集，即`organdata`表。就像`gapminder`一样，它具有国家-年份结构。它包含17个经合组织国家器官移植捐赠信息超过十年的数据。器官采购率是衡量用于移植手术的遗体器官捐赠者获得的人体器官数量的指标。除了捐赠数据外，该数据集还包含各种数值人口统计指标，以及健康和福利政策与法律的几个分类指标。与`gapminder`数据不同，一些观测值缺失。这些观测值被指定为`NA`，这是R中缺失数据的标准代码。`organdata`表包含在`socviz`库中。加载它并快速查看。这次我们不用`head()`，为了变化，我们将创建一个简短的管道来选择数据集的前六列，然后使用名为`sample_n()`的函数随机选择五行。这个函数有两个主要参数。首先，我们提供我们想要从中抽取数据的表格。因为我们使用的是管道，所以这隐式地从管道的开始传递下来。然后我们提供我们想要抽取的抽取次数。在`select()`中使用这种方式选择数字，可以选择数据框的编号列。你也可以直接选择变量名。
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Lets’s start by naively graphing some of the data. We can take a look at a scatterplot
    of donors vs year.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先天真地绘制一些数据。我们可以查看捐赠者与年份的散点图。
- en: '![Not very informative.](../Images/8a6a1259ee0fd826e0f9513be05f79d3.png) Figure
    5.4: Not very informative.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![信息量不大。](../Images/8a6a1259ee0fd826e0f9513be05f79d3.png) 图5.4：信息量不大。'
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A message from ggplot warns you about the missing values. We’ll suppress this
    warning from now on, so that it doesn’t clutter the output, but in general it’s
    wise to read and understand the warnings that R gives, even when code appears
    to run properly. If there are a large number of warnings, R will collect them
    all and invite you to view them with the `warnings()` function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ggplot发出了一条关于缺失值的警告。从现在起，我们将抑制此警告，以免输出混乱，但一般来说，阅读和理解R给出的警告是明智的，即使代码看起来运行正常。如果有大量警告，R将收集它们，并邀请你使用`warnings()`函数查看它们。
- en: We could use `geom_line()` to plot each country’s time series, like we did with
    the gapminder data. To do that, remember, we need to tell ggplot what the grouping
    variable is. This time we can also facet the figure by country, as we do not have
    too many of them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`geom_line()`来绘制每个国家的时间序列，就像我们在gapminder数据中做的那样。要做到这一点，记住，我们需要告诉ggplot分组变量是什么。这次我们也可以按国家分面图，因为我们没有太多国家。
- en: '![A faceted line plot.](../Images/2b99e6558ebdda27d7c48cbb953eb8fa.png) Figure
    5.5: A faceted line plot.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![一个分面线图。](../Images/2b99e6558ebdda27d7c48cbb953eb8fa.png) 图5.5：一个分面线图。'
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By default the facets are ordered alphabetically by country. We will see how
    to change this momentarily.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，分面图是按国家字母顺序排序的。我们将稍后展示如何更改这一点。
- en: Let’s focus on the country-level variation, but without paying attention to
    the time trend. We can use `geom_boxplot()` to get a picture of variation by year
    across countries. Just as `geom_bar()` by default calculates a count of observations
    by the category you map to `x`, the `stat_boxplot()` function that works with
    `geom_boxplot()` will calculate a number of statistics that allow the box and
    whiskers to be drawn. We tell `geom_boxplot()` the variable we want to categorize
    by (here, `country`) and the continuous variable we want summarized (here, `donors`)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于国家层面的变化，但不要关注时间趋势。我们可以使用`geom_boxplot()`来获取各国按年份变化的分布图。就像`geom_bar()`默认情况下根据你映射到`x`的类别计算观测值的计数一样，与`geom_boxplot()`一起工作的`stat_boxplot()`函数将计算一些统计量，这些统计量允许绘制箱线和胡须。我们告诉`geom_boxplot()`我们想要按什么变量分类（在这里，`country`）和想要总结的连续变量（在这里，`donors`）
- en: '![A first attempt at boxplots by country.](../Images/e451458bc9c750df1e711b18dbf06767.png)
    Figure 5.6: A first attempt at boxplots by country.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![按国家尝试的第一次箱线图。](../Images/e451458bc9c750df1e711b18dbf06767.png) 图5.6：按国家尝试的第一次箱线图。'
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The boxplots look interesting but two issues could be addressed. First, as we
    saw in the previous chapter, it is awkward to have the country names on the x-axis
    because the labels will overlap. We use `coord_flip()` again to switch the axes
    (but not the mappings).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 箱线图看起来很有趣，但有两个问题可以解决。首先，正如我们在上一章中看到的，在x轴上有国家名称是不方便的，因为标签会重叠。我们再次使用`coord_flip()`来切换轴（但不切换映射）。
- en: '![Moving the countries to the y-axis.](../Images/3b584e8c67dab2c11385972d18069b5f.png)
    Figure 5.7: Moving the countries to the y-axis.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![将国家移动到y轴。](../Images/3b584e8c67dab2c11385972d18069b5f.png) 图5.7：将国家移动到y轴。'
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'That’s more legible but still not ideal. We generally want our plots to present
    data in some meaningful order. An obvious way is to have the countries listed
    from high to low average donation rate. We accomplish this by reordering the `country`
    variable by the mean of `donors.` The `reorder()` function will do this for us.
    It takes two required arguments. The first is the categorical variable or factor
    that we want to reorder. In this case, that’s `country`. The second is the variable
    we want to reorder it by. Here that is the donation rate, `donors`. The third
    and optional argument to `reorder()` is the function you want to use as a summary
    statistic. If you only give `reorder()` the first two required arguments, then
    by default it will reorder the categories of your first variable by the mean value
    of the second. You can name any sensible function you like to reorder the categorical
    variable (e.g., `median`, or `sd`). There is one additional wrinkle. In R, the
    default `mean` function will fail with an error if there are missing values in
    the variable you are trying to take the average of. You must say that it is OK
    to remove the missing values when calculating the mean. This is done by supplying
    the `na.rm=TRUE` argument to `reorder()`, which internally passes that argument
    on to `mean()`. We are reordering the variable we are mapping to the `x` aesthetic,
    so we use `reorder()` at that point in our code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这样看起来更易读，但仍然不是理想的。我们通常希望我们的图表以某种有意义的方式呈现数据。一个明显的方法是将国家按平均捐赠率从高到低列出。我们通过按`donors`的平均值重新排序`country`变量来实现这一点。`reorder()`函数会为我们完成这项工作。它需要两个必需的参数。第一个是我们想要重新排序的分类变量或因子。在这种情况下，那就是`country`。第二个是我们想要按其重新排序的变量。这里就是捐赠率，`donors`。`reorder()`的第三个和可选参数是你想要用作汇总统计函数的函数。如果你只给`reorder()`提供前两个必需参数，那么默认情况下，它将按第二个变量的平均值重新排序第一个变量的类别。你可以命名任何合理的函数来重新排序分类变量（例如，`median`或`sd`）。还有一个额外的细节。在R中，如果变量中有缺失值，默认的`mean`函数将因错误而失败。你必须说明在计算平均值时可以删除缺失值。这是通过向`reorder()`提供`na.rm=TRUE`参数来完成的，该参数内部将此参数传递给`mean()`。我们正在重新排序映射到`x`美学的变量，因此我们在代码中使用`reorder()`：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Boxplots reordered by mean donation rate.](../Images/303d95e0edeba02ff11d09e70bc320f9.png)
    Figure 5.8: Boxplots reordered by mean donation rate.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![按平均捐赠率重新排序的箱线图。](../Images/303d95e0edeba02ff11d09e70bc320f9.png) 图5.8：按平均捐赠率重新排序的箱线图。'
- en: Because it’s obvious what the country names are, in the `labs()` call we set
    their axis label to empty with `labs(x=NULL)`. Ggplot offers some variants on
    the basic boxplot, including the violin plot. Try it with `geom_violin()`. There
    are also numerous arguments that control the finer details of the boxes and whiskers,
    including their width. Boxplots can also take `color` and `fill` aesthetic mappings
    like other geoms.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因为国家名称很明显，在`labs()`调用中，我们将它们的轴标签设置为空，使用`labs(x=NULL)`。Ggplot提供了基本的箱线图的一些变体，包括小提琴图。尝试使用`geom_violin()`。还有许多参数可以控制箱子和胡须的更精细的细节，包括它们的宽度。箱线图也可以像其他几何对象一样接受`color`和`fill`美学映射。
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Figure 5.9: A boxplot with the fill aesthetic mapped.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9：一个将填充美学映射到箱线图上的箱线图。
- en: '![A boxplot with the fill aesthetic mapped.](../Images/0ec40145582f9a93b39249c1a11f8e55.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![一个将填充美学映射到箱线图上的箱线图。](../Images/0ec40145582f9a93b39249c1a11f8e55.png)'
- en: Putting categorical variables on the y-axis to compare their distributions is
    a very useful trick. Its makes it easy to effectively present summary data on
    more categories. The plots can be quite compact and fit a relatively large number
    of cases in by row. The approach also has the advantage of putting the variable
    being compared onto the x-axis, which sometimes makes it easier to compare across
    categories. If the number of observations within each categoriy is relatively
    small, we can skip (or supplement) the boxplots and show the individual observations,
    too. In this next example we map the `world` variable to `color` instead of `fill`
    as the default `geom_point()` plot shape has a color attribute, but not a fill.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将分类变量放在 y 轴上以比较它们的分布是一个非常实用的技巧。这使得在更多类别上有效地展示总结数据变得容易。这些图可以相当紧凑，并且可以通过行来容纳相对大量的案例。这种方法的优势在于将比较的变量放在
    x 轴上，这有时会使得跨类别比较更容易。如果每个类别中的观察值数量相对较小，我们可以跳过（或补充）箱线图，并显示个别观察值。在下一个例子中，我们将 `world`
    变量映射到 `color` 而不是 `fill`，因为默认的 `geom_point()` 图形形状有一个颜色属性，但没有填充属性。
- en: '![Using points instead of a boxplot.](../Images/ee3d7de1c71b47df463cd41a77952b9e.png)
    Figure 5.10: Using points instead of a boxplot.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用点而不是箱线图。](../Images/ee3d7de1c71b47df463cd41a77952b9e.png) 图 5.10：使用点而不是箱线图。'
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When we use `geom_point()` like this, there is some overplotting of observations.
    In these cases, it can be useful to perturb the data just a little bit in order
    to get a better sense of how many observations there are at different values.
    We use `geom_jitter()` to do this. This geom works much like `geom_point()`, but
    randomly nudges each observation by a small amount.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们像这样使用 `geom_point()` 时，观察值会有一些重叠。在这些情况下，稍微扰动一下数据可能会有助于更好地了解在不同值上有多少观察值。我们使用
    `geom_jitter()` 来做这件事。这个 geom 与 `geom_point()` 非常相似，但它会随机将每个观察值微调一小段距离。
- en: '![Jittering the points.](../Images/bc484a1d7342a9dabffc983284087891.png) Figure
    5.11: Jittering the points.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![抖动点。](../Images/bc484a1d7342a9dabffc983284087891.png) 图 5.11：抖动点。'
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The default amount of jitter is a little too much for our purposes. We can control
    it using `height` and `width` arguments to a `position_jitter()` function within
    the geom. Because we’re making a one-dimensional summary here, we just need `width`.Can
    you see why we did not use height? If not, try it and see what happens.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的抖动量对于我们的目的来说有点太多。我们可以通过在 geom 中的 `position_jitter()` 函数中使用 `height` 和 `width`
    参数来控制它。因为我们在这里制作的是一维总结，所以我们只需要 `width`。你能看出我们为什么没有使用 `height` 吗？如果不能，试着做一下，看看会发生什么。
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Figure 5.12: A jittered plot.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12：一个抖动图。
- en: '![A jittered plot.](../Images/3962f4a2a83430505c2d11a495b5584b.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![一个抖动图。](../Images/3962f4a2a83430505c2d11a495b5584b.png)'
- en: When we want to summarize a categorical variable that just has one point per
    category, we should use this approach as well. The result will be a Cleveland
    dotplot, a simple and extremely effective method of presenting data that is usually
    better than either a bar chart or a table. For example, we can make a Cleveland
    dotplot of the average donation rate.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要总结一个每个类别只有一个点的分类变量时，我们也应该使用这种方法。结果将是一个克利夫兰点图，这是一种简单且极其有效的数据展示方法，通常比条形图或表格都要好。例如，我们可以制作一个平均捐赠率的克利夫兰点图。
- en: 'This also gives us another opportunity to do a little bit of data munging with
    a dplyr pipeline. We will use one to aggregate our larger country-year data frame
    to a smaller table of summary statistics by country. There is more than one way
    to do pipeline this task. We could choose the variables we want to summarize and
    then repeatedly use the `mean()` and `sd()` functions to calculate the means and
    standard deviations of the variables we want. We will again use the pipe operator,
    `%>%`, to do our work:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这也给了我们另一个机会使用 dplyr 管道进行一些数据整理。我们将使用一个管道来将较大的国家-年数据框聚合到一个较小的按国家汇总统计的表中。完成这个任务的方法不止一种。我们可以选择我们想要汇总的变量，然后反复使用
    `mean()` 和 `sd()` 函数来计算我们想要的变量的平均值和标准差。我们再次使用管道操作符 `%>%` 来完成我们的工作：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The pipeline consists of two steps. First we group the data by `consent_law`
    and `country`, and then use `summarize()` to create six new variables, each one
    of which is the mean or standard deviation of each country’s score on a corresponding
    variable in the original `organdata` data frame.For an alternative view, change
    `country` to `year` in the grouping statement and see what happens.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 管道由两个步骤组成。首先，我们按 `consent_law` 和 `country` 对数据进行分组，然后使用 `summarize()` 创建六个新变量，每个变量都是每个国家在原始
    `organdata` 数据框中相应变量的平均值或标准差。为了获得不同的视角，在分组语句中将 `country` 改为 `year`，看看会发生什么。
- en: 'As usual, `summarize()` step, will inherit information about the original data
    and the grouping, and then do its calculations at the innermost grouping level.
    In this case it takes all the observations for each country and calculates the
    mean or standard deviation as requested. Here is what the resulting object looks
    like:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，`summarize()` 步骤将继承有关原始数据和分组的信息，然后在最内层的分组级别上进行计算。在这种情况下，它为每个国家取所有观测值，并按请求计算平均值或标准差。以下是结果对象的外观：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As before, the variables specified in `group_by()` are retained in the new data
    frame, the variables created with `summarize()` are added, and all the other variables
    in the original data are dropped. The countries are also summarized alphabetically
    within `consent_law`, which was the outermost grouping variable in the `group_by()`
    statement at the start of the pipeline.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，`group_by()` 中指定的变量保留在新数据框中，使用 `summarize()` 创建的变量被添加，原始数据中的所有其他变量都被删除。国家也在
    `consent_law` 中按字母顺序汇总，这是管道开始时 `group_by()` 语句中最外层的分组变量。
- en: Using our pipeline this way is reasonable, but the code is worth looking at
    again. For one thing, we have to repeatedly type out the names of the `mean()`
    and `sd()` functions and give each of them the name of the variable we want summarized
    *and* the `na.rm = TRUE` argument each time to make sure the functions don’t complain
    about missing values. We also repeatedly name our new summary variables in the
    same way, by adding `_mean` or `_sd` to the end of the original variable name.
    If we wanted to calculate the mean and standard deviation for all the numerical
    variables in `organdata`, our code would get even longer. Plus, in this version
    we lose the other, time-invariant categorical variables that we haven’t grouped
    by, such as `world`. When we see repeated actions like this in our code, we can
    ask whether there’s a better way to proceed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用我们的管道是合理的，但代码值得再次审视。一方面，我们必须反复输入 `mean()` 和 `sd()` 函数的名称，并且每次都要为每个函数提供我们想要汇总的变量的名称以及
    `na.rm = TRUE` 参数，以确保函数不会对缺失值发出抱怨。我们同样反复以相同的方式命名我们的新汇总变量，即在原始变量名称的末尾添加 `_mean`
    或 `_sd`。如果我们想计算 `organdata` 中所有数值变量的平均值和标准差，我们的代码将会更长。此外，在这个版本中，我们失去了我们未按其分组的其他时间不变的分类变量，例如
    `world`。当我们看到代码中这种重复的操作时，我们可以问自己是否有更好的处理方式。
- en: 'There is. What we would like to do is apply the `mean()` and `sd()` functions
    to every numerical variable in `organdata`, but *only* the numerical ones. Then
    we want to name the results in a consistent way, and return a summary table including
    all the categorical variables like `world`. We can create a better version of
    the `by_country` object using a little bit of R’s functional programming abilities.
    Here is the code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 确实有。我们想要做的是将 `mean()` 和 `sd()` 函数应用于 `organdata` 中的每个数值变量，但**仅**是数值变量。然后我们希望以一致的方式命名结果，并返回一个包括所有分类变量（如
    `world`）的汇总表。我们可以使用一点 R 的函数式编程能力来创建一个更好的 `by_country` 对象版本。以下是代码：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The pipeline starts off just as before, taking `organdata` and then grouping
    it by `consent_law` and `country`. In the next step, though, instead of manually
    taking the mean and standard deviation of a subset of variables, we use the `summarize_if()`
    function instead. As its name suggests, it examines each column in our data and
    applies a test to it. It only summarizes if the test is passed, that is, if it
    returns a value of `TRUE`.We do not have to use parentheses when naming the functions
    inside `summarize_if()`. Here the test is the function `is.numeric()`, which looks
    to see if a vector is a numeric value or not. If it is, then `summarize_if()`
    will apply the summary function or functions we want to `organdata`. Because we
    are taking both the mean and the standard deviation, we use `funs()` to list the
    functions we want to use. And we finish with the `na.rm = TRUE` argument, which
    will be passed on to each use of both `mean()` and `sd()`. In the last step in
    the pipeline we `ungroup()` the dataSometimes graphing functions can get confused
    by grouped tibbles where we don’t explicitly use the groups in the plot., so that
    the result is a plain tibble.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 管道开始的方式和之前一样，先取 `organdata`，然后按 `consent_law` 和 `country` 进行分组。然而，在下一步中，我们不是手动取变量子集的均值和标准差，而是使用
    `summarize_if()` 函数。正如其名称所暗示的，它检查我们数据中的每一列，并对它进行测试。只有当测试通过时，即返回值为 `TRUE` 时，它才会进行汇总。我们不需要在
    `summarize_if()` 内部命名函数时使用括号。这里的测试是函数 `is.numeric()`，它检查一个向量是否是数值值。如果是，那么 `summarize_if()`
    将应用我们想要的汇总函数或函数到 `organdata`。因为我们同时取均值和标准差，所以我们使用 `funs()` 列出我们想要使用的函数。并且我们以 `na.rm
    = TRUE` 参数结束，这个参数将被传递给 `mean()` 和 `sd()` 的每次使用。在管道的最后一步中，我们 `ungroup()` 数据，有时绘图函数会混淆分组
    tibbles，其中我们没有在图中明确使用组，所以结果是普通的 tibble。
- en: 'Here is what the pipeline returns:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是管道返回的内容：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'All the numeric variables have been summarized. They are named using the original
    variable, with the function’s name appended: `donors_mean` and `donors_sd`, and
    so on. This is a compact way to rapidly transform our data in various ways. There
    is a family of `summarize_` functions for various tasks, and a complementary group
    of `mutate_` functions for when we want to add columns to the data rather than
    aggregated it.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数值变量都已汇总。它们使用原始变量名，并附加函数名来命名：`donors_mean` 和 `donors_sd` 等。这是一种快速以各种方式转换我们数据的紧凑方式。有一系列
    `summarize_` 函数用于各种任务，以及一组互补的 `mutate_` 函数，用于当我们想要向数据中添加列而不是聚合它时。
- en: With our data summarized by country, we can draw a dotplot with `geom_point()`.
    Let’s also color the results by the consent law for each country.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按国家汇总我们的数据，我们可以使用 `geom_point()` 绘制散点图。让我们也根据每个国家的同意法来着色结果。
- en: '![A Cleveland dotplot, with colored points.](../Images/54fe19bef527864af0679a092193b9cc.png)
    Figure 5.13: A Cleveland dotplot, with colored points.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![克利夫兰散点图，带有彩色点。](../Images/54fe19bef527864af0679a092193b9cc.png) 图 5.13：克利夫兰散点图，带有彩色点。'
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Alternatively, if we liked, we could use a facet instead of coloring the points.
    Using `facet_wrap()` we can split the `consent_law` variable into two panels,
    and then rank the countries by donation rate within each panel. Because we have
    a categorical variable on our y-axis, there are two wrinkles worth noting. First,
    if we leave `facet_wrap()` to its defaults, the panels will be plotted side by
    side. This will make it difficult to compare the two groups on the same scale.
    Instead the plot will be read left to right, which is not useful. To avoid this,
    we will have the panels appear one on top of the other by saying we only want
    toq have one column. This is the `ncol=1` argument. Second, and again because
    we have a categorical variable on the y-axis, the default facet plot will have
    the names of every country appear on the y-axis of *both* panels. (Were the y-axis
    a continuous variable this would be the what we would want.) In that case, only
    half the rows in each panel of our plot will have points in them.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们愿意，我们可以使用面版而不是着色点。使用 `facet_wrap()`，我们可以将 `consent_law` 变量拆分为两个面板，然后在每个面板内按捐赠率对国家进行排名。因为我们
    y 轴上有一个分类变量，有两个值得注意的细节。首先，如果我们让 `facet_wrap()` 保持默认设置，面板将并排绘制。这将使得比较同一尺度上的两组变得困难。相反，图表将从左到右读取，这并不有用。为了避免这种情况，我们将通过说我们只想有一个列来让面板一个接一个地出现。这是
    `ncol=1` 参数。其次，再次因为我们在 y 轴上有一个分类变量，默认的面版图将在两个面板的 y 轴上显示每个国家的名称。（如果 y 轴是一个连续变量，这将是我们想要的。）在这种情况下，每个面板的每一行中只有一半的行会有点。
- en: To avoid this we allow the y-axes scale to be free. This is the `scales="free_y"`
    argument. Again, for faceted plots where both variables are continuous, we generally
    do not want the scales to be free, because it allows the x- or y-axis for each
    panel to vary with the range of the data inside that panel only, instead of the
    range across the whole dataset. Ordinarily, the point of small-multiple facets
    is to be able to compare across the panels. This means free scales are usually
    not a good idea, because each panel gets its own x- or y-axis range, which breaks
    comparability. But where one axis is categorical, as here, we can free the categorical
    axis and leave the continuous one fixed. The result is that each panel shares
    the same x-axis, and it is easy to compare between them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们允许 y 轴的刻度是自由的。这是 `scales="free_y"` 参数。同样，对于具有两个连续变量的分面图，我们通常不希望刻度是自由的，因为这允许每个面板的
    x 或 y 轴仅根据该面板内部的数据范围变化，而不是整个数据集的范围。通常，小多倍分面图的目的是能够在面板之间进行比较。这意味着自由刻度通常不是一个好主意，因为每个面板都得到自己的
    x 或 y 轴范围，这破坏了可比性。但是，当一个轴是分类的，就像这里一样，我们可以使分类轴自由，而将连续轴固定。结果是每个面板共享相同的 x 轴，并且它们之间很容易进行比较。
- en: '![A faceted dotplot with free scales on the y-axis.](../Images/f23ad812ec7dc45c1eb758591a5bc983.png)
    Figure 5.14: A faceted dotplot with free scales on the y-axis.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![一个具有自由 y 轴刻度的分面点图。](../Images/f23ad812ec7dc45c1eb758591a5bc983.png) 图 5.14：一个具有自由
    y 轴刻度的分面点图。'
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Cleveland dotplots are generally preferred to bar or column charts. When making
    them, put the categories on the y-axis and order them in the way that is most
    relevant to the numerical summary you are providing. This sort of plot is also
    an excellent way to summarize model results or any data with with error ranges.
    We use `geom_point()` to draw our dotplots. There is a geom called `geom_dotplot()`,
    but it is designed to produce a different sort of figure. It is a kind of histogram,
    with individual observations represented by dots that are then stacked on top
    of one another to show how many of them there are.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 克利夫兰点图通常比条形图或柱状图更受欢迎。在制作它们时，将类别放在 y 轴上，并按与您提供的数值摘要最相关的顺序排列。这种图表也是总结模型结果或任何带有误差范围的数据的绝佳方式。我们使用
    `geom_point()` 来绘制点图。有一个名为 `geom_dotplot()` 的几何对象，但它旨在生成不同类型的图形。它是一种直方图，通过将单个观测值表示为点，并将这些点堆叠在一起以显示它们的数量。
- en: The Cleveland-style dotplot can be extended to cases where we want to include
    some information about variance or error in the plot. Using `geom_pointrange()`,
    we can tell ggplot to show us a point estimate and a range around it. Here we
    will use the standard deviation of the donation rate that we calculated above.
    But this is also the natural way to present, for example, estimates of model coefficients
    with confidence intervals. With `geom_pointrange()` we map our `x` and `y` variables
    as usual, but the function needs a little more information than `geom_point`.
    It needs to know the range of the line to draw on either side of the point, defined
    by the arguments `ymax` and `ymin`. This is given by the y value (`donors_mean`)
    plus or minus its standard deviation (`donors_sd`). If a function argument expects
    a number, it is OK to give it a mathematical expression that resolves to the number
    you want. R will calculate the result for you.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 克利夫兰风格的点图可以扩展到我们需要在图中包含一些关于方差或误差信息的情形。使用 `geom_pointrange()`，我们可以告诉 ggplot 显示一个点估计及其周围的范围。在这里，我们将使用我们上面计算出的捐赠率的平均值的标准差。但这也是以自然的方式呈现，例如，带有置信区间的模型系数估计的方法。使用
    `geom_pointrange()`，我们像往常一样映射 `x` 和 `y` 变量，但该函数需要比 `geom_point()` 更多一点的信息。它需要知道在点两侧绘制线的范围，由
    `ymax` 和 `ymin` 参数定义。这是由 y 值（捐赠者平均值）加上或减去其标准差（捐赠者标准差）给出的。如果一个函数参数期望一个数字，你可以给它一个数学表达式，该表达式解析为所需的数字。R
    会为你计算结果。
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Figure 5.15: A dot-and-whisker plot, with the range defined by the standard
    deviation of the measured variable.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15：一个点-须图，其范围由测量变量的标准差定义。
- en: '![A dot-and-whisker plot, with the range defined by the standard deviation
    of the measured variable.](../Images/952e4fd0cb72b9c57a8b9aa4a0a54573.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![一个点-须图，其范围由测量变量的标准差定义。](../Images/952e4fd0cb72b9c57a8b9aa4a0a54573.png)'
- en: Because `geom_pointrange()` expects `y`, `ymin`, and `ymax` as arguments, we
    map `donors_mean` to `y` and the `ccode` variable to `x`, then flip the axes at
    the end with `coord_flip()`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `geom_pointrange()` 期望 `y`、`ymin` 和 `ymax` 作为参数，所以我们把 `donors_mean` 映射到 `y`，把
    `ccode` 变量映射到 `x`，然后在最后使用 `coord_flip()` 翻转坐标轴。
- en: 5.3 Plot text directly
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 直接绘制图表文本
- en: It can sometimes be useful to plot the labels along with the points in a scatterplot,
    or just plot informative labels directly. We can do this with `geom_text()`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在散点图中将标签与点一起绘制，或者直接绘制信息标签，这可能会很有用。我们可以使用`geom_text()`来实现这一点。
- en: '![Plotting labels and text.](../Images/98e62e9b42d105ddde8909e3548704e4.png)
    Figure 5.16: Plotting labels and text.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![绘制标签和文本。](../Images/98e62e9b42d105ddde8909e3548704e4.png) 图5.16：绘制标签和文本。'
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The text is plotted right on top of the points, because both are positioned
    using the same x and y mapping. One way of dealing with this, often the most effective
    if we are not too worried about excessive precision in the graph, is to remove
    the points by dropping `geom_point()` from the plot. A second option is to adjust
    the position of the text. We can left- or right-justify the labels using the `hjust`
    argument to `geom_text()`. Setting `hjust=0` will left justify the label, and
    `hjust=1` will right justify it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 文本直接绘制在点上方，因为它们都使用相同的x和y映射进行定位。处理这个问题的一种方法，通常是最有效的方法，如果我们不太担心图形中的过度精确，就是通过从图中删除`geom_point()`来移除点。第二种选择是调整文本的位置。我们可以使用`geom_text()`的`hjust`参数来左对齐或右对齐标签。将`hjust=0`设置为左对齐标签，而`hjust=1`将右对齐它。
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You might be tempted to try different values to `hjust` to fine-tune your labels.
    But this is not a robust approach. It will often fail because the space is added
    in proportion to the length of the label. The result is that longer labels move
    further away from their points than you want. There are ways around this, but
    they introduce other problems.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想尝试不同的`hjust`值来微调你的标签。但这并不是一个稳健的方法。它通常会失败，因为空间是按标签长度成比例增加的。结果是，较长的标签会移动到比预期更远的位置。有其他方法可以解决这个问题，但它们会引入其他问题。
- en: '![Plot points and text labels, with a horizontal position adjustment.](../Images/13eb6a51f767063ac5af3c89c8c60bea.png)
    Figure 5.17: Plot points and text labels, with a horizontal position adjustment.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![绘制点和文本标签，并进行水平位置调整。](../Images/13eb6a51f767063ac5af3c89c8c60bea.png) 图5.17：绘制点和文本标签，并进行水平位置调整。'
- en: 'Instead of wrestling any further with `geom_text()`, we will use `ggrepel`
    instead. This very useful library adds some new geoms to ggplot. Just as `ggplot`
    extends the plotting capabilities of R, there are many small libraries that extend
    the capabilities of `ggplot`, often by providing some new type of `geom`. The
    `ggrepel` library provides `geom_text_repel()` and `geom_label_repel()`, two geoms
    that can pick out labels much more flexibly than the default `geom_text()`. First,
    make sure the library is installed, then load it in the usual way:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再与`geom_text()`纠缠，而是使用`ggrepel`。这个非常有用的库为ggplot添加了一些新的几何对象。正如`ggplot`扩展了R的绘图功能一样，有许多小型库通过提供一些新的`geom`类型来扩展`ggplot`的功能。`ggrepel`库提供了`geom_text_repel()`和`geom_label_repel()`，这两种几何对象可以比默认的`geom_text()`更灵活地选择标签。首先，确保库已安装，然后以通常的方式加载它：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We will use `geom_text_repel()` instead of `geom_text()`. To demonstrate some
    of what `geom_text_repel()` can do, we will switch datasets and work with some
    historical U.S. presidential election data provided in the `socviz` library.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`geom_text_repel()`而不是`geom_text()`。为了展示`geom_text_repel()`的一些功能，我们将切换数据集，并使用`socviz`库中提供的一些历史美国总统选举数据进行分析。
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Figure [5.18](workgeoms.html#fig:ch-05-electionplot-01) takes each U.S. presidential
    election since 1824 (the first year that the size of the popular vote was recorded),
    and plots the winner’s share of the popular vote against the winner’s share of
    the electoral college vote. The shares are stored in the data as proportions (from
    0 to 1) rather than percentages, so we need to adjust the labels of the scales
    using `scale_x_continuous()` and `scale_y_continuous()`. Seeing as we are interested
    in particular presidencies, we also want to label the points. ButNormally it is
    not a good idea to label every point on a plot in the way we do here. A better
    approach might be to select a few points of particular interest. because many
    of the data points are plotted quite close together we need to make sure the labels
    do not overlap with each other, or obscure other points. The `geom_text_repel()`
    function handles the problem very well. This plot has relatively long labels.
    We could put them directly in the code, but just to keep things a bit tidier we
    assign the text to some named objects instead. Then we use those in the plot formula.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [5.18](workgeoms.html#fig:ch-05-electionplot-01) 显示了自 1824 年（首次记录普选投票规模的那一年）以来的每一届美国总统选举，并绘制了获胜者的普选票份额与获胜者的选举人团投票份额。这些份额在数据中作为比例（从
    0 到 1）存储，而不是百分比，因此我们需要使用 `scale_x_continuous()` 和 `scale_y_continuous()` 调整刻度标签。鉴于我们对特定的总统任期感兴趣，我们还想标记这些点。但通常来说，像我们在这里做的那样在图表上标记每个点并不是一个好主意。一个更好的方法可能是选择一些特别感兴趣的点。因为许多数据点绘制得相当接近，我们需要确保标签之间不重叠，或者不遮挡其他点。`geom_text_repel()`
    函数很好地处理了这个问题。这个图表有相当长的标签。我们本可以直接将它们放入代码中，但为了使事情更整洁，我们将其分配给一些命名的对象。然后我们在绘图公式中使用这些对象。
- en: '![Text labels with ggrepel.](../Images/a2613e5adc2cd4f46414ddca11200103.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![使用 ggrepel 的文本标签。](../Images/a2613e5adc2cd4f46414ddca11200103.png)'
- en: 'Figure 5.18: Text labels with ggrepel.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18：使用 ggrepel 的文本标签。
- en: In this plot, what is of interest about any particular point is the quadrant
    of the x-y plane each point it is in, and how far away it is from the fifty percent
    threshold on both the x-axis (with the popular vote share) and the y-axis (with
    the electoral college vote share). To underscore this point we draw two reference
    lines at the fifty percent line in each direction. They are drawn at the beginning
    of the plotting process so that the points and labels can be layered on top of
    them. We use two new geoms, `geom_hline()` and `geom_vline()` to make the lines.
    They take `yintercept` and `xintercept` arguments, respectively, and the lines
    can also be sized and colored as you please. There is also a `geom_abline()` geom
    that draws straight lines based on a supplied slope and intercept. This is useful
    for plotting, for example, 45 degree reference lines in scatterplots.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，任何特定点的有趣之处在于它所在的 x-y 平面的象限，以及它距离 x 轴（以得票率份额）和 y 轴（以选举人团投票份额）上的百分之五十阈值有多远。为了强调这一点，我们在每个方向上的百分之五十线上画了两条参考线。它们在绘图过程的开始时画出，以便点标签可以叠加在上面。我们使用两个新的几何形状，`geom_hline()`
    和 `geom_vline()` 来画线。它们分别接受 `yintercept` 和 `xintercept` 参数，并且线也可以根据您的喜好调整大小和颜色。还有一个
    `geom_abline()` 几何形状，它根据提供的斜率和截距绘制直线。这在绘制散点图中的 45 度参考线时非常有用。
- en: The ggrepel package has several other useful geoms and options to aid with effectively
    plotting labels along with points. The performance of its labeling algorithm is
    consistently very good. For many purposes it will be a better first choice than
    `geom_text()`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ggrepel 包含其他几个有用的几何形状和选项，有助于有效地在点旁边绘制标签。其标签算法的性能始终非常好。对于许多用途来说，它将比 `geom_text()`
    更好的第一个选择。
- en: 5.4 Label outliers
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 标记异常值
- en: Sometimes we want to pick out some points of interest in the data without labeling
    every single item. We can still use `geom_text()` or `geom_text_repel()`. We just
    need to pick out the points we want to label. In the code above, we do this on
    the fly by telling `geom_text_repel()` to use a different data set from the one
    `geom_point()` is using. We do this using the `subset()` function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们想要在数据中挑选出一些感兴趣的点，而不需要对每个单独的项目进行标记。我们仍然可以使用 `geom_text()` 或 `geom_text_repel()`。我们只需要挑选出我们想要标记的点。在上面的代码中，我们通过告诉
    `geom_text_repel()` 使用与 `geom_point()` 不同的数据集来实现这一点。我们使用 `subset()` 函数来完成这个操作。
- en: '![Top: Labeling text according to a single criterion. Bottom: Labeling according
    to several criteria.](../Images/5d49387a28c157265c595c015e091824.png)![Top: Labeling
    text according to a single criterion. Bottom: Labeling according to several criteria.](../Images/ede49654a99f1b182c6ac76cf63d9833.png)
    Figure 5.19: Top: Labeling text according to a single criterion. Bottom: Labeling
    according to several criteria.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![顶部：根据单个标准标注文本。底部：根据多个标准标注。](../Images/5d49387a28c157265c595c015e091824.png)![顶部：根据单个标准标注文本。底部：根据多个标准标注。](../Images/ede49654a99f1b182c6ac76cf63d9833.png)
    图5.19：顶部：根据单个标准标注文本。底部：根据多个标准标注。'
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the first figure, we specify a new `data` argument to the text geom, and
    use `subset()` to create a small dataset on the fly. The `subset()` function takes
    the `by_country` object and selects only the cases where `gdp_mean` is over 25,000,
    with the result that only those points are labeled in the plot. The criteria we
    use can be whatever we like, as long as we can write a logical expression that
    defines it. For example, in the lower figure we pick out cases where `gdp_mean`
    is greater than 25,000, *or* `health_mean` is less than 1,500, *or* the country
    is Belgium. In all of these plots, because we are using `geom_text_repel()`, we
    no longer have to worry about our earlier problem where the country labels were
    clipped at the edge of the plot.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一幅图中，我们指定了文本几何的新`data`参数，并使用`subset()`动态创建了一个小数据集。`subset()`函数接受`by_country`对象，并仅选择`gdp_mean`超过25,000的案例，结果是在图中仅标注了这些点。我们使用的标准可以是任何我们喜欢的，只要我们能编写一个定义它的逻辑表达式。例如，在下面的图中，我们挑选出`gdp_mean`大于25,000、*或者*`health_mean`小于1,500、*或者*国家是比利时的案例。在所有这些图中，因为我们使用了`geom_text_repel()`，所以我们不再需要担心之前国家标签被图边缘裁剪的问题。
- en: Alternatively, we can pick out specific points by creating a dummy variable
    in the data set just for this purpose. Here we add a column to `organdata` called
    `ind`. An observation gets coded as `TRUE` if `ccode` is “Ita”, or “Spa”, *and*
    if the `year` is greater than 1998\. We use this new `ind` variable in two ways
    in the plotting code. First, we map it to the `color` aesthetic in the usual way.
    Second, we use it to subset the data that the text geom will label. Then we suppress
    the legend that would otherwise appear for the `label` and `color` aesthetics
    by using the `guides()` function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过在数据集中创建一个仅为此目的的虚拟变量来挑选出特定的点。在这里，我们在`organdata`中添加了一个名为`ind`的列。如果一个观察值被编码为`TRUE`，那么`ccode`是“Ita”或“Spa”，*并且*如果`year`大于1998年。我们在绘图代码中使用这个新的`ind`变量两种方式。首先，我们按照常规方式将其映射到`color`美学。其次，我们使用它来子集化文本几何将标签化的数据。然后，我们使用`guides()`函数抑制了原本会出现在`label`和`color`美学上的图例。
- en: '![Labeling using a dummy variable.](../Images/caf5eb8cfdc0c144bcad11c66fd01e87.png)
    Figure 5.20: Labeling using a dummy variable.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用虚拟变量进行标注。](../Images/caf5eb8cfdc0c144bcad11c66fd01e87.png) 图5.20：使用虚拟变量进行标注。'
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 5.5 Write and draw in the plot area
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 在绘图区域书写和绘制
- en: Sometimes we want to annotate the figure directly. Maybe we need to point out
    something important that is not mapped to a variable. We use `annotate()` for
    this purpose. It isn’t quite a geom, as it doesn’t accept any variable mappings
    from our data. Instead, it can *use* geoms, temporarily taking advantage of their
    features in order to place something on the plot. The most obvious use-case is
    putting arbitrary text on the plot.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们想要直接在图中标注。也许我们需要指出一些没有映射到变量的重要信息。我们使用`annotate()`来完成这个目的。它并不完全是一个几何对象，因为它不接受来自我们数据的任何变量映射。相反，它可以使用几何对象，临时利用它们的特性来在图上放置某些内容。最明显的用例是在图上放置任意文本。
- en: We will tell `annotate()` to use a text geom. It hands the plotting duties to
    `geom_text()`, which means that we can use all of that geom’s arguments in the
    `annotate()` call. This includes the `x`, `y`, and `label` arguments, as one would
    expect, but also things like `size`, `color`, and the `hjust` and `vjust` settings
    that allow text to be justified. This is particularly useful when our label has
    several lines in it. We include extra lines by using the special “newline” code,
    `\n`, which we use instead of a space to force a line-break as needed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将告诉`annotate()`使用文本几何。它将绘图任务交给`geom_text()`，这意味着我们可以在`annotate()`调用中使用该几何的所有参数。这包括`x`、`y`和`label`参数，正如预期的那样，还包括`size`、`color`以及允许文本对齐的`hjust`和`vjust`设置。当我们的标签有几行时，这特别有用。我们通过使用特殊的“换行”代码`\n`来包含额外的行，我们使用`\n`而不是空格来强制换行，以满足需要。
- en: '![Arbitrary text with <code>annotate()</code>.](../Images/3f86d50559672b7f362dad81b3e0db5d.png)
    Figure 5.21: Arbitrary text with `annotate()`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用 <code>annotate()</code> 添加任意文本。](../Images/3f86d50559672b7f362dad81b3e0db5d.png)
    图 5.21：使用 `annotate()` 添加任意文本。'
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `annotate()` function can work with other geoms, too. Use it to draw rectangles,
    line segments, and arrows. Just remember to pass along the right arguments to
    the geom you use. We can add a rectangle to this plot, for instance, with a second
    call to the function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`annotate()` 函数也可以与其他 geom 一起使用。使用它来绘制矩形、线段和箭头。只需确保传递给所使用的 geom 正确的参数即可。例如，我们可以通过对该函数的第二次调用向此图添加一个矩形。'
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Figure 5.22: Using two different geoms with `annotate()`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.22：使用 `annotate()` 与两个不同的 geom。
- en: '![Using two different geoms with <code>annotate()</code>.](../Images/6e64df4718fa9855a4e9dac823c96edf.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![使用两个不同的 geom 与 <code>annotate()</code>。](../Images/6e64df4718fa9855a4e9dac823c96edf.png)'
- en: 5.6 Understanding scales, guides, and themes
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6 理解尺度、指南和主题
- en: This chapter has gradually extended our ggplot vocabulary in two ways. First,
    we introduced some new `geom_` functions that allowed us to draw new kinds of
    plots. Second, we made use of new functions controlling some aspects of the appearance
    of our graph. We used `scale_x_log10()`, `scale_x_continuous()` and other `scale_`
    functions to adjust axis labels. We used the `guides()` function to remove the
    legends for a `color` mapping and a `label` mapping. And we also used the `theme()`
    function to move the position of a legend from the side to the top of a figure.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以两种方式逐渐扩展了我们的 ggplot 词汇。首先，我们引入了一些新的 `geom_` 函数，使我们能够绘制新的图表类型。其次，我们利用了控制我们图表外观的一些新函数。我们使用
    `scale_x_log10()`、`scale_x_continuous()` 和其他 `scale_` 函数来调整轴标签。我们使用 `guides()`
    函数移除 `color` 映射和 `label` 映射的图例。我们还使用了 `theme()` 函数将图例的位置从侧面移动到图形的顶部。
- en: Learning about new geoms extended what we have seen already. Each geom makes
    a different type of plot. Different plots require different mappings in order
    to work, and so each `geom_` function takes mappings tailored to the kind of graph
    it draws. You can’t use `geom_point()` to make a scatterplot without supplying
    an `x` and a `y` mapping, for example. Using `geom_histogram()` only requires
    you to supply an `x` mapping. Similarly, `geom_pointrange()` requires `ymin` and
    `ymax` mappings in order to know where to draw the lineranges it makes. A `geom_`
    function may take optional arguments, too. When using `geom_boxplot()` you can
    specify what the outliers look like using arguments like `outlier.shape` and `outlier.color`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 了解新的 geom 扩展了我们已经看到的内容。每个 geom 都绘制不同类型的图表。不同的图表需要不同的映射才能工作，因此每个 `geom_` 函数都采用针对其绘制的图表类型的映射。例如，您不能在没有提供
    `x` 和 `y` 映射的情况下使用 `geom_point()` 来制作散点图。使用 `geom_histogram()` 只需要提供 `x` 映射。同样，`geom_pointrange()`
    需要提供 `ymin` 和 `ymax` 映射，以便知道在哪里绘制它所创建的线性范围。`geom_` 函数也可能接受可选参数。当使用 `geom_boxplot()`
    时，您可以使用 `outlier.shape` 和 `outlier.color` 等参数指定异常值的外观。
- en: The second kind of extension introduced some new functions, and with them some
    new concepts. What are the differences between the `scale_` functions, the `guides()`
    function, and the `theme()` function? When do you know to use one rather than
    the other? Why are there so many `scale_` functions listed in the online help,
    anyway? How can you tell which one you need?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种扩展引入了一些新函数，以及一些新概念。`scale_` 函数、`guides()` 函数和 `theme()` 函数之间的区别是什么？您何时知道使用其中一个而不是另一个？为什么在线帮助中列出了这么多
    `scale_` 函数？您如何确定您需要哪一个？
- en: 'Here is a rough and ready starting point:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个粗略的起点：
- en: Every aesthetic mapping has a scale. If you want to adjust how that scale is
    marked or graduated, then you use a `scale_` function.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个美学映射都有一个尺度。如果您想调整该尺度如何标记或分级，则使用 `scale_` 函数。
- en: Many scales come with a legend or key to help the reader interpret the graph.
    These are called *guides*. You can make adjustments to them with the `guides()`
    function. Perhaps the most common use case is to make the legend disappear, as
    it is sometimes superfluous. Another is to adjust the arrangement of the key in
    legends and colorbars.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多尺度都附带图例或键，以帮助读者解释图表。这些被称为 *指南*。您可以使用 `guides()` 函数对它们进行调整。最常见的情况可能是使图例消失，因为有时它可能是多余的。另一种情况是调整图例和颜色条中键的排列。
- en: Graphs have other features not strictly connected to the logical structure of
    the data being displayed. These include things like their background color, the
    typeface used for labels, or the placement of the legend on the graph. To adjust
    these, use the `theme()` function.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图表还有其他一些特征，它们与显示的数据的逻辑结构没有严格的联系。这些包括诸如背景颜色、用于标签的字体类型，或者图例在图上的位置等。要调整这些，请使用 `theme()`
    函数。
- en: Consistent with ggplot’s overall approach, adjusting some visible feature of
    the graph means first thinking about the relationship that the feature has with
    the underlying data. Roughly speaking, if the change you want to make will affect
    the substantive interpretation of any particular geom, then most likely you will
    either be mapping an aesthetic to a variable using that geom’s `aes()` function,
    or you will be specifying a change via some `scale_` function. If the change you
    want to make does not affect the interpretation of a given geom_, then most likely
    you will either be setting a variable inside the `geom_` function, or making a
    cosmetic change via the `theme()` function.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 与 ggplot 的整体方法一致，调整图表的一些可见特征意味着首先考虑该特征与底层数据之间的关系。大致来说，如果你想要进行的更改将影响任何特定几何图形的实质性解释，那么你很可能会使用该几何图形的
    `aes()` 函数将美学映射到变量，或者通过某个 `scale_` 函数指定更改。如果你想要进行的更改不会影响给定几何图形的解释，那么你很可能会在 `geom_`
    函数内部设置变量，或者通过 `theme()` 函数进行外观上的更改。
- en: '![Every mapped variable has a scale.](../Images/2baf5a838809dd86e16a88cbfc970f7e.png)
    Figure 5.23: Every mapped variable has a scale.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![每个映射的变量都有一个尺度。](../Images/2baf5a838809dd86e16a88cbfc970f7e.png) 图 5.23：每个映射的变量都有一个尺度。'
- en: Scales and guides are closely connected, which can make things confusing. The
    guide provides information about the scale, such as in a legend or colorbar. Thus,
    it is possible to make adjustments to guides from inside the various `scale_`
    functions. More often it is easier to use the `guides()` function directly.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 尺度和指南紧密相连，这可能会让人感到困惑。指南提供了有关尺度的信息，例如图例或颜色条。因此，可以从各种 `scale_` 函数内部调整指南。通常，直接使用
    `guides()` 函数会更简单。
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Figure [5.23](workgeoms.html#fig:ch-05-scalesfig-01) shows a plot with three
    aesthetic mappings. The variable `roads` is mapped to `x`; `donors` is mapped
    to `y`; and `world` is mapped to `color`. The `x` and `y` scales are both *continuous*,
    running smoothly from just under the lowest value of the variable to just over
    the highest value. Various labeled tick marks orient the reader to the values
    on each axis. The `color` mapping also has a scale. The `world` measure is an
    unordered categorical variable, so its scale is *discrete*. It takes one of four
    values, each represented by a different color.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [5.23](workgeoms.html#fig:ch-05-scalesfig-01) 展示了一个具有三个美学映射的图表。变量 `roads`
    映射到 `x`；`donors` 映射到 `y`；而 `world` 映射到 `color`。`x` 和 `y` 尺度都是 *连续的*，从略低于变量的最低值平滑运行到略高于变量的最高值。各种标记的刻度线引导读者了解每个轴上的值。`color`
    映射也有一个尺度。`world` 测量是一个无序的分类变量，因此其尺度是 *离散的*。它取四个值之一，每个值由不同的颜色表示。
- en: Along with `color`, mappings like `fill`, `shape`, and `size` will have scales
    that we might want to customize or adjust. We could have mapped `world` to `shape`
    instead of `color`. In that case our four-category variable would have a scale
    consisting of four different shapes. Scales for these mappings may have labels,
    axis tick marks at particular positions, or specific colors or shapes. If we want
    to adjust them, we use one of the `scale_` functions.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `color` 之外，像 `fill`、`shape` 和 `size` 这样的映射也将具有我们可能想要自定义或调整的尺度。我们本可以将 `world`
    映射到 `shape` 而不是 `color`。在这种情况下，我们的四分类变量将有一个由四个不同形状组成的尺度。这些映射的尺度可能包含标签、特定位置的轴刻度线或特定的颜色或形状。如果我们想要调整它们，我们使用一个
    `scale_` 函数。
- en: Many different kinds of variable can be mapped. More often than not `x` and
    `y` are continuous measures. But they might also easily be discrete, as when we
    mapped country names to the `y` axis in our boxplots and dotplots. An `x` or `y`
    mapping can also be defined as a transformation onto a log scale, or as a special
    sort of number value like a date. Similarly, a `color` or a `fill` mapping can
    be discrete and *unordered*, as with our `world` variable, or discrete and *ordered*,
    as with letter grades in an exam. A `color` or `fill` mapping can also be a continuous
    quantity, represented as a gradient running smoothly from a low to a high value.
    Finally, both continuous gradients and ordered discrete values might have some
    defined neutral midpoint with extremes diverging in both directions.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将许多不同类型的变量映射到图表中。通常情况下，`x`和`y`是连续的度量。但它们也可能很容易地是离散的，就像我们在箱形图和点图中将国家名称映射到`y`轴时那样。`x`或`y`映射也可以定义为对数比例的转换，或者定义为特殊的数值类型，如日期。同样，`color`或`fill`映射可以是离散的且*无序的*，就像我们的`world`变量一样，或者离散的且*有序的*，就像考试中的字母等级一样。`color`或`fill`映射也可以是连续的数量，表示为从低值到高值平滑过渡的渐变。最后，连续渐变和有序离散值可能都有一个定义的中性中间点，两端向相反方向发散。
- en: '![A schema for naming the <code>scale</code> functions.](../Images/f68891a3a348d121e8d9d743eaa18404.png)
    Figure 5.24: A schema for naming the `scale` functions.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![命名`scale`函数的架构。](../Images/f68891a3a348d121e8d9d743eaa18404.png) 图5.24：命名`scale`函数的架构。'
- en: Because we have several potential mappings, and each mapping might be to one
    of several different scales, we end up with a lot of individual `scale_` functions.
    Each deals with one combination of mapping and scale. They are named according
    to a consistent logic, shown in Figure [5.24](workgeoms.html#fig:ch-05-scale-template).
    First comes the `scale_` name, then the *mapping* it applies to, and finally the
    *kind* of value the scale will display. Thus, the `scale_x_continuous()` function
    controls `x` scales for continuous variables; `scale_y_discrete()` adjusts `y`
    scales for discrete variables; and `scale_x_log10()` transforms an `x` mapping
    to a log scale. Most of the time, ggplot will guess correctly what sort of scale
    is needed for your mapping. Then it will work out some default features of the
    scale (such as its labels and where the tick marks go). In many cases you will
    not need to make any scale adjustments. If `x` is mapped to a continuous variable
    then adding `+ scale_x_continuous()` to your plot statement with no further arguments
    will have no effect. It is already there implicitly. Adding `+ scale_x_log10()`,
    on the other hand, will transform your scale, as now you have replaced the default
    treatment of a continuous x variable.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们有几个潜在的映射，每个映射可能对应于几个不同的比例之一，所以我们最终会有很多个单独的`scale_`函数。每个函数处理一种映射和比例的组合。它们根据一致的逻辑命名，如图[5.24](workgeoms.html#fig:ch-05-scale-template)所示。首先是`scale_`名称，然后是它应用的*映射*，最后是比例将显示的*类型*。因此，`scale_x_continuous()`函数控制连续变量的`x`比例；`scale_y_discrete()`调整离散变量的`y`比例；而`scale_x_log10()`将`x`映射转换为对数比例。大多数时候，ggplot会正确猜测你的映射所需的类型。然后它会计算出比例的一些默认特征（如标签和刻度标记的位置）。在许多情况下，你不需要进行任何比例调整。如果`x`映射到连续变量，那么在绘图语句中添加`+
    scale_x_continuous()`而没有其他参数将没有任何效果。它已经隐含地存在了。另一方面，添加`+ scale_x_log10()`将转换你的比例，因为你已经替换了默认的连续x变量的处理方式。
- en: If you want to adjust the labels or tick marks on a scale, you will need to
    know which mapping it is for and what sort of scale it is. Then you supply the
    arguments to the appropriate scale function. For example, we can change the x-axis
    of the previous plot to a log scale, and then also change the position and labels
    of the tick marks on the y-axis.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要调整比例上的标签或刻度标记，你需要知道它是针对哪个映射以及它是哪种类型的比例。然后你提供适当的比例函数的参数。例如，我们可以将之前图表的x轴更改为对数比例，然后也可以更改y轴上刻度标记的位置和标签。
- en: '![Making some scale adjustments.](../Images/cc6fa882fd8215de245122737bccb83c.png)
    Figure 5.25: Making some scale adjustments.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![进行一些比例调整。](../Images/cc6fa882fd8215de245122737bccb83c.png) 图5.25：进行一些比例调整。'
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The same applies to mappings like `color` and `fill`. Here the available `scale_`
    functions include ones that deal with continuous, diverging, and discrete variables,
    as well as others that we will encounter later when we discuss the use of color
    and color palettes in more detail. When working with a scale that produces a legend,
    we can also use this its `scale_` function to specify the labels in the key. To
    change the *title* of the legend, however, we use the `labs()` function, which
    lets us label all the mappings.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于 `color` 和 `fill` 这样的映射。这里可用的 `scale_` 函数包括处理连续、发散和离散变量的函数，以及我们稍后将在更详细地讨论颜色和颜色调色板的使用时遇到的函数。当与生成图例的缩放一起工作时，我们也可以使用这个
    `scale_` 函数来指定键中的标签。然而，要更改图例的 *标题*，我们使用 `labs()` 函数，它允许我们标记所有映射。
- en: '![Relabeling via a scale function.](../Images/de3905e462410cdccab6ff95d4746cc5.png)
    Figure 5.26: Relabeling via a scale function.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![通过缩放函数进行重命名。](../Images/de3905e462410cdccab6ff95d4746cc5.png) 图 5.26：通过缩放函数进行重命名。'
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If we want to move the legend somewhere else on the plot, we are making a purely
    cosmetic decision and that is the job of the `theme()` function. As we have already
    seen, adding `+ theme(legend.position = "top")` will move the legend as instructed.
    Finally, to make the legend disappear altogether, we tell ggplot that we do not
    want a guide for that scale. This is generally not good practice, but there can
    be good reasons to do it. We will see some examples later on.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将图例移动到图表的另一个位置，我们只是在做一项纯粹的外观决定，这是 `theme()` 函数的工作。正如我们已经看到的，添加 `+ theme(legend.position
    = "top")` 将按照指示移动图例。最后，为了使图例完全消失，我们告诉 ggplot 我们不希望对该缩放有指南。这通常不是好的做法，但有时有很好的理由这样做。我们稍后会看到一些例子。
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![Removing the guide to a scale.](../Images/c75b51f0fc2df917751b27f2d454693b.png)
    Figure 5.27: Removing the guide to a scale.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![移除缩放指南。](../Images/c75b51f0fc2df917751b27f2d454693b.png) 图 5.27：移除缩放指南。'
- en: We will look more closely at `scale_` and `theme()` functions in Chapter [8](refineplots.html#refineplots),
    when we discuss how to polish plots that we are ready to display or publish. Until
    then, we will use `scale_` functions fairly regularly to make small adjustments
    to the labels and axes of our graphs. And we will occasionally use the `theme()`
    function to make some cosmetic adjustments here and there. So you do not need
    to worry too much about additional details of how they work until later on. But
    at this point it *is* worth knowing what `scale_` functions are for, and the logic
    behind their naming scheme. Understanding the `scale_<mapping>_<kind>()` rule
    makes it easier to see what is going on when one of these functions is called
    to make an adjustment to a plot.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 [8](refineplots.html#refineplots) 章节中更详细地探讨 `scale_` 和 `theme()` 函数，那时我们将讨论如何润色我们准备展示或发布的图表。在此之前，我们将相当频繁地使用
    `scale_` 函数来对图表的标签和坐标轴进行微调。偶尔，我们也会使用 `theme()` 函数在这里和那里做一些外观上的调整。所以，你不必过于担心它们的工作细节，直到稍后。但在此阶段，了解
    `scale_` 函数的用途及其命名逻辑是值得的。理解 `scale_<mapping>_<kind>()` 规则可以使我们更容易看到当调用这些函数之一来调整图表时发生了什么。
- en: 5.7 Where to go next
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.7 接下来去哪里
- en: We covered several new functions and data aggregation techniques in this Chapter.
    You should practice working with them.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了几个新的函数和数据聚合技术。你应该练习使用它们。
- en: '![Two figures from Chapter 1.](../Images/29521484b08d54e09144a78dfbe4c4ba.png)![Two
    figures from Chapter 1.](../Images/4d47e812c07ab78006c1ab2415e80c88.png) Figure
    5.28: Two figures from Chapter 1.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![第 1 章的两个图。](../Images/29521484b08d54e09144a78dfbe4c4ba.png) ![第 1 章的两个图。](../Images/4d47e812c07ab78006c1ab2415e80c88.png)
    图 5.28：第 1 章的两个图。'
- en: The `subset()` function is very useful when used in conjunction with a series
    of layered geoms. Go back to your code for the Presidential Elections plot (Figure
    [5.18](workgeoms.html#fig:ch-05-electionplot-01)) and redo it so that it shows
    all the data points but only labels elections since 1992\. You might need to look
    again at the `elections_historic` data to see what variables are available to
    you. You can also experiment with subsetting by political party, or changing the
    colors of the points to reflect the winning party.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当与一系列分层几何对象一起使用时，`subset()` 函数非常有用。回到你为总统选举图（图 5.18）编写的代码，并重新编写它，以便显示所有数据点，但只标记自
    1992 年以来的选举。你可能需要再次查看 `elections_historic` 数据，以了解可用的变量。你也可以通过政党进行子集化实验，或者改变点的颜色以反映获胜的政党。
- en: Use `geom_point()` and `reorder()` to make a Cleveland dot plot of all Presidential
    elections, ordered by share of the popular vote.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `geom_point()` 和 `reorder()` 创建一个按得票率排序的所有总统选举的克利夫兰点图。
- en: Try using `annotate()` to add a rectangle that lightly colors the entire upper
    left quadrant of Figure [5.18](workgeoms.html#fig:ch-05-electionplot-01).
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用 `annotate()` 添加一个矩形，轻轻着色图 [5.18](workgeoms.html#fig:ch-05-electionplot-01)
    的整个左上象限。
- en: The main action verbs in the `dplyr` library are `group_by()`, `filter()`, `select()`,
    `summarize()`, and `mutate()`. Practice with them by revisiting the `gapminder`
    data to see if you can reproduce a pair of graphs from Chapter One, shown here
    again in Figure [5.28](workgeoms.html#fig:ch-05-gapminder-revisit). You will need
    to filter some rows, group the data by continent, and calculate the mean life
    expectancy by continent before beginning the plotting process.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dplyr` 库中的主要动作动词是 `group_by()`、`filter()`、`select()`、`summarize()` 和 `mutate()`。通过重新访问
    `gapminder` 数据来练习它们，看看你是否能重现第一章中的一对图表，这里再次在图 [5.28](workgeoms.html#fig:ch-05-gapminder-revisit)
    中展示。在开始绘图过程之前，你需要过滤一些行，按大陆分组数据，并计算按大陆的平均预期寿命。'
- en: 'Get comfortable with grouping, mutating, and summarizing data in pipelines.
    This will become a routine task as you work with your data. There are many ways
    that tables can be aggregated and transformed. Remember `group_by()` groups your
    data from left to right, with the rightmost or innermost group being the level
    calculations will be done at; `mutate()` adds a column at the current level of
    grouping; and `summarize()` aggregates to the next level up. Try creating some
    grouped objects from the GSS data, calculating frequencies as you learned in this
    Chapter, and then check to see if the totals are what you expect. For example,
    start by grouping `degree` by `race`, like this:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在管道中熟悉分组、变异和汇总数据。当你处理数据时，这将变成一项常规任务。表格可以以多种方式聚合和转换。记住 `group_by()` 从左到右分组你的数据，最右边或最内层的组是将在其上进行计算的级别；`mutate()`
    在当前分组级别添加一列；而 `summarize()` 聚合到下一个级别。尝试从 GSS 数据中创建一些分组对象，计算频率，就像你在本章中学到的那样，然后检查总数是否符合你的预期。例如，首先按
    `race` 对 `degree` 进行分组，如下所示：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This code is similar to what you saw earlier, but a little more compact. (We
    calculate the `pct` values directly.) Check the results are as you expect by grouping
    by `race` and summing the percentages. Try doing the same exercise grouping by
    `sex` or `region`.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码与之前看到的大致相同，但稍微紧凑一些。（我们直接计算 `pct` 值。）通过按 `race` 分组并汇总百分比来检查结果是否符合你的预期。尝试通过
    `sex` 或 `region` 进行相同的分组练习。
- en: 'Try summary calculations with functions other than `sum`. Can you calculate
    the mean and median number of children by `degree`? (Hint: the `childs` variable
    in `gss_sm` has children as a numeric value.)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用除 `sum` 之外的其他函数进行汇总计算。你能按 `degree` 计算平均和中等儿童数量吗？（提示：`gss_sm` 中的 `childs`
    变量表示儿童的数量为数值。）
- en: '`dplyr` has a large number of helper functions that let you summarize data
    in many different ways. The vignette on *window functions* included with the `dplyr`
    documentation is a good place to begin learning about these. You should also look
    at Chapter 3 of Wickham & Grolemund (2016) for more information on transforming
    data with `dplyr`.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dplyr` 有许多辅助函数，可以让你以许多不同的方式汇总数据。`dplyr` 文档中包含的关于 *窗口函数* 的示例是一个开始学习这些函数的好地方。你还应该查看
    Wickham & Grolemund (2016) 的第 3 章，以获取有关使用 `dplyr` 转换数据的更多信息。'
- en: 'Experiment with the `gapminder` data to practice some of the new geoms we have
    learned. Try examining population or life expectancy over time using a series
    of boxplots. (Hint: you may need to use the `group` aesthetic in the `aes()` call.)
    Can you facet this boxplot by continent? Is anything different if you create a
    tibble from `gapminder` that explicitly groups the data by `year` and `continent`
    first, and then create your plots with that?'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用 `gapminder` 数据来练习我们学到的一些新 geom。尝试使用一系列箱线图来检查人口或预期寿命随时间的变化。（提示：你可能需要在 `aes()`
    调用中使用 `group` 美学。）你能按大陆分面这个箱线图吗？如果你首先从 `gapminder` 创建一个明确按 `year` 和 `continent`
    分组的 tibble，然后使用它来创建图表，会有什么不同吗？
- en: Read the help page for `geom_boxplot()` and take a look at the `notch` and `varwidth`
    options. Try them out to see how they change the look of the plot.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读关于 `geom_boxplot()` 的帮助页面，并查看 `notch` 和 `varwidth` 选项。尝试使用它们来观察它们如何改变图表的外观。
- en: As an alternative to `geom_boxplot()` try `geom_violin()` for a similar plot,
    but with a mirrored density distribution instead of a box and whiskers.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 `geom_boxplot()` 的替代方案，尝试使用 `geom_violin()` 来创建类似的图表，但使用镜像密度分布而不是箱线和胡须。
- en: '`geom_pointrange()` is one of a family of related geoms that produce different
    kinds of error bars and ranges, depending on your specific needs. They include
    `geom_linerange()`, `geom_crossbar()`, and `geom_errorbar()`. Try them out using
    `gapminder` or `organdata` to see how they differ.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geom_pointrange()` 是一系列相关几何图形之一，根据您的具体需求产生不同类型的误差线和范围。它们包括 `geom_linerange()`、`geom_crossbar()`
    和 `geom_errorbar()`。尝试使用 `gapminder` 或 `organdata` 来试用它们，看看它们有何不同。'
- en: 5.1 Use pipes to summarize data
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 使用管道总结数据
- en: In Chapter [4](groupfacettx.html#groupfacettx) we began making plots of the
    distributions and relative frequencies of variables. Cross-classifying one measure
    by another is one of the basic descriptive tasks in data analysis. Tables [5.1](workgeoms.html#tab:relig1)
    and [5.2](workgeoms.html#tab:relig2) show two common ways of summarizing our GSS
    data on the distribution of religious affiliation and region. Table [5.1](workgeoms.html#tab:relig1)
    shows the column marginals, where the numbers sum to a hundred by column and show,
    e.g., the distribution of Protestants across regions. Meanwhile in Table [5.2](workgeoms.html#tab:relig2)
    the numbers sum to a hundred across the rows, showing for example the distribution
    of religious affiliations within any particular region.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 [4](groupfacettx.html#groupfacettx) 章中，我们开始绘制变量的分布和相对频率的图表。通过另一个度量标准对某一度量标准进行交叉分类是数据分析中的基本描述性任务之一。表
    [5.1](workgeoms.html#tab:relig1) 和 [5.2](workgeoms.html#tab:relig2) 展示了两种总结我们GSS数据中宗教归属和地区分布的常见方法。表
    [5.1](workgeoms.html#tab:relig1) 显示了列边际，其中数字按列相加总和为一百，例如，显示新教徒在各个地区的分布。同时，在表 [5.2](workgeoms.html#tab:relig2)
    中，数字按行相加总和为一百，例如，显示任何特定地区内宗教归属的分布。
- en: We saw in Chapter [4](groupfacettx.html#groupfacettx) that `geom_bar()` can
    plot both counts and relative frequencies depending on what we asked of it. In
    practice, though, letting the geoms (and their `stat_` functions) do the work
    can sometimes get a little confusing. It is too easy to lose track of whether
    one has calculated row margins, column margins, or overall relative frequencies.
    The code to do the calculations on the fly ends up stuffed into the mapping function
    and can become hard to read. A better strategy is to calculate the frequency table
    you want first, and then plot that table. This has the benefit of allowing you
    do to some quick sanity checks on your tables, to make sure you haven’t made any
    errors.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 [4](groupfacettx.html#groupfacettx) 章中看到，`geom_bar()` 可以根据我们的要求绘制计数和相对频率。然而，在实践中，让几何图形（及其
    `stat_` 函数）做工作有时可能会有些混乱。很容易失去对是否已经计算了行边际、列边际或整体相对频率的跟踪。实时计算的计算代码最终会被塞入映射函数中，变得难以阅读。更好的策略是首先计算你想要的频率表，然后绘制该表。这有一个好处，就是允许你快速检查你的表格，以确保你没有犯任何错误。
- en: 'Table 5.2: Row marginals. (Numbers in rows sum to 100.)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.2：行边际。 (行中的数字总和为 100。)
- en: '|  | Protestant | Catholic | Jewish | None | Other | NA |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '|  | 新教徒 | 天主教徒 | 犹太教徒 | 无 | 其他 | NA |'
- en: '| --- | --: | --: | --: | --: | --: | --: |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| --- | --: | --: | --: | --: | --: | --: |'
- en: '| Northeast | 32 | 33 | 6 | 23 | 6 | 0 |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 东北部 | 32 | 33 | 6 | 23 | 6 | 0 |'
- en: '| Midwest | 47 | 25 | 0 | 23 | 5 | 1 |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 中部 | 47 | 25 | 0 | 23 | 5 | 1 |'
- en: '| South | 62 | 15 | 1 | 16 | 5 | 1 |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 南部 | 62 | 15 | 1 | 16 | 5 | 1 |'
- en: '| West | 38 | 25 | 2 | 28 | 8 | 0 |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 西部 | 38 | 25 | 2 | 28 | 8 | 0 |'
- en: Let’s say we want a plot of the row-marginals for religion within region. We
    will take the opportunity to do a little bit of data-munging in order to get from
    our underlying table of GSS data to the summary tabulation that we want to plot.
    To do this we will use the tools provided by `dplyr`, a component of the tidyverse
    library that provides functions for manipulating and reshaping tables of data
    on the fly. We start from our individual-level `gss_sm` data frame with its `bigregion`
    and `religion` variables. Our goal is a summary table with percentages of religious
    preferences grouped within region.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要一个显示地区内宗教的行边际的图表。我们将利用这个机会进行一些数据整理，以便从我们的GSS数据基础表到我们想要绘制的汇总表。为此，我们将使用`dplyr`提供的工具，它是tidyverse库的一个组成部分，它提供了一些函数，用于实时操作和重塑数据表。我们从包含`bigregion`和`religion`变量的个体级`gss_sm`数据框开始。我们的目标是创建一个汇总表，其中包含按地区分组宗教偏好的百分比。
- en: '![How we want to transform the individual-level data.](../Images/c96fe64ed11c6cdbac73f2faf91c0a26.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![我们希望如何转换个体级数据。](../Images/c96fe64ed11c6cdbac73f2faf91c0a26.png)'
- en: 'Figure 5.1: How we want to transform the individual-level data.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：我们希望如何转换个体级数据。
- en: As shown schematically in Figure [5.1](workgeoms.html#fig:ch-05-dplyr-example),
    we will start with our individual-level table of about 2,500 GSS respondents.
    Then we want to summarize them into a new table that shows a count of each religious
    preference, grouped by region. Finally we will turn these within-region counts
    into percentages, where the denominator is the total number of respondents within
    each region. The `dplyr` library provides a few tools to make this easy and clear
    to read. We will use a special operator, `%>%`, to do our work. This is the *pipe*
    operator. It plays the role of the yellow triangle in Figure [5.1](workgeoms.html#fig:ch-05-dplyr-example),
    in that it helps us perform the actions that get us from one table to the next.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 [5.1](workgeoms.html#fig:ch-05-dplyr-example) 所示，我们将从大约 2,500 名 GSS 被调查者的个体级表格开始。然后我们想要将它们汇总到一个新的表格中，该表格显示了按地区分组的每种宗教偏好的计数。最后，我们将这些地区内的计数转换为百分比，分母是每个地区内受访者的总数。`dplyr`
    库提供了一些工具，使这个过程变得简单且易于阅读。我们将使用一个特殊操作符 `%>%` 来完成我们的工作。这是 *管道* 操作符。它在图 [5.1](workgeoms.html#fig:ch-05-dplyr-example)
    中的作用类似于黄色三角形，它帮助我们执行从一张表到下一张表的转换操作。
- en: 'We have being building our plots in an *additive* fashion, starting with a
    `ggplot` object and layering on new elements. By analogy, think of the `%>%` operator
    as allowing us to start with a data frame and perform a *sequence* or *pipeline*
    of operations to turn it into another, usually smaller and more aggregated table.
    Data goes in one side of the pipe, actions are performed via functions, and results
    come out the other. A pipeline is typically a series of operations that do one
    or more of four things:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在以 *累加* 的方式构建我们的图形，从 `ggplot` 对象开始，并添加新的元素。通过类比，将 `%>%` 操作符视为允许我们从数据框开始，执行一系列操作，将其转换成另一张表，通常是更小、更汇总的表。数据从管道的一侧进入，通过函数执行操作，结果从另一侧出来。管道通常是一系列操作，执行以下四件事情之一或多个：
- en: '*Group*`group_by()` the data into the nested structure we want for our summary,
    such as “Religion by Region” or “Authors by Publications by Year”.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分组* 使用 `group_by()` 将数据分组到我们想要的汇总的嵌套结构中，例如“宗教按地区”或“作者按出版物按年份”。'
- en: '*Filter*`filter()` rows; `select()` columns or *select* pieces of the data
    by row, column, or both. This gets us the piece of the table we want to work on.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*过滤* `filter()` 行；`select()` 列或通过行、列或两者选择数据的一部分。这使我们能够得到我们想要工作的表格部分。'
- en: '*Mutate*`mutate()` the data by creating new variables at the *current* level
    of grouping. This adds new columns to the table without aggregating it.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*转换* 使用 `mutate()` 通过在 *当前* 分组级别创建新变量来转换数据。这向表格中添加新列，而不进行聚合。'
- en: '*Summarize*`summarize()` or aggregate the grouped data. This creates new variables
    at a *higher* level of grouping. For example we might calculate means with `mean()`
    or counts with `n()`. This results in a smaller, summary table, which we might
    do more things on if we want.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*汇总* 使用 `summarize()` 或聚合分组数据。这会在 *更高* 的分组级别创建新变量。例如，我们可能使用 `mean()` 计算平均值或使用
    `n()` 计算计数。这会产生一个更小、更简洁的汇总表，如果我们想进行更多操作，我们可以在此基础上进行。'
- en: We use the `dplyr` functions `group_by()`, `filter()`, `select()`, `mutate()`,
    and `summarize()` to carry out these tasks within our pipeline. They are written
    in a way that allows them to be easily piped. That is, they understand how to
    take inputs from the left side of a pipe operator and pass results along through
    the right side of one. The dplyr documentation has some useful vignettes that
    introduce these grouping, filtering, selection, and transformation functions.
    There is also a more detailed discussion of these tools, along with many more
    examples, in Wickham & Grolemund (2016).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `dplyr` 函数 `group_by()`、`filter()`、`select()`、`mutate()` 和 `summarize()`
    在我们的管道中执行这些任务。它们被编写成易于管道化的方式。也就是说，它们理解如何从管道操作符的左侧获取输入，并通过右侧传递结果。dplyr 文档中包含一些有用的示例，介绍了这些分组、过滤、选择和转换函数。在
    Wickham & Grolemund (2016) 中，对这些工具进行了更详细的讨论，并提供了许多更多示例。
- en: 'We will create a new table called `rel_by_region`. Here’s the code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `rel_by_region` 的新表格。以下是代码：
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: What are these lines doing? First, we are creating an object as usual, with
    the familiar assignment operator, `<-`. Next, at the steps to the right. Read
    the objects and functions from left to right, with the pipe operator “`%>%`” connecting
    them together meaning “and then …”. Objects on the left hand side “pass through”
    the pipe, and whatever is specified on the right of the pipe gets done to that
    object. The resulting object then passes through to the right again, and so on
    down to the end of the pipeline.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行在做什么？首先，我们像往常一样创建一个对象，使用熟悉的赋值运算符`<-`。接下来，在右侧的步骤中。从左到右读取对象和函数，使用管道运算符“`%>%`”将它们连接起来，意味着“然后……”。左侧的对象“通过”管道，管道右侧指定的任何内容都会应用于该对象。结果对象然后再次通过管道，依此类推，直到管道的末端。
- en: 'Reading from the left, the code says this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右读取，代码表示：
- en: 'Create`rel_by_region <- gss_sm %>%` a new object, `rel_by_region`. It will
    get the result of the following sequence of actions: Start with the `gss_sm` data,
    and then'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新对象`rel_by_region <- gss_sm %>%`，名为`rel_by_region`。它将获取以下一系列操作的结果：从`gss_sm`数据开始，然后
- en: Group`group_by(bigregion, religion) %>%` the rows by `bigregion` and, within
    that, by `religion`.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group_by(bigregion, religion) %>%`按`bigregion`分组行，并在其中按`religion`分组。'
- en: 'Summarize this table`summarize(N = n()) %>%` to create a new, much smaller
    table, with three columns: `bigregion`, `religion`, and a new summary variable,
    `N`, that is a count of the number of observations within each religious group
    for each region.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将此表`summarize(N = n()) %>%`汇总以创建一个新表，包含三列：`bigregion`、`religion`和一个新的汇总变量`N`，它是每个地区每个宗教群体内观测数的计数。
- en: 'With this new table, `mutate(freq = N / sum(N), pct = round((freq*100), 0))`
    use the `N` variable to calculate two new columns: the relative proportion (`freq`)
    and percentage (`pct`) for each religious category, still grouped by region. Round
    the results to the nearest percentage point.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这个新表，`mutate(freq = N / sum(N), pct = round((freq*100), 0))`使用`N`变量计算两个新列：每个宗教类别的相对比例（`freq`）和百分比（`pct`），仍然按地区分组。将结果四舍五入到最接近的百分点。
- en: In this way of doing things, objects passed along the pipeline and the functions
    acting on them carry some assumptions about their context. For one thing, you
    don’t have to keep specifying the name of the underlying data frame object you
    are working from. Everything is implicitly carried forward from `gss_sm`. Within
    the pipeline, the transient or implicit objects created from your summaries and
    other transformations are carried through, too.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种做事方式中，沿着管道传递的对象和作用于它们的函数对其上下文有一些假设。一方面，你不必始终指定你正在工作的底层数据框对象的名称。一切都被隐式地从`gss_sm`传递。在管道内，从你的汇总和其他转换中创建的临时或隐式对象也被传递。
- en: Second, the `group_by()` function sets up how the grouped or nested data will
    be processed within the `summarize()` step. Any function used to create a new
    variable within `summarize()`, such as `mean()` or `sd()` or `n()`, will be applied
    to the *innermost* grouping level first. Grouping levels are named from left to
    right within `group_by()` from outermost to innermost. So the function call `summarize(N
    = n())` counts up the number of observations for each value of `religion` within
    `bigregion` and puts them in a new variable named `N`. As dplyr’s functions see
    things, summarizing actions “peel off” one grouping level at a time, so that the
    resulting summaries are at the next level up. In this case, we start with individual-level
    observations and group them by religion within region. The `summarize()` operation
    aggregates the individual observations to counts of the number of people affiliated
    with each religion, for each region.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，`group_by()`函数设置了在`summarize()`步骤中如何处理分组或嵌套数据。在`summarize()`内部创建新变量的任何函数，例如`mean()`、`sd()`或`n()`，将首先应用于最内层的分组级别。分组级别在`group_by()`中从最外层到最内层按从左到右命名。因此，函数调用`summarize(N
    = n())`计算每个`bigregion`内每个`religion`值的观测数，并将它们放入一个名为`N`的新变量中。在dplyr的函数看来，汇总操作“逐层剥离”一个分组级别，因此结果汇总是在下一个级别上。在这种情况下，我们开始于个体级别的观测值，并在地区内按宗教进行分组。`summarize()`操作将个体观测值聚合为每个地区每个宗教群体的人数计数。
- en: Third, the `mutate()` step takes the `N` variable and uses it to create `freq`,
    the relative frequency for each subgroup within region, and finally `pct`, the
    relative frequency turned into a rounded percentage. These `mutate()` operations
    add or remove columns from tables, but do not change the grouping level.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，`mutate()`步骤使用`N`变量来创建`freq`，即每个区域内的子组的相对频率，最后创建`pct`，即转换为四舍五入百分比的相对频率。这些`mutate()`操作向表中添加或移除列，但不会改变分组级别。
- en: Inside both `mutate()` and `summarize()`, we are able to create new variables
    in a way that we have not seen before. Usually, when we see something like `name
    = value` inside a function, the `name` is a general, named argument and the function
    is expecting information from us about the specific value it should take.As in
    the case of `aes(x = gdpPercap, y = lifeExp)`, for example. Normally if we give
    a function a named argument it doesn’t know about (`aes(chuckles = year)`) it
    will ignore it, complain, or break. With `summarize()` and `mutate()`, however,
    we can invent named arguments. We are still assigning specific values to `N`,
    `freq`, and `pct`, but we pick the names, too. They are the names that the newly-created
    variables in the summary table will have. The `summarize()` and `mutate()` functions
    do not need to know what they will be in advance.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mutate()`和`summarize()`内部，我们能够以我们之前未见过的这种方式创建新变量。通常，当我们在一个函数内部看到类似`name =
    value`的东西时，`name`是一个通用的命名参数，函数期望我们从它那里获取关于特定值的信息。例如，在`aes(x = gdpPercap, y = lifeExp)`的情况下。通常，如果我们给一个函数一个它不知道的命名参数（`aes(chuckles
    = year)`），它将忽略它、抱怨或崩溃。然而，在`summarize()`和`mutate()`的情况下，我们可以发明命名参数。我们仍然在将特定的值分配给`N`、`freq`和`pct`，但我们也在选择名称。它们是新创建的汇总表中的变量的名称。`summarize()`和`mutate()`函数不需要提前知道它们会是什么。
- en: Finally, when we use `mutate()` to create the `freq` variable, not only can
    we make up that name within the function, `mutate()` is also clever enough to
    let us *use* that name right away, on the next line of the same function call,
    when we create the `pct` variable. This means we do not have to repeatedly write
    separate `mutate()` calls for every new variable we want to create.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们使用`mutate()`创建`freq`变量时，我们不仅可以在函数内部命名这个变量，`mutate()`还足够聪明，允许我们在同一函数调用的下一行立即使用这个名称来创建`pct`变量。这意味着我们不需要为每个想要创建的新变量重复编写单独的`mutate()`调用。
- en: 'Our pipeline takes the `gss_sm` data frame, which has 2867 rows and 32 columns,
    and transforms it into `rel_by_region`, a summary table with 24 rows and 5 columns
    that looks like this, in part:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的管道将`gss_sm`数据框（有2867行和32列）转换成`rel_by_region`，这是一个包含24行和5列的汇总表，部分如下所示：
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The variables specified in `group_by()` are retained in the new summary table;
    the variables created with `summarize()` and `mutate()` are added, and all the
    other variables in the original dataset are dropped.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在`group_by()`中指定的变量保留在新的汇总表中；使用`summarize()`和`mutate()`创建的变量被添加，原始数据集中的所有其他变量都被删除。
- en: We said before that, when trying to grasp what each additive step in a `ggplot()`
    sequence does, it can be helpful to work backwards, removing one piece at a time
    to see what the plot looks like when that step is not included. In the same way,
    when looking at pipelined code it can be helpful to start from the end of the
    line, and then remove one “`%>%`” step at a time to see what the resulting intermediate
    object looks like. For instance, what if we remove the `mutate()` step from the
    code above? What does `rel_by_region` look like then? What if we remove the `summarize()`
    step? How big is the table returned at each step? What level of grouping is it
    at? What variables have been added or removed?
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前说过，在尝试理解`ggplot()`序列中的每个添加步骤时，逆向工作，一次移除一个部分，看看当这一步不包括在内时，图表看起来像什么，这可能会很有帮助。同样，在查看管道代码时，从行的末尾开始，然后一次移除一个“`%>%`”步骤，看看结果的中介对象看起来像什么，这可能会很有帮助。例如，如果我们从上面的代码中移除`mutate()`步骤会怎样？那时`rel_by_region`看起来会怎样？如果我们移除`summarize()`步骤呢？每一步返回的表格有多大？它处于哪个分组级别？哪些变量被添加或移除了？
- en: 'Plots that do not require sequential aggregation and transformation of the
    data before they are displayed are usually easy to write directly in ggplot, as
    the details of the layout are handled by a combination of mapping variables and
    layering geoms. One-step filtering or aggregation of the data (such as calculating
    a proportion, or a specific subset of observations) is also straightforward. But
    when the result we want to display is several steps removed from the data, and
    in particular when we want to group or aggregate a table and do some more calculations
    on the result before drawing anything, then it can make sense to use dplyr’s tools
    to produce these summary tables first. This is true even if would also be possible
    to do it within a `ggplot()` call. In addition to making our code easier to read,
    it lets us more easily perform sanity checks on our results, so that we are sure
    we have grouped and summarized things in the right order. For instance, if we
    have done things properly with `rel_by_region`, the `pct` values associated with
    `religion` should sum to 100 within each region, perhaps with a bit of rounding
    error. We can quickly check this using a very short pipeline, too:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要在进行显示之前对数据进行顺序聚合和转换的图表通常可以直接在ggplot中编写，因为布局的细节是由映射变量和层叠geom的组合来处理的。对数据进行一步过滤或聚合（例如计算比例或特定观察值的子集）也是直接的。但是，当我们想要显示的结果与数据相隔几个步骤，尤其是当我们想要对表格进行分组或聚合并在绘制任何内容之前进行一些计算时，使用dplyr的工具来首先生成这些汇总表是有意义的。即使我们也可以在`ggplot()`调用中完成它。除了使我们的代码更容易阅读外，它还让我们更容易对我们的结果进行合理性检查，以确保我们以正确的顺序对事物进行了分组和汇总。例如，如果我们正确地使用了`rel_by_region`，与`religion`相关的`pct`值在每个地区内应该总和为100，可能有一些舍入误差。我们也可以使用一个非常短的管道快速检查这一点：
- en: '[PRE47]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This looks good. As before, now that we are working directly with percentage
    values in a summary table, we can use `geom_col()` instead of `geom_bar()`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不错。和之前一样，现在我们直接在汇总表中工作，使用百分比值，我们可以使用`geom_col()`而不是`geom_bar()`。
- en: '![Religious preferences by Region.](../Images/215092b752bc49a696e9556855685408.png)
    Figure 5.2: Religious preferences by Region.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![按地区划分的宗教偏好](../Images/215092b752bc49a696e9556855685408.png) 图5.2：按地区划分的宗教偏好。'
- en: '[PRE49]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We use a different `position` argument here, `dodge2` instead of `dodge`. This
    puts the bars side by side. When dealing with pre-computed values in `geom_col()`,
    the default `position` is to make a proportionally stacked column chart. If you
    use `dodge` they will be stacked within columns but the result will read incorrectly.
    Using `dodge2` puts the sub-categories (religious affiliations) side-by-side within
    groups (regions).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了一个不同的`position`参数，`dodge2`而不是`dodge`。这使条形并排放置。当处理`geom_col()`中的预计算值时，默认的`position`是制作一个成比例堆叠的柱状图。如果你使用`dodge`，它们将在列内堆叠，但结果将读起来不正确。使用`dodge2`将子类别（宗教归属）在组（地区）内并排放置。
- en: The values in this bar chart are the percentage equivalents to the stacked counts
    in Figure [4.10](groupfacettx.html#fig:ch-04-gss-06). Religious affiliations sum
    to 100 percent within region. The trouble is, although we now know how to cleanly
    produce frequency tables, this is still a bad figure. It is too crowded, with
    too many bars side-by-side. We can do better.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此条形图中的值是图[4.10](groupfacettx.html#fig:ch-04-gss-06)中堆叠计数百分比等价。宗教归属在每个地区内总和为100%。问题是，尽管我们现在知道如何干净地生成频率表，但这仍然是一个糟糕的图表。它太拥挤了，有太多的条形并排。我们可以做得更好。
- en: As a rule, dodged charts can be more cleanly expressed as faceted plots. This
    removes the need for a legend, and thus makes the chart simpler to read. We also
    introduce a new function. If we map religion to the x-axis, the labels will overlap
    and become illegible. It’s possible to manually adjust the tick mark labels so
    that they are printed at an angle, but that isn’t so easy to read, either. It
    makes more sense to put the religions on the y-axis and the percent scores on
    the x-axis. Because of the way `geom_bar()` works internally, simply swapping
    the `x` and `y` mapping will not work. (Try it and see what happens.) What we
    do instead is to transform the *coordinate system* that the results are plotted
    in, so that the x and y axes are flipped. We do this with `coord_flip()`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，错位图表可以更清晰地表达为分面图。这消除了对图例的需求，因此使图表更易于阅读。我们还引入了一个新函数。如果我们把宗教映射到x轴，标签将重叠并变得难以辨认。手动调整刻度标签以使其以角度打印是可能的，但这也不容易阅读。将宗教放在y轴上，将百分比分数放在x轴上更有意义。由于`geom_bar()`内部的工作方式，简单地交换`x`和`y`映射将不起作用。（试一试，看看会发生什么。）我们实际上是对结果绘制在其中的*坐标系*进行转换，以便x轴和y轴翻转。我们使用`coord_flip()`来完成这项工作。
- en: '[PRE50]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '![Religious preferences by Region, faceted version.](../Images/004dec05a264c8e45176131cd621f9b9.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![宗教偏好按地区划分，分面版本](../Images/004dec05a264c8e45176131cd621f9b9.png)'
- en: 'Figure 5.3: Religious preferences by Region, faceted version.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：宗教偏好按地区划分，分面版本。
- en: For most plots the coordinate system is cartesian, showing plots on a plane
    defined by an x-axis and a y-axis. The `coord_cartesian()` function manages this,
    but we don’t need to call it. The `coord_flip()` function switches the x and y
    axes after the plot is made. It does not remap variables to aesthetics. In this
    case, `religion` is still mapped to `x` and `pct` to `y`. Because the religion
    names do not need an axis label to be understood, we set `x = NULL` in the `labs()`
    call.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数图表，坐标系是笛卡尔坐标系，显示由x轴和y轴定义的平面上的图表。`coord_cartesian()`函数管理这一点，但我们不需要调用它。`coord_flip()`函数在绘制图表后切换x轴和y轴。它不会重新映射变量到美学。在这种情况下，`religion`仍然映射到`x`，`pct`映射到`y`。由于宗教名称不需要轴标签就能理解，我们在`labs()`调用中设置`x
    = NULL`。
- en: We will see more of what dplyr’s grouping and filtering operations can do later.
    It is a flexible and powerful framework. For now, think of it as a way to quickly
    summarize tables of data without having to write code in the body of our `ggplot()`
    or `geom_` functions.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后看到dplyr的分组和过滤操作能做什么。它是一个灵活且强大的框架。目前，将其视为一种快速总结数据表的方法，而无需在我们的`ggplot()`或`geom_`函数的主体中编写代码。
- en: 5.2 Continuous variables by group or category
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 按组或类别划分的连续变量
- en: Let’s move to a new dataset, the `organdata` table. Like `gapminder`, it has
    a country-year structure. It contains a little more than a decade’s worth of information
    on the donation of organs for transplants in seventeen OECD countries. The organ
    procurement rate is a measure of the number of human organs obtained from cadaver
    organ donors for use in transplant operations. Along with this donation data,
    the dataset has a variety of numerical demographic measures, and several categorical
    measures of health and welfare policy and law. Unlike the `gapminder` data, some
    observations are missing. These are designated with a value of `NA`, R’s standard
    code for missing data. The `organdata` table is included in the `socviz` library.
    Load it up and take a quick look. Instead of using `head()`, for variety this
    time we will make a short pipeline to select the first six columns of the dataset,
    and then pick five rows at random using a function called `sample_n()`. This function
    takes two main arguments. First we provide the table of data we want to sample
    from. Because we are using a pipeline, this is implicitly passed down from the
    beginning of the pipe. Then we supply the number of draws we want to make.Using
    numbers this way in `select()` chooses the numbered columns of the data frame.
    You can also select variable names directly.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到一个新的数据集，`organdata` 表。像 `gapminder` 一样，它有一个国家-年份结构。它包含关于十七个 OECD 国家器官移植捐赠超过十年的信息。器官采购率是衡量从尸体器官捐赠者获得的人体器官数量，用于移植手术的指标。除了捐赠数据外，该数据集还包含各种数值人口统计指标，以及健康和福利政策与法律的几个分类指标。与
    `gapminder` 数据不同，一些观察值是缺失的。这些用 `NA` 值表示，这是 R 的标准缺失数据代码。`organdata` 表包含在 `socviz`
    库中。加载它并快速查看。这次我们不会使用 `head()`，为了变化，我们将制作一个简短的管道来选择数据集的前六列，然后使用一个名为 `sample_n()`
    的函数随机选择五行。这个函数有两个主要参数。首先，我们提供我们想要从中抽取数据的表格。因为我们使用管道，所以这隐式地从管道的开始传递下来。然后我们提供我们想要抽取的数字。在
    `select()` 中使用这种方式选择数据框的编号列。你还可以直接选择变量名。
- en: '[PRE51]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Lets’s start by naively graphing some of the data. We can take a look at a scatterplot
    of donors vs year.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先天真地绘制一些数据。我们可以查看捐赠者与年份的散点图。
- en: '![Not very informative.](../Images/8a6a1259ee0fd826e0f9513be05f79d3.png) Figure
    5.4: Not very informative.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![信息量不大。](../Images/8a6a1259ee0fd826e0f9513be05f79d3.png) 图 5.4：信息量不大。'
- en: '[PRE53]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: A message from ggplot warns you about the missing values. We’ll suppress this
    warning from now on, so that it doesn’t clutter the output, but in general it’s
    wise to read and understand the warnings that R gives, even when code appears
    to run properly. If there are a large number of warnings, R will collect them
    all and invite you to view them with the `warnings()` function.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ggplot 发出一个消息，警告你关于缺失值。从现在开始，我们将抑制这个警告，以免输出混乱，但一般来说，阅读和理解 R 给出的警告是明智的，即使代码看起来运行正常。如果有大量警告，R
    将收集它们，并邀请你使用 `warnings()` 函数查看。
- en: We could use `geom_line()` to plot each country’s time series, like we did with
    the gapminder data. To do that, remember, we need to tell ggplot what the grouping
    variable is. This time we can also facet the figure by country, as we do not have
    too many of them.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `geom_line()` 来绘制每个国家的时间序列，就像我们在 gapminder 数据中做的那样。要做到这一点，记住，我们需要告诉 ggplot
    分组变量是什么。这次我们也可以按国家分面图，因为我们没有太多国家。
- en: '![A faceted line plot.](../Images/2b99e6558ebdda27d7c48cbb953eb8fa.png) Figure
    5.5: A faceted line plot.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '![分面线图。](../Images/2b99e6558ebdda27d7c48cbb953eb8fa.png) 图 5.5：分面线图。'
- en: '[PRE55]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: By default the facets are ordered alphabetically by country. We will see how
    to change this momentarily.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，分面图是按国家字母顺序排序的。我们将稍后展示如何更改这一点。
- en: Let’s focus on the country-level variation, but without paying attention to
    the time trend. We can use `geom_boxplot()` to get a picture of variation by year
    across countries. Just as `geom_bar()` by default calculates a count of observations
    by the category you map to `x`, the `stat_boxplot()` function that works with
    `geom_boxplot()` will calculate a number of statistics that allow the box and
    whiskers to be drawn. We tell `geom_boxplot()` the variable we want to categorize
    by (here, `country`) and the continuous variable we want summarized (here, `donors`)
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注国家层面的变化，但不要关注时间趋势。我们可以使用 `geom_boxplot()` 来获取各国年度变化的图像。正如 `geom_bar()`
    默认情况下会根据你映射到 `x` 的类别计算观察值的数量一样，与 `geom_boxplot()` 一起工作的 `stat_boxplot()` 函数将计算一系列统计量，这些统计量允许绘制箱线和须线。我们告诉
    `geom_boxplot()` 我们想要按什么变量进行分类（在这里，`country`）以及我们想要汇总的连续变量（在这里，`donors`）
- en: '![A first attempt at boxplots by country.](../Images/e451458bc9c750df1e711b18dbf06767.png)
    Figure 5.6: A first attempt at boxplots by country.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![按国家绘制箱线图的第一尝试](../Images/e451458bc9c750df1e711b18dbf06767.png) 图5.6：按国家绘制箱线图的第一尝试。'
- en: '[PRE56]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The boxplots look interesting but two issues could be addressed. First, as we
    saw in the previous chapter, it is awkward to have the country names on the x-axis
    because the labels will overlap. We use `coord_flip()` again to switch the axes
    (but not the mappings).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 箱线图看起来很有趣，但有两个问题可以解决。首先，正如我们在上一章看到的，将国家名称放在x轴上显得有些尴尬，因为标签会重叠。我们再次使用`coord_flip()`来切换坐标轴（但不切换映射）。
- en: '![Moving the countries to the y-axis.](../Images/3b584e8c67dab2c11385972d18069b5f.png)
    Figure 5.7: Moving the countries to the y-axis.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![将国家移动到y轴](../Images/3b584e8c67dab2c11385972d18069b5f.png) 图5.7：将国家移动到y轴。'
- en: '[PRE57]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'That’s more legible but still not ideal. We generally want our plots to present
    data in some meaningful order. An obvious way is to have the countries listed
    from high to low average donation rate. We accomplish this by reordering the `country`
    variable by the mean of `donors.` The `reorder()` function will do this for us.
    It takes two required arguments. The first is the categorical variable or factor
    that we want to reorder. In this case, that’s `country`. The second is the variable
    we want to reorder it by. Here that is the donation rate, `donors`. The third
    and optional argument to `reorder()` is the function you want to use as a summary
    statistic. If you only give `reorder()` the first two required arguments, then
    by default it will reorder the categories of your first variable by the mean value
    of the second. You can name any sensible function you like to reorder the categorical
    variable (e.g., `median`, or `sd`). There is one additional wrinkle. In R, the
    default `mean` function will fail with an error if there are missing values in
    the variable you are trying to take the average of. You must say that it is OK
    to remove the missing values when calculating the mean. This is done by supplying
    the `na.rm=TRUE` argument to `reorder()`, which internally passes that argument
    on to `mean()`. We are reordering the variable we are mapping to the `x` aesthetic,
    so we use `reorder()` at that point in our code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这样看起来更清晰，但仍然不是理想的。我们通常希望我们的图表以某种有意义的方式呈现数据。一种明显的方法是将国家按平均捐赠率从高到低列出。我们通过按`donors`的平均值重新排序`country`变量来实现这一点。`reorder()`函数会为我们完成这项工作。它需要两个必需的参数。第一个是我们想要重新排序的分类变量或因子。在这种情况下，那就是`country`。第二个是我们想要按其重新排序的变量。这里就是捐赠率，`donors`。`reorder()`的第三个和可选参数是你想要用作汇总统计函数的函数。如果你只给`reorder()`提供前两个必需参数，那么默认情况下，它将按第二个变量的平均值重新排序第一个变量的类别。你可以命名任何合理的函数来重新排序分类变量（例如，`median`或`sd`）。还有一个额外的细节。在R中，如果变量中有缺失值，默认的`mean`函数将因错误而失败。你必须说明在计算平均值时可以删除缺失值。这是通过向`reorder()`提供`na.rm=TRUE`参数来完成的，该参数内部将此参数传递给`mean()`。我们正在重新排序映射到`x`美学的变量，因此我们在代码中使用`reorder()`：
- en: '[PRE58]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '![Boxplots reordered by mean donation rate.](../Images/303d95e0edeba02ff11d09e70bc320f9.png)
    Figure 5.8: Boxplots reordered by mean donation rate.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '![按平均捐赠率重新排序的箱线图](../Images/303d95e0edeba02ff11d09e70bc320f9.png) 图5.8：按平均捐赠率重新排序的箱线图。'
- en: Because it’s obvious what the country names are, in the `labs()` call we set
    their axis label to empty with `labs(x=NULL)`. Ggplot offers some variants on
    the basic boxplot, including the violin plot. Try it with `geom_violin()`. There
    are also numerous arguments that control the finer details of the boxes and whiskers,
    including their width. Boxplots can also take `color` and `fill` aesthetic mappings
    like other geoms.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 由于国家名称很明显，在`labs()`调用中，我们将它们的轴标签设置为空，使用`labs(x=NULL)`。Ggplot提供了基本的箱线图的一些变体，包括小提琴图。尝试使用`geom_violin()`。还有许多参数可以控制箱子和胡须的更精细的细节，包括它们的宽度。箱线图也可以像其他几何对象一样接受`color`和`fill`美学映射。
- en: '[PRE59]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Figure 5.9: A boxplot with the fill aesthetic mapped.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9：具有填充美学的箱线图。
- en: '![A boxplot with the fill aesthetic mapped.](../Images/0ec40145582f9a93b39249c1a11f8e55.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![具有填充美学的箱线图](../Images/0ec40145582f9a93b39249c1a11f8e55.png)'
- en: Putting categorical variables on the y-axis to compare their distributions is
    a very useful trick. Its makes it easy to effectively present summary data on
    more categories. The plots can be quite compact and fit a relatively large number
    of cases in by row. The approach also has the advantage of putting the variable
    being compared onto the x-axis, which sometimes makes it easier to compare across
    categories. If the number of observations within each categoriy is relatively
    small, we can skip (or supplement) the boxplots and show the individual observations,
    too. In this next example we map the `world` variable to `color` instead of `fill`
    as the default `geom_point()` plot shape has a color attribute, but not a fill.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 将分类变量放在 y 轴上以比较它们的分布是一个非常实用的技巧。这使得有效地展示更多类别的汇总数据变得容易。这些图可以相当紧凑，并且可以通过行来容纳相对大量的案例。这种方法的优势在于将比较的变量放在
    x 轴上，这有时会使得跨类别比较更容易。如果每个类别内的观察值数量相对较小，我们可以跳过（或补充）箱线图，并显示个别观察值。在下一个例子中，我们将 `world`
    变量映射到 `color` 而不是默认的 `geom_point()` 图形形状的 `fill`，因为默认的 `geom_point()` 图形具有颜色属性，但没有填充属性。
- en: '![Using points instead of a boxplot.](../Images/ee3d7de1c71b47df463cd41a77952b9e.png)
    Figure 5.10: Using points instead of a boxplot.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用点而不是箱线图。](../Images/ee3d7de1c71b47df463cd41a77952b9e.png) 图 5.10：使用点而不是箱线图。'
- en: '[PRE60]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: When we use `geom_point()` like this, there is some overplotting of observations.
    In these cases, it can be useful to perturb the data just a little bit in order
    to get a better sense of how many observations there are at different values.
    We use `geom_jitter()` to do this. This geom works much like `geom_point()`, but
    randomly nudges each observation by a small amount.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `geom_point()` 如此操作时，观察值之间会有一些重叠。在这些情况下，对数据进行一点微小的扰动可能会有助于更好地了解在不同值上存在多少观察值。我们使用
    `geom_jitter()` 来实现这一点。这个几何形状与 `geom_point()` 非常相似，但它会随机地将每个观察值微调一小段距离。
- en: '![Jittering the points.](../Images/bc484a1d7342a9dabffc983284087891.png) Figure
    5.11: Jittering the points.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '![抖动点。](../Images/bc484a1d7342a9dabffc983284087891.png) 图 5.11：抖动点。'
- en: '[PRE61]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The default amount of jitter is a little too much for our purposes. We can control
    it using `height` and `width` arguments to a `position_jitter()` function within
    the geom. Because we’re making a one-dimensional summary here, we just need `width`.Can
    you see why we did not use height? If not, try it and see what happens.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的抖动量对于我们的目的来说有点过多。我们可以通过在几何形状中的 `position_jitter()` 函数中使用 `height` 和 `width`
    参数来控制它。因为我们在这里制作的是一维汇总，所以我们只需要 `width`。你能看出为什么我们没有使用 `height` 吗？如果不能，试着试试看会发生什么。
- en: '[PRE62]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Figure 5.12: A jittered plot.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12：一个抖动图。
- en: '![A jittered plot.](../Images/3962f4a2a83430505c2d11a495b5584b.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![一个抖动图。](../Images/3962f4a2a83430505c2d11a495b5584b.png)'
- en: When we want to summarize a categorical variable that just has one point per
    category, we should use this approach as well. The result will be a Cleveland
    dotplot, a simple and extremely effective method of presenting data that is usually
    better than either a bar chart or a table. For example, we can make a Cleveland
    dotplot of the average donation rate.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要汇总一个每个类别只有一个点的分类变量时，我们也应该使用这种方法。结果将是一个克利夫兰点图，这是一种简单而极其有效的展示数据的方法，通常比条形图或表格更好。例如，我们可以制作一个平均捐赠率的克利夫兰点图。
- en: 'This also gives us another opportunity to do a little bit of data munging with
    a dplyr pipeline. We will use one to aggregate our larger country-year data frame
    to a smaller table of summary statistics by country. There is more than one way
    to do pipeline this task. We could choose the variables we want to summarize and
    then repeatedly use the `mean()` and `sd()` functions to calculate the means and
    standard deviations of the variables we want. We will again use the pipe operator,
    `%>%`, to do our work:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这也给了我们另一个机会，使用 dplyr 管道进行一点数据整理。我们将使用一个管道来将较大的国家-年份数据框聚合到一个较小的按国家汇总的统计表。完成这个管道任务的方法不止一种。我们可以选择要汇总的变量，然后反复使用
    `mean()` 和 `sd()` 函数来计算我们想要的变量的平均值和标准差。我们再次使用管道操作符 `%>%` 来完成我们的工作：
- en: '[PRE63]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The pipeline consists of two steps. First we group the data by `consent_law`
    and `country`, and then use `summarize()` to create six new variables, each one
    of which is the mean or standard deviation of each country’s score on a corresponding
    variable in the original `organdata` data frame.For an alternative view, change
    `country` to `year` in the grouping statement and see what happens.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 该流程包括两个步骤。首先，我们按 `consent_law` 和 `country` 对数据进行分组，然后使用 `summarize()` 创建六个新变量，每个变量都是每个国家在原始
    `organdata` 数据框中对应变量的平均值或标准差。为了获得不同的视角，在分组语句中将 `country` 改为 `year`，看看会发生什么。
- en: 'As usual, `summarize()` step, will inherit information about the original data
    and the grouping, and then do its calculations at the innermost grouping level.
    In this case it takes all the observations for each country and calculates the
    mean or standard deviation as requested. Here is what the resulting object looks
    like:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`summarize()` 步骤将继承有关原始数据和分组的信息，然后在最内层的分组级别进行计算。在这种情况下，它为每个国家取所有观测值，并按请求计算平均值或标准差。以下是结果对象的外观：
- en: '[PRE64]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: As before, the variables specified in `group_by()` are retained in the new data
    frame, the variables created with `summarize()` are added, and all the other variables
    in the original data are dropped. The countries are also summarized alphabetically
    within `consent_law`, which was the outermost grouping variable in the `group_by()`
    statement at the start of the pipeline.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如同以往，`group_by()` 中指定的变量将保留在新数据框中，使用 `summarize()` 创建的变量将被添加，原始数据中的所有其他变量将被删除。国家在
    `consent_law` 内按字母顺序汇总，这是管道开始时的 `group_by()` 语句中最外层的分组变量。
- en: Using our pipeline this way is reasonable, but the code is worth looking at
    again. For one thing, we have to repeatedly type out the names of the `mean()`
    and `sd()` functions and give each of them the name of the variable we want summarized
    *and* the `na.rm = TRUE` argument each time to make sure the functions don’t complain
    about missing values. We also repeatedly name our new summary variables in the
    same way, by adding `_mean` or `_sd` to the end of the original variable name.
    If we wanted to calculate the mean and standard deviation for all the numerical
    variables in `organdata`, our code would get even longer. Plus, in this version
    we lose the other, time-invariant categorical variables that we haven’t grouped
    by, such as `world`. When we see repeated actions like this in our code, we can
    ask whether there’s a better way to proceed.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用我们的流程是合理的，但代码值得再次审视。一方面，我们必须反复输入 `mean()` 和 `sd()` 函数的名称，并且每次都要给出我们想要汇总的变量的名称以及
    `na.rm = TRUE` 参数，以确保函数不会对缺失值发出抱怨。我们同样以相同的方式反复命名我们的新汇总变量，即在原始变量名称的末尾添加 `_mean`
    或 `_sd`。如果我们想要计算 `organdata` 中所有数值变量的平均值和标准差，我们的代码将会更长。此外，在这个版本中，我们失去了那些我们没有按其分组的其他时间不变的分类变量，例如
    `world`。当我们看到代码中这种重复的操作时，我们可以问自己是否有更好的处理方式。
- en: 'There is. What we would like to do is apply the `mean()` and `sd()` functions
    to every numerical variable in `organdata`, but *only* the numerical ones. Then
    we want to name the results in a consistent way, and return a summary table including
    all the categorical variables like `world`. We can create a better version of
    the `by_country` object using a little bit of R’s functional programming abilities.
    Here is the code:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 确实存在。我们想要做的是将 `mean()` 和 `sd()` 函数应用于 `organdata` 中的每一个数值变量，但**仅限**数值变量。然后我们希望以一致的方式命名结果，并返回一个包含所有分类变量，如
    `world` 的汇总表。我们可以利用一点 R 的函数式编程能力来创建一个更好的 `by_country` 对象版本。以下是代码：
- en: '[PRE66]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The pipeline starts off just as before, taking `organdata` and then grouping
    it by `consent_law` and `country`. In the next step, though, instead of manually
    taking the mean and standard deviation of a subset of variables, we use the `summarize_if()`
    function instead. As its name suggests, it examines each column in our data and
    applies a test to it. It only summarizes if the test is passed, that is, if it
    returns a value of `TRUE`.We do not have to use parentheses when naming the functions
    inside `summarize_if()`. Here the test is the function `is.numeric()`, which looks
    to see if a vector is a numeric value or not. If it is, then `summarize_if()`
    will apply the summary function or functions we want to `organdata`. Because we
    are taking both the mean and the standard deviation, we use `funs()` to list the
    functions we want to use. And we finish with the `na.rm = TRUE` argument, which
    will be passed on to each use of both `mean()` and `sd()`. In the last step in
    the pipeline we `ungroup()` the dataSometimes graphing functions can get confused
    by grouped tibbles where we don’t explicitly use the groups in the plot., so that
    the result is a plain tibble.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 管道开始的方式与之前相同，先取 `organdata`，然后按 `consent_law` 和 `country` 进行分组。然而，在下一步中，我们不是手动取一组变量的均值和标准差，而是使用
    `summarize_if()` 函数。正如其名称所暗示的，它检查我们数据中的每一列，并对它进行测试。只有当测试通过时，即返回值为 `TRUE` 时，才会进行汇总。我们不需要在
    `summarize_if()` 内部命名函数时使用括号。这里测试是函数 `is.numeric()`，它检查一个向量是否是数值值。如果是，那么 `summarize_if()`
    将应用我们想要的汇总函数或函数到 `organdata`。因为我们同时取均值和标准差，所以我们使用 `funs()` 列出我们想要使用的函数。并且我们以 `na.rm
    = TRUE` 参数结束，这个参数将被传递给 `mean()` 和 `sd()` 的每次使用。在管道的最后一步中，我们 `ungroup()` 数据，有时绘图函数会混淆分组
    tibbles，其中我们没有在图表中明确使用组，因此结果是普通的 tibble。
- en: 'Here is what the pipeline returns:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这是管道返回的内容：
- en: '[PRE67]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'All the numeric variables have been summarized. They are named using the original
    variable, with the function’s name appended: `donors_mean` and `donors_sd`, and
    so on. This is a compact way to rapidly transform our data in various ways. There
    is a family of `summarize_` functions for various tasks, and a complementary group
    of `mutate_` functions for when we want to add columns to the data rather than
    aggregated it.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数值变量都已汇总。它们使用原始变量命名，并附加函数名称：`donors_mean` 和 `donors_sd` 等。这是一种快速以各种方式转换我们数据的方法。有一系列
    `summarize_` 函数用于各种任务，以及一组互补的 `mutate_` 函数，当我们想要向数据中添加列而不是聚合它时使用。
- en: With our data summarized by country, we can draw a dotplot with `geom_point()`.
    Let’s also color the results by the consent law for each country.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按国家汇总我们的数据，我们可以使用 `geom_point()` 绘制点图。让我们也按每个国家的同意法对结果进行着色。
- en: '![A Cleveland dotplot, with colored points.](../Images/54fe19bef527864af0679a092193b9cc.png)
    Figure 5.13: A Cleveland dotplot, with colored points.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '![克利夫兰点图，带有彩色点。](../Images/54fe19bef527864af0679a092193b9cc.png) 图 5.13：克利夫兰点图，带有彩色点。'
- en: '[PRE69]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Alternatively, if we liked, we could use a facet instead of coloring the points.
    Using `facet_wrap()` we can split the `consent_law` variable into two panels,
    and then rank the countries by donation rate within each panel. Because we have
    a categorical variable on our y-axis, there are two wrinkles worth noting. First,
    if we leave `facet_wrap()` to its defaults, the panels will be plotted side by
    side. This will make it difficult to compare the two groups on the same scale.
    Instead the plot will be read left to right, which is not useful. To avoid this,
    we will have the panels appear one on top of the other by saying we only want
    toq have one column. This is the `ncol=1` argument. Second, and again because
    we have a categorical variable on the y-axis, the default facet plot will have
    the names of every country appear on the y-axis of *both* panels. (Were the y-axis
    a continuous variable this would be the what we would want.) In that case, only
    half the rows in each panel of our plot will have points in them.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们愿意的话，我们可以使用面元而不是给点着色。使用 `facet_wrap()` 我们可以将 `consent_law` 变量分成两个面板，然后在每个面板内按捐赠率对国家进行排名。因为我们
    y 轴上有一个分类变量，有两个值得注意的细节。首先，如果我们让 `facet_wrap()` 保持默认设置，面板将并排绘制。这将使得比较同一尺度上的两组变得困难。相反，图表将从左到右读取，这并不实用。为了避免这种情况，我们将面板设置为一个叠在另一个上面，通过说我们只想有一列。这是
    `ncol=1` 参数。其次，同样因为我们在 y 轴上有一个分类变量，默认的面元图将在两个面板的 y 轴上显示每个国家的名称。（如果 y 轴是一个连续变量，这将是我们想要的。）在这种情况下，我们图表的每个面板中只有一半的行会有点。
- en: To avoid this we allow the y-axes scale to be free. This is the `scales="free_y"`
    argument. Again, for faceted plots where both variables are continuous, we generally
    do not want the scales to be free, because it allows the x- or y-axis for each
    panel to vary with the range of the data inside that panel only, instead of the
    range across the whole dataset. Ordinarily, the point of small-multiple facets
    is to be able to compare across the panels. This means free scales are usually
    not a good idea, because each panel gets its own x- or y-axis range, which breaks
    comparability. But where one axis is categorical, as here, we can free the categorical
    axis and leave the continuous one fixed. The result is that each panel shares
    the same x-axis, and it is easy to compare between them.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们允许 y 轴的刻度自由。这是 `scales="free_y"` 参数。同样，对于面图，其中两个变量都是连续的，我们通常不希望刻度是自由的，因为这允许每个面板的
    x 或 y 轴仅根据该面板内部的数据范围变化，而不是整个数据集的范围。通常，小面板的目的是能够跨面板进行比较。这意味着自由刻度通常不是一个好主意，因为每个面板都会得到自己的
    x 或 y 轴范围，这会破坏可比性。但是，当其中一个轴是分类的，就像这里一样，我们可以使分类轴自由，而将连续轴固定。结果是每个面板共享相同的 x 轴，并且很容易在它们之间进行比较。
- en: '![A faceted dotplot with free scales on the y-axis.](../Images/f23ad812ec7dc45c1eb758591a5bc983.png)
    Figure 5.14: A faceted dotplot with free scales on the y-axis.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '![一个具有自由 y 轴刻度的面图点状图。](../Images/f23ad812ec7dc45c1eb758591a5bc983.png) 图 5.14：一个具有自由
    y 轴刻度的面图点状图。'
- en: '[PRE70]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Cleveland dotplots are generally preferred to bar or column charts. When making
    them, put the categories on the y-axis and order them in the way that is most
    relevant to the numerical summary you are providing. This sort of plot is also
    an excellent way to summarize model results or any data with with error ranges.
    We use `geom_point()` to draw our dotplots. There is a geom called `geom_dotplot()`,
    but it is designed to produce a different sort of figure. It is a kind of histogram,
    with individual observations represented by dots that are then stacked on top
    of one another to show how many of them there are.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Cleveland 点状图通常比条形图或柱状图更受欢迎。在制作它们时，将类别放在 y 轴上，并按与您提供的数值摘要最相关的顺序排列。这种图表也是总结模型结果或任何具有误差范围的数据的绝佳方式。我们使用
    `geom_point()` 来绘制我们的点状图。还有一个名为 `geom_dotplot()` 的几何对象，但它被设计成产生不同类型的图形。它是一种直方图，通过将点堆叠在一起来表示单个观测值，以显示有多少个这样的点。
- en: The Cleveland-style dotplot can be extended to cases where we want to include
    some information about variance or error in the plot. Using `geom_pointrange()`,
    we can tell ggplot to show us a point estimate and a range around it. Here we
    will use the standard deviation of the donation rate that we calculated above.
    But this is also the natural way to present, for example, estimates of model coefficients
    with confidence intervals. With `geom_pointrange()` we map our `x` and `y` variables
    as usual, but the function needs a little more information than `geom_point`.
    It needs to know the range of the line to draw on either side of the point, defined
    by the arguments `ymax` and `ymin`. This is given by the y value (`donors_mean`)
    plus or minus its standard deviation (`donors_sd`). If a function argument expects
    a number, it is OK to give it a mathematical expression that resolves to the number
    you want. R will calculate the result for you.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Cleveland 风格的点状图可以扩展到我们想要在图中包含关于方差或误差的一些信息的情况。使用 `geom_pointrange()`，我们可以告诉
    ggplot 显示给我们一个点估计及其周围的范围。这里我们将使用我们上面计算出的捐赠率的方差。但这也是以置信区间呈现模型系数估计的自然方式。使用 `geom_pointrange()`，我们像往常一样映射
    `x` 和 `y` 变量，但该函数需要比 `geom_point()` 更多一点信息。它需要知道在点两侧绘制线的范围，由参数 `ymax` 和 `ymin`
    定义。这由 y 值（`donors_mean`）加减其标准差（`donors_sd`）给出。如果一个函数参数期望一个数字，你可以给它一个数学表达式，该表达式解析为你想要的数字。R
    会为你计算结果。
- en: '[PRE71]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Figure 5.15: A dot-and-whisker plot, with the range defined by the standard
    deviation of the measured variable.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15：一个点状和须状图，其范围由测量变量的标准差定义。
- en: '![A dot-and-whisker plot, with the range defined by the standard deviation
    of the measured variable.](../Images/952e4fd0cb72b9c57a8b9aa4a0a54573.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![一个点状和须状图，其范围由测量变量的标准差定义。](../Images/952e4fd0cb72b9c57a8b9aa4a0a54573.png)'
- en: Because `geom_pointrange()` expects `y`, `ymin`, and `ymax` as arguments, we
    map `donors_mean` to `y` and the `ccode` variable to `x`, then flip the axes at
    the end with `coord_flip()`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `geom_pointrange()` 需要参数 `y`、`ymin` 和 `ymax`，所以我们把 `donors_mean` 映射到 `y`，把
    `ccode` 变量映射到 `x`，然后在最后使用 `coord_flip()` 翻转坐标轴。
- en: 5.3 Plot text directly
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 直接绘制文本
- en: It can sometimes be useful to plot the labels along with the points in a scatterplot,
    or just plot informative labels directly. We can do this with `geom_text()`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在散点图中绘制标签与点一起，或者直接绘制信息标签可能会有用。我们可以使用`geom_text()`来实现这一点。
- en: '![Plotting labels and text.](../Images/98e62e9b42d105ddde8909e3548704e4.png)
    Figure 5.16: Plotting labels and text.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '![绘制标签和文本。](../Images/98e62e9b42d105ddde8909e3548704e4.png) 图5.16：绘制标签和文本。'
- en: '[PRE72]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The text is plotted right on top of the points, because both are positioned
    using the same x and y mapping. One way of dealing with this, often the most effective
    if we are not too worried about excessive precision in the graph, is to remove
    the points by dropping `geom_point()` from the plot. A second option is to adjust
    the position of the text. We can left- or right-justify the labels using the `hjust`
    argument to `geom_text()`. Setting `hjust=0` will left justify the label, and
    `hjust=1` will right justify it.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 文本直接绘制在点上方，因为它们都是使用相同的x和y映射来定位的。处理这个问题的一种方法，通常在不太担心图形中过度精确的情况下是最有效的，就是通过从图形中删除`geom_point()`来移除点。第二种选择是调整文本的位置。我们可以使用`geom_text()`的`hjust`参数来左对齐或右对齐标签。将`hjust=0`设置为左对齐标签，而`hjust=1`将右对齐它。
- en: '[PRE73]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You might be tempted to try different values to `hjust` to fine-tune your labels.
    But this is not a robust approach. It will often fail because the space is added
    in proportion to the length of the label. The result is that longer labels move
    further away from their points than you want. There are ways around this, but
    they introduce other problems.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想尝试不同的`hjust`值来微调你的标签。但这并不是一个稳健的方法。它通常会失败，因为空间是按标签长度的比例添加的。结果是，较长的标签会比你想的更远离它们对应的点。有绕过这个问题的方法，但它们会引入其他问题。
- en: '![Plot points and text labels, with a horizontal position adjustment.](../Images/13eb6a51f767063ac5af3c89c8c60bea.png)
    Figure 5.17: Plot points and text labels, with a horizontal position adjustment.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '![绘制点和文本标签，并进行水平位置调整。](../Images/13eb6a51f767063ac5af3c89c8c60bea.png) 图5.17：绘制点和文本标签，并进行水平位置调整。'
- en: 'Instead of wrestling any further with `geom_text()`, we will use `ggrepel`
    instead. This very useful library adds some new geoms to ggplot. Just as `ggplot`
    extends the plotting capabilities of R, there are many small libraries that extend
    the capabilities of `ggplot`, often by providing some new type of `geom`. The
    `ggrepel` library provides `geom_text_repel()` and `geom_label_repel()`, two geoms
    that can pick out labels much more flexibly than the default `geom_text()`. First,
    make sure the library is installed, then load it in the usual way:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不再与`geom_text()`纠缠，而是使用`ggrepel`。这个非常有用的库为ggplot添加了一些新的几何形状。就像`ggplot`扩展了R的绘图功能一样，有许多小型库通过提供某种新的`geom`类型来扩展`ggplot`的功能。`ggrepel`库提供了`geom_text_repel()`和`geom_label_repel()`，这两种几何形状可以比默认的`geom_text()`更灵活地挑选出标签。首先，确保库已安装，然后以通常的方式加载它：
- en: '[PRE74]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We will use `geom_text_repel()` instead of `geom_text()`. To demonstrate some
    of what `geom_text_repel()` can do, we will switch datasets and work with some
    historical U.S. presidential election data provided in the `socviz` library.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`geom_text_repel()`而不是`geom_text()`。为了展示`geom_text_repel()`能做什么，我们将切换数据集，并使用`socviz`库中提供的一些历史美国总统选举数据。
- en: '[PRE75]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Figure [5.18](workgeoms.html#fig:ch-05-electionplot-01) takes each U.S. presidential
    election since 1824 (the first year that the size of the popular vote was recorded),
    and plots the winner’s share of the popular vote against the winner’s share of
    the electoral college vote. The shares are stored in the data as proportions (from
    0 to 1) rather than percentages, so we need to adjust the labels of the scales
    using `scale_x_continuous()` and `scale_y_continuous()`. Seeing as we are interested
    in particular presidencies, we also want to label the points. ButNormally it is
    not a good idea to label every point on a plot in the way we do here. A better
    approach might be to select a few points of particular interest. because many
    of the data points are plotted quite close together we need to make sure the labels
    do not overlap with each other, or obscure other points. The `geom_text_repel()`
    function handles the problem very well. This plot has relatively long labels.
    We could put them directly in the code, but just to keep things a bit tidier we
    assign the text to some named objects instead. Then we use those in the plot formula.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [5.18](workgeoms.html#fig:ch-05-electionplot-01) 展示了自 1824 年（首次记录普选票大小的年份）以来的每一届美国总统选举，并绘制了获胜者的普选票得票率与获胜者的选举人团票得票率之间的关系。这些份额在数据中存储为比例（从
    0 到 1），而不是百分比，因此我们需要使用 `scale_x_continuous()` 和 `scale_y_continuous()` 调整刻度标签。鉴于我们对特定的总统任期感兴趣，我们还想标记这些点。但通常来说，像我们在这里做的那样在图表上标记每一个点并不是一个好主意。一个更好的方法可能是选择一些特别感兴趣的点。由于许多数据点非常接近，我们需要确保标签之间不重叠，或者不遮挡其他点。`geom_text_repel()`
    函数很好地解决了这个问题。这个图表的标签相对较长。我们本可以直接将它们放入代码中，但为了使事情更整洁，我们将其分配给一些命名的对象，然后在图表公式中使用这些对象。
- en: '![Text labels with ggrepel.](../Images/a2613e5adc2cd4f46414ddca11200103.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![使用 ggrepel 的文本标签](../Images/a2613e5adc2cd4f46414ddca11200103.png)'
- en: 'Figure 5.18: Text labels with ggrepel.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18：使用 ggrepel 的文本标签。
- en: In this plot, what is of interest about any particular point is the quadrant
    of the x-y plane each point it is in, and how far away it is from the fifty percent
    threshold on both the x-axis (with the popular vote share) and the y-axis (with
    the electoral college vote share). To underscore this point we draw two reference
    lines at the fifty percent line in each direction. They are drawn at the beginning
    of the plotting process so that the points and labels can be layered on top of
    them. We use two new geoms, `geom_hline()` and `geom_vline()` to make the lines.
    They take `yintercept` and `xintercept` arguments, respectively, and the lines
    can also be sized and colored as you please. There is also a `geom_abline()` geom
    that draws straight lines based on a supplied slope and intercept. This is useful
    for plotting, for example, 45 degree reference lines in scatterplots.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，任何特定点的有趣之处在于它位于 x-y 平面的哪个象限，以及它距离 x 轴（普选票份额）和 y 轴（选举人团票份额）上的百分之五十阈值有多远。为了强调这一点，我们在每个方向上的百分之五十线上画了两条参考线。它们在绘图过程的开始时画出，以便点标签可以叠加在其上。我们使用两个新的
    geom，`geom_hline()` 和 `geom_vline()` 来画线。它们分别接受 `yintercept` 和 `xintercept` 参数，并且线也可以根据您的喜好调整大小和颜色。还有一个
    `geom_abline()` geom，它根据提供的斜率和截距绘制直线。这在绘制散点图中的 45 度参考线时非常有用。
- en: The ggrepel package has several other useful geoms and options to aid with effectively
    plotting labels along with points. The performance of its labeling algorithm is
    consistently very good. For many purposes it will be a better first choice than
    `geom_text()`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ggrepel 包含其他几个有用的 geom 和选项，有助于有效地在点旁边绘制标签。其标签算法的性能始终非常好。对于许多用途，它将比 `geom_text()`
    成为更好的首选。
- en: 5.4 Label outliers
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 标记异常值
- en: Sometimes we want to pick out some points of interest in the data without labeling
    every single item. We can still use `geom_text()` or `geom_text_repel()`. We just
    need to pick out the points we want to label. In the code above, we do this on
    the fly by telling `geom_text_repel()` to use a different data set from the one
    `geom_point()` is using. We do this using the `subset()` function.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们想在数据中挑选出一些感兴趣的点，而不必标记每一个项目。我们仍然可以使用 `geom_text()` 或 `geom_text_repel()`。我们只需要挑选出我们想要标记的点。在上面的代码中，我们通过告诉
    `geom_text_repel()` 使用与 `geom_point()` 不同的数据集来实现这一点。我们使用 `subset()` 函数来完成这个操作。
- en: '![Top: Labeling text according to a single criterion. Bottom: Labeling according
    to several criteria.](../Images/5d49387a28c157265c595c015e091824.png)![Top: Labeling
    text according to a single criterion. Bottom: Labeling according to several criteria.](../Images/ede49654a99f1b182c6ac76cf63d9833.png)
    Figure 5.19: Top: Labeling text according to a single criterion. Bottom: Labeling
    according to several criteria.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '![顶部：根据单一标准进行文本标记。底部：根据多个标准进行标记。](../Images/5d49387a28c157265c595c015e091824.png)![顶部：根据单一标准进行文本标记。底部：根据多个标准进行标记。](../Images/ede49654a99f1b182c6ac76cf63d9833.png)
    图5.19：顶部：根据单一标准进行文本标记。底部：根据多个标准进行标记。'
- en: '[PRE78]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In the first figure, we specify a new `data` argument to the text geom, and
    use `subset()` to create a small dataset on the fly. The `subset()` function takes
    the `by_country` object and selects only the cases where `gdp_mean` is over 25,000,
    with the result that only those points are labeled in the plot. The criteria we
    use can be whatever we like, as long as we can write a logical expression that
    defines it. For example, in the lower figure we pick out cases where `gdp_mean`
    is greater than 25,000, *or* `health_mean` is less than 1,500, *or* the country
    is Belgium. In all of these plots, because we are using `geom_text_repel()`, we
    no longer have to worry about our earlier problem where the country labels were
    clipped at the edge of the plot.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一幅图中，我们为文本几何形状指定了一个新的`data`参数，并使用`subset()`动态创建一个小数据集。`subset()`函数接受`by_country`对象，并选择`gdp_mean`超过25,000的案例，结果是在图中只标记了这些点。我们使用的标准可以是任何我们喜欢的，只要我们能编写一个定义它的逻辑表达式。例如，在下面的图中，我们挑选出`gdp_mean`大于25,000、`health_mean`小于1,500或国家是比利时的案例。在所有这些图中，因为我们使用了`geom_text_repel()`，所以我们不再需要担心之前的问题，即国家标签被裁剪在图的边缘。
- en: Alternatively, we can pick out specific points by creating a dummy variable
    in the data set just for this purpose. Here we add a column to `organdata` called
    `ind`. An observation gets coded as `TRUE` if `ccode` is “Ita”, or “Spa”, *and*
    if the `year` is greater than 1998\. We use this new `ind` variable in two ways
    in the plotting code. First, we map it to the `color` aesthetic in the usual way.
    Second, we use it to subset the data that the text geom will label. Then we suppress
    the legend that would otherwise appear for the `label` and `color` aesthetics
    by using the `guides()` function.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过在数据集中创建一个仅为此目的的虚拟变量来挑选特定的点。在这里，我们在`organdata`中添加了一个名为`ind`的列。如果一个观察值`ccode`是“Ita”或“Spa”，并且`year`大于1998，则将其编码为`TRUE`。我们在绘图代码中使用这个新的`ind`变量两种方式。首先，我们按照常规方式将其映射到`color`美学。其次，我们使用它来选择文本几何形状将要标记的数据子集。然后，我们使用`guides()`函数抑制了本应出现在`label`和`color`美学上的图例。
- en: '![Labeling using a dummy variable.](../Images/caf5eb8cfdc0c144bcad11c66fd01e87.png)
    Figure 5.20: Labeling using a dummy variable.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用虚拟变量进行标记](../Images/caf5eb8cfdc0c144bcad11c66fd01e87.png) 图5.20：使用虚拟变量进行标记。'
- en: '[PRE79]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 5.5 Write and draw in the plot area
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 在绘图区域书写和绘制
- en: Sometimes we want to annotate the figure directly. Maybe we need to point out
    something important that is not mapped to a variable. We use `annotate()` for
    this purpose. It isn’t quite a geom, as it doesn’t accept any variable mappings
    from our data. Instead, it can *use* geoms, temporarily taking advantage of their
    features in order to place something on the plot. The most obvious use-case is
    putting arbitrary text on the plot.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们想要直接在图中进行注释。也许我们需要指出一些没有映射到变量的重要信息。我们使用`annotate()`来完成这个目的。它并不完全是一个几何形状，因为它不接受来自我们数据的任何变量映射。相反，它可以使用几何形状，暂时利用它们的特性来在图中放置某些内容。最明显的用例是在图中放置任意文本。
- en: We will tell `annotate()` to use a text geom. It hands the plotting duties to
    `geom_text()`, which means that we can use all of that geom’s arguments in the
    `annotate()` call. This includes the `x`, `y`, and `label` arguments, as one would
    expect, but also things like `size`, `color`, and the `hjust` and `vjust` settings
    that allow text to be justified. This is particularly useful when our label has
    several lines in it. We include extra lines by using the special “newline” code,
    `\n`, which we use instead of a space to force a line-break as needed.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将告诉`annotate()`使用文本几何形状。它将绘图任务交给`geom_text()`，这意味着我们可以在`annotate()`调用中使用该几何形状的所有参数。这包括`x`、`y`和`label`参数，正如预期的那样，还包括`size`、`color`以及允许文本对齐的`hjust`和`vjust`设置。当我们的标签包含多行时，这尤其有用。我们通过使用特殊的“换行”代码`\n`来包含额外的行，我们使用这个代码而不是空格来强制换行，以满足需要。
- en: '![Arbitrary text with <code>annotate()</code>.](../Images/3f86d50559672b7f362dad81b3e0db5d.png)
    Figure 5.21: Arbitrary text with `annotate()`.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用 <code>annotate()</code> 的任意文本。](../Images/3f86d50559672b7f362dad81b3e0db5d.png)
    图 5.21：使用 `annotate()` 的任意文本。'
- en: '[PRE80]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The `annotate()` function can work with other geoms, too. Use it to draw rectangles,
    line segments, and arrows. Just remember to pass along the right arguments to
    the geom you use. We can add a rectangle to this plot, for instance, with a second
    call to the function.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`annotate()` 函数也可以与其他 geom 一起使用。使用它来绘制矩形、线段和箭头。只需确保传递给所使用的 geom 正确的参数即可。例如，我们可以通过对该函数的第二次调用向此图添加一个矩形。'
- en: '[PRE81]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Figure 5.22: Using two different geoms with `annotate()`.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.22：使用 `annotate()` 与两种不同的 geom。
- en: '![Using two different geoms with <code>annotate()</code>.](../Images/6e64df4718fa9855a4e9dac823c96edf.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![使用 <code>annotate()</code> 与两种不同的 geom。](../Images/6e64df4718fa9855a4e9dac823c96edf.png)'
- en: 5.6 Understanding scales, guides, and themes
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6 理解尺度、指南和主题
- en: This chapter has gradually extended our ggplot vocabulary in two ways. First,
    we introduced some new `geom_` functions that allowed us to draw new kinds of
    plots. Second, we made use of new functions controlling some aspects of the appearance
    of our graph. We used `scale_x_log10()`, `scale_x_continuous()` and other `scale_`
    functions to adjust axis labels. We used the `guides()` function to remove the
    legends for a `color` mapping and a `label` mapping. And we also used the `theme()`
    function to move the position of a legend from the side to the top of a figure.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以两种方式逐渐扩展了我们的 ggplot 词汇。首先，我们介绍了一些新的 `geom_` 函数，使我们能够绘制新的图表类型。其次，我们利用了新的函数来控制图表外观的一些方面。我们使用了
    `scale_x_log10()`、`scale_x_continuous()` 和其他 `scale_` 函数来调整坐标轴标签。我们使用了 `guides()`
    函数来移除 `color` 映射和 `label` 映射的图例。我们还使用了 `theme()` 函数将图例的位置从侧面移动到图的上部。
- en: Learning about new geoms extended what we have seen already. Each geom makes
    a different type of plot. Different plots require different mappings in order
    to work, and so each `geom_` function takes mappings tailored to the kind of graph
    it draws. You can’t use `geom_point()` to make a scatterplot without supplying
    an `x` and a `y` mapping, for example. Using `geom_histogram()` only requires
    you to supply an `x` mapping. Similarly, `geom_pointrange()` requires `ymin` and
    `ymax` mappings in order to know where to draw the lineranges it makes. A `geom_`
    function may take optional arguments, too. When using `geom_boxplot()` you can
    specify what the outliers look like using arguments like `outlier.shape` and `outlier.color`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 了解新的 geom 扩展了我们已经看到的内容。每个 geom 都绘制不同类型的图表。不同的图表需要不同的映射才能工作，因此每个 `geom_` 函数都包含针对其绘制的图表类型的定制映射。例如，不提供
    `x` 和 `y` 映射，就不能使用 `geom_point()` 来制作散点图。使用 `geom_histogram()` 只需要提供 `x` 映射。同样，`geom_pointrange()`
    需要提供 `ymin` 和 `ymax` 映射，以便知道在哪里绘制它所绘制的线段范围。`geom_` 函数也可能接受可选参数。在使用 `geom_boxplot()`
    时，你可以使用 `outlier.shape` 和 `outlier.color` 等参数指定异常值的外观。
- en: The second kind of extension introduced some new functions, and with them some
    new concepts. What are the differences between the `scale_` functions, the `guides()`
    function, and the `theme()` function? When do you know to use one rather than
    the other? Why are there so many `scale_` functions listed in the online help,
    anyway? How can you tell which one you need?
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种扩展引入了一些新函数，以及一些新概念。`scale_` 函数、`guides()` 函数和 `theme()` 函数之间的区别是什么？何时知道使用其中一个而不是另一个？为什么在线帮助中列出了这么多
    `scale_` 函数？你如何判断你需要哪一个？
- en: 'Here is a rough and ready starting point:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个粗略的起点：
- en: Every aesthetic mapping has a scale. If you want to adjust how that scale is
    marked or graduated, then you use a `scale_` function.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个美学映射都有一个尺度。如果你想要调整该尺度如何标记或分级，那么你使用一个 `scale_` 函数。
- en: Many scales come with a legend or key to help the reader interpret the graph.
    These are called *guides*. You can make adjustments to them with the `guides()`
    function. Perhaps the most common use case is to make the legend disappear, as
    it is sometimes superfluous. Another is to adjust the arrangement of the key in
    legends and colorbars.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多尺度都附带图例或键，以帮助读者解释图表。这些被称为 *指南*。你可以使用 `guides()` 函数对这些进行调整。最常见的情况可能是使图例消失，因为有时它是多余的。另一种情况是调整图例和颜色条中键的排列。
- en: Graphs have other features not strictly connected to the logical structure of
    the data being displayed. These include things like their background color, the
    typeface used for labels, or the placement of the legend on the graph. To adjust
    these, use the `theme()` function.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形还有一些与显示数据的逻辑结构不严格相关的特征。这些包括背景颜色、用于标签的字体类型，或者图例在图上的位置。要调整这些，请使用`theme()`函数。
- en: Consistent with ggplot’s overall approach, adjusting some visible feature of
    the graph means first thinking about the relationship that the feature has with
    the underlying data. Roughly speaking, if the change you want to make will affect
    the substantive interpretation of any particular geom, then most likely you will
    either be mapping an aesthetic to a variable using that geom’s `aes()` function,
    or you will be specifying a change via some `scale_` function. If the change you
    want to make does not affect the interpretation of a given geom_, then most likely
    you will either be setting a variable inside the `geom_` function, or making a
    cosmetic change via the `theme()` function.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 与ggplot的整体方法一致，调整图形的一些可见特征意味着首先思考该特征与底层数据之间的关系。大致来说，如果你想要进行的更改将影响任何特定几何图形的实质性解释，那么你很可能会使用该几何图形的`aes()`函数将美学映射到变量，或者通过某个`scale_`函数指定更改。如果你想要进行的更改不会影响给定几何图形的解释，那么你很可能会在`geom_`函数内部设置变量，或者通过`theme()`函数进行外观上的更改。
- en: '![Every mapped variable has a scale.](../Images/2baf5a838809dd86e16a88cbfc970f7e.png)
    Figure 5.23: Every mapped variable has a scale.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '![每个映射的变量都有一个刻度。](../Images/2baf5a838809dd86e16a88cbfc970f7e.png) 图 5.23：每个映射的变量都有一个刻度。'
- en: Scales and guides are closely connected, which can make things confusing. The
    guide provides information about the scale, such as in a legend or colorbar. Thus,
    it is possible to make adjustments to guides from inside the various `scale_`
    functions. More often it is easier to use the `guides()` function directly.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 刻度和指南紧密相关，这可能会让人感到困惑。指南提供了有关刻度的信息，例如在图例或颜色条中。因此，从各种`scale_`函数内部调整指南是可能的。更常见的是，直接使用`guides()`函数更容易。
- en: '[PRE82]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Figure [5.23](workgeoms.html#fig:ch-05-scalesfig-01) shows a plot with three
    aesthetic mappings. The variable `roads` is mapped to `x`; `donors` is mapped
    to `y`; and `world` is mapped to `color`. The `x` and `y` scales are both *continuous*,
    running smoothly from just under the lowest value of the variable to just over
    the highest value. Various labeled tick marks orient the reader to the values
    on each axis. The `color` mapping also has a scale. The `world` measure is an
    unordered categorical variable, so its scale is *discrete*. It takes one of four
    values, each represented by a different color.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [5.23](workgeoms.html#fig:ch-05-scalesfig-01) 展示了一个具有三个美学映射的图表。变量`roads`映射到`x`；`donors`映射到`y`；而`world`映射到`颜色`。`x`和`y`刻度都是*连续的*，从略低于变量的最低值平滑运行到略高于变量的最高值。各种带有标签的刻度标记使读者能够定位到每个轴的值。`颜色`映射也有一个刻度。`world`度量是一个无序的分类变量，因此其刻度是*离散的*。它取四个值之一，每个值由不同的颜色表示。
- en: Along with `color`, mappings like `fill`, `shape`, and `size` will have scales
    that we might want to customize or adjust. We could have mapped `world` to `shape`
    instead of `color`. In that case our four-category variable would have a scale
    consisting of four different shapes. Scales for these mappings may have labels,
    axis tick marks at particular positions, or specific colors or shapes. If we want
    to adjust them, we use one of the `scale_` functions.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`颜色`之外，像`填充`、`形状`和`大小`这样的映射也将具有我们可能想要自定义或调整的刻度。我们本可以将`世界`映射到`形状`而不是`颜色`。在这种情况下，我们的四分类变量将包含四种不同的形状的刻度。这些映射的刻度可能包含标签、特定位置的轴刻度标记，或者特定的颜色或形状。如果我们想要调整它们，我们可以使用`scale_`函数中的一个。
- en: Many different kinds of variable can be mapped. More often than not `x` and
    `y` are continuous measures. But they might also easily be discrete, as when we
    mapped country names to the `y` axis in our boxplots and dotplots. An `x` or `y`
    mapping can also be defined as a transformation onto a log scale, or as a special
    sort of number value like a date. Similarly, a `color` or a `fill` mapping can
    be discrete and *unordered*, as with our `world` variable, or discrete and *ordered*,
    as with letter grades in an exam. A `color` or `fill` mapping can also be a continuous
    quantity, represented as a gradient running smoothly from a low to a high value.
    Finally, both continuous gradients and ordered discrete values might have some
    defined neutral midpoint with extremes diverging in both directions.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将多种不同类型的变量映射到图表中。通常情况下，`x`和`y`是连续的度量。但它们也可能是离散的，就像我们在箱线图和点图中将国家名称映射到`y`轴时那样。`x`或`y`映射也可以定义为对数刻度的转换，或者定义为特殊类型的数值，如日期。同样，`color`或`fill`映射可以是离散的且*无序的*，就像我们的`world`变量那样，或者离散的且*有序的*，就像考试中的字母等级那样。`color`或`fill`映射也可以是连续的数量，表示从低值到高值平滑过渡的渐变。最后，连续渐变和有序离散值可能都有一个定义的中性中间点，两端向相反方向发散。
- en: '![A schema for naming the <code>scale</code> functions.](../Images/f68891a3a348d121e8d9d743eaa18404.png)
    Figure 5.24: A schema for naming the `scale` functions.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '![命名<code>scale</code>函数的方案](../Images/f68891a3a348d121e8d9d743eaa18404.png)
    图5.24：命名`scale`函数的方案。'
- en: Because we have several potential mappings, and each mapping might be to one
    of several different scales, we end up with a lot of individual `scale_` functions.
    Each deals with one combination of mapping and scale. They are named according
    to a consistent logic, shown in Figure [5.24](workgeoms.html#fig:ch-05-scale-template).
    First comes the `scale_` name, then the *mapping* it applies to, and finally the
    *kind* of value the scale will display. Thus, the `scale_x_continuous()` function
    controls `x` scales for continuous variables; `scale_y_discrete()` adjusts `y`
    scales for discrete variables; and `scale_x_log10()` transforms an `x` mapping
    to a log scale. Most of the time, ggplot will guess correctly what sort of scale
    is needed for your mapping. Then it will work out some default features of the
    scale (such as its labels and where the tick marks go). In many cases you will
    not need to make any scale adjustments. If `x` is mapped to a continuous variable
    then adding `+ scale_x_continuous()` to your plot statement with no further arguments
    will have no effect. It is already there implicitly. Adding `+ scale_x_log10()`,
    on the other hand, will transform your scale, as now you have replaced the default
    treatment of a continuous x variable.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有几种潜在的映射，每种映射可能对应几种不同的刻度，所以我们最终会有很多个单独的`scale_`函数。每个函数处理一种映射和刻度的组合。它们的命名遵循一致的逻辑，如图[5.24](workgeoms.html#fig:ch-05-scale-template)所示。首先是`scale_`名称，然后是它应用的*映射*，最后是刻度将显示的*类型*。因此，`scale_x_continuous()`函数控制连续变量的`x`刻度；`scale_y_discrete()`调整离散变量的`y`刻度；`scale_x_log10()`将`x`映射转换为对数刻度。大多数时候，ggplot会正确猜测你的映射需要哪种刻度。然后它会计算出刻度的默认特征（如标签和刻度标记的位置）。在许多情况下，你不需要进行任何刻度调整。如果`x`映射到连续变量，那么在绘图语句中添加`+
    scale_x_continuous()`而没有其他参数将不会有任何效果。它已经隐含地存在了。另一方面，添加`+ scale_x_log10()`将转换你的刻度，因为你已经替换了连续x变量的默认处理方式。
- en: If you want to adjust the labels or tick marks on a scale, you will need to
    know which mapping it is for and what sort of scale it is. Then you supply the
    arguments to the appropriate scale function. For example, we can change the x-axis
    of the previous plot to a log scale, and then also change the position and labels
    of the tick marks on the y-axis.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要调整刻度上的标签或刻度标记，你需要知道它是哪种映射以及它属于哪种刻度类型。然后，你为相应的刻度函数提供参数。例如，我们可以将之前图表的x轴改为对数刻度，然后也可以改变y轴上刻度标记的位置和标签。
- en: '![Making some scale adjustments.](../Images/cc6fa882fd8215de245122737bccb83c.png)
    Figure 5.25: Making some scale adjustments.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '![进行一些刻度调整](../Images/cc6fa882fd8215de245122737bccb83c.png) 图5.25：进行一些刻度调整。'
- en: '[PRE83]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The same applies to mappings like `color` and `fill`. Here the available `scale_`
    functions include ones that deal with continuous, diverging, and discrete variables,
    as well as others that we will encounter later when we discuss the use of color
    and color palettes in more detail. When working with a scale that produces a legend,
    we can also use this its `scale_` function to specify the labels in the key. To
    change the *title* of the legend, however, we use the `labs()` function, which
    lets us label all the mappings.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于 `color` 和 `fill` 这样的映射。这里可用的 `scale_` 函数包括处理连续、发散和离散变量的函数，以及我们在更详细地讨论颜色和调色板的使用时将遇到的其它函数。当与产生图例的比例一起工作时，我们也可以使用这个
    `scale_` 函数来指定键中的标签。然而，要更改图例的 *标题*，我们使用 `labs()` 函数，它允许我们为所有映射添加标签。
- en: '![Relabeling via a scale function.](../Images/de3905e462410cdccab6ff95d4746cc5.png)
    Figure 5.26: Relabeling via a scale function.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '![通过比例函数重新标记。](../Images/de3905e462410cdccab6ff95d4746cc5.png) 图 5.26：通过比例函数重新标记。'
- en: '[PRE84]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: If we want to move the legend somewhere else on the plot, we are making a purely
    cosmetic decision and that is the job of the `theme()` function. As we have already
    seen, adding `+ theme(legend.position = "top")` will move the legend as instructed.
    Finally, to make the legend disappear altogether, we tell ggplot that we do not
    want a guide for that scale. This is generally not good practice, but there can
    be good reasons to do it. We will see some examples later on.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将图例移动到图表的另一个位置，我们只是在做一项纯粹的外观决定，这是 `theme()` 函数的工作。正如我们已经看到的，添加 `+ theme(legend.position
    = "top")` 将按照指示移动图例。最后，为了使图例完全消失，我们告诉 ggplot 我们不希望对该比例有指南。这通常不是好的做法，但有时有很好的理由这样做。我们稍后会看到一些例子。
- en: '[PRE85]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '![Removing the guide to a scale.](../Images/c75b51f0fc2df917751b27f2d454693b.png)
    Figure 5.27: Removing the guide to a scale.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '![移除比例的指南。](../Images/c75b51f0fc2df917751b27f2d454693b.png) 图 5.27：移除比例的指南。'
- en: We will look more closely at `scale_` and `theme()` functions in Chapter [8](refineplots.html#refineplots),
    when we discuss how to polish plots that we are ready to display or publish. Until
    then, we will use `scale_` functions fairly regularly to make small adjustments
    to the labels and axes of our graphs. And we will occasionally use the `theme()`
    function to make some cosmetic adjustments here and there. So you do not need
    to worry too much about additional details of how they work until later on. But
    at this point it *is* worth knowing what `scale_` functions are for, and the logic
    behind their naming scheme. Understanding the `scale_<mapping>_<kind>()` rule
    makes it easier to see what is going on when one of these functions is called
    to make an adjustment to a plot.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 [8](refineplots.html#refineplots) 章节中更详细地探讨 `scale_` 和 `theme()` 函数，那时我们将讨论如何润色我们准备展示或发布的图表。在此之前，我们将相当频繁地使用
    `scale_` 函数来对图表的标签和坐标轴进行微调。偶尔，我们也会使用 `theme()` 函数在这里和那里做一些外观上的调整。所以，你不必过于担心它们的工作细节，直到稍后。但在此阶段，了解
    `scale_` 函数的用途及其命名逻辑是值得的。理解 `scale_<mapping>_<kind>()` 规则可以使我们更容易看到当调用这些函数之一来调整图表时发生了什么。
- en: 5.7 Where to go next
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.7 接下来去哪里
- en: We covered several new functions and data aggregation techniques in this Chapter.
    You should practice working with them.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了几个新的函数和数据聚合技术。你应该练习使用它们。
- en: '![Two figures from Chapter 1.](../Images/29521484b08d54e09144a78dfbe4c4ba.png)![Two
    figures from Chapter 1.](../Images/4d47e812c07ab78006c1ab2415e80c88.png) Figure
    5.28: Two figures from Chapter 1.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '![第 1 章的两个图表。](../Images/29521484b08d54e09144a78dfbe4c4ba.png)![第 1 章的两个图表。](../Images/4d47e812c07ab78006c1ab2415e80c88.png)
    图 5.28：第 1 章的两个图表。'
- en: The `subset()` function is very useful when used in conjunction with a series
    of layered geoms. Go back to your code for the Presidential Elections plot (Figure
    [5.18](workgeoms.html#fig:ch-05-electionplot-01)) and redo it so that it shows
    all the data points but only labels elections since 1992\. You might need to look
    again at the `elections_historic` data to see what variables are available to
    you. You can also experiment with subsetting by political party, or changing the
    colors of the points to reflect the winning party.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当与一系列分层几何图形一起使用时，`subset()` 函数非常有用。回到你的总统选举图（图 [5.18](workgeoms.html#fig:ch-05-electionplot-01)）的代码，重新做一下，使其显示所有数据点，但只标记自
    1992 年以来的选举。你可能需要再次查看 `elections_historic` 数据，看看有哪些变量可供使用。你还可以通过政党进行子集划分实验，或者改变点的颜色以反映获胜的政党。
- en: Use `geom_point()` and `reorder()` to make a Cleveland dot plot of all Presidential
    elections, ordered by share of the popular vote.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `geom_point()` 和 `reorder()` 创建所有总统选举的克利夫兰点图，按得票率排序。
- en: Try using `annotate()` to add a rectangle that lightly colors the entire upper
    left quadrant of Figure [5.18](workgeoms.html#fig:ch-05-electionplot-01).
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用 `annotate()` 添加一个矩形，轻轻着色图 [5.18](workgeoms.html#fig:ch-05-electionplot-01)
    的整个左上象限。
- en: The main action verbs in the `dplyr` library are `group_by()`, `filter()`, `select()`,
    `summarize()`, and `mutate()`. Practice with them by revisiting the `gapminder`
    data to see if you can reproduce a pair of graphs from Chapter One, shown here
    again in Figure [5.28](workgeoms.html#fig:ch-05-gapminder-revisit). You will need
    to filter some rows, group the data by continent, and calculate the mean life
    expectancy by continent before beginning the plotting process.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dplyr` 库中的主要动作动词是 `group_by()`、`filter()`、`select()`、`summarize()` 和 `mutate()`。通过重新访问
    `gapminder` 数据来练习它们，看看您是否能重现第一章中的一对图表，如图 [5.28](workgeoms.html#fig:ch-05-gapminder-revisit)
    所示。在开始绘图过程之前，您需要过滤一些行，按大陆分组数据，并计算按大陆的平均预期寿命。'
- en: 'Get comfortable with grouping, mutating, and summarizing data in pipelines.
    This will become a routine task as you work with your data. There are many ways
    that tables can be aggregated and transformed. Remember `group_by()` groups your
    data from left to right, with the rightmost or innermost group being the level
    calculations will be done at; `mutate()` adds a column at the current level of
    grouping; and `summarize()` aggregates to the next level up. Try creating some
    grouped objects from the GSS data, calculating frequencies as you learned in this
    Chapter, and then check to see if the totals are what you expect. For example,
    start by grouping `degree` by `race`, like this:'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在管道中熟悉分组、变异和汇总数据。随着您与数据一起工作，这将成为一项常规任务。表格可以以多种方式聚合和转换。记住 `group_by()` 从左到右分组您的数据，最右边或最内层的组是将在其上进行计算的级别；`mutate()`
    在当前分组级别添加一列；而 `summarize()` 聚合到下一个级别。尝试从 GSS 数据中创建一些分组对象，计算您在本章中学到的频率，然后检查总数是否符合您的预期。例如，首先按
    `degree` 分组 `race`，如下所示：
- en: '[PRE86]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: This code is similar to what you saw earlier, but a little more compact. (We
    calculate the `pct` values directly.) Check the results are as you expect by grouping
    by `race` and summing the percentages. Try doing the same exercise grouping by
    `sex` or `region`.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码与您之前看到的类似，但更加紧凑。（我们直接计算 `pct` 值。）通过按 `race` 分组并汇总百分比来检查结果是否符合您的预期。尝试按 `sex`
    或 `region` 分组进行相同的练习。
- en: 'Try summary calculations with functions other than `sum`. Can you calculate
    the mean and median number of children by `degree`? (Hint: the `childs` variable
    in `gss_sm` has children as a numeric value.)'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用除 `sum` 之外的其他函数进行汇总计算。您能否按 `degree` 计算儿童的平均数和中位数？（提示：`gss_sm` 中的 `childs`
    变量将儿童表示为数值。）
- en: '`dplyr` has a large number of helper functions that let you summarize data
    in many different ways. The vignette on *window functions* included with the `dplyr`
    documentation is a good place to begin learning about these. You should also look
    at Chapter 3 of Wickham & Grolemund (2016) for more information on transforming
    data with `dplyr`.'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dplyr` 包含大量辅助函数，让您以多种方式汇总数据。`dplyr` 文档中包含的关于 *窗口函数* 的示例是一个开始学习这些函数的好地方。您还应该查看
    Wickham & Grolemund (2016) 的第 3 章，以获取更多关于使用 `dplyr` 转换数据的信息。'
- en: 'Experiment with the `gapminder` data to practice some of the new geoms we have
    learned. Try examining population or life expectancy over time using a series
    of boxplots. (Hint: you may need to use the `group` aesthetic in the `aes()` call.)
    Can you facet this boxplot by continent? Is anything different if you create a
    tibble from `gapminder` that explicitly groups the data by `year` and `continent`
    first, and then create your plots with that?'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `gapminder` 数据进行实验，以练习我们学习到的一些新几何形状。尝试使用一系列箱线图来检查人口或预期寿命随时间的变化。（提示：您可能需要在
    `aes()` 调用中使用 `group` 美学。）您能否通过大陆来细分这个箱线图？如果您首先从 `gapminder` 创建一个明确按 `year` 和
    `continent` 分组的 tibble，然后使用它来创建图表，会有什么不同？
- en: Read the help page for `geom_boxplot()` and take a look at the `notch` and `varwidth`
    options. Try them out to see how they change the look of the plot.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读关于 `geom_boxplot()` 的帮助页面，并查看 `notch` 和 `varwidth` 选项。尝试使用它们来观察它们如何改变图表的外观。
- en: As an alternative to `geom_boxplot()` try `geom_violin()` for a similar plot,
    but with a mirrored density distribution instead of a box and whiskers.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 `geom_boxplot()` 的替代方案，尝试使用 `geom_violin()` 来创建类似的图表，但使用镜像密度分布而不是箱线和胡须。
- en: '`geom_pointrange()` is one of a family of related geoms that produce different
    kinds of error bars and ranges, depending on your specific needs. They include
    `geom_linerange()`, `geom_crossbar()`, and `geom_errorbar()`. Try them out using
    `gapminder` or `organdata` to see how they differ.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geom_pointrange()` 是一系列相关 geoms 中的一个，根据您的具体需求，它可以生成不同类型的误差条和范围。它们包括 `geom_linerange()`、`geom_crossbar()`
    和 `geom_errorbar()`。使用 `gapminder` 或 `organdata` 尝试它们，看看它们之间的区别。'
