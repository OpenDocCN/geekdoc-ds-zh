- en: '20'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '20'
- en: UNDERSTANDING EXPERIMENTAL DATA
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 理解实验数据
- en: This chapter is about understanding experimental data. We will make extensive
    use of plotting to visualize the data and show how to use linear regression to
    build a model of experimental data. We will also talk about the interplay between
    physical and computational experiments. We defer our discussion of how to draw
    valid statistical conclusions about data to Chapter 21.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于理解实验数据的。我们将广泛使用绘图来可视化数据，并展示如何使用线性回归构建实验数据模型。我们还将讨论物理实验和计算实验之间的相互作用。我们将讨论如何得出有效的统计结论的内容推迟到第21章。
- en: 20.1 The Behavior of Springs
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.1 弹簧的行为
- en: Springs are wonderful things. When they are compressed or stretched by some
    force, they store energy. When that force is no longer applied, they release the
    stored energy. This property allows them to smooth the ride in cars, help mattresses
    conform to our bodies, retract seat belts, and launch projectiles.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 弹簧是非常奇妙的东西。当它们被某种力压缩或拉伸时，会储存能量。当这个力不再施加时，它们释放储存的能量。这一特性使它们能够在汽车中平滑行驶，帮助床垫适应我们的身体，收回安全带，发射弹丸。
- en: 'In 1676 the British physicist Robert Hooke formulated **Hooke''s law** of elasticity:
    *Ut tensio, sic vis*, in English, `F = -kx`. In other words, the force `F` stored
    in a spring is linearly related to the distance the spring has been compressed
    (or stretched). (The minus sign indicates that the force exerted by the spring
    is in the opposite direction of the displacement.) Hooke''s law holds for a wide
    variety of materials and systems, including many biological systems. Of course,
    it does not hold for an arbitrarily large force. All springs have an **elastic
    limit**, beyond which the law fails. Those of you who have stretched a Slinky
    too far know this all too well.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 1676年，英国物理学家**罗伯特·胡克**制定了弹性**胡克定律**：*Ut tensio, sic vis*，用英语表达为`F = -kx`。换句话说，存储在弹簧中的力`F`与弹簧被压缩（或拉伸）的距离呈线性关系。（负号表示弹簧施加的力与位移方向相反。）胡克定律适用于各种材料和系统，包括许多生物系统。当然，它不适用于任意大的力。所有弹簧都有一个**弹性极限**，超过这个极限，定律就失效了。那些拉伸过度的Slinky玩具的人对此了解得太清楚了。
- en: The constant of proportionality, `k`, is called the **spring constant**. If
    the spring is stiff (like the ones in the suspension of a car or the limbs of
    an archer's bow), `k` is large. If the spring is weak, like the spring in a ballpoint
    pen, `k` is small.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 比例常数`k`称为**弹簧常数**。如果弹簧很硬（比如汽车悬挂中的弹簧或弓箭手的弓臂），`k`就大。如果弹簧很弱，比如圆珠笔中的弹簧，`k`就小。
- en: Knowing the spring constant of a particular spring can be a matter of some import.
    The calibrations of both simple scales and atomic force microscopes depend upon
    knowing the spring constants of components. The mechanical behavior of a strand
    of DNA is related to the force required to compress it. The force with which a
    bow launches an arrow is related to the spring constant of its limbs. And so on.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 知道特定弹簧的弹簧常数可能非常重要。简单秤和原子力显微镜的标定都依赖于知道组件的弹簧常数。DNA链的机械行为与压缩它所需的力相关。弓发射箭矢的力与其弓臂的弹簧常数相关，等等。
- en: Generations of physics students have learned to estimate spring constants using
    an experimental apparatus similar to one pictured in [Figure 20-1](#c20-fig-0001).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 代代物理学生通过使用类似于[图20-1](#c20-fig-0001)所示的实验装置来估计弹簧常数。
- en: '![c20-fig-0001.jpg](../images/c20-fig-0001.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![c20-fig-0001.jpg](../images/c20-fig-0001.jpg)'
- en: '[Figure 20-1](#c20-fig-0001a) A classic experiment'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[图20-1](#c20-fig-0001a) 经典实验'
- en: We start with a spring with no attached weight, and measure the distance to
    the bottom of the spring from the top of the stand. We then hang a known mass
    on the spring and wait for it to stop moving. At this point, the force stored
    in the spring is the force exerted on the spring by the weight hanging from it.
    This is the value of `F` in Hooke's law. We again measure the distance from the
    bottom of the spring to the top of the stand. The difference between this distance
    and the distance before we hung the weight becomes the value of `x` in Hooke's
    law.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个没有附加重量的弹簧开始，测量弹簧底部到支架顶部的距离。然后我们在弹簧上挂上已知质量的物体，并等待它停止移动。在此时，存储在弹簧中的力就是悬挂物体施加在弹簧上的力。这就是胡克定律中的`F`值。我们再次测量弹簧底部到支架顶部的距离。这个距离与挂上重量之前的距离之间的差值就是胡克定律中的`x`值。
- en: We know that the force, `F`, being exerted on the spring is equal to the mass,
    `m`, multiplied by the acceleration due to gravity, `g` (`9.81 m/s`² is a pretty
    good approximation of `g` on the surface of this planet), so we substitute `m`*`g`
    for `F`. By simple algebra, we know that `k = -(m`*`g)/x.`
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '我们知道施加在弹簧上的力`F`等于质量`m`乘以重力加速度`g`（`9.81 m/s`²是这个星球表面`g`的一个相当好的近似值），因此我们将`m`*`g`代入`F`。通过简单的代数，我们知道`k
    = -(m`*`g)/x.` '
- en: Suppose, for example, that `m = 1kg` and `x = 0.1m`, then
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，`m = 1kg`和`x = 0.1m`，那么
- en: '![c20-fig-5001.jpg](../images/c20-fig-5001.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![c20-fig-5001.jpg](../images/c20-fig-5001.jpg)'
- en: According to this calculation, it will take `*98.1*` Newtons[^(137)](#c20-fn-0001)
    of force to stretch the spring one meter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个计算，拉伸弹簧一米需要`*98.1*`牛顿[^(137)](#c20-fn-0001)的力。
- en: This would all be well and good if
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切都很好
- en: We had complete confidence that we would conduct this experiment perfectly.
    In that case, we could take one measurement, perform the calculation, and know
    that we had found `k`. Unfortunately, experimental science hardly ever works this
    way.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们完全相信我们能够完美地进行这个实验。在这种情况下，我们可以进行一次测量，执行计算，并知道我们找到了`k`。不幸的是，实验科学几乎从不这样运作。
- en: We could be sure that we were operating below the elastic limit of the spring.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以确保我们在弹簧的弹性极限以下进行操作。
- en: 'A more robust experiment would be to hang a series of increasingly heavier
    weights on the spring, measure the stretch of the spring each time, and plot the
    results. We ran such an experiment, and typed the results into a file named `springData.csv`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更稳健的实验是将一系列越来越重的重物悬挂在弹簧上，每次测量弹簧的伸长并绘制结果。我们进行了这样的实验，并将结果输入到一个名为`springData.csv`的文件中：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The function in [Figure 20-2](#c20-fig-0003) reads data from a file such as
    the one we saved, and returns lists containing the distances and masses.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[图20-2](#c20-fig-0003)中的函数从一个文件读取数据，例如我们保存的文件，并返回包含距离和质量的列表。'
- en: '![c20-fig-0002.jpg](../images/c20-fig-0002.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![c20-fig-0002.jpg](../images/c20-fig-0002.jpg)'
- en: '[Figure 20-2](#c20-fig-0003a) Extracting the data from a file'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[图20-2](#c20-fig-0003a) 从文件中提取数据'
- en: The function in [Figure 20-3](#c20-fig-0004) uses `get_data` to extract the
    experimental data from the file and then produces the plot in [Figure 20-4](#c20-fig-0005).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[图20-3](#c20-fig-0004)中的函数使用`get_data`从文件中提取实验数据，然后生成[图20-4](#c20-fig-0005)中的图表。'
- en: '![c20-fig-0003.jpg](../images/c20-fig-0003.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![c20-fig-0003.jpg](../images/c20-fig-0003.jpg)'
- en: '[Figure 20-3](#c20-fig-0004a) Plotting the data'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[图20-3](#c20-fig-0004a) 绘制数据'
- en: '![c20-fig-0004.jpg](../images/c20-fig-0004.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![c20-fig-0004.jpg](../images/c20-fig-0004.jpg)'
- en: '[Figure 20-4](#c20-fig-0005a) Displacement of spring'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[图20-4](#c20-fig-0005a) 弹簧的位移'
- en: This is not what Hooke's law predicts. Hooke's law tells us that the distance
    should increase linearly with the mass, i.e., the points should lie on a straight
    line the slope of which is determined by the spring constant. Of course, we know
    that when we take real measurements, the experimental data are rarely a perfect
    match for the theory. Measurement error is to be expected, so we should expect
    the points to lie around a line rather than on it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是胡克定律所预测的。胡克定律告诉我们，距离应与质量线性增加，即点应位于一条直线上，其斜率由弹簧常数决定。当然，我们知道当我们进行真实测量时，实验数据很少与理论完全吻合。测量误差是可以预期的，因此我们应当期望点位于一条线附近，而不是在线上。
- en: Still, it would be nice to see a line that represents our best guess of where
    the points would have been if we had no measurement error. The usual way to do
    this is to fit a line to the data.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然，看到一条代表我们最佳猜测的线会很好，假如没有测量误差，点将会在何处。通常的做法是对数据进行线性拟合。
- en: 20.1.1 Using Linear Regression to Find a Fit
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.1.1 使用线性回归找到拟合
- en: Whenever we fit any curve (including a line) to data, we need some way to decide
    which curve is the best **fit** for the data. This means that we need to define
    an objective function that provides a quantitative assessment of how well the
    curve fits the data. Once we have such a function, finding the best fit can be
    formulated as finding a curve that minimizes (or maximizes) the value of that
    function, i.e., as an optimization problem (see Chapters 14 and 15).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们将任何曲线（包括直线）拟合到数据时，我们需要某种方法来判断哪条曲线是数据的最佳**拟合**。这意味着我们需要定义一个客观函数，以定量评估曲线与数据的拟合程度。一旦我们有了这样的函数，找到最佳拟合可以被表述为寻找一个最小化（或最大化）该函数值的曲线，即作为一个优化问题（见第14和15章）。
- en: The most commonly used objective function is called **least squares**. Let `*observed*`
    and `*predicted*` be vectors of equal length, where `*observed*` contains the
    measured points and *predicted* the corresponding data points on the proposed
    fit.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的目标函数称为 **最小二乘法**。令 `*observed*` 和 `*predicted*` 为相同长度的向量，其中 `*observed*`
    包含测量点，*predicted* 包含建议拟合的相应数据点。
- en: 'The objective function is then defined as:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后定义目标函数为：
- en: '![c20-fig-5002.jpg](../images/c20-fig-5002.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![c20-fig-5002.jpg](../images/c20-fig-5002.jpg)'
- en: Squaring the difference between observed and predicted points makes large differences
    between observed and predicted points relatively more important than small differences.
    Squaring the difference also discards information about whether the difference
    is positive or negative.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对观察值和预测值之间的差异进行平方处理，使观察值和预测值之间的大差异相对比小差异更为重要。平方差异还丢失了关于差异是正还是负的信息。
- en: How might we go about finding the best least-squares fit? One way is to use
    a successive approximation algorithm similar to the Newton–Raphson algorithm in
    Chapter 3\. Alternatively, there are analytic solutions that are often applicable.
    But we don't have to implement either Newton–Raphson or an analytic solution,
    because `numpy` provides a built-in function, `polyfit`, that finds an approximation
    to the best least-squares fit. The call
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何找到最佳的最小二乘拟合？一种方法是使用类似于第 3 章中牛顿–拉夫森算法的逐次逼近算法。或者，通常适用解析解。但我们不必实现牛顿–拉夫森或解析解，因为
    `numpy` 提供了一个内置函数 `polyfit`，该函数可以找到最佳最小二乘拟合的近似值。该调用
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: finds the coefficients of a polynomial of degree `n` that provides a best least-squares
    fit for the set of points defined by the two arrays `observed_x_vals` and `observed_y_vals`.
    For example, the call
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 查找提供最佳最小二乘拟合的多项式的系数，次数为 `n`，该多项式由两个数组 `observed_x_vals` 和 `observed_y_vals`
    定义的点集给出。例如，该调用
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: will find a line described by the polynomial `y = ax + b`, where `a` is the
    slope of the line and `b` the y-intercept. In this case, the call returns an array
    with two floating-point values. Similarly, a parabola is described by the quadratic
    equation `y = ax`² `+ bx + c`. Therefore, the call
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将找到由多项式 `y = ax + b` 描述的直线，其中 `a` 是直线的斜率，`b` 是 y 轴截距。在这种情况下，调用返回一个包含两个浮点值的数组。类似地，抛物线由二次方程
    `y = ax`² `+ bx + c` 描述。因此，该调用
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: returns an array with three floating-point values.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个包含三个浮点值的数组。
- en: The algorithm used by `polyfit` is called **linear regression**. This may seem
    a bit confusing, since we can use it to fit curves other than lines. Some authors
    do make a distinction between linear regression (when the model is a line) and
    **polynomial regression** (when the model is a polynomial with degree greater
    than `1`), but most do not.[^(138)](#c20-fn-0002)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`polyfit` 使用的算法称为 **线性回归**。这可能有些令人困惑，因为我们可以用它来拟合除直线以外的曲线。一些作者确实区分线性回归（当模型是直线时）和
    **多项式回归**（当模型是次数大于 `1` 的多项式时），但大多数作者没有。[^(138)](#c20-fn-0002)'
- en: The function `fit_data` in [Figure 20-5](#c20-fig-0007) extends the `plot_data`
    function in [Figure 20-3](#c20-fig-0004) by adding a line that represents the
    best fit for the data. It uses `polyfit` to find the coefficients `a` and `b`,
    and then uses those coefficients to generate the predicted spring displacement
    for each force. Notice that there is an asymmetry in the way `forces` and `distance`
    are treated. The values in `forces` (which are derived from the mass suspended
    from the spring) are treated as independent, and used to produce the values in
    the dependent variable `predicted_distances` (a prediction of the displacements
    produced by suspending the mass).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 20-5](#c20-fig-0007) 中的函数 `fit_data` 通过添加一条表示数据最佳拟合的直线来扩展 [图 20-3](#c20-fig-0004)
    中的 `plot_data` 函数。它使用 `polyfit` 找到系数 `a` 和 `b`，然后利用这些系数生成每个力的预测弹簧位移。注意，`forces`
    和 `distance` 的处理方式存在不对称性。`forces` 中的值（来自悬挂在弹簧上的质量）被视为独立变量，用于生成因悬挂该质量而产生的因变量 `predicted_distances`
    的值。'
- en: '![c20-fig-0005.jpg](../images/c20-fig-0005.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![c20-fig-0005.jpg](../images/c20-fig-0005.jpg)'
- en: '[Figure 20-5](#c20-fig-0007a) Fitting a curve to data'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 20-5](#c20-fig-0007a) 拟合数据曲线'
- en: The function also computes the spring constant, `k`. The slope of the line,
    `a`, is `Δdistance/Δforce`. The spring constant, on the other hand, is `Δforce/Δdistance`.
    Consequently, `k` is the inverse of `a.`
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数还计算弹簧常数 `k`。直线的斜率 `a` 是 `Δdistance/Δforce`。另一方面，弹簧常数 `k` 是 `Δforce/Δdistance`。因此，`k`
    是 `a` 的倒数。
- en: The call `fit_data('springData.csv')` produces the plot in [Figure 20-6](#c20-fig-0008).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`fit_data('springData.csv')`生成[图20-6](#c20-fig-0008)中的图表。
- en: '![c20-fig-0006.jpg](../images/c20-fig-0006.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![c20-fig-0006.jpg](../images/c20-fig-0006.jpg)'
- en: '[Figure 20-6](#c20-fig-0008a) Measured points and linear model'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[图20-6](#c20-fig-0008a) 测量点和线性模型'
- en: It is interesting to observe that very few points actually lie on the least-squares
    fit. This is plausible because we are trying to minimize the sum of the squared
    errors, rather than maximize the number of points that lie on the line. Still,
    it doesn't look like a great fit. Let's try a cubic fit by adding to `fit_data`
    the code
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，实际上很少有点落在最小二乘拟合上。这是合理的，因为我们试图最小化平方误差的总和，而不是最大化落在直线上的点的数量。不过，这看起来似乎并不是一个很好的拟合。让我们通过向`fit_data`添加代码来尝试三次拟合
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this code, we have used the function `polyval` to generate the points associated
    with the cubic fit. This function takes two arguments: a sequence of polynomial
    coefficients and a sequence of values at which the polynomial is to be evaluated.
    The code fragments'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们使用了函数`polyval`来生成与三次拟合相关的点。这个函数接受两个参数：一组多项式系数和一组用于计算多项式值的自变量。代码片段
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: and
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: are equivalent.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 是等价的。
- en: This produces the plot in [Figure 20-7](#c20-fig-0009). The cubic fit looks
    like a much better model of the data than the linear fit, but is it? Probably
    not.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了[图20-7](#c20-fig-0009)中的图表。三次拟合似乎比线性拟合更好地描述了数据，但真的如此吗？可能不是。
- en: '![c20-fig-0007.jpg](../images/c20-fig-0007.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![c20-fig-0007.jpg](../images/c20-fig-0007.jpg)'
- en: '[Figure 20-7](#c20-fig-0009a) Linear and cubic fits'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[图20-7](#c20-fig-0009a) 线性与三次拟合'
- en: Both technical and popular articles frequently include plots like this that
    show both raw data and a curve fit to the data. All too often, however, the authors
    then go on to assume that the fitted curve is the description of the real situation,
    and the raw data merely an indication of experimental error. This can be dangerous.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 技术性和大众化文章经常包含这样的图表，展示原始数据和与数据拟合的曲线。然而，作者常常假设拟合曲线就是对实际情况的描述，而原始数据仅仅是实验误差的指示。这是很危险的。
- en: Recall that we started with a theory that there should be a linear relationship
    between the `x` and `y` values, not a cubic one. Let's see what happens if we
    use our linear and cubic fits to predict where the point corresponding to hanging
    a `1.5kg` weight would lie, [Figure 20-8](#c20-fig-0010).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们开始时的理论是`x`和`y`值之间应该存在线性关系，而不是三次关系。让我们看看如果使用我们的线性和三次拟合来预测对应于悬挂`1.5kg`重量的点会落在哪里，[图20-8](#c20-fig-0010)。
- en: '![c20-fig-0008.jpg](../images/c20-fig-0008.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![c20-fig-0008.jpg](../images/c20-fig-0008.jpg)'
- en: '[Figure 20-8](#c20-fig-0010a) Using the model to make a prediction'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[图20-8](#c20-fig-0010a) 使用模型进行预测'
- en: Now the cubic fit doesn't look so good. In particular, it seems highly unlikely
    that by hanging a large weight on the spring we can cause the spring to rise above
    (the y value is negative) the bar from which it is suspended. What we have is
    an example of **overfitting**. Overfitting typically occurs when a model is excessively
    complex, e.g., it has too many parameters relative to the amount of data. When
    this happens, the fit can capture noise in the data rather than meaningful relationships.
    A model that has been overfit usually has poor predictive power, as seen in this
    example.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在三次拟合看起来不太好。特别是，通过在弹簧上挂一个大重量，弹簧会升高到（y值为负）其悬挂的杆上方，这似乎极不可能。我们遇到的是**过拟合**的例子。过拟合通常发生在模型过于复杂时，例如，相对于数据量，它有太多参数。当这种情况发生时，拟合可以捕捉到数据中的噪声，而不是有意义的关系。过拟合的模型通常具有较差的预测能力，正如这个例子所示。
- en: '**Finger exercise:** Modify the code in [Figure 20-5](#c20-fig-0007) so that
    it produces the plot in [Figure 20-8](#c20-fig-0010).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**手指练习：** 修改[图20-5](#c20-fig-0007)中的代码，以便生成[图20-8](#c20-fig-0010)中的图表。'
- en: Let's go back to the linear fit. For the moment, forget the line and study the
    raw data. Does anything about it seem odd? If we were to fit a line to the rightmost
    six points it would be nearly parallel to the x-axis. This seems to contradict
    Hooke's law—until we recall that Hooke's law holds only up to some elastic limit.
    Perhaps that limit is reached for this spring somewhere around `7N` (approximately
    `0.7kg`).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到线性拟合。此刻，忘掉直线，研究原始数据。它有什么奇怪的地方吗？如果我们对最右侧的六个点拟合一条直线，它将几乎与x轴平行。这似乎与胡克定律相矛盾——直到我们记起胡克定律仅在某个弹性极限内有效。也许这个极限在`7N`（大约`0.7kg`）附近。
- en: Let's see what happens if we eliminate the last six points by replacing the
    second and third lines of the `fit_data` by
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果通过替换`fit_data`的第二和第三行来消除最后六个点会发生什么。
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As [Figure 20-9](#c20-fig-0011) shows, eliminating those points certainly makes
    a difference: `k` has dropped dramatically and the linear and cubic fits are almost
    indistinguishable. But how do we know which of the two linear fits is a better
    representation of how our spring performs up to its elastic limit? We could use
    some statistical test to determine which line is a better fit for the data, but
    that would be beside the point. This is not a question that can be answered by
    statistics. After all we could throw out all the data except any two points and
    know that `polyfit` would find a line that would be a perfect fit for those two
    points. It is never appropriate to throw out experimental results merely to get
    a better fit.[^(139)](#c20-fn-0003) Here we justified throwing out the rightmost
    points by appealing to the theory underlying Hooke''s law, i.e., that springs
    have an elastic limit. That justification could not have been appropriately used
    to eliminate points elsewhere in the data.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[图20-9](#c20-fig-0011)所示，去掉那些点确实会产生影响：`k`值显著下降，线性和立方拟合几乎无法区分。但我们怎么知道哪条线性拟合更好地代表了我们的弹簧在其弹性极限内的表现呢？我们可以使用某种统计检验来确定哪条线更适合数据，但那并不是重点。这个问题无法通过统计来回答。毕竟，我们可以抛弃所有数据，只保留任意两个点，并知道`polyfit`会找到一条完全适合这两个点的线。单纯为了获得更好的拟合而抛弃实验结果是完全不合适的。[^(139)](#c20-fn-0003)
    在这里，我们通过引用胡克定律的理论，即弹簧具有弹性极限，来合理化抛弃最右侧的点。这个理由不应该被用于其他地方的数据点。
- en: '![c20-fig-0009.jpg](../images/c20-fig-0009.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![c20-fig-0009.jpg](../images/c20-fig-0009.jpg)'
- en: '[Figure 20-9](#c20-fig-0011a) A model up to the elastic limit'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[图20-9](#c20-fig-0011a) 弹性极限的模型'
- en: 20.2 The Behavior of Projectiles
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.2 发射体的行为
- en: Growing bored with merely stretching springs, we decided to use one of our springs
    to build a device capable of launching a projectile.[^(140)](#c20-fn-0004) We
    used the device four times to fire a projectile at a target `30` yards (`1080`
    inches) from the launching point. Each time, we measured the height of the projectile
    at various distances from the launching point. The launching point and the target
    were at the same height, which we treated as `0.0` in our measurements.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于仅仅拉伸弹簧感到厌倦，我们决定用我们的一个弹簧制作一个能够发射发射体的装置。[^(140)](#c20-fn-0004) 我们使用该装置四次，将发射体发射到距离发射点`30`码（`1080`英寸）的目标上。每次，我们都测量发射体在距离发射点不同距离时的高度。发射点和目标在同一高度，我们在测量中将其视为`0.0`。
- en: The data was stored in a file, part of which shown in [Figure 20-10](#c20-fig-0012).
    The first column contains distances of the projectile from the target. The other
    columns contain the height of the projectile at that distance for each of the
    four trials. All of the measurements are in inches.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储在一个文件中，部分数据如[图20-10](#c20-fig-0012)所示。第一列包含发射体距离目标的距离。其他列包含在该距离下四次实验中发射体的高度。所有测量均以英寸为单位。
- en: '![c20-fig-0010.jpg](../images/c20-fig-0010.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![c20-fig-0010.jpg](../images/c20-fig-0010.jpg)'
- en: '[Figure 20-10](#c20-fig-0012a) Data from projectile experiment'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[图20-10](#c20-fig-0012) 来自发射体实验的数据'
- en: The code in [Figure 20-11](#c20-fig-0013) was used to plot the mean altitude
    of the projectile in the four trials against the distance from the point of launch.
    It also plots the best linear and quadratic fits to those points. (In case you
    have forgotten the meaning of multiplying a list by an integer, the expression
    `[0]*len(distances)` produces a list of `len(distances)` `0`'s.)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[图20-11](#c20-fig-0013)中的代码用于绘制四次实验中发射体的平均高度与发射点之间的距离关系。它还绘制了这些点的最佳线性和二次拟合。（如果你忘记了将列表与整数相乘的含义，表达式`[0]*len(distances)`将生成一个包含`len(distances)`个`0`的列表。）'
- en: '![c20-fig-0011.jpg](../images/c20-fig-0011.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![c20-fig-0011.jpg](../images/c20-fig-0011.jpg)'
- en: '[Figure 20-11](#c20-fig-0013a) Plotting the trajectory of a projectile'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[图20-11](#c20-fig-0013a) 绘制发射体的轨迹'
- en: A quick look at the plot in [Figure 20-12](#c20-fig-0014) makes it quite clear
    that a quadratic fit is far better than a linear one.[^(141)](#c20-fn-0005) But,
    in an absolute sense, just how bad a fit is the line and how good is the quadratic
    fit?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过快速查看[图20-12](#c20-fig-0014)中的图表，很明显，二次拟合远优于线性拟合。[^(141)](#c20-fn-0005) 但从绝对意义上讲，这条线的拟合有多糟糕，二次拟合又有多好呢？
- en: '![c20-fig-0012.jpg](../images/c20-fig-0012.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![c20-fig-0012.jpg](../images/c20-fig-0012.jpg)'
- en: '[Figure 20-12](#c20-fig-0014a) Plot of trajectory'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 20-12](#c20-fig-0014a) 轨迹图'
- en: 20.2.1  Coefficient of Determination
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.2.1 决定系数
- en: When we fit a curve to a set of data, we are finding a function that relates
    an independent variable (inches horizontally from the launch point in this example)
    to a predicted value of a dependent variable (inches above the launch point in
    this example). Asking about the **goodness of a fit** is equivalent to asking
    about the accuracy of these predictions. Recall that the fits were found by minimizing
    the mean square error. This suggests that we could evaluate the goodness of a
    fit by looking at the mean square error. The problem with that approach is that
    while there is a lower bound for the mean square error (0), there is no upper
    bound. This means that while the mean square error is useful for comparing the
    relative goodness of two fits to the same data, it is not particularly useful
    for getting a sense of the absolute goodness of a fit.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为一组数据拟合曲线时，我们是在寻找一个将自变量（本例中从发射点水平距离的英寸数）与因变量的预测值（本例中发射点以上的英寸数）关联的函数。询问**拟合优度**相当于询问这些预测的准确性。请记住，拟合是通过最小化均方误差来找到的。这表明我们可以通过查看均方误差来评估拟合优度。该方法的问题在于，虽然均方误差有下界（0），但没有上界。这意味着尽管均方误差对于比较同一数据的两个拟合的相对优度是有用的，但它对于获取拟合的绝对优度的感觉并不特别有用。
- en: We can calculate the absolute goodness of a fit using the **coefficient of determination**,
    often written as `R`**²**.[^(142)](#c20-fn-0006) Let *y[i]* be the *i^(th)*observed
    value, *p[i]* be the corresponding value predicted by the model, and *μ* be the
    mean of the observed values.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**决定系数**计算拟合的绝对优度，通常写作`R`**²**。[^(142)](#c20-fn-0006) 设*y[i]*为第*i^(th)*个观察值，*p[i]*为模型预测的对应值，*μ*为观察值的均值。
- en: '![c20-fig-5003.jpg](../images/c20-fig-5003.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![c20-fig-5003.jpg](../images/c20-fig-5003.jpg)'
- en: By comparing the estimation errors (the numerator) with the variability of the
    original values (the denominator), `R`² is intended to capture the proportion
    of variability (relative to the mean) in a data set that is accounted for by the
    statistical model provided by the fit. When the model being evaluated is produced
    by a linear regression, the value of `R`² always lies between `0` and `1`. If
    `R`² `= 1`, the model is a perfect fit to the data. If `R`² `= 0`, there is no
    relationship between the values predicted by the model and the way the data is
    distributed around the mean.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将估计误差（分子）与原始值的变异性（分母）进行比较，`R`²旨在捕捉统计模型所解释的数据集中相对于均值的变异比例。当评估的模型由线性回归产生时，`R`²的值始终介于`0`和`1`之间。如果`R`²`=
    1`，则模型与数据完全拟合。如果`R`²`= 0`，则模型预测的值与数据围绕均值的分布之间没有关系。
- en: The code in [Figure 20-13](#c20-fig-0016) provides a straightforward implementation
    of this statistical measure. Its compactness stems from the expressiveness of
    the operations on numpy arrays. The expression `(predicted - measured)**2` subtracts
    the elements of one array from the elements of another, and then squares each
    element in the result. The expression `(measured - mean_of_measured)**2)` subtracts
    the scalar value `mean_of_measured` from each element of the array `measured`,
    and then squares each element of the results.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 20-13](#c20-fig-0016)中的代码提供了这个统计度量的直接实现。它的紧凑性源于对numpy数组操作的表达能力。表达式`(predicted
    - measured)**2`从一个数组的元素中减去另一个数组的元素，然后对结果中的每个元素进行平方。表达式`(measured - mean_of_measured)**2`从数组`measured`的每个元素中减去标量值`mean_of_measured`，然后对结果中的每个元素进行平方。'
- en: '![c20-fig-0013.jpg](../images/c20-fig-0013.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![c20-fig-0013.jpg](../images/c20-fig-0013.jpg)'
- en: '[Figure 20-13](#c20-fig-0016a) Computing R²'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 20-13](#c20-fig-0016a) 计算 R²'
- en: When the lines of code
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码行
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: and
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: are inserted after the appropriate calls to `plt.plot` in `process_trajectories`
    (see [Figure 20-11](#c20-fig-0013)), they print
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`process_trajectories`中适当调用`plt.plot`之后插入时，它们会打印
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Roughly speaking, this tells us that less than `2%` of the variation in the
    measured data can be explained by the linear model, but more than `98%` of the
    variation can be explained by the quadratic model.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 粗略地说，这告诉我们，线性模型只能解释测量数据中不到`2%`的变异，但二次模型可以解释超过`98%`的变异。
- en: 20.2.2 Using a Computational Model
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.2.2 使用计算模型
- en: 'Now that we have what seems to be a good model of our data, we can use this
    model to help answer questions about our original data. One interesting question
    is the horizontal speed at which the projectile is traveling when it hits the
    target. We might use the following train of thought to design a computation that
    answers this question:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个似乎是我们数据的良好模型，我们可以利用这个模型帮助回答关于我们原始数据的问题。一个有趣的问题是弹道在击中目标时的水平速度。我们可以使用以下思路来设计一个计算，以回答这个问题：
- en: 1\. We know that the trajectory of the projectile is given by a formula of the
    form `y = ax`² `+ bx + c`, i.e., it is a parabola. Since every parabola is symmetrical
    around its vertex, we know that its peak occurs halfway between the launch point
    and the target; call this distance `xMid`. The peak height, yPeak, is therefore
    given by yPeak =a*xMid² + b*xMid + c.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 我们知道，弹道的轨迹由形式为`y = ax`² `+ bx + c`的公式给出，即它是一个抛物线。由于每个抛物线在其顶点处是对称的，我们知道其最高点发生在发射点与目标之间的中间位置；将此距离称为`xMid`。因此，峰值高度yPeak由yPeak
    = a*xMid² + b*xMid + c给出。
- en: 2\. If we ignore air resistance (remember that no model is perfect), we can
    compute the amount of time it takes for the projectile to fall from `yPeak` to
    the height of the target, because that is purely a function of gravity. It is
    given by the equation ![c20-fig-5004.jpg](../images/c20-fig-5004.jpg).[^(143)](#c20-fn-0007)
    This is also the amount of time it takes for the projectile to travel the horizontal
    distance from `xMid` to the target, because once it reaches the target it stops
    moving.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 如果我们忽略空气阻力（记住没有模型是完美的），我们可以计算弹道从`yPeak`降到目标高度所需的时间，因为这纯粹是重力的函数。它由方程给出![c20-fig-5004.jpg](../images/c20-fig-5004.jpg)。[^(143)](#c20-fn-0007)这也是弹道从`xMid`移动到目标所需的时间，因为一旦它到达目标就停止移动。
- en: 3\. Given the time to go from `xMid` to the target, we can easily compute the
    average horizontal speed of the projectile over that interval. If we assume that
    the projectile was neither accelerating nor decelerating in the horizontal direction
    during that interval, we can use the average horizontal speed as an estimate of
    the horizontal speed when the projectile hits the target.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 给定从`xMid`到目标的时间，我们可以轻松计算该时间段内弹道的平均水平速度。如果我们假设弹道在该时间段内在水平方向上既没有加速也没有减速，我们可以将平均水平速度作为弹道击中目标时水平速度的估计。
- en: '[Figure 20-14](#c20-fig-0017) implements this technique for estimating the
    horizontal velocity of the projectile.[^(144)](#c20-fn-0008)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 20-14](#c20-fig-0017)实现了这种估算弹道水平速度的技术。[^(144)](#c20-fn-0008)'
- en: '![c20-fig-0014.jpg](../images/c20-fig-0014.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![c20-fig-0014.jpg](../images/c20-fig-0014.jpg)'
- en: '[Figure 20-14](#c20-fig-0017a) Computing the horizontal speed of a projectile'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 20-14](#c20-fig-0017a) 计算弹道的水平速度'
- en: "When the line `\uFEFFget_horizontal_speed(fit, distances[-1], distances[0])`\
    \ is inserted at the end of `process_trajectories (`[Figure 20-11](#c20-fig-0013)`)`,\
    \ it prints"
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: "当在`process_trajectories (`[图 20-11](#c20-fig-0013)`)`末尾插入行`\uFEFFget_horizontal_speed(fit,\
    \ distances[-1], distances[0])`时，它会打印。"
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The sequence of steps we have just worked through follows a common pattern.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚经历的步骤序列遵循一个常见模式。
- en: 1\. We started by performing an experiment to get some data about the behavior
    of a physical system.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 我们首先进行了一项实验，以获取有关物理系统行为的数据。
- en: 2\. We then used computation to find and evaluate the quality of a model of
    the behavior of the system.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 然后我们使用计算来寻找并评估系统行为模型的质量。
- en: 3\. Finally, we used some theory and analysis to design a simple computation
    to derive an interesting consequence of the model.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 最后，我们使用一些理论和分析设计了一个简单的计算，以推导出模型的一个有趣结果。
- en: '**Finger exercise:** In a vacuum, the speed of a falling object is defined
    by the equation `v = v0 + gt`, where `v0` is the initial velocity of the object,
    `t` is the number of seconds the object has been falling, and *g* is the gravitational
    constant, roughly `9.8 m/sec`² on the surface of the Earth and `3.711 m/ sec`²
    on Mars. A scientist measures the velocity of a falling object on an unknown planet.
    She does this by measuring the downward velocity of an object at different points
    in time. At time `0`, the object has an unknown velocity of `v0`. Implement a
    function that fits a model to the time and velocity data and estimates `g` for
    that planet and `v0` for the experiment. It should return its estimates for `g`
    and `v0`, and also r-squared for the model.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**手指练习：** 在真空中，物体下落的速度由方程`v = v0 + gt`定义，其中`v0`是物体的初始速度，`t`是物体下落的秒数，*g*是重力常数，地球表面约为`9.8
    m/sec`²，火星上为`3.711 m/sec`²。一位科学家在一个未知星球上测量下落物体的速度。她通过在不同时间点测量物体的下落速度来实现。在时间`0`时，物体的速度为未知的`v0`。实现一个函数，将模型拟合到时间和速度数据上，并估计该星球的`g`和实验的`v0`。它应该返回`g`和`v0`的估计值，以及模型的r平方值。'
- en: 20.3 Fitting Exponentially Distributed Data
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.3 拟合指数分布数据
- en: '`Polyfit` uses linear regression to find a polynomial of a given degree that
    is the best least-squares fit for some data. It works well if the data can be
    directly approximated by a polynomial. But this is not always possible. Consider,
    for example, the simple exponential growth function `y = 3`^x. The code in [Figure
    20-15](#c20-fig-0018) fits a fifth-degree polynomial to the first tenpoints and
    plots the results as shown in [Figure 20-16](#c20-fig-0019). It uses the function
    call `np.arange(10)`, which returns an `array` containing the integers `0-9.`
    The parameter setting `markeredgewidth = 2` sets the width of the lines used in
    the marker.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Polyfit`使用线性回归来找到某个给定次数的多项式，该多项式是某些数据的最佳最小二乘拟合。如果数据可以直接用多项式近似，它工作得很好。但这并不总是可能。例如，考虑简单的指数增长函数`y
    = 3`^x。[图 20-15](#c20-fig-0018)中的代码拟合了一个五次多项式到前十个点，并按[图 20-16](#c20-fig-0019)中的结果绘制。它使用函数调用`np.arange(10)`，返回一个包含整数`0-9`的`array`。参数设置`markeredgewidth
    = 2`设置了标记中使用的线条宽度。'
- en: '![c20-fig-0015.jpg](../images/c20-fig-0015.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![c20-fig-0015.jpg](../images/c20-fig-0015.jpg)'
- en: '[Figure 20-15](#c20-fig-0018a) Fitting a polynomial curve to an exponential
    distribution'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 20-15](#c20-fig-0018a) 拟合指数分布的多项式曲线'
- en: '![c20-fig-0016.jpg](../images/c20-fig-0016.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![c20-fig-0016.jpg](../images/c20-fig-0016.jpg)'
- en: '[Figure 20-16](#c20-fig-0019a) Fitting an exponential distribution'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 20-16](#c20-fig-0019a) 拟合指数分布'
- en: The fit is clearly a good one for these data points. However, let's look at
    what the model predicts for `3`^(20). When we add the code
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 拟合对于这些数据点显然是好的。然而，让我们看看模型对`3`^(20)的预测。当我们添加代码时
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: to the end of [Figure 20-15](#c20-fig-0018), it prints,
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到[图 20-15](#c20-fig-0018)的末尾，它打印出，
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Oh dear! Despite fitting the data, the model produced by `polyfit` is apparently
    not a good one. Is it because `5` was not the right degree? No. It is because
    no polynomial is a good fit for an exponential distribution. Does this mean that
    we cannot use `polyfit` to build a model of an exponential distribution? Fortunately,
    it does not, because we can use `polyfit` to find a curve that fits the original
    independent values and the log of the dependent values.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！尽管拟合了数据，但`polyfit`产生的模型显然不好。这是因为`5`不是正确的次数吗？不。这是因为没有多项式能很好地拟合指数分布。这是否意味着我们无法使用`polyfit`来建立指数分布的模型？幸运的是，不是这样，因为我们可以使用`polyfit`找到一个适合原始独立值和依赖值对数的曲线。
- en: Consider the exponential sequence `[1, 2, 4, 8, 16, 32, 64, 128, 256, 512]`.
    If we take the log base `2` of each value, we get the sequence `[0, 1, 2, 3, 4,
    5, 6, 7, 8, 9]`, i.e., a sequence that grows linearly. In fact, if a function
    `y = f(x)` exhibits exponential growth, the log (to any base) of `f(x)` grows
    linearly. This can be visualized by plotting an exponential function with a logarithmic
    y-axis. The code
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑指数序列`[1, 2, 4, 8, 16, 32, 64, 128, 256, 512]`。如果我们对每个值取以`2`为底的对数，我们得到序列`[0,
    1, 2, 3, 4, 5, 6, 7, 8, 9]`，即线性增长的序列。实际上，如果一个函数`y = f(x)`表现出指数增长，则`f(x)`的对数（以任何底数）都是线性增长的。这可以通过绘制具有对数y轴的指数函数来可视化。代码
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: produces the plot in [Figure 20-17](#c20-fig-0020).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 产生的图在[图 20-17](#c20-fig-0020)中。
- en: '![c20-fig-0017.jpg](../images/c20-fig-0017.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![c20-fig-0017.jpg](../images/c20-fig-0017.jpg)'
- en: '[Figure 20-17](#c20-fig-0020a) An exponential on a semilog plot'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 20-17](#c20-fig-0020a) 半对数图上的指数'
- en: The fact that taking the log of an exponential function produces a linear function
    can be used to construct a model for an exponentially distributed set of data
    points, as illustrated by the code in [Figure 20-18](#c20-fig-0021). We use `polyfit`
    to find a curve that fits the `x` values and the log of the `y` values. Notice
    that we use yet another Python standard library module, `math`, which supplies
    a `log` function. (We could have used `np.log2`, but wanted to point out that
    `math` has a more general log function.)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对指数函数取对数会产生线性函数这一事实可以用来构建指数分布的数据点模型，如[图 20-18](#c20-fig-0021)中的代码所示。我们使用 `polyfit`
    找到适合 `x` 值和 `y` 值对数的曲线。请注意，我们还使用了另一个 Python 标准库模块 `math`，它提供了一个 `log` 函数。（我们本可以使用
    `np.log2`，但想指出 `math` 有一个更通用的对数函数。）
- en: '![c20-fig-0018.jpg](../images/c20-fig-0018.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![c20-fig-0018.jpg](../images/c20-fig-0018.jpg)'
- en: '[Figure 20-18](#c20-fig-0021a) Using `polyfit` to fit an exponential'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 20-18](#c20-fig-0021a) 使用 `polyfit` 拟合指数函数'
- en: When run, the code
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，代码
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: produces the plot in [Figure 20-19](#c20-fig-0022), in which the actual values
    and the predicted values coincide. Moreover, when the model is tested on a value
    (`20`) that was not used to produce the fit, it prints
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图在[图 20-19](#c20-fig-0022)中，实际值与预测值重合。此外，当模型在一个未用于生成拟合值的值（`20`）上进行测试时，它输出为
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![c20-fig-0019.jpg](../images/c20-fig-0019.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![c20-fig-0019.jpg](../images/c20-fig-0019.jpg)'
- en: '[Figure 20-19](#c20-fig-0022a) A fit for an exponential function'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 20-19](#c20-fig-0022a) 指数函数的拟合'
- en: This method of using `polyfit` to find a model for data works when the relationship
    can be described by an equation of the form `y = base`^(ax+b). If used on data
    for which such a model is not a reasonably good fit, it will yield poor results.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `polyfit` 找到数据模型的方法适用于关系可以用形式为 `y = base`^(ax+b) 的方程描述的情况。如果用于不适合此模型的数据，将会产生糟糕的结果。
- en: To see this, let's create `yVals` using
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这一点，我们使用
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The model now makes a poor prediction, printing
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型现在的预测效果很差，输出为
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 20.4 When Theory Is Missing
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.4 当理论缺失时
- en: In this chapter, we have emphasized the interplay between theoretical, experimental,
    and computational science. Sometimes, however, we find ourselves with lots of
    interesting data, but little or no theory. In such cases, we often resort to using
    computational techniques to develop a theory by building a model that seems to
    fit the data.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们强调了理论、实验和计算科学之间的相互作用。然而，有时我们发现自己拥有大量有趣的数据，却几乎没有理论。在这种情况下，我们通常 resort
    to 使用计算技术通过构建一个似乎符合数据的模型来发展理论。
- en: In an ideal world, we would run a controlled experiment (e.g., hang weights
    from a spring), study the results, and retrospectively formulate a model consistent
    with those results. We would then run a new experiment (e.g., hang different weights
    from the same spring), and compare the results of that experiment to what the
    model predicted.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想情况下，我们会进行一次受控实验（例如，从弹簧上挂重物），研究结果，然后回顾性地制定与结果一致的模型。接着我们会进行新的实验（例如，从同一个弹簧上挂不同的重物），并将实验结果与模型预测进行比较。
- en: Unfortunately, in many cases it is impossible to run even one controlled experiment.
    Imagine, for example, building a model designed to shed light on how interest
    rates affect stock prices. Very few of us are in a position to set interest rates
    and see what happens. On the other hand, there is no shortage of relevant historical
    data.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在许多情况下，甚至无法进行一次受控实验。举个例子，假设建立一个模型来揭示利率如何影响股价。我们中的很少有人有能力设定利率并观察结果。另一方面，相关的历史数据却是源源不断的。
- en: In such situations, we can simulate a set of experiments by dividing the existing
    data into a **training set** and a **holdout set** to use as a **test set**. Without
    looking at the holdout set, we build a model that seems to explain the training
    set. For example, we find a curve that has a reasonable `R`² for the training
    set. We then test that model on the holdout set. Most of the time the model will
    fit the training set more closely than it fits the holdout set. But if the model
    is a good one, it should fit the holdout set reasonably well. If it doesn't, the
    model should probably be discarded.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以通过将现有数据分为**训练集**和**保留集**来模拟一组实验，用作**测试集**。在不查看保留集的情况下，我们建立一个似乎能解释训练集的模型。例如，我们找到一个对训练集具有合理
    `R`² 的曲线。然后我们在保留集上测试该模型。大多数情况下，该模型会比保留集拟合训练集得更好。但是如果模型是好的，它应该能合理地拟合保留集。如果没有，那么该模型可能应该被舍弃。
- en: How do we choose the training set? We want it to be representative of the data
    set as a whole. One way to do this is to randomly choose the samples for the training
    set. If the data set is sufficiently large, this often works pretty well.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何选择训练集？我们希望它能代表整个数据集。一种方法是随机选择训练集的样本。如果数据集足够大，这通常效果不错。
- en: A related but slightly different way to check a model is to train on many randomly
    selected subsets of the original data and see how similar the models are to one
    another. If they are quite similar, then we can feel pretty good. This approach
    is known as **cross validation**.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 检查模型的另一种相关但稍微不同的方法是对原始数据的多个随机选择子集进行训练，并查看模型之间的相似程度。如果它们非常相似，那么我们可以比较有信心。这种方法称为**交叉验证**。
- en: Cross validation is discussed in more detail in Chapters 21 and 24.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉验证在第21章和第24章中有更详细的讨论。
- en: 20.5 Terms Introduced in Chapter
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.5 在章节中引入的术语
- en: Hooke's law
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胡克定律
- en: elastic limit
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性极限
- en: spring constant
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹簧常数
- en: curve fitting
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 曲线拟合
- en: least squares
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小二乘法
- en: linear regression
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性回归
- en: polynomial regression
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多项式回归
- en: overfitting
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过拟合
- en: goodness of fit
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拟合优度
- en: coefficient of determination (R²)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定系数 (R²)
- en: training set
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练集
- en: test set
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试集
- en: holdout set
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留集
- en: cross validation
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交叉验证
