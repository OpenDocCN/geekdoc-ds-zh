- en: Chapter 10 Using Third-Party Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章 使用第三方代码
- en: 原文：[https://randpythonbook.netlify.app/using-third-party-code](https://randpythonbook.netlify.app/using-third-party-code)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://randpythonbook.netlify.app/using-third-party-code](https://randpythonbook.netlify.app/using-third-party-code)'
- en: Before using third-party code, it must first be installed. After it is installed,
    it must be “loaded in” to your session. I will describe both of these steps in
    R and Python.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用第三方代码之前，必须首先安装它。安装后，必须将其“加载”到您的会话中。我将在这两部分中分别介绍 R 和 Python。
- en: 10.1 Installing Packages In R
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 在 R 中安装软件包
- en: In R, there are thousands of free, user-created **packages** (Lander [2017](#ref-r_for_everyone)).
    You can download most of these from the [*Comprehensive R Archive Network*](https://cran.r-project.org/).
    You can also download packages from other publishing platforms like [Bioconductor](https://www.bioconductor.org/),
    or [Github](https://github.com/). Installing from CRAN is more commonplace, and
    extremely easy to do. Just use the `install.packages()` function. This can be
    run inside your R console, so there is no need to type things into the command
    line.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，有成千上万的免费、用户创建的**软件包**（Lander [2017](#ref-r_for_everyone)）。您可以从[*综合 R 存档网络*](https://cran.r-project.org/)下载其中大部分。您还可以从其他发布平台下载软件包，如[Bioconductor](https://www.bioconductor.org/)或[Github](https://github.com/)。从
    CRAN 安装更为常见，并且非常容易操作。只需使用`install.packages()`函数即可。这可以在您的 R 控制台中运行，因此无需在命令行中输入内容。
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 10.2 Installing Packages In Python
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 在 Python 中安装软件包
- en: In Python, installing packages is more complicated. Commands must be written
    in the command line, and there are multiple package managers. This isn’t surprising,
    because Python is used more extensively than R in fields other than data science.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，安装软件包更为复杂。必须在命令行中编写命令，并且存在多个软件包管理器。这并不奇怪，因为除了数据科学之外，Python 在其他领域的使用比
    R 更广泛。
- en: If you followed the suggestions provided in earlier in the text, then you installed
    Anaconda. This means you will usually be using the [`conda` command](https://docs.anaconda.com/anaconda/user-guide/tasks/install-packages/).
    Point-and-click interfaces are made available as well.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遵循了文本中提供的建议，那么您已经安装了 Anaconda。这意味着您通常会使用[`conda`命令](https://docs.anaconda.com/anaconda/user-guide/tasks/install-packages/)。还提供了点对点界面。
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are some packages that will not be available using this method. For more
    information on that situation, see [here.](https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-pkgs.html#install-non-conda-packages)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法可能无法访问某些软件包。有关该情况的更多信息，请参阅[此处](https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-pkgs.html#install-non-conda-packages)。
- en: 10.3 Loading Packages In R
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 在 R 中加载软件包
- en: After they are installed on your machine, third-party code will need to be “loaded”
    into your R or Python session.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的机器上安装后，第三方代码需要被“加载”到您的 R 或 Python 会话中。
- en: Loading in a package is relatively simple in R, however complications can arise
    when different variables share the same name. This happens relatively often because
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中加载软件包相对简单，然而当不同的变量共享相同的名称时可能会出现复杂情况。这种情况相对常见，因为
- en: it’s easy to create a variable in the global environment that has the same name
    as another object you don’t know about, and
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在全局环境中创建一个与您不知道的其他对象同名变量很容易，
- en: different packages you load in sometimes share names accidentally.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您加载的不同软件包有时会意外地共享名称。
- en: Starting off with the basics, here’s how to load in a package of third-party
    code. Just type the following into your R console.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从基础知识开始，以下是如何在 R 控制台中加载第三方代码包。只需将以下内容输入到您的 R 控制台中。
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can also use the `require()` function, which has slightly different behavior
    when the requested package is not found.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`require()`函数，当请求的软件包未找到时，该函数的行为略有不同。
- en: To understand this more deeply, we need to talk about **environments** again.
    We discussed these before in [6.3](/functions#more-details-on-rs-user-defined-functions),
    but only in the context of user-defined functions. When we load in a package with
    `library()`, we make its contents available by putting it all in an environment
    for that package.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要更深入地理解这一点，我们需要再次讨论**环境**。我们之前在[6.3](/functions#more-details-on-rs-user-defined-functions)中讨论过这些，但仅限于用户定义函数的上下文。当我们使用`library()`加载软件包时，我们通过将其全部放入该软件包的环境中来使其内容可用。
- en: An [environment](https://cran.r-project.org/doc/manuals/R-lang.html#Environment-objects)
    holds the names of objects. There are usually several environments, and each holds
    a different set of functions and variables. All the variables you define are in
    an environment, every package you load in gets its own environment, and all the
    functions that come in R pre-loaded have their own environment.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个[环境](https://cran.r-project.org/doc/manuals/R-lang.html#Environment-objects)包含对象的名称。通常有几个环境，每个环境包含不同的函数和变量集合。你定义的所有变量都在一个环境中，你加载的每个包都有自己的环境，R
    预加载的所有函数也有它们自己的环境。
- en: 'Formally, each environment is pair of two things: a **frame** and an **enclosure**.
    The frame is the set of symbol-value pairs, and the enclosure is a pointer to
    the parent environment. If you’ve heard of a *linked list* in a computer science
    class, it’s the same thing.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 形式上，每个环境由两个东西组成：一个**框架**和一个**封装器**。框架是符号值对的集合，封装器是指向父环境的指针。如果你在计算机科学课程中听说过**链表**，那么它就是同一回事。
- en: Moreover, all of these environments are connected in a chain-like structure.
    To see what environments are loaded on your machine, and what order they were
    loaded in, use the `search()` function. This displays the [**search path**](https://cran.r-project.org/doc/manuals/R-lang.html#Search-path),
    or the ordered sequence of all of your environments.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有这些环境都连接成一个链状结构。要查看你的机器上加载了哪些环境以及它们的加载顺序，请使用 `search()` 函数。这显示了[**搜索路径**](https://cran.r-project.org/doc/manuals/R-lang.html#Search-path)，即所有环境的有序序列。
- en: Alternatively, if you’re using RStudio, the search path, and the contents of
    each of its environments, are displayed in the “Environment” window. You can choose
    which environment you’d like to look at by selecting it from the drop-down menu.
    This allows you to see all of the variables in that particular environment. The
    **global environment** (i.e. `".GlobalEnv"`) is displayed by default, because
    that is where you store all the objects you are creating in the console.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你使用的是 RStudio，搜索路径以及每个环境的内含物都会在“环境”窗口中显示。你可以通过从下拉菜单中选择来查看你想要查看的环境。这允许你看到该特定环境中的所有变量。默认情况下显示的是**全局环境**（即
    `".GlobalEnv"`），因为这是你存储在控制台创建的所有对象的地方。
- en: '![The Environment Window in RStudio](../Images/d8fb1046f559e66fd0254cffa591dff1.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![RStudio中的环境窗口](../Images/d8fb1046f559e66fd0254cffa591dff1.png)'
- en: 'Figure 10.1: The Environment Window in RStudio'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：RStudio中的环境窗口
- en: When you call `library(thePackage)`, the package has an environment created
    for it, and it is *inserted between the global environment, and the most recently
    loaded package.* When you want to access an object by name, R will first search
    the global environment, and then it will traverse the environments in the search
    path in order. These has a few important implications.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `library(thePackage)` 时，为该包创建了一个环境，并且它被**插入到全局环境和最近加载的包之间**。当你想通过名称访问一个对象时，R
    首先会搜索全局环境，然后按照搜索路径的顺序遍历环境。这有几个重要的含义。
- en: First, **don’t define variables in the global environment that are already named
    in another environment.** There are many variables that come pre-loaded in the
    `base` package (to see them, type `ls("package:base")`), and if you like using
    a lot of packages, you’re increasing the number of names you should avoid using.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，**不要在全局环境中定义在其他环境中已经命名的变量**。`base` 包中预加载了许多变量（要查看它们，请输入 `ls("package:base")`），如果你喜欢使用很多包，那么你应该避免使用的名称数量就会增加。
- en: Second, **don’t `library()` in a package unless you need it, and if you do,
    be aware of all the names it will mask it packages you loaded in before**. The
    good news is that `library` will often print warnings letting you know which names
    have been masked. The bad news is that it’s somewhat out of your control–if you
    need two packages, then they might have a shared name, and the only thing you
    can do about it is watch the ordering you load them in.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，**除非你需要，否则不要在包中使用 `library()`，并且如果你确实需要，要意识到它将掩盖你之前加载的包中的所有名称**。好消息是 `library`
    通常会打印警告，告诉你哪些名称已被掩盖。坏消息是这有点超出你的控制——如果你需要两个包，它们可能有一个共享的名称，而你能做的唯一一件事就是注意它们的加载顺序。
- en: Third, don’t use `library()` inside code that is `source()`’d in other files.
    For example, if you attach a package to the search path from within a function
    you defined, anybody that uses your function loses control over the order of packages
    that get attached.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，不要在其他文件中`source()`的代码中使用`library()`。例如，如果你在一个你定义的函数内部将包附加到搜索路径，那么使用你的函数的人将失去控制附加包的顺序。
- en: All is not lost if there is a name conflict. The variables haven’t disappeared.
    It’s just slightly more difficult to refer to them. For instance, if I load in
    `Hmisc` (Harrell Jr, Charles Dupont, and others. [2021](#ref-hmisc)), I get the
    warning warning that `format.pval` and `units` are now masked because they were
    names that were in `"package:base"`. I can still refer to these masked variables
    with the double colon operator (`::`).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在名称冲突，并非一切都已丢失。变量并没有消失。只是引用它们稍微困难一些。例如，如果我加载了`Hmisc`（Harrell Jr, Charles
    Dupont等人。[2021](#ref-hmisc)），我得到警告，警告说`format.pval`和`units`现在被屏蔽，因为它们是`"package:base"`中的名称。我仍然可以用双冒号运算符（`::`）引用这些屏蔽变量。
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 10.4 Loading Packages In Python
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 在Python中加载包
- en: In Python, you use the `import` statement to access objects defined in another
    file. It is slightly more complicated than R’s `library()` function, but it is
    also more flexible. To make the contents of a package called, say, `the_package`
    available, type *one of the following* inside a Python session.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，你使用`import`语句来访问另一个文件中定义的对象。它比R的`library()`函数稍微复杂一些，但也更加灵活。为了使名为`the_package`的包的内容可用，在Python会话中输入以下之一。
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To describe the difference between these three approaches, as well as to highlight
    the important takeaways and compare them with the important takeaways in the last
    section, we need to discuss what a Python module is, what a package is, and what
    a Python namespace is.[^(17)](#fn17)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了描述这三种方法的区别，以及突出重要的要点并与上一节的重要要点进行比较，我们需要讨论什么是Python模块，什么是包，以及什么是Python命名空间。[^(17)](#fn17)
- en: A Python [**`module`**](https://docs.python.org/3/tutorial/modules.html) is
    a `.py` file, separate from the one you are currently editing, with function and/or
    object definitions in it.[^(18)](#fn18)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Python[**模块**](https://docs.python.org/3/tutorial/modules.html)是一个包含函数和/或对象定义的`.py`文件，与当前编辑的文件分开。[^(18)](#fn18)
- en: A [package](https://docs.python.org/3/tutorial/modules.html#packages) is a group
    of modules.[^(19)](#fn19)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个[包](https://docs.python.org/3/tutorial/modules.html#packages)是一组模块。[^(19)](#fn19)
- en: A [**namespace**](https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces)
    is “a mapping from names to objects.”
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个[**命名空间**](https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces)是“从名称到对象的映射。”
- en: With these definitions, we can define `import`ing. According to the [Python
    documentation](https://docs.python.org/3/reference/import.html#the-import-system),
    “[t]he import statement combines two operations; it searches for the named module,
    then it binds the results of that search to a name in the local scope.”
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python文档[Python文档](https://docs.python.org/3/reference/import.html#the-import-system)，“`import`语句结合了两个操作；它搜索命名的模块，然后将搜索结果绑定到局部作用域中的一个名称。”
- en: The sequence of places Python looks for a module is called the search path.
    This is not the same as R’s search path, though. In Python, the search path is
    a list of places to look for *modules*, not a list of places to look for variables.
    To see it, `import sys`, then type `sys.path`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Python查找模块的顺序称为搜索路径。这不同于R的搜索路径。在Python中，搜索路径是查找模块的地点列表，而不是查找变量的地点列表。要查看它，请输入`import
    sys`，然后输入`sys.path`。
- en: After a module is found, the variable names inside it become available to the
    `import`ing module. These variables are available in the global scope, but the
    names you use to access them will depend on what kind of `import` statement you
    used. From there, you are using the same scoping rules that we described in [6.6](/functions#function-scope-in-python),
    which means the LEGB acronym still applies.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 找到模块后，其中的变量名称对导入模块可用。这些变量在全局作用域中可用，但你用来访问它们的名称将取决于你使用的`import`语句的类型。从那里，你使用的是我们在[6.6](/functions#function-scope-in-python)中描述的作用域规则，这意味着LEGB缩写词仍然适用。
- en: In both languages, an (unqualified) variable name can only refer to one object
    at any time. This does not necessarily have anything to do with using third-party
    code–you can redefine objects, but don’t expect to be able to access the old object
    after you do it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种语言中，一个（未限定的）变量名在任何时候只能引用一个对象。这不一定与使用第三方代码有关——您可以重新定义对象，但不要期望在这样做之后能够访问旧对象。
- en: The same thing can happen when you use third-party code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用第三方代码时，也可能发生同样的事情。
- en: In R, you have to worry about the order of `library()` and `require()` calls,
    because there is potential *masking* going on.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 R 中，您必须担心 `library()` 和 `require()` 调用的顺序，因为可能存在潜在的遮蔽问题。
- en: If you don’t want to worry about masking, don’t use `library()` or `require()`,
    and just refer to variables using the `::` operator (e.g. `coolPackage::specialFunc()`).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您不想担心遮蔽（masking）问题，请不要使用 `library()` 或 `require()`，只需使用 `::` 操作符来引用变量（例如 `coolPackage::specialFunc()`）。
- en: In Python, loading packages using either the `import package` format or the
    `import package as p` format means you do not need to worry about the order of
    imports because you will be forced to qualify variable names (e.g. `package.func()`
    or `p.func()`).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Python 中，使用 `import package` 格式或 `import package as p` 格式加载包意味着您不需要担心导入的顺序，因为您将被迫限定变量名（例如
    `package.func()` 或 `p.func()`）。
- en: In Python, if you load third-party code using either `from package import foo`
    or `from package import *`, you won’t have to qualify variable names, but imported
    objects will overwrite any variables that happen to have the same name as something
    you’re importing.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Python 中，如果您使用 `from package import foo` 或 `from package import *` 加载第三方代码，您就不需要限定变量名，但导入的对象将覆盖任何与您导入的内容具有相同名称的变量。
- en: The way variable names are stored are only slightly different between R and
    Python.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: R 和 Python 之间变量名存储的方式只有细微的差别。
- en: Python namespaces are similar to R environments in that they hold name-value
    pairs; however
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 命名空间与 R 环境类似，因为它们都包含名称-值对；然而
- en: Python namespaces are unlike R environments in that they are not arranged into
    a sorted list.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 命名空间与 R 环境不同，因为它们不是按顺序排列的列表。
- en: Also, Python modules may be organized into a nested or tree-like structure,
    whereas R packages will always have a flat structure.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，Python 模块可能组织成嵌套或树状结构，而 R 包总是具有平面结构。
- en: 10.4.1 `import`ing Examples
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.1 `import` 示例
- en: In the example below, we import the entire `numpy` package in a way that lets
    us refer to it as `np`. This reduces the amount of typing that is required of
    us, but it also protects against variable name clashing. We then use the `normal()`
    function to simulate normal random variables. This function is in the [`random`
    sub-module](https://numpy.org/doc/stable/reference/random/index.html?highlight=random#module-numpy.random),
    which is a sub-module in `numpy` that collects all of the pseudorandom number
    generation functionality together.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们以允许我们将其称为 `np` 的方式导入整个 `numpy` 包。这减少了我们需要输入的字符数量，但也保护了变量名冲突。然后我们使用
    `normal()` 函数来模拟正态随机变量。此函数位于 `random` 子模块中（[https://numpy.org/doc/stable/reference/random/index.html?highlight=random#module-numpy.random](https://numpy.org/doc/stable/reference/random/index.html?highlight=random#module-numpy.random)），它是
    `numpy` 中的一个子模块，收集了所有伪随机数生成功能。
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is one use of the dot operator (`.`). It is also used to access attributes
    and methods of objects (more information on that will come later in chapter [14](/an-introduction-to-object-oriented-programming#an-introduction-to-object-oriented-programming)).
    `normal` is *inside of* `random`, which it itself inside of `np`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是点操作符（`.`）的一个用途。它还用于访问对象的属性和方法（关于这一点，将在第 [14](/an-introduction-to-object-oriented-programming#an-introduction-to-object-oriented-programming)
    章节中稍后详细介绍）。`normal` 是 `random` 的内部属性，而 `random` 本身又是 `np` 的内部属性。
- en: As a second example, suppose we were interested in the [`stats` sub-module](https://docs.scipy.org/doc/scipy/reference/tutorial/stats.html)
    found inside the `scipy` package. We could import all of `scipy`, but just like
    the above example, that would mean we would need to consistently refer to a variable’s
    module, the sub-module, and the variable name. For long programs, this can become
    tedious if we had to type `scipy.stats.norm` over and over again. Instead, let’s
    import the sub-module (or sub-package) and ignore the rest of `scipy`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二个示例，假设我们对 `scipy` 包内找到的 `stats` 子模块感兴趣。[https://docs.scipy.org/doc/scipy/reference/tutorial/stats.html](https://docs.scipy.org/doc/scipy/reference/tutorial/stats.html)。我们可以导入整个
    `scipy`，但就像上面的例子一样，这意味着我们需要一致地引用变量的模块、子模块和变量名。对于长程序，如果我们不得不反复输入 `scipy.stats.norm`，这可能会变得繁琐。相反，让我们导入子模块（或子包）并忽略
    `scipy` 的其余部分。
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So we don’t have to type `scipy` every time we use something in `scipy.stats`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不必每次在 `scipy.stats` 中使用 `scipy`。
- en: Finally, we can import the function directly, and refer to it with only one
    letter. This is highly discouraged, though. We are much more likely to accidentally
    use the name `n` twice. Further, `n` is not a very descriptive name, which means
    it could be difficult to understand what your program is doing later.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以直接导入函数，只用一个字母来引用它。尽管如此，这被高度不建议。我们更有可能意外地两次使用名称 `n`。此外，`n` 不是一个非常描述性的名称，这意味着以后可能难以理解你的程序在做什么。
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Keep in mind, you’re always at risk of accidentally re-using names, even if
    you aren’t `import`ing anything. For example, consider the following code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，即使你没有导入任何内容，你也总是有意外重复使用名称的风险。例如，考虑以下代码。
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is very bad, because now you cannot use the `n()` function that was imported
    from the `numpy.random` sub-module earlier. In other words, it is longer *callable*.
    The error message from the above code will be something like `TypeError: ''int''
    object is not callable`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '这非常糟糕，因为你现在不能使用之前从 `numpy.random` 子模块导入的 `n()` 函数。换句话说，它不再可调用。上述代码的错误信息可能类似于
    `TypeError: ''int'' object is not callable`。'
- en: Use the `dir()` function to see what is available inside a module. Here are
    a few examples. Type them into your own machine to see what they output.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dir()` 函数查看模块内部有什么可用。这里有一些示例。将它们输入到你的机器上，看看它们会输出什么。
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 10.5 Exercises
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 练习
- en: What are important differences in the package installation procedures of R and
    Python? Select all that apply.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: R 和 Python 的包安装过程有哪些重要的不同之处？选择所有适用的选项。
- en: Installing R packages can be done from within R, while installing packages in
    Python can be done in the command line.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: R 包的安装可以在 R 内完成，而 Python 包的安装可以在命令行中完成。
- en: Installing R packages can usually be done with the same function `install.packages()`,
    while installing packages in Python can be done with a variety of package installers
    such as `pip install` and `conda install`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 R 包通常可以使用相同的函数 `install.packages()`，而安装 Python 中的包可以使用各种包安装器，如 `pip install`
    和 `conda install`。
- en: There is only one package repository for R, but many for Python.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: R 只有一个包仓库，但 Python 有很多。
- en: There is only one package repository for Python, but many for R.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python 的包仓库只有一个，但 R 的包仓库有很多。
- en: What are important similarities and differences in the package loading procedures
    of R and Python? Select all that apply.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: R 和 Python 的包加载过程有哪些重要的相似之处和不同之处？选择所有适用的选项。
- en: R and Python both have a search path.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: R 和 Python 都有一个搜索路径。
- en: R’s `::` operator is very similar to Python’s `.` operator because they can
    both help access variable names inside packages.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: R 的 `::` 运算符与 Python 的 `.` 运算符非常相似，因为它们都可以帮助访问包内部的变量名称。
- en: Python namespaces are unlike R environments in that they are not arranged into
    a sorted list.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python 的命名空间与 R 的环境不同，因为它们不是按顺序排列的。
- en: '`library(package)` in R is similar to `from package import *` in Python because
    it will allow you to refer to all variables in `package` without qualification.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: R 中的 `library(package)` 与 Python 中的 `from package import *` 类似，因为它将允许你无需限定条件地引用
    `package` 中的所有变量。
- en: Python packages might have `sub-modules` whereas R’s packages do not.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python 的包可能有 `子模块`，而 R 的包没有。
- en: In Python, which of the following is, generally speaking, the best way to `import`?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，以下哪个通常是最佳导入方式？
- en: '`import the_package`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import the_package`'
- en: '`from the_package import *`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from the_package import *`'
- en: '`import the_package as tp`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import the_package as tp`'
- en: In Python, which of the following is, generally speaking, the worst way to `import`?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，以下哪个通常是最差的导入方式？
- en: '`import the_package`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import the_package`'
- en: '`from the_package import *`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from the_package import *`'
- en: '`import the_package as tp`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import the_package as tp`'
- en: In R, if you want to use a function `func()` from `package`, do you always have
    to use `library(package)` or `require(package)` first?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，如果你想使用 `package` 中的函数 `func()`，你是否总是需要先使用 `library(package)` 或 `require(package)`？
- en: Yes, otherwise `func()` won’t be available.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是的，否则 `func()` 将不可用。
- en: No, you can just use `package::func()` without calling any function that performs
    pre-loading.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不，你可以直接使用 `package::func()` 而不必调用任何执行预加载的函数。
- en: References
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Harrell Jr, Frank E, with contributions from Charles Dupont, and many others.
    2021\. *Hmisc: Harrell Miscellaneous*. [https://CRAN.R-project.org/package=Hmisc](https://CRAN.R-project.org/package=Hmisc).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '哈雷尔，弗兰克·E，由查尔斯·杜邦等人贡献。2021. *Hmisc: 哈雷尔杂项*。[https://CRAN.R-project.org/package=Hmisc](https://CRAN.R-project.org/package=Hmisc)。'
- en: 'Lander, Jared P. 2017\. *R for Everyone: Advanced Analytics and Graphics (2nd
    Edition)*. 2nd ed. Addison-Wesley Professional.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Lander, Jared P. 2017\. *《R语言：面向所有人的高级分析与图形（第2版）》*. 2nd ed. Addison-Wesley Professional.
- en: '* * *'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: I am avoiding any mention of *R’s* namespaces and modules. These are things
    that exist, but they are different from Python’s namespaces and modules, and are
    not within the scope of this text.[↩](/using-third-party-code#fnref17)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我避免提及 *R* 的命名空间和模块。这些是存在的事物，但它们与 Python 的命名空间和模块不同，并且不在此文本的范围内。[↩](/using-third-party-code#fnref17)
- en: The scripts you write are modules. They usually come with the intention of being
    run from start to finish. Other non-script modules are just a bag of definitions
    to be used in other places.[↩](/using-third-party-code#fnref18)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你所编写的脚本都是模块。它们通常带有从头到尾运行的意图。其他非脚本模块只是一些定义的集合，用于其他地方。[↩](/using-third-party-code#fnref18)
- en: Sometimes a package is called a *library* but I will avoid this terminology.[↩](/using-third-party-code#fnref19)
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时一个包被称为 *库*，但我会避免使用这个术语。[↩](/using-third-party-code#fnref19)
