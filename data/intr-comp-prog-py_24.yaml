- en: '23'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '23'
- en: EXPLORING DATA WITH PANDAS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PANDAS 探索数据
- en: Most of the second half of this book is focused on building various kinds of
    computational models that can be used to extract useful information from data.
    In the chapters following this one, we will take a quick look at simple ways to
    use machine learning to build models from data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书后半部分的大部分内容都集中在构建各种计算模型上，这些模型可以用来从数据中提取有用的信息。在接下来的章节中，我们将快速了解使用机器学习从数据构建模型的简单方法。
- en: Before doing so, however, we will look at a popular library that can be used
    to quickly get acquainted with a dataset before diving into more detailed analysis.
    **Pandas**[^(173)](#c23-fn-0001) is built on top of numpy. Pandas provides mechanisms
    to facilitate
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这样做之前，我们将查看一个流行的库，它可以快速帮助我们熟悉数据集，然后再深入到更详细的分析中。**Pandas**[^(173)](#c23-fn-0001)
    是建立在 numpy 之上的。Pandas 提供了促进
- en: Organizing data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织数据
- en: Calculating simple statistics about data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算数据的简单统计
- en: Storing the data in formats that faciltates future analysis
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以便于未来分析的格式存储数据
- en: 23.1 DataFrames and CSV Files
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 23.1 DataFrames 和 CSV 文件
- en: Everything in Pandas is built around the type **DataFrame**. A DataFrame is
    a mutable two-dimensional tabular data structure with labeled axes (rows and columns).
    One way to think about it is as a spreadsheet on steroids.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 中的一切都是围绕 **DataFrame** 类型构建的。DataFrame 是一个可变的二维表格数据结构，具有标记的轴（行和列）。可以将其视为一种增强版的电子表格。
- en: While DataFrames can be built from scratch using Python code, a more common
    way to create a DataFrame is by reading in a **CSV file**. As we saw in Chapter
    19, each line of a CSV file consists of one or more values, separated by commas.[^(174)](#c23-fn-0002)
    CSV files are typically used to store tabular numbers in plain text. In such cases,
    it is common for lines to have the same number of fields. Because they are plain
    text, they are often used to move data from one application to another. For example,
    most spreadsheet programs allow users to write the contents of spreadsheet into
    a CSV file.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用 Python 代码从头构建 DataFrame，但创建 DataFrame 更常见的方法是通过读取 **CSV 文件**。正如我们在第 19
    章中看到的，CSV 文件的每一行由一个或多个值组成，这些值由逗号分隔。[^(174)](#c23-fn-0002) CSV 文件通常用于以纯文本格式存储表格数据。在这种情况下，行通常具有相同数量的字段。由于它们是纯文本，因此经常用于将数据从一个应用程序移动到另一个应用程序。例如，大多数电子表格程序允许用户将电子表格的内容写入
    CSV 文件。
- en: '[Figure 23-1](#c23-fig-0001) shows a DataFrame containing information about
    the late rounds of the 2019 FIFA Women''s World Cup. Each column represents something
    called a **series**. An **index** is associated with each row. By default, the
    indices are consecutive numbers, but they needn''t be. A **name** is associated
    with each column. As we will see, these names play a role similar to that of keys
    in dictionaries.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 23-1](#c23-fig-0001) 显示了一个 DataFrame，其中包含关于 2019 年 FIFA 女子世界杯后期轮次的信息。每一列代表一个称为
    **series** 的东西。每一行都有一个 **index** 相关联。默认情况下，索引是连续的数字，但它们并不一定需要如此。每一列都有一个 **name**
    相关联。正如我们将看到的，这些名称的作用类似于字典中的键。'
- en: '![c23-fig-0001.jpg](../images/c23-fig-0001.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![c23-fig-0001.jpg](../images/c23-fig-0001.jpg)'
- en: '[Figure 23-1](#c23-fig-0001a) A sample Pandas DataFrame bound to the variable
    wwc'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 23-1](#c23-fig-0001) 一个绑定到变量 wwc 的示例 Pandas DataFrame'
- en: The DataFrame pictured in [Figure 23-1](#c23-fig-0001) was produced using the
    code below and the CSV file depicted in [Figure 23-2](#c23-fig-0002).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 23-1](#c23-fig-0001) 中显示的 DataFrame 是使用下面的代码和 [图 23-2](#c23-fig-0002) 中所示的
    CSV 文件生成的。
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![c23-fig-0002.jpg](../images/c23-fig-0002.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![c23-fig-0002.jpg](../images/c23-fig-0002.jpg)'
- en: '[Figure 23-2](#c23-fig-0002a) An example CSV file'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 23-2](#c23-fig-0002a) 一个示例 CSV 文件'
- en: After importing Pandas, the code uses the Pandas’ function `read_csv` to read
    the CSV file, and then prints it in the tabular form shown in [Figure 23-1](#c23-fig-0001).
    If the DataFrame has a large number of rows or columns, `print` will replace columns
    and/or rows in the center of the DataFrame with ellipses. This can be avoided
    by first converting the DataFrame to a string using the DataFrame method `to_string`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入 Pandas 后，代码使用 Pandas 的函数 `read_csv` 来读取 CSV 文件，然后以 [图 23-1](#c23-fig-0001)
    中所示的表格形式打印出来。如果 DataFrame 具有大量的行或列，`print` 将在 DataFrame 的中心用省略号替换列和/或行。这可以通过首先使用
    DataFrame 方法 `to_string` 将 DataFrame 转换为字符串来避免。
- en: Together, a row index and a column label indicate a data cell (as in a spreadsheet).
    We discuss how to access individual cells and groups of cells in Section 23.3\.
    Typically, but not always, the cells in a column are all of the same type. In
    the DataFrame in [Figure 23-1](#c23-fig-0001), each of the cells in the `Round`,
    `Winner`, and `Loser` columns is of type `str`. The cells in the `W` `Goals` and
    `L` `Goals` columns are of type `numpy.int64`. You won't have a problem if you
    think of them as Python ints.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一行索引和一个列标签一起指示一个数据单元（如在电子表格中）。我们将在第 23.3 节讨论如何访问单个单元和单元组。通常，但并不总是，列中的单元格都是同一种类型。在
    [图 23-1](#c23-fig-0001) 的 DataFrame 中，`Round`、`Winner` 和 `Loser` 列中的每个单元格都是 `str`
    类型。`W Goals` 和 `L Goals` 列中的单元格是 `numpy.int64` 类型。如果你将它们视为 Python 的整型，你就不会有问题。
- en: We can directly access the three components of a DataFrame using the attributes
    `index`, `columns`, and `values`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接使用属性 `index`、`columns` 和 `values` 访问 DataFrame 的三个组成部分。
- en: "The `index` attribute is of type `RangeIndex`. For example, the value of `wwc.index`\
    \ is `\uFEFFRangeIndex(start=0, stop=8, step=1)`. Therefore, the code"
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`index` 属性的类型为 `RangeIndex`。例如，`wwc.index` 的值为 `RangeIndex(start=0, stop=8,
    step=1)`。因此，代码'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: will print the integers 0-7 in ascending order.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将按升序打印整数 0-7。
- en: "The `columns` attribute is of type `Index`. For example, the value `wwc.columns`\
    \ is \uFEFF`Index(['Round', 'Winner', 'W Goals', 'Loser', 'L Goals'], dtype='object')`,\
    \ and the code"
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`columns` 属性的类型为 `Index`。例如，值 `wwc.columns` 是 `Index([''Round'', ''Winner'',
    ''W Goals'', ''Loser'', ''L Goals''], dtype=''object'')`，而代码'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: prints
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: "The `values` attribute is of type `numpy.ndarray`. In Chapter 13 we introduced\
    \ the type `numpy.array`. It turns out that `array` is a special case of `ndarray`.\
    \ Whereas arrays are one-dimensional (like other sequence types), ndarrays can\
    \ be multidimensional. The number of dimensions and items in an ndarray is called\
    \ its **shape** and is represented by a tuple of non-negative integers that specify\
    \ the size of each dimension. The value of \uFEFF`wwc.values` is the two-dimensional\
    \ ndarray"
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`values` 属性的类型为 `numpy.ndarray`。在第 13 章中，我们介绍了类型 `numpy.array`。事实证明，`array`
    是 `ndarray` 的特殊情况。虽然数组是一维的（像其他序列类型一样），但 ndarrays 可以是多维的。ndarray 的维数和项目数称为其 **shape**，并用一个表示每个维度大小的非负整数元组表示。值
    `wwc.values` 是二维 ndarrays'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Since it has eight rows and five columns, its shape is `(8, 5)`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它有八行五列，因此它的形状为 `(8, 5)`。
- en: 23.2 Creating Series and DataFrames
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 23.2 创建系列和 DataFrame
- en: In practice, Pandas’ DataFrames are typically created by loading a dataset that
    has been stored as either an SQL database, a CSV file, or in a format associated
    with a spreadsheet application. However, it is sometimes useful to construct series
    and DataFrames using Python code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Pandas 的 DataFrame 通常是通过加载存储为 SQL 数据库、CSV 文件或与电子表格应用程序相关的格式的数据集来创建的。然而，有时使用
    Python 代码构建系列和 DataFrame 是有用的。
- en: "The expression `\uFEFFpd.DataFrame()` produces an empty DataFrame, and the\
    \ statement `print(pd.DataFrame())` produces the output"
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `pd.DataFrame()` 生成一个空的 DataFrame，而语句 `print(pd.DataFrame())` 产生的输出
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A simple way to create a non-empty DataFrame is to pass in a list. For example,
    the code
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个非空 DataFrame 的简单方法是传入一个列表。例如，代码
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: prints
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: "Notice that Pandas has automatically generated a label, albeit not a particularly\
    \ descriptive one, for the DataFrame's only column. To get a more descriptive\
    \ label, we can pass in a dictionary rather than a list. For example, the code\
    \ \uFEFF`print(pd.DataFrame({'Round': rounds}))` prints"
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，Pandas 为 DataFrame 的唯一一列自动生成了一个标签，尽管这个标签并不是特别描述性。为了获得更具描述性的标签，我们可以传入一个字典而不是一个列表。例如，代码
    `print(pd.DataFrame({''Round'': rounds}))` 会打印'
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To directly create a DataFrame with multiple columns, we need only pass in a
    dictionary with multiple entries, each consisting of a column label as a key and
    a list as the value associated with each key. Each of these lists must be of the
    same length. For example, the code
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要直接创建一个具有多列的 DataFrame，我们只需传入一个包含多个条目的字典，每个条目由一个列标签作为键和一个与每个键相关联的列表作为值。这些列表必须具有相同的长度。例如，代码
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: prints
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once a DataFrame has been created, it is easy to add columns. For example, the
    statement `df['W Goals'] = [2, 1, 0, 0]` mutates `df` so that its value becomes
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了 DataFrame，就很容易添加列。例如，语句 `df['W Goals'] = [2, 1, 0, 0]` 会修改 `df`，使其值变为
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: "Just as the values associated with a key in dictionary can be replaced, the\
    \ values associated with a column can be replaced. For example, after executing\
    \ the statement \uFEFF `\uFEFFdf['W Goals'] = [2, 1, 2, 2]`, the value of `df`\
    \ becomes"
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 就像字典中与键关联的值可以被替换一样，与列关联的值也可以被替换。例如，在执行语句`df['W Goals'] = [2, 1, 2, 2]`后，`df`的值变为
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: "It is also easy to drop columns from a DataFrame. The function call `\uFEFF\
    print(df.drop('Winner', axis = 'columns'))` prints"
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从DataFrame中删除列也是很简单的。函数调用`print(df.drop('Winner', axis = 'columns'))`会打印出
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: "and leaves `df` unchanged. If we had not included `axis = 'columns'` (or equivalently\
    \ `axis = 1`) in the call to `drop`, the axis would have defaulted to `'rows'`\
    \ (equivalent to `axis = 0`), which would have led to generating the exception\
    \ \uFEFF`KeyError: \"['Winner'] not found in axis.\"`"
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '并且`df`保持不变。如果在调用`drop`时没有包含`axis = ''columns''`（或等效地`axis = 1`），则轴将默认为`''rows''`（等效于`axis
    = 0`），这将导致生成异常`KeyError: "[''Winner''] not found in axis."`'
- en: "If a DataFrame is large, using `drop` in this way is inefficient, since it\
    \ requires copying the DataFrame. The copy can be avoided by setting the `inplace`\
    \ keyword argument to `drop` to `True`. The call \uFEFF`df.drop('Winner', axis\
    \ = 'columns', inplace = True)` mutates `df` and returns `None`."
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个DataFrame很大，以这种方式使用`drop`是低效的，因为这需要复制DataFrame。通过将`drop`的`inplace`关键字参数设置为`True`，可以避免复制。调用`df.drop('Winner',
    axis = 'columns', inplace = True)`会修改`df`并返回`None`。
- en: Rows can be added to the beginning or end of a DataFrame using the `DataFrame`
    constructor to create a new DataFrame, and then using the `concat` function to
    combine the new DataFrame with an existing DataFrame. For example, the code
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`DataFrame`构造函数将行添加到DataFrame的开头或末尾，然后使用`concat`函数将新DataFrame与现有DataFrame组合。例如，代码
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: sets `df` to
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将`df`设置为
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Had the keyword argument `sort` been set to `True`, `concat` would have also
    changed the order of the columns based upon the lexographic ordering of their
    labels. That is
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将关键字参数`sort`设置为`True`，`concat`也会根据列标签的字典序改变列的顺序。也就是说，
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: swaps the position of the last two columns and returns the DataFrame
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 交换最后两列的位置并返回DataFrame。
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If no value for `sort` is provided, it defaults to `False`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供`sort`的值，则默认为`False`。
- en: Notice that the indices of each of the concatenated DataFrames are unchanged.
    Consequently, there are multiple rows with the same index. The indices can be
    reset using the `reset_index` method. For example, the expression `df.reset_index(drop
    = True)` evaluates to
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个连接的DataFrame的索引保持不变。因此，会有多个具有相同索引的行。可以使用`reset_index`方法重置索引。例如，表达式`df.reset_index(drop
    = True)`的值为
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If `reset_index` is invoked with `drop = False`, a new column containing the
    old indices is added to the DataFrame. The column is labeled `index`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`reset_index`被调用时`drop = False`，则会向DataFrame添加一个包含旧索引的新列。该列被标记为`index`。
- en: "You might be wondering why Pandas even allows duplicate indices. The reason\
    \ is that it is often helpful to use a semantically meaningful index to label\
    \ rows. For example, `\uFEFFdf.set_index('Round')` evaluates to"
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么Pandas甚至允许重复索引。原因是使用语义上有意义的索引来标记行通常是有帮助的。例如，`df.set_index('Round')`的值为
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 23.3 Selecting Columns and Rows
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 23.3 选择列和行
- en: "As is the case for other composite types in Python, square brackets are the\
    \ primary mechanism for selecting parts of a DataFrame. To select a single column\
    \ of a DataFrame, we simply place the label of the column in between square brackets.\
    \ For example, \uFEFF `wwc['Winner']` evaluates to"
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python中的其他复合类型，方括号是选择DataFrame部分的主要机制。要选择DataFrame的单列，只需将列的标签放在方括号之间。例如，`wwc['Winner']`的值为
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: "The type of this object is `**Series**`, i.e., it is not a DataFrame. A Series\
    \ is a one-dimensional sequence of values, each of which is labeled by an index.\
    \ To select a single item from a Series, we place an index within square brackets\
    \ following the series. So, \uFEFF`wwc['Winner'][3]` evaluates to the string `Sweden`."
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 该对象的类型是`**Series**`，即它不是DataFrame。Series是一维值序列，每个值都有一个索引标签。要从Series中选择单个项目，我们在系列后面的方括号中放入一个索引。因此，`wwc['Winner'][3]`的值为字符串`Sweden`。
- en: We can iterate over a series using a `for` loop. For example,
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`for`循环遍历一个序列。例如，
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: "prints \uFEFF`England,USA,Netherlands,Sweden,USA,Netherlands,Sweden,USA`."
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 打印出`England,USA,Netherlands,Sweden,USA,Netherlands,Sweden,USA`。
- en: '**Finger exercise:** Write a function that returns the sum of the goals scored
    by winners.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**指尖练习：** 编写一个函数，返回获胜者所进球的总和。'
- en: "Square brackets can also be used to select multiple columns from a DataFrame.\
    \ This is done by placing a list of column labels within the square brackets.\
    \ This produces a DataFrame rather than series. For example, \uFEFF`wwc[['Winner',\
    \ 'Loser']]` produces the DataFrame"
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号也可以用来从DataFrame中选择多个列。这是通过在方括号内放置列标签的列表来完成的。这将产生一个DataFrame而不是Series。例如，`wwc[['Winner',
    'Loser']]`产生的DataFrame为：
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: "The column labels in the list within the selection square brackets don't have\
    \ to be in the same order as the labels appear in the original DataFrame. This\
    \ makes it convenient to use selection to reorganize the DataFrame. For example,\
    \ \uFEFF\uFEFF`\uFEFFwwc[['Round','Winner','Loser','W Goals','L Goals']]` returns\
    \ the DataFrame"
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 选择方括号中的标签列表的顺序不必与原始DataFrame中的标签顺序相同。这使得通过选择来重新组织DataFrame变得方便。例如，`wwc[['Round','Winner','Loser','W
    Goals','L Goals']]`返回的DataFrame为：
- en: '[PRE23]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that attempting to select a row by putting its index inside of square brackets
    will not work. It will generate a `KeyError` exception. Curiously, however, we
    can select rows using slicing. So, while `wwc[1]` causes an exception, `wwc[1:2]`
    produces a DataFrame with a single row,
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试通过将行的索引放入方括号中来选择一行将不起作用。这将产生一个`KeyError`异常。然而，奇怪的是，我们可以通过切片选择行。因此，虽然`wwc[1]`会导致异常，`wwc[1:2]`会产生一个包含单行的DataFrame。
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We discuss other ways of selecting rows in the next subsection.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一小节讨论其他选择行的方法。
- en: 23.3.1 Selection Using loc and iloc
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.3.1 使用loc和iloc进行选择
- en: The `**loc**` method can be used to select rows, columns, or combinations of
    rows and columns from a DataFrame. Importantly, all selection is done using labels.
    This is worth emphasizing, since some of the labels (e.g., the indices) can look
    suspiciously like numbers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`**loc**`方法可以用于从DataFrame中选择行、列或行列的组合。重要的是，所有选择都是通过标签进行的。这一点值得强调，因为某些标签（例如索引）看起来可能像数字。'
- en: If `df` is a DataFrame, the expression `df.loc[label]` returns a series corresponding
    to the row associated with `label` in `df`. For example, `wwc.loc[3]` returns
    the Series
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`df`是一个DataFrame，则表达式`df.loc[label]`返回与`df`中`label`关联的行对应的Series。例如，`wwc.loc[3]`返回的Series为：
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that the column labels of `wwc` are the index labels for the Series,
    and the values associated with those labels are the values for the corresponding
    columns in the row labeled `3` in `wwc`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`wwc`的列标签是Series的索引标签，与这些标签相关联的值是`wwc`中标签为`3`的行对应列的值。
- en: "To select multiple rows, we need only put a list of labels (rather than a single\
    \ label) inside the square brackets following `.loc`. When this is done, the value\
    \ of the expression is a DataFrame rather than a Series. For example, the expression\
    \ `\uFEFFwwc.loc[[1,3,5]]` produces"
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择多行，我们只需在`.loc`后面的方括号内放置标签列表（而不是单个标签）。这样做时，表达式的值是一个DataFrame而不是一个Series。例如，表达式`wwc.loc[[1,3,5]]`产生：
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice that the index associated with each row of the new DataFrame is the index
    of that row in the old DataFrame.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，新DataFrame中每一行的索引是旧DataFrame中该行的索引。
- en: "Slicing provides another way to select multiple rows. The general form is `df.loc[first:last:step]`.\
    \ If `first` is not supplied, it defaults to the first index in the DataFrame.\
    \ If `last` is not supplied, it defaults to the last index in the DataFrame.If\
    \ `step` is not supplied, it defaults to `1`. The expression `\uFEFFwwc.loc[3:7:2]`\
    \ produces the DataFrame"
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 切片提供了另一种选择多行的方法。一般形式为`df.loc[first:last:step]`。如果未提供`first`，则默认为DataFrame中的第一个索引。如果未提供`last`，则默认为DataFrame中的最后一个索引。如果未提供`step`，则默认为`1`。表达式`wwc.loc[3:7:2]`产生的DataFrame为：
- en: '[PRE27]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: "As a Python programmer, you might be surprised that that the row labeled `7`\
    \ is included. For other Python data containers (such as lists), the last value\
    \ is excluded when slicing, but not for DataFrames.[^(175)](#c23-fn-0003) The\
    \ expression \uFEFF`wwc.loc[6:]` produces the DataFrame"
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名Python程序员，你可能会惊讶于标签为`7`的行被包含在内。对于其他Python数据容器（如列表），切片时最后一个值会被排除，但对于DataFrame则不是这样。[^(175)](#c23-fn-0003)
    表达式`wwc.loc[6:]`产生的DataFrame为：
- en: '[PRE28]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: "And the expression \uFEFF`wwc.loc[:2]` produces"
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`wwc.loc[:2]`产生：
- en: '[PRE29]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Finger exercise:** Write an expression that selects all even numbered rows
    in `wwc`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**指尖练习：** 写一个表达式，选择`wwc`中所有偶数编号的行。'
- en: As we mentioned earlier, `loc` can be used to simultaneously select a combination
    of rows and columns. This is done with an expression of the form
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`loc`可以用来同时选择行和列的组合。这是通过类似以下形式的表达式完成的：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The row and column selectors can be written using any of the mechanisms already
    discussed, i.e., a single label, a list of labels, or a slicing expression. For
    example, `wwc.loc[0:2, 'Round':'L Goals':2]` produces
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 行和列选择器可以使用之前讨论过的任何机制编写，即单个标签、标签列表或切片表达式。例如，`wwc.loc[0:2, 'Round':'L Goals':2]`生成
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Finger exercise:** Write an expression that generates the DataFrame'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**手指练习：** 写一个生成数据框的表达式'
- en: '[PRE32]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Thus far, you wouldn't have gone wrong if you thought of the index labels as
    integers. Let's see how selection works when 1) the labels are not number-like,
    and 2) more than one row has the same label. Let `wwc_by_round` be the DataFrame
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果你把索引标签视为整数，你是不会错的。让我们看看当1)标签不是数字型，2)有多行具有相同标签时，选择是如何工作的。让`wwc_by_round`成为数据框
- en: '[PRE33]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: "What do you think the expression \uFEFF`wwc_by_round.loc['Semis']` evaluates\
    \ to? It selects all rows with the label `Semis` to return"
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为表达式`wwc_by_round.loc['Semis']`的结果是什么？它选择所有标签为`Semis`的行，以返回
- en: '[PRE34]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: "Similarly, \uFEFF`wwc_by_round.loc[['Semis', \uFEFF'Championship']]` selects\
    \ all rows with a label of either `Semis` or \uFEFF`Championship`:"
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`wwc_by_round.loc[['Semis', 'Championship']]`选择所有标签为`Semis`或`Championship`的行：
- en: '[PRE35]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Slicing also work with non-numeric indices. The expression
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 切片也适用于非数字索引。表达式
- en: '[PRE36]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: produces a DataFrame by selecting the first row labeled by `Quarters` and then
    selecting every other row until it has passed a row labeled `Semis` to generate
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择标记为`Quarters`的第一行，然后选择每隔一行，直到经过标记为`Semis`的行，生成
- en: '[PRE37]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: "Now, suppose we want to select the second and third of the rows labeled `Quarters`.\
    \ We can't simply write \uFEFF`wwc_by_round.loc['Quarters']` because that will\
    \ select all four rows labeled `Quarters`. Enter the `iloc` method."
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想选择标记为`Quarters`的第二行和第三行。我们不能简单地写`wwc_by_round.loc['Quarters']`，因为那样会选择所有四行标记为`Quarters`。使用`iloc`方法。
- en: "The `**iloc**` method is like `loc`, except rather than working with labels,\
    \ it works with integers (hence the `i` in `iloc`). The first row of a DataFrame\
    \ is `iloc 0`, the second at `iloc 1`, etc. So, to select the second and third\
    \ of the rows labeled `Quarters`, we write \uFEFF`wwc_by_round.iloc[[1,2]]`."
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`**iloc**`方法类似于`loc`，但它是基于整数而不是标签（因此有`i`在`iloc`中）。数据框的第一行是`iloc 0`，第二行为`iloc
    1`，依此类推。因此，要选择标记为`Quarters`的第二行和第三行，我们写`wwc_by_round.iloc[[1,2]]`。'
- en: 23.3.2 Selection by Group
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.3.2 按组选择
- en: It is often convenient to split a DataFrame into subsets and apply some aggregation
    or transformation separately to each subset. The `groupby` method makes it easy
    to do this sort of thing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据框分成子集，并对每个子集分别应用一些聚合或转换，通常很方便。`groupby`方法使得这种操作变得简单。
- en: Suppose, for example, we want to know the total number of goals scored by the
    winning and losing teams in each round. The code
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，我们想知道每轮中获胜和失利球队总进球数。代码
- en: '[PRE38]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: "binds `group_by_round` to an object of type \uFEFF`DataFrameGroupBy`. We can\
    \ then apply the aggregator `sum` to that object to generate a DataFrame. The\
    \ code"
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将`group_by_round`绑定到类型为`DataFrameGroupBy`的对象。我们可以对该对象应用聚合器`sum`以生成一个数据框。代码
- en: '[PRE39]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: prints
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '[PRE40]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: "The code \uFEFF`print(wwc.groupby('Winner').mean())` prints"
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 代码`print(wwc.groupby('Winner').mean())`打印出
- en: '[PRE41]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: From this we can easily see that England averaged three goals in the games it
    won, while shutting out its opponents.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以很容易地看出，英格兰在赢得的比赛中平均进了三球，同时零封了对手。
- en: "The code \uFEFF`print(wwc.groupby(['Loser', 'Round']).mean())` prints"
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 代码`print(wwc.groupby(['Loser', 'Round']).mean())`打印出
- en: '[PRE42]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: From this we can easily see that England averaged one goal in the games it lost,
    while giving up two.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以很容易地看出，英格兰在输掉的比赛中平均进了一球，而丢了两个。
- en: 23.3.3 Selection by Content
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.3.3 按内容选择
- en: Suppose we want to select all of the rows for games won by Sweden from the DataFrame
    in [Figure 23-1](#c23-fig-0001). Since this DataFrame is a small one, we could
    look at each row and find the indices of the rows corresponding to those games.
    Of course, that approach doesn't scale to large DataFrames. Fortunately, it is
    easy to select rows based on their contents using something called **Boolean indexing**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想从数据框中选择瑞典赢得的所有比赛的行，如[图23-1](#c23-fig-0001)。由于这个数据框比较小，我们可以查看每一行并找到对应比赛的行索引。当然，这种方法不适用于大型数据框。幸运的是，使用称为**布尔索引**的东西可以轻松根据内容选择行。
- en: "The basic idea is to write a logical expression referring to the values contained\
    \ in the DataFrame. That expression is then evaluated on each row of the DataFrame,\
    \ and the rows for which it evaluates to `True` are selected. The expression \uFEFF\
    `wwc.loc[wwc['Winner'] == ‘Sweden']` evaluates to the DataFrame"
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想是编写一个逻辑表达式，引用 DataFrame 中的值。该表达式随后在 DataFrame 的每一行上进行评估，评估结果为 `True` 的行将被选中。表达式
    `wwc.loc[wwc['Winner'] == 'Sweden']` 评估为 DataFrame
- en: '[PRE43]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Retrieving all of the games involving Sweden is only a little more complicated.
    The logical operators `**&**` (corresponding to and), `**|**` (corresponding to
    or), and `**–**` (corresponding to not) can be used to form expressions. The expression
    `wwc.loc[(wwc['Winner'] == ‘Sweden') | (wwc['Loser'] == ‘Sweden')]` returns
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 提取所有涉及瑞典的比赛稍微复杂一些。逻辑运算符 `**&**`（对应于与），`**|**`（对应于或）和 `**–**`（对应于非）可用于形成表达式。表达式
    `wwc.loc[(wwc['Winner'] == 'Sweden') | (wwc['Loser'] == 'Sweden')]` 返回
- en: '[PRE44]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Beware, the parentheses around the two subterms of the logical expression are
    necessary because in Pandas `|` has higher precedence than `==`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，逻辑表达式两个子项周围的括号是必要的，因为在 Pandas 中，`|` 的优先级高于 `==`。
- en: '**Finger exercise:** Write an expression that returns a DataFrame containing
    games in which the USA but not France played.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习:** 编写一个表达式，返回一个包含美国参赛但法国没有参赛的比赛的 DataFrame。'
- en: If we expect to do many queries selecting games in which a country participated,
    it might be convenient to define the function
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们预计会进行许多查询以选择某个国家参与的比赛，定义一个函数可能会很方便。
- en: '[PRE45]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: "Since `get_country` returns a DataFrame, it is easy to extract the games between\
    \ pairs of teams by composing two calls of `get_country`. For example, evaluating\
    \ \uFEFF`get_country(get_country(wwc, ‘Sweden'),'Germany')` extracts the one game\
    \ (teams play each other at most once during a knockout round) between these two\
    \ teams."
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `get_country` 返回一个 DataFrame，因此通过组合两次调用 `get_country` 很容易提取成对球队之间的比赛。例如，评估
    `get_country(get_country(wwc, 'Sweden'),'Germany')` 提取了这两支球队之间的一场比赛（球队在淘汰赛阶段最多相互对阵一次）。
- en: 'Suppose we want to generalize `get_country` so that it accepts a list of countries
    as an argument and returns all games in which any of the countries in the list
    played. We can do this using the `isin` method:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要对 `get_country` 进行概括，使其接受国家列表作为参数并返回列表中任何国家参加的所有比赛。我们可以使用 `isin` 方法来实现：
- en: '[PRE46]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `isin` method filters a DataFrame by selecting only those rows with a specified
    value (or element of a specified collection of values) in a specified column.
    The expression `df['Winner'].isin(countries)` in the implementation of `get_games`
    selects those rows in `df` in which the column `Winner` contains an element in
    the list `countries`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`isin` 方法通过在指定列中选择仅包含指定值（或指定值集合中的元素）的行来过滤 DataFrame。在 `get_games` 的实现中，表达式
    `df[''Winner''].isin(countries)` 选择了 `df` 中 `Winner` 列包含 `countries` 列表中的元素的行。'
- en: '**Finger exercise:** Print a DataFrame containing only the games in which Sweden
    played either Germany or Netherlands.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习:** 打印一个只包含瑞典与德国或荷兰比赛的 DataFrame。'
- en: 23.4 Manipulating the Data in a DataFrame
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 23.4 在 DataFrame 中操作数据
- en: We've now looked at some simple ways to create and select parts of DataFrames.
    One of the things that makes DataFrames worth creating is the ease of extracting
    aggregate information from them. Let's start by looking at some ways we might
    extract aggregate information from the DataFrame `wwc`, pictured in [Figure 23-1](#c23-fig-0001).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经查看了一些创建和选择 DataFrame 部分的简单方法。创建 DataFrame 的一个原因是能够轻松提取聚合信息。让我们首先看看如何从
    DataFrame `wwc` 中提取聚合信息，如 [图 23-1](#c23-fig-0001) 所示。
- en: "The columns of a DataFrame can be operated on in ways that are analogous to\
    \ the ways we operate on numpy arrays. For example, analogous to the way the expression\
    \ \uFEFF`2*np.array([1,2,3])` evaluates to the array `\uFEFF[2 4 6]`, the expression\
    \ \uFEFF`2*wwc['W Goals']` evaluates to the series"
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: "DataFrame 的列可以以类似于我们对 numpy 数组操作的方式进行操作。例如，类似于表达式 `2*np.array([1,2,3])` 评估为数组\
    \ `\uFEFF[2 4 6]`，表达式 `2*wwc['W Goals']` 评估为系列"
- en: '[PRE47]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The expression `wwc['W Goals'].sum()` sums the values in the `W Goals` column
    to produce the value `16`. Similarly, the expression
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `wwc['W Goals'].sum()` 对 `W Goals` 列中的值进行求和，得到值 `16`。类似地，表达式
- en: '[PRE48]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: computes the total number of goals scored by Sweden, 6, and the expression
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 计算瑞典队进球总数为 `6`，并且表达式
- en: '[PRE49]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: computes the mean goal differential of the games in the DataFrame, `1.5`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 DataFrame 中比赛的平均进球差为 `1.5`。
- en: '**Finger exercise:** Write an expression that computes the total number of
    goals scored in all of the rounds.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**手指练习：** 写一个表达式，计算所有轮次中进球的总数。'
- en: '**Finger exercise**: Write an expression that computes the total number of
    goals scored by the losing teams in the quarter finals.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**手指练习：** 写一个表达式，计算四分之一决赛中输球队进球的总数。'
- en: "Suppose we want to add a column containing the goal differential for all of\
    \ the games and add a row summarizing the totals for all the columns containing\
    \ numbers. Adding the column is simple. We merely execute \uFEFF`wwc['G Diff']\
    \ = wwc['W Goals'] - wwc['L Goals']`. Adding the row is more involved. We first\
    \ create a dictionary with the contents of the desired row, and then use that\
    \ dictionary to create a new DataFrame containing only the new row. We then use\
    \ the `concat` function to concatenate `wwc` and the new DataFrame."
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想添加一列，包含所有比赛的进球差异，并添加一行，总结所有包含数字的列的总计。添加列很简单。我们只需执行`wwc['G Diff'] = wwc['W
    Goals'] - wwc['L Goals']`。添加行则更复杂。我们首先创建一个包含所需行内容的字典，然后使用该字典创建一个只包含新行的新数据框。接着，我们使用`concat`函数将`wwc`和新数据框连接起来。
- en: '[PRE50]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This code produces the DataFrame
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成了数据框。
- en: '[PRE51]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Notice that when we tried to sum the values in columns that did not contain
    numbers, Pandas did not generate an exception. Instead it supplied the special
    value `NaN` (Not a Number).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们尝试对不包含数字的列中的值求和时，Pandas没有产生异常。相反，它提供了特殊值`NaN`（非数字）。
- en: In addition to providing simple arithmetic operations like sum and mean, Pandas
    provides methods for computing a variety of useful statistical functions. Among
    the most useful of these is `corr`, which is used to compute the **correlation**
    between two series.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供简单的算术操作，如求和和均值，Pandas还提供计算各种有用统计函数的方法。其中最有用的是`corr`，用于计算两个系列之间的**相关性**。
- en: A correlation is a number between -1 and 1 that provides information about the
    relationship between two numeric values. A positive correlation indicates that
    as the value of one variable increases, so does the value of the other. A negative
    correlation indicates that as the value of one variable increases, the value of
    the other variable decreases. A correlation of zero indicates that there is no
    relation between the values of the variables.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 相关性是一个介于-1和1之间的数字，提供有关两个数值之间关系的信息。正相关表明一个变量的值增加时，另一个变量的值也增加；负相关表明一个变量的值增加时，另一个变量的值减少。相关性为零表示变量之间没有关系。
- en: The most commonly used measure of correction is Pearson correlation. Pearson
    correlation measures the strength and direction of the linear relationship between
    two variables. In addition to Pearson correlation, Pandas supports two other measures
    of correlation, Spearman and Kendall. There are important differences among the
    three measures (e.g., Spearman is less sensitive to outliers than Pearson, but
    is useful only for discovering monotonic relationships), but a discussion of when
    to use which is beyond the scope of this book.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的相关性度量是皮尔逊相关性。皮尔逊相关性衡量两个变量之间线性关系的强度和方向。除了皮尔逊相关性外，Pandas还支持其他两种相关性度量，斯皮尔曼和肯德尔。这三种度量之间存在重要差异（例如，斯皮尔曼对异常值的敏感性低于皮尔逊，但仅对单调关系有用），但讨论何时使用哪一种超出了本书的范围。
- en: To print the Pearson pairwise correlations of `W Goals`, `L Goals`, and `G Diff`
    for all of the games (and exclude the row with the totals), we need only execute
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印`W Goals`、`L Goals`和`G Diff`的皮尔逊成对相关性（并排除包含总计的行），我们只需执行。
- en: '[PRE52]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: which produces
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了。
- en: '[PRE53]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The values along the diagonal are all 1, because each series is perfectly positively
    correlated with itself. Unsurprisingly, the goal differentials are strongly positively
    correlated with the number of goals scored by the winning team, and strongly negatively
    correlated with the number of goals scored by the loser. The weaker negative correlation
    between the goals scored by the winners and losers also makes sense for professional
    soccer.[^(176)](#c23-fn-0004)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对角线上的值都是1，因为每个系列与自身完全正相关。不出所料，进球差异与获胜队的进球数强正相关，而与输球队的进球数强负相关。获胜者和输者进球之间较弱的负相关在职业足球中也有其道理。[^(176)](#c23-fn-0004)
- en: 23.5 An Extended Example
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 23.5 扩展示例
- en: In this section we will look at two datasets, one containing historical temperature
    data for 21 U.S. cities and the other historical data about the global use of
    fossil fuels.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看两个数据集，一个包含21个美国城市的历史温度数据，另一个包含全球化石燃料使用的历史数据。
- en: 23.5.1 Temperature Data
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.5.1 温度数据
- en: The code
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE54]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: prints
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '[PRE55]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The first two lines of code set default options that limit the number of rows
    and columns shown when printing DataFrames. These options play a role similar
    to that played by the `rcParams` we used for setting various default values for
    plotting. The function `reset_option` can be used to set an option back to the
    system default value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行代码设置了默认选项，以限制打印DataFrame时显示的行数和列数。这些选项的作用类似于我们用于设置各种绘图默认值的`rcParams`。函数`reset_option`可以用来将选项恢复为系统默认值。
- en: This DataFrame is organized in a way that makes it easy to see what the weather
    was like in different cities on specific dates. For example, the query
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个DataFrame以一种便于查看特定日期不同城市天气的方式组织。例如，查询
- en: '[PRE56]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: tells us that on August 12, 1979, the temperature in New York was 15C and in
    Tampa 25.55C.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉我们在1979年8月12日，纽约的温度为15°C，坦帕为25.55°C。
- en: '**Finger exercise:** Write an expression that evaluates to `True` if Phoenix
    was warmer than Tampa on October 31, 2000, and `False` otherwise.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**手指练习：** 写一个表达式，如果2000年10月31日凤凰城比坦帕温暖则评估为`True`，否则评估为`False`。'
- en: '**Finger exercise:** Write code to extract the date on which the temperature
    in Phoenix was 41.4C.[^(177)](#c23-fn-0005)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**手指练习：** 编写代码提取凤凰城温度为41.4°C的日期。[^(177)](#c23-fn-0005)'
- en: Unfortunately, looking at data from 21 cities for 20,088 dates doesn't give
    us much direct insight into larger questions related to temperature trends. Let's
    start by adding columns that provide summary information about the temperatures
    each day. The code
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，查看21个城市在20,088个日期的数据并不能直接洞察与温度趋势相关的大问题。让我们开始添加提供每日温度汇总信息的列。代码
- en: '[PRE57]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: prints
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '[PRE58]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Was the mean temperature of those 21 cities on July 4, 2000, really much higher
    than the temperature on the surface of the sun? Probably not. It seems more likely
    that there is a bug in our code. The problem is that our DataFrame encodes dates
    as numbers, and these numbers are used to compute the mean of each row. Conceptually,
    it might make more sense to think of the date as an index for a series of temperatures.
    So, let's change the DataFrame to make the dates indices. The code
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 2000年7月4日，那21个城市的平均温度真的比太阳表面的温度高很多吗？可能不是。更可能的是我们的代码存在bug。问题在于我们的DataFrame将日期编码为数字，而这些数字用于计算每行的平均值。从概念上讲，考虑日期作为温度系列的索引可能更有意义。因此，让我们将DataFrame中的日期改为索引。代码
- en: '[PRE60]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: prints the more plausible
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 打印更可信的
- en: '[PRE61]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Notice, by the way, that since `Date` is no longer a column label, we had to
    use a different print statement. Why did we use slicing to select a single row?
    Because we wanted to create a DataFrame rather than a series.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，由于`Date`不再是列标签，我们不得不使用不同的打印语句。我们为什么要用切片选择单行？因为我们想创建一个DataFrame而不是一个系列。
- en: We are now in a position to start producing some plots showing various trends.
    For example,
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始绘制一些显示各种趋势的图表。例如，
- en: '[PRE62]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: "produces a plot that shows the seasonality of temperatures in the United States.\
    \ Notice that before plotting the mean temperatures we cast the series into a\
    \ list. Had we plotted the series directly, it would have used the indices of\
    \ the series (integers representing dates) for the x-axis. This would have produced\
    \ a rather odd-looking plot, since the points on the x-axis would have been strangely\
    \ spaced. For example, the distance between December 30, 1961 and December 31,\
    \ 1961 would have been 1, but the distance between December 31, 1961 and January\
    \ 1, 1962 would have been 8870 (\uFEFF19620,101 – 19611231)."
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: "生成的图表显示了美国温度的季节性。请注意，在绘制平均温度之前，我们将系列转换为列表。如果直接绘制系列，它将使用系列的索引（代表日期的整数）作为x轴。这将产生一种相当奇怪的图，因为x轴上的点会奇怪地间隔。例如，1961年12月30日和1961年12月31日之间的距离为1，但1961年12月31日和1962年1月1日之间的距离为8870（\uFEFF\
    19620,101 – 19611231）。"
- en: '![c23-fig-5001.jpg](../images/c23-fig-5001.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![c23-fig-5001.jpg](../images/c23-fig-5001.jpg)'
- en: We can see the seasonal pattern more clearly, by zooming in on a few years and
    producing a plot using the call `plt.plot(list(temperatures['Mean T'])[0:3*365])`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过放大几年的数据并使用调用`plt.plot(list(temperatures['Mean T'])[0:3*365])`生成图表，我们可以更清楚地看到季节模式。
- en: '![c23-fig-5002.jpg](../images/c23-fig-5002.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![c23-fig-5002.jpg](../images/c23-fig-5002.jpg)'
- en: Over the last decades, a consensus that the Earth is warming has emerged. Let's
    see whether this data is consistent with that consensus. Since we are investigating
    a hypothesis about a long-term trend, we should probably not be looking at daily
    or seasonal variations in temperature. Instead, let's look at annual data.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几十年里，关于地球变暖的共识已经形成。让我们看看这些数据是否与这一共识一致。由于我们正在研究一个关于长期趋势的假设，可能不应关注每日或季节性的温度变化。相反，让我们看一下年度数据。
- en: As a first step, let's use the data in `temperatures` to build a new DataFrame
    in which the rows represent years rather than days. Code that does this is contained
    in [Figure 23-3](#c23-fig-0005) and [Figure 23-4](#c23-fig-0006). Most of the
    work is done in the function `get_dict`, [Figure 23-3](#c23-fig-0005), which returns
    a dictionary mapping a year to a dictionary giving the values for that year associated
    with different labels. The implementation of `get_dict` iterates over the rows
    in `temperatures` using `iterrows`. That method returns an iterator that for each
    row returns a pair containing the index label and the contents of the row as a
    series. Elements of the yielded series can be selected using column labels.[^(178)](#c23-fn-0006)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，让我们使用`temperatures`中的数据构建一个新的数据框，其中行代表年份而不是天。执行此操作的代码包含在[图23-3](#c23-fig-0005)和[图23-4](#c23-fig-0006)中。大部分工作在函数`get_dict`中完成，
    [图23-3](#c23-fig-0005)返回一个字典，将年份映射到一个字典，该字典给出与不同标签相关的该年份的值。`get_dict`的实现使用`iterrows`遍历`temperatures`中的行。该方法返回一个迭代器，每一行返回一个包含索引标签和该行内容的系列对。可以使用列标签选择生成系列的元素。[^(178)](#c23-fn-0006)
- en: '![c23-fig-0003.jpg](../images/c23-fig-0003.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![c23-fig-0003.jpg](../images/c23-fig-0003.jpg)'
- en: '[Figure 23-3](#c23-fig-0005a) Building a dictionary mapping years to temperature
    data'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[图23-3](#c23-fig-0005a) 构建一个将年份映射到温度数据的字典'
- en: If `test` were the DataFrame
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`test`是数据框。
- en: '[PRE63]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: "the call \uFEFF`get_dict(test, ['Max', 'Min'])` would return the dictionary"
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`get_dict(test, ['Max', 'Min'])`将返回字典。
- en: '[PRE64]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '![c23-fig-0004.jpg](../images/c23-fig-0004.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![c23-fig-0004.jpg](../images/c23-fig-0004.jpg)'
- en: '[Figure 23-4](#c23-fig-0006a) Building a DataFrame organized around years'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[图23-4](#c23-fig-0006a) 围绕年份构建数据框'
- en: 'The code following the invocation of get_dict in [Figure 23-4](#c23-fig-0006)
    builds a list containing each year appearing in `temperatures,` and additional
    lists containing the minimum, maximum, and mean temperatures for those years.
    Finally it uses those lists to build the DataFrame `yearly_temps`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图23-4](#c23-fig-0006)中调用`get_dict`后的代码构建了一个包含出现在`temperatures`中的每一年的列表，以及包含这些年的最低、最高和平均温度的附加列表。最后，它使用这些列表构建数据框`yearly_temps`：
- en: '[PRE65]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now that we have the data in a convenient format, let's generate some plots
    to visualize how the temperatures change over time. The code in [Figure 23-5](#c23-fig-0007)
    produced the plots in [Figure 23-6](#c23-fig-0008).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经以便于处理的格式获得了数据，让我们生成一些图表来可视化温度随时间的变化。 [图23-5](#c23-fig-0007)中的代码生成了[图23-6](#c23-fig-0008)中的图表。
- en: '![c23-fig-0005.jpg](../images/c23-fig-0005.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![c23-fig-0005.jpg](../images/c23-fig-0005.jpg)'
- en: '[Figure 23-5](#c23-fig-0007a) Produce plots relating year to temperature measurements'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[图23-5](#c23-fig-0007a) 生成与年份相关的温度测量图'
- en: '![c23-fig-0006.jpg](../images/c23-fig-0006.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![c23-fig-0006.jpg](../images/c23-fig-0006.jpg)'
- en: '[Figure 23-6](#c23-fig-0008a) Mean and minimum annual temperatures'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[图23-6](#c23-fig-0008a) 年度平均和最低温度'
- en: The plot on the left in [Figure 23-6](#c23-fig-0008) shows an undeniable trend;[^(179)](#c23-fn-0007)
    the mean temperatures in these 21 cities has risen over time. The plot on the
    right is less clear. The extreme annual fluctuations make it hard to see a trend.
    A more revealing plot can be produced by plotting a **moving average** of the
    temperatures.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[图23-6](#c23-fig-0008)左侧的图表显示了一个不可否认的趋势；[^(179)](#c23-fn-0007)这21个城市的平均温度随着时间的推移而上升。右侧的图表则不那么清晰。极端的年度波动使得很难看出趋势。通过绘制温度的**移动平均**，可以生成更具启示性的图表。'
- en: "The Pandas method `rolling` is used to perform an operation on multiple consecutive\
    \ values of a series. Evaluating the expression `\uFEFFyearly_temps['Min T'].rolling(7).mean()`\
    \ produces a series in which the first 6 values are `NaN`, and for each i greater\
    \ than 6, the ith value in the series is the mean of `yearly_temps['Min'][i-6:i+1].`\
    \ Plotting that series against the year produces the plot in [Figure 23-7](#c23-fig-0009),\
    \ which does suggest a trend."
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas方法`rolling`用于对系列的多个连续值执行操作。评估表达式`yearly_temps['Min T'].rolling(7).mean()`会生成一个系列，其中前6个值为`NaN`，对于每个大于6的i，系列中的第i个值为`yearly_temps['Min'][i-6:i+1]`的平均值。将该系列与年份绘制在一起会生成图
    [图 23-7](#c23-fig-0009)，这确实暗示了一个趋势。
- en: '![c23-fig-0007.jpg](../images/c23-fig-0007.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![c23-fig-0007.jpg](../images/c23-fig-0007.jpg)'
- en: '[Figure 23-7](#c23-fig-0009a) Rolling average minimum temperatures'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 23-7](#c23-fig-0009a) 滚动平均最低温度'
- en: While visualizing the relationship between two series can be informative, it
    is often useful to look at those relationships more quantitatively. Let's start
    by looking at the correlations between years and the seven-year rolling averages
    of the minimum, maximum, and mean temperatures. Before computing the correlations,
    we first update the series in `yearly_temps` to contain rolling averages and then
    convert the year values from strings to integers. The code
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可视化两个系列之间的关系可以提供信息，但通常更有用的是以更定量的方式观察这些关系。让我们先看一下年份与七年滚动平均最低、最高和平均温度之间的相关性。在计算相关性之前，我们首先更新`yearly_temps`中的系列以包含滚动平均值，然后将年份值从字符串转换为整数。代码
- en: '[PRE66]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: prints
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '[PRE67]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: All of the summary temperature values are positively correlated with the year,
    with the mean temperatures the most strongly correlated. That raises the question
    of how much of the variance in the rolling average of the mean temperatures is
    explained by the year. The following code prints the coefficient of determination
    (Section 20.2.1).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 所有汇总的温度值与年份呈正相关，其中平均温度的相关性最强。这引发了一个问题：年份解释了平均温度滚动平均值方差的多少。以下代码打印决定系数（第 20.2.1
    节）。
- en: '[PRE68]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: "Since some of the values in the `Mean` series are `NaN`, we first use the function\
    \ `np.isfinite` to get the indices of the non-`NaN` values in `\uFEFFyearly_temps['Mean']`.\
    \ We then build a linear model and finally use the `r_squared` function (see Figure\
    \ 20-13) to compare the results predicted by the model to the actual temperatures.\
    \ The linear model relating years to the seven-year rolling average mean temperature\
    \ explains nearly 94% of the variance."
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Mean`系列中的一些值为`NaN`，我们首先使用函数`np.isfinite`获取`yearly_temps['Mean']`中非`NaN`值的索引。然后我们构建一个线性模型，最后使用`r_squared`函数（见图
    20-13）将模型预测的结果与实际温度进行比较。与年份相关的七年滚动平均温度几乎解释了94%的方差。
- en: '**Finger exercise:** Find the coefficient of determination (r²) for the mean
    annual temperature rather than for the rolling average and for a ten-year rolling
    average.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**指尖练习：** 找到平均年温度而非滚动平均和十年滚动平均的决定系数（r²）。'
- en: If you happen to live in the U.S. or plan to travel to the U.S., you might be
    more interested in looking at the data by city rather than year. Let's start by
    producing a new DataFrame that provides summary data for each city. In deference
    to our American readers, we convert all temperatures to Fahrenheit by applying
    a conversion function to all values in `city_temps`. The penultimate line adds
    a column showing how extreme the temperature variation is. Executing this code
    produces the DataFrame in [Figure 23-8](#c23-fig-0010).[^(180)](#c23-fn-0008)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你恰好住在美国或计划前往美国，你可能更有兴趣按城市而不是按年份查看数据。让我们首先生成一个新的DataFrame，以提供每个城市的汇总数据。为了考虑到我们的美国读者，我们通过对`city_temps`中的所有值应用转换函数，将所有温度转换为华氏度。倒数第二行添加了一列，显示温度变化的极端程度。执行此代码会生成
    [图 23-8](#c23-fig-0010) 中的DataFrame。[^(180)](#c23-fn-0008)
- en: '[PRE69]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '![c23-fig-0008.jpg](../images/c23-fig-0008.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![c23-fig-0008.jpg](../images/c23-fig-0008.jpg)'
- en: '[Figure 23-8](#c23-fig-0010a) Average temperatures for select cities'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 23-8](#c23-fig-0010a) 部分城市的平均温度'
- en: To visualize differences among cities, we generated the plot in [Figure 23-9](#c23-fig-0011)
    using the code
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化城市之间的差异，我们使用代码生成了图 [图 23-9](#c23-fig-0011)
- en: '[PRE70]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: "Notice that we used the sort order \uFEFF`Max - Min` for all three series.\
    \ The use of `ascending = False` reverses the default sorting order."
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们对所有三个系列使用了排序顺序`Max - Min`。使用`ascending = False`会逆转默认的排序顺序。
- en: '![c23-fig-0009.jpg](../images/c23-fig-0009.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![c23-fig-0009.jpg](../images/c23-fig-0009.jpg)'
- en: '[Figure 23-9](#c23-fig-0011a) Variation in temperature extremes'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[图23-9](#c23-fig-0011a) 温度极端变化'
- en: Looking at this plot we can see, among other things, that
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 看这个图我们可以看到，除了其他内容之外，
- en: Across cities, the minimum temperature differs much more than the maximum temperature.
    Because of this, Max – Min (the sort order) is strongly positively correlated
    with the minimum temperature.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在城市之间，最低温度的差异远大于最高温度。因此，最大值减去最小值（排序顺序）与最低温度之间存在强正相关。
- en: It never gets very hot in San Francisco or Seattle.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旧金山或西雅图从未变得非常炎热。
- en: The temperature in San Juan is close to constant.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圣胡安的温度几乎保持不变。
- en: The temperature in Chicago is not close to constant. It gets both quite hot
    and frighteningly cold in the windy city.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 芝加哥的温度并不接近恒定。这个风城的温度既会变得相当炎热，也会变得令人畏惧的寒冷。
- en: It gets uncomfortably hot in both Phoenix and Las Vegas.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凤凰城和拉斯维加斯都变得异常炎热。
- en: San Francisco and Albuquerque have about the same mean temperature, but radically
    different minima and maxima.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旧金山和阿尔伯克基的平均气温大致相同，但最低和最高温度差异显著。
- en: 23.5.2 Fossil Fuel Consumption
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.5.2 化石燃料消费
- en: "The file \uFEFFglobal-fossil-fuel-consumption.csv contains data about the yearly\
    \ consumption of fossil fuels on Earth from 1965 and 2015\\. The code"
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 文件global-fossil-fuel-consumption.csv包含1965年至2015年地球上化石燃料年消费的数据。代码
- en: '[PRE71]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: prints
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '[PRE72]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now, let's replace the columns showing the consumption of each kind of fuel
    by two columns, one showing the sum of the three, and the other the five-year
    rolling average of the sum.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将显示每种燃料消费的列替换为两列，一列显示三者的总和，另一列显示五年滚动平均的总和。
- en: '[PRE73]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We can plot this data using
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用
- en: '[PRE74]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: to get the plot in [Figure 23-10](#c23-fig-0012).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取[图23-10](#c23-fig-0012)中的情节。
- en: '![c23-fig-0010.jpg](../images/c23-fig-0010.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![c23-fig-0010.jpg](../images/c23-fig-0010.jpg)'
- en: '[Figure 23-10](#c23-fig-0012a) Global consumption of fossil fuels'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[图23-10](#c23-fig-0012a) 全球化石燃料消费'
- en: While there are a few small dips in consumption (e.g., around the 2008 financial
    crisis), the upward trend is unmistakable.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管消费量在少数小幅下滑（例如，2008年金融危机期间），但上升趋势显而易见。
- en: The scientific community has reached consensus that there is an association
    between this rise in fuel consumption and the rise in the average temperature
    on the planet. Let's see how it relates to the temperatures in the 21 U.S. cities
    we looked at in Section 23.5.1.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 科学界已达成共识，燃料消费的上升与地球平均温度的上升之间存在关联。让我们看看它与我们在23.5.1节中查看的21个美国城市的温度之间的关系。
- en: Recall that `yearly_temps` was bound to the DataFrame
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`yearly_temps`被绑定到数据框中。
- en: '[PRE75]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Wouldn't it be nice if there were an easy way to combine `yearly_temps` and
    `emissions`? Pandas’ `merge` function does just that. The code
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一种简单的方法来组合`yearly_temps`和`emissions`，那该多好啊？Pandas的`merge`函数正是如此。代码
- en: '[PRE76]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: prints the DataFrame
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 打印数据框
- en: '[PRE77]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The DataFrame contains the union of the columns appearing in `yearly_temps`
    and `emissions` but includes only rows built from the rows in `yearly_temps` and
    `emissions` that contain the same value in the `Year` column.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框包含出现在`yearly_temps`和`emissions`中的列的并集，但仅包括来自`yearly_temps`和`emissions`中具有相同`Year`值的行构建的行。
- en: "Now that we have the emissions and temperature information in the same DataFrame,\
    \ it is easy to look at how things are correlated with each other. The code  `\uFEFF\
    print(merged_df.corr().round(2).to_string())` prints"
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在同一个数据框中拥有排放和温度信息，轻松查看它们之间的相关性。代码`print(merged_df.corr().round(2).to_string())`打印
- en: '[PRE78]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We see that global fuel consumption in previous years is indeed highly correlated
    with both the mean and maximum temperature in these U.S. cities. Does this imply
    that increased fuel consumption is causing the rise in temperature? It does not.
    Notice that both are highly correlated with year. Perhaps some lurking variable
    is also correlated with year and is the causal factor. What we can say from a
    statistical perspective, is that the data does not contradict the widely accepted
    scientific hypothesis that the increased use of fossil fuels generates greenhouse
    gasses that have caused temperatures to rise.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，前几年的全球燃料消费确实与这些美国城市的平均温度和最高温度高度相关。这是否意味着增加的燃料消费导致温度上升？并不是。请注意，两者都与年份高度相关。也许某个潜在变量也与年份相关并且是因果因素。从统计学的角度来看，我们可以说，数据并不反驳广泛接受的科学假设，即化石燃料的增加使用产生的温室气体导致温度上升。
- en: This concludes our brief look at Pandas. We have only scratched the surface
    of what it offers. We will use it later in the book and introduce a few more features.
    If you want to learn more, there are many online resources and some excellent
    inexpensive books. The website `[https://www.dataschool.io/best-python-pandas-resources/](https://www.dataschool.io/best-python-pandas-resources/)`
    lists some of these.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对Pandas的简要介绍。我们只是在它所提供的内容上轻轻触及了一下。我们将在书中后续部分使用它，并介绍更多功能。如果你想了解更多，有许多在线资源以及一些优秀的廉价书籍。网站
    `[https://www.dataschool.io/best-python-pandas-resources/](https://www.dataschool.io/best-python-pandas-resources/)`
    列出了其中的一些。
- en: 23.6 Terms Introduced in Chapter
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 23.6 在章节中引入的术语
- en: DataFrame
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据框
- en: row
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行
- en: series
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列
- en: index
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引
- en: name
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称
- en: CSV file
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSV文件
- en: shape (of ndarray)
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ndarray的形状
- en: Boolean indexing
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔索引
- en: correlation of series
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列的相关性
- en: moving (rolling) average
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动（滚动）平均
