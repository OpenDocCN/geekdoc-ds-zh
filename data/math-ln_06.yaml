- en: 6\. Discrete Mathematics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 离散数学
- en: 原文：[https://leanprover-community.github.io/mathematics_in_lean/C06_Discrete_Mathematics.html](https://leanprover-community.github.io/mathematics_in_lean/C06_Discrete_Mathematics.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://leanprover-community.github.io/mathematics_in_lean/C06_Discrete_Mathematics.html](https://leanprover-community.github.io/mathematics_in_lean/C06_Discrete_Mathematics.html)'
- en: '*[Mathematics in Lean](index.html)* **   6\. Discrete Mathematics'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*[Lean中的数学](index.html)* **   6. 离散数学'
- en: '[View page source](_sources/C06_Discrete_Mathematics.rst.txt)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[查看页面源代码](_sources/C06_Discrete_Mathematics.rst.txt)'
- en: '* * *'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '*Discrete Mathematics* is the study of finite sets, objects, and structures.
    We can count the elements of a finite set, and we can compute finite sums or products
    over its elements, we can compute maximums and minimums, and so on. We can also
    study objects that are generated by finitely many applications of certain generating
    functions, we can define functions by structural recursion, and prove theorems
    by structural induction. This chapters describes parts of Mathlib that support
    these activities.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*离散数学*是研究有限集合、对象和结构的学科。我们可以计算有限集合的元素，我们可以对其元素计算有限和或积，我们可以计算最大值和最小值，等等。我们还可以研究由有限次应用某些生成函数生成的对象，我们可以通过结构递归定义函数，并通过结构归纳证明定理。本章描述了Mathlib支持这些活动的部分。'
- en: '## 6.1\. Finsets and Fintypes[](#finsets-and-fintypes "Link to this heading")'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '## 6.1. Finsets 和 Fintypes[](#finsets-and-fintypes "链接到本标题")'
- en: Dealing with finite sets and types in Mathlib can be confusing, because the
    library offers multiple ways of handling them. In this section we will discuss
    the most common ones.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mathlib中处理有限集合和类型可能会令人困惑，因为该库提供了多种处理它们的方式。在本节中，我们将讨论其中最常见的一些。
- en: 'We have already come across the type `Finset` in [Section 5.2](C05_Elementary_Number_Theory.html#section-induction-and-recursion)
    and [Section 5.3](C05_Elementary_Number_Theory.html#section-infinitely-many-primes).
    As the name suggests, an element of type `Finset α` is a finite set of elements
    of type `α`. We will call these “finsets.” The `Finset` data type is designed
    to have a computational interpretation, and many basic operations on `Finset α`
    assume that `α` has decidable equality, which guarantees that there is an algorithm
    for testing whether `a : α` is an element of a finset `s`.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '我们已经在[第5.2节](C05_Elementary_Number_Theory.html#section-induction-and-recursion)和[第5.3节](C05_Elementary_Number_Theory.html#section-infinitely-many-primes)中遇到了类型`Finset`。正如其名所示，类型`Finset
    α`的元素是类型`α`的有限集合。我们将称这些为“finsets”。`Finset`数据类型被设计成具有计算解释，并且许多对`Finset α`的基本操作都假设`α`具有可判定的等价性，这保证了存在一个算法来测试`a
    : α`是否是finset `s`的元素。'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you remove the declaration `[DecidableEq α]`, Lean will complain on the line
    `#check s ∩ t` because it cannot compute the intersection. All of the data types
    that you should expect to be able to compute with have decidable equality, however,
    and if you work classically by opening the `Classical` namespace and declaring
    `noncomputable section`, you can reason about finsets of elements of any type
    at all.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你移除了声明`[DecidableEq α]`，Lean将在`#check s ∩ t`这一行上抱怨，因为它无法计算交集。然而，你应该期望能够计算的所有数据类型都具有可判定的等价性，如果你通过打开`Classical`命名空间并声明`noncomputable
    section`进行经典工作，你就可以对任何类型的元素进行finsets的推理。
- en: 'Finsets support most of the set-theoretic operations that sets do:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Finsets支持集合所支持的大多数集合论操作：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that we have opened the `Finset` namespace, where theorems specific to
    finsets are found. If you step through the last example below, you will see applying
    `ext` followed by `simp` reduces the identity to a problem in propositional logic.
    As an exercise, you can try proving some of set identities from [Chapter 4](C04_Sets_and_Functions.html#sets-and-functions),
    transported to finsets.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经打开了`Finset`命名空间，其中包含特定于finsets的定理。如果你浏览下面的最后一个例子，你会看到应用`ext`然后是`simp`将恒等式简化为一个命题逻辑问题。作为一个练习，你可以尝试证明一些来自[第4章](C04_Sets_and_Functions.html#sets-and-functions)的集合恒等式，并将其转移到finsets中。
- en: 'You have already seen the notation `Finset.range n` for the finite set of natural
    numbers \(\{ 0, 1, \ldots, n-1 \}\). `Finset` also allows you to define finite
    sets by enumerating the elements:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了表示自然数有限集合\(\{ 0, 1, \ldots, n-1 \}\)的符号`Finset.range n`。`Finset`还允许你通过枚举元素来定义有限集合：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There are various ways to get Lean to recognize that order of elements and duplicates
    do not matter in a set presented in this way.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以让Lean认识到，在这种方式呈现的集合中，元素的顺序和重复项并不重要。
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can use `insert` to add a single element to a Finset, and `Finset.erase`
    to delete a single element. Note that `erase` is in the `Finset` namespace, but
    `insert` is in the root namespace.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `insert` 向 Finset 添加单个元素，并使用 `Finset.erase` 删除单个元素。请注意，`erase` 在 `Finset`
    命名空间中，但 `insert` 在根命名空间中。
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In fact, `{0, 1, 2}` is just notation for `insert 0 (insert 1 (singleton 2))`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`{0, 1, 2}` 只是 `insert 0 (insert 1 (singleton 2))` 的符号。
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Given a finset `s` and a predicate `P`, we can use set-builder notation `{x
    ∈ s | P x}` to define the set of elements of `s` that satisfy `P`. This is notation
    for `Finset.filter P s`, which can also be written `s.filter P`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个 finset `s` 和一个谓词 `P`，我们可以使用集合构造器符号 `{x ∈ s | P x}` 来定义满足 `P` 的 `s` 的元素集合。这是
    `Finset.filter P s` 的符号，也可以写成 `s.filter P`。
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Mathlib knows that the image of a finset under a function is a finset.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib 知道在函数下的 finset 的像是一个 finset。
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Lean also knows that the cartesian product `s ×ˢ t` of two finsets is a finset,
    and that the powerset of a finset is a finset. (Note that the notation `s ×ˢ t`
    also works for sets.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 也知道两个 finset 的笛卡尔积 `s ×ˢ t` 是一个 finset，以及一个 finset 的幂集也是一个 finset。（注意，符号
    `s ×ˢ t` 也可以用于集合。）
- en: '[PRE8]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Defining operations on finsets in terms of their elements is tricky, because
    any such definition has to be independent of the order in which the elements are
    presented. Of course, you can always define functions by composing existing operations.
    Another thing you can do is use `Finset.fold` to fold a binary operation over
    the elements, provided that the operation is associative and commutative, since
    these properties guarantee that the result is independent of the order that the
    operation is applied. Finite sums, products, and unions are defined in that way.
    In the last example below, `biUnion` stands for “bounded indexed union.” With
    conventional mathematical notation, the expression would be written \(\bigcup_{i
    ∈ s} g(i)\).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 finset 的元素上定义操作是棘手的，因为任何这样的定义都必须独立于元素呈现的顺序。当然，你可以通过组合现有操作来定义函数。你还可以使用 `Finset.fold`
    来对元素上的二元操作进行折叠，前提是操作是结合的和交换的，因为这些性质保证了结果与操作应用的顺序无关。有限和、积和并集就是这样定义的。在下面的最后一个例子中，`biUnion`
    代表“有界索引并”。用传统的数学符号，这个表达式将被写成 \(\bigcup_{i ∈ s} g(i)\)。
- en: '[PRE9]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There is a natural principle of induction on finsets: to prove that every finset
    has a property, show that the empty set has the property and that the property
    is preserved when we add one new element to a finset. (The `@` symbol in `@insert`
    is needed in the induction step of the next example to give names to the parameters
    `a` and `s` because they have been marked implicit. )'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 finset 有一个自然的归纳原则：要证明每个 finset 都有一个属性，只需证明空集具有该属性，并且当我们向 finset 添加一个新元素时，该属性得到保持。（在下一个例子的归纳步骤中，`@`
    符号在 `@insert` 中是必需的，因为它为参数 `a` 和 `s` 提供了名称，因为它们已被标记为隐式。）
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If `s` is a finset, `Finset.Nonempty s` is defined to be `∃ x, x ∈ s`. You can
    use classical choice to pick an element of a nonempty finset. Similarly, the library
    defines `Finset.toList s` which uses choice to pick the elements of `s` in some
    order.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `s` 是一个 finset，`Finset.Nonempty s` 被定义为 `∃ x, x ∈ s`。你可以使用经典选择来选择非空 finset
    的一个元素。同样，库定义了 `Finset.toList s`，它使用选择以某种顺序选择 `s` 的元素。
- en: '[PRE11]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can use `Finset.min` and `Finset.max` to choose the minimum or maximum element
    of a finset of elements of a linear order, and similarly you can use `Finset.inf`
    and `Finset.sup` with finsets of elements of a lattice, but there is a catch.
    What should the minimum element of an empty finset be? You can check that the
    primed versions of the functions below add a precondition that the finset is nonempty.
    The non-primed versions `Finset.min` and `Finset.max` add a top or bottom element,
    respectively, to the output type, to handle the case where the finset is empty.
    The non-primed versions `Finset.inf` and `Finset.sup` assume that the lattice
    comes equipped with a top or bottom element, respectively.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `Finset.min` 和 `Finset.max` 来选择线性顺序元素的 finset 的最小或最大元素，同样你也可以使用 `Finset.inf`
    和 `Finset.sup` 与格元素的 finset 一起使用，但有一个问题。空 finset 的最小元素应该是什么？你可以检查下面函数的带撇版本添加了一个先决条件，即
    finset 不能为空。不带撇版本的 `Finset.min` 和 `Finset.max` 分别向输出类型添加一个顶或底元素，以处理 finset 为空的情况。不带撇版本的
    `Finset.inf` 和 `Finset.sup` 假设格已经配备了顶或底元素。
- en: '[PRE12]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Every finset `s` has a finite cardinality, `Finset.card s`, which can be written
    `#s` when the `Finset` namespace is open.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 finset `s` 都有一个有限的基数，`Finset.card s`，当 `Finset` 命名空间打开时可以写成 `#s`。
- en: '[PRE13]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The next section is all about reasoning about cardinality.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将全部关于推理基数。
- en: When formalizing mathematics, one often has to make a decision as to whether
    to express one’s definitions and theorems in terms of sets or types. Using types
    often simplifies notation and proofs, but working with subsets of a type can be
    more flexible. The type-based analogue of a finset is a *fintype*, that is, a
    type `Fintype α` for some `α`. By definition, a fintype is just a data type that
    comes equipped with a finset `univ` that contains all its elements.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在形式化数学时，人们常常需要决定是否用集合或类型来表述自己的定义和定理。使用类型通常可以简化符号和证明，但处理类型的子集可能更加灵活。finset 的类型对应物是
    *fintype*，即某个 `α` 的类型 `Fintype α`。根据定义，fintype 只是一个带有包含所有其元素的 finset `univ` 的数据类型。
- en: '[PRE14]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`Fintype.card α` is equal to the cardinality of the corresponding finset.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fintype.card α` 等于相应 finset 的基数。'
- en: '[PRE15]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have already seen a prototypical example of a fintype, namely, the types
    `Fin n` for each `n`. Lean recognizes that the fintypes are closed under operations
    like the product operation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一个 fintype 的典型例子，即每个 `n` 的类型 `Fin n`。Lean 认识到 fintype 在乘积运算等操作下是封闭的。
- en: '[PRE16]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Any element `s` of `Finset α` can be coercied to a type `(↑s : Finset α)`,
    namely, the subtype of elements of `α` that are contained in `s`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Finset α` 的任何元素 `s` 都可以强制转换为类型 `(↑s : Finset α)`，即包含在 `s` 中的 `α` 的元素的子类型。'
- en: '[PRE17]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Lean and Mathlib use *type class inference* to track the additional structure
    on fintypes, namely, the universal finset that contains all the elements. In other
    words, you can think of a fintype as an algebraic structure equipped with that
    extra data. [Chapter 7](C07_Structures.html#structures) explains how this works.  ##
    6.2\. Counting Arguments[](#counting-arguments "Link to this heading")'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lean 和 Mathlib 使用 *类型类推理* 来追踪 fintype 上的额外结构，即包含所有元素的通用 finset。换句话说，你可以将 fintype
    视为一个带有额外数据的代数结构。[第 7 章](C07_Structures.html#structures) 解释了这是如何工作的。  ## 6.2\.
    计数论证[](#counting-arguments "链接到本标题")'
- en: 'The art of counting things is a central part of combinatorics. Mathlib contains
    several basic identities for counting elements of finsets:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 计数事物的艺术是组合数学的一个核心部分。Mathlib 包含了几个用于计数 finset 元素的基本恒等式：
- en: '[PRE18]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Opening the `Finset` namespace allows us to use the notation `#s` for `s.card`,
    as well as to use the shortened names card_union and so on.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Finset` 命名空间允许我们使用 `#s` 表示 `s.card` 的符号，以及使用缩短的名称 card_union 等等。
- en: 'Mathlib can also count elements of fintypes:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib 也可以计数 fintype 的元素：
- en: '[PRE19]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When the `Fintype` namespace is not open, we have to use `Fintype.card` instead
    of card.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Fintype` 命名空间未开放时，我们必须使用 `Fintype.card` 而不是 card。
- en: The following is an example of calculating the cardinality of a finset, namely,
    the union of range n with a copy of range n that has been shifted by more than
    n. The calculation requires showing the the two sets in the union are disjoint;
    the first line of the proof yields the side condition `Disjoint (range n) (image
    (fun i ↦ m + i) (range n))`, which is established at the end of the proof. The
    `Disjoint` predicate is too general to be directly useful to us, but the theorem
    `disjoint_iff_ne` puts it in a form we can use.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个计算 finset 基数的例子，即范围 n 与移位超过 n 的范围 n 的副本的并集。这个计算需要证明联合中的两个集合是互斥的；证明的第一行产生了侧条件
    `Disjoint (range n) (image (fun i ↦ m + i) (range n))`，该条件在证明的末尾得到证实。`Disjoint`
    谓词过于通用，直接对我们没有直接用处，但定理 `disjoint_iff_ne` 将其置于我们可以使用的形式。
- en: '[PRE20]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Throughout this section, `omega` will be a workhorse for us, for dealing with
    arithmetic calculations and inequalities.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，`omega` 将是我们处理算术计算和不等式的一个主要工具。
- en: Here is a more interesting example. Consider the subset of \(\{0, \ldots, n\}
    \times \{0, \ldots, n\}\) consisting of pairs \((i, j)\) such that \(i < j\).
    If you think of these as lattice points in the coordinate plane, they constitute
    an upper triangle of the square with corners \((0, 0)\) and \((n, n)\), not including
    the diagonal. The cardinality of the full square is \((n + 1)^2\), and removing
    the size of the diagonal and halving the result shows us that the cardinality
    of the triangle is \(n (n + 1) / 2\).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个更有趣的例子。考虑由 \(\{0, \ldots, n\} \times \{0, \ldots, n\}\) 的子集组成的对 \((i, j)\)，其中
    \(i < j\)。如果你将它们视为坐标平面上的格点，它们构成了一个以 \((0, 0)\) 和 \((n, n)\) 为顶点的上三角形，不包括对角线。整个正方形的基数是
    \((n + 1)^2\)，减去对角线的长度并将结果除以二，我们得到三角形的基数是 \(n (n + 1) / 2\)。
- en: Alternatively, we note that the rows of the triangle have sizes \(0, 1, \ldots,
    n\), so the cardinality is the sum of the first \(n\) natural numbers. The first
    `have` of the proof below describes the triangle as the union of the rows, where
    row \(j\) consists of the numbers \(0, 1, ..., j - 1\) paired with \(j\). In the
    proof below, the notation `(., j)` abbreviates the function `fun i ↦ (i, j)`.
    The rest of the proof is just a calculation with finset cardinalities.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们注意到三角形的行的大小为 \(0, 1, \ldots, n\)，因此基数是前 \(n\) 个自然数的和。下面证明的第一部分将三角形描述为行的并集，其中行
    \(j\) 由数字 \(0, 1, ..., j - 1\) 与 \(j\) 配对组成。在下面的证明中，符号 `(., j)` 简化了函数 `fun i ↦
    (i, j)`。其余的证明只是对有限集基数进行计算。
- en: '[PRE21]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The following variation on the proof does the calculation with fintypes instead
    of finsets. The type `α ≃ β` is the type of equivalences between `α` and `β`,
    consisting of a map in the forward direction, the map in the backward direction,
    and proofs that these two are inverse to one another. The first `have` in the
    proof shows that `triangle n` is equivalent to the disjoint union of `Fin i` as
    `i` ranges over `Fin (n + 1)`. Interestingly, the forward function and the reverse
    function are constructed with tactics, rather than written explicitly. Since they
    do nothing more than move data and information around, `rfl` establishes that
    they are inverses.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对证明的变体，它使用有限类型而不是有限集进行计算。类型 `α ≃ β` 是 `α` 和 `β` 之间等价关系的类型，由正向映射、反向映射以及证明这两个映射是彼此的逆映射组成。证明中的第一个
    `have` 显示 `triangle n` 与 `Fin i` 的不相交并等价，其中 `i` 在 `Fin (n + 1)` 上取值。有趣的是，正向函数和反向函数是用策略构建的，而不是明确写出。由于它们所做的只是移动数据和信息，`rfl`
    证明了它们是逆映射。
- en: After that, `rw [←Fintype.card_coe]` rewrites `#(triangle n)` as the cardinality
    of the subtype `{ x // x ∈ triangle n }`, and the rest of the proof is a calculation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，`rw [←Fintype.card_coe]` 将 `#(triangle n)` 重写为子类型 `{ x // x ∈ triangle n
    }` 的基数，其余的证明都是计算。
- en: '[PRE22]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here is yet another approach. The first line of the proof below reduces the
    problem to showing `2 * #(triangle n) = (n + 1) * n`. We can do that by showing
    that two copies of the triangle exactly fill the rectangle `range n ×ˢ range (n
    + 1)`. As an exercise, see if you can fill in the steps of the calculation. In
    the solutions, we rely on `omega` extensively in the second-to-last step, but
    we unfortunately have to do a fair amount of work by hand.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '这里是另一种方法。下面证明的第一行将问题简化为证明 `2 * #(triangle n) = (n + 1) * n`。我们可以通过证明三角形的两个副本正好填满矩形
    `range n ×ˢ range (n + 1)` 来做到这一点。作为一个练习，看看你是否能填补计算步骤。在解答中，我们在倒数第二步大量使用了 `omega`，但不幸的是，我们不得不手动做相当多的工作。'
- en: '[PRE23]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can convince yourself that we get the same triangle, shifted down, if we
    replace `n` by `n + 1` and replace `<` by `≤` in the definition of `triangle`.
    The exercise below asks you to use this fact to show that the two triangles have
    the same size.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自己验证，如果我们用 `n + 1` 替换 `n` 并在 `triangle` 的定义中将 `<` 替换为 `≤`，我们会得到相同的三角形，只是向下移动了。下面的练习要求你使用这个事实来证明两个三角形具有相同的大小。
- en: '[PRE24]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let us close this section with an example and an exercise from a [tutorial](https://www.youtube.com/watch?v=_cJctOIXWE4&list=PLlF-CfQhukNn7xEbfL38eLgkveyk9_myQ&index=8&t=2737s&ab_channel=leanprovercommunity)
    on combinatorics given by Bhavik Mehta at *Lean for the Curious Mathematician*
    in 2023. Suppose we have a bipartite graph with vertex sets `s` and `t`, such
    that for every `a` in `s`, there are at least three edges leaving `a`, and for
    every `b` in `t`, there is at most one edge entering `b`. Then the total number
    of edges in the graph is at least three times the cardinality of `s` and at most
    the cardinality of `t`, from which is follows that three times the cardinality
    of `s` is at most the cardinality of `t`. The following theorem implements this
    argument, where we use the relation `r` to represent the edges of the graph. The
    proof is an elegant calculation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个例子和一个练习来结束这一节，这个例子和练习来自 Bhavik Mehta 在 2023 年于 *Lean for the Curious Mathematician*
    上给出的组合学教程 [教程](https://www.youtube.com/watch?v=_cJctOIXWE4&list=PLlF-CfQhukNn7xEbfL38eLgkveyk9_myQ&index=8&t=2737s&ab_channel=leanprovercommunity)。假设我们有一个二分图，其顶点集为
    `s` 和 `t`，对于 `s` 中的每个 `a`，至少有三条离开 `a` 的边，而对于 `t` 中的每个 `b`，最多有一条进入 `b` 的边。那么图中边的总数至少是
    `s` 的基数的三倍，最多是 `t` 的基数，由此可以推出三倍的 `s` 的基数最多是 `t` 的基数。以下定理实现了这个论证，其中我们使用关系 `r` 来表示图的边。证明是一个优雅的计算。
- en: '[PRE25]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The following exercise is also taken from Mehta’s tutorial. Suppose `A` is a
    subset of `range (2 * n)` with `n + 1` elements. It’s easy to see that `A` must
    contain two consecutive integers, and hence two elements that are coprime. If
    you watch the tutorial, you will see that a good deal of effort was spent in establishing
    the following fact, which is now proved automatically by `omega`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习也来自 Mehta 的教程。假设 `A` 是 `range (2 * n)` 的一个包含 `n + 1` 个元素的子集。很容易看出 `A` 必须包含两个连续的整数，因此包含两个互质的元素。如果你观看教程，你会看到大量的努力用于建立以下事实，现在这个事实已经被
    `omega` 自动证明。
- en: '[PRE26]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The solution to Mehta’s exercise uses the pigeonhole principle, in the form
    `exists_lt_card_fiber_of_mul_lt_card_of_maps_to`, to show that there are two distinct
    elements `m` and `k` in `A` such that `m / 2 = k / 2`. See if you can complete
    the justification of that fact and then use it to finish the proof.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Mehta 练习的解决方案使用了抽屉原理，形式为 `exists_lt_card_fiber_of_mul_lt_card_of_maps_to`，以表明在
    `A` 中存在两个不同的元素 `m` 和 `k`，使得 `m / 2 = k / 2`。看看你是否能完成该事实的证明，然后使用它来完成证明。
- en: '[PRE27]  ## 6.3\. Inductively Defined Types[](#inductively-defined-types "Link
    to this heading")'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE27]  ## 6.3\. 归纳定义的类型[](#inductively-defined-types "链接到本标题")'
- en: Lean’s foundation allows us to define inductive types, that is, data types whose
    instances are generated from the bottom up. For example, the data type `List α`
    of lists of elements of `α` is generated by starting with the empty list, `nil`,
    and successively adding elements to the front the list. Below we will define a
    type of binary trees, `BinTree`, whose elements are generated by starting with
    the empty tree and building new trees by attaching a new node to two existing
    trees.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 的基础允许我们定义归纳类型，即从底部向上生成实例的数据类型。例如，由空列表 `nil` 开始，并逐个添加元素到列表前端的 `List α` 列表类型。下面我们将定义一个二叉树类型
    `BinTree`，其元素从空树开始，通过将新节点附加到两个现有树来构建新树。
- en: 'In Lean, one can define inductive types whose objects are infinite, like countably
    branching well-founded trees. Finite inductive definitions are commonly used in
    discrete mathematics, however, especially in those branches of discrete mathematics
    that are relevant to computer science. Lean provides not only the means to define
    such types, but also principles of induction and definition by recursion. For
    example, the data type `List α` is defined inductively:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lean 中，可以定义对象无限、如可数分支良好基础树的归纳类型。在离散数学中，有限归纳定义通常被使用，尤其是在与计算机科学相关的离散数学分支中。Lean
    不仅提供了定义此类类型的手段，还提供了归纳和递归定义的原则。例如，数据类型 `List α` 是通过归纳定义的：
- en: '[PRE28]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The inductive definition says that every element of `List α` is either `nil`,
    the empty list, or `cons a as`, where `a` is an element of `α` and `as` is a list
    of elements of `α`. The constructors are properly named `List.nil` and `List.cons`,
    but you can use the shorter notation with the `List` namespace is open. When the
    `List` namespace is *not* open, you can write `.nil` and `.cons a as` anywhere
    that `Lean` expects a list, and Lean will automatically insert the `List` qualifier.
    Throughout this section, we will put temporary definitions in separate namespaces
    like `MyListSpace` to avoid conflicts with the standard library. Outside the temporary
    namespace, we revert to using the standard library definitions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳定义说明 `List α` 的每个元素要么是 `nil`，即空列表，要么是 `cons a as`，其中 `a` 是 `α` 的一个元素，`as`
    是 `α` 的元素列表。构造函数被适当地命名为 `List.nil` 和 `List.cons`，但你可以使用 `List` 命名空间开放的简短表示。当 `List`
    命名空间 *不* 开放时，你可以在 Lean 需要列表的任何地方写 `.nil` 和 `.cons a as`，Lean 将自动插入 `List` 限定符。在本节中，我们将临时定义放在单独的命名空间，如
    `MyListSpace`，以避免与标准库冲突。在临时命名空间之外，我们将恢复使用标准库定义。
- en: 'Lean defines the notation `[]` for `nil` and `::` for `cons`, and you can write
    `[a, b, c]` for `a :: b :: c :: []`. The append and map functions are defined
    recursively as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lean 定义了 `[]` 表示 `nil` 和 `::` 表示 `cons` 的符号，你可以用 `[a, b, c]` 表示 `a :: b ::
    c :: []`。append 和 map 函数如下递归定义：'
- en: '[PRE29]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Notice that there is a base case and a recursive case. In each case, the two
    defining clauses hold definitionally:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，存在一个基本情况和一个递归情况。在每种情况下，两个定义子句都定义性地成立：
- en: '[PRE30]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The functions `append` and `map` are defined in the standard library, and `append
    as bs` can be written as `as ++ bs`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `append` 和 `map` 定义在标准库中，`append as bs` 可以写成 `as ++ bs`。
- en: Lean allows you to write proofs by induction following the structure of the
    definition.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 允许你按照定义的结构通过归纳来编写证明。
- en: '[PRE31]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can also use the `induction'` tactic.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `induction'` 策略。
- en: Of course, these theorems are already in the standard library. As an exercise,
    try defining a function `reverse` in the `MyListSpace3` namespace (to avoid conflicting
    with the standard `List.reverse`) that reverses a list. You can use `#eval reverse
    [1, 2, 3, 4, 5]` to test it out. The most straightforward definition of `reverse`
    requires quadratic time, but don’t worry about that. You can jump to the definition
    of `List.reverse` in the standard library to see a linear-time implementation.
    Try proving `reverse (as ++ bs) = reverse bs ++ reverse as` and `reverse (reverse
    as) = as`. You can use `cons_append` and `append_assoc`, but you You may need
    to come up with auxiliary lemmas and prove them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些定理已经在标准库中。作为一个练习，尝试在 `MyListSpace3` 命名空间中定义一个函数 `reverse`（为了避免与标准 `List.reverse`
    冲突），该函数反转一个列表。你可以使用 `#eval reverse [1, 2, 3, 4, 5]` 来测试它。`reverse` 的最直接定义需要二次时间，但不用担心这一点。你可以跳转到标准库中
    `List.reverse` 的定义，以查看线性时间实现。尝试证明 `reverse (as ++ bs) = reverse bs ++ reverse
    as` 和 `reverse (reverse as) = as`。你可以使用 `cons_append` 和 `append_assoc`，但你可能需要提出辅助引理并证明它们。
- en: '[PRE32]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For another example, consider the following inductive definition of binary trees
    together with functions to compute the size and depth of a binary tree.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，考虑以下二叉树的归纳定义以及计算二叉树大小和深度的函数。
- en: '[PRE33]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It is convenient to count the empty binary tree as a binary tree of size 0 and
    depth 0. In the literature, this data type is sometimes called the *extended binary
    trees*. Including the empty tree means, for example, that we can define the tree
    `node empty (node empty empty)` consisting of a root node, and empty left subtree,
    and a right subtree consisting of a single node.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将空二叉树计为大小为 0 和深度为 0 的二叉树是很方便的。在文献中，这种数据类型有时被称为 *扩展二叉树*。包括空树意味着，例如，我们可以定义由根节点、空左子树和由单个节点组成的右子树构成的树
    `node empty (node empty empty)`。
- en: 'Here is an important inequality relating the size and the depth:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个重要的不等式，它关联了大小和深度：
- en: '[PRE34]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Try proving the following inequality, which is somewhat easier. Remember, if
    you do a proof by induction as in the previous theorem, you have to delete the
    `:= by`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试证明以下不等式，这稍微容易一些。记住，如果你像前一个定理那样进行归纳证明，你必须删除 `:= by`。
- en: '[PRE35]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Also define the `flip` operation on binary trees, which recursively swaps the
    left and right subtrees.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 还定义二叉树上的 `flip` 操作，它递归地交换左右子树。
- en: '[PRE36]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you did it right, the proof of the following should be rfl.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做对了，以下证明应该是 rfl。
- en: '[PRE37]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Prove the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 证明以下内容：
- en: '[PRE38]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We close this section with some formal logic. The following is an inductive
    definition of propositional formulas.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一些形式逻辑结束本节。以下是对命题公式的归纳定义。
- en: '[PRE39]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Every propositional formula is either a variable `var n`, the constant false
    `fls`, or a compound formula of the form `conj A B`, `disj A B`, or `impl A B`.
    With ordinary mathematical notation, these are commonly written \(p_n\), \(\bot\),
    \(A \wedge B\), \(A \vee B\), and \(A \to B\), respectively. The other propositional
    connectives can be defined in terms of these; for example, we can define \(\neg
    A\) as \(A \to \bot\) and \(A \leftrightarrow B\) as \((A \to B) \wedge (B \to
    A)\).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命题公式要么是一个变量 `var n`，要么是常量假 `fls`，要么是形如 `conj A B`、`disj A B` 或 `impl A B`
    的复合公式。用常规数学符号，这些通常分别写成 \(p_n\)、\(\bot\)、\(A \wedge B\)、\(A \vee B\) 和 \(A \to
    B\)。其他命题连接词可以用这些来定义；例如，我们可以定义 \(\neg A\) 为 \(A \to \bot\) 和 \(A \leftrightarrow
    B\) 为 \((A \to B) \wedge (B \to A)\)。
- en: Having defined the data type of propositional formulas, we define what it means
    to evaluate a propositional formula with respect to an assignment `v` of Boolean
    truth values to the variables.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了命题公式的数据类型之后，我们定义了相对于布尔真值赋值 `v` 的变量赋值来评估命题公式的含义。
- en: '[PRE40]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The next definition specifies the set of variables occurring in a formula, and
    the subsequent theorem shows that evaluating a formula on two truth assignments
    that agree on its variables yields that same value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个定义指定了公式中出现的变量集合，接下来的定理表明，在两个变量上达成一致的真值赋值上评估公式会产生相同的值。
- en: '[PRE41]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Noticing the repetition, we can be clever about the use of automation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到重复，我们可以巧妙地使用自动化。
- en: '[PRE42]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The function `subst A m C` describes the result of substituting the formula
    `C` for every occurrence of the variable `var m` in the formula `A`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `subst A m C` 描述了将公式 `C` 替换到公式 `A` 中每个 `var m` 出现的结果。
- en: '[PRE43]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As an example, show that substituting for a variable that does not occur in
    a formula has no effect:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，展示替换一个在公式中不出现的变量没有任何影响：
- en: '[PRE44]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following theorem says something more subtle and interesting: evaluating
    `A.subst n C` on a truth assignment `v` is the same as evaluating `A` on a truth
    assignment that assigns the value of `C` to `var n`. See if you can prove it.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下定理提出了更微妙且有趣的内容：在真值赋值`v`上评估`A.subst n C`与在将`C`的值赋给变量`n`的真值赋值上评估`A`是相同的。看看你是否能证明它。
- en: '[PRE45] [Previous](C05_Elementary_Number_Theory.html "5\. Elementary Number
    Theory") [Next](C07_Structures.html "7\. Structures")'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE45] [上一节](C05_Elementary_Number_Theory.html "5\. 基础数论") [下一节](C07_Structures.html
    "7\. 结构")'
- en: '* * *'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: © Copyright 2020-2025, Jeremy Avigad, Patrick Massot. Text licensed under CC
    BY 4.0.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: © 版权所有 2020-2025，Jeremy Avigad，Patrick Massot。文本许可协议为CC BY 4.0。
- en: Built with [Sphinx](https://www.sphinx-doc.org/) using a [theme](https://github.com/readthedocs/sphinx_rtd_theme)
    provided by [Read the Docs](https://readthedocs.org). *Discrete Mathematics* is
    the study of finite sets, objects, and structures. We can count the elements of
    a finite set, and we can compute finite sums or products over its elements, we
    can compute maximums and minimums, and so on. We can also study objects that are
    generated by finitely many applications of certain generating functions, we can
    define functions by structural recursion, and prove theorems by structural induction.
    This chapters describes parts of Mathlib that support these activities.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[Sphinx](https://www.sphinx-doc.org/)和[Read the Docs](https://readthedocs.org)提供的[主题](https://github.com/readthedocs/sphinx_rtd_theme)构建。*离散数学*是研究有限集合、对象和结构的学科。我们可以计算有限集合的元素数量，也可以对其元素进行有限求和或乘积计算，还可以计算最大值和最小值等。我们还可以研究由有限次应用某些生成函数生成的对象，可以通过结构递归定义函数，并通过结构归纳证明定理。本章描述了Mathlib支持这些活动的部分。
- en: '## 6.1\. Finsets and Fintypes[](#finsets-and-fintypes "Link to this heading")'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '## 6.1. Finsets 和 Fintypes[](#finsets-and-fintypes "链接到本标题")'
- en: Dealing with finite sets and types in Mathlib can be confusing, because the
    library offers multiple ways of handling them. In this section we will discuss
    the most common ones.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mathlib中处理有限集合和类型可能会令人困惑，因为该库提供了多种处理它们的方式。在本节中，我们将讨论最常见的方法。
- en: 'We have already come across the type `Finset` in [Section 5.2](C05_Elementary_Number_Theory.html#section-induction-and-recursion)
    and [Section 5.3](C05_Elementary_Number_Theory.html#section-infinitely-many-primes).
    As the name suggests, an element of type `Finset α` is a finite set of elements
    of type `α`. We will call these “finsets.” The `Finset` data type is designed
    to have a computational interpretation, and many basic operations on `Finset α`
    assume that `α` has decidable equality, which guarantees that there is an algorithm
    for testing whether `a : α` is an element of a finset `s`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '我们已经在[第5.2节](C05_Elementary_Number_Theory.html#section-induction-and-recursion)和[第5.3节](C05_Elementary_Number_Theory.html#section-infinitely-many-primes)中遇到了`Finset`类型。正如其名所示，`Finset
    α`类型的一个元素是类型`α`的有限集合。我们将称这些为“finsets”。`Finset`数据类型旨在具有计算解释，并且`Finset α`上的许多基本操作都假设`α`具有可判定的等价性，这保证了存在一个算法来测试`a
    : α`是否是finset `s`的元素。'
- en: '[PRE46]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If you remove the declaration `[DecidableEq α]`, Lean will complain on the line
    `#check s ∩ t` because it cannot compute the intersection. All of the data types
    that you should expect to be able to compute with have decidable equality, however,
    and if you work classically by opening the `Classical` namespace and declaring
    `noncomputable section`, you can reason about finsets of elements of any type
    at all.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你移除声明`[DecidableEq α]`，Lean将在`#check s ∩ t`行上抱怨，因为它无法计算交集。然而，你应该期望能够计算的所有数据类型都具有可判定的等价性，如果你通过打开`Classical`命名空间并声明`noncomputable
    section`进行经典工作，你就可以对任何类型的元素进行finsets的推理。
- en: 'Finsets support most of the set-theoretic operations that sets do:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Finsets支持集合所具有的大多数集合论操作：
- en: '[PRE47]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that we have opened the `Finset` namespace, where theorems specific to
    finsets are found. If you step through the last example below, you will see applying
    `ext` followed by `simp` reduces the identity to a problem in propositional logic.
    As an exercise, you can try proving some of set identities from [Chapter 4](C04_Sets_and_Functions.html#sets-and-functions),
    transported to finsets.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经打开了`Finset`命名空间，其中包含特定于finsets的定理。如果你浏览下面的最后一个例子，你会看到应用`ext`后跟`simp`将恒等式简化为命题逻辑中的问题。作为练习，你可以尝试证明一些来自[第4章](C04_Sets_and_Functions.html#sets-and-functions)的集合恒等式，并将其转移到finsets中。
- en: 'You have already seen the notation `Finset.range n` for the finite set of natural
    numbers \(\{ 0, 1, \ldots, n-1 \}\). `Finset` also allows you to define finite
    sets by enumerating the elements:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了 `Finset.range n` 的表示法，它表示自然数有限集合 \(\{ 0, 1, \ldots, n-1 \}\)。`Finset`
    还允许你通过枚举元素来定义有限集合：
- en: '[PRE48]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: There are various ways to get Lean to recognize that order of elements and duplicates
    do not matter in a set presented in this way.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以让 Lean 认识到以这种方式呈现的集合中元素的顺序和重复是不重要的。
- en: '[PRE49]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You can use `insert` to add a single element to a Finset, and `Finset.erase`
    to delete a single element. Note that `erase` is in the `Finset` namespace, but
    `insert` is in the root namespace.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `insert` 向有限集合添加单个元素，并使用 `Finset.erase` 删除单个元素。请注意，`erase` 在 `Finset`
    命名空间中，但 `insert` 在根命名空间中。
- en: '[PRE50]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In fact, `{0, 1, 2}` is just notation for `insert 0 (insert 1 (singleton 2))`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`{0, 1, 2}` 只是对 `insert 0 (insert 1 (singleton 2))` 的表示。
- en: '[PRE51]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Given a finset `s` and a predicate `P`, we can use set-builder notation `{x
    ∈ s | P x}` to define the set of elements of `s` that satisfy `P`. This is notation
    for `Finset.filter P s`, which can also be written `s.filter P`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个有限集合 `s` 和一个谓词 `P`，我们可以使用集合构造符号 `{x ∈ s | P x}` 来定义满足 `P` 的 `s` 的元素集合。这是
    `Finset.filter P s` 的表示法，也可以写作 `s.filter P`。
- en: '[PRE52]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Mathlib knows that the image of a finset under a function is a finset.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib 知道有限集合在函数下的像也是一个有限集合。
- en: '[PRE53]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Lean also knows that the cartesian product `s ×ˢ t` of two finsets is a finset,
    and that the powerset of a finset is a finset. (Note that the notation `s ×ˢ t`
    also works for sets.)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 还知道两个有限集合的笛卡尔积 `s ×ˢ t` 是一个有限集合，以及有限集合的幂集也是一个有限集合。（注意，`s ×ˢ t` 的表示法也适用于集合。）
- en: '[PRE54]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Defining operations on finsets in terms of their elements is tricky, because
    any such definition has to be independent of the order in which the elements are
    presented. Of course, you can always define functions by composing existing operations.
    Another thing you can do is use `Finset.fold` to fold a binary operation over
    the elements, provided that the operation is associative and commutative, since
    these properties guarantee that the result is independent of the order that the
    operation is applied. Finite sums, products, and unions are defined in that way.
    In the last example below, `biUnion` stands for “bounded indexed union.” With
    conventional mathematical notation, the expression would be written \(\bigcup_{i
    ∈ s} g(i)\).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在有限集合的元素上定义操作是棘手的，因为任何这样的定义都必须独立于元素呈现的顺序。当然，你可以通过组合现有操作来定义函数。你还可以使用 `Finset.fold`
    来对元素执行二元操作，前提是操作是结合的和交换的，因为这些性质保证了结果与操作应用的顺序无关。有限和、积和并集就是这样定义的。在下面的最后一个例子中，`biUnion`
    表示“有界索引并”。按照传统的数学符号，这个表达式将被写作 \(\bigcup_{i ∈ s} g(i)\)。
- en: '[PRE55]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'There is a natural principle of induction on finsets: to prove that every finset
    has a property, show that the empty set has the property and that the property
    is preserved when we add one new element to a finset. (The `@` symbol in `@insert`
    is needed in the induction step of the next example to give names to the parameters
    `a` and `s` because they have been marked implicit. )'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有限集合有一个自然的归纳原理：要证明每个有限集合都具有某个性质，需要证明空集具有该性质，并且当我们向有限集合添加一个新元素时，该性质得到保持。（在 `@insert`
    的下一个例子的归纳步骤中，`@` 符号是必需的，因为它为参数 `a` 和 `s` 提供了名称，因为它们已被标记为隐式。）
- en: '[PRE56]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If `s` is a finset, `Finset.Nonempty s` is defined to be `∃ x, x ∈ s`. You can
    use classical choice to pick an element of a nonempty finset. Similarly, the library
    defines `Finset.toList s` which uses choice to pick the elements of `s` in some
    order.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `s` 是一个有限集合，`Finset.Nonempty s` 被定义为 `∃ x, x ∈ s`。你可以使用经典选择来选择一个非空有限集合的元素。同样，库定义了
    `Finset.toList s`，它使用选择来以某种顺序选择 `s` 的元素。
- en: '[PRE57]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You can use `Finset.min` and `Finset.max` to choose the minimum or maximum element
    of a finset of elements of a linear order, and similarly you can use `Finset.inf`
    and `Finset.sup` with finsets of elements of a lattice, but there is a catch.
    What should the minimum element of an empty finset be? You can check that the
    primed versions of the functions below add a precondition that the finset is nonempty.
    The non-primed versions `Finset.min` and `Finset.max` add a top or bottom element,
    respectively, to the output type, to handle the case where the finset is empty.
    The non-primed versions `Finset.inf` and `Finset.sup` assume that the lattice
    comes equipped with a top or bottom element, respectively.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `Finset.min` 和 `Finset.max` 来选择线性顺序元素的 finset 的最小或最大元素，同样你也可以使用 `Finset.inf`
    和 `Finset.sup` 与格元素的 finset，但有一个问题。空 finset 的最小元素应该是什么？你可以检查以下函数的带撇版本添加了一个先决条件，即
    finset 不能为空。不带撇版本的 `Finset.min` 和 `Finset.max` 分别向输出类型添加一个顶或底元素，以处理 finset 为空的情况。不带撇版本的
    `Finset.inf` 和 `Finset.sup` 假设格已经配备了顶或底元素。
- en: '[PRE58]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Every finset `s` has a finite cardinality, `Finset.card s`, which can be written
    `#s` when the `Finset` namespace is open.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每个finset `s` 都有一个有限的基数，`Finset.card s`，当 `Finset` 命名空间打开时可以写成 `#s`。
- en: '[PRE59]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The next section is all about reasoning about cardinality.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分完全是关于推理基数。
- en: When formalizing mathematics, one often has to make a decision as to whether
    to express one’s definitions and theorems in terms of sets or types. Using types
    often simplifies notation and proofs, but working with subsets of a type can be
    more flexible. The type-based analogue of a finset is a *fintype*, that is, a
    type `Fintype α` for some `α`. By definition, a fintype is just a data type that
    comes equipped with a finset `univ` that contains all its elements.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在形式化数学时，人们常常需要决定是否用集合或类型来表述自己的定义和定理。使用类型通常可以简化符号和证明，但处理类型的子集可能更加灵活。基于类型的 finset
    类似物是 *fintype*，即某个 `α` 的类型 `Fintype α`。根据定义，fintype 只是一个带有包含所有元素的 finset `univ`
    的数据类型。
- en: '[PRE60]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`Fintype.card α` is equal to the cardinality of the corresponding finset.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fintype.card α` 等于相应的 finset 的基数。'
- en: '[PRE61]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We have already seen a prototypical example of a fintype, namely, the types
    `Fin n` for each `n`. Lean recognizes that the fintypes are closed under operations
    like the product operation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 fintype 的一个典型例子，即每个 `n` 的类型 `Fin n`。Lean 认识到 fintype 在诸如积运算之类的操作下是封闭的。
- en: '[PRE62]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Any element `s` of `Finset α` can be coercied to a type `(↑s : Finset α)`,
    namely, the subtype of elements of `α` that are contained in `s`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`Finset α` 的任何元素 `s` 都可以强制转换为类型 `(↑s : Finset α)`，即包含在 `s` 中的 `α` 的元素的子类型。'
- en: '[PRE63]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Lean and Mathlib use *type class inference* to track the additional structure
    on fintypes, namely, the universal finset that contains all the elements. In other
    words, you can think of a fintype as an algebraic structure equipped with that
    extra data. [Chapter 7](C07_Structures.html#structures) explains how this works.  ##
    6.2\. Counting Arguments[](#counting-arguments "Link to this heading")'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 和 Mathlib 使用 *类型类推断* 来跟踪 fintype 上的附加结构，即包含所有元素的通用 finset。换句话说，你可以将 fintype
    视为一个带有额外数据的代数结构。[第 7 章](C07_Structures.html#structures) 解释了这是如何工作的。
- en: 'The art of counting things is a central part of combinatorics. Mathlib contains
    several basic identities for counting elements of finsets:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 计数事物的艺术是组合数学的核心部分。Mathlib 包含了几个用于计数 finset 元素的基本恒等式：
- en: '[PRE64]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Opening the `Finset` namespace allows us to use the notation `#s` for `s.card`,
    as well as to use the shortened names card_union and so on.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Finset` 命名空间允许我们使用 `#s` 表示 `s.card`，以及使用缩短的名称 card_union 等等。
- en: 'Mathlib can also count elements of fintypes:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib 也可以计数 fintype 的元素：
- en: '[PRE65]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: When the `Fintype` namespace is not open, we have to use `Fintype.card` instead
    of card.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Fintype` 命名空间没有打开时，我们必须使用 `Fintype.card` 而不是 card。
- en: The following is an example of calculating the cardinality of a finset, namely,
    the union of range n with a copy of range n that has been shifted by more than
    n. The calculation requires showing the the two sets in the union are disjoint;
    the first line of the proof yields the side condition `Disjoint (range n) (image
    (fun i ↦ m + i) (range n))`, which is established at the end of the proof. The
    `Disjoint` predicate is too general to be directly useful to us, but the theorem
    `disjoint_iff_ne` puts it in a form we can use.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个计算有限集基数（finset）的例子，即范围 n 与一个比范围 n 移动超过 n 的范围 n 的副本的并集。计算需要证明联合中的两个集合是互斥的；证明的第一行给出了条件
    `Disjoint (range n) (image (fun i ↦ m + i) (range n))`，这个条件在证明的末尾得到证实。`Disjoint`
    谓词过于通用，对我们直接有用，但定理 `disjoint_iff_ne` 将其转换成我们可以使用的形式。
- en: '[PRE66]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Throughout this section, `omega` will be a workhorse for us, for dealing with
    arithmetic calculations and inequalities.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，`omega` 将成为我们的得力助手，用于处理算术计算和不等式。
- en: Here is a more interesting example. Consider the subset of \(\{0, \ldots, n\}
    \times \{0, \ldots, n\}\) consisting of pairs \((i, j)\) such that \(i < j\).
    If you think of these as lattice points in the coordinate plane, they constitute
    an upper triangle of the square with corners \((0, 0)\) and \((n, n)\), not including
    the diagonal. The cardinality of the full square is \((n + 1)^2\), and removing
    the size of the diagonal and halving the result shows us that the cardinality
    of the triangle is \(n (n + 1) / 2\).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个更有趣的例子。考虑由 \(\{0, \ldots, n\} \times \{0, \ldots, n\}\) 的子集组成的对 \((i, j)\)，其中
    \(i < j\)。如果你把它们看作坐标平面上的格点，它们构成了一个以 \((0, 0)\) 和 \((n, n)\) 为顶点的正方形的上三角形，不包括对角线。整个正方形的基数是
    \((n + 1)^2\)，减去对角线的长度并将结果除以二，我们得到三角形的基数是 \(n (n + 1) / 2\)。
- en: Alternatively, we note that the rows of the triangle have sizes \(0, 1, \ldots,
    n\), so the cardinality is the sum of the first \(n\) natural numbers. The first
    `have` of the proof below describes the triangle as the union of the rows, where
    row \(j\) consists of the numbers \(0, 1, ..., j - 1\) paired with \(j\). In the
    proof below, the notation `(., j)` abbreviates the function `fun i ↦ (i, j)`.
    The rest of the proof is just a calculation with finset cardinalities.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们注意到三角形的行的大小是 \(0, 1, \ldots, n\)，因此基数是前 \(n\) 个自然数的和。下面证明中的第一个 `have` 将三角形描述为行的并集，其中行
    \(j\) 由数字 \(0, 1, ..., j - 1\) 与 \(j\) 配对组成。在下面的证明中，符号 `(., j)` 简化了函数 `fun i ↦
    (i, j)`。其余的证明只是对有限集基数进行计算。
- en: '[PRE67]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The following variation on the proof does the calculation with fintypes instead
    of finsets. The type `α ≃ β` is the type of equivalences between `α` and `β`,
    consisting of a map in the forward direction, the map in the backward direction,
    and proofs that these two are inverse to one another. The first `have` in the
    proof shows that `triangle n` is equivalent to the disjoint union of `Fin i` as
    `i` ranges over `Fin (n + 1)`. Interestingly, the forward function and the reverse
    function are constructed with tactics, rather than written explicitly. Since they
    do nothing more than move data and information around, `rfl` establishes that
    they are inverses.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对证明的变体，它使用有限类型（fintype）而不是有限集（finset）进行计算。类型 `α ≃ β` 是 `α` 和 `β` 之间等价类的类型，由正向映射、反向映射以及证明这两个映射是彼此的逆映射组成。证明中的第一个
    `have` 显示 `triangle n` 与 `Fin i` 的不相交并等价，其中 `i` 在 `Fin (n + 1)` 上取值。有趣的是，正向函数和反向函数是用策略构建的，而不是明确写出。由于它们所做的只是移动数据和信息，`rfl`
    证明了它们是逆映射。
- en: After that, `rw [←Fintype.card_coe]` rewrites `#(triangle n)` as the cardinality
    of the subtype `{ x // x ∈ triangle n }`, and the rest of the proof is a calculation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，`rw [←Fintype.card_coe]` 将 `#(triangle n)` 重写为子类型 `{ x // x ∈ triangle n
    }` 的基数，其余的证明都是计算。
- en: '[PRE68]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Here is yet another approach. The first line of the proof below reduces the
    problem to showing `2 * #(triangle n) = (n + 1) * n`. We can do that by showing
    that two copies of the triangle exactly fill the rectangle `range n ×ˢ range (n
    + 1)`. As an exercise, see if you can fill in the steps of the calculation. In
    the solutions, we rely on `omega` extensively in the second-to-last step, but
    we unfortunately have to do a fair amount of work by hand.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '这里还有另一种方法。下面证明的第一行将问题简化为证明 `2 * #(triangle n) = (n + 1) * n`。我们可以通过证明两个三角形的副本正好填满矩形
    `range n ×ˢ range (n + 1)` 来做到这一点。作为一个练习，看看你是否能填补计算步骤。在解决方案中，我们在倒数第二步中广泛地使用了 `omega`，但不幸的是，我们不得不手动做相当多的工作。'
- en: '[PRE69]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: You can convince yourself that we get the same triangle, shifted down, if we
    replace `n` by `n + 1` and replace `<` by `≤` in the definition of `triangle`.
    The exercise below asks you to use this fact to show that the two triangles have
    the same size.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自己验证，如果我们将`n`替换为`n + 1`，并在`triangle`的定义中将`<`替换为`≤`，我们会得到相同的三角形，只是向下移动了。下面的练习要求你使用这个事实来证明两个三角形具有相同的大小。
- en: '[PRE70]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Let us close this section with an example and an exercise from a [tutorial](https://www.youtube.com/watch?v=_cJctOIXWE4&list=PLlF-CfQhukNn7xEbfL38eLgkveyk9_myQ&index=8&t=2737s&ab_channel=leanprovercommunity)
    on combinatorics given by Bhavik Mehta at *Lean for the Curious Mathematician*
    in 2023. Suppose we have a bipartite graph with vertex sets `s` and `t`, such
    that for every `a` in `s`, there are at least three edges leaving `a`, and for
    every `b` in `t`, there is at most one edge entering `b`. Then the total number
    of edges in the graph is at least three times the cardinality of `s` and at most
    the cardinality of `t`, from which is follows that three times the cardinality
    of `s` is at most the cardinality of `t`. The following theorem implements this
    argument, where we use the relation `r` to represent the edges of the graph. The
    proof is an elegant calculation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个例子和一个练习来结束本节，这个例子和练习来自Bhavik Mehta在2023年于*Lean for the Curious Mathematician*上给出的[组合学教程](https://www.youtube.com/watch?v=_cJctOIXWE4&list=PLlF-CfQhukNn7xEbfL38eLgkveyk9_myQ&index=8&t=2737s&ab_channel=leanprovercommunity)。假设我们有一个由顶点集`s`和`t`组成的二分图，对于`s`中的每个`a`，至少有三条边离开`a`，而对于`t`中的每个`b`，最多只有一条边进入`b`。那么图中边的总数至少是`s`的基数的三倍，最多是`t`的基数，由此可以推出`s`的基数的三倍最多是`t`的基数。以下定理实现了这个论证，其中我们使用关系`r`来表示图的边。证明是一个优雅的计算。
- en: '[PRE71]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The following exercise is also taken from Mehta’s tutorial. Suppose `A` is a
    subset of `range (2 * n)` with `n + 1` elements. It’s easy to see that `A` must
    contain two consecutive integers, and hence two elements that are coprime. If
    you watch the tutorial, you will see that a good deal of effort was spent in establishing
    the following fact, which is now proved automatically by `omega`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习也来自Mehta的教程。假设`A`是`range (2 * n)`的子集，包含`n + 1`个元素。很容易看出`A`必须包含两个连续的整数，因此包含两个互质的元素。如果你观看教程，你会看到大量的努力被用于建立以下事实，现在这个事实被`omega`自动证明。
- en: '[PRE72]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The solution to Mehta’s exercise uses the pigeonhole principle, in the form
    `exists_lt_card_fiber_of_mul_lt_card_of_maps_to`, to show that there are two distinct
    elements `m` and `k` in `A` such that `m / 2 = k / 2`. See if you can complete
    the justification of that fact and then use it to finish the proof.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Mehta练习的解决方案使用了鸽巢原理，形式为`exists_lt_card_fiber_of_mul_lt_card_of_maps_to`，来证明在`A`中有两个不同的元素`m`和`k`，使得`m
    / 2 = k / 2`。看看你是否能完成这个事实的证明，然后使用它来完成证明。
- en: '[PRE73]  ## 6.3\. Inductively Defined Types[](#inductively-defined-types "Link
    to this heading")'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE73]  ## 6.3\. 归纳定义的类型[](#inductively-defined-types "链接到本标题")'
- en: Lean’s foundation allows us to define inductive types, that is, data types whose
    instances are generated from the bottom up. For example, the data type `List α`
    of lists of elements of `α` is generated by starting with the empty list, `nil`,
    and successively adding elements to the front the list. Below we will define a
    type of binary trees, `BinTree`, whose elements are generated by starting with
    the empty tree and building new trees by attaching a new node to two existing
    trees.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Lean的基础允许我们定义归纳类型，即从底部向上生成实例的数据类型。例如，由`α`的元素组成的列表数据类型`List α`是通过从空列表`nil`开始，并依次向列表前添加元素来生成的。下面我们将定义一个二叉树类型`BinTree`，其元素是通过从空树开始，并通过将新节点附加到两个现有树来构建新树来生成的。
- en: 'In Lean, one can define inductive types whose objects are infinite, like countably
    branching well-founded trees. Finite inductive definitions are commonly used in
    discrete mathematics, however, especially in those branches of discrete mathematics
    that are relevant to computer science. Lean provides not only the means to define
    such types, but also principles of induction and definition by recursion. For
    example, the data type `List α` is defined inductively:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lean中，可以定义对象无限归纳类型，例如可数分支良基树。在离散数学中，有限归纳定义被广泛使用，尤其是在与计算机科学相关的离散数学分支中。Lean不仅提供了定义此类类型的手段，还提供了归纳和递归定义的原则。例如，数据类型`List
    α`是通过归纳定义的：
- en: '[PRE74]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The inductive definition says that every element of `List α` is either `nil`,
    the empty list, or `cons a as`, where `a` is an element of `α` and `as` is a list
    of elements of `α`. The constructors are properly named `List.nil` and `List.cons`,
    but you can use the shorter notation with the `List` namespace is open. When the
    `List` namespace is *not* open, you can write `.nil` and `.cons a as` anywhere
    that `Lean` expects a list, and Lean will automatically insert the `List` qualifier.
    Throughout this section, we will put temporary definitions in separate namespaces
    like `MyListSpace` to avoid conflicts with the standard library. Outside the temporary
    namespace, we revert to using the standard library definitions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳定义说明`List α`的每个元素要么是`nil`，即空列表，要么是`cons a as`，其中`a`是`α`的一个元素，`as`是`α`元素列表。构造函数被适当地命名为`List.nil`和`List.cons`，但如果你使用`List`命名空间是开放的，你可以使用更短的符号。当`List`命名空间*不是*开放时，你可以在`Lean`期望列表的任何地方写`.nil`和`.cons
    a as`，`Lean`将自动插入`List`限定符。在本节中，我们将临时定义放在单独的命名空间，如`MyListSpace`，以避免与标准库冲突。在临时命名空间之外，我们将恢复使用标准库定义。
- en: 'Lean defines the notation `[]` for `nil` and `::` for `cons`, and you can write
    `[a, b, c]` for `a :: b :: c :: []`. The append and map functions are defined
    recursively as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lean定义了`[]`表示`nil`和`::`表示`cons`的符号，你可以用`[a, b, c]`表示`a :: b :: c :: []`。append和map函数递归地定义为以下：'
- en: '[PRE75]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Notice that there is a base case and a recursive case. In each case, the two
    defining clauses hold definitionally:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里有一个基本情况和一个递归情况。在每种情况下，两个定义子句都定义性地成立：
- en: '[PRE76]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The functions `append` and `map` are defined in the standard library, and `append
    as bs` can be written as `as ++ bs`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`append`和`map`在标准库中定义，`append as bs`可以写成`as ++ bs`。
- en: Lean allows you to write proofs by induction following the structure of the
    definition.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Lean允许你按照定义的结构通过归纳来编写证明。
- en: '[PRE77]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You can also use the `induction'` tactic.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`induction'`策略。
- en: Of course, these theorems are already in the standard library. As an exercise,
    try defining a function `reverse` in the `MyListSpace3` namespace (to avoid conflicting
    with the standard `List.reverse`) that reverses a list. You can use `#eval reverse
    [1, 2, 3, 4, 5]` to test it out. The most straightforward definition of `reverse`
    requires quadratic time, but don’t worry about that. You can jump to the definition
    of `List.reverse` in the standard library to see a linear-time implementation.
    Try proving `reverse (as ++ bs) = reverse bs ++ reverse as` and `reverse (reverse
    as) = as`. You can use `cons_append` and `append_assoc`, but you You may need
    to come up with auxiliary lemmas and prove them.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些定理已经在标准库中。作为一个练习，尝试在`MyListSpace3`命名空间中定义一个函数`reverse`（以避免与标准`List.reverse`冲突），该函数可以反转一个列表。你可以使用`#eval
    reverse [1, 2, 3, 4, 5]`来测试它。`reverse`的最直接定义需要二次时间，但不用担心这一点。你可以跳转到标准库中`List.reverse`的定义，以查看线性时间实现。尝试证明`reverse
    (as ++ bs) = reverse bs ++ reverse as`和`reverse (reverse as) = as`。你可以使用`cons_append`和`append_assoc`，但你可能需要提出辅助引理并证明它们。
- en: '[PRE78]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: For another example, consider the following inductive definition of binary trees
    together with functions to compute the size and depth of a binary tree.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于另一个例子，考虑以下关于二叉树的归纳定义以及计算二叉树大小和深度的函数。
- en: '[PRE79]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: It is convenient to count the empty binary tree as a binary tree of size 0 and
    depth 0. In the literature, this data type is sometimes called the *extended binary
    trees*. Including the empty tree means, for example, that we can define the tree
    `node empty (node empty empty)` consisting of a root node, and empty left subtree,
    and a right subtree consisting of a single node.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将空二叉树视为大小为0、深度为0的二叉树是很方便的。在文献中，这种数据类型有时被称为*扩展二叉树*。包括空树意味着，例如，我们可以定义一个由根节点、空左子树和由单个节点组成的右子树构成的树`node
    empty (node empty empty)`。
- en: 'Here is an important inequality relating the size and the depth:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个重要的不等式，它关联了大小和深度：
- en: '[PRE80]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Try proving the following inequality, which is somewhat easier. Remember, if
    you do a proof by induction as in the previous theorem, you have to delete the
    `:= by`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试证明以下不等式，这相对容易一些。记住，如果你像上一个定理那样进行归纳证明，你必须删除`:= by`。
- en: '[PRE81]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Also define the `flip` operation on binary trees, which recursively swaps the
    left and right subtrees.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 还定义二叉树上的`flip`操作，该操作递归地交换左右子树。
- en: '[PRE82]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: If you did it right, the proof of the following should be rfl.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做得正确，以下证明应该是`rfl`。
- en: '[PRE83]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Prove the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 证明以下内容：
- en: '[PRE84]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We close this section with some formal logic. The following is an inductive
    definition of propositional formulas.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一些形式逻辑结束本节。以下是对命题公式的归纳定义。
- en: '[PRE85]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Every propositional formula is either a variable `var n`, the constant false
    `fls`, or a compound formula of the form `conj A B`, `disj A B`, or `impl A B`.
    With ordinary mathematical notation, these are commonly written \(p_n\), \(\bot\),
    \(A \wedge B\), \(A \vee B\), and \(A \to B\), respectively. The other propositional
    connectives can be defined in terms of these; for example, we can define \(\neg
    A\) as \(A \to \bot\) and \(A \leftrightarrow B\) as \((A \to B) \wedge (B \to
    A)\).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命题公式要么是一个变量 `var n`，要么是常假 `fls`，要么是形式为 `conj A B`、`disj A B` 或 `impl A B`
    的复合公式。使用常规数学符号，这些通常分别写作 \(p_n\)、\(\bot\)、\(A \wedge B\)、\(A \vee B\) 和 \(A \to
    B\)。其他命题连接词可以用这些来定义；例如，我们可以将 \(\neg A\) 定义为 \(A \to \bot\)，将 \(A \leftrightarrow
    B\) 定义为 \((A \to B) \wedge (B \to A)\)。
- en: Having defined the data type of propositional formulas, we define what it means
    to evaluate a propositional formula with respect to an assignment `v` of Boolean
    truth values to the variables.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了命题公式的数据类型后，我们定义了相对于将布尔真值分配给变量的赋值 `v` 来评估命题公式意味着什么。
- en: '[PRE86]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The next definition specifies the set of variables occurring in a formula, and
    the subsequent theorem shows that evaluating a formula on two truth assignments
    that agree on its variables yields that same value.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个定义指定了公式中出现的变量的集合，接下来的定理表明，在两个在变量上达成一致的真值赋值上评估公式会产生相同的值。
- en: '[PRE87]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Noticing the repetition, we can be clever about the use of automation.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到重复，我们可以巧妙地使用自动化。
- en: '[PRE88]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The function `subst A m C` describes the result of substituting the formula
    `C` for every occurrence of the variable `var m` in the formula `A`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `subst A m C` 描述了将公式 `C` 替换为公式 `A` 中每个 `var m` 出现的结果。
- en: '[PRE89]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'As an example, show that substituting for a variable that does not occur in
    a formula has no effect:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，展示替换一个在公式中未出现的变量没有任何影响：
- en: '[PRE90]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The following theorem says something more subtle and interesting: evaluating
    `A.subst n C` on a truth assignment `v` is the same as evaluating `A` on a truth
    assignment that assigns the value of `C` to `var n`. See if you can prove it.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下定理提出了更微妙和有趣的内容：在真值赋值 `v` 上评估 `A.subst n C` 与在将 `C` 的值分配给 `var n` 的真值赋值上评估
    `A` 是相同的。看看你是否能证明它。
- en: '[PRE91]  ## 6.1\. Finsets and Fintypes[](#finsets-and-fintypes "Link to this
    heading")'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE91]  ## 6.1\. Finsets 和 Fintypes[](#finsets-and-fintypes "链接到本标题")'
- en: Dealing with finite sets and types in Mathlib can be confusing, because the
    library offers multiple ways of handling them. In this section we will discuss
    the most common ones.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mathlib 中处理有限集和类型可能会令人困惑，因为该库提供了多种处理它们的方式。在本节中，我们将讨论最常见的方法。
- en: 'We have already come across the type `Finset` in [Section 5.2](C05_Elementary_Number_Theory.html#section-induction-and-recursion)
    and [Section 5.3](C05_Elementary_Number_Theory.html#section-infinitely-many-primes).
    As the name suggests, an element of type `Finset α` is a finite set of elements
    of type `α`. We will call these “finsets.” The `Finset` data type is designed
    to have a computational interpretation, and many basic operations on `Finset α`
    assume that `α` has decidable equality, which guarantees that there is an algorithm
    for testing whether `a : α` is an element of a finset `s`.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '我们已经在 [第 5.2 节](C05_Elementary_Number_Theory.html#section-induction-and-recursion)
    和 [第 5.3 节](C05_Elementary_Number_Theory.html#section-infinitely-many-primes)
    中遇到了类型 `Finset`。正如其名所示，类型 `Finset α` 的元素是类型 `α` 的有限集合。我们将称这些为“有限集”。`Finset` 数据类型旨在具有计算解释，并且
    `Finset α` 上的许多基本操作都假设 `α` 具有可判定的等价性，这保证了存在一个算法来测试 `a : α` 是否是有限集 `s` 的元素。'
- en: '[PRE92]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: If you remove the declaration `[DecidableEq α]`, Lean will complain on the line
    `#check s ∩ t` because it cannot compute the intersection. All of the data types
    that you should expect to be able to compute with have decidable equality, however,
    and if you work classically by opening the `Classical` namespace and declaring
    `noncomputable section`, you can reason about finsets of elements of any type
    at all.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你移除声明 `[DecidableEq α]`，Lean 将在第 `#check s ∩ t` 行上抱怨，因为它无法计算交集。然而，你应该期望能够计算的所有数据类型都具有可判定的等价性，并且如果你通过打开
    `Classical` 命名空间并声明 `noncomputable section` 来进行经典工作，你就可以对任何类型的元素的所有有限集进行推理。
- en: 'Finsets support most of the set-theoretic operations that sets do:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有限集支持大多数集合论操作，这些操作集合也支持：
- en: '[PRE93]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Note that we have opened the `Finset` namespace, where theorems specific to
    finsets are found. If you step through the last example below, you will see applying
    `ext` followed by `simp` reduces the identity to a problem in propositional logic.
    As an exercise, you can try proving some of set identities from [Chapter 4](C04_Sets_and_Functions.html#sets-and-functions),
    transported to finsets.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经打开了 `Finset` 命名空间，其中包含特定于有限集合的定理。如果你浏览下面的最后一个例子，你会看到应用 `ext` 后跟 `simp`
    将恒等式简化为一个命题逻辑问题。作为练习，你可以尝试证明一些来自 [第 4 章](C04_Sets_and_Functions.html#sets-and-functions)
    的集合恒等式，这些恒等式被转移到有限集合中。
- en: 'You have already seen the notation `Finset.range n` for the finite set of natural
    numbers \(\{ 0, 1, \ldots, n-1 \}\). `Finset` also allows you to define finite
    sets by enumerating the elements:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了 `Finset.range n` 的表示法，表示自然数有限集合 \(\{ 0, 1, \ldots, n-1 \}\)。`Finset`
    还允许你通过枚举元素来定义有限集合：
- en: '[PRE94]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: There are various ways to get Lean to recognize that order of elements and duplicates
    do not matter in a set presented in this way.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以让 Lean 识别出在这种方式呈现的集合中元素顺序和重复元素不重要。
- en: '[PRE95]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: You can use `insert` to add a single element to a Finset, and `Finset.erase`
    to delete a single element. Note that `erase` is in the `Finset` namespace, but
    `insert` is in the root namespace.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `insert` 向有限集合添加单个元素，并使用 `Finset.erase` 删除单个元素。请注意，`erase` 在 `Finset`
    命名空间中，而 `insert` 在根命名空间中。
- en: '[PRE96]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: In fact, `{0, 1, 2}` is just notation for `insert 0 (insert 1 (singleton 2))`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`{0, 1, 2}` 只是 `insert 0 (insert 1 (singleton 2))` 的表示法。
- en: '[PRE97]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Given a finset `s` and a predicate `P`, we can use set-builder notation `{x
    ∈ s | P x}` to define the set of elements of `s` that satisfy `P`. This is notation
    for `Finset.filter P s`, which can also be written `s.filter P`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个有限集合 `s` 和一个谓词 `P`，我们可以使用集合构造器符号 `{x ∈ s | P x}` 来定义满足 `P` 的 `s` 的元素集合。这是
    `Finset.filter P s` 的表示法，也可以写成 `s.filter P`。
- en: '[PRE98]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Mathlib knows that the image of a finset under a function is a finset.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib 知道在函数下的有限集合的像是有限集合。
- en: '[PRE99]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Lean also knows that the cartesian product `s ×ˢ t` of two finsets is a finset,
    and that the powerset of a finset is a finset. (Note that the notation `s ×ˢ t`
    also works for sets.)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 还知道，两个有限集合的笛卡尔积 `s ×ˢ t` 也是一个有限集合，并且有限集合的幂集也是一个有限集合。（注意，符号 `s ×ˢ t` 也可以用于集合。）
- en: '[PRE100]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Defining operations on finsets in terms of their elements is tricky, because
    any such definition has to be independent of the order in which the elements are
    presented. Of course, you can always define functions by composing existing operations.
    Another thing you can do is use `Finset.fold` to fold a binary operation over
    the elements, provided that the operation is associative and commutative, since
    these properties guarantee that the result is independent of the order that the
    operation is applied. Finite sums, products, and unions are defined in that way.
    In the last example below, `biUnion` stands for “bounded indexed union.” With
    conventional mathematical notation, the expression would be written \(\bigcup_{i
    ∈ s} g(i)\).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在有限集合的元素上定义操作是棘手的，因为任何这样的定义都必须独立于元素呈现的顺序。当然，你可以通过组合现有操作来定义函数。你还可以使用 `Finset.fold`
    对元素应用二元运算，前提是该运算是结合的和交换的，因为这些性质保证了结果与运算应用顺序无关。有限和、积和并集就是这样定义的。在下面的最后一个例子中，`biUnion`
    代表“有界索引并”。用传统的数学符号，该表达式将被写成 \(\bigcup_{i ∈ s} g(i)\)。
- en: '[PRE101]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'There is a natural principle of induction on finsets: to prove that every finset
    has a property, show that the empty set has the property and that the property
    is preserved when we add one new element to a finset. (The `@` symbol in `@insert`
    is needed in the induction step of the next example to give names to the parameters
    `a` and `s` because they have been marked implicit. )'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有限集合的归纳原理是自然的：要证明每个有限集合都具有某个属性，需要证明空集具有该属性，并且当我们向有限集合添加一个新元素时，该属性得到保持。（在 `@insert`
    的下一个例子的归纳步骤中，`@` 符号是必需的，因为它为参数 `a` 和 `s` 提供了名称，因为它们已被标记为隐式。）
- en: '[PRE102]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: If `s` is a finset, `Finset.Nonempty s` is defined to be `∃ x, x ∈ s`. You can
    use classical choice to pick an element of a nonempty finset. Similarly, the library
    defines `Finset.toList s` which uses choice to pick the elements of `s` in some
    order.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `s` 是一个有限集合，则 `Finset.Nonempty s` 被定义为 `∃ x, x ∈ s`。你可以使用经典选择来选择一个非空有限集合的元素。同样，库定义了
    `Finset.toList s`，它使用选择以某种顺序选择 `s` 的元素。
- en: '[PRE103]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: You can use `Finset.min` and `Finset.max` to choose the minimum or maximum element
    of a finset of elements of a linear order, and similarly you can use `Finset.inf`
    and `Finset.sup` with finsets of elements of a lattice, but there is a catch.
    What should the minimum element of an empty finset be? You can check that the
    primed versions of the functions below add a precondition that the finset is nonempty.
    The non-primed versions `Finset.min` and `Finset.max` add a top or bottom element,
    respectively, to the output type, to handle the case where the finset is empty.
    The non-primed versions `Finset.inf` and `Finset.sup` assume that the lattice
    comes equipped with a top or bottom element, respectively.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`Finset.min`和`Finset.max`来选择线性顺序元素的有限集的最小或最大元素，同样你也可以使用`Finset.inf`和`Finset.sup`与格元素的有限集，但有一个问题。空有限集的最小元素应该是什么？你可以检查以下函数的带撇版本添加了一个先决条件，即有限集非空。不带撇版本的`Finset.min`和`Finset.max`分别向输出类型添加一个上界或下界元素，以处理有限集为空的情况。不带撇版本的`Finset.inf`和`Finset.sup`假设格已经配备了上界或下界元素。
- en: '[PRE104]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Every finset `s` has a finite cardinality, `Finset.card s`, which can be written
    `#s` when the `Finset` namespace is open.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 每个有限集`s`都有一个有限的基数，`Finset.card s`，当`Finset`命名空间打开时，可以写成`#s`。
- en: '[PRE105]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The next section is all about reasoning about cardinality.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节全部关于推理基数。
- en: When formalizing mathematics, one often has to make a decision as to whether
    to express one’s definitions and theorems in terms of sets or types. Using types
    often simplifies notation and proofs, but working with subsets of a type can be
    more flexible. The type-based analogue of a finset is a *fintype*, that is, a
    type `Fintype α` for some `α`. By definition, a fintype is just a data type that
    comes equipped with a finset `univ` that contains all its elements.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在形式化数学时，人们常常需要决定是否用集合或类型来表述自己的定义和定理。使用类型通常可以简化符号和证明，但处理类型的子集可能更加灵活。基于类型的有限集（finset）的类似物是**fintype**，即某个`α`的`Fintype
    α`类型。根据定义，fintype仅仅是一个带有包含所有元素的有限集`univ`的数据类型。
- en: '[PRE106]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '`Fintype.card α` is equal to the cardinality of the corresponding finset.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fintype.card α`等于相应有限集的基数。'
- en: '[PRE107]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: We have already seen a prototypical example of a fintype, namely, the types
    `Fin n` for each `n`. Lean recognizes that the fintypes are closed under operations
    like the product operation.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一个fintype的原型示例，即每个`n`的`Fin n`类型。Lean认识到fintype在乘积运算等操作下是封闭的。
- en: '[PRE108]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Any element `s` of `Finset α` can be coercied to a type `(↑s : Finset α)`,
    namely, the subtype of elements of `α` that are contained in `s`.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`Finset α`的任何元素`s`都可以强制转换为类型`(↑s : Finset α)`，即包含在`s`中的`α`的元素的子类型。'
- en: '[PRE109]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Lean and Mathlib use *type class inference* to track the additional structure
    on fintypes, namely, the universal finset that contains all the elements. In other
    words, you can think of a fintype as an algebraic structure equipped with that
    extra data. [Chapter 7](C07_Structures.html#structures) explains how this works.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Lean和Mathlib使用**类型类推断**来跟踪fintype上的附加结构，即包含所有元素的通用有限集。换句话说，你可以将fintype视为一个带有额外数据的代数结构。[第7章](C07_Structures.html#structures)解释了这是如何工作的。
- en: '## 6.2\. Counting Arguments[](#counting-arguments "Link to this heading")'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '## 6.2\. 计数论证[](#counting-arguments "链接到本标题")'
- en: 'The art of counting things is a central part of combinatorics. Mathlib contains
    several basic identities for counting elements of finsets:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 计数事物的艺术是组合学的核心部分。Mathlib包含几个用于计数有限集元素的基数的基本恒等式：
- en: '[PRE110]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Opening the `Finset` namespace allows us to use the notation `#s` for `s.card`,
    as well as to use the shortened names card_union and so on.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Finset`命名空间允许我们使用`#s`表示`s.card`，以及使用缩短的名称如card_union等。
- en: 'Mathlib can also count elements of fintypes:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib也可以计数fintype的元素：
- en: '[PRE111]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: When the `Fintype` namespace is not open, we have to use `Fintype.card` instead
    of card.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Fintype`命名空间未打开时，我们必须使用`Fintype.card`而不是card。
- en: The following is an example of calculating the cardinality of a finset, namely,
    the union of range n with a copy of range n that has been shifted by more than
    n. The calculation requires showing the the two sets in the union are disjoint;
    the first line of the proof yields the side condition `Disjoint (range n) (image
    (fun i ↦ m + i) (range n))`, which is established at the end of the proof. The
    `Disjoint` predicate is too general to be directly useful to us, but the theorem
    `disjoint_iff_ne` puts it in a form we can use.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个计算有限集合（finset）基数（即n范围与n范围的副本的并集，该副本已通过n进行偏移）的例子。计算需要证明并集中的两个集合是互斥的；证明的第一行产生了侧条件`Disjoint
    (range n) (image (fun i ↦ m + i) (range n))`，该条件在证明的末尾得到证实。`Disjoint`谓词过于通用，对我们直接有用，但定理`disjoint_iff_ne`将其置于我们可以使用的形式。
- en: '[PRE112]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Throughout this section, `omega` will be a workhorse for us, for dealing with
    arithmetic calculations and inequalities.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，`omega`将是我们处理算术计算和不等式的工作马。
- en: Here is a more interesting example. Consider the subset of \(\{0, \ldots, n\}
    \times \{0, \ldots, n\}\) consisting of pairs \((i, j)\) such that \(i < j\).
    If you think of these as lattice points in the coordinate plane, they constitute
    an upper triangle of the square with corners \((0, 0)\) and \((n, n)\), not including
    the diagonal. The cardinality of the full square is \((n + 1)^2\), and removing
    the size of the diagonal and halving the result shows us that the cardinality
    of the triangle is \(n (n + 1) / 2\).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个更有趣的例子。考虑由\(\{0, \ldots, n\} \times \{0, \ldots, n\}\)组成的子集，其中包含满足\(i <
    j\)的成对\((i, j)\)。如果你把它们看作坐标平面中的格点，它们构成了一个以\((0, 0)\)和\((n, n)\)为顶点的正方形上方的三角形，不包括对角线。整个正方形的基数为\((n
    + 1)^2\)，减去对角线的大小并将结果除以二，我们得到三角形的基数为\(n (n + 1) / 2\)。
- en: Alternatively, we note that the rows of the triangle have sizes \(0, 1, \ldots,
    n\), so the cardinality is the sum of the first \(n\) natural numbers. The first
    `have` of the proof below describes the triangle as the union of the rows, where
    row \(j\) consists of the numbers \(0, 1, ..., j - 1\) paired with \(j\). In the
    proof below, the notation `(., j)` abbreviates the function `fun i ↦ (i, j)`.
    The rest of the proof is just a calculation with finset cardinalities.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们注意到三角形的行的大小为\(0, 1, \ldots, n\)，因此基数是前\(n\)个自然数的和。下面证明的第一个`have`描述了三角形作为行的并集，其中行\(j\)由数字\(0,
    1, ..., j - 1\)与\(j\)配对组成。在下面的证明中，符号`(., j)`是函数`fun i ↦ (i, j)`的缩写。其余的证明只是对有限集合基数进行计算。
- en: '[PRE113]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The following variation on the proof does the calculation with fintypes instead
    of finsets. The type `α ≃ β` is the type of equivalences between `α` and `β`,
    consisting of a map in the forward direction, the map in the backward direction,
    and proofs that these two are inverse to one another. The first `have` in the
    proof shows that `triangle n` is equivalent to the disjoint union of `Fin i` as
    `i` ranges over `Fin (n + 1)`. Interestingly, the forward function and the reverse
    function are constructed with tactics, rather than written explicitly. Since they
    do nothing more than move data and information around, `rfl` establishes that
    they are inverses.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对证明的变体，它使用有限类型（fintype）而不是有限集合（finset）进行计算。类型`α ≃ β`是`α`和`β`之间等价类的类型，由正向映射、反向映射以及证明这两个映射互为逆映射组成。证明中的第一个`have`表明`triangle
    n`与`Fin i`的并集等价，其中`i`在`Fin (n + 1)`范围内。有趣的是，正向函数和反向函数是用策略构建的，而不是明确写出。由于它们所做的只是移动数据和信息，`rfl`建立了它们是逆映射。
- en: After that, `rw [←Fintype.card_coe]` rewrites `#(triangle n)` as the cardinality
    of the subtype `{ x // x ∈ triangle n }`, and the rest of the proof is a calculation.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，`rw [←Fintype.card_coe]`将`#(triangle n)`重写为子类型`{ x // x ∈ triangle n }`的基数，其余的证明是一个计算过程。
- en: '[PRE114]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Here is yet another approach. The first line of the proof below reduces the
    problem to showing `2 * #(triangle n) = (n + 1) * n`. We can do that by showing
    that two copies of the triangle exactly fill the rectangle `range n ×ˢ range (n
    + 1)`. As an exercise, see if you can fill in the steps of the calculation. In
    the solutions, we rely on `omega` extensively in the second-to-last step, but
    we unfortunately have to do a fair amount of work by hand.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '这里还有另一种方法。下面证明的第一行将问题简化为证明`2 * #(triangle n) = (n + 1) * n`。我们可以通过证明三角形的两个副本正好填满矩形`range
    n ×ˢ range (n + 1)`来实现这一点。作为一个练习，看看你是否能填补计算步骤。在解决方案中，我们在倒数第二步中广泛使用`omega`，但不幸的是，我们必须手动做相当多的工作。'
- en: '[PRE115]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: You can convince yourself that we get the same triangle, shifted down, if we
    replace `n` by `n + 1` and replace `<` by `≤` in the definition of `triangle`.
    The exercise below asks you to use this fact to show that the two triangles have
    the same size.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自己验证，如果我们将 `n` 替换为 `n + 1` 并在 `triangle` 的定义中将 `<` 替换为 `≤`，我们会得到相同的三角形，只是向下移动了。下面的练习要求你使用这个事实来证明两个三角形具有相同的大小。
- en: '[PRE116]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Let us close this section with an example and an exercise from a [tutorial](https://www.youtube.com/watch?v=_cJctOIXWE4&list=PLlF-CfQhukNn7xEbfL38eLgkveyk9_myQ&index=8&t=2737s&ab_channel=leanprovercommunity)
    on combinatorics given by Bhavik Mehta at *Lean for the Curious Mathematician*
    in 2023. Suppose we have a bipartite graph with vertex sets `s` and `t`, such
    that for every `a` in `s`, there are at least three edges leaving `a`, and for
    every `b` in `t`, there is at most one edge entering `b`. Then the total number
    of edges in the graph is at least three times the cardinality of `s` and at most
    the cardinality of `t`, from which is follows that three times the cardinality
    of `s` is at most the cardinality of `t`. The following theorem implements this
    argument, where we use the relation `r` to represent the edges of the graph. The
    proof is an elegant calculation.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个例子和一个练习来结束本节，这个例子和练习来自 Bhavik Mehta 在 2023 年于 *Lean for the Curious Mathematician*
    上提供的组合学教程[教程](https://www.youtube.com/watch?v=_cJctOIXWE4&list=PLlF-CfQhukNn7xEbfL38eLgkveyk9_myQ&index=8&t=2737s&ab_channel=leanprovercommunity)。假设我们有一个二分图，其顶点集为
    `s` 和 `t`，对于 `s` 中的每个 `a`，至少有三条边离开 `a`，而对于 `t` 中的每个 `b`，最多只有一条边进入 `b`。那么图中边的总数至少是
    `s` 的三倍，最多是 `t` 的数量，从而得出三倍的 `s` 的数量最多是 `t` 的数量。以下定理实现了这个论证，其中我们使用关系 `r` 来表示图的边。证明是一个优雅的计算。
- en: '[PRE117]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The following exercise is also taken from Mehta’s tutorial. Suppose `A` is a
    subset of `range (2 * n)` with `n + 1` elements. It’s easy to see that `A` must
    contain two consecutive integers, and hence two elements that are coprime. If
    you watch the tutorial, you will see that a good deal of effort was spent in establishing
    the following fact, which is now proved automatically by `omega`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习也来自 Mehta 的教程。假设 `A` 是 `range (2 * n)` 的一个子集，包含 `n + 1` 个元素。很容易看出 `A` 必须包含两个连续的整数，因此包含两个互质的元素。如果你观看教程，你会看到在建立以下事实上花费了大量精力，现在这个事实由
    `omega` 自动证明。这个事实是，`A` 必须包含两个连续的整数，因此包含两个互质的元素。
- en: '[PRE118]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The solution to Mehta’s exercise uses the pigeonhole principle, in the form
    `exists_lt_card_fiber_of_mul_lt_card_of_maps_to`, to show that there are two distinct
    elements `m` and `k` in `A` such that `m / 2 = k / 2`. See if you can complete
    the justification of that fact and then use it to finish the proof.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Mehta 练习的解决方案使用了鸽巢原理，形式为 `exists_lt_card_fiber_of_mul_lt_card_of_maps_to`，来证明在
    `A` 中存在两个不同的元素 `m` 和 `k`，使得 `m / 2 = k / 2`。看看你是否能完成这个事实的证明，然后使用它来完成证明。
- en: '[PRE119]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '## 6.3\. Inductively Defined Types[](#inductively-defined-types "Link to this
    heading")'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '## 6.3. 递归定义的类型[](#inductively-defined-types "链接到本标题")'
- en: Lean’s foundation allows us to define inductive types, that is, data types whose
    instances are generated from the bottom up. For example, the data type `List α`
    of lists of elements of `α` is generated by starting with the empty list, `nil`,
    and successively adding elements to the front the list. Below we will define a
    type of binary trees, `BinTree`, whose elements are generated by starting with
    the empty tree and building new trees by attaching a new node to two existing
    trees.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 的基础允许我们定义递归类型，即从底部向上生成实例的数据类型。例如，由 `α` 的元素组成的列表数据类型 `List α` 是从空列表 `nil`
    开始，并依次向列表前添加元素生成的。下面我们将定义一个二叉树类型 `BinTree`，其元素是从空树开始，通过将新节点附加到两个现有树来构建新树。
- en: 'In Lean, one can define inductive types whose objects are infinite, like countably
    branching well-founded trees. Finite inductive definitions are commonly used in
    discrete mathematics, however, especially in those branches of discrete mathematics
    that are relevant to computer science. Lean provides not only the means to define
    such types, but also principles of induction and definition by recursion. For
    example, the data type `List α` is defined inductively:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lean 中，可以定义对象无限递归类型，例如可数分支良好基础树。在离散数学中，有限递归定义通常被使用，尤其是在与计算机科学相关的离散数学分支中。Lean
    不仅提供了定义此类类型的手段，还提供了归纳原理和递归定义的原则。例如，数据类型 `List α` 是通过归纳定义的：
- en: '[PRE120]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The inductive definition says that every element of `List α` is either `nil`,
    the empty list, or `cons a as`, where `a` is an element of `α` and `as` is a list
    of elements of `α`. The constructors are properly named `List.nil` and `List.cons`,
    but you can use the shorter notation with the `List` namespace is open. When the
    `List` namespace is *not* open, you can write `.nil` and `.cons a as` anywhere
    that `Lean` expects a list, and Lean will automatically insert the `List` qualifier.
    Throughout this section, we will put temporary definitions in separate namespaces
    like `MyListSpace` to avoid conflicts with the standard library. Outside the temporary
    namespace, we revert to using the standard library definitions.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳定义说明 `List α` 的每个元素要么是 `nil`，即空列表，要么是 `cons a as`，其中 `a` 是 `α` 的一个元素，`as`
    是 `α` 元素列表。构造函数被适当地命名为 `List.nil` 和 `List.cons`，但如果你在 `List` 命名空间是开放的，你可以使用简短的表示法。当
    `List` 命名空间不是开放的，你可以在 Lean 需要列表的地方写 `.nil` 和 `.cons a as`，Lean 会自动插入 `List` 限定符。在本节中，我们将临时定义放在单独的命名空间中，如
    `MyListSpace`，以避免与标准库冲突。在临时命名空间之外，我们将恢复使用标准库定义。
- en: 'Lean defines the notation `[]` for `nil` and `::` for `cons`, and you can write
    `[a, b, c]` for `a :: b :: c :: []`. The append and map functions are defined
    recursively as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lean 定义了 `[]` 符号表示 `nil` 和 `::` 符号表示 `cons`，你可以用 `[a, b, c]` 来表示 `a :: b ::
    c :: []`。`append` 和 `map` 函数被递归地定义为如下：'
- en: '[PRE121]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Notice that there is a base case and a recursive case. In each case, the two
    defining clauses hold definitionally:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里有一个基本情况和一个递归情况。在每种情况下，两个定义子句都是定义上成立的：
- en: '[PRE122]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The functions `append` and `map` are defined in the standard library, and `append
    as bs` can be written as `as ++ bs`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`append` 和 `map` 函数定义在标准库中，`append as bs` 可以写成 `as ++ bs`。'
- en: Lean allows you to write proofs by induction following the structure of the
    definition.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 允许你按照定义的结构来编写归纳证明。
- en: '[PRE123]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: You can also use the `induction'` tactic.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `induction'` 策略。
- en: Of course, these theorems are already in the standard library. As an exercise,
    try defining a function `reverse` in the `MyListSpace3` namespace (to avoid conflicting
    with the standard `List.reverse`) that reverses a list. You can use `#eval reverse
    [1, 2, 3, 4, 5]` to test it out. The most straightforward definition of `reverse`
    requires quadratic time, but don’t worry about that. You can jump to the definition
    of `List.reverse` in the standard library to see a linear-time implementation.
    Try proving `reverse (as ++ bs) = reverse bs ++ reverse as` and `reverse (reverse
    as) = as`. You can use `cons_append` and `append_assoc`, but you You may need
    to come up with auxiliary lemmas and prove them.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些定理已经包含在标准库中。作为一个练习，尝试在 `MyListSpace3` 命名空间中定义一个 `reverse` 函数（以避免与标准库中的
    `List.reverse` 冲突），该函数可以反转一个列表。你可以使用 `#eval reverse [1, 2, 3, 4, 5]` 来测试它。`reverse`
    的最直接定义需要二次时间复杂度，但不用担心这一点。你可以跳转到标准库中 `List.reverse` 的定义，以查看线性时间复杂度的实现。尝试证明 `reverse
    (as ++ bs) = reverse bs ++ reverse as` 和 `reverse (reverse as) = as`。你可以使用 `cons_append`
    和 `append_assoc`，但你可能需要提出辅助引理并证明它们。
- en: '[PRE124]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: For another example, consider the following inductive definition of binary trees
    together with functions to compute the size and depth of a binary tree.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，考虑以下二叉树的归纳定义及其计算二叉树大小和深度的函数。
- en: '[PRE125]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: It is convenient to count the empty binary tree as a binary tree of size 0 and
    depth 0. In the literature, this data type is sometimes called the *extended binary
    trees*. Including the empty tree means, for example, that we can define the tree
    `node empty (node empty empty)` consisting of a root node, and empty left subtree,
    and a right subtree consisting of a single node.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 计算空二叉树的大小为 0 和深度为 0 是方便的。在文献中，这种数据类型有时被称为 *扩展二叉树*。包括空树意味着，例如，我们可以定义由根节点、空左子树和由单个节点组成的右子树构成的树
    `node empty (node empty empty)`。
- en: 'Here is an important inequality relating the size and the depth:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个重要的关于大小和深度的不等式：
- en: '[PRE126]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Try proving the following inequality, which is somewhat easier. Remember, if
    you do a proof by induction as in the previous theorem, you have to delete the
    `:= by`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试证明以下不等式，这相对容易一些。记住，如果你像上一个定理那样进行归纳证明，你必须删除 `:= by`。
- en: '[PRE127]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Also define the `flip` operation on binary trees, which recursively swaps the
    left and right subtrees.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 还定义了二叉树上的 `flip` 操作，该操作递归地交换左右子树。
- en: '[PRE128]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: If you did it right, the proof of the following should be rfl.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做得正确，以下证明应该是 rfl。
- en: '[PRE129]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Prove the following:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 证明以下：
- en: '[PRE130]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: We close this section with some formal logic. The following is an inductive
    definition of propositional formulas.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一些形式逻辑结束本节。以下是对命题公式的归纳定义。
- en: '[PRE131]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Every propositional formula is either a variable `var n`, the constant false
    `fls`, or a compound formula of the form `conj A B`, `disj A B`, or `impl A B`.
    With ordinary mathematical notation, these are commonly written \(p_n\), \(\bot\),
    \(A \wedge B\), \(A \vee B\), and \(A \to B\), respectively. The other propositional
    connectives can be defined in terms of these; for example, we can define \(\neg
    A\) as \(A \to \bot\) and \(A \leftrightarrow B\) as \((A \to B) \wedge (B \to
    A)\).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命题公式要么是一个变量 `var n`，要么是常假 `fls`，要么是形式为 `conj A B`、`disj A B` 或 `impl A B`
    的复合公式。用常规数学符号，这些通常分别写成 \(p_n\)、\(\bot\)、\(A \wedge B\)、\(A \vee B\) 和 \(A \to
    B\)。其他命题连接词可以用这些来定义；例如，我们可以将 \(\neg A\) 定义为 \(A \to \bot\)，将 \(A \leftrightarrow
    B\) 定义为 \((A \to B) \wedge (B \to A)\)。
- en: Having defined the data type of propositional formulas, we define what it means
    to evaluate a propositional formula with respect to an assignment `v` of Boolean
    truth values to the variables.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了命题公式的数据类型后，我们定义了相对于将布尔真值赋给变量的赋值 `v` 评估命题公式意味着什么。
- en: '[PRE132]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The next definition specifies the set of variables occurring in a formula, and
    the subsequent theorem shows that evaluating a formula on two truth assignments
    that agree on its variables yields that same value.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个定义指定了公式中出现的变量集合，接下来的定理表明，在两个在变量上达成一致的真值赋值上评估公式会产生相同的值。
- en: '[PRE133]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Noticing the repetition, we can be clever about the use of automation.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到重复，我们可以巧妙地使用自动化。
- en: '[PRE134]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: The function `subst A m C` describes the result of substituting the formula
    `C` for every occurrence of the variable `var m` in the formula `A`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `subst A m C` 描述了将公式 `C` 替换到公式 `A` 中每个 `var m` 出现的结果。
- en: '[PRE135]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'As an example, show that substituting for a variable that does not occur in
    a formula has no effect:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，展示替换一个在公式中未出现的变量没有任何效果：
- en: '[PRE136]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The following theorem says something more subtle and interesting: evaluating
    `A.subst n C` on a truth assignment `v` is the same as evaluating `A` on a truth
    assignment that assigns the value of `C` to `var n`. See if you can prove it.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 以下定理提出了更微妙和有趣的观点：在真值赋值 `v` 上评估 `A.subst n C` 与在将 `C` 的值赋给变量 `var n` 的真值赋值上评估
    `A` 是相同的。看看你是否能证明它。
- en: '[PRE137]*'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE137]*'
