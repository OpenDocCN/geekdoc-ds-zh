- en: Binary Exponentiation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制指数运算
- en: 原文：[https://en.algorithmica.org/hpc/number-theory/exponentiation/](https://en.algorithmica.org/hpc/number-theory/exponentiation/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/number-theory/exponentiation/](https://en.algorithmica.org/hpc/number-theory/exponentiation/)
- en: In modular arithmetic (and computational algebra in general), you often need
    to raise a number to the $n$-th power — to do [modular division](../modular/#modular-division),
    perform [primality tests](../modular/#fermats-theorem), or compute some combinatorial
    values — ­and you usually want to spend fewer than $\Theta(n)$ operations calculating
    it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在模运算（以及计算代数的一般情况）中，你经常需要将一个数提高到 $n$ 次幂——为了进行[模除法](../modular/#modular-division)，执行[素性测试](../modular/#fermats-theorem)，或者计算某些组合值——而你通常希望花费少于
    $\Theta(n)$ 次操作来计算它。
- en: '*Binary exponentiation*, also known as *exponentiation by squaring*, is a method
    that allows for computation of the $n$-th power using $O(\log n)$ multiplications,
    relying on the following observation:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*二进制指数运算*，也称为*平方根指数运算*，是一种允许使用 $O(\log n)$ 次乘法来计算 $n$ 次幂的方法，依赖于以下观察：'
- en: '$$ \begin{aligned} a^{2k} &= (a^k)^2 \\ a^{2k + 1} &= (a^k)^2 \cdot a \end{aligned}
    $$ To compute $a^n$, we can recursively compute $a^{\lfloor n / 2 \rfloor}$, square
    it, and then optionally multiply by $a$ if $n$ is odd, corresponding to the following
    recurrence: $$ a^n = f(a, n) = \begin{cases} 1, && n = 0 \\ f(a, \frac{n}{2})^2,
    && 2 \mid n \\ f(a, n - 1) \cdot a, && 2 \nmid n \end{cases} $$'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: $$ \begin{aligned} a^{2k} &= (a^k)^2 \\ a^{2k + 1} &= (a^k)^2 \cdot a \end{aligned}
    $$ 为了计算 $a^n$，我们可以递归地计算 $a^{\lfloor n / 2 \rfloor}$，然后平方它，如果 $n$ 是奇数，则可选地乘以 $a$，对应以下递归：$$
    a^n = f(a, n) = \begin{cases} 1, && n = 0 \\ f(a, \frac{n}{2})^2, && 2 \mid n
    \\ f(a, n - 1) \cdot a, && 2 \nmid n \end{cases} $$
- en: Since $n$ is at least halved every two recursive transitions, the depth of this
    recurrence and the total number of multiplications will be at most $O(\log n)$.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 $n$ 在每次递归转换中至少减半，这个递归的深度和总乘法次数将最多为 $O(\log n)$。
- en: '### [#](https://en.algorithmica.org/hpc/number-theory/exponentiation/#recursive-implementation)Recursive
    Implementation'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/number-theory/exponentiation/#recursive-implementation)递归实现'
- en: 'As we already have a recurrence, it is natural to implement the algorithm as
    a case matching recursive function:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有了一个递归，很自然地，我们将算法实现为一个匹配情况的递归函数：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In our benchmark, we use $n = m - 2$ so that we compute the [multiplicative
    inverse](../modular/#modular-division) of $a$ modulo $m$:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的基准测试中，我们使用 $n = m - 2$，这样我们就可以计算 $a$ 模 $m$ 的[乘法逆元](../modular/#modular-division)：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We use $m = 10^9+7$, which is a modulo value commonly used in competitive programming
    to calculate checksums in combinatorial problems — because it is prime (allowing
    inverse via binary exponentiation), sufficiently large, not overflowing `int`
    in addition, not overflowing `long long` in multiplication, and easy to type as
    `1e9 + 7`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 $m = 10^9+7$，这是一个在组合问题中计算校验和常用的模值，用于竞技编程——因为它是一个质数（允许通过二进制指数运算进行逆运算），足够大，不会在加法中溢出
    `int`，不会在乘法中溢出 `long long`，并且容易输入为 `1e9 + 7`。
- en: Since we use it as compile-time constant in the code, the compiler can optimize
    the modulo by [replacing it with multiplication](/hpc/arithmetic/division/) (even
    if it is not a compile-time constant, it is still cheaper to compute the magic
    constants by hand once and use them for fast reduction).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在代码中将它用作编译时常数，编译器可以优化模运算，通过[将其替换为乘法](/hpc/arithmetic/division/)（即使它不是编译时常数，通过手动计算一次魔法常数并用于快速化简仍然更便宜）。
- en: The execution path — and consequently the running time — depends on the value
    of $n$. For this particular $n$, the baseline implementation takes around 330ns
    per call. As recursion introduces some [overhead](/hpc/architecture/functions/),
    it makes sense to unroll the implementation into an iterative procedure.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 执行路径——以及因此的运行时间——取决于 $n$ 的值。对于这个特定的 $n$，基线实现每次调用大约需要 330 纳秒。由于递归引入了一些[开销](/hpc/architecture/functions/)，将其实现展开为迭代过程是有意义的。
- en: '### [#](https://en.algorithmica.org/hpc/number-theory/exponentiation/#iterative-implementation)Iterative
    Implementation'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/number-theory/exponentiation/#iterative-implementation)迭代实现'
- en: The result of $a^n$ can be represented as the product of $a$ to some powers
    of two — those that correspond to 1s in the binary representation of $n$. For
    example, if $n = 42 = 32 + 8 + 2$, then
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: $a^n$ 的结果可以表示为 $a$ 的某些2的幂的乘积——那些对应于 $n$ 的二进制表示中的1的幂。例如，如果 $n = 42 = 32 + 8 +
    2$，那么
- en: $$ a^{42} = a^{32+8+2} = a^{32} \cdot a^8 \cdot a^2 $$
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: $$ a^{42} = a^{32+8+2} = a^{32} \cdot a^8 \cdot a^2 $$
- en: 'To calculate this product, we can iterate over the bits of $n$ maintaining
    two variables: the value of $a^{2^k}$ and the current product after considering
    $k$ lowest bits of $n$. On each step, we multiply the current product by $a^{2^k}$
    if the $k$-th bit of $n$ is set, and, in either case, square $a^k$ to get $a^{2^k
    \cdot 2} = a^{2^{k+1}}$ that will be used on the next iteration.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算这个乘积，我们可以遍历$n$的位，同时维护两个变量：$a^{2^k}$的值和考虑$n$的$k$个最低位后的当前乘积。在每一步中，如果$n$的第$k$位被设置，则将当前乘积乘以$a^{2^k}$，并且在任何情况下，将$a^k$平方以得到$a^{2^k
    \cdot 2} = a^{2^{k+1}}$，这将用于下一次迭代。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The iterative implementation takes about 180ns per call. The heavy calculations
    are the same; the improvement mainly comes from the reduced dependency chain:
    `a = a * a % M` needs to finish before the loop can proceed, and it can now execute
    concurrently with `r = res * a % M`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代实现的每次调用大约需要180纳秒。繁重的计算保持不变；改进主要来自于减少的依赖链：`a = a * a % M`需要在循环继续之前完成，而现在它可以与`r
    = res * a % M`并发执行。
- en: 'The performance also benefits from $n$ being a constant, [making all branches
    predictable](/hpc/pipelining/branching/) and letting the scheduler know what needs
    to be executed in advance. The compiler, however, does not take advantage of it
    and does not unroll the `while(n) n >>= 1` loop. We can rewrite it as a `for`
    loop that performs constant 30 iterations:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 性能还受益于$n$是一个常数，[使得所有分支可预测](/hpc/pipelining/branching/)，并让调度器提前知道需要执行什么。然而，编译器并没有利用这一点，也没有展开`while(n)
    n >>= 1`循环。我们可以将其重写为一个执行30次常量迭代的`for`循环：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This forces the compiler to generate only the instructions we need, shaving
    off another 10ns and making the total running time ~170ns.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这迫使编译器只生成我们需要的指令，从而再节省10纳秒，使总运行时间约为170纳秒。
- en: Note that the performance depends not only on the binary length of $n$, but
    also on the number of binary 1s. If $n$ is $2^{30}$, it takes around 20ns less
    as we don’t have to to perform any off-path multiplications. [← Modular Arithmetic](https://en.algorithmica.org/hpc/number-theory/modular/)[Extended
    Euclidean Algorithm →](https://en.algorithmica.org/hpc/number-theory/euclid-extended/)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，性能不仅取决于$n$的二进制长度，还取决于二进制中1的数量。如果$n$是$2^{30}$，由于我们不需要执行任何旁路乘法，所以大约可以节省20纳秒。[←模运算](https://en.algorithmica.org/hpc/number-theory/modular/)[扩展欧几里得算法→](https://en.algorithmica.org/hpc/number-theory/euclid-extended/)
