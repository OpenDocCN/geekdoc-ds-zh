- en: Search Trees
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索树
- en: 原文：[https://en.algorithmica.org/hpc/data-structures/b-tree/](https://en.algorithmica.org/hpc/data-structures/b-tree/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/data-structures/b-tree/](https://en.algorithmica.org/hpc/data-structures/b-tree/)
- en: In the [previous article](../s-tree), we designed and implemented *static* B-trees
    to speed up binary searching in sorted arrays. In its [last section](../s-tree/#as-a-dynamic-tree),
    we briefly discussed how to make them *dynamic* back while retaining the performance
    gains from [SIMD](/hpc/simd) and validated our predictions by adding and following
    explicit pointers in the internal nodes of the S+ tree.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[上一篇文章](../s-tree)中，我们设计和实现了*静态*B-树以加速排序数组中的二分搜索。在其[最后一节](../s-tree/#as-a-dynamic-tree)中，我们简要讨论了如何使它们*动态*，同时保留从[S+树](../s-tree/#modifications-and-further-optimizations)中获得的性能提升，并通过在S+树的内部节点中添加和跟踪显式指针来验证我们的预测。
- en: In this article, we follow up on that proposition and design a minimally functional
    search tree for integer keys, [achieving](#evaluation) up to 18x/8x speedup over
    `std::set` and up to 7x/2x speedup over [`absl::btree`](https://abseil.io/blog/20190812-btree)
    for `lower_bound` and `insert` queries, respectively — with yet ample room for
    improvement.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们继续探讨那个命题，并设计了一个功能最少的整数键搜索树，[实现](#evaluation)了相对于`std::set`的18x/8x速度提升，相对于`absl::btree`的`lower_bound`和`insert`查询分别达到7x/2x速度提升——同时仍有很大的改进空间。
- en: The memory overhead of the structure is around 30% for 32-bit integers, and
    the final implementation is [under 150 lines of C++](https://github.com/sslotin/amh-code/blob/main/b-tree/btree-final.cc).
    It can be easily generalized to other arithmetic types and small/fixed-length
    strings such as hashes, country codes, and stock symbols.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构的内存开销大约为32位整数的30%，最终实现少于150行C++代码[under 150 lines of C++](https://github.com/sslotin/amh-code/blob/main/b-tree/btree-final.cc)。它可以很容易地推广到其他算术类型和小/固定长度的字符串，如哈希、国家代码和股票符号。
- en: '## [#](https://en.algorithmica.org/hpc/data-structures/b-tree/#b-tree)B− Tree'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '## [#](https://en.algorithmica.org/hpc/data-structures/b-tree/#b-tree)B-树'
- en: 'Instead of making small incremental improvements like we usually do in other
    case studies, in this article, we will implement just one data structure that
    we name *B− tree*, which is based on the [B+ tree](../s-tree/#b-tree-layout-1),
    with a few minor differences:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在其他案例研究中通常所做的微小增量改进不同，在本文中，我们将仅实现一个名为*B-树*的数据结构，它基于[B+树](../s-tree/#b-tree-layout-1)，但有几个小的不同之处：
- en: Nodes in the B− tree do not store pointers or any metadata except for the pointers
    to internal node children (while the B+ tree leaf nodes store a pointer to the
    next leaf node). This lets us perfectly place the keys in the leaf nodes on cache
    lines.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B-树中的节点不存储指针或任何元数据，除了指向内部节点子节点的指针（而B+树的叶子节点存储指向下一个叶子节点的指针）。这使得我们能够完美地将键放置在叶子节点上的缓存行中。
- en: We define key $i$ to be the *maximum* key in the subtree of the child $i$ instead
    of the *minimum* key in the subtree of the child $(i + 1)$. This lets us not fetch
    any other nodes after we reach a leaf (in the B+ tree, all keys in the leaf node
    may be less than the search key, so we need to go to the next leaf node to fetch
    its first element).
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将键$i$定义为子节点$i$的子树中的*最大*键，而不是子节点$(i + 1)$的子树中的*最小*键。这使得我们在达到叶子节点后不需要获取任何其他节点（在B+树中，叶子节点中的所有键可能都小于搜索键，因此我们需要转到下一个叶子节点以获取其第一个元素）。
- en: We also use a node size of $B=32$, which is smaller than typical. The reason
    why it is not $16$, which was [optimal for the S+ tree](../s-tree/#modifications-and-further-optimizations),
    is because we have the additional overhead associated with fetching the pointer,
    and the benefit of reducing the tree height by ~20% outweighs the cost of processing
    twice the elements per node, and also because it improves the running time of
    the `insert` query that needs to perform a costly node split every $\frac{B}{2}$
    insertions on average.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用节点大小$B=32$，这比典型值小。它不是$16$的原因，因为[对于S+树来说是最优的](../s-tree/#modifications-and-further-optimizations)，是因为我们还有与获取指针相关的额外开销，而通过减少树的高度约20%带来的好处超过了处理每个节点中两倍元素的成本，还因为这也提高了需要平均每$\frac{B}{2}$次插入时执行昂贵节点分割的`insert`查询的运行时间。
- en: '### [#](https://en.algorithmica.org/hpc/data-structures/b-tree/#memory-layout)Memory
    Layout'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/data-structures/b-tree/#memory-layout)内存布局'
- en: 'Although this is probably not the best approach in terms of software engineering,
    we will simply store the entire tree in a large pre-allocated array, without discriminating
    between leaves and internal nodes:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从软件工程的角度来看这可能不是最佳方法，但我们将简单地在一个大预分配数组中存储整个树，而不区分叶节点和内部节点：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We also pre-fill this array with infinities to simplify the implementation:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还预先用无穷大填充这个数组，以简化实现：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: (In general, it is technically cheating to compare against `std::set` or other
    structures that use `new` under the hood, but memory allocation and initialization
    are not the bottlenecks here, so this does not significantly affect the evaluation.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: （一般来说，与使用`new`的`std::set`或其他结构比较在技术上是不诚实的，但内存分配和初始化在这里不是瓶颈，所以这不会显著影响评估。）
- en: 'Both nodes types store their keys sequentially in sorted order and are identified
    by the index of its first key in the array:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 两种节点类型都按顺序以排序顺序存储它们的键，并通过数组中第一个键的索引来识别：
- en: A leaf node has up to $(B - 1)$ keys but is padded to $B$ elements with infinities.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 叶节点最多有$(B - 1)$个键，但用无穷大填充到$B$个元素。
- en: An internal node has up to $(B - 2)$ keys padded to $B$ elements and up to $(B
    - 1)$ indices of its child nodes, also padded to $B$ elements.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部节点最多有$(B - 2)$个键填充到$B$个元素，以及最多$(B - 1)$个子节点索引，这些索引也填充到$B$个元素。
- en: 'These design decisions are not arbitrary:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设计决策并非任意：
- en: The padding ensures that leaf nodes occupy exactly 2 cache lines and internal
    nodes occupy exactly 4 cache lines.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充确保叶节点恰好占用2个缓存行，内部节点恰好占用4个缓存行。
- en: We specifically use [indices instead of pointers](/hpc/cpu-cache/pointers/)
    to save cache space and make moving them with SIMD faster.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们特别使用[索引而不是指针](/hpc/cpu-cache/pointers/)来节省缓存空间，并使使用SIMD移动它们更快。
- en: (We will use “pointer” and “index” interchangeably from now on.)
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （从现在起，我们将“指针”和“索引”互换使用。）
- en: We store indices right after the keys even though they are stored in separate
    cache lines because [we have reasons](/hpc/cpu-cache/aos-soa/).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管索引存储在单独的缓存行中，我们仍然将索引存储在键的后面，因为我们有[原因](/hpc/cpu-cache/aos-soa/)。
- en: We intentionally “waste” one array cell in leaf nodes and $2+1=3$ cells in internal
    nodes because we need it to store temporary results during a node split.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们故意在叶节点中“浪费”一个数组单元，在内部节点中浪费$2+1=3$个单元，因为我们需要它们在节点分割期间存储临时结果。
- en: 'Initially, we only have one empty leaf node as the root:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们只有一个作为根的空叶节点：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To “allocate” a new node, we simply increase `n_tree` by $B$ if it is a leaf
    node or by $2 B$ if it is an internal node.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要“分配”一个新节点，如果它是一个叶节点，我们只需将`n_tree`增加$B$，如果是内部节点，则增加$2 B$。
- en: Since new nodes can only be created by splitting a full node, each node except
    for the root will be at least half full. This implies that we need between 4 and
    8 bytes per integer element (the internal nodes will contribute $\frac{1}{16}$-th
    or so to that number), the former being the case when the inserts are sequential,
    and the latter being the case when the input is adversarial. When the queries
    are uniformly distributed, the nodes are ~75% full on average, projecting to ~5.2
    bytes per element.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于新节点只能通过分割一个完整节点来创建，除了根节点之外，每个节点至少会有一半是满的。这意味着我们需要为每个整数元素分配4到8个字节（内部节点将贡献大约1/16的数量），前者是在插入顺序时的情况，后者是在输入具有对抗性时的情况。当查询均匀分布时，节点平均大约有75%的容量，相当于每个元素大约5.2个字节。
- en: B-trees are very memory-efficient compared to the pointer-based binary trees.
    For example, `std::set` needs at least three pointers (the left child, the right
    child, and the parent), alone costing $3 \times 8 = 24$ bytes, plus at least another
    $8$ bytes to store the key and the meta-information due to [structure padding](/hpc/cpu-cache/alignment/).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于指针的二元树相比，B树在内存效率上非常高。例如，`std::set`至少需要三个指针（左子树、右子树和父节点），单独就花费了$3 \times 8
    = 24$字节，再加上至少另外$8$字节来存储键和元信息，这是由于[结构填充](/hpc/cpu-cache/alignment/)。
- en: '### [#](https://en.algorithmica.org/hpc/data-structures/b-tree/#searching)Searching'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/data-structures/b-tree/#searching)搜索'
- en: It is a very common scenario when >90% of operations are lookups, and even if
    this is not the case, every other tree operation typically begins with locating
    a key anyway, so we will start with implementing and optimizing the searches.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当超过90%的操作是查找时，这是一个非常常见的场景，即使不是这种情况，每个其他树操作通常也以定位键开始，所以我们将从实现和优化搜索开始。
- en: When we implemented [S-trees](../s-tree/#optimization), we ended up storing
    the keys in permuted order due to the intricacies of how the blending/packs instructions
    work. For the *dynamic tree* problem, storing the keys in permuted order would
    make inserts much harder to implement, so we will change the approach instead.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现[S-trees](../s-tree/#optimization)时，由于混合/打包指令的复杂性，我们最终以排列顺序存储键。对于*动态树*问题，以排列顺序存储键会使插入的实现变得更加困难，因此我们将改变方法。
- en: 'An alternative way to think about finding the would-be position of the element
    `x` in a sorted array is not “the index of the first element that is not less
    than `x`” but “the number of elements that are less than `x`.” This observation
    generates the following idea: compare the keys against `x`, aggregate the vector
    masks into a 32-bit mask (where each bit can correspond to any element as long
    as the mapping is bijective), and then call `popcnt` on it, returning the number
    of elements less than `x`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到在排序数组中找到元素 `x` 的潜在位置的另一种方法是“第一个不小于 `x` 的元素的索引”，而不是“小于 `x` 的元素的数量。”这个观察产生了以下想法：将键与
    `x` 进行比较，将向量掩码聚合到一个 32 位掩码中（其中每个位可以对应任何元素，只要映射是双射的），然后调用 `popcnt`，返回小于 `x` 的元素数量。
- en: 'This trick lets us perform the local search efficiently and without requiring
    any shuffling:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧让我们可以有效地执行局部搜索，而不需要任何洗牌操作：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that, because of this procedure, we have to pad the “key area” with infinities,
    which prevents us from storing metadata in the vacated cells (unless we are also
    willing to spend a few cycles to mask it out when loading a SIMD lane).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于这个程序，我们必须用无穷大填充“键区域”，这阻止我们在空出的单元格中存储元数据（除非我们也愿意在加载 SIMD 通道时花费几个周期来屏蔽它）。
- en: 'Now, to implement `lower_bound`, we can descend the tree just like we did in
    the S+ tree, but fetching the pointer after we compute the child number:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要实现 `lower_bound`，我们可以像在 S+ 树中做的那样遍历树，但在计算子节点编号后获取指针：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Implementing search is easy, and it doesn’t introduce much overhead. The hard
    part is implementing insertion.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 实现搜索很简单，并且不会引入太多开销。困难的部分是实现插入。
- en: '### [#](https://en.algorithmica.org/hpc/data-structures/b-tree/#insertion)Insertion'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/data-structures/b-tree/#insertion)插入'
- en: On the one side, correctly implementing insertion takes a lot of code, but on
    the other, most of that code is executed very infrequently, so we don’t have to
    care about its performance that much. Most often, all we need to do is to reach
    the leaf node (which we’ve already figured out how to do) and then insert a new
    key into it, moving some suffix of the keys one position to the right. Occasionally,
    we also need to split the node and/or update some ancestors, but this is relatively
    rare, so let’s focus on the most common execution path first.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在一方面，正确实现插入需要大量的代码，但另一方面，其中大部分代码执行频率很低，所以我们不必太关心其性能。通常，我们只需要到达叶节点（我们已经知道了如何做到这一点）并插入一个新的键，将一些键的子串向右移动一个位置。偶尔，我们还需要分割节点和/或更新一些祖先，但这相对较少，所以让我们首先关注最常见的执行路径。
- en: 'To insert a key into an array of $(B - 1)$ sorted elements, we can load them
    in vector registers and then [mask-store](/hpc/simd/masking) them one position
    to the right using a [precomputed](/hpc/compilation/precalc/) mask that tells
    which elements need to be written for a given `i`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个键插入到 $(B - 1)$ 个排序元素的数组中，我们可以将它们加载到向量寄存器中，然后使用一个[预计算的](/hpc/compilation/precalc/)掩码将它们向右移动一个位置，该掩码告诉哪些元素需要写入给定的
    `i`：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This [constexpr magic](/hpc/compilation/precalc/) is the only C++ feature we
    use.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种[constexpr 魔法](/hpc/compilation/precalc/)是我们使用的唯一 C++ 功能。
- en: There are other ways to do it, some possibly more efficient, but we are going
    to stop there for now.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他方法可以做到这一点，其中一些可能更高效，但我们现在将停止在这里。
- en: 'When we split a node, we need to move half of the keys to another node, so
    let’s write another primitive that does it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们分割一个节点时，需要将一半的键移动到另一个节点，因此让我们编写另一个原始操作来完成它：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With these two vector functions implemented, we can now very carefully implement
    insertion:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了这两个向量函数后，我们现在可以非常小心地实现插入：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There are many inefficiencies, but, luckily, the body of `if (filled)` is executed
    very infrequently — approximately every $\frac{B}{2}$ insertions — and the insertion
    performance is not really our top priority, so we will just leave it there.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然存在许多低效之处，但幸运的是，`if (filled)` 的主体执行频率非常低——大约每 $\frac{B}{2}$ 次插入——因此插入性能并不是我们的首要任务，所以我们只需将其保留即可。
- en: '## [#](https://en.algorithmica.org/hpc/data-structures/b-tree/#evaluation)Evaluation'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '## [#](https://en.algorithmica.org/hpc/data-structures/b-tree/#evaluation)评估'
- en: We have only implemented `insert` and `lower_bound`, so this is what we will
    measure.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只实现了 `insert` 和 `lower_bound`，因此这是我们将会测量的内容。
- en: 'We want the evaluation to take a reasonable time, so our benchmark is a loop
    that alternates between two steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望评估过程花费合理的时间，因此我们的基准是一个在两个步骤之间交替的循环：
- en: Increase the structure size from $1.17^k$ to $1.17^{k+1}$ using individual `insert`s
    and measure the time it took.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结构大小从 $1.17^k$ 增加到 $1.17^{k+1}$，通过单个 `insert` 操作并测量所需时间。
- en: Perform $10^6$ random `lower_bound` queries and measure the time it took.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 $10^6$ 次随机的 `lower_bound` 查询并测量所需时间。
- en: We start at the size $10^4$ and end at $10^7$, for around $50$ data points in
    total. We generate the data for both query types uniformly in the $[0, 2^{30})$
    range and independently between the stages. Since the data generation process
    allows for repeated keys, we compared against `std::multiset` and `absl::btree_multiset`^([1](#fn:1)),
    although we still refer to them as `std::set` and `absl::btree` for brevity. We
    also enable [hugepages](/hpc/cpu-cache/paging) on the system level for all three
    runs.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从大小 $10^4$ 开始，结束于 $10^7$，总共大约有 $50$ 个数据点。我们在 $[0, 2^{30})$ 范围内均匀地生成两种查询类型的数据，并在各个阶段独立生成。由于数据生成过程允许重复的键，我们与
    `std::multiset` 和 `absl::btree_multiset`^([1](#fn:1)) 进行了比较，尽管为了简洁起见，我们仍然将它们称为
    `std::set` 和 `absl::btree`。我们还为所有三次运行在系统级别上启用了 [hugepages](/hpc/cpu-cache/paging)。
- en: 'The performance of the B− tree matches what we originally predicted — at least
    for the lookups:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: B−树的表现与我们最初预测的相符 — 至少对于查找操作：
- en: '![](../Images/26083816f86f5976244114da1efa0dab.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/26083816f86f5976244114da1efa0dab.png)'
- en: 'The relative speedup varies with the structure size — 7-18x/3-8x over STL and
    3-7x/1.5-2x over Abseil:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 相对速度提升随着结构大小的变化而变化 — 相比 STL，速度提升 7-18 倍/3-8 倍，相比 Abseil，速度提升 3-7 倍/1.5-2 倍：
- en: '![](../Images/18c97b4d8a35a1b9df83ca03db53208d.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18c97b4d8a35a1b9df83ca03db53208d.png)'
- en: 'Insertions are only 1.5-2 faster than for `absl::btree`, which uses scalar
    code to do everything. My best guess why insertions are *that* slow is due to
    data dependency: since the tree nodes may change, the CPU can’t start processing
    the next query before the previous one finishes (the [true latency](../s-tree/#comparison-with-stdlower_bound)
    of both queries is roughly equal and ~3x of the reciprocal throughput of `lower_bound`).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 插入操作比 `absl::btree` 快 1.5-2 倍，后者使用标量代码执行所有操作。我最好的猜测是插入操作之所以那么慢，是因为数据依赖性：由于树节点可能会改变，CPU
    在完成上一个查询之前不能开始处理下一个查询（两个查询的 [真实延迟](../s-tree/#comparison-with-stdlower_bound)
    大约相等，并且是 `lower_bound` 倒数吞吐量的 ~3 倍）。
- en: '![](../Images/0449323c1e75d28258465c347b9aff02.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0449323c1e75d28258465c347b9aff02.png)'
- en: 'When the structure size is small, the [reciprocal throughput](../s-tree/#comparison-with-stdlower_bound)
    of `lower_bound` increases in discrete steps: it starts with 3.5ns when there
    is only the root to visit, then grows to 6.5ns (two nodes), and then to 12ns (three
    nodes), and then hits the L2 cache (not shown on the graphs) and starts increasing
    more smoothly, but still with noticeable spikes when the tree height increases.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当结构大小较小时，`lower_bound` 的 [倒数吞吐量](../s-tree/#comparison-with-stdlower_bound)
    以离散的步骤增加：当只有根节点需要访问时，它从 3.5ns 开始，然后增长到 6.5ns（两个节点），然后到 12ns（三个节点），然后达到 L2 缓存（图中未显示）并开始更平滑地增加，但仍然在树高度增加时出现明显的峰值。
- en: 'Interestingly, B− tree outperforms `absl::btree` even when it only stores a
    single key: it takes around 5ns stalling on [branch misprediction](/hpc/pipelining/branching/),
    while (the search in) the B− tree is entirely branchless.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，即使 B−树只存储单个键，它的性能也优于 `absl::btree`：它在 [分支预测错误](/hpc/pipelining/branching/)
    上停滞了大约 5ns，而 B−树中的搜索是完全无分支的。
- en: '### [#](https://en.algorithmica.org/hpc/data-structures/b-tree/#possible-optimizations)Possible
    Optimizations'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/data-structures/b-tree/#possible-optimizations)可能的优化'
- en: 'In our previous endeavors in data structure optimization, it helped a lot to
    make as many variables as possible compile-time constants: the compiler can hardcode
    these constants into the machine code, simplify the arithmetic, unroll all the
    loops, and do many other nice things for us.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的数据结构优化努力中，尽可能多地使变量成为编译时常量有很大帮助：编译器可以将这些常量硬编码到机器代码中，简化算术运算，展开所有循环，并为我们做许多其他好事。
- en: 'This would not be a problem at all if our tree were of constant height, but
    it is not. It is *largely* constant, though: the height rarely changes, and in
    fact, under the constraints of the benchmark, the maximum height was only 6.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的树高度是常数，这根本不会是问题，但事实并非如此。它*大部分*是常数：高度很少改变，实际上，在基准测试的约束下，最大高度仅为6。
- en: 'What we can do is pre-compile the `insert` and `lower_bound` functions for
    several different compile-time constant heights and switch between them as the
    tree grows. The idiomatic C++ way is to use virtual functions, but I prefer to
    be explicit and use raw function pointers like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以预先编译`insert`和`lower_bound`函数，用于几个不同的编译时常量高度，并在树生长时在这之间切换。C++的惯用方法是使用虚拟函数，但我更喜欢明确地使用原始函数指针，如下所示：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We now define template functions that have the tree height as a parameter,
    and in the grow-tree block inside the `insert` function, we change the pointers
    as the tree grows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在定义了具有树高度作为参数的模板函数，并在`insert`函数内的`grow-tree`块中，随着树的生长改变指针：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I tried but could not get any performance improvement with this, but I still
    have high hope for this approach because the compiler can (theoretically) remove
    `sk` and `si`, completely removing any temporary storage and only reading and
    computing everything once, greatly optimizing the `insert` procedure.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我尝试了，但使用这种方法并没有获得任何性能提升，但我仍然对这个方法抱有很高的期望，因为编译器可以（理论上）移除`sk`和`si`，完全移除任何临时存储，并且只读取和计算一次，极大地优化了`insert`过程。
- en: 'Insertion can also probably be optimized by using a larger block size as node
    splits would become rare, but this comes at the cost of slower lookups. We could
    also try different node sizes for different layers: leaves should probably be
    larger than the internal nodes.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 插入也可以通过使用更大的块大小来优化，因为节点分裂会变得很少，但这会以更慢的查找为代价。我们还可以尝试为不同层使用不同的节点大小：叶子节点可能应该比内部节点大。
- en: '**Another idea** is to move extra keys on insert to a sibling node, delaying
    the node split as long as possible.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**另一个想法**是在插入时将额外的键移动到兄弟节点，尽可能延迟节点分裂。'
- en: One such particular modification is known as the B* tree. It moves the last
    key to the next node if the current one is full, and when both nodes become full,
    it jointly splits both of them, producing three nodes that are ⅔ full. This reduces
    the memory overhead (the nodes will be ⅚ full on average) and increases the fanout
    factor, reducing the height, which helps all operations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种特定的修改方法被称为B*树。如果当前节点已满，它会将最后一个键移动到下一个节点；当两个节点都满了，它会同时分裂它们，产生三个三分之二满的节点。这减少了内存开销（节点平均将会有六分之五满），增加了分支因子，减少了树的高度，这有助于所有操作。
- en: This technique can even be extended to, say, three-to-four splits, although
    further generalization would come at the cost of a slower `insert`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术甚至可以扩展到，比如说，三到四的分裂，尽管进一步的泛化将付出更慢的`insert`的代价。
- en: '**And yet another idea** is to get rid of (some) pointers. For example, for
    large trees, we can probably afford a small [S+ tree](../s-tree) for $16 \cdot
    17$ or so elements as the root, which we rebuild from scratch on each infrequent
    occasion when it changes. You can’t extend it to the whole tree, unfortunately:
    I believe there is a paper somewhere saying that we can’t turn a dynamic structure
    fully implicit without also having to do $\Omega(\sqrt n)$ operations per query.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**还有另一个想法**是去除（一些）指针。例如，对于大型树，我们可能可以承受一个小的[S+树](../s-tree)，用于大约$16 \cdot 17$个元素作为根，每次它不经常改变时，我们从头开始重建它。不幸的是，你不能将其扩展到整个树：我相信某处有一篇论文说，如果我们不进行$\Omega(\sqrt
    n)$的操作，就无法将动态结构完全隐式化。'
- en: We could also try some non-tree data structures, such as the [skip list](https://en.wikipedia.org/wiki/Skip_list).
    There has even been a [successful attempt to vectorize it](https://doublequan.github.io/)
    — although the speedup was not that impressive. I have low hope that skip-list,
    in particular, can be improved, although it may achieve a higher total throughput
    in the concurrent setting.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以尝试一些非树数据结构，例如[跳表](https://en.wikipedia.org/wiki/Skip_list)。甚至有人尝试了[向量化的成功尝试](https://doublequan.github.io/)——尽管速度提升并不那么令人印象深刻。我对跳表，特别是，能被改进的希望很低，尽管它可能在并发设置中实现更高的总吞吐量。
- en: '### [#](https://en.algorithmica.org/hpc/data-structures/b-tree/#other-operations)Other
    Operations'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/data-structures/b-tree/#other-operations)其他操作'
- en: To *delete* a key, we can similarly locate and remove it from a node with the
    same mask-store trick. After that, if the node is at least half-full, we’re done.
    Otherwise, we try to borrow a key from the next sibling. If the sibling has more
    than $\frac{B}{2}$ keys, we append its first key and shift its keys one to the
    left. Otherwise, both the current node and the next node have less than $\frac{B}{2}$
    keys, so we can merge them, after which we go to the parent and iteratively delete
    a key there.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要*删除*一个键，我们可以用类似的方法通过相同的mask-store技巧定位并从节点中移除它。之后，如果节点至少有一半是满的，我们就完成了。否则，我们尝试从下一个兄弟节点借一个键。如果兄弟节点有超过
    $\frac{B}{2}$ 个键，我们就附加它的第一个键并将它的键向左移动一个位置。否则，当前节点和下一个节点都少于 $\frac{B}{2}$ 个键，因此我们可以合并它们，之后我们前往父节点并迭代地在那里删除一个键。
- en: Another thing we may want to implement is *iteration*. Bulk-loading each key
    from `l` to `r` is a very common pattern — for example, in `SELECT abc ORDER BY
    xyz` type of queries in databases — and B+ trees usually store pointers to the
    next node in the data layer to allow for this type of rapid iteration. In B− trees,
    as we’re using a much smaller node size, we can experience [pointer chasing](/hpc/cpu-cache/latency/)
    problems if we do this. Going to the parent and reading all its $B$ pointers is
    probably faster as it negates this problem. Therefore, a stack of ancestors (the
    `sk` and `si` arrays we used in `insert`) can serve as an iterator and may even
    be better than separately storing pointers in nodes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可能想要实现的是*迭代*。从`l`到`r`批量加载每个键是一个非常常见的模式——例如，在数据库中的`SELECT abc ORDER BY xyz`类型的查询中——B+树通常在数据层存储指向下一个节点的指针，以便进行此类快速迭代。在B-树中，由于我们使用的是更小的节点大小，如果我们这样做，可能会遇到[指针追踪](/hpc/cpu-cache/latency/)问题。前往父节点并读取所有它的$B$个指针可能更快，因为它消除了这个问题。因此，祖先节点栈（我们在`insert`中使用的`sk`和`si`数组）可以用作迭代器，甚至可能比在节点中单独存储指针更好。
- en: 'We can easily implement almost everything that `std::set` does, but the B−
    tree, like any other B-tree, is very unlikely to become a drop-in replacement
    to `std::set` due to the requirement of pointer stability: a pointer to an element
    should remain valid unless the element is deleted, which is hard to achieve when
    we split and merge nodes all the time. This is a major problem not only for search
    trees but most data structures in general: having both pointer stability and high
    performance at the same time is next to impossible.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松实现`std::set`几乎能做的所有事情，但B-树，就像任何其他B树一样，由于指针稳定性的要求，不太可能成为`std::set`的直接替代品：指向元素的指针应该保持有效，除非元素被删除，这在不断分割和合并节点时很难实现。这不仅是对搜索树，也是对大多数数据结构的一个主要问题：同时拥有指针稳定性和高性能几乎是不可能的。
- en: '## [#](https://en.algorithmica.org/hpc/data-structures/b-tree/#acknowledgements)Acknowledgements'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '## [#](https://en.algorithmica.org/hpc/data-structures/b-tree/#acknowledgements)致谢'
- en: Thanks to [Danila Kutenin](https://danlark.org/) from Google for meaningful
    discussions of applicability and the usage of B-trees in Abseil.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢Google的[Danila Kutenin](https://danlark.org/)就适用性和在Abseil中使用B树的意义进行了有意义的讨论。
- en: '* * *'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: If you also think that only comparing with Abseil’s B-tree is not convincing
    enough, [feel free](https://github.com/sslotin/amh-code/tree/main/b-tree) to add
    your favorite search tree to the benchmark. [↩︎](#fnref:1) [← Static B-Trees](https://en.algorithmica.org/hpc/data-structures/s-tree/)[Segment
    Trees →](https://en.algorithmica.org/hpc/data-structures/segment-trees/)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你认为仅仅比较Abseil的B树还不够令人信服，[请随意](https://github.com/sslotin/amh-code/tree/main/b-tree)
    将你喜欢的搜索树添加到基准测试中。[↑](#fnref:1) [← 静态B树](https://en.algorithmica.org/hpc/data-structures/s-tree/)[段树
    →](https://en.algorithmica.org/hpc/data-structures/segment-trees/)
