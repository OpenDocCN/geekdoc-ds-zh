- en: 28Â Pyret for Racketeers and SchemersğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 28 Pyret for Racketeers and SchemersğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/p4rs.html](https://dcic-world.org/2025-08-27/p4rs.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/p4rs.html](https://dcic-world.org/2025-08-27/p4rs.html)
- en: '| Â Â Â Â [28.1Â Numbers, Strings, and Booleans](#%28part._.Numbers__.Strings__and_.Booleans%29)
    |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| 28.1 æ•°å­—ã€å­—ç¬¦ä¸²å’Œå¸ƒå°”å€¼](#%28part._.Numbers__.Strings__and_.Booleans%29) |'
- en: '| Â Â Â Â [28.2Â Infix Expressions](#%28part._.Infix_.Expressions%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| 28.2 ä¸­ç¼€è¡¨è¾¾å¼](#%28part._.Infix_.Expressions%29) |'
- en: '| Â Â Â Â [28.3Â Function Definition and Application](#%28part._.Function_.Definition_and_.Application%29)
    |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| 28.3 å‡½æ•°å®šä¹‰å’Œåº”ç”¨](#%28part._.Function_.Definition_and_.Application%29) |'
- en: '| Â Â Â Â [28.4Â Tests](#%28part._.Tests%29) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| 28.4 æµ‹è¯•](#%28part._.Tests%29) |'
- en: '| Â Â Â Â [28.5Â Variable Names](#%28part._.Variable_.Names%29) |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| 28.5 å˜é‡å](#%28part._.Variable_.Names%29) |'
- en: '| Â Â Â Â [28.6Â Data Definitions](#%28part._.Data_.Definitions%29) |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 28.6 æ•°æ®å®šä¹‰](#%28part._.Data_.Definitions%29) |'
- en: '| Â Â Â Â [28.7Â Conditionals](#%28part._.Conditionals%29) |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 28.7 æ¡ä»¶è¯­å¥](#%28part._.Conditionals%29) |'
- en: '| Â Â Â Â [28.8Â Lists](#%28part._.Lists%29) |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 28.8 åˆ—è¡¨](#%28part._.Lists%29) |'
- en: '| Â Â Â Â [28.9Â First-Class Functions](#%28part._.First-.Class_.Functions%29) |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 28.9 é¦–ç±»å‡½æ•°](#%28part._.First-.Class_.Functions%29) |'
- en: '| Â Â Â Â [28.10Â Annotations](#%28part._.Annotations%29) |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 28.10 æ³¨é‡Š](#%28part._.Annotations%29) |'
- en: '| Â Â Â Â [28.11Â What Else?](#%28part._.What_.Else_%29) |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 28.11 è¿˜æœ‰å…¶ä»–ä»€ä¹ˆï¼Ÿ](#%28part._.What_.Else_%29) |'
- en: If youâ€™ve programmed before in a language like Scheme or the student levels
    of Racket (or the WeScheme programming environment), or for that matter even in
    certain parts of OCaml, Haskell, Scala, Erlang, Clojure, or other languages, you
    will find many parts of Pyret very familiar. This chapter is specifically written
    to help you make the transition from (student) Racket/Scheme/WeScheme (abbreviated
    â€œRSWâ€) to Pyret by showing you how to convert the syntax. Most of what we say
    applies to all these languages, though in some cases we will refer specifically
    to Racket (and WeScheme) features not found in Scheme.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ ä¹‹å‰åœ¨åƒ Scheme æˆ– Racket çš„å­¦ç”Ÿçº§åˆ«ï¼ˆæˆ– WeScheme ç¼–ç¨‹ç¯å¢ƒï¼‰è¿™æ ·çš„è¯­è¨€ä¸­ç¼–ç¨‹è¿‡ï¼Œæˆ–è€…ç”šè‡³åœ¨æŸäº›éƒ¨åˆ†çš„ OCamlã€Haskellã€Scalaã€Erlangã€Clojure
    æˆ–å…¶ä»–è¯­è¨€ä¸­ç¼–ç¨‹è¿‡ï¼Œä½ ä¼šå‘ç° Pyret çš„è®¸å¤šéƒ¨åˆ†éå¸¸ç†Ÿæ‚‰ã€‚æœ¬ç« ä¸“é—¨ç¼–å†™æ¥å¸®åŠ©ä½ é€šè¿‡å±•ç¤ºå¦‚ä½•è½¬æ¢è¯­æ³•ï¼Œä»ï¼ˆå­¦ç”Ÿï¼‰Racket/Scheme/WeSchemeï¼ˆç¼©å†™ä¸ºâ€œRSWâ€ï¼‰è¿‡æ¸¡åˆ°
    Pyretã€‚æˆ‘ä»¬æ‰€è¯´çš„å†…å®¹å¤§å¤šé€‚ç”¨äºæ‰€æœ‰è¿™äº›è¯­è¨€ï¼Œå°½ç®¡åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°†å…·ä½“æåˆ° Racketï¼ˆå’Œ WeSchemeï¼‰ä¸­æœªåœ¨ Scheme ä¸­æ‰¾åˆ°çš„åŠŸèƒ½ã€‚
- en: In every example below, the two programs will produce the same results.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸‹é¢çš„æ¯ä¸ªä¾‹å­ä¸­ï¼Œä¸¤ä¸ªç¨‹åºå°†äº§ç”Ÿç›¸åŒçš„ç»“æœã€‚
- en: 28.1Â Numbers, Strings, and Booleans[ğŸ”—](#(part._.Numbers__.Strings__and_.Booleans)
    "Link to here")
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.1 æ•°å­—ã€å­—ç¬¦ä¸²å’Œå¸ƒå°”å€¼[ğŸ”—](#(part._.Numbers__.Strings__and_.Booleans) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Numbers are very similar between the two. Like Scheme, Pyret implements arbitrary-precision
    numbers and rationals. Some of the more exotic numeric systems of Scheme (such
    as complex numbers) arenâ€™t in Pyret; Pyret also treats imprecise numbers slightly
    differently.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸¤ä¸ªè¯­è¨€ä¹‹é—´çš„æ•°å­—éå¸¸ç›¸ä¼¼ã€‚åƒ Scheme ä¸€æ ·ï¼ŒPyret å®ç°äº†ä»»æ„ç²¾åº¦æ•°å­—å’Œæœ‰ç†æ•°ã€‚ä¸€äº› Scheme ä¸­æ›´å¥‡ç‰¹çš„æ•°å­—ç³»ç»Ÿï¼ˆå¦‚å¤æ•°ï¼‰ä¸åœ¨ Pyret
    ä¸­ï¼›Pyret è¿˜å¯¹ä¸ç²¾ç¡®æ•°å­—çš„å¤„ç†ç•¥æœ‰ä¸åŒã€‚
- en: '| RSW | Pyret |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| 1 | `1` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `1` |'
- en: '| RSW | Pyret |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| 1/2 | `1/2` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 1/2 | `1/2` |'
- en: '| RSW | Pyret |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| #i3.14 | `~3.14` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| #i3.14 | `~3.14` |'
- en: Strings are also very similar, though Pyret allows you to use single-quotes
    as well.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: å­—ç¬¦ä¸²ä¹Ÿéå¸¸ç›¸ä¼¼ï¼Œå°½ç®¡ Pyret å…è®¸ä½ ä½¿ç”¨å•å¼•å·ã€‚
- en: '| RSW | Pyret |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| "Hello,Â world!" | `"Hello, world!"` |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| "Hello, world!" | `"Hello, world!"` |'
- en: '| RSW | Pyret |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| "\"Hello\",Â heÂ said" | `"\"Hello\", he said"` |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| â€œHelloâ€ï¼Œä»–è¯´ | `"â€œHelloâ€ï¼Œä»–è¯´"` |'
- en: '| RSW | Pyret |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| "\"Hello\",Â heÂ said" | `''"Hello", he said''` |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| â€œHelloâ€ï¼Œä»–è¯´ | `''"Hello"ï¼Œä»–è¯´''` |'
- en: 'Booleans have the same names:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: å¸ƒå°”å€¼å…·æœ‰ç›¸åŒçš„åç§°ï¼š
- en: '| RSW | Pyret |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| true | `true` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| true | `true` |'
- en: '| RSW | Pyret |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| false | `false` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| false | `false` |'
- en: 28.2Â Infix Expressions[ğŸ”—](#(part._.Infix_.Expressions) "Link to here")
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.2 ä¸­ç¼€è¡¨è¾¾å¼[ğŸ”—](#(part._.Infix_.Expressions) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Pyret uses an infix syntax, reminiscent of many other textual programming languages:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret ä½¿ç”¨ä¸­ç¼€è¯­æ³•ï¼Œç±»ä¼¼äºè®¸å¤šå…¶ä»–æ–‡æœ¬ç¼–ç¨‹è¯­è¨€ï¼š
- en: '| RSW | Pyret |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| (+Â 1Â 2) | `1 + 2` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| (+ 1 2) | `1 + 2` |'
- en: '| RSW | Pyret |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| (*Â (-Â 4Â 2)Â 5) | `(4 - 2) * 5` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| (* (- 4 2) 5) | `(4 - 2) * 5` |'
- en: 'Note that Pyret does not have rules about orders of precedence between operators,
    so when you mix operators, you have to parenthesize the expression to make your
    intent clear. When you chain the same operator you donâ€™t need to parenthesize;
    chaining associates to the left in both languages:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼ŒPyret æ²¡æœ‰å…³äºè¿ç®—ç¬¦ä¼˜å…ˆçº§é¡ºåºçš„è§„åˆ™ï¼Œæ‰€ä»¥å½“ä½ æ··åˆè¿ç®—ç¬¦æ—¶ï¼Œä½ å¿…é¡»æ‹¬å·è¡¨è¾¾å¼ä»¥ä½¿ä½ çš„æ„å›¾æ˜ç¡®ã€‚å½“ä½ é“¾å¼ä½¿ç”¨ç›¸åŒçš„è¿ç®—ç¬¦æ—¶ï¼Œä½ ä¸éœ€è¦æ‹¬å·ï¼›é“¾å¼åœ¨ä¸¤ç§è¯­è¨€ä¸­éƒ½æ˜¯å·¦ç»“åˆçš„ï¼š
- en: '| RSW | Pyret |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| (/Â 1Â 2Â 3Â 4) | `1 / 2 / 3 / 4` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| (/ 1 2 3 4) | `1 / 2 / 3 / 4` |'
- en: These both evaluate to 1/24.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸¤ä¸ªéƒ½è®¡ç®—ä¸º 1/24ã€‚
- en: 28.3Â Function Definition and Application[ğŸ”—](#(part._.Function_.Definition_and_.Application)
    "Link to here")
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.3 å‡½æ•°å®šä¹‰å’Œåº”ç”¨[ğŸ”—](#(part._.Function_.Definition_and_.Application) "é“¾æ¥è‡³æ­¤")
- en: 'Function definition and application in Pyret have an infix syntax, more reminiscent
    of many other textual programming languages. Application uses a syntax familiar
    from conventional algebra books:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Pyret ä¸­ï¼Œå‡½æ•°å®šä¹‰å’Œåº”ç”¨å…·æœ‰ä¸­ç¼€è¯­æ³•ï¼Œæ›´ç±»ä¼¼äºè®¸å¤šå…¶ä»–æ–‡æœ¬ç¼–ç¨‹è¯­è¨€ã€‚åº”ç”¨ä½¿ç”¨ä»ä¼ ç»Ÿä»£æ•°ä¹¦ç±ä¸­ç†Ÿæ‚‰çš„è¯­æ³•ï¼š
- en: '| RSW | Pyret |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| (distÂ 3Â 4) | `dist(3, 4)` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| (dist 3 4) | `dist(3, 4)` |'
- en: 'Application correspondingly uses a similar syntax in function headers, and
    infix in the body:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: åº”ç”¨åœ¨å‡½æ•°å¤´ä¸­ä½¿ç”¨ç±»ä¼¼çš„è¯­æ³•ï¼Œåœ¨ä¸»ä½“ä¸­ä½¿ç”¨ä¸­ç¼€ï¼š
- en: '| RSW | Pyret |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '|'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124; (defineÂ (distÂ xÂ y) &#124;'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '&#124; (define (dist x y) &#124;'
- en: '&#124; Â Â (sqrtÂ (+Â (*Â xÂ x) &#124;'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '&#124; (sqrt (+ (* x x) &#124;'
- en: '&#124; Â Â Â Â Â Â Â Â Â Â Â (*Â yÂ y)))) &#124;'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '&#124; (* y y))) &#124;'
- en: '|'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 28.4Â Tests[ğŸ”—](#(part._.Tests) "Link to here")
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.4 æµ‹è¯•[ğŸ”—](#(part._.Tests) "é“¾æ¥è‡³æ­¤")
- en: 'There are essentially three different ways of writing the equivalent of Racketâ€™s
    check-expect tests. They can be translated into check blocks:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šï¼Œæœ‰ä¸‰ç§ä¸åŒçš„æ–¹å¼æ¥ç¼–å†™ Racket çš„ check-expect æµ‹è¯•çš„ç­‰æ•ˆä»£ç ã€‚å®ƒä»¬å¯ä»¥ç¿»è¯‘æˆ check å—ï¼š
- en: '| RSW | Pyret |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| (check-expectÂ 1Â 1) |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| (check-expect 1 1) |'
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Note that multiple tests can be put into a single block:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå¯ä»¥å°†å¤šä¸ªæµ‹è¯•æ”¾å…¥ä¸€ä¸ªå—ä¸­ï¼š
- en: '| RSW | Pyret |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '|'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124; (check-expectÂ 1Â 1) &#124;'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '&#124; (check-expect 1 1) &#124;'
- en: '&#124; (check-expectÂ 2Â 2) &#124;'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '&#124; (check-expect 2 2) &#124;'
- en: '|'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'The second way is this: as an alias for `check` we can also write `examples`.
    The two are functionally identical, but they capture the human difference between
    examples (which explore the problem, and are written before attempting a solution)
    and tests (which try to find bugs in the solution, and are written to probe its
    design).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬äºŒç§æ–¹å¼æ˜¯ï¼šä½œä¸º `check` çš„åˆ«åï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å†™ `examples`ã€‚è¿™ä¸¤ä¸ªåœ¨åŠŸèƒ½ä¸Šæ˜¯ç›¸åŒçš„ï¼Œä½†å®ƒä»¬æ•æ‰äº†ä¾‹å­ï¼ˆæ¢ç´¢é—®é¢˜ï¼Œåœ¨å°è¯•è§£å†³æ–¹æ¡ˆä¹‹å‰ç¼–å†™ï¼‰å’Œæµ‹è¯•ï¼ˆè¯•å›¾æ‰¾åˆ°è§£å†³æ–¹æ¡ˆä¸­çš„é”™è¯¯ï¼Œå¹¶ç¼–å†™æ¥æ¢æµ‹å…¶è®¾è®¡ï¼‰ä¹‹é—´çš„äººç±»å·®å¼‚ã€‚
- en: 'The third way is to write a `where` block to accompany a function definition.
    For instance:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸‰ç§æ–¹å¼æ˜¯ç¼–å†™ä¸€ä¸ª `where` å—æ¥ä¼´éšå‡½æ•°å®šä¹‰ã€‚ä¾‹å¦‚ï¼š
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These can even be written for internal functions (i.e., functions contained
    inside other functions), which isnâ€™t true for check-expect.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›ç”šè‡³å¯ä»¥ç”¨äºå†…éƒ¨å‡½æ•°ï¼ˆå³åŒ…å«åœ¨å…¶ä»–å‡½æ•°ä¸­çš„å‡½æ•°ï¼‰ï¼Œè¿™å¯¹äº check-expect æ¥è¯´å¹¶ä¸æˆç«‹ã€‚
- en: 'In Pyret, unlike in Racket, a testing block can contain a documentation string.
    This is used by Pyret when reporting test successes and failures. For instance,
    try to run and see what you get:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ Racket ä¸åŒï¼ŒPyret ä¸­çš„æµ‹è¯•å—å¯ä»¥åŒ…å«æ–‡æ¡£å­—ç¬¦ä¸²ã€‚å½“ Pyret æŠ¥å‘Šæµ‹è¯•æˆåŠŸå’Œå¤±è´¥æ—¶ï¼Œä¼šä½¿ç”¨å®ƒã€‚ä¾‹å¦‚ï¼Œå°è¯•è¿è¡Œå¹¶æŸ¥çœ‹æ‚¨å¾—åˆ°çš„ç»“æœï¼š
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is useful for documenting the purpose of a testing block.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯¹äºè®°å½•æµ‹è¯•å—çš„ç›®çš„å¾ˆæœ‰ç”¨ã€‚
- en: Just as in Racket, there are many testing operators in Pyret (in addition to
    `is`). See [the documentation](https://www.pyret.org/docs/latest/testing.html).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: å°±åƒåœ¨ Racket ä¸­ä¸€æ ·ï¼ŒPyret ä¸­æœ‰è®¸å¤šæµ‹è¯•è¿ç®—ç¬¦ï¼ˆé™¤äº† `is`ï¼‰ã€‚å‚è§ [æ–‡æ¡£](https://www.pyret.org/docs/latest/testing.html)ã€‚
- en: 28.5Â Variable Names[ğŸ”—](#(part._.Variable_.Names) "Link to here")
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.5 å˜é‡å[ğŸ”—](#(part._.Variable_.Names) "é“¾æ¥è‡³æ­¤")
- en: 'Both languages have a fairly permissive system for naming variables. While
    you can use CamelCase and under_scores in both, it is conventional to instead
    use what is known as [kebab-case](http://c2.com/cgi/wiki?KebabCase).This name
    is inaccurate. The word â€œkebabâ€ just means â€œmeatâ€. The skewer is the â€œshishâ€.
    Therefore, it ought to at least be called â€œshish kebab caseâ€. Thus:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸¤ç§è¯­è¨€éƒ½æœ‰ç›¸å½“å®½å®¹çš„å˜é‡å‘½åç³»ç»Ÿã€‚è™½ç„¶ä½ å¯ä»¥åœ¨ä¸¤è€…ä¸­ä½¿ç”¨é©¼å³°å¼å’Œä¸‹åˆ’çº¿ï¼Œä½†ä¼ ç»Ÿä¸Šä½¿ç”¨æ‰€è°“çš„ [kebab-case](http://c2.com/cgi/wiki?KebabCase)ã€‚è¿™ä¸ªåç§°ä¸å‡†ç¡®ã€‚å•è¯â€œkebabâ€åªæ˜¯æ„å‘³ç€â€œè‚‰â€ã€‚ä¸²æ˜¯â€œshishâ€ã€‚å› æ­¤ï¼Œè‡³å°‘åº”è¯¥è¢«ç§°ä¸ºâ€œshish
    kebab caseâ€ã€‚å› æ­¤ï¼š
- en: '| RSW | Pyret |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| this-is-a-name | `this-is-a-name` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| this-is-a-name | `this-is-a-name` |'
- en: Even though Pyret has infix subtraction, the language can unambiguously tell
    apart `this-name` (a variable) from `this - name` (a subtraction expression) because
    the `-` in the latter must be surrounded by spaces.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: å³ä½¿ Pyret æœ‰ä¸­ç¼€å‡æ³•ï¼Œè¯¥è¯­è¨€ä¹Ÿèƒ½æ˜ç¡®åŒºåˆ† `this-name`ï¼ˆä¸€ä¸ªå˜é‡ï¼‰å’Œ `this - name`ï¼ˆä¸€ä¸ªå‡æ³•è¡¨è¾¾å¼ï¼‰ï¼Œå› ä¸ºåè€…ä¸­çš„ `-`
    å¿…é¡»è¢«ç©ºæ ¼åŒ…å›´ã€‚
- en: Despite this spacing convention, Pyret does not permit some of the more exotic
    names permitted by Scheme. For instance, one can write
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡å­˜åœ¨è¿™ç§ç¼©è¿›çº¦å®šï¼ŒPyret å¹¶ä¸å…è®¸ Scheme å…è®¸çš„ä¸€äº›æ›´å¥‡ç‰¹çš„åå­—ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥è¿™æ ·å†™
- en: '| (defineÂ e^i*piÂ -1) |'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define e^i*pi -1) |'
- en: in Scheme but that is not a valid variable name in Pyret.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Scheme ä¸­æ˜¯æœ‰æ•ˆçš„ï¼Œä½†åœ¨ Pyret ä¸­ä¸æ˜¯æœ‰æ•ˆçš„å˜é‡åã€‚
- en: 28.6Â Data Definitions[ğŸ”—](#(part._.Data_.Definitions) "Link to here")
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.6 æ•°æ®å®šä¹‰[ğŸ”—](#(part._.Data_.Definitions) "é“¾æ¥è‡³æ­¤")
- en: 'Pyret diverges from Racket (and even more so from Scheme) in its handling of
    data definitions. First, we will see how to define a structure:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret åœ¨å¤„ç†æ•°æ®å®šä¹‰æ–¹é¢ä¸ Racketï¼ˆç”šè‡³ä¸ Schemeï¼‰æœ‰æ‰€ä¸åŒã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å°†çœ‹åˆ°å¦‚ä½•å®šä¹‰ä¸€ä¸ªç»“æ„ï¼š
- en: '| RSW | Pyret |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| (define-structÂ ptÂ (xÂ y)) |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| (define-structÂ ptÂ (xÂ y)) |'
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'This might seem like a fair bit of overkill, but weâ€™ll see in a moment why
    itâ€™s useful. Meanwhile, itâ€™s worth observing that when you have only a single
    kind of datum in a data definition, it feels unwieldy to take up so many lines.
    Writing it on one line is valid, but now it feels ugly to have the `|` in the
    middle:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯èƒ½çœ‹èµ·æ¥æœ‰äº›è¿‡åº¦ï¼Œä½†æˆ‘ä»¬å°†å¾ˆå¿«çœ‹åˆ°ä¸ºä»€ä¹ˆå®ƒæ˜¯æœ‰ç”¨çš„ã€‚åŒæ—¶ï¼Œå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå½“æ•°æ®å®šä¹‰ä¸­åªæœ‰ä¸€ç§æ•°æ®ç±»å‹æ—¶ï¼Œå ç”¨è¿™ä¹ˆå¤šè¡Œæ¥ç¼–å†™å®ƒæ„Ÿè§‰å¾ˆä¸æ–¹ä¾¿ã€‚å°†å…¶å†™åœ¨ä¸€è¡Œæ˜¯æœ‰æ•ˆçš„ï¼Œä½†ç°åœ¨ä¸­é—´çš„
    `|` è®©ä»£ç çœ‹èµ·æ¥å¾ˆä¸‘ï¼š
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Therefore, Pyret permits you to drop the initial `|`, resulting in the more
    readable
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼ŒPyret å…è®¸ä½ çœç•¥åˆå§‹çš„ `|`ï¼Œä»è€Œä½¿å¾—ä»£ç æ›´æ˜“è¯»ã€‚
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now suppose we have two kinds of points. In the student languages of Racket,
    we would describe this with a comment:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨å‡è®¾æˆ‘ä»¬æœ‰ä¸¤ç§ç±»å‹çš„ç‚¹ã€‚åœ¨ Racket çš„å­¦ç”Ÿè¯­è¨€ä¸­ï¼Œæˆ‘ä»¬ä¼šç”¨æ³¨é‡Šæ¥æè¿°è¿™ä¸€ç‚¹ï¼š
- en: '| ;;Â AÂ PointÂ isÂ either |'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ;;Â ä¸€ä¸ªç‚¹å¯ä»¥æ˜¯ |'
- en: '| ;;Â -Â (ptÂ numberÂ number),Â or |'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ;;Â -Â (ptÂ numberÂ number),Â or |'
- en: '| ;;Â -Â (pt3dÂ numberÂ numberÂ number) |'
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ;;Â -Â (pt3dÂ numberÂ numberÂ number) |'
- en: 'In Pyret, we can express this directly:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Pyret ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥è¡¨è¾¾è¿™ä¸€ç‚¹ï¼š
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In short, Racket optimizes for the single-variant case, whereas Pyret optimizes
    for the multi-variant case. As a result, it is difficult to clearly express the
    multi-variant case in Racket, while it is unwieldy to express the single-variant
    case in Pyret.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ç®€è€Œè¨€ä¹‹ï¼ŒRacket ä¼˜åŒ–äº†å•å˜ä½“æƒ…å†µï¼Œè€Œ Pyret ä¼˜åŒ–äº†å¤šå˜ä½“æƒ…å†µã€‚å› æ­¤ï¼Œåœ¨ Racket ä¸­æ¸…æ¥šåœ°è¡¨è¾¾å¤šå˜ä½“æƒ…å†µå¾ˆå›°éš¾ï¼Œè€Œåœ¨ Pyret ä¸­è¡¨è¾¾å•å˜ä½“æƒ…å†µåˆ™æ˜¾å¾—ç¬¨æ‹™ã€‚
- en: 'For structures, both Racket and Pyret expose constructors, selectors, and predicates.
    Constructors are just functions:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºç»“æ„ï¼ŒRacket å’Œ Pyret éƒ½æš´éœ²äº†æ„é€ å‡½æ•°ã€é€‰æ‹©å™¨å’Œè°“è¯ã€‚æ„é€ å‡½æ•°åªæ˜¯å‡½æ•°ï¼š
- en: '| RSW | Pyret |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| (ptÂ 1Â 2) | `pt(1, 2)` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| (ptÂ 1Â 2) | `pt(1, 2)` |'
- en: 'Predicates are also functions with a particular naming scheme:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: è°“è¯ä¹Ÿæ˜¯éµå¾ªç‰¹å®šå‘½åæ–¹æ¡ˆçš„å‡½æ•°ï¼š
- en: '| RSW | Pyret |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| (pt?Â x) | is-pt(x) |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| (pt?Â x) | is-pt(x) |'
- en: 'and they behave the same way (returning true if the argument was constructed
    by that constructor, and false otherwise). In contrast, selection is different
    in the two languages (and we will see more about selection below, with `cases`):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒä»¬çš„è¡Œä¸ºæ–¹å¼ç›¸åŒï¼ˆå¦‚æœå‚æ•°æ˜¯ç”±è¯¥æ„é€ å‡½æ•°æ„é€ çš„ï¼Œåˆ™è¿”å› trueï¼Œå¦åˆ™è¿”å› falseï¼‰ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œé€‰æ‹©åœ¨ä¸¤ç§è¯­è¨€ä¸­æ˜¯ä¸åŒçš„ï¼ˆæˆ‘ä»¬å°†åœ¨ä¸‹é¢å…³äº `cases`
    çš„éƒ¨åˆ†ä¸­çœ‹åˆ°æ›´å¤šå…³äºé€‰æ‹©çš„å†…å®¹ï¼‰ï¼š
- en: '| RSW | Pyret |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| (pt-xÂ v) | `v.x` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| (pt-xÂ v) | `v.x` |'
- en: Note that in the Racket case, pt-x checks that the parameter was constructed
    by pt before extracting the value of the x field. Thus, pt-x and pt3d-x are two
    different functions and neither one can be used in place of the other. In contast,
    in Pyret, `.x` extracts an `x` field of any value that has such a field, without
    attention to how it was constructed. Thus, we can use `.x` on a value whether
    it was constructed by `pt` or `pt3d` (or indeed anything else with that field).
    In contrast, `cases` does pay attention to this distinction.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨ Racket çš„æƒ…å†µä¸‹ï¼Œpt-x åœ¨æå– x å­—æ®µçš„å€¼ä¹‹å‰ä¼šæ£€æŸ¥å‚æ•°æ˜¯å¦ç”± pt æ„é€ ã€‚å› æ­¤ï¼Œpt-x å’Œ pt3d-x æ˜¯ä¸¤ä¸ªä¸åŒçš„å‡½æ•°ï¼Œä¸èƒ½äº’ç›¸æ›¿ä»£ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œåœ¨
    Pyret ä¸­ï¼Œ`.x` ä»ä»»ä½•å…·æœ‰è¯¥å­—æ®µçš„å€¼ä¸­æå– `x` å­—æ®µï¼Œè€Œä¸è€ƒè™‘å®ƒæ˜¯å¦‚ä½•æ„é€ çš„ã€‚å› æ­¤ï¼Œæ— è®ºå€¼æ˜¯ç”± `pt` æˆ– `pt3d`ï¼ˆæˆ–ä»»ä½•å…¶ä»–å…·æœ‰è¯¥å­—æ®µçš„å¯¹è±¡ï¼‰æ„é€ çš„ï¼Œæˆ‘ä»¬éƒ½å¯ä»¥åœ¨å€¼ä¸Šä½¿ç”¨
    `.x`ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œ`cases` ä¼šæ³¨æ„è¿™ç§åŒºåˆ«ã€‚
- en: 28.7Â Conditionals[ğŸ”—](#(part._.Conditionals) "Link to here")
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.7 æ¡ä»¶[ğŸ”—](#(part._.Conditionals) "é“¾æ¥åˆ°æ­¤å¤„")
- en: There are several kinds of conditionals in Pyret, one more than in the Racket
    student languages.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret ä¸­æœ‰å‡ ç§æ¡ä»¶ç±»å‹ï¼Œæ¯” Racket çš„å­¦ç”Ÿè¯­è¨€å¤šä¸€ç§ã€‚
- en: General conditionals can be written using `if`, corresponding to Racketâ€™s `if`
    but with more syntax.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: é€šç”¨æ¡ä»¶å¯ä»¥ä½¿ç”¨ `if` è¡¨è¾¾ï¼Œå¯¹åº”äº Racket çš„ `if`ï¼Œä½†è¯­æ³•æ›´å¤æ‚ã€‚
- en: '| RSW | Pyret |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '|'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124; (ifÂ full-moon &#124;'
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '&#124; (ifÂ full-moon &#124;'
- en: '&#124; Â Â Â Â "howl" &#124;'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '&#124; Â Â Â Â "howl" &#124;'
- en: '&#124; Â Â Â Â "meow") &#124;'
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '&#124; Â Â Â Â "meow") &#124;'
- en: '|'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| RSW | Pyret |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '|'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124; (ifÂ full-moon &#124;'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '&#124; (ifÂ full-moon &#124;'
- en: '&#124; Â Â Â Â "howl" &#124;'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '&#124; Â Â Â Â "howl" &#124;'
- en: '&#124; Â Â Â Â (ifÂ new-moon &#124;'
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '&#124; Â Â Â Â (ifÂ new-moon &#124;'
- en: '&#124; Â Â Â Â Â Â Â Â "bark" &#124;'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '&#124; Â Â Â Â Â Â Â Â "bark" &#124;'
- en: '&#124; Â Â Â Â Â Â Â Â "meow")) &#124;'
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '&#124; Â Â Â Â Â Â Â Â "meow")) &#124;'
- en: '|'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Note that `if` includes `else if`, which makes it possible to list a collection
    of questions at the same level of indentation, which if in Racket does not have.
    The corresponding code in Racket would be written
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œ`if` åŒ…å« `else if`ï¼Œè¿™ä½¿å¾—å¯ä»¥åœ¨åŒä¸€ç¼©è¿›çº§åˆ«ä¸Šåˆ—å‡ºä¸€ç³»åˆ—é—®é¢˜ï¼Œè¿™åœ¨ Racket ä¸­æ˜¯ä¸å­˜åœ¨çš„ã€‚ç›¸åº”çš„ Racket ä»£ç å°†å†™æˆ
- en: '| (cond |'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (cond |'
- en: '| Â Â [full-moonÂ "howl"] |'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| Â Â [full-moonÂ "howl"] |'
- en: '| Â Â [new-moonÂ "bark"] |'
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| Â Â [new-moonÂ "bark"] |'
- en: '| Â Â [elseÂ "meow"]) |'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| Â Â [elseÂ "meow"]) |'
- en: 'to restore the indentation. There is a similar construct in Pyret called `ask`,
    designed to parallel `cond`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†æ¢å¤ç¼©è¿›ã€‚Pyret ä¸­æœ‰ä¸€ä¸ªç±»ä¼¼çš„æ„é€ ï¼Œç§°ä¸º `ask`ï¼Œæ—¨åœ¨ä¸ `cond` å¹³è¡Œï¼š
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In Racket, we also use `cond` to dispatch on a datatype:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Racket ä¸­ï¼Œæˆ‘ä»¬ä¹Ÿä½¿ç”¨ `cond` æ¥æ ¹æ®æ•°æ®ç±»å‹åˆ†å‘ï¼š
- en: '| (cond |'
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (cond |'
- en: '| Â Â [(pt?Â v)Â Â Â (+Â (pt-xÂ v)Â (pt-yÂ v))] |'
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|Â Â Â [(pt?Â v)Â Â Â (+Â (pt-xÂ v)Â (pt-yÂ v))] |'
- en: '| Â Â [(pt3d?Â v)Â (+Â (pt-xÂ v)Â (pt-zÂ v))]) |'
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|Â Â Â [(pt3d?Â v)Â (+Â (pt-xÂ v)Â (pt-zÂ v))]) |'
- en: 'We could write this in close parallel in Pyret:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥åœ¨ Pyret ä¸­ä»¥éå¸¸ç›¸ä¼¼çš„æ–¹å¼ç¼–å†™ï¼š
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'or even as:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ–è€…ç”šè‡³å¯ä»¥å†™æˆï¼š
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: (As in Racket student languages, the Pyret versions will signal an error if
    no branch of the conditional matched.)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: (ä¸ Racket å­¦ç”Ÿè¯­è¨€ä¸€æ ·ï¼Œå¦‚æœæ¡ä»¶åˆ†æ”¯æ²¡æœ‰åŒ¹é…ï¼ŒPyret ç‰ˆæœ¬å°†å‘å‡ºé”™è¯¯ä¿¡å·ã€‚)
- en: 'However, Pyret provides a special syntax just for data definitions:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼ŒPyret æä¾›äº†ä¸“é—¨ç”¨äºæ•°æ®å®šä¹‰çš„ç‰¹æ®Šè¯­æ³•ï¼š
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This checks that `v` is a `Point`, provides a clean syntactic way of identifying
    the different branches, and makes it possible to give a concise local name to
    each field position instead of having to use selectors like `.x`. In general,
    in Pyret we prefer to use `cases` to process data definitions. However, there
    are times when, for instance, there many variants of data but a function processes
    only very few of them. In such situations, it makes more sense to explicitly use
    predicates and selectors.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ£€æŸ¥ `v` æ˜¯å¦ä¸º `Point`ï¼Œæä¾›äº†ä¸€ç§å¹²å‡€çš„è¯­æ³•æ–¹å¼æ¥è¯†åˆ«ä¸åŒçš„åˆ†æ”¯ï¼Œå¹¶ä½¿å¾—ä¸ºæ¯ä¸ªå­—æ®µä½ç½®æä¾›ä¸€ä¸ªç®€æ´çš„å±€éƒ¨åç§°æˆä¸ºå¯èƒ½ï¼Œè€Œä¸æ˜¯å¿…é¡»ä½¿ç”¨é€‰æ‹©å™¨å¦‚
    `.x`ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œåœ¨ Pyret ä¸­ï¼Œæˆ‘ä»¬æ›´å–œæ¬¢ä½¿ç”¨ `cases` æ¥å¤„ç†æ•°æ®å®šä¹‰ã€‚ç„¶è€Œï¼Œæœ‰æ—¶ï¼Œä¾‹å¦‚ï¼Œæ•°æ®æœ‰å¤šç§å˜ä½“ï¼Œä½†å‡½æ•°åªå¤„ç†å…¶ä¸­çš„ä¸€å°éƒ¨åˆ†ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ˜¾å¼ä½¿ç”¨è°“è¯å’Œé€‰æ‹©å™¨æ›´æœ‰æ„ä¹‰ã€‚
- en: 28.8Â Lists[ğŸ”—](#(part._.Lists) "Link to here")
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.8Â åˆ—è¡¨[ğŸ”—](#(part._.Lists) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'In Racket, depending on the language level, lists are created using either
    cons or list, with empty for the empty list. The corresponding notions in Pyret
    are called `link`, `list`, and `empty`, respectively. `link` is a two-argument
    function, just as in Racket:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Racket ä¸­ï¼Œæ ¹æ®è¯­è¨€çº§åˆ«ï¼Œåˆ—è¡¨å¯ä»¥ä½¿ç”¨ cons æˆ– list åˆ›å»ºï¼Œç©ºåˆ—è¡¨ä½¿ç”¨ emptyã€‚Pyret ä¸­çš„å¯¹åº”æ¦‚å¿µåˆ†åˆ«ç§°ä¸º `link`ã€`list`
    å’Œ `empty`ã€‚`link` æ˜¯ä¸€ä¸ªæ¥å—ä¸¤ä¸ªå‚æ•°çš„å‡½æ•°ï¼Œå°±åƒåœ¨ Racket ä¸­ä¸€æ ·ï¼š
- en: '| RSW | Pyret |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| (consÂ 1Â empty) | `link(1, empty)` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| (consÂ 1Â empty) | `link(1, empty)` |'
- en: '| RSW | Pyret |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| (listÂ 1Â 2Â 3) | `[list: 1, 2, 3]` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| (listÂ 1Â 2Â 3) | `[list: 1, 2, 3]` |'
- en: 'Note that the syntax `[1, 2, 3]`, which represents lists in many languages,
    is not legal in Pyret: lists are not privileged with their own syntax. Rather,
    we must use an explicit constructor: just as `[list: 1, 2, 3]` constructs a list,
    `[set: 1, 2, 3]` constructs a set instead of a list.In fact, we can [create our
    own constructors](https://www.pyret.org/docs/latest/Expressions.html#%28part._s~3aconstruct-expr%29)
    and use them with this syntax.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ³¨æ„ï¼Œè¡¨ç¤ºåˆ—è¡¨çš„è¯­æ³• `[1, 2, 3]` åœ¨ Pyret ä¸­æ˜¯éæ³•çš„ï¼šåˆ—è¡¨æ²¡æœ‰è‡ªå·±çš„ä¸“ç”¨è¯­æ³•ã€‚ç›¸åï¼Œæˆ‘ä»¬å¿…é¡»ä½¿ç”¨æ˜¾å¼çš„æ„é€ å‡½æ•°ï¼šæ­£å¦‚ `[list:
    1, 2, 3]` æ„é€ åˆ—è¡¨ä¸€æ ·ï¼Œ`[set: 1, 2, 3]` æ„é€ é›†åˆè€Œä¸æ˜¯åˆ—è¡¨ã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥ [åˆ›å»ºè‡ªå·±çš„æ„é€ å‡½æ•°](https://www.pyret.org/docs/latest/Expressions.html#%28part._s~3aconstruct-expr%29)
    å¹¶ä½¿ç”¨è¿™ç§è¯­æ³•ã€‚'
- en: Exercise
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try typing `[1, 2, 3]` and see the error message.
  id: totrans-164
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°è¯•è¾“å…¥ `[1, 2, 3]` å¹¶æŸ¥çœ‹é”™è¯¯ä¿¡æ¯ã€‚
- en: 'This shows us how to construct lists. To take them apart, we use `cases`. There
    are two variants, `empty` and `link` (which we used to construct the lists):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å±•ç¤ºäº†å¦‚ä½•æ„é€ åˆ—è¡¨ã€‚è¦åˆ†è§£å®ƒä»¬ï¼Œæˆ‘ä»¬ä½¿ç”¨ `cases`ã€‚æœ‰ä¸¤ç§å˜ä½“ï¼Œ`empty` å’Œ `link`ï¼ˆæˆ‘ä»¬ç”¨æ¥æ„é€ åˆ—è¡¨ï¼‰ï¼š
- en: '| RSW | Pyret |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '|'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124; (cond &#124;'
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '&#124; (cond &#124;'
- en: '&#124; Â Â [(empty?Â l)Â 0] &#124;'
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '&#124;Â Â Â [(empty?Â l)Â 0] &#124;'
- en: '&#124; Â Â [(cons?Â l) &#124;'
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '&#124;Â Â Â [(cons?Â l) &#124;'
- en: '&#124; Â Â Â (+Â (firstÂ l) &#124;'
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '&#124;Â Â Â (+Â (firstÂ l) &#124;'
- en: '&#124; Â Â Â Â Â Â (gÂ (restÂ l)))]) &#124;'
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '&#124;Â Â Â Â Â (gÂ (restÂ l)))] &#124;'
- en: '|'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: It is conventional to call the fields `f` and `r` (for â€œfirstâ€ and â€œrestâ€).
    Of course, this convention does not work if there are other things by the same
    name; in particular, when writing a nested destructuring of a list, we conventionally
    write `fr` and `rr` (for â€œfirst of the restâ€ and â€œrest of the restâ€).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: é€šå¸¸å°†å­—æ®µå‘½åä¸º `f` å’Œ `r`ï¼ˆåˆ†åˆ«ä»£è¡¨â€œfirstâ€å’Œâ€œrestâ€ï¼‰ã€‚å½“ç„¶ï¼Œå¦‚æœå­˜åœ¨å…¶ä»–åŒåçš„äº‹ç‰©ï¼Œè¿™ç§çº¦å®šå°±ä¸é€‚ç”¨ï¼›ç‰¹åˆ«æ˜¯å½“ç¼–å†™åˆ—è¡¨çš„åµŒå¥—åˆ†è§£æ—¶ï¼Œæˆ‘ä»¬é€šå¸¸å†™æˆ
    `fr` å’Œ `rr`ï¼ˆåˆ†åˆ«ä»£è¡¨â€œfirst of the restâ€å’Œâ€œrest of the restâ€ï¼‰ã€‚
- en: 28.9Â First-Class Functions[ğŸ”—](#(part._.First-.Class_.Functions) "Link to here")
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.9Â ä¸€ç­‰å‡½æ•°[ğŸ”—](#(part._.First-.Class_.Functions) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'The equivalent of Racketâ€™s lambda is Pyretâ€™s `lam`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Racket çš„ lambda å¯¹åº”äº Pyret çš„ `lam`ï¼š
- en: '| RSW | Pyret |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| (lambdaÂ (xÂ y)Â (+Â xÂ y)) | `lam(x, y): x + y end` |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| (lambdaÂ (xÂ y)Â (+Â xÂ y)) | `lam(x, y): x + y end` |'
- en: 28.10Â Annotations[ğŸ”—](#(part._.Annotations) "Link to here")
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.10Â æ³¨è§£[ğŸ”—](#(part._.Annotations) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'In student Racket languages, annotations are usually written as comments:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å­¦ç”Ÿ Racket è¯­è¨€ä¸­ï¼Œæ³¨è§£é€šå¸¸ä»¥æ³¨é‡Šçš„å½¢å¼ä¹¦å†™ï¼š
- en: '| ;Â square:Â NumberÂ ->Â Number |'
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ;Â square:Â NumberÂ ->Â Number |'
- en: '| ;Â sort-nums:Â List<Number>Â ->Â List<Number> |'
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ;Â sort-nums:Â List<Number>Â ->Â List<Number> |'
- en: '| ;Â sort:Â List<T>Â *Â (TÂ *Â TÂ ->Â Boolean)Â ->Â List<T> |'
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ; sort: List<T> * (T * T -> Boolean) -> List<T> |'
- en: In Pyret, we write the annotations directly on the parameters and return values.
    Pyret will check them to a limited extent dynamically, and can check them statically
    with its type checker. The corresponding annotations to those above would be written
    as
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Pyret ä¸­ï¼Œæˆ‘ä»¬ç›´æ¥åœ¨å‚æ•°å’Œè¿”å›å€¼ä¸Šå†™æ³¨é‡Šã€‚Pyret å°†åœ¨æœ‰é™ç¨‹åº¦ä¸ŠåŠ¨æ€æ£€æŸ¥å®ƒä»¬ï¼Œå¹¶ä¸”å¯ä»¥ä½¿ç”¨å…¶ç±»å‹æ£€æŸ¥å™¨é™æ€æ£€æŸ¥å®ƒä»¬ã€‚ä¸Šè¿°å¯¹åº”çš„æ³¨é‡Šå°†å†™æˆ
- en: '[PRE16]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 28.11Â What Else?[ğŸ”—](#(part._.What_.Else_) "Link to here")
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.11 å…¶ä»–å†…å®¹ï¼Ÿ[ğŸ”—](#(part._.What_.Else_) "é“¾æ¥è‡³æ­¤")
- en: If there are other parts of Scheme or Racket syntax that you would like to see
    translated, please [let us know](http://cs.brown.edu/~sk/Contact/).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨æƒ³çœ‹åˆ° Scheme æˆ– Racket è¯­æ³•çš„å…¶ä»–éƒ¨åˆ†è¢«ç¿»è¯‘ï¼Œè¯·[å‘ŠçŸ¥æˆ‘ä»¬](http://cs.brown.edu/~sk/Contact/)ã€‚
- en: 28.1Â Numbers, Strings, and Booleans[ğŸ”—](#(part._.Numbers__.Strings__and_.Booleans)
    "Link to here")
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.1 æ•°å­—ã€å­—ç¬¦ä¸²å’Œå¸ƒå°”å€¼[ğŸ”—](#(part._.Numbers__.Strings__and_.Booleans) "é“¾æ¥è‡³æ­¤")
- en: Numbers are very similar between the two. Like Scheme, Pyret implements arbitrary-precision
    numbers and rationals. Some of the more exotic numeric systems of Scheme (such
    as complex numbers) arenâ€™t in Pyret; Pyret also treats imprecise numbers slightly
    differently.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸¤ä¸ªè¯­è¨€ä¸­çš„æ•°å­—éå¸¸ç›¸ä¼¼ã€‚åƒ Scheme ä¸€æ ·ï¼ŒPyret å®ç°äº†ä»»æ„ç²¾åº¦æ•°å­—å’Œæœ‰ç†æ•°ã€‚ä¸€äº› Scheme ä¸­æ›´å¥‡ç‰¹çš„æ•°å­—ç³»ç»Ÿï¼ˆå¦‚å¤æ•°ï¼‰ä¸åœ¨ Pyret
    ä¸­ï¼›Pyret è¿˜å¯¹ä¸ç²¾ç¡®æ•°å­—çš„å¤„ç†ç•¥æœ‰ä¸åŒã€‚
- en: '| RSW | Pyret |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| 1 | `1` |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `1` |'
- en: '| RSW | Pyret |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| 1/2 | `1/2` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 1/2 | `1/2` |'
- en: '| RSW | Pyret |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| #i3.14 | `~3.14` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| #i3.14 | `~3.14` |'
- en: Strings are also very similar, though Pyret allows you to use single-quotes
    as well.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: å­—ç¬¦ä¸²ä¹Ÿéå¸¸ç›¸ä¼¼ï¼Œå°½ç®¡ Pyret å…è®¸æ‚¨ä½¿ç”¨å•å¼•å·ã€‚
- en: '| RSW | Pyret |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| "Hello,Â world!" | `"Hello, world!"` |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| "Hello, world!" | `"Hello, world!"` |'
- en: '| RSW | Pyret |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| "\"Hello\",Â heÂ said" | `"\"Hello\", he said"` |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| "\"Hello\", he said" | `"\"Hello\", he said"` |'
- en: '| RSW | Pyret |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| "\"Hello\",Â heÂ said" | `''"Hello", he said''` |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| "\"Hello\", he said" | `''"Hello", he said''` |'
- en: 'Booleans have the same names:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: å¸ƒå°”å€¼å…·æœ‰ç›¸åŒçš„åç§°ï¼š
- en: '| RSW | Pyret |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| true | `true` |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| true | `true` |'
- en: '| RSW | Pyret |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| false | `false` |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| false | `false` |'
- en: 28.2Â Infix Expressions[ğŸ”—](#(part._.Infix_.Expressions) "Link to here")
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.2 ä¸­ç¼€è¡¨è¾¾å¼[ğŸ”—](#(part._.Infix_.Expressions) "é“¾æ¥è‡³æ­¤")
- en: 'Pyret uses an infix syntax, reminiscent of many other textual programming languages:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret ä½¿ç”¨ä¸­ç¼€è¯­æ³•ï¼Œè¿™è®©äººè”æƒ³åˆ°è®¸å¤šå…¶ä»–æ–‡æœ¬ç¼–ç¨‹è¯­è¨€ï¼š
- en: '| RSW | Pyret |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| (+Â 1Â 2) | `1 + 2` |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| (+ 1 2) | `1 + 2` |'
- en: '| RSW | Pyret |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| (*Â (-Â 4Â 2)Â 5) | `(4 - 2) * 5` |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| (* (- 4 2) 5) | `(4 - 2) * 5` |'
- en: 'Note that Pyret does not have rules about orders of precedence between operators,
    so when you mix operators, you have to parenthesize the expression to make your
    intent clear. When you chain the same operator you donâ€™t need to parenthesize;
    chaining associates to the left in both languages:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼ŒPyret æ²¡æœ‰å…³äºè¿ç®—ç¬¦ä¼˜å…ˆçº§é¡ºåºçš„è§„åˆ™ï¼Œæ‰€ä»¥å½“æ‚¨æ··åˆè¿ç®—ç¬¦æ—¶ï¼Œæ‚¨å¿…é¡»ä½¿ç”¨æ‹¬å·æ¥æ˜ç¡®æ‚¨çš„æ„å›¾ã€‚å½“æ‚¨é“¾å¼ä½¿ç”¨ç›¸åŒçš„è¿ç®—ç¬¦æ—¶ï¼Œæ‚¨ä¸éœ€è¦ä½¿ç”¨æ‹¬å·ï¼›é“¾å¼åœ¨ä¸¤ç§è¯­è¨€ä¸­éƒ½æ˜¯å·¦ç»“åˆçš„ï¼š
- en: '| RSW | Pyret |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| (/Â 1Â 2Â 3Â 4) | `1 / 2 / 3 / 4` |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| (/ 1 2 3 4) | `1 / 2 / 3 / 4` |'
- en: These both evaluate to 1/24.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸¤ä¸ªéƒ½ç­‰äº 1/24ã€‚
- en: 28.3Â Function Definition and Application[ğŸ”—](#(part._.Function_.Definition_and_.Application)
    "Link to here")
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.3 å‡½æ•°å®šä¹‰å’Œåº”ç”¨[ğŸ”—](#(part._.Function_.Definition_and_.Application) "é“¾æ¥è‡³æ­¤")
- en: 'Function definition and application in Pyret have an infix syntax, more reminiscent
    of many other textual programming languages. Application uses a syntax familiar
    from conventional algebra books:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret ä¸­çš„å‡½æ•°å®šä¹‰å’Œåº”ç”¨ä½¿ç”¨ä¸­ç¼€è¯­æ³•ï¼Œè¿™è®©äººè”æƒ³åˆ°è®¸å¤šå…¶ä»–æ–‡æœ¬ç¼–ç¨‹è¯­è¨€ã€‚åº”ç”¨ä½¿ç”¨ä»ä¼ ç»Ÿä»£æ•°ä¹¦ç±ä¸­ç†Ÿæ‚‰çš„è¯­æ³•ï¼š
- en: '| RSW | Pyret |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| (distÂ 3Â 4) | `dist(3, 4)` |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| (dist 3 4) | `dist(3, 4)` |'
- en: 'Application correspondingly uses a similar syntax in function headers, and
    infix in the body:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: å‡½æ•°å¤´ä¸­ç›¸åº”åœ°ä½¿ç”¨ç±»ä¼¼çš„è¯­æ³•ï¼Œè€Œåœ¨å‡½æ•°ä½“ä¸­ä½¿ç”¨ä¸­ç¼€è¯­æ³•ï¼š
- en: '| RSW | Pyret |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '|'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124; (defineÂ (distÂ xÂ y) &#124;'
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '| (define (dist x y) | '
- en: '&#124; Â Â (sqrtÂ (+Â (*Â xÂ x) &#124;'
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '| | (sqrt (+ (* x x) | '
- en: '&#124; Â Â Â Â Â Â Â Â Â Â Â (*Â yÂ y)))) &#124;'
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '| | (* y y)))) | '
- en: '|'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 28.4Â Tests[ğŸ”—](#(part._.Tests) "Link to here")
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.4 æµ‹è¯•[ğŸ”—](#(part._.Tests) "é“¾æ¥è‡³æ­¤")
- en: 'There are essentially three different ways of writing the equivalent of Racketâ€™s
    check-expect tests. They can be translated into check blocks:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šï¼Œæœ‰ä¸‰ç§ä¸åŒçš„æ–¹å¼æ¥ç¼–å†™ Racket çš„ check-expect æµ‹è¯•çš„ç­‰ä»·ç‰©ã€‚å®ƒä»¬å¯ä»¥ç¿»è¯‘æˆæ£€æŸ¥å—ï¼š
- en: '| RSW | Pyret |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| (check-expectÂ 1Â 1) |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| (check-expect 1 1) | '
- en: '[PRE18]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Note that multiple tests can be put into a single block:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå¤šä¸ªæµ‹è¯•å¯ä»¥æ”¾å…¥ä¸€ä¸ªå•ç‹¬çš„å—ä¸­ï¼š
- en: '| RSW | Pyret |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '|'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124; (check-expectÂ 1Â 1) &#124;'
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '| (check-expect 1 1) | '
- en: '&#124; (check-expectÂ 2Â 2) &#124;'
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '| (check-expect 2 2) | '
- en: '|'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE19]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'The second way is this: as an alias for `check` we can also write `examples`.
    The two are functionally identical, but they capture the human difference between
    examples (which explore the problem, and are written before attempting a solution)
    and tests (which try to find bugs in the solution, and are written to probe its
    design).'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬äºŒç§æ–¹æ³•æ˜¯ï¼šä½œä¸º`check`çš„åˆ«åï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å†™æˆ`examples`ã€‚è¿™ä¸¤ä¸ªåœ¨åŠŸèƒ½ä¸Šæ˜¯ç›¸åŒçš„ï¼Œä½†å®ƒä»¬æ•æ‰äº†ä¾‹å­ï¼ˆæ¢ç´¢é—®é¢˜ï¼Œåœ¨å°è¯•è§£å†³æ–¹æ¡ˆä¹‹å‰ç¼–å†™ï¼‰å’Œæµ‹è¯•ï¼ˆè¯•å›¾åœ¨è§£å†³æ–¹æ¡ˆä¸­æ‰¾åˆ°é”™è¯¯ï¼Œå¹¶ç¼–å†™æ¥æ¢æµ‹å…¶è®¾è®¡ï¼‰ä¹‹é—´çš„äººç±»å·®å¼‚ã€‚
- en: 'The third way is to write a `where` block to accompany a function definition.
    For instance:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸‰ç§æ–¹æ³•æ˜¯ç¼–å†™ä¸€ä¸ª`where`å—æ¥ä¼´éšå‡½æ•°å®šä¹‰ã€‚ä¾‹å¦‚ï¼š
- en: '[PRE20]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These can even be written for internal functions (i.e., functions contained
    inside other functions), which isnâ€™t true for check-expect.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›ç”šè‡³å¯ä»¥æ˜¯ä¸ºå†…éƒ¨å‡½æ•°ï¼ˆå³åŒ…å«åœ¨å…¶ä»–å‡½æ•°ä¸­çš„å‡½æ•°ï¼‰ç¼–å†™çš„ï¼Œè¿™å¯¹äºcheck-expectæ¥è¯´å¹¶ä¸æˆç«‹ã€‚
- en: 'In Pyret, unlike in Racket, a testing block can contain a documentation string.
    This is used by Pyret when reporting test successes and failures. For instance,
    try to run and see what you get:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Pyretä¸­ï¼Œä¸Racketä¸åŒï¼Œæµ‹è¯•å—å¯ä»¥åŒ…å«æ–‡æ¡£å­—ç¬¦ä¸²ã€‚å½“PyretæŠ¥å‘Šæµ‹è¯•æˆåŠŸå’Œå¤±è´¥æ—¶ï¼Œä¼šä½¿ç”¨è¿™ä¸ªå­—ç¬¦ä¸²ã€‚ä¾‹å¦‚ï¼Œå°è¯•è¿è¡Œå¹¶æŸ¥çœ‹ä½ å¾—åˆ°çš„ç»“æœï¼š
- en: '[PRE21]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is useful for documenting the purpose of a testing block.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯¹äºè®°å½•æµ‹è¯•å—çš„ç›®çš„å¾ˆæœ‰ç”¨ã€‚
- en: Just as in Racket, there are many testing operators in Pyret (in addition to
    `is`). See [the documentation](https://www.pyret.org/docs/latest/testing.html).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: å°±åƒåœ¨Racketä¸­ä¸€æ ·ï¼ŒPyretä¸­æœ‰è®¸å¤šæµ‹è¯•è¿ç®—ç¬¦ï¼ˆé™¤äº†`is`ä¹‹å¤–ï¼‰ã€‚å‚è§[æ–‡æ¡£](https://www.pyret.org/docs/latest/testing.html)ã€‚
- en: 28.5Â Variable Names[ğŸ”—](#(part._.Variable_.Names) "Link to here")
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.5 å˜é‡å[ğŸ”—](#(part._.Variable_.Names) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Both languages have a fairly permissive system for naming variables. While
    you can use CamelCase and under_scores in both, it is conventional to instead
    use what is known as [kebab-case](http://c2.com/cgi/wiki?KebabCase).This name
    is inaccurate. The word â€œkebabâ€ just means â€œmeatâ€. The skewer is the â€œshishâ€.
    Therefore, it ought to at least be called â€œshish kebab caseâ€. Thus:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸¤ç§è¯­è¨€éƒ½æœ‰ç›¸å½“å®½å®¹çš„å˜é‡å‘½åç³»ç»Ÿã€‚è™½ç„¶ä½ å¯ä»¥åœ¨ä¸¤è€…ä¸­ä½¿ç”¨é©¼å³°å¼å’Œä¸‹åˆ’çº¿ï¼Œä½†ä¼ ç»Ÿä¸Šä½¿ç”¨çš„æ˜¯æ‰€è°“çš„[kebab-case](http://c2.com/cgi/wiki?KebabCase)ã€‚è¿™ä¸ªåç§°ä¸å‡†ç¡®ã€‚å•è¯â€œkebabâ€åªæ˜¯æ„å‘³ç€â€œè‚‰â€ã€‚ä¸²çƒ¤æ¶æ˜¯â€œshishâ€ã€‚å› æ­¤ï¼Œè‡³å°‘åº”è¯¥è¢«ç§°ä¸ºâ€œshish
    kebab caseâ€ã€‚å› æ­¤ï¼š
- en: '| RSW | Pyret |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| this-is-a-name | `this-is-a-name` |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| this-is-a-name | `this-is-a-name` |'
- en: Even though Pyret has infix subtraction, the language can unambiguously tell
    apart `this-name` (a variable) from `this - name` (a subtraction expression) because
    the `-` in the latter must be surrounded by spaces.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡Pyretæœ‰ä¸­ç¼€å‡æ³•ï¼Œä½†è¯­è¨€å¯ä»¥æ˜ç¡®åœ°åŒºåˆ†`this-name`ï¼ˆä¸€ä¸ªå˜é‡ï¼‰å’Œ`this - name`ï¼ˆä¸€ä¸ªå‡æ³•è¡¨è¾¾å¼ï¼‰ï¼Œå› ä¸ºåè€…çš„`-`å¿…é¡»è¢«ç©ºæ ¼åŒ…å›´ã€‚
- en: Despite this spacing convention, Pyret does not permit some of the more exotic
    names permitted by Scheme. For instance, one can write
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡æœ‰è¿™ç§é—´è·çº¦å®šï¼ŒPyretä¸å…è®¸Schemeå…è®¸çš„ä¸€äº›æ›´å¥‡ç‰¹çš„åå­—ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥è¿™æ ·å†™
- en: '| (defineÂ e^i*piÂ -1) |'
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (defineÂ e^i*piÂ -1) |'
- en: in Scheme but that is not a valid variable name in Pyret.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Schemeä¸­æ˜¯æœ‰æ•ˆçš„ï¼Œä½†åœ¨Pyretä¸­ä¸æ˜¯æœ‰æ•ˆçš„å˜é‡åã€‚
- en: 28.6Â Data Definitions[ğŸ”—](#(part._.Data_.Definitions) "Link to here")
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.6 æ•°æ®å®šä¹‰[ğŸ”—](#(part._.Data_.Definitions) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Pyret diverges from Racket (and even more so from Scheme) in its handling of
    data definitions. First, we will see how to define a structure:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Pyretåœ¨å¤„ç†æ•°æ®å®šä¹‰æ–¹é¢ä¸Racketï¼ˆç”šè‡³æ›´ä¸ç”¨è¯´Schemeï¼‰æœ‰æ‰€ä¸åŒã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å°†çœ‹åˆ°å¦‚ä½•å®šä¹‰ä¸€ä¸ªç»“æ„ï¼š
- en: '| RSW | Pyret |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| (define-structÂ ptÂ (xÂ y)) |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| (define-structÂ ptÂ (xÂ y)) |'
- en: '[PRE22]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'This might seem like a fair bit of overkill, but weâ€™ll see in a moment why
    itâ€™s useful. Meanwhile, itâ€™s worth observing that when you have only a single
    kind of datum in a data definition, it feels unwieldy to take up so many lines.
    Writing it on one line is valid, but now it feels ugly to have the `|` in the
    middle:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯èƒ½çœ‹èµ·æ¥æœ‰äº›è¿‡åº¦ï¼Œä½†æˆ‘ä»¬å°†å¾ˆå¿«çœ‹åˆ°ä¸ºä»€ä¹ˆå®ƒæ˜¯æœ‰ç”¨çš„ã€‚åŒæ—¶ï¼Œå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå½“æ•°æ®å®šä¹‰ä¸­åªæœ‰ä¸€ä¸ªæ•°æ®ç±»å‹æ—¶ï¼Œå ç”¨è¿™ä¹ˆå¤šè¡Œä¼šæ„Ÿè§‰éš¾ä»¥ç®¡ç†ã€‚åœ¨ä¸€è¡Œä¸­å†™å®ƒæ˜¯æœ‰æ•ˆçš„ï¼Œä½†ç°åœ¨ä¸­é—´çš„`|`çœ‹èµ·æ¥å¾ˆä¸‘é™‹ï¼š
- en: '[PRE23]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Therefore, Pyret permits you to drop the initial `|`, resulting in the more
    readable
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼ŒPyretå…è®¸ä½ çœç•¥å¼€å¤´çš„`|`ï¼Œä»è€Œä½¿å…¶æ›´æ˜“äºé˜…è¯»
- en: '[PRE24]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now suppose we have two kinds of points. In the student languages of Racket,
    we would describe this with a comment:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨å‡è®¾æˆ‘ä»¬æœ‰ä¸¤ç§ç±»å‹çš„ç‚¹ã€‚åœ¨Racketçš„å­¦ç”Ÿè¯­è¨€ä¸­ï¼Œæˆ‘ä»¬ä¼šç”¨æ³¨é‡Šæ¥æè¿°è¿™ä¸€ç‚¹ï¼š
- en: '| ;;Â AÂ PointÂ isÂ either |'
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ;;Â AÂ PointÂ isÂ either |'
- en: '| ;;Â -Â (ptÂ numberÂ number),Â or |'
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ;;Â -Â (ptÂ numberÂ number),Â or |'
- en: '| ;;Â -Â (pt3dÂ numberÂ numberÂ number) |'
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ;;Â -Â (pt3dÂ numberÂ numberÂ number) |'
- en: 'In Pyret, we can express this directly:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Pyretä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥è¡¨è¾¾è¿™ä¸€ç‚¹ï¼š
- en: '[PRE25]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In short, Racket optimizes for the single-variant case, whereas Pyret optimizes
    for the multi-variant case. As a result, it is difficult to clearly express the
    multi-variant case in Racket, while it is unwieldy to express the single-variant
    case in Pyret.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ç®€è€Œè¨€ä¹‹ï¼ŒRacketä¼˜åŒ–äº†å•å˜ä½“æƒ…å†µï¼Œè€ŒPyretä¼˜åŒ–äº†å¤šå˜ä½“æƒ…å†µã€‚å› æ­¤ï¼Œåœ¨Racketä¸­æ¸…æ¥šåœ°è¡¨è¾¾å¤šå˜ä½“æƒ…å†µæ¯”è¾ƒå›°éš¾ï¼Œè€Œåœ¨Pyretä¸­è¡¨è¾¾å•å˜ä½“æƒ…å†µåˆ™æ˜¾å¾—ç¬¨æ‹™ã€‚
- en: 'For structures, both Racket and Pyret expose constructors, selectors, and predicates.
    Constructors are just functions:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºç»“æ„ä½“ï¼ŒRacketå’ŒPyretéƒ½æš´éœ²äº†æ„é€ å‡½æ•°ã€é€‰æ‹©å™¨å’Œæ–­è¨€ã€‚æ„é€ å‡½æ•°åªæ˜¯å‡½æ•°ï¼š
- en: '| RSW | Pyret |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| (ptÂ 1Â 2) | `pt(1, 2)` |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â (ptÂ 1Â 2) |Â Â Â `pt(1, 2)` |'
- en: 'Predicates are also functions with a particular naming scheme:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: æ–­è¨€ä¹Ÿæ˜¯éµå¾ªç‰¹å®šå‘½åçº¦å®šçš„å‡½æ•°ï¼š
- en: '| RSW | Pyret |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| (pt?Â x) | is-pt(x) |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â (pt?Â x) | is-pt(x) |'
- en: 'and they behave the same way (returning true if the argument was constructed
    by that constructor, and false otherwise). In contrast, selection is different
    in the two languages (and we will see more about selection below, with `cases`):'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒä»¬çš„è¡Œä¸ºæ–¹å¼ç›¸åŒï¼ˆå¦‚æœå‚æ•°æ˜¯ç”±è¯¥æ„é€ å‡½æ•°æ„é€ çš„ï¼Œåˆ™è¿”å›trueï¼Œå¦åˆ™è¿”å›falseï¼‰ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œé€‰æ‹©åœ¨ä¸¤ç§è¯­è¨€ä¸­æ˜¯ä¸åŒçš„ï¼ˆæˆ‘ä»¬å°†åœ¨ä¸‹é¢å…³äº`cases`çš„è®¨è®ºä¸­çœ‹åˆ°æ›´å¤šå…³äºé€‰æ‹©çš„å†…å®¹ï¼‰ï¼š
- en: '| RSW | Pyret |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| (pt-xÂ v) | `v.x` |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â (pt-xÂ v) | `v.x` |'
- en: Note that in the Racket case, pt-x checks that the parameter was constructed
    by pt before extracting the value of the x field. Thus, pt-x and pt3d-x are two
    different functions and neither one can be used in place of the other. In contast,
    in Pyret, `.x` extracts an `x` field of any value that has such a field, without
    attention to how it was constructed. Thus, we can use `.x` on a value whether
    it was constructed by `pt` or `pt3d` (or indeed anything else with that field).
    In contrast, `cases` does pay attention to this distinction.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨Racketçš„æƒ…å†µä¸‹ï¼Œpt-xåœ¨æå–xå­—æ®µçš„å€¼ä¹‹å‰ä¼šæ£€æŸ¥å‚æ•°æ˜¯å¦æ˜¯ç”±ptæ„é€ çš„ã€‚å› æ­¤ï¼Œpt-xå’Œpt3d-xæ˜¯ä¸¤ä¸ªä¸åŒçš„å‡½æ•°ï¼Œä¸èƒ½äº’ç›¸æ›¿ä»£ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œåœ¨Pyretä¸­ï¼Œ`.x`ä¼šä»ä»»ä½•å…·æœ‰è¯¥å­—æ®µçš„å€¼ä¸­æå–`x`å­—æ®µï¼Œè€Œä¸è€ƒè™‘å®ƒæ˜¯å¦‚ä½•æ„é€ çš„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ç”±`pt`æˆ–`pt3d`ï¼ˆæˆ–ä»»ä½•å…¶ä»–å…·æœ‰è¯¥å­—æ®µçš„å¯¹è±¡ï¼‰æ„é€ çš„å€¼ä¸Šä½¿ç”¨`.x`ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œ`cases`åˆ™æ³¨æ„è¿™ç§åŒºåˆ«ã€‚
- en: 28.7Â Conditionals[ğŸ”—](#(part._.Conditionals) "Link to here")
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.7 æ¡ä»¶è¯­å¥[ğŸ”—](#(part._.Conditionals) "é“¾æ¥åˆ°æ­¤å¤„")
- en: There are several kinds of conditionals in Pyret, one more than in the Racket
    student languages.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Pyretä¸­æœ‰å‡ ç§æ¡ä»¶è¯­å¥ï¼Œæ¯”Racketçš„å­¦ç”Ÿè¯­è¨€å¤šä¸€ç§ã€‚
- en: General conditionals can be written using `if`, corresponding to Racketâ€™s `if`
    but with more syntax.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: é€šç”¨æ¡ä»¶è¯­å¥å¯ä»¥ä½¿ç”¨ `if` æ¥ç¼–å†™ï¼Œå¯¹åº”äºRacketçš„ `if`ï¼Œä½†è¯­æ³•æ›´ä¸°å¯Œã€‚
- en: '| RSW | Pyret |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '|'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124; (ifÂ full-moon &#124;'
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|Â Â Â (ifÂ æ»¡æœˆ |'
- en: '&#124; Â Â Â Â "howl" &#124;'
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|Â Â Â "howl" |'
- en: '&#124; Â Â Â Â "meow") &#124;'
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|Â Â Â "meow") |Â Â Â "å–µå–µ" |'
- en: '|'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE26]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| RSW | Pyret |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '|'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124; (ifÂ full-moon &#124;'
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|Â Â Â (ifÂ æ»¡æœˆ |'
- en: '&#124; Â Â Â Â "howl" &#124;'
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|Â Â Â "howl" |'
- en: '&#124; Â Â Â Â (ifÂ new-moon &#124;'
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|Â Â Â (ifÂ new-moon |'
- en: '&#124; Â Â Â Â Â Â Â Â "bark" &#124;'
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|Â Â Â "å å«" |'
- en: '&#124; Â Â Â Â Â Â Â Â "meow")) &#124;'
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|Â Â Â "meow")) |Â Â Â "å–µå–µ" |'
- en: '|'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Note that `if` includes `else if`, which makes it possible to list a collection
    of questions at the same level of indentation, which if in Racket does not have.
    The corresponding code in Racket would be written
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œ`if` åŒ…å« `else if`ï¼Œè¿™ä½¿å¾—å¯ä»¥åœ¨åŒä¸€ç¼©è¿›çº§åˆ«ä¸Šåˆ—å‡ºä¸€ç³»åˆ—é—®é¢˜ï¼Œè¿™åœ¨Racketä¸­æ˜¯ä¸å…·å¤‡çš„ã€‚åœ¨Racketä¸­å¯¹åº”çš„ä»£ç å°†å†™æˆ
- en: '| (cond |'
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (cond |'
- en: '| Â Â [full-moonÂ "howl"] |'
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|Â Â Â [æ»¡æœˆÂ "å—¥å«"] |'
- en: '| Â Â [new-moonÂ "bark"] |'
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|Â Â Â [æ–°æœˆÂ "å å«"] |'
- en: '| Â Â [elseÂ "meow"]) |'
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|Â Â Â [elseÂ "meow"]) |'
- en: 'to restore the indentation. There is a similar construct in Pyret called `ask`,
    designed to parallel `cond`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†æ¢å¤ç¼©è¿›ã€‚Pyretä¸­æœ‰ä¸€ä¸ªç±»ä¼¼çš„æ„é€ ï¼Œç§°ä¸º`ask`ï¼Œæ—¨åœ¨ä¸`cond`å¹³è¡Œï¼š
- en: '[PRE28]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In Racket, we also use `cond` to dispatch on a datatype:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Racketä¸­ï¼Œæˆ‘ä»¬åŒæ ·ä½¿ç”¨ `cond` æ¥æ ¹æ®æ•°æ®ç±»å‹è¿›è¡Œåˆ†å‘ï¼š
- en: '| (cond |'
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (cond |'
- en: '| Â Â [(pt?Â v)Â Â Â (+Â (pt-xÂ v)Â (pt-yÂ v))] |'
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|Â Â Â [(pt?Â v)Â Â Â (+Â (pt-xÂ v)Â (pt-yÂ v))] |'
- en: '| Â Â [(pt3d?Â v)Â (+Â (pt-xÂ v)Â (pt-zÂ v))]) |'
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|Â Â Â [(pt3d?Â v)Â (+Â (pt-xÂ v)Â (pt-zÂ v))] |'
- en: 'We could write this in close parallel in Pyret:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥åœ¨Pyretä¸­éå¸¸ç›¸ä¼¼åœ°å†™å‡ºï¼š
- en: '[PRE29]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'or even as:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ–è€…ç”šè‡³å¯ä»¥å†™æˆï¼š
- en: '[PRE30]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: (As in Racket student languages, the Pyret versions will signal an error if
    no branch of the conditional matched.)
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆä¸Racketçš„å­¦ç”Ÿè¯­è¨€ä¸€æ ·ï¼Œå¦‚æœæ¡ä»¶è¯­å¥çš„ä»»ä½•åˆ†æ”¯éƒ½æ²¡æœ‰åŒ¹é…ï¼ŒPyretç‰ˆæœ¬å°†å‘å‡ºé”™è¯¯ä¿¡å·ã€‚ï¼‰
- en: 'However, Pyret provides a special syntax just for data definitions:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼ŒPyretæä¾›äº†ä¸€ç§ç‰¹æ®Šçš„è¯­æ³•ï¼Œä¸“é—¨ç”¨äºæ•°æ®å®šä¹‰ï¼š
- en: '[PRE31]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This checks that `v` is a `Point`, provides a clean syntactic way of identifying
    the different branches, and makes it possible to give a concise local name to
    each field position instead of having to use selectors like `.x`. In general,
    in Pyret we prefer to use `cases` to process data definitions. However, there
    are times when, for instance, there many variants of data but a function processes
    only very few of them. In such situations, it makes more sense to explicitly use
    predicates and selectors.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ£€æŸ¥ `v` æ˜¯å¦ä¸º `Point`ï¼Œæä¾›äº†ä¸€ç§å¹²å‡€çš„è¯­æ³•æ–¹å¼æ¥è¯†åˆ«ä¸åŒçš„åˆ†æ”¯ï¼Œå¹¶ä½¿å¾—ä¸ºæ¯ä¸ªå­—æ®µä½ç½®æä¾›ä¸€ä¸ªç®€æ´çš„å±€éƒ¨åç§°æˆä¸ºå¯èƒ½ï¼Œè€Œä¸æ˜¯å¿…é¡»ä½¿ç”¨é€‰æ‹©å™¨å¦‚
    `.x`ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œåœ¨ Pyret ä¸­ï¼Œæˆ‘ä»¬æ›´å–œæ¬¢ä½¿ç”¨ `cases` æ¥å¤„ç†æ•°æ®å®šä¹‰ã€‚ç„¶è€Œï¼Œæœ‰æ—¶ï¼Œä¾‹å¦‚ï¼Œæ•°æ®æœ‰å¤šç§å˜ä½“ï¼Œä½†å‡½æ•°åªå¤„ç†å…¶ä¸­çš„ä¸€å°éƒ¨åˆ†ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ˜¾å¼ä½¿ç”¨è°“è¯å’Œé€‰æ‹©å™¨æ›´æœ‰æ„ä¹‰ã€‚
- en: 28.8Â Lists[ğŸ”—](#(part._.Lists) "Link to here")
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.8 åˆ—è¡¨[ğŸ”—](#(part._.Lists) "é“¾æ¥è‡³æ­¤")
- en: 'In Racket, depending on the language level, lists are created using either
    cons or list, with empty for the empty list. The corresponding notions in Pyret
    are called `link`, `list`, and `empty`, respectively. `link` is a two-argument
    function, just as in Racket:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Racket ä¸­ï¼Œæ ¹æ®è¯­è¨€çº§åˆ«ï¼Œåˆ—è¡¨çš„åˆ›å»ºä½¿ç”¨ cons æˆ– listï¼Œç©ºåˆ—è¡¨ä½¿ç”¨ emptyã€‚Pyret ä¸­çš„å¯¹åº”æ¦‚å¿µåˆ†åˆ«ç§°ä¸º `link`ã€`list`
    å’Œ `empty`ã€‚`link` æ˜¯ä¸€ä¸ªæ¥å—ä¸¤ä¸ªå‚æ•°çš„å‡½æ•°ï¼Œå°±åƒåœ¨ Racket ä¸­ä¸€æ ·ï¼š
- en: '| RSW | Pyret |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| (consÂ 1Â empty) | `link(1, empty)` |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| (cons 1 empty) | `link(1, empty)` |'
- en: '| RSW | Pyret |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| (listÂ 1Â 2Â 3) | `[list: 1, 2, 3]` |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| (list 1 2 3) | `[list: 1, 2, 3]` |'
- en: 'Note that the syntax `[1, 2, 3]`, which represents lists in many languages,
    is not legal in Pyret: lists are not privileged with their own syntax. Rather,
    we must use an explicit constructor: just as `[list: 1, 2, 3]` constructs a list,
    `[set: 1, 2, 3]` constructs a set instead of a list.In fact, we can [create our
    own constructors](https://www.pyret.org/docs/latest/Expressions.html#%28part._s~3aconstruct-expr%29)
    and use them with this syntax.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ³¨æ„ï¼Œåœ¨è®¸å¤šè¯­è¨€ä¸­è¡¨ç¤ºåˆ—è¡¨çš„è¯­æ³• `[1, 2, 3]` åœ¨ Pyret ä¸­æ˜¯éæ³•çš„ï¼šåˆ—è¡¨æ²¡æœ‰è‡ªå·±çš„ç‰¹æƒè¯­æ³•ã€‚ç›¸åï¼Œæˆ‘ä»¬å¿…é¡»ä½¿ç”¨æ˜¾å¼çš„æ„é€ å™¨ï¼šæ­£å¦‚ `[list:
    1, 2, 3]` æ„å»ºä¸€ä¸ªåˆ—è¡¨ä¸€æ ·ï¼Œ`[set: 1, 2, 3]` æ„å»ºä¸€ä¸ªé›†åˆè€Œä¸æ˜¯åˆ—è¡¨ã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥[åˆ›å»ºè‡ªå·±çš„æ„é€ å™¨](https://www.pyret.org/docs/latest/Expressions.html#%28part._s~3aconstruct-expr%29)å¹¶ä½¿ç”¨è¿™ç§è¯­æ³•ã€‚'
- en: Exercise
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try typing `[1, 2, 3]` and see the error message.
  id: totrans-339
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°è¯•è¾“å…¥ `[1, 2, 3]` å¹¶æŸ¥çœ‹é”™è¯¯ä¿¡æ¯ã€‚
- en: 'This shows us how to construct lists. To take them apart, we use `cases`. There
    are two variants, `empty` and `link` (which we used to construct the lists):'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å±•ç¤ºäº†æˆ‘ä»¬å¦‚ä½•æ„å»ºåˆ—è¡¨ã€‚è¦åˆ†è§£å®ƒä»¬ï¼Œæˆ‘ä»¬ä½¿ç”¨ `cases`ã€‚æœ‰ä¸¤ç§å˜ä½“ï¼Œ`empty` å’Œ `link`ï¼ˆæˆ‘ä»¬ç”¨æ¥æ„å»ºåˆ—è¡¨ï¼‰ï¼š
- en: '| RSW | Pyret |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '|'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124; (cond &#124;'
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '&#124; (cond &#124;'
- en: '&#124; Â Â [(empty?Â l)Â 0] &#124;'
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '&#124; [(empty? l) 0] &#124;'
- en: '&#124; Â Â [(cons?Â l) &#124;'
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '&#124; [(cons? l) &#124;'
- en: '&#124; Â Â Â (+Â (firstÂ l) &#124;'
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '&#124; (+ (first l) &#124;'
- en: '&#124; Â Â Â Â Â Â (gÂ (restÂ l)))]) &#124;'
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '&#124; (g (rest l)))]) &#124;'
- en: '|'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE32]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: It is conventional to call the fields `f` and `r` (for â€œfirstâ€ and â€œrestâ€).
    Of course, this convention does not work if there are other things by the same
    name; in particular, when writing a nested destructuring of a list, we conventionally
    write `fr` and `rr` (for â€œfirst of the restâ€ and â€œrest of the restâ€).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: é€šå¸¸å°†å­—æ®µç§°ä¸º `f` å’Œ `r`ï¼ˆåˆ†åˆ«ä»£è¡¨â€œç¬¬ä¸€ä¸ªâ€å’Œâ€œå…¶ä½™â€ï¼‰ã€‚å½“ç„¶ï¼Œå¦‚æœå­˜åœ¨å…¶ä»–åŒåçš„äº‹ç‰©ï¼Œè¿™ç§çº¦å®šå°±ä¸é€‚ç”¨ï¼›ç‰¹åˆ«æ˜¯åœ¨ç¼–å†™åˆ—è¡¨çš„åµŒå¥—è§£æ„æ—¶ï¼Œæˆ‘ä»¬é€šå¸¸å†™ä½œ
    `fr` å’Œ `rr`ï¼ˆåˆ†åˆ«ä»£è¡¨â€œå…¶ä½™çš„ç¬¬ä¸€ä¸ªâ€å’Œâ€œå…¶ä½™çš„å…¶ä½™â€ï¼‰ã€‚
- en: 28.9Â First-Class Functions[ğŸ”—](#(part._.First-.Class_.Functions) "Link to here")
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.9 é¦–ç±»å‡½æ•°[ğŸ”—](#(part._.First-.Class_.Functions) "é“¾æ¥è‡³æ­¤")
- en: 'The equivalent of Racketâ€™s lambda is Pyretâ€™s `lam`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Racket çš„ lambda çš„ç­‰ä»·ç‰©æ˜¯ Pyret çš„ `lam`ï¼š
- en: '| RSW | Pyret |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| RSW | Pyret |'
- en: '| (lambdaÂ (xÂ y)Â (+Â xÂ y)) | `lam(x, y): x + y end` |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| (lambda (x y) (+ x y)) | `lam(x, y): x + y end` |'
- en: 28.10Â Annotations[ğŸ”—](#(part._.Annotations) "Link to here")
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.10 æ³¨é‡Š[ğŸ”—](#(part._.Annotations) "é“¾æ¥è‡³æ­¤")
- en: 'In student Racket languages, annotations are usually written as comments:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å­¦ç”Ÿ Racket è¯­è¨€ä¸­ï¼Œæ³¨é‡Šé€šå¸¸ä»¥æ³¨é‡Šçš„å½¢å¼ç¼–å†™ï¼š
- en: '| ;Â square:Â NumberÂ ->Â Number |'
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ; square: Number -> Number |'
- en: '| ;Â sort-nums:Â List<Number>Â ->Â List<Number> |'
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ; sort-nums: List<Number> -> List<Number> |'
- en: '| ;Â sort:Â List<T>Â *Â (TÂ *Â TÂ ->Â Boolean)Â ->Â List<T> |'
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ; sort: List<T> * (T * T -> Boolean) -> List<T> |'
- en: In Pyret, we write the annotations directly on the parameters and return values.
    Pyret will check them to a limited extent dynamically, and can check them statically
    with its type checker. The corresponding annotations to those above would be written
    as
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Pyret ä¸­ï¼Œæˆ‘ä»¬ç›´æ¥åœ¨å‚æ•°å’Œè¿”å›å€¼ä¸Šå†™æ³¨é‡Šã€‚Pyret å°†åœ¨æœ‰é™èŒƒå›´å†…åŠ¨æ€æ£€æŸ¥å®ƒä»¬ï¼Œå¹¶ä¸”å¯ä»¥ä½¿ç”¨å…¶ç±»å‹æ£€æŸ¥å™¨é™æ€æ£€æŸ¥å®ƒä»¬ã€‚ä¸Šè¿°å¯¹åº”çš„æ³¨é‡Šå°†å†™ä½œ
- en: '[PRE33]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 28.11Â What Else?[ğŸ”—](#(part._.What_.Else_) "Link to here")
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.11 å…¶ä»–å†…å®¹ï¼Ÿ[ğŸ”—](#(part._.What_.Else_) "é“¾æ¥è‡³æ­¤")
- en: If there are other parts of Scheme or Racket syntax that you would like to see
    translated, please [let us know](http://cs.brown.edu/~sk/Contact/).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨å¸Œæœ›çœ‹åˆ° Scheme æˆ– Racket è¯­æ³•ä¸­å…¶ä»–éƒ¨åˆ†çš„ç¿»è¯‘ï¼Œè¯·[å‘ŠçŸ¥æˆ‘ä»¬](http://cs.brown.edu/~sk/Contact/)ã€‚
