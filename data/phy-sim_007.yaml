- en: Implicit Time Integration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式时间积分
- en: 原文：[https://phys-sim-book.github.io/lec1.5-implicit_time_integration.html](https://phys-sim-book.github.io/lec1.5-implicit_time_integration.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://phys-sim-book.github.io/lec1.5-implicit_time_integration.html](https://phys-sim-book.github.io/lec1.5-implicit_time_integration.html)
- en: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
- en: In contrast to explicit time integration, implicit time integration requires
    solving a system of equations to determine the values of \(x^{n+1}\) and \(v^{n+1}\).
    A notable benefit of this approach is its potential for greatly improved stability.
    The simplest form of implicit integration, the backward Euler method, is introduced
    as follows.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与显式时间积分相比，隐式时间积分需要解决一个方程组以确定 \(x^{n+1}\) 和 \(v^{n+1}\) 的值。这种方法的一个显著优点是它有可能大大提高稳定性。隐式积分的最简单形式，即向后欧拉方法，如下所述。
- en: '****Method 1.5.1 (Backward Euler Time Integration Application to Newton''s
    Second Law).**** Given the current state variables, the mass matrix, and the time
    interval from \(t^n\) to \(t^{n+1}\), the update rules are as follows: xn+1vn+1​=xn+Δtvn+1,=vn+ΔtM−1fn+1,​(1.5.1)
    where \(n\) ranges from \(0,1,2,\dots\).'
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '****方法 1.5.1（向后欧拉时间积分应用于牛顿第二定律）****。给定当前状态变量、质量矩阵以及从 \(t^n\) 到 \(t^{n+1}\)
    的时间间隔，更新规则如下：\(x_{n+1} v_{n+1} = x_n + \Delta t v_n + \Delta t M^{-1} f_{n+1}\)，其中
    \(n\) 的范围从 \(0,1,2,\dots\)。'
- en: 'In many scenarios discussed in this book, the forces are derived from position
    vectors \(x\). Thus, we can represent \(f^{n+1} = f(x^{n+1})\). It''s crucial
    to recognize that the update for \(x^{n+1}\) depends on knowing \(v^{n+1}\), yet
    the calculation of \(v^{n+1}\) is contingent on \(x^{n+1}\). This interdependence
    creates a cyclical dependency, necessitating the resolution of a system of equations
    to accurately find \(x^{n+1}\) and \(v^{n+1}\). By formulating \(v^{n+1} = (x^{n+1}
    - x^n) / \Delta t\), Equation [(1.5.1)](#eq:lec1:updateRule_implicit) can be rephrased
    as: M(xn+1−(xn+Δtvn))−Δt2f(xn+1)=0.(1.5.2) Given that forces \(f\) often exhibit
    nonlinearity with respect to positions \(x\), Equation [(1.5.2)](#eq:lec1:system_IE)
    generally becomes nonlinear, requiring the use of nonlinear root finding techniques
    like **Newton''s method** for solution.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书讨论的许多场景中，力是通过位置向量 \(x\) 导出的。因此，我们可以表示 \(f^{n+1} = f(x^{n+1})\)。认识到 \(x^{n+1}\)
    的更新依赖于知道 \(v^{n+1}\)，而 \(v^{n+1}\) 的计算又依赖于 \(x^{n+1}\)，这一点至关重要。这种相互依赖性产生了一个循环依赖，需要解决一个方程组来准确找到
    \(x^{n+1}\) 和 \(v^{n+1}\)。通过公式 \(v^{n+1} = (x^{n+1} - x^n) / \Delta t\)，方程 [(1.5.1)](#eq:lec1:updateRule_implicit)
    可以重新表述为：\(M(x_{n+1} - (x_n + \Delta t v_n)) - \Delta t^2 f(x_{n+1}) = 0\)。(1.5.2)
    由于力 \(f\) 通常在位置 \(x\) 方面表现出非线性，方程 [(1.5.2)](#eq:lec1:system_IE) 通常是非线性的，需要使用非线性根查找技术，如**牛顿法**进行求解。
- en: '****Method 1.5.2 (Newton''s Method Applied to Backward Euler Time Integration).****
    As described in the algorithm below, Newton''s method is an iterative technique
    starting from an initial estimate \(x^i\) of the solution. At the current iteration
    \(x^i\), it linearly approximates \(f(x^{n+1}) \approx f(x^i) + (x^{n+1}-x^i)
    \nabla f(x^i)\), then resolves a linear system and updates the iteration. This
    process is repeated until a satisfactory degree of convergence is reached.'
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '****方法 1.5.2（牛顿法应用于向后欧拉时间积分）****。如以下算法所述，牛顿法是一种从解的初始估计 \(x^i\) 开始的迭代技术。在当前迭代
    \(x^i\) 时，它线性近似 \(f(x^{n+1}) \approx f(x^i) + (x^{n+1}-x^i) \nabla f(x^i)\)，然后解决一个线性系统并更新迭代。这个过程重复进行，直到达到令人满意的收敛程度。'
- en: ''
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Algorithm 1.5.1 (Newton''s Method for Backward Euler Time Integration).**
    ![](../Images/886e6bd1c54ee6b52a8aefe0b0295d47.png)'
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**算法 1.5.1（向后欧拉时间积分的牛顿法）** ![](../Images/886e6bd1c54ee6b52a8aefe0b0295d47.png)'
- en: While the backward Euler method ensures **unconditional stability** even for
    large values of \(\Delta t\), it's crucial to recognize that increasing \(\Delta
    t\) may lead to poorer system conditioning. This complication can make solving
    the linear system more challenging. Additionally, it's important to remember that
    force linearization is an approximation. If the initial estimate for the solution
    is far from the actual solution, the standard iteration of Newton's method might
    not converge, and it could even diverge.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然向后欧拉方法确保了对于大的 \(\Delta t\) 值的**无条件稳定性**，但重要的是要认识到增加 \(\Delta t\) 可能会导致系统条件恶化。这种复杂性可能会使解决线性系统更加困难。此外，重要的是要记住，力线性化是一个近似。如果解的初始估计远离实际解，牛顿法的标准迭代可能不会收敛，甚至可能发散。
- en: In later discussions, we will introduce a modified version of Newton's method.
    This adaptation is designed to guarantee convergence for specific types of problems,
    regardless of the initial estimate or the size of \(\Delta t\).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续讨论中，我们将介绍牛顿法的改进版本。这种改进旨在确保对于特定类型的问题，无论初始估计或\(\Delta t\)的大小如何，都能保证收敛。
