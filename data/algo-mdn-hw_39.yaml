- en: Modular Arithmetic
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模运算
- en: 原文：[https://en.algorithmica.org/hpc/number-theory/modular/](https://en.algorithmica.org/hpc/number-theory/modular/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/number-theory/modular/](https://en.algorithmica.org/hpc/number-theory/modular/)
- en: Computers usually store time as the number of seconds that have passed since
    the 1st of January, 1970 — the start of the “Unix era” — and use these timestamps
    in all computations that have to do with time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机通常将时间存储为自1970年1月1日以来经过的秒数——即“Unix时代”的开始——并在所有与时间相关的计算中使用这些时间戳。
- en: We humans also keep track of time relative to some point in the past, which
    usually has a political or religious significance. For example, at the moment
    of writing, approximately 63882260594 seconds have passed since 1 AD — [6th century
    Eastern Roman monks’ best estimate](https://en.wikipedia.org/wiki/Anno_Domini)
    of the day Jesus Christ was born.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们人类也根据过去某个点来追踪时间，这通常具有政治或宗教意义。例如，在写作的时刻，自公元1年以来大约已经过去了63882260594秒——这是[6世纪东罗马僧侣对耶稣基督出生日的最佳估计](https://en.wikipedia.org/wiki/Anno_Domini)。
- en: 'But unlike computers, we do not always need *all* that information. Depending
    on the task at hand, the relevant part may be that it’s 2 pm right now, and it’s
    time to go to dinner; or that it’s Thursday, and so Subway’s sub of the day is
    an Italian BMT. Instead of the whole timestamp, we use its *remainder* containing
    just the information we need: it is much easier to deal with 1- or 2-digit numbers
    than 11-digit ones.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但与计算机不同，我们并不总是需要所有这些信息。根据手头的任务，相关的部分可能是现在正是下午2点，是时候去吃晚餐了；或者今天是星期四，因此Subway的当日三明治是意大利BMT。我们不用整个时间戳，而是使用其*余数*，它只包含我们需要的信息：处理1位或2位数字比处理11位数字要容易得多。
- en: '**Problem.** Today is Thursday. What day of the week will be exactly in a year?'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**。今天是星期四。一年后将是星期几？'
- en: If we enumerate each day of the week, starting with Monday, from $0$ to $6$
    inclusive, Thursday gets number $3$. To find out what day it is going to be in
    a year from now, we need to add $365$ to it and then reduce modulo $7$. Conveniently,
    $365 \bmod 7 = 1$, so we know that it will be Friday unless it is a leap year
    (in which case it will be Saturday).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按顺序从星期一开始，编号从$0$到$6$，星期四的编号是$3$。为了找出一年后将是什么星期，我们需要将$365$加到它上面，然后对$7$取模。方便的是，$365
    \bmod 7 = 1$，所以我们知道除非是闰年（在这种情况下将是星期六），否则它将是星期五。
- en: '### [#](https://en.algorithmica.org/hpc/number-theory/modular/#residues)Residues'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '### [余数](https://en.algorithmica.org/hpc/number-theory/modular/#residues)'
- en: '**Definition.** Two integers $a$ and $b$ are said to be *congruent* modulo
    $m$ if $m$ divides their difference:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义**。如果整数$a$和$b$的差能被$m$整除，则称这两个整数在模$m$下是**同余**的。'
- en: $$ m \mid (a - b) \; \Longleftrightarrow \; a \equiv b \pmod m $$
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: $$ m \mid (a - b) \; \Longleftrightarrow \; a \equiv b \pmod m $$
- en: For example, the 42nd day of the year is the same weekday as the 161st since
    $(161 - 42) = 119 = 17 \times 7$.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一年的第42天与第161天的星期几相同，因为$(161 - 42) = 119 = 17 \times 7$。
- en: Congruence modulo $m$ is an equivalence relation that splits all integers into
    equivalence classes called *residues*. Each residue class modulo $m$ may be represented
    by any one of its members — although we commonly use the smallest nonnegative
    integer of that class (equal to the remainder $x \bmod m$ for all nonnegative
    $x$).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 模$m$的同余是一个等价关系，它将所有整数分成称为**余数**的等价类。模$m$的每个余数类可以用其任何一个成员来表示——尽管我们通常使用该类中最小的非负整数（对于所有非负$x$等于余数$x
    \bmod m$）。
- en: '*Modular arithmetic* studies these sets of residues, which are fundamental
    for number theory.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*模运算*研究这些余数集合，这些集合对于数论是基本的。'
- en: '**Problem.** Our “week” now consists of $m$ days, and our year consists of
    $a$ days (no leap years). How many distinct days of the week there will be among
    one, two, three and so on whole years from now?'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**。我们的“周”现在由$m$天组成，我们的年由$a$天组成（没有闰年）。从现在起一年、两年、三年等等，将有多少不同的星期天？'
- en: For simplicity, assume that today is Monday, so that the initial day number
    $d_0$ is zero, and after each year, it changes to
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，假设今天是星期一，因此初始天数$d_0$为零，并且每年之后，它变为
- en: $$ d_{k + 1} = (d_k + a) \bmod m $$ After $k$ years, it will be $$ d_k = k \cdot
    a \bmod m $$ Since there are only $m$ days in a week, at some point, it will be
    Monday again, and the sequence of day numbers is going to cycle. The number of
    distinct days is the length of this cycle, so we need to find the smallest $k$
    such that $$ k \cdot a \equiv 0 \pmod m $$
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: $$ d_{k + 1} = (d_k + a) \bmod m $$ 经过 $k$ 年后，它将是 $$ d_k = k \cdot a \bmod m
    $$ 由于一周只有 $m$ 天，所以某个时刻，星期一将再次出现，并且天数序列将会循环。不同天数的天数是循环的长度，因此我们需要找到最小的 $k$ 使得 $$
    k \cdot a \equiv 0 \pmod m $$
- en: 'First of all, if $a \equiv 0$, it will be eternal Monday. Now, assuming the
    non-trivial case of $a \not \equiv 0$:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果 $a \equiv 0$，它将是永恒的星期一。现在，假设非平凡情况 $a \not \equiv 0$：
- en: For a seven-day week, $m = 7$ is prime. There is no $k$ smaller than $m$ such
    that $k \cdot a$ is divisible by $m$ because $m$ can not be decomposed in such
    a product by the definition of primality. So, if $m$ is prime, we will cycle through
    all of $m$ weekdays.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一周七天的星期，$m = 7$ 是质数。没有小于 $m$ 的 $k$ 使得 $k \cdot a$ 能被 $m$ 整除，因为根据质数的定义，$m$
    不能通过这样的乘积分解。所以，如果 $m$ 是质数，我们将循环遍历所有的 $m$ 个工作日。
- en: 'If $m$ is not prime, but $a$ is *coprime* with it (that is, $a$ and $m$ do
    not have common divisors), then the answer is still $m$ for the same reason: the
    divisors of $a$ do not help in zeroing out the product any faster.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 $m$ 不是质数，但 $a$ 与它 *互质*（即 $a$ 和 $m$ 没有公约数），那么答案仍然是 $m$，原因相同：$a$ 的因子不会帮助更快地将乘积归零。
- en: If $a$ and $m$ share some divisors, then it is only possible to get residues
    that are also divisible by them. For example, if the week is $m = 10$ days long,
    and the year has $a = 42$ or any other even number of days, then we will cycle
    through all even day numbers, and if the number of days is a multiple of $5$,
    then we will only oscillate between $0$ and $5$. Otherwise, we will go through
    all the $10$ remainders.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 $a$ 和 $m$ 有一些共同的因子，那么只能得到也是这些因子倍数的余数。例如，如果一周是 $m = 10$ 天，而一年有 $a = 42$ 天或任何其他偶数天，那么我们将循环遍历所有偶数天数，如果天数是
    $5$ 的倍数，那么我们将在 $0$ 和 $5$ 之间摆动。否则，我们将遍历所有的 $10$ 个余数。
- en: Therefore, in general, the answer is $\frac{m}{\gcd(a, m)}$, where $\gcd(a,
    m)$ is the [greatest common divisor](/hpc/algorithms/gcd/) of $a$ and $m$.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一般来说，答案是 $\frac{m}{\gcd(a, m)}$，其中 $\gcd(a, m)$ 是 $a$ 和 $m$ 的 [最大公约数](/hpc/algorithms/gcd/)。
- en: '### [#](https://en.algorithmica.org/hpc/number-theory/modular/#fermats-theorem)Fermat’s
    Theorem'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/number-theory/modular/#fermats-theorem)费马定理'
- en: Now, consider what happens if, instead of adding a number $a$, we repeatedly
    multiply by it, writing out a sequence of
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑如果我们不是加一个数 $a$，而是反复乘以它，写出一系列
- en: $$ d_n = a^n \bmod m $$
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: $$ d_n = a^n \bmod m $$
- en: Again, since there is a finite number of residues, there is going to be a cycle.
    But what will its length be? Turns out, if $m$ is prime, it will span all $(m
    - 1)$ non-zero residues.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，由于余数是有限的，所以必然会有一个循环。但它的长度是多少呢？结果是，如果 $m$ 是质数，它将覆盖所有 $(m - 1)$ 个非零余数。
- en: '**Theorem.** For any $a$ and a prime $p$:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**定理**。对于任何 $a$ 和质数 $p$：'
- en: '$$ a^p \equiv a \pmod p $$ **Proof**. Let $P(x_1, x_2, \ldots, x_n) = \frac{k}{\prod
    (x_i!)}$ be the *multinomial coefficient:* the number of times the element $a_1^{x_1}
    a_2^{x_2} \ldots a_n^{x_n}$ appears after the expansion of $(a_1 + a_2 + \ldots
    + a_n)^k$. Then: $$ \begin{aligned} a^p &= (\underbrace{1+1+\ldots+1+1}_\text{$a$
    times})^p & \\\ &= \sum_{x_1+x_2+\ldots+x_a = p} P(x_1, x_2, \ldots, x_a) & \text{(by
    definition)} \\\ &= \sum_{x_1+x_2+\ldots+x_a = p} \frac{p!}{x_1! x_2! \ldots x_a!}
    & \text{(which terms will not be divisible by $p$?)} \\\ &\equiv P(p, 0, \ldots,
    0) + \ldots + P(0, 0, \ldots, p) & \text{(everything else will be canceled)} \\\
    &= a \end{aligned} $$'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: $$ a^p \equiv a \pmod p $$ **证明**。设 $P(x_1, x_2, \ldots, x_n) = \frac{k}{\prod
    (x_i!)}$ 为 *多项式系数*：在 $(a_1 + a_2 + \ldots + a_n)^k$ 展开后，元素 $a_1^{x_1} a_2^{x_2}
    \ldots a_n^{x_n}$ 出现的次数。那么：$$ \begin{aligned} a^p &= (\underbrace{1+1+\ldots+1+1}_\text{$a$
    次})^p & \\\ &= \sum_{x_1+x_2+\ldots+x_a = p} P(x_1, x_2, \ldots, x_a) & \text{(根据定义)}
    \\\ &= \sum_{x_1+x_2+\ldots+x_a = p} \frac{p!}{x_1! x_2! \ldots x_a!} & \text{(哪些项不能被
    $p$ 整除？)} \\\ &\equiv P(p, 0, \ldots, 0) + \ldots + P(0, 0, \ldots, p) & \text{(其他所有项都将被抵消)}
    \\\ &= a \end{aligned} $$
- en: 'Note that this is only true for prime $p$. We can use this fact to test whether
    a given number is prime faster than by factoring it: we can pick a number $a$
    at random, calculate $a^{p} \bmod p$, and check whether it is equal to $a$ or
    not.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这仅对质数 $p$ 成立。我们可以利用这个事实来更快地测试一个给定的数是否为质数，而不是通过分解它：我们可以随机选择一个数 $a$，计算 $a^{p}
    \bmod p$，并检查它是否等于 $a$。
- en: This is called *Fermat primality test*, and it is probabilistic — only returning
    either “no” or “maybe” — since it may be that $a^p$ just happened to be equal
    to $a$ despite $p$ being composite, in which case you need to repeat the test
    with a different random $a$ until you are satisfied with the false positive probability.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为 *费马素性测试*，它是概率性的——只返回“否”或“可能”——因为可能 $a^p$ 只是恰好等于 $a$，尽管 $p$ 是合数，在这种情况下，你需要用不同的随机
    $a$ 重复测试，直到你对假阳性概率满意。
- en: Primality tests are commonly used to generate large primes (for cryptographic
    purposes). There are roughly $\frac{n}{\ln n}$ primes among the first $n$ numbers
    (a fact that we are not going to prove), and they are distributed more or less
    evenly. One can just pick a random number from the required range, perform a primality
    check, and repeat until a prime is found, performing $O(\ln n)$ trials on average.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 素性测试通常用于生成大素数（用于加密目的）。在第一个 $n$ 个数中大约有 $\frac{n}{\ln n}$ 个素数（我们不会证明这个事实），它们的分布相对均匀。一个人可以从所需范围内随机选择一个数，执行素性检查，直到找到一个素数，平均进行
    $O(\ln n)$ 次试验。
- en: An extremely bad input to the Fermat test is the [Carmichael numbers](https://en.wikipedia.org/wiki/Carmichael_number),
    which are composite numbers $n$ that satisfy $a^{n-1} \equiv 1 \pmod n$ for all
    relatively prime $a$. But these are [rare](https://oeis.org/A002997), and the
    chance of randomly bumping into it is low.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 费马测试的一个极其糟糕的输入是 [卡迈克尔数](https://en.wikipedia.org/wiki/Carmichael_number)，这些是满足对于所有互质的
    $a$ 有 $a^{n-1} \equiv 1 \pmod n$ 的合数 $n$。但它们是 [罕见的](https://oeis.org/A002997)，随机遇到它们的概率很低。
- en: '### [#](https://en.algorithmica.org/hpc/number-theory/modular/#modular-division)Modular
    Division'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/number-theory/modular/#modular-division)模除法'
- en: 'Implementing most “normal” arithmetic operations with residues is straightforward.
    You only need to take care of integer overflows and remember to take modulo:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用余数实现大多数“正常”的算术运算很简单。你只需要注意整数溢出并记得取模：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'But there is an issue with division: we can’t just bluntly divide two residues.
    For example, $\frac{8}{2} = 4$, but'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但在除法方面有一个问题：我们不能简单地除以两个余数。例如，$\frac{8}{2} = 4$，但
- en: '$$ \frac{8 \bmod 5}{2 \bmod 5} = \frac{3}{2} \neq 4 $$ To perform modular division,
    we need to find an element that “acts” like the reciprocal $\frac{1}{a} = a^{-1}$
    and multiply by it. This element is called a *modular multiplicative inverse*,
    and Fermat’s theorem can help us find it when the modulo $p$ is a prime. When
    we divide its equivalence twice by $a$, we get: $$ a^p \equiv a \implies a^{p-1}
    \equiv 1 \implies a^{p-2} \equiv a^{-1} $$ Therefore, $a^{p-2}$ is like $a^{-1}$
    for the purposes of multiplication, which is what we need from a modular inverse
    of $a$.[← ../Number Theory](https://en.algorithmica.org/hpc/number-theory/)[Binary
    Exponentiation →](https://en.algorithmica.org/hpc/number-theory/exponentiation/)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: $$ \frac{8 \bmod 5}{2 \bmod 5} = \frac{3}{2} \neq 4 $$ 要执行模除，我们需要找到一个“作用”像倒数
    $\frac{1}{a} = a^{-1}$ 的元素，并乘以它。这个元素被称为 *模乘法逆元*，当模 $p$ 是素数时，费马定理可以帮助我们找到它。当我们用
    $a$ 除其等价两次时，我们得到：$$ a^p \equiv a \implies a^{p-1} \equiv 1 \implies a^{p-2} \equiv
    a^{-1} $$ 因此，$a^{p-2}$ 对于乘法来说就像 $a^{-1}$，这正是我们从 $a$ 的模逆元中需要的。[← ../数论](https://en.algorithmica.org/hpc/number-theory/)[二进制指数运算
    →](https://en.algorithmica.org/hpc/number-theory/exponentiation/)
