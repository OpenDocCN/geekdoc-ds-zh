- en: Extended Euclidean Algorithm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展欧几里得算法
- en: 原文：[https://en.algorithmica.org/hpc/number-theory/euclid-extended/](https://en.algorithmica.org/hpc/number-theory/euclid-extended/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/number-theory/euclid-extended/](https://en.algorithmica.org/hpc/number-theory/euclid-extended/)
- en: '[Fermat’s theorem](../modular/#fermats-theorem) allows us to calculate modular
    multiplicative inverses through [binary exponentiation](..exponentiation/) in
    $O(\log n)$ operations, but it only works with prime modula. There is a generalization
    of it, [Euler’s theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem), stating
    that if $m$ and $a$ are coprime, then $$ a^{\phi(m)} \equiv 1 \pmod m $$'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[费马定理](../modular/#fermats-theorem)允许我们通过 $O(\log n)$ 次操作中的二进制指数运算来计算模乘法逆元，但它只适用于素数模数。存在它的一个推广，[欧拉定理](https://en.wikipedia.org/wiki/Euler%27s_theorem)，指出如果
    $m$ 和 $a$ 互质，则 $$ a^{\phi(m)} \equiv 1 \pmod m $$'
- en: where $\phi(m)$ is [Euler’s totient function](https://en.wikipedia.org/wiki/Euler%27s_totient_function)
    defined as the number of positive integers $x < m$ that are coprime with $m$.
    In the special case when $m$ is a prime, then all the $m - 1$ residues are coprime
    and $\phi(m) = m - 1$, yielding the Fermat’s theorem.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 $\phi(m)$ 是 [欧拉函数](https://en.wikipedia.org/wiki/Euler%27s_totient_function)，定义为小于
    $m$ 的正整数 $x$ 中与 $m$ 互质的数的个数。在 $m$ 是素数的情况下，所有 $m - 1$ 个余数都是互质的，因此 $\phi(m) = m
    - 1$，从而得到费马定理。
- en: 'This lets us calculate the inverse of $a$ as $a^{\phi(m) - 1}$ if we know $\phi(m)$,
    but in turn, calculating it is not so fast: you usually need to obtain the [factorization](/hpc/algorithms/factorization/)
    of $m$ to do it. There is a more general method that works by modifying the [the
    Euclidean algorthm](/hpc/algorithms/gcd/).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们可以通过知道 $\phi(m)$ 来计算 $a$ 的逆元为 $a^{\phi(m) - 1}$，但反过来计算它并不快：通常需要获得 $m$ 的[因式分解](/hpc/algorithms/factorization/)来执行它。存在一个更通用的方法，它通过修改[欧几里得算法](/hpc/algorithms/gcd/)来实现。
- en: '### [#](https://en.algorithmica.org/hpc/number-theory/euclid-extended/#algorithm)Algorithm'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/number-theory/euclid-extended/#algorithm)算法'
- en: '*Extended Euclidean algorithm*, apart from finding $g = \gcd(a, b)$, also finds
    integers $x$ and $y$ such that'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*扩展欧几里得算法*，除了找到 $g = \gcd(a, b)$，还找到整数 $x$ 和 $y$，使得'
- en: '$$ a \cdot x + b \cdot y = g $$ which solves the problem of finding modular
    inverse if we substitute $b$ with $m$ and $g$ with $1$: $$ a^{-1} \cdot a + k
    \cdot m = 1 $$'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: $$ a \cdot x + b \cdot y = g $$ 这就解决了在将 $b$ 替换为 $m$ 和 $g$ 替换为 $1$ 的情况下寻找模逆元的问题：$$
    a^{-1} \cdot a + k \cdot m = 1 $$
- en: Note that, if $a$ is not coprime with $m$, there is no solution since no integer
    combination of $a$ and $m$ can yield anything that is not a multiple of their
    greatest common divisor.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果 $a$ 与 $m$ 不互质，则没有解，因为 $a$ 和 $m$ 的任何整数组合都无法得到不是它们最大公约数倍数的任何数。
- en: 'The algorithm is also recursive: it calculates the coefficients $x’$ and $y’$
    for $\gcd(b, a \bmod b)$ and restores the solution for the original number pair.
    If we have a solution $(x’, y’)$ for the pair $(b, a \bmod b)$'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 算法也是递归的：它计算 $\gcd(b, a \bmod b)$ 的系数 $x’$ 和 $y’$，并恢复原始数对的解。如果我们有一个数对 $(b, a
    \bmod b)$ 的解 $(x’， y’)$
- en: '$$ b \cdot x'' + (a \bmod b) \cdot y'' = g $$ then, to get the solution for
    the initial input, we can rewrite the expression $(a \bmod b)$ as $(a - \lfloor
    \frac{a}{b} \rfloor \cdot b)$ and subsitute it into the aforementioned equation:
    $$ b \cdot x'' + (a - \Big \lfloor \frac{a}{b} \Big \rfloor \cdot b) \cdot y''
    = g $$ Now we rearrange the terms grouping by $a$ and $b$ to get $$ a \cdot \underbrace{y''}_x
    + b \cdot \underbrace{(x'' - \Big \lfloor \frac{a}{b} \Big \rfloor \cdot y'')}_y
    = g $$'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: $$ b \cdot x' + (a \bmod b) \cdot y' = g $$ 那么，为了得到初始输入的解，我们可以将 $(a \bmod b)$
    重新写为 $(a - \lfloor \frac{a}{b} \rfloor \cdot b)$ 并将其代入上述方程：$$ b \cdot x' + (a
    - \Big \lfloor \frac{a}{b} \Big \rfloor \cdot b) \cdot y' = g $$ 现在我们重新排列项，按 $a$
    和 $b$ 分组，得到 $$ a \cdot \underbrace{y'}_x + b \cdot \underbrace{(x' - \Big \lfloor
    \frac{a}{b} \Big \rfloor \cdot y')}_y = g $$
- en: Comparing it with the initial expression, we infer that we can just use coefficients
    of $a$ and $b$ for the initial $x$ and $y$.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与初始表达式进行比较，我们可以推断出我们可以直接使用 $a$ 和 $b$ 的系数作为初始的 $x$ 和 $y$。
- en: '### [#](https://en.algorithmica.org/hpc/number-theory/euclid-extended/#implementation)Implementation'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/number-theory/euclid-extended/#implementation)实现'
- en: 'We implement the algorithm as a recursive function. Since its output is not
    one but three integers, we pass the coefficients to it by reference:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将算法实现为一个递归函数。由于它的输出不是单个整数，而是三个整数，所以我们通过引用传递系数：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To calculate the inverse, we simply pass $a$ and $m$ and return the $x$ coefficient
    the algorithm finds. Since we pass two positive numbers, one of the coefficient
    will be positive and the other one is negative (which one depends on whether the
    number of iterations is odd or even), so we need to optionally check if $x$ is
    negative and add $m$ to get a correct residue:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算逆元，我们只需传递$a$和$m$，然后返回算法找到的$x$系数。由于我们传递了两个正数，其中一个系数将是正的，另一个是负的（哪个是负的取决于迭代次数是奇数还是偶数），因此我们需要可选地检查$x$是否为负，并加上$m$以获得正确的余数：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It works in ~160ns — 10ns faster than inverting numbers with [binary exponentiation](../exponentiation).
    To optimize it further, we can similarly turn it iterative ­— which takes 135ns:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它在160纳秒内完成——比使用[二进制指数运算](../exponentiation)求逆数快10纳秒。为了进一步优化它，我们可以将其转换为迭代形式——这需要135纳秒：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that, unlike binary exponentiation, the running time depends on the value
    of $a$. For example, for this particular value of $m$ ($10^9 + 7$), the worst
    input happens to be 564400443, for which the algorithm performs 37 iterations
    and takes 250ns.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与二进制指数运算不同，运行时间取决于$a$的值。例如，对于这个特定的$m$值（$10^9 + 7$），最坏的情况是564400443，算法执行了37次迭代，耗时250纳秒。
- en: '**Exercise**. Try to adapt the same technique for the [binary GCD](/hpc/algorithms/gcd/#binary-gcd)
    (it won’t give performance speedup though unless you are better than me at optimization).
    [← Binary Exponentiation](https://en.algorithmica.org/hpc/number-theory/exponentiation/)[Montgomery
    Multiplication →](https://en.algorithmica.org/hpc/number-theory/montgomery/)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**。尝试将相同的技巧应用于[二进制最大公约数](/hpc/algorithms/gcd/#binary-gcd)（除非你在优化方面比我更好，否则它不会带来性能提升）。[←
    二进制指数运算](https://en.algorithmica.org/hpc/number-theory/exponentiation/)[蒙哥马利乘法
    →](https://en.algorithmica.org/hpc/number-theory/montgomery/)'
