- en: Benchmarking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试
- en: 原文：[https://en.algorithmica.org/hpc/profiling/benchmarking/](https://en.algorithmica.org/hpc/profiling/benchmarking/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/profiling/benchmarking/](https://en.algorithmica.org/hpc/profiling/benchmarking/)
- en: 'Most good software engineering practices in one way or another address the
    issue of making *development cycles* faster: you want to compile your software
    faster (build systems), catch bugs as soon as possible (static analysis, continuous
    integration), release as soon as the new version is ready (continuous deployment),
    and react to user feedback without much delay (agile development).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数优秀的软件工程实践以某种方式解决了加快*开发周期*的问题：你希望编译软件更快（构建系统）、尽快捕捉到错误（静态分析、持续集成）、一旦新版本准备好就发布（持续部署），以及尽可能少地延迟地响应用户反馈（敏捷开发）。
- en: 'Performance engineering is not different. If you do it correctly, it should
    also resemble a cycle:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 性能工程也不例外。如果你做得正确，它也应该类似于一个循环：
- en: Run the program and collect metrics.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序并收集指标。
- en: Figure out where the bottleneck is.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定瓶颈在哪里。
- en: Remove the bottleneck and go to step 1.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除瓶颈并回到步骤 1。
- en: In this section, we will talk about benchmarking and discuss some practical
    techniques that make this cycle shorter and help you iterate faster. Most of the
    advice comes from working on this book, so you can find many real examples of
    described setups in the [code repository](https://github.com/sslotin/ahm-code)
    for this book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论基准测试，并讨论一些实用的技术，这些技术可以使这个循环更短，并帮助你更快地迭代。大部分建议都来自本书的编写工作，因此你可以在本书的[代码仓库](https://github.com/sslotin/ahm-code)中找到许多描述的设置的实例。
- en: '### [#](https://en.algorithmica.org/hpc/profiling/benchmarking/#benchmarking-inside-c)Benchmarking
    Inside C++'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/profiling/benchmarking/#benchmarking-inside-c)C++
    内部基准测试'
- en: There are several approaches to writing benchmarking code. Perhaps the most
    popular one is to include several same-language implementations you want to compare
    in one file, separately invoke them from the `main` function, and calculate all
    the metrics you want in the same source file.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 存在几种编写基准测试代码的方法。可能最流行的一种是将你想要比较的几个相同语言的实现包含在一个文件中，从 `main` 函数中单独调用它们，并在同一源文件中计算你想要的全部指标。
- en: 'The disadvantage of this method is that you need to write a lot of boilerplate
    code and duplicate it for each implementation, but it can be partially neutralized
    with metaprogramming. For example, when you are benchmarking multiple [gcd](/hpc/algorithms/gcd)
    implementations, you can reduce benchmarking code considerably with this higher-order
    function:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，你需要编写大量的样板代码，并且为每个实现重复它，但可以通过元编程部分地抵消这一点。例如，当你正在基准测试多个 [gcd](/hpc/algorithms/gcd)
    实现时，你可以使用这个高阶函数显著减少基准测试代码：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is a very low-overhead method that lets you run more experiments and [get
    more accurate results](../noise) from them. You still have to perform some repeated
    actions, but they can be largely automated with frameworks, [Google benchmark
    library](https://github.com/google/benchmark) being the most popular choice for
    C++. Some programming languages also have handy built-in tools for benchmarking:
    special mention here goes to [Python’s timeit function](https://docs.python.org/3/library/timeit.html)
    and [Julia’s @benchmark macro](https://github.com/JuliaCI/BenchmarkTools.jl).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个低开销的方法，让你能够运行更多的实验，并从它们中获得更准确的结果。[../noise](../noise)。你仍然需要执行一些重复操作，但它们可以通过框架在很大程度上自动化，其中最受欢迎的选择是
    C++ 的 [Google 基准库](https://github.com/google/benchmark)。一些编程语言也有方便的内置基准测试工具：在此特别提一下
    [Python 的 timeit 函数](https://docs.python.org/3/library/timeit.html)和 [Julia 的
    @benchmark 宏](https://github.com/JuliaCI/BenchmarkTools.jl)。
- en: Although *efficient* in terms of execution speed, C and C++ are not the most
    *productive* languages, especially when it comes to analytics. When your algorithm
    depends on some parameters such as the input size, and you need to collect more
    than just one data point from each implementation, you really want to integrate
    your benchmarking code with the outside environment and analyze the results using
    something else.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在执行速度方面*高效*，但 C 和 C++ 并不是最*高效*的语言，尤其是在分析方面。当你的算法依赖于某些参数，如输入大小，并且你需要从每个实现中收集不止一个数据点时，你真的希望将你的基准测试代码与外部环境集成，并使用其他工具来分析结果。
- en: '### [#](https://en.algorithmica.org/hpc/profiling/benchmarking/#splitting-up-implementations)Splitting
    Up Implementations'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/profiling/benchmarking/#splitting-up-implementations)拆分实现'
- en: One way to improve modularity and reusability is to separate all testing and
    analytics code from the actual implementation of the algorithm, and also make
    it so that different versions are implemented in separate files, but have the
    same interface.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 提高模块化和可重用性的一个方法是将所有测试和统计分析代码与算法的实际实现分开，并且确保不同版本在单独的文件中实现，但具有相同的接口。
- en: 'In C/C++, you can do this by creating a single header file (e.g., `gcd.hh`)
    with a function interface and all its benchmarking code in `main`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在C/C++中，你可以通过创建一个包含函数接口及其所有基准测试代码的`main`中的单个头文件（例如，`gcd.hh`）来实现这一点：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then you create many implementation files for each algorithm version (e.g.,
    `v1.cc`, `v2.cc`, and so on, or some meaningful names if applicable) that all
    include that single header file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为每个算法版本创建许多实现文件（例如，`v1.cc`、`v2.cc`等，或者如果适用，一些有意义的名称），它们都包含那个单独的头文件：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The whole purpose of doing this is to be able to benchmark a specific algorithm
    version from the command line without touching any source code files. For this
    purpose, you may also want to expose any parameters that it may have — for example,
    by parsing them from the command line arguments:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的整个目的是能够从命令行中测试特定的算法版本，而不需要触摸任何源代码文件。为此，你可能还希望公开它可能具有的任何参数——例如，通过解析命令行参数：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Another way to do it is to use C-style global defines and then pass them with
    the `-D N=...` flag during compilation:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用C风格的全局定义，然后在编译时通过`-D N=...`标志传递它们：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This way you can make use of compile-time constants, which may be very beneficial
    for the performance of some algorithms, at the expense of having to re-build the
    program each time you want to change the parameter, which considerably increases
    the time you need to collect metrics across a range of parameter values.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这样你可以利用编译时的常量，这可能对某些算法的性能非常有帮助，但代价是每次你想更改参数时都必须重新构建程序，这会显著增加你在一系列参数值上收集指标所需的时间。
- en: '### [#](https://en.algorithmica.org/hpc/profiling/benchmarking/#makefiles)Makefiles'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/profiling/benchmarking/#makefiles)Makefiles'
- en: Splitting up source files allows you to speed up compilation using a caching
    build system such as [Make](https://en.wikipedia.org/wiki/Make_(software)).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将源文件拆分可以让你使用像[Make](https://en.wikipedia.org/wiki/Make_(software))这样的缓存构建系统来加速编译。
- en: 'I usually carry a version of this Makefile across my projects:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常在我的项目中携带这个Makefile的版本：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can now compile `example.cc` with `make example`, and automatically run
    it with `make example.run`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用`make example`来编译`example.cc`，并自动运行它使用`make example.run`。
- en: You can also add scripts for calculating statistics in the Makefile, or incorporate
    it with `perf stat` calls to make profiling automatic.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在Makefile中添加用于计算统计的脚本，或者与`perf stat`调用结合使用，使分析自动化。
- en: '### [#](https://en.algorithmica.org/hpc/profiling/benchmarking/#jupyter-notebooks)Jupyter
    Notebooks'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/profiling/benchmarking/#jupyter-notebooks)Jupyter
    Notebooks'
- en: To speed up high-level analytics, you can create a Jupyter notebook where you
    put all your scripts and do all the plots.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快高级分析的速度，你可以创建一个Jupyter笔记本，在其中放置所有脚本并执行所有绘图。
- en: 'It is convenient to add a wrapper for benchmarking an implementation, which
    just returns a scalar result:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个用于基准测试实现的包装器很方便，它只返回一个标量结果：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then you can use it to write clean analytics code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以用它来编写干净的统计分析代码：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once established, this workflow makes you iterate much faster and focus on optimizing
    the algorithm itself. [← Machine Code Analyzers](https://en.algorithmica.org/hpc/profiling/mca/)[Getting
    Accurate Results →](https://en.algorithmica.org/hpc/profiling/noise/)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立，这个工作流程会让你迭代得更快，并专注于优化算法本身。[← 机器代码分析器](https://en.algorithmica.org/hpc/profiling/mca/)[获取准确结果
    →](https://en.algorithmica.org/hpc/profiling/noise/)
