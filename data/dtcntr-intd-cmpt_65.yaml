- en: 20Â Recursion and Cycles from MutationğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 20Â é€’å½’ä¸å¾ªç¯ä»å˜å¼‚ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/rec-from-mut.html](https://dcic-world.org/2025-08-27/rec-from-mut.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/rec-from-mut.html](https://dcic-world.org/2025-08-27/rec-from-mut.html)
- en: 'Earlier [[From Acyclicity to Cycles](Sharing_and_Equality.html#%28part._acyc-to-cyc%29)],
    we saw the difficulty of constructing cyclic data, and saw how we could address
    this problem using state [[Cyclic Data](unified-cyclic-data.html)]. Let us now
    return to the earlier example of creating a cyclic list of alternating colors.
    We had tried to write:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ—©æœŸ [[ä»æ— ç¯åˆ°å¾ªç¯](Sharing_and_Equality.html#%28part._acyc-to-cyc%29)]ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†æ„å»ºå¾ªç¯æ•°æ®çš„å›°éš¾ï¼Œå¹¶çœ‹åˆ°äº†æˆ‘ä»¬å¦‚ä½•ä½¿ç”¨çŠ¶æ€
    [[å¾ªç¯æ•°æ®](unified-cyclic-data.html)]æ¥è§£å†³æ­¤é—®é¢˜ã€‚ç°åœ¨è®©æˆ‘ä»¬å›åˆ°ä¹‹å‰åˆ›å»ºäº¤æ›¿é¢œè‰²å¾ªç¯åˆ—è¡¨çš„æ—©æœŸä¾‹å­ã€‚æˆ‘ä»¬æ›¾è¯•å›¾å†™ï¼š
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: which, as we noted, does not pass muster because `web-colors` is not bound on
    the right of the `=`. (Why not? Because otherwise, if we try to substitute `web-colors`
    on the right, we would end up in an infinite regress.)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬æ‰€æ³¨æ„åˆ°çš„ï¼Œè¿™å¹¶ä¸ç¬¦åˆæ ‡å‡†ï¼Œå› ä¸º`web-colors`æ²¡æœ‰ç»‘å®šåœ¨`=`çš„å³ä¾§ã€‚ï¼ˆä¸ºä»€ä¹ˆï¼Ÿå› ä¸ºå¦‚æœæˆ‘ä»¬å°è¯•åœ¨å³ä¾§æ›¿æ¢`web-colors`ï¼Œæˆ‘ä»¬æœ€ç»ˆä¼šé™·å…¥æ— é™å›å½’ã€‚ï¼‰
- en: 'Something about this should make you a little suspicious: we have been able
    to write recursive functions all the time, without difficulty. Why are they different?
    For two reasons:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™åº”è¯¥è®©ä½ æœ‰ç‚¹æ€€ç–‘ï¼šæˆ‘ä»¬ä¸€ç›´èƒ½å¤Ÿè½»æ¾åœ°ç¼–å†™é€’å½’å‡½æ•°ï¼Œä¸ºä»€ä¹ˆå®ƒä»¬ä¸åŒï¼Ÿæœ‰ä¸¤ä¸ªåŸå› ï¼š
- en: The first reason is the fact that weâ€™re defining a function. A functionâ€™s body
    is not evaluated right awayâ€”<wbr>only when we apply itâ€”<wbr>so the language can
    wait for the body to finish being defined. (Weâ€™ll see what this might mean in
    a moment.)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ä¸ªåŸå› æ˜¯æˆ‘ä»¬åœ¨å®šä¹‰ä¸€ä¸ªå‡½æ•°ã€‚å‡½æ•°ä½“ä¸æ˜¯ç«‹å³è¯„ä¼°çš„â€”â€”<wbr>åªæœ‰å½“æˆ‘ä»¬åº”ç”¨å®ƒæ—¶â€”â€”<wbr>å› æ­¤ï¼Œè¯­è¨€å¯ä»¥ç­‰å¾…ä½“è¢«å®šä¹‰å®Œæˆã€‚ï¼ˆæˆ‘ä»¬ç¨åä¼šçœ‹åˆ°è¿™å¯èƒ½ä¼šæ„å‘³ç€ä»€ä¹ˆã€‚ï¼‰
- en: 'The second reason isnâ€™t actually a reason: function definitions actually are
    special. But we are about to expose whatâ€™s so special about themâ€”<wbr>itâ€™s the
    use of a box! [[Boxes: A Canonical Mutable Structure](state-in-pyret.html#%28part._boxes%29)]â€”<wbr>so
    that any definition can avail of it.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç¬¬äºŒä¸ªåŸå› å®é™…ä¸Šå¹¶ä¸æ˜¯ä¸€ä¸ªåŸå› ï¼šå‡½æ•°å®šä¹‰å®é™…ä¸Šæ˜¯ç‰¹æ®Šçš„ã€‚ä½†æˆ‘ä»¬å°†æ­ç¤ºå®ƒä»¬ä¹‹æ‰€ä»¥ç‰¹æ®Šçš„åŸå› â€”â€”<wbr>é‚£å°±æ˜¯ä½¿ç”¨ä¸€ä¸ªæ¡†ï¼[[æ¡†ï¼šä¸€ä¸ªè§„èŒƒçš„å¯å˜ç»“æ„](state-in-pyret.html#%28part._boxes%29)]â€”â€”<wbr>è¿™æ ·ä»»ä½•å®šä¹‰éƒ½å¯ä»¥åˆ©ç”¨å®ƒã€‚
- en: 'Returning to our example above, recall that we canâ€™t make up our list using
    `link`s, because we want the list to never terminate. Therefore, let us first
    define a new datatype to hold an cyclic list:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: å›åˆ°æˆ‘ä»¬ä¸Šé¢çš„ä¾‹å­ï¼Œå›æƒ³ä¸€ä¸‹æˆ‘ä»¬æ— æ³•ä½¿ç”¨`link`sæ¥æ„å»ºæˆ‘ä»¬çš„åˆ—è¡¨ï¼Œå› ä¸ºæˆ‘ä»¬å¸Œæœ›åˆ—è¡¨æ°¸è¿œä¸ä¼šç»ˆæ­¢ã€‚å› æ­¤ï¼Œè®©æˆ‘ä»¬é¦–å…ˆå®šä¹‰ä¸€ä¸ªæ–°çš„æ•°æ®ç±»å‹æ¥ä¿å­˜å¾ªç¯åˆ—è¡¨ï¼š
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You should think of this as analogous to a list, where `hd` is the first element
    and `tl` is the rest.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ åº”è¯¥æŠŠå®ƒçœ‹ä½œä¸åˆ—è¡¨ç±»ä¼¼ï¼Œå…¶ä¸­`hd`æ˜¯ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œ`tl`æ˜¯å…¶ä½™éƒ¨åˆ†ã€‚
- en: Observe that we have carefully avoided writing type definitions for the fields;
    we will instead try to figure them out as we go along. Also, however, this definition
    as written cannot work.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„åˆ°æˆ‘ä»¬ä»”ç»†åœ°é¿å…äº†ä¸ºå­—æ®µç¼–å†™ç±»å‹å®šä¹‰ï¼›æˆ‘ä»¬å°†å°è¯•åœ¨è¿‡ç¨‹ä¸­æ‰¾å‡ºå®ƒä»¬ã€‚ç„¶è€Œï¼Œè¿™ä¸ªå®šä¹‰æŒ‰ç°åœ¨çš„å†™æ³•æ˜¯æ— æ³•å·¥ä½œçš„ã€‚
- en: Do Now!
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see why not?
  id: totrans-14
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ çœ‹æ‡‚ä¸ºä»€ä¹ˆä¸è¡Œå—ï¼Ÿ
- en: 'Letâ€™s decompose the intended infinite list into two pieces: lists that begin
    with white and ones that begin with grey. What follows white? A grey list. What
    follows grey? A white list. It is clear we canâ€™t write down these two definitions
    because one of them must precede the other, but each one depends on the other.
    (This is the same problem as trying to write a single definition above.)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å°†é¢„æœŸçš„æ— é™åˆ—è¡¨åˆ†è§£æˆä¸¤éƒ¨åˆ†ï¼šä»¥ç™½è‰²å¼€å§‹çš„åˆ—è¡¨å’Œä»¥ç°è‰²å¼€å§‹çš„åˆ—è¡¨ã€‚ç™½è‰²ä¹‹åæ˜¯ä»€ä¹ˆï¼Ÿä¸€ä¸ªç°è‰²åˆ—è¡¨ã€‚ç°è‰²ä¹‹åæ˜¯ä»€ä¹ˆï¼Ÿä¸€ä¸ªç™½è‰²åˆ—è¡¨ã€‚å¾ˆæ˜æ˜¾ï¼Œæˆ‘ä»¬æ— æ³•å†™ä¸‹è¿™ä¸¤ä¸ªå®šä¹‰ï¼Œå› ä¸ºå…¶ä¸­ä¸€ä¸ªå¿…é¡»å…ˆäºå¦ä¸€ä¸ªï¼Œä½†æ¯ä¸ªå®šä¹‰éƒ½ä¾èµ–äºå¦ä¸€ä¸ªã€‚ï¼ˆè¿™æ­£æ˜¯å°è¯•åœ¨ä¸Šé¢å†™ä¸€ä¸ªå•ä¸€å®šä¹‰æ—¶é‡åˆ°çš„é—®é¢˜ã€‚ï¼‰
- en: 20.1Â Partial Definitions[ğŸ”—](#(part._.Partial_.Definitions) "Link to here")
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.1Â éƒ¨åˆ†å®šä¹‰[ğŸ”—](#(part._.Partial_.Definitions) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'What we need to instead do is to partially define each list, and then complete
    the definition using the other one. However, that is impossible using the above
    definition, because we cannot change anything once it is constructed. Instead,
    therefore, we need:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éœ€è¦åšçš„æ˜¯éƒ¨åˆ†å®šä¹‰æ¯ä¸ªåˆ—è¡¨ï¼Œç„¶åä½¿ç”¨å¦ä¸€ä¸ªåˆ—è¡¨æ¥å®Œæˆå®šä¹‰ã€‚ç„¶è€Œï¼Œä½¿ç”¨ä¸Šé¢çš„å®šä¹‰è¿™æ˜¯ä¸å¯èƒ½çš„ï¼Œå› ä¸ºæˆ‘ä»¬ä¸€æ—¦æ„å»ºäº†å®ƒå°±ä¸èƒ½å†æ”¹å˜ä»»ä½•ä¸œè¥¿ã€‚å› æ­¤ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦ï¼š
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that this datatype lacks a base case, which should remind you of definitions
    we saw in [Streams From Functions](func-as-data.html#%28part._streams-from-funs%29).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè¿™ä¸ªæ•°æ®ç±»å‹ç¼ºå°‘ä¸€ä¸ªåŸºæœ¬æƒ…å†µï¼Œè¿™åº”è¯¥è®©ä½ æƒ³èµ·æˆ‘ä»¬åœ¨[ä»å‡½æ•°åˆ°æµ](func-as-data.html#%28part._streams-from-funs%29)ä¸­çœ‹åˆ°çš„å®šä¹‰ã€‚
- en: 'Using this, we can define:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ï¼š
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Each of these definitions is quite useless by itself, but they each represent
    what we want, and they have a mutable field for the rest, currently holding a
    dummy value. Therefore, itâ€™s clear what we must do next: update the mutable field.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: æ¯ä¸ªè¿™æ ·çš„å®šä¹‰å•ç‹¬æ¥çœ‹éƒ½æ˜¯ç›¸å½“æ— ç”¨çš„ï¼Œä½†å®ƒä»¬å„è‡ªä»£è¡¨äº†æˆ‘ä»¬çš„éœ€æ±‚ï¼Œå¹¶ä¸”éƒ½æœ‰ä¸€ä¸ªå¯å˜å­—æ®µï¼Œç›®å‰æŒæœ‰çš„æ˜¯ä¸€ä¸ªå ä½ç¬¦å€¼ã€‚å› æ­¤ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å¿…é¡»åšçš„äº‹æƒ…å¾ˆæ¸…æ¥šï¼šæ›´æ–°è¿™ä¸ªå¯å˜å­—æ®µã€‚
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Because we have ordained that our colors must alternate beginning with white,
    this rounds up our definition:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸ºæˆ‘ä»¬å·²ç»è§„å®šæˆ‘ä»¬çš„é¢œè‰²å¿…é¡»ä»ç™½è‰²å¼€å§‹äº¤æ›¿ï¼Œè¿™ä½¿æˆ‘ä»¬çš„å®šä¹‰åœ†æ»¡ç»“æŸï¼š
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we ask Pyret to inspect the value of `web-colors`, we notice that it employs
    an algorithm to prevent traversing infinite objects. You can learn more about
    how that works separately [[Detecting Cycles](cycle-detection.html)].
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬è¦æ±‚ Pyret æ£€æŸ¥ `web-colors` çš„å€¼ï¼Œæˆ‘ä»¬ä¼šæ³¨æ„åˆ°å®ƒä½¿ç”¨äº†ä¸€ä¸ªç®—æ³•æ¥é˜²æ­¢éå†æ— é™å¯¹è±¡ã€‚ä½ å¯ä»¥å•ç‹¬äº†è§£å®ƒæ˜¯å¦‚ä½•å·¥ä½œçš„ [[æ£€æµ‹å¾ªç¯](cycle-detection.html)]ã€‚
- en: 'We can define a helper function, `take`, a variation of which we saw for streams
    [[Streams From Functions](func-as-data.html#%28part._streams-from-funs%29)], to
    inspect a finite prefix of an infinite list:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªè¾…åŠ©å‡½æ•°ï¼Œ`take`ï¼Œè¿™æ˜¯æˆ‘ä»¬åœ¨æµä¸­çœ‹åˆ°çš„ä¸€ç§å˜ä½“ [[ä»å‡½æ•°ç”Ÿæˆæµ](func-as-data.html#%28part._streams-from-funs%29)]ï¼Œç”¨æ¥æ£€æŸ¥æ— é™åˆ—è¡¨çš„ä¸€ä¸ªæœ‰é™å‰ç¼€ï¼š
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'such that:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥è‡³äºï¼š
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 20.2Â Recursive Functions[ğŸ”—](#(part._rec-for-recursive) "Link to here")
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.2 é€’å½’å‡½æ•°[ğŸ”—](#(part._rec-for-recursive) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Based on this, we can now understand recursive functions. Consider a very simple
    example, such as this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: åŸºäºæ­¤ï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥ç†è§£é€’å½’å‡½æ•°ã€‚è€ƒè™‘ä¸€ä¸ªéå¸¸ç®€å•çš„ä¾‹å­ï¼Œæ¯”å¦‚è¿™ä¸ªï¼š
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We might like to think this is equivalent to:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯èƒ½è®¤ä¸ºè¿™ç­‰åŒäºï¼š
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: but if you enter this, Pyret will complain that `sum` is not bound. We must
    instead write
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†å¦‚æœä½ è¾“å…¥è¿™ä¸ªï¼ŒPyret ä¼šæŠ±æ€¨ `sum` æœªç»‘å®šã€‚æˆ‘ä»¬å¿…é¡»æ”¹å†™ä¸º
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: What do you think `rec` does? It binds `sum` to a box initially containing a
    dummy value; it then defines the function in an environment where the name is
    bound, unboxing the use of the name; and finally, it replaces the boxâ€™s content
    with the defined function, following the same pattern we saw earlier for `web-colors`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ è®¤ä¸º `rec` åšäº†ä»€ä¹ˆï¼Ÿå®ƒå°† `sum` ç»‘å®šåˆ°ä¸€ä¸ªæœ€åˆåŒ…å«å ä½ç¬¦å€¼çš„ç›’å­é‡Œï¼›ç„¶åå®ƒåœ¨ä¸€ä¸ªåç§°å·²ç»‘å®šçš„ç¯å¢ƒä¸­å®šä¹‰å‡½æ•°ï¼Œè§£åŒ…åç§°çš„ä½¿ç”¨ï¼›æœ€åï¼Œå®ƒç”¨å®šä¹‰çš„å‡½æ•°æ›¿æ¢ç›’å­çš„å†…å®¹ï¼Œéµå¾ªæˆ‘ä»¬ä¹‹å‰åœ¨
    `web-colors` ä¸­çœ‹åˆ°çš„ç›¸åŒæ¨¡å¼ã€‚
- en: 20.3Â Premature Evaluation[ğŸ”—](#(part._premature-eval) "Link to here")
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.3 æå‰è¯„ä¼°[ğŸ”—](#(part._premature-eval) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Observe that the above description reveals that there is a time between the
    creation of the name and the assignment of a value to it. Can this intermediate
    state be observed? It sure can!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„åˆ°ä¸Šè¿°æè¿°æ­ç¤ºäº†åœ¨åˆ›å»ºåç§°å’Œä¸ºå…¶åˆ†é…å€¼ä¹‹é—´å­˜åœ¨ä¸€ä¸ªæ—¶é—´å·®ã€‚è¿™ä¸ªä¸­é—´çŠ¶æ€å¯ä»¥è¢«è§‚å¯Ÿåˆ°å—ï¼Ÿå½“ç„¶å¯ä»¥ï¼
- en: 'There are generally three solutions to this problem:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: é€šå¸¸æœ‰ä¸‰ä¸ªè§£å†³æ–¹æ¡ˆæ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼š
- en: Make sure the value is sufficiently obscure so that it can never be used in
    a meaningful context. This means values like 0 are especially bad, and indeed
    most common datatypes should be shunned. Indeed, there is no value already in
    use that can be used here that might not be confusing in some context.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ç¡®ä¿å€¼è¶³å¤Ÿéšæ™¦ï¼Œä»¥è‡³äºå®ƒæ°¸è¿œä¸ä¼šåœ¨æœ‰æ„ä¹‰çš„ç¯å¢ƒä¸­ä½¿ç”¨ã€‚è¿™æ„å‘³ç€åƒ 0 è¿™æ ·çš„å€¼å°¤å…¶ç³Ÿç³•ï¼Œå®é™…ä¸Šï¼Œå¤§å¤šæ•°å¸¸è§çš„æ•°æ®ç±»å‹éƒ½åº”è¯¥é¿å…ä½¿ç”¨ã€‚ç¡®å®ï¼Œæ²¡æœ‰å·²ç»ä½¿ç”¨çš„å€¼å¯ä»¥åœ¨è¿™é‡Œä½¿ç”¨ï¼Œè¿™å¯èƒ½ä¼šåœ¨æŸäº›ä¸Šä¸‹æ–‡ä¸­é€ æˆæ··æ·†ã€‚
- en: 'The language might create a new type of value just for use here. For instance,
    imagine this definition of `CList`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è¯­è¨€å¯èƒ½ä¼šä¸ºè¿™é‡Œåˆ›å»ºä¸€ä¸ªæ–°çš„å€¼ç±»å‹ã€‚ä¾‹å¦‚ï¼Œæƒ³è±¡ä¸€ä¸‹ `CList` çš„è¿™ä¸ªå®šä¹‰ï¼š
- en: '[PRE11]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`undef` appears to be a â€œbase caseâ€, thus making `CList` very similar to `List`.
    In truth, however, the `undef` is present only until the first mutation happens,
    after which it will never again be present: the intent is that `r` only contain
    a reference to other `clink`s.'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`undef` çœ‹èµ·æ¥åƒæ˜¯ä¸€ä¸ªâ€œåŸºæœ¬æƒ…å†µâ€ï¼Œè¿™ä½¿å¾— `CList` éå¸¸ç±»ä¼¼äº `List`ã€‚ç„¶è€Œï¼Œå®é™…ä¸Šï¼Œ`undef` åªå­˜åœ¨äºç¬¬ä¸€æ¬¡çªå˜ä¹‹å‰ï¼Œä¹‹åå°†ä¸å†å­˜åœ¨ï¼šæ„å›¾æ˜¯
    `r` åªåŒ…å«å¯¹å…¶ä»– `clink` çš„å¼•ç”¨ã€‚'
- en: The `undef` value can now be used by the language to check for premature uses
    of a cyclic list. However, while this is technically feasible, it imposes a run-time
    penalty. Therefore, this check is usually only performed by languages focused
    on teaching; professional programmers are assumed to be able to manage the consequences
    of such premature use by themselves.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: è¯­è¨€ç°åœ¨å¯ä»¥ä½¿ç”¨ `undef` å€¼æ¥æ£€æŸ¥å¾ªç¯åˆ—è¡¨çš„æå‰ä½¿ç”¨ã€‚ç„¶è€Œï¼Œè™½ç„¶è¿™åœ¨æŠ€æœ¯ä¸Šå¯è¡Œï¼Œä½†å®ƒä¼šå¸¦æ¥è¿è¡Œæ—¶æƒ©ç½šã€‚å› æ­¤ï¼Œè¿™ç§æ£€æŸ¥é€šå¸¸åªç”±ä¸“æ³¨äºæ•™å­¦çš„ç¼–ç¨‹è¯­è¨€æ‰§è¡Œï¼›å‡è®¾ä¸“ä¸šç¨‹åºå‘˜èƒ½å¤Ÿè‡ªå·±ç®¡ç†è¿™ç§æå‰ä½¿ç”¨çš„åæœã€‚
- en: Allow the recursion constructor to be used only in the case of binding functions,
    and then make sure that the right-hand side of the binding is syntactically a
    function. This solution precludes some reasonable programs, but is certainly safe.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å…è®¸é€’å½’æ„é€ å‡½æ•°ä»…åœ¨ç»‘å®šå‡½æ•°çš„æƒ…å†µä¸‹ä½¿ç”¨ï¼Œå¹¶ç¡®ä¿ç»‘å®šçš„å³ä¾§åœ¨è¯­æ³•ä¸Šæ˜¯ä¸€ä¸ªå‡½æ•°ã€‚è¿™ç§è§£å†³æ–¹æ¡ˆæ’é™¤äº†æŸäº›åˆç†çš„ç¨‹åºï¼Œä½†è‚¯å®šæ˜¯å®‰å…¨çš„ã€‚
- en: 20.4Â Cyclic Lists Versus Streams[ğŸ”—](#(part._.Cyclic_.Lists_.Versus_.Streams)
    "Link to here")
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.4Â å¾ªç¯åˆ—è¡¨ä¸æµ[ğŸ”—](#(part._.Cyclic_.Lists_.Versus_.Streams) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: The color list example above is, as we have noted, very reminiscent of stream
    examples. What is the relationship between the two ways of defining infinite data?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æˆ‘ä»¬æ‰€æåˆ°çš„ï¼Œä¸Šé¢çš„é¢œè‰²åˆ—è¡¨ç¤ºä¾‹éå¸¸ç±»ä¼¼äºæµç¤ºä¾‹ã€‚è¿™ä¸¤ç§å®šä¹‰æ— é™æ•°æ®çš„æ–¹å¼ä¹‹é—´æœ‰ä»€ä¹ˆå…³ç³»ï¼Ÿ
- en: 'Cyclic lists have on their side simplicity. The pattern of definition used
    above can actually be encapsulated into a language construct, so programmers do
    not need to wrestle with mutable fields (as above) or thunks (as streams demand).
    This simplicity, however, comes at a price: cyclic lists can only represent strictly
    repeating data, i.e., you cannot define `nats` or `fibs` as cyclic lists. In contrast,
    the function abstraction in a stream makes it generative: each invocation can
    create a truly novel datum (such as the next natural or Fibonacci number). Therefore,
    it is straightforward to implement cyclic lists as streams, but not vice versa.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: å¾ªç¯åˆ—è¡¨åœ¨å…¶ä¸€è¾¹æœ‰ç®€å•æ€§ã€‚ä¸Šé¢ä½¿ç”¨çš„å®šä¹‰æ¨¡å¼å®é™…ä¸Šå¯ä»¥å°è£…æˆä¸€ä¸ªè¯­è¨€æ„é€ ï¼Œè¿™æ ·ç¨‹åºå‘˜å°±ä¸éœ€è¦ä¸å¯å˜å­—æ®µï¼ˆå¦‚ä¸Šæ‰€ç¤ºï¼‰æˆ– thunksï¼ˆæµæ‰€è¦æ±‚çš„ï¼‰ææ–—ã€‚ç„¶è€Œï¼Œè¿™ç§ç®€å•æ€§æ˜¯æœ‰ä»£ä»·çš„ï¼šå¾ªç¯åˆ—è¡¨åªèƒ½è¡¨ç¤ºä¸¥æ ¼é‡å¤çš„æ•°æ®ï¼Œå³ä½ ä¸èƒ½å°†
    `nats` æˆ– `fibs` å®šä¹‰ä¸ºå¾ªç¯åˆ—è¡¨ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œæµä¸­çš„å‡½æ•°æŠ½è±¡ä½¿å…¶å…·æœ‰ç”Ÿæˆæ€§ï¼šæ¯æ¬¡è°ƒç”¨éƒ½å¯ä»¥åˆ›å»ºä¸€ä¸ªçœŸæ­£æ–°é¢–çš„æ•°æ®ï¼ˆå¦‚ä¸‹ä¸€ä¸ªè‡ªç„¶æ•°æˆ–æ–æ³¢é‚£å¥‘æ•°ï¼‰ã€‚å› æ­¤ï¼Œå°†å¾ªç¯åˆ—è¡¨ä½œä¸ºæµå®ç°æ˜¯ç›´æ¥çš„ï¼Œä½†åä¹‹åˆ™ä¸ç„¶ã€‚
- en: 20.1Â Partial Definitions[ğŸ”—](#(part._.Partial_.Definitions) "Link to here")
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.1Â éƒ¨åˆ†å®šä¹‰[ğŸ”—](#(part._.Partial_.Definitions) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'What we need to instead do is to partially define each list, and then complete
    the definition using the other one. However, that is impossible using the above
    definition, because we cannot change anything once it is constructed. Instead,
    therefore, we need:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éœ€è¦åšçš„ç›¸åçš„æ˜¯ï¼Œéƒ¨åˆ†å®šä¹‰æ¯ä¸ªåˆ—è¡¨ï¼Œç„¶åä½¿ç”¨å¦ä¸€ä¸ªåˆ—è¡¨æ¥å®Œæˆå®šä¹‰ã€‚ç„¶è€Œï¼Œä½¿ç”¨ä¸Šè¿°å®šä¹‰è¿™æ˜¯ä¸å¯èƒ½çš„ï¼Œå› ä¸ºæˆ‘ä»¬ä¸€æ—¦æ„å»ºäº†å®ƒå°±ä¸èƒ½å†æ”¹å˜ä»»ä½•ä¸œè¥¿ã€‚å› æ­¤ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦ï¼š
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that this datatype lacks a base case, which should remind you of definitions
    we saw in [Streams From Functions](func-as-data.html#%28part._streams-from-funs%29).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè¿™ä¸ªæ•°æ®ç±»å‹ç¼ºå°‘ä¸€ä¸ªåŸºæœ¬æƒ…å†µï¼Œè¿™åº”è¯¥è®©ä½ æƒ³èµ·æˆ‘ä»¬åœ¨ [ä»å‡½æ•°ç”Ÿæˆæµ](func-as-data.html#%28part._streams-from-funs%29)
    ä¸­çœ‹åˆ°çš„å®šä¹‰ã€‚
- en: 'Using this, we can define:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ï¼š
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Each of these definitions is quite useless by itself, but they each represent
    what we want, and they have a mutable field for the rest, currently holding a
    dummy value. Therefore, itâ€™s clear what we must do next: update the mutable field.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: æ¯ä¸ªè¿™æ ·çš„å®šä¹‰æœ¬èº«éƒ½ç›¸å½“æ— ç”¨ï¼Œä½†å®ƒä»¬å„è‡ªä»£è¡¨æˆ‘ä»¬æƒ³è¦çš„ä¸œè¥¿ï¼Œå¹¶ä¸”å®ƒä»¬éƒ½æœ‰ä¸€ä¸ªå¯å˜å­—æ®µï¼Œç›®å‰æŒæœ‰å ä½ç¬¦å€¼ã€‚å› æ­¤ï¼Œå¾ˆæ˜æ˜¾æˆ‘ä»¬æ¥ä¸‹æ¥å¿…é¡»åšä»€ä¹ˆï¼šæ›´æ–°å¯å˜å­—æ®µã€‚
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Because we have ordained that our colors must alternate beginning with white,
    this rounds up our definition:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸ºæˆ‘ä»¬å·²ç»è§„å®šæˆ‘ä»¬çš„é¢œè‰²å¿…é¡»ä»ç™½è‰²å¼€å§‹äº¤æ›¿ï¼Œè¿™ä½¿æˆ‘ä»¬çš„å®šä¹‰åœ†æ»¡ï¼š
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we ask Pyret to inspect the value of `web-colors`, we notice that it employs
    an algorithm to prevent traversing infinite objects. You can learn more about
    how that works separately [[Detecting Cycles](cycle-detection.html)].
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬è¦æ±‚ Pyret æ£€æŸ¥ `web-colors` çš„å€¼ï¼Œæˆ‘ä»¬ä¼šæ³¨æ„åˆ°å®ƒä½¿ç”¨äº†ä¸€ç§ç®—æ³•æ¥é˜²æ­¢éå†æ— é™å¯¹è±¡ã€‚ä½ å¯ä»¥å•ç‹¬äº†è§£å®ƒæ˜¯å¦‚ä½•å·¥ä½œçš„ [[æ£€æµ‹å¾ªç¯](cycle-detection.html)]ã€‚
- en: 'We can define a helper function, `take`, a variation of which we saw for streams
    [[Streams From Functions](func-as-data.html#%28part._streams-from-funs%29)], to
    inspect a finite prefix of an infinite list:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªè¾…åŠ©å‡½æ•°ï¼Œ`take`ï¼Œè¿™æ˜¯æˆ‘ä»¬åœ¨æµä¸­çœ‹åˆ°çš„ä¸€ç§å˜ä½“ [[ä»å‡½æ•°ç”Ÿæˆæµ](func-as-data.html#%28part._streams-from-funs%29)]ï¼Œæ¥æ£€æŸ¥æ— é™åˆ—è¡¨çš„æœ‰é™å‰ç¼€ï¼š
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'such that:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿å¾—ï¼š
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 20.2Â Recursive Functions[ğŸ”—](#(part._rec-for-recursive) "Link to here")
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.2Â é€’å½’å‡½æ•°[ğŸ”—](#(part._rec-for-recursive) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Based on this, we can now understand recursive functions. Consider a very simple
    example, such as this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: åŸºäºæ­¤ï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥ç†è§£é€’å½’å‡½æ•°ã€‚è€ƒè™‘ä¸€ä¸ªéå¸¸ç®€å•çš„ä¾‹å­ï¼Œæ¯”å¦‚è¿™ä¸ªï¼š
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We might like to think this is equivalent to:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯èƒ½å¸Œæœ›è®¤ä¸ºè¿™ç­‰åŒäºï¼š
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: but if you enter this, Pyret will complain that `sum` is not bound. We must
    instead write
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†å¦‚æœä½ è¾“å…¥è¿™ä¸ªï¼ŒPyret ä¼šæŠ±æ€¨ `sum` æ²¡æœ‰ç»‘å®šã€‚æˆ‘ä»¬å¿…é¡»æ”¹å†™ä¸º
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: What do you think `rec` does? It binds `sum` to a box initially containing a
    dummy value; it then defines the function in an environment where the name is
    bound, unboxing the use of the name; and finally, it replaces the boxâ€™s content
    with the defined function, following the same pattern we saw earlier for `web-colors`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ è®¤ä¸º`rec`åšäº†ä»€ä¹ˆï¼Ÿå®ƒå°†`sum`ç»‘å®šåˆ°ä¸€ä¸ªæœ€åˆåŒ…å«å ä½ç¬¦å€¼çš„ç›’å­ä¸­ï¼›ç„¶ååœ¨ç»‘å®šåç§°çš„ç¯å¢ƒä¸­å®šä¹‰å‡½æ•°ï¼Œè§£åŒ…åç§°çš„ä½¿ç”¨ï¼›æœ€åï¼ŒæŒ‰ç…§æˆ‘ä»¬ä¹‹å‰çœ‹åˆ°çš„`web-colors`çš„ç›¸åŒæ¨¡å¼ï¼Œç”¨å®šä¹‰çš„å‡½æ•°æ›¿æ¢ç›’å­çš„å†…å®¹ã€‚
- en: 20.3Â Premature Evaluation[ğŸ”—](#(part._premature-eval) "Link to here")
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.3Â æå‰è¯„ä¼°[ğŸ”—](#(part._premature-eval) "é“¾æ¥è‡³æ­¤")
- en: Observe that the above description reveals that there is a time between the
    creation of the name and the assignment of a value to it. Can this intermediate
    state be observed? It sure can!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œä¸Šé¢çš„æè¿°æ­ç¤ºäº†åœ¨åç§°åˆ›å»ºå’Œå¯¹å…¶èµ‹å€¼ä¹‹é—´æœ‰ä¸€ä¸ªæ—¶é—´å·®ã€‚è¿™ä¸ªä¸­é—´çŠ¶æ€å¯ä»¥è¢«è§‚å¯Ÿåˆ°å—ï¼Ÿå½“ç„¶å¯ä»¥ï¼
- en: 'There are generally three solutions to this problem:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: é€šå¸¸æœ‰ä¸‰ä¸ªè§£å†³æ–¹æ¡ˆæ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼š
- en: Make sure the value is sufficiently obscure so that it can never be used in
    a meaningful context. This means values like 0 are especially bad, and indeed
    most common datatypes should be shunned. Indeed, there is no value already in
    use that can be used here that might not be confusing in some context.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ç¡®ä¿å€¼è¶³å¤Ÿéšæ™¦ï¼Œä»¥è‡³äºå®ƒæ°¸è¿œä¸ä¼šåœ¨æœ‰æ„ä¹‰çš„ç¯å¢ƒä¸­ä½¿ç”¨ã€‚è¿™æ„å‘³ç€åƒ0è¿™æ ·çš„å€¼ç‰¹åˆ«ç³Ÿç³•ï¼Œå®é™…ä¸Šï¼Œå¤§å¤šæ•°å¸¸è§çš„æ•°æ®ç±»å‹éƒ½åº”è¯¥é¿å…ä½¿ç”¨ã€‚ç¡®å®ï¼Œæ²¡æœ‰å·²ç»ä½¿ç”¨çš„å€¼å¯ä»¥åœ¨è¿™é‡Œä½¿ç”¨ï¼Œè¿™å¯èƒ½åœ¨æŸäº›ä¸Šä¸‹æ–‡ä¸­é€ æˆæ··æ·†ã€‚
- en: 'The language might create a new type of value just for use here. For instance,
    imagine this definition of `CList`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è¯­è¨€å¯èƒ½ä¼šä¸ºè¿™é‡Œåˆ›å»ºä¸€ç§å…¨æ–°çš„å€¼ç±»å‹ã€‚ä¾‹å¦‚ï¼Œæƒ³è±¡ä¸€ä¸‹`CList`çš„å®šä¹‰å¦‚ä¸‹ï¼š
- en: '[PRE21]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`undef` appears to be a â€œbase caseâ€, thus making `CList` very similar to `List`.
    In truth, however, the `undef` is present only until the first mutation happens,
    after which it will never again be present: the intent is that `r` only contain
    a reference to other `clink`s.'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`undef`çœ‹èµ·æ¥åƒæ˜¯ä¸€ä¸ªâ€œåŸºæœ¬æƒ…å†µâ€ï¼Œè¿™ä½¿å¾—`CList`éå¸¸ç±»ä¼¼äº`List`ã€‚ç„¶è€Œï¼Œå®é™…ä¸Šï¼Œ`undef`åªå­˜åœ¨äºç¬¬ä¸€æ¬¡çªå˜ä¹‹å‰ï¼Œä¹‹åå°†ä¸å†å­˜åœ¨ï¼šæ„å›¾æ˜¯`r`åªåŒ…å«å¯¹å…¶ä»–`clink`çš„å¼•ç”¨ã€‚'
- en: The `undef` value can now be used by the language to check for premature uses
    of a cyclic list. However, while this is technically feasible, it imposes a run-time
    penalty. Therefore, this check is usually only performed by languages focused
    on teaching; professional programmers are assumed to be able to manage the consequences
    of such premature use by themselves.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œ`undef`å€¼å¯ä»¥è¢«è¯­è¨€ç”¨æ¥æ£€æŸ¥å¾ªç¯åˆ—è¡¨çš„æå‰ä½¿ç”¨ã€‚ç„¶è€Œï¼Œè™½ç„¶è¿™åœ¨æŠ€æœ¯ä¸Šå¯è¡Œï¼Œä½†å®ƒä¼šå¸¦æ¥è¿è¡Œæ—¶æƒ©ç½šã€‚å› æ­¤ï¼Œè¿™ç§æ£€æŸ¥é€šå¸¸åªç”±ä¸“æ³¨äºæ•™å­¦çš„ç¼–ç¨‹è¯­è¨€æ‰§è¡Œï¼›å‡è®¾ä¸“ä¸šç¨‹åºå‘˜èƒ½å¤Ÿè‡ªå·±ç®¡ç†è¿™ç§æå‰ä½¿ç”¨çš„åæœã€‚
- en: Allow the recursion constructor to be used only in the case of binding functions,
    and then make sure that the right-hand side of the binding is syntactically a
    function. This solution precludes some reasonable programs, but is certainly safe.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å…è®¸é€’å½’æ„é€ å‡½æ•°ä»…åœ¨ç»‘å®šå‡½æ•°çš„æƒ…å†µä¸‹ä½¿ç”¨ï¼Œå¹¶ç¡®ä¿ç»‘å®šçš„å³ä¾§æ˜¯è¯­æ³•ä¸Šæ­£ç¡®çš„å‡½æ•°ã€‚è¿™ç§è§£å†³æ–¹æ¡ˆæ’é™¤äº†æŸäº›åˆç†çš„ç¨‹åºï¼Œä½†è‚¯å®šæ˜¯å®‰å…¨çš„ã€‚
- en: 20.4Â Cyclic Lists Versus Streams[ğŸ”—](#(part._.Cyclic_.Lists_.Versus_.Streams)
    "Link to here")
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.4Â å¾ªç¯åˆ—è¡¨ä¸æµ[ğŸ”—](#(part._.Cyclic_.Lists_.Versus_.Streams) "é“¾æ¥è‡³æ­¤")
- en: The color list example above is, as we have noted, very reminiscent of stream
    examples. What is the relationship between the two ways of defining infinite data?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æˆ‘ä»¬æ‰€æåˆ°çš„ï¼Œä¸Šé¢çš„é¢œè‰²åˆ—è¡¨ç¤ºä¾‹éå¸¸ç±»ä¼¼äºæµç¤ºä¾‹ã€‚è¿™ä¸¤ç§å®šä¹‰æ— é™æ•°æ®çš„æ–¹å¼ä¹‹é—´æœ‰ä»€ä¹ˆå…³ç³»å‘¢ï¼Ÿ
- en: 'Cyclic lists have on their side simplicity. The pattern of definition used
    above can actually be encapsulated into a language construct, so programmers do
    not need to wrestle with mutable fields (as above) or thunks (as streams demand).
    This simplicity, however, comes at a price: cyclic lists can only represent strictly
    repeating data, i.e., you cannot define `nats` or `fibs` as cyclic lists. In contrast,
    the function abstraction in a stream makes it generative: each invocation can
    create a truly novel datum (such as the next natural or Fibonacci number). Therefore,
    it is straightforward to implement cyclic lists as streams, but not vice versa.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: å¾ªç¯åˆ—è¡¨åœ¨å…¶ä¸€ä¾§å…·æœ‰ç®€å•æ€§ã€‚ä¸Šé¢ä½¿ç”¨çš„å®šä¹‰æ¨¡å¼å®é™…ä¸Šå¯ä»¥å°è£…æˆè¯­è¨€æ„é€ ï¼Œè¿™æ ·ç¨‹åºå‘˜å°±ä¸éœ€è¦ä¸å¯å˜å­—æ®µï¼ˆå¦‚ä¸Šæ‰€è¿°ï¼‰æˆ–å»¶è¿Ÿæ‰§è¡Œï¼ˆå¦‚æµæ‰€è¦æ±‚ï¼‰è¿›è¡Œæ–—äº‰ã€‚ç„¶è€Œï¼Œè¿™ç§ç®€å•æ€§æ˜¯æœ‰ä»£ä»·çš„ï¼šå¾ªç¯åˆ—è¡¨åªèƒ½è¡¨ç¤ºä¸¥æ ¼é‡å¤çš„æ•°æ®ï¼Œå³ä½ ä¸èƒ½å°†`nats`æˆ–`fibs`å®šä¹‰ä¸ºå¾ªç¯åˆ—è¡¨ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œæµä¸­çš„å‡½æ•°æŠ½è±¡ä½¿å…¶å…·æœ‰ç”Ÿæˆæ€§ï¼šæ¯æ¬¡è°ƒç”¨éƒ½å¯ä»¥åˆ›å»ºä¸€ä¸ªçœŸæ­£æ–°é¢–çš„æ•°æ®ï¼ˆä¾‹å¦‚ä¸‹ä¸€ä¸ªè‡ªç„¶æ•°æˆ–æ–æ³¢é‚£å¥‘æ•°ï¼‰ã€‚å› æ­¤ï¼Œå°†å¾ªç¯åˆ—è¡¨ä½œä¸ºæµå®ç°æ˜¯ç›´æ¥çš„ï¼Œä½†åä¹‹åˆ™ä¸ç„¶ã€‚
