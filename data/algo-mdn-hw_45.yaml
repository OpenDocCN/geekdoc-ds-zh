- en: Virtual Memory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟内存
- en: 原文：[https://en.algorithmica.org/hpc/external-memory/virtual/](https://en.algorithmica.org/hpc/external-memory/virtual/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/external-memory/virtual/](https://en.algorithmica.org/hpc/external-memory/virtual/)
- en: 'Early operating systems gave every process the freedom of reading and modifying
    any memory region they want, including those allocated for other processes. While
    this keeps things simple, it also poses some problems:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的操作系统赋予每个进程读取和修改任何所需内存区域的自由，包括为其他进程分配的内存区域。虽然这样做使事情变得简单，但也带来了一些问题：
- en: What if one of the processes is buggy or outright malicious? How do we prevent
    it from modifying the memory allocated for other processes while still keeping
    inter-process communication through memory possible?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果其中一个进程有bug或恶意行为怎么办？我们如何防止它修改为其他进程分配的内存，同时仍然通过内存保持进程间通信？
- en: How do we deal with memory fragmentation? Say, we have 4MB of memory, process
    A allocates the first 1MB for itself, then process B claims the next 2MB, then
    A terminates and releases its memory, and then process C comes and asks for a
    contiguous 2MB region — and can’t get it because we only have two separate 1MB
    slices. Restarting process B or somehow stopping it and shifting all its data
    and pointers by one megabyte doesn’t seem like a good solution.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何处理内存碎片化？比如说，我们有4MB的内存，进程A为自己分配了前1MB，然后进程B声称下2MB，接着A终止并释放了其内存，然后进程C来请求一个连续的2MB区域——但它无法得到，因为我们只有两个独立的1MB片段。重启进程B或以某种方式停止它，并将所有数据和指针移动一个兆字节，似乎不是一个好办法。
- en: How do we access non-RAM memory types? How do we plug a flash drive and read
    a specific file from it?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何访问非RAM内存类型？我们如何连接一个闪存驱动器并从中读取特定文件？
- en: These problems are not that critical for some specialized computer systems such
    as GPUs, where you typically solve just one task at a time and have full control
    over the computation, but they are absolutely essential for modern multitasking
    operating systems — and they solve all these problems with a technique called
    *virtual memory*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些专门的计算机系统，如GPU，这些问题并不那么关键，因为通常一次只解决一个任务，并且对计算有完全的控制权，但对于现代多任务操作系统来说，这些问题绝对是必不可少的——它们通过一种称为*虚拟内存*的技术解决了所有这些问题。
- en: '### [#](https://en.algorithmica.org/hpc/external-memory/virtual/#memory-paging)Memory
    Paging'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/external-memory/virtual/#memory-paging)内存分页'
- en: Virtual memory gives each process the impression that it fully controls a contiguous
    region of memory, which in reality may be mapped to multiple smaller blocks of
    the physical memory — which includes both the main memory (RAM) and external memory
    (HDD, SSD).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟内存给每个进程一种完全控制连续内存区域的印象，而实际上这些区域可能映射到物理内存的多个较小的块——这包括主内存（RAM）和外存（HDD，SSD）。
- en: '![](../Images/7b70071a77f6138c747c18296dda8a28.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/7b70071a77f6138c747c18296dda8a28.png)'
- en: To achieve this, the memory address space is divided into *pages* (typically
    4KB in size), which are the base units of memory that the programs can request
    from the operating system. The memory system maintains a special hardware data
    structure called the *page table*, which contains the mappings of virtual page
    addresses to the physical ones. When a process accesses data using its virtual
    memory address, the memory system calculates its page number (by right-shifting
    it by $12$ if $4096=2^{12}$ is the page size), looks up in the page table that
    its physical address is, and forwards the read or write request to where that
    data is actually stored.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，内存地址空间被划分为*页面*（通常大小为4KB），这是程序可以从操作系统请求的内存的基本单位。内存系统维护一个特殊硬件数据结构，称为*页面表*，它包含虚拟页面地址到物理地址的映射。当进程使用其虚拟内存地址访问数据时，内存系统计算其页面号（如果页面大小为4096=2^12，则通过右移12位），在页面表中查找其物理地址，并将读或写请求转发到实际存储数据的位置。
- en: Since the address translation needs to be done for each memory request, and
    the number of memory pages itself may be large (e.g., 16G RAM / 4K page size =
    4M pages), address translation poses a difficult problem in itself. One way to
    speed it up is to use a special cache for the page table itself called *translation
    lookaside buffer* (TLB), and the other is to [increase the page size](/hpc/cpu-cache/paging)
    so that the total number of memory pages is made smaller at the cost of reduced
    granularity.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个内存请求都需要进行地址转换，并且内存页的数量本身可能很大（例如，16G RAM / 4K页面大小 = 4M页面），地址转换本身就是一个难题。加快其速度的一种方法是为页面表本身使用一个特殊的缓存，称为*转换后备缓冲区*（TLB），另一种方法是[增加页面大小](/hpc/cpu-cache/paging)，以减少内存页的总数，代价是降低了粒度。
- en: '### [#](https://en.algorithmica.org/hpc/external-memory/virtual/#mapping-external-memory)Mapping
    External Memory'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/external-memory/virtual/#mapping-external-memory)映射外部内存'
- en: 'The mechanism of virtual memory also allows using external memory types quite
    transparently. Modern operating systems support [memory mapping](https://en.wikipedia.org/wiki/Mmap),
    which lets you open a file and use its contents as if they were in the main memory:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟内存的机制还允许透明地使用外部内存类型。现代操作系统支持[内存映射](https://en.wikipedia.org/wiki/Mmap)，这允许你打开一个文件，并像它们在主内存中一样使用其内容：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here we map a 4K file, which can fit entirely on just a single memory page,
    but when we open larger files, its reads will be done lazily when we request a
    certain page, and its writes will be buffered and committed to the file system
    when the operating decides to (usually on the program termination or when the
    system runs out of RAM).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们映射一个4K文件，它可以完全适应单个内存页面，但是当我们请求某个页面时，其读取将延迟执行，而其写入将被缓冲，并在操作系统决定时提交到文件系统（通常在程序终止或系统内存不足时）。
- en: A technique that has the same operating principle, but the reverse intention
    is the *swap file*, which lets the operating system automatically use parts of
    an SSD or an HDD as an extension of the main memory when there is not enough real
    RAM. This lets the systems that run out of memory just experience a terrible slowdown
    instead of crashing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相同操作原理但相反意图的技术是*交换文件*，它允许操作系统在真实RAM不足时自动将SSD或HDD的部分空间作为主内存的扩展。这使得内存不足的系统只是经历严重的速度下降，而不是崩溃。
- en: This seamless integration of the main and external memory essentially turns
    RAM into an “L4 cache” for the external memory, which is a convenient way to think
    about it from the algorithm design perspective. [← Memory Hierarchy](https://en.algorithmica.org/hpc/external-memory/hierarchy/)[External
    Memory Model →](https://en.algorithmica.org/hpc/external-memory/model/)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 主内存和外部内存的无缝集成本质上将RAM变成了外部内存的“L4缓存”，从算法设计角度来看，这是一种方便的思考方式。[← 存储层次](https://en.algorithmica.org/hpc/external-memory/hierarchy/)[外部内存模型
    →](https://en.algorithmica.org/hpc/external-memory/model/)
