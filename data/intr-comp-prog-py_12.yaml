- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: A SIMPLISTIC INTRODUCTION TO ALGORITHMIC COMPLEXITY
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对算法复杂性的简单介绍
- en: The most important thing to think about when designing and implementing a program
    is that it should produce results that can be relied upon. We want our bank balances
    to be calculated correctly. We want the fuel injectors in our automobiles to inject
    appropriate amounts of fuel. We would prefer that neither airplanes nor operating
    systems crash.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 设计和实现程序时最重要的是，它应该产生可依赖的结果。我们希望我们的银行余额能够正确计算。我们希望汽车中的燃油喷射器能够注入适量的燃料。我们更希望飞机和操作系统都不会崩溃。
- en: Sometimes performance is an important aspect of correctness. This is most obvious
    for programs that need to run in real time. A program that warns airplanes of
    potential obstructions needs to issue the warning before the obstructions are
    encountered. Performance can also affect the utility of many non-real-time programs.
    The number of transactions completed per minute is an important metric when evaluating
    the utility of database systems. Users care about the time required to start an
    application on their phone. Biologists care about how long their phylogenetic
    inference calculations take.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有时性能是正确性的一个重要方面。这对于需要实时运行的程序最为明显。一个警告飞机潜在障碍物的程序需要在遇到障碍物之前发出警告。性能也会影响许多非实时程序的实用性。在评估数据库系统的实用性时，每分钟完成的事务数量是一个重要指标。用户关心在手机上启动应用程序所需的时间。生物学家关心它们的系统发育推断计算需要多长时间。
- en: Writing efficient programs is not easy. The most straightforward solution is
    often not the most efficient. Computationally efficient algorithms often employ
    subtle tricks that can make them difficult to understand. Consequently, programmers
    often increase the **conceptual complexity** of a program in an effort to reduce
    its **computational complexity**. To do this in a sensible way, we need to understand
    how to go about estimating the computational complexity of a program. That is
    the topic of this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 编写高效程序并不容易。最简单的解决方案往往不是最有效的。计算上高效的算法通常采用微妙的技巧，这可能使它们难以理解。因此，程序员往往增加程序的**概念复杂性**以降低其**计算复杂性**。为了以合理的方式做到这一点，我们需要了解如何估算程序的计算复杂性。这是本章的主题。
- en: 11.1 Thinking about Computational Complexity
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 思考计算复杂性
- en: How should one go about answering the question “How long will the following
    function take to run?”
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如何回答“以下函数运行需要多长时间？”这个问题？
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We could run the program on some input and time it. But that wouldn't be particularly
    informative because the result would depend upon
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在某些输入上运行程序并计时。但这并不会提供特别有用的信息，因为结果会依赖于
- en: The speed of the computer on which it is run
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行程序的计算机的速度
- en: The efficiency of the Python implementation on that machine
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在那台机器上Python实现的效率
- en: The value of the input
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入的值
- en: We get around the first two issues by using a more abstract measure of time.
    Instead of measuring time in microseconds, we measure time in terms of the number
    of basic steps executed by the program.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用更抽象的时间度量来解决前两个问题。我们不是以微秒来衡量时间，而是通过程序执行的基本步骤数量来衡量时间。
- en: For simplicity, we will use a **random access machine** as our model of computation.
    In a random access machine, steps are executed sequentially, one at a time.[^(66)](#c11-fn-0001)
    A **step** is an operation that takes a fixed amount of time, such as binding
    a variable to an object, making a comparison, executing an arithmetic operation,
    or accessing an object in memory.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将使用**随机访问机器**作为我们的计算模型。在随机访问机器中，步骤是依次执行的，一次一个。[^(66)](#c11-fn-0001)
    一个**步骤**是一个固定时间内执行的操作，比如将变量绑定到对象、进行比较、执行算术操作或访问内存中的对象。
- en: Now that we have a more abstract way to think about the meaning of time, we
    turn to the question of dependence on the value of the input. We deal with that
    by moving away from expressing time complexity as a single number and instead
    relating it to the sizes of the inputs. This allows us to compare the efficiency
    of two algorithms by talking about how the running time of each grows with respect
    to the sizes of the inputs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种更抽象的方式来思考时间的意义，我们转向输入值的依赖性问题。我们通过不再将时间复杂性表达为单一数字，而是与输入的大小相关联来解决这个问题。这使我们能够通过讨论每个算法的运行时间如何随输入大小的变化而变化，从而比较两种算法的效率。
- en: Of course, the actual running time of an algorithm can depend not only upon
    the sizes of the inputs but also upon their values. Consider, for example, the
    linear search algorithm implemented by
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，算法的实际运行时间不仅取决于输入的大小，还取决于它们的值。考虑线性搜索算法的实现。
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Suppose that `L` is a list containing a million elements, and consider the call
    `linear_search(L, 3)`. If the first element in `L` is `3`, `linear_search` will
    return `True` almost immediately. On the other hand, if `3` is not in `L`, `linear_search`
    will have to examine all one million elements before returning `False`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`L`是一个包含一百万个元素的列表，考虑调用`linear_search(L, 3)`。如果`L`中的第一个元素是`3`，`linear_search`几乎会立即返回`True`。另一方面，如果`3`不在`L`中，`linear_search`必须检查所有一百万个元素才能返回`False`。
- en: 'In general, there are three broad cases to think about:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，有三种广泛的情况需要考虑：
- en: The best-case running time is the running time of the algorithm when the inputs
    are as favorable as possible. That is, the **best-case** running time is the minimum
    running time over all the possible inputs of a given size. For `linear_search`,
    the best-case running time is independent of the size of `L`.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳情况运行时间是算法在输入尽可能有利时的运行时间。也就是说，**最佳情况**运行时间是给定大小的所有可能输入中的最小运行时间。对于`linear_search`，最佳情况运行时间与`L`的大小无关。
- en: Similarly, the **worst-case** running time is the maximum running time over
    all the possible inputs of a given size. For `linear_search`, the worst-case running
    time is linear in the size of `L`.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，**最坏情况**运行时间是给定大小的所有可能输入中的最大运行时间。对于`linear_search`，最坏情况运行时间与`L`的大小成线性关系。
- en: By analogy with the definitions of the best-case and worst-case running time,
    the **average-case** (also called **expected-case**) running time is the average
    running time over all possible inputs of a given size. Alternatively, if one has
    some *a priori* information about the distribution of input values (e.g., that
    `90%` of the time `x` is in `L`), one can take that into account.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与最佳情况和最坏情况运行时间的定义类比，**平均情况**（也称为**期望情况**）运行时间是给定大小的所有可能输入的平均运行时间。或者，如果人们对输入值的分布有一些*先验*信息（例如，`90%`的时间`x`在`L`中），可以考虑这些信息。
- en: 'People usually focus on the worst case. All engineers share a common article
    of faith, Murphy''s Law: If something can go wrong, it will go wrong. The worst-case
    provides an **upper bound** on the running time. This is critical when there is
    a time constraint on how long a computation can take. It is not good enough to
    know that “most of the time” the air traffic control system warns of impending
    collisions before they occur.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 人们通常关注最坏情况。所有工程师都有一个共同信条，墨菲定律：如果某件事可能出错，它就一定会出错。最坏情况提供了运行时间的**上限**。在对计算所需时间有限制时，这一点至关重要。仅仅知道“在大多数情况下”航空交通控制系统会在碰撞发生前发出警告是不够的。
- en: 'Let''s look at the worst-case running time of an iterative implementation of
    the factorial function:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看阶乘函数的迭代实现的最坏情况运行时间：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The number of steps required to run this program is something like `2` (`1`
    for the initial assignment statement and `1` for the `return`) `+ 5n` (counting
    `1` step for the test in the `while`, `2` steps for the first assignment statement
    in the `while` loop, and `2` steps for the second assignment statement in the
    loop). So, for example, if `n` is `1000`, the function will execute roughly `5002`
    steps.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序所需的步骤数大约是`2`（`1`步用于初始赋值语句，`1`步用于`return）` `+ 5n`（计算`while`中的测试需要`1`步，在`while`循环中的第一个赋值语句需要`2`步，循环中的第二个赋值语句需要`2`步）。所以，例如，如果`n`是`1000`，函数大约会执行`5002`步。
- en: It should be immediately obvious that as `n` gets large, worrying about the
    difference between `5n` and `5n+2` is kind of silly. For this reason, we typically
    ignore additive constants when reasoning about running time. Multiplicative constants
    are more problematical. Should we care whether the computation takes `1000` steps
    or `5000` steps? Multiplicative factors can be important. Whether a search engine
    takes a half second or `2.5` seconds to service a query can be the difference
    between whether people use that search engine or go to a competitor.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，随着`n`增大，担心`5n`与`5n+2`之间的差异有些无谓。因此，当我们推理运行时间时，通常会忽略加性常数。乘法常数则更为复杂。我们是否需要关心计算需要`1000`步还是`5000`步？乘法因素可能很重要。搜索引擎响应查询所需的时间是`0.5`秒还是`2.5`秒，可能会影响用户是使用该搜索引擎还是转向竞争对手。
- en: On the other hand, when comparing two different algorithms, it is often the
    case that even multiplicative constants are irrelevant. Recall that in Chapter 3
    we looked at two algorithms, exhaustive enumeration and bisection search, for
    finding an approximation to the square root of a floating-point number. Functions
    based on these algorithms are shown in [Figure 11-1](#c11-fig-0001) and [Figure
    11-2](#c11-fig-0002).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在比较两个不同算法时，即使乘法常数也往往是无关紧要的。回想一下，在第3章中，我们查看了两种算法：穷举枚举和二分搜索，用于寻找浮点数平方根的近似值。基于这些算法的函数在[图11-1](#c11-fig-0001)和[图11-2](#c11-fig-0002)中显示。
- en: '![c11-fig-0001.jpg](../images/c11-fig-0001.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![c11-fig-0001.jpg](../images/c11-fig-0001.jpg)'
- en: '[Figure 11-1](#c11-fig-0001a) Using exhaustive enumeration to approximate square
    root'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-1](#c11-fig-0001a) 使用穷举枚举来近似平方根'
- en: '![c11-fig-0002.jpg](../images/c11-fig-0002.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![c11-fig-0002.jpg](../images/c11-fig-0002.jpg)'
- en: '[Figure 11-2](#c11-fig-0002a) Using bisection search to approximate square
    root'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-2](#c11-fig-0002a) 使用二分搜索来近似平方根'
- en: We saw that exhaustive enumeration was so slow as to be impractical for many
    combinations of values for `x` and `epsilon`. For example, evaluating `square_root_exhaustive(100,
    0.0001)` requires roughly one billion iterations of the `while` loop. In contrast,
    evaluating `square_root_bi(100, 0.0001)` takes roughly 20 iterations of a slightly
    more complex `while` loop. When the difference in the number of iterations is
    this large, it doesn't really matter how many instructions are in the loop. That
    is, the multiplicative constants are irrelevant.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，穷举枚举在处理许多`x`和`epsilon`值组合时是如此缓慢，以至于不切实际。例如，评估`square_root_exhaustive(100,
    0.0001)`大约需要十亿次`while`循环迭代。相比之下，评估`square_root_bi(100, 0.0001)`大约只需20次稍微复杂的`while`循环迭代。当迭代次数差异如此之大时，循环中的指令数量其实并不重要。也就是说，乘法常数是无关紧要的。
- en: 11.2 Asymptotic Notation
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 渐进符号
- en: We use something called **asymptotic notation** to provide a formal way to talk
    about the relationship between the running time of an algorithm and the size of
    its inputs. The underlying motivation is that almost any algorithm is sufficiently
    efficient when run on small inputs. What we typically need to worry about is the
    efficiency of the algorithm when run on very large inputs. As a proxy for “very
    large,” asymptotic notation describes the complexity of an algorithm as the size
    of its inputs approaches infinity.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一种称为**渐进符号**的东西，提供了一种正式的方式来讨论算法运行时间与其输入大小之间的关系。其根本动机是，几乎任何算法在小输入上运行时都是足够高效的。我们通常需要担心的是算法在非常大输入上运行时的效率。作为“非常大”的代理，渐进符号描述了当输入大小趋向于无穷大时算法的复杂度。
- en: Consider, for example, the code in [Figure 11-3](#c11-fig-0003).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑[图11-3](#c11-fig-0003)中的代码。
- en: '![c11-fig-0003.jpg](../images/c11-fig-0003.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![c11-fig-0003.jpg](../images/c11-fig-0003.jpg)'
- en: '[Figure 11-3](#c11-fig-0003a) Asymptotic complexity'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-3](#c11-fig-0003a) 渐进复杂度'
- en: If we assume that each line of code takes one unit of time to execute, the running
    time of this function can be described as `1000 + x + 2x`². The constant `1000`
    corresponds to the number of times the first loop is executed. The term `x` corresponds
    to the number of times the second loop is executed. Finally, the term `2x`² corresponds
    to the time spent executing the two statements in the nested `for` loop. Consequently,
    the call `f(10)` will print
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设每行代码执行一次需要一个单位的时间，则该函数的运行时间可以描述为`1000 + x + 2x`²。常数`1000`对应于第一个循环执行的次数。项`x`对应于第二个循环执行的次数。最后，项`2x`²对应于在嵌套`for`循环中执行两个语句所花费的时间。因此，调用`f(10)`将打印
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: and the call `f(1000)` will print
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 而调用`f(1000)`将打印
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For small values of `x` the constant term dominates. If `x` is `10`, `over 80%`
    of the steps are accounted for by the first loop. On the other hand, if `x` is
    `1000`, each of the first two loops accounts for only about `0.05%` of the steps.
    When `x` is `1,000,000`, the first loop takes about `0.00000005%` of the total
    time and the second loop about `0.00005%`*.* A full `2,000,000,000,000` of the
    `2,000,001,001,000` steps are in the body of the inner `for` loop.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小的`x`值，常数项占主导地位。如果`x`是`10`，则超过`80%`的步骤由第一个循环完成。另一方面，如果`x`是`1000`，前两个循环仅占约`0.05%`的步骤。当`x`为`1,000,000`时，第一个循环大约占总时间的`0.00000005%`，第二个循环约占`0.00005%`。总共`2,000,000,000,000`的`2,000,001,001,000`步骤在内部`for`循环的主体中。
- en: 'Clearly, we can get a meaningful notion of how long this code will take to
    run on very large inputs by considering only the inner loop, i.e., the quadratic
    component. Should we care about the fact that this loop takes `2x`² steps rather
    than `x`² steps? If your computer executes roughly 100 million steps per second,
    evaluating `f` will take about `5.5` hours. If we could reduce the complexity
    to `x`² steps, it would take about `2.25` hours. In either case, the moral is
    the same: we should probably look for a more efficient algorithm.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，通过只考虑内层循环，即二次项，我们可以获得对这段代码在非常大输入下运行时间的有意义的概念。我们是否在乎这个循环需要`2x²`步而不是`x²`步？如果你的计算机每秒执行大约1亿步，评估`f`将需要大约`5.5`小时。如果我们能将复杂度降低到`x²`步，将只需大约`2.25`小时。在这两种情况下，结论是一样的：我们可能应该寻找更高效的算法。
- en: 'This kind of analysis leads us to use the following rules of thumb in describing
    the asymptotic complexity of an algorithm:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分析引导我们在描述算法的渐近复杂度时使用以下经验法则：
- en: If the running time is the sum of multiple terms, keep the one with the largest
    growth rate, and drop the others.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果运行时间是多个项的总和，保留增长率最大的项，去掉其他项。
- en: If the remaining term is a product, drop any constants.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果剩余项是一个乘积，则去掉任何常数。
- en: The most commonly used asymptotic notation is called “**Big O**” notation.[^(67)](#c11-fn-0002)
    Big O notation is used to give an **upper bound** on the asymptotic growth (often
    called the **order of growth**) of a function. For example, the formula `f(x)
    ∈ O(x`²`)` means that the function `f` grows no faster than the quadratic polynomial
    `x`², in an asymptotic sense.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的渐近符号被称为“**大O**”符号。大O符号用于给出函数的渐近增长的**上界**（通常称为**增长阶**）。例如，公式`f(x) ∈ O(x²)`意味着函数`f`的增长速度不快于二次多项式`x²`，从渐近意义上看。
- en: Many computer scientists will abuse Big O notation by making statements like,
    “the complexity of `f(x)` `is O(x`²`)`.” By this they mean that in the worst case
    `f` will take no more than `O(x`²`)` steps to run. The difference between a function
    being “in `O(x`²`)`” and “being `O(x`²`)`” is subtle but important. Saying that
    `f(x) ∈ O(x`²`)` does not preclude the worst-case running time of `f` from being
    considerably less than `O(x`²`)`. To avoid this kind of confusion we will use
    **Big Theta** (*θ*) when we are describing something that is both an upper and
    a **lower bound** on the asymptotic worst-case running time. This is called a
    **tight bound**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 许多计算机科学家会滥用大O符号，像这样表述：“`f(x)`的复杂度`是 O(x²)`。”他们的意思是在最坏情况下，`f`的运行步骤不超过`O(x²)`。一个函数“在`O(x²)`”与“是`O(x²)`”之间的区别是微妙但重要的。说`f(x)
    ∈ O(x²)`并不排除`f`的最坏情况下运行时间明显小于`O(x²)`。为避免这种混淆，我们在描述某个上界和**下界**的渐近最坏情况下运行时间时，会使用**大Θ**（*θ*）。这称为**紧界**。
- en: '**Finger exercise**: What is the asymptotic complexity of each of the following
    functions?'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**指尖练习**：以下每个函数的渐近复杂度是什么？'
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 11.3 Some Important Complexity Classes
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 一些重要的复杂度类
- en: Some of the most common instances of Big O (and *θ*) are listed below. In each
    case, n is a measure of the size of the inputs to the function.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 大O（和*θ*）的最常见实例如下所示。在每种情况下，n是输入大小的度量。
- en: '`O(1)` denotes **constant** running time.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O(1)`表示**常数**运行时间。'
- en: '`O(log n)` denotes **logarithmic** running time.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O(log n)`表示**对数**运行时间。'
- en: '`O(n)` denotes **linear** running time.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O(n)`表示**线性**运行时间。'
- en: '`O(n log n)` denotes **log-linear** running time**.**'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O(n log n)`表示**对数线性**运行时间。'
- en: '`O(n`^k`)` denotes **polynomial** running time. Notice that k is a constant.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O(n^k)`表示**多项式**运行时间。注意k是一个常数。'
- en: '`O(c`^n`)` denotes **exponential** running time. Here a constant is being raised
    to a power based on the size of the input.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O(c^n)`表示**指数**运行时间。这里常数是基于输入大小的幂。'
- en: 11.3.1 Constant Complexity
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 常数复杂度
- en: This indicates that the asymptotic complexity is independent of the size of
    the inputs. There are very few interesting programs in this class, but all programs
    have pieces (for example, finding out the length of a Python list or multiplying
    two floating-point numbers) that fit into this class. Constant running time does
    not imply that there are no loops or recursive calls in the code, but it does
    imply that the number of iterations or recursive calls is independent of the size
    of the inputs.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明渐进复杂度与输入的大小无关。这个类别中有很少有趣的程序，但所有程序都有一些片段（例如，计算 Python 列表的长度或乘两个浮点数），适合这个类别。常数运行时间并不意味着代码中没有循环或递归调用，但它确实意味着迭代或递归调用的次数与输入的大小无关。
- en: 11.3.2 Logarithmic Complexity
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2 对数复杂度
- en: Such functions have a complexity that grows as the log of at least one of the
    inputs. Binary search, for example, is logarithmic in the length of the list being
    searched. (We will look at binary search and analyze its complexity in Chapter
    12.) By the way, we don't care about the base of the log, since the difference
    between using one base and another is merely a constant multiplicative factor.
    For example, `O(log`[2]`(x)) = O(log`[2]`(10)`*`log`[10]`(x))`. There are lots
    of interesting functions with logarithmic complexity. Consider
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的函数具有复杂度，随着至少一个输入的对数而增长。二分查找，例如，在被搜索列表的长度上是对数级的。（我们将在第12章中讨论二分查找并分析其复杂度。）顺便提一下，我们不关心对数的底数，因为使用一个底数和另一个底数之间的差异仅仅是一个常数乘法因子。例如，`O(log`[2]`(x)) = O(log`[2]`(10)`*`log`[10]`(x))`。有许多有趣的函数具有对数复杂度。考虑一下
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since there are no function or method calls in this code, we know that we only
    have to look at the loops to determine the complexity class. There is only one
    loop, so the only thing that we need to do is characterize the number of iterations.
    That boils down to the number of times we can use `//` (floor division) to divide
    `i` by `10` before getting a result of `0`. So, the complexity of `int_to_str`
    is in `O(log(i))`. More precisely, it is order *θ*(log(i)), because log(i) is
    a tight bound.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这段代码中没有函数或方法调用，我们知道我们只需查看循环以确定复杂度类别。只有一个循环，因此我们需要做的就是描述迭代次数。这归结为在得到`0`的结果之前，我们可以使用`//`（向下取整除法）将`i`除以`10`的次数。因此，`int_to_str`的复杂度是`O(log(i))`。更确切地说，它是
    *θ*(log(i))，因为 log(i) 是一个紧密的界限。
- en: What about the complexity of
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 那么复杂度如何呢
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The complexity of converting `n` to a string using `int_to_str` is order *θ*`(log(n))`,
    and `int_to_str` returns a string of length `log(n)`. The `for` loop will be executed
    order *θ*`(len(string_rep))` times, i.e., order *θ*`(log(n))` times. Putting it
    all together, and assuming that a character representing a digit can be converted
    to an integer in constant time, the program will run in time proportional to *θ*`(log(n))
    +` *θ*`(log(n))`, which makes it order *θ*`(log(n))`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`int_to_str`将`n`转换为字符串的复杂度是 *θ*`(log(n))`，并且`int_to_str`返回长度为`log(n)`的字符串。`for`循环将执行
    *θ*`(len(string_rep))` 次，即 *θ*`(log(n))` 次。综合来看，假设表示数字的字符可以在常数时间内转换为整数，程序的运行时间将与
    *θ*`(log(n)) +` *θ*`(log(n))` 成正比，这使得它的复杂度是 *θ*`(log(n))`。
- en: 11.3.3 Linear Complexity
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.3 线性复杂度
- en: Many algorithms that deal with lists or other kinds of sequences are linear
    because they touch each element of the sequence a constant (greater than `0`)
    number of times.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 许多处理列表或其他类型序列的算法是线性的，因为它们以一个常数（大于`0`）的次数访问序列的每个元素。
- en: Consider, for example,
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function is linear in the length of `s`, i.e., *θ*`(len(s))`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在`s`的长度上是线性的，即 *θ*`(len(s))`。
- en: Of course, a program does not need to have a loop to have linear complexity.
    Consider
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一个程序不需要有循环也可以具有线性复杂度。考虑一下
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are no loops in this code, so in order to analyze the complexity we need
    to figure out how many recursive calls are made. The series of calls is simply
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中没有循环，因此为了分析复杂度，我们需要弄清楚进行多少次递归调用。调用序列就是
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The length of this series, and thus the complexity of the function, is order
    *θ*`(x)`*.*
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列的长度，因此函数的复杂度，是 *θ*`(x)`*。
- en: Thus far in this chapter we have looked only at the time complexity of our code.
    This is fine for algorithms that use a constant amount of space, but this implementation
    of factorial does not have that property. As we discussed in Chapter 4, each recursive
    call of `factorial` causes a new stack frame to be allocated, and that frame continues
    to occupy memory until the call returns. At the maximum depth of recursion, this
    code will have allocated `x` stack frames, so the space complexity is in `O(x)`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只关注了代码的时间复杂度。这对于使用恒定空间的算法是可以的，但这个阶乘实现并不具备这一特性。如我们在第4章讨论的，每次递归调用`factorial`都会分配一个新的堆栈帧，并且该帧在调用返回之前会占用内存。在递归的最大深度，代码将分配`x`个堆栈帧，因此空间复杂度为`O(x)`。
- en: The impact of space complexity is harder to appreciate than the impact of time
    complexity. Whether a program takes one minute or two minutes to complete is quite
    visible to its user, but whether it uses one megabyte or two megabytes of memory
    is largely invisible to users. This is why people typically give more attention
    to time complexity than to space complexity. The exception occurs when a program
    needs more space than is available in the fast memory of the machine on which
    it is run.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 空间复杂度的影响比时间复杂度更难以察觉。程序完成所需的一分钟或两分钟对用户来说非常明显，但它使用一兆字节还是两兆字节的内存则大多对用户是不可见的。这就是为什么人们通常更关注时间复杂度而不是空间复杂度的原因。例外情况发生在程序需要的空间超过运行它的机器的快速内存时。
- en: 11.3.4 Log-Linear Complexity
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.4 对数线性复杂度
- en: This is slightly more complicated than the complexity classes we have looked
    at thus far. It involves the product of two terms, each of which depends upon
    the size of the inputs. It is an important class, because many practical algorithms
    are log-linear. The most commonly used log-linear algorithm is probably merge
    sort, which is order *θ*`(n log(n))`*,* where `n` is the length of the list being
    sorted. We will look at that algorithm and analyze its complexity in Chapter 12.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这比我们迄今为止看到的复杂度类稍微复杂一些。它涉及两个项的乘积，每个项都依赖于输入的大小。这是一个重要的类别，因为许多实际算法是对数线性的。最常用的对数线性算法可能是归并排序，其复杂度为*θ*`(n
    log(n))`，其中`n`是待排序列表的长度。我们将在第12章中查看该算法并分析其复杂度。
- en: 11.3.5 Polynomial Complexity
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.5 多项式复杂度
- en: The most commonly used polynomial algorithms are **quadratic**, i.e., their
    complexity grows as the square of the size of their input. Consider, for example,
    the function in [Figure 11-4](#c11-fig-0004), which implements a subset test.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的多项式算法是**二次**算法，即它们的复杂度随着输入大小的平方而增长。例如，考虑在[图11-4](#c11-fig-0004)中实现的子集测试函数。
- en: '![c11-fig-0004.jpg](../images/c11-fig-0004.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![c11-fig-0004.jpg](../images/c11-fig-0004.jpg)'
- en: '[Figure 11-4](#c11-fig-0004a) Implementation of subset test'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-4](#c11-fig-0004a) 子集测试的实现'
- en: Each time the inner loop is reached it is executed order *θ*`(len(L2))` times.
    The function `is_subset` will execute the outer loop order *θ*`(len(L1))` times,
    so the inner loop will be reached order *θ*`(len(L1)`*`len(L2))`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每次到达内层循环时，它将执行*θ*`(len(L2))`次。函数`is_subset`将执行外层循环*θ*`(len(L1))`次，因此内层循环将达到*θ*`(len(L1)`*`len(L2))`。
- en: Now consider the function `intersect` in [Figure 11-5](#c11-fig-0005). The running
    time for the part of the code building the list that might contain duplicates
    is clearly order *θ*(`len(L1)`*`len(L2))`. At first glance, it appears that the
    part of the code that builds the duplicate-free list is linear in the length of
    `tmp`, but it is not.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑[图11-5](#c11-fig-0005)中的函数`intersect`。构建可能包含重复项的列表的代码部分的运行时间显然是*θ*(`len(L1)`*`len(L2)`)。乍一看，构建无重复列表的代码部分似乎是线性的，但实际上并非如此。
- en: '![c11-fig-0005.jpg](../images/c11-fig-0005.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![c11-fig-0005.jpg](../images/c11-fig-0005.jpg)'
- en: '[Figure 11-5](#c11-fig-0005a) Implementation of list intersection'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-5](#c11-fig-0005a) 列表交集的实现'
- en: Evaluating the expression `e not in result` potentially involves looking at
    each element in `result`, and is therefore *θ*`(len(result))`; consequently the
    second part of the implementation is order *θ*`(len(tmp)`*`len(result))`. However,
    since the lengths of `result` and `tmp` are bounded by the length of the smaller
    of `L1` and `L2`, and since we ignore additive terms, the complexity of `intersect`
    is *θ*`(len(L1)`*`len(L2))`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 评估表达式`e not in result`可能涉及查看`result`中的每个元素，因此是*θ*`(len(result))`；因此，实现的第二部分的复杂度为*θ*`(len(tmp)`*`len(result))`。然而，由于`result`和`tmp`的长度受限于`L1`和`L2`中较小者的长度，并且我们忽略了加法项，`intersect`的复杂度为*θ*`(len(L1)`*`len(L2))`。
- en: 11.3.6 Exponential Complexity
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.6 指数复杂性
- en: As we will see later in this book, many important problems are inherently exponential,
    i.e., solving them completely can require time that is exponential in the size
    of the input. This is unfortunate, since it rarely pays to write a program that
    has a reasonably high probability of taking exponential time to run. Consider,
    for example, the code in [Figure 11-6](#c11-fig-0006).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本书后面看到的，许多重要问题本质上是指数级的，即完全解决它们可能需要与输入大小成指数关系的时间。这是令人遗憾的，因为编写一个在合理概率上需要指数时间运行的程序往往得不偿失。考虑一下[图
    11-6](#c11-fig-0006)中的代码。
- en: '![c11-fig-0006.jpg](../images/c11-fig-0006.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![c11-fig-0006.jpg](../images/c11-fig-0006.jpg)'
- en: '[Figure 11-6](#c11-fig-0006a) Generating the power set'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-6](#c11-fig-0006a) 生成幂集'
- en: The function `gen_powerset(L)` returns a list of lists that contains all possible
    combinations of the elements of `L`. For example, if `L` is `['x', 'y']`, the
    powerset of `L` will be a list containing the lists `[]`, `['x']`, `['y']`, and
    `['x', 'y']`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`gen_powerset(L)`返回一个列表的列表，包含`L`的所有可能组合。例如，如果`L`是`['x', 'y']`，那么`L`的幂集将是一个包含列表`[]`、`['x']`、`['y']`和`['x',
    'y']`的列表。
- en: The algorithm is a bit subtle. Consider a list of `n` elements. We can represent
    any combination of elements by a string of `n` `0's` and `1's`, where a `1` represents
    the presence of an element and a `0` its absence. The combination containing no
    items is represented by a string of all `0's`, the combination containing all
    of the items is represented by a string of all `1's`, the combination containing
    only the first and last elements is represented by `100…001`, etc.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法有些微妙。考虑一个包含`n`个元素的列表。我们可以用一个包含`n`个`0`和`1`的字符串来表示元素的任何组合，其中`1`表示元素的存在，`0`表示其不存在。包含没有项目的组合用全是`0`的字符串表示，包含所有项目的组合用全是`1`的字符串表示，仅包含第一个和最后一个元素的组合用`100…001`表示，等等。
- en: 'Generating all sublists of a list `L` of length `n` can be done as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 生成长度为`n`的列表`L`的所有子列表可以如下进行：
- en: Generate all `n`-bit binary numbers. These are the numbers from `0` to `2`^n
    - 1.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成所有`n`位的二进制数。这些数字从`0`到`2`^n - 1。
- en: For each of these `2`^n binary numbers, `b`, generate a list by selecting those
    elements of `L` that have an index corresponding to a `1` in `b`. For example,
    if `L` is `['x', 'y', 'z']` and `b` is `101`, generate the list `['x', 'z']`.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个`2`^n的二进制数`b`，通过选择`L`中索引与`b`中的`1`对应的元素来生成一个列表。例如，如果`L`是`['x', 'y', 'z']`，而`b`是`101`，则生成列表`['x',
    'z']`。
- en: Try running `gen_powerset` on a list containing the first 10 letters of the
    alphabet. It will finish quite quickly and produce a list with 1024 elements.
    Next, try running `gen_powerset` on the first 20 letters of the alphabet. It will
    take more than a bit of time to run, and will return a list with about a million
    elements. If you try running `gen_powerset` on all 26 letters, you will probably
    get tired of waiting for it to complete, unless your computer runs out of memory
    trying to build a list with tens of millions of elements. Don't even think about
    trying to run `gen_powerset` on a list containing all uppercase and lowercase
    letters. Step 1 of the algorithm generates order *θ*`(2`^(len(L))`)` binary numbers,
    so the algorithm is exponential in len(L`)`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在包含字母表前10个字母的列表上运行`gen_powerset`。它会很快完成，并生成一个包含1024个元素的列表。接下来，尝试在前20个字母的列表上运行`gen_powerset`。这将需要一些时间，并返回一个大约有一百万个元素的列表。如果你在所有26个字母的列表上运行`gen_powerset`，你可能会厌倦等待它完成，除非你的计算机因尝试构建一个包含数千万个元素的列表而耗尽内存。甚至不要考虑在包含所有大写和小写字母的列表上运行`gen_powerset`。算法的第1步生成的二进制数是*θ*`(2`^(len(L))`)`，因此算法在len(L`)`中是指数级的。
- en: Does this mean that we cannot use computation to tackle exponentially hard problems?
    Absolutely not. It means that we have to find algorithms that provide approximate
    solutions to these problems or that find exact solutions on some instances of
    the problem. But that is a subject for later chapters.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着我们不能使用计算来解决指数级困难的问题？绝对不是。这意味着我们必须找到提供这些问题的近似解或在某些实例上找到精确解的算法。但这是后面章节的主题。
- en: 11.3.7 Comparisons of Complexity Classes
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.7 复杂性类的比较
- en: The plots in this section are intended to convey an impression of the implications
    of an algorithm being in one or another of these complexity classes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的图表旨在传达算法处于这些复杂性类之一或另一类的含义。
- en: The plot on the left in [Figure 11-7](#c11-fig-0007) compares the growth of
    a constant-time algorithm to that of a logarithmic algorithm. Note that the size
    of the input has to reach about 30,000 for the two of them to cross, even for
    the very small constant of 15\. When the size of the input is 100,000, the time
    required by a logarithmic algorithm is still quite small. The moral is that logarithmic
    algorithms are almost as good as constant-time ones.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-7](#c11-fig-0007)左侧的图表比较了常数时间算法与对数算法的增长。注意，输入的大小必须达到约 30,000，两者才会相交，即使常数非常小（15）。当输入大小为
    100,000 时，对数算法所需的时间仍然相当小。其道理是，对数算法几乎与常数时间算法一样优秀。'
- en: The plot on the right of [Figure 11-7](#c11-fig-0007) illustrates the dramatic
    difference between logarithmic algorithms and linear algorithms. While we needed
    to look at large inputs to appreciate the difference between constant-time and
    logarithmic-time algorithms, the difference between logarithmic-time and linear-time
    algorithms is apparent even on small inputs. The dramatic difference in the relative
    performance of logarithmic and linear algorithms does not mean that linear algorithms
    are bad. In fact, much of the time a linear algorithm is acceptably efficient.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-7](#c11-fig-0007)右侧的图表展示了对数算法与线性算法之间的显著差异。虽然我们需要观察较大输入才能理解常数时间算法与对数时间算法之间的差异，但对数时间算法与线性时间算法之间的差异即使在小输入上也很明显。对数算法和线性算法相对性能的显著差异并不意味着线性算法不好。实际上，线性算法在很多情况下效率足够可接受。'
- en: '![c11-fig-0007.jpg](../images/c11-fig-0007.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![c11-fig-0007.jpg](../images/c11-fig-0007.jpg)'
- en: '[Figure 11-7](#c11-fig-0007a) Constant, logarithmic, and linear growth'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-7](#c11-fig-0007) 常数、对数和线性增长'
- en: The plot on the left in [Figure 11-8](#c11-fig-0008) shows that there is a significant
    difference between `O(n)` and `O(n log(n))`*.* Given how slowly `log(n)` grows,
    this may seem surprising, but keep in mind that it is a multiplicative factor.
    Also keep in mind that in many practical situations, `O(n log(n))` is fast enough
    to be useful. On the other hand, as the plot on the right in [Figure 11-8](#c11-fig-0008)
    suggests, there are many situations in which a quadratic rate of growth is prohibitive.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-8](#c11-fig-0008)左侧的图表显示 `O(n)` 和 `O(n log(n))` 之间存在显著差异。考虑到 `log(n)`
    的增长非常缓慢，这可能看起来令人惊讶，但请记住，这是一个乘法因子。还要记住，在许多实际情况中，`O(n log(n))` 是足够快速且有用的。另一方面，正如[图
    11-8](#c11-fig-0008)右侧的图所示，存在许多情况下，二次增长的速度是不可接受的。'
- en: '![c11-fig-0008.jpg](../images/c11-fig-0008.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![c11-fig-0008.jpg](../images/c11-fig-0008.jpg)'
- en: '[Figure 11-8](#c11-fig-0008a) Linear, log-linear, and quadratic growth'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-8](#c11-fig-0008a) 线性、对数线性和二次增长'
- en: The plots in [Figure 11-9](#c11-fig-0009) are about exponential complexity.
    In the plot on the left of [Figure 11-9](#c11-fig-0009), the numbers to the left
    of the y-axis run from `0` to `6`. However, the notation `1e29` on the top left
    means that each tick on the y-axis should be multiplied by `10`^(29). So, the
    plotted y-values range from `0` to roughly `6.6*10`^(29). The curve for quadratic
    growth is almost invisible in the plot on the left in [Figure 11-9](#c11-fig-0009).
    That's because an exponential function grows so quickly that relative to the `y`
    value of the highest point (which determines the scale of the y‑axis), the `y`
    values of earlier points on the exponential curve (and all points on the quadratic
    curve) are almost indistinguishable from `0`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-9](#c11-fig-0009)中的图表讨论了指数复杂度。在[图 11-9](#c11-fig-0009)左侧的图中，y轴左侧的数字从
    `0` 到 `6`。然而，左上角的标记 `1e29` 意味着 y 轴上的每个刻度都应乘以 `10`^(29)。因此，绘制的 y 值范围从 `0` 到大约 `6.6*10`^(29)。在[图
    11-9](#c11-fig-0009)左侧的图中，二次增长的曲线几乎不可见。这是因为指数函数增长得如此迅速，以至于与最高点的 y 值（决定 y 轴的刻度）相比，指数曲线上早期点的
    y 值（以及二次曲线上所有点）几乎与 `0` 无法区分。'
- en: The plot on the right in [Figure 11-9](#c11-fig-0009) addresses this issue by
    using a logarithmic scale on the y‑axis. One can readily see that exponential
    algorithms are impractical for all but the smallest of inputs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-9](#c11-fig-0009)右侧的图表通过在 y 轴上使用对数尺度解决了这个问题。人们很容易看到，指数算法对于除了最小输入之外的所有情况都是不切实际的。'
- en: Notice that when plotted on a logarithmic scale, an exponential curve appears
    as a straight line. We will have more to say about this in later chapters.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在对数尺度上绘制时，指数曲线呈现为直线。我们将在后面的章节中对此进行更深入的探讨。
- en: '![c11-fig-0009.jpg](../images/c11-fig-0009.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![c11-fig-0009.jpg](../images/c11-fig-0009.jpg)'
- en: '[Figure 11-9](#c11-fig-0009a) Quadratic and exponential growth'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-9](#c11-fig-0009a) 二次和指数增长'
- en: 11.4 Terms Introduced in Chapter
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 本章引入的术语
- en: conceptual complexity
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概念复杂度
- en: computational complexity
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算复杂度
- en: random access machine
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机访问机
- en: computational step
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算步骤
- en: best-case complexity
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳情况复杂度
- en: worst-case complexity
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最坏情况复杂度
- en: average-case complexity
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均情况复杂度
- en: expected-case complexity
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 期望情况复杂度
- en: upper bound
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上界
- en: asymptotic notation
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渐进记号
- en: Big O notation
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大O记号
- en: order of growth
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增长阶
- en: Big Theta notation
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大θ记号
- en: lower bound
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下界
- en: tight bound
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧界
- en: constant time
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常数时间
- en: logarithmic time
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数时间
- en: linear time
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性时间
- en: log-linear time
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数线性时间
- en: polynomial time
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多项式时间
- en: quadratic time
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二次时间
- en: exponential time
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数时间
