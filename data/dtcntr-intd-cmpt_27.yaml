- en: 9.2Â DictionariesğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.2Â å­—å…¸ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/dictionaries.html](https://dcic-world.org/2025-08-27/dictionaries.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/dictionaries.html](https://dcic-world.org/2025-08-27/dictionaries.html)
- en: '| Â Â Â Â [9.2.1Â Creating and Using a Dictionary](#%28part._.Creating_and_.Using_a_.Dictionary%29)
    |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â [9.2.1Â åˆ›å»ºå’Œä½¿ç”¨å­—å…¸](#%28part._.Creating_and_.Using_a_.Dictionary%29) |'
- en: '| Â Â Â Â [9.2.2Â Searching Through the Values in a Dictionary](#%28part._.Searching_.Through_the_.Values_in_a_.Dictionary%29)
    |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â [9.2.2Â åœ¨å­—å…¸ä¸­æœç´¢å€¼](#%28part._.Searching_.Through_the_.Values_in_a_.Dictionary%29)
    |'
- en: '| Â Â Â Â [9.2.3Â Dictionaries with More Complex Values](#%28part._.Dictionaries_with_.More_.Complex_.Values%29)
    |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â [9.2.3Â å…·æœ‰æ›´å¤æ‚å€¼çš„å­—å…¸](#%28part._.Dictionaries_with_.More_.Complex_.Values%29)
    |'
- en: '| Â Â Â Â [9.2.4Â Dictionaries versus Dataclasses](#%28part._.Dictionaries_versus_.Dataclasses%29)
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â [9.2.4Â å­—å…¸ä¸æ•°æ®ç±»](#%28part._.Dictionaries_versus_.Dataclasses%29) |'
- en: '| Â Â Â Â Â Â [Summary](#%28part._.Summary%29) |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â Â Â [æ‘˜è¦](#%28part._.Summary%29) |'
- en: So far, we have seen several ways to process sequential data such as lists.
    In each of Pyret and Python, we can use `filter` and `map` to perform certain
    operations that yield lists. In Pyret, we used recursion to aggregate list data
    into a single value. In Python, we used for-loops for this task. While we could
    use recursion or for-loops for `filter` and `map` tasks as well, using these named
    operators makes it easier for someone else to quickly read your code and understand
    what kind of operation it is performing.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»çœ‹åˆ°äº†å‡ ç§å¤„ç†é¡ºåºæ•°æ®ï¼ˆå¦‚åˆ—è¡¨ï¼‰çš„æ–¹æ³•ã€‚åœ¨Pyretå’ŒPythonä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `filter` å’Œ `map` æ¥æ‰§è¡Œäº§ç”Ÿåˆ—è¡¨çš„æŸäº›æ“ä½œã€‚åœ¨Pyretä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨é€’å½’å°†åˆ—è¡¨æ•°æ®èšåˆä¸ºå•ä¸ªå€¼ã€‚åœ¨Pythonä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨forå¾ªç¯æ¥å®Œæˆè¿™é¡¹ä»»åŠ¡ã€‚è™½ç„¶æˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨é€’å½’æˆ–forå¾ªç¯æ¥å¤„ç†
    `filter` å’Œ `map` ä»»åŠ¡ï¼Œä½†ä½¿ç”¨è¿™äº›å‘½åçš„æ“ä½œç¬¦å¯ä»¥ä½¿å…¶ä»–äººæ›´å¿«åœ°é˜…è¯»ä½ çš„ä»£ç å¹¶ç†è§£å®ƒæ‰§è¡Œçš„æ“ä½œç±»å‹ã€‚
- en: 'This observation raises a question though: are there other common code patterns
    that get written with recursion or for-loops that would benefit from specialized
    handling?'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªè§‚å¯Ÿç»“æœå¼•å‘äº†ä¸€ä¸ªé—®é¢˜ï¼šæ˜¯å¦æœ‰å…¶ä»–å¸¸è§çš„ä»£ç æ¨¡å¼æ˜¯ç”¨é€’å½’æˆ–forå¾ªç¯ç¼–å†™çš„ï¼Œè¿™äº›æ¨¡å¼ä¼šä»ä¸“é—¨çš„å¤„ç†ä¸­å—ç›Šï¼Ÿ
- en: 'As an example, imagine that we had a dataclass for airline flights. Each flight
    has its origin and destination cities, the flight code (including the airline
    name and flight number), and the number of seats on the flight. Imagine also that
    we have functions to look up the destination and seating capacity of individual
    flights:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªç”¨äºèˆªç­çš„æ•°æ®ç±»ã€‚æ¯ä¸ªèˆªç­éƒ½æœ‰å…¶å‡ºå‘åœ°å’Œç›®çš„åœ°åŸå¸‚ã€èˆªç­ä»£ç ï¼ˆåŒ…æ‹¬èˆªç©ºå…¬å¸åç§°å’Œèˆªç­å·ï¼‰ï¼Œä»¥åŠèˆªç­ä¸Šçš„åº§ä½æ•°ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œæˆ‘ä»¬è¿˜æ‹¥æœ‰æŸ¥æ‰¾å•ä¸ªèˆªç­çš„ç›®çš„åœ°å’Œåº§ä½å®¹é‡çš„å‡½æ•°ï¼š
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Do Now!
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Look at the similarity between `destination1` and `capacity1`. How might we
    share the common code between these two functions?
  id: totrans-13
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: çœ‹çœ‹ `destination1` å’Œ `capacity1` ä¹‹é—´çš„ç›¸ä¼¼æ€§ã€‚æˆ‘ä»¬å¦‚ä½•åœ¨è¿™ä¸¤ä¸ªå‡½æ•°ä¹‹é—´å…±äº«é€šç”¨ä»£ç ï¼Ÿ
- en: 'Both `destination1` and `capacity1` traverse the list of flights looking for
    the one with the given flight-code, then extract a piece of information from that
    flight. The for-loop isnâ€™t doing anything other than looking for the desired flight
    data. This suggests that a `find_flight` helper could be useful here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`destination1` å’Œ `capacity1` éƒ½éå†èˆªç­åˆ—è¡¨ï¼Œå¯»æ‰¾å…·æœ‰ç»™å®šèˆªç­ä»£ç çš„èˆªç­ï¼Œç„¶åä»è¯¥èˆªç­ä¸­æå–ä¸€äº›ä¿¡æ¯ã€‚forå¾ªç¯é™¤äº†å¯»æ‰¾æ‰€éœ€çš„èˆªç­æ•°æ®å¤–ï¼Œæ²¡æœ‰åšå…¶ä»–ä»»ä½•äº‹æƒ…ã€‚è¿™è¡¨æ˜åœ¨è¿™é‡Œä½¿ç”¨ä¸€ä¸ª
    `find_flight` è¾…åŠ©å‡½æ•°å¯èƒ½ä¼šæœ‰ç”¨ï¼š'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Searching for a single element from a list based on a specific piece of information
    is common in many programs. This is so common, in fact, that languages provide
    special data structures and operations just to help with this task. In Python,
    this data structure is called a dictionary (hashmap, hashtable, and associative
    arrays are names for similar data structures in other languages, though there
    are key nuances that distinguish all these variations).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨åŸºäºç‰¹å®šä¿¡æ¯ä»åˆ—è¡¨ä¸­æœç´¢å•ä¸ªå…ƒç´ åœ¨è®¸å¤šç¨‹åºä¸­å¾ˆå¸¸è§ã€‚äº‹å®ä¸Šï¼Œè¿™ç§æƒ…å†µå¦‚æ­¤æ™®éï¼Œä»¥è‡³äºè¯­è¨€æä¾›äº†ç‰¹æ®Šçš„æ•°æ®ç»“æ„å’Œæ“ä½œæ¥å¸®åŠ©å®Œæˆè¿™é¡¹ä»»åŠ¡ã€‚åœ¨Pythonä¸­ï¼Œè¿™ç§æ•°æ®ç»“æ„ç§°ä¸ºå­—å…¸ï¼ˆåœ¨å…¶ä»–è¯­è¨€ä¸­ï¼Œç±»ä¼¼çš„æ•°æ®ç»“æ„è¢«ç§°ä¸ºhashmapã€hashtableå’Œå…³è”æ•°ç»„ï¼Œå°½ç®¡æ‰€æœ‰è¿™äº›å˜ä½“éƒ½æœ‰ä¸€äº›å…³é”®çš„åŒºåˆ«ï¼‰ã€‚
- en: 9.2.1Â Creating and Using a Dictionary[ğŸ”—](#(part._.Creating_and_.Using_a_.Dictionary)
    "Link to here")
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1Â åˆ›å»ºå’Œä½¿ç”¨å­—å…¸[ğŸ”—](#(part._.Creating_and_.Using_a_.Dictionary) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'A dictionary maps unique values (called keys) to corresponding pieces of data
    for each key (called values). Here is our flight example written instead as a
    dictionary instead of a list:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: å­—å…¸å°†å”¯ä¸€çš„å€¼ï¼ˆç§°ä¸ºé”®ï¼‰æ˜ å°„åˆ°æ¯ä¸ªé”®å¯¹åº”çš„æ•°æ®ç‰‡æ®µï¼ˆç§°ä¸ºå€¼ï¼‰ã€‚ä»¥ä¸‹æ˜¯æˆ‘ä»¬å°†èˆªç­ç¤ºä¾‹æ”¹å†™ä¸ºå­—å…¸è€Œä¸æ˜¯åˆ—è¡¨çš„å½¢å¼ï¼š
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The general form of a dictionary is:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: å­—å…¸çš„ä¸€èˆ¬å½¢å¼æ˜¯ï¼š
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Dictionaries are designed to enable easy lookup of values give a key. To get
    the
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: å­—å…¸è¢«è®¾è®¡æˆèƒ½å¤Ÿé€šè¿‡é”®å€¼è½»æ¾æŸ¥æ‰¾å€¼ã€‚ä¸ºäº†è·å–
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'associated with key `''CSA-145''`, we can write simply:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: å…³è”åˆ°é”® `'CSA-145'` çš„ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•åœ°å†™ï¼š
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To get the number of seats on flight `''CSA-145''`, we can simply write:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: è¦è·å–èˆªç­`'CSA-145'`çš„åº§ä½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•åœ°å†™ä¸‹ï¼š
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In other words, the dictionary data structure removes the need to traverse
    a list to find the `Flight` with a specific key. The dictionary lookup operation
    does that work for us. Actually, dictionaries are even more nuanced: depending
    on how they are designed, dictionaries can retrieve the value for a key without
    traversing all the values (or even any other value). In general, you can assume
    that dictionary-based lookup is significantly faster than a list-based one. How
    this works is a more advanced topic; some of this content is explained in [SECREF].'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: æ¢å¥è¯è¯´ï¼Œå­—å…¸æ•°æ®ç»“æ„æ¶ˆé™¤äº†éå†åˆ—è¡¨ä»¥æ‰¾åˆ°å…·æœ‰ç‰¹å®šé”®çš„`Flight`çš„éœ€è¦ã€‚å­—å…¸æŸ¥æ‰¾æ“ä½œä¸ºæˆ‘ä»¬å®Œæˆäº†è¿™é¡¹å·¥ä½œã€‚å®é™…ä¸Šï¼Œå­—å…¸ç”šè‡³æ›´åŠ å¾®å¦™ï¼šæ ¹æ®å®ƒä»¬çš„è®¾è®¡æ–¹å¼ï¼Œå­—å…¸å¯ä»¥åœ¨ä¸éå†æ‰€æœ‰å€¼ï¼ˆç”šè‡³ä»»ä½•å…¶ä»–å€¼ï¼‰çš„æƒ…å†µä¸‹æ£€ç´¢é”®çš„å€¼ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œä½ å¯ä»¥å‡è®¾åŸºäºå­—å…¸çš„æŸ¥æ‰¾æ¯”åŸºäºåˆ—è¡¨çš„æŸ¥æ‰¾è¦å¿«å¾—å¤šã€‚è¿™æ˜¯æ›´é«˜çº§çš„è¯é¢˜ï¼›å…¶ä¸­ä¸€äº›å†…å®¹åœ¨[SECREF]ä¸­æœ‰æ‰€è§£é‡Šã€‚
- en: 'One limitation of dictionaries is that they allow only one value per key. Letâ€™s
    consider a different example, this time one that uses rooms in a building as keys
    and occupants as values:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: å­—å…¸çš„ä¸€ä¸ªå±€é™æ€§æ˜¯å®ƒä»¬åªå…è®¸æ¯ä¸ªé”®ä¸€ä¸ªå€¼ã€‚è®©æˆ‘ä»¬è€ƒè™‘ä¸€ä¸ªä¸åŒçš„ä¾‹å­ï¼Œè¿™æ¬¡ä½¿ç”¨å»ºç­‘ä¸­çš„æˆ¿é—´ä½œä¸ºé”®ï¼Œå ç”¨è€…ä½œä¸ºå€¼ï¼š
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'What if someone new moves into office 412? In Python, we can the value for
    that key as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæœ‰äººæ¬è¿›äº†åŠå…¬å®¤412ï¼Ÿåœ¨Pythonä¸­ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·æ›´æ”¹è¯¥é”®çš„å€¼ï¼š
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, any use of `office_dict[412]` will evaluate to `'Zeynep'` instead of `'Marisol'`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œä»»ä½•å¯¹`office_dict[412]`çš„ä½¿ç”¨éƒ½å°†è¯„ä¼°ä¸º`'Zeynep'`è€Œä¸æ˜¯`'Marisol'`ã€‚
- en: 9.2.2Â Searching Through the Values in a Dictionary[ğŸ”—](#(part._.Searching_.Through_the_.Values_in_a_.Dictionary)
    "Link to here")
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.2Â åœ¨å­—å…¸ä¸­æœç´¢å€¼[ğŸ”—](#(part._.Searching_.Through_the_.Values_in_a_.Dictionary) "é“¾æ¥åˆ°æ­¤å¤„")
- en: What if we wanted to find all of the flights with more than 100 seats? For this,
    we have to search through all of the key-value pairs and check their balances.
    This again sounds like we need a for-loop. What does that look like on a dictionary
    though?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æƒ³æ‰¾åˆ°æ‰€æœ‰åº§ä½æ•°è¶…è¿‡100çš„èˆªç­å‘¢ï¼Ÿä¸ºæ­¤ï¼Œæˆ‘ä»¬å¿…é¡»éå†æ‰€æœ‰çš„é”®å€¼å¯¹å¹¶æ£€æŸ¥å®ƒä»¬çš„ä½™é¢ã€‚è¿™å¬èµ·æ¥åˆåƒæ˜¯æˆ‘ä»¬éœ€è¦ä¸€ä¸ªforå¾ªç¯ã€‚ä½†åœ¨å­—å…¸ä¸Šè¿™çœ‹èµ·æ¥ä¼šæ˜¯ä»€ä¹ˆæ ·å­å‘¢ï¼Ÿ
- en: 'Turns out, it looks much like writing a for loop on a list (at least in Python).
    Hereâ€™s a program that creates a list of the flights with more than 100 seats:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æœè¡¨æ˜ï¼Œè¿™çœ‹èµ·æ¥å°±åƒåœ¨åˆ—è¡¨ä¸Šç¼–å†™forå¾ªç¯ï¼ˆè‡³å°‘åœ¨Pythonä¸­æ˜¯è¿™æ ·ï¼‰ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªåˆ›å»ºåº§ä½æ•°è¶…è¿‡100ä¸ªåº§ä½çš„èˆªç­åˆ—è¡¨çš„ç¨‹åºï¼š
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, the for-loop iterates over the keys. Within the loop, we use each key
    to retrieve its corresponding `Flight`, perform the balance check on the `Flight`,
    then put the `Flight` in our running list if it meets our criterion.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œforå¾ªç¯éå†é”®ã€‚åœ¨å¾ªç¯å†…éƒ¨ï¼Œæˆ‘ä»¬ä½¿ç”¨æ¯ä¸ªé”®æ¥æ£€ç´¢å…¶å¯¹åº”çš„`Flight`ï¼Œå¯¹`Flight`è¿›è¡Œä½™é¢æ£€æŸ¥ï¼Œç„¶åå¦‚æœå®ƒç¬¦åˆæˆ‘ä»¬çš„æ ‡å‡†ï¼Œå°±å°†`Flight`æ”¾å…¥æˆ‘ä»¬çš„è¿è¡Œåˆ—è¡¨ä¸­ã€‚
- en: Exercise
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Create a dictionary that maps names of classrooms or meeting rooms to the numbers
    of seats that they have. Write expressions to:'
  id: totrans-41
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åˆ›å»ºä¸€ä¸ªå°†æ•™å®¤æˆ–ä¼šè®®å®¤çš„åç§°æ˜ å°„åˆ°å®ƒä»¬åº§ä½æ•°çš„å­—å…¸ã€‚ç¼–å†™è¡¨è¾¾å¼æ¥ï¼š
- en: ''
  id: totrans-42
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Look up how many seats are in a specific room
  id: totrans-43
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: æŸ¥è¯¢ç‰¹å®šæˆ¿é—´æœ‰å¤šå°‘åº§ä½
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Change the capacity of a specific room to have 10 more seats than it did initially
  id: totrans-46
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: å°†ç‰¹å®šæˆ¿é—´çš„å®¹é‡æ”¹ä¸ºæ¯”æœ€åˆå¤š10ä¸ªåº§ä½
- en: ''
  id: totrans-47
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-48
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Find all rooms that can seat at least 50 students
  id: totrans-49
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: æ‰¾å‡ºå¯ä»¥å®¹çº³è‡³å°‘50åå­¦ç”Ÿçš„æ‰€æœ‰æˆ¿é—´
- en: 9.2.3Â Dictionaries with More Complex Values[ğŸ”—](#(part._.Dictionaries_with_.More_.Complex_.Values)
    "Link to here")
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.3Â å…·æœ‰æ›´å¤æ‚å€¼çš„å­—å…¸[ğŸ”—](#(part._.Dictionaries_with_.More_.Complex_.Values) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Do Now!
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A track-and-field tournament needs to manage the names of the players on the
    individual teams that will be competing. For example, â€œTeam Redâ€ has â€œShaomingâ€
    and â€œLijinâ€, â€œTeam Greenâ€ contains â€œObiâ€ and â€Chinaraâ€, and â€œTeam Blueâ€ has â€œMateoâ€
    and â€œSophiaâ€. Come up with a way to organize the data that will allow the organizers
    to easily access the names of the players on each team, keeping in mind that there
    could be many more teams than just the three listed here.
  id: totrans-53
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç”°å¾„é”¦æ ‡èµ›éœ€è¦ç®¡ç†å°†è¦å‚åŠ æ¯”èµ›çš„å„ä¸ªé˜Ÿä¼çš„è¿åŠ¨å‘˜åå•ã€‚ä¾‹å¦‚ï¼Œâ€œçº¢é˜Ÿâ€æœ‰â€œShaomingâ€å’Œâ€œLijinâ€ï¼Œâ€œç»¿é˜Ÿâ€åŒ…å«â€œObiâ€å’Œâ€œChinaraâ€ï¼Œè€Œâ€œè“é˜Ÿâ€æœ‰â€œMateoâ€å’Œâ€œSophiaâ€ã€‚æƒ³å‡ºä¸€ä¸ªç»„ç»‡æ•°æ®çš„æ–¹æ³•ï¼Œä½¿å¾—ç»„ç»‡è€…å¯ä»¥è½»æ¾è®¿é—®æ¯ä¸ªé˜Ÿä¼çš„è¿åŠ¨å‘˜åå•ï¼ŒåŒæ—¶è€ƒè™‘åˆ°å¯èƒ½æ¯”è¿™é‡Œåˆ—å‡ºçš„ä¸‰ä¸ªé˜Ÿä¼è¿˜è¦å¤šã€‚
- en: 'This feels like a dictionary situation, in that we have a meaningful key (the
    team name) with which we want to access values (the names of the players). However,
    we have already said that dictionaries allow only one value per key. Consider
    the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™çœ‹èµ·æ¥åƒæ˜¯ä¸€ä¸ªå­—å…¸æƒ…å†µï¼Œå› ä¸ºæˆ‘ä»¬æœ‰ä¸€ä¸ªæœ‰æ„ä¹‰çš„é”®ï¼ˆé˜Ÿä¼åç§°ï¼‰ï¼Œæˆ‘ä»¬æƒ³è¦é€šè¿‡å®ƒæ¥è®¿é—®å€¼ï¼ˆè¿åŠ¨å‘˜çš„å§“åï¼‰ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬ä¹‹å‰å·²ç»è¯´è¿‡ï¼Œå­—å…¸åªå…è®¸æ¯ä¸ªé”®ä¸€ä¸ªå€¼ã€‚è€ƒè™‘ä»¥ä¸‹ä»£ç ï¼š
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Do Now!
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What would be in the dictionary after running this code? If you arenâ€™t sure,
    try it out!
  id: totrans-58
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿è¡Œæ­¤ä»£ç åå­—å…¸ä¸­ä¼šæœ‰ä»€ä¹ˆå†…å®¹ï¼Ÿå¦‚æœä½ ä¸ç¡®å®šï¼Œå¯ä»¥è¯•ä¸€è¯•ï¼
- en: 'How do we store multiple player names under the same key? The insight here
    is that the collection of players, not an individual player, is what we want to
    associate with the team name. We should therefore store a list of players under
    each key, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•å°†å¤šä¸ªç©å®¶åç§°å­˜å‚¨åœ¨åŒä¸€ä¸ªé”®ä¸‹ï¼Ÿè¿™é‡Œçš„è§è§£æ˜¯ï¼Œæˆ‘ä»¬æƒ³è¦ä¸é˜Ÿåå…³è”çš„æ˜¯ç©å®¶é›†åˆï¼Œè€Œä¸æ˜¯å•ä¸ªç©å®¶ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åº”è¯¥åœ¨æ¯ä¸ªé”®ä¸‹å­˜å‚¨ç©å®¶åˆ—è¡¨ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The values in a dictionary arenâ€™t limited to being basic values. They can be
    arbitrarily complex, including lists, tables, or even other dictionaries (and
    more!). There is still only one value per key, which is the requirement of a dictionary.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: å­—å…¸ä¸­çš„å€¼ä¸ä»…é™äºåŸºæœ¬å€¼ã€‚å®ƒä»¬å¯ä»¥æ˜¯ä»»æ„å¤æ‚çš„ï¼ŒåŒ…æ‹¬åˆ—è¡¨ã€è¡¨æ ¼ï¼Œç”šè‡³æ˜¯å…¶ä»–å­—å…¸ï¼ˆç­‰ç­‰ï¼ï¼‰ï¼æ¯ä¸ªé”®ä»ç„¶åªæœ‰ä¸€ä¸ªå€¼ï¼Œè¿™æ˜¯å­—å…¸çš„è¦æ±‚ã€‚
- en: 9.2.4Â Dictionaries versus Dataclasses[ğŸ”—](#(part._.Dictionaries_versus_.Dataclasses)
    "Link to here")
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.4 å­—å…¸ä¸æ•°æ®ç±»[ğŸ”—](#(part._.Dictionaries_versus_.Dataclasses) "é“¾æ¥è‡³æ­¤")
- en: 'Previously, we learned about dataclasses as a way to create compound data in
    Python. Here again is the `ToDoItem` dataclass that we introduced earlier, as
    well as an example datum for that class:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹‹å‰ï¼Œæˆ‘ä»¬å­¦ä¹ äº†ä½¿ç”¨æ•°æ®ç±»ï¼ˆdataclassesï¼‰åœ¨ Python ä¸­åˆ›å»ºå¤åˆæ•°æ®çš„æ–¹æ³•ã€‚è¿™é‡Œå†æ¬¡ä»‹ç»æˆ‘ä»¬ä¹‹å‰å¼•å…¥çš„ `ToDoItem` æ•°æ®ç±»ï¼Œä»¥åŠè¯¥ç±»çš„ç¤ºä¾‹æ•°æ®ï¼š
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'One could view the field names in the dataclass as akin to keys in a dictionary.
    If we did so, we could also capture the `milk` datum via a dictionary as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: å¯ä»¥å°†æ•°æ®ç±»ä¸­çš„å­—æ®µåè§†ä¸ºç±»ä¼¼äºå­—å…¸ä¸­çš„é”®ã€‚å¦‚æœæˆ‘ä»¬è¿™æ ·åšï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼é€šè¿‡å­—å…¸æ•è· `milk` æ•°æ®ï¼š
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Do Now!
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a dictionary to capture the compound datum
  id: totrans-69
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åˆ›å»ºä¸€ä¸ªå­—å…¸æ¥æ•è·å¤åˆæ•°æ®
- en: ''
  id: totrans-70
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-71
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Do Now!
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a to-do list named `myTD_D` that contains a list of dictionaries, rather
    than a list of dataclasses.
  id: totrans-74
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åˆ›å»ºä¸€ä¸ªåä¸º `myTD_D` çš„å¾…åŠäº‹é¡¹åˆ—è¡¨ï¼Œå…¶ä¸­åŒ…å«å­—å…¸åˆ—è¡¨ï¼Œè€Œä¸æ˜¯æ•°æ®ç±»åˆ—è¡¨ã€‚
- en: 'Putting these two approaches side-by-side, hereâ€™s the contrast:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: å°†è¿™ä¸¤ç§æ–¹æ³•å¹¶æ’æ”¾ç½®ï¼Œä»¥ä¸‹æ˜¯å¯¹æ¯”ï¼š
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Do Now!
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you see as the benefits and drawbacks of each of dataclasses and dictionaries
    to represent compound data?
  id: totrans-79
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ è®¤ä¸ºä½¿ç”¨æ•°æ®ç±»å’Œå­—å…¸æ¥è¡¨ç¤ºå¤åˆæ•°æ®å„æœ‰ä»€ä¹ˆä¼˜ç¼ºç‚¹ï¼Ÿ
- en: Dataclasses have a fixed number of fields, while directories allow arbitrary
    numbers of keys. Dataclass fields can be annotated with types (which most languages
    will check when you make new data); dictionaries can use fixed types for each
    of keys and values, though this gets restrictive when using dictionaries to capture
    dataclasses with fields of different types. Dataclasses give you a function name
    for creating new data, whereas with dictionaries youâ€™d have to create such a function
    on your own.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: æ•°æ®ç±»æœ‰å›ºå®šæ•°é‡çš„å­—æ®µï¼Œè€Œç›®å½•å…è®¸ä»»æ„æ•°é‡çš„é”®ã€‚æ•°æ®ç±»å­—æ®µå¯ä»¥ç”¨ç±»å‹æ³¨è§£ï¼ˆå¤§å¤šæ•°è¯­è¨€åœ¨åˆ›å»ºæ–°æ•°æ®æ—¶ä¼šæ£€æŸ¥è¿™äº›ç±»å‹ï¼‰ï¼›å­—å…¸å¯ä»¥ä¸ºæ¯ä¸ªé”®å’Œå€¼ä½¿ç”¨å›ºå®šç±»å‹ï¼Œå°½ç®¡å½“ä½¿ç”¨å­—å…¸æ•è·å…·æœ‰ä¸åŒç±»å‹å­—æ®µçš„å­—å…¸æ—¶ï¼Œè¿™ä¼šå˜å¾—é™åˆ¶æ€§ã€‚æ•°æ®ç±»ä¸ºä½ æä¾›äº†ä¸€ä¸ªåˆ›å»ºæ–°æ•°æ®çš„å‡½æ•°åï¼Œè€Œä½¿ç”¨å­—å…¸æ—¶ï¼Œä½ å¿…é¡»è‡ªå·±åˆ›å»ºè¿™æ ·çš„å‡½æ•°ã€‚
- en: 'Overall, dataclasses come with more linguistic support for error checking:
    you canâ€™t supply data for the wrong number of fields or field values of the wrong
    type. Dictionaries are more flexible: you can support optional fields more easily,
    including adding new fields/keys as a program runs. Each of these makes more sense
    in some programming situations.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: æ€»ä½“è€Œè¨€ï¼Œæ•°æ®ç±»åœ¨é”™è¯¯æ£€æŸ¥æ–¹é¢æä¾›äº†æ›´å¤šçš„è¯­è¨€æ”¯æŒï¼šä½ ä¸èƒ½ä¸ºé”™è¯¯æ•°é‡çš„å­—æ®µæˆ–å­—æ®µå€¼æä¾›æ•°æ®ã€‚å­—å…¸æ›´çµæ´»ï¼šä½ å¯ä»¥æ›´å®¹æ˜“åœ°æ”¯æŒå¯é€‰å­—æ®µï¼ŒåŒ…æ‹¬åœ¨ç¨‹åºè¿è¡Œæ—¶æ·»åŠ æ–°å­—æ®µ/é”®ã€‚è¿™äº›åœ¨æŸç§ç¼–ç¨‹æƒ…å†µä¸‹éƒ½æ›´æœ‰æ„ä¹‰ã€‚
- en: Do Now!
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function `ToDoItem_D` that takes a description, due date, and list of
    tags and returns a dictionary with keys for each field of a to-do item.
  id: totrans-84
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ä¸€ä¸ªå‡½æ•° `ToDoItem_D`ï¼Œå®ƒæ¥å—ä¸€ä¸ªæè¿°ã€æˆªæ­¢æ—¥æœŸå’Œæ ‡ç­¾åˆ—è¡¨ï¼Œå¹¶è¿”å›ä¸€ä¸ªåŒ…å«å¾…åŠäº‹é¡¹æ¯ä¸ªå­—æ®µé”®çš„å­—å…¸ã€‚
- en: Summary[ğŸ”—](#(part._.Summary) "Link to here")
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: æ‘˜è¦[ğŸ”—](#(part._.Summary) "é“¾æ¥è‡³æ­¤")
- en: 'Python programmers tend to make substantial use of dictionaries. In this chapter,
    weâ€™ve seen dictionaries used in two different settings:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Python ç¨‹åºå‘˜å€¾å‘äºå¤§é‡ä½¿ç”¨å­—å…¸ã€‚åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†å­—å…¸åœ¨ä¸¤ç§ä¸åŒç¯å¢ƒä¸­çš„åº”ç”¨ï¼š
- en: one in which the keys uniquely identify different entities or individuals among
    a larger set; the values represent some consistent type of information about each
    individual. The dictionary overall captures information about a large population
    of individuals, each with their own key.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å…¶ä¸­é”®å”¯ä¸€æ ‡è¯†æ›´å¤§é›†åˆä¸­çš„ä¸åŒå®ä½“æˆ–ä¸ªäººï¼›å€¼ä»£è¡¨å…³äºæ¯ä¸ªä¸ªä½“çš„æŸç§ä¸€è‡´ç±»å‹çš„ä¿¡æ¯ã€‚è¯¥å­—å…¸æ€»ä½“ä¸Šæ•è·äº†å¤§é‡ä¸ªäººçš„ä¿¡æ¯ï¼Œæ¯ä¸ªä¸ªä½“éƒ½æœ‰è‡ªå·±çš„é”®ã€‚
- en: one in which the keys name fields of compound data; the values associated with
    each field can have different types from the values for other fields. This setting
    corresponds to the use of dataclasses, in which a dictionary captures information
    about one individual; some other structure (such as a list or another dictionary)
    would be needed to hold the dictionaries for each individual.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å…¶ä¸­é”®å‘½åäº†å¤åˆæ•°æ®å­—æ®µï¼›ä¸æ¯ä¸ªå­—æ®µç›¸å…³è”çš„å€¼å¯ä»¥ä¸å…¶ä»–å­—æ®µçš„å€¼å…·æœ‰ä¸åŒçš„ç±»å‹ã€‚è¿™ç§è®¾ç½®å¯¹åº”äºæ•°æ®ç±»çš„ä½¿ç”¨ï¼Œå…¶ä¸­å­—å…¸æ•è·æœ‰å…³ä¸€ä¸ªäººçš„ä¿¡æ¯ï¼›éœ€è¦å…¶ä»–ç»“æ„ï¼ˆå¦‚åˆ—è¡¨æˆ–å¦ä¸€ä¸ªå­—å…¸ï¼‰æ¥ä¿å­˜æ¯ä¸ªä¸ªäººçš„å­—å…¸ã€‚
- en: As a general rule, it is better to use dataclasses for the second setting when
    you have a fixed set of fields. The use of dictionaries for dataclasses is somewhat
    associated with programming practices in the Python community (less so in other
    languages). The first setting, however, is a common use of dictionaries in nearly
    all languages, especially since dictionaries are usually built to provide fast
    access to the data associated with a specific key.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºä¸€èˆ¬è§„åˆ™ï¼Œå½“ä½ æœ‰ä¸€ç»„å›ºå®šçš„å­—æ®µæ—¶ï¼Œæœ€å¥½ä½¿ç”¨æ•°æ®ç±»ã€‚åœ¨Pythonç¤¾åŒºä¸­ï¼Œå­—å…¸çš„ä½¿ç”¨ä¸æ•°æ®ç±»çš„ä½¿ç”¨æœ‰äº›å…³è”ï¼ˆåœ¨å…¶ä»–è¯­è¨€ä¸­åˆ™ä¸é‚£ä¹ˆæ˜æ˜¾ï¼‰ã€‚ç„¶è€Œï¼Œç¬¬ä¸€ä¸ªè®¾ç½®æ˜¯å­—å…¸åœ¨å‡ ä¹æ‰€æœ‰è¯­è¨€ä¸­çš„å¸¸è§ç”¨æ³•ï¼Œå°¤å…¶æ˜¯å› ä¸ºå­—å…¸é€šå¸¸è¢«æ„å»ºä¸ºæä¾›å¯¹ç‰¹å®šé”®ç›¸å…³æ•°æ®çš„å¿«é€Ÿè®¿é—®ã€‚
- en: 9.2.1Â Creating and Using a Dictionary[ğŸ”—](#(part._.Creating_and_.Using_a_.Dictionary)
    "Link to here")
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1 åˆ›å»ºå’Œä½¿ç”¨å­—å…¸[ğŸ”—](#(part._.Creating_and_.Using_a_.Dictionary) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'A dictionary maps unique values (called keys) to corresponding pieces of data
    for each key (called values). Here is our flight example written instead as a
    dictionary instead of a list:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: å­—å…¸å°†å”¯ä¸€çš„å€¼ï¼ˆç§°ä¸ºé”®ï¼‰æ˜ å°„åˆ°æ¯ä¸ªé”®å¯¹åº”çš„æ•°æ®ç‰‡æ®µï¼ˆç§°ä¸ºå€¼ï¼‰ã€‚ä»¥ä¸‹æ˜¯æˆ‘ä»¬å°†é£è¡Œç¤ºä¾‹æ”¹å†™ä¸ºå­—å…¸è€Œä¸æ˜¯åˆ—è¡¨çš„å½¢å¼ï¼š
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The general form of a dictionary is:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: å­—å…¸çš„ä¸€èˆ¬å½¢å¼æ˜¯ï¼š
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Dictionaries are designed to enable easy lookup of values give a key. To get
    the
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: å­—å…¸è¢«è®¾è®¡æˆèƒ½å¤Ÿæ ¹æ®é”®è½»æ¾æŸ¥æ‰¾å€¼ã€‚ä¸ºäº†è·å–
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'associated with key `''CSA-145''`, we can write simply:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸é”® `'CSA-145'` ç›¸å…³ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•åœ°å†™ï¼š
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To get the number of seats on flight `''CSA-145''`, we can simply write:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: è¦è·å– `'CSA-145'` é£è¡Œçš„åº§ä½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•åœ°å†™ï¼š
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In other words, the dictionary data structure removes the need to traverse
    a list to find the `Flight` with a specific key. The dictionary lookup operation
    does that work for us. Actually, dictionaries are even more nuanced: depending
    on how they are designed, dictionaries can retrieve the value for a key without
    traversing all the values (or even any other value). In general, you can assume
    that dictionary-based lookup is significantly faster than a list-based one. How
    this works is a more advanced topic; some of this content is explained in [SECREF].'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: æ¢å¥è¯è¯´ï¼Œå­—å…¸æ•°æ®ç»“æ„æ¶ˆé™¤äº†éå†åˆ—è¡¨ä»¥æ‰¾åˆ°å…·æœ‰ç‰¹å®šé”®çš„ `Flight` çš„éœ€è¦ã€‚å­—å…¸æŸ¥æ‰¾æ“ä½œä¸ºæˆ‘ä»¬å®Œæˆäº†è¿™é¡¹å·¥ä½œã€‚å®é™…ä¸Šï¼Œå­—å…¸ç”šè‡³æ›´åŠ ç²¾ç»†ï¼šæ ¹æ®å®ƒä»¬çš„è®¾è®¡æ–¹å¼ï¼Œå­—å…¸å¯ä»¥åœ¨ä¸éå†æ‰€æœ‰å€¼ï¼ˆç”šè‡³ä»»ä½•å…¶ä»–å€¼ï¼‰çš„æƒ…å†µä¸‹æ£€ç´¢é”®çš„å€¼ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œä½ å¯ä»¥å‡è®¾åŸºäºå­—å…¸çš„æŸ¥æ‰¾æ¯”åŸºäºåˆ—è¡¨çš„æŸ¥æ‰¾è¦å¿«å¾—å¤šã€‚è¿™æ˜¯å¦‚ä½•å·¥ä½œçš„æ˜¯ä¸€ä¸ªæ›´é«˜çº§çš„è¯é¢˜ï¼›å…¶ä¸­ä¸€äº›å†…å®¹åœ¨
    [SECREF] ä¸­æœ‰è§£é‡Šã€‚
- en: 'One limitation of dictionaries is that they allow only one value per key. Letâ€™s
    consider a different example, this time one that uses rooms in a building as keys
    and occupants as values:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: å­—å…¸çš„ä¸€ä¸ªå±€é™æ€§æ˜¯å®ƒä»¬åªå…è®¸æ¯ä¸ªé”®ä¸€ä¸ªå€¼ã€‚è®©æˆ‘ä»¬è€ƒè™‘ä¸€ä¸ªä¸åŒçš„ä¾‹å­ï¼Œè¿™æ¬¡æ˜¯ä½¿ç”¨å»ºç­‘ä¸­çš„æˆ¿é—´ä½œä¸ºé”®ï¼Œå±…ä½è€…ä½œä¸ºå€¼ï¼š
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What if someone new moves into office 412? In Python, we can the value for
    that key as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæœ‰äººæ¬è¿›äº†åŠå…¬å®¤412ï¼Œåœ¨Pythonä¸­ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·è®¾ç½®è¯¥é”®çš„å€¼ï¼š
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, any use of `office_dict[412]` will evaluate to `'Zeynep'` instead of `'Marisol'`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œä»»ä½•å¯¹ `office_dict[412]` çš„ä½¿ç”¨éƒ½å°†è¯„ä¼°ä¸º `'Zeynep'` è€Œä¸æ˜¯ `'Marisol'`ã€‚
- en: 9.2.2Â Searching Through the Values in a Dictionary[ğŸ”—](#(part._.Searching_.Through_the_.Values_in_a_.Dictionary)
    "Link to here")
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.2 åœ¨å­—å…¸ä¸­æœç´¢å€¼[ğŸ”—](#(part._.Searching_.Through_the_.Values_in_a_.Dictionary) "é“¾æ¥åˆ°æ­¤å¤„")
- en: What if we wanted to find all of the flights with more than 100 seats? For this,
    we have to search through all of the key-value pairs and check their balances.
    This again sounds like we need a for-loop. What does that look like on a dictionary
    though?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æƒ³æ‰¾åˆ°æ‰€æœ‰åº§ä½æ•°è¶…è¿‡100çš„èˆªç­ï¼Œæˆ‘ä»¬å¿…é¡»éå†æ‰€æœ‰çš„é”®å€¼å¯¹å¹¶æ£€æŸ¥å®ƒä»¬çš„ä½™é¢ã€‚è¿™å¬èµ·æ¥åˆåƒæˆ‘ä»¬éœ€è¦ä¸€ä¸ªforå¾ªç¯ã€‚ä½†åœ¨å­—å…¸ä¸Šè¿™çœ‹èµ·æ¥æ˜¯ä»€ä¹ˆæ ·å­å‘¢ï¼Ÿ
- en: 'Turns out, it looks much like writing a for loop on a list (at least in Python).
    Hereâ€™s a program that creates a list of the flights with more than 100 seats:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æœè¡¨æ˜ï¼Œå®ƒçœ‹èµ·æ¥å°±åƒåœ¨åˆ—è¡¨ä¸Šå†™ä¸€ä¸ªforå¾ªç¯ï¼ˆè‡³å°‘åœ¨Pythonä¸­æ˜¯è¿™æ ·ï¼‰ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªåˆ›å»ºåº§ä½æ•°è¶…è¿‡100çš„èˆªç­åˆ—è¡¨çš„ç¨‹åºï¼š
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, the for-loop iterates over the keys. Within the loop, we use each key
    to retrieve its corresponding `Flight`, perform the balance check on the `Flight`,
    then put the `Flight` in our running list if it meets our criterion.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œforå¾ªç¯éå†é”®ã€‚åœ¨å¾ªç¯å†…éƒ¨ï¼Œæˆ‘ä»¬ä½¿ç”¨æ¯ä¸ªé”®æ¥æ£€ç´¢å…¶å¯¹åº”çš„`Flight`ï¼Œå¯¹`Flight`è¿›è¡Œå¹³è¡¡æ£€æŸ¥ï¼Œç„¶åå¦‚æœå®ƒç¬¦åˆæˆ‘ä»¬çš„æ ‡å‡†ï¼Œå°±å°†`Flight`æ”¾å…¥æˆ‘ä»¬çš„è¿è¡Œåˆ—è¡¨ä¸­ã€‚
- en: Exercise
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Create a dictionary that maps names of classrooms or meeting rooms to the numbers
    of seats that they have. Write expressions to:'
  id: totrans-114
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åˆ›å»ºä¸€ä¸ªå°†æ•™å®¤æˆ–ä¼šè®®å®¤çš„åç§°æ˜ å°„åˆ°å®ƒä»¬æ‹¥æœ‰çš„åº§ä½æ•°çš„å­—å…¸ã€‚ç¼–å†™è¡¨è¾¾å¼ï¼š
- en: ''
  id: totrans-115
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Look up how many seats are in a specific room
  id: totrans-116
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: æŸ¥è¯¢ç‰¹å®šæˆ¿é—´æœ‰å¤šå°‘åº§ä½
- en: ''
  id: totrans-117
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-118
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Change the capacity of a specific room to have 10 more seats than it did initially
  id: totrans-119
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: å°†ç‰¹å®šæˆ¿é—´çš„å®¹é‡æ”¹ä¸ºæ¯”æœ€åˆå¤š10ä¸ªåº§ä½
- en: ''
  id: totrans-120
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-121
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Find all rooms that can seat at least 50 students
  id: totrans-122
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: æ‰¾å‡ºå¯ä»¥å®¹çº³è‡³å°‘50åå­¦ç”Ÿçš„æ‰€æœ‰æˆ¿é—´
- en: 9.2.3Â Dictionaries with More Complex Values[ğŸ”—](#(part._.Dictionaries_with_.More_.Complex_.Values)
    "Link to here")
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.3Â å…·æœ‰æ›´å¤æ‚å€¼çš„å­—å…¸[ğŸ”—](#(part._.Dictionaries_with_.More_.Complex_.Values) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Do Now!
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A track-and-field tournament needs to manage the names of the players on the
    individual teams that will be competing. For example, â€œTeam Redâ€ has â€œShaomingâ€
    and â€œLijinâ€, â€œTeam Greenâ€ contains â€œObiâ€ and â€Chinaraâ€, and â€œTeam Blueâ€ has â€œMateoâ€
    and â€œSophiaâ€. Come up with a way to organize the data that will allow the organizers
    to easily access the names of the players on each team, keeping in mind that there
    could be many more teams than just the three listed here.
  id: totrans-126
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç”°å¾„é”¦æ ‡èµ›éœ€è¦ç®¡ç†å°†è¦å‚èµ›çš„å„ä¸ªé˜Ÿä¼çš„ç©å®¶åç§°ã€‚ä¾‹å¦‚ï¼Œâ€œçº¢é˜Ÿâ€æœ‰â€œShaomingâ€å’Œâ€œLijinâ€ï¼Œâ€œç»¿é˜Ÿâ€åŒ…å«â€œObiâ€å’Œâ€œChinaraâ€ï¼Œâ€œè“é˜Ÿâ€æœ‰â€œMateoâ€å’Œâ€œSophiaâ€ã€‚æƒ³å‡ºä¸€ä¸ªç»„ç»‡æ•°æ®çš„æ–¹æ³•ï¼Œä½¿å¾—ç»„ç»‡è€…å¯ä»¥è½»æ¾è®¿é—®æ¯ä¸ªé˜Ÿä¼çš„ç©å®¶åç§°ï¼ŒåŒæ—¶è€ƒè™‘åˆ°å¯èƒ½æ¯”è¿™é‡Œåˆ—å‡ºçš„ä¸‰ä¸ªé˜Ÿä¼è¿˜è¦å¤šå¾ˆå¤šé˜Ÿä¼ã€‚
- en: 'This feels like a dictionary situation, in that we have a meaningful key (the
    team name) with which we want to access values (the names of the players). However,
    we have already said that dictionaries allow only one value per key. Consider
    the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ„Ÿè§‰åƒæ˜¯ä¸€ä¸ªå­—å…¸æƒ…å†µï¼Œå› ä¸ºæˆ‘ä»¬æœ‰ä¸€ä¸ªæœ‰æ„ä¹‰çš„é”®ï¼ˆå›¢é˜Ÿåç§°ï¼‰ï¼Œæˆ‘ä»¬æƒ³è¦é€šè¿‡å®ƒè®¿é—®å€¼ï¼ˆç©å®¶çš„åç§°ï¼‰ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬ä¹‹å‰å·²ç»è¯´è¿‡ï¼Œå­—å…¸æ¯ä¸ªé”®åªèƒ½æœ‰ä¸€ä¸ªå€¼ã€‚è€ƒè™‘ä»¥ä¸‹ä»£ç ï¼š
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Do Now!
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What would be in the dictionary after running this code? If you arenâ€™t sure,
    try it out!
  id: totrans-131
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿è¡Œæ­¤ä»£ç åå­—å…¸ä¸­ä¼šæœ‰ä»€ä¹ˆï¼Ÿå¦‚æœä½ ä¸ç¡®å®šï¼Œè¯•ç€è¯•ä¸€ä¸‹ï¼
- en: 'How do we store multiple player names under the same key? The insight here
    is that the collection of players, not an individual player, is what we want to
    associate with the team name. We should therefore store a list of players under
    each key, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•å°†å¤šä¸ªç©å®¶åç§°å­˜å‚¨åœ¨åŒä¸€ä¸ªé”®ä¸‹ï¼Ÿè¿™é‡Œçš„æ´å¯ŸåŠ›åœ¨äºï¼Œæˆ‘ä»¬æƒ³è¦ä¸å›¢é˜Ÿåç§°å…³è”çš„æ˜¯ç©å®¶é›†åˆï¼Œè€Œä¸æ˜¯å•ä¸ªç©å®¶ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åº”è¯¥åœ¨æ¯ä¸ªé”®ä¸‹å­˜å‚¨ç©å®¶åˆ—è¡¨ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The values in a dictionary arenâ€™t limited to being basic values. They can be
    arbitrarily complex, including lists, tables, or even other dictionaries (and
    more!). There is still only one value per key, which is the requirement of a dictionary.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: å­—å…¸ä¸­çš„å€¼ä¸ä»…é™äºåŸºæœ¬å€¼ã€‚å®ƒä»¬å¯ä»¥æ˜¯ä»»æ„å¤æ‚çš„ï¼ŒåŒ…æ‹¬åˆ—è¡¨ã€è¡¨æ ¼ï¼Œç”šè‡³æ˜¯å…¶ä»–å­—å…¸ï¼ˆç­‰ç­‰ï¼ï¼‰ï¼æ¯ä¸ªé”®ä»ç„¶åªæœ‰ä¸€ä¸ªå€¼ï¼Œè¿™æ˜¯å­—å…¸çš„è¦æ±‚ã€‚
- en: 9.2.4Â Dictionaries versus Dataclasses[ğŸ”—](#(part._.Dictionaries_versus_.Dataclasses)
    "Link to here")
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.4Â å­—å…¸ä¸dataclassesçš„æ¯”è¾ƒ[ğŸ”—](#(part._.Dictionaries_versus_.Dataclasses) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Previously, we learned about dataclasses as a way to create compound data in
    Python. Here again is the `ToDoItem` dataclass that we introduced earlier, as
    well as an example datum for that class:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹‹å‰ï¼Œæˆ‘ä»¬å­¦ä¹ äº†dataclassä½œä¸ºåœ¨Pythonä¸­åˆ›å»ºå¤åˆæ•°æ®çš„ä¸€ç§æ–¹æ³•ã€‚è¿™é‡Œå†æ¬¡ä»‹ç»æˆ‘ä»¬ä¹‹å‰å¼•å…¥çš„`ToDoItem` dataclassä»¥åŠè¯¥ç±»çš„ç¤ºä¾‹æ•°æ®ï¼š
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'One could view the field names in the dataclass as akin to keys in a dictionary.
    If we did so, we could also capture the `milk` datum via a dictionary as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: å¯ä»¥å°†dataclassä¸­çš„å­—æ®µåç§°è§†ä¸ºç±»ä¼¼äºå­—å…¸ä¸­çš„é”®ã€‚å¦‚æœæˆ‘ä»¬è¿™æ ·åšï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼é€šè¿‡å­—å…¸æ•è·`milk`æ•°æ®ï¼š
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Do Now!
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a dictionary to capture the compound datum
  id: totrans-142
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åˆ›å»ºä¸€ä¸ªå­—å…¸æ¥æ•è·å¤åˆæ•°æ®
- en: ''
  id: totrans-143
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-144
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Do Now!
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a to-do list named `myTD_D` that contains a list of dictionaries, rather
    than a list of dataclasses.
  id: totrans-147
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åˆ›å»ºä¸€ä¸ªåä¸º`myTD_D`çš„å¾…åŠäº‹é¡¹åˆ—è¡¨ï¼Œå…¶ä¸­åŒ…å«å­—å…¸åˆ—è¡¨ï¼Œè€Œä¸æ˜¯dataclassesåˆ—è¡¨ã€‚
- en: 'Putting these two approaches side-by-side, hereâ€™s the contrast:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: å°†è¿™ä¸¤ç§æ–¹æ³•å¹¶æ’æ”¾ç½®ï¼Œä»¥ä¸‹æ˜¯å®ƒä»¬çš„å¯¹æ¯”ï¼š
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Do Now!
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you see as the benefits and drawbacks of each of dataclasses and dictionaries
    to represent compound data?
  id: totrans-152
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ è®¤ä¸ºä½¿ç”¨dataclasseså’Œå­—å…¸æ¥è¡¨ç¤ºå¤åˆæ•°æ®æœ‰å“ªäº›ä¼˜ç‚¹å’Œç¼ºç‚¹ï¼Ÿ
- en: Dataclasses have a fixed number of fields, while directories allow arbitrary
    numbers of keys. Dataclass fields can be annotated with types (which most languages
    will check when you make new data); dictionaries can use fixed types for each
    of keys and values, though this gets restrictive when using dictionaries to capture
    dataclasses with fields of different types. Dataclasses give you a function name
    for creating new data, whereas with dictionaries youâ€™d have to create such a function
    on your own.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: æ•°æ®ç±»å…·æœ‰å›ºå®šæ•°é‡çš„å­—æ®µï¼Œè€Œç›®å½•å…è®¸ä»»æ„æ•°é‡çš„é”®ã€‚æ•°æ®ç±»çš„å­—æ®µå¯ä»¥ç”¨ç±»å‹è¿›è¡Œæ³¨è§£ï¼ˆå¤§å¤šæ•°è¯­è¨€åœ¨åˆ›å»ºæ–°æ•°æ®æ—¶ä¼šæ£€æŸ¥ç±»å‹ï¼‰ï¼›å­—å…¸å¯ä»¥ä¸ºæ¯ä¸ªé”®å’Œå€¼ä½¿ç”¨å›ºå®šç±»å‹ï¼Œä½†å½“ä½¿ç”¨å­—å…¸æ•è·å…·æœ‰ä¸åŒç±»å‹å­—æ®µçš„æ•°æ®ç±»æ—¶ï¼Œè¿™ä¼šå˜å¾—é™åˆ¶æ€§ã€‚æ•°æ®ç±»ä¸ºä½ æä¾›äº†ä¸€ä¸ªåˆ›å»ºæ–°æ•°æ®çš„å‡½æ•°åï¼Œè€Œä½¿ç”¨å­—å…¸æ—¶ï¼Œä½ å¿…é¡»è‡ªå·±åˆ›å»ºè¿™æ ·çš„å‡½æ•°ã€‚
- en: 'Overall, dataclasses come with more linguistic support for error checking:
    you canâ€™t supply data for the wrong number of fields or field values of the wrong
    type. Dictionaries are more flexible: you can support optional fields more easily,
    including adding new fields/keys as a program runs. Each of these makes more sense
    in some programming situations.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: æ€»ä½“è€Œè¨€ï¼Œæ•°æ®ç±»æä¾›äº†æ›´å¤šçš„è¯­è¨€æ”¯æŒä»¥è¿›è¡Œé”™è¯¯æ£€æŸ¥ï¼šä½ ä¸èƒ½ä¸ºé”™è¯¯æ•°é‡çš„å­—æ®µæˆ–å­—æ®µå€¼æä¾›æ•°æ®ã€‚å­—å…¸æ›´çµæ´»ï¼šä½ å¯ä»¥æ›´å®¹æ˜“åœ°æ”¯æŒå¯é€‰å­—æ®µï¼ŒåŒ…æ‹¬åœ¨ç¨‹åºè¿è¡Œæ—¶æ·»åŠ æ–°å­—æ®µ/é”®ã€‚è¿™äº›åœ¨æŸç§ç¼–ç¨‹åœºæ™¯ä¸­æ›´æœ‰æ„ä¹‰ã€‚
- en: Do Now!
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function `ToDoItem_D` that takes a description, due date, and list of
    tags and returns a dictionary with keys for each field of a to-do item.
  id: totrans-157
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ä¸€ä¸ªå‡½æ•°`ToDoItem_D`ï¼Œå®ƒæ¥å—ä¸€ä¸ªæè¿°ã€æˆªæ­¢æ—¥æœŸå’Œæ ‡ç­¾åˆ—è¡¨ï¼Œå¹¶è¿”å›ä¸€ä¸ªåŒ…å«å¾…åŠäº‹é¡¹æ¯ä¸ªå­—æ®µé”®çš„å­—å…¸ã€‚
- en: Summary[ğŸ”—](#(part._.Summary) "Link to here")
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: æ‘˜è¦[ğŸ”—](#(part._.Summary) "é“¾æ¥è‡³æ­¤")
- en: 'Python programmers tend to make substantial use of dictionaries. In this chapter,
    weâ€™ve seen dictionaries used in two different settings:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Pythonç¨‹åºå‘˜å€¾å‘äºå¤§é‡ä½¿ç”¨å­—å…¸ã€‚åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†å­—å…¸åœ¨ä¸¤ç§ä¸åŒåœºæ™¯ä¸‹çš„åº”ç”¨ï¼š
- en: one in which the keys uniquely identify different entities or individuals among
    a larger set; the values represent some consistent type of information about each
    individual. The dictionary overall captures information about a large population
    of individuals, each with their own key.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ç§æƒ…å†µæ˜¯é”®å”¯ä¸€æ ‡è¯†æ›´å¤§é›†åˆä¸­çš„ä¸åŒå®ä½“æˆ–ä¸ªäººï¼›å€¼ä»£è¡¨å…³äºæ¯ä¸ªä¸ªä½“çš„æŸç§ä¸€è‡´ç±»å‹çš„ä¿¡æ¯ã€‚å­—å…¸æ•´ä½“ä¸Šæ•æ‰äº†å…³äºå¤§é‡ä¸ªä½“çš„ä¿¡æ¯ï¼Œæ¯ä¸ªä¸ªä½“éƒ½æœ‰è‡ªå·±çš„é”®ã€‚
- en: one in which the keys name fields of compound data; the values associated with
    each field can have different types from the values for other fields. This setting
    corresponds to the use of dataclasses, in which a dictionary captures information
    about one individual; some other structure (such as a list or another dictionary)
    would be needed to hold the dictionaries for each individual.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ç§æƒ…å†µæ˜¯é”®å‘½åå¤åˆæ•°æ®ä¸­çš„å­—æ®µï¼›ä¸æ¯ä¸ªå­—æ®µå…³è”çš„å€¼å¯ä»¥ä¸å…¶ä»–å­—æ®µçš„å€¼å…·æœ‰ä¸åŒçš„ç±»å‹ã€‚è¿™ç§è®¾ç½®å¯¹åº”äºæ•°æ®ç±»çš„ä½¿ç”¨ï¼Œå…¶ä¸­å­—å…¸æ•æ‰äº†å…³äºä¸€ä¸ªä¸ªä½“çš„ä¿¡æ¯ï¼›éœ€è¦å…¶ä»–ç»“æ„ï¼ˆå¦‚åˆ—è¡¨æˆ–å¦ä¸€ä¸ªå­—å…¸ï¼‰æ¥ä¿å­˜æ¯ä¸ªä¸ªä½“çš„å­—å…¸ã€‚
- en: As a general rule, it is better to use dataclasses for the second setting when
    you have a fixed set of fields. The use of dictionaries for dataclasses is somewhat
    associated with programming practices in the Python community (less so in other
    languages). The first setting, however, is a common use of dictionaries in nearly
    all languages, especially since dictionaries are usually built to provide fast
    access to the data associated with a specific key.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºä¸€èˆ¬è§„åˆ™ï¼Œå½“ä½ æœ‰ä¸€ä¸ªå›ºå®šå­—æ®µé›†æ—¶ï¼Œæœ€å¥½ä½¿ç”¨æ•°æ®ç±»ã€‚åœ¨Pythonç¤¾åŒºä¸­ï¼Œå­—å…¸ç”¨äºæ•°æ®ç±»çš„ä½¿ç”¨ä¸ç¼–ç¨‹å®è·µæœ‰å…³ï¼ˆåœ¨å…¶ä»–è¯­è¨€ä¸­åˆ™ä¸é‚£ä¹ˆç›¸å…³ï¼‰ã€‚ç„¶è€Œï¼Œç¬¬ä¸€ç§è®¾ç½®æ˜¯å‡ ä¹æ‰€æœ‰è¯­è¨€ä¸­å­—å…¸çš„å¸¸è§ç”¨æ³•ï¼Œå°¤å…¶æ˜¯åœ¨å­—å…¸é€šå¸¸è¢«æ„å»ºä¸ºæä¾›å¿«é€Ÿè®¿é—®ä¸ç‰¹å®šé”®å…³è”çš„æ•°æ®çš„æƒ…å†µä¸‹ã€‚
- en: Summary[ğŸ”—](#(part._.Summary) "Link to here")
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: æ‘˜è¦[ğŸ”—](#(part._.Summary) "é“¾æ¥è‡³æ­¤")
- en: 'Python programmers tend to make substantial use of dictionaries. In this chapter,
    weâ€™ve seen dictionaries used in two different settings:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Pythonç¨‹åºå‘˜å€¾å‘äºå¤§é‡ä½¿ç”¨å­—å…¸ã€‚åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†å­—å…¸åœ¨ä¸¤ç§ä¸åŒåœºæ™¯ä¸‹çš„åº”ç”¨ï¼š
- en: one in which the keys uniquely identify different entities or individuals among
    a larger set; the values represent some consistent type of information about each
    individual. The dictionary overall captures information about a large population
    of individuals, each with their own key.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ç§æƒ…å†µæ˜¯é”®å”¯ä¸€æ ‡è¯†æ›´å¤§é›†åˆä¸­çš„ä¸åŒå®ä½“æˆ–ä¸ªäººï¼›å€¼ä»£è¡¨å…³äºæ¯ä¸ªä¸ªä½“çš„æŸç§ä¸€è‡´ç±»å‹çš„ä¿¡æ¯ã€‚å­—å…¸æ•´ä½“ä¸Šæ•æ‰äº†å…³äºå¤§é‡ä¸ªä½“çš„ä¿¡æ¯ï¼Œæ¯ä¸ªä¸ªä½“éƒ½æœ‰è‡ªå·±çš„é”®ã€‚
- en: one in which the keys name fields of compound data; the values associated with
    each field can have different types from the values for other fields. This setting
    corresponds to the use of dataclasses, in which a dictionary captures information
    about one individual; some other structure (such as a list or another dictionary)
    would be needed to hold the dictionaries for each individual.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å…¶ä¸­é”®å‘½åäº†å¤åˆæ•°æ®å­—æ®µï¼›ä¸æ¯ä¸ªå­—æ®µç›¸å…³è”çš„å€¼å¯ä»¥ä¸å…¶ä»–å­—æ®µçš„å€¼å…·æœ‰ä¸åŒçš„ç±»å‹ã€‚è¿™ç§è®¾ç½®å¯¹åº”äºæ•°æ®ç±»çš„ä½¿ç”¨ï¼Œå…¶ä¸­å­—å…¸æ•è·æœ‰å…³ä¸€ä¸ªä¸ªä½“çš„ä¿¡æ¯ï¼›éœ€è¦å…¶ä»–ç»“æ„ï¼ˆå¦‚åˆ—è¡¨æˆ–å¦ä¸€ä¸ªå­—å…¸ï¼‰æ¥ä¿å­˜æ¯ä¸ªä¸ªä½“çš„å­—å…¸ã€‚
- en: As a general rule, it is better to use dataclasses for the second setting when
    you have a fixed set of fields. The use of dictionaries for dataclasses is somewhat
    associated with programming practices in the Python community (less so in other
    languages). The first setting, however, is a common use of dictionaries in nearly
    all languages, especially since dictionaries are usually built to provide fast
    access to the data associated with a specific key.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºä¸€èˆ¬è§„åˆ™ï¼Œå½“ä½ æœ‰ä¸€ç»„å›ºå®šçš„å­—æ®µæ—¶ï¼Œæœ€å¥½åœ¨ç¬¬äºŒä¸ªè®¾ç½®ä¸­ä½¿ç”¨æ•°æ®ç±»ã€‚åœ¨æ•°æ®ç±»ä¸­ä½¿ç”¨å­—å…¸ä¸ Python ç¤¾åŒºçš„ç¼–ç¨‹å®è·µæœ‰ä¸€å®šçš„å…³è”ï¼ˆåœ¨å…¶ä»–è¯­è¨€ä¸­åˆ™ä¸é‚£ä¹ˆæ˜æ˜¾ï¼‰ã€‚ç„¶è€Œï¼Œç¬¬ä¸€ä¸ªè®¾ç½®æ˜¯å‡ ä¹æ‰€æœ‰è¯­è¨€ä¸­å­—å…¸çš„å¸¸è§ç”¨æ³•ï¼Œå°¤å…¶æ˜¯åœ¨å­—å…¸é€šå¸¸è¢«æ„å»ºä»¥æä¾›å¯¹ä¸ç‰¹å®šé”®ç›¸å…³è”çš„æ•°æ®çš„å¿«é€Ÿè®¿é—®çš„æƒ…å†µä¸‹ã€‚
