- en: 17.4Â Shortest (or Lightest) PathsğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.4 æœ€çŸ­ï¼ˆæˆ–æœ€è½»ï¼‰è·¯å¾„ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/lightest-paths.html](https://dcic-world.org/2025-08-27/lightest-paths.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/lightest-paths.html](https://dcic-world.org/2025-08-27/lightest-paths.html)
- en: '|  |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Imagine planning a trip: itâ€™s natural that you might want to get to your destination
    in the least time, or for the least money, or some other criterion that involves
    minimizing the sum of edge weights. This is known as computing the shortest path.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ³è±¡è§„åˆ’ä¸€æ¬¡æ—…è¡Œï¼šä½ è‡ªç„¶å¸Œæœ›ä»¥æœ€çŸ­çš„æ—¶é—´ã€æœ€å°‘çš„é‡‘é’±æˆ–å…¶ä»–æ¶‰åŠæœ€å°åŒ–è¾¹æƒé‡æ€»å’Œçš„æ ‡å‡†åˆ°è¾¾ç›®çš„åœ°ã€‚è¿™è¢«ç§°ä¸ºè®¡ç®—æœ€çŸ­è·¯å¾„ã€‚
- en: We should immediately clarify an unfortunate terminological confusion. What
    we really want to compute is the lightest pathâ€”<wbr>the one of least weight. Unfortunately,
    computer science terminology has settled on the terminology we use here; just
    be sure to not take it literally.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åº”è¯¥ç«‹å³æ¾„æ¸…ä¸€ä¸ªä¸å¹¸çš„æœ¯è¯­æ··æ·†ã€‚æˆ‘ä»¬çœŸæ­£æƒ³è¦è®¡ç®—çš„æ˜¯æœ€çŸ­è·¯å¾„â€”â€”å³æƒé‡æœ€å°çš„è·¯å¾„ã€‚ä¸å¹¸çš„æ˜¯ï¼Œè®¡ç®—æœºç§‘å­¦æœ¯è¯­å·²ç»å›ºå®šäº†æˆ‘ä»¬åœ¨è¿™é‡Œä½¿ç”¨çš„æœ¯è¯­ï¼›åªéœ€ç¡®ä¿ä¸è¦å­—é¢ç†è§£å³å¯ã€‚
- en: Exercise
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Construct a graph and select a pair of nodes in it such that the shortest path
    from one to the other is not the lightest one, and vice versa.
  id: totrans-7
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ„å»ºä¸€ä¸ªå›¾ï¼Œå¹¶é€‰æ‹©å›¾ä¸­çš„ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œä½¿å¾—ä»ä¸€ä¸ªèŠ‚ç‚¹åˆ°å¦ä¸€ä¸ªèŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸æ˜¯æœ€è½»çš„ï¼Œåä¹‹äº¦ç„¶ã€‚
- en: We have already seen [[Depth- and Breadth-First Traversals](basic-graph-trav.html#%28part._dfs-bfs%29)]
    that breadth-first search constructs shortest paths in unweighted graphs. These
    correspond to lightest paths when there are no weights (or, equivalently, all
    weights are identical and positive). Now we have to generalize this to the case
    where the edges have weights.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»çœ‹åˆ° [[æ·±åº¦ä¼˜å…ˆæœç´¢å’Œå¹¿åº¦ä¼˜å…ˆæœç´¢](basic-graph-trav.html#%28part._dfs-bfs%29)]ï¼Œå¹¿åº¦ä¼˜å…ˆæœç´¢åœ¨æ— æƒå›¾ä¸­æ„å»ºæœ€çŸ­è·¯å¾„ã€‚å½“æ²¡æœ‰æƒé‡ï¼ˆæˆ–ç­‰ä»·åœ°ï¼Œæ‰€æœ‰æƒé‡éƒ½æ˜¯ç›¸åŒä¸”æ­£çš„ï¼‰æ—¶ï¼Œè¿™äº›å¯¹åº”äºæœ€è½»è·¯å¾„ã€‚ç°åœ¨æˆ‘ä»¬å¿…é¡»å°†è¿™ä¸€ç‚¹æ¨å¹¿åˆ°è¾¹æœ‰æƒé‡çš„æƒ…å†µã€‚
- en: We will proceed inductively, gradually defining a function seemingly of this
    type
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†é‡‡ç”¨å½’çº³æ³•ï¼Œé€æ­¥å®šä¹‰ä¸€ä¸ªçœ‹ä¼¼è¿™ç§ç±»å‹çš„å‡½æ•°
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'that reflects the weight of the lightest path from the source node to that
    one. But letâ€™s think about this annotation: since weâ€™re building this up node-by-node,
    initially most nodes have no weight to report; and even at the end, a node that
    is unreachable from the source will have no weight for a lightest (or indeed,
    any) path. Rather than make up a number that pretends to reflect this situation,
    we will instead use an option type:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™åæ˜ äº†ä»æºèŠ‚ç‚¹åˆ°è¯¥èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„çš„æƒé‡ã€‚ä½†è®©æˆ‘ä»¬è€ƒè™‘è¿™ä¸ªæ³¨é‡Šï¼šç”±äºæˆ‘ä»¬æ˜¯é€ä¸ªèŠ‚ç‚¹æ„å»ºçš„ï¼Œæœ€åˆå¤§å¤šæ•°èŠ‚ç‚¹æ²¡æœ‰è¦æŠ¥å‘Šçš„æƒé‡ï¼›ç”šè‡³åœ¨æœ€åï¼Œä¸€ä¸ªæ— æ³•ä»æºèŠ‚ç‚¹åˆ°è¾¾çš„èŠ‚ç‚¹å°†æ²¡æœ‰æœ€çŸ­ï¼ˆæˆ–å®é™…ä¸Šä»»ä½•ï¼‰è·¯å¾„çš„æƒé‡ã€‚è€Œä¸æ˜¯ç¼–é€ ä¸€ä¸ªæ•°å­—æ¥å‡è£…åæ˜ è¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ä¸€ä¸ªé€‰é¡¹ç±»å‹ï¼š
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When there is `some` value it will be the weight; otherwise the weight will
    be `none`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: å½“å­˜åœ¨æŸä¸ªå€¼æ—¶ï¼Œå®ƒå°†æ˜¯æƒé‡ï¼›å¦åˆ™ï¼Œæƒé‡å°†æ˜¯â€œæ— â€ã€‚
- en: Now letâ€™s think about this inductively. What do we know initially? Well, certainly
    that the source node is at a distance of zero from itself (that must be the lightest
    path, because we canâ€™t get any lighter). This gives us a (trivial) set of nodes
    for which we already know the lightest weight. Our goal is to grow this set of
    nodesâ€”<wbr>modestly, by one, on each iterationâ€”<wbr>until we either find the destination,
    or we have no more nodes to add (in which case our desination is not reachable
    from the source).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬å½’çº³åœ°æ€è€ƒä¸€ä¸‹ã€‚æˆ‘ä»¬æœ€åˆçŸ¥é“ä»€ä¹ˆï¼Ÿå¥½å§ï¼Œå½“ç„¶ï¼ŒæºèŠ‚ç‚¹åˆ°è‡ªèº«çš„è·ç¦»æ˜¯é›¶ï¼ˆè¿™å¿…é¡»æ˜¯æœ€çŸ­è·¯å¾„ï¼Œå› ä¸ºæˆ‘ä»¬æ— æ³•æ›´è½»ï¼‰ã€‚è¿™ç»™æˆ‘ä»¬ä¸€ä¸ªï¼ˆå¹³å‡¡çš„ï¼‰èŠ‚ç‚¹é›†åˆï¼Œå¯¹äºè¿™äº›èŠ‚ç‚¹æˆ‘ä»¬å·²ç»çŸ¥é“æœ€çŸ­æƒé‡ã€‚æˆ‘ä»¬çš„ç›®æ ‡æ˜¯æ‰©å±•è¿™ä¸ªèŠ‚ç‚¹é›†åˆâ€”â€”åœ¨æ¯æ¬¡è¿­ä»£ä¸­é€‚åº¦åœ°å¢åŠ ä¸€ä¸ªèŠ‚ç‚¹â€”â€”ç›´åˆ°æˆ‘ä»¬æ‰¾åˆ°ç›®çš„åœ°ï¼Œæˆ–è€…æˆ‘ä»¬æ²¡æœ‰æ›´å¤šçš„èŠ‚ç‚¹å¯ä»¥æ·»åŠ ï¼ˆåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬çš„ç›®çš„åœ°æ— æ³•ä»æºèŠ‚ç‚¹åˆ°è¾¾ï¼‰ã€‚
- en: Inductively, at each step we have the set of all nodes for which we know the
    lightest path (initially this is just the source node, but it does mean this set
    is never empty, which will matter in what we say next). Now consider all the edges
    adjacent to this set of nodes that lead to nodes for which we donâ€™t already know
    the lightest path. Choose a node, \(q\), that minimizes the total weight of the
    path to it. We claim that this will in fact be the lightest path to that node.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: å½’çº³åœ°ï¼Œåœ¨æ¯ä¸€æ­¥ä¸­ï¼Œæˆ‘ä»¬éƒ½æœ‰æ‰€æœ‰å·²çŸ¥æœ€çŸ­è·¯å¾„çš„èŠ‚ç‚¹é›†åˆï¼ˆæœ€åˆè¿™ä»…ä»…æ˜¯æºèŠ‚ç‚¹ï¼Œä½†è¿™ç¡®å®æ„å‘³ç€è¿™ä¸ªé›†åˆæ°¸è¿œä¸ä¼šä¸ºç©ºï¼Œè¿™åœ¨æ¥ä¸‹æ¥çš„è®¨è®ºä¸­ä¼šå¾ˆé‡è¦ï¼‰ã€‚ç°åœ¨è€ƒè™‘æ‰€æœ‰ä¸è¿™ä¸ªèŠ‚ç‚¹é›†åˆç›¸é‚»çš„è¾¹ï¼Œè¿™äº›è¾¹é€šå‘é‚£äº›æˆ‘ä»¬å°šæœªçŸ¥é“æœ€çŸ­è·¯å¾„çš„èŠ‚ç‚¹ã€‚é€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè®°ä¸º
    \(q\)ï¼Œä½¿å¾—åˆ°è¾¾è¯¥èŠ‚ç‚¹çš„è·¯å¾„æ€»æƒé‡æœ€å°ã€‚æˆ‘ä»¬æ–­è¨€è¿™å®é™…ä¸Šå°†æ˜¯åˆ°è¾¾è¯¥èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ã€‚
- en: If this claim is true, then we are done. Thatâ€™s because we would now add \(q\)
    to the set of nodes whose lightest weights we now know, and repeat the process
    of finding lightest outgoing edges from there. This process has thus added one
    more node. At some point we will find that there are no edges that lead outside
    the known set, at which point we can terminate.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœè¿™ä¸ªè¯´æ³•æ˜¯æ­£ç¡®çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å®Œæˆäº†ã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬ç°åœ¨ä¼šå°† \(q\) æ·»åŠ åˆ°å·²çŸ¥æœ€å°æƒé‡çš„èŠ‚ç‚¹é›†åˆä¸­ï¼Œå¹¶ä»é‚£é‡Œé‡å¤å¯»æ‰¾æœ€è½»å‡ºè¾¹çš„è¿‡ç¨‹ã€‚è¿™ä¸ªè¿‡ç¨‹å› æ­¤å¢åŠ äº†ä¸€ä¸ªèŠ‚ç‚¹ã€‚åœ¨æŸä¸ªæ—¶åˆ»ï¼Œæˆ‘ä»¬ä¼šå‘ç°æ²¡æœ‰è¾¹èƒ½ä»å·²çŸ¥é›†åˆä¸­å¼•å‡ºï¼Œè¿™æ—¶æˆ‘ä»¬å¯ä»¥ç»ˆæ­¢ã€‚
- en: 'It stands to reason that terminating at this point is safe: it corresponds
    to having computed the reachable set. The only thing left is to demonstrate that
    this greedy algorithm yields a lightest path to each node.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰ç†ç”±ç›¸ä¿¡åœ¨è¿™ä¸ªç‚¹ä¸Šç»ˆæ­¢æ˜¯å®‰å…¨çš„ï¼šå®ƒå¯¹åº”äºå·²ç»è®¡ç®—äº†å¯è¾¾é›†åˆã€‚å”¯ä¸€å‰©ä¸‹çš„äº‹æƒ…æ˜¯è¦è¯æ˜è¿™ä¸ªè´ªå¿ƒç®—æ³•ä¸ºæ¯ä¸ªèŠ‚ç‚¹æä¾›äº†æœ€çŸ­è·¯å¾„ã€‚
- en: We will prove this by contradiction. Suppose we have the path \(s \rightarrow
    d\) from source \(s\) to node \(d\), as found by the algorithm above, but assume
    also that we have a different path that is actually lighter. At every node, when
    we added a node along the \(s \rightarrow d\) path, the algorithm would have added
    a lighter path if it existed. The fact that it did not falsifies our claim that
    a lighter path exists (there could be a different path of the same weight; this
    would be permitted by the algorithm, but it also doesnâ€™t contradict our claim).
    Therefore the algorithm does indeed find the lightest path.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†é€šè¿‡åè¯æ³•æ¥è¯æ˜è¿™ä¸€ç‚¹ã€‚å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªä»æºç‚¹ \(s\) åˆ°èŠ‚ç‚¹ \(d\) çš„è·¯å¾„ \(s \rightarrow d\)ï¼Œè¿™æ˜¯é€šè¿‡ä¸Šè¿°ç®—æ³•æ‰¾åˆ°çš„ï¼Œä½†å‡è®¾æˆ‘ä»¬è¿˜æœ‰ä¸€ä¸ªå®é™…ä¸Šæ›´è½»çš„è·¯å¾„ã€‚åœ¨æ¯ä¸€æ­¥ï¼Œå½“æˆ‘ä»¬æ²¿ç€
    \(s \rightarrow d\) è·¯å¾„æ·»åŠ ä¸€ä¸ªèŠ‚ç‚¹æ—¶ï¼Œå¦‚æœå­˜åœ¨æ›´è½»çš„è·¯å¾„ï¼Œç®—æ³•ä¼šæ·»åŠ ä¸€ä¸ªæ›´è½»çš„è·¯å¾„ã€‚å®ƒæ²¡æœ‰è¿™æ ·åšçš„äº‹å®å¦å®šäº†å­˜åœ¨æ›´è½»è·¯å¾„çš„æ–­è¨€ï¼ˆå¯èƒ½å­˜åœ¨ä¸€ä¸ªç›¸åŒæƒé‡çš„ä¸åŒè·¯å¾„ï¼›è¿™ä¼šè¢«ç®—æ³•å…è®¸ï¼Œä½†è¿™ä¹Ÿä¸ä¸æˆ‘ä»¬çš„æ–­è¨€ç›¸çŸ›ç›¾ï¼‰ã€‚å› æ­¤ï¼Œç®—æ³•ç¡®å®æ‰¾åˆ°äº†æœ€çŸ­è·¯å¾„ã€‚
- en: 'What remains is to determine a data structure that enables this algorithm.
    At every node, we want to know the least weight from the set of nodes for which
    we know the least weight to all their neighbors. We could achieve this by sorting,
    but this is overkill: we donâ€™t actually need a total ordering on all these weights,
    only the lightest one. A heap [see Wikipedia](https://en.wikipedia.org/wiki/Heap_(data_structure))
    gives us this.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: å‰©ä¸‹çš„å·¥ä½œæ˜¯è¦ç¡®å®šä¸€ç§æ•°æ®ç»“æ„ï¼Œä½¿å¾—è¿™ä¸ªç®—æ³•èƒ½å¤Ÿå®ç°ã€‚åœ¨æ¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæˆ‘ä»¬å¸Œæœ›çŸ¥é“ä»é‚£äº›æˆ‘ä»¬çŸ¥é“æœ€å°æƒé‡çš„èŠ‚ç‚¹é›†åˆä¸­ï¼Œåˆ°å®ƒä»¬æ‰€æœ‰é‚»å±…çš„æœ€å°æƒé‡ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡æ’åºæ¥å®ç°è¿™ä¸€ç‚¹ï¼Œä½†è¿™è¿‡äºå¤æ‚äº†ï¼šæˆ‘ä»¬å®é™…ä¸Šå¹¶ä¸éœ€è¦å¯¹æ‰€æœ‰è¿™äº›æƒé‡è¿›è¡Œå®Œå…¨æ’åºï¼Œåªéœ€è¦çŸ¥é“æœ€è½»çš„é‚£ä¸ªã€‚ä¸€ä¸ªå †ï¼ˆè§ç»´åŸºç™¾ç§‘[Heap
    (data structure)](https://en.wikipedia.org/wiki/Heap_(data_structure)))å¯ä»¥ç»™æˆ‘ä»¬æä¾›è¿™ä¸ªã€‚
- en: Exercise
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What if we allowed edges of weight zero? What would change in the above algorithm?
  id: totrans-22
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬å…è®¸æƒé‡ä¸ºé›¶çš„è¾¹å‘¢ï¼Ÿä¸Šè¿°ç®—æ³•ä¼šæœ‰ä»€ä¹ˆå˜åŒ–ï¼Ÿ
- en: Exercise
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What if we allowed edges of negative weight? What would change in the above
    algorithm?After youâ€™ve thought about this for a while, take a look at [this article](https://www.quantamagazine.org/finally-a-fast-algorithm-for-shortest-paths-on-negative-graphs-20230118/).
  id: totrans-25
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬å…è®¸è´Ÿæƒé‡çš„è¾¹å‘¢ï¼Ÿä¸Šè¿°ç®—æ³•ä¼šæœ‰ä»€ä¹ˆå˜åŒ–ï¼Ÿåœ¨æ€è€ƒäº†ä¸€æ®µæ—¶é—´åï¼Œè¯·æŸ¥çœ‹[è¿™ç¯‡æ–‡ç« ](https://www.quantamagazine.org/finally-a-fast-algorithm-for-shortest-paths-on-negative-graphs-20230118/)ã€‚
- en: For your reference, this algorithm is known as Dijkstraâ€™s Algorithm.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾›æ‚¨å‚è€ƒï¼Œè¿™ä¸ªç®—æ³•è¢«ç§°ä¸ºè¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•ï¼ˆDijkstraâ€™s Algorithmï¼‰ã€‚
