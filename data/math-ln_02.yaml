- en: 2\. Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 基础
- en: 原文：[https://leanprover-community.github.io/mathematics_in_lean/C02_Basics.html](https://leanprover-community.github.io/mathematics_in_lean/C02_Basics.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://leanprover-community.github.io/mathematics_in_lean/C02_Basics.html](https://leanprover-community.github.io/mathematics_in_lean/C02_Basics.html)
- en: '*[Mathematics in Lean](index.html)* **   2\. Basics'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*[数学在Lean中](index.html)* **   2. 基础'
- en: '[View page source](_sources/C02_Basics.rst.txt)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[查看页面源代码](_sources/C02_Basics.rst.txt)'
- en: '* * *'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'This chapter is designed to introduce you to the nuts and bolts of mathematical
    reasoning in Lean: calculating, applying lemmas and theorems, and reasoning about
    generic structures.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在向您介绍Lean中数学推理的精髓：计算、应用引理和定理，以及关于通用结构的推理。
- en: 2.1\. Calculating[](#calculating "Link to this heading")
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1. 计算[](#calculating "链接到这个标题")
- en: We generally learn to carry out mathematical calculations without thinking of
    them as proofs. But when we justify each step in a calculation, as Lean requires
    us to do, the net result is a proof that the left-hand side of the calculation
    is equal to the right-hand side.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常学会进行数学计算，而不将其视为证明。但当我们像Lean所要求的那样为计算的每一步进行辩护时，最终结果是证明计算的左侧等于右侧。
- en: In Lean, stating a theorem is tantamount to stating a goal, namely, the goal
    of proving the theorem. Lean provides the rewriting tactic `rw`, to replace the
    left-hand side of an identity by the right-hand side in the goal. If `a`, `b`,
    and `c` are real numbers, `mul_assoc a b c` is the identity `a * b * c = a * (b
    * c)` and `mul_comm a b` is the identity `a * b = b * a`. Lean provides automation
    that generally eliminates the need to refer the facts like these explicitly, but
    they are useful for the purposes of illustration. In Lean, multiplication associates
    to the left, so the left-hand side of `mul_assoc` could also be written `(a *
    b) * c`. However, it is generally good style to be mindful of Lean’s notational
    conventions and leave out parentheses when Lean does as well.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lean中，陈述一个定理等同于陈述一个目标，即证明该定理的目标。Lean提供了重写策略`rw`，用于在目标中将等式的左侧替换为右侧。如果`a`、`b`和`c`是实数，`mul_assoc
    a b c`是等式`a * b * c = a * (b * c)`，而`mul_comm a b`是等式`a * b = b * a`。Lean提供了自动化，通常可以消除显式引用此类事实的需要，但它们对于说明目的很有用。在Lean中，乘法结合律适用于左侧，因此`mul_assoc`的左侧也可以写成`(a
    * b) * c`。然而，通常好的风格是注意Lean的符号约定，并在Lean也这样做的情况下省略括号。
- en: Let’s try out `rw`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试`rw`。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `import` lines at the beginning of the associated examples file import the
    theory of the real numbers from Mathlib, as well as useful automation. For the
    sake of brevity, we generally suppress information like this in the textbook.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在相关示例文件的开头，`import` 行导入来自Mathlib的实数理论以及有用的自动化。为了简洁起见，我们在教科书中通常省略此类信息。
- en: 'You are welcome to make changes to see what happens. You can type the `ℝ` character
    as `\R` or `\real` in VS Code. The symbol doesn’t appear until you hit space or
    the tab key. If you hover over a symbol when reading a Lean file, VS Code will
    show you the syntax that can be used to enter it. If you are curious to see all
    available abbreviations, you can hit Ctrl-Shift-P and then type abbreviations
    to get access to the `Lean 4: Show Unicode Input Abbreviations` command. If your
    keyboard does not have an easily accessible backslash, you can change the leading
    character by changing the `lean4.input.leader` setting.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以尝试修改以查看会发生什么。您可以在VS Code中键入`ℝ`字符为`\R`或`\real`。符号只有在您按下空格键或制表键时才会出现。如果您在阅读Lean文件时将鼠标悬停在符号上，VS
    Code将显示可以用来输入它的语法。如果您想查看所有可用的缩写，您可以按Ctrl-Shift-P，然后键入缩写以获取访问`Lean 4: 显示Unicode输入缩写`命令的权限。如果您的键盘没有容易访问的反斜杠，您可以通过更改`lean4.input.leader`设置来更改前导字符。'
- en: 'When a cursor is in the middle of a tactic proof, Lean reports on the current
    *proof state* in the *Lean Infoview* window. As you move your cursor past each
    step of the proof, you can see the state change. A typical proof state in Lean
    might look as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当光标位于策略证明的中间时，Lean会在*Lean Infoview*窗口中报告当前的*证明状态*。随着您将光标移过证明的每一步，您可以看到状态的变化。Lean中的一个典型证明状态可能如下所示：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The lines before the one that begins with `⊢` denote the *context*: they are
    the objects and assumptions currently at play. In this example, these include
    two objects, `x` and `y`, each a natural number. They also include three assumptions,
    labelled `h₁`, `h₂`, and `h₃`. In Lean, everything in a context is labelled with
    an identifier. You can type these subscripted labels as `h\1`, `h\2`, and `h\3`,
    but any legal identifiers would do: you can use `h1`, `h2`, `h3` instead, or `foo`,
    `bar`, and `baz`. The last line represents the *goal*, that is, the fact to be
    proved. Sometimes people use *target* for the fact to be proved, and *goal* for
    the combination of the context and the target. In practice, the intended meaning
    is usually clear.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在以 `⊢` 开头的行之前表示的是*上下文*：它们是当前正在使用的对象和假设。在这个例子中，这些包括两个对象，`x` 和 `y`，每个都是自然数。它们还包括三个假设，分别标记为
    `h₁`、`h₂` 和 `h₃`。在 Lean 中，上下文中的所有内容都用标识符标记。你可以将这些下标标签键入为 `h\1`、`h\2` 和 `h\3`，但任何合法的标识符都可以：你可以使用
    `h1`、`h2`、`h3`，或者 `foo`、`bar` 和 `baz`。最后一行代表*目标*，即要证明的事实。有时人们用*目标*来表示要证明的事实，用*目标*来表示上下文和目标的组合。在实践中，通常可以清楚地理解意图。
- en: Try proving these identities, in each case replacing `sorry` by a tactic proof.
    With the `rw` tactic, you can use a left arrow (`\l`) to reverse an identity.
    For example, `rw [← mul_assoc a b c]` replaces `a * (b * c)` by `a * b * c` in
    the current goal. Note that the left-pointing arrow refers to going from right
    to left in the identity provided by `mul_assoc`, it has nothing to do with the
    left or right side of the goal.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试证明这些恒等式，在每种情况下用策略证明替换 `sorry`。使用 `rw` 策略，你可以使用左箭头 (`\l`) 来反转一个恒等式。例如，`rw [←
    mul_assoc a b c]` 将当前目标中的 `a * (b * c)` 替换为 `a * b * c`。注意，指向左边的箭头指的是从右到左在 `mul_assoc`
    提供的恒等式中移动，它与目标左右两侧无关。
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can also use identities like `mul_assoc` and `mul_comm` without arguments.
    In this case, the rewrite tactic tries to match the left-hand side with an expression
    in the goal, using the first pattern it finds.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以不带参数使用像 `mul_assoc` 和 `mul_comm` 这样的恒等式。在这种情况下，重写策略尝试将左侧与目标中的表达式匹配，使用它找到的第一个模式。
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can also provide *partial* information. For example, `mul_comm a` matches
    any pattern of the form `a * ?` and rewrites it to `? * a`. Try doing the first
    of these examples without providing any arguments at all, and the second with
    only one argument.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以提供*部分*信息。例如，`mul_comm a` 匹配任何形式为 `a * ?` 的模式，并将其重写为 `? * a`。尝试在不提供任何参数的情况下完成这些示例的第一个，以及只提供一个参数的第二个。
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can also use `rw` with facts from the local context.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用来自局部上下文的事实 `rw`。
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Try these, using the theorem `sub_self` for the second one:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些，使用定理 `sub_self` 对第二个进行操作：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Multiple rewrite commands can be carried out with a single command, by listing
    the relevant identities separated by commas inside the square brackets.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在方括号内用逗号分隔相关恒等式来使用单个命令执行多个重写命令。
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You still see the incremental progress by placing the cursor after a comma in
    any list of rewrites.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何重写列表中，将光标放在逗号后面，你仍然可以看到增量进度。
- en: Another trick is that we can declare variables once and for all outside an example
    or theorem. Lean then includes them automatically.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个技巧是，我们可以在示例或定理之外一次性声明变量。然后 Lean 会自动包含它们。
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Inspection of the tactic state at the beginning of the above proof reveals
    that Lean indeed included all variables. We can delimit the scope of the declaration
    by putting it in a `section ... end` block. Finally, recall from the introduction
    that Lean provides us with a command to determine the type of an expression:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 检查上述证明开始时的策略状态，可以发现 Lean 确实包含了所有变量。我们可以通过将其放在 `section ... end` 块中来限定声明的范围。最后，从引言中回忆起
    Lean 为我们提供了一个命令来确定表达式的类型：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `#check` command works for both objects and facts. In response to the command
    `#check a`, Lean reports that `a` has type `ℝ`. In response to the command `#check
    mul_comm a b`, Lean reports that `mul_comm a b` is a proof of the fact `a * b
    = b * a`. The command `#check (a : ℝ)` states our expectation that the type of
    `a` is `ℝ`, and Lean will raise an error if that is not the case. We will explain
    the output of the last three `#check` commands later, but in the meanwhile, you
    can take a look at them, and experiment with some `#check` commands of your own.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`#check`命令适用于对象和事实。对于命令`#check a`，Lean报告`a`的类型为`ℝ`。对于命令`#check mul_comm a b`，Lean报告`mul_comm
    a b`是事实`a * b = b * a`的证明。命令`#check (a : ℝ)`表示我们期望`a`的类型是`ℝ`，如果这不是情况，Lean将引发错误。我们将在稍后解释最后三个`#check`命令的输出，但在此同时，您可以查看它们，并尝试一些自己的`#check`命令。'
- en: Let’s try some more examples. The theorem `two_mul a` says that `2 * a = a +
    a`. The theorems `add_mul` and `mul_add` express the distributivity of multiplication
    over addition, and the theorem `add_assoc` expresses the associativity of addition.
    Use the `#check` command to see the precise statements.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些更复杂的例子。定理`two_mul a`表明`2 * a = a + a`。定理`add_mul`和`mul_add`表达了乘法在加法上的分配性，而定理`add_assoc`表达了加法的结合性。使用`#check`命令查看精确的陈述。
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Whereas it is possible to figure out what is going on in this proof by stepping
    through it in the editor, it is hard to read on its own. Lean provides a more
    structured way of writing proofs like this using the `calc` keyword.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以通过在编辑器中逐步执行来弄清楚这个证明的情况，但单独阅读时很难理解。Lean提供了使用`calc`关键字编写这种证明的更结构化方式。
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Notice that the proof does *not* begin with `by`: an expression that begins
    with `calc` is a *proof term*. A `calc` expression can also be used inside a tactic
    proof, but Lean interprets it as the instruction to use the resulting proof term
    to solve the goal. The `calc` syntax is finicky: the underscores and justification
    have to be in the format indicated above. Lean uses indentation to determine things
    like where a block of tactics or a `calc` block begins and ends; try changing
    the indentation in the proof above to see what happens.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，证明并不是从`by`开始的：以`calc`开头的表达式是一个*证明项*。`calc`表达式也可以用在策略证明中，但Lean将其解释为使用生成的证明项来解决目标的指令。`calc`语法很挑剔：下划线和论证必须采用上述格式。Lean使用缩进来确定策略块或`calc`块的开始和结束位置；尝试更改上述证明中的缩进来看看会发生什么。
- en: One way to write a `calc` proof is to outline it first using the `sorry` tactic
    for justification, make sure Lean accepts the expression modulo these, and then
    justify the individual steps using tactics.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 编写`calc`证明的一种方法首先使用`sorry`策略进行论证，确保Lean接受这些表达式，然后使用策略论证各个步骤。
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Try proving the following identity using both a pure `rw` proof and a more
    structured `calc` proof:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用纯`rw`证明和更结构化的`calc`证明来证明以下恒等式：
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The following exercise is a little more challenging. You can use the theorems
    listed underneath.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习稍微有些挑战性。你可以使用下面列出的定理。
- en: '[PRE14]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can also perform rewriting in an assumption in the context. For example,
    `rw [mul_comm a b] at hyp` replaces `a * b` by `b * a` in the assumption `hyp`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在假设的上下文中进行重写。例如，`rw [mul_comm a b] at hyp`将假设`hyp`中的`a * b`替换为`b * a`。
- en: '[PRE15]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the last step, the `exact` tactic can use `hyp` to solve the goal because
    at that point `hyp` matches the goal exactly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，`exact`策略可以使用`hyp`来解决目标，因为那时`hyp`与目标完全匹配。
- en: We close this section by noting that Mathlib provides a useful bit of automation
    with a `ring` tactic, which is designed to prove identities in any commutative
    ring as long as they follow purely from the ring axioms, without using any local
    assumption.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过指出Mathlib提供了一个有用的自动化功能，即`ring`策略来结束本节，该策略旨在证明任何交换环中的恒等式，只要它们纯粹地来自环公理，而不使用任何局部假设。
- en: '[PRE16]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `ring` tactic is imported indirectly when we import `Mathlib.Data.Real.Basic`,
    but we will see in the next section that it can be used for calculations on structures
    other than the real numbers. It can be imported explicitly with the command `import
    Mathlib.Tactic`. We will see there are similar tactics for other common kind of
    algebraic structures.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们导入`Mathlib.Data.Real.Basic`时，`ring`策略是间接导入的，但在下一节中我们将看到它可以用在除了实数以外的结构上。可以使用命令`import
    Mathlib.Tactic`显式导入。我们将在那里看到其他常见代数结构的类似策略。
- en: There is a variation of `rw` called `nth_rw` that allows you to replace only
    particular instances of an expression in the goal. Possible matches are enumerated
    starting with 1, so in the following example, `nth_rw 2 [h]` replaces the second
    occurrence of `a + b` with `c`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种 `rw` 的变体称为 `nth_rw`，它允许你只替换目标中特定实例的表达式。可能的匹配从 1 开始枚举，所以在这个例子中，`nth_rw 2
    [h]` 将 `a + b` 的第二个出现替换为 `c`。
- en: '[PRE17]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '## 2.2\. Proving Identities in Algebraic Structures[](#proving-identities-in-algebraic-structures
    "Link to this heading")'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '## 2.2\. 在代数结构中证明恒等式[](#proving-identities-in-algebraic-structures "链接到这个标题")'
- en: 'Mathematically, a ring consists of a collection of objects, \(R\), operations
    \(+\) \(\times\), and constants \(0\) and \(1\), and an operation \(x \mapsto
    -x\) such that:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，一个环由一个对象集合 \(R\)、运算 \(+\) 和 \(\times\)、常数 \(0\) 和 \(1\) 以及一个运算 \(x \mapsto
    -x\) 组成，该运算满足以下条件：
- en: \(R\) with \(+\) is an *abelian group*, with \(0\) as the additive identity
    and negation as inverse.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(R\) 与 \(+\) 是一个 *阿贝尔群*，其中 \(0\) 是加法单位元，否定是逆元。
- en: Multiplication is associative with identity \(1\), and multiplication distributes
    over addition.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法与单位元 \(1\) 结合，并且乘法对加法分配。
- en: 'In Lean, the collection of objects is represented as a *type*, `R`. The ring
    axioms are as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lean 中，对象的集合被表示为一个 *类型*，`R`。环的公理如下：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You will learn more about the square brackets in the first line later, but for
    the time being, suffice it to say that the declaration gives us a type, `R`, and
    a ring structure on `R`. Lean then allows us to use generic ring notation with
    elements of `R`, and to make use of a library of theorems about rings.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在以后了解第一行中的方括号，但就目前而言，只需说这个声明给我们一个类型，`R`，以及 `R` 上的环结构。然后 Lean 允许我们使用 `R` 的元素进行通用的环符号，并利用关于环的定理库。
- en: 'The names of some of the theorems should look familiar: they are exactly the
    ones we used to calculate with the real numbers in the last section. Lean is good
    not only for proving things about concrete mathematical structures like the natural
    numbers and the integers, but also for proving things about abstract structures,
    characterized axiomatically, like rings. Moreover, Lean supports *generic reasoning*
    about both abstract and concrete structures, and can be trained to recognize appropriate
    instances. So any theorem about rings can be applied to concrete rings like the
    integers, `ℤ`, the rational numbers, `ℚ`, and the complex numbers `ℂ`. It can
    also be applied to any instance of an abstract structure that extends rings, such
    as any ordered ring or any field.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一些定理的名称应该看起来很熟悉：它们正是我们在上一节中使用实数进行计算时使用的那些。Lean 不仅擅长证明关于自然数和整数等具体数学结构的性质，而且也擅长证明关于抽象结构（如环）的性质，这些结构是公理化定义的。此外，Lean
    支持 *通用推理* 关于抽象和具体结构，并且可以训练它识别适当的实例。因此，任何关于环的定理都可以应用于具体的环，如整数环 `ℤ`、有理数环 `ℚ` 和复数环
    `ℂ`。它也可以应用于任何扩展环的抽象结构的实例，例如任何有序环或任何域。
- en: Not all important properties of the real numbers hold in an arbitrary ring,
    however. For example, multiplication on the real numbers is commutative, but that
    does not hold in general. If you have taken a course in linear algebra, you will
    recognize that, for every \(n\), the \(n\) by \(n\) matrices of real numbers form
    a ring in which commutativity usually fails. If we declare `R` to be a *commutative*
    ring, in fact, all the theorems in the last section continue to hold when we replace
    `ℝ` by `R`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有实数的性质在任意环中都成立。例如，实数上的乘法是交换的，但通常不成立。如果你已经学过线性代数课程，你会认识到，对于每个 \(n\)，实数的
    \(n\) 阶矩阵形成一个环，其中交换性通常不成立。如果我们声明 `R` 为 *交换环*，实际上，当我们将 `ℝ` 替换为 `R` 时，上一节中的所有定理仍然成立。
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We leave it to you to check that all the other proofs go through unchanged.
    Notice that when a proof is short, like `by ring` or `by linarith` or `by sorry`,
    it is common (and permissible) to put it on the same line as the `by`. Good proof-writing
    style should strike a balance between concision and readability.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们留给你们去验证所有其他证明都保持不变。注意，当证明很短，如 `by ring` 或 `by linarith` 或 `by sorry` 时，将其放在
    `by` 的同一行上是常见（并且允许）的。良好的证明写作风格应在简洁性和可读性之间取得平衡。
- en: The goal of this section is to strengthen the skills you have developed in the
    last section and apply them to reasoning axiomatically about rings. We will start
    with the axioms listed above, and use them to derive other facts. Most of the
    facts we prove are already in Mathlib. We will give the versions we prove the
    same names to help you learn the contents of the library as well as the naming
    conventions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是加强你在上一节中发展的技能，并将它们应用于对环进行公理推理。我们将从上面列出的公理开始，并使用它们推导出其他事实。我们证明的大多数事实已经在
    Mathlib 中。我们将给出我们证明的版本相同的名称，以帮助你学习库的内容以及命名约定。
- en: 'Lean provides an organizational mechanism similar to those used in programming
    languages: when a definition or theorem `foo` is introduced in a *namespace* `bar`,
    its full name is `bar.foo`. The command `open bar` later *opens* the namespace,
    which allows us to use the shorter name `foo`. To avoid errors due to name clashes,
    in the next example we put our versions of the library theorems in a new namespace
    called `MyRing.`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 提供了一种类似于编程语言中使用的组织机制：当在 *命名空间* `bar` 中引入定义或定理 `foo` 时，其全名是 `bar.foo`。命令
    `open bar` 会在稍后 *打开* 命名空间，这允许我们使用较短的名称 `foo`。为了避免由于名称冲突而引起的错误，在下一个示例中，我们将我们库定理的版本放在一个新的命名空间
    `MyRing` 中。
- en: The next example shows that we do not need `add_zero` or `add_neg_cancel` as
    ring axioms, because they follow from the other axioms.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例表明，我们不需要将 `add_zero` 或 `add_neg_cancel` 作为环公理，因为它们可以从其他公理中得出。
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The net effect is that we can temporarily reprove a theorem in the library,
    and then go on using the library version after that. But don’t cheat! In the exercises
    that follow, take care to use only the general facts about rings that we have
    proved earlier in this section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种效果是，我们可以暂时重新证明库中的一个定理，然后继续使用库版本。但不要作弊！在接下来的练习中，请务必只使用我们在本节中之前已经证明的关于环的一般事实。
- en: '(If you are paying careful attention, you may have noticed that we changed
    the round brackets in `(R : Type*)` for curly brackets in `{R : Type*}`. This
    declares `R` to be an *implicit argument*. We will explain what this means in
    a moment, but don’t worry about it in the meanwhile.)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '（如果你仔细观察，你可能已经注意到我们在 `(R : Type*)` 中将圆括号改为了花括号 `{R : Type*}`。这表明 `R` 是一个 *隐式参数*。我们将在稍后解释这意味着什么，但在此期间不必担心。）'
- en: 'Here is a useful theorem:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有用的定理：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Prove the companion version:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 证明伴随版本：
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Use these to prove the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些来证明以下内容：
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With enough planning, you can do each of them with three rewrites.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的规划下，你可以用三次重写来完成每一个。
- en: 'We will now explain the use of the curly braces. Imagine you are in a situation
    where you have `a`, `b`, and `c` in your context, as well as a hypothesis `h :
    a + b = a + c`, and you would like to draw the conclusion `b = c`. In Lean, you
    can apply a theorem to hypotheses and facts just the same way that you can apply
    them to objects, so you might think that `add_left_cancel a b c h` is a proof
    of the fact `b = c`. But notice that explicitly writing `a`, `b`, and `c` is redundant,
    because the hypothesis `h` makes it clear that those are the objects we have in
    mind. In this case, typing a few extra characters is not onerous, but if we wanted
    to apply `add_left_cancel` to more complicated expressions, writing them would
    be tedious. In cases like these, Lean allows us to mark arguments as *implicit*,
    meaning that they are supposed to be left out and inferred by other means, such
    as later arguments and hypotheses. The curly brackets in `{a b c : R}` do exactly
    that. So, given the statement of the theorem above, the correct expression is
    simply `add_left_cancel h`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们将解释花括号的使用。想象一下，你处于一个情境，其中你的上下文中有 `a`、`b` 和 `c`，以及一个假设 `h : a + b = a +
    c`，你想要得出结论 `b = c`。在 Lean 中，你可以像对对象一样对假设和事实应用定理，所以你可能认为 `add_left_cancel a b c
    h` 是 `b = c` 这一事实的证明。但请注意，明确写出 `a`、`b` 和 `c` 是多余的，因为假设 `h` 清楚地表明了这些是我们心中的对象。在这种情况下，输入几个额外的字符并不麻烦，但如果我们想要将
    `add_left_cancel` 应用到更复杂的表达式中，编写它们将会很繁琐。在这些情况下，Lean 允许我们将参数标记为 *隐式*，这意味着它们应该被省略，并通过其他方式（如后续参数和假设）推断出来。`{a
    b c : R}` 中的花括号正是这样做的。因此，给定上述定理的陈述，正确的表达式仅仅是 `add_left_cancel h`。'
- en: To illustrate, let us show that `a * 0 = 0` follows from the ring axioms.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，让我们展示 `a * 0 = 0` 可以从环公理中得出。
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We have used a new trick! If you step through the proof, you can see what is
    going on. The `have` tactic introduces a new goal, `a * 0 + a * 0 = a * 0 + 0`,
    with the same context as the original goal. The fact that the next line is indented
    indicates that Lean is expecting a block of tactics that serves to prove this
    new goal. The indentation therefore promotes a modular style of proof: the indented
    subproof establishes the goal that was introduced by the `have`. After that, we
    are back to proving the original goal, except a new hypothesis `h` has been added:
    having proved it, we are now free to use it. At this point, the goal is exactly
    the result of `add_left_cancel h`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个新的技巧！如果你逐步通过证明，你可以看到发生了什么。`have` 策略引入了一个新的目标，`a * 0 + a * 0 = a * 0 +
    0`，与原始目标具有相同的环境。下一行缩进的事实表明 Lean 预期一个策略块，该块用于证明这个新目标。因此，缩进促进了模块化证明风格：缩进的子证明建立了由
    `have` 引入的目标。之后，我们回到证明原始目标，除了增加了一个新的假设 `h`：证明它之后，我们现在可以自由地使用它。此时，目标正好是 `add_left_cancel
    h` 的结果。
- en: We could equally well have closed the proof with `apply add_left_cancel h` or
    `exact add_left_cancel h`. The `exact` tactic takes as argument a proof term which
    completely proves the current goal, without creating any new goal. The `apply`
    tactic is a variant whose argument is not necessarily a complete proof. The missing
    pieces are either inferred automatically by Lean or become new goals to prove.
    While the `exact` tactic is technically redundant since it is strictly less powerful
    than `apply`, it makes proof scripts slightly clearer to human readers and easier
    to maintain when the library evolves.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们同样可以用 `apply add_left_cancel h` 或 `exact add_left_cancel h` 来结束证明。`exact`
    策略的参数是一个完全证明当前目标的证明项，而不创建任何新的目标。`apply` 策略是一个变体，其参数不一定是完整的证明。缺失的部分要么由 Lean 自动推断，要么成为需要证明的新目标。虽然
    `exact` 策略在技术上可能是多余的，因为它严格不如 `apply` 强大，但它使证明脚本对人类读者来说更清晰，并且在库演变时更容易维护。
- en: Remember that multiplication is not assumed to be commutative, so the following
    theorem also requires some work.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，乘法不一定假设是交换的，因此下面的定理也需要一些工作。
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: By now, you should also be able replace each `sorry` in the next exercise with
    a proof, still using only facts about rings that we have established in this section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你也应该能够将下一个练习中的每个 `sorry` 替换为一个证明，仍然只使用本节中我们建立的关于环的事实。
- en: '[PRE26]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We had to use the annotation `(-0 : R)` instead of `0` in the third theorem
    because without specifying `R` it is impossible for Lean to infer which `0` we
    have in mind, and by default it would be interpreted as a natural number.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在第三个定理中必须使用注释 `(-0 : R)` 而不是 `0`，因为没有指定 `R`，Lean 就无法推断我们心中所想的 `0` 是什么，默认情况下它会被解释为自然数。'
- en: In Lean, subtraction in a ring is provably equal to addition of the additive
    inverse.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lean 中，环中的减法可以证明等于加法上的加法逆元。
- en: '[PRE27]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'On the real numbers, it is *defined* that way:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在实数上，它是这样定义的：
- en: '[PRE28]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The proof term `rfl` is short for “reflexivity”. Presenting it as a proof of
    `a - b = a + -b` forces Lean to unfold the definition and recognize both sides
    as being the same. The `rfl` tactic does the same. This is an instance of what
    is known as a *definitional equality* in Lean’s underlying logic. This means that
    not only can one rewrite with `sub_eq_add_neg` to replace `a - b = a + -b`, but
    in some contexts, when dealing with the real numbers, you can use the two sides
    of the equation interchangeably. For example, you now have enough information
    to prove the theorem `self_sub` from the last section:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 证明项 `rfl` 是“自反性”的简称。将其作为 `a - b = a + -b` 的证明迫使 Lean 展开定义并认识到两边是相同的。`rfl` 策略做的是同样的事情。这是
    Lean 内在逻辑中所谓的 *定义性等价* 的一个例子。这意味着不仅可以用 `sub_eq_add_neg` 来重写 `a - b = a + -b`，而且在某些上下文中，当处理实数时，你可以交换方程的两边。例如，你现在有足够的信息来证明上一节中的定理
    `self_sub`：
- en: '[PRE29]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Show that you can prove this using `rw`, but if you replace the arbitrary ring
    `R` by the real numbers, you can also prove it using either `apply` or `exact`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 证明你可以使用 `rw` 来证明这一点，但如果将任意的环 `R` 替换为实数，你也可以使用 `apply` 或 `exact` 中的任何一个来证明。
- en: 'Lean knows that `1 + 1 = 2` holds in any ring. With a bit of effort, you can
    use that to prove the theorem `two_mul` from the last section:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 知道 `1 + 1 = 2` 在任何环中都成立。通过一点努力，你可以用这个来证明上一节中的定理 `two_mul`：
- en: '[PRE30]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We close this section by noting that some of the facts about addition and negation
    that we established above do not need the full strength of the ring axioms, or
    even commutativity of addition. The weaker notion of a *group* can be axiomatized
    as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节结束时指出，我们上面建立的一些关于加法和负的事实不需要环公理的全部强度，甚至不需要加法的交换性。弱化的 *群* 概念可以如下公理化：
- en: '[PRE31]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It is conventional to use additive notation when the group operation is commutative,
    and multiplicative notation otherwise. So Lean defines a multiplicative version
    as well as the additive version (and also their abelian variants, `AddCommGroup`
    and `CommGroup`).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当群运算交换时，使用加法符号是惯例，否则使用乘法符号。因此，Lean 定义了乘法版本以及加法版本（以及它们的阿贝尔变体 `AddCommGroup` 和
    `CommGroup`）。
- en: '[PRE32]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you are feeling cocky, try proving the following facts about groups, using
    only these axioms. You will need to prove a number of helper lemmas along the
    way. The proofs we have carried out in this section provide some hints.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感到自信，尝试仅使用这些公理来证明以下关于群的事实。在这个过程中，你需要证明一些辅助引理。本节中我们已经完成的证明提供了一些提示。
- en: '[PRE33]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Explicitly invoking those lemmas is tedious, so Mathlib provides tactics similar
    to ring in order to cover most uses: group is for non-commutative multiplicative
    groups, abel for abelian additive groups, and noncomm_ring for non-commutative
    rings. It may seem odd that the algebraic structures are called Ring and CommRing
    while the tactics are named noncomm_ring and ring. This is partly for historical
    reasons, but also for the convenience of using a shorter name for the tactic that
    deals with commutative rings, since it is used more often.  ## 2.3\. Using Theorems
    and Lemmas[](#using-theorems-and-lemmas "Link to this heading")'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 明确调用这些引理是繁琐的，因此 Mathlib 提供了类似于环的策略来覆盖大多数用法：`group` 用于非交换乘法群，`abel` 用于阿贝尔加法群，而
    `noncomm_ring` 用于非交换环。看起来很奇怪，代数结构被称为 Ring 和 CommRing，而策略被命名为 noncomm_ring 和 ring。这部分是历史原因，但也为了方便使用更短的名称来处理交换环的策略，因为它使用得更频繁。##
    2.3. 使用定理和引理[](#using-theorems-and-lemmas "链接到本标题")
- en: Rewriting is great for proving equations, but what about other sorts of theorems?
    For example, how can we prove an inequality, like the fact that \(a + e^b \le
    a + e^c\) holds whenever \(b \le c\)? We have already seen that theorems can be
    applied to arguments and hypotheses, and that the `apply` and `exact` tactics
    can be used to solve goals. In this section, we will make good use of these tools.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重写对于证明方程很有用，但对于其他类型的定理呢？例如，我们如何证明一个不等式，比如 \(a + e^b \le a + e^c\) 在 \(b \le
    c\) 时总是成立？我们已经看到定理可以应用于论点和假设，并且可以使用 `apply` 和 `exact` 策略来解决目标。在本节中，我们将充分利用这些工具。
- en: 'Consider the library theorems `le_refl` and `le_trans`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑库中的定理 `le_refl` 和 `le_trans`：
- en: '[PRE34]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As we explain in more detail in [Section 3.1](C03_Logic.html#implication-and-the-universal-quantifier),
    the implicit parentheses in the statement of `le_trans` associate to the right,
    so it should be interpreted as `a ≤ b → (b ≤ c → a ≤ c)`. The library designers
    have set the arguments `a`, `b` and `c` to `le_trans` implicit, so that Lean will
    *not* let you provide them explicitly (unless you really insist, as we will discuss
    later). Rather, it expects to infer them from the context in which they are used.
    For example, when hypotheses `h : a ≤ b` and `h'' : b ≤ c` are in the context,
    all the following work:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们在[第 3.1 节](C03_Logic.html#implication-and-the-universal-quantifier)中更详细地解释的那样，`le_trans`
    的陈述中的隐式括号与右侧关联，因此它应该被解释为 `a ≤ b → (b ≤ c → a ≤ c)`。库设计者已经将 `a`、`b` 和 `c` 设置为 `le_trans`
    的隐式参数，这样 Lean 就不会让你明确地提供它们（除非你真的坚持，我们稍后会讨论）。相反，它期望从它们被使用的上下文中推断它们。例如，当假设 `h :
    a ≤ b` 和 `h'' : b ≤ c` 在上下文中时，以下所有内容都有效：'
- en: '[PRE35]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `apply` tactic takes a proof of a general statement or implication, tries
    to match the conclusion with the current goal, and leaves the hypotheses, if any,
    as new goals. If the given proof matches the goal exactly (modulo *definitional*
    equality), you can use the `exact` tactic instead of `apply`. So, all of these
    work:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply` 策略接受一个一般陈述或蕴涵的证明，尝试将结论与当前目标匹配，并将假设（如果有的话）作为新的目标留下。如果给定的证明与目标完全匹配（模定义等价），则可以使用
    `exact` 策略而不是 `apply`。所以，所有这些都有效：'
- en: '[PRE36]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the first example, applying `le_trans` creates two goals, and we use the
    dots to indicate where the proof of each begins. The dots are optional, but they
    serve to *focus* the goal: within the block introduced by the dot, only one goal
    is visible, and it must be completed before the end of the block. Here we end
    the first block by starting a new one with another dot. We could just as well
    have decreased the indentation. In the third example and in the last example,
    we avoid going into tactic mode entirely: `le_trans h₀ h₁` and `le_refl x` are
    the proof terms we need.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，应用 `le_trans` 创建了两个目标，我们使用点来表示每个证明的开始位置。点是可以省略的，但它们有助于 *聚焦* 目标：在点引入的块内，只有一个目标可见，并且必须在块的末尾之前完成。在这里，我们通过用另一个点开始一个新的块来结束第一个块。我们也可以减少缩进。在第三个例子和最后一个例子中，我们完全避免了进入策略模式：`le_trans
    h₀ h₁` 和 `le_refl x` 是我们需要证明项。
- en: 'Here are a few more library theorems:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一些图书馆定理：
- en: '[PRE37]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Use them together with `apply` and `exact` to prove the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们与 `apply` 和 `exact` 结合起来证明以下内容：
- en: '[PRE38]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In fact, Lean has a tactic that does this sort of thing automatically:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Lean 有一个策略可以自动完成这类事情：
- en: '[PRE39]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `linarith` tactic is designed to handle *linear arithmetic*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`linarith` 策略被设计用来处理 *线性算术*。'
- en: '[PRE40]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In addition to equations and inequalities in the context, `linarith` will use
    additional inequalities that you pass as arguments. In the next example, `exp_le_exp.mpr
    h'` is a proof of `exp b ≤ exp c`, as we will explain in a moment. Notice that,
    in Lean, we write `f x` to denote the application of a function `f` to the argument
    `x`, exactly the same way we write `h x` to denote the result of applying a fact
    or theorem `h` to the argument `x`. Parentheses are only needed for compound arguments,
    as in `f (x + y)`. Without the parentheses, `f x + y` would be parsed as `(f x)
    + y`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上下文中的方程和不等式，`linarith` 还会使用您作为参数传递的额外不等式。在下一个例子中，`exp_le_exp.mpr h'` 是 `exp
    b ≤ exp c` 的证明，我们将在下面解释。请注意，在 Lean 中，我们用 `f x` 来表示函数 `f` 对参数 `x` 的应用，这与我们用 `h
    x` 来表示事实或定理 `h` 对参数 `x` 的应用完全相同。括号仅用于复合参数，例如 `f (x + y)`。如果没有括号，`f x + y` 将被解析为
    `(f x) + y`。
- en: '[PRE41]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here are some more theorems in the library that can be used to establish inequalities
    on the real numbers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图书馆中还有一些定理可以用来在实数上建立不等式。
- en: '[PRE42]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Some of the theorems, `exp_le_exp`, `exp_lt_exp` use a *bi-implication*, which
    represents the phrase “if and only if.” (You can type it in VS Code with `\lr`
    or `\iff`). We will discuss this connective in greater detail in the next chapter.
    Such a theorem can be used with `rw` to rewrite a goal to an equivalent one:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一些定理，如 `exp_le_exp`、`exp_lt_exp` 使用了 *双向蕴涵*，它表示“当且仅当”这个短语。（您可以在 VS Code 中使用
    `\lr` 或 `\iff` 来输入它）。我们将在下一章中更详细地讨论这个连接词。这样的定理可以用 `rw` 来将目标重写为等价的目标：
- en: '[PRE43]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In this section, however, we will use the fact that if `h : A ↔ B` is such
    an equivalence, then `h.mp` establishes the forward direction, `A → B`, and `h.mpr`
    establishes the reverse direction, `B → A`. Here, `mp` stands for “modus ponens”
    and `mpr` stands for “modus ponens reverse.” You can also use `h.1` and `h.2`
    for `h.mp` and `h.mpr`, respectively, if you prefer. Thus the following proof
    works:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，在本节中，我们将使用以下事实：如果 `h : A ↔ B` 是这样的等价关系，那么 `h.mp` 建立了正向方向，`A → B`，而 `h.mpr`
    建立了反向方向，`B → A`。在这里，`mp` 代表“modus ponens”，而 `mpr` 代表“modus ponens reverse”。如果您愿意，也可以使用
    `h.1` 和 `h.2` 来代替 `h.mp` 和 `h.mpr`。因此，以下证明是有效的：'
- en: '[PRE44]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The first line, `apply add_lt_add_of_lt_of_le`, creates two goals, and once
    again we use a dot to separate the proof of the first from the proof of the second.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行，`apply add_lt_add_of_lt_of_le` 创建了两个目标，并且再次使用点来区分第一个和第二个证明。
- en: Try the following examples on your own. The example in the middle shows you
    that the `norm_num` tactic can be used to solve concrete numeric goals.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下示例。中间的示例向您展示了 `norm_num` 策略可以用来解决具体的数值目标。
- en: '[PRE45]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'From these examples, it should be clear that being able to find the library
    theorems you need constitutes an important part of formalization. There are a
    number of strategies you can use:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些例子中，应该很明显，能够找到所需的库定理是形式化的重要部分。您可以使用多种策略：
- en: You can browse Mathlib in its [GitHub repository](https://github.com/leanprover-community/mathlib4).
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在其 [GitHub 仓库](https://github.com/leanprover-community/mathlib4) 中浏览 Mathlib。
- en: You can use the API documentation on the Mathlib [web pages](https://leanprover-community.github.io/mathlib4_docs/).
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 Mathlib [网页](https://leanprover-community.github.io/mathlib4_docs/) 上的
    API 文档。
- en: You can use Loogle <https://loogle.lean-lang.org> to search Lean and Mathlib
    definitions and theorems by patterns.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 Loogle <https://loogle.lean-lang.org> 通过模式搜索 Lean 和 Mathlib 的定义和定理。
- en: You can rely on Mathlib naming conventions and Ctrl-space completion in the
    editor to guess a theorem name (or Cmd-space on a Mac keyboard). In Lean, a theorem
    named `A_of_B_of_C` establishes something of the form `A` from hypotheses of the
    form `B` and `C`, where `A`, `B`, and `C` approximate the way we might read the
    goals out loud. So a theorem establishing something like `x + y ≤ ...` will probably
    start with `add_le`. Typing `add_le` and hitting Ctrl-space will give you some
    helpful choices. Note that hitting Ctrl-space twice displays more information
    about the available completions.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以依靠 Mathlib 的命名约定和在编辑器中的 Ctrl-space 完成功能来猜测定理名称（或在 Mac 键盘上按 Cmd-space）。在 Lean
    中，一个名为 `A_of_B_of_C` 的定理从形式为 `B` 和 `C` 的假设中建立 `A`，其中 `A`、`B` 和 `C` 大致表示我们可能大声读出的目标。因此，一个类似于
    `x + y ≤ ...` 的定理可能以 `add_le` 开头。键入 `add_le` 并按 Ctrl-space 将提供一些有用的选择。请注意，按 Ctrl-space
    两次将显示有关可用完成信息的更多信息。
- en: If you right-click on an existing theorem name in VS Code, the editor will show
    a menu with the option to jump to the file where the theorem is defined, and you
    can find similar theorems nearby.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你右键单击 VS Code 中的一个现有定理名称，编辑器将显示一个菜单，其中包含跳转到定理定义文件并找到附近类似定理的选项。
- en: You can use the `apply?` tactic, which tries to find the relevant theorem in
    the library.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `apply?` 策略，它试图在库中找到相关的定理。
- en: '[PRE46]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To try out `apply?` in this example, delete the `exact` command and uncomment
    the previous line. Using these tricks, see if you can find what you need to do
    the next example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试在这个例子中使用 `apply?`，请删除 `exact` 命令并取消注释上一行。使用这些技巧，看看你是否能找到完成下一个例子所需的内容：
- en: '[PRE47]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Using the same tricks, confirm that `linarith` instead of `apply?` can also
    finish the job.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的技巧，确认 `linarith` 而不是 `apply?` 也可以完成工作。
- en: 'Here is another example of an inequality:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是不等式的一个例子：
- en: '[PRE48]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Mathlib tends to put spaces around binary operations like `*` and `^`, but in
    this example, the more compressed format increases readability. There are a number
    of things worth noticing. First, an expression `s ≥ t` is definitionally equivalent
    to `t ≤ s`. In principle, this means one should be able to use them interchangeably.
    But some of Lean’s automation does not recognize the equivalence, so Mathlib tends
    to favor `≤` over `≥`. Second, we have used the `ring` tactic extensively. It
    is a real timesaver! Finally, notice that in the second line of the second `calc`
    proof, instead of writing `by exact add_le_add (le_refl _) h`, we can simply write
    the proof term `add_le_add (le_refl _) h`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib 倾向于在二进制运算符（如 `*` 和 `^`）周围放置空格，但在本例中，更紧凑的格式提高了可读性。有几个值得注意的地方。首先，表达式 `s
    ≥ t` 在定义上是等价于 `t ≤ s` 的。原则上，这意味着应该能够互换使用它们。但是 Lean 的一些自动化工具没有识别出这种等价性，因此 Mathlib
    倾向于更喜欢 `≤` 而不是 `≥`。其次，我们广泛使用了 `ring` 策略。这是一个真正的节省时间！最后，请注意，在第二个 `calc` 证明的第二行中，我们不需要写
    `by exact add_le_add (le_refl _) h`，我们可以简单地写出证明项 `add_le_add (le_refl _) h`。
- en: 'In fact, the only cleverness in the proof above is figuring out the hypothesis
    `h`. Once we have it, the second calculation involves only linear arithmetic,
    and `linarith` can handle it:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，上述证明中唯一的巧妙之处在于找出假设 `h`。一旦我们有了它，第二个计算只涉及线性代数，而 `linarith` 可以处理它：
- en: '[PRE49]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How nice! We challenge you to use these ideas to prove the following theorem.
    You can use the theorem `abs_le'.mpr`. You will also need the `constructor` tactic
    to split a conjunction to two goals; see [Section 3.4](C03_Logic.html#conjunction-and-biimplication).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 多么好！我们挑战你使用这些想法来证明以下定理。你可以使用定理 `abs_le'.mpr`。你还需要使用 `constructor` 策略将合取式拆分为两个目标；参见[第3.4节](C03_Logic.html#conjunction-and-biimplication)。
- en: '[PRE50]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If you managed to solve this, congratulations! You are well on your way to
    becoming a master formalizer.  ## 2.4\. More examples using apply and rw[](#more-examples-using-apply-and-rw
    "Link to this heading")'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你设法解决了这个问题，恭喜你！你正朝着成为一位大师级形式化专家的道路上迈进。  ## 2.4\. 使用 apply 和 rw 的更多示例[](#more-examples-using-apply-and-rw
    "链接到这个标题")'
- en: 'The `min` function on the real numbers is uniquely characterized by the following
    three facts:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 实数上的 `min` 函数由以下三个事实唯一确定：
- en: '[PRE51]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Can you guess the names of the theorems that characterize `max` in a similar
    way?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜出以类似方式描述 `max` 的定理的名称吗？
- en: Notice that we have to apply `min` to a pair of arguments `a` and `b` by writing
    `min a b` rather than `min (a, b)`. Formally, `min` is a function of type `ℝ →
    ℝ → ℝ`. When we write a type like this with multiple arrows, the convention is
    that the implicit parentheses associate to the right, so the type is interpreted
    as `ℝ → (ℝ → ℝ)`. The net effect is that if `a` and `b` have type `ℝ` then `min
    a` has type `ℝ → ℝ` and `min a b` has type `ℝ`, so `min` acts like a function
    of two arguments, as we expect. Handling multiple arguments in this way is known
    as *currying*, after the logician Haskell Curry.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须通过编写 `min a b` 而不是 `min (a, b)` 来将 `min` 应用到一对参数 `a` 和 `b`。形式上，`min`
    是一个类型为 `ℝ → ℝ → ℝ` 的函数。当我们用多个箭头写这样的类型时，约定是隐式括号向右结合，所以类型被解释为 `ℝ → (ℝ → ℝ)`。最终效果是，如果
    `a` 和 `b` 的类型是 `ℝ`，那么 `min a` 的类型是 `ℝ → ℝ`，`min a b` 的类型是 `ℝ`，所以 `min` 的行为就像一个有两个参数的函数，正如我们所期望的那样。以这种方式处理多个参数被称为
    *currying*，这是逻辑学家 Haskell Curry 的名字。
- en: The order of operations in Lean can also take some getting used to. Function
    application binds tighter than infix operations, so the expression `min a b +
    c` is interpreted as `(min a b) + c`. With time, these conventions will become
    second nature.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 中的运算顺序可能需要一些时间来习惯。函数应用比中缀操作绑定得更紧密，所以表达式 `min a b + c` 被解释为 `(min a b) +
    c`。随着时间的推移，这些约定将变得自然而然。
- en: 'Using the theorem `le_antisymm`, we can show that two real numbers are equal
    if each is less than or equal to the other. Using this and the facts above, we
    can show that `min` is commutative:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用定理 `le_antisymm`，我们可以证明如果每个数都小于或等于另一个数，那么两个实数是相等的。使用这个和上述事实，我们可以证明 `min` 是可交换的：
- en: '[PRE52]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here we have used dots to separate proofs of different goals. Our usage is
    inconsistent: at the outer level, we use dots and indentation for both goals,
    whereas for the nested proofs, we use dots only until a single goal remains. Both
    conventions are reasonable and useful. We also use the `show` tactic to structure
    the proof and indicate what is being proved in each block. The proof still works
    without the `show` commands, but using them makes the proof easier to read and
    maintain.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用点来分隔不同目标证明。我们的用法不一致：在外层，我们使用点和缩进来表示两个目标，而对于嵌套证明，我们只使用点直到只剩下一个目标。这两种约定都是合理且有用的。我们还使用
    `show` 策略来结构化证明并指示每个块中正在证明的内容。即使没有 `show` 命令，证明仍然有效，但使用它们可以使证明更容易阅读和维护。
- en: 'It may bother you that the proof is repetitive. To foreshadow skills you will
    learn later on, we note that one way to avoid the repetition is to state a local
    lemma and then use it:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得证明过程很重复。为了预示你以后将学习到的技能，我们注意到避免重复的一种方法就是陈述一个局部引理然后使用它：
- en: '[PRE53]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We will say more about the universal quantifier in [Section 3.1](C03_Logic.html#implication-and-the-universal-quantifier),
    but suffice it to say here that the hypothesis `h` says that the desired inequality
    holds for any `x` and `y`, and the `intro` tactic introduces an arbitrary `x`
    and `y` to establish the conclusion. The first `apply` after `le_antisymm` implicitly
    uses `h a b`, whereas the second one uses `h b a`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第 3.1 节](C03_Logic.html#implication-and-the-universal-quantifier) 中更多地讨论全称量词，但在这里只需说，假设
    `h` 表示对于任何 `x` 和 `y`，所期望的不等式都成立，而 `intro` 策略引入任意的 `x` 和 `y` 来建立结论。在 `le_antisymm`
    之后的第一个 `apply` 隐式地使用了 `h a b`，而第二个则使用了 `h b a`。
- en: Another solution is to use the `repeat` tactic, which applies a tactic (or a
    block) as many times as it can.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是使用 `repeat` 策略，它可以尽可能多次地应用策略（或一个块）。
- en: '[PRE54]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We encourage you to prove the following as exercises. You can use either of
    the tricks just described to shorten the first.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励你将以下内容作为练习来证明。你可以使用上面描述的任何一种技巧来缩短第一个证明。
- en: '[PRE55]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Of course, you are welcome to prove the associativity of `max` as well.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以尝试证明 `max` 的结合律。
- en: It is an interesting fact that `min` distributes over `max` the way that multiplication
    distributes over addition, and vice-versa. In other words, on the real numbers,
    we have the identity `min a (max b c) = max (min a b) (min a c)` as well as the
    corresponding version with `max` and `min` switched. But in the next section we
    will see that this does *not* follow from the transitivity and reflexivity of
    `≤` and the characterizing properties of `min` and `max` enumerated above. We
    need to use the fact that `≤` on the real numbers is a *total order*, which is
    to say, it satisfies `∀ x y, x ≤ y ∨ y ≤ x`. Here the disjunction symbol, `∨`,
    represents “or”. In the first case, we have `min x y = x`, and in the second case,
    we have `min x y = y`. We will learn how to reason by cases in [Section 3.5](C03_Logic.html#disjunction),
    but for now we will stick to examples that don’t require the case split.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的事实是 `min` 在 `max` 上分配的方式与乘法在加法上分配的方式相同，反之亦然。换句话说，在实数上，我们有恒等式 `min a (max
    b c) = max (min a b) (min a c)`，以及将 `max` 和 `min` 交换的对应版本。但在下一节中，我们将看到这并不从 `≤`
    的传递性和自反性以及上面列出的 `min` 和 `max` 的特征属性中得出。我们需要使用事实，即实数上的 `≤` 是一个 *全序*，也就是说，它满足 `∀
    x y, x ≤ y ∨ y ≤ x`。这里的析取符号 `∨` 代表“或”。在第一种情况下，我们有 `min x y = x`，在第二种情况下，我们有 `min
    x y = y`。我们将在 [第 3.5 节](C03_Logic.html#disjunction) 中学习如何进行情况推理，但到目前为止，我们将坚持不需要情况分解的例子。
- en: 'Here is one such example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个这样的例子：
- en: '[PRE56]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: It is clear that `aux` provides one of the two inequalities needed to prove
    the equality, but applying it to suitable values yields the other direction as
    well. As a hint, you can use the theorem `add_neg_cancel_right` and the `linarith`
    tactic.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`aux` 提供了证明等式所需的两个不等式之一，但将其应用于合适的值也会得到另一个方向。作为一个提示，你可以使用定理 `add_neg_cancel_right`
    和 `linarith` 策略。
- en: 'Lean’s naming convention is made manifest in the library’s name for the triangle
    inequality:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 的命名约定在库中三角不等式的名称中得到了体现：
- en: '[PRE57]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Use it to prove the following variant, using also `add_sub_cancel_right`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它来证明以下变体，同时使用 `add_sub_cancel_right`：
- en: '[PRE58]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: See if you can do this in three lines or less. You can use the theorem `sub_add_cancel`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能在三行或更少的代码中完成这个任务。你可以使用定理 `sub_add_cancel`。
- en: 'Another important relation that we will make use of in the sections to come
    is the divisibility relation on the natural numbers, `x ∣ y`. Be careful: the
    divisibility symbol is *not* the ordinary bar on your keyboard. Rather, it is
    a unicode character obtained by typing `\|` in VS Code. By convention, Mathlib
    uses `dvd` to refer to it in theorem names.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们还将使用的一个重要关系是自然数上的可除性关系，`x ∣ y`。请注意：可除性符号 *不是* 你键盘上的普通横线。相反，它是一个通过在
    VS Code 中输入 `\|` 获得的 unicode 字符。按照惯例，Mathlib 在定理名称中使用 `dvd` 来指代它。
- en: '[PRE59]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the last example, the exponent is a natural number, and applying `dvd_mul_left`
    forces Lean to expand the definition of `x^2` to `x^1 * x`. See if you can guess
    the names of the theorems you need to prove the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个例子中，指数是一个自然数，应用 `dvd_mul_left` 强制 Lean 展开定义 `x^2` 为 `x^1 * x`。看看你是否能猜出你需要证明以下定理的名称：
- en: '[PRE60]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'With respect to divisibility, the *greatest common divisor*, `gcd`, and least
    common multiple, `lcm`, are analogous to `min` and `max`. Since every number divides
    `0`, `0` is really the greatest element with respect to divisibility:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 关于可除性，*最大公约数* `gcd` 和最小公倍数 `lcm` 与 `min` 和 `max` 类似。由于每个数都能整除 `0`，所以 `0` 真的是可除性关系中的最大元素：
- en: '[PRE61]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'See if you can guess the names of the theorems you will need to prove the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能猜出你需要证明以下定理的名称：
- en: '[PRE62]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Hint: you can use `dvd_antisymm`, but if you do, Lean will complain that the
    expression is ambiguous between the generic theorem and the version `Nat.dvd_antisymm`,
    the one specifically for the natural numbers. You can use `_root_.dvd_antisymm`
    to specify the generic one; either one will work.  ## 2.5\. Proving Facts about
    Algebraic Structures[](#proving-facts-about-algebraic-structures "Link to this
    heading")'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：你可以使用 `dvd_antisymm`，但如果你这样做，Lean 会抱怨表达式在通用定理和版本 `Nat.dvd_antisymm`（专门针对自然数的版本）之间是模糊的。你可以使用
    `_root_.dvd_antisymm` 来指定通用版本；两者都可以工作。
- en: 'In [Section 2.2](#proving-identities-in-algebraic-structures), we saw that
    many common identities governing the real numbers hold in more general classes
    of algebraic structures, such as commutative rings. We can use any axioms we want
    to describe an algebraic structure, not just equations. For example, a *partial
    order* consists of a set with a binary relation that is reflexive, transitive,
    and antisymmetric. like `≤` on the real numbers. Lean knows about partial orders:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第2.2节](#proving-identities-in-algebraic-structures) 中，我们看到了许多常见的关于实数的恒等式在更一般的代数结构中成立，例如交换环。我们可以使用任何我们想要的公理来描述代数结构，而不仅仅是方程。例如，一个
    *偏序* 由一个集合和一个二元关系组成，该关系是自反的、传递的和反对称的，类似于实数上的 `≤`。Lean了解偏序：
- en: '[PRE63]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here we are adopting the Mathlib convention of using letters like `α`, `β`,
    and `γ` (entered as `\a`, `\b`, and `\g`) for arbitrary types. The library often
    uses letters like `R` and `G` for the carriers of algebraic structures like rings
    and groups, respectively, but in general Greek letters are used for types, especially
    when there is little or no structure associated with them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们采用Mathlib的约定，使用像 `α`、`β` 和 `γ`（输入为 `\a`、`\b` 和 `\g`）这样的字母表示任意类型。该库通常使用像
    `R` 和 `G` 这样的字母表示代数结构如环和群的载体，但通常在几乎没有与之关联的结构时使用希腊字母表示类型。
- en: Associated to any partial order, `≤`, there is also a *strict partial order*,
    `<`, which acts somewhat like `<` on the real numbers. Saying that `x` is less
    than `y` in this order is equivalent to saying that it is less-than-or-equal to
    `y` and not equal to `y`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何偏序 `≤` 相关联的，还有一个 *严格偏序* `<`，它在某种程度上类似于实数中的 `<`。在这个顺序中说 `x` 小于 `y` 等价于说它小于或等于
    `y` 但不等于 `y`。
- en: '[PRE64]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In this example, the symbol `∧` stands for “and,” the symbol `¬` stands for
    “not,” and `x ≠ y` abbreviates `¬ (x = y)`. In [Chapter 3](C03_Logic.html#logic),
    you will learn how to use these logical connectives to *prove* that `<` has the
    properties indicated.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，符号 `∧` 代表“和”，符号 `¬` 代表“非”，`x ≠ y` 简写为 `¬ (x = y)`。在 [第3章](C03_Logic.html#logic)
    中，您将学习如何使用这些逻辑连接词来 *证明* `<` 具有指示的性质。
- en: 'A *lattice* is a structure that extends a partial order with operations `⊓`
    and `⊔` that are analogous to `min` and `max` on the real numbers:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *拉丁格* 是一个扩展了偏序并带有 `⊓` 和 `⊔` 操作的结构，这些操作类似于实数上的 `min` 和 `max`：
- en: '[PRE65]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The characterizations of `⊓` and `⊔` justify calling them the *greatest lower
    bound* and *least upper bound*, respectively. You can type them in VS code using
    `\glb` and `\lub`. The symbols are also often called then *infimum* and the *supremum*,
    and Mathlib refers to them as `inf` and `sup` in theorem names. To further complicate
    matters, they are also often called *meet* and *join*. Therefore, if you work
    with lattices, you have to keep the following dictionary in mind:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`⊓` 和 `⊔` 的特征使得可以称它们分别为 *最大下界* 和 *最小上界*。您可以在VS code中使用 `\glb` 和 `\lub` 来输入它们。这些符号也常被称为
    *下确界* 和 *上确界*，Mathlib在定理名称中称它们为 `inf` 和 `sup`。为了进一步复杂化问题，它们也常被称为 *交* 和 *并*。因此，如果您与拉丁格一起工作，您必须记住以下字典：'
- en: '`⊓` is the *greatest lower bound*, *infimum*, or *meet*.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`⊓` 是 *最大下界*、*下确界* 或 *交*。'
- en: '`⊔` is the *least upper bound*, *supremum*, or *join*.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`⊔` 是 *最小上界*、*上确界* 或 *并*。'
- en: 'Some instances of lattices include:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 拉丁格的一些实例包括：
- en: '`min` and `max` on any total order, such as the integers or real numbers with
    `≤`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何全序，如整数或实数上的 `≤`
- en: '`∩` and `∪` on the collection of subsets of some domain, with the ordering
    `⊆`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某个域的子集集合上的 `∩` 和 `∪`，具有排序 `⊆`
- en: '`∧` and `∨` on boolean truth values, with ordering `x ≤ y` if either `x` is
    false or `y` is true'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在布尔真值上的 `∧` 和 `∨`，其中排序 `x ≤ y` 当且仅当 `x` 为假或 `y` 为真
- en: '`gcd` and `lcm` on the natural numbers (or positive natural numbers), with
    the divisibility ordering, `∣`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcd` 和 `lcm` 在自然数（或正自然数）上，具有可除性排序 `∣`'
- en: the collection of linear subspaces of a vector space, where the greatest lower
    bound is given by the intersection, the least upper bound is given by the sum
    of the two spaces, and the ordering is inclusion
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量空间线性子空间的集合，其中最大下界由交集给出，最小上界由两个空间的和给出，排序是包含关系
- en: the collection of topologies on a set (or, in Lean, a type), where the greatest
    lower bound of two topologies consists of the topology that is generated by their
    union, the least upper bound is their intersection, and the ordering is reverse
    inclusion
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个集合（或在Lean中，一个类型）上的拓扑集合，其中两个拓扑的最小下界是由它们的并集生成的拓扑，最小上界是它们的交集，且排序是反向包含
- en: You can check that, as with `min` / `max` and `gcd` / `lcm`, you can prove the
    commutativity and associativity of the infimum and supremum using only their characterizing
    axioms, together with `le_refl` and `le_trans`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以检查，就像`min`/`max`和`gcd`/`lcm`一样，你可以仅使用它们的特征公理以及`le_refl`和`le_trans`来证明下确界和上确界的交换性和结合性。
- en: Using `apply le_trans` when seeing a goal `x ≤ z` is not a great idea. Indeed
    Lean has no way to guess which intermediate element `y` we want to use. So `apply
    le_trans` produces three goals that look like `x ≤ ?a`, `?a ≤ z` and `α` where
    `?a` (probably with a more complicated auto-generated name) stands for the mysterious
    `y`. The last goal, with type `α`, is to provide the value of `y`. It comes lasts
    because Lean hopes to automatically infer it from the proof of the first goal
    `x ≤ ?a`. In order to avoid this unappealing situation, you can use the `calc`
    tactic to explicitly provide `y`. Alternatively, you can use the `trans` tactic
    which takes `y` as an argument and produces the expected goals `x ≤ y` and `y
    ≤ z`. Of course you can also avoid this issue by providing directly a full proof
    such as `exact le_trans inf_le_left inf_le_right`, but this requires a lot more
    planning.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当看到目标`x ≤ z`时使用`apply le_trans`不是一个好主意。实际上，Lean没有方法猜测我们想要使用哪个中间元素`y`。因此，`apply
    le_trans`会产生三个看起来像`x ≤ ?a`、`?a ≤ z`和`α`的目标，其中`?a`（可能有一个更复杂的自动生成的名称）代表神秘的`y`。最后一个目标，类型为`α`，是提供`y`的值。它最后出现，因为Lean希望从第一个目标`x
    ≤ ?a`的证明中自动推断它。为了避免这种不吸引人的情况，你可以使用`calc`策略显式地提供`y`。或者，你可以使用`trans`策略，它将`y`作为参数，并产生预期的目标`x
    ≤ y`和`y ≤ z`。当然，你也可以通过直接提供一个完整的证明来避免这个问题，例如`exact le_trans inf_le_left inf_le_right`，但这需要更多的计划。
- en: '[PRE66]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You can find these theorems in the Mathlib as `inf_comm`, `inf_assoc`, `sup_comm`,
    and `sup_assoc`, respectively.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Mathlib中找到这些定理，分别命名为`inf_comm`、`inf_assoc`、`sup_comm`和`sup_assoc`。
- en: 'Another good exercise is to prove the *absorption laws* using only those axioms:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的练习是仅使用那些公理来证明**吸收律**：
- en: '[PRE67]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: These can be found in Mathlib with the names `inf_sup_self` and `sup_inf_self`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以在Mathlib中以`inf_sup_self`和`sup_inf_self`的名称找到。
- en: 'A lattice that satisfies the additional identities `x ⊓ (y ⊔ z) = (x ⊓ y) ⊔
    (x ⊓ z)` and `x ⊔ (y ⊓ z) = (x ⊔ y) ⊓ (x ⊔ z)` is called a *distributive lattice*.
    Lean knows about these too:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 满足额外的恒等式`x ⊓ (y ⊔ z) = (x ⊓ y) ⊔ (x ⊓ z)`和`x ⊔ (y ⊓ z) = (x ⊔ y) ⊓ (x ⊔ z)`的格称为**分配格**。Lean也知道这些：
- en: '[PRE68]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The left and right versions are easily shown to be equivalent, given the commutativity
    of `⊓` and `⊔`. It is a good exercise to show that not every lattice is distributive
    by providing an explicit description of a nondistributive lattice with finitely
    many elements. It is also a good exercise to show that in any lattice, either
    distributivity law implies the other:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在`⊓`和`⊔`的交换性给定的情况下，左右版本很容易被证明是等价的。通过提供一个非分配格的显式描述，其中包含有限多个元素，来证明并非每个格都是分配的，这是一个很好的练习。同样，证明在任何格中，分配律中的一个蕴含另一个也是一个很好的练习：
- en: '[PRE69]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'It is possible to combine axiomatic structures into larger ones. For example,
    a *strict ordered ring* consists of a ring together with a partial order on the
    carrier satisfying additional axioms that say that the ring operations are compatible
    with the order:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将公理结构组合成更大的结构。例如，一个**严格有序环**由一个环及其载体上的偏序组成，该偏序满足额外的公理，这些公理说明环运算与顺序是兼容的：
- en: '[PRE70]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[Chapter 3](C03_Logic.html#logic) will provide the means to derive the following
    from `mul_pos` and the definition of `<`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](C03_Logic.html#logic)将提供从`mul_pos`和`<`的定义中推导以下内容的方法：'
- en: '[PRE71]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'It is then an extended exercise to show that many common facts used to reason
    about arithmetic and the ordering on the real numbers hold generically for any
    ordered ring. Here are a couple of examples you can try, using only properties
    of rings, partial orders, and the facts enumerated in the last two examples (beware
    that those rings are not assumed to be commutative, so the ring tactic is not
    available):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是一个扩展练习，即证明许多用于推理算术和实数顺序的常见事实对于任何有序环都是通用的。这里有一些你可以尝试的例子，仅使用环、偏序以及最后两个例子中列出的事实（注意，这些环不假设是交换的，因此没有环策略）：
- en: '[PRE72]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Finally, here is one last example. A *metric space* consists of a set equipped
    with a notion of distance, `dist x y`, mapping any pair of elements to a real
    number. The distance function is assumed to satisfy the following axioms:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里有一个最后的例子。一个**度量空间**由一个集合和一个距离概念`dist x y`组成，该距离将任何一对元素映射到一个实数。距离函数假设满足以下公理：
- en: '[PRE73]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Having mastered this section, you can show that it follows from these axioms
    that distances are always nonnegative:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握这一部分后，你可以证明以下公理意味着距离总是非负的：
- en: '[PRE74]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We recommend making use of the theorem `nonneg_of_mul_nonneg_left`. As you may
    have guessed, this theorem is called `dist_nonneg` in Mathlib. [Previous](C01_Introduction.html
    "1\. Introduction") [Next](C03_Logic.html "3\. Logic")
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推荐使用定理 `nonneg_of_mul_nonneg_left`。正如你可能猜到的，这个定理在 Mathlib 中被称为 `dist_nonneg`。[上一节](C01_Introduction.html
    "1. 简介") [下一节](C03_Logic.html "3. 逻辑")
- en: '* * *'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: © Copyright 2020-2025, Jeremy Avigad, Patrick Massot. Text licensed under CC
    BY 4.0.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: © 版权 2020-2025，Jeremy Avigad，Patrick Massot。文本许可协议为 CC BY 4.0。
- en: 'Built with [Sphinx](https://www.sphinx-doc.org/) using a [theme](https://github.com/readthedocs/sphinx_rtd_theme)
    provided by [Read the Docs](https://readthedocs.org). This chapter is designed
    to introduce you to the nuts and bolts of mathematical reasoning in Lean: calculating,
    applying lemmas and theorems, and reasoning about generic structures.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [Sphinx](https://www.sphinx-doc.org/) 和由 [Read the Docs](https://readthedocs.org)
    提供的 [主题](https://github.com/readthedocs/sphinx_rtd_theme) 构建。本章旨在向您介绍 Lean 中数学推理的精髓：计算、应用引理和定理，以及关于通用结构的推理。
- en: 2.1\. Calculating[](#calculating "Link to this heading")
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1. 计算[](#calculating "链接到这个标题")
- en: We generally learn to carry out mathematical calculations without thinking of
    them as proofs. But when we justify each step in a calculation, as Lean requires
    us to do, the net result is a proof that the left-hand side of the calculation
    is equal to the right-hand side.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常学习进行数学计算，而不把它们当作证明。但当我们像 Lean 所要求的那样证明计算的每一步，最终结果是证明计算的左边等于右边。
- en: In Lean, stating a theorem is tantamount to stating a goal, namely, the goal
    of proving the theorem. Lean provides the rewriting tactic `rw`, to replace the
    left-hand side of an identity by the right-hand side in the goal. If `a`, `b`,
    and `c` are real numbers, `mul_assoc a b c` is the identity `a * b * c = a * (b
    * c)` and `mul_comm a b` is the identity `a * b = b * a`. Lean provides automation
    that generally eliminates the need to refer the facts like these explicitly, but
    they are useful for the purposes of illustration. In Lean, multiplication associates
    to the left, so the left-hand side of `mul_assoc` could also be written `(a *
    b) * c`. However, it is generally good style to be mindful of Lean’s notational
    conventions and leave out parentheses when Lean does as well.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lean 中，陈述一个定理等同于陈述一个目标，即证明该定理的目标。Lean 提供了重写策略 `rw`，在目标中将等式的左边替换为右边。如果 `a`、`b`
    和 `c` 是实数，`mul_assoc a b c` 是等式 `a * b * c = a * (b * c)`，而 `mul_comm a b` 是等式
    `a * b = b * a`。Lean 提供了自动化，通常可以消除明确引用此类事实的需要，但它们对于说明目的很有用。在 Lean 中，乘法从左结合，因此
    `mul_assoc` 的左边也可以写成 `(a * b) * c`。然而，通常来说，注意 Lean 的符号约定并省略括号是好的风格。
- en: Let’s try out `rw`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下 `rw`。
- en: '[PRE75]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `import` lines at the beginning of the associated examples file import the
    theory of the real numbers from Mathlib, as well as useful automation. For the
    sake of brevity, we generally suppress information like this in the textbook.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在相关示例文件的开始部分，`import` 行从 Mathlib 导入实数理论以及有用的自动化。为了简洁起见，我们在教科书中通常省略此类信息。
- en: 'You are welcome to make changes to see what happens. You can type the `ℝ` character
    as `\R` or `\real` in VS Code. The symbol doesn’t appear until you hit space or
    the tab key. If you hover over a symbol when reading a Lean file, VS Code will
    show you the syntax that can be used to enter it. If you are curious to see all
    available abbreviations, you can hit Ctrl-Shift-P and then type abbreviations
    to get access to the `Lean 4: Show Unicode Input Abbreviations` command. If your
    keyboard does not have an easily accessible backslash, you can change the leading
    character by changing the `lean4.input.leader` setting.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以随意修改以查看会发生什么。在 VS Code 中，你可以将 `ℝ` 字符键入为 `\R` 或 `\real`。符号只有在按下空格键或制表键后才会出现。当你阅读
    Lean 文件时，将鼠标悬停在符号上，VS Code 将显示可以用来输入它的语法。如果你好奇想查看所有可用的缩写，你可以按 Ctrl-Shift-P，然后键入缩写以访问
    `Lean 4: 显示 Unicode 输入缩写` 命令。如果你的键盘上没有容易访问的反斜杠，你可以通过更改 `lean4.input.leader` 设置来更改前导字符。'
- en: 'When a cursor is in the middle of a tactic proof, Lean reports on the current
    *proof state* in the *Lean Infoview* window. As you move your cursor past each
    step of the proof, you can see the state change. A typical proof state in Lean
    might look as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当光标在策略证明的中间时，Lean在*Lean Infoview*窗口中报告当前的*证明状态*。当你将光标移过证明的每一步时，你可以看到状态的变化。Lean中的一个典型证明状态可能如下所示：
- en: '[PRE76]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The lines before the one that begins with `⊢` denote the *context*: they are
    the objects and assumptions currently at play. In this example, these include
    two objects, `x` and `y`, each a natural number. They also include three assumptions,
    labelled `h₁`, `h₂`, and `h₃`. In Lean, everything in a context is labelled with
    an identifier. You can type these subscripted labels as `h\1`, `h\2`, and `h\3`,
    but any legal identifiers would do: you can use `h1`, `h2`, `h3` instead, or `foo`,
    `bar`, and `baz`. The last line represents the *goal*, that is, the fact to be
    proved. Sometimes people use *target* for the fact to be proved, and *goal* for
    the combination of the context and the target. In practice, the intended meaning
    is usually clear.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在以`⊢`开始的行之前的行表示*上下文*：它们是当前正在使用的对象和假设。在这个例子中，这些包括两个对象，`x`和`y`，每个都是自然数。它们还包括三个假设，标记为`h₁`、`h₂`和`h₃`。在Lean中，上下文中的所有内容都用标识符标记。你可以输入这些带下标的标签作为`h\1`、`h\2`和`h\3`，但任何合法的标识符都可以：你可以使用`h1`、`h2`、`h3`代替，或者`foo`、`bar`和`baz`。最后一行代表*目标*，即要证明的事实。有时人们用*目标*来表示要证明的事实，用*目标*来表示上下文和目标的组合。在实践中，通常可以清楚地理解意图的含义。
- en: Try proving these identities, in each case replacing `sorry` by a tactic proof.
    With the `rw` tactic, you can use a left arrow (`\l`) to reverse an identity.
    For example, `rw [← mul_assoc a b c]` replaces `a * (b * c)` by `a * b * c` in
    the current goal. Note that the left-pointing arrow refers to going from right
    to left in the identity provided by `mul_assoc`, it has nothing to do with the
    left or right side of the goal.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试证明这些恒等式，在每种情况下用策略证明替换`sorry`。使用`rw`策略，你可以使用左箭头（`\l`）来反转一个恒等式。例如，`rw [← mul_assoc
    a b c]`将当前目标中的`a * (b * c)`替换为`a * b * c`。注意，指向左边的箭头指的是从右到左在`mul_assoc`提供的恒等式中移动，它与目标左右两侧无关。
- en: '[PRE77]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You can also use identities like `mul_assoc` and `mul_comm` without arguments.
    In this case, the rewrite tactic tries to match the left-hand side with an expression
    in the goal, using the first pattern it finds.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在不提供参数的情况下使用像`mul_assoc`和`mul_comm`这样的恒等式。在这种情况下，重写策略尝试将目标左边的表达式与目标中的表达式匹配，使用它找到的第一个模式。
- en: '[PRE78]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: You can also provide *partial* information. For example, `mul_comm a` matches
    any pattern of the form `a * ?` and rewrites it to `? * a`. Try doing the first
    of these examples without providing any arguments at all, and the second with
    only one argument.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以提供*部分*信息。例如，`mul_comm a`与形式为`a * ?`的任何模式匹配，并将其重写为`? * a`。尝试在不提供任何参数的情况下执行这些示例中的第一个，以及在只有一个参数的情况下执行第二个。
- en: '[PRE79]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: You can also use `rw` with facts from the local context.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用来自本地上下文的事实与`rw`结合。
- en: '[PRE80]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Try these, using the theorem `sub_self` for the second one:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些，对于第二个使用定理`sub_self`：
- en: '[PRE81]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Multiple rewrite commands can be carried out with a single command, by listing
    the relevant identities separated by commas inside the square brackets.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在方括号内用逗号分隔的相关身份来执行多个重写命令。
- en: '[PRE82]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: You still see the incremental progress by placing the cursor after a comma in
    any list of rewrites.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以通过在任何重写列表中将光标放在逗号之后来看到增量进步。
- en: Another trick is that we can declare variables once and for all outside an example
    or theorem. Lean then includes them automatically.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个技巧是，我们可以在示例或定理之外一次性声明变量。然后Lean会自动包含它们。
- en: '[PRE83]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Inspection of the tactic state at the beginning of the above proof reveals
    that Lean indeed included all variables. We can delimit the scope of the declaration
    by putting it in a `section ... end` block. Finally, recall from the introduction
    that Lean provides us with a command to determine the type of an expression:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 检查上述证明开始时的策略状态，可以发现Lean确实包含了所有变量。我们可以通过将其放在`section ... end`块中来限定声明的范围。最后，从介绍中回忆起Lean为我们提供了一个命令来确定表达式的类型：
- en: '[PRE84]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `#check` command works for both objects and facts. In response to the command
    `#check a`, Lean reports that `a` has type `ℝ`. In response to the command `#check
    mul_comm a b`, Lean reports that `mul_comm a b` is a proof of the fact `a * b
    = b * a`. The command `#check (a : ℝ)` states our expectation that the type of
    `a` is `ℝ`, and Lean will raise an error if that is not the case. We will explain
    the output of the last three `#check` commands later, but in the meanwhile, you
    can take a look at them, and experiment with some `#check` commands of your own.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`#check` 命令适用于对象和事实。对于 `#check a` 命令，Lean 报告 `a` 的类型为 `ℝ`。对于 `#check mul_comm
    a b` 命令，Lean 报告 `mul_comm a b` 是事实 `a * b = b * a` 的证明。命令 `#check (a : ℝ)` 表明我们期望
    `a` 的类型是 `ℝ`，如果这不是情况，Lean 将引发错误。我们将在稍后解释最后三个 `#check` 命令的输出，但在此同时，您可以查看它们，并尝试一些自己的
    `#check` 命令。'
- en: Let’s try some more examples. The theorem `two_mul a` says that `2 * a = a +
    a`. The theorems `add_mul` and `mul_add` express the distributivity of multiplication
    over addition, and the theorem `add_assoc` expresses the associativity of addition.
    Use the `#check` command to see the precise statements.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些更多的例子。定理 `two_mul a` 表明 `2 * a = a + a`。定理 `add_mul` 和 `mul_add` 表达了乘法对加法的分配律，而定理
    `add_assoc` 表达了加法的结合律。使用 `#check` 命令来查看精确的陈述。
- en: '[PRE85]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Whereas it is possible to figure out what is going on in this proof by stepping
    through it in the editor, it is hard to read on its own. Lean provides a more
    structured way of writing proofs like this using the `calc` keyword.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以通过在编辑器中逐步执行来弄清楚这个证明的情况，但单独阅读起来很困难。Lean 提供了一种更结构化的方式来编写这样的证明，使用 `calc` 关键字。
- en: '[PRE86]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Notice that the proof does *not* begin with `by`: an expression that begins
    with `calc` is a *proof term*. A `calc` expression can also be used inside a tactic
    proof, but Lean interprets it as the instruction to use the resulting proof term
    to solve the goal. The `calc` syntax is finicky: the underscores and justification
    have to be in the format indicated above. Lean uses indentation to determine things
    like where a block of tactics or a `calc` block begins and ends; try changing
    the indentation in the proof above to see what happens.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，证明并不以 `by` 开头：以 `calc` 开头的表达式是一个 *证明项*。`calc` 表达式也可以用在策略证明中，但 Lean 将其解释为使用生成的证明项来解决目标的指令。`calc`
    语法很挑剔：下划线和论证必须采用上述格式。Lean 使用缩进来确定诸如策略块或 `calc` 块的开始和结束位置；尝试更改上述证明中的缩进以查看会发生什么。
- en: One way to write a `calc` proof is to outline it first using the `sorry` tactic
    for justification, make sure Lean accepts the expression modulo these, and then
    justify the individual steps using tactics.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 写一个 `calc` 证明的一种方法首先是用 `sorry` 策略进行论证，确保 Lean 接受这些表达式模这些，然后使用策略来论证各个步骤。
- en: '[PRE87]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Try proving the following identity using both a pure `rw` proof and a more
    structured `calc` proof:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用纯 `rw` 证明和更结构化的 `calc` 证明来证明以下恒等式：
- en: '[PRE88]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The following exercise is a little more challenging. You can use the theorems
    listed underneath.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习稍微有些挑战性。您可以使用下面列出的定理。
- en: '[PRE89]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We can also perform rewriting in an assumption in the context. For example,
    `rw [mul_comm a b] at hyp` replaces `a * b` by `b * a` in the assumption `hyp`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在假设的上下文中进行重写。例如，`rw [mul_comm a b] at hyp` 将假设 `hyp` 中的 `a * b` 替换为 `b
    * a`。
- en: '[PRE90]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: In the last step, the `exact` tactic can use `hyp` to solve the goal because
    at that point `hyp` matches the goal exactly.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，`exact` 策略可以使用 `hyp` 来解决目标，因为此时 `hyp` 与目标完全匹配。
- en: We close this section by noting that Mathlib provides a useful bit of automation
    with a `ring` tactic, which is designed to prove identities in any commutative
    ring as long as they follow purely from the ring axioms, without using any local
    assumption.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过指出 Mathlib 提供了一个有用的自动化功能，即 `ring` 策略，该策略旨在证明任何交换环中的恒等式，只要它们纯粹从环公理中得出，而不使用任何局部假设，来结束本节。
- en: '[PRE91]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The `ring` tactic is imported indirectly when we import `Mathlib.Data.Real.Basic`,
    but we will see in the next section that it can be used for calculations on structures
    other than the real numbers. It can be imported explicitly with the command `import
    Mathlib.Tactic`. We will see there are similar tactics for other common kind of
    algebraic structures.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们导入 `Mathlib.Data.Real.Basic` 时，`ring` 策略是间接导入的，但我们在下一节将看到它可以用作对除了实数以外的结构进行计算。可以使用命令
    `import Mathlib.Tactic` 明确导入。我们将看到有类似策略用于其他常见的代数结构。
- en: There is a variation of `rw` called `nth_rw` that allows you to replace only
    particular instances of an expression in the goal. Possible matches are enumerated
    starting with 1, so in the following example, `nth_rw 2 [h]` replaces the second
    occurrence of `a + b` with `c`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种 `rw` 的变体称为 `nth_rw`，它允许你只替换目标中特定实例的表达式。可能的匹配从 1 开始枚举，所以在这个例子中，`nth_rw 2
    [h]` 将 `a + b` 的第二个出现替换为 `c`。
- en: '[PRE92]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '## 2.2\. Proving Identities in Algebraic Structures[](#proving-identities-in-algebraic-structures
    "Link to this heading")'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '## 2.2\. 在代数结构中证明恒等式[](#proving-identities-in-algebraic-structures "链接到本标题")'
- en: 'Mathematically, a ring consists of a collection of objects, \(R\), operations
    \(+\) \(\times\), and constants \(0\) and \(1\), and an operation \(x \mapsto
    -x\) such that:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，一个环由一组对象 \(R\)、运算 \(+\) 和 \(\times\)、常数 \(0\) 和 \(1\) 以及一个运算 \(x \mapsto
    -x\) 组成，该运算满足以下条件：
- en: \(R\) with \(+\) is an *abelian group*, with \(0\) as the additive identity
    and negation as inverse.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(R\) 与 \(+\) 是一个 *阿贝尔群*，其中 \(0\) 是加法单位元，负号是逆元。
- en: Multiplication is associative with identity \(1\), and multiplication distributes
    over addition.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法与单位元 \(1\) 结合，并且乘法对加法分配。
- en: 'In Lean, the collection of objects is represented as a *type*, `R`. The ring
    axioms are as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lean 中，对象的集合被表示为一个 *类型*，`R`。环的公理如下：
- en: '[PRE93]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: You will learn more about the square brackets in the first line later, but for
    the time being, suffice it to say that the declaration gives us a type, `R`, and
    a ring structure on `R`. Lean then allows us to use generic ring notation with
    elements of `R`, and to make use of a library of theorems about rings.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在以后学习到第一行中方括号的作用，但在此阶段，只需说这个声明给我们一个类型 `R` 和 `R` 上的环结构即可。Lean 然后允许我们使用 `R`
    的元素进行通用的环符号表示，并利用关于环的定理库。
- en: 'The names of some of the theorems should look familiar: they are exactly the
    ones we used to calculate with the real numbers in the last section. Lean is good
    not only for proving things about concrete mathematical structures like the natural
    numbers and the integers, but also for proving things about abstract structures,
    characterized axiomatically, like rings. Moreover, Lean supports *generic reasoning*
    about both abstract and concrete structures, and can be trained to recognize appropriate
    instances. So any theorem about rings can be applied to concrete rings like the
    integers, `ℤ`, the rational numbers, `ℚ`, and the complex numbers `ℂ`. It can
    also be applied to any instance of an abstract structure that extends rings, such
    as any ordered ring or any field.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 一些定理的名称应该看起来很熟悉：它们正是我们在上一节中使用实数进行计算时用到的那些。Lean 不仅擅长证明关于自然数和整数等具体数学结构的性质，而且擅长证明关于抽象结构（如环）的性质。此外，Lean
    支持关于抽象和具体结构的 *通用推理*，并且可以训练它识别适当的实例。因此，任何关于环的定理都可以应用于具体的环，如整数环 `ℤ`、有理数环 `ℚ` 和复数环
    `ℂ`。它也可以应用于任何扩展环的抽象结构的实例，例如任何有序环或任何域。
- en: Not all important properties of the real numbers hold in an arbitrary ring,
    however. For example, multiplication on the real numbers is commutative, but that
    does not hold in general. If you have taken a course in linear algebra, you will
    recognize that, for every \(n\), the \(n\) by \(n\) matrices of real numbers form
    a ring in which commutativity usually fails. If we declare `R` to be a *commutative*
    ring, in fact, all the theorems in the last section continue to hold when we replace
    `ℝ` by `R`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有实数的性质在任意环中都成立。例如，实数上的乘法是交换的，但这一点在一般情况下并不成立。如果你已经学过线性代数课程，你会认识到，对于每一个
    \(n\)，实数的 \(n\) 阶矩阵形成一个环，其中交换律通常不成立。如果我们声明 `R` 为一个 *交换* 环，实际上，当我们将 `ℝ` 替换为 `R`
    时，上一节中所有定理仍然成立。
- en: '[PRE94]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We leave it to you to check that all the other proofs go through unchanged.
    Notice that when a proof is short, like `by ring` or `by linarith` or `by sorry`,
    it is common (and permissible) to put it on the same line as the `by`. Good proof-writing
    style should strike a balance between concision and readability.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们留给你们去检查其他所有证明是否保持不变。注意，当证明很短，如 `by ring` 或 `by linarith` 或 `by sorry` 时，将其放在
    `by` 的同一行上是常见（且允许）的。良好的证明风格应该在简洁性和可读性之间取得平衡。
- en: The goal of this section is to strengthen the skills you have developed in the
    last section and apply them to reasoning axiomatically about rings. We will start
    with the axioms listed above, and use them to derive other facts. Most of the
    facts we prove are already in Mathlib. We will give the versions we prove the
    same names to help you learn the contents of the library as well as the naming
    conventions.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是加强你在上一节中发展的技能，并将它们应用于对环进行公理推理。我们将从上面列出的公理开始，并使用它们来推导其他事实。我们证明的大多数事实已经在Mathlib中。我们将给出我们证明的版本相同的名称，以帮助你学习库的内容以及命名约定。
- en: 'Lean provides an organizational mechanism similar to those used in programming
    languages: when a definition or theorem `foo` is introduced in a *namespace* `bar`,
    its full name is `bar.foo`. The command `open bar` later *opens* the namespace,
    which allows us to use the shorter name `foo`. To avoid errors due to name clashes,
    in the next example we put our versions of the library theorems in a new namespace
    called `MyRing.`'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Lean提供了一种类似于编程语言中使用的组织机制：当一个定义或定理`foo`在*命名空间*`bar`中引入时，它的全名是`bar.foo`。命令`open
    bar`稍后*打开*命名空间，这允许我们使用较短的名称`foo`。为了避免由于名称冲突而引起的错误，在下一个例子中，我们将我们的库定理版本放在一个新的命名空间`MyRing`中。
- en: The next example shows that we do not need `add_zero` or `add_neg_cancel` as
    ring axioms, because they follow from the other axioms.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 下一例子表明，我们不需要`add_zero`或`add_neg_cancel`作为环公理，因为它们可以从其他公理中得出。
- en: '[PRE95]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The net effect is that we can temporarily reprove a theorem in the library,
    and then go on using the library version after that. But don’t cheat! In the exercises
    that follow, take care to use only the general facts about rings that we have
    proved earlier in this section.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的效果是，我们可以暂时重新证明库中的一个定理，然后继续使用库版本。但不要作弊！在接下来的练习中，请务必只使用我们在本节中之前已经证明过的关于环的一般事实。
- en: '(If you are paying careful attention, you may have noticed that we changed
    the round brackets in `(R : Type*)` for curly brackets in `{R : Type*}`. This
    declares `R` to be an *implicit argument*. We will explain what this means in
    a moment, but don’t worry about it in the meanwhile.)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '（如果你仔细观察，你可能已经注意到我们在`(R : Type*)`中使用了圆括号，而在`{R : Type*}`中使用了花括号。这表明`R`是一个*隐式参数*。我们稍后会解释这意味着什么，但在此期间请不要担心。）'
- en: 'Here is a useful theorem:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有用的定理：
- en: '[PRE96]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Prove the companion version:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 证明伴随版本：
- en: '[PRE97]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Use these to prove the following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些来证明以下内容：
- en: '[PRE98]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: With enough planning, you can do each of them with three rewrites.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的计划下，你可以用三次重写来完成每一个。
- en: 'We will now explain the use of the curly braces. Imagine you are in a situation
    where you have `a`, `b`, and `c` in your context, as well as a hypothesis `h :
    a + b = a + c`, and you would like to draw the conclusion `b = c`. In Lean, you
    can apply a theorem to hypotheses and facts just the same way that you can apply
    them to objects, so you might think that `add_left_cancel a b c h` is a proof
    of the fact `b = c`. But notice that explicitly writing `a`, `b`, and `c` is redundant,
    because the hypothesis `h` makes it clear that those are the objects we have in
    mind. In this case, typing a few extra characters is not onerous, but if we wanted
    to apply `add_left_cancel` to more complicated expressions, writing them would
    be tedious. In cases like these, Lean allows us to mark arguments as *implicit*,
    meaning that they are supposed to be left out and inferred by other means, such
    as later arguments and hypotheses. The curly brackets in `{a b c : R}` do exactly
    that. So, given the statement of the theorem above, the correct expression is
    simply `add_left_cancel h`.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '我们现在将解释花括号的使用。想象一下，你处于一个情境，其中你的上下文中有`a`、`b`和`c`，以及一个假设`h : a + b = a + c`，你想要得出结论`b
    = c`。在Lean中，你可以像对对象一样对假设和事实应用定理，所以你可能认为`add_left_cancel a b c h`是事实`b = c`的证明。但请注意，明确写出`a`、`b`和`c`是多余的，因为假设`h`清楚地表明了这些是我们心中的对象。在这种情况下，输入几个额外的字符并不麻烦，但如果我们要将`add_left_cancel`应用于更复杂的表达式，编写它们将会很繁琐。在这些情况下，Lean允许我们将参数标记为*隐式*，这意味着它们应该被省略，并通过其他方式推断，例如后续的参数和假设。`{a
    b c : R}`中的花括号正是这样做的。所以，给定上述定理的陈述，正确的表达式仅仅是`add_left_cancel h`。'
- en: To illustrate, let us show that `a * 0 = 0` follows from the ring axioms.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，让我们展示`a * 0 = 0`可以从环公理中得出。
- en: '[PRE99]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We have used a new trick! If you step through the proof, you can see what is
    going on. The `have` tactic introduces a new goal, `a * 0 + a * 0 = a * 0 + 0`,
    with the same context as the original goal. The fact that the next line is indented
    indicates that Lean is expecting a block of tactics that serves to prove this
    new goal. The indentation therefore promotes a modular style of proof: the indented
    subproof establishes the goal that was introduced by the `have`. After that, we
    are back to proving the original goal, except a new hypothesis `h` has been added:
    having proved it, we are now free to use it. At this point, the goal is exactly
    the result of `add_left_cancel h`.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个新技巧！如果你逐步查看证明，你可以看到发生了什么。`have` 策略引入了一个新的目标，`a * 0 + a * 0 = a * 0 +
    0`，与原始目标具有相同的环境。下一行缩进的事实表明 Lean 预期一个策略块，该块用于证明这个新目标。因此，缩进促进了模块化证明风格：缩进的子证明建立了由
    `have` 引入的目标。之后，我们回到证明原始目标，除了增加了一个新的假设 `h`：证明它之后，我们现在可以自由地使用它。此时，目标正好是 `add_left_cancel
    h` 的结果。
- en: We could equally well have closed the proof with `apply add_left_cancel h` or
    `exact add_left_cancel h`. The `exact` tactic takes as argument a proof term which
    completely proves the current goal, without creating any new goal. The `apply`
    tactic is a variant whose argument is not necessarily a complete proof. The missing
    pieces are either inferred automatically by Lean or become new goals to prove.
    While the `exact` tactic is technically redundant since it is strictly less powerful
    than `apply`, it makes proof scripts slightly clearer to human readers and easier
    to maintain when the library evolves.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们同样可以用 `apply add_left_cancel h` 或 `exact add_left_cancel h` 来结束证明。`exact`
    策略的参数是一个证明项，它完全证明了当前目标，而不创建任何新的目标。`apply` 策略是一个变体，其参数不一定是完整的证明。缺失的部分要么由 Lean 自动推断，要么成为需要证明的新目标。虽然
    `exact` 策略在技术上可能是多余的，因为它严格不如 `apply` 强大，但它使证明脚本对人类读者来说更清晰，并且在库演变时更容易维护。
- en: Remember that multiplication is not assumed to be commutative, so the following
    theorem also requires some work.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 记住乘法不一定假设是交换的，所以下面的定理也需要一些工作。
- en: '[PRE100]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: By now, you should also be able replace each `sorry` in the next exercise with
    a proof, still using only facts about rings that we have established in this section.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你也应该能够用证明来替换下一个练习中的每个 `sorry`，仍然只使用本节中我们建立的关于环的事实。
- en: '[PRE101]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We had to use the annotation `(-0 : R)` instead of `0` in the third theorem
    because without specifying `R` it is impossible for Lean to infer which `0` we
    have in mind, and by default it would be interpreted as a natural number.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '在第三个定理中，我们不得不使用注释 `(-0 : R)` 而不是 `0`，因为没有指定 `R`，Lean 就无法推断我们指的是哪个 `0`，默认情况下它会被解释为自然数。'
- en: In Lean, subtraction in a ring is provably equal to addition of the additive
    inverse.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lean 中，环中的减法可以证明等于加法上的相反数。
- en: '[PRE102]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'On the real numbers, it is *defined* that way:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在实数上，它是这样 *定义* 的：
- en: '[PRE103]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The proof term `rfl` is short for “reflexivity”. Presenting it as a proof of
    `a - b = a + -b` forces Lean to unfold the definition and recognize both sides
    as being the same. The `rfl` tactic does the same. This is an instance of what
    is known as a *definitional equality* in Lean’s underlying logic. This means that
    not only can one rewrite with `sub_eq_add_neg` to replace `a - b = a + -b`, but
    in some contexts, when dealing with the real numbers, you can use the two sides
    of the equation interchangeably. For example, you now have enough information
    to prove the theorem `self_sub` from the last section:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 证明项 `rfl` 是“自反性”的缩写。将其作为 `a - b = a + -b` 的证明，迫使 Lean 展开定义并识别出两边是相同的。`rfl` 策略做的是同样的事情。这是
    Lean 内在逻辑中所谓的 *定义等价* 的一个例子。这意味着不仅可以用 `sub_eq_add_neg` 重新编写以替换 `a - b = a + -b`，而且在某些上下文中，当处理实数时，你可以互换地使用方程的两边。例如，你现在有足够的信息来证明上一节中的定理
    `self_sub`：
- en: '[PRE104]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Show that you can prove this using `rw`, but if you replace the arbitrary ring
    `R` by the real numbers, you can also prove it using either `apply` or `exact`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 展示你可以使用 `rw` 来证明这一点，但如果将任意的环 `R` 替换为实数，你也可以使用 `apply` 或 `exact` 来证明它。
- en: 'Lean knows that `1 + 1 = 2` holds in any ring. With a bit of effort, you can
    use that to prove the theorem `two_mul` from the last section:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 知道 `1 + 1 = 2` 在任何环中都成立。通过一点努力，你可以用这个来证明上一节中的定理 `two_mul`：
- en: '[PRE105]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'We close this section by noting that some of the facts about addition and negation
    that we established above do not need the full strength of the ring axioms, or
    even commutativity of addition. The weaker notion of a *group* can be axiomatized
    as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过指出，我们上面建立的一些关于加法和否定的事实不需要环公理的全部力量，甚至不需要加法的交换性。一个更弱的概念的*群*可以如下公理化：
- en: '[PRE106]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: It is conventional to use additive notation when the group operation is commutative,
    and multiplicative notation otherwise. So Lean defines a multiplicative version
    as well as the additive version (and also their abelian variants, `AddCommGroup`
    and `CommGroup`).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当群运算交换时，使用加法符号是惯例，否则使用乘法符号。因此，Lean 定义了乘法版本以及加法版本（以及它们的阿贝尔变体，`AddCommGroup` 和
    `CommGroup`）。
- en: '[PRE107]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: If you are feeling cocky, try proving the following facts about groups, using
    only these axioms. You will need to prove a number of helper lemmas along the
    way. The proofs we have carried out in this section provide some hints.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感到自信，尝试只使用这些公理证明以下关于群的事实。在过程中，你需要证明许多辅助引理。本节中我们进行的证明提供了一些提示。
- en: '[PRE108]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Explicitly invoking those lemmas is tedious, so Mathlib provides tactics similar
    to ring in order to cover most uses: group is for non-commutative multiplicative
    groups, abel for abelian additive groups, and noncomm_ring for non-commutative
    rings. It may seem odd that the algebraic structures are called Ring and CommRing
    while the tactics are named noncomm_ring and ring. This is partly for historical
    reasons, but also for the convenience of using a shorter name for the tactic that
    deals with commutative rings, since it is used more often.  ## 2.3\. Using Theorems
    and Lemmas[](#using-theorems-and-lemmas "Link to this heading")'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 明确调用这些引理是繁琐的，所以 Mathlib 提供了类似于环的策略，以覆盖大多数用法：group 用于非交换乘法群，abel 用于阿贝尔加法群，noncomm_ring
    用于非交换环。看起来很奇怪，代数结构被称为 Ring 和 CommRing，而策略被命名为 noncomm_ring 和 ring。这部分是历史原因，但也是为了方便使用更短的名称来处理交换环的策略，因为它使用得更频繁。
- en: Rewriting is great for proving equations, but what about other sorts of theorems?
    For example, how can we prove an inequality, like the fact that \(a + e^b \le
    a + e^c\) holds whenever \(b \le c\)? We have already seen that theorems can be
    applied to arguments and hypotheses, and that the `apply` and `exact` tactics
    can be used to solve goals. In this section, we will make good use of these tools.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 重写对于证明方程很有用，但其他类型的定理呢？例如，我们如何证明一个不等式，比如 \(a + e^b \le a + e^c\) 在 \(b \le c\)
    时成立？我们已经看到定理可以应用于论点和假设，并且可以使用 `apply` 和 `exact` 策略来解决目标。在本节中，我们将充分利用这些工具。
- en: 'Consider the library theorems `le_refl` and `le_trans`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑库定理 `le_refl` 和 `le_trans`：
- en: '[PRE109]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'As we explain in more detail in [Section 3.1](C03_Logic.html#implication-and-the-universal-quantifier),
    the implicit parentheses in the statement of `le_trans` associate to the right,
    so it should be interpreted as `a ≤ b → (b ≤ c → a ≤ c)`. The library designers
    have set the arguments `a`, `b` and `c` to `le_trans` implicit, so that Lean will
    *not* let you provide them explicitly (unless you really insist, as we will discuss
    later). Rather, it expects to infer them from the context in which they are used.
    For example, when hypotheses `h : a ≤ b` and `h'' : b ≤ c` are in the context,
    all the following work:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '如我们在[第3.1节](C03_Logic.html#implication-and-the-universal-quantifier)中更详细地解释的那样，`le_trans`
    表述中的隐含括号是向右结合的，因此它应该被解释为 `a ≤ b → (b ≤ c → a ≤ c)`。库设计者已经将 `a`、`b` 和 `c` 设置为 `le_trans`
    的隐含参数，这样 Lean 就不会让你明确地提供它们（除非你真的坚持，我们稍后会讨论）。相反，它期望从它们被使用的上下文中推断它们。例如，当假设 `h :
    a ≤ b` 和 `h'' : b ≤ c` 在上下文中时，以下所有内容都有效：'
- en: '[PRE110]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The `apply` tactic takes a proof of a general statement or implication, tries
    to match the conclusion with the current goal, and leaves the hypotheses, if any,
    as new goals. If the given proof matches the goal exactly (modulo *definitional*
    equality), you can use the `exact` tactic instead of `apply`. So, all of these
    work:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply` 策略接受一个一般陈述或蕴涵的证明，尝试将结论与当前目标匹配，并将假设（如果有的话）作为新目标留下。如果给定的证明与目标完全匹配（模定义等价），则可以使用
    `exact` 策略而不是 `apply`。所以，所有这些都有效：'
- en: '[PRE111]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'In the first example, applying `le_trans` creates two goals, and we use the
    dots to indicate where the proof of each begins. The dots are optional, but they
    serve to *focus* the goal: within the block introduced by the dot, only one goal
    is visible, and it must be completed before the end of the block. Here we end
    the first block by starting a new one with another dot. We could just as well
    have decreased the indentation. In the third example and in the last example,
    we avoid going into tactic mode entirely: `le_trans h₀ h₁` and `le_refl x` are
    the proof terms we need.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，应用 `le_trans` 产生了两个目标，我们使用点来指示每个证明的开始位置。点是可以省略的，但它们有助于 *聚焦* 目标：在点引入的块内，只有一个目标可见，并且必须在块的末尾之前完成。在这里，我们通过用另一个点开始一个新的块来结束第一个块。我们也可以减少缩进。在第三个示例和最后一个示例中，我们完全避免了进入策略模式：`le_trans
    h₀ h₁` 和 `le_refl x` 是我们需要证明项。
- en: 'Here are a few more library theorems:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一些库定理：
- en: '[PRE112]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Use them together with `apply` and `exact` to prove the following:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们与 `apply` 和 `exact` 结合起来证明以下内容：
- en: '[PRE113]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'In fact, Lean has a tactic that does this sort of thing automatically:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Lean 有一个策略可以自动完成这类事情：
- en: '[PRE114]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The `linarith` tactic is designed to handle *linear arithmetic*.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`linarith` 策略被设计用来处理 *线性算术*。'
- en: '[PRE115]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: In addition to equations and inequalities in the context, `linarith` will use
    additional inequalities that you pass as arguments. In the next example, `exp_le_exp.mpr
    h'` is a proof of `exp b ≤ exp c`, as we will explain in a moment. Notice that,
    in Lean, we write `f x` to denote the application of a function `f` to the argument
    `x`, exactly the same way we write `h x` to denote the result of applying a fact
    or theorem `h` to the argument `x`. Parentheses are only needed for compound arguments,
    as in `f (x + y)`. Without the parentheses, `f x + y` would be parsed as `(f x)
    + y`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上下文中的等式和不等式之外，`linarith` 还会使用你作为参数传递的额外不等式。在下一个示例中，`exp_le_exp.mpr h'` 是 `exp
    b ≤ exp c` 的证明，我们将在下一刻解释。请注意，在 Lean 中，我们用 `f x` 来表示函数 `f` 对参数 `x` 的应用，这与我们用 `h
    x` 来表示事实或定理 `h` 对参数 `x` 的应用的方式完全相同。括号仅用于复合参数，例如 `f (x + y)`。如果没有括号，`f x + y` 将被解析为
    `(f x) + y`。
- en: '[PRE116]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Here are some more theorems in the library that can be used to establish inequalities
    on the real numbers.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些库中的定理，可以用来在实数上建立不等式。
- en: '[PRE117]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Some of the theorems, `exp_le_exp`, `exp_lt_exp` use a *bi-implication*, which
    represents the phrase “if and only if.” (You can type it in VS Code with `\lr`
    or `\iff`). We will discuss this connective in greater detail in the next chapter.
    Such a theorem can be used with `rw` to rewrite a goal to an equivalent one:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 一些定理，如 `exp_le_exp` 和 `exp_lt_exp`，使用 *双向蕴涵*，它表示短语“当且仅当”。（你可以在 VS Code 中使用 `\lr`
    或 `\iff` 来输入它）。我们将在下一章中更详细地讨论这个连接词。这样的定理可以用 `rw` 来重写一个目标为等价的目标：
- en: '[PRE118]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'In this section, however, we will use the fact that if `h : A ↔ B` is such
    an equivalence, then `h.mp` establishes the forward direction, `A → B`, and `h.mpr`
    establishes the reverse direction, `B → A`. Here, `mp` stands for “modus ponens”
    and `mpr` stands for “modus ponens reverse.” You can also use `h.1` and `h.2`
    for `h.mp` and `h.mpr`, respectively, if you prefer. Thus the following proof
    works:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '在本节中，然而，我们将使用以下事实：如果 `h : A ↔ B` 是这样一个等价关系，那么 `h.mp` 建立了正向方向，`A → B`，而 `h.mpr`
    建立了反向方向，`B → A`。在这里，`mp` 代表“modus ponens”，而 `mpr` 代表“modus ponens reverse”。如果你更喜欢，你也可以使用
    `h.1` 和 `h.2` 分别代表 `h.mp` 和 `h.mpr`。因此，以下证明是有效的：'
- en: '[PRE119]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The first line, `apply add_lt_add_of_lt_of_le`, creates two goals, and once
    again we use a dot to separate the proof of the first from the proof of the second.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行，`apply add_lt_add_of_lt_of_le` 产生了两个目标，并且我们再次使用一个点来区分第一个证明和第二个证明。
- en: Try the following examples on your own. The example in the middle shows you
    that the `norm_num` tactic can be used to solve concrete numeric goals.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下示例。中间的示例显示你可以使用 `norm_num` 策略来解决具体的数值目标。
- en: '[PRE120]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'From these examples, it should be clear that being able to find the library
    theorems you need constitutes an important part of formalization. There are a
    number of strategies you can use:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些示例中，应该很明显，能够找到你需要的库定理是形式化的重要部分。你可以使用以下几种策略：
- en: You can browse Mathlib in its [GitHub repository](https://github.com/leanprover-community/mathlib4).
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在其 [GitHub 仓库](https://github.com/leanprover-community/mathlib4) 中浏览 Mathlib。
- en: You can use the API documentation on the Mathlib [web pages](https://leanprover-community.github.io/mathlib4_docs/).
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 Mathlib 的 [网页](https://leanprover-community.github.io/mathlib4_docs/)
    上的 API 文档。
- en: You can use Loogle <https://loogle.lean-lang.org> to search Lean and Mathlib
    definitions and theorems by patterns.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用Loogle <https://loogle.lean-lang.org>通过模式搜索Lean和Mathlib的定义和定理。
- en: You can rely on Mathlib naming conventions and Ctrl-space completion in the
    editor to guess a theorem name (or Cmd-space on a Mac keyboard). In Lean, a theorem
    named `A_of_B_of_C` establishes something of the form `A` from hypotheses of the
    form `B` and `C`, where `A`, `B`, and `C` approximate the way we might read the
    goals out loud. So a theorem establishing something like `x + y ≤ ...` will probably
    start with `add_le`. Typing `add_le` and hitting Ctrl-space will give you some
    helpful choices. Note that hitting Ctrl-space twice displays more information
    about the available completions.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以依靠Mathlib的命名约定和编辑器的Ctrl-space自动完成来猜测定理名称（或在Mac键盘上按Cmd-space）。在Lean中，一个名为`A_of_B_of_C`的定理从形式为`B`和`C`的假设中建立`A`，其中`A`、`B`和`C`近似于我们大声读出目标的方式。所以一个建立类似`x
    + y ≤ ...`的定理可能以`add_le`开头。键入`add_le`并按Ctrl-space将给出一些有用的选择。请注意，按Ctrl-space两次将显示有关可用完成信息的更多信息。
- en: If you right-click on an existing theorem name in VS Code, the editor will show
    a menu with the option to jump to the file where the theorem is defined, and you
    can find similar theorems nearby.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你右键单击VS Code中的现有定理名称，编辑器将显示一个菜单，其中包含跳转到定理定义文件的选项，你可以在附近找到类似定理。
- en: You can use the `apply?` tactic, which tries to find the relevant theorem in
    the library.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`apply?`策略，它试图在库中找到相关的定理。
- en: '[PRE121]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'To try out `apply?` in this example, delete the `exact` command and uncomment
    the previous line. Using these tricks, see if you can find what you need to do
    the next example:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中尝试`apply?`，请删除`exact`命令并取消上一行的注释。使用这些技巧，看看你是否能找到进行下一个例子所需的内容：
- en: '[PRE122]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Using the same tricks, confirm that `linarith` instead of `apply?` can also
    finish the job.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的技巧，确认`linarith`而不是`apply?`也可以完成这项工作。
- en: 'Here is another example of an inequality:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个不等式的例子：
- en: '[PRE123]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Mathlib tends to put spaces around binary operations like `*` and `^`, but in
    this example, the more compressed format increases readability. There are a number
    of things worth noticing. First, an expression `s ≥ t` is definitionally equivalent
    to `t ≤ s`. In principle, this means one should be able to use them interchangeably.
    But some of Lean’s automation does not recognize the equivalence, so Mathlib tends
    to favor `≤` over `≥`. Second, we have used the `ring` tactic extensively. It
    is a real timesaver! Finally, notice that in the second line of the second `calc`
    proof, instead of writing `by exact add_le_add (le_refl _) h`, we can simply write
    the proof term `add_le_add (le_refl _) h`.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib倾向于在二元运算如`*`和`^`周围放置空格，但在这个例子中，更紧凑的格式提高了可读性。有一些值得注意的事情。首先，表达式`s ≥ t`在定义上是等价于`t
    ≤ s`的。原则上，这意味着人们应该能够互换使用它们。但是，Lean的一些自动化没有识别出这种等价性，所以Mathlib倾向于更喜欢`≤`而不是`≥`。其次，我们广泛使用了`ring`策略。它真的节省了时间！最后，注意在第二个`calc`证明的第二行中，我们不需要写`by
    exact add_le_add (le_refl _) h`，我们可以简单地写出证明项`add_le_add (le_refl _) h`。
- en: 'In fact, the only cleverness in the proof above is figuring out the hypothesis
    `h`. Once we have it, the second calculation involves only linear arithmetic,
    and `linarith` can handle it:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，上述证明中唯一的巧妙之处在于找出假设`h`。一旦我们有了它，第二个计算只涉及线性代数，而`linarith`可以处理它：
- en: '[PRE124]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: How nice! We challenge you to use these ideas to prove the following theorem.
    You can use the theorem `abs_le'.mpr`. You will also need the `constructor` tactic
    to split a conjunction to two goals; see [Section 3.4](C03_Logic.html#conjunction-and-biimplication).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 真是太好了！我们挑战你使用这些想法来证明以下定理。你可以使用定理`abs_le'.mpr`。你还需要使用`constructor`策略将合取分解为两个目标；参见[第3.4节](C03_Logic.html#conjunction-and-biimplication)。
- en: '[PRE125]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'If you managed to solve this, congratulations! You are well on your way to
    becoming a master formalizer.  ## 2.4\. More examples using apply and rw[](#more-examples-using-apply-and-rw
    "Link to this heading")'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你设法解决了这个问题，恭喜你！你正朝着成为一位大师级形式化专家的道路上迈进。
- en: 'The `min` function on the real numbers is uniquely characterized by the following
    three facts:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 实数上的`min`函数由以下三个事实唯一表征：
- en: '[PRE126]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Can you guess the names of the theorems that characterize `max` in a similar
    way?
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜出表征`max`的定理的名称吗？
- en: Notice that we have to apply `min` to a pair of arguments `a` and `b` by writing
    `min a b` rather than `min (a, b)`. Formally, `min` is a function of type `ℝ →
    ℝ → ℝ`. When we write a type like this with multiple arrows, the convention is
    that the implicit parentheses associate to the right, so the type is interpreted
    as `ℝ → (ℝ → ℝ)`. The net effect is that if `a` and `b` have type `ℝ` then `min
    a` has type `ℝ → ℝ` and `min a b` has type `ℝ`, so `min` acts like a function
    of two arguments, as we expect. Handling multiple arguments in this way is known
    as *currying*, after the logician Haskell Curry.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须通过编写 `min a b` 而不是 `min (a, b)` 来将 `min` 应用到一对参数 `a` 和 `b` 上。形式上，`min`
    是一个类型为 `ℝ → ℝ → ℝ` 的函数。当我们用多个箭头写这样的类型时，约定是隐式括号向右结合，所以类型被解释为 `ℝ → (ℝ → ℝ)`。最终的效果是，如果
    `a` 和 `b` 的类型是 `ℝ`，那么 `min a` 的类型是 `ℝ → ℝ`，`min a b` 的类型是 `ℝ`，所以 `min` 的行为就像一个有两个参数的函数，正如我们所期望的那样。以这种方式处理多个参数被称为
    *currying*，这是逻辑学家 Haskell Curry 的名字。
- en: The order of operations in Lean can also take some getting used to. Function
    application binds tighter than infix operations, so the expression `min a b +
    c` is interpreted as `(min a b) + c`. With time, these conventions will become
    second nature.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 中的运算顺序也需要一些时间来适应。函数应用比中缀操作绑定得更紧密，所以表达式 `min a b + c` 被解释为 `(min a b) +
    c`。随着时间的推移，这些约定将变得自然而然。
- en: 'Using the theorem `le_antisymm`, we can show that two real numbers are equal
    if each is less than or equal to the other. Using this and the facts above, we
    can show that `min` is commutative:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 使用定理 `le_antisymm`，我们可以证明两个实数相等当且仅当每个数都小于或等于另一个数。利用这一点和上述事实，我们可以证明 `min` 是可交换的：
- en: '[PRE127]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Here we have used dots to separate proofs of different goals. Our usage is
    inconsistent: at the outer level, we use dots and indentation for both goals,
    whereas for the nested proofs, we use dots only until a single goal remains. Both
    conventions are reasonable and useful. We also use the `show` tactic to structure
    the proof and indicate what is being proved in each block. The proof still works
    without the `show` commands, but using them makes the proof easier to read and
    maintain.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了点来分隔不同目标证明。我们的用法不一致：在外层，我们使用点和缩进来表示两个目标，而对于嵌套证明，我们只使用点，直到只剩下一个目标。这两种约定都是合理且有用的。我们还使用
    `show` 策略来结构化证明并指示每个块中正在证明的内容。即使没有 `show` 命令，证明仍然有效，但使用它们可以使证明更容易阅读和维护。
- en: 'It may bother you that the proof is repetitive. To foreshadow skills you will
    learn later on, we note that one way to avoid the repetition is to state a local
    lemma and then use it:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会让你感到烦恼的是，证明是重复的。为了预示你以后将学习到的技能，我们注意到避免重复的一种方法是可以声明一个局部引理然后使用它：
- en: '[PRE128]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: We will say more about the universal quantifier in [Section 3.1](C03_Logic.html#implication-and-the-universal-quantifier),
    but suffice it to say here that the hypothesis `h` says that the desired inequality
    holds for any `x` and `y`, and the `intro` tactic introduces an arbitrary `x`
    and `y` to establish the conclusion. The first `apply` after `le_antisymm` implicitly
    uses `h a b`, whereas the second one uses `h b a`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第3.1节](C03_Logic.html#implication-and-the-universal-quantifier) 中详细介绍全称量词，但在这里只需说明，假设
    `h` 表示对于任何 `x` 和 `y`，所期望的不等式都成立，而 `intro` 策略引入任意的 `x` 和 `y` 来建立结论。在 `le_antisymm`
    之后的第一 `apply` 隐式地使用了 `h a b`，而第二个 `apply` 使用了 `h b a`。
- en: Another solution is to use the `repeat` tactic, which applies a tactic (or a
    block) as many times as it can.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是使用 `repeat` 策略，它可以尽可能多次地应用策略（或一个块）。
- en: '[PRE129]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: We encourage you to prove the following as exercises. You can use either of
    the tricks just described to shorten the first.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励你将以下内容作为练习来证明。你可以使用上面描述的任何一种技巧来缩短第一个证明。
- en: '[PRE130]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Of course, you are welcome to prove the associativity of `max` as well.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以证明 `max` 的结合律。
- en: It is an interesting fact that `min` distributes over `max` the way that multiplication
    distributes over addition, and vice-versa. In other words, on the real numbers,
    we have the identity `min a (max b c) = max (min a b) (min a c)` as well as the
    corresponding version with `max` and `min` switched. But in the next section we
    will see that this does *not* follow from the transitivity and reflexivity of
    `≤` and the characterizing properties of `min` and `max` enumerated above. We
    need to use the fact that `≤` on the real numbers is a *total order*, which is
    to say, it satisfies `∀ x y, x ≤ y ∨ y ≤ x`. Here the disjunction symbol, `∨`,
    represents “or”. In the first case, we have `min x y = x`, and in the second case,
    we have `min x y = y`. We will learn how to reason by cases in [Section 3.5](C03_Logic.html#disjunction),
    but for now we will stick to examples that don’t require the case split.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的事实，即`min`在`max`上的分配方式与乘法在加法上的分配方式相同，反之亦然。换句话说，在实数上，我们有恒等式`min a (max
    b c) = max (min a b) (min a c)`，以及将`max`和`min`互换的对应版本。但在下一节中，我们将看到这一点并不从`≤`的可传递性和自反性以及上面列出的`min`和`max`的特征属性中得出。我们需要使用`≤`在实数上是全序的事实，也就是说，它满足`∀
    x y, x ≤ y ∨ y ≤ x`。在这里，析取符号`∨`代表“或”。在第一种情况下，我们有`min x y = x`，在第二种情况下，我们有`min
    x y = y`。我们将学习如何在[第3.5节](C03_Logic.html#disjunction)中通过情况推理，但就目前而言，我们将坚持使用不需要情况分解的例子。
- en: 'Here is one such example:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个这样的例子：
- en: '[PRE131]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: It is clear that `aux` provides one of the two inequalities needed to prove
    the equality, but applying it to suitable values yields the other direction as
    well. As a hint, you can use the theorem `add_neg_cancel_right` and the `linarith`
    tactic.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，`aux`提供了证明等式所需的两个不等式之一，但将其应用于适当的值也会得到另一个方向。作为一个提示，你可以使用定理`add_neg_cancel_right`和`linarith`策略。
- en: 'Lean’s naming convention is made manifest in the library’s name for the triangle
    inequality:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: Lean的命名约定在库的名称中得到了体现，即三角不等式的名称：
- en: '[PRE132]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Use it to prove the following variant, using also `add_sub_cancel_right`:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它来证明以下变体，同时使用`add_sub_cancel_right`：
- en: '[PRE133]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: See if you can do this in three lines or less. You can use the theorem `sub_add_cancel`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能在三行或更少的文字中做到这一点。你可以使用定理`sub_add_cancel`。
- en: 'Another important relation that we will make use of in the sections to come
    is the divisibility relation on the natural numbers, `x ∣ y`. Be careful: the
    divisibility symbol is *not* the ordinary bar on your keyboard. Rather, it is
    a unicode character obtained by typing `\|` in VS Code. By convention, Mathlib
    uses `dvd` to refer to it in theorem names.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将使用的一个重要关系是自然数上的除法关系 `x ∣ y`。请注意：除法符号 *不是* 你键盘上的普通竖线。相反，它是一个通过在VS
    Code中输入 `\|` 获得的Unicode字符。按照惯例，Mathlib在定理名称中使用 `dvd` 来指代它。
- en: '[PRE134]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'In the last example, the exponent is a natural number, and applying `dvd_mul_left`
    forces Lean to expand the definition of `x^2` to `x^1 * x`. See if you can guess
    the names of the theorems you need to prove the following:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个例子中，指数是一个自然数，应用`dvd_mul_left`迫使Lean展开`x^2`的定义为`x^1 * x`。看看你是否能猜出你需要证明以下内容所需的定理名称：
- en: '[PRE135]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'With respect to divisibility, the *greatest common divisor*, `gcd`, and least
    common multiple, `lcm`, are analogous to `min` and `max`. Since every number divides
    `0`, `0` is really the greatest element with respect to divisibility:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在除法方面，*最大公约数* `gcd` 和最小公倍数 `lcm` 与 `min` 和 `max` 类似。由于每个数都能整除 `0`，所以 `0` 真的是除法关系中的最大元素：
- en: '[PRE136]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'See if you can guess the names of the theorems you will need to prove the following:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能猜出你需要证明以下内容所需的定理名称：
- en: '[PRE137]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Hint: you can use `dvd_antisymm`, but if you do, Lean will complain that the
    expression is ambiguous between the generic theorem and the version `Nat.dvd_antisymm`,
    the one specifically for the natural numbers. You can use `_root_.dvd_antisymm`
    to specify the generic one; either one will work.  ## 2.5\. Proving Facts about
    Algebraic Structures[](#proving-facts-about-algebraic-structures "Link to this
    heading")'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：你可以使用`dvd_antisymm`，但如果你这样做，Lean会抱怨表达式在通用定理和版本`Nat.dvd_antisymm`（专门针对自然数的版本）之间是模糊的。你可以使用`_root_.dvd_antisymm`来指定通用版本；任何一个都可以工作。
- en: 'In [Section 2.2](#proving-identities-in-algebraic-structures), we saw that
    many common identities governing the real numbers hold in more general classes
    of algebraic structures, such as commutative rings. We can use any axioms we want
    to describe an algebraic structure, not just equations. For example, a *partial
    order* consists of a set with a binary relation that is reflexive, transitive,
    and antisymmetric. like `≤` on the real numbers. Lean knows about partial orders:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 2.2 节](#proving-identities-in-algebraic-structures)中，我们看到了许多常见的关于实数的恒等式在更一般的代数结构中也是成立的，例如交换环。我们可以使用任何我们想要的公理来描述代数结构，而不仅仅是方程。例如，**部分序**由一个集合和二元关系组成，该关系是自反的、传递的和反对称的，类似于实数上的
    `≤`。Lean 了解部分序：
- en: '[PRE138]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Here we are adopting the Mathlib convention of using letters like `α`, `β`,
    and `γ` (entered as `\a`, `\b`, and `\g`) for arbitrary types. The library often
    uses letters like `R` and `G` for the carriers of algebraic structures like rings
    and groups, respectively, but in general Greek letters are used for types, especially
    when there is little or no structure associated with them.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们采用了 Mathlib 的约定，使用像 `α`、`β` 和 `γ`（输入为 `\a`、`\b` 和 `\g`）这样的字母来表示任意类型。该库通常使用像
    `R` 和 `G` 这样的字母来表示环和群等代数结构的载体，但在一般情况下，希腊字母用于类型，特别是在与它们关联的结构很少或没有结构时。 '
- en: Associated to any partial order, `≤`, there is also a *strict partial order*,
    `<`, which acts somewhat like `<` on the real numbers. Saying that `x` is less
    than `y` in this order is equivalent to saying that it is less-than-or-equal to
    `y` and not equal to `y`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何部分序 `≤` 相关联的，还有一个**严格部分序**`<`，它在某种程度上类似于实数上的 `<`。在这个顺序中，说 `x` 小于 `y` 等同于说它小于或等于
    `y` 但不等于 `y`。
- en: '[PRE139]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: In this example, the symbol `∧` stands for “and,” the symbol `¬` stands for
    “not,” and `x ≠ y` abbreviates `¬ (x = y)`. In [Chapter 3](C03_Logic.html#logic),
    you will learn how to use these logical connectives to *prove* that `<` has the
    properties indicated.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，符号 `∧` 表示“和”，符号 `¬` 表示“非”，而 `x ≠ y` 简写为 `¬ (x = y)`。在[第 3 章](C03_Logic.html#logic)中，您将学习如何使用这些逻辑连接词来**证明**
    `<` 具有指示的性质。
- en: 'A *lattice* is a structure that extends a partial order with operations `⊓`
    and `⊔` that are analogous to `min` and `max` on the real numbers:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**格**是一种扩展了部分序（`≤`）并带有 `⊓` 和 `⊔` 操作的结构，这些操作与实数上的 `min` 和 `max` 类似：'
- en: '[PRE140]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The characterizations of `⊓` and `⊔` justify calling them the *greatest lower
    bound* and *least upper bound*, respectively. You can type them in VS code using
    `\glb` and `\lub`. The symbols are also often called then *infimum* and the *supremum*,
    and Mathlib refers to them as `inf` and `sup` in theorem names. To further complicate
    matters, they are also often called *meet* and *join*. Therefore, if you work
    with lattices, you have to keep the following dictionary in mind:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`⊓` 和 `⊔` 的定义使得它们分别被称为**最大下界**和**最小上界**。您可以在 VS code 中使用 `\glb` 和 `\lub` 来输入这些符号。这些符号也常被称为**下确界**和**上确界**，Mathlib
    在定理名称中用 `inf` 和 `sup` 来指代它们。为了进一步复杂化问题，它们也常被称为**交**和**并**。因此，如果您与格（lattices）打交道，您必须记住以下字典：'
- en: '`⊓` is the *greatest lower bound*, *infimum*, or *meet*.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`⊓` 是**最大下界**、**下确界**或**交**。'
- en: '`⊔` is the *least upper bound*, *supremum*, or *join*.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`⊔` 是**最小上界**、**上确界**或**并**。'
- en: 'Some instances of lattices include:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 一些格的实例包括：
- en: '`min` and `max` on any total order, such as the integers or real numbers with
    `≤`'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何全序（如整数或实数与 `≤`）上的 `min` 和 `max`。
- en: '`∩` and `∪` on the collection of subsets of some domain, with the ordering
    `⊆`'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某个域的子集集合上，使用 `⊆` 排序，`∩` 和 `∪` 表示。
- en: '`∧` and `∨` on boolean truth values, with ordering `x ≤ y` if either `x` is
    false or `y` is true'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在布尔真值上的 `∧` 和 `∨`，如果 `x` 为假或 `y` 为真，则 `x ≤ y`。
- en: '`gcd` and `lcm` on the natural numbers (or positive natural numbers), with
    the divisibility ordering, `∣`'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在自然数（或正自然数）上的 `gcd` 和 `lcm`，使用可除性排序 `∣`。
- en: the collection of linear subspaces of a vector space, where the greatest lower
    bound is given by the intersection, the least upper bound is given by the sum
    of the two spaces, and the ordering is inclusion
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量空间线性子空间的集合，其中最大下界由交集给出，最小上界由两个空间的和给出，排序是包含关系。
- en: the collection of topologies on a set (or, in Lean, a type), where the greatest
    lower bound of two topologies consists of the topology that is generated by their
    union, the least upper bound is their intersection, and the ordering is reverse
    inclusion
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合上的拓扑集合（或在 Lean 中，类型），其中两个拓扑的最大下界是由它们的并生成的拓扑，最小上界是它们的交集，排序是反向包含关系。
- en: You can check that, as with `min` / `max` and `gcd` / `lcm`, you can prove the
    commutativity and associativity of the infimum and supremum using only their characterizing
    axioms, together with `le_refl` and `le_trans`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以检查，与`min`/`max`和`gcd`/`lcm`一样，你可以仅使用它们的特征公理以及`le_refl`和`le_trans`来证明下确界和上确界的交换性和结合性。
- en: Using `apply le_trans` when seeing a goal `x ≤ z` is not a great idea. Indeed
    Lean has no way to guess which intermediate element `y` we want to use. So `apply
    le_trans` produces three goals that look like `x ≤ ?a`, `?a ≤ z` and `α` where
    `?a` (probably with a more complicated auto-generated name) stands for the mysterious
    `y`. The last goal, with type `α`, is to provide the value of `y`. It comes lasts
    because Lean hopes to automatically infer it from the proof of the first goal
    `x ≤ ?a`. In order to avoid this unappealing situation, you can use the `calc`
    tactic to explicitly provide `y`. Alternatively, you can use the `trans` tactic
    which takes `y` as an argument and produces the expected goals `x ≤ y` and `y
    ≤ z`. Of course you can also avoid this issue by providing directly a full proof
    such as `exact le_trans inf_le_left inf_le_right`, but this requires a lot more
    planning.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 当看到目标`x ≤ z`时使用`apply le_trans`不是一个好主意。实际上，Lean没有方法猜测我们想要使用哪个中间元素`y`。因此，`apply
    le_trans`会产生三个看起来像`x ≤ ?a`、`?a ≤ z`和`α`的目标，其中`?a`（可能有一个更复杂的自动生成的名称）代表神秘的`y`。最后一个目标，类型为`α`，是提供`y`的值。它最后出现，因为Lean希望从第一个目标`x
    ≤ ?a`的证明中自动推断它。为了避免这种不吸引人的情况，你可以使用`calc`策略显式地提供`y`。或者，你可以使用接受`y`作为参数的`trans`策略，它会产生预期的目标`x
    ≤ y`和`y ≤ z`。当然，你也可以通过直接提供一个完整的证明来避免这个问题，例如`exact le_trans inf_le_left inf_le_right`，但这需要更多的计划。
- en: '[PRE141]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: You can find these theorems in the Mathlib as `inf_comm`, `inf_assoc`, `sup_comm`,
    and `sup_assoc`, respectively.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Mathlib中找到这些定理，分别命名为`inf_comm`、`inf_assoc`、`sup_comm`和`sup_assoc`。
- en: 'Another good exercise is to prove the *absorption laws* using only those axioms:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的练习是仅使用那些公理来证明**吸收律**：
- en: '[PRE142]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: These can be found in Mathlib with the names `inf_sup_self` and `sup_inf_self`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以在Mathlib中找到，名称分别为`inf_sup_self`和`sup_inf_self`。
- en: 'A lattice that satisfies the additional identities `x ⊓ (y ⊔ z) = (x ⊓ y) ⊔
    (x ⊓ z)` and `x ⊔ (y ⊓ z) = (x ⊔ y) ⊓ (x ⊔ z)` is called a *distributive lattice*.
    Lean knows about these too:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 满足额外的恒等式`x ⊓ (y ⊔ z) = (x ⊓ y) ⊔ (x ⊓ z)`和`x ⊔ (y ⊓ z) = (x ⊔ y) ⊓ (x ⊔ z)`的格称为**分配格**。Lean也了解这些：
- en: '[PRE143]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'The left and right versions are easily shown to be equivalent, given the commutativity
    of `⊓` and `⊔`. It is a good exercise to show that not every lattice is distributive
    by providing an explicit description of a nondistributive lattice with finitely
    many elements. It is also a good exercise to show that in any lattice, either
    distributivity law implies the other:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧和右侧版本很容易证明是等价的，考虑到`⊓`和`⊔`的交换性。证明不是每个格都是分配格是一个很好的练习，可以通过提供一个具有有限个元素的非分配格的显式描述来完成。证明在任何格中，分配律中的任何一个都蕴含另一个也是一个很好的练习：
- en: '[PRE144]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'It is possible to combine axiomatic structures into larger ones. For example,
    a *strict ordered ring* consists of a ring together with a partial order on the
    carrier satisfying additional axioms that say that the ring operations are compatible
    with the order:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能将公理结构组合成更大的结构。例如，一个**严格有序环**由一个环及其载体上的偏序组成，该偏序满足额外的公理，这些公理说明环运算与顺序是兼容的：
- en: '[PRE145]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[Chapter 3](C03_Logic.html#logic) will provide the means to derive the following
    from `mul_pos` and the definition of `<`:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](C03_Logic.html#logic)将提供从`mul_pos`和`<`的定义中推导出以下内容的方法：'
- en: '[PRE146]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'It is then an extended exercise to show that many common facts used to reason
    about arithmetic and the ordering on the real numbers hold generically for any
    ordered ring. Here are a couple of examples you can try, using only properties
    of rings, partial orders, and the facts enumerated in the last two examples (beware
    that those rings are not assumed to be commutative, so the ring tactic is not
    available):'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是一个扩展练习，证明许多用于推理算术和实数排序的常见事实对于任何有序环都是通用的。这里有一些你可以尝试的例子，仅使用环的性质、偏序以及最后两个例子中列出的事实（注意，这些环不一定假设是交换的，因此没有提供环策略）：
- en: '[PRE147]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Finally, here is one last example. A *metric space* consists of a set equipped
    with a notion of distance, `dist x y`, mapping any pair of elements to a real
    number. The distance function is assumed to satisfy the following axioms:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里有一个最后的例子。一个**度量空间**由一个集合组成，该集合配备了距离的概念，`dist x y`，将任何一对元素映射到一个实数。距离函数假设满足以下公理：
- en: '[PRE148]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Having mastered this section, you can show that it follows from these axioms
    that distances are always nonnegative:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了这个部分后，您可以证明距离总是非负的，这是由这些公理得出的：
- en: '[PRE149]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: We recommend making use of the theorem `nonneg_of_mul_nonneg_left`. As you may
    have guessed, this theorem is called `dist_nonneg` in Mathlib.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用定理 `nonneg_of_mul_nonneg_left`。正如您可能已经猜到的，这个定理在 Mathlib 中被称为 `dist_nonneg`。
- en: 2.1\. Calculating[](#calculating "Link to this heading")
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1\. 计算[](#calculating "链接到这个标题")
- en: We generally learn to carry out mathematical calculations without thinking of
    them as proofs. But when we justify each step in a calculation, as Lean requires
    us to do, the net result is a proof that the left-hand side of the calculation
    is equal to the right-hand side.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常学习进行数学计算，而不把它们当作证明。但当我们像 Lean 所要求的那样证明计算的每一步，最终结果是证明计算的左侧等于右侧。
- en: In Lean, stating a theorem is tantamount to stating a goal, namely, the goal
    of proving the theorem. Lean provides the rewriting tactic `rw`, to replace the
    left-hand side of an identity by the right-hand side in the goal. If `a`, `b`,
    and `c` are real numbers, `mul_assoc a b c` is the identity `a * b * c = a * (b
    * c)` and `mul_comm a b` is the identity `a * b = b * a`. Lean provides automation
    that generally eliminates the need to refer the facts like these explicitly, but
    they are useful for the purposes of illustration. In Lean, multiplication associates
    to the left, so the left-hand side of `mul_assoc` could also be written `(a *
    b) * c`. However, it is generally good style to be mindful of Lean’s notational
    conventions and leave out parentheses when Lean does as well.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lean 中，陈述一个定理相当于陈述一个目标，即证明该定理的目标。Lean 提供了重写策略 `rw`，在目标中将等式的左侧替换为右侧。如果 `a`、`b`
    和 `c` 是实数，`mul_assoc a b c` 是等式 `a * b * c = a * (b * c)`，而 `mul_comm a b` 是等式
    `a * b = b * a`。Lean 提供了自动化，通常可以消除明确引用此类事实的需要，但它们对于说明目的很有用。在 Lean 中，乘法从左结合，因此
    `mul_assoc` 的左侧也可以写成 `(a * b) * c`。然而，通常良好的风格是注意 Lean 的符号约定，并在 Lean 也这样做时省略括号。
- en: Let’s try out `rw`.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试 `rw`。
- en: '[PRE150]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: The `import` lines at the beginning of the associated examples file import the
    theory of the real numbers from Mathlib, as well as useful automation. For the
    sake of brevity, we generally suppress information like this in the textbook.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在相关示例文件的开始部分，`import` 行导入了 Mathlib 中的实数理论以及有用的自动化。为了简洁起见，我们在教科书中通常抑制此类信息。
- en: 'You are welcome to make changes to see what happens. You can type the `ℝ` character
    as `\R` or `\real` in VS Code. The symbol doesn’t appear until you hit space or
    the tab key. If you hover over a symbol when reading a Lean file, VS Code will
    show you the syntax that can be used to enter it. If you are curious to see all
    available abbreviations, you can hit Ctrl-Shift-P and then type abbreviations
    to get access to the `Lean 4: Show Unicode Input Abbreviations` command. If your
    keyboard does not have an easily accessible backslash, you can change the leading
    character by changing the `lean4.input.leader` setting.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以随意修改以查看会发生什么。在 VS Code 中，您可以将 `ℝ` 字符键入为 `\R` 或 `\real`。符号只有在您按下空格键或制表键后才会显示。当您在阅读
    Lean 文件时悬停在符号上，VS Code 将显示可以用来输入它的语法。如果您想查看所有可用的缩写，您可以按 Ctrl-Shift-P，然后输入缩写以访问
    `Lean 4: 显示 Unicode 输入缩写` 命令。如果您的键盘上没有容易访问的反斜杠，您可以通过更改 `lean4.input.leader` 设置来更改前导字符。'
- en: 'When a cursor is in the middle of a tactic proof, Lean reports on the current
    *proof state* in the *Lean Infoview* window. As you move your cursor past each
    step of the proof, you can see the state change. A typical proof state in Lean
    might look as follows:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 当光标位于策略证明的中间时，Lean 在 *Lean Infoview* 窗口中报告当前的 *证明状态*。当您将光标移过证明的每一步时，您可以看到状态的变化。Lean
    中的一个典型证明状态可能如下所示：
- en: '[PRE151]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'The lines before the one that begins with `⊢` denote the *context*: they are
    the objects and assumptions currently at play. In this example, these include
    two objects, `x` and `y`, each a natural number. They also include three assumptions,
    labelled `h₁`, `h₂`, and `h₃`. In Lean, everything in a context is labelled with
    an identifier. You can type these subscripted labels as `h\1`, `h\2`, and `h\3`,
    but any legal identifiers would do: you can use `h1`, `h2`, `h3` instead, or `foo`,
    `bar`, and `baz`. The last line represents the *goal*, that is, the fact to be
    proved. Sometimes people use *target* for the fact to be proved, and *goal* for
    the combination of the context and the target. In practice, the intended meaning
    is usually clear.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 以`⊢`开头的行表示*上下文*：它们是当前正在使用的对象和假设。在这个例子中，这些包括两个对象，`x`和`y`，每个都是自然数。它们还包括三个假设，分别标记为`h₁`、`h₂`和`h₃`。在Lean中，上下文中的所有内容都用标识符标记。您可以将这些下标标签键入为`h\1`、`h\2`和`h\3`，但任何合法的标识符都可以：您可以使用`h1`、`h2`、`h3`代替，或者使用`foo`、`bar`和`baz`。最后一行代表*目标*，即要证明的事实。有时人们用*目标*来表示要证明的事实，用*目标*来表示上下文和目标的组合。在实践中，通常可以清楚地理解意图。
- en: Try proving these identities, in each case replacing `sorry` by a tactic proof.
    With the `rw` tactic, you can use a left arrow (`\l`) to reverse an identity.
    For example, `rw [← mul_assoc a b c]` replaces `a * (b * c)` by `a * b * c` in
    the current goal. Note that the left-pointing arrow refers to going from right
    to left in the identity provided by `mul_assoc`, it has nothing to do with the
    left or right side of the goal.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试证明这些恒等式，在每种情况下用策略证明替换`sorry`。使用`rw`策略，您可以使用左箭头（`\l`）来反转一个恒等式。例如，`rw [← mul_assoc
    a b c]`将当前目标中的`a * (b * c)`替换为`a * b * c`。请注意，指向左边的箭头指的是从右到左在`mul_assoc`提供的恒等式中移动，它与目标左侧或右侧无关。
- en: '[PRE152]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: You can also use identities like `mul_assoc` and `mul_comm` without arguments.
    In this case, the rewrite tactic tries to match the left-hand side with an expression
    in the goal, using the first pattern it finds.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在不提供参数的情况下使用像`mul_assoc`和`mul_comm`这样的恒等式。在这种情况下，重写策略会尝试使用它找到的第一个模式将目标左侧与目标中的表达式匹配。
- en: '[PRE153]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: You can also provide *partial* information. For example, `mul_comm a` matches
    any pattern of the form `a * ?` and rewrites it to `? * a`. Try doing the first
    of these examples without providing any arguments at all, and the second with
    only one argument.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以提供*部分*信息。例如，`mul_comm a`与形式为`a * ?`的任何模式匹配，并将其重写为`? * a`。尝试在不提供任何参数的情况下执行这些示例的第一个，以及只提供一个参数的情况下执行第二个。
- en: '[PRE154]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: You can also use `rw` with facts from the local context.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用`rw`与局部上下文中的事实。
- en: '[PRE155]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Try these, using the theorem `sub_self` for the second one:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些，对于第二个使用定理`sub_self`：
- en: '[PRE156]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Multiple rewrite commands can be carried out with a single command, by listing
    the relevant identities separated by commas inside the square brackets.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在方括号内用逗号分隔相关恒等式来执行多个重写命令。
- en: '[PRE157]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: You still see the incremental progress by placing the cursor after a comma in
    any list of rewrites.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然可以通过在任何重写列表的逗号后放置光标来看到增量进度。
- en: Another trick is that we can declare variables once and for all outside an example
    or theorem. Lean then includes them automatically.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个技巧是，我们可以在示例或定理之外一次性声明变量。然后Lean会自动包含它们。
- en: '[PRE158]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Inspection of the tactic state at the beginning of the above proof reveals
    that Lean indeed included all variables. We can delimit the scope of the declaration
    by putting it in a `section ... end` block. Finally, recall from the introduction
    that Lean provides us with a command to determine the type of an expression:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 检查上述证明开始时的策略状态，可以发现Lean确实包含了所有变量。我们可以通过将其放在`section ... end`块中来限定声明的范围。最后，从引言中回忆起，Lean为我们提供了一个命令来确定表达式的类型：
- en: '[PRE159]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'The `#check` command works for both objects and facts. In response to the command
    `#check a`, Lean reports that `a` has type `ℝ`. In response to the command `#check
    mul_comm a b`, Lean reports that `mul_comm a b` is a proof of the fact `a * b
    = b * a`. The command `#check (a : ℝ)` states our expectation that the type of
    `a` is `ℝ`, and Lean will raise an error if that is not the case. We will explain
    the output of the last three `#check` commands later, but in the meanwhile, you
    can take a look at them, and experiment with some `#check` commands of your own.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '`#check` 命令适用于对象和事实。对于命令 `#check a`，Lean 报告 `a` 的类型为 `ℝ`。对于命令 `#check mul_comm
    a b`，Lean 报告 `mul_comm a b` 是事实 `a * b = b * a` 的证明。命令 `#check (a : ℝ)` 表明我们期望
    `a` 的类型是 `ℝ`，如果这不是情况，Lean 将引发错误。我们将在稍后解释最后三个 `#check` 命令的输出，但在此同时，您可以查看它们，并尝试一些自己的
    `#check` 命令。'
- en: Let’s try some more examples. The theorem `two_mul a` says that `2 * a = a +
    a`. The theorems `add_mul` and `mul_add` express the distributivity of multiplication
    over addition, and the theorem `add_assoc` expresses the associativity of addition.
    Use the `#check` command to see the precise statements.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些更多的例子。定理 `two_mul a` 表示 `2 * a = a + a`。定理 `add_mul` 和 `mul_add` 表达了乘法在加法上的分配律，而定理
    `add_assoc` 表达了加法的结合律。使用 `#check` 命令来查看精确的陈述。
- en: '[PRE160]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Whereas it is possible to figure out what is going on in this proof by stepping
    through it in the editor, it is hard to read on its own. Lean provides a more
    structured way of writing proofs like this using the `calc` keyword.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以通过在编辑器中逐步执行这个证明来弄清楚发生了什么，但单独阅读起来很困难。Lean 提供了一种使用 `calc` 关键字来编写这种证明的更结构化的方式。
- en: '[PRE161]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Notice that the proof does *not* begin with `by`: an expression that begins
    with `calc` is a *proof term*. A `calc` expression can also be used inside a tactic
    proof, but Lean interprets it as the instruction to use the resulting proof term
    to solve the goal. The `calc` syntax is finicky: the underscores and justification
    have to be in the format indicated above. Lean uses indentation to determine things
    like where a block of tactics or a `calc` block begins and ends; try changing
    the indentation in the proof above to see what happens.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，证明并不以 `by` 开头：以 `calc` 开头的表达式是一个 *证明项*。`calc` 表达式也可以用在策略证明中，但 Lean 将其解释为使用生成的证明项来解决目标的指令。`calc`
    语法很挑剔：下划线和证明必须采用上述格式。Lean 使用缩进来确定策略块或 `calc` 块的开始和结束位置；尝试更改上述证明中的缩进来看看会发生什么。
- en: One way to write a `calc` proof is to outline it first using the `sorry` tactic
    for justification, make sure Lean accepts the expression modulo these, and then
    justify the individual steps using tactics.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 写一个 `calc` 证明的一种方法是首先使用 `sorry` 策略来概述它，确保 Lean 接受这些表达式，然后使用策略来证明各个步骤。
- en: '[PRE162]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Try proving the following identity using both a pure `rw` proof and a more
    structured `calc` proof:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用纯 `rw` 证明和更结构化的 `calc` 证明来证明以下恒等式：
- en: '[PRE163]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: The following exercise is a little more challenging. You can use the theorems
    listed underneath.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习稍微有些挑战性。你可以使用下面列出的定理。
- en: '[PRE164]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: We can also perform rewriting in an assumption in the context. For example,
    `rw [mul_comm a b] at hyp` replaces `a * b` by `b * a` in the assumption `hyp`.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在上下文中的假设中执行重写。例如，`rw [mul_comm a b] at hyp` 将假设 `hyp` 中的 `a * b` 替换为 `b
    * a`。
- en: '[PRE165]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: In the last step, the `exact` tactic can use `hyp` to solve the goal because
    at that point `hyp` matches the goal exactly.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，`exact` 策略可以使用 `hyp` 来解决目标，因为那时 `hyp` 与目标完全匹配。
- en: We close this section by noting that Mathlib provides a useful bit of automation
    with a `ring` tactic, which is designed to prove identities in any commutative
    ring as long as they follow purely from the ring axioms, without using any local
    assumption.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过指出 Mathlib 提供了一个有用的自动化功能，即 `ring` 策略，该策略旨在证明任何交换环中的恒等式，只要它们纯粹地来自环公理，而不使用任何局部假设，来结束本节。
- en: '[PRE166]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: The `ring` tactic is imported indirectly when we import `Mathlib.Data.Real.Basic`,
    but we will see in the next section that it can be used for calculations on structures
    other than the real numbers. It can be imported explicitly with the command `import
    Mathlib.Tactic`. We will see there are similar tactics for other common kind of
    algebraic structures.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们导入 `Mathlib.Data.Real.Basic` 时，`ring` 策略是间接导入的，但我们将看到在下一节中它可以用作对除了实数以外的结构进行计算。可以使用命令
    `import Mathlib.Tactic` 明确导入。我们将看到还有其他类似策略用于其他常见的代数结构。
- en: There is a variation of `rw` called `nth_rw` that allows you to replace only
    particular instances of an expression in the goal. Possible matches are enumerated
    starting with 1, so in the following example, `nth_rw 2 [h]` replaces the second
    occurrence of `a + b` with `c`.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种 `rw` 的变体称为 `nth_rw`，它允许你只替换目标中特定实例的表达式。可能的匹配从 1 开始枚举，所以在这个例子中，`nth_rw 2
    [h]` 将 `a + b` 的第二个出现替换为 `c`。
- en: '[PRE167]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '## 2.2\. Proving Identities in Algebraic Structures[](#proving-identities-in-algebraic-structures
    "Link to this heading")'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '## 2.2\. 在代数结构中证明恒等式[](#proving-identities-in-algebraic-structures "链接到这个标题")'
- en: 'Mathematically, a ring consists of a collection of objects, \(R\), operations
    \(+\) \(\times\), and constants \(0\) and \(1\), and an operation \(x \mapsto
    -x\) such that:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，一个环由一组对象 \(R\)、运算 \(+\) 和 \(\times\)、常数 \(0\) 和 \(1\) 以及一个运算 \(x \mapsto
    -x\) 组成，使得：
- en: \(R\) with \(+\) is an *abelian group*, with \(0\) as the additive identity
    and negation as inverse.
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(R\) 加号表示的是一个 *阿贝尔群*，其中 \(0\) 是加法单位元，否定是逆元。
- en: Multiplication is associative with identity \(1\), and multiplication distributes
    over addition.
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法与单位元 \(1\) 结合，并且乘法对加法分配。
- en: 'In Lean, the collection of objects is represented as a *type*, `R`. The ring
    axioms are as follows:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lean 中，对象的集合被表示为一个 *类型*，`R`。环公理如下：
- en: '[PRE168]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: You will learn more about the square brackets in the first line later, but for
    the time being, suffice it to say that the declaration gives us a type, `R`, and
    a ring structure on `R`. Lean then allows us to use generic ring notation with
    elements of `R`, and to make use of a library of theorems about rings.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在以后了解第一行中的方括号，但暂时只需知道这个声明给我们一个类型，`R`，以及 `R` 上的环结构。Lean 然后允许我们使用 `R` 的元素进行通用的环符号，并利用关于环的定理库。
- en: 'The names of some of the theorems should look familiar: they are exactly the
    ones we used to calculate with the real numbers in the last section. Lean is good
    not only for proving things about concrete mathematical structures like the natural
    numbers and the integers, but also for proving things about abstract structures,
    characterized axiomatically, like rings. Moreover, Lean supports *generic reasoning*
    about both abstract and concrete structures, and can be trained to recognize appropriate
    instances. So any theorem about rings can be applied to concrete rings like the
    integers, `ℤ`, the rational numbers, `ℚ`, and the complex numbers `ℂ`. It can
    also be applied to any instance of an abstract structure that extends rings, such
    as any ordered ring or any field.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 一些定理的名称应该看起来很熟悉：它们正是我们在上一节中使用实数进行计算时用到的。Lean 不仅擅长证明关于自然数和整数等具体数学结构的性质，而且也擅长证明关于抽象结构（如环）的性质。此外，Lean
    支持关于抽象和具体结构的 *通用推理*，并且可以被训练以识别适当的实例。因此，任何关于环的定理都可以应用于具体的环，如整数环 `ℤ`、有理数环 `ℚ` 和复数环
    `ℂ`。它也可以应用于任何扩展环的抽象结构的实例，例如任何有序环或任何域。
- en: Not all important properties of the real numbers hold in an arbitrary ring,
    however. For example, multiplication on the real numbers is commutative, but that
    does not hold in general. If you have taken a course in linear algebra, you will
    recognize that, for every \(n\), the \(n\) by \(n\) matrices of real numbers form
    a ring in which commutativity usually fails. If we declare `R` to be a *commutative*
    ring, in fact, all the theorems in the last section continue to hold when we replace
    `ℝ` by `R`.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有实数的性质在任意环中都成立。例如，实数上的乘法是交换的，但这一点在一般情况下并不成立。如果你已经学过线性代数课程，你会认识到，对于每一个
    \(n\)，实数的 \(n\) 阶矩阵形成一个环，其中交换律通常不成立。如果我们声明 `R` 是一个 *交换环*，实际上，当我们将 `ℝ` 替换为 `R`
    时，上一节中所有定理仍然成立。
- en: '[PRE169]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: We leave it to you to check that all the other proofs go through unchanged.
    Notice that when a proof is short, like `by ring` or `by linarith` or `by sorry`,
    it is common (and permissible) to put it on the same line as the `by`. Good proof-writing
    style should strike a balance between concision and readability.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 我们留给你们去检查其他所有证明是否保持不变。注意，当证明很短，如 `by ring` 或 `by linarith` 或 `by sorry` 时，将其放在
    `by` 的同一行上是常见（并且是允许的）。好的证明风格应该在简洁性和可读性之间取得平衡。
- en: The goal of this section is to strengthen the skills you have developed in the
    last section and apply them to reasoning axiomatically about rings. We will start
    with the axioms listed above, and use them to derive other facts. Most of the
    facts we prove are already in Mathlib. We will give the versions we prove the
    same names to help you learn the contents of the library as well as the naming
    conventions.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是加强你在上一节中发展的技能，并将它们应用于关于环的公理推理。我们将从上面列出的公理开始，并使用它们推导出其他事实。我们证明的大多数事实已经在Mathlib中。我们将给出我们证明的版本相同的名称，以帮助你学习库的内容以及命名约定。
- en: 'Lean provides an organizational mechanism similar to those used in programming
    languages: when a definition or theorem `foo` is introduced in a *namespace* `bar`,
    its full name is `bar.foo`. The command `open bar` later *opens* the namespace,
    which allows us to use the shorter name `foo`. To avoid errors due to name clashes,
    in the next example we put our versions of the library theorems in a new namespace
    called `MyRing.`'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: Lean提供了一个类似于编程语言中使用的组织机制：当在*命名空间*`bar`中引入定义或定理`foo`时，它的全名是`bar.foo`。命令`open
    bar`稍后*打开*命名空间，这允许我们使用较短的名称`foo`。为了避免由于名称冲突而引起的错误，在下一个例子中，我们将我们的库定理版本放在一个新的命名空间`MyRing`中。
- en: The next example shows that we do not need `add_zero` or `add_neg_cancel` as
    ring axioms, because they follow from the other axioms.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 以下例子表明，我们不需要`add_zero`或`add_neg_cancel`作为环公理，因为它们可以从其他公理中得出。
- en: '[PRE170]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: The net effect is that we can temporarily reprove a theorem in the library,
    and then go on using the library version after that. But don’t cheat! In the exercises
    that follow, take care to use only the general facts about rings that we have
    proved earlier in this section.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 这种净效应是，我们可以暂时重新证明库中的一个定理，然后继续使用库版本。但不要作弊！在接下来的练习中，请务必只使用我们在本节前面已经证明的关于环的一般事实。
- en: '(If you are paying careful attention, you may have noticed that we changed
    the round brackets in `(R : Type*)` for curly brackets in `{R : Type*}`. This
    declares `R` to be an *implicit argument*. We will explain what this means in
    a moment, but don’t worry about it in the meanwhile.)'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '（如果你仔细观察，你可能已经注意到我们在`(R : Type*)`中将圆括号改为了花括号`{R : Type*}`。这表示`R`是一个*隐式参数*。我们稍后会解释这意味着什么，但在此期间不必担心。）'
- en: 'Here is a useful theorem:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有用的定理：
- en: '[PRE171]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Prove the companion version:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 证明其伴随版本：
- en: '[PRE172]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Use these to prove the following:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些来证明以下内容：
- en: '[PRE173]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: With enough planning, you can do each of them with three rewrites.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 通过足够的规划，你可以用三次重写来完成每一个。
- en: 'We will now explain the use of the curly braces. Imagine you are in a situation
    where you have `a`, `b`, and `c` in your context, as well as a hypothesis `h :
    a + b = a + c`, and you would like to draw the conclusion `b = c`. In Lean, you
    can apply a theorem to hypotheses and facts just the same way that you can apply
    them to objects, so you might think that `add_left_cancel a b c h` is a proof
    of the fact `b = c`. But notice that explicitly writing `a`, `b`, and `c` is redundant,
    because the hypothesis `h` makes it clear that those are the objects we have in
    mind. In this case, typing a few extra characters is not onerous, but if we wanted
    to apply `add_left_cancel` to more complicated expressions, writing them would
    be tedious. In cases like these, Lean allows us to mark arguments as *implicit*,
    meaning that they are supposed to be left out and inferred by other means, such
    as later arguments and hypotheses. The curly brackets in `{a b c : R}` do exactly
    that. So, given the statement of the theorem above, the correct expression is
    simply `add_left_cancel h`.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们将解释花括号的使用。想象一下，你处于一个情境，其中你的上下文中有`a`、`b`和`c`，以及一个假设`h : a + b = a + c`，你想要得出结论`b
    = c`。在Lean中，你可以像对对象一样对假设和事实应用定理，所以你可能认为`add_left_cancel a b c h`是`b = c`这个事实的证明。但请注意，明确写出`a`、`b`和`c`是多余的，因为假设`h`清楚地表明了这些是我们心中的对象。在这种情况下，输入一些额外的字符并不麻烦，但如果我们要将`add_left_cancel`应用于更复杂的表达式，编写它们将会很繁琐。在这些情况下，Lean允许我们将参数标记为*隐式*，这意味着它们应该被省略，并通过其他方式推断，例如后续的参数和假设。`{a
    b c : R}`中的花括号正是如此。因此，给定上述定理的陈述，正确的表达式仅仅是`add_left_cancel h`。'
- en: To illustrate, let us show that `a * 0 = 0` follows from the ring axioms.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，让我们展示`a * 0 = 0`可以从环公理中得出。
- en: '[PRE174]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'We have used a new trick! If you step through the proof, you can see what is
    going on. The `have` tactic introduces a new goal, `a * 0 + a * 0 = a * 0 + 0`,
    with the same context as the original goal. The fact that the next line is indented
    indicates that Lean is expecting a block of tactics that serves to prove this
    new goal. The indentation therefore promotes a modular style of proof: the indented
    subproof establishes the goal that was introduced by the `have`. After that, we
    are back to proving the original goal, except a new hypothesis `h` has been added:
    having proved it, we are now free to use it. At this point, the goal is exactly
    the result of `add_left_cancel h`.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个新技巧！如果你逐步查看证明过程，你可以看到正在发生什么。`have` 策略引入了一个新的目标，`a * 0 + a * 0 = a * 0
    + 0`，与原始目标具有相同的上下文。下一行缩进的事实表明 Lean 预期一个用于证明这个新目标的策略块。因此，缩进促进了模块化证明风格：缩进的子证明建立了由
    `have` 引入的目标。之后，我们回到证明原始目标，除了增加了一个新的假设 `h`：证明它之后，我们现在可以自由使用它。此时，目标正好是 `add_left_cancel
    h` 的结果。
- en: We could equally well have closed the proof with `apply add_left_cancel h` or
    `exact add_left_cancel h`. The `exact` tactic takes as argument a proof term which
    completely proves the current goal, without creating any new goal. The `apply`
    tactic is a variant whose argument is not necessarily a complete proof. The missing
    pieces are either inferred automatically by Lean or become new goals to prove.
    While the `exact` tactic is technically redundant since it is strictly less powerful
    than `apply`, it makes proof scripts slightly clearer to human readers and easier
    to maintain when the library evolves.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 我们同样可以用 `apply add_left_cancel h` 或 `exact add_left_cancel h` 来结束证明。`exact`
    策略的参数是一个完全证明当前目标的证明项，而不创建任何新的目标。`apply` 策略是一个变体，其参数不一定是完整的证明。缺失的部分要么由 Lean 自动推断，要么成为需要证明的新目标。虽然
    `exact` 策略在技术上可能是多余的，因为它严格不如 `apply` 强大，但它使证明脚本对人类读者来说更清晰，并且在库演变时更容易维护。
- en: Remember that multiplication is not assumed to be commutative, so the following
    theorem also requires some work.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，乘法不一定假设是交换的，所以下面的定理也需要一些工作。
- en: '[PRE175]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: By now, you should also be able replace each `sorry` in the next exercise with
    a proof, still using only facts about rings that we have established in this section.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你也应该能够用证明替换下一个练习中的每个 `sorry`，仍然只使用我们在本节中建立的关于环的事实。
- en: '[PRE176]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'We had to use the annotation `(-0 : R)` instead of `0` in the third theorem
    because without specifying `R` it is impossible for Lean to infer which `0` we
    have in mind, and by default it would be interpreted as a natural number.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '在第三个定理中，我们不得不使用注释 `(-0 : R)` 而不是 `0`，因为没有指定 `R`，Lean 无法推断我们心中所想的 `0` 是什么，默认情况下它会被解释为自然数。'
- en: In Lean, subtraction in a ring is provably equal to addition of the additive
    inverse.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lean 中，环中的减法可以证明等于加法上的加法逆元。
- en: '[PRE177]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'On the real numbers, it is *defined* that way:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在实数上，它是这样定义的：
- en: '[PRE178]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'The proof term `rfl` is short for “reflexivity”. Presenting it as a proof of
    `a - b = a + -b` forces Lean to unfold the definition and recognize both sides
    as being the same. The `rfl` tactic does the same. This is an instance of what
    is known as a *definitional equality* in Lean’s underlying logic. This means that
    not only can one rewrite with `sub_eq_add_neg` to replace `a - b = a + -b`, but
    in some contexts, when dealing with the real numbers, you can use the two sides
    of the equation interchangeably. For example, you now have enough information
    to prove the theorem `self_sub` from the last section:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 证明项 `rfl` 是“自反性”的缩写。将其作为 `a - b = a + -b` 的证明迫使 Lean 展开定义并识别两边的相同。`rfl` 策略做的是同样的事情。这是
    Lean 内在逻辑中所谓的 *定义性等价* 的一个例子。这意味着不仅可以用 `sub_eq_add_neg` 来重写 `a - b = a + -b`，而且在某些上下文中，当处理实数时，你可以将方程的两边互换使用。例如，你现在有足够的信息来证明上一节中的定理
    `self_sub`：
- en: '[PRE179]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Show that you can prove this using `rw`, but if you replace the arbitrary ring
    `R` by the real numbers, you can also prove it using either `apply` or `exact`.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 展示你可以使用 `rw` 来证明这一点，但如果将任意的环 `R` 替换为实数，你也可以使用 `apply` 或 `exact` 来证明它。
- en: 'Lean knows that `1 + 1 = 2` holds in any ring. With a bit of effort, you can
    use that to prove the theorem `two_mul` from the last section:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 知道 `1 + 1 = 2` 在任何环中都成立。通过一点努力，你可以用它来证明上一节中的定理 `two_mul`：
- en: '[PRE180]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'We close this section by noting that some of the facts about addition and negation
    that we established above do not need the full strength of the ring axioms, or
    even commutativity of addition. The weaker notion of a *group* can be axiomatized
    as follows:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节的结尾指出，我们上面建立的一些关于加法和否定的事实不需要环公理的全部力量，甚至不需要加法的交换性。一个 *群* 的较弱概念可以如下公理化：
- en: '[PRE181]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: It is conventional to use additive notation when the group operation is commutative,
    and multiplicative notation otherwise. So Lean defines a multiplicative version
    as well as the additive version (and also their abelian variants, `AddCommGroup`
    and `CommGroup`).
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 当群运算交换时，使用加法符号是惯例，否则使用乘法符号。因此，Lean 定义了乘法版本以及加法版本（以及它们的阿贝尔变体，`AddCommGroup` 和
    `CommGroup`）。
- en: '[PRE182]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: If you are feeling cocky, try proving the following facts about groups, using
    only these axioms. You will need to prove a number of helper lemmas along the
    way. The proofs we have carried out in this section provide some hints.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感到自信，尝试使用这些公理证明以下关于群的事实。在过程中，你需要证明许多辅助引理。本节中我们进行的证明提供了一些提示。
- en: '[PRE183]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Explicitly invoking those lemmas is tedious, so Mathlib provides tactics similar
    to ring in order to cover most uses: group is for non-commutative multiplicative
    groups, abel for abelian additive groups, and noncomm_ring for non-commutative
    rings. It may seem odd that the algebraic structures are called Ring and CommRing
    while the tactics are named noncomm_ring and ring. This is partly for historical
    reasons, but also for the convenience of using a shorter name for the tactic that
    deals with commutative rings, since it is used more often.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 明确调用这些引理是繁琐的，因此 Mathlib 提供了类似于环的策略来覆盖大多数用法：`group` 用于非交换乘法群，`abel` 用于阿贝尔加法群，`noncomm_ring`
    用于非交换环。看起来很奇怪，代数结构被称为 Ring 和 CommRing，而策略被命名为 noncomm_ring 和 ring。这部分是历史原因，但也为了方便使用更短的名称来处理交换环的策略，因为它使用得更频繁。
- en: '## 2.3\. Using Theorems and Lemmas[](#using-theorems-and-lemmas "Link to this
    heading")'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '## 2.3\. 使用定理和引理[](#using-theorems-and-lemmas "链接到本标题")'
- en: Rewriting is great for proving equations, but what about other sorts of theorems?
    For example, how can we prove an inequality, like the fact that \(a + e^b \le
    a + e^c\) holds whenever \(b \le c\)? We have already seen that theorems can be
    applied to arguments and hypotheses, and that the `apply` and `exact` tactics
    can be used to solve goals. In this section, we will make good use of these tools.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 重写对于证明方程非常有用，但对于其他类型的定理呢？例如，我们如何证明一个不等式，比如 \(a + e^b \le a + e^c\) 在 \(b \le
    c\) 时总是成立？我们已经看到定理可以应用于论点和假设，并且可以使用 `apply` 和 `exact` 策略来解决目标。在本节中，我们将充分利用这些工具。
- en: 'Consider the library theorems `le_refl` and `le_trans`:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑库定理 `le_refl` 和 `le_trans`：
- en: '[PRE184]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'As we explain in more detail in [Section 3.1](C03_Logic.html#implication-and-the-universal-quantifier),
    the implicit parentheses in the statement of `le_trans` associate to the right,
    so it should be interpreted as `a ≤ b → (b ≤ c → a ≤ c)`. The library designers
    have set the arguments `a`, `b` and `c` to `le_trans` implicit, so that Lean will
    *not* let you provide them explicitly (unless you really insist, as we will discuss
    later). Rather, it expects to infer them from the context in which they are used.
    For example, when hypotheses `h : a ≤ b` and `h'' : b ≤ c` are in the context,
    all the following work:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '如我们在[第 3.1 节](C03_Logic.html#implication-and-the-universal-quantifier)中更详细地解释的那样，`le_trans`
    声明中的隐式括号与右侧关联，因此它应该被解释为 `a ≤ b → (b ≤ c → a ≤ c)`。库设计者已经将 `a`、`b` 和 `c` 设置为 `le_trans`
    的隐式参数，这样 Lean 就不会让你明确地提供它们（除非你真的坚持，我们稍后会讨论）。相反，它期望从它们被使用的上下文中推断它们。例如，当假设 `h :
    a ≤ b` 和 `h'' : b ≤ c` 在上下文中时，以下所有内容都有效：'
- en: '[PRE185]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'The `apply` tactic takes a proof of a general statement or implication, tries
    to match the conclusion with the current goal, and leaves the hypotheses, if any,
    as new goals. If the given proof matches the goal exactly (modulo *definitional*
    equality), you can use the `exact` tactic instead of `apply`. So, all of these
    work:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply` 策略接受一个一般陈述或蕴涵的证明，尝试将结论与当前目标匹配，并将假设（如果有的话）作为新目标留下。如果给定的证明与目标完全匹配（模 *定义性*
    等价），则可以使用 `exact` 策略代替 `apply`。所以，所有这些都有效：'
- en: '[PRE186]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'In the first example, applying `le_trans` creates two goals, and we use the
    dots to indicate where the proof of each begins. The dots are optional, but they
    serve to *focus* the goal: within the block introduced by the dot, only one goal
    is visible, and it must be completed before the end of the block. Here we end
    the first block by starting a new one with another dot. We could just as well
    have decreased the indentation. In the third example and in the last example,
    we avoid going into tactic mode entirely: `le_trans h₀ h₁` and `le_refl x` are
    the proof terms we need.'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，应用 `le_trans` 创建了两个目标，我们使用点来表示每个证明的开始位置。点是可以省略的，但它们有助于 *聚焦* 目标：在点引入的块内，只有一个目标可见，并且必须在块的末尾之前完成。在这里，我们通过用另一个点开始一个新的块来结束第一个块。我们也可以减少缩进。在第三个例子和最后一个例子中，我们完全避免了进入策略模式：`le_trans
    h₀ h₁` 和 `le_refl x` 是我们需要证明的项。
- en: 'Here are a few more library theorems:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些更多的库定理：
- en: '[PRE187]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Use them together with `apply` and `exact` to prove the following:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们与 `apply` 和 `exact` 结合起来，以证明以下内容：
- en: '[PRE188]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'In fact, Lean has a tactic that does this sort of thing automatically:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Lean 有一种策略可以自动完成这类事情：
- en: '[PRE189]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: The `linarith` tactic is designed to handle *linear arithmetic*.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '`linarith` 策略被设计用来处理 *线性代数*。'
- en: '[PRE190]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: In addition to equations and inequalities in the context, `linarith` will use
    additional inequalities that you pass as arguments. In the next example, `exp_le_exp.mpr
    h'` is a proof of `exp b ≤ exp c`, as we will explain in a moment. Notice that,
    in Lean, we write `f x` to denote the application of a function `f` to the argument
    `x`, exactly the same way we write `h x` to denote the result of applying a fact
    or theorem `h` to the argument `x`. Parentheses are only needed for compound arguments,
    as in `f (x + y)`. Without the parentheses, `f x + y` would be parsed as `(f x)
    + y`.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上下文中的方程和不等式之外，`linarith` 还会使用你作为参数传递的额外不等式。在下一个例子中，`exp_le_exp.mpr h'` 是 `exp
    b ≤ exp c` 的证明，我们将在下一刻解释。请注意，在 Lean 中，我们用 `f x` 来表示函数 `f` 对参数 `x` 的应用，这与我们用 `h
    x` 来表示事实或定理 `h` 对参数 `x` 的应用完全相同。括号仅用于复合参数，例如 `f (x + y)`。如果没有括号，`f x + y` 将被解析为
    `(f x) + y`。
- en: '[PRE191]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Here are some more theorems in the library that can be used to establish inequalities
    on the real numbers.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些库中的更多定理，可以用来在实数上建立不等式。
- en: '[PRE192]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'Some of the theorems, `exp_le_exp`, `exp_lt_exp` use a *bi-implication*, which
    represents the phrase “if and only if.” (You can type it in VS Code with `\lr`
    or `\iff`). We will discuss this connective in greater detail in the next chapter.
    Such a theorem can be used with `rw` to rewrite a goal to an equivalent one:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 一些定理，如 `exp_le_exp` 和 `exp_lt_exp`，使用 *双向蕴涵*，表示“当且仅当”的短语。（你可以在 VS Code 中使用 `\lr`
    或 `\iff` 来输入它）。我们将在下一章更详细地讨论这个连接词。这样的定理可以用 `rw` 将目标重写为等价的目标：
- en: '[PRE193]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'In this section, however, we will use the fact that if `h : A ↔ B` is such
    an equivalence, then `h.mp` establishes the forward direction, `A → B`, and `h.mpr`
    establishes the reverse direction, `B → A`. Here, `mp` stands for “modus ponens”
    and `mpr` stands for “modus ponens reverse.” You can also use `h.1` and `h.2`
    for `h.mp` and `h.mpr`, respectively, if you prefer. Thus the following proof
    works:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，在本节中，我们将使用以下事实：如果 `h : A ↔ B` 是这样的等价关系，那么 `h.mp` 建立了正向方向，`A → B`，而 `h.mpr`
    建立了反向方向，`B → A`。在这里，`mp` 代表“肯定前件”（modus ponens），而 `mpr` 代表“否定后件”（modus ponens
    reverse）。如果你愿意，你也可以使用 `h.1` 和 `h.2` 来代替 `h.mp` 和 `h.mpr`。因此，以下证明是有效的：'
- en: '[PRE194]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: The first line, `apply add_lt_add_of_lt_of_le`, creates two goals, and once
    again we use a dot to separate the proof of the first from the proof of the second.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行，`apply add_lt_add_of_lt_of_le` 创建了两个目标，并且再次我们使用点来区分第一个证明和第二个证明。
- en: Try the following examples on your own. The example in the middle shows you
    that the `norm_num` tactic can be used to solve concrete numeric goals.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下示例。中间的示例显示你可以使用 `norm_num` 策略来解决具体的数值目标。
- en: '[PRE195]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'From these examples, it should be clear that being able to find the library
    theorems you need constitutes an important part of formalization. There are a
    number of strategies you can use:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些例子中，应该很明显，能够找到你需要的库定理是形式化的重要组成部分。你可以使用多种策略：
- en: You can browse Mathlib in its [GitHub repository](https://github.com/leanprover-community/mathlib4).
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 [GitHub 仓库](https://github.com/leanprover-community/mathlib4) 中浏览 Mathlib。
- en: You can use the API documentation on the Mathlib [web pages](https://leanprover-community.github.io/mathlib4_docs/).
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 Mathlib [网页](https://leanprover-community.github.io/mathlib4_docs/) 上的
    API 文档。
- en: You can use Loogle <https://loogle.lean-lang.org> to search Lean and Mathlib
    definitions and theorems by patterns.
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 Loogle <https://loogle.lean-lang.org> 通过模式搜索 Lean 和 Mathlib 的定义和定理。
- en: You can rely on Mathlib naming conventions and Ctrl-space completion in the
    editor to guess a theorem name (or Cmd-space on a Mac keyboard). In Lean, a theorem
    named `A_of_B_of_C` establishes something of the form `A` from hypotheses of the
    form `B` and `C`, where `A`, `B`, and `C` approximate the way we might read the
    goals out loud. So a theorem establishing something like `x + y ≤ ...` will probably
    start with `add_le`. Typing `add_le` and hitting Ctrl-space will give you some
    helpful choices. Note that hitting Ctrl-space twice displays more information
    about the available completions.
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以依靠 Mathlib 的命名约定和编辑器中的 Ctrl-space 完成功能来猜测定理名称（或在 Mac 键盘上按 Cmd-space）。在 Lean
    中，名为 `A_of_B_of_C` 的定理从形式为 `B` 和 `C` 的假设中建立 `A`，其中 `A`、`B` 和 `C` 大致对应于我们大声读出目标的方式。因此，建立类似
    `x + y ≤ ...` 的定理可能以 `add_le` 开头。键入 `add_le` 并按 Ctrl-space 将提供一些有用的选择。请注意，按 Ctrl-space
    两次将显示有关可用完成信息的更多信息。
- en: If you right-click on an existing theorem name in VS Code, the editor will show
    a menu with the option to jump to the file where the theorem is defined, and you
    can find similar theorems nearby.
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你右键单击 VS Code 中的一个现有定理名称，编辑器将显示一个菜单，其中包含跳转到定理定义文件的选项，你可以在附近找到类似定理。
- en: You can use the `apply?` tactic, which tries to find the relevant theorem in
    the library.
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `apply?` 策略，它会尝试在库中找到相关的定理。
- en: '[PRE196]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'To try out `apply?` in this example, delete the `exact` command and uncomment
    the previous line. Using these tricks, see if you can find what you need to do
    the next example:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试在这个例子中应用 `apply?`，请删除 `exact` 命令并取消注释上一行。使用这些技巧，看看你是否能找到完成下一个例子所需的内容：
- en: '[PRE197]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: Using the same tricks, confirm that `linarith` instead of `apply?` can also
    finish the job.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的技巧，确认 `linarith` 而不是 `apply?` 也可以完成这项工作。
- en: 'Here is another example of an inequality:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个不等式的例子：
- en: '[PRE198]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Mathlib tends to put spaces around binary operations like `*` and `^`, but in
    this example, the more compressed format increases readability. There are a number
    of things worth noticing. First, an expression `s ≥ t` is definitionally equivalent
    to `t ≤ s`. In principle, this means one should be able to use them interchangeably.
    But some of Lean’s automation does not recognize the equivalence, so Mathlib tends
    to favor `≤` over `≥`. Second, we have used the `ring` tactic extensively. It
    is a real timesaver! Finally, notice that in the second line of the second `calc`
    proof, instead of writing `by exact add_le_add (le_refl _) h`, we can simply write
    the proof term `add_le_add (le_refl _) h`.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib 倾向于在二进制运算符如 `*` 和 `^` 的周围放置空格，但在这个例子中，更紧凑的格式提高了可读性。有几个值得注意的地方。首先，表达式
    `s ≥ t` 在定义上是等价于 `t ≤ s` 的。原则上，这意味着应该能够互换使用它们。但是 Lean 的一些自动化工具没有识别出这种等价性，因此 Mathlib
    倾向于更喜欢 `≤` 而不是 `≥`。其次，我们广泛使用了 `ring` 策略。这是一个真正的省时工具！最后，请注意，在第二个 `calc` 证明的第二行中，我们不需要写
    `by exact add_le_add (le_refl _) h`，我们可以简单地写证明项 `add_le_add (le_refl _) h`。
- en: 'In fact, the only cleverness in the proof above is figuring out the hypothesis
    `h`. Once we have it, the second calculation involves only linear arithmetic,
    and `linarith` can handle it:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，上述证明中唯一的巧妙之处在于找出假设 `h`。一旦我们找到了它，第二个计算就只涉及线性算术，而 `linarith` 可以处理它：
- en: '[PRE199]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: How nice! We challenge you to use these ideas to prove the following theorem.
    You can use the theorem `abs_le'.mpr`. You will also need the `constructor` tactic
    to split a conjunction to two goals; see [Section 3.4](C03_Logic.html#conjunction-and-biimplication).
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 多么好！我们挑战你使用这些想法来证明以下定理。你可以使用定理 `abs_le'.mpr`。你还需要使用 `constructor` 策略将合取分解为两个目标；参见[第
    3.4 节](C03_Logic.html#conjunction-and-biimplication)。
- en: '[PRE200]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: If you managed to solve this, congratulations! You are well on your way to becoming
    a master formalizer.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你设法解决了这个问题，恭喜你！你正朝着成为一位大师级形式化专家的道路上迈进。
- en: '## 2.4\. More examples using apply and rw[](#more-examples-using-apply-and-rw
    "Link to this heading")'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '## 2.4\. 使用 apply 和 rw 的更多示例[](#more-examples-using-apply-and-rw "链接到这个标题")'
- en: 'The `min` function on the real numbers is uniquely characterized by the following
    three facts:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 实数上的 `min` 函数由以下三个事实唯一确定：
- en: '[PRE201]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: Can you guess the names of the theorems that characterize `max` in a similar
    way?
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜出那些以类似方式描述 `max` 的定理的名字吗？
- en: Notice that we have to apply `min` to a pair of arguments `a` and `b` by writing
    `min a b` rather than `min (a, b)`. Formally, `min` is a function of type `ℝ →
    ℝ → ℝ`. When we write a type like this with multiple arrows, the convention is
    that the implicit parentheses associate to the right, so the type is interpreted
    as `ℝ → (ℝ → ℝ)`. The net effect is that if `a` and `b` have type `ℝ` then `min
    a` has type `ℝ → ℝ` and `min a b` has type `ℝ`, so `min` acts like a function
    of two arguments, as we expect. Handling multiple arguments in this way is known
    as *currying*, after the logician Haskell Curry.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须通过编写 `min a b` 而不是 `min (a, b)` 来将 `min` 应用到一对参数 `a` 和 `b` 上。形式上，`min`
    是一个类型为 `ℝ → ℝ → ℝ` 的函数。当我们用多个箭头写出这样的类型时，惯例是隐式括号向右结合，因此类型被解释为 `ℝ → (ℝ → ℝ)`。最终的效果是，如果
    `a` 和 `b` 的类型为 `ℝ`，那么 `min a` 的类型为 `ℝ → ℝ`，而 `min a b` 的类型为 `ℝ`，所以 `min` 的行为就像一个接受两个参数的函数，正如我们所期望的那样。以这种方式处理多个参数的方法被称为
    *currying*，这是以逻辑学家 Haskell Curry 命名的。
- en: The order of operations in Lean can also take some getting used to. Function
    application binds tighter than infix operations, so the expression `min a b +
    c` is interpreted as `(min a b) + c`. With time, these conventions will become
    second nature.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 中运算的顺序也需要一些时间来习惯。函数应用比中缀操作绑定得更紧，所以表达式 `min a b + c` 被解释为 `(min a b) + c`。随着时间的推移，这些惯例将变得习以为常。
- en: 'Using the theorem `le_antisymm`, we can show that two real numbers are equal
    if each is less than or equal to the other. Using this and the facts above, we
    can show that `min` is commutative:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 使用定理 `le_antisymm`，我们可以证明如果每个数都小于或等于另一个数，那么两个实数是相等的。利用这一点和上述事实，我们可以证明 `min`
    是可交换的：
- en: '[PRE202]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Here we have used dots to separate proofs of different goals. Our usage is
    inconsistent: at the outer level, we use dots and indentation for both goals,
    whereas for the nested proofs, we use dots only until a single goal remains. Both
    conventions are reasonable and useful. We also use the `show` tactic to structure
    the proof and indicate what is being proved in each block. The proof still works
    without the `show` commands, but using them makes the proof easier to read and
    maintain.'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了点来分隔不同目标证明。我们的用法不一致：在外层，我们使用点和缩进来表示两个目标，而对于嵌套证明，我们只使用点，直到只剩下一个目标。这两种惯例都是合理且有用的。我们还使用
    `show` 策略来结构化证明并指示每个块中正在证明的内容。即使没有 `show` 命令，证明仍然有效，但使用它们可以使证明更容易阅读和维护。
- en: 'It may bother you that the proof is repetitive. To foreshadow skills you will
    learn later on, we note that one way to avoid the repetition is to state a local
    lemma and then use it:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会让你感到烦恼的是，证明是重复的。为了预示你以后将学习到的技能，我们注意到避免重复的一种方法就是陈述一个局部引理然后使用它：
- en: '[PRE203]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: We will say more about the universal quantifier in [Section 3.1](C03_Logic.html#implication-and-the-universal-quantifier),
    but suffice it to say here that the hypothesis `h` says that the desired inequality
    holds for any `x` and `y`, and the `intro` tactic introduces an arbitrary `x`
    and `y` to establish the conclusion. The first `apply` after `le_antisymm` implicitly
    uses `h a b`, whereas the second one uses `h b a`.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第 3.1 节](C03_Logic.html#implication-and-the-universal-quantifier) 中详细介绍全称量词，但在这里只需说，假设
    `h` 表示对于任何 `x` 和 `y`，所期望的不等式都成立，而 `intro` 策略通过引入任意的 `x` 和 `y` 来建立结论。在 `le_antisymm`
    之后的第一个 `apply` 隐式地使用了 `h a b`，而第二个则使用了 `h b a`。
- en: Another solution is to use the `repeat` tactic, which applies a tactic (or a
    block) as many times as it can.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是使用 `repeat` 策略，它可以尽可能多次地应用策略（或一个块）。
- en: '[PRE204]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: We encourage you to prove the following as exercises. You can use either of
    the tricks just described to shorten the first.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励您将以下内容作为练习来证明。您可以使用刚刚描述的任何一种技巧来简化第一个。
- en: '[PRE205]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: Of course, you are welcome to prove the associativity of `max` as well.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以证明 `max` 的结合性。
- en: It is an interesting fact that `min` distributes over `max` the way that multiplication
    distributes over addition, and vice-versa. In other words, on the real numbers,
    we have the identity `min a (max b c) = max (min a b) (min a c)` as well as the
    corresponding version with `max` and `min` switched. But in the next section we
    will see that this does *not* follow from the transitivity and reflexivity of
    `≤` and the characterizing properties of `min` and `max` enumerated above. We
    need to use the fact that `≤` on the real numbers is a *total order*, which is
    to say, it satisfies `∀ x y, x ≤ y ∨ y ≤ x`. Here the disjunction symbol, `∨`,
    represents “or”. In the first case, we have `min x y = x`, and in the second case,
    we have `min x y = y`. We will learn how to reason by cases in [Section 3.5](C03_Logic.html#disjunction),
    but for now we will stick to examples that don’t require the case split.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的事实是 `min` 在 `max` 上的分配方式与乘法在加法上的分配方式相同，反之亦然。换句话说，在实数上，我们有恒等式 `min a (max
    b c) = max (min a b) (min a c)`，以及相应地交换 `max` 和 `min` 的版本。但在下一节中，我们将看到这并不从 `≤`
    的传递性和自反性以及上述 `min` 和 `max` 的特征属性中得出。我们需要使用实数上的 `≤` 是一个 *全序* 的这一事实，也就是说，它满足 `∀
    x y, x ≤ y ∨ y ≤ x`。这里的析取符号，`∨`，代表“或”。在第一种情况下，我们有 `min x y = x`，在第二种情况下，我们有 `min
    x y = y`。我们将在 [第 3.5 节](C03_Logic.html#disjunction)中学习如何进行分情况推理，但就目前而言，我们将坚持使用不需要分情况分析的例子。
- en: 'Here is one such example:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个这样的例子：
- en: '[PRE206]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: It is clear that `aux` provides one of the two inequalities needed to prove
    the equality, but applying it to suitable values yields the other direction as
    well. As a hint, you can use the theorem `add_neg_cancel_right` and the `linarith`
    tactic.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`aux` 提供了证明等式所需两个不等式之一，但将其应用于合适的值也会得到另一个方向。作为一个提示，你可以使用定理 `add_neg_cancel_right`
    和 `linarith` 策略。
- en: 'Lean’s naming convention is made manifest in the library’s name for the triangle
    inequality:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 的命名约定在库中三角不等式的名称中得到了体现：
- en: '[PRE207]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'Use it to prove the following variant, using also `add_sub_cancel_right`:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它来证明以下变体，同时使用 `add_sub_cancel_right`：
- en: '[PRE208]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: See if you can do this in three lines or less. You can use the theorem `sub_add_cancel`.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能在三行或更少的文字中完成这个任务。你可以使用定理 `sub_add_cancel`。
- en: 'Another important relation that we will make use of in the sections to come
    is the divisibility relation on the natural numbers, `x ∣ y`. Be careful: the
    divisibility symbol is *not* the ordinary bar on your keyboard. Rather, it is
    a unicode character obtained by typing `\|` in VS Code. By convention, Mathlib
    uses `dvd` to refer to it in theorem names.'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将使用的一个重要关系是自然数上的可除性关系，`x ∣ y`。请注意：可除性符号 *不是* 你键盘上的普通竖线。而是通过在 VS Code
    中输入 `\|` 获得的 unicode 字符。按照惯例，Mathlib 在定理名称中使用 `dvd` 来指代它。
- en: '[PRE209]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'In the last example, the exponent is a natural number, and applying `dvd_mul_left`
    forces Lean to expand the definition of `x^2` to `x^1 * x`. See if you can guess
    the names of the theorems you need to prove the following:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，指数是一个自然数，应用 `dvd_mul_left` 会迫使 Lean 展开定义 `x^2` 为 `x^1 * x`。看看你是否能猜出你需要证明以下定理的名称：
- en: '[PRE210]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'With respect to divisibility, the *greatest common divisor*, `gcd`, and least
    common multiple, `lcm`, are analogous to `min` and `max`. Since every number divides
    `0`, `0` is really the greatest element with respect to divisibility:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 在除法方面，*最大公约数*，`gcd`，和最小公倍数，`lcm`，类似于 `min` 和 `max`。由于每个数都能整除 `0`，所以 `0` 真的是除法意义上的最大元素：
- en: '[PRE211]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'See if you can guess the names of the theorems you will need to prove the following:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能猜出你需要证明以下定理的名称：
- en: '[PRE212]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'Hint: you can use `dvd_antisymm`, but if you do, Lean will complain that the
    expression is ambiguous between the generic theorem and the version `Nat.dvd_antisymm`,
    the one specifically for the natural numbers. You can use `_root_.dvd_antisymm`
    to specify the generic one; either one will work.'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：你可以使用 `dvd_antisymm`，但如果你这样做，Lean 会抱怨表达式在通用定理和版本 `Nat.dvd_antisymm`（专门针对自然数的版本）之间是模糊的。你可以使用
    `_root_.dvd_antisymm` 来指定通用版本；两者都适用。
- en: '## 2.5\. Proving Facts about Algebraic Structures[](#proving-facts-about-algebraic-structures
    "Link to this heading")'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '## 2.5\. 证明关于代数结构的事实[](#proving-facts-about-algebraic-structures "链接到这个标题")'
- en: 'In [Section 2.2](#proving-identities-in-algebraic-structures), we saw that
    many common identities governing the real numbers hold in more general classes
    of algebraic structures, such as commutative rings. We can use any axioms we want
    to describe an algebraic structure, not just equations. For example, a *partial
    order* consists of a set with a binary relation that is reflexive, transitive,
    and antisymmetric. like `≤` on the real numbers. Lean knows about partial orders:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2.2 节](#proving-identities-in-algebraic-structures) 中，我们看到了许多常见的关于实数的恒等式在更一般的代数结构中同样成立，例如交换环。我们可以使用任何我们想要的公理来描述代数结构，而不仅仅是方程。例如，*偏序*
    由一个集合和二元关系组成，该关系是自反的、传递的和反对称的，就像实数上的 `≤`。Lean 了解偏序：
- en: '[PRE213]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Here we are adopting the Mathlib convention of using letters like `α`, `β`,
    and `γ` (entered as `\a`, `\b`, and `\g`) for arbitrary types. The library often
    uses letters like `R` and `G` for the carriers of algebraic structures like rings
    and groups, respectively, but in general Greek letters are used for types, especially
    when there is little or no structure associated with them.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们采用了 Mathlib 的约定，使用像 `α`、`β` 和 `γ`（输入为 `\a`、`\b` 和 `\g`）这样的字母表示任意类型。该库通常使用像
    `R` 和 `G` 这样的字母表示代数结构如环和群的载体，但通常希腊字母用于表示类型，尤其是在它们与很少或没有结构相关联时。
- en: Associated to any partial order, `≤`, there is also a *strict partial order*,
    `<`, which acts somewhat like `<` on the real numbers. Saying that `x` is less
    than `y` in this order is equivalent to saying that it is less-than-or-equal to
    `y` and not equal to `y`.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何偏序 `≤` 相关，也存在一个 *严格偏序* `<`，它在某种程度上类似于实数上的 `<`。在这个顺序中，说 `x` 小于 `y` 等同于说它小于或等于
    `y` 但不等于 `y`。
- en: '[PRE214]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: In this example, the symbol `∧` stands for “and,” the symbol `¬` stands for
    “not,” and `x ≠ y` abbreviates `¬ (x = y)`. In [Chapter 3](C03_Logic.html#logic),
    you will learn how to use these logical connectives to *prove* that `<` has the
    properties indicated.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，符号 `∧` 表示“和”，符号 `¬` 表示“非”，`x ≠ y` 简写为 `¬ (x = y)`。在 [第 3 章](C03_Logic.html#logic)
    中，您将学习如何使用这些逻辑连接词来 *证明* `<` 具有指示的性质。
- en: 'A *lattice* is a structure that extends a partial order with operations `⊓`
    and `⊔` that are analogous to `min` and `max` on the real numbers:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '*格* 是一个扩展了偏序并带有类似于实数上的 `min` 和 `max` 的操作 `⊓` 和 `⊔` 的结构：'
- en: '[PRE215]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'The characterizations of `⊓` and `⊔` justify calling them the *greatest lower
    bound* and *least upper bound*, respectively. You can type them in VS code using
    `\glb` and `\lub`. The symbols are also often called then *infimum* and the *supremum*,
    and Mathlib refers to them as `inf` and `sup` in theorem names. To further complicate
    matters, they are also often called *meet* and *join*. Therefore, if you work
    with lattices, you have to keep the following dictionary in mind:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '`⊓` 和 `⊔` 的特征使得它们分别被称为 *最大下界* 和 *最小上界*。您可以在 VS code 中使用 `\glb` 和 `\lub` 来输入它们。这些符号也常被称为
    *下确界* 和 *上确界*，Mathlib 在定理名称中称它们为 `inf` 和 `sup`。为了进一步复杂化问题，它们也常被称为 *交* 和 *并*。因此，如果您与格（lattices）一起工作，您必须记住以下字典：'
- en: '`⊓` is the *greatest lower bound*, *infimum*, or *meet*.'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`⊓` 是 *最大下界*、*下确界* 或 *交*。'
- en: '`⊔` is the *least upper bound*, *supremum*, or *join*.'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`⊔` 是 *最小上界*、*上确界* 或 *并*。'
- en: 'Some instances of lattices include:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 一些格的实例包括：
- en: '`min` and `max` on any total order, such as the integers or real numbers with
    `≤`'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何全序，如整数或实数上的 `≤`，的 `min` 和 `max`
- en: '`∩` and `∪` on the collection of subsets of some domain, with the ordering
    `⊆`'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合的子集上的 `∩` 和 `∪`，具有顺序 `⊆`
- en: '`∧` and `∨` on boolean truth values, with ordering `x ≤ y` if either `x` is
    false or `y` is true'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔真值上的 `∧` 和 `∨`，如果 `x` 为假或 `y` 为真，则顺序 `x ≤ y`
- en: '`gcd` and `lcm` on the natural numbers (or positive natural numbers), with
    the divisibility ordering, `∣`'
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自然数（或正自然数）上的 `gcd` 和 `lcm`，具有除法顺序 `∣`
- en: the collection of linear subspaces of a vector space, where the greatest lower
    bound is given by the intersection, the least upper bound is given by the sum
    of the two spaces, and the ordering is inclusion
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量空间的线性子空间的集合，其中最大下界由交集给出，最小上界由两个空间的和给出，顺序是包含
- en: the collection of topologies on a set (or, in Lean, a type), where the greatest
    lower bound of two topologies consists of the topology that is generated by their
    union, the least upper bound is their intersection, and the ordering is reverse
    inclusion
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合上的拓扑（或在 Lean 中，类型）的集合，其中两个拓扑的最大下界是由它们的并集生成的拓扑，最小上界是它们的交集，顺序是反向包含
- en: You can check that, as with `min` / `max` and `gcd` / `lcm`, you can prove the
    commutativity and associativity of the infimum and supremum using only their characterizing
    axioms, together with `le_refl` and `le_trans`.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以检查，与`min`/`max`和`gcd`/`lcm`一样，你可以仅使用它们的特征公理以及`le_refl`和`le_trans`证明下确界和上确界的交换性和结合性：
- en: Using `apply le_trans` when seeing a goal `x ≤ z` is not a great idea. Indeed
    Lean has no way to guess which intermediate element `y` we want to use. So `apply
    le_trans` produces three goals that look like `x ≤ ?a`, `?a ≤ z` and `α` where
    `?a` (probably with a more complicated auto-generated name) stands for the mysterious
    `y`. The last goal, with type `α`, is to provide the value of `y`. It comes lasts
    because Lean hopes to automatically infer it from the proof of the first goal
    `x ≤ ?a`. In order to avoid this unappealing situation, you can use the `calc`
    tactic to explicitly provide `y`. Alternatively, you can use the `trans` tactic
    which takes `y` as an argument and produces the expected goals `x ≤ y` and `y
    ≤ z`. Of course you can also avoid this issue by providing directly a full proof
    such as `exact le_trans inf_le_left inf_le_right`, but this requires a lot more
    planning.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 当看到目标`x ≤ z`时使用`apply le_trans`不是一个好主意。实际上，Lean没有方法猜测我们想要使用哪个中间元素`y`。因此，`apply
    le_trans`会产生三个看起来像`x ≤ ?a`、`?a ≤ z`和`α`的目标，其中`?a`（可能有一个更复杂的自动生成的名称）代表神秘的`y`。最后一个目标，类型为`α`，是提供`y`的值。它最后出现，因为Lean希望从第一个目标`x
    ≤ ?a`的证明中自动推断它。为了避免这种不吸引人的情况，你可以使用`calc`策略显式提供`y`。或者，你可以使用接受`y`作为参数的`trans`策略，它会产生预期的目标`x
    ≤ y`和`y ≤ z`。当然，你也可以通过直接提供一个完整的证明来避免这个问题，例如`exact le_trans inf_le_left inf_le_right`，但这需要更多的计划。
- en: '[PRE216]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: You can find these theorems in the Mathlib as `inf_comm`, `inf_assoc`, `sup_comm`,
    and `sup_assoc`, respectively.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Mathlib中找到这些定理，分别命名为`inf_comm`、`inf_assoc`、`sup_comm`和`sup_assoc`。
- en: 'Another good exercise is to prove the *absorption laws* using only those axioms:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的练习是仅使用这些公理证明**吸收律**：
- en: '[PRE217]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: These can be found in Mathlib with the names `inf_sup_self` and `sup_inf_self`.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以在Mathlib中找到，名称分别为`inf_sup_self`和`sup_inf_self`。
- en: 'A lattice that satisfies the additional identities `x ⊓ (y ⊔ z) = (x ⊓ y) ⊔
    (x ⊓ z)` and `x ⊔ (y ⊓ z) = (x ⊔ y) ⊓ (x ⊔ z)` is called a *distributive lattice*.
    Lean knows about these too:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 满足额外恒等式`x ⊓ (y ⊔ z) = (x ⊓ y) ⊔ (x ⊓ z)`和`x ⊔ (y ⊓ z) = (x ⊔ y) ⊓ (x ⊔ z)`的格称为**分配格**。Lean也了解这些：
- en: '[PRE218]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'The left and right versions are easily shown to be equivalent, given the commutativity
    of `⊓` and `⊔`. It is a good exercise to show that not every lattice is distributive
    by providing an explicit description of a nondistributive lattice with finitely
    many elements. It is also a good exercise to show that in any lattice, either
    distributivity law implies the other:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧和右侧版本很容易证明是等价的，考虑到`⊓`和`⊔`的交换性。通过提供一个非分配格的显式描述，证明不是每个格都是分配的，这是一个很好的练习。同样，证明在任何格中，分配律中的任意一个都蕴含另一个，也是一个很好的练习：
- en: '[PRE219]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'It is possible to combine axiomatic structures into larger ones. For example,
    a *strict ordered ring* consists of a ring together with a partial order on the
    carrier satisfying additional axioms that say that the ring operations are compatible
    with the order:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将公理结构组合成更大的结构。例如，一个**严格有序环**由一个环以及一个在载体上的偏序组成，该偏序满足额外的公理，这些公理说明环运算与顺序是兼容的：
- en: '[PRE220]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[Chapter 3](C03_Logic.html#logic) will provide the means to derive the following
    from `mul_pos` and the definition of `<`:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](C03_Logic.html#logic)将提供从`mul_pos`和`<`的定义推导以下内容的方法：'
- en: '[PRE221]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'It is then an extended exercise to show that many common facts used to reason
    about arithmetic and the ordering on the real numbers hold generically for any
    ordered ring. Here are a couple of examples you can try, using only properties
    of rings, partial orders, and the facts enumerated in the last two examples (beware
    that those rings are not assumed to be commutative, so the ring tactic is not
    available):'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是一个扩展练习，用以证明许多用于对算术和实数排序进行推理的常见事实在任意有序环中普遍成立。这里有一些你可以尝试的例子，仅使用环的性质、偏序以及前两个例子中列出的事实（请注意，这些环并不假设是交换的，因此环策略不可用）：
- en: '[PRE222]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'Finally, here is one last example. A *metric space* consists of a set equipped
    with a notion of distance, `dist x y`, mapping any pair of elements to a real
    number. The distance function is assumed to satisfy the following axioms:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里有一个最后的例子。一个**度量空间**由一个集合组成，该集合具有距离的概念，`dist x y`，将任何一对元素映射到一个实数。距离函数假设满足以下公理：
- en: '[PRE223]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'Having mastered this section, you can show that it follows from these axioms
    that distances are always nonnegative:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握这一章节后，你可以证明以下公理意味着距离总是非负的：
- en: '[PRE224]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: We recommend making use of the theorem `nonneg_of_mul_nonneg_left`. As you may
    have guessed, this theorem is called `dist_nonneg` in Mathlib.*
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推荐使用定理 `nonneg_of_mul_nonneg_left`。正如你可能猜到的，这个定理在 Mathlib 中被称为 `dist_nonneg`*。
