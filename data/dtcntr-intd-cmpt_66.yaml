- en: 21Â Detecting CyclesğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 21Â æ£€æµ‹å¾ªç¯ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/cycle-detection.html](https://dcic-world.org/2025-08-27/cycle-detection.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/cycle-detection.html](https://dcic-world.org/2025-08-27/cycle-detection.html)
- en: '| Â Â Â Â [21.1Â A Running Example](#%28part._.A_.Running_.Example%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [21.1Â ä¸€ä¸ªè¿è¡Œç¤ºä¾‹](#%28part._.A_.Running_.Example%29) |'
- en: '| Â Â Â Â [21.2Â Types](#%28part._.Types%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [21.2Â ç±»å‹](#%28part._.Types%29) |'
- en: '| Â Â Â Â [21.3Â A First Checker](#%28part._.A_.First_.Checker%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [21.3Â ç¬¬ä¸€ä¸ªæ£€æŸ¥å™¨](#%28part._.A_.First_.Checker%29) |'
- en: '| Â Â Â Â [21.4Â Complexity](#%28part._cyc-det-comp%29) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [21.4Â å¤æ‚æ€§](#%28part._cyc-det-comp%29) |'
- en: '| Â Â Â Â [21.5Â A Fabulous Improvement](#%28part._.A_.Fabulous_.Improvement%29)
    |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [21.5Â ä¸€ä¸ªæƒŠäººçš„æ”¹è¿›](#%28part._.A_.Fabulous_.Improvement%29) |'
- en: '| Â Â Â Â [21.6Â Testing](#%28part._.Testing%29) |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [21.6Â æµ‹è¯•](#%28part._.Testing%29) |'
- en: 21.1Â A Running Example[ğŸ”—](#(part._.A_.Running_.Example) "Link to here")
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.1Â ä¸€ä¸ªè¿è¡Œç¤ºä¾‹[ğŸ”—](#(part._.A_.Running_.Example) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: As you may have noticed, Pyret will check for and print cycles. For instance,
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚ä½ æ‰€æ³¨æ„åˆ°çš„ï¼ŒPyret å°†æ£€æŸ¥å¹¶æ‰“å°å¾ªç¯ã€‚ä¾‹å¦‚ï¼Œ
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Do Now!
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¿›è¡Œï¼
- en: ''
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sketch out the above pairs to make sure you see all the cycles.
  id: totrans-13
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»˜åˆ¶ä¸Šè¿°å¯¹ï¼Œä»¥ç¡®ä¿ä½ èƒ½çœ‹åˆ°æ‰€æœ‰çš„å¾ªç¯ã€‚
- en: So we have two that participate in no cyclic behavior (`p0` and `p1`), two (`p2`
    and `p3` that are mutually-cyclic, one (`p6`) that is a self-cycle, and two (`p4`
    and `p5`) that lead to a cycle.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬æœ‰ä¸¤ä¸ªä¸å‚ä¸ä»»ä½•å¾ªç¯è¡Œä¸ºï¼ˆ`p0` å’Œ `p1`ï¼‰ï¼Œä¸¤ä¸ªï¼ˆ`p2` å’Œ `p3` æ˜¯ç›¸äº’å¾ªç¯çš„ï¼‰ï¼Œä¸€ä¸ªï¼ˆ`p6` æ˜¯è‡ªå¾ªç¯çš„ï¼‰ï¼Œä»¥åŠä¸¤ä¸ªï¼ˆ`p4`
    å’Œ `p5` å¯¼è‡´å¾ªç¯ï¼‰ã€‚
- en: 21.2Â Types[ğŸ”—](#(part._.Types) "Link to here")
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.2Â ç±»å‹[ğŸ”—](#(part._.Types) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'As an aside, imagine we try to type-check this program. We have to provide
    a type for `tl`, but itâ€™s not clear what this can be: sometimes itâ€™s a `Number`,
    and other times itâ€™s a `Pair`. However, we might observe that if our goal is to
    create cyclic data, then we want `tl` to refer to a `Pair` or to nothing at all.
    That suggests that a useful type is:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºå¦ä¸€ä¸ªæ—ç™½ï¼Œæƒ³è±¡æˆ‘ä»¬å°è¯•å¯¹è¿™ä¸ªç¨‹åºè¿›è¡Œç±»å‹æ£€æŸ¥ã€‚æˆ‘ä»¬å¿…é¡»ä¸º `tl` æä¾›ä¸€ä¸ªç±»å‹ï¼Œä½†è¿™ä¸ªç±»å‹æ˜¯ä»€ä¹ˆå¹¶ä¸æ¸…æ¥šï¼šæœ‰æ—¶å®ƒæ˜¯ä¸€ä¸ª `Number`ï¼Œæœ‰æ—¶å®ƒæ˜¯ä¸€ä¸ª
    `Pair`ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å¯èƒ½ä¼šè§‚å¯Ÿåˆ°ï¼Œå¦‚æœæˆ‘ä»¬çš„ç›®æ ‡æ˜¯åˆ›å»ºå¾ªç¯æ•°æ®ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¸Œæœ› `tl` æŒ‡å‘ä¸€ä¸ª `Pair` æˆ–è€…ä»€ä¹ˆéƒ½æ²¡æœ‰ã€‚è¿™è¡¨æ˜ä¸€ä¸ªæœ‰ç”¨çš„ç±»å‹æ˜¯ï¼š
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: so that we can write
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å†™
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This works, but we have to deal with the `Option` everywhere. Since our goal
    is to focus on cycles, and this would become unwieldy, we ignore the typed version
    from now on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯ä»¥å·¥ä½œï¼Œä½†æˆ‘ä»¬ä¸å¾—ä¸åœ¨æ‰€æœ‰åœ°æ–¹å¤„ç† `Option`ã€‚ç”±äºæˆ‘ä»¬çš„ç›®æ ‡æ˜¯å…³æ³¨å¾ªç¯ï¼Œè€Œä¸”è¿™ä¼šå˜å¾—éš¾ä»¥ç®¡ç†ï¼Œæ‰€ä»¥æˆ‘ä»¬ä»ç°åœ¨å¼€å§‹å¿½ç•¥æœ‰ç±»å‹çš„ç‰ˆæœ¬ã€‚
- en: 21.3Â A First Checker[ğŸ”—](#(part._.A_.First_.Checker) "Link to here")
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.3Â ç¬¬ä¸€ä¸ªæ£€æŸ¥å™¨[ğŸ”—](#(part._.A_.First_.Checker) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Okay, back to the untyped version.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½çš„ï¼Œå›åˆ°æ— ç±»å‹çš„ç‰ˆæœ¬ã€‚
- en: So letâ€™s try to figure out whether, given a Pair, it leads to a cycle. What
    should the type be?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥ï¼Œè®©æˆ‘ä»¬æ¥å°è¯•å¼„æ¸…æ¥šï¼Œç»™å®šä¸€ä¸ªå¯¹ï¼Œå®ƒæ˜¯å¦ä¼šå¯¼è‡´ä¸€ä¸ªå¾ªç¯ã€‚ç±»å‹åº”è¯¥æ˜¯ä»€ä¹ˆï¼Ÿ
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: where `cc` stands for â€œcheck cycleâ€.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­ `cc` ä»£è¡¨â€œæ£€æŸ¥å¾ªç¯â€ã€‚
- en: 'Critically, itâ€™s important that this be a total function: i.e., it always terminates.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: å…³é”®çš„æ˜¯ï¼Œè¿™åº”è¯¥æ˜¯ä¸€ä¸ªå…¨å‡½æ•°ï¼šå³ï¼Œå®ƒæ€»æ˜¯ç»ˆæ­¢ã€‚
- en: 'So letâ€™s write the most obvious solution:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥è®©æˆ‘ä»¬å†™å‡ºæœ€æ˜æ˜¾çš„è§£å†³æ–¹æ¡ˆï¼š
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'First of all, does this even terminate? It could take a while to visit all
    the nodes, but a cycle demands that somewhere, we revisit a node we saw before.
    Since we track that, we canâ€™t not terminate. Therefore, termination is guaranteed,
    and the function is total. Indeed, all these tests pass:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œè¿™ç”šè‡³èƒ½ç»ˆæ­¢å—ï¼Ÿè®¿é—®æ‰€æœ‰èŠ‚ç‚¹å¯èƒ½éœ€è¦ä¸€æ®µæ—¶é—´ï¼Œä½†å¾ªç¯è¦æ±‚æˆ‘ä»¬åœ¨æŸä¸ªåœ°æ–¹é‡æ–°è®¿é—®ä¹‹å‰å·²ç»çœ‹åˆ°çš„èŠ‚ç‚¹ã€‚ç”±äºæˆ‘ä»¬è·Ÿè¸ªè¿™ä¸€ç‚¹ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸èƒ½ä¸ç»ˆæ­¢ã€‚å› æ­¤ï¼Œç»ˆæ­¢æ˜¯ä¿è¯çš„ï¼Œå‡½æ•°æ˜¯å…¨çš„ã€‚ç¡®å®ï¼Œæ‰€æœ‰è¿™äº›æµ‹è¯•éƒ½é€šè¿‡äº†ï¼š
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As another aside, observe that we could have written these tests instead like
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºå¦ä¸€ä¸ªæ—ç™½ï¼Œæ³¨æ„æˆ‘ä»¬æœ¬æ¥å¯ä»¥åƒè¿™æ ·ç¼–å†™è¿™äº›æµ‹è¯•
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'which would be more concise, but that would also be misleading: it would suggest
    that `cc` is a desirable property, so `p2` is a â€œgoodâ€ instance and `p0` is a
    â€œbadâ€ one. However, `cc` is not a judgment of qualityâ€”<wbr>its two responses have
    equal weightâ€”<wbr>so this would be confusing to a later reader.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°†æ›´ç®€æ´ï¼Œä½†è¿™ä¹Ÿå¯èƒ½æ˜¯è¯¯å¯¼æ€§çš„ï¼šå®ƒå¯èƒ½ä¼šæš—ç¤º `cc` æ˜¯ä¸€ä¸ªæœŸæœ›çš„ç‰¹æ€§ï¼Œæ‰€ä»¥ `p2` æ˜¯ä¸€ä¸ªâ€œå¥½â€çš„å®ä¾‹ï¼Œè€Œ `p0` æ˜¯ä¸€ä¸ªâ€œåâ€çš„å®ä¾‹ã€‚ç„¶è€Œï¼Œ`cc`
    å¹¶ä¸æ˜¯å¯¹è´¨é‡çš„åˆ¤æ–­â€”â€”å®ƒçš„ä¸¤ä¸ªå“åº”å…·æœ‰ç›¸ç­‰çš„æƒé‡â€”â€”æ‰€ä»¥è¿™å¯¹åæ¥çš„è¯»è€…æ¥è¯´å¯èƒ½ä¼šé€ æˆå›°æƒ‘ã€‚
- en: 21.4Â Complexity[ğŸ”—](#(part._cyc-det-comp) "Link to here")
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.4Â å¤æ‚æ€§[ğŸ”—](#(part._cyc-det-comp) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Now that we have determined that it terminates, we can ask for its time and
    space complexity. First we have to decide what we are even computing the complexity
    over. If the sequence is finite, then the size is clearly the size of the sequence.
    But if itâ€™s infinite, we donâ€™t want to traverse the â€œwhole thingâ€: rather, we
    mean its finite part (excluding any repetition). So the meaningful measure in
    either case is the number of `p` nodes, i.e., the finite size. It may just be
    that some of these lead back to themselves, so that a naÃ¯ve traversal will go
    on forever.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»ç¡®å®šå®ƒå°†ç»ˆæ­¢ï¼Œæˆ‘ä»¬å¯ä»¥è¯¢é—®å…¶æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦ã€‚é¦–å…ˆæˆ‘ä»¬å¿…é¡»å†³å®šæˆ‘ä»¬åœ¨è®¡ç®—å¤æ‚åº¦æ—¶åˆ°åº•åœ¨è®¡ç®—ä»€ä¹ˆã€‚å¦‚æœåºåˆ—æ˜¯æœ‰é™çš„ï¼Œé‚£ä¹ˆå¤§å°æ˜¾ç„¶æ˜¯åºåˆ—çš„å¤§å°ã€‚ä½†å¦‚æœå®ƒæ˜¯æ— é™çš„ï¼Œæˆ‘ä»¬ä¸æƒ³éå†â€œæ•´ä¸ªåºåˆ—â€ï¼šæˆ‘ä»¬æŒ‡çš„æ˜¯å®ƒçš„æœ‰é™éƒ¨åˆ†ï¼ˆæ’é™¤ä»»ä½•é‡å¤ï¼‰ã€‚æ‰€ä»¥ä¸¤ç§æƒ…å†µä¸‹æœ‰æ„ä¹‰çš„åº¦é‡æ˜¯`p`èŠ‚ç‚¹çš„æ•°é‡ï¼Œå³æœ‰é™çš„å¤§å°ã€‚å¯èƒ½åªæ˜¯å…¶ä¸­ä¸€äº›ä¼šå›åˆ°è‡ªå·±ï¼Œæ‰€ä»¥ä¸€ä¸ªç®€å•çš„éå†ä¼šæ°¸è¿œè¿›è¡Œä¸‹å»ã€‚
- en: 'Okay, so we visit each node once. We keep track of all the nodes just in case
    we double back over, either until we run out of nodes or we repeat one. Therefore,
    the space complexity is linear in the length of the sum of the prefix (from the
    starting node) and the cycle. The time complexity is that but also, at each point,
    we have to check membership, so itâ€™s quadratic in the length of that prefix +
    cycle. So: linear space, quadratic time, in the size of the prefix + cycle.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½å§ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦è®¿é—®æ¯ä¸ªèŠ‚ç‚¹ä¸€æ¬¡ã€‚æˆ‘ä»¬è·Ÿè¸ªæ‰€æœ‰èŠ‚ç‚¹ï¼Œä»¥é˜²æˆ‘ä»¬å›å¤´ï¼Œç›´åˆ°æˆ‘ä»¬ç”¨å®ŒèŠ‚ç‚¹æˆ–é‡å¤ä¸€ä¸ªã€‚å› æ­¤ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯å‰ç¼€ï¼ˆä»èµ·å§‹èŠ‚ç‚¹ï¼‰å’Œå¾ªç¯é•¿åº¦çš„çº¿æ€§ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯é‚£ä¸ªï¼Œä½†åœ¨æ¯ä¸ªç‚¹ä¸Šï¼Œæˆ‘ä»¬éƒ½è¦æ£€æŸ¥æˆå‘˜èµ„æ ¼ï¼Œæ‰€ä»¥å®ƒæ˜¯å‰ç¼€+å¾ªç¯é•¿åº¦çš„äºŒæ¬¡ã€‚æ‰€ä»¥ï¼šçº¿æ€§ç©ºé—´ï¼ŒäºŒæ¬¡æ—¶é—´ï¼Œåœ¨å‰ç¼€+å¾ªç¯çš„å¤§å°ä¸Šã€‚
- en: 'Now, some degree of linear behavior is unavoidable: we clearly have to keep
    going until we run out or hit a cycle, so for detecting the cycle having something
    be linear in the size of the prefix (get it out of the way) + length of the cycle
    (find the cycle) seems essential. But can we improve on this complexity? It seems
    unlikely: by definition, how can we check for a cycle if we donâ€™t remember everything
    weâ€™ve seen?'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œä¸€å®šç¨‹åº¦çš„çº¿æ€§è¡Œä¸ºæ˜¯ä¸å¯é¿å…çš„ï¼šæˆ‘ä»¬æ˜¾ç„¶å¿…é¡»ç»§ç»­å‰è¿›ï¼Œç›´åˆ°æˆ‘ä»¬ç”¨å®Œæˆ–é‡åˆ°ä¸€ä¸ªå¾ªç¯ï¼Œæ‰€ä»¥ä¸ºäº†æ£€æµ‹å¾ªç¯ï¼Œè®©æŸç‰©ä¸å‰ç¼€çš„å¤§å°æˆçº¿æ€§å…³ç³»ï¼ˆæŠŠå®ƒå»æ‰ï¼‰+ å¾ªç¯çš„é•¿åº¦ï¼ˆæ‰¾åˆ°å¾ªç¯ï¼‰ä¼¼ä¹æ˜¯å¿…è¦çš„ã€‚ä½†æˆ‘ä»¬èƒ½æ”¹è¿›è¿™ä¸ªå¤æ‚åº¦å—ï¼Ÿè¿™ä¼¼ä¹ä¸å¤ªå¯èƒ½ï¼šæŒ‰ç…§å®šä¹‰ï¼Œå¦‚æœæˆ‘ä»¬ä¸è®°å¾—æˆ‘ä»¬æ‰€çœ‹åˆ°çš„ä¸€åˆ‡ï¼Œæˆ‘ä»¬æ€ä¹ˆèƒ½æ£€æŸ¥å¾ªç¯å‘¢ï¼Ÿ
- en: Our first hunch might be, â€œMaybe thereâ€™s another space-time tradeoff!â€ But itâ€™s
    not so clear here. Our space is linear and time quadratic, so we may think we
    can flip those around. But the time canâ€™t be less than the space! If, for instance,
    we had linear time and quadratic space, that wouldnâ€™t make sense, because weâ€™d
    need at least quadratic time just to fill the space. So thatâ€™s not going to work
    so well.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„ç¬¬ä¸€ç›´è§‰å¯èƒ½æ˜¯ï¼Œâ€œä¹Ÿè®¸è¿˜æœ‰å¦ä¸€ç§æ—¶ç©ºæƒè¡¡ï¼â€ä½†åœ¨è¿™é‡Œå¹¶ä¸é‚£ä¹ˆæ¸…æ¥šã€‚æˆ‘ä»¬çš„ç©ºé—´æ˜¯çº¿æ€§çš„ï¼Œæ—¶é—´æ˜¯äºŒæ¬¡çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯èƒ½è®¤ä¸ºæˆ‘ä»¬å¯ä»¥æŠŠå®ƒä»¬é¢ å€’è¿‡æ¥ã€‚ä½†æ—¶é—´ä¸èƒ½å°äºç©ºé—´ï¼ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬æœ‰çº¿æ€§æ—¶é—´å’ŒäºŒæ¬¡ç©ºé—´ï¼Œé‚£å°±æ²¡æœ‰æ„ä¹‰äº†ï¼Œå› ä¸ºæˆ‘ä»¬è‡³å°‘éœ€è¦äºŒæ¬¡æ—¶é—´æ¥å¡«å……ç©ºé—´ã€‚æ‰€ä»¥è¿™ä¸ä¼šå¾ˆå¥½ç”¨ã€‚
- en: Instead, the best way to improve seems to have a better lookup data structure.
    Weâ€™d still take linear spaceâ€”<wbr>as we said, linear was unavoidable (and we canâ€™t
    just be linear in the size of the cycle, because the whole point is we donâ€™t even
    know we have a cycle, much less which parts are prefix and which parts cycle)â€”<wbr>and
    the time complexity would hopefully reduce from quadratic to linear-times-something-sublinear.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åï¼Œä¼¼ä¹æœ€å¥½çš„æ”¹è¿›æ–¹æ³•æ˜¯æœ‰æ›´å¥½çš„æŸ¥æ‰¾æ•°æ®ç»“æ„ã€‚æˆ‘ä»¬ä»ç„¶ä¼šå ç”¨çº¿æ€§ç©ºé—´â€”â€”æ­£å¦‚æˆ‘ä»¬æ‰€è¯´çš„ï¼Œçº¿æ€§æ˜¯ä¸å¯é¿å…çš„ï¼ˆæˆ‘ä»¬ä¹Ÿä¸èƒ½åªæ˜¯åœ¨çº¿æ€§å¾ªç¯çš„å¤§å°ä¸Šä¿æŒçº¿æ€§ï¼Œå› ä¸ºæ•´ä¸ªç‚¹æ˜¯æˆ‘ä»¬ç”šè‡³ä¸çŸ¥é“æˆ‘ä»¬æœ‰ä¸€ä¸ªå¾ªç¯ï¼Œæ›´ä¸ç”¨è¯´å“ªäº›éƒ¨åˆ†æ˜¯å‰ç¼€å’Œå“ªäº›éƒ¨åˆ†æ˜¯å¾ªç¯äº†ï¼‰â€”â€”æ—¶é—´å¤æ‚åº¦æœ‰æœ›ä»äºŒæ¬¡é™ä½åˆ°çº¿æ€§ä¹˜ä»¥æŸä¸ªäºšçº¿æ€§ã€‚
- en: 21.5Â A Fabulous Improvement[ğŸ”—](#(part._.A_.Fabulous_.Improvement) "Link to here")
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.5 ä¸€ä¸ªäº†ä¸èµ·çš„æ”¹è¿›[ğŸ”—](#(part._.A_.Fabulous_.Improvement) "é“¾æ¥åˆ°æ­¤å¤„")
- en: It turns out we can do a lot better! Itâ€™s called the tortoise-and-hare algorithm.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æœè¯æ˜æˆ‘ä»¬å¯ä»¥åšå¾—æ›´å¥½ï¼è¿™è¢«ç§°ä¸ºä¹Œé¾Ÿå’Œå…”å­ç®—æ³•ã€‚
- en: We start off with two references into the sequence, one called the tortoise
    and the other the hare.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä»ä¸¤ä¸ªå¯¹åºåˆ—çš„å¼•ç”¨å¼€å§‹ï¼Œä¸€ä¸ªå«åšä¹Œé¾Ÿï¼Œå¦ä¸€ä¸ªå«åšå…”å­ã€‚
- en: At each step, the tortoise tries to advance by one node. If it cannot, weâ€™ve
    run out of sequence, and weâ€™re done. The hare, being a hare and not a tortoise,
    tries to advance by two nodes. Again, if it cannot, weâ€™ve run out of sequence,
    and weâ€™re done. Otherwise both advance, and check if theyâ€™re at the same place.
    If they are, because they started out being at distinct nodes, weâ€™ve found a cycle!
    If they are not, then we iterate.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ¯ä¸€æ­¥ï¼Œä¹Œé¾Ÿå°è¯•å‰è¿›ä¸€ä¸ªèŠ‚ç‚¹ã€‚å¦‚æœå®ƒä¸èƒ½å‰è¿›ï¼Œæˆ‘ä»¬å°±ç”¨å®Œäº†åºåˆ—ï¼Œè¿™å°±ç»“æŸäº†ã€‚å…”å­ï¼Œä½œä¸ºä¸€ä¸ªå…”å­è€Œä¸æ˜¯ä¹Œé¾Ÿï¼Œå°è¯•å‰è¿›ä¸¤ä¸ªèŠ‚ç‚¹ã€‚å†æ¬¡ï¼Œå¦‚æœå®ƒä¸èƒ½å‰è¿›ï¼Œæˆ‘ä»¬å°±ç”¨å®Œäº†åºåˆ—ï¼Œè¿™å°±ç»“æŸäº†ã€‚å¦åˆ™ï¼Œä¸¤è€…éƒ½å‰è¿›ï¼Œå¹¶æ£€æŸ¥å®ƒä»¬æ˜¯å¦åœ¨åŒä¸€ä½ç½®ã€‚å¦‚æœå®ƒä»¬åœ¨åŒä¸€ä½ç½®ï¼Œå› ä¸ºå®ƒä»¬æœ€åˆæ˜¯åœ¨ä¸åŒçš„èŠ‚ç‚¹ä¸Šï¼Œæˆ‘ä»¬å°±æ‰¾åˆ°äº†ä¸€ä¸ªå¾ªç¯ï¼å¦‚æœå®ƒä»¬ä¸åœ¨åŒä¸€ä½ç½®ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±è¿­ä»£ã€‚
- en: 'Why does this even work? In the finite case itâ€™s clear, because the hare will
    run out of next nodes. We only have to think about the infinite case. There, in
    general, we have this kind of situation:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ºä»€ä¹ˆç”šè‡³èƒ½å·¥ä½œå‘¢ï¼Ÿåœ¨æœ‰é™æƒ…å†µä¸‹è¿™æ˜¯æ˜ç¡®çš„ï¼Œå› ä¸ºå…”å­ä¼šè€—å°½ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚æˆ‘ä»¬åªéœ€è¦è€ƒè™‘æ— é™æƒ…å†µã€‚åœ¨é‚£é‡Œï¼Œé€šå¸¸æˆ‘ä»¬æœ‰è¿™ç§æƒ…å†µï¼š
- en: '![](../Images/31742a6ba02914cbc2bca965912ea982.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/31742a6ba02914cbc2bca965912ea982.png)'
- en: There is some prefix of nodes, followed by a cycle. Now, we donâ€™t know how long
    the prefix is, so we donâ€™t know how far ahead of the tortoise the hare is. Nevertheless,
    there is some first point at which the tortoise enters the cycle. (There must
    be, because the tortoise always makes progress, and the prefix can only be finite.)
    From this point on, we know that on each step, the relative speed of the two animals
    is 1\. That means the hare â€œgainsâ€ 1 on the tortoise every step. We can see that
    eventually, the hare must catch up with the tortoiseâ€”<wbr>or, alternatively, that
    the tortoise catches up with the hare!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰ä¸€äº›èŠ‚ç‚¹å‰ç¼€ï¼Œåé¢è·Ÿç€ä¸€ä¸ªå¾ªç¯ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬ä¸çŸ¥é“å‰ç¼€æœ‰å¤šé•¿ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸çŸ¥é“å…”å­æ¯”ä¹Œé¾Ÿé¢†å…ˆå¤šè¿œã€‚å°½ç®¡å¦‚æ­¤ï¼Œæ€»æœ‰ä¸€ä¸ªä¹Œé¾Ÿè¿›å…¥å¾ªç¯çš„ç¬¬ä¸€ä¸ªç‚¹ã€‚ï¼ˆä¸€å®šæœ‰ï¼Œå› ä¸ºä¹Œé¾Ÿæ€»æ˜¯æœ‰è¿›æ­¥ï¼Œå‰ç¼€åªèƒ½æ˜¯æœ‰é™çš„ã€‚ï¼‰ä»è¿™ä¸€ç‚¹å¼€å§‹ï¼Œæˆ‘ä»¬çŸ¥é“åœ¨æ¯ä¸€æ­¥ï¼Œä¸¤åªåŠ¨ç‰©çš„ç›¸å¯¹é€Ÿåº¦æ˜¯1ã€‚è¿™æ„å‘³ç€å…”å­æ¯ä¸€æ­¥éƒ½ä¼šæ¯”ä¹Œé¾Ÿâ€œé¢†å…ˆâ€1ã€‚æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œæœ€ç»ˆï¼Œå…”å­å¿…é¡»è¿½ä¸Šä¹Œé¾Ÿâ€”â€”æˆ–è€…ï¼Œæ¢å¥è¯è¯´ï¼Œä¹Œé¾Ÿè¿½ä¸Šå…”å­ï¼
- en: 'Now letâ€™s analyze this. The tortoise will get caught by the time it has completed
    one loop of the cycle. Because the tortoise moves one step at a time, the total
    time is the length of the prefix + length of the loop. In terms of space, however,
    we no longer need any history at all; we only need the current positions of the
    tortoise and hare. Therefore, our time complexity is linear, but the space complexity
    is now significantly smaller: down to constant!'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æ¥åˆ†æä¸€ä¸‹ã€‚ä¹Œé¾Ÿåœ¨å®Œæˆå¾ªç¯çš„ä¸€åœˆæ—¶å°±ä¼šè¢«æŠ“ä½ã€‚å› ä¸ºä¹Œé¾Ÿæ¯æ¬¡ç§»åŠ¨ä¸€æ­¥ï¼Œæ‰€ä»¥æ€»æ—¶é—´æ˜¯å‰ç¼€é•¿åº¦åŠ ä¸Šå¾ªç¯é•¿åº¦ã€‚ç„¶è€Œï¼Œåœ¨ç©ºé—´æ–¹é¢ï¼Œæˆ‘ä»¬ä¸å†éœ€è¦ä»»ä½•å†å²è®°å½•ï¼›æˆ‘ä»¬åªéœ€è¦ä¹Œé¾Ÿå’Œå…”å­çš„å½“å‰ä½ç½®ã€‚å› æ­¤ï¼Œæˆ‘ä»¬çš„æ—¶é—´å¤æ‚åº¦æ˜¯çº¿æ€§çš„ï¼Œä½†ç©ºé—´å¤æ‚åº¦ç°åœ¨æ˜¾è‘—æ›´å°ï¼šé™è‡³å¸¸æ•°ï¼
- en: 'Here is the code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯ä»£ç ï¼š
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 21.6Â Testing[ğŸ”—](#(part._.Testing) "Link to here")
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.6 æµ‹è¯•[ğŸ”—](#(part._.Testing) "é“¾æ¥åˆ°æ­¤å¤„")
- en: While it might be tempting to write tests like
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶ç¼–å†™æµ‹è¯•å¯èƒ½å¾ˆæœ‰å¸å¼•åŠ›ï¼Œ
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '(i.e., the same as before, but with `cc` replaced by `ph`), we should instead
    write them as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆå³ä¸ä¹‹å‰ç›¸åŒï¼Œä½†å°†`cc`æ›¿æ¢ä¸º`ph`ï¼‰ï¼Œæˆ‘ä»¬åº”å°†å…¶å†™ä¸ºä»¥ä¸‹å†…å®¹ï¼š
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This confers two advantages. First, if we change the example, we donâ€™t have
    to update two tests, only one. But the much more important reason is that we intend
    for `pr` to be an optimized version of `cc`. That is, we expect the two to produce
    the same result. We can think of `cc` as our clear, reference implementation.
    That is, this is another instance of model-based testing.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¸¦æ¥äº†ä¸¤ä¸ªä¼˜ç‚¹ã€‚é¦–å…ˆï¼Œå¦‚æœæˆ‘ä»¬æ›´æ”¹ç¤ºä¾‹ï¼Œæˆ‘ä»¬ä¸éœ€è¦æ›´æ–°ä¸¤ä¸ªæµ‹è¯•ï¼Œåªéœ€è¦ä¸€ä¸ªã€‚ä½†æ›´é‡è¦çš„æ˜¯ï¼Œæˆ‘ä»¬å¸Œæœ›`pr`æ˜¯`cc`çš„ä¼˜åŒ–ç‰ˆæœ¬ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬æœŸæœ›ä¸¤è€…äº§ç”Ÿç›¸åŒçš„ç»“æœã€‚æˆ‘ä»¬å¯ä»¥å°†`cc`è§†ä¸ºæˆ‘ä»¬çš„æ¸…æ™°ã€å‚è€ƒå®ç°ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™æ˜¯åŸºäºæ¨¡å‹æµ‹è¯•çš„å¦ä¸€ä¸ªå®ä¾‹ã€‚
- en: As an aside, this algorithm is not exactly what Pyret does, because we need
    to check for arbitrary graph-ness, not just cycles. Itâ€™s also complicated due
    to user-defined functions, etc.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºæ—ç™½ï¼Œè¿™ä¸ªç®—æ³•å¹¶ä¸å®Œå…¨ç­‰åŒäºPyretæ‰€åšçš„å·¥ä½œï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦æ£€æŸ¥ä»»æ„å›¾æ€§è´¨ï¼Œè€Œä¸ä»…ä»…æ˜¯å¾ªç¯ã€‚ç”±äºç”¨æˆ·å®šä¹‰çš„å‡½æ•°ç­‰åŸå› ï¼Œè¿™ä¹Ÿå˜å¾—å¤æ‚èµ·æ¥ã€‚
- en: 21.1Â A Running Example[ğŸ”—](#(part._.A_.Running_.Example) "Link to here")
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.1 è¿è¡Œç¤ºä¾‹[ğŸ”—](#(part._.A_.Running_.Example) "é“¾æ¥åˆ°æ­¤å¤„")
- en: As you may have noticed, Pyret will check for and print cycles. For instance,
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æ‚¨å¯èƒ½å·²ç»æ³¨æ„åˆ°çš„ï¼ŒPyretä¼šæ£€æŸ¥å¹¶æ‰“å°å¾ªç¯ã€‚ä¾‹å¦‚ï¼Œ
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Do Now!
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sketch out the above pairs to make sure you see all the cycles.
  id: totrans-62
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»˜åˆ¶ä¸Šè¿°å¯¹ä»¥ç¡®è®¤æ‚¨çœ‹åˆ°äº†æ‰€æœ‰å¾ªç¯ã€‚
- en: So we have two that participate in no cyclic behavior (`p0` and `p1`), two (`p2`
    and `p3` that are mutually-cyclic, one (`p6`) that is a self-cycle, and two (`p4`
    and `p5`) that lead to a cycle.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬æœ‰ä¸¤ç§ä¸å‚ä¸å¾ªç¯è¡Œä¸ºçš„ï¼ˆ`p0`å’Œ`p1`ï¼‰ï¼Œä¸¤ç§äº’ç›¸å¾ªç¯çš„ï¼ˆ`p2`å’Œ`p3`ï¼‰ï¼Œä¸€ç§è‡ªå¾ªç¯çš„ï¼ˆ`p6`ï¼‰ï¼Œä»¥åŠä¸¤ç§å¯¼è‡´å¾ªç¯çš„ï¼ˆ`p4`å’Œ`p5`ï¼‰ã€‚
- en: 21.2Â Types[ğŸ”—](#(part._.Types) "Link to here")
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.2 ç±»å‹[ğŸ”—](#(part._.Types) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'As an aside, imagine we try to type-check this program. We have to provide
    a type for `tl`, but itâ€™s not clear what this can be: sometimes itâ€™s a `Number`,
    and other times itâ€™s a `Pair`. However, we might observe that if our goal is to
    create cyclic data, then we want `tl` to refer to a `Pair` or to nothing at all.
    That suggests that a useful type is:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºæ—ç™½ï¼Œæƒ³è±¡æˆ‘ä»¬å°è¯•å¯¹è¿™ä¸ªç¨‹åºè¿›è¡Œç±»å‹æ£€æŸ¥ã€‚æˆ‘ä»¬å¿…é¡»ä¸º`tl`æä¾›ä¸€ä¸ªç±»å‹ï¼Œä½†è¿™ä¸ªç±»å‹å¹¶ä¸æ˜ç¡®ï¼šæœ‰æ—¶å®ƒæ˜¯ä¸€ä¸ª`Number`ï¼Œæœ‰æ—¶å®ƒæ˜¯ä¸€ä¸ª`Pair`ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å¯èƒ½ä¼šè§‚å¯Ÿåˆ°ï¼Œå¦‚æœæˆ‘ä»¬çš„ç›®æ ‡æ˜¯åˆ›å»ºå¾ªç¯æ•°æ®ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¸Œæœ›`tl`æŒ‡å‘ä¸€ä¸ª`Pair`æˆ–è€…ä»€ä¹ˆéƒ½æ²¡æœ‰ã€‚è¿™è¡¨æ˜ä¸€ä¸ªæœ‰ç”¨çš„ç±»å‹æ˜¯ï¼š
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: so that we can write
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤æˆ‘ä»¬å¯ä»¥ç¼–å†™
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This works, but we have to deal with the `Option` everywhere. Since our goal
    is to focus on cycles, and this would become unwieldy, we ignore the typed version
    from now on.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è¡Œå¾—é€šï¼Œä½†æˆ‘ä»¬å¿…é¡»åœ¨æ¯ä¸ªåœ°æ–¹å¤„ç†`Option`ã€‚ç”±äºæˆ‘ä»¬çš„ç›®æ ‡æ˜¯å…³æ³¨å¾ªç¯ï¼Œè€Œä¸”è¿™ä¼šå˜å¾—éš¾ä»¥ç®¡ç†ï¼Œæ‰€ä»¥æˆ‘ä»¬ä»ç°åœ¨èµ·å¿½ç•¥æœ‰ç±»å‹çš„ç‰ˆæœ¬ã€‚
- en: 21.3Â A First Checker[ğŸ”—](#(part._.A_.First_.Checker) "Link to here")
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.3Â ç¬¬ä¸€ä¸ªæ£€æŸ¥å™¨[ğŸ”—](#(part._.A_.First_.Checker) "é“¾æ¥è‡³æ­¤")
- en: Okay, back to the untyped version.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½å§ï¼Œå›åˆ°æ— ç±»å‹ç‰ˆæœ¬ã€‚
- en: So letâ€™s try to figure out whether, given a Pair, it leads to a cycle. What
    should the type be?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆï¼Œè®©æˆ‘ä»¬æ¥å¼„æ¸…æ¥šï¼Œç»™å®šä¸€ä¸ªå¯¹ï¼ˆPairï¼‰ï¼Œå®ƒæ˜¯å¦ä¼šå¯¼è‡´ä¸€ä¸ªå¾ªç¯ã€‚ç±»å‹åº”è¯¥æ˜¯ä»€ä¹ˆï¼Ÿ
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: where `cc` stands for â€œcheck cycleâ€.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­`cc`ä»£è¡¨â€œæ£€æŸ¥å¾ªç¯â€ã€‚
- en: 'Critically, itâ€™s important that this be a total function: i.e., it always terminates.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: å…³é”®çš„æ˜¯ï¼Œè¿™ä¸ªå‡½æ•°å¿…é¡»æ˜¯å…¨ç§°çš„ï¼šå³ï¼Œå®ƒæ€»æ˜¯ç»ˆæ­¢ã€‚
- en: 'So letâ€™s write the most obvious solution:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥è®©æˆ‘ä»¬å†™ä¸‹æœ€æ˜æ˜¾çš„è§£å†³æ–¹æ¡ˆï¼š
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'First of all, does this even terminate? It could take a while to visit all
    the nodes, but a cycle demands that somewhere, we revisit a node we saw before.
    Since we track that, we canâ€™t not terminate. Therefore, termination is guaranteed,
    and the function is total. Indeed, all these tests pass:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œè¿™ç”šè‡³èƒ½ç»ˆæ­¢å—ï¼Ÿè®¿é—®æ‰€æœ‰èŠ‚ç‚¹å¯èƒ½éœ€è¦ä¸€æ®µæ—¶é—´ï¼Œä½†å¾ªç¯è¦æ±‚æˆ‘ä»¬åœ¨æŸä¸ªåœ°æ–¹é‡æ–°è®¿é—®ä¹‹å‰å·²ç»çœ‹åˆ°çš„èŠ‚ç‚¹ã€‚ç”±äºæˆ‘ä»¬è·Ÿè¸ªè¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬ä¸å¯èƒ½ä¸ç»ˆæ­¢ã€‚å› æ­¤ï¼Œç»ˆæ­¢æ˜¯ä¿è¯çš„ï¼Œå‡½æ•°æ˜¯å…¨ç§°çš„ã€‚äº‹å®ä¸Šï¼Œæ‰€æœ‰è¿™äº›æµ‹è¯•éƒ½é€šè¿‡äº†ï¼š
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As another aside, observe that we could have written these tests instead like
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºå¦ä¸€ä¸ªæ—ç™½ï¼Œè¯·æ³¨æ„ï¼Œæˆ‘ä»¬å¯ä»¥å°†è¿™äº›æµ‹è¯•å†™æˆè¿™æ ·
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'which would be more concise, but that would also be misleading: it would suggest
    that `cc` is a desirable property, so `p2` is a â€œgoodâ€ instance and `p0` is a
    â€œbadâ€ one. However, `cc` is not a judgment of qualityâ€”<wbr>its two responses have
    equal weightâ€”<wbr>so this would be confusing to a later reader.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°†æ›´åŠ ç®€æ´ï¼Œä½†ä¹Ÿä¼šé€ æˆè¯¯å¯¼ï¼šå®ƒä¼¼ä¹è¡¨æ˜`cc`æ˜¯ä¸€ä¸ªæœŸæœ›çš„ç‰¹æ€§ï¼Œå› æ­¤`p2`æ˜¯ä¸€ä¸ªâ€œå¥½â€çš„å®ä¾‹ï¼Œè€Œ`p0`æ˜¯ä¸€ä¸ªâ€œåâ€çš„å®ä¾‹ã€‚ç„¶è€Œï¼Œ`cc`å¹¶ä¸æ˜¯å¯¹è´¨é‡çš„åˆ¤æ–­â€”â€”å®ƒçš„ä¸¤ä¸ªå“åº”å…·æœ‰ç›¸ç­‰çš„æƒé‡â€”â€”å› æ­¤è¿™å¯¹åæ¥çš„è¯»è€…æ¥è¯´å¯èƒ½ä¼šé€ æˆå›°æƒ‘ã€‚
- en: 21.4Â Complexity[ğŸ”—](#(part._cyc-det-comp) "Link to here")
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.4Â å¤æ‚æ€§[ğŸ”—](#(part._cyc-det-comp) "é“¾æ¥è‡³æ­¤")
- en: 'Now that we have determined that it terminates, we can ask for its time and
    space complexity. First we have to decide what we are even computing the complexity
    over. If the sequence is finite, then the size is clearly the size of the sequence.
    But if itâ€™s infinite, we donâ€™t want to traverse the â€œwhole thingâ€: rather, we
    mean its finite part (excluding any repetition). So the meaningful measure in
    either case is the number of `p` nodes, i.e., the finite size. It may just be
    that some of these lead back to themselves, so that a naÃ¯ve traversal will go
    on forever.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»ç¡®å®šå®ƒèƒ½å¤Ÿç»ˆæ­¢ï¼Œæˆ‘ä»¬å¯ä»¥è¯¢é—®å…¶æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦ã€‚é¦–å…ˆæˆ‘ä»¬å¿…é¡»å†³å®šæˆ‘ä»¬åœ¨è®¡ç®—å¤æ‚åº¦æ—¶åˆ°åº•åœ¨è®¡ç®—ä»€ä¹ˆã€‚å¦‚æœåºåˆ—æ˜¯æœ‰é™çš„ï¼Œé‚£ä¹ˆå¤§å°æ˜¾ç„¶æ˜¯åºåˆ—çš„å¤§å°ã€‚ä½†å¦‚æœå®ƒæ˜¯æ— é™çš„ï¼Œæˆ‘ä»¬ä¸æƒ³éå†â€œæ•´ä¸ªåºåˆ—â€ï¼šæˆ‘ä»¬æŒ‡çš„æ˜¯å®ƒçš„æœ‰é™éƒ¨åˆ†ï¼ˆæ’é™¤ä»»ä½•é‡å¤ï¼‰ã€‚å› æ­¤ï¼Œåœ¨ä¸¤ç§æƒ…å†µä¸‹ï¼Œæœ‰æ„ä¹‰çš„åº¦é‡æ˜¯`p`èŠ‚ç‚¹çš„æ•°é‡ï¼Œå³æœ‰é™çš„å°ºå¯¸ã€‚å¯èƒ½åªæ˜¯å…¶ä¸­ä¸€äº›ä¼šå›åˆ°è‡ªå·±ï¼Œè¿™æ ·ç®€å•çš„éå†å°±ä¼šæ°¸è¿œè¿›è¡Œä¸‹å»ã€‚
- en: 'Okay, so we visit each node once. We keep track of all the nodes just in case
    we double back over, either until we run out of nodes or we repeat one. Therefore,
    the space complexity is linear in the length of the sum of the prefix (from the
    starting node) and the cycle. The time complexity is that but also, at each point,
    we have to check membership, so itâ€™s quadratic in the length of that prefix +
    cycle. So: linear space, quadratic time, in the size of the prefix + cycle.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½å§ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¼šè®¿é—®æ¯ä¸ªèŠ‚ç‚¹ä¸€æ¬¡ã€‚æˆ‘ä»¬è·Ÿè¸ªæ‰€æœ‰èŠ‚ç‚¹ï¼Œä»¥é˜²æˆ‘ä»¬å›å¤´ï¼Œè¦ä¹ˆç›´åˆ°ç”¨å®ŒèŠ‚ç‚¹ï¼Œè¦ä¹ˆé‡å¤ä¸€ä¸ªã€‚å› æ­¤ï¼Œç©ºé—´å¤æ‚åº¦ä¸å‰ç¼€ï¼ˆä»èµ·å§‹èŠ‚ç‚¹å¼€å§‹ï¼‰å’Œå¾ªç¯é•¿åº¦çš„æ€»å’Œæˆçº¿æ€§å…³ç³»ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯çº¿æ€§çš„ï¼Œä½†åœ¨æ¯ä¸ªç‚¹ä¸Šï¼Œæˆ‘ä»¬éƒ½è¦æ£€æŸ¥æˆå‘˜èµ„æ ¼ï¼Œæ‰€ä»¥å®ƒåœ¨é‚£ä¸ªå‰ç¼€+å¾ªç¯çš„é•¿åº¦ä¸Šæ˜¯äºŒæ¬¡çš„ã€‚æ‰€ä»¥ï¼šçº¿æ€§ç©ºé—´ï¼ŒäºŒæ¬¡æ—¶é—´ï¼Œåœ¨å‰ç¼€+å¾ªç¯çš„å¤§å°ä¸Šã€‚
- en: 'Now, some degree of linear behavior is unavoidable: we clearly have to keep
    going until we run out or hit a cycle, so for detecting the cycle having something
    be linear in the size of the prefix (get it out of the way) + length of the cycle
    (find the cycle) seems essential. But can we improve on this complexity? It seems
    unlikely: by definition, how can we check for a cycle if we donâ€™t remember everything
    weâ€™ve seen?'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œä¸€å®šç¨‹åº¦ä¸Šçš„çº¿æ€§è¡Œä¸ºæ˜¯ä¸å¯é¿å…çš„ï¼šæˆ‘ä»¬æ˜¾ç„¶å¿…é¡»ç»§ç»­è¿›è¡Œï¼Œç›´åˆ°ç”¨å®Œæˆ–é‡åˆ°ä¸€ä¸ªå¾ªç¯ï¼Œå› æ­¤ä¸ºäº†æ£€æµ‹å¾ªç¯ï¼Œè®©æŸä¸ªä¸œè¥¿ä¸å‰ç¼€çš„å¤§å°ï¼ˆå°†å…¶ç§»é™¤ï¼‰+ å¾ªç¯é•¿åº¦ï¼ˆæ‰¾åˆ°å¾ªç¯ï¼‰ä¼¼ä¹è‡³å…³é‡è¦ã€‚ä½†æˆ‘ä»¬èƒ½å¦æ”¹è¿›è¿™ä¸ªå¤æ‚æ€§ï¼Ÿè¿™ä¼¼ä¹ä¸å¤ªå¯èƒ½ï¼šæŒ‰ç…§å®šä¹‰ï¼Œå¦‚æœæˆ‘ä»¬æ²¡æœ‰è®°ä½æˆ‘ä»¬æ‰€çœ‹åˆ°çš„ä¸€åˆ‡ï¼Œæˆ‘ä»¬å¦‚ä½•æ£€æŸ¥å¾ªç¯å‘¢ï¼Ÿ
- en: Our first hunch might be, â€œMaybe thereâ€™s another space-time tradeoff!â€ But itâ€™s
    not so clear here. Our space is linear and time quadratic, so we may think we
    can flip those around. But the time canâ€™t be less than the space! If, for instance,
    we had linear time and quadratic space, that wouldnâ€™t make sense, because weâ€™d
    need at least quadratic time just to fill the space. So thatâ€™s not going to work
    so well.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„ç¬¬ä¸€ååº”å¯èƒ½æ˜¯ï¼Œâ€œä¹Ÿè®¸è¿˜æœ‰å¦ä¸€ç§æ—¶ç©ºæƒè¡¡ï¼â€ä½†åœ¨è¿™é‡Œå¹¶ä¸é‚£ä¹ˆæ¸…æ¥šã€‚æˆ‘ä»¬çš„ç©ºé—´æ˜¯çº¿æ€§çš„ï¼Œæ—¶é—´æ˜¯äºŒæ¬¡çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯èƒ½è®¤ä¸ºæˆ‘ä»¬å¯ä»¥äº’æ¢å®ƒä»¬ã€‚ä½†æ—¶é—´ä¸èƒ½å°äºç©ºé—´ï¼ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬æœ‰çº¿æ€§æ—¶é—´å’ŒäºŒæ¬¡ç©ºé—´ï¼Œé‚£å°±æ²¡æœ‰æ„ä¹‰äº†ï¼Œå› ä¸ºæˆ‘ä»¬è‡³å°‘éœ€è¦äºŒæ¬¡æ—¶é—´æ¥å¡«å……ç©ºé—´ã€‚æ‰€ä»¥è¿™ä¸ä¼šå¾ˆå¥½ç”¨ã€‚
- en: Instead, the best way to improve seems to have a better lookup data structure.
    Weâ€™d still take linear spaceâ€”<wbr>as we said, linear was unavoidable (and we canâ€™t
    just be linear in the size of the cycle, because the whole point is we donâ€™t even
    know we have a cycle, much less which parts are prefix and which parts cycle)â€”<wbr>and
    the time complexity would hopefully reduce from quadratic to linear-times-something-sublinear.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åï¼Œæé«˜æ•ˆç‡çš„æœ€ä½³æ–¹å¼ä¼¼ä¹æ˜¯æœ‰æ›´å¥½çš„æŸ¥æ‰¾æ•°æ®ç»“æ„ã€‚æˆ‘ä»¬ä»ç„¶ä¼šå ç”¨çº¿æ€§ç©ºé—´â€”â€”æ­£å¦‚æˆ‘ä»¬æ‰€è¯´çš„ï¼Œçº¿æ€§ç©ºé—´æ˜¯ä¸å¯é¿å…çš„ï¼ˆè€Œä¸”æˆ‘ä»¬ä¸èƒ½ä»…ä»…åœ¨å¾ªç¯çš„å¤§å°ä¸Šæ˜¯çº¿æ€§çš„ï¼Œå› ä¸ºæ•´ä¸ªé—®é¢˜çš„å…³é”®æ˜¯æˆ‘ä»¬ç”šè‡³ä¸çŸ¥é“æˆ‘ä»¬æœ‰ä¸€ä¸ªå¾ªç¯ï¼Œæ›´ä¸ç”¨è¯´å“ªäº›éƒ¨åˆ†æ˜¯å‰ç¼€ï¼Œå“ªäº›éƒ¨åˆ†æ˜¯å¾ªç¯äº†ï¼‰â€”â€”æ—¶é—´å¤æ‚åº¦æœ‰æœ›ä»äºŒæ¬¡é™ä½åˆ°çº¿æ€§ä¹˜ä»¥æŸä¸ªäºšçº¿æ€§ã€‚
- en: 21.5Â A Fabulous Improvement[ğŸ”—](#(part._.A_.Fabulous_.Improvement) "Link to here")
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.5Â ä¸€ä¸ªæƒŠäººçš„æ”¹è¿›[ğŸ”—](#(part._.A_.Fabulous_.Improvement) "é“¾æ¥åˆ°æ­¤å¤„")
- en: It turns out we can do a lot better! Itâ€™s called the tortoise-and-hare algorithm.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æœï¼Œæˆ‘ä»¬å¯ä»¥åšå¾—æ›´å¥½ï¼è¿™è¢«ç§°ä¸ºé¾Ÿå…”ç®—æ³•ã€‚
- en: We start off with two references into the sequence, one called the tortoise
    and the other the hare.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä»ä¸¤ä¸ªå¯¹åºåˆ—çš„å¼•ç”¨å¼€å§‹ï¼Œä¸€ä¸ªå«åšä¹Œé¾Ÿï¼Œå¦ä¸€ä¸ªå«åšå…”å­ã€‚
- en: At each step, the tortoise tries to advance by one node. If it cannot, weâ€™ve
    run out of sequence, and weâ€™re done. The hare, being a hare and not a tortoise,
    tries to advance by two nodes. Again, if it cannot, weâ€™ve run out of sequence,
    and weâ€™re done. Otherwise both advance, and check if theyâ€™re at the same place.
    If they are, because they started out being at distinct nodes, weâ€™ve found a cycle!
    If they are not, then we iterate.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ¯ä¸€æ­¥ï¼Œä¹Œé¾Ÿå°è¯•å‰è¿›ä¸€ä¸ªèŠ‚ç‚¹ã€‚å¦‚æœå®ƒä¸èƒ½å‰è¿›ï¼Œæˆ‘ä»¬å°±ç”¨å®Œäº†åºåˆ—ï¼Œè¿™å°±ç»“æŸäº†ã€‚å…”å­ï¼Œä½œä¸ºä¸€ä¸ªå…”å­è€Œä¸æ˜¯ä¹Œé¾Ÿï¼Œå°è¯•å‰è¿›ä¸¤ä¸ªèŠ‚ç‚¹ã€‚å†æ¬¡ï¼Œå¦‚æœå®ƒä¸èƒ½å‰è¿›ï¼Œæˆ‘ä»¬å°±ç”¨å®Œäº†åºåˆ—ï¼Œè¿™å°±ç»“æŸäº†ã€‚å¦åˆ™ï¼Œä¸¤è€…éƒ½å‰è¿›ï¼Œå¹¶æ£€æŸ¥å®ƒä»¬æ˜¯å¦åœ¨åŒä¸€ä½ç½®ã€‚å¦‚æœå®ƒä»¬åœ¨åŒä¸€ä½ç½®ï¼Œå› ä¸ºå®ƒä»¬æœ€åˆæ˜¯åœ¨ä¸åŒçš„èŠ‚ç‚¹ä¸Šï¼Œæˆ‘ä»¬å°±æ‰¾åˆ°äº†ä¸€ä¸ªå¾ªç¯ï¼å¦‚æœå®ƒä»¬ä¸åœ¨åŒä¸€ä½ç½®ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±è¿­ä»£ã€‚
- en: 'Why does this even work? In the finite case itâ€™s clear, because the hare will
    run out of next nodes. We only have to think about the infinite case. There, in
    general, we have this kind of situation:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ºä»€ä¹ˆç”šè‡³æœ‰æ•ˆå‘¢ï¼Ÿåœ¨æœ‰é™çš„æƒ…å†µä¸‹è¿™æ˜¯æ˜ç¡®çš„ï¼Œå› ä¸ºå…”å­ä¼šè€—å°½ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚æˆ‘ä»¬åªéœ€è¦è€ƒè™‘æ— é™çš„æƒ…å†µã€‚åœ¨é‚£é‡Œï¼Œé€šå¸¸æˆ‘ä»¬æœ‰è¿™ç§æƒ…å†µï¼š
- en: '![](../Images/31742a6ba02914cbc2bca965912ea982.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/31742a6ba02914cbc2bca965912ea982.png)'
- en: There is some prefix of nodes, followed by a cycle. Now, we donâ€™t know how long
    the prefix is, so we donâ€™t know how far ahead of the tortoise the hare is. Nevertheless,
    there is some first point at which the tortoise enters the cycle. (There must
    be, because the tortoise always makes progress, and the prefix can only be finite.)
    From this point on, we know that on each step, the relative speed of the two animals
    is 1\. That means the hare â€œgainsâ€ 1 on the tortoise every step. We can see that
    eventually, the hare must catch up with the tortoiseâ€”<wbr>or, alternatively, that
    the tortoise catches up with the hare!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰ä¸€äº›èŠ‚ç‚¹çš„å‰ç¼€ï¼Œç„¶åæ˜¯ä¸€ä¸ªå¾ªç¯ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬ä¸çŸ¥é“å‰ç¼€æœ‰å¤šé•¿ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸çŸ¥é“å…”å­æ¯”ä¹Œé¾Ÿé¢†å…ˆå¤šè¿œã€‚å°½ç®¡å¦‚æ­¤ï¼Œæ€»æœ‰ä¸€ä¸ªä¹Œé¾Ÿè¿›å…¥å¾ªç¯çš„ç¬¬ä¸€ä¸ªç‚¹ã€‚ï¼ˆä¸€å®šæœ‰ï¼Œå› ä¸ºä¹Œé¾Ÿæ€»æ˜¯ä¼šæœ‰è¿›æ­¥ï¼Œå‰ç¼€åªèƒ½æ˜¯æœ‰é™çš„ã€‚ï¼‰ä»è¿™ä¸ªç‚¹å¼€å§‹ï¼Œæˆ‘ä»¬çŸ¥é“åœ¨æ¯ä¸€æ­¥ï¼Œä¸¤åªåŠ¨ç‰©çš„ç›¸å¯¹é€Ÿåº¦æ˜¯1ã€‚è¿™æ„å‘³ç€å…”å­æ¯ä¸€æ­¥â€œé¢†å…ˆâ€ä¹Œé¾Ÿ1ä¸ªèŠ‚ç‚¹ã€‚æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œæœ€ç»ˆï¼Œå…”å­å¿…é¡»è¿½ä¸Šä¹Œé¾Ÿâ€”â€”æˆ–è€…ï¼Œæ¢å¥è¯è¯´ï¼Œä¹Œé¾Ÿè¿½ä¸Šå…”å­ï¼
- en: 'Now letâ€™s analyze this. The tortoise will get caught by the time it has completed
    one loop of the cycle. Because the tortoise moves one step at a time, the total
    time is the length of the prefix + length of the loop. In terms of space, however,
    we no longer need any history at all; we only need the current positions of the
    tortoise and hare. Therefore, our time complexity is linear, but the space complexity
    is now significantly smaller: down to constant!'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æ¥åˆ†æä¸€ä¸‹ã€‚ä¹Œé¾Ÿå°†åœ¨å®Œæˆå¾ªç¯çš„ä¸€åœˆåè¢«æŠ“ä½ã€‚å› ä¸ºä¹Œé¾Ÿæ¯æ¬¡ç§»åŠ¨ä¸€æ­¥ï¼Œæ‰€ä»¥æ€»æ—¶é—´æ˜¯å‰ç¼€é•¿åº¦åŠ ä¸Šå¾ªç¯é•¿åº¦ã€‚ç„¶è€Œï¼Œåœ¨ç©ºé—´æ–¹é¢ï¼Œæˆ‘ä»¬ä¸å†éœ€è¦ä»»ä½•å†å²è®°å½•ï¼›æˆ‘ä»¬åªéœ€è¦ä¹Œé¾Ÿå’Œå…”å­çš„å½“å‰ä½ç½®ã€‚å› æ­¤ï¼Œæˆ‘ä»¬çš„æ—¶é—´å¤æ‚åº¦æ˜¯çº¿æ€§çš„ï¼Œä½†ç©ºé—´å¤æ‚åº¦ç°åœ¨æ˜¾è‘—å‡å°ï¼šé™è‡³å¸¸æ•°ï¼
- en: 'Here is the code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯ä»£ç ï¼š
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 21.6Â Testing[ğŸ”—](#(part._.Testing) "Link to here")
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.6Â æµ‹è¯•[ğŸ”—](#(part._.Testing) "é“¾æ¥åˆ°æ­¤å¤„")
- en: While it might be tempting to write tests like
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶å†™æµ‹è¯•å¯èƒ½å¾ˆæœ‰å¸å¼•åŠ›ï¼Œä¾‹å¦‚
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '(i.e., the same as before, but with `cc` replaced by `ph`), we should instead
    write them as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆå³ï¼Œä¸ä¹‹å‰ç›¸åŒï¼Œä½†å°† `cc` æ›¿æ¢ä¸º `ph`ï¼‰ï¼Œæˆ‘ä»¬åº”å°†å…¶å†™ä¸ºå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This confers two advantages. First, if we change the example, we donâ€™t have
    to update two tests, only one. But the much more important reason is that we intend
    for `pr` to be an optimized version of `cc`. That is, we expect the two to produce
    the same result. We can think of `cc` as our clear, reference implementation.
    That is, this is another instance of model-based testing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¸¦æ¥äº†ä¸¤ä¸ªä¼˜åŠ¿ã€‚é¦–å…ˆï¼Œå¦‚æœæˆ‘ä»¬æ›´æ”¹ç¤ºä¾‹ï¼Œæˆ‘ä»¬ä¸éœ€è¦æ›´æ–°ä¸¤ä¸ªæµ‹è¯•ï¼Œåªéœ€ä¸€ä¸ªå³å¯ã€‚ä½†æ›´é‡è¦çš„æ˜¯ï¼Œæˆ‘ä»¬å¸Œæœ› `pr` æ˜¯ `cc` çš„ä¼˜åŒ–ç‰ˆæœ¬ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬æœŸæœ›è¿™ä¸¤ä¸ªèƒ½äº§ç”Ÿç›¸åŒçš„ç»“æœã€‚æˆ‘ä»¬å¯ä»¥å°†
    `cc` è§†ä¸ºæˆ‘ä»¬æ¸…æ™°çš„ã€å‚è€ƒçš„å®ç°ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™æ˜¯åŸºäºæ¨¡å‹æµ‹è¯•çš„å¦ä¸€ä¸ªå®ä¾‹ã€‚
- en: As an aside, this algorithm is not exactly what Pyret does, because we need
    to check for arbitrary graph-ness, not just cycles. Itâ€™s also complicated due
    to user-defined functions, etc.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºè¡¥å……ï¼Œè¿™ä¸ªç®—æ³•å¹¶ä¸å®Œå…¨ç­‰åŒäº Pyret æ‰€åšçš„ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦æ£€æŸ¥ä»»æ„å›¾æ€§è´¨ï¼Œè€Œä¸ä»…ä»…æ˜¯å¾ªç¯ã€‚ç”±äºç”¨æˆ·å®šä¹‰çš„å‡½æ•°ç­‰åŸå› ï¼Œå®ƒä¹Ÿå¾ˆå¤æ‚ã€‚
