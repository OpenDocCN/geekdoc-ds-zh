- en: 4.1Â Introduction to Tabular DatağŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.1 è¡¨æ ¼æ•°æ®ç®€ä»‹ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/intro-tabular-data.html](https://dcic-world.org/2025-08-27/intro-tabular-data.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/intro-tabular-data.html](https://dcic-world.org/2025-08-27/intro-tabular-data.html)
- en: '| Â Â Â Â [4.1.1Â Creating Tabular Data](#%28part._.Creating_.Tabular_.Data%29)
    |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [4.1.1 åˆ›å»ºè¡¨æ ¼æ•°æ®](#(%28part._.Creating_.Tabular_.Data%29) |'
- en: '| Â Â Â Â [4.1.2Â Extracting Rows and Cell Values](#%28part._.Extracting_.Rows_and_.Cell_.Values%29)
    |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [4.1.2 æå–è¡Œå’Œå•å…ƒæ ¼å€¼](#(%28part._.Extracting_.Rows_and_.Cell_.Values%29) |'
- en: '| Â Â Â Â [4.1.3Â Functions over Rows](#%28part._.Functions_over_.Rows%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [4.1.3 è¡Œä¸Šçš„å‡½æ•°](#(%28part._.Functions_over_.Rows%29) |'
- en: '| Â Â Â Â [4.1.4Â Processing Rows](#%28part._.Processing_.Rows%29) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [4.1.4 å¤„ç†è¡Œ](#(%28part._.Processing_.Rows%29) |'
- en: '| Â Â Â Â Â Â [4.1.4.1Â Finding Rows](#%28part._subsec~3afinding-rows%29) |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â Â [4.1.4.1 æŸ¥æ‰¾è¡Œ](#(%28part._subsec~3afinding-rows%29) |'
- en: '| Â Â Â Â Â Â [4.1.4.2Â Ordering Rows](#%28part._.Ordering_.Rows%29) |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â Â [4.1.4.2 æ’åºè¡Œ](#(%28part._.Ordering_.Rows%29) |'
- en: '| Â Â Â Â Â Â [4.1.4.3Â Adding New Columns](#%28part._.Adding_.New_.Columns%29) |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â Â [4.1.4.3 æ·»åŠ æ–°åˆ—](#(%28part._.Adding_.New_.Columns%29) |'
- en: '| Â Â Â Â Â Â [4.1.4.4Â Calculating New Column Values](#%28part._.Calculating_.New_.Column_.Values%29)
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â Â [4.1.4.4 è®¡ç®—æ–°åˆ—å€¼](#(%28part._.Calculating_.New_.Column_.Values%29) |'
- en: '| Â Â Â Â [4.1.5Â Examples for Table-Producing Functions](#%28part._.Examples_for_.Table-.Producing_.Functions%29)
    |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [4.1.5 è¡¨ç”Ÿæˆå‡½æ•°çš„ç¤ºä¾‹](#(%28part._.Examples_for_.Table-.Producing_.Functions%29)
    |'
- en: '| Â Â Â Â [4.1.6Â Lambda: Anonymous Functions](#%28part._sec~3alambda-tables%29)
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [4.1.6 Lambdaï¼šåŒ¿åå‡½æ•°](#(%28part._sec~3alambda-tables%29) |'
- en: 'Many interesting data in computing are tabularâ€”<wbr>i.e., like a tableâ€”<wbr>in
    form. First weâ€™ll see a few examples of them, before we try to identify what they
    have in common. Here are some of them:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: è®¡ç®—æœºä¸­è®¸å¤šæœ‰è¶£çš„æ•°æ®éƒ½æ˜¯è¡¨æ ¼å½¢å¼çš„â€”â€”å³ï¼Œåƒè¡¨æ ¼ä¸€æ ·â€”â€”åœ¨å½¢å¼ä¸Šã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å°†çœ‹åˆ°å®ƒä»¬çš„ä¸€äº›ä¾‹å­ï¼Œç„¶åå°è¯•ç¡®å®šå®ƒä»¬æœ‰ä»€ä¹ˆå…±åŒä¹‹å¤„ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›ä¾‹å­ï¼š
- en: 'An email inbox is a list of messages. For each message, your inbox stores a
    bunch of information: its sender, the subject line, the conversation itâ€™s part
    of, the body, and quite a bit more.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªç”µå­é‚®ä»¶æ”¶ä»¶ç®±æ˜¯ä¸€ç³»åˆ—æ¶ˆæ¯ã€‚å¯¹äºæ¯æ¡æ¶ˆæ¯ï¼Œæ‚¨çš„æ”¶ä»¶ç®±å­˜å‚¨ä¸€ç³»åˆ—ä¿¡æ¯ï¼šå‘ä»¶äººã€ä¸»é¢˜è¡Œã€å®ƒæ‰€å±çš„å¯¹è¯ã€æ­£æ–‡ä»¥åŠæ›´å¤šã€‚
- en: '![](../Images/17a64e6b5180eb56ebf06a02ffe39113.png)'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](../Images/17a64e6b5180eb56ebf06a02ffe39113.png)'
- en: 'A music playlist. For each song, your music player maintains a bunch of information:
    its name, the singer, its length, its genre, and so on.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªéŸ³ä¹æ’­æ”¾åˆ—è¡¨ã€‚å¯¹äºæ¯é¦–æ­Œæ›²ï¼Œæ‚¨çš„éŸ³ä¹æ’­æ”¾å™¨ç»´æŠ¤ä¸€ç³»åˆ—ä¿¡æ¯ï¼šæ­Œæ›²åç§°ã€æ­Œæ‰‹ã€æ—¶é•¿ã€æµæ´¾ç­‰ã€‚
- en: '![](../Images/c49e8b34342ce5900ea7036fda0dff30.png)'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](../Images/c49e8b34342ce5900ea7036fda0dff30.png)'
- en: A filesystem folder or directory. For each file, your filesystem records a name,
    a modification date, size, and other information.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿæ–‡ä»¶å¤¹æˆ–ç›®å½•ã€‚å¯¹äºæ¯ä¸ªæ–‡ä»¶ï¼Œæ‚¨çš„æ–‡ä»¶ç³»ç»Ÿè®°å½•ä¸€ä¸ªåç§°ã€ä¿®æ”¹æ—¥æœŸã€å¤§å°å’Œå…¶ä»–ä¿¡æ¯ã€‚
- en: '![](../Images/b73acd1cfa429053983b7085ec7786c9.png)'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](../Images/b73acd1cfa429053983b7085ec7786c9.png)'
- en: Do Now!
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨åšä»€ä¹ˆï¼Ÿ
- en: ''
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can you come up with more examples?
  id: totrans-21
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ èƒ½æƒ³å‡ºæ›´å¤šä¾‹å­å—ï¼Ÿ
- en: 'How about:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: æ€ä¹ˆæ ·ï¼Ÿ
- en: Responses to a party invitation.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹æ´¾å¯¹é‚€è¯·çš„å›å¤ã€‚
- en: A gradebook.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæˆç»©å†Œã€‚
- en: A calendar agenda.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæ—¥å†è®®ç¨‹ã€‚
- en: You can think of many more in your life!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ åœ¨ç”Ÿæ´»ä¸­è¿˜èƒ½æƒ³åˆ°æ›´å¤šï¼
- en: 'What do all these have in common? The characteristics of tabular data are:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€æœ‰è¿™äº›æœ‰ä»€ä¹ˆå…±åŒä¹‹å¤„ï¼Ÿè¡¨æ ¼æ•°æ®çš„ç‰¹å¾æ˜¯ï¼š
- en: They contain information about zero or more items (i.e., individuals or artifacts)
    that share characteristics. Each item is stored in a row. Each column tracks one
    of the shared attributes across the rows. For example, each song or email message
    or file is a row. Each of their characteristicsâ€”<wbr>the song title, the message
    subject, the filenameâ€”<wbr>is a column. While some spreadsheets might swap the
    roles of rows and columns, we stick to this organization as it aligns with the
    design of data-science software libraries. This is an example of what Hadley Wickham
    calls [tidy data](https://vita.had.co.nz/papers/tidy-data.pdf).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å®ƒä»¬åŒ…å«å…³äºé›¶ä¸ªæˆ–å¤šä¸ªå…·æœ‰å…±åŒç‰¹å¾çš„é¡¹ç›®ï¼ˆå³ä¸ªäººæˆ–ç‰©å“ï¼‰çš„ä¿¡æ¯ã€‚æ¯ä¸ªé¡¹ç›®å­˜å‚¨åœ¨ä¸€è¡Œä¸­ã€‚æ¯ä¸€åˆ—è·Ÿè¸ªè¡Œä¹‹é—´çš„ä¸€ä¸ªå…±äº«å±æ€§ã€‚ä¾‹å¦‚ï¼Œæ¯é¦–æ­Œæ›²æˆ–ç”µå­é‚®ä»¶æ¶ˆæ¯æˆ–æ–‡ä»¶æ˜¯ä¸€è¡Œã€‚å®ƒä»¬çš„æ¯ä¸ªç‰¹å¾â€”â€”æ­Œæ›²æ ‡é¢˜ã€æ¶ˆæ¯ä¸»é¢˜ã€æ–‡ä»¶åâ€”â€”æ˜¯ä¸€åˆ—ã€‚è™½ç„¶ä¸€äº›ç”µå­è¡¨æ ¼å¯èƒ½äº¤æ¢è¡Œå’Œåˆ—çš„è§’è‰²ï¼Œä½†æˆ‘ä»¬åšæŒè¿™ç§ç»„ç»‡æ–¹å¼ï¼Œå› ä¸ºå®ƒä¸æ•°æ®ç§‘å­¦è½¯ä»¶åº“çš„è®¾è®¡ç›¸ä¸€è‡´ã€‚è¿™æ˜¯Hadley
    Wickhamæ‰€è¯´çš„[æ•´æ´æ•°æ®](https://vita.had.co.nz/papers/tidy-data.pdf)çš„ä¸€ä¸ªä¾‹å­ã€‚
- en: Each row has the same columns as the other rows, in the same order.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¯ä¸€è¡Œéƒ½æœ‰ä¸å…¶ä»–è¡Œç›¸åŒçš„åˆ—ï¼Œé¡ºåºç›¸åŒã€‚
- en: A given column has the same type, but different columns can have different types.
    For instance, an email message has a senderâ€™s name, which is a string; a subject
    line, which is a string; a sent date, which is a date; whether itâ€™s been read,
    which is a Boolean; and so on.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç»™å®šçš„åˆ—å…·æœ‰ç›¸åŒçš„ç±»å‹ï¼Œä½†ä¸åŒçš„åˆ—å¯ä»¥æœ‰ä¸åŒçš„ç±»å‹ã€‚ä¾‹å¦‚ï¼Œä¸€å°ç”µå­é‚®ä»¶æ¶ˆæ¯æœ‰ä¸€ä¸ªå‘ä»¶äººå§“åï¼Œå®ƒæ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼›ä¸€ä¸ªä¸»é¢˜è¡Œï¼Œå®ƒæ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼›å‘é€æ—¥æœŸï¼Œå®ƒæ˜¯ä¸€ä¸ªæ—¥æœŸï¼›æ˜¯å¦å·²é˜…è¯»ï¼Œå®ƒæ˜¯ä¸€ä¸ªå¸ƒå°”å€¼ï¼›ç­‰ç­‰ã€‚
- en: The rows might be in some particular order. For instance, the emails are ordered
    by which was most recently sent.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¡Œå¯èƒ½æŒ‰ç…§æŸç§ç‰¹å®šçš„é¡ºåºæ’åˆ—ã€‚ä¾‹å¦‚ï¼Œç”µå­é‚®ä»¶æ˜¯æŒ‰ç…§æœ€è¿‘å‘é€çš„é¡ºåºæ’åˆ—çš„ã€‚
- en: Exercise
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Find the characteristics of tabular data in the other examples described above,
    as well as in the ones you described.
  id: totrans-34
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨ä¸Šè¿°å…¶ä»–ç¤ºä¾‹ä¸­ä»¥åŠæ‚¨æè¿°çš„ç¤ºä¾‹ä¸­ï¼Œæ‰¾åˆ°è¡¨æ ¼æ•°æ®çš„ç‰¹å¾ã€‚
- en: 'We will now learn how to program with tables and to how to decompose tasks
    that process them. To access the functions that weâ€™ll use to do this, you need
    to set the context (at the top of the definitions window) to dcic2024\. Earlier
    editions of the book had you use `shared-gdrive` to load a file to access these
    functions. This is no longer necessary when using the dcic2024 context. In CPO,
    click on the down arrow at the top left of the screen (left of the Pyret logo),
    select â€Choose Contextâ€œ, then enter dcic2024 in the box, as shown in this screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•ä½¿ç”¨è¡¨æ ¼ç¼–ç¨‹ä»¥åŠå¦‚ä½•åˆ†è§£å¤„ç†å®ƒä»¬çš„ä»»åŠ¡ã€‚è¦è®¿é—®æˆ‘ä»¬å°†ä½¿ç”¨çš„å‡½æ•°ï¼Œæ‚¨éœ€è¦å°†ä¸Šä¸‹æ–‡ï¼ˆåœ¨å®šä¹‰çª—å£çš„é¡¶éƒ¨ï¼‰è®¾ç½®ä¸ºdcic2024ã€‚æœ¬ä¹¦çš„æ—©æœŸç‰ˆæœ¬è¦æ±‚æ‚¨ä½¿ç”¨`shared-gdrive`æ¥åŠ è½½æ–‡ä»¶ä»¥è®¿é—®è¿™äº›å‡½æ•°ã€‚åœ¨dcic2024ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨æ—¶ï¼Œè¿™ä¸å†å¿…è¦ã€‚åœ¨CPOä¸­ï¼Œç‚¹å‡»å±å¹•å·¦ä¸Šè§’çš„å‘ä¸‹ç®­å¤´ï¼ˆPyretæ ‡å¿—çš„å·¦ä¾§ï¼‰ï¼Œé€‰æ‹©â€œé€‰æ‹©ä¸Šä¸‹æ–‡â€ï¼Œç„¶ååœ¨æ¡†ä¸­è¾“å…¥dcic2024ï¼Œå¦‚å›¾æ‰€ç¤ºï¼š
- en: '![](../Images/710c9c4fd77163faf8376fe746fdec28.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](../Images/710c9c4fd77163faf8376fe746fdec28.png)'
- en: 'After you click the Submit button, the definitions window will show the name
    of the context as in the following image:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ç‚¹å‡»æäº¤æŒ‰é’®åï¼Œå®šä¹‰çª—å£å°†æ˜¾ç¤ºä¸Šä¸‹æ–‡åç§°ï¼Œå¦‚å›¾æ‰€ç¤ºï¼š
- en: '![](../Images/6d810094e710d0cc7fbef1bae2a68941.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](../Images/6d810094e710d0cc7fbef1bae2a68941.png)'
- en: '[Documentation on the function-based table operators](https://hackmd.io/@cs111/table)
    is available on a separate page outside of the Pyret documentation.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[åŸºäºå‡½æ•°çš„è¡¨æ ¼æ“ä½œæ–‡æ¡£](https://hackmd.io/@cs111/table)å¯åœ¨Pyretæ–‡æ¡£ä¹‹å¤–çš„å•ç‹¬é¡µé¢æ‰¾åˆ°ã€‚'
- en: 4.1.1Â Creating Tabular Data[ğŸ”—](#(part._.Creating_.Tabular_.Data) "Link to here")
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1 åˆ›å»ºè¡¨æ ¼æ•°æ®[ğŸ”—](#(part._.Creating_.Tabular_.Data) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Pyret provides multiple easy ways of creating tabular data. The simplest is
    to define the datum in a program as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Pyretæä¾›äº†å¤šç§åˆ›å»ºè¡¨æ ¼æ•°æ®çš„æ–¹æ³•ã€‚æœ€ç®€å•çš„æ˜¯åœ¨ç¨‹åºä¸­å°†æ•°æ®å®šä¹‰ä¸ºå¦‚ä¸‹ï¼š
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That is, a `table` is followed by the names of the columns in their desired
    order, followed by a sequence of `row`s. Each row must contain as many data as
    the column declares, and in the same order.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: å³ï¼Œä¸€ä¸ª`table`åé¢è·Ÿç€åˆ—çš„åç§°ï¼ŒæŒ‰ç…§æ‰€éœ€çš„é¡ºåºï¼Œç„¶åæ˜¯ä¸€ä¸ª`row`åºåˆ—ã€‚æ¯ä¸€è¡Œå¿…é¡»åŒ…å«ä¸åˆ—å£°æ˜ç›¸åŒæ•°é‡çš„æ•°æ®ï¼Œå¹¶ä¸”é¡ºåºç›¸åŒã€‚
- en: Exercise
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Change different parts of the above exampleâ€”<wbr>e.g., remove a necessary value
    from a row, add an extraneous one, remove a comma, add an extra comma, leave an
    extra comma at the end of a rowâ€”<wbr>and see what errors you get.
  id: totrans-46
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ”¹å˜ä¸Šè¿°ç¤ºä¾‹çš„ä¸åŒéƒ¨åˆ†â€”â€”ä¾‹å¦‚ï¼Œä»ä¸€è¡Œä¸­åˆ é™¤ä¸€ä¸ªå¿…è¦çš„å€¼ï¼Œæ·»åŠ ä¸€ä¸ªå¤šä½™çš„å€¼ï¼Œåˆ é™¤ä¸€ä¸ªé€—å·ï¼Œæ·»åŠ ä¸€ä¸ªé¢å¤–çš„é€—å·ï¼Œåœ¨è¡Œæœ«ç•™ä¸‹ä¸€ä¸ªå¤šä½™çš„é€—å·â€”â€”ç„¶åæŸ¥çœ‹æ‚¨ä¼šå¾—åˆ°ä»€ä¹ˆé”™è¯¯ã€‚
- en: 'Note that in a table, the order of columns matters: two tables that are otherwise
    identical but with different column orders are not considered equal.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨è¡¨æ ¼ä¸­ï¼Œåˆ—çš„é¡ºåºå¾ˆé‡è¦ï¼šä¸¤ä¸ªåœ¨å…¶ä»–æ–¹é¢ç›¸åŒä½†åˆ—é¡ºåºä¸åŒçš„è¡¨æ ¼ä¸è¢«è®¤ä¸ºæ˜¯ç›¸ç­‰çš„ã€‚
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Observe that the example above uses `is-not`, i.e., the test passes, meaning
    that the tables are not equal.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„åˆ°ä¸Šé¢çš„ä¾‹å­ä½¿ç”¨äº†`is-not`ï¼Œå³æµ‹è¯•é€šè¿‡ï¼Œè¿™æ„å‘³ç€è¡¨æ ¼ä¸ç›¸ç­‰ã€‚
- en: The `check:` annotation here is a way of writing `is` assertions about expressions
    outside of the context of a function (and its `where` block). Weâ€™ll learn more
    about `check` in [From Examples to Tests](testing.html#%28part._from-examples-to-tests%29).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œçš„`check:`æ³¨é‡Šæ˜¯ç¼–å†™å…³äºå‡½æ•°ï¼ˆåŠå…¶`where`å—ï¼‰ä¸Šä¸‹æ–‡ä¹‹å¤–çš„è¡¨è¾¾å¼çš„`is`æ–­è¨€çš„æ–¹å¼ã€‚æˆ‘ä»¬å°†åœ¨[ä»ç¤ºä¾‹åˆ°æµ‹è¯•](testing.html#%28part._from-examples-to-tests%29)ä¸­äº†è§£æ›´å¤šå…³äº`check`çš„ä¿¡æ¯ã€‚
- en: 'Table expressions create table values. These can be stored in variables just
    like numbers, strings, and images:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: è¡¨è¾¾å¼åˆ›å»ºè¡¨å€¼ã€‚è¿™äº›å¯ä»¥åƒæ•°å­—ã€å­—ç¬¦ä¸²å’Œå›¾åƒä¸€æ ·å­˜å‚¨åœ¨å˜é‡ä¸­ï¼š
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We call these literal tables when we create them with `table`. Pyret provides
    other ways to get tabular data, too! In particular, you can [import tabular data
    from a spreadsheet](https://www.pyret.org/docs/latest/gdrive-sheets.html), so
    any mechanism that lets you create such a sheet can also be used. You might:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬ä½¿ç”¨`table`åˆ›å»ºå®ƒä»¬æ—¶ï¼Œæˆ‘ä»¬ç§°è¿™äº›ä¸ºå­—é¢è¡¨æ ¼ã€‚Pyretè¿˜æä¾›äº†å…¶ä»–è·å–è¡¨æ ¼æ•°æ®çš„æ–¹æ³•ï¼ç‰¹åˆ«æ˜¯ï¼Œæ‚¨å¯ä»¥ä»ç”µå­è¡¨æ ¼[å¯¼å…¥è¡¨æ ¼æ•°æ®](https://www.pyret.org/docs/latest/gdrive-sheets.html)ï¼Œå› æ­¤ä»»ä½•å…è®¸æ‚¨åˆ›å»ºæ­¤ç±»å·¥ä½œè¡¨çš„æœºåˆ¶ä¹Ÿå¯ä»¥ä½¿ç”¨ã€‚æ‚¨å¯èƒ½ï¼š
- en: create the sheet on your own,
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç‹¬è‡ªåˆ›å»ºå·¥ä½œè¡¨ï¼Œ
- en: create a sheet collaboratively with friends,
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸æœ‹å‹åä½œåˆ›å»ºå·¥ä½œè¡¨ï¼Œ
- en: find data on the Web that you can import into a sheet,
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨ç½‘ç»œä¸Šæ‰¾åˆ°å¯ä»¥å¯¼å…¥åˆ°å·¥ä½œè¡¨ä¸­çš„æ•°æ®ï¼Œ
- en: create a Google Form that you get others to fill out, and obtain a sheet out
    of their responses
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ›å»ºä¸€ä¸ªGoogleè¡¨å•ï¼Œè®©å…¶ä»–äººå¡«å†™ï¼Œå¹¶ä»ä»–ä»¬çš„å›å¤ä¸­è·å¾—å·¥ä½œè¡¨ã€‚
- en: and so on. Let your imagination run wild! Once the data are in Pyret, it doesnâ€™t
    matter where they came from.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥æ­¤ç±»æ¨ã€‚è®©ä½ çš„æƒ³è±¡åŠ›è‡ªç”±é©°éª‹ï¼ä¸€æ—¦æ•°æ®è¿›å…¥ Pyretï¼Œå®ƒä»¬æ¥è‡ªå“ªé‡Œå°±ä¸å†é‡è¦äº†ã€‚
- en: With tables, we begin to explore data that contain other (smaller) pieces of
    data. Weâ€™ll refer to such data as structured data. Structured data organize their
    inner data in a structured way (here, rows and columns). As with images, when
    we wrote code that reflected the structure of the final image, we will see that
    code that works with tables also follows the structure of the data.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¡¨æ ¼ï¼Œæˆ‘ä»¬å¼€å§‹æ¢ç´¢åŒ…å«å…¶ä»–ï¼ˆè¾ƒå°ï¼‰æ•°æ®ç‰‡æ®µçš„æ•°æ®ã€‚æˆ‘ä»¬å°†æ­¤ç±»æ•°æ®ç§°ä¸ºç»“æ„åŒ–æ•°æ®ã€‚ç»“æ„åŒ–æ•°æ®ä»¥ç»“æ„åŒ–çš„æ–¹å¼ç»„ç»‡å…¶å†…éƒ¨æ•°æ®ï¼ˆåœ¨è¿™é‡Œï¼Œè¡Œå’Œåˆ—ï¼‰ã€‚ä¸å›¾åƒä¸€æ ·ï¼Œå½“æˆ‘ä»¬ç¼–å†™çš„ä»£ç åæ˜ äº†æœ€ç»ˆå›¾åƒçš„ç»“æ„æ—¶ï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ°ä¸è¡¨æ ¼ä¸€èµ·å·¥ä½œçš„ä»£ç ä¹Ÿéµå¾ªæ•°æ®ç»“æ„ã€‚
- en: 4.1.2Â Extracting Rows and Cell Values[ğŸ”—](#(part._.Extracting_.Rows_and_.Cell_.Values)
    "Link to here")
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.2 æå–è¡Œå’Œå•å…ƒæ ¼å€¼[ğŸ”—](#(part._.Extracting_.Rows_and_.Cell_.Values) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Given a table, we sometimes want to look up the value of a particular cell.
    Weâ€™ll work with the following table showing the number of riders on a shuttle
    service over several months:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªè¡¨æ ¼ï¼Œæˆ‘ä»¬æœ‰æ—¶æƒ³æŸ¥æ‰¾ç‰¹å®šå•å…ƒæ ¼çš„å€¼ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ä»¥ä¸‹è¡¨æ ¼ï¼Œæ˜¾ç¤ºå‡ ä¸ªæœˆæ¥ç©¿æ¢­æœåŠ¡çš„ä¹˜å®¢æ•°é‡ï¼š
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Do Now!
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you put this table in the definitions pane and press Run, what will be in
    the Pyret directory once the interactions prompt appears? Would the column names
    be listed in the directory?
  id: totrans-65
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœä½ å°†è¿™ä¸ªè¡¨æ ¼æ”¾å…¥å®šä¹‰é¢æ¿å¹¶è¿è¡Œï¼Œå½“äº¤äº’å¼æç¤ºå‡ºç°æ—¶ï¼ŒPyret ç›®å½•ä¸­ä¼šæœ‰ä»€ä¹ˆå†…å®¹ï¼Ÿåˆ—åä¼šè¢«åˆ—åœ¨ç›®å½•ä¸­å—ï¼Ÿ
- en: As a reminder, the directory contains only those names that we assign values
    to using the form `name =` . The directory here would contain `shuttle`, which
    would be bound to the table (yes, the entire table would be in the directory!).
    The column names would not have their own entries in the directory. At the low
    level, this is because we never wrote anything of the form `colname = ...`. At
    the high level, we donâ€™t usually build tables by creating individual columns and
    putting them together side by side. (If anything, it is more common to create
    individual rows, since rows correspond to individual observations, events, or
    entities; we didnâ€™t do that in this example, however).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: æé†’ä¸€ä¸‹ï¼Œç›®å½•ä¸­åªåŒ…å«æˆ‘ä»¬ä½¿ç”¨ `name =` å½¢å¼èµ‹å€¼çš„é‚£äº›åç§°ã€‚è¿™é‡Œçš„ç›®å½•å°†åŒ…å« `shuttle`ï¼Œå®ƒå°†ç»‘å®šåˆ°è¡¨æ ¼ä¸Šï¼ˆæ˜¯çš„ï¼Œæ•´ä¸ªè¡¨æ ¼éƒ½ä¼šåœ¨ç›®å½•ä¸­ï¼ï¼‰åˆ—åä¸ä¼šåœ¨ç›®å½•ä¸­å•ç‹¬åˆ—å‡ºã€‚åœ¨åº•å±‚ï¼Œè¿™æ˜¯å› ä¸ºæˆ‘ä»¬ä»æœªç¼–å†™è¿‡
    `colname = ...` å½¢å¼çš„å†…å®¹ã€‚åœ¨é«˜å±‚ï¼Œæˆ‘ä»¬é€šå¸¸ä¸ä¼šé€šè¿‡åˆ›å»ºå•ä¸ªåˆ—å¹¶å°†å®ƒä»¬å¹¶æ’æ”¾ç½®æ¥æ„å»ºè¡¨æ ¼ã€‚ï¼ˆå¦‚æœæœ‰ä»€ä¹ˆä¸åŒçš„è¯ï¼Œåˆ›å»ºå•ä¸ªè¡Œæ›´ä¸ºå¸¸è§ï¼Œå› ä¸ºè¡Œå¯¹åº”äºå•ä¸ªè§‚å¯Ÿã€äº‹ä»¶æˆ–å®ä½“ï¼›ç„¶è€Œåœ¨è¿™ä¸ªä¾‹å­ä¸­æˆ‘ä»¬æ²¡æœ‰è¿™æ ·åšï¼‰ã€‚
- en: Starting from the name associated with a table, we can lookup the value in a
    given cell (row and column) in the table. Concretely, assume we want to extract
    the number of riders in March (`1087`) so we can use it in another computation.
    How do we do that?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ä»ä¸è¡¨æ ¼ç›¸å…³çš„åç§°å¼€å§‹ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è¡¨æ ¼çš„ç»™å®šå•å…ƒæ ¼ï¼ˆè¡Œå’Œåˆ—ï¼‰ä¸­æŸ¥æ‰¾å€¼ã€‚å…·ä½“æ¥è¯´ï¼Œå‡è®¾æˆ‘ä»¬æƒ³æå–ä¸‰æœˆä»½çš„ä¹˜å®¢æ•°é‡ï¼ˆ`1087`ï¼‰ï¼Œä»¥ä¾¿åœ¨å¦ä¸€ä¸ªè®¡ç®—ä¸­ä½¿ç”¨ã€‚æˆ‘ä»¬è¯¥å¦‚ä½•åšï¼Ÿ
- en: Pyret (and most other programming languages designed for data analysis) organizes
    tables as collections of rows with shared columns. Given that organization, we
    get to a specific cell by first isolating the row we are interested in, then retrieving
    the contents of the cell.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Pyretï¼ˆä»¥åŠå¤§å¤šæ•°ä¸ºæ•°æ®åˆ†æè®¾è®¡çš„å…¶ä»–ç¼–ç¨‹è¯­è¨€ï¼‰å°†è¡¨æ ¼ç»„ç»‡ä¸ºå…·æœ‰å…±äº«åˆ—çš„è¡Œé›†åˆã€‚é‰´äºè¿™ç§ç»„ç»‡æ–¹å¼ï¼Œæˆ‘ä»¬é¦–å…ˆéš”ç¦»æˆ‘ä»¬æ„Ÿå…´è¶£çš„è¡Œï¼Œç„¶åæ£€ç´¢å•å…ƒæ ¼çš„å†…å®¹ã€‚
- en: 'Pyret numbers the rows of a table from top to bottom starting at 0 (most programming
    languages use 0 as the first position in a piece of data, for reasons we will
    see later). So if we want to see the data for March, we need to isolate row 2\.
    We write:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret ä»é¡¶éƒ¨åˆ°åº•éƒ¨å¯¹è¡¨æ ¼çš„è¡Œè¿›è¡Œç¼–å·ï¼Œèµ·å§‹ä½ç½®ä¸º 0ï¼ˆå¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€ä½¿ç”¨ 0 ä½œä¸ºæ•°æ®ä¸­çš„ç¬¬ä¸€ä¸ªä½ç½®ï¼ŒåŸå› æˆ‘ä»¬å°†åœ¨åé¢çœ‹åˆ°ï¼‰ã€‚æ‰€ä»¥å¦‚æœæˆ‘ä»¬æƒ³æŸ¥çœ‹ä¸‰æœˆä»½çš„æ•°æ®ï¼Œæˆ‘ä»¬éœ€è¦éš”ç¦»è¡Œ
    2ã€‚æˆ‘ä»¬å†™ï¼š
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We use the period notation to dig into a piece of structured data. Here, we
    are saying "dig into the `shuttle` table, extracting row number `2`" (which is
    really the third row since Pyret counts positions from 0).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä½¿ç”¨ç‚¹ç¬¦å·æ¥æ·±å…¥æ¢ç©¶ç»“æ„åŒ–æ•°æ®ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬è¯´çš„æ˜¯â€œæ·±å…¥ `shuttle` è¡¨æ ¼ï¼Œæå–è¡Œå· `2`â€ï¼ˆå®é™…ä¸Šè¿™æ˜¯ç¬¬ä¸‰è¡Œï¼Œå› ä¸º Pyret ä» 0
    å¼€å§‹è®¡æ•°ä½ç½®ï¼‰ã€‚
- en: If we run this expression at the prompt, we get
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬åœ¨æç¤ºç¬¦ä¸­è¿è¡Œè¿™ä¸ªè¡¨è¾¾å¼ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°
- en: '![](../Images/d60ae702af1ad3975e72ce720628831a.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d60ae702af1ad3975e72ce720628831a.png)'
- en: This is a new type of data called a `Row`. When Pyret displays a `Row` value,
    it shows you the column names and the corresponding values within the row.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ç§æ–°çš„æ•°æ®ç±»å‹ï¼Œç§°ä¸º `Row`ã€‚å½“ Pyret æ˜¾ç¤º `Row` å€¼æ—¶ï¼Œå®ƒä¼šæ˜¾ç¤ºè¡Œåå’Œè¡Œå†…å¯¹åº”çš„å€¼ã€‚
- en: 'To extract the value of a specific column within a row, we write the row followed
    by the name of the column (as a string) in square brackets. Here are two equivalent
    ways of getting the value of the `riders` column from the row for March:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: è¦æå–è¡Œä¸­ç‰¹å®šåˆ—çš„å€¼ï¼Œæˆ‘ä»¬å†™ä¸‹è¡Œåï¼Œç„¶åæ˜¯åˆ—åï¼ˆä½œä¸ºå­—ç¬¦ä¸²ï¼‰çš„æ–¹æ‹¬å·ã€‚ä»¥ä¸‹æ˜¯ä¸¤ç§è·å–ä¸‰æœˆä»½è¡Œä¸­`riders`åˆ—å€¼çš„ç­‰æ•ˆæ–¹å¼ï¼š
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Do Now!
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What names would be in the Pyret directory when using each of these approaches?
  id: totrans-80
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™äº›æ–¹æ³•æ—¶ï¼ŒPyretç›®å½•ä¸­ä¼šæœ‰å“ªäº›åç§°ï¼Ÿ
- en: Once we have the cell value (here a `Number`), we can use it in any other computation,
    such as
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æˆ‘ä»¬æœ‰äº†å•å…ƒæ ¼å€¼ï¼ˆè¿™é‡Œæ˜¯ä¸€ä¸ª`Number`ï¼‰ï¼Œæˆ‘ä»¬å°±å¯ä»¥å°†å…¶ç”¨äºä»»ä½•å…¶ä»–è®¡ç®—ï¼Œä¾‹å¦‚
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: (which checks whether there were at least `1000` riders in March).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆæ£€æŸ¥ä¸‰æœˆä»½æ˜¯å¦æœ‰è‡³å°‘`1000`åä¹˜å®¢ï¼‰ã€‚
- en: Do Now!
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What do you expect would happen if you forgot the quotation marks and instead
    wrote:'
  id: totrans-86
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœä½ å¿˜è®°äº†å¼•å·ï¼Œè€Œæ˜¯å†™äº†ï¼š
- en: ''
  id: totrans-87
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-88
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What would Pyret do and why?
  id: totrans-90
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Pyretä¼šåšä»€ä¹ˆï¼Œä¸ºä»€ä¹ˆï¼Ÿ
- en: 4.1.3Â Functions over Rows[ğŸ”—](#(part._.Functions_over_.Rows) "Link to here")
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.3Â è¡Œä¸Šçš„å‡½æ•°[ğŸ”—](#(part._.Functions_over_.Rows) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Now that we have the ability to isolate Rows from tables, we can write functions
    that ask questions about individual rows. We just saw an example of doing a computation
    over row data, when we checked whether the row for March had more than 1000 riders.
    What if we wanted to do this comparison for an arbitrary row of this table? Letâ€™s
    write a function! Weâ€™ll call it `cleared-1K`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æœ‰äº†ä»è¡¨ä¸­éš”ç¦»è¡Œçš„èƒ½åŠ›ï¼Œæˆ‘ä»¬å¯ä»¥ç¼–å†™è¯¢é—®å•ä¸ªè¡Œçš„å‡½æ•°ã€‚å½“æˆ‘ä»¬æ£€æŸ¥ä¸‰æœˆä»½çš„è¡Œæ˜¯å¦æœ‰è¶…è¿‡1000åä¹˜å®¢æ—¶ï¼Œæˆ‘ä»¬åˆšåˆšçœ‹åˆ°äº†ä¸€ä¸ªåœ¨è¡Œæ•°æ®ä¸Šæ‰§è¡Œè®¡ç®—çš„ç¤ºä¾‹ã€‚å¦‚æœæˆ‘ä»¬æƒ³å¯¹è¿™ä¸ªè¡¨ä¸­çš„ä»»æ„è¡Œè¿›è¡Œè¿™ç§æ¯”è¾ƒå‘¢ï¼Ÿè®©æˆ‘ä»¬å†™ä¸€ä¸ªå‡½æ•°ï¼æˆ‘ä»¬å°†å®ƒå‘½åä¸º`cleared-1K`ã€‚
- en: 'Letâ€™s start with a function header and some examples:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä»å‡½æ•°å¤´å’Œä¸€äº›ç¤ºä¾‹å¼€å§‹ï¼š
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This shows you what examples for `Row` functions look like, as well as how we
    use `Row` as an input type.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å±•ç¤ºäº†`Row`å‡½æ•°çš„ç¤ºä¾‹æ˜¯ä»€ä¹ˆæ ·çš„ï¼Œä»¥åŠæˆ‘ä»¬å¦‚ä½•ä½¿ç”¨`Row`ä½œä¸ºè¾“å…¥ç±»å‹ã€‚
- en: 'To fill in the body of the function, we extract the content of the `"riders"`
    cell and compare it to `1000`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: è¦å¡«å†™å‡½æ•°çš„ä¸»ä½“ï¼Œæˆ‘ä»¬æå–`"riders"`å•å…ƒæ ¼çš„å†…å®¹ï¼Œå¹¶å°†å…¶ä¸`1000`è¿›è¡Œæ¯”è¾ƒï¼š
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Do Now!
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Looking at the examples, both of them share the `shuttle.row-n` portion. Would
    it have been better to instead make `cleared-1K` a function that takes just the
    row position as input, such as:'
  id: totrans-100
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: çœ‹çœ‹è¿™äº›ç¤ºä¾‹ï¼Œå®ƒä»¬éƒ½å…±äº«äº†`shuttle.row-n`éƒ¨åˆ†ã€‚æ˜¯å¦æ›´å¥½çš„åšæ³•æ˜¯å°†`cleared-1K`æ”¹ä¸ºä¸€ä¸ªåªæ¥å—è¡Œä½ç½®ä½œä¸ºè¾“å…¥çš„å‡½æ•°ï¼Œä¾‹å¦‚ï¼š
- en: ''
  id: totrans-101
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-102
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ''
  id: totrans-103
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are the benefits and limitations to doing this?
  id: totrans-104
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åšè¿™ä»¶äº‹æœ‰ä»€ä¹ˆå¥½å¤„å’Œå±€é™æ€§ï¼Ÿ
- en: In general, the version that takes the `Row` input is more flexible because
    it can work with a row from any table that has a column named `"riders"`. We might
    have another table with more columns of information or different data tables for
    different years. If we modify `cleared-1K` to only take the row position as input,
    that function will have to fix which table it works with. In contrast, our original
    version leaves the specific table (`shuttle`) outside the function, which leads
    to flexibility.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: é€šå¸¸ï¼Œæ¥å—`Row`è¾“å…¥çš„ç‰ˆæœ¬æ›´çµæ´»ï¼Œå› ä¸ºå®ƒå¯ä»¥ä¸ä»»ä½•å…·æœ‰åä¸º`"riders"`çš„åˆ—çš„è¡¨ä¸­çš„è¡Œä¸€èµ·å·¥ä½œã€‚æˆ‘ä»¬å¯èƒ½è¿˜æœ‰åŒ…å«æ›´å¤šåˆ—ä¿¡æ¯æˆ–ä¸åŒå¹´ä»½çš„æ•°æ®è¡¨çš„å¦ä¸€ä¸ªè¡¨ã€‚å¦‚æœæˆ‘ä»¬ä¿®æ”¹`cleared-1K`ä»¥ä»…æ¥å—è¡Œä½ç½®ä½œä¸ºè¾“å…¥ï¼Œé‚£ä¹ˆè¯¥å‡½æ•°å°†å¿…é¡»å›ºå®šå®ƒæ‰€å·¥ä½œçš„è¡¨ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œæˆ‘ä»¬çš„åŸå§‹ç‰ˆæœ¬å°†ç‰¹å®šçš„è¡¨ï¼ˆ`shuttle`ï¼‰æ”¾åœ¨å‡½æ•°å¤–éƒ¨ï¼Œè¿™å¸¦æ¥äº†çµæ´»æ€§ã€‚
- en: Exercise
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function `is-winter` that takes a `Row` with a `"month"` column as input
    and produces a `Boolean` indicating whether the month in that row is one of `"Jan"`,
    `"Feb"`, or `"Mar"`.
  id: totrans-108
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ä¸€ä¸ªå‡½æ•°`is-winter`ï¼Œå®ƒæ¥å—ä¸€ä¸ªå¸¦æœ‰`"month"`åˆ—çš„`Row`ä½œä¸ºè¾“å…¥ï¼Œå¹¶äº§ç”Ÿä¸€ä¸ª`Boolean`å€¼ï¼ŒæŒ‡ç¤ºè¯¥è¡Œä¸­çš„æœˆä»½æ˜¯å¦æ˜¯`"Jan"`ã€`"Feb"`æˆ–`"Mar"`ä¹‹ä¸€ã€‚
- en: Exercise
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function `low-winter` that takes in `Row` with both `"month"` and `"riders"`
    columns and produces a `Boolean` indicating whether the row is a winter row with
    fewer than 1050 riders.
  id: totrans-111
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ä¸€ä¸ªå‡½æ•°`low-winter`ï¼Œå®ƒæ¥å—å¸¦æœ‰`"month"`å’Œ`"riders"`åˆ—çš„`Row`ï¼Œå¹¶äº§ç”Ÿä¸€ä¸ª`Boolean`å€¼ï¼ŒæŒ‡ç¤ºè¯¥è¡Œæ˜¯å¦æ˜¯å°‘äº1050åä¹˜å®¢çš„å†¬å­£è¡Œã€‚
- en: Exercise
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Practice with the program directory! Take a `Row` function and one of its `where`
    examples, and show how the program directory evolves as you evaluate the example.
  id: totrans-114
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨ç¨‹åºç›®å½•ä¸­è¿›è¡Œç»ƒä¹ ï¼å–ä¸€ä¸ª`Row`å‡½æ•°åŠå…¶ä¸€ä¸ª`where`ç¤ºä¾‹ï¼Œå¹¶å±•ç¤ºå½“ä½ è¯„ä¼°ç¤ºä¾‹æ—¶ç¨‹åºç›®å½•æ˜¯å¦‚ä½•æ¼”å˜çš„ã€‚
- en: 4.1.4Â Processing Rows[ğŸ”—](#(part._.Processing_.Rows) "Link to here")
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.4Â å¤„ç†è¡Œ[ğŸ”—](#(part._.Processing_.Rows) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'So far, we have looked at extracting individual rows by their position in the
    table and computing over them. Extracting rows by position isnâ€™t always convenient:
    we might have hundreds or thousands of rows, and we might not know where the data
    we want even is in the table. We would much rather be able to write a small program
    that identifies the row (or rows!) that meets a specific criterion.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»æ¢è®¨äº†é€šè¿‡åœ¨è¡¨ä¸­çš„ä½ç½®æå–å•ä¸ªè¡Œå¹¶å¯¹å®ƒä»¬è¿›è¡Œè®¡ç®—ã€‚æŒ‰ä½ç½®æå–è¡Œå¹¶ä¸æ€»æ˜¯æ–¹ä¾¿çš„ï¼šæˆ‘ä»¬å¯èƒ½æœ‰æ•°ç™¾æˆ–æ•°åƒè¡Œï¼Œæˆ‘ä»¬ç”šè‡³ä¸çŸ¥é“æˆ‘ä»¬æƒ³è¦çš„æ•°æ®åœ¨è¡¨ä¸­åœ¨å“ªé‡Œã€‚æˆ‘ä»¬æ›´æ„¿æ„èƒ½å¤Ÿç¼–å†™ä¸€ä¸ªå°ç¨‹åºæ¥è¯†åˆ«æ»¡è¶³ç‰¹å®šæ ‡å‡†çš„è¡Œï¼ˆæˆ–è¡Œï¼ï¼‰ã€‚
- en: 'Pyret offers three different notations for processing tables: one uses functions,
    one uses methods, and one uses a SQL-like notation. This chapter uses the function-based
    notation. The SQL-like notation and the methods-based notation are shown in the
    Pyret Documentation. To use the function-based notation, youâ€™ll need to include
    the file specified in the main narrative.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret æä¾›äº†ä¸‰ç§ä¸åŒçš„å¤„ç†è¡¨çš„è¡¨ç¤ºæ³•ï¼šä¸€ç§ä½¿ç”¨å‡½æ•°ï¼Œä¸€ç§ä½¿ç”¨æ–¹æ³•ï¼Œè¿˜æœ‰ä¸€ç§ä½¿ç”¨ç±»ä¼¼ SQL çš„è¡¨ç¤ºæ³•ã€‚æœ¬ç« ä½¿ç”¨åŸºäºå‡½æ•°çš„è¡¨ç¤ºæ³•ã€‚ç±»ä¼¼ SQL çš„è¡¨ç¤ºæ³•å’ŒåŸºäºæ–¹æ³•çš„è¡¨ç¤ºæ³•åœ¨
    Pyret æ–‡æ¡£ä¸­å±•ç¤ºã€‚è¦ä½¿ç”¨åŸºäºå‡½æ•°çš„è¡¨ç¤ºæ³•ï¼Œä½ éœ€è¦åŒ…å«ä¸»å™äº‹ä¸­æŒ‡å®šçš„æ–‡ä»¶ã€‚
- en: The rest of this section assumes that you have loaded the functions notations
    for working with tables.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬èŠ‚çš„å…¶ä½™éƒ¨åˆ†å‡è®¾ä½ å·²ç»åŠ è½½äº†ç”¨äºå¤„ç†è¡¨çš„å‡½æ•°ç¬¦å·ã€‚
- en: 4.1.4.1Â Finding Rows[ğŸ”—](#(part._subsec~3afinding-rows) "Link to here")
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.1.4.1 æŸ¥æ‰¾è¡Œ[ğŸ”—](#(part._subsec~3afinding-rows) "é“¾æ¥è‡³æ­¤")
- en: 'Imagine that we wanted to write a program to locate a row that has fewer than
    `1000` riders from our `shuttle` table. With what weâ€™ve studied so far, how might
    we try to write this? We could imagine using a conditional, like follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬æƒ³è¦ç¼–å†™ä¸€ä¸ªç¨‹åºæ¥å®šä½ `shuttle` è¡¨ä¸­å°‘äº `1000` åä¹˜å®¢çš„è¡Œã€‚æ ¹æ®æˆ‘ä»¬è¿„ä»Šä¸ºæ­¢æ‰€å­¦çš„å†…å®¹ï¼Œæˆ‘ä»¬å¦‚ä½•å°è¯•ç¼–å†™è¿™ä¸ªç¨‹åºï¼Ÿæˆ‘ä»¬å¯ä»¥æƒ³è±¡ä½¿ç”¨ä¸€ä¸ªæ¡ä»¶ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Do Now!
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What benefits and limitations do you see to this approach?
  id: totrans-124
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ è®¤ä¸ºè¿™ç§æ–¹æ³•çš„ä¼˜ç‚¹å’Œå±€é™æ€§æ˜¯ä»€ä¹ˆï¼Ÿ
- en: There are a couple of reasons why we might not care for this solution. First,
    if we have thousands of rows, this will be terribly painful to write. Second,
    thereâ€™s a lot of repetition here (only the row positions are changing). Third,
    it isnâ€™t clear what to do if there arenâ€™t any matching rows. In addition, what
    happens if there are multiple rows that meet our criterion? In some cases, we
    might want to be able to identify all of the rows that meet a condition and use
    them for a subsequent computation (like seeing whether some months have more low-ridership
    days than others).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰å‡ ä¸ªåŸå› æˆ‘ä»¬å¯èƒ½ä¸å–œæ¬¢è¿™ä¸ªè§£å†³æ–¹æ¡ˆã€‚é¦–å…ˆï¼Œå¦‚æœæˆ‘ä»¬æœ‰æ•°åƒè¡Œï¼Œè¿™å°†éå¸¸ç—›è‹¦åœ°ç¼–å†™ã€‚å…¶æ¬¡ï¼Œè¿™é‡Œæœ‰å¾ˆå¤šé‡å¤ï¼ˆåªæœ‰è¡Œä½ç½®åœ¨å˜åŒ–ï¼‰ã€‚ç¬¬ä¸‰ï¼Œå¦‚æœæ²¡æœ‰ä»»ä½•åŒ¹é…çš„è¡Œï¼Œä¸æ¸…æ¥šè¯¥æ€ä¹ˆåŠã€‚æ­¤å¤–ï¼Œå¦‚æœæœ‰å¤šä¸ªè¡Œç¬¦åˆæˆ‘ä»¬çš„æ ‡å‡†ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯èƒ½å¸Œæœ›èƒ½å¤Ÿè¯†åˆ«æ‰€æœ‰ç¬¦åˆæ¡ä»¶çš„è¡Œï¼Œå¹¶ä½¿ç”¨å®ƒä»¬è¿›è¡Œåç»­è®¡ç®—ï¼ˆä¾‹å¦‚ï¼ŒæŸ¥çœ‹æ˜¯å¦æœ‰å‡ ä¸ªæœˆçš„ä¹˜å®¢è¾ƒå°‘çš„å¤©æ•°æ¯”å…¶ä»–æœˆä»½å¤šï¼‰ã€‚
- en: 'This conditional is, however, the spirit of what we want to do: go through
    the rows of the table one at a time, identifying those that match some criterion.
    We just donâ€™t want to be responsible for manually checking each row. Fortunately
    for us, Pyret knows how to do that. Pyret knows which rows are in a given table.
    Pyret can pull out those rows one position at a time and check a criterion about
    each one.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œè¿™ä¸ªæ¡ä»¶çš„ç²¾ç¥æ­£æ˜¯æˆ‘ä»¬æƒ³è¦åšçš„ï¼šé€è¡Œéå†è¡¨ä¸­çš„è¡Œï¼Œè¯†åˆ«é‚£äº›ç¬¦åˆæŸäº›æ ‡å‡†çš„è¡Œã€‚æˆ‘ä»¬åªæ˜¯ä¸æƒ³æ‰‹åŠ¨æ£€æŸ¥æ¯ä¸€è¡Œã€‚å¹¸è¿çš„æ˜¯ï¼ŒPyret çŸ¥é“å¦‚ä½•åšã€‚Pyret
    çŸ¥é“ç»™å®šè¡¨ä¸­æœ‰å“ªäº›è¡Œã€‚Pyret å¯ä»¥é€ä¸ªä½ç½®æå–è¿™äº›è¡Œï¼Œå¹¶å¯¹æ¯ä¸€è¡Œæ£€æŸ¥ä¸€ä¸ªæ ‡å‡†ã€‚
- en: We just need to tell Pyret what criterion we want to use.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åªéœ€è¦å‘Šè¯‰ Pyret æˆ‘ä»¬æƒ³ä½¿ç”¨ä»€ä¹ˆæ ‡å‡†ã€‚
- en: 'As before, we can express our criterion as a function that takes a `Row` and
    produces a `Boolean` (a Boolean because our criterion was used as the question
    part of an `if` expression in our code sketch). In this case, we want:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ä¹‹å‰ä¸€æ ·ï¼Œæˆ‘ä»¬å¯ä»¥å°†æˆ‘ä»¬çš„æ ‡å‡†è¡¨è¾¾ä¸ºä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ª `Row` å¹¶äº§ç”Ÿä¸€ä¸ª `Boolean`ï¼ˆå› ä¸ºæˆ‘ä»¬çš„æ ‡å‡†åœ¨ä»£ç è‰å›¾ä¸­çš„ `if` è¡¨è¾¾å¼çš„æ¡ä»¶éƒ¨åˆ†è¢«ç”¨ä½œé—®é¢˜ï¼‰ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬æƒ³è¦ï¼š
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we just need a way to tell Pyret to use this criterion as it searches
    through the rows. We do this with a function called `filter-with` which takes
    two inputs: the table to process and the criterion to check on each row of the
    table.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬åªéœ€è¦ä¸€ç§æ–¹æ³•æ¥å‘Šè¯‰ Pyret åœ¨æœç´¢è¡Œæ—¶ä½¿ç”¨è¿™ä¸ªæ ‡å‡†ã€‚æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªåä¸º `filter-with` çš„å‡½æ•°æ¥å®ç°ï¼Œå®ƒæ¥å—ä¸¤ä¸ªè¾“å…¥ï¼šè¦å¤„ç†çš„è¡¨å’Œè¦æ£€æŸ¥çš„æ¯è¡Œæ ‡å‡†ã€‚
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Under the hood, `filter-with` works roughly like the `if` statement we outlined
    above: it takes each row one at a time and calls the given criterion function
    on it. But what does it do with the results?'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨åº•å±‚ï¼Œ`filter-with` çš„å·¥ä½œæ–¹å¼å¤§è‡´ç±»ä¼¼äºæˆ‘ä»¬ä¸Šé¢æ¦‚è¿°çš„ `if` è¯­å¥ï¼šå®ƒé€è¡Œå¤„ç†æ¯ä¸€è¡Œï¼Œå¹¶å¯¹å®ƒè°ƒç”¨ç»™å®šçš„æ ‡å‡†å‡½æ•°ã€‚ä½†å®ƒå¯¹ç»“æœåšäº†ä»€ä¹ˆï¼Ÿ
- en: 'If you run the above expression, youâ€™ll see that `filter-with` produces a table
    containing the matching row, not the row by itself. This behavior is handy if
    multiple rows match the criterion. For example, try:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ è¿è¡Œä¸Šé¢çš„è¡¨è¾¾å¼ï¼Œä½ ä¼šçœ‹åˆ°`filter-with`äº§ç”Ÿäº†ä¸€ä¸ªåŒ…å«åŒ¹é…è¡Œçš„è¡¨æ ¼ï¼Œè€Œä¸æ˜¯å•ç‹¬çš„è¡Œã€‚å¦‚æœæœ‰å¤šè¡ŒåŒ¹é…æ ‡å‡†ï¼Œè¿™ç§è¡Œä¸ºä¼šå¾ˆæœ‰ç”¨ã€‚ä¾‹å¦‚ï¼Œå°è¯•ï¼š
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '(using the `is-winter` function from an exercise earlier in this chapter).
    Now we get a table with the three rows corresponding to winter months. If we want
    to be able to name this table for use in future computations, we can do so with
    our usual notation for naming values:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆä½¿ç”¨æœ¬ç« æ—©æœŸç»ƒä¹ ä¸­ä½¿ç”¨çš„`is-winter`å‡½æ•°ï¼‰ã€‚ç°åœ¨æˆ‘ä»¬å¾—åˆ°äº†ä¸€ä¸ªåŒ…å«å¯¹åº”å†¬å­£æœˆä»½çš„ä¸‰è¡Œè¡¨æ ¼ã€‚å¦‚æœæˆ‘ä»¬æƒ³è¦åœ¨æœªæ¥çš„è®¡ç®—ä¸­ä½¿ç”¨è¿™ä¸ªè¡¨æ ¼ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨æˆ‘ä»¬é€šå¸¸çš„å‘½åå€¼çš„æ–¹æ³•æ¥åšï¼š
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 4.1.4.2Â Ordering Rows[ğŸ”—](#(part._.Ordering_.Rows) "Link to here")
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.1.4.2Â è¡Œæ’åº[ğŸ”—](#(part._.Ordering_.Rows) "é“¾æ¥è‡³æ­¤")
- en: 'Letâ€™s ask a new question: which winter month had the fewest number of riders?.
    This question requires us to identify a specific row, namely, the winter row with
    the smallest value in the `"riders"` column.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æå‡ºä¸€ä¸ªæ–°çš„é—®é¢˜ï¼šå“ªä¸ªæœˆä»½çš„å†¬å­£éª‘è¡Œè€…äººæ•°æœ€å°‘ï¼Ÿè¿™ä¸ªé—®é¢˜è¦æ±‚æˆ‘ä»¬è¯†åˆ«ç‰¹å®šçš„ä¸€è¡Œï¼Œå³â€œridersâ€åˆ—ä¸­å€¼æœ€å°çš„å†¬å­£è¡Œã€‚
- en: Do Now!
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can we do this with `filter-with`? Why or why not?
  id: totrans-141
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ç”¨`filter-with`æ¥åšè¿™ä»¶äº‹å—ï¼Ÿä¸ºä»€ä¹ˆå¯ä»¥æˆ–ä¸å¯ä»¥ï¼Ÿ
- en: 'Think back to the `if` expression that motivated `filter-with`: each row is
    evaluated independently of the others. Our current question, however, requires
    comparing across rows. Thatâ€™s a different operation, so we will need more than
    `filter-with`.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: å›æƒ³ä¸€ä¸‹`if`è¡¨è¾¾å¼ï¼Œå®ƒæ˜¯`filter-with`çš„åŠ¨æœºï¼šæ¯ä¸€è¡Œéƒ½æ˜¯ç‹¬ç«‹äºå…¶ä»–è¡Œè¿›è¡Œè¯„ä¼°çš„ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å½“å‰çš„é—®é¢˜éœ€è¦è·¨è¡Œæ¯”è¾ƒã€‚è¿™æ˜¯ä¸€ä¸ªä¸åŒçš„æ“ä½œï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦æ¯”`filter-with`æ›´å¤šçš„ä¸œè¥¿ã€‚
- en: 'Tools for analyzing data (whether programming languages or spreadsheets) provide
    ways for users to sort rows of a table based on the values in a single column.
    That would help us here: we could sort the winter rows from smallest to largest
    value in the `"riders"` column, then extract the `"riders"` value from the first
    row. First, letâ€™s sort the rows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ†ææ•°æ®ï¼ˆæ— è®ºæ˜¯ç¼–ç¨‹è¯­è¨€è¿˜æ˜¯ç”µå­è¡¨æ ¼ï¼‰çš„å·¥å…·ä¸ºç”¨æˆ·æä¾›äº†ä¸€ç§æ–¹æ³•ï¼Œå¯ä»¥æ ¹æ®å•åˆ—ä¸­çš„å€¼å¯¹è¡¨æ ¼çš„è¡Œè¿›è¡Œæ’åºã€‚è¿™åœ¨è¿™é‡Œä¼šæœ‰æ‰€å¸®åŠ©ï¼šæˆ‘ä»¬å¯ä»¥æŒ‰â€œridersâ€åˆ—çš„æœ€å°åˆ°æœ€å¤§å€¼å¯¹å†¬å­£è¡Œè¿›è¡Œæ’åºï¼Œç„¶åä»ç¬¬ä¸€è¡Œæå–â€œridersâ€å€¼ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬å¯¹è¡Œè¿›è¡Œæ’åºï¼š
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `order-by` function takes three inputs: the table to sort (`winter`), the
    column to sort on (`"riders"`), and a `Boolean` to indicate whether we want to
    sort in increasing order. (Had the third argument been `false`, the rows would
    be sorted in decreasing order of the values in the named column.)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`order-by`å‡½æ•°æœ‰ä¸‰ä¸ªè¾“å…¥ï¼šè¦æ’åºçš„è¡¨æ ¼ï¼ˆ`winter`ï¼‰ï¼Œæ’åºçš„åˆ—ï¼ˆ`"riders"`ï¼‰ï¼Œä»¥åŠä¸€ä¸ª`Boolean`å€¼ï¼Œè¡¨ç¤ºæˆ‘ä»¬æ˜¯å¦å¸Œæœ›æŒ‰å‡åºæ’åºã€‚ï¼ˆå¦‚æœç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯`false`ï¼Œåˆ™è¡Œå°†æŒ‰åˆ—ä¸­å€¼çš„é™åºæ’åºã€‚ï¼‰'
- en: '![](../Images/50fd4ee1a960ed4942030557bea37389.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](../Images/50fd4ee1a960ed4942030557bea37389.png)'
- en: In the sorted table, the row with the fewest riders is in the first position.
    Our original question asked us to lookup the month with the fewest riders. We
    did this earlier.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ’åºåçš„è¡¨æ ¼ä¸­ï¼Œéª‘è¡Œè€…äººæ•°æœ€å°‘çš„è¡Œä½äºç¬¬ä¸€ä½ã€‚æˆ‘ä»¬åŸæ¥çš„é—®é¢˜è¦æ±‚æˆ‘ä»¬æŸ¥æ‰¾éª‘è¡Œè€…äººæ•°æœ€å°‘çš„æœˆä»½ã€‚æˆ‘ä»¬ä¹‹å‰å·²ç»è¿™æ ·åšè¿‡äº†ã€‚
- en: Do Now!
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write the code to extract the name of the winter month with the fewest riders.
  id: totrans-150
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ä»£ç ä»¥æå–éª‘è¡Œè€…äººæ•°æœ€å°‘çš„å†¬å­£æœˆä»½çš„åç§°ã€‚
- en: 'Here are two ways to write that computation:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸¤ç§ç¼–å†™è¿™ç§è®¡ç®—çš„æ–¹æ³•ï¼š
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Do Now!
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of these two ways do you prefer? Why?
  id: totrans-156
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ æ›´å–œæ¬¢è¿™ä¸¤ç§æ–¹æ³•ä¸­çš„å“ªä¸€ç§ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ
- en: Do Now!
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How does each of these programs affect the program directory?
  id: totrans-159
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™äº›ç¨‹åºä¸­çš„æ¯ä¸€ä¸ªæ˜¯å¦‚ä½•å½±å“ç¨‹åºç›®å½•çš„ï¼Ÿ
- en: 'Note that this problem asked us to combine several actions that weâ€™ve already
    seen on rows: we identify rows from within a table (`filter-with`), order the
    rows (`order-by`), extract a specific row (`row-n`), then extract a cell (with
    square brackets and a column name). This is typical of how we will operate on
    tables, combining multiple operations to compute a result (much as we did with
    programs that manipulate images).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè¿™ä¸ªé—®é¢˜è¦æ±‚æˆ‘ä»¬ç»“åˆæˆ‘ä»¬å·²ç»çœ‹åˆ°çš„å‡ ä¸ªå…³äºè¡Œçš„æ“ä½œï¼šæˆ‘ä»¬åœ¨è¡¨æ ¼å†…è¯†åˆ«è¡Œï¼ˆ`filter-with`ï¼‰ï¼Œæ’åºè¡Œï¼ˆ`order-by`ï¼‰ï¼Œæå–ç‰¹å®šè¡Œï¼ˆ`row-n`ï¼‰ï¼Œç„¶åæå–å•å…ƒæ ¼ï¼ˆä½¿ç”¨æ–¹æ‹¬å·å’Œåˆ—åï¼‰ã€‚è¿™æ˜¯æˆ‘ä»¬æ“ä½œè¡¨æ ¼çš„å…¸å‹æ–¹å¼ï¼Œç»“åˆå¤šä¸ªæ“ä½œæ¥è®¡ç®—ç»“æœï¼ˆå°±åƒæˆ‘ä»¬å¤„ç†å›¾åƒçš„ç¨‹åºä¸€æ ·ï¼‰ã€‚
- en: 4.1.4.3Â Adding New Columns[ğŸ”—](#(part._.Adding_.New_.Columns) "Link to here")
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.1.4.3Â æ·»åŠ æ–°åˆ—[ğŸ”—](#(part._.Adding_.New_.Columns) "é“¾æ¥è‡³æ­¤")
- en: 'Sometimes, we want to create a new column whose value is based on those of
    existing columns. For instance, our table might reflect employee records, and
    have columns named `hourly-wage` and `hours-worked`, representing the corresponding
    quantities. We would now like to extend this table with a new column to reflect
    each employeeâ€™s total wage. Assume we started with the following table:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰æ—¶å€™ï¼Œæˆ‘ä»¬æƒ³è¦åˆ›å»ºä¸€ä¸ªæ–°åˆ—ï¼Œå…¶å€¼åŸºäºç°æœ‰åˆ—çš„å€¼ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬çš„è¡¨æ ¼å¯èƒ½åæ˜ äº†å‘˜å·¥è®°å½•ï¼Œå¹¶å…·æœ‰åä¸º `hourly-wage` å’Œ `hours-worked`
    çš„åˆ—ï¼Œåˆ†åˆ«ä»£è¡¨ç›¸åº”çš„æ•°é‡ã€‚æˆ‘ä»¬ç°åœ¨æƒ³è¦æ‰©å±•è¿™ä¸ªè¡¨æ ¼ï¼Œæ·»åŠ ä¸€ä¸ªæ–°åˆ—æ¥åæ˜ æ¯ä½å‘˜å·¥çš„å·¥èµ„æ€»é¢ã€‚å‡è®¾æˆ‘ä»¬ä»ä¸€ä¸ªä»¥ä¸‹è¡¨æ ¼å¼€å§‹ï¼š
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The table we want to end up with is:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¸Œæœ›æœ€ç»ˆå¾—åˆ°çš„è¡¨æ ¼æ˜¯ï¼š
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '(with the expressions in the `total-wage` column computed to their numeric
    equivalents: we used the expressions here to illustrate what we are trying to
    do).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆå°† `total-wage` åˆ—ä¸­çš„è¡¨è¾¾å¼è®¡ç®—ä¸ºå®ƒä»¬çš„æ•°å€¼ç­‰æ•ˆï¼šæˆ‘ä»¬åœ¨è¿™é‡Œä½¿ç”¨è¡¨è¾¾å¼æ¥å±•ç¤ºæˆ‘ä»¬è¯•å›¾åšä»€ä¹ˆï¼‰ã€‚
- en: Previously, when we have had a computation that we performed multiple times,
    we created a helper function to do the computation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¹‹å‰ï¼Œå½“æˆ‘ä»¬æœ‰ä¸€ä¸ªå¤šæ¬¡æ‰§è¡Œçš„è®¡ç®—æ—¶ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªè¾…åŠ©å‡½æ•°æ¥æ‰§è¡Œè¿™ä¸ªè®¡ç®—ã€‚
- en: Do Now!
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Propose a helper function for computing total wages given the hourly wage and
    number of hours worked.
  id: totrans-170
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æå‡ºä¸€ä¸ªè¾…åŠ©å‡½æ•°ï¼Œç”¨äºæ ¹æ®æ—¶è–ªå’Œå·¥æ—¶è®¡ç®—æ€»å·¥èµ„ã€‚
- en: 'Perhaps you came up with something like:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹Ÿè®¸ä½ æå‡ºäº†ä»¥ä¸‹æƒ³æ³•ï¼š
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'which we could use as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ–¹å¼ï¼š
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is the right idea, but we can actually have this function do a bit more
    work for us. The `wage` and `hours` values are in cells within the same row. So
    if we could instead get the current row as an input, we could write:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªæ­£ç¡®çš„æƒ³æ³•ï¼Œä½†å®é™…ä¸Šæˆ‘ä»¬å¯ä»¥è®©è¿™ä¸ªå‡½æ•°ä¸ºæˆ‘ä»¬åšæ›´å¤šçš„å·¥ä½œã€‚`wage` å’Œ `hours` å€¼ä½äºåŒä¸€è¡Œçš„å•å…ƒæ ¼ä¸­ã€‚å› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬èƒ½å¤Ÿè·å–å½“å‰è¡Œä½œä¸ºè¾“å…¥ï¼Œæˆ‘ä»¬å¯ä»¥ç¼–å†™ï¼š
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'But now, we are writing calls to `compute-wages` over and over! Adding computed
    columns is a sufficiently common operation that Pyret provides a table function
    called `build-column` for this purpose. We use it by providing the function to
    use to populate values in the new column as an input:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†ç°åœ¨ï¼Œæˆ‘ä»¬ä¸æ–­åœ°åœ¨é‡å¤è°ƒç”¨ `compute-wages`ï¼æ·»åŠ è®¡ç®—åˆ—æ˜¯ä¸€ä¸ªè¶³å¤Ÿå¸¸è§çš„æ“ä½œï¼ŒPyret æä¾›äº†ä¸€ä¸ªåä¸º `build-column`
    çš„è¡¨æ ¼å‡½æ•°æ¥æ‰§è¡Œæ­¤æ“ä½œã€‚æˆ‘ä»¬é€šè¿‡æä¾›ç”¨äºå¡«å……æ–°åˆ—å€¼çš„å‡½æ•°ä½œä¸ºè¾“å…¥æ¥ä½¿ç”¨å®ƒï¼š
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This creates a new column, `total-wage`, whose value in each row is the product
    of the two named columns in that row. Pyret will put the new column at the right
    end.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™åˆ›å»ºäº†ä¸€ä¸ªåä¸º `total-wage` çš„æ–°åˆ—ï¼Œå…¶ä¸­æ¯è¡Œçš„å€¼æ˜¯é‚£ä¸€è¡Œä¸­ä¸¤ä¸ªå‘½ååˆ—çš„ä¹˜ç§¯ã€‚Pyret å°†å°†æ–°åˆ—æ”¾åœ¨æ­£ç¡®çš„ä½ç½®ã€‚
- en: 4.1.4.4Â Calculating New Column Values[ğŸ”—](#(part._.Calculating_.New_.Column_.Values)
    "Link to here")
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.1.4.4Â è®¡ç®—æ–°åˆ—å€¼[ğŸ”—](#(part._.Calculating_.New_.Column_.Values) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Sometimes, we just want to calculate new values for an existing column, rather
    than create an entirely new column. Giving raises to employees is one such example.
    Assume we wanted to give a `10%` raise to all employees making less than `20`
    an hour. We could write:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰æ—¶å€™ï¼Œæˆ‘ä»¬åªæƒ³ä¸ºç°æœ‰åˆ—è®¡ç®—æ–°å€¼ï¼Œè€Œä¸æ˜¯åˆ›å»ºä¸€ä¸ªå…¨æ–°çš„åˆ—ã€‚ç»™å‘˜å·¥åŠ è–ªå°±æ˜¯ä¸€ä¸ªä¾‹å­ã€‚å‡è®¾æˆ‘ä»¬æƒ³è¦ç»™æ¯å°æ—¶å·¥èµ„å°‘äº `20` ç¾å…ƒçš„æ‰€æœ‰å‘˜å·¥åŠ è–ª `10%`ã€‚æˆ‘ä»¬å¯ä»¥ç¼–å†™ï¼š
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, `transform-column` takes a table, the name of an existing column in the
    table, and a function to update the value. The updating function takes the current
    value in the column as input and produces the new value for the column as output.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œ`transform-column` å‡½æ•°æ¥å—ä¸€ä¸ªè¡¨æ ¼ã€è¡¨æ ¼ä¸­ç°æœ‰åˆ—çš„åç§°ä»¥åŠä¸€ä¸ªç”¨äºæ›´æ–°å€¼çš„å‡½æ•°ã€‚æ›´æ–°å‡½æ•°æ¥æ”¶åˆ—ä¸­çš„å½“å‰å€¼ä½œä¸ºè¾“å…¥ï¼Œå¹¶ç”Ÿæˆåˆ—çš„æ–°å€¼ä½œä¸ºè¾“å‡ºã€‚
- en: Do Now!
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Run `give-raises` on the `employees` table. What wage will show for `"Miyako"`
    in the `employees` table after `give-raises` completes. Why?
  id: totrans-186
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨ `employees` è¡¨æ ¼ä¸Šè¿è¡Œ `give-raises`ã€‚åœ¨ `give-raises` å®Œæˆåï¼Œ`employees` è¡¨æ ¼ä¸­ `"Miyako"`
    çš„å·¥èµ„å°†æ˜¾ç¤ºä¸ºå¤šå°‘ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ
- en: Like all other Pyret `Table` operations, `transform-column` produces a new table,
    leaving the original intact. Editing the original table could be problematicâ€“what
    if you made a mistake? How would you recover the original table in that case?
    In general, producing new tables with any modifications, then creating a new name
    for the updated table once you have the one you want, is a less error-prone way
    of working with datasets.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸æ‰€æœ‰å…¶ä»– Pyret `Table` æ“ä½œä¸€æ ·ï¼Œ`transform-column` ä¼šç”Ÿæˆä¸€ä¸ªæ–°çš„è¡¨æ ¼ï¼Œè€Œä¿ç•™åŸå§‹è¡¨æ ¼ä¸å˜ã€‚ç¼–è¾‘åŸå§‹è¡¨æ ¼å¯èƒ½ä¼šå‡ºç°é—®é¢˜â€”â€”å¦‚æœä½ çŠ¯äº†é”™è¯¯æ€ä¹ˆåŠï¼Ÿåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½ å°†å¦‚ä½•æ¢å¤åŸå§‹è¡¨æ ¼ï¼Ÿä¸€èˆ¬æ¥è¯´ï¼Œåœ¨ä¿®æ”¹ä»»ä½•è¡¨æ ¼åç”Ÿæˆæ–°çš„è¡¨æ ¼ï¼Œç„¶ååœ¨å¾—åˆ°ä½ æƒ³è¦çš„è¡¨æ ¼åä¸ºæ›´æ–°åçš„è¡¨æ ¼åˆ›å»ºä¸€ä¸ªæ–°åç§°ï¼Œè¿™æ˜¯ä¸€ç§æ›´ä¸å®¹æ˜“å‡ºé”™çš„å·¥ä½œæ–¹å¼ã€‚
- en: 4.1.5Â Examples for Table-Producing Functions[ğŸ”—](#(part._.Examples_for_.Table-.Producing_.Functions)
    "Link to here")
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.5Â è¡¨æ ¼ç”Ÿæˆå‡½æ•°çš„ç¤ºä¾‹[ğŸ”—](#(part._.Examples_for_.Table-.Producing_.Functions) "é“¾æ¥åˆ°æ­¤å¤„")
- en: How do we write examples for functions that produce tables? Conceptually, the
    answer is simply "make sure you got the output table that you expected". Logistically,
    writing examples for table functions seems more painful because writing out an
    expected output tables is more work than simply writing the output of a function
    that produces numbers or strings. What can we do to manage that complexity?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•ä¸ºç”Ÿæˆè¡¨çš„å‡½æ•°ç¼–å†™ç¤ºä¾‹ï¼Ÿä»æ¦‚å¿µä¸Šè®²ï¼Œç­”æ¡ˆæ˜¯â€œç¡®ä¿ä½ å¾—åˆ°äº†é¢„æœŸçš„è¾“å‡ºè¡¨â€ã€‚ä»å®é™…æ“ä½œæ¥çœ‹ï¼Œç¼–å†™è¡¨å‡½æ•°çš„ç¤ºä¾‹ä¼¼ä¹æ›´ç—›è‹¦ï¼Œå› ä¸ºç¼–å†™é¢„æœŸçš„è¾“å‡ºè¡¨æ¯”ç¼–å†™ç”Ÿæˆæ•°å­—æˆ–å­—ç¬¦ä¸²çš„å‡½æ•°çš„è¾“å‡ºè¦è´¹åŠ²ã€‚æˆ‘ä»¬èƒ½åšäº›ä»€ä¹ˆæ¥ç®¡ç†è¿™ç§å¤æ‚æ€§ï¼Ÿ
- en: Do Now!
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How might you write the `where` block for `give-raises`?
  id: totrans-192
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ ä¼šå¦‚ä½•ç¼–å†™`give-raises`çš„`where`å—ï¼Ÿ
- en: 'Here are some ideas for writing the examples practically:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€äº›å®é™…ç¼–å†™ç¤ºä¾‹çš„æƒ³æ³•ï¼š
- en: 'Simplify the input table. Rather than work with a large table with all of the
    columns you have, create a small table that has sufficient variety only in the
    columns that the function uses. For our example, we might use:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç®€åŒ–è¾“å…¥è¡¨ã€‚ä¸å…¶å¤„ç†åŒ…å«æ‰€æœ‰åˆ—çš„å¤§è¡¨ï¼Œä¸å¦‚åˆ›å»ºä¸€ä¸ªåªæœ‰å‡½æ•°ä½¿ç”¨çš„åˆ—æœ‰è¶³å¤Ÿå¤šæ ·æ€§çš„å°è¡¨ã€‚ä»¥æˆ‘ä»¬çš„ä¾‹å­æ¥è¯´ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šä½¿ç”¨ï¼š
- en: '[PRE27]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Do Now!
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Would any table with a column of numbers work here? Or are there some constraints
    on the rows or columns of the table?
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä»»ä½•åŒ…å«æ•°å­—åˆ—çš„è¡¨éƒ½é€‚ç”¨äºè¿™é‡Œå—ï¼Ÿæˆ–è€…è¡¨ä¸­çš„è¡Œæˆ–åˆ—æœ‰ä¸€äº›çº¦æŸå—ï¼Ÿ
- en: The only constraint is that your input table has to have the column names used
    in your function.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å”¯ä¸€çš„çº¦æŸæ˜¯ï¼Œä½ çš„è¾“å…¥è¡¨å¿…é¡»åŒ…å«å‡½æ•°ä¸­ä½¿ç”¨çš„åˆ—åã€‚
- en: Remember that you can write computations in the code to construct tables. This
    saves you from doing calculations by hand.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è®°ä½ï¼Œä½ å¯ä»¥åœ¨ä»£ç ä¸­ç¼–å†™è®¡ç®—æ¥æ„é€ è¡¨ã€‚è¿™å¯ä»¥è®©ä½ é¿å…æ‰‹åŠ¨è®¡ç®—ã€‚
- en: '[PRE28]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This example shows that you can write an output table directly in the `where:`
    block â€“ the table doesnâ€™t need to be named outside the function.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: è¿™ä¸ªä¾‹å­è¡¨æ˜ï¼Œä½ å¯ä»¥åœ¨`where:`å—ä¸­ç›´æ¥ç¼–å†™è¾“å‡ºè¡¨â€”â€”è¡¨ä¸éœ€è¦åœ¨å‡½æ•°å¤–éƒ¨å‘½åã€‚
- en: 'Create a new table by taking rows from an existing table. If you were instead
    writing examples for a function that involves filtering out rows of a table, it
    helps to know how to create a new table using rows of an existing one. For example,
    if we were writing a function to find all rows in which employees were working
    exactly 40 hours, weâ€™d like to make sure that the resulting table had the first
    and fourth rows of the `employees` table. Rather than write a new `table` expression
    to create that table, we could write it as follows:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: é€šè¿‡ä»ç°æœ‰è¡¨ä¸­å–è¡Œæ¥åˆ›å»ºä¸€ä¸ªæ–°çš„è¡¨ã€‚å¦‚æœä½ åœ¨ç¼–å†™æ¶‰åŠè¿‡æ»¤è¡¨è¡Œçš„å‡½æ•°çš„ç¤ºä¾‹ï¼Œäº†è§£å¦‚ä½•ä½¿ç”¨ç°æœ‰è¡¨çš„è¡Œåˆ›å»ºæ–°è¡¨å¾ˆæœ‰å¸®åŠ©ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬æ­£åœ¨ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥æŸ¥æ‰¾æ‰€æœ‰å‘˜å·¥å·¥ä½œæ­£å¥½40å°æ—¶çš„è¡Œï¼Œæˆ‘ä»¬å¸Œæœ›ç¡®ä¿ç»“æœè¡¨åŒ…å«`employees`è¡¨çš„ç¬¬ä¸€è¡Œå’Œç¬¬å››è¡Œã€‚è€Œä¸æ˜¯ç¼–å†™ä¸€ä¸ªæ–°çš„`table`è¡¨è¾¾å¼æ¥åˆ›å»ºè¿™ä¸ªè¡¨ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·å†™ï¼š
- en: '[PRE29]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, `employees.empty()` creates a new, empty table with the same column headers
    as `employees`. Weâ€™ve already seen how `row-n` extracts a row from a table. The
    `add-row` function places the given row at the end of the given table.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œ`employees.empty()`åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„ã€ç©ºçš„è¡¨ï¼Œå…¶åˆ—æ ‡é¢˜ä¸`employees`ç›¸åŒã€‚æˆ‘ä»¬å·²ç»çœ‹åˆ°äº†å¦‚ä½•ä½¿ç”¨`row-n`ä»è¡¨ä¸­æå–è¡Œã€‚`add-row`å‡½æ•°å°†æŒ‡å®šçš„è¡Œæ”¾ç½®åœ¨ç»™å®šè¡¨çš„æœ«å°¾ã€‚
- en: 'Another tip to keep in mind: when the only thing your function does is call
    a built-in function like `transform-column` it usually suffices to write examples
    for the function you wrote to compute the new column value. It is only when your
    code is combining table operations, or doing more complex processing than a single
    call to a built-in table operation that you really need to present your own examples
    to a reader of your code.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€ä¸ªéœ€è¦æ³¨æ„çš„æŠ€å·§ï¼šå½“ä½ çš„å‡½æ•°åªåšè°ƒç”¨å†…ç½®å‡½æ•°ï¼ˆå¦‚`transform-column`ï¼‰çš„äº‹æƒ…æ—¶ï¼Œé€šå¸¸åªéœ€è¦ä¸ºä½ çš„å‡½æ•°ç¼–å†™ç¤ºä¾‹æ¥è®¡ç®—æ–°åˆ—çš„å€¼å°±è¶³å¤Ÿäº†ã€‚åªæœ‰å½“ä½ çš„ä»£ç ç»“åˆäº†è¡¨æ“ä½œï¼Œæˆ–è€…æ‰§è¡Œæ¯”å•ä¸ªå†…ç½®è¡¨æ“ä½œæ›´å¤æ‚çš„å¤„ç†æ—¶ï¼Œä½ æ‰çœŸçš„éœ€è¦å‘ä½ çš„ä»£ç è¯»è€…å±•ç¤ºè‡ªå·±çš„ç¤ºä¾‹ã€‚
- en: '4.1.6Â Lambda: Anonymous Functions[ğŸ”—](#(part._sec~3alambda-tables) "Link to
    here")'
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.6 Lambdaï¼šåŒ¿åå‡½æ•°[ğŸ”—](#(part._sec~3alambda-tables) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Letâ€™s revisit the program we wrote in [Finding Rows](#%28part._subsec~3afinding-rows%29)
    for finding all of the months in a table with fewer than 1000 riders:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹æˆ‘ä»¬åœ¨[æŸ¥æ‰¾è¡Œ](#%28part._subsec~3afinding-rows%29)ä¸­ç¼–å†™çš„ç¨‹åºï¼Œç”¨äºæŸ¥æ‰¾è¡¨ä¸­å°‘äº1000åä¹˜å®¢çš„æ‰€æœ‰æœˆä»½ï¼š
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This program might feel a bit verbose: do we really need to write a helper
    function just to perform something as simple as a `filter-with`? Wouldnâ€™t it be
    easier to just write something like:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªç¨‹åºå¯èƒ½æ„Ÿè§‰æœ‰ç‚¹å†—é•¿ï¼šæˆ‘ä»¬çœŸçš„éœ€è¦å†™ä¸€ä¸ªè¾…åŠ©å‡½æ•°æ¥æ‰§è¡Œåƒ`filter-with`è¿™æ ·ç®€å•çš„äº‹æƒ…å—ï¼Ÿéš¾é“ç›´æ¥å†™ç‚¹ä¸œè¥¿ä¸æ˜¯æ›´å®¹æ˜“å—ï¼Ÿ
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Do Now!
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What will Pyret produce if you run this expression?
  id: totrans-214
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœä½ è¿è¡Œè¿™ä¸ªè¡¨è¾¾å¼ï¼ŒPyretä¼šç”Ÿæˆä»€ä¹ˆï¼Ÿ
- en: Pyret will produce an `unbound identifier` error around the use of `r` in this
    expression. What is `r`? We mean for `r` to be the elements from `shuttle` in
    turn. Conceptually, thatâ€™s what `filter-with` does, but we donâ€™t have the mechanics
    right. When we call a function, we evaluate the arguments before the body of the
    function. Hence, the error regarding `r` being unbound. The whole point of the
    `below-1K` helper function is to make `r` a parameter to a function whose body
    is only evaluated once a value for `r` is available.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret åœ¨æ­¤è¡¨è¾¾å¼ä½¿ç”¨ `r` æ—¶ä¼šäº§ç”Ÿä¸€ä¸ª `æœªç»‘å®šæ ‡è¯†ç¬¦` é”™è¯¯ã€‚`r` æ˜¯ä»€ä¹ˆï¼Ÿæˆ‘ä»¬çš„æ„æ€æ˜¯è®© `r` ä¾æ¬¡ä»£è¡¨ `shuttle` ä¸­çš„å…ƒç´ ã€‚ä»æ¦‚å¿µä¸Šè®²ï¼Œè¿™å°±æ˜¯
    `filter-with` æ‰€åšçš„ï¼Œä½†æˆ‘ä»¬æ²¡æœ‰æ­£ç¡®å®ç°æœºåˆ¶ã€‚å½“æˆ‘ä»¬è°ƒç”¨ä¸€ä¸ªå‡½æ•°æ—¶ï¼Œæˆ‘ä»¬ä¼šå…ˆè¯„ä¼°å‡½æ•°ä½“ä¹‹å‰çš„å‚æ•°ã€‚å› æ­¤ï¼Œå…³äº `r` æœªç»‘å®šçš„é”™è¯¯ã€‚`below-1K`
    è¾…åŠ©å‡½æ•°çš„å…¨éƒ¨ç›®çš„å°±æ˜¯ä½¿ `r` æˆä¸ºå‡½æ•°çš„ä¸€ä¸ªå‚æ•°ï¼Œè¯¥å‡½æ•°çš„å‡½æ•°ä½“åªæœ‰åœ¨ `r` æœ‰å€¼æ—¶æ‰ä¼šè¢«è¯„ä¼°ã€‚
- en: 'To tighten the notation as in the one-line `filter-with` expression, then,
    we have to find a way to tell Pyret to make a temporary function that will get
    its inputs once `filter-with` is running. The following notation achieves this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ä½¿ç¬¦å·æ›´ç´§å‡‘ï¼Œå°±åƒå•è¡Œ `filter-with` è¡¨è¾¾å¼é‚£æ ·ï¼Œé‚£ä¹ˆï¼Œæˆ‘ä»¬éœ€è¦æ‰¾åˆ°ä¸€ç§æ–¹æ³•å‘Šè¯‰ Pyret åˆ›å»ºä¸€ä¸ªä¸´æ—¶å‡½æ•°ï¼Œè¯¥å‡½æ•°å°†åœ¨ `filter-with`
    è¿è¡Œæ—¶è·å–å…¶è¾“å…¥ã€‚ä»¥ä¸‹ç¬¦å·å®ç°äº†è¿™ä¸€ç‚¹ï¼š
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We have added `lam(r)` and `end` around the expression that we want to use in
    the `filter-with`. The `lam(r)` says "make a temporary function that takes `r`
    as an input". The `end` serves to end the function definition, as when we use
    `fun`. `lam` is short for `lambda`, a form of function definition that exists
    in many, though not all, languages.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨æƒ³è¦åœ¨ `filter-with` ä¸­ä½¿ç”¨çš„è¡¨è¾¾å¼å‘¨å›´æ·»åŠ äº† `lam(r)` å’Œ `end`ã€‚`lam(r)` è¡¨ç¤ºâ€œåˆ›å»ºä¸€ä¸ªä»¥ `r` ä½œä¸ºè¾“å…¥çš„ä¸´æ—¶å‡½æ•°â€ã€‚`end`
    ç”¨äºç»“æŸå‡½æ•°å®šä¹‰ï¼Œå°±åƒæˆ‘ä»¬ä½¿ç”¨ `fun` ä¸€æ ·ã€‚`lam` æ˜¯ `lambda` çš„ç®€ç§°ï¼Œè¿™æ˜¯ä¸€ç§å­˜åœ¨äºè®¸å¤šè¯­è¨€ä¸­ä½†å¹¶éæ‰€æœ‰è¯­è¨€ä¸­çš„å‡½æ•°å®šä¹‰å½¢å¼ã€‚
- en: 'The main difference between our original expression (using the `below-1K` helper)
    and this new one (using `lam`) can be seen through the program directory. To explain
    this, a little detail about how `filter-with` is defined under the hood. In part,
    it looks like:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åŸå§‹è¡¨è¾¾å¼ï¼ˆä½¿ç”¨ `below-1K` è¾…åŠ©å‡½æ•°ï¼‰å’Œè¿™ä¸ªæ–°è¡¨è¾¾å¼ï¼ˆä½¿ç”¨ `lam`ï¼‰ä¹‹é—´çš„ä¸»è¦åŒºåˆ«å¯ä»¥é€šè¿‡ç¨‹åºç›®å½•æ¥çœ‹åˆ°ã€‚ä¸ºäº†è§£é‡Šè¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦äº†è§£ä¸€ä¸‹
    `filter-with` åœ¨åº•å±‚æ˜¯å¦‚ä½•å®šä¹‰çš„ã€‚éƒ¨åˆ†åœ°ï¼Œå®ƒçœ‹èµ·æ¥åƒï¼š
- en: '[PRE33]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Whether we pass `below-1K` or the `lam` version to `filter-with`, the `keep`
    parameter ends up referring to a function with the same parameter and body. Since
    the function is only actually called through the `keep` name, it doesnâ€™t matter
    whether or not a name is associated with it when it is initially defined.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: æ— è®ºæˆ‘ä»¬ä¼ é€’ `below-1K` è¿˜æ˜¯ `lam` ç‰ˆæœ¬åˆ° `filter-with`ï¼Œ`keep` å‚æ•°æœ€ç»ˆéƒ½ä¼šå¼•ç”¨ä¸€ä¸ªå…·æœ‰ç›¸åŒå‚æ•°å’Œä¸»ä½“çš„å‡½æ•°ã€‚ç”±äºå‡½æ•°å®é™…ä¸Šæ˜¯é€šè¿‡
    `keep` åç§°è°ƒç”¨çš„ï¼Œå› æ­¤å½“å®ƒæœ€åˆå®šä¹‰æ—¶ï¼Œæ˜¯å¦ä¸å®ƒå…³è”åç§°å¹¶ä¸é‡è¦ã€‚
- en: In practice, we use `lam` when we have to pass simple (single line) functions
    to operations like `filter-with` (or `transform-column`, `build-column`, etc).
    Of course, you can continue to write out names for helper functions as we did
    with `below-1K` if that makes more sense to you.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šï¼Œå½“æˆ‘ä»¬éœ€è¦å°†ç®€å•çš„ï¼ˆå•è¡Œï¼‰å‡½æ•°ä¼ é€’ç»™ `filter-with`ï¼ˆæˆ– `transform-column`ã€`build-column` ç­‰æ“ä½œï¼‰æ—¶ï¼Œæˆ‘ä»¬ä¼šä½¿ç”¨
    `lam`ã€‚å½“ç„¶ï¼Œå¦‚æœä½ è§‰å¾—è¿™æ ·æ›´æœ‰æ„ä¹‰ï¼Œä½ å¯ä»¥ç»§ç»­åƒæˆ‘ä»¬å¯¹ `below-1K` æ‰€åšçš„é‚£æ ·ï¼Œä¸ºè¾…åŠ©å‡½æ•°å†™å‡ºåç§°ã€‚
- en: Exercise
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write the program to add 10 riders to each row in the `shuttle` table above,
    using `lam` rather than a named helper-function.
  id: totrans-225
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ç¨‹åºï¼Œä½¿ç”¨ `lam` è€Œä¸æ˜¯å‘½åè¾…åŠ©å‡½æ•°ï¼Œå‘ä¸Šé¢ `shuttle` è¡¨æ ¼ä¸­çš„æ¯ä¸€è¡Œæ·»åŠ  10 åä¹˜å®¢ã€‚
- en: 4.1.1Â Creating Tabular Data[ğŸ”—](#(part._.Creating_.Tabular_.Data) "Link to here")
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1 åˆ›å»ºè¡¨æ ¼æ•°æ®[ğŸ”—](#(part._.Creating_.Tabular_.Data) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Pyret provides multiple easy ways of creating tabular data. The simplest is
    to define the datum in a program as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret æä¾›äº†å¤šç§åˆ›å»ºè¡¨æ ¼æ•°æ®çš„æ–¹æ³•ã€‚æœ€ç®€å•çš„æ˜¯åœ¨ç¨‹åºä¸­å°†æ•°æ®å®šä¹‰å¦‚ä¸‹ï¼š
- en: '[PRE34]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: That is, a `table` is followed by the names of the columns in their desired
    order, followed by a sequence of `row`s. Each row must contain as many data as
    the column declares, and in the same order.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: å³ï¼Œä¸€ä¸ª `table` åè·Ÿåˆ—çš„åç§°ï¼ŒæŒ‰ç…§æ‰€éœ€çš„é¡ºåºï¼Œç„¶åæ˜¯ä¸€ä¸ª `row` çš„åºåˆ—ã€‚æ¯ä¸€è¡Œå¿…é¡»åŒ…å«ä¸åˆ—å£°æ˜ç›¸åŒæ•°é‡çš„æ•°æ®ï¼Œå¹¶ä¸”æŒ‰ç…§ç›¸åŒçš„é¡ºåºã€‚
- en: Exercise
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Change different parts of the above exampleâ€”<wbr>e.g., remove a necessary value
    from a row, add an extraneous one, remove a comma, add an extra comma, leave an
    extra comma at the end of a rowâ€”<wbr>and see what errors you get.
  id: totrans-232
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ”¹å˜ä¸Šè¿°ç¤ºä¾‹çš„ä¸åŒéƒ¨åˆ†â€”â€”ä¾‹å¦‚ï¼Œä»ä¸€è¡Œä¸­åˆ é™¤ä¸€ä¸ªå¿…è¦çš„å€¼ï¼Œæ·»åŠ ä¸€ä¸ªå¤šä½™çš„å€¼ï¼Œåˆ é™¤ä¸€ä¸ªé€—å·ï¼Œæ·»åŠ ä¸€ä¸ªé¢å¤–çš„é€—å·ï¼Œåœ¨è¡Œæœ«ç•™ä¸‹ä¸€ä¸ªå¤šä½™çš„é€—å·â€”â€”ç„¶åçœ‹çœ‹ä½ ä¼šå¾—åˆ°ä»€ä¹ˆé”™è¯¯ã€‚
- en: 'Note that in a table, the order of columns matters: two tables that are otherwise
    identical but with different column orders are not considered equal.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨è¡¨æ ¼ä¸­ï¼Œåˆ—çš„é¡ºåºå¾ˆé‡è¦ï¼šä¸¤ä¸ªåœ¨å…¶ä»–æ–¹é¢ç›¸åŒä½†åˆ—é¡ºåºä¸åŒçš„è¡¨æ ¼ä¸è¢«è®¤ä¸ºæ˜¯ç›¸ç­‰çš„ã€‚
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Observe that the example above uses `is-not`, i.e., the test passes, meaning
    that the tables are not equal.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„åˆ°ä¸Šé¢çš„ä¾‹å­ä½¿ç”¨äº† `is-not`ï¼Œå³æµ‹è¯•é€šè¿‡ï¼Œæ„å‘³ç€è¡¨æ ¼ä¸ç›¸ç­‰ã€‚
- en: The `check:` annotation here is a way of writing `is` assertions about expressions
    outside of the context of a function (and its `where` block). Weâ€™ll learn more
    about `check` in [From Examples to Tests](testing.html#%28part._from-examples-to-tests%29).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œçš„ `check:` æ³¨é‡Šæ˜¯ä¸€ç§åœ¨å‡½æ•°ï¼ˆåŠå…¶ `where` å—ï¼‰ä¸Šä¸‹æ–‡ä¹‹å¤–ç¼–å†™å…³äºè¡¨è¾¾å¼çš„ `is` æ–­è¨€çš„æ–¹å¼ã€‚æˆ‘ä»¬å°†åœ¨[ä»ç¤ºä¾‹åˆ°æµ‹è¯•](testing.html#%28part._from-examples-to-tests%29)ä¸­äº†è§£æ›´å¤šå…³äº
    `check` çš„å†…å®¹ã€‚
- en: 'Table expressions create table values. These can be stored in variables just
    like numbers, strings, and images:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: è¡¨è¾¾å¼åˆ›å»ºè¡¨æ ¼å€¼ã€‚è¿™äº›å¯ä»¥åƒæ•°å­—ã€å­—ç¬¦ä¸²å’Œå›¾åƒä¸€æ ·å­˜å‚¨åœ¨å˜é‡ä¸­ï¼š
- en: '[PRE36]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We call these literal tables when we create them with `table`. Pyret provides
    other ways to get tabular data, too! In particular, you can [import tabular data
    from a spreadsheet](https://www.pyret.org/docs/latest/gdrive-sheets.html), so
    any mechanism that lets you create such a sheet can also be used. You might:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬ä½¿ç”¨ `table` åˆ›å»ºè¿™äº›è¡¨æ—¶ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºæ–‡å­—è¡¨æ ¼ã€‚Pyret è¿˜æä¾›äº†å…¶ä»–è·å–è¡¨æ ¼æ•°æ®çš„æ–¹æ³•ï¼ç‰¹åˆ«æ˜¯ï¼Œä½ å¯ä»¥[ä»ç”µå­è¡¨æ ¼ä¸­å¯¼å…¥è¡¨æ ¼æ•°æ®](https://www.pyret.org/docs/latest/gdrive-sheets.html)ï¼Œå› æ­¤ä»»ä½•è®©ä½ åˆ›å»ºæ­¤ç±»è¡¨æ ¼çš„æœºåˆ¶ä¹Ÿå¯ä»¥ä½¿ç”¨ã€‚ä½ å¯èƒ½ï¼š
- en: create the sheet on your own,
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨ä½ è‡ªå·±çš„è¡¨æ ¼ä¸­åˆ›å»ºè¡¨æ ¼ï¼Œ
- en: create a sheet collaboratively with friends,
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸æœ‹å‹åä½œåˆ›å»ºè¡¨æ ¼ï¼Œ
- en: find data on the Web that you can import into a sheet,
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨ç½‘ç»œä¸Šæ‰¾åˆ°å¯ä»¥å¯¼å…¥åˆ°è¡¨æ ¼ä¸­çš„æ•°æ®ï¼Œ
- en: create a Google Form that you get others to fill out, and obtain a sheet out
    of their responses
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ›å»ºä¸€ä¸ªè°·æ­Œè¡¨å•ï¼Œè®©å…¶ä»–äººå¡«å†™ï¼Œå¹¶ä»ä»–ä»¬çš„å›å¤ä¸­è·å¾—è¡¨æ ¼
- en: and so on. Let your imagination run wild! Once the data are in Pyret, it doesnâ€™t
    matter where they came from.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ç­‰ç­‰ã€‚è®©ä½ çš„æƒ³è±¡åŠ›è‡ªç”±é©°éª‹ï¼ä¸€æ—¦æ•°æ®è¿›å…¥ Pyretï¼Œå®ƒä»¬æ¥è‡ªå“ªé‡Œå°±ä¸å†é‡è¦äº†ã€‚
- en: With tables, we begin to explore data that contain other (smaller) pieces of
    data. Weâ€™ll refer to such data as structured data. Structured data organize their
    inner data in a structured way (here, rows and columns). As with images, when
    we wrote code that reflected the structure of the final image, we will see that
    code that works with tables also follows the structure of the data.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¡¨æ ¼ï¼Œæˆ‘ä»¬å¼€å§‹æ¢ç´¢åŒ…å«å…¶ä»–ï¼ˆè¾ƒå°ï¼‰æ•°æ®å—çš„æ•°æ®ã€‚æˆ‘ä»¬å°†æ­¤ç±»æ•°æ®ç§°ä¸ºç»“æ„åŒ–æ•°æ®ã€‚ç»“æ„åŒ–æ•°æ®ä»¥ç»“æ„åŒ–çš„æ–¹å¼ç»„ç»‡å…¶å†…éƒ¨æ•°æ®ï¼ˆåœ¨è¿™é‡Œï¼Œè¡Œå’Œåˆ—ï¼‰ã€‚å°±åƒå›¾åƒä¸€æ ·ï¼Œå½“æˆ‘ä»¬ç¼–å†™åæ˜ æœ€ç»ˆå›¾åƒç»“æ„çš„ä»£ç æ—¶ï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ°å¤„ç†è¡¨æ ¼çš„ä»£ç ä¹Ÿéµå¾ªæ•°æ®ç»“æ„ã€‚
- en: 4.1.2Â Extracting Rows and Cell Values[ğŸ”—](#(part._.Extracting_.Rows_and_.Cell_.Values)
    "Link to here")
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.2 æå–è¡Œå’Œå•å…ƒæ ¼å€¼[ğŸ”—](#(part._.Extracting_.Rows_and_.Cell_.Values) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Given a table, we sometimes want to look up the value of a particular cell.
    Weâ€™ll work with the following table showing the number of riders on a shuttle
    service over several months:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªè¡¨æ ¼ï¼Œæˆ‘ä»¬æœ‰æ—¶éœ€è¦æŸ¥æ‰¾ç‰¹å®šå•å…ƒæ ¼çš„å€¼ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ä»¥ä¸‹è¡¨æ ¼ï¼Œå±•ç¤ºäº†å‡ ä¸ªæœˆä»½ç©¿æ¢­æœåŠ¡çš„ä¹˜å®¢æ•°é‡ï¼š
- en: '[PRE37]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Do Now!
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you put this table in the definitions pane and press Run, what will be in
    the Pyret directory once the interactions prompt appears? Would the column names
    be listed in the directory?
  id: totrans-251
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœä½ å°†è¿™ä¸ªè¡¨æ ¼æ”¾å…¥å®šä¹‰é¢æ¿å¹¶è¿è¡Œï¼Œå½“äº¤äº’å¼æç¤ºå‡ºç°æ—¶ï¼ŒPyret ç›®å½•ä¸­ä¼šæœ‰ä»€ä¹ˆï¼Ÿåˆ—åä¼šè¢«åˆ—åœ¨ç›®å½•ä¸­å—ï¼Ÿ
- en: As a reminder, the directory contains only those names that we assign values
    to using the form `name =` . The directory here would contain `shuttle`, which
    would be bound to the table (yes, the entire table would be in the directory!).
    The column names would not have their own entries in the directory. At the low
    level, this is because we never wrote anything of the form `colname = ...`. At
    the high level, we donâ€™t usually build tables by creating individual columns and
    putting them together side by side. (If anything, it is more common to create
    individual rows, since rows correspond to individual observations, events, or
    entities; we didnâ€™t do that in this example, however).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºæé†’ï¼Œç›®å½•ä¸­åªåŒ…å«æˆ‘ä»¬ä½¿ç”¨ `name =` å½¢å¼èµ‹å€¼çš„é‚£äº›åç§°ã€‚è¿™é‡Œçš„ç›®å½•å°†åŒ…å« `shuttle`ï¼Œå®ƒå°†ç»‘å®šåˆ°è¡¨æ ¼ï¼ˆæ˜¯çš„ï¼Œæ•´ä¸ªè¡¨æ ¼éƒ½ä¼šåœ¨ç›®å½•ä¸­ï¼ï¼‰ï¼åˆ—åä¸ä¼šåœ¨ç›®å½•ä¸­æœ‰è‡ªå·±çš„æ¡ç›®ã€‚åœ¨ä½çº§åˆ«ä¸Šï¼Œè¿™æ˜¯å› ä¸ºæˆ‘ä»¬ä»æœªç¼–å†™è¿‡
    `colname = ...` å½¢å¼çš„ä»»ä½•å†…å®¹ã€‚åœ¨é«˜çº§åˆ«ä¸Šï¼Œæˆ‘ä»¬é€šå¸¸ä¸ä¼šé€šè¿‡åˆ›å»ºå•ä¸ªåˆ—å¹¶å°†å®ƒä»¬å¹¶æ’æ”¾ç½®æ¥æ„å»ºè¡¨æ ¼ã€‚ï¼ˆå¦‚æœæœ‰ä»€ä¹ˆä¸åŒçš„è¯ï¼Œåˆ›å»ºå•ä¸ªè¡Œæ›´ä¸ºå¸¸è§ï¼Œå› ä¸ºè¡Œå¯¹åº”äºå•ä¸ªè§‚å¯Ÿã€äº‹ä»¶æˆ–å®ä½“ï¼›ç„¶è€Œï¼Œåœ¨è¿™ä¸ªä¾‹å­ä¸­æˆ‘ä»¬æ²¡æœ‰è¿™æ ·åšï¼‰ã€‚
- en: Starting from the name associated with a table, we can lookup the value in a
    given cell (row and column) in the table. Concretely, assume we want to extract
    the number of riders in March (`1087`) so we can use it in another computation.
    How do we do that?
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ä»ä¸è¡¨æ ¼å…³è”çš„åç§°å¼€å§‹ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è¡¨æ ¼ä¸­ç»™å®šå•å…ƒæ ¼ï¼ˆè¡Œå’Œåˆ—ï¼‰ä¸­æŸ¥æ‰¾å€¼ã€‚å…·ä½“æ¥è¯´ï¼Œå‡è®¾æˆ‘ä»¬æƒ³æå–ä¸‰æœˆä»½çš„ä¹˜å®¢æ•°é‡ï¼ˆ`1087`ï¼‰ï¼Œä»¥ä¾¿åœ¨å¦ä¸€ä¸ªè®¡ç®—ä¸­ä½¿ç”¨ã€‚æˆ‘ä»¬å¦‚ä½•åšåˆ°è¿™ä¸€ç‚¹ï¼Ÿ
- en: Pyret (and most other programming languages designed for data analysis) organizes
    tables as collections of rows with shared columns. Given that organization, we
    get to a specific cell by first isolating the row we are interested in, then retrieving
    the contents of the cell.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Pyretï¼ˆä»¥åŠå¤§å¤šæ•°ä¸ºæ•°æ®åˆ†æè®¾è®¡çš„å…¶ä»–ç¼–ç¨‹è¯­è¨€ï¼‰å°†è¡¨æ ¼ç»„ç»‡ä¸ºå…·æœ‰å…±äº«åˆ—çš„è¡Œé›†åˆã€‚é‰´äºè¿™ç§ç»„ç»‡æ–¹å¼ï¼Œæˆ‘ä»¬é¦–å…ˆéš”ç¦»æ„Ÿå…´è¶£çš„è¡Œï¼Œç„¶åæ£€ç´¢å•å…ƒæ ¼çš„å†…å®¹ã€‚
- en: 'Pyret numbers the rows of a table from top to bottom starting at 0 (most programming
    languages use 0 as the first position in a piece of data, for reasons we will
    see later). So if we want to see the data for March, we need to isolate row 2\.
    We write:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Pyretä»ä¸Šåˆ°ä¸‹å¯¹è¡¨æ ¼çš„è¡Œè¿›è¡Œç¼–å·ï¼Œèµ·å§‹å€¼ä¸º0ï¼ˆå¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€ä½¿ç”¨0ä½œä¸ºæ•°æ®ä¸­çš„ç¬¬ä¸€ä¸ªä½ç½®ï¼ŒåŸå› æˆ‘ä»¬å°†åœ¨åé¢çœ‹åˆ°ï¼‰ã€‚å› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬æƒ³æŸ¥çœ‹ä¸‰æœˆä»½çš„æ•°æ®ï¼Œæˆ‘ä»¬éœ€è¦éš”ç¦»ç¬¬2è¡Œã€‚æˆ‘ä»¬å†™ä¸‹ï¼š
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We use the period notation to dig into a piece of structured data. Here, we
    are saying "dig into the `shuttle` table, extracting row number `2`" (which is
    really the third row since Pyret counts positions from 0).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä½¿ç”¨ç‚¹ç¬¦å·æ¥æ·±å…¥ç»“æ„åŒ–æ•°æ®ã€‚è¿™é‡Œï¼Œæˆ‘ä»¬è¯´çš„æ˜¯â€œæ·±å…¥`shuttle`è¡¨ï¼Œæå–è¡Œå·`2`â€ï¼ˆåœ¨Pyretä¸­ï¼Œè¿™å®é™…ä¸Šæ˜¯ç¬¬ä¸‰è¡Œï¼Œå› ä¸ºPyretä»0å¼€å§‹è®¡æ•°ä½ç½®ï¼‰ã€‚
- en: If we run this expression at the prompt, we get
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬åœ¨æç¤ºç¬¦ä¸­è¿è¡Œè¿™ä¸ªè¡¨è¾¾å¼ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°
- en: '![](../Images/d60ae702af1ad3975e72ce720628831a.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](../Images/d60ae702af1ad3975e72ce720628831a.png)'
- en: This is a new type of data called a `Row`. When Pyret displays a `Row` value,
    it shows you the column names and the corresponding values within the row.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ç§æ–°çš„æ•°æ®ç±»å‹ï¼Œç§°ä¸º`Row`ã€‚å½“Pyretæ˜¾ç¤º`Row`å€¼æ—¶ï¼Œå®ƒä¼šæ˜¾ç¤ºè¡Œä¸­çš„åˆ—åå’Œç›¸åº”çš„å€¼ã€‚
- en: 'To extract the value of a specific column within a row, we write the row followed
    by the name of the column (as a string) in square brackets. Here are two equivalent
    ways of getting the value of the `riders` column from the row for March:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: è¦æå–è¡Œä¸­ç‰¹å®šåˆ—çš„å€¼ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æ–¹æ‹¬å·ä¸­å†™ä¸‹è¡Œåï¼ˆä½œä¸ºå­—ç¬¦ä¸²ï¼‰ï¼Œç„¶åè·Ÿä¸Šåˆ—åã€‚ä»¥ä¸‹æ˜¯ä»ä¸‰æœˆä»½çš„è¡Œä¸­è·å–`riders`åˆ—å€¼çš„ä¸¤ç§ç­‰æ•ˆæ–¹å¼ï¼š
- en: '[PRE39]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Do Now!
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What names would be in the Pyret directory when using each of these approaches?
  id: totrans-266
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™äº›æ–¹æ³•æ—¶ï¼ŒPyretç›®å½•ä¸­ä¼šæœ‰å“ªäº›åç§°ï¼Ÿ
- en: Once we have the cell value (here a `Number`), we can use it in any other computation,
    such as
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æˆ‘ä»¬æœ‰äº†å•å…ƒæ ¼å€¼ï¼ˆè¿™é‡Œæ˜¯ä¸€ä¸ª`Number`ï¼‰ï¼Œæˆ‘ä»¬å°±å¯ä»¥å°†å…¶ç”¨äºä»»ä½•å…¶ä»–è®¡ç®—ï¼Œä¾‹å¦‚
- en: '[PRE41]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: (which checks whether there were at least `1000` riders in March).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆè¿™æ£€æŸ¥ä¸‰æœˆä»½æ˜¯å¦æœ‰è‡³å°‘`1000`åéª‘æ‰‹ï¼‰ã€‚
- en: Do Now!
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What do you expect would happen if you forgot the quotation marks and instead
    wrote:'
  id: totrans-272
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœä½ å¿˜è®°äº†å¼•å·ï¼Œè€Œæ˜¯è¿™æ ·å†™ï¼Œä½ æœŸæœ›ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
- en: ''
  id: totrans-273
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-274
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ''
  id: totrans-275
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What would Pyret do and why?
  id: totrans-276
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Pyretä¼šåšä»€ä¹ˆï¼Œä¸ºä»€ä¹ˆï¼Ÿ
- en: 4.1.3Â Functions over Rows[ğŸ”—](#(part._.Functions_over_.Rows) "Link to here")
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.3 å‡½æ•°å¯¹è¡Œ[ğŸ”—](#(part._.Functions_over_.Rows) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Now that we have the ability to isolate Rows from tables, we can write functions
    that ask questions about individual rows. We just saw an example of doing a computation
    over row data, when we checked whether the row for March had more than 1000 riders.
    What if we wanted to do this comparison for an arbitrary row of this table? Letâ€™s
    write a function! Weâ€™ll call it `cleared-1K`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æœ‰èƒ½åŠ›ä»è¡¨ä¸­éš”ç¦»è¡Œï¼Œæˆ‘ä»¬å¯ä»¥ç¼–å†™è¯¢é—®å•ä¸ªè¡Œçš„å‡½æ•°ã€‚æˆ‘ä»¬åˆšåˆšçœ‹åˆ°äº†ä¸€ä¸ªåœ¨è¡Œæ•°æ®ä¸Šæ‰§è¡Œè®¡ç®—çš„ä¾‹å­ï¼Œå½“æˆ‘ä»¬æ£€æŸ¥ä¸‰æœˆä»½çš„è¡Œæ˜¯å¦æœ‰è¶…è¿‡1000åéª‘æ‰‹æ—¶ã€‚å¦‚æœæˆ‘ä»¬æƒ³å¯¹è¿™ä¸ªè¡¨æ ¼çš„ä»»æ„è¡Œè¿›è¡Œè¿™ç§æ¯”è¾ƒï¼Œä¼šæ€æ ·ï¼Ÿè®©æˆ‘ä»¬å†™ä¸€ä¸ªå‡½æ•°ï¼æˆ‘ä»¬å°†å®ƒå‘½åä¸º`cleared-1K`ã€‚
- en: 'Letâ€™s start with a function header and some examples:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä»å‡½æ•°å¤´å’Œä¸€äº›ç¤ºä¾‹å¼€å§‹ï¼š
- en: '[PRE43]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This shows you what examples for `Row` functions look like, as well as how we
    use `Row` as an input type.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å±•ç¤ºäº†`Row`å‡½æ•°çš„ç¤ºä¾‹ï¼Œä»¥åŠæˆ‘ä»¬å¦‚ä½•ä½¿ç”¨`Row`ä½œä¸ºè¾“å…¥ç±»å‹ã€‚
- en: 'To fill in the body of the function, we extract the content of the `"riders"`
    cell and compare it to `1000`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: è¦å¡«å……å‡½æ•°çš„ä¸»ä½“ï¼Œæˆ‘ä»¬æå–`"riders"`å•å…ƒæ ¼çš„å†…å®¹ï¼Œå¹¶å°†å…¶ä¸`1000`è¿›è¡Œæ¯”è¾ƒï¼š
- en: '[PRE44]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Do Now!
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Looking at the examples, both of them share the `shuttle.row-n` portion. Would
    it have been better to instead make `cleared-1K` a function that takes just the
    row position as input, such as:'
  id: totrans-286
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è§‚å¯Ÿç¤ºä¾‹ï¼Œå®ƒä»¬éƒ½å…±äº«`shuttle.row-n`éƒ¨åˆ†ã€‚æ˜¯å¦å°†`cleared-1K`æ”¹ä¸ºä¸€ä¸ªåªæ¥å—è¡Œä½ç½®ä½œä¸ºè¾“å…¥çš„å‡½æ•°ä¼šæ›´å¥½ï¼Œä¾‹å¦‚ï¼š
- en: ''
  id: totrans-287
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-288
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ''
  id: totrans-289
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are the benefits and limitations to doing this?
  id: totrans-290
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™æ ·åšçš„ä¼˜ç‚¹å’Œå±€é™æ€§æ˜¯ä»€ä¹ˆï¼Ÿ
- en: In general, the version that takes the `Row` input is more flexible because
    it can work with a row from any table that has a column named `"riders"`. We might
    have another table with more columns of information or different data tables for
    different years. If we modify `cleared-1K` to only take the row position as input,
    that function will have to fix which table it works with. In contrast, our original
    version leaves the specific table (`shuttle`) outside the function, which leads
    to flexibility.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: é€šå¸¸æƒ…å†µä¸‹ï¼Œæ¥å—`Row`è¾“å…¥çš„ç‰ˆæœ¬æ›´çµæ´»ï¼Œå› ä¸ºå®ƒå¯ä»¥ä¸ä»»ä½•å…·æœ‰åä¸º`"riders"`çš„åˆ—çš„è¡¨ä¸€èµ·å·¥ä½œã€‚æˆ‘ä»¬å¯èƒ½è¿˜æœ‰å¦ä¸€ä¸ªåŒ…å«æ›´å¤šåˆ—ä¿¡æ¯æˆ–ä¸åŒå¹´ä»½çš„æ•°æ®è¡¨ã€‚å¦‚æœæˆ‘ä»¬ä¿®æ”¹`cleared-1K`ä½¿å…¶åªæ¥å—è¡Œä½ç½®ä½œä¸ºè¾“å…¥ï¼Œé‚£ä¹ˆè¯¥å‡½æ•°å°†ä¸å¾—ä¸ç¡®å®šå®ƒè¦ä½¿ç”¨å“ªä¸ªè¡¨ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œæˆ‘ä»¬çš„åŸå§‹ç‰ˆæœ¬å°†ç‰¹å®šçš„è¡¨ï¼ˆ`shuttle`ï¼‰æ”¾åœ¨å‡½æ•°å¤–éƒ¨ï¼Œè¿™å¯¼è‡´äº†çµæ´»æ€§ã€‚
- en: Exercise
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function `is-winter` that takes a `Row` with a `"month"` column as input
    and produces a `Boolean` indicating whether the month in that row is one of `"Jan"`,
    `"Feb"`, or `"Mar"`.
  id: totrans-294
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ä¸€ä¸ªåä¸º`is-winter`çš„å‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ªå…·æœ‰`"month"`åˆ—çš„`Row`ä½œä¸ºè¾“å…¥ï¼Œå¹¶äº§ç”Ÿä¸€ä¸ª`Boolean`å€¼ï¼ŒæŒ‡ç¤ºè¯¥è¡Œä¸­çš„æœˆä»½æ˜¯å¦ä¸º`"Jan"`ã€`"Feb"`æˆ–`"Mar"`ä¹‹ä¸€ã€‚
- en: Exercise
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function `low-winter` that takes in `Row` with both `"month"` and `"riders"`
    columns and produces a `Boolean` indicating whether the row is a winter row with
    fewer than 1050 riders.
  id: totrans-297
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ä¸€ä¸ªåä¸º`low-winter`çš„å‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ªå…·æœ‰`"month"`å’Œ`"riders"`åˆ—çš„`Row`ï¼Œå¹¶äº§ç”Ÿä¸€ä¸ª`Boolean`å€¼ï¼ŒæŒ‡ç¤ºè¯¥è¡Œæ˜¯å¦æ˜¯æ‹¥æœ‰å°‘äº1050åä¹˜å®¢çš„å†¬å­£è¡Œã€‚
- en: Exercise
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Practice with the program directory! Take a `Row` function and one of its `where`
    examples, and show how the program directory evolves as you evaluate the example.
  id: totrans-300
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨ç¨‹åºç›®å½•ä¸­è¿›è¡Œç»ƒä¹ ï¼å–ä¸€ä¸ª`Row`å‡½æ•°åŠå…¶`where`ç¤ºä¾‹ä¹‹ä¸€ï¼Œå¹¶å±•ç¤ºå½“ä½ è¯„ä¼°ç¤ºä¾‹æ—¶ç¨‹åºç›®å½•æ˜¯å¦‚ä½•æ¼”å˜çš„ã€‚
- en: 4.1.4Â Processing Rows[ğŸ”—](#(part._.Processing_.Rows) "Link to here")
  id: totrans-301
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.4Â å¤„ç†è¡Œ[ğŸ”—](#(part._.Processing_.Rows) "é“¾æ¥è‡³æ­¤")
- en: 'So far, we have looked at extracting individual rows by their position in the
    table and computing over them. Extracting rows by position isnâ€™t always convenient:
    we might have hundreds or thousands of rows, and we might not know where the data
    we want even is in the table. We would much rather be able to write a small program
    that identifies the row (or rows!) that meets a specific criterion.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»ç ”ç©¶äº†é€šè¿‡è¡¨ä¸­çš„ä½ç½®æå–å•ä¸ªè¡Œå¹¶å¯¹å®ƒä»¬è¿›è¡Œè®¡ç®—ã€‚é€šè¿‡ä½ç½®æå–è¡Œå¹¶ä¸æ€»æ˜¯æ–¹ä¾¿çš„ï¼šæˆ‘ä»¬å¯èƒ½æœ‰æ•°ç™¾æˆ–æ•°åƒè¡Œï¼Œæˆ‘ä»¬ç”šè‡³ä¸çŸ¥é“æˆ‘ä»¬æƒ³è¦çš„æ•°æ®åœ¨è¡¨ä¸­åœ¨å“ªé‡Œã€‚æˆ‘ä»¬æ›´æ„¿æ„èƒ½å¤Ÿç¼–å†™ä¸€ä¸ªå°ç¨‹åºæ¥è¯†åˆ«æ»¡è¶³ç‰¹å®šæ ‡å‡†çš„è¡Œï¼ˆæˆ–è¡Œï¼ï¼‰ã€‚
- en: 'Pyret offers three different notations for processing tables: one uses functions,
    one uses methods, and one uses a SQL-like notation. This chapter uses the function-based
    notation. The SQL-like notation and the methods-based notation are shown in the
    Pyret Documentation. To use the function-based notation, youâ€™ll need to include
    the file specified in the main narrative.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Pyretæä¾›äº†ä¸‰ç§ä¸åŒçš„å¤„ç†è¡¨çš„æ–¹æ³•ï¼šä¸€ç§ä½¿ç”¨å‡½æ•°ï¼Œä¸€ç§ä½¿ç”¨æ–¹æ³•ï¼Œè¿˜æœ‰ä¸€ç§ä½¿ç”¨ç±»ä¼¼SQLçš„è¡¨ç¤ºæ³•ã€‚æœ¬ç« ä½¿ç”¨åŸºäºå‡½æ•°çš„è¡¨ç¤ºæ³•ã€‚ç±»ä¼¼SQLçš„è¡¨ç¤ºæ³•å’ŒåŸºäºæ–¹æ³•çš„è¡¨ç¤ºæ³•åœ¨Pyretæ–‡æ¡£ä¸­å±•ç¤ºã€‚è¦ä½¿ç”¨åŸºäºå‡½æ•°çš„è¡¨ç¤ºæ³•ï¼Œæ‚¨éœ€è¦åŒ…å«ä¸»å™äº‹ä¸­æŒ‡å®šçš„æ–‡ä»¶ã€‚
- en: The rest of this section assumes that you have loaded the functions notations
    for working with tables.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬èŠ‚çš„å…¶ä½™éƒ¨åˆ†å‡è®¾ä½ å·²ç»åŠ è½½äº†ç”¨äºå¤„ç†è¡¨çš„å‡½æ•°è¡¨ç¤ºæ³•ã€‚
- en: 4.1.4.1Â Finding Rows[ğŸ”—](#(part._subsec~3afinding-rows) "Link to here")
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.1.4.1Â æŸ¥æ‰¾è¡Œ[ğŸ”—](#(part._subsec~3afinding-rows) "é“¾æ¥è‡³æ­¤")
- en: 'Imagine that we wanted to write a program to locate a row that has fewer than
    `1000` riders from our `shuttle` table. With what weâ€™ve studied so far, how might
    we try to write this? We could imagine using a conditional, like follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ³è±¡ä¸€ä¸‹ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦ç¼–å†™ä¸€ä¸ªç¨‹åºæ¥å®šä½`shuttle`è¡¨ä¸­å°‘äº`1000`åä¹˜å®¢çš„è¡Œã€‚æ ¹æ®æˆ‘ä»¬è¿„ä»Šä¸ºæ­¢æ‰€å­¦çš„çŸ¥è¯†ï¼Œæˆ‘ä»¬è¯¥å¦‚ä½•å°è¯•ç¼–å†™è¿™ä¸ªç¨‹åºå‘¢ï¼Ÿæˆ‘ä»¬å¯ä»¥æƒ³è±¡ä½¿ç”¨ä¸€ä¸ªæ¡ä»¶è¯­å¥ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE46]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Do Now!
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What benefits and limitations do you see to this approach?
  id: totrans-310
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ çœ‹åˆ°è¿™ç§æ–¹æ³•æœ‰å“ªäº›ä¼˜ç‚¹å’Œå±€é™æ€§ï¼Ÿ
- en: There are a couple of reasons why we might not care for this solution. First,
    if we have thousands of rows, this will be terribly painful to write. Second,
    thereâ€™s a lot of repetition here (only the row positions are changing). Third,
    it isnâ€™t clear what to do if there arenâ€™t any matching rows. In addition, what
    happens if there are multiple rows that meet our criterion? In some cases, we
    might want to be able to identify all of the rows that meet a condition and use
    them for a subsequent computation (like seeing whether some months have more low-ridership
    days than others).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯èƒ½ä¸å¸Œæœ›é‡‡ç”¨è¿™ç§è§£å†³æ–¹æ¡ˆæœ‰å‡ ä¸ªåŸå› ã€‚é¦–å…ˆï¼Œå¦‚æœæˆ‘ä»¬æœ‰æˆåƒä¸Šä¸‡è¡Œï¼Œè¿™å°†éå¸¸ç—›è‹¦å»ç¼–å†™ã€‚å…¶æ¬¡ï¼Œè¿™é‡Œæœ‰å¾ˆå¤šé‡å¤ï¼ˆåªæœ‰è¡Œä½ç½®åœ¨å˜åŒ–ï¼‰ã€‚ç¬¬ä¸‰ï¼Œå¦‚æœæ²¡æœ‰ä»»ä½•åŒ¹é…çš„è¡Œï¼Œä¸æ¸…æ¥šè¯¥æ€ä¹ˆåšã€‚æ­¤å¤–ï¼Œå¦‚æœæœ‰å¤šä¸ªè¡Œç¬¦åˆæˆ‘ä»¬çš„æ ‡å‡†ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯èƒ½å¸Œæœ›èƒ½å¤Ÿè¯†åˆ«å‡ºæ‰€æœ‰ç¬¦åˆç‰¹å®šæ¡ä»¶çš„è¡Œï¼Œå¹¶ä½¿ç”¨å®ƒä»¬è¿›è¡Œåç»­çš„è®¡ç®—ï¼ˆä¾‹å¦‚ï¼ŒæŸ¥çœ‹æŸäº›æœˆä»½æ˜¯å¦æœ‰æ¯”å…¶ä»–æœˆä»½æ›´å¤šçš„ä½ä¹˜å®¢æ—¥ï¼‰ã€‚
- en: 'This conditional is, however, the spirit of what we want to do: go through
    the rows of the table one at a time, identifying those that match some criterion.
    We just donâ€™t want to be responsible for manually checking each row. Fortunately
    for us, Pyret knows how to do that. Pyret knows which rows are in a given table.
    Pyret can pull out those rows one position at a time and check a criterion about
    each one.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œè¿™ä¸ªæ¡ä»¶æ­£æ˜¯æˆ‘ä»¬æƒ³è¦åšçš„äº‹æƒ…çš„ç²¾ç¥ï¼šé€è¡Œéå†è¡¨æ ¼ï¼Œè¯†åˆ«é‚£äº›ç¬¦åˆæŸäº›æ ‡å‡†çš„è¡Œã€‚æˆ‘ä»¬åªæ˜¯ä¸æƒ³æ‰‹åŠ¨æ£€æŸ¥æ¯ä¸€è¡Œã€‚å¹¸è¿çš„æ˜¯ï¼ŒPyretçŸ¥é“å¦‚ä½•åšè¿™ä»¶äº‹ã€‚PyretçŸ¥é“ç»™å®šè¡¨æ ¼ä¸­çš„å“ªäº›è¡Œã€‚Pyretå¯ä»¥ä¸€æ¬¡æ‹‰å‡ºä¸€ä¸ªä½ç½®ï¼Œå¹¶å¯¹æ¯ä¸€è¡Œæ£€æŸ¥ä¸€ä¸ªæ ‡å‡†ã€‚
- en: We just need to tell Pyret what criterion we want to use.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åªéœ€è¦å‘Šè¯‰Pyretæˆ‘ä»¬æƒ³è¦ä½¿ç”¨ä»€ä¹ˆæ ‡å‡†ã€‚
- en: 'As before, we can express our criterion as a function that takes a `Row` and
    produces a `Boolean` (a Boolean because our criterion was used as the question
    part of an `if` expression in our code sketch). In this case, we want:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: å’Œä¹‹å‰ä¸€æ ·ï¼Œæˆ‘ä»¬å¯ä»¥å°†æˆ‘ä»¬çš„æ ‡å‡†è¡¨è¾¾ä¸ºä¸€ä¸ªå‡½æ•°ï¼Œå®ƒæ¥å—ä¸€ä¸ª`Row`å¹¶äº§ç”Ÿä¸€ä¸ª`Boolean`ï¼ˆå› ä¸ºæˆ‘ä»¬çš„æ ‡å‡†åœ¨æˆ‘ä»¬çš„ä»£ç è‰å›¾ä¸­çš„`if`è¡¨è¾¾å¼çš„æ¡ä»¶éƒ¨åˆ†è¢«ä½¿ç”¨ï¼‰ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬æƒ³è¦ï¼š
- en: '[PRE47]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we just need a way to tell Pyret to use this criterion as it searches
    through the rows. We do this with a function called `filter-with` which takes
    two inputs: the table to process and the criterion to check on each row of the
    table.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬åªéœ€è¦ä¸€ç§æ–¹æ³•æ¥å‘Šè¯‰Pyretåœ¨æœç´¢è¡Œæ—¶ä½¿ç”¨è¿™ä¸ªæ ‡å‡†ã€‚æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªåä¸º`filter-with`çš„å‡½æ•°æ¥åšè¿™ä»¶äº‹ï¼Œå®ƒæ¥å—ä¸¤ä¸ªè¾“å…¥ï¼šè¦å¤„ç†çš„è¡¨æ ¼å’Œè¦æ£€æŸ¥è¡¨æ ¼æ¯ä¸€è¡Œçš„æ ‡å‡†ã€‚
- en: '[PRE48]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Under the hood, `filter-with` works roughly like the `if` statement we outlined
    above: it takes each row one at a time and calls the given criterion function
    on it. But what does it do with the results?'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨åº•å±‚ï¼Œ`filter-with`çš„å·¥ä½œæ–¹å¼å¤§è‡´ç±»ä¼¼äºæˆ‘ä»¬ä¸Šé¢æ¦‚è¿°çš„`if`è¯­å¥ï¼šå®ƒä¸€æ¬¡å¤„ç†ä¸€è¡Œï¼Œå¹¶å¯¹å®ƒè°ƒç”¨ç»™å®šçš„æ ‡å‡†å‡½æ•°ã€‚ä½†å®ƒå¯¹ç»“æœåšäº†ä»€ä¹ˆï¼Ÿ
- en: 'If you run the above expression, youâ€™ll see that `filter-with` produces a table
    containing the matching row, not the row by itself. This behavior is handy if
    multiple rows match the criterion. For example, try:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ è¿è¡Œä¸Šé¢çš„è¡¨è¾¾å¼ï¼Œä½ ä¼šçœ‹åˆ°`filter-with`äº§ç”Ÿä¸€ä¸ªåŒ…å«åŒ¹é…è¡Œçš„è¡¨æ ¼ï¼Œè€Œä¸æ˜¯å•ç‹¬çš„è¡Œã€‚å¦‚æœæœ‰å¤šè¡ŒåŒ¹é…æ ‡å‡†ï¼Œè¿™ç§è¡Œä¸ºå¾ˆæœ‰ç”¨ã€‚ä¾‹å¦‚ï¼Œå°è¯•ï¼š
- en: '[PRE49]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '(using the `is-winter` function from an exercise earlier in this chapter).
    Now we get a table with the three rows corresponding to winter months. If we want
    to be able to name this table for use in future computations, we can do so with
    our usual notation for naming values:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆä½¿ç”¨æœ¬ç« æ—©æœŸç»ƒä¹ ä¸­æåˆ°çš„`is-winter`å‡½æ•°ï¼‰ã€‚ç°åœ¨æˆ‘ä»¬å¾—åˆ°äº†ä¸€ä¸ªåŒ…å«å¯¹åº”å†¬å­£æœˆä»½çš„ä¸‰è¡Œè¡¨æ ¼ã€‚å¦‚æœæˆ‘ä»¬æƒ³èƒ½å¤Ÿåœ¨æœªæ¥çš„è®¡ç®—ä¸­ä½¿ç”¨è¿™ä¸ªè¡¨æ ¼çš„åç§°ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æˆ‘ä»¬ä¸ºå‘½åå€¼å¸¸ç”¨çš„ç¬¦å·æ¥åšè¿™ä»¶äº‹ï¼š
- en: '[PRE50]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 4.1.4.2Â Ordering Rows[ğŸ”—](#(part._.Ordering_.Rows) "Link to here")
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.1.4.2Â æ’åºè¡Œ[ğŸ”—](#(part._.Ordering_.Rows) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Letâ€™s ask a new question: which winter month had the fewest number of riders?.
    This question requires us to identify a specific row, namely, the winter row with
    the smallest value in the `"riders"` column.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æå‡ºä¸€ä¸ªæ–°çš„é—®é¢˜ï¼šå“ªä¸ªå†¬å­£æœˆä»½çš„ä¹˜å®¢æ•°é‡æœ€å°‘ï¼Ÿè¿™ä¸ªé—®é¢˜è¦æ±‚æˆ‘ä»¬è¯†åˆ«ä¸€ä¸ªç‰¹å®šçš„è¡Œï¼Œå³`"riders"`åˆ—ä¸­å€¼æœ€å°çš„å†¬å­£è¡Œã€‚
- en: Do Now!
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can we do this with `filter-with`? Why or why not?
  id: totrans-327
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ç”¨`filter-with`åšè¿™ä»¶äº‹å—ï¼Ÿä¸ºä»€ä¹ˆæˆ–ä¸ºä»€ä¹ˆä¸ï¼Ÿ
- en: 'Think back to the `if` expression that motivated `filter-with`: each row is
    evaluated independently of the others. Our current question, however, requires
    comparing across rows. Thatâ€™s a different operation, so we will need more than
    `filter-with`.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: å›æƒ³ä¸€ä¸‹æ¿€åŠ±`filter-with`çš„`if`è¡¨è¾¾å¼ï¼šæ¯ä¸€è¡Œéƒ½æ˜¯ç‹¬ç«‹äºå…¶ä»–è¡Œè¿›è¡Œè¯„ä¼°çš„ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬çš„å½“å‰é—®é¢˜éœ€è¦è·¨è¡Œè¿›è¡Œæ¯”è¾ƒã€‚è¿™æ˜¯ä¸€ä¸ªä¸åŒçš„æ“ä½œï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦æ¯”`filter-with`æ›´å¤šçš„ä¸œè¥¿ã€‚
- en: 'Tools for analyzing data (whether programming languages or spreadsheets) provide
    ways for users to sort rows of a table based on the values in a single column.
    That would help us here: we could sort the winter rows from smallest to largest
    value in the `"riders"` column, then extract the `"riders"` value from the first
    row. First, letâ€™s sort the rows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ†ææ•°æ®çš„å·¥å…·ï¼ˆæ— è®ºæ˜¯ç¼–ç¨‹è¯­è¨€è¿˜æ˜¯ç”µå­è¡¨æ ¼ï¼‰ä¸ºç”¨æˆ·æä¾›äº†ä¸€ç§æ–¹æ³•ï¼Œå¯ä»¥æ ¹æ®å•åˆ—ä¸­çš„å€¼å¯¹è¡¨æ ¼çš„è¡Œè¿›è¡Œæ’åºã€‚è¿™åœ¨è¿™é‡Œä¼šæœ‰å¸®åŠ©ï¼šæˆ‘ä»¬å¯ä»¥æ ¹æ®`"riders"`åˆ—ä¸­çš„å€¼ä»å°åˆ°å¤§å¯¹å†¬å­£è¡Œè¿›è¡Œæ’åºï¼Œç„¶åä»ç¬¬ä¸€è¡Œä¸­æå–`"riders"`å€¼ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬å¯¹è¡Œè¿›è¡Œæ’åºï¼š
- en: '[PRE51]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `order-by` function takes three inputs: the table to sort (`winter`), the
    column to sort on (`"riders"`), and a `Boolean` to indicate whether we want to
    sort in increasing order. (Had the third argument been `false`, the rows would
    be sorted in decreasing order of the values in the named column.)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`order-by`å‡½æ•°æ¥å—ä¸‰ä¸ªè¾“å…¥ï¼šè¦æ’åºçš„è¡¨æ ¼ï¼ˆ`winter`ï¼‰ã€æ’åºçš„åˆ—ï¼ˆ`"riders"`ï¼‰ä»¥åŠä¸€ä¸ª`Boolean`å€¼ï¼Œè¡¨ç¤ºæˆ‘ä»¬æ˜¯å¦æƒ³è¦æŒ‰å‡åºæ’åºã€‚ï¼ˆå¦‚æœç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯`false`ï¼Œåˆ™è¡Œå°†æŒ‰åˆ—ä¸­å€¼çš„é™åºæ’åºã€‚ï¼‰'
- en: '![](../Images/50fd4ee1a960ed4942030557bea37389.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/50fd4ee1a960ed4942030557bea37389.png)'
- en: In the sorted table, the row with the fewest riders is in the first position.
    Our original question asked us to lookup the month with the fewest riders. We
    did this earlier.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ’åºåçš„è¡¨ä¸­ï¼Œä¹˜å®¢æœ€å°‘çš„è¡Œä½äºç¬¬ä¸€ä½ã€‚æˆ‘ä»¬æœ€åˆçš„é—®é¢˜è¦æ±‚æˆ‘ä»¬æŸ¥æ‰¾ä¹˜å®¢æœ€å°‘çš„æœˆä»½ã€‚æˆ‘ä»¬ä¹‹å‰å·²ç»è¿™æ ·åšè¿‡äº†ã€‚
- en: Do Now!
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write the code to extract the name of the winter month with the fewest riders.
  id: totrans-336
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ä»£ç ä»¥æå–ä¹˜å®¢æœ€å°‘çš„å†¬å­£æœˆä»½çš„åç§°ã€‚
- en: 'Here are two ways to write that computation:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸¤ç§ç¼–å†™è¿™ç§è®¡ç®—çš„æ–¹æ³•ï¼š
- en: '[PRE52]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Do Now!
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of these two ways do you prefer? Why?
  id: totrans-342
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ æ›´å–œæ¬¢è¿™ä¸¤ç§æ–¹æ³•ä¸­çš„å“ªä¸€ç§ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ
- en: Do Now!
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How does each of these programs affect the program directory?
  id: totrans-345
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ¯ä¸ªç¨‹åºå¦‚ä½•å½±å“ç¨‹åºç›®å½•ï¼Ÿ
- en: 'Note that this problem asked us to combine several actions that weâ€™ve already
    seen on rows: we identify rows from within a table (`filter-with`), order the
    rows (`order-by`), extract a specific row (`row-n`), then extract a cell (with
    square brackets and a column name). This is typical of how we will operate on
    tables, combining multiple operations to compute a result (much as we did with
    programs that manipulate images).'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè¿™ä¸ªé—®é¢˜è¦æ±‚æˆ‘ä»¬ç»“åˆæˆ‘ä»¬å·²ç»çœ‹åˆ°çš„å‡ ä¸ªè¡Œæ“ä½œï¼šæˆ‘ä»¬è¯†åˆ«è¡¨ä¸­çš„è¡Œï¼ˆ`filter-with`ï¼‰ï¼Œå¯¹è¡Œè¿›è¡Œæ’åºï¼ˆ`order-by`ï¼‰ï¼Œæå–ç‰¹å®šçš„è¡Œï¼ˆ`row-n`ï¼‰ï¼Œç„¶åæå–å•å…ƒæ ¼ï¼ˆä½¿ç”¨æ–¹æ‹¬å·å’Œåˆ—åï¼‰ã€‚è¿™æ˜¯æˆ‘ä»¬æ“ä½œè¡¨æ ¼çš„å…¸å‹æ–¹å¼ï¼Œç»“åˆå¤šä¸ªæ“ä½œæ¥è®¡ç®—ç»“æœï¼ˆå°±åƒæˆ‘ä»¬å¤„ç†å›¾åƒçš„ç¨‹åºä¸€æ ·ï¼‰ã€‚
- en: 4.1.4.3Â Adding New Columns[ğŸ”—](#(part._.Adding_.New_.Columns) "Link to here")
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.1.4.3Â æ·»åŠ æ–°åˆ—[ğŸ”—](#(part._.Adding_.New_.Columns) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Sometimes, we want to create a new column whose value is based on those of
    existing columns. For instance, our table might reflect employee records, and
    have columns named `hourly-wage` and `hours-worked`, representing the corresponding
    quantities. We would now like to extend this table with a new column to reflect
    each employeeâ€™s total wage. Assume we started with the following table:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰æ—¶å€™ï¼Œæˆ‘ä»¬æƒ³è¦åˆ›å»ºä¸€ä¸ªæ–°åˆ—ï¼Œå…¶å€¼åŸºäºç°æœ‰åˆ—çš„å€¼ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬çš„è¡¨æ ¼å¯èƒ½åæ˜ äº†å‘˜å·¥è®°å½•ï¼Œå¹¶å…·æœ‰åä¸º `hourly-wage` å’Œ `hours-worked`
    çš„åˆ—ï¼Œä»£è¡¨ç›¸åº”çš„æ•°é‡ã€‚æˆ‘ä»¬ç°åœ¨æƒ³é€šè¿‡æ·»åŠ ä¸€ä¸ªæ–°åˆ—æ¥æ‰©å±•è¿™ä¸ªè¡¨æ ¼ï¼Œä»¥åæ˜ æ¯ä½å‘˜å·¥çš„å·¥èµ„æ€»é¢ã€‚å‡è®¾æˆ‘ä»¬å¼€å§‹æ—¶çš„è¡¨æ ¼å¦‚ä¸‹ï¼š
- en: '[PRE54]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The table we want to end up with is:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æƒ³è¦çš„æœ€ç»ˆè¡¨æ ¼å¦‚ä¸‹ï¼š
- en: '[PRE55]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '(with the expressions in the `total-wage` column computed to their numeric
    equivalents: we used the expressions here to illustrate what we are trying to
    do).'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆåœ¨ `total-wage` åˆ—ä¸­çš„è¡¨è¾¾å¼è®¡ç®—åˆ°å®ƒä»¬çš„æ•°å€¼ç­‰æ•ˆï¼šæˆ‘ä»¬åœ¨è¿™é‡Œä½¿ç”¨è¡¨è¾¾å¼æ¥å±•ç¤ºæˆ‘ä»¬è¯•å›¾åšä»€ä¹ˆï¼‰ã€‚
- en: Previously, when we have had a computation that we performed multiple times,
    we created a helper function to do the computation.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥å‰ï¼Œå½“æˆ‘ä»¬éœ€è¦å¤šæ¬¡æ‰§è¡ŒæŸä¸ªè®¡ç®—æ—¶ï¼Œæˆ‘ä»¬ä¼šåˆ›å»ºä¸€ä¸ªè¾…åŠ©å‡½æ•°æ¥å®Œæˆè¿™ä¸ªè®¡ç®—ã€‚
- en: Do Now!
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Propose a helper function for computing total wages given the hourly wage and
    number of hours worked.
  id: totrans-356
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æå‡ºä¸€ä¸ªè¾…åŠ©å‡½æ•°ï¼Œç”¨äºæ ¹æ®æ—¶è–ªå’Œå·¥æ—¶è®¡ç®—æ€»å·¥èµ„ã€‚
- en: 'Perhaps you came up with something like:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½æƒ³åˆ°äº†ç±»ä¼¼ä»¥ä¸‹çš„å†…å®¹ï¼š
- en: '[PRE56]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'which we could use as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥è¿™æ ·ä½¿ç”¨å®ƒï¼š
- en: '[PRE57]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This is the right idea, but we can actually have this function do a bit more
    work for us. The `wage` and `hours` values are in cells within the same row. So
    if we could instead get the current row as an input, we could write:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªæ­£ç¡®çš„æƒ³æ³•ï¼Œä½†å®é™…ä¸Šæˆ‘ä»¬å¯ä»¥è®©è¿™ä¸ªå‡½æ•°ä¸ºæˆ‘ä»¬åšæ›´å¤šçš„å·¥ä½œã€‚`wage` å’Œ `hours` å€¼ä½äºåŒä¸€è¡Œçš„å•å…ƒæ ¼ä¸­ã€‚å› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬èƒ½å¤Ÿè·å–å½“å‰è¡Œä½œä¸ºè¾“å…¥ï¼Œæˆ‘ä»¬å¯ä»¥ç¼–å†™ï¼š
- en: '[PRE58]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'But now, we are writing calls to `compute-wages` over and over! Adding computed
    columns is a sufficiently common operation that Pyret provides a table function
    called `build-column` for this purpose. We use it by providing the function to
    use to populate values in the new column as an input:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†ç°åœ¨ï¼Œæˆ‘ä»¬æ­£åœ¨åå¤ç¼–å†™å¯¹ `compute-wages` çš„è°ƒç”¨ï¼æ·»åŠ è®¡ç®—åˆ—æ˜¯ä¸€ä¸ªè¶³å¤Ÿå¸¸è§çš„æ“ä½œï¼ŒPyret æä¾›äº†ä¸€ä¸ªåä¸º `build-column`
    çš„è¡¨å‡½æ•°æ¥å®Œæˆæ­¤æ“ä½œã€‚æˆ‘ä»¬é€šè¿‡æä¾›ç”¨äºå¡«å……æ–°åˆ—å€¼çš„å‡½æ•°ä½œä¸ºè¾“å…¥æ¥ä½¿ç”¨å®ƒï¼š
- en: '[PRE59]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This creates a new column, `total-wage`, whose value in each row is the product
    of the two named columns in that row. Pyret will put the new column at the right
    end.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°†åˆ›å»ºä¸€ä¸ªæ–°åˆ—ï¼Œ`total-wage`ï¼Œå…¶ä¸­æ¯è¡Œçš„å€¼æ˜¯é‚£ä¸€è¡Œä¸­ä¸¤ä¸ªå‘½ååˆ—çš„ä¹˜ç§¯ã€‚Pyret å°†å°†æ–°åˆ—æ”¾åœ¨å³ä¾§ã€‚
- en: 4.1.4.4Â Calculating New Column Values[ğŸ”—](#(part._.Calculating_.New_.Column_.Values)
    "Link to here")
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.1.4.4Â è®¡ç®—æ–°åˆ—å€¼[ğŸ”—](#(part._.Calculating_.New_.Column_.Values) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Sometimes, we just want to calculate new values for an existing column, rather
    than create an entirely new column. Giving raises to employees is one such example.
    Assume we wanted to give a `10%` raise to all employees making less than `20`
    an hour. We could write:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰æ—¶å€™ï¼Œæˆ‘ä»¬åªæƒ³è®¡ç®—ç°æœ‰åˆ—çš„æ–°å€¼ï¼Œè€Œä¸æ˜¯åˆ›å»ºä¸€ä¸ªå…¨æ–°çš„åˆ—ã€‚ç»™å‘˜å·¥åŠ è–ªå°±æ˜¯ä¸€ä¸ªä¾‹å­ã€‚å‡è®¾æˆ‘ä»¬æƒ³è¦ç»™æ¯å°æ—¶å·¥èµ„å°‘äº `20` ç¾å…ƒçš„æ‰€æœ‰å‘˜å·¥åŠ  `10%`
    çš„å·¥èµ„ã€‚æˆ‘ä»¬å¯ä»¥ç¼–å†™ï¼š
- en: '[PRE60]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, `transform-column` takes a table, the name of an existing column in the
    table, and a function to update the value. The updating function takes the current
    value in the column as input and produces the new value for the column as output.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œ`transform-column`æ¥å—ä¸€ä¸ªè¡¨æ ¼ã€è¡¨æ ¼ä¸­ç°æœ‰åˆ—çš„åç§°ä»¥åŠä¸€ä¸ªç”¨äºæ›´æ–°å€¼çš„å‡½æ•°ã€‚æ›´æ–°å‡½æ•°æ¥å—åˆ—ä¸­çš„å½“å‰å€¼ä½œä¸ºè¾“å…¥ï¼Œå¹¶äº§ç”Ÿåˆ—çš„æ–°å€¼ä½œä¸ºè¾“å‡ºã€‚
- en: Do Now!
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Run `give-raises` on the `employees` table. What wage will show for `"Miyako"`
    in the `employees` table after `give-raises` completes. Why?
  id: totrans-372
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨`employees`è¡¨ä¸Šè¿è¡Œ`give-raises`ã€‚åœ¨`give-raises`å®Œæˆåï¼Œ`employees`è¡¨ä¸­`"Miyako"`çš„å·¥èµ„å°†æ˜¾ç¤ºä»€ä¹ˆï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ
- en: Like all other Pyret `Table` operations, `transform-column` produces a new table,
    leaving the original intact. Editing the original table could be problematicâ€“what
    if you made a mistake? How would you recover the original table in that case?
    In general, producing new tables with any modifications, then creating a new name
    for the updated table once you have the one you want, is a less error-prone way
    of working with datasets.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: å°±åƒæ‰€æœ‰å…¶ä»–Pyret `Table`æ“ä½œä¸€æ ·ï¼Œ`transform-column`ç”Ÿæˆä¸€ä¸ªæ–°çš„è¡¨æ ¼ï¼Œä¿ç•™åŸå§‹è¡¨æ ¼ä¸å˜ã€‚ç¼–è¾‘åŸå§‹è¡¨æ ¼å¯èƒ½ä¼šæœ‰é—®é¢˜â€”â€”å¦‚æœä½ çŠ¯äº†é”™è¯¯æ€ä¹ˆåŠï¼Ÿåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½ å¦‚ä½•æ¢å¤åŸå§‹è¡¨æ ¼ï¼Ÿä¸€èˆ¬æ¥è¯´ï¼Œåœ¨ä¿®æ”¹ä»»ä½•æ•°æ®é›†åç”Ÿæˆæ–°è¡¨æ ¼ï¼Œç„¶ååœ¨ä½ å¾—åˆ°æƒ³è¦çš„è¡¨æ ¼åä¸ºæ›´æ–°çš„è¡¨æ ¼åˆ›å»ºä¸€ä¸ªæ–°åç§°ï¼Œè¿™æ˜¯ä¸€ç§æ›´ä¸å®¹æ˜“å‡ºé”™çš„æ“ä½œæ–¹å¼ã€‚
- en: 4.1.4.1Â Finding Rows[ğŸ”—](#(part._subsec~3afinding-rows) "Link to here")
  id: totrans-374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.1.4.1Â æŸ¥æ‰¾è¡Œ[ğŸ”—](#(part._subsec~3afinding-rows) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Imagine that we wanted to write a program to locate a row that has fewer than
    `1000` riders from our `shuttle` table. With what weâ€™ve studied so far, how might
    we try to write this? We could imagine using a conditional, like follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬æƒ³è¦ç¼–å†™ä¸€ä¸ªç¨‹åºæ¥å®šä½`shuttle`è¡¨ä¸­ä¹˜å®¢å°‘äº`1000`çš„è¡Œã€‚æ ¹æ®æˆ‘ä»¬è¿„ä»Šä¸ºæ­¢å­¦åˆ°çš„çŸ¥è¯†ï¼Œæˆ‘ä»¬å¦‚ä½•å°è¯•ç¼–å†™è¿™ä¸ªç¨‹åºï¼Ÿæˆ‘ä»¬å¯ä»¥æƒ³è±¡ä½¿ç”¨ä¸€ä¸ªæ¡ä»¶ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE61]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Do Now!
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What benefits and limitations do you see to this approach?
  id: totrans-379
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ çœ‹åˆ°è¿™ä¸ªæ–¹æ³•æœ‰å“ªäº›ä¼˜ç‚¹å’Œå±€é™æ€§ï¼Ÿ
- en: There are a couple of reasons why we might not care for this solution. First,
    if we have thousands of rows, this will be terribly painful to write. Second,
    thereâ€™s a lot of repetition here (only the row positions are changing). Third,
    it isnâ€™t clear what to do if there arenâ€™t any matching rows. In addition, what
    happens if there are multiple rows that meet our criterion? In some cases, we
    might want to be able to identify all of the rows that meet a condition and use
    them for a subsequent computation (like seeing whether some months have more low-ridership
    days than others).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯èƒ½ä¸å…³å¿ƒè¿™ä¸ªè§£å†³æ–¹æ¡ˆæœ‰å‡ ä¸ªåŸå› ã€‚é¦–å…ˆï¼Œå¦‚æœæˆ‘ä»¬æœ‰æ•°åƒè¡Œï¼Œè¿™å°†éå¸¸ç—›è‹¦åœ°ç¼–å†™ã€‚å…¶æ¬¡ï¼Œè¿™é‡Œæœ‰å¾ˆå¤šé‡å¤ï¼ˆåªæœ‰è¡Œä½ç½®åœ¨å˜åŒ–ï¼‰ã€‚ç¬¬ä¸‰ï¼Œå¦‚æœæ²¡æœ‰ä»»ä½•åŒ¹é…çš„è¡Œï¼Œä¸æ¸…æ¥šè¦åšä»€ä¹ˆã€‚æ­¤å¤–ï¼Œå¦‚æœæœ‰å¤šä¸ªè¡Œç¬¦åˆæˆ‘ä»¬çš„æ ‡å‡†ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯èƒ½å¸Œæœ›èƒ½å¤Ÿè¯†åˆ«æ‰€æœ‰ç¬¦åˆæ¡ä»¶çš„è¡Œï¼Œå¹¶ä½¿ç”¨å®ƒä»¬è¿›è¡Œåç»­è®¡ç®—ï¼ˆæ¯”å¦‚æŸ¥çœ‹æ˜¯å¦æœ‰å‡ ä¸ªæœˆçš„ä¹˜å®¢æ—¥æ¯”å…¶ä»–æœˆä»½å¤šï¼‰ã€‚
- en: 'This conditional is, however, the spirit of what we want to do: go through
    the rows of the table one at a time, identifying those that match some criterion.
    We just donâ€™t want to be responsible for manually checking each row. Fortunately
    for us, Pyret knows how to do that. Pyret knows which rows are in a given table.
    Pyret can pull out those rows one position at a time and check a criterion about
    each one.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªæ¡ä»¶å®é™…ä¸Šæ˜¯æˆ‘ä»¬æƒ³è¦åšçš„äº‹æƒ…çš„ç²¾ç¥ï¼šé€è¡Œéå†è¡¨æ ¼ï¼Œè¯†åˆ«é‚£äº›ç¬¦åˆæŸäº›æ ‡å‡†çš„è¡Œã€‚æˆ‘ä»¬åªæ˜¯ä¸æƒ³æ‰‹åŠ¨æ£€æŸ¥æ¯ä¸€è¡Œã€‚å¹¸è¿çš„æ˜¯ï¼ŒPyretçŸ¥é“å¦‚ä½•åšåˆ°è¿™ä¸€ç‚¹ã€‚PyretçŸ¥é“ç»™å®šè¡¨æ ¼ä¸­çš„å“ªäº›è¡Œã€‚Pyretå¯ä»¥ä¸€æ¬¡æå–ä¸€è¡Œï¼Œå¹¶å¯¹æ¯ä¸€è¡Œæ£€æŸ¥ä¸€ä¸ªæ ‡å‡†ã€‚
- en: We just need to tell Pyret what criterion we want to use.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åªéœ€è¦å‘Šè¯‰Pyretæˆ‘ä»¬æƒ³è¦ä½¿ç”¨ä»€ä¹ˆæ ‡å‡†ã€‚
- en: 'As before, we can express our criterion as a function that takes a `Row` and
    produces a `Boolean` (a Boolean because our criterion was used as the question
    part of an `if` expression in our code sketch). In this case, we want:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: å’Œä¹‹å‰ä¸€æ ·ï¼Œæˆ‘ä»¬å¯ä»¥å°†æ ‡å‡†è¡¨è¾¾ä¸ºä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ª`Row`å¹¶äº§ç”Ÿä¸€ä¸ª`Boolean`ï¼ˆå› ä¸ºæˆ‘ä»¬çš„æ ‡å‡†åœ¨ä»£ç è‰å›¾ä¸­çš„`if`è¡¨è¾¾å¼çš„æ¡ä»¶éƒ¨åˆ†è¢«ä½¿ç”¨ï¼‰ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬æƒ³è¦ï¼š
- en: '[PRE62]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, we just need a way to tell Pyret to use this criterion as it searches
    through the rows. We do this with a function called `filter-with` which takes
    two inputs: the table to process and the criterion to check on each row of the
    table.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬åªéœ€è¦ä¸€ç§æ–¹æ³•æ¥å‘Šè¯‰Pyretåœ¨æœç´¢è¡Œæ—¶ä½¿ç”¨è¿™ä¸ªæ ‡å‡†ã€‚æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªåä¸º`filter-with`çš„å‡½æ•°æ¥å®Œæˆè¿™ä¸ªæ“ä½œï¼Œè¯¥å‡½æ•°æ¥å—ä¸¤ä¸ªè¾“å…¥ï¼šè¦å¤„ç†çš„è¡¨æ ¼å’Œè¦æ£€æŸ¥è¡¨æ ¼æ¯ä¸€è¡Œçš„æ ‡å‡†ã€‚
- en: '[PRE63]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Under the hood, `filter-with` works roughly like the `if` statement we outlined
    above: it takes each row one at a time and calls the given criterion function
    on it. But what does it do with the results?'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨åº•å±‚ï¼Œ`filter-with`çš„å·¥ä½œæ–¹å¼å¤§è‡´ç±»ä¼¼äºæˆ‘ä»¬ä¸Šé¢æ¦‚è¿°çš„`if`è¯­å¥ï¼šå®ƒé€è¡Œå¤„ç†æ¯ä¸€è¡Œï¼Œå¹¶å¯¹å®ƒè°ƒç”¨ç»™å®šçš„æ ‡å‡†å‡½æ•°ã€‚ä½†å®ƒå¯¹ç»“æœåšäº†ä»€ä¹ˆï¼Ÿ
- en: 'If you run the above expression, youâ€™ll see that `filter-with` produces a table
    containing the matching row, not the row by itself. This behavior is handy if
    multiple rows match the criterion. For example, try:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ è¿è¡Œä¸Šé¢çš„è¡¨è¾¾å¼ï¼Œä½ ä¼šçœ‹åˆ° `filter-with` äº§ç”Ÿä¸€ä¸ªåŒ…å«åŒ¹é…è¡Œçš„è¡¨æ ¼ï¼Œè€Œä¸æ˜¯å•ç‹¬çš„è¡Œã€‚å¦‚æœæœ‰å¤šè¡ŒåŒ¹é…æ¡ä»¶ï¼Œè¿™ç§è¡Œä¸ºå°±å¾ˆæœ‰ç”¨ã€‚ä¾‹å¦‚ï¼Œå°è¯•ï¼š
- en: '[PRE64]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '(using the `is-winter` function from an exercise earlier in this chapter).
    Now we get a table with the three rows corresponding to winter months. If we want
    to be able to name this table for use in future computations, we can do so with
    our usual notation for naming values:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆä½¿ç”¨æœ¬ç« æ—©æœŸç»ƒä¹ ä¸­çš„ `is-winter` å‡½æ•°ï¼‰ã€‚ç°åœ¨æˆ‘ä»¬å¾—åˆ°äº†ä¸€ä¸ªåŒ…å«å¯¹åº”å†¬å­£æœˆä»½çš„ä¸‰è¡Œè¡¨æ ¼ã€‚å¦‚æœæˆ‘ä»¬æƒ³åœ¨æœªæ¥çš„è®¡ç®—ä¸­ä½¿ç”¨è¿™ä¸ªè¡¨ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨æˆ‘ä»¬å‘½åå€¼çš„å¸¸è§„ç¬¦å·æ¥åšï¼š
- en: '[PRE65]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 4.1.4.2Â Ordering Rows[ğŸ”—](#(part._.Ordering_.Rows) "Link to here")
  id: totrans-392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.1.4.2 æ’åºè¡Œ[ğŸ”—](#(part._.Ordering_.Rows) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Letâ€™s ask a new question: which winter month had the fewest number of riders?.
    This question requires us to identify a specific row, namely, the winter row with
    the smallest value in the `"riders"` column.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æå‡ºä¸€ä¸ªæ–°çš„é—®é¢˜ï¼šå“ªä¸ªå†¬å­£æœˆä»½çš„ä¹˜å®¢æ•°é‡æœ€å°‘ï¼Ÿè¿™ä¸ªé—®é¢˜è¦æ±‚æˆ‘ä»¬è¯†åˆ«ä¸€ä¸ªç‰¹å®šçš„è¡Œï¼Œå³ `"riders"` åˆ—ä¸­å€¼æœ€å°çš„å†¬å­£è¡Œã€‚
- en: Do Now!
  id: totrans-394
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-395
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can we do this with `filter-with`? Why or why not?
  id: totrans-396
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬èƒ½å¦ç”¨ `filter-with` æ¥åšè¿™ä»¶äº‹ï¼Ÿä¸ºä»€ä¹ˆå¯ä»¥æˆ–ä¸å¯ä»¥ï¼Ÿ
- en: 'Think back to the `if` expression that motivated `filter-with`: each row is
    evaluated independently of the others. Our current question, however, requires
    comparing across rows. Thatâ€™s a different operation, so we will need more than
    `filter-with`.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: å›æƒ³ä¸€ä¸‹æ¿€å‘ `filter-with` çš„ `if` è¡¨è¾¾å¼ï¼šæ¯ä¸€è¡Œéƒ½æ˜¯ç‹¬ç«‹äºå…¶ä»–è¡Œè¿›è¡Œè¯„ä¼°çš„ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å½“å‰çš„é—®é¢˜éœ€è¦è·¨è¡Œæ¯”è¾ƒã€‚è¿™æ˜¯ä¸€ä¸ªä¸åŒçš„æ“ä½œï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦æ¯”
    `filter-with` æ›´å¤šçš„åŠŸèƒ½ã€‚
- en: 'Tools for analyzing data (whether programming languages or spreadsheets) provide
    ways for users to sort rows of a table based on the values in a single column.
    That would help us here: we could sort the winter rows from smallest to largest
    value in the `"riders"` column, then extract the `"riders"` value from the first
    row. First, letâ€™s sort the rows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ†ææ•°æ®ï¼ˆæ— è®ºæ˜¯ç¼–ç¨‹è¯­è¨€è¿˜æ˜¯ç”µå­è¡¨æ ¼ï¼‰çš„å·¥å…·ä¸ºç”¨æˆ·æä¾›äº†ä¸€ç§æ–¹æ³•ï¼Œå¯ä»¥æ ¹æ®å•åˆ—ä¸­çš„å€¼å¯¹è¡¨æ ¼çš„è¡Œè¿›è¡Œæ’åºã€‚è¿™åœ¨è¿™é‡Œä¼šå¾ˆæœ‰å¸®åŠ©ï¼šæˆ‘ä»¬å¯ä»¥æ ¹æ® `"riders"`
    åˆ—ä¸­çš„å€¼ä»å°åˆ°å¤§å¯¹å†¬å­£è¡Œè¿›è¡Œæ’åºï¼Œç„¶åä»ç¬¬ä¸€è¡Œä¸­æå– `"riders"` å€¼ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬å¯¹è¡Œè¿›è¡Œæ’åºï¼š
- en: '[PRE66]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `order-by` function takes three inputs: the table to sort (`winter`), the
    column to sort on (`"riders"`), and a `Boolean` to indicate whether we want to
    sort in increasing order. (Had the third argument been `false`, the rows would
    be sorted in decreasing order of the values in the named column.)'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`order-by` å‡½æ•°æ¥å—ä¸‰ä¸ªè¾“å…¥ï¼šè¦æ’åºçš„è¡¨ï¼ˆ`winter`ï¼‰ã€æ’åºçš„åˆ—ï¼ˆ`"riders"`ï¼‰ä»¥åŠä¸€ä¸ª `Boolean` å€¼ï¼Œè¡¨ç¤ºæˆ‘ä»¬æ˜¯å¦å¸Œæœ›æŒ‰å‡åºæ’åºã€‚ï¼ˆå¦‚æœç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯
    `false`ï¼Œåˆ™è¡Œå°†æŒ‰å‘½ååˆ—ä¸­çš„å€¼é™åºæ’åºã€‚ï¼‰'
- en: '![](../Images/50fd4ee1a960ed4942030557bea37389.png)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/50fd4ee1a960ed4942030557bea37389.png)'
- en: In the sorted table, the row with the fewest riders is in the first position.
    Our original question asked us to lookup the month with the fewest riders. We
    did this earlier.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ’åºåçš„è¡¨ä¸­ï¼Œä¹˜å®¢æœ€å°‘çš„è¡Œä½äºç¬¬ä¸€ä¸ªä½ç½®ã€‚æˆ‘ä»¬åŸæ¥çš„é—®é¢˜è¦æ±‚æˆ‘ä»¬æŸ¥æ‰¾ä¹˜å®¢æœ€å°‘çš„æœˆä»½ã€‚æˆ‘ä»¬ä¹‹å‰å·²ç»è¿™æ ·åšè¿‡äº†ã€‚
- en: Do Now!
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write the code to extract the name of the winter month with the fewest riders.
  id: totrans-405
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ä»£ç ä»¥æå–ä¹˜å®¢æœ€å°‘çš„å†¬å­£æœˆä»½çš„åç§°ã€‚
- en: 'Here are two ways to write that computation:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸¤ç§ç¼–å†™è¿™ç§è®¡ç®—çš„æ–¹æ³•ï¼š
- en: '[PRE67]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Do Now!
  id: totrans-409
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-410
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of these two ways do you prefer? Why?
  id: totrans-411
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ æ›´å–œæ¬¢è¿™ä¸¤ç§æ–¹å¼ä¸­çš„å“ªä¸€ç§ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ
- en: Do Now!
  id: totrans-412
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-413
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How does each of these programs affect the program directory?
  id: totrans-414
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™äº›ç¨‹åºä¸­çš„æ¯ä¸€ä¸ªå¦‚ä½•å½±å“ç¨‹åºç›®å½•ï¼Ÿ
- en: 'Note that this problem asked us to combine several actions that weâ€™ve already
    seen on rows: we identify rows from within a table (`filter-with`), order the
    rows (`order-by`), extract a specific row (`row-n`), then extract a cell (with
    square brackets and a column name). This is typical of how we will operate on
    tables, combining multiple operations to compute a result (much as we did with
    programs that manipulate images).'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè¿™ä¸ªé—®é¢˜è¦æ±‚æˆ‘ä»¬ç»„åˆæˆ‘ä»¬å·²ç»çœ‹åˆ°çš„å‡ ä¸ªå¯¹è¡Œçš„æ“ä½œï¼šæˆ‘ä»¬è¯†åˆ«è¡¨å†…çš„è¡Œï¼ˆ`filter-with`ï¼‰ã€å¯¹è¡Œè¿›è¡Œæ’åºï¼ˆ`order-by`ï¼‰ã€æå–ç‰¹å®šçš„è¡Œï¼ˆ`row-n`ï¼‰ï¼Œç„¶åæå–å•å…ƒæ ¼ï¼ˆä½¿ç”¨æ–¹æ‹¬å·å’Œåˆ—åï¼‰ã€‚è¿™æ˜¯æˆ‘ä»¬æ“ä½œè¡¨çš„æ–¹å¼çš„å…¸å‹ä¾‹å­ï¼Œé€šè¿‡ç»„åˆå¤šä¸ªæ“ä½œæ¥è®¡ç®—ç»“æœï¼ˆå°±åƒæˆ‘ä»¬å¤„ç†å›¾åƒçš„ç¨‹åºä¸€æ ·ï¼‰ã€‚
- en: 4.1.4.3Â Adding New Columns[ğŸ”—](#(part._.Adding_.New_.Columns) "Link to here")
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.1.4.3 æ·»åŠ æ–°åˆ—[ğŸ”—](#(part._.Adding_.New_.Columns) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Sometimes, we want to create a new column whose value is based on those of
    existing columns. For instance, our table might reflect employee records, and
    have columns named `hourly-wage` and `hours-worked`, representing the corresponding
    quantities. We would now like to extend this table with a new column to reflect
    each employeeâ€™s total wage. Assume we started with the following table:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰æ—¶å€™ï¼Œæˆ‘ä»¬æƒ³è¦åˆ›å»ºä¸€ä¸ªæ–°åˆ—ï¼Œå…¶å€¼åŸºäºç°æœ‰åˆ—çš„å€¼ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬çš„è¡¨æ ¼å¯èƒ½åæ˜ äº†å‘˜å·¥çš„è®°å½•ï¼Œå¹¶å…·æœ‰åä¸º`hourly-wage`å’Œ`hours-worked`çš„åˆ—ï¼Œä»£è¡¨ç›¸åº”çš„æ•°é‡ã€‚æˆ‘ä»¬ç°åœ¨æƒ³åœ¨è¿™ä¸ªè¡¨æ ¼ä¸­æ·»åŠ ä¸€ä¸ªæ–°åˆ—æ¥åæ˜ æ¯ä½å‘˜å·¥çš„å·¥èµ„æ€»é¢ã€‚å‡è®¾æˆ‘ä»¬å¼€å§‹æ—¶çš„è¡¨æ ¼å¦‚ä¸‹ï¼š
- en: '[PRE69]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The table we want to end up with is:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¸Œæœ›å¾—åˆ°çš„è¡¨æ ¼æ˜¯ï¼š
- en: '[PRE70]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '(with the expressions in the `total-wage` column computed to their numeric
    equivalents: we used the expressions here to illustrate what we are trying to
    do).'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆ`total-wage`åˆ—ä¸­çš„è¡¨è¾¾å¼è®¡ç®—ä¸ºå®ƒä»¬çš„æ•°å€¼ç­‰ä»·ç‰©ï¼šæˆ‘ä»¬åœ¨è¿™é‡Œä½¿ç”¨è¿™äº›è¡¨è¾¾å¼æ¥å±•ç¤ºæˆ‘ä»¬è¯•å›¾åšä»€ä¹ˆï¼‰ã€‚
- en: Previously, when we have had a computation that we performed multiple times,
    we created a helper function to do the computation.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥å‰ï¼Œå½“æˆ‘ä»¬æœ‰å¤šæ¬¡æ‰§è¡Œçš„è®¡ç®—æ—¶ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªè¾…åŠ©å‡½æ•°æ¥å®Œæˆè®¡ç®—ã€‚
- en: Do Now!
  id: totrans-423
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-424
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Propose a helper function for computing total wages given the hourly wage and
    number of hours worked.
  id: totrans-425
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æå‡ºä¸€ä¸ªè¾…åŠ©å‡½æ•°ï¼Œç”¨äºæ ¹æ®æ—¶è–ªå’Œå·¥æ—¶è®¡ç®—æ€»å·¥èµ„ã€‚
- en: 'Perhaps you came up with something like:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹Ÿè®¸ä½ æå‡ºäº†ç±»ä¼¼ä»¥ä¸‹çš„å†…å®¹ï¼š
- en: '[PRE71]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'which we could use as follows:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥è¿™æ ·ä½¿ç”¨ï¼š
- en: '[PRE72]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This is the right idea, but we can actually have this function do a bit more
    work for us. The `wage` and `hours` values are in cells within the same row. So
    if we could instead get the current row as an input, we could write:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªæ­£ç¡®çš„æƒ³æ³•ï¼Œä½†å®é™…ä¸Šæˆ‘ä»¬å¯ä»¥è®©è¿™ä¸ªå‡½æ•°ä¸ºæˆ‘ä»¬åšæ›´å¤šçš„å·¥ä½œã€‚`wage`å’Œ`hours`å€¼ä½äºåŒä¸€è¡Œçš„å•å…ƒæ ¼ä¸­ã€‚æ‰€ä»¥å¦‚æœæˆ‘ä»¬èƒ½è·å–å½“å‰è¡Œä½œä¸ºè¾“å…¥ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·å†™ï¼š
- en: '[PRE73]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'But now, we are writing calls to `compute-wages` over and over! Adding computed
    columns is a sufficiently common operation that Pyret provides a table function
    called `build-column` for this purpose. We use it by providing the function to
    use to populate values in the new column as an input:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†ç°åœ¨ï¼Œæˆ‘ä»¬ä¸æ–­åœ°åœ¨å†™`compute-wages`çš„è°ƒç”¨ï¼æ·»åŠ è®¡ç®—åˆ—æ˜¯ä¸€ä¸ªè¶³å¤Ÿå¸¸è§çš„æ“ä½œï¼ŒPyretæä¾›äº†ä¸€ä¸ªåä¸º`build-column`çš„è¡¨æ ¼å‡½æ•°æ¥å®Œæˆè¿™ä¸ªç›®çš„ã€‚æˆ‘ä»¬é€šè¿‡æä¾›ç”¨äºå¡«å……æ–°åˆ—å€¼çš„å‡½æ•°ä½œä¸ºè¾“å…¥æ¥ä½¿ç”¨å®ƒï¼š
- en: '[PRE74]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This creates a new column, `total-wage`, whose value in each row is the product
    of the two named columns in that row. Pyret will put the new column at the right
    end.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„åˆ—ï¼Œåä¸º`total-wage`ï¼Œå…¶ä¸­æ¯è¡Œçš„å€¼æ˜¯é‚£ä¸€è¡Œä¸­ä¸¤ä¸ªå‘½ååˆ—çš„ä¹˜ç§¯ã€‚Pyretä¼šå°†æ–°åˆ—æ”¾åœ¨å³ä¾§ã€‚
- en: 4.1.4.4Â Calculating New Column Values[ğŸ”—](#(part._.Calculating_.New_.Column_.Values)
    "Link to here")
  id: totrans-435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.1.4.4 è®¡ç®—æ–°åˆ—å€¼[ğŸ”—](#(part._.Calculating_.New_.Column_.Values) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Sometimes, we just want to calculate new values for an existing column, rather
    than create an entirely new column. Giving raises to employees is one such example.
    Assume we wanted to give a `10%` raise to all employees making less than `20`
    an hour. We could write:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰æ—¶å€™ï¼Œæˆ‘ä»¬åªæƒ³è®¡ç®—ç°æœ‰åˆ—çš„æ–°å€¼ï¼Œè€Œä¸æ˜¯åˆ›å»ºä¸€ä¸ªå…¨æ–°çš„åˆ—ã€‚ç»™å‘˜å·¥åŠ è–ªå°±æ˜¯ä¸€ä¸ªä¾‹å­ã€‚å‡è®¾æˆ‘ä»¬æƒ³è¦ç»™æ¯å°æ—¶å·¥èµ„ä½äº`20`ç¾å…ƒçš„æ‰€æœ‰å‘˜å·¥åŠ `10%`çš„å·¥èµ„ã€‚æˆ‘ä»¬å¯ä»¥è¿™æ ·å†™ï¼š
- en: '[PRE75]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here, `transform-column` takes a table, the name of an existing column in the
    table, and a function to update the value. The updating function takes the current
    value in the column as input and produces the new value for the column as output.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œ`transform-column`æ¥å—ä¸€ä¸ªè¡¨æ ¼ã€è¡¨æ ¼ä¸­ç°æœ‰åˆ—çš„åç§°å’Œä¸€ä¸ªç”¨äºæ›´æ–°å€¼çš„å‡½æ•°ã€‚æ›´æ–°å‡½æ•°æ¥å—åˆ—ä¸­çš„å½“å‰å€¼ä½œä¸ºè¾“å…¥ï¼Œå¹¶äº§ç”Ÿåˆ—çš„æ–°å€¼ä½œä¸ºè¾“å‡ºã€‚
- en: Do Now!
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Run `give-raises` on the `employees` table. What wage will show for `"Miyako"`
    in the `employees` table after `give-raises` completes. Why?
  id: totrans-441
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨`employees`è¡¨ä¸Šè¿è¡Œ`give-raises`ã€‚åœ¨`give-raises`å®Œæˆåï¼Œ`employees`è¡¨ä¸­`"Miyako"`çš„å·¥èµ„æ˜¯å¤šå°‘ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ
- en: Like all other Pyret `Table` operations, `transform-column` produces a new table,
    leaving the original intact. Editing the original table could be problematicâ€“what
    if you made a mistake? How would you recover the original table in that case?
    In general, producing new tables with any modifications, then creating a new name
    for the updated table once you have the one you want, is a less error-prone way
    of working with datasets.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸æ‰€æœ‰å…¶ä»–Pyret `Table`æ“ä½œä¸€æ ·ï¼Œ`transform-column`äº§ç”Ÿä¸€ä¸ªæ–°çš„è¡¨æ ¼ï¼Œè€Œä¿ç•™åŸå§‹è¡¨æ ¼ä¸å˜ã€‚ç¼–è¾‘åŸå§‹è¡¨æ ¼å¯èƒ½ä¼šæœ‰é—®é¢˜â€”â€”å¦‚æœä½ çŠ¯äº†é”™è¯¯æ€ä¹ˆåŠï¼Ÿåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½ å¦‚ä½•æ¢å¤åŸå§‹è¡¨æ ¼ï¼Ÿä¸€èˆ¬æ¥è¯´ï¼Œåœ¨ä¿®æ”¹åäº§ç”Ÿæ–°çš„è¡¨æ ¼ï¼Œç„¶ååœ¨å¾—åˆ°ä½ æƒ³è¦çš„è¡¨æ ¼åä¸ºæ›´æ–°åçš„è¡¨æ ¼åˆ›å»ºä¸€ä¸ªæ–°çš„åç§°ï¼Œè¿™æ˜¯ä¸€ç§æ›´ä¸å®¹æ˜“å‡ºé”™åœ°å¤„ç†æ•°æ®é›†çš„æ–¹æ³•ã€‚
- en: 4.1.5Â Examples for Table-Producing Functions[ğŸ”—](#(part._.Examples_for_.Table-.Producing_.Functions)
    "Link to here")
  id: totrans-443
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.5 è¡¨æ ¼ç”Ÿæˆå‡½æ•°ç¤ºä¾‹[ğŸ”—](#(part._.Examples_for_.Table-.Producing_.Functions) "é“¾æ¥åˆ°æ­¤å¤„")
- en: How do we write examples for functions that produce tables? Conceptually, the
    answer is simply "make sure you got the output table that you expected". Logistically,
    writing examples for table functions seems more painful because writing out an
    expected output tables is more work than simply writing the output of a function
    that produces numbers or strings. What can we do to manage that complexity?
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•ä¸ºç”Ÿæˆè¡¨çš„å‡½æ•°ç¼–å†™ç¤ºä¾‹ï¼Ÿä»æ¦‚å¿µä¸Šè®²ï¼Œç­”æ¡ˆæ˜¯â€œç¡®ä¿ä½ å¾—åˆ°äº†é¢„æœŸçš„è¾“å‡ºè¡¨â€ã€‚ä»å®é™…æ“ä½œæ¥çœ‹ï¼Œç¼–å†™è¡¨å‡½æ•°çš„ç¤ºä¾‹ä¼¼ä¹æ›´ç—›è‹¦ï¼Œå› ä¸ºç¼–å†™é¢„æœŸçš„è¾“å‡ºè¡¨æ¯”ç¼–å†™ç”Ÿæˆæ•°å­—æˆ–å­—ç¬¦ä¸²çš„å‡½æ•°çš„è¾“å‡ºè¦è´¹åŠ²ã€‚æˆ‘ä»¬èƒ½åšäº›ä»€ä¹ˆæ¥ç®¡ç†è¿™ç§å¤æ‚æ€§ï¼Ÿ
- en: Do Now!
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How might you write the `where` block for `give-raises`?
  id: totrans-447
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ ä¼šå¦‚ä½•ç¼–å†™`where`å—ä¸º`give-raises`ï¼Ÿ
- en: 'Here are some ideas for writing the examples practically:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€äº›å®é™…ç¼–å†™ç¤ºä¾‹çš„æƒ³æ³•ï¼š
- en: 'Simplify the input table. Rather than work with a large table with all of the
    columns you have, create a small table that has sufficient variety only in the
    columns that the function uses. For our example, we might use:'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç®€åŒ–è¾“å…¥è¡¨ã€‚ä¸å…¶å¤„ç†åŒ…å«æ‰€æœ‰åˆ—çš„å¤§è¡¨ï¼Œä¸å¦‚åˆ›å»ºä¸€ä¸ªåªæœ‰å‡½æ•°ä½¿ç”¨çš„åˆ—æœ‰è¶³å¤Ÿå¤šæ ·æ€§çš„å°è¡¨ã€‚åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å¯èƒ½ä½¿ç”¨ï¼š
- en: '[PRE76]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Do Now!
  id: totrans-451
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-452
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Would any table with a column of numbers work here? Or are there some constraints
    on the rows or columns of the table?
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä»»ä½•æœ‰æ•°å­—åˆ—çš„è¡¨éƒ½é€‚ç”¨å—ï¼Ÿæˆ–è€…è¡¨è¡Œæˆ–åˆ—æœ‰ä¸€äº›çº¦æŸå—ï¼Ÿ
- en: The only constraint is that your input table has to have the column names used
    in your function.
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å”¯ä¸€çš„çº¦æŸæ˜¯æ‚¨çš„è¾“å…¥è¡¨å¿…é¡»ä½¿ç”¨æ‚¨å‡½æ•°ä¸­ä½¿ç”¨çš„åˆ—åã€‚
- en: Remember that you can write computations in the code to construct tables. This
    saves you from doing calculations by hand.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è®°ä½ï¼Œä½ å¯ä»¥åœ¨ä»£ç ä¸­ç¼–å†™è®¡ç®—æ¥æ„å»ºè¡¨æ ¼ã€‚è¿™å¯ä»¥è®©ä½ å…äºæ‰‹åŠ¨è®¡ç®—ã€‚
- en: '[PRE77]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This example shows that you can write an output table directly in the `where:`
    block â€“ the table doesnâ€™t need to be named outside the function.
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: è¿™ä¸ªç¤ºä¾‹è¡¨æ˜ï¼Œä½ å¯ä»¥åœ¨`where:`å—ä¸­ç›´æ¥ç¼–å†™è¾“å‡ºè¡¨â€”â€”è¡¨ä¸éœ€è¦åœ¨å‡½æ•°å¤–éƒ¨å‘½åã€‚
- en: 'Create a new table by taking rows from an existing table. If you were instead
    writing examples for a function that involves filtering out rows of a table, it
    helps to know how to create a new table using rows of an existing one. For example,
    if we were writing a function to find all rows in which employees were working
    exactly 40 hours, weâ€™d like to make sure that the resulting table had the first
    and fourth rows of the `employees` table. Rather than write a new `table` expression
    to create that table, we could write it as follows:'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: é€šè¿‡ä»ç°æœ‰è¡¨ä¸­å–è¡Œæ¥åˆ›å»ºä¸€ä¸ªæ–°è¡¨ã€‚å¦‚æœä½ åœ¨ç¼–å†™æ¶‰åŠè¿‡æ»¤è¡¨è¡Œçš„ä¸€ä¸ªå‡½æ•°çš„ç¤ºä¾‹ï¼Œäº†è§£å¦‚ä½•ä½¿ç”¨ç°æœ‰è¡¨çš„è¡Œåˆ›å»ºæ–°è¡¨å¾ˆæœ‰å¸®åŠ©ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬ç¼–å†™ä¸€ä¸ªæŸ¥æ‰¾å‘˜å·¥æ°å¥½å·¥ä½œ40å°æ—¶çš„å‡½æ•°ï¼Œæˆ‘ä»¬å¸Œæœ›ç¡®ä¿ç»“æœè¡¨åŒ…å«`employees`è¡¨çš„ç¬¬ä¸€è¡Œå’Œç¬¬å››è¡Œã€‚è€Œä¸æ˜¯ç¼–å†™ä¸€ä¸ªæ–°çš„`table`è¡¨è¾¾å¼æ¥åˆ›å»ºè¯¥è¡¨ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·å†™ï¼š
- en: '[PRE78]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Here, `employees.empty()` creates a new, empty table with the same column headers
    as `employees`. Weâ€™ve already seen how `row-n` extracts a row from a table. The
    `add-row` function places the given row at the end of the given table.
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œ`employees.empty()`åˆ›å»ºäº†ä¸€ä¸ªå…·æœ‰ä¸`employees`ç›¸åŒåˆ—æ ‡é¢˜çš„æ–°ç©ºè¡¨ã€‚æˆ‘ä»¬å·²ç»çœ‹åˆ°äº†å¦‚ä½•ä½¿ç”¨`row-n`ä»è¡¨ä¸­æå–è¡Œã€‚`add-row`å‡½æ•°å°†æŒ‡å®šçš„è¡Œæ”¾ç½®åœ¨ç»™å®šè¡¨çš„æœ«å°¾ã€‚
- en: 'Another tip to keep in mind: when the only thing your function does is call
    a built-in function like `transform-column` it usually suffices to write examples
    for the function you wrote to compute the new column value. It is only when your
    code is combining table operations, or doing more complex processing than a single
    call to a built-in table operation that you really need to present your own examples
    to a reader of your code.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€ä¸ªéœ€è¦æ³¨æ„çš„æŠ€å·§æ˜¯ï¼šå½“ä½ çš„å‡½æ•°åªåšè°ƒç”¨å†…ç½®å‡½æ•°ï¼ˆå¦‚`transform-column`ï¼‰çš„äº‹æƒ…æ—¶ï¼Œé€šå¸¸åªéœ€è¦ä¸ºç¼–å†™è®¡ç®—æ–°åˆ—å€¼çš„å‡½æ•°ç¼–å†™ç¤ºä¾‹ã€‚åªæœ‰å½“ä½ çš„ä»£ç ç»“åˆè¡¨æ“ä½œï¼Œæˆ–è€…æ‰§è¡Œæ¯”å•ä¸ªå†…ç½®è¡¨æ“ä½œæ›´å¤æ‚çš„å¤„ç†æ—¶ï¼Œä½ æ‰çœŸæ­£éœ€è¦å‘ä½ çš„ä»£ç è¯»è€…å±•ç¤ºè‡ªå·±çš„ç¤ºä¾‹ã€‚
- en: '4.1.6Â Lambda: Anonymous Functions[ğŸ”—](#(part._sec~3alambda-tables) "Link to
    here")'
  id: totrans-462
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.6 Lambdaï¼šåŒ¿åå‡½æ•°[ğŸ”—](#(part._sec~3alambda-tables) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Letâ€™s revisit the program we wrote in [Finding Rows](#%28part._subsec~3afinding-rows%29)
    for finding all of the months in a table with fewer than 1000 riders:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹åœ¨[æŸ¥æ‰¾è¡Œ](#%28part._subsec~3afinding-rows%29)ä¸­ç¼–å†™çš„ç¨‹åºï¼Œç”¨äºæŸ¥æ‰¾è¡¨ä¸­å°‘äº1000åä¹˜å®¢çš„æ‰€æœ‰æœˆä»½ï¼š
- en: '[PRE79]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This program might feel a bit verbose: do we really need to write a helper
    function just to perform something as simple as a `filter-with`? Wouldnâ€™t it be
    easier to just write something like:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªç¨‹åºå¯èƒ½æ„Ÿè§‰æœ‰ç‚¹å†—é•¿ï¼šæˆ‘ä»¬çœŸçš„éœ€è¦ç¼–å†™ä¸€ä¸ªè¾…åŠ©å‡½æ•°æ¥æ‰§è¡Œåƒ`filter-with`è¿™æ ·ç®€å•çš„äº‹æƒ…å—ï¼Ÿç›´æ¥å†™ç‚¹åƒè¿™æ ·çš„äº‹æƒ…ä¸æ˜¯æ›´å®¹æ˜“å—ï¼Ÿ
- en: '[PRE80]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Do Now!
  id: totrans-467
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-468
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What will Pyret produce if you run this expression?
  id: totrans-469
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœä½ è¿è¡Œè¿™ä¸ªè¡¨è¾¾å¼ï¼ŒPyretä¼šç”Ÿæˆä»€ä¹ˆï¼Ÿ
- en: Pyret will produce an `unbound identifier` error around the use of `r` in this
    expression. What is `r`? We mean for `r` to be the elements from `shuttle` in
    turn. Conceptually, thatâ€™s what `filter-with` does, but we donâ€™t have the mechanics
    right. When we call a function, we evaluate the arguments before the body of the
    function. Hence, the error regarding `r` being unbound. The whole point of the
    `below-1K` helper function is to make `r` a parameter to a function whose body
    is only evaluated once a value for `r` is available.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: Pyretå°†åœ¨è¯¥è¡¨è¾¾å¼ä¸­ä½¿ç”¨`r`æ—¶äº§ç”Ÿä¸€ä¸ª`æœªç»‘å®šæ ‡è¯†ç¬¦`é”™è¯¯ã€‚`r`æ˜¯ä»€ä¹ˆï¼Ÿæˆ‘ä»¬å¸Œæœ›`r`ä¾æ¬¡æ˜¯`shuttle`ä¸­çš„å…ƒç´ ã€‚ä»æ¦‚å¿µä¸Šè®²ï¼Œè¿™æ­£æ˜¯`filter-with`æ‰€åšçš„äº‹æƒ…ï¼Œä½†æˆ‘ä»¬æ²¡æœ‰æ­£ç¡®åœ°å¤„ç†æœºåˆ¶ã€‚å½“æˆ‘ä»¬è°ƒç”¨ä¸€ä¸ªå‡½æ•°æ—¶ï¼Œæˆ‘ä»¬ä¼šåœ¨å‡½æ•°çš„ä¸»ä½“ä¹‹å‰è¯„ä¼°å‚æ•°ã€‚å› æ­¤ï¼Œå…³äº`r`æœªç»‘å®šçš„é”™è¯¯ã€‚`below-1K`è¾…åŠ©å‡½æ•°çš„å…¨éƒ¨ç›®çš„å°±æ˜¯è®©`r`æˆä¸ºå‡½æ•°çš„å‚æ•°ï¼Œè¯¥å‡½æ•°çš„ä¸»ä½“åªæœ‰åœ¨`r`çš„å€¼å¯ç”¨æ—¶æ‰ä¼šè¢«è¯„ä¼°ã€‚
- en: 'To tighten the notation as in the one-line `filter-with` expression, then,
    we have to find a way to tell Pyret to make a temporary function that will get
    its inputs once `filter-with` is running. The following notation achieves this:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ä½¿ç¬¦å·æ›´åŠ ç´§å‡‘ï¼Œå°±åƒåœ¨ä¸€è¡Œ`filter-with`è¡¨è¾¾å¼ä¸­é‚£æ ·ï¼Œæˆ‘ä»¬å¿…é¡»æ‰¾åˆ°ä¸€ç§æ–¹æ³•è®©Pyretåˆ›å»ºä¸€ä¸ªä¸´æ—¶å‡½æ•°ï¼Œè¯¥å‡½æ•°å°†åœ¨`filter-with`è¿è¡Œæ—¶è·å–å…¶è¾“å…¥ã€‚ä¸‹é¢çš„ç¬¦å·å®ç°äº†è¿™ä¸€ç‚¹ï¼š
- en: '[PRE81]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We have added `lam(r)` and `end` around the expression that we want to use in
    the `filter-with`. The `lam(r)` says "make a temporary function that takes `r`
    as an input". The `end` serves to end the function definition, as when we use
    `fun`. `lam` is short for `lambda`, a form of function definition that exists
    in many, though not all, languages.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨`filter-with`ä¸­æƒ³è¦ä½¿ç”¨çš„è¡¨è¾¾å¼å‘¨å›´æ·»åŠ äº†`lam(r)`å’Œ`end`ã€‚`lam(r)`è¡¨ç¤ºâ€œåˆ›å»ºä¸€ä¸ªä»¥`r`ä¸ºè¾“å…¥çš„ä¸´æ—¶å‡½æ•°â€ã€‚`end`çš„ä½œç”¨æ˜¯ç»“æŸå‡½æ•°å®šä¹‰ï¼Œå°±åƒæˆ‘ä»¬ä½¿ç”¨`fun`æ—¶ä¸€æ ·ã€‚`lam`æ˜¯`lambda`çš„ç®€ç§°ï¼Œè¿™æ˜¯ä¸€ç§å­˜åœ¨äºè®¸å¤šè¯­è¨€ä¸­ï¼ˆå°½ç®¡ä¸æ˜¯æ‰€æœ‰è¯­è¨€ï¼‰çš„å‡½æ•°å®šä¹‰å½¢å¼ã€‚
- en: 'The main difference between our original expression (using the `below-1K` helper)
    and this new one (using `lam`) can be seen through the program directory. To explain
    this, a little detail about how `filter-with` is defined under the hood. In part,
    it looks like:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åŸå§‹è¡¨è¾¾å¼ï¼ˆä½¿ç”¨`below-1K`è¾…åŠ©å‡½æ•°ï¼‰å’Œè¿™ä¸ªæ–°è¡¨è¾¾å¼ï¼ˆä½¿ç”¨`lam`ï¼‰ä¹‹é—´çš„ä¸»è¦åŒºåˆ«å¯ä»¥é€šè¿‡ç¨‹åºç›®å½•æ¥è§‚å¯Ÿã€‚ä¸ºäº†è§£é‡Šè¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦äº†è§£ä¸€ä¸‹`filter-with`åœ¨åº•å±‚æ˜¯å¦‚ä½•å®šä¹‰çš„ã€‚éƒ¨åˆ†åœ°ï¼Œå®ƒçœ‹èµ·æ¥åƒï¼š
- en: '[PRE82]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Whether we pass `below-1K` or the `lam` version to `filter-with`, the `keep`
    parameter ends up referring to a function with the same parameter and body. Since
    the function is only actually called through the `keep` name, it doesnâ€™t matter
    whether or not a name is associated with it when it is initially defined.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: æ— è®ºæˆ‘ä»¬ä¼ é€’`below-1K`è¿˜æ˜¯`lam`ç‰ˆæœ¬ç»™`filter-with`ï¼Œ`keep`å‚æ•°æœ€ç»ˆéƒ½ä¼šæŒ‡å‘ä¸€ä¸ªå…·æœ‰ç›¸åŒå‚æ•°å’Œä¸»ä½“çš„å‡½æ•°ã€‚ç”±äºå‡½æ•°å®é™…ä¸Šæ˜¯é€šè¿‡`keep`åç§°è°ƒç”¨çš„ï¼Œå› æ­¤å½“å®ƒæœ€åˆå®šä¹‰æ—¶æ˜¯å¦ä¸åç§°ç›¸å…³è”å¹¶ä¸é‡è¦ã€‚
- en: In practice, we use `lam` when we have to pass simple (single line) functions
    to operations like `filter-with` (or `transform-column`, `build-column`, etc).
    Of course, you can continue to write out names for helper functions as we did
    with `below-1K` if that makes more sense to you.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å®è·µä¸­ï¼Œå½“æˆ‘ä»¬éœ€è¦å°†ç®€å•çš„ï¼ˆå•è¡Œï¼‰å‡½æ•°ä¼ é€’ç»™`filter-with`ï¼ˆæˆ–`transform-column`ã€`build-column`ç­‰ï¼‰è¿™æ ·çš„æ“ä½œæ—¶ï¼Œæˆ‘ä»¬ä¼šä½¿ç”¨`lam`ã€‚å½“ç„¶ï¼Œå¦‚æœä½ è§‰å¾—è¿™æ ·æ›´æœ‰æ„ä¹‰ï¼Œä½ ä»ç„¶å¯ä»¥åƒæˆ‘ä»¬å¯¹`below-1K`æ‰€åšçš„é‚£æ ·ï¼Œä¸ºè¾…åŠ©å‡½æ•°å†™å‡ºåç§°ã€‚
- en: Exercise
  id: totrans-478
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-479
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write the program to add 10 riders to each row in the `shuttle` table above,
    using `lam` rather than a named helper-function.
  id: totrans-480
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ç¨‹åºï¼Œä½¿ç”¨`lam`è€Œä¸æ˜¯å‘½åçš„è¾…åŠ©å‡½æ•°ï¼Œå‘ä¸Šé¢çš„`shuttle`è¡¨ä¸­çš„æ¯ä¸€è¡Œæ·»åŠ 10åä¹˜å®¢ã€‚
