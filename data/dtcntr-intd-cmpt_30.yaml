- en: 10.1Â Introduction to PandasğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.1Â Pandas ç®€ä»‹ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/python-tables-Pandas.html](https://dcic-world.org/2025-08-27/python-tables-Pandas.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/python-tables-Pandas.html](https://dcic-world.org/2025-08-27/python-tables-Pandas.html)
- en: '| Â Â Â Â [10.1.1Â Pandas Table Basics](#%28part._.Pandas_.Table_.Basics%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   [10.1.1Â Pandas è¡¨åŸºç¡€](#%28part._.Pandas_.Table_.Basics%29) |'
- en: '| Â Â Â Â Â Â [10.1.1.1Â Core Datatypes: DataFrame and Series](#%28part._.Core_.Datatypes__.Data.Frame_and_.Series%29)
    |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|   [10.1.1.1Â æ ¸å¿ƒæ•°æ®ç±»å‹ï¼šDataFrame å’Œ Series](#%28part._.Core_.Datatypes__.Data.Frame_and_.Series%29)
    |'
- en: '| Â Â Â Â Â Â [10.1.1.2Â Creating and Loading DataFrames](#%28part._.Creating_and_.Loading_.Data.Frames%29)
    |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|   [10.1.1.2Â åˆ›å»ºå’ŒåŠ è½½æ•°æ®å¸§](#%28part._.Creating_and_.Loading_.Data.Frames%29) |'
- en: '| Â Â Â Â Â Â [10.1.1.3Â Using Labels and Indices to Access Cells](#%28part._.Using_.Labels_and_.Indices_to_.Access_.Cells%29)
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|   [10.1.1.3Â ä½¿ç”¨æ ‡ç­¾å’Œç´¢å¼•è®¿é—®å•å…ƒæ ¼](#%28part._.Using_.Labels_and_.Indices_to_.Access_.Cells%29)
    |'
- en: '| Â Â Â Â [10.1.2Â Filtering Rows](#%28part._.Filtering_.Rows%29) |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|   [10.1.2Â è¿‡æ»¤è¡Œ](#%28part._.Filtering_.Rows%29) |'
- en: '| Â Â Â Â [10.1.3Â Cleaning and Normalizing Data](#%28part._.Cleaning_and_.Normalizing_.Data%29)
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|   [10.1.3Â æ¸…ç†å’Œè§„èŒƒåŒ–æ•°æ®](#%28part._.Cleaning_and_.Normalizing_.Data%29) |'
- en: '| Â Â Â Â Â Â [10.1.3.1Â Clearing out unknown values](#%28part._.Clearing_out_unknown_values%29)
    |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|   [10.1.3.1Â æ¸…é™¤æœªçŸ¥å€¼](#%28part._.Clearing_out_unknown_values%29) |'
- en: '| Â Â Â Â Â Â [10.1.3.2Â Repairing Values and Column Types](#%28part._.Repairing_.Values_and_.Column_.Types%29)
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|   [10.1.3.2Â ä¿®å¤å€¼å’Œåˆ—ç±»å‹](#%28part._.Repairing_.Values_and_.Column_.Types%29)
    |'
- en: '| Â Â Â Â [10.1.4Â Computing New Columns](#%28part._.Computing_.New_.Columns%29)
    |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|   [10.1.4Â è®¡ç®—æ–°åˆ—](#%28part._.Computing_.New_.Columns%29) |'
- en: '| Â Â Â Â [10.1.5Â Aggregating and Grouping Columns](#%28part._.Aggregating_and_.Grouping_.Columns%29)
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|   [10.1.5Â èšåˆå’Œåˆ†ç»„åˆ—](#%28part._.Aggregating_and_.Grouping_.Columns%29) |'
- en: '| Â Â Â Â [10.1.6Â Wide Versus Tall Data](#%28part._.Wide_.Versus_.Tall_.Data%29)
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|   [10.1.6Â å®½è¡¨ä¸é•¿è¡¨](#%28part._.Wide_.Versus_.Tall_.Data%29) |'
- en: '| Â Â Â Â Â Â [Converting Between Wide and Tall Data](#%28part._.Converting_.Between_.Wide_and_.Tall_.Data%29)
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|   [åœ¨å®½è¡¨å’Œé•¿è¡¨ä¹‹é—´è½¬æ¢](#%28part._.Converting_.Between_.Wide_and_.Tall_.Data%29) |'
- en: '| Â Â Â Â [10.1.7Â Plotting Data](#%28part._.Plotting_.Data%29) |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|   [10.1.7Â æ•°æ®ç»˜å›¾](#%28part._.Plotting_.Data%29) |'
- en: '| Â Â Â Â [10.1.8Â Takeaways](#%28part._.Takeaways%29) |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|   [10.1.8Â è¦ç‚¹](#%28part._.Takeaways%29) |'
- en: Now itâ€™s time to transfer what we learned about tables in Pyret over to Python.
    Pandas is a popular package, and youâ€™ll find many tutorial and help sites for
    it online. In general, Python usually provides many ways to approach a given task.
    As such, there are many ways to do common operations in Pandas. We have chosen
    to present a certain collection of ways that align with the concepts as we covered
    them in Pyret.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æ˜¯æ—¶å€™å°†æˆ‘ä»¬åœ¨ Pyret ä¸­å­¦åˆ°çš„å…³äºè¡¨æ ¼çš„çŸ¥è¯†è½¬ç§»åˆ° Python ä¸Šã€‚Pandas æ˜¯ä¸€ä¸ªæµè¡Œçš„åŒ…ï¼Œä½ å¯ä»¥åœ¨ç½‘ä¸Šæ‰¾åˆ°è®¸å¤šå…³äºå®ƒçš„æ•™ç¨‹å’Œå¸®åŠ©ç½‘ç«™ã€‚ä¸€èˆ¬æ¥è¯´ï¼ŒPython
    é€šå¸¸æä¾›å¤šç§æ–¹æ³•æ¥å¤„ç†ç»™å®šçš„ä»»åŠ¡ã€‚å› æ­¤ï¼Œåœ¨ Pandas ä¸­æ‰§è¡Œå¸¸è§æ“ä½œæœ‰è®¸å¤šæ–¹æ³•ã€‚æˆ‘ä»¬é€‰æ‹©å±•ç¤ºä¸€ç³»åˆ—ä¸æˆ‘ä»¬åœ¨ Pyret ä¸­ä»‹ç»çš„æ¦‚å¿µç›¸ç¬¦çš„æ–¹æ³•ã€‚
- en: 'To work in Pandas, youâ€™ll need to include the following line at the top of
    your file:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: è¦åœ¨ Pandas ä¸­å·¥ä½œï¼Œä½ éœ€è¦åœ¨æ–‡ä»¶é¡¶éƒ¨åŒ…å«ä»¥ä¸‹è¡Œï¼š
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 10.1.1Â Pandas Table Basics[ğŸ”—](#(part._.Pandas_.Table_.Basics) "Link to here")
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.1Â Pandas è¡¨åŸºç¡€[ğŸ”—](#(part._.Pandas_.Table_.Basics) "é“¾æ¥åˆ°æ­¤å¤„")
- en: '10.1.1.1Â Core Datatypes: DataFrame and Series[ğŸ”—](#(part._.Core_.Datatypes__.Data.Frame_and_.Series)
    "Link to here")'
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.1.1.1Â æ ¸å¿ƒæ•°æ®ç±»å‹ï¼šDataFrame å’Œ Series[ğŸ”—](#(part._.Core_.Datatypes__.Data.Frame_and_.Series)
    "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Pandas uses the term DataFrame for a table with rows and columns. DataFrames
    are built out of two more basic types:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas ä½¿ç”¨ DataFrame æœ¯è¯­æ¥è¡¨ç¤ºå…·æœ‰è¡Œå’Œåˆ—çš„è¡¨ã€‚DataFrame ç”±ä¸¤ç§æ›´åŸºæœ¬çš„æ•°æ®ç±»å‹æ„å»ºï¼š
- en: An array is a sequence of values that can be accessed by position (e.g., 0,
    1, ... up to one less than the length of the array). Like lists, arrays capture
    a linear (ordered) collection of values. Unlike lists, arrays are created with
    a limit on the number of elements that they contain. In practice, lists are more
    commonly used when elements are frequently added or removed whereas arrays are
    more commonly used when elements frequently get accessed by their position. Nearly
    every programming language offers both lists and arrays; a detailed contrast is
    beyond the scope of this book (this information would be covered in a data structures
    class).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ•°ç»„æ˜¯ä¸€ç³»åˆ—å¯ä»¥é€šè¿‡ä½ç½®è®¿é—®çš„å€¼ï¼ˆä¾‹å¦‚ï¼Œ0ã€1ã€... ç›´åˆ°æ•°ç»„é•¿åº¦å‡ä¸€ï¼‰ã€‚åƒåˆ—è¡¨ä¸€æ ·ï¼Œæ•°ç»„æ•è·äº†ä¸€ä¸ªçº¿æ€§ï¼ˆæœ‰åºï¼‰çš„å€¼é›†åˆã€‚ä¸åˆ—è¡¨ä¸åŒï¼Œæ•°ç»„åˆ›å»ºæ—¶å¯¹å…¶åŒ…å«çš„å…ƒç´ æ•°é‡æœ‰é™åˆ¶ã€‚åœ¨å®è·µä¸­ï¼Œå½“å…ƒç´ ç»å¸¸è¢«æ·»åŠ æˆ–åˆ é™¤æ—¶ï¼Œé€šå¸¸ä½¿ç”¨åˆ—è¡¨ï¼Œè€Œå½“å…ƒç´ ç»å¸¸é€šè¿‡å…¶ä½ç½®è®¿é—®æ—¶ï¼Œé€šå¸¸ä½¿ç”¨æ•°ç»„ã€‚å‡ ä¹æ¯ç§ç¼–ç¨‹è¯­è¨€éƒ½æä¾›åˆ—è¡¨å’Œæ•°ç»„ï¼›è¯¦ç»†çš„å¯¹æ¯”è¶…å‡ºäº†æœ¬ä¹¦çš„èŒƒå›´ï¼ˆè¿™äº›ä¿¡æ¯å°†åœ¨æ•°æ®ç»“æ„è¯¾ç¨‹ä¸­ä»‹ç»ï¼‰ã€‚
- en: A Series is an array in which the positions optionally have labels in addition
    to the position numbers.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç³»åˆ—æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œå…¶ä½ç½®é™¤äº†ä½ç½®æ•°å­—å¤–è¿˜å¯ä»¥æœ‰æ ‡ç­¾ã€‚
- en: In Pandas, a row is a Series in which an array of the cell values is labeled
    with the column headers (this is similar to the â€˜Rowâ€˜ datatype in Pyret). A DataFrame
    is a series of these rows.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Pandas ä¸­ï¼Œè¡Œæ˜¯ä¸€ä¸ªå¸¦æœ‰åˆ—æ ‡é¢˜æ ‡ç­¾çš„å€¼æ•°ç»„çš„ Seriesï¼ˆè¿™ç±»ä¼¼äº Pyret ä¸­çš„â€˜Rowâ€™æ•°æ®ç±»å‹ï¼‰ã€‚DataFrame æ˜¯è¿™äº›è¡Œçš„åºåˆ—ã€‚
- en: 10.1.1.2Â Creating and Loading DataFrames[ğŸ”—](#(part._.Creating_and_.Loading_.Data.Frames)
    "Link to here")
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.1.1.2 åˆ›å»ºå’ŒåŠ è½½ DataFrames[ğŸ”—](#(part._.Creating_and_.Loading_.Data.Frames) "é“¾æ¥è‡³æ­¤")
- en: 'DataFrames can be created manually or loaded in from a file, as we did in Pyret.
    Hereâ€™s a simple example of creating one by hand:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrames å¯ä»¥æ‰‹åŠ¨åˆ›å»ºæˆ–ä»æ–‡ä»¶ä¸­åŠ è½½ï¼Œå°±åƒæˆ‘ä»¬åœ¨ Pyret ä¸­åšçš„é‚£æ ·ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªæ‰‹åŠ¨åˆ›å»º DataFrame çš„ç®€å•ç¤ºä¾‹ï¼š
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`data` is a dictionary that maps column names to values. Calling `pd.DataFrame`
    creates a DataFrame from the dictionary. (There are other ways to create DataFrames
    manually which you can find by searching online.)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`data` æ˜¯ä¸€ä¸ªå°†åˆ—åæ˜ å°„åˆ°å€¼çš„å­—å…¸ã€‚è°ƒç”¨ `pd.DataFrame` ä»å­—å…¸ä¸­åˆ›å»º DataFrameã€‚ï¼ˆè¿˜æœ‰å…¶ä»–æ‰‹åŠ¨åˆ›å»º DataFrame
    çš„æ–¹æ³•ï¼Œæ‚¨å¯ä»¥é€šè¿‡åœ¨çº¿æœç´¢æ‰¾åˆ°å®ƒä»¬ã€‚ï¼‰'
- en: 'To load a DataFrame from a CSV file, you need either the path to the file on
    your computer or the url where you can get the CSV file online. Hereâ€™s an example
    of the url version. In this example, we have the following CSV contents and we
    want to change the header names when loading the file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: è¦ä» CSV æ–‡ä»¶åŠ è½½ DataFrameï¼Œæ‚¨éœ€è¦è®¡ç®—æœºä¸Šæ–‡ä»¶çš„è·¯å¾„æˆ–å¯ä»¥åœ¨çº¿è·å– CSV æ–‡ä»¶çš„ URLã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ª URL ç‰ˆæœ¬çš„ç¤ºä¾‹ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬æœ‰ä»¥ä¸‹
    CSV å†…å®¹ï¼Œå¹¶ä¸”æˆ‘ä»¬å¸Œæœ›åœ¨åŠ è½½æ–‡ä»¶æ—¶æ›´æ”¹æ ‡é¢˜åç§°ï¼š
- en: The following `read_csv` command says that the CSV file is at `url`, that there
    are headers in the first row (numbered `0`), and that we want to use the values
    in `names` as the column labels (this will ignore whatever might be in the header
    row in the CSV file).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹ `read_csv` å‘½ä»¤è¡¨ç¤º CSV æ–‡ä»¶ä½äº `url`ï¼Œç¬¬ä¸€è¡Œæœ‰æ ‡é¢˜ï¼ˆç¼–å·ä¸º `0`ï¼‰ï¼Œå¹¶ä¸”æˆ‘ä»¬å¸Œæœ›ä½¿ç”¨ `names` ä¸­çš„å€¼ä½œä¸ºåˆ—æ ‡ç­¾ï¼ˆè¿™å°†å¿½ç•¥
    CSV æ–‡ä»¶æ ‡é¢˜è¡Œä¸­å¯èƒ½å­˜åœ¨çš„ä»»ä½•å†…å®¹ï¼‰ã€‚
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we wanted to use the headers in the CSV file as the column headers, we would
    leave out the `names=[...]` part. If the CSV had no header row, we would write
    `header=None` instead of `header=0`. (There are many more configuration options
    in the [Pandas documentation](https://Pandas.pydata.org/docs/reference/api/Pandas.read_csv.html),
    but you wonâ€™t need them for the examples in this book.)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æƒ³ä½¿ç”¨ CSV æ–‡ä»¶ä¸­çš„æ ‡é¢˜ä½œä¸ºåˆ—æ ‡é¢˜ï¼Œæˆ‘ä»¬å°†çœç•¥ `names=[...]` éƒ¨åˆ†ã€‚å¦‚æœ CSV æ²¡æœ‰æ ‡é¢˜è¡Œï¼Œæˆ‘ä»¬å°†å†™ `header=None`
    è€Œä¸æ˜¯ `header=0`ã€‚ï¼ˆPandas æ–‡æ¡£ä¸­æœ‰è®¸å¤šå…¶ä»–é…ç½®é€‰é¡¹ï¼Œä¾‹å¦‚ [Pandas æ–‡æ¡£](https://Pandas.pydata.org/docs/reference/api/Pandas.read_csv.html)ï¼Œä½†æ‚¨ä¸éœ€è¦å®ƒä»¬æ¥å¤„ç†æœ¬ä¹¦ä¸­çš„ç¤ºä¾‹ã€‚ï¼‰
- en: 'Conceptually, the loaded DataFrame is as follows, with the labels shown in
    blue and the indicies (positions) show in yellow:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ä»æ¦‚å¿µä¸Šè®²ï¼ŒåŠ è½½çš„ DataFrame å¦‚ä¸‹æ‰€ç¤ºï¼Œæ ‡ç­¾ä»¥è“è‰²æ˜¾ç¤ºï¼Œç´¢å¼•ï¼ˆä½ç½®ï¼‰ä»¥é»„è‰²æ˜¾ç¤ºï¼š
- en: '![](../Images/d63a7003f02c1f4bfd00ac93817af463.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](../Images/d63a7003f02c1f4bfd00ac93817af463.png)'
- en: Since we did not specify labels for the rows, Pandas has used numeric labels
    by default. At the moment, the positions and the labels are the same for each
    row, but we will see that this is not always the case.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºæˆ‘ä»¬æ²¡æœ‰ä¸ºè¡ŒæŒ‡å®šæ ‡ç­¾ï¼ŒPandas é»˜è®¤ä½¿ç”¨äº†æ•°å­—æ ‡ç­¾ã€‚ç›®å‰ï¼Œæ¯è¡Œçš„ä½ç½®å’Œæ ‡ç­¾æ˜¯ç›¸åŒçš„ï¼Œä½†æˆ‘ä»¬ä¼šçœ‹åˆ°è¿™å¹¶ä¸æ€»æ˜¯å¦‚æ­¤ã€‚
- en: (If you look at the actual loaded table, some of the blank cells in the discount
    column will contain `NaN`, which is the standard Python value for â€œmissing informationâ€.
    We will deal with that information shortly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆå¦‚æœæ‚¨æŸ¥çœ‹å®é™…åŠ è½½çš„è¡¨æ ¼ï¼ŒæŠ˜æ‰£åˆ—ä¸­çš„ä¸€äº›ç©ºç™½å•å…ƒæ ¼å°†åŒ…å« `NaN`ï¼Œè¿™æ˜¯ Python ä¸­â€œç¼ºå¤±ä¿¡æ¯â€çš„æ ‡å‡†å€¼ã€‚æˆ‘ä»¬å°†åœ¨ç¨åå¤„ç†è¿™äº›ä¿¡æ¯ã€‚ï¼‰
- en: 10.1.1.3Â Using Labels and Indices to Access Cells[ğŸ”—](#(part._.Using_.Labels_and_.Indices_to_.Access_.Cells)
    "Link to here")
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.1.1.3 ä½¿ç”¨æ ‡ç­¾å’Œç´¢å¼•è®¿é—®å•å…ƒæ ¼[ğŸ”—](#(part._.Using_.Labels_and_.Indices_to_.Access_.Cells)
    "é“¾æ¥è‡³æ­¤")
- en: 'Rows, columns, and cells can be accessed using either their (numeric) positions
    or their labels. Here are some examples:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: å¯ä»¥ä½¿ç”¨å®ƒä»¬çš„ï¼ˆæ•°å­—ï¼‰ä½ç½®æˆ–æ ‡ç­¾æ¥è®¿é—®è¡Œã€åˆ—å’Œå•å…ƒæ ¼ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›ç¤ºä¾‹ï¼š
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that we used different notation for accessing a cell depending on whether
    we accessed the row first or the column first. This is because we are showing
    you how to access data through either position indices or labels. Using `.loc`
    tells Pandas that you are using a label to access a row. If you want to use the
    position instead, you need to use `iloc` (the `i` stands for â€œintegerâ€). If you
    are using a programmer-supplied label instead, you can just use the label directly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬æ ¹æ®æ˜¯å…ˆè®¿é—®è¡Œè¿˜æ˜¯å…ˆè®¿é—®åˆ—æ¥ä½¿ç”¨ä¸åŒçš„ç¬¦å·æ¥è®¿é—®å•å…ƒæ ¼ã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬æ­£åœ¨å‘æ‚¨å±•ç¤ºå¦‚ä½•é€šè¿‡ä½ç½®ç´¢å¼•æˆ–æ ‡ç­¾è®¿é—®æ•°æ®ã€‚ä½¿ç”¨ `.loc` å‘Šè¯‰ Pandas
    æ‚¨æ­£åœ¨ä½¿ç”¨æ ‡ç­¾æ¥è®¿é—®è¡Œã€‚å¦‚æœæ‚¨æƒ³ä½¿ç”¨ä½ç½®ï¼Œåˆ™éœ€è¦ä½¿ç”¨ `iloc`ï¼ˆ`i` ä»£è¡¨â€œæ•´æ•°â€ï¼‰ã€‚å¦‚æœæ‚¨æ­£åœ¨ä½¿ç”¨ç¨‹åºå‘˜æä¾›çš„æ ‡ç­¾ï¼Œåˆ™å¯ä»¥ç›´æ¥ä½¿ç”¨è¯¥æ ‡ç­¾ã€‚
- en: In a DataFrame, both rows and columns always have position indices and may have
    labels. The `.loc` notation works on either rows or columns, we just happened
    to illustrate the notation on the rows since we had already created labels on
    the columns when we loaded `events`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨DataFrameä¸­ï¼Œè¡Œå’Œåˆ—å§‹ç»ˆéƒ½æœ‰ä½ç½®ç´¢å¼•ï¼Œå¹¶ä¸”å¯èƒ½å…·æœ‰æ ‡ç­¾ã€‚`.loc`è¡¨ç¤ºæ³•é€‚ç”¨äºè¡Œæˆ–åˆ—ï¼Œæˆ‘ä»¬ä¹‹æ‰€ä»¥åœ¨è¡Œä¸Šå±•ç¤ºè¿™ä¸ªè¡¨ç¤ºæ³•ï¼Œæ˜¯å› ä¸ºæˆ‘ä»¬åœ¨åŠ è½½`events`æ—¶å·²ç»åœ¨åˆ—ä¸Šåˆ›å»ºäº†æ ‡ç­¾ã€‚
- en: 10.1.2Â Filtering Rows[ğŸ”—](#(part._.Filtering_.Rows) "Link to here")
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.2 è¿‡æ»¤è¡Œ[ğŸ”—](#(part._.Filtering_.Rows) "é“¾æ¥è‡³æ­¤")
- en: Back in Pyret, we filtered rows from a table by writing a function from `Row`
    to `Boolean`. The `filter-with` function applied that function to every row in
    the table, returning a new table with those rows for which the predicate were
    true.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Pyretä¸­ï¼Œæˆ‘ä»¬é€šè¿‡ç¼–å†™ä¸€ä¸ªä»`Row`åˆ°`Boolean`çš„å‡½æ•°æ¥ä»è¡¨ä¸­è¿‡æ»¤è¡Œã€‚`filter-with`å‡½æ•°å°†æ­¤å‡½æ•°åº”ç”¨äºè¡¨ä¸­çš„æ¯ä¸€è¡Œï¼Œè¿”å›ä¸€ä¸ªæ–°è¡¨ï¼Œå…¶ä¸­åŒ…å«é‚£äº›è°“è¯ä¸ºçœŸçš„è¡Œã€‚
- en: In Pandas, we select rows by providing an array of Booleans that has the same
    length as the number of rows in the DataFrame. Filtering keeps those rows for
    which the corresponding array entry is `True`. For example, hereâ€™s our DataFrame
    diagram from before, this time with an array to the right indicating that we want
    to keep rows 0, 2, and 6.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Pandasä¸­ï¼Œæˆ‘ä»¬é€šè¿‡æä¾›ä¸€ä¸ªä¸DataFrameè¡Œæ•°ç›¸åŒçš„å¸ƒå°”æ•°ç»„æ¥é€‰æ‹©è¡Œã€‚è¿‡æ»¤ä¼šä¿ç•™å¯¹åº”æ•°ç»„æ¡ç›®ä¸º`True`çš„è¡Œã€‚ä¾‹å¦‚ï¼Œè¿™æ˜¯æˆ‘ä»¬çš„DataFrameå›¾ç¤ºï¼Œè¿™æ¬¡åœ¨å³ä¾§æœ‰ä¸€ä¸ªæ•°ç»„ï¼Œè¡¨ç¤ºæˆ‘ä»¬æƒ³è¦ä¿ç•™è¡Œ0ã€2å’Œ6ã€‚
- en: '![](../Images/0958f43b8192439a6fd898de3fbe50fb.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](../Images/0958f43b8192439a6fd898de3fbe50fb.png)'
- en: 'The â€œkeepâ€ array is not part of the DataFrame. Here is the corresponding array
    expressed in code, followed by the notation to use the array to filter the DataFrame:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: â€œä¿ç•™â€æ•°ç»„ä¸æ˜¯DataFrameçš„ä¸€éƒ¨åˆ†ã€‚ä»¥ä¸‹æ˜¯ç›¸åº”çš„ä»£ç è¡¨ç¤ºï¼Œéšåæ˜¯ä½¿ç”¨è¯¥æ•°ç»„æ¥è¿‡æ»¤DataFrameçš„è¡¨ç¤ºæ³•ï¼š
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once we have the array of booleans, we use it to extract a collection of rows
    using similar notation that we previously used to extract a column. Just as we
    wrote `events[''numtix'']` to select the `''numtix''` column, we can write `events[keep]`
    to select a collection of rows. The DataFrame that results from filtering (along
    with the `True` cells of the `keep` array for illustration) appears as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æˆ‘ä»¬æœ‰äº†å¸ƒå°”æ•°ç»„ï¼Œæˆ‘ä»¬å°±ä½¿ç”¨å®ƒæ¥æå–ä¸€ç»„è¡Œï¼Œä½¿ç”¨ä¸ä¹‹å‰ç”¨äºæå–åˆ—ç›¸ä¼¼çš„è¡¨ç¤ºæ³•ã€‚å°±åƒæˆ‘ä»¬å†™`events['numtix']`æ¥é€‰æ‹©`'numtix'`åˆ—ä¸€æ ·ï¼Œæˆ‘ä»¬å¯ä»¥å†™`events[keep]`æ¥é€‰æ‹©ä¸€ç»„è¡Œã€‚è¿‡æ»¤åçš„DataFrameï¼ˆä»¥åŠä¸ºäº†è¯´æ˜è€Œæ˜¾ç¤ºçš„`keep`æ•°ç»„çš„`True`å•å…ƒæ ¼ï¼‰å¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '![](../Images/0baa50e0adf5a889a71a977667d9c7e9.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](../Images/0baa50e0adf5a889a71a977667d9c7e9.png)'
- en: 'How does Pandas know whether we want to select rows or columns? It depends
    on what we provide in the square brackets: if we provide a single label, we get
    the column or row with that label; if we provide an array of booleans, we get
    the rows for which the corresponding row (by position) is `True`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Pandaså¦‚ä½•çŸ¥é“æˆ‘ä»¬æ˜¯è¦é€‰æ‹©è¡Œè¿˜æ˜¯åˆ—ï¼Ÿè¿™å–å†³äºæˆ‘ä»¬åœ¨æ–¹æ‹¬å·ä¸­æä¾›äº†ä»€ä¹ˆï¼šå¦‚æœæˆ‘ä»¬æä¾›ä¸€ä¸ªæ ‡ç­¾ï¼Œæˆ‘ä»¬å°±å¾—åˆ°å…·æœ‰è¯¥æ ‡ç­¾çš„åˆ—æˆ–è¡Œï¼›å¦‚æœæˆ‘ä»¬æä¾›ä¸€ä¸ªå¸ƒå°”æ•°ç»„ï¼Œæˆ‘ä»¬å°±å¾—åˆ°å¯¹åº”è¡Œï¼ˆæŒ‰ä½ç½®ï¼‰ä¸º`True`çš„è¡Œã€‚
- en: Do Now!
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Look at the returned DataFrame. Do you notice anything interesting?
  id: totrans-53
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: çœ‹çœ‹è¿”å›çš„DataFrameã€‚ä½ æ³¨æ„åˆ°ä»€ä¹ˆæœ‰è¶£çš„åœ°æ–¹äº†å—ï¼Ÿ
- en: 'Look at the row labels and indices: the labels have been retained from the
    original DataFrame (0, 2, and 6), while the indices are a sequence of consecutive
    numbers starting from 0\. Having both ways to reference rowsâ€”<wbr>one based on
    raw order and the other based on programmer-provided labelsâ€”<wbr>provides a lot
    of flexibility as we use filter to isolate parts of tables that we want to work
    on.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: çœ‹çœ‹è¡Œæ ‡ç­¾å’Œç´¢å¼•ï¼šæ ‡ç­¾å·²ä»åŸå§‹DataFrameï¼ˆ0ã€2å’Œ6ï¼‰ä¿ç•™ï¼Œè€Œç´¢å¼•æ˜¯ä»0å¼€å§‹çš„è¿ç»­æ•°å­—åºåˆ—ã€‚æ‹¥æœ‰è¿™ä¸¤ç§å¼•ç”¨è¡Œçš„æ–¹å¼â€”â€”åŸºäºåŸå§‹é¡ºåºå’ŒåŸºäºç¨‹åºå‘˜æä¾›çš„æ ‡ç­¾â€”â€”åœ¨æˆ‘ä»¬ä½¿ç”¨è¿‡æ»¤æ¥éš”ç¦»æˆ‘ä»¬æƒ³è¦å·¥ä½œçš„è¡¨çš„éƒ¨åˆ†æ—¶æä¾›äº†å¾ˆå¤§çš„çµæ´»æ€§ã€‚
- en: Do Now!
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does filtering rows this way in Python keep the original `events` DataFrame
    intact? Try it out!
  id: totrans-57
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä»¥è¿™ç§æ–¹å¼åœ¨Pythonä¸­è¿‡æ»¤è¡Œæ˜¯å¦ä¼šä¿æŒåŸå§‹`events` DataFrameçš„å®Œæ•´æ€§ï¼Ÿè¯•ä¸€è¯•ï¼
- en: Arrays of booleans that are used for filtering out other arrays are called masks.
    Here, we have shown a simple mask that we constructed by hand. If we had a long
    DataFrame, however, we would not want to construct a mask for it by hand. Fortunately,
    we donâ€™t have to. Python provides notations that let us construct masks via expressions
    over a series.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ç”¨äºè¿‡æ»¤å…¶ä»–æ•°ç»„çš„å¸ƒå°”æ•°ç»„è¢«ç§°ä¸ºæ©ç ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å±•ç¤ºäº†æˆ‘ä»¬æ‰‹åŠ¨æ„å»ºçš„ä¸€ä¸ªç®€å•æ©ç ã€‚ç„¶è€Œï¼Œå¦‚æœæˆ‘ä»¬æœ‰ä¸€ä¸ªå¾ˆé•¿çš„DataFrameï¼Œæˆ‘ä»¬å°±ä¸æƒ³æ‰‹åŠ¨ä¸ºå®ƒæ„å»ºä¸€ä¸ªæ©ç ã€‚å¹¸è¿çš„æ˜¯ï¼Œæˆ‘ä»¬ä¸å¿…è¿™æ ·åšã€‚Pythonæä¾›äº†é€šè¿‡è¡¨è¾¾å¼æ„å»ºæ©ç çš„ç¬¦å·ã€‚
- en: 'Imagine that we wanted to filter the `events` table down to those rows with
    delivery method `''email''`. To create a mask for this, we first select the delivery
    column as a series:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬æƒ³è¦å°† `events` è¡¨è¿‡æ»¤åˆ°é‚£äº›ä½¿ç”¨ `'email'` äº¤ä»˜æ–¹å¼çš„è¡Œã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬é¦–å…ˆå°†äº¤ä»˜åˆ—ä½œä¸ºä¸€ä¸ªåºåˆ—é€‰æ‹©ï¼š
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we use the series in a boolean expression that states the constraint
    that we want on each element of the series:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬åœ¨å¸ƒå°”è¡¨è¾¾å¼ä¸­ä½¿ç”¨åºåˆ—ï¼Œä»¥è¡¨ç¤ºæˆ‘ä»¬æƒ³è¦å¯¹åºåˆ—ä¸­æ¯ä¸ªå…ƒç´ æ–½åŠ çš„çº¦æŸï¼š
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Wait, whatâ€™s going on here? `events['deliver']` is a Series (a labeled array
    of strings). `'email'` is a string. What does it even mean to ask whether two
    values of different types be considered equal, especially when one has many component
    values and the other does not?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ç­‰ç­‰ï¼Œè¿™é‡Œå‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿ`events['deliver']` æ˜¯ä¸€ä¸ªåºåˆ—ï¼ˆä¸€ä¸ªæ ‡è®°çš„å­—ç¬¦ä¸²æ•°ç»„ï¼‰ã€‚`'email'` æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚è¯¢é—®ä¸¤ä¸ªä¸åŒç±»å‹çš„æ•°æ®å€¼æ˜¯å¦ç›¸ç­‰æœ‰ä»€ä¹ˆæ„ä¹‰ï¼Œå°¤å…¶æ˜¯å½“ä¸€ä¸ªæœ‰å¤šä¸ªç»„ä»¶å€¼è€Œå¦ä¸€ä¸ªæ²¡æœ‰æ—¶ï¼Ÿ
- en: In this case, the `==` doesnâ€™t mean â€œare these equalâ€? Instead, Python applies
    `== 'email'` to every element of the `events['delivery']` Series, constructing
    a new Series of the results. This idea of applying an operation to all elements
    of an array is known as â€œliftingâ€. It is one of the shortcuts that Python provides
    to help experienced programmers do simple common tasks quickly and easily.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ`==` å¹¶ä¸æ„å‘³ç€â€œå®ƒä»¬æ˜¯å¦ç›¸ç­‰â€ï¼Ÿç›¸åï¼ŒPythonå°† `== 'email'` åº”ç”¨åˆ° `events['delivery']` åºåˆ—çš„æ¯ä¸ªå…ƒç´ ä¸Šï¼Œæ„å»ºä¸€ä¸ªæ–°çš„åŒ…å«ç»“æœçš„åºåˆ—ã€‚å°†æ“ä½œåº”ç”¨äºæ•°ç»„æ‰€æœ‰å…ƒç´ çš„è¿™ä¸ªæƒ³æ³•è¢«ç§°ä¸ºâ€œæå‡â€ã€‚è¿™æ˜¯Pythonæä¾›ç»™ç»éªŒä¸°å¯Œçš„ç¨‹åºå‘˜å¿«é€Ÿè½»æ¾å®Œæˆç®€å•å¸¸è§ä»»åŠ¡çš„å¿«æ·æ–¹å¼ä¹‹ä¸€ã€‚
- en: 'Now that we have a Series of booleans (for which events will be picked up by
    email), we can use it to select those rows from the `events` DataFrame:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æœ‰ä¸€ä¸ªå¸ƒå°”åºåˆ—ï¼ˆè¡¨ç¤ºå“ªäº›äº‹ä»¶å°†é€šè¿‡ç”µå­é‚®ä»¶è¢«é€‰ä¸­ï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®ƒæ¥é€‰æ‹© `events` DataFrameä¸­çš„è¿™äº›è¡Œï¼š
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The inner use of `events` is for creating the mask, while the outer one is for
    filtering the table with that mask.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: å†…éƒ¨ä½¿ç”¨ `events` æ˜¯ä¸ºäº†åˆ›å»ºæ©ç ï¼Œè€Œå¤–éƒ¨ä½¿ç”¨æ˜¯ä¸ºäº†ä½¿ç”¨è¯¥æ©ç è¿‡æ»¤è¡¨æ ¼ã€‚
- en: 'As a warning: if you search online for information on how to filter or process
    DataFrame, you might find code samples that do this using for loops. While that
    approach works, it isnâ€™t considered good Pandas (or general programming) practice.
    Most modern languages provide built-in constructs for iterating over lists and
    other sequence-style data. These operations have more descriptive names than generic
    loops (which makes them easier for other programmers to read), and are often engineered
    to run more efficiently under the hood. As a general rule, only default to basic
    loops if there is no built-in operator to do the computation that you have in
    mind.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºè­¦å‘Šï¼šå¦‚æœä½ åœ¨ç½‘ä¸Šæœç´¢æœ‰å…³å¦‚ä½•è¿‡æ»¤æˆ–å¤„ç†DataFrameçš„ä¿¡æ¯ï¼Œä½ å¯èƒ½ä¼šæ‰¾åˆ°ä½¿ç”¨forå¾ªç¯æ¥å®Œæˆæ­¤æ“ä½œçš„ä»£ç ç¤ºä¾‹ã€‚è™½ç„¶è¿™ç§æ–¹æ³•å¯è¡Œï¼Œä½†å¹¶ä¸è¢«è®¤ä¸ºæ˜¯å¥½çš„Pandasï¼ˆæˆ–é€šç”¨ç¼–ç¨‹ï¼‰å®è·µã€‚å¤§å¤šæ•°ç°ä»£è¯­è¨€éƒ½æä¾›äº†éå†åˆ—è¡¨å’Œå…¶ä»–åºåˆ—å¼æ•°æ®çš„å†…ç½®æ„é€ ã€‚è¿™äº›æ“ä½œæ¯”é€šç”¨å¾ªç¯æœ‰æ›´å…·æè¿°æ€§çš„åç§°ï¼ˆè¿™ä½¿å¾—å…¶ä»–ç¨‹åºå‘˜æ›´å®¹æ˜“é˜…è¯»ï¼‰ï¼Œå¹¶ä¸”é€šå¸¸åœ¨åº•å±‚è¿è¡Œå¾—æ›´é«˜æ•ˆã€‚ä¸€èˆ¬æ¥è¯´ï¼Œåªæœ‰åœ¨ä½ æ²¡æœ‰å†…ç½®è¿ç®—ç¬¦æ¥å®Œæˆä½ å¿ƒä¸­çš„è®¡ç®—æ—¶ï¼Œæ‰é»˜è®¤ä½¿ç”¨åŸºæœ¬å¾ªç¯ã€‚
- en: 10.1.3Â Cleaning and Normalizing Data[ğŸ”—](#(part._.Cleaning_and_.Normalizing_.Data)
    "Link to here")
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.3 æ¸…ç†å’Œå½’ä¸€åŒ–æ•°æ®[ğŸ”—](#(part._.Cleaning_and_.Normalizing_.Data) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'The same operator-lifting idea that we just saw when creating masks from DataFrames
    also comes into play for normalizing data. Recall that when we worked with the
    `events` table in Pyret, we converted all of the discount codes to lowercase.
    Hereâ€™s the code that does this in Pandas:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åˆšæ‰åœ¨ä»DataFrameåˆ›å»ºæ©ç æ—¶çœ‹åˆ°çš„ç›¸åŒçš„æ“ä½œæå‡æƒ³æ³•ä¹Ÿé€‚ç”¨äºæ•°æ®å½’ä¸€åŒ–ã€‚å›æƒ³ä¸€ä¸‹ï¼Œå½“æˆ‘ä»¬ä½¿ç”¨Pyretå¤„ç† `events` è¡¨æ—¶ï¼Œæˆ‘ä»¬å°†æ‰€æœ‰æŠ˜æ‰£ä»£ç è½¬æ¢ä¸ºå°å†™ã€‚ä»¥ä¸‹æ˜¯Pandasä¸­æ‰§è¡Œæ­¤æ“ä½œçš„ä»£ç ï¼š
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Do Now!
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Look at the above code. Break it down and try to articulate what each part does.
    Do any parts seem new or different from things weâ€™ve done so far in Pandas?
  id: totrans-74
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: çœ‹çœ‹ä¸Šé¢çš„ä»£ç ã€‚å°†å…¶åˆ†è§£å¹¶å°è¯•é˜è¿°æ¯ä¸ªéƒ¨åˆ†çš„ä½œç”¨ã€‚æ˜¯å¦æœ‰ä»»ä½•éƒ¨åˆ†çœ‹èµ·æ¥æ˜¯æ–°çš„æˆ–è€…ä¸æˆ‘ä»¬åœ¨Pandasä¸­ä¹‹å‰æ‰€åšçš„ä¸ä¸€æ ·ï¼Ÿ
- en: On the right side of the `=`, we are extracting the Series of discount codes
    (`events['discount']`), then using the lowercase operation on strings `str.lower()`
    to convert each one, building up a Series of the results. Normally, given a string
    (such as `'BIRTHDAY'`), we could get a lowercase version of it by writing just
    `'BIRTHDAY'.lower()`. Whatâ€™s the extra `str` doing in there?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ `=` çš„å³ä¾§ï¼Œæˆ‘ä»¬æ­£åœ¨æå–æŠ˜æ‰£ä»£ç çš„åºåˆ—ï¼ˆ`events['discount']`ï¼‰ï¼Œç„¶åä½¿ç”¨å­—ç¬¦ä¸²çš„ `str.lower()` æ“ä½œå°†æ¯ä¸ªå…ƒç´ è½¬æ¢ä¸ºå°å†™ï¼Œæ„å»ºä¸€ä¸ªåŒ…å«ç»“æœçš„åºåˆ—ã€‚é€šå¸¸ï¼Œç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼ˆå¦‚
    `'BIRTHDAY'`ï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ç®€å•åœ°ç¼–å†™ `'BIRTHDAY'.lower()` æ¥è·å–å…¶å°å†™ç‰ˆæœ¬ã€‚é‚£é‡Œé¢å¤–çš„ `str` æ˜¯åšä»€ä¹ˆçš„ï¼Ÿ
- en: This is a nuance about lifting. Python can evaluate `'BIRTHDAY'.lower()` because
    `lower()` is defined directly on strings. `lower()` is not, however, directly
    defined on Series. To bridge the gap between having Series data and wanting to
    use a string operation on it, we insert `str` before `lower()`. Effectively, this
    tells Python where to find the `lower()` operation (in the collection of operations
    defined on strings).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æå‡çš„ä¸€ä¸ªç»†å¾®å·®åˆ«ã€‚Python å¯ä»¥è¯„ä¼° `'BIRTHDAY'.lower()`ï¼Œå› ä¸º `lower()` æ˜¯ç›´æ¥å®šä¹‰åœ¨å­—ç¬¦ä¸²ä¸Šçš„ã€‚ç„¶è€Œï¼Œ`lower()`
    å¹¶ä¸æ˜¯ç›´æ¥å®šä¹‰åœ¨ Series ä¸Šçš„ã€‚ä¸ºäº†åœ¨æ‹¥æœ‰ Series æ•°æ®å’Œæƒ³è¦å¯¹å…¶æ‰§è¡Œå­—ç¬¦ä¸²æ“ä½œä¹‹é—´æ¶èµ·æ¡¥æ¢ï¼Œæˆ‘ä»¬åœ¨ `lower()` å‰æ’å…¥ `str`ã€‚å®é™…ä¸Šï¼Œè¿™å‘Šè¯‰
    Python åœ¨å“ªé‡Œå¯ä»¥æ‰¾åˆ° `lower()` æ“ä½œï¼ˆåœ¨å®šä¹‰åœ¨å­—ç¬¦ä¸²ä¸Šçš„æ“ä½œé›†åˆä¸­ï¼‰ã€‚
- en: 'The left side of the above code looks like:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šè¿°ä»£ç çš„å·¦ä¾§çœ‹èµ·æ¥åƒï¼š
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This tells Pandas to replace the current contents of the `''discount''` series
    with the series on the right side of the `=`. It is similar to `transform-column`
    from Pyret, but with a fundamental difference: in Pyret, `transform-column` left
    the old table intact and produced a new table with the new column values. Instead,
    in Pandas the old column gets replaced, thus destroying the original table. There
    are many nuances to having operations destroy and replace data; the chapter on
    [Mutating Structures](mutating-structures.html) studies them in detail.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å‘Šè¯‰ Pandas å°† `'discount'` ç³»åˆ—çš„å½“å‰å†…å®¹æ›¿æ¢ä¸º `=` å³ä¾§çš„ç³»åˆ—ã€‚å®ƒä¸ Pyret ä¸­çš„ `transform-column`
    ç±»ä¼¼ï¼Œä½†æœ‰ä¸€ä¸ªåŸºæœ¬åŒºåˆ«ï¼šåœ¨ Pyret ä¸­ï¼Œ`transform-column` ä¿ç•™äº†æ—§è¡¨å¹¶ç”Ÿæˆäº†å…·æœ‰æ–°åˆ—å€¼çš„æ–°è¡¨ã€‚ç›¸åï¼Œåœ¨ Pandas ä¸­ï¼Œæ—§åˆ—è¢«æ›¿æ¢ï¼Œä»è€Œç ´åäº†åŸå§‹è¡¨ã€‚æœ‰è®¸å¤šå…³äºæ“ä½œç ´åå’Œæ›¿æ¢æ•°æ®çš„ç»†å¾®å·®åˆ«ï¼›å…³äº[ä¿®æ”¹ç»“æ„](mutating-structures.html)çš„ç« èŠ‚è¯¦ç»†ç ”ç©¶äº†è¿™äº›ã€‚
- en: 10.1.3.1Â Clearing out unknown values[ğŸ”—](#(part._.Clearing_out_unknown_values)
    "Link to here")
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.1.3.1 æ¸…é™¤æœªçŸ¥å€¼[ğŸ”—](#(part._.Clearing_out_unknown_values) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Now letâ€™s try a different cleaning and normalization problem: we want the discount
    column to contain only known discount codes or empty strings. The `none` entry
    in line 3 of the table should be converted to an empty string, and we should make
    sure that all of the `NaN` and seemingly empty entries in the discount cells are
    also converted to empty strings (as opposed to strings of multiple spaces).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬å°è¯•ä¸€ä¸ªä¸åŒçš„æ¸…ç†å’Œå½’ä¸€åŒ–é—®é¢˜ï¼šæˆ‘ä»¬å¸Œæœ›æŠ˜æ‰£åˆ—åªåŒ…å«å·²çŸ¥çš„æŠ˜æ‰£ä»£ç æˆ–ç©ºå­—ç¬¦ä¸²ã€‚è¡¨æ ¼ç¬¬3è¡Œçš„ `none` æ¡ç›®åº”è½¬æ¢ä¸ºç©ºå­—ç¬¦ä¸²ï¼Œå¹¶ä¸”æˆ‘ä»¬åº”è¯¥ç¡®ä¿æ‰€æœ‰æŠ˜æ‰£å•å…ƒæ ¼ä¸­çš„
    `NaN` å’Œçœ‹ä¼¼ç©ºç™½çš„æ¡ç›®ä¹Ÿè½¬æ¢ä¸ºç©ºå­—ç¬¦ä¸²ï¼ˆè€Œä¸æ˜¯å¤šä¸ªç©ºæ ¼çš„å­—ç¬¦ä¸²ï¼‰ã€‚
- en: Do Now!
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Plan out how you might do this task using mask expressions. Even if you donâ€™t
    know all the specific notation for the operations you need, you can still work
    out a plan for completing this task.
  id: totrans-84
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è®¡åˆ’å¦‚ä½•ä½¿ç”¨æ©ç è¡¨è¾¾å¼æ¥å®Œæˆè¿™é¡¹ä»»åŠ¡ã€‚å³ä½¿ä½ ä¸çŸ¥é“æ‰€éœ€æ“ä½œçš„æ‰€æœ‰ç‰¹å®šç¬¦å·ï¼Œä½ ä»ç„¶å¯ä»¥ä¸ºå®Œæˆè¿™é¡¹ä»»åŠ¡åˆ¶å®šä¸€ä¸ªè®¡åˆ’ã€‚
- en: 'If you planned out the tasks, you might have a todo list like the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ åˆ¶å®šäº†ä»»åŠ¡è®¡åˆ’ï¼Œä½ å¯èƒ½æœ‰ä¸€ä¸ªå¦‚ä¸‹æ‰€ç¤ºçš„ä»»åŠ¡æ¸…å•ï¼š
- en: create a mask of rows with known discount codes
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åˆ›å»ºä¸€ä¸ªåŒ…å«å·²çŸ¥æŠ˜æ‰£ä»£ç çš„è¡Œçš„æ©ç 
- en: invert that mask (swap the false and true values)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åè½¬è¯¥æ©ç ï¼ˆäº¤æ¢å‡å€¼å’ŒçœŸå€¼ï¼‰
- en: filter the DataFrame to rows without a known discount code
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è¿‡æ»¤æ‰å…·æœ‰å·²çŸ¥æŠ˜æ‰£ä»£ç çš„è¡Œ
- en: replace all the discount column values in that DataFrame with an empty string
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å°†è¯¥ DataFrame ä¸­æ‰€æœ‰æŠ˜æ‰£åˆ—çš„å€¼æ›¿æ¢ä¸ºç©ºå­—ç¬¦ä¸²
- en: 'We have seen how to do parts of steps 1 and 3, but neither of steps 2 and 4\.
    Letâ€™s work through the steps one by one:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»çœ‹åˆ°äº†å¦‚ä½•å®Œæˆæ­¥éª¤1å’Œ3çš„éƒ¨åˆ†ï¼Œä½†æ­¥éª¤2å’Œ4éƒ½æ²¡æœ‰å®Œæˆã€‚è®©æˆ‘ä»¬ä¸€æ­¥ä¸€æ­¥åœ°å®Œæˆè¿™äº›æ­¥éª¤ï¼š
- en: 'Hereâ€™s the code for step 1, which creates a mask for the rows with known discount
    codes:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æ­¥éª¤1çš„ä»£ç ï¼Œå®ƒä¸ºå…·æœ‰å·²çŸ¥æŠ˜æ‰£ä»£ç çš„è¡Œåˆ›å»ºäº†ä¸€ä¸ªæ©ç ï¼š
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we use a lifted `isin` operator on lists to compute the mask.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨æå‡çš„ `isin` æ“ä½œç¬¦åœ¨åˆ—è¡¨ä¸Šè®¡ç®—æ©ç ã€‚
- en: 'For step 2, we have to swap the true and false values. We can do this by using
    the negation operator `~` on the mask from step 1:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºç¬¬äºŒæ­¥ï¼Œæˆ‘ä»¬å¿…é¡»äº¤æ¢çœŸå€¼å’Œå‡å€¼ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨ç¬¬ä¸€æ­¥çš„æ©ç ä¸Šä½¿ç”¨å¦å®šè¿ç®—ç¬¦ `~` æ¥å®ç°è¿™ä¸€ç‚¹ï¼š
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For step 3, we want to filter `events` with this mask. Just to keep the code
    easier to read, weâ€™ll give the mask a name and then perform the filter:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºç¬¬ä¸‰æ­¥ï¼Œæˆ‘ä»¬æƒ³è¦ä½¿ç”¨è¿™ä¸ªæ©ç æ¥è¿‡æ»¤ `events`ã€‚ä¸ºäº†ä½¿ä»£ç æ›´å®¹æ˜“é˜…è¯»ï¼Œæˆ‘ä»¬å°†ç»™æ©ç èµ·ä¸€ä¸ªåå­—ï¼Œç„¶åæ‰§è¡Œè¿‡æ»¤æ“ä½œï¼š
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we use `=` to set the discount column of the filtered DataFrame to
    the empty string:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæˆ‘ä»¬ä½¿ç”¨ `=` å°†è¿‡æ»¤åçš„ DataFrame çš„æŠ˜æ‰£åˆ—è®¾ç½®ä¸ºç©ºå­—ç¬¦ä¸²ï¼š
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Whoops â€“ this seems to have generated an error message that says something
    about a â€œSettingWithCopyWarningâ€. This is a subtlety that has to do with what
    happens when data gets updated under the hood (weâ€™ll learn about subtleties of
    mutation in [Mutable Lists](mutable-lists.html)). For now, weâ€™ll use this alternate
    form that avoids the error:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: å“å‘€â€”â€”è¿™ä¼¼ä¹ç”Ÿæˆäº†ä¸€ä¸ªé”™è¯¯æ¶ˆæ¯ï¼Œè¯´äº†ä¸€äº›å…³äºâ€œSettingWithCopyWarningâ€çš„äº‹æƒ…ã€‚è¿™æ˜¯ä¸€ä¸ªä¸æ•°æ®åœ¨åº•å±‚æ›´æ–°æ—¶å‘ç”Ÿçš„äº‹æƒ…æœ‰å…³çš„å¾®å¦™ä¹‹å¤„ï¼ˆæˆ‘ä»¬å°†åœ¨[å¯å˜åˆ—è¡¨](mutable-lists.html)ä¸­äº†è§£çªå˜å¾®å¦™ä¹‹å¤„ï¼‰ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨è¿™ä¸ªé¿å…é”™è¯¯çš„å…¶ä»–å½¢å¼ï¼š
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Putting it all together, the entire program looks like:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: å°†æ‰€æœ‰è¿™äº›æ”¾åœ¨ä¸€èµ·ï¼Œæ•´ä¸ªç¨‹åºçœ‹èµ·æ¥å¦‚ä¸‹ï¼š
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Summarizing, the code pattern for updating values for a column in some rows
    of a DataFrame is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: æ€»ç»“ï¼Œæ›´æ–°DataFrameä¸­æŸäº›è¡Œåˆ—å€¼çš„ä»£ç æ¨¡å¼å¦‚ä¸‹ï¼š
- en: make a boolean series mask for which rows to update
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸ºè¦æ›´æ–°çš„è¡Œåˆ›å»ºä¸€ä¸ªå¸ƒå°”åºåˆ—æ©ç 
- en: use the mask to select just the rows where the mask is true
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨æ©ç ä»…é€‰æ‹©æ©ç ä¸ºçœŸçš„è¡Œ
- en: use `.loc` with the mask and column name to select the series of cells to update
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`.loc`å’Œæ©ç ä»¥åŠåˆ—åæ¥é€‰æ‹©è¦æ›´æ–°çš„å•å…ƒæ ¼åºåˆ—
- en: use `=` to give those cells their new value
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`=`ä¸ºè¿™äº›å•å…ƒæ ¼èµ‹äºˆæ–°å€¼
- en: Exercise
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Follow the above pattern to transform all delivery values of `'yes'` to `'pickup'`.
  id: totrans-111
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æŒ‰ç…§ä¸Šè¿°æ¨¡å¼å°†æ‰€æœ‰äº¤ä»˜å€¼`'yes'`è½¬æ¢ä¸º`'pickup'`ã€‚
- en: 10.1.3.2Â Repairing Values and Column Types[ğŸ”—](#(part._.Repairing_.Values_and_.Column_.Types)
    "Link to here")
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.1.3.2Â ä¿®å¤å€¼å’Œåˆ—ç±»å‹[ğŸ”—](#(part._.Repairing_.Values_and_.Column_.Types) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'The source file for the `events` table contained an error in which someone
    entered the string `''three''` in place of the number `3` for the number of tickets
    in the last row. We can repair errors like this manually:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`events`è¡¨æºæ–‡ä»¶ä¸­å­˜åœ¨ä¸€ä¸ªé”™è¯¯ï¼Œæœ‰äººå°†å­—ç¬¦ä¸²`''three''`è¾“å…¥åˆ°æœ€åä¸€è¡Œçš„ç¥¨æ•°`3`çš„ä½ç½®ã€‚æˆ‘ä»¬å¯ä»¥æ‰‹åŠ¨ä¿®å¤è¿™æ ·çš„é”™è¯¯ï¼š'
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Do Now!
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make this repair and ask your Python environment to show you the corrected table.
  id: totrans-117
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿›è¡Œæ­¤ä¿®å¤ï¼Œå¹¶è®©æ‚¨çš„Pythonç¯å¢ƒæ˜¾ç¤ºå·²çº æ­£çš„è¡¨æ ¼ã€‚
- en: 'Now that the `''numtix''` column contains only numbers, we can total the number
    of tickets that were sold:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ç”±äº`'numtix'`åˆ—åªåŒ…å«æ•°å­—ï¼Œæˆ‘ä»¬å¯ä»¥è®¡ç®—å·²å”®å‡ºçš„ç¥¨æ•°æ€»æ•°ï¼š
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Do Now!
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What did you get? Why?
  id: totrans-122
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ å¾—åˆ°äº†ä»€ä¹ˆï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ
- en: 'Because Python environments print strings without quotation marks, the numtix
    column appears to contain numbers. The failure of `sum` shows that this is indeed
    not the case. We can inspect the types that Python has determined for the numtix
    values using the `type` operation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸ºPythonç¯å¢ƒåœ¨æ²¡æœ‰å¼•å·çš„æƒ…å†µä¸‹æ‰“å°å­—ç¬¦ä¸²ï¼Œæ‰€ä»¥`numtix`åˆ—çœ‹èµ·æ¥åŒ…å«æ•°å­—ã€‚`sum`å¤±è´¥è¡¨æ˜è¿™ç¡®å®ä¸æ˜¯æƒ…å†µã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨`type`æ“ä½œæ£€æŸ¥Pythonä¸º`numtix`å€¼ç¡®å®šçš„ç±»å‹ï¼š
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What happened here? During the original call to `read_csv`, Python detected
    both numeric and string data in the numtix column. It therefore read in all the
    values as strings. Our manual repair that replaced the string `'three'` with the
    number `3` fixed the value and type for one row, but the remaining values in that
    column have still been read in as integers.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿåœ¨åŸå§‹è°ƒç”¨`read_csv`æ—¶ï¼ŒPythonæ£€æµ‹åˆ°`numtix`åˆ—ä¸­æ—¢æœ‰æ•°å­—ä¹Ÿæœ‰å­—ç¬¦ä¸²æ•°æ®ã€‚å› æ­¤ï¼Œå®ƒå°†æ‰€æœ‰å€¼éƒ½è¯»å…¥ä¸ºå­—ç¬¦ä¸²ã€‚æˆ‘ä»¬æ‰‹åŠ¨ä¿®å¤ï¼Œå°†å­—ç¬¦ä¸²`'three'`æ›¿æ¢ä¸ºæ•°å­—`3`ï¼Œä¿®å¤äº†ä¸€è¡Œçš„å€¼å’Œç±»å‹ï¼Œä½†è¯¥åˆ—ä¸­å‰©ä½™çš„å€¼ä»ç„¶è¢«è¯»å…¥ä¸ºæ•´æ•°ã€‚
- en: Fortunately, Python provides an operation to change the type of data within
    a series. The following code converts the values in the `events['numtix']` series
    to integers, updating the series within the DataFrame in the process.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¸è¿çš„æ˜¯ï¼ŒPythonæä¾›äº†ä¸€ä¸ªæ“ä½œæ¥æ›´æ”¹åºåˆ—ä¸­æ•°æ®çš„ç±»å‹ã€‚ä»¥ä¸‹ä»£ç å°†`events['numtix']`åºåˆ—ä¸­çš„å€¼è½¬æ¢ä¸ºæ•´æ•°ï¼Œå¹¶åœ¨è¿‡ç¨‹ä¸­æ›´æ–°DataFrameä¸­çš„åºåˆ—ã€‚
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 10.1.4Â Computing New Columns[ğŸ”—](#(part._.Computing_.New_.Columns) "Link to here")
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.4Â è®¡ç®—æ–°åˆ—[ğŸ”—](#(part._.Computing_.New_.Columns) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Letâ€™s extend the events table with the total cost of tickets, while also accounting
    for a discount. Weâ€™ll start by building a column for the ticket price without
    any discounts. This is a straightforward application of lifting as weâ€™ve seen
    it so far:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ‰©å±•äº‹ä»¶è¡¨ï¼ŒåŒ…æ‹¬ç¥¨åŠ¡çš„æ€»æˆæœ¬ï¼ŒåŒæ—¶è€ƒè™‘æŠ˜æ‰£ã€‚æˆ‘ä»¬å°†é¦–å…ˆåˆ›å»ºä¸€ä¸ªæ²¡æœ‰æŠ˜æ‰£çš„ç¥¨ä»·åˆ—ã€‚è¿™æ˜¯åˆ°ç›®å‰ä¸ºæ­¢æˆ‘ä»¬æ‰€çœ‹åˆ°çš„æå‡åº”ç”¨çš„ç›´æ¥åº”ç”¨ï¼š
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Do Now!
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use masks, operator lifting, filtering, and series updating to give a 10% discount
    to everyone with the â€œbirthdayâ€ discount code.
  id: totrans-133
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨æ©ç ã€æå‡æ“ä½œã€è¿‡æ»¤å’Œåºåˆ—æ›´æ–°ï¼Œä¸ºæ‹¥æœ‰â€œç”Ÿæ—¥â€æŠ˜æ‰£ä»£ç çš„æ¯ä¸ªäººæä¾›10%çš„æŠ˜æ‰£ã€‚
- en: We do this by creating a mask for the â€œbirthdayâ€ discount, then updating just
    that part of the DataFrame.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é€šè¿‡åˆ›å»ºä¸€ä¸ªé’ˆå¯¹â€œç”Ÿæ—¥â€æŠ˜æ‰£çš„æ©ç ï¼Œç„¶ååªæ›´æ–°DataFrameçš„è¿™ä¸€éƒ¨åˆ†æ¥å®ç°è¿™ä¸€ç‚¹ã€‚
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that the notation for computing new columns and updating existing ones
    is the same (unlike in Pyret, where we had different operations `build-column`
    and `transform-column`). In Pandas, a new column is created if the given column
    name doesnâ€™t already exist in the DataFrame; otherwise, the existing column with
    the given name gets updated.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè®¡ç®—æ–°åˆ—å’Œæ›´æ–°ç°æœ‰åˆ—çš„ç¬¦å·æ˜¯ç›¸åŒçš„ï¼ˆä¸ Pyret ä¸åŒï¼Œåœ¨ Pyret ä¸­æˆ‘ä»¬æœ‰ä¸åŒçš„æ“ä½œ `build-column` å’Œ `transform-column`ï¼‰ã€‚åœ¨
    Pandas ä¸­ï¼Œå¦‚æœç»™å®šçš„åˆ—ååœ¨ DataFrame ä¸­ä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºæ–°åˆ—ï¼›å¦åˆ™ï¼Œå°†æ›´æ–°å…·æœ‰ç»™å®šåç§°çš„ç°æœ‰åˆ—ã€‚
- en: 10.1.5Â Aggregating and Grouping Columns[ğŸ”—](#(part._.Aggregating_and_.Grouping_.Columns)
    "Link to here")
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.5Â èšåˆå’Œåˆ†ç»„åˆ—[ğŸ”—](#(part._.Aggregating_and_.Grouping_.Columns) "é“¾æ¥è‡³æ­¤")
- en: Pandas has built-in operations for doing standard mathematical computations
    over series. For example, to total the number of tickets sold or to compute the
    average number of tickets per order, we can write
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas ä¸ºåœ¨åºåˆ—ä¸Šæ‰§è¡Œæ ‡å‡†æ•°å­¦è®¡ç®—æä¾›äº†å†…ç½®æ“ä½œã€‚ä¾‹å¦‚ï¼Œä¸ºäº†è®¡ç®—é”€å”®çš„ç¥¨æ•°æ€»æ•°æˆ–è®¡ç®—æ¯è®¢å•çš„å¹³å‡ç¥¨æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ç¼–å†™
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These are the same built-in operations that apply to Python lists.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æ˜¯åº”ç”¨äº Python åˆ—çš„å†…ç½®æ“ä½œã€‚
- en: Imagine now that we wanted a finer-grained look at total ticket sales. Rather
    than just the total sold overall, weâ€™d like the total sold per discount category.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬ç°åœ¨æƒ³æ›´ç»†è‡´åœ°æŸ¥çœ‹æ€»ç¥¨åŠ¡é”€å”®æƒ…å†µã€‚è€Œä¸ä»…ä»…æ˜¯æ•´ä½“é”€å”®æ€»æ•°ï¼Œæˆ‘ä»¬è¿˜æƒ³æŒ‰æŠ˜æ‰£ç±»åˆ«æŸ¥çœ‹æ€»é”€å”®æ•°ã€‚
- en: Do Now!
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How might you compute this?
  id: totrans-144
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ ä¼šå¦‚ä½•è®¡ç®—è¿™ä¸ªï¼Ÿ
- en: We could imagine constructing a list of the discount codes, filtering the ticket
    sales table to each code, then using `sum` on each filtered table. This feels
    like a lot of work, however. Producing summaries of one column (e.g., [PRE23])
    around the values in another (e.g., [PRE24]) is a common technique in data analysis.
    Spreadsheets typically provide a feature called a â€œpivot tableâ€ that supports
    such a view of data.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥æƒ³è±¡æ„å»ºä¸€ä¸ªæŠ˜æ‰£ä»£ç åˆ—è¡¨ï¼Œè¿‡æ»¤ç¥¨åŠ¡é”€å”®è¡¨ä»¥é’ˆå¯¹æ¯ä¸ªä»£ç ï¼Œç„¶åå¯¹æ¯ä¸ªè¿‡æ»¤è¡¨ä½¿ç”¨ `sum`ã€‚ç„¶è€Œï¼Œè¿™æ„Ÿè§‰åƒæ˜¯ä¸€é¡¹å¤§é‡å·¥ä½œã€‚åœ¨æ•°æ®åˆ†æä¸­ï¼Œå›´ç»•å¦ä¸€ä¸ªå€¼ï¼ˆä¾‹å¦‚ï¼Œ[PRE23]ï¼‰çš„å€¼ï¼ˆä¾‹å¦‚ï¼Œ[PRE24]ï¼‰å‘¨å›´ç”Ÿæˆä¸€ä¸ªåˆ—çš„æ‘˜è¦ï¼ˆä¾‹å¦‚ï¼‰æ˜¯ä¸€ç§å¸¸è§æŠ€æœ¯ã€‚ç”µå­è¡¨æ ¼é€šå¸¸æä¾›ä¸€ç§ç§°ä¸ºâ€œæ•°æ®é€è§†è¡¨â€çš„åŠŸèƒ½ï¼Œæ”¯æŒè¿™ç§æ•°æ®è§†å›¾ã€‚
- en: 'In Pandas, we can do a computation like this using an operation called `groupby`.
    Hereâ€™s are two examples. The first reports how many sales (rows) were made with
    each discount code, while the second summarize the total number of tickets sold
    by discount code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Pandas ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªåä¸º `groupby` çš„æ“ä½œæ¥è¿›è¡Œè¿™æ ·çš„è®¡ç®—ã€‚è¿™é‡Œæœ‰ä¸¤ä¸ªä¾‹å­ã€‚ç¬¬ä¸€ä¸ªæŠ¥å‘Šäº†æ¯ä¸ªæŠ˜æ‰£ä»£ç çš„é”€å”®ï¼ˆè¡Œï¼‰æ•°é‡ï¼Œè€Œç¬¬äºŒä¸ªæ€»ç»“äº†æŒ‰æŠ˜æ‰£ä»£ç é”€å”®çš„ç¥¨æ•°æ€»æ•°ï¼š
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`groupby` takes the name of the column whose values will be used to cluster
    rows. It returns a special type of data (called `GroupBy`). From there, we can
    select a column and perform an operation on it. The column selection and operation
    are performed on each collection of rows in the `GroupBy`. The results of the
    second expression in the above code are reported in a new DataFrame:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupby` æ¥æ”¶åˆ—åï¼Œè¯¥åˆ—çš„å€¼å°†ç”¨äºèšç±»è¡Œã€‚å®ƒè¿”å›ä¸€ç§ç‰¹æ®Šç±»å‹çš„æ•°æ®ï¼ˆç§°ä¸º `GroupBy`ï¼‰ã€‚ä»é‚£é‡Œï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹©ä¸€ä¸ªåˆ—å¹¶å¯¹å®ƒè¿›è¡Œæ“ä½œã€‚åˆ—é€‰æ‹©å’Œæ“ä½œæ˜¯åœ¨
    `GroupBy` çš„æ¯ä¸€è¡Œé›†åˆä¸Šæ‰§è¡Œçš„ã€‚ä¸Šè¿°ä»£ç ä¸­ç¬¬äºŒä¸ªè¡¨è¾¾å¼çš„ç»“æœåœ¨æ–°çš„ DataFrame ä¸­æŠ¥å‘Šï¼š'
- en: '![](../Images/0b9ecb1c08c84c777f66a57137d73fb3.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](../Images/0b9ecb1c08c84c777f66a57137d73fb3.png)'
- en: In this DataFrame, discount labels a column. The first row has the empty string
    in the discount column, with 14 tickets purchased without discount codes. There
    were 2 tickets purchased with a birthday discount and 8 with a student discount.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ª DataFrame ä¸­ï¼ŒæŠ˜æ‰£æ ‡è®°äº†ä¸€ä¸ªåˆ—ã€‚ç¬¬ä¸€è¡Œåœ¨æŠ˜æ‰£åˆ—ä¸­æœ‰ä¸€ä¸ªç©ºå­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºæ²¡æœ‰æŠ˜æ‰£ä»£ç è´­ä¹°äº† 14 å¼ ç¥¨ã€‚æœ‰ 2 å¼ ç¥¨ä½¿ç”¨äº†ç”Ÿæ—¥æŠ˜æ‰£ï¼Œ8 å¼ ç¥¨ä½¿ç”¨äº†å­¦ç”ŸæŠ˜æ‰£ã€‚
- en: The Pandas documentation provides a large collection of operations that can
    used on `GroupBy` data; these cover computations such as counting, mean, finding
    largest and smallest values, and performing various other statistical operations.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas æ–‡æ¡£æä¾›äº†ä¸€ç»„å¯ç”¨äº `GroupBy` æ•°æ®çš„æ“ä½œï¼›è¿™äº›åŒ…æ‹¬è®¡æ•°ã€å¹³å‡å€¼ã€æŸ¥æ‰¾æœ€å¤§å’Œæœ€å°å€¼ä»¥åŠæ‰§è¡Œå„ç§å…¶ä»–ç»Ÿè®¡æ“ä½œã€‚
- en: 10.1.6Â Wide Versus Tall Data[ğŸ”—](#(part._.Wide_.Versus_.Tall_.Data) "Link to
    here")
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.6Â å®½æ•°æ®ä¸é•¿æ•°æ®[ğŸ”—](#(part._.Wide_.Versus_.Tall_.Data) "é“¾æ¥è‡³æ­¤")
- en: 'Letâ€™s try grouping data on a different dataset. Hereâ€™s a table showing sales
    data across several regions during each month of the year:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å°è¯•åœ¨å¦ä¸€ä¸ªæ•°æ®é›†ä¸Šå¯¹æ•°æ®è¿›è¡Œåˆ†ç»„ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªè¡¨æ ¼ï¼Œæ˜¾ç¤ºäº†è¯¥å¹´åº¦æ¯ä¸ªæœˆä»½åœ¨ä¸åŒåœ°åŒºçš„é”€å”®æ•°æ®ï¼š
- en: '![](../Images/ec0e7f8f6b70454dec5da967061e0316.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](../Images/ec0e7f8f6b70454dec5da967061e0316.png)'
- en: Copy the following code to load this table for yourself.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: å°†ä»¥ä¸‹ä»£ç å¤åˆ¶ä¸‹æ¥ä»¥åŠ è½½æ­¤è¡¨æ ¼ã€‚
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Do Now!
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Here are several questions that we might want to ask from this dataset. For
    each one, develop a plan that indicates which Pandas operations you would use
    to answer it. If a question seems hard to answer with the operations you have,
    explain whatâ€™s difficult about answering that question.
  id: totrans-159
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€äº›æˆ‘ä»¬å¯èƒ½æƒ³è¦ä»è¿™ä¸ªæ•°æ®é›†ä¸­æå‡ºçš„é—®é¢˜ã€‚å¯¹äºæ¯ä¸ªé—®é¢˜ï¼Œåˆ¶å®šä¸€ä¸ªè®¡åˆ’ï¼Œè¯´æ˜ä½ ä¼šä½¿ç”¨å“ªäº›Pandasæ“ä½œæ¥å›ç­”å®ƒã€‚å¦‚æœä¸€ä¸ªé—®é¢˜çš„å›ç­”ä¼¼ä¹å¾ˆéš¾ç”¨ä½ æ‹¥æœ‰çš„æ“ä½œæ¥å®Œæˆï¼Œè§£é‡Šå›ç­”è¯¥é—®é¢˜å›°éš¾çš„åŸå› ã€‚
- en: ''
  id: totrans-160
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: In which month did the northwest region have the lowest sales?
  id: totrans-161
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: åœ¨å“ªä¸ªæœˆä»½ï¼Œè¥¿åŒ—åœ°åŒºçš„é”€å”®é¢æœ€ä½ï¼Ÿ
- en: ''
  id: totrans-162
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-163
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: What were the total sales per month across all regions?
  id: totrans-164
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: æ‰€æœ‰åœ°åŒºæ¯æœˆçš„æ€»é”€å”®é¢æ˜¯å¤šå°‘ï¼Ÿ
- en: ''
  id: totrans-165
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-166
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Which region had the highest sales in April?
  id: totrans-167
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: å“ªä¸ªåœ°åŒºåœ¨4æœˆä»½çš„é”€å”®é¢æœ€é«˜ï¼Ÿ
- en: ''
  id: totrans-168
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-169
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Which region had the highest sales for the entire year?
  id: totrans-170
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: å“ªä¸ªåœ°åŒºåœ¨å…¨å¹´ä¸­çš„é”€å”®é¢æœ€é«˜ï¼Ÿ
- en: For question 1, we can sort the table by northwest sales in decreasing order,
    then see which month is listed in the first row.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºé—®é¢˜1ï¼Œæˆ‘ä»¬å¯ä»¥æŒ‰è¥¿åŒ—åœ°åŒºçš„é”€å”®é¢é™åºæ’åºè¡¨æ ¼ï¼Œç„¶åæŸ¥çœ‹ç¬¬ä¸€è¡Œåˆ—å‡ºçš„æœˆä»½ã€‚
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Do Now!
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¿›è¡Œæ—¶ï¼
- en: ''
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What value would we have gotten had we used `loc` instead of `iloc` in the above
    code?
  id: totrans-175
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœåœ¨ä¸Šé¢çš„ä»£ç ä¸­ä½¿ç”¨`loc`è€Œä¸æ˜¯`iloc`ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä»€ä¹ˆå€¼ï¼Ÿ
- en: Do Now!
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¿›è¡Œæ—¶ï¼
- en: ''
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did sorting the `sales` table change the row order permanently? Check by having
    Python show you the value of `sales` after you run `sort_values`.
  id: totrans-178
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ’åºâ€œé”€å”®é¢â€è¡¨æ˜¯å¦æ°¸ä¹…æ”¹å˜äº†è¡Œé¡ºåºï¼Ÿé€šè¿‡è¿è¡Œ`sort_values`åè®©Pythonæ˜¾ç¤º`sales`çš„å€¼æ¥æ£€æŸ¥ã€‚
- en: 'For question 2, we could build a new column that stores the sales data across
    each row:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºé—®é¢˜2ï¼Œæˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªæ–°çš„åˆ—æ¥å­˜å‚¨æ¯è¡Œçš„é”€å”®æ•°æ®ï¼š
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Do Now!
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¿›è¡Œæ—¶ï¼
- en: ''
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did computing the `total` column change the row order permanently? Check by
    having Python show you the value of `sales` after you run the code.
  id: totrans-183
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è®¡ç®—æ€»è®¡åˆ—æ˜¯å¦æ°¸ä¹…æ”¹å˜äº†è¡Œé¡ºåºï¼Ÿé€šè¿‡è¿è¡Œä»£ç åè®©Pythonæ˜¾ç¤º`sales`çš„å€¼æ¥æ£€æŸ¥ã€‚
- en: (If you want to remove the new `total` column, you can do this with `sales =
    sales.drop(columns='total')`.)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆå¦‚æœä½ æƒ³è¦åˆ é™¤æ–°çš„â€œæ€»è®¡â€åˆ—ï¼Œå¯ä»¥ä½¿ç”¨`sales = sales.drop(columns='total')`æ¥å®ç°ã€‚ï¼‰
- en: Question 3 is more challenging because we want to sort on the regions, which
    are in columns rather than rows. Question 4 is even more challenging because we
    want to produce sums of columns, then compare regions. Both of these feel a bit
    like problems we might know how to solve if the rows corresponded to regions rather
    than months, but that isnâ€™t how our data are organized. And even if we did flip
    the table around (we could, the technical term for this is `transpose`), problem
    4 would still feel a bit complicated by the time we computed annual sales per
    region and sorted them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: é—®é¢˜3æ›´å…·æŒ‘æˆ˜æ€§ï¼Œå› ä¸ºæˆ‘ä»¬æƒ³è¦æ ¹æ®åœ°åŒºè¿›è¡Œæ’åºï¼Œè€Œè¿™äº›åœ°åŒºä½äºåˆ—è€Œä¸æ˜¯è¡Œã€‚é—®é¢˜4çš„æŒ‘æˆ˜æ€§æ›´å¤§ï¼Œå› ä¸ºæˆ‘ä»¬æƒ³è¦è®¡ç®—åˆ—çš„æ€»å’Œï¼Œç„¶åæ¯”è¾ƒåœ°åŒºã€‚è¿™ä¸¤ä¸ªé—®é¢˜éƒ½æœ‰äº›åƒæˆ‘ä»¬å¯èƒ½çŸ¥é“å¦‚ä½•è§£å†³çš„ï¼Œå¦‚æœè¡Œå¯¹åº”åœ°åŒºè€Œä¸æ˜¯æœˆä»½ï¼Œä½†æˆ‘ä»¬çš„æ•°æ®ç»„ç»‡å¹¶ä¸æ˜¯è¿™æ ·ã€‚å³ä½¿æˆ‘ä»¬ç¿»è½¬äº†è¡¨æ ¼ï¼ˆæˆ‘ä»¬å¯ä»¥è¿™æ ·åšï¼Œè¿™ä¸ªæœ¯è¯­å«åšâ€œè½¬ç½®â€ï¼‰ï¼Œåœ¨è®¡ç®—æ¯ä¸ªåœ°åŒºçš„å¹´åº¦é”€å”®é¢å¹¶å¯¹å…¶è¿›è¡Œæ’åºä¹‹åï¼Œé—®é¢˜4ä»ç„¶ä¼šæ„Ÿè§‰æœ‰äº›å¤æ‚ã€‚
- en: What if instead our table had looked like the following? Would questions 3 and
    4 get any easier?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬çš„è¡¨æ ¼çœ‹èµ·æ¥åƒä¸‹é¢è¿™æ ·å‘¢ï¼Ÿé—®é¢˜3å’Œ4ä¼šå˜å¾—å®¹æ˜“ä¸€äº›å—ï¼Ÿ
- en: '![](../Images/0b8815a10314d9cdee7892b1e09f891d.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0b8815a10314d9cdee7892b1e09f891d.png)'
- en: With the data organized this way, question 3 can be answered with a combination
    of row selection and `sort_values`. Question 4 becomes easy to answer with a `groupby`.
    Even the code for Question 2 gets cleaner.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥è¿™ç§æ–¹å¼ç»„ç»‡æ•°æ®ï¼Œé—®é¢˜3å¯ä»¥é€šè¿‡è¡Œé€‰æ‹©å’Œ`sort_values`çš„ç»„åˆæ¥å›ç­”ã€‚é—®é¢˜4å¯ä»¥é€šè¿‡`groupby`è½»æ¾å›ç­”ã€‚ç”šè‡³é—®é¢˜2çš„ä»£ç ä¹Ÿå˜å¾—æ›´ç®€æ´ã€‚
- en: The contrast between these two tables highlights that how our data are organized
    can determine how easy or hard it is to process them with the standard operations
    provided by table-processing packages such as Pandas (what weâ€™re discussing here
    applies to other languages that support tables, such as Pyret and R).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸¤ä¸ªè¡¨æ ¼ä¹‹é—´çš„å¯¹æ¯”çªå‡ºäº†æˆ‘ä»¬çš„æ•°æ®ç»„ç»‡æ–¹å¼å¯ä»¥å†³å®šä½¿ç”¨åƒPandasè¿™æ ·çš„è¡¨æ ¼å¤„ç†åŒ…æä¾›çš„æ ‡å‡†æ“ä½œæ¥å¤„ç†æ•°æ®æ˜¯å®¹æ˜“è¿˜æ˜¯å›°éš¾ï¼ˆè¿™é‡Œè®¨è®ºçš„å†…å®¹ä¹Ÿé€‚ç”¨äºæ”¯æŒè¡¨æ ¼çš„å…¶ä»–è¯­è¨€ï¼Œå¦‚Pyretå’ŒRï¼‰ã€‚
- en: In general, the operations in table-processing packages were designed to assume
    that there is one core observation per row (about which we might have many smaller
    details or attributes), and that we will want to aggregate and display data across
    rows, not across columns. Our original treated each month as an observation, with
    the regions being details. For questions 1 and 2, which focused on months, the
    built-in operations sufficed to process the table. But for questions 3 and 4,
    which focused on regions or combinations of regions and months, it helps to have
    each month and region data be in its own row.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: é€šå¸¸ï¼Œè¡¨å¤„ç†åŒ…ä¸­çš„æ“ä½œè¢«è®¾è®¡ä¸ºå‡è®¾æ¯è¡Œæœ‰ä¸€ä¸ªæ ¸å¿ƒè§‚æµ‹å€¼ï¼ˆå…³äºè¿™ä¸ªè§‚æµ‹å€¼æˆ‘ä»¬å¯èƒ½æœ‰å¤šä¸ªè¾ƒå°çš„ç»†èŠ‚æˆ–å±æ€§ï¼‰ï¼Œå¹¶ä¸”æˆ‘ä»¬å¸Œæœ›è·¨è¡Œè€Œä¸æ˜¯è·¨åˆ—èšåˆå’Œæ˜¾ç¤ºæ•°æ®ã€‚æˆ‘ä»¬çš„åŸå§‹æ•°æ®å°†æ¯ä¸ªæœˆè§†ä¸ºä¸€ä¸ªè§‚æµ‹å€¼ï¼Œåœ°åŒºæ˜¯ç»†èŠ‚ã€‚å¯¹äºå…³æ³¨æœˆä»½çš„é—®é¢˜1å’Œ2ï¼Œå†…ç½®æ“ä½œè¶³ä»¥å¤„ç†è¡¨æ ¼ã€‚ä½†å¯¹äºå…³æ³¨åœ°åŒºæˆ–åœ°åŒºå’Œæœˆä»½ç»„åˆçš„é—®é¢˜3å’Œ4ï¼Œå°†æ¯ä¸ªæœˆå’Œåœ°åŒºæ•°æ®æ”¾åœ¨è‡ªå·±çš„è¡Œä¸­ä¼šæœ‰æ‰€å¸®åŠ©ã€‚
- en: Tables like the original `sales` data are called wide tables, whereas the second
    form are termed tall tables. At the extremes, wide tables have every variable
    in its own column whereas tall tables have only one column for a single value
    of interest, with a separate row for each variable that contributed to that value.
    Wide tables tend to be easier for people to read; as we have seen with our sales
    data, tall tables can be easier to process in code, depending on how our questions
    align with our variables.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: åƒåŸå§‹`sales`æ•°æ®è¿™æ ·çš„è¡¨è¢«ç§°ä¸ºå®½è¡¨ï¼Œè€Œç¬¬äºŒç§å½¢å¼è¢«ç§°ä¸ºé•¿è¡¨ã€‚åœ¨æç«¯æƒ…å†µä¸‹ï¼Œå®½è¡¨ä¸­çš„æ¯ä¸ªå˜é‡éƒ½æœ‰è‡ªå·±çš„ä¸€åˆ—ï¼Œè€Œé•¿è¡¨åªæœ‰ä¸€ä¸ªåˆ—ç”¨äºæ„Ÿå…´è¶£çš„å•ä¸€å€¼ï¼Œæ¯ä¸ªå˜é‡éƒ½è´¡çŒ®äº†è¯¥å€¼ï¼Œæ¯ä¸ªå˜é‡éƒ½æœ‰ä¸€ä¸ªå•ç‹¬çš„è¡Œã€‚å®½è¡¨é€šå¸¸æ›´å®¹æ˜“é˜…è¯»ï¼›æ­£å¦‚æˆ‘ä»¬é€šè¿‡é”€å”®æ•°æ®æ‰€çœ‹åˆ°çš„ï¼Œé•¿è¡¨åœ¨ä»£ç ä¸­å¤„ç†èµ·æ¥å¯èƒ½æ›´å®¹æ˜“ï¼Œè¿™å–å†³äºæˆ‘ä»¬çš„é—®é¢˜ä¸å˜é‡çš„å¯¹é½æ–¹å¼ã€‚
- en: Converting Between Wide and Tall Data[ğŸ”—](#(part._.Converting_.Between_.Wide_and_.Tall_.Data)
    "Link to here")
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: åœ¨å®½è¡¨å’Œé•¿è¡¨ä¹‹é—´è½¬æ¢[ğŸ”—](#(part._.Converting_.Between_.Wide_and_.Tall_.Data) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Table-processing packages generally provide built-in operators for converting
    between wide and tall data formats. The following Pandas expression converts the
    (original) wide-format `sales` table into a tall-format table, retaining the month
    of the year and the product division as a label on every datapoint:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: è¡¨å¤„ç†åŒ…é€šå¸¸æä¾›å†…ç½®è¿ç®—ç¬¦ï¼Œç”¨äºåœ¨å®½è¡¨å’Œé•¿è¡¨æ•°æ®æ ¼å¼ä¹‹é—´è¿›è¡Œè½¬æ¢ã€‚ä»¥ä¸‹Pandasè¡¨è¾¾å¼å°†ï¼ˆåŸå§‹çš„ï¼‰å®½æ ¼å¼`sales`è¡¨è½¬æ¢ä¸ºé•¿æ ¼å¼è¡¨ï¼ŒåŒæ—¶ä¿ç•™å¹´ä»½çš„æœˆä»½å’Œäº§å“éƒ¨é—¨ä½œä¸ºæ¯ä¸ªæ•°æ®ç‚¹çš„æ ‡ç­¾ï¼š
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This basic `melt` expression uses default column names of `variable` and `value`
    for the new columns. We can customize those names as part of the `melt` call if
    we wish:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªåŸºæœ¬çš„`melt`è¡¨è¾¾å¼ä½¿ç”¨é»˜è®¤çš„åˆ—å`variable`å’Œ`value`ä¸ºæ–°åˆ—å‘½åã€‚å¦‚æœæˆ‘ä»¬æ„¿æ„ï¼Œå¯ä»¥åœ¨`melt`è°ƒç”¨ä¸­è‡ªå®šä¹‰è¿™äº›åç§°ï¼š
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Letâ€™s put the wide and tall tables side by side to visualize what `melt` is
    doing.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å°†å®½è¡¨å’Œé•¿è¡¨å¹¶æ’æ”¾ç½®ï¼Œä»¥å¯è§†åŒ–`melt`æ“ä½œçš„æ•ˆæœã€‚
- en: '![](../Images/3a8f49b403e48f063552947c7f7f252d.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](../Images/3a8f49b403e48f063552947c7f7f252d.png)'
- en: The columns named in `id_vars` remain in the original table. For each column
    not named in `id_vars`, a row is created with the `id_vars` columns, the melted-column
    name, and the melted-column value for the `id_vars`. The above figure color codes
    how cells from the wide table are arranged in the melted tall table.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨`id_vars`ä¸­å‘½åçš„åˆ—ä¿ç•™åœ¨åŸå§‹è¡¨ä¸­ã€‚å¯¹äºä¸åœ¨`id_vars`ä¸­å‘½åçš„æ¯ä¸ªåˆ—ï¼Œéƒ½ä¼šåˆ›å»ºä¸€ä¸ªåŒ…å«`id_vars`åˆ—ã€ç†”åŒ–åˆ—åç§°å’Œç†”åŒ–åˆ—å€¼çš„è¡Œã€‚ä¸Šå›¾ç”¨é¢œè‰²ç¼–ç äº†å®½è¡¨ä¸­çš„å•å…ƒæ ¼å¦‚ä½•åœ¨ç†”åŒ–åçš„é•¿è¡¨ä¸­æ’åˆ—ã€‚
- en: 'With the tall table in hand, we can proceed to answer questions 3 and 4, as
    well as to redo our solution to question 2:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: æ‹¿ç€é•¿è¡¨ï¼Œæˆ‘ä»¬å¯ä»¥ç»§ç»­å›ç­”é—®é¢˜3å’Œ4ï¼Œä»¥åŠé‡æ–°è§£å†³é—®é¢˜2ï¼š
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The solution to question 4 uses a new Pandas operator called `reset_index`,
    which is needed if you want to manipulate the output of a `group-by` as a regular
    DataFrame.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: é—®é¢˜4çš„è§£å†³æ–¹æ¡ˆä½¿ç”¨äº†æ–°çš„Pandasè¿ç®—ç¬¦`reset_index`ï¼Œå¦‚æœä½ æƒ³è¦å°†`group-by`çš„è¾“å‡ºä½œä¸ºå¸¸è§„DataFrameè¿›è¡Œæ“ä½œï¼Œåˆ™éœ€è¦è¿™ä¸ªè¿ç®—ç¬¦ã€‚
- en: 10.1.7Â Plotting Data[ğŸ”—](#(part._.Plotting_.Data) "Link to here")
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.7Â ç»˜å›¾æ•°æ®[ğŸ”—](#(part._.Plotting_.Data) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Letâ€™s continue with the sales data as we explore plotting in Pandas.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬æ¢ç´¢Pandasä¸­çš„ç»˜å›¾æ—¶ï¼Œè®©æˆ‘ä»¬ç»§ç»­ä½¿ç”¨é”€å”®æ•°æ®ã€‚
- en: Letâ€™s say we now want to take a seasonal view, rather than a monthly view, and
    look at sales within seasons.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬ç°åœ¨æƒ³ä»å­£èŠ‚æ€§è§†è§’è€Œä¸æ˜¯æœˆåº¦è§†è§’æ¥çœ‹ï¼Œå¹¶æŸ¥çœ‹å­£èŠ‚å†…çš„é”€å”®æƒ…å†µã€‚
- en: 'Letâ€™s say we wanted to see how summer sales varied over the years. This is
    a good situation in which to use a line plot. To create this, we first need to
    load `matplotlib`, the Python graphic library:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬æƒ³æŸ¥çœ‹å¤å­£é”€å”®éšå¹´ä»½çš„å˜åŒ–æƒ…å†µã€‚è¿™æ˜¯ä¸€ä¸ªä½¿ç”¨æŠ˜çº¿å›¾çš„å¥½æƒ…å†µã€‚è¦åˆ›å»ºè¿™ä¸ªå›¾è¡¨ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦åŠ è½½`matplotlib`ï¼ŒPythonçš„å›¾å½¢åº“ï¼š
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Next, to generate the line plots, we call the `plt.plot` function on the series
    of numbers that we want to form the points on the plot. We can also specify the
    values on the axes, as shown the following examples.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼Œä¸ºäº†ç”Ÿæˆçº¿å½¢å›¾ï¼Œæˆ‘ä»¬åœ¨æ„æˆå›¾è¡¨ä¸Šç‚¹çš„æ•°å­—åºåˆ—ä¸Šè°ƒç”¨ `plt.plot` å‡½æ•°ã€‚æˆ‘ä»¬è¿˜å¯ä»¥æŒ‡å®šè½´ä¸Šçš„å€¼ï¼Œå¦‚ä¸‹é¢çš„ç¤ºä¾‹æ‰€ç¤ºã€‚
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Pandas will put both line plots in the same display window. In general, each
    time you call `plt.figure()`, you create a new window in which subsequent plot
    commands will appear (at least until you ask for a plot that does not nicely overlay
    with the previous plot type).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas å°†å°†ä¸¤ä¸ªçº¿å½¢å›¾æ”¾åœ¨åŒä¸€ä¸ªæ˜¾ç¤ºçª—å£ä¸­ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œæ¯æ¬¡ä½ è°ƒç”¨ `plt.figure()`ï¼Œä½ éƒ½ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„çª—å£ï¼Œåç»­çš„ç»˜å›¾å‘½ä»¤å°†å‡ºç°åœ¨è¯¥çª—å£ä¸­ï¼ˆè‡³å°‘ç›´åˆ°ä½ è¯·æ±‚ä¸€ä¸ªä¸å…ˆå‰ç»˜å›¾ç±»å‹ä¸å¾ˆå¥½åœ°å åŠ çš„ç»˜å›¾ï¼‰ã€‚
- en: The `matplotlib` package offers many kinds of charts and customizations to graph
    layouts. A more comprehensive look is beyond the scope of this book; see the [matplotlib
    website](https://matplotlib.org/stable/index.html) for tutorials and many examples
    of more sophisticated plots.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`matplotlib` åŒ…æä¾›äº†è®¸å¤šç§ç±»çš„å›¾è¡¨å’Œå›¾å½¢å¸ƒå±€çš„å®šåˆ¶ã€‚æ›´å…¨é¢çš„ä»‹ç»è¶…å‡ºäº†æœ¬ä¹¦çš„èŒƒå›´ï¼›æœ‰å…³æ•™ç¨‹å’Œæ›´å¤æ‚å›¾è¡¨çš„è®¸å¤šç¤ºä¾‹ï¼Œè¯·å‚é˜… [matplotlib
    ç½‘ç«™](https://matplotlib.org/stable/index.html)ã€‚'
- en: 10.1.8Â Takeaways[ğŸ”—](#(part._.Takeaways) "Link to here")
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.8 æ€»ç»“[ğŸ”—](#(part._.Takeaways) "é“¾æ¥è‡³æ­¤")
- en: 'This chapter has been designed to give you an overview of Pandas while pointing
    out key concepts in programming for data science. It is by no means a comprehensive
    Pandas tutorial or reference guide: for those, see the [Pandas website](https://pandas.pydata.org/).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ç« æ—¨åœ¨ä¸ºä½ æä¾›ä¸€ä¸ª Pandas çš„æ¦‚è¿°ï¼ŒåŒæ—¶æŒ‡å‡ºæ•°æ®ç§‘å­¦ç¼–ç¨‹ä¸­çš„å…³é”®æ¦‚å¿µã€‚è¿™ç»å¯¹ä¸æ˜¯ Pandas çš„å…¨é¢æ•™ç¨‹æˆ–å‚è€ƒæŒ‡å—ï¼šå¯¹äºè¿™äº›ï¼Œè¯·å‚é˜… [Pandas
    ç½‘ç«™](https://pandas.pydata.org/)ã€‚
- en: 'Conceptually, we hope you will take away three high-level ideas from this chapter:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ä»æ¦‚å¿µä¸Šè®²ï¼Œæˆ‘ä»¬å¸Œæœ›ä½ èƒ½ä»æœ¬ç« ä¸­å¸¦èµ°ä¸‰ä¸ªé«˜çº§æ€æƒ³ï¼š
- en: 'There are two notions for how to access specific cells in tables and DataFrames:
    by numeric position (e.g., first row, second column) or by labeled index (e.g.,
    numtix). Both have their roles in professional-grade data analysis programming.
    Filter-like operations that extract rows from tables maintain labeled indices,
    but renumber the positional ones (so that every DataFrame has a sequence of consecutively-numbered
    rows).'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨è¡¨æ ¼å’Œ DataFrame ä¸­è®¿é—®ç‰¹å®šå•å…ƒæ ¼æœ‰ä¸¤ç§æ¦‚å¿µï¼šé€šè¿‡æ•°å­—ä½ç½®ï¼ˆä¾‹å¦‚ï¼Œç¬¬ä¸€è¡Œï¼Œç¬¬äºŒåˆ—ï¼‰æˆ–é€šè¿‡æ ‡ç­¾ç´¢å¼•ï¼ˆä¾‹å¦‚ï¼Œnumtixï¼‰ã€‚ä¸¤è€…åœ¨ä¸“ä¸šçº§æ•°æ®åˆ†æç¼–ç¨‹ä¸­éƒ½æ‰®æ¼”ç€å„è‡ªçš„è§’è‰²ã€‚ç±»ä¼¼è¿‡æ»¤çš„æ“ä½œä»è¡¨æ ¼ä¸­æå–è¡Œæ—¶ä¿æŒæ ‡ç­¾ç´¢å¼•ï¼Œä½†é‡æ–°ç¼–å·ä½ç½®ç´¢å¼•ï¼ˆå› æ­¤æ¯ä¸ª
    DataFrame éƒ½æœ‰ä¸€ç³»åˆ—è¿ç»­ç¼–å·çš„è¡Œï¼‰ã€‚
- en: Professional-grade programming languages sometimes â€œliftâ€ operations from single
    values to collections of values (e.g., using `+` to add elements within similarly-sized
    series). Lifting can be a powerful and timesaving tool for programmers, but they
    can also lead to type confusions for both novices and experienced programmers.
    You should be aware that this feature exists as you learn new languages and packages.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸“ä¸šçº§ç¼–ç¨‹è¯­è¨€æœ‰æ—¶ä¼šâ€œæå‡â€æ“ä½œä»å•ä¸ªå€¼åˆ°å€¼çš„é›†åˆï¼ˆä¾‹å¦‚ï¼Œä½¿ç”¨ `+` åœ¨å¤§å°ç›¸ä¼¼çš„åºåˆ—ä¸­æ·»åŠ å…ƒç´ ï¼‰ã€‚æå‡å¯¹äºç¨‹åºå‘˜æ¥è¯´å¯ä»¥æ˜¯ä¸€ä¸ªå¼ºå¤§ä¸”èŠ‚çœæ—¶é—´çš„å·¥å…·ï¼Œä½†å®ƒä»¬ä¹Ÿå¯èƒ½å¯¼è‡´æ–°æ‰‹å’Œç»éªŒä¸°å¯Œçš„ç¨‹åºå‘˜äº§ç”Ÿç±»å‹æ··æ·†ã€‚å½“ä½ å­¦ä¹ æ–°è¯­è¨€å’ŒåŒ…æ—¶ï¼Œä½ åº”è¯¥æ„è¯†åˆ°è¿™ä¸ªåŠŸèƒ½çš„å­˜åœ¨ã€‚
- en: Different table organizations (for the same data) are better in different situations.
    Wide and tall tables are two general shapes, each with their own affordances.
    You should be aware that table-processing packages provide a variety of tools
    to help you automatically reformat tables. If the computation you are trying to
    do feels too complicated, stop and consider whether the problem would be easier
    with a different organization of the same data.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹äºç›¸åŒçš„æ•°æ®ï¼Œä¸åŒçš„è¡¨æ ¼ç»„ç»‡åœ¨ä¸åŒçš„æƒ…å¢ƒä¸‹æ›´å¥½ã€‚å®½è¡¨å’Œé•¿è¡¨æ˜¯ä¸¤ç§å¸¸è§çš„å½¢çŠ¶ï¼Œæ¯ç§å½¢çŠ¶éƒ½æœ‰è‡ªå·±çš„ä¼˜åŠ¿ã€‚ä½ åº”è¯¥æ„è¯†åˆ°ï¼Œè¡¨æ ¼å¤„ç†åŒ…æä¾›äº†å„ç§å·¥å…·æ¥å¸®åŠ©ä½ è‡ªåŠ¨é‡æ–°æ ¼å¼åŒ–è¡¨æ ¼ã€‚å¦‚æœä½ è¯•å›¾è¿›è¡Œçš„è®¡ç®—æ„Ÿè§‰å¤ªå¤æ‚ï¼Œè¯·åœæ­¢å¹¶è€ƒè™‘æ˜¯å¦ä½¿ç”¨ç›¸åŒæ•°æ®çš„ä¸åŒç»„ç»‡æ–¹å¼ä¼šä½¿é—®é¢˜æ›´å®¹æ˜“è§£å†³ã€‚
- en: 10.1.1Â Pandas Table Basics[ğŸ”—](#(part._.Pandas_.Table_.Basics) "Link to here")
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.1 Pandas è¡¨åŸºç¡€[ğŸ”—](#(part._.Pandas_.Table_.Basics) "é“¾æ¥è‡³æ­¤")
- en: '10.1.1.1Â Core Datatypes: DataFrame and Series[ğŸ”—](#(part._.Core_.Datatypes__.Data.Frame_and_.Series)
    "Link to here")'
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.1.1.1 æ ¸å¿ƒæ•°æ®ç±»å‹ï¼šDataFrame å’Œ Series[ğŸ”—](#(part._.Core_.Datatypes__.Data.Frame_and_.Series)
    "é“¾æ¥è‡³æ­¤")
- en: 'Pandas uses the term DataFrame for a table with rows and columns. DataFrames
    are built out of two more basic types:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas ä½¿ç”¨ DataFrame æœ¯è¯­æ¥è¡¨ç¤ºå…·æœ‰è¡Œå’Œåˆ—çš„è¡¨æ ¼ã€‚DataFrame ç”±ä¸¤ç§æ›´åŸºæœ¬çš„æ•°æ®ç±»å‹æ„å»ºï¼š
- en: An array is a sequence of values that can be accessed by position (e.g., 0,
    1, ... up to one less than the length of the array). Like lists, arrays capture
    a linear (ordered) collection of values. Unlike lists, arrays are created with
    a limit on the number of elements that they contain. In practice, lists are more
    commonly used when elements are frequently added or removed whereas arrays are
    more commonly used when elements frequently get accessed by their position. Nearly
    every programming language offers both lists and arrays; a detailed contrast is
    beyond the scope of this book (this information would be covered in a data structures
    class).
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ•°ç»„æ˜¯ä¸€ç³»åˆ—å¯ä»¥é€šè¿‡ä½ç½®è®¿é—®çš„å€¼ï¼ˆä¾‹å¦‚ï¼Œ0ã€1ã€... ç›´åˆ°æ•°ç»„é•¿åº¦å‡ä¸€ï¼‰ã€‚åƒåˆ—è¡¨ä¸€æ ·ï¼Œæ•°ç»„æ•è·äº†ä¸€ä¸ªçº¿æ€§ï¼ˆæœ‰åºï¼‰çš„å€¼é›†åˆã€‚ä¸åˆ—è¡¨ä¸åŒï¼Œæ•°ç»„åˆ›å»ºæ—¶å¯¹å…¶åŒ…å«çš„å…ƒç´ æ•°é‡æœ‰é™åˆ¶ã€‚åœ¨å®è·µä¸­ï¼Œå½“å…ƒç´ ç»å¸¸è¢«æ·»åŠ æˆ–åˆ é™¤æ—¶ï¼Œæ›´å¸¸ç”¨åˆ—è¡¨ï¼›è€Œå½“å…ƒç´ ç»å¸¸æŒ‰ä½ç½®è®¿é—®æ—¶ï¼Œæ›´å¸¸ç”¨æ•°ç»„ã€‚å‡ ä¹æ¯ç§ç¼–ç¨‹è¯­è¨€éƒ½æä¾›äº†åˆ—è¡¨å’Œæ•°ç»„ï¼›è¯¦ç»†çš„å¯¹æ¯”è¶…å‡ºäº†æœ¬ä¹¦çš„èŒƒå›´ï¼ˆè¿™äº›ä¿¡æ¯å°†åœ¨æ•°æ®ç»“æ„è¯¾ç¨‹ä¸­ä»‹ç»ï¼‰ã€‚
- en: A Series is an array in which the positions optionally have labels in addition
    to the position numbers.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Series æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œå…¶ä½ç½®é™¤äº†ä½ç½®æ•°å­—å¤–ï¼Œè¿˜å¯ä»¥æœ‰å¯é€‰çš„æ ‡ç­¾ã€‚
- en: In Pandas, a row is a Series in which an array of the cell values is labeled
    with the column headers (this is similar to the â€˜Rowâ€˜ datatype in Pyret). A DataFrame
    is a series of these rows.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Pandas ä¸­ï¼Œä¸€è¡Œæ˜¯ä¸€ä¸ª Seriesï¼Œå…¶ä¸­å•å…ƒæ ¼å€¼çš„æ•°ç»„è¢«åˆ—æ ‡é¢˜æ ‡è®°ï¼ˆè¿™ä¸ Pyret ä¸­çš„â€˜Rowâ€™æ•°æ®ç±»å‹ç±»ä¼¼ï¼‰ã€‚DataFrame æ˜¯è¿™äº›è¡Œçš„åºåˆ—ã€‚
- en: 10.1.1.2Â Creating and Loading DataFrames[ğŸ”—](#(part._.Creating_and_.Loading_.Data.Frames)
    "Link to here")
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.1.1.2 åˆ›å»ºå’ŒåŠ è½½ DataFrame[ğŸ”—](#(part._.Creating_and_.Loading_.Data.Frames) "é“¾æ¥è‡³æ­¤")
- en: 'DataFrames can be created manually or loaded in from a file, as we did in Pyret.
    Hereâ€™s a simple example of creating one by hand:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame å¯ä»¥æ‰‹åŠ¨åˆ›å»ºæˆ–ä»æ–‡ä»¶åŠ è½½ï¼Œå°±åƒæˆ‘ä»¬åœ¨ Pyret ä¸­åšçš„é‚£æ ·ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªæ‰‹åŠ¨åˆ›å»º DataFrame çš„ç®€å•ç¤ºä¾‹ï¼š
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`data` is a dictionary that maps column names to values. Calling `pd.DataFrame`
    creates a DataFrame from the dictionary. (There are other ways to create DataFrames
    manually which you can find by searching online.)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`data` æ˜¯ä¸€ä¸ªå°†åˆ—åç§°æ˜ å°„åˆ°å€¼çš„å­—å…¸ã€‚è°ƒç”¨ `pd.DataFrame` ä»å­—å…¸åˆ›å»º DataFrameã€‚ï¼ˆè¿˜æœ‰å…¶ä»–åˆ›å»º DataFrame çš„æ‰‹åŠ¨æ–¹æ³•ï¼Œä½ å¯ä»¥åœ¨ç½‘ä¸Šæœç´¢æ‰¾åˆ°ã€‚ï¼‰'
- en: 'To load a DataFrame from a CSV file, you need either the path to the file on
    your computer or the url where you can get the CSV file online. Hereâ€™s an example
    of the url version. In this example, we have the following CSV contents and we
    want to change the header names when loading the file:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: è¦ä» CSV æ–‡ä»¶åŠ è½½ DataFrameï¼Œä½ éœ€è¦ç”µè„‘ä¸Šçš„æ–‡ä»¶è·¯å¾„æˆ–å¯ä»¥åœ¨çº¿è·å– CSV æ–‡ä»¶çš„ç½‘å€ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªç½‘å€ç‰ˆæœ¬çš„ç¤ºä¾‹ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬æœ‰ä»¥ä¸‹
    CSV å†…å®¹ï¼Œæˆ‘ä»¬å¸Œæœ›åœ¨åŠ è½½æ–‡ä»¶æ—¶æ›´æ”¹æ ‡é¢˜åç§°ï¼š
- en: The following `read_csv` command says that the CSV file is at `url`, that there
    are headers in the first row (numbered `0`), and that we want to use the values
    in `names` as the column labels (this will ignore whatever might be in the header
    row in the CSV file).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹ `read_csv` å‘½ä»¤è¡¨ç¤º CSV æ–‡ä»¶ä½äº `url`ï¼Œç¬¬ä¸€è¡Œæœ‰æ ‡é¢˜ï¼ˆç¼–å·ä¸º `0`ï¼‰ï¼Œå¹¶ä¸”æˆ‘ä»¬å¸Œæœ›ä½¿ç”¨ `names` ä¸­çš„å€¼ä½œä¸ºåˆ—æ ‡ç­¾ï¼ˆè¿™å°†å¿½ç•¥
    CSV æ–‡ä»¶æ ‡é¢˜è¡Œä¸­å¯èƒ½å­˜åœ¨çš„ä»»ä½•å†…å®¹ï¼‰ã€‚
- en: '[PRE35]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If we wanted to use the headers in the CSV file as the column headers, we would
    leave out the `names=[...]` part. If the CSV had no header row, we would write
    `header=None` instead of `header=0`. (There are many more configuration options
    in the [Pandas documentation](https://Pandas.pydata.org/docs/reference/api/Pandas.read_csv.html),
    but you wonâ€™t need them for the examples in this book.)
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æƒ³ä½¿ç”¨ CSV æ–‡ä»¶ä¸­çš„æ ‡é¢˜ä½œä¸ºåˆ—æ ‡é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥çœç•¥ `names=[...]` éƒ¨åˆ†ã€‚å¦‚æœ CSV æ²¡æœ‰æ ‡é¢˜è¡Œï¼Œæˆ‘ä»¬å°†å†™ `header=None`
    è€Œä¸æ˜¯ `header=0`ã€‚ï¼ˆPandas æ–‡æ¡£ä¸­æœ‰è®¸å¤šå…¶ä»–é…ç½®é€‰é¡¹ï¼Œä¾‹å¦‚ [Pandas æ–‡æ¡£](https://Pandas.pydata.org/docs/reference/api/Pandas.read_csv.html)ï¼Œä½†ä½ åœ¨æœ¬ä¹¦çš„ç¤ºä¾‹ä¸­ä¸éœ€è¦å®ƒä»¬ã€‚ï¼‰
- en: 'Conceptually, the loaded DataFrame is as follows, with the labels shown in
    blue and the indicies (positions) show in yellow:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ä»æ¦‚å¿µä¸Šè®²ï¼ŒåŠ è½½çš„ DataFrame å¦‚ä¸‹æ‰€ç¤ºï¼Œæ ‡ç­¾ä»¥è“è‰²æ˜¾ç¤ºï¼Œç´¢å¼•ï¼ˆä½ç½®ï¼‰ä»¥é»„è‰²æ˜¾ç¤ºï¼š
- en: '![](../Images/d63a7003f02c1f4bfd00ac93817af463.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d63a7003f02c1f4bfd00ac93817af463.png)'
- en: Since we did not specify labels for the rows, Pandas has used numeric labels
    by default. At the moment, the positions and the labels are the same for each
    row, but we will see that this is not always the case.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºæˆ‘ä»¬æ²¡æœ‰ä¸ºè¡ŒæŒ‡å®šæ ‡ç­¾ï¼ŒPandas é»˜è®¤ä½¿ç”¨äº†æ•°å­—æ ‡ç­¾ã€‚ç›®å‰ï¼Œæ¯è¡Œçš„ä½ç½®å’Œæ ‡ç­¾æ˜¯ç›¸åŒçš„ï¼Œä½†æˆ‘ä»¬å°†çœ‹åˆ°è¿™å¹¶ä¸æ€»æ˜¯å¦‚æ­¤ã€‚
- en: (If you look at the actual loaded table, some of the blank cells in the discount
    column will contain `NaN`, which is the standard Python value for â€œmissing informationâ€.
    We will deal with that information shortly.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆå¦‚æœä½ æŸ¥çœ‹å®é™…åŠ è½½çš„è¡¨æ ¼ï¼ŒæŠ˜æ‰£åˆ—ä¸­çš„ä¸€äº›ç©ºç™½å•å…ƒæ ¼å°†åŒ…å« `NaN`ï¼Œè¿™æ˜¯ Python ä¸­è¡¨ç¤ºâ€œç¼ºå¤±ä¿¡æ¯â€çš„æ ‡å‡†å€¼ã€‚æˆ‘ä»¬å°†åœ¨ç¨åå¤„ç†è¿™äº›ä¿¡æ¯ã€‚ï¼‰
- en: 10.1.1.3Â Using Labels and Indices to Access Cells[ğŸ”—](#(part._.Using_.Labels_and_.Indices_to_.Access_.Cells)
    "Link to here")
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.1.1.3 ä½¿ç”¨æ ‡ç­¾å’Œç´¢å¼•è®¿é—®å•å…ƒæ ¼[ğŸ”—](#(part._.Using_.Labels_and_.Indices_to_.Access_.Cells)
    "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Rows, columns, and cells can be accessed using either their (numeric) positions
    or their labels. Here are some examples:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: å¯ä»¥ä½¿ç”¨å®ƒä»¬çš„ï¼ˆæ•°å­—ï¼‰ä½ç½®æˆ–æ ‡ç­¾æ¥è®¿é—®è¡Œã€åˆ—å’Œå•å…ƒæ ¼ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›ç¤ºä¾‹ï¼š
- en: '[PRE36]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice that we used different notation for accessing a cell depending on whether
    we accessed the row first or the column first. This is because we are showing
    you how to access data through either position indices or labels. Using `.loc`
    tells Pandas that you are using a label to access a row. If you want to use the
    position instead, you need to use `iloc` (the `i` stands for â€œintegerâ€). If you
    are using a programmer-supplied label instead, you can just use the label directly.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„åˆ°ï¼Œæˆ‘ä»¬æ ¹æ®æ˜¯å…ˆè®¿é—®è¡Œè¿˜æ˜¯å…ˆè®¿é—®åˆ—æ¥ä½¿ç”¨ä¸åŒçš„ç¬¦å·æ¥è®¿é—®å•å…ƒæ ¼ã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬æ­£åœ¨å‘æ‚¨å±•ç¤ºå¦‚ä½•é€šè¿‡ä½ç½®ç´¢å¼•æˆ–æ ‡ç­¾æ¥è®¿é—®æ•°æ®ã€‚ä½¿ç”¨ `.loc` å‘Šè¯‰
    Pandas æ‚¨æ­£åœ¨ä½¿ç”¨æ ‡ç­¾æ¥è®¿é—®è¡Œã€‚å¦‚æœæ‚¨æƒ³ä½¿ç”¨ä½ç½®ï¼Œåˆ™éœ€è¦ä½¿ç”¨ `iloc`ï¼ˆå…¶ä¸­çš„ `i` ä»£è¡¨â€œæ•´æ•°â€ï¼‰ã€‚å¦‚æœæ‚¨ä½¿ç”¨çš„æ˜¯ç¨‹åºå‘˜æä¾›çš„æ ‡ç­¾ï¼Œåˆ™å¯ä»¥ç›´æ¥ä½¿ç”¨è¯¥æ ‡ç­¾ã€‚
- en: In a DataFrame, both rows and columns always have position indices and may have
    labels. The `.loc` notation works on either rows or columns, we just happened
    to illustrate the notation on the rows since we had already created labels on
    the columns when we loaded `events`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ DataFrame ä¸­ï¼Œè¡Œå’Œåˆ—å§‹ç»ˆéƒ½æœ‰ä½ç½®ç´¢å¼•ï¼Œå¹¶ä¸”å¯èƒ½è¿˜æœ‰æ ‡ç­¾ã€‚`.loc` ç¬¦å·é€‚ç”¨äºè¡Œæˆ–åˆ—ï¼Œæˆ‘ä»¬åªæ˜¯ç¢°å·§åœ¨è¡Œä¸Šè¯´æ˜äº†è¿™ä¸ªç¬¦å·ï¼Œå› ä¸ºæˆ‘ä»¬å·²ç»åœ¨åŠ è½½
    `events` æ—¶ä¸ºåˆ—åˆ›å»ºäº†æ ‡ç­¾ã€‚
- en: '10.1.1.1Â Core Datatypes: DataFrame and Series[ğŸ”—](#(part._.Core_.Datatypes__.Data.Frame_and_.Series)
    "Link to here")'
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.1.1.1 æ ¸å¿ƒæ•°æ®ç±»å‹ï¼šDataFrame å’Œ Series[ğŸ”—](#(part._.Core_.Datatypes__.Data.Frame_and_.Series)
    "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Pandas uses the term DataFrame for a table with rows and columns. DataFrames
    are built out of two more basic types:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas ä½¿ç”¨ DataFrame æœ¯è¯­æ¥è¡¨ç¤ºå…·æœ‰è¡Œå’Œåˆ—çš„è¡¨æ ¼ã€‚DataFrame ç”±ä¸¤ç§æ›´åŸºæœ¬çš„æ•°æ®ç±»å‹ç»„æˆï¼š
- en: An array is a sequence of values that can be accessed by position (e.g., 0,
    1, ... up to one less than the length of the array). Like lists, arrays capture
    a linear (ordered) collection of values. Unlike lists, arrays are created with
    a limit on the number of elements that they contain. In practice, lists are more
    commonly used when elements are frequently added or removed whereas arrays are
    more commonly used when elements frequently get accessed by their position. Nearly
    every programming language offers both lists and arrays; a detailed contrast is
    beyond the scope of this book (this information would be covered in a data structures
    class).
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ•°ç»„æ˜¯ä¸€ç³»åˆ—å¯ä»¥é€šè¿‡ä½ç½®è®¿é—®çš„å€¼ï¼ˆä¾‹å¦‚ï¼Œ0ã€1ã€... ç›´åˆ°æ•°ç»„é•¿åº¦å‡ä¸€ï¼‰ã€‚åƒåˆ—è¡¨ä¸€æ ·ï¼Œæ•°ç»„æ•è·äº†ä¸€ä¸ªçº¿æ€§ï¼ˆæœ‰åºï¼‰çš„å€¼é›†åˆã€‚ä¸åˆ—è¡¨ä¸åŒï¼Œæ•°ç»„åˆ›å»ºæ—¶å¯¹å…¶åŒ…å«çš„å…ƒç´ æ•°é‡æœ‰é™åˆ¶ã€‚åœ¨å®è·µä¸­ï¼Œå½“å…ƒç´ ç»å¸¸è¢«æ·»åŠ æˆ–åˆ é™¤æ—¶ï¼Œæ›´å¸¸ç”¨åˆ—è¡¨ï¼›è€Œå½“å…ƒç´ ç»å¸¸æŒ‰ä½ç½®è®¿é—®æ—¶ï¼Œæ›´å¸¸ç”¨æ•°ç»„ã€‚å‡ ä¹æ¯ç§ç¼–ç¨‹è¯­è¨€éƒ½æä¾›åˆ—è¡¨å’Œæ•°ç»„ï¼›è¯¦ç»†çš„å¯¹æ¯”è¶…å‡ºäº†æœ¬ä¹¦çš„èŒƒå›´ï¼ˆè¿™äº›ä¿¡æ¯å°†åœ¨æ•°æ®ç»“æ„è¯¾ç¨‹ä¸­ä»‹ç»ï¼‰ã€‚
- en: A Series is an array in which the positions optionally have labels in addition
    to the position numbers.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Series æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œå…¶ä½ç½®é™¤äº†ä½ç½®æ•°å­—å¤–ï¼Œè¿˜å¯ä»¥æœ‰æ ‡ç­¾ã€‚
- en: In Pandas, a row is a Series in which an array of the cell values is labeled
    with the column headers (this is similar to the â€˜Rowâ€˜ datatype in Pyret). A DataFrame
    is a series of these rows.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Pandas ä¸­ï¼Œè¡Œæ˜¯ä¸€ä¸ª Seriesï¼Œå…¶ä¸­å•å…ƒæ ¼å€¼çš„æ•°ç»„è¢«åˆ—æ ‡é¢˜æ ‡è®°ï¼ˆè¿™ä¸ Pyret ä¸­çš„â€œRowâ€æ•°æ®ç±»å‹ç±»ä¼¼ï¼‰ã€‚DataFrame æ˜¯è¿™äº›è¡Œçš„åºåˆ—ã€‚
- en: 10.1.1.2Â Creating and Loading DataFrames[ğŸ”—](#(part._.Creating_and_.Loading_.Data.Frames)
    "Link to here")
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.1.1.2 åˆ›å»ºå’ŒåŠ è½½ DataFrame[ğŸ”—](#(part._.Creating_and_.Loading_.Data.Frames) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'DataFrames can be created manually or loaded in from a file, as we did in Pyret.
    Hereâ€™s a simple example of creating one by hand:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame å¯ä»¥æ‰‹åŠ¨åˆ›å»ºæˆ–ä»æ–‡ä»¶ä¸­åŠ è½½ï¼Œå°±åƒæˆ‘ä»¬åœ¨ Pyret ä¸­åšçš„é‚£æ ·ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªæ‰‹åŠ¨åˆ›å»º DataFrame çš„ç®€å•ç¤ºä¾‹ï¼š
- en: '[PRE37]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`data` is a dictionary that maps column names to values. Calling `pd.DataFrame`
    creates a DataFrame from the dictionary. (There are other ways to create DataFrames
    manually which you can find by searching online.)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`data` æ˜¯ä¸€ä¸ªå°†åˆ—åæ˜ å°„åˆ°å€¼çš„å­—å…¸ã€‚è°ƒç”¨ `pd.DataFrame` ä»å­—å…¸ä¸­åˆ›å»º DataFrameã€‚ï¼ˆè¿˜æœ‰å…¶ä»–åˆ›å»º DataFrame çš„æ–¹æ³•ï¼Œæ‚¨å¯ä»¥é€šè¿‡åœ¨çº¿æœç´¢æ‰¾åˆ°å®ƒä»¬ã€‚ï¼‰'
- en: 'To load a DataFrame from a CSV file, you need either the path to the file on
    your computer or the url where you can get the CSV file online. Hereâ€™s an example
    of the url version. In this example, we have the following CSV contents and we
    want to change the header names when loading the file:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: è¦ä» CSV æ–‡ä»¶ä¸­åŠ è½½ DataFrameï¼Œæ‚¨éœ€è¦æ‚¨çš„è®¡ç®—æœºä¸Šçš„æ–‡ä»¶è·¯å¾„æˆ–å¯ä»¥åœ¨çº¿è·å– CSV æ–‡ä»¶çš„ URLã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ª URL ç‰ˆæœ¬çš„ç¤ºä¾‹ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬æœ‰ä»¥ä¸‹
    CSV å†…å®¹ï¼Œæˆ‘ä»¬å¸Œæœ›åœ¨åŠ è½½æ–‡ä»¶æ—¶æ›´æ”¹æ ‡é¢˜åç§°ï¼š
- en: The following `read_csv` command says that the CSV file is at `url`, that there
    are headers in the first row (numbered `0`), and that we want to use the values
    in `names` as the column labels (this will ignore whatever might be in the header
    row in the CSV file).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹ `read_csv` å‘½ä»¤è¯´æ˜ CSV æ–‡ä»¶ä½äº `url`ï¼Œç¬¬ä¸€è¡Œæœ‰æ ‡é¢˜ï¼ˆç¼–å·ä¸º `0`ï¼‰ï¼Œå¹¶ä¸”æˆ‘ä»¬å¸Œæœ›ä½¿ç”¨ `names` ä¸­çš„å€¼ä½œä¸ºåˆ—æ ‡ç­¾ï¼ˆè¿™å°†å¿½ç•¥
    CSV æ–‡ä»¶æ ‡é¢˜è¡Œä¸­å¯èƒ½å­˜åœ¨çš„ä»»ä½•å†…å®¹ï¼‰ã€‚
- en: '[PRE38]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If we wanted to use the headers in the CSV file as the column headers, we would
    leave out the `names=[...]` part. If the CSV had no header row, we would write
    `header=None` instead of `header=0`. (There are many more configuration options
    in the [Pandas documentation](https://Pandas.pydata.org/docs/reference/api/Pandas.read_csv.html),
    but you wonâ€™t need them for the examples in this book.)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æƒ³ä½¿ç”¨ CSV æ–‡ä»¶ä¸­çš„æ ‡é¢˜ä½œä¸ºåˆ—æ ‡é¢˜ï¼Œæˆ‘ä»¬å°†çœç•¥ `names=[...]` éƒ¨åˆ†ã€‚å¦‚æœ CSV æ²¡æœ‰æ ‡é¢˜è¡Œï¼Œæˆ‘ä»¬å°†å†™ `header=None`
    è€Œä¸æ˜¯ `header=0`ã€‚ï¼ˆåœ¨ [Pandas æ–‡æ¡£](https://Pandas.pydata.org/docs/reference/api/Pandas.read_csv.html)
    ä¸­æœ‰æ›´å¤šé…ç½®é€‰é¡¹ï¼Œä½†æ‚¨ä¸éœ€è¦è¿™äº›é€‰é¡¹æ¥å¤„ç†æœ¬ä¹¦ä¸­çš„ç¤ºä¾‹ã€‚ï¼‰
- en: 'Conceptually, the loaded DataFrame is as follows, with the labels shown in
    blue and the indicies (positions) show in yellow:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ä»æ¦‚å¿µä¸Šè®²ï¼ŒåŠ è½½çš„ DataFrame å¦‚ä¸‹æ‰€ç¤ºï¼Œæ ‡ç­¾ä»¥è“è‰²æ˜¾ç¤ºï¼Œç´¢å¼•ï¼ˆä½ç½®ï¼‰ä»¥é»„è‰²æ˜¾ç¤ºï¼š
- en: '![](../Images/d63a7003f02c1f4bfd00ac93817af463.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d63a7003f02c1f4bfd00ac93817af463.png)'
- en: Since we did not specify labels for the rows, Pandas has used numeric labels
    by default. At the moment, the positions and the labels are the same for each
    row, but we will see that this is not always the case.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºæˆ‘ä»¬æ²¡æœ‰ä¸ºè¡ŒæŒ‡å®šæ ‡ç­¾ï¼ŒPandas é»˜è®¤ä½¿ç”¨äº†æ•°å­—æ ‡ç­¾ã€‚ç›®å‰ï¼Œæ¯è¡Œçš„ä½ç½®å’Œæ ‡ç­¾æ˜¯ç›¸åŒçš„ï¼Œä½†æˆ‘ä»¬å°†çœ‹åˆ°è¿™å¹¶ä¸æ€»æ˜¯å¦‚æ­¤ã€‚
- en: (If you look at the actual loaded table, some of the blank cells in the discount
    column will contain `NaN`, which is the standard Python value for â€œmissing informationâ€.
    We will deal with that information shortly.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆå¦‚æœæ‚¨æŸ¥çœ‹å®é™…åŠ è½½çš„è¡¨æ ¼ï¼ŒæŠ˜æ‰£åˆ—ä¸­çš„ä¸€äº›ç©ºç™½å•å…ƒæ ¼å°†åŒ…å« `NaN`ï¼Œè¿™æ˜¯ Python ä¸­â€œç¼ºå¤±ä¿¡æ¯â€çš„æ ‡å‡†å€¼ã€‚æˆ‘ä»¬å°†åœ¨ç¨åå¤„ç†è¿™äº›ä¿¡æ¯ã€‚ï¼‰
- en: 10.1.1.3Â Using Labels and Indices to Access Cells[ğŸ”—](#(part._.Using_.Labels_and_.Indices_to_.Access_.Cells)
    "Link to here")
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.1.1.3 ä½¿ç”¨æ ‡ç­¾å’Œç´¢å¼•è®¿é—®å•å…ƒæ ¼[ğŸ”—](#(part._.Using_.Labels_and_.Indices_to_.Access_.Cells)
    "é“¾æ¥è‡³æ­¤")
- en: 'Rows, columns, and cells can be accessed using either their (numeric) positions
    or their labels. Here are some examples:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: è¡Œã€åˆ—å’Œå•å…ƒæ ¼å¯ä»¥é€šè¿‡å®ƒä»¬çš„ï¼ˆæ•°å­—ï¼‰ä½ç½®æˆ–æ ‡ç­¾æ¥è®¿é—®ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›ç¤ºä¾‹ï¼š
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Notice that we used different notation for accessing a cell depending on whether
    we accessed the row first or the column first. This is because we are showing
    you how to access data through either position indices or labels. Using `.loc`
    tells Pandas that you are using a label to access a row. If you want to use the
    position instead, you need to use `iloc` (the `i` stands for â€œintegerâ€). If you
    are using a programmer-supplied label instead, you can just use the label directly.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬æ ¹æ®æ˜¯å…ˆè®¿é—®è¡Œè¿˜æ˜¯å…ˆè®¿é—®åˆ—æ¥ä½¿ç”¨ä¸åŒçš„ç¬¦å·æ¥è®¿é—®å•å…ƒæ ¼ã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬æ­£åœ¨å‘æ‚¨å±•ç¤ºå¦‚ä½•é€šè¿‡ä½ç½®ç´¢å¼•æˆ–æ ‡ç­¾æ¥è®¿é—®æ•°æ®ã€‚ä½¿ç”¨ `.loc` å‘Šè¯‰ Pandas
    æ‚¨æ­£åœ¨ä½¿ç”¨æ ‡ç­¾æ¥è®¿é—®è¡Œã€‚å¦‚æœæ‚¨æƒ³ä½¿ç”¨ä½ç½®ï¼Œåˆ™éœ€è¦ä½¿ç”¨ `iloc`ï¼ˆ`i` ä»£è¡¨â€œæ•´æ•°â€ï¼‰ã€‚å¦‚æœæ‚¨æ­£åœ¨ä½¿ç”¨ç¨‹åºå‘˜æä¾›çš„æ ‡ç­¾ï¼Œåˆ™å¯ä»¥ç›´æ¥ä½¿ç”¨è¯¥æ ‡ç­¾ã€‚
- en: In a DataFrame, both rows and columns always have position indices and may have
    labels. The `.loc` notation works on either rows or columns, we just happened
    to illustrate the notation on the rows since we had already created labels on
    the columns when we loaded `events`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ DataFrame ä¸­ï¼Œè¡Œå’Œåˆ—å§‹ç»ˆéƒ½æœ‰ä½ç½®ç´¢å¼•ï¼Œå¹¶ä¸”å¯èƒ½å…·æœ‰æ ‡ç­¾ã€‚`.loc` ç¬¦å·é€‚ç”¨äºè¡Œæˆ–åˆ—ï¼Œæˆ‘ä»¬åªæ˜¯ç¢°å·§åœ¨è¡Œä¸Šè¯´æ˜äº†è¿™ä¸ªç¬¦å·ï¼Œå› ä¸ºæˆ‘ä»¬åŠ è½½ `events`
    æ—¶å·²ç»åœ¨åˆ—ä¸Šåˆ›å»ºäº†æ ‡ç­¾ã€‚
- en: 10.1.2Â Filtering Rows[ğŸ”—](#(part._.Filtering_.Rows) "Link to here")
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.2 è¿‡æ»¤è¡Œ[ğŸ”—](#(part._.Filtering_.Rows) "é“¾æ¥è‡³æ­¤")
- en: Back in Pyret, we filtered rows from a table by writing a function from `Row`
    to `Boolean`. The `filter-with` function applied that function to every row in
    the table, returning a new table with those rows for which the predicate were
    true.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Pyret ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡ç¼–å†™ä» `Row` åˆ° `Boolean` çš„å‡½æ•°æ¥è¿‡æ»¤è¡¨æ ¼ä¸­çš„è¡Œã€‚`filter-with` å‡½æ•°å°†è¯¥å‡½æ•°åº”ç”¨äºè¡¨æ ¼ä¸­çš„æ¯ä¸€è¡Œï¼Œè¿”å›ä¸€ä¸ªæ–°è¡¨æ ¼ï¼Œå…¶ä¸­åŒ…å«é‚£äº›è°“è¯ä¸ºçœŸçš„è¡Œã€‚
- en: In Pandas, we select rows by providing an array of Booleans that has the same
    length as the number of rows in the DataFrame. Filtering keeps those rows for
    which the corresponding array entry is `True`. For example, hereâ€™s our DataFrame
    diagram from before, this time with an array to the right indicating that we want
    to keep rows 0, 2, and 6.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Pandas ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡æä¾›ä¸€ä¸ªä¸ DataFrame ä¸­è¡Œæ•°ç›¸åŒçš„å¸ƒå°”æ•°ç»„æ¥é€‰æ‹©è¡Œã€‚è¿‡æ»¤ä¿ç•™é‚£äº›å¯¹åº”æ•°ç»„æ¡ç›®ä¸º `True` çš„è¡Œã€‚ä¾‹å¦‚ï¼Œè¿™æ˜¯ä¹‹å‰æˆ‘ä»¬çš„
    DataFrame å›¾è¡¨ï¼Œè¿™æ¬¡å³ä¾§æœ‰ä¸€ä¸ªæ•°ç»„è¡¨ç¤ºæˆ‘ä»¬å¸Œæœ›ä¿ç•™è¡Œ 0ã€2 å’Œ 6ã€‚
- en: '![](../Images/0958f43b8192439a6fd898de3fbe50fb.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0958f43b8192439a6fd898de3fbe50fb.png)'
- en: 'The â€œkeepâ€ array is not part of the DataFrame. Here is the corresponding array
    expressed in code, followed by the notation to use the array to filter the DataFrame:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: â€œä¿ç•™â€æ•°ç»„ä¸æ˜¯ DataFrame çš„ä¸€éƒ¨åˆ†ã€‚ä»¥ä¸‹æ˜¯ç›¸åº”çš„æ•°ç»„åœ¨ä»£ç ä¸­çš„è¡¨ç¤ºï¼Œåé¢è·Ÿç€ä½¿ç”¨è¯¥æ•°ç»„æ¥è¿‡æ»¤ DataFrame çš„ç¬¦å·ï¼š
- en: '[PRE40]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Once we have the array of booleans, we use it to extract a collection of rows
    using similar notation that we previously used to extract a column. Just as we
    wrote `events[''numtix'']` to select the `''numtix''` column, we can write `events[keep]`
    to select a collection of rows. The DataFrame that results from filtering (along
    with the `True` cells of the `keep` array for illustration) appears as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æˆ‘ä»¬æœ‰äº†å¸ƒå°”æ•°ç»„ï¼Œæˆ‘ä»¬å°±ä½¿ç”¨å®ƒæ¥æå–ä¸€ç³»åˆ—è¡Œï¼Œä½¿ç”¨ä¸ä¹‹å‰ç”¨äºæå–åˆ—ç›¸ä¼¼çš„ç¬¦å·ã€‚å°±åƒæˆ‘ä»¬å†™ `events['numtix']` æ¥é€‰æ‹© `'numtix'`
    åˆ—ä¸€æ ·ï¼Œæˆ‘ä»¬å¯ä»¥å†™ `events[keep]` æ¥é€‰æ‹©ä¸€ç³»åˆ—è¡Œã€‚è¿‡æ»¤åçš„ DataFrameï¼ˆä»¥åŠ `keep` æ•°ç»„çš„ `True` å•å…ƒç”¨äºè¯´æ˜ï¼‰å¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '![](../Images/0baa50e0adf5a889a71a977667d9c7e9.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0baa50e0adf5a889a71a977667d9c7e9.png)'
- en: 'How does Pandas know whether we want to select rows or columns? It depends
    on what we provide in the square brackets: if we provide a single label, we get
    the column or row with that label; if we provide an array of booleans, we get
    the rows for which the corresponding row (by position) is `True`.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas å¦‚ä½•çŸ¥é“æˆ‘ä»¬æƒ³è¦é€‰æ‹©è¡Œè¿˜æ˜¯åˆ—ï¼Ÿè¿™å–å†³äºæˆ‘ä»¬åœ¨æ–¹æ‹¬å·ä¸­æä¾›äº†ä»€ä¹ˆï¼šå¦‚æœæˆ‘ä»¬æä¾›ä¸€ä¸ªå•ä¸ªæ ‡ç­¾ï¼Œæˆ‘ä»¬å°±å¾—åˆ°å…·æœ‰è¯¥æ ‡ç­¾çš„åˆ—æˆ–è¡Œï¼›å¦‚æœæˆ‘ä»¬æä¾›ä¸€ä¸ªå¸ƒå°”æ•°ç»„ï¼Œæˆ‘ä»¬å°±å¾—åˆ°é‚£äº›å¯¹åº”è¡Œï¼ˆæŒ‰ä½ç½®ï¼‰ä¸º
    `True` çš„è¡Œã€‚
- en: Do Now!
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Look at the returned DataFrame. Do you notice anything interesting?
  id: totrans-274
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: çœ‹çœ‹è¿”å›çš„ DataFrameã€‚ä½ æ³¨æ„åˆ°ä»€ä¹ˆæœ‰è¶£çš„åœ°æ–¹å—ï¼Ÿ
- en: 'Look at the row labels and indices: the labels have been retained from the
    original DataFrame (0, 2, and 6), while the indices are a sequence of consecutive
    numbers starting from 0\. Having both ways to reference rowsâ€”<wbr>one based on
    raw order and the other based on programmer-provided labelsâ€”<wbr>provides a lot
    of flexibility as we use filter to isolate parts of tables that we want to work
    on.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: çœ‹çœ‹è¡Œæ ‡ç­¾å’Œç´¢å¼•ï¼šæ ‡ç­¾å·²ç»ä¿ç•™è‡ªåŸå§‹ DataFrameï¼ˆ0ã€2 å’Œ 6ï¼‰ï¼Œè€Œç´¢å¼•æ˜¯ä» 0 å¼€å§‹çš„è¿ç»­æ•°å­—åºåˆ—ã€‚æ‹¥æœ‰ä¸¤ç§å¼•ç”¨è¡Œçš„æ–¹å¼â€”â€”åŸºäºåŸå§‹é¡ºåºçš„ä¸€ä¸ªå’ŒåŸºäºç¨‹åºå‘˜æä¾›çš„æ ‡ç­¾çš„ä¸€ä¸ªâ€”â€”åœ¨æˆ‘ä»¬ä½¿ç”¨è¿‡æ»¤å™¨éš”ç¦»æˆ‘ä»¬æƒ³è¦å·¥ä½œçš„è¡¨çš„éƒ¨åˆ†æ—¶æä¾›äº†å¾ˆå¤§çš„çµæ´»æ€§ã€‚
- en: Do Now!
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does filtering rows this way in Python keep the original `events` DataFrame
    intact? Try it out!
  id: totrans-278
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨ Python ä¸­è¿™æ ·è¿‡æ»¤è¡Œæ˜¯å¦ä¼šä¿æŒåŸå§‹çš„ `events` DataFrame å®Œæ•´ï¼Ÿè¯•ä¸€è¯•ï¼
- en: Arrays of booleans that are used for filtering out other arrays are called masks.
    Here, we have shown a simple mask that we constructed by hand. If we had a long
    DataFrame, however, we would not want to construct a mask for it by hand. Fortunately,
    we donâ€™t have to. Python provides notations that let us construct masks via expressions
    over a series.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ç”¨äºè¿‡æ»¤å…¶ä»–æ•°ç»„çš„å¸ƒå°”æ•°ç»„è¢«ç§°ä¸ºæ©ç ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å±•ç¤ºäº†æˆ‘ä»¬æ‰‹åŠ¨æ„å»ºçš„ä¸€ä¸ªç®€å•æ©ç ã€‚ç„¶è€Œï¼Œå¦‚æœæˆ‘ä»¬æœ‰ä¸€ä¸ªå¾ˆé•¿çš„ DataFrameï¼Œæˆ‘ä»¬å°±ä¸æƒ³æ‰‹åŠ¨æ„å»ºä¸€ä¸ªæ©ç ã€‚å¹¸è¿çš„æ˜¯ï¼Œæˆ‘ä»¬ä¸å¿…è¿™æ ·åšã€‚Python
    æä¾›äº†é€šè¿‡åºåˆ—ä¸Šçš„è¡¨è¾¾å¼æ„å»ºæ©ç çš„ç¬¦å·ã€‚
- en: 'Imagine that we wanted to filter the `events` table down to those rows with
    delivery method `''email''`. To create a mask for this, we first select the delivery
    column as a series:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬æƒ³è¦å°† `events` è¡¨è¿‡æ»¤åˆ°é‚£äº›ä½¿ç”¨ `'email'` äº¤ä»˜æ–¹å¼è¡Œçš„ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬é¦–å…ˆå°†äº¤ä»˜åˆ—ä½œä¸ºä¸€ä¸ªåºåˆ—é€‰æ‹©ï¼š
- en: '[PRE41]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we use the series in a boolean expression that states the constraint
    that we want on each element of the series:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬ä½¿ç”¨è¿™ä¸ªåºåˆ—åœ¨å¸ƒå°”è¡¨è¾¾å¼ä¸­å£°æ˜æˆ‘ä»¬æƒ³è¦å¯¹åºåˆ—ä¸­æ¯ä¸ªå…ƒç´ æ–½åŠ çš„çº¦æŸï¼š
- en: '[PRE42]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Wait, whatâ€™s going on here? `events['deliver']` is a Series (a labeled array
    of strings). `'email'` is a string. What does it even mean to ask whether two
    values of different types be considered equal, especially when one has many component
    values and the other does not?
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ç­‰ç­‰ï¼Œè¿™é‡Œå‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿ`events['deliver']` æ˜¯ä¸€ä¸ªåºåˆ—ï¼ˆä¸€ä¸ªæ ‡è®°çš„å­—ç¬¦ä¸²æ•°ç»„ï¼‰ã€‚`'email'` æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚è¯¢é—®ä¸¤ä¸ªä¸åŒç±»å‹çš„å€¼æ˜¯å¦ç›¸ç­‰æœ‰ä»€ä¹ˆæ„ä¹‰ï¼Œå°¤å…¶æ˜¯å½“å…¶ä¸­ä¸€ä¸ªæœ‰å¤šä¸ªç»„ä»¶å€¼è€Œå¦ä¸€ä¸ªæ²¡æœ‰æ—¶ï¼Ÿ
- en: In this case, the `==` doesnâ€™t mean â€œare these equalâ€? Instead, Python applies
    `== 'email'` to every element of the `events['delivery']` Series, constructing
    a new Series of the results. This idea of applying an operation to all elements
    of an array is known as â€œliftingâ€. It is one of the shortcuts that Python provides
    to help experienced programmers do simple common tasks quickly and easily.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ`==` å¹¶ä¸æ„å‘³ç€â€œå®ƒä»¬ç›¸ç­‰â€ï¼Ÿç›¸åï¼ŒPython å°† `== 'email'` åº”ç”¨åˆ° `events['delivery']` åºåˆ—çš„æ¯ä¸ªå…ƒç´ ä¸Šï¼Œæ„å»ºä¸€ä¸ªæ–°çš„ç»“æœåºåˆ—ã€‚å°†æ“ä½œåº”ç”¨äºæ•°ç»„æ‰€æœ‰å…ƒç´ çš„æƒ³æ³•è¢«ç§°ä¸ºâ€œæå‡â€ã€‚è¿™æ˜¯
    Python æä¾›çš„å¿«æ·æ–¹å¼ä¹‹ä¸€ï¼Œä»¥å¸®åŠ©ç»éªŒä¸°å¯Œçš„ç¨‹åºå‘˜å¿«é€Ÿè½»æ¾åœ°å®Œæˆç®€å•å¸¸è§ä»»åŠ¡ã€‚
- en: 'Now that we have a Series of booleans (for which events will be picked up by
    email), we can use it to select those rows from the `events` DataFrame:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æœ‰ä¸€ä¸ªå¸ƒå°”å€¼åºåˆ—ï¼ˆç”¨äºé€šè¿‡ç”µå­é‚®ä»¶é€‰æ‹©äº‹ä»¶ï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥é€‰æ‹© `events` DataFrame ä¸­çš„è¿™äº›è¡Œï¼š
- en: '[PRE43]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The inner use of `events` is for creating the mask, while the outer one is for
    filtering the table with that mask.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: å†…éƒ¨çš„`events`ç”¨äºåˆ›å»ºæ©ç ï¼Œè€Œå¤–éƒ¨çš„`events`ç”¨äºä½¿ç”¨è¯¥æ©ç è¿‡æ»¤è¡¨æ ¼ã€‚
- en: 'As a warning: if you search online for information on how to filter or process
    DataFrame, you might find code samples that do this using for loops. While that
    approach works, it isnâ€™t considered good Pandas (or general programming) practice.
    Most modern languages provide built-in constructs for iterating over lists and
    other sequence-style data. These operations have more descriptive names than generic
    loops (which makes them easier for other programmers to read), and are often engineered
    to run more efficiently under the hood. As a general rule, only default to basic
    loops if there is no built-in operator to do the computation that you have in
    mind.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºè­¦å‘Šï¼šå¦‚æœä½ åœ¨ç½‘ä¸Šæœç´¢æœ‰å…³å¦‚ä½•è¿‡æ»¤æˆ–å¤„ç†DataFrameçš„ä¿¡æ¯ï¼Œä½ å¯èƒ½ä¼šæ‰¾åˆ°ä½¿ç”¨å¾ªç¯è¿›è¡Œæ­¤æ“ä½œçš„ä»£ç ç¤ºä¾‹ã€‚è™½ç„¶è¿™ç§æ–¹æ³•å¯è¡Œï¼Œä½†å¹¶ä¸è¢«è®¤ä¸ºæ˜¯å¥½çš„Pandasï¼ˆæˆ–é€šç”¨ç¼–ç¨‹ï¼‰å®è·µã€‚å¤§å¤šæ•°ç°ä»£è¯­è¨€éƒ½æä¾›äº†ç”¨äºéå†åˆ—è¡¨å’Œå…¶ä»–åºåˆ—å¼æ•°æ®çš„å†…ç½®æ„é€ ã€‚è¿™äº›æ“ä½œå…·æœ‰æ¯”é€šç”¨å¾ªç¯æ›´å…·æœ‰æè¿°æ€§çš„åç§°ï¼ˆè¿™ä½¿å¾—å…¶ä»–ç¨‹åºå‘˜æ›´å®¹æ˜“é˜…è¯»ï¼‰ï¼Œå¹¶ä¸”é€šå¸¸åœ¨åº•å±‚è¿è¡Œå¾—æ›´é«˜æ•ˆã€‚ä¸€èˆ¬æ¥è¯´ï¼Œåªæœ‰åœ¨ä½ æ²¡æœ‰å†…ç½®è¿ç®—ç¬¦æ¥å®Œæˆä½ å¿ƒä¸­çš„è®¡ç®—æ—¶ï¼Œæ‰é»˜è®¤ä½¿ç”¨åŸºæœ¬å¾ªç¯ã€‚
- en: 10.1.3Â Cleaning and Normalizing Data[ğŸ”—](#(part._.Cleaning_and_.Normalizing_.Data)
    "Link to here")
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.3 æ¸…ç†å’Œå½’ä¸€åŒ–æ•°æ®[ğŸ”—](#(part._.Cleaning_and_.Normalizing_.Data) "é“¾æ¥è‡³æ­¤")
- en: 'The same operator-lifting idea that we just saw when creating masks from DataFrames
    also comes into play for normalizing data. Recall that when we worked with the
    `events` table in Pyret, we converted all of the discount codes to lowercase.
    Hereâ€™s the code that does this in Pandas:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åˆšæ‰åœ¨ä»DataFrameåˆ›å»ºæ©ç æ—¶çœ‹åˆ°çš„ç›¸åŒçš„æ“ä½œç¬¦æå‡æƒ³æ³•ä¹Ÿé€‚ç”¨äºæ•°æ®å½’ä¸€åŒ–ã€‚å›æƒ³ä¸€ä¸‹ï¼Œå½“æˆ‘ä»¬ä½¿ç”¨Pyretä¸­çš„`events`è¡¨æ—¶ï¼Œæˆ‘ä»¬å°†æ‰€æœ‰çš„æŠ˜æ‰£ä»£ç è½¬æ¢ä¸ºå°å†™ã€‚ä»¥ä¸‹æ˜¯Pandasä¸­æ‰§è¡Œæ­¤æ“ä½œçš„ä»£ç ï¼š
- en: '[PRE44]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Do Now!
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Look at the above code. Break it down and try to articulate what each part does.
    Do any parts seem new or different from things weâ€™ve done so far in Pandas?
  id: totrans-295
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: çœ‹çœ‹ä¸Šé¢çš„ä»£ç ã€‚åˆ†è§£å®ƒå¹¶å°è¯•é˜è¿°æ¯ä¸ªéƒ¨åˆ†çš„ä½œç”¨ã€‚æ˜¯å¦æœ‰ä»»ä½•éƒ¨åˆ†çœ‹èµ·æ¥æ˜¯æ–°çš„æˆ–ä¸æˆ‘ä»¬åœ¨Pandasä¸­è¿„ä»Šä¸ºæ­¢æ‰€åšçš„ä¸œè¥¿ä¸åŒï¼Ÿ
- en: On the right side of the `=`, we are extracting the Series of discount codes
    (`events['discount']`), then using the lowercase operation on strings `str.lower()`
    to convert each one, building up a Series of the results. Normally, given a string
    (such as `'BIRTHDAY'`), we could get a lowercase version of it by writing just
    `'BIRTHDAY'.lower()`. Whatâ€™s the extra `str` doing in there?
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç­‰å·`=`çš„å³ä¾§ï¼Œæˆ‘ä»¬æ­£åœ¨æå–æŠ˜æ‰£ä»£ç çš„åºåˆ—(`events['discount']`)ï¼Œç„¶åä½¿ç”¨å­—ç¬¦ä¸²çš„`str.lower()`å°å†™æ“ä½œå°†æ¯ä¸ªä»£ç è½¬æ¢ä¸ºå°å†™ï¼Œä»è€Œæ„å»ºä¸€ä¸ªç»“æœçš„åºåˆ—ã€‚é€šå¸¸ï¼Œç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼ˆä¾‹å¦‚`'BIRTHDAY'`ï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ç®€å•åœ°ç¼–å†™`'BIRTHDAY'.lower()`æ¥è·å–å®ƒçš„å°å†™ç‰ˆæœ¬ã€‚é‚£ä¹ˆï¼Œè¿™é‡Œçš„é¢å¤–`str`æœ‰ä»€ä¹ˆä½œç”¨å‘¢ï¼Ÿ
- en: This is a nuance about lifting. Python can evaluate `'BIRTHDAY'.lower()` because
    `lower()` is defined directly on strings. `lower()` is not, however, directly
    defined on Series. To bridge the gap between having Series data and wanting to
    use a string operation on it, we insert `str` before `lower()`. Effectively, this
    tells Python where to find the `lower()` operation (in the collection of operations
    defined on strings).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªæå‡çš„ç»†å¾®å·®åˆ«ã€‚Pythonå¯ä»¥è¯„ä¼°`'BIRTHDAY'.lower()`ï¼Œå› ä¸º`lower()`æ˜¯åœ¨å­—ç¬¦ä¸²ä¸Šç›´æ¥å®šä¹‰çš„ã€‚ç„¶è€Œï¼Œ`lower()`å¹¶ä¸æ˜¯åœ¨Seriesä¸Šç›´æ¥å®šä¹‰çš„ã€‚ä¸ºäº†åœ¨æ‹¥æœ‰Seriesæ•°æ®å’Œæƒ³è¦å¯¹å…¶æ‰§è¡Œå­—ç¬¦ä¸²æ“ä½œä¹‹é—´æ¶èµ·æ¡¥æ¢ï¼Œæˆ‘ä»¬åœ¨`lower()`ä¹‹å‰æ’å…¥`str`ã€‚å®é™…ä¸Šï¼Œè¿™å‘Šè¯‰Pythonåœ¨å“ªé‡Œå¯ä»¥æ‰¾åˆ°`lower()`æ“ä½œï¼ˆåœ¨å®šä¹‰åœ¨å­—ç¬¦ä¸²ä¸Šçš„æ“ä½œé›†åˆä¸­ï¼‰ã€‚
- en: 'The left side of the above code looks like:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šè¿°ä»£ç çš„å·¦ä¾§çœ‹èµ·æ¥åƒï¼š
- en: '[PRE45]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This tells Pandas to replace the current contents of the `''discount''` series
    with the series on the right side of the `=`. It is similar to `transform-column`
    from Pyret, but with a fundamental difference: in Pyret, `transform-column` left
    the old table intact and produced a new table with the new column values. Instead,
    in Pandas the old column gets replaced, thus destroying the original table. There
    are many nuances to having operations destroy and replace data; the chapter on
    [Mutating Structures](mutating-structures.html) studies them in detail.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å‘Šè¯‰Pandasç”¨ç­‰å·å³ä¾§çš„åºåˆ—æ›¿æ¢`'discount'`åºåˆ—çš„å½“å‰å†…å®¹ã€‚è¿™ä¸Pyretä¸­çš„`transform-column`ç±»ä¼¼ï¼Œä½†æœ‰ä¸€ä¸ªåŸºæœ¬åŒºåˆ«ï¼šåœ¨Pyretä¸­ï¼Œ`transform-column`ä¿ç•™äº†æ—§è¡¨å¹¶ç”Ÿæˆäº†å…·æœ‰æ–°åˆ—å€¼çš„æ–°è¡¨ã€‚ç›¸åï¼Œåœ¨Pandasä¸­ï¼Œæ—§åˆ—è¢«æ›¿æ¢ï¼Œä»è€Œç ´åäº†åŸå§‹è¡¨ã€‚æ“ä½œç ´åå’Œæ›¿æ¢æ•°æ®æœ‰è®¸å¤šç»†å¾®å·®åˆ«ï¼›å…³äº[ä¿®æ”¹ç»“æ„](mutating-structures.html)çš„ç« èŠ‚è¯¦ç»†ç ”ç©¶äº†è¿™äº›ã€‚
- en: 10.1.3.1Â Clearing out unknown values[ğŸ”—](#(part._.Clearing_out_unknown_values)
    "Link to here")
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.1.3.1 æ¸…é™¤æœªçŸ¥å€¼[ğŸ”—](#(part._.Clearing_out_unknown_values) "é“¾æ¥è‡³æ­¤")
- en: 'Now letâ€™s try a different cleaning and normalization problem: we want the discount
    column to contain only known discount codes or empty strings. The `none` entry
    in line 3 of the table should be converted to an empty string, and we should make
    sure that all of the `NaN` and seemingly empty entries in the discount cells are
    also converted to empty strings (as opposed to strings of multiple spaces).'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬å°è¯•ä¸€ä¸ªä¸åŒçš„æ¸…ç†å’Œå½’ä¸€åŒ–é—®é¢˜ï¼šæˆ‘ä»¬å¸Œæœ›æŠ˜æ‰£åˆ—åªåŒ…å«å·²çŸ¥çš„æŠ˜æ‰£ä»£ç æˆ–ç©ºå­—ç¬¦ä¸²ã€‚è¡¨æ ¼ç¬¬3è¡Œçš„`none`æ¡ç›®åº”è½¬æ¢ä¸ºç©ºå­—ç¬¦ä¸²ï¼Œå¹¶ä¸”æˆ‘ä»¬åº”ç¡®ä¿å°†æ‰€æœ‰æŠ˜æ‰£å•å…ƒæ ¼ä¸­çš„`NaN`å’Œçœ‹ä¼¼ç©ºç™½çš„æ¡ç›®ä¹Ÿè½¬æ¢ä¸ºç©ºå­—ç¬¦ä¸²ï¼ˆè€Œä¸æ˜¯å¤šä¸ªç©ºæ ¼çš„å­—ç¬¦ä¸²ï¼‰ã€‚
- en: Do Now!
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Plan out how you might do this task using mask expressions. Even if you donâ€™t
    know all the specific notation for the operations you need, you can still work
    out a plan for completing this task.
  id: totrans-305
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è®¡åˆ’å¦‚ä½•ä½¿ç”¨æ©ç è¡¨è¾¾å¼æ¥å®Œæˆè¿™é¡¹ä»»åŠ¡ã€‚å³ä½¿ä½ ä¸çŸ¥é“æ‰€éœ€æ“ä½œçš„æ‰€æœ‰ç‰¹å®šç¬¦å·ï¼Œä½ ä»ç„¶å¯ä»¥åˆ¶å®šä¸€ä¸ªå®Œæˆä»»åŠ¡çš„è®¡åˆ’ã€‚
- en: 'If you planned out the tasks, you might have a todo list like the following:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ å·²ç»è§„åˆ’äº†ä»»åŠ¡ï¼Œä½ å¯èƒ½æœ‰ä¸€ä¸ªå¦‚ä¸‹æ‰€ç¤ºçš„å¾…åŠäº‹é¡¹åˆ—è¡¨ï¼š
- en: create a mask of rows with known discount codes
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åˆ›å»ºä¸€ä¸ªåŒ…å«å·²çŸ¥æŠ˜æ‰£ä»£ç çš„è¡Œçš„æ©ç 
- en: invert that mask (swap the false and true values)
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å–æ¶ˆè¯¥æ©ç ï¼ˆäº¤æ¢å‡å’ŒçœŸå€¼ï¼‰
- en: filter the DataFrame to rows without a known discount code
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è¿‡æ»¤æ‰å…·æœ‰å·²çŸ¥æŠ˜æ‰£ä»£ç çš„è¡Œ
- en: replace all the discount column values in that DataFrame with an empty string
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å°†è¯¥DataFrameä¸­çš„æ‰€æœ‰æŠ˜æ‰£åˆ—å€¼æ›¿æ¢ä¸ºç©ºå­—ç¬¦ä¸²
- en: 'We have seen how to do parts of steps 1 and 3, but neither of steps 2 and 4\.
    Letâ€™s work through the steps one by one:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»çœ‹åˆ°äº†å¦‚ä½•æ‰§è¡Œæ­¥éª¤1å’Œ3çš„éƒ¨åˆ†ï¼Œä½†æ­¥éª¤2å’Œ4éƒ½æ²¡æœ‰æ‰§è¡Œã€‚è®©æˆ‘ä»¬ä¸€æ­¥ä¸€æ­¥åœ°å®Œæˆè¿™äº›æ­¥éª¤ï¼š
- en: 'Hereâ€™s the code for step 1, which creates a mask for the rows with known discount
    codes:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æ­¥éª¤1çš„ä»£ç ï¼Œå®ƒåˆ›å»ºäº†ä¸€ä¸ªåŒ…å«å·²çŸ¥æŠ˜æ‰£ä»£ç çš„è¡Œçš„æ©ç ï¼š
- en: '[PRE46]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, we use a lifted `isin` operator on lists to compute the mask.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨æå‡çš„`isin`è¿ç®—ç¬¦åœ¨åˆ—è¡¨ä¸Šè®¡ç®—æ©ç ã€‚
- en: 'For step 2, we have to swap the true and false values. We can do this by using
    the negation operator `~` on the mask from step 1:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæ­¥éª¤2ï¼Œæˆ‘ä»¬å¿…é¡»äº¤æ¢çœŸå’Œå‡å€¼ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨æ­¥éª¤1çš„æ©ç ä¸Šä½¿ç”¨å¦å®šè¿ç®—ç¬¦`~`æ¥å®Œæˆæ­¤æ“ä½œï¼š
- en: '[PRE47]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For step 3, we want to filter `events` with this mask. Just to keep the code
    easier to read, weâ€™ll give the mask a name and then perform the filter:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºç¬¬3æ­¥ï¼Œæˆ‘ä»¬å¸Œæœ›ä½¿ç”¨è¿™ä¸ªæ©ç æ¥è¿‡æ»¤`äº‹ä»¶`ã€‚ä¸ºäº†ä½¿ä»£ç æ›´å®¹æ˜“é˜…è¯»ï¼Œæˆ‘ä»¬å°†ç»™æ©ç èµ·ä¸€ä¸ªåå­—ï¼Œç„¶åæ‰§è¡Œè¿‡æ»¤æ“ä½œï¼š
- en: '[PRE48]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, we use `=` to set the discount column of the filtered DataFrame to
    the empty string:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæˆ‘ä»¬ä½¿ç”¨`=`æ¥å°†è¿‡æ»¤åçš„DataFrameçš„æŠ˜æ‰£åˆ—è®¾ç½®ä¸ºç©ºå­—ç¬¦ä¸²ï¼š
- en: '[PRE49]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Whoops â€“ this seems to have generated an error message that says something
    about a â€œSettingWithCopyWarningâ€. This is a subtlety that has to do with what
    happens when data gets updated under the hood (weâ€™ll learn about subtleties of
    mutation in [Mutable Lists](mutable-lists.html)). For now, weâ€™ll use this alternate
    form that avoids the error:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: å“å‘€â€”â€”è¿™ä¼¼ä¹ç”Ÿæˆäº†ä¸€ä¸ªé”™è¯¯æ¶ˆæ¯ï¼Œæåˆ°äº†â€œSettingWithCopyWarningâ€ã€‚è¿™æ˜¯ä¸€ä¸ªä¸æ•°æ®åœ¨åº•å±‚æ›´æ–°æ—¶å‘ç”Ÿçš„äº‹æƒ…æœ‰å…³çš„å¾®å¦™ä¹‹å¤„ï¼ˆæˆ‘ä»¬å°†åœ¨[å¯å˜åˆ—è¡¨](mutable-lists.html)ä¸­å­¦ä¹ çªå˜æ€§çš„å¾®å¦™ä¹‹å¤„ï¼‰ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨è¿™ä¸ªé¿å…é”™è¯¯çš„æ›¿ä»£å½¢å¼ï¼š
- en: '[PRE50]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Putting it all together, the entire program looks like:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: å°†æ‰€æœ‰è¿™äº›æ”¾åœ¨ä¸€èµ·ï¼Œæ•´ä¸ªç¨‹åºçœ‹èµ·æ¥å¦‚ä¸‹ï¼š
- en: '[PRE51]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Summarizing, the code pattern for updating values for a column in some rows
    of a DataFrame is as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: æ€»ç»“ï¼Œæ›´æ–°DataFrameä¸­æŸäº›è¡Œåˆ—å€¼çš„ä»£ç æ¨¡å¼å¦‚ä¸‹ï¼š
- en: make a boolean series mask for which rows to update
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸ºè¦æ›´æ–°çš„è¡Œåˆ›å»ºä¸€ä¸ªå¸ƒå°”ç³»åˆ—æ©ç 
- en: use the mask to select just the rows where the mask is true
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨æ©ç é€‰æ‹©ä»…å½“æ©ç ä¸ºçœŸçš„è¡Œ
- en: use `.loc` with the mask and column name to select the series of cells to update
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`.loc`å’Œæ©ç ä»¥åŠåˆ—åæ¥é€‰æ‹©è¦æ›´æ–°çš„å•å…ƒæ ¼ç³»åˆ—
- en: use `=` to give those cells their new value
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`=`ä¸ºè¿™äº›å•å…ƒæ ¼èµ‹äºˆæ–°çš„å€¼
- en: Exercise
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Follow the above pattern to transform all delivery values of `'yes'` to `'pickup'`.
  id: totrans-332
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æŒ‰ç…§ä¸Šè¿°æ¨¡å¼å°†æ‰€æœ‰`'yes'`çš„äº¤ä»˜å€¼è½¬æ¢ä¸º`'pickup'`ã€‚
- en: 10.1.3.2Â Repairing Values and Column Types[ğŸ”—](#(part._.Repairing_.Values_and_.Column_.Types)
    "Link to here")
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.1.3.2Â ä¿®å¤å€¼å’Œåˆ—ç±»å‹[ğŸ”—](#(part._.Repairing_.Values_and_.Column_.Types) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'The source file for the `events` table contained an error in which someone
    entered the string `''three''` in place of the number `3` for the number of tickets
    in the last row. We can repair errors like this manually:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`events`è¡¨çš„æºæ–‡ä»¶ä¸­å­˜åœ¨ä¸€ä¸ªé”™è¯¯ï¼Œæœ‰äººå°†å­—ç¬¦ä¸²`''three''`é”™è¯¯åœ°è¾“å…¥åˆ°æœ€åä¸€è¡Œçš„ç¥¨æ•°`3`çš„ä½ç½®ã€‚æˆ‘ä»¬å¯ä»¥æ‰‹åŠ¨ä¿®å¤è¿™æ ·çš„é”™è¯¯ï¼š'
- en: '[PRE52]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Do Now!
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make this repair and ask your Python environment to show you the corrected table.
  id: totrans-338
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿›è¡Œè¿™æ¬¡ä¿®å¤ï¼Œå¹¶è®©Pythonç¯å¢ƒæ˜¾ç¤ºä¿®æ­£åçš„è¡¨æ ¼ã€‚
- en: 'Now that the `''numtix''` column contains only numbers, we can total the number
    of tickets that were sold:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œ`'numtix'`åˆ—åªåŒ…å«æ•°å­—ï¼Œæˆ‘ä»¬å¯ä»¥è®¡ç®—å·²å”®å‡ºçš„ç¥¨æ•°æ€»å’Œï¼š
- en: '[PRE53]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Do Now!
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What did you get? Why?
  id: totrans-343
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ å¾—åˆ°äº†ä»€ä¹ˆï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ
- en: 'Because Python environments print strings without quotation marks, the numtix
    column appears to contain numbers. The failure of `sum` shows that this is indeed
    not the case. We can inspect the types that Python has determined for the numtix
    values using the `type` operation:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äº Python ç¯å¢ƒåœ¨æ‰“å°å­—ç¬¦ä¸²æ—¶ä¸ä½¿ç”¨å¼•å·ï¼Œå› æ­¤çœ‹èµ·æ¥ numtix åˆ—åŒ…å«æ•°å­—ã€‚`sum` å‡½æ•°çš„å¤±è´¥è¡¨æ˜è¿™ç¡®å®ä¸æ˜¯æƒ…å†µã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `type`
    æ“ä½œæ¥æ£€æŸ¥ Python ä¸º numtix å€¼ç¡®å®šçš„ç±»å‹ï¼š
- en: '[PRE54]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: What happened here? During the original call to `read_csv`, Python detected
    both numeric and string data in the numtix column. It therefore read in all the
    values as strings. Our manual repair that replaced the string `'three'` with the
    number `3` fixed the value and type for one row, but the remaining values in that
    column have still been read in as integers.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œå‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿåœ¨åŸå§‹è°ƒç”¨ `read_csv` æ—¶ï¼ŒPython åœ¨ numtix åˆ—ä¸­æ£€æµ‹åˆ°æ•°å­—å’Œå­—ç¬¦ä¸²æ•°æ®ã€‚å› æ­¤ï¼Œå®ƒå°†æ‰€æœ‰å€¼ä½œä¸ºå­—ç¬¦ä¸²è¯»å…¥ã€‚æˆ‘ä»¬æ‰‹åŠ¨ä¿®å¤å°†å­—ç¬¦ä¸²
    `'three'` æ›¿æ¢ä¸ºæ•°å­— `3` çš„æ“ä½œä¿®å¤äº†ä¸€è¡Œçš„å€¼å’Œç±»å‹ï¼Œä½†è¯¥åˆ—ä¸­å‰©ä½™çš„å€¼ä»ç„¶è¢«è¯»å…¥ä¸ºæ•´æ•°ã€‚
- en: Fortunately, Python provides an operation to change the type of data within
    a series. The following code converts the values in the `events['numtix']` series
    to integers, updating the series within the DataFrame in the process.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¸è¿çš„æ˜¯ï¼ŒPython æä¾›äº†ä¸€ä¸ªæ“ä½œæ¥æ›´æ”¹åºåˆ—ä¸­çš„æ•°æ®ç±»å‹ã€‚ä»¥ä¸‹ä»£ç å°† `events['numtix']` åºåˆ—ä¸­çš„å€¼è½¬æ¢ä¸ºæ•´æ•°ï¼Œå¹¶åœ¨è¿‡ç¨‹ä¸­æ›´æ–° DataFrame
    ä¸­çš„åºåˆ—ã€‚
- en: '[PRE55]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 10.1.3.1Â Clearing out unknown values[ğŸ”—](#(part._.Clearing_out_unknown_values)
    "Link to here")
  id: totrans-349
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.1.3.1 æ¸…é™¤æœªçŸ¥å€¼[ğŸ”—](#(part._.Clearing_out_unknown_values) "é“¾æ¥è‡³æ­¤")
- en: 'Now letâ€™s try a different cleaning and normalization problem: we want the discount
    column to contain only known discount codes or empty strings. The `none` entry
    in line 3 of the table should be converted to an empty string, and we should make
    sure that all of the `NaN` and seemingly empty entries in the discount cells are
    also converted to empty strings (as opposed to strings of multiple spaces).'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬å°è¯•ä¸€ä¸ªä¸åŒçš„æ¸…ç†å’Œå½’ä¸€åŒ–é—®é¢˜ï¼šæˆ‘ä»¬å¸Œæœ›æŠ˜æ‰£åˆ—åªåŒ…å«å·²çŸ¥çš„æŠ˜æ‰£ä»£ç æˆ–ç©ºå­—ç¬¦ä¸²ã€‚è¡¨æ ¼ç¬¬ 3 è¡Œçš„ `none` æ¡ç›®åº”è½¬æ¢ä¸ºç©ºå­—ç¬¦ä¸²ï¼Œå¹¶ä¸”æˆ‘ä»¬åº”ç¡®ä¿æŠ˜æ‰£å•å…ƒæ ¼ä¸­æ‰€æœ‰
    `NaN` å’Œçœ‹ä¼¼ç©ºç™½çš„æ¡ç›®ä¹Ÿè½¬æ¢ä¸ºç©ºå­—ç¬¦ä¸²ï¼ˆè€Œä¸æ˜¯å¤šä¸ªç©ºæ ¼çš„å­—ç¬¦ä¸²ï¼‰ã€‚
- en: Do Now!
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Plan out how you might do this task using mask expressions. Even if you donâ€™t
    know all the specific notation for the operations you need, you can still work
    out a plan for completing this task.
  id: totrans-353
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è®¡åˆ’å¦‚ä½•ä½¿ç”¨æ©ç è¡¨è¾¾å¼æ¥å®Œæˆæ­¤ä»»åŠ¡ã€‚å³ä½¿ä½ ä¸çŸ¥é“æ‰€éœ€æ“ä½œçš„æ‰€æœ‰ç‰¹å®šç¬¦å·ï¼Œä½ ä»ç„¶å¯ä»¥åˆ¶å®šä¸€ä¸ªå®Œæˆæ­¤ä»»åŠ¡çš„è®¡åˆ’ã€‚
- en: 'If you planned out the tasks, you might have a todo list like the following:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ åˆ¶å®šäº†ä»»åŠ¡è®¡åˆ’ï¼Œä½ å¯èƒ½ä¼šæœ‰ä»¥ä¸‹å¾…åŠäº‹é¡¹åˆ—è¡¨ï¼š
- en: create a mask of rows with known discount codes
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åˆ›å»ºä¸€ä¸ªå…·æœ‰å·²çŸ¥æŠ˜æ‰£ä»£ç çš„è¡Œçš„æ©ç 
- en: invert that mask (swap the false and true values)
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: é€†è½¬è¯¥æ©ç ï¼ˆäº¤æ¢å‡å€¼å’ŒçœŸå€¼ï¼‰
- en: filter the DataFrame to rows without a known discount code
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è¿‡æ»¤ DataFrameï¼Œä»¥å»é™¤å…·æœ‰å·²çŸ¥æŠ˜æ‰£ä»£ç çš„è¡Œ
- en: replace all the discount column values in that DataFrame with an empty string
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å°†è¯¥ DataFrame ä¸­æ‰€æœ‰æŠ˜æ‰£åˆ—çš„å€¼æ›¿æ¢ä¸ºç©ºå­—ç¬¦ä¸²
- en: 'We have seen how to do parts of steps 1 and 3, but neither of steps 2 and 4\.
    Letâ€™s work through the steps one by one:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»çœ‹åˆ°äº†å¦‚ä½•æ‰§è¡Œæ­¥éª¤ 1 å’Œ 3 çš„éƒ¨åˆ†ï¼Œä½†æ­¥éª¤ 2 å’Œ 4 éƒ½æ²¡æœ‰æ‰§è¡Œã€‚è®©æˆ‘ä»¬ä¸€æ­¥ä¸€æ­¥åœ°å®Œæˆè¿™äº›æ­¥éª¤ï¼š
- en: 'Hereâ€™s the code for step 1, which creates a mask for the rows with known discount
    codes:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æ­¥éª¤ 1 çš„ä»£ç ï¼Œå®ƒä¸ºå…·æœ‰å·²çŸ¥æŠ˜æ‰£ä»£ç çš„è¡Œåˆ›å»ºäº†ä¸€ä¸ªæ©ç ï¼š
- en: '[PRE56]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, we use a lifted `isin` operator on lists to compute the mask.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨æå‡çš„ `isin` æ“ä½œç¬¦åœ¨åˆ—è¡¨ä¸Šè®¡ç®—æ©ç ã€‚
- en: 'For step 2, we have to swap the true and false values. We can do this by using
    the negation operator `~` on the mask from step 1:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæ­¥éª¤ 2ï¼Œæˆ‘ä»¬å¿…é¡»äº¤æ¢çœŸå€¼å’Œå‡å€¼ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨æ­¥éª¤ 1 çš„æ©ç ä¸Šä½¿ç”¨å¦å®šè¿ç®—ç¬¦ `~` æ¥å®ç°è¿™ä¸€ç‚¹ï¼š
- en: '[PRE57]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'For step 3, we want to filter `events` with this mask. Just to keep the code
    easier to read, weâ€™ll give the mask a name and then perform the filter:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæ­¥éª¤ 3ï¼Œæˆ‘ä»¬æƒ³è¦ä½¿ç”¨è¿™ä¸ªæ©ç è¿‡æ»¤ `events`ã€‚ä¸ºäº†ä½¿ä»£ç æ›´å®¹æ˜“é˜…è¯»ï¼Œæˆ‘ä»¬å°†ç»™æ©ç èµ·ä¸€ä¸ªåå­—ï¼Œç„¶åæ‰§è¡Œè¿‡æ»¤æ“ä½œï¼š
- en: '[PRE58]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, we use `=` to set the discount column of the filtered DataFrame to
    the empty string:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæˆ‘ä»¬ä½¿ç”¨ `=` å°†è¿‡æ»¤åçš„ DataFrame çš„æŠ˜æ‰£åˆ—è®¾ç½®ä¸ºç©ºå­—ç¬¦ä¸²ï¼š
- en: '[PRE59]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Whoops â€“ this seems to have generated an error message that says something
    about a â€œSettingWithCopyWarningâ€. This is a subtlety that has to do with what
    happens when data gets updated under the hood (weâ€™ll learn about subtleties of
    mutation in [Mutable Lists](mutable-lists.html)). For now, weâ€™ll use this alternate
    form that avoids the error:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: å“å‘€â€”â€”è¿™ä¼¼ä¹ç”Ÿæˆäº†ä¸€ä¸ªé”™è¯¯æ¶ˆæ¯ï¼Œæåˆ°äº†â€œSettingWithCopyWarningâ€ã€‚è¿™æ˜¯ä¸€ä¸ªä¸åº•å±‚æ•°æ®æ›´æ–°æ—¶å‘ç”Ÿçš„äº‹æƒ…æœ‰å…³çš„å¾®å¦™ä¹‹å¤„ï¼ˆæˆ‘ä»¬å°†åœ¨ [å¯å˜åˆ—è¡¨](mutable-lists.html)
    ä¸­äº†è§£çªå˜å¾®å¦™ä¹‹å¤„ï¼‰ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨é¿å…é”™è¯¯çš„å…¶ä»–å½¢å¼ï¼š
- en: '[PRE60]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Putting it all together, the entire program looks like:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: å°†æ‰€æœ‰å†…å®¹ç»„åˆèµ·æ¥ï¼Œæ•´ä¸ªç¨‹åºçœ‹èµ·æ¥åƒè¿™æ ·ï¼š
- en: '[PRE61]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Summarizing, the code pattern for updating values for a column in some rows
    of a DataFrame is as follows:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: æ€»ç»“ï¼Œæ›´æ–°DataFrameä¸­æŸäº›è¡Œçš„åˆ—å€¼çš„ä»£ç æ¨¡å¼å¦‚ä¸‹ï¼š
- en: make a boolean series mask for which rows to update
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸ºè¦æ›´æ–°çš„è¡Œåˆ›å»ºä¸€ä¸ªå¸ƒå°”åºåˆ—æ©ç 
- en: use the mask to select just the rows where the mask is true
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨æ©ç é€‰æ‹©ä»…å½“æ©ç ä¸ºçœŸçš„è¡Œ
- en: use `.loc` with the mask and column name to select the series of cells to update
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`.loc`å’Œæ©ç ä»¥åŠåˆ—åæ¥é€‰æ‹©è¦æ›´æ–°çš„å•å…ƒæ ¼åºåˆ—
- en: use `=` to give those cells their new value
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`=`ä¸ºè¿™äº›å•å…ƒæ ¼èµ‹äºˆæ–°çš„å€¼
- en: Exercise
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Follow the above pattern to transform all delivery values of `'yes'` to `'pickup'`.
  id: totrans-380
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æŒ‰ç…§ä¸Šè¿°æ¨¡å¼å°†æ‰€æœ‰ `'yes'` çš„é…é€å€¼è½¬æ¢ä¸º `'pickup'`ã€‚
- en: 10.1.3.2Â Repairing Values and Column Types[ğŸ”—](#(part._.Repairing_.Values_and_.Column_.Types)
    "Link to here")
  id: totrans-381
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.1.3.2Â ä¿®å¤å€¼å’Œåˆ—ç±»å‹[ğŸ”—](#(part._.Repairing_.Values_and_.Column_.Types) "é“¾æ¥è‡³æ­¤")
- en: 'The source file for the `events` table contained an error in which someone
    entered the string `''three''` in place of the number `3` for the number of tickets
    in the last row. We can repair errors like this manually:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`events`è¡¨çš„æºæ–‡ä»¶ä¸­å­˜åœ¨ä¸€ä¸ªé”™è¯¯ï¼Œæœ‰äººåœ¨æœ€åä¸€è¡Œå°†å­—ç¬¦ä¸²`''three''`è¾“å…¥ä»£æ›¿äº†ç¥¨æ•°çš„æ•°å­—`3`ã€‚æˆ‘ä»¬å¯ä»¥æ‰‹åŠ¨ä¿®å¤æ­¤ç±»é”™è¯¯ï¼š'
- en: '[PRE62]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Do Now!
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make this repair and ask your Python environment to show you the corrected table.
  id: totrans-386
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿›è¡Œæ­¤ä¿®å¤å¹¶è®©æ‚¨çš„Pythonç¯å¢ƒæ˜¾ç¤ºä¿®æ­£åçš„è¡¨æ ¼ã€‚
- en: 'Now that the `''numtix''` column contains only numbers, we can total the number
    of tickets that were sold:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œ`'numtix'`åˆ—åªåŒ…å«æ•°å­—ï¼Œæˆ‘ä»¬å¯ä»¥è®¡ç®—å”®å‡ºçš„ç¥¨æ•°æ€»æ•°ï¼š
- en: '[PRE63]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Do Now!
  id: totrans-389
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What did you get? Why?
  id: totrans-391
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ å¾—åˆ°äº†ä»€ä¹ˆï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ
- en: 'Because Python environments print strings without quotation marks, the numtix
    column appears to contain numbers. The failure of `sum` shows that this is indeed
    not the case. We can inspect the types that Python has determined for the numtix
    values using the `type` operation:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸ºPythonç¯å¢ƒåœ¨æ‰“å°å­—ç¬¦ä¸²æ—¶ä¸ä½¿ç”¨å¼•å·ï¼Œæ‰€ä»¥`numtix`åˆ—çœ‹èµ·æ¥åŒ…å«æ•°å­—ã€‚`sum`æ“ä½œå¤±è´¥è¡¨æ˜è¿™ç¡®å®ä¸æ˜¯æƒ…å†µã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨`type`æ“ä½œæ£€æŸ¥Pythonä¸º`numtix`å€¼ç¡®å®šçš„ç±»å‹ï¼š
- en: '[PRE64]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: What happened here? During the original call to `read_csv`, Python detected
    both numeric and string data in the numtix column. It therefore read in all the
    values as strings. Our manual repair that replaced the string `'three'` with the
    number `3` fixed the value and type for one row, but the remaining values in that
    column have still been read in as integers.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œå‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿåœ¨åŸå§‹è°ƒç”¨`read_csv`æ—¶ï¼ŒPythonæ£€æµ‹åˆ°`numtix`åˆ—ä¸­æ—¢æœ‰æ•°å­—ä¹Ÿæœ‰å­—ç¬¦ä¸²æ•°æ®ã€‚å› æ­¤ï¼Œå®ƒå°†æ‰€æœ‰å€¼éƒ½è¯»å…¥ä¸ºå­—ç¬¦ä¸²ã€‚æˆ‘ä»¬æ‰‹åŠ¨ä¿®å¤å°†å­—ç¬¦ä¸²`'three'`æ›¿æ¢ä¸ºæ•°å­—`3`çš„æ“ä½œä¿®å¤äº†ä¸€ä¸ªè¡Œçš„å€¼å’Œç±»å‹ï¼Œä½†è¯¥åˆ—ä¸­å‰©ä½™çš„å€¼ä»ç„¶è¢«è¯»å…¥ä¸ºæ•´æ•°ã€‚
- en: Fortunately, Python provides an operation to change the type of data within
    a series. The following code converts the values in the `events['numtix']` series
    to integers, updating the series within the DataFrame in the process.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¸è¿çš„æ˜¯ï¼ŒPythonæä¾›äº†ä¸€ä¸ªæ“ä½œæ¥æ›´æ”¹åºåˆ—ä¸­çš„æ•°æ®ç±»å‹ã€‚ä»¥ä¸‹ä»£ç å°†`events['numtix']`åºåˆ—ä¸­çš„å€¼è½¬æ¢ä¸ºæ•´æ•°ï¼Œå¹¶åœ¨è¿‡ç¨‹ä¸­æ›´æ–°DataFrameä¸­çš„åºåˆ—ã€‚
- en: '[PRE65]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 10.1.4Â Computing New Columns[ğŸ”—](#(part._.Computing_.New_.Columns) "Link to here")
  id: totrans-397
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.4Â è®¡ç®—æ–°åˆ—[ğŸ”—](#(part._.Computing_.New_.Columns) "é“¾æ¥è‡³æ­¤")
- en: 'Letâ€™s extend the events table with the total cost of tickets, while also accounting
    for a discount. Weâ€™ll start by building a column for the ticket price without
    any discounts. This is a straightforward application of lifting as weâ€™ve seen
    it so far:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬é€šè¿‡æ·»åŠ ç¥¨åŠ¡æ€»æˆæœ¬ä»¥åŠè€ƒè™‘æŠ˜æ‰£æ¥æ‰©å±•`events`è¡¨ã€‚æˆ‘ä»¬å°†é¦–å…ˆåˆ›å»ºä¸€ä¸ªæ²¡æœ‰æŠ˜æ‰£çš„ç¥¨ä»·åˆ—ï¼Œè¿™æ˜¯æˆ‘ä»¬æ‰€è§åˆ°çš„æå‡çš„ç›´æ¥åº”ç”¨ï¼š
- en: '[PRE66]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Do Now!
  id: totrans-400
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-401
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use masks, operator lifting, filtering, and series updating to give a 10% discount
    to everyone with the â€œbirthdayâ€ discount code.
  id: totrans-402
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨æ©ç ã€æ“ä½œæå‡ã€è¿‡æ»¤å’Œåºåˆ—æ›´æ–°ï¼Œä¸ºæ‹¥æœ‰â€œç”Ÿæ—¥æŠ˜æ‰£ä»£ç â€çš„æ¯ä¸ªäººæä¾›10%çš„æŠ˜æ‰£ã€‚
- en: We do this by creating a mask for the â€œbirthdayâ€ discount, then updating just
    that part of the DataFrame.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é€šè¿‡åˆ›å»ºä¸€ä¸ªâ€œç”Ÿæ—¥æŠ˜æ‰£â€çš„æ©ç ï¼Œç„¶ååªæ›´æ–°DataFrameçš„è¿™éƒ¨åˆ†æ¥å®ç°è¿™ä¸€ç‚¹ã€‚
- en: '[PRE67]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Notice that the notation for computing new columns and updating existing ones
    is the same (unlike in Pyret, where we had different operations `build-column`
    and `transform-column`). In Pandas, a new column is created if the given column
    name doesnâ€™t already exist in the DataFrame; otherwise, the existing column with
    the given name gets updated.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè®¡ç®—æ–°åˆ—å’Œæ›´æ–°ç°æœ‰åˆ—çš„è¡¨ç¤ºæ³•æ˜¯ç›¸åŒçš„ï¼ˆä¸Pyretä¸åŒï¼Œåœ¨Pyretä¸­æˆ‘ä»¬ä½¿ç”¨äº†ä¸åŒçš„æ“ä½œ`build-column`å’Œ`transform-column`ï¼‰ã€‚åœ¨Pandasä¸­ï¼Œå¦‚æœç»™å®šçš„åˆ—ååœ¨DataFrameä¸­ä¸å­˜åœ¨ï¼Œåˆ™ä¼šåˆ›å»ºä¸€ä¸ªæ–°åˆ—ï¼›å¦åˆ™ï¼Œå°†æ›´æ–°å…·æœ‰ç»™å®šåç§°çš„ç°æœ‰åˆ—ã€‚
- en: 10.1.5Â Aggregating and Grouping Columns[ğŸ”—](#(part._.Aggregating_and_.Grouping_.Columns)
    "Link to here")
  id: totrans-406
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.5Â èšåˆå’Œåˆ†ç»„åˆ—[ğŸ”—](#(part._.Aggregating_and_.Grouping_.Columns) "é“¾æ¥è‡³æ­¤")
- en: Pandas has built-in operations for doing standard mathematical computations
    over series. For example, to total the number of tickets sold or to compute the
    average number of tickets per order, we can write
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Pandaså…·æœ‰ç”¨äºåœ¨åºåˆ—ä¸Šæ‰§è¡Œæ ‡å‡†æ•°å­¦è®¡ç®—çš„å†…ç½®æ“ä½œã€‚ä¾‹å¦‚ï¼Œä¸ºäº†è®¡ç®—é”€å”®çš„æ€»ç¥¨æ•°æˆ–è®¡ç®—æ¯è®¢å•çš„å¹³å‡ç¥¨æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ç¼–å†™
- en: '[PRE68]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: These are the same built-in operations that apply to Python lists.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æ˜¯é€‚ç”¨äºPythonåˆ—è¡¨çš„ç›¸åŒå†…ç½®æ“ä½œã€‚
- en: Imagine now that we wanted a finer-grained look at total ticket sales. Rather
    than just the total sold overall, weâ€™d like the total sold per discount category.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬ç°åœ¨æƒ³è¦æ›´ç»†è‡´åœ°æŸ¥çœ‹æ€»ç¥¨åŠ¡é”€å”®é¢ã€‚è€Œä¸ä»…ä»…æ˜¯æ•´ä½“çš„æ€»é”€å”®é¢ï¼Œæˆ‘ä»¬è¿˜æƒ³çœ‹åˆ°æ¯ä¸ªæŠ˜æ‰£ç±»åˆ«çš„æ€»é”€å”®é¢ã€‚
- en: Do Now!
  id: totrans-411
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-412
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How might you compute this?
  id: totrans-413
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ ä¼šå¦‚ä½•è®¡ç®—è¿™ä¸ªï¼Ÿ
- en: We could imagine constructing a list of the discount codes, filtering the ticket
    sales table to each code, then using `sum` on each filtered table. This feels
    like a lot of work, however. Producing summaries of one column (e.g., [PRE69])
    around the values in another (e.g., [PRE70]) is a common technique in data analysis.
    Spreadsheets typically provide a feature called a â€œpivot tableâ€ that supports
    such a view of data.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥æƒ³è±¡æ„å»ºä¸€ä¸ªæŠ˜æ‰£ä»£ç åˆ—è¡¨ï¼Œè¿‡æ»¤ç¥¨åŠ¡é”€å”®è¡¨ä»¥æ¯ä¸ªä»£ç ï¼Œç„¶åå¯¹æ¯ä¸ªè¿‡æ»¤åçš„è¡¨ä½¿ç”¨`sum`ã€‚ç„¶è€Œï¼Œè¿™æ„Ÿè§‰åƒæ˜¯ä¸€é¡¹å¤§é‡å·¥ä½œã€‚åœ¨æ•°æ®åˆ†æä¸­ï¼Œå›´ç»•å¦ä¸€ä¸ªå€¼ï¼ˆä¾‹å¦‚[PRE70]ï¼‰çš„å€¼ï¼ˆä¾‹å¦‚[PRE69]ï¼‰å‘¨å›´ç”Ÿæˆä¸€ä¸ªåˆ—çš„æ‘˜è¦æ˜¯ä¸€ç§å¸¸è§æŠ€æœ¯ã€‚ç”µå­è¡¨æ ¼é€šå¸¸æä¾›ä¸€ç§ç§°ä¸ºâ€œæ•°æ®é€è§†è¡¨â€çš„åŠŸèƒ½ï¼Œå®ƒæ”¯æŒè¿™ç§æ•°æ®è§†å›¾ã€‚
- en: 'In Pandas, we can do a computation like this using an operation called `groupby`.
    Hereâ€™s are two examples. The first reports how many sales (rows) were made with
    each discount code, while the second summarize the total number of tickets sold
    by discount code:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Pandasä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªåä¸º`groupby`çš„æ“ä½œæ¥è¿›è¡Œè¿™æ ·çš„è®¡ç®—ã€‚è¿™é‡Œæœ‰ä¸¤ç»„ç¤ºä¾‹ã€‚ç¬¬ä¸€ç»„æŠ¥å‘Šäº†ä½¿ç”¨æ¯ä¸ªæŠ˜æ‰£ä»£ç çš„é”€å”®ï¼ˆè¡Œï¼‰æ•°é‡ï¼Œè€Œç¬¬äºŒç»„æ€»ç»“äº†æŒ‰æŠ˜æ‰£ä»£ç é”€å”®çš„æ€»ç¥¨æ•°ï¼š
- en: '[PRE71]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`groupby` takes the name of the column whose values will be used to cluster
    rows. It returns a special type of data (called `GroupBy`). From there, we can
    select a column and perform an operation on it. The column selection and operation
    are performed on each collection of rows in the `GroupBy`. The results of the
    second expression in the above code are reported in a new DataFrame:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupby`æ¥å—ä¸€ä¸ªåˆ—åï¼Œè¯¥åˆ—çš„å€¼å°†ç”¨äºèšç±»è¡Œã€‚å®ƒè¿”å›ä¸€ç§ç‰¹æ®Šç±»å‹çš„æ•°æ®ï¼ˆç§°ä¸º`GroupBy`ï¼‰ã€‚ä»é‚£é‡Œï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹©ä¸€ä¸ªåˆ—å¹¶å¯¹å®ƒæ‰§è¡Œæ“ä½œã€‚åˆ—é€‰æ‹©å’Œæ“ä½œåœ¨`GroupBy`ä¸­çš„æ¯ä¸€è¡Œé›†åˆä¸Šæ‰§è¡Œã€‚ä¸Šè¿°ä»£ç ä¸­ç¬¬äºŒä¸ªè¡¨è¾¾å¼çš„ç»“æœæŠ¥å‘Šåœ¨ä¸€ä¸ªæ–°çš„DataFrameä¸­ï¼š'
- en: '![](../Images/0b9ecb1c08c84c777f66a57137d73fb3.png)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0b9ecb1c08c84c777f66a57137d73fb3.png)'
- en: In this DataFrame, discount labels a column. The first row has the empty string
    in the discount column, with 14 tickets purchased without discount codes. There
    were 2 tickets purchased with a birthday discount and 8 with a student discount.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªDataFrameä¸­ï¼ŒæŠ˜æ‰£æ ‡ç­¾äº†ä¸€ä¸ªåˆ—ã€‚ç¬¬ä¸€è¡Œåœ¨æŠ˜æ‰£åˆ—ä¸­æœ‰ä¸€ä¸ªç©ºå­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºæ²¡æœ‰æŠ˜æ‰£ä»£ç è´­ä¹°äº†14å¼ ç¥¨ã€‚æœ‰2å¼ ç¥¨ä½¿ç”¨äº†ç”Ÿæ—¥æŠ˜æ‰£ï¼Œ8å¼ ä½¿ç”¨äº†å­¦ç”ŸæŠ˜æ‰£ã€‚
- en: The Pandas documentation provides a large collection of operations that can
    used on `GroupBy` data; these cover computations such as counting, mean, finding
    largest and smallest values, and performing various other statistical operations.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: Pandasæ–‡æ¡£æä¾›äº†ä¸€å¤§æ‰¹å¯ä»¥åœ¨`GroupBy`æ•°æ®ä¸Šä½¿ç”¨çš„æ“ä½œï¼›è¿™äº›æ“ä½œåŒ…æ‹¬è®¡æ•°ã€æ±‚å¹³å‡å€¼ã€æŸ¥æ‰¾æœ€å¤§å’Œæœ€å°å€¼ä»¥åŠæ‰§è¡Œå„ç§å…¶ä»–ç»Ÿè®¡æ“ä½œã€‚
- en: 10.1.6Â Wide Versus Tall Data[ğŸ”—](#(part._.Wide_.Versus_.Tall_.Data) "Link to
    here")
  id: totrans-421
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.6Â å®½æ•°æ®ä¸é•¿æ•°æ®[ğŸ”—](#(part._.Wide_.Versus_.Tall_.Data) "é“¾æ¥è‡³æ­¤")
- en: 'Letâ€™s try grouping data on a different dataset. Hereâ€™s a table showing sales
    data across several regions during each month of the year:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å°è¯•åœ¨å¦ä¸€ä¸ªæ•°æ®é›†ä¸Šå¯¹æ•°æ®è¿›è¡Œåˆ†ç»„ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªæ˜¾ç¤ºæ¯å¹´æ¯æœˆå‡ ä¸ªåœ°åŒºé”€å”®æ•°æ®çš„è¡¨æ ¼ï¼š
- en: '![](../Images/ec0e7f8f6b70454dec5da967061e0316.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ec0e7f8f6b70454dec5da967061e0316.png)'
- en: Copy the following code to load this table for yourself.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: å¤åˆ¶ä»¥ä¸‹ä»£ç ä»¥åŠ è½½æ­¤è¡¨ä¾›è‡ªå·±ä½¿ç”¨ã€‚
- en: '[PRE72]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Do Now!
  id: totrans-426
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-427
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Here are several questions that we might want to ask from this dataset. For
    each one, develop a plan that indicates which Pandas operations you would use
    to answer it. If a question seems hard to answer with the operations you have,
    explain whatâ€™s difficult about answering that question.
  id: totrans-428
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€äº›æˆ‘ä»¬å¯èƒ½æƒ³è¦ä»è¿™ä¸ªæ•°æ®é›†ä¸­æå‡ºçš„é—®é¢˜ã€‚å¯¹äºæ¯ä¸€ä¸ªé—®é¢˜ï¼Œåˆ¶å®šä¸€ä¸ªè®¡åˆ’ï¼Œè¯´æ˜ä½ ä¼šä½¿ç”¨å“ªäº›Pandasæ“ä½œæ¥å›ç­”å®ƒã€‚å¦‚æœä¸€ä¸ªé—®é¢˜ä¼¼ä¹ä½¿ç”¨ä½ ç°æœ‰çš„æ“ä½œéš¾ä»¥å›ç­”ï¼Œè§£é‡Šå›ç­”è¯¥é—®é¢˜å›°éš¾çš„åŸå› ã€‚
- en: ''
  id: totrans-429
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: In which month did the northwest region have the lowest sales?
  id: totrans-430
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: åœ¨å“ªä¸ªæœˆä»½è¥¿åŒ—åœ°åŒºçš„é”€å”®é¢æœ€ä½ï¼Ÿ
- en: ''
  id: totrans-431
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-432
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: What were the total sales per month across all regions?
  id: totrans-433
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: æ‰€æœ‰åœ°åŒºæŒ‰æœˆæ€»é”€å”®é¢æ˜¯å¤šå°‘ï¼Ÿ
- en: ''
  id: totrans-434
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-435
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Which region had the highest sales in April?
  id: totrans-436
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: å“ªä¸ªåœ°åŒºåœ¨4æœˆä»½çš„é”€å”®é¢æœ€é«˜ï¼Ÿ
- en: ''
  id: totrans-437
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-438
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Which region had the highest sales for the entire year?
  id: totrans-439
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: å“ªä¸ªåœ°åŒºåœ¨å…¨å¹´é”€å”®é¢æœ€é«˜ï¼Ÿ
- en: For question 1, we can sort the table by northwest sales in decreasing order,
    then see which month is listed in the first row.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºé—®é¢˜1ï¼Œæˆ‘ä»¬å¯ä»¥æŒ‰è¥¿åŒ—éƒ¨çš„é”€å”®é¢é™åºå¯¹è¡¨æ ¼è¿›è¡Œæ’åºï¼Œç„¶åæŸ¥çœ‹ç¬¬ä¸€è¡Œåˆ—å‡ºçš„æœˆä»½ã€‚
- en: '[PRE73]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Do Now!
  id: totrans-442
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-443
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What value would we have gotten had we used `loc` instead of `iloc` in the above
    code?
  id: totrans-444
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœåœ¨ä¸Šé¢çš„ä»£ç ä¸­ä½¿ç”¨`loc`è€Œä¸æ˜¯`iloc`ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä»€ä¹ˆå€¼ï¼Ÿ
- en: Do Now!
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did sorting the `sales` table change the row order permanently? Check by having
    Python show you the value of `sales` after you run `sort_values`.
  id: totrans-447
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ’åº`sales`è¡¨æ ¼æ˜¯å¦æ°¸ä¹…æ”¹å˜äº†è¡Œé¡ºåºï¼Ÿé€šè¿‡è¿è¡Œ`sort_values`åè®©Pythonæ˜¾ç¤º`sales`çš„å€¼æ¥æ£€æŸ¥ã€‚
- en: 'For question 2, we could build a new column that stores the sales data across
    each row:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºé—®é¢˜2ï¼Œæˆ‘ä»¬å¯ä»¥æ„å»ºä¸€ä¸ªæ–°çš„åˆ—æ¥å­˜å‚¨æ¯è¡Œçš„é”€å”®é¢æ•°æ®ï¼š
- en: '[PRE74]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Do Now!
  id: totrans-450
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-451
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did computing the `total` column change the row order permanently? Check by
    having Python show you the value of `sales` after you run the code.
  id: totrans-452
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è®¡ç®—æ€»åˆ—æ˜¯å¦æ°¸ä¹…æ”¹å˜äº†è¡Œé¡ºåºï¼Ÿé€šè¿‡è¿è¡Œä»£ç åè®©Pythonæ˜¾ç¤º`sales`çš„å€¼æ¥æ£€æŸ¥ã€‚
- en: (If you want to remove the new `total` column, you can do this with `sales =
    sales.drop(columns='total')`.)
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆå¦‚æœä½ æƒ³è¦åˆ é™¤æ–°çš„`total`åˆ—ï¼Œå¯ä»¥ä½¿ç”¨`sales = sales.drop(columns='total')`ã€‚ï¼‰
- en: Question 3 is more challenging because we want to sort on the regions, which
    are in columns rather than rows. Question 4 is even more challenging because we
    want to produce sums of columns, then compare regions. Both of these feel a bit
    like problems we might know how to solve if the rows corresponded to regions rather
    than months, but that isnâ€™t how our data are organized. And even if we did flip
    the table around (we could, the technical term for this is `transpose`), problem
    4 would still feel a bit complicated by the time we computed annual sales per
    region and sorted them.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬3ä¸ªé—®é¢˜æ›´å…·æŒ‘æˆ˜æ€§ï¼Œå› ä¸ºæˆ‘ä»¬æƒ³è¦æŒ‰åœ°åŒºæ’åºï¼Œè¿™äº›åœ°åŒºä½äºåˆ—è€Œä¸æ˜¯è¡Œã€‚ç¬¬4ä¸ªé—®é¢˜æ›´å…·æŒ‘æˆ˜æ€§ï¼Œå› ä¸ºæˆ‘ä»¬æƒ³è¦ç”Ÿæˆåˆ—çš„æ€»å’Œï¼Œç„¶åæ¯”è¾ƒåœ°åŒºã€‚è¿™ä¸¤ä¸ªé—®é¢˜éƒ½æœ‰äº›åƒæˆ‘ä»¬å¯èƒ½çŸ¥é“å¦‚ä½•è§£å†³çš„ï¼Œå¦‚æœè¡Œå¯¹åº”åœ°åŒºè€Œä¸æ˜¯æœˆä»½ï¼Œä½†æˆ‘ä»¬çš„æ•°æ®ç»„ç»‡å¹¶ä¸æ˜¯è¿™æ ·ã€‚å³ä½¿æˆ‘ä»¬ç¿»è½¬äº†è¡¨æ ¼ï¼ˆæˆ‘ä»¬å¯ä»¥è¿™æ ·åšï¼Œè¿™ä¸ªæœ¯è¯­æ˜¯â€œè½¬ç½®â€ï¼‰ï¼Œåœ¨è®¡ç®—æ¯ä¸ªåœ°åŒºçš„å¹´åº¦é”€å”®é¢å¹¶å¯¹å…¶è¿›è¡Œæ’åºåï¼Œé—®é¢˜4ä»ç„¶ä¼šæ„Ÿè§‰æœ‰äº›å¤æ‚ã€‚
- en: What if instead our table had looked like the following? Would questions 3 and
    4 get any easier?
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬çš„è¡¨æ ¼çœ‹èµ·æ¥åƒä»¥ä¸‹è¿™æ ·ï¼Œé—®é¢˜3å’Œé—®é¢˜4ä¼šå˜å¾—å®¹æ˜“ä¸€äº›å—ï¼Ÿ
- en: '![](../Images/0b8815a10314d9cdee7892b1e09f891d.png)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](../Images/0b8815a10314d9cdee7892b1e09f891d.png)'
- en: With the data organized this way, question 3 can be answered with a combination
    of row selection and `sort_values`. Question 4 becomes easy to answer with a `groupby`.
    Even the code for Question 2 gets cleaner.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥è¿™ç§æ–¹å¼ç»„ç»‡æ•°æ®åï¼Œé—®é¢˜3å¯ä»¥é€šè¿‡è¡Œé€‰æ‹©å’Œ`sort_values`çš„ç»„åˆæ¥å›ç­”ã€‚é—®é¢˜4å¯ä»¥é€šè¿‡`groupby`è½»æ¾å›ç­”ã€‚ç”šè‡³é—®é¢˜2çš„ä»£ç ä¹Ÿå˜å¾—æ›´ç®€æ´ã€‚
- en: The contrast between these two tables highlights that how our data are organized
    can determine how easy or hard it is to process them with the standard operations
    provided by table-processing packages such as Pandas (what weâ€™re discussing here
    applies to other languages that support tables, such as Pyret and R).
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸¤ä¸ªè¡¨æ ¼ä¹‹é—´çš„å¯¹æ¯”çªå‡ºäº†æˆ‘ä»¬çš„æ•°æ®ç»„ç»‡æ–¹å¼å¯ä»¥å†³å®šä½¿ç”¨è¡¨æ ¼å¤„ç†è½¯ä»¶åŒ…ï¼ˆå¦‚Pandasï¼‰æä¾›çš„æ ‡å‡†æ“ä½œå¤„ç†æ•°æ®çš„éš¾æ˜“ç¨‹åº¦ï¼ˆè¿™é‡Œè®¨è®ºçš„å†…å®¹ä¹Ÿé€‚ç”¨äºæ”¯æŒè¡¨æ ¼çš„å…¶ä»–è¯­è¨€ï¼Œå¦‚Pyretå’ŒRï¼‰ã€‚
- en: In general, the operations in table-processing packages were designed to assume
    that there is one core observation per row (about which we might have many smaller
    details or attributes), and that we will want to aggregate and display data across
    rows, not across columns. Our original treated each month as an observation, with
    the regions being details. For questions 1 and 2, which focused on months, the
    built-in operations sufficed to process the table. But for questions 3 and 4,
    which focused on regions or combinations of regions and months, it helps to have
    each month and region data be in its own row.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: é€šå¸¸æƒ…å†µä¸‹ï¼Œè¡¨æ ¼å¤„ç†è½¯ä»¶ä¸­çš„æ“ä½œè¢«è®¾è®¡ä¸ºå‡è®¾æ¯è¡Œåªæœ‰ä¸€ä¸ªæ ¸å¿ƒè§‚æµ‹å€¼ï¼ˆå…³äºè¿™ä¸ªè§‚æµ‹å€¼æˆ‘ä»¬å¯èƒ½æœ‰å¤šä¸ªæ›´å°çš„ç»†èŠ‚æˆ–å±æ€§ï¼‰ï¼Œå¹¶ä¸”æˆ‘ä»¬å¸Œæœ›è·¨è¡Œè€Œä¸æ˜¯è·¨åˆ—æ±‡æ€»å’Œæ˜¾ç¤ºæ•°æ®ã€‚æˆ‘ä»¬çš„åŸå§‹å¤„ç†æ–¹æ³•å°†æ¯ä¸ªæœˆè§†ä¸ºä¸€ä¸ªè§‚æµ‹å€¼ï¼Œåœ°åŒºä½œä¸ºç»†èŠ‚ã€‚å¯¹äºç¬¬1å’Œç¬¬2ä¸ªé—®é¢˜ï¼Œå®ƒä»¬å…³æ³¨æœˆä»½ï¼Œå†…ç½®æ“ä½œè¶³ä»¥å¤„ç†è¡¨æ ¼ã€‚ä½†å¯¹äºç¬¬3å’Œç¬¬4ä¸ªé—®é¢˜ï¼Œå®ƒä»¬å…³æ³¨åœ°åŒºæˆ–åœ°åŒºå’Œæœˆä»½çš„ç»„åˆï¼Œå°†æ¯ä¸ªæœˆå’Œåœ°åŒºæ•°æ®æ”¾åœ¨å„è‡ªçš„è¡Œä¸­ä¼šæœ‰æ‰€å¸®åŠ©ã€‚
- en: Tables like the original `sales` data are called wide tables, whereas the second
    form are termed tall tables. At the extremes, wide tables have every variable
    in its own column whereas tall tables have only one column for a single value
    of interest, with a separate row for each variable that contributed to that value.
    Wide tables tend to be easier for people to read; as we have seen with our sales
    data, tall tables can be easier to process in code, depending on how our questions
    align with our variables.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å°†å®½æ ¼å¼è¡¨å’Œé•¿æ ¼å¼è¡¨å¹¶æ’æ”¾ç½®ï¼Œä»¥å¯è§†åŒ– `melt` çš„æ“ä½œã€‚
- en: Converting Between Wide and Tall Data[ğŸ”—](#(part._.Converting_.Between_.Wide_and_.Tall_.Data)
    "Link to here")
  id: totrans-461
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '![å›¾ç‰‡](../Images/3a8f49b403e48f063552947c7f7f252d.png)'
- en: 'Table-processing packages generally provide built-in operators for converting
    between wide and tall data formats. The following Pandas expression converts the
    (original) wide-format `sales` table into a tall-format table, retaining the month
    of the year and the product division as a label on every datapoint:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: è¡¨å¤„ç†è½¯ä»¶é€šå¸¸æä¾›å†…ç½®è¿ç®—ç¬¦ï¼Œç”¨äºåœ¨å®½æ ¼å¼å’Œé•¿æ ¼å¼æ•°æ®ä¹‹é—´è¿›è¡Œè½¬æ¢ã€‚ä»¥ä¸‹ Pandas è¡¨è¾¾å¼å°†ï¼ˆåŸå§‹çš„ï¼‰å®½æ ¼å¼ `sales` è¡¨è½¬æ¢ä¸ºé•¿æ ¼å¼è¡¨ï¼ŒåŒæ—¶ä¿ç•™å¹´ä»½çš„æœˆä»½å’Œäº§å“éƒ¨é—¨ä½œä¸ºæ¯ä¸ªæ•°æ®ç‚¹çš„æ ‡ç­¾ï¼š
- en: '[PRE75]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This basic `melt` expression uses default column names of `variable` and `value`
    for the new columns. We can customize those names as part of the `melt` call if
    we wish:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªåŸºæœ¬çš„ `melt` è¡¨è¾¾å¼ä½¿ç”¨é»˜è®¤çš„åˆ—å `variable` å’Œ `value` ä¸ºæ–°åˆ—å‘½åã€‚å¦‚æœæˆ‘ä»¬æ„¿æ„ï¼Œå¯ä»¥åœ¨ `melt` è°ƒç”¨ä¸­è‡ªå®šä¹‰è¿™äº›åç§°ï¼š
- en: '[PRE76]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Letâ€™s put the wide and tall tables side by side to visualize what `melt` is
    doing.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å°†å®½æ ¼å¼è¡¨å’Œé•¿æ ¼å¼è¡¨å¹¶æ’æ”¾ç½®ï¼Œä»¥å¯è§†åŒ– `melt` çš„æ“ä½œã€‚
- en: '![](../Images/3a8f49b403e48f063552947c7f7f252d.png)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: åƒåŸå§‹ `sales` æ•°æ®è¿™æ ·çš„è¡¨è¢«ç§°ä¸ºå®½è¡¨ï¼Œè€Œç¬¬äºŒç§å½¢å¼è¢«ç§°ä¸ºé•¿è¡¨ã€‚åœ¨æç«¯æƒ…å†µä¸‹ï¼Œå®½è¡¨ä¸­çš„æ¯ä¸ªå˜é‡éƒ½æœ‰è‡ªå·±çš„ä¸€åˆ—ï¼Œè€Œé•¿è¡¨åªæœ‰ä¸€ä¸ªåˆ—ç”¨äºæ„Ÿå…´è¶£çš„å•ä¸€å€¼ï¼Œæ¯ä¸ªå˜é‡éƒ½è´¡çŒ®äº†ä¸€ä¸ªå•ç‹¬çš„è¡Œã€‚å®½è¡¨é€šå¸¸æ›´å®¹æ˜“é˜…è¯»ï¼›æ­£å¦‚æˆ‘ä»¬é€šè¿‡é”€å”®æ•°æ®æ‰€çœ‹åˆ°çš„ï¼Œé•¿è¡¨åœ¨ä»£ç ä¸­å¯èƒ½æ›´å®¹æ˜“å¤„ç†ï¼Œè¿™å–å†³äºæˆ‘ä»¬çš„é—®é¢˜ä¸å˜é‡çš„å¯¹é½æ–¹å¼ã€‚
- en: The columns named in `id_vars` remain in the original table. For each column
    not named in `id_vars`, a row is created with the `id_vars` columns, the melted-column
    name, and the melted-column value for the `id_vars`. The above figure color codes
    how cells from the wide table are arranged in the melted tall table.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '[åœ¨å®½æ ¼å¼å’Œé•¿æ ¼å¼æ•°æ®ä¹‹é—´è½¬æ¢](#(part._.Converting_.Between_.Wide_and_.Tall_.Data) "é“¾æ¥åˆ°æ­¤å¤„")'
- en: 'With the tall table in hand, we can proceed to answer questions 3 and 4, as
    well as to redo our solution to question 2:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: æ‹¥æœ‰é•¿æ ¼å¼è¡¨åï¼Œæˆ‘ä»¬å¯ä»¥ç»§ç»­å›ç­”é—®é¢˜ 3 å’Œ 4ï¼Œä»¥åŠé‡æ–°è§£ç­”é—®é¢˜ 2ï¼š
- en: '[PRE77]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The solution to question 4 uses a new Pandas operator called `reset_index`,
    which is needed if you want to manipulate the output of a `group-by` as a regular
    DataFrame.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: é—®é¢˜ 4 çš„è§£å†³æ–¹æ¡ˆä½¿ç”¨äº† Pandas çš„æ–°è¿ç®—ç¬¦ `reset_index`ï¼Œå¦‚æœæ‚¨æƒ³å°† `group-by` çš„è¾“å‡ºä½œä¸ºå¸¸è§„ DataFrame
    è¿›è¡Œæ“ä½œï¼Œåˆ™éœ€è¦ä½¿ç”¨å®ƒã€‚
- en: Converting Between Wide and Tall Data[ğŸ”—](#(part._.Converting_.Between_.Wide_and_.Tall_.Data)
    "Link to here")
  id: totrans-472
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[åœ¨å®½æ ¼å¼å’Œé•¿æ ¼å¼æ•°æ®ä¹‹é—´è½¬æ¢](#(part._.Converting_.Between_.Wide_and_.Tall_.Data) "é“¾æ¥åˆ°æ­¤å¤„")'
- en: 'Table-processing packages generally provide built-in operators for converting
    between wide and tall data formats. The following Pandas expression converts the
    (original) wide-format `sales` table into a tall-format table, retaining the month
    of the year and the product division as a label on every datapoint:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: è¡¨å¤„ç†è½¯ä»¶é€šå¸¸æä¾›å†…ç½®è¿ç®—ç¬¦ï¼Œç”¨äºåœ¨å®½æ ¼å¼å’Œé•¿æ ¼å¼æ•°æ®ä¹‹é—´è¿›è¡Œè½¬æ¢ã€‚ä»¥ä¸‹ Pandas è¡¨è¾¾å¼å°†ï¼ˆåŸå§‹çš„ï¼‰å®½æ ¼å¼ `sales` è¡¨è½¬æ¢ä¸ºé•¿æ ¼å¼è¡¨ï¼ŒåŒæ—¶ä¿ç•™å¹´ä»½çš„æœˆä»½å’Œäº§å“éƒ¨é—¨ä½œä¸ºæ¯ä¸ªæ•°æ®ç‚¹çš„æ ‡ç­¾ï¼š
- en: '[PRE78]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This basic `melt` expression uses default column names of `variable` and `value`
    for the new columns. We can customize those names as part of the `melt` call if
    we wish:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªåŸºæœ¬çš„ `melt` è¡¨è¾¾å¼ä½¿ç”¨é»˜è®¤çš„åˆ—å `variable` å’Œ `value` ä¸ºæ–°åˆ—å‘½åã€‚å¦‚æœæˆ‘ä»¬æ„¿æ„ï¼Œå¯ä»¥åœ¨ `melt` è°ƒç”¨ä¸­è‡ªå®šä¹‰è¿™äº›åç§°ï¼š
- en: '[PRE79]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Letâ€™s put the wide and tall tables side by side to visualize what `melt` is
    doing.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ `id_vars` ä¸­å‘½åçš„åˆ—ä¿æŒåŸè¡¨ä¸­çš„çŠ¶æ€ã€‚å¯¹äºä¸åœ¨ `id_vars` ä¸­å‘½åçš„æ¯ä¸ªåˆ—ï¼Œå°†åˆ›å»ºä¸€ä¸ªåŒ…å« `id_vars` åˆ—ã€ç†”åŒ–åˆ—åç§°å’Œ
    `id_vars` çš„ç†”åŒ–åˆ—å€¼çš„è¡Œã€‚ä¸Šå›¾ç”¨é¢œè‰²ç¼–ç äº†å®½è¡¨ä¸­çš„å•å…ƒæ ¼å¦‚ä½•åœ¨ç†”åŒ–åçš„é•¿è¡¨ä¸­æ’åˆ—ã€‚
- en: '![](../Images/3a8f49b403e48f063552947c7f7f252d.png)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](../Images/3a8f49b403e48f063552947c7f7f252d.png)'
- en: The columns named in `id_vars` remain in the original table. For each column
    not named in `id_vars`, a row is created with the `id_vars` columns, the melted-column
    name, and the melted-column value for the `id_vars`. The above figure color codes
    how cells from the wide table are arranged in the melted tall table.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: é—®é¢˜ 4 çš„è§£å†³æ–¹æ¡ˆä½¿ç”¨äº† Pandas çš„æ–°è¿ç®—ç¬¦ `reset_index`ï¼Œå¦‚æœæ‚¨æƒ³å°† `group-by` çš„è¾“å‡ºä½œä¸ºå¸¸è§„ DataFrame
    è¿›è¡Œæ“ä½œï¼Œåˆ™éœ€è¦ä½¿ç”¨å®ƒã€‚
- en: 'With the tall table in hand, we can proceed to answer questions 3 and 4, as
    well as to redo our solution to question 2:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: æ‹¥æœ‰é•¿æ ¼å¼è¡¨åï¼Œæˆ‘ä»¬å¯ä»¥ç»§ç»­å›ç­”é—®é¢˜ 3 å’Œ 4ï¼Œä»¥åŠé‡æ–°è§£ç­”é—®é¢˜ 2ï¼š
- en: '[PRE80]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The solution to question 4 uses a new Pandas operator called `reset_index`,
    which is needed if you want to manipulate the output of a `group-by` as a regular
    DataFrame.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: é—®é¢˜4çš„è§£å†³æ–¹æ¡ˆä½¿ç”¨äº† Pandas ä¸­çš„ä¸€ä¸ªæ–°æ“ä½œç¬¦ `reset_index`ï¼Œå¦‚æœä½ æƒ³è¦å°† `group-by` çš„è¾“å‡ºä½œä¸ºä¸€ä¸ªå¸¸è§„ DataFrame
    è¿›è¡Œæ“ä½œï¼Œè¿™ä¸ªæ“ä½œç¬¦æ˜¯å¿…éœ€çš„ã€‚
- en: 10.1.7Â Plotting Data[ğŸ”—](#(part._.Plotting_.Data) "Link to here")
  id: totrans-483
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.7 ç»˜åˆ¶æ•°æ®[ğŸ”—](#(part._.Plotting_.Data) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Letâ€™s continue with the sales data as we explore plotting in Pandas.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ç»§ç»­ä½¿ç”¨é”€å”®æ•°æ®ï¼Œåœ¨æˆ‘ä»¬æ¢ç´¢ Pandas ä¸­çš„ç»˜å›¾æ—¶ã€‚
- en: Letâ€™s say we now want to take a seasonal view, rather than a monthly view, and
    look at sales within seasons.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬ç°åœ¨æƒ³ä»å­£èŠ‚çš„è§’åº¦è€Œä¸æ˜¯ä»æœˆåº¦çš„è§’åº¦æ¥æŸ¥çœ‹ï¼Œå¹¶æŸ¥çœ‹å­£èŠ‚å†…çš„é”€å”®æƒ…å†µã€‚
- en: 'Letâ€™s say we wanted to see how summer sales varied over the years. This is
    a good situation in which to use a line plot. To create this, we first need to
    load `matplotlib`, the Python graphic library:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬æƒ³çœ‹çœ‹å¤å­£é”€å”®éšå¹´ä»½çš„å˜åŒ–æƒ…å†µã€‚è¿™æ˜¯ä¸€ä¸ªä½¿ç”¨çº¿å½¢å›¾çš„å¥½æƒ…å†µã€‚ä¸ºäº†åˆ›å»ºè¿™ä¸ªå›¾è¡¨ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦åŠ è½½ `matplotlib`ï¼ŒPython çš„å›¾å½¢åº“ï¼š
- en: '[PRE81]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Next, to generate the line plots, we call the `plt.plot` function on the series
    of numbers that we want to form the points on the plot. We can also specify the
    values on the axes, as shown the following examples.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼Œä¸ºäº†ç”Ÿæˆçº¿å½¢å›¾ï¼Œæˆ‘ä»¬åœ¨æƒ³è¦åœ¨å›¾ä¸Šå½¢æˆç‚¹çš„æ•°å€¼åºåˆ—ä¸Šè°ƒç”¨ `plt.plot` å‡½æ•°ã€‚æˆ‘ä»¬è¿˜å¯ä»¥æŒ‡å®šè½´ä¸Šçš„å€¼ï¼Œå¦‚ä¸‹é¢çš„ç¤ºä¾‹æ‰€ç¤ºã€‚
- en: '[PRE82]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Pandas will put both line plots in the same display window. In general, each
    time you call `plt.figure()`, you create a new window in which subsequent plot
    commands will appear (at least until you ask for a plot that does not nicely overlay
    with the previous plot type).
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas ä¼šå°†ä¸¤ä¸ªçº¿å½¢å›¾éƒ½æ”¾åœ¨åŒä¸€ä¸ªæ˜¾ç¤ºçª—å£ä¸­ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œæ¯æ¬¡ä½ è°ƒç”¨ `plt.figure()`ï¼Œä½ éƒ½ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„çª—å£ï¼Œåç»­çš„ç»˜å›¾å‘½ä»¤å°†å‡ºç°åœ¨è¿™ä¸ªçª—å£ä¸­ï¼ˆè‡³å°‘ç›´åˆ°ä½ è¯·æ±‚ä¸€ä¸ªä¸ä¹‹å‰ç»˜å›¾ç±»å‹ä¸å®Œç¾å åŠ çš„ç»˜å›¾ï¼‰ã€‚
- en: The `matplotlib` package offers many kinds of charts and customizations to graph
    layouts. A more comprehensive look is beyond the scope of this book; see the [matplotlib
    website](https://matplotlib.org/stable/index.html) for tutorials and many examples
    of more sophisticated plots.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '`matplotlib` åŒ…æä¾›äº†è®¸å¤šç§ç±»çš„å›¾è¡¨å’Œå›¾å½¢å¸ƒå±€çš„å®šåˆ¶ã€‚æ›´å…¨é¢çš„ä»‹ç»è¶…å‡ºäº†æœ¬ä¹¦çš„èŒƒå›´ï¼›æœ‰å…³æ•™ç¨‹å’Œæ›´å¤æ‚å›¾è¡¨çš„è®¸å¤šç¤ºä¾‹ï¼Œè¯·å‚é˜… [matplotlib
    ç½‘ç«™](https://matplotlib.org/stable/index.html)ã€‚'
- en: 10.1.8Â Takeaways[ğŸ”—](#(part._.Takeaways) "Link to here")
  id: totrans-492
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.8 æ€»ç»“[ğŸ”—](#(part._.Takeaways) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'This chapter has been designed to give you an overview of Pandas while pointing
    out key concepts in programming for data science. It is by no means a comprehensive
    Pandas tutorial or reference guide: for those, see the [Pandas website](https://pandas.pydata.org/).'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ç« æ—¨åœ¨ä¸ºä½ æä¾›ä¸€ä¸ª Pandas çš„æ¦‚è§ˆï¼ŒåŒæ—¶æŒ‡å‡ºæ•°æ®ç§‘å­¦ç¼–ç¨‹ä¸­çš„å…³é”®æ¦‚å¿µã€‚è¿™ç»å¯¹ä¸æ˜¯ä¸€æœ¬å…¨é¢çš„ Pandas æ•™ç¨‹æˆ–å‚è€ƒæŒ‡å—ï¼šå¯¹äºè¿™äº›ï¼Œè¯·å‚é˜… [Pandas
    ç½‘ç«™](https://pandas.pydata.org/)ã€‚
- en: 'Conceptually, we hope you will take away three high-level ideas from this chapter:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: ä»æ¦‚å¿µä¸Šè®²ï¼Œæˆ‘ä»¬å¸Œæœ›ä½ èƒ½ä»è¿™ä¸ªç« èŠ‚ä¸­å¸¦èµ°ä¸‰ä¸ªé«˜çº§æƒ³æ³•ï¼š
- en: 'There are two notions for how to access specific cells in tables and DataFrames:
    by numeric position (e.g., first row, second column) or by labeled index (e.g.,
    numtix). Both have their roles in professional-grade data analysis programming.
    Filter-like operations that extract rows from tables maintain labeled indices,
    but renumber the positional ones (so that every DataFrame has a sequence of consecutively-numbered
    rows).'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥è®¿é—®è¡¨æ ¼å’Œ DataFrame ä¸­çš„ç‰¹å®šå•å…ƒæ ¼ï¼šé€šè¿‡æ•°å­—ä½ç½®ï¼ˆä¾‹å¦‚ï¼Œç¬¬ä¸€è¡Œï¼Œç¬¬äºŒåˆ—ï¼‰æˆ–é€šè¿‡æ ‡ç­¾ç´¢å¼•ï¼ˆä¾‹å¦‚ï¼Œnumtixï¼‰ã€‚ä¸¤è€…åœ¨ä¸“ä¸šçº§åˆ«çš„æ•°æ®åˆ†æç¼–ç¨‹ä¸­éƒ½æœ‰å…¶ä½œç”¨ã€‚ç±»ä¼¼äºè¿‡æ»¤çš„æ“ä½œå¯ä»¥æå–è¡¨æ ¼ä¸­çš„è¡Œï¼Œä½†ä¼šä¿æŒæ ‡ç­¾ç´¢å¼•ï¼ŒåŒæ—¶é‡æ–°ç¼–å·ä½ç½®ç´¢å¼•ï¼ˆå› æ­¤æ¯ä¸ª
    DataFrame éƒ½æœ‰ä¸€ä¸ªè¿ç»­ç¼–å·çš„è¡Œåºåˆ—ï¼‰ã€‚
- en: Professional-grade programming languages sometimes â€œliftâ€ operations from single
    values to collections of values (e.g., using `+` to add elements within similarly-sized
    series). Lifting can be a powerful and timesaving tool for programmers, but they
    can also lead to type confusions for both novices and experienced programmers.
    You should be aware that this feature exists as you learn new languages and packages.
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸“ä¸šçº§åˆ«çš„ç¼–ç¨‹è¯­è¨€æœ‰æ—¶ä¼šä»å•ä¸ªå€¼â€œæå‡â€åˆ°å€¼çš„é›†åˆä¸­çš„æ“ä½œï¼ˆä¾‹å¦‚ï¼Œä½¿ç”¨ `+` æ¥æ·»åŠ åŒæ ·å¤§å°çš„åºåˆ—ä¸­çš„å…ƒç´ ï¼‰ã€‚æå‡å¯¹äºç¨‹åºå‘˜æ¥è¯´å¯ä»¥æ˜¯ä¸€ä¸ªå¼ºå¤§ä¸”èŠ‚çœæ—¶é—´çš„å·¥å…·ï¼Œä½†å®ƒä»¬ä¹Ÿå¯èƒ½å¯¼è‡´æ–°æ‰‹å’Œç»éªŒä¸°å¯Œçš„ç¨‹åºå‘˜äº§ç”Ÿç±»å‹æ··æ·†ã€‚å½“ä½ å­¦ä¹ æ–°çš„è¯­è¨€å’ŒåŒ…æ—¶ï¼Œä½ åº”è¯¥æ„è¯†åˆ°è¿™ä¸ªåŠŸèƒ½çš„å­˜åœ¨ã€‚
- en: Different table organizations (for the same data) are better in different situations.
    Wide and tall tables are two general shapes, each with their own affordances.
    You should be aware that table-processing packages provide a variety of tools
    to help you automatically reformat tables. If the computation you are trying to
    do feels too complicated, stop and consider whether the problem would be easier
    with a different organization of the same data.
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸åŒçš„è¡¨æ ¼ç»„ç»‡æ–¹å¼ï¼ˆé’ˆå¯¹ç›¸åŒçš„æ•°æ®ï¼‰åœ¨ä¸åŒæƒ…å†µä¸‹è¡¨ç°æ›´ä½³ã€‚å®½è¡¨å’Œé•¿è¡¨æ˜¯ä¸¤ç§å¸¸è§çš„å½¢çŠ¶ï¼Œæ¯ç§éƒ½æœ‰å…¶è‡ªèº«çš„ä¼˜åŠ¿ã€‚ä½ åº”è¯¥æ„è¯†åˆ°ï¼Œè¡¨æ ¼å¤„ç†è½¯ä»¶åŒ…æä¾›äº†å„ç§å·¥å…·æ¥å¸®åŠ©ä½ è‡ªåŠ¨é‡æ–°æ ¼å¼åŒ–è¡¨æ ¼ã€‚å¦‚æœä½ æ­£åœ¨å°è¯•çš„è®¡ç®—æ„Ÿè§‰è¿‡äºå¤æ‚ï¼Œè¯·åœä¸‹æ¥è€ƒè™‘ï¼Œæ˜¯å¦ä½¿ç”¨ç›¸åŒæ•°æ®çš„ä¸åŒç»„ç»‡æ–¹å¼ä¼šä½¿é—®é¢˜æ›´å®¹æ˜“è§£å†³ã€‚
