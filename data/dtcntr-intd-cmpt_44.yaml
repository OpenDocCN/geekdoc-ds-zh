- en: 14Â Predicting GrowthğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14Â é¢„æµ‹å¢é•¿ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/predicting-growth.html](https://dcic-world.org/2025-08-27/predicting-growth.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/predicting-growth.html](https://dcic-world.org/2025-08-27/predicting-growth.html)
- en: '| Â Â Â Â [14.1Â A Little (True) Story](#%28part._.A_.Little__.True__.Story%29)
    |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [14.1Â ä¸€ä¸ªç®€çŸ­ï¼ˆçœŸå®ï¼‰çš„æ•…äº‹](#%28part._.A_.Little__.True__.Story%29) |'
- en: '| Â Â Â Â [14.2Â The Analytical Idea](#%28part._.The_.Analytical_.Idea%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [14.2Â åˆ†ææ€æƒ³](#%28part._.The_.Analytical_.Idea%29) |'
- en: '| Â Â Â Â [14.3Â A Cost Model for Pyret Running Time](#%28part._cost-model%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [14.3Â Pyret è¿è¡Œæ—¶é—´çš„æˆæœ¬æ¨¡å‹](#%28part._cost-model%29) |'
- en: '| Â Â Â Â [14.4Â The Size of the Input](#%28part._size-of-input%29) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [14.4Â è¾“å…¥çš„å¤§å°](#%28part._size-of-input%29) |'
- en: '| Â Â Â Â [14.5Â The Tabular Method for Singly-Structurally-Recursive Functions](#%28part._.The_.Tabular_.Method_for_.Singly-.Structurally-.Recursive_.Functions%29)
    |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [14.5Â å•ç»“æ„é€’å½’å‡½æ•°çš„è¡¨æ ¼æ–¹æ³•](#%28part._.The_.Tabular_.Method_for_.Singly-.Structurally-.Recursive_.Functions%29)
    |'
- en: '| Â Â Â Â [14.6Â Creating Recurrences](#%28part._creating-recurrences%29) |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [14.6Â åˆ›å»ºé€’å½’](#%28part._creating-recurrences%29) |'
- en: '| Â Â Â Â [14.7Â A Notation for Functions](#%28part._math-anon-functions%29) |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [14.7Â å‡½æ•°çš„è¡¨ç¤ºæ³•](#%28part._math-anon-functions%29) |'
- en: '| Â Â Â Â [14.8Â Comparing Functions](#%28part._big-oh-def%29) |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [14.8Â æ¯”è¾ƒå‡½æ•°](#%28part._big-oh-def%29) |'
- en: '| Â Â Â Â [14.9Â Combining Big-Oh Without Woe](#%28part._big-oh-closure%29) |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [14.9Â åœ¨ä¸å¸¦çƒ¦æ¼çš„æƒ…å†µä¸‹ç»„åˆ Big-Oh](#%28part._big-oh-closure%29) |'
- en: '| Â Â Â Â [14.10Â Solving Recurrences](#%28part._solving-recurrences%29) |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [14.10Â è§£å†³é€’å½’](#%28part._solving-recurrences%29) |'
- en: We will now commence the study of determining how long a computation takes.
    Weâ€™ll begin with a little (true) story.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨å°†å¼€å§‹ç ”ç©¶ç¡®å®šè®¡ç®—æ‰€éœ€æ—¶é—´çš„æ–¹æ³•ã€‚æˆ‘ä»¬å°†ä»ä¸€ä¸ªç®€çŸ­ï¼ˆçœŸå®ï¼‰çš„æ•…äº‹å¼€å§‹ã€‚
- en: 14.1Â A Little (True) Story[ğŸ”—](#(part._.A_.Little__.True__.Story) "Link to here")
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1Â ä¸€ä¸ªç®€çŸ­ï¼ˆçœŸå®ï¼‰çš„æ•…äº‹[ğŸ”—](#(part._.A_.Little__.True__.Story) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: My student Debbie recently wrote tools to analyze data for a startup. The company
    collects information about product scans made on mobile phones, and Debbieâ€™s analytic
    tools classified these by product, by region, by time, and so on. As a good programmer,
    Debbie first wrote synthetic test cases, then developed her programs and tested
    them. She then obtained some actual test data from the company, broke them down
    into small chunks, computed the expected answers by hand, and tested her programs
    again against these real (but small) data sets. At the end of this she was ready
    to declare the programs ready.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘çš„å­¦ç”Ÿ Debbie æœ€è¿‘ä¸ºä¸€å®¶åˆåˆ›å…¬å¸ç¼–å†™äº†åˆ†ææ•°æ®çš„å·¥å…·ã€‚è¯¥å…¬å¸æ”¶é›†æœ‰å…³åœ¨æ‰‹æœºä¸Šè¿›è¡Œçš„å•†å“æ‰«æçš„ä¿¡æ¯ï¼ŒDebbie çš„åˆ†æå·¥å…·æŒ‰äº§å“ã€åœ°åŒºã€æ—¶é—´ç­‰å¯¹è¿™äº›ä¿¡æ¯è¿›è¡Œåˆ†ç±»ã€‚ä½œä¸ºä¸€åä¼˜ç§€çš„ç¨‹åºå‘˜ï¼ŒDebbie
    é¦–å…ˆç¼–å†™äº†åˆæˆæµ‹è¯•ç”¨ä¾‹ï¼Œç„¶åå¼€å‘äº†å¥¹çš„ç¨‹åºå¹¶è¿›è¡Œäº†æµ‹è¯•ã€‚ä¹‹åï¼Œå¥¹ä»å…¬å¸è·å¾—äº†å®é™…æµ‹è¯•æ•°æ®ï¼Œå°†è¿™äº›æ•°æ®åˆ†è§£æˆå°å—ï¼Œæ‰‹åŠ¨è®¡ç®—å‡ºé¢„æœŸç­”æ¡ˆï¼Œå¹¶å†æ¬¡ç”¨è¿™äº›çœŸå®ï¼ˆä½†è§„æ¨¡è¾ƒå°ï¼‰çš„æ•°æ®é›†æµ‹è¯•å¥¹çš„ç¨‹åºã€‚åœ¨å®Œæˆè¿™äº›å·¥ä½œåï¼Œå¥¹å®£å¸ƒç¨‹åºå‡†å¤‡å°±ç»ªã€‚
- en: 'At this point, however, she had only tested them for functional correctness.
    There was still a question of how quickly her analytical tools would produce answers.
    This presented two problems:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œæ­¤æ—¶å¥¹åªæµ‹è¯•äº†å®ƒä»¬çš„åŠŸèƒ½æ­£ç¡®æ€§ã€‚ä»ç„¶æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå³å¥¹çš„åˆ†æå·¥å…·äº§ç”Ÿç­”æ¡ˆçš„é€Ÿåº¦æœ‰å¤šå¿«ã€‚è¿™æå‡ºäº†ä¸¤ä¸ªé—®é¢˜ï¼š
- en: The company was rightly reluctant to share the entire dataset with outsiders,
    and in turn we didnâ€™t want to be responsible for carefully guarding all their
    data.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å…¬å¸æ­£ç¡®åœ°ä¸æ„¿æ„ä¸å¤–ç•Œåˆ†äº«æ•´ä¸ªæ•°æ®é›†ï¼Œè€Œæˆ‘ä»¬ä¹Ÿæ— æ„æ‰¿æ‹…ä»”ç»†ä¿ç®¡ä»–ä»¬æ‰€æœ‰æ•°æ®çš„è´£ä»»ã€‚
- en: Even if we did get a sample of their data, as more users used their product,
    the amount of data they had was sure to grow.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å³ä½¿æˆ‘ä»¬å¯ä»¥è·å–ä»–ä»¬çš„æ•°æ®æ ·æœ¬ï¼Œéšç€æ›´å¤šç”¨æˆ·ä½¿ç”¨ä»–ä»¬çš„äº§å“ï¼Œä»–ä»¬æ‹¥æœ‰çš„æ•°æ®é‡è‚¯å®šä¼šå¢é•¿ã€‚
- en: We therefore got only a sampling of their full data, and from this had to make
    some prediction on how long it would take to run the analytics on subsets (e.g.,
    those corresponding to just one region) or all of their data set, both today and
    as it grew over time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬åªèƒ½è·å–ä»–ä»¬å…¨éƒ¨æ•°æ®çš„æ ·æœ¬ï¼Œå¹¶æ®æ­¤é¢„æµ‹åˆ†æå­é›†ï¼ˆä¾‹å¦‚ï¼Œä»…å¯¹åº”ä¸€ä¸ªåŒºåŸŸçš„æ•°æ®ï¼‰æˆ–å…¨éƒ¨æ•°æ®é›†æ‰€éœ€çš„æ—¶é—´ï¼Œæ— è®ºæ˜¯ä»Šå¤©è¿˜æ˜¯éšç€æ—¶é—´çš„æ¨ç§»ã€‚
- en: Debbie was given 100,000 data points. She broke them down into input sets of
    10, 100, 1,000, 10,000, and 100,000 data points, ran her tools on each input size,
    and plotted the result.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Debbie è¢«åˆ†é…äº† 100,000 ä¸ªæ•°æ®ç‚¹ã€‚å¥¹å°†å®ƒä»¬åˆ†è§£æˆåŒ…å« 10ã€100ã€1,000ã€10,000 å’Œ 100,000 ä¸ªæ•°æ®ç‚¹çš„è¾“å…¥é›†ï¼Œå¯¹æ¯ä¸ªè¾“å…¥å¤§å°è¿è¡Œå¥¹çš„å·¥å…·ï¼Œå¹¶ç»˜åˆ¶ç»“æœã€‚
- en: From this graph we have a good bet at guessing how long the tool would take
    on a dataset of 50,000\. Itâ€™s much harder, however, to be sure how long it would
    take on datasets of size 1.5 million or 3 million or 10 million.These processes
    are respectively called interpolation and extrapolation. Weâ€™ve already explained
    why we couldnâ€™t get more data from the company. So what could we do?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ä»è¿™å¼ å›¾ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆå¥½åœ°çŒœæµ‹åœ¨åŒ…å«50,000ä¸ªæ•°æ®é›†çš„å·¥å…·ä¸Šéœ€è¦å¤šé•¿æ—¶é—´ã€‚ç„¶è€Œï¼Œè¦ç¡®å®šåœ¨1.5ç™¾ä¸‡ã€3ç™¾ä¸‡æˆ–1åƒä¸‡è§„æ¨¡çš„æ•°æ®é›†ä¸Šéœ€è¦å¤šé•¿æ—¶é—´å°±å›°éš¾å¤šäº†ã€‚è¿™äº›è¿‡ç¨‹åˆ†åˆ«è¢«ç§°ä¸ºå†…æ’å’Œå¤–æ¨ã€‚æˆ‘ä»¬å·²ç»è§£é‡Šäº†ä¸ºä»€ä¹ˆæˆ‘ä»¬æ— æ³•ä»å…¬å¸è·å–æ›´å¤šæ•°æ®ã€‚é‚£ä¹ˆæˆ‘ä»¬èƒ½åšä»€ä¹ˆå‘¢ï¼Ÿ
- en: 'As another problem, suppose we have multiple implementations available. When
    we plot their running time, say the graphs look like this, with red, green, and
    blue each representing different implementations. On small inputs, suppose the
    running times look like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºå¦ä¸€ä¸ªé—®é¢˜ï¼Œå‡è®¾æˆ‘ä»¬æœ‰å¤šä¸ªå®ç°å¯ç”¨ã€‚å½“æˆ‘ä»¬ç»˜åˆ¶å®ƒä»¬çš„è¿è¡Œæ—¶é—´æ—¶ï¼Œæ¯”å¦‚å›¾è¡¨çœ‹èµ·æ¥åƒè¿™æ ·ï¼Œçº¢è‰²ã€ç»¿è‰²å’Œè“è‰²åˆ†åˆ«ä»£è¡¨ä¸åŒçš„å®ç°ã€‚åœ¨å°è¾“å…¥ä¸Šï¼Œå‡è®¾è¿è¡Œæ—¶é—´çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ï¼š
- en: '![image](../Images/1fe6a875e4a9f3d3a6f962c860dda585.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/1fe6a875e4a9f3d3a6f962c860dda585.png)'
- en: 'This doesnâ€™t seem to help us distinguish between the implementations. Now suppose
    we run the algorithms on larger inputs, and we get the following graphs:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¼¼ä¹ä¸èƒ½å¸®åŠ©æˆ‘ä»¬åŒºåˆ†è¿™äº›å®ç°ã€‚ç°åœ¨å‡è®¾æˆ‘ä»¬åœ¨æ›´å¤§çš„è¾“å…¥ä¸Šè¿è¡Œç®—æ³•ï¼Œæˆ‘ä»¬å¾—åˆ°ä»¥ä¸‹å›¾è¡¨ï¼š
- en: '![image](../Images/e4ff72c49a10103cea5fe1690ae0b404.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/e4ff72c49a10103cea5fe1690ae0b404.png)'
- en: 'Now we seem to have a clear winner (red), though itâ€™s not clear there is much
    to give between the other two (blue and green). But if we calculate on even larger
    inputs, we start to see dramatic differences:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬ä¼¼ä¹æœ‰ä¸€ä¸ªæ˜æ˜¾çš„èµ¢å®¶ï¼ˆçº¢è‰²ï¼‰ï¼Œå°½ç®¡ä¸æ¸…æ¥šå…¶ä»–ä¸¤ä¸ªï¼ˆè“è‰²å’Œç»¿è‰²ï¼‰ä¹‹é—´æœ‰ä»€ä¹ˆåŒºåˆ«ã€‚ä½†å¦‚æœæˆ‘ä»¬å¯¹æ›´å¤§çš„è¾“å…¥è¿›è¡Œè®¡ç®—ï¼Œæˆ‘ä»¬å¼€å§‹çœ‹åˆ°æ˜æ˜¾çš„å·®å¼‚ï¼š
- en: '![image](../Images/d9aeccc8e556d7c4435cdf97c958a74d.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/d9aeccc8e556d7c4435cdf97c958a74d.png)'
- en: In fact, the functions that resulted in these lines were the same in all three
    figures. What these pictures tell us is that it is dangerous to extrapolate too
    much from the performance on small inputs. If we could obtain closed-form descriptions
    of the performance of computations, it would be nice if we could compare them
    better. That is what we will do in the next section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šï¼Œå¯¼è‡´è¿™äº›çº¿æ¡çš„å‡½æ•°åœ¨ä¸‰ä¸ªå›¾è¡¨ä¸­éƒ½æ˜¯ç›¸åŒçš„ã€‚è¿™äº›å›¾ç‰‡å‘Šè¯‰æˆ‘ä»¬ï¼Œä»å°è¾“å…¥çš„æ€§èƒ½ä¸­è¿‡åº¦å¤–æ¨æ˜¯å±é™©çš„ã€‚å¦‚æœæˆ‘ä»¬èƒ½è·å¾—è®¡ç®—æ€§èƒ½çš„é—­å¼æè¿°ï¼Œå¦‚æœèƒ½æ›´å¥½åœ°æ¯”è¾ƒå®ƒä»¬å°±å¤ªå¥½äº†ã€‚è¿™å°±æ˜¯æˆ‘ä»¬å°†åœ¨ä¸‹ä¸€èŠ‚ä¸­è¦åšçš„ã€‚
- en: 'Responsible Computing: Choose Analysis Artifacts Wisely'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è´Ÿè´£ä»»è®¡ç®—ï¼šæ˜æ™ºåœ°é€‰æ‹©åˆ†æå·¥ä»¶
- en: ''
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As more and more decisions are guided by statistical analyses of data (performed
    by humans), itâ€™s critical to recognize that data can be a poor proxy for the actual
    phenomenon that we seek to understand. Here, Debbie had data about program behavior,
    which led to mis-interpretations regarding which program is best. But Debbie also
    had the programs themselves, from which the data were generated. Analyzing the
    programs, rather than the data, is a more direct approach to assessing the performance
    of a program.
  id: totrans-30
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: éšç€è¶Šæ¥è¶Šå¤šçš„å†³ç­–ç”±æ•°æ®ï¼ˆç”±äººç±»è¿›è¡Œçš„ç»Ÿè®¡åˆ†æï¼‰æŒ‡å¯¼ï¼Œè®¤è¯†åˆ°æ•°æ®å¯èƒ½æ— æ³•å¾ˆå¥½åœ°ä»£è¡¨æˆ‘ä»¬è¯•å›¾ç†è§£çš„å®é™…æƒ…å†µè‡³å…³é‡è¦ã€‚åœ¨è¿™é‡Œï¼ŒDebbieæœ‰å…³äºç¨‹åºè¡Œä¸ºçš„èµ„æ–™ï¼Œè¿™å¯¼è‡´äº†å…³äºå“ªä¸ªç¨‹åºæœ€å¥½çš„è¯¯è§£ã€‚ä½†Debbieä¹Ÿæœ‰ç”Ÿæˆè¿™äº›æ•°æ®çš„ç¨‹åºæœ¬èº«ã€‚åˆ†æç¨‹åºï¼Œè€Œä¸æ˜¯æ•°æ®ï¼Œæ˜¯è¯„ä¼°ç¨‹åºæ€§èƒ½çš„ç›´æ¥æ–¹æ³•ã€‚
- en: ''
  id: totrans-31
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: While the rest of this chapter is about analyzing programs as written in code,
    this point carries over to non-programs as well. You might want to understand
    the effectiveness of a process for triaging patients at a hospital, for example.
    In that case, you have both the policy documents (rules which may or may not have
    been turned into a software program to support managing patients) and data on
    the effectiveness of using that process. Responsible computing tells us to analyze
    both the process and its behavioral data, against knowledge about best practices
    in patient care, to evaluate the effectiveness of systems.
  id: totrans-32
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è™½ç„¶æœ¬ç« çš„å…¶ä½™éƒ¨åˆ†æ˜¯å…³äºåˆ†æä»£ç ä¸­ç¼–å†™çš„ç¨‹åºï¼Œä½†è¿™ä¸ªè§‚ç‚¹ä¹Ÿé€‚ç”¨äºéç¨‹åºã€‚ä¾‹å¦‚ï¼Œä½ å¯èƒ½æƒ³äº†è§£åŒ»é™¢ä¸­åˆ†çº§æ‚£è€…æµç¨‹çš„æœ‰æ•ˆæ€§ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½ æ—¢æœ‰æ”¿ç­–æ–‡ä»¶ï¼ˆå¯èƒ½æˆ–å¯èƒ½æ²¡æœ‰è½¬åŒ–ä¸ºæ”¯æŒç®¡ç†æ‚£è€…çš„è½¯ä»¶ç¨‹åºï¼‰ä»¥åŠä½¿ç”¨è¯¥æµç¨‹çš„æœ‰æ•ˆæ€§æ•°æ®ã€‚è´Ÿè´£ä»»è®¡ç®—å‘Šè¯‰æˆ‘ä»¬ï¼Œè¦åˆ†ææµç¨‹åŠå…¶è¡Œä¸ºæ•°æ®ï¼Œä¸å…³äºæ‚£è€…æŠ¤ç†æœ€ä½³å®è·µçš„çŸ¥è¯†ç›¸å¯¹æ¯”ï¼Œä»¥è¯„ä¼°ç³»ç»Ÿçš„æœ‰æ•ˆæ€§ã€‚
- en: 14.2Â The Analytical Idea[ğŸ”—](#(part._.The_.Analytical_.Idea) "Link to here")
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2 åˆ†ææ€æƒ³[ğŸ”—](#(part._.The_.Analytical_.Idea) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'With many physical processes, the best we can do is obtain as many data points
    as possible, extrapolate, and apply statistics to reason about the most likely
    outcome. Sometimes we can do that in computer science, too, but fortunately we
    computer scientists have an enormous advantage over most other sciences: instead
    of measuring a black-box process, we have full access to its internals, namely
    the source code. This enables us to apply analytical methods.â€œAnalyticalâ€ means
    applying algebraic and other mathematical methods to make predictive statements
    about a process without running it. The answer we compute this way is complementary
    to what we obtain from the above experimental analysis, and in practice we will
    usually want to use a combination of the two to arrive a strong understanding
    of the programâ€™s behavior.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºè®¸å¤šç‰©ç†è¿‡ç¨‹ï¼Œæˆ‘ä»¬èƒ½åšçš„æœ€å¥½çš„äº‹æƒ…å°±æ˜¯å°½å¯èƒ½å¤šåœ°è·å–æ•°æ®ç‚¹ï¼Œè¿›è¡Œå¤–æ¨ï¼Œå¹¶åº”ç”¨ç»Ÿè®¡å­¦æ¥æ¨ç†æœ€å¯èƒ½çš„ç»“æœã€‚æœ‰æ—¶åœ¨è®¡ç®—æœºç§‘å­¦ä¸­æˆ‘ä»¬ä¹Ÿèƒ½è¿™æ ·åšï¼Œä½†å¹¸è¿çš„æ˜¯ï¼Œæˆ‘ä»¬è®¡ç®—æœºç§‘å­¦å®¶åœ¨å¤§å¤šæ•°å…¶ä»–ç§‘å­¦ä¸­æ‹¥æœ‰å·¨å¤§çš„ä¼˜åŠ¿ï¼šæˆ‘ä»¬ä¸æ˜¯æµ‹é‡ä¸€ä¸ªé»‘ç›’è¿‡ç¨‹ï¼Œè€Œæ˜¯å®Œå…¨è®¿é—®å…¶å†…éƒ¨ï¼Œå³æºä»£ç ã€‚è¿™ä½¿å¾—æˆ‘ä»¬å¯ä»¥åº”ç”¨åˆ†ææ–¹æ³•ã€‚â€œåˆ†æâ€æ„å‘³ç€åº”ç”¨ä»£æ•°å’Œå…¶ä»–æ•°å­¦æ–¹æ³•æ¥å¯¹è¿‡ç¨‹åšå‡ºé¢„æµ‹æ€§é™ˆè¿°ï¼Œè€Œä¸éœ€è¦è¿è¡Œå®ƒã€‚æˆ‘ä»¬è¿™æ ·è®¡ç®—å‡ºçš„ç­”æ¡ˆæ˜¯ä¸Šè¿°å®éªŒåˆ†æå¾—åˆ°çš„ç­”æ¡ˆçš„è¡¥å……ï¼Œåœ¨å®è·µä¸­ï¼Œæˆ‘ä»¬é€šå¸¸å¸Œæœ›ç»“åˆä½¿ç”¨è¿™ä¸¤ç§æ–¹æ³•ï¼Œä»¥è·å¾—å¯¹ç¨‹åºè¡Œä¸ºçš„æ·±å…¥ç†è§£ã€‚
- en: 'The analytical idea is startlingly simple. We look at the source of the program
    and list the operations it performs. For each operation, we look up what it costs.We
    are going to focus on one kind of cost, namely running time. There are many other
    other kinds of costs one can compute. We might naturally be interested in space
    (memory) consumed, which tells us how big a machine we need to buy. We might also
    care about power, this tells us the cost of our energy bills, or of bandwidth,
    which tells us what kind of Internet connection we will need. In general, then,
    weâ€™re interested in resource consumption. In short, donâ€™t make the mistake of
    equating â€œperformanceâ€ with â€œspeedâ€: the costs that matter depend on the context
    in which the application runs. We add up these costs for all the operations. This
    gives us a total cost for the program.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ†ææ€æƒ³éå¸¸ç®€å•ã€‚æˆ‘ä»¬æŸ¥çœ‹ç¨‹åºçš„æºä»£ç ï¼Œå¹¶åˆ—å‡ºå®ƒæ‰§è¡Œçš„æ“ä½œã€‚å¯¹äºæ¯ä¸ªæ“ä½œï¼Œæˆ‘ä»¬æŸ¥æ‰¾å®ƒçš„æˆæœ¬ã€‚æˆ‘ä»¬å°†å…³æ³¨ä¸€ç§æˆæœ¬ï¼Œå³è¿è¡Œæ—¶é—´ã€‚è¿˜æœ‰è®¸å¤šå…¶ä»–ç±»å‹çš„æˆæœ¬å¯ä»¥è®¡ç®—ã€‚æˆ‘ä»¬å¯èƒ½è‡ªç„¶ä¼šå¯¹ç©ºé—´ï¼ˆå†…å­˜ï¼‰æ¶ˆè€—æ„Ÿå…´è¶£ï¼Œè¿™å‘Šè¯‰æˆ‘ä»¬éœ€è¦è´­ä¹°å¤šå¤§æœºå™¨ã€‚æˆ‘ä»¬ä¹Ÿå¯èƒ½å…³å¿ƒç”µåŠ›ï¼Œè¿™å‘Šè¯‰æˆ‘ä»¬ç”µè´¹çš„æˆæœ¬ï¼Œæˆ–è€…å¸¦å®½ï¼Œè¿™å‘Šè¯‰æˆ‘ä»¬éœ€è¦ä»€ä¹ˆæ ·çš„äº’è”ç½‘è¿æ¥ã€‚æ€»çš„æ¥è¯´ï¼Œæˆ‘ä»¬æ„Ÿå…´è¶£çš„æ˜¯èµ„æºæ¶ˆè€—ã€‚ç®€è€Œè¨€ä¹‹ï¼Œä¸è¦çŠ¯å°†â€œæ€§èƒ½â€ç­‰åŒäºâ€œé€Ÿåº¦â€çš„é”™è¯¯ï¼šç›¸å…³çš„æˆæœ¬å–å†³äºåº”ç”¨ç¨‹åºè¿è¡Œçš„ç¯å¢ƒã€‚æˆ‘ä»¬å°†æ‰€æœ‰æ“ä½œçš„æˆæœ¬åŠ èµ·æ¥ã€‚è¿™ç»™å‡ºäº†ç¨‹åºçš„æ€»æˆæœ¬ã€‚
- en: Naturally, for most programs the answer will not be a constant number. Rather,
    it will depend on factors such as the size of the input. Therefore, our answer
    is likely to be an expression in terms of parameters (such as the inputâ€™s size).
    In other words, our answer will be a function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: è‡ªç„¶åœ°ï¼Œå¯¹äºå¤§å¤šæ•°ç¨‹åºï¼Œç­”æ¡ˆä¸ä¼šæ˜¯ä¸€ä¸ªå¸¸æ•°ã€‚ç›¸åï¼Œå®ƒå°†å–å†³äºè¯¸å¦‚è¾“å…¥å¤§å°ç­‰å› ç´ ã€‚å› æ­¤ï¼Œæˆ‘ä»¬çš„ç­”æ¡ˆå¯èƒ½æ˜¯ä¸€ä¸ªå…³äºå‚æ•°ï¼ˆå¦‚è¾“å…¥çš„å¤§å°ï¼‰çš„è¡¨è¾¾å¼ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬çš„ç­”æ¡ˆå°†æ˜¯ä¸€ä¸ªå‡½æ•°ã€‚
- en: 'There are many functions that can describe the running-time of a function.
    Often we want an upper bound on the running time: i.e., the actual number of operations
    will always be no more than what the function predicts. This tells us the maximum
    resource we will need to allocate. Another function may present a lower bound,
    which tells us the least resource we need. Sometimes we want an average-case analysis.
    And so on. In this text we will focus on upper-bounds, but keep in mind that all
    these other analyses are also extremely valuable.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰è®¸å¤šå‡½æ•°å¯ä»¥æè¿°ä¸€ä¸ªå‡½æ•°çš„è¿è¡Œæ—¶é—´ã€‚é€šå¸¸æˆ‘ä»¬å¸Œæœ›æœ‰ä¸€ä¸ªè¿è¡Œæ—¶é—´çš„ä¸Šç•Œï¼šå³å®é™…çš„æ“ä½œæ•°å°†æ°¸è¿œä¸ä¼šè¶…è¿‡å‡½æ•°é¢„æµ‹çš„æ•°é‡ã€‚è¿™å‘Šè¯‰æˆ‘ä»¬éœ€è¦åˆ†é…çš„æœ€å¤§èµ„æºã€‚å¦ä¸€ä¸ªå‡½æ•°å¯èƒ½æä¾›ä¸€ä¸ªä¸‹ç•Œï¼Œè¿™å‘Šè¯‰æˆ‘ä»¬éœ€è¦çš„æœ€å°‘èµ„æºã€‚æœ‰æ—¶æˆ‘ä»¬æƒ³è¦å¹³å‡æƒ…å†µåˆ†æã€‚ç­‰ç­‰ã€‚åœ¨è¿™ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†é‡ç‚¹å…³æ³¨ä¸Šç•Œï¼Œä½†è¯·è®°ä½ï¼Œæ‰€æœ‰è¿™äº›å…¶ä»–åˆ†æä¹Ÿéå¸¸æœ‰ä»·å€¼ã€‚
- en: Exercise
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is incorrect to speak of â€œtheâ€ upper-bound function, because there isnâ€™t
    just one. Given one upper-bound function, can you construct another one?
  id: totrans-40
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è®¨è®ºæ‰€è°“çš„â€œä¸Šç•Œå‡½æ•°â€æ˜¯ä¸æ­£ç¡®çš„ï¼Œå› ä¸ºå¹¶ä¸åªæœ‰ä¸€ä¸ªã€‚ç»™å®šä¸€ä¸ªä¸Šç•Œå‡½æ•°ï¼Œä½ èƒ½æ„é€ å‡ºå¦ä¸€ä¸ªå—ï¼Ÿ
- en: 14.3Â A Cost Model for Pyret Running Time[ğŸ”—](#(part._cost-model) "Link to here")
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3 Pyret è¿è¡Œæ—¶é—´çš„æˆæœ¬æ¨¡å‹[ğŸ”—](#(part._cost-model) "é“¾æ¥åˆ°æ­¤å¤„")
- en: We begin by presenting a cost model for the running time of Pyret programs.
    We are interested in the cost of running a program, which is tantamount to studying
    the expressions of a program. Simply making a definition does not cost anything;
    the cost is incurred only when we use a definition.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é¦–å…ˆæå‡ºä¸€ä¸ªç”¨äºPyretç¨‹åºè¿è¡Œæ—¶é—´çš„æˆæœ¬æ¨¡å‹ã€‚æˆ‘ä»¬å¯¹ç¨‹åºè¿è¡Œçš„æˆæœ¬æ„Ÿå…´è¶£ï¼Œè¿™ç›¸å½“äºç ”ç©¶ç¨‹åºçš„è¡¨è¾¾å¼ã€‚ä»…ä»…å®šä¹‰ä¸€ä¸ªä¸œè¥¿å¹¶ä¸éœ€è¦èŠ±è´¹ä»»ä½•æˆæœ¬ï¼›åªæœ‰åœ¨ä½¿ç”¨å®šä¹‰æ—¶æ‰ä¼šäº§ç”Ÿæˆæœ¬ã€‚
- en: 'We will use a very simple (but sufficiently accurate) cost model: every operation
    costs one unit of time in addition to the time needed to evaluate its sub-expressions.
    Thus it takes one unit of time to look up a variable or to allocate a constant.
    Applying primitive functions also costs one unit of time. Everything else is a
    compound expression with sub-expressions. The cost of a compound expression is
    one plus that of each of its sub-expressions. For instance, the running time cost
    of the expression `e1 + e2` (for some sub-expressions `e1` and `e2`) is the running
    time for `e1` + the running time for `e2` + 1\. Thus the expression `17 + 29`
    has a cost of 3 (one for each sub-expression and one for the addition); the expression
    `1 + (7 * (2 / 9))` costs 7.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†ä½¿ç”¨ä¸€ä¸ªéå¸¸ç®€å•ï¼ˆä½†è¶³å¤Ÿå‡†ç¡®ï¼‰çš„æˆæœ¬æ¨¡å‹ï¼šæ¯ä¸ªæ“ä½œé™¤äº†éœ€è¦è¯„ä¼°å…¶å­è¡¨è¾¾å¼çš„æ‰€éœ€æ—¶é—´å¤–ï¼Œè¿˜éœ€è¦é¢å¤–ä¸€å•ä½çš„æ—¶é—´ã€‚å› æ­¤ï¼ŒæŸ¥æ‰¾ä¸€ä¸ªå˜é‡æˆ–åˆ†é…ä¸€ä¸ªå¸¸é‡éœ€è¦ä¸€å•ä½çš„æ—¶é—´ã€‚åº”ç”¨åŸå§‹å‡½æ•°ä¹Ÿéœ€è¦ä¸€å•ä½çš„æ—¶é—´ã€‚å…¶ä»–æ‰€æœ‰ä¸œè¥¿éƒ½æ˜¯åŒ…å«å­è¡¨è¾¾å¼çš„å¤åˆè¡¨è¾¾å¼ã€‚å¤åˆè¡¨è¾¾å¼çš„æˆæœ¬æ˜¯å…¶å­è¡¨è¾¾å¼æˆæœ¬çš„æ€»å’ŒåŠ ä¸€ã€‚ä¾‹å¦‚ï¼Œè¡¨è¾¾å¼
    `e1 + e2`ï¼ˆå¯¹äºæŸäº›å­è¡¨è¾¾å¼ `e1` å’Œ `e2`ï¼‰çš„è¿è¡Œæ—¶é—´æˆæœ¬æ˜¯ `e1` çš„è¿è¡Œæ—¶é—´åŠ ä¸Š `e2` çš„è¿è¡Œæ—¶é—´å†åŠ ä¸€ã€‚å› æ­¤ï¼Œè¡¨è¾¾å¼ `17
    + 29` çš„æˆæœ¬æ˜¯ 3ï¼ˆæ¯ä¸ªå­è¡¨è¾¾å¼ä¸€ä¸ªï¼ŒåŠ æ³•æ“ä½œä¸€ä¸ªï¼‰ï¼›è¡¨è¾¾å¼ `1 + (7 * (2 / 9))` çš„æˆæœ¬æ˜¯ 7ã€‚
- en: 'As you can see, there are two big approximations here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æ‚¨æ‰€è§ï¼Œè¿™é‡Œæœ‰ä¸¤ä¸ªå¤§çš„è¿‘ä¼¼ï¼š
- en: First, we are using an abstract rather than concrete notion of time. This is
    unhelpful in terms of estimating the so-called â€œwall clockâ€ running time of a
    program, but then again, that number depends on numerous factorsâ€”<wbr>not just
    what kind of processor and how much memory you have, but even what other tasks
    are running on your computer at the same time. In contrast, abstract time units
    are more portable.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯æŠ½è±¡çš„æ—¶é—´æ¦‚å¿µï¼Œè€Œä¸æ˜¯å…·ä½“çš„æ—¶é—´æ¦‚å¿µã€‚åœ¨ä¼°è®¡ç¨‹åºçš„æ‰€è°“â€œå®é™…è¿è¡Œæ—¶é—´â€æ–¹é¢ï¼Œè¿™å¹¶ä¸æœ‰å¸®åŠ©ï¼Œä½†è¯åˆè¯´å›æ¥ï¼Œè¿™ä¸ªæ•°å­—å–å†³äºè®¸å¤šå› ç´ â€”â€”<wbr>ä¸ä»…ä»…æ˜¯ä½ çš„å¤„ç†å™¨ç±»å‹å’Œå†…å­˜å¤§å°ï¼Œç”šè‡³è¿˜æœ‰ä½ ç”µè„‘ä¸ŠåŒæ—¶è¿è¡Œçš„å…¶ä»–ä»»åŠ¡ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼ŒæŠ½è±¡æ—¶é—´å•ä½æ›´å…·æœ‰å¯ç§»æ¤æ€§ã€‚
- en: Second, not every operation takes the same number of machine cycles, whereas
    we have charged all of them the same number of abstract time units. As long as
    the actual number of cycles each one takes is bounded by a constant factor of
    the number taken by another, this will not pose any mathematical problems for
    reasons we will soon understand [[Comparing Functions](#%28part._big-oh-def%29)].
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å…¶æ¬¡ï¼Œå¹¶éæ¯ä¸ªæ“ä½œéƒ½éœ€è¦ç›¸åŒæ•°é‡çš„æœºå™¨å‘¨æœŸï¼Œè€Œæˆ‘ä»¬å·²ç»å¯¹æ‰€æœ‰æ“ä½œæ”¶å–äº†ç›¸åŒæ•°é‡çš„æŠ½è±¡æ—¶é—´å•ä½ã€‚åªè¦æ¯ä¸ªæ“ä½œå®é™…éœ€è¦çš„å‘¨æœŸæ•°æ˜¯å¦ä¸€ä¸ªæ“ä½œæ‰€éœ€å‘¨æœŸæ•°çš„å¸¸æ•°å€ï¼Œè¿™å°±ä¸ä¼šå¯¹æ•°å­¦ä¸Šé€ æˆä»»ä½•é—®é¢˜ï¼ŒåŸå› æˆ‘ä»¬å¾ˆå¿«å°±ä¼šç†è§£
    [[æ¯”è¾ƒå‡½æ•°](#(part._big-oh-def%29)]).
- en: Of course, it is instructiveâ€”<wbr>after carefully settting up the experimental
    conditionsâ€”<wbr>to make an analytical prediction of a programâ€™s behavior and then
    verify it against what the implementation actually does. If the analytical prediction
    is accurate, we can reconstruct the constant factors hidden in our calculations
    and thus obtain very precise wall-clock time bounds for the program.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œåœ¨ä»”ç»†è®¾ç½®å®éªŒæ¡ä»¶ä¹‹åâ€”â€”<wbr>å¯¹ç¨‹åºçš„è¡Œä¸ºè¿›è¡Œè§£æé¢„æµ‹ï¼Œç„¶åéªŒè¯å…¶å®é™…å®ç°ï¼Œè¿™æ˜¯å¾ˆæœ‰æ•™è‚²æ„ä¹‰çš„ã€‚å¦‚æœè§£æé¢„æµ‹æ˜¯å‡†ç¡®çš„ï¼Œæˆ‘ä»¬å°±å¯ä»¥é‡å»ºè®¡ç®—ä¸­éšè—çš„å¸¸æ•°å› å­ï¼Œä»è€Œè·å¾—ç¨‹åºéå¸¸ç²¾ç¡®çš„å®é™…è¿è¡Œæ—¶é—´ç•Œé™ã€‚
- en: 'There is one especially tricky kind of expression: `if` (and its fancier cousins,
    like `cases` and `ask`). How do we think about the cost of an `if`? It always
    evaluates the condition. After that, it evaluates only one of its branches. But
    we are interested in the worst case time, i.e., what is the longest it could take?
    For a conditional, itâ€™s the cost of the condition added to the cost of the maximum
    of the two branches.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰ä¸€ç§ç‰¹åˆ«æ£˜æ‰‹çš„è¡¨è¾¾å¼ç±»å‹ï¼š`if`ï¼ˆä»¥åŠå®ƒæ›´å¤æ‚çš„äº²æˆšï¼Œå¦‚ `cases` å’Œ `ask`ï¼‰ã€‚æˆ‘ä»¬å¦‚ä½•è€ƒè™‘ `if` çš„æˆæœ¬ï¼Ÿå®ƒæ€»æ˜¯è¯„ä¼°æ¡ä»¶ã€‚ä¹‹åï¼Œå®ƒåªè¯„ä¼°å…¶åˆ†æ”¯ä¸­çš„ä¸€ä¸ªã€‚ä½†æˆ‘ä»¬æ„Ÿå…´è¶£çš„æ˜¯æœ€åæƒ…å†µä¸‹çš„æ—¶é—´ï¼Œå³å®ƒå¯èƒ½éœ€è¦å¤šé•¿æ—¶é—´ï¼Ÿå¯¹äºæ¡ä»¶è¡¨è¾¾å¼ï¼Œè¿™æ˜¯æ¡ä»¶çš„æˆæœ¬åŠ ä¸Šä¸¤ä¸ªåˆ†æ”¯ä¸­æœ€å¤§åˆ†æ”¯çš„æˆæœ¬ã€‚
- en: 14.4Â The Size of the Input[ğŸ”—](#(part._size-of-input) "Link to here")
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4 è¾“å…¥çš„å¤§å°[ğŸ”—](#(part._size-of-input) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'We gloss over the size of a number, treating it as constant. Observe that the
    value of a number is exponentially larger than its size: \(n\) digits in base
    \(b\) can represent \(b^n\) numbers. Though irrelevant here, when numbers are
    centralâ€”<wbr>e.g., when testing primalityâ€”<wbr>the difference becomes critical!
    We will return to this briefly later [[The Complexity of Numbers](avoid-recomp.html#%28part._numbers-not-constant%29)].'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¿½ç•¥äº†æ•°å­—çš„å¤§å°ï¼Œå°†å…¶è§†ä¸ºå¸¸æ•°ã€‚è§‚å¯Ÿåˆ°ä¸€ä¸ªæ•°å­—çš„å€¼æ¯”å…¶å¤§å°æŒ‡æ•°çº§å¤§ï¼šä»¥\(b\)ä¸ºåº•\(n\)ä½å¯ä»¥è¡¨ç¤º\(b^n\)ä¸ªæ•°å­—ã€‚è™½ç„¶åœ¨è¿™é‡Œä¸ç›¸å…³ï¼Œä½†å½“æ•°å­—æ˜¯æ ¸å¿ƒæ—¶â€”â€”ä¾‹å¦‚ï¼Œåœ¨æµ‹è¯•ç´ æ•°æ—¶â€”â€”å·®å¼‚å˜å¾—è‡³å…³é‡è¦ï¼æˆ‘ä»¬å°†åœ¨ç¨åç®€è¦å›é¡¾
    [[æ•°å­—çš„å¤æ‚æ€§](avoid-recomp.html#%28part._numbers-not-constant%29)].
- en: It can be subtle to define the size of the argument. Suppose a function consumes
    a list of numbers; it would be natural to define the size of its argument to be
    the length of the list, i.e., the number of `link`s in the list. We could also
    define it to be twice as large, to account for both the `link`s and the individual
    numbers (but as weâ€™ll see [[Comparing Functions](#%28part._big-oh-def%29)], constants
    usually donâ€™t matter). But suppose a function consumes a list of music albums,
    and each music album is itself a list of songs, each of which has information
    about singers and so on. Then how we measure the size depends on what part of
    the input the function being analyzed actually examines. If, say, it only returns
    the length of the list of albums, then it is indifferent to what each list element
    contains [[Monomorphic Lists and Polymorphic Types](processing-lists.html#%28part._polymorphic-data%29)],
    and only the length of the list of albums matters. If, however, the function returns
    a list of all the singers on every album, then it traverses all the way down to
    individual songs, and we have to account for all these data. In short, we care
    about the size of the data potentially accessed by the function.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: å®šä¹‰å‚æ•°çš„å¤§å°å¯èƒ½å¾ˆå¾®å¦™ã€‚å‡è®¾ä¸€ä¸ªå‡½æ•°æ¶ˆè€—ä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼›å®šä¹‰å…¶å‚æ•°çš„å¤§å°ä¸ºåˆ—è¡¨çš„é•¿åº¦ï¼Œå³åˆ—è¡¨ä¸­çš„`link`æ•°é‡ï¼Œä¼¼ä¹æ˜¯è‡ªç„¶çš„ã€‚æˆ‘ä»¬ä¹Ÿå¯ä»¥å°†å…¶å®šä¹‰ä¸ºä¸¤å€å¤§å°ï¼Œä»¥è€ƒè™‘åˆ°`link`å’Œå•ä¸ªæ•°å­—ï¼ˆä½†æ­£å¦‚æˆ‘ä»¬å°†çœ‹åˆ°çš„
    [[æ¯”è¾ƒå‡½æ•°](#%28part._big-oh-def%29)]ï¼‰ï¼Œå¸¸æ•°é€šå¸¸å¹¶ä¸é‡è¦ï¼‰ã€‚ä½†æ˜¯ï¼Œå‡è®¾ä¸€ä¸ªå‡½æ•°æ¶ˆè€—ä¸€ä¸ªéŸ³ä¹ä¸“è¾‘åˆ—è¡¨ï¼Œå¹¶ä¸”æ¯ä¸ªéŸ³ä¹ä¸“è¾‘æœ¬èº«åˆæ˜¯ä¸€ä¸ªåŒ…å«æ­Œæ‰‹ç­‰ä¿¡æ¯çš„æ­Œæ›²åˆ—è¡¨ã€‚é‚£ä¹ˆæˆ‘ä»¬å¦‚ä½•è¡¡é‡å¤§å°å–å†³äºè¢«åˆ†æå‡½æ•°å®é™…æ£€æŸ¥çš„è¾“å…¥éƒ¨åˆ†ã€‚å¦‚æœï¼Œæ¯”å¦‚è¯´ï¼Œå®ƒåªè¿”å›ä¸“è¾‘åˆ—è¡¨çš„é•¿åº¦ï¼Œé‚£ä¹ˆå®ƒå¯¹æ¯ä¸ªåˆ—è¡¨å…ƒç´ çš„å†…å®¹æ— å…³ç´§è¦
    [[å•æ€åˆ—è¡¨å’Œå¤šæ€ç±»å‹](processing-lists.html#%28part._polymorphic-data%29)]ï¼Œåªæœ‰ä¸“è¾‘åˆ—è¡¨çš„é•¿åº¦æ‰æ˜¯é‡è¦çš„ã€‚ç„¶è€Œï¼Œå¦‚æœå‡½æ•°è¿”å›æ¯ä¸ªä¸“è¾‘ä¸Šçš„æ‰€æœ‰æ­Œæ‰‹çš„åˆ—è¡¨ï¼Œé‚£ä¹ˆå®ƒå°†éå†åˆ°å•ä¸ªæ­Œæ›²ï¼Œæˆ‘ä»¬å¿…é¡»è€ƒè™‘åˆ°æ‰€æœ‰è¿™äº›æ•°æ®ã€‚ç®€è€Œè¨€ä¹‹ï¼Œæˆ‘ä»¬å…³å¿ƒå‡½æ•°å¯èƒ½è®¿é—®çš„æ•°æ®çš„å¤§å°ã€‚
- en: 14.5Â The Tabular Method for Singly-Structurally-Recursive Functions[ğŸ”—](#(part._.The_.Tabular_.Method_for_.Singly-.Structurally-.Recursive_.Functions)
    "Link to here")
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.5 å•ç»“æ„é€’å½’å‡½æ•°çš„è¡¨æ ¼æ³•[ğŸ”—](#(part._.The_.Tabular_.Method_for_.Singly-.Structurally-.Recursive_.Functions)
    "é“¾æ¥åˆ°æ­¤å¤„")
- en: Given sizes for the arguments, we simply examine the body of the function and
    add up the costs of the individual operations. Most interesting functions are,
    however, conditionally defined, and may even recur. Here we will assume there
    is only one structural recursive call. We will get to more general cases in a
    bit [[Creating Recurrences](#%28part._creating-recurrences%29)].
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ç»™å®šå‚æ•°çš„å¤§å°åï¼Œæˆ‘ä»¬åªéœ€æ£€æŸ¥å‡½æ•°ä½“å¹¶ç´¯åŠ å„ä¸ªæ“ä½œçš„ä»£ä»·ã€‚ç„¶è€Œï¼Œå¤§å¤šæ•°æœ‰è¶£çš„å‡½æ•°éƒ½æ˜¯æ¡ä»¶å®šä¹‰çš„ï¼Œç”šè‡³å¯èƒ½é€’å½’ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†å‡è®¾åªæœ‰ä¸€ä¸ªç»“æ„åŒ–é€’å½’è°ƒç”¨ã€‚æˆ‘ä»¬å°†åœ¨ç¨åè®¨è®ºæ›´ä¸€èˆ¬çš„æƒ…å†µ
    [[åˆ›å»ºé€’å½’](#(part._creating-recurrences%29)]).
- en: When we have a function with only one recursive call, and itâ€™s structural, thereâ€™s
    a handy technique we can use to handle conditionals.This idea is due to Prabhakar
    Ragde. We will set up a table. It wonâ€™t surprise you to hear that the table will
    have as many rows as the cond has clauses. But instead of two columns, it has
    seven! This sounds daunting, but youâ€™ll soon see where they come from and why
    theyâ€™re there.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬æœ‰ä¸€ä¸ªåªæœ‰ä¸€ä¸ªé€’å½’è°ƒç”¨çš„å‡½æ•°ï¼Œå¹¶ä¸”å®ƒæ˜¯ç»“æ„åŒ–çš„ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ç§æ–¹ä¾¿çš„æŠ€æœ¯æ¥å¤„ç†æ¡ä»¶ã€‚è¿™ä¸ªæƒ³æ³•å½’åŠŸäºPrabhakar Ragdeã€‚æˆ‘ä»¬å°†å»ºç«‹ä¸€ä¸ªè¡¨æ ¼ã€‚å¬åˆ°è¡¨æ ¼å°†æœ‰ä¸æ¡ä»¶ç›¸åŒçš„è¡Œæ•°ï¼Œä½ ä¸ä¼šæ„Ÿåˆ°æƒŠè®¶ã€‚ä½†ä¸ä¸¤åˆ—ä¸åŒï¼Œå®ƒæœ‰ä¸ƒåˆ—ï¼è¿™å¬èµ·æ¥å¾ˆå“äººï¼Œä½†å¾ˆå¿«ä½ å°±ä¼šçœ‹åˆ°å®ƒä»¬ä»ä½•è€Œæ¥ä»¥åŠä¸ºä»€ä¹ˆå­˜åœ¨ã€‚
- en: 'For each row, fill in the columns as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæ¯ä¸€è¡Œï¼ŒæŒ‰ç…§ä»¥ä¸‹æ–¹å¼å¡«å†™åˆ—ï¼š
- en: '|Q|: the number of operations in the question'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '|Q|ï¼šé—®é¢˜ä¸­çš„æ“ä½œæ•°'
- en: '#Q: the number of times the question will execute'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '#Qï¼šé—®é¢˜å°†æ‰§è¡Œæ¬¡æ•°'
- en: 'TotQ: the total cost of the question (multiply the previous two)'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TotQï¼šé—®é¢˜çš„æ€»æˆæœ¬ï¼ˆä¹˜ä»¥å‰ä¸¤ä¸ªå€¼ï¼‰
- en: '|A|: the number of operations in the answer'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '|A|ï¼šç­”æ¡ˆä¸­çš„æ“ä½œæ•°'
- en: '#A: the number of times the answer will execute'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '#Aï¼šç­”æ¡ˆå°†æ‰§è¡Œæ¬¡æ•°'
- en: 'TotA: the total cost of the answer (multiply the previous two)'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TotAï¼šç­”æ¡ˆçš„æ€»æˆæœ¬ï¼ˆä¹˜ä»¥å‰ä¸¤ä¸ªå€¼ï¼‰
- en: 'Total: add the two totals to obtain an answer for the clause'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æ€»è®¡ï¼šå°†ä¸¤ä¸ªæ€»è®¡ç›¸åŠ ï¼Œä»¥è·å¾—å­å¥çš„ç­”æ¡ˆ
- en: Finally, the total cost of the `cond` expression is obtained by summing the
    Total column in the individual rows.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œé€šè¿‡å°†å•ä¸ªè¡Œçš„æ€»è®¡åˆ—ç›¸åŠ ï¼Œè·å¾—`cond`è¡¨è¾¾å¼çš„æ€»æˆæœ¬ã€‚
- en: In the process of computing these costs, we may come across recursive calls
    in an answer expression. So long as there is only one recursive call in the entire
    answer, ignore it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è®¡ç®—è¿™äº›æˆæœ¬çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šåœ¨ç­”æ¡ˆè¡¨è¾¾å¼ä¸­é‡åˆ°é€’å½’è°ƒç”¨ã€‚åªè¦æ•´ä¸ªç­”æ¡ˆä¸­åªæœ‰ä¸€ä¸ªé€’å½’è°ƒç”¨ï¼Œå°±å¯ä»¥å¿½ç•¥å®ƒã€‚
- en: Exercise
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Once youâ€™ve read the material on [Creating Recurrences](#%28part._creating-recurrences%29),
    come back to this and justify why it is okay to just skip the recursive call.
    Explain in the context of the overall tabular method.
  id: totrans-67
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸€æ—¦ä½ é˜…è¯»äº†å…³äº[åˆ›å»ºé€’å½’](#%28part._creating-recurrences%29)çš„ææ–™ï¼Œè¯·å›åˆ°è¿™é‡Œå¹¶è§£é‡Šä¸ºä»€ä¹ˆå¯ä»¥ç®€å•åœ°è·³è¿‡é€’å½’è°ƒç”¨ã€‚åœ¨æ•´ä½“è¡¨æ ¼æ–¹æ³•çš„èƒŒæ™¯ä¸‹è¿›è¡Œè§£é‡Šã€‚
- en: Exercise
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Excluding the treatment of recursion, justify (a) that these columns are individually
    accurate (e.g., the use of additions and multiplications is appropriate), and
    (b) sufficient (i.e., combined, they account for all operations that will be performed
    by that `cond` clause).
  id: totrans-70
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ’é™¤é€’å½’å¤„ç†çš„å¤„ç†ï¼Œè¯æ˜ï¼ˆaï¼‰è¿™äº›åˆ—å„è‡ªå‡†ç¡®ï¼ˆä¾‹å¦‚ï¼Œä½¿ç”¨åŠ æ³•å’Œä¹˜æ³•æ˜¯åˆé€‚çš„ï¼‰ï¼Œå¹¶ä¸”ï¼ˆbï¼‰è¶³å¤Ÿï¼ˆå³ï¼Œç»“åˆåœ¨ä¸€èµ·ï¼Œå®ƒä»¬å¯ä»¥è§£é‡Šå°†ç”±è¯¥`cond`å­å¥æ‰§è¡Œçš„æ‰€æœ‰æ“ä½œï¼‰ã€‚
- en: 'Itâ€™s easiest to understand this by applying it to a few examples. First, letâ€™s
    consider the `len` function, noting before we proceed that it does meet the criterion
    of having a single recursive call where the argument is structural:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡åº”ç”¨å‡ ä¸ªä¾‹å­æ¥ç†è§£è¿™ä¸€ç‚¹æ˜¯æœ€å®¹æ˜“çš„ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬è€ƒè™‘`len`å‡½æ•°ï¼Œåœ¨ç»§ç»­ä¹‹å‰è¦æ³¨æ„å®ƒç¡®å®æ»¡è¶³åªæœ‰ä¸€ä¸ªç»“æ„åŒ–å‚æ•°çš„é€’å½’è°ƒç”¨çš„æ ‡å‡†ï¼š
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Letâ€™s compute the cost of running `len` on a list of length \(k\) (where we
    are only counting the number of `link`s in the list, and ignoring the content
    of each first element (`f`), since `len` ignores them too).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è®¡ç®—åœ¨é•¿åº¦ä¸º\(k\)çš„åˆ—è¡¨ä¸Šè¿è¡Œ`len`çš„æˆæœ¬ï¼ˆåœ¨è¿™é‡Œæˆ‘ä»¬åªè®¡ç®—åˆ—è¡¨ä¸­çš„`link`æ•°é‡ï¼Œå¹¶å¿½ç•¥æ¯ä¸ªç¬¬ä¸€ä¸ªå…ƒç´ çš„å†…å®¹ï¼ˆ`f`ï¼‰ï¼Œå› ä¸º`len`ä¹Ÿå¿½ç•¥å®ƒä»¬ï¼‰ã€‚
- en: Because the entire body of `len` is given by a conditional, we can proceed directly
    to building the table.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸º`len`å‡½æ•°çš„ä¸»ä½“å®Œå…¨ç”±ä¸€ä¸ªæ¡ä»¶è¡¨è¾¾å¼ç»™å‡ºï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥å¼€å§‹æ„å»ºè¡¨æ ¼ã€‚
- en: Letâ€™s consider the first row. The question costs three units (one each to evaluate
    the implicit `empty`-ness predicate, `l`, and to apply the former to the latter).
    This is evaluated once per element in the list and once more when the list is
    empty, i.e., \(k+1\) times. The total cost of the question is thus \(3(k+1)\).
    The answer takes one unit of time to compute, and is evaluated only once (when
    the list is empty). Thus it takes a total of one unit, for a total of \(3k+4\)
    units.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è€ƒè™‘ç¬¬ä¸€è¡Œã€‚é—®é¢˜èŠ±è´¹ä¸‰ä¸ªå•ä½ï¼ˆæ¯ä¸ªå…ƒç´ è¯„ä¼°éšå«çš„`empty`-nessè°“è¯`l`ï¼Œå¹¶å°†å‰è€…åº”ç”¨äºåè€…ï¼‰ã€‚è¿™æ˜¯å¯¹åˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ è¯„ä¼°ä¸€æ¬¡ï¼Œå½“åˆ—è¡¨ä¸ºç©ºæ—¶å†è¯„ä¼°ä¸€æ¬¡ï¼Œå³\(k+1\)æ¬¡ã€‚å› æ­¤ï¼Œé—®é¢˜çš„æ€»æˆæœ¬æ˜¯\(3(k+1)\)ã€‚ç­”æ¡ˆçš„è®¡ç®—éœ€è¦ä¸€å•ä½æ—¶é—´ï¼Œå¹¶ä¸”åªè¯„ä¼°ä¸€æ¬¡ï¼ˆå½“åˆ—è¡¨ä¸ºç©ºæ—¶ï¼‰ã€‚å› æ­¤ï¼Œæ€»å…±éœ€è¦ä¸€å•ä½æ—¶é—´ï¼Œæ€»æˆæœ¬ä¸º\(3k+4\)å•ä½ã€‚
- en: Now for the second row. The question again costs three units, and is evaluated
    \(k\) times. The answer involves two units to evaluate the rest of the list `l.rest`,
    which is implicitly hidden by the naming of `r`, two more to evaluate and apply
    `1 +`, one more to evaluate `len`...and no more, because we are ignoring the time
    spent in the recursive call itself. In short, it takes five units of time (in
    addition to the recursion weâ€™ve chosen to ignore).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æ¥çœ‹ç¬¬äºŒè¡Œã€‚é—®é¢˜å†æ¬¡èŠ±è´¹ä¸‰ä¸ªå•ä½ï¼Œè¯„ä¼°\(k\)æ¬¡ã€‚ç­”æ¡ˆæ¶‰åŠä¸¤ä¸ªå•ä½æ¥è¯„ä¼°åˆ—è¡¨`l.rest`çš„å…¶ä½™éƒ¨åˆ†ï¼Œè¿™éƒ¨åˆ†è¢«`r`çš„å‘½åéšå«åœ°éšè—ï¼Œè¿˜éœ€è¦ä¸¤ä¸ªå•ä½æ¥è¯„ä¼°å’Œæ‰§è¡Œ`1
    +`ï¼Œè¿˜éœ€è¦ä¸€ä¸ªå•ä½æ¥è¯„ä¼°`len`...ç­‰ç­‰ï¼Œå› ä¸ºæˆ‘ä»¬å¿½ç•¥äº†é€’å½’è°ƒç”¨æœ¬èº«æ‰€èŠ±è´¹çš„æ—¶é—´ã€‚ç®€è€Œè¨€ä¹‹ï¼Œå®ƒéœ€è¦äº”ä¸ªå•ä½çš„æ—¶é—´ï¼ˆé™¤äº†æˆ‘ä»¬é€‰æ‹©å¿½ç•¥çš„é€’å½’æ—¶é—´ï¼‰ã€‚
- en: 'In tabular form:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥è¡¨æ ¼å½¢å¼ï¼š
- en: '| &#124;Q&#124; |  | #Q |  | TotQ |  | &#124;A&#124; |  | #A |  | TotA |  |
    Total |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| &#124;Q&#124; |  | #Q |  | TotQ |  | &#124;A&#124; |  | #A |  | TotA |  |
    Total |'
- en: '| \(3\) |  | \(k+1\) |  | \(3(k+1)\) |  | \(1\) |  | \(1\) |  | \(1\) |  |
    \(3k+4\) |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| \(3\) |  | \(k+1\) |  | \(3(k+1)\) |  | \(1\) |  | \(1\) |  | \(1\) |  |
    \(3k+4\) |'
- en: '| \(3\) |  | \(k\) |  | \(3k\) |  | \(5\) |  | \(k\) |  | \(5k\) |  | \(8k\)
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| \(3\) |  | \(k\) |  | \(3k\) |  | \(5\) |  | \(k\) |  | \(5k\) |  | \(8k\)
    |'
- en: Adding, we get \(11k + 4\). Thus running `len` on a \(k\)-element list takes
    \(11k+4\) units of time.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åŠ ï¼Œæˆ‘ä»¬å¾—åˆ°\(11k + 4\)ã€‚å› æ­¤ï¼Œåœ¨\(k\)ä¸ªå…ƒç´ çš„åˆ—è¡¨ä¸Šè¿è¡Œ`len`éœ€è¦\(11k+4\)å•ä½æ—¶é—´ã€‚
- en: Exercise
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How accurate is this estimate? If you try applying `len` to different sizes
    of lists, do you obtain a consistent estimate for \(k\)?
  id: totrans-84
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™ä¸ªä¼°è®¡æœ‰å¤šå‡†ç¡®ï¼Ÿå¦‚æœä½ å°è¯•å°†`len`åº”ç”¨äºä¸åŒå¤§å°çš„åˆ—è¡¨ï¼Œä½ æ˜¯å¦è·å¾—äº†å¯¹\(k\)çš„ä¸€è‡´ä¼°è®¡ï¼Ÿ
- en: 14.6Â Creating Recurrences[ğŸ”—](#(part._creating-recurrences) "Link to here")
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.6Â åˆ›å»ºé€’å½’[ğŸ”—](#(part._creating-recurrences) "é“¾æ¥åˆ°æ­¤å¤„")
- en: We will now see a systematic way of analytically computing the time of a program.
    Suppose we have only one function `f`. We will define a function, \(T\), to compute
    an upper-bound of the time of `f`.In general, we will have one such cost function
    for each function in the program. In such cases, it would be useful to give a
    different name to each function to easily tell them apart. Since we are looking
    at only one function for now, weâ€™ll reduce notational overhead by having only
    one \(T\). \(T\) takes as many parameters as `f` does. The parameters to \(T\)
    represent the sizes of the corresponding arguments to `f`. Eventually we will
    want to arrive at a closed form solution to \(T\), i.e., one that does not refer
    to \(T\) itself. But the easiest way to get there is to write a solution that
    is permitted to refer to \(T\), called a recurrence relation, and then see how
    to eliminate the self-reference [[Solving Recurrences](#%28part._solving-recurrences%29)].
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨å°†çœ‹åˆ°ä¸€ç§ç³»ç»ŸåŒ–çš„æ–¹æ³•æ¥åˆ†æè®¡ç®—ç¨‹åºçš„æ—¶é—´ã€‚å‡è®¾æˆ‘ä»¬åªæœ‰ä¸€ä¸ªå‡½æ•° `f`ã€‚æˆ‘ä»¬å°†å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œ\(T\)ï¼Œæ¥è®¡ç®— `f` çš„æ—¶é—´ä¸Šç•Œã€‚ä¸€èˆ¬æ¥è¯´ï¼Œæˆ‘ä»¬å°†åœ¨ç¨‹åºä¸­çš„æ¯ä¸ªå‡½æ•°éƒ½æœ‰ä¸€ä¸ªè¿™æ ·çš„æˆæœ¬å‡½æ•°ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä¸ºæ¯ä¸ªå‡½æ•°ç»™å‡ºä¸åŒçš„åå­—ä»¥æ–¹ä¾¿åŒºåˆ†æ˜¯æœ‰ç”¨çš„ã€‚ç”±äºæˆ‘ä»¬ç°åœ¨åªå…³æ³¨ä¸€ä¸ªå‡½æ•°ï¼Œæˆ‘ä»¬å°†é€šè¿‡åªæœ‰ä¸€ä¸ª
    \(T\) æ¥å‡å°‘è®°å·å¼€é”€ã€‚\(T\) æœ‰ä¸ `f` ç›¸åŒæ•°é‡çš„å‚æ•°ã€‚\(T\) çš„å‚æ•°ä»£è¡¨ `f` å¯¹åº”å‚æ•°çš„å¤§å°ã€‚æœ€ç»ˆï¼Œæˆ‘ä»¬å¸Œæœ›å¾—åˆ°ä¸€ä¸ªå°é—­å½¢å¼çš„è§£ \(T\)ï¼Œå³ä¸å¼•ç”¨
    \(T\) è‡ªèº«çš„è§£ã€‚ä½†åˆ°è¾¾é‚£é‡Œçš„æœ€ç®€å•æ–¹æ³•æ˜¯å†™ä¸€ä¸ªå…è®¸å¼•ç”¨ \(T\) çš„è§£ï¼Œç§°ä¸ºé€’å½’å…³ç³»ï¼Œç„¶åçœ‹çœ‹å¦‚ä½•æ¶ˆé™¤è‡ªæˆ‘å¼•ç”¨ [[è§£å†³é€’å½’å…³ç³»](#(part._solving-recurrences))]ã€‚
- en: We repeat this procedure for each function in the program in turn. If there
    are many functions, first solve for the one with no dependencies on other functions,
    then use its solution to solve for a function that depends only on it, and progress
    thus up the dependency chain. That way, when we get to a function that refers
    to other functions, we will already have a closed-form solution for the referred
    functionâ€™s running time and can simply plug in parameters to obtain a solution.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†ä¾æ¬¡å¯¹ç¨‹åºä¸­çš„æ¯ä¸ªå‡½æ•°é‡å¤æ­¤è¿‡ç¨‹ã€‚å¦‚æœæœ‰è®¸å¤šå‡½æ•°ï¼Œé¦–å…ˆè§£å†³é‚£äº›ä¸ä¾èµ–äºå…¶ä»–å‡½æ•°çš„å‡½æ•°ï¼Œç„¶åä½¿ç”¨å…¶è§£æ¥è§£å†³ä»…ä¾èµ–äºå®ƒçš„å‡½æ•°ï¼Œå¹¶æ²¿ç€ä¾èµ–é“¾å‘ä¸Šæ¨è¿›ã€‚è¿™æ ·ï¼Œå½“æˆ‘ä»¬åˆ°è¾¾ä¸€ä¸ªå¼•ç”¨å…¶ä»–å‡½æ•°çš„å‡½æ•°æ—¶ï¼Œæˆ‘ä»¬å·²ç»æœ‰äº†ä¸€ä¸ªå…³äºè¢«å¼•ç”¨å‡½æ•°è¿è¡Œæ—¶é—´çš„å°é—­å½¢å¼è§£ï¼Œå¯ä»¥ç®€å•åœ°æ’å…¥å‚æ•°ä»¥è·å¾—ä¸€ä¸ªè§£ã€‚
- en: Exercise
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The strategy outlined above doesnâ€™t work when there are functions that depend
    on each other. How would you generalize it to handle this case?
  id: totrans-90
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å½“æœ‰å‡½æ•°ç›¸äº’ä¾èµ–æ—¶ï¼Œä¸Šè¿°ç­–ç•¥ä¸èµ·ä½œç”¨ã€‚ä½ å°†å¦‚ä½•æ³›åŒ–å®ƒä»¥å¤„ç†è¿™ç§æƒ…å†µï¼Ÿ
- en: The process of setting up a recurrence is easy. We simply define the right-hand-side
    of \(T\) to add up the operations performed in `f`â€™s body. This is straightforward
    except for conditionals and recursion. Weâ€™ll elaborate on the treatment of conditionals
    in a moment. If we get to a recursive call to `f` on the argument `a`, in the
    recurrence we turn this into a (self-)reference to \(T\) on the size of `a`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: è®¾ç½®é€’å½’çš„è¿‡ç¨‹å¾ˆç®€å•ã€‚æˆ‘ä»¬åªéœ€å°† \(T\) çš„å³ä¾§å®šä¹‰ä¸ºåœ¨ `f` çš„ä¸»ä½“ä¸­æ‰§è¡Œçš„æ“ä½œçš„æ€»å’Œã€‚è¿™å¾ˆç®€å•ï¼Œé™¤äº†æ¡ä»¶å’Œé€’å½’ã€‚æˆ‘ä»¬å°†åœ¨ç¨åè¯¦ç»†è¯´æ˜å¯¹æ¡ä»¶çš„å¤„ç†ã€‚å¦‚æœæˆ‘ä»¬å¯¹
    `f` çš„å‚æ•° `a` è¿›è¡Œé€’å½’è°ƒç”¨ï¼Œåœ¨é€’å½’ä¸­ï¼Œæˆ‘ä»¬å°†æ­¤è½¬æ¢ä¸ºå¯¹ `a` å¤§å°ä¸Šçš„ \(T\) çš„ï¼ˆè‡ªæˆ‘ï¼‰å¼•ç”¨ã€‚
- en: 'For conditionals, we use only the |Q| and |A| columns of the corresponding
    table. Rather than multiplying by the size of the input, we add up the operations
    that happen on one invocation of `f` other than the recursive call, and then add
    the cost of the recursive call in terms of a reference to \(T\). Thus, if we were
    doing this for `len` above, we would define \(T(k)\)â€”<wbr>the time needed on an
    input of length \(k\)â€”<wbr>in two parts: the value of \(T(0)\) (when the list
    is empty) and the value for non-zero values of \(k\). We know that \(T(0) = 4\)
    (the cost of the first conditional and its corresponding answer). If the list
    is non-empty, the cost is \(T(k) = 3 + 3 + 5 + T(k-1)\) (respectively from the
    first question, the second question, the remaining operations in the second answer,
    and the recursive call on a list one element smaller). This gives the following
    recurrence:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæ¡ä»¶è¯­å¥ï¼Œæˆ‘ä»¬åªä½¿ç”¨å¯¹åº”è¡¨æ ¼ä¸­çš„ |Q| å’Œ |A| åˆ—ã€‚æˆ‘ä»¬ä¸æ˜¯é€šè¿‡ä¹˜ä»¥è¾“å…¥çš„å¤§å°æ¥è®¡ç®—ï¼Œè€Œæ˜¯å°† `f` çš„ä¸€æ¬¡è°ƒç”¨ä¸­é™¤é€’å½’è°ƒç”¨ä¹‹å¤–çš„æ“ä½œç´¯åŠ èµ·æ¥ï¼Œç„¶ååŠ ä¸Šé€’å½’è°ƒç”¨çš„æˆæœ¬ï¼Œå³å¯¹
    \(T\) çš„å¼•ç”¨ã€‚å› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬å¯¹ä¸Šé¢çš„ `len` è¿›è¡Œè¿™æ ·çš„æ“ä½œï¼Œæˆ‘ä»¬å°† \(T(k)\)â€”â€”å³è¾“å…¥é•¿åº¦ä¸º \(k\) æ—¶æ‰€éœ€çš„æ—¶é—´â€”â€”å®šä¹‰ä¸ºä¸¤éƒ¨åˆ†ï¼š\(T(0)\)
    çš„å€¼ï¼ˆå½“åˆ—è¡¨ä¸ºç©ºæ—¶ï¼‰å’Œ \(k\) ä¸ä¸ºé›¶æ—¶çš„å€¼ã€‚æˆ‘ä»¬çŸ¥é“ \(T(0) = 4\)ï¼ˆç¬¬ä¸€ä¸ªæ¡ä»¶åŠå…¶å¯¹åº”ç­”æ¡ˆçš„æˆæœ¬ï¼‰ã€‚å¦‚æœåˆ—è¡¨ä¸ä¸ºç©ºï¼Œæˆæœ¬ä¸º \(T(k)
    = 3 + 3 + 5 + T(k-1)\)ï¼ˆåˆ†åˆ«æ¥è‡ªç¬¬ä¸€ä¸ªé—®é¢˜ã€ç¬¬äºŒä¸ªé—®é¢˜ã€ç¬¬äºŒä¸ªç­”æ¡ˆä¸­çš„å‰©ä½™æ“ä½œï¼Œä»¥åŠåˆ—è¡¨ä¸­ä¸€ä¸ªå…ƒç´ æ›´å°çš„é€’å½’è°ƒç”¨ï¼‰ã€‚è¿™ç»™å‡ºäº†ä»¥ä¸‹é€’å½’å…³ç³»ï¼š
- en: \begin{equation*}T(k) = \begin{cases} 4 & \text{when } k = 0 \\ 11 + T(k-1)
    & \text{when } k > 0\\ \end{cases}\end{equation*}
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}T(k) = \begin{cases} 4 & \text{when } k = 0 \\ 11 + T(k-1)
    & \text{when } k > 0\\ \end{cases}\end{equation*}
- en: 'For a given list that is \(p\) elements long (note that \(p \geq 0\)), this
    would take \(11\) steps for the first element, \(11\) more steps for the second,
    \(11\) more for the third, and so on, until we run out of list elements and need
    \(4\) more steps: a total of \(11p + 4\) steps. Notice this is precisely the same
    answer we obtained by the tabular method!'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºä¸€ä¸ªé•¿åº¦ä¸º \(p\) çš„ç»™å®šåˆ—è¡¨ï¼ˆæ³¨æ„ \(p \geq 0\)ï¼‰ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ éœ€è¦ \(11\) æ­¥ï¼Œç¬¬äºŒä¸ªå…ƒç´ éœ€è¦ \(11\) æ›´å¤šæ­¥ï¼Œç¬¬ä¸‰ä¸ªå…ƒç´ éœ€è¦
    \(11\) æ›´å¤šæ­¥ï¼Œä»¥æ­¤ç±»æ¨ï¼Œç›´åˆ°æˆ‘ä»¬ç”¨å®Œåˆ—è¡¨å…ƒç´ å¹¶éœ€è¦é¢å¤–çš„ \(4\) æ­¥ï¼šæ€»å…± \(11p + 4\) æ­¥ã€‚æ³¨æ„ï¼Œè¿™æ­£æ˜¯æˆ‘ä»¬é€šè¿‡è¡¨æ ¼æ–¹æ³•å¾—åˆ°çš„ç»“æœï¼
- en: Exercise
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why can we assume that for a list \(p\) elements long, \(p \geq 0\)? And why
    did we take the trouble to explicitly state this above?
  id: totrans-97
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆæˆ‘ä»¬å¯ä»¥å‡è®¾å¯¹äºä¸€ä¸ªé•¿åº¦ä¸º \(p\) çš„åˆ—è¡¨ï¼Œ\(p \geq 0\)ï¼Ÿä¸ºä»€ä¹ˆæˆ‘ä»¬è´¹å¿ƒåœ¨ä¸Šè¿°å†…å®¹ä¸­æ˜ç¡®åœ°å£°æ˜è¿™ä¸€ç‚¹ï¼Ÿ
- en: With some thought, you can see that the idea of constructing a recurrence works
    even when there is more than one recursive call, and when the argument to that
    call is one element structurally smaller. What we havenâ€™t seen, however, is a
    way to solve such relations in general. Thatâ€™s where weâ€™re going next [[Solving
    Recurrences](#%28part._solving-recurrences%29)].
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ç»è¿‡ä¸€äº›æ€è€ƒï¼Œä½ å¯ä»¥çœ‹åˆ°ï¼Œå½“å­˜åœ¨å¤šä¸ªé€’å½’è°ƒç”¨ï¼Œå¹¶ä¸”è°ƒç”¨å‚æ•°åœ¨ç»“æ„ä¸Šæ›´å°çš„æ—¶å€™ï¼Œæ„å»ºé€’å½’å…³ç³»çš„æƒ³æ³•ä¹Ÿæ˜¯å¯è¡Œçš„ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬æ²¡æœ‰çœ‹åˆ°ä¸€ç§è§£å†³è¿™ç±»å…³ç³»çš„ä¸€èˆ¬æ–¹æ³•ã€‚è¿™å°±æ˜¯æˆ‘ä»¬æ¥ä¸‹æ¥è¦è®¨è®ºçš„
    [[æ±‚è§£é€’å½’å…³ç³»](#%28part._solving-recurrences%29)]ã€‚
- en: 14.7Â A Notation for Functions[ğŸ”—](#(part._math-anon-functions) "Link to here")
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.7 å‡½æ•°çš„è¡¨ç¤ºæ³•[ğŸ”—](#(part._math-anon-functions) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'We have seen above that we can describe the running time of `len` through a
    function. We donâ€™t have an especially good notation for writing such (anonymous)
    functions. Wait, we doâ€”<wbr>`lam(k): (11 * k) + 4 end`â€”<wbr>but my colleagues
    would be horrified if you wrote this on their exams. Therefore, weâ€™ll introduce
    the following notation to mean precisely the same thing:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 'æˆ‘ä»¬åœ¨ä¸Šé¢å·²ç»çœ‹åˆ°ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸€ä¸ªå‡½æ•°æ¥æè¿° `len` çš„è¿è¡Œæ—¶é—´ã€‚æˆ‘ä»¬æ²¡æœ‰ç‰¹åˆ«å¥½çš„ç¬¦å·æ¥ç¼–å†™è¿™æ ·çš„ï¼ˆåŒ¿åï¼‰å‡½æ•°ã€‚ç­‰ç­‰ï¼Œæˆ‘ä»¬ç¡®å®æœ‰â€”â€”<wbr>`lam(k):
    (11 * k) + 4 end`â€”<wbr>ä½†å¦‚æœä½ åœ¨åŒäº‹çš„è€ƒè¯•ä¸­å†™ä¸‹è¿™ä¸ªï¼Œä»–ä»¬å¯èƒ½ä¼šå¾ˆéœ‡æƒŠã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°†å¼•å…¥ä»¥ä¸‹ç¬¦å·æ¥ç²¾ç¡®åœ°è¡¨è¾¾ç›¸åŒçš„æ„æ€ï¼š'
- en: \begin{equation*}[k \rightarrow 11k + 4]\end{equation*}
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}[k \rightarrow 11k + 4]\end{equation*}
- en: The brackets denote anonymous functions, with the parameters before the arrow
    and the body after.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: æ‹¬å·è¡¨ç¤ºåŒ¿åå‡½æ•°ï¼Œç®­å¤´å‰çš„å‚æ•°å’Œç®­å¤´åçš„å‡½æ•°ä½“ã€‚
- en: 14.8Â Comparing Functions[ğŸ”—](#(part._big-oh-def) "Link to here")
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.8 æ¯”è¾ƒå‡½æ•°[ğŸ”—](#(part._big-oh-def) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Letâ€™s return to the running time of `len`. Weâ€™ve written down a function of
    great precision: 11! 4! Is this justified?'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å›åˆ° `len` çš„è¿è¡Œæ—¶é—´ã€‚æˆ‘ä»¬å·²ç»å†™ä¸‹äº†ä¸€ä¸ªéå¸¸ç²¾ç¡®çš„å‡½æ•°ï¼š11! 4! è¿™æ˜¯æœ‰é“ç†çš„å—ï¼Ÿ
- en: At a fine-grained level already, no, itâ€™s not. Weâ€™ve lumped many operations,
    with different actual running times, into a cost of one. So perhaps we should
    not worry too much about the differences between, say, \([k \rightarrow 11k +
    4]\) and \([k \rightarrow 4k + 10]\). If we were given two implementations with
    these running times, respectively, itâ€™s likely that we would pick other characteristics
    to choose between them.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç»†ç²’åº¦å±‚é¢ä¸Šï¼Œä¸ï¼Œå¹¶ä¸æ˜¯è¿™æ ·ã€‚æˆ‘ä»¬å·²ç»å°†è®¸å¤šå…·æœ‰ä¸åŒå®é™…è¿è¡Œæ—¶é—´çš„æ“ä½œåˆå¹¶ä¸ºä¸€ä¸ªæˆæœ¬ã€‚å› æ­¤ï¼Œä¹Ÿè®¸æˆ‘ä»¬ä¸å¿…è¿‡äºæ‹…å¿ƒï¼Œæ¯”å¦‚ \([k \rightarrow
    11k + 4]\) å’Œ \([k \rightarrow 4k + 10]\) ä¹‹é—´çš„å·®å¼‚ã€‚å¦‚æœæˆ‘ä»¬åˆ†åˆ«ç»™å‡ºäº†å…·æœ‰è¿™äº›è¿è¡Œæ—¶é—´çš„ä¸¤ä¸ªå®ç°ï¼Œæˆ‘ä»¬å¾ˆå¯èƒ½ä¼šé€‰æ‹©å…¶ä»–ç‰¹å¾æ¥åŒºåˆ†å®ƒä»¬ã€‚
- en: 'What this boils down to is being able to compare two functions (representing
    the performance of implementations) for whether one is somehow quantitatively
    better in some meaningful sense than the other: i.e., is the quantitative difference
    so great that it might lead to a qualitative one. The example above suggests that
    small differences in constants probably do not matter.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å®é™…ä¸Šæ„å‘³ç€èƒ½å¤Ÿæ¯”è¾ƒä¸¤ä¸ªå‡½æ•°ï¼ˆä»£è¡¨å®ç°çš„æ€§èƒ½ï¼‰ï¼Œçœ‹å…¶ä¸­ä¸€ä¸ªæ˜¯å¦åœ¨æŸäº›æœ‰æ„ä¹‰çš„æ„ä¹‰ä¸Šæ¯”å¦ä¸€ä¸ªå®šé‡åœ°æ›´å¥½ï¼šå³ï¼Œè¿™ç§å®šé‡å·®å¼‚æ˜¯å¦å¦‚æ­¤ä¹‹å¤§ï¼Œä»¥è‡³äºå¯èƒ½å¯¼è‡´å®šæ€§å·®å¼‚ã€‚ä¸Šé¢çš„ä¾‹å­è¡¨æ˜ï¼Œå¸¸æ•°ä¹‹é—´çš„å¾®å°å·®å¼‚å¯èƒ½å¹¶ä¸é‡è¦ã€‚
- en: 'That is, we want a way to compare two functions, \(f_1\) and \(f_2\). What
    does it mean for \(f_1\) to be â€œlessâ€ than \(f_2\), without worrying about constants?
    We obtain this definition:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬æƒ³è¦ä¸€ç§æ–¹æ³•æ¥æ¯”è¾ƒä¸¤ä¸ªå‡½æ•° \(f_1\) å’Œ \(f_2\)ã€‚\(f_1\) æ¯” \(f_2\) â€œå°â€æ„å‘³ç€ä»€ä¹ˆï¼Œè€Œä¸å¿…æ‹…å¿ƒå¸¸æ•°ï¼Ÿæˆ‘ä»¬å¾—åˆ°ä»¥ä¸‹å®šä¹‰ï¼š
- en: \begin{equation*}\exists c . \forall n \in \mathbb{N}, f_1(n) \leq c \cdot f_2(n)
    \Rightarrow f_1 \leq f_2\end{equation*}
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}\exists c . \forall n \in \mathbb{N}, f_1(n) \leq c \cdot f_2(n)
    \Rightarrow f_1 \leq f_2\end{equation*}
- en: 'This says that for all natural numbers (\(N\)), the value of \(f_1\) will always
    be less than the value of \(f_2\). However, to accommodate our intution that multiplicative
    constants donâ€™t matter, the definition allows the value of \(f_2\) at all points
    to be multiplied by some constant \(c\) to achieve the inequality. Observe, however,
    that \(c\) is independent of \(n\): it is chosen once and must then work for the
    infinite number of values. In practice, this means that the presence of \(c\)
    lets us bypass some number of early values where \(f_1\) might have a greater
    value than \(f_2\), so long as, after a point, \(f_2\) dominates \(f_1\).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ„å‘³ç€å¯¹äºæ‰€æœ‰è‡ªç„¶æ•° (\(N\))ï¼Œ\(f_1\) çš„å€¼å°†å§‹ç»ˆå°äº \(f_2\) çš„å€¼ã€‚ç„¶è€Œï¼Œä¸ºäº†é€‚åº”æˆ‘ä»¬å…³äºä¹˜æ³•å¸¸æ•°æ— å…³ç´§è¦çš„ç›´è§‰ï¼Œå®šä¹‰å…è®¸å°†
    \(f_2\) åœ¨æ‰€æœ‰ç‚¹çš„å€¼ä¹˜ä»¥æŸä¸ªå¸¸æ•° \(c\) ä»¥è¾¾åˆ°ä¸ç­‰å¼ã€‚ç„¶è€Œï¼Œè¯·æ³¨æ„ï¼Œ\(c\) ä¸ \(n\) æ— å…³ï¼šå®ƒåªé€‰æ‹©ä¸€æ¬¡ï¼Œç„¶åå¿…é¡»é€‚ç”¨äºæ— é™å¤šä¸ªå€¼ã€‚åœ¨å®è·µä¸­ï¼Œè¿™æ„å‘³ç€
    \(c\) çš„å­˜åœ¨ä½¿æˆ‘ä»¬èƒ½å¤Ÿç»•è¿‡ä¸€äº›æ—©æœŸå€¼ï¼Œåœ¨è¿™äº›å€¼ä¸­ \(f_1\) å¯èƒ½æ¯” \(f_2\) å¤§ï¼Œåªè¦åœ¨æŸä¸ªç‚¹ä¹‹å \(f_2\) ä¸»å¯¼ \(f_1\)ã€‚
- en: 'This definition has more flexibility than we might initially think. For instance,
    consider our running example compared with \([k \rightarrow k^2]\). Clearly, the
    latter function eventually dominates the former: i.e.,'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªå®šä¹‰æ¯”æˆ‘ä»¬æœ€åˆæƒ³è±¡çš„è¦çµæ´»ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘æˆ‘ä»¬çš„è¿è¡Œç¤ºä¾‹ä¸ \([k \rightarrow k^2]\) çš„æ¯”è¾ƒã€‚æ˜¾ç„¶ï¼Œåè€…å‡½æ•°æœ€ç»ˆä¼šä¸»å¯¼å‰è€…ï¼šå³ï¼Œ
- en: \begin{equation*}[k \rightarrow 11k+4] \leq [k \rightarrow k^2]\end{equation*}
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}[k \rightarrow 11k+4] \leq [k \rightarrow k^2]\end{equation*}
- en: We just need to pick a sufficiently large constant and we will find this to
    be true.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åªéœ€è¦é€‰æ‹©ä¸€ä¸ªè¶³å¤Ÿå¤§çš„å¸¸æ•°ï¼Œæˆ‘ä»¬å°±ä¼šæ‰¾åˆ°è¿™æ˜¯çœŸçš„ã€‚
- en: Exercise
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the smallest constant that will suffice?
  id: totrans-115
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä»€ä¹ˆæ˜¯æœ€å°çš„å¸¸æ•°ï¼Œè¶³ä»¥æ»¡è¶³æ¡ä»¶ï¼Ÿ
- en: You will find more complex definitions in the literature and they all have merits,
    because they enable us to make finer-grained distinctions than this definition
    allows. For the purpose of this book, however, the above definition suffices.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å°†åœ¨æ–‡çŒ®ä¸­æ‰¾åˆ°æ›´å¤æ‚çš„å®šä¹‰ï¼Œå®ƒä»¬éƒ½æœ‰ä¼˜ç‚¹ï¼Œå› ä¸ºå®ƒä»¬ä½¿æˆ‘ä»¬èƒ½å¤Ÿæ¯”è¿™ä¸ªå®šä¹‰å…è®¸çš„åšå‡ºæ›´ç²¾ç»†çš„åŒºåˆ†ã€‚ç„¶è€Œï¼Œå¯¹äºæœ¬ä¹¦çš„ç›®çš„ï¼Œä¸Šè¿°å®šä¹‰å°±è¶³å¤Ÿäº†ã€‚
- en: Do Now!
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¿›è¡Œï¼
- en: ''
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why are the quantifiers written in this and not the opposite order? What if
    we had swapped them, so that we could choose a \(c\) for each \(n\)?
  id: totrans-119
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆé‡è¯çš„å†™æ³•æ˜¯è¿™ä¸ªé¡ºåºè€Œä¸æ˜¯ç›¸åçš„é¡ºåºï¼Ÿå¦‚æœæˆ‘ä»¬äº¤æ¢å®ƒä»¬ï¼Œé‚£ä¹ˆæˆ‘ä»¬èƒ½ä¸ºæ¯ä¸ª \(n\) é€‰æ‹©ä¸€ä¸ª \(c\) å‘¢ï¼Ÿ
- en: Had we swapped the order, it would mean that for every point along the number
    line, there must exist a constantâ€”<wbr>and there pretty much always does! The
    swapped definition would therefore be useless. What is important is that we can
    identify the constant no matter how large the parameter gets. That is what makes
    this truly a constant.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬äº¤æ¢äº†é¡ºåºï¼Œè¿™æ„å‘³ç€åœ¨æ•°è½´ä¸Šçš„æ¯ä¸€ä¸ªç‚¹ï¼Œéƒ½å¿…é¡»å­˜åœ¨ä¸€ä¸ªå¸¸æ•°â€”â€”å®é™…ä¸Šå‡ ä¹æ€»æ˜¯å­˜åœ¨ï¼å› æ­¤ï¼Œäº¤æ¢åçš„å®šä¹‰å°†æ¯«æ— ç”¨å¤„ã€‚é‡è¦çš„æ˜¯ï¼Œæ— è®ºå‚æ•°æœ‰å¤šå¤§ï¼Œæˆ‘ä»¬éƒ½èƒ½è¯†åˆ«å‡ºè¿™ä¸ªå¸¸æ•°ã€‚è¿™å°±æ˜¯å®ƒçœŸæ­£æˆä¸ºå¸¸æ•°çš„åŸå› ã€‚
- en: Observe that for a given function \(f\), there are numerous functions that are
    less than it. We use the notation \(O(\cdot)\) to describe this family of functions.In
    computer science this is usually pronounced â€œbig-Ohâ€, though some prefer to call
    it the Bachmann-Landau notation after its originators. Thus if \(g \leq f\), we
    can write \(g \in O(f)\), which we can read as â€œ\(f\) is an upper-bound for \(g\)â€.
    Thus, for instance,
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå¯¹äºç»™å®šçš„å‡½æ•° \(f\)ï¼Œæœ‰æ— æ•°ä¸ªå‡½æ•°çš„å€¼éƒ½å°äºå®ƒã€‚æˆ‘ä»¬ä½¿ç”¨ \(O(\cdot)\) ç¬¦å·æ¥æè¿°è¿™ä¸ªå‡½æ•°æ—ã€‚åœ¨è®¡ç®—æœºç§‘å­¦ä¸­ï¼Œè¿™é€šå¸¸è¯»ä½œâ€œå¤§Oâ€ï¼Œå°½ç®¡æœ‰äº›äººæ›´å–œæ¬¢å°†å…¶ç§°ä¸ºå…¶åˆ›å§‹äºº
    Bachmann-Landau çš„ç¬¦å·ã€‚å› æ­¤ï¼Œå¦‚æœ \(g \leq f\)ï¼Œæˆ‘ä»¬å¯ä»¥å†™æˆ \(g \in O(f)\)ï¼Œæˆ‘ä»¬å¯ä»¥è¯»ä½œâ€œ\(f\) æ˜¯ \(g\)
    çš„ä¸Šç•Œâ€ã€‚å› æ­¤ï¼Œä¾‹å¦‚ï¼Œ
- en: \begin{equation*}[k \rightarrow 3k] \in O([k \rightarrow 4k+12])\end{equation*}
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}[k \rightarrow 3k] \in O([k \rightarrow 4k+12])\end{equation*}
- en: \begin{equation*}[k \rightarrow 4k+12] \in O([k \rightarrow k^2])\end{equation*}
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}[k \rightarrow 4k+12] \in O([k \rightarrow k^2])\end{equation*}
- en: and so on. Obviously, the â€œbiggerâ€ function is likely to be a less useful bound
    than a â€œtighterâ€ one. That said, it is conventional to write a â€œminimalâ€ bound
    for functions, which means avoiding unnecessary constants, sum terms, and so on.
    The justification for this is given below [[Combining Big-Oh Without Woe](#%28part._big-oh-closure%29)].
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥åŠç­‰ç­‰ã€‚æ˜¾ç„¶ï¼Œâ€œæ›´å¤§çš„â€å‡½æ•°å¯èƒ½æ¯”â€œæ›´ç´§çš„â€å‡½æ•°ä½œä¸ºä¸€ä¸ªç•Œé™ä¸é‚£ä¹ˆæœ‰ç”¨ã€‚ç„¶è€Œï¼Œä¼ ç»Ÿä¸Šå†™ä¸€ä¸ªâ€œæœ€å°â€ç•Œé™å¯¹äºå‡½æ•°ï¼Œè¿™æ„å‘³ç€é¿å…ä¸å¿…è¦çš„å¸¸æ•°ã€æ±‚å’Œé¡¹ç­‰ç­‰ã€‚è¿™ç§åšæ³•çš„åˆç†æ€§å°†åœ¨ä¸‹é¢ç»™å‡º
    [[æ— çƒ¦æ¼åœ°ç»“åˆå¤§Oç¬¦å·](#%28part._big-oh-closure%29)]ã€‚
- en: Pay especially close attention to our notation. We write \(\in\) rather than
    \(=\) or some other symbol, because \(O(f)\) describes a family of functions of
    which \(g\) is a member. We also write \(f\) rather than \(f(x)\) because we are
    comparing functionsâ€”<wbr>\(f\)â€”<wbr>rather than their values at particular pointsâ€”<wbr>\(f(x)\)â€”<wbr>which
    would be ordinary numbers! Most of the notation in most the books and Web sites
    suffers from one or both flaws. We know, however, that functions are values, and
    that functions can be anonymous. We have actually exploited both facts to be able
    to write
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ç‰¹åˆ«æ³¨æ„æˆ‘ä»¬çš„ç¬¦å·ã€‚æˆ‘ä»¬å†™ \(\in\) è€Œä¸æ˜¯ \(=\) æˆ–å…¶ä»–ç¬¦å·ï¼Œå› ä¸º \(O(f)\) æè¿°äº†ä¸€ä¸ªå‡½æ•°æ—ï¼Œå…¶ä¸­ \(g\) æ˜¯ä¸€ä¸ªæˆå‘˜ã€‚æˆ‘ä»¬ä¹Ÿä¸å†™
    \(f\) è€Œå†™ \(f(x)\)ï¼Œå› ä¸ºæˆ‘ä»¬æ¯”è¾ƒçš„æ˜¯å‡½æ•°â€”â€”\(f\)â€”â€”è€Œä¸æ˜¯å®ƒä»¬åœ¨ç‰¹å®šç‚¹çš„å€¼â€”â€”\(f(x)\)ï¼Œè¿™å°†æ˜¯æ™®é€šæ•°å­—ï¼å¤§å¤šæ•°ä¹¦ç±å’Œç½‘ç«™ä¸Šçš„å¤§å¤šæ•°ç¬¦å·éƒ½å­˜åœ¨ä¸€ä¸ªæˆ–ä¸¤ä¸ªç¼ºé™·ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬çŸ¥é“å‡½æ•°æ˜¯å€¼ï¼Œå‡½æ•°å¯ä»¥æ˜¯åŒ¿åçš„ã€‚æˆ‘ä»¬å®é™…ä¸Šåˆ©ç”¨äº†è¿™ä¸¤ä¸ªäº‹å®æ¥èƒ½å¤Ÿå†™å‡º
- en: \begin{equation*}[k \rightarrow 3k] \in O([k \rightarrow 4k+12])\end{equation*}
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}[k \rightarrow 3k] \in O([k \rightarrow 4k+12])\end{equation*}
- en: This is not the only notion of function comparison that we can have. For instance,
    given the definition of \(\leq\) above, we can define a natural relation \(<\).
    This then lets us ask, given a function \(f\), what are all the functions \(g\)
    such that \(g \leq f\) but not \(g < f\), i.e., those that are â€œequalâ€ to \(f\).Look
    out! We are using quotes because this is not the same as ordinary function equality,
    which is defined as the two functions giving the same answer on all inputs. Here,
    two â€œequalâ€ functions may not give the same answer on any inputs. This is the
    family of functions that are separated by at most a constant; when the functions
    indicate the order of growth of programs, â€œequalâ€ functions signify programs that
    grow at the same speed (up to constants). We use the notation \(\Theta(\cdot)\)
    to speak of this family of functions, so if \(g\) is equivalent to \(f\) by this
    notion, we can write \(g \in \Theta(f)\) (and it would then also be true that
    \(f \in \Theta(g)\)).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸æ˜¯æˆ‘ä»¬èƒ½æœ‰çš„å”¯ä¸€å‡½æ•°æ¯”è¾ƒçš„æ¦‚å¿µã€‚ä¾‹å¦‚ï¼Œç»™å®šä¸Šè¿°çš„ \(\leq\) å®šä¹‰ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªè‡ªç„¶çš„å…³ç³» `<`ã€‚è¿™æ ·ï¼Œæˆ‘ä»¬å°±èƒ½å¤Ÿè¯¢é—®ï¼Œç»™å®šä¸€ä¸ªå‡½æ•° \(f\)ï¼Œæ‰€æœ‰æ»¡è¶³
    \(g \leq f\) ä½†ä¸æ»¡è¶³ \(g < f\) çš„å‡½æ•° \(g\) æ˜¯ä»€ä¹ˆï¼Œå³é‚£äº›â€œç­‰äºâ€ \(f\) çš„å‡½æ•°ã€‚æ³¨æ„ï¼æˆ‘ä»¬ä½¿ç”¨å¼•å·ï¼Œå› ä¸ºè¿™ä¸æ™®é€šå‡½æ•°çš„ç­‰ä»·æ€§ä¸åŒï¼Œæ™®é€šå‡½æ•°çš„ç­‰ä»·æ€§å®šä¹‰ä¸ºåœ¨æ‰€æœ‰è¾“å…¥ä¸Šç»™å‡ºç›¸åŒçš„ç­”æ¡ˆã€‚åœ¨è¿™é‡Œï¼Œä¸¤ä¸ªâ€œç­‰ä»·â€çš„å‡½æ•°å¯èƒ½åœ¨ä»»ä½•è¾“å…¥ä¸Šéƒ½ä¸ç»™å‡ºç›¸åŒçš„ç­”æ¡ˆã€‚è¿™æ˜¯ç”±å¸¸æ•°åˆ†éš”çš„å‡½æ•°æ—ï¼›å½“å‡½æ•°è¡¨ç¤ºç¨‹åºçš„è¿è¡Œæ—¶é—´æ—¶ï¼Œâ€œç­‰ä»·â€çš„å‡½æ•°è¡¨ç¤ºä»¥ç›¸åŒé€Ÿåº¦å¢é•¿ï¼ˆåˆ°å¸¸æ•°ï¼‰çš„ç¨‹åºã€‚æˆ‘ä»¬ä½¿ç”¨ç¬¦å·
    \(\Theta(\cdot)\) æ¥è°ˆè®ºè¿™ä¸ªå‡½æ•°æ—ï¼Œæ‰€ä»¥å¦‚æœ \(g\) é€šè¿‡è¿™ä¸ªæ¦‚å¿µä¸ \(f\) ç­‰ä»·ï¼Œæˆ‘ä»¬å¯ä»¥å†™ \(g \in \Theta(f)\)ï¼ˆå¹¶ä¸”è¿™ä¹Ÿæ„å‘³ç€
    \(f \in \Theta(g)\)ï¼‰ã€‚
- en: Exercise
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Convince yourself that this notion of function equality is an equivalence relation,
    and hence worthy of the name â€œequalâ€. It needs to be (a) reflexive (i.e., every
    function is related to itself); (b) antisymmetric (if \(f \leq g\) and \(g \leq
    f\) then \(f\) and \(g\) are equal); and (c) transitive (\(f \leq g\) and \(g
    \leq h\) implies \(f \leq h\)).
  id: totrans-130
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¯´æœè‡ªå·±è¿™ä¸ªå‡½æ•°ç­‰ä»·çš„æ¦‚å¿µæ˜¯ä¸€ä¸ªç­‰ä»·å…³ç³»ï¼Œå› æ­¤å€¼å¾—ç§°ä¸ºâ€œç­‰ä»·â€ã€‚å®ƒéœ€è¦æ˜¯ï¼ˆaï¼‰è‡ªåçš„ï¼ˆå³ï¼Œæ¯ä¸ªå‡½æ•°éƒ½ä¸è‡ªå·±ç›¸å…³ï¼‰ï¼›ï¼ˆbï¼‰åå¯¹ç§°çš„ï¼ˆå¦‚æœ \(f \leq
    g\) ä¸” \(g \leq f\)ï¼Œåˆ™ \(f\) å’Œ \(g\) æ˜¯ç›¸ç­‰çš„ï¼‰ï¼›ä»¥åŠï¼ˆcï¼‰ä¼ é€’çš„ï¼ˆ\(f \leq g\) å’Œ \(g \leq h\)
    æ„å‘³ç€ \(f \leq h\)ï¼‰ã€‚
- en: 14.9Â Combining Big-Oh Without Woe[ğŸ”—](#(part._big-oh-closure) "Link to here")
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.9Â åœ¨ä¸çƒ¦æ¼çš„æƒ…å†µä¸‹ç»„åˆå¤§O[ğŸ”—](#(part._big-oh-closure) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Now that weâ€™ve introduced this notation, we should inquire about its closure
    properties: namely, how do these families of functions combine? To nudge your
    intuitions, assume that in all cases weâ€™re discussing the running time of functions.
    Weâ€™ll consider three cases:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»å¼•å…¥äº†è¿™ä¸ªç¬¦å·ï¼Œæˆ‘ä»¬åº”è¯¥è¯¢é—®å®ƒçš„é—­åŒ…å±æ€§ï¼šå³è¿™äº›å‡½æ•°æ—æ˜¯å¦‚ä½•ç»„åˆçš„ï¼Ÿä¸ºäº†å¼•å¯¼ä½ çš„ç›´è§‰ï¼Œå‡è®¾åœ¨æ‰€æœ‰æƒ…å†µä¸‹æˆ‘ä»¬éƒ½åœ¨è®¨è®ºå‡½æ•°çš„è¿è¡Œæ—¶é—´ã€‚æˆ‘ä»¬å°†è€ƒè™‘ä¸‰ç§æƒ…å†µï¼š
- en: 'Suppose we have a function `f` (whose running time is) in \(O(F)\). Letâ€™s say
    we run it \(p\) times, for some given constant. The running time of the resulting
    code is then \(p \times O(F)\). However, observe that this is really no different
    from \(O(F)\): we can simply use a bigger constant for \(c\) in the definition
    of \(O(\cdot)\)â€”<wbr>in particular, we can just use \(pc\). Conversely, then,
    \(O(pF)\) is equivalent to \(O(F)\). This is the heart of the intution that â€œmultiplicative
    constants donâ€™t matterâ€.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªå‡½æ•° `f`ï¼ˆå…¶è¿è¡Œæ—¶é—´æ˜¯ï¼‰åœ¨ \(O(F)\) å†…ã€‚å‡è®¾æˆ‘ä»¬è¿è¡Œå®ƒ \(p\) æ¬¡ï¼Œå¯¹äºæŸä¸ªç»™å®šçš„å¸¸æ•°ã€‚é‚£ä¹ˆï¼Œäº§ç”Ÿçš„ä»£ç çš„è¿è¡Œæ—¶é—´å°±æ˜¯
    \(p \times O(F)\)ã€‚ç„¶è€Œï¼Œè¯·æ³¨æ„ï¼Œè¿™å®é™…ä¸Šä¸ \(O(F)\) æ²¡æœ‰åŒºåˆ«ï¼šæˆ‘ä»¬åªéœ€åœ¨ \(O(\cdot)\) çš„å®šä¹‰ä¸­ä½¿ç”¨æ›´å¤§çš„å¸¸æ•° \(c\)â€”â€”ç‰¹åˆ«æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨
    \(pc\)ã€‚åè¿‡æ¥ï¼Œé‚£ä¹ˆï¼Œ\(O(pF)\) ç­‰ä»·äº \(O(F)\)ã€‚è¿™æ­£æ˜¯â€œä¹˜æ³•å¸¸æ•°æ— å…³ç´§è¦â€è¿™ä¸€ç›´è§‰çš„æ ¸å¿ƒã€‚
- en: Suppose we have two functions, `f` in \(O(F)\) and `g` in \(O(G)\). If we run
    `f` followed by `g`, we would expect the running time of the combination to be
    the sum of their individual running times, i.e., \(O(F) + O(G)\). You should convince
    yourself that this is simply \(O(max(F, G))\).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬æœ‰ä¸¤ä¸ªå‡½æ•°ï¼Œ`f` åœ¨ \(O(F)\) ä¸­ï¼Œ`g` åœ¨ \(O(G)\) ä¸­ã€‚å¦‚æœæˆ‘ä»¬å…ˆè¿è¡Œ `f` å†è¿è¡Œ `g`ï¼Œæˆ‘ä»¬é¢„è®¡ç»„åˆçš„è¿è¡Œæ—¶é—´å°†æ˜¯å®ƒä»¬å„è‡ªè¿è¡Œæ—¶é—´çš„æ€»å’Œï¼Œå³
    \(O(F) + O(G)\)ã€‚ä½ åº”è¯¥è®©è‡ªå·±ç›¸ä¿¡è¿™ä»…ä»…æ˜¯ \(O(max(F, G))\)ã€‚
- en: Suppose we have two functions, `f` in \(O(F)\) and `g` in \(O(G)\). If `f` invokes
    `g` in each of its steps, we would expect the running time of the combination
    to be the product of their individual running times, i.e., \(O(F) \times O(G)\).
    You should convince yourself that this is simply \(O(F \times G)\).
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬æœ‰ä¸¤ä¸ªå‡½æ•°ï¼Œ`f` åœ¨ \(O(F)\) ä¸­ï¼Œ`g` åœ¨ \(O(G)\) ä¸­ã€‚å¦‚æœ `f` åœ¨æ¯ä¸€æ­¥éƒ½è°ƒç”¨ `g`ï¼Œæˆ‘ä»¬é¢„è®¡ç»„åˆçš„è¿è¡Œæ—¶é—´å°†æ˜¯å®ƒä»¬å„è‡ªè¿è¡Œæ—¶é—´çš„ä¹˜ç§¯ï¼Œå³
    \(O(F) \times O(G)\)ã€‚ä½ åº”è¯¥è®©è‡ªå·±ç›¸ä¿¡è¿™ä»…ä»…æ˜¯ \(O(F \times G)\)ã€‚
- en: 'These three operationsâ€”<wbr>addition, multiplication by a constant, and multiplication
    by a functionâ€”<wbr>cover just about all the cases.To ensure that the table fits
    in a reasonable width, we will abuse notation. For instance, we can use this to
    reinterpret the [tabular operations](#%28elem._length-cost-table%29) above (assuming
    everything is a function of \(k\)):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸‰ä¸ªæ“ä½œâ€”â€”<wbr>åŠ æ³•ã€å¸¸æ•°ä¹˜æ³•å’Œå‡½æ•°ä¹˜æ³•â€”â€”<wbr>æ¶µç›–äº†å‡ ä¹æ‰€æœ‰çš„æƒ…å†µã€‚ä¸ºäº†ç¡®ä¿è¡¨æ ¼é€‚åˆåˆç†çš„å®½åº¦ï¼Œæˆ‘ä»¬å°†æ»¥ç”¨ç¬¦å·ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨è¿™ä¸ªæ¥é‡æ–°è§£é‡Šä¸Šé¢çš„
    [è¡¨æ ¼æ“ä½œ](#%28elem._length-cost-table%29)ï¼ˆå‡è®¾ä¸€åˆ‡éƒ½æ˜¯ \(k\) çš„å‡½æ•°ï¼‰ï¼š
- en: '| &#124;Q&#124; |  | #Q |  | TotQ |  | &#124;A&#124; |  | #A |  | TotA |  |
    Total |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| &#124;Q&#124; |  | #Q |  | TotQ |  | &#124;A&#124; |  | #A |  | TotA |  |
    Total |'
- en: '| \(O(1)\) |  | \(O(k)\) |  | \(O(k)\) |  | \(O(1)\) |  | \(O(1)\) |  | \(O(1)\)
    |  | \(O(k)\) |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| \(O(1)\) |  | \(O(k)\) |  | \(O(k)\) |  | \(O(1)\) |  | \(O(1)\) |  | \(O(1)\)
    |  | \(O(k)\) |'
- en: '| \(O(1)\) |  | \(O(k)\) |  | \(O(k)\) |  | \(O(1)\) |  | \(O(k)\) |  | \(O(k)\)
    |  | \(O(k)\) |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| \(O(1)\) |  | \(O(k)\) |  | \(O(k)\) |  | \(O(1)\) |  | \(O(k)\) |  | \(O(k)\)
    |  | \(O(k)\) |'
- en: 'Because multiplication by constants doesnâ€™t matter, we can replace the \(3\)
    with \(1\). Because addition of a constant doesnâ€™t matter (run the addition rule
    in reverse), \(k+1\) can become \(k\). Adding this gives us \(O(k) + O(k) = 2
    \times O(k) \in O(k)\). This justifies claiming that running `len` on a \(k\)-element
    list takes time in \(O([k \rightarrow k])\), which is a much simpler way of describing
    its bound than \(O([k \rightarrow 11k + 4])\). In particular, it provides us with
    the essential information and nothing else: as the input (list) grows, the running
    time grows proportional to it, i.e., if we add one more element to the input,
    we should expect to add a constant more of time to the running time.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºå¸¸æ•°ä¹˜æ³•å¹¶ä¸é‡è¦ï¼Œæˆ‘ä»¬å¯ä»¥å°† \(3\) æ›¿æ¢ä¸º \(1\)ã€‚ç”±äºå¸¸æ•°åŠ æ³•å¹¶ä¸é‡è¦ï¼ˆåå‘è¿è¡ŒåŠ æ³•è§„åˆ™ï¼‰ï¼Œ\(k+1\) å¯ä»¥å˜æˆ \(k\)ã€‚åŠ ä¸Šè¿™äº›ï¼Œæˆ‘ä»¬å¾—åˆ°
    \(O(k) + O(k) = 2 \times O(k) \in O(k)\)ã€‚è¿™è¯æ˜äº†åœ¨ \(k\) å…ƒç´ åˆ—è¡¨ä¸Šè¿è¡Œ `len` çš„æ—¶é—´æ˜¯ \(O([k
    \rightarrow k])\)ï¼Œè¿™æ¯” \(O([k \rightarrow 11k + 4])\) æè¿°å…¶ç•Œé™çš„æ–¹å¼ç®€å•å¾—å¤šã€‚ç‰¹åˆ«æ˜¯ï¼Œå®ƒä¸ºæˆ‘ä»¬æä¾›äº†å¿…è¦çš„ä¿¡æ¯ï¼Œæ²¡æœ‰å…¶ä»–ä¿¡æ¯ï¼šéšç€è¾“å…¥ï¼ˆåˆ—è¡¨ï¼‰çš„å¢é•¿ï¼Œè¿è¡Œæ—¶é—´æˆæ¯”ä¾‹å¢é•¿ï¼Œå³å¦‚æœæˆ‘ä»¬å‘è¾“å…¥æ·»åŠ ä¸€ä¸ªå…ƒç´ ï¼Œæˆ‘ä»¬åº”è¯¥æœŸæœ›å‘è¿è¡Œæ—¶é—´æ·»åŠ ä¸€ä¸ªå¸¸æ•°çš„æ—¶é—´ã€‚
- en: 14.10Â Solving Recurrences[ğŸ”—](#(part._solving-recurrences) "Link to here")
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.10Â è§£å†³é€’å½’[ğŸ”—](#(part._solving-recurrences) "é“¾æ¥åˆ°æ­¤å¤„")
- en: There is a great deal of literature on solving recurrence equations. In this
    section we wonâ€™t go into general techniques, nor will we even discuss very many
    different recurrences. Rather, weâ€™ll focus on just a handful that should be in
    the repertoire of every computer scientist. Youâ€™ll see these over and over, so
    you should instinctively recognize their recurrence pattern and know what complexity
    they describe (or know how to quickly derive it).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: å…³äºè§£å†³é€’å½’æ–¹ç¨‹çš„æ–‡çŒ®éå¸¸ä¸°å¯Œã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬ä¸ä¼šæ·±å…¥æ¢è®¨ä¸€èˆ¬æŠ€æœ¯ï¼Œä¹Ÿä¸ä¼šè®¨è®ºå¾ˆå¤šä¸åŒçš„é€’å½’æ–¹ç¨‹ã€‚ç›¸åï¼Œæˆ‘ä»¬å°†ä¸“æ³¨äºä»…æœ‰çš„å‡ ç±»åº”è¯¥å±äºæ¯ä½è®¡ç®—æœºç§‘å­¦å®¶çš„æŠ€èƒ½åº“ä¸­çš„å†…å®¹ã€‚ä½ ä¼šåå¤çœ‹åˆ°è¿™äº›å†…å®¹ï¼Œå› æ­¤ä½ åº”è¯¥æœ¬èƒ½åœ°è¯†åˆ«å®ƒä»¬çš„é€’å½’æ¨¡å¼ï¼Œå¹¶çŸ¥é“å®ƒä»¬æè¿°çš„å¤æ‚åº¦ï¼ˆæˆ–è€…çŸ¥é“å¦‚ä½•å¿«é€Ÿæ¨å¯¼å®ƒï¼‰ã€‚
- en: 'Earlier we saw a recurrence that had two cases: one for the empty input and
    one for all others. In general, we should expect to find one case for each non-recursive
    call and one for each recursive one, i.e., roughly one per `cases` clause. In
    what follows, we will ignore the base cases so long as the size of the input is
    constant (such as zero or one), because in such cases the amount of work done
    will also be a constant, which we can generally ignore [[Comparing Functions](#%28part._big-oh-def%29)].'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹‹å‰æˆ‘ä»¬çœ‹åˆ°äº†ä¸€ä¸ªæœ‰ä¸¤ä¸ªæƒ…å†µçš„é€’å½’ï¼šä¸€ä¸ªç”¨äºç©ºè¾“å…¥ï¼Œå¦ä¸€ä¸ªç”¨äºæ‰€æœ‰å…¶ä»–æƒ…å†µã€‚ä¸€èˆ¬æ¥è¯´ï¼Œæˆ‘ä»¬åº”è¯¥æœŸæœ›ä¸ºæ¯ä¸ªéé€’å½’è°ƒç”¨æ‰¾åˆ°ä¸€ä¸ªæƒ…å†µï¼Œä¸ºæ¯ä¸ªé€’å½’è°ƒç”¨æ‰¾åˆ°ä¸€ä¸ªæƒ…å†µï¼Œå³å¤§çº¦æ¯ä¸ª
    `cases` å­å¥ä¸€ä¸ªã€‚åœ¨ä»¥ä¸‹å†…å®¹ä¸­ï¼Œåªè¦è¾“å…¥çš„å¤§å°æ˜¯å¸¸æ•°ï¼ˆå¦‚é›¶æˆ–ä¸€ï¼‰ï¼Œæˆ‘ä»¬å°±å°†å¿½ç•¥åŸºæœ¬æƒ…å†µï¼Œå› ä¸ºåœ¨è¿™äº›æƒ…å†µä¸‹ï¼Œæ‰€åšçš„å·¥ä½œé‡ä¹Ÿå°†æ˜¯å¸¸æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ä¸€èˆ¬åœ°å¿½ç•¥
    [[æ¯”è¾ƒå‡½æ•°](#%28part._big-oh-def%29)]ã€‚
- en: '| \(T(k)\) | = | \(T(k-1) + c\) |'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_TB
  zh: '| \(T(k)\) | = | \(T(k-1) + c\) |'
- en: '|  | = | \(T(k-2) + c + c\) |'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(k-2) + c + c\) |'
- en: '|  | = | \(T(k-3) + c + c + c\) |'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(k-3) + c + c + c\) |'
- en: '|  | = | ... |'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | ... |'
- en: '|  | = | \(T(0) + c \times k\) |'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(0) + c \times k\) |'
- en: '|  | = | \(c_0 + c \times k\) |'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(c_0 + c \times k\) |'
- en: Thus \(T \in O([k \rightarrow k])\). Intuitively, we do a constant amount of
    work (\(c\)) each time we throw away one element (\(k-1\)), so we do a linear
    amount of work overall.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å› æ­¤ \(T \in O([k \rightarrow k])\)ã€‚ç›´è§‚ä¸Šï¼Œæ¯æ¬¡æˆ‘ä»¬ä¸¢å¼ƒä¸€ä¸ªå…ƒç´ ï¼ˆ\(k-1\)ï¼‰æ—¶ï¼Œæˆ‘ä»¬éƒ½ä¼šåšä¸€å®šé‡çš„å·¥ä½œï¼ˆ\(c\)ï¼‰ï¼Œå› æ­¤æ€»ä½“ä¸Šæˆ‘ä»¬åšäº†çº¿æ€§é‡çš„å·¥ä½œã€‚
- en: '| \(T(k)\) | = | \(T(k-1) + k\) |'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_TB
  zh: '| \(T(k)\) | = | \(T(k-1) + k\) |'
- en: '|  | = | \(T(k-2) + (k-1) + k\) |'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(k-2) + (k-1) + k\) |'
- en: '|  | = | \(T(k-3) + (k-2) + (k-1) + k\) |'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(k-3) + (k-2) + (k-1) + k\) |'
- en: '|  | = | ... |'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | ... |'
- en: '|  | = | \(T(0) + (k-(k-1)) + (k-(k-2)) + \cdots + (k-2) + (k-1) + k\) |'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(0) + (k-(k-1)) + (k-(k-2)) + \cdots + (k-2) + (k-1) + k\) |'
- en: '|  | = | \(c_0 + 1 + 2 + \cdots + (k-2) + (k-1) + k\) |'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(c_0 + 1 + 2 + \cdots + (k-2) + (k-1) + k\) |'
- en: '|  | = | \(c_0 + {\frac{k \cdot (k+1)}{2}}\) |'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(c_0 + {\frac{k \cdot (k+1)}{2}}\) |'
- en: Thus \(T \in O([k \rightarrow k^2])\). This follows from the solution to the
    sum of the first \(k\) numbers. We call algorithms that have this running time
    quadratic algorithms.One of the hardest algorithmic problems in programming software
    is to avoid making programs [accidentally quadratic](https://accidentallyquadratic.tumblr.com/).
    As you can see, even serious, professional software falls into this trap, and
    it affects real sytems, even bringing them down.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å› æ­¤ \(T \in O([k \rightarrow k^2])\)ã€‚è¿™æ¥è‡ªäºå‰ \(k\) ä¸ªæ•°çš„å’Œçš„è§£ã€‚æˆ‘ä»¬ç§°å…·æœ‰è¿™ç§è¿è¡Œæ—¶é—´çš„ç®—æ³•ä¸ºäºŒæ¬¡ç®—æ³•ã€‚åœ¨ç¼–ç¨‹è½¯ä»¶ä¸­ï¼Œé¿å…åˆ¶ä½œå‡º[æ„å¤–äºŒæ¬¡çš„](https://accidentallyquadratic.tumblr.com/)ç®—æ³•æ˜¯å…¶ä¸­ä¸€ä¸ªæœ€å›°éš¾çš„ç®—æ³•é—®é¢˜ã€‚æ­£å¦‚ä½ æ‰€è§ï¼Œå³ä½¿æ˜¯ä¸¥è‚ƒçš„ä¸“ä¸šè½¯ä»¶ä¹Ÿä¼šé™·å…¥è¿™ä¸ªé™·é˜±ï¼Œå®ƒä¼šå½±å“çœŸå®ç³»ç»Ÿï¼Œç”šè‡³å¯¼è‡´å®ƒä»¬å´©æºƒã€‚
- en: 'We can also view this recurrence geometrically. Imagine each x below refers
    to a unit of work, and we start with \(k\) of them. Then the first row has \(k\)
    units of work:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¹Ÿå¯ä»¥ä»å‡ ä½•çš„è§’åº¦çœ‹å¾…è¿™ä¸ªé€’å½’ã€‚æƒ³è±¡ä¸‹é¢æ¯ä¸ª x éƒ½ä»£è¡¨ä¸€ä¸ªå·¥ä½œé‡å•ä½ï¼Œæˆ‘ä»¬å¼€å§‹æ—¶æœ‰ \(k\) ä¸ªå®ƒä»¬ã€‚ç„¶åç¬¬ä¸€è¡Œæœ‰ \(k\) ä¸ªå·¥ä½œé‡å•ä½ï¼š
- en: '| xxxxxxxx |'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxxxxxxx |'
- en: 'followed by the recurrence on \(k-1\) of them:'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ç„¶åæ˜¯å¯¹ \(k-1\) ä¸ªå…ƒç´ çš„é€’å½’ï¼š
- en: '| xxxxxxx |'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxxxxxx |'
- en: 'which is followed by another recurrence on one smaller, and so on, until we
    fill end up with:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: è¿™éšååˆå¼•å‡ºå¯¹è¾ƒå°å…ƒç´ çš„ä¸€ä¸ªé€’å½’ï¼Œç­‰ç­‰ï¼Œç›´åˆ°æˆ‘ä»¬æœ€ç»ˆå¾—åˆ°ï¼š
- en: '| xxxxxxxx |'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxxxxxxx |'
- en: '| xxxxxxx |'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxxxxxx |'
- en: '| xxxxxx |'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxxxxx |'
- en: '| xxxxx |'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxxxx |'
- en: '| xxxx |'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxxx |'
- en: '| xxx |'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxx |'
- en: '| xx |'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xx |'
- en: '| x |'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| x |'
- en: 'The total work is then essentially the area of this triangle, whose base and
    height are both \(k\): or, if you prefer, half of this \(k \times k\) square:'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆæ€»å·¥ä½œé‡åŸºæœ¬ä¸Šæ˜¯è¿™ä¸ªä¸‰è§’å½¢çš„é¢ç§¯ï¼Œå…¶åº•å’Œé«˜éƒ½æ˜¯ \(k\)ï¼šæˆ–è€…ï¼Œå¦‚æœä½ æ›´å–œæ¬¢ï¼Œæ˜¯ \(k \times k\) æ­£æ–¹å½¢çš„ä¸€åŠï¼š
- en: '| xxxxxxxx |'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxxxxxxx |'
- en: '| xxxxxxx. |'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxxxxxx. |'
- en: '| xxxxxx.. |'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxxxxx.. |'
- en: '| xxxxx... |'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxxxx... |'
- en: '| xxxx.... |'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxxx.... |'
- en: '| xxx..... |'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxx..... |'
- en: '| xx...... |'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xx...... |'
- en: '| x....... |'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| x....... |'
- en: Similar geometric arguments can be made for all these recurrences.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å¯¹äºæ‰€æœ‰è¿™äº›é€’å½’ï¼Œéƒ½å¯ä»¥è¿›è¡Œç±»ä¼¼çš„å‡ ä½•è®ºè¯ã€‚
- en: '| \(T(k)\) | = | \(T(k/2) + c\) |'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_TB
  zh: '| \(T(k)\) | = | \(T(k/2) + c\) |'
- en: '|  | = | \(T(k/4) + c + c\) |'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(k/4) + c + c\) |'
- en: '|  | = | \(T(k/8) + c + c + c\) |'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(k/8) + c + c + c\) |'
- en: '|  | = | ... |'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | ... |'
- en: '|  | = | \(T(k/2^{\log_2 k}) + c \cdot \log_2 k\) |'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(k/2^{\log_2 k}) + c \cdot \log_2 k\) |'
- en: '|  | = | \(c_1 + c \cdot \log_2 k\) |'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(c_1 + c \cdot \log_2 k\) |'
- en: Thus \(T \in O([k \rightarrow \log k])\). Intuitively, weâ€™re able to do only
    constant work (\(c\)) at each level, then throw away half the input. In a logarithmic
    number of steps we will have exhausted the input, having done only constant work
    each time. Thus the overall complexity is logarithmic.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å› æ­¤ \(T \in O([k \rightarrow \log k])\)ã€‚ç›´è§‚ä¸Šï¼Œæˆ‘ä»¬èƒ½å¤Ÿåœ¨æ¯ä¸ªçº§åˆ«ä¸Šåªåšå¸¸æ•°å·¥ä½œé‡ï¼ˆ\(c\)ï¼‰ï¼Œç„¶åä¸¢å¼ƒä¸€åŠçš„è¾“å…¥ã€‚åœ¨ä»¥å¯¹æ•°æ•°é‡çº§çš„æ­¥éª¤ä¸­ï¼Œæˆ‘ä»¬å°†è€—å°½è¾“å…¥ï¼Œæ¯æ¬¡åªåšå¸¸æ•°å·¥ä½œé‡ã€‚å› æ­¤ï¼Œæ•´ä½“å¤æ‚åº¦æ˜¯å¯¹æ•°çš„ã€‚
- en: '| \(T(k)\) | = | \(T(k/2) + k\) |'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_TB
  zh: '| \(T(k)\) | = | \(T(k/2) + k\) |'
- en: '|  | = | \(T(k/4) + k/2 + k\) |'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(k/4) + k/2 + k\) |'
- en: '|  | = | ... |'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | ... |'
- en: '|  | = | \(T(1) + k/2^{\log_2 k} + \cdots + k/4 + k/2 + k\) |'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(1) + k/2^{\log_2 k} + \cdots + k/4 + k/2 + k\) |'
- en: '|  | = | \(c_1 + k(1/2^{\log_2 k} + \cdots + 1/4 + 1/2 + 1)\) |'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(c_1 + k(1/2^{\log_2 k} + \cdots + 1/4 + 1/2 + 1)\) |'
- en: '|  | = | \(c_1 + 2k\) |'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(c_1 + 2k\) |'
- en: Thus \(T \in O([k \rightarrow k])\). Intuitively, the first time your process
    looks at all the elements, the second time it looks at half of them, the third
    time a quarter, and so on. This kind of successive halving is equivalent to scanning
    all the elements in the input a second time. Hence this results in a linear process.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å› æ­¤ \(T \in O([k \rightarrow k])\)ã€‚ç›´è§‚ä¸Šï¼Œç¬¬ä¸€æ¬¡ä½ çš„è¿‡ç¨‹æŸ¥çœ‹æ‰€æœ‰å…ƒç´ ï¼Œç¬¬äºŒæ¬¡æŸ¥çœ‹å…¶ä¸­çš„ä¸€åŠï¼Œç¬¬ä¸‰æ¬¡æŸ¥çœ‹å››åˆ†ä¹‹ä¸€ï¼Œä»¥æ­¤ç±»æ¨ã€‚è¿™ç§è¿ç»­å‡åŠç›¸å½“äºå†æ¬¡æ‰«æè¾“å…¥ä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚å› æ­¤ï¼Œè¿™å¯¼è‡´äº†ä¸€ä¸ªçº¿æ€§è¿‡ç¨‹ã€‚
- en: '| \(T(k)\) | = | \(2T(k/2) + k\) |'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_TB
  zh: '| \(T(k)\) | = | \(2T(k/2) + k\) |'
- en: '|  | = | \(2(2T(k/4) + k/2) + k\) |'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(2(2T(k/4) + k/2) + k\) |'
- en: '|  | = | \(4T(k/4) + k + k\) |'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(4T(k/4) + k + k\) |'
- en: '|  | = | \(4(2T(k/8) + k/4) + k + k\) |'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(4(2T(k/8) + k/4) + k + k\) |'
- en: '|  | = | \(8T(k/8) + k + k + k\) |'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(8T(k/8) + k + k + k\) |'
- en: '|  | = | ... |'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | ... |'
- en: '|  | = | \(2^{\log_2 k} T(1) + k \cdot \log_2 k\) |'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(2^{\log_2 k} T(1) + k \cdot \log_2 k\) |'
- en: '|  | = | \(k \cdot c_1 + k \cdot \log_2 k\) |'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(k \cdot c_1 + k \cdot \log_2 k\) |'
- en: Thus \(T \in O([k \rightarrow k \cdot \log k])\). Intuitively, each time weâ€™re
    processing all the elements in each recursive call (the \(k\)) as well as decomposing
    into two half sub-problems. This decomposition gives us a recursion tree of logarithmic
    height, at each of which levels weâ€™re doing linear work.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å› æ­¤ \(T \in O([k \rightarrow k \cdot \log k])\)ã€‚ç›´è§‚åœ°è¯´ï¼Œæ¯æ¬¡æˆ‘ä»¬éƒ½åœ¨å¤„ç†æ¯ä¸ªé€’å½’è°ƒç”¨ä¸­çš„æ‰€æœ‰å…ƒç´ ï¼ˆ\(k\)ï¼‰ï¼ŒåŒæ—¶å°†å…¶åˆ†è§£ä¸ºä¸¤ä¸ªå­é—®é¢˜ã€‚è¿™ç§åˆ†è§£ç»™æˆ‘ä»¬ä¸€ä¸ªå¯¹æ•°é«˜åº¦çš„é€’å½’æ ‘ï¼Œåœ¨æ¯ä¸€å±‚æˆ‘ä»¬éƒ½åœ¨åšçº¿æ€§å·¥ä½œã€‚
- en: '| \(T(k)\) | = | \(2T(k-1) + c\) |'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_TB
  zh: '| \(T(k)\) | = | \(2T(k-1) + c\) |'
- en: '|  | = | \(2T(k-1) + (2-1)c\) |'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(2T(k-1) + (2-1)c\) |'
- en: '|  | = | \(2(2T(k-2) + c) + (2-1)c\) |'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(2(2T(k-2) + c) + (2-1)c\) |'
- en: '|  | = | \(4T(k-2) + 3c\) |'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(4T(k-2) + 3c\) |'
- en: '|  | = | \(4T(k-2) + (4-1)c\) |'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(4T(k-2) + (4-1)c\) |'
- en: '|  | = | \(4(2T(k-3) + c) + (4-1)c\) |'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(4(2T(k-3) + c) + (4-1)c\) |'
- en: '|  | = | \(8T(k-3) + 7c\) |'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(8T(k-3) + 7c\) |'
- en: '|  | = | \(8T(k-3) + (8-1)c\) |'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(8T(k-3) + (8-1)c\) |'
- en: '|  | = | ... |'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | ... |'
- en: '|  | = | \(2^k T(0) + (2^k-1)c\) |'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(2^k T(0) + (2^k-1)c\) |'
- en: Thus \(T \in O([k \rightarrow 2^k])\). Disposing of each element requires doing
    a constant amount of work for it and then doubling the work done on the rest.
    This successive doubling leads to the exponential.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å› æ­¤ \(T \in O([k \rightarrow 2^k])\)ã€‚å¤„ç†æ¯ä¸ªå…ƒç´ éœ€è¦ä¸ºå…¶åšä¸€å®šé‡çš„å·¥ä½œï¼Œç„¶åå°†å…¶ä½™å·¥ä½œåŠ å€ã€‚è¿™ç§è¿ç»­åŠ å€å¯¼è‡´æŒ‡æ•°å¢é•¿ã€‚
- en: Exercise
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using induction, prove each of the above derivations.
  id: totrans-218
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨å½’çº³æ³•è¯æ˜ä¸Šè¿°æ¨å¯¼ã€‚
- en: 14.1Â A Little (True) Story[ğŸ”—](#(part._.A_.Little__.True__.Story) "Link to here")
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1 ä¸€ç‚¹ï¼ˆçœŸå®ï¼‰æ•…äº‹[ğŸ”—](#(part._.A_.Little__.True__.Story) "é“¾æ¥åˆ°æ­¤å¤„")
- en: My student Debbie recently wrote tools to analyze data for a startup. The company
    collects information about product scans made on mobile phones, and Debbieâ€™s analytic
    tools classified these by product, by region, by time, and so on. As a good programmer,
    Debbie first wrote synthetic test cases, then developed her programs and tested
    them. She then obtained some actual test data from the company, broke them down
    into small chunks, computed the expected answers by hand, and tested her programs
    again against these real (but small) data sets. At the end of this she was ready
    to declare the programs ready.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘çš„å­¦ç”Ÿé»›æ¯”æœ€è¿‘ä¸ºä¸€å®¶åˆåˆ›å…¬å¸ç¼–å†™äº†åˆ†ææ•°æ®çš„å·¥å…·ã€‚è¯¥å…¬å¸æ”¶é›†æœ‰å…³åœ¨æ‰‹æœºä¸Šè¿›è¡Œçš„å•†å“æ‰«æçš„ä¿¡æ¯ï¼Œé»›æ¯”çš„åˆ†æå·¥å…·å°†è¿™äº›ä¿¡æ¯æŒ‰äº§å“ã€åœ°åŒºã€æ—¶é—´ç­‰è¿›è¡Œåˆ†ç±»ã€‚ä½œä¸ºä¸€åä¼˜ç§€çš„ç¨‹åºå‘˜ï¼Œé»›æ¯”é¦–å…ˆç¼–å†™äº†åˆæˆæµ‹è¯•ç”¨ä¾‹ï¼Œç„¶åå¼€å‘äº†å¥¹çš„ç¨‹åºå¹¶è¿›è¡Œäº†æµ‹è¯•ã€‚ç„¶åï¼Œå¥¹ä»å…¬å¸è·å¾—äº†å®é™…æµ‹è¯•æ•°æ®ï¼Œå°†å®ƒä»¬åˆ†è§£æˆå°å—ï¼Œæ‰‹åŠ¨è®¡ç®—å‡ºé¢„æœŸç­”æ¡ˆï¼Œå¹¶å†æ¬¡ç”¨è¿™äº›çœŸå®ï¼ˆä½†è§„æ¨¡è¾ƒå°ï¼‰çš„æ•°æ®é›†æµ‹è¯•å¥¹çš„ç¨‹åºã€‚åœ¨å®Œæˆè¿™äº›å·¥ä½œåï¼Œå¥¹å®£å¸ƒç¨‹åºå‡†å¤‡å°±ç»ªã€‚
- en: 'At this point, however, she had only tested them for functional correctness.
    There was still a question of how quickly her analytical tools would produce answers.
    This presented two problems:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œæ­¤æ—¶å¥¹åªæµ‹è¯•äº†å®ƒä»¬çš„åŠŸèƒ½æ­£ç¡®æ€§ã€‚ä»ç„¶æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå³å¥¹çš„åˆ†æå·¥å…·äº§ç”Ÿç­”æ¡ˆçš„é€Ÿåº¦æœ‰å¤šå¿«ã€‚è¿™æå‡ºäº†ä¸¤ä¸ªé—®é¢˜ï¼š
- en: The company was rightly reluctant to share the entire dataset with outsiders,
    and in turn we didnâ€™t want to be responsible for carefully guarding all their
    data.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å…¬å¸æœ‰ç†ç”±ä¸æ„¿æ„ä¸å¤–ç•Œåˆ†äº«æ•´ä¸ªæ•°æ®é›†ï¼Œç›¸åº”åœ°ï¼Œæˆ‘ä»¬ä¹Ÿä¸æƒ³è´Ÿè´£ä»”ç»†ä¿æŠ¤ä»–ä»¬çš„æ‰€æœ‰æ•°æ®ã€‚
- en: Even if we did get a sample of their data, as more users used their product,
    the amount of data they had was sure to grow.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å³ä½¿æˆ‘ä»¬å·²ç»å¾—åˆ°äº†ä»–ä»¬æ•°æ®çš„æ ·æœ¬ï¼Œéšç€æ›´å¤šç”¨æˆ·ä½¿ç”¨ä»–ä»¬çš„äº§å“ï¼Œä»–ä»¬æ‹¥æœ‰çš„æ•°æ®é‡è‚¯å®šä¼šå¢é•¿ã€‚
- en: We therefore got only a sampling of their full data, and from this had to make
    some prediction on how long it would take to run the analytics on subsets (e.g.,
    those corresponding to just one region) or all of their data set, both today and
    as it grew over time.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬åªèƒ½è·å–ä»–ä»¬å…¨éƒ¨æ•°æ®çš„ä¸€éƒ¨åˆ†ï¼Œå¹¶æ®æ­¤é¢„æµ‹åˆ†æå­é›†ï¼ˆä¾‹å¦‚ï¼Œä»…å¯¹åº”ä¸€ä¸ªåŒºåŸŸçš„æ•°æ®ï¼‰æˆ–æ•´ä¸ªæ•°æ®é›†æ‰€éœ€çš„æ—¶é—´ï¼Œæ— è®ºæ˜¯ç°åœ¨è¿˜æ˜¯éšç€æ—¶é—´çš„æ¨ç§»ã€‚
- en: Debbie was given 100,000 data points. She broke them down into input sets of
    10, 100, 1,000, 10,000, and 100,000 data points, ran her tools on each input size,
    and plotted the result.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: é»›æ¯”å¾—åˆ°äº†10ä¸‡ä¸ªæ•°æ®ç‚¹ã€‚å¥¹å°†è¿™äº›æ•°æ®ç‚¹åˆ†è§£æˆ10ã€100ã€1,000ã€10,000å’Œ100,000ä¸ªæ•°æ®ç‚¹çš„è¾“å…¥é›†ï¼Œå¯¹æ¯ä¸ªè¾“å…¥å¤§å°è¿è¡Œå¥¹çš„å·¥å…·ï¼Œå¹¶ç»˜åˆ¶äº†ç»“æœã€‚
- en: From this graph we have a good bet at guessing how long the tool would take
    on a dataset of 50,000\. Itâ€™s much harder, however, to be sure how long it would
    take on datasets of size 1.5 million or 3 million or 10 million.These processes
    are respectively called interpolation and extrapolation. Weâ€™ve already explained
    why we couldnâ€™t get more data from the company. So what could we do?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ä»è¿™å¼ å›¾ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆå¥½åœ°çŒœæµ‹å·¥å…·åœ¨5ä¸‡ä¸ªæ•°æ®é›†ä¸Šçš„è¿è¡Œæ—¶é—´ã€‚ç„¶è€Œï¼Œè¦ç¡®å®šåœ¨150ä¸‡ã€300ä¸‡æˆ–1000ä¸‡ä¸ªæ•°æ®é›†ä¸Šçš„è¿è¡Œæ—¶é—´å°±å›°éš¾å¾—å¤šã€‚è¿™äº›è¿‡ç¨‹åˆ†åˆ«è¢«ç§°ä¸ºå†…æ’å’Œå¤–æ¨ã€‚æˆ‘ä»¬å·²ç»è§£é‡Šäº†ä¸ºä»€ä¹ˆæˆ‘ä»¬æ— æ³•ä»å…¬å¸è·å–æ›´å¤šæ•°æ®ã€‚é‚£ä¹ˆæˆ‘ä»¬èƒ½åšä»€ä¹ˆå‘¢ï¼Ÿ
- en: 'As another problem, suppose we have multiple implementations available. When
    we plot their running time, say the graphs look like this, with red, green, and
    blue each representing different implementations. On small inputs, suppose the
    running times look like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºå¦ä¸€ä¸ªé—®é¢˜ï¼Œå‡è®¾æˆ‘ä»¬æœ‰å¤šä¸ªå®ç°å¯ç”¨ã€‚å½“æˆ‘ä»¬ç»˜åˆ¶å®ƒä»¬çš„è¿è¡Œæ—¶é—´æ—¶ï¼Œæ¯”å¦‚å›¾è¡¨çœ‹èµ·æ¥åƒè¿™æ ·ï¼Œçº¢è‰²ã€ç»¿è‰²å’Œè“è‰²åˆ†åˆ«ä»£è¡¨ä¸åŒçš„å®ç°ã€‚åœ¨å°çš„è¾“å…¥ä¸Šï¼Œå‡è®¾è¿è¡Œæ—¶é—´çœ‹èµ·æ¥åƒè¿™æ ·ï¼š
- en: '![image](../Images/1fe6a875e4a9f3d3a6f962c860dda585.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/1fe6a875e4a9f3d3a6f962c860dda585.png)'
- en: 'This doesnâ€™t seem to help us distinguish between the implementations. Now suppose
    we run the algorithms on larger inputs, and we get the following graphs:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¼¼ä¹å¹¶ä¸èƒ½å¸®åŠ©æˆ‘ä»¬åŒºåˆ†ä¸åŒçš„å®ç°ã€‚ç°åœ¨å‡è®¾æˆ‘ä»¬åœ¨æ›´å¤§çš„è¾“å…¥ä¸Šè¿è¡Œç®—æ³•ï¼Œæˆ‘ä»¬å¾—åˆ°ä»¥ä¸‹å›¾è¡¨ï¼š
- en: '![image](../Images/e4ff72c49a10103cea5fe1690ae0b404.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/e4ff72c49a10103cea5fe1690ae0b404.png)'
- en: 'Now we seem to have a clear winner (red), though itâ€™s not clear there is much
    to give between the other two (blue and green). But if we calculate on even larger
    inputs, we start to see dramatic differences:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬ä¼¼ä¹æœ‰ä¸€ä¸ªæ˜æ˜¾çš„èµ¢å®¶ï¼ˆçº¢è‰²ï¼‰ï¼Œå°½ç®¡ä¸æ¸…æ¥šå…¶ä»–ä¸¤ä¸ªï¼ˆè“è‰²å’Œç»¿è‰²ï¼‰ä¹‹é—´æœ‰ä»€ä¹ˆåŒºåˆ«ã€‚ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬å¯¹æ›´å¤§çš„è¾“å…¥è¿›è¡Œè®¡ç®—ï¼Œæˆ‘ä»¬å¼€å§‹çœ‹åˆ°æ˜æ˜¾çš„å·®å¼‚ï¼š
- en: '![image](../Images/d9aeccc8e556d7c4435cdf97c958a74d.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/d9aeccc8e556d7c4435cdf97c958a74d.png)'
- en: In fact, the functions that resulted in these lines were the same in all three
    figures. What these pictures tell us is that it is dangerous to extrapolate too
    much from the performance on small inputs. If we could obtain closed-form descriptions
    of the performance of computations, it would be nice if we could compare them
    better. That is what we will do in the next section.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: äº‹å®ä¸Šï¼Œå¯¼è‡´è¿™äº›è¡Œå‡ºç°çš„å‡½æ•°åœ¨ä¸‰ä¸ªå›¾ä¸­éƒ½æ˜¯ç›¸åŒçš„ã€‚è¿™äº›å›¾ç‰‡å‘Šè¯‰æˆ‘ä»¬ï¼Œä»å°çš„è¾“å…¥æ€§èƒ½ä¸­è¿‡åº¦å¤–æ¨æ˜¯å±é™©çš„ã€‚å¦‚æœæˆ‘ä»¬èƒ½è·å¾—è®¡ç®—æ€§èƒ½çš„å°é—­å½¢å¼æè¿°ï¼Œé‚£ä¹ˆèƒ½å¤Ÿæ›´å¥½åœ°æ¯”è¾ƒå®ƒä»¬å°†æ˜¯ä»¶å¥½äº‹ã€‚è¿™å°±æ˜¯æˆ‘ä»¬å°†åœ¨ä¸‹ä¸€èŠ‚ä¸­è¦åšçš„ã€‚
- en: 'Responsible Computing: Choose Analysis Artifacts Wisely'
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è´Ÿè´£ä»»è®¡ç®—ï¼šæ˜æ™ºåœ°é€‰æ‹©åˆ†æå·¥å…·
- en: ''
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As more and more decisions are guided by statistical analyses of data (performed
    by humans), itâ€™s critical to recognize that data can be a poor proxy for the actual
    phenomenon that we seek to understand. Here, Debbie had data about program behavior,
    which led to mis-interpretations regarding which program is best. But Debbie also
    had the programs themselves, from which the data were generated. Analyzing the
    programs, rather than the data, is a more direct approach to assessing the performance
    of a program.
  id: totrans-236
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: éšç€è¶Šæ¥è¶Šå¤šçš„å†³ç­–ç”±æ•°æ®ï¼ˆç”±äººç±»æ‰§è¡Œï¼‰çš„ç»Ÿè®¡åˆ†ææŒ‡å¯¼ï¼Œè®¤è¯†åˆ°æ•°æ®å¯èƒ½æ— æ³•å¾ˆå¥½åœ°ä»£è¡¨æˆ‘ä»¬è¯•å›¾ç†è§£çš„å®é™…æƒ…å†µè‡³å…³é‡è¦ã€‚åœ¨è¿™é‡Œï¼ŒDebbieæœ‰å…³äºç¨‹åºè¡Œä¸ºçš„æ•°æ®ï¼Œè¿™å¯¼è‡´äº†å…³äºå“ªä¸ªç¨‹åºæœ€å¥½çš„è¯¯è§£ã€‚ä½†Debbieä¹Ÿæœ‰ç”Ÿæˆè¿™äº›æ•°æ®çš„ç¨‹åºæœ¬èº«ã€‚åˆ†æç¨‹åºè€Œä¸æ˜¯æ•°æ®æ˜¯è¯„ä¼°ç¨‹åºæ€§èƒ½çš„ç›´æ¥æ–¹æ³•ã€‚
- en: ''
  id: totrans-237
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: While the rest of this chapter is about analyzing programs as written in code,
    this point carries over to non-programs as well. You might want to understand
    the effectiveness of a process for triaging patients at a hospital, for example.
    In that case, you have both the policy documents (rules which may or may not have
    been turned into a software program to support managing patients) and data on
    the effectiveness of using that process. Responsible computing tells us to analyze
    both the process and its behavioral data, against knowledge about best practices
    in patient care, to evaluate the effectiveness of systems.
  id: totrans-238
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°½ç®¡æœ¬ç« çš„å…¶ä½™éƒ¨åˆ†æ˜¯å…³äºåˆ†æä»¥ä»£ç å½¢å¼ç¼–å†™çš„ç¨‹åºï¼Œä½†è¿™ä¸€ç‚¹ä¹Ÿé€‚ç”¨äºéç¨‹åºã€‚ä¾‹å¦‚ï¼Œä½ å¯èƒ½æƒ³äº†è§£åœ¨åŒ»é™¢å¯¹ç—…äººè¿›è¡Œåˆ†ç±»å¤„ç†æµç¨‹çš„æœ‰æ•ˆæ€§ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½ æ—¢æœ‰æ”¿ç­–æ–‡ä»¶ï¼ˆå¯èƒ½æˆ–å¯èƒ½æ²¡æœ‰è½¬åŒ–ä¸ºæ”¯æŒç®¡ç†ç—…äººçš„è½¯ä»¶ç¨‹åºçš„è§„å®šï¼‰ï¼Œä¹Ÿæœ‰å…³äºè¯¥æµç¨‹æœ‰æ•ˆæ€§çš„æ•°æ®ã€‚è´Ÿè´£ä»»è®¡ç®—å‘Šè¯‰æˆ‘ä»¬ï¼Œè¦åˆ†ææµç¨‹åŠå…¶è¡Œä¸ºæ•°æ®ï¼Œä¸å…³äºç—…äººæŠ¤ç†æœ€ä½³å®è·µçš„çŸ¥è¯†ç›¸å¯¹æ¯”ï¼Œä»¥è¯„ä¼°ç³»ç»Ÿçš„æœ‰æ•ˆæ€§ã€‚
- en: 14.2Â The Analytical Idea[ğŸ”—](#(part._.The_.Analytical_.Idea) "Link to here")
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2Â åˆ†ææ€æƒ³[ğŸ”—](#(part._.The_.Analytical_.Idea) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'With many physical processes, the best we can do is obtain as many data points
    as possible, extrapolate, and apply statistics to reason about the most likely
    outcome. Sometimes we can do that in computer science, too, but fortunately we
    computer scientists have an enormous advantage over most other sciences: instead
    of measuring a black-box process, we have full access to its internals, namely
    the source code. This enables us to apply analytical methods.â€œAnalyticalâ€ means
    applying algebraic and other mathematical methods to make predictive statements
    about a process without running it. The answer we compute this way is complementary
    to what we obtain from the above experimental analysis, and in practice we will
    usually want to use a combination of the two to arrive a strong understanding
    of the programâ€™s behavior.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºè®¸å¤šç‰©ç†è¿‡ç¨‹ï¼Œæˆ‘ä»¬æ‰€èƒ½åšçš„å°±æ˜¯å°½å¯èƒ½å¤šåœ°è·å¾—æ•°æ®ç‚¹ï¼Œè¿›è¡Œå¤–æ¨ï¼Œå¹¶åº”ç”¨ç»Ÿè®¡å­¦æ¥æ¨æ–­æœ€å¯èƒ½çš„ç»“æœã€‚æœ‰æ—¶åœ¨è®¡ç®—æœºç§‘å­¦ä¸­æˆ‘ä»¬ä¹Ÿèƒ½è¿™æ ·åšï¼Œä½†å¹¸è¿çš„æ˜¯ï¼Œæˆ‘ä»¬è®¡ç®—æœºç§‘å­¦å®¶åœ¨å¤§å¤šæ•°å…¶ä»–ç§‘å­¦ä¸­æ‹¥æœ‰å·¨å¤§çš„ä¼˜åŠ¿ï¼šæˆ‘ä»¬ä¸æ˜¯æµ‹é‡ä¸€ä¸ªé»‘ç›’è¿‡ç¨‹ï¼Œè€Œæ˜¯å®Œå…¨è®¿é—®å…¶å†…éƒ¨ï¼Œå³æºä»£ç ã€‚è¿™ä½¿å¾—æˆ‘ä»¬èƒ½å¤Ÿåº”ç”¨åˆ†ææ–¹æ³•ã€‚â€œåˆ†æâ€æ„å‘³ç€åº”ç”¨ä»£æ•°å’Œå…¶ä»–æ•°å­¦æ–¹æ³•æ¥å¯¹è¿‡ç¨‹åšå‡ºé¢„æµ‹æ€§é™ˆè¿°ï¼Œè€Œæ— éœ€è¿è¡Œå®ƒã€‚æˆ‘ä»¬è¿™æ ·è®¡ç®—å‡ºçš„ç­”æ¡ˆæ˜¯ä¸Šè¿°å®éªŒåˆ†æå¾—åˆ°çš„è¡¥å……ï¼Œåœ¨å®è·µä¸­ï¼Œæˆ‘ä»¬é€šå¸¸å¸Œæœ›ç»“åˆä½¿ç”¨è¿™ä¸¤ç§æ–¹æ³•ï¼Œä»¥è·å¾—å¯¹ç¨‹åºè¡Œä¸ºçš„æ·±å…¥ç†è§£ã€‚
- en: 'The analytical idea is startlingly simple. We look at the source of the program
    and list the operations it performs. For each operation, we look up what it costs.We
    are going to focus on one kind of cost, namely running time. There are many other
    other kinds of costs one can compute. We might naturally be interested in space
    (memory) consumed, which tells us how big a machine we need to buy. We might also
    care about power, this tells us the cost of our energy bills, or of bandwidth,
    which tells us what kind of Internet connection we will need. In general, then,
    weâ€™re interested in resource consumption. In short, donâ€™t make the mistake of
    equating â€œperformanceâ€ with â€œspeedâ€: the costs that matter depend on the context
    in which the application runs. We add up these costs for all the operations. This
    gives us a total cost for the program.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ†æçš„æƒ³æ³•éå¸¸ç®€å•ã€‚æˆ‘ä»¬æŸ¥çœ‹ç¨‹åºçš„æºä»£ç ï¼Œå¹¶åˆ—å‡ºå®ƒæ‰§è¡Œçš„æ“ä½œã€‚å¯¹äºæ¯ä¸ªæ“ä½œï¼Œæˆ‘ä»¬æŸ¥æ‰¾å®ƒçš„æˆæœ¬ã€‚æˆ‘ä»¬å°†ä¸“æ³¨äºä¸€ç§æˆæœ¬ï¼Œå³è¿è¡Œæ—¶é—´ã€‚è¿˜æœ‰è®¸å¤šå…¶ä»–ç±»å‹çš„æˆæœ¬å¯ä»¥è®¡ç®—ã€‚æˆ‘ä»¬å¯èƒ½è‡ªç„¶ä¼šå¯¹ç©ºé—´ï¼ˆå†…å­˜ï¼‰æ¶ˆè€—æ„Ÿå…´è¶£ï¼Œè¿™å‘Šè¯‰æˆ‘ä»¬éœ€è¦è´­ä¹°å¤šå¤§å‹çš„æœºå™¨ã€‚æˆ‘ä»¬ä¹Ÿå¯èƒ½å…³å¿ƒç”µåŠ›ï¼Œè¿™å‘Šè¯‰æˆ‘ä»¬ç”µè´¹çš„æˆæœ¬ï¼Œæˆ–è€…å¸¦å®½ï¼Œè¿™å‘Šè¯‰æˆ‘ä»¬éœ€è¦ä»€ä¹ˆæ ·çš„äº’è”ç½‘è¿æ¥ã€‚æ€»çš„æ¥è¯´ï¼Œæˆ‘ä»¬æ„Ÿå…´è¶£çš„æ˜¯èµ„æºæ¶ˆè€—ã€‚ç®€è€Œè¨€ä¹‹ï¼Œä¸è¦çŠ¯å°†â€œæ€§èƒ½â€ç­‰åŒäºâ€œé€Ÿåº¦â€çš„é”™è¯¯ï¼šé‡è¦çš„æˆæœ¬å–å†³äºåº”ç”¨ç¨‹åºè¿è¡Œçš„ç¯å¢ƒã€‚æˆ‘ä»¬å°†æ‰€æœ‰æ“ä½œçš„æˆæœ¬åŠ èµ·æ¥ã€‚è¿™ç»™å‡ºäº†ç¨‹åºçš„æ€»æˆæœ¬ã€‚
- en: Naturally, for most programs the answer will not be a constant number. Rather,
    it will depend on factors such as the size of the input. Therefore, our answer
    is likely to be an expression in terms of parameters (such as the inputâ€™s size).
    In other words, our answer will be a function.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: è‡ªç„¶åœ°ï¼Œå¯¹äºå¤§å¤šæ•°ç¨‹åºï¼Œç­”æ¡ˆä¸ä¼šæ˜¯ä¸€ä¸ªå¸¸æ•°ã€‚ç›¸åï¼Œå®ƒå°†å–å†³äºè¯¸å¦‚è¾“å…¥å¤§å°ç­‰å› ç´ ã€‚å› æ­¤ï¼Œæˆ‘ä»¬çš„ç­”æ¡ˆå¯èƒ½æ˜¯ä¸€ä¸ªå…³äºå‚æ•°çš„è¡¨è¾¾å¼ï¼ˆä¾‹å¦‚è¾“å…¥çš„å¤§å°ï¼‰ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬çš„ç­”æ¡ˆå°†æ˜¯ä¸€ä¸ªå‡½æ•°ã€‚
- en: 'There are many functions that can describe the running-time of a function.
    Often we want an upper bound on the running time: i.e., the actual number of operations
    will always be no more than what the function predicts. This tells us the maximum
    resource we will need to allocate. Another function may present a lower bound,
    which tells us the least resource we need. Sometimes we want an average-case analysis.
    And so on. In this text we will focus on upper-bounds, but keep in mind that all
    these other analyses are also extremely valuable.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰è®¸å¤šå‡½æ•°å¯ä»¥æè¿°ä¸€ä¸ªå‡½æ•°çš„è¿è¡Œæ—¶é—´ã€‚é€šå¸¸æˆ‘ä»¬å¸Œæœ›æœ‰ä¸€ä¸ªè¿è¡Œæ—¶é—´çš„ä¸Šç•Œï¼šå³å®é™…çš„æ“ä½œæ•°å°†æ°¸è¿œä¸ä¼šè¶…è¿‡å‡½æ•°é¢„æµ‹çš„æ•°é‡ã€‚è¿™å‘Šè¯‰æˆ‘ä»¬éœ€è¦åˆ†é…çš„æœ€å¤§èµ„æºã€‚å¦ä¸€ä¸ªå‡½æ•°å¯èƒ½æä¾›ä¸€ä¸ªä¸‹ç•Œï¼Œè¿™å‘Šè¯‰æˆ‘ä»¬éœ€è¦çš„æœ€å°‘èµ„æºã€‚æœ‰æ—¶æˆ‘ä»¬æƒ³è¦å¹³å‡æƒ…å†µåˆ†æã€‚ç­‰ç­‰ã€‚åœ¨è¿™ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†é‡ç‚¹å…³æ³¨ä¸Šç•Œï¼Œä½†è¯·è®°ä½ï¼Œæ‰€æœ‰è¿™äº›å…¶ä»–åˆ†æä¹Ÿéå¸¸æœ‰ä»·å€¼ã€‚
- en: Exercise
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is incorrect to speak of â€œtheâ€ upper-bound function, because there isnâ€™t
    just one. Given one upper-bound function, can you construct another one?
  id: totrans-246
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¯´åˆ°â€œä¸Šç•Œå‡½æ•°â€ï¼Œè¿™æ˜¯ä¸æ­£ç¡®çš„ï¼Œå› ä¸ºå¹¶ä¸åªæœ‰ä¸€ä¸ªã€‚ç»™å®šä¸€ä¸ªä¸Šç•Œå‡½æ•°ï¼Œä½ èƒ½æ„é€ å¦ä¸€ä¸ªå—ï¼Ÿ
- en: 14.3Â A Cost Model for Pyret Running Time[ğŸ”—](#(part._cost-model) "Link to here")
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3 Pyret è¿è¡Œæ—¶é—´çš„æˆæœ¬æ¨¡å‹[ğŸ”—](#(part._cost-model) "é“¾æ¥è‡³æ­¤")
- en: We begin by presenting a cost model for the running time of Pyret programs.
    We are interested in the cost of running a program, which is tantamount to studying
    the expressions of a program. Simply making a definition does not cost anything;
    the cost is incurred only when we use a definition.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é¦–å…ˆä»‹ç» Pyret ç¨‹åºè¿è¡Œæ—¶é—´çš„æˆæœ¬æ¨¡å‹ã€‚æˆ‘ä»¬å¯¹ç¨‹åºè¿è¡Œçš„æˆæœ¬æ„Ÿå…´è¶£ï¼Œè¿™ç›¸å½“äºç ”ç©¶ç¨‹åºçš„è¡¨è¾¾å¼ã€‚ä»…ä»…å®šä¹‰ä¸€ä¸ªè¡¨è¾¾å¼å¹¶ä¸éœ€è¦ä»»ä½•æˆæœ¬ï¼›åªæœ‰åœ¨ä½¿ç”¨å®šä¹‰æ—¶æ‰ä¼šäº§ç”Ÿæˆæœ¬ã€‚
- en: 'We will use a very simple (but sufficiently accurate) cost model: every operation
    costs one unit of time in addition to the time needed to evaluate its sub-expressions.
    Thus it takes one unit of time to look up a variable or to allocate a constant.
    Applying primitive functions also costs one unit of time. Everything else is a
    compound expression with sub-expressions. The cost of a compound expression is
    one plus that of each of its sub-expressions. For instance, the running time cost
    of the expression `e1 + e2` (for some sub-expressions `e1` and `e2`) is the running
    time for `e1` + the running time for `e2` + 1\. Thus the expression `17 + 29`
    has a cost of 3 (one for each sub-expression and one for the addition); the expression
    `1 + (7 * (2 / 9))` costs 7.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†ä½¿ç”¨ä¸€ä¸ªéå¸¸ç®€å•ï¼ˆä½†è¶³å¤Ÿå‡†ç¡®ï¼‰çš„æˆæœ¬æ¨¡å‹ï¼šæ¯ä¸ªæ“ä½œé™¤äº†éœ€è¦è¯„ä¼°å…¶å­è¡¨è¾¾å¼çš„æ‰€éœ€æ—¶é—´å¤–ï¼Œè¿˜éœ€è¦é¢å¤–ä¸€å•ä½çš„æ—¶é—´ã€‚å› æ­¤ï¼ŒæŸ¥æ‰¾ä¸€ä¸ªå˜é‡æˆ–åˆ†é…ä¸€ä¸ªå¸¸é‡éœ€è¦ä¸€å•ä½çš„æ—¶é—´ã€‚åº”ç”¨åŸå§‹å‡½æ•°ä¹Ÿéœ€è¦ä¸€å•ä½çš„æ—¶é—´ã€‚å…¶ä»–æ‰€æœ‰å†…å®¹éƒ½æ˜¯åŒ…å«å­è¡¨è¾¾å¼çš„å¤åˆè¡¨è¾¾å¼ã€‚å¤åˆè¡¨è¾¾å¼çš„æˆæœ¬æ˜¯å…¶å­è¡¨è¾¾å¼æˆæœ¬çš„æ€»å’ŒåŠ ä¸€ã€‚ä¾‹å¦‚ï¼Œè¡¨è¾¾å¼
    `e1 + e2`ï¼ˆå¯¹äºæŸäº›å­è¡¨è¾¾å¼ `e1` å’Œ `e2`ï¼‰çš„è¿è¡Œæ—¶é—´æˆæœ¬æ˜¯ `e1` çš„è¿è¡Œæ—¶é—´åŠ ä¸Š `e2` çš„è¿è¡Œæ—¶é—´å†åŠ ä¸€ã€‚å› æ­¤ï¼Œè¡¨è¾¾å¼ `17
    + 29` çš„æˆæœ¬æ˜¯ 3ï¼ˆæ¯ä¸ªå­è¡¨è¾¾å¼ä¸€ä¸ªï¼ŒåŠ æ³•æ“ä½œä¸€ä¸ªï¼‰ï¼›è¡¨è¾¾å¼ `1 + (7 * (2 / 9))` çš„æˆæœ¬æ˜¯ 7ã€‚
- en: 'As you can see, there are two big approximations here:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æ‚¨æ‰€è§ï¼Œè¿™é‡Œæœ‰ä¸¤ä¸ªå¤§çš„è¿‘ä¼¼ï¼š
- en: First, we are using an abstract rather than concrete notion of time. This is
    unhelpful in terms of estimating the so-called â€œwall clockâ€ running time of a
    program, but then again, that number depends on numerous factorsâ€”<wbr>not just
    what kind of processor and how much memory you have, but even what other tasks
    are running on your computer at the same time. In contrast, abstract time units
    are more portable.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯æ—¶é—´çš„æŠ½è±¡æ¦‚å¿µè€Œä¸æ˜¯å…·ä½“æ¦‚å¿µã€‚è¿™åœ¨ä¼°è®¡ç¨‹åºæ‰€è°“çš„â€œå¢™é’Ÿâ€è¿è¡Œæ—¶é—´æ–¹é¢å¹¶ä¸ helpfulï¼Œä½†è¯åˆè¯´å›æ¥ï¼Œè¿™ä¸ªæ•°å­—å–å†³äºè®¸å¤šå› ç´ â€”â€”ä¸ä»…ä»…æ˜¯ä½ çš„å¤„ç†å™¨ç±»å‹å’Œå†…å­˜å¤§å°ï¼Œç”šè‡³è¿˜åŒ…æ‹¬ä½ ç”µè„‘ä¸ŠåŒæ—¶è¿è¡Œçš„å…¶ä»–ä»»åŠ¡ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼ŒæŠ½è±¡æ—¶é—´å•ä½æ›´æ˜“äºç§»æ¤ã€‚
- en: Second, not every operation takes the same number of machine cycles, whereas
    we have charged all of them the same number of abstract time units. As long as
    the actual number of cycles each one takes is bounded by a constant factor of
    the number taken by another, this will not pose any mathematical problems for
    reasons we will soon understand [[Comparing Functions](#%28part._big-oh-def%29)].
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç¬¬äºŒï¼Œä¸æ˜¯æ¯ä¸ªæ“ä½œéƒ½éœ€è¦ç›¸åŒæ•°é‡çš„æœºå™¨å‘¨æœŸï¼Œè€Œæˆ‘ä»¬ç»™æ‰€æœ‰æ“ä½œéƒ½è®¡å…¥äº†ç›¸åŒæ•°é‡çš„æŠ½è±¡æ—¶é—´å•ä½ã€‚åªè¦æ¯ä¸ªæ“ä½œå®é™…éœ€è¦çš„å‘¨æœŸæ•°è¢«å¦ä¸€ä¸ªæ“ä½œæ‰€éœ€å‘¨æœŸæ•°çš„å¸¸æ•°å› å­æ‰€é™åˆ¶ï¼Œè¿™å°±ä¸ä¼šå¯¹æ•°å­¦é€ æˆä»»ä½•é—®é¢˜ï¼ŒåŸå› æˆ‘ä»¬å¾ˆå¿«å°±ä¼šç†è§£
    [[æ¯”è¾ƒå‡½æ•°](#%28part._big-oh-def%29)]ã€‚
- en: Of course, it is instructiveâ€”<wbr>after carefully settting up the experimental
    conditionsâ€”<wbr>to make an analytical prediction of a programâ€™s behavior and then
    verify it against what the implementation actually does. If the analytical prediction
    is accurate, we can reconstruct the constant factors hidden in our calculations
    and thus obtain very precise wall-clock time bounds for the program.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œåœ¨ä»”ç»†è®¾ç½®å®éªŒæ¡ä»¶ä¹‹åï¼Œå¯¹ç¨‹åºçš„è¡Œä¸ºè¿›è¡Œè§£æé¢„æµ‹ï¼Œç„¶åéªŒè¯å…¶å®é™…å®ç°ï¼Œè¿™æ˜¯å¾ˆæœ‰æ•™è‚²æ„ä¹‰çš„ã€‚å¦‚æœè§£æé¢„æµ‹æ˜¯å‡†ç¡®çš„ï¼Œæˆ‘ä»¬å°±å¯ä»¥é‡å»ºæˆ‘ä»¬è®¡ç®—ä¸­éšè—çš„å¸¸æ•°å› å­ï¼Œä»è€Œè·å¾—ç¨‹åºéå¸¸ç²¾ç¡®çš„å¢™é’Ÿæ—¶é—´ç•Œé™ã€‚
- en: 'There is one especially tricky kind of expression: `if` (and its fancier cousins,
    like `cases` and `ask`). How do we think about the cost of an `if`? It always
    evaluates the condition. After that, it evaluates only one of its branches. But
    we are interested in the worst case time, i.e., what is the longest it could take?
    For a conditional, itâ€™s the cost of the condition added to the cost of the maximum
    of the two branches.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰ä¸€ç§ç‰¹åˆ«æ£˜æ‰‹çš„è¡¨è¾¾å¼ç±»å‹ï¼š`if`ï¼ˆä»¥åŠå®ƒæ›´å¤æ‚çš„äº²æˆšï¼Œå¦‚ `cases` å’Œ `ask`ï¼‰ã€‚æˆ‘ä»¬å¦‚ä½•è€ƒè™‘ `if` çš„æˆæœ¬ï¼Ÿå®ƒæ€»æ˜¯è¯„ä¼°æ¡ä»¶ã€‚ä¹‹åï¼Œå®ƒåªè¯„ä¼°å…¶åˆ†æ”¯ä¸­çš„ä¸€ä¸ªã€‚ä½†æˆ‘ä»¬æ„Ÿå…´è¶£çš„æ˜¯æœ€åæƒ…å†µä¸‹çš„æ—¶é—´ï¼Œå³å®ƒå¯èƒ½éœ€è¦å¤šé•¿æ—¶é—´ï¼Ÿå¯¹äºæ¡ä»¶è¡¨è¾¾å¼ï¼Œè¿™æ˜¯æ¡ä»¶çš„æˆæœ¬åŠ ä¸Šä¸¤ä¸ªåˆ†æ”¯ä¸­æœ€å¤§åˆ†æ”¯çš„æˆæœ¬ã€‚
- en: 14.4Â The Size of the Input[ğŸ”—](#(part._size-of-input) "Link to here")
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4 è¾“å…¥å¤§å°[ğŸ”—](#(part._size-of-input) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'We gloss over the size of a number, treating it as constant. Observe that the
    value of a number is exponentially larger than its size: \(n\) digits in base
    \(b\) can represent \(b^n\) numbers. Though irrelevant here, when numbers are
    centralâ€”<wbr>e.g., when testing primalityâ€”<wbr>the difference becomes critical!
    We will return to this briefly later [[The Complexity of Numbers](avoid-recomp.html#%28part._numbers-not-constant%29)].'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¿½ç•¥äº†æ•°å­—çš„å¤§å°ï¼Œå°†å…¶è§†ä¸ºå¸¸æ•°ã€‚è¯·æ³¨æ„ï¼Œæ•°å­—çš„å€¼æ¯”å…¶å¤§å°æŒ‡æ•°çº§åœ°å¤§ï¼šä»¥\(b\)ä¸ºåº•\(n\)ä½å¯ä»¥è¡¨ç¤º\(b^n\)ä¸ªæ•°å­—ã€‚è™½ç„¶åœ¨è¿™é‡Œä¸ç›¸å…³ï¼Œä½†å½“æ•°å­—æ˜¯æ ¸å¿ƒæ—¶â€”â€”ä¾‹å¦‚ï¼Œåœ¨æµ‹è¯•ç´ æ•°æ—¶â€”â€”è¿™ç§å·®å¼‚å˜å¾—è‡³å…³é‡è¦ï¼æˆ‘ä»¬ç¨åä¼šç®€è¦åœ°å›åˆ°è¿™ä¸€ç‚¹
    [[æ•°å­—çš„å¤æ‚æ€§](avoid-recomp.html#%28part._numbers-not-constant%29)]ã€‚
- en: It can be subtle to define the size of the argument. Suppose a function consumes
    a list of numbers; it would be natural to define the size of its argument to be
    the length of the list, i.e., the number of `link`s in the list. We could also
    define it to be twice as large, to account for both the `link`s and the individual
    numbers (but as weâ€™ll see [[Comparing Functions](#%28part._big-oh-def%29)], constants
    usually donâ€™t matter). But suppose a function consumes a list of music albums,
    and each music album is itself a list of songs, each of which has information
    about singers and so on. Then how we measure the size depends on what part of
    the input the function being analyzed actually examines. If, say, it only returns
    the length of the list of albums, then it is indifferent to what each list element
    contains [[Monomorphic Lists and Polymorphic Types](processing-lists.html#%28part._polymorphic-data%29)],
    and only the length of the list of albums matters. If, however, the function returns
    a list of all the singers on every album, then it traverses all the way down to
    individual songs, and we have to account for all these data. In short, we care
    about the size of the data potentially accessed by the function.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: å®šä¹‰å‚æ•°çš„å¤§å°å¯èƒ½æœ‰äº›å¾®å¦™ã€‚å‡è®¾ä¸€ä¸ªå‡½æ•°æ¶ˆè€—ä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼›è‡ªç„¶åœ°ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰å…¶å‚æ•°çš„å¤§å°ä¸ºåˆ—è¡¨çš„é•¿åº¦ï¼Œå³åˆ—è¡¨ä¸­`é“¾æ¥`çš„æ•°é‡ã€‚æˆ‘ä»¬ä¹Ÿå¯ä»¥å°†å…¶å®šä¹‰ä¸ºä¸¤å€å¤§ï¼Œä»¥è€ƒè™‘åˆ°`é“¾æ¥`å’Œå•ä¸ªæ•°å­—ï¼ˆä½†æ­£å¦‚æˆ‘ä»¬å°†çœ‹åˆ°çš„
    [[æ¯”è¾ƒå‡½æ•°](#%28part._big-oh-def%29)]ï¼‰ï¼Œå¸¸æ•°é€šå¸¸å¹¶ä¸é‡è¦ï¼‰ã€‚ä½†æ˜¯ï¼Œå‡è®¾ä¸€ä¸ªå‡½æ•°æ¶ˆè€—ä¸€ä¸ªéŸ³ä¹ä¸“è¾‘åˆ—è¡¨ï¼Œå¹¶ä¸”æ¯ä¸ªéŸ³ä¹ä¸“è¾‘æœ¬èº«åˆæ˜¯ä¸€ä¸ªæ­Œæ›²åˆ—è¡¨ï¼Œæ¯ä¸ªæ­Œæ›²éƒ½æœ‰å…³äºæ­Œæ‰‹ç­‰ä¿¡æ¯ã€‚é‚£ä¹ˆæˆ‘ä»¬å¦‚ä½•è¡¡é‡å¤§å°å°±å–å†³äºè¢«åˆ†æå‡½æ•°å®é™…æ£€æŸ¥çš„è¾“å…¥éƒ¨åˆ†ã€‚å¦‚æœï¼Œæ¯”å¦‚è¯´ï¼Œå®ƒåªè¿”å›ä¸“è¾‘åˆ—è¡¨çš„é•¿åº¦ï¼Œé‚£ä¹ˆå®ƒå¯¹æ¯ä¸ªåˆ—è¡¨å…ƒç´ çš„å†…å®¹å°±æ— å…³ç´§è¦
    [[å•æ€åˆ—è¡¨å’Œå¤šæ€ç±»å‹](processing-lists.html#%28part._polymorphic-data%29)]ï¼Œåªæœ‰ä¸“è¾‘åˆ—è¡¨çš„é•¿åº¦æ‰æ˜¯é‡è¦çš„ã€‚ç„¶è€Œï¼Œå¦‚æœå‡½æ•°è¿”å›æ¯ä¸ªä¸“è¾‘ä¸Šæ‰€æœ‰æ­Œæ‰‹çš„åˆ—è¡¨ï¼Œé‚£ä¹ˆå®ƒå°†éå†åˆ°å•ä¸ªæ­Œæ›²ï¼Œæˆ‘ä»¬å¿…é¡»è€ƒè™‘åˆ°æ‰€æœ‰è¿™äº›æ•°æ®ã€‚ç®€è€Œè¨€ä¹‹ï¼Œæˆ‘ä»¬å…³æ³¨çš„æ˜¯å‡½æ•°å¯èƒ½è®¿é—®çš„æ•°æ®çš„å¤§å°ã€‚
- en: 14.5Â The Tabular Method for Singly-Structurally-Recursive Functions[ğŸ”—](#(part._.The_.Tabular_.Method_for_.Singly-.Structurally-.Recursive_.Functions)
    "Link to here")
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.5 å•ç»“æ„é€’å½’å‡½æ•°çš„è¡¨æ ¼æ³•[ğŸ”—](#(part._.The_.Tabular_.Method_for_.Singly-.Structurally-.Recursive_.Functions)
    "é“¾æ¥åˆ°æ­¤å¤„")
- en: Given sizes for the arguments, we simply examine the body of the function and
    add up the costs of the individual operations. Most interesting functions are,
    however, conditionally defined, and may even recur. Here we will assume there
    is only one structural recursive call. We will get to more general cases in a
    bit [[Creating Recurrences](#%28part._creating-recurrences%29)].
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ç»™å®šå‚æ•°çš„å¤§å°ï¼Œæˆ‘ä»¬åªéœ€æ£€æŸ¥å‡½æ•°çš„ä¸»ä½“å¹¶ç´¯åŠ å•ä¸ªæ“ä½œçš„æˆæœ¬ã€‚ç„¶è€Œï¼Œå¤§å¤šæ•°æœ‰è¶£çš„å‡½æ•°éƒ½æ˜¯æ¡ä»¶å®šä¹‰çš„ï¼Œç”šè‡³å¯èƒ½é€’å½’ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†å‡è®¾åªæœ‰ä¸€ä¸ªç»“æ„é€’å½’è°ƒç”¨ã€‚æˆ‘ä»¬å°†åœ¨ç¨åè®¨è®ºæ›´ä¸€èˆ¬çš„æƒ…å†µ
    [[åˆ›å»ºé€’å½’](#%28part._creating-recurrences%29)]ã€‚
- en: When we have a function with only one recursive call, and itâ€™s structural, thereâ€™s
    a handy technique we can use to handle conditionals.This idea is due to Prabhakar
    Ragde. We will set up a table. It wonâ€™t surprise you to hear that the table will
    have as many rows as the cond has clauses. But instead of two columns, it has
    seven! This sounds daunting, but youâ€™ll soon see where they come from and why
    theyâ€™re there.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬æœ‰ä¸€ä¸ªåªæœ‰ä¸€ä¸ªé€’å½’è°ƒç”¨çš„å‡½æ•°ï¼Œå¹¶ä¸”å®ƒæ˜¯ç»“æ„æ€§çš„ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ç§æ–¹ä¾¿çš„æŠ€æœ¯æ¥å¤„ç†æ¡ä»¶ã€‚è¿™ä¸ªæƒ³æ³•å½’åŠŸäºPrabhakar Ragdeã€‚æˆ‘ä»¬å°†å»ºç«‹ä¸€ä¸ªè¡¨æ ¼ã€‚å¬åˆ°è¡¨æ ¼å°†æœ‰ä¸æ¡ä»¶ç›¸åŒçš„è¡Œæ•°ï¼Œä½ ä¸ä¼šæ„Ÿåˆ°æƒŠè®¶ã€‚ä½†æ˜¯ï¼Œå®ƒä¸æ˜¯ä¸¤åˆ—ï¼Œè€Œæ˜¯ä¸ƒåˆ—ï¼è¿™å¬èµ·æ¥å¯èƒ½æœ‰äº›å“äººï¼Œä½†å¾ˆå¿«ä½ å°±ä¼šçœ‹åˆ°å®ƒä»¬ä»ä½•è€Œæ¥ä»¥åŠä¸ºä»€ä¹ˆå­˜åœ¨ã€‚
- en: 'For each row, fill in the columns as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæ¯ä¸€è¡Œï¼ŒæŒ‰ç…§ä»¥ä¸‹æ–¹å¼å¡«å†™åˆ—ï¼š
- en: '|Q|: the number of operations in the question'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '|Q|ï¼šé—®é¢˜ä¸­çš„æ“ä½œæ•°'
- en: '#Q: the number of times the question will execute'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '#Qï¼šé—®é¢˜å°†æ‰§è¡Œçš„æ¬¡æ•°'
- en: 'TotQ: the total cost of the question (multiply the previous two)'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TotQï¼šé—®é¢˜çš„æ€»æˆæœ¬ï¼ˆä¹˜ä»¥å‰ä¸¤ä¸ªï¼‰
- en: '|A|: the number of operations in the answer'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '|A|ï¼šç­”æ¡ˆä¸­çš„æ“ä½œæ•°'
- en: '#A: the number of times the answer will execute'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '#Aï¼šç­”æ¡ˆå°†æ‰§è¡Œçš„æ¬¡æ•°'
- en: 'TotA: the total cost of the answer (multiply the previous two)'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TotAï¼šç­”æ¡ˆçš„æ€»æˆæœ¬ï¼ˆä¹˜ä»¥å‰ä¸¤ä¸ªï¼‰
- en: 'Total: add the two totals to obtain an answer for the clause'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æ€»è®¡ï¼šå°†ä¸¤ä¸ªæ€»è®¡ç›¸åŠ ä»¥è·å¾—å­å¥çš„ç­”æ¡ˆ
- en: Finally, the total cost of the `cond` expression is obtained by summing the
    Total column in the individual rows.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œé€šè¿‡å°†å„ä¸ªè¡Œçš„æ€»è®¡åˆ—ç›¸åŠ ï¼Œå¾—åˆ° `cond` è¡¨è¾¾å¼çš„æ€»æˆæœ¬ã€‚
- en: In the process of computing these costs, we may come across recursive calls
    in an answer expression. So long as there is only one recursive call in the entire
    answer, ignore it.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è®¡ç®—è¿™äº›æˆæœ¬çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šåœ¨ç­”æ¡ˆè¡¨è¾¾å¼ä¸­é‡åˆ°é€’å½’è°ƒç”¨ã€‚åªè¦æ•´ä¸ªç­”æ¡ˆä¸­åªæœ‰ä¸€ä¸ªé€’å½’è°ƒç”¨ï¼Œå°±å¯ä»¥å¿½ç•¥å®ƒã€‚
- en: Exercise
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Once youâ€™ve read the material on [Creating Recurrences](#%28part._creating-recurrences%29),
    come back to this and justify why it is okay to just skip the recursive call.
    Explain in the context of the overall tabular method.
  id: totrans-273
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¯»å®Œå…³äº [åˆ›å»ºé€’å½’](#%28part._creating-recurrences%29) çš„ææ–™åï¼Œå›åˆ°è¿™é‡Œå¹¶è§£é‡Šä¸ºä»€ä¹ˆå¯ä»¥ç®€å•åœ°è·³è¿‡é€’å½’è°ƒç”¨ã€‚åœ¨æ•´ä½“è¡¨æ ¼æ–¹æ³•çš„èƒŒæ™¯ä¸‹è¿›è¡Œè§£é‡Šã€‚
- en: Exercise
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Excluding the treatment of recursion, justify (a) that these columns are individually
    accurate (e.g., the use of additions and multiplications is appropriate), and
    (b) sufficient (i.e., combined, they account for all operations that will be performed
    by that `cond` clause).
  id: totrans-276
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ’é™¤é€’å½’å¤„ç†ï¼Œè¯æ˜ï¼ˆaï¼‰è¿™äº›åˆ—å„è‡ªæ˜¯å‡†ç¡®çš„ï¼ˆä¾‹å¦‚ï¼Œä½¿ç”¨åŠ æ³•å’Œä¹˜æ³•æ˜¯åˆé€‚çš„ï¼‰ï¼Œå¹¶ä¸”ï¼ˆbï¼‰è¶³å¤Ÿå……åˆ†ï¼ˆå³ï¼Œç»“åˆåœ¨ä¸€èµ·ï¼Œå®ƒä»¬è§£é‡Šäº† `cond` å­å¥å°†æ‰§è¡Œçš„æ‰€æœ‰æ“ä½œï¼‰ã€‚
- en: 'Itâ€™s easiest to understand this by applying it to a few examples. First, letâ€™s
    consider the `len` function, noting before we proceed that it does meet the criterion
    of having a single recursive call where the argument is structural:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡åº”ç”¨å®ƒåˆ°å‡ ä¸ªä¾‹å­ä¸­ï¼Œæœ€å®¹æ˜“ç†è§£è¿™ä¸€ç‚¹ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬è€ƒè™‘ `len` å‡½æ•°ï¼Œåœ¨ç»§ç»­ä¹‹å‰è¯·æ³¨æ„å®ƒç¡®å®æ»¡è¶³åªæœ‰ä¸€ä¸ªé€’å½’è°ƒç”¨ä¸”å‚æ•°æ˜¯ç»“æ„æ€§çš„æ ‡å‡†ï¼š
- en: '[PRE1]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Letâ€™s compute the cost of running `len` on a list of length \(k\) (where we
    are only counting the number of `link`s in the list, and ignoring the content
    of each first element (`f`), since `len` ignores them too).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è®¡ç®—åœ¨é•¿åº¦ä¸º \(k\) çš„åˆ—è¡¨ä¸Šè¿è¡Œ `len` å‡½æ•°çš„æˆæœ¬ï¼ˆåœ¨è¿™é‡Œæˆ‘ä»¬åªè®¡ç®—åˆ—è¡¨ä¸­ `link` çš„æ•°é‡ï¼Œè€Œå¿½ç•¥æ¯ä¸ªç¬¬ä¸€ä¸ªå…ƒç´ ï¼ˆ`f`ï¼‰çš„å†…å®¹ï¼Œå› ä¸º
    `len` ä¹Ÿä¼šå¿½ç•¥å®ƒä»¬ï¼‰ã€‚
- en: Because the entire body of `len` is given by a conditional, we can proceed directly
    to building the table.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸º `len` çš„æ•´ä¸ªä¸»ä½“ç”±ä¸€ä¸ªæ¡ä»¶ç»™å‡ºï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç›´æ¥å¼€å§‹æ„å»ºè¡¨æ ¼ã€‚
- en: Letâ€™s consider the first row. The question costs three units (one each to evaluate
    the implicit `empty`-ness predicate, `l`, and to apply the former to the latter).
    This is evaluated once per element in the list and once more when the list is
    empty, i.e., \(k+1\) times. The total cost of the question is thus \(3(k+1)\).
    The answer takes one unit of time to compute, and is evaluated only once (when
    the list is empty). Thus it takes a total of one unit, for a total of \(3k+4\)
    units.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è€ƒè™‘ç¬¬ä¸€è¡Œã€‚é—®é¢˜èŠ±è´¹ä¸‰ä¸ªå•ä½ï¼ˆæ¯ä¸ªå…ƒç´ è¯„ä¼°éšå«çš„ `empty`-ness è°“è¯ `l` å’Œå°†å‰è€…åº”ç”¨äºåè€…å„ä¸€ä¸ªå•ä½ï¼‰ã€‚è¿™æ˜¯å¯¹åˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ è¯„ä¼°ä¸€æ¬¡ï¼Œå½“åˆ—è¡¨ä¸ºç©ºæ—¶å†è¯„ä¼°ä¸€æ¬¡ï¼Œå³
    \(k+1\) æ¬¡ã€‚å› æ­¤ï¼Œé—®é¢˜çš„æ€»æˆæœ¬æ˜¯ \(3(k+1)\)ã€‚ç­”æ¡ˆéœ€è¦ä¸€å•ä½æ—¶é—´æ¥è®¡ç®—ï¼Œå¹¶ä¸”åªè¯„ä¼°ä¸€æ¬¡ï¼ˆå½“åˆ—è¡¨ä¸ºç©ºæ—¶ï¼‰ã€‚å› æ­¤ï¼Œæ€»å…±éœ€è¦ä¸€å•ä½æ—¶é—´ï¼Œæ€»æˆæœ¬ä¸º
    \(3k+4\) ä¸ªå•ä½ã€‚
- en: Now for the second row. The question again costs three units, and is evaluated
    \(k\) times. The answer involves two units to evaluate the rest of the list `l.rest`,
    which is implicitly hidden by the naming of `r`, two more to evaluate and apply
    `1 +`, one more to evaluate `len`...and no more, because we are ignoring the time
    spent in the recursive call itself. In short, it takes five units of time (in
    addition to the recursion weâ€™ve chosen to ignore).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è€ƒè™‘ç¬¬äºŒè¡Œã€‚é—®é¢˜å†æ¬¡èŠ±è´¹ä¸‰ä¸ªå•ä½ï¼Œå¹¶ä¸”è¢«è¯„ä¼° \(k\) æ¬¡ã€‚ç­”æ¡ˆæ¶‰åŠä¸¤ä¸ªå•ä½æ¥è¯„ä¼°å‰©ä½™çš„åˆ—è¡¨ `l.rest`ï¼Œè¿™æ˜¯é€šè¿‡ `r` çš„å‘½åéšå«çš„ï¼Œå¦å¤–ä¸¤ä¸ªå•ä½æ¥è¯„ä¼°å’Œåº”ç”¨
    `1 +`ï¼Œä¸€ä¸ªå•ä½æ¥è¯„ä¼° `len`...ç­‰ç­‰ï¼Œå› ä¸ºæˆ‘ä»¬å¿½ç•¥äº†é€’å½’è°ƒç”¨æœ¬èº«æ‰€èŠ±è´¹çš„æ—¶é—´ã€‚ç®€è€Œè¨€ä¹‹ï¼Œå®ƒéœ€è¦äº”ä¸ªå•ä½çš„æ—¶é—´ï¼ˆé™¤äº†æˆ‘ä»¬é€‰æ‹©å¿½ç•¥çš„é€’å½’ä¹‹å¤–ï¼‰ã€‚
- en: 'In tabular form:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥è¡¨æ ¼å½¢å¼ï¼š
- en: '| &#124;Q&#124; |  | #Q |  | TotQ |  | &#124;A&#124; |  | #A |  | TotA |  |
    Total |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| &#124;Q&#124; |  | #Q |  | TotQ |  | &#124;A&#124; |  | #A |  | TotA |  |
    Total |'
- en: '| \(3\) |  | \(k+1\) |  | \(3(k+1)\) |  | \(1\) |  | \(1\) |  | \(1\) |  |
    \(3k+4\) |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| \(3\) |  | \(k+1\) |  | \(3(k+1)\) |  | \(1\) |  | \(1\) |  | \(1\) |  |
    \(3k+4\) |'
- en: '| \(3\) |  | \(k\) |  | \(3k\) |  | \(5\) |  | \(k\) |  | \(5k\) |  | \(8k\)
    |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| \(3\) |  | \(k\) |  | \(3k\) |  | \(5\) |  | \(k\) |  | \(5k\) |  | \(8k\)
    |'
- en: Adding, we get \(11k + 4\). Thus running `len` on a \(k\)-element list takes
    \(11k+4\) units of time.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: åŠ èµ·æ¥ï¼Œæˆ‘ä»¬å¾—åˆ° \(11k + 4\)ã€‚å› æ­¤ï¼Œåœ¨ \(k\) ä¸ªå…ƒç´ çš„åˆ—è¡¨ä¸Šè¿è¡Œ `len` å‡½æ•°éœ€è¦ \(11k+4\) ä¸ªæ—¶é—´å•ä½ã€‚
- en: Exercise
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How accurate is this estimate? If you try applying `len` to different sizes
    of lists, do you obtain a consistent estimate for \(k\)?
  id: totrans-290
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™ä¸ªä¼°è®¡æœ‰å¤šå‡†ç¡®ï¼Ÿå¦‚æœä½ å°è¯•å°† `len` åº”ç”¨äºä¸åŒå¤§å°çš„åˆ—è¡¨ï¼Œä½ æ˜¯å¦è·å¾—äº†å¯¹ \(k\) çš„ä¸€è‡´ä¼°è®¡ï¼Ÿ
- en: 14.6Â Creating Recurrences[ğŸ”—](#(part._creating-recurrences) "Link to here")
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.6Â åˆ›å»ºé€’å½’[ğŸ”—](#(part._creating-recurrences) "é“¾æ¥åˆ°æ­¤å¤„")
- en: We will now see a systematic way of analytically computing the time of a program.
    Suppose we have only one function `f`. We will define a function, \(T\), to compute
    an upper-bound of the time of `f`.In general, we will have one such cost function
    for each function in the program. In such cases, it would be useful to give a
    different name to each function to easily tell them apart. Since we are looking
    at only one function for now, weâ€™ll reduce notational overhead by having only
    one \(T\). \(T\) takes as many parameters as `f` does. The parameters to \(T\)
    represent the sizes of the corresponding arguments to `f`. Eventually we will
    want to arrive at a closed form solution to \(T\), i.e., one that does not refer
    to \(T\) itself. But the easiest way to get there is to write a solution that
    is permitted to refer to \(T\), called a recurrence relation, and then see how
    to eliminate the self-reference [[Solving Recurrences](#%28part._solving-recurrences%29)].
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨å°†çœ‹åˆ°ä¸€ç§ç³»ç»Ÿæ€§çš„åˆ†ææ–¹æ³•æ¥è®¡ç®—ç¨‹åºçš„æ—¶é—´ã€‚å‡è®¾æˆ‘ä»¬åªæœ‰ä¸€ä¸ªå‡½æ•° `f`ã€‚æˆ‘ä»¬å°†å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œ\(T\)ï¼Œæ¥è®¡ç®— `f` æ—¶é—´çš„ä¸Šç•Œã€‚ä¸€èˆ¬æ¥è¯´ï¼Œå¯¹äºç¨‹åºä¸­çš„æ¯ä¸ªå‡½æ•°ï¼Œæˆ‘ä»¬éƒ½ä¼šæœ‰ä¸€ä¸ªè¿™æ ·çš„æˆæœ¬å‡½æ•°ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç»™æ¯ä¸ªå‡½æ•°èµ·ä¸€ä¸ªä¸åŒçš„åå­—ä»¥ä¾¿äºåŒºåˆ†ä¼šå¾ˆæœ‰ç”¨ã€‚ç”±äºæˆ‘ä»¬ç°åœ¨åªå…³æ³¨ä¸€ä¸ªå‡½æ•°ï¼Œæˆ‘ä»¬å°†é€šè¿‡åªæœ‰ä¸€ä¸ª
    \(T\) æ¥å‡å°‘ç¬¦å·çš„è´Ÿæ‹…ã€‚\(T\) çš„å‚æ•°æ•°é‡ä¸ `f` ç›¸åŒã€‚\(T\) çš„å‚æ•°ä»£è¡¨ `f` å¯¹åº”å‚æ•°çš„å¤§å°ã€‚æœ€ç»ˆï¼Œæˆ‘ä»¬å¸Œæœ›å¾—åˆ° \(T\) çš„å°é—­å½¢å¼è§£ï¼Œå³ä¸ç›´æ¥å¼•ç”¨
    \(T\) æœ¬èº«çš„è§£ã€‚ä½†è¾¾åˆ°è¿™ä¸€ç‚¹çš„æœ€ç®€å•æ–¹æ³•æ˜¯å†™å‡ºä¸€ä¸ªå…è®¸å¼•ç”¨ \(T\) çš„è§£ï¼Œç§°ä¸ºé€’å½’å…³ç³»ï¼Œç„¶åçœ‹çœ‹å¦‚ä½•æ¶ˆé™¤è‡ªå¼•ç”¨ [[è§£å†³é€’å½’](#(part._solving-recurrences))]ã€‚
- en: We repeat this procedure for each function in the program in turn. If there
    are many functions, first solve for the one with no dependencies on other functions,
    then use its solution to solve for a function that depends only on it, and progress
    thus up the dependency chain. That way, when we get to a function that refers
    to other functions, we will already have a closed-form solution for the referred
    functionâ€™s running time and can simply plug in parameters to obtain a solution.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¾æ¬¡å¯¹ç¨‹åºä¸­çš„æ¯ä¸ªå‡½æ•°é‡å¤æ­¤è¿‡ç¨‹ã€‚å¦‚æœæœ‰è®¸å¤šå‡½æ•°ï¼Œé¦–å…ˆè§£å†³æ²¡æœ‰å…¶ä»–å‡½æ•°ä¾èµ–çš„å‡½æ•°ï¼Œç„¶åä½¿ç”¨å…¶è§£æ¥è§£å†³åªä¾èµ–äºå®ƒçš„å‡½æ•°ï¼Œå¹¶æ²¿ç€ä¾èµ–é“¾å‘ä¸Šæ¨è¿›ã€‚è¿™æ ·ï¼Œå½“æˆ‘ä»¬åˆ°è¾¾ä¸€ä¸ªå¼•ç”¨å…¶ä»–å‡½æ•°çš„å‡½æ•°æ—¶ï¼Œæˆ‘ä»¬å·²ç»æœ‰äº†ä¸€ä¸ªå°é—­å½¢å¼çš„è§£ï¼Œå¯ä»¥ç®€å•åœ°æ’å…¥å‚æ•°æ¥è·å¾—ä¸€ä¸ªè§£ã€‚
- en: Exercise
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The strategy outlined above doesnâ€™t work when there are functions that depend
    on each other. How would you generalize it to handle this case?
  id: totrans-296
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å½“æœ‰å‡½æ•°ç›¸äº’ä¾èµ–æ—¶ï¼Œä¸Šè¿°ç­–ç•¥ä¸èµ·ä½œç”¨ã€‚ä½ å°†å¦‚ä½•æ³›åŒ–å®ƒä»¥å¤„ç†è¿™ç§æƒ…å†µï¼Ÿ
- en: The process of setting up a recurrence is easy. We simply define the right-hand-side
    of \(T\) to add up the operations performed in `f`â€™s body. This is straightforward
    except for conditionals and recursion. Weâ€™ll elaborate on the treatment of conditionals
    in a moment. If we get to a recursive call to `f` on the argument `a`, in the
    recurrence we turn this into a (self-)reference to \(T\) on the size of `a`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: è®¾ç½®é€’å½’çš„è¿‡ç¨‹å¾ˆç®€å•ã€‚æˆ‘ä»¬åªéœ€å®šä¹‰ \(T\) çš„å³ä¾§æ¥ç´¯åŠ  `f` ä½“ä¸­æ‰§è¡Œçš„æ“ä½œã€‚è¿™å¾ˆç®€å•ï¼Œé™¤äº†æ¡ä»¶è¯­å¥å’Œé€’å½’ã€‚æˆ‘ä»¬ç¨åä¼šè¯¦ç»†è¯´æ˜å¯¹æ¡ä»¶è¯­å¥çš„å¤„ç†ã€‚å¦‚æœæˆ‘ä»¬å¯¹å‚æ•°
    `a` çš„ `f` è¿›è¡Œé€’å½’è°ƒç”¨ï¼Œåœ¨é€’å½’ä¸­ï¼Œæˆ‘ä»¬å°†è¿™è½¬æ¢ä¸ºå¯¹ `a` å¤§å°ä¸Šçš„ \(T\) çš„ï¼ˆè‡ªæˆ‘ï¼‰å¼•ç”¨ã€‚
- en: 'For conditionals, we use only the |Q| and |A| columns of the corresponding
    table. Rather than multiplying by the size of the input, we add up the operations
    that happen on one invocation of `f` other than the recursive call, and then add
    the cost of the recursive call in terms of a reference to \(T\). Thus, if we were
    doing this for `len` above, we would define \(T(k)\)â€”<wbr>the time needed on an
    input of length \(k\)â€”<wbr>in two parts: the value of \(T(0)\) (when the list
    is empty) and the value for non-zero values of \(k\). We know that \(T(0) = 4\)
    (the cost of the first conditional and its corresponding answer). If the list
    is non-empty, the cost is \(T(k) = 3 + 3 + 5 + T(k-1)\) (respectively from the
    first question, the second question, the remaining operations in the second answer,
    and the recursive call on a list one element smaller). This gives the following
    recurrence:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæ¡ä»¶è¯­å¥ï¼Œæˆ‘ä»¬åªä½¿ç”¨ç›¸åº”è¡¨æ ¼çš„ |Q| å’Œ |A| åˆ—ã€‚æˆ‘ä»¬ä¸æ˜¯é€šè¿‡ä¹˜ä»¥è¾“å…¥çš„å¤§å°æ¥ç´¯åŠ æ“ä½œï¼Œè€Œæ˜¯ç´¯åŠ  `f` çš„ä¸€æ¬¡è°ƒç”¨ä¸­é™¤äº†é€’å½’è°ƒç”¨ä¹‹å¤–å‘ç”Ÿçš„æ“ä½œï¼Œç„¶ååŠ ä¸Šé€’å½’è°ƒç”¨çš„æˆæœ¬ï¼Œä»¥
    \(T\) çš„å¼•ç”¨æ¥è¡¨ç¤ºã€‚å› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬å¯¹ä¸Šé¢çš„ `len` åšè¿™ä»¶äº‹ï¼Œæˆ‘ä»¬å°† \(T(k)\)â€”â€”å³è¾“å…¥é•¿åº¦ä¸º \(k\) æ—¶æ‰€éœ€çš„æ—¶é—´â€”â€”å®šä¹‰ä¸ºä¸¤éƒ¨åˆ†ï¼š\(T(0)\)
    çš„å€¼ï¼ˆå½“åˆ—è¡¨ä¸ºç©ºæ—¶ï¼‰å’Œ \(k\) éé›¶å€¼æ—¶çš„å€¼ã€‚æˆ‘ä»¬çŸ¥é“ \(T(0) = 4\)ï¼ˆç¬¬ä¸€ä¸ªæ¡ä»¶è¯­å¥åŠå…¶å¯¹åº”ç­”æ¡ˆçš„æˆæœ¬ï¼‰ã€‚å¦‚æœåˆ—è¡¨ä¸ä¸ºç©ºï¼Œæˆæœ¬æ˜¯ \(T(k)
    = 3 + 3 + 5 + T(k-1)\)ï¼ˆåˆ†åˆ«æ¥è‡ªç¬¬ä¸€ä¸ªé—®é¢˜ã€ç¬¬äºŒä¸ªé—®é¢˜ã€ç¬¬äºŒä¸ªç­”æ¡ˆä¸­çš„å‰©ä½™æ“ä½œå’Œå¯¹é•¿åº¦å°ä¸€ä¸ªå…ƒç´ çš„åˆ—è¡¨çš„é€’å½’è°ƒç”¨ï¼‰ã€‚è¿™ç»™å‡ºäº†ä»¥ä¸‹é€’å½’å…³ç³»ï¼š
- en: \begin{equation*}T(k) = \begin{cases} 4 & \text{when } k = 0 \\ 11 + T(k-1)
    & \text{when } k > 0\\ \end{cases}\end{equation*}
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}T(k) = \begin{cases} 4 & \text{when } k = 0 \\ 11 + T(k-1)
    & \text{when } k > 0\\ \end{cases}\end{equation*}
- en: 'For a given list that is \(p\) elements long (note that \(p \geq 0\)), this
    would take \(11\) steps for the first element, \(11\) more steps for the second,
    \(11\) more for the third, and so on, until we run out of list elements and need
    \(4\) more steps: a total of \(11p + 4\) steps. Notice this is precisely the same
    answer we obtained by the tabular method!'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºä¸€ä¸ªé•¿åº¦ä¸º \(p\) çš„ç»™å®šåˆ—è¡¨ï¼ˆæ³¨æ„ \(p \geq 0\)ï¼‰ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ éœ€è¦ \(11\) æ­¥ï¼Œç¬¬äºŒä¸ªå…ƒç´ éœ€è¦ \(11\) æ›´å¤šæ­¥ï¼Œç¬¬ä¸‰ä¸ªå…ƒç´ éœ€è¦
    \(11\) æ›´å¤šæ­¥ï¼Œä»¥æ­¤ç±»æ¨ï¼Œç›´åˆ°æˆ‘ä»¬ç”¨å®Œåˆ—è¡¨å…ƒç´ å¹¶éœ€è¦ \(4\) æ›´å¤šæ­¥ï¼šæ€»å…± \(11p + 4\) æ­¥ã€‚æ³¨æ„ï¼Œè¿™æ­£æ˜¯æˆ‘ä»¬é€šè¿‡è¡¨æ ¼æ–¹æ³•å¾—åˆ°çš„ç»“æœï¼
- en: Exercise
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why can we assume that for a list \(p\) elements long, \(p \geq 0\)? And why
    did we take the trouble to explicitly state this above?
  id: totrans-303
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆæˆ‘ä»¬å¯ä»¥å‡è®¾å¯¹äºä¸€ä¸ªé•¿åº¦ä¸º \(p\) çš„åˆ—è¡¨ï¼Œ\(p \geq 0\)ï¼Ÿä¸ºä»€ä¹ˆæˆ‘ä»¬è´¹å¿ƒåœ¨ä¸Šæ–‡ä¸­æ˜ç¡®åœ°å£°æ˜è¿™ä¸€ç‚¹ï¼Ÿ
- en: With some thought, you can see that the idea of constructing a recurrence works
    even when there is more than one recursive call, and when the argument to that
    call is one element structurally smaller. What we havenâ€™t seen, however, is a
    way to solve such relations in general. Thatâ€™s where weâ€™re going next [[Solving
    Recurrences](#%28part._solving-recurrences%29)].
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ç»è¿‡ä¸€äº›æ€è€ƒï¼Œä½ å¯ä»¥çœ‹åˆ°ï¼Œå³ä½¿å­˜åœ¨å¤šä¸ªé€’å½’è°ƒç”¨ï¼Œå¹¶ä¸”è°ƒç”¨å‚æ•°ç»“æ„ä¸Šæ›´å°ï¼Œæ„é€ é€’å½’çš„æƒ³æ³•ä¹Ÿæ˜¯å¯è¡Œçš„ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬è¿˜æ²¡æœ‰çœ‹åˆ°ä¸€ç§è§£å†³æ­¤ç±»å…³ç³»çš„ä¸€èˆ¬æ–¹æ³•ã€‚è¿™å°±æ˜¯æˆ‘ä»¬æ¥ä¸‹æ¥è¦è®¨è®ºçš„
    [[æ±‚è§£é€’å½’å…³ç³»](#(part._solving-recurrences%29)]ï¼‰ã€‚
- en: 14.7Â A Notation for Functions[ğŸ”—](#(part._math-anon-functions) "Link to here")
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.7 å‡½æ•°çš„ç¬¦å·[ğŸ”—](#(part._math-anon-functions) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'We have seen above that we can describe the running time of `len` through a
    function. We donâ€™t have an especially good notation for writing such (anonymous)
    functions. Wait, we doâ€”<wbr>`lam(k): (11 * k) + 4 end`â€”<wbr>but my colleagues
    would be horrified if you wrote this on their exams. Therefore, weâ€™ll introduce
    the following notation to mean precisely the same thing:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 'æˆ‘ä»¬åœ¨ä¸Šé¢çœ‹åˆ°ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸€ä¸ªå‡½æ•°æ¥æè¿° `len` çš„è¿è¡Œæ—¶é—´ã€‚æˆ‘ä»¬æ²¡æœ‰ç‰¹åˆ«å¥½çš„ç¬¦å·æ¥ç¼–å†™è¿™æ ·çš„ï¼ˆåŒ¿åï¼‰å‡½æ•°ã€‚ç­‰ç­‰ï¼Œæˆ‘ä»¬ç¡®å®æœ‰â€”â€”<wbr>`lam(k):
    (11 * k) + 4 end`â€”<wbr>ä½†å¦‚æœä½ åœ¨åŒäº‹çš„è€ƒè¯•ä¸Šå†™ä¸‹è¿™ä¸ªï¼Œä»–ä»¬å¯èƒ½ä¼šå¾ˆéœ‡æƒŠã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°†å¼•å…¥ä»¥ä¸‹ç¬¦å·ï¼Œå…¶å«ä¹‰ä¸ä¸Šè¿°å†…å®¹å®Œå…¨ç›¸åŒï¼š'
- en: \begin{equation*}[k \rightarrow 11k + 4]\end{equation*}
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}[k \rightarrow 11k + 4]\end{equation*}
- en: The brackets denote anonymous functions, with the parameters before the arrow
    and the body after.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: æ–¹æ‹¬å·è¡¨ç¤ºåŒ¿åå‡½æ•°ï¼Œç®­å¤´å‰çš„å‚æ•°å’Œç®­å¤´åçš„ä¸»ä½“ã€‚
- en: 14.8Â Comparing Functions[ğŸ”—](#(part._big-oh-def) "Link to here")
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.8 æ¯”è¾ƒå‡½æ•°[ğŸ”—](#(part._big-oh-def) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Letâ€™s return to the running time of `len`. Weâ€™ve written down a function of
    great precision: 11! 4! Is this justified?'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å›åˆ° `len` çš„è¿è¡Œæ—¶é—´ã€‚æˆ‘ä»¬å·²ç»å†™ä¸‹äº†ä¸€ä¸ªéå¸¸ç²¾ç¡®çš„å‡½æ•°ï¼š\(11!\) å’Œ \(4!\)ã€‚è¿™æ˜¯å¦åˆç†ï¼Ÿ
- en: At a fine-grained level already, no, itâ€™s not. Weâ€™ve lumped many operations,
    with different actual running times, into a cost of one. So perhaps we should
    not worry too much about the differences between, say, \([k \rightarrow 11k +
    4]\) and \([k \rightarrow 4k + 10]\). If we were given two implementations with
    these running times, respectively, itâ€™s likely that we would pick other characteristics
    to choose between them.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç»†ç²’åº¦å±‚é¢ä¸Šï¼Œä¸ï¼Œå¹¶ä¸æ˜¯è¿™æ ·ã€‚æˆ‘ä»¬å·²ç»å°†è®¸å¤šå…·æœ‰ä¸åŒå®é™…è¿è¡Œæ—¶é—´çš„æ“ä½œåˆå¹¶ä¸ºä¸€ä¸ªæˆæœ¬ã€‚å› æ­¤ï¼Œä¹Ÿè®¸æˆ‘ä»¬ä¸å¿…è¿‡äºæ‹…å¿ƒï¼Œæ¯”å¦‚ \([k \rightarrow
    11k + 4]\) å’Œ \([k \rightarrow 4k + 10]\) ä¹‹é—´çš„å·®å¼‚ã€‚å¦‚æœæˆ‘ä»¬è¢«æä¾›äº†å…·æœ‰è¿™äº›è¿è¡Œæ—¶é—´çš„ä¸¤ä¸ªå®ç°ï¼Œæˆ‘ä»¬å¾ˆå¯èƒ½ä¼šé€‰æ‹©å…¶ä»–ç‰¹å¾æ¥åŒºåˆ†å®ƒä»¬ã€‚
- en: 'What this boils down to is being able to compare two functions (representing
    the performance of implementations) for whether one is somehow quantitatively
    better in some meaningful sense than the other: i.e., is the quantitative difference
    so great that it might lead to a qualitative one. The example above suggests that
    small differences in constants probably do not matter.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å½’ç»“ä¸ºèƒ½å¤Ÿæ¯”è¾ƒä¸¤ä¸ªå‡½æ•°ï¼ˆä»£è¡¨å®ç°çš„æ€§èƒ½ï¼‰ï¼Œä»¥åˆ¤æ–­ä¸€ä¸ªåœ¨æŸç§æ„ä¹‰ä¸Šæ˜¯å¦æ¯”å¦ä¸€ä¸ªå®šé‡åœ°æ›´å¥½ï¼šå³ï¼Œè¿™ç§å®šé‡å·®å¼‚æ˜¯å¦å¦‚æ­¤ä¹‹å¤§ï¼Œä»¥è‡³äºå¯èƒ½å¯¼è‡´å®šæ€§å·®å¼‚ã€‚ä¸Šé¢çš„ä¾‹å­è¡¨æ˜ï¼Œå¸¸æ•°ä¹‹é—´çš„å¾®å°å·®å¼‚å¯èƒ½å¹¶ä¸é‡è¦ã€‚
- en: 'That is, we want a way to compare two functions, \(f_1\) and \(f_2\). What
    does it mean for \(f_1\) to be â€œlessâ€ than \(f_2\), without worrying about constants?
    We obtain this definition:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: å³ï¼Œæˆ‘ä»¬æƒ³è¦ä¸€ç§æ¯”è¾ƒä¸¤ä¸ªå‡½æ•° \(f_1\) å’Œ \(f_2\) çš„æ–¹æ³•ã€‚\(f_1\) æ¯” \(f_2\) â€œå°â€æ„å‘³ç€ä»€ä¹ˆï¼Œè€Œä¸å¿…æ‹…å¿ƒå¸¸æ•°ï¼Ÿæˆ‘ä»¬å¾—åˆ°ä»¥ä¸‹å®šä¹‰ï¼š
- en: \begin{equation*}\exists c . \forall n \in \mathbb{N}, f_1(n) \leq c \cdot f_2(n)
    \Rightarrow f_1 \leq f_2\end{equation*}
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}\exists c . \forall n \in \mathbb{N}, f_1(n) \leq c \cdot f_2(n)
    \Rightarrow f_1 \leq f_2\end{equation*}
- en: 'This says that for all natural numbers (\(N\)), the value of \(f_1\) will always
    be less than the value of \(f_2\). However, to accommodate our intution that multiplicative
    constants donâ€™t matter, the definition allows the value of \(f_2\) at all points
    to be multiplied by some constant \(c\) to achieve the inequality. Observe, however,
    that \(c\) is independent of \(n\): it is chosen once and must then work for the
    infinite number of values. In practice, this means that the presence of \(c\)
    lets us bypass some number of early values where \(f_1\) might have a greater
    value than \(f_2\), so long as, after a point, \(f_2\) dominates \(f_1\).'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ„å‘³ç€å¯¹äºæ‰€æœ‰è‡ªç„¶æ•° (\(N\))ï¼Œ\(f_1\) çš„å€¼å°†å§‹ç»ˆå°äº \(f_2\) çš„å€¼ã€‚ç„¶è€Œï¼Œä¸ºäº†é€‚åº”æˆ‘ä»¬å…³äºä¹˜æ³•å¸¸æ•°æ— å…³ç´§è¦çš„ç›´è§‰ï¼Œå®šä¹‰å…è®¸åœ¨æ‰€æœ‰ç‚¹ä¸Šå°†
    \(f_2\) çš„å€¼ä¹˜ä»¥æŸä¸ªå¸¸æ•° \(c\) ä»¥è¾¾åˆ°ä¸ç­‰å¼ã€‚ç„¶è€Œï¼Œè¯·æ³¨æ„ï¼Œ\(c\) ä¸ \(n\) æ— å…³ï¼šå®ƒåªé€‰æ‹©ä¸€æ¬¡ï¼Œç„¶åå¿…é¡»é€‚ç”¨äºæ— é™å¤šä¸ªå€¼ã€‚åœ¨å®è·µä¸­ï¼Œè¿™æ„å‘³ç€
    \(c\) çš„å­˜åœ¨ä½¿æˆ‘ä»¬èƒ½å¤Ÿç»•è¿‡ä¸€äº›æ—©æœŸå€¼ï¼Œåœ¨è¿™äº›å€¼ä¸­ \(f_1\) å¯èƒ½æ¯” \(f_2\) å¤§ï¼Œåªè¦åœ¨æŸä¸ªç‚¹ä¸Š \(f_2\) ä¼˜äº \(f_1\)ã€‚
- en: 'This definition has more flexibility than we might initially think. For instance,
    consider our running example compared with \([k \rightarrow k^2]\). Clearly, the
    latter function eventually dominates the former: i.e.,'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªå®šä¹‰æ¯”æˆ‘ä»¬æœ€åˆæƒ³è±¡çš„è¦çµæ´»å¾—å¤šã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘æˆ‘ä»¬çš„è¿è¡Œç¤ºä¾‹ä¸ \([k \rightarrow k^2]\) çš„æ¯”è¾ƒã€‚æ˜¾ç„¶ï¼Œåè€…å‡½æ•°æœ€ç»ˆä¼šä¸»å¯¼å‰è€…ï¼šå³ï¼Œ
- en: \begin{equation*}[k \rightarrow 11k+4] \leq [k \rightarrow k^2]\end{equation*}
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}[k \rightarrow 11k+4] \leq [k \rightarrow k^2]\end{equation*}
- en: We just need to pick a sufficiently large constant and we will find this to
    be true.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åªéœ€è¦é€‰æ‹©ä¸€ä¸ªè¶³å¤Ÿå¤§çš„å¸¸æ•°ï¼Œæˆ‘ä»¬å°±ä¼šæ‰¾åˆ°è¿™æ˜¯çœŸçš„ã€‚
- en: Exercise
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the smallest constant that will suffice?
  id: totrans-321
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æœ€å°çš„å¸¸æ•°æ˜¯å¤šå°‘æ‰èƒ½æ»¡è¶³æ¡ä»¶ï¼Ÿ
- en: You will find more complex definitions in the literature and they all have merits,
    because they enable us to make finer-grained distinctions than this definition
    allows. For the purpose of this book, however, the above definition suffices.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å°†åœ¨æ–‡çŒ®ä¸­æ‰¾åˆ°æ›´å¤æ‚çš„å®šä¹‰ï¼Œå¹¶ä¸”å®ƒä»¬éƒ½æœ‰ä¼˜ç‚¹ï¼Œå› ä¸ºå®ƒä»¬ä½¿æˆ‘ä»¬èƒ½å¤Ÿåšå‡ºæ¯”è¿™ä¸ªå®šä¹‰æ›´ç²¾ç»†çš„åŒºåˆ†ã€‚ç„¶è€Œï¼Œå¯¹äºæœ¬ä¹¦çš„ç›®çš„ï¼Œä¸Šè¿°å®šä¹‰å°±è¶³å¤Ÿäº†ã€‚
- en: Do Now!
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why are the quantifiers written in this and not the opposite order? What if
    we had swapped them, so that we could choose a \(c\) for each \(n\)?
  id: totrans-325
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆé‡è¯è¢«å†™æˆè¿™ç§é¡ºåºè€Œä¸æ˜¯ç›¸åçš„é¡ºåºï¼Ÿå¦‚æœæˆ‘ä»¬äº¤æ¢å®ƒä»¬ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ˜¯å¦å¯ä»¥ä¸ºæ¯ä¸ª \(n\) é€‰æ‹©ä¸€ä¸ª \(c\)ï¼Ÿ
- en: Had we swapped the order, it would mean that for every point along the number
    line, there must exist a constantâ€”<wbr>and there pretty much always does! The
    swapped definition would therefore be useless. What is important is that we can
    identify the constant no matter how large the parameter gets. That is what makes
    this truly a constant.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬äº¤æ¢äº†é¡ºåºï¼Œè¿™æ„å‘³ç€å¯¹äºæ•°è½´ä¸Šçš„æ¯ä¸€ä¸ªç‚¹ï¼Œéƒ½å¿…é¡»å­˜åœ¨ä¸€ä¸ªå¸¸æ•°â€”â€”å®é™…ä¸Šï¼Œè¿™å‡ ä¹æ€»æ˜¯æˆç«‹çš„ï¼å› æ­¤ï¼Œäº¤æ¢åçš„å®šä¹‰å°†å˜å¾—æ¯«æ— ç”¨å¤„ã€‚é‡è¦çš„æ˜¯ï¼Œæ— è®ºå‚æ•°æœ‰å¤šå¤§ï¼Œæˆ‘ä»¬éƒ½èƒ½è¯†åˆ«å‡ºè¿™ä¸ªå¸¸æ•°ã€‚è¿™å°±æ˜¯å®ƒçœŸæ­£æˆä¸ºå¸¸æ•°çš„åŸå› ã€‚
- en: Observe that for a given function \(f\), there are numerous functions that are
    less than it. We use the notation \(O(\cdot)\) to describe this family of functions.In
    computer science this is usually pronounced â€œbig-Ohâ€, though some prefer to call
    it the Bachmann-Landau notation after its originators. Thus if \(g \leq f\), we
    can write \(g \in O(f)\), which we can read as â€œ\(f\) is an upper-bound for \(g\)â€.
    Thus, for instance,
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå¯¹äºç»™å®šçš„å‡½æ•° \(f\)ï¼Œå­˜åœ¨è®¸å¤šæ¯”å®ƒå°çš„å‡½æ•°ã€‚æˆ‘ä»¬ä½¿ç”¨ \(O(\cdot)\) ç¬¦å·æ¥æè¿°è¿™ä¸ªå‡½æ•°æ—ã€‚åœ¨è®¡ç®—æœºç§‘å­¦ä¸­ï¼Œè¿™é€šå¸¸è¯»ä½œâ€œå¤§-Oâ€ï¼Œå°½ç®¡æœ‰äº›äººæ›´å–œæ¬¢å°†å…¶ç§°ä¸ºå…¶åˆ›å§‹äºº
    Bachmann-Landau çš„ç¬¦å·ã€‚å› æ­¤ï¼Œå¦‚æœ \(g \leq f\)ï¼Œæˆ‘ä»¬å¯ä»¥å†™æˆ \(g \in O(f)\)ï¼Œæˆ‘ä»¬å¯ä»¥è¯»ä½œâ€œ\(f\) æ˜¯ \(g\)
    çš„ä¸Šç•Œâ€ã€‚å› æ­¤ï¼Œä¾‹å¦‚ï¼Œ
- en: \begin{equation*}[k \rightarrow 3k] \in O([k \rightarrow 4k+12])\end{equation*}
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}[k \rightarrow 3k] \in O([k \rightarrow 4k+12])\end{equation*}
- en: \begin{equation*}[k \rightarrow 4k+12] \in O([k \rightarrow k^2])\end{equation*}
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}[k \rightarrow 4k+12] \in O([k \rightarrow k^2])\end{equation*}
- en: and so on. Obviously, the â€œbiggerâ€ function is likely to be a less useful bound
    than a â€œtighterâ€ one. That said, it is conventional to write a â€œminimalâ€ bound
    for functions, which means avoiding unnecessary constants, sum terms, and so on.
    The justification for this is given below [[Combining Big-Oh Without Woe](#%28part._big-oh-closure%29)].
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥æ­¤ç±»æ¨ã€‚æ˜¾ç„¶ï¼Œâ€œæ›´å¤§â€çš„å‡½æ•°å¯èƒ½æ¯”â€œæ›´ç´§â€çš„å‡½æ•°ä½œä¸ºç•Œé™ä¸é‚£ä¹ˆæœ‰ç”¨ã€‚å°½ç®¡å¦‚æ­¤ï¼Œä¼ ç»Ÿä¸Šä¸ºå‡½æ•°å†™ä¸€ä¸ªâ€œæœ€å°â€ç•Œé™ï¼Œè¿™æ„å‘³ç€é¿å…ä¸å¿…è¦çš„å¸¸æ•°ã€æ±‚å’Œé¡¹ç­‰ã€‚è¿™ç§åšæ³•çš„åˆç†æ€§å°†åœ¨ä»¥ä¸‹éƒ¨åˆ†ç»™å‡º
    [[æ— çƒ¦æ¼åœ°åˆå¹¶å¤§-O](#(part._big-oh-closure))]ã€‚
- en: Pay especially close attention to our notation. We write \(\in\) rather than
    \(=\) or some other symbol, because \(O(f)\) describes a family of functions of
    which \(g\) is a member. We also write \(f\) rather than \(f(x)\) because we are
    comparing functionsâ€”<wbr>\(f\)â€”<wbr>rather than their values at particular pointsâ€”<wbr>\(f(x)\)â€”<wbr>which
    would be ordinary numbers! Most of the notation in most the books and Web sites
    suffers from one or both flaws. We know, however, that functions are values, and
    that functions can be anonymous. We have actually exploited both facts to be able
    to write
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ç‰¹åˆ«æ³¨æ„æˆ‘ä»¬çš„ç¬¦å·ã€‚æˆ‘ä»¬å†™ \(\in\) è€Œä¸æ˜¯ \(=\) æˆ–å…¶ä»–ç¬¦å·ï¼Œå› ä¸º \(O(f)\) æè¿°äº†ä¸€æ—å‡½æ•°ï¼Œå…¶ä¸­ \(g\) æ˜¯æˆå‘˜ä¹‹ä¸€ã€‚æˆ‘ä»¬ä¹Ÿå†™
    \(f\) è€Œä¸æ˜¯ \(f(x)\)ï¼Œå› ä¸ºæˆ‘ä»¬æ˜¯åœ¨æ¯”è¾ƒå‡½æ•°â€”â€”<wbr>\(f\)â€”â€”<wbr>è€Œä¸æ˜¯å®ƒä»¬åœ¨ç‰¹å®šç‚¹çš„å€¼â€”â€”<wbr>\(f(x)\)â€”<wbr>è¿™å°†æ˜¯æ™®é€šæ•°å­—ï¼å¤§å¤šæ•°ä¹¦ç±å’Œç½‘ç«™ä¸Šçš„å¤§å¤šæ•°ç¬¦å·éƒ½å­˜åœ¨ä¸€ä¸ªæˆ–ä¸¤ä¸ªç¼ºé™·ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬çŸ¥é“å‡½æ•°æ˜¯å€¼ï¼Œå‡½æ•°å¯ä»¥æ˜¯åŒ¿åçš„ã€‚æˆ‘ä»¬å®é™…ä¸Šåˆ©ç”¨äº†è¿™ä¸¤ä¸ªäº‹å®æ¥èƒ½å¤Ÿå†™å‡º
- en: \begin{equation*}[k \rightarrow 3k] \in O([k \rightarrow 4k+12])\end{equation*}
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}[k \rightarrow 3k] \in O([k \rightarrow 4k+12])\end{equation*}
- en: This is not the only notion of function comparison that we can have. For instance,
    given the definition of \(\leq\) above, we can define a natural relation \(<\).
    This then lets us ask, given a function \(f\), what are all the functions \(g\)
    such that \(g \leq f\) but not \(g < f\), i.e., those that are â€œequalâ€ to \(f\).Look
    out! We are using quotes because this is not the same as ordinary function equality,
    which is defined as the two functions giving the same answer on all inputs. Here,
    two â€œequalâ€ functions may not give the same answer on any inputs. This is the
    family of functions that are separated by at most a constant; when the functions
    indicate the order of growth of programs, â€œequalâ€ functions signify programs that
    grow at the same speed (up to constants). We use the notation \(\Theta(\cdot)\)
    to speak of this family of functions, so if \(g\) is equivalent to \(f\) by this
    notion, we can write \(g \in \Theta(f)\) (and it would then also be true that
    \(f \in \Theta(g)\)).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸æ˜¯æˆ‘ä»¬å¯ä»¥æ‹¥æœ‰çš„å”¯ä¸€å‡½æ•°æ¯”è¾ƒæ¦‚å¿µã€‚ä¾‹å¦‚ï¼Œç»™å®šä¸Šè¿°çš„ \(\leq\) å®šä¹‰ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªè‡ªç„¶å…³ç³» \(<\)ã€‚è¿™æ ·ï¼Œæˆ‘ä»¬å°±å¯ä»¥é—®ï¼Œç»™å®šä¸€ä¸ªå‡½æ•°
    \(f\)ï¼Œæ‰€æœ‰æ»¡è¶³ \(g \leq f\) ä½†ä¸æ»¡è¶³ \(g < f\) çš„å‡½æ•° \(g\) æ˜¯ä»€ä¹ˆï¼Œå³é‚£äº›â€œç­‰äºâ€ \(f\) çš„å‡½æ•°ã€‚æ³¨æ„ï¼æˆ‘ä»¬ä½¿ç”¨å¼•å·ï¼Œå› ä¸ºè¿™ä¸åŒäºæ™®é€šå‡½æ•°çš„ç­‰ä»·æ€§ï¼Œæ™®é€šå‡½æ•°çš„ç­‰ä»·æ€§å®šä¹‰ä¸ºåœ¨æ‰€æœ‰è¾“å…¥ä¸Šç»™å‡ºç›¸åŒç­”æ¡ˆçš„ä¸¤ä¸ªå‡½æ•°ã€‚åœ¨è¿™é‡Œï¼Œä¸¤ä¸ªâ€œç›¸ç­‰â€çš„å‡½æ•°å¯èƒ½åœ¨ä»»ä½•è¾“å…¥ä¸Šéƒ½ä¸ç»™å‡ºç›¸åŒç­”æ¡ˆã€‚è¿™æ˜¯ç”±æœ€å¤šä¸€ä¸ªå¸¸æ•°åˆ†éš”çš„å‡½æ•°æ—ï¼›å½“å‡½æ•°è¡¨ç¤ºç¨‹åºçš„é˜¶å¢é•¿æ—¶ï¼Œâ€œç›¸ç­‰â€çš„å‡½æ•°è¡¨ç¤ºä»¥ç›¸åŒé€Ÿåº¦ï¼ˆæœ€å¤šå¸¸æ•°ï¼‰å¢é•¿çš„ç¨‹åºã€‚æˆ‘ä»¬ä½¿ç”¨ç¬¦å·
    \(\Theta(\cdot)\) æ¥è°ˆè®ºè¿™ä¸ªå‡½æ•°æ—ï¼Œæ‰€ä»¥å¦‚æœ \(g\) é€šè¿‡è¿™ä¸ªæ¦‚å¿µä¸ \(f\) ç­‰ä»·ï¼Œæˆ‘ä»¬å¯ä»¥å†™ \(g \in \Theta(f)\)ï¼ˆå¹¶ä¸”é‚£æ—¶
    \(f \in \Theta(g)\) ä¹Ÿæˆç«‹ï¼‰ã€‚
- en: Exercise
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Convince yourself that this notion of function equality is an equivalence relation,
    and hence worthy of the name â€œequalâ€. It needs to be (a) reflexive (i.e., every
    function is related to itself); (b) antisymmetric (if \(f \leq g\) and \(g \leq
    f\) then \(f\) and \(g\) are equal); and (c) transitive (\(f \leq g\) and \(g
    \leq h\) implies \(f \leq h\)).
  id: totrans-336
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¯´æœè‡ªå·±è¿™ä¸ªå‡½æ•°ç­‰ä»·æ€§çš„æ¦‚å¿µæ˜¯ä¸€ä¸ªç­‰ä»·å…³ç³»ï¼Œå› æ­¤å€¼å¾—ç§°ä¸ºâ€œç­‰ä»·â€ã€‚å®ƒéœ€è¦æ˜¯ï¼ˆaï¼‰è‡ªåçš„ï¼ˆå³ï¼Œæ¯ä¸ªå‡½æ•°éƒ½ä¸è‡ªèº«ç›¸å…³ï¼‰ï¼›ï¼ˆbï¼‰åå¯¹ç§°çš„ï¼ˆå¦‚æœ \(f \leq
    g\) ä¸” \(g \leq f\)ï¼Œåˆ™ \(f\) å’Œ \(g\) æ˜¯ç›¸ç­‰çš„ï¼‰ï¼›ï¼ˆcï¼‰ä¼ é€’çš„ï¼ˆ\(f \leq g\) å’Œ \(g \leq h\) æ„å‘³ç€
    \(f \leq h\)ï¼‰ã€‚
- en: 14.9Â Combining Big-Oh Without Woe[ğŸ”—](#(part._big-oh-closure) "Link to here")
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.9 æ— å¿§ç»“åˆå¤§O[ğŸ”—](#(part._big-oh-closure) "é“¾æ¥è‡³æ­¤")
- en: 'Now that weâ€™ve introduced this notation, we should inquire about its closure
    properties: namely, how do these families of functions combine? To nudge your
    intuitions, assume that in all cases weâ€™re discussing the running time of functions.
    Weâ€™ll consider three cases:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»å¼•å…¥äº†è¿™ä¸ªç¬¦å·ï¼Œæˆ‘ä»¬åº”è¯¥æ¢ç©¶å®ƒçš„é—­åŒ…æ€§è´¨ï¼šå³è¿™äº›å‡½æ•°æ—æ˜¯å¦‚ä½•ç»„åˆçš„ï¼Ÿä¸ºäº†å¼•å¯¼ä½ çš„ç›´è§‰ï¼Œå‡è®¾åœ¨æ‰€æœ‰æƒ…å†µä¸‹æˆ‘ä»¬éƒ½åœ¨è®¨è®ºå‡½æ•°çš„è¿è¡Œæ—¶é—´ã€‚æˆ‘ä»¬å°†è€ƒè™‘ä¸‰ç§æƒ…å†µï¼š
- en: 'Suppose we have a function `f` (whose running time is) in \(O(F)\). Letâ€™s say
    we run it \(p\) times, for some given constant. The running time of the resulting
    code is then \(p \times O(F)\). However, observe that this is really no different
    from \(O(F)\): we can simply use a bigger constant for \(c\) in the definition
    of \(O(\cdot)\)â€”<wbr>in particular, we can just use \(pc\). Conversely, then,
    \(O(pF)\) is equivalent to \(O(F)\). This is the heart of the intution that â€œmultiplicative
    constants donâ€™t matterâ€.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªå‡½æ•° `f`ï¼ˆå…¶è¿è¡Œæ—¶é—´æ˜¯ï¼‰åœ¨ \(O(F)\) å†…ã€‚å‡è®¾æˆ‘ä»¬è¿è¡Œå®ƒ \(p\) æ¬¡ï¼Œå¯¹äºæŸä¸ªç»™å®šçš„å¸¸æ•°ã€‚é‚£ä¹ˆï¼Œäº§ç”Ÿçš„ä»£ç çš„è¿è¡Œæ—¶é—´å°±æ˜¯
    \(p \times O(F)\)ã€‚ç„¶è€Œï¼Œè¯·æ³¨æ„ï¼Œè¿™å®é™…ä¸Šä¸ \(O(F)\) æ²¡æœ‰åŒºåˆ«ï¼šæˆ‘ä»¬åªéœ€åœ¨ \(O(\cdot)\) çš„å®šä¹‰ä¸­ä½¿ç”¨æ›´å¤§çš„å¸¸æ•° \(c\)â€”â€”<wbr>ç‰¹åˆ«æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨
    \(pc\)ã€‚åè¿‡æ¥ï¼Œé‚£ä¹ˆï¼Œ\(O(pF)\) ç­‰ä»·äº \(O(F)\)ã€‚è¿™æ­£æ˜¯â€œä¹˜æ³•å¸¸æ•°æ— å…³ç´§è¦â€è¿™ä¸€ç›´è§‰çš„æ ¸å¿ƒã€‚
- en: Suppose we have two functions, `f` in \(O(F)\) and `g` in \(O(G)\). If we run
    `f` followed by `g`, we would expect the running time of the combination to be
    the sum of their individual running times, i.e., \(O(F) + O(G)\). You should convince
    yourself that this is simply \(O(max(F, G))\).
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬æœ‰ä¸¤ä¸ªå‡½æ•°ï¼Œ`f` åœ¨ \(O(F)\) ä¸­ï¼Œ`g` åœ¨ \(O(G)\) ä¸­ã€‚å¦‚æœæˆ‘ä»¬å…ˆè¿è¡Œ `f`ï¼Œç„¶åè¿è¡Œ `g`ï¼Œæˆ‘ä»¬é¢„è®¡ç»„åˆçš„è¿è¡Œæ—¶é—´æ˜¯å®ƒä»¬å„è‡ªè¿è¡Œæ—¶é—´çš„æ€»å’Œï¼Œå³
    \(O(F) + O(G)\)ã€‚ä½ åº”è¯¥ç¡®ä¿¡è¿™ä»…ä»…æ˜¯ \(O(max(F, G))\)ã€‚
- en: Suppose we have two functions, `f` in \(O(F)\) and `g` in \(O(G)\). If `f` invokes
    `g` in each of its steps, we would expect the running time of the combination
    to be the product of their individual running times, i.e., \(O(F) \times O(G)\).
    You should convince yourself that this is simply \(O(F \times G)\).
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬æœ‰ä¸¤ä¸ªå‡½æ•°ï¼Œ`f` åœ¨ \(O(F)\) ä¸­ï¼Œ`g` åœ¨ \(O(G)\) ä¸­ã€‚å¦‚æœ `f` åœ¨æ¯ä¸€æ­¥éƒ½è°ƒç”¨ `g`ï¼Œæˆ‘ä»¬é¢„è®¡ç»„åˆçš„è¿è¡Œæ—¶é—´æ˜¯å®ƒä»¬å„è‡ªè¿è¡Œæ—¶é—´çš„ä¹˜ç§¯ï¼Œå³
    \(O(F) \times O(G)\)ã€‚ä½ åº”è¯¥ç¡®ä¿¡è¿™ä»…ä»…æ˜¯ \(O(F \times G)\)ã€‚
- en: 'These three operationsâ€”<wbr>addition, multiplication by a constant, and multiplication
    by a functionâ€”<wbr>cover just about all the cases.To ensure that the table fits
    in a reasonable width, we will abuse notation. For instance, we can use this to
    reinterpret the [tabular operations](#%28elem._length-cost-table%29) above (assuming
    everything is a function of \(k\)):'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸‰ç§æ“ä½œâ€”â€”<wbr>åŠ æ³•ã€ä¹˜ä»¥å¸¸æ•°å’Œä¹˜ä»¥å‡½æ•°â€”â€”<wbr>æ¶µç›–äº†å‡ ä¹æ‰€æœ‰çš„æƒ…å†µã€‚ä¸ºäº†ç¡®ä¿è¡¨æ ¼é€‚åˆåˆç†çš„å®½åº¦ï¼Œæˆ‘ä»¬å°†æ»¥ç”¨ç¬¦å·ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨è¿™ä¸ªæ¥é‡æ–°è§£é‡Šä¸Šé¢çš„
    [è¡¨æ ¼æ“ä½œ](#%28elem._length-cost-table%29)ï¼ˆå‡è®¾ä¸€åˆ‡éƒ½æ˜¯ \(k\) çš„å‡½æ•°ï¼‰ï¼š
- en: '| &#124;Q&#124; |  | #Q |  | TotQ |  | &#124;A&#124; |  | #A |  | TotA |  |
    Total |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| &#124;Q&#124; |  | #Q |  | TotQ |  | &#124;A&#124; |  | #A |  | TotA |  |
    Total |'
- en: '| \(O(1)\) |  | \(O(k)\) |  | \(O(k)\) |  | \(O(1)\) |  | \(O(1)\) |  | \(O(1)\)
    |  | \(O(k)\) |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| \(O(1)\) |  | \(O(k)\) |  | \(O(k)\) |  | \(O(1)\) |  | \(O(1)\) |  | \(O(1)\)
    |  | \(O(k)\) |'
- en: '| \(O(1)\) |  | \(O(k)\) |  | \(O(k)\) |  | \(O(1)\) |  | \(O(k)\) |  | \(O(k)\)
    |  | \(O(k)\) |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| \(O(1)\) |  | \(O(k)\) |  | \(O(k)\) |  | \(O(1)\) |  | \(O(k)\) |  | \(O(k)\)
    |  | \(O(k)\) |'
- en: 'Because multiplication by constants doesnâ€™t matter, we can replace the \(3\)
    with \(1\). Because addition of a constant doesnâ€™t matter (run the addition rule
    in reverse), \(k+1\) can become \(k\). Adding this gives us \(O(k) + O(k) = 2
    \times O(k) \in O(k)\). This justifies claiming that running `len` on a \(k\)-element
    list takes time in \(O([k \rightarrow k])\), which is a much simpler way of describing
    its bound than \(O([k \rightarrow 11k + 4])\). In particular, it provides us with
    the essential information and nothing else: as the input (list) grows, the running
    time grows proportional to it, i.e., if we add one more element to the input,
    we should expect to add a constant more of time to the running time.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºå¸¸æ•°ä¹˜æ³•å¹¶ä¸é‡è¦ï¼Œæˆ‘ä»¬å¯ä»¥å°† \(3\) æ›¿æ¢ä¸º \(1\)ã€‚ç”±äºå¸¸æ•°åŠ æ³•å¹¶ä¸é‡è¦ï¼ˆåå‘è¿è¡ŒåŠ æ³•è§„åˆ™ï¼‰ï¼Œ\(k+1\) å¯ä»¥å˜ä¸º \(k\)ã€‚åŠ ä¸Šè¿™äº›ï¼Œæˆ‘ä»¬å¾—åˆ°
    \(O(k) + O(k) = 2 \times O(k) \in O(k)\)ã€‚è¿™è¯æ˜äº†åœ¨ \(k\) å…ƒç´ åˆ—è¡¨ä¸Šè¿è¡Œ `len` æ‰€éœ€çš„æ—¶é—´æ˜¯ \(O([k
    \rightarrow k])\)ï¼Œè¿™æ˜¯ä¸€ç§æ¯” \(O([k \rightarrow 11k + 4])\) æ›´ç®€å•çš„æè¿°å…¶ç•Œé™çš„æ–¹æ³•ã€‚ç‰¹åˆ«æ˜¯ï¼Œå®ƒä¸ºæˆ‘ä»¬æä¾›äº†å¿…è¦çš„ä¿¡æ¯ï¼Œè€Œæ²¡æœ‰å…¶ä»–ä¿¡æ¯ï¼šéšç€è¾“å…¥ï¼ˆåˆ—è¡¨ï¼‰çš„å¢é•¿ï¼Œè¿è¡Œæ—¶é—´ä¹Ÿæˆæ¯”ä¾‹å¢é•¿ï¼Œå³å¦‚æœæˆ‘ä»¬å‘è¾“å…¥æ·»åŠ ä¸€ä¸ªå…ƒç´ ï¼Œæˆ‘ä»¬åº”è¯¥é¢„æœŸè¿è¡Œæ—¶é—´å¢åŠ ä¸€ä¸ªå¸¸æ•°ã€‚
- en: 14.10Â Solving Recurrences[ğŸ”—](#(part._solving-recurrences) "Link to here")
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.10 æ±‚è§£é€’å½’[ğŸ”—](#(part._solving-recurrences) "é“¾æ¥è‡³æ­¤")
- en: There is a great deal of literature on solving recurrence equations. In this
    section we wonâ€™t go into general techniques, nor will we even discuss very many
    different recurrences. Rather, weâ€™ll focus on just a handful that should be in
    the repertoire of every computer scientist. Youâ€™ll see these over and over, so
    you should instinctively recognize their recurrence pattern and know what complexity
    they describe (or know how to quickly derive it).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: å…³äºæ±‚è§£é€’å½’æ–¹ç¨‹çš„æ–‡çŒ®éå¸¸ä¸°å¯Œã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬ä¸ä¼šæ·±å…¥æ¢è®¨ä¸€èˆ¬æŠ€æœ¯ï¼Œç”šè‡³ä¸ä¼šè®¨è®ºå¾ˆå¤šä¸åŒçš„é€’å½’æ–¹ç¨‹ã€‚ç›¸åï¼Œæˆ‘ä»¬å°†ä¸“æ³¨äºä»…æœ‰çš„å‡ ç±»åº”è¯¥åŒ…å«åœ¨æ¯ä¸ªè®¡ç®—æœºç§‘å­¦å®¶æŠ€èƒ½åº“ä¸­çš„é€’å½’æ–¹ç¨‹ã€‚ä½ å°†åå¤é‡åˆ°è¿™äº›æ–¹ç¨‹ï¼Œå› æ­¤ä½ åº”è¯¥æœ¬èƒ½åœ°è¯†åˆ«å®ƒä»¬çš„é€’å½’æ¨¡å¼ï¼Œå¹¶äº†è§£å®ƒä»¬æè¿°çš„å¤æ‚åº¦ï¼ˆæˆ–è€…çŸ¥é“å¦‚ä½•å¿«é€Ÿæ¨å¯¼å®ƒï¼‰ã€‚
- en: 'Earlier we saw a recurrence that had two cases: one for the empty input and
    one for all others. In general, we should expect to find one case for each non-recursive
    call and one for each recursive one, i.e., roughly one per `cases` clause. In
    what follows, we will ignore the base cases so long as the size of the input is
    constant (such as zero or one), because in such cases the amount of work done
    will also be a constant, which we can generally ignore [[Comparing Functions](#%28part._big-oh-def%29)].'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹‹å‰æˆ‘ä»¬çœ‹åˆ°äº†ä¸€ä¸ªæœ‰ä¸¤ä¸ªæƒ…å†µçš„é€’å½’æ–¹ç¨‹ï¼šä¸€ä¸ªç”¨äºç©ºè¾“å…¥ï¼Œå¦ä¸€ä¸ªç”¨äºæ‰€æœ‰å…¶ä»–æƒ…å†µã€‚ä¸€èˆ¬æ¥è¯´ï¼Œæˆ‘ä»¬åº”è¯¥æœŸæœ›å¯¹äºæ¯ä¸ªéé€’å½’è°ƒç”¨æ‰¾åˆ°ä¸€ä¸ªæƒ…å†µï¼Œå¯¹äºæ¯ä¸ªé€’å½’è°ƒç”¨æ‰¾åˆ°ä¸€ä¸ªæƒ…å†µï¼Œå³å¤§çº¦æ¯ä¸ª
    `cases` å­å¥ä¸€ä¸ªã€‚åœ¨ä»¥ä¸‹å†…å®¹ä¸­ï¼Œåªè¦è¾“å…¥çš„å¤§å°æ˜¯å¸¸æ•°ï¼ˆå¦‚é›¶æˆ–ä¸€ï¼‰ï¼Œæˆ‘ä»¬å°†å¿½ç•¥åŸºæœ¬æ¡ˆä¾‹ï¼Œå› ä¸ºåœ¨è¿™äº›æƒ…å†µä¸‹æ‰€åšçš„å·¥ä½œé‡ä¹Ÿå°†æ˜¯å¸¸æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ä¸€èˆ¬åœ°å¿½ç•¥ [[æ¯”è¾ƒå‡½æ•°](#%28part._big-oh-def%29)]ã€‚
- en: '| \(T(k)\) | = | \(T(k-1) + c\) |'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_TB
  zh: '| \(T(k)\) | = | \(T(k-1) + c\) |'
- en: '|  | = | \(T(k-2) + c + c\) |'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(k-2) + c + c\) |'
- en: '|  | = | \(T(k-3) + c + c + c\) |'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(k-3) + c + c + c\) |'
- en: '|  | = | ... |'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | ... |'
- en: '|  | = | \(T(0) + c \times k\) |'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(0) + c \times k\) |'
- en: '|  | = | \(c_0 + c \times k\) |'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(c_0 + c \times k\) |'
- en: Thus \(T \in O([k \rightarrow k])\). Intuitively, we do a constant amount of
    work (\(c\)) each time we throw away one element (\(k-1\)), so we do a linear
    amount of work overall.
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å› æ­¤ \(T \in O([k \rightarrow k])\). ç›´è§‚åœ°è¯´ï¼Œæ¯æ¬¡æˆ‘ä»¬ä¸¢å¼ƒä¸€ä¸ªå…ƒç´  (\(k-1\)) æ—¶ï¼Œæˆ‘ä»¬éƒ½ä¼šåšå¸¸æ•°å·¥ä½œé‡ (\(c\))ï¼Œæ‰€ä»¥æ€»ä½“ä¸Šæˆ‘ä»¬åšäº†çº¿æ€§å·¥ä½œé‡ã€‚
- en: '| \(T(k)\) | = | \(T(k-1) + k\) |'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_TB
  zh: '| \(T(k)\) | = | \(T(k-1) + k\) |'
- en: '|  | = | \(T(k-2) + (k-1) + k\) |'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(k-2) + (k-1) + k\) |'
- en: '|  | = | \(T(k-3) + (k-2) + (k-1) + k\) |'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(k-3) + (k-2) + (k-1) + k\) |'
- en: '|  | = | ... |'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | ... |'
- en: '|  | = | \(T(0) + (k-(k-1)) + (k-(k-2)) + \cdots + (k-2) + (k-1) + k\) |'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(0) + (k-(k-1)) + (k-(k-2)) + \cdots + (k-2) + (k-1) + k\) |'
- en: '|  | = | \(c_0 + 1 + 2 + \cdots + (k-2) + (k-1) + k\) |'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(c_0 + 1 + 2 + \cdots + (k-2) + (k-1) + k\) |'
- en: '|  | = | \(c_0 + {\frac{k \cdot (k+1)}{2}}\) |'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(c_0 + {\frac{k \cdot (k+1)}{2}}\) |'
- en: Thus \(T \in O([k \rightarrow k^2])\). This follows from the solution to the
    sum of the first \(k\) numbers. We call algorithms that have this running time
    quadratic algorithms.One of the hardest algorithmic problems in programming software
    is to avoid making programs [accidentally quadratic](https://accidentallyquadratic.tumblr.com/).
    As you can see, even serious, professional software falls into this trap, and
    it affects real sytems, even bringing them down.
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å› æ­¤ \(T \in O([k \rightarrow k^2])\). è¿™æ˜¯ä»å‰ \(k\) ä¸ªæ•°çš„å’Œçš„è§£ä¸­å¾—å‡ºçš„ã€‚æˆ‘ä»¬ç§°å…·æœ‰è¿™ç§è¿è¡Œæ—¶é—´çš„ç®—æ³•ä¸ºäºŒæ¬¡ç®—æ³•ã€‚åœ¨ç¼–ç¨‹è½¯ä»¶ä¸­ï¼Œé¿å…ç¨‹åº[æ„å¤–åœ°æˆä¸ºäºŒæ¬¡çš„](https://accidentallyquadratic.tumblr.com/)æ˜¯ç®—æ³•ä¸­ä¸€ä¸ªæœ€å›°éš¾çš„é—®é¢˜ä¹‹ä¸€ã€‚æ­£å¦‚ä½ æ‰€è§ï¼Œå³ä½¿æ˜¯ä¸¥è‚ƒçš„ä¸“ä¸šè½¯ä»¶ä¹Ÿå¯èƒ½é™·å…¥è¿™ä¸ªé™·é˜±ï¼Œå®ƒä¼šå½±å“çœŸå®ç³»ç»Ÿï¼Œç”šè‡³å¯èƒ½ä½¿å®ƒä»¬å´©æºƒã€‚
- en: 'We can also view this recurrence geometrically. Imagine each x below refers
    to a unit of work, and we start with \(k\) of them. Then the first row has \(k\)
    units of work:'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¹Ÿå¯ä»¥ä»å‡ ä½•çš„è§’åº¦çœ‹å¾…è¿™ä¸ªé€’å½’ã€‚æƒ³è±¡æ¯ä¸ªä¸‹é¢çš„ x éƒ½ä»£è¡¨ä¸€ä¸ªå·¥ä½œé‡å•ä½ï¼Œæˆ‘ä»¬å¼€å§‹æ—¶æœ‰ \(k\) ä¸ªã€‚ç„¶åç¬¬ä¸€è¡Œæœ‰ \(k\) ä¸ªå·¥ä½œé‡å•ä½ï¼š
- en: '| xxxxxxxx |'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxxxxxxx |'
- en: 'followed by the recurrence on \(k-1\) of them:'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ç„¶åæ˜¯å…³äº \(k-1\) çš„é€’å½’ï¼š
- en: '| xxxxxxx |'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxxxxxx |'
- en: 'which is followed by another recurrence on one smaller, and so on, until we
    fill end up with:'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: è¿™éšåæ˜¯å¦ä¸€ä¸ªå…³äºè¾ƒå°è§„æ¨¡çš„é€’å½’ï¼Œä»¥æ­¤ç±»æ¨ï¼Œç›´åˆ°æˆ‘ä»¬æœ€ç»ˆå¾—åˆ°ï¼š
- en: '| xxxxxxxx |'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxxxxxxx |'
- en: '| xxxxxxx |'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxxxxxx |'
- en: '| xxxxxx |'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxxxxx |'
- en: '| xxxxx |'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxxxx |'
- en: '| xxxx |'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxxx |'
- en: '| xxx |'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxx |'
- en: '| xx |'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xx |'
- en: '| x |'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| x |'
- en: 'The total work is then essentially the area of this triangle, whose base and
    height are both \(k\): or, if you prefer, half of this \(k \times k\) square:'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: æ€»å·¥ä½œé‡å®é™…ä¸Šæ˜¯è¿™ä¸ªä¸‰è§’å½¢çš„é¢ç§¯ï¼Œå…¶åº•è¾¹å’Œé«˜åº¦éƒ½æ˜¯ \(k\)ï¼šæˆ–è€…ï¼Œå¦‚æœä½ æ›´å–œæ¬¢ï¼Œæ˜¯ \(k \times k\) æ­£æ–¹å½¢çš„ä¸€åŠï¼š
- en: '| xxxxxxxx |'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxxxxxxx |'
- en: '| xxxxxxx. |'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxxxxxx. |'
- en: '| xxxxxx.. |'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxxxxx.. |'
- en: '| xxxxx... |'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxxxx... |'
- en: '| xxxx.... |'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxxx.... |'
- en: '| xxx..... |'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xxx..... |'
- en: '| xx...... |'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| xx...... |'
- en: '| x....... |'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| x....... |'
- en: Similar geometric arguments can be made for all these recurrences.
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å¯¹äºæ‰€æœ‰è¿™äº›é€’å½’ï¼Œéƒ½å¯ä»¥è¿›è¡Œç±»ä¼¼çš„å‡ ä½•è®ºè¯ã€‚
- en: '| \(T(k)\) | = | \(T(k/2) + c\) |'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_TB
  zh: '| \(T(k)\) | = | \(T(k/2) + c\) |'
- en: '|  | = | \(T(k/4) + c + c\) |'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(k/4) + c + c\) |'
- en: '|  | = | \(T(k/8) + c + c + c\) |'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(k/8) + c + c + c\) |'
- en: '|  | = | ... |'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | ... |'
- en: '|  | = | \(T(k/2^{\log_2 k}) + c \cdot \log_2 k\) |'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(k/2^{\log_2 k}) + c \cdot \log_2 k\) |'
- en: '|  | = | \(c_1 + c \cdot \log_2 k\) |'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(c_1 + c \cdot \log_2 k\) |'
- en: Thus \(T \in O([k \rightarrow \log k])\). Intuitively, weâ€™re able to do only
    constant work (\(c\)) at each level, then throw away half the input. In a logarithmic
    number of steps we will have exhausted the input, having done only constant work
    each time. Thus the overall complexity is logarithmic.
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å› æ­¤ \(T \in O([k \rightarrow \log k])\). ç›´è§‚åœ°è¯´ï¼Œæˆ‘ä»¬åœ¨æ¯ä¸ªçº§åˆ«ä¸Šåªèƒ½åšå¸¸æ•°å·¥ä½œé‡ (\(c\))ï¼Œç„¶åä¸¢å¼ƒä¸€åŠçš„è¾“å…¥ã€‚åœ¨ä»¥å¯¹æ•°æ•°é‡çº§çš„æ­¥éª¤ä¸­ï¼Œæˆ‘ä»¬å°†è€—å°½è¾“å…¥ï¼Œæ¯æ¬¡åªåšå¸¸æ•°å·¥ä½œé‡ã€‚å› æ­¤ï¼Œæ•´ä½“å¤æ‚åº¦æ˜¯å¯¹æ•°çš„ã€‚
- en: '| \(T(k)\) | = | \(T(k/2) + k\) |'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_TB
  zh: '| \(T(k)\) | = | \(T(k/2) + k\) |'
- en: '|  | = | \(T(k/4) + k/2 + k\) |'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(k/4) + k/2 + k\) |'
- en: '|  | = | ... |'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | ... |'
- en: '|  | = | \(T(1) + k/2^{\log_2 k} + \cdots + k/4 + k/2 + k\) |'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(1) + k/2^{\log_2 k} + \cdots + k/4 + k/2 + k\) |'
- en: '|  | = | \(c_1 + k(1/2^{\log_2 k} + \cdots + 1/4 + 1/2 + 1)\) |'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(c_1 + k(1/2^{\log_2 k} + \cdots + 1/4 + 1/2 + 1)\) |'
- en: '|  | = | \(c_1 + 2k\) |'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(c_1 + 2k\) |'
- en: Thus \(T \in O([k \rightarrow k])\). Intuitively, the first time your process
    looks at all the elements, the second time it looks at half of them, the third
    time a quarter, and so on. This kind of successive halving is equivalent to scanning
    all the elements in the input a second time. Hence this results in a linear process.
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å› æ­¤ \(T \in O([k \rightarrow k])\). ç›´è§‚åœ°è¯´ï¼Œç¬¬ä¸€æ¬¡ä½ çš„è¿‡ç¨‹æŸ¥çœ‹æ‰€æœ‰å…ƒç´ ï¼Œç¬¬äºŒæ¬¡æŸ¥çœ‹å…¶ä¸­çš„ä¸€åŠï¼Œç¬¬ä¸‰æ¬¡æŸ¥çœ‹å››åˆ†ä¹‹ä¸€ï¼Œä»¥æ­¤ç±»æ¨ã€‚è¿™ç§è¿ç»­å‡åŠç›¸å½“äºå†æ¬¡æ‰«æè¾“å…¥ä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚å› æ­¤ï¼Œè¿™å¯¼è‡´äº†ä¸€ä¸ªçº¿æ€§è¿‡ç¨‹ã€‚
- en: '| \(T(k)\) | = | \(2T(k/2) + k\) |'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_TB
  zh: '| \(T(k)\) | = | \(2T(k/2) + k\) |'
- en: '|  | = | \(2(2T(k/4) + k/2) + k\) |'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(2(2T(k/4) + k/2) + k\) |'
- en: '|  | = | \(4T(k/4) + k + k\) |'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(4T(k/4) + k + k\) |'
- en: '|  | = | \(4(2T(k/8) + k/4) + k + k\) |'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(4(2T(k/8) + k/4) + k + k\) |'
- en: '|  | = | \(8T(k/8) + k + k + k\) |'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(8T(k/8) + k + k + k\) |'
- en: '|  | = | ... |'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | ... |'
- en: '|  | = | \(2^{\log_2 k} T(1) + k \cdot \log_2 k\) |'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(2^{\log_2 k} T(1) + k \cdot \log_2 k\) |'
- en: '|  | = | \(k \cdot c_1 + k \cdot \log_2 k\) |'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(k \cdot c_1 + k \cdot \log_2 k\) |'
- en: Thus \(T \in O([k \rightarrow k \cdot \log k])\). Intuitively, each time weâ€™re
    processing all the elements in each recursive call (the \(k\)) as well as decomposing
    into two half sub-problems. This decomposition gives us a recursion tree of logarithmic
    height, at each of which levels weâ€™re doing linear work.
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å› æ­¤ \(T \in O([k \rightarrow k \cdot \log k])\)ã€‚ç›´è§‚ä¸Šï¼Œæ¯æ¬¡æˆ‘ä»¬éƒ½åœ¨å¤„ç†æ¯ä¸ªé€’å½’è°ƒç”¨ä¸­çš„æ‰€æœ‰å…ƒç´ ï¼ˆå³ \(k\)ï¼‰ï¼ŒåŒæ—¶å°†å…¶åˆ†è§£ä¸ºä¸¤ä¸ªå­é—®é¢˜ã€‚è¿™ç§åˆ†è§£ç»™æˆ‘ä»¬ä¸€ä¸ªå¯¹æ•°é«˜åº¦çš„é€’å½’æ ‘ï¼Œåœ¨æ¯ä¸€å±‚æˆ‘ä»¬éƒ½åœ¨è¿›è¡Œçº¿æ€§å·¥ä½œã€‚
- en: '| \(T(k)\) | = | \(2T(k-1) + c\) |'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_TB
  zh: '| \(T(k)\) | = | \(2T(k-1) + c\) |'
- en: '|  | = | \(2T(k-1) + (2-1)c\) |'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(2T(k-1) + (2-1)c\) |'
- en: '|  | = | \(2(2T(k-2) + c) + (2-1)c\) |'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(2(2T(k-2) + c) + (2-1)c\) |'
- en: '|  | = | \(4T(k-2) + 3c\) |'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(4T(k-2) + 3c\) |'
- en: '|  | = | \(4T(k-2) + (4-1)c\) |'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(4T(k-2) + (4-1)c\) |'
- en: '|  | = | \(4(2T(k-3) + c) + (4-1)c\) |'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(4(2T(k-3) + c) + (4-1)c\) |'
- en: '|  | = | \(8T(k-3) + 7c\) |'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(8T(k-3) + 7c\) |'
- en: '|  | = | \(8T(k-3) + (8-1)c\) |'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(8T(k-3) + (8-1)c\) |'
- en: '|  | = | ... |'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | ... |'
- en: '|  | = | \(2^k T(0) + (2^k-1)c\) |'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(2^k T(0) + (2^k-1)c\) |'
- en: Thus \(T \in O([k \rightarrow 2^k])\). Disposing of each element requires doing
    a constant amount of work for it and then doubling the work done on the rest.
    This successive doubling leads to the exponential.
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å› æ­¤ \(T \in O([k \rightarrow 2^k])\)ã€‚å¤„ç†æ¯ä¸ªå…ƒç´ éœ€è¦ä¸ºå…¶æ‰§è¡Œä¸€ä¸ªå¸¸é‡å·¥ä½œé‡ï¼Œç„¶åå°†å…¶ä½™å·¥ä½œé‡åŠ å€ã€‚è¿™ç§è¿ç»­åŠ å€å¯¼è‡´æŒ‡æ•°å¢é•¿ã€‚
- en: Exercise
  id: totrans-422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-423
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using induction, prove each of the above derivations.
  id: totrans-424
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨å½’çº³æ³•ï¼Œè¯æ˜ä¸Šè¿°æ¯ä¸ªæ¨å¯¼ã€‚
