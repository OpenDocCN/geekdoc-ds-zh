- en: Inertia Term
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 惯性项
- en: 原文：[https://phys-sim-book.github.io/lec4.2-inertia.html](https://phys-sim-book.github.io/lec4.2-inertia.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://phys-sim-book.github.io/lec4.2-inertia.html](https://phys-sim-book.github.io/lec4.2-inertia.html)
- en: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
- en: 'For the inertia term, with \(\tilde{x}^n = x^n + h v^n\), we have \[ E_I(x)
    = \frac{1}{2}\|x - \tilde{x}^n \|_M^2, \quad \nabla E_I(x) = M(x - \tilde{x}^n),
    \quad \text{and} \quad \nabla^2 E_I(x) = M, \] which is straightforward to implement:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于惯性项，给定 \(\tilde{x}^n = x^n + h v^n\)，我们有 \[ E_I(x) = \frac{1}{2}\|x - \tilde{x}^n
    \|_M^2, \quad \nabla E_I(x) = M(x - \tilde{x}^n), \quad \text{and} \quad \nabla^2
    E_I(x) = M, \] 这一点易于实现：
- en: '**Implementation 4.2.1 (InertiaEnergy.py).**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现 4.2.1 (InertiaEnergy.py)**。'
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The functions `val()`, `grad()`, and `hess()` are designed to compute different
    components of the inertia term. Specifically:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`val()`、`grad()`和`hess()`被设计用来计算惯性项的不同组成部分。具体来说：
- en: '`val()`: Computes the value of the inertia term.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`val()`: 计算惯性项的值。'
- en: '`grad()`: Calculates the gradient of the inertia term.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grad()`: 计算惯性项的梯度。'
- en: '`hess()`: Determines the Hessian of the inertia term.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hess()`: 确定惯性项的Hessian矩阵。'
- en: 'Regarding the Hessian matrix, a memory-efficient approach is employed. Rather
    than allocating a large two-dimensional array to store all entries of the Hessian
    matrix, only the nonzero entries are kept. This is achieved using the `IJV` structure,
    which consists of three lists:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Hessian矩阵，采用了一种内存高效的策略。而不是分配一个大的二维数组来存储Hessian矩阵的所有条目，只保留非零条目。这是通过使用由三个列表组成的`IJV`结构实现的：
- en: '**Row Index**: Identifies the row position of each nonzero entry.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**行索引**：标识每个非零条目的行位置。'
- en: '**Column Index**: Indicates the column position of each nonzero entry.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**列索引**：指示每个非零条目的列位置。'
- en: '**Value**: The actual nonzero value at the specified row and column.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**值**：在指定行和列的实际非零值。'
- en: This method significantly reduces memory usage and computational costs associated
    with downstream processing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法显著降低了与下游处理相关的内存使用和计算成本。
