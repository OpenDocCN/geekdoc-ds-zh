- en: <title>Ray Tracing in One Weekend</title>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <title>一个周末的光线追踪</title>
- en: Ray Tracing in One Weekend[Peter Shirley](https://github.com/petershirley),
    [Trevor David Black](https://github.com/trevordblack), [Steve Hollasch](https://github.com/hollasch)Version
    4.0.2, 2025-04-25Copyright 2018-2024 Peter Shirley. All rights reserved.Contents
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一个周末的光线追踪[彼得·雪莉](https://github.com/petershirley), [特雷弗·大卫·布莱克](https://github.com/trevordblack),
    [史蒂夫·霍拉斯](https://github.com/hollasch)版本 4.0.2, 2025-04-25版权所有 2018-2024 彼得·雪莉。保留所有权利。
- en: '[(Top)](#)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[(顶部)](#)'
- en: '[1 Overview](#overview)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[1 概述](#overview)'
- en: '[2 Output an Image](#outputanimage)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[2 输出图像](#outputanimage)'
- en: '[2.1 The PPM Image Format](#outputanimage/theppmimageformat)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[2.1 PPM 图像格式](#outputanimage/theppmimageformat)'
- en: '[2.2 Creating an Image File](#outputanimage/creatinganimagefile)'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[2.2 创建图像文件](#outputanimage/creatinganimagefile)'
- en: '[2.3 Adding a Progress Indicator](#outputanimage/addingaprogressindicator)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[2.3 添加进度指示器](#outputanimage/addingaprogressindicator)'
- en: '[3 The vec3 Class](#thevec3class)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[3 vec3 类](#thevec3class)'
- en: '[3.1 Color Utility Functions](#thevec3class/colorutilityfunctions)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[3.1 颜色实用函数](#thevec3class/colorutilityfunctions)'
- en: '[4 Rays, a Simple Camera, and Background](#rays,asimplecamera,andbackground)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[4 光线、简单相机和背景](#rays,asimplecamera,andbackground)'
- en: '[4.1 The ray Class](#rays,asimplecamera,andbackground/therayclass)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[4.1 ray 类](#rays,asimplecamera,andbackground/therayclass)'
- en: '[4.2 Sending Rays Into the Scene](#rays,asimplecamera,andbackground/sendingraysintothescene)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[4.2 将光线发送到场景中](#rays,asimplecamera,andbackground/sendingraysintothescene)'
- en: '[5 Adding a Sphere](#addingasphere)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[5 添加球体](#addingasphere)'
- en: '[5.1 Ray-Sphere Intersection](#addingasphere/ray-sphereintersection)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[5.1 光线-球体交点](#addingasphere/ray-sphereintersection)'
- en: '[5.2 Creating Our First Raytraced Image](#addingasphere/creatingourfirstraytracedimage)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[5.2 创建我们的第一个光线追踪图像](#addingasphere/creatingourfirstraytracedimage)'
- en: '[6 Surface Normals and Multiple Objects](#surfacenormalsandmultipleobjects)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[6 表面法线和多个对象](#surfacenormalsandmultipleobjects)'
- en: '[6.1 Shading with Surface Normals](#surfacenormalsandmultipleobjects/shadingwithsurfacenormals)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[6.1 使用表面法线进行着色](#surfacenormalsandmultipleobjects/shadingwithsurfacenormals)'
- en: '[6.2 Simplifying the Ray-Sphere Intersection Code](#surfacenormalsandmultipleobjects/simplifyingtheray-sphereintersectioncode)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[6.2 简化光线-球体交点代码](#surfacenormalsandmultipleobjects/simplifyingtheray-sphereintersectioncode)'
- en: '[6.3 An Abstraction for Hittable Objects](#surfacenormalsandmultipleobjects/anabstractionforhittableobjects)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[6.3 可击中对象的抽象](#surfacenormalsandmultipleobjects/anabstractionforhittableobjects)'
- en: '[6.4 Front Faces Versus Back Faces](#surfacenormalsandmultipleobjects/frontfacesversusbackfaces)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[6.4 前面与后面](#surfacenormalsandmultipleobjects/frontfacesversusbackfaces)'
- en: '[6.5 A List of Hittable Objects](#surfacenormalsandmultipleobjects/alistofhittableobjects)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[6.5 可击中对象列表](#surfacenormalsandmultipleobjects/alistofhittableobjects)'
- en: '[6.6 Some New C++ Features](#surfacenormalsandmultipleobjects/somenewc++features)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[6.6 一些新的 C++ 功能](#surfacenormalsandmultipleobjects/somenewc++features)'
- en: '[6.7 Common Constants and Utility Functions](#surfacenormalsandmultipleobjects/commonconstantsandutilityfunctions)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[6.7 常用常量和实用函数](#surfacenormalsandmultipleobjects/commonconstantsandutilityfunctions)'
- en: '[6.8 An Interval Class](#surfacenormalsandmultipleobjects/anintervalclass)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[6.8 间隔类](#surfacenormalsandmultipleobjects/anintervalclass)'
- en: '[7 Moving Camera Code Into Its Own Class](#movingcameracodeintoitsownclass)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[7 将相机代码移动到自己的类中](#movingcameracodeintoitsownclass)'
- en: '[8 Antialiasing](#antialiasing)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[8 抗锯齿](#antialiasing)'
- en: '[8.1 Some Random Number Utilities](#antialiasing/somerandomnumberutilities)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[8.1 一些随机数实用工具](#antialiasing/somerandomnumberutilities)'
- en: '[8.2 Generating Pixels with Multiple Samples](#antialiasing/generatingpixelswithmultiplesamples)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[8.2 使用多个样本生成像素](#antialiasing/generatingpixelswithmultiplesamples)'
- en: '[9 Diffuse Materials](#diffusematerials)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[9 扩散材料](#diffusematerials)'
- en: '[9.1 A Simple Diffuse Material](#diffusematerials/asimplediffusematerial)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.1 简单的扩散材料](#diffusematerials/asimplediffusematerial)'
- en: '[9.2 Limiting the Number of Child Rays](#diffusematerials/limitingthenumberofchildrays)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.2 限制子光线数量](#diffusematerials/limitingthenumberofchildrays)'
- en: '[9.3 Fixing Shadow Acne](#diffusematerials/fixingshadowacne)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.3 解决阴影痤疮](#diffusematerials/fixingshadowacne)'
- en: '[9.4 True Lambertian Reflection](#diffusematerials/truelambertianreflection)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.4 真实的朗伯反射](#diffusematerials/truelambertianreflection)'
- en: '[9.5 Using Gamma Correction for Accurate Color Intensity](#diffusematerials/usinggammacorrectionforaccuratecolorintensity)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.5 使用伽玛校正以获得准确的色彩强度](#diffusematerials/usinggammacorrectionforaccuratecolorintensity)'
- en: '[10 Metal](#metal)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[10 金属](#metal)'
- en: '[10.1 An Abstract Class for Materials](#metal/anabstractclassformaterials)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[10.1 材料抽象类](#metal/anabstractclassformaterials)'
- en: '[10.2 A Data Structure to Describe Ray-Object Intersections](#metal/adatastructuretodescriberay-objectintersections)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[10.2 描述光线-对象交点的数据结构](#metal/adatastructuretodescriberay-objectintersections)'
- en: '[10.3 Modeling Light Scatter and Reflectance](#metal/modelinglightscatterandreflectance)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[10.3 模拟光散射和反射](#metal/modelinglightscatterandreflectance)'
- en: '[10.4 Mirrored Light Reflection](#metal/mirroredlightreflection)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[10.4 镜面光反射](#metal/mirroredlightreflection)'
- en: '[10.5 A Scene with Metal Spheres](#metal/ascenewithmetalspheres)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[10.5 一个带有金属球的场景](#metal/ascenewithmetalspheres)'
- en: '[10.6 Fuzzy Reflection](#metal/fuzzyreflection)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[10.6 模糊反射](#metal/fuzzyreflection)'
- en: '[11 Dielectrics](#dielectrics)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[11 电介质](#dielectrics)'
- en: '[11.1 Refraction](#dielectrics/refraction)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[11.1 折射](#dielectrics/refraction)'
- en: '[11.2 Snell''s Law](#dielectrics/snell''slaw)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[11.2 斯涅尔定律](#dielectrics/snell''slaw)'
- en: '[11.3 Total Internal Reflection](#dielectrics/totalinternalreflection)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[11.3 全内反射](#dielectrics/totalinternalreflection)'
- en: '[11.4 Schlick Approximation](#dielectrics/schlickapproximation)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[11.4 Schlick 近似](#dielectrics/schlickapproximation)'
- en: '[11.5 Modeling a Hollow Glass Sphere](#dielectrics/modelingahollowglasssphere)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[11.5 模拟空心玻璃球](#dielectrics/modelingahollowglasssphere)'
- en: '[12 Positionable Camera](#positionablecamera)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[12 可定位相机](#positionablecamera)'
- en: '[12.1 Camera Viewing Geometry](#positionablecamera/cameraviewinggeometry)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[12.1 相机观看几何](#positionablecamera/cameraviewinggeometry)'
- en: '[12.2 Positioning and Orienting the Camera](#positionablecamera/positioningandorientingthecamera)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[12.2 定位和定向相机](#positionablecamera/positioningandorientingthecamera)'
- en: '[13 Defocus Blur](#defocusblur)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[13 虚化模糊](#defocusblur)'
- en: '[13.1 A Thin Lens Approximation](#defocusblur/athinlensapproximation)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[13.1 薄透镜近似](#defocusblur/athinlensapproximation)'
- en: '[13.2 Generating Sample Rays](#defocusblur/generatingsamplerays)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[13.2 生成样本光线](#defocusblur/generatingsamplerays)'
- en: '[14 Where Next?](#wherenext?)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[14 接下来是什么？](#wherenext?)'
- en: '[14.1 A Final Render](#wherenext?/afinalrender)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[14.1 最终渲染](#wherenext?/afinalrender)'
- en: '[14.2 Next Steps](#wherenext?/nextsteps)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[14.2 下一步](#wherenext?/nextsteps)'
- en: '[14.2.1 Book 2: *Ray Tracing: The Next Week*](#wherenext?/nextsteps/book2:raytracing:thenextweek)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[14.2.1 书籍 2：*光线追踪：下周*](#wherenext?/nextsteps/book2:raytracing:thenextweek)'
- en: '[14.2.2 Book 3: *Ray Tracing: The Rest of Your Life*](#wherenext?/nextsteps/book3:raytracing:therestofyourlife)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[14.2.2 书籍 3：*光线追踪：你余生的其余部分*](#wherenext?/nextsteps/book3:raytracing:therestofyourlife)'
- en: '[14.2.3 Other Directions](#wherenext?/nextsteps/otherdirections)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[14.2.3 其他方向](#wherenext?/nextsteps/otherdirections)'
- en: '[15 Acknowledgments](#acknowledgments)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[15 致谢](#acknowledgments)'
- en: '[16 Citing This Book](#citingthisbook)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[16 引用这本书](#citingthisbook)'
- en: '[16.1 Basic Data](#citingthisbook/basicdata)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[16.1 基本数据](#citingthisbook/basicdata)'
- en: '[16.2 Snippets](#citingthisbook/snippets)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[16.2 碎片](#citingthisbook/snippets)'
- en: '[16.2.1 Markdown](#citingthisbook/snippets/markdown)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[16.2.1 Markdown](#citingthisbook/snippets/markdown)'
- en: '[16.2.2 HTML](#citingthisbook/snippets/html)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[16.2.2 HTML](#citingthisbook/snippets/html)'
- en: '[16.2.3 LaTeX and BibTex](#citingthisbook/snippets/latexandbibtex)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[16.2.3 LaTeX 和 BibTeX](#citingthisbook/snippets/latexandbibtex)'
- en: '[16.2.4 BibLaTeX](#citingthisbook/snippets/biblatex)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[16.2.4 BibLaTeX](#citingthisbook/snippets/biblatex)'
- en: '[16.2.5 IEEE](#citingthisbook/snippets/ieee)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[16.2.5 IEEE](#citingthisbook/snippets/ieee)'
- en: '[16.2.6 MLA:](#citingthisbook/snippets/mla:)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[16.2.6 MLA:](#citingthisbook/snippets/mla:])'
- en: Overview
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: I’ve taught many graphics classes over the years. Often I do them in ray tracing,
    because you are forced to write all the code, but you can still get cool images
    with no API. I decided to adapt my course notes into a how-to, to get you to a
    cool program as quickly as possible. It will not be a full-featured ray tracer,
    but it does have the indirect lighting which has made ray tracing a staple in
    movies. Follow these steps, and the architecture of the ray tracer you produce
    will be good for extending to a more extensive ray tracer if you get excited and
    want to pursue that.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些年我教过很多图形学课程。通常我会用光线追踪来做，因为这样你必须编写所有的代码，但你仍然可以用没有 API 的方式得到酷炫的图像。我决定将我的课程笔记改编成教程，以便你能尽快进入一个酷炫的程序。这不会是一个功能齐全的光线追踪器，但它确实具有使光线追踪成为电影中必备技术的间接照明。遵循这些步骤，如果你兴奋并想要进一步追求，你制作的光线追踪器的架构将适合扩展到一个更广泛的光线追踪器。
- en: When somebody says “ray tracing” it could mean many things. What I am going
    to describe is technically a path tracer, and a fairly general one. While the
    code will be pretty simple (let the computer do the work!) I think you’ll be very
    happy with the images you can make.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人说“光线追踪”时，它可能意味着很多不同的东西。我将要描述的是技术上的路径追踪器，而且相当通用。虽然代码将会相当简单（让计算机做工作！）但我相信你会对能制作出的图像感到非常满意。
- en: I’ll take you through writing a ray tracer in the order I do it, along with
    some debugging tips. By the end, you will have a ray tracer that produces some
    great images. You should be able to do this in a weekend. If you take longer,
    don’t worry about it. I use C++ as the driving language, but you don’t need to.
    However, I suggest you do, because it’s fast, portable, and most production movie
    and video game renderers are written in C++. Note that I avoid most “modern features”
    of C++, but inheritance and operator overloading are too useful for ray tracers
    to pass on.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我会按照我实际操作的方式带你编写光线追踪器，并提供一些调试技巧。到那时，你将拥有一个能够生成一些精美图像的光线追踪器。你应该能在周末内完成这个任务。如果你花了更长的时间，不要担心。我使用C++作为驱动语言，但你不必这样做。然而，我建议你这样做，因为C++速度快、可移植，并且大多数电影和视频游戏的渲染器都是用C++编写的。请注意，我避免使用C++的“现代特性”，但继承和运算符重载对于光线追踪器来说太有用，不能放弃。
- en: I do not provide the code online, but the code is real and I show all of it
    except for a few straightforward operators in the `vec3` class. I am a big believer
    in typing in code to learn it, but when code is available I use it, so I only
    practice what I preach when the code is not available. So don’t ask!
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我没有在网上提供代码，但代码是真实的，除了`vec3`类中的一些简单运算符外，我都展示了所有代码。我非常相信通过输入代码来学习，但代码可用时我会使用它，所以当代码不可用时，我只实践我所宣扬的。所以请不要问我！
- en: I have left that last part in because it is funny what a 180 I have done. Several
    readers ended up with subtle errors that were helped when we compared code. So
    please do type in the code, but you can find the finished source for each book
    in the [RayTracing project on GitHub](https://github.com/RayTracing/raytracing.github.io/).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我保留了最后一部分，因为我在这里做了180度的大转弯。一些读者在比较代码时发现了细微的错误，这得到了帮助。所以请务必输入代码，但你可以在GitHub上的[RayTracing项目](https://github.com/RayTracing/raytracing.github.io/)中找到每本书的完成源代码。
- en: 'A note on the implementing code for these books — our philosophy for the included
    code prioritizes the following goals:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些书籍的实现代码——我们对于包含的代码的哲学优先考虑以下目标：
- en: The code should implement the concepts covered in the books.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码应实现书中涵盖的概念。
- en: We use C++, but as simple as possible. Our programming style is very C-like,
    but we take advantage of modern features where it makes the code easier to use
    or understand.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用C++，但尽可能简单。我们的编程风格非常类似于C语言，但我们利用现代特性，使其代码更容易使用或理解。
- en: Our coding style continues the style established from the original books as
    much as possible, for continuity.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的编码风格尽可能地延续了原始书籍中建立的风格，以保持连贯性。
- en: Line length is kept to 96 characters per line, to keep lines consistent between
    the codebase and code listings in the books.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每行代码长度保持在每行96个字符，以保持代码库和书中代码列表的一致性。
- en: The code thus provides a baseline implementation, with tons of improvements
    left for the reader to enjoy. There are endless ways one can optimize and modernize
    the code; we prioritize the simple solution.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，代码提供了一个基线实现，留下了大量的改进空间供读者享受。有无数种优化和现代化的方法；我们优先考虑简单的解决方案。
- en: 'We assume a little bit of familiarity with vectors (like dot product and vector
    addition). If you don’t know that, do a little review. If you need that review,
    or to learn it for the first time, check out the online [*Graphics Codex*](https://graphicscodex.com/)
    by Morgan McGuire, *Fundamentals of Computer Graphics* by Steve Marschner and
    Peter Shirley, or *Computer Graphics: Principles and Practice* by J.D. Foley and
    Andy Van Dam.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设读者对向量（如点积和向量加法）有一定的熟悉度。如果你不知道这些，请稍作复习。如果你需要复习，或者第一次学习这些内容，请查看Morgan McGuire的在线[*Graphics
    Codex*](https://graphicscodex.com/)，Steve Marschner和Peter Shirley的[*计算机图形学基础*](https://graphicscodex.com/)，或者J.D.
    Foley和Andy Van Dam的[*计算机图形学：原理与实践*](https://graphicscodex.com/)。
- en: See the [project README](../README.md) file for information about this project,
    the repository on GitHub, directory structure, building & running, and how to
    make or reference corrections and contributions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 查看项目的[README文件](../README.md)以获取有关此项目、GitHub上的存储库、目录结构、构建和运行以及如何制作或引用更正和贡献的信息。
- en: See [our Further Reading wiki page](https://github.com/RayTracing/raytracing.github.io/wiki/Further-Readings)
    for additional project related resources.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们的[进一步阅读wiki页面](https://github.com/RayTracing/raytracing.github.io/wiki/Further-Readings)以获取更多与项目相关的资源。
- en: These books have been formatted to print well directly from your browser. We
    also include PDFs of each book [with each release](https://github.com/RayTracing/raytracing.github.io/releases/),
    in the “Assets” section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些书籍已经格式化，可以直接从你的浏览器打印出来。我们还包含每个版本的书籍 PDF 文件[与每个发布版本一起](https://github.com/RayTracing/raytracing.github.io/releases/)，在“资产”部分。
- en: 'If you want to communicate with us, feel free to send us an email at:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想与我们联系，请随时通过以下邮箱发送邮件：
- en: Peter Shirley, [ptrshrl@gmail.com](mailto:ptrshrl@gmail.com)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 彼得·雪莉，[ptrshrl@gmail.com](mailto:ptrshrl@gmail.com)
- en: Steve Hollasch, [steve@hollasch.net](mailto:steve@hollasch.net)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 史蒂夫·霍拉斯奇，[steve@hollasch.net](mailto:steve@hollasch.net)
- en: Trevor David Black, [trevordblack@trevord.black](mailto:trevordblack@trevord.black)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特雷弗·大卫·布莱克，[trevordblack@trevord.black](mailto:trevordblack@trevord.black)
- en: Finally, if you run into problems with your implementation, have general questions,
    or would like to share your own ideas or work, see [the GitHub Discussions forum](https://github.com/RayTracing/raytracing.github.io/discussions/)
    on the GitHub project.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你在实现过程中遇到问题，有一般性问题，或者想要分享你自己的想法或工作，请参阅 GitHub 项目上的[GitHub 讨论论坛](https://github.com/RayTracing/raytracing.github.io/discussions/)。
- en: Thanks to everyone who lent a hand on this project. You can find them in the
    [acknowledgments](#acknowledgments) section at the end of this book.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢所有在这个项目上伸出援手的人。你可以在本书末尾的[致谢](#acknowledgments)部分找到他们。
- en: Let’s get on with it!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Output an Image
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出图像
- en: The PPM Image Format
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PPM 图像格式
- en: 'Whenever you start a renderer, you need a way to see an image. The most straightforward
    way is to write it to a file. The catch is, there are so many formats. Many of
    those are complex. I always start with a plain text ppm file. Here’s a nice description
    from Wikipedia:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 每次启动渲染器时，你需要一种查看图像的方法。最直接的方法是将它写入文件。问题是，有如此多的格式。其中许多都很复杂。我总是从一个简单的 ppm 文本文件开始。以下是从维基百科的一个很好的描述：
- en: '[![](https://raytracing.github.io/images/fig-1.01-ppm.jpg)](https://raytracing.github.io/images/fig-1.01-ppm.jpg)**Figure 1:**
    PPM ExampleLet’s make some C++ code to output such a thing:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](https://raytracing.github.io/images/fig-1.01-ppm.jpg)](https://raytracing.github.io/images/fig-1.01-ppm.jpg)**图 1:**
    PPM 示例让我们编写一些 C++ 代码来输出这样的内容：'
- en: '[PRE0]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Listing 1:** `[main.cc]` Creating your first image'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 1:** `[main.cc]` 创建你的第一个图像'
- en: 'There are some things to note in this code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中需要注意一些事项：
- en: The pixels are written out in rows.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像素是按行写出的。
- en: Every row of pixels is written out left to right.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每行像素是从左到右写出的。
- en: These rows are written out from top to bottom.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些行是从上到下写出的。
- en: By convention, each of the red/green/blue components are represented internally
    by real-valued variables that range from 0.0 to 1.0\. These must be scaled to
    integer values between 0 and 255 before we print them out.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照惯例，每个红色/绿色/蓝色组件在内部都由范围从 0.0 到 1.0 的实值变量表示。在打印出来之前，这些必须缩放到 0 到 255 之间的整数值。
- en: Red goes from fully off (black) to fully on (bright red) from left to right,
    and green goes from fully off at the top (black) to fully on at the bottom (bright
    green). Adding red and green light together make yellow so we should expect the
    bottom right corner to be yellow.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 红色从完全关闭（黑色）到完全开启（亮红色）从左到右变化，绿色从顶部完全关闭（黑色）到底部完全开启（亮绿色）变化。红色和绿色光结合在一起形成黄色，因此我们应该预期右下角是黄色。
- en: Creating an Image File
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建图像文件
- en: Because the file is written to the standard output stream, you'll need to redirect
    it to an image file. Typically this is done from the command-line by using the
    `>` redirection operator.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因为文件是写入标准输出流，所以你需要将其重定向到图像文件。通常这通过命令行使用 `>` 重定向运算符来完成。
- en: 'On Windows, you''d get the debug build from CMake running this command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，你会从 CMake 运行此命令以获取调试构建：
- en: '[PRE1]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then run your newly-built program like so:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后这样运行你新构建的程序：
- en: '[PRE2]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Later, it will be better to run optimized builds for speed. In that case, you
    would build like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，为了提高速度，最好运行优化后的构建。在这种情况下，你会这样构建：
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'and would run the optimized program like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后这样运行优化后的程序：
- en: '[PRE4]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The examples above assume that you are building with CMake, using the same approach
    as the `CMakeLists.txt` file in the included source. Use whatever build environment
    (and language) you're most comfortable with.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例假设你正在使用 CMake 构建，使用与包含源文件中的 `CMakeLists.txt` 文件相同的方法。使用你最舒适的构建环境（和语言）。
- en: 'On Mac or Linux, release build, you would launch the program like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac 或 Linux 上，发布构建，你会这样启动程序：
- en: '[PRE5]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Complete building and running instructions can be found in the [project README](../README.md).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的构建和运行说明可以在[项目 README](../README.md)中找到。
- en: 'Opening the output file (in `ToyViewer` on my Mac, but try it in your favorite
    image viewer and Google “ppm viewer” if your viewer doesn’t support it) shows
    this result:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的Mac上，我在`ToyViewer`中打开输出文件（如果你的查看器不支持，请尝试使用你喜欢的图像查看器，并在Google中搜索“ppm viewer”），显示以下结果：
- en: '[![](https://raytracing.github.io/images/img-1.01-first-ppm-image.png)](https://raytracing.github.io/images/img-1.01-first-ppm-image.png)Image
    1: First PPM image'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](https://raytracing.github.io/images/img-1.01-first-ppm-image.png)](https://raytracing.github.io/images/img-1.01-first-ppm-image.png)图1：第一个PPM图像'
- en: 'Hooray! This is the graphics “hello world”. If your image doesn’t look like
    that, open the output file in a text editor and see what it looks like. It should
    start something like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 哈喽！这是“hello world”的图形。如果你的图像看起来不像这样，请用文本编辑器打开输出文件，看看它是什么样子。它应该从以下内容开始：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Listing 2:** First image output'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表2**：第一个图像输出'
- en: If your PPM file doesn't look like this, then double-check your formatting code.
    If it *does* look like this but fails to render, then you may have line-ending
    differences or something similar that is confusing your image viewer. To help
    debug this, you can find a file `test.ppm` in the `images` directory of the Github
    project. This should help to ensure that your viewer can handle the PPM format
    and to use as a comparison against your generated PPM file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的PPM文件看起来不像这样，那么请仔细检查你的格式化代码。如果它确实看起来像这样但无法渲染，那么你可能存在行结束差异或其他类似的问题，这可能会使你的图像查看器困惑。为了帮助调试这个问题，你可以在GitHub项目的`images`目录中找到一个名为`test.ppm`的文件。这应该有助于确保你的查看器可以处理PPM格式，并作为与你的生成PPM文件进行比较的依据。
- en: Some readers have reported problems viewing their generated files on Windows.
    In this case, the problem is often that the PPM is written out as UTF-16, often
    from PowerShell. If you run into this problem, see [Discussion 1114](https://github.com/RayTracing/raytracing.github.io/discussions/1114)
    for help with this issue.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一些读者报告说，他们在Windows上查看生成的文件时遇到了问题。在这种情况下，问题通常是PPM被以UTF-16格式写入，通常来自PowerShell。如果你遇到这个问题，请参阅[讨论1114](https://github.com/RayTracing/raytracing.github.io/discussions/1114)以获取此问题的帮助。
- en: If everything displays correctly, then you're pretty much done with system and
    IDE issues — everything in the remainder of this series uses this same simple
    mechanism for generated rendered images.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切显示正确，那么你基本上就完成了系统和IDE的问题——本系列剩余部分的所有内容都使用这种相同的简单机制来生成渲染图像。
- en: If you want to produce other image formats, I am a fan of `stb_image.h`, a header-only
    image library available on GitHub at [https://github.com/nothings/stb](https://github.com/nothings/stb).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要生成其他图像格式，我非常喜欢`stb_image.h`，这是一个GitHub上可用的仅头文件图像库，网址为[https://github.com/nothings/stb](https://github.com/nothings/stb)。
- en: Adding a Progress Indicator
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加进度指示器
- en: Before we continue, let's add a progress indicator to our output. This is a
    handy way to track the progress of a long render, and also to possibly identify
    a run that's stalled out due to an infinite loop or other problem.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们给我们的输出添加一个进度指示器。这是一种跟踪长时间渲染进度的便捷方式，也可以用来识别由于无限循环或其他问题而停滞的运行。
- en: 'Our program outputs the image to the standard output stream (`std::cout`),
    so leave that alone and instead write to the logging output stream (`std::clog`):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序将图像输出到标准输出流（`std::cout`），所以请保持不变，而是写入到日志输出流（`std::clog`）：
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Listing 3:** `[main.cc]` Main render loop with progress reporting'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表3**：`[main.cc]`带有进度报告的主渲染循环'
- en: Now when running, you'll see a running count of the number of scanlines remaining.
    Hopefully this runs so fast that you don't even see it! Don't worry — you'll have
    lots of time in the future to watch a slowly updating progress line as we expand
    our ray tracer.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行时，你会看到剩余扫描线的运行计数。希望这运行得如此之快，以至于你甚至看不到它！别担心——将来你将有足够的时间观察缓慢更新的进度条，随着我们扩展光线追踪器。
- en: The vec3 Class
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: vec3类
- en: 'Almost all graphics programs have some class(es) for storing geometric vectors
    and colors. In many systems these vectors are 4D (3D position plus a homogeneous
    coordinate for geometry, or RGB plus an alpha transparency component for colors).
    For our purposes, three coordinates suffice. We’ll use the same class `vec3` for
    colors, locations, directions, offsets, whatever. Some people don’t like this
    because it doesn’t prevent you from doing something silly, like subtracting a
    position from a color. They have a good point, but we’re going to always take
    the “less code” route when not obviously wrong. In spite of this, we do declare
    two aliases for `vec3`: `point3` and `color`. Since these two types are just aliases
    for `vec3`, you won''t get warnings if you pass a `color` to a function expecting
    a `point3`, and nothing is stopping you from adding a `point3` to a `color`, but
    it makes the code a little bit easier to read and to understand.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有图形程序都有一些用于存储几何向量和颜色的类。在许多系统中，这些向量是4D的（3D位置加上用于几何的齐次坐标，或RGB加上alpha透明度组件用于颜色）。就我们的目的而言，三个坐标就足够了。我们将使用相同的类`vec3`来表示颜色、位置、方向、偏移等。有些人不喜欢这样做，因为它不能阻止你做一些愚蠢的事情，比如从一个颜色中减去一个位置。他们有很好的观点，但当我们没有明显错误时，我们将始终选择“更少的代码”路线。尽管如此，我们仍然为`vec3`声明了两个别名：`point3`和`color`。由于这两个类型只是`vec3`的别名，所以如果你将一个`color`传递给期望一个`point3`的函数，你不会收到警告，而且没有任何东西阻止你将一个`point3`加到一个`color`上，但这会使代码更容易阅读和理解。
- en: 'We define the `vec3` class in the top half of a new `vec3.h` header file, and
    define a set of useful vector utility functions in the bottom half:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在新的`vec3.h`头文件的顶部定义了`vec3`类，并在底部定义了一组有用的向量实用函数：
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Listing 4:** `[vec3.h]` vec3 definitions and helper functions'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 4:** `[vec3.h]` vec3定义和辅助函数'
- en: We use `double` here, but some ray tracers use `float`. `double` has greater
    precision and range, but is twice the size compared to `float`. This increase
    in size may be important if you're programming in limited memory conditions (such
    as hardware shaders). Either one is fine — follow your own tastes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`double`，但一些光线追踪器使用`float`。`double`具有更高的精度和范围，但与`float`相比大小是其两倍。如果您的编程环境内存有限（例如硬件着色器），这种大小的增加可能很重要。两者都行——跟随您的个人喜好。
- en: Color Utility Functions
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颜色实用函数
- en: Using our new `vec3` class, we'll create a new `color.h` header file and define
    a utility function that writes a single pixel's color out to the standard output
    stream.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们新的`vec3`类，我们将创建一个新的`color.h`头文件，并定义一个实用函数，该函数将单个像素的颜色写入标准输出流。
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Listing 5:** `[color.h]` color utility functionsNow we can change our main
    to use both of these:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 5:** `[color.h]` 颜色实用函数现在我们可以更改我们的主程序来使用这两个：'
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Listing 6:** `[main.cc]` Final code for the first PPM image'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 6:** `[main.cc]` 首个PPM图像的最终代码'
- en: And you should get the exact same picture as before.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到与之前完全相同的图片。
- en: Rays, a Simple Camera, and Background
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光线、简单相机和背景
- en: The ray Class
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 光线类
- en: The one thing that all ray tracers have is a ray class and a computation of
    what color is seen along a ray. Let’s think of a ray as a function <nobr aria-hidden="true">P(t)=A+tb</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">P</mi></mrow><mo stretchy="false">(</mo><mi>t</mi><mo
    stretchy="false">)</mo><mo>=</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">A</mi></mrow><mo>+</mo><mi>t</mi><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">b</mi></mrow>. Here <nobr aria-hidden="true">P</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">P</mi></mrow> is a 3D position
    along a line in 3D. <nobr aria-hidden="true">A</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">A</mi></mrow> is the ray origin and <nobr aria-hidden="true">b</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">b</mi></mrow> is the ray direction.
    The ray parameter <nobr aria-hidden="true">t</nobr><mi>t</mi> is a real number
    (`double` in the code). Plug in a different <nobr aria-hidden="true">t</nobr><mi>t</mi>
    and <nobr aria-hidden="true">P(t)</nobr><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">P</mi></mrow><mo
    stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo> moves the point along
    the ray. Add in negative <nobr aria-hidden="true">t</nobr><mi>t</mi> values and
    you can go anywhere on the 3D line. For positive <nobr aria-hidden="true">t</nobr><mi>t</mi>,
    you get only the parts in front of <nobr aria-hidden="true">A</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">A</mi></mrow>, and this is what is often called a half-line
    or a ray.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 所有光线追踪器都有的一个东西是一个射线类和计算沿射线所看到的颜色。让我们把射线想象成一个函数 <nobr aria-hidden="true">P(t)=A+tb</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">P</mi></mrow><mo stretchy="false">(</mo><mi>t</mi><mo
    stretchy="false">)</mo><mo>=</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">A</mi></mrow><mo>+</mo><mi>t</mi><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">b</mi></mrow>. 这里 <nobr aria-hidden="true">P</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">P</mi></mrow> 是沿 3D 线的 3D 位置。 <nobr
    aria-hidden="true">A</nobr><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">A</mi></mrow>
    是射线的起点，而 <nobr aria-hidden="true">b</nobr><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">b</mi></mrow>
    是射线的方向。射线参数 <nobr aria-hidden="true">t</nobr><mi>t</mi> 是一个实数（代码中的 `double`）。插入不同的
    <nobr aria-hidden="true">t</nobr><mi>t</mi> 值，<nobr aria-hidden="true">P(t)</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">P</mi></mrow><mo stretchy="false">(</mo><mi>t</mi><mo
    stretchy="false">)</mo> 会沿着射线移动点。加入负的 <nobr aria-hidden="true">t</nobr><mi>t</mi>
    值，你可以在 3D 线上的任何地方移动。对于正的 <nobr aria-hidden="true">t</nobr><mi>t</mi>，你只能得到 <nobr
    aria-hidden="true">A</nobr><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">A</mi></mrow>
    前面的部分，这通常被称为半线或射线。
- en: '[![](https://raytracing.github.io/images/fig-1.02-lerp.jpg)](https://raytracing.github.io/images/fig-1.02-lerp.jpg)**Figure 2:**
    Linear interpolationWe can represent the idea of a ray as a class, and represent
    the function <nobr aria-hidden="true">P(t)</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">P</mi></mrow><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo>
    as a function that we''ll call `ray::at(t)`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](https://raytracing.github.io/images/fig-1.02-lerp.jpg)](https://raytracing.github.io/images/fig-1.02-lerp.jpg)**图
    2:** 线性插值我们可以将射线的概念表示为一个类，并将函数 <nobr aria-hidden="true">P(t)</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">P</mi></mrow><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo>
    表示为我们将要称为 `ray::at(t)` 的函数：'
- en: '[PRE11]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Listing 7:** `[ray.h]` The ray class'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 7:** `[ray.h]` 射线类'
- en: (For those unfamiliar with C++, the functions `ray::origin()` and `ray::direction()`
    both return an immutable reference to their members. Callers can either just use
    the reference directly, or make a mutable copy depending on their needs.)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: （对于不熟悉 C++ 的人来说，`ray::origin()` 和 `ray::direction()` 函数都返回对其成员的不可变引用。调用者可以直接使用该引用，或者根据需要创建一个可变副本。）
- en: Sending Rays Into the Scene
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将射线发送到场景中
- en: Now we are ready to turn the corner and make a ray tracer. At its core, a ray
    tracer sends rays through pixels and computes the color seen in the direction
    of those rays. The involved steps are
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备转弯并制作一个光线追踪器。其核心是，光线追踪器通过像素发送射线并计算这些射线的方向上所看到的颜色。涉及的步骤是
- en: Calculate the ray from the “eye” through the pixel,
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算从“眼睛”通过像素的射线
- en: Determine which objects the ray intersects, and
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定射线与哪些对象相交，
- en: Compute a color for the closest intersection point.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算最近交点的颜色。
- en: When first developing a ray tracer, I always do a simple camera for getting
    the code up and running.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次开发光线追踪器时，我总是先做一个简单的相机，以便让代码运行起来。
- en: I’ve often gotten into trouble using square images for debugging because I transpose
    <nobr aria-hidden="true">x</nobr><mi>x</mi> and <nobr aria-hidden="true">y</nobr><mi>y</mi>
    too often, so we’ll use a non-square image. A square image has a 1∶1 aspect ratio,
    because its width is the same as its height. Since we want a non-square image,
    we'll choose 16∶9 because it's so common. A 16∶9 aspect ratio means that the ratio
    of image width to image height is 16∶9\. Put another way, given an image with
    a 16∶9 aspect ratio,
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常因为经常混淆 <nobr aria-hidden="true">x</nobr><mi>x</mi> 和 <nobr aria-hidden="true">y</nobr><mi>y</mi>
    而陷入调试的麻烦，所以我们将使用非正方形图像。正方形图像的宽高比是1:1，因为它的宽度和高度相同。由于我们想要非正方形图像，我们将选择16:9，因为它非常常见。16:9的宽高比意味着图像宽度和高度的比例是16:9。换句话说，给定一个16:9宽高比的图像，
- en: <nobr aria-hidden="true">width/height=16/9=1.7778</nobr><mtext>width</mtext><mrow
    class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mtext>height</mtext><mo>=</mo><mn>16</mn><mrow
    class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>9</mn><mo>=</mo><mn>1.7778</mn>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">宽/高=16/9=1.7778</nobr><mtext>宽</mtext><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mtext>高</mtext><mo>=</mo><mn>16</mn><mrow
    class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>9</mn><mo>=</mo><mn>1.7778</mn>
- en: For a practical example, an image 800 pixels wide by 400 pixels high has a 2∶1
    aspect ratio.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个实际例子，一个宽度为800像素、高度为400像素的图像具有2:1的宽高比。
- en: The image's aspect ratio can be determined from the ratio of its width to its
    height. However, since we have a given aspect ratio in mind, it's easier to set
    the image's width and the aspect ratio, and then using this to calculate for its
    height. This way, we can scale up or down the image by changing the image width,
    and it won't throw off our desired aspect ratio. We do have to make sure that
    when we solve for the image height the resulting height is at least 1.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的宽高比可以通过其宽度和高度的比值来确定。然而，由于我们心中已经有了特定的宽高比，因此设置图像的宽度和宽高比会更简单，然后利用这个比值来计算其高度。这样，我们可以通过改变图像宽度来放大或缩小图像，而不会破坏我们想要的宽高比。我们确实需要确保在求解图像高度时，得到的高度至少为1。
- en: In addition to setting up the pixel dimensions for the rendered image, we also
    need to set up a virtual *viewport* through which to pass our scene rays. The
    viewport is a virtual rectangle in the 3D world that contains the grid of image
    pixel locations. If pixels are spaced the same distance horizontally as they are
    vertically, the viewport that bounds them will have the same aspect ratio as the
    rendered image. The distance between two adjacent pixels is called the pixel spacing,
    and square pixels is the standard.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置渲染图像的像素维度外，我们还需要设置一个虚拟的*视口*，通过它传递我们的场景光线。视口是3D世界中的一个虚拟矩形，包含图像像素位置的网格。如果像素在水平方向上的间距与垂直方向上的间距相同，那么包含它们的视口将具有与渲染图像相同的宽高比。两个相邻像素之间的距离称为像素间距，正方形像素是标准。
- en: 'To start things off, we''ll choose an arbitrary viewport height of 2.0, and
    scale the viewport width to give us the desired aspect ratio. Here''s a snippet
    of what this code will look like:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们将选择一个任意的视口高度为2.0，并将视口宽度缩放以获得所需的宽高比。以下是这段代码的片段：
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Listing 8:** Rendered image setup'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表8：渲染图像设置**'
- en: If you're wondering why we don't just use `aspect_ratio` when computing `viewport_width`,
    it's because the value set to `aspect_ratio` is the ideal ratio, it may not be
    the *actual* ratio between `image_width` and `image_height`. If `image_height`
    was allowed to be real valued—rather than just an integer—then it would be fine
    to use `aspect_ratio`. But the *actual* ratio between `image_width` and `image_height`
    can vary based on two parts of the code. First, `image_height` is rounded down
    to the nearest integer, which can increase the ratio. Second, we don't allow `image_height`
    to be less than one, which can also change the actual aspect ratio.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么我们在计算`viewport_width`时不直接使用`aspect_ratio`，那是因为设置给`aspect_ratio`的值是理想比例，它可能不是`image_width`和`image_height`之间的*实际*比例。如果`image_height`被允许是实数值——而不仅仅是整数——那么使用`aspect_ratio`将是可行的。但是，`image_width`和`image_height`之间的*实际*比例可能会根据代码的两个部分而变化。首先，`image_height`会被四舍五入到最接近的整数，这可能会增加比例。其次，我们不允许`image_height`小于1，这也可能改变实际的宽高比。
- en: Note that `aspect_ratio` is an ideal ratio, which we approximate as best as
    possible with the integer-based ratio of image width over image height. In order
    for our viewport proportions to exactly match our image proportions, we use the
    calculated image aspect ratio to determine our final viewport width.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`aspect_ratio` 是一个理想的比例，我们尽可能地用基于整数的图像宽度与高度的比率来近似。为了使我们的视口比例与图像比例完全匹配，我们使用计算出的图像宽高比来确定最终的视口宽度。
- en: 'Next we will define the camera center: a point in 3D space from which all scene
    rays will originate (this is also commonly referred to as the *eye point*). The
    vector from the camera center to the viewport center will be orthogonal to the
    viewport. We''ll initially set the distance between the viewport and the camera
    center point to be one unit. This distance is often referred to as the *focal
    length*.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将定义相机中心：一个在 3D 空间中的点，所有场景光线都将从这个点发出（这也通常被称为 *视点*）。从相机中心到视口中心的向量将与视口垂直。我们最初将视口和相机中心点之间的距离设置为
    1 个单位。这个距离通常被称为 *焦距*。
- en: For simplicity we'll start with the camera center at <nobr aria-hidden="true">(0,0,0)</nobr><mo
    stretchy="false">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo>.
    We'll also have the y-axis go up, the x-axis to the right, and the negative z-axis
    pointing in the viewing direction. (This is commonly referred to as *right-handed
    coordinates*.)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们将以相机中心在 <nobr aria-hidden="true">(0,0,0)</nobr><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo
    stretchy="false">)</mo> 为起点。我们还将使 y 轴向上，x 轴向右，负 z 轴指向观察方向。（这通常被称为 *右手坐标系*。）
- en: '[![](https://raytracing.github.io/images/fig-1.03-cam-geom.jpg)](https://raytracing.github.io/images/fig-1.03-cam-geom.jpg)**Figure 3:**
    Camera geometry'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](https://raytracing.github.io/images/fig-1.03-cam-geom.jpg)](https://raytracing.github.io/images/fig-1.03-cam-geom.jpg)**图
    3：** 相机几何'
- en: 'Now the inevitable tricky part. While our 3D space has the conventions above,
    this conflicts with our image coordinates, where we want to have the zeroth pixel
    in the top-left and work our way down to the last pixel at the bottom right. This
    means that our image coordinate Y-axis is inverted: Y increases going down the
    image.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是不可避免的棘手部分。虽然我们的 3D 空间有上述惯例，但这与我们的图像坐标相冲突，我们希望在图像的左上角有零像素，然后向下到右下角的最后像素。这意味着我们的图像坐标
    Y 轴是反转的：Y 值随着图像向下增加。
- en: As we scan our image, we will start at the upper left pixel (pixel <nobr aria-hidden="true">0,0</nobr><mn>0</mn><mo>,</mo><mn>0</mn>),
    scan left-to-right across each row, and then scan row-by-row, top-to-bottom. To
    help navigate the pixel grid, we'll use a vector from the left edge to the right
    edge (<nobr aria-hidden="true">Vu</nobr><mrow class="MJX-TeXAtom-ORD"><msub><mi
    mathvariant="bold">V</mi><mi mathvariant="bold">u</mi></msub></mrow>), and a vector
    from the upper edge to the lower edge (<nobr aria-hidden="true">Vv</nobr><mrow
    class="MJX-TeXAtom-ORD"><msub><mi mathvariant="bold">V</mi><mi mathvariant="bold">v</mi></msub></mrow>).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在扫描我们的图像时，我们将从左上角的像素（像素 <nobr aria-hidden="true">0,0</nobr><mn>0</mn><mo>,</mo><mn>0</mn>）开始，从左到右扫描每一行，然后逐行从上到下扫描。为了帮助导航像素网格，我们将使用从左边缘到右边缘的向量（<nobr
    aria-hidden="true">Vu</nobr><mrow class="MJX-TeXAtom-ORD"><msub><mi mathvariant="bold">V</mi><mi
    mathvariant="bold">u</mi></msub></mrow>），以及从上边缘到下边缘的向量（<nobr aria-hidden="true">Vv</nobr><mrow
    class="MJX-TeXAtom-ORD"><msub><mi mathvariant="bold">V</mi><mi mathvariant="bold">v</mi></msub></mrow>）。
- en: 'Our pixel grid will be inset from the viewport edges by half the pixel-to-pixel
    distance. This way, our viewport area is evenly divided into width × height identical
    regions. Here''s what our viewport and pixel grid look like:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的像素网格将嵌入视口边缘，距离为像素间距离的一半。这样，我们的视口区域就被均匀地分成了宽度 × 高度相同的区域。以下是我们的视口和像素网格的示意图：
- en: '[![](https://raytracing.github.io/images/fig-1.04-pixel-grid.jpg)](https://raytracing.github.io/images/fig-1.04-pixel-grid.jpg)**Figure 4:**
    Viewport and pixel grid'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](https://raytracing.github.io/images/fig-1.04-pixel-grid.jpg)](https://raytracing.github.io/images/fig-1.04-pixel-grid.jpg)**图
    4：** 视口和像素网格'
- en: In this figure, we have the viewport, the pixel grid for a 7×5 resolution image,
    the viewport upper left corner <nobr aria-hidden="true">Q</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">Q</mi></mrow>, the pixel <nobr aria-hidden="true">P0,0</nobr><mrow
    class="MJX-TeXAtom-ORD"><msub><mi mathvariant="bold">P</mi><mrow class="MJX-TeXAtom-ORD"><mn
    mathvariant="bold">0</mn><mo mathvariant="bold">,</mo><mn mathvariant="bold">0</mn></mrow></msub></mrow>
    location, the viewport vector <nobr aria-hidden="true">Vu</nobr><mrow class="MJX-TeXAtom-ORD"><msub><mi
    mathvariant="bold">V</mi><mi mathvariant="bold">u</mi></msub></mrow> (`viewport_u`),
    the viewport vector <nobr aria-hidden="true">Vv</nobr><mrow class="MJX-TeXAtom-ORD"><msub><mi
    mathvariant="bold">V</mi><mi mathvariant="bold">v</mi></msub></mrow> (`viewport_v`),
    and the pixel delta vectors <nobr aria-hidden="true">Δu</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">Δ</mi><mi mathvariant="bold">u</mi></mrow> and <nobr aria-hidden="true">Δv</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">Δ</mi><mi mathvariant="bold">v</mi></mrow>.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们有视口、7×5 分辨率图像的像素网格、视口左上角 <nobr aria-hidden="true">Q</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">Q</mi></mrow>、像素位置 <nobr aria-hidden="true">P0,0</nobr><mrow
    class="MJX-TeXAtom-ORD"><msub><mi mathvariant="bold">P</mi><mrow class="MJX-TeXAtom-ORD"><mn
    mathvariant="bold">0</mn><mo mathvariant="bold">,</mo><mn mathvariant="bold">0</mn></mrow></msub></mrow>，视口向量
    <nobr aria-hidden="true">Vu</nobr><mrow class="MJX-TeXAtom-ORD"><msub><mi mathvariant="bold">V</mi><mi
    mathvariant="bold">u</mi></msub></mrow> (`viewport_u`)，视口向量 <nobr aria-hidden="true">Vv</nobr><mrow
    class="MJX-TeXAtom-ORD"><msub><mi mathvariant="bold">V</mi><mi mathvariant="bold">v</mi></msub></mrow>
    (`viewport_v`)，以及像素增量向量 <nobr aria-hidden="true">Δu</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">Δ</mi><mi mathvariant="bold">u</mi></mrow> 和 <nobr aria-hidden="true">Δv</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">Δ</mi><mi mathvariant="bold">v</mi></mrow>.
- en: Drawing from all of this, here's the code that implements the camera. We'll
    stub in a function `ray_color(const ray& r)` that returns the color for a given
    scene ray — which we'll set to always return black for now.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 从所有这些中汲取灵感，以下是实现相机的代码。我们将创建一个函数 `ray_color(const ray& r)`，该函数返回给定场景射线的颜色——我们目前将其设置为总是返回黑色。
- en: '[PRE13]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Listing 9:** `[main.cc]` Creating scene rays'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 9:** `[main.cc]` 创建场景射线'
- en: Notice that in the code above, I didn't make `ray_direction` a unit vector,
    because I think not doing that makes for simpler and slightly faster code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到在上述代码中，我没有将 `ray_direction` 设置为单位向量，因为我认为这样做可以使代码更简单且稍微快一点。
- en: Now we'll fill in the `ray_color(ray)` function to implement a simple gradient.
    This function will linearly blend white and blue depending on the height of the
    <nobr aria-hidden="true">y</nobr><mi>y</mi> coordinate *after* scaling the ray
    direction to unit length (so <nobr aria-hidden="true">−1.0<y<1.0</nobr><mo>−</mo><mn>1.0</mn><mo><</mo><mi>y</mi><mo><</mo><mn>1.0</mn>).
    Because we're looking at the <nobr aria-hidden="true">y</nobr><mi>y</mi> height
    after normalizing the vector, you'll notice a horizontal gradient to the color
    in addition to the vertical gradient.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将填充 `ray_color(ray)` 函数以实现一个简单的渐变。这个函数将根据 <nobr aria-hidden="true">y</nobr><mi>y</mi>
    坐标的高度线性混合白色和蓝色，在将射线方向缩放为单位长度之后（因此 <nobr aria-hidden="true">−1.0<y<1.0</nobr><mo>−</mo><mn>1.0</mn><mo><</mo><mi>y</mi><mo><</mo><mn>1.0</mn>）。因为我们是在规范化向量后查看
    <nobr aria-hidden="true">y</nobr><mi>y</mi> 高度，所以你会注意到除了垂直渐变外，还有水平渐变到颜色中。
- en: I'll use a standard graphics trick to linearly scale <nobr aria-hidden="true">0.0≤a≤1.0</nobr><mn>0.0</mn><mo>≤</mo><mi>a</mi><mo>≤</mo><mn>1.0</mn>.
    When <nobr aria-hidden="true">a=1.0</nobr><mi>a</mi><mo>=</mo><mn>1.0</mn>, I
    want blue. When <nobr aria-hidden="true">a=0.0</nobr><mi>a</mi><mo>=</mo><mn>0.0</mn>,
    I want white. In between, I want a blend. This forms a “linear blend”, or “linear
    interpolation”. This is commonly referred to as a *lerp* between two values. A
    lerp is always of the form
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用一个标准的图形技巧来线性缩放 <nobr aria-hidden="true">0.0≤a≤1.0</nobr><mn>0.0</mn><mo>≤</mo><mi>a</mi><mo>≤</mo><mn>1.0</mn>.
    当 <nobr aria-hidden="true">a=1.0</nobr><mi>a</mi><mo>=</mo><mn>1.0</mn> 时，我想要蓝色。当
    <nobr aria-hidden="true">a=0.0</nobr><mi>a</mi><mo>=</mo><mn>0.0</mn> 时，我想要白色。在两者之间，我想要混合。这形成了一个“线性混合”，或“线性插值”。这通常被称为两个值之间的
    *lerp*。lerp 总是以下形式
- en: <nobr aria-hidden="true">blendedValue=(1−a)⋅startValue+a⋅endValue,</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit" mathvariant="italic">b</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">l</mi><mi class="MJX-tex-mathit" mathvariant="italic">e</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">n</mi><mi class="MJX-tex-mathit" mathvariant="italic">d</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">e</mi><mi class="MJX-tex-mathit" mathvariant="italic">d</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">V</mi><mi class="MJX-tex-mathit" mathvariant="italic">a</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">l</mi><mi class="MJX-tex-mathit" mathvariant="italic">u</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">e</mi></mrow><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>a</mi><mo
    stretchy="false">)</mo><mo>⋅</mo><mrow class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit"
    mathvariant="italic">s</mi><mi class="MJX-tex-mathit" mathvariant="italic">t</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">a</mi><mi class="MJX-tex-mathit" mathvariant="italic">r</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">t</mi><mi class="MJX-tex-mathit" mathvariant="italic">V</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">a</mi><mi class="MJX-tex-mathit" mathvariant="italic">l</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">u</mi><mi class="MJX-tex-mathit" mathvariant="italic">e</mi></mrow><mo>+</mo><mi>a</mi><mo>⋅</mo><mrow
    class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit" mathvariant="italic">e</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">n</mi><mi class="MJX-tex-mathit" mathvariant="italic">d</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">V</mi><mi class="MJX-tex-mathit" mathvariant="italic">a</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">l</mi><mi class="MJX-tex-mathit" mathvariant="italic">u</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">e</mi></mrow><mo>,</mo>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">blendedValue=(1−a)⋅startValue+a⋅endValue,</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit" mathvariant="italic">b</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">l</mi><mi class="MJX-tex-mathit" mathvariant="italic">e</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">n</mi><mi class="MJX-tex-mathit" mathvariant="italic">d</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">e</mi><mi class="MJX-tex-mathit" mathvariant="italic">d</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">V</mi><mi class="MJX-tex-mathit" mathvariant="italic">a</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">l</mi><mi class="MJX-tex-mathit" mathvariant="italic">u</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">e</mi></mrow><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>a</mi><mo
    stretchy="false">)</mo><mo>⋅</mo><mrow class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit"
    mathvariant="italic">s</mi><mi class="MJX-tex-mathit" mathvariant="italic">t</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">a</mi><mi class="MJX-tex-mathit" mathvariant="italic">r</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">t</mi><mi class="MJX-tex-mathit" mathvariant="italic">V</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">a</mi><mi class="MJX-tex-mathit" mathvariant="italic">l</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">u</mi><mi class="MJX-tex-mathit" mathvariant="italic">e</mi></mrow><mo>+</mo><mi>a</mi><mo>⋅</mo><mrow
    class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit" mathvariant="italic">e</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">n</mi><mi class="MJX-tex-mathit" mathvariant="italic">d</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">V</mi><mi class="MJX-tex-mathit" mathvariant="italic">a</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">l</mi><mi class="MJX-tex-mathit" mathvariant="italic">u</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">e</mi></mrow><mo>,</mo>
- en: with <nobr aria-hidden="true">a</nobr><mi>a</mi> going from zero to one.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 <nobr aria-hidden="true">a</nobr><mi>a</mi> 从零到一变化。
- en: 'Putting all this together, here''s what we get:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们得到以下结果：
- en: '[PRE14]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Listing 10:** `[main.cc]` Rendering a blue-to-white gradientIn our case this
    produces:[![](https://raytracing.github.io/images/img-1.02-blue-to-white.png)](https://raytracing.github.io/images/img-1.02-blue-to-white.png)Image
    2: A blue-to-white gradient depending on ray Y coordinate'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 10:** `[main.cc]` 渲染从蓝色到白色的渐变。在我们的情况下，这会产生：[![](https://raytracing.github.io/images/img-1.02-blue-to-white.png)](https://raytracing.github.io/images/img-1.02-blue-to-white.png)图
    2：根据射线 Y 坐标的蓝色到白色渐变'
- en: Adding a Sphere
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加球体
- en: Let’s add a single object to our ray tracer. People often use spheres in ray
    tracers because calculating whether a ray hits a sphere is relatively simple.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的光线追踪器中添加一个单独的对象。人们经常在光线追踪器中使用球体，因为计算射线是否击中球体相对简单。
- en: Ray-Sphere Intersection
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 射线-球面交点
- en: 'The equation for a sphere of radius <nobr aria-hidden="true">r</nobr><mi>r</mi>
    that is centered at the origin is an important mathematical equation:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以原点为中心的半径为 <nobr aria-hidden="true">r</nobr><mi>r</mi> 的球体方程是一个重要的数学方程：
- en: <nobr aria-hidden="true">x2+y2+z2=r2</nobr><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><msup><mi>z</mi><mn>2</mn></msup><mo>=</mo><msup><mi>r</mi><mn>2</mn></msup>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">x2+y2+z2=r2</nobr><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><msup><mi>z</mi><mn>2</mn></msup><mo>=</mo><msup><mi>r</mi><mn>2</mn></msup>
- en: You can also think of this as saying that if a given point <nobr aria-hidden="true">(x,y,z)</nobr><mo
    stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo>
    is on the surface of the sphere, then <nobr aria-hidden="true">x2+y2+z2=r2</nobr><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><msup><mi>z</mi><mn>2</mn></msup><mo>=</mo><msup><mi>r</mi><mn>2</mn></msup>.
    If a given point <nobr aria-hidden="true">(x,y,z)</nobr><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo
    stretchy="false">)</mo> is *inside* the sphere, then <nobr aria-hidden="true">x2+y2+z2<r2</nobr><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><msup><mi>z</mi><mn>2</mn></msup><mo><</mo><msup><mi>r</mi><mn>2</mn></msup>,
    and if a given point <nobr aria-hidden="true">(x,y,z)</nobr><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo
    stretchy="false">)</mo> is *outside* the sphere, then <nobr aria-hidden="true">x2+y2+z2>r2</nobr><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><msup><mi>z</mi><mn>2</mn></msup><mo>></mo><msup><mi>r</mi><mn>2</mn></msup>.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以这样理解，如果给定点 <nobr aria-hidden="true">(x,y,z)</nobr><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo
    stretchy="false">)</mo> 在球面上，那么 <nobr aria-hidden="true">x2+y2+z2=r2</nobr><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><msup><mi>z</mi><mn>2</mn></msup><mo>=</mo><msup><mi>r</mi><mn>2</mn></msup>.
    如果给定点 <nobr aria-hidden="true">(x,y,z)</nobr><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo
    stretchy="false">)</mo> 在球内，那么 <nobr aria-hidden="true">x2+y2+z2<r2</nobr><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><msup><mi>z</mi><mn>2</mn></msup><mo><</mo><msup><mi>r</mi><mn>2</mn></msup>,
    如果给定点 <nobr aria-hidden="true">(x,y,z)</nobr><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo
    stretchy="false">)</mo> 在球外，那么 <nobr aria-hidden="true">x2+y2+z2>r2</nobr><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><msup><mi>z</mi><mn>2</mn></msup><mo>></mo><msup><mi>r</mi><mn>2</mn></msup>.
- en: 'If we want to allow the sphere center to be at an arbitrary point <nobr aria-hidden="true">(Cx,Cy,Cz)</nobr><mo
    stretchy="false">(</mo><msub><mi>C</mi><mi>x</mi></msub><mo>,</mo><msub><mi>C</mi><mi>y</mi></msub><mo>,</mo><msub><mi>C</mi><mi>z</mi></msub><mo
    stretchy="false">)</mo>, then the equation becomes a lot less nice:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要允许球心位于任意点 <nobr aria-hidden="true">(Cx,Cy,Cz)</nobr><mo stretchy="false">(</mo><msub><mi>C</mi><mi>x</mi></msub><mo>,</mo><msub><mi>C</mi><mi>y</mi></msub><mo>,</mo><msub><mi>C</mi><mi>z</mi></msub><mo
    stretchy="false">)</mo>，那么方程就变得不那么简洁了：
- en: <nobr aria-hidden="true">(Cx−x)2+(Cy−y)2+(Cz−z)2=r2</nobr><mo stretchy="false">(</mo><msub><mi>C</mi><mi>x</mi></msub><mo>−</mo><mi>x</mi><msup><mo
    stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><msub><mi>C</mi><mi>y</mi></msub><mo>−</mo><mi>y</mi><msup><mo
    stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><msub><mi>C</mi><mi>z</mi></msub><mo>−</mo><mi>z</mi><msup><mo
    stretchy="false">)</mo><mn>2</mn></msup><mo>=</mo><msup><mi>r</mi><mn>2</mn></msup>
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">(Cx−x)2+(Cy−y)2+(Cz−z)2=r2</nobr><mo stretchy="false">(</mo><msub><mi>C</mi><mi>x</mi></msub><mo>−</mo><mi>x</mi><msup><mo
    stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><msub><mi>C</mi><mi>y</mi></msub><mo>−</mo><mi>y</mi><msup><mo
    stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><msub><mi>C</mi><mi>z</mi></msub><mo>−</mo><mi>z</mi><msup><mo
    stretchy="false">)</mo><mn>2</mn></msup><mo>=</mo><msup><mi>r</mi><mn>2</mn></msup>
- en: In graphics, you almost always want your formulas to be in terms of vectors
    so that all the <nobr aria-hidden="true">x</nobr><mi>x</mi>/<nobr aria-hidden="true">y</nobr><mi>y</mi>/<nobr
    aria-hidden="true">z</nobr><mi>z</mi> stuff can be simply represented using a
    `vec3` class. You might note that the vector from point <nobr aria-hidden="true">P=(x,y,z)</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">P</mi></mrow><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo
    stretchy="false">)</mo> to center <nobr aria-hidden="true">C=(Cx,Cy,Cz)</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>=</mo><mo stretchy="false">(</mo><msub><mi>C</mi><mi>x</mi></msub><mo>,</mo><msub><mi>C</mi><mi>y</mi></msub><mo>,</mo><msub><mi>C</mi><mi>z</mi></msub><mo
    stretchy="false">)</mo> is <nobr aria-hidden="true">(C−P)</nobr><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">P</mi></mrow><mo stretchy="false">)</mo>.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形学中，你几乎总是希望你的公式以向量的形式表示，这样所有关于 <nobr aria-hidden="true">x</nobr><mi>x</mi>/<nobr
    aria-hidden="true">y</nobr><mi>y</mi>/<nobr aria-hidden="true">z</nobr><mi>z</mi>
    的内容都可以简单地使用一个 `vec3` 类来表示。你可能注意到，从点 <nobr aria-hidden="true">P=(x,y,z)</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">P</mi></mrow><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo
    stretchy="false">)</mo> 到中心 <nobr aria-hidden="true">C=(Cx,Cy,Cz)</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>=</mo><mo stretchy="false">(</mo><msub><mi>C</mi><mi>x</mi></msub><mo>,</mo><msub><mi>C</mi><mi>y</mi></msub><mo>,</mo><msub><mi>C</mi><mi>z</mi></msub><mo
    stretchy="false">)</mo> 的向量是 <nobr aria-hidden="true">(C−P)</nobr><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">P</mi></mrow><mo stretchy="false">)</mo>.
- en: 'If we use the definition of the dot product:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用点积的定义：
- en: <nobr aria-hidden="true">(C−P)⋅(C−P)=(Cx−x)2+(Cy−y)2+(Cz−z)2</nobr><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">P</mi></mrow><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">P</mi></mrow><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>C</mi><mi>x</mi></msub><mo>−</mo><mi>x</mi><msup><mo
    stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><msub><mi>C</mi><mi>y</mi></msub><mo>−</mo><mi>y</mi><msup><mo
    stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><msub><mi>C</mi><mi>z</mi></msub><mo>−</mo><mi>z</mi><msup><mo
    stretchy="false">)</mo><mn>2</mn></msup>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">(C−P)⋅(C−P)=(Cx−x)2+(Cy−y)2+(Cz−z)2</nobr><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">P</mi></mrow><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">P</mi></mrow><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>C</mi><mi>x</mi></msub><mo>−</mo><mi>x</mi><msup><mo
    stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><msub><mi>C</mi><mi>y</mi></msub><mo>−</mo><mi>y</mi><msup><mo
    stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><msub><mi>C</mi><mi>z</mi></msub><mo>−</mo><mi>z</mi><msup><mo
    stretchy="false">)</mo><mn>2</mn></msup>
- en: 'Then we can rewrite the equation of the sphere in vector form as:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将球面的方程重写为向量形式：
- en: <nobr aria-hidden="true">(C−P)⋅(C−P)=r2</nobr><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">P</mi></mrow><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">P</mi></mrow><mo stretchy="false">)</mo><mo>=</mo><msup><mi>r</mi><mn>2</mn></msup>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">(C−P)⋅(C−P)=r2</nobr><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">P</mi></mrow><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">P</mi></mrow><mo stretchy="false">)</mo><mo>=</mo><msup><mi>r</mi><mn>2</mn></msup>
- en: 'We can read this as “any point <nobr aria-hidden="true">P</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">P</mi></mrow> that satisfies this equation is on the sphere”.
    We want to know if our ray <nobr aria-hidden="true">P(t)=Q+td</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">P</mi></mrow><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">Q</mi></mrow><mo>+</mo><mi>t</mi><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">d</mi></mrow> ever hits the sphere
    anywhere. If it does hit the sphere, there is some <nobr aria-hidden="true">t</nobr><mi>t</mi>
    for which <nobr aria-hidden="true">P(t)</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">P</mi></mrow><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo>
    satisfies the sphere equation. So we are looking for any <nobr aria-hidden="true">t</nobr><mi>t</mi>
    where this is true:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其读作“任何满足此方程的点 <nobr aria-hidden="true">P</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">P</mi></mrow> 都位于球面上”。我们想知道我们的射线 <nobr aria-hidden="true">P(t)=Q+td</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">P</mi></mrow><mo stretchy="false">(</mo><mi>t</mi><mo
    stretchy="false">)</mo><mo>=</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">Q</mi></mrow><mo>+</mo><mi>t</mi><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">d</mi></mrow> 是否在任何地方击中球面。如果它击中了球面，那么存在某个
    <nobr aria-hidden="true">t</nobr><mi>t</mi>，使得 <nobr aria-hidden="true">P(t)</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">P</mi></mrow><mo stretchy="false">(</mo><mi>t</mi><mo
    stretchy="false">)</mo> 满足球面方程。因此，我们正在寻找任何 <nobr aria-hidden="true">t</nobr><mi>t</mi>，其中这是真的：
- en: <nobr aria-hidden="true">(C−P(t))⋅(C−P(t))=r2</nobr><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">P</mi></mrow><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo
    stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">P</mi></mrow><mo
    stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msup><mi>r</mi><mn>2</mn></msup>
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">(C−P(t))⋅(C−P(t))=r2</nobr><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">P</mi></mrow><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo
    stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">P</mi></mrow><mo
    stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msup><mi>r</mi><mn>2</mn></msup>
- en: 'which can be found by replacing <nobr aria-hidden="true">P(t)</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">P</mi></mrow><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo>
    with its expanded form:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将 <nobr aria-hidden="true">P(t)</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">P</mi></mrow><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo>
    替换为其展开形式来找到：
- en: <nobr aria-hidden="true">(C−(Q+td))⋅(C−(Q+td))=r2</nobr><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">Q</mi></mrow><mo>+</mo><mi>t</mi><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">d</mi></mrow><mo stretchy="false">)</mo><mo
    stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">C</mi></mrow><mo>−</mo><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">Q</mi></mrow><mo>+</mo><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">d</mi></mrow><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msup><mi>r</mi><mn>2</mn></msup>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">(C−(Q+td))⋅(C−(Q+td))=r2</nobr><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">Q</mi></mrow><mo>+</mo><mi>t</mi><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">d</mi></mrow><mo stretchy="false">)</mo><mo
    stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">C</mi></mrow><mo>−</mo><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">Q</mi></mrow><mo>+</mo><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">d</mi></mrow><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msup><mi>r</mi><mn>2</mn></msup>
- en: 'We have three vectors on the left dotted by three vectors on the right. If
    we solved for the full dot product we would get nine vectors. You can definitely
    go through and write everything out, but we don''t need to work that hard. If
    you remember, we want to solve for <nobr aria-hidden="true">t</nobr><mi>t</mi>,
    so we''ll separate the terms based on whether there is a <nobr aria-hidden="true">t</nobr><mi>t</mi>
    or not:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个向量在左边与右边的三个向量点乘。如果我们求解完整的点积，我们会得到九个向量。你当然可以逐个写出来，但我们不需要那么辛苦。如果你记得，我们想要求解的是
    <nobr aria-hidden="true">t</nobr><mi>t</mi>，所以我们将项根据是否有 <nobr aria-hidden="true">t</nobr><mi>t</mi>
    来分开：
- en: <nobr aria-hidden="true">(−td+(C−Q))⋅(−td+(C−Q))=r2</nobr><mo stretchy="false">(</mo><mo>−</mo><mi>t</mi><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">d</mi></mrow><mo>+</mo><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">Q</mi></mrow><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⋅</mo><mo
    stretchy="false">(</mo><mo>−</mo><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">d</mi></mrow><mo>+</mo><mo
    stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">Q</mi></mrow><mo stretchy="false">)</mo><mo
    stretchy="false">)</mo><mo>=</mo><msup><mi>r</mi><mn>2</mn></msup>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">(−td+(C−Q))⋅(−td+(C−Q))=r2</nobr><mo stretchy="false">(</mo><mo>−</mo><mi>t</mi><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">d</mi></mrow><mo>+</mo><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">Q</mi></mrow><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⋅</mo><mo
    stretchy="false">(</mo><mo>−</mo><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">d</mi></mrow><mo>+</mo><mo
    stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">Q</mi></mrow><mo stretchy="false">)</mo><mo
    stretchy="false">)</mo><mo>=</mo><msup><mi>r</mi><mn>2</mn></msup>
- en: 'And now we follow the rules of vector algebra to distribute the dot product:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们遵循向量代数的规则来分配点积：
- en: <nobr aria-hidden="true">t2d⋅d−2td⋅(C−Q)+(C−Q)⋅(C−Q)=r2</nobr><msup><mi>t</mi><mn>2</mn></msup><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">d</mi></mrow><mo>⋅</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">d</mi></mrow><mo>−</mo><mn>2</mn><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">d</mi></mrow><mo>⋅</mo><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">Q</mi></mrow><mo
    stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">Q</mi></mrow><mo
    stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">Q</mi></mrow><mo
    stretchy="false">)</mo><mo>=</mo><msup><mi>r</mi><mn>2</mn></msup>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">t2d⋅d−2td⋅(C−Q)+(C−Q)⋅(C−Q)=r2</nobr><msup><mi>t</mi><mn>2</mn></msup><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">d</mi></mrow><mo>⋅</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">d</mi></mrow><mo>−</mo><mn>2</mn><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">d</mi></mrow><mo>⋅</mo><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">Q</mi></mrow><mo
    stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">Q</mi></mrow><mo
    stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">Q</mi></mrow><mo
    stretchy="false">)</mo><mo>=</mo><msup><mi>r</mi><mn>2</mn></msup>
- en: 'Move the square of the radius over to the left hand side:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将半径的平方移到左边：
- en: <nobr aria-hidden="true">t2d⋅d−2td⋅(C−Q)+(C−Q)⋅(C−Q)−r2=0</nobr><msup><mi>t</mi><mn>2</mn></msup><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">d</mi></mrow><mo>⋅</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">d</mi></mrow><mo>−</mo><mn>2</mn><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">d</mi></mrow><mo>⋅</mo><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">Q</mi></mrow><mo
    stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">Q</mi></mrow><mo
    stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">Q</mi></mrow><mo
    stretchy="false">)</mo><mo>−</mo><msup><mi>r</mi><mn>2</mn></msup><mo>=</mo><mn>0</mn>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">t2d⋅d−2td⋅(C−Q)+(C−Q)⋅(C−Q)−r2=0</nobr><msup><mi>t</mi><mn>2</mn></msup><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">d</mi></mrow><mo>⋅</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">d</mi></mrow><mo>−</mo><mn>2</mn><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">d</mi></mrow><mo>⋅</mo><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">Q</mi></mrow><mo
    stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">Q</mi></mrow><mo
    stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">Q</mi></mrow><mo
    stretchy="false">)</mo><mo>−</mo><msup><mi>r</mi><mn>2</mn></msup><mo>=</mo><mn>0</mn>
- en: 'It''s hard to make out what exactly this equation is, but the vectors and <nobr
    aria-hidden="true">r</nobr><mi>r</mi> in that equation are all constant and known.
    Furthermore, the only vectors that we have are reduced to scalars by dot product.
    The only unknown is <nobr aria-hidden="true">t</nobr><mi>t</mi>, and we have a
    <nobr aria-hidden="true">t2</nobr><msup><mi>t</mi><mn>2</mn></msup>, which means
    that this equation is quadratic. You can solve for a quadratic equation <nobr
    aria-hidden="true">ax2+bx+c=0</nobr><mi>a</mi><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mi>b</mi><mi>x</mi><mo>+</mo><mi>c</mi><mo>=</mo><mn>0</mn>
    by using the quadratic formula:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 很难看清楚这个方程具体是什么，但方程中的向量和 <nobr aria-hidden="true">r</nobr><mi>r</mi> 都是常数且已知的。此外，我们拥有的唯一向量通过点积被简化为标量。唯一的未知数是
    <nobr aria-hidden="true">t</nobr><mi>t</mi>，我们有一个 <nobr aria-hidden="true">t2</nobr><msup><mi>t</mi><mn>2</mn></msup>，这意味着这个方程是二次的。你可以通过使用二次公式来解二次方程
    <nobr aria-hidden="true">ax2+bx+c=0</nobr><mi>a</mi><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mi>b</mi><mi>x</mi><mo>+</mo><mi>c</mi><mo>=</mo><mn>0</mn>：
- en: <nobr aria-hidden="true">−b±b2−4ac−−−−−−−√2a</nobr><mfrac><mrow><mo>−</mo><mi>b</mi><mo>±</mo><msqrt><msup><mi>b</mi><mn>2</mn></msup><mo>−</mo><mn>4</mn><mi>a</mi><mi>c</mi></msqrt></mrow><mrow><mn>2</mn><mi>a</mi></mrow></mfrac>
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">−b±b2−4ac−−−−−−−√2a</nobr><mfrac><mrow><mo>−</mo><mi>b</mi><mo>±</mo><msqrt><msup><mi>b</mi><mn>2</mn></msup><mo>−</mo><mn>4</mn><mi>a</mi><mi>c</mi></msqrt></mrow><mrow><mn>2</mn><mi>a</mi></mrow></mfrac>
- en: 'So solving for <nobr aria-hidden="true">t</nobr><mi>t</mi> in the ray-sphere
    intersection equation gives us these values for <nobr aria-hidden="true">a</nobr><mi>a</mi>,
    <nobr aria-hidden="true">b</nobr><mi>b</mi>, and <nobr aria-hidden="true">c</nobr><mi>c</mi>:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在求解射线与球面交点方程中的 <nobr aria-hidden="true">t</nobr><mi>t</mi> 时，我们得到了以下 <nobr
    aria-hidden="true">a</nobr><mi>a</mi>、<nobr aria-hidden="true">b</nobr><mi>b</mi>
    和 <nobr aria-hidden="true">c</nobr><mi>c</mi> 的值：
- en: <nobr aria-hidden="true">a=d⋅d</nobr><mi>a</mi><mo>=</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">d</mi></mrow><mo>⋅</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">d</mi></mrow><nobr
    aria-hidden="true">b=−2d⋅(C−Q)</nobr><mi>b</mi><mo>=</mo><mo>−</mo><mn>2</mn><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">d</mi></mrow><mo>⋅</mo><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">Q</mi></mrow><mo stretchy="false">)</mo><nobr aria-hidden="true">c=(C−Q)⋅(C−Q)−r2</nobr><mi>c</mi><mo>=</mo><mo
    stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">Q</mi></mrow><mo stretchy="false">)</mo><mo>⋅</mo><mo
    stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">Q</mi></mrow><mo stretchy="false">)</mo><mo>−</mo><msup><mi>r</mi><mn>2</mn></msup>
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">a=d⋅d</nobr><mi>a</mi><mo>=</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">d</mi></mrow><mo>⋅</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">d</mi></mrow><nobr
    aria-hidden="true">b=−2d⋅(C−Q)</nobr><mi>b</mi><mo>=</mo><mo>−</mo><mn>2</mn><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">d</mi></mrow><mo>⋅</mo><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">Q</mi></mrow><mo stretchy="false">)</mo><nobr aria-hidden="true">c=(C−Q)⋅(C−Q)−r2</nobr><mi>c</mi><mo>=</mo><mo
    stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">Q</mi></mrow><mo stretchy="false">)</mo><mo>⋅</mo><mo
    stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">Q</mi></mrow><mo stretchy="false">)</mo><mo>−</mo><msup><mi>r</mi><mn>2</mn></msup>
- en: 'Using all of the above you can solve for <nobr aria-hidden="true">t</nobr><mi>t</mi>,
    but there is a square root part that can be either positive (meaning two real
    solutions), negative (meaning no real solutions), or zero (meaning one real solution).
    In graphics, the algebra almost always relates very directly to the geometry.
    What we have is:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述所有内容，你可以解出 <nobr aria-hidden="true">t</nobr><mi>t</mi>，但其中有一个平方根部分可以是正数（意味着有两个实数解），负数（意味着没有实数解），或者零（意味着有一个实数解）。在图形学中，代数几乎总是直接与几何相关。我们得到的是：
- en: '[![](https://raytracing.github.io/images/fig-1.05-ray-sphere.jpg)](https://raytracing.github.io/images/fig-1.05-ray-sphere.jpg)**Figure 5:**
    Ray-sphere intersection results'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](https://raytracing.github.io/images/fig-1.05-ray-sphere.jpg)](https://raytracing.github.io/images/fig-1.05-ray-sphere.jpg)**图5:**
    光线与球体交点结果'
- en: Creating Our First Raytraced Image
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的第一个光线追踪图像
- en: If we take that math and hard-code it into our program, we can test our code
    by placing a small sphere at −1 on the z-axis and then coloring red any pixel
    that intersects it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个数学公式硬编码到我们的程序中，我们可以通过在z轴上放置一个小球体在-1的位置，然后为与之相交的任何像素着色红色来测试我们的代码。
- en: '[PRE15]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Listing 11:** `[main.cc]` Rendering a red sphereWhat we get is this:[![](https://raytracing.github.io/images/img-1.03-red-sphere.png)](https://raytracing.github.io/images/img-1.03-red-sphere.png)Image
    3: A simple red sphere'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表11:** `[main.cc]` 渲染红色球体我们得到的是这个：[![](https://raytracing.github.io/images/img-1.03-red-sphere.png)](https://raytracing.github.io/images/img-1.03-red-sphere.png)图像3：一个简单的红色球体'
- en: Now this lacks all sorts of things — like shading, reflection rays, and more
    than one object — but we are closer to halfway done than we are to our start!
    One thing to be aware of is that we are testing to see if a ray intersects with
    the sphere by solving the quadratic equation and seeing if a solution exists,
    but solutions with negative values of <nobr aria-hidden="true">t</nobr><mi>t</mi>
    work just fine. If you change your sphere center to <nobr aria-hidden="true">z=+1</nobr><mi>z</mi><mo>=</mo><mo>+</mo><mn>1</mn>
    you will get exactly the same picture because this solution doesn't distinguish
    between objects *in front of the camera* and objects *behind the camera*. This
    is not a feature! We’ll fix those issues next.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在缺少各种东西——比如着色、反射光线和多个对象——但我们已经比开始时更接近完成一半了！需要注意的一点是，我们通过解二次方程来测试光线是否与球体相交，并查看是否存在解，但带有负值
    <nobr aria-hidden="true">t</nobr><mi>t</mi> 的解同样有效。如果你将球体中心改为 <nobr aria-hidden="true">z=+1</nobr><mi>z</mi><mo>=</mo><mo>+</mo><mn>1</mn>，你将得到完全相同的图像，因为此解无法区分
    *相机前面的对象* 和 *相机后面的对象*。这不是一个特性！我们将在下一部分修复这些问题。
- en: Surface Normals and Multiple Objects
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表面法线和多个对象
- en: Shading with Surface Normals
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用表面法线进行着色
- en: First, let’s get ourselves a surface normal so we can shade. This is a vector
    that is perpendicular to the surface at the point of intersection.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们获取一个表面法线，以便我们可以进行着色。这是一个垂直于交点处的表面的向量。
- en: 'We have a key design decision to make for normal vectors in our code: whether
    normal vectors will have an arbitrary length, or will be normalized to unit length.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的代码中的法向量，我们需要做出一个关键的设计决策：法向量将具有任意长度，还是将被归一化到单位长度。
- en: It is tempting to skip the expensive square root operation involved in normalizing
    the vector, in case it's not needed. In practice, however, there are three important
    observations. First, if a unit-length normal vector is *ever* required, then you
    might as well do it up front once, instead of over and over again “just in case”
    for every location where unit-length is required. Second, we *do* require unit-length
    normal vectors in several places. Third, if you require normal vectors to be unit
    length, then you can often efficiently generate that vector with an understanding
    of the specific geometry class, in its constructor, or in the `hit()` function.
    For example, sphere normals can be made unit length simply by dividing by the
    sphere radius, avoiding the square root entirely.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过在归一化向量时涉及的开方运算似乎很有吸引力，以防万一不需要它。然而，在实践中，有三个重要的观察。首先，如果需要单位长度的法向量，那么最好一开始就一次性完成，而不是每次需要单位长度时都反复“以防万一”。其次，我们在几个地方确实需要单位长度的法向量。第三，如果你需要法向量具有单位长度，那么通常可以通过理解特定的几何类，在其构造函数中或在`hit()`函数中有效地生成该向量。例如，通过除以球体半径，可以简单地使球面法向量成为单位长度，从而完全避免开方运算。
- en: Given all of this, we will adopt the policy that all normal vectors will be
    of unit length.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，我们将采用所有法向量都将具有单位长度的策略。
- en: 'For a sphere, the outward normal is in the direction of the hit point minus
    the center:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于球体，外向法向量是指向入射点减去中心的方向：
- en: '[![](https://raytracing.github.io/images/fig-1.06-sphere-normal.jpg)](https://raytracing.github.io/images/fig-1.06-sphere-normal.jpg)**Figure 6:**
    Sphere surface-normal geometry'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](https://raytracing.github.io/images/fig-1.06-sphere-normal.jpg)](https://raytracing.github.io/images/fig-1.06-sphere-normal.jpg)**图6：**
    球面法向量几何'
- en: 'On the earth, this means that the vector from the earth’s center to you points
    straight up. Let’s throw that into the code now, and shade it. We don’t have any
    lights or anything yet, so let’s just visualize the normals with a color map.
    A common trick used for visualizing normals (because it’s easy and somewhat intuitive
    to assume <nobr aria-hidden="true">n</nobr><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">n</mi></mrow>
    is a unit length vector — so each component is between −1 and 1) is to map each
    component to the interval from 0 to 1, and then map <nobr aria-hidden="true">(x,y,z)</nobr><mo
    stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo>
    to <nobr aria-hidden="true">(red,green,blue)</nobr><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit" mathvariant="italic">r</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">e</mi><mi class="MJX-tex-mathit" mathvariant="italic">d</mi></mrow><mo>,</mo><mrow
    class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit" mathvariant="italic">g</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">r</mi><mi class="MJX-tex-mathit" mathvariant="italic">e</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">e</mi><mi class="MJX-tex-mathit" mathvariant="italic">n</mi></mrow><mo>,</mo><mrow
    class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit" mathvariant="italic">b</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">l</mi><mi class="MJX-tex-mathit" mathvariant="italic">u</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">e</mi></mrow><mo stretchy="false">)</mo>.
    For the normal, we need the hit point, not just whether we hit or not (which is
    all we''re calculating at the moment). We only have one sphere in the scene, and
    it''s directly in front of the camera, so we won''t worry about negative values
    of <nobr aria-hidden="true">t</nobr><mi>t</mi> yet. We''ll just assume the closest
    hit point (smallest <nobr aria-hidden="true">t</nobr><mi>t</mi>) is the one that
    we want. These changes in the code let us compute and visualize <nobr aria-hidden="true">n</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">n</mi></mrow>:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '在地球上，这意味着从地球中心到你的向量直接向上。现在让我们将其加入代码中，并对其进行着色。我们目前还没有任何光源或其他东西，所以让我们用颜色图来可视化法线。用于可视化法线的一个常见技巧（因为它简单且直观，可以假设
    <nobr aria-hidden="true">n</nobr><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">n</mi></mrow>
    是一个单位长度向量——因此每个分量都在 -1 和 1 之间）是将每个分量映射到 0 到 1 的区间，然后将 <nobr aria-hidden="true">(x,y,z)</nobr><mo
    stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo>
    映射到 <nobr aria-hidden="true">(red,green,blue)</nobr><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit" mathvariant="italic">r</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">e</mi><mi class="MJX-tex-mathit" mathvariant="italic">d</mi></mrow><mo>,</mo><mrow
    class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit" mathvariant="italic">g</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">r</mi><mi class="MJX-tex-mathit" mathvariant="italic">e</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">e</mi><mi class="MJX-tex-mathit" mathvariant="italic">n</mi></mrow><mo>,</mo><mrow
    class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit" mathvariant="italic">b</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">l</mi><mi class="MJX-tex-mathit" mathvariant="italic">u</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">e</mi></mrow><mo stretchy="false">)</mo>.
    对于法线，我们需要击中点，而不仅仅是是否击中（这是我们目前所计算的全部）。场景中只有一个球体，并且它正位于摄像机前方，所以我们暂时不用担心 <nobr aria-hidden="true">t</nobr><mi>t</mi>
    的负值。我们只需假设最近的击中点（最小的 <nobr aria-hidden="true">t</nobr><mi>t</mi>）是我们想要的点。这些代码中的更改使我们能够计算和可视化
    <nobr aria-hidden="true">n</nobr><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">n</mi></mrow>:'
- en: '[PRE16]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Listing 12:** `[main.cc]` Rendering surface normals on a sphereAnd that yields
    this picture:[![](https://raytracing.github.io/images/img-1.04-normals-sphere.png)](https://raytracing.github.io/images/img-1.04-normals-sphere.png)Image
    4: A sphere colored according to its normal vectors'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 12:** `[main.cc]` 在球面上渲染表面法线'
- en: Simplifying the Ray-Sphere Intersection Code
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化射线-球面交点代码
- en: 'Let’s revisit the ray-sphere function:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视射线-球面函数：
- en: '[PRE17]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Listing 13:** `[main.cc]` Ray-sphere intersection code (before)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 13:** `[main.cc]` 射线-球面交点代码（之前）'
- en: First, recall that a vector dotted with itself is equal to the squared length
    of that vector.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 首先回忆一下，一个向量与自身的点积等于该向量的长度的平方。
- en: 'Second, notice how the equation for `b` has a factor of negative two in it.
    Consider what happens to the quadratic equation if <nobr aria-hidden="true">b=−2h</nobr><mi>b</mi><mo>=</mo><mo>−</mo><mn>2</mn><mi>h</mi>:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，注意 `b` 的方程中有一个负二的因子。考虑如果 <nobr aria-hidden="true">b=−2h</nobr><mi>b</mi><mo>=</mo><mo>−</mo><mn>2</mn><mi>h</mi>
    发生在二次方程上会发生什么：
- en: <nobr aria-hidden="true">−b±b2−4ac−−−−−−−√2a</nobr><mfrac><mrow><mo>−</mo><mi>b</mi><mo>±</mo><msqrt><msup><mi>b</mi><mn>2</mn></msup><mo>−</mo><mn>4</mn><mi>a</mi><mi>c</mi></msqrt></mrow><mrow><mn>2</mn><mi>a</mi></mrow></mfrac><nobr
    aria-hidden="true">=−(−2h)±(−2h)2−4ac−−−−−−−−−−−√2a</nobr><mo>=</mo><mfrac><mrow><mo>−</mo><mo
    stretchy="false">(</mo><mo>−</mo><mn>2</mn><mi>h</mi><mo stretchy="false">)</mo><mo>±</mo><msqrt><mo
    stretchy="false">(</mo><mo>−</mo><mn>2</mn><mi>h</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>−</mo><mn>4</mn><mi>a</mi><mi>c</mi></msqrt></mrow><mrow><mn>2</mn><mi>a</mi></mrow></mfrac><nobr
    aria-hidden="true">=2h±2h2−ac−−−−−−√2a</nobr><mo>=</mo><mfrac><mrow><mn>2</mn><mi>h</mi><mo>±</mo><mn>2</mn><msqrt><msup><mi>h</mi><mn>2</mn></msup><mo>−</mo><mi>a</mi><mi>c</mi></msqrt></mrow><mrow><mn>2</mn><mi>a</mi></mrow></mfrac><nobr
    aria-hidden="true">=h±h2−ac−−−−−−√a</nobr><mo>=</mo><mfrac><mrow><mi>h</mi><mo>±</mo><msqrt><msup><mi>h</mi><mn>2</mn></msup><mo>−</mo><mi>a</mi><mi>c</mi></msqrt></mrow><mi>a</mi></mfrac>
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">−b±b2−4ac−−−−−−−√2a</nobr><mfrac><mrow><mo>−</mo><mi>b</mi><mo>±</mo><msqrt><msup><mi>b</mi><mn>2</mn></msup><mo>−</mo><mn>4</mn><mi>a</mi><mi>c</mi></msqrt></mrow><mrow><mn>2</mn><mi>a</mi></mrow></mfrac><nobr
    aria-hidden="true">=−(−2h)±(−2h)2−4ac−−−−−−−−−−−√2a</nobr><mo>=</mo><mfrac><mrow><mo>−</mo><mo
    stretchy="false">(</mo><mo>−</mo><mn>2</mn><mi>h</mi><mo stretchy="false">)</mo><mo>±</mo><msqrt><mo
    stretchy="false">(</mo><mo>−</mo><mn>2</mn><mi>h</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>−</mo><mn>4</mn><mi>a</mi><mi>c</mi></msqrt></mrow><mrow><mn>2</mn><mi>a</mi></mrow></mfrac><nobr
    aria-hidden="true">=2h±2h2−ac−−−−−−√2a</nobr><mo>=</mo><mfrac><mrow><mn>2</mn><mi>h</mi><mo>±</mo><mn>2</mn><msqrt><msup><mi>h</mi><mn>2</mn></msup><mo>−</mo><mi>a</mi><mi>c</mi></msqrt></mrow><mrow><mn>2</mn><mi>a</mi></mrow></mfrac><nobr
    aria-hidden="true">=h±h2−ac−−−−−−√a</nobr><mo>=</mo><mfrac><mrow><mi>h</mi><mo>±</mo><msqrt><msup><mi>h</mi><mn>2</mn></msup><mo>−</mo><mi>a</mi><mi>c</mi></msqrt></mrow><mi>a</mi></mfrac>
- en: 'This simplifies nicely, so we''ll use it. So solving for <nobr aria-hidden="true">h</nobr><mi>h</mi>:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这简化得很好，所以我们将使用它。因此，求解 <nobr aria-hidden="true">h</nobr><mi>h</mi>：
- en: '<nobr aria-hidden="true">b=−2d⋅(C−Q)</nobr><mi>b</mi><mo>=</mo><mo>−</mo><mn>2</mn><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">d</mi></mrow><mo>⋅</mo><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">Q</mi></mrow><mo stretchy="false">)</mo><nobr aria-hidden="true">b=−2h</nobr><mi>b</mi><mo>=</mo><mo>−</mo><mn>2</mn><mi>h</mi><nobr
    aria-hidden="true">h=b−2=d⋅(C−Q)</nobr><mi>h</mi><mo>=</mo><mfrac><mi>b</mi><mrow><mo>−</mo><mn>2</mn></mrow></mfrac><mo>=</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">d</mi></mrow><mo>⋅</mo><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">Q</mi></mrow><mo stretchy="false">)</mo>Using these observations,
    we can now simplify the sphere-intersection code to this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">b=−2d⋅(C−Q)</nobr><mi>b</mi><mo>=</mo><mo>−</mo><mn>2</mn><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">d</mi></mrow><mo>⋅</mo><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">Q</mi></mrow><mo stretchy="false">)</mo><nobr aria-hidden="true">b=−2h</nobr><mi>b</mi><mo>=</mo><mo>−</mo><mn>2</mn><mi>h</mi><nobr
    aria-hidden="true">h=b−2=d⋅(C−Q)</nobr><mi>h</mi><mo>=</mo><mfrac><mi>b</mi><mrow><mo>−</mo><mn>2</mn></mrow></mfrac><mo>=</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">d</mi></mrow><mo>⋅</mo><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">C</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">Q</mi></mrow><mo stretchy="false">)</mo>使用这些观察结果，我们现在可以将球面交点代码简化为以下形式：
- en: '[PRE18]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Listing 14:** `[main.cc]` Ray-sphere intersection code (after)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 14:** `[main.cc]` 射线与球面交点代码（之后）'
- en: An Abstraction for Hittable Objects
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hittable对象的抽象
- en: Now, how about more than one sphere? While it is tempting to have an array of
    spheres, a very clean solution is to make an “abstract class” for anything a ray
    might hit, and make both a sphere and a list of spheres just something that can
    be hit. What that class should be called is something of a quandary — calling
    it an “object” would be good if not for “object oriented” programming. “Surface”
    is often used, with the weakness being maybe we will want volumes (fog, clouds,
    stuff like that). “hittable” emphasizes the member function that unites them.
    I don’t love any of these, but we'll go with “hittable”.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果有多个球面呢？虽然使用球面数组很诱人，但一个更干净的方法是创建一个“抽象类”，用于任何射线可能击中的对象，并使球面和球面列表都成为可以被击中的对象。这个类应该叫什么名字有些令人困惑——如果它不是面向对象的编程，那么叫“对象”会很好。“表面”经常被使用，但缺点可能是我们可能还想有体积（雾、云等）。
    “可击中”强调将它们联系在一起的成员函数。我不喜欢这些中的任何一个，但我们将使用“可击中”。
- en: 'This `hittable` abstract class will have a `hit` function that takes in a ray.
    Most ray tracers have found it convenient to add a valid interval for hits <nobr
    aria-hidden="true">tmin</nobr><msub><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mrow
    class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit" mathvariant="italic">m</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">i</mi><mi class="MJX-tex-mathit" mathvariant="italic">n</mi></mrow></mrow></msub>
    to <nobr aria-hidden="true">tmax</nobr><msub><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mrow
    class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit" mathvariant="italic">m</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">a</mi><mi class="MJX-tex-mathit" mathvariant="italic">x</mi></mrow></mrow></msub>,
    so the hit only “counts” if <nobr aria-hidden="true">tmin<t<tmax</nobr><msub><mi>t</mi><mrow
    class="MJX-TeXAtom-ORD"><mrow class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit"
    mathvariant="italic">m</mi><mi class="MJX-tex-mathit" mathvariant="italic">i</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">n</mi></mrow></mrow></msub><mo><</mo><mi>t</mi><mo><</mo><msub><mi>t</mi><mrow
    class="MJX-TeXAtom-ORD"><mrow class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit"
    mathvariant="italic">m</mi><mi class="MJX-tex-mathit" mathvariant="italic">a</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">x</mi></mrow></mrow></msub>. For the
    initial rays this is positive <nobr aria-hidden="true">t</nobr><mi>t</mi>, but
    as we will see, it can simplify our code to have an interval <nobr aria-hidden="true">tmin</nobr><msub><mi>t</mi><mrow
    class="MJX-TeXAtom-ORD"><mrow class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit"
    mathvariant="italic">m</mi><mi class="MJX-tex-mathit" mathvariant="italic">i</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">n</mi></mrow></mrow></msub> to <nobr
    aria-hidden="true">tmax</nobr><msub><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mrow
    class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit" mathvariant="italic">m</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">a</mi><mi class="MJX-tex-mathit" mathvariant="italic">x</mi></mrow></mrow></msub>.
    One design question is whether to do things like compute the normal if we hit
    something. We might end up hitting something closer as we do our search, and we
    will only need the normal of the closest thing. I will go with the simple solution
    and compute a bundle of stuff I will store in some structure. Here’s the abstract
    class:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`hittable`抽象类将有一个接受光线作为参数的`hit`函数。大多数光线追踪器发现添加一个有效的碰撞时间间隔（`<nobr aria-hidden="true">tmin</nobr><msub><mi>t</mi><mrow
    class="MJX-TeXAtom-ORD"><mrow class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit"
    mathvariant="italic">m</mi><mi class="MJX-tex-mathit" mathvariant="italic">i</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">n</mi></mrow></mrow></msub>`到`<nobr
    aria-hidden="true">tmax</nobr><msub><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mrow
    class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit" mathvariant="italic">m</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">a</mi><mi class="MJX-tex-mathit" mathvariant="italic">x</mi></mrow></mrow></msub>`的有效区间很方便，这样碰撞只有在`<nobr
    aria-hidden="true">tmin<t<tmax</nobr><msub><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mrow
    class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit" mathvariant="italic">m</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">i</mi><mi class="MJX-tex-mathit" mathvariant="italic">n</mi></mrow></mrow></msub><mo><</mo><mi>t</mi><mo><</mo><msub><mi>t</mi><mrow
    class="MJX-TeXAtom-ORD"><mrow class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit"
    mathvariant="italic">m</mi><mi class="MJX-tex-mathit" mathvariant="italic">a</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">x</mi></mrow></mrow></msub>`时才“计算”在内。对于初始光线，这是正的`<nobr
    aria-hidden="true">t</nobr><mi>t</mi>`，但正如我们将看到的，将时间间隔`<nobr aria-hidden="true">tmin</nobr><msub><mi>t</mi><mrow
    class="MJX-TeXAtom-ORD"><mrow class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit"
    mathvariant="italic">m</mi><mi class="MJX-tex-mathit" mathvariant="italic">i</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">n</mi></mrow></mrow></msub>`到`<nobr
    aria-hidden="true">tmax</nobr><msub><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mrow
    class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit" mathvariant="italic">m</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">a</mi><mi class="MJX-tex-mathit" mathvariant="italic">x</mi></mrow></mrow></msub>`简化我们的代码是有帮助的。一个设计问题是，如果我们碰撞到某个物体，是否要计算法线。在我们进行搜索的过程中，我们可能会遇到更近的物体，我们只需要最近物体的法线。我将采用简单的解决方案，计算一些我将存储在某种结构中的东西。以下是抽象类：
- en: '[PRE19]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Listing 15:** `[hittable.h]` The hittable classAnd here’s the sphere:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表15**：`[hittable.h]` 可碰撞类，以及这里的球体：'
- en: '[PRE20]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Listing 16:** `[sphere.h]` The sphere class'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表16**：`[sphere.h]` 球体类'
- en: (Note here that we use the C++ standard function `std::fmax()`, which returns
    the maximum of the two floating-point arguments. Similarly, we will later use
    `std::fmin()`, which returns the minimum of the two floating-point arguments.)
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: （注意这里我们使用C++标准函数`std::fmax()`，它返回两个浮点数参数中的最大值。同样，我们稍后还会使用`std::fmin()`，它返回两个浮点数参数中的最小值。）
- en: Front Faces Versus Back Faces
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前面与后面
- en: The second design decision for normals is whether they should always point out.
    At present, the normal found will always be in the direction of the center to
    the intersection point (the normal points out). If the ray intersects the sphere
    from the outside, the normal points against the ray. If the ray intersects the
    sphere from the inside, the normal (which always points out) points with the ray.
    Alternatively, we can have the normal always point against the ray. If the ray
    is outside the sphere, the normal will point outward, but if the ray is inside
    the sphere, the normal will point inward.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 正常向量的第二个设计决策是它们是否应该始终指向外部。目前，找到的正常向量始终指向中心到交点的方向（正常向量指向外部）。如果光线从外部与球体相交，则正常向量与光线方向相反。如果光线从内部与球体相交，则正常向量（始终指向外部）与光线方向相同。或者，我们也可以让正常向量始终与光线方向相反。如果光线在球体外部，则正常向量指向外部，但如果光线在球体内部，则正常向量指向内部。
- en: '[![](https://raytracing.github.io/images/fig-1.07-normal-sides.jpg)](https://raytracing.github.io/images/fig-1.07-normal-sides.jpg)**Figure 7:**
    Possible directions for sphere surface-normal geometry'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7：球面表面法线几何的可能方向](https://raytracing.github.io/images/fig-1.07-normal-sides.jpg)**图
    7：** 球面表面法线几何的可能方向'
- en: We need to choose one of these possibilities because we will eventually want
    to determine which side of the surface that the ray is coming from. This is important
    for objects that are rendered differently on each side, like the text on a two-sided
    sheet of paper, or for objects that have an inside and an outside, like glass
    balls.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要选择这些可能性之一，因为我们最终想要确定光线来自表面的哪一侧。这对于在每一侧渲染不同的物体很重要，比如两面纸上的文字，或者对于具有内外侧的物体，如玻璃球。
- en: If we decide to have the normals always point out, then we will need to determine
    which side the ray is on when we color it. We can figure this out by comparing
    the ray with the normal. If the ray and the normal face in the same direction,
    the ray is inside the object, if the ray and the normal face in the opposite direction,
    then the ray is outside the object. This can be determined by taking the dot product
    of the two vectors, where if their dot is positive, the ray is inside the sphere.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定让法线始终指向外部，那么在着色时我们需要确定光线所在的一侧。我们可以通过比较光线与法线来解决这个问题。如果光线和法线方向相同，则光线在物体内部；如果光线和法线方向相反，则光线在物体外部。这可以通过计算两个向量的点积来确定，如果点积为正，则光线在球体内部。
- en: '[PRE21]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Listing 17:** Comparing the ray and the normalIf we decide to have the normals
    always point against the ray, we won''t be able to use the dot product to determine
    which side of the surface the ray is on. Instead, we would need to store that
    information:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 17：比较光线和法线**如果我们决定让法线始终指向光线方向，我们就无法使用点积来确定光线在表面的哪一侧。相反，我们需要存储该信息：'
- en: '[PRE22]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Listing 18:** Remembering the side of the surface'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 18：记住表面的侧面**'
- en: We can set things up so that normals always point “outward” from the surface,
    or always point against the incident ray. This decision is determined by whether
    you want to determine the side of the surface at the time of geometry intersection
    or at the time of coloring. In this book we have more material types than we have
    geometry types, so we'll go for less work and put the determination at geometry
    time. This is simply a matter of preference, and you'll see both implementations
    in the literature.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设置法线始终指向表面“外部”或始终指向入射光线。这个决策取决于你是在几何相交时还是着色时确定表面的一侧。在这本书中，我们拥有的材质类型比几何类型多，所以我们将选择更简单的方法，在几何时间进行确定。这仅仅是一个偏好问题，你将在文献中看到两种实现。
- en: 'We add the `front_face` bool to the `hit_record` class. We''ll also add a function
    to solve this calculation for us: `set_face_normal()`. For convenience we will
    assume that the vector passed to the new `set_face_normal()` function is of unit
    length. We could always normalize the parameter explicitly, but it''s more efficient
    if the geometry code does this, as it''s usually easier when you know more about
    the specific geometry.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `front_face` 布尔值添加到 `hit_record` 类中。我们还将添加一个函数来帮助我们进行这个计算：`set_face_normal()`。为了方便，我们将假设传递给新
    `set_face_normal()` 函数的向量是单位长度。我们始终可以显式地规范化参数，但如果几何代码这样做更有效，因为通常在了解特定几何时更容易。
- en: '[PRE23]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Listing 19:** `[hittable.h]` Adding front-face tracking to hit_recordAnd
    then we add the surface side determination to the class:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 19：`[hittable.h]` 添加前侧面跟踪到 hit_record 然后我们将表面侧面确定添加到类中：'
- en: '[PRE24]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Listing 20:** `[sphere.h]` The sphere class with normal determination'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 20**：`[sphere.h]` 具有正常确定的球类'
- en: A List of Hittable Objects
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可击中对象的列表
- en: 'We have a generic object called a `hittable` that the ray can intersect with.
    We now add a class that stores a list of `hittable`s:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为 `hittable` 的通用对象，射线可以与之相交。我们现在添加一个存储 `hittable` 列表的类：
- en: '[PRE25]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Listing 21:** `[hittable_list.h]` The hittable_list class'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 21**：`[hittable_list.h]` hittable_list 类'
- en: Some New C++ Features
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些新的 C++ 特性
- en: 'The `hittable_list` class code uses some C++ features that may trip you up
    if you''re not normally a C++ programmer: `vector`, `shared_ptr`, and `make_shared`.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`hittable_list` 类的代码使用了某些可能让你感到困惑的 C++ 特性：`vector`、`shared_ptr` 和 `make_shared`。'
- en: '`shared_ptr<type>` is a pointer to some allocated type, with reference-counting
    semantics. Every time you assign its value to another shared pointer (usually
    with a simple assignment), the reference count is incremented. As shared pointers
    go out of scope (like at the end of a block or function), the reference count
    is decremented. Once the count goes to zero, the object is safely deleted.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr<type>` 是指向已分配类型的指针，具有引用计数语义。每次将它的值赋给另一个共享指针（通常使用简单的赋值），引用计数就会增加。当共享指针超出作用域（例如在块或函数的末尾）时，引用计数就会减少。一旦计数达到零，对象就会被安全地删除。'
- en: 'Typically, a shared pointer is first initialized with a newly-allocated object,
    something like this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，共享指针首先用新分配的对象进行初始化，例如：
- en: '[PRE26]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Listing 22:** An example allocation using shared_ptr'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 22**：使用 `shared_ptr` 的一个示例分配'
- en: '`make_shared<thing>(thing_constructor_params ...)` allocates a new instance
    of type `thing`, using the constructor parameters. It returns a `shared_ptr<thing>`.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_shared<thing>(thing_constructor_params ...)` 使用构造函数参数分配 `thing` 类型的新实例。它返回一个
    `shared_ptr<thing>`。'
- en: 'Since the type can be automatically deduced by the return type of `make_shared<type>(...)`,
    the above lines can be more simply expressed using C++''s `auto` type specifier:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型可以由 `make_shared<type>(...)` 的返回类型自动推导，因此上述行可以使用 C++ 的 `auto` 类型说明符更简单地表达：
- en: '[PRE27]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Listing 23:** An example allocation using shared_ptr with auto type'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 23**：使用 `shared_ptr` 和 `auto` 类型的一个示例分配'
- en: We'll use shared pointers in our code, because it allows multiple geometries
    to share a common instance (for example, a bunch of spheres that all use the same
    color material), and because it makes memory management automatic and easier to
    reason about.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在代码中使用共享指针，因为它允许多个几何体共享一个公共实例（例如，使用相同颜色材料的多个球体），并且因为它使内存管理自动化，更容易推理。
- en: '`std::shared_ptr` is included with the `<memory>` header.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::shared_ptr` 包含在 `<memory>` 头文件中。'
- en: 'The second C++ feature you may be unfamiliar with is `std::vector`. This is
    a generic array-like collection of an arbitrary type. Above, we use a collection
    of pointers to `hittable`. `std::vector` automatically grows as more values are
    added: `objects.push_back(object)` adds a value to the end of the `std::vector`
    member variable `objects`.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不熟悉的第二个 C++ 特性是 `std::vector`。这是一个类似于任意类型的数组样式的通用集合。上面，我们使用指向 `hittable`
    的指针集合。`std::vector` 会随着添加更多值而自动增长：`objects.push_back(object)` 将一个值添加到 `std::vector`
    成员变量 `objects` 的末尾。
- en: '`std::vector` is included with the `<vector>` header.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector` 包含在 `<vector>` 头文件中。'
- en: Finally, the `using` statements in [listing 21](#listing_hittable-list-initial)
    tell the compiler that we'll be getting `shared_ptr` and `make_shared` from the
    `std` library, so we don't need to prefix these with `std::` every time we reference
    them.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[列表 21](#listing_hittable-list-initial) 中的 `using` 语句告诉编译器我们将从 `std` 库中获取
    `shared_ptr` 和 `make_shared`，因此我们每次引用它们时不需要前缀 `std::`。
- en: Common Constants and Utility Functions
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常用常量和实用函数
- en: We need some math constants that we conveniently define in their own header
    file. For now we only need infinity, but we will also throw our own definition
    of pi in there, which we will need later. We'll also throw common useful constants
    and future utility functions in here. This new header, `rtweekend.h`, will be
    our general main header file.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些数学常量，我们将它们方便地定义在自己的头文件中。现在我们只需要无穷大，但我们也会在那里抛出我们自己的 pi 定义，我们稍后会需要。我们还将在这里放置一些常用的常量和未来的实用函数。这个新的头文件
    `rtweekend.h` 将是我们的通用主头文件。
- en: '[PRE28]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Listing 24:** `[rtweekend.h]` The rtweekend.h common header'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 24**：`[rtweekend.h]` rtweekend.h 公共头文件'
- en: Program files will include `rtweekend.h` first, so all other header files (where
    the bulk of our code will reside) can implicitly assume that `rtweekend.h` has
    already been included. Header files still need to explicitly include any other
    necessary header files. We'll make some updates with these assumptions in mind.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 程序文件将首先包含 `rtweekend.h`，因此所有其他头文件（我们的代码将驻留的地方）可以隐式地假设 `rtweekend.h` 已经被包含。头文件仍然需要显式地包含任何其他必要的头文件。我们将基于这些假设进行一些更新。
- en: '[PRE29]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Listing 25:** `[color.h]` Assume rtweekend.h inclusion for color.h'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 25:** `[color.h]` 假设包含 rtweekend.h 的 color.h'
- en: '[PRE30]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Listing 26:** `[hittable.h]` Assume rtweekend.h inclusion for hittable.h'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 26:** `[hittable.h]` 假设包含 rtweekend.h 的 hittable.h'
- en: '[PRE31]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Listing 27:** `[hittable_list.h]` Assume rtweekend.h inclusion for hittable_list.h'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 27:** `[hittable_list.h]` 假设包含 rtweekend.h 的 hittable_list.h'
- en: '[PRE32]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Listing 28:** `[sphere.h]` Assume rtweekend.h inclusion for sphere.h'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 28:** `[sphere.h]` 假设包含 rtweekend.h 的 sphere.h'
- en: '[PRE33]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Listing 29:** `[vec3.h]` Assume rtweekend.h inclusion for vec3.hAnd now the
    new main:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 29:** `[vec3.h]` 假设包含 rtweekend.h 的 vec3.h，现在的新主程序：'
- en: '[PRE34]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Listing 30:** `[main.cc]` The new main with hittables'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 30:** `[main.cc]` 带有可碰撞体的新主程序'
- en: This yields a picture that is really just a visualization of where the spheres
    are located along with their surface normal. This is often a great way to view
    any flaws or specific characteristics of a geometric model.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生一个图，实际上只是对球体位置及其表面法线的可视化。这通常是查看任何几何模型缺陷或特定特征的好方法。
- en: '[![](https://raytracing.github.io/images/img-1.05-normals-sphere-ground.png)](https://raytracing.github.io/images/img-1.05-normals-sphere-ground.png)Image
    5: Resulting render of normals-colored sphere with ground'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](https://raytracing.github.io/images/img-1.05-normals-sphere-ground.png)](https://raytracing.github.io/images/img-1.05-normals-sphere-ground.png)
    图 5：带有地面的法线着色球体的渲染结果'
- en: An Interval Class
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区间类
- en: Before we continue, we'll implement an interval class to manage real-valued
    intervals with a minimum and a maximum. We'll end up using this class quite often
    as we proceed.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们将实现一个区间类来管理具有最小值和最大值的实值区间。随着我们的进行，我们将经常使用这个类。
- en: '[PRE35]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Listing 31:** `[interval.h]` Introducing the new interval class'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 31:** `[interval.h]` 介绍新的区间类'
- en: '[PRE36]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Listing 32:** `[rtweekend.h]` Including the new interval class'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 32:** `[rtweekend.h]` 包含新的区间类'
- en: '[PRE37]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Listing 33:** `[hittable.h]` hittable::hit() using interval'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 33:** `[hittable.h]` 使用区间进行 hittable::hit()'
- en: '[PRE38]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**Listing 34:** `[hittable_list.h]` hittable_list::hit() using interval'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 34:** `[hittable_list.h]` 使用区间进行 hittable_list::hit()'
- en: '[PRE39]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**Listing 35:** `[sphere.h]` sphere using interval'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 35:** `[sphere.h]` 使用区间进行 sphere'
- en: '[PRE40]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Listing 36:** `[main.cc]` The new main using interval'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 36:** `[main.cc]` 使用区间的新主程序'
- en: Moving Camera Code Into Its Own Class
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将摄像机代码移动到自己的类中
- en: 'Before continuing, now is a good time to consolidate our camera and scene-render
    code into a single new class: the `camera` class. The camera class will be responsible
    for two important jobs:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，现在是一个将我们的摄像机和场景渲染代码合并到单个新类中的好时机：`camera` 类。摄像机类将负责两个重要的任务：
- en: Construct and dispatch rays into the world.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并将射线派发到世界中。
- en: Use the results of these rays to construct the rendered image.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这些射线的成果来构建渲染图像。
- en: In this refactoring, we'll collect the `ray_color()` function, along with the
    image, camera, and render sections of our main program. The new camera class will
    contain two public methods `initialize()` and `render()`, plus two private helper
    methods `get_ray()` and `ray_color()`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次重构中，我们将收集 `ray_color()` 函数，以及主程序中的图像、摄像机和渲染部分。新的摄像机类将包含两个公共方法 `initialize()`
    和 `render()`，以及两个私有辅助方法 `get_ray()` 和 `ray_color()`。
- en: 'Ultimately, the camera will follow the simplest usage pattern that we could
    think of: it will be default constructed no arguments, then the owning code will
    modify the camera''s public variables through simple assignment, and finally everything
    is initialized by a call to the `initialize()` function. This pattern is chosen
    instead of the owner calling a constructor with a ton of parameters or by defining
    and calling a bunch of setter methods. Instead, the owning code only needs to
    set what it explicitly cares about. Finally, we could either have the owning code
    call `initialize()`, or just have the camera call this function automatically
    at the start of `render()`. We''ll use the second approach.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，摄像机将遵循我们所能想到的最简单使用模式：默认构造无参数，然后拥有代码将通过简单赋值修改摄像机的公共变量，最后通过调用 `initialize()`
    函数初始化一切。我们选择这种模式而不是拥有者调用带有大量参数的构造函数或定义并调用一大堆设置方法。相反，拥有代码只需要设置它明确关心的部分。最后，我们既可以由拥有代码调用
    `initialize()`，也可以让摄像机在 `render()` 函数开始时自动调用此函数。我们将采用第二种方法。
- en: After main creates a camera and sets default values, it will call the `render()`
    method. The `render()` method will prepare the camera for rendering and then execute
    the render loop.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 创建摄像机并设置默认值后，它将调用 `render()` 方法。`render()` 方法将准备摄像机进行渲染，然后执行渲染循环。
- en: 'Here''s the skeleton of our new `camera` class:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的新 `camera` 类的骨架：
- en: '[PRE41]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Listing 37:** `[camera.h]` The camera class skeletonTo begin with, let''s
    fill in the `ray_color()` function from `main.cc`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 37:** `[camera.h]` 摄像机类骨架首先，让我们从 `main.cc` 中填充 `ray_color()` 函数：'
- en: '[PRE42]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**Listing 38:** `[camera.h]` The camera::ray_color functionNow we move almost
    everything from the `main()` function into our new camera class. The only thing
    remaining in the `main()` function is the world construction. Here''s the camera
    class with newly migrated code:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 38:** `[camera.h]` camera::ray_color 函数现在我们将几乎所有的内容从 `main()` 函数移入我们新的摄像机类。在
    `main()` 函数中剩下的唯一事情是世界的构建。以下是带有新迁移代码的摄像机类：'
- en: '[PRE43]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**Listing 39:** `[camera.h]` The working camera classAnd here''s the much reduced
    main:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 39:** `[camera.h]` 工作摄像机类以下是大大简化后的主函数：'
- en: '[PRE44]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**Listing 40:** `[main.cc]` The new main, using the new camera'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 40:** `[main.cc]` 使用新摄像机的新的主函数'
- en: Running this newly refactored program should give us the same rendered image
    as before.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个新重构的程序应该会给出与之前相同的渲染图像。
- en: Antialiasing
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抗锯齿
- en: If you zoom into the rendered images so far, you might notice the harsh “stair
    step” nature of edges in our rendered images. This stair-stepping is commonly
    referred to as “aliasing”, or “jaggies”. When a real camera takes a picture, there
    are usually no jaggies along edges, because the edge pixels are a blend of some
    foreground and some background. Consider that unlike our rendered images, a true
    image of the world is continuous. Put another way, the world (and any true image
    of it) has effectively infinite resolution. We can get the same effect by averaging
    a bunch of samples for each pixel.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将渲染图像放大，你可能会注意到我们渲染图像中边缘的“阶梯”性质。这种阶梯通常被称为“混叠”，或“锯齿”。当真实相机拍照时，通常沿着边缘没有锯齿，因为边缘像素是前景和背景的一些混合。考虑到我们的渲染图像与我们的渲染图像不同，真实世界的图像是连续的。换句话说，世界（以及它的任何真实图像）实际上具有无限分辨率。我们可以通过为每个像素平均大量样本来达到相同的效果。
- en: 'With a single ray through the center of each pixel, we are performing what
    is commonly called *point sampling*. The problem with point sampling can be illustrated
    by rendering a small checkerboard far away. If this checkerboard consists of an
    8×8 grid of black and white tiles, but only four rays hit it, then all four rays
    might intersect only white tiles, or only black, or some odd combination. In the
    real world, when we perceive a checkerboard far away with our eyes, we perceive
    it as a gray color, instead of sharp points of black and white. That''s because
    our eyes are naturally doing what we want our ray tracer to do: integrate the
    (continuous function of) light falling on a particular (discrete) region of our
    rendered image.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 通过每个像素中心的单个光线，我们正在执行通常称为 *点采样* 的操作。点采样的问题可以通过渲染一个远离的小棋盘来展示。如果这个棋盘由一个 8×8 的黑白瓷砖网格组成，但只有四个光线击中它，那么这四个光线可能只与白色瓷砖相交，或者只与黑色瓷砖相交，或者某种奇特的组合。在现实世界中，当我们用眼睛看一个远离的棋盘时，我们感知到的是灰色，而不是黑白分明的尖锐点。这是因为我们的眼睛自然地做了我们希望我们的光线追踪器做的事情：整合落在我们的渲染图像特定（离散）区域上的（连续函数）光线。
- en: Clearly we don't gain anything by just resampling the same ray through the pixel
    center multiple times — we'd just get the same result each time. Instead, we want
    to sample the light falling *around* the pixel, and then integrate those samples
    to approximate the true continuous result. So, how do we integrate the light falling
    around the pixel?
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，仅仅通过多次在像素中心重新采样相同的射线并不会带来任何好处——我们每次都会得到相同的结果。相反，我们希望采样围绕像素的光，然后对这些样本进行积分以近似真正的连续结果。那么，我们如何积分围绕像素的光呢？
- en: 'We''ll adopt the simplest model: sampling the square region centered at the
    pixel that extends halfway to each of the four neighboring pixels. This is not
    the optimal approach, but it is the most straight-forward. (See [*A Pixel is Not
    a Little Square*](https://www.researchgate.net/publication/244986797) for a deeper
    dive into this topic.)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用最简单的模型：采样以像素为中心的方形区域，该区域延伸到四个相邻像素的中间。这不是最佳方法，但是最直接的方法。（参见[*一个像素不是一个小方块*](https://www.researchgate.net/publication/244986797)深入了解此主题。）
- en: '[![](https://raytracing.github.io/images/fig-1.08-pixel-samples.jpg)](https://raytracing.github.io/images/fig-1.08-pixel-samples.jpg)**Figure 8:**
    Pixel samples'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](https://raytracing.github.io/images/fig-1.08-pixel-samples.jpg)](https://raytracing.github.io/images/fig-1.08-pixel-samples.jpg)**图
    8:** 像素采样'
- en: Some Random Number Utilities
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些随机数实用工具
- en: We're going to need a random number generator that returns real random numbers.
    This function should return a canonical random number, which by convention falls
    in the range <nobr aria-hidden="true">0≤n<1</nobr><mn>0</mn><mo>≤</mo><mi>n</mi><mo><</mo><mn>1</mn>.
    The “less than” before the 1 is important, as we will sometimes take advantage
    of that.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个返回实数随机数的随机数生成器。此函数应返回一个规范化的随机数，按照惯例，它落在范围<nobr aria-hidden="true">0≤n<1</nobr><mn>0</mn><mo>≤</mo><mi>n</mi><mo><</mo><mn>1</mn>内。在1之前的重要的“小于”符号，因为我们有时会利用这一点。
- en: 'A simple approach to this is to use the `std::rand()` function that can be
    found in `<cstdlib>`, which returns a random integer in the range 0 and `RAND_MAX`.
    Hence we can get a real random number as desired with the following code snippet,
    added to `rtweekend.h`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的方法是使用`<cstdlib>`中可找到的`std::rand()`函数，它返回0到`RAND_MAX`范围内的随机整数。因此，我们可以通过以下代码片段在`rtweekend.h`中添加来获取所需的实数随机数：
- en: '[PRE45]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '**Listing 41:** `[rtweekend.h]` random_double() functions'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 41:** `[rtweekend.h]` `random_double()`函数'
- en: 'C++ did not traditionally have a standard random number generator, but newer
    versions of C++ have addressed this issue with the `<random>` header (if imperfectly
    according to some experts). If you want to use this, you can obtain a random number
    with the conditions we need as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: C++传统上没有标准的随机数生成器，但C++的新版本通过`<random>`头文件（尽管某些专家认为并不完美）解决了这个问题。如果您想使用它，可以使用以下条件获取随机数：
- en: '[PRE46]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**Listing 42:** `[rtweekend.h]` random_double(), alternate implementation'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 42:** `[rtweekend.h]` `random_double()`，另一种实现'
- en: Generating Pixels with Multiple Samples
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多个样本生成像素
- en: For a single pixel composed of multiple samples, we'll select samples from the
    area surrounding the pixel and average the resulting light (color) values together.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 对于由多个样本组成的单个像素，我们将从围绕像素的区域中选择样本，并将得到的（颜色）光值平均在一起。
- en: 'First we''ll update the `write_color()` function to account for the number
    of samples we use: we need to find the average across all of the samples that
    we take. To do this, we''ll add the full color from each iteration, and then finish
    with a single division (by the number of samples) at the end, before writing out
    the color. To ensure that the color components of the final result remain within
    the proper <nobr aria-hidden="true">[0,1]</nobr><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo
    stretchy="false">]</mo> bounds, we''ll add and use a small helper function: `interval::clamp(x)`.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将更新`write_color()`函数以考虑我们使用的样本数量：我们需要找到所有样本的平均值。为此，我们将添加每次迭代的完整颜色，然后在写入颜色之前进行一次除法（除以样本数量）。为了确保最终结果的颜色分量保持在适当的<nobr
    aria-hidden="true">[0,1]</nobr><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo
    stretchy="false">]</mo>范围内，我们将添加并使用一个小型辅助函数：`interval::clamp(x)`。
- en: '[PRE47]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '**Listing 43:** `[interval.h]` The interval::clamp() utility function'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 43:** `[interval.h]` `interval::clamp()`实用函数'
- en: 'Here''s the updated `write_color()` function that incorporates the interval
    clamping function:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是包含区间限制函数的更新后的`write_color()`函数：
- en: '[PRE48]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '**Listing 44:** `[color.h]` The multi-sample write_color() function'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 44:** `[color.h]` 多样本`write_color()`函数'
- en: Now let's update the camera class to define and use a new `camera::get_ray(i,j)`
    function, which will generate different samples for each pixel. This function
    will use a new helper function `sample_square()` that generates a random sample
    point within the unit square centered at the origin. We then transform the random
    sample from this ideal square back to the particular pixel we're currently sampling.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们更新相机类以定义和使用新的 `camera::get_ray(i,j)` 函数，该函数将为每个像素生成不同的样本。这个函数将使用一个新的辅助函数
    `sample_square()`，该函数在以原点为中心的单位正方形内生成一个随机样本点。然后我们将从这个理想正方形中的随机样本转换回我们当前正在采样的特定像素。
- en: '[PRE49]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '**Listing 45:** `[camera.h]` Camera with samples-per-pixel parameter'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 45**：`[camera.h]` 带有每像素样本参数的相机'
- en: (In addition to the new `sample_square()` function above, you'll also find the
    function `sample_disk()` in the Github source code. This is included in case you'd
    like to experiment with non-square pixels, but we won't be using it in this book.
    `sample_disk()` depends on the function `random_in_unit_disk()` which is defined
    later on.)
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: （除了上面提到的新的 `sample_square()` 函数外，你还可以在 Github 源代码中找到 `sample_disk()` 函数。这包括如果你想要尝试非正方形像素的情况，但在这本书中我们不会使用它。`sample_disk()`
    函数依赖于稍后定义的 `random_in_unit_disk()` 函数。）
- en: Main is updated to set the new camera parameter.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序更新为设置新的相机参数。
- en: '[PRE50]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**Listing 46:** `[main.cc]` Setting the new samples-per-pixel parameterZooming
    into the image that is produced, we can see the difference in edge pixels.[![](https://raytracing.github.io/images/img-1.06-antialias-before-after.png)](https://raytracing.github.io/images/img-1.06-antialias-before-after.png)Image
    6: Before and after antialiasing'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 46**：`[main.cc]` 设置新的每像素样本参数。放大生成的图像，我们可以看到边缘像素的差异。[![](https://raytracing.github.io/images/img-1.06-antialias-before-after.png)](https://raytracing.github.io/images/img-1.06-antialias-before-after.png)图
    6：抗锯齿前后的对比'
- en: Diffuse Materials
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 漫反射材料
- en: Now that we have objects and multiple rays per pixel, we can make some realistic
    looking materials. We’ll start with diffuse materials (also called *matte*). One
    question is whether we mix and match geometry and materials (so that we can assign
    a material to multiple spheres, or vice versa) or if geometry and materials are
    tightly bound (which could be useful for procedural objects where the geometry
    and material are linked). We’ll go with separate — which is usual in most renderers
    — but do be aware that there are alternative approaches.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了对象和每个像素的多个射线，我们可以制作一些看起来更逼真的材料。我们将从漫反射材料（也称为*哑光*）开始。一个问题是我们是否混合和匹配几何形状和材料（这样我们就可以将材料分配给多个球体，反之亦然），或者几何形状和材料是否紧密绑定（这对于几何形状和材料链接的程序化对象可能很有用）。我们将选择分开——这在大多数渲染器中是常见的——但请注意，还有其他方法。
- en: A Simple Diffuse Material
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的漫反射材料
- en: 'Diffuse objects that don’t emit their own light merely take on the color of
    their surroundings, but they do modulate that with their own intrinsic color.
    Light that reflects off a diffuse surface has its direction randomized, so, if
    we send three rays into a crack between two diffuse surfaces they will each have
    different random behavior:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 漫反射物体不会发出自己的光，只是接受周围环境的颜色，但它们会用自己的固有颜色来调制这种颜色。从漫反射表面反射的光线方向是随机的，因此，如果我们向两个漫反射表面之间的裂缝中发送三束光线，它们各自都会有不同的随机行为：
- en: '[![](https://raytracing.github.io/images/fig-1.09-light-bounce.jpg)](https://raytracing.github.io/images/fig-1.09-light-bounce.jpg)**Figure 9:**
    Light ray bounces'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](https://raytracing.github.io/images/fig-1.09-light-bounce.jpg)](https://raytracing.github.io/images/fig-1.09-light-bounce.jpg)**图
    9**：光线反弹'
- en: 'They might also be absorbed rather than reflected. The darker the surface,
    the more likely the ray is absorbed (that’s why it''s dark!). Really any algorithm
    that randomizes direction will produce surfaces that look matte. Let''s start
    with the most intuitive: a surface that randomly bounces a ray equally in all
    directions. For this material, a ray that hits the surface has an equal probability
    of bouncing in any direction away from the surface.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可能被吸收而不是反射。表面越暗，光线被吸收的可能性就越大（这就是为什么它是黑色的！）。实际上，任何随机化方向的算法都会产生看起来像哑光的表面。让我们从最直观的开始：一个表面可以随机地向所有方向等概率地反弹光线。对于这种材料，击中表面的光线有等概率地向表面外的任何方向反弹。
- en: '[![](https://raytracing.github.io/images/fig-1.10-random-vec-horizon.jpg)](https://raytracing.github.io/images/fig-1.10-random-vec-horizon.jpg)**Figure 10:**
    Equal reflection above the horizon'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](https://raytracing.github.io/images/fig-1.10-random-vec-horizon.jpg)](https://raytracing.github.io/images/fig-1.10-random-vec-horizon.jpg)**图
    10**：地平线以上的均匀反射'
- en: 'This very intuitive material is the simplest kind of diffuse and — indeed —
    many of the first raytracing papers used this diffuse method (before adopting
    a more accurate method that we''ll be implementing a little bit later). We don''t
    currently have a way to randomly reflect a ray, so we''ll need to add a few functions
    to our vector utility header. The first thing we need is the ability to generate
    arbitrary random vectors:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这份非常直观的材料是简单类型的光滑扩散，实际上——许多早期的光线追踪论文都使用了这种方法（在采用更精确的方法之前，我们将在稍后实施）。我们目前还没有随机反射光线的方法，因此我们需要在我们的向量工具头中添加几个函数。首先，我们需要的是生成任意随机向量的能力：
- en: '[PRE51]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**Listing 47:** `[vec3.h]` vec3 random utility functions'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 47:** `[vec3.h]` vec3 随机实用函数'
- en: 'Then we need to figure out how to manipulate a random vector so that we only
    get results that are on the surface of a hemisphere. There are analytical methods
    of doing this, but they are actually surprisingly complicated to understand, and
    quite a bit complicated to implement. Instead, we''ll use what is typically the
    easiest algorithm: A rejection method. A rejection method works by repeatedly
    generating random samples until we produce a sample that meets the desired criteria.
    In other words, keep rejecting bad samples until you find a good one.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要弄清楚如何操作随机向量，以便我们只得到半球表面的结果。有分析方法的实现，但实际上它们理解起来相当复杂，实现起来也相当复杂。相反，我们将使用通常最容易的算法：拒绝法。拒绝法通过反复生成随机样本，直到我们产生一个满足所需标准的样本。换句话说，继续拒绝不良样本，直到找到一个好的样本。
- en: 'There are many equally valid ways of generating a random vector on a hemisphere
    using the rejection method, but for our purposes we will go with the simplest,
    which is:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 使用拒绝法在半球上生成随机向量有许多同样有效的方法，但出于我们的目的，我们将采用最简单的方法，即：
- en: Generate a random vector inside the unit sphere
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单位球体内生成一个随机向量
- en: Normalize this vector to extend it to the sphere surface
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此向量归一化以扩展到球面
- en: Invert the normalized vector if it falls onto the wrong hemisphere
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果归一化向量落在错误的半球上，则将其反转
- en: First, we will use a rejection method to generate the random vector inside the
    unit sphere (that is, a sphere of radius 1). Pick a random point inside the cube
    enclosing the unit sphere (that is, where <nobr aria-hidden="true">x</nobr><mi>x</mi>,
    <nobr aria-hidden="true">y</nobr><mi>y</mi>, and <nobr aria-hidden="true">z</nobr><mi>z</mi>
    are all in the range <nobr aria-hidden="true">[−1,+1]</nobr><mo stretchy="false">[</mo><mo>−</mo><mn>1</mn><mo>,</mo><mo>+</mo><mn>1</mn><mo
    stretchy="false">]</mo>). If this point lies outside the unit sphere, then generate
    a new one until we find one that lies inside or on the unit sphere. [![](https://raytracing.github.io/images/fig-1.11-sphere-vec.jpg)](https://raytracing.github.io/images/fig-1.11-sphere-vec.jpg)**Figure 11:**
    Two vectors were rejected before finding a good one (pre-normalization) [![](https://raytracing.github.io/images/fig-1.12-sphere-unit-vec.jpg)](https://raytracing.github.io/images/fig-1.12-sphere-unit-vec.jpg)**Figure 12:**
    The accepted random vector is normalized to produce a unit vector
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用拒绝法生成单位球体内的随机向量（即半径为1的球体）。在包含单位球体的立方体内随机选择一个点（即，其中 <nobr aria-hidden="true">x</nobr><mi>x</mi>,
    <nobr aria-hidden="true">y</nobr><mi>y</mi>, 和 <nobr aria-hidden="true">z</nobr><mi>z</mi>
    都在范围 <nobr aria-hidden="true">[−1,+1]</nobr><mo stretchy="false">[</mo><mo>−</mo><mn>1</mn><mo>,</mo><mo>+</mo><mn>1</mn><mo
    stretchy="false">]</mo> 内）。如果这个点位于单位球体之外，那么就生成一个新的点，直到我们找到一个位于单位球体内部或其上的点。[![](https://raytracing.github.io/images/fig-1.11-sphere-vec.jpg)](https://raytracing.github.io/images/fig-1.11-sphere-vec.jpg)**图
    11:** 在找到合适的向量之前，拒绝了两个向量（归一化前）[![](https://raytracing.github.io/images/fig-1.12-sphere-unit-vec.jpg)](https://raytracing.github.io/images/fig-1.12-sphere-unit-vec.jpg)**图
    12:** 被接受的随机向量被归一化以产生一个单位向量
- en: 'Here''s our first draft of the function:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的函数的第一个草案：
- en: '[PRE52]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '**Listing 48:** `[vec3.h]` The random_unit_vector() function, version one'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 48:** `[vec3.h]` random_unit_vector() 函数，版本一'
- en: Sadly, we have a small floating-point abstraction leak to deal with. Since floating-point
    numbers have finite precision, a very small value can underflow to zero when squared.
    So if all three coordinates are small enough (that is, very near the center of
    the sphere), the norm of the vector will be zero, and thus normalizing will yield
    the bogus vector <nobr aria-hidden="true">[±∞,±∞,±∞]</nobr><mo stretchy="false">[</mo><mo>±</mo><mi
    mathvariant="normal">∞</mi><mo>,</mo><mo>±</mo><mi mathvariant="normal">∞</mi><mo>,</mo><mo>±</mo><mi
    mathvariant="normal">∞</mi><mo stretchy="false">]</mo>. To fix this, we'll also
    reject points that lie inside this “black hole” around the center. With double
    precision (64-bit floats), we can safely support values greater than <nobr aria-hidden="true">10−160</nobr><msup><mn>10</mn><mrow
    class="MJX-TeXAtom-ORD"><mo>−</mo><mn>160</mn></mrow></msup>.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，我们有一个小的浮点数抽象泄漏需要处理。由于浮点数具有有限的精度，一个非常小的值在平方时可能会下溢为零。因此，如果所有三个坐标都足够小（即，非常接近球体的中心），则向量的范数将为零，从而归一化将产生错误的向量
    <nobr aria-hidden="true">[±∞,±∞,±∞]</nobr><mo stretchy="false">[</mo><mo>±</mo><mi
    mathvariant="normal">∞</mi><mo>,</mo><mo>±</mo><mi mathvariant="normal">∞</mi><mo>,</mo><mo>±</mo><mi
    mathvariant="normal">∞</mi><mo stretchy="false">]</mo>。为了解决这个问题，我们还将拒绝位于中心周围这个“黑洞”内的点。使用双精度（64
    位浮点数），我们可以安全地支持大于 <nobr aria-hidden="true">10−160</nobr><msup><mn>10</mn><mrow
    class="MJX-TeXAtom-ORD"><mo>−</mo><mn>160</mn></mrow></msup> 的值。
- en: 'Here''s our more robust function:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的更健壮的函数：
- en: '[PRE53]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**Listing 49:** `[vec3.h]` The random_unit_vector() function, version twoNow
    that we have a random unit vector, we can determine if it is on the correct hemisphere
    by comparing against the surface normal: [![](https://raytracing.github.io/images/fig-1.13-surface-normal.jpg)](https://raytracing.github.io/images/fig-1.13-surface-normal.jpg)**Figure 13:**
    The normal vector tells us which hemisphere we needWe can take the dot product
    of the surface normal and our random vector to determine if it''s in the correct
    hemisphere. If the dot product is positive, then the vector is in the correct
    hemisphere. If the dot product is negative, then we need to invert the vector.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 49:** `[vec3.h]` random_unit_vector() 函数，版本二。现在我们有了随机单位向量，我们可以通过将其与表面法线进行比较来确定它是否位于正确的半球：[![](https://raytracing.github.io/images/fig-1.13-surface-normal.jpg)](https://raytracing.github.io/images/fig-1.13-surface-normal.jpg)**图
    13:** 法线向量告诉我们需要哪个半球。我们可以计算表面法线与我们的随机向量的点积，以确定它是否位于正确的半球。如果点积为正，则向量位于正确的半球。如果点积为负，则需要反转向量。'
- en: '[PRE54]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '**Listing 50:** `[vec3.h]` The random_on_hemisphere() function'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 50:** `[vec3.h]` random_on_hemisphere() 函数'
- en: If a ray bounces off of a material and keeps 100% of its color, then we say
    that the material is *white*. If a ray bounces off of a material and keeps 0%
    of its color, then we say that the material is black. As a first demonstration
    of our new diffuse material we'll set the `ray_color` function to return 50% of
    the color from a bounce. We should expect to get a nice gray color.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一条射线从材料上弹回并保留了 100% 的颜色，那么我们说该材料是**白色**的。如果一条射线从材料上弹回并保留了 0% 的颜色，那么我们说该材料是黑色。作为对我们新漫反射材料的第一次演示，我们将
    `ray_color` 函数设置为返回弹跳 50% 的颜色。我们应该期望得到一个漂亮的灰色。
- en: '[PRE55]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**Listing 51:** `[camera.h]` ray_color() using a random ray direction... Indeed
    we do get rather nice gray spheres:[![](https://raytracing.github.io/images/img-1.07-first-diffuse.png)](https://raytracing.github.io/images/img-1.07-first-diffuse.png)Image
    7: First render of a diffuse sphere'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 51:** `[camera.h]` 使用随机射线方向进行 ray_color()... 确实，我们得到了相当漂亮的灰色球体：[![](https://raytracing.github.io/images/img-1.07-first-diffuse.png)](https://raytracing.github.io/images/img-1.07-first-diffuse.png)图
    7：漫反射球体的首次渲染'
- en: Limiting the Number of Child Rays
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制子射线数量
- en: 'There''s one potential problem lurking here. Notice that the `ray_color` function
    is recursive. When will it stop recursing? When it fails to hit anything. In some
    cases, however, that may be a long time — long enough to blow the stack. To guard
    against that, let''s limit the maximum recursion depth, returning no light contribution
    at the maximum depth:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个潜在的问题潜伏着。请注意，`ray_color` 函数是递归的。它何时会停止递归？当它未能击中任何东西时。然而，在某些情况下，这可能需要很长时间——足够长以至于会溢出堆栈。为了防止这种情况，让我们限制最大递归深度，在最大深度时返回无光贡献：
- en: '[PRE56]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '**Listing 52:** `[camera.h]` camera::ray_color() with depth limitingUpdate
    the main() function to use this new depth limit:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 52:** `[camera.h]` camera::ray_color() 带深度限制'
- en: '[PRE57]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '**Listing 53:** `[main.cc]` Using the new ray depth limitingFor this very simple
    scene we should get basically the same result:[![](https://raytracing.github.io/images/img-1.08-second-diffuse.png)](https://raytracing.github.io/images/img-1.08-second-diffuse.png)Image
    8: Second render of a diffuse sphere with limited bounces'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 53:** `[main.cc]` 使用新的光线深度限制对于这个非常简单的场景，我们应该得到基本上相同的结果：[![](https://raytracing.github.io/images/img-1.08-second-diffuse.png)](https://raytracing.github.io/images/img-1.08-second-diffuse.png)
    图 8：有限次反射的漫反射球体的第二次渲染'
- en: Fixing Shadow Acne
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决阴影痘痘问题
- en: 'There’s also a subtle bug that we need to address. A ray will attempt to accurately
    calculate the intersection point when it intersects with a surface. Unfortunately
    for us, this calculation is susceptible to floating point rounding errors which
    can cause the intersection point to be ever so slightly off. This means that the
    origin of the next ray, the ray that is randomly scattered off of the surface,
    is unlikely to be perfectly flush with the surface. It might be just above the
    surface. It might be just below the surface. If the ray''s origin is just below
    the surface then it could intersect with that surface again. Which means that
    it will find the nearest surface at <nobr aria-hidden="true">t=0.00000001</nobr><mi>t</mi><mo>=</mo><mn>0.00000001</mn>
    or whatever floating point approximation the hit function gives us. The simplest
    hack to address this is just to ignore hits that are very close to the calculated
    intersection point:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个需要我们解决的微妙错误。当光线与表面相交时，它会尝试准确计算交点。不幸的是，这个计算容易受到浮点舍入误差的影响，这可能导致交点略微偏离。这意味着下一束光线的起源，即从表面随机散射的光线，不太可能完美地与表面齐平。它可能刚好在表面之上。它可能刚好在表面之下。如果光线的起源刚好在表面之下，那么它可能会再次与该表面相交。这意味着它将在
    <nobr aria-hidden="true">t=0.00000001</nobr><mi>t</mi><mo>=</mo><mn>0.00000001</mn>
    或 whatever floating point approximation the hit function gives us 处找到最近的表面。解决这个问题的最简单的方法就是忽略那些非常接近计算出的交点的碰撞：
- en: '[PRE58]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '**Listing 54:** `[camera.h]` Calculating reflected ray origins with toleranceThis
    gets rid of the shadow acne problem. Yes it is really called that. Here''s the
    result:[![](https://raytracing.github.io/images/img-1.09-no-acne.png)](https://raytracing.github.io/images/img-1.09-no-acne.png)Image
    9: Diffuse sphere with no shadow acne'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 54:** `[camera.h]` 使用容差计算反射光线起源这解决了阴影痘痘问题。是的，它确实被这样称呼。这是结果：[![](https://raytracing.github.io/images/img-1.09-no-acne.png)](https://raytracing.github.io/images/img-1.09-no-acne.png)
    图 9：无阴影痘痘的漫反射球体'
- en: True Lambertian Reflection
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真实的朗伯反射
- en: Scattering reflected rays evenly about the hemisphere produces a nice soft diffuse
    model, but we can definitely do better. A more accurate representation of real
    diffuse objects is the *Lambertian* distribution. This distribution scatters reflected
    rays in a manner that is proportional to <nobr aria-hidden="true">cos(ϕ)</nobr><mi>cos</mi><mo>⁡</mo><mo
    stretchy="false">(</mo><mi>ϕ</mi><mo stretchy="false">)</mo>, where <nobr aria-hidden="true">ϕ</nobr><mi>ϕ</mi>
    is the angle between the reflected ray and the surface normal. This means that
    a reflected ray is most likely to scatter in a direction near the surface normal,
    and less likely to scatter in directions away from the normal. This non-uniform
    Lambertian distribution does a better job of modeling material reflection in the
    real world than our previous uniform scattering.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在半球面上均匀散射反射光线会产生一个很好的柔和漫反射模型，但我们肯定可以做得更好。对真实漫反射物体的更准确表示是 *朗伯* 分布。这种分布以与 <nobr
    aria-hidden="true">cos(ϕ)</nobr><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>ϕ</mi><mo
    stretchy="false">)</mo> 成正比的方式散射反射光线，其中 <nobr aria-hidden="true">ϕ</nobr><mi>ϕ</mi>
    是反射光线与表面法线之间的角度。这意味着反射光线最有可能在接近表面法线的方向上散射，而不太可能在远离法线的方向上散射。这种非均匀的朗伯分布比我们之前的均匀散射更好地模拟了现实世界中的材料反射。
- en: We can create this distribution by adding a random unit vector to the normal
    vector. At the point of intersection on a surface there is the hit point, <nobr
    aria-hidden="true">p</nobr><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">p</mi></mrow>,
    and there is the normal of the surface, <nobr aria-hidden="true">n</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">n</mi></mrow>. At the point of
    intersection, this surface has exactly two sides, so there can only be two unique
    unit spheres tangent to any intersection point (one unique sphere for each side
    of the surface). These two unit spheres will be displaced from the surface by
    the length of their radius, which is exactly one for a unit sphere.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向法线向量添加一个随机单位向量来创建这种分布。在表面的交点处，有碰撞点，<nobr aria-hidden="true">p</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">p</mi></mrow>，以及表面的法线，<nobr aria-hidden="true">n</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">n</mi></mrow>。在交点处，这个表面恰好有两个面，因此只能有两个独特的单位球体与任何交点相切（每个面一个独特的球体）。这两个单位球体将沿着它们的半径长度从表面移动，对于一个单位球体，这个长度正好是一。
- en: One sphere will be displaced in the direction of the surface's normal (<nobr
    aria-hidden="true">n</nobr><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">n</mi></mrow>)
    and one sphere will be displaced in the opposite direction (<nobr aria-hidden="true">−n</nobr><mrow
    class="MJX-TeXAtom-ORD"><mo mathvariant="bold">−</mo><mi mathvariant="bold">n</mi></mrow>).
    This leaves us with two spheres of unit size that will only be *just* touching
    the surface at the intersection point. From this, one of the spheres will have
    its center at <nobr aria-hidden="true">(P+n)</nobr><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">P</mi></mrow><mo>+</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">n</mi></mrow><mo stretchy="false">)</mo> and the other sphere
    will have its center at <nobr aria-hidden="true">(P−n)</nobr><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">P</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">n</mi></mrow><mo stretchy="false">)</mo>. The sphere with a
    center at <nobr aria-hidden="true">(P−n)</nobr><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">P</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">n</mi></mrow><mo stretchy="false">)</mo> is considered *inside*
    the surface, whereas the sphere with center <nobr aria-hidden="true">(P+n)</nobr><mo
    stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">P</mi></mrow><mo>+</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">n</mi></mrow><mo stretchy="false">)</mo>
    is considered *outside* the surface.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 一个球体将沿着表面的法线方向（<nobr aria-hidden="true">n</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">n</mi></mrow>）移动，另一个球体将沿着相反方向（<nobr aria-hidden="true">−n</nobr><mrow
    class="MJX-TeXAtom-ORD"><mo mathvariant="bold">−</mo><mi mathvariant="bold">n</mi></mrow>）移动。这导致我们有两个单位大小的球体，它们仅在交点处刚好接触表面。由此，一个球体的中心位于
    <nobr aria-hidden="true">(P+n)</nobr><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">P</mi></mrow><mo>+</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">n</mi></mrow><mo
    stretchy="false">)</mo>，而另一个球体的中心位于 <nobr aria-hidden="true">(P−n)</nobr><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">P</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">n</mi></mrow><mo stretchy="false">)</mo>。中心位于 <nobr aria-hidden="true">(P−n)</nobr><mo
    stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">P</mi></mrow><mo>−</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">n</mi></mrow><mo stretchy="false">)</mo>
    的球体被认为是表面**内部**的，而中心位于 <nobr aria-hidden="true">(P+n)</nobr><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">P</mi></mrow><mo>+</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">n</mi></mrow><mo stretchy="false">)</mo> 的球体被认为是表面**外部**的。
- en: 'We want to select the tangent unit sphere that is on the same side of the surface
    as the ray origin. Pick a random point <nobr aria-hidden="true">S</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">S</mi></mrow> on this unit radius
    sphere and send a ray from the hit point <nobr aria-hidden="true">P</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">P</mi></mrow> to the random point
    <nobr aria-hidden="true">S</nobr><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">S</mi></mrow>
    (this is the vector <nobr aria-hidden="true">(S−P)</nobr><mo stretchy="false">(</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">S</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">P</mi></mrow><mo stretchy="false">)</mo>):'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要选择与射线原点位于表面同一侧的切线单位球。在这个单位半径球上随机选择一个点 <nobr aria-hidden="true">S</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">S</mi></mrow>，并从击中点 <nobr aria-hidden="true">P</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">P</mi></mrow> 发射一条射线到随机点 <nobr
    aria-hidden="true">S</nobr><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">S</mi></mrow>（这是向量
    <nobr aria-hidden="true">(S−P)</nobr><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">S</mi></mrow><mo>−</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">P</mi></mrow><mo
    stretchy="false">)</mo>）：
- en: '[![](https://raytracing.github.io/images/fig-1.14-rand-unitvec.jpg)](https://raytracing.github.io/images/fig-1.14-rand-unitvec.jpg)**Figure 14:**
    Randomly generating a vector according to Lambertian distributionThe change is
    actually fairly minimal:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](https://raytracing.github.io/images/fig-1.14-rand-unitvec.jpg)](https://raytracing.github.io/images/fig-1.14-rand-unitvec.jpg)**图
    14**：根据 Lambertian 分布随机生成一个向量The变化实际上相当微小：'
- en: '[PRE59]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**Listing 55:** `[camera.h]` ray_color() with replacement diffuseAfter rendering
    we get a similar image:[![](https://raytracing.github.io/images/img-1.10-correct-lambertian.png)](https://raytracing.github.io/images/img-1.10-correct-lambertian.png)Image
    10: Correct rendering of Lambertian spheres'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 55**：`[camera.h]` 中的 `ray_color()` 函数使用替换漫反射在渲染后我们得到一个类似的图像：[![](https://raytracing.github.io/images/img-1.10-correct-lambertian.png)](https://raytracing.github.io/images/img-1.10-correct-lambertian.png)
    图像 10：Lambertian 球体的正确渲染'
- en: 'It''s hard to tell the difference between these two diffuse methods, given
    that our scene of two spheres is so simple, but you should be able to notice two
    important visual differences:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的场景是两个简单的球体，很难区分这两种漫反射方法，但你应该能够注意到两个重要的视觉差异：
- en: The shadows are more pronounced after the change
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变化后阴影更加明显
- en: Both spheres are tinted blue from the sky after the change
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个球体在变化后都从天空中染上了蓝色
- en: Both of these changes are due to the less uniform scattering of the light rays—more
    rays are scattering toward the normal. This means that for diffuse objects, they
    will appear *darker* because less light bounces toward the camera. For the shadows,
    more light bounces straight-up, so the area underneath the sphere is darker.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个变化都是由于光线散射的不均匀性——更多的光线散射向法线。这意味着对于漫反射物体，它们将看起来 *更暗*，因为向相机反弹的光更少。对于阴影，更多的光线直接向上反弹，因此球体下方的区域更暗。
- en: Not a lot of common, everyday objects are perfectly diffuse, so our visual intuition
    of how these objects behave under light can be poorly formed. As scenes become
    more complicated over the course of the book, you are encouraged to switch between
    the different diffuse renderers presented here. Most scenes of interest will contain
    a large amount of diffuse materials. You can gain valuable insight by understanding
    the effect of different diffuse methods on the lighting of a scene.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 并非很多常见的日常物体都是完美漫反射的，因此我们对这些物体在光照下行为的视觉直觉可能形成得并不好。随着书中场景的逐渐复杂化，你被鼓励在这几种在此处展示的漫反射渲染器之间进行切换。大多数有趣的场景将包含大量的漫反射材料。通过理解不同漫反射方法对场景光照的影响，你可以获得宝贵的见解。
- en: Using Gamma Correction for Accurate Color Intensity
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用伽玛校正以获得准确的色彩强度
- en: 'Note the shadowing under the sphere. The picture is very dark, but our spheres
    only absorb half the energy of each bounce, so they are 50% reflectors. The spheres
    should look pretty bright (in real life, a light grey) but they appear to be rather
    dark. We can see this more clearly if we walk through the full brightness gamut
    for our diffuse material. We start by setting the reflectance of the `ray_color`
    function from `0.5` (50%) to `0.1` (10%):'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 注意球体下的阴影。图片非常暗，但我们的球体只吸收了每次反弹的一半能量，因此它们是 50% 的反射体。球体应该看起来相当明亮（在现实生活中，是浅灰色），但它们看起来相当暗。如果我们通过我们的漫反射材料的完整亮度范围来观察，我们可以更清楚地看到这一点。我们首先将
    `ray_color` 函数的反射率从 `0.5`（50%）设置为 `0.1`（10%）：
- en: '[PRE60]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**Listing 56:** `[camera.h]` ray_color() with 10% reflectance'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 56**：`[camera.h]` 中的 `ray_color()` 函数使用 10% 的反射率'
- en: 'We render out at this new 10% reflectance. We then set reflectance to 30% and
    render again. We repeat for 50%, 70%, and finally 90%. You can overlay these images
    from left to right in the photo editor of your choice and you should get a very
    nice visual representation of the increasing brightness of your chosen gamut.
    This is the one that we''ve been working with so far:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以新的10%反射率进行渲染。然后我们将反射率设置为30%并再次渲染。我们重复这个过程，直到达到50%、70%，最后是90%。您可以在您选择的图片编辑器中从左到右叠加这些图像，应该能得到一个很好的所选色域亮度增加的视觉表示。这是我们迄今为止一直在使用的：
- en: '[![](https://raytracing.github.io/images/img-1.11-linear-gamut.png)](https://raytracing.github.io/images/img-1.11-linear-gamut.png)Image
    11: The gamut of our renderer so far'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](https://raytracing.github.io/images/img-1.11-linear-gamut.png)](https://raytracing.github.io/images/img-1.11-linear-gamut.png)图11：我们渲染器目前的色域'
- en: If you look closely, or if you use a color picker, you should notice that the
    50% reflectance render (the one in the middle) is far too dark to be half-way
    between white and black (middle-gray). Indeed, the 70% reflector is closer to
    middle-gray. The reason for this is that almost all computer programs assume that
    an image is “gamma corrected” before being written into an image file. This means
    that the 0 to 1 values have some transform applied before being stored as a byte.
    Images with data that are written without being transformed are said to be in
    *linear space*, whereas images that are transformed are said to be in *gamma space*.
    It is likely that the image viewer you are using is expecting an image in gamma
    space, but we are giving it an image in linear space. This is the reason why our
    image appears inaccurately dark.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细观察，或者使用颜色选择器，您应该会注意到50%反射率的渲染（中间的那个）过于暗淡，无法在白色和黑色（中间灰）之间达到一半（中间灰）。实际上，70%的反射器更接近中间灰。这是因为几乎所有计算机程序都假设在写入图像文件之前，图像是“伽玛校正”的。这意味着0到1的值在存储为字节之前应用了一些转换。没有经过转换就写入数据的图像被称为处于“线性空间”，而经过转换的图像被称为处于“伽玛空间”。很可能是您使用的图像查看器期望一个伽玛空间的图像，但我们给它的是一个线性空间的图像。这就是我们的图像看起来不准确的原因。
- en: There are many good reasons for why images should be stored in gamma space,
    but for our purposes we just need to be aware of it. We are going to transform
    our data into gamma space so that our image viewer can more accurately display
    our image. As a simple approximation, we can use “gamma 2” as our transform, which
    is the power that you use when going from gamma space to linear space. We need
    to go from linear space to gamma space, which means taking the inverse of “gamma
    2", which means an exponent of <nobr aria-hidden="true">1/gamma</nobr><mn>1</mn><mrow
    class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit"
    mathvariant="italic">g</mi><mi class="MJX-tex-mathit" mathvariant="italic">a</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">m</mi><mi class="MJX-tex-mathit" mathvariant="italic">m</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">a</mi></mrow>, which is just the square-root.
    We'll also want to ensure that we robustly handle negative inputs.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '存储图像在伽玛空间中有许多很好的理由，但就我们的目的而言，我们只需要意识到这一点。我们将我们的数据转换到伽玛空间，以便我们的图像查看器可以更准确地显示我们的图像。作为一个简单的近似，我们可以使用“伽玛2”作为我们的转换，这是从伽玛空间到线性空间使用的幂。我们需要从线性空间转换到伽玛空间，这意味着取“伽玛2”的倒数，即<sup
    class="MJX-TeXAtom-ORD"><span class="MJX-TeXAtom-ORD" style="vertical-align: -0.7em;"><mi
    class="MJX-tex-mathit" mathvariant="italic">1</mi></span></sup><span class="MJX-TeXAtom-ORD"
    style="vertical-align: -0.7em;"><mi class="MJX-tex-mathit" mathvariant="italic">g</mi></span><span
    class="MJX-TeXAtom-ORD" style="vertical-align: -0.7em;"><mi class="MJX-tex-mathit"
    mathvariant="italic">a</mi></span><span class="MJX-TeXAtom-ORD" style="vertical-align:
    -0.7em;"><mi class="MJX-tex-mathit" mathvariant="italic">m</mi></span><span class="MJX-TeXAtom-ORD"
    style="vertical-align: -0.7em;"><mi class="MJX-tex-mathit" mathvariant="italic">m</mi></span><span
    class="MJX-TeXAtom-ORD" style="vertical-align: -0.7em;"><mi class="MJX-tex-mathit"
    mathvariant="italic">a</mi></span>，这仅仅是平方根。我们还想确保我们能够稳健地处理负输入。'
- en: '[PRE61]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**Listing 57:** `[color.h]` write_color(), with gamma correctionUsing this
    gamma correction, we now get a much more consistent ramp from darkness to lightness:[![](https://raytracing.github.io/images/img-1.12-gamma-gamut.png)](https://raytracing.github.io/images/img-1.12-gamma-gamut.png)Image
    12: The gamut of our renderer, gamma-corrected'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表57**：`[color.h]` write_color()，使用伽玛校正使用这种伽玛校正，我们现在从暗到亮得到了一个更加一致的渐变：[![](https://raytracing.github.io/images/img-1.12-gamma-gamut.png)](https://raytracing.github.io/images/img-1.12-gamma-gamut.png)图12：我们的渲染器色域，伽玛校正'
- en: Metal
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 金属
- en: An Abstract Class for Materials
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 材料抽象类
- en: 'If we want different objects to have different materials, we have a design
    decision. We could have a universal material type with lots of parameters so any
    individual material type could just ignore the parameters that don''t affect it.
    This is not a bad approach. Or we could have an abstract material class that encapsulates
    unique behavior. I am a fan of the latter approach. For our program the material
    needs to do two things:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让不同的物体有不同的材料，我们有一个设计决策。我们可以有一个具有许多参数的通用材料类型，这样任何单个材料类型都可以忽略不影响它的参数。这不是一个坏方法。或者我们可以有一个封装独特行为的抽象材料类。我是后者的支持者。对于我们的程序，材料需要做两件事：
- en: Produce a scattered ray (or say it absorbed the incident ray).
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 产生一个散射射线（或者可以说它吸收了入射射线）。
- en: If scattered, say how much the ray should be attenuated.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果分散，请说明射线应该衰减多少。
- en: 'This suggests the abstract class:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明了抽象类：
- en: '[PRE62]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '**Listing 58:** `[material.h]` The material class'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 58**：`[material.h]` 材料类'
- en: A Data Structure to Describe Ray-Object Intersections
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述射线-物体相交的数据结构
- en: The `hit_record` is to avoid a bunch of arguments so we can stuff whatever info
    we want in there. You can use arguments instead of an encapsulated type, it’s
    just a matter of taste. Hittables and materials need to be able to reference the
    other's type in code so there is some circularity of the references. In C++ we
    add the line `class material;` to tell the compiler that `material` is a class
    that will be defined later. Since we're just specifying a pointer to the class,
    the compiler doesn't need to know the details of the class, solving the circular
    reference issue.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`hit_record` 是为了避免大量参数，我们可以将任何我们想要的 信息放入其中。你可以使用参数而不是封装的类型，这只是口味的问题。击中物和材料需要在代码中能够引用对方的类型，因此存在一些引用的循环。在
    C++ 中，我们添加 `class material;` 这一行来告诉编译器 `material` 是一个将在以后定义的类。由于我们只是指定了类的指针，编译器不需要知道类的细节，这样就解决了循环引用的问题。'
- en: '[PRE63]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '**Listing 59:** `[hittable.h]` Hit record with added material pointer'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 59**：`[hittable.h]` 带有附加材料指针的击中记录'
- en: '`hit_record` is just a way to stuff a bunch of arguments into a class so we
    can send them as a group. When a ray hits a surface (a particular sphere for example),
    the material pointer in the `hit_record` will be set to point at the material
    pointer the sphere was given when it was set up in `main()` when we start. When
    the `ray_color()` routine gets the `hit_record` it can call member functions of
    the material pointer to find out what ray, if any, is scattered.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`hit_record` 只是一种将大量参数放入一个类中的方法，这样我们就可以将它们作为一个组发送。当射线击中一个表面（例如一个特定的球体）时，`hit_record`
    中的材料指针将被设置为指向在 `main()` 中设置球体时提供的材料指针。当 `ray_color()` 例程获取 `hit_record` 时，它可以调用材料指针的成员函数以找出是否有任何射线被散射。'
- en: To achieve this, `hit_record` needs to be told the material that is assigned
    to the sphere.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，`hit_record` 需要知道分配给球体的材料。
- en: '[PRE64]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '**Listing 60:** `[sphere.h]` Ray-sphere intersection with added material information'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 60**：`[sphere.h]` 带有附加材料信息的射线-球体相交'
- en: Modeling Light Scatter and Reflectance
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟光散射和反射
- en: Here and throughout these books we will use the term *albedo* (Latin for “whiteness”).
    Albedo is a precise technical term in some disciplines, but in all cases it is
    used to define some form of *fractional reflectance*. Albedo will vary with material
    color and (as we will later implement for glass materials) can also vary with
    incident viewing direction (the direction of the incoming ray).
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里以及在这些书籍的整个过程中，我们将使用术语 *albedo*（拉丁语意为“白色”）。Albedo 在某些学科中是一个精确的技术术语，但在所有情况下，它都用于定义某种形式的
    *分数反射率*。Albedo 会随材料颜色变化，并且（正如我们将在玻璃材料中后来实现的那样）也可以随入射观察方向（入射射线的方向）变化。
- en: 'Lambertian (diffuse) reflectance can either always scatter and attenuate light
    according to its reflectance <nobr aria-hidden="true">R</nobr><mi>R</mi>, or it
    can sometimes scatter (with probability <nobr aria-hidden="true">1−R</nobr><mn>1</mn><mo>−</mo><mi>R</mi>)
    with no attenuation (where a ray that isn''t scattered is just absorbed into the
    material). It could also be a mixture of both those strategies. We will choose
    to always scatter, so implementing Lambertian materials becomes a simple task:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 拉姆伯特（漫反射）反射率可以始终根据其反射率 <nobr aria-hidden="true">R</nobr><mi>R</mi> 散射并衰减光线，或者它有时可以（概率
    <nobr aria-hidden="true">1−R</nobr><mn>1</mn><mo>−</mo><mi>R</mi>）不衰减地散射（其中未散射的射线只是被材料吸收）。它也可以是这两种策略的混合。我们将选择始终散射，因此实现拉姆伯特材料变得简单：
- en: '[PRE65]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '**Listing 61:** `[material.h]` The new lambertian material class'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 61**：`[material.h]` 新的拉姆伯特材料类'
- en: 'Note the third option: we could scatter with some fixed probability <nobr aria-hidden="true">p</nobr><mi>p</mi>
    and have attenuation be <nobr aria-hidden="true">albedo/p</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    class="MJX-tex-mathit" mathvariant="italic">a</mi><mi class="MJX-tex-mathit" mathvariant="italic">l</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">b</mi><mi class="MJX-tex-mathit" mathvariant="italic">e</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">d</mi><mi class="MJX-tex-mathit" mathvariant="italic">o</mi></mrow><mrow
    class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mi>p</mi>. Your choice.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第三个选项：我们可以以某个固定的概率 <nobr aria-hidden="true">p</nobr><mi>p</mi> 进行散射，并且衰减为
    <nobr aria-hidden="true">albedo/p</nobr><mrow class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit"
    mathvariant="italic">a</mi><mi class="MJX-tex-mathit" mathvariant="italic">l</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">b</mi><mi class="MJX-tex-mathit" mathvariant="italic">e</mi><mi
    class="MJX-tex-mathit" mathvariant="italic">d</mi><mi class="MJX-tex-mathit" mathvariant="italic">o</mi></mrow><mrow
    class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mi class="MJX-tex-mathit" mathvariant="italic">p</mi>.
    您的选择。
- en: If you read the code above carefully, you'll notice a small chance of mischief.
    If the random unit vector we generate is exactly opposite the normal vector, the
    two will sum to zero, which will result in a zero scatter direction vector. This
    leads to bad scenarios later on (infinities and NaNs), so we need to intercept
    the condition before we pass it on.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细阅读上面的代码，你会注意到有一点点麻烦。如果我们生成的随机单位向量正好与法向量相反，这两个向量将相加为零，这将导致散射方向向量为零。这会导致后续出现不良情况（无穷大和
    NaN），因此我们需要在传递之前拦截这种条件。
- en: In service of this, we'll create a new vector method — `vec3::near_zero()` —
    that returns true if the vector is very close to zero in all dimensions.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将创建一个新的向量方法——`vec3::near_zero()`——如果向量在所有维度上都非常接近零，则返回 true。
- en: The following changes will use the C++ standard library function `std::fabs`,
    which returns the absolute value of its input.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 以下更改将使用 C++ 标准库函数 `std::fabs`，该函数返回其输入的绝对值。
- en: '[PRE66]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '**Listing 62:** `[vec3.h]` The vec3::near_zero() method'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 62**：`[vec3.h]` vec3::near_zero() 方法'
- en: '[PRE67]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '**Listing 63:** `[material.h]` Lambertian scatter, bullet-proof'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 63**：`[material.h]` 拉姆伯特散射，防弹'
- en: Mirrored Light Reflection
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 镜面光反射
- en: 'For polished metals the ray won’t be randomly scattered. The key question is:
    How does a ray get reflected from a metal mirror? Vector math is our friend here:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 对于抛光金属，光线不会随机散射。关键问题是：光线是如何从金属镜子上反射的？向量数学是我们的朋友：
- en: '[![](https://raytracing.github.io/images/fig-1.15-reflection.jpg)](https://raytracing.github.io/images/fig-1.15-reflection.jpg)**Figure 15:**
    Ray reflection'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15：光线反射](https://raytracing.github.io/images/fig-1.15-reflection.jpg)**图
    15**：光线反射'
- en: The reflected ray direction in red is just <nobr aria-hidden="true">v+2b</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">v</mi></mrow><mo>+</mo><mn>2</mn><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">b</mi></mrow>. In our design, <nobr
    aria-hidden="true">n</nobr><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">n</mi></mrow>
    is a unit vector (length one), but <nobr aria-hidden="true">v</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">v</mi></mrow> may not be. To get the vector <nobr aria-hidden="true">b</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">b</mi></mrow>, we scale the normal
    vector by the length of the projection of <nobr aria-hidden="true">v</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">v</mi></mrow> onto <nobr aria-hidden="true">n</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">n</mi></mrow>, which is given by
    the dot product <nobr aria-hidden="true">v⋅n</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">v</mi></mrow><mo>⋅</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">n</mi></mrow>.
    (If <nobr aria-hidden="true">n</nobr><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">n</mi></mrow>
    were not a unit vector, we would also need to divide this dot product by the length
    of <nobr aria-hidden="true">n</nobr><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">n</mi></mrow>.)
    Finally, because <nobr aria-hidden="true">v</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">v</mi></mrow> points *into* the surface, and we want <nobr
    aria-hidden="true">b</nobr><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">b</mi></mrow>
    to point *out* of the surface, we need to negate this projection length.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 反射射线的方向用红色表示，即 <nobr aria-hidden="true">v+2b</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">v</mi></mrow><mo>+</mo><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">b</mi></mrow>。在我们的设计中，<nobr aria-hidden="true">n</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">n</mi></mrow> 是一个单位向量（长度为 1），但
    <nobr aria-hidden="true">v</nobr><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">v</mi></mrow>
    可能不是。为了得到向量 <nobr aria-hidden="true">b</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">b</mi></mrow>，我们将法向量乘以 <nobr aria-hidden="true">v</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">v</mi></mrow> 在 <nobr aria-hidden="true">n</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">n</mi></mrow> 上的投影长度，该长度由点积 <nobr
    aria-hidden="true">v⋅n</nobr><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">v</mi></mrow><mo>⋅</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">n</mi></mrow> 给出。（如果 <nobr aria-hidden="true">n</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">n</mi></mrow> 不是一个单位向量，我们还需要将这个点积除以
    <nobr aria-hidden="true">n</nobr><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">n</mi></mrow>
    的长度。）最后，因为 <nobr aria-hidden="true">v</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">v</mi></mrow> 指向表面内部，而我们希望 <nobr aria-hidden="true">b</nobr><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">b</mi></mrow> 指向表面外部，所以我们需要取这个投影长度的负值。
- en: 'Putting everything together, we get the following computation of the reflected
    vector:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容组合起来，我们得到以下反射向量的计算：
- en: '[PRE68]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '**Listing 64:** `[vec3.h]` vec3 reflection functionThe metal material just
    reflects rays using that formula:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 64:** `[vec3.h]` vec3 反射函数金属材质仅使用该公式反射射线：'
- en: '[PRE69]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '**Listing 65:** `[material.h]` Metal material with reflectance functionWe need
    to modify the `ray_color()` function for all of our changes:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 65:** `[material.h]` 具有反射函数的金属材质我们需要修改 `ray_color()` 函数以适应所有更改：'
- en: '[PRE70]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '**Listing 66:** `[camera.h]` Ray color with scattered reflectance'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 66:** `[camera.h]` 具有散射反射的射线颜色'
- en: 'Now we''ll update the `sphere` constructor to initialize the material pointer
    `mat`:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更新 `sphere` 构造函数以初始化材质指针 `mat`：
- en: '[PRE71]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '**Listing 67:** `[sphere.h]` Initializing sphere with a material'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 67:** `[sphere.h]` 使用材质初始化球体'
- en: A Scene with Metal Spheres
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 金属球体场景
- en: 'Now let’s add some metal spheres to our scene:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在我们的场景中添加一些金属球体：
- en: '[PRE72]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '**Listing 68:** `[main.cc]` Scene with metal spheresWhich gives:[![](https://raytracing.github.io/images/img-1.13-metal-shiny.png)](https://raytracing.github.io/images/img-1.13-metal-shiny.png)Image
    13: Shiny metal'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 68:** `[main.cc]` 金属球体场景，它给出：[![](https://raytracing.github.io/images/img-1.13-metal-shiny.png)](https://raytracing.github.io/images/img-1.13-metal-shiny.png)
    图 13：闪亮的金属'
- en: Fuzzy Reflection
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模糊反射
- en: We can also randomize the reflected direction by using a small sphere and choosing
    a new endpoint for the ray. We'll use a random point from the surface of a sphere
    centered on the original endpoint, scaled by the fuzz factor.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用一个小球体并选择射线的新的端点来随机化反射方向。我们将使用一个随机点，该点来自以原始端点为中心的球体表面，并按模糊因子进行缩放。
- en: '[![](https://raytracing.github.io/images/fig-1.16-reflect-fuzzy.jpg)](https://raytracing.github.io/images/fig-1.16-reflect-fuzzy.jpg)**Figure 16:**
    Generating fuzzed reflection rays'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](https://raytracing.github.io/images/fig-1.16-reflect-fuzzy.jpg)](https://raytracing.github.io/images/fig-1.16-reflect-fuzzy.jpg)**图
    16：生成模糊反射射线'
- en: The bigger the fuzz sphere, the fuzzier the reflections will be. This suggests
    adding a fuzziness parameter that is just the radius of the sphere (so zero is
    no perturbation). The catch is that for big spheres or grazing rays, we may scatter
    below the surface. We can just have the surface absorb those.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊球体越大，反射就越模糊。这表明我们可以添加一个模糊性参数，它正好是球体的半径（因此零表示没有扰动）。但是，对于大球体或掠射光线，我们可能在表面下方发生散射。我们可以让表面吸收这些光线。
- en: Also note that in order for the fuzz sphere to make sense, it needs to be consistently
    scaled compared to the reflection vector, which can vary in length arbitrarily.
    To address this, we need to normalize the reflected ray.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，为了让模糊球体有意义，它需要与反射向量保持一致的缩放比例，反射向量的长度可以是任意变化的。为了解决这个问题，我们需要对反射光线进行归一化。
- en: '[PRE73]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '**Listing 69:** `[material.h]` Metal material fuzzinessWe can try that out
    by adding fuzziness 0.3 and 1.0 to the metals:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表69**：`[material.h]` 金属材料的模糊性我们可以通过给金属添加模糊性0.3和1.0来尝试一下：'
- en: '[PRE74]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '**Listing 70:** `[main.cc]` Metal spheres with fuzziness[![](https://raytracing.github.io/images/img-1.14-metal-fuzz.png)](https://raytracing.github.io/images/img-1.14-metal-fuzz.png)Image
    14: Fuzzed metal'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表70**：`[main.cc]` 具有模糊性的金属球[![](https://raytracing.github.io/images/img-1.14-metal-fuzz.png)](https://raytracing.github.io/images/img-1.14-metal-fuzz.png)图14：模糊金属'
- en: Dielectrics
  id: totrans-483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电介质
- en: Clear materials such as water, glass, and diamond are dielectrics. When a light
    ray hits them, it splits into a reflected ray and a refracted (transmitted) ray.
    We’ll handle that by randomly choosing between reflection and refraction, only
    generating one scattered ray per interaction.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰的材料，如水、玻璃和钻石，是电介质。当光线击中它们时，它会分成一个反射光线和一个折射（透射）光线。我们将通过随机选择反射和折射来处理这个问题，每次交互只生成一个散射光线。
- en: As a quick review of terms, a *reflected* ray hits a surface and then “bounces”
    off in a new direction.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 作为术语的快速回顾，一个**反射**光线击中表面然后“弹跳”到新的方向。
- en: A *refracted* ray bends as it transitions from a material's surroundings into
    the material itself (as with glass or water). This is why a pencil looks bent
    when partially inserted in water.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 当折射光线从一种材料的周围过渡到该材料本身时（例如玻璃或水），它会弯曲。这就是为什么铅笔部分插入水中时看起来会弯曲。
- en: The amount that a refracted ray bends is determined by the material's *refractive
    index*. Generally, this is a single value that describes how much light bends
    when entering a material from a vacuum. Glass has a refractive index of something
    like 1.5–1.7, diamond is around 2.4, and air has a small refractive index of 1.000293.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 折射光线弯曲的程度由材料的**折射率**决定。通常，这是一个单一值，描述了光线从真空进入材料时弯曲的程度。玻璃的折射率大约是1.5–1.7，钻石大约是2.4，而空气有一个很小的折射率1.000293。
- en: 'When a transparent material is embedded in a different transparent material,
    you can describe the refraction with a relative refraction index: the refractive
    index of the object''s material divided by the refractive index of the surrounding
    material. For example, if you want to render a glass ball under water, then the
    glass ball would have an effective refractive index of 1.125\. This is given by
    the refractive index of glass (1.5) divided by the refractive index of water (1.333).'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个透明材料嵌入到另一种透明材料中时，你可以用相对折射率来描述折射：物体的材料折射率除以周围材料的折射率。例如，如果你想渲染一个浸在水中玻璃球，那么玻璃球的有效折射率将是1.125。这是由玻璃的折射率（1.5）除以水的折射率（1.333）得出的。
- en: You can find the refractive index of most common materials with a quick internet
    search.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过快速网络搜索找到大多数常见材料的折射率。
- en: Refraction
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 折射
- en: 'The hardest part to debug is the refracted ray. I usually first just have all
    the light refract if there is a refraction ray at all. For this project, I tried
    to put two glass balls in our scene, and I got this (I have not told you how to
    do this right or wrong yet, but soon!):'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 调试中最困难的部分是折射光线。我通常首先让所有光线在存在折射光线的情况下都发生折射。对于这个项目，我尝试在我们的场景中放入两个玻璃球，结果就是这样（我还没有告诉你这样做是对是错，但很快就会告诉你！）：
- en: '[![](https://raytracing.github.io/images/img-1.15-glass-first.png)](https://raytracing.github.io/images/img-1.15-glass-first.png)Image
    15: Glass first'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '![![](https://raytracing.github.io/images/img-1.15-glass-first.png)](https://raytracing.github.io/images/img-1.15-glass-first.png)图15：玻璃首次出现'
- en: Is that right? Glass balls look odd in real life. But no, it isn’t right. The
    world should be flipped upside down and no weird black stuff. I just printed out
    the ray straight through the middle of the image and it was clearly wrong. That
    often does the job.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这对吗？现实生活中玻璃球看起来很奇怪。但不是的，这是不对的。世界应该是颠倒的，没有奇怪的黑东西。我只是将光线直接打印在图像的中间，这显然是错误的。这通常能解决问题。
- en: Snell's Law
  id: totrans-494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 斯涅尔定律
- en: 'The refraction is described by Snell’s law:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 折射由斯涅尔定律描述：
- en: <nobr aria-hidden="true">η⋅sinθ=η′⋅sinθ′</nobr><mi>η</mi><mo>⋅</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi><mo>=</mo><msup><mi>η</mi><mo>′</mo></msup><mo>⋅</mo><mi>sin</mi><mo>⁡</mo><msup><mi>θ</mi><mo>′</mo></msup>
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">η⋅sinθ=η′⋅sinθ′</nobr><mi>η</mi><mo>⋅</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi><mo>=</mo><msup><mi>η</mi><mo>′</mo></msup><mo>⋅</mo><mi>sin</mi><mo>⁡</mo><msup><mi>θ</mi><mo>′</mo></msup>
- en: 'Where <nobr aria-hidden="true">θ</nobr><mi>θ</mi> and <nobr aria-hidden="true">θ′</nobr><msup><mi>θ</mi><mo>′</mo></msup>
    are the angles from the normal, and <nobr aria-hidden="true">η</nobr><mi>η</mi>
    and <nobr aria-hidden="true">η′</nobr><msup><mi>η</mi><mo>′</mo></msup> (pronounced
    “eta” and “eta prime”) are the refractive indices. The geometry is:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 <nobr aria-hidden="true">θ</nobr><mi>θ</mi> 和 <nobr aria-hidden="true">θ′</nobr><msup><mi>θ</mi><mo>′</mo></msup>
    是从法线到角度，而 <nobr aria-hidden="true">η</nobr><mi>η</mi> 和 <nobr aria-hidden="true">η′</nobr><msup><mi>η</mi><mo>′</mo></msup>（发音为“eta”和“eta
    prime”）是折射率。几何关系如下：
- en: '[![](https://raytracing.github.io/images/fig-1.17-refraction.jpg)](https://raytracing.github.io/images/fig-1.17-refraction.jpg)**Figure 17:**
    Ray refraction'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '![![](https://raytracing.github.io/images/fig-1.17-refraction.jpg)](https://raytracing.github.io/images/fig-1.17-refraction.jpg)**图17：**
    光线折射'
- en: 'In order to determine the direction of the refracted ray, we have to solve
    for <nobr aria-hidden="true">sinθ′</nobr><mi>sin</mi><mo>⁡</mo><msup><mi>θ</mi><mo>′</mo></msup>:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '为了确定折射光线的方向，我们需要求解 <nobr aria-hidden="true">sinθ′</nobr><mi>sin</mi><mo>⁡</mo><msup><mi>θ</mi><mo>′</mo></msup>:'
- en: <nobr aria-hidden="true">sinθ′=ηη′⋅sinθ</nobr><mi>sin</mi><mo>⁡</mo><msup><mi>θ</mi><mo>′</mo></msup><mo>=</mo><mfrac><mi>η</mi><msup><mi>η</mi><mo>′</mo></msup></mfrac><mo>⋅</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi>
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">sinθ′=ηη′⋅sinθ</nobr><mi>sin</mi><mo>⁡</mo><msup><mi>θ</mi><mo>′</mo></msup><mo>=</mo><mfrac><mi>η</mi><msup><mi>η</mi><mo>′</mo></msup></mfrac><mo>⋅</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi>
- en: 'On the refracted side of the surface there is a refracted ray <nobr aria-hidden="true">R′</nobr><mrow
    class="MJX-TeXAtom-ORD"><msup><mi mathvariant="bold">R</mi><mo>′</mo></msup></mrow>
    and a normal <nobr aria-hidden="true">n′</nobr><mrow class="MJX-TeXAtom-ORD"><msup><mi
    mathvariant="bold">n</mi><mo>′</mo></msup></mrow>, and there exists an angle,
    <nobr aria-hidden="true">θ′</nobr><msup><mi>θ</mi><mo>′</mo></msup>, between them.
    We can split <nobr aria-hidden="true">R′</nobr><mrow class="MJX-TeXAtom-ORD"><msup><mi
    mathvariant="bold">R</mi><mo>′</mo></msup></mrow> into the parts of the ray that
    are perpendicular to <nobr aria-hidden="true">n′</nobr><mrow class="MJX-TeXAtom-ORD"><msup><mi
    mathvariant="bold">n</mi><mo>′</mo></msup></mrow> and parallel to <nobr aria-hidden="true">n′</nobr><mrow
    class="MJX-TeXAtom-ORD"><msup><mi mathvariant="bold">n</mi><mo>′</mo></msup></mrow>:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 在表面的折射侧有一个折射光线 <nobr aria-hidden="true">R′</nobr><mrow class="MJX-TeXAtom-ORD"><msup><mi
    mathvariant="bold">R</mi><mo>′</mo></msup></mrow> 和一个法线 <nobr aria-hidden="true">n′</nobr><mrow
    class="MJX-TeXAtom-ORD"><msup><mi mathvariant="bold">n</mi><mo>′</mo></msup></mrow>，它们之间存在一个角度，<nobr
    aria-hidden="true">θ′</nobr><msup><mi>θ</mi><mo>′</mo></msup>。我们可以将 <nobr aria-hidden="true">R′</nobr><mrow
    class="MJX-TeXAtom-ORD"><msup><mi mathvariant="bold">R</mi><mo>′</mo></msup></mrow>
    分解为与 <nobr aria-hidden="true">n′</nobr><mrow class="MJX-TeXAtom-ORD"><msup><mi
    mathvariant="bold">n</mi><mo>′</mo></msup></mrow> 垂直和平行的部分：
- en: <nobr aria-hidden="true">R′=R′⊥+R′∥</nobr><mrow class="MJX-TeXAtom-ORD"><msup><mi
    mathvariant="bold">R</mi><mo>′</mo></msup></mrow><mo>=</mo><msub><mrow class="MJX-TeXAtom-ORD"><msup><mi
    mathvariant="bold">R</mi><mo>′</mo></msup></mrow><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="normal">⊥</mi></mrow></msub><mo>+</mo><msub><mrow class="MJX-TeXAtom-ORD"><msup><mi
    mathvariant="bold">R</mi><mo>′</mo></msup></mrow><mrow class="MJX-TeXAtom-ORD"><mo>∥</mo></mrow></msub>
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">R′=R′⊥+R′∥</nobr><mrow class="MJX-TeXAtom-ORD"><msup><mi
    mathvariant="bold">R</mi><mo>′</mo></msup></mrow><mo>=</mo><msub><mrow class="MJX-TeXAtom-ORD"><msup><mi
    mathvariant="bold">R</mi><mo>′</mo></msup></mrow><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="normal">⊥</mi></mrow></msub><mo>+</mo><msub><mrow class="MJX-TeXAtom-ORD"><msup><mi
    mathvariant="bold">R</mi><mo>′</mo></msup></mrow><mrow class="MJX-TeXAtom-ORD"><mo>∥</mo></mrow></msub>
- en: 'If we solve for <nobr aria-hidden="true">R′⊥</nobr><msub><mrow class="MJX-TeXAtom-ORD"><msup><mi
    mathvariant="bold">R</mi><mo>′</mo></msup></mrow><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="normal">⊥</mi></mrow></msub> and <nobr aria-hidden="true">R′∥</nobr><msub><mrow
    class="MJX-TeXAtom-ORD"><msup><mi mathvariant="bold">R</mi><mo>′</mo></msup></mrow><mrow
    class="MJX-TeXAtom-ORD"><mo>∥</mo></mrow></msub> we get:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们求解 <nobr aria-hidden="true">R′⊥</nobr><msub><mrow class="MJX-TeXAtom-ORD"><msup><mi
    mathvariant="bold">R</mi><mo>′</mo></msup></mrow><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="normal">⊥</mi></mrow></msub> 和 <nobr aria-hidden="true">R′∥</nobr><msub><mrow
    class="MJX-TeXAtom-ORD"><msup><mi mathvariant="bold">R</mi><mo>′</mo></msup></mrow><mrow
    class="MJX-TeXAtom-ORD"><mo>∥</mo></mrow></msub>，我们得到：
- en: <nobr aria-hidden="true">R′⊥=ηη′(R+|R|cos(θ)n)</nobr><msub><mrow class="MJX-TeXAtom-ORD"><msup><mi
    mathvariant="bold">R</mi><mo>′</mo></msup></mrow><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="normal">⊥</mi></mrow></msub><mo>=</mo><mfrac><mi>η</mi><msup><mi>η</mi><mo>′</mo></msup></mfrac><mo
    stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">R</mi></mrow><mo>+</mo><mrow
    class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">R</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mi>cos</mi><mo>⁡</mo><mo
    stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">n</mi></mrow><mo stretchy="false">)</mo><nobr aria-hidden="true">R′∥=−1−|R′⊥|2−−−−−−−−√n</nobr><msub><mrow
    class="MJX-TeXAtom-ORD"><msup><mi mathvariant="bold">R</mi><mo>′</mo></msup></mrow><mrow
    class="MJX-TeXAtom-ORD"><mo>∥</mo></mrow></msub><mo>=</mo><mo>−</mo><msqrt><mn>1</mn><mo>−</mo><mrow
    class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><msub><mrow class="MJX-TeXAtom-ORD"><msup><mi
    mathvariant="bold">R</mi><mo>′</mo></msup></mrow><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="normal">⊥</mi></mrow></msub><msup><mrow class="MJX-TeXAtom-ORD"><mo
    stretchy="false">|</mo></mrow><mn>2</mn></msup></msqrt><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">n</mi></mrow>
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">R′⊥=ηη′(R+|R|cos(θ)n)</nobr><msub><mrow class="MJX-TeXAtom-ORD"><msup><mi
    mathvariant="bold">R</mi><mo>′</mo></msup></mrow><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="normal">⊥</mi></mrow></msub><mo>=</mo><mfrac><mi>η</mi><msup><mi>η</mi><mo>′</mo></msup></mfrac><mo
    stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">R</mi></mrow><mo>+</mo><mrow
    class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">R</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mi>cos</mi><mo>⁡</mo><mo
    stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">n</mi></mrow><mo stretchy="false">)</mo><nobr aria-hidden="true">R′∥=−1−|R′⊥|2−−−−−−−−√n</nobr><msub><mrow
    class="MJX-TeXAtom-ORD"><msup><mi mathvariant="bold">R</mi><mo>′</mo></msup></mrow><mrow
    class="MJX-TeXAtom-ORD"><mo>∥</mo></mrow></msub><mo>=</mo><mo>−</mo><msqrt><mn>1</mn><mo>−</mo><mrow
    class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><msub><mrow class="MJX-TeXAtom-ORD"><msup><mi
    mathvariant="bold">R</mi><mo>′</mo></msup></mrow><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="normal">⊥</mi></mrow></msub><msup><mrow class="MJX-TeXAtom-ORD"><mo
    stretchy="false">|</mo></mrow><mn>2</mn></msup></msqrt><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">n</mi></mrow>
- en: You can go ahead and prove this for yourself if you want, but we will treat
    it as fact and move on. The rest of the book will not require you to understand
    the proof.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想亲自证明这一点，可以继续，但我们将把它作为事实并继续前进。本书的其余部分不需要你理解证明过程。
- en: 'We know the value of every term on the right-hand side except for <nobr aria-hidden="true">cosθ</nobr><mi>cos</mi><mo>⁡</mo><mi>θ</mi>.
    It is well known that the dot product of two vectors can be explained in terms
    of the cosine of the angle between them:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道右侧每个项的值，除了 <nobr aria-hidden="true">cosθ</nobr><mi>cos</mi><mo>⁡</mo><mi>θ</mi>。众所周知，两个向量的点积可以用它们之间角度的余弦来解释：
- en: <nobr aria-hidden="true">a⋅b=|a||b|cosθ</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">a</mi></mrow><mo>⋅</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">b</mi></mrow><mo>=</mo><mrow
    class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">a</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mrow
    class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">b</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi>
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">a⋅b=|a||b|cosθ</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">a</mi></mrow><mo>⋅</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">b</mi></mrow><mo>=</mo><mrow
    class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">a</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mrow
    class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">b</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi>
- en: 'If we restrict <nobr aria-hidden="true">a</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">a</mi></mrow> and <nobr aria-hidden="true">b</nobr><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">b</mi></mrow> to be unit vectors:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 <nobr aria-hidden="true">a</nobr><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">a</mi></mrow>
    和 <nobr aria-hidden="true">b</nobr><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">b</mi></mrow>
    限制为单位向量：
- en: <nobr aria-hidden="true">a⋅b=cosθ</nobr><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">a</mi></mrow><mo>⋅</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">b</mi></mrow><mo>=</mo><mi>cos</mi><mo>⁡</mo><mi>θ</mi>
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">a⋅b=cosθ</nobr><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">a</mi></mrow><mo>⋅</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">b</mi></mrow><mo>=</mo><mi>cos</mi><mo>⁡</mo><mi>θ</mi>
- en: 'We can now rewrite <nobr aria-hidden="true">R′⊥</nobr><msub><mrow class="MJX-TeXAtom-ORD"><msup><mi
    mathvariant="bold">R</mi><mo>′</mo></msup></mrow><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="normal">⊥</mi></mrow></msub> in terms of known quantities:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以用已知量来重新表示 <nobr aria-hidden="true">R′⊥</nobr><msub><mrow class="MJX-TeXAtom-ORD"><msup><mi
    mathvariant="bold">R</mi><mo>′</mo></msup></mrow><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="normal">⊥</mi></mrow></msub>：
- en: '<nobr aria-hidden="true">R′⊥=ηη′(R+(−R⋅n)n)</nobr><msub><mrow class="MJX-TeXAtom-ORD"><msup><mi
    mathvariant="bold">R</mi><mo>′</mo></msup></mrow><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="normal">⊥</mi></mrow></msub><mo>=</mo><mfrac><mi>η</mi><msup><mi>η</mi><mo>′</mo></msup></mfrac><mo
    stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">R</mi></mrow><mo>+</mo><mo
    stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mo mathvariant="bold">−</mo><mi
    mathvariant="bold">R</mi></mrow><mo>⋅</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">n</mi></mrow><mo
    stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">n</mi></mrow><mo
    stretchy="false">)</mo>When we combine them back together, we can write a function
    to calculate <nobr aria-hidden="true">R′</nobr><mrow class="MJX-TeXAtom-ORD"><msup><mi
    mathvariant="bold">R</mi><mo>′</mo></msup></mrow>:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">R′⊥=ηη′(R+(−R⋅n)n)</nobr><msub><mrow class="MJX-TeXAtom-ORD"><msup><mi
    mathvariant="bold">R</mi><mo>′</mo></msup></mrow><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="normal">⊥</mi></mrow></msub><mo>=</mo><mfrac><mi>η</mi><msup><mi>η</mi><mo>′</mo></msup></mfrac><mo
    stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">R</mi></mrow><mo>+</mo><mo
    stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mo mathvariant="bold">−</mo><mi
    mathvariant="bold">R</mi></mrow><mo>⋅</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">n</mi></mrow><mo
    stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="bold">n</mi></mrow><mo
    stretchy="false">)</mo>当我们把它们组合在一起时，我们可以编写一个函数来计算 <nobr aria-hidden="true">R′</nobr><mrow
    class="MJX-TeXAtom-ORD"><msup><mi mathvariant="bold">R</mi><mo>′</mo></msup></mrow>：
- en: '[PRE75]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '**Listing 71:** `[vec3.h]` Refraction functionAnd the dielectric material that
    always refracts is:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 71**：`[vec3.h]` 折射函数始终折射的介电材料是：'
- en: '[PRE76]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '**Listing 72:** `[material.h]` Dielectric material class that always refractsNow
    we''ll update the scene to illustrate refraction by changing the left sphere to
    glass, which has an index of refraction of approximately 1.5.'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 72**：`[material.h]` 始终折射的介电材料类现在我们将场景更新为通过将左侧球体改为玻璃来展示折射，玻璃的折射率约为1.5。'
- en: '[PRE77]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '**Listing 73:** `[main.cc]` Changing the left sphere to glassThis gives us
    the following result:[![](https://raytracing.github.io/images/img-1.16-glass-always-refract.png)](https://raytracing.github.io/images/img-1.16-glass-always-refract.png)Image
    16: Glass sphere that always refracts'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 73**：`[main.cc]` 将左侧球体改为玻璃这给我们以下结果：[![](https://raytracing.github.io/images/img-1.16-glass-always-refract.png)](https://raytracing.github.io/images/img-1.16-glass-always-refract.png)
    图16：始终折射的玻璃球体'
- en: Total Internal Reflection
  id: totrans-518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总内反射
- en: 'One troublesome practical issue with refraction is that there are ray angles
    for which no solution is possible using Snell''s law. When a ray enters a medium
    of lower index of refraction at a sufficiently glancing angle, it can refract
    with an angle greater than 90°. If we refer back to Snell''s law and the derivation
    of <nobr aria-hidden="true">sinθ′</nobr><mi>sin</mi><mo>⁡</mo><msup><mi>θ</mi><mo>′</mo></msup>:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 折射中存在的一个棘手的问题是，对于某些射线角度，使用斯涅尔定律无法找到解决方案。当射线以足够大的斜角进入折射率较低的介质时，它可以以大于90°的角度折射。如果我们回顾斯涅尔定律和
    <nobr aria-hidden="true">sinθ′</nobr><mi>sin</mi><mo>⁡</mo><msup><mi>θ</mi><mo>′</mo></msup>
    的推导：
- en: <nobr aria-hidden="true">sinθ′=ηη′⋅sinθ</nobr><mi>sin</mi><mo>⁡</mo><msup><mi>θ</mi><mo>′</mo></msup><mo>=</mo><mfrac><mi>η</mi><msup><mi>η</mi><mo>′</mo></msup></mfrac><mo>⋅</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi>
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">sinθ′=ηη′⋅sinθ</nobr><mi>sin</mi><mo>⁡</mo><msup><mi>θ</mi><mo>′</mo></msup><mo>=</mo><mfrac><mi>η</mi><msup><mi>η</mi><mo>′</mo></msup></mfrac><mo>⋅</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi>
- en: 'If the ray is inside glass and outside is air (<nobr aria-hidden="true">η=1.5</nobr><mi>η</mi><mo>=</mo><mn>1.5</mn>
    and <nobr aria-hidden="true">η′=1.0</nobr><msup><mi>η</mi><mo>′</mo></msup><mo>=</mo><mn>1.0</mn>):'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 如果光线在玻璃内部，外部是空气（<nobr aria-hidden="true">η=1.5</nobr><mi>η</mi><mo>=</mo><mn>1.5</mn>
    和 <nobr aria-hidden="true">η′=1.0</nobr><msup><mi>η</mi><mo>′</mo></msup><mo>=</mo><mn>1.0</mn>）：
- en: <nobr aria-hidden="true">sinθ′=1.51.0⋅sinθ</nobr><mi>sin</mi><mo>⁡</mo><msup><mi>θ</mi><mo>′</mo></msup><mo>=</mo><mfrac><mn>1.5</mn><mn>1.0</mn></mfrac><mo>⋅</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi>The
    value of <nobr aria-hidden="true">sinθ′</nobr><mi>sin</mi><mo>⁡</mo><msup><mi>θ</mi><mo>′</mo></msup>
    cannot be greater than 1\. So, if,<nobr aria-hidden="true">1.51.0⋅sinθ>1.0</nobr><mfrac><mn>1.5</mn><mn>1.0</mn></mfrac><mo>⋅</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi><mo>></mo><mn>1.0</mn>
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">sinθ′=1.5/1.0⋅sinθ</nobr><mi>sin</mi><mo>⁡</mo><msup><mi>θ</mi><mo>′</mo></msup><mo>=</mo><mfrac><mn>1.5</mn><mn>1.0</mn></mfrac><mo>⋅</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi>The
    value of <nobr aria-hidden="true">sinθ′</nobr><mi>sin</mi><mo>⁡</mo><msup><mi>θ</mi><mo>′</mo></msup>
    cannot be greater than 1\. So, if,<nobr aria-hidden="true">1.5/1.0⋅sinθ>1.0</nobr><mfrac><mn>1.5</mn><mn>1.0</mn></mfrac><mo>⋅</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi><mo>></mo><mn>1.0</mn>
- en: 'the equality between the two sides of the equation is broken, and a solution
    cannot exist. If a solution does not exist, the glass cannot refract, and therefore
    must reflect the ray:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式两边的等式被打破，不存在解。如果不存在解，玻璃不能折射，因此必须反射光线：
- en: '[PRE78]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '**Listing 74:** `[material.h]` Determining if the ray can refract'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 74:** `[material.h]` 判断光线是否可以折射'
- en: Here all the light is reflected, and because in practice that is usually inside
    solid objects, it is called *total internal reflection*. This is why sometimes
    the water-to-air boundary acts as a perfect mirror when you are submerged — if
    you're under water looking up, you can see things above the water, but when you
    are close to the surface and looking sideways, the water surface looks like a
    mirror.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里所有光线都被反射，因为实际上这通常是在固体物体内部，所以它被称为 *全内反射*。这就是为什么有时当你浸没在水中时，水-空气边界会像一个完美的镜子——如果你在水中向上看，你可以看到水面以上的东西，但是当你靠近水面并朝侧面看时，水面看起来像一面镜子。
- en: 'We can solve for `sin_theta` using the trigonometric identities:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用三角恒等式求解 `sin_theta`：
- en: <nobr aria-hidden="true">sinθ=1−cos2θ−−−−−−−−√</nobr><mi>sin</mi><mo>⁡</mo><mi>θ</mi><mo>=</mo><msqrt><mn>1</mn><mo>−</mo><msup><mi>cos</mi><mn>2</mn></msup><mo>⁡</mo><mi>θ</mi></msqrt>
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">sinθ=√(1−cos²θ)</nobr><mi>sin</mi><mo>⁡</mo><mi>θ</mi><mo>=</mo><msqrt><mn>1</mn><mo>−</mo><msup><mi>cos</mi><mn>2</mn></msup><mo>⁡</mo><mi>θ</mi></msqrt>
- en: and
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: <nobr aria-hidden="true">cosθ=R⋅n</nobr><mi>cos</mi><mo>⁡</mo><mi>θ</mi><mo>=</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">R</mi></mrow><mo>⋅</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">n</mi></mrow>
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">cosθ=R⋅n</nobr><mi>cos</mi><mo>⁡</mo><mi>θ</mi><mo>=</mo><mrow
    class="MJX-TeXAtom-ORD"><mi mathvariant="bold">R</mi></mrow><mo>⋅</mo><mrow class="MJX-TeXAtom-ORD"><mi
    mathvariant="bold">n</mi></mrow>
- en: '[PRE79]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '**Listing 75:** `[material.h]` Determining if the ray can refractAnd the dielectric
    material that always refracts (when possible) is:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 75:** `[material.h]` 判断光线是否可以折射，以及总是折射（如果可能）的介质是：'
- en: '[PRE80]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '**Listing 76:** `[material.h]` Dielectric material class with reflection'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 76:** `[material.h]` 具有反射的介质材料类'
- en: Attenuation is always 1 — the glass surface absorbs nothing.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 衰减总是 1——玻璃表面不吸收任何东西。
- en: If we render the prior scene with the new `dielectric::scatter()` function,
    we see … no change. Huh?
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用新的 `dielectric::scatter()` 函数渲染先前的场景，我们看到……没有变化。咦？
- en: Well, it turns out that given a sphere of material with an index of refraction
    greater than air, there's no incident angle that will yield total internal reflection
    — neither at the ray-sphere entrance point nor at the ray exit. This is due to
    the geometry of spheres, as a grazing incoming ray will always be bent to a smaller
    angle, and then bent back to the original angle on exit.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，结果是，给定一个折射率大于空气的材料的球体，没有入射角会产生全内反射——无论是光线进入球体的点还是光线离开的点。这是由于球体的几何形状，因为掠入射的光线总是会弯曲到一个更小的角度，然后在离开时弯曲回原来的角度。
- en: So how can we illustrate total internal reflection? Well, if the sphere has
    an index of refraction *less* than the medium it's in, then we can hit it with
    shallow grazing angles, getting total *external* reflection. That should be good
    enough to observe the effect.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 那我们如何说明全内反射呢？嗯，如果球体的折射率小于它所在的介质，那么我们可以用浅掠入射角去撞击它，得到全外反射。这应该足以观察到效果。
- en: We'll model a world filled with water (index of refraction approximately 1.33),
    and change the sphere material to air (index of refraction 1.00) — an air bubble!
    To do this, change the left sphere material's index of refraction to
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将模拟一个充满水的世界（折射率约为 1.33），并将球体材料改为空气（折射率 1.00）——一个气泡！为此，将左球体材料的折射率改为
- en: <nobr aria-hidden="true">index of refraction of airindex of refraction of water</nobr><mfrac><mtext>index
    of refraction of air</mtext><mtext>index of refraction of water</mtext></mfrac>
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: <nobr aria-hidden="true">空气折射率/水折射率</nobr><mfrac><mtext>空气折射率</mtext><mtext>水折射率</mtext></mfrac>
- en: '[PRE81]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '**Listing 77:** `[main.cc]` Left sphere is an air bubble in waterThis change
    yields the following render:[![](https://raytracing.github.io/images/img-1.17-air-bubble-total-reflection.png)](https://raytracing.github.io/images/img-1.17-air-bubble-total-reflection.png)Image
    17: Air bubble sometimes refracts, sometimes reflects'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 77:** `[main.cc]` 左球是水中的气泡This change yields the following render:[![](https://raytracing.github.io/images/img-1.17-air-bubble-total-reflection.png)](https://raytracing.github.io/images/img-1.17-air-bubble-total-reflection.png)图
    17：气泡有时折射，有时反射'
- en: Here you can see that more-or-less direct rays refract, while glancing rays
    reflect.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到大致直接的光线会折射，而掠射光线会反射。
- en: Schlick Approximation
  id: totrans-544
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Schlick 近似
- en: 'Now real glass has reflectivity that varies with angle — look at a window at
    a steep angle and it becomes a mirror. There is a big ugly equation for that,
    but almost everybody uses a cheap and surprisingly accurate polynomial approximation
    by Christophe Schlick. This yields our full glass material:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 现实中的玻璃具有随角度变化的反射率——以陡峭的角度看窗户，它变成了镜子。为此有一个很大的丑陋方程，但几乎每个人都使用 Christophe Schlick
    提出的一个便宜且出奇准确的多项式近似。这产生了我们的全玻璃材料：
- en: '[PRE82]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '**Listing 78:** `[material.h]` Full glass material'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 78:** `[material.h]` 全玻璃材料'
- en: Modeling a Hollow Glass Sphere
  id: totrans-548
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空心玻璃球的建模
- en: Let's model a hollow glass sphere. This is a sphere of some thickness with another
    sphere of air inside it. If you think about the path of a ray going through such
    an object, it will hit the outer sphere, refract, hit the inner sphere (assuming
    we do hit it), refract a second time, and travel through the air inside. Then
    it will continue on, hit the inside surface of the inner sphere, refract back,
    then hit the inside surface of the outer sphere, and finally refract and exit
    back into the scene atmosphere.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们模拟一个空心玻璃球。这是一个有一定厚度的球体，里面有一个空气球。如果你考虑光线穿过这样一个物体的路径，它将击中外球，折射，击中内球（假设我们确实击中了它），第二次折射，然后穿过球内的空气。然后它将继续前进，击中内球的内表面，折射回来，然后击中外球的内表面，最后折射并返回场景大气中。
- en: The outer sphere is just modeled with a standard glass sphere, with a refractive
    index of around 1.50 (modeling a refraction from the outside air into glass).
    The inner sphere is a bit different because *its* refractive index should be relative
    to the material of the surrounding outer sphere, thus modeling a transition from
    glass into the inner air.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 外球只是用标准玻璃球建模，折射率约为 1.50（模拟从外部空气进入玻璃的折射）。内球则略有不同，因为*它的*折射率应该相对于周围的外球材料，从而模拟从玻璃进入内空气的过渡。
- en: This is actually simple to specify, as the `refraction_index` parameter to the
    dielectric material can be interpreted as the *ratio* of the refractive index
    of the object divided by the refractive index of the enclosing medium. In this
    case, the inner sphere would have an refractive index of air (the inner sphere
    material) over the index of refraction of glass (the enclosing medium), or <nobr
    aria-hidden="true">1.00/1.50=0.67</nobr><mn>1.00</mn><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>1.50</mn><mo>=</mo><mn>0.67</mn>.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上很简单就可以指定，因为电介质材料的 `refraction_index` 参数可以解释为物体折射率与包围介质折射率的*比值*。在这种情况下，内球将具有空气折射率（内球材料）与玻璃折射率（包围介质）的比值，或者
    <nobr aria-hidden="true">1.00/1.50=0.67</nobr><mn>1.00</mn><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>1.50</mn><mo>=</mo><mn>0.67</mn>.
- en: 'Here''s the code:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: '[PRE83]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '**Listing 79:** `[main.cc]` Scene with hollow glass sphereAnd here''s the result:[![](https://raytracing.github.io/images/img-1.18-glass-hollow.png)](https://raytracing.github.io/images/img-1.18-glass-hollow.png)Image
    18: A hollow glass sphere'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 79:** `[main.cc]` 带空心玻璃球的场景And here''s the result:[![](https://raytracing.github.io/images/img-1.18-glass-hollow.png)](https://raytracing.github.io/images/img-1.18-glass-hollow.png)图
    18：空心玻璃球'
- en: Positionable Camera
  id: totrans-555
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可定位相机
- en: Cameras, like dielectrics, are a pain to debug, so I always develop mine incrementally.
    First, let’s allow for an adjustable field of view (*fov*). This is the visual
    angle from edge to edge of the rendered image. Since our image is not square,
    the fov is different horizontally and vertically. I always use vertical fov. I
    also usually specify it in degrees and change to radians inside a constructor
    — a matter of personal taste.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像机，就像电介质一样，调试起来很麻烦，所以我总是逐步开发我的摄像机。首先，让我们允许调整视场角（*fov*）。这是渲染图像边缘到边缘的视角。由于我们的图像不是正方形，水平方向和垂直方向的fov是不同的。我总是使用垂直fov。我也通常用度数指定它，并在构造函数内部将其转换为弧度——这是一个个人喜好问题。
- en: Camera Viewing Geometry
  id: totrans-557
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摄像机观看几何
- en: 'First, we''ll keep the rays coming from the origin and heading to the <nobr
    aria-hidden="true">z=−1</nobr><mi>z</mi><mo>=</mo><mo>−</mo><mn>1</mn> plane.
    We could make it the <nobr aria-hidden="true">z=−2</nobr><mi>z</mi><mo>=</mo><mo>−</mo><mn>2</mn>
    plane, or whatever, as long as we made <nobr aria-hidden="true">h</nobr><mi>h</mi>
    a ratio to that distance. Here is our setup:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将保持从原点发出的光线朝向 <nobr aria-hidden="true">z=−1</nobr><mi>z</mi><mo>=</mo><mo>−</mo><mn>1</mn>
    平面。我们可以将其设置为 <nobr aria-hidden="true">z=−2</nobr><mi>z</mi><mo>=</mo><mo>−</mo><mn>2</mn>
    平面，或者任何其他平面，只要我们使 <nobr aria-hidden="true">h</nobr><mi>h</mi> 与该距离成比例。以下是我们的设置：
- en: '[![](https://raytracing.github.io/images/fig-1.18-cam-view-geom.jpg)](https://raytracing.github.io/images/fig-1.18-cam-view-geom.jpg)**Figure 18:**
    Camera viewing geometry (from the side)This implies <nobr aria-hidden="true">h=tan(θ2)</nobr><mi>h</mi><mo>=</mo><mi>tan</mi><mo>⁡</mo><mo
    stretchy="false">(</mo><mfrac><mi>θ</mi><mn>2</mn></mfrac><mo stretchy="false">)</mo>.
    Our camera now becomes:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](https://raytracing.github.io/images/fig-1.18-cam-view-geom.jpg)](https://raytracing.github.io/images/fig-1.18-cam-view-geom.jpg)**图18：**
    摄像机观看几何（侧面）这表示 <nobr aria-hidden="true">h=tan(θ2)</nobr><mi>h</mi><mo>=</mo><mi>tan</mi><mo>⁡</mo><mo
    stretchy="false">(</mo><mfrac><mi>θ</mi><mn>2</mn></mfrac><mo stretchy="false">)</mo>.
    我们现在的摄像机变为：'
- en: '[PRE84]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '**Listing 80:** `[camera.h]` Camera with adjustable field-of-view (fov)We''ll
    test out these changes with a simple scene of two touching spheres, using a 90°
    field of view.'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表80：** `[camera.h]` 可调节视场角（fov）的摄像机我们将通过一个简单的两个接触球体的场景来测试这些更改，使用90°的视场角。'
- en: '[PRE85]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '**Listing 81:** `[main.cc]` Scene with wide-angle cameraThis gives us the rendering:[![](https://raytracing.github.io/images/img-1.19-wide-view.png)](https://raytracing.github.io/images/img-1.19-wide-view.png)Image
    19: A wide-angle view'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表81：** `[main.cc]` 宽角摄像机场景这给我们带来了渲染效果：[![](https://raytracing.github.io/images/img-1.19-wide-view.png)](https://raytracing.github.io/images/img-1.19-wide-view.png)图19：宽角视图'
- en: Positioning and Orienting the Camera
  id: totrans-564
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定位和定向摄像机
- en: To get an arbitrary viewpoint, let’s first name the points we care about. We’ll
    call the position where we place the camera *lookfrom*, and the point we look
    at *lookat*. (Later, if you want, you could define a direction to look in instead
    of a point to look at.)
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得任意视角，让我们首先命名我们关心的点。我们将放置摄像机的位置称为 *lookfrom*，我们看的点称为 *lookat*。（稍后，如果你愿意，你可以定义一个看的方向而不是看的点。）
- en: 'We also need a way to specify the roll, or sideways tilt, of the camera: the
    rotation around the lookat-lookfrom axis. Another way to think about it is that
    even if you keep `lookfrom` and `lookat` constant, you can still rotate your head
    around your nose. What we need is a way to specify an “up” vector for the camera.'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一种方法来指定摄像机的翻滚或侧倾：即绕着lookat-lookfrom轴的旋转。另一种思考方式是，即使你保持`lookfrom`和`lookat`不变，你仍然可以围绕你的鼻子旋转你的头。我们需要的是为摄像机指定一个“向上”向量的方法。
- en: '[![](https://raytracing.github.io/images/fig-1.19-cam-view-dir.jpg)](https://raytracing.github.io/images/fig-1.19-cam-view-dir.jpg)**Figure 19:**
    Camera view direction'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](https://raytracing.github.io/images/fig-1.19-cam-view-dir.jpg)](https://raytracing.github.io/images/fig-1.19-cam-view-dir.jpg)**图19：**
    摄像机视图方向'
- en: We can specify any up vector we want, as long as it's not parallel to the view
    direction. Project this up vector onto the plane orthogonal to the view direction
    to get a camera-relative up vector. I use the common convention of naming this
    the “view up” (*vup*) vector. After a few cross products and vector normalizations,
    we now have a complete orthonormal basis <nobr aria-hidden="true">(u,v,w)</nobr><mo
    stretchy="false">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo>,</mo><mi>w</mi><mo stretchy="false">)</mo>
    to describe our camera’s orientation. <nobr aria-hidden="true">u</nobr><mi>u</mi>
    will be the unit vector pointing to camera right, <nobr aria-hidden="true">v</nobr><mi>v</mi>
    is the unit vector pointing to camera up, <nobr aria-hidden="true">w</nobr><mi>w</mi>
    is the unit vector pointing opposite the view direction (since we use right-hand
    coordinates), and the camera center is at the origin.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定任何我们想要的向上向量，只要它不与视角方向平行。将这个向上向量投影到与视角方向正交的平面上，以获得相机相关的向上向量。我使用常见的命名惯例，将其命名为“视图向上”
    (*vup*) 向量。经过几次叉乘和向量归一化后，我们现在有一个完整的正交归一基 <nobr aria-hidden="true">(u,v,w)</nobr><mo
    stretchy="false">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo>,</mo><mi>w</mi><mo stretchy="false">)</mo>
    来描述我们的相机方向。 <nobr aria-hidden="true">u</nobr><mi>u</mi> 将是指向相机右侧的单位向量，<nobr aria-hidden="true">v</nobr><mi>v</mi>
    是指向相机向上的单位向量，<nobr aria-hidden="true">w</nobr><mi>w</mi> 是指向与视角方向相反的单位向量（因为我们使用右手坐标系），并且相机中心在原点。
- en: '[![](https://raytracing.github.io/images/fig-1.20-cam-view-up.jpg)](https://raytracing.github.io/images/fig-1.20-cam-view-up.jpg)**Figure 20:**
    Camera view up direction'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](https://raytracing.github.io/images/fig-1.20-cam-view-up.jpg)](https://raytracing.github.io/images/fig-1.20-cam-view-up.jpg)**图
    20**：相机向上视图方向'
- en: Like before, when our fixed camera faced <nobr aria-hidden="true">−Z</nobr><mo>−</mo><mi>Z</mi>,
    our arbitrary view camera faces <nobr aria-hidden="true">−w</nobr><mo>−</mo><mi>w</mi>.
    Keep in mind that we can — but we don’t have to — use world up <nobr aria-hidden="true">(0,1,0)</nobr><mo
    stretchy="false">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo>
    to specify vup. This is convenient and will naturally keep your camera horizontally
    level until you decide to experiment with crazy camera angles.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，当我们的固定相机面向 <nobr aria-hidden="true">−Z</nobr><mo>−</mo><mi>Z</mi> 时，我们的任意视角相机面向
    <nobr aria-hidden="true">−w</nobr><mo>−</mo><mi>w</mi>。记住，我们可以——但不必——使用世界向上 <nobr
    aria-hidden="true">(0,1,0)</nobr><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo
    stretchy="false">)</mo> 来指定 vup。这是方便的，并且会自然地保持你的相机水平直到你决定尝试疯狂的相机角度。
- en: '[PRE86]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '**Listing 82:** `[camera.h]` Positionable and orientable cameraWe''ll change
    back to the prior scene, and use the new viewpoint:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 82**：`[camera.h]` 可定位和可定向的相机我们将回到先前的场景，并使用新的视角：'
- en: '[PRE87]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '**Listing 83:** `[main.cc]` Scene with alternate viewpointto get:[![](https://raytracing.github.io/images/img-1.20-view-distant.png)](https://raytracing.github.io/images/img-1.20-view-distant.png)Image
    20: A distant viewAnd we can change field of view:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 83**：`[main.cc]` 使用不同视角的场景：[![](https://raytracing.github.io/images/img-1.20-view-distant.png)](https://raytracing.github.io/images/img-1.20-view-distant.png)
    图像 20：远景视图，并且我们可以更改视野：'
- en: '[PRE88]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '**Listing 84:** `[main.cc]` Change field of viewto get:[![](https://raytracing.github.io/images/img-1.21-view-zoom.png)](https://raytracing.github.io/images/img-1.21-view-zoom.png)Image
    21: Zooming in'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 84**：`[main.cc]` 将视野更改为：[![](https://raytracing.github.io/images/img-1.21-view-zoom.png)](https://raytracing.github.io/images/img-1.21-view-zoom.png)
    图像 21：放大视图'
- en: Defocus Blur
  id: totrans-577
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 散焦模糊
- en: 'Now our final feature: *defocus blur*. Note, photographers call this *depth
    of field*, so be sure to only use the term *defocus blur* among your raytracing
    friends.'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们最后的功能：*散焦模糊*。注意，摄影师称之为*景深*，所以请确保在你的光线追踪朋友中只使用术语*散焦模糊*。
- en: 'The reason we have defocus blur in real cameras is because they need a big
    hole (rather than just a pinhole) through which to gather light. A large hole
    would defocus everything, but if we stick a lens in front of the film/sensor,
    there will be a certain distance at which everything is in focus. Objects placed
    at that distance will appear in focus and will linearly appear blurrier the further
    they are from that distance. You can think of a lens this way: all light rays
    coming *from* a specific point at the focus distance — and that hit the lens —
    will be bent back *to* a single point on the image sensor.'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在真实相机中看到散焦模糊的原因是因为它们需要一个大的孔（而不是仅仅是一个小孔）来收集光线。一个大孔会让所有东西都失焦，但如果我们在胶片/传感器前面放一个镜头，那么就会有一个特定的距离，在这个距离上所有东西都是清晰的。放置在这个距离上的物体将看起来是清晰的，而距离这个距离越远，它们就会线性地变得越来越模糊。你可以这样想：所有从焦点距离的特定点发出的光线——并且击中镜头——都会弯曲回图像传感器上的一个单一点。
- en: We call the distance between the camera center and the plane where everything
    is in perfect focus the *focus distance*. Be aware that the focus distance is
    not usually the same as the focal length — the *focal length* is the distance
    between the camera center and the image plane. For our model, however, these two
    will have the same value, as we will put our pixel grid right on the focus plane,
    which is *focus distance* away from the camera center.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '我们称相机中心和所有东西都处于完美焦点平面的距离为**焦距**。请注意，焦距通常不等于焦距——焦距是相机中心和图像平面之间的距离。然而，在我们的模型中，这两个值将相同，因为我们将在焦点平面上放置我们的像素网格，它距离相机中心**焦距**。 '
- en: In a physical camera, the focus distance is controlled by the distance between
    the lens and the film/sensor. That is why you see the lens move relative to the
    camera when you change what is in focus (that may happen in your phone camera
    too, but the sensor moves). The “aperture” is a hole to control how big the lens
    is effectively. For a real camera, if you need more light you make the aperture
    bigger, and will get more blur for objects away from the focus distance. For our
    virtual camera, we can have a perfect sensor and never need more light, so we
    only use an aperture when we want defocus blur.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理相机中，焦距是由镜头和胶片/传感器之间的距离控制的。这就是为什么当你改变焦点时，你会看到镜头相对于相机移动（这可能在你的手机相机中也会发生，但传感器会移动）。"光圈"是一个孔，用于控制镜头的有效大小。对于真正的相机，如果你需要更多的光线，你使光圈变大，这将导致远离焦距的物体产生更多的模糊。对于我们的虚拟相机，我们可以有一个完美的传感器，永远不需要更多的光线，所以我们只在想要失焦模糊时使用光圈。
- en: A Thin Lens Approximation
  id: totrans-582
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 薄镜头近似
- en: 'A real camera has a complicated compound lens. For our code, we could simulate
    the order: sensor, then lens, then aperture. Then we could figure out where to
    send the rays, and flip the image after it''s computed (the image is projected
    upside down on the film). Graphics people, however, usually use a thin lens approximation:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 真实相机有一个复杂的复合镜头。对于我们的代码，我们可以模拟这个顺序：传感器，然后是镜头，然后是光圈。然后我们可以确定发送光线的位置，并在计算后翻转图像（图像在胶片上倒置）。然而，图形人员通常使用薄镜头近似：
- en: '[![](https://raytracing.github.io/images/fig-1.21-cam-lens.jpg)](https://raytracing.github.io/images/fig-1.21-cam-lens.jpg)**Figure 21:**
    Camera lens model'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](https://raytracing.github.io/images/fig-1.21-cam-lens.jpg)](https://raytracing.github.io/images/fig-1.21-cam-lens.jpg)**图21：**相机镜头模型'
- en: We don’t need to simulate any of the inside of the camera — for the purposes
    of rendering an image outside the camera, that would be unnecessary complexity.
    Instead, I usually start rays from an infinitely thin circular “lens”, and send
    them toward the pixel of interest on the focus plane (`focal_length` away from
    the lens), where everything on that plane in the 3D world is in perfect focus.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要模拟相机内部的任何部分——为了渲染相机外的图像，这将是多余的复杂性。相反，我通常从无限薄的圆形“镜头”处开始发射光线，并将它们发送到焦平面上的目标像素（距离镜头`focal_length`），在这个平面上，3D世界中的所有东西都处于完美的焦点。
- en: 'In practice, we accomplish this by placing the viewport in this plane. Putting
    everything together:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我们通过将视口放置在这个平面上来实现这一点。将所有这些放在一起：
- en: The focus plane is orthogonal to the camera view direction.
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 焦平面垂直于相机视图方向。
- en: The focus distance is the distance between the camera center and the focus plane.
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 焦距是相机中心和焦平面之间的距离。
- en: The viewport lies on the focus plane, centered on the camera view direction
    vector.
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视口位于焦平面上，以相机视图方向向量为中心。
- en: The grid of pixel locations lies inside the viewport (located in the 3D world).
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像素位置的网格位于视口（位于3D世界中）内部。
- en: Random image sample locations are chosen from the region around the current
    pixel location.
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机图像样本位置是从当前像素位置周围的区域选择的。
- en: The camera fires rays from random points on the lens through the current image
    sample location.
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相机从镜头上的随机点发射光线，通过当前图像样本位置。
- en: '[![](https://raytracing.github.io/images/fig-1.22-cam-film-plane.jpg)](https://raytracing.github.io/images/fig-1.22-cam-film-plane.jpg)**Figure 22:**
    Camera focus plane'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](https://raytracing.github.io/images/fig-1.22-cam-film-plane.jpg)](https://raytracing.github.io/images/fig-1.22-cam-film-plane.jpg)**图22：**相机焦平面'
- en: Generating Sample Rays
  id: totrans-594
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成样本光线
- en: Without defocus blur, all scene rays originate from the camera center (or `lookfrom`).
    In order to accomplish defocus blur, we construct a disk centered at the camera
    center. The larger the radius, the greater the defocus blur. You can think of
    our original camera as having a defocus disk of radius zero (no blur at all),
    so all rays originated at the disk center (`lookfrom`).
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 没有散焦模糊时，所有场景光线都源自相机中心（或`lookfrom`）。为了实现散焦模糊，我们在相机中心构造一个圆盘。半径越大，散焦模糊越明显。你可以把我们的原始相机想象成具有半径为零的散焦圆盘（完全没有模糊），因此所有光线都源自圆盘中心（`lookfrom`）。
- en: So, how large should the defocus disk be? Since the size of this disk controls
    how much defocus blur we get, that should be a parameter of the camera class.
    We could just take the radius of the disk as a camera parameter, but the blur
    would vary depending on the projection distance. A slightly easier parameter is
    to specify the angle of the cone with apex at viewport center and base (defocus
    disk) at the camera center. This should give you more consistent results as you
    vary the focus distance for a given shot.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，散焦圆盘应该有多大？由于这个圆盘的大小控制着我们能得到多少散焦模糊，因此这应该是相机类的一个参数。我们只需将圆盘的半径作为相机参数即可，但模糊会根据投影距离而变化。一个稍微容易一些的参数是指定以视口中心为顶点、以相机中心为底部的圆锥的角度。这应该会给你提供更一致的结果，因为你在给定镜头中改变焦距。
- en: 'Since we''ll be choosing random points from the defocus disk, we''ll need a
    function to do that: `random_in_unit_disk()`. This function works using the same
    kind of method we use in `random_unit_vector()`, just for two dimensions.'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将从散焦圆盘中选择随机点，我们需要一个函数来完成这个任务：`random_in_unit_disk()`。这个函数使用与我们在`random_unit_vector()`中使用的方法相同，只是针对二维。
- en: '[PRE89]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '**Listing 85:** `[vec3.h]` Generate random point inside unit disk'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 85**：`[vec3.h]` 在单位圆盘中生成随机点'
- en: 'Now let''s update the camera to originate rays from the defocus disk:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更新相机，使其从散焦圆盘发出光线：
- en: '[PRE90]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '**Listing 86:** `[camera.h]` Camera with adjustable depth-of-fieldUsing a large
    aperture:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 86**：`[camera.h]` 可调节景深的相机使用大光圈：'
- en: '[PRE91]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '**Listing 87:** `[main.cc]` Scene camera with depth-of-fieldWe get:[![](https://raytracing.github.io/images/img-1.22-depth-of-field.png)](https://raytracing.github.io/images/img-1.22-depth-of-field.png)Image
    22: Spheres with depth-of-field'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 87**：`[main.cc]` 场景相机具有景深我们得到：[![](https://raytracing.github.io/images/img-1.22-depth-of-field.png)](https://raytracing.github.io/images/img-1.22-depth-of-field.png)
    图像 22：具有景深的球体'
- en: Where Next?
  id: totrans-605
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: A Final Render
  id: totrans-606
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终渲染
- en: Let’s make the image on the cover of this book — lots of random spheres.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们制作这本书的封面图像——许多随机的球体。
- en: '[PRE92]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '**Listing 88:** `[main.cc]` Final scene'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 88**：`[main.cc]` 最终场景'
- en: '(Note that the code above differs slightly from the project sample code: the
    `samples_per_pixel` is set to 500 above for a high-quality image that will take
    quite a while to render. The project source code uses a value of 10 in the interest
    of reasonable run times while developing and validating.)'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: （注意，上面的代码与项目示例代码略有不同：为了获得高质量图像，上面的`samples_per_pixel`设置为500，这将需要相当长的时间来渲染。项目源代码在开发和验证过程中使用10的值，以实现合理的运行时间。）
- en: 'This gives:[![](https://raytracing.github.io/images/img-1.23-book1-final.jpg)](https://raytracing.github.io/images/img-1.23-book1-final.jpg)Image
    23: Final scene'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了：[![](https://raytracing.github.io/images/img-1.23-book1-final.jpg)](https://raytracing.github.io/images/img-1.23-book1-final.jpg)
    图像 23：最终场景
- en: An interesting thing you might note is the glass balls don’t really have shadows
    which makes them look like they are floating. This is not a bug — you don’t see
    glass balls much in real life, where they also look a bit strange, and indeed
    seem to float on cloudy days. A point on the big sphere under a glass ball still
    has lots of light hitting it because the sky is re-ordered rather than blocked.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到的一个有趣的现象是，玻璃球实际上并没有影子，这使得它们看起来像是悬浮在空中。这并不是一个错误——在现实生活中，你很少看到玻璃球，它们看起来也有些奇怪，而且在多云的日子里确实似乎在空中漂浮。在玻璃球下的大球体上的一个点仍然有大量的光线照射到它，因为天空是重新排列而不是被阻挡。
- en: Next Steps
  id: totrans-613
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下一步
- en: You now have a cool ray tracer! What next?
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在有一个很酷的射线追踪器！接下来是什么？
- en: 'Book 2: *Ray Tracing: The Next Week*'
  id: totrans-615
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 书 2：《光线追踪：下周见》
- en: 'The second book in this series builds on the ray tracer you''ve developed here.
    This includes new features such as:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 本系列的第二本书基于你在这里开发的射线追踪器。这包括新的功能，如：
- en: Motion blur — Realistically render moving objects.
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态模糊——真实地渲染移动的物体。
- en: Bounding volume hierarchies — speeding up the rendering of complex scenes.
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 界定体积层次结构——加快复杂场景的渲染速度。
- en: Texture maps — placing images on objects.
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理贴图——在物体上放置图像。
- en: Perlin noise — a random noise generator very useful for many techniques.
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Perlin噪声 — 一个非常有用的随机噪声生成器，适用于许多技术。
- en: Quadrilaterals — something to render besides spheres! Also, the foundation to
    implement disks, triangles, rings or just about any other 2D primitive.
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四边形 — 除了球体之外可以渲染的东西！也是实现圆盘、三角形、环形或其他任何二维原型的基石。
- en: Lights — add sources of light to your scene.
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光线 — 向场景中添加光源。
- en: Transforms — useful for placing and rotating objects.
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变换 — 用于放置和旋转对象。
- en: Volumetric rendering — render smoke, clouds and other gaseous volumes.
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 体积渲染 — 渲染烟雾、云彩和其他气态体积。
- en: 'Book 3: *Ray Tracing: The Rest of Your Life*'
  id: totrans-625
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 书籍3：*光线追踪：你余生的其余部分*
- en: This book expands again on the content from the second book. A lot of this book
    is about improving both the rendered image quality and the renderer performance,
    and focuses on generating the *right* rays and accumulating them appropriately.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书在第二本书的基础上进一步扩展了内容。这本书的很大一部分是关于提高渲染图像质量和渲染器性能，并专注于生成*正确*的光线并适当地累积它们。
- en: This book is for the reader seriously interested in writing professional-level
    ray tracers, and/or interested in the foundation to implement advanced effects
    like subsurface scattering or nested dielectrics.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是为那些真正对编写专业级光线追踪器感兴趣的人，以及那些对实现高级效果（如次表面散射或嵌套电介质）的基础感兴趣的人。
- en: Other Directions
  id: totrans-628
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他方向
- en: 'There are so many additional directions you can take from here, including techniques
    we haven''t (yet?) covered in this series. These include:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里你可以探索很多额外的方向，包括我们在这个系列中尚未（？）涵盖的技术。这些包括：
- en: '**Triangles** — Most cool models are in triangle form. The model I/O is the
    worst and almost everybody tries to get somebody else’s code to do this. This
    also includes efficiently handling large *meshes* of triangles, which present
    their own challenges.'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '**三角形** — 大多数酷炫的模型都是以三角形的形式存在。模型I/O是最糟糕的，几乎每个人都试图使用别人的代码来完成这项工作。这也包括高效地处理大量三角形的*网格*，它们本身也带来了挑战。'
- en: '**Parallelism** — Run <nobr aria-hidden="true">N</nobr><mi>N</mi> copies of
    your code on <nobr aria-hidden="true">N</nobr><mi>N</mi> cores with different
    random seeds. Average the <nobr aria-hidden="true">N</nobr><mi>N</mi> runs. This
    averaging can also be done hierarchically where <nobr aria-hidden="true">N/2</nobr><mi>N</mi><mrow
    class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>2</mn> pairs can be averaged to get
    <nobr aria-hidden="true">N/4</nobr><mi>N</mi><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>4</mn>
    images, and pairs of those can be averaged. That method of parallelism should
    extend well into the thousands of cores with very little coding.'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '**并行处理** — 在具有不同随机种子的N个核心上运行你的代码的N个副本。平均这N次运行。这种平均也可以分层进行，其中N/2对可以平均得到N/4个图像，然后这些图像的对也可以平均。这种方法应该可以很好地扩展到数千个核心，而无需编写太多代码。'
- en: '**Shadow Rays** — When firing rays at light sources, you can determine exactly
    how a particular point is shadowed. With this, you can render crisp or soft shadows,
    adding another degreee of realism to your scenes.'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '**阴影光线** — 当向光源发射光线时，你可以确切地确定特定点的阴影情况。有了这个，你可以渲染清晰或柔和的阴影，为场景增加另一个真实感层次。'
- en: Have fun, and please send me your cool images!
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 玩得开心，并请将你的酷炫图片发给我！
- en: Acknowledgments
  id: totrans-634
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 致谢
- en: '**Original Manuscript Help**'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '**原始手稿帮助**'
- en: Dave Hart
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dave Hart
- en: Jean Buckley
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jean Buckley
- en: '**Web Release**'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络发布**'
- en: '[Berna Kabadayı](https://github.com/bernakabadayi)'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Berna Kabadayı](https://github.com/bernakabadayi)'
- en: '[Lorenzo Mancini](https://github.com/lmancini)'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Lorenzo Mancini](https://github.com/lmancini)'
- en: '[Lori Whippler Hollasch](https://github.com/lorihollasch)'
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Lori Whippler Hollasch](https://github.com/lorihollasch)'
- en: '[Ronald Wotzlaw](https://github.com/ronaldfw)'
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ronald Wotzlaw](https://github.com/ronaldfw)'
- en: '**Corrections and Improvements**'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '**校对和改进**'
- en: '[Aaryaman Vasishta](https://github.com/jammm)'
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Aaryaman Vasishta](https://github.com/jammm)'
- en: Andrew Kensler
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Andrew Kensler
- en: '[Antonio Gamiz](https://github.com/antoniogamiz)'
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Antonio Gamiz](https://github.com/antoniogamiz)'
- en: Apoorva Joshi
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apoorva Joshi
- en: '[Aras Pranckevičius](https://github.com/aras-p)'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Aras Pranckevičius](https://github.com/aras-p)'
- en: '[Arman Uguray](https://github.com/armansito)'
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Arman Uguray](https://github.com/armansito)'
- en: Becker
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Becker
- en: Ben Kerl
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ben Kerl
- en: Benjamin Summerton
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Benjamin Summerton
- en: Bennett Hardwick
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bennett Hardwick
- en: '[Benny Tsang](https://bthtsang.github.io/)'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Benny Tsang](https://bthtsang.github.io/)'
- en: Dan Drummond
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dan Drummond
- en: '[David Chambers](https://github.com/dafhi)'
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[David Chambers](https://github.com/dafhi)'
- en: David Hart
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: David Hart
- en: '[Dimitry Ishenko](https://github.com/dimitry-ishenko)'
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Dimitry Ishenko](https://github.com/dimitry-ishenko)'
- en: '[Dmitry Lomov](https://github.com/mu-lambda)'
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Dmitry Lomov](https://github.com/mu-lambda)'
- en: '[Eric Haines](https://github.com/erich666)'
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Eric Haines](https://github.com/erich666)'
- en: Fabio Sancinetti
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fabio Sancinetti
- en: Filipe Scur
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Filipe Scur
- en: Frank He
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Frank He
- en: '[Gareth Martin](https://github.com/TheThief)'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Gareth Martin](https://github.com/TheThief)'
- en: '[Gerrit Wessendorf](https://github.com/celeph)'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Gerrit Wessendorf](https://github.com/celeph)'
- en: Grue Debry
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grue Debry
- en: '[Gustaf Waldemarson](https://github.com/xaldew)'
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Gustaf Waldemarson](https://github.com/xaldew)'
- en: Ingo Wald
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ingo Wald
- en: Jason Stone
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jason Stone
- en: '[JC-ProgJava](https://github.com/JC-ProgJava)'
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[JC-ProgJava](https://github.com/JC-ProgJava)'
- en: Jean Buckley
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jean Buckley
- en: '[Jeff Smith](https://github.com/whydoubt)'
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Jeff Smith](https://github.com/whydoubt)'
- en: Joey Cho
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Joey Cho
- en: '[John Kilpatrick](https://github.com/rjkilpatrick)'
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[John Kilpatrick](https://github.com/rjkilpatrick)'
- en: '[Kaan Eraslan](https://github.com/D-K-E)'
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Kaan Eraslan](https://github.com/D-K-E)'
- en: '[Lorenzo Mancini](https://github.com/lmancini)'
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Lorenzo Mancini](https://github.com/lmancini)'
- en: '[Manas Kale](https://github.com/manas96)'
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Manas Kale](https://github.com/manas96)'
- en: Marcus Ottosson
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Marcus Ottosson
- en: '[Mark Craig](https://github.com/mrmcsoftware)'
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Mark Craig](https://github.com/mrmcsoftware)'
- en: Markus Boos
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Markus Boos
- en: Matthew Heimlich
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Matthew Heimlich
- en: Nakata Daisuke
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nakata Daisuke
- en: '[Nate Rupsis](https://github.com/rupsis)'
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Nate Rupsis](https://github.com/rupsis)'
- en: '[Niccolò Tiezzi](https://github.com/niccolot)'
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Niccolò Tiezzi](https://github.com/niccolot)'
- en: Paul Melis
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Paul Melis
- en: Phil Cristensen
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Phil Cristensen
- en: '[LollipopFt](https://github.com/LollipopFt)'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[LollipopFt](https://github.com/LollipopFt)'
- en: '[Ronald Wotzlaw](https://github.com/ronaldfw)'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ronald Wotzlaw](https://github.com/ronaldfw)'
- en: '[Shaun P. Lee](https://github.com/shaunplee)'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Shaun P. Lee](https://github.com/shaunplee)'
- en: '[Shota Kawajiri](https://github.com/estshorter)'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Shota Kawajiri](https://github.com/estshorter)'
- en: Tatsuya Ogawa
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tatsuya Ogawa
- en: Thiago Ize
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Thiago Ize
- en: '[Thien Tran](https://github.com/gau-nernst)'
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Thien Tran](https://github.com/gau-nernst)'
- en: Vahan Sosoyan
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vahan Sosoyan
- en: '[WANG Lei](https://github.com/wlbksy)'
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[WANG Lei](https://github.com/wlbksy)'
- en: '[Yann Herklotz](https://github.com/ymherklotz)'
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Yann Herklotz](https://github.com/ymherklotz)'
- en: '[ZeHao Chen](https://github.com/oxine)'
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ZeHao Chen](https://github.com/oxine)'
- en: '**Special Thanks**Thanks to the team at [Limnu](https://limnu.com/) for help
    on the figures.'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '**特别感谢**感谢 [Limnu](https://limnu.com/) 团队对图表的帮助。'
- en: These books are entirely written in Morgan McGuire's fantastic and free [Markdeep](https://casual-effects.com/markdeep/)
    library. To see what this looks like, view the page source from your browser.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 这些书籍完全使用 Morgan McGuire 的神奇且免费的 [Markdeep](https://casual-effects.com/markdeep/)
    库编写。要查看其外观，请从您的浏览器中查看页面源代码。
- en: Thanks to [Helen Hu](https://github.com/hhu) for graciously donating her [https://github.com/RayTracing/](https://github.com/RayTracing/)
    GitHub organization to this project.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢 [Helen Hu](https://github.com/hhu) 慷慨地将她的 [https://github.com/RayTracing/](https://github.com/RayTracing/)
    GitHub 组织捐赠给本项目。
- en: <link rel="stylesheet" href="https://raytracing.github.io/books/../style/book.css">
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: <link rel="stylesheet" href="https://raytracing.github.io/books/../style/book.css">
- en: Citing This Book
  id: totrans-702
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用此书
- en: Consistent citations make it easier to identify the source, location and versions
    of this work. If you are citing this book, we ask that you try to use one of the
    following forms if possible.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 一致的引用使识别本作品的来源、位置和版本变得更容易。如果您正在引用此书，我们建议您尽可能使用以下格式之一。
- en: Basic Data
  id: totrans-704
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本数据
- en: '**Title (series)**: “Ray Tracing in One Weekend Series”'
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标题 (系列)**："一周之内学习光线追踪系列"'
- en: '**Title (book)**: “Ray Tracing in One Weekend”'
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标题 (书籍)**："一周之内学习光线追踪"'
- en: '**Author**: Peter Shirley, Trevor David Black, Steve Hollasch'
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作者**：Peter Shirley, Trevor David Black, Steve Hollasch'
- en: '**Version/Edition**: v4.0.2'
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本/版次**：v4.0.2'
- en: '**Date**: 2025-04-25'
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日期**：2025-04-25'
- en: '**URL (series)**: [https://raytracing.github.io](https://raytracing.github.io)'
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URL (系列)**：[https://raytracing.github.io](https://raytracing.github.io)'
- en: '**URL (book)**: [https://raytracing.github.io/books/raytracinginoneweekend.html](https://raytracing.github.io/books/raytracinginoneweekend.html)'
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URL (书籍)**：[https://raytracing.github.io/books/raytracinginoneweekend.html](https://raytracing.github.io/books/raytracinginoneweekend.html)'
- en: Snippets
  id: totrans-712
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碎片
- en: Markdown
  id: totrans-713
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Markdown
- en: '[PRE93]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: HTML
  id: totrans-715
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTML
- en: '[PRE94]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: LaTeX and BibTex
  id: totrans-717
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LaTeX 和 BibTex
- en: '[PRE95]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: BibLaTeX
  id: totrans-719
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BibLaTeX
- en: '[PRE96]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: IEEE
  id: totrans-721
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IEEE
- en: '[PRE97]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'MLA:'
  id: totrans-723
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'MLA:'
- en: '[PRE98]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: <link rel="stylesheet" href="../style/book.css">
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: <link rel="stylesheet" href="../style/book.css">
