- en: Reductions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少操作
- en: 原文：[https://en.algorithmica.org/hpc/simd/reduction/](https://en.algorithmica.org/hpc/simd/reduction/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/simd/reduction/](https://en.algorithmica.org/hpc/simd/reduction/)
- en: '*Reduction* (also known as *folding* in functional programming) is the action
    of computing the value of some associative and commutative operation (i.e., $(a
    \circ b) \circ c = a \circ (b \circ c)$ and $a \circ b = b \circ a$) over a range
    of arbitrary elements.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*减少操作*（在函数式编程中也称为*折叠*）是在任意元素范围内计算某些结合律和交换律操作（即，$(a \circ b) \circ c = a \circ
    (b \circ c)$和$a \circ b = b \circ a$）的值的行为。'
- en: 'The simplest example of reduction is calculating the sum an array:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的减少操作示例是计算数组的和：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The naive approach is not so straightforward to vectorize, because the state
    of the loop (sum $s$ on the current prefix) depends on the previous iteration.
    The way to overcome this is to split a single scalar accumulator $s$ into 8 separate
    ones, so that $s_i$ would contain the sum of every 8th element of the original
    array, shifted by $i$:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 原始方法不太容易向量化，因为循环的状态（当前前缀上的和`s`）依赖于前一次迭代。克服这个问题的方法是，将单个标量累加器`s`分成8个独立的累加器，这样`s_i`就会包含原始数组每8个元素的和，并且每个`s_i`都向右移动了$i$位：
- en: $$ s_i = \sum_{j=0}^{n / 8} a_{8 \cdot j + i } $$
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: $$ s_i = \sum_{j=0}^{n / 8} a_{8 \cdot j + i } $$
- en: 'If we store these 8 accumulators in a single 256-bit vector, we can update
    them all at once by adding consecutive 8-element segments of the array. With [vector
    extensions](../x86-simd), this is straightforward:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这8个累加器存储在一个256位的向量中，我们可以通过添加数组的连续8元素段来一次性更新它们。使用[向量扩展](../x86-simd)，这很简单：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can use this approach for other reductions, such as for finding the minimum
    or the xor-sum of an array.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这种方法进行其他减少操作，例如寻找数组的最小值或异或和。
- en: '### [#](https://en.algorithmica.org/hpc/simd/reduction/#instruction-level-parallelism)Instruction-Level
    Parallelism'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/simd/reduction/#instruction-level-parallelism)指令级并行'
- en: 'Our implementation matches what the compiler produces automatically, but it
    is actually suboptimal: when we use just one accumulator, [we have to wait](/hpc/pipelining/throughput)
    one cycle between the loop iterations for a vector addition to complete, while
    the [throughput](/hpc/pipelining/tables/) of corresponding instruction is 2 on
    this microarchitecture.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现与编译器自动生成的结果相匹配，但实际上并不最优：当我们只使用一个累加器时，[我们必须等待](/hpc/pipelining/throughput)一个周期，以便在循环迭代之间完成向量加法，而在这个微架构上相应指令的吞吐量是2。
- en: 'If we again divide the array in $B \geq 2$ parts and use a *separate* accumulator
    for each, we can saturate the throughput of vector addition and increase the performance
    twofold:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次将数组分成$B \geq 2$部分，并为每个部分使用一个*独立的*累加器，我们可以饱和向量加法的吞吐量，并将性能提高两倍：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you have more than 2 relevant execution ports, you can increase the `B` constant
    accordingly, but the $n$-fold performance increase will only apply to arrays that
    fit into L1 cache — [memory bandwidth](/hpc/cpu-cache/bandwidth) will be the bottleneck
    for anything larger.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多于2个相关的执行端口，你可以相应地增加`B`常数，但`n`倍的性能提升只会应用于适合L1缓存的数组——[内存带宽](/hpc/cpu-cache/bandwidth)将是任何更大数组的瓶颈。
- en: '### [#](https://en.algorithmica.org/hpc/simd/reduction/#horizontal-summation)Horizontal
    Summation'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/simd/reduction/#horizontal-summation)水平求和'
- en: The part where we sum up the 8 accumulators stored in a vector register into
    a single scalar to get the total sum is called “horizontal summation.”
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将存储在向量寄存器中的8个累加器相加到单个标量以获得总和的部分被称为“水平求和”。
- en: Although extracting and adding every scalar one by one only takes a constant
    number of cycles, it can be computed slightly faster using a [special instruction](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#techs=AVX,AVX2&text=_mm256_hadd_epi32&expand=2941)
    that adds together pairs of adjacent elements in a register.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然逐个提取和添加每个标量只需要常数个周期，但可以使用一个[特殊指令](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#techs=AVX,AVX2&text=_mm256_hadd_epi32&expand=2941)来稍微快一点地计算，该指令将寄存器中相邻元素对相加。
- en: '![](../Images/81ecce41823f2ec0950f81c7ee46d064.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/81ecce41823f2ec0950f81c7ee46d064.png)'
- en: 'Horizontal summation in SSE/AVX. Note how the output is stored: the (a b a
    b) interleaving is common for reducing operations'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: SSE/AVX中的水平求和。注意输出是如何存储的：输出中的(a b a b)交错对于减少操作是常见的
- en: 'Since it is a very specific operation, it can only be done with SIMD intrinsics
    — although the compiler probably emits roughly the same procedure for the scalar
    code anyway:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个非常特定的操作，它只能通过SIMD内联函数来完成——尽管编译器可能仍然会为标量代码生成大致相同的程序：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There are [other similar instructions](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#techs=AVX,AVX2&ig_expand=3037,3009,5135,4870,4870,4872,4875,833,879,874,849,848,6715,4845&text=horizontal),
    e.g., for integer multiplication or calculating absolute differences between adjacent
    elements (used in image processing).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有[其他类似的指令](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#techs=AVX,AVX2&ig_expand=3037,3009,5135,4870,4870,4872,4875,833,879,874,849,848,6715,4845&text=horizontal)，例如，用于整数乘法或计算相邻元素之间的绝对差值（用于图像处理）。
- en: 'There is also one specific instruction, `_mm_minpos_epu16`, that calculates
    the horizontal minimum and its index among eight 16-bit integers. This is the
    only horizontal reduction that works in one go: all others are computed in multiple
    steps. [← Moving Data](https://en.algorithmica.org/hpc/simd/moving/)[Masking and
    Blending →](https://en.algorithmica.org/hpc/simd/masking/)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个特定的指令`_mm_minpos_epu16`，它计算八个16位整数中的水平最小值及其索引。这是唯一一次就能完成的水平归约：其他所有操作都是分多步计算的。[←
    数据移动](https://en.algorithmica.org/hpc/simd/moving/)[掩码和混合 →](https://en.algorithmica.org/hpc/simd/masking/)
