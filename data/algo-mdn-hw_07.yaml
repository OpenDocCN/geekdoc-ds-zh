- en: Loops and Conditionals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环和条件语句
- en: 原文：[https://en.algorithmica.org/hpc/architecture/loops/](https://en.algorithmica.org/hpc/architecture/loops/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/architecture/loops/](https://en.algorithmica.org/hpc/architecture/loops/)
- en: 'Let’s consider a slightly more complex example:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个稍微复杂一些的例子：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It calculates the sum of a 32-bit integer array, just as a simple `for` loop
    would.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 它计算了一个 32 位整数数组的总和，就像简单的 `for` 循环一样。
- en: 'The “body” of the loop is `add edx, DWORD PTR [rax]`: this instruction loads
    data from the iterator `rax` and adds it to the accumulator `edx`. Next, we move
    the iterator 4 bytes forward with `add rax, 4`. Then, a slightly more complicated
    thing happens.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的“主体”是 `add edx, DWORD PTR [rax]`：这条指令从迭代器 `rax` 加载数据并将其加到累加器 `edx` 上。接下来，我们使用
    `add rax, 4` 将迭代器向前移动 4 个字节。然后，发生了一个稍微复杂一些的事情。
- en: '### [#](https://en.algorithmica.org/hpc/architecture/loops/#jumps)Jumps'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/architecture/loops/#jumps) 跳转'
- en: Assembly doesn’t have if-s, for-s, functions, or other control flow structures
    that high-level languages have. What it does have is `goto`, or “jump,” how it
    is known in the world of low-level programming.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言没有 if-s、for-s、函数或其他高级语言中的控制流结构。它所拥有的只是 `goto`，或者称为“跳转”，这是在低级编程领域中的叫法。
- en: '**Jump** moves the instruction pointer to a location specified by its operand.
    This location may be either an absolute address in memory, relative to the current
    address or even [computed during runtime](../indirect). To avoid the headache
    of managing these addresses directly, you can mark any instruction with a string
    followed by `:`, and then use this string as a label which gets replaced by the
    relative address of this instruction when converted to machine code.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**跳转**将指令指针移动到由其操作数指定的位置。这个位置可以是内存中的绝对地址，相对于当前地址，甚至可以在运行时[计算](../indirect)。为了避免直接管理这些地址的麻烦，你可以用字符串后跟
    `:` 标记任何指令，然后使用这个字符串作为标签，当转换为机器代码时，这个标签会被替换为该指令的相对地址。'
- en: Labels can be any string, but compilers don’t get creative and [typically](https://godbolt.org/z/T45x8GKa5)
    just use the line numbers in the source code and function names with their signatures
    when picking names for labels.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 标签可以是任何字符串，但编译器并不富有创意，[通常](https://godbolt.org/z/T45x8GKa5) 只使用源代码中的行号和带有签名的函数名来选择标签名称。
- en: '**Unconditional** jump `jmp` can only be used to implement `while (true)` kind
    of loops or stitch parts of a program together. A family of **conditional** jumps
    is used to implement actual control flow.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**无条件**跳转 `jmp` 只能用来实现 `while (true)` 类型的循环或将程序的一部分连接起来。一系列**条件**跳转用于实现实际的控制流。'
- en: 'It is reasonable to think that these conditions are computed as `bool`-s somewhere
    and passed to conditional jumps as operands: after all, this is how it works in
    programming languages. But that is not how it is implemented in hardware. Conditional
    operations use a special `FLAGS` register, which first needs to be populated by
    executing instructions that perform some kind of check.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有理由认为这些条件是在某处计算为 `bool` 类型的值，并将它们作为操作数传递给条件跳转：毕竟，这是在编程语言中是如何工作的。但在硬件中并不是这样实现的。条件操作使用一个特殊的
    `FLAGS` 寄存器，首先需要通过执行执行某些检查的指令来填充它。
- en: In our example, `cmp rax, rcx` compares the iterator `rax` with the end-of-array
    pointer `rcx`. This updates the `FLAGS` register, and now it can be used by `jne
    loop`, which looks up a certain bit there that tells whether the two values are
    equal or not, and then either jumps back to the beginning or continues to the
    next instruction, thus breaking the loop.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`cmp rax, rcx` 比较迭代器 `rax` 与数组结束指针 `rcx`。这会更新 `FLAGS` 寄存器，现在它可以由 `jne
    loop` 使用，它查找那里的一定位，以确定两个值是否相等，然后要么跳回到开始，要么继续到下一个指令，从而打破循环。
- en: '### [#](https://en.algorithmica.org/hpc/architecture/loops/#loop-unrolling)Loop
    Unrolling'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/architecture/loops/#loop-unrolling)
    循环展开'
- en: One thing you might have noticed about the loop above is that there is a lot
    of overhead to process a single element. During each cycle, there is only one
    useful instruction executed, and the other 3 are incrementing the iterator and
    trying to find out if we are done yet.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了上面的循环有一个很大的开销来处理单个元素。在每次循环中，只有一个有用的指令被执行，其他 3 个指令是在增加迭代器并尝试确定我们是否已经完成。
- en: 'What we can do is to *unroll* the loop by grouping iterations together — equivalent
    to writing something like this in C:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的就是对循环进行展开，将迭代分组在一起——相当于在 C 语言中编写如下内容：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In assembly, it would look something like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中，它看起来可能像这样：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we only need 3 loop control instructions for 4 useful ones (an improvement
    from $\frac{1}{4}$ to $\frac{4}{7}$ in terms of efficiency), and this can be continued
    to reduce the overhead almost to zero.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要3条循环控制指令来处理4个有用的指令（从效率的$\frac{1}{4}$提升到$\frac{4}{7}$），并且这可以继续减少开销，几乎接近于零。
- en: In practice, unrolling loops isn’t always necessary for performance because
    modern processors don’t actually execute instructions one-by-one, but maintain
    a [queue of pending instructions](/hpc/pipelining) so that two independent operations
    can be executed concurrently without waiting for each other to finish.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，展开循环并不总是对性能必要，因为现代处理器实际上并不是逐条执行指令，而是维护一个[待执行指令队列](/hpc/pipelining)，这样两个独立的操作就可以并发执行，无需等待对方完成。
- en: 'This is our case too: the real speedup from unrolling won’t be fourfold, because
    the operations of incrementing the counter and checking if we are done are independent
    from the loop body, and can be scheduled to run concurrently with it. But may
    still be beneficial to [ask the compiler](/hpc/compilation/situational) to unroll
    it to some extent.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是我们的情况：展开循环的实际加速不会是四倍，因为增加计数器和检查是否完成的操作与循环体是独立的，并且可以安排与它同时运行。但仍然可能有益于[请求编译器](/hpc/compilation/situational)在一定程度上展开它。
- en: '### [#](https://en.algorithmica.org/hpc/architecture/loops/#an-alternative-approach)An
    Alternative Approach'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/architecture/loops/#an-alternative-approach)另一种方法'
- en: You don’t have to explicitly use `cmp` or a similar instruction to make a conditional
    jump. Many other instructions either read or modify the `FLAGS` register, sometimes
    as a by-product enabling optional exception checks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必显式使用`cmp`或类似的指令来执行条件跳转。许多其他指令要么读取要么修改`FLAGS`寄存器，有时作为副产品启用可选的异常检查。
- en: 'For example, `add` always sets a number of flags, denoting whether the result
    is zero, is negative, whether an overflow or an underflow occurred, and so on.
    Taking advantage of this mechanism, compilers often produce loops like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`add`指令总是设置一系列标志，表示结果是否为零、是否为负、是否发生溢出或下溢等。利用这一机制，编译器通常会生成如下循环：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code is a bit harder to read for a human, but it is one instruction shorter
    in the repeated part, which may meaningfully affect performance. [← Assembly Language](https://en.algorithmica.org/hpc/architecture/assembly/)[Functions
    and Recursion →](https://en.algorithmica.org/hpc/architecture/functions/)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码对人类来说读起来有点困难，但在重复部分中指令数量少了一条，这可能会对性能产生有意义的影响。[← 汇编语言](https://en.algorithmica.org/hpc/architecture/assembly/)[函数和递归
    →](https://en.algorithmica.org/hpc/architecture/functions/)
