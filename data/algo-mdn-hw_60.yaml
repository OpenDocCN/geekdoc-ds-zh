- en: Pointer Alternatives
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针替代方案
- en: 原文：[https://en.algorithmica.org/hpc/cpu-cache/pointers/](https://en.algorithmica.org/hpc/cpu-cache/pointers/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/cpu-cache/pointers/](https://en.algorithmica.org/hpc/cpu-cache/pointers/)
- en: 'In the [pointer chasing benchmark](../latency), for simplicity, we didn’t use
    actual pointers, but integer indices relative to a base address:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[指针追逐基准测试](../latency)中，为了简单起见，我们没有使用实际的指针，而是使用相对于基址的整数索引：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[The memory addressing operator](/hpc/architecture/assembly#addressing-modes)
    on x86 is fused with the address computation, so the `k = q[k]` line folds into
    just a single terse instruction that also does multiplication by 4 and addition
    under the hood:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: x86上的[内存寻址运算符](/hpc/architecture/assembly#addressing-modes)与地址计算融合，所以`k = q[k]`这一行折叠成一条简洁的指令，该指令还暗中执行乘以4和加法操作：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Although fully fused, these additional computations add some delay to memory
    operations. The latency of an L1 fetch is either 4 or 5 cycles — the latter being
    the case if we need to perform a complex computation of the address. For this
    reason, the permutation benchmark measures 3ns or 6 cycles per jump: 4+1 for the
    read and address computation and another one to move the result to the right register.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然完全融合，但这些额外的计算会给内存操作增加一些延迟。L1缓存的读取延迟是4或5个周期——后者是我们需要执行地址的复杂计算时的情况。因此，排列基准测试测量每次跳跃3纳秒或6个周期：4+1用于读取和地址计算，另一个用于将结果移动到正确的寄存器。
- en: '### [#](https://en.algorithmica.org/hpc/cpu-cache/pointers/#pointers)Pointers'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/cpu-cache/pointers/#pointers)指针'
- en: We can make our benchmark run slightly faster if we replace “fake pointers”
    — indices — with actual pointers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用实际的指针替换“假指针”——索引，我们的基准测试可以稍微快一些。
- en: 'There are some syntactical issues in getting “pointer to pointer to pointer…”
    constructions to work, so instead we will define a struct that just wraps a pointers
    to its own type — this is how most pointer chasing works anyway:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在使“指针到指针到指针……”这样的结构正常工作方面存在一些语法问题，所以我们将定义一个结构体，它只是封装了指向其自身类型的指针——这正是大多数指针追逐的工作方式：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we randomly fill our array with pointers and chase them instead:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们随机填充我们的数组指针，然后追逐它们：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code now runs in 2ns / 4 cycles for arrays that fit in the L1 cache. Why
    not 4+1=5? Because Zen 2 [has an interesting feature](https://www.agner.org/forum/viewtopic.php?t=41)
    that allows zero-latency reuse of data accessed just by address, so the “move”
    here is transparent, resulting in whole two cycles saved.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码现在在适合L1缓存的数组上运行，每秒2纳秒/4个周期。为什么不是4+1=5？因为Zen 2 [有一个有趣的功能](https://www.agner.org/forum/viewtopic.php?t=41)，它允许通过地址访问的数据零延迟重用，所以这里的“移动”是透明的，从而节省了整个两个周期。
- en: 'Unfortunately, there is a problem with it on 64-bit systems as the pointers
    become twice as large, making the array spill out of cache much sooner compared
    to using a 32-bit index. The latency-versus-size graph looks like if it was shifted
    by one power of two to the left — exactly like it should:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在64位系统上存在一个问题，因为指针的大小加倍，使得数组比使用32位索引更早地溢出缓存。延迟与大小图看起来就像向左移动了一个二进制位——这正是它应该的样子：
- en: '![](../Images/056a930394d7fd4f3950099f1a65dbaf.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/056a930394d7fd4f3950099f1a65dbaf.png)'
- en: 'This problem is mitigated by switching to the 32-bit mode:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过切换到32位模式可以减轻这个问题：
- en: '![](../Images/e7771d2e8d9297605c558166e3f8a705.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e7771d2e8d9297605c558166e3f8a705.png)'
- en: You need to go [through some trouble](https://askubuntu.com/questions/91909/trouble-compiling-a-32-bit-binary-on-a-64-bit-machine)
    getting 32-bit libs to get this running on a computer made in this century, but
    this shouldn’t pose other problems unless you need to interoperate with 64-bit
    software or access more than 4G of RAM
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要费些周折才能获取32位库，以便在这台本世纪的计算机上运行，但这不应该引起其他问题，除非你需要与64位软件交互或访问超过4G的RAM
- en: '### [#](https://en.algorithmica.org/hpc/cpu-cache/pointers/#bit-fields)Bit
    Fields'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/cpu-cache/pointers/#bit-fields)位字段'
- en: 'The fact that on larger problem sizes the performance is bottlenecked by memory
    rather than CPU lets us try something even more strange: we can use less than
    4 bytes for storing indices. This can be done with [bit fields](../alignment#bit-fields):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在较大的问题规模上，性能瓶颈是内存而不是CPU，这让我们可以尝试一些更奇怪的事情：我们可以使用少于4个字节来存储索引。这可以通过[位字段](../alignment#bit-fields)来实现：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You don’t need to do anything else other than defining a structure for the
    bit field — the compiler handles the 3-byte integer all by itself:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义位字段的结构之外，你不需要做任何事情——编译器会自己处理3字节的整数：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code measures at 6.5ns for the L1 cache. There is some room for improvement
    as the default conversion procedure chosen by the compiler is suboptimal. We could
    manually load a 4-byte integer and truncate it ourselves (we also need to add
    one more element to the `q` array to ensure we own that extra one byte of memory):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码测量了L1缓存的6.5ns。由于编译器选择的默认转换过程不是最优的，因此还有改进的空间。我们可以手动加载一个4字节整数并自行截断它（我们还需要向`q`数组中添加一个额外的元素以确保我们拥有那额外的1个字节内存）：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It now runs in 4ns, and produces the following graph:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它运行在4ns，并生成以下图表：
- en: '![](../Images/d921de7b5200b975d35a4ba6e4b6053c.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d921de7b5200b975d35a4ba6e4b6053c.png)'
- en: If you zoom close enough ([the graph is an svg](../img/permutation-bf-custom.svg)),
    you’ll see that the pointers win on very small arrays, then starting from around
    the L2-L3 cache boundary our custom bit fields take over, and for very large arrays
    it doesn’t matter because we never hit cache anyway.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你足够接近地放大（[图表是一个svg](../img/permutation-bf-custom.svg)），你会看到在非常小的数组上指针获胜，然后从大约L2-L3缓存边界开始，我们的自定义位字段接管，对于非常大的数组来说，这并不重要，因为我们无论如何也不会命中缓存。
- en: This isn’t a kind of optimization that can give you a 5x improvement, but it’s
    still something to try when all the other resources are exhausted. [← Alignment
    and Packing](https://en.algorithmica.org/hpc/cpu-cache/alignment/)[Cache Associativity
    →](https://en.algorithmica.org/hpc/cpu-cache/associativity/)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一种能给你带来5倍改进的优化，但仍然是在所有其他资源耗尽时值得一试的方法。[← 对齐和打包](https://en.algorithmica.org/hpc/cpu-cache/alignment/)[缓存关联性
    →](https://en.algorithmica.org/hpc/cpu-cache/associativity/)
