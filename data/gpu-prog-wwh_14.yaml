- en: Preparing code for GPU porting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备代码以进行GPU移植
- en: 原文：[https://enccs.github.io/gpu-programming/11-gpu-porting/](https://enccs.github.io/gpu-programming/11-gpu-porting/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://enccs.github.io/gpu-programming/11-gpu-porting/](https://enccs.github.io/gpu-programming/11-gpu-porting/)
- en: '*[GPU programming: why, when and how?](../)* **   Preparing code for GPU porting'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*GPU编程：为什么、何时以及如何？](../)* **   准备代码以进行GPU移植'
- en: '[Edit on GitHub](https://github.com/ENCCS/gpu-programming/blob/main/content/11-gpu-porting.rst)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在GitHub上编辑](https://github.com/ENCCS/gpu-programming/blob/main/content/11-gpu-porting.rst)'
- en: '* * *'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Questions
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 问题
- en: What are the key steps involved in porting code to take advantage of GPU parallel
    processing capability?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别利用GPU并行处理能力的代码移植的关键步骤是什么？
- en: How can I identify the computationally intensive parts of my code that can benefit
    from GPU acceleration?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何识别代码中可以受益于GPU加速的计算密集部分？
- en: What are the considerations for refactoring loops to suit the GPU architecture
    and improve memory access patterns?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构循环以适应GPU架构并改进内存访问模式时需要考虑哪些因素？
- en: Are there any tools that can translate automatically between different frameworks?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有没有工具可以在不同的框架之间自动翻译？
- en: Objectives
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 目标
- en: Getting familiarized the steps involved in porting code to GPUs to take advantage
    of parallel processing capabilities.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉将代码移植到GPU以利用并行处理能力的步骤。
- en: Giving some idea about refactoring loops and modifying operations to suit the
    GPU architecture and improve memory access patterns.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一些关于重构循环和修改操作以适应GPU架构并改进内存访问模式的想法。
- en: Learn to use automatic translation tools to port from CUDA to HIP and from OpenACC
    to OpenMP
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用自动翻译工具将CUDA转换为HIP以及将OpenACC转换为OpenMP
- en: Instructor note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 讲师备注
- en: 30 min teaching
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 30分钟教学
- en: 20 min exercises
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 20分钟练习
- en: Porting from CPU to GPU
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从CPU到GPU的移植
- en: 'When porting code to take advantage of the parallel processing capability of
    GPUs, several steps need to be followed and some additional work is required before
    writing actual parallel code to be executed on the GPUs:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当将代码移植以利用GPU的并行处理能力时，需要遵循几个步骤，并在编写实际在GPU上执行的并行代码之前做一些额外的工作：
- en: '**Identify Targeted Parts**: Begin by identifying the parts of the code that
    contribute significantly to the execution time. These are often computationally
    intensive sections such as loops or matrix operations. The Pareto principle suggests
    that roughly 10-20% of the code accounts for 80-90% of the execution time.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**识别目标部分**：首先识别对执行时间贡献显著的代码部分。这些通常是计算密集的部分，如循环或矩阵运算。帕累托原则表明，大约10-20%的代码占用了80-90%的执行时间。'
- en: '**Equivalent GPU Libraries**: If the original code uses CPU libraries like
    BLAS, FFT, etc, it’s crucial to identify the equivalent GPU libraries. For example,
    cuBLAS or hipBLAS can replace CPU-based BLAS libraries. Utilizing GPU-specific
    libraries ensures efficient GPU utilization.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**等效GPU库**：如果原始代码使用CPU库如BLAS、FFT等，识别等效的GPU库至关重要。例如，cuBLAS或hipBLAS可以替换基于CPU的BLAS库。利用GPU特定的库确保高效的GPU利用。'
- en: '**Refactor Loops**: When porting loops directly to GPUs, some refactoring is
    necessary to suit the GPU architecture. This typically involves splitting the
    loop into multiple steps or modifying operations to exploit the independence between
    iterations and improve memory access patterns. Each step of the original loop
    can be mapped to a kernel, executed by multiple GPU threads, with each thread
    corresponding to an iteration.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构循环**：当直接将循环移植到GPU时，需要进行一些重构以适应GPU架构。这通常涉及将循环拆分为多个步骤或修改操作以利用迭代之间的独立性并改进内存访问模式。原始循环的每一步都可以映射到一个内核，由多个GPU线程执行，每个线程对应一个迭代。'
- en: '**Memory Access Optimization**: Consider the memory access patterns in the
    code. GPUs perform best when memory access is coalesced and aligned. Minimizing
    global memory accesses and maximizing utilization of shared memory or registers
    can significantly enhance performance. Review the code to ensure optimal memory
    access for GPU execution.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存访问优化**：考虑代码中的内存访问模式。当内存访问是归一化和对齐时，GPU表现最佳。最小化全局内存访问并最大化共享内存或寄存器的利用率可以显著提高性能。审查代码以确保GPU执行的最优内存访问。'
- en: Discussion
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 讨论
- en: How would this be ported? (n_soap ≈ 100, n_sites ⩾ 10000, k_max ≈ 20*n_sites
    )
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这将如何移植？（n_soap ≈ 100，n_sites ⩾ 10000，k_max ≈ 20*n_sites）
- en: ''
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Inspect the following Fortran code (if you don’t read Fortran: do-loops ==
    for-loops)'
  id: totrans-26
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查以下Fortran代码（如果你不读Fortran：do-loops == for-loops）
- en: ''
  id: totrans-27
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ''
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Some steps at first glance:'
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一些初步步骤：
- en: ''
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: the code could (has to) be splitted in 3-4 kernels. Why?
  id: totrans-32
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可能（必须）拆分为3-4个内核。为什么？
- en: ''
  id: totrans-33
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-34
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: check if there are any variables that could lead to false dependencies between
    iterations, like the index k2
  id: totrans-35
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查是否存在可能导致迭代之间产生虚假依赖的变量，例如索引k2
- en: ''
  id: totrans-36
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-37
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: is it efficient for GPUs to split the work over the index i? What about the
    memory access? Note the arrays are 2D in Fortran
  id: totrans-38
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于GPU来说，将工作分配到索引i是否高效？关于内存访问呢？注意Fortran中的数组是二维的。
- en: ''
  id: totrans-39
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-40
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: is it possible to collapse some loops? Combining nested loops can reduce overhead
    and improve memory access patterns, leading to better GPU performance.
  id: totrans-41
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否可以合并一些循环？合并嵌套循环可以减少开销并改善内存访问模式，从而提高GPU性能。
- en: ''
  id: totrans-42
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-43
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: what is the best memory access in a GPU? Review memory access patterns in the
    code. Minimize global memory access by utilizing shared memory or registers where
    appropriate. Ensure memory access is coalesced and aligned, maximizing GPU memory
    throughput
  id: totrans-44
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GPU中最佳的内存访问方式是什么？审查代码中的内存访问模式。通过在适当的地方使用共享内存或寄存器来最小化全局内存访问，确保内存访问是归约和齐的，以最大化GPU内存吞吐量。
- en: Refactored code!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重构完成！
- en: Registers are limited and the larger the kernel use more registers registers
    resulting in less active threads (small occupancy).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器数量有限，内核使用越多寄存器，导致活跃线程减少（占用率低）。
- en: In order to compute soap_rad_der(is,k2) the CUDA thread needs access to all
    the previous values soap_rad_der(1:nsoap,k2).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了计算soap_rad_der(is,k2)，CUDA线程需要访问所有之前的值soap_rad_der(1:nsoap,k2)。
- en: In order to compute soap_cart_der(1, 1:n_soap, k3) it is required to have access
    to all values (k3+1:k2+n_neigh(i)).
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了计算soap_cart_der(1, 1:n_soap, k3)，需要访问所有值(k3+1:k2+n_neigh(i))。
- en: Note the indices in the first part. The matrices are transposed for better access
    patterns.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意第一部分的索引。矩阵被转置以获得更好的访问模式。
- en: '[PRE1]'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Keypoints
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 重点
- en: Identify equivalent GPU libraries for CPU-based libraries and utilizing them
    to ensure efficient GPU utilization.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定与基于CPU的库等效的GPU库，并利用它们以确保高效的GPU利用率。
- en: Importance of identifying the computationally intensive parts of the code that
    contribute significantly to the execution time.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别代码中计算密集部分的重要性，这些部分对执行时间有显著贡献。
- en: The need to refactor loops to suit the GPU architecture.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要重构循环以适应GPU架构。
- en: Significance of memory access optimization for efficient GPU execution, including
    coalesced and aligned memory access patterns.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存访问优化对高效GPU执行的重要性，包括归约和齐内存访问模式。
- en: Porting between different GPU frameworks
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同GPU框架之间的移植
- en: You might also find yourself in a situation where you need to port a code from
    one particular GPU framework to another. This section gives an overview of different
    tools that enable converting CUDA and OpenACC codes to HIP and OpenMP, respectively.
    This conversion process enables an application to target various GPU architectures,
    specifically, NVIDIA and AMD GPUs. Here we focus on [hipify](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html)
    and [clacc](https://csmd.ornl.gov/project/clacc) tools. This guide is adapted
    from the [NRIS documentation](https://documentation.sigma2.no/code_development/guides/cuda_translating-tools.html).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会遇到需要将代码从一个特定的GPU框架移植到另一个框架的情况。本节概述了不同的工具，这些工具可以将CUDA和OpenACC代码分别转换为HIP和OpenMP。此转换过程使应用程序能够针对各种GPU架构进行优化，特别是NVIDIA和AMD
    GPU。在此，我们关注[hipify](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html)和[clacc](https://csmd.ornl.gov/project/clacc)工具。本指南改编自[NRIS文档](https://documentation.sigma2.no/code_development/guides/cuda_translating-tools.html)。
- en: Translating CUDA to HIP with Hipify
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Hipify将CUDA转换为HIP
- en: In this section, we cover the use of `hipify-perl` and `hipify-clang` tools
    to translate a CUDA code to HIP.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了使用`hipify-perl`和`hipify-clang`工具将CUDA代码翻译为HIP的方法。
- en: Hipify-perl
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Hipify-perl
- en: The `hipify-perl` tool is a script based on perl that translates CUDA syntax
    into HIP syntax (see .e.g. [here](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl)
    for more details). For instance, in a CUDA code that incorporates the CUDA functions
    `` cudaMalloc` `` and `cudaDeviceSynchronize`, the tool will substitute `cudaMalloc`
    with the HIP function `hipMalloc`. Similarly the CUDA function `cudaDeviceSynchronize`
    will be substituted with the HIP function `hipDeviceSynchronize`. We list below
    the basic steps to run `hipify-perl` on LUMI-G.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`hipify-perl` 工具是一个基于 perl 的脚本，它将 CUDA 语法转换为 HIP 语法（例如，有关更多详细信息，请参阅[此处](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl)）。例如，在一个包含
    CUDA 函数 `cudaMalloc` 和 `cudaDeviceSynchronize` 的 CUDA 代码中，该工具会将 `cudaMalloc` 替换为
    HIP 函数 `hipMalloc`。同样，CUDA 函数 `cudaDeviceSynchronize` 也会被替换为 HIP 函数 `hipDeviceSynchronize`。以下是在
    LUMI-G 上运行 `hipify-perl` 的基本步骤。'
- en: '**Step 1**: Generating `hipify-perl` script'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 1**：生成 `hipify-perl` 脚本'
- en: '[PRE2]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Step 2**: Running the generated `hipify-perl`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 2**：运行生成的 `hipify-perl`'
- en: '[PRE3]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Step 3**: Compiling with `hipcc` the generated HIP code'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 3**：使用 `hipcc` 编译生成的 HIP 代码'
- en: '[PRE4]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Despite the simplicity of the use of `hipify-perl`, the tool might not be suitable
    for large applications, as it relies heavily on substituting CUDA strings with
    HIP strings (e.g. it substitutes `*cuda*` with `*hip*`). In addition, `hipify-perl`
    lacks the ability of [distinguishing device/host function calls](https://docs.amd.com/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl).
    The alternative here is to use the `hipify-clang` tool as will be described in
    the next section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用 `hipify-perl` 的操作很简单，但该工具可能不适合大型应用程序，因为它严重依赖于将 CUDA 字符串替换为 HIP 字符串（例如，它将
    `*cuda*` 替换为 `*hip*`）。此外，`hipify-perl` 缺乏区分设备/主机函数调用的能力。[区分设备/主机函数调用](https://docs.amd.com/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl)
    的替代方案是使用下一节将要描述的 `hipify-clang` 工具。
- en: Hipify-clang
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Hipify-clang
- en: As described in the [HIPIFY documentation](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl),
    the `hipify-clang` tool is based on clang for translating CUDA sources into HIP
    sources. The tool is more robust for translating CUDA codes compared to the `hipify-perl`
    tool. Furthermore, it facilitates the analysis of the code by providing assistance.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [HIPIFY 文档](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl)
    所述，`hipify-clang` 工具基于 clang，用于将 CUDA 源代码转换为 HIP 源代码。与 `hipify-perl` 工具相比，该工具在转换
    CUDA 代码方面更为稳健。此外，它通过提供辅助功能来促进代码分析。
- en: 'In short, `hipify-clang` requires `LLVM+CLANG` and `CUDA`. Details about building
    `hipify-clang` can be found [here](https://github.com/ROCm/HIPIFY). Note that
    `hipify-clang` is available on LUMI-G. The issue however might be related to the
    installation of CUDA-toolkit. To avoid any eventual issues with the installation
    procedure we opt for CUDA singularity container. Here we present a step-by-step
    guide for running `hipify-clang`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`hipify-clang` 需要 `LLVM+CLANG` 和 `CUDA`。有关构建 `hipify-clang` 的详细信息，请参阅[此处](https://github.com/ROCm/HIPIFY)。请注意，`hipify-clang`
    在 LUMI-G 上可用。然而，问题可能与 CUDA-toolkit 的安装有关。为了避免安装过程中的任何潜在问题，我们选择使用 CUDA singularity
    容器。在此，我们提供了一个逐步指南，用于运行 `hipify-clang`：
- en: '**Step 1**: Pulling a CUDA singularity container e.g.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 1**：拉取 CUDA singularity 容器，例如'
- en: '[PRE5]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Step 2**: Loading a rocm module and launching the CUDA singularity'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 2**：加载 rocm 模块并启动 CUDA singularity'
- en: '[PRE6]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: where the current directory `$PWD` in the host is mounted to that of the container,
    and the directory `/opt` in the host is mounted to the that inside the container.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中，主机当前目录 `$PWD` 被挂载到容器中的相应目录，主机中的 `/opt` 目录被挂载到容器内的相应目录。
- en: '**Step 3**: Setting the environment variable `$PATH`. In order to run `hipify-clang`
    from inside the container, one can set the environment variable `$PATH` that defines
    the path to look for the binary `hipify-clang`.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 3**：设置环境变量 `$PATH`。为了在容器内运行 `hipify-clang`，可以设置环境变量 `$PATH`，该变量定义了查找二进制文件
    `hipify-clang` 的路径。'
- en: '[PRE7]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the rocm version we used is `rocm-6.0.3`.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们使用的 rocm 版本是 `rocm-6.0.3`。
- en: '**Step 4**: Running `hipify-clang` from inside the singularity container'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 4**：在 singularity 容器内运行 `hipify-clang`'
- en: '[PRE8]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here the cuda path and the path to the `*includes*` and `*defines*` files should
    be specified. The CUDA source code and the generated output code are program.cu
    and hip_program.cu.hip, respectively.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此处，应指定 cuda 路径以及 `*includes*` 和 `*defines*` 文件的路经。CUDA 源代码和生成的输出代码分别是 program.cu
    和 hip_program.cu.hip。
- en: The syntax for the compilation process of the generated hip code is similar
    to the one described in the previous section (see the **Step 3** in the hipify-perl
    section).
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成的 hip 代码的编译过程语法与上一节中描述的类似（参见 hipify-perl 部分的 **步骤 3**）。
- en: 'Code examples for the `Hipify` exercises can be accessed in the content/examples/exercise_hipify
    subdirectory by cloning this repository:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过克隆此仓库来访问 `Hipify` 练习的代码示例，该示例位于 `content/examples/exercise_hipify` 子目录中：
- en: '[PRE9]'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Exercise I : Translate an CUDA code to HIP with `hipify-perl`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 I：使用 `hipify-perl` 将 CUDA 代码翻译为 HIP
- en: 1.1 Generate the `hipify-perl` tool.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1 生成 `hipify-perl` 工具。
- en: 1.2 Convert the CUDA code `vec_add_cuda.cu` located in `/exercise_hipify/Hipify_perl`
    with the `Hipify-perl` tool to HIP.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2 使用 `Hipify-perl` 工具将位于 `/exercise_hipify/Hipify_perl` 的 `vec_add_cuda.cu`
    CUDA 代码转换为 HIP。
- en: 1.3 Compile the generated HIP code with the `hipcc` compiler wrapper and run
    it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3 使用 `hipcc` 编译器包装器编译生成的 HIP 代码并运行它。
- en: 'Exercise II : Translate an CUDA code to HIP with `hipify-clang`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 II：使用 `hipify-clang` 将 CUDA 代码翻译为 HIP
- en: 2.1 Convert the CUDA code `vec_add_cuda.cu` located in `/exercise_hipify/Hipify_clang`
    with the `Hipify-clang` tool to HIP.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 2.1 使用 `Hipify-clang` 工具将位于 `/exercise_hipify/Hipify_clang` 的 `vec_add_cuda.cu`
    CUDA 代码转换为 HIP。
- en: 2.2 Compile the generated HIP code with the `hipcc` compiler wrapper and run
    it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 2.2 使用 `hipcc` 编译器包装器编译生成的 HIP 代码并运行它。
- en: Translating OpenACC to OpenMP with Clacc
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Clacc 将 OpenACC 转换为 OpenMP
- en: '[Clacc](https://github.com/llvm-doe-org/llvm-project/tree/clacc/main) is a
    tool to translate an OpenACC application to OpenMP offloading with the Clang/LLVM
    compiler environment. Note that the tool is specific to OpenACC C, while OpenACC
    Fortran is already supported on AMD GPU. As indicated in the [GitHub repository](https://github.com/llvm-doe-org/llvm-project/tree/clacc/main)
    the compiler `Clacc` is the `Clang`’s executable in the subdirectory `\bin` of
    the `\install` directory as described below.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[Clacc](https://github.com/llvm-doe-org/llvm-project/tree/clacc/main) 是一个工具，可以将
    OpenACC 应用程序转换为使用 Clang/LLVM 编译器环境的 OpenMP 转发。请注意，该工具特定于 OpenACC C，而 OpenACC Fortran
    已在 AMD GPU 上得到支持。如 [GitHub 仓库](https://github.com/llvm-doe-org/llvm-project/tree/clacc/main)
    中所示，编译器 `Clacc` 是位于 `\install` 目录 `\bin` 子目录中的 `Clang` 可执行文件，如下所述。'
- en: 'In the following we present a step-by-step guide for building and using Clacc:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下内容中，我们提供了一个逐步指南，用于构建和使用 Clacc：
- en: '**Step 1**: Building and installing [Clacc](https://github.com/llvm-doe-org/llvm-project/tree/clacc/main).'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 1**：构建和安装 [Clacc](https://github.com/llvm-doe-org/llvm-project/tree/clacc/main)。'
- en: '[PRE10]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Step 2**: Setting up environment variables to be able to work from the `/install`
    directory, which is the simplest way. We assume that the `/install` directory
    is located in the path `/project/project_xxxxxx/Clacc/llvm-project`.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 2**：设置环境变量，以便能够从 `/install` 目录工作，这是最简单的方法。我们假设 `/install` 目录位于路径 `/project/project_xxxxxx/Clacc/llvm-project`。'
- en: For more advanced usage, which includes for instance modifying `Clacc`, we refer
    readers to [“Usage from Build directory”](https://github.com/llvm-doe-org/llvm-project/blob/clacc/main/README.md)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高级的使用，例如修改 `Clacc`，我们建议读者参考 [“从构建目录使用”](https://github.com/llvm-doe-org/llvm-project/blob/clacc/main/README.md)。
- en: '[PRE11]'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Step 3**: Source to source conversion of the openACC_code.c code to be printed
    out to the file openMP_code.c:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 3**：将 openACC_code.c 代码从源代码转换为要打印到文件 openMP_code.c 的代码：'
- en: '[PRE12]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here the flag `-fopenacc-structured-ref-count-omp=no-ompx-hold` is introduced
    to disable the `ompx_hold` map type modifier, which is used by the OpenACC `copy`
    clause translation. The `ompx_hold` is an OpenMP extension that might not be supported
    yet by other compilers.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里引入了标志 `-fopenacc-structured-ref-count-omp=no-ompx-hold` 来禁用 `ompx_hold` 映射类型修饰符，该修饰符用于
    OpenACC `copy` 子句的翻译。`ompx_hold` 是一个 OpenMP 扩展，可能尚未被其他编译器支持。
- en: '**Step 4** Compiling the code with the [cc compiler wrapper](https://docs.lumi-supercomputer.eu/development/compiling/prgenv/)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 4** 使用 [cc 编译器包装器](https://docs.lumi-supercomputer.eu/development/compiling/prgenv/)
    编译代码'
- en: '[PRE13]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Access exercise material
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 访问练习材料
- en: 'Code examples for the `Clacc` exercise can be accessed in the content/examples/exercise_clacc
    subdirectory by cloning this repository:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过克隆此仓库来访问 `Clacc` 练习的代码示例，该示例位于 `content/examples/exercise_clacc` 子目录中：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Exercise : Translate an OpenACC code to OpenMP'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：将 OpenACC 代码转换为 OpenMP
- en: Convert the OpenACC code `openACC_code.c` located in `/exercise_clacc` with
    the `Clacc` compiler.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Clacc` 编译器将位于 `/exercise_clacc` 的 `openACC_code.c` 代码转换为 OpenACC 代码。
- en: Compile the generated OpenMP code with the `cc` compiler wrapper and run it.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cc` 编译器包装器编译生成的 OpenMP 代码并运行它。
- en: Translating CUDA to SYCL/DPC++ with SYCLomatic
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 SYCLomatic 将 CUDA 转换为 SYCL/DPC++
- en: Intel offers a tool for CUDA-to-SYCL code migration, included in the Intel oneAPI
    Basekit.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔提供了一种CUDA到SYCL代码迁移的工具，包含在Intel oneAPI Basekit中。
- en: 'It is not installed on LUMI, but the general workflow is similar to the HIPify
    Clang and also requires an existing CUDA installation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有安装在LUMI上，但一般工作流程与HIPify Clang类似，也要求现有的CUDA安装：
- en: '[PRE15]'
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE15]'
- en: SYCLomatic can migrate larger projects by using `-in-root` and `-out-root` flags
    to process directories recursively. It can also use compilation database (supported
    by CMake and other build systems) to deal with more complex project layouts.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: SYCLomatic可以通过使用`-in-root`和`-out-root`标志递归地处理目录来迁移较大的项目。它还可以使用编译数据库（由CMake和其他构建系统支持）来处理更复杂的项目布局。
- en: Please note that the code generated by SYCLomatic relies on oneAPI-specific
    extensions, and thus cannot be directly used with other SYCL implementations,
    such as AdaptiveCpp (hipSYCL). The `--no-incremental-migration` flag can be added
    to `dpct` command to minimize, but not completely avoid, the use of this compatibility
    layer. That would require manual effort, since some CUDA concepts cannot be directly
    mapped to SYCL.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由SYCLomatic生成的代码依赖于oneAPI特定的扩展，因此不能直接与其他SYCL实现（如AdaptiveCpp（hipSYCL））一起使用。可以通过将`--no-incremental-migration`标志添加到`dpct`命令中来最小化，但无法完全避免使用此兼容层。这需要手动操作，因为某些CUDA概念不能直接映射到SYCL。
- en: Additionally, CUDA applications might assume certain hardware behavior, such
    as 32-wide warps. If the target hardware is different (e.g., AMD MI250 GPUs, used
    in LUMI, have warp size of 64), the algorithms might need to be adjusted manually.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，CUDA应用程序可能假设某些硬件行为，例如32宽的warp。如果目标硬件不同（例如，LUMI中使用的AMD MI250 GPU具有64个warp大小），则算法可能需要手动调整。
- en: Conclusion
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: This concludes a brief overview of the usage of available tools to convert CUDA
    codes to HIP and SYCL, and OpenACC codes to OpenMP offloading. In general the
    translation process for large applications might be incomplete and thus requires
    manual modification to complete the porting process. It is however worth noting
    that the accuracy of the translation process requires that applications are written
    correctly according to the CUDA and OpenACC syntaxes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这简要概述了使用现有工具将CUDA代码转换为HIP和SYCL，以及将OpenACC代码转换为OpenMP卸载的用法。一般来说，大型应用程序的翻译过程可能不完整，因此需要手动修改以完成移植过程。然而，值得注意的是，翻译过程的准确性要求应用程序根据CUDA和OpenACC语法正确编写。
- en: See also
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考阅读
- en: '[Hipify GitHub](https://github.com/ROCm/HIPIFY)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Hipify GitHub](https://github.com/ROCm/HIPIFY)'
- en: '[HIPify Reference Guide v5.1](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[HIPify参考指南v5.1](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html)'
- en: '[HIP example](https://github.com/olcf-tutorials/simple_HIP_examples/tree/master/vector_addition)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[HIP示例](https://github.com/olcf-tutorials/simple_HIP_examples/tree/master/vector_addition)'
- en: '[Porting CUDA to HIP](https://www.admin-magazine.com/HPC/Articles/Porting-CUDA-to-HIP)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将CUDA移植到HIP](https://www.admin-magazine.com/HPC/Articles/Porting-CUDA-to-HIP)'
- en: '[Clacc Main repository README](https://github.com/llvm-doe-org/llvm-project/blob/clacc/main/README.md)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Clacc主仓库README](https://github.com/llvm-doe-org/llvm-project/blob/clacc/main/README.md)'
- en: '[SYCLomatic main mage](https://www.intel.com/content/www/us/en/developer/articles/technical/syclomatic-new-cuda-to-sycl-code-migration-tool.html)'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SYCLomatic主页面](https://www.intel.com/content/www/us/en/developer/articles/technical/syclomatic-new-cuda-to-sycl-code-migration-tool.html)'
- en: '[SYCLomatic documentation](https://oneapi-src.github.io/SYCLomatic/get_started/index.html)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SYCLomatic文档](https://oneapi-src.github.io/SYCLomatic/get_started/index.html)'
- en: Keypoints
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 重点
- en: Useful tools exist to automatically translate tools from CUDA to HIP and SYCL
    and from OpenACC to OpenMP, but they may require manual modifications. [Previous](../10-multiple_gpu/
    "Multiple GPU programming with MPI") [Next](../12-recommendations/ "Recommendations")
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在着一些有用的工具，可以自动将工具从CUDA转换为HIP和SYCL，以及从OpenACC转换为OpenMP，但它们可能需要手动修改。[上一页](../10-multiple_gpu/
    "使用MPI的多GPU编程") [下一页](../12-recommendations/ "推荐")
- en: '* * *'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: © Copyright 2023-2024, The contributors.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: © 版权所有 2023-2024，贡献者。
- en: Built with [Sphinx](https://www.sphinx-doc.org/) using a [theme](https://github.com/readthedocs/sphinx_rtd_theme)
    provided by [Read the Docs](https://readthedocs.org). Questions
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[Sphinx](https://www.sphinx-doc.org/)和由[Read the Docs](https://readthedocs.org)提供的[主题](https://github.com/readthedocs/sphinx_rtd_theme)构建。问题
- en: What are the key steps involved in porting code to take advantage of GPU parallel
    processing capability?
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码移植以利用GPU并行处理能力的关键步骤有哪些？
- en: How can I identify the computationally intensive parts of my code that can benefit
    from GPU acceleration?
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何识别代码中可以受益于 GPU 加速的计算密集型部分？
- en: What are the considerations for refactoring loops to suit the GPU architecture
    and improve memory access patterns?
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构循环以适应 GPU 架构并改进内存访问模式时需要考虑哪些因素？
- en: Are there any tools that can translate automatically between different frameworks?
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有没有工具可以自动在不同框架之间进行翻译？
- en: Objectives
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 目标
- en: Getting familiarized the steps involved in porting code to GPUs to take advantage
    of parallel processing capabilities.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉将代码移植到 GPU 以利用并行处理能力的步骤。
- en: Giving some idea about refactoring loops and modifying operations to suit the
    GPU architecture and improve memory access patterns.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一些关于重构循环和修改操作以适应 GPU 架构并改进内存访问模式的想法。
- en: Learn to use automatic translation tools to port from CUDA to HIP and from OpenACC
    to OpenMP
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用自动翻译工具将 CUDA 移植到 HIP 以及将 OpenACC 移植到 OpenMP
- en: Instructor note
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 教师备注
- en: 30 min teaching
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 30 分钟教学
- en: 20 min exercises
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 20 分钟练习
- en: Porting from CPU to GPU
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 CPU 移植到 GPU
- en: 'When porting code to take advantage of the parallel processing capability of
    GPUs, several steps need to be followed and some additional work is required before
    writing actual parallel code to be executed on the GPUs:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在将代码移植以利用 GPU 的并行处理能力时，需要遵循几个步骤，并在实际编写要在 GPU 上执行的并行代码之前做一些额外的工作：
- en: '**Identify Targeted Parts**: Begin by identifying the parts of the code that
    contribute significantly to the execution time. These are often computationally
    intensive sections such as loops or matrix operations. The Pareto principle suggests
    that roughly 10-20% of the code accounts for 80-90% of the execution time.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**识别目标部分**：首先识别对执行时间贡献显著的代码部分。这些通常是计算密集型部分，如循环或矩阵运算。帕累托原则表明，大约 10-20% 的代码占用了
    80-90% 的执行时间。'
- en: '**Equivalent GPU Libraries**: If the original code uses CPU libraries like
    BLAS, FFT, etc, it’s crucial to identify the equivalent GPU libraries. For example,
    cuBLAS or hipBLAS can replace CPU-based BLAS libraries. Utilizing GPU-specific
    libraries ensures efficient GPU utilization.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**等效 GPU 库**：如果原始代码使用 CPU 库如 BLAS、FFT 等，识别等效的 GPU 库至关重要。例如，cuBLAS 或 hipBLAS
    可以替换基于 CPU 的 BLAS 库。利用 GPU 特定的库可以确保高效的 GPU 利用。'
- en: '**Refactor Loops**: When porting loops directly to GPUs, some refactoring is
    necessary to suit the GPU architecture. This typically involves splitting the
    loop into multiple steps or modifying operations to exploit the independence between
    iterations and improve memory access patterns. Each step of the original loop
    can be mapped to a kernel, executed by multiple GPU threads, with each thread
    corresponding to an iteration.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构循环**：在直接将循环移植到 GPU 时，需要进行一些重构以适应 GPU 架构。这通常涉及将循环拆分成多个步骤或修改操作以利用迭代之间的独立性并改进内存访问模式。原始循环的每个步骤都可以映射到一个内核，由多个
    GPU 线程执行，每个线程对应一个迭代。'
- en: '**Memory Access Optimization**: Consider the memory access patterns in the
    code. GPUs perform best when memory access is coalesced and aligned. Minimizing
    global memory accesses and maximizing utilization of shared memory or registers
    can significantly enhance performance. Review the code to ensure optimal memory
    access for GPU execution.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存访问优化**：考虑代码中的内存访问模式。GPU 在内存访问合并和对齐时表现最佳。最小化全局内存访问并最大化共享内存或寄存器的利用率可以显著提高性能。审查代码以确保
    GPU 执行的内存访问最优。'
- en: Discussion
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 讨论
- en: How would this be ported? (n_soap ≈ 100, n_sites ⩾ 10000, k_max ≈ 20*n_sites
    )
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这将如何移植？（n_soap ≈ 100，n_sites ⩾ 10000，k_max ≈ 20*n_sites）
- en: ''
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Inspect the following Fortran code (if you don’t read Fortran: do-loops ==
    for-loops)'
  id: totrans-154
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查以下 Fortran 代码（如果你不读 Fortran：do-loops == for-loops）
- en: ''
  id: totrans-155
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-156
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ''
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Some steps at first glance:'
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一些初步步骤：
- en: ''
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: the code could (has to) be splitted in 3-4 kernels. Why?
  id: totrans-160
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可以（必须）分成 3-4 个内核。为什么？
- en: ''
  id: totrans-161
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-162
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: check if there are any variables that could lead to false dependencies between
    iterations, like the index k2
  id: totrans-163
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查是否存在可能导致迭代之间产生虚假依赖的变量，如索引 k2
- en: ''
  id: totrans-164
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-165
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: is it efficient for GPUs to split the work over the index i? What about the
    memory access? Note the arrays are 2D in Fortran
  id: totrans-166
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 GPU 来说，将工作分配到索引 i 上是否高效？关于内存访问呢？注意 Fortran 中的数组是二维的。
- en: ''
  id: totrans-167
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-168
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: is it possible to collapse some loops? Combining nested loops can reduce overhead
    and improve memory access patterns, leading to better GPU performance.
  id: totrans-169
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否可以合并一些循环？合并嵌套循环可以减少开销并改进内存访问模式，从而提高 GPU 性能。
- en: ''
  id: totrans-170
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-171
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: what is the best memory access in a GPU? Review memory access patterns in the
    code. Minimize global memory access by utilizing shared memory or registers where
    appropriate. Ensure memory access is coalesced and aligned, maximizing GPU memory
    throughput
  id: totrans-172
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GPU中最佳的内存访问方式是什么？审查代码中的内存访问模式。通过在适当的地方使用共享内存或寄存器来最小化全局内存访问。确保内存访问是归一化和对齐的，以最大化GPU内存吞吐量
- en: Refactored code!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 重构后的代码！
- en: Registers are limited and the larger the kernel use more registers registers
    resulting in less active threads (small occupancy).
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器数量有限，内核使用越多寄存器，就会导致更少的活跃线程（低占用率）。
- en: In order to compute soap_rad_der(is,k2) the CUDA thread needs access to all
    the previous values soap_rad_der(1:nsoap,k2).
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了计算`soap_rad_der(is,k2)`，CUDA线程需要访问所有之前计算的值`soap_rad_der(1:nsoap,k2)`。
- en: In order to compute soap_cart_der(1, 1:n_soap, k3) it is required to have access
    to all values (k3+1:k2+n_neigh(i)).
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了计算`soap_cart_der(1, 1:n_soap, k3)`，需要访问所有值（`k3+1:k2+n_neigh(i)`）。
- en: Note the indices in the first part. The matrices are transposed for better access
    patterns.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意第一部分中的索引。矩阵被转置以获得更好的访问模式。
- en: '[PRE17]'
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Keypoints
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点
- en: Identify equivalent GPU libraries for CPU-based libraries and utilizing them
    to ensure efficient GPU utilization.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别与基于CPU的库等效的GPU库，并利用它们以确保高效的GPU利用。
- en: Importance of identifying the computationally intensive parts of the code that
    contribute significantly to the execution time.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别代码中计算密集部分的重要性，这些部分对执行时间有显著贡献。
- en: The need to refactor loops to suit the GPU architecture.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要重构循环以适应GPU架构。
- en: Significance of memory access optimization for efficient GPU execution, including
    coalesced and aligned memory access patterns.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存访问优化对高效GPU执行的重要性，包括归一化和对齐的内存访问模式。
- en: Porting between different GPU frameworks
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在不同的GPU框架之间移植
- en: You might also find yourself in a situation where you need to port a code from
    one particular GPU framework to another. This section gives an overview of different
    tools that enable converting CUDA and OpenACC codes to HIP and OpenMP, respectively.
    This conversion process enables an application to target various GPU architectures,
    specifically, NVIDIA and AMD GPUs. Here we focus on [hipify](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html)
    and [clacc](https://csmd.ornl.gov/project/clacc) tools. This guide is adapted
    from the [NRIS documentation](https://documentation.sigma2.no/code_development/guides/cuda_translating-tools.html).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也会遇到需要将代码从一个特定的GPU框架移植到另一个框架的情况。本节概述了不同的工具，这些工具可以将CUDA和OpenACC代码分别转换为HIP和OpenMP。此转换过程使应用程序能够针对不同的GPU架构进行优化，特别是NVIDIA和AMD
    GPU。在此，我们重点关注[hipify](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html)和[clacc](https://csmd.ornl.gov/project/clacc)工具。本指南改编自[NRIS文档](https://documentation.sigma2.no/code_development/guides/cuda_translating-tools.html)。
- en: Translating CUDA to HIP with Hipify
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Hipify将CUDA转换为HIP
- en: In this section, we cover the use of `hipify-perl` and `hipify-clang` tools
    to translate a CUDA code to HIP.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍使用`hipify-perl`和`hipify-clang`工具将CUDA代码转换为HIP。
- en: Hipify-perl
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Hipify-perl
- en: The `hipify-perl` tool is a script based on perl that translates CUDA syntax
    into HIP syntax (see .e.g. [here](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl)
    for more details). For instance, in a CUDA code that incorporates the CUDA functions
    `` cudaMalloc` `` and `cudaDeviceSynchronize`, the tool will substitute `cudaMalloc`
    with the HIP function `hipMalloc`. Similarly the CUDA function `cudaDeviceSynchronize`
    will be substituted with the HIP function `hipDeviceSynchronize`. We list below
    the basic steps to run `hipify-perl` on LUMI-G.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`hipify-perl`工具是基于perl的脚本，它将CUDA语法转换为HIP语法（例如，请参阅[此处](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl)以获取更多详细信息）。例如，在一个包含CUDA函数`cudaMalloc`和`cudaDeviceSynchronize`的CUDA代码中，该工具将`cudaMalloc`替换为HIP函数`hipMalloc`。同样，CUDA函数`cudaDeviceSynchronize`将被替换为HIP函数`hipDeviceSynchronize`。以下是在LUMI-G上运行`hipify-perl`的基本步骤。'
- en: '**Step 1**: Generating `hipify-perl` script'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤1**：生成`hipify-perl`脚本'
- en: '[PRE18]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Step 2**: Running the generated `hipify-perl`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤2**：运行生成的`hipify-perl`'
- en: '[PRE19]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Step 3**: Compiling with `hipcc` the generated HIP code'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤3**：使用`hipcc`编译生成的HIP代码'
- en: '[PRE20]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Despite the simplicity of the use of `hipify-perl`, the tool might not be suitable
    for large applications, as it relies heavily on substituting CUDA strings with
    HIP strings (e.g. it substitutes `*cuda*` with `*hip*`). In addition, `hipify-perl`
    lacks the ability of [distinguishing device/host function calls](https://docs.amd.com/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl).
    The alternative here is to use the `hipify-clang` tool as will be described in
    the next section.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用`hipify-perl`很简单，但该工具可能不适合大型应用程序，因为它严重依赖于用HIP字符串替换CUDA字符串（例如，它将`*cuda*`替换为`*hip*`）。此外，`hipify-perl`缺乏[区分设备/主机函数调用](https://docs.amd.com/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl)的能力。这里的替代方案是使用下一节将要描述的`hipify-clang`工具。
- en: Hipify-clang
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Hipify-clang
- en: As described in the [HIPIFY documentation](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl),
    the `hipify-clang` tool is based on clang for translating CUDA sources into HIP
    sources. The tool is more robust for translating CUDA codes compared to the `hipify-perl`
    tool. Furthermore, it facilitates the analysis of the code by providing assistance.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如[HIPIFY文档](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl)所述，`hipify-clang`工具基于clang，用于将CUDA源代码转换为HIP源代码。与`hipify-perl`工具相比，该工具在转换CUDA代码方面更为健壮。此外，它通过提供辅助功能来促进代码的分析。
- en: 'In short, `hipify-clang` requires `LLVM+CLANG` and `CUDA`. Details about building
    `hipify-clang` can be found [here](https://github.com/ROCm/HIPIFY). Note that
    `hipify-clang` is available on LUMI-G. The issue however might be related to the
    installation of CUDA-toolkit. To avoid any eventual issues with the installation
    procedure we opt for CUDA singularity container. Here we present a step-by-step
    guide for running `hipify-clang`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`hipify-clang`需要`LLVM+CLANG`和`CUDA`。有关构建`hipify-clang`的详细信息，请参阅[此处](https://github.com/ROCm/HIPIFY)。请注意，`hipify-clang`在LUMI-G上可用。然而，问题可能与管理CUDA-toolkit的安装有关。为了避免安装过程中的任何潜在问题，我们选择使用CUDA
    singularity容器。在此，我们提供了一个逐步指南，用于运行`hipify-clang`：
- en: '**Step 1**: Pulling a CUDA singularity container e.g.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤1**：拉取CUDA singularity容器，例如。'
- en: '[PRE21]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Step 2**: Loading a rocm module and launching the CUDA singularity'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤2**：加载rocm模块并启动CUDA singularity'
- en: '[PRE22]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: where the current directory `$PWD` in the host is mounted to that of the container,
    and the directory `/opt` in the host is mounted to the that inside the container.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中，主机当前目录`$PWD`挂载到容器中的相应目录，主机中的`/opt`目录挂载到容器内部的相应目录。
- en: '**Step 3**: Setting the environment variable `$PATH`. In order to run `hipify-clang`
    from inside the container, one can set the environment variable `$PATH` that defines
    the path to look for the binary `hipify-clang`.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤3**：设置环境变量`$PATH`。为了在容器内部运行`hipify-clang`，可以设置环境变量`$PATH`，该变量定义了查找二进制文件`hipify-clang`的路径。'
- en: '[PRE23]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that the rocm version we used is `rocm-6.0.3`.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们使用的rocm版本是`rocm-6.0.3`。
- en: '**Step 4**: Running `hipify-clang` from inside the singularity container'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤4**：在singularity容器内部运行`hipify-clang`'
- en: '[PRE24]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here the cuda path and the path to the `*includes*` and `*defines*` files should
    be specified. The CUDA source code and the generated output code are program.cu
    and hip_program.cu.hip, respectively.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，应指定cuda路径以及`*includes*`和`*defines*`文件的路径。CUDA源代码和生成的输出代码分别是`program.cu`和`hip_program.cu.hip`。
- en: The syntax for the compilation process of the generated hip code is similar
    to the one described in the previous section (see the **Step 3** in the hipify-perl
    section).
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成的hip代码的编译过程语法与上一节中描述的类似（参见hipify-perl部分的**步骤3**）。
- en: 'Code examples for the `Hipify` exercises can be accessed in the content/examples/exercise_hipify
    subdirectory by cloning this repository:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hipify`练习的代码示例可以通过在`content/examples/exercise_hipify`子目录中克隆此存储库来访问：'
- en: '[PRE25]'
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Exercise I : Translate an CUDA code to HIP with `hipify-perl`'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 练习I：使用`hipify-perl`将CUDA代码转换为HIP
- en: 1.1 Generate the `hipify-perl` tool.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1 生成`hipify-perl`工具。
- en: 1.2 Convert the CUDA code `vec_add_cuda.cu` located in `/exercise_hipify/Hipify_perl`
    with the `Hipify-perl` tool to HIP.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2 使用`Hipify-perl`工具将位于`/exercise_hipify/Hipify_perl`的CUDA代码`vec_add_cuda.cu`转换为HIP。
- en: 1.3 Compile the generated HIP code with the `hipcc` compiler wrapper and run
    it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3 使用`hipcc`编译器包装器编译生成的HIP代码并运行它。
- en: 'Exercise II : Translate an CUDA code to HIP with `hipify-clang`'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 练习II：使用`hipify-clang`将CUDA代码转换为HIP
- en: 2.1 Convert the CUDA code `vec_add_cuda.cu` located in `/exercise_hipify/Hipify_clang`
    with the `Hipify-clang` tool to HIP.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 2.1 使用`Hipify-clang`工具将位于`/exercise_hipify/Hipify_clang`的CUDA代码`vec_add_cuda.cu`转换为HIP。
- en: 2.2 Compile the generated HIP code with the `hipcc` compiler wrapper and run
    it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 2.2 使用 `hipcc` 编译器包装器编译生成的 HIP 代码并运行。
- en: Translating OpenACC to OpenMP with Clacc
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Clacc 将 OpenACC 转换为 OpenMP
- en: '[Clacc](https://github.com/llvm-doe-org/llvm-project/tree/clacc/main) is a
    tool to translate an OpenACC application to OpenMP offloading with the Clang/LLVM
    compiler environment. Note that the tool is specific to OpenACC C, while OpenACC
    Fortran is already supported on AMD GPU. As indicated in the [GitHub repository](https://github.com/llvm-doe-org/llvm-project/tree/clacc/main)
    the compiler `Clacc` is the `Clang`’s executable in the subdirectory `\bin` of
    the `\install` directory as described below.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[Clacc](https://github.com/llvm-doe-org/llvm-project/tree/clacc/main) 是一个工具，用于将
    OpenACC 应用程序转换为使用 Clang/LLVM 编译器环境的 OpenMP 转发。请注意，该工具针对 OpenACC C，而 OpenACC Fortran
    已经在 AMD GPU 上得到支持。如 [GitHub 仓库](https://github.com/llvm-doe-org/llvm-project/tree/clacc/main)
    中所示，编译器 `Clacc` 是位于 `\install` 目录下的 `\bin` 子目录中的 `Clang` 可执行文件，具体描述如下。'
- en: 'In the following we present a step-by-step guide for building and using Clacc:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下内容中，我们提供了一个逐步指南，用于构建和使用 Clacc：
- en: '**Step 1**: Building and installing [Clacc](https://github.com/llvm-doe-org/llvm-project/tree/clacc/main).'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 1**：构建和安装 [Clacc](https://github.com/llvm-doe-org/llvm-project/tree/clacc/main)。'
- en: '[PRE26]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Step 2**: Setting up environment variables to be able to work from the `/install`
    directory, which is the simplest way. We assume that the `/install` directory
    is located in the path `/project/project_xxxxxx/Clacc/llvm-project`.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 2**：设置环境变量，以便能够从 `/install` 目录工作，这是最简单的方法。我们假设 `/install` 目录位于路径 `/project/project_xxxxxx/Clacc/llvm-project`。'
- en: For more advanced usage, which includes for instance modifying `Clacc`, we refer
    readers to [“Usage from Build directory”](https://github.com/llvm-doe-org/llvm-project/blob/clacc/main/README.md)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高级的使用，例如修改 `Clacc`，我们建议读者参考[“从构建目录使用”](https://github.com/llvm-doe-org/llvm-project/blob/clacc/main/README.md)。
- en: '[PRE27]'
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Step 3**: Source to source conversion of the openACC_code.c code to be printed
    out to the file openMP_code.c:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 3**：将需要打印输出的 openACC_code.c 代码源代码转换为 openMP_code.c：'
- en: '[PRE28]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here the flag `-fopenacc-structured-ref-count-omp=no-ompx-hold` is introduced
    to disable the `ompx_hold` map type modifier, which is used by the OpenACC `copy`
    clause translation. The `ompx_hold` is an OpenMP extension that might not be supported
    yet by other compilers.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里引入了标志 `-fopenacc-structured-ref-count-omp=no-ompx-hold` 来禁用 `ompx_hold` 映射类型修饰符，该修饰符用于
    OpenACC `copy` 子句的翻译。`ompx_hold` 是一个 OpenMP 扩展，可能尚未被其他编译器支持。
- en: '**Step 4** Compiling the code with the [cc compiler wrapper](https://docs.lumi-supercomputer.eu/development/compiling/prgenv/)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 4**：使用 [cc 编译器包装器](https://docs.lumi-supercomputer.eu/development/compiling/prgenv/)
    编译代码。'
- en: '[PRE29]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Access exercise material
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 访问练习材料
- en: 'Code examples for the `Clacc` exercise can be accessed in the content/examples/exercise_clacc
    subdirectory by cloning this repository:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`Clacc` 练习的代码示例可以通过在内容目录 `examples/exercise_clacc` 中克隆此仓库来访问：'
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Exercise : Translate an OpenACC code to OpenMP'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：将 OpenACC 代码转换为 OpenMP
- en: Convert the OpenACC code `openACC_code.c` located in `/exercise_clacc` with
    the `Clacc` compiler.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Clacc` 编译器将位于 `/exercise_clacc` 的 OpenACC 代码 `openACC_code.c` 转换。
- en: Compile the generated OpenMP code with the `cc` compiler wrapper and run it.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cc` 编译器包装器编译生成的 OpenMP 代码并运行。
- en: Translating CUDA to SYCL/DPC++ with SYCLomatic
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 SYCLomatic 将 CUDA 转换为 SYCL/DPC++
- en: Intel offers a tool for CUDA-to-SYCL code migration, included in the Intel oneAPI
    Basekit.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Intel 提供了一个用于 CUDA 到 SYCL 代码迁移的工具，包含在 Intel oneAPI Basekit 中。
- en: 'It is not installed on LUMI, but the general workflow is similar to the HIPify
    Clang and also requires an existing CUDA installation:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有安装在 LUMI 上，但一般工作流程与 HIPify Clang 相似，并且也需要现有的 CUDA 安装：
- en: '[PRE31]'
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE31]'
- en: SYCLomatic can migrate larger projects by using `-in-root` and `-out-root` flags
    to process directories recursively. It can also use compilation database (supported
    by CMake and other build systems) to deal with more complex project layouts.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: SYCLomatic 可以通过使用 `-in-root` 和 `-out-root` 标志递归地处理目录来迁移较大的项目。它还可以使用编译数据库（由 CMake
    和其他构建系统支持）来处理更复杂的项目布局。
- en: Please note that the code generated by SYCLomatic relies on oneAPI-specific
    extensions, and thus cannot be directly used with other SYCL implementations,
    such as AdaptiveCpp (hipSYCL). The `--no-incremental-migration` flag can be added
    to `dpct` command to minimize, but not completely avoid, the use of this compatibility
    layer. That would require manual effort, since some CUDA concepts cannot be directly
    mapped to SYCL.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由 SYCLomatic 生成的代码依赖于 oneAPI 特定扩展，因此不能直接与其他 SYCL 实现（如 AdaptiveCpp（hipSYCL））一起使用。可以通过将
    `--no-incremental-migration` 标志添加到 `dpct` 命令中来最小化，但无法完全避免使用此兼容层。因为这需要手动操作，因为某些
    CUDA 概念不能直接映射到 SYCL。
- en: Additionally, CUDA applications might assume certain hardware behavior, such
    as 32-wide warps. If the target hardware is different (e.g., AMD MI250 GPUs, used
    in LUMI, have warp size of 64), the algorithms might need to be adjusted manually.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，CUDA 应用程序可能假设某些硬件行为，例如 32 宽的 warps。如果目标硬件不同（例如，LUMI 中使用的 AMD MI250 GPU，warp
    的大小为 64），则算法可能需要手动调整。
- en: Conclusion
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: This concludes a brief overview of the usage of available tools to convert CUDA
    codes to HIP and SYCL, and OpenACC codes to OpenMP offloading. In general the
    translation process for large applications might be incomplete and thus requires
    manual modification to complete the porting process. It is however worth noting
    that the accuracy of the translation process requires that applications are written
    correctly according to the CUDA and OpenACC syntaxes.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这简要概述了使用现有工具将 CUDA 代码转换为 HIP 和 SYCL，以及将 OpenACC 代码转换为 OpenMP 转发的用法。一般来说，大型应用程序的转换过程可能不完整，因此需要手动修改以完成迁移过程。然而，值得注意的是，转换过程的准确性要求应用程序根据
    CUDA 和 OpenACC 语法正确编写。
- en: See also
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Hipify GitHub](https://github.com/ROCm/HIPIFY)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Hipify GitHub](https://github.com/ROCm/HIPIFY)'
- en: '[HIPify Reference Guide v5.1](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Hipify 参考指南 v5.1](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html)'
- en: '[HIP example](https://github.com/olcf-tutorials/simple_HIP_examples/tree/master/vector_addition)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[HIP 示例](https://github.com/olcf-tutorials/simple_HIP_examples/tree/master/vector_addition)'
- en: '[Porting CUDA to HIP](https://www.admin-magazine.com/HPC/Articles/Porting-CUDA-to-HIP)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将 CUDA 迁移到 HIP](https://www.admin-magazine.com/HPC/Articles/Porting-CUDA-to-HIP)'
- en: '[Clacc Main repository README](https://github.com/llvm-doe-org/llvm-project/blob/clacc/main/README.md)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Clacc 主仓库 README](https://github.com/llvm-doe-org/llvm-project/blob/clacc/main/README.md)'
- en: '[SYCLomatic main mage](https://www.intel.com/content/www/us/en/developer/articles/technical/syclomatic-new-cuda-to-sycl-code-migration-tool.html)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SYCLomatic 主图](https://www.intel.com/content/www/us/en/developer/articles/technical/syclomatic-new-cuda-to-sycl-code-migration-tool.html)'
- en: '[SYCLomatic documentation](https://oneapi-src.github.io/SYCLomatic/get_started/index.html)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SYCLomatic 文档](https://oneapi-src.github.io/SYCLomatic/get_started/index.html)'
- en: Keypoints
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 重点
- en: Useful tools exist to automatically translate tools from CUDA to HIP and SYCL
    and from OpenACC to OpenMP, but they may require manual modifications.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在将工具从 CUDA 转换到 HIP 和 SYCL 以及从 OpenACC 转换到 OpenMP 的有用工具，但可能需要手动修改。
- en: Porting from CPU to GPU
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 CPU 迁移到 GPU
- en: 'When porting code to take advantage of the parallel processing capability of
    GPUs, several steps need to be followed and some additional work is required before
    writing actual parallel code to be executed on the GPUs:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在将代码迁移以利用 GPU 的并行处理能力时，需要遵循几个步骤，并在实际编写要在 GPU 上执行的并行代码之前做一些额外的工作：
- en: '**Identify Targeted Parts**: Begin by identifying the parts of the code that
    contribute significantly to the execution time. These are often computationally
    intensive sections such as loops or matrix operations. The Pareto principle suggests
    that roughly 10-20% of the code accounts for 80-90% of the execution time.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**识别目标部分**：首先识别对执行时间贡献显著的代码部分。这些通常是计算密集型部分，如循环或矩阵运算。帕累托原则表明，大约 10-20% 的代码占用了
    80-90% 的执行时间。'
- en: '**Equivalent GPU Libraries**: If the original code uses CPU libraries like
    BLAS, FFT, etc, it’s crucial to identify the equivalent GPU libraries. For example,
    cuBLAS or hipBLAS can replace CPU-based BLAS libraries. Utilizing GPU-specific
    libraries ensures efficient GPU utilization.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**等效 GPU 库**：如果原始代码使用 CPU 库（如 BLAS、FFT 等），则识别等效 GPU 库至关重要。例如，cuBLAS 或 hipBLAS
    可以替换基于 CPU 的 BLAS 库。利用特定于 GPU 的库可以确保高效利用 GPU。'
- en: '**Refactor Loops**: When porting loops directly to GPUs, some refactoring is
    necessary to suit the GPU architecture. This typically involves splitting the
    loop into multiple steps or modifying operations to exploit the independence between
    iterations and improve memory access patterns. Each step of the original loop
    can be mapped to a kernel, executed by multiple GPU threads, with each thread
    corresponding to an iteration.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构循环**：在直接将循环移植到GPU时，需要进行一些重构以适应GPU架构。这通常涉及将循环拆分为多个步骤或修改操作以利用迭代之间的独立性并改进内存访问模式。原始循环的每个步骤都可以映射到一个内核，由多个GPU线程执行，每个线程对应一个迭代。'
- en: '**Memory Access Optimization**: Consider the memory access patterns in the
    code. GPUs perform best when memory access is coalesced and aligned. Minimizing
    global memory accesses and maximizing utilization of shared memory or registers
    can significantly enhance performance. Review the code to ensure optimal memory
    access for GPU execution.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存访问优化**：考虑代码中的内存访问模式。当内存访问是归一化和对齐的时，GPU表现最佳。通过最小化全局内存访问并最大化共享内存或寄存器的利用，可以显著提高性能。审查代码以确保GPU执行的优化内存访问。'
- en: Discussion
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 讨论
- en: How would this be ported? (n_soap ≈ 100, n_sites ⩾ 10000, k_max ≈ 20*n_sites
    )
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这将如何移植？（n_soap ≈ 100，n_sites ⩾ 10000，k_max ≈ 20*n_sites）
- en: ''
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Inspect the following Fortran code (if you don’t read Fortran: do-loops ==
    for-loops)'
  id: totrans-268
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查以下Fortran代码（如果你不读Fortran：do-loops == for-loops）
- en: ''
  id: totrans-269
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-270
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ''
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Some steps at first glance:'
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一些初步步骤：
- en: ''
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: the code could (has to) be splitted in 3-4 kernels. Why?
  id: totrans-274
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可以被（必须）拆分为3-4个内核。为什么？
- en: ''
  id: totrans-275
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-276
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: check if there are any variables that could lead to false dependencies between
    iterations, like the index k2
  id: totrans-277
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查是否存在可能导致迭代之间产生虚假依赖的变量，如索引k2
- en: ''
  id: totrans-278
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-279
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: is it efficient for GPUs to split the work over the index i? What about the
    memory access? Note the arrays are 2D in Fortran
  id: totrans-280
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于GPU来说，将工作分配到索引i是否高效？关于内存访问呢？注意Fortran中的数组是二维的。
- en: ''
  id: totrans-281
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-282
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: is it possible to collapse some loops? Combining nested loops can reduce overhead
    and improve memory access patterns, leading to better GPU performance.
  id: totrans-283
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否可以合并一些循环？合并嵌套循环可以减少开销并改进内存访问模式，从而提高GPU性能。
- en: ''
  id: totrans-284
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-285
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: what is the best memory access in a GPU? Review memory access patterns in the
    code. Minimize global memory access by utilizing shared memory or registers where
    appropriate. Ensure memory access is coalesced and aligned, maximizing GPU memory
    throughput
  id: totrans-286
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GPU中最佳的内存访问是什么？回顾代码中的内存访问模式。通过在适当的地方使用共享内存或寄存器来最小化全局内存访问，确保内存访问是归一化和对齐的，以最大化GPU内存吞吐量。
- en: Refactored code!
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重构！
- en: Registers are limited and the larger the kernel use more registers registers
    resulting in less active threads (small occupancy).
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器有限，内核使用寄存器越多，活跃线程就越少（占用率低）。
- en: In order to compute soap_rad_der(is,k2) the CUDA thread needs access to all
    the previous values soap_rad_der(1:nsoap,k2).
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了计算 soap_rad_der(is,k2)，CUDA线程需要访问所有之前值 soap_rad_der(1:nsoap,k2)。
- en: In order to compute soap_cart_der(1, 1:n_soap, k3) it is required to have access
    to all values (k3+1:k2+n_neigh(i)).
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了计算 soap_cart_der(1, 1:n_soap, k3)，需要访问所有值（k3+1:k2+n_neigh(i)）。
- en: Note the indices in the first part. The matrices are transposed for better access
    patterns.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意第一部分中的索引。矩阵被转置以获得更好的访问模式。
- en: '[PRE33]'
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Keypoints
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 重点
- en: Identify equivalent GPU libraries for CPU-based libraries and utilizing them
    to ensure efficient GPU utilization.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别与基于CPU的库等效的GPU库，并利用它们以确保高效的GPU利用。
- en: Importance of identifying the computationally intensive parts of the code that
    contribute significantly to the execution time.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别代码中计算密集部分的重要性，这些部分对执行时间有显著贡献。
- en: The need to refactor loops to suit the GPU architecture.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要重构循环以适应GPU架构。
- en: Significance of memory access optimization for efficient GPU execution, including
    coalesced and aligned memory access patterns.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存访问优化对于高效GPU执行的重要性，包括归一化和对齐的内存访问模式。
- en: Discussion
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 讨论
- en: How would this be ported? (n_soap ≈ 100, n_sites ⩾ 10000, k_max ≈ 20*n_sites
    )
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这将如何移植？（n_soap ≈ 100，n_sites ⩾ 10000，k_max ≈ 20*n_sites）
- en: ''
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Inspect the following Fortran code (if you don’t read Fortran: do-loops ==
    for-loops)'
  id: totrans-301
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查以下Fortran代码（如果你不读Fortran：do-loops == for-loops）
- en: ''
  id: totrans-302
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-303
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ''
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Some steps at first glance:'
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一些初步步骤：
- en: ''
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: the code could (has to) be splitted in 3-4 kernels. Why?
  id: totrans-307
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可以被（必须）拆分为3-4个内核。为什么？
- en: ''
  id: totrans-308
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-309
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: check if there are any variables that could lead to false dependencies between
    iterations, like the index k2
  id: totrans-310
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查是否存在可能导致迭代之间产生虚假依赖的变量，如索引k2
- en: ''
  id: totrans-311
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-312
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: is it efficient for GPUs to split the work over the index i? What about the
    memory access? Note the arrays are 2D in Fortran
  id: totrans-313
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 GPU 来说，将工作分配到索引 i 是否高效？关于内存访问呢？注意 Fortran 中的数组是二维的
- en: ''
  id: totrans-314
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-315
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: is it possible to collapse some loops? Combining nested loops can reduce overhead
    and improve memory access patterns, leading to better GPU performance.
  id: totrans-316
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否可以合并一些循环？合并嵌套循环可以减少开销并改善内存访问模式，从而提高 GPU 性能。
- en: ''
  id: totrans-317
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-318
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: what is the best memory access in a GPU? Review memory access patterns in the
    code. Minimize global memory access by utilizing shared memory or registers where
    appropriate. Ensure memory access is coalesced and aligned, maximizing GPU memory
    throughput
  id: totrans-319
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GPU 中最佳的内存访问方式是什么？审查代码中的内存访问模式。通过在适当的地方利用共享内存或寄存器来最小化全局内存访问。确保内存访问是合并和对齐的，以最大化
    GPU 内存吞吐量
- en: Refactored code!
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 重构后的代码！
- en: Registers are limited and the larger the kernel use more registers registers
    resulting in less active threads (small occupancy).
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器有限，内核使用寄存器越多，活跃线程就越少（占用率低）。
- en: In order to compute soap_rad_der(is,k2) the CUDA thread needs access to all
    the previous values soap_rad_der(1:nsoap,k2).
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了计算 soap_rad_der(is,k2)，CUDA 线程需要访问所有之前值 soap_rad_der(1:nsoap,k2)。
- en: In order to compute soap_cart_der(1, 1:n_soap, k3) it is required to have access
    to all values (k3+1:k2+n_neigh(i)).
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了计算 soap_cart_der(1, 1:n_soap, k3)，需要访问所有值（k3+1:k2+n_neigh(i)）。
- en: Note the indices in the first part. The matrices are transposed for better access
    patterns.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意第一部分中的索引。矩阵被转置以获得更好的访问模式。
- en: '[PRE35]'
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Keypoints
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点
- en: Identify equivalent GPU libraries for CPU-based libraries and utilizing them
    to ensure efficient GPU utilization.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别与基于 CPU 的库等效的 GPU 库，并利用它们以确保高效的 GPU 利用率。
- en: Importance of identifying the computationally intensive parts of the code that
    contribute significantly to the execution time.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别代码中计算密集部分的重要性，这些部分对执行时间有显著贡献。
- en: The need to refactor loops to suit the GPU architecture.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要重构循环以适应 GPU 架构。
- en: Significance of memory access optimization for efficient GPU execution, including
    coalesced and aligned memory access patterns.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存访问优化对高效 GPU 执行的重要性，包括合并和对齐的内存访问模式。
- en: Porting between different GPU frameworks
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在不同的 GPU 框架之间移植
- en: You might also find yourself in a situation where you need to port a code from
    one particular GPU framework to another. This section gives an overview of different
    tools that enable converting CUDA and OpenACC codes to HIP and OpenMP, respectively.
    This conversion process enables an application to target various GPU architectures,
    specifically, NVIDIA and AMD GPUs. Here we focus on [hipify](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html)
    and [clacc](https://csmd.ornl.gov/project/clacc) tools. This guide is adapted
    from the [NRIS documentation](https://documentation.sigma2.no/code_development/guides/cuda_translating-tools.html).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也会发现自己处于需要将代码从一个特定的 GPU 框架移植到另一个框架的情况。本节概述了不同的工具，这些工具可以将 CUDA 和 OpenACC 代码分别转换为
    HIP 和 OpenMP。此转换过程使应用程序能够针对各种 GPU 架构，特别是 NVIDIA 和 AMD GPU。在此，我们关注 [hipify](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html)
    和 [clacc](https://csmd.ornl.gov/project/clacc) 工具。本指南改编自 [NRIS 文档](https://documentation.sigma2.no/code_development/guides/cuda_translating-tools.html)。
- en: Translating CUDA to HIP with Hipify
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Hipify 将 CUDA 转换为 HIP
- en: In this section, we cover the use of `hipify-perl` and `hipify-clang` tools
    to translate a CUDA code to HIP.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了使用 `hipify-perl` 和 `hipify-clang` 工具将 CUDA 代码转换为 HIP 的方法。
- en: Hipify-perl
  id: totrans-335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Hipify-perl
- en: The `hipify-perl` tool is a script based on perl that translates CUDA syntax
    into HIP syntax (see .e.g. [here](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl)
    for more details). For instance, in a CUDA code that incorporates the CUDA functions
    `` cudaMalloc` `` and `cudaDeviceSynchronize`, the tool will substitute `cudaMalloc`
    with the HIP function `hipMalloc`. Similarly the CUDA function `cudaDeviceSynchronize`
    will be substituted with the HIP function `hipDeviceSynchronize`. We list below
    the basic steps to run `hipify-perl` on LUMI-G.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`hipify-perl` 工具是一个基于 perl 的脚本，它将 CUDA 语法转换为 HIP 语法（例如，请参阅[此处](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl)以获取更多详细信息）。例如，在一个包含
    CUDA 函数 `cudaMalloc` 和 `cudaDeviceSynchronize` 的 CUDA 代码中，该工具将用 HIP 函数 `hipMalloc`
    替换 `cudaMalloc`。同样，CUDA 函数 `cudaDeviceSynchronize` 将被 HIP 函数 `hipDeviceSynchronize`
    替换。以下是在 LUMI-G 上运行 `hipify-perl` 的基本步骤。'
- en: '**Step 1**: Generating `hipify-perl` script'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 1**：生成 `hipify-perl` 脚本'
- en: '[PRE36]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Step 2**: Running the generated `hipify-perl`'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 2**：运行生成的 `hipify-perl`'
- en: '[PRE37]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Step 3**: Compiling with `hipcc` the generated HIP code'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 3**：使用 `hipcc` 编译器包装器编译生成的 HIP 代码'
- en: '[PRE38]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Despite the simplicity of the use of `hipify-perl`, the tool might not be suitable
    for large applications, as it relies heavily on substituting CUDA strings with
    HIP strings (e.g. it substitutes `*cuda*` with `*hip*`). In addition, `hipify-perl`
    lacks the ability of [distinguishing device/host function calls](https://docs.amd.com/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl).
    The alternative here is to use the `hipify-clang` tool as will be described in
    the next section.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `hipify-perl` 的使用很简单，但该工具可能不适合大型应用程序，因为它主要依赖于将 CUDA 字符串替换为 HIP 字符串（例如，将 `*cuda*`
    替换为 `*hip*`）。此外，`hipify-perl` 缺乏[区分设备/主机函数调用](https://docs.amd.com/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl)的能力。这里的替代方案是使用下一节将要描述的
    `hipify-clang` 工具。
- en: Hipify-clang
  id: totrans-344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Hipify-clang
- en: As described in the [HIPIFY documentation](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl),
    the `hipify-clang` tool is based on clang for translating CUDA sources into HIP
    sources. The tool is more robust for translating CUDA codes compared to the `hipify-perl`
    tool. Furthermore, it facilitates the analysis of the code by providing assistance.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [HIPIFY 文档](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl)
    所述，`hipify-clang` 工具基于 clang，用于将 CUDA 源代码转换为 HIP 源代码。与 `hipify-perl` 工具相比，该工具在翻译
    CUDA 代码方面更稳健。此外，它通过提供辅助功能来促进代码分析。
- en: 'In short, `hipify-clang` requires `LLVM+CLANG` and `CUDA`. Details about building
    `hipify-clang` can be found [here](https://github.com/ROCm/HIPIFY). Note that
    `hipify-clang` is available on LUMI-G. The issue however might be related to the
    installation of CUDA-toolkit. To avoid any eventual issues with the installation
    procedure we opt for CUDA singularity container. Here we present a step-by-step
    guide for running `hipify-clang`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`hipify-clang` 需要 `LLVM+CLANG` 和 `CUDA`。有关构建 `hipify-clang` 的详细信息，请参阅[此处](https://github.com/ROCm/HIPIFY)。请注意，`hipify-clang`
    在 LUMI-G 上可用。然而，问题可能与管理 CUDA-toolkit 的安装有关。为了避免安装过程中可能出现的任何问题，我们选择使用 CUDA singularity
    容器。在此，我们提供了一个逐步指南，用于运行 `hipify-clang`：
- en: '**Step 1**: Pulling a CUDA singularity container e.g.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 1**：拉取 CUDA singularity 容器，例如。'
- en: '[PRE39]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**Step 2**: Loading a rocm module and launching the CUDA singularity'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 2**：加载 rocm 模块并启动 CUDA singularity'
- en: '[PRE40]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: where the current directory `$PWD` in the host is mounted to that of the container,
    and the directory `/opt` in the host is mounted to the that inside the container.
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中，主机中的当前目录 `$PWD` 被挂载到容器中的相应目录，主机中的 `/opt` 目录被挂载到容器内的相应目录。
- en: '**Step 3**: Setting the environment variable `$PATH`. In order to run `hipify-clang`
    from inside the container, one can set the environment variable `$PATH` that defines
    the path to look for the binary `hipify-clang`.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 3**：设置环境变量 `$PATH`。为了在容器内运行 `hipify-clang`，可以设置环境变量 `$PATH`，该变量定义了查找二进制文件
    `hipify-clang` 的路径。'
- en: '[PRE41]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that the rocm version we used is `rocm-6.0.3`.
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们使用的 rocm 版本是 `rocm-6.0.3`。
- en: '**Step 4**: Running `hipify-clang` from inside the singularity container'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 4**：在 singularity 容器内运行 `hipify-clang`'
- en: '[PRE42]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here the cuda path and the path to the `*includes*` and `*defines*` files should
    be specified. The CUDA source code and the generated output code are program.cu
    and hip_program.cu.hip, respectively.
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，应指定 cuda 路径以及 `*includes*` 和 `*defines*` 文件的路经。CUDA 源代码和生成的输出代码分别是 program.cu
    和 hip_program.cu.hip。
- en: The syntax for the compilation process of the generated hip code is similar
    to the one described in the previous section (see the **Step 3** in the hipify-perl
    section).
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成 hip 代码的编译过程语法与上一节中描述的类似（参见 hipify-perl 节的 **步骤 3**）。
- en: 'Code examples for the `Hipify` exercises can be accessed in the content/examples/exercise_hipify
    subdirectory by cloning this repository:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过克隆此存储库在内容/示例/exercise_hipify 子目录中访问 `Hipify` 练习的代码示例：
- en: '[PRE43]'
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Exercise I : Translate an CUDA code to HIP with `hipify-perl`'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 I：使用 `hipify-perl` 将 CUDA 代码翻译成 HIP
- en: 1.1 Generate the `hipify-perl` tool.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1 生成 `hipify-perl` 工具。
- en: 1.2 Convert the CUDA code `vec_add_cuda.cu` located in `/exercise_hipify/Hipify_perl`
    with the `Hipify-perl` tool to HIP.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2 使用 `Hipify-perl` 工具将位于 `/exercise_hipify/Hipify_perl` 的 CUDA 代码 `vec_add_cuda.cu`
    转换为 HIP。
- en: 1.3 Compile the generated HIP code with the `hipcc` compiler wrapper and run
    it.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3 使用 `hipcc` 编译器包装器编译生成的 HIP 代码并运行它。
- en: 'Exercise II : Translate an CUDA code to HIP with `hipify-clang`'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 II：使用 `hipify-clang` 将 CUDA 代码翻译成 HIP
- en: 2.1 Convert the CUDA code `vec_add_cuda.cu` located in `/exercise_hipify/Hipify_clang`
    with the `Hipify-clang` tool to HIP.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 2.1 使用`Hipify-clang`工具将位于`/exercise_hipify/Hipify_clang`的CUDA代码`vec_add_cuda.cu`转换为HIP。
- en: 2.2 Compile the generated HIP code with the `hipcc` compiler wrapper and run
    it.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 2.2 使用`hipcc`编译器包装器编译生成的HIP代码并运行它。
- en: Translating OpenACC to OpenMP with Clacc
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Clacc将OpenACC转换为OpenMP
- en: '[Clacc](https://github.com/llvm-doe-org/llvm-project/tree/clacc/main) is a
    tool to translate an OpenACC application to OpenMP offloading with the Clang/LLVM
    compiler environment. Note that the tool is specific to OpenACC C, while OpenACC
    Fortran is already supported on AMD GPU. As indicated in the [GitHub repository](https://github.com/llvm-doe-org/llvm-project/tree/clacc/main)
    the compiler `Clacc` is the `Clang`’s executable in the subdirectory `\bin` of
    the `\install` directory as described below.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[Clacc](https://github.com/llvm-doe-org/llvm-project/tree/clacc/main)是一个工具，可以将OpenACC应用程序转换为使用Clang/LLVM编译器环境的OpenMP卸载。请注意，该工具特定于OpenACC
    C，而OpenACC Fortran已在AMD GPU上得到支持。如[GitHub存储库](https://github.com/llvm-doe-org/llvm-project/tree/clacc/main)中所示，编译器`Clacc`是描述如下`\install`目录`\bin`子目录中的`Clang`的可执行文件。'
- en: 'In the following we present a step-by-step guide for building and using Clacc:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下内容中，我们提供了一个逐步指南来构建和使用Clacc：
- en: '**Step 1**: Building and installing [Clacc](https://github.com/llvm-doe-org/llvm-project/tree/clacc/main).'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 1**：构建和安装[Clacc](https://github.com/llvm-doe-org/llvm-project/tree/clacc/main)。'
- en: '[PRE44]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**Step 2**: Setting up environment variables to be able to work from the `/install`
    directory, which is the simplest way. We assume that the `/install` directory
    is located in the path `/project/project_xxxxxx/Clacc/llvm-project`.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 2**：设置环境变量以便能够从`/install`目录工作，这是最简单的方法。我们假设`/install`目录位于路径`/project/project_xxxxxx/Clacc/llvm-project`中。'
- en: For more advanced usage, which includes for instance modifying `Clacc`, we refer
    readers to [“Usage from Build directory”](https://github.com/llvm-doe-org/llvm-project/blob/clacc/main/README.md)
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高级的使用，例如修改`Clacc`，我们建议读者参考[“从构建目录使用”](https://github.com/llvm-doe-org/llvm-project/blob/clacc/main/README.md)
- en: '[PRE45]'
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '**Step 3**: Source to source conversion of the openACC_code.c code to be printed
    out to the file openMP_code.c:'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 3**：将openACC_code.c代码源到源转换为要打印到文件openMP_code.c中的代码：'
- en: '[PRE46]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here the flag `-fopenacc-structured-ref-count-omp=no-ompx-hold` is introduced
    to disable the `ompx_hold` map type modifier, which is used by the OpenACC `copy`
    clause translation. The `ompx_hold` is an OpenMP extension that might not be supported
    yet by other compilers.
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里引入了标志`-fopenacc-structured-ref-count-omp=no-ompx-hold`来禁用`ompx_hold`映射类型修饰符，该修饰符用于OpenACC
    `copy`子句的转换。`ompx_hold`是OpenMP扩展，可能尚未被其他编译器支持。
- en: '**Step 4** Compiling the code with the [cc compiler wrapper](https://docs.lumi-supercomputer.eu/development/compiling/prgenv/)'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 4**：使用[cc编译器包装器](https://docs.lumi-supercomputer.eu/development/compiling/prgenv/)编译代码'
- en: '[PRE47]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Access exercise material
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 访问练习材料
- en: 'Code examples for the `Clacc` exercise can be accessed in the content/examples/exercise_clacc
    subdirectory by cloning this repository:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在内容目录`content/examples/exercise_clacc`下克隆此存储库来访问`Clacc`练习的代码示例：
- en: '[PRE48]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Exercise : Translate an OpenACC code to OpenMP'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：将OpenACC代码转换为OpenMP
- en: Convert the OpenACC code `openACC_code.c` located in `/exercise_clacc` with
    the `Clacc` compiler.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Clacc`编译器将位于`/exercise_clacc`的OpenACC代码`openACC_code.c`转换为HIP。
- en: Compile the generated OpenMP code with the `cc` compiler wrapper and run it.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cc`编译器包装器编译生成的OpenMP代码并运行它。
- en: Translating CUDA to SYCL/DPC++ with SYCLomatic
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用SYCLomatic将CUDA转换为SYCL/DPC++
- en: Intel offers a tool for CUDA-to-SYCL code migration, included in the Intel oneAPI
    Basekit.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: Intel提供了一种CUDA到SYCL代码迁移的工具，包含在Intel oneAPI Basekit中。
- en: 'It is not installed on LUMI, but the general workflow is similar to the HIPify
    Clang and also requires an existing CUDA installation:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: Clacc没有安装在LUMI上，但总体工作流程与HIPify Clang类似，也要求存在现有的CUDA安装：
- en: '[PRE49]'
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE49]'
- en: SYCLomatic can migrate larger projects by using `-in-root` and `-out-root` flags
    to process directories recursively. It can also use compilation database (supported
    by CMake and other build systems) to deal with more complex project layouts.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: SYCLomatic可以通过使用`-in-root`和`-out-root`标志递归处理目录来迁移更大的项目。它还可以使用编译数据库（由CMake和其他构建系统支持）来处理更复杂的项目布局。
- en: Please note that the code generated by SYCLomatic relies on oneAPI-specific
    extensions, and thus cannot be directly used with other SYCL implementations,
    such as AdaptiveCpp (hipSYCL). The `--no-incremental-migration` flag can be added
    to `dpct` command to minimize, but not completely avoid, the use of this compatibility
    layer. That would require manual effort, since some CUDA concepts cannot be directly
    mapped to SYCL.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由 SYCLomatic 生成的代码依赖于 oneAPI 特定扩展，因此不能直接与其他 SYCL 实现一起使用，例如 AdaptiveCpp（hipSYCL）。可以将
    `--no-incremental-migration` 标志添加到 `dpct` 命令中，以最小化但不完全避免使用此兼容层。这将需要手动操作，因为某些 CUDA
    概念不能直接映射到 SYCL。
- en: Additionally, CUDA applications might assume certain hardware behavior, such
    as 32-wide warps. If the target hardware is different (e.g., AMD MI250 GPUs, used
    in LUMI, have warp size of 64), the algorithms might need to be adjusted manually.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，CUDA 应用程序可能假设某些硬件行为，例如 32 宽的 warp。如果目标硬件不同（例如，LUMI 中使用的 AMD MI250 GPU，warp
    的大小为 64），则算法可能需要手动调整。
- en: Conclusion
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: This concludes a brief overview of the usage of available tools to convert CUDA
    codes to HIP and SYCL, and OpenACC codes to OpenMP offloading. In general the
    translation process for large applications might be incomplete and thus requires
    manual modification to complete the porting process. It is however worth noting
    that the accuracy of the translation process requires that applications are written
    correctly according to the CUDA and OpenACC syntaxes.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了关于使用现有工具将 CUDA 代码转换为 HIP 和 SYCL，以及将 OpenACC 代码转换为 OpenMP 载荷的简要概述。一般来说，大型应用程序的转换过程可能是不完整的，因此需要手动修改以完成移植过程。然而，值得注意的是，转换过程的准确性要求应用程序根据
    CUDA 和 OpenACC 语法正确编写。
- en: Translating CUDA to HIP with Hipify
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Hipify 将 CUDA 转换为 HIP
- en: In this section, we cover the use of `hipify-perl` and `hipify-clang` tools
    to translate a CUDA code to HIP.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何使用 `hipify-perl` 和 `hipify-clang` 工具将 CUDA 代码转换为 HIP。
- en: Hipify-perl
  id: totrans-398
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Hipify-perl
- en: The `hipify-perl` tool is a script based on perl that translates CUDA syntax
    into HIP syntax (see .e.g. [here](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl)
    for more details). For instance, in a CUDA code that incorporates the CUDA functions
    `` cudaMalloc` `` and `cudaDeviceSynchronize`, the tool will substitute `cudaMalloc`
    with the HIP function `hipMalloc`. Similarly the CUDA function `cudaDeviceSynchronize`
    will be substituted with the HIP function `hipDeviceSynchronize`. We list below
    the basic steps to run `hipify-perl` on LUMI-G.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`hipify-perl` 工具是一个基于 perl 的脚本，它将 CUDA 语法转换为 HIP 语法（更多详情请参见[此处](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl)）。例如，在一个包含
    CUDA 函数 `cudaMalloc` 和 `cudaDeviceSynchronize` 的 CUDA 代码中，该工具会将 `cudaMalloc` 替换为
    HIP 函数 `hipMalloc`。同样，CUDA 函数 `cudaDeviceSynchronize` 也会被替换为 HIP 函数 `hipDeviceSynchronize`。以下是在
    LUMI-G 上运行 `hipify-perl` 的基本步骤。'
- en: '**Step 1**: Generating `hipify-perl` script'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 1**：生成 `hipify-perl` 脚本'
- en: '[PRE50]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**Step 2**: Running the generated `hipify-perl`'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 2**：运行生成的 `hipify-perl`'
- en: '[PRE51]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**Step 3**: Compiling with `hipcc` the generated HIP code'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 3**：使用 `hipcc` 编译生成的 HIP 代码'
- en: '[PRE52]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Despite the simplicity of the use of `hipify-perl`, the tool might not be suitable
    for large applications, as it relies heavily on substituting CUDA strings with
    HIP strings (e.g. it substitutes `*cuda*` with `*hip*`). In addition, `hipify-perl`
    lacks the ability of [distinguishing device/host function calls](https://docs.amd.com/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl).
    The alternative here is to use the `hipify-clang` tool as will be described in
    the next section.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用 `hipify-perl` 的操作很简单，但这个工具可能不适合大型应用程序，因为它主要依赖于将 CUDA 字符串替换为 HIP 字符串（例如，将
    `*cuda*` 替换为 `*hip*`）。此外，`hipify-perl` 缺乏区分设备/主机函数调用的能力[参见 HIPify 参考指南](https://docs.amd.com/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl)。在这种情况下，可以使用下一节中将要描述的
    `hipify-clang` 工具。
- en: Hipify-clang
  id: totrans-407
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Hipify-clang
- en: As described in the [HIPIFY documentation](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl),
    the `hipify-clang` tool is based on clang for translating CUDA sources into HIP
    sources. The tool is more robust for translating CUDA codes compared to the `hipify-perl`
    tool. Furthermore, it facilitates the analysis of the code by providing assistance.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [HIPIFY 文档](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl)
    所述，`hipify-clang` 工具基于 clang，用于将 CUDA 源代码转换为 HIP 源代码。与 `hipify-perl` 工具相比，该工具在翻译
    CUDA 代码方面更为稳健。此外，它通过提供辅助功能来促进代码的分析。
- en: 'In short, `hipify-clang` requires `LLVM+CLANG` and `CUDA`. Details about building
    `hipify-clang` can be found [here](https://github.com/ROCm/HIPIFY). Note that
    `hipify-clang` is available on LUMI-G. The issue however might be related to the
    installation of CUDA-toolkit. To avoid any eventual issues with the installation
    procedure we opt for CUDA singularity container. Here we present a step-by-step
    guide for running `hipify-clang`:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`hipify-clang` 需要 `LLVM+CLANG` 和 `CUDA`。有关构建 `hipify-clang` 的详细信息，请参阅[此处](https://github.com/ROCm/HIPIFY)。请注意，`hipify-clang`
    可在 LUMI-G 上使用。然而，问题可能与管理 CUDA-toolkit 的安装有关。为了避免安装过程中可能出现的任何问题，我们选择使用 CUDA singularity
    容器。以下是如何运行 `hipify-clang` 的分步指南：
- en: '**Step 1**: Pulling a CUDA singularity container e.g.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 1**：拉取 CUDA singularity 容器，例如'
- en: '[PRE53]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**Step 2**: Loading a rocm module and launching the CUDA singularity'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 2**：加载 rocm 模块并启动 CUDA singularity'
- en: '[PRE54]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: where the current directory `$PWD` in the host is mounted to that of the container,
    and the directory `/opt` in the host is mounted to the that inside the container.
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中主机当前目录 `$PWD` 映射到容器中的相应目录，主机中的 `/opt` 目录映射到容器内的相应目录。
- en: '**Step 3**: Setting the environment variable `$PATH`. In order to run `hipify-clang`
    from inside the container, one can set the environment variable `$PATH` that defines
    the path to look for the binary `hipify-clang`.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 3**：设置环境变量 `$PATH`。为了在容器内运行 `hipify-clang`，可以设置环境变量 `$PATH`，该变量定义了查找二进制文件
    `hipify-clang` 的路径。'
- en: '[PRE55]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note that the rocm version we used is `rocm-6.0.3`.
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们使用的 ROCm 版本是 `rocm-6.0.3`。
- en: '**Step 4**: Running `hipify-clang` from inside the singularity container'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 4**：在 singularity 容器内运行 `hipify-clang`'
- en: '[PRE56]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here the cuda path and the path to the `*includes*` and `*defines*` files should
    be specified. The CUDA source code and the generated output code are program.cu
    and hip_program.cu.hip, respectively.
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，应指定 cuda 路径以及 `*includes*` 和 `*defines*` 文件的路经。CUDA 源代码和生成的输出代码分别是 program.cu
    和 hip_program.cu.hip。
- en: The syntax for the compilation process of the generated hip code is similar
    to the one described in the previous section (see the **Step 3** in the hipify-perl
    section).
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成 hip 代码的编译过程语法与上一节中描述的类似（请参阅 hipify-perl 节的 **步骤 3**）。
- en: 'Code examples for the `Hipify` exercises can be accessed in the content/examples/exercise_hipify
    subdirectory by cloning this repository:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过克隆此存储库在内容/示例/exercise_hipify 子目录中访问 `Hipify` 练习的代码示例：
- en: '[PRE57]'
  id: totrans-423
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Exercise I : Translate an CUDA code to HIP with `hipify-perl`'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 I：使用 `hipify-perl` 将 CUDA 代码翻译成 HIP
- en: 1.1 Generate the `hipify-perl` tool.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1 生成 `hipify-perl` 工具。
- en: 1.2 Convert the CUDA code `vec_add_cuda.cu` located in `/exercise_hipify/Hipify_perl`
    with the `Hipify-perl` tool to HIP.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2 使用 `Hipify-perl` 工具将位于 `/exercise_hipify/Hipify_perl` 的 CUDA 代码 `vec_add_cuda.cu`
    转换为 HIP。
- en: 1.3 Compile the generated HIP code with the `hipcc` compiler wrapper and run
    it.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3 使用 `hipcc` 编译器包装器编译生成的 HIP 代码并运行它。
- en: 'Exercise II : Translate an CUDA code to HIP with `hipify-clang`'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 II：使用 `hipify-clang` 将 CUDA 代码翻译成 HIP
- en: 2.1 Convert the CUDA code `vec_add_cuda.cu` located in `/exercise_hipify/Hipify_clang`
    with the `Hipify-clang` tool to HIP.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 2.1 使用 `Hipify-clang` 工具将位于 `/exercise_hipify/Hipify_clang` 的 CUDA 代码 `vec_add_cuda.cu`
    转换为 HIP。
- en: 2.2 Compile the generated HIP code with the `hipcc` compiler wrapper and run
    it.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 2.2 使用 `hipcc` 编译器包装器编译生成的 HIP 代码并运行它。
- en: Hipify-perl
  id: totrans-431
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Hipify-perl
- en: The `hipify-perl` tool is a script based on perl that translates CUDA syntax
    into HIP syntax (see .e.g. [here](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl)
    for more details). For instance, in a CUDA code that incorporates the CUDA functions
    `` cudaMalloc` `` and `cudaDeviceSynchronize`, the tool will substitute `cudaMalloc`
    with the HIP function `hipMalloc`. Similarly the CUDA function `cudaDeviceSynchronize`
    will be substituted with the HIP function `hipDeviceSynchronize`. We list below
    the basic steps to run `hipify-perl` on LUMI-G.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`hipify-perl` 工具是一个基于 perl 的脚本，它将 CUDA 语法转换为 HIP 语法（例如，[此处](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl)提供了更多详细信息）。例如，在一个包含
    CUDA 函数 `cudaMalloc` 和 `cudaDeviceSynchronize` 的 CUDA 代码中，该工具将 `cudaMalloc` 替换为
    HIP 函数 `hipMalloc`。同样，CUDA 函数 `cudaDeviceSynchronize` 将被替换为 HIP 函数 `hipDeviceSynchronize`。以下是在
    LUMI-G 上运行 `hipify-perl` 的基本步骤。'
- en: '**Step 1**: Generating `hipify-perl` script'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 1**：生成 `hipify-perl` 脚本'
- en: '[PRE58]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '**Step 2**: Running the generated `hipify-perl`'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 2**：运行生成的 `hipify-perl`'
- en: '[PRE59]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**Step 3**: Compiling with `hipcc` the generated HIP code'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 3**：使用 `hipcc` 编译器包装器编译生成的 HIP 代码'
- en: '[PRE60]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Despite the simplicity of the use of `hipify-perl`, the tool might not be suitable
    for large applications, as it relies heavily on substituting CUDA strings with
    HIP strings (e.g. it substitutes `*cuda*` with `*hip*`). In addition, `hipify-perl`
    lacks the ability of [distinguishing device/host function calls](https://docs.amd.com/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl).
    The alternative here is to use the `hipify-clang` tool as will be described in
    the next section.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用 `hipify-perl` 简单，但该工具可能不适合大型应用程序，因为它严重依赖于用 HIP 字符串替换 CUDA 字符串（例如，将 `*cuda*`
    替换为 `*hip*`）。此外，`hipify-perl` 缺乏区分设备/主机函数调用的能力。[区分设备/主机函数调用](https://docs.amd.com/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl)。这里的替代方案是使用下一节将要描述的
    `hipify-clang` 工具。
- en: Hipify-clang
  id: totrans-440
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Hipify-clang
- en: As described in the [HIPIFY documentation](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl),
    the `hipify-clang` tool is based on clang for translating CUDA sources into HIP
    sources. The tool is more robust for translating CUDA codes compared to the `hipify-perl`
    tool. Furthermore, it facilitates the analysis of the code by providing assistance.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [HIPIFY 文档](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html#perl)
    所述，`hipify-clang` 工具基于 clang，用于将 CUDA 源代码转换为 HIP 源代码。与 `hipify-perl` 工具相比，该工具在转换
    CUDA 代码方面更为健壮。此外，它通过提供辅助功能来促进代码分析。
- en: 'In short, `hipify-clang` requires `LLVM+CLANG` and `CUDA`. Details about building
    `hipify-clang` can be found [here](https://github.com/ROCm/HIPIFY). Note that
    `hipify-clang` is available on LUMI-G. The issue however might be related to the
    installation of CUDA-toolkit. To avoid any eventual issues with the installation
    procedure we opt for CUDA singularity container. Here we present a step-by-step
    guide for running `hipify-clang`:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`hipify-clang` 需要 `LLVM+CLANG` 和 `CUDA`。有关构建 `hipify-clang` 的详细信息，请参阅[此处](https://github.com/ROCm/HIPIFY)。请注意，`hipify-clang`
    可在 LUMI-G 上使用。然而，问题可能与管理 CUDA-toolkit 的安装有关。为了避免安装过程中的任何潜在问题，我们选择使用 CUDA singularity
    容器。在此，我们提供了一个逐步指南，用于运行 `hipify-clang`：
- en: '**Step 1**: Pulling a CUDA singularity container e.g.'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 1**：拉取 CUDA singularity 容器，例如'
- en: '[PRE61]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**Step 2**: Loading a rocm module and launching the CUDA singularity'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 2**：加载 ROCm 模块并启动 CUDA singularity'
- en: '[PRE62]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: where the current directory `$PWD` in the host is mounted to that of the container,
    and the directory `/opt` in the host is mounted to the that inside the container.
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中，主机当前目录 `$PWD` 映射到容器的相应目录，主机中的 `/opt` 目录映射到容器内部的相应目录。
- en: '**Step 3**: Setting the environment variable `$PATH`. In order to run `hipify-clang`
    from inside the container, one can set the environment variable `$PATH` that defines
    the path to look for the binary `hipify-clang`.'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 3**：设置环境变量 `$PATH`。为了在容器内部运行 `hipify-clang`，可以设置环境变量 `$PATH`，该变量定义了查找二进制文件
    `hipify-clang` 的路径。'
- en: '[PRE63]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note that the rocm version we used is `rocm-6.0.3`.
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们使用的 ROCm 版本是 `rocm-6.0.3`。
- en: '**Step 4**: Running `hipify-clang` from inside the singularity container'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 4**：在 singularity 容器内部运行 `hipify-clang`'
- en: '[PRE64]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here the cuda path and the path to the `*includes*` and `*defines*` files should
    be specified. The CUDA source code and the generated output code are program.cu
    and hip_program.cu.hip, respectively.
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里应指定 cuda 路径以及 `*includes*` 和 `*defines*` 文件的路经。CUDA 源代码和生成的输出代码分别是 program.cu
    和 hip_program.cu.hip。
- en: The syntax for the compilation process of the generated hip code is similar
    to the one described in the previous section (see the **Step 3** in the hipify-perl
    section).
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成的 HIP 代码的编译过程语法与上一节中描述的类似（参见 hipify-perl 节的 **步骤 3**）。
- en: 'Code examples for the `Hipify` exercises can be accessed in the content/examples/exercise_hipify
    subdirectory by cloning this repository:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过克隆此存储库在内容目录下的 examples/exercise_hipify 子目录中访问 `Hipify` 练习的代码示例：
- en: '[PRE65]'
  id: totrans-456
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Exercise I : Translate an CUDA code to HIP with `hipify-perl`'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 I：使用 `hipify-perl` 将 CUDA 代码转换为 HIP
- en: 1.1 Generate the `hipify-perl` tool.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1 生成 `hipify-perl` 工具。
- en: 1.2 Convert the CUDA code `vec_add_cuda.cu` located in `/exercise_hipify/Hipify_perl`
    with the `Hipify-perl` tool to HIP.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2 使用 `Hipify-perl` 工具将位于 `/exercise_hipify/Hipify_perl` 的 CUDA 代码 `vec_add_cuda.cu`
    转换为 HIP。
- en: 1.3 Compile the generated HIP code with the `hipcc` compiler wrapper and run
    it.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3 使用 `hipcc` 编译器包装器编译生成的 HIP 代码并运行。
- en: 'Exercise II : Translate an CUDA code to HIP with `hipify-clang`'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 II：使用 `hipify-clang` 将 CUDA 代码转换为 HIP
- en: 2.1 Convert the CUDA code `vec_add_cuda.cu` located in `/exercise_hipify/Hipify_clang`
    with the `Hipify-clang` tool to HIP.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 2.1 使用 `Hipify-clang` 工具将位于 `/exercise_hipify/Hipify_clang` 的 CUDA 代码 `vec_add_cuda.cu`
    转换为 HIP。
- en: 2.2 Compile the generated HIP code with the `hipcc` compiler wrapper and run
    it.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 2.2 使用 `hipcc` 编译器包装器编译生成的 HIP 代码并运行它。
- en: Translating OpenACC to OpenMP with Clacc
  id: totrans-464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Clacc 将 OpenACC 转换为 OpenMP
- en: '[Clacc](https://github.com/llvm-doe-org/llvm-project/tree/clacc/main) is a
    tool to translate an OpenACC application to OpenMP offloading with the Clang/LLVM
    compiler environment. Note that the tool is specific to OpenACC C, while OpenACC
    Fortran is already supported on AMD GPU. As indicated in the [GitHub repository](https://github.com/llvm-doe-org/llvm-project/tree/clacc/main)
    the compiler `Clacc` is the `Clang`’s executable in the subdirectory `\bin` of
    the `\install` directory as described below.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '[Clacc](https://github.com/llvm-doe-org/llvm-project/tree/clacc/main) 是一个工具，可以将
    OpenACC 应用程序转换为使用 Clang/LLVM 编译器环境的 OpenMP 转发。请注意，该工具特定于 OpenACC C，而 OpenACC Fortran
    已经在 AMD GPU 上得到支持。如 [GitHub 存储库](https://github.com/llvm-doe-org/llvm-project/tree/clacc/main)
    中所示，编译器 `Clacc` 是 `\install` 目录下 `\bin` 子目录中的 `Clang` 可执行文件，如下所述。'
- en: 'In the following we present a step-by-step guide for building and using Clacc:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下内容中，我们提供了一个逐步指南，用于构建和使用 Clacc：
- en: '**Step 1**: Building and installing [Clacc](https://github.com/llvm-doe-org/llvm-project/tree/clacc/main).'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 1**：构建和安装 [Clacc](https://github.com/llvm-doe-org/llvm-project/tree/clacc/main)。'
- en: '[PRE66]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '**Step 2**: Setting up environment variables to be able to work from the `/install`
    directory, which is the simplest way. We assume that the `/install` directory
    is located in the path `/project/project_xxxxxx/Clacc/llvm-project`.'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 2**：设置环境变量，以便能够从 `/install` 目录工作，这是最简单的方法。我们假设 `/install` 目录位于路径 `/project/project_xxxxxx/Clacc/llvm-project`。'
- en: For more advanced usage, which includes for instance modifying `Clacc`, we refer
    readers to [“Usage from Build directory”](https://github.com/llvm-doe-org/llvm-project/blob/clacc/main/README.md)
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高级的使用，例如修改 `Clacc`，我们建议读者参考[“从构建目录使用”](https://github.com/llvm-doe-org/llvm-project/blob/clacc/main/README.md)。
- en: '[PRE67]'
  id: totrans-471
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '**Step 3**: Source to source conversion of the openACC_code.c code to be printed
    out to the file openMP_code.c:'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 3**：将 openACC_code.c 代码从源代码转换为要打印到 openMP_code.c 文件的代码：'
- en: '[PRE68]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Here the flag `-fopenacc-structured-ref-count-omp=no-ompx-hold` is introduced
    to disable the `ompx_hold` map type modifier, which is used by the OpenACC `copy`
    clause translation. The `ompx_hold` is an OpenMP extension that might not be supported
    yet by other compilers.
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里引入了标志 `-fopenacc-structured-ref-count-omp=no-ompx-hold` 来禁用 `ompx_hold` 映射类型修饰符，该修饰符用于
    OpenACC `copy` 子句的翻译。`ompx_hold` 是一个可能尚未被其他编译器支持的 OpenMP 扩展。
- en: '**Step 4** Compiling the code with the [cc compiler wrapper](https://docs.lumi-supercomputer.eu/development/compiling/prgenv/)'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 4** 使用 [cc 编译器包装器](https://docs.lumi-supercomputer.eu/development/compiling/prgenv/)
    编译代码'
- en: '[PRE69]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Access exercise material
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 访问练习材料
- en: 'Code examples for the `Clacc` exercise can be accessed in the content/examples/exercise_clacc
    subdirectory by cloning this repository:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在内容/示例/exercise_clacc 子目录中克隆此存储库来访问 `Clacc` 练习的代码示例：
- en: '[PRE70]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Exercise : Translate an OpenACC code to OpenMP'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：将 OpenACC 代码转换为 OpenMP
- en: Convert the OpenACC code `openACC_code.c` located in `/exercise_clacc` with
    the `Clacc` compiler.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Clacc` 编译器将位于 `/exercise_clacc` 的 OpenACC 代码 `openACC_code.c` 转换。
- en: Compile the generated OpenMP code with the `cc` compiler wrapper and run it.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cc` 编译器包装器编译生成的 OpenMP 代码并运行它。
- en: Translating CUDA to SYCL/DPC++ with SYCLomatic
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 SYCLomatic 将 CUDA 转换为 SYCL/DPC++
- en: Intel offers a tool for CUDA-to-SYCL code migration, included in the Intel oneAPI
    Basekit.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔提供了一种将 CUDA 转换为 SYCL 代码的工具，包含在 Intel oneAPI Basekit 中。
- en: 'It is not installed on LUMI, but the general workflow is similar to the HIPify
    Clang and also requires an existing CUDA installation:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有安装在 LUMI 上，但一般的工作流程与 HIPify Clang 类似，也要求有一个现有的 CUDA 安装：
- en: '[PRE71]'
  id: totrans-486
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE71]'
- en: SYCLomatic can migrate larger projects by using `-in-root` and `-out-root` flags
    to process directories recursively. It can also use compilation database (supported
    by CMake and other build systems) to deal with more complex project layouts.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: SYCLomatic 可以通过使用 `-in-root` 和 `-out-root` 标志递归地处理目录来迁移较大的项目。它还可以使用编译数据库（由 CMake
    和其他构建系统支持）来处理更复杂的项目布局。
- en: Please note that the code generated by SYCLomatic relies on oneAPI-specific
    extensions, and thus cannot be directly used with other SYCL implementations,
    such as AdaptiveCpp (hipSYCL). The `--no-incremental-migration` flag can be added
    to `dpct` command to minimize, but not completely avoid, the use of this compatibility
    layer. That would require manual effort, since some CUDA concepts cannot be directly
    mapped to SYCL.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由 SYCLomatic 生成的代码依赖于 oneAPI 特定扩展，因此不能直接与其他 SYCL 实现一起使用，例如 AdaptiveCpp (hipSYCL)。可以将
    `--no-incremental-migration` 标志添加到 `dpct` 命令中，以最小化，但不是完全避免使用此兼容层。这将需要手动工作，因为某些
    CUDA 概念不能直接映射到 SYCL。
- en: Additionally, CUDA applications might assume certain hardware behavior, such
    as 32-wide warps. If the target hardware is different (e.g., AMD MI250 GPUs, used
    in LUMI, have warp size of 64), the algorithms might need to be adjusted manually.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，CUDA 应用程序可能假设某些硬件行为，例如 32 宽的 warp。如果目标硬件不同（例如，LUMI 中使用的 AMD MI250 GPU，warp
    的大小为 64），算法可能需要手动调整。
- en: Conclusion
  id: totrans-490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: This concludes a brief overview of the usage of available tools to convert CUDA
    codes to HIP and SYCL, and OpenACC codes to OpenMP offloading. In general the
    translation process for large applications might be incomplete and thus requires
    manual modification to complete the porting process. It is however worth noting
    that the accuracy of the translation process requires that applications are written
    correctly according to the CUDA and OpenACC syntaxes.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 这总结了使用现有工具将 CUDA 代码转换为 HIP 和 SYCL，以及将 OpenACC 代码转换为 OpenMP 转发的简要概述。一般来说，大型应用程序的转换过程可能不完整，因此需要手动修改以完成迁移过程。然而，值得注意的是，转换过程的准确性要求应用程序根据
    CUDA 和 OpenACC 语法正确编写。
- en: See also
  id: totrans-492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Hipify GitHub](https://github.com/ROCm/HIPIFY)'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Hipify GitHub](https://github.com/ROCm/HIPIFY)'
- en: '[HIPify Reference Guide v5.1](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html)'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[HIPify 参考指南 v5.1](https://docs.amd.com/en-US/bundle/HIPify-Reference-Guide-v5.1/page/HIPify.html)'
- en: '[HIP example](https://github.com/olcf-tutorials/simple_HIP_examples/tree/master/vector_addition)'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[HIP 示例](https://github.com/olcf-tutorials/simple_HIP_examples/tree/master/vector_addition)'
- en: '[Porting CUDA to HIP](https://www.admin-magazine.com/HPC/Articles/Porting-CUDA-to-HIP)'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将 CUDA 迁移到 HIP](https://www.admin-magazine.com/HPC/Articles/Porting-CUDA-to-HIP)'
- en: '[Clacc Main repository README](https://github.com/llvm-doe-org/llvm-project/blob/clacc/main/README.md)'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Clacc 主仓库 README](https://github.com/llvm-doe-org/llvm-project/blob/clacc/main/README.md)'
- en: '[SYCLomatic main mage](https://www.intel.com/content/www/us/en/developer/articles/technical/syclomatic-new-cuda-to-sycl-code-migration-tool.html)'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SYCLomatic 主页](https://www.intel.com/content/www/us/en/developer/articles/technical/syclomatic-new-cuda-to-sycl-code-migration-tool.html)'
- en: '[SYCLomatic documentation](https://oneapi-src.github.io/SYCLomatic/get_started/index.html)'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SYCLomatic 文档](https://oneapi-src.github.io/SYCLomatic/get_started/index.html)'
- en: Keypoints
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点
- en: Useful tools exist to automatically translate tools from CUDA to HIP and SYCL
    and from OpenACC to OpenMP, but they may require manual modifications.*
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在着一些有用的工具，可以自动将工具从 CUDA 转换为 HIP 和 SYCL，以及从 OpenACC 转换为 OpenMP，但它们可能需要手动修改*。
