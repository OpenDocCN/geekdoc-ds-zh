- en: 7\. Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 结构
- en: 原文：[https://leanprover-community.github.io/mathematics_in_lean/C07_Structures.html](https://leanprover-community.github.io/mathematics_in_lean/C07_Structures.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://leanprover-community.github.io/mathematics_in_lean/C07_Structures.html](https://leanprover-community.github.io/mathematics_in_lean/C07_Structures.html)
- en: '*[Mathematics in Lean](index.html)* **   7\. Structures'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*[Lean中的数学](index.html)* **   7. 结构'
- en: '[View page source](_sources/C07_Structures.rst.txt)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[查看页面源代码](_sources/C07_Structures.rst.txt)'
- en: '* * *'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Modern mathematics makes essential use of algebraic structures, which encapsulate
    patterns that can be instantiated in multiple settings. The subject provides various
    ways of defining such structures and constructing particular instances.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现代数学在本质上是使用代数结构，这些结构封装了可以在多个设置中实例化的模式。该主题提供了定义此类结构及其特定实例的多种方法。
- en: Lean therefore provides corresponding ways of defining structures formally and
    working with them. You have already seen examples of algebraic structures in Lean,
    such as rings and lattices, which were discussed in [Chapter 2](C02_Basics.html#basics).
    This chapter will explain the mysterious square bracket annotations that you saw
    there, `[Ring α]` and `[Lattice α]`. It will also show you how to define and use
    algebraic structures on your own.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Lean提供了定义结构及其操作的形式化方法。您已经看到了Lean中代数结构的例子，例如环和格，这些在[第2章](C02_Basics.html#basics)中讨论过。本章将解释您在那里看到的神秘方括号注解，`[Ring
    α]`和`[Lattice α]`。它还将向您展示如何定义和使用您自己的代数结构。
- en: For more technical detail, you can consult [Theorem Proving in Lean](https://leanprover.github.io/theorem_proving_in_lean/),
    and a paper by Anne Baanen, [Use and abuse of instance parameters in the Lean
    mathematical library](https://arxiv.org/abs/2202.01629).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更详细的技术信息，您可以查阅[Lean中的定理证明](https://leanprover.github.io/theorem_proving_in_lean/)，以及安妮·巴恩的一篇论文，[在Lean数学库中使用和滥用实例参数](https://arxiv.org/abs/2202.01629)。
- en: '## 7.1\. Defining structures[](#defining-structures "Link to this heading")'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '## 7.1. 定义结构[](#defining-structures "链接到本标题")'
- en: 'In the broadest sense of the term, a *structure* is a specification of a collection
    of data, possibly with constraints that the data is required to satisfy. An *instance*
    of the structure is a particular bundle of data satisfying the constraints. For
    example, we can specify that a point is a tuple of three real numbers:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在术语的最广泛意义上，*结构*是一组数据的规范，可能包含数据必须满足的约束。结构的*实例*是满足这些约束的特定数据包。例如，我们可以指定一个点是一组三个实数的元组：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `@[ext]` annotation tells Lean to automatically generate theorems that can
    be used to prove that two instances of a structure are equal when their components
    are equal, a property known as *extensionality*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`@[ext]`注解告诉Lean自动生成定理，这些定理可以用来证明当结构的组件相等时，两个结构实例是相等的，这种性质称为*扩展性*。'
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can then define particular instances of the `Point` structure. Lean provides
    multiple ways of doing that.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以定义`Point`结构的特定实例。Lean提供了多种实现方式。
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the first example, the fields of the structure are named explicitly. The
    function `Point.mk` referred to in the definition of `myPoint3` is known as the
    *constructor* for the `Point` structure, because it serves to construct elements.
    You can specify a different name if you want, like `build`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，结构的字段被明确命名。在`myPoint3`的定义中提到的`Point.mk`函数被称为`Point`结构的*构造函数*，因为它用于构建元素。如果您想，也可以指定不同的名称，比如`build`。
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The next two examples show how to define functions on structures. Whereas the
    second example makes the `Point.mk` constructor explicit, the first example uses
    an anonymous constructor for brevity. Lean can infer the relevant constructor
    from the indicated type of `add`. It is conventional to put definitions and theorems
    associated with a structure like `Point` in a namespace with the same name. In
    the example below, because we have opened the `Point` namespace, the full name
    of `add` is `Point.add`. When the namespace is not open, we have to use the full
    name. But remember that it is often convenient to use anonymous projection notation,
    which allows us to write `a.add b` instead of `Point.add a b`. Lean interprets
    the former as the latter because `a` has type `Point`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两个例子展示了如何在结构上定义函数。第二个例子使`Point.mk`构造函数显式化，而第一个例子为了简洁使用了匿名构造函数。Lean可以从`add`指示的类型推断出相关的构造函数。将定义和与`Point`这样的结构相关的定理放在具有相同名称的命名空间中是一种惯例。在下面的例子中，因为我们已经打开了`Point`命名空间，所以`add`的全称是`Point.add`。当命名空间未打开时，我们必须使用全称。但请记住，使用匿名投影符号通常很方便，它允许我们写出`a.add
    b`而不是`Point.add a b`。因为`a`具有`Point`类型，Lean将前者解释为后者。
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Below we will continue to put definitions in the relevant namespace, but we
    will leave the namespacing commands out of the quoted snippets. To prove properties
    of the addition function, we can use `rw` to expand the definition and `ext` to
    reduce an equation between two elements of the structure to equations between
    the components. Below we use the `protected` keyword so that the name of the theorem
    is `Point.add_comm`, even when the namespace is open. This is helpful when we
    want to avoid ambiguity with a generic theorem like `add_comm`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下面我们将继续在相关命名空间中放置定义，但我们将省略引用片段中的命名空间命令。为了证明加法函数的性质，我们可以使用`rw`来展开定义，并使用`ext`将结构中两个元素之间的等式简化为分量之间的等式。下面我们使用`protected`关键字，即使命名空间已打开，定理的名称也是`Point.add_comm`。这在我们想要避免与像`add_comm`这样的通用定理产生歧义时很有帮助。
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Because Lean can unfold definitions and simplify projections internally, sometimes
    the equations we want hold definitionally.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Lean可以内部展开定义和简化投影，有时我们想要的等式在语义上是成立的。
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is also possible to define functions on structures using pattern matching,
    in a manner similar to the way we defined recursive functions in [Section 5.2](C05_Elementary_Number_Theory.html#section-induction-and-recursion).
    The definitions `addAlt` and `addAlt'` below are essentially the same; the only
    difference is that we use anonymous constructor notation in the second. Although
    it is sometimes convenient to define functions this way, and structural eta-reduction
    makes this alternative definitionally equivalent, it can make things less convenient
    in later proofs. In particular, `rw [addAlt]` leaves us with a messier goal view
    containing a `match` statement.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用模式匹配在结构上定义函数，方式类似于我们在[第5.2节](C05_Elementary_Number_Theory.html#section-induction-and-recursion)中定义递归函数的方式。下面的`addAlt`和`addAlt'`定义基本上是相同的；唯一的区别是我们第二个定义中使用了匿名构造函数符号。虽然有时以这种方式定义函数很方便，结构eta-归约使这种替代定义在语义上等价，但它可能在后续的证明中使事情变得不那么方便。特别是，`rw
    [addAlt]`会给我们留下一个包含`match`语句的更混乱的目标视图。
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Mathematical constructions often involve taking apart bundled information and
    putting it together again in different ways. It therefore makes sense that Lean
    and Mathlib offer so many ways of doing this efficiently. As an exercise, try
    proving that `Point.add` is associative. Then define scalar multiplication for
    a point and show that it distributes over addition.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数学构造通常涉及将捆绑的信息拆分开来，并以不同的方式重新组合。因此，Lean和Mathlib提供如此多的方法来高效地完成这项任务是有意义的。作为练习，尝试证明`Point.add`是结合的。然后定义点的标量乘法，并证明它对加法分配。
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using structures is only the first step on the road to algebraic abstraction.
    We don’t yet have a way to link `Point.add` to the generic `+` symbol, or to connect
    `Point.add_comm` and `Point.add_assoc` to the generic `add_comm` and `add_assoc`
    theorems. These tasks belong to the *algebraic* aspect of using structures, and
    we will explain how to carry them out in the next section. For now, just think
    of a structure as a way of bundling together objects and information.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用结构只是通往代数抽象道路上的第一步。我们还没有将`Point.add`链接到通用`+`符号的方法，或者将`Point.add_comm`和`Point.add_assoc`连接到通用的`add_comm`和`add_assoc`定理。这些任务属于使用结构的*代数*方面，我们将在下一节中解释如何执行它们。现在，只需将结构视为一种将对象和信息捆绑在一起的方式。
- en: 'It is especially useful that a structure can specify not only data types but
    also constraints that the data must satisfy. In Lean, the latter are represented
    as fields of type `Prop`. For example, the *standard 2-simplex* is defined to
    be the set of points \((x, y, z)\) satisfying \(x ≥ 0\), \(y ≥ 0\), \(z ≥ 0\),
    and \(x + y + z = 1\). If you are not familiar with the notion, you should draw
    a picture, and convince yourself that this set is the equilateral triangle in
    three-space with vertices \((1, 0, 0)\), \((0, 1, 0)\), and \((0, 0, 1)\), together
    with its interior. We can represent it in Lean as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 特别有用的是，结构不仅可以指定数据类型，还可以指定数据必须满足的约束。在Lean中，后者表示为类型`Prop`的字段。例如，*标准2-单纯形*被定义为满足\(x
    ≥ 0\)、\(y ≥ 0\)、\(z ≥ 0\)和\(x + y + z = 1\)的点集\((x, y, z)\)。如果你不熟悉这个概念，你应该画一个图，并说服自己这个集合是三维空间中的等边三角形，其顶点为\((1,
    0, 0)\)、\((0, 1, 0)\)和\((0, 0, 1)\)，以及其内部。我们可以在Lean中表示如下：
- en: '[PRE9]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice that the last four fields refer to `x`, `y`, and `z`, that is, the first
    three fields. We can define a map from the two-simplex to itself that swaps `x`
    and `y`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到最后四个字段指的是`x`、`y`和`z`，即前三个字段。我们可以定义一个从二单纯形到自身的映射，该映射交换`x`和`y`：
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: More interestingly, we can compute the midpoint of two points on the simplex.
    We have added the phrase `noncomputable section` at the beginning of this file
    in order to use division on the real numbers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，我们可以计算单纯形上两点之间的中点。我们在文件开头添加了`noncomputable section`短语，以便在实数上使用除法。
- en: '[PRE11]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here we have established `x_nonneg`, `y_nonneg`, and `z_nonneg` with concise
    proof terms, but establish `sum_eq` in tactic mode, using `by`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们用简洁的证明术语建立了`x_nonneg`、`y_nonneg`和`z_nonneg`，但在战术模式下使用`by`来建立`sum_eq`。
- en: Given a parameter \(\lambda\) satisfying \(0 \le \lambda \le 1\), we can take
    the weighted average \(\lambda a + (1 - \lambda) b\) of two points \(a\) and \(b\)
    in the standard 2-simplex. We challenge you to define that function, in analogy
    to the `midpoint` function above.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个满足\(0 \le \lambda \le 1\)的参数\(\lambda\)，我们可以取标准2-单纯形上两点\(a\)和\(b\)的加权平均值\(\lambda
    a + (1 - \lambda) b\)。我们挑战你定义这个函数，类似于上面的`midpoint`函数。
- en: '[PRE12]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Structures can depend on parameters. For example, we can generalize the standard
    2-simplex to the standard \(n\)-simplex for any \(n\). At this stage, you don’t
    have to know anything about the type `Fin n` except that it has \(n\) elements,
    and that Lean knows how to sum over it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 结构可以依赖于参数。例如，我们可以将标准的2-单纯形推广到任何\(n\)的标准\(n\)-单纯形。在这个阶段，你不必了解类型`Fin n`的任何东西，除了它有\(n\)个元素，以及Lean知道如何对其求和。
- en: '[PRE13]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As an exercise, see if you can define the weighted average of two points in
    the standard \(n\)-simplex. You can use `Finset.sum_add_distrib` and `Finset.mul_sum`
    to manipulate the relevant sums.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，看看你是否可以定义标准\(n\)-单纯形上两点的加权平均值。你可以使用`Finset.sum_add_distrib`和`Finset.mul_sum`来操作相关的和。
- en: We have seen that structures can be used to bundle together data and properties.
    Interestingly, they can also be used to bundle together properties without the
    data. For example, the next structure, `IsLinear`, bundles together the two components
    of linearity.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，结构可以被用来捆绑数据和属性。有趣的是，它们也可以用来捆绑属性而不包含数据。例如，下一个结构`IsLinear`捆绑了线性的两个组成部分。
- en: '[PRE14]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It is worth pointing out that structures are not the only way to bundle together
    data. The `Point` data structure can be defined using the generic type product,
    and `IsLinear` can be defined with a simple `and`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，结构并不是捆绑数据的唯一方式。`Point`数据结构可以使用通用类型积来定义，而`IsLinear`可以用简单的`and`来定义。
- en: '[PRE15]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Generic type constructions can even be used in place of structures with dependencies
    between their components. For example, the *subtype* construction combines a piece
    of data with a property. You can think of the type `PReal` in the next example
    as being the type of positive real numbers. Any `x : PReal` has two components:
    the value, and the property of being positive. You can access these components
    as `x.val`, which has type `ℝ`, and `x.property`, which represents the fact `0
    < x.val`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '通用类型构造甚至可以用作具有组件之间依赖的结构。例如，*子类型*构造将数据与属性结合起来。你可以将下一个示例中的类型`PReal`视为正实数的类型。任何`x
    : PReal`都有两个组成部分：值和正属性。你可以通过`x.val`访问这些组件，它具有类型`ℝ`，以及`x.property`，它代表`0 < x.val`这一事实。'
- en: '[PRE16]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We could have used subtypes to define the standard 2-simplex, as well as the
    standard \(n\)-simplex for an arbitrary \(n\).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用子类型来定义标准的2-单纯形，以及任意\(n\)的标准的\(n\)-单纯形。
- en: '[PRE17]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Similarly, *Sigma types* are generalizations of ordered pairs, whereby the type
    of the second component depends on the type of the first.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，*Sigma类型* 是有序对的推广，其中第二个组件的类型取决于第一个组件的类型。
- en: '[PRE18]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Given `s : StdSimplex`, the first component `s.fst` is a natural number, and
    the second component is an element of the corresponding simplex `StandardSimplex
    s.fst`. The difference between a Sigma type and a subtype is that the second component
    of a Sigma type is data rather than a proposition.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '给定 `s : StdSimplex`，第一个组件 `s.fst` 是一个自然数，第二个组件是相应单纯形 `StandardSimplex s.fst`
    的一个元素。Sigma类型与子类型之间的区别在于，Sigma类型的第二个组件是数据而不是命题。'
- en: 'But even though we can use products, subtypes, and Sigma types instead of structures,
    using structures has a number of advantages. Defining a structure abstracts away
    the underlying representation and provides custom names for the functions that
    access the components. This makes proofs more robust: proofs that rely only on
    the interface to a structure will generally continue to work when we change the
    definition, as long as we redefine the old accessors in terms of the new definition.
    Moreover, as we are about to see, Lean provides support for weaving structures
    together into a rich, interconnected hierarchy, and for managing the interactions
    between them.  ## 7.2\. Algebraic Structures[](#algebraic-structures "Link to
    this heading")'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以使用产品、子类型和Sigma类型来代替结构体，但使用结构体仍然具有许多优点。定义一个结构体会抽象出底层表示，并为访问组件的函数提供自定义名称。这使得证明更加健壮：仅依赖于结构体接口的证明，在定义更改时通常仍然有效，只要我们用新的定义重新定义旧的访问器。此外，正如我们即将看到的，Lean提供了将结构体编织成丰富、相互关联的层次结构以及管理它们之间交互的支持。##
    7.2\. 代数结构[](#algebraic-structures "链接到这个标题")
- en: To clarify what we mean by the phrase *algebraic structure*, it will help to
    consider some examples.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阐明我们所说的“代数结构”的含义，考虑一些例子会有所帮助。
- en: A *partially ordered set* consists of a set \(P\) and a binary relation \(\le\)
    on \(P\) that is transitive and reflexive.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 *部分有序集* 由一个集合 \(P\) 和一个在 \(P\) 上的二元关系 \(\le\) 组成，该关系是传递的和自反的。
- en: A *group* consists of a set \(G\) with an associative binary operation, an identity
    element \(1\), and a function \(g \mapsto g^{-1}\) that returns an inverse for
    each \(g\) in \(G\). A group is *abelian* or *commutative* if the operation is
    commutative.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 *群* 由一个集合 \(G\) 和一个结合的二元运算、一个单位元素 \(1\) 以及一个函数 \(g \mapsto g^{-1}\)，该函数为
    \(G\) 中的每个 \(g\) 返回一个逆元素组成。如果一个群的操作是交换的，则该群是 *阿贝尔群* 或 *交换群*。
- en: A *lattice* is a partially ordered set with meets and joins.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 *格* 是一个具有交集和并集的部分有序集。
- en: A *ring* consists of an (additively written) abelian group \((R, +, 0, x \mapsto
    -x)\) together with an associative multiplication operation \(\cdot\) and an identity
    \(1\), such that multiplication distributes over addition. A ring is *commutative*
    if the multiplication is commutative.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 *环* 由一个（加法表示的）阿贝尔群 \((R, +, 0, x \mapsto -x)\) 和一个结合乘法运算 \(\cdot\) 以及一个单位
    \(1\) 组成，使得乘法对加法分配。如果一个环的乘法是交换的，则该环是 *交换环*。
- en: An *ordered ring* \((R, +, 0, -, \cdot, 1, \le)\) consists of a ring together
    with a partial order on its elements, such that \(a \le b\) implies \(a + c \le
    b + c\) for every \(a\), \(b\), and \(c\) in \(R\), and \(0 \le a\) and \(0 \le
    b\) implies \(0 \le a b\) for every \(a\) and \(b\) in \(R\).
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 *有序环* \((R, +, 0, -, \cdot, 1, \le)\) 由一个环及其元素上的部分序组成，使得对于 \(R\) 中的每个 \(a\)、\(b\)
    和 \(c\)，\(a \le b\) 蕴含 \(a + c \le b + c\)，并且 \(0 \le a\) 和 \(0 \le b\) 蕴含 \(0
    \le a b\) 对于 \(R\) 中的每个 \(a\) 和 \(b\) 成立。
- en: 'A *metric space* consists of a set \(X\) and a function \(d : X \times X \to
    \mathbb{R}\) such that the following hold:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '一个 *度量空间* 由一个集合 \(X\) 和一个函数 \(d : X \times X \to \mathbb{R}\) 组成，使得以下条件成立：'
- en: \(d(x, y) \ge 0\) for every \(x\) and \(y\) in \(X\).
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 \(X\) 中的每个 \(x\) 和 \(y\)，有 \(d(x, y) \ge 0\)。
- en: \(d(x, y) = 0\) if and only if \(x = y\).
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果且仅当 \(x = y\) 时，\(d(x, y) = 0\)。
- en: \(d(x, y) = d(y, x)\) for every \(x\) and \(y\) in \(X\).
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 \(X\) 中的每个 \(x\) 和 \(y\)，有 \(d(x, y) = d(y, x)\)。
- en: \(d(x, z) \le d(x, y) + d(y, z)\) for every \(x\), \(y\), and \(z\) in \(X\).
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 \(X\) 中的每个 \(x\)、\(y\) 和 \(z\)，有 \(d(x, z) \le d(x, y) + d(y, z)\)。
- en: 'A *topological space* consists of a set \(X\) and a collection \(\mathcal T\)
    of subsets of \(X\), called the *open subsets of* \(X\), such that the following
    hold:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 *拓扑空间* 由一个集合 \(X\) 和一个集合 \(\mathcal T\) 的子集组成，称为 \(X\) 的 *开子集*，使得以下条件成立：
- en: The empty set and \(X\) are open.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空集和 \(X\) 是开集。
- en: The intersection of two open sets is open.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个开集的交集是开集。
- en: An arbitrary union of open sets is open.
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开集的任意并集是开集。
- en: In each of these examples, the elements of the structure belong to a set, the
    *carrier set*, that sometimes stands proxy for the entire structure. For example,
    when we say “let \(G\) be a group” and then “let \(g \in G\),” we are using \(G\)
    to stand for both the structure and its carrier. Not every algebraic structure
    is associated with a single carrier set in this way. For example, a *bipartite
    graph* involves a relation between two sets, as does a *Galois connection*, A
    *category* also involves two sets of interest, commonly called the *objects* and
    the *morphisms*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些例子中，结构的元素属于一个集合，称为*载体集*，有时它代表整个结构。例如，当我们说“设\(G\)为一个群”然后“设\(g \in G\)”时，我们使用\(G\)来代表结构和它的载体。并非每个代数结构都以这种方式与单个载体集相关联。例如，一个*二部图*涉及两个集合之间的关系，正如*伽罗瓦连接*一样，一个*范畴*也涉及两个感兴趣的集合，通常称为*对象*和*态射*。
- en: The examples indicate some of the things that a proof assistant has to do in
    order to support algebraic reasoning. First, it needs to recognize concrete instances
    of structures. The number systems \(\mathbb{Z}\), \(\mathbb{Q}\), and \(\mathbb{R}\)
    are all ordered rings, and we should be able to apply a generic theorem about
    ordered rings in any of these instances. Sometimes a concrete set may be an instance
    of a structure in more than one way. For example, in addition to the usual topology
    on \(\mathbb{R}\), which forms the basis for real analysis, we can also consider
    the *discrete* topology on \(\mathbb{R}\), in which every set is open.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子表明了证明辅助工具为了支持代数推理必须执行的一些事情。首先，它需要识别结构的具体实例。数系\(\mathbb{Z}\)、\(\mathbb{Q}\)和\(\mathbb{R}\)都是有序环，我们应该能够在这些实例中的任何一个上应用关于有序环的通用定理。有时一个具体集合可能以多种方式成为结构的实例。例如，除了\(\mathbb{R}\)上的常规拓扑，它是实分析的基础之外，我们还可以考虑\(\mathbb{R}\)上的*离散*拓扑，其中每个集合都是开集。
- en: Second, a proof assistant needs to support generic notation on structures. In
    Lean, the notation `*` is used for multiplication in all the usual number systems,
    as well as for multiplication in generic groups and rings. When we use an expression
    like `f x * y`, Lean has to use information about the types of `f`, `x`, and `y`
    to determine which multiplication we have in mind.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，证明辅助工具需要支持结构上的通用符号。在Lean中，符号`*`用于所有常规数系中的乘法，以及用于通用群和环中的乘法。当我们使用表达式`f x *
    y`时，Lean必须使用关于`f`、`x`和`y`类型的知识来确定我们心中的乘法是哪一种。
- en: Third, it needs to deal with the fact that structures can inherit definitions,
    theorems, and notation from other structures in various ways. Some structures
    extend others by adding more axioms. A commutative ring is still a ring, so any
    definition that makes sense in a ring also makes sense in a commutative ring,
    and any theorem that holds in a ring also holds in a commutative ring. Some structures
    extend others by adding more data. For example, the additive part of any ring
    is an additive group. The ring structure adds a multiplication and an identity,
    as well as axioms that govern them and relate them to the additive part. Sometimes
    we can define one structure in terms of another. Any metric space has a canonical
    topology associated with it, the *metric space topology*, and there are various
    topologies that can be associated with any linear ordering.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，它需要处理结构可以通过各种方式从其他结构继承定义、定理和符号的事实。一些结构通过添加更多的公理来扩展其他结构。交换环仍然是环，所以任何在环中有意义的定义在交换环中也有意义，任何在环中成立的定理在交换环中也成立。一些结构通过添加更多数据来扩展其他结构。例如，任何环的加法部分是一个加法群。环结构添加了乘法和单位元，以及规范这些乘法和将它们与加法部分相关联的公理。有时我们可以用另一个结构来定义一个结构。任何度量空间都有一个与之相关的典型拓扑，即*度量空间拓扑*，还有可以与任何线性序相关联的各种拓扑。
- en: Finally, it is important to keep in mind that mathematics allows us to use functions
    and operations to define structures in the same way we use functions and operations
    to define numbers. Products and powers of groups are again groups. For every \(n\),
    the integers modulo \(n\) form a ring, and for every \(k > 0\), the \(k \times
    k\) matrices of polynomials with coefficients in that ring again form a ring.
    Thus we can calculate with structures just as easily as we can calculate with
    their elements. This means that algebraic structures lead dual lives in mathematics,
    as containers for collections of objects and as objects in their own right. A
    proof assistant has to accommodate this dual role.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，重要的是要记住，数学允许我们使用函数和运算来定义结构，就像我们使用函数和运算来定义数字一样。群的积和幂仍然是群。对于每一个 \(n\)，模 \(n\)
    的整数构成一个环，而对于每一个 \(k > 0\)，具有该环系数的多项式 \(k \times k\) 矩阵再次构成一个环。因此，我们可以像计算它们的元素一样容易地计算结构。这意味着代数结构在数学中具有双重生活，既是对象集合的容器，也是它们自身的对象。证明辅助工具必须适应这种双重角色。
- en: When dealing with elements of a type that has an algebraic structure associated
    with it, a proof assistant needs to recognize the structure and find the relevant
    definitions, theorems, and notation. All this should sound like a lot of work,
    and it is. But Lean uses a small collection of fundamental mechanisms to carry
    out these tasks. The goal of this section is to explain these mechanisms and show
    you how to use them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理与具有代数结构关联的类型元素时，证明辅助工具需要识别该结构并找到相关的定义、定理和符号。所有这些听起来像是一大堆工作，确实如此。但 Lean 使用一组基本的机制来完成这些任务。本节的目标是解释这些机制并展示如何使用它们。
- en: 'The first ingredient is almost too obvious to mention: formally speaking, algebraic
    structures are structures in the sense of [Section 7.1](#section-structures).
    An algebraic structure is a specification of a bundle of data satisfying some
    axiomatic hypotheses, and we saw in [Section 7.1](#section-structures) that this
    is exactly what the `structure` command is designed to accommodate. It’s a marriage
    made in heaven!'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个要素几乎是显而易见的：从形式上讲，代数结构是 [第 7.1 节](#section-structures) 中的结构。一个代数结构是一组满足某些公理假设的数据的规范，我们在
    [第 7.1 节](#section-structures) 中看到，这正是 `structure` 命令设计用来适应的。这是一场天作之合！
- en: Given a data type `α`, we can define the group structure on `α` as follows.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个数据类型 `α`，我们可以如下定义 `α` 上的群结构。
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Notice that the type `α` is a *parameter* in the definition of `Group₁`. So
    you should think of an object `struc : Group₁ α` as being a group structure on
    `α`. We saw in [Section 2.2](C02_Basics.html#proving-identities-in-algebraic-structures)
    that the counterpart `mul_inv_cancel` to `inv_mul_cancel` follows from the other
    group axioms, so there is no need to add it to the definition.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '注意到类型 `α` 是 `Group₁` 定义中的一个 *参数*。因此，你应该将对象 `struc : Group₁ α` 视为 `α` 上的群结构。我们在
    [第 2.2 节](C02_Basics.html#proving-identities-in-algebraic-structures) 中看到，`inv_mul_cancel`
    的对应物 `mul_inv_cancel` 是从其他群公理中得出的，因此没有必要将其添加到定义中。'
- en: This definition of a group is similar to the definition of `Group` in Mathlib,
    and we have chosen the name `Group₁` to distinguish our version. If you write
    `#check Group` and ctrl-click on the definition, you will see that the Mathlib
    version of `Group` is defined to extend another structure; we will explain how
    to do that later. If you type `#print Group` you will also see that the Mathlib
    version of `Group` has a number of extra fields. For reasons we will explain later,
    sometimes it is useful to add redundant information to a structure, so that there
    are additional fields for objects and functions that can be defined from the core
    data. Don’t worry about that for now. Rest assured that our simplified version
    `Group₁` is morally the same as the definition of a group that Mathlib uses.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个群的定义与 Mathlib 中 `Group` 的定义相似，我们选择了 `Group₁` 这个名字来区分我们的版本。如果你输入 `#check Group`
    并使用 Ctrl 点击定义，你会看到 Mathlib 版本的 `Group` 被定义为扩展另一个结构；我们将在稍后解释如何做到这一点。如果你输入 `#print
    Group`，你也会看到 Mathlib 版本的 `Group` 有许多额外的字段。由于我们将解释的原因，有时在结构中添加冗余信息是有用的，这样就可以为从核心数据定义的对象和函数提供额外的字段。现在不用担心这一点。请放心，我们的简化版本
    `Group₁` 在道德上是与 Mathlib 使用的群定义相同的。
- en: 'It is sometimes useful to bundle the type together with the structure, and
    Mathlib also contains a definition of a `Grp` structure that is equivalent to
    the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有时将类型与其结构捆绑在一起是有用的，Mathlib 也包含了一个与以下内容等价的 `Grp` 结构定义：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The Mathlib version is found in `Mathlib.Algebra.Category.Grp.Basic`, and you
    can `#check` it if you add this to the imports at the beginning of the examples
    file.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib 版本位于 `Mathlib.Algebra.Category.Grp.Basic` 中，如果您将此添加到示例文件开头的导入中，则可以 `#check`
    它。
- en: For reasons that will become clearer below, it is more often useful to keep
    the type `α` separate from the structure `Group α`. We refer to the two objects
    together as a *partially bundled structure*, since the representation combines
    most, but not all, of the components into one structure. It is common in Mathlib
    to use capital roman letters like `G` for a type when it is used as the carrier
    type for a group.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于以下原因将变得更为清晰，通常更有用将类型 `α` 与结构 `Group α` 分开。我们将这两个对象合称为 *部分捆绑结构*，因为表示结合了大多数但不是所有组件到一个结构中。在
    Mathlib 中，当它用作群的同构类型时，通常使用大写罗马字母如 `G` 表示类型。
- en: 'Let’s construct a group, which is to say, an element of the `Group₁` type.
    For any pair of types `α` and `β`, Mathlib defines the type `Equiv α β` of *equivalences*
    between `α` and `β`. Mathlib also defines the suggestive notation `α ≃ β` for
    this type. An element `f : α ≃ β` is a bijection between `α` and `β` represented
    by four components: a function `f.toFun` from `α` to `β`, the inverse function
    `f.invFun` from `β` to `α`, and two properties that specify these functions are
    indeed inverse to one another.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们构建一个群，也就是说，`Group₁` 类型的元素。对于任何一对类型 `α` 和 `β`，Mathlib 定义了 `α` 和 `β` 之间的 *等价*
    类型 `Equiv α β`。Mathlib 还为这个类型定义了有启发性的符号 `α ≃ β`。元素 `f : α ≃ β` 是 `α` 和 `β` 之间的双射，由四个组件表示：从
    `α` 到 `β` 的函数 `f.toFun`，从 `β` 到 `α` 的逆函数 `f.invFun`，以及两个指定这些函数确实是彼此的逆的性质。'
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice the creative naming of the last three constructions. We think of the
    identity function `Equiv.refl`, the inverse operation `Equiv.symm`, and the composition
    operation `Equiv.trans` as explicit evidence that the property of being in bijective
    correspondence is an equivalence relation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后三个构造的命名非常具有创意。我们认为恒等函数 `Equiv.refl`、逆操作 `Equiv.symm` 和组合操作 `Equiv.trans`
    是显式证据，表明属于双射对应关系的性质是一个等价关系。
- en: Notice also that `f.trans g` requires composing the forward functions in reverse
    order. Mathlib has declared a *coercion* from `Equiv α β` to the function type
    `α → β`, so we can omit writing `.toFun` and have Lean insert it for us.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`f.trans g` 需要按逆序组合前向函数。Mathlib 已经声明了一个从 `Equiv α β` 到函数类型 `α → β` 的 *强制转换*，因此我们可以省略写入
    `.toFun`，由 Lean 为我们插入。
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Mathlib also defines the type `perm α` of equivalences between `α` and itself.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib 还定义了 `perm α` 类型，它是 `α` 与自身之间的等价关系类型。
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It should be clear that `Equiv.Perm α` forms a group under composition of equivalences.
    We orient things so that `mul f g` is equal to `g.trans f`, whose forward function
    is `f ∘ g`. In other words, multiplication is what we ordinarily think of as composition
    of the bijections. Here we define this group:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 应该很明显，`Equiv.Perm α` 在等价关系的组合下形成一个群。我们这样安排，使得 `mul f g` 等于 `g.trans f`，其前向函数是
    `f ∘ g`。换句话说，乘法就是我们通常认为的双射的组合。我们在这里定义这个群：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In fact, Mathlib defines exactly this `Group` structure on `Equiv.Perm α` in
    the file `Algebra.Group.End`. As always, you can hover over the theorems used
    in the definition of `permGroup` to see their statements, and you can jump to
    their definitions in the original file to learn more about how they are implemented.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Mathlib 在 `Algebra.Group.End` 文件中精确地定义了 `Equiv.Perm α` 上的这个 `Group` 结构。一如既往，您可以在
    `permGroup` 定义中悬停查看使用的定理以查看它们的陈述，并且您可以跳转到原始文件中的定义以了解更多关于它们是如何实现的。
- en: In ordinary mathematics, we generally think of notation as independent of structure.
    For example, we can consider groups \((G_1, \cdot, 1, \cdot^{-1})\), \((G_2, \circ,
    e, i(\cdot))\), and \((G_3, +, 0, -)\). In the first case, we write the binary
    operation as \(\cdot\), the identity as \(1\), and the inverse function as \(x
    \mapsto x^{-1}\). In the second and third cases, we use the notational alternatives
    shown. When we formalize the notion of a group in Lean, however, the notation
    is more tightly linked to the structure. In Lean, the components of any `Group`
    are named `mul`, `one`, and `inv`, and in a moment we will see how multiplicative
    notation is set up to refer to them. If we want to use additive notation, we instead
    use an isomorphic structure `AddGroup` (the structure underlying additive groups).
    Its components are named `add`, `zero`, and `neg`, and the associated notation
    is what you would expect it to be.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在普通数学中，我们通常认为符号与结构是独立的。例如，我们可以考虑群 \((G_1, \cdot, 1, \cdot^{-1})\)、\((G_2, \circ,
    e, i(\cdot))\) 和 \((G_3, +, 0, -)\)。在第一种情况下，我们用 \(\cdot\) 写二元运算，用 \(1\) 写单位元，用
    \(x \mapsto x^{-1}\) 写逆函数。在第二种和第三种情况下，我们使用显示的符号替代。然而，当我们形式化 Lean 中的群概念时，符号与结构联系得更紧密。在
    Lean 中，任何 `Group` 的组件被命名为 `mul`、`one` 和 `inv`，我们很快就会看到乘法符号是如何设置来引用它们的。如果我们想使用加法符号，我们则使用同构结构
    `AddGroup`（加法群的底层结构）。它的组件被命名为 `add`、`zero` 和 `neg`，相关的符号正是你所期望的。
- en: Recall the type `Point` that we defined in [Section 7.1](#section-structures),
    and the addition function that we defined there. These definitions are reproduced
    in the examples file that accompanies this section. As an exercise, define an
    `AddGroup₁` structure that is similar to the `Group₁` structure we defined above,
    except that it uses the additive naming scheme just described. Define negation
    and a zero on the `Point` data type, and define the `AddGroup₁` structure on `Point`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在 [第 7.1 节](#section-structures) 中定义的 `Point` 类型以及我们那里定义的加法函数。这些定义在伴随本节的示例文件中重现。作为一个练习，定义一个类似于我们上面定义的
    `Group₁` 结构的 `AddGroup₁` 结构，除了它使用前面描述的加法命名方案。在 `Point` 数据类型上定义否定和零，并在 `Point`
    上定义 `AddGroup₁` 结构。
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We are making progress. Now we know how to define algebraic structures in Lean,
    and we know how to define instances of those structures. But we also want to associate
    notation with structures so that we can use it with each instance. Moreover, we
    want to arrange it so that we can define an operation on a structure and use it
    with any particular instance, and we want to arrange it so that we can prove a
    theorem about a structure and use it with any instance.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在取得进展。现在我们知道了如何在 Lean 中定义代数结构，也知道如何定义这些结构的实例。但我们还希望将符号与结构关联起来，以便我们可以与每个实例一起使用它。此外，我们希望安排好，可以定义结构上的一个操作并使用任何特定的实例，我们还想安排好，可以证明关于结构的一个定理并使用任何实例。
- en: In fact, Mathlib is already set up to use generic group notation, definitions,
    and theorems for `Equiv.Perm α`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Mathlib 已经配置好了使用 `Equiv.Perm α` 的泛型群符号、定义和定理。
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can check that this is not the case for the additive group structure on
    `Point` that we asked you to define above. Our task now is to understand that
    magic that goes on under the hood in order to make the examples for `Equiv.Perm
    α` work the way they do.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以检查一下，我们上面要求你定义的 `Point` 上的加法群结构并不是这样。我们的任务现在是要理解那些使 `Equiv.Perm α` 的例子按预期工作的底层魔法。
- en: 'The issue is that Lean needs to be able to *find* the relevant notation and
    the implicit group structure, using the information that is found in the expressions
    that we type. Similarly, when we write `x + y` with expressions `x` and `y` that
    have type `ℝ`, Lean needs to interpret the `+` symbol as the relevant addition
    function on the reals. It also has to recognize the type `ℝ` as an instance of
    a commutative ring, so that all the definitions and theorems for a commutative
    ring are available. For another example, continuity is defined in Lean relative
    to any two topological spaces. When we have `f : ℝ → ℂ` and we write `Continuous
    f`, Lean has to find the relevant topologies on `ℝ` and `ℂ`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '问题是 Lean 需要能够 *找到* 相关的符号和隐含的群结构，使用我们在输入的表达式中找到的信息。同样，当我们用类型为 `ℝ` 的表达式 `x` 和
    `y` 写出 `x + y` 时，Lean 需要解释 `+` 符号为实数上的相关加法函数。它还必须识别类型 `ℝ` 为交换环的一个实例，这样就可以使用所有关于交换环的定义和定理。例如，连续性在
    Lean 中是在任何两个拓扑空间上定义的。当我们有 `f : ℝ → ℂ` 并写出 `Continuous f` 时，Lean 必须找到 `ℝ` 和 `ℂ`
    上的相关拓扑。'
- en: The magic is achieved with a combination of three things.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法是通过三个事物的结合实现的。
- en: '*Logic.* A definition that should be interpreted in any group takes, as arguments,
    the type of the group and the group structure as arguments. Similarly, a theorem
    about the elements of an arbitrary group begins with universal quantifiers over
    the type of the group and the group structure.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*逻辑*。任何组中应该被解释的定义，将组类型和组结构作为参数。同样，关于任意组元素的定理以组类型和组结构的全称量词开始。'
- en: '*Implicit arguments.* The arguments for the type and the structure are generally
    left implicit, so that we do not have to write them or see them in the Lean information
    window. Lean fills the information in for us silently.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*隐式参数*。类型和结构的参数通常被省略，这样我们就不必写它们或在Lean信息窗口中看到它们。Lean会默默地为我们填写信息。'
- en: '*Type class inference.* Also known as *class inference*, this is a simple but
    powerful mechanism that enables us to register information for Lean to use later
    on. When Lean is called on to fill in implicit arguments to a definition, theorem,
    or piece of notation, it can make use of information that has been registered.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*类型类推断*，也称为*类推断*，这是一个简单但强大的机制，使我们能够为Lean注册信息以供以后使用。当Lean被调用以填充定义、定理或符号中的隐式参数时，它可以利用已注册的信息。'
- en: 'Whereas an annotation `(grp : Group G)` tells Lean that it should expect to
    be given that argument explicitly and the annotation `{grp : Group G}` tells Lean
    that it should try to figure it out from contextual cues in the expression, the
    annotation `[grp : Group G]` tells Lean that the corresponding argument should
    be synthesized using type class inference. Since the whole point to the use of
    such arguments is that we generally do not need to refer to them explicitly, Lean
    allows us to write `[Group G]` and leave the name anonymous. You have probably
    already noticed that Lean chooses names like `_inst_1` automatically. When we
    use the anonymous square-bracket annotation with the `variables` command, then
    as long as the variables are still in scope, Lean automatically adds the argument
    `[Group G]` to any definition or theorem that mentions `G`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '而一个注解`(grp : Group G)`告诉Lean它应该明确地给出该参数，注解`{grp : Group G}`告诉Lean它应该从表达式的上下文中推断出它，注解`[grp
    : Group G]`告诉Lean应该使用类型类推断来合成相应的参数。由于使用此类参数的整个目的是我们通常不需要明确地引用它们，Lean允许我们写出`[Group
    G]`并保留名称匿名。你可能已经注意到Lean会自动选择像`_inst_1`这样的名称。当我们使用匿名方括号注解与`variables`命令一起使用时，只要变量仍然在作用域内，Lean就会自动将参数`[Group
    G]`添加到任何提及`G`的定义或定理中。'
- en: How do we register the information that Lean needs to use to carry out the search?
    Returning to our group example, we need only make two changes. First, instead
    of using the `structure` command to define the group structure, we use the keyword
    `class` to indicate that it is a candidate for class inference. Second, instead
    of defining particular instances with `def`, we use the keyword `instance` to
    register the particular instance with Lean. As with the names of class variables,
    we are allowed to leave the name of an instance definition anonymous, since in
    general we intend Lean to find it and put it to use without troubling us with
    the details.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何注册Lean需要用来执行搜索的信息？回到我们的组示例，我们只需要做两个更改。首先，我们不再使用`structure`命令来定义组结构，而是使用关键字`class`来表示它是一个类推断的候选。其次，我们不再使用`def`来定义特定的实例，而是使用关键字`instance`来在Lean中注册特定的实例。与类变量的名称一样，我们可以保留实例定义的名称为匿名，因为在一般情况下，我们希望Lean找到它并使用它，而不必让我们烦恼于细节。
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The following illustrates their use.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下说明了它们的使用。
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `#check` command shows that `Group₂.mul` has an implicit argument `[Group₂
    α]` that we expect to be found by class inference, where `α` is the type of the
    arguments to `Group₂.mul`. In other words, `{α : Type*}` is the implicit argument
    for the type of the group elements and `[Group₂ α]` is the implicit argument for
    the group structure on `α`. Similarly, when we define a generic squaring function
    `my_square` for `Group₂`, we use an implicit argument `{α : Type*}` for the type
    of the elements and an implicit argument `[Group₂ α]` for the `Group₂` structure.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`#check` 命令显示 `Group₂.mul` 有一个隐含的参数 `[Group₂ α]`，我们期望通过类推断找到它，其中 `α` 是 `Group₂.mul`
    参数的类型。换句话说，`{α : Type*}` 是群元素类型的隐含参数，`[Group₂ α]` 是 `α` 上的群结构的隐含参数。同样，当我们为 `Group₂`
    定义一个泛型平方函数 `my_square` 时，我们使用一个隐含参数 `{α : Type*}` 用于元素类型和一个隐含参数 `[Group₂ α]` 用于
    `Group₂` 结构。'
- en: In the first example, when we write `Group₂.mul f g`, the type of `f` and `g`
    tells Lean that in the argument `α` to `Group₂.mul` has to be instantiated to
    `Equiv.Perm β`. That means that Lean has to find an element of `Group₂ (Equiv.Perm
    β)`. The previous `instance` declaration tells Lean exactly how to do that. Problem
    solved!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，当我们编写 `Group₂.mul f g` 时，`f` 和 `g` 的类型告诉 Lean 在 `Group₂.mul` 的参数 `α`
    必须实例化为 `Equiv.Perm β`。这意味着 Lean 必须找到一个 `Group₂ (Equiv.Perm β)` 的元素。之前的 `instance`
    声明告诉 Lean 如何做到这一点。问题解决了！
- en: 'This simple mechanism for registering information so that Lean can find it
    when it needs it is remarkably useful. Here is one way it comes up. In Lean’s
    foundation, a data type `α` may be empty. In a number of applications, however,
    it is useful to know that a type has at least one element. For example, the function
    `List.headI`, which returns the first element of a list, can return the default
    value when the list is empty. To make that work, the Lean library defines a class
    `Inhabited α`, which does nothing more than store a default value. We can show
    that the `Point` type is an instance:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的机制，用于注册信息以便 Lean 在需要时能够找到它，非常有用。这里有一种出现的方式。在 Lean 的基础上，数据类型 `α` 可能是空的。然而，在许多应用中，知道一个类型至少有一个元素是有用的。例如，函数
    `List.headI`，它返回列表的第一个元素，当列表为空时可以返回默认值。为了使这一点工作，Lean 库定义了一个类 `Inhabited α`，它所做的只是存储一个默认值。我们可以证明
    `Point` 类型是一个实例：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The class inference mechanism is also used for generic notation. The expression
    `x + y` is an abbreviation for `Add.add x y` where—you guessed it—`Add α` is a
    class that stores a binary function on `α`. Writing `x + y` tells Lean to find
    a registered instance of `[Add.add α]` and use the corresponding function. Below,
    we register the addition function for `Point`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 类推断机制也用于泛型符号。表达式 `x + y` 是 `Add.add x y` 的缩写，其中——正如你所猜到的——`Add α` 是一个存储在 `α`
    上的二元函数的类。编写 `x + y` 告诉 Lean 寻找一个已注册的 `[Add.add α]` 实例并使用相应的函数。下面，我们注册了 `Point`
    的加法函数。
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this way, we can assign the notation `+` to binary operations on other types
    as well.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们还可以将符号 `+` 分配给其他类型的二元运算。
- en: 'But we can do even better. We have seen that `*` can be used in any group,
    `+` can be used in any additive group, and both can be used in any ring. When
    we define a new instance of a ring in Lean, we don’t have to define `+` and `*`
    for that instance, because Lean knows that these are defined for every ring. We
    can use this method to specify notation for our `Group₂` class:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们还能做得更好。我们已经看到 `*` 可以在任何群中使用，`+` 可以在任何加法群中使用，并且两者都可以在任何环中使用。当我们定义 Lean 中环的新实例时，我们不需要为该实例定义
    `+` 和 `*`，因为 Lean 知道这些为每个环都定义了。我们可以使用这种方法为我们的 `Group₂` 类指定符号：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: What makes this approach work is that Lean carries out a recursive search. According
    to the instances we have declared, Lean can find an instance of `Mul (Equiv.Perm
    α)` by finding an instance of `Group₂ (Equiv.Perm α)`, and it can find an instance
    of `Group₂ (Equiv.Perm α)` because we have provided one. Lean is capable of finding
    these two facts and chaining them together.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使这种方法有效的是 Lean 执行递归搜索。根据我们声明的实例，Lean 可以通过找到一个 `Group₂ (Equiv.Perm α)` 的实例来找到一个
    `Mul (Equiv.Perm α)` 的实例，并且它可以通过我们提供的一个实例来找到一个 `Group₂ (Equiv.Perm α)` 的实例。Lean
    能够找到这两个事实并将它们链接在一起。
- en: The example we have just given is dangerous, because Lean’s library also has
    an instance of `Group (Equiv.Perm α)`, and multiplication is defined on any group.
    So it is ambiguous as to which instance is found. In fact, Lean favors more recent
    declarations unless you explicitly specify a different priority. Also, there is
    another way to tell Lean that one structure is an instance of another, using the
    `extends` keyword. This is how Mathlib specifies that, for example, every commutative
    ring is a ring. You can find more information in [Section 8](C08_Hierarchies.html#hierarchies)
    and in a [section on class inference](https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html#managing-type-class-inference)
    in *Theorem Proving in Lean*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才给出的例子是危险的，因为 Lean 的库中也有一个 `Group (Equiv.Perm α)` 的实例，并且乘法在任意群上都是定义好的。所以，哪个实例被找到是不确定的。实际上，Lean
    优先选择较新的声明，除非你明确指定了不同的优先级。此外，还有另一种方法告诉 Lean 一个结构是另一个结构的实例，即使用 `extends` 关键字。这就是
    Mathlib 如何指定，例如，每个交换环都是一个环。你可以在[第 8 节](C08_Hierarchies.html#hierarchies)和*《Lean
    中的定理证明》*中的一个关于类推断的[章节](https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html#managing-type-class-inference)中找到更多信息。
- en: In general, it is a bad idea to specify a value of `*` for an instance of an
    algebraic structure that already has the notation defined. Redefining the notion
    of `Group` in Lean is an artificial example. In this case, however, both interpretations
    of the group notation unfold to `Equiv.trans`, `Equiv.refl`, and `Equiv.symm`,
    in the same way.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为已经定义了表示法的代数结构的实例指定 `*` 的值是一个坏主意。在 Lean 中重新定义 `Group` 的概念是一个人为的例子。然而，在这种情况下，两种对群表示法的解释都展开为
    `Equiv.trans`、`Equiv.refl` 和 `Equiv.symm`，方式相同。
- en: As a similarly artificial exercise, define a class `AddGroup₂` in analogy to
    `Group₂`. Define the usual notation for addition, negation, and zero on any `AddGroup₂`
    using the classes `Add`, `Neg`, and `Zero`. Then show `Point` is an instance of
    `AddGroup₂`. Try it out and make sure that the additive group notation works for
    elements of `Point`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项类似的练习，定义一个类似于 `Group₂` 的类 `AddGroup₂`。在任意的 `AddGroup₂` 上使用类 `Add`、`Neg`
    和 `Zero` 定义加法、取反和零的常规表示法。然后证明 `Point` 是 `AddGroup₂` 的一个实例。尝试一下，确保加法群表示法适用于 `Point`
    的元素。
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It is not a big problem that we have already declared instances `Add`, `Neg`,
    and `Zero` for `Point` above. Once again, the two ways of synthesizing the notation
    should come up with the same answer.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上文中为 `Point` 声明了 `Add`、`Neg` 和 `Zero` 的实例，这并不是一个大问题。再次强调，两种合成表示法应该得出相同的答案。
- en: 'Class inference is subtle, and you have to be careful when using it, because
    it configures automation that invisibly governs the interpretation of the expressions
    we type. When used wisely, however, class inference is a powerful tool. It is
    what makes algebraic reasoning possible in Lean.  ## 7.3\. Building the Gaussian
    Integers[](#building-the-gaussian-integers "Link to this heading")'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 类推断是微妙的，使用时必须小心，因为它配置了无形地控制我们输入的表达式解释的自动化。然而，当明智地使用时，类推断是一个强大的工具。它是 Lean 中代数推理成为可能的原因。##
    7.3. 构建高斯整数[](#building-the-gaussian-integers "链接到这个标题")
- en: We will now illustrate the use of the algebraic hierarchy in Lean by building
    an important mathematical object, the *Gaussian integers*, and showing that it
    is a Euclidean domain. In other words, according to the terminology we have been
    using, we will define the Gaussian integers and show that they are an instance
    of the Euclidean domain structure.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过构建一个重要的数学对象——*高斯整数*，并展示它是一个欧几里得域，来展示 Lean 中代数层次结构的用法。换句话说，根据我们一直在使用的术语，我们将定义高斯整数，并展示它们是欧几里得域结构的实例。
- en: In ordinary mathematical terms, the set of Gaussian integers \(\Bbb{Z}[i]\)
    is the set of complex numbers \(\{ a + b i \mid a, b \in \Bbb{Z}\}\). But rather
    than define them as a subset of the complex numbers, our goal here is to define
    them as a data type in their own right. We do this by representing a Gaussian
    integer as a pair of integers, which we think of as the *real* and *imaginary*
    parts.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 用普通的数学术语来说，高斯整数集 \(\Bbb{Z}[i]\) 是复数集 \(\{ a + b i \mid a, b \in \Bbb{Z}\}\)
    的集合。但与其将它们定义为复数的一个子集，我们的目标是在这里将它们定义为一个独立的数据类型。我们通过将高斯整数表示为一对整数来实现这一点，我们将这对整数视为*实部*和*虚部*。
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We first show that the Gaussian integers have the structure of a ring, with
    `0` defined to be `⟨0, 0⟩`, `1` defined to be `⟨1, 0⟩`, and addition defined pointwise.
    To work out the definition of multiplication, remember that we want the element
    \(i\), represented by `⟨0, 1⟩`, to be a square root of \(-1\). Thus we want
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先证明高斯整数具有环的结构，其中 `0` 定义为 `⟨0, 0⟩`，`1` 定义为 `⟨1, 0⟩`，加法定义为逐点。为了确定乘法定义，记住我们希望元素
    \(i\)，由 `⟨0, 1⟩` 表示，是 \(-1\) 的一个平方根。因此我们希望
- en: \[\begin{split}(a + bi) (c + di) & = ac + bci + adi + bd i^2 \\ & = (ac - bd)
    + (bc + ad)i.\end{split}\]
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}(a + bi) (c + di) & = ac + bci + adi + bd i^2 \\ & = (ac - bd)
    + (bc + ad)i.\end{split}\]
- en: This explains the definition of `Mul` below.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了下面 `Mul` 的定义。
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As noted in [Section 7.1](#section-structures), it is a good idea to put all
    the definitions related to a data type in a namespace with the same name. Thus
    in the Lean files associated with this chapter, these definitions are made in
    the `GaussInt` namespace.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 7.1 节](#section-structures) 所述，将所有与数据类型相关的定义放在具有相同名称的命名空间中是一个好主意。因此，在本章相关的
    Lean 文件中，这些定义是在 `GaussInt` 命名空间中进行的。
- en: Notice that here we are defining the interpretations of the notation `0`, `1`,
    `+`, `-`, and `*` directly, rather than naming them `GaussInt.zero` and the like
    and assigning the notation to those. It is often useful to have an explicit name
    for the definitions, for example, to use with `simp` and `rw`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里我们直接定义了符号 `0`、`1`、`+`、`-` 和 `*` 的解释，而不是将它们命名为 `GaussInt.zero` 等等，并将符号分配给它们。对于使用
    `simp` 和 `rw` 等操作来说，有一个明确的名称对于定义来说通常是很有用的。
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It is also useful to name the rules that compute the real and imaginary parts,
    and to declare them to the simplifier.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 给出计算实部和虚部的规则并声明给简化器也是有用的。
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It is now surprisingly easy to show that the Gaussian integers are an instance
    of a commutative ring. We are putting the structure concept to good use. Each
    particular Gaussian integer is an instance of the `GaussInt` structure, whereas
    the type `GaussInt` itself, together with the relevant operations, is an instance
    of the `CommRing` structure. The `CommRing` structure, in turn, extends the notational
    structures `Zero`, `One`, `Add`, `Neg`, and `Mul`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在出人意料地容易证明高斯整数是交换环的一个实例。我们正在充分利用结构概念。每个特定的高斯整数是 `GaussInt` 结构的一个实例，而类型 `GaussInt`
    本身以及相关的操作是 `CommRing` 结构的一个实例。`CommRing` 结构反过来又扩展了 `Zero`、`One`、`Add`、`Neg` 和
    `Mul` 等符号结构。
- en: 'If you type `instance : CommRing GaussInt := _`, click on the light bulb that
    appears in VS Code, and then ask Lean to fill in a skeleton for the structure
    definition, you will see a scary number of entries. Jumping to the definition
    of the structure, however, shows that many of the fields have default definitions
    that Lean will fill in for you automatically. The essential ones appear in the
    definition below. A special case are `nsmul` and `zsmul` which should be ignored
    for now and will be explained in the next chapter. In each case, the relevant
    identity is proved by unfolding definitions, using the `ext` tactic to reduce
    the identities to their real and imaginary components, simplifying, and, if necessary,
    carrying out the relevant ring calculation in the integers. Note that we could
    easily avoid repeating all this code, but this is not the topic of the current
    discussion.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你输入 `instance : CommRing GaussInt := _`，然后在 VS Code 中点击出现的灯泡图标，并让 Lean 填写结构定义的骨架，你会看到大量的条目。然而，跳转到结构的定义中，你会发现许多字段都有默认定义，Lean
    会自动为你填写。下面列出了关键的定义。一个特殊情况是 `nsmul` 和 `zsmul`，目前可以忽略，将在下一章中解释。在每种情况下，相关恒等式都是通过展开定义、使用
    `ext` 策略将恒等式简化到其实部和虚部、简化，并在必要时在整数中执行相关环运算来证明的。请注意，我们很容易避免重复所有这些代码，但这不是当前讨论的主题。'
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Lean’s library defines the class of *nontrivial* types to be types with at least
    two distinct elements. In the context of a ring, this is equivalent to saying
    that the zero is not equal to the one. Since some common theorems depend on that
    fact, we may as well establish it now.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 的库定义了 *非平凡* 类型为至少有两个不同元素的类型。在环的上下文中，这相当于说零不等于一。由于一些常见的定理依赖于这个事实，我们不妨现在就建立它。
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will now show that the Gaussian integers have an important additional property.
    A *Euclidean domain* is a ring \(R\) equipped with a *norm* function \(N : R \to
    \mathbb{N}\) with the following two properties:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '我们现在将展示高斯整数具有一个重要的附加属性。一个 *欧几里得域* 是一个带有 *范数* 函数 \(N : R \to \mathbb{N}\) 的环
    \(R\)，它具有以下两个性质：'
- en: For every \(a\) and \(b \ne 0\) in \(R\), there are \(q\) and \(r\) in \(R\)
    such that \(a = bq + r\) and either \(r = 0\) or \(N(r) < N(b)\).
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 \(R\) 中的每一个 \(a\) 和 \(b \ne 0\)，存在 \(R\) 中的 \(q\) 和 \(r\)，使得 \(a = bq + r\)，且
    \(r = 0\) 或 \(N(r) < N(b)\)。
- en: For every \(a\) and \(b \ne 0\), \(N(a) \le N(ab)\).
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每一个 \(a\) 和 \(b \ne 0\)，\(N(a) \le N(ab)\)。
- en: 'The ring of integers \(\Bbb{Z}\) with \(N(a) = |a|\) is an archetypal example
    of a Euclidean domain. In that case, we can take \(q\) to be the result of integer
    division of \(a\) by \(b\) and \(r\) to be the remainder. These functions are
    defined in Lean so that the satisfy the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 \(N(a) = |a|\) 的整数环 \(\Bbb{Z}\) 是欧几里得域的一个典型例子。在这种情况下，我们可以取 \(q\) 为 \(a\)
    除以 \(b\) 的整数除法的结果，\(r\) 为余数。这些函数在 Lean 中定义为满足以下条件：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In an arbitrary ring, an element \(a\) is said to be a *unit* if it divides
    \(1\). A nonzero element \(a\) is said to be *irreducible* if it cannot be written
    in the form \(a = bc\) where neither \(b\) nor \(c\) is a unit. In the integers,
    every irreducible element \(a\) is *prime*, which is to say, whenever \(a\) divides
    a product \(bc\), it divides either \(b\) or \(c\). But in other rings this property
    can fail. In the ring \(\Bbb{Z}[\sqrt{-5}]\), we have
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个任意的环中，一个元素 \(a\) 被称为*单位*，如果它能整除 \(1\)。一个非零元素 \(a\) 被称为*不可约*，如果它不能写成 \(a =
    bc\) 的形式，其中 \(b\) 和 \(c\) 都不是单位。在整数中，每个不可约元素 \(a\) 都是*素数*，也就是说，每当 \(a\) 整除一个乘积
    \(bc\) 时，它要么整除 \(b\)，要么整除 \(c\)。但在其他环中，这个性质可能不成立。在环 \(\Bbb{Z}[\sqrt{-5}]\) 中，我们有
- en: \[6 = 2 \cdot 3 = (1 + \sqrt{-5})(1 - \sqrt{-5}),\]
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: \[6 = 2 \cdot 3 = (1 + \sqrt{-5})(1 - \sqrt{-5}),\]
- en: 'and the elements \(2\), \(3\), \(1 + \sqrt{-5}\), and \(1 - \sqrt{-5}\) are
    all irreducible, but they are not prime. For example, \(2\) divides the product
    \((1 + \sqrt{-5})(1 - \sqrt{-5})\), but it does not divide either factor. In particular,
    we no longer have unique factorization: the number \(6\) can be factored into
    irreducible elements in more than one way.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 并且元素 \(2\)、\(3\)、\(1 + \sqrt{-5}\) 和 \(1 - \sqrt{-5}\) 都是不可约的，但它们不是素数。例如，\(2\)
    能整除乘积 \((1 + \sqrt{-5})(1 - \sqrt{-5})\)，但它不能整除任何一个因子。特别是，我们不再有唯一的分解：数字 \(6\)
    可以以多种方式分解为不可约元素。
- en: In contrast, every Euclidean domain is a unique factorization domain, which
    implies that every irreducible element is prime. The axioms for a Euclidean domain
    imply that one can write any nonzero element as a finite product of irreducible
    elements. They also imply that one can use the Euclidean algorithm to find a greatest
    common divisor of any two nonzero elements `a` and `b`, i.e. an element that is
    divisible by any other common divisor. This, in turn, implies that factorization
    into irreducible elements is unique up to multiplication by units.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，每个欧几里得域都是一个唯一分解域，这意味着每个不可约元素都是素数。欧几里得域的公理意味着可以写出任何非零元素为不可约元素的有限乘积。它们还意味着可以使用欧几里得算法找到任何两个非零元素
    `a` 和 `b` 的最大公约数，即任何其他公约数都能整除的元素。这反过来又意味着不可约元素的分解是唯一的，直到乘以单位元素。
- en: We now show that the Gaussian integers are a Euclidean domain with the norm
    defined by \(N(a + bi) = (a + bi)(a - bi) = a^2 + b^2\). The Gaussian integer
    \(a - bi\) is called the *conjugate* of \(a + bi\). It is not hard to check that
    for any complex numbers \(x\) and \(y\), we have \(N(xy) = N(x)N(y)\).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在证明高斯整数是一个具有由 \(N(a + bi) = (a + bi)(a - bi) = a^2 + b^2\) 定义的范数的欧几里得域。高斯整数
    \(a - bi\) 被称为 \(a + bi\) 的*共轭*。不难验证，对于任何复数 \(x\) 和 \(y\)，我们有 \(N(xy) = N(x)N(y)\)。
- en: To see that this definition of the norm makes the Gaussian integers a Euclidean
    domain, only the first property is challenging. Suppose we want to write \(a +
    bi = (c + di) q + r\) for suitable \(q\) and \(r\). Treating \(a + bi\) and \(c
    + di\) as complex numbers, carry out the division
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这种范数的定义使得高斯整数成为一个欧几里得域，只有第一个性质是具有挑战性的。假设我们想要将 \(a + bi = (c + di) q + r\)
    写成合适的 \(q\) 和 \(r\)。将 \(a + bi\) 和 \(c + di\) 作为复数处理，进行除法
- en: \[\frac{a + bi}{c + di} = \frac{(a + bi)(c - di)}{(c + di)(c-di)} = \frac{ac
    + bd}{c^2 + d^2} + \frac{bc -ad}{c^2+d^2} i.\]
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: \[\frac{a + bi}{c + di} = \frac{(a + bi)(c - di)}{(c + di)(c-di)} = \frac{ac
    + bd}{c^2 + d^2} + \frac{bc -ad}{c^2+d^2} i.\]
- en: The real and imaginary parts might not be integers, but we can round them to
    the nearest integers \(u\) and \(v\). We can then express the right-hand side
    as \((u + vi) + (u' + v'i)\), where \(u' + v'i\) is the part left over. Note that
    we have \(|u'| \le 1/2\) and \(|v'| \le 1/2\), and hence
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 实部和虚部可能不是整数，但我们可以将它们四舍五入到最近的整数 \(u\) 和 \(v\)。然后我们可以将右侧表示为 \((u + vi) + (u' +
    v'i)\)，其中 \(u' + v'i\) 是剩余的部分。注意，我们有 \(|u'| \le 1/2\) 和 \(|v'| \le 1/2\)，因此
- en: \[N(u' + v' i) = (u')^2 + (v')^2 \le 1/4 + 1/4 \le 1/2.\]
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: \[N(u' + v' i) = (u')^2 + (v')^2 \le 1/4 + 1/4 \le 1/2.\]
- en: Multiplying through by \(c + di\), we have
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 乘以 \(c + di\)，我们得到
- en: \[a + bi = (c + di) (u + vi) + (c + di) (u' + v'i).\]
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: \[a + bi = (c + di) (u + vi) + (c + di) (u' + v'i).\]
- en: 'Setting \(q = u + vi\) and \(r = (c + di) (u'' + v''i)\), we have \(a + bi
    = (c + di) q + r\), and we only need to bound \(N(r)\):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 将 \(q = u + vi\) 和 \(r = (c + di) (u' + v'i)\) 代入，我们得到 \(a + bi = (c + di) q
    + r\)，我们只需要对 \(N(r)\) 进行界限定：
- en: \[N(r) = N(c + di)N(u' + v'i) \le N(c + di) \cdot 1/2 < N(c + di).\]
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: \[N(r) = N(c + di)N(u' + v'i) \le N(c + di) \cdot 1/2 < N(c + di).\]
- en: The argument we just carried out requires viewing the Gaussian integers as a
    subset of the complex numbers. One option for formalizing it in Lean is therefore
    to embed the Gaussian integers in the complex numbers, embed the integers in the
    Gaussian integers, define the rounding function from the real numbers to the integers,
    and take great care to pass back and forth between these number systems appropriately.
    In fact, this is exactly the approach that is followed in Mathlib, where the Gaussian
    integers themselves are constructed as a special case of a ring of *quadratic
    integers*. See the file [GaussianInt.lean](https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/NumberTheory/Zsqrtd/GaussianInt.lean).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才进行的论证需要将高斯整数视为复数集的子集。因此，在 Lean 中形式化它的一个选项是将高斯整数嵌入到复数中，将整数嵌入到高斯整数中，定义从实数到整数的舍入函数，并非常小心地在这些数系之间来回传递。事实上，这正是
    Mathlib 中采用的方法，其中高斯整数本身被构造为二次整数环的特殊情况。参见文件 [GaussianInt.lean](https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/NumberTheory/Zsqrtd/GaussianInt.lean)。
- en: 'Here we will instead carry out an argument that stays in the integers. This
    illustrates a choice one commonly faces when formalizing mathematics. Given an
    argument that requires concepts or machinery that is not already in the library,
    one has two choices: either formalize the concepts and machinery needed, or adapt
    the argument to make use of concepts and machinery you already have. The first
    choice is generally a good investment of time when the results can be used in
    other contexts. Pragmatically speaking, however, sometimes seeking a more elementary
    proof is more efficient.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将进行一个保持在整数范围内的论证。这说明了在形式化数学时人们通常面临的选择。给定一个需要库中尚未存在的概念或工具的论证，你有两个选择：要么形式化所需的概念和工具，要么调整论证以利用你已有的概念和工具。当结果可以在其他上下文中使用时，第一个选择通常是时间的好投资。然而，从实用主义的角度来看，有时寻找更基础的证明可能更有效。
- en: The usual quotient-remainder theorem for the integers says that for every \(a\)
    and nonzero \(b\), there are \(q\) and \(r\) such that \(a = b q + r\) and \(0
    \le r < b\). Here we will make use of the following variation, which says that
    there are \(q'\) and \(r'\) such that \(a = b q' + r'\) and \(|r'| \le b/2\).
    You can check that if the value of \(r\) in the first statement satisfies \(r
    \le b/2\), we can take \(q' = q\) and \(r' = r\), and otherwise we can take \(q'
    = q + 1\) and \(r' = r - b\). We are grateful to Heather Macbeth for suggesting
    the following more elegant approach, which avoids definition by cases. We simply
    add `b / 2` to `a` before dividing and then subtract it from the remainder.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 整数除法的商余定理指出，对于每一个 \(a\) 和非零 \(b\)，存在 \(q\) 和 \(r\) 使得 \(a = b q + r\) 且 \(0
    \le r < b\)。在这里，我们将使用以下变体，它指出存在 \(q'\) 和 \(r'\) 使得 \(a = b q' + r'\) 且 \(|r'|
    \le b/2\)。你可以检查，如果第一个陈述中的 \(r\) 的值满足 \(r \le b/2\)，我们可以取 \(q' = q\) 和 \(r' = r\)，否则我们可以取
    \(q' = q + 1\) 和 \(r' = r - b\)。我们感谢 Heather Macbeth 提出以下更优雅的方法，它避免了分情况定义。我们只需在除法之前将
    `b / 2` 加到 `a` 上，然后从余数中减去它。
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note the use of our old friend, `linarith`. We will also need to express `mod'`
    in terms of `div'`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们老朋友 `linarith` 的使用。我们还需要将 `mod'` 用 `div'` 来表示。
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We will use the fact that \(x^2 + y^2\) is equal to zero if and only if \(x\)
    and \(y\) are both zero. As an exercise, we ask you to prove that this holds in
    any ordered ring.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 \(x^2 + y^2\) 仅当 \(x\) 和 \(y\) 都为零时等于零的事实。作为练习，我们要求你证明这在任何有序环中都成立。
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We will put all the remaining definitions and theorems in this section in the
    `GaussInt` namespace. First, we define the `norm` function and ask you to establish
    some of its properties. The proofs are all short.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个部分的所有剩余定义和定理放入 `GaussInt` 命名空间。首先，我们定义 `norm` 函数并要求你建立其一些性质。证明都很简短。
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next we define the conjugate function:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们定义共轭函数：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Finally, we define division for the Gaussian integers with the notation `x /
    y`, that rounds the complex quotient to the nearest Gaussian integer. We use our
    bespoke `Int.div'` for that purpose. As we calculated above, if `x` is \(a + bi\)
    and `y` is \(c + di\), then the real and imaginary parts of `x / y` are the nearest
    integers to
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们用 `x / y` 的记号定义高斯整数的除法，它将复数商四舍五入到最接近的高斯整数。我们使用定制的 `Int.div'` 来实现这一点。正如我们上面所计算的，如果
    `x` 是 \(a + bi\) 且 `y` 是 \(c + di\)，那么 `x / y` 的实部和虚部是到 \(c + di\) 的范数最近的整数。
- en: \[\frac{ac + bd}{c^2 + d^2} \quad \text{and} \quad \frac{bc -ad}{c^2+d^2},\]
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: \[\frac{ac + bd}{c^2 + d^2} \quad \text{和} \quad \frac{bc -ad}{c^2+d^2},\]
- en: respectively. Here the numerators are the real and imaginary parts of \((a +
    bi) (c - di)\), and the denominators are both equal to the norm of \(c + di\).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 分别。在这里，分子是 \((a + bi) (c - di)\) 的实部和虚部，分母都是 \(c + di\) 的范数。
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Having defined `x / y`, We define `x % y` to be the remainder, `x - (x / y)
    * y`. As above, we record the definitions in the theorems `div_def` and `mod_def`
    so that we can use them with `simp` and `rw`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了 `x / y` 之后，我们定义 `x % y` 为余数，`x - (x / y) * y`。如上所述，我们在定理 `div_def` 和 `mod_def`
    中记录这些定义，以便我们可以使用它们与 `simp` 和 `rw` 一起使用。
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: These definitions immediately yield `x = y * (x / y) + x % y` for every `x`
    and `y`, so all we need to do is show that the norm of `x % y` is less than the
    norm of `y` when `y` is not zero.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义立即给出了对于每一个 `x` 和 `y`，`x = y * (x / y) + x % y`，因此我们只需要证明当 `y` 不为零时，`x %
    y` 的范数小于 `y` 的范数。
- en: We just defined the real and imaginary parts of `x / y` to be `div' (x * conj
    y).re (norm y)` and `div' (x * conj y).im (norm y)`, respectively. Calculating,
    we have
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义了 `x / y` 的实部和虚部分别为 `div' (x * conj y).re (norm y)` 和 `div' (x * conj
    y).im (norm y)`。计算后，我们有
- en: '`(x % y) * conj y = (x - x / y * y) * conj y = x * conj y - x / y * (y * conj
    y)`'
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`(x % y) * conj y = (x - x / y * y) * conj y = x * conj y - x / y * (y * conj
    y)`'
- en: The real and imaginary parts of the right-hand side are exactly `mod' (x * conj
    y).re (norm y)` and `mod' (x * conj y).im (norm y)`. By the properties of `div'`
    and `mod'`, these are guaranteed to be less than or equal to `norm y / 2`. So
    we have
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的实部和虚部正好是 `mod' (x * conj y).re (norm y)` 和 `mod' (x * conj y).im (norm y)`。根据
    `div'` 和 `mod'` 的性质，这些保证小于或等于 `norm y / 2`。因此我们有
- en: '`norm ((x % y) * conj y) ≤ (norm y / 2)^2 + (norm y / 2)^2 ≤ (norm y / 2) *
    norm y`.'
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`norm ((x % y) * conj y) ≤ (norm y / 2)^2 + (norm y / 2)^2 ≤ (norm y / 2) *
    norm y`。'
- en: On the other hand, we have
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们有
- en: '`norm ((x % y) * conj y) = norm (x % y) * norm (conj y) = norm (x % y) * norm
    y`.'
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`norm ((x % y) * conj y) = norm (x % y) * norm (conj y) = norm (x % y) * norm
    y`。'
- en: Dividing through by `norm y` we have `norm (x % y) ≤ (norm y) / 2 < norm y`,
    as required.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 除以 `norm y`，我们得到 `norm (x % y) ≤ (norm y) / 2 < norm y`，正如所要求的。
- en: This messy calculation is carried out in the next proof. We encourage you to
    step through the details and see if you can find a nicer argument.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这项繁杂的计算将在下一个证明中进行。我们鼓励你逐步查看细节，看看你是否能找到一个更简洁的论证。
- en: '[PRE47]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We are in the home stretch. Our `norm` function maps Gaussian integers to nonnegative
    integers. We need a function that maps Gaussian integers to natural numbers, and
    we obtain that by composing `norm` with the function `Int.natAbs`, which maps
    integers to the natural numbers. The first of the next two lemmas establishes
    that mapping the norm to the natural numbers and back to the integers does not
    change the value. The second one re-expresses the fact that the norm is decreasing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经接近终点。我们的 `norm` 函数将高斯整数映射到非负整数。我们需要一个将高斯整数映射到自然数的函数，我们通过将 `norm` 与将整数映射到自然数的函数
    `Int.natAbs` 组合来实现这一点。下一个两个引理中的第一个建立了将范数映射到自然数再映射回整数不会改变值的性质。第二个重新表述了范数是递减的事实。
- en: '[PRE48]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We also need to establish the second key property of the norm function on a
    Euclidean domain.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在欧几里得域上建立范数函数的第二个关键性质。
- en: '[PRE49]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can now put it together to show that the Gaussian integers are an instance
    of a Euclidean domain. We use the quotient and remainder function we have defined.
    The Mathlib definition of a Euclidean domain is more general than the one above
    in that it allows us to show that remainder decreases with respect to any well-founded
    measure. Comparing the values of a norm function that returns natural numbers
    is just one instance of such a measure, and in that case, the required properties
    are the theorems `natAbs_norm_mod_lt` and `not_norm_mul_left_lt_norm`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将这些放在一起来证明高斯整数是欧几里得域的一个实例。我们使用我们定义的商和余数函数。Mathlib中欧几里得域的定义比上面的定义更通用，因为它允许我们证明余数与任何良基测度相关减少。比较返回自然数的范数函数的值只是这种测度的一个实例，在这种情况下，所需性质是定理`natAbs_norm_mod_lt`和`not_norm_mul_left_lt_norm`。
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: An immediate payoff is that we now know that, in the Gaussian integers, the
    notions of being prime and being irreducible coincide.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 立即的回报是，我们现在知道，在高斯整数中，素数和不可约的概念是一致的。
- en: '[PRE51] [Previous](C06_Discrete_Mathematics.html "6\. Discrete Mathematics")
    [Next](C08_Hierarchies.html "8\. Hierarchies")'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE51] [上一节](C06_Discrete_Mathematics.html "6\. 离散数学") [下一节](C08_Hierarchies.html
    "8\. 层次")'
- en: '* * *'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: © Copyright 2020-2025, Jeremy Avigad, Patrick Massot. Text licensed under CC
    BY 4.0.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: © 版权所有 2020-2025，Jeremy Avigad，Patrick Massot。文本许可协议为CC BY 4.0。
- en: Built with [Sphinx](https://www.sphinx-doc.org/) using a [theme](https://github.com/readthedocs/sphinx_rtd_theme)
    provided by [Read the Docs](https://readthedocs.org). Modern mathematics makes
    essential use of algebraic structures, which encapsulate patterns that can be
    instantiated in multiple settings. The subject provides various ways of defining
    such structures and constructing particular instances.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[Sphinx](https://www.sphinx-doc.org/)构建，使用[主题](https://github.com/readthedocs/sphinx_rtd_theme)由[Read
    the Docs](https://readthedocs.org)提供。现代数学在本质上是使用代数结构，这些结构封装了可以在多个设置中实例化的模式。该主题提供了定义此类结构及其构建特定实例的各种方法。
- en: Lean therefore provides corresponding ways of defining structures formally and
    working with them. You have already seen examples of algebraic structures in Lean,
    such as rings and lattices, which were discussed in [Chapter 2](C02_Basics.html#basics).
    This chapter will explain the mysterious square bracket annotations that you saw
    there, `[Ring α]` and `[Lattice α]`. It will also show you how to define and use
    algebraic structures on your own.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Lean提供了定义结构及其形式化操作的方法。您已经看到了Lean中代数结构的例子，例如环和格，这些在[第2章](C02_Basics.html#basics)中有所讨论。本章将解释您在那里看到的神秘方括号注释，`[Ring
    α]`和`[Lattice α]`。它还将向您展示如何定义和使用您自己的代数结构。
- en: For more technical detail, you can consult [Theorem Proving in Lean](https://leanprover.github.io/theorem_proving_in_lean/),
    and a paper by Anne Baanen, [Use and abuse of instance parameters in the Lean
    mathematical library](https://arxiv.org/abs/2202.01629).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更详细的技术信息，您可以查阅[Lean中的定理证明](https://leanprover.github.io/theorem_proving_in_lean/)，以及Anne
    Baanen的一篇论文，[在Lean数学库中使用和滥用实例参数](https://arxiv.org/abs/2202.01629)。
- en: '## 7.1\. Defining structures[](#defining-structures "Link to this heading")'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '## 7.1\. 定义结构[](#defining-structures "链接到此标题")'
- en: 'In the broadest sense of the term, a *structure* is a specification of a collection
    of data, possibly with constraints that the data is required to satisfy. An *instance*
    of the structure is a particular bundle of data satisfying the constraints. For
    example, we can specify that a point is a tuple of three real numbers:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在最广泛的意义上，一个*结构*是一组数据的指定，可能包含数据需要满足的约束。该结构的*实例*是满足这些约束的特定数据包。例如，我们可以指定一个点是三个实数的元组：
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `@[ext]` annotation tells Lean to automatically generate theorems that can
    be used to prove that two instances of a structure are equal when their components
    are equal, a property known as *extensionality*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`@[ext]`注释告诉Lean自动生成定理，这些定理可以用来证明当结构实例的组件相等时，两个结构实例是相等的，这种性质称为*扩展性*。'
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We can then define particular instances of the `Point` structure. Lean provides
    multiple ways of doing that.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以定义`Point`结构的特定实例。Lean提供了多种方法来实现这一点。
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the first example, the fields of the structure are named explicitly. The
    function `Point.mk` referred to in the definition of `myPoint3` is known as the
    *constructor* for the `Point` structure, because it serves to construct elements.
    You can specify a different name if you want, like `build`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，结构的字段被明确命名。在 `myPoint3` 的定义中提到的 `Point.mk` 函数被称为 `Point` 结构的 *构造函数*，因为它用于构建元素。如果你想，可以指定不同的名称，比如
    `build`。
- en: '[PRE55]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The next two examples show how to define functions on structures. Whereas the
    second example makes the `Point.mk` constructor explicit, the first example uses
    an anonymous constructor for brevity. Lean can infer the relevant constructor
    from the indicated type of `add`. It is conventional to put definitions and theorems
    associated with a structure like `Point` in a namespace with the same name. In
    the example below, because we have opened the `Point` namespace, the full name
    of `add` is `Point.add`. When the namespace is not open, we have to use the full
    name. But remember that it is often convenient to use anonymous projection notation,
    which allows us to write `a.add b` instead of `Point.add a b`. Lean interprets
    the former as the latter because `a` has type `Point`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两个例子展示了如何在结构上定义函数。第二个例子使 `Point.mk` 构造函数显式化，而第一个例子为了简洁使用了匿名构造函数。Lean 可以从
    `add` 的指示类型推断出相关的构造函数。将定义和定理与像 `Point` 这样的结构关联的命名空间与相同名称的命名空间放在一起是一种惯例。在下面的例子中，因为我们已经打开了
    `Point` 命名空间，所以 `add` 的全名是 `Point.add`。当命名空间未打开时，我们必须使用全名。但请记住，使用匿名投影符号通常很方便，它允许我们写出
    `a.add b` 而不是 `Point.add a b`。因为 `a` 的类型是 `Point`，所以 Lean 将前者解释为后者。
- en: '[PRE56]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Below we will continue to put definitions in the relevant namespace, but we
    will leave the namespacing commands out of the quoted snippets. To prove properties
    of the addition function, we can use `rw` to expand the definition and `ext` to
    reduce an equation between two elements of the structure to equations between
    the components. Below we use the `protected` keyword so that the name of the theorem
    is `Point.add_comm`, even when the namespace is open. This is helpful when we
    want to avoid ambiguity with a generic theorem like `add_comm`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 下面我们将继续在相关命名空间中放置定义，但我们将省略引用片段中的命名空间命令。为了证明加法函数的性质，我们可以使用 `rw` 来展开定义，并使用 `ext`
    将结构中两个元素之间的等式简化为组件之间的等式。我们使用 `protected` 关键字，即使命名空间是开放的，定理的名称也是 `Point.add_comm`。这在我们想要避免与像
    `add_comm` 这样的通用定理产生歧义时很有帮助。
- en: '[PRE57]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Because Lean can unfold definitions and simplify projections internally, sometimes
    the equations we want hold definitionally.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Lean 可以在内部展开定义并简化投影，有时我们想要的方程在定义上是成立的。
- en: '[PRE58]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: It is also possible to define functions on structures using pattern matching,
    in a manner similar to the way we defined recursive functions in [Section 5.2](C05_Elementary_Number_Theory.html#section-induction-and-recursion).
    The definitions `addAlt` and `addAlt'` below are essentially the same; the only
    difference is that we use anonymous constructor notation in the second. Although
    it is sometimes convenient to define functions this way, and structural eta-reduction
    makes this alternative definitionally equivalent, it can make things less convenient
    in later proofs. In particular, `rw [addAlt]` leaves us with a messier goal view
    containing a `match` statement.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用模式匹配在结构上定义函数，这与我们在 [第 5.2 节](C05_Elementary_Number_Theory.html#section-induction-and-recursion)
    中定义递归函数的方式类似。下面的 `addAlt` 和 `addAlt'` 定义基本上是相同的；唯一的区别是我们第二个使用了匿名构造函数符号。虽然以这种方式定义函数有时很方便，结构性的
    eta-归约使这种替代定义上等价，但它可能会在后续的证明中使事情变得不那么方便。特别是，`rw [addAlt]` 会留下一个包含 `match` 语句的更混乱的目标视图。
- en: '[PRE59]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Mathematical constructions often involve taking apart bundled information and
    putting it together again in different ways. It therefore makes sense that Lean
    and Mathlib offer so many ways of doing this efficiently. As an exercise, try
    proving that `Point.add` is associative. Then define scalar multiplication for
    a point and show that it distributes over addition.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 数学构造通常涉及拆分捆绑的信息，并以不同的方式重新组合。因此，Lean 和 Mathlib 提供了如此多的方法来高效地完成这项工作是有意义的。作为练习，尝试证明
    `Point.add` 是结合的。然后定义点的标量乘法，并证明它对加法分配。
- en: '[PRE60]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Using structures is only the first step on the road to algebraic abstraction.
    We don’t yet have a way to link `Point.add` to the generic `+` symbol, or to connect
    `Point.add_comm` and `Point.add_assoc` to the generic `add_comm` and `add_assoc`
    theorems. These tasks belong to the *algebraic* aspect of using structures, and
    we will explain how to carry them out in the next section. For now, just think
    of a structure as a way of bundling together objects and information.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用结构只是通往代数抽象道路上的第一步。我们还没有一种方法将 `Point.add` 与泛型 `+` 符号链接起来，或者将 `Point.add_comm`
    和 `Point.add_assoc` 与泛型 `add_comm` 和 `add_assoc` 公理连接起来。这些任务属于使用结构的 *代数* 方面，我们将在下一节中解释如何执行它们。现在，只需将结构视为捆绑对象和信息的方式即可。
- en: 'It is especially useful that a structure can specify not only data types but
    also constraints that the data must satisfy. In Lean, the latter are represented
    as fields of type `Prop`. For example, the *standard 2-simplex* is defined to
    be the set of points \((x, y, z)\) satisfying \(x ≥ 0\), \(y ≥ 0\), \(z ≥ 0\),
    and \(x + y + z = 1\). If you are not familiar with the notion, you should draw
    a picture, and convince yourself that this set is the equilateral triangle in
    three-space with vertices \((1, 0, 0)\), \((0, 1, 0)\), and \((0, 0, 1)\), together
    with its interior. We can represent it in Lean as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 特别有用的是，一个结构不仅可以指定数据类型，还可以指定数据必须满足的约束。在 Lean 中，后者表示为类型 `Prop` 的字段。例如，*标准 2-单纯形*定义为满足
    \(x ≥ 0\)、\(y ≥ 0\)、\(z ≥ 0\) 以及 \(x + y + z = 1\) 的点集 \((x, y, z)\)。如果你不熟悉这个概念，你应该画一个图，并说服自己这个集合是三维空间中的等边三角形，其顶点为
    \((1, 0, 0)\)、\((0, 1, 0)\) 和 \((0, 0, 1)\)，以及其内部。我们可以在 Lean 中如下表示它：
- en: '[PRE61]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Notice that the last four fields refer to `x`, `y`, and `z`, that is, the first
    three fields. We can define a map from the two-simplex to itself that swaps `x`
    and `y`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到最后四个字段指的是 `x`、`y` 和 `z`，即前三个字段。我们可以定义一个从二单纯形到自身的映射，该映射交换 `x` 和 `y`：
- en: '[PRE62]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: More interestingly, we can compute the midpoint of two points on the simplex.
    We have added the phrase `noncomputable section` at the beginning of this file
    in order to use division on the real numbers.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，我们可以在单纯形上计算两点之间的中点。我们在文件开头添加了“不可计算部分”这个短语，以便在实数上使用除法。
- en: '[PRE63]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here we have established `x_nonneg`, `y_nonneg`, and `z_nonneg` with concise
    proof terms, but establish `sum_eq` in tactic mode, using `by`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经用简洁的证明项建立了 `x_nonneg`、`y_nonneg` 和 `z_nonneg`，但在战术模式中使用 `by` 建立了 `sum_eq`。
- en: Given a parameter \(\lambda\) satisfying \(0 \le \lambda \le 1\), we can take
    the weighted average \(\lambda a + (1 - \lambda) b\) of two points \(a\) and \(b\)
    in the standard 2-simplex. We challenge you to define that function, in analogy
    to the `midpoint` function above.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个满足 \(0 \le \lambda \le 1\) 的参数 \(\lambda\)，我们可以在标准 2-单纯形中取两个点 \(a\) 和 \(b\)
    的加权平均 \(\lambda a + (1 - \lambda) b\)。我们挑战你定义这个函数，类似于上面的 `midpoint` 函数。
- en: '[PRE64]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Structures can depend on parameters. For example, we can generalize the standard
    2-simplex to the standard \(n\)-simplex for any \(n\). At this stage, you don’t
    have to know anything about the type `Fin n` except that it has \(n\) elements,
    and that Lean knows how to sum over it.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 结构可以依赖于参数。例如，我们可以将标准 2-单纯形推广到标准 \(n\)-单纯形，对于任何 \(n\) 都可以这样做。在这个阶段，你不必了解类型 `Fin
    n` 的任何东西，除了它有 \(n\) 个元素，以及 Lean 知道如何对其求和。
- en: '[PRE65]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: As an exercise, see if you can define the weighted average of two points in
    the standard \(n\)-simplex. You can use `Finset.sum_add_distrib` and `Finset.mul_sum`
    to manipulate the relevant sums.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，看看你是否可以定义标准 \(n\)-单纯形中两个点的加权平均。你可以使用 `Finset.sum_add_distrib` 和 `Finset.mul_sum`
    来操作相关的和。
- en: We have seen that structures can be used to bundle together data and properties.
    Interestingly, they can also be used to bundle together properties without the
    data. For example, the next structure, `IsLinear`, bundles together the two components
    of linearity.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，结构可以用来捆绑数据和属性。有趣的是，它们也可以用来捆绑属性而不包含数据。例如，下一个结构 `IsLinear` 捆绑了线性性的两个组成部分。
- en: '[PRE66]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: It is worth pointing out that structures are not the only way to bundle together
    data. The `Point` data structure can be defined using the generic type product,
    and `IsLinear` can be defined with a simple `and`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，结构并不是捆绑数据的唯一方式。可以使用泛型类型积定义 `Point` 数据结构，并且可以使用简单的 `and` 定义 `IsLinear`。
- en: '[PRE67]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Generic type constructions can even be used in place of structures with dependencies
    between their components. For example, the *subtype* construction combines a piece
    of data with a property. You can think of the type `PReal` in the next example
    as being the type of positive real numbers. Any `x : PReal` has two components:
    the value, and the property of being positive. You can access these components
    as `x.val`, which has type `ℝ`, and `x.property`, which represents the fact `0
    < x.val`.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '泛型类型构造甚至可以用作具有组件之间依赖关系的结构。例如，*子类型*构造将数据与属性结合起来。你可以将下一个示例中的类型`PReal`视为正实数的类型。任何`x
    : PReal`都有两个组件：值和正属性。你可以通过`x.val`访问这些组件，它具有类型`ℝ`，以及`x.property`，它表示`0 < x.val`这一事实。'
- en: '[PRE68]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We could have used subtypes to define the standard 2-simplex, as well as the
    standard \(n\)-simplex for an arbitrary \(n\).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用子类型来定义标准的2-单纯形，以及任意\(n\)的标准\(n\)-单纯形。
- en: '[PRE69]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Similarly, *Sigma types* are generalizations of ordered pairs, whereby the type
    of the second component depends on the type of the first.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，*Sigma类型*是有序对的推广，其中第二个组件的类型取决于第一个组件的类型。
- en: '[PRE70]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Given `s : StdSimplex`, the first component `s.fst` is a natural number, and
    the second component is an element of the corresponding simplex `StandardSimplex
    s.fst`. The difference between a Sigma type and a subtype is that the second component
    of a Sigma type is data rather than a proposition.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '给定`s : StdSimplex`，第一个组件`s.fst`是一个自然数，第二个组件是对应单纯形`StandardSimplex s.fst`的一个元素。Sigma类型与子类型之间的区别在于，Sigma类型的第二个组件是数据而不是命题。'
- en: 'But even though we can use products, subtypes, and Sigma types instead of structures,
    using structures has a number of advantages. Defining a structure abstracts away
    the underlying representation and provides custom names for the functions that
    access the components. This makes proofs more robust: proofs that rely only on
    the interface to a structure will generally continue to work when we change the
    definition, as long as we redefine the old accessors in terms of the new definition.
    Moreover, as we are about to see, Lean provides support for weaving structures
    together into a rich, interconnected hierarchy, and for managing the interactions
    between them.  ## 7.2\. Algebraic Structures[](#algebraic-structures "Link to
    this heading")'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '尽管我们可以使用积、子类型和Sigma类型来代替结构，但使用结构有许多优点。定义结构抽象出底层表示，并为访问组件的函数提供自定义名称。这使得证明更加健壮：仅依赖于结构接口的证明，在定义更改时通常仍然有效，只要我们用新定义重新定义旧的访问器。此外，正如我们即将看到的，Lean提供了将结构编织成丰富、相互关联的层次结构以及管理它们之间交互的支持。  '
- en: To clarify what we mean by the phrase *algebraic structure*, it will help to
    consider some examples.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阐明我们所说的*代数结构*的含义，考虑一些例子会有所帮助。
- en: A *partially ordered set* consists of a set \(P\) and a binary relation \(\le\)
    on \(P\) that is transitive and reflexive.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个*偏序集*由一个集合\(P\)和一个在\(P\)上的二元关系\(\le\)组成，该关系是传递的和自反的。
- en: A *group* consists of a set \(G\) with an associative binary operation, an identity
    element \(1\), and a function \(g \mapsto g^{-1}\) that returns an inverse for
    each \(g\) in \(G\). A group is *abelian* or *commutative* if the operation is
    commutative.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个*群*由一个具有结合二元运算、单位元素 \(1\) 和一个函数 \(g \mapsto g^{-1}\) 的集合 \(G\) 组成，该函数为 \(G\)
    中的每个 \(g\) 返回一个逆元素。如果运算是对称的，则群是*阿贝尔的*或*交换的*。
- en: A *lattice* is a partially ordered set with meets and joins.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个*格*是一个具有交集和并集的偏序集。
- en: A *ring* consists of an (additively written) abelian group \((R, +, 0, x \mapsto
    -x)\) together with an associative multiplication operation \(\cdot\) and an identity
    \(1\), such that multiplication distributes over addition. A ring is *commutative*
    if the multiplication is commutative.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个*环*由一个（加法表示的）阿贝尔群 \((R, +, 0, x \mapsto -x)\) 组成，以及一个结合乘法运算 \(\cdot\) 和一个单位
    \(1\)，使得乘法对加法分配。如果乘法是交换的，则环是*交换的*。
- en: An *ordered ring* \((R, +, 0, -, \cdot, 1, \le)\) consists of a ring together
    with a partial order on its elements, such that \(a \le b\) implies \(a + c \le
    b + c\) for every \(a\), \(b\), and \(c\) in \(R\), and \(0 \le a\) and \(0 \le
    b\) implies \(0 \le a b\) for every \(a\) and \(b\) in \(R\).
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个*有序环* \((R, +, 0, -, \cdot, 1, \le)\) 由一个环及其元素上的偏序组成，使得对于\(R\)中的每个\(a\)、\(b\)和\(c\)，\(a
    \le b\)意味着\(a + c \le b + c\)，并且\(0 \le a\)和\(0 \le b\)意味着对于\(R\)中的每个\(a\)和\(b\)，\(0
    \le a b\)。
- en: 'A *metric space* consists of a set \(X\) and a function \(d : X \times X \to
    \mathbb{R}\) such that the following hold:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '一个 *度量空间* 由一个集合 \(X\) 和一个函数 \(d : X \times X \to \mathbb{R}\) 组成，使得以下条件成立：'
- en: \(d(x, y) \ge 0\) for every \(x\) and \(y\) in \(X\).
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 \(X\) 中的每一个 \(x\) 和 \(y\)，有 \(d(x, y) \ge 0\)。
- en: \(d(x, y) = 0\) if and only if \(x = y\).
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(d(x, y) = 0\) 当且仅当 \(x = y\)。
- en: \(d(x, y) = d(y, x)\) for every \(x\) and \(y\) in \(X\).
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 \(X\) 中的每一个 \(x\) 和 \(y\)，有 \(d(x, y) = d(y, x)\)。
- en: \(d(x, z) \le d(x, y) + d(y, z)\) for every \(x\), \(y\), and \(z\) in \(X\).
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 \(X\) 中的每一个 \(x\)、\(y\) 和 \(z\)，有 \(d(x, z) \le d(x, y) + d(y, z)\)。
- en: 'A *topological space* consists of a set \(X\) and a collection \(\mathcal T\)
    of subsets of \(X\), called the *open subsets of* \(X\), such that the following
    hold:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 *拓扑空间* 由一个集合 \(X\) 和一个 \(X\) 的子集的集合 \(\mathcal T\) 组成，称为 \(X\) 的 *开子集*，使得以下条件成立：
- en: The empty set and \(X\) are open.
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空集和 \(X\) 是开集。
- en: The intersection of two open sets is open.
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个开集的交集是开集。
- en: An arbitrary union of open sets is open.
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开集的任意并集是开集。
- en: In each of these examples, the elements of the structure belong to a set, the
    *carrier set*, that sometimes stands proxy for the entire structure. For example,
    when we say “let \(G\) be a group” and then “let \(g \in G\),” we are using \(G\)
    to stand for both the structure and its carrier. Not every algebraic structure
    is associated with a single carrier set in this way. For example, a *bipartite
    graph* involves a relation between two sets, as does a *Galois connection*, A
    *category* also involves two sets of interest, commonly called the *objects* and
    the *morphisms*.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些例子中，结构的元素属于一个集合，称为 *载体集*，有时它代表整个结构。例如，当我们说“设 \(G\) 为一个群”然后“设 \(g \in G\)”时，我们使用
    \(G\) 来代表结构和它的载体。并非每个代数结构都以这种方式与单个载体集相关联。例如，一个 *二部图* 涉及两个集合之间的关系，正如 *高斯连接* 一样，一个
    *范畴* 也涉及两个感兴趣的集合，通常称为 *对象* 和 *态射*。
- en: The examples indicate some of the things that a proof assistant has to do in
    order to support algebraic reasoning. First, it needs to recognize concrete instances
    of structures. The number systems \(\mathbb{Z}\), \(\mathbb{Q}\), and \(\mathbb{R}\)
    are all ordered rings, and we should be able to apply a generic theorem about
    ordered rings in any of these instances. Sometimes a concrete set may be an instance
    of a structure in more than one way. For example, in addition to the usual topology
    on \(\mathbb{R}\), which forms the basis for real analysis, we can also consider
    the *discrete* topology on \(\mathbb{R}\), in which every set is open.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子表明，证明辅助工具为了支持代数推理必须完成的一些事情。首先，它需要识别结构的具体实例。数系 \(\mathbb{Z}\)、\(\mathbb{Q}\)
    和 \(\mathbb{R}\) 都是序环，我们应该能够在这些实例中的任何一个上应用关于序环的通用定理。有时一个具体集合可能以多种方式成为某个结构的一个实例。例如，除了
    \(\mathbb{R}\) 上的通常拓扑，它是实分析的基础之外，我们还可以考虑 \(\mathbb{R}\) 上的 *离散* 拓扑，其中每个集合都是开集。
- en: Second, a proof assistant needs to support generic notation on structures. In
    Lean, the notation `*` is used for multiplication in all the usual number systems,
    as well as for multiplication in generic groups and rings. When we use an expression
    like `f x * y`, Lean has to use information about the types of `f`, `x`, and `y`
    to determine which multiplication we have in mind.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，证明辅助工具需要支持结构上的通用符号。在 Lean 中，符号 `*` 用于所有常规数系中的乘法，以及用于通用群和环中的乘法。当我们使用像 `f x
    * y` 这样的表达式时，Lean 必须使用关于 `f`、`x` 和 `y` 的类型信息来确定我们心中的乘法是哪一种。
- en: Third, it needs to deal with the fact that structures can inherit definitions,
    theorems, and notation from other structures in various ways. Some structures
    extend others by adding more axioms. A commutative ring is still a ring, so any
    definition that makes sense in a ring also makes sense in a commutative ring,
    and any theorem that holds in a ring also holds in a commutative ring. Some structures
    extend others by adding more data. For example, the additive part of any ring
    is an additive group. The ring structure adds a multiplication and an identity,
    as well as axioms that govern them and relate them to the additive part. Sometimes
    we can define one structure in terms of another. Any metric space has a canonical
    topology associated with it, the *metric space topology*, and there are various
    topologies that can be associated with any linear ordering.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，它需要处理结构可以从其他结构以各种方式继承定义、定理和记号的事实。一些结构通过添加更多的公理来扩展其他结构。交换环仍然是一个环，所以任何在环中有意义的定义在交换环中也有意义，任何在环中成立的定理在交换环中也成立。一些结构通过添加更多的数据来扩展其他结构。例如，任何环的加法部分是一个加法群。环结构添加了乘法和单位元，以及规范这些乘法和单位元以及它们与加法部分关系的公理。有时我们可以用另一个结构来定义一个结构。任何度量空间都有一个与之相关的典型拓扑，即*度量空间拓扑*，还有可以与任何线性顺序相关联的各种拓扑。
- en: Finally, it is important to keep in mind that mathematics allows us to use functions
    and operations to define structures in the same way we use functions and operations
    to define numbers. Products and powers of groups are again groups. For every \(n\),
    the integers modulo \(n\) form a ring, and for every \(k > 0\), the \(k \times
    k\) matrices of polynomials with coefficients in that ring again form a ring.
    Thus we can calculate with structures just as easily as we can calculate with
    their elements. This means that algebraic structures lead dual lives in mathematics,
    as containers for collections of objects and as objects in their own right. A
    proof assistant has to accommodate this dual role.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，重要的是要记住，数学允许我们使用函数和运算以定义结构的方式，就像我们使用函数和运算来定义数字一样。群的乘积和幂仍然是群。对于每一个\(n\)，模\(n\)的整数构成一个环，对于每一个\(k
    > 0\)，系数在该环中的\(k \times k\)多项式矩阵再次构成一个环。因此，我们可以像计算它们的元素一样容易地计算结构。这意味着代数结构在数学中过着双重生活，既是对象集合的容器，也是它们自身的对象。证明辅助工具必须适应这种双重角色。
- en: When dealing with elements of a type that has an algebraic structure associated
    with it, a proof assistant needs to recognize the structure and find the relevant
    definitions, theorems, and notation. All this should sound like a lot of work,
    and it is. But Lean uses a small collection of fundamental mechanisms to carry
    out these tasks. The goal of this section is to explain these mechanisms and show
    you how to use them.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理与具有代数结构相关联的类型元素时，证明辅助工具需要识别该结构并找到相关的定义、定理和记号。所有这些听起来像是一大堆工作，确实如此。但Lean使用一小套基本机制来完成这些任务。本节的目标是解释这些机制并展示如何使用它们。
- en: 'The first ingredient is almost too obvious to mention: formally speaking, algebraic
    structures are structures in the sense of [Section 7.1](#section-structures).
    An algebraic structure is a specification of a bundle of data satisfying some
    axiomatic hypotheses, and we saw in [Section 7.1](#section-structures) that this
    is exactly what the `structure` command is designed to accommodate. It’s a marriage
    made in heaven!'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个要素几乎是显而易见的：从严格意义上讲，代数结构是[第7.1节](#section-structures)意义上的结构。代数结构是一组满足某些公理假设的数据的指定，我们在[第7.1节](#section-structures)中看到，这正是`structure`命令设计用来适应的。这是一场天作之合！
- en: Given a data type `α`, we can define the group structure on `α` as follows.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个数据类型`α`，我们可以如下定义`α`上的群结构。
- en: '[PRE71]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Notice that the type `α` is a *parameter* in the definition of `Group₁`. So
    you should think of an object `struc : Group₁ α` as being a group structure on
    `α`. We saw in [Section 2.2](C02_Basics.html#proving-identities-in-algebraic-structures)
    that the counterpart `mul_inv_cancel` to `inv_mul_cancel` follows from the other
    group axioms, so there is no need to add it to the definition.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，类型`α`是`Group₁`定义中的一个*参数*。因此，你应该将对象`struc : Group₁ α`视为`α`上的群结构。我们在[第2.2节](C02_Basics.html#proving-identities-in-algebraic-structures)中看到，`inv_mul_cancel`的对应项`mul_inv_cancel`可以从其他群公理中得出，因此没有必要将其添加到定义中。'
- en: This definition of a group is similar to the definition of `Group` in Mathlib,
    and we have chosen the name `Group₁` to distinguish our version. If you write
    `#check Group` and ctrl-click on the definition, you will see that the Mathlib
    version of `Group` is defined to extend another structure; we will explain how
    to do that later. If you type `#print Group` you will also see that the Mathlib
    version of `Group` has a number of extra fields. For reasons we will explain later,
    sometimes it is useful to add redundant information to a structure, so that there
    are additional fields for objects and functions that can be defined from the core
    data. Don’t worry about that for now. Rest assured that our simplified version
    `Group₁` is morally the same as the definition of a group that Mathlib uses.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个群的定义与 Mathlib 中 `Group` 的定义相似，我们选择 `Group₁` 这个名字来区分我们的版本。如果你写 `#check Group`
    并在定义上 ctrl-click，你会看到 Mathlib 版本的 `Group` 被定义为扩展另一个结构；我们将在稍后解释如何做到这一点。如果你输入 `#print
    Group`，你也会看到 Mathlib 版本的 `Group` 有许多额外的字段。由于我们将解释的原因，有时在结构中添加冗余信息是有用的，这样就可以为从核心数据定义的对象和函数添加额外的字段。现在不用担心这个问题。请放心，我们的简化版本
    `Group₁` 在道德上是与 Mathlib 使用的群定义相同的。
- en: 'It is sometimes useful to bundle the type together with the structure, and
    Mathlib also contains a definition of a `Grp` structure that is equivalent to
    the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 有时将类型与结构捆绑在一起是有用的，Mathlib 也包含了一个与以下等价的 `Grp` 结构定义：
- en: '[PRE72]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The Mathlib version is found in `Mathlib.Algebra.Category.Grp.Basic`, and you
    can `#check` it if you add this to the imports at the beginning of the examples
    file.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib 版本可以在 `Mathlib.Algebra.Category.Grp.Basic` 中找到，如果你在示例文件的开始处添加这个导入，你可以使用
    `#check` 来检查它。
- en: For reasons that will become clearer below, it is more often useful to keep
    the type `α` separate from the structure `Group α`. We refer to the two objects
    together as a *partially bundled structure*, since the representation combines
    most, but not all, of the components into one structure. It is common in Mathlib
    to use capital roman letters like `G` for a type when it is used as the carrier
    type for a group.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 由于以下原因将变得更为清晰，通常更有用的是将类型 `α` 与结构 `Group α` 分开。我们将这两个对象一起称为 *部分捆绑结构*，因为表示结合了大多数但不是所有组件到一个结构中。在
    Mathlib 中，当用作群的载体类型时，通常使用大写罗马字母如 `G` 来表示类型。
- en: 'Let’s construct a group, which is to say, an element of the `Group₁` type.
    For any pair of types `α` and `β`, Mathlib defines the type `Equiv α β` of *equivalences*
    between `α` and `β`. Mathlib also defines the suggestive notation `α ≃ β` for
    this type. An element `f : α ≃ β` is a bijection between `α` and `β` represented
    by four components: a function `f.toFun` from `α` to `β`, the inverse function
    `f.invFun` from `β` to `α`, and two properties that specify these functions are
    indeed inverse to one another.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们构造一个群，也就是说，`Group₁` 类型的元素。对于任何一对类型 `α` 和 `β`，Mathlib 定义了 `α` 和 `β` 之间 *等价*
    的类型 `Equiv α β`。Mathlib 还为这个类型定义了有启发性的符号 `α ≃ β`。一个元素 `f : α ≃ β` 是 `α` 和 `β`
    之间的双射，由四个组件表示：一个从 `α` 到 `β` 的函数 `f.toFun`，一个从 `β` 到 `α` 的逆函数 `f.invFun`，以及两个指定这些函数确实是彼此的逆的性质。'
- en: '[PRE73]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Notice the creative naming of the last three constructions. We think of the
    identity function `Equiv.refl`, the inverse operation `Equiv.symm`, and the composition
    operation `Equiv.trans` as explicit evidence that the property of being in bijective
    correspondence is an equivalence relation.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后三个构造的命名非常具有创意。我们将恒等函数 `Equiv.refl`、逆运算 `Equiv.symm` 和复合运算 `Equiv.trans`
    视为明确的证据，表明双射对应性是一个等价关系。
- en: Notice also that `f.trans g` requires composing the forward functions in reverse
    order. Mathlib has declared a *coercion* from `Equiv α β` to the function type
    `α → β`, so we can omit writing `.toFun` and have Lean insert it for us.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`f.trans g` 需要以前向函数的逆序进行组合。Mathlib 声明了一个从 `Equiv α β` 到函数类型 `α → β` 的 *强制转换*，因此我们可以省略写
    `.toFun`，让 Lean 为我们插入它。
- en: '[PRE74]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Mathlib also defines the type `perm α` of equivalences between `α` and itself.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib 还定义了类型 `perm α`，它是 `α` 与自身之间的等价类型。
- en: '[PRE75]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'It should be clear that `Equiv.Perm α` forms a group under composition of equivalences.
    We orient things so that `mul f g` is equal to `g.trans f`, whose forward function
    is `f ∘ g`. In other words, multiplication is what we ordinarily think of as composition
    of the bijections. Here we define this group:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 应该清楚，`Equiv.Perm α` 在等价关系的组合下形成一个群。我们这样安排，使得 `mul f g` 等于 `g.trans f`，其前向函数是
    `f ∘ g`。换句话说，乘法就是我们通常认为的双射的复合。在这里，我们定义了这个群：
- en: '[PRE76]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In fact, Mathlib defines exactly this `Group` structure on `Equiv.Perm α` in
    the file `Algebra.Group.End`. As always, you can hover over the theorems used
    in the definition of `permGroup` to see their statements, and you can jump to
    their definitions in the original file to learn more about how they are implemented.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Mathlib 在 `Algebra.Group.End` 文件中在 `Equiv.Perm α` 上定义了确切的这个 `Group` 结构。一如既往，你可以悬停在
    `permGroup` 定义中使用的定理上以查看它们的陈述，你也可以跳转到原始文件中的定义以了解更多关于它们是如何实现的。
- en: In ordinary mathematics, we generally think of notation as independent of structure.
    For example, we can consider groups \((G_1, \cdot, 1, \cdot^{-1})\), \((G_2, \circ,
    e, i(\cdot))\), and \((G_3, +, 0, -)\). In the first case, we write the binary
    operation as \(\cdot\), the identity as \(1\), and the inverse function as \(x
    \mapsto x^{-1}\). In the second and third cases, we use the notational alternatives
    shown. When we formalize the notion of a group in Lean, however, the notation
    is more tightly linked to the structure. In Lean, the components of any `Group`
    are named `mul`, `one`, and `inv`, and in a moment we will see how multiplicative
    notation is set up to refer to them. If we want to use additive notation, we instead
    use an isomorphic structure `AddGroup` (the structure underlying additive groups).
    Its components are named `add`, `zero`, and `neg`, and the associated notation
    is what you would expect it to be.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规数学中，我们通常认为符号与结构是独立的。例如，我们可以考虑群 \((G_1, \cdot, 1, \cdot^{-1})\)、\((G_2, \circ,
    e, i(\cdot))\) 和 \((G_3, +, 0, -)\)。在第一种情况下，我们用 \(\cdot\) 表示二元运算，用 \(1\) 表示单位元，用
    \(x \mapsto x^{-1}\) 表示逆函数。在第二种和第三种情况下，我们使用显示的符号替代。然而，当我们用 Lean 正式化群的观念时，符号与结构的关系更为紧密。在
    Lean 中，任何 `Group` 的组成部分被命名为 `mul`、`one` 和 `inv`，我们很快就会看到如何设置乘法符号来引用它们。如果我们想使用加法符号，我们则使用同构结构
    `AddGroup`（加法群的底层结构）。它的组成部分被命名为 `add`、`zero` 和 `neg`，相关的符号正如你所期望的那样。
- en: Recall the type `Point` that we defined in [Section 7.1](#section-structures),
    and the addition function that we defined there. These definitions are reproduced
    in the examples file that accompanies this section. As an exercise, define an
    `AddGroup₁` structure that is similar to the `Group₁` structure we defined above,
    except that it uses the additive naming scheme just described. Define negation
    and a zero on the `Point` data type, and define the `AddGroup₁` structure on `Point`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在 [第 7.1 节](#section-structures) 中定义的 `Point` 类型以及我们那里定义的加法函数。这些定义在伴随本节的示例文件中重现。作为一个练习，定义一个类似于我们上面定义的
    `Group₁` 结构的 `AddGroup₁` 结构，但它使用前面描述的加法命名方案。在 `Point` 数据类型上定义否定和零，并在 `Point` 上定义
    `AddGroup₁` 结构。
- en: '[PRE77]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We are making progress. Now we know how to define algebraic structures in Lean,
    and we know how to define instances of those structures. But we also want to associate
    notation with structures so that we can use it with each instance. Moreover, we
    want to arrange it so that we can define an operation on a structure and use it
    with any particular instance, and we want to arrange it so that we can prove a
    theorem about a structure and use it with any instance.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在取得进展。现在我们知道了如何在 Lean 中定义代数结构，也知道如何定义这些结构的实例。但我们还希望将符号与结构关联起来，以便我们可以与每个实例一起使用它。此外，我们希望将其组织得可以定义结构上的一个运算并使用任何特定实例，我们还想组织得可以证明关于结构的一个定理并使用任何实例。
- en: In fact, Mathlib is already set up to use generic group notation, definitions,
    and theorems for `Equiv.Perm α`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Mathlib 已经设置好使用通用的群符号、定义和定理为 `Equiv.Perm α`。
- en: '[PRE78]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: You can check that this is not the case for the additive group structure on
    `Point` that we asked you to define above. Our task now is to understand that
    magic that goes on under the hood in order to make the examples for `Equiv.Perm
    α` work the way they do.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以检查我们上面要求你定义的 `Point` 上的加法群结构并非如此。我们的任务现在是要理解在 `Equiv.Perm α` 的例子背后发生的魔法，以便它们能以这种方式工作。
- en: 'The issue is that Lean needs to be able to *find* the relevant notation and
    the implicit group structure, using the information that is found in the expressions
    that we type. Similarly, when we write `x + y` with expressions `x` and `y` that
    have type `ℝ`, Lean needs to interpret the `+` symbol as the relevant addition
    function on the reals. It also has to recognize the type `ℝ` as an instance of
    a commutative ring, so that all the definitions and theorems for a commutative
    ring are available. For another example, continuity is defined in Lean relative
    to any two topological spaces. When we have `f : ℝ → ℂ` and we write `Continuous
    f`, Lean has to find the relevant topologies on `ℝ` and `ℂ`.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '问题在于Lean需要能够*找到*相关的符号和隐含的群结构，使用我们在输入的表达式中找到的信息。同样，当我们用具有类型`ℝ`的表达式`x`和`y`来写`x
    + y`时，Lean需要将`+`符号解释为实数上的相关加法函数。它还必须识别类型`ℝ`作为交换环的一个实例，这样所有交换环的定义和定理都可用。例如，连续性在Lean中相对于任何两个拓扑空间定义。当我们有`f
    : ℝ → ℂ`并写`Continuous f`时，Lean必须找到`ℝ`和`ℂ`上的相关拓扑。'
- en: The magic is achieved with a combination of three things.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这个魔法是通过三个事物的结合实现的。
- en: '*Logic.* A definition that should be interpreted in any group takes, as arguments,
    the type of the group and the group structure as arguments. Similarly, a theorem
    about the elements of an arbitrary group begins with universal quantifiers over
    the type of the group and the group structure.'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*逻辑*。任何群中应被解释的定义，其参数是群类型和群结构。同样，关于任意群元素的定理以对群类型和群结构的全称量词开始。'
- en: '*Implicit arguments.* The arguments for the type and the structure are generally
    left implicit, so that we do not have to write them or see them in the Lean information
    window. Lean fills the information in for us silently.'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*隐含参数*。类型和结构的参数通常被省略，这样我们就不必写它们或在Lean信息窗口中看到它们。Lean会默默地为我们填写信息。'
- en: '*Type class inference.* Also known as *class inference*, this is a simple but
    powerful mechanism that enables us to register information for Lean to use later
    on. When Lean is called on to fill in implicit arguments to a definition, theorem,
    or piece of notation, it can make use of information that has been registered.'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*类型类推断*。也称为*类推断*，这是一个简单但强大的机制，使我们能够为Lean注册信息以便以后使用。当Lean被调用以填充定义、定理或符号中的隐含参数时，它可以利用已注册的信息。'
- en: 'Whereas an annotation `(grp : Group G)` tells Lean that it should expect to
    be given that argument explicitly and the annotation `{grp : Group G}` tells Lean
    that it should try to figure it out from contextual cues in the expression, the
    annotation `[grp : Group G]` tells Lean that the corresponding argument should
    be synthesized using type class inference. Since the whole point to the use of
    such arguments is that we generally do not need to refer to them explicitly, Lean
    allows us to write `[Group G]` and leave the name anonymous. You have probably
    already noticed that Lean chooses names like `_inst_1` automatically. When we
    use the anonymous square-bracket annotation with the `variables` command, then
    as long as the variables are still in scope, Lean automatically adds the argument
    `[Group G]` to any definition or theorem that mentions `G`.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '而一个注解`(grp : Group G)`告诉Lean它应该期望显式地给出该参数，注解`{grp : Group G}`告诉Lean它应该尝试从表达式的上下文中推断出来，注解`[grp
    : Group G]`告诉Lean相应的参数应该通过类型类推断来合成。由于使用此类参数的整个目的通常是我们不需要显式地引用它们，Lean允许我们写`[Group
    G]`并使名称匿名。你可能已经注意到Lean会自动选择像`_inst_1`这样的名称。当我们使用匿名方括号注解与`variables`命令一起使用时，只要变量仍然在作用域内，Lean就会自动将参数`[Group
    G]`添加到任何提及`G`的定义或定理中。'
- en: How do we register the information that Lean needs to use to carry out the search?
    Returning to our group example, we need only make two changes. First, instead
    of using the `structure` command to define the group structure, we use the keyword
    `class` to indicate that it is a candidate for class inference. Second, instead
    of defining particular instances with `def`, we use the keyword `instance` to
    register the particular instance with Lean. As with the names of class variables,
    we are allowed to leave the name of an instance definition anonymous, since in
    general we intend Lean to find it and put it to use without troubling us with
    the details.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何注册Lean执行搜索所需的信息？回到我们的群组例子，我们只需要做两个更改。首先，我们不是使用`structure`命令来定义群结构，而是使用关键字`class`来表示它是类推断的候选。其次，我们不是使用`def`定义特定的实例，而是使用关键字`instance`将特定的实例注册到Lean中。与类变量名一样，我们可以省略实例定义的名称，因为在一般情况下，我们希望Lean找到它并投入使用，而不必麻烦我们处理细节。
- en: '[PRE79]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The following illustrates their use.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以下说明了它们的使用。
- en: '[PRE80]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `#check` command shows that `Group₂.mul` has an implicit argument `[Group₂
    α]` that we expect to be found by class inference, where `α` is the type of the
    arguments to `Group₂.mul`. In other words, `{α : Type*}` is the implicit argument
    for the type of the group elements and `[Group₂ α]` is the implicit argument for
    the group structure on `α`. Similarly, when we define a generic squaring function
    `my_square` for `Group₂`, we use an implicit argument `{α : Type*}` for the type
    of the elements and an implicit argument `[Group₂ α]` for the `Group₂` structure.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`#check`命令显示`Group₂.mul`有一个隐含的参数`[Group₂ α]`，我们期望通过类推断找到它，其中`α`是`Group₂.mul`参数的类型。换句话说，`{α
    : Type*}`是群元素类型的隐含参数，`[Group₂ α]`是`α`上的群结构的隐含参数。同样，当我们为`Group₂`定义一个泛型平方函数`my_square`时，我们使用一个隐含参数`{α
    : Type*}`作为元素类型，以及一个隐含参数`[Group₂ α]`作为`Group₂`结构。'
- en: In the first example, when we write `Group₂.mul f g`, the type of `f` and `g`
    tells Lean that in the argument `α` to `Group₂.mul` has to be instantiated to
    `Equiv.Perm β`. That means that Lean has to find an element of `Group₂ (Equiv.Perm
    β)`. The previous `instance` declaration tells Lean exactly how to do that. Problem
    solved!
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，当我们写`Group₂.mul f g`时，`f`和`g`的类型告诉Lean，在`Group₂.mul`的参数`α`中必须实例化为`Equiv.Perm
    β`。这意味着Lean必须找到一个`Group₂ (Equiv.Perm β)`的元素。之前的`instance`声明告诉Lean如何做到这一点。问题解决！
- en: 'This simple mechanism for registering information so that Lean can find it
    when it needs it is remarkably useful. Here is one way it comes up. In Lean’s
    foundation, a data type `α` may be empty. In a number of applications, however,
    it is useful to know that a type has at least one element. For example, the function
    `List.headI`, which returns the first element of a list, can return the default
    value when the list is empty. To make that work, the Lean library defines a class
    `Inhabited α`, which does nothing more than store a default value. We can show
    that the `Point` type is an instance:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的信息注册机制，使得Lean在需要时能够找到它，非常有用。这里有一种它出现的方式。在Lean的基础中，数据类型`α`可能是空的。然而，在许多应用中，知道一个类型至少有一个元素是有用的。例如，函数`List.headI`，它返回列表的第一个元素，当列表为空时可以返回默认值。为了实现这一点，Lean库定义了一个类`Inhabited
    α`，它所做的只是存储一个默认值。我们可以证明`Point`类型是一个实例：
- en: '[PRE81]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The class inference mechanism is also used for generic notation. The expression
    `x + y` is an abbreviation for `Add.add x y` where—you guessed it—`Add α` is a
    class that stores a binary function on `α`. Writing `x + y` tells Lean to find
    a registered instance of `[Add.add α]` and use the corresponding function. Below,
    we register the addition function for `Point`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 类推断机制也用于泛型表示。表达式`x + y`是`Add.add x y`的缩写，其中——你可能已经猜到了——`Add α`是一个存储在`α`上的二元函数的类。写`x
    + y`告诉Lean找到已注册的`[Add.add α]`实例，并使用相应的函数。下面，我们注册了`Point`的加法函数。
- en: '[PRE82]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In this way, we can assign the notation `+` to binary operations on other types
    as well.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们还可以将符号`+`分配给其他类型上的二元运算。
- en: 'But we can do even better. We have seen that `*` can be used in any group,
    `+` can be used in any additive group, and both can be used in any ring. When
    we define a new instance of a ring in Lean, we don’t have to define `+` and `*`
    for that instance, because Lean knows that these are defined for every ring. We
    can use this method to specify notation for our `Group₂` class:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以做得更好。我们已经看到 `*` 可以在任何群中使用，`+` 可以在任何加法群中使用，并且两者都可以在任何环中使用。当我们定义 Lean 中的新环实例时，我们不需要为该实例定义
    `+` 和 `*`，因为 Lean 知道这些在每一个环中都是定义好的。我们可以使用这种方法来指定 `Group₂` 类的符号：
- en: '[PRE83]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: What makes this approach work is that Lean carries out a recursive search. According
    to the instances we have declared, Lean can find an instance of `Mul (Equiv.Perm
    α)` by finding an instance of `Group₂ (Equiv.Perm α)`, and it can find an instance
    of `Group₂ (Equiv.Perm α)` because we have provided one. Lean is capable of finding
    these two facts and chaining them together.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法之所以有效，是因为 Lean 进行了递归搜索。根据我们声明的实例，Lean 可以通过找到一个 `Group₂ (Equiv.Perm α)` 的实例来找到一个
    `Mul (Equiv.Perm α)` 的实例，并且它可以通过我们提供的一个实例来找到一个 `Group₂ (Equiv.Perm α)` 的实例。Lean
    能够找到这两个事实并将它们连接起来。
- en: The example we have just given is dangerous, because Lean’s library also has
    an instance of `Group (Equiv.Perm α)`, and multiplication is defined on any group.
    So it is ambiguous as to which instance is found. In fact, Lean favors more recent
    declarations unless you explicitly specify a different priority. Also, there is
    another way to tell Lean that one structure is an instance of another, using the
    `extends` keyword. This is how Mathlib specifies that, for example, every commutative
    ring is a ring. You can find more information in [Section 8](C08_Hierarchies.html#hierarchies)
    and in a [section on class inference](https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html#managing-type-class-inference)
    in *Theorem Proving in Lean*.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才给出的例子是危险的，因为 Lean 的库中也有一个 `Group (Equiv.Perm α)` 的实例，并且乘法在任意群上都是定义好的。所以，哪个实例被找到是不确定的。实际上，Lean
    优先考虑较新的声明，除非你明确指定了不同的优先级。此外，还有另一种方法告诉 Lean 一个结构是另一个结构的实例，即使用 `extends` 关键字。这就是
    Mathlib 如何指定，例如，每个交换环都是一个环。你可以在[第 8 节](C08_Hierarchies.html#hierarchies)和*《Lean
    中的定理证明》*中的一个关于类推断的[章节](https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html#managing-type-class-inference)中找到更多信息。
- en: In general, it is a bad idea to specify a value of `*` for an instance of an
    algebraic structure that already has the notation defined. Redefining the notion
    of `Group` in Lean is an artificial example. In this case, however, both interpretations
    of the group notation unfold to `Equiv.trans`, `Equiv.refl`, and `Equiv.symm`,
    in the same way.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为已经定义了符号的代数结构实例指定 `*` 的值是一个坏主意。在 Lean 中重新定义 `Group` 的概念是一个人为的例子。然而，在这种情况下，群符号的两种解释都展开为
    `Equiv.trans`、`Equiv.refl` 和 `Equiv.symm`，方式相同。
- en: As a similarly artificial exercise, define a class `AddGroup₂` in analogy to
    `Group₂`. Define the usual notation for addition, negation, and zero on any `AddGroup₂`
    using the classes `Add`, `Neg`, and `Zero`. Then show `Point` is an instance of
    `AddGroup₂`. Try it out and make sure that the additive group notation works for
    elements of `Point`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 作为类似的人为练习，定义一个类似于 `Group₂` 的类 `AddGroup₂`。使用类 `Add`、`Neg` 和 `Zero` 在任何 `AddGroup₂`
    上定义加法、负数和零的常规符号。然后证明 `Point` 是 `AddGroup₂` 的一个实例。尝试一下，确保加法群符号对 `Point` 的元素有效。
- en: '[PRE84]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: It is not a big problem that we have already declared instances `Add`, `Neg`,
    and `Zero` for `Point` above. Once again, the two ways of synthesizing the notation
    should come up with the same answer.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上面的 `Point` 中声明了实例 `Add`、`Neg` 和 `Zero` 并不是什么大问题。再次强调，两种合成符号的方法应该得出相同的答案。
- en: 'Class inference is subtle, and you have to be careful when using it, because
    it configures automation that invisibly governs the interpretation of the expressions
    we type. When used wisely, however, class inference is a powerful tool. It is
    what makes algebraic reasoning possible in Lean.  ## 7.3\. Building the Gaussian
    Integers[](#building-the-gaussian-integers "Link to this heading")'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 类推断是微妙的，使用时必须小心，因为它配置了自动化的设置，这些设置无形中控制着我们输入的表达式的解释。然而，如果使用得当，类推断是一个强大的工具。它是使
    Lean 中的代数推理成为可能的原因。## 7.3\. 构建高斯整数[](#building-the-gaussian-integers "链接到这个标题")
- en: We will now illustrate the use of the algebraic hierarchy in Lean by building
    an important mathematical object, the *Gaussian integers*, and showing that it
    is a Euclidean domain. In other words, according to the terminology we have been
    using, we will define the Gaussian integers and show that they are an instance
    of the Euclidean domain structure.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将通过构建一个重要的数学对象，即高斯整数，并展示它是一个欧几里得域，来展示在Lean中使用代数层次结构的用法。换句话说，根据我们一直在使用的术语，我们将定义高斯整数并展示它们是欧几里得域结构的实例。
- en: In ordinary mathematical terms, the set of Gaussian integers \(\Bbb{Z}[i]\)
    is the set of complex numbers \(\{ a + b i \mid a, b \in \Bbb{Z}\}\). But rather
    than define them as a subset of the complex numbers, our goal here is to define
    them as a data type in their own right. We do this by representing a Gaussian
    integer as a pair of integers, which we think of as the *real* and *imaginary*
    parts.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在普通数学术语中，高斯整数集 \(\Bbb{Z}[i]\) 是复数集 \(\{ a + b i \mid a, b \in \Bbb{Z}\}\)。但与其将它们定义为复数的子集，我们的目标在这里是将它们定义为它们自己的数据类型。我们通过将高斯整数表示为整数对来实现这一点，我们将这些整数视为*实部*和*虚部*。
- en: '[PRE85]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We first show that the Gaussian integers have the structure of a ring, with
    `0` defined to be `⟨0, 0⟩`, `1` defined to be `⟨1, 0⟩`, and addition defined pointwise.
    To work out the definition of multiplication, remember that we want the element
    \(i\), represented by `⟨0, 1⟩`, to be a square root of \(-1\). Thus we want
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先展示高斯整数具有环的结构，其中`0`被定义为`⟨0, 0⟩`，`1`被定义为`⟨1, 0⟩`，加法被定义为逐点加法。为了确定乘法定义，记住我们希望元素
    \(i\)，由`⟨0, 1⟩`表示，是 \(-1\) 的一个平方根。因此我们希望
- en: \[\begin{split}(a + bi) (c + di) & = ac + bci + adi + bd i^2 \\ & = (ac - bd)
    + (bc + ad)i.\end{split}\]
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}(a + bi) (c + di) & = ac + bci + adi + bd i^2 \\ & = (ac - bd)
    + (bc + ad)i.\end{split}\]
- en: This explains the definition of `Mul` below.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了下面`Mul`的定义。
- en: '[PRE86]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: As noted in [Section 7.1](#section-structures), it is a good idea to put all
    the definitions related to a data type in a namespace with the same name. Thus
    in the Lean files associated with this chapter, these definitions are made in
    the `GaussInt` namespace.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第7.1节](#section-structures) 所述，将所有与数据类型相关的定义放在具有相同名称的命名空间中是一个好主意。因此，在本章相关的Lean文件中，这些定义是在`GaussInt`命名空间中进行的。
- en: Notice that here we are defining the interpretations of the notation `0`, `1`,
    `+`, `-`, and `*` directly, rather than naming them `GaussInt.zero` and the like
    and assigning the notation to those. It is often useful to have an explicit name
    for the definitions, for example, to use with `simp` and `rw`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里我们直接定义了符号 `0`、`1`、`+`、`-` 和 `*` 的解释，而不是将它们命名为 `GaussInt.zero` 等等，并将符号分配给它们。对于与
    `simp` 和 `rw` 一起使用，有一个明确的名称对于定义来说通常是有用的。
- en: '[PRE87]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: It is also useful to name the rules that compute the real and imaginary parts,
    and to declare them to the simplifier.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 也有必要命名计算实部和虚部的规则，并将它们声明给简化器。
- en: '[PRE88]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: It is now surprisingly easy to show that the Gaussian integers are an instance
    of a commutative ring. We are putting the structure concept to good use. Each
    particular Gaussian integer is an instance of the `GaussInt` structure, whereas
    the type `GaussInt` itself, together with the relevant operations, is an instance
    of the `CommRing` structure. The `CommRing` structure, in turn, extends the notational
    structures `Zero`, `One`, `Add`, `Neg`, and `Mul`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在证明高斯整数是交换环的实例变得出奇地简单。我们正在充分利用结构概念。每个特定的高斯整数是`GaussInt`结构的实例，而类型`GaussInt`本身，连同相关操作，是`CommRing`结构的实例。`CommRing`结构反过来又扩展了`Zero`、`One`、`Add`、`Neg`和`Mul`的符号结构。
- en: 'If you type `instance : CommRing GaussInt := _`, click on the light bulb that
    appears in VS Code, and then ask Lean to fill in a skeleton for the structure
    definition, you will see a scary number of entries. Jumping to the definition
    of the structure, however, shows that many of the fields have default definitions
    that Lean will fill in for you automatically. The essential ones appear in the
    definition below. A special case are `nsmul` and `zsmul` which should be ignored
    for now and will be explained in the next chapter. In each case, the relevant
    identity is proved by unfolding definitions, using the `ext` tactic to reduce
    the identities to their real and imaginary components, simplifying, and, if necessary,
    carrying out the relevant ring calculation in the integers. Note that we could
    easily avoid repeating all this code, but this is not the topic of the current
    discussion.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你输入 `instance : CommRing GaussInt := _`，然后在 VS Code 中点击出现的灯泡，然后让 Lean 填写结构定义的骨架，你会看到很多条目。然而，跳转到结构的定义，你会发现许多字段都有默认定义，Lean
    会自动为你填写。下面定义的是基本的部分。一个特殊情况是 `nsmul` 和 `zsmul`，现在可以忽略它们，将在下一章中解释。在每种情况下，相关恒等式都是通过展开定义、使用
    `ext` 策略将恒等式简化到其实部和虚部、简化，并在必要时在整数中进行相关环计算来证明的。请注意，我们可以轻松避免重复所有这些代码，但这不是当前讨论的主题。'
- en: '[PRE89]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Lean’s library defines the class of *nontrivial* types to be types with at least
    two distinct elements. In the context of a ring, this is equivalent to saying
    that the zero is not equal to the one. Since some common theorems depend on that
    fact, we may as well establish it now.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 的库定义**非平凡**类型为至少有两个不同元素的类型。在环的上下文中，这相当于说零不等于一。由于一些常见的定理依赖于这个事实，我们不妨现在就建立它。
- en: '[PRE90]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We will now show that the Gaussian integers have an important additional property.
    A *Euclidean domain* is a ring \(R\) equipped with a *norm* function \(N : R \to
    \mathbb{N}\) with the following two properties:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '我们现在将展示高斯整数具有一个重要的附加属性。一个**欧几里得域**是一个带有**范数**函数 \(N : R \to \mathbb{N}\) 的环
    \(R\)，它具有以下两个性质：'
- en: For every \(a\) and \(b \ne 0\) in \(R\), there are \(q\) and \(r\) in \(R\)
    such that \(a = bq + r\) and either \(r = 0\) or \(N(r) < N(b)\).
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 \(R\) 中的每个 \(a\) 和 \(b \ne 0\)，存在 \(q\) 和 \(r\) 在 \(R\) 中，使得 \(a = bq + r\)，并且要么
    \(r = 0\)，要么 \(N(r) < N(b)\)。
- en: For every \(a\) and \(b \ne 0\), \(N(a) \le N(ab)\).
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个 \(a\) 和 \(b \ne 0\)，\(N(a) \le N(ab)\)。
- en: 'The ring of integers \(\Bbb{Z}\) with \(N(a) = |a|\) is an archetypal example
    of a Euclidean domain. In that case, we can take \(q\) to be the result of integer
    division of \(a\) by \(b\) and \(r\) to be the remainder. These functions are
    defined in Lean so that the satisfy the following:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 整数环 \(\Bbb{Z}\) 与 \(N(a) = |a|\) 是欧几里得域的一个典型例子。在这种情况下，我们可以取 \(q\) 为 \(a\) 除以
    \(b\) 的整数除法的结果，\(r\) 为余数。这些函数在 Lean 中定义，以满足以下条件：
- en: '[PRE91]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: In an arbitrary ring, an element \(a\) is said to be a *unit* if it divides
    \(1\). A nonzero element \(a\) is said to be *irreducible* if it cannot be written
    in the form \(a = bc\) where neither \(b\) nor \(c\) is a unit. In the integers,
    every irreducible element \(a\) is *prime*, which is to say, whenever \(a\) divides
    a product \(bc\), it divides either \(b\) or \(c\). But in other rings this property
    can fail. In the ring \(\Bbb{Z}[\sqrt{-5}]\), we have
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个任意的环中，一个元素 \(a\) 被称为**单位**，如果它能整除 \(1\)。一个非零元素 \(a\) 被称为**不可约**的，如果它不能写成形式
    \(a = bc\)，其中 \(b\) 和 \(c\) 都不是单位。在整数中，每个不可约元素 \(a\) 都是**素数**，也就是说，每当 \(a\) 整除一个乘积
    \(bc\) 时，它要么整除 \(b\)，要么整除 \(c\)。但在其他环中，这个性质可能不成立。在环 \(\Bbb{Z}[\sqrt{-5}]\) 中，我们有
- en: \[6 = 2 \cdot 3 = (1 + \sqrt{-5})(1 - \sqrt{-5}),\]
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: \[6 = 2 \cdot 3 = (1 + \sqrt{-5})(1 - \sqrt{-5}),\]
- en: 'and the elements \(2\), \(3\), \(1 + \sqrt{-5}\), and \(1 - \sqrt{-5}\) are
    all irreducible, but they are not prime. For example, \(2\) divides the product
    \((1 + \sqrt{-5})(1 - \sqrt{-5})\), but it does not divide either factor. In particular,
    we no longer have unique factorization: the number \(6\) can be factored into
    irreducible elements in more than one way.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 并且元素 \(2\)、\(3\)、\(1 + \sqrt{-5}\) 和 \(1 - \sqrt{-5}\) 都是不可约的，但它们不是素数。例如，\(2\)
    整除乘积 \((1 + \sqrt{-5})(1 - \sqrt{-5})\)，但它不整除任何一个因子。特别是，我们不再有唯一的分解：数字 \(6\) 可以以多种方式分解为不可约元素。
- en: In contrast, every Euclidean domain is a unique factorization domain, which
    implies that every irreducible element is prime. The axioms for a Euclidean domain
    imply that one can write any nonzero element as a finite product of irreducible
    elements. They also imply that one can use the Euclidean algorithm to find a greatest
    common divisor of any two nonzero elements `a` and `b`, i.e. an element that is
    divisible by any other common divisor. This, in turn, implies that factorization
    into irreducible elements is unique up to multiplication by units.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，每个欧几里得整环都是一个唯一分解整环，这意味着每个不可约元素都是素数。欧几里得整环的公理意味着任何一个非零元素都可以表示为不可约元素的有限乘积。它们还意味着可以使用欧几里得算法找到任意两个非零元素
    \(a\) 和 \(b\) 的最大公约数，即可以被任何其他公约数整除的元素。这反过来又意味着不可约元素的分解是唯一的，直到乘以单位元素。
- en: We now show that the Gaussian integers are a Euclidean domain with the norm
    defined by \(N(a + bi) = (a + bi)(a - bi) = a^2 + b^2\). The Gaussian integer
    \(a - bi\) is called the *conjugate* of \(a + bi\). It is not hard to check that
    for any complex numbers \(x\) and \(y\), we have \(N(xy) = N(x)N(y)\).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们证明高斯整数是具有由 \(N(a + bi) = (a + bi)(a - bi) = a^2 + b^2\) 定义的范数的欧几里得整环。高斯整数
    \(a - bi\) 被称为 \(a + bi\) 的**共轭**。对于任何复数 \(x\) 和 \(y\)，我们不难验证 \(N(xy) = N(x)N(y)\)。
- en: To see that this definition of the norm makes the Gaussian integers a Euclidean
    domain, only the first property is challenging. Suppose we want to write \(a +
    bi = (c + di) q + r\) for suitable \(q\) and \(r\). Treating \(a + bi\) and \(c
    + di\) as complex numbers, carry out the division
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 要证明这种范数的定义使得高斯整数成为一个欧几里得整环，只有第一个性质是具有挑战性的。假设我们想要将 \(a + bi\) 写成 \(a + bi = (c
    + di) q + r\) 的形式，其中 \(q\) 和 \(r\) 是合适的。将 \(a + bi\) 和 \(c + di\) 作为复数处理，进行除法
- en: \[\frac{a + bi}{c + di} = \frac{(a + bi)(c - di)}{(c + di)(c-di)} = \frac{ac
    + bd}{c^2 + d^2} + \frac{bc -ad}{c^2+d^2} i.\]
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: \[\frac{a + bi}{c + di} = \frac{(a + bi)(c - di)}{(c + di)(c-di)} = \frac{ac
    + bd}{c^2 + d^2} + \frac{bc -ad}{c^2+d^2} i.\]
- en: The real and imaginary parts might not be integers, but we can round them to
    the nearest integers \(u\) and \(v\). We can then express the right-hand side
    as \((u + vi) + (u' + v'i)\), where \(u' + v'i\) is the part left over. Note that
    we have \(|u'| \le 1/2\) and \(|v'| \le 1/2\), and hence
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 实部和虚部可能不是整数，但我们可以将它们四舍五入到最近的整数 \(u\) 和 \(v\)。然后我们可以将右侧表示为 \((u + vi) + (u' +
    v'i)\)，其中 \(u' + v'i\) 是剩余的部分。注意，我们有 \(|u'| \le 1/2\) 和 \(|v'| \le 1/2\)，因此
- en: \[N(u' + v' i) = (u')^2 + (v')^2 \le 1/4 + 1/4 \le 1/2.\]
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: \[N(u' + v' i) = (u')^2 + (v')^2 \le 1/4 + 1/4 \le 1/2.\]
- en: Multiplying through by \(c + di\), we have
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 乘以 \(c + di\)，我们得到
- en: \[a + bi = (c + di) (u + vi) + (c + di) (u' + v'i).\]
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: \[a + bi = (c + di) (u + vi) + (c + di) (u' + v'i).\]
- en: 'Setting \(q = u + vi\) and \(r = (c + di) (u'' + v''i)\), we have \(a + bi
    = (c + di) q + r\), and we only need to bound \(N(r)\):'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 令 \(q = u + vi\) 和 \(r = (c + di) (u' + v'i)\)，我们有 \(a + bi = (c + di) q + r\)，我们只需要界定
    \(N(r)\)：
- en: \[N(r) = N(c + di)N(u' + v'i) \le N(c + di) \cdot 1/2 < N(c + di).\]
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: \[N(r) = N(c + di)N(u' + v'i) \le N(c + di) \cdot 1/2 < N(c + di).\]
- en: The argument we just carried out requires viewing the Gaussian integers as a
    subset of the complex numbers. One option for formalizing it in Lean is therefore
    to embed the Gaussian integers in the complex numbers, embed the integers in the
    Gaussian integers, define the rounding function from the real numbers to the integers,
    and take great care to pass back and forth between these number systems appropriately.
    In fact, this is exactly the approach that is followed in Mathlib, where the Gaussian
    integers themselves are constructed as a special case of a ring of *quadratic
    integers*. See the file [GaussianInt.lean](https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/NumberTheory/Zsqrtd/GaussianInt.lean).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才进行的论证需要将高斯整数视为复数集的一个子集。因此，在 Lean 中形式化它的一个选项是将高斯整数嵌入到复数中，将整数嵌入到高斯整数中，定义从实数到整数的舍入函数，并非常小心地在这些数系之间进行适当的转换。实际上，这正是
    Mathlib 中所采用的方法，其中高斯整数本身被构造为**二次整数环**的一个特例。参见文件 [GaussianInt.lean](https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/NumberTheory/Zsqrtd/GaussianInt.lean)。
- en: 'Here we will instead carry out an argument that stays in the integers. This
    illustrates a choice one commonly faces when formalizing mathematics. Given an
    argument that requires concepts or machinery that is not already in the library,
    one has two choices: either formalize the concepts and machinery needed, or adapt
    the argument to make use of concepts and machinery you already have. The first
    choice is generally a good investment of time when the results can be used in
    other contexts. Pragmatically speaking, however, sometimes seeking a more elementary
    proof is more efficient.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将执行一个始终保持在整数范围内的论证。这说明了在形式化数学时人们常常面临的一个选择。给定一个需要或机器不在库中的概念或工具的论证，你有两个选择：要么形式化所需的概念和工具，要么调整论证以利用你已有的概念和工具。当结果可以在其他上下文中使用时，第一个选择通常是值得投入时间的。然而，从实用主义的角度来看，有时寻找一个更基础的证明可能更有效。
- en: The usual quotient-remainder theorem for the integers says that for every \(a\)
    and nonzero \(b\), there are \(q\) and \(r\) such that \(a = b q + r\) and \(0
    \le r < b\). Here we will make use of the following variation, which says that
    there are \(q'\) and \(r'\) such that \(a = b q' + r'\) and \(|r'| \le b/2\).
    You can check that if the value of \(r\) in the first statement satisfies \(r
    \le b/2\), we can take \(q' = q\) and \(r' = r\), and otherwise we can take \(q'
    = q + 1\) and \(r' = r - b\). We are grateful to Heather Macbeth for suggesting
    the following more elegant approach, which avoids definition by cases. We simply
    add `b / 2` to `a` before dividing and then subtract it from the remainder.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 整数的通常的商余定理表明，对于每一个 \(a\) 和非零的 \(b\)，存在 \(q\) 和 \(r\) 使得 \(a = b q + r\) 且 \(0
    \le r < b\)。在这里，我们将利用以下变体，它表明存在 \(q'\) 和 \(r'\) 使得 \(a = b q' + r'\) 且 \(|r'|
    \le b/2\)。你可以检查，如果第一个陈述中的 \(r\) 的值满足 \(r \le b/2\)，我们可以取 \(q' = q\) 和 \(r' = r\)，否则我们可以取
    \(q' = q + 1\) 和 \(r' = r - b\)。我们感谢 Heather Macbeth 提出以下更优雅的方法，它避免了分情况定义。我们只是在除法之前将
    `b / 2` 加到 `a` 上，然后从余数中减去它。
- en: '[PRE92]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Note the use of our old friend, `linarith`. We will also need to express `mod'`
    in terms of `div'`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们老朋友 `linarith` 的使用。我们还将需要用 `div'` 表达 `mod'`。
- en: '[PRE93]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: We will use the fact that \(x^2 + y^2\) is equal to zero if and only if \(x\)
    and \(y\) are both zero. As an exercise, we ask you to prove that this holds in
    any ordered ring.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 \(x^2 + y^2\) 仅当 \(x\) 和 \(y\) 都为零时等于零的事实。作为一个练习，我们要求你证明这在任何有序环中都成立。
- en: '[PRE94]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We will put all the remaining definitions and theorems in this section in the
    `GaussInt` namespace. First, we define the `norm` function and ask you to establish
    some of its properties. The proofs are all short.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个部分将所有剩余的定义和定理放入`GaussInt`命名空间中。首先，我们定义`norm`函数并要求你建立其一些性质。证明都是简短的。
- en: '[PRE95]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Next we define the conjugate function:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义共轭函数：
- en: '[PRE96]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Finally, we define division for the Gaussian integers with the notation `x /
    y`, that rounds the complex quotient to the nearest Gaussian integer. We use our
    bespoke `Int.div'` for that purpose. As we calculated above, if `x` is \(a + bi\)
    and `y` is \(c + di\), then the real and imaginary parts of `x / y` are the nearest
    integers to
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们用 `x / y` 的符号定义高斯整数的除法，它将复数商四舍五入到最接近的高斯整数。我们使用我们定制的 `Int.div'` 来实现这一点。正如我们上面计算的，如果
    `x` 是 \(a + bi\) 而 `y` 是 \(c + di\)，那么 `x / y` 的实部和虚部是
- en: \[\frac{ac + bd}{c^2 + d^2} \quad \text{and} \quad \frac{bc -ad}{c^2+d^2},\]
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: \[\frac{ac + bd}{c^2 + d^2} \quad \text{和} \quad \frac{bc -ad}{c^2+d^2},\]
- en: respectively. Here the numerators are the real and imaginary parts of \((a +
    bi) (c - di)\), and the denominators are both equal to the norm of \(c + di\).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 分别。在这里，分子是 \((a + bi) (c - di)\) 的实部和虚部，分母都是 \(c + di\) 的范数。
- en: '[PRE97]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Having defined `x / y`, We define `x % y` to be the remainder, `x - (x / y)
    * y`. As above, we record the definitions in the theorems `div_def` and `mod_def`
    so that we can use them with `simp` and `rw`.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了 `x / y` 之后，我们定义 `x % y` 为余数，`x - (x / y) * y`。如上所述，我们在定理 `div_def` 和 `mod_def`
    中记录这些定义，以便我们可以使用它们与 `simp` 和 `rw` 一起。
- en: '[PRE98]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: These definitions immediately yield `x = y * (x / y) + x % y` for every `x`
    and `y`, so all we need to do is show that the norm of `x % y` is less than the
    norm of `y` when `y` is not zero.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义立即给出了对于每个 `x` 和 `y` 的 `x = y * (x / y) + x % y`，所以我们只需要证明当 `y` 不为零时，`x %
    y` 的范数小于 `y` 的范数。
- en: We just defined the real and imaginary parts of `x / y` to be `div' (x * conj
    y).re (norm y)` and `div' (x * conj y).im (norm y)`, respectively. Calculating,
    we have
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义了 `x / y` 的实部和虚部为 `div' (x * conj y).re (norm y)` 和 `div' (x * conj y).im
    (norm y)`，分别。计算后，我们有
- en: '`(x % y) * conj y = (x - x / y * y) * conj y = x * conj y - x / y * (y * conj
    y)`'
  id: totrans-373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`(x % y) * conj y = (x - x / y * y) * conj y = x * conj y - x / y * (y * conj
    y)`'
- en: The real and imaginary parts of the right-hand side are exactly `mod' (x * conj
    y).re (norm y)` and `mod' (x * conj y).im (norm y)`. By the properties of `div'`
    and `mod'`, these are guaranteed to be less than or equal to `norm y / 2`. So
    we have
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的实部和虚部正好是 `mod' (x * conj y).re (norm y)` 和 `mod' (x * conj y).im (norm y)`。根据
    `div'` 和 `mod'` 的性质，这些值保证小于或等于 `norm y / 2`。因此我们有
- en: '`norm ((x % y) * conj y) ≤ (norm y / 2)^2 + (norm y / 2)^2 ≤ (norm y / 2) *
    norm y`.'
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`norm ((x % y) * conj y) ≤ (norm y / 2)^2 + (norm y / 2)^2 ≤ (norm y / 2) *
    norm y`。'
- en: On the other hand, we have
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们有
- en: '`norm ((x % y) * conj y) = norm (x % y) * norm (conj y) = norm (x % y) * norm
    y`.'
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`norm ((x % y) * conj y) = norm (x % y) * norm (conj y) = norm (x % y) * norm
    y`。'
- en: Dividing through by `norm y` we have `norm (x % y) ≤ (norm y) / 2 < norm y`,
    as required.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 通过除以 `norm y`，我们得到 `norm (x % y) ≤ (norm y) / 2 < norm y`，正如所需的那样。
- en: This messy calculation is carried out in the next proof. We encourage you to
    step through the details and see if you can find a nicer argument.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这个复杂的计算将在下一个证明中进行。我们鼓励你逐步查看细节，看看你是否能找到一个更好的论点。
- en: '[PRE99]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: We are in the home stretch. Our `norm` function maps Gaussian integers to nonnegative
    integers. We need a function that maps Gaussian integers to natural numbers, and
    we obtain that by composing `norm` with the function `Int.natAbs`, which maps
    integers to the natural numbers. The first of the next two lemmas establishes
    that mapping the norm to the natural numbers and back to the integers does not
    change the value. The second one re-expresses the fact that the norm is decreasing.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经接近终点。我们的 `norm` 函数将高斯整数映射到非负整数。我们需要一个将高斯整数映射到自然数的函数，我们通过将 `norm` 与函数 `Int.natAbs`（将整数映射到自然数）组合来实现这一点。接下来的两个引理中的第一个建立了将范数映射到自然数再映射回整数不会改变值的性质。第二个引理重新表述了范数是递减的事实。
- en: '[PRE100]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: We also need to establish the second key property of the norm function on a
    Euclidean domain.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要建立欧几里得域上范数函数的第二个关键性质。
- en: '[PRE101]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We can now put it together to show that the Gaussian integers are an instance
    of a Euclidean domain. We use the quotient and remainder function we have defined.
    The Mathlib definition of a Euclidean domain is more general than the one above
    in that it allows us to show that remainder decreases with respect to any well-founded
    measure. Comparing the values of a norm function that returns natural numbers
    is just one instance of such a measure, and in that case, the required properties
    are the theorems `natAbs_norm_mod_lt` and `not_norm_mul_left_lt_norm`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将其组合起来，以证明高斯整数是欧几里得域的一个实例。我们使用我们定义的商和余数函数。Mathlib 对欧几里得域的定义比上面的定义更通用，因为它允许我们证明余数与任何良基测度相关。比较返回自然数的范数函数的值只是这种测度的一个实例，在这种情况下，所需性质是定理
    `natAbs_norm_mod_lt` 和 `not_norm_mul_left_lt_norm`。
- en: '[PRE102]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: An immediate payoff is that we now know that, in the Gaussian integers, the
    notions of being prime and being irreducible coincide.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 一个直接的好处是，我们现在知道在高斯整数中，素数和不可约的概念是一致的。
- en: '[PRE103]  ## 7.1\. Defining structures[](#defining-structures "Link to this
    heading")'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE103]  ## 7.1\. 定义结构[](#defining-structures "链接到这个标题")'
- en: 'In the broadest sense of the term, a *structure* is a specification of a collection
    of data, possibly with constraints that the data is required to satisfy. An *instance*
    of the structure is a particular bundle of data satisfying the constraints. For
    example, we can specify that a point is a tuple of three real numbers:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个术语的最广泛意义上，一个 *结构* 是对一组数据的规范，可能包含数据必须满足的约束。结构的 *实例* 是满足这些约束的特定数据包。例如，我们可以指定一个点是三个实数的元组：
- en: '[PRE104]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The `@[ext]` annotation tells Lean to automatically generate theorems that can
    be used to prove that two instances of a structure are equal when their components
    are equal, a property known as *extensionality*.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`@[ext]` 注解告诉 Lean 自动生成定理，这些定理可以用来证明当结构的不同组件相等时，两个结构实例是相等的，这种性质称为 *外延性*。'
- en: '[PRE105]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: We can then define particular instances of the `Point` structure. Lean provides
    multiple ways of doing that.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以定义 `Point` 结构的特定实例。Lean 提供了多种实现方式。
- en: '[PRE106]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: In the first example, the fields of the structure are named explicitly. The
    function `Point.mk` referred to in the definition of `myPoint3` is known as the
    *constructor* for the `Point` structure, because it serves to construct elements.
    You can specify a different name if you want, like `build`.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，结构的字段被明确命名。在`myPoint3`的定义中提到的函数`Point.mk`被称为`Point`结构的*构造器*，因为它用于构建元素。如果你想，可以指定不同的名称，比如`build`。
- en: '[PRE107]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The next two examples show how to define functions on structures. Whereas the
    second example makes the `Point.mk` constructor explicit, the first example uses
    an anonymous constructor for brevity. Lean can infer the relevant constructor
    from the indicated type of `add`. It is conventional to put definitions and theorems
    associated with a structure like `Point` in a namespace with the same name. In
    the example below, because we have opened the `Point` namespace, the full name
    of `add` is `Point.add`. When the namespace is not open, we have to use the full
    name. But remember that it is often convenient to use anonymous projection notation,
    which allows us to write `a.add b` instead of `Point.add a b`. Lean interprets
    the former as the latter because `a` has type `Point`.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两个例子展示了如何在结构上定义函数。第二个例子使`Point.mk`构造器显式化，而第一个例子为了简洁使用了匿名构造器。Lean可以从`add`的指示类型推断出相关的构造器。将定义和与结构如`Point`相关的定理放在具有相同名称的命名空间中是一种惯例。在下面的例子中，因为我们已经打开了`Point`命名空间，所以`add`的全称是`Point.add`。当命名空间未打开时，我们必须使用全称。但请记住，使用匿名投影符号通常很方便，它允许我们写出`a.add
    b`而不是`Point.add a b`。Lean将前者解释为后者，因为`a`具有`Point`类型。
- en: '[PRE108]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Below we will continue to put definitions in the relevant namespace, but we
    will leave the namespacing commands out of the quoted snippets. To prove properties
    of the addition function, we can use `rw` to expand the definition and `ext` to
    reduce an equation between two elements of the structure to equations between
    the components. Below we use the `protected` keyword so that the name of the theorem
    is `Point.add_comm`, even when the namespace is open. This is helpful when we
    want to avoid ambiguity with a generic theorem like `add_comm`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 下面我们将继续在相关命名空间中放置定义，但我们将省略引用片段中的命名空间命令。为了证明加法函数的性质，我们可以使用`rw`来展开定义，并使用`ext`将结构中两个元素之间的等式简化为组件之间的等式。下面我们使用`protected`关键字，即使命名空间是开放的，定理的名称也是`Point.add_comm`。这在我们想要避免与通用定理如`add_comm`产生歧义时很有帮助。
- en: '[PRE109]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Because Lean can unfold definitions and simplify projections internally, sometimes
    the equations we want hold definitionally.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Lean可以内部展开定义并简化投影，有时我们想要的等式在定义上是成立的。
- en: '[PRE110]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: It is also possible to define functions on structures using pattern matching,
    in a manner similar to the way we defined recursive functions in [Section 5.2](C05_Elementary_Number_Theory.html#section-induction-and-recursion).
    The definitions `addAlt` and `addAlt'` below are essentially the same; the only
    difference is that we use anonymous constructor notation in the second. Although
    it is sometimes convenient to define functions this way, and structural eta-reduction
    makes this alternative definitionally equivalent, it can make things less convenient
    in later proofs. In particular, `rw [addAlt]` leaves us with a messier goal view
    containing a `match` statement.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模式匹配在结构上定义函数也是可能的，其方式与我们定义递归函数的方式类似，如[第5.2节](C05_Elementary_Number_Theory.html#section-induction-and-recursion)中所述。下面的`addAlt`和`addAlt'`定义本质上相同；唯一的区别在于我们在第二个中使用了匿名构造器符号。尽管有时以这种方式定义函数很方便，结构η-归约使得这种替代定义等价，但它可能会在后续的证明中使事情变得不那么方便。特别是，`rw
    [addAlt]`会给我们留下一个包含`match`语句的更混乱的目标视图。
- en: '[PRE111]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Mathematical constructions often involve taking apart bundled information and
    putting it together again in different ways. It therefore makes sense that Lean
    and Mathlib offer so many ways of doing this efficiently. As an exercise, try
    proving that `Point.add` is associative. Then define scalar multiplication for
    a point and show that it distributes over addition.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 数学构造通常涉及将捆绑的信息拆分开来，以不同的方式重新组合。因此，Lean和Mathlib提供多种高效执行此操作的方法是有意义的。作为练习，尝试证明`Point.add`是结合的。然后定义点的标量乘法，并证明它对加法是分配的。
- en: '[PRE112]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Using structures is only the first step on the road to algebraic abstraction.
    We don’t yet have a way to link `Point.add` to the generic `+` symbol, or to connect
    `Point.add_comm` and `Point.add_assoc` to the generic `add_comm` and `add_assoc`
    theorems. These tasks belong to the *algebraic* aspect of using structures, and
    we will explain how to carry them out in the next section. For now, just think
    of a structure as a way of bundling together objects and information.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 使用结构只是通往代数抽象道路上的第一步。我们还没有一种方法将 `Point.add` 与通用的 `+` 符号链接起来，或者将 `Point.add_comm`
    和 `Point.add_assoc` 与通用的 `add_comm` 和 `add_assoc` 公理联系起来。这些任务属于使用结构的 *代数* 方面，我们将在下一节中解释如何执行它们。现在，只需将结构视为将对象和信息捆绑在一起的方式。
- en: 'It is especially useful that a structure can specify not only data types but
    also constraints that the data must satisfy. In Lean, the latter are represented
    as fields of type `Prop`. For example, the *standard 2-simplex* is defined to
    be the set of points \((x, y, z)\) satisfying \(x ≥ 0\), \(y ≥ 0\), \(z ≥ 0\),
    and \(x + y + z = 1\). If you are not familiar with the notion, you should draw
    a picture, and convince yourself that this set is the equilateral triangle in
    three-space with vertices \((1, 0, 0)\), \((0, 1, 0)\), and \((0, 0, 1)\), together
    with its interior. We can represent it in Lean as follows:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 特别有用的是，结构不仅可以指定数据类型，还可以指定数据必须满足的约束。在 Lean 中，后者表示为 `Prop` 类型的字段。例如，*标准 2-单纯形*
    定义为满足 \(x ≥ 0\)、\(y ≥ 0\)、\(z ≥ 0\) 和 \(x + y + z = 1\) 的点集 \((x, y, z)\)。如果你不熟悉这个概念，你应该画一个图，并说服自己这个集合是三维空间中的等边三角形，其顶点为
    \((1, 0, 0)\)、\((0, 1, 0)\) 和 \((0, 0, 1)\)，以及其内部。我们可以在 Lean 中如下表示它：
- en: '[PRE113]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Notice that the last four fields refer to `x`, `y`, and `z`, that is, the first
    three fields. We can define a map from the two-simplex to itself that swaps `x`
    and `y`:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到最后四个字段指的是 `x`、`y` 和 `z`，即前三个字段。我们可以定义一个从二单纯形到自身的映射，该映射交换 `x` 和 `y`：
- en: '[PRE114]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: More interestingly, we can compute the midpoint of two points on the simplex.
    We have added the phrase `noncomputable section` at the beginning of this file
    in order to use division on the real numbers.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，我们可以在单纯形上计算两点之间的中点。我们在文件开头添加了“不可计算部分”这个短语，以便在实数上使用除法。
- en: '[PRE115]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Here we have established `x_nonneg`, `y_nonneg`, and `z_nonneg` with concise
    proof terms, but establish `sum_eq` in tactic mode, using `by`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们用简洁的证明项建立了 `x_nonneg`、`y_nonneg` 和 `z_nonneg`，但使用 `by` 在战术模式中建立 `sum_eq`。
- en: Given a parameter \(\lambda\) satisfying \(0 \le \lambda \le 1\), we can take
    the weighted average \(\lambda a + (1 - \lambda) b\) of two points \(a\) and \(b\)
    in the standard 2-simplex. We challenge you to define that function, in analogy
    to the `midpoint` function above.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个满足 \(0 \le \lambda \le 1\) 的参数 \(\lambda\)，我们可以在标准 2-单纯形上取两个点 \(a\) 和 \(b\)
    的加权平均 \(\lambda a + (1 - \lambda) b\)。我们挑战你定义这个函数，类似于上面的 `midpoint` 函数。
- en: '[PRE116]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Structures can depend on parameters. For example, we can generalize the standard
    2-simplex to the standard \(n\)-simplex for any \(n\). At this stage, you don’t
    have to know anything about the type `Fin n` except that it has \(n\) elements,
    and that Lean knows how to sum over it.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 结构可以依赖于参数。例如，我们可以将标准 2-单纯形推广到任何 \(n\) 的标准 \(n\)-单纯形。在这个阶段，你不必了解 `Fin n` 类型，除了它有
    \(n\) 个元素，以及 Lean 知道如何对它求和。
- en: '[PRE117]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: As an exercise, see if you can define the weighted average of two points in
    the standard \(n\)-simplex. You can use `Finset.sum_add_distrib` and `Finset.mul_sum`
    to manipulate the relevant sums.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，看看你是否可以定义标准 \(n\)-单纯形上两个点的加权平均。你可以使用 `Finset.sum_add_distrib` 和 `Finset.mul_sum`
    来操作相关的和。
- en: We have seen that structures can be used to bundle together data and properties.
    Interestingly, they can also be used to bundle together properties without the
    data. For example, the next structure, `IsLinear`, bundles together the two components
    of linearity.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，结构可以用来捆绑数据和属性。有趣的是，它们也可以用来捆绑属性而不包含数据。例如，下一个结构 `IsLinear` 捆绑了线性的两个组成部分。
- en: '[PRE118]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: It is worth pointing out that structures are not the only way to bundle together
    data. The `Point` data structure can be defined using the generic type product,
    and `IsLinear` can be defined with a simple `and`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，结构并不是捆绑数据的唯一方式。`Point` 数据结构可以使用通用类型积来定义，而 `IsLinear` 可以用简单的 `and` 定义。
- en: '[PRE119]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Generic type constructions can even be used in place of structures with dependencies
    between their components. For example, the *subtype* construction combines a piece
    of data with a property. You can think of the type `PReal` in the next example
    as being the type of positive real numbers. Any `x : PReal` has two components:
    the value, and the property of being positive. You can access these components
    as `x.val`, which has type `ℝ`, and `x.property`, which represents the fact `0
    < x.val`.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '通用类型构造甚至可以用来代替其组件之间有依赖关系的结构。例如，**子类型**构造将数据与属性结合起来。你可以在下一个示例中将类型`PReal`视为正实数的类型。任何`x
    : PReal`都有两个组件：值和正属性。你可以通过`x.val`访问这些组件，它具有类型`ℝ`，以及`x.property`，它代表`0 < x.val`的事实。'
- en: '[PRE120]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: We could have used subtypes to define the standard 2-simplex, as well as the
    standard \(n\)-simplex for an arbitrary \(n\).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用子类型来定义标准的2-单纯形，以及任意\(n\)的标准\(n\)-单纯形。
- en: '[PRE121]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Similarly, *Sigma types* are generalizations of ordered pairs, whereby the type
    of the second component depends on the type of the first.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，**Sigma类型**是有序对的推广，其中第二个组件的类型取决于第一个组件的类型。
- en: '[PRE122]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Given `s : StdSimplex`, the first component `s.fst` is a natural number, and
    the second component is an element of the corresponding simplex `StandardSimplex
    s.fst`. The difference between a Sigma type and a subtype is that the second component
    of a Sigma type is data rather than a proposition.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '给定`s : StdSimplex`，第一个组件`s.fst`是一个自然数，第二个组件是相应单纯形`StandardSimplex s.fst`的一个元素。Sigma类型与子类型之间的区别在于，Sigma类型的第二个组件是数据而不是命题。'
- en: 'But even though we can use products, subtypes, and Sigma types instead of structures,
    using structures has a number of advantages. Defining a structure abstracts away
    the underlying representation and provides custom names for the functions that
    access the components. This makes proofs more robust: proofs that rely only on
    the interface to a structure will generally continue to work when we change the
    definition, as long as we redefine the old accessors in terms of the new definition.
    Moreover, as we are about to see, Lean provides support for weaving structures
    together into a rich, interconnected hierarchy, and for managing the interactions
    between them.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以使用产品、子类型和Sigma类型来代替结构体，但使用结构体仍然具有许多优点。定义一个结构体会抽象出底层的表示，并为访问组件的函数提供自定义名称。这使得证明更加健壮：仅依赖于结构体接口的证明，在定义更改时通常仍然有效，只要我们用新的定义重新定义旧的访问器。此外，正如我们即将看到的，Lean提供了将结构体编织成丰富、相互关联的层次结构以及管理它们之间交互的支持。
- en: '## 7.2\. Algebraic Structures[](#algebraic-structures "Link to this heading")'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '## 7.2\. 代数结构[](#algebraic-structures "链接到这个标题")'
- en: To clarify what we mean by the phrase *algebraic structure*, it will help to
    consider some examples.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阐明我们所说的“代数结构”的含义，考虑一些例子会有所帮助。
- en: A *partially ordered set* consists of a set \(P\) and a binary relation \(\le\)
    on \(P\) that is transitive and reflexive.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个**偏序集**由一个集合\(P\)和一个在\(P\)上的传递且自反的二元关系\(\le\)组成。
- en: A *group* consists of a set \(G\) with an associative binary operation, an identity
    element \(1\), and a function \(g \mapsto g^{-1}\) that returns an inverse for
    each \(g\) in \(G\). A group is *abelian* or *commutative* if the operation is
    commutative.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个**群**由一个具有结合二元运算、单位元素\(1\)和函数\(g \mapsto g^{-1}\)的集合\(G\)组成，该函数为\(G\)中的每个\(g\)返回一个逆元素。如果运算是对称的，则群是**阿贝尔的**或**交换的**。
- en: A *lattice* is a partially ordered set with meets and joins.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个**格**是具有交集和并集的偏序集。
- en: A *ring* consists of an (additively written) abelian group \((R, +, 0, x \mapsto
    -x)\) together with an associative multiplication operation \(\cdot\) and an identity
    \(1\), such that multiplication distributes over addition. A ring is *commutative*
    if the multiplication is commutative.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个**环**由一个（加法表示的）阿贝尔群\((R, +, 0, x \mapsto -x)\)以及一个结合乘法运算\(\cdot\)和一个单位\(1\)组成，使得乘法对加法分配。如果乘法是交换的，则环是**交换的**。
- en: An *ordered ring* \((R, +, 0, -, \cdot, 1, \le)\) consists of a ring together
    with a partial order on its elements, such that \(a \le b\) implies \(a + c \le
    b + c\) for every \(a\), \(b\), and \(c\) in \(R\), and \(0 \le a\) and \(0 \le
    b\) implies \(0 \le a b\) for every \(a\) and \(b\) in \(R\).
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个**有序环**\((R, +, 0, -, \cdot, 1, \le)\)由一个环及其元素上的偏序组成，使得对于\(R\)中的每个\(a\)、\(b\)和\(c\)，\(a
    \le b\)意味着\(a + c \le b + c\)，并且\(0 \le a\)和\(0 \le b\)意味着对于\(R\)中的每个\(a\)和\(b\)，\(0
    \le a b\)。
- en: 'A *metric space* consists of a set \(X\) and a function \(d : X \times X \to
    \mathbb{R}\) such that the following hold:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '一个**度量空间**由一个集合 \(X\) 和一个函数 \(d : X \times X \to \mathbb{R}\) 组成，使得以下条件成立：'
- en: \(d(x, y) \ge 0\) for every \(x\) and \(y\) in \(X\).
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 \(X\) 中的每个 \(x\) 和 \(y\)，有 \(d(x, y) \ge 0\)。
- en: \(d(x, y) = 0\) if and only if \(x = y\).
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(d(x, y) = 0\) 当且仅当 \(x = y\)。
- en: \(d(x, y) = d(y, x)\) for every \(x\) and \(y\) in \(X\).
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 \(X\) 中的每个 \(x\) 和 \(y\)，有 \(d(x, y) = d(y, x)\)。
- en: \(d(x, z) \le d(x, y) + d(y, z)\) for every \(x\), \(y\), and \(z\) in \(X\).
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 \(X\) 中的每个 \(x\)，\(y\) 和 \(z\)，有 \(d(x, z) \le d(x, y) + d(y, z)\)。
- en: 'A *topological space* consists of a set \(X\) and a collection \(\mathcal T\)
    of subsets of \(X\), called the *open subsets of* \(X\), such that the following
    hold:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个**拓扑空间**由一个集合 \(X\) 和一个 \(X\) 的子集集合 \(\mathcal T\) 组成，称为 \(X\) 的**开子集**，使得以下条件成立：
- en: The empty set and \(X\) are open.
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空集和 \(X\) 是开集。
- en: The intersection of two open sets is open.
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个开集的交集是开集。
- en: An arbitrary union of open sets is open.
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开集的任意并集是开集。
- en: In each of these examples, the elements of the structure belong to a set, the
    *carrier set*, that sometimes stands proxy for the entire structure. For example,
    when we say “let \(G\) be a group” and then “let \(g \in G\),” we are using \(G\)
    to stand for both the structure and its carrier. Not every algebraic structure
    is associated with a single carrier set in this way. For example, a *bipartite
    graph* involves a relation between two sets, as does a *Galois connection*, A
    *category* also involves two sets of interest, commonly called the *objects* and
    the *morphisms*.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些例子中，结构的元素属于一个集合，称为**载体集**，有时它代表整个结构。例如，当我们说“设 \(G\) 为一个群”然后“设 \(g \in G\)”时，我们使用
    \(G\) 来代表结构和它的载体。并非每个代数结构都以这种方式与单个载体集相关联。例如，一个**二部图**涉及两个集合之间的关系，正如**高斯连接**一样，一个**范畴**也涉及两个感兴趣的集合，通常称为**对象**和**态射**。
- en: The examples indicate some of the things that a proof assistant has to do in
    order to support algebraic reasoning. First, it needs to recognize concrete instances
    of structures. The number systems \(\mathbb{Z}\), \(\mathbb{Q}\), and \(\mathbb{R}\)
    are all ordered rings, and we should be able to apply a generic theorem about
    ordered rings in any of these instances. Sometimes a concrete set may be an instance
    of a structure in more than one way. For example, in addition to the usual topology
    on \(\mathbb{R}\), which forms the basis for real analysis, we can also consider
    the *discrete* topology on \(\mathbb{R}\), in which every set is open.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 例子表明，证明辅助工具必须执行一些事情以支持代数推理。首先，它需要识别结构的具体实例。数系 \(\mathbb{Z}\)，\(\mathbb{Q}\)，和
    \(\mathbb{R}\) 都是序环，我们应该能够在这些实例中的任何一个上应用关于序环的通用定理。有时一个具体集合可能以多种方式成为某个结构的一个实例。例如，除了
    \(\mathbb{R}\) 上的通常拓扑，它是实分析的基础之外，我们还可以考虑 \(\mathbb{R}\) 上的**离散**拓扑，在这种拓扑中，每个集合都是开集。
- en: Second, a proof assistant needs to support generic notation on structures. In
    Lean, the notation `*` is used for multiplication in all the usual number systems,
    as well as for multiplication in generic groups and rings. When we use an expression
    like `f x * y`, Lean has to use information about the types of `f`, `x`, and `y`
    to determine which multiplication we have in mind.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，证明辅助工具需要支持结构上的通用符号。在 Lean 中，符号 `*` 用于所有常规数系中的乘法，以及用于通用群和环中的乘法。当我们使用像 `f x
    * y` 这样的表达式时，Lean 必须使用有关 `f`，`x` 和 `y` 的类型的信息来确定我们心中所想的乘法是什么。
- en: Third, it needs to deal with the fact that structures can inherit definitions,
    theorems, and notation from other structures in various ways. Some structures
    extend others by adding more axioms. A commutative ring is still a ring, so any
    definition that makes sense in a ring also makes sense in a commutative ring,
    and any theorem that holds in a ring also holds in a commutative ring. Some structures
    extend others by adding more data. For example, the additive part of any ring
    is an additive group. The ring structure adds a multiplication and an identity,
    as well as axioms that govern them and relate them to the additive part. Sometimes
    we can define one structure in terms of another. Any metric space has a canonical
    topology associated with it, the *metric space topology*, and there are various
    topologies that can be associated with any linear ordering.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，需要处理这样一个事实：结构可以通过各种方式从其他结构继承定义、定理和符号。一些结构通过添加更多的公理来扩展其他结构。交换环仍然是一个环，所以任何在环中具有意义的定义在交换环中也具有意义，任何在环中成立的定理在交换环中也成立。一些结构通过添加更多的数据来扩展其他结构。例如，任何环的加法部分是一个加法群。环结构添加了乘法和单位元，以及规范这些乘法和单位元并使其与加法部分相关联的公理。有时我们可以用另一个结构来定义一个结构。任何度量空间都有一个与之相关的典型拓扑，即*度量空间拓扑*，还有各种可以与任何线性顺序相关联的拓扑。
- en: Finally, it is important to keep in mind that mathematics allows us to use functions
    and operations to define structures in the same way we use functions and operations
    to define numbers. Products and powers of groups are again groups. For every \(n\),
    the integers modulo \(n\) form a ring, and for every \(k > 0\), the \(k \times
    k\) matrices of polynomials with coefficients in that ring again form a ring.
    Thus we can calculate with structures just as easily as we can calculate with
    their elements. This means that algebraic structures lead dual lives in mathematics,
    as containers for collections of objects and as objects in their own right. A
    proof assistant has to accommodate this dual role.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，重要的是要记住，数学允许我们使用函数和运算以定义结构的方式，就像我们使用函数和运算来定义数字一样。群的乘积和幂仍然是群。对于每一个\(n\)，模\(n\)的整数构成一个环，对于每一个\(k
    > 0\)，系数在该环中的\(k \times k\)多项式矩阵再次构成一个环。因此，我们可以像计算它们的元素一样容易地计算结构。这意味着代数结构在数学中过着双重生活，既是对象集合的容器，也是它们自身的对象。证明辅助工具必须适应这种双重角色。
- en: When dealing with elements of a type that has an algebraic structure associated
    with it, a proof assistant needs to recognize the structure and find the relevant
    definitions, theorems, and notation. All this should sound like a lot of work,
    and it is. But Lean uses a small collection of fundamental mechanisms to carry
    out these tasks. The goal of this section is to explain these mechanisms and show
    you how to use them.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理与代数结构相关联的类型元素时，证明辅助工具需要识别该结构并找到相关的定义、定理和符号。所有这些听起来像是一大堆工作，确实如此。但Lean使用一小套基本机制来完成这些任务。本节的目标是解释这些机制并展示如何使用它们。
- en: 'The first ingredient is almost too obvious to mention: formally speaking, algebraic
    structures are structures in the sense of [Section 7.1](#section-structures).
    An algebraic structure is a specification of a bundle of data satisfying some
    axiomatic hypotheses, and we saw in [Section 7.1](#section-structures) that this
    is exactly what the `structure` command is designed to accommodate. It’s a marriage
    made in heaven!'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个要素几乎是显而易见的：从形式上讲，代数结构是[第7.1节](#section-structures)意义上的结构。代数结构是一组满足某些公理假设的数据的规范，我们在[第7.1节](#section-structures)中看到，这正是`structure`命令设计用来适应的。这是一场天作之合！
- en: Given a data type `α`, we can define the group structure on `α` as follows.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个数据类型`α`，我们可以如下定义`α`上的群结构。
- en: '[PRE123]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Notice that the type `α` is a *parameter* in the definition of `Group₁`. So
    you should think of an object `struc : Group₁ α` as being a group structure on
    `α`. We saw in [Section 2.2](C02_Basics.html#proving-identities-in-algebraic-structures)
    that the counterpart `mul_inv_cancel` to `inv_mul_cancel` follows from the other
    group axioms, so there is no need to add it to the definition.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，类型`α`是`Group₁`定义中的一个*参数*。因此，你应该将对象`struc : Group₁ α`视为`α`上的群结构。我们在[第2.2节](C02_Basics.html#proving-identities-in-algebraic-structures)中看到，`inv_mul_cancel`的对应项`mul_inv_cancel`可以从其他群公理中得出，因此没有必要将其添加到定义中。'
- en: This definition of a group is similar to the definition of `Group` in Mathlib,
    and we have chosen the name `Group₁` to distinguish our version. If you write
    `#check Group` and ctrl-click on the definition, you will see that the Mathlib
    version of `Group` is defined to extend another structure; we will explain how
    to do that later. If you type `#print Group` you will also see that the Mathlib
    version of `Group` has a number of extra fields. For reasons we will explain later,
    sometimes it is useful to add redundant information to a structure, so that there
    are additional fields for objects and functions that can be defined from the core
    data. Don’t worry about that for now. Rest assured that our simplified version
    `Group₁` is morally the same as the definition of a group that Mathlib uses.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 这个群的定义与 Mathlib 中 `Group` 的定义相似，我们选择了 `Group₁` 这个名字来区分我们的版本。如果你输入 `#check Group`
    并在定义上按住 Ctrl 点击，你会看到 Mathlib 版本的 `Group` 是定义为扩展另一个结构的；我们将在稍后解释如何做到这一点。如果你输入 `#print
    Group`，你也会看到 Mathlib 版本的 `Group` 有许多额外的字段。由于我们将在稍后解释的原因，有时在结构中添加冗余信息是有用的，这样就可以为从核心数据定义的对象和函数提供额外的字段。现在不用担心这个。放心，我们的简化版本
    `Group₁` 在道德上是与 Mathlib 使用的群定义相同的。
- en: 'It is sometimes useful to bundle the type together with the structure, and
    Mathlib also contains a definition of a `Grp` structure that is equivalent to
    the following:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 有时将类型与结构捆绑在一起是有用的，Mathlib 也包含了一个与以下等价的 `Grp` 结构定义：
- en: '[PRE124]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: The Mathlib version is found in `Mathlib.Algebra.Category.Grp.Basic`, and you
    can `#check` it if you add this to the imports at the beginning of the examples
    file.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib 版本可以在 `Mathlib.Algebra.Category.Grp.Basic` 中找到，如果你在示例文件的开始处添加这个导入，你可以使用
    `#check` 来检查它。
- en: For reasons that will become clearer below, it is more often useful to keep
    the type `α` separate from the structure `Group α`. We refer to the two objects
    together as a *partially bundled structure*, since the representation combines
    most, but not all, of the components into one structure. It is common in Mathlib
    to use capital roman letters like `G` for a type when it is used as the carrier
    type for a group.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 由于以下原因将在下面变得更为清晰，通常更有用的是将类型 `α` 与结构 `Group α` 分开。我们将这两个对象一起称为 *部分捆绑结构*，因为表示结合了大多数但不是所有组件到一个结构中。在
    Mathlib 中，当用作群的载体类型时，通常使用大写罗马字母如 `G` 来表示类型。
- en: 'Let’s construct a group, which is to say, an element of the `Group₁` type.
    For any pair of types `α` and `β`, Mathlib defines the type `Equiv α β` of *equivalences*
    between `α` and `β`. Mathlib also defines the suggestive notation `α ≃ β` for
    this type. An element `f : α ≃ β` is a bijection between `α` and `β` represented
    by four components: a function `f.toFun` from `α` to `β`, the inverse function
    `f.invFun` from `β` to `α`, and two properties that specify these functions are
    indeed inverse to one another.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们构建一个群，也就是说，`Group₁` 类型的元素。对于任何一对类型 `α` 和 `β`，Mathlib 定义了 `α` 和 `β` 之间等价关系的类型
    `Equiv α β`。Mathlib 还为这个类型定义了有启发性的符号 `α ≃ β`。一个元素 `f : α ≃ β` 是 `α` 和 `β` 之间的双射，由四个组成部分表示：一个从
    `α` 到 `β` 的函数 `f.toFun`，一个从 `β` 到 `α` 的逆函数 `f.invFun`，以及两个指定这些函数确实是彼此的逆的性质。'
- en: '[PRE125]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Notice the creative naming of the last three constructions. We think of the
    identity function `Equiv.refl`, the inverse operation `Equiv.symm`, and the composition
    operation `Equiv.trans` as explicit evidence that the property of being in bijective
    correspondence is an equivalence relation.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后三个构造的创造性命名。我们认为恒等函数 `Equiv.refl`、逆操作 `Equiv.symm` 和复合操作 `Equiv.trans` 是双射对应性质是等价关系的明确证据。
- en: Notice also that `f.trans g` requires composing the forward functions in reverse
    order. Mathlib has declared a *coercion* from `Equiv α β` to the function type
    `α → β`, so we can omit writing `.toFun` and have Lean insert it for us.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `f.trans g` 需要按逆序组合前向函数。Mathlib 声明了一个从 `Equiv α β` 到函数类型 `α → β` 的 *强制转换*，因此我们可以省略写
    `.toFun`，让 Lean 为我们插入它。
- en: '[PRE126]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Mathlib also defines the type `perm α` of equivalences between `α` and itself.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib 还定义了 `α` 和自身之间等价关系的类型 `perm α`。
- en: '[PRE127]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'It should be clear that `Equiv.Perm α` forms a group under composition of equivalences.
    We orient things so that `mul f g` is equal to `g.trans f`, whose forward function
    is `f ∘ g`. In other words, multiplication is what we ordinarily think of as composition
    of the bijections. Here we define this group:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 应该很明显，`Equiv.Perm α` 在等价关系的复合下形成一个群。我们这样安排，使得 `mul f g` 等于 `g.trans f`，其前向函数是
    `f ∘ g`。换句话说，乘法就是我们通常认为的双射的复合。在这里，我们定义这个群：
- en: '[PRE128]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: In fact, Mathlib defines exactly this `Group` structure on `Equiv.Perm α` in
    the file `Algebra.Group.End`. As always, you can hover over the theorems used
    in the definition of `permGroup` to see their statements, and you can jump to
    their definitions in the original file to learn more about how they are implemented.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Mathlib 在 `Algebra.Group.End` 文件中精确地定义了 `Equiv.Perm α` 上的这个 `Group` 结构。像往常一样，你可以悬停在
    `permGroup` 定义中使用的定理上，以查看它们的陈述，并且你可以跳转到原始文件中的定义，以了解更多关于它们是如何实现的。
- en: In ordinary mathematics, we generally think of notation as independent of structure.
    For example, we can consider groups \((G_1, \cdot, 1, \cdot^{-1})\), \((G_2, \circ,
    e, i(\cdot))\), and \((G_3, +, 0, -)\). In the first case, we write the binary
    operation as \(\cdot\), the identity as \(1\), and the inverse function as \(x
    \mapsto x^{-1}\). In the second and third cases, we use the notational alternatives
    shown. When we formalize the notion of a group in Lean, however, the notation
    is more tightly linked to the structure. In Lean, the components of any `Group`
    are named `mul`, `one`, and `inv`, and in a moment we will see how multiplicative
    notation is set up to refer to them. If we want to use additive notation, we instead
    use an isomorphic structure `AddGroup` (the structure underlying additive groups).
    Its components are named `add`, `zero`, and `neg`, and the associated notation
    is what you would expect it to be.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规数学中，我们通常认为符号与结构是独立的。例如，我们可以考虑群 \((G_1, \cdot, 1, \cdot^{-1})\)、\((G_2, \circ,
    e, i(\cdot))\) 和 \((G_3, +, 0, -)\)。在第一种情况下，我们用 \(\cdot\) 表示二元运算，用 \(1\) 表示单位元，用
    \(x \mapsto x^{-1}\) 表示逆函数。在第二种和第三种情况下，我们使用显示的符号替代。然而，当我们用 Lean 正式化群的观念时，符号与结构之间的联系更为紧密。在
    Lean 中，任何 `Group` 的组成部分被命名为 `mul`、`one` 和 `inv`，我们很快就会看到乘法符号是如何设置来引用它们的。如果我们想使用加法符号，我们则使用同构结构
    `AddGroup`（加法群的底层结构）。它的组成部分被命名为 `add`、`zero` 和 `neg`，相关的符号正如你所期望的那样。
- en: Recall the type `Point` that we defined in [Section 7.1](#section-structures),
    and the addition function that we defined there. These definitions are reproduced
    in the examples file that accompanies this section. As an exercise, define an
    `AddGroup₁` structure that is similar to the `Group₁` structure we defined above,
    except that it uses the additive naming scheme just described. Define negation
    and a zero on the `Point` data type, and define the `AddGroup₁` structure on `Point`.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在 [第7.1节](#section-structures) 中定义的 `Point` 类型以及我们那里定义的加法函数。这些定义在伴随本节的示例文件中重现。作为一个练习，定义一个类似于我们上面定义的
    `Group₁` 结构的 `AddGroup₁` 结构，但使用前面描述的加法命名方案。在 `Point` 数据类型上定义否定和零，并在 `Point` 上定义
    `AddGroup₁` 结构。
- en: '[PRE129]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: We are making progress. Now we know how to define algebraic structures in Lean,
    and we know how to define instances of those structures. But we also want to associate
    notation with structures so that we can use it with each instance. Moreover, we
    want to arrange it so that we can define an operation on a structure and use it
    with any particular instance, and we want to arrange it so that we can prove a
    theorem about a structure and use it with any instance.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在取得进展。现在我们知道如何在 Lean 中定义代数结构，也知道如何定义这些结构的实例。但我们还希望将符号与结构关联起来，以便我们可以与每个实例一起使用它。此外，我们希望安排好，以便我们可以在结构上定义一个运算并使用任何特定的实例，我们还想安排好，以便我们可以在结构上证明一个定理并使用任何实例。
- en: In fact, Mathlib is already set up to use generic group notation, definitions,
    and theorems for `Equiv.Perm α`.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Mathlib 已经设置好，为 `Equiv.Perm α` 使用通用的群符号、定义和定理。
- en: '[PRE130]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: You can check that this is not the case for the additive group structure on
    `Point` that we asked you to define above. Our task now is to understand that
    magic that goes on under the hood in order to make the examples for `Equiv.Perm
    α` work the way they do.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以检查我们上面要求你定义的 `Point` 上的加法群结构并不是这样。我们的任务现在是要理解在 `Equiv.Perm α` 的例子背后发生的魔法，以便它们能按预期工作。
- en: 'The issue is that Lean needs to be able to *find* the relevant notation and
    the implicit group structure, using the information that is found in the expressions
    that we type. Similarly, when we write `x + y` with expressions `x` and `y` that
    have type `ℝ`, Lean needs to interpret the `+` symbol as the relevant addition
    function on the reals. It also has to recognize the type `ℝ` as an instance of
    a commutative ring, so that all the definitions and theorems for a commutative
    ring are available. For another example, continuity is defined in Lean relative
    to any two topological spaces. When we have `f : ℝ → ℂ` and we write `Continuous
    f`, Lean has to find the relevant topologies on `ℝ` and `ℂ`.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '问题在于 Lean 需要能够 *找到* 相关的符号和隐含的群结构，使用我们在输入的表达式中找到的信息。同样，当我们用具有类型 `ℝ` 的表达式 `x`
    和 `y` 写 `x + y` 时，Lean 需要解释 `+` 符号为实数上的相关加法函数。它还必须识别类型 `ℝ` 为交换环的实例，这样所有交换环的定义和定理都可用。例如，连续性在
    Lean 中相对于任何两个拓扑空间定义。当我们有 `f : ℝ → ℂ` 并写 `Continuous f` 时，Lean 必须找到 `ℝ` 和 `ℂ` 上的相关拓扑。'
- en: The magic is achieved with a combination of three things.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 这个魔法是通过三件事的结合实现的。
- en: '*Logic.* A definition that should be interpreted in any group takes, as arguments,
    the type of the group and the group structure as arguments. Similarly, a theorem
    about the elements of an arbitrary group begins with universal quantifiers over
    the type of the group and the group structure.'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*逻辑。* 任何一组中应被解释的定义，将组类型和组结构作为论证。同样，关于任意组元素的定理，也是从组类型和组结构的全称量词开始的。'
- en: '*Implicit arguments.* The arguments for the type and the structure are generally
    left implicit, so that we do not have to write them or see them in the Lean information
    window. Lean fills the information in for us silently.'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*隐含参数。* 类型结构和结构的参数通常被省略，这样我们就不必写它们或在 Lean 信息窗口中看到它们。Lean 会默默地为我们填写信息。'
- en: '*Type class inference.* Also known as *class inference*, this is a simple but
    powerful mechanism that enables us to register information for Lean to use later
    on. When Lean is called on to fill in implicit arguments to a definition, theorem,
    or piece of notation, it can make use of information that has been registered.'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*类型类推断。* 也称为 *类推断*，这是一个简单但强大的机制，使我们能够为 Lean 注册信息以供以后使用。当 Lean 被调用以填充定义、定理或符号中的隐含参数时，它可以利用已注册的信息。'
- en: 'Whereas an annotation `(grp : Group G)` tells Lean that it should expect to
    be given that argument explicitly and the annotation `{grp : Group G}` tells Lean
    that it should try to figure it out from contextual cues in the expression, the
    annotation `[grp : Group G]` tells Lean that the corresponding argument should
    be synthesized using type class inference. Since the whole point to the use of
    such arguments is that we generally do not need to refer to them explicitly, Lean
    allows us to write `[Group G]` and leave the name anonymous. You have probably
    already noticed that Lean chooses names like `_inst_1` automatically. When we
    use the anonymous square-bracket annotation with the `variables` command, then
    as long as the variables are still in scope, Lean automatically adds the argument
    `[Group G]` to any definition or theorem that mentions `G`.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '而一个注释 `(grp : Group G)` 告诉 Lean 应该明确地期望得到这个论证，注释 `{grp : Group G}` 告诉 Lean
    应该尝试从表达式的上下文中推断它，注释 `[grp : Group G]` 告诉 Lean 相应的论证应该通过类型类推断来合成。由于使用此类论证的整个目的是我们通常不需要明确地引用它们，Lean
    允许我们写出 `[Group G]` 并使名称匿名。你可能已经注意到 Lean 会自动选择像 `_inst_1` 这样的名称。当我们使用匿名方括号注释与 `variables`
    命令一起使用时，只要变量仍然在作用域内，Lean 就会自动将 `[Group G]` 参数添加到任何提及 `G` 的定义或定理中。'
- en: How do we register the information that Lean needs to use to carry out the search?
    Returning to our group example, we need only make two changes. First, instead
    of using the `structure` command to define the group structure, we use the keyword
    `class` to indicate that it is a candidate for class inference. Second, instead
    of defining particular instances with `def`, we use the keyword `instance` to
    register the particular instance with Lean. As with the names of class variables,
    we are allowed to leave the name of an instance definition anonymous, since in
    general we intend Lean to find it and put it to use without troubling us with
    the details.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何注册 Lean 需要用于执行搜索的信息？回到我们的群例子，我们只需要做两个更改。首先，我们不是使用 `structure` 命令来定义群结构，而是使用关键字
    `class` 来表示它是类推断的候选。其次，我们不是使用 `def` 定义特定的实例，而是使用关键字 `instance` 将特定的实例注册到 Lean
    中。与类变量名称一样，我们可以省略实例定义的名称，因为在一般情况下，我们希望 Lean 找到它并投入使用，而不必麻烦我们处理细节。
- en: '[PRE131]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The following illustrates their use.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子说明了它们的使用。
- en: '[PRE132]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The `#check` command shows that `Group₂.mul` has an implicit argument `[Group₂
    α]` that we expect to be found by class inference, where `α` is the type of the
    arguments to `Group₂.mul`. In other words, `{α : Type*}` is the implicit argument
    for the type of the group elements and `[Group₂ α]` is the implicit argument for
    the group structure on `α`. Similarly, when we define a generic squaring function
    `my_square` for `Group₂`, we use an implicit argument `{α : Type*}` for the type
    of the elements and an implicit argument `[Group₂ α]` for the `Group₂` structure.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '`#check` 命令显示 `Group₂.mul` 有一个隐含的参数 `[Group₂ α]`，我们期望它通过类推断找到，其中 `α` 是 `Group₂.mul`
    参数的类型。换句话说，`{α : Type*}` 是群元素类型的隐含参数，而 `[Group₂ α]` 是 `α` 上群结构的隐含参数。同样，当我们为 `Group₂`
    定义一个通用的平方函数 `my_square` 时，我们使用一个隐含参数 `{α : Type*}` 用于元素类型，以及一个隐含参数 `[Group₂ α]`
    用于 `Group₂` 结构。'
- en: In the first example, when we write `Group₂.mul f g`, the type of `f` and `g`
    tells Lean that in the argument `α` to `Group₂.mul` has to be instantiated to
    `Equiv.Perm β`. That means that Lean has to find an element of `Group₂ (Equiv.Perm
    β)`. The previous `instance` declaration tells Lean exactly how to do that. Problem
    solved!
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，当我们写下 `Group₂.mul f g` 时，`f` 和 `g` 的类型告诉 Lean 在 `Group₂.mul` 的参数 `α`
    必须实例化为 `Equiv.Perm β`。这意味着 Lean 必须找到一个 `Group₂ (Equiv.Perm β)` 的元素。之前的 `instance`
    声明告诉 Lean 如何做到这一点。问题解决！
- en: 'This simple mechanism for registering information so that Lean can find it
    when it needs it is remarkably useful. Here is one way it comes up. In Lean’s
    foundation, a data type `α` may be empty. In a number of applications, however,
    it is useful to know that a type has at least one element. For example, the function
    `List.headI`, which returns the first element of a list, can return the default
    value when the list is empty. To make that work, the Lean library defines a class
    `Inhabited α`, which does nothing more than store a default value. We can show
    that the `Point` type is an instance:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的机制，用于注册信息以便 Lean 在需要时可以找到它，是非常有用的。这里有一种它出现的方式。在 Lean 的基础上，一个数据类型 `α` 可能是空的。然而，在许多应用中，知道一个类型至少有一个元素是有用的。例如，函数
    `List.headI`，它返回列表的第一个元素，当列表为空时可以返回默认值。为了使它工作，Lean 库定义了一个类 `Inhabited α`，它所做的只是存储一个默认值。我们可以证明
    `Point` 类型是一个实例：
- en: '[PRE133]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: The class inference mechanism is also used for generic notation. The expression
    `x + y` is an abbreviation for `Add.add x y` where—you guessed it—`Add α` is a
    class that stores a binary function on `α`. Writing `x + y` tells Lean to find
    a registered instance of `[Add.add α]` and use the corresponding function. Below,
    we register the addition function for `Point`.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 类推断机制也用于泛型符号。表达式 `x + y` 是 `Add.add x y` 的缩写，其中——正如你所猜的——`Add α` 是一个存储在 `α`
    上的二元函数的类。写下 `x + y` 告诉 Lean 找到一个注册的 `[Add.add α]` 实例，并使用相应的函数。下面，我们注册了 `Point`
    的加法函数。
- en: '[PRE134]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: In this way, we can assign the notation `+` to binary operations on other types
    as well.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们也可以将符号 `+` 分配给其他类型的二元运算。
- en: 'But we can do even better. We have seen that `*` can be used in any group,
    `+` can be used in any additive group, and both can be used in any ring. When
    we define a new instance of a ring in Lean, we don’t have to define `+` and `*`
    for that instance, because Lean knows that these are defined for every ring. We
    can use this method to specify notation for our `Group₂` class:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以做得更好。我们已经看到`*`可以在任何群中使用，`+`可以在任何加法群中使用，并且两者都可以在任何环中使用。当我们定义Lean中的新环实例时，我们不需要为该实例定义`+`和`*`，因为Lean知道这些在每一个环中都是定义好的。我们可以使用这种方法为我们的`Group₂`类指定符号：
- en: '[PRE135]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: What makes this approach work is that Lean carries out a recursive search. According
    to the instances we have declared, Lean can find an instance of `Mul (Equiv.Perm
    α)` by finding an instance of `Group₂ (Equiv.Perm α)`, and it can find an instance
    of `Group₂ (Equiv.Perm α)` because we have provided one. Lean is capable of finding
    these two facts and chaining them together.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 使这种方法有效的是Lean执行递归搜索。根据我们声明的实例，Lean可以通过找到`Group₂ (Equiv.Perm α)`的实例来找到`Mul (Equiv.Perm
    α)`的实例，并且它可以通过我们提供的一个实例来找到`Group₂ (Equiv.Perm α)`的实例。Lean能够找到这两个事实并将它们串联起来。
- en: The example we have just given is dangerous, because Lean’s library also has
    an instance of `Group (Equiv.Perm α)`, and multiplication is defined on any group.
    So it is ambiguous as to which instance is found. In fact, Lean favors more recent
    declarations unless you explicitly specify a different priority. Also, there is
    another way to tell Lean that one structure is an instance of another, using the
    `extends` keyword. This is how Mathlib specifies that, for example, every commutative
    ring is a ring. You can find more information in [Section 8](C08_Hierarchies.html#hierarchies)
    and in a [section on class inference](https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html#managing-type-class-inference)
    in *Theorem Proving in Lean*.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚给出的例子是危险的，因为Lean的库也有一个`Group (Equiv.Perm α)`的实例，并且乘法在任意群上都是定义好的。所以找到哪个实例是不确定的。实际上，Lean倾向于优先考虑较新的声明，除非你明确指定了不同的优先级。此外，还有另一种方法告诉Lean一个结构是另一个结构的实例，使用`extends`关键字。这就是Mathlib指定例如每个交换环都是环的方式。你可以在[第8节](C08_Hierarchies.html#hierarchies)和*《Lean中的定理证明》*中的一个关于类推断的[章节](https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html#managing-type-class-inference)中找到更多信息。
- en: In general, it is a bad idea to specify a value of `*` for an instance of an
    algebraic structure that already has the notation defined. Redefining the notion
    of `Group` in Lean is an artificial example. In this case, however, both interpretations
    of the group notation unfold to `Equiv.trans`, `Equiv.refl`, and `Equiv.symm`,
    in the same way.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，为一个已经定义了符号的代数结构实例指定`*`的值是一个坏主意。在Lean中重新定义`Group`的概念是一个人为的例子。然而，在这种情况下，群符号的两种解释都展开为`Equiv.trans`、`Equiv.refl`和`Equiv.symm`，方式相同。
- en: As a similarly artificial exercise, define a class `AddGroup₂` in analogy to
    `Group₂`. Define the usual notation for addition, negation, and zero on any `AddGroup₂`
    using the classes `Add`, `Neg`, and `Zero`. Then show `Point` is an instance of
    `AddGroup₂`. Try it out and make sure that the additive group notation works for
    elements of `Point`.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项类似的练习，定义一个与`Group₂`类似的类`AddGroup₂`。在任意的`AddGroup₂`上使用类`Add`、`Neg`和`Zero`定义加法、减法和零的常规符号。然后证明`Point`是`AddGroup₂`的一个实例。尝试一下，确保加法群符号对`Point`的元素有效。
- en: '[PRE136]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: It is not a big problem that we have already declared instances `Add`, `Neg`,
    and `Zero` for `Point` above. Once again, the two ways of synthesizing the notation
    should come up with the same answer.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为`Point`声明了实例`Add`、`Neg`和`Zero`，这并不是一个大问题。再次强调，两种合成符号的方式应该得出相同的答案。
- en: Class inference is subtle, and you have to be careful when using it, because
    it configures automation that invisibly governs the interpretation of the expressions
    we type. When used wisely, however, class inference is a powerful tool. It is
    what makes algebraic reasoning possible in Lean.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 类推断很微妙，使用时必须小心，因为它配置了自动化，这种自动化无形中控制着我们输入表达式的解释。然而，如果使用得当，类推断是一个强大的工具。它是使在Lean中进行代数推理成为可能的原因。
- en: '## 7.3\. Building the Gaussian Integers[](#building-the-gaussian-integers
    "Link to this heading")'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '## 7.3\. 构建高斯整数[](#building-the-gaussian-integers "链接到这个标题")'
- en: We will now illustrate the use of the algebraic hierarchy in Lean by building
    an important mathematical object, the *Gaussian integers*, and showing that it
    is a Euclidean domain. In other words, according to the terminology we have been
    using, we will define the Gaussian integers and show that they are an instance
    of the Euclidean domain structure.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过构建一个重要的数学对象，高斯整数（*Gaussian integers*），并展示它是一个欧几里得域，来展示在 Lean 中使用代数层次结构的应用。换句话说，根据我们一直在使用的术语，我们将定义高斯整数并展示它们是欧几里得域结构的一个实例。
- en: In ordinary mathematical terms, the set of Gaussian integers \(\Bbb{Z}[i]\)
    is the set of complex numbers \(\{ a + b i \mid a, b \in \Bbb{Z}\}\). But rather
    than define them as a subset of the complex numbers, our goal here is to define
    them as a data type in their own right. We do this by representing a Gaussian
    integer as a pair of integers, which we think of as the *real* and *imaginary*
    parts.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在普通数学术语中，高斯整数集 \(\Bbb{Z}[i]\) 是复数集 \(\{ a + b i \mid a, b \in \Bbb{Z}\}\)。但我们的目标不是将它们定义为复数集的子集，而是将它们定义为一个独立的数据类型。我们通过将高斯整数表示为整数对来实现这一点，我们将这些整数视为
    *实部* 和 *虚部*。
- en: '[PRE137]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: We first show that the Gaussian integers have the structure of a ring, with
    `0` defined to be `⟨0, 0⟩`, `1` defined to be `⟨1, 0⟩`, and addition defined pointwise.
    To work out the definition of multiplication, remember that we want the element
    \(i\), represented by `⟨0, 1⟩`, to be a square root of \(-1\). Thus we want
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先展示高斯整数具有环的结构，其中 `0` 定义为 `⟨0, 0⟩`，`1` 定义为 `⟨1, 0⟩`，加法定义为逐点。为了确定乘法定义，记住我们希望元素
    \(i\)，由 `⟨0, 1⟩` 表示，是 \(-1\) 的一个平方根。因此我们希望
- en: \[\begin{split}(a + bi) (c + di) & = ac + bci + adi + bd i^2 \\ & = (ac - bd)
    + (bc + ad)i.\end{split}\]
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}(a + bi) (c + di) & = ac + bci + adi + bd i^2 \\ & = (ac - bd)
    + (bc + ad)i.\end{split}\]
- en: This explains the definition of `Mul` below.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了下面 `Mul` 的定义。
- en: '[PRE138]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: As noted in [Section 7.1](#section-structures), it is a good idea to put all
    the definitions related to a data type in a namespace with the same name. Thus
    in the Lean files associated with this chapter, these definitions are made in
    the `GaussInt` namespace.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 7.1 节](#section-structures) 所述，将一个数据类型相关的所有定义放在具有相同名称的空间中是一个好主意。因此，在本章相关的
    Lean 文件中，这些定义是在 `GaussInt` 空间中进行的。
- en: Notice that here we are defining the interpretations of the notation `0`, `1`,
    `+`, `-`, and `*` directly, rather than naming them `GaussInt.zero` and the like
    and assigning the notation to those. It is often useful to have an explicit name
    for the definitions, for example, to use with `simp` and `rw`.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里我们直接定义了记号 `0`、`1`、`+`、`-` 和 `*` 的解释，而不是将它们命名为 `GaussInt.zero` 等并分配给这些记号。为定义提供显式的名称通常很有用，例如与
    `simp` 和 `rw` 一起使用。
- en: '[PRE139]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: It is also useful to name the rules that compute the real and imaginary parts,
    and to declare them to the simplifier.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 给出计算实部和虚部的规则并将其声明给简化器也是有用的。
- en: '[PRE140]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: It is now surprisingly easy to show that the Gaussian integers are an instance
    of a commutative ring. We are putting the structure concept to good use. Each
    particular Gaussian integer is an instance of the `GaussInt` structure, whereas
    the type `GaussInt` itself, together with the relevant operations, is an instance
    of the `CommRing` structure. The `CommRing` structure, in turn, extends the notational
    structures `Zero`, `One`, `Add`, `Neg`, and `Mul`.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 现在出人意料地容易证明高斯整数是一个交换环的实例。我们正在很好地利用结构概念。每个特定的高斯整数是 `GaussInt` 结构的一个实例，而 `GaussInt`
    类型本身，连同相关操作，是 `CommRing` 结构的一个实例。`CommRing` 结构反过来又扩展了 `Zero`、`One`、`Add`、`Neg`
    和 `Mul` 等记法结构。
- en: 'If you type `instance : CommRing GaussInt := _`, click on the light bulb that
    appears in VS Code, and then ask Lean to fill in a skeleton for the structure
    definition, you will see a scary number of entries. Jumping to the definition
    of the structure, however, shows that many of the fields have default definitions
    that Lean will fill in for you automatically. The essential ones appear in the
    definition below. A special case are `nsmul` and `zsmul` which should be ignored
    for now and will be explained in the next chapter. In each case, the relevant
    identity is proved by unfolding definitions, using the `ext` tactic to reduce
    the identities to their real and imaginary components, simplifying, and, if necessary,
    carrying out the relevant ring calculation in the integers. Note that we could
    easily avoid repeating all this code, but this is not the topic of the current
    discussion.'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你输入 `instance : CommRing GaussInt := _`，然后在 VS Code 中点击出现的灯泡图标，并让 Lean 填写结构定义的骨架，你会看到很多条目。然而，跳转到结构的定义，你会发现许多字段都有默认定义，Lean
    会自动为你填写。下面列出了关键的定义。一个特殊情况是 `nsmul` 和 `zsmul`，目前可以忽略，将在下一章中解释。在每种情况下，相关恒等式都是通过展开定义、使用
    `ext` 策略将恒等式简化为其实部和虚部、简化，并在必要时在整数中进行相关环计算来证明的。请注意，我们可以轻松避免重复所有这些代码，但这不是当前讨论的主题。'
- en: '[PRE141]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Lean’s library defines the class of *nontrivial* types to be types with at least
    two distinct elements. In the context of a ring, this is equivalent to saying
    that the zero is not equal to the one. Since some common theorems depend on that
    fact, we may as well establish it now.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 的库定义 *非平凡* 类型为至少有两个不同元素的类型。在环的上下文中，这相当于说零不等于一。由于一些常见的定理依赖于这个事实，我们不妨现在就建立它。
- en: '[PRE142]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'We will now show that the Gaussian integers have an important additional property.
    A *Euclidean domain* is a ring \(R\) equipped with a *norm* function \(N : R \to
    \mathbb{N}\) with the following two properties:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们将展示高斯整数具有一个重要的附加属性。一个 *欧几里得域* 是一个带有 *范数* 函数 \(N : R \to \mathbb{N}\) 的环
    \(R\)，它具有以下两个属性：'
- en: For every \(a\) and \(b \ne 0\) in \(R\), there are \(q\) and \(r\) in \(R\)
    such that \(a = bq + r\) and either \(r = 0\) or \(N(r) < N(b)\).
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 \(R\) 中的每个 \(a\) 和 \(b \ne 0\)，存在 \(q\) 和 \(r\) 在 \(R\) 中，使得 \(a = bq + r\)，并且要么
    \(r = 0\)，要么 \(N(r) < N(b)\)。
- en: For every \(a\) and \(b \ne 0\), \(N(a) \le N(ab)\).
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个 \(a\) 和 \(b \ne 0\)，\(N(a) \le N(ab)\)。
- en: 'The ring of integers \(\Bbb{Z}\) with \(N(a) = |a|\) is an archetypal example
    of a Euclidean domain. In that case, we can take \(q\) to be the result of integer
    division of \(a\) by \(b\) and \(r\) to be the remainder. These functions are
    defined in Lean so that the satisfy the following:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 整数环 \(\Bbb{Z}\) 中，\(N(a) = |a|\) 是欧几里得域的一个典型例子。在这种情况下，我们可以取 \(q\) 为 \(a\) 除以
    \(b\) 的整数除法结果，\(r\) 为余数。这些函数在 Lean 中定义，以便它们满足以下条件：
- en: '[PRE143]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: In an arbitrary ring, an element \(a\) is said to be a *unit* if it divides
    \(1\). A nonzero element \(a\) is said to be *irreducible* if it cannot be written
    in the form \(a = bc\) where neither \(b\) nor \(c\) is a unit. In the integers,
    every irreducible element \(a\) is *prime*, which is to say, whenever \(a\) divides
    a product \(bc\), it divides either \(b\) or \(c\). But in other rings this property
    can fail. In the ring \(\Bbb{Z}[\sqrt{-5}]\), we have
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个任意的环中，一个元素 \(a\) 被称为 *单位*，如果它可以整除 \(1\)。一个非零元素 \(a\) 被称为 *不可约*，如果它不能写成 \(a
    = bc\) 的形式，其中 \(b\) 和 \(c\) 都不是单位。在整数中，每个不可约元素 \(a\) 都是 *素数*，也就是说，每当 \(a\) 整除一个乘积
    \(bc\) 时，它要么整除 \(b\)，要么整除 \(c\)。但在其他环中，这个属性可能不成立。在环 \(\Bbb{Z}[\sqrt{-5}]\) 中，我们有
- en: \[6 = 2 \cdot 3 = (1 + \sqrt{-5})(1 - \sqrt{-5}),\]
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: \[6 = 2 \cdot 3 = (1 + \sqrt{-5})(1 - \sqrt{-5}),\]
- en: 'and the elements \(2\), \(3\), \(1 + \sqrt{-5}\), and \(1 - \sqrt{-5}\) are
    all irreducible, but they are not prime. For example, \(2\) divides the product
    \((1 + \sqrt{-5})(1 - \sqrt{-5})\), but it does not divide either factor. In particular,
    we no longer have unique factorization: the number \(6\) can be factored into
    irreducible elements in more than one way.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 元素 \(2\)、\(3\)、\(1 + \sqrt{-5}\) 和 \(1 - \sqrt{-5}\) 都是不可约的，但它们不是素数。例如，\(2\)
    可以整除乘积 \((1 + \sqrt{-5})(1 - \sqrt{-5})\)，但它不能整除任何一个因子。特别是，我们不再有唯一的分解：数字 \(6\)
    可以以多种方式分解成不可约元素。
- en: In contrast, every Euclidean domain is a unique factorization domain, which
    implies that every irreducible element is prime. The axioms for a Euclidean domain
    imply that one can write any nonzero element as a finite product of irreducible
    elements. They also imply that one can use the Euclidean algorithm to find a greatest
    common divisor of any two nonzero elements `a` and `b`, i.e. an element that is
    divisible by any other common divisor. This, in turn, implies that factorization
    into irreducible elements is unique up to multiplication by units.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，每个欧几里得域都是一个唯一分解域，这意味着每个不可约元素都是素数。欧几里得域的公理意味着可以写出任何非零元素为不可约元素的有限乘积。它们还意味着可以使用欧几里得算法找到任何两个非零元素
    `a` 和 `b` 的最大公约数，即任何其他公约数都能整除的元素。这反过来又意味着不可约元素的分解是唯一的，直到乘以单位元素。
- en: We now show that the Gaussian integers are a Euclidean domain with the norm
    defined by \(N(a + bi) = (a + bi)(a - bi) = a^2 + b^2\). The Gaussian integer
    \(a - bi\) is called the *conjugate* of \(a + bi\). It is not hard to check that
    for any complex numbers \(x\) and \(y\), we have \(N(xy) = N(x)N(y)\).
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在证明高斯整数是一个具有由 \(N(a + bi) = (a + bi)(a - bi) = a^2 + b^2\) 定义的范数的欧几里得域。高斯整数
    \(a - bi\) 被称为 \(a + bi\) 的**共轭**。对于任何复数 \(x\) 和 \(y\)，检查并不困难，我们有 \(N(xy) = N(x)N(y)\)。
- en: To see that this definition of the norm makes the Gaussian integers a Euclidean
    domain, only the first property is challenging. Suppose we want to write \(a +
    bi = (c + di) q + r\) for suitable \(q\) and \(r\). Treating \(a + bi\) and \(c
    + di\) as complex numbers, carry out the division
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这个范数的定义使得高斯整数成为一个欧几里得域，只需考虑第一个性质就具有挑战性。假设我们想要将 \(a + bi = (c + di) q + r\)
    写成合适的 \(q\) 和 \(r\)。将 \(a + bi\) 和 \(c + di\) 作为复数来处理，进行除法运算
- en: \[\frac{a + bi}{c + di} = \frac{(a + bi)(c - di)}{(c + di)(c-di)} = \frac{ac
    + bd}{c^2 + d^2} + \frac{bc -ad}{c^2+d^2} i.\]
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: \[\frac{a + bi}{c + di} = \frac{(a + bi)(c - di)}{(c + di)(c-di)} = \frac{ac
    + bd}{c^2 + d^2} + \frac{bc -ad}{c^2+d^2} i.\]
- en: The real and imaginary parts might not be integers, but we can round them to
    the nearest integers \(u\) and \(v\). We can then express the right-hand side
    as \((u + vi) + (u' + v'i)\), where \(u' + v'i\) is the part left over. Note that
    we have \(|u'| \le 1/2\) and \(|v'| \le 1/2\), and hence
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 实部和虚部可能不是整数，但我们可以将它们四舍五入到最近的整数 \(u\) 和 \(v\)。然后我们可以将右侧表示为 \((u + vi) + (u' +
    v'i)\)，其中 \(u' + v'i\) 是剩余的部分。注意，我们有 \(|u'| \le 1/2\) 和 \(|v'| \le 1/2\)，因此
- en: \[N(u' + v' i) = (u')^2 + (v')^2 \le 1/4 + 1/4 \le 1/2.\]
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: \[N(u' + v' i) = (u')^2 + (v')^2 \le 1/4 + 1/4 \le 1/2.\]
- en: Multiplying through by \(c + di\), we have
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 乘以 \(c + di\)，我们得到
- en: \[a + bi = (c + di) (u + vi) + (c + di) (u' + v'i).\]
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: \[a + bi = (c + di) (u + vi) + (c + di) (u' + v'i).\]
- en: 'Setting \(q = u + vi\) and \(r = (c + di) (u'' + v''i)\), we have \(a + bi
    = (c + di) q + r\), and we only need to bound \(N(r)\):'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 设 \(q = u + vi\) 和 \(r = (c + di) (u' + v'i)\)，则 \(a + bi = (c + di) q + r\)，我们只需要界定
    \(N(r)\)：
- en: \[N(r) = N(c + di)N(u' + v'i) \le N(c + di) \cdot 1/2 < N(c + di).\]
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: \[N(r) = N(c + di)N(u' + v'i) \le N(c + di) \cdot 1/2 < N(c + di).\]
- en: The argument we just carried out requires viewing the Gaussian integers as a
    subset of the complex numbers. One option for formalizing it in Lean is therefore
    to embed the Gaussian integers in the complex numbers, embed the integers in the
    Gaussian integers, define the rounding function from the real numbers to the integers,
    and take great care to pass back and forth between these number systems appropriately.
    In fact, this is exactly the approach that is followed in Mathlib, where the Gaussian
    integers themselves are constructed as a special case of a ring of *quadratic
    integers*. See the file [GaussianInt.lean](https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/NumberTheory/Zsqrtd/GaussianInt.lean).
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才进行的论证需要将高斯整数视为复数的一个子集。因此，在 Lean 中形式化它的一个选项是将高斯整数嵌入到复数中，将整数嵌入到高斯整数中，定义从实数到整数的舍入函数，并且要非常小心地在这些数系之间适当地来回传递。实际上，这正是
    Mathlib 中所采用的方法，其中高斯整数本身被构造为**二次整数环**的一个特例。参见文件 [GaussianInt.lean](https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/NumberTheory/Zsqrtd/GaussianInt.lean)。
- en: 'Here we will instead carry out an argument that stays in the integers. This
    illustrates a choice one commonly faces when formalizing mathematics. Given an
    argument that requires concepts or machinery that is not already in the library,
    one has two choices: either formalize the concepts and machinery needed, or adapt
    the argument to make use of concepts and machinery you already have. The first
    choice is generally a good investment of time when the results can be used in
    other contexts. Pragmatically speaking, however, sometimes seeking a more elementary
    proof is more efficient.'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将进行一个保持在整数范围内的论证。这说明了在形式化数学时人们通常面临的选择。给定一个需要或使用库中尚未存在的概念或工具的论证，你有两个选择：要么形式化所需的概念和工具，要么调整论证以利用你已有的概念和工具。当结果可以在其他上下文中使用时，第一个选择通常是时间的好投资。然而，从实用主义的角度来看，有时寻找更基础的证明可能更有效。
- en: The usual quotient-remainder theorem for the integers says that for every \(a\)
    and nonzero \(b\), there are \(q\) and \(r\) such that \(a = b q + r\) and \(0
    \le r < b\). Here we will make use of the following variation, which says that
    there are \(q'\) and \(r'\) such that \(a = b q' + r'\) and \(|r'| \le b/2\).
    You can check that if the value of \(r\) in the first statement satisfies \(r
    \le b/2\), we can take \(q' = q\) and \(r' = r\), and otherwise we can take \(q'
    = q + 1\) and \(r' = r - b\). We are grateful to Heather Macbeth for suggesting
    the following more elegant approach, which avoids definition by cases. We simply
    add `b / 2` to `a` before dividing and then subtract it from the remainder.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 整数的常规商余定理表明，对于每一个\(a\)和非零的\(b\)，存在\(q\)和\(r\)使得\(a = b q + r\)且\(0 \le r < b\)。在这里，我们将利用以下变体，它表明存在\(q'\)和\(r'\)使得\(a
    = b q' + r'\)且\(|r'| \le b/2\)。你可以检查，如果第一个陈述中的\(r\)的值满足\(r \le b/2\)，我们可以取\(q'
    = q\)和\(r' = r\)，否则我们可以取\(q' = q + 1\)和\(r' = r - b\)。我们感谢Heather Macbeth提出了以下更优雅的方法，它避免了分情况定义。我们只是在除法之前将`b
    / 2`加到`a`上，然后从余数中减去。
- en: '[PRE144]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Note the use of our old friend, `linarith`. We will also need to express `mod'`
    in terms of `div'`.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们使用了老朋友`linarith`。我们还需要将`mod'`用`div'`来表示。
- en: '[PRE145]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: We will use the fact that \(x^2 + y^2\) is equal to zero if and only if \(x\)
    and \(y\) are both zero. As an exercise, we ask you to prove that this holds in
    any ordered ring.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用\(x^2 + y^2\)等于零当且仅当\(x\)和\(y\)都为零的事实。作为一个练习，我们要求你证明这在任何有序环中都成立。
- en: '[PRE146]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: We will put all the remaining definitions and theorems in this section in the
    `GaussInt` namespace. First, we define the `norm` function and ask you to establish
    some of its properties. The proofs are all short.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个部分的剩余定义和定理中放入`GaussInt`命名空间。首先，我们定义`norm`函数并要求你证明其一些性质。证明都很简短。
- en: '[PRE147]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Next we define the conjugate function:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义共轭函数：
- en: '[PRE148]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Finally, we define division for the Gaussian integers with the notation `x /
    y`, that rounds the complex quotient to the nearest Gaussian integer. We use our
    bespoke `Int.div'` for that purpose. As we calculated above, if `x` is \(a + bi\)
    and `y` is \(c + di\), then the real and imaginary parts of `x / y` are the nearest
    integers to
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们用`x / y`的符号定义高斯整数的除法，它将复数商四舍五入到最接近的高斯整数。我们使用定制的`Int.div'`来完成这个目的。正如我们上面计算的，如果`x`是\(a
    + bi\)且`y`是\(c + di\)，那么`x / y`的实部和虚部是接近于
- en: \[\frac{ac + bd}{c^2 + d^2} \quad \text{and} \quad \frac{bc -ad}{c^2+d^2},\]
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: \[\frac{ac + bd}{c^2 + d^2} \quad \text{和} \quad \frac{bc -ad}{c^2+d^2},\]
- en: respectively. Here the numerators are the real and imaginary parts of \((a +
    bi) (c - di)\), and the denominators are both equal to the norm of \(c + di\).
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 分别。在这里，分子是\((a + bi) (c - di)\)的实部和虚部，分母都是\(c + di\)的范数。
- en: '[PRE149]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Having defined `x / y`, We define `x % y` to be the remainder, `x - (x / y)
    * y`. As above, we record the definitions in the theorems `div_def` and `mod_def`
    so that we can use them with `simp` and `rw`.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了`x / y`之后，我们定义`x % y`为余数，即`x - (x / y) * y`。与上面类似，我们在定理`div_def`和`mod_def`中记录这些定义，以便我们可以使用它们进行`simp`和`rw`。
- en: '[PRE150]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: These definitions immediately yield `x = y * (x / y) + x % y` for every `x`
    and `y`, so all we need to do is show that the norm of `x % y` is less than the
    norm of `y` when `y` is not zero.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义立即给出了对于每个`x`和`y`的`x = y * (x / y) + x % y`，所以我们只需要证明当`y`不为零时，`x % y`的范数小于`y`的范数。
- en: We just defined the real and imaginary parts of `x / y` to be `div' (x * conj
    y).re (norm y)` and `div' (x * conj y).im (norm y)`, respectively. Calculating,
    we have
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义了`x / y`的实部和虚部分别为`div' (x * conj y).re (norm y)`和`div' (x * conj y).im
    (norm y)`。计算后，我们得到
- en: '`(x % y) * conj y = (x - x / y * y) * conj y = x * conj y - x / y * (y * conj
    y)`'
  id: totrans-562
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`(x % y) * conj y = (x - x / y * y) * conj y = x * conj y - x / y * (y * conj
    y)`'
- en: The real and imaginary parts of the right-hand side are exactly `mod' (x * conj
    y).re (norm y)` and `mod' (x * conj y).im (norm y)`. By the properties of `div'`
    and `mod'`, these are guaranteed to be less than or equal to `norm y / 2`. So
    we have
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的实部和虚部正好是 `mod' (x * conj y).re (norm y)` 和 `mod' (x * conj y).im (norm y)`。根据
    `div'` 和 `mod'` 的性质，这些值保证小于或等于 `norm y / 2`。因此我们有
- en: '`norm ((x % y) * conj y) ≤ (norm y / 2)^2 + (norm y / 2)^2 ≤ (norm y / 2) *
    norm y`.'
  id: totrans-564
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`norm ((x % y) * conj y) ≤ (norm y / 2)^2 + (norm y / 2)^2 ≤ (norm y / 2) *
    norm y`.'
- en: On the other hand, we have
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们有
- en: '`norm ((x % y) * conj y) = norm (x % y) * norm (conj y) = norm (x % y) * norm
    y`.'
  id: totrans-566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`norm ((x % y) * conj y) = norm (x % y) * norm (conj y) = norm (x % y) * norm
    y`.'
- en: Dividing through by `norm y` we have `norm (x % y) ≤ (norm y) / 2 < norm y`,
    as required.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 通过除以 `norm y`，我们得到 `norm (x % y) ≤ (norm y) / 2 < norm y`，正如所需的那样。
- en: This messy calculation is carried out in the next proof. We encourage you to
    step through the details and see if you can find a nicer argument.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 这个混乱的计算将在下一个证明中进行。我们鼓励您逐步查看细节，看看您是否能找到一个更合理的论点。
- en: '[PRE151]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: We are in the home stretch. Our `norm` function maps Gaussian integers to nonnegative
    integers. We need a function that maps Gaussian integers to natural numbers, and
    we obtain that by composing `norm` with the function `Int.natAbs`, which maps
    integers to the natural numbers. The first of the next two lemmas establishes
    that mapping the norm to the natural numbers and back to the integers does not
    change the value. The second one re-expresses the fact that the norm is decreasing.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经接近终点。我们的 `norm` 函数将高斯整数映射到非负整数。我们需要一个将高斯整数映射到自然数的函数，我们通过将 `norm` 与函数 `Int.natAbs`
    组合来获得，该函数将整数映射到自然数。下两个引理中的第一个建立了将范数映射到自然数再映射回整数不会改变值。第二个重新表述了范数是递减的事实。
- en: '[PRE152]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: We also need to establish the second key property of the norm function on a
    Euclidean domain.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要建立欧几里得域上范数函数的第二个关键性质。
- en: '[PRE153]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: We can now put it together to show that the Gaussian integers are an instance
    of a Euclidean domain. We use the quotient and remainder function we have defined.
    The Mathlib definition of a Euclidean domain is more general than the one above
    in that it allows us to show that remainder decreases with respect to any well-founded
    measure. Comparing the values of a norm function that returns natural numbers
    is just one instance of such a measure, and in that case, the required properties
    are the theorems `natAbs_norm_mod_lt` and `not_norm_mul_left_lt_norm`.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将其组合起来，以表明高斯整数是欧几里得域的一个实例。我们使用我们定义的商和余数函数。Mathlib 对欧几里得域的定义比上面的定义更通用，因为它允许我们证明余数与任何良基测度相关时是递减的。比较返回自然数的范数函数的值只是这种测度的一个实例，在这种情况下，所需性质是定理
    `natAbs_norm_mod_lt` 和 `not_norm_mul_left_lt_norm`。
- en: '[PRE154]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: An immediate payoff is that we now know that, in the Gaussian integers, the
    notions of being prime and being irreducible coincide.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 一个直接的好处是，我们现在知道在高斯整数中，素数和不可约的概念是一致的。
- en: '[PRE155]*'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE155]*'
