- en: 1\. Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 简介
- en: 原文：[https://leanprover-community.github.io/mathematics_in_lean/C01_Introduction.html](https://leanprover-community.github.io/mathematics_in_lean/C01_Introduction.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://leanprover-community.github.io/mathematics_in_lean/C01_Introduction.html](https://leanprover-community.github.io/mathematics_in_lean/C01_Introduction.html)
- en: '*[Mathematics in Lean](index.html)* **   1\. Introduction'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*[Lean 中的数学](index.html)* **   1. 简介'
- en: '[View page source](_sources/C01_Introduction.rst.txt)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[查看页面源代码](_sources/C01_Introduction.rst.txt)'
- en: '* * *'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '## 1.1\. Getting Started[](#getting-started "Link to this heading")'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '## 1.1. 开始[](#getting-started "链接到这个标题")'
- en: 'The goal of this book is to teach you to formalize mathematics using the Lean
    4 interactive proof assistant. It assumes that you know some mathematics, but
    it does not require much. Although we will cover examples ranging from number
    theory to measure theory and analysis, we will focus on elementary aspects of
    those fields, in the hopes that if they are not familiar to you, you can pick
    them up as you go. We also don’t presuppose any background with formal methods.
    Formalization can be seen as a kind of computer programming: we will write mathematical
    definitions, theorems, and proofs in a regimented language, like a programming
    language, that Lean can understand. In return, Lean provides feedback and information,
    interprets expressions and guarantees that they are well-formed, and ultimately
    certifies the correctness of our proofs.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目标是教你使用 Lean 4 交互式证明辅助工具形式化数学。它假设你了解一些数学知识，但不需要太多。虽然我们将涵盖从数论到测度理论和分析的例子，但我们将专注于这些领域的初阶方面，希望如果你不熟悉它们，你可以在学习过程中掌握它们。我们也不预设任何关于形式方法的背景知识。形式化可以看作是一种计算机编程：我们将用
    Lean 可以理解的有组织的语言（类似于编程语言）编写数学定义、定理和证明。作为回报，Lean 提供反馈和信息，解释表达式并保证它们是良好形成的，并最终证明我们证明的正确性。
- en: You can learn more about Lean from the [Lean project page](https://leanprover.github.io)
    and the [Lean community web pages](https://leanprover-community.github.io/). This
    tutorial is based on Lean’s large and ever-growing library, *Mathlib*. We also
    strongly recommend joining the [Lean Zulip online chat group](https://leanprover.zulipchat.com/)
    if you haven’t already. You’ll find a lively and welcoming community of Lean enthusiasts
    there, happy to answer questions and offer moral support.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 [Lean 项目页面](https://leanprover.github.io) 和 [Lean 社区网页](https://leanprover-community.github.io/)
    了解更多关于 Lean 的信息。本教程基于 Lean 的庞大且不断增长的库 *Mathlib*。我们还强烈建议如果你还没有的话，加入 [Lean Zulip
    在线聊天组](https://leanprover.zulipchat.com/)。在那里，你会发现一个充满活力和欢迎的 Lean 爱好者社区，他们乐于回答问题和提供精神支持。
- en: 'Although you can read a pdf or html version of this book online, it is designed
    to be read interactively, running Lean from inside the VS Code editor. To get
    started:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在网上阅读这本书的 pdf 或 html 版本，但它旨在进行交互式阅读，在 VS Code 编辑器中运行 Lean。要开始：
- en: Install Lean 4 and VS Code following these [installation instructions](https://leanprover-community.github.io/get_started.html).
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下[安装说明](https://leanprover-community.github.io/get_started.html)安装 Lean 4
    和 VS Code。
- en: Make sure you have [git](https://git-scm.com/) installed.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你已经安装了 [git](https://git-scm.com/)。
- en: Follow these [instructions](https://leanprover-community.github.io/install/project.html#working-on-an-existing-project)
    to fetch the `mathematics_in_lean` repository and open it up in VS Code.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下[说明](https://leanprover-community.github.io/install/project.html#working-on-an-existing-project)获取
    `mathematics_in_lean` 仓库并在 VS Code 中打开它。
- en: Each section in this book has an associated Lean file with examples and exercises.
    You can find them in the folder `MIL`, organized by chapter. We strongly recommend
    making a copy of that folder and experimenting and doing the exercises in that
    copy. This leaves the originals intact, and it also makes it easier to update
    the repository as it changes (see below). You can call the copy `my_files` or
    whatever you want and use it to create your own Lean files as well.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本书中的每一节都有一个相关的 Lean 文件，其中包含示例和练习。你可以在 `MIL` 文件夹中找到它们，按章节组织。我们强烈建议复制该文件夹并在这个副本中进行实验和练习。这样，原始文件保持不变，也使得在更改时更新仓库更容易（见下文）。你可以将副本命名为
    `my_files` 或你想要的任何名称，并使用它来创建你自己的 Lean 文件。
- en: 'At that point, you can open the textbook in a side panel in VS Code as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个阶段，你可以按照以下方式在 VS Code 的侧面板中打开教科书：
- en: Type `ctrl-shift-P` (`command-shift-P` in macOS).
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `ctrl-shift-P` (`command-shift-P` 在 macOS 上)。
- en: 'Type `Lean 4: Docs: Show Documentation Resources` in the bar that appears,
    and then press return. (You can press return to select it as soon as it is highlighted
    in the menu.)'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在出现的栏中输入 `Lean 4: Docs: Show Documentation Resources`，然后按回车键。（你可以在它被菜单中的高亮显示后按回车键来选择它。）'
- en: In the window that opens, click on `Mathematics in Lean`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的窗口中，点击 `Mathematics in Lean`。
- en: Alternatively, you can run Lean and VS Code in the cloud, using [Gitpod](https://gitpod.io/).
    You can find instructions as to how to do that on the Mathematics in Lean [project
    page](https://github.com/leanprover-community/mathematics_in_lean) on Github.
    We still recommend working in a copy of the MIL folder, as described above.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在云中使用 Lean 和 VS Code，使用 [Gitpod](https://gitpod.io/)。你可以在 Github 上的 Mathematics
    in Lean [项目页面](https://github.com/leanprover-community/mathematics_in_lean)上找到如何做到这一点的说明。我们仍然建议使用上面描述的
    MIL 文件夹的副本进行工作。
- en: This textbook and the associated repository are still a work in progress. You
    can update the repository by typing `git pull` followed by `lake exe cache get`
    inside the `mathematics_in_lean` folder. (This assumes that you have not changed
    the contents of the `MIL` folder, which is why we suggested making a copy.)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这本教科书和相关的仓库仍在进行中。你可以在 `mathematics_in_lean` 文件夹内通过输入 `git pull` 后跟 `lake exe
    cache get` 来更新仓库。（这假设你没有更改 `MIL` 文件夹的内容，这就是我们建议制作副本的原因。）
- en: 'We intend for you to work on the exercises in the `MIL` folder while reading
    the textbook, which contains explanations, instructions, and hints. The text will
    often include examples, like this one:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你在阅读包含解释、说明和提示的教科书的同时，在 `MIL` 文件夹中完成练习。文本通常会包括例子，就像这个例子一样：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You should be able to find the corresponding example in the associated Lean
    file. If you click on the line, VS Code will show you Lean’s feedback in the `Lean
    Goal` window, and if you hover your cursor over the `#eval` command VS Code will
    show you Lean’s response to this command in a pop-up window. You are encouraged
    to edit the file and try examples of your own.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够在相关的 Lean 文件中找到相应的例子。如果你点击该行，VS Code 将在 `Lean Goal` 窗口中显示 Lean 的反馈，如果你将鼠标悬停在
    `#eval` 命令上，VS Code 将在弹出窗口中显示 Lean 对此命令的响应。你被鼓励编辑文件并尝试自己的例子。
- en: This book moreover provides lots of challenging exercises for you to try. Don’t
    rush past these! Lean is about *doing* mathematics interactively, not just reading
    about it. Working through the exercises is central to the experience. You don’t
    have to do all of them; when you feel comfortable that you have mastered the relevant
    skills, feel free to move on. You can always compare your solutions to the ones
    in the `solutions` folder associated with each section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这本书还提供了许多具有挑战性的练习供你尝试。不要匆匆略过这些！Lean 是关于 *交互式* 做数学，而不仅仅是阅读它。完成练习是体验的核心。你不必全部完成；当你觉得你已经掌握了相关技能时，你可以自由地继续前进。你总是可以比较你的解决方案与每个部分相关的
    `solutions` 文件夹中的解决方案。
- en: 1.2\. Overview[](#overview "Link to this heading")
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2. 概述[](#overview "链接到这个标题")
- en: Put simply, Lean is a tool for building complex expressions in a formal language
    known as *dependent type theory*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Lean 是一个用于在称为 *依赖类型理论* 的形式语言中构建复杂表达式的工具。
- en: 'Every expression has a *type*, and you can use the #check command to print
    it. Some expressions have types like ℕ or ℕ → ℕ. These are mathematical objects.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '每个表达式都有一个 *类型*，你可以使用 #check 命令来打印它。一些表达式的类型像 ℕ 或 ℕ → ℕ。这些都是数学对象。'
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Some expressions have type Prop. These are mathematical statements.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一些表达式的类型是 Prop。这些都是数学陈述。
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Some expressions have a type, P, where P itself has type Prop. Such an expression
    is a proof of the proposition P.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一些表达式的类型是 P，其中 P 本身有类型 Prop。这样的表达式是命题 P 的证明。
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you manage to construct an expression of type `FermatLastTheorem` and Lean
    accepts it as a term of that type, you have done something very impressive. (Using
    `sorry` is cheating, and Lean knows it.) So now you know the game. All that is
    left to learn are the rules.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你设法构造了一个类型为 `FermatLastTheorem` 的表达式，并且 Lean 接受它作为该类型的项，那么你已经做了非常令人印象深刻的事情。（使用
    `sorry` 是作弊，Lean 知道这一点。）所以现在你知道游戏规则了。剩下要学的是规则。
- en: This book is complementary to a companion tutorial, [Theorem Proving in Lean](https://leanprover.github.io/theorem_proving_in_lean4/),
    which provides a more thorough introduction to the underlying logical framework
    and core syntax of Lean. *Theorem Proving in Lean* is for people who prefer to
    read a user manual cover to cover before using a new dishwasher. If you are the
    kind of person who prefers to hit the *start* button and figure out how to activate
    the potscrubber feature later, it makes more sense to start here and refer back
    to *Theorem Proving in Lean* as necessary.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本书与配套教程 [Theorem Proving in Lean](https://leanprover.github.io/theorem_proving_in_lean4/)
    相辅相成，后者提供了对 Lean 的底层逻辑框架和核心语法的更全面介绍。*Theorem Proving in Lean* 适合那些喜欢在使用新洗碗机之前从头到尾阅读用户手册的人。如果你是那种喜欢按下
    *启动* 按钮，稍后再找出如何激活去污功能的人，那么从这里开始，并在需要时参考 *Theorem Proving in Lean* 会更有意义。
- en: 'Another thing that distinguishes *Mathematics in Lean* from *Theorem Proving
    in Lean* is that here we place a much greater emphasis on the use of *tactics*.
    Given that we are trying to build complex expressions, Lean offers two ways of
    going about it: we can write down the expressions themselves (that is, suitable
    text descriptions thereof), or we can provide Lean with *instructions* as to how
    to construct them. For example, the following expression represents a proof of
    the fact that if `n` is even then so is `m * n`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区分 *Mathematics in Lean* 和 *Theorem Proving in Lean* 的特点是，在这里我们更加重视 *tactics*
    的使用。鉴于我们试图构建复杂的表达式，Lean 提供了两种方法来实现这一点：我们可以写下表达式本身（即其合适的文本描述），或者我们可以向 Lean 提供如何构建它们的
    *指令*。例如，以下表达式代表了一个证明，即如果 `n` 是偶数，那么 `m * n` 也是偶数：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The *proof term* can be compressed to a single line:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*证明项* 可以压缩成一行：'
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following is, instead, a *tactic-style* proof of the same theorem, where
    lines starting with `--` are comments, hence ignored by Lean:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是同一定理的 *策略风格* 证明，其中以 `--` 开头的行是注释，因此 Lean 会忽略它们：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you enter each line of such a proof in VS Code, Lean displays the *proof
    state* in a separate window, telling you what facts you have already established
    and what tasks remain to prove your theorem. You can replay the proof by stepping
    through the lines, since Lean will continue to show you the state of the proof
    at the point where the cursor is. In this example, you will then see that the
    first line of the proof introduces `m` and `n` (we could have renamed them at
    that point, if we wanted to), and also decomposes the hypothesis `Even n` to a
    `k` and the assumption that `n = 2 * k`. The second line, `use m * k`, declares
    that we are going to show that `m * n` is even by showing `m * n = 2 * (m * k)`.
    The next line uses the `rw` tactic to replace `n` by `2 * k` in the goal (`rw`
    stands for “rewrite”), and the `ring` tactic solves the resulting goal `m * (2
    * k) = 2 * (m * k)`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 VS Code 中输入这样证明的每一行时，Lean 会在一个单独的窗口中显示 *证明状态*，告诉你你已经建立了哪些事实，以及还需要证明定理的任务。你可以通过逐行执行来重放证明，因为
    Lean 会继续显示光标所在点的证明状态。在这个例子中，你会发现证明的第一行引入了 `m` 和 `n`（如果我们想的话，我们可以在那时将它们重命名），并且还将假设
    `Even n` 分解为 `k` 和 `n = 2 * k`。第二行 `use m * k` 声明我们将通过展示 `m * n = 2 * (m * k)`
    来证明 `m * n` 是偶数。下一行使用 `rw` 策略将目标中的 `n` 替换为 `2 * k`（`rw` 代表“重写”），而 `ring` 策略解决了由此产生的目标
    `m * (2 * k) = 2 * (m * k)`。
- en: 'The ability to build a proof in small steps with incremental feedback is extremely
    powerful. For that reason, tactic proofs are often easier and quicker to write
    than proof terms. There isn’t a sharp distinction between the two: tactic proofs
    can be inserted in proof terms, as we did with the phrase `by rw [hk, mul_add]`
    in the example above. We will also see that, conversely, it is often useful to
    insert a short proof term in the middle of a tactic proof. That said, in this
    book, our emphasis will be on the use of tactics.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以小步骤构建证明并逐步提供反馈的能力非常强大。因此，策略证明通常比证明项更容易、更快地编写。两者之间没有明显的区别：策略证明可以插入到证明项中，就像我们在上面的例子中使用短语
    `by rw [hk, mul_add]` 一样。我们还将看到，相反，在策略证明的中间插入一个简短的证明项通常很有用。尽管如此，在这本书中，我们将重点介绍策略的使用。
- en: 'In our example, the tactic proof can also be reduced to a one-liner:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，策略证明也可以简化为一行：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here we have used tactics to carry out small proof steps. But they can also
    provide substantial automation, and justify longer calculations and bigger inferential
    steps. For example, we can invoke Lean’s simplifier with specific rules for simplifying
    statements about parity to prove our theorem automatically.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了策略来执行小的证明步骤。但它们也可以提供实质性的自动化，并证明更长的计算和更大的推理步骤是合理的。例如，我们可以使用Lean的简化器，并应用特定的规则来简化关于偶性的陈述，从而自动证明我们的定理。
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Another big difference between the two introductions is that *Theorem Proving
    in Lean* depends only on core Lean and its built-in tactics, whereas *Mathematics
    in Lean* is built on top of Lean’s powerful and ever-growing library, *Mathlib*.
    As a result, we can show you how to use some of the mathematical objects and theorems
    in the library, and some of the very useful tactics. This book is not meant to
    be used as an complete overview of the library; the [community](https://leanprover-community.github.io/)
    web pages contain extensive documentation. Rather, our goal is to introduce you
    to the style of thinking that underlies that formalization, and point out basic
    entry points so that you are comfortable browsing the library and finding things
    on your own.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 两个介绍之间的另一个重大区别是，*Lean中的定理证明*仅依赖于核心Lean及其内置策略，而*Lean中的数学*建立在Lean强大且不断增长的库*Mathlib*之上。因此，我们可以向您展示如何使用库中的一些数学对象和定理，以及一些非常有用的策略。这本书的目的不是用作库的完整概述；[社区](https://leanprover-community.github.io/)网页包含了广泛的文档。相反，我们的目标是向您介绍支撑这种形式化的思维方式，并指出基本的入门点，以便您能够舒适地浏览库并自行查找内容。
- en: Interactive theorem proving can be frustrating, and the learning curve is steep.
    But the Lean community is very welcoming to newcomers, and people are available
    on the [Lean Zulip chat group](https://leanprover.zulipchat.com/) round the clock
    to answer questions. We hope to see you there, and have no doubt that soon enough
    you, too, will be able to answer such questions and contribute to the development
    of *Mathlib*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式定理证明可能会令人沮丧，学习曲线很陡峭。但Lean社区对新来者非常欢迎，人们全天候在[Lean Zulip聊天组](https://leanprover.zulipchat.com/)上提供帮助，回答问题。我们希望在那里见到您，并确信不久您也将能够回答这样的问题并为*Mathlib*的发展做出贡献。
- en: 'So here is your mission, should you choose to accept it: dive in, try the exercises,
    come to Zulip with questions, and have fun. But be forewarned: interactive theorem
    proving will challenge you to think about mathematics and mathematical reasoning
    in fundamentally new ways. Your life may never be the same.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是您的任务，如果您选择接受它：深入其中，尝试练习，带着问题来Zulip，享受乐趣。但请提前警告：交互式定理证明将挑战您以全新的方式思考数学和数学推理。您的生活可能永远不再一样。
- en: '*Acknowledgments.* We are grateful to Gabriel Ebner for setting up the infrastructure
    for running this tutorial in VS Code, and to Kim Morrison and Mario Carneiro for
    help porting it from Lean 4. We are also grateful for help and corrections from
    Takeshi Abe, Julian Berman, Alex Best, Thomas Browning, Bulwi Cha, Hanson Char,
    Bryan Gin-ge Chen, Steven Clontz, Mauricio Collaris, Johan Commelin, Mark Czubin,
    Alexandru Duca, Pierpaolo Frasa, Denis Gorbachev, Winston de Greef, Mathieu Guay-Paquet,
    Marc Huisinga, Benjamin Jones, Julian Külshammer, Victor Liu, Jimmy Lu, Martin
    C. Martin, Giovanni Mascellani, John McDowell, Joseph McKinsey, Bhavik Mehta,
    Isaiah Mindich, Kabelo Moiloa, Hunter Monroe, Pietro Monticone, Oliver Nash, Emanuelle
    Natale, Filippo A. E. Nuccio, Pim Otte, Bartosz Piotrowski, Nicolas Rolland, Keith
    Rush, Yannick Seurin, Guilherme Silva, Bernardo Subercaseaux, Pedro Sánchez Terraf,
    Matthew Toohey, Alistair Tucker, Floris van Doorn, Eric Wieser, and others. Our
    work has been partially supported by the Hoskinson Center for Formal Mathematics.
    [Previous](index.html "Mathematics in Lean") [Next](C02_Basics.html "2\. Basics")'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*致谢。*我们感谢Gabriel Ebner为在VS Code中运行此教程的基础设施，以及Kim Morrison和Mario Carneiro将其从Lean
    4迁移过来提供的帮助。我们还感谢Takeshi Abe、Julian Berman、Alex Best、Thomas Browning、Bulwi Cha、Hanson
    Char、Bryan Gin-ge Chen、Steven Clontz、Mauricio Collaris、Johan Commelin、Mark Czubin、Alexandru
    Duca、Pierpaolo Frasa、Denis Gorbachev、Winston de Greef、Mathieu Guay-Paquet、Marc
    Huisinga、Benjamin Jones、Julian Külshammer、Victor Liu、Jimmy Lu、Martin C. Martin、Giovanni
    Mascellani、John McDowell、Joseph McKinsey、Bhavik Mehta、Isaiah Mindich、Kabelo Moiloa、Hunter
    Monroe、Pietro Monticone、Oliver Nash、Emanuelle Natale、Filippo A. E. Nuccio、Pim
    Otte、Bartosz Piotrowski、Nicolas Rolland、Keith Rush、Yannick Seurin、Guilherme Silva、Bernardo
    Subercaseaux、Pedro Sánchez Terraf、Matthew Toohey、Alistair Tucker、Floris van Doorn、Eric
    Wieser和其他人的帮助。我们的工作部分得到了Hoskinson形式数学中心的支持。[上一页](index.html "Lean中的数学") [下一页](C02_Basics.html
    "2. 基础")'
- en: '* * *'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: © Copyright 2020-2025, Jeremy Avigad, Patrick Massot. Text licensed under CC
    BY 4.0.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: © 版权所有 2020-2025，Jeremy Avigad，Patrick Massot。文本许可协议为CC BY 4.0。
- en: 'Built with [Sphinx](https://www.sphinx-doc.org/) using a [theme](https://github.com/readthedocs/sphinx_rtd_theme)
    provided by [Read the Docs](https://readthedocs.org). ## 1.1\. Getting Started[](#getting-started
    "Link to this heading")'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[Sphinx](https://www.sphinx-doc.org/)和[Read the Docs](https://readthedocs.org)提供的[主题](https://github.com/readthedocs/sphinx_rtd_theme)构建。##
    1.1. 开始使用[](#getting-started "链接到本标题")
- en: 'The goal of this book is to teach you to formalize mathematics using the Lean
    4 interactive proof assistant. It assumes that you know some mathematics, but
    it does not require much. Although we will cover examples ranging from number
    theory to measure theory and analysis, we will focus on elementary aspects of
    those fields, in the hopes that if they are not familiar to you, you can pick
    them up as you go. We also don’t presuppose any background with formal methods.
    Formalization can be seen as a kind of computer programming: we will write mathematical
    definitions, theorems, and proofs in a regimented language, like a programming
    language, that Lean can understand. In return, Lean provides feedback and information,
    interprets expressions and guarantees that they are well-formed, and ultimately
    certifies the correctness of our proofs.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目标是教会您使用Lean 4交互式证明辅助工具形式化数学。它假设您了解一些数学知识，但不需要太多。尽管我们将涵盖从数论到测度理论和分析的例子，但我们将重点介绍这些领域的初等方面，希望如果您不熟悉，您可以在学习过程中掌握它们。我们也不预设任何关于形式方法的背景知识。形式化可以看作是一种计算机编程：我们将使用Lean可以理解的有组织的语言（类似于编程语言）编写数学定义、定理和证明。作为回报，Lean提供反馈和信息，解释表达式并保证它们是良好形成的，并最终证明我们的证明是正确的。
- en: You can learn more about Lean from the [Lean project page](https://leanprover.github.io)
    and the [Lean community web pages](https://leanprover-community.github.io/). This
    tutorial is based on Lean’s large and ever-growing library, *Mathlib*. We also
    strongly recommend joining the [Lean Zulip online chat group](https://leanprover.zulipchat.com/)
    if you haven’t already. You’ll find a lively and welcoming community of Lean enthusiasts
    there, happy to answer questions and offer moral support.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[Lean项目页面](https://leanprover.github.io)和[Lean社区网页](https://leanprover-community.github.io/)了解更多关于Lean的信息。本教程基于Lean的大型且不断增长的库*Mathlib*。我们还强烈建议如果您还没有，加入[Lean
    Zulip在线聊天组](https://leanprover.zulipchat.com/)。在那里，您会发现一个充满活力和欢迎的Lean爱好者社区，他们乐于回答问题和提供道德支持。
- en: 'Although you can read a pdf or html version of this book online, it is designed
    to be read interactively, running Lean from inside the VS Code editor. To get
    started:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以在网上阅读这本书的pdf或html版本，但它旨在交互式阅读，在VS Code编辑器中运行Lean。要开始：
- en: Install Lean 4 and VS Code following these [installation instructions](https://leanprover-community.github.io/get_started.html).
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照这些[安装说明](https://leanprover-community.github.io/get_started.html)安装Lean 4和VS
    Code。
- en: Make sure you have [git](https://git-scm.com/) installed.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您已安装[git](https://git-scm.com/)。
- en: Follow these [instructions](https://leanprover-community.github.io/install/project.html#working-on-an-existing-project)
    to fetch the `mathematics_in_lean` repository and open it up in VS Code.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照这些[说明](https://leanprover-community.github.io/install/project.html#working-on-an-existing-project)获取`mathematics_in_lean`存储库，并在VS
    Code中打开它。
- en: Each section in this book has an associated Lean file with examples and exercises.
    You can find them in the folder `MIL`, organized by chapter. We strongly recommend
    making a copy of that folder and experimenting and doing the exercises in that
    copy. This leaves the originals intact, and it also makes it easier to update
    the repository as it changes (see below). You can call the copy `my_files` or
    whatever you want and use it to create your own Lean files as well.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本书中的每一节都有一个相关的Lean文件，包含示例和练习。您可以在`MIL`文件夹中找到它们，按章节组织。我们强烈建议复制该文件夹，并在其中进行实验和练习。这样，原始文件保持不变，也使得在更改时更新存储库更容易（见下文）。您可以将其命名为`my_files`或您想要的任何名称，并使用它来创建您自己的Lean文件。
- en: 'At that point, you can open the textbook in a side panel in VS Code as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到那时，您可以在VS Code的侧面板中打开教科书，如下所示：
- en: Type `ctrl-shift-P` (`command-shift-P` in macOS).
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`ctrl-shift-P`（在macOS中为`command-shift-P`）。
- en: 'Type `Lean 4: Docs: Show Documentation Resources` in the bar that appears,
    and then press return. (You can press return to select it as soon as it is highlighted
    in the menu.)'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在出现的栏中输入`Lean 4: Docs: Show Documentation Resources`，然后按回车键。（您可以在它被菜单中的高亮显示后立即按回车键选择它。）'
- en: In the window that opens, click on `Mathematics in Lean`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的窗口中，点击 `Mathematics in Lean`。
- en: Alternatively, you can run Lean and VS Code in the cloud, using [Gitpod](https://gitpod.io/).
    You can find instructions as to how to do that on the Mathematics in Lean [project
    page](https://github.com/leanprover-community/mathematics_in_lean) on Github.
    We still recommend working in a copy of the MIL folder, as described above.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在云中使用 Lean 和 VS Code，使用 [Gitpod](https://gitpod.io/)。你可以在 Github 上的 Mathematics
    in Lean [项目页面](https://github.com/leanprover-community/mathematics_in_lean)上找到如何做到这一点的说明。我们仍然建议按照上述方法在
    `MIL` 文件夹的副本中工作。
- en: This textbook and the associated repository are still a work in progress. You
    can update the repository by typing `git pull` followed by `lake exe cache get`
    inside the `mathematics_in_lean` folder. (This assumes that you have not changed
    the contents of the `MIL` folder, which is why we suggested making a copy.)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这本教科书和相关的仓库仍在进行中。你可以在 `mathematics_in_lean` 文件夹内通过输入 `git pull` 然后跟 `lake exe
    cache get` 来更新仓库。（这假设你没有更改 `MIL` 文件夹的内容，这就是我们建议制作副本的原因。）
- en: 'We intend for you to work on the exercises in the `MIL` folder while reading
    the textbook, which contains explanations, instructions, and hints. The text will
    often include examples, like this one:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你在阅读包含解释、指令和提示的教科书的同时，在 `MIL` 文件夹中完成练习。文本通常会包括示例，就像这个例子一样：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You should be able to find the corresponding example in the associated Lean
    file. If you click on the line, VS Code will show you Lean’s feedback in the `Lean
    Goal` window, and if you hover your cursor over the `#eval` command VS Code will
    show you Lean’s response to this command in a pop-up window. You are encouraged
    to edit the file and try examples of your own.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在相关的 Lean 文件中找到相应的示例。如果你点击该行，VS Code 将在 `Lean Goal` 窗口中显示 Lean 的反馈，如果你将鼠标悬停在
    `#eval` 命令上，VS Code 将在弹出窗口中显示 Lean 对此命令的响应。鼓励你编辑文件并尝试自己的示例。
- en: This book moreover provides lots of challenging exercises for you to try. Don’t
    rush past these! Lean is about *doing* mathematics interactively, not just reading
    about it. Working through the exercises is central to the experience. You don’t
    have to do all of them; when you feel comfortable that you have mastered the relevant
    skills, feel free to move on. You can always compare your solutions to the ones
    in the `solutions` folder associated with each section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本书还提供了许多具有挑战性的练习供你尝试。不要匆匆而过！Lean 是关于 *交互式* 做数学，而不仅仅是阅读它。完成练习是体验的核心。你不必全部完成；当你觉得你已经掌握了相关技能时，可以自由地继续前进。你总是可以比较你的解决方案与每个部分相关的
    `solutions` 文件夹中的解决方案。
- en: 1.2\. Overview[](#overview "Link to this heading")
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2. 概述[](#overview "链接到这个标题")
- en: Put simply, Lean is a tool for building complex expressions in a formal language
    known as *dependent type theory*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Lean 是一个用于在名为 *依赖类型理论* 的形式语言中构建复杂表达式的工具。
- en: 'Every expression has a *type*, and you can use the #check command to print
    it. Some expressions have types like ℕ or ℕ → ℕ. These are mathematical objects.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '每个表达式都有一个 *类型*，你可以使用 #check 命令来打印它。一些表达式具有类型如 ℕ 或 ℕ → ℕ。这些是数学对象。'
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Some expressions have type Prop. These are mathematical statements.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一些表达式具有类型 Prop。这些是数学陈述。
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Some expressions have a type, P, where P itself has type Prop. Such an expression
    is a proof of the proposition P.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一些表达式具有类型 P，其中 P 本身具有类型 Prop。这样的表达式是命题 P 的证明。
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you manage to construct an expression of type `FermatLastTheorem` and Lean
    accepts it as a term of that type, you have done something very impressive. (Using
    `sorry` is cheating, and Lean knows it.) So now you know the game. All that is
    left to learn are the rules.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你成功构造了一个类型为 `FermatLastTheorem` 的表达式，并且 Lean 接受它作为该类型的项，那么你已经做了非常令人印象深刻的事情。（使用
    `sorry` 是作弊，而 Lean 知道这一点。）所以现在你知道游戏规则了。剩下要学的就是规则了。
- en: This book is complementary to a companion tutorial, [Theorem Proving in Lean](https://leanprover.github.io/theorem_proving_in_lean4/),
    which provides a more thorough introduction to the underlying logical framework
    and core syntax of Lean. *Theorem Proving in Lean* is for people who prefer to
    read a user manual cover to cover before using a new dishwasher. If you are the
    kind of person who prefers to hit the *start* button and figure out how to activate
    the potscrubber feature later, it makes more sense to start here and refer back
    to *Theorem Proving in Lean* as necessary.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书与一个配套教程 [Lean 中的定理证明](https://leanprover.github.io/theorem_proving_in_lean4/)
    相辅相成，该教程提供了对 Lean 的底层逻辑框架和核心语法的更全面介绍。*Lean 中的定理证明* 是为那些喜欢在使用新洗碗机之前从头到尾阅读用户手册的人准备的。如果你是那种喜欢按下
    *开始* 按钮，稍后再找出如何激活去污功能的人，那么从这里开始，并在需要时参考 *Lean 中的定理证明* 会更有意义。
- en: 'Another thing that distinguishes *Mathematics in Lean* from *Theorem Proving
    in Lean* is that here we place a much greater emphasis on the use of *tactics*.
    Given that we are trying to build complex expressions, Lean offers two ways of
    going about it: we can write down the expressions themselves (that is, suitable
    text descriptions thereof), or we can provide Lean with *instructions* as to how
    to construct them. For example, the following expression represents a proof of
    the fact that if `n` is even then so is `m * n`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个将 *Lean 中的数学* 与 *Lean 中的定理证明* 区分开来的特点是，在这里我们更加重视 *策略* 的使用。鉴于我们试图构建复杂的表达式，Lean
    提供了两种方法：我们可以写下表达式本身（即其合适的文本描述），或者我们可以向 Lean 提供如何构建它们的 *指令*。例如，以下表达式代表了一个证明，即如果
    `n` 是偶数，那么 `m * n` 也是偶数：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The *proof term* can be compressed to a single line:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*证明项*可以被压缩成一行：'
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following is, instead, a *tactic-style* proof of the same theorem, where
    lines starting with `--` are comments, hence ignored by Lean:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个相反的 *策略风格* 的同一定理证明，其中以 `--` 开头的行是注释，因此 Lean 会忽略它们：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you enter each line of such a proof in VS Code, Lean displays the *proof
    state* in a separate window, telling you what facts you have already established
    and what tasks remain to prove your theorem. You can replay the proof by stepping
    through the lines, since Lean will continue to show you the state of the proof
    at the point where the cursor is. In this example, you will then see that the
    first line of the proof introduces `m` and `n` (we could have renamed them at
    that point, if we wanted to), and also decomposes the hypothesis `Even n` to a
    `k` and the assumption that `n = 2 * k`. The second line, `use m * k`, declares
    that we are going to show that `m * n` is even by showing `m * n = 2 * (m * k)`.
    The next line uses the `rw` tactic to replace `n` by `2 * k` in the goal (`rw`
    stands for “rewrite”), and the `ring` tactic solves the resulting goal `m * (2
    * k) = 2 * (m * k)`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 VS Code 中输入这样一条证明的每一行时，Lean 会在一个单独的窗口中显示 *证明状态*，告诉你你已经建立了哪些事实，以及还需要证明定理的任务。你可以通过逐行回放证明，因为
    Lean 会继续显示光标所在点的证明状态。在这个例子中，你会看到证明的第一行引入了 `m` 和 `n`（如果我们想的话，我们可以在那时给它们重新命名），并且将假设
    `Even n` 分解为 `k` 和 `n = 2 * k` 的假设。第二行 `use m * k` 声明我们将通过展示 `m * n = 2 * (m *
    k)` 来证明 `m * n` 是偶数。下一行使用 `rw` 策略将目标中的 `n` 替换为 `2 * k`（`rw` 代表“重写”），而 `ring` 策略解决了由此产生的目标
    `m * (2 * k) = 2 * (m * k)`。
- en: 'The ability to build a proof in small steps with incremental feedback is extremely
    powerful. For that reason, tactic proofs are often easier and quicker to write
    than proof terms. There isn’t a sharp distinction between the two: tactic proofs
    can be inserted in proof terms, as we did with the phrase `by rw [hk, mul_add]`
    in the example above. We will also see that, conversely, it is often useful to
    insert a short proof term in the middle of a tactic proof. That said, in this
    book, our emphasis will be on the use of tactics.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 能够以小步骤构建证明并得到增量反馈的能力非常强大。因此，策略证明通常比证明项更容易和更快地编写。两者之间没有明显的区别：策略证明可以插入到证明项中，就像我们在上面的例子中用短语
    `by rw [hk, mul_add]` 所做的那样。我们还将看到，相反地，在策略证明的中间插入一个简短的证明项通常是有用的。尽管如此，在这本书中，我们将侧重于策略的使用。
- en: 'In our example, the tactic proof can also be reduced to a one-liner:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，策略证明也可以简化为一行：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here we have used tactics to carry out small proof steps. But they can also
    provide substantial automation, and justify longer calculations and bigger inferential
    steps. For example, we can invoke Lean’s simplifier with specific rules for simplifying
    statements about parity to prove our theorem automatically.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了策略来执行小的证明步骤。但它们也可以提供实质性的自动化，并证明更长的计算和更大的推理步骤。例如，我们可以使用Lean的简化器，并应用特定的规则来简化关于偶数的陈述，从而自动证明我们的定理。
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Another big difference between the two introductions is that *Theorem Proving
    in Lean* depends only on core Lean and its built-in tactics, whereas *Mathematics
    in Lean* is built on top of Lean’s powerful and ever-growing library, *Mathlib*.
    As a result, we can show you how to use some of the mathematical objects and theorems
    in the library, and some of the very useful tactics. This book is not meant to
    be used as an complete overview of the library; the [community](https://leanprover-community.github.io/)
    web pages contain extensive documentation. Rather, our goal is to introduce you
    to the style of thinking that underlies that formalization, and point out basic
    entry points so that you are comfortable browsing the library and finding things
    on your own.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 两个介绍之间的另一个重大区别是，*Lean中的定理证明*仅依赖于核心Lean及其内置策略，而*Lean中的数学*建立在Lean强大且不断增长的库*Mathlib*之上。因此，我们可以向你展示如何使用库中的一些数学对象和定理，以及一些非常有用的策略。这本书的目的不是用作库的完整概述；[社区](https://leanprover-community.github.io/)网页包含了广泛的文档。相反，我们的目标是介绍支撑这种形式化的思维方式，并指出基本的入门点，以便你能够舒适地浏览库并自己找到所需的内容。
- en: Interactive theorem proving can be frustrating, and the learning curve is steep.
    But the Lean community is very welcoming to newcomers, and people are available
    on the [Lean Zulip chat group](https://leanprover.zulipchat.com/) round the clock
    to answer questions. We hope to see you there, and have no doubt that soon enough
    you, too, will be able to answer such questions and contribute to the development
    of *Mathlib*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式定理证明可能会让人感到沮丧，学习曲线也很陡峭。但Lean社区对新来者非常欢迎，人们全天候在[Lean Zulip聊天组](https://leanprover.zulipchat.com/)上提供帮助，解答问题。我们希望在那里见到你，并且确信不久之后你也能回答这样的问题，并为*Mathlib*的发展做出贡献。
- en: 'So here is your mission, should you choose to accept it: dive in, try the exercises,
    come to Zulip with questions, and have fun. But be forewarned: interactive theorem
    proving will challenge you to think about mathematics and mathematical reasoning
    in fundamentally new ways. Your life may never be the same.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这里是你可以选择接受的任务：深入其中，尝试练习，带着问题来Zulip，享受乐趣。但请提前警告：交互式定理证明将挑战你以全新的方式思考数学和数学推理。你的生活可能永远不再一样。
- en: '*Acknowledgments.* We are grateful to Gabriel Ebner for setting up the infrastructure
    for running this tutorial in VS Code, and to Kim Morrison and Mario Carneiro for
    help porting it from Lean 4. We are also grateful for help and corrections from
    Takeshi Abe, Julian Berman, Alex Best, Thomas Browning, Bulwi Cha, Hanson Char,
    Bryan Gin-ge Chen, Steven Clontz, Mauricio Collaris, Johan Commelin, Mark Czubin,
    Alexandru Duca, Pierpaolo Frasa, Denis Gorbachev, Winston de Greef, Mathieu Guay-Paquet,
    Marc Huisinga, Benjamin Jones, Julian Külshammer, Victor Liu, Jimmy Lu, Martin
    C. Martin, Giovanni Mascellani, John McDowell, Joseph McKinsey, Bhavik Mehta,
    Isaiah Mindich, Kabelo Moiloa, Hunter Monroe, Pietro Monticone, Oliver Nash, Emanuelle
    Natale, Filippo A. E. Nuccio, Pim Otte, Bartosz Piotrowski, Nicolas Rolland, Keith
    Rush, Yannick Seurin, Guilherme Silva, Bernardo Subercaseaux, Pedro Sánchez Terraf,
    Matthew Toohey, Alistair Tucker, Floris van Doorn, Eric Wieser, and others. Our
    work has been partially supported by the Hoskinson Center for Formal Mathematics.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*致谢。*我们感谢Gabriel Ebner为在VS Code中运行此教程的基础设施，以及Kim Morrison和Mario Carneiro将其从Lean
    4迁移过来提供的帮助。我们还感谢Takeshi Abe、Julian Berman、Alex Best、Thomas Browning、Bulwi Cha、Hanson
    Char、Bryan Gin-ge Chen、Steven Clontz、Mauricio Collaris、Johan Commelin、Mark Czubin、Alexandru
    Duca、Pierpaolo Frasa、Denis Gorbachev、Winston de Greef、Mathieu Guay-Paquet、Marc
    Huisinga、Benjamin Jones、Julian Külshammer、Victor Liu、Jimmy Lu、Martin C. Martin、Giovanni
    Mascellani、John McDowell、Joseph McKinsey、Bhavik Mehta、Isaiah Mindich、Kabelo Moiloa、Hunter
    Monroe、Pietro Monticone、Oliver Nash、Emanuelle Natale、Filippo A. E. Nuccio、Pim
    Otte、Bartosz Piotrowski、Nicolas Rolland、Keith Rush、Yannick Seurin、Guilherme Silva、Bernardo
    Subercaseaux、Pedro Sánchez Terraf、Matthew Toohey、Alistair Tucker、Floris van Doorn、Eric
    Wieser和其他人的帮助。我们的工作得到了Hoskinson形式数学中心的部分支持。'
- en: 1.1\. Getting Started[](#getting-started "Link to this heading")
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1\. 开始[](#getting-started "链接到这个标题")
- en: 'The goal of this book is to teach you to formalize mathematics using the Lean
    4 interactive proof assistant. It assumes that you know some mathematics, but
    it does not require much. Although we will cover examples ranging from number
    theory to measure theory and analysis, we will focus on elementary aspects of
    those fields, in the hopes that if they are not familiar to you, you can pick
    them up as you go. We also don’t presuppose any background with formal methods.
    Formalization can be seen as a kind of computer programming: we will write mathematical
    definitions, theorems, and proofs in a regimented language, like a programming
    language, that Lean can understand. In return, Lean provides feedback and information,
    interprets expressions and guarantees that they are well-formed, and ultimately
    certifies the correctness of our proofs.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目标是教会你使用 Lean 4 交互式证明辅助工具来形式化数学。它假设你了解一些数学知识，但不需要太多。尽管我们将涵盖从数论到测度论和分析的例子，但我们将专注于这些领域的初阶方面，希望如果你不熟悉它们，你可以在学习过程中掌握它们。我们也不预设任何关于形式方法的背景知识。形式化可以看作是一种计算机编程：我们将用
    Lean 可以理解的有组织语言（类似于编程语言）来编写数学定义、定理和证明。作为回报，Lean 提供反馈和信息，解释表达式并保证它们是良好形成的，并最终证明我们证明的正确性。
- en: You can learn more about Lean from the [Lean project page](https://leanprover.github.io)
    and the [Lean community web pages](https://leanprover-community.github.io/). This
    tutorial is based on Lean’s large and ever-growing library, *Mathlib*. We also
    strongly recommend joining the [Lean Zulip online chat group](https://leanprover.zulipchat.com/)
    if you haven’t already. You’ll find a lively and welcoming community of Lean enthusiasts
    there, happy to answer questions and offer moral support.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[Lean 项目页面](https://leanprover.github.io)和[Lean 社区网页](https://leanprover-community.github.io/)了解更多关于
    Lean 的信息。本教程基于 Lean 的庞大且不断增长的库 *Mathlib*。我们还强烈建议如果你还没有的话，加入[Lean Zulip 在线聊天组](https://leanprover.zulipchat.com/)。在那里，你会发现一个充满活力和欢迎的
    Lean 爱好者社区，乐于回答问题和提供道德支持。
- en: 'Although you can read a pdf or html version of this book online, it is designed
    to be read interactively, running Lean from inside the VS Code editor. To get
    started:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在网上阅读本书的 pdf 或 html 版本，但它旨在以交互式方式阅读，在 VS Code 编辑器中运行 Lean。要开始：
- en: Install Lean 4 and VS Code following these [installation instructions](https://leanprover-community.github.io/get_started.html).
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照这些[安装说明](https://leanprover-community.github.io/get_started.html)安装 Lean 4
    和 VS Code。
- en: Make sure you have [git](https://git-scm.com/) installed.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你已经安装了 [git](https://git-scm.com/)。
- en: Follow these [instructions](https://leanprover-community.github.io/install/project.html#working-on-an-existing-project)
    to fetch the `mathematics_in_lean` repository and open it up in VS Code.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照这些[说明](https://leanprover-community.github.io/install/project.html#working-on-an-existing-project)获取
    `mathematics_in_lean` 仓库并在 VS Code 中打开它。
- en: Each section in this book has an associated Lean file with examples and exercises.
    You can find them in the folder `MIL`, organized by chapter. We strongly recommend
    making a copy of that folder and experimenting and doing the exercises in that
    copy. This leaves the originals intact, and it also makes it easier to update
    the repository as it changes (see below). You can call the copy `my_files` or
    whatever you want and use it to create your own Lean files as well.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本书中的每一节都有一个相关的 Lean 文件，包含示例和练习。你可以在 `MIL` 文件夹中找到它们，按章节组织。我们强烈建议复制该文件夹，并在该副本中进行实验和练习。这样，原始文件保持不变，也使得在它发生变化时更新仓库更容易（见下文）。你可以将副本命名为
    `my_files` 或你想要的任何名称，并使用它来创建你自己的 Lean 文件。
- en: 'At that point, you can open the textbook in a side panel in VS Code as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可以按照以下方式在 VS Code 的侧面板中打开教科书：
- en: Type `ctrl-shift-P` (`command-shift-P` in macOS).
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `ctrl-shift-P`（在 macOS 上为 `command-shift-P`）。
- en: 'Type `Lean 4: Docs: Show Documentation Resources` in the bar that appears,
    and then press return. (You can press return to select it as soon as it is highlighted
    in the menu.)'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在出现的栏中输入 `Lean 4: Docs: Show Documentation Resources`，然后按回车键。（你可以按回车键选择它，一旦它在菜单中高亮显示。）'
- en: In the window that opens, click on `Mathematics in Lean`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的窗口中，点击 `Mathematics in Lean`。
- en: Alternatively, you can run Lean and VS Code in the cloud, using [Gitpod](https://gitpod.io/).
    You can find instructions as to how to do that on the Mathematics in Lean [project
    page](https://github.com/leanprover-community/mathematics_in_lean) on Github.
    We still recommend working in a copy of the MIL folder, as described above.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在云中运行Lean和VS Code，使用[Gitpod](https://gitpod.io/)。您可以在GitHub上的Mathematics
    in Lean [项目页面](https://github.com/leanprover-community/mathematics_in_lean)上找到如何做到这一点的说明。我们仍然建议按照上述方法在MIL文件夹的副本中工作。
- en: This textbook and the associated repository are still a work in progress. You
    can update the repository by typing `git pull` followed by `lake exe cache get`
    inside the `mathematics_in_lean` folder. (This assumes that you have not changed
    the contents of the `MIL` folder, which is why we suggested making a copy.)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这本教科书和相关的仓库仍在不断完善中。您可以通过在`mathematics_in_lean`文件夹内输入`git pull`命令后跟`lake exe
    cache get`来更新仓库。（这假设您没有更改`MIL`文件夹的内容，这就是我们建议制作副本的原因。）
- en: 'We intend for you to work on the exercises in the `MIL` folder while reading
    the textbook, which contains explanations, instructions, and hints. The text will
    often include examples, like this one:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您在阅读包含解释、说明和提示的教科书的同时，在`MIL`文件夹中完成练习。文本通常会包含示例，例如这个：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You should be able to find the corresponding example in the associated Lean
    file. If you click on the line, VS Code will show you Lean’s feedback in the `Lean
    Goal` window, and if you hover your cursor over the `#eval` command VS Code will
    show you Lean’s response to this command in a pop-up window. You are encouraged
    to edit the file and try examples of your own.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够在相关的Lean文件中找到相应的示例。如果您点击该行，VS Code将在`Lean Goal`窗口中显示Lean的反馈，如果您将鼠标悬停在`#eval`命令上，VS
    Code将在弹出窗口中显示Lean对此命令的响应。您被鼓励编辑文件并尝试自己的示例。
- en: This book moreover provides lots of challenging exercises for you to try. Don’t
    rush past these! Lean is about *doing* mathematics interactively, not just reading
    about it. Working through the exercises is central to the experience. You don’t
    have to do all of them; when you feel comfortable that you have mastered the relevant
    skills, feel free to move on. You can always compare your solutions to the ones
    in the `solutions` folder associated with each section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本书还提供了许多具有挑战性的练习供您尝试。不要匆匆而过！Lean是关于*交互式*做数学的，而不仅仅是阅读它。完成练习是体验的核心。您不必全部完成；当您觉得您已经掌握了相关技能时，您可以自由地继续前进。您总是可以比较您在每个部分的关联`solutions`文件夹中的解决方案。
- en: 1.2\. Overview[](#overview "Link to this heading")
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2. 概述[](#overview "链接到这个标题")
- en: Put simply, Lean is a tool for building complex expressions in a formal language
    known as *dependent type theory*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，Lean是一个在称为*依赖类型理论*的正式语言中构建复杂表达式的工具。
- en: 'Every expression has a *type*, and you can use the #check command to print
    it. Some expressions have types like ℕ or ℕ → ℕ. These are mathematical objects.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每个表达式都有一个*类型*，您可以使用#check命令来打印它。一些表达式具有类型如ℕ或ℕ → ℕ。这些是数学对象。
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Some expressions have type Prop. These are mathematical statements.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一些表达式具有类型Prop。这些都是数学陈述。
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Some expressions have a type, P, where P itself has type Prop. Such an expression
    is a proof of the proposition P.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一些表达式具有类型P，其中P本身具有类型Prop。这样的表达式是命题P的证明。
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you manage to construct an expression of type `FermatLastTheorem` and Lean
    accepts it as a term of that type, you have done something very impressive. (Using
    `sorry` is cheating, and Lean knows it.) So now you know the game. All that is
    left to learn are the rules.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您设法构造了一个类型为`FermatLastTheorem`的表达式，并且Lean接受它作为该类型的项，那么您已经做了非常了不起的事情。（使用`sorry`是作弊，Lean也知道。）所以现在您知道了游戏规则。剩下要学习的就是规则了。
- en: This book is complementary to a companion tutorial, [Theorem Proving in Lean](https://leanprover.github.io/theorem_proving_in_lean4/),
    which provides a more thorough introduction to the underlying logical framework
    and core syntax of Lean. *Theorem Proving in Lean* is for people who prefer to
    read a user manual cover to cover before using a new dishwasher. If you are the
    kind of person who prefers to hit the *start* button and figure out how to activate
    the potscrubber feature later, it makes more sense to start here and refer back
    to *Theorem Proving in Lean* as necessary.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是配套教程 [Lean 中的定理证明](https://leanprover.github.io/theorem_proving_in_lean4/)
    的补充，后者提供了对 Lean 的底层逻辑框架和核心语法的更全面介绍。*Lean 中的定理证明* 是为那些喜欢在使用新洗碗机之前从头到尾阅读用户手册的人准备的。如果你是那种喜欢按下
    *开始* 按钮，稍后再找出如何激活去污功能的人，那么从这里开始，并在需要时参考 *Lean 中的定理证明* 会更有意义。
- en: 'Another thing that distinguishes *Mathematics in Lean* from *Theorem Proving
    in Lean* is that here we place a much greater emphasis on the use of *tactics*.
    Given that we are trying to build complex expressions, Lean offers two ways of
    going about it: we can write down the expressions themselves (that is, suitable
    text descriptions thereof), or we can provide Lean with *instructions* as to how
    to construct them. For example, the following expression represents a proof of
    the fact that if `n` is even then so is `m * n`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个将 *Lean 中的数学* 与 *Lean 中的定理证明* 区分开来的因素是，在这里我们更加重视 *策略* 的使用。鉴于我们试图构建复杂的表达式，Lean
    提供了两种方法：我们可以写下表达式本身（即其合适的文本描述），或者我们可以向 Lean 提供如何构建它们的 *指令*。例如，以下表达式代表了一个证明，即如果
    `n` 是偶数，那么 `m * n` 也是偶数：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The *proof term* can be compressed to a single line:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*证明项* 可以压缩为单行：'
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following is, instead, a *tactic-style* proof of the same theorem, where
    lines starting with `--` are comments, hence ignored by Lean:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对同一定理的 *策略风格* 证明，其中以 `--` 开头的行是注释，因此被 Lean 忽略：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you enter each line of such a proof in VS Code, Lean displays the *proof
    state* in a separate window, telling you what facts you have already established
    and what tasks remain to prove your theorem. You can replay the proof by stepping
    through the lines, since Lean will continue to show you the state of the proof
    at the point where the cursor is. In this example, you will then see that the
    first line of the proof introduces `m` and `n` (we could have renamed them at
    that point, if we wanted to), and also decomposes the hypothesis `Even n` to a
    `k` and the assumption that `n = 2 * k`. The second line, `use m * k`, declares
    that we are going to show that `m * n` is even by showing `m * n = 2 * (m * k)`.
    The next line uses the `rw` tactic to replace `n` by `2 * k` in the goal (`rw`
    stands for “rewrite”), and the `ring` tactic solves the resulting goal `m * (2
    * k) = 2 * (m * k)`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 VS Code 中输入这样一条证明的每一行时，Lean 会在一个单独的窗口中显示 *证明状态*，告诉你你已经建立了哪些事实，以及还需要证明定理的任务。你可以通过逐行执行来重放证明，因为
    Lean 会继续显示光标所在点的证明状态。在这个例子中，你会发现证明的第一行引入了 `m` 和 `n`（如果我们想的话，我们可以在那时将它们重命名），并且将假设
    `Even n` 分解为 `k` 和 `n = 2 * k`。第二行 `use m * k` 声明我们将通过展示 `m * n = 2 * (m * k)`
    来证明 `m * n` 是偶数。下一行使用 `rw` 策略将目标中的 `n` 替换为 `2 * k`（`rw` 代表“重写”），而 `ring` 策略解决了由此产生的目标
    `m * (2 * k) = 2 * (m * k)`。
- en: 'The ability to build a proof in small steps with incremental feedback is extremely
    powerful. For that reason, tactic proofs are often easier and quicker to write
    than proof terms. There isn’t a sharp distinction between the two: tactic proofs
    can be inserted in proof terms, as we did with the phrase `by rw [hk, mul_add]`
    in the example above. We will also see that, conversely, it is often useful to
    insert a short proof term in the middle of a tactic proof. That said, in this
    book, our emphasis will be on the use of tactics.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用小步骤构建证明并得到增量反馈的能力非常强大。因此，策略证明通常比证明项更容易、更快地编写。两者之间没有明显的区别：策略证明可以插入到证明项中，就像我们在上面的例子中用短语
    `by rw [hk, mul_add]` 所做的那样。我们还将看到，相反地，在策略证明的中间插入一个简短的证明项通常是有用的。尽管如此，在这本书中，我们将重点介绍策略的使用。
- en: 'In our example, the tactic proof can also be reduced to a one-liner:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，策略证明也可以简化为单行：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here we have used tactics to carry out small proof steps. But they can also
    provide substantial automation, and justify longer calculations and bigger inferential
    steps. For example, we can invoke Lean’s simplifier with specific rules for simplifying
    statements about parity to prove our theorem automatically.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了策略来执行小的证明步骤。但它们也可以提供实质性的自动化，并证明更长的计算和更大的推理步骤。例如，我们可以使用Lean的简化器，并应用特定的规则来简化关于偶数的陈述，从而自动证明我们的定理。
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Another big difference between the two introductions is that *Theorem Proving
    in Lean* depends only on core Lean and its built-in tactics, whereas *Mathematics
    in Lean* is built on top of Lean’s powerful and ever-growing library, *Mathlib*.
    As a result, we can show you how to use some of the mathematical objects and theorems
    in the library, and some of the very useful tactics. This book is not meant to
    be used as an complete overview of the library; the [community](https://leanprover-community.github.io/)
    web pages contain extensive documentation. Rather, our goal is to introduce you
    to the style of thinking that underlies that formalization, and point out basic
    entry points so that you are comfortable browsing the library and finding things
    on your own.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 两个介绍之间的另一个重大区别是，*Lean中的定理证明*仅依赖于核心Lean及其内置策略，而*Lean中的数学*建立在Lean强大且不断增长的库*Mathlib*之上。因此，我们可以向您展示如何使用库中的某些数学对象和定理，以及一些非常有用的策略。这本书的目的不是用作库的完整概述；[社区](https://leanprover-community.github.io/)网页包含广泛的文档。我们的目标是通过介绍支撑形式化的思维方式，指出基本的入门点，让您能够舒适地浏览库并自行查找内容。
- en: Interactive theorem proving can be frustrating, and the learning curve is steep.
    But the Lean community is very welcoming to newcomers, and people are available
    on the [Lean Zulip chat group](https://leanprover.zulipchat.com/) round the clock
    to answer questions. We hope to see you there, and have no doubt that soon enough
    you, too, will be able to answer such questions and contribute to the development
    of *Mathlib*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式定理证明可能会让人感到沮丧，学习曲线很陡峭。但Lean社区对新来者非常欢迎，人们全天候在[Lean Zulip聊天组](https://leanprover.zulipchat.com/)上提供帮助。我们希望在那里见到你，并且毫无疑问，不久你也将能够回答这样的问题，并为*Mathlib*的发展做出贡献。
- en: 'So here is your mission, should you choose to accept it: dive in, try the exercises,
    come to Zulip with questions, and have fun. But be forewarned: interactive theorem
    proving will challenge you to think about mathematics and mathematical reasoning
    in fundamentally new ways. Your life may never be the same.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你选择接受，这就是你的任务：深入其中，尝试练习，带着问题来Zulip，享受乐趣。但请提前警告：交互式定理证明将挑战你以全新的方式思考数学和数学推理。你的生活可能永远都不会一样。
- en: '*Acknowledgments.* We are grateful to Gabriel Ebner for setting up the infrastructure
    for running this tutorial in VS Code, and to Kim Morrison and Mario Carneiro for
    help porting it from Lean 4. We are also grateful for help and corrections from
    Takeshi Abe, Julian Berman, Alex Best, Thomas Browning, Bulwi Cha, Hanson Char,
    Bryan Gin-ge Chen, Steven Clontz, Mauricio Collaris, Johan Commelin, Mark Czubin,
    Alexandru Duca, Pierpaolo Frasa, Denis Gorbachev, Winston de Greef, Mathieu Guay-Paquet,
    Marc Huisinga, Benjamin Jones, Julian Külshammer, Victor Liu, Jimmy Lu, Martin
    C. Martin, Giovanni Mascellani, John McDowell, Joseph McKinsey, Bhavik Mehta,
    Isaiah Mindich, Kabelo Moiloa, Hunter Monroe, Pietro Monticone, Oliver Nash, Emanuelle
    Natale, Filippo A. E. Nuccio, Pim Otte, Bartosz Piotrowski, Nicolas Rolland, Keith
    Rush, Yannick Seurin, Guilherme Silva, Bernardo Subercaseaux, Pedro Sánchez Terraf,
    Matthew Toohey, Alistair Tucker, Floris van Doorn, Eric Wieser, and others. Our
    work has been partially supported by the Hoskinson Center for Formal Mathematics.*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*致谢。* 我们感谢Gabriel Ebner为在VS Code中运行此教程的基础设施建设，感谢Kim Morrison和Mario Carneiro帮助将其从Lean
    4迁移过来。我们还感谢Takeshi Abe、Julian Berman、Alex Best、Thomas Browning、Bulwi Cha、Hanson
    Char、Bryan Gin-ge Chen、Steven Clontz、Mauricio Collaris、Johan Commelin、Mark Czubin、Alexandru
    Duca、Pierpaolo Frasa、Denis Gorbachev、Winston de Greef、Mathieu Guay-Paquet、Marc
    Huisinga、Benjamin Jones、Julian Külshammer、Victor Liu、Jimmy Lu、Martin C. Martin、Giovanni
    Mascellani、John McDowell、Joseph McKinsey、Bhavik Mehta、Isaiah Mindich、Kabelo Moiloa、Hunter
    Monroe、Pietro Monticone、Oliver Nash、Emanuelle Natale、Filippo A. E. Nuccio、Pim
    Otte、Bartosz Piotrowski、Nicolas Rolland、Keith Rush、Yannick Seurin、Guilherme Silva、Bernardo
    Subercaseaux、Pedro Sánchez Terraf、Matthew Toohey、Alistair Tucker、Floris van Doorn、Eric
    Wieser以及其他人提供的帮助和纠正。我们的工作部分得到了Hoskinson形式数学中心的支持。'
