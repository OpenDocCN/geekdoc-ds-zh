- en: Chapter 3 Cleaning and wrangling data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 数据清洗和整理
- en: 原文：[https://datasciencebook.ca/wrangling.html](https://datasciencebook.ca/wrangling.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://datasciencebook.ca/wrangling.html](https://datasciencebook.ca/wrangling.html)
- en: 3.1 Overview
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 概述
- en: This chapter is centered around defining tidy data—a data format that is suitable
    for analysis—and the tools needed to transform raw data into this format. This
    will be presented in the context of a real-world data science application, providing
    more practice working through a whole case study.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要围绕定义整洁数据——一种适合分析的数据格式——以及将原始数据转换为这种格式的工具展开。这将在现实世界的数据科学应用背景下进行展示，提供更多通过整个案例研究进行实践的机会。
- en: 3.2 Chapter learning objectives
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 章节学习目标
- en: 'By the end of the chapter, readers will be able to do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，读者将能够做到以下几点：
- en: Define the term “tidy data”.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义“整洁数据”这一术语。
- en: Discuss the advantages of storing data in a tidy data format.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论以整洁数据格式存储数据的优点。
- en: Define what vectors, lists, and data frames are in R, and describe how they
    relate to each other.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义R中的向量、列表和数据框，并描述它们之间的关系。
- en: Describe the common types of data in R and their uses.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述R中常见的数据类型及其用途。
- en: 'Use the following functions for their intended data wrangling tasks:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下函数执行它们预期的数据整理任务：
- en: '`c`'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c`'
- en: '`pivot_longer`'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pivot_longer`'
- en: '`pivot_wider`'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pivot_wider`'
- en: '`separate`'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`separate`'
- en: '`select`'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`select`'
- en: '`filter`'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`'
- en: '`mutate`'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mutate`'
- en: '`summarize`'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`summarize`'
- en: '`map`'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`'
- en: '`group_by`'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group_by`'
- en: '`across`'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`across`'
- en: '`rowwise`'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rowwise`'
- en: 'Use the following operators for their intended data wrangling tasks:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下运算符执行它们预期的数据整理任务：
- en: '`==`, `!=`, `<`, `<=`, `>`, and `>=`'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`==`, `!=`, `<`, `<=`, `>`, 和 `>=`'
- en: '`%in%`'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%in%`'
- en: '`!`, `&`, and `|`'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!`, `&`, 和 `|`'
- en: '`|>` and `%>%`'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`|>` 和 `%>%`'
- en: 3.3 Data frames, vectors, and lists
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 数据框、向量和列表
- en: 'In Chapters [1](intro.html#intro) and [2](reading.html#reading), *data frames*
    were the focus: we learned how to import data into R as a data frame, and perform
    basic operations on data frames in R. In the remainder of this book, this pattern
    continues. The vast majority of tools we use will require that data are represented
    as a data frame in R. Therefore, in this section, we will dig more deeply into
    what data frames are and how they are represented in R. This knowledge will be
    helpful in effectively utilizing these objects in our data analyses.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在第[1](intro.html#intro)章和第[2](reading.html#reading)章中，*数据框*是重点：我们学习了如何将数据导入R作为数据框，并在R中对数据框执行基本操作。本书的其余部分，这种模式将继续。我们将使用的大多数工具都将要求数据以R中的数据框形式表示。因此，在本节中，我们将更深入地探讨数据框是什么以及它们在R中的表示方式。这些知识将有助于我们在数据分析中有效地利用这些对象。
- en: 3.3.1 What is a data frame?
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 什么是数据框？
- en: 'A data frame is a table-like structure for storing data in R. Data frames are
    important to learn about because most data that you will encounter in practice
    can be naturally stored as a table. In order to define data frames precisely,
    we need to introduce a few technical terms:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框是R中用于存储数据的表格结构。了解数据框非常重要，因为在实践中遇到的大多数数据都可以自然地以表格形式存储。为了精确地定义数据框，我们需要引入一些技术术语：
- en: '**variable:** a characteristic, number, or quantity that can be measured.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量**：可以测量的特征、数字或数量。'
- en: '**observation:** all of the measurements for a given entity.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观测值**：给定实体的所有测量值。'
- en: '**value:** a single measurement of a single variable for a given entity.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值**：给定实体单个变量的单一测量。'
- en: Given these definitions, a **data frame** is a tabular data structure in R that
    is designed to store observations, variables, and their values. Most commonly,
    each column in a data frame corresponds to a variable, and each row corresponds
    to an observation. For example, Figure [3.1](wrangling.html#fig:02-obs) displays
    a data set of city populations. Here, the variables are “region, year, population”;
    each of these are properties that can be collected or measured. The first observation
    is “Toronto, 2016, 2235145”; these are the values that the three variables take
    for the first entity in the data set. There are 13 entities in the data set in
    total, corresponding to the 13 rows in Figure [3.1](wrangling.html#fig:02-obs).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些定义，**数据框**是R中一种用于存储观测值、变量及其值的表格数据结构。在大多数情况下，数据框中的每一列对应一个变量，每一行对应一个观测值。例如，图[3.1](wrangling.html#fig:02-obs)显示了一个城市人口数据集。在这里，变量是“地区、年份、人口”；这些都是可以收集或测量的属性。第一个观测值是“多伦多，2016，2235145”；这些是数据集中第一个实体三个变量所取的值。数据集中总共有13个实体，对应图[3.1](wrangling.html#fig:02-obs)中的13行。
- en: '![A data frame storing data regarding the population of various regions in
    Canada. In this example data frame, the row that corresponds to the observation
    for the city of Vancouver is colored yellow, and the column that corresponds to
    the population variable is colored blue.](../Images/7914c2a3a640b721becbc1e943b5e330.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![存储有关加拿大各地区人口数据的数据框。在这个示例数据框中，对应于温哥华市观测的行被涂成黄色，对应于人口变量的列被涂成蓝色。](../Images/7914c2a3a640b721becbc1e943b5e330.png)'
- en: 'Figure 3.1: A data frame storing data regarding the population of various regions
    in Canada. In this example data frame, the row that corresponds to the observation
    for the city of Vancouver is colored yellow, and the column that corresponds to
    the population variable is colored blue.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：存储有关加拿大各地区人口数据的数据框。在这个示例数据框中，对应于温哥华市观测的行被涂成黄色，对应于人口变量的列被涂成蓝色。
- en: R stores the columns of a data frame as either *lists* or *vectors*. For example,
    the data frame in Figure [3.2](wrangling.html#fig:02-vectors) has three vectors
    whose names are `region`, `year` and `population`. The next two sections will
    explain what lists and vectors are.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: R 将数据框的列存储为 *列表* 或 *向量*。例如，图 [3.2](wrangling.html#fig:02-vectors) 中的数据框有三个向量，其名称分别为
    `region`、`year` 和 `population`。接下来的两节将解释列表和向量是什么。
- en: '![Data frame with three vectors.](../Images/1ed3cf69966a6f09aeca18ee8ffb70a8.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![包含三个向量的数据框](../Images/1ed3cf69966a6f09aeca18ee8ffb70a8.png)'
- en: 'Figure 3.2: Data frame with three vectors.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：包含三个向量的数据框。
- en: 3.3.2 What is a vector?
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 什么是向量？
- en: 'In R, **vectors** are objects that can contain one or more elements. The vector
    elements are ordered, and they must all be of the same **data type**; R has several
    different basic data types, as shown in Table [3.1](wrangling.html#tab:datatype-table).
    Figure [3.3](wrangling.html#fig:02-vector) provides an example of a vector where
    all of the elements are of character type. You can create vectors in R using the
    `c` function (`c` stands for “concatenate”). For example, to create the vector
    `region` as shown in Figure [3.3](wrangling.html#fig:02-vector), you would write:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，**向量**是包含一个或多个元素的对象。向量元素是有序的，并且它们必须都是相同的 **数据类型**；R 有几种不同的基本数据类型，如表 [3.1](wrangling.html#tab:datatype-table)
    所示。图 [3.3](wrangling.html#fig:02-vector) 提供了一个所有元素都是字符类型的向量的示例。您可以使用 `c` 函数在 R
    中创建向量（`c` 代表“连接”）。例如，要创建图 [3.3](wrangling.html#fig:02-vector) 中所示的 `region` 向量，您将编写：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Note:** Technically, these objects are called “atomic vectors.” In this book
    we have chosen to call them “vectors,” which is how they are most commonly referred
    to in the R community. To be totally precise, “vector” is an umbrella term that
    encompasses both atomic vector and list objects in R. But this creates a confusing
    situation where the term “vector” could mean “atomic vector” *or* “the umbrella
    term for atomic vector and list,” depending on context. Very confusing indeed!
    So to keep things simple, in this book we *always* use the term “vector” to refer
    to “atomic vector.” We encourage readers who are enthusiastic to learn more to
    read the Vectors chapter of *Advanced R* ([Wickham 2019](#ref-wickham2019advanced)).'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：** 从技术上讲，这些对象被称为“原子向量”。在这本书中，我们选择称它们为“向量”，这是 R 社区中最常见的称呼。为了完全准确，"向量"是一个总称，包括
    R 中的原子向量和列表对象。但这会创造一个令人困惑的情况，即“向量”一词可能意味着“原子向量”或“原子向量和列表的总称”，这取决于上下文。确实非常令人困惑！因此，为了使事情简单，在这本书中，我们
    *始终* 使用“向量”一词来指代“原子向量”。我们鼓励那些热衷于学习更多知识的读者阅读 *Advanced R* 中的向量章节 ([Wickham 2019](#ref-wickham2019advanced))。'
- en: '![Example of a vector whose type is character.](../Images/6c81dd9dfaf2526dc78fbcb0e12ea920.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![字符类型向量的示例](../Images/6c81dd9dfaf2526dc78fbcb0e12ea920.png)'
- en: 'Figure 3.3: Example of a vector whose type is character.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：字符类型向量的示例。
- en: 'Table 3.1: Basic data types in R'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1：R 中的基本数据类型
- en: '| Data type | Abbreviation | Description | Example |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 缩写 | 描述 | 示例 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| character | chr | letters or numbers surrounded by quotes | “1” , “Hello
    world!” |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| character | chr | 用引号包围的字母或数字 | “1”， “Hello world!” |'
- en: '| double | dbl | numbers with decimals values | 1.2333 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| double | dbl | 带小数值的数字 | 1.2333 |'
- en: '| integer | int | numbers that do not contain decimals | 1L, 20L (where “L”
    tells R to store as an integer) |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| integer | int | 不包含小数的数字 | 1L, 20L（其中“L”告诉 R 以整数存储）|'
- en: '| logical | lgl | either true or false | `TRUE`, `FALSE` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| logical | lgl | 要么为真要么为假 | `TRUE`，`FALSE` |'
- en: '| factor | fct | used to represent data with a limited number of values (usually
    categories) | a `color` variable with levels `red`, `green` and `orange` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 因子 | fct | 用于表示具有有限值（通常是类别）的数据 | 一个具有级别`red`、`green`和`orange`的`color`变量 |'
- en: It is important in R to make sure you represent your data with the correct type.
    Many of the `tidyverse` functions we use in this book treat the various data types
    differently. You should use integers and double types (which both fall under the
    “numeric” umbrella type) to represent numbers and perform arithmetic. Doubles
    are more common than integers in R, though; for instance, a double data type is
    the default when you create a vector of numbers using `c()`, and when you read
    in whole numbers via `read_csv`. Characters are used to represent data that should
    be thought of as “text”, such as words, names, paths, URLs, and more. Factors
    help us encode variables that represent *categories*; a factor variable takes
    one of a discrete set of values known as *levels* (one for each category). The
    levels can be ordered or unordered. Even though factors can sometimes *look* like
    characters, they are not used to represent text, words, names, and paths in the
    way that characters are; in fact, R internally stores factors using integers!
    There are other basic data types in R, such as *raw* and *complex*, but we do
    not use these in this textbook.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，确保你用正确的类型表示数据非常重要。我们在这本书中使用的许多`tidyverse`函数对不同的数据类型有不同的处理方式。你应该使用整数和双精度浮点数类型（两者都属于“数值”类型）来表示数字并进行算术运算。尽管在R中双精度浮点数比整数更常见；例如，当你使用`c()`创建数字向量时，或者通过`read_csv`读取整数时，默认数据类型是双精度浮点数。字符用于表示应被视为“文本”的数据，例如单词、名称、路径、URL等。因子帮助我们编码表示*类别*的变量；因子变量取一个离散集合中的值，称为*级别*（每个类别一个）。级别可以是有序的或无序的。尽管因子有时*看起来*像字符，但它们不是像字符那样用于表示文本、单词、名称和路径；实际上，R内部使用整数存储因子！R中还有其他基本数据类型，如*原始*和*复数*，但我们在本教材中不使用这些类型。
- en: 3.3.3 What is a list?
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.3 列表是什么？
- en: Lists are also objects in R that have multiple, ordered elements. Vectors and
    lists differ by the requirement of element type consistency. All elements within
    a single vector must be of the same type (e.g., all elements are characters),
    whereas elements within a single list can be of different types (e.g., characters,
    integers, logicals, and even other lists). See Figure [3.4](wrangling.html#fig:02-vec-vs-list).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表也是R中的对象，它具有多个有序元素。向量与列表的区别在于元素类型一致性的要求。单个向量中的所有元素必须是同一类型（例如，所有元素都是字符），而单个列表中的元素可以是不同类型（例如，字符、整数、逻辑值，甚至是其他列表）。见图[3.4](wrangling.html#fig:02-vec-vs-list)。
- en: '![A vector versus a list.](../Images/715a70602eef40951a81695d4410b85b.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![向量与列表的比较](../Images/715a70602eef40951a81695d4410b85b.png)'
- en: 'Figure 3.4: A vector versus a list.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：向量与列表的比较。
- en: 3.3.4 What does this have to do with data frames?
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.4 这与数据框有什么关系？
- en: 'A data frame is really a special kind of list that follows two rules:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框实际上是一种特殊的列表，它遵循两个规则：
- en: Each element itself must either be a vector or a list.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个元素本身必须是向量或列表。
- en: Each element (vector or list) must have the same length.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个元素（向量或列表）必须具有相同的长度。
- en: 'Not all columns in a data frame need to be of the same type. Figure [3.5](wrangling.html#fig:02-dataframe)
    shows a data frame where the columns are vectors of different types. But remember:
    because the columns in this example are *vectors*, the elements must be the same
    data type *within each column.* On the other hand, if our data frame had *list*
    columns, there would be no such requirement. It is generally much more common
    to use *vector* columns, though, as the values for a single variable are usually
    all of the same type.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框中的所有列不一定需要是同一类型。图[3.5](wrangling.html#fig:02-dataframe)显示了一个列是不同类型向量的数据框。但请记住：因为在这个例子中列是*向量*，所以每个列中的元素必须是相同的数据类型。另一方面，如果我们的数据框有*列表*列，则不会有这样的要求。然而，通常更常见的是使用*向量*列，因为单个变量的值通常都是同一类型。
- en: '![Data frame and vector types.](../Images/bc95f68f07bc4d8be61a9bd3615be9a1.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![数据框和向量类型](../Images/bc95f68f07bc4d8be61a9bd3615be9a1.png)'
- en: 'Figure 3.5: Data frame and vector types.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：数据框和向量类型。
- en: Data frames are actually included in R itself, without the need for any additional
    packages. However, the `tidyverse` functions that we use throughout this book
    all work with a special kind of data frame called a *tibble*. Tibbles have some
    additional features and benefits over built-in data frames in R. These include
    the ability to add useful attributes (such as grouping, which we will discuss
    later) and more predictable type preservation when subsetting. Because a tibble
    is just a data frame with some added features, we will collectively refer to both
    built-in R data frames and tibbles as *data frames* in this book.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框实际上包含在R本身中，无需任何额外的包。然而，本书中使用的`tidyverse`函数都是与一种特殊的数据框类型一起工作的，这种类型称为*tibble*。Tibbles相对于R内置的数据框有一些额外的功能和优势。这包括添加有用的属性（例如分组，我们将在后面讨论）以及在子集时更可预测的类型保留。因为tibble只是一个添加了一些功能的数据框，所以我们将在本书中将内置的R数据框和tibbles统称为*数据框*。
- en: '**Note:** You can use the function `class` on a data object to assess whether
    a data frame is a built-in R data frame or a tibble. If the data object is a data
    frame, `class` will return `"data.frame"`. If the data object is a tibble it will
    return `"tbl_df" "tbl" "data.frame"`. You can easily convert built-in R data frames
    to tibbles using the `tidyverse` `as_tibble` function. For example we can check
    the class of the Canadian languages data set, `can_lang`, we worked with in the
    previous chapters and we see it is a tibble.'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意**：您可以使用`class`函数对一个数据对象进行评估，以确定它是一个内置的R数据框还是一个tibble。如果数据对象是数据框，`class`将返回`"data.frame"`。如果数据对象是tibble，它将返回`"tbl_df"
    "tbl" "data.frame"`。您可以使用`tidyverse`的`as_tibble`函数轻松地将内置的R数据框转换为tibbles。例如，我们可以检查我们在前几章中使用的加拿大语言数据集`can_lang`的类，我们看到它是一个tibble。'
- en: ''
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ''
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Vectors, data frames and lists are basic types of *data structure* in R, which
    are core to most data analyses. We summarize them in Table [3.2](wrangling.html#tab:datastructure-table).
    There are several other data structures in the R programming language (*e.g.,*
    matrices), but these are beyond the scope of this book.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 向量、数据框和列表是R中的基本数据结构类型，它们是大多数数据分析的核心。我们在表[3.2](wrangling.html#tab:datastructure-table)中总结了它们。R编程语言中还有其他几种数据结构（例如，矩阵），但这些超出了本书的范围。
- en: 'Table 3.2: Basic data structures in R'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2：R中的基本数据结构
- en: '| Data Structure | Description |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 数据结构 | 描述 |'
- en: '| --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| vector | An ordered collection of one, or more, values of the *same data
    type*. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 向量 | 一个有序的值集合，这些值可以是单个值或多个值，且数据类型相同。|'
- en: '| list | An ordered collection of one, or more, values of *possibly different
    data types*. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 列表 | 一个有序的值集合，这些值可以是单个值或多个值，且数据类型可能不同。|'
- en: '| data frame | A list of either vectors or lists of the *same length*, with
    column names. We typically use a data frame to represent a data set. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 数据框 | 一组具有相同长度的向量或列表，带有列名。我们通常使用数据框来表示数据集。|'
- en: 3.4 Tidy data
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 整洁数据
- en: 'There are many ways a tabular data set can be organized. This chapter will
    focus on introducing the **tidy data** format of organization and how to make
    your raw (and likely messy) data tidy. A tidy data frame satisfies the following
    three criteria ([Wickham 2014](#ref-wickham2014tidy)):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 表格数据集的组织方式有很多种。本章将重点介绍**整洁数据**的组织格式以及如何使你的原始（可能杂乱）数据变得整洁。整洁数据框满足以下三个标准([Wickham
    2014](#ref-wickham2014tidy))：
- en: each row is a single observation,
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一行代表一个单独的观察值，
- en: each column is a single variable, and
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一列代表一个单独的变量，并且
- en: each value is a single cell (i.e., its entry in the data frame is not shared
    with another value).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个值都是一个单独的单元格（即，它在数据框中的条目不与其他值共享）。
- en: Figure [3.6](wrangling.html#fig:02-tidy-image) demonstrates a tidy data set
    that satisfies these three criteria.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图[3.6](wrangling.html#fig:02-tidy-image)演示了一个满足这些三个标准的数据集。
- en: '![Tidy data satisfies three criteria.](../Images/7f59d5afd776e4d5f96c20e0db9fc684.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![整洁数据满足三个标准](../Images/7f59d5afd776e4d5f96c20e0db9fc684.png)'
- en: 'Figure 3.6: Tidy data satisfies three criteria.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：整洁数据满足三个标准。
- en: There are many good reasons for making sure your data are tidy as a first step
    in your analysis. The most important is that it is a single, consistent format
    that nearly every function in the `tidyverse` recognizes. No matter what the variables
    and observations in your data represent, as long as the data frame is tidy, you
    can manipulate it, plot it, and analyze it using the same tools. If your data
    is *not* tidy, you will have to write special bespoke code in your analysis that
    will not only be error-prone, but hard for others to understand. Beyond making
    your analysis more accessible to others and less error-prone, tidy data is also
    typically easy for humans to interpret. Given these benefits, it is well worth
    spending the time to get your data into a tidy format upfront. Fortunately, there
    are many well-designed `tidyverse` data cleaning/wrangling tools to help you easily
    tidy your data. Let’s explore them below!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析的第一步确保数据整洁有许多很好的理由。最重要的是，它是一个单一、一致的格式，几乎 `tidyverse` 中的每个函数都认可。无论你的数据中的变量和观测值代表什么，只要数据框是整洁的，你就可以使用相同的工具来操作它、绘制它和分析它。如果你的数据不是整洁的，你将不得不在分析中编写特殊的定制代码，这不仅容易出错，而且难以他人理解。除了使你的分析更容易被他人理解和减少错误之外，整洁数据通常也更容易被人类解释。考虑到这些好处，花时间将数据整理成整洁格式是非常值得的。幸运的是，有许多精心设计的
    `tidyverse` 数据清理/整理工具可以帮助你轻松整理数据。让我们在下面探索它们！
- en: '**Note:** Is there only one shape for tidy data for a given data set? Not necessarily!
    It depends on the statistical question you are asking and what the variables are
    for that question. For tidy data, each variable should be its own column. So,
    just as it’s essential to match your statistical question with the appropriate
    data analysis tool, it’s important to match your statistical question with the
    appropriate variables and ensure they are represented as individual columns to
    make the data tidy.'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：**对于给定的数据集，整洁数据是否只有一种形状？不一定！这取决于你提出的统计问题和该问题的变量。对于整洁数据，每个变量应该有自己的列。因此，就像匹配你的统计问题与适当的数据分析工具是至关重要的，匹配你的统计问题与适当的变量并确保它们以单独的列形式表示，以使数据整洁也同样重要。'
- en: '3.4.1 Tidying up: going from wide to long using `pivot_longer`'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 整理数据：使用 `pivot_longer` 从宽格式转换为长格式
- en: One task that is commonly performed to get data into a tidy format is to combine
    values that are stored in separate columns, but are really part of the same variable,
    into one. Data is often stored this way because this format is sometimes more
    intuitive for human readability and understanding, and humans create data sets.
    In Figure [3.7](wrangling.html#fig:02-wide-to-long), the table on the left is
    in an untidy, “wide” format because the year values (2006, 2011, 2016) are stored
    as column names. And as a consequence, the values for population for the various
    cities over these years are also split across several columns.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将存储在单独列中的值合并成一个值，这是将数据整理成整洁格式时经常执行的任务，因为这些值实际上是同一变量的组成部分。数据通常以这种方式存储，因为这种格式有时对人类阅读和理解来说更直观，并且是人类创建数据集。在图[3.7](wrangling.html#fig:02-wide-to-long)中，左边的表格以不整洁的、“宽”格式呈现，因为年份值（2006、2011、2016）被存储为列名。因此，这些年份中各个城市的总人口值也被分散在几个列中。
- en: For humans, this table is easy to read, which is why you will often find data
    stored in this wide format. However, this format is difficult to work with when
    performing data visualization or statistical analysis using R. For example, if
    we wanted to find the latest year it would be challenging because the year values
    are stored as column names instead of as values in a single column. So before
    we could apply a function to find the latest year (for example, by using `max`),
    we would have to first extract the column names to get them as a vector and then
    apply a function to extract the latest year. The problem only gets worse if you
    would like to find the value for the population for a given region for the latest
    year. Both of these tasks are greatly simplified once the data is tidied.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于人类来说，这个表格很容易阅读，这就是为什么你经常会发现数据以这种宽格式存储。然而，当使用 R 进行数据可视化或统计分析时，这种格式很难处理。例如，如果我们想找到最新的年份，这将是一个挑战，因为年份值被存储为列名，而不是存储在单个列中的值。因此，在我们能够应用一个函数来找到最新的年份（例如，使用
    `max`）之前，我们首先需要提取列名，将它们作为一个向量，然后应用一个函数来提取最新的年份。如果你还想找到给定地区在最新年份的人口值，这个问题会更糟。一旦数据被整理，这两个任务都会大大简化。
- en: Another problem with data in this format is that we don’t know what the numbers
    under each year actually represent. Do those numbers represent population size?
    Land area? It’s not clear. To solve both of these problems, we can reshape this
    data set to a tidy data format by creating a column called “year” and a column
    called “population.” This transformation—which makes the data “longer”—is shown
    as the right table in Figure [3.7](wrangling.html#fig:02-wide-to-long).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式的数据还存在另一个问题，那就是我们不知道每年下面的数字实际上代表什么。这些数字代表人口规模？土地面积？并不清楚。为了解决这两个问题，我们可以通过创建一个名为“year”的列和一个名为“population”的列来将这个数据集重塑为整洁数据格式。这种使数据“更长”的转换在图[3.7](wrangling.html#fig:02-wide-to-long)的右侧表格中显示。
- en: '![Pivoting data from a wide to long data format.](../Images/2c920be10d244297b8f6fc1ae920bd4f.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![从宽格式到长格式的数据转换。](../Images/2c920be10d244297b8f6fc1ae920bd4f.png)'
- en: 'Figure 3.7: Pivoting data from a wide to long data format.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7：从宽格式到长格式的数据转换。
- en: We can achieve this effect in R using the `pivot_longer` function from the `tidyverse`
    package. The `pivot_longer` function combines columns, and is usually used during
    tidying data when we need to make the data frame longer and narrower. To learn
    how to use `pivot_longer`, we will work through an example with the `region_lang_top5_cities_wide.csv`
    data set. This data set contains the counts of how many Canadians cited each language
    as their mother tongue for five major Canadian cities (Toronto, Montréal, Vancouver,
    Calgary, and Edmonton) from the 2016 Canadian census. To get started, we will
    load the `tidyverse` package and use `read_csv` to load the (untidy) data.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用来自 `tidyverse` 包的 `pivot_longer` 函数在 R 中实现这种效果。`pivot_longer` 函数用于合并列，通常在整理数据时使用，当我们需要将数据框变得更长更窄时。要学习如何使用
    `pivot_longer`，我们将通过一个使用 `region_lang_top5_cities_wide.csv` 数据集的例子来操作。这个数据集包含了2016年加拿大人口普查中，五个主要加拿大城市（多伦多、蒙特利尔、温哥华、卡尔加里和埃德蒙顿）的加拿大人将每种语言作为母语的计数。为了开始，我们将加载
    `tidyverse` 包并使用 `read_csv` 读取（未整理）的数据。
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What is wrong with the untidy format above? The table on the left in Figure
    [3.8](wrangling.html#fig:img-pivot-longer-with-table) represents the data in the
    “wide” (messy) format. From a data analysis perspective, this format is not ideal
    because the values of the variable *region* (Toronto, Montréal, Vancouver, Calgary,
    and Edmonton) are stored as column names. Thus they are not easily accessible
    to the data analysis functions we will apply to our data set. Additionally, the
    *mother tongue* variable values are spread across multiple columns, which will
    prevent us from doing any desired visualization or statistical tasks until we
    combine them into one column. For instance, suppose we want to know the languages
    with the highest number of Canadians reporting it as their mother tongue among
    all five regions. This question would be tough to answer with the data in its
    current format. We *could* find the answer with the data in this format, though
    it would be much easier to answer if we tidy our data first. If mother tongue
    were instead stored as one column, as shown in the tidy data on the right in Figure
    [3.8](wrangling.html#fig:img-pivot-longer-with-table), we could simply use the
    `max` function in one line of code to get the maximum value.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上述未整理格式有什么问题？图[3.8](wrangling.html#fig:img-pivot-longer-with-table)左边的表格代表了“宽”（杂乱）格式的数据。从数据分析的角度来看，这种格式并不理想，因为变量
    *region*（多伦多、蒙特利尔、温哥华、卡尔加里和埃德蒙顿）的值被存储为列名。因此，它们不容易被我们应用到数据集上的数据分析函数访问。此外，*母语*变量的值分散在多个列中，这将阻止我们进行任何所需的可视化或统计任务，直到我们将它们合并到一个列中。例如，如果我们想了解在所有五个地区中报告母语数量最多的语言，这个问题在当前的数据格式下将很难回答。虽然我们可以用这种格式找到答案，但如果首先整理我们的数据，回答这个问题会容易得多。如果母语被存储为图[3.8](wrangling.html#fig:img-pivot-longer-with-table)右边的整洁数据中所示的一个列，我们只需一行代码中的
    `max` 函数就可以得到最大值。
- en: '![Going from wide to long with the pivot_longer function.](../Images/1de51df3a7de542bf78307f2bcec6f4a.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![使用 pivot_longer 函数从宽到长转换。](../Images/1de51df3a7de542bf78307f2bcec6f4a.png)'
- en: 'Figure 3.8: Going from wide to long with the `pivot_longer` function.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8：使用 `pivot_longer` 函数从宽格式到长格式转换。
- en: Figure [3.9](wrangling.html#fig:img-pivot-longer) details the arguments that
    we need to specify in the `pivot_longer` function to accomplish this data transformation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图[3.9](wrangling.html#fig:img-pivot-longer)详细说明了在 `pivot_longer` 函数中我们需要指定的参数以完成这种数据转换。
- en: '![Syntax for the pivot_longer function.](../Images/3af1b85c3acffbbfd400ad152edd83c2.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![pivot_longer 函数的语法。](../Images/3af1b85c3acffbbfd400ad152edd83c2.png)'
- en: 'Figure 3.9: Syntax for the `pivot_longer` function.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9：`pivot_longer`函数的语法。
- en: 'We use `pivot_longer` to combine the Toronto, Montréal, Vancouver, Calgary,
    and Edmonton columns into a single column called `region`, and create a column
    called `mother_tongue` that contains the count of how many Canadians report each
    language as their mother tongue for each metropolitan area. We use a colon `:`
    between Toronto and Edmonton to tell R to select all the columns between Toronto
    and Edmonton:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`pivot_longer`将多伦多、蒙特利尔、温哥华、卡尔加里和埃德蒙顿的列合并成一个名为`region`的单列，并创建一个名为`mother_tongue`的列，该列包含报告每种语言为各自大都市区母语的加拿大人的数量。我们在多伦多和埃德蒙顿之间使用冒号`:`来告诉R选择多伦多和埃德蒙顿之间的所有列：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Note**: In the code above, the call to the `pivot_longer` function is split
    across several lines. This is allowed in certain cases; for example, when calling
    a function as above, as long as the line ends with a comma `,` R knows to keep
    reading on the next line. Splitting long lines like this across multiple lines
    is encouraged as it helps significantly with code readability. Generally speaking,
    you should limit each line of code to about 80 characters.'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意**：在上面的代码中，对`pivot_longer`函数的调用被拆分成了多行。在某些情况下这是允许的；例如，像上面那样调用函数，只要行末以逗号`,`结尾，R就会知道继续读取下一行。将长行拆分到多行中是鼓励的做法，因为它可以显著提高代码的可读性。一般来说，你应该将每行代码限制在大约80个字符以内。'
- en: 'The data above is now tidy because all three criteria for tidy data have now
    been met:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 上述数据现在已经是整洁的，因为所有三个整洁数据的准则现在都已满足：
- en: All the variables (`category`, `language`, `region` and `mother_tongue`) are
    now their own columns in the data frame.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有变量（`category`、`language`、`region`和`mother_tongue`）现在都是数据框中的单独列。
- en: Each observation, (i.e., each language in a region) is in a single row.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个观察值（即，该地区的一种语言）都在单独的一行中。
- en: Each value is a single cell, i.e., its row, column position in the data frame
    is not shared with another value.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个值都是一个单独的单元格，即，它在数据框中的行和列位置不与其他值共享。
- en: '3.4.2 Tidying up: going from long to wide using `pivot_wider`'
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.2 整理：使用 `pivot_wider` 从长格式转换为宽格式
- en: 'Suppose we have observations spread across multiple rows rather than in a single
    row. For example, in Figure [3.10](wrangling.html#fig:long-to-wide), the table
    on the left is in an untidy, long format because the `count` column contains three
    variables (population, commuter count, and year the city was incorporated) and
    information about each observation (here, population, commuter, and incorporated
    values for a region) is split across three rows. Remember: one of the criteria
    for tidy data is that each observation must be in a single row.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的观察值分布在多行而不是单行中。例如，在图[3.10](wrangling.html#fig:long-to-wide)中，左边的表格是不整洁的长格式，因为`count`列包含三个变量（人口、通勤者计数和城市成立年份）以及每个观察值（在这里，地区的人口、通勤者和成立值）的信息分布在三个行中。记住：整洁数据的准则之一是每个观察值必须在单行中。
- en: Using data in this format—where two or more variables are mixed together in
    a single column—makes it harder to apply many usual `tidyverse` functions. For
    example, finding the maximum number of commuters would require an additional step
    of filtering for the commuter values before the maximum can be computed. In comparison,
    if the data were tidy, all we would have to do is compute the maximum value for
    the commuter column. To reshape this untidy data set to a tidy (and in this case,
    wider) format, we need to create columns called “population”, “commuters”, and
    “incorporated.” This is illustrated in the right table of Figure [3.10](wrangling.html#fig:long-to-wide).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种格式的数据——其中两个或多个变量混合在单个列中——使得应用许多常用的`tidyverse`函数变得更加困难。例如，找到通勤者的最大数量需要额外的步骤来过滤通勤者的值，然后才能计算最大值。相比之下，如果数据是整洁的，我们只需要计算通勤列的最大值。要将这个不整洁的数据集重塑为整洁的（在这个例子中，更宽的）格式，我们需要创建名为“population”（人口）、“commuters”（通勤者）和“incorporated”（成立）的列。这如图[3.10](wrangling.html#fig:long-to-wide)的右表所示。
- en: '![Going from long to wide data.](../Images/3e70901cd7bae358979f55da3d94602e.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![从长格式到宽格式的数据转换。](../Images/3e70901cd7bae358979f55da3d94602e.png)'
- en: 'Figure 3.10: Going from long to wide data.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10：从长格式到宽格式的数据转换。
- en: To tidy this type of data in R, we can use the `pivot_wider` function. The `pivot_wider`
    function generally increases the number of columns (widens) and decreases the
    number of rows in a data set. To learn how to use `pivot_wider`, we will work
    through an example with the `region_lang_top5_cities_long.csv` data set. This
    data set contains the number of Canadians reporting the primary language at home
    and work for five major cities (Toronto, Montréal, Vancouver, Calgary, and Edmonton).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要在R中整理此类数据，我们可以使用`pivot_wider`函数。`pivot_wider`函数通常会增加数据集中的列数（加宽）并减少行数。为了了解如何使用`pivot_wider`，我们将通过`region_lang_top5_cities_long.csv`数据集的示例来操作。此数据集包含五个主要城市（多伦多、蒙特利尔、温哥华、卡尔加里和埃德蒙顿）的加拿大人报告的在家和工作时使用的首选语言的数量。
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'What makes the data set shown above untidy? In this example, each observation
    is a language in a region. However, each observation is split across multiple
    rows: one where the count for `most_at_home` is recorded, and the other where
    the count for `most_at_work` is recorded. Suppose the goal with this data was
    to visualize the relationship between the number of Canadians reporting their
    primary language at home and work. Doing that would be difficult with this data
    in its current form, since these two variables are stored in the same column.
    Figure [3.11](wrangling.html#fig:img-pivot-wider-table) shows how this data will
    be tidied using the `pivot_wider` function.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上述数据集为什么是不整洁的？在这个例子中，每个观测值是一个区域的语言。然而，每个观测值被分割在多行中：一行记录了`most_at_home`的计数，另一行记录了`most_at_work`的计数。假设这个数据的目标是可视化报告其在家和工作时使用首选语言的加拿大人数量的关系。以当前数据的形式做这件事将是困难的，因为这两个变量存储在同一列中。图[3.11](wrangling.html#fig:img-pivot-wider-table)展示了如何使用`pivot_wider`函数来整理这些数据。
- en: '![Going from long to wide with the pivot_wider function.](../Images/907b8f81062ae9bc0e3ed92378e21922.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![使用`pivot_wider`函数从长格式转换为宽格式。](../Images/907b8f81062ae9bc0e3ed92378e21922.png)'
- en: 'Figure 3.11: Going from long to wide with the `pivot_wider` function.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11：使用`pivot_wider`函数从长格式转换为宽格式。
- en: Figure [3.12](wrangling.html#fig:img-pivot-wider) details the arguments that
    we need to specify in the `pivot_wider` function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图[3.12](wrangling.html#fig:img-pivot-wider)详细说明了在`pivot_wider`函数中需要指定的参数。
- en: '![Syntax for the pivot_wider function.](../Images/2cb7eaf858863b26f5f45640ff0628cc.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![`pivot_wider`函数的语法。](../Images/2cb7eaf858863b26f5f45640ff0628cc.png)'
- en: 'Figure 3.12: Syntax for the `pivot_wider` function.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12：`pivot_wider`函数的语法。
- en: We will apply the function as detailed in Figure [3.12](wrangling.html#fig:img-pivot-wider).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在图[3.12](wrangling.html#fig:img-pivot-wider)中详细说明如何应用此函数。
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The data above is now tidy! We can go through the three criteria again to check
    that this data is a tidy data set.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的数据现在已经整洁！我们可以再次通过三个标准来检查这些数据是否是整洁数据集。
- en: All the statistical variables are their own columns in the data frame (i.e.,
    `most_at_home`, and `most_at_work` have been separated into their own columns
    in the data frame).
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有统计变量都是数据框中的单独列（即，`most_at_home`和`most_at_work`已经被分离到数据框中的单独列）。
- en: Each observation, (i.e., each language in a region) is in a single row.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个观测值（即，每个区域中的每种语言）都在单独的一行中。
- en: Each value is a single cell (i.e., its row, column position in the data frame
    is not shared with another value).
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个值都是一个单独的单元格（即，它在数据框中的行和列位置不与其他值共享）。
- en: You might notice that we have the same number of columns in the tidy data set
    as we did in the messy one. Therefore `pivot_wider` didn’t really “widen” the
    data, as the name suggests. This is just because the original `type` column only
    had two categories in it. If it had more than two, `pivot_wider` would have created
    more columns, and we would see the data set “widen.”
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，我们在整洁数据集中拥有的列数与杂乱数据集中的一样。因此，`pivot_wider`并没有真正“加宽”数据，正如其名称所暗示的。这仅仅是因为原始的`type`列中只有两个类别。如果它有超过两个，`pivot_wider`将创建更多的列，我们就会看到数据集“加宽”。
- en: '3.4.3 Tidying up: using `separate` to deal with multiple delimiters'
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.3 整理数据：使用`separate`处理多个分隔符
- en: 'Data are also not considered tidy when multiple values are stored in the same
    cell. The data set we show below is even messier than the ones we dealt with above:
    the `Toronto`, `Montréal`, `Vancouver`, `Calgary`, and `Edmonton` columns contain
    the number of Canadians reporting their primary language at home and work in one
    column separated by the delimiter (`/`). The column names are the values of a
    variable, *and* each value does not have its own cell! To turn this messy data
    into tidy data, we’ll have to fix these issues.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个值存储在同一单元格中时，数据也被认为是不整洁的。下面我们展示的数据集甚至比上面我们处理的数据集还要混乱：`Toronto`、`Montréal`、`Vancouver`、`Calgary`
    和 `Edmonton` 列包含报告他们在家和工作中主要语言的加拿大人数，这些数字在一个列中通过分隔符（`/`）分隔。列名是变量的值，*而且*每个值都没有自己的单元格！为了将这种混乱的数据转换为整洁数据，我们得解决这些问题。
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First we’ll use `pivot_longer` to create two columns, `region` and `value`,
    similar to what we did previously. The new `region` columns will contain the region
    names, and the new column `value` will be a temporary holding place for the data
    that we need to further separate, i.e., the number of Canadians reporting their
    primary language at home and work.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用 `pivot_longer` 创建两个列，`region` 和 `value`，类似于我们之前所做的那样。新的 `region` 列将包含区域名称，新的列
    `value` 将是进一步分离所需数据的临时存储位置，即报告在家和工作中主要语言的加拿大人数。
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next we’ll use `separate` to split the `value` column into two columns. One
    column will contain only the counts of Canadians that speak each language most
    at home, and the other will contain the counts of Canadians that speak each language
    most at work for each region. Figure [3.13](wrangling.html#fig:img-separate) outlines
    what we need to specify to use `separate`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `separate` 将 `value` 列拆分为两个列。一个列将只包含说在家中最常使用的语言的加拿大人数，另一个列将包含每个地区说在工作中最常使用的语言的加拿大人数。图
    [3.13](wrangling.html#fig:img-separate) 概述了我们使用 `separate` 需要指定的内容。
- en: '![Syntax for the separate function.](../Images/b69ec800f11787b8902ae6ac5098dcf8.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![`separate` 函数的语法。](../Images/b69ec800f11787b8902ae6ac5098dcf8.png)'
- en: 'Figure 3.13: Syntax for the `separate` function.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13：`separate` 函数的语法。
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Is this data set now tidy? If we recall the three criteria for tidy data:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据集现在整洁了吗？如果我们回想一下整洁数据的三个标准：
- en: each row is a single observation,
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每行是一个单独的观察值，
- en: each column is a single variable, and
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每列是一个单独的变量，并且
- en: each value is a single cell.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个值都是一个单独的单元格。
- en: We can see that this data now satisfies all three criteria, making it easier
    to analyze. But we aren’t done yet! Notice in the table above that the word `<chr>`
    appears beneath each of the column names. The word under the column name indicates
    the data type of each column. Here all of the variables are “character” data types.
    Recall, character data types are letter(s) or digits(s) surrounded by quotes.
    In the previous example in Section [3.4.2](wrangling.html#pivot-wider), the `most_at_home`
    and `most_at_work` variables were `<dbl>` (double)—you can verify this by looking
    at the tables in the previous sections—which is a type of numeric data. This change
    is due to the delimiter (`/`) when we read in this messy data set. R read these
    columns in as character types, and by default, `separate` will return columns
    as character data types.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，现在这个数据满足所有三个标准，这使得分析变得更加容易。但我们还没有完成！注意在上述表格中，每个列名下面都出现了 `<chr>` 这个词。列名下的词表示每个列的数据类型。在这里，所有变量都是“字符”数据类型。回想一下，字符数据类型是被引号包围的字母或数字。在
    3.4.2 节的先前的例子中，`most_at_home` 和 `most_at_work` 变量是 `<dbl>`（双精度浮点数）——你可以通过查看前几节中的表格来验证这一点——这是一种数值数据类型。这种变化是由于我们在读取这个混乱的数据集时使用的分隔符（`/`）。R
    将这些列读取为字符类型，并且默认情况下，`separate` 将返回字符数据类型的列。
- en: 'It makes sense for `region`, `category`, and `language` to be stored as a character
    (or perhaps factor) type. However, suppose we want to apply any functions that
    treat the `most_at_home` and `most_at_work` columns as a number (e.g., finding
    rows above a numeric threshold of a column). In that case, it won’t be possible
    to do if the variable is stored as a `character`. Fortunately, the `separate`
    function provides a natural way to fix problems like this: we can set `convert
    = TRUE` to convert the `most_at_home` and `most_at_work` columns to the correct
    data type.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `region`、`category` 和 `language` 存储为字符（或可能是因子）类型是有意义的。然而，如果我们想应用任何将 `most_at_home`
    和 `most_at_work` 列作为数字处理的函数（例如，查找超过列的数值阈值的行）。在这种情况下，如果变量存储为 `character` 类型，将无法完成。幸运的是，`separate`
    函数提供了一个自然的方式来解决这个问题：我们可以设置 `convert = TRUE` 将 `most_at_home` 和 `most_at_work`
    列转换为正确的数据类型。
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now we see `<int>` appears under the `most_at_home` and `most_at_work` columns,
    indicating they are integer data types (i.e., numbers)!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们看到 `<int>` 出现在 `most_at_home` 和 `most_at_work` 列下面，这表明它们是整数数据类型（即，数字）！
- en: 3.5 Using `select` to extract a range of columns
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 使用 `select` 提取一系列列
- en: 'Now that the `tidy_lang` data is indeed *tidy*, we can start manipulating it
    using the powerful suite of functions from the `tidyverse`. For the first example,
    recall the `select` function from Chapter [1](intro.html#intro), which lets us
    create a subset of columns from a data frame. Suppose we wanted to select only
    the columns `language`, `region`, `most_at_home` and `most_at_work` from the `tidy_lang`
    data set. Using what we learned in Chapter [1](intro.html#intro), we would pass
    the `tidy_lang` data frame as well as all of these column names into the `select`
    function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 既然 `tidy_lang` 数据确实是 *tidy* 的，我们就可以开始使用 `tidyverse` 中的强大函数集来操作它了。对于第一个例子，回忆一下第
    [1](intro.html#intro) 章中的 `select` 函数，它允许我们从数据框中创建列的子集。假设我们只想从 `tidy_lang` 数据集中选择
    `language`、`region`、`most_at_home` 和 `most_at_work` 这些列。使用我们在第 [1](intro.html#intro)
    章中学到的知识，我们将 `tidy_lang` 数据框以及所有这些列名传递给 `select` 函数：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here we wrote out the names of each of the columns. However, this method is
    time-consuming, especially if you have a lot of columns! Another approach is to
    use a “select helper”. Select helpers are operators that make it easier for us
    to select columns. For instance, we can use a select helper to choose a range
    of columns rather than typing each column name out. To do this, we use the colon
    (`:`) operator to denote the range. For example, to get all the columns in the
    `tidy_lang` data frame from `language` to `most_at_work` we pass `language:most_at_work`
    as the second argument to the `select` function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们写出了每一列的名称。然而，这种方法很耗时，尤其是如果你有很多列！另一种方法是使用“选择辅助工具”。选择辅助工具是使我们可以更容易地选择列的运算符。例如，我们可以使用选择辅助工具来选择一系列列，而不是逐个输入每个列名。为此，我们使用冒号（`:`）运算符来表示范围。例如，要获取
    `tidy_lang` 数据框中从 `language` 到 `most_at_work` 的所有列，我们将 `language:most_at_work`
    作为 `select` 函数的第二个参数传递。
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that we get the same output as we did above, but with less (and clearer!)
    code. This type of operator is especially handy for large data sets.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们得到了与上面相同的输出，但代码更少（也更清晰！）这种类型的运算符对于大型数据集特别有用。
- en: 'Suppose instead we wanted to extract columns that followed a particular pattern
    rather than just selecting a range. For example, let’s say we wanted only to select
    the columns `most_at_home` and `most_at_work`. There are other helpers that allow
    us to select variables based on their names. In particular, we can use the `select`
    helper `starts_with` to choose only the columns that start with the word “most”:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要提取符合特定模式的列，而不仅仅是选择一个范围。例如，假设我们只想选择 `most_at_home` 和 `most_at_work` 这些列。还有其他辅助函数允许我们根据它们的名称选择变量。特别是，我们可以使用
    `select` 辅助函数 `starts_with` 来选择以单词“most”开头的列：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We could also have chosen the columns containing an underscore `_` by adding
    `contains("_")` as the second argument in the `select` function, since we notice
    the columns we want contain underscores and the others don’t.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以选择包含下划线 `_` 的列，通过在 `select` 函数中添加 `contains("_")` 作为第二个参数，因为我们注意到我们想要的列包含下划线，而其他列则没有。
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There are many different `select` helpers that select variables based on certain
    criteria. The additional resources section at the end of this chapter provides
    a comprehensive resource on `select` helpers.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的 `select` 辅助函数，可以根据特定标准选择变量。本章末尾的附加资源部分提供了关于 `select` 辅助函数的全面资源。
- en: 3.6 Using `filter` to extract rows
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 使用 `filter` 提取行
- en: 'Next, we revisit the `filter` function from Chapter [1](intro.html#intro),
    which lets us create a subset of rows from a data frame. Recall the two main arguments
    to the `filter` function: the first is the name of the data frame object, and
    the second is a *logical statement* to use when filtering the rows. `filter` works
    by returning the rows where the logical statement evaluates to `TRUE`. This section
    will highlight more advanced usage of the `filter` function. In particular, this
    section provides an in-depth treatment of the variety of logical statements one
    can use in the `filter` function to select subsets of rows.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们回顾第[1](intro.html#intro)章中的`filter`函数，它允许我们从数据帧中创建行子集。回想一下`filter`函数的两个主要参数：第一个是数据帧对象的名称，第二个是用于过滤行的*逻辑语句*。`filter`函数通过返回逻辑语句评估为`TRUE`的行来工作。本节将突出介绍`filter`函数的更高级用法。特别是，本节深入探讨了在`filter`函数中可以使用各种逻辑语句来选择行子集。
- en: 3.6.1 Extracting rows that have a certain value with `==`
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.1 使用`==`提取具有特定值的行
- en: Suppose we are only interested in the subset of rows in `tidy_lang` corresponding
    to the official languages of Canada (English and French). We can `filter` for
    these rows by using the *equivalency operator* (`==`) to compare the values of
    the `category` column with the value `"Official languages"`. With these arguments,
    `filter` returns a data frame with all the columns of the input data frame but
    only the rows we asked for in the logical statement, i.e., those where the `category`
    column holds the value `"Official languages"`. We name this data frame `official_langs`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只对`tidy_lang`数据集中对应加拿大官方语言（英语和法语）的行子集感兴趣。我们可以通过使用*等价运算符*（`==`）比较`category`列的值与`"Official
    languages"`的值来`filter`这些行。使用这些参数，`filter`返回一个数据帧，包含输入数据帧的所有列，但只有我们在逻辑语句中请求的行，即`category`列包含值`"Official
    languages"`的行。我们将这个数据帧命名为`official_langs`。
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 3.6.2 Extracting rows that do not have a certain value with `!=`
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.2 使用`!=`提取不具有特定值的行
- en: What if we want all the other language categories in the data set *except* for
    those in the `"Official languages"` category? We can accomplish this with the
    `!=` operator, which means “not equal to”. So if we want to find all the rows
    where the `category` does *not* equal `"Official languages"` we write the code
    below.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要数据集中除“官方语言”类别之外的所有其他语言类别怎么办？我们可以使用`!=`运算符，它表示“不等于”。因此，如果我们想要找到所有`category`列不等于`"Official
    languages"`的行，我们可以编写下面的代码。
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 3.6.3 Extracting rows satisfying multiple conditions using `,` or `&`
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.3 使用`,`或`&`提取满足多个条件的行
- en: Suppose now we want to look at only the rows for the French language in Montréal.
    To do this, we need to filter the data set to find rows that satisfy multiple
    conditions simultaneously. We can do this with the comma symbol (`,`), which in
    the case of `filter` is interpreted by R as “and”. We write the code as shown
    below to filter the `official_langs` data frame to subset the rows where `region
    == "Montréal"` *and* the `language == "French"`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在我们只想查看蒙特利尔地区的法语行。为此，我们需要过滤数据集以找到同时满足多个条件的行。我们可以使用逗号符号（`,`），在`filter`函数中，R将其解释为“和”。下面我们编写代码来过滤`official_langs`数据帧，以子集形式获取满足`region
    == "Montréal"` *和* `language == "French"`的行。
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We can also use the ampersand (`&`) logical operator, which gives us cases where
    *both* one condition *and* another condition are satisfied. You can use either
    comma (`,`) or ampersand (`&`) in the `filter` function interchangeably.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用逻辑运算符`&`，它提供了满足一个条件 *和* 另一个条件都满足的情况。在`filter`函数中，你可以互换使用逗号（`,`）或逻辑运算符`&`。
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 3.6.4 Extracting rows satisfying at least one condition using `|`
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.4 使用`|`提取至少满足一个条件的行
- en: Suppose we were interested in only those rows corresponding to cities in Alberta
    in the `official_langs` data set (Edmonton and Calgary). We can’t use `,` as we
    did above because `region` cannot be both Edmonton *and* Calgary simultaneously.
    Instead, we can use the vertical pipe (`|`) logical operator, which gives us the
    cases where one condition *or* another condition *or* both are satisfied. In the
    code below, we ask R to return the rows where the `region` columns are equal to
    “Calgary” *or* “Edmonton”.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只对`official_langs`数据集中对应阿尔伯塔省城市（埃德蒙顿和卡尔加里）的行感兴趣。我们不能使用上面提到的逗号（`,`），因为`region`不能同时等于埃德蒙顿
    *和* 卡尔加里。相反，我们可以使用垂直管道（`|`）逻辑运算符，它提供了满足一个条件 *或* 另一个条件 *或* 两个条件都满足的情况。在下面的代码中，我们要求R返回`region`列等于“Calgary”
    *或* “Edmonton”的行。
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 3.6.5 Extracting rows with values in a vector using `%in%`
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.5 使用 `%in%` 提取向量中的值
- en: Next, suppose we want to see the populations of our five cities. Let’s read
    in the `region_data.csv` file that comes from the 2016 Canadian census, as it
    contains statistics for number of households, land area, population and number
    of dwellings for different regions.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，假设我们想查看我们五个城市的总人口。让我们读取来自 2016 年加拿大人口普查的 `region_data.csv` 文件，因为它包含不同地区的家庭数量、土地面积、人口和住宅数量的统计数据。
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To get the population of the five cities we can filter the data set using the
    `%in%` operator. The `%in%` operator is used to see if an element belongs to a
    vector. Here we are filtering for rows where the value in the `region` column
    matches any of the five cities we are intersted in: Toronto, Montréal, Vancouver,
    Calgary, and Edmonton.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取五个城市的总人口，我们可以使用 `%in%` 操作符过滤数据集。`%in%` 操作符用于检查一个元素是否属于一个向量。在这里，我们正在过滤那些 `region`
    列中的值与我们所感兴趣的五个城市（多伦多、蒙特利尔、温哥华、卡尔加里和埃德蒙顿）中的任何一个匹配的行。
- en: '[PRE40]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Note:** What’s the difference between `==` and `%in%`? Suppose we have two
    vectors, `vectorA` and `vectorB`. If you type `vectorA == vectorB` into R it will
    compare the vectors element by element. R checks if the first element of `vectorA`
    equals the first element of `vectorB`, the second element of `vectorA` equals
    the second element of `vectorB`, and so on. On the other hand, `vectorA %in% vectorB`
    compares the first element of `vectorA` to all the elements in `vectorB`. Then
    the second element of `vectorA` is compared to all the elements in `vectorB`,
    and so on. Notice the difference between `==` and `%in%` in the example below.'
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：** `==` 和 `%in%` 之间有什么区别？假设我们有两个向量，`vectorA` 和 `vectorB`。如果你在 R 中输入 `vectorA
    == vectorB`，它将逐元素比较这两个向量。R 会检查 `vectorA` 的第一个元素是否等于 `vectorB` 的第一个元素，`vectorA`
    的第二个元素是否等于 `vectorB` 的第二个元素，依此类推。另一方面，`vectorA %in% vectorB` 将 `vectorA` 的第一个元素与
    `vectorB` 中的所有元素进行比较。然后 `vectorA` 的第二个元素与 `vectorB` 中的所有元素进行比较，依此类推。注意以下示例中 `==`
    和 `%in%` 之间的区别。'
- en: ''
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ''
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ''
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ''
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 3.6.6 Extracting rows above or below a threshold using `>` and `<`
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.6 使用 `>` 和 `<` 提取高于或低于阈值的行
- en: We saw in Section [3.6.3](wrangling.html#filter-and) that 2,669,195 people reported
    speaking French in Montréal as their primary language at home. If we are interested
    in finding the official languages in regions with higher numbers of people who
    speak it as their primary language at home compared to French in Montréal, then
    we can use `filter` to obtain rows where the value of `most_at_home` is greater
    than 2,669,195. We use the `>` symbol to look for values *above* a threshold,
    and the `<` symbol to look for values *below* a threshold. The `>=` and `<=` symbols
    similarly look for *equal to or above* a threshold and *equal to or below* a threshold.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [3.6.3](wrangling.html#filter-and) 节中看到，有 2,669,195 人报告说在蒙特利尔将法语作为他们的家庭主要语言。如果我们对在家庭中将其作为主要语言的人数比蒙特利尔的法语更多的人口地区寻找官方语言感兴趣，那么我们可以使用
    `filter` 来获取 `most_at_home` 值大于 2,669,195 的行。我们使用 `>` 符号来查找高于阈值的值，使用 `<` 符号来查找低于阈值的值。`>=`
    和 `<=` 符号类似地用于查找等于或高于阈值的值和等于或低于阈值的值。
- en: '[PRE46]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`filter` returns a data frame with only one row, indicating that when considering
    the official languages, only English in Toronto is reported by more people as
    their primary language at home than French in Montréal according to the 2016 Canadian
    census.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter` 返回一个只有一行的数据框，表明在考虑官方语言的情况下，根据 2016 年加拿大人口普查，在多伦多，更多的人将英语而不是法语作为他们的家庭主要语言报告，这比蒙特利尔的法语要多。'
- en: 3.7 Using `mutate` to modify or add columns
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7 使用 `mutate` 修改或添加列
- en: 3.7.1 Using `mutate` to modify columns
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7.1 使用 `mutate` 修改列
- en: In Section [3.4.3](wrangling.html#separate), when we first read in the `"region_lang_top5_cities_messy.csv"`
    data, all of the variables were “character” data types. During the tidying process,
    we used the `convert` argument from the `separate` function to convert the `most_at_home`
    and `most_at_work` columns to the desired integer (i.e., numeric class) data types.
    But suppose we didn’t use the `convert` argument, and needed to modify the column
    type some other way. Below we create such a situation so that we can demonstrate
    how to use `mutate` to change the column types of a data frame. `mutate` is a
    useful function to modify or create new data frame columns.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [3.4.3](wrangling.html#separate) 节中，当我们首次读取 `"region_lang_top5_cities_messy.csv"`
    数据时，所有变量都是“字符”数据类型。在整理过程中，我们使用了 `separate` 函数的 `convert` 参数将 `most_at_home` 和
    `most_at_work` 列转换为所需的整数（即数值类）数据类型。但假设我们没有使用 `convert` 参数，需要以其他方式修改列类型。下面我们创建这样的场景，以便我们可以展示如何使用
    `mutate` 来更改数据框的列类型。`mutate` 是一个有用的函数，可以修改或创建新的数据框列。
- en: '[PRE48]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: To use `mutate`, again we first specify the data set in the first argument,
    and in the following arguments, we specify the name of the column we want to modify
    or create (here `most_at_home` and `most_at_work`), an `=` sign, and then the
    function we want to apply (here `as.numeric`). In the function we want to apply,
    we refer directly to the column name upon which we want it to act (here `most_at_home`
    and `most_at_work`). In our example, we are naming the columns the same names
    as columns that already exist in the data frame (“most_at_home”, “most_at_work”)
    and this will cause `mutate` to *overwrite* those columns (also referred to as
    modifying those columns *in-place*). If we were to give the columns a new name,
    then `mutate` would create new columns with the names we specified. `mutate`’s
    general syntax is detailed in Figure [3.14](wrangling.html#fig:img-mutate).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `mutate`，我们首先在第一个参数中指定数据集，然后在后续参数中指定我们想要修改或创建的列的名称（这里为 `most_at_home` 和
    `most_at_work`），一个 `=` 符号，然后是我们想要应用的功能（这里为 `as.numeric`）。在我们想要应用的功能中，我们直接引用我们想要其作用的列名（这里为
    `most_at_home` 和 `most_at_work`）。在我们的例子中，我们给列取的名字与数据框中已存在的列名相同（“most_at_home”，
    “most_at_work”），这将导致 `mutate` 会 *覆盖* 这些列（也称为就地 *修改* 这些列）。如果我们给列取一个新的名字，那么 `mutate`
    会创建我们指定的新列名。`mutate` 的通用语法在图 [3.14](wrangling.html#fig:img-mutate) 中详细说明。
- en: '![Syntax for the mutate function.](../Images/8dc63a5f19a0692b46d0ea68e4ef8cae.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![`mutate` 函数的语法。](../Images/8dc63a5f19a0692b46d0ea68e4ef8cae.png)'
- en: 'Figure 3.14: Syntax for the `mutate` function.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14：`mutate` 函数的语法。
- en: 'Below we use `mutate` to convert the columns `most_at_home` and `most_at_work`
    to numeric data types in the `official_langs` data set as described in Figure
    [3.14](wrangling.html#fig:img-mutate):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下面我们使用 `mutate` 将 `official_langs` 数据集中的 `most_at_home` 和 `most_at_work` 列转换为数值数据类型，如图
    [3.14](wrangling.html#fig:img-mutate) 所示：
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now we see `<dbl>` appears under the `most_at_home` and `most_at_work` columns,
    indicating they are double data types (which is a numeric data type)!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到 `most_at_home` 和 `most_at_work` 列下面出现了 `<dbl>`，这表明它们是双精度浮点数据类型（这是一种数值数据类型）！
- en: 3.7.2 Using `mutate` to create new columns
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7.2 使用 `mutate` 创建新列
- en: We can see in the table that 3,836,770 people reported speaking English in Toronto
    as their primary language at home, according to the 2016 Canadian census. What
    does this number mean to us? To understand this number, we need context. In particular,
    how many people were in Toronto when this data was collected? From the 2016 Canadian
    census profile, the population of Toronto was reported to be 5,928,040 people.
    The number of people who report that English is their primary language at home
    is much more meaningful when we report it in this context. We can even go a step
    further and transform this count to a relative frequency or proportion. We can
    do this by dividing the number of people reporting a given language as their primary
    language at home by the number of people who live in Toronto. For example, the
    proportion of people who reported that their primary language at home was English
    in the 2016 Canadian census was 0.65 in Toronto.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在表中看到，根据 2016 年加拿大人口普查，有 3,836,770 人报告说在家中使用英语作为他们的主要语言。这个数字对我们意味着什么？为了理解这个数字，我们需要上下文。特别是，在收集这些数据时多伦多有多少人？根据
    2016 年加拿大人口普查概要，多伦多的人口报告为 5,928,040 人。当我们在这种背景下报告说英语是他们的主要家庭语言的人数时，这个数字就更有意义了。我们甚至可以更进一步，将这个计数转换为相对频率或比例。我们可以通过将报告说他们的主要家庭语言是给定语言的人数除以居住在多伦多的人数来实现这一点。例如，2016
    年加拿大人口普查中报告说他们的主要家庭语言是英语的比例在多伦多是 0.65。
- en: 'Let’s use `mutate` to create a new column in our data frame that holds the
    proportion of people who speak English for our five cities of focus in this chapter.
    To accomplish this, we will need to do two tasks beforehand:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `mutate` 在我们的数据框中创建一个新列，该列包含我们本章关注的五个城市中讲英语的人的比例。为了完成这项任务，我们事先需要做两个任务：
- en: Create a vector containing the population values for the cities.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含城市人口值的向量。
- en: Filter the `official_langs` data frame so that we only keep the rows where the
    language is English.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 筛选 `official_langs` 数据框，只保留语言为英语的行。
- en: 'To create a vector containing the population values for the five cities (Toronto,
    Montréal, Vancouver, Calgary, Edmonton), we will use the `c` function (recall
    that `c` stands for “concatenate”):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个包含五个城市（多伦多、蒙特利尔、温哥华、卡尔加里、埃德蒙顿）的人口值的向量，我们将使用 `c` 函数（回想一下 `c` 代表“连接”）：
- en: '[PRE52]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And next, we will filter the `official_langs` data frame so that we only keep
    the rows where the language is English. We will name the new data frame we get
    from this `english_langs`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将筛选 `official_langs` 数据框，只保留语言为英语的行。我们将得到的新数据框命名为 `english_langs`：
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Finally, we can use `mutate` to create a new column, named `most_at_home_proportion`,
    that will have value that corresponds to the proportion of people reporting English
    as their primary language at home. We will compute this by dividing the column
    by our vector of city populations.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 `mutate` 创建一个名为 `most_at_home_proportion` 的新列，其值对应于报告说他们的主要家庭语言是英语的人数比例。我们将通过将列除以我们的城市人口向量来计算这个值。
- en: '[PRE56]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the computation above, we had to ensure that we ordered the `city_pops` vector
    in the same order as the cities were listed in the `english_langs` data frame.
    This is because R will perform the division computation we did by dividing each
    element of the `most_at_home` column by each element of the `city_pops` vector,
    matching them up by position. Failing to do this would have resulted in the incorrect
    math being performed.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的计算中，我们必须确保将 `city_pops` 向量按照 `english_langs` 数据框中城市列表的顺序排序。这是因为 R 会执行我们进行的除法计算，通过将
    `most_at_home` 列的每个元素除以 `city_pops` 向量的每个元素，并按位置匹配。如果没有这样做，就会导致执行错误的数学运算。
- en: '**Note:** In more advanced data wrangling, one might solve this problem in
    a less error-prone way though using a technique called “joins.” We link to resources
    that discuss this in the additional resources at the end of this chapter.'
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：** 在更高级的数据整理中，有人可能会通过使用称为“连接”的技术以更不易出错的方式解决这个问题。我们将在本章末尾的附加资源中链接到讨论此内容的资源。'
- en: 3.8 Combining functions using the pipe operator, `|>`
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.8 使用管道操作符 `|>` 组合函数
- en: 'In R, we often have to call multiple functions in a sequence to process a data
    frame. The basic ways of doing this can become quickly unreadable if there are
    many steps. For example, suppose we need to perform three operations on a data
    frame called `data`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，我们经常需要按顺序调用多个函数来处理数据框。如果有许多步骤，基本的方法会很快变得难以阅读。例如，假设我们需要对一个名为 `data` 的数据框执行三个操作：
- en: add a new column `new_col` that is double another `old_col`,
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新列 `new_col`，它是另一列 `old_col` 的两倍，
- en: filter for rows where another column, `other_col`, is more than 5, and
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 筛选行，其中另一列 `other_col` 大于 5，
- en: select only the new column `new_col` for those rows.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅选择那些行的新的列 `new_col`。
- en: 'One way of performing these three steps is to just write multiple lines of
    code, storing temporary objects as you go:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这三个步骤的一种方法就是简单地编写多行代码，在执行过程中存储临时对象：
- en: '[PRE58]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is difficult to understand for multiple reasons. The reader may be tricked
    into thinking the named `output_1` and `output_2` objects are important for some
    reason, while they are just temporary intermediate computations. Further, the
    reader has to look through and find where `output_1` and `output_2` are used in
    each subsequent line.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于多个原因来说难以理解。读者可能会被误导，认为命名对象 `output_1` 和 `output_2` 由于某种原因很重要，而实际上它们只是临时的中间计算。此外，读者必须逐行查找
    `output_1` 和 `output_2` 在后续每一行中的使用位置。
- en: 'Another option for doing this would be to *compose* the functions:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种完成这个任务的方法是 *组合* 函数：
- en: '[PRE59]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Code like this can also be difficult to understand. Functions compose (reading
    from left to right) in the *opposite order* in which they are computed by R (above,
    `mutate` happens first, then `filter`, then `select`). It is also just a really
    long line of code to read in one go.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的代码也可能难以理解。函数以与 R 计算它们的顺序相反的顺序（从左到右）组合（在上面的例子中，`mutate` 首先发生，然后是 `filter`，然后是
    `select`）。这同样是一行很长的代码，一次阅读起来可能很困难。
- en: 'The *pipe operator* (`|>`) solves this problem, resulting in cleaner and easier-to-follow
    code. `|>` is built into R so you don’t need to load any packages to use it. You
    can think of the pipe as a physical pipe. It takes the output from the function
    on the left-hand side of the pipe, and passes it as the first argument to the
    function on the right-hand side of the pipe. The code below accomplishes the same
    thing as the previous two code blocks:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*管道操作符* (`|>`) 解决了这个问题，使得代码更加清晰且易于理解。`|>` 是 R 内置的，因此你不需要加载任何包来使用它。你可以将管道想象成一个物理管道。它从管道左侧函数的输出中获取数据，并将其作为管道右侧函数的第一个参数传递。下面的代码与之前的两个代码块完成相同的功能：'
- en: '[PRE60]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**Note:** You might also have noticed that we split the function calls across
    lines after the pipe, similar to when we did this earlier in the chapter for long
    function calls. Again, this is allowed and recommended, especially when the piped
    function calls create a long line of code. Doing this makes your code more readable.
    When you do this, it is important to end each line with the pipe operator `|>`
    to tell R that your code is continuing onto the next line.'
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：** 你可能也注意到了，在管道之后我们将函数调用分跨多行，这与我们在本章前面处理长函数调用时所做的类似。再次强调，这是允许的，也是推荐的，尤其是在管道函数调用创建了一行很长的代码时。这样做可以使你的代码更易于阅读。当你这样做时，重要的是要在每一行末尾使用管道操作符
    `|>` 来告诉 R 你的代码将继续到下一行。'
- en: '**Note:** In this textbook, we will be using the base R pipe operator syntax,
    `|>`. This base R `|>` pipe operator was inspired by a previous version of the
    pipe operator, `%>%`. The `%>%` pipe operator is not built into R and is from
    the `magrittr` R package. The `tidyverse` metapackage imports the `%>%` pipe operator
    via `dplyr` (which in turn imports the `magrittr` R package). There are some other
    differences between `%>%` and `|>` related to more advanced R uses, such as sharing
    and distributing code as R packages, however, these are beyond the scope of this
    textbook. We have this note in the book to make the reader aware that `%>%` exists
    as it is still commonly used in data analysis code and in many data science books
    and other resources. In most cases these two pipes are interchangeable and either
    can be used.'
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：** 在这本教科书中，我们将使用基础 R 管道操作符语法，`|>`。这个基础 R 的 `|>` 管道操作符受到了之前版本管道操作符 `%>%`
    的启发。`%>%` 管道操作符不是 R 内置的，它来自 `magrittr` R 包。`tidyverse` 元包通过 `dplyr` 导入了 `%>%`
    管道操作符（`dplyr` 又反过来导入了 `magrittr` R 包）。`%>%` 和 `|>` 之间有一些与更高级 R 使用相关的差异，例如作为 R
    包共享和分发代码，但这些超出了本教科书的范围。我们在书中添加这个说明是为了让读者知道 `%>%` 存在，因为它仍然在数据分析代码、许多数据科学书籍和其他资源中广泛使用。在大多数情况下，这两个管道是可以互换的，你可以使用任一。'
- en: 3.8.1 Using `|>` to combine `filter` and `select`
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.8.1 使用 `|>` 结合 `filter` 和 `select`
- en: 'Let’s work with the tidy `tidy_lang` data set from Section [3.4.3](wrangling.html#separate),
    which contains the number of Canadians reporting their primary language at home
    and work for five major cities (Toronto, Montréal, Vancouver, Calgary, and Edmonton):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们处理第[3.4.3](wrangling.html#separate)节中的整洁`tidy_lang`数据集，该数据集包含五个主要城市（多伦多、蒙特利尔、温哥华、卡尔加里和埃德蒙顿）的加拿大人报告他们在家和工作的主要语言数量：
- en: '[PRE61]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Suppose we want to create a subset of the data with only the languages and counts
    of each language spoken most at home for the city of Vancouver. To do this, we
    can use the functions `filter` and `select`. First, we use `filter` to create
    a data frame called `van_data` that contains only values for Vancouver.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个只包含温哥华市最常在家说的语言及其数量的数据子集。为此，我们可以使用`filter`和`select`函数。首先，我们使用`filter`创建一个名为`van_data`的数据框，其中只包含温哥华的值。
- en: '[PRE63]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We then use `select` on this data frame to keep only the variables we want:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`select`在这个数据框上仅保留我们想要的变量：
- en: '[PRE65]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Although this is valid code, there is a more readable approach we could take
    by using the pipe, `|>`. With the pipe, we do not need to create an intermediate
    object to store the output from `filter`. Instead, we can directly send the output
    of `filter` to the input of `select`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是有效的代码，但我们可以通过使用管道`|>`来采取更易于阅读的方法。使用管道，我们不需要创建一个中间对象来存储`filter`的输出。相反，我们可以直接将`filter`的输出发送到`select`的输入：
- en: '[PRE67]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'But wait…Why do the `select` function calls look different in these two examples?
    Remember: when you use the pipe, the output of the first function is automatically
    provided as the first argument for the function that comes after it. Therefore
    you do not specify the first argument in that function call. In the code above,
    The pipe passes the left-hand side (the output of `filter`) to the first argument
    of the function on the right (`select`), so in the `select` function you only
    see the second argument (and beyond). As you can see, both of these approaches—with
    and without pipes—give us the same output, but the second approach is clearer
    and more readable.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等…为什么这两个例子中的`select`函数调用看起来不同？记住：当你使用管道时，第一个函数的输出会自动提供给后续函数的第一个参数。因此，你不需要在函数调用中指定第一个参数。在上面的代码中，管道将左侧（`filter`的输出）传递给右侧函数（`select`）的第一个参数，所以在`select`函数中你只看到第二个参数（及以后）。正如你所看到的，这两种方法——带和不带管道——都给出了相同的输出，但第二种方法更清晰、更易于阅读。
- en: 3.8.2 Using `|>` with more than two functions
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.8.2 使用`|>`与两个以上的函数
- en: 'The pipe operator (|>) can be used with any function in R. Additionally, we
    can pipe together more than two functions. For example, we can pipe together three
    functions to:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 管道操作符（|>）可以与R中的任何函数一起使用。此外，我们可以将两个以上的函数连接起来。例如，我们可以将三个函数连接起来：
- en: '`filter` rows to include only those where the counts of the language most spoken
    at home are greater than 10,000,'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`行以包含在家最常说的语言数量大于10,000的行。'
- en: '`select` only the columns corresponding to `region`, `language` and `most_at_home`,
    and'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅选择对应于`region`、`language`和`most_at_home`的列，
- en: '`arrange` the data frame rows in order by counts of the language most spoken
    at home from smallest to largest.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按在家最常说的语言的数量从小到大对数据框行进行`arrange`排序。
- en: As we saw in Chapter [1](intro.html#intro), we can use the `tidyverse` `arrange`
    function to order the rows in the data frame by the values of one or more columns.
    Here we pass the column name `most_at_home` to arrange the data frame rows by
    the values in that column, in ascending order.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在第[1](intro.html#intro)章中看到的，我们可以使用`tidyverse`的`arrange`函数按一个或多个列的值对数据框中的行进行排序。在这里，我们传递列名`most_at_home`来按该列中的值对数据框行进行排序，按升序排列。
- en: '[PRE69]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: You will notice above that we passed `tidy_lang` as the first argument of the
    `filter` function. We can also pipe the data frame into the same sequence of functions
    rather than using it as the first argument of the first function. These two choices
    are equivalent, and we get the same result.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在上面的例子中，我们将`tidy_lang`作为`filter`函数的第一个参数。我们也可以将数据框管道输入到相同的函数序列中，而不是将其用作第一个函数的第一个参数。这两个选择是等效的，我们得到相同的结果。
- en: '[PRE71]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now that we’ve shown you the pipe operator as an alternative to storing temporary
    objects and composing code, does this mean you should *never* store temporary
    objects or compose code? Not necessarily! There are times when you will still
    want to do these things. For example, you might store a temporary object before
    feeding it into a plot function so you can iteratively change the plot without
    having to redo all of your data transformations. Additionally, piping many functions
    can be overwhelming and difficult to debug; you may want to store a temporary
    object midway through to inspect your result before moving on with further steps.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经向您展示了管道操作符作为存储临时对象和组合代码的替代方案，这意味着您应该 *永远* 不要存储临时对象或组合代码吗？不一定！有时您仍然会想要做这些事情。例如，您可能在将其输入到绘图函数之前存储一个临时对象，这样您就可以迭代地更改图表，而无需重新执行所有数据转换。此外，管道多个函数可能会让人感到不知所措且难以调试；您可能希望在中间存储一个临时对象，以便在继续下一步之前检查您的结果。
- en: 3.9 Aggregating data with `summarize` and `map`
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.9 使用 `summarize` 和 `map` 聚合数据
- en: 3.9.1 Calculating summary statistics on whole columns
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.9.1 在整个列上计算摘要统计
- en: As a part of many data analyses, we need to calculate a summary value for the
    data (a *summary statistic*). Examples of summary statistics we might want to
    calculate are the number of observations, the average/mean value for a column,
    the minimum value, etc. Oftentimes, this summary statistic is calculated from
    the values in a data frame column, or columns, as shown in Figure [3.15](wrangling.html#fig:summarize).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 作为许多数据分析的一部分，我们需要计算数据的摘要值（*摘要统计量*）。我们可能想要计算的摘要统计量的例子包括观测值的数量、列的平均/均值值、最小值等。通常，这个摘要统计量是从数据框的值或列中计算出来的，如图
    [3.15](wrangling.html#fig:summarize) 所示。
- en: '![summarize is useful for calculating summary statistics on one or more column(s).
    In its simplest use case, it creates a new data frame with a single row containing
    the summary statistic(s) for each column being summarized. The darker, top row
    of each table represents the column headers.](../Images/f34fdcc3b5693eedce35f32236573913.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![总结统计对于计算一个或多个列的摘要统计很有用。在其最简单的使用案例中，它创建一个新的数据框，其中包含每列的摘要统计量。每个表格的较暗、顶行代表列标题。](../Images/f34fdcc3b5693eedce35f32236573913.png)'
- en: 'Figure 3.15: `summarize` is useful for calculating summary statistics on one
    or more column(s). In its simplest use case, it creates a new data frame with
    a single row containing the summary statistic(s) for each column being summarized.
    The darker, top row of each table represents the column headers.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15：`summarize` 对于计算一个或多个列的摘要统计很有用。在其最简单的使用案例中，它创建一个新的数据框，其中包含每列的摘要统计量。每个表格的较暗、顶行代表列标题。
- en: 'A useful `dplyr` function for calculating summary statistics is `summarize`,
    where the first argument is the data frame and subsequent arguments are the summaries
    we want to perform. Here we show how to use the `summarize` function to calculate
    the minimum and maximum number of Canadians reporting a particular language as
    their primary language at home. First a reminder of what `region_lang` looks like:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于计算摘要统计的有用 `dplyr` 函数是 `summarize`，其中第一个参数是数据框，后续参数是我们想要执行的摘要。在这里，我们展示了如何使用
    `summarize` 函数来计算报告将特定语言作为其在家主要语言的加拿大人的最小和最大数量。首先，让我们回顾一下 `region_lang` 的样子：
- en: '[PRE73]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We apply `summarize` to calculate the minimum and maximum number of Canadians
    reporting a particular language as their primary language at home, for any region:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用 `summarize` 来计算报告将特定语言作为其在家主要语言的加拿大人的最小和最大数量，对于任何地区：
- en: '[PRE75]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: From this we see that there are some languages in the data set that no one speaks
    as their primary language at home. We also see that the most commonly spoken primary
    language at home is spoken by 3,836,770 people.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里我们可以看到，数据集中有一些语言没有人将其作为在家主要语言。我们还看到，在家最常说的主要语言是由 3,836,770 人使用的。
- en: 3.9.2 Calculating summary statistics when there are `NA`s
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.9.2 当存在 `NA` 时计算摘要统计
- en: In data frames in R, the value `NA` is often used to denote missing data. Many
    of the base R statistical summary functions (e.g., `max`, `min`, `mean`, `sum`,
    etc) will return `NA` when applied to columns containing `NA` values. Usually
    that is not what we want to happen; instead, we would usually like R to ignore
    the missing entries and calculate the summary statistic using all of the other
    non-`NA` values in the column. Fortunately many of these functions provide an
    argument `na.rm` that lets us tell the function what to do when it encounters
    `NA` values. In particular, if we specify `na.rm = TRUE`, the function will ignore
    missing values and return a summary of all the non-missing entries. We show an
    example of this combined with `summarize` below.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在R的数据框中，值`NA`通常用来表示缺失数据。许多基本的R统计汇总函数（例如`max`、`min`、`mean`、`sum`等）在应用于包含`NA`值的列时将返回`NA`。通常我们并不希望发生这种情况；相反，我们通常希望R忽略缺失条目，并使用列中所有其他非`NA`值来计算汇总统计量。幸运的是，许多这些函数提供了一个名为`na.rm`的参数，允许我们告诉函数在遇到`NA`值时该怎么做。特别是，如果我们指定`na.rm
    = TRUE`，函数将忽略缺失值，并返回所有非缺失条目的汇总。以下是一个结合`summarize`的示例。
- en: 'First we create a new version of the `region_lang` data frame, named `region_lang_na`,
    that has a seemingly innocuous `NA` in the first row of the `most_at_home column`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个新的`region_lang`数据框版本，命名为`region_lang_na`，其中在`most_at_home`列的第一行有一个看似无害的`NA`：
- en: '[PRE77]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Now if we apply the `summarize` function as above, we see that we no longer
    get the minimum and maximum returned, but just an `NA` instead!
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们像上面那样应用`summarize`函数，我们会看到我们不再得到最小和最大值返回，而是只得到一个`NA`！
- en: '[PRE79]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We can fix this by adding the `na.rm = TRUE` as explained above:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加`na.rm = TRUE`来解决这个问题，如上所述：
- en: '[PRE81]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 3.9.3 Calculating summary statistics for groups of rows
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.9.3 计算行组的汇总统计量
- en: A common pairing with `summarize` is `group_by`. Pairing these functions together
    can let you summarize values for subgroups within a data set, as illustrated in
    Figure [3.16](wrangling.html#fig:summarize-groupby). For example, we can use `group_by`
    to group the regions of the `region_lang` data frame and then calculate the minimum
    and maximum number of Canadians reporting the language as the primary language
    at home for each of the regions in the data set.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`summarize`的一个常见搭配是`group_by`。将这些函数组合在一起可以让你对数据集中的子组进行汇总，如图[3.16](wrangling.html#fig:summarize-groupby)所示。例如，我们可以使用`group_by`来对`region_lang`数据框中的区域进行分组，然后计算数据集中每个区域报告将语言作为家庭主要语言的加拿大人的最小和最大数量。'
- en: '![summarize and group_by is useful for calculating summary statistics on one
    or more column(s) for each group. It creates a new data frame—with one row for
    each group—containing the summary statistic(s) for each column being summarized.
    It also creates a column listing the value of the grouping variable. The darker,
    top row of each table represents the column headers. The orange, blue, and green
    colored rows correspond to the rows that belong to each of the three groups being
    represented in this cartoon example.](../Images/d3efbdb29f75a9a9e2dc6b99ec2af15c.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![summarize和group_by对于计算每个组的一个或多个列的汇总统计量非常有用。它创建了一个新的数据框——每个组一行——包含每个被汇总列的汇总统计量。它还创建了一个列，列出分组变量的值。每个表格较暗的顶部行代表列标题。橙色、蓝色和绿色的行对应于在这个卡通示例中代表的三组中的每一组。](../Images/d3efbdb29f75a9a9e2dc6b99ec2af15c.png)'
- en: 'Figure 3.16: `summarize` and `group_by` is useful for calculating summary statistics
    on one or more column(s) for each group. It creates a new data frame—with one
    row for each group—containing the summary statistic(s) for each column being summarized.
    It also creates a column listing the value of the grouping variable. The darker,
    top row of each table represents the column headers. The orange, blue, and green
    colored rows correspond to the rows that belong to each of the three groups being
    represented in this cartoon example.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16：`summarize`和`group_by`对于计算每个组的一个或多个列的汇总统计量非常有用。它创建了一个新的数据框——每个组一行——包含每个被汇总列的汇总统计量。它还创建了一个列，列出分组变量的值。每个表格较暗的顶部行代表列标题。橙色、蓝色和绿色的行对应于在这个卡通示例中代表的三组中的每一组。
- en: The `group_by` function takes at least two arguments. The first is the data
    frame that will be grouped, and the second and onwards are columns to use in the
    grouping. Here we use only one column for grouping (`region`), but more than one
    can also be used. To do this, list additional columns separated by commas.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`group_by` 函数至少需要两个参数。第一个是要分组的DataFrame，第二个及以后的参数是用于分组的列。在这里，我们只使用一个列进行分组（`region`），但也可以使用多个列。为此，请用逗号分隔列出额外的列。'
- en: '[PRE83]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Notice that `group_by` on its own doesn’t change the way the data looks. In
    the output below, the grouped data set looks the same, and it doesn’t *appear*
    to be grouped by `region`. Instead, `group_by` simply changes how other functions
    work with the data, as we saw with `summarize` above.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`group_by` 本身不会改变数据的外观。在下面的输出中，分组后的数据集看起来相同，并且它看起来并没有按 `region` 进行分组。相反，`group_by`
    只是改变了其他函数如何处理数据，正如我们在上面的 `summarize` 中看到的。
- en: '[PRE85]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 3.9.4 Calculating summary statistics on many columns
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.9.4 在多列上计算总结统计
- en: Sometimes we need to summarize statistics across many columns. An example of
    this is illustrated in Figure [3.17](wrangling.html#fig:summarize-across). In
    such a case, using `summarize` alone means that we have to type out the name of
    each column we want to summarize. In this section we will meet two strategies
    for performing this task. First we will see how we can do this using `summarize`
    + `across`. Then we will also explore how we can use a more general iteration
    function, `map`, to also accomplish this.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们需要总结多列的统计数据。图 [3.17](wrangling.html#fig:summarize-across) 中的例子说明了这种情况。在这种情况下，单独使用
    `summarize` 意味着我们必须逐个输入我们想要总结的每一列的名称。在本节中，我们将介绍两种执行此任务的方法。首先，我们将看到如何使用 `summarize`
    + `across` 来完成这项任务。然后，我们还将探讨如何使用更通用的迭代函数 `map` 来完成这项任务。
- en: '![summarize + across or map is useful for efficiently calculating summary statistics
    on many columns at once. The darker, top row of each table represents the column
    headers.](../Images/e3711db4946ca6bae3cead1d5fe4f2ab.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![summarize + across or map is useful for efficiently calculating summary statistics
    on many columns at once. The darker, top row of each table represents the column
    headers.](../Images/e3711db4946ca6bae3cead1d5fe4f2ab.png)'
- en: 'Figure 3.17: `summarize` + `across` or `map` is useful for efficiently calculating
    summary statistics on many columns at once. The darker, top row of each table
    represents the column headers.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.17：`summarize` + `across` 或 `map` 对于同时高效计算多列的总结统计很有用。每个表格中较暗的顶部行代表列标题。
- en: '`summarize` and `across` for calculating summary statistics on many columns'
  id: totrans-320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 `summarize` 和 `across` 在多列上计算总结统计
- en: To summarize statistics across many columns, we can use the `summarize` function
    we have just recently learned about. However, in such a case, using `summarize`
    alone means that we have to type out the name of each column we want to summarize.
    To do this more efficiently, we can pair `summarize` with `across` and use a colon
    `:` to specify a range of columns we would like to perform the statistical summaries
    on. Here we demonstrate finding the maximum value of each of the numeric columns
    of the `region_lang` data set.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 要总结多列的统计数据，我们可以使用我们刚刚学到的新函数 `summarize`。然而，在这种情况下，单独使用 `summarize` 意味着我们必须逐个输入我们想要总结的每一列的名称。为了更有效地完成这项任务，我们可以将
    `summarize` 与 `across` 配对，并使用冒号 `:` 来指定我们想要进行统计总结的列的范围。在这里，我们将演示如何找到 `region_lang`
    数据集中每个数值列的最大值。
- en: '[PRE87]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '**Note:** Similar to when we use base R statistical summary functions (e.g.,
    `max`, `min`, `mean`, `sum`, etc) with `summarize` alone, the use of the `summarize`
    + `across` functions paired with base R statistical summary functions also return
    `NA`s when we apply them to columns that contain `NA`s in the data frame.'
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：** 与我们单独使用基础 R 统计总结函数（例如 `max`、`min`、`mean`、`sum` 等）时的情况类似，当我们将 `summarize`
    + `across` 函数与基础 R 统计总结函数配对使用时，如果我们将它们应用于包含 `NA` 的数据框的列，也会返回 `NA`。'
- en: ''
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To resolve this issue, again we need to add the argument `na.rm = TRUE`. But
    in this case we need to use it a little bit differently: we write a `~`, and then
    call the summary function with the first argument `.x` and the second argument
    `na.rm = TRUE`. For example, for the previous example with the `max` function,
    we would write'
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们再次需要添加参数 `na.rm = TRUE`。但在这个情况下，我们需要稍微不同地使用它：我们写一个 `~`，然后调用总结函数，第一个参数是
    `.x`，第二个参数是 `na.rm = TRUE`。例如，对于之前使用 `max` 函数的例子，我们会写成
- en: ''
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE89]'
- en: ''
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE90]'
- en: ''
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The meaning of this unusual syntax is a bit beyond the scope of this book, but
    interested readers can look up *anonymous functions* in the `purrr` package from
    `tidyverse`.
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种不寻常语法的含义略超出了本书的范围，但感兴趣的读者可以在 `tidyverse` 的 `purrr` 包中查找 *匿名函数*。
- en: '`map` for calculating summary statistics on many columns'
  id: totrans-333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`map` 用于计算多个列的摘要统计量'
- en: 'An alternative to `summarize` and `across` for applying a function to many
    columns is the `map` family of functions. Let’s again find the maximum value of
    each column of the `region_lang` data frame, but using `map` with the `max` function
    this time. `map` takes two arguments: an object (a vector, data frame or list)
    that you want to apply the function to, and the function that you would like to
    apply to each column. Note that `map` does not have an argument to specify *which*
    columns to apply the function to. Therefore, we will use the `select` function
    before calling `map` to choose the columns for which we want the maximum.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将函数应用于多个列的 `summarize` 和 `across` 的替代方案是 `map` 函数族。让我们再次找到 `region_lang` 数据框中每一列的最大值，但这次使用
    `map` 函数和 `max` 函数。`map` 函数接受两个参数：一个对象（一个向量、数据框或列表），你想要对其应用函数，以及你想要应用于每一列的函数。请注意，`map`
    没有参数来指定要应用函数的 *哪些* 列。因此，在调用 `map` 之前，我们将使用 `select` 函数来选择我们想要获取最大值的列。
- en: '[PRE91]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '**Note:** The `map` function comes from the `purrr` package. But since `purrr`
    is part of the tidyverse, once we call `library(tidyverse)` we do not need to
    load the `purrr` package separately.'
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：** `map` 函数来自 `purrr` 包。但由于 `purrr` 是 tidyverse 的一部分，一旦我们调用了 `library(tidyverse)`，我们就不需要单独加载
    `purrr` 包。'
- en: 'The output looks a bit weird… we passed in a data frame, but the output doesn’t
    look like a data frame. As it so happens, it is *not* a data frame, but rather
    a plain list:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来有点奇怪……我们传递了一个数据框，但输出看起来并不像数据框。实际上，它 *不是* 数据框，而是一个普通的列表：
- en: '[PRE93]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: So what do we do? Should we convert this to a data frame? We could, but a simpler
    alternative is to just use a different `map` function. There are quite a few to
    choose from, they all work similarly, but their name reflects the type of output
    you want from the mapping operation. Table [3.3](wrangling.html#tab:map-table)
    lists the commonly used `map` functions as well as their output type.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们该怎么办？我们应该将其转换为数据框吗？我们可以这样做，但一个更简单的替代方案是只使用不同的 `map` 函数。可供选择的有相当多，它们的工作方式相似，但它们的名称反映了映射操作想要得到的输出类型。表
    [3.3](wrangling.html#tab:map-table) 列出了常用的 `map` 函数以及它们的输出类型。
- en: 'Table 3.3: The `map` functions in R.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.3：R 中的 `map` 函数。
- en: '| `map` function | Output |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| `map` 函数 | 输出 |'
- en: '| --- | --- |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `map` | list |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| `map` | 列表 |'
- en: '| `map_lgl` | logical vector |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| `map_lgl` | 逻辑向量 |'
- en: '| `map_int` | integer vector |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| `map_int` | 整数向量 |'
- en: '| `map_dbl` | double vector |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| `map_dbl` | 双精度向量 |'
- en: '| `map_chr` | character vector |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `map_chr` | 字符向量 |'
- en: '| `map_dfc` | data frame, combining column-wise |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `map_dfc` | 数据框，列向合并 |'
- en: '| `map_dfr` | data frame, combining row-wise |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `map_dfr` | 数据框，行向合并 |'
- en: 'Let’s get the columns’ maximums again, but this time use the `map_dfr` function
    to return the output as a data frame:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次获取列的最大值，但这次使用 `map_dfr` 函数将输出作为数据框返回：
- en: '[PRE95]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '**Note:** Similar to when we use base R statistical summary functions (e.g.,
    `max`, `min`, `mean`, `sum`, etc.) with `summarize`, `map` functions paired with
    base R statistical summary functions also return `NA` values when we apply them
    to columns that contain `NA` values.'
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：** 与我们使用基础 R 统计摘要函数（例如 `max`、`min`、`mean`、`sum` 等）与 `summarize` 一起使用时类似，当我们将
    `map` 函数应用于包含 `NA` 值的列时，也会返回 `NA` 值。'
- en: ''
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To avoid this, again we need to add the argument `na.rm = TRUE`. When we use
    this with `map`, we do this by adding a `,` and then `na.rm = TRUE` after specifying
    the function, as illustrated below:'
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们再次需要添加参数 `na.rm = TRUE`。当我们使用 `map` 时，我们通过在指定函数后添加 `,` 和 `na.rm =
    TRUE` 来这样做，如下所示：
- en: ''
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE97]'
- en: ''
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The `map` functions are generally quite useful for solving many problems involving
    repeatedly applying functions in R. Additionally, their use is not limited to
    columns of a data frame; `map` family functions can be used to apply functions
    to elements of a vector, or a list, and even to lists of (nested!) data frames.
    To learn more about the `map` functions, see the additional resources section
    at the end of this chapter.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 函数通常非常有用，可以解决许多涉及在 R 中重复应用函数的问题。此外，它们的使用不仅限于数据框的列；`map` 函数族可以用于将函数应用于向量的元素、列表，甚至（嵌套的！）数据框的列表。要了解更多关于
    `map` 函数的信息，请参阅本章末尾的附加资源部分。'
- en: 3.10 Apply functions across many columns with `mutate` and `across`
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.10 使用 `mutate` 和 `across` 在多列上应用函数
- en: Sometimes we need to apply a function to many columns in a data frame. For example,
    we would need to do this when converting units of measurements across many columns.
    We illustrate such a data transformation in Figure [3.18](wrangling.html#fig:mutate-across).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要在数据框的许多列上应用一个函数。例如，当我们需要在多列上转换度量单位时，我们就需要这样做。我们在图 [3.18](wrangling.html#fig:mutate-across)
    中展示了这种数据转换。
- en: '![mutate and across is useful for applying functions across many columns. The
    darker, top row of each table represents the column headers.](../Images/b438c16cffdfc9bd48cc74d956935185.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![mutate 和 across 在应用于多列时非常有用。每个表格中较暗的顶部行代表列标题。](../Images/b438c16cffdfc9bd48cc74d956935185.png)'
- en: 'Figure 3.18: `mutate` and `across` is useful for applying functions across
    many columns. The darker, top row of each table represents the column headers.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '图3.18: `mutate` 和 `across` 在应用于多列时非常有用。每个表格中较暗的顶部行代表列标题。'
- en: For example, imagine that we wanted to convert all the numeric columns in the
    `region_lang` data frame from double type to integer type using the `as.integer`
    function. When we revisit the `region_lang` data frame, we can see that this would
    be the columns from `mother_tongue` to `lang_known`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要使用 `as.integer` 函数将 `region_lang` 数据框中所有数值列从双精度类型转换为整型类型。当我们再次查看 `region_lang`
    数据框时，我们可以看到这将是从 `mother_tongue` 到 `lang_known` 的列。
- en: '[PRE99]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: To accomplish such a task, we can use `mutate` paired with `across`. This works
    in a similar way for column selection, as we saw when we used `summarize` + `across`
    earlier. As we did above, we again use `across` to specify the columns using `select`
    syntax as well as the function we want to apply on the specified columns. However,
    a key difference here is that we are using `mutate`, which means that we get back
    a data frame with the same number of columns and rows. The only thing that changes
    is the transformation we applied to the specified columns (here `mother_tongue`
    to `lang_known`).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这样的任务，我们可以使用 `mutate` 与 `across` 配对。这与我们在之前使用 `summarize` + `across` 时看到的方式类似。正如我们上面所做的那样，我们再次使用
    `across` 来指定列，使用 `select` 语法以及我们想要在指定列上应用的函数。然而，这里的一个关键区别是我们正在使用 `mutate`，这意味着我们得到一个具有相同列数和行数的数据框。唯一改变的是我们对指定列（此处为
    `mother_tongue` 到 `lang_known`）应用了转换。
- en: '[PRE101]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 3.11 Apply functions across columns within one row with `rowwise` and `mutate`
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.11 使用 `rowwise` 和 `mutate` 在一行内对列应用函数
- en: What if you want to apply a function across columns but within one row? We illustrate
    such a data transformation in Figure [3.19](wrangling.html#fig:rowwise).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在行内而不是在列上应用一个函数怎么办？我们在图 [3.19](wrangling.html#fig:rowwise) 中展示了这种数据转换。
- en: '![rowwise and mutate is useful for applying functions across columns within
    one row. The darker, top row of each table represents the column headers.](../Images/5229b54f088993f60f1beb56e0a82aaa.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![rowwise 和 mutate 在应用于一行内的列时非常有用。每个表格中较暗的顶部行代表列标题。](../Images/5229b54f088993f60f1beb56e0a82aaa.png)'
- en: 'Figure 3.19: `rowwise` and `mutate` is useful for applying functions across
    columns within one row. The darker, top row of each table represents the column
    headers.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '图3.19: `rowwise` 和 `mutate` 在应用于一行内的列时非常有用。每个表格中较暗的顶部行代表列标题。'
- en: For instance, suppose we want to know the maximum value between `mother_tongue`,
    `most_at_home`, `most_at_work` and `lang_known` for each language and region in
    the `region_lang` data set. In other words, we want to apply the `max` function
    *row-wise.* We will use the (aptly named) `rowwise` function in combination with
    `mutate` to accomplish this task.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想知道在 `region_lang` 数据集中每个语言和地区的 `mother_tongue`、`most_at_home`、`most_at_work`
    和 `lang_known` 之间的最大值。换句话说，我们想要按行应用 `max` 函数。我们将使用（恰如其分的）`rowwise` 函数与 `mutate`
    结合来完成此任务。
- en: 'Before we apply `rowwise`, we will `select` only the count columns so we can
    see all the columns in the data frame’s output easily in the book. So for this
    demonstration, the data set we are operating on looks like this:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用 `rowwise` 之前，我们将只 `select` 计数列，这样我们就可以在书中轻松地看到数据框的输出中的所有列。因此，对于这个演示，我们正在操作的数据集看起来是这样的：
- en: '[PRE103]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Now we apply `rowwise` before `mutate`, to tell R that we would like the mutate
    function to be applied across, and within, a row, as opposed to being applied
    on a column (which is the default behavior of `mutate`):'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们先应用 `rowwise`，然后再 `mutate`，告诉 R 我们希望 `mutate` 函数在行内和行间应用，而不是在列上应用（这是 `mutate`
    的默认行为）：
- en: '[PRE105]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: We see that we get an additional column added to the data frame, named `maximum`,
    which is the maximum value between `mother_tongue`, `most_at_home`, `most_at_work`
    and `lang_known` for each language and region.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到数据框中增加了一个额外的列，名为 `maximum`，它是每个语言和地区在 `mother_tongue`、`most_at_home`、`most_at_work`
    和 `lang_known` 之间的最大值。
- en: Similar to `group_by`, `rowwise` doesn’t appear to do anything when it is called
    by itself. However, we can apply `rowwise` in combination with other functions
    to change how these other functions operate on the data. Notice if we used `mutate`
    without `rowwise`, we would have computed the maximum value across *all* rows
    rather than the maximum value for *each* row. Below we show what would have happened
    had we not used `rowwise`. In particular, the same maximum value is reported in
    every single row; this code does not provide the desired result.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `group_by` 类似，`rowwise` 在单独调用时似乎没有做任何事情。然而，我们可以将 `rowwise` 与其他函数结合使用，以改变这些函数对数据操作的方式。注意，如果我们没有使用
    `rowwise` 就使用 `mutate`，我们会计算所有 *所有* 行的最大值，而不是每行的最大值。下面我们将展示如果没有使用 `rowwise` 会发生什么。特别是，每行都会报告相同的最大值；这段代码没有提供期望的结果。
- en: '[PRE107]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 3.12 Summary
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.12 摘要
- en: Cleaning and wrangling data can be a very time-consuming process. However, it
    is a critical step in any data analysis. We have explored many different functions
    for cleaning and wrangling data into a tidy format. Table [3.4](wrangling.html#tab:summary-functions-table)
    summarizes some of the key wrangling functions we learned in this chapter. In
    the following chapters, you will learn how you can take this tidy data and do
    so much more with it to answer your burning data science questions!
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 清洗和整理数据可能是一个非常耗时的过程。然而，这是任何数据分析中的关键步骤。我们已经探索了许多不同的函数来清洗和整理数据，使其成为整洁的格式。表 [3.4](wrangling.html#tab:summary-functions-table)
    总结了我们在本章中学到的关键整理函数。在接下来的章节中，你将学习如何使用这些整洁的数据做更多的事情，以回答你迫切的数据科学问题！
- en: 'Table 3.4: Summary of wrangling functions'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.4：数据整理函数摘要
- en: '| Function | Description |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `across` | allows you to apply function(s) to multiple columns |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| `across` | 允许你将函数应用于多个列 |'
- en: '| `filter` | subsets rows of a data frame |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| `filter` | 选择数据框的行子集 |'
- en: '| `group_by` | allows you to apply function(s) to groups of rows |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| `group_by` | 允许你将函数应用于行组 |'
- en: '| `mutate` | adds or modifies columns in a data frame |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| `mutate` | 在数据框中添加或修改列 |'
- en: '| `map` | general iteration function |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| `map` | 通用迭代函数 |'
- en: '| `pivot_longer` | generally makes the data frame longer and narrower |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| `pivot_longer` | 通常使数据框更长且更窄 |'
- en: '| `pivot_wider` | generally makes a data frame wider and decreases the number
    of rows |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| `pivot_wider` | 通常使数据框更宽并减少行数 |'
- en: '| `rowwise` | applies functions across columns within one row |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| `rowwise` | 在一行内应用函数 |'
- en: '| `separate` | splits up a character column into multiple columns |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| `separate` | 将字符列拆分为多个列 |'
- en: '| `select` | subsets columns of a data frame |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| `select` | 选择数据框的列子集 |'
- en: '| `summarize` | calculates summaries of inputs |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| `summarize` | 计算输入的摘要 |'
- en: 3.13 Exercises
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.13 练习
- en: Practice exercises for the material covered in this chapter can be found in
    the accompanying [worksheets repository](https://worksheets.datasciencebook.ca)
    in the “Cleaning and wrangling data” row. You can launch an interactive version
    of the worksheet in your browser by clicking the “launch binder” button. You can
    also preview a non-interactive version of the worksheet by clicking “view worksheet.”
    If you instead decide to download the worksheet and run it on your own machine,
    make sure to follow the instructions for computer setup found in Chapter [13](setup.html#setup).
    This will ensure that the automated feedback and guidance that the worksheets
    provide will function as intended.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的练习材料可以在“清洗和整理数据”行下的配套 [worksheets 仓库](https://worksheets.datasciencebook.ca)
    中找到。你可以通过点击“launch binder”按钮在你的浏览器中启动工作表的交互式版本。你也可以通过点击“view worksheet”预览工作表的非交互式版本。如果你决定下载工作表并在自己的机器上运行它，请确保遵循第
    [13](setup.html#setup) 章中找到的计算机设置说明。这将确保工作表提供的自动反馈和指导能够按预期工作。
- en: 3.14 Additional resources
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.14 其他资源
- en: 'As we mentioned earlier, `tidyverse` is actually an *R meta package*: it installs
    and loads a collection of R packages that all follow the tidy data philosophy
    we discussed above. One of the `tidyverse` packages is `dplyr`—a data wrangling
    workhorse. You have already met many of `dplyr`’s functions (`select`, `filter`,
    `mutate`, `arrange`, `summarize`, and `group_by`). To learn more about these functions
    and meet a few more useful functions, we recommend you check out Chapters 5-9
    of the [STAT545 online notes](https://stat545.com/). of the data wrangling, exploration,
    and analysis with R book.'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如我们之前提到的，`tidyverse` 实际上是一个 *R 元包*：它安装并加载了一组遵循我们上面讨论的 tidy data 哲学的 R 包。`tidyverse`
    包中的一个就是 `dplyr`——一个数据处理的主力工具。你已经遇到了 `dplyr` 的许多函数（`select`、`filter`、`mutate`、`arrange`、`summarize`
    和 `group_by`）。为了了解更多关于这些函数的信息，并了解一些其他有用的函数，我们建议你查看 [STAT545 在线笔记](https://stat545.com/)
    的第 5-9 章，这些笔记是关于使用 R 进行数据处理、探索和分析的书籍。
- en: The [`dplyr` R package documentation](https://dplyr.tidyverse.org/) ([Wickham,
    François, et al. 2021](#ref-dplyr)) is another resource to learn more about the
    functions in this chapter, the full set of arguments you can use, and other related
    functions. The site also provides a very nice cheat sheet that summarizes many
    of the data wrangling functions from this chapter.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dplyr` R 包的文档([Wickham, François, et al. 2021](#ref-dplyr)) 是了解本章中函数、你可以使用的完整参数集以及其他相关函数的另一个资源。该网站还提供了一个非常棒的速查表，总结了本章中的许多数据处理函数。'
- en: Check out the [`tidyselect` R package page](https://tidyselect.r-lib.org/index.html)
    ([Henry and Wickham 2021](#ref-tidyselect)) for a comprehensive list of `select`
    helpers. These helpers can be used to choose columns in a data frame when paired
    with the `select` function (and other functions that use the `tidyselect` syntax,
    such as `pivot_longer`). The [documentation for `select` helpers](https://tidyselect.r-lib.org/reference/select_helpers.html)
    is a useful reference to find the helper you need for your particular problem.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看关于 `tidyselect` R 包的页面([Henry and Wickham 2021](#ref-tidyselect))，以获取 `select`
    辅助函数的完整列表。这些辅助函数可以与 `select` 函数（以及其他使用 `tidyselect` 语法的功能，如 `pivot_longer`）一起使用，以选择数据框中的列。`select`
    辅助函数的文档([https://tidyselect.r-lib.org/reference/select_helpers.html](https://tidyselect.r-lib.org/reference/select_helpers.html))
    是一个有用的参考资料，可以帮助你找到解决特定问题的辅助函数。
- en: '*R for Data Science* ([Wickham and Grolemund 2016](#ref-wickham2016r)) has
    a few chapters related to data wrangling that go into more depth than this book.
    For example, the [tidy data chapter](https://r4ds.had.co.nz/tidy-data.html) covers
    tidy data, `pivot_longer`/`pivot_wider` and `separate`, but also covers missing
    values and additional wrangling functions (like `unite`). The [data transformation
    chapter](https://r4ds.had.co.nz/transform.html) covers `select`, `filter`, `arrange`,
    `mutate`, and `summarize`. And the [`map` functions chapter](https://r4ds.had.co.nz/iteration.html#the-map-functions)
    provides more about the `map` functions.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《R for Data Science》* ([Wickham and Grolemund 2016](#ref-wickham2016r)) 中有几章与数据处理相关，其深度超过了本书的内容。例如，[tidy
    data 章节](https://r4ds.had.co.nz/tidy-data.html)涵盖了 tidy data、`pivot_longer`/`pivot_wider`
    和 `separate`，同时也涵盖了缺失值和额外的数据处理函数（如 `unite`）。[数据转换章节](https://r4ds.had.co.nz/transform.html)涵盖了
    `select`、`filter`、`arrange`、`mutate` 和 `summarize`。而[map 函数章节](https://r4ds.had.co.nz/iteration.html#the-map-functions)提供了关于
    `map` 函数的更多信息。'
- en: You will occasionally encounter a case where you need to iterate over items
    in a data frame, but none of the above functions are flexible enough to do what
    you want. In that case, you may consider using [a for loop](https://r4ds.had.co.nz/iteration.html#iteration).
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有时会遇到需要遍历数据框中项的情况，但上述函数没有一个足够灵活以满足你的需求。在这种情况下，你可能需要考虑使用 [for 循环](https://r4ds.had.co.nz/iteration.html#iteration)。
- en: References
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考文献部分
- en: 'Henry, Lionel, and Hadley Wickham. 2021\. *tidyselect R package*. [https://tidyselect.r-lib.org/](https://tidyselect.r-lib.org/).Wickham,
    Hadley. 2014\. “Tidy Data.” *Journal of Statistical Software* 59 (10): 1–23.———.
    2019\. *Advanced R*. CRC Press. [https://adv-r.hadley.nz/](https://adv-r.hadley.nz/).Wickham,
    Hadley, Romain François, Lionel Henry, and Kirill Müller. 2021\. *dplyr R package*.
    [https://dplyr.tidyverse.org/](https://dplyr.tidyverse.org/).Wickham, Hadley,
    and Garrett Grolemund. 2016\. *R for Data Science: Import, Tidy, Transform, Visualize,
    and Model Data*. O’Reilly. [https://r4ds.had.co.nz/](https://r4ds.had.co.nz/).'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 'Henry, Lionel, 和 Hadley Wickham. 2021\. *tidyselect R 包*. [https://tidyselect.r-lib.org/](https://tidyselect.r-lib.org/).Wickham,
    Hadley. 2014\. “Tidy Data.” *统计软件杂志* 59 (10): 1–23.———. 2019\. *高级 R*. CRC Press.
    [https://adv-r.hadley.nz/](https://adv-r.hadley.nz/).Wickham, Hadley, Romain François,
    Lionel Henry, 和 Kirill Müller. 2021\. *dplyr R 包*. [https://dplyr.tidyverse.org/](https://dplyr.tidyverse.org/).Wickham,
    Hadley 和 Garrett Grolemund. 2016\. *R 语言数据科学：导入、整理、转换、可视化和建模数据*. O’Reilly. [https://r4ds.had.co.nz/](https://r4ds.had.co.nz/).'
