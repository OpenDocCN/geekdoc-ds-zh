- en: Chapter 8 Data Frames
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章 数据框
- en: 原文：[https://randpythonbook.netlify.app/data-frames](https://randpythonbook.netlify.app/data-frames)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://randpythonbook.netlify.app/data-frames](https://randpythonbook.netlify.app/data-frames)
- en: The rectangular array of information (e.g. an Excel spreadsheet ) is what many
    think of when they hear the word “data.” Each column contains elements of a shared
    data type, and these data types can vary from column to column.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们听到“数据”这个词时，很多人会想到信息矩形数组（例如 Excel 工作表）。每一列包含共享数据类型的元素，而这些数据类型可以按列变化。
- en: 'There is a type for this in R and Python: a data frame. It might even be the
    most common way that data is stored in both R and Python programs because many
    functions that read in data from an external source return objects of this type
    (e.g. `read.csv()` in R and `pd.read_csv()` in Python).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 和 Python 中都有这种类型的对应：数据框。这甚至可能是 R 和 Python 程序中存储数据最常见的方式，因为许多从外部源读取数据的函数返回的对象都是这种类型（例如
    R 中的 `read.csv()` 和 Python 中的 `pd.read_csv()`）。
- en: 'R and Python’s data frames have a number of things in common:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: R 和 Python 的数据框有许多共同之处：
- en: each column must be the same length as all other columns,
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每一列的长度必须与其他所有列相同，
- en: each column’s elements will all have the same type,
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每一列的元素都将具有相同的类型。
- en: elements in any rows can have different types,
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何行的元素可以有不同的类型，
- en: columns and rows can be named in different ways,
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列和行可以用不同的方式命名，
- en: there are many ways to get and set different subsets of data, and
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有许多方法可以获取和设置数据的不同子集，并且
- en: when reading in data, the same sorts of difficulties arise in both languages.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在读取数据时，两种语言都会遇到类似的问题。
- en: 8.1 Data Frames in R
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 R 中的数据框
- en: 'Let’s consider as an example Fisher’s “Iris” data set (Fisher [1988](#ref-misc_iris_53))
    hosted by (Dua and Graff [2017](#ref-uci_data)). We will read this data set in
    from a comma separated file (more information on input/output can be found in
    chapter [9](/input-and-output#input-and-output)). This file can be downloaded
    from this link: [https://archive.ics.uci.edu/ml/datasets/iris](https://archive.ics.uci.edu/ml/datasets/iris).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以费舍尔的“鸢尾花”数据集为例（Fisher [1988](#ref-misc_iris_53)），由（Dua 和 Graff [2017](#ref-uci_data)）提供。我们将从这个逗号分隔的文件中读取这个数据集（有关输入/输出的更多信息，请参阅第
    [9](/input-and-output#input-and-output) 章）。此文件可以从以下链接下载：[https://archive.ics.uci.edu/ml/datasets/iris](https://archive.ics.uci.edu/ml/datasets/iris)。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are some exceptions, but most data sets can be stored as a `data.frame`.
    These kinds of two-dimensional data sets are quite common. Any particular row
    is often an observation on one experimental unit (e.g. person, place or thing).
    Looking at a particular column gives you one kind of measurement stored for all
    observations.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一些例外，但大多数数据集都可以存储为 `data.frame`。这类二维数据集相当常见。任何特定的行通常是对一个实验单元（例如人、地点或事物）的观察。查看特定的列会给你一个为所有观察存储的测量值。
- en: Do not rely on the default arguments of `read.csv()` or `read.table()`! After
    you read in a data frame, always check to make sure that
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 不要依赖 `read.csv()` 或 `read.table()` 的默认参数！在读取数据框后，始终检查以确保
- en: the number of columns is correct because the correct column *separator* was
    used (c.f. `sep=`),
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列数是正确的，因为使用了正确的列 *分隔符*（例如 `sep=`），
- en: column names were parsed correctly, if there were some in the raw text file,
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果原始文本文件中有一些列名，则列名被正确解析，
- en: the first row of data wasn’t used as a column name sequence, if there weren’t
    column names in the text file, and
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文本文件中没有列名，数据的第一行没有被用作列名序列，
- en: the last few rows aren’t reading in empty spaces
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后几行没有读取空格
- en: character columns are read in correctly (c.f. `stringsAsFactors=`), and
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符列被正确读取（例如 `stringsAsFactors=`），并且
- en: special characters signifying missing data were correctly identified (c.f. `na.strings=`).
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表示缺失数据的特殊字符被正确识别（例如 `na.strings=`）。
- en: '[A `data.frame` is a special case of a `list`](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Data-frame-objects).
    Every element of the list is a column. Columns can be `vector`s or `factor`s,
    and they can all be of a different type. This is one of the biggest differences
    between data frames and `matrix`s. They are both two-dimensional, but a `matrix`
    needs elements to be all the same type. Unlike a general `list`, a `data.frame`
    requires all of its columns to have the same number of elements. In other words,
    the `data.frame` is not a “*ragged*” list.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[`data.frame`是`list`的特殊情况](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Data-frame-objects)。列表的每个元素都是一列。列可以是`vector`s或`factor`s，并且它们可以具有不同的类型。这是数据框和`matrix`之间最大的区别之一。它们都是二维的，但`matrix`需要所有元素都是同一类型。与一般的`list`不同，`data.frame`要求所有列具有相同数量的元素。换句话说，`data.frame`不是一个“*杂乱*”的列表。'
- en: Often times you will need to extract pieces of information from a `data.frame`.
    This can be done in many ways. If the columns have names, you can use the `$`
    operator to access a single column. Accessing a single column might be followed
    up by creating a new vector. You can also use the `[` operator to access multiple
    columns by name.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你需要从`data.frame`中提取信息片段。这可以通过多种方式完成。如果列有名称，你可以使用`$`运算符来访问单个列。访问单个列之后，可能会创建一个新的向量。你也可以使用`[`运算符通过名称访问多个列。
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `[` operator is also useful for selecting rows and columns by index numbers,
    or by some logical criteria.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`[`运算符也用于通过索引数字或某些逻辑标准选择行和列。'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the code above, `irisData$species == "Iris-setosa"` creates a logical vector
    (try it!) using the vectorized `==` operator. The `[` operator selects the rows
    for which the corresponding element of this logical vector is `TRUE`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，`irisData$species == "Iris-setosa"`使用向量化`==`运算符创建了一个逻辑向量（试试看！）。“[`运算符选择逻辑向量对应元素为`TRUE`的行。
- en: 'Be careful: depending on how you use the square brackets, you can either get
    a `data.frame` or a `vector.` As an example, try both `class(irisData[,1])` and
    `class(irisData[,c(1,2)])`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：根据你如何使用方括号，你可能会得到一个`data.frame`或一个`vector`。例如，尝试`class(irisData[,1])`和`class(irisData[,c(1,2)])`。
- en: In R, `data.frame`s might have row names. You can get and set this character
    `vector` with the `rownames()` function. You can access rows by name using the
    square bracket operator.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，`data.frame`s可能有行名。你可以使用`rownames()`函数获取和设置这个字符`vector`。你可以使用方括号运算符通过名称访问行。
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Code that modifies data usually looks quite similar to code extracting data.
    You’ll notice a lot of the same symbols (e.g. `$`, `[`, etc.), but the (`<-`)
    will point in the other direction.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 修改数据的代码通常看起来与提取数据的代码非常相似。你会注意到很多相同的符号（例如`$`，`[`等），但`(`<-`)`会指向另一个方向。
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 8.2 Data Frames in Python
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 Python中的数据框
- en: The Pandas library in Python has data frames that are modeled after R’s (McKinney
    [2017](#ref-pandas_guy)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的Pandas库中的数据框是模仿R的（McKinney [2017](#ref-pandas_guy)）。
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The structure is very similar to that of R’s data frame. It’s two dimensional,
    and you can [access columns and rows by name or number.](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html)
    Each column is a `Series` object, and each column can have a different `dtype`,
    which is analogous to R’s situation. Again, because the elements need to be the
    same type along columns only, this is a big difference between 2-d Numpy `ndarray`s
    and `DataFrame`s (c.f. R’s `matrix` versus R’s `data.frame`).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 其结构与R的数据框非常相似。它是二维的，你可以通过名称或数字[访问列和行](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html)。每一列都是一个`Series`对象，每一列可以有不同的`dtype`，这与R的情况类似。再次强调，因为元素只需要在列中是同一类型，这是2维Numpy
    `ndarray`s和`DataFrame`s之间的一大区别（参看R的`matrix`与R的`data.frame`）。
- en: Again, do not rely on the default arguments of `pd.read_csv()`! After you read
    in a data set, always check that
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，不要依赖`pd.read_csv()`的默认参数！在读取数据集之后，始终要检查
- en: the number of columns is correct because the correct column *separator* was
    used (c.f. `sep=`),
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列数是正确的，因为使用了正确的列*分隔符*（参看`sep=`），
- en: column names were parsed correctly, if there were some in the raw text file,
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果原始文本文件中有列名，则列名被正确解析，
- en: the first row of data wasn’t used as a column name sequence, if there weren’t
    column names in the text file (c.f. `header=`), and
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文本文件中没有列名，则数据的第一行不会被用作列名序列（参看`header=`），并且
- en: the last few rows aren’t reading in empty spaces
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后几行没有读取空格
- en: character columns are read in correctly (c.f. `dtype=`), and
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符列被正确读取（参看`dtype=`），并且
- en: special characters signifying missing data were correctly identified (c.f. `na.values=`).
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表示缺失数据的特殊字符被正确识别（例如 `na.values=`）。
- en: Square brackets are a little different in Python than they are in R. Just like
    in R, you can access columns by name with square brackets, and you can also access
    rows. Unlike R, though, you don’t have to specify both rows and columns every
    time you use the square brackets.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，方括号的使用与 R 略有不同。就像在 R 中一样，你可以使用方括号通过名称访问列，你也可以访问行。然而，与 R 不同的是，你不需要每次使用方括号时都指定行和列。
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that `iris_data['sepal.length']` returns a `Series` and `iris_data[["sepal.length",
    "sepal.width"]]` returns a Pandas `DataFrame`. This behavior is similar to what
    happened in R. For more details, click [here](https://pandas.pydata.org/pandas-docs/stable/user_guide/dsintro.html#indexing-selection).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`iris_data['sepal.length']` 返回一个 `Series`，而 `iris_data[["sepal.length", "sepal.width"]]`
    返回一个 Pandas `DataFrame`。这种行为与 R 中发生的情况类似。有关更多详细信息，请点击 [这里](https://pandas.pydata.org/pandas-docs/stable/user_guide/dsintro.html#indexing-selection)。
- en: You can select columns and rows by number with the [`.iloc` method](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iloc.html).
    `iloc` is (probably) short for “integer location.”
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 [`.iloc` 方法](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iloc.html)
    通过数字选择列和行。`iloc` 可能代表“整数位置”。
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Selecting columns by anything besides integer number can be done with the [`.loc()`
    method](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html).
    You should generally prefer this method to access columns because accessing things
    by *name* instead of *number* is more readable. Here are some examples.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除了整数编号之外，你可以使用 [`.loc()` 方法](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html)
    来选择列。通常，你应该更喜欢这种方法来访问列，因为通过名称而不是编号访问事物更易于阅读。以下是一些示例。
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice we used a `slice` (i.e. `'sepal.width':'pedal.width'`) to access many
    columns by only referring to the left-most and the right-most. Unlike slicing
    with numbers, [the right end is included](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#slicing-ranges).
    Also note that this does not work with the regular square bracket operator (i.e. `iris_data['sepal.width':'pedal.width']`).
    The second example filters out the rows where the `"species"` column elements
    are equal to `"Iris-setosa"`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用了一个 `slice`（即 `'sepal.width':'pedal.width'`）来通过只引用最左端和最右端来访问多个列。与数字切片不同，[右端是包含在内的](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#slicing-ranges)。此外，请注意，这不能与常规方括号运算符（即
    `iris_data['sepal.width':'pedal.width']`）一起使用。第二个示例过滤掉了 `"species"` 列元素等于 `"Iris-setosa"`
    的行。
- en: Each `DataFrame` in Pandas comes with an `.index` attribute. This is analogous
    to a row name in R, but it’s much more flexible because the index can take on
    a variety of types. This can help us highlight the difference between `.loc` and
    `.iloc`. Recall that `.loc` was *label-based selection.* Labels don’t necessarily
    have to be strings. Consider the following example.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 中的每个 `DataFrame` 都有一个 `.index` 属性。这类似于 R 中的行名，但它更加灵活，因为索引可以采用多种类型。这有助于我们突出
    `.loc` 和 `.iloc` 之间的区别。回想一下，`.loc` 是基于标签的选择。标签不一定是字符串。考虑以下示例。
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`iris_data.loc[0]` selects the `0`th index. The second line reversed the indexes,
    so this is actually the last row. If you want the first row, use `iris_data.iloc[0]`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`iris_data.loc[0]` 选择第 `0` 个索引。第二行反转了索引，所以这实际上是最后一行。如果你想选择第一行，请使用 `iris_data.iloc[0]`。'
- en: Modifying data inside a data frame looks quite similar to extracting data. You’ll
    recognize a lot of the methods mentioned earlier.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据帧内部修改数据看起来与提取数据非常相似。你会认出前面提到的大多数方法。
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can also use the [`.assign()` method](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.assign.html)
    to create a new column. This method does not modify the data frame in place. It
    returns a new `DataFrame` with the additional column.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 [`.assign()` 方法](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.assign.html)
    来创建新列。此方法不会就地修改数据帧。它返回一个新的包含额外列的 `DataFrame`。
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Above we were assigning Numpy arrays to columns of a `DataFrame`. Be careful
    when you’re assigning `Series` objects. You’ll see in the documentation that [“Pandas
    aligns all AXES when setting Series and `DataFrame` from `.loc`, and `.iloc`.”](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#basics).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，我们将 Numpy 数组分配给 `DataFrame` 的列。当你分配 `Series` 对象时要小心。你会在文档中看到，“Pandas 在从
    `.loc` 和 `.iloc` 设置 Series 和 `DataFrame` 时对所有的轴进行对齐。”
- en: 8.3 Exercises
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 练习
- en: 8.3.1 R Questions
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 R 问题
- en: Consider the data set `"original_rt_snippets.txt"` (Socher et al. [2013](#ref-SocherEtAl2013:RNTN)),
    which is hosted by (Dua and Graff [2017](#ref-uci_data)). We will calculate the
    *term frequency-inverse document frequency statistics* (Jones [1972](#ref-Jones72astatistical))
    on this data set, which is a common data transformation technique used in text
    mining and natural language processing. You may use the `stringr` library for
    this question, if you wish.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑数据集 `"original_rt_snippets.txt"`（Socher 等人 [2013](#ref-SocherEtAl2013:RNTN)），由
    (Dua 和 Graff [2017](#ref-uci_data)) 提供。我们将计算这个数据集上的 *词频-逆文档频率统计*（Jones [1972](#ref-Jones72astatistical)），这是文本挖掘和自然语言处理中常用的数据转换技术。如果你愿意，可以使用
    `stringr` 库来回答这个问题。
- en: read in this data set as a `vector` and call it `corpus`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个数据集作为一个 `vector` 读取，并命名为 `corpus`。
- en: 'create a `vector` called `dictionary` that contains the following phrases:
    “charming”,“fantasy”, “hate”, and “boring”.'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下短语的 `vector`，名为 `dictionary`：“charming”，“fantasy”，“hate”，和“boring”。
- en: Construct a `data.frame` with four columns called `bagOfWords` that contains
    the number of appearances of each word in the dictionary. Match the exact phrases.
    For simplicity, don’t worry about the case of letters or using regular expressions
    (c.f. section [3.9](/r-vectors-versus-numpy-arrays-and-pandas-series#an-introduction-to-regular-expressions)).
    Label the columns of this `data.frame` with the phrases you’re searching for.
    Try to write code that is easy to modify if you decide to change the set of phrases
    in your dictionary.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个名为 `bagOfWords` 的 `data.frame`，包含四个列，其中包含字典中每个单词出现的次数。匹配精确短语。为了简单起见，无需担心字母的大小写或使用正则表达式（参看第
    [3.9](/r-vectors-versus-numpy-arrays-and-pandas-series#an-introduction-to-regular-expressions)
    节）。用你正在搜索的短语标记这个 `data.frame` 的列。尽量编写易于修改的代码，以防你决定更改字典中的短语集合。
- en: Create a `data.frame` with four columns called `termFrequency`. Each element
    should correspond with the count from the previous `data.frame`. Instead of the
    count, each element should be \(\log(1 + \text{count})\).
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含四个列的 `data.frame`，名为 `termFrequency`。每个元素应与上一个 `data.frame` 中的计数相对应。而不是计数，每个元素应该是
    \(\log(1 + \text{count})\)。
- en: Create a `vector` of length four called `invDocFrequency`. The inverse document
    frequency formula for any term \(t\) is \(\log([\text{number of documents in corpus}])\)
    minus \(\log([\text{number of documents that contain term } t])\). Make sure the
    names of this vector are the same as the words in the dictionary.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个长度为四的 `vector`，名为 `invDocFrequency`。任何术语 \(t\) 的逆文档频率公式是 \(\log([\text{语料库中的文档数量}])\)
    减去 \(\log([\text{包含术语 } t \text{ 的文档数量}])\)。确保这个 `vector` 的名称与字典中的单词相同。
- en: 'Create a `data.frame` called `tfidf` (short for “term frequency-inverse document
    frequency”). For row/document \(d\), and column/term \(t\), the formula is the
    product: \([\text{term frequency of term } t \text{ and document } d ] \times
    [\text{inverse doc. freq. of term } t]\).'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `tfidf`（代表“词频-逆文档频率”）的 `data.frame`。对于行/文档 \(d\) 和列/术语 \(t\)，公式是乘积：\([\text{术语
    } t \text{ 和文档 } d \text{ 的词频}] \times [\text{术语 } t \text{ 的逆文档频率}]\)。
- en: Extract the elements of `corpus` that have at least one nonzero element in the
    corresponding row of `tfidf`. Call the `vector` `informativeDocuments`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `corpus` 中提取具有 `tfidf` 对应行中至少一个非零元素的元素。将这个 `vector` 呼叫 `informativeDocuments`。
- en: Do you see any documents that were labeled as informative, that do not actually
    contain the words you searched for?
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否看到任何被标记为信息性的文档，但实际上并不包含你搜索的单词？
- en: '`mtcars` is a data set that is built into R, so you don’t need to read it in.
    You can read more about it by typing `?datasets::mtcars`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`mtcars` 是 R 中内置的数据集，因此你不需要读取它。你可以通过输入 `?datasets::mtcars` 来了解更多关于它的信息。'
- en: Create a new `data.frame` called `withoutDisp` that is the same as `mtcars`,
    but has its `disp` column removed.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与 `mtcars` 相同但移除了 `disp` 列的新 `data.frame`，名为 `withoutDisp`。
- en: Create a new column for `withoutDisp` called `coolnessScore`. The formula is
    \(\frac{1}{\text{mpg}} + \text{quarter mile time}\).
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `withoutDisp` 创建一个新列，名为 `coolnessScore`。公式是 \(\frac{1}{\text{mpg}} + \text{四分之一英里时间}\)。
- en: Create a new `data.frame` called `sortedWD` that is equal to `withoutDisp`,
    but sorted in descending order by the coolness score.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sortedWD` 的新 `data.frame`，它与 `withoutDisp` 相同，但按酷炫分数降序排列。
- en: Create a new `data.frame` from `sortedWD` called `specialRows` that keeps only
    rows where \(\text{weight (1000lbs)} + \text{rear axle ratio} < 7\)
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `sortedWD` 创建一个名为 `specialRows` 的新 `data.frame`，只保留满足 `\(\text{重量 (1000磅)}
    + \text{后轴比} < 7\)` 条件的行。
- en: Calculate the percent reduction in number of rows, going from `sortedWD` to
    `specialRows`. Call it `percReduction`. Make sure it is between \(0\) and \(100\).
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算从 `sortedWD` 到 `specialRows` 的行数减少百分比，称为 `percReduction`。确保它在 \(0\) 到 \(100\)
    之间。
- en: This question investigates the [*Zillow Home Value Index (ZHVI)*](https://www.zillow.com/research/data/)
    for single family homes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题调查了**Zillow 房屋价值指数 (ZHVI)**（[https://www.zillow.com/research/data/](https://www.zillow.com/research/data/)）对于单户住宅的情况。
- en: read in `"Zip_zhvi_uc_sfr_tier_0.33_0.67_sm_sa_month.csv"`. Call the `data.frame`
    `homeData`. Remember to be careful with file paths. Also, when looking at the
    data set with a text editor, be sure that “word wrap” is not turned on.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取 `"Zip_zhvi_uc_sfr_tier_0.33_0.67_sm_sa_month.csv"`。将 `data.frame` 命名为 `homeData`。记住要小心文件路径。此外，当使用文本编辑器查看数据集时，请确保“自动换行”未开启。
- en: Extract the rows of `homeData` that correspond with Charlottesville, VA, and
    assign them as a `data.frame` to the variable `cvilleData`
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取与弗吉尼亚州夏洛茨维尔对应的 `homeData` 的行，并将它们作为 `data.frame` 分配给变量 `cvilleData`。
- en: Assign all the unique zip codes to a `character vector` called `cvilleZips`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有唯一的邮政编码分配给一个名为 `cvilleZips` 的 `character vector`。
- en: Extract the columns of `cvilleData` that correspond with home prices, and transpose
    them so that each row of the result corresponds with a different month. Call this
    new `data.frame` `timeSeriesData`. Also, make sure that the column names of this
    new `data.frame` are set equal to the appropriate zip codes.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取 `cvilleData` 中与房屋价格对应的列，并将它们转置，使得结果中的每一行对应不同的月份。将这个新的 `data.frame` 称为 `timeSeriesData`。同时，确保这个新的
    `data.frame` 的列名设置为适当的邮政编码。
- en: Write a function called `getAveMonthlyChange` that takes in a numeric `vector`,
    and returns the average change. Your function should not return an `NA`, so be
    sure to deal with `NA`s appropriately.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为 `getAveMonthlyChange` 的函数，该函数接受一个数值 `vector` 并返回平均变化。你的函数不应返回 `NA`，因此请确保适当地处理
    `NA`。
- en: Calculate the average monthly price change for each zip code. Store your results
    in a `vector` called `aveMonthlyChanges`. Make sure this `vector` has named elements
    so one can extract elements by zip code.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算每个邮政编码的平均月价格变化。将你的结果存储在名为 `aveMonthlyChanges` 的 `vector` 中。确保这个 `vector` 有命名元素，以便可以通过邮政编码提取元素。
- en: 8.3.2 Python Questions
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 Python 问题
- en: This question deals with looking at historical prices of the S&P500 Index. This
    data was downloaded from [https://finance.yahoo.com](https://finance.yahoo.com)
    (“GSPC Data” [2021](#ref-gspc_data)). It contains prices starting from “2007-01-03”
    and going until “2021-10-01”.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题涉及查看 S&P500 指数的历史价格。这些数据是从 [https://finance.yahoo.com](https://finance.yahoo.com)
    下载的（“GSPC 数据” [2021](#ref-gspc_data)）。它包含从 “2007-01-03” 开始到 “2021-10-01” 的价格。
- en: Read in the data file `"gspc.csv"` as a `data.frame` and call the variable `gspc`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以 `data.frame` 的形式读取数据文件 `"gspc.csv"` 并将变量命名为 `gspc`。
- en: Use [`.set_index()`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.set_index.html)
    to change the index of `gspc` to its `"Index"` column. Store the new `DataFrame`
    as `gspc_good_idx`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 [`.set_index()`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.set_index.html)
    将 `gspc` 的索引更改为其 `"Index"` 列。将新的 `DataFrame` 存储为 `gspc_good_idx`。
- en: Recall the formula for *log returns* provided in exercises of chapter [3](/r-vectors-versus-numpy-arrays-and-pandas-series#r-vectors-versus-numpy-arrays-and-pandas-series).
    Add a column to `gspc_good_idx` called `log_returns`. Calculate them from the
    column `GSPC.Adjusted`. Make sure to scale them by \(100\) and put an `np.nan`
    in the first element where you don’t have a return.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回忆一下第 [3](/r-vectors-versus-numpy-arrays-and-pandas-series#r-vectors-versus-numpy-arrays-and-pandas-series)
    章节练习中提供的 *log returns* 公式。在 `gspc_good_idx` 中添加一个名为 `log_returns` 的列。从 `GSPC.Adjusted`
    列计算它们。确保将它们按 \(100\) 缩放，并在没有回报的第一个元素中放置一个 `np.nan`。
- en: Extract all the returns that are available for the year 2021, and store them
    as a `Series` called `this_year_returns`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取 2021 年可用的所有回报，并将它们存储为名为 `this_year_returns` 的 `Series`。
- en: Add a column to `gspc_good_idx` containing the *drawdown* time series. Call
    this column `drawdown`. To calculate drawdown at a given date, subtract that date’s
    price from the running maximum price that is current at that date. Use only adjusted
    close prices for this calculation.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `gspc_good_idx` 中添加一个包含 *drawdown* 时间序列的列。称为 `drawdown`。要计算给定日期的 drawdown，从该日期的价格中减去该日期当前的运行最高价格。此计算仅使用调整后的收盘价。
- en: Add a column to `gspc_good_idx` containing the percent drawdown time series.
    Call this column `perc_drawdown`. Use the previous column, but make this number
    a percent of the corresponding running maximum.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`gspc_good_idx`添加一个包含百分比回撤时间序列的列。将此列命名为`perc_drawdown`。使用上一列，但将此数字作为对应运行最大值的百分比。
- en: What is the maximum drawdown of this time series? Store it as a percent in the
    value `mdd`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个时间序列的最大回撤是多少？将其作为百分比存储在值`mdd`中。
- en: In this question we’ll look at [some data on radon measurements](https://www.tensorflow.org/datasets/catalog/radon)
    (Gelman and Hill [2007](#ref-GelmanHill:2007)). Instead of reading in a text file,
    we will load the data into Python using the [`tensorflow_datasets` module](https://www.tensorflow.org/datasets)
    (“TensorFlow Datasets, a Collection of Ready-to-Use Datasets” [2021](#ref-TFDS)).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们将查看[一些关于氡测量的数据](https://www.tensorflow.org/datasets/catalog/radon)（Gelman
    和 Hill [2007](#ref-GelmanHill:2007)）。我们不会读取文本文件，而是使用`tensorflow_datasets`模块将数据加载到Python中（“TensorFlow
    Datasets，一组可用的数据集” [2021](#ref-TFDS)）。
- en: Please include the following code in your submission.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请在您的提交中包含以下代码。
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Many of you will need to install `tensorflow` and `tensorflow_datasets` before
    you’re able to `import` it. If that’s so, please read section [10.2](/using-third-party-code#installing-packages-in-python)
    for more information on how to install packages.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在您能够导入之前，许多人需要安装`tensorflow`和`tensorflow_datasets`。如果是这样，请阅读第[10.2](/using-third-party-code#installing-packages-in-python)节以获取有关如何安装包的更多信息。
- en: Assign to `worst_row` the row of `d` that is associated the highest recorded
    level of radon. Make sure it a `DataFrame`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将与最高记录的氡水平相关的`d`的行分配给`worst_row`。确保它是一个`DataFrame`。
- en: Assign to `nrows` and `ncols` the number of rows and columns of `d`, respectively.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`nrows`和`ncols`分别分配给`d`的行数和列数。
- en: Assign the most common column data type to `most_common_dtype`. Make sure the
    variable is of type `numpy.dtype`
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将最常见的列数据类型分配给`most_common_dtype`。确保变量是`numpy.dtype`类型
- en: Are there any observations from Virginia in this data set? If so, assign `True`
    to `any_va`. Otherwise assign `False`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个数据集中是否有来自弗吉尼亚的观测数据？如果有，将`any_va`分配为`True`。否则分配为`False`。
- en: Create a new column in `d` called `dist_from_cville`. Use the **Haversine formula**
    to calculate distance between each row and the University of Virginia, in kilometers.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`d`中创建一个名为`dist_from_cville`的新列。使用**哈弗辛公式**计算每行与弗吉尼亚大学的距离，单位为公里。
- en: Assume the University of Virginia is at 38.0336\(^\circ\) N, 78.5080\(^\circ\)W
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设弗吉尼亚大学位于北纬38.0336\(^\circ\)，西经78.5080\(^\circ\)W
- en: Assume the Earth’s radius \(r = 6378.137\) kilometers.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设地球半径 \(r = 6378.137\) 公里。
- en: The formula for distance between \((\lambda_1, \phi_1)\) (signed longitude in
    radians, signed latitude in radians) and \((\lambda_2, \phi_2)\) is\[\begin{equation}
    2 \hspace{1mm} r \hspace{1mm} \text{arcsin}\left( \sqrt{ \sin^2\left( \frac{\phi_2
    - \phi_1}{2}\right) + \cos(\phi_1)\cos(\phi_2) \sin^2\left( \frac{\lambda_2 -
    \lambda_1}{2} \right) } \right) \end{equation}\]
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: \((\lambda_1, \phi_1)\)（以弧度为单位的带符号经度，以弧度为单位的带符号纬度）和\((\lambda_2, \phi_2)\)之间的距离公式是\[\begin{equation}
    2 \hspace{1mm} r \hspace{1mm} \text{arcsin}\left( \sqrt{ \sin^2\left( \frac{\phi_2
    - \phi_1}{2}\right) + \cos(\phi_1)\cos(\phi_2) \sin^2\left( \frac{\lambda_2 -
    \lambda_1}{2} \right) } \right) \end{equation}\]
- en: What is the average radon measurement between all measurements taken at the
    place that is closest to where we are now? Assign your answer as a `float` to
    `close_ave`
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有在离我们现在最近的地方测量的平均氡测量值是多少？将您的答案作为`float`类型的`close_ave`分配。
- en: References
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考文献
- en: Dua, Dheeru, and Casey Graff. 2017\. “UCI Machine Learning Repository.” University
    of California, Irvine, School of Information; Computer Sciences. [http://archive.ics.uci.edu/ml](http://archive.ics.uci.edu/ml).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Dua, Dheeru, 和 Casey Graff. 2017\. “UCI机器学习库.” 加州大学欧文分校，信息学院；计算机科学系。[http://archive.ics.uci.edu/ml](http://archive.ics.uci.edu/ml).
- en: Fisher, Test, R.A. & Creator. 1988\. “Iris.” UCI Machine Learning Repository.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Fisher, Test, R.A. & Creator. 1988\. “Iris.” UCI机器学习库。
- en: Gelman, Andrew, and Jennifer Hill. 2007\. *Data Analysis Using Regression and
    Multilevel/Hierarchical Models*. Analytical Methods for Social Research. Cambridge
    University Press.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Gelman, Andrew, 和 Jennifer Hill. 2007\. *使用回归和多级/分层模型进行数据分析*. 社会研究分析方法. 剑桥大学出版社。
- en: “GSPC Data.” 2021\. [https://finance.yahoo.com/quote/%5EGSPC/history?p=%5EGSPC](https://finance.yahoo.com/quote/%5EGSPC/history?p=%5EGSPC).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: “GSPC数据。” 2021\. [https://finance.yahoo.com/quote/%5EGSPC/history?p=%5EGSPC](https://finance.yahoo.com/quote/%5EGSPC/history?p=%5EGSPC)。
- en: 'Jones, Karen Spärck. 1972\. “A Statistical Interpretation of Term Specificity
    and Its Application in Retrieval.” *Journal of Documentation* 28: 11–21.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 'Jones, Karen Spärck. 1972\. “术语特定性的统计解释及其在检索中的应用.” *文献与信息工作* 28: 11–21.'
- en: 'McKinney, Wes. 2017\. *Python for Data Analysis: Data Wrangling with Pandas,
    Numpy, and Ipython*. 2nd ed. O’Reilly Media, Inc.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: McKinney, Wes. 2017\. *Python数据分析：使用Pandas、Numpy和Ipython进行数据处理*. 2nd ed. O’Reilly
    Media, Inc.
- en: Socher, Richard, Alex Perelygin, Jean Wu, Jason Chuang, Christopher Manning,
    Andrew Ng, and Christopher Potts. 2013\. “Parsing with Compositional Vector Grammars.”
    In *EMNLP*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Socher, Richard, Alex Perelygin, Jean Wu, Jason Chuang, Christopher Manning,
    Andrew Ng, and Christopher Potts. 2013\. “基于组合向量语法的解析.” In *EMNLP*.
- en: “TensorFlow Datasets, a Collection of Ready-to-Use Datasets.” 2021\. [https://www.tensorflow.org/datasets](https://www.tensorflow.org/datasets).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: “TensorFlow数据集，一组可用的数据集.” 2021\. [https://www.tensorflow.org/datasets](https://www.tensorflow.org/datasets).
