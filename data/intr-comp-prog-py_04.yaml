- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: SOME SIMPLE NUMERICAL PROGRAMS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一些简单的数值程序
- en: Now that we have covered some basic Python constructs, it is time to start thinking
    about how we can combine those constructs to write simple programs. Along the
    way, we'll sneak in more language constructs and some algorithmic techniques.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经涵盖了一些基本的 Python 结构，现在是时候开始思考如何将这些结构结合起来编写简单的程序。在这个过程中，我们会悄悄引入更多的语言结构和一些算法技术。
- en: 3.1 Exhaustive Enumeration
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 穷举枚举
- en: The code in [Figure 3-1](#c3-fig-0001) prints the integer cube root, if it exists,
    of an integer. If the input is not a perfect cube, it prints a message to that
    effect. The operator `!=` means not equal.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-1](#c3-fig-0001) 中的代码会打印出一个整数的立方根（如果存在的话）。如果输入不是一个完美的立方，则会打印出相应的消息。操作符
    `!=` 意思是“不等于”。'
- en: '![c3-fig-0001.jpg](../images/c3-fig-0001.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0001.jpg](../images/c3-fig-0001.jpg)'
- en: '[Figure 3-1](#c3-fig-0001a) Using exhaustive enumeration to find the cube root'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-1](#c3-fig-0001) 使用穷举枚举来寻找立方根'
- en: The code first attempts to set the variable `ans` to the cube root of the absolute
    value of `x`. If it succeeds, it then sets `ans` to `-ans` if `x` is negative.
    The heavy lifting (such as it is) in this code is done in the `while` loop. Whenever
    a program contains a loop, it is important to understand what causes the program
    to eventually exit this loop. For what values of `x` will this `while` loop terminate?
    The answer is “all integers.” This can be argued quite simply.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先尝试将变量 `ans` 设置为 `x` 的绝对值的立方根。如果成功了，接着如果 `x` 为负，则将 `ans` 设置为 `-ans`。在这段代码中，重任（虽说也不算重）是在
    `while` 循环中完成的。每当程序包含一个循环时，理解是什么导致程序最终退出这个循环是很重要的。对于什么值的 `x`，这个 `while` 循环会终止？答案是“所有整数”。这一点可以很简单地说明。
- en: The value of the expression `ans**3` starts at `0` and gets larger each time
    through the loop.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式 `ans**3` 的值从 `0` 开始，每次循环时增大。
- en: When it reaches or exceeds `abs(x)`, the loop terminates.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当其值达到或超过 `abs(x)` 时，循环终止。
- en: Since `abs(x)` is always positive, there are only a finite number of iterations
    before the loop must terminate.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 `abs(x)` 始终是正数，因此在循环必须终止之前，只有有限的迭代次数。
- en: 'This argument is based upon the notion of a **decrementing function**. This
    is a function that has the following properties:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个论点基于**递减函数**的概念。这个函数具有以下属性：
- en: It maps a set of program variables into an integer.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将一组程序变量映射到一个整数。
- en: When the loop is entered, its value is nonnegative.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当循环被进入时，它的值是非负的。
- en: When its value is ≤ 0, the loop terminates.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当其值 ≤ 0 时，循环终止。
- en: Its value is decreased every time through the loop.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的值在每次循环时减少。
- en: What is the decrementing function for the `while` loop in [Figure 3-1](#c3-fig-0001)?
    It is `abs(x) ‑ ans**3`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 3-1](#c3-fig-0001) 中，`while` 循环的递减函数是什么？它是 `abs(x) ‑ ans**3`。
- en: Now, let's insert some errors and see what happens. First, try commenting out
    the statement `ans = 0`. The Python interpreter prints the error message
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们插入一些错误，看看会发生什么。首先，尝试注释掉语句 `ans = 0`。Python 解释器将不断打印错误信息。
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: because the interpreter attempts to find the value to which `ans` is bound before
    it has been bound to anything. Now, restore the initialization of `ans`, replace
    the statement `ans = ans + 1` by `ans` `=` `ans`, and try finding the cube root
    of 8\. After you get tired of waiting, enter “control c” (hold down the `Ctrl`
    key and the `c` key simultaneously). This will return you to the user prompt in
    the shell.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因为解释器尝试在 `ans` 被绑定到任何值之前找到它的绑定值。现在，恢复 `ans` 的初始化，将语句 `ans = ans + 1` 替换为 `ans`
    `=` `ans`，并尝试寻找 8 的立方根。当你等得不耐烦时，输入“control c”（同时按住 `Ctrl` 键和 `c` 键）。这将把你带回到 shell
    的用户提示符。
- en: Now, add the statement
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加语句
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: at the start of the loop, and try running it again. This time it will print
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环开始时，再次尝试运行。这次它将打印
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: over and over again.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一遍又一遍地。
- en: The program would have run forever because the loop body is no longer reducing
    the distance between `ans**3` and `abs(x)`. When confronted with a program that
    seems not to be terminating, experienced programmers often insert print statements,
    such as the one here, to test whether the decrementing function is indeed being
    decremented.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会永远运行下去，因为循环体不再缩小 `ans**3` 和 `abs(x)` 之间的距离。当遇到一个似乎没有终止的程序时，经验丰富的程序员常常会插入打印语句，比如这里的语句，以测试递减函数是否确实在递减。
- en: The algorithmic technique used in this program is a variant of **guess-and-check**
    called **exhaustive enumeration**. We enumerate all possibilities until we get
    to the right answer or exhaust the space of possibilities. At first blush, this
    may seem like an incredibly stupid way to solve a problem. Surprisingly, however,
    exhaustive enumeration algorithms are often the most practical way to solve a
    problem. They are typically easy to implement and easy to understand. And, in
    many cases, they run fast enough for all practical purposes. Remove or comment
    out the print statement that you inserted for debugging, and reinsert the statement
    `ans = ans + 1`. Now try finding the cube root of `1957816251`. The program will
    finish almost instantaneously. Now, try `7406961012236344616`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本程序使用的算法技术是**猜测与检查**的一种变体，称为**耗尽枚举**。我们枚举所有可能性，直到找到正确答案或穷尽所有可能性。乍一看，这似乎是解决问题的一个极其愚蠢的方法。然而，令人惊讶的是，耗尽枚举算法往往是解决问题的最实际方法。它们通常易于实现和理解，并且在许多情况下，它们的运行速度足够快以满足所有实际需求。去掉或注释掉你为调试插入的打印语句，并重新插入语句`ans
    = ans + 1`。现在尝试寻找`1957816251`的立方根。程序几乎会瞬间完成。现在试试`7406961012236344616`。
- en: As you can see, even if millions of guesses are required, run time is not usually
    a problem. Modern computers are amazingly fast. It takes less than one nanosecond—one
    billionth of a second—to execute an instruction. It's hard to appreciate how fast
    that is. For perspective, it takes slightly more than a nanosecond for light to
    travel a single foot (0.3 meters). Another way to think about this is that in
    the time it takes for the sound of your voice to travel a 100 feet, a modern computer
    can execute millions of instructions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，即使需要数百万次猜测，运行时间通常也不是问题。现代计算机速度惊人。执行一条指令所需的时间不到一纳秒——十亿分之一秒。很难想象这有多快。为了更好地理解，光在一英尺（0.3米）中传播的时间稍微超过一纳秒。另一种理解方式是，在你声音传播100英尺的时间内，现代计算机可以执行数百万条指令。
- en: Just for fun, try executing the code
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为好玩，尝试执行该代码。
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: See how large an integer you need to enter before there is a perceptible pause
    before the result is printed.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你需要输入多大的整数，才能在结果打印之前感知到延迟。
- en: 'Let''s look at another example of exhaustive enumeration: testing whether an
    integer is a prime number and returning the smallest divisor if it is not. A prime
    number is an integer greater than 1 that is evenly divisible only by itself and
    1\. For example, 2, 3, 5, and 111,119 are primes, and 4, 6, 8 and 62,710,561 are
    not primes.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个耗尽枚举的另一个例子：测试一个整数是否为质数，并在不是时返回最小的因子。质数是大于1的整数，仅能被自身和1整除。例如，2、3、5和111,119是质数，而4、6、8和62,710,561不是质数。
- en: The simplest way to find out if an integer, x, greater than 3 is prime, is to
    divide x by each integer between 2 and, x-1\. If the remainder of any of those
    divisions is 0, x is not prime, otherwise x is prime. The code in [Figure 3-2](#c3-fig-0002)
    implements that approach. It first asks the user to enter an integer, converts
    the returned string to an `int`, and assigns that integer to the variable `x`.
    It then sets up the initial conditions for an exhaustive enumeration by initializing
    `guess` to `2` and the variable `smallest_divisor` to `None`—indicating that until
    proven otherwise, the code assumes that `x` is prime.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 确定一个大于3的整数`x`是否为质数的最简单方法是将`x`除以2到`x-1`之间的每个整数。如果其中任何一个除法的余数为0，则`x`不是质数，否则`x`是质数。[图3-2](#c3-fig-0002)中的代码实现了这种方法。它首先要求用户输入一个整数，将返回的字符串转换为`int`，并将该整数赋值给变量`x`。接着，它通过将`guess`初始化为`2`和将变量`smallest_divisor`初始化为`None`来设置耗尽枚举的初始条件——这表明在未证明的情况下，代码假定`x`为质数。
- en: The exhaustive enumeration is done within a `for` loop. The loop terminates
    when either all possible integer divisors of `x` have been tried or it has discovered
    an integer that is a divisor of `x`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 耗尽枚举是在`for`循环中完成的。当所有可能的`x`的整数因子都已尝试过，或者发现一个`x`的因子时，循环终止。
- en: After exiting the loop, the code checks the value of `smallest_divisor` and
    prints the appropriate text. The trick of initializing a variable before entering
    a loop, and then checking whether that value has been changed upon exit, is a
    common one.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 退出循环后，代码检查`smallest_divisor`的值并打印相应的文本。在进入循环之前初始化变量，然后检查该值在退出时是否已更改是一种常见的技巧。
- en: '![c3-fig-0002.jpg](../images/c3-fig-0002.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0002.jpg](../images/c3-fig-0002.jpg)'
- en: '[Figure 3-2](#c3-fig-0002a) Using exhaustive enumeration to test primality'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-2](#c3-fig-0002a) 使用耗尽枚举测试质性。'
- en: '**Finger exercise:** Change the code in [Figure 3-2](#c3-fig-0002) so that
    it returns the largest rather than the smallest divisor. Hint: if y*z = x and
    y is the smallest divisor of x, z is the largest divisor of x.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习：** 修改[图3-2](#c3-fig-0002)中的代码，使其返回最大而不是最小的除数。提示：如果`y*z = x`且`y`是`x`的最小除数，`z`就是`x`的最大除数。'
- en: The code in [Figure 3-2](#c3-fig-0002) works, but is unnecessarily inefficient.
    For example, there is no need to check even numbers beyond 2, since if an integer
    is divisible by any even number, it is divisible by 2\. The code in [Figure 3-3](#c3-fig-0003)
    takes advantage of this fact by first testing whether `x` is an even number. If
    not, it uses a loop to test whether `x` is divisible by any odd number.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-2](#c3-fig-0002)中的代码能够运行，但效率不必要地低。例如，检查大于2的偶数是没有必要的，因为如果一个整数能被任何偶数整除，那么它必定能被2整除。[图3-3](#c3-fig-0003)中的代码利用了这一点，先测试`x`是否是偶数。如果不是，它会使用循环测试`x`是否能被任何奇数整除。'
- en: While the code in [Figure 3-3](#c3-fig-0003) is slightly more complex than the
    code in [Figure 3-2](#c3-fig-0002), it is considerably faster, since half as many
    numbers are checked within the loop. The opportunity to trade code complexity
    for runtime efficiency is a common phenomenon. But faster does not always mean
    better. There is a lot to be said for simple code that is obviously correct and
    still fast enough to be useful.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管[图3-3](#c3-fig-0003)中的代码比[图3-2](#c3-fig-0002)中的代码稍复杂，但它明显更快，因为在循环中检查的数字减少了一半。将代码复杂性与运行效率进行权衡是一个常见现象。但更快并不总意味着更好。简单的代码明显正确，并且仍然足够快以便有用，值得赞美。
- en: '![c3-fig-0003.jpg](../images/c3-fig-0003.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0003.jpg](../images/c3-fig-0003.jpg)'
- en: '[Figure 3-3](#c3-fig-0003a) A more efficient primality test'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-3](#c3-fig-0003a) 更高效的质数测试'
- en: '**Finger exercise:** Write a program that asks the user to enter an integer
    and prints two integers, `root` and `pwr`, such that `1 < pwr < 6` and `root**pwr`
    is equal to the integer entered by the user. If no such pair of integers exists,
    it should print a message to that effect.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习：** 编写一个程序，要求用户输入一个整数，并打印两个整数`root`和`pwr`，使得`1 < pwr < 6`并且`root**pwr`等于用户输入的整数。如果不存在这样的整数对，应该打印相应的消息。'
- en: '**Finger exercise:** Write a program that prints the sum of the prime numbers
    greater than 2 and less than 1000\. Hint: you probably want to have a loop that
    is a primality test nested inside a loop that iterates over the odd integers between
    3 and 999.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习：** 编写一个程序，打印大于2且小于1000的所有质数的和。提示：你可能想要一个循环，其中包含一个嵌套在循环内的质数测试，迭代3到999之间的奇数。'
- en: 3.2 Approximate Solutions and Bisection Search
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 近似解和二分查找
- en: Imagine that someone asks you to write a program that prints the square root
    of any nonnegative number. What should you do?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，有人要求你编写一个程序，打印任何非负数的平方根。你应该怎么做？
- en: You should probably start by saying that you need a better problem statement.
    For example, what should the program do if asked to find the square root of `2`?
    The square root of `2` is not a rational number. This means that there is no way
    to precisely represent its value as a finite string of digits (or as a `float)`,
    so the problem as initially stated cannot be solved.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能应该先说你需要一个更好的问题陈述。例如，如果被要求找到`2`的平方根，程序应该怎么做？`2`的平方根不是一个有理数。这意味着没有办法精确表示它的值为有限的数字字符串（或作为`float`），所以最初陈述的问题无法解决。
- en: The thing a program can do is find an **approximation** to the square root—i.e.,
    an answer that is close enough to the actual square root to be useful. We will
    return to this issue in considerable detail later in the book. But for now, let's
    think of “close enough” as an answer that lies within some constant, call it `epsilon`,
    of the actual answer.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以做的事情是找到平方根的**近似值**——即，接近实际平方根的答案，以便有用。我们稍后将在书中详细讨论这个问题。但现在，让我们把“足够接近”理解为在实际答案的某个常量范围内，称之为`epsilon`。
- en: The code in [Figure 3-4](#c3-fig-0004) implements an algorithm that prints an
    approximation to the square root of `x`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-4](#c3-fig-0004)中的代码实现了一个打印`x`的平方根近似值的算法。'
- en: '![c3-fig-0004.jpg](../images/c3-fig-0004.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0004.jpg](../images/c3-fig-0004.jpg)'
- en: '[Figure 3-4](#c3-fig-0004a) Approximating the square root using exhaustive
    enumeration'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-4](#c3-fig-0004a) 使用穷举枚举来近似平方根'
- en: Once again, we are using exhaustive enumeration. Notice that this method for
    finding the square root has nothing in common with the way of finding square roots
    using a pencil that you might have learned in middle school. It is often the case
    that the best way to solve a problem with a computer is quite different from how
    one would approach the problem by hand.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用穷举枚举。请注意，这种寻找平方根的方法与您在中学时学到的用铅笔找平方根的方法没有任何共同之处。计算机解决问题的最佳方法通常与手工解决问题的方法大相径庭。
- en: If `x` is 25, the code will print
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`x`是25，代码将打印
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Should we be disappointed that the program didn't figure out that `25` is a
    perfect square and print `5`? No. The program did what it was intended to do.
    Though it would have been OK to print `5`, doing so is no better than printing
    any value close enough to `5`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该失望于程序没有识别出`25`是一个完全平方并打印`5`吗？不。程序做了它应该做的事。虽然打印`5`也可以，但这样做与打印任何接近`5`的值并没有什么不同。
- en: What do you think will happen if we set `x = 0.25`? Will it find a root close
    to `0.5`? Nope. Alas, it will report
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们设定`x = 0.25`，你认为会发生什么？它会找到接近`0.5`的根吗？不。可惜，它会报告
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Exhaustive enumeration is a search technique that works only if the set of values
    being searched includes the answer. In this case, we are enumerating the values
    between `0` and the value of `x`. When `x` is between `0` and `1`, the square
    root of `x` does not lie in this interval. One way to fix this is to change the
    second operand of `and` in the first line of the `while` loop to get
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 穷举枚举是一种搜索技术，只有在被搜索的值集合中包含答案时才有效。在这种情况下，我们在枚举`0`到`x`的值。当`x`在`0`和`1`之间时，`x`的平方根不在这个区间内。解决这个问题的一种方法是改变`while`循环第一行中`and`的第二个操作数，以得到
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When we run our code after this change, it reports that
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这个变化后运行代码时，它报告
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, let's think about how long the program will take to run. The number of
    iterations depends upon how close the answer is to our starting point, 0, and
    on the size of the steps. Roughly speaking, the program will execute the `while`
    loop at most `x/step` times.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们想想程序运行需要多长时间。迭代次数取决于答案与我们起始点0的接近程度，以及步长的大小。粗略来说，程序最多会执行`while`循环`x/step`次。
- en: Let's try the code on something bigger, e.g., `x = 123456`. It will run for
    a quite a while, and then print
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在更大的数上运行代码，例如`x = 123456`。它将运行一段时间，然后打印
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What do you think happened? Surely there is a floating-point number that approximates
    the square root of `123456` to within `0.01`. Why didn't our program find it?
    The problem is that our step size was too large, and the program skipped over
    all the suitable answers. Once again, we are exhaustively searching a space that
    doesn't contain a solution. Try making `step` equal to `epsilon**3` and running
    the program. It will eventually find a suitable answer, but you might not have
    the patience to wait for it to do so.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为发生了什么？肯定有一个浮点数可以将`123456`的平方根近似到`0.01`之内。为什么我们的程序没有找到它？问题在于我们的步长太大，程序跳过了所有合适的答案。我们又一次在一个不包含解的空间中进行穷举搜索。试着将`step`设为`epsilon**3`并运行程序。它最终会找到一个合适的答案，但你可能没有耐心等待它。
- en: Roughly how many guesses will it have to make? The step size will be `0.000001`
    and the square root of `123456` is around `351.36`. This means that the program
    will have to make in the neighborhood of `351,000,000` guesses to find a satisfactory
    answer. We could try to speed it up by starting closer to the answer, but that
    presumes that we know the neighborhood of the answer.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 大概需要多少次猜测？步长将是`0.000001`，`123456`的平方根大约是`351.36`。这意味着程序必须进行大约`351,000,000`次猜测才能找到满意的答案。我们可以通过更接近答案的起始点来加速，但这假设我们知道答案的邻域。
- en: The time has come to look for a different way to attack the problem. We need
    to choose a better algorithm rather than fine-tune the current one. But before
    doing so, let's look at a problem that, at first blush, appears to be completely
    different from root finding.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是寻找不同方法解决问题的时候了。我们需要选择一个更好的算法，而不是微调当前的算法。但在这样做之前，让我们看一个乍一看与根寻找完全不同的问题。
- en: Consider the problem of discovering whether a word starting with a given sequence
    of letters appears in a hard-copy dictionary[^(22)](#c3-fn-0001) of the English
    language. Exhaustive enumeration would, in principle, work. You could begin at
    the first word and examine each word until either you found a word starting with
    the sequence of letters or you ran out of words to examine. If the dictionary
    contained `n` words, it would, on average, take `n/2` probes to find the word.
    If the word were not in the dictionary, it would take `n` probes. Of course, those
    who have had the pleasure of looking a word up in a physical (rather than online)
    dictionary would never proceed in this way.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑发现一个以给定字母序列开头的单词是否出现在英语的纸质字典[^(22)](#c3-fn-0001)中的问题。理论上，穷举枚举是可行的。你可以从第一个单词开始，检查每个单词，直到找到一个以该字母序列开头的单词，或者检查完所有单词。如果字典包含
    `n` 个单词，平均需要 `n/2` 次查询才能找到该单词。如果该单词不在字典中，则需要 `n` 次查询。当然，那些曾经在纸质（而非在线）字典中查找单词的人永远不会以这种方式进行。
- en: Fortunately, the folks who publish hard-copy dictionaries go to the trouble
    of putting the words in lexicographical order. This allows us to open the book
    to a page where we think the word might lie (e.g., near the middle for words starting
    with the letter m). If the sequence of letters lexicographically precedes the
    first word on the page, we know to go backwards. If the sequence of letters follows
    the last word on the page, we know to go forwards. Otherwise, we check whether
    the sequence of letters matches a word on the page.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，出版纸质字典的人会费心将单词按字典顺序排列。这使我们能够打开书本到我们认为该单词可能存在的一页（例如，对于以字母 m 开头的单词，通常是在中间附近）。如果字母序列在页面上第一个单词之前，我们就知道要向后查找。如果字母序列在页面上最后一个单词之后，我们就知道要向前查找。否则，我们检查字母序列是否与页面上的单词匹配。
- en: Now let's take the same idea and apply it to the problem of finding the square
    root of x. Suppose we know that a good approximation to the square root of `x`
    lies somewhere between `0` and `max`. We can exploit the fact that numbers are
    **totally ordered**. That is, for any pair of distinct numbers, `n1` and `n2`,
    either `n1 < n2` or `n1 > n2`. So, we can think of the square root of x as lying
    somewhere on the line
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来把同样的思路应用于寻找 x 的平方根的问题。假设我们知道 `x` 的平方根的一个好近似值位于 `0` 和 `max` 之间。我们可以利用数字是**完全有序**的这一事实。也就是说，对于任何一对不同的数字，`n1`
    和 `n2`，要么 `n1 < n2`，要么 `n1 > n2`。因此，我们可以认为 x 的平方根位于以下线段上
- en: '`0`_________________________________________________________`max`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`0`_________________________________________________________`max`'
- en: and start searching that interval. Since we don't necessarily know where to
    start searching, let's start in the middle.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后开始搜索该区间。由于我们不一定知道从哪里开始搜索，让我们从中间开始。
- en: '`0`__________________________guess__________________________`max`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`0`__________________________guess__________________________`max`'
- en: If that is not the right answer (and it won't be most of the time), ask whether
    it is too big or too small. If it is too big, we know that the answer must lie
    to the left. If it is too small, we know that the answer must lie to the right.
    We then repeat the process on the smaller interval. [Figure 3-5](#c3-fig-0005)
    contains an implementation and test of this algorithm.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这不是正确的答案（大多数时候都不是），请询问它是太大还是太小。如果太大，我们知道答案必须在左侧。如果太小，我们知道答案必须在右侧。然后我们在更小的区间上重复这个过程。[图
    3-5](#c3-fig-0005) 包含了该算法的实现和测试。
- en: '![c3-fig-0005.jpg](../images/c3-fig-0005.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0005.jpg](../images/c3-fig-0005.jpg)'
- en: '[Figure 3-5](#c3-fig-0005a) Using bisection search to approximate square root'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-5](#c3-fig-0005) 使用二分查找来近似平方根'
- en: When run for `x` = 25, it prints
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行 `x` = 25 时，它打印
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that it finds a different answer than our earlier algorithm. That is
    perfectly fine, since it still meets the problem's specification.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，它找到的答案与我们早期的算法不同。这完全没问题，因为它仍然符合问题的规范。
- en: More important, notice that at each iteration of the loop, the size of the space
    to be searched is cut in half. For this reason, the algorithm is called **bisection
    search**. Bisection search is a huge improvement over our earlier algorithm, which
    reduced the search space by only a small amount at each iteration.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，请注意在循环的每次迭代中，要搜索的空间大小减半。因此，该算法被称为**二分查找**。二分查找相比于我们早期的算法有了巨大的改进，后者在每次迭代中仅减少了少量搜索空间。
- en: Let us try `x = 123456` again. This time the program takes only 30 guesses to
    find an acceptable answer. How about `x = 123456789` ? It takes only 45 guesses.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次尝试`x = 123456`。这次程序仅需30次猜测就能找到一个可接受的答案。`x = 123456789`呢？仅需45次猜测。
- en: There is nothing special about using this algorithm to find square roots. For
    example, by changing a couple of `2`'s to `3`'s, we can use it to approximate
    a cube root of a nonnegative number. In Chapter 4, we introduce a language mechanism
    that allows us to generalize this code to find any root.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该算法来寻找平方根并没有什么特别之处。例如，通过将几个`2`改为`3`，我们可以用它来近似一个非负数的立方根。在第4章中，我们将介绍一种语言机制，使我们能够将这段代码推广到寻找任何根。
- en: Bisection search is a widely useful technique for many things other than finding
    roots. For example, the code in [Figure 3-6](#c3-fig-0006) uses bisection search
    to find an approximation to the log base 2 of `x` (i.e., a number, `ans`, such
    that `2**ans` is close to `x`). It is structured exactly like the code used to
    find an approximation to a square root. It first finds an interval containing
    a suitable answer, and then uses bisection search to efficiently explore that
    interval.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 二分搜索是一种广泛适用的技术，除了寻找根以外还可以用于许多其他事情。例如，[图 3-6](#c3-fig-0006)中的代码使用二分搜索来寻找`x`的以2为底的对数的近似值（即，一个数字`ans`，使得`2**ans`接近于`x`）。它的结构与用于寻找平方根近似值的代码完全相同。它首先找到一个包含合适答案的区间，然后使用二分搜索高效地探索该区间。
- en: '![c3-fig-0006.jpg](../images/c3-fig-0006.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0006.jpg](../images/c3-fig-0006.jpg)'
- en: '[Figure 3-6](#c3-fig-0006a) Using bisection search to estimate log base 2'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-6](#c3-fig-0006) 使用二分搜索来估计以2为底的对数'
- en: Bisection search is an example of a **successive approximation** method. Such
    methods work by making a sequence of guesses with the property that each guess
    is closer to a correct answer than the previous guess. We will look at an important
    successive approximation algorithm, Newton's method, later in this chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 二分搜索是**逐次逼近**方法的一个示例。这种方法通过一系列猜测来工作，每个猜测都比前一个猜测更接近正确答案。我们将在本章稍后讨论一个重要的逐次逼近算法，牛顿法。
- en: '**Finger exercise:** What would the code in [Figure 3-5](#c3-fig-0005) do if
    `x = -25`?'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**动手练习：** 如果`x = -25`，那么[图 3-5](#c3-fig-0005)中的代码会做什么？'
- en: '**Finger exercise:** What would have to be changed to make the code in [Figure
    3-5](#c3-fig-0005) work for finding an approximation to the cube root of both
    negative and positive numbers? Hint: think about changing `low` to ensure that
    the answer lies within the region being searched.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**动手练习：** 为了让[图 3-5](#c3-fig-0005)中的代码能够找到负数和正数的立方根近似值，需要做出什么更改？提示：考虑改变`low`以确保答案位于被搜索的区域内。'
- en: '**Finger exercise:** The Empire State Building is 102 stories high. A man wanted
    to know the highest floor from which he could drop an egg without the egg breaking.
    He proposed to drop an egg from the top floor. If it broke, he would go down a
    floor, and try it again. He would do this until the egg did not break. At worst,
    this method requires 102 eggs. Implement a method that at worst uses seven eggs.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**动手练习：** 帝国大厦有102层。一名男子想知道他可以从哪个最高楼层扔鸡蛋而不会破。于是他提出从顶楼扔一个鸡蛋。如果鸡蛋破了，他就下降一层，再试一次。他会一直这样做，直到鸡蛋不破。最坏情况下，这种方法需要102个鸡蛋。实现一种方法，最多只使用七个鸡蛋。'
- en: 3.3 A Few Words about Using Floats
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 关于使用浮点数的几点说明
- en: Most of the time, numbers of type `float` provide a reasonably good approximation
    to real numbers. But “most of the time” is not all of the time, and when they
    don't, it can lead to surprising consequences. For example, try running the code
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，`float`类型的数字能够 reasonably 地近似真实数字。但“在大多数情况下”并不意味着在所有情况下，当它们不准确时，可能会导致意想不到的后果。例如，尝试运行以下代码：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Perhaps you, like most people, find it surprising that it prints,
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 或许你和大多数人一样，发现它打印的结果令人惊讶。
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Why does it get to the `else` clause in the first place?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它首先会进入`else`语句呢？
- en: To understand why this happens, we need to understand how floating-point numbers
    are represented in the computer during a computation. To understand that, we need
    to understand **binary numbers**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么会发生这种情况，我们需要了解在计算过程中浮点数是如何在计算机中表示的。要理解这一点，我们需要了解**二进制数**。
- en: When you first learned about decimal numbers—i.e., numbers base `10`—you learned
    that any decimal number can be represented by a sequence of the digits `0123456789`.
    The rightmost digit is the `10`⁰ place, the next digit towards the left is the
    `10`¹ place, etc. For example, the sequence of decimal digits `302` represents
    `3`*`100` `+ 0`*`10 + 2`*`1`. How many different numbers can be represented by
    a sequence of length `n`? A sequence of length `1` can represent any one of 10
    numbers (`0-9`); a sequence of length 2 can represent 100 different numbers (`0-99`).
    More generally, a sequence of length n can represent `10`^n different numbers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次学习十进制数字——即以 `10` 为底的数字——时，你了解到任何十进制数字可以通过数字 `0123456789` 的序列表示。最右边的数字是
    `10`⁰ 位，向左下一个数字是 `10`¹ 位，等等。例如，十进制数字序列 `302` 表示 `3` * `100` + `0` * `10 + 2` *
    `1`。一个长度为 `n` 的序列可以表示多少不同的数字？长度为 `1` 的序列可以表示 10 个数字（`0-9`）；长度为 2 的序列可以表示 100 个不同的数字（`0-99`）。更一般地，长度为
    n 的序列可以表示 `10`^n 个不同的数字。
- en: Binary numbers—numbers base `2`—work similarly. A binary number is represented
    by a sequence of digits each of which is either `0` or `1`. These digits are often
    called **bits**. The rightmost digit is the `2`⁰place, the next digit towards
    the left is the `2`¹ place, etc. For example, the sequence of binary digits `101`
    represents `1`*`4 + 0`*`2 + 1`*`1 = 5`. How many different numbers can be represented
    by a sequence of length n? `2`^n.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数字——以 `2` 为底的数字——工作原理类似。一个二进制数字由一系列数字表示，每个数字要么是 `0` 要么是 `1`。这些数字通常称为**位**。最右边的数字是
    `2`⁰ 位，向左下一个数字是 `2`¹ 位，等等。例如，二进制数字序列 `101` 表示 `1` * `4 + 0` * `2 + 1` * `1 = 5`。一个长度为
    n 的序列可以表示多少不同的数字？ `2`^n。
- en: '**Finger exercise:** What is the decimal equivalent of the binary number `10011`?'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**手指练习：** 二进制数 `10011` 的十进制等值是多少？'
- en: Perhaps because most people have ten fingers, we like to use decimals to represent
    numbers. On the other hand, all modern computer systems represent numbers in binary.
    This is not because computers are born with two fingers. It is because it is easy
    to build hardware **switches**, i.e., devices that can be in only one of two states,
    on or off. That computers use a binary representation and people a decimal representation
    can lead to occasional cognitive dissonance.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 也许因为大多数人有十根手指，我们喜欢用十进制表示数字。另一方面，所有现代计算机系统都是用二进制表示数字。这并不是因为计算机天生只有两根手指，而是因为构建只能处于开或关两种状态的硬件**开关**很简单。计算机使用二进制表示法而人类使用十进制表示法可能会导致偶尔的认知失调。
- en: In modern programming languages non-integer numbers are implemented using a
    representation called **floating point**. For the moment, let's pretend that the
    internal representation is in decimal. We would represent a number as a pair of
    integers—the **significant digits** of the number and an **exponent**. For example,
    the number `1.949` would be represented as the pair `(1949, -3)`, which stands
    for the product `1949`*`10`^(-3).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代编程语言中，非整数数字使用一种称为**浮点**的表示法实现。暂时假设内部表示是十进制。我们可以将数字表示为一对整数——数字的**有效数字**和一个**指数**。例如，数字
    `1.949` 可以表示为一对 `(1949, -3)`，这表示 `1949` * `10`^(-3) 的乘积。
- en: The number of significant digits determines the **precision** with which numbers
    can be represented. If, for example, there were only two significant digits, the
    number `1.949` could not be represented exactly. It would have to be converted
    to some approximation of `1.949`, in this case `1.9`. That approximation is called
    the **rounded value**.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有效数字的数量决定了数字的**精度**。例如，如果只有两个有效数字，数字 `1.949` 将无法精确表示。它必须被转换为某种近似值，在这种情况下是 `1.9`。这种近似值称为**舍入值**。
- en: Modern computers use binary, not decimal, representations. They represent the
    significant digits and exponents in binary rather than decimal, and raise `2`
    rather than `10` to the exponent. For example, the number represented by the decimal
    digits `0.625` (`5/8`) would be represented as the pair `(101, -11)`; `b`ecause
    `101` is the binary representation of the number 5 and -`11` is the binary representation
    of -3, the pair `(101, -11)` stands for `5`*`2`^(-3) `= 5/8 = 0.625`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算机使用二进制而不是十进制表示法。它们以二进制而不是十进制表示有效数字和指数，并将 `2` 而不是 `10` 提升到指数。例如，十进制数字 `0.625`（`5/8`）表示为一对
    `(101, -11)`；因为 `101` 是数字 5 的二进制表示，`-11` 是 -3 的二进制表示，所以一对 `(101, -11)` 表示 `5`
    * `2`^(-3) = 5/8 = 0.625。
- en: What about the decimal fraction `1/10`, which we write in Python as `0.1`? The
    best we can do with four significant binary digits is `(0011, -101)`. This is
    equivalent to `3/32`, i.e., `0.09375`. If we had five significant binary digits,
    we would represent `0.1` as `(11001, -1000)`, which is equivalent to `25/256`,
    i.e., `0.09765625`. How many significant digits would we need to get an exact
    floating-point representation of `0.1`? An infinite number of digits! There do
    not exist integers `sig` and `exp` such that `sig` * `2`^(-exp) equals `0.1`.
    So, no matter how many bits Python (or any other language) uses to represent floating-point
    numbers, it can represent only an approximation to `0.1`. In most Python implementations,
    there are `53` bits of precision available for floating-point numbers, so the
    significant digits stored for the decimal number `0.1` will be
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 那么十进制分数`1/10`，我们在Python中写作`0.1`，最佳的四个有效二进制数字是`(0011, -101)`。这相当于`3/32`，即`0.09375`。如果我们有五个有效二进制数字，我们将`0.1`表示为`(11001,
    -1000)`，这相当于`25/256`，即`0.09765625`。我们需要多少个有效数字才能准确表示`0.1`的浮点数？无限多个数字！不存在整数`sig`和`exp`使得`sig`
    * `2^(-exp)`等于`0.1`。因此，无论Python（或任何其他语言）使用多少位来表示浮点数，它只能表示对`0.1`的近似。在大多数Python实现中，浮点数可用`53`位精度，因此存储的十进制数`0.1`的有效数字将是。
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is equivalent to the decimal number
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于十进制数。
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Pretty close to `1/10`, but not exactly `1/10`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 非常接近`1/10`，但并不完全是`1/10`。
- en: Returning to the original mystery, why does
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 回到最初的谜题，为什么。
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: print
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 打印。
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '``We now see that the test `x == 1.0` produces the result `False` because the
    value to which `x` is bound is not exactly `1.0`. This explains why the `else`
    clause was executed. But why did it decide that `x` was less than 1.0 when the
    floating-point representation of 0.1 is slightly greater than 0.1? Because during
    some iteration of the loop, Python ran out of significant digits and did some
    rounding, which happened to be downwards. What gets printed if we add to the end
    of the `else` clause the code `print x == 10.0*0.1`? It prints `False`. It''s
    not what our elementary school teachers taught us, but adding `0.1` ten times
    does not produce the same value as multiplying `0.1` by `10`.    By the way, if
    you want to explicitly round a floating-point number, use the `round` function.
    The expression `round(x, num_digits)` returns the floating-point number equivalent
    to rounding the value of `x` to `num_digits` digits following the decimal point.
    For example, print `round(2**0.5, 3)` will print `1.414` as an approximation to
    the square root of 2.    Does the difference between real and floating-point numbers
    really matter? Most of the time, mercifully, it does not. There are few situations
    where the difference between `0.9999999999999999`, `1.0`, and `1.00000000000000001`
    matter. However, one thing that is almost always worth worrying about is tests
    for equality. As we have seen, using `==` to compare two floating-point values
    can produce a surprising result. It is almost always more appropriate to ask whether
    two floating point values are close enough to each other, not whether they are
    identical. So, for example, it is better to write `abs(x‑y) < 0.0001` rather than
    `x == y`.    Another thing to worry about is the accumulation of rounding errors.
    Most of the time things work out okay, because sometimes the number stored in
    the computer is a little bigger than intended, and sometimes it is a little smaller
    than intended. However, in some programs, the errors will all be in the same direction
    and accumulate over time.``  ``## 3.4 Newton–Raphson[^(23)](#c3-fn-0002)    The
    most commonly used approximation algorithm is usually attributed to Isaac Newton.
    It is typically called Newton''s method, but is sometimes referred to as the **Newton–Raphson**
    method.[^(24)](#c3-fn-0003) It can be used to find the real roots of many functions,
    but we will look at it only in the context of finding the real roots of a polynomial
    with one variable. The generalization to polynomials with multiple variables is
    straightforward both mathematically and algorithmically.    A **polynomial** with
    one variable (by convention, we write the variable as `*x*`) is either 0 or the
    sum of a finite number of nonzero terms, e.g., `3*x*² + 2*x* + 3`. Each term,
    e.g., `3*x*²`, consists of a constant (the **coefficient** of the term, `3` in
    this case) multiplied by the variable (`*x*` in this case) raised to a nonnegative
    integer exponent (`2` in this case). The exponent in a term is called the **degree**
    of that term. The degree of a polynomial is the largest degree of any single term.
    Some examples are `3` (degree `0`), `2.5*x* + 12` (degree `1`), and `3*x*²` (degree 2).    If
    `*p*` is a polynomial and `*r*` a real number, we will write `*p*(*r*)` to stand
    for the value of the polynomial when `*x* = *r*`. A **root** of the polynomial
    `*p*` is a solution to the equation `*p* = 0`, i.e., an `*r*` such that `*p*(*r*)
    = 0`. So, for example, the problem of finding an approximation to the square root
    of `24` can be formulated as finding an *x* such that `*x*² − 24` is close to
    `0`.    Newton proved a theorem that implies that if a value, call it `*guess*`,
    is an approximation to a root of a polynomial, then `*guess* − 𝑝(*guess*)/𝑝’(*guess*)`,
    where `*p*’` is the first derivative of `*p*`, is a better approximation than
    `*guess*`.    The first derivative of a function `*f*(*x*)` can be thought of
    as expressing how the value of `*f*(*x*)` changes with respect to changes in `*x*`.
    For example, the first derivative of a constant is 0, because the value of a constant
    doesn''t change. For any term `*c***x^p*`, the first derivative of that term is
    `*c***p***x^p*^(−1)`. So, the first derivative of a polynomial of the form  ![c3-fig-5001.jpg](../images/c3-fig-5001.jpg)      is  ![c3-fig-5002.jpg](../images/c3-fig-5002.jpg)      To
    find the square root of a number, say *k*, we need to find a value *x* such that
    `*x*² − *k* = 0`. The first derivative of this polynomial is simply `2*x*`. Therefore,
    we know that we can improve on the current guess by choosing as our next guess
    `*guess* − (*guess*2 − 𝑘)/2 * *guess*`. [Figure 3-7](#c3-fig-0009) contains code
    illustrating how to use this method to quickly find an approximation to the square
    root.  ![c3-fig-0007.jpg](../images/c3-fig-0007.jpg)    [Figure 3-7](#c3-fig-0009a) Implementation
    of Newton–Raphson method      **Finger exercise:** Add some code to the implementation
    of Newton–Raphson that keeps track of the number of iterations used to find the
    root. Use that code as part of a program that compares the efficiency of Newton–Raphson
    and bisection search. (You should discover that Newton–Raphson is far more efficient.)    ##
    3.5 Terms Introduced in Chapter    *   decrementing function *   guess-and-check
    *   exhaustive enumeration *   approximation *   total ordering *   bisection
    search *   successive approximation *   binary numbers *   bit *   switch *   floating
    point *   significant digits *   exponent *   precision *   rounding *   Newton–Raphson
    *   polynomial *   coefficient *   degree *   root``'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '``我们现在看到测试`x == 1.0`的结果为`False`，因为`x`绑定的值并不完全等于`1.0`。这解释了为什么执行了`else`分支。但为什么在`0.1`的浮点表示稍大于`0.1`时，系统却认为`x`小于`1.0`？因为在循环的某次迭代中，Python的有效数字用完了，进行了向下的四舍五入。如果我们在`else`分支末尾添加代码`print
    x == 10.0*0.1`，会打印出`False`。这与我们小学老师教的不同，但十次加`0.1`的结果并不等于将`0.1`乘以`10`。顺便说一下，如果你想明确地对浮点数进行四舍五入，使用`round`函数。表达式`round(x,
    num_digits)`返回将`x`的值四舍五入到小数点后`num_digits`位的浮点数。例如，打印`round(2**0.5, 3)`会打印`1.414`，作为`2`的平方根的近似值。    实际数与浮点数之间的差异真的重要吗？大多数情况下，谢天谢地，它并不重要。`0.9999999999999999`、`1.0`和`1.00000000000000001`之间的差异几乎没有影响。然而，有一件事几乎总是值得担心，那就是等式测试。正如我们所见，使用`==`比较两个浮点值可能会产生令人惊讶的结果。询问两个浮点值是否足够接近，几乎总是比询问它们是否相同更合适。因此，例如，写`abs(x‑y)
    < 0.0001`要比`x == y`更好。    另一个需要担心的问题是舍入误差的积累。大多数时候事情运转良好，因为有时存储在计算机中的数字比预期稍大，有时则稍小。然而，在某些程序中，误差会朝同一方向累积。``  ``##
    3.4 牛顿–拉弗森方法[^(23)](#c3-fn-0002)    最常用的近似算法通常归因于艾萨克·牛顿。通常称为牛顿法，有时也称为**牛顿–拉弗森**方法。[^(24)](#c3-fn-0003)
    它可以用于找到许多函数的实根，但我们只在寻找单变量多项式的实根的背景下讨论它。推广到多个变量的多项式在数学和算法上都是直接的。    一个**多项式**（按照约定，我们将变量写为`*x*`）要么是0，要么是有限个非零项的和，例如`3*x*²
    + 2*x* + 3`。每一项，例如`3*x*²`，由一个常数（这一项的**系数**，在本例中为`3`）乘以变量（在本例中为`*x*`），后者的指数为非负整数（在本例中为`2`）。项的指数称为该项的**次数**。多项式的次数是任何单一项的最大次数。一些例子是`3`（次数为`0`）、`2.5*x*
    + 12`（次数为`1`）和`3*x*²`（次数为`2`）。    如果`*p*`是一个多项式，`*r*`是一个实数，我们将写`*p*(*r*)`表示多项式在`*x*
    = *r*`时的值。多项式`*p*`的一个**根**是方程`*p* = 0`的解，即使得`*p*(*r*) = 0`的`*r*`。例如，寻找`24`的平方根的近似值的问题可以表述为寻找一个`*x*`，使得`*x*²
    − 24`接近于`0`。    牛顿证明了一个定理，意味着如果一个值，称为`*guess*`，是多项式的根的近似值，那么`*guess* − 𝑝(*guess*)/𝑝’(*guess*)`（其中`*p*’`是`*p*`的一阶导数）是比`*guess*`更好的近似值。    一个函数`*f*(*x*)`的一阶导数可以理解为表达`*f*(*x*)`的值相对于`*x*`的变化。例如，一个常数的一阶导数是`0`，因为常数的值不变。对于任何项`*c***x^p*`，该项的一阶导数是`*c***p***x^p*^(−1)`。因此，形式为
    ![c3-fig-5001.jpg](../images/c3-fig-5001.jpg) 的多项式的一阶导数是 ![c3-fig-5002.jpg](../images/c3-fig-5002.jpg)
    为了找到一个数字的平方根，例如*k*，我们需要找到一个值*x*，使得`*x*² − *k* = 0`。这个多项式的一阶导数就是`2*x*`。因此，我们知道可以通过选择下一个猜测为`*guess*
    − (*guess*² − 𝑘)/2 * *guess*`来改进当前猜测。[图3-7](#c3-fig-0009)包含代码，展示如何使用该方法快速找到平方根的近似值。  ![c3-fig-0007.jpg](../images/c3-fig-0007.jpg)    [图3-7](#c3-fig-0009a) 牛顿–拉弗森方法的实现      **指尖练习：**在牛顿–拉弗森的实现中添加一些代码，以跟踪找到根所用的迭代次数。将该代码作为一个程序的一部分，比较牛顿–拉弗森法与二分搜索的效率。（你会发现牛顿–拉弗森法更高效。）    ##
    3.5 本章引入的术语    *   递减函数 *   猜测与检查 *   穷举枚举 *   近似 *   全序 *   二分搜索 *   逐次近似 *   二进制数
    *   位 *   开关 *   浮点数 *   有效数字 *   指数 *   精度 *   舍入 *   牛顿–拉弗森 *   多项式 *   系数 *   次数
    *   根```'
