- en: Integer Numbers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数数
- en: 原文：[https://en.algorithmica.org/hpc/arithmetic/integer/](https://en.algorithmica.org/hpc/arithmetic/integer/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/arithmetic/integer/](https://en.algorithmica.org/hpc/arithmetic/integer/)
- en: 'If you are reading this chapter sequentially from the beginning, you might
    be wondering: why would I introduce integer arithmetic after floating-point one?
    Isn’t it supposed to be easier?'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是从头开始顺序阅读这一章，你可能想知道：为什么在介绍浮点数之后要介绍整数算术？难道它不是应该更容易吗？
- en: 'True: plain integer representations are simpler. But, counterintuitively, their
    simplicity allows for more possibilities for operations to be expressed in terms
    of others. And if floating-point representations are so unwieldy that most of
    their operations are implemented in hardware, efficiently manipulating integers
    requires much more creative use of the instruction set.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 真的：纯整数表示更简单。但出人意料的是，它们的简单性使得可以用其他方式表达操作的可能性更多。而且，如果浮点数表示法如此难以处理，以至于大多数操作都在硬件中实现，那么高效地操作整数就需要更富有创造性的指令集使用。
- en: '## [#](https://en.algorithmica.org/hpc/arithmetic/integer/#binary-formats)Binary
    Formats'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '## [#](https://en.algorithmica.org/hpc/arithmetic/integer/#binary-formats)二进制格式'
- en: '*Unsigned integers* are just natural numbers written in binary:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*无符号整数*只是用二进制表示的自然数：'
- en: $$ \begin{aligned} 5_{10} &= 101_2 = 4 + 1 \\ 42_{10} &= 101010_2 = 32 + 8 +
    2 \\ 256_{10} &= 100000000_2 = 2^8 \end{aligned} $$
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: $$ \begin{aligned} 5_{10} &= 101_2 = 4 + 1 \\ 42_{10} &= 101010_2 = 32 + 8 +
    2 \\ 256_{10} &= 100000000_2 = 2^8 \end{aligned} $$
- en: When the result of an operation can’t fit into the word size (e.g., is more
    or equal to $2^{32}$ for 32-bit unsigned integers), it *overflows* by leaving
    only the lowest 32 bits of the result. Similarly, if the result is a negative
    value, it *underflows* by adding it to $2^{32}$, so that it always stays in the
    $[0, 2^{32})$ range.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个操作的结果无法适应字大小（例如，对于32位无符号整数，结果大于或等于 $2^{32}$）时，它将只保留结果的最低32位，从而发生*溢出*。同样，如果结果是负值，它将通过加
    $2^{32}$ 来*下溢*，这样它始终保持在 $[0, 2^{32})$ 范围内。
- en: 'This is equivalent to performing all operations modulo a power of two:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于对所有操作执行模2的幂次运算：
- en: $$ \begin{aligned} 256 &\equiv 0 \pmod {2^8} \\ 2021 &\equiv 229 \pmod {2^8}
    \\ -42 \equiv 256 - 42 &\equiv 214 \pmod {2^8} \end{aligned} $$
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: $$ \begin{aligned} 256 &\equiv 0 \pmod {2^8} \\ 2021 &\equiv 229 \pmod {2^8}
    \\ -42 &\equiv 256 - 42 &\equiv 214 \pmod {2^8} \end{aligned} $$
- en: In either case, it raises a special flag which you can check, but usually when
    people explicitly use unsigned integers, they are expecting this behavior.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，它都会触发一个特殊的标志，你可以检查它，但通常当人们明确使用无符号整数时，他们期望这种行为。
- en: '### [#](https://en.algorithmica.org/hpc/arithmetic/integer/#signed-integers)Signed
    Integers'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/arithmetic/integer/#signed-integers)有符号整数'
- en: '*Signed integers* support storing negative values by dedicating the highest
    bit to represent the sign of the number, in a similar fashion as floating-point
    numbers do. This halves the range of representable non-negative numbers: the maximum
    possible 32-bit integer is now $(2^{31}-1)$ and not $(2^{32}-1)$. But the encoding
    of negative values is not quite the same as for floating-point numbers.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*有符号整数*支持通过将最高位用于表示数字的符号来存储负值，这与浮点数类似。这减半了可表示的非负数的范围：现在可能的32位整数的最大值是 $(2^{31}-1)$，而不是
    $(2^{32}-1)$。但负值的编码与浮点数并不完全相同。'
- en: 'Computer engineers are even lazier than programmers — and this is not only
    motivated by the instinctive desire for simplification, but also by saving transistor
    space. This can be achieved by reusing circuitry that you already have for other
    operations, which is what they aimed for when designing the signed integer format:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机工程师甚至比程序员还懒惰——这不仅仅是由简化本能欲望所驱动，也是为了节省晶体管空间。这可以通过重用电路来实现，这些电路已经用于其他操作，这就是他们设计有符号整数格式时所追求的目标：
- en: For an $n$-bit signed integer type, the encodings of all numbers in the $[0,
    2^{n-1})$ range remain the same as their unsigned binary representations.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一个 $n$-位的带符号整数类型，$[0, 2^{n-1})$ 范围内所有数字的编码与它们的无符号二进制表示相同。
- en: All numbers in the $[-2^{n-1}, 0)$ range are encoded sequentially right after
    the “positive” range — that is, starting with $(-2^{n - 1})$ that has code $(2^{n-1})$
    and ending with $(-1)$ that has code $(2^n - 1)$.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: $[-2^{n-1}, 0)$ 范围内的所有数字都按顺序编码在“正数”范围之后——也就是说，从代码为 $(2^{n-1})$ 的 $(-2^{n - 1})$
    开始，到代码为 $(2^n - 1)$ 的 $(-1)$ 结束。
- en: 'One way to look at this is that all negative numbers are just encoded as if
    they were subtracted from $2^n$ — an operation known as *two’s complement*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一种看待这个问题的方式是，所有负数都编码为从 $2^n$ 中减去——这是一种称为*二进制补码*的操作：
- en: $$ \begin{aligned} -x &= 2^{32} - x \\ &= \bar{x} + 1 \end{aligned} $$
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: $$ \begin{aligned} -x &= 2^{32} - x \\ &= \bar{x} + 1 \end{aligned} $$
- en: Here $\bar{x}$ represents bitwise negation, which can be also thought of as
    subtracting $x$ from $(2^n - 1)$.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 $\bar{x}$ 代表位取反，也可以理解为从 $(2^n - 1)$ 中减去 $x$。
- en: 'As an exercise, here are some facts about signed integers:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，以下是一些关于有符号整数的知识点：
- en: All positive numbers and zero remain the same as their binary notation.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有正数和零都保持与它们的二进制表示相同。
- en: All negative numbers have the highest bit set to one.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有负数都将最高位设置为 1。
- en: There are more negative numbers than positive numbers (exactly by one — because
    of zero).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负数的数量比正数的数量多（正好多一个——因为零）。
- en: For `int`, if you add $1$ to $(2^{31}-1)$, the result will be $-2^{31}$, represented
    as `10000000` (for exposition purposes, we will only write 8 bits instead of 32).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `int`，如果你将 $1$ 加到 $(2^{31}-1)$ 上，结果将是 $-2^{31}$，表示为 `10000000`（为了说明目的，我们只写
    8 位而不是 32 位）。
- en: Knowing a binary notation of a positive number `x`, you can get the binary notation
    of `-x` as `~x + 1`.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道一个正数 `x` 的二进制表示，你可以得到 `-x` 的二进制表示为 `~x + 1`。
- en: '`-1` is represented as `~1 + 1 = 11111110 + 00000001 = 11111111`.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-1` 表示为 `~1 + 1 = 11111110 + 00000001 = 11111111`。'
- en: '`-42` is represented as `~42 + 1 = 11010101 + 00000001 = 11010110`.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-42` 表示为 `~42 + 1 = 11010101 + 00000001 = 11010110`。'
- en: The number `-1 = 11111111` is followed by `0 = -1 + 1 = 11111111 + 00000001
    = 00000000`.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字 `-1 = 11111111` 后面跟着 `0 = -1 + 1 = 11111111 + 00000001 = 00000000`。
- en: The main advantage of this encoding is that you don’t have to do anything to
    convert unsigned integers to signed ones (except maybe check for overflow), and
    you can reuse the same circuitry for most operations, possibly only flipping the
    sign bit for comparisons and such.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编码的主要优势是，你不需要做任何事情就可以将无符号整数转换为有符号整数（也许需要检查溢出），并且你可以为大多数操作重用相同的电路，可能只需要翻转符号位来进行比较等操作。
- en: 'That said, you need to be careful with signed integer overflows. Even though
    they almost always overflow the same way as unsigned integers, programming languages
    usually consider the possibility of overflow as undefined behavior. If you need
    to overflow integer variables, convert them to unsigned integers: it’s free anyway.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，你需要小心处理有符号整数的溢出。尽管它们几乎总是以与无符号整数相同的方式溢出，但编程语言通常将溢出视为未定义行为。如果你需要溢出整数变量，将它们转换为无符号整数：反正也是免费的。
- en: '**Exercise.** What is the only integer value for which `std::abs` produces
    a wrong result? What will this result be?'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**。哪个整数值是 `std::abs` 产生错误结果的唯一值？这个结果会是什么？'
- en: '### [#](https://en.algorithmica.org/hpc/arithmetic/integer/#integer-types)Integer
    Types'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/arithmetic/integer/#integer-types)
    整数类型'
- en: Integers come in different sizes, but all function roughly the same.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 整数有不同的尺寸，但它们的功能大致相同。
- en: '| Bits | Bytes | Signed C type | Unsigned C type | Assembly |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 比特 | 字节 | 有符号 C 类型 | 无符号 C 类型 | 汇编 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 8 | 1 | `signed char`^([1](#fn:1)) | `unsigned char` | `byte` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 1 | `signed char`^([1](#fn:1)) | `unsigned char` | `byte` |'
- en: '| 16 | 2 | `short` | `unsigned short` | `word` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 2 | `short` | `unsigned short` | `word` |'
- en: '| 32 | 4 | `int` | `unsigned int` | `dword` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 32 | 4 | `int` | `unsigned int` | `dword` |'
- en: '| 64 | 8 | `long long` | `unsigned long long` | `qword` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 64 | 8 | `long long` | `unsigned long long` | `qword` |'
- en: 'The bits of an integer are simply stored sequentially. The only ambiguity here
    is the order in which to store them — left to right or right to left — called
    *endianness*. Depending on the architecture, the format can be either:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 整数的比特位是简单地按顺序存储的。这里的唯一歧义是存储它们的顺序——从左到右或从右到左——称为*字节序*。根据架构的不同，格式可以是以下两种之一：
- en: '*Little-endian*, which lists *lower* bits first. For example, $42_{10}$ will
    be stored as $010101$.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*小端序*，它首先列出*低*位。例如，$42_{10}$ 将存储为 $010101$。'
- en: '*Big-endian*, which lists *higher* bits first. All previous examples in this
    article follow it.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*大端序*，它首先列出*高*位。本文中的所有先前的例子都遵循它。'
- en: 'This seems like an important architecture aspect, but in most cases, it doesn’t
    make a difference: just pick one style and stick with it. But in some cases it
    does:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是一个重要的架构方面，但在大多数情况下，它并没有什么区别：只需选择一种风格并坚持下去。但在某些情况下，它确实有影响：
- en: Little-endian has the advantage that you can cast a value to a smaller type
    (e.g., `long long` to `int`) by just loading fewer bytes, which in most cases
    means doing nothing — thanks to *register aliasing*, `eax` refers to the first
    4 bytes of `rax`, so conversion is essentially free. It is also easier to read
    values in a variety of type sizes — while on big-endian architectures, loading
    an `int` from a `long long` array would require shifting the pointer by 2 bytes.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小端序的优点在于，你可以通过只加载更少的字节来将一个值转换为更小的类型（例如，将`long long`转换为`int`），在大多数情况下这意味着什么都不做——多亏了*寄存器别名*，`eax`指向`rax`的第一个4字节，因此转换基本上是免费的。这也更容易读取各种类型大小的值——而在大端序架构上，从一个`long
    long`数组中加载`int`需要将指针移位2字节。
- en: Big-endian has the advantage that higher bytes are loaded first, which in theory
    can make highest-to-lowest routines such as comparisons and printing faster. You
    can also perform certain checks such as finding out whether a number is negative
    by only loading its first byte.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大端序的优点在于，首先加载高字节，这在理论上可以使最高到最低的例程（如比较和打印）更快。你也可以只加载其第一个字节来执行某些检查，例如找出一个数是否为负。
- en: Big-endian is also more “natural” — this is how we write binary numbers on paper
    — but the advantage of having faster type conversions outweights it. For this
    reason, little-endian is used by default on most hardware, although some CPUs
    are “bi-endian” and can be configured to switch modes on demand.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 大端序也更“自然”——这是我们如何在纸上写二进制数的方式——但更快类型转换的优势超过了它。因此，在大多数硬件上默认使用小端序，尽管一些CPU是“双端序”的，并且可以配置在需要时切换模式。
- en: '### [#](https://en.algorithmica.org/hpc/arithmetic/integer/#128-bit-integers)128-bit
    Integers'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/arithmetic/integer/#128-bit-integers)128位整数'
- en: Sometimes we need to multiply two 64-bit integers to get a 128-bit integer —
    usually to serve as a temporary value and be reduced modulo a 64-bit integer right
    away.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要将两个64位整数相乘以得到一个128位整数——通常用作临时值，并立即对64位整数取模。
- en: 'There are no 128-bit registers to hold the result of such multiplication, so
    the `mul` instruction, in addition to the normal `mul r r` form where it multiplies
    the values in registers and keeps the lower half of the result, has another `mul
    r` mode, where it multiplies whatever is stored in the `rax` register by its operand,
    and writes the result into two registers — the lower 64 bits of the result will
    go into `rax`, and the higher 64 bits go into `rdx`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 没有128位寄存器可以存储这种乘积的结果，所以`mul`指令除了正常的`mul r r`形式，其中它将寄存器中的值相乘并保留结果的一半，还有一个`mul
    r`模式，其中它将`rax`寄存器中存储的任何值与其操作数相乘，并将结果写入两个寄存器——结果的较低64位将进入`rax`，较高的64位进入`rdx`：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Some compilers have a separate type supporting this operation. In GCC and Clang
    it is available as `__int128`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编译器有支持这种操作的独立类型。在GCC和Clang中，它可用作`__int128`：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Its typical use case is to immediately extract either the lower or the higher
    part of the multiplication and forget about it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 它的典型用法是立即提取乘积的较低或较高部分，然后忘记它：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For all purposes other than multiplication, 128-bit integers are just bundled
    as two registers. This makes it too weird to have a full-fledged 128-bit type,
    so the support for it is limited, other than for basic arithmetic operations.
    For example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于除乘法以外的所有目的，128位整数只是作为两个寄存器捆绑在一起。这使得拥有一个完整的128位类型变得非常奇怪，因此除了基本算术操作之外，对其的支持有限。例如：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'is compiled into:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 编译成：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Other platforms provide similar mechanisms for dealing with longer-than-word
    multiplication. For example, Arm has `mulhi` and `mullo` instructions, returning
    lower and higher parts of the multiplication, and x86 [SIMD extensions](/hpc/simd)
    have similar 32-bit instructions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 其他平台提供了类似的机制来处理超过字大小的乘法。例如，Arm有`mulhi`和`mullo`指令，返回乘积的较低和较高部分，而x86 [SIMD扩展](/hpc/simd)有类似的32位指令。
- en: '* * *'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Note that `char`, `unsigned char`, and `signed char` are technically three distinct
    types. The C standard leaves it up to the implementation whether the plain `char`
    is signed or unsigned (on most compilers, it is signed). [↩︎](#fnref:1) [← Fast
    Inverse Square Root](https://en.algorithmica.org/hpc/arithmetic/rsqrt/)[Integer
    Division →](https://en.algorithmica.org/hpc/arithmetic/division/)
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，`char`、`unsigned char`和`signed char`在技术上是有三个不同的类型。C标准将是否将`char`声明为有符号或无符号留给实现（在大多数编译器中，它是无符号的）。 [↩︎](#fnref:1)
    [← 快速平方根倒数](https://en.algorithmica.org/hpc/arithmetic/rsqrt/)[整数除法 →](https://en.algorithmica.org/hpc/arithmetic/division/)
