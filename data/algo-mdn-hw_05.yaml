- en: Instruction Set Architectures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令集架构
- en: 原文：[https://en.algorithmica.org/hpc/architecture/isa/](https://en.algorithmica.org/hpc/architecture/isa/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/architecture/isa/](https://en.algorithmica.org/hpc/architecture/isa/)
- en: As software engineers, we absolutely love building and using abstractions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件工程师，我们绝对热爱构建和使用抽象。
- en: Just imagine how much stuff happens when you load a URL. You type something
    on a keyboard; key presses are somehow detected by the OS and get sent to the
    browser; browser parses the URL and asks the OS to make a network request; then
    comes DNS, routing, TCP, HTTP, and all the other OSI layers; browser parses HTML;
    JavaScript works its magic; some representation of a page gets sent over to GPU
    for rendering; image frames get sent to the monitor… and each of these steps probably
    involves doing dozens of more specific things in the process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下当你输入一个URL时会发生多少事情。你在键盘上输入一些内容；按键被操作系统检测到并发送到浏览器；浏览器解析URL并请求操作系统进行网络请求；然后是DNS、路由、TCP、HTTP以及所有其他的OSI层；浏览器解析HTML；JavaScript施展其魔法；页面的某种表示形式被发送到GPU进行渲染；图像帧被发送到显示器……而且这些步骤中的每一个可能都涉及到在过程中执行数十个更具体的事情。
- en: 'Abstractions help us in reducing all this complexity down to a single *interface*
    that describes what a certain *module* can do without fixing a concrete implementation.
    This provides double benefits:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象帮助我们把这些复杂性简化为单个*接口*，该接口描述了某个*模块*可以做什么，而不固定具体的实现。这提供了双重好处：
- en: Engineers working on higher-level modules only need to know the (much smaller)
    interface.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在更高层模块上工作的工程师只需要了解（更小的）接口。
- en: Engineers working on the module itself get the freedom to optimize and refactor
    its implementation as long as it complies with its *contracts*.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模块本身上工作的工程师有权优化和重构其实现，只要它符合其*契约*。
- en: Hardware engineers love abstractions too. An abstraction of a CPU is called
    an *instruction set architecture* (ISA), and it defines how a computer should
    work from a programmer’s perspective. Similar to software interfaces, it gives
    computer engineers the ability to improve on existing CPU designs while also giving
    its users — us, programmers — the confidence that things that worked before won’t
    break on newer chips.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件工程师也热爱抽象。CPU的抽象称为*指令集架构*（ISA），它定义了从程序员的角度来看计算机应该如何工作。类似于软件接口，它赋予计算机工程师改进现有CPU设计的能力，同时也给其用户——我们程序员——信心，即之前工作良好的事物在新芯片上不会出问题。
- en: 'An ISA essentially defines how the hardware should interpret the machine language.
    Apart from instructions and their binary encodings, an ISA also defines the counts,
    sizes, and purposes of registers, the memory model, and the input/output model.
    Similar to software interfaces, ISAs can be extended too: in fact, they are often
    updated, mostly in a backward-compatible way, to add new and more specialized
    instructions that can improve performance.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 指令集架构（ISA）本质上定义了硬件应该如何解释机器语言。除了指令及其二进制编码外，ISA还定义了寄存器的数量、大小和用途、内存模型以及输入/输出模型。类似于软件接口，ISA也可以扩展：事实上，它们通常以向后兼容的方式更新，以添加新的和更专业的指令，从而提高性能。
- en: '### [#](https://en.algorithmica.org/hpc/architecture/isa/#risc-vs-cisc)RISC
    vs CISC'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '### [RISC vs CISC](https://en.algorithmica.org/hpc/architecture/isa/#risc-vs-cisc)'
- en: 'Historically, there have been many competing ISAs in use. But unlike [character
    encodings and instant messaging protocols](https://xkcd.com/927/), developing
    and maintaining a completely separate ISA is costly, so mainstream CPU designs
    ended up converging to one of the two families:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，使用过许多相互竞争的ISA。但与[字符编码和即时通讯协议](https://xkcd.com/927/)不同，开发和维护一个完全独立的ISA是昂贵的，因此主流CPU设计最终收敛到了两个家族之一：
- en: '**Arm** chips, which are used in almost all mobile devices, as well as other
    computer-like devices such as TVs, smart fridges, microwaves, [car autopilots](https://en.wikipedia.org/wiki/Tesla_Autopilot),
    and so on. They are designed by a British company of the same name, as well as
    a number of electronics manufacturers including Apple and Samsung.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Arm**芯片，几乎用于所有移动设备，以及其他类似计算机的设备，如电视、智能冰箱、微波炉、[汽车自动驾驶系统](https://en.wikipedia.org/wiki/Tesla_Autopilot)等。它们由同名的英国公司以及包括苹果和三星在内的多家电子产品制造商设计。'
- en: '**x86**^([1](#fn:1)) chips, which are used in almost all servers and desktops,
    with a few notable exceptions such as Apple’s M1 MacBooks, AWS’s Graviton processors,
    and the current [world’s fastest supercomputer](https://en.wikipedia.org/wiki/Fugaku_(supercomputer)),
    all of which use Arm-based CPUs. They are designed by a duopoly of Intel and AMD.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**x86**^([1](#fn:1)) 芯片，几乎用于所有服务器和台式机，一些值得注意的例外包括苹果的 M1 MacBooks、AWS 的 Graviton
    处理器以及当前 [世界上最快的超级计算机](https://en.wikipedia.org/wiki/Fugaku_(supercomputer))，所有这些设备都使用了基于
    Arm 的处理器。它们由英特尔和 AMD 的双头垄断设计。'
- en: 'The main difference between them is that of architectural complexity, which
    is more of a design philosophy rather than some strictly defined property:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 他们之间的主要区别在于架构复杂性，这更多的是一种设计哲学，而不是一些严格定义的特性：
- en: Arm CPUs are *reduced* instruction set computers (RISC). They improve performance
    by keeping the instruction set small and highly optimized, although some less
    common operations have to be implemented with subroutines involving several instructions.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arm 处理器是 *精简* 指令集计算机 (RISC)。它们通过保持指令集小且高度优化来提高性能，尽管一些不太常见的操作需要通过涉及多个指令的子程序来实现。
- en: x86 CPUs are *complex* instruction set computers (CISC). They improve performance
    by adding many specialized instructions, some of which may only be rarely used
    in practical programs.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x86 处理器是 *复杂* 指令集计算机 (CISC)。它们通过添加许多专用指令来提高性能，其中一些指令在实际程序中可能很少使用。
- en: The main advantage of RISC designs is that they result in simpler and smaller
    chips, which projects to lower manufacturing costs and power usage. It’s not surprising
    that the market segmented itself with Arm dominating battery-powered, general-purpose
    devices, and leaving the complex neural network and Galois field calculations
    to server-grade, highly-specialized x86s.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: RISC 设计的主要优势是它们导致芯片更简单、更小，这预示着更低的制造成本和功耗。Arm 在电池供电的通用设备市场占据主导地位，而将复杂的神经网络和伽罗瓦域计算留给服务器级、高度专业化的
    x86 处理器，这并不令人惊讶。
- en: '* * *'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Modern 64-bit versions of x86 are known as “AMD64,” “Intel 64,” or by the more
    vendor-neutral names of “x86-64” or just “x64.” A similar 64-bit extension of
    Arm is called “AArch64” or “ARM64.” In this book, we will just use plain “x86”
    and “Arm” implying the 64-bit versions. [↩︎](#fnref:1) [← ../Computer Architecture](https://en.algorithmica.org/hpc/architecture/)[Assembly
    Language →](https://en.algorithmica.org/hpc/architecture/assembly/)
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现代版本的 x86 64 位处理器被称为“AMD64”、“Intel 64”，或者更中立的名称“x86-64”或简称为“x64”。类似地，Arm 的 64
    位扩展称为“AARCH64”或“ARM64”。在这本书中，我们将只使用“x86”和“Arm”，这暗示了它们是 64 位版本。[↩︎](#fnref:1) [←
    ../计算机架构](https://en.algorithmica.org/hpc/architecture/)[汇编语言 →](https://en.algorithmica.org/hpc/architecture/assembly/)
