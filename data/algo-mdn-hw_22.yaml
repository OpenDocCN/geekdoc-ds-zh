- en: Precomputation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预计算
- en: 原文：[https://en.algorithmica.org/hpc/compilation/precalc/](https://en.algorithmica.org/hpc/compilation/precalc/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/compilation/precalc/](https://en.algorithmica.org/hpc/compilation/precalc/)
- en: When compilers can infer that a certain variable does not depend on any user-provided
    data, they can compute its value during compile time and turn it into a constant
    by embedding it into the generated machine code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器可以推断出某个变量不依赖于任何用户提供的数据时，它可以在编译时计算其值，并通过将其嵌入生成的机器代码中将其转换为常量。
- en: This optimization helps performance a lot, but it is not a part of the C++ standard,
    so compilers don’t *have to* do that. When a compile-time computation is either
    hard to implement or time-intensive, a compiler may pass on that opportunity.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这种优化对性能有很大帮助，但它不是C++标准的一部分，因此编译器**不必**这样做。当编译时计算既难以实现又耗时，编译器可能会放弃这个机会。
- en: '### [#](https://en.algorithmica.org/hpc/compilation/precalc/#constant-expressions)Constant
    Expressions'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/compilation/precalc/#constant-expressions)常量表达式'
- en: 'For a more reliable solution, in modern C++ you can mark a function as `constexpr`;
    if it is called by passing constants its value is guaranteed to be computed during
    compile time:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更可靠的解决方案，在现代C++中，你可以将一个函数标记为`constexpr`；如果它通过传递常量被调用，其值保证在编译时计算：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These functions have some restrictions like that they only call other `constexpr`
    functions and can’t do memory allocation, but otherwise, they are executed “as
    is.”
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数有一些限制，例如它们只能调用其他`constexpr`函数，不能进行内存分配，但除此之外，它们将“原样”执行。
- en: 'Note that while `constexpr` functions don’t cost anything during run time,
    they still increase compilation time, so at least remotely care about their efficiency
    and don’t put something NP-complete in them:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管`constexpr`函数在运行时不会产生任何开销，但它们仍然会增加编译时间，所以至少在某种程度上要关心它们的效率，不要将NP完全问题放入其中：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There used to be many more limitations in earlier C++ standards, like you could
    not use any sort of state inside them and had to rely on recursion, so the whole
    process felt more like Haskell programming rather than C++. Since C++17, you can
    even compute static arrays using the imperative style, which is useful for precomputing
    lookup tables:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的C++标准中，曾经有许多限制，例如你无法在它们中使用任何状态，并且必须依赖递归，所以整个过程更像Haskell编程而不是C++。自从C++17以来，你甚至可以使用命令式风格计算静态数组，这对于预计算查找表很有用：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that when you call `constexpr` functions while passing non-constants,
    the compiler may or may not compute them during compile time:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你调用`constexpr`函数并传递非常量时，编译器可能或在编译时计算它们：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, even though technically we perform a constant number of iterations
    and call `fibonacci` with parameters known at compile time, they are technically
    not compile-time constants. It’s up to the compiler whether to optimize this loop
    or not — and for heavy computations, it often chooses not to. [← Contract Programming](https://en.algorithmica.org/hpc/compilation/contracts/)[../Profiling
    →](https://en.algorithmica.org/hpc/profiling/)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，尽管技术上我们执行了固定次数的迭代，并且使用编译时已知的参数调用`fibonacci`，但它们在技术上并不是编译时常量。是否优化这个循环取决于编译器——对于大量计算，它通常选择不进行优化。[←
    合约编程](https://en.algorithmica.org/hpc/compilation/contracts/)[../性能分析 →](https://en.algorithmica.org/hpc/profiling/)
