- en: Machine Code Analyzers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器代码分析器
- en: 原文：[https://en.algorithmica.org/hpc/profiling/mca/](https://en.algorithmica.org/hpc/profiling/mca/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/profiling/mca/](https://en.algorithmica.org/hpc/profiling/mca/)
- en: A *machine code analyzer* is a program that takes a small snippet of assembly
    code and [simulates](../simulation) its execution on a particular microarchitecture
    using information available to compilers, and outputs the latency and throughput
    of the whole block, as well as cycle-perfect utilization of various resources
    within the CPU.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*机器代码分析器* 是一个程序，它接受一小段汇编代码，并使用编译器可用的信息在特定的微架构上模拟其执行，并输出整个块的延迟和吞吐量，以及CPU内部各种资源的完美周期利用率。'
- en: '### [#](https://en.algorithmica.org/hpc/profiling/mca/#using-llvm-mca)Using
    `llvm-mca`'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/profiling/mca/#using-llvm-mca)使用 `llvm-mca`'
- en: There are many different machine code analyzers, but I personally prefer `llvm-mca`,
    which you can probably install via a package manager together with `clang`. You
    can also access it through a web-based tool called [UICA](https://uica.uops.info)
    or in the [Compiler Explorer](https://godbolt.org/) by selecting “Analysis” as
    the language.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的机器代码分析器，但我个人更喜欢 `llvm-mca`，你很可能可以通过包管理器与 `clang` 一起安装它。你也可以通过一个名为 [UICA](https://uica.uops.info)
    的基于Web的工具或通过在 [Compiler Explorer](https://godbolt.org/) 中选择“分析”作为语言来访问它。
- en: What `llvm-mca` does is it runs a set number of iterations of a given assembly
    snippet and computes statistics about the resource usage of each instruction,
    which is useful for finding out where the bottleneck is.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`llvm-mca` 做的是运行给定汇编代码片段的一组迭代次数，并计算每个指令的资源使用统计信息，这对于找出瓶颈位置非常有用。'
- en: 'We will consider the array sum as our simple example:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将数组求和作为我们的简单示例：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is its analysis with `llvm-mca` for the Skylake microarchitecture:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `llvm-mca` 对Skylake微架构的分析：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'First, it outputs general information about the loop and the hardware:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它输出循环和硬件的一般信息：
- en: It “ran” the loop 100 times, executing 400 instructions in total in 108 cycles,
    which is the same as executing $\frac{400}{108} \approx 3.7$ [instructions per
    cycle](/hpc/complexity/hardware) on average (IPC).
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它“运行”了100次循环，总共执行了400条指令，耗时108周期，平均每周期执行 $\frac{400}{108} \approx 3.7$ [条指令](/hpc/complexity/hardware)（IPC）。
- en: The CPU is theoretically capable of executing up to 6 instructions per cycle
    ([dispatch width](/hpc/architecture/layout)).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU理论上每周期可以执行多达6条指令（[调度宽度](/hpc/architecture/layout)）。
- en: Each cycle in theory can be executed in 0.8 cycles on average ([block reciprocal
    throughput](/hpc/pipelining/tables)).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理论上，每个周期平均可以在0.8个周期内执行（[块倒数吞吐量](/hpc/pipelining/tables)）。
- en: The “uOps” here are the micro-operations that the CPU splits each instruction
    into (e.g., fused load-add is composed of two uOps).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里的“uOps”是指CPU将每条指令分解成的微操作（例如，融合加载加法由两个uOps组成）。
- en: 'Then it proceeds to give information about each individual instruction:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它继续提供关于每个单独指令的信息：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There is nothing there that there isn’t in the [instruction tables](/hpc/pipelining/tables):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在[指令表](/hpc/pipelining/tables)中没有什么是不存在的：
- en: how many uOps each instruction is split into;
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每条指令分解成多少个uOps；
- en: how many cycles each instruction takes to complete (latency);
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每条指令完成所需多少周期（延迟）；
- en: how many cycles each instruction takes to complete in the amortized sense (reciprocal
    throughput), considering that several copies of it can be executed simultaneously.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到可以同时执行多个副本，每条指令完成所需的周期数（平均倒数吞吐量）；
- en: 'Then it outputs probably the most important part — which instructions are executing
    when and where:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它输出可能最重要的部分——哪些指令在何时何地执行：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As the contention for execution ports causes [structural hazards](/hpc/pipelining/hazards),
    ports often become the bottleneck for throughput-oriented loops, and this chart
    helps diagnose why. It does not give you a cycle-perfect Gantt chart of something
    like that, but it gives you the aggregate statistics of the execution ports used
    for each instruction, which lets you find which one is overloaded. [← Program
    Simulation](https://en.algorithmica.org/hpc/profiling/simulation/)[Benchmarking
    →](https://en.algorithmica.org/hpc/profiling/benchmarking/)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对执行端口的竞争导致[结构冒险](/hpc/pipelining/hazards)，端口经常成为吞吐量导向型循环的瓶颈，此图表有助于诊断原因。它不会给你一个完美的周期Gantt图，但会给出每个指令使用的执行端口的聚合统计数据，这让你可以找出哪个端口过载。[←
    程序模拟](https://en.algorithmica.org/hpc/profiling/simulation/)[基准测试 →](https://en.algorithmica.org/hpc/profiling/benchmarking/)
