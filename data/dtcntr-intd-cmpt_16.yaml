- en: 6.1Â Introduction to Structured DatağŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.1 ç»“æ„åŒ–æ•°æ®ç®€ä»‹[ğŸ”—](#(part._.Introduction_to_.Structured_.Data) "é“¾æ¥åˆ°æ­¤å¤„")
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/intro-struct-data.html](https://dcic-world.org/2025-08-27/intro-struct-data.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/intro-struct-data.html](https://dcic-world.org/2025-08-27/intro-struct-data.html)
- en: '| Â Â Â Â [6.1.1Â Understanding the Kinds of Compound Data](#%28part._.Understanding_the_.Kinds_of_.Compound_.Data%29)
    |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| [6.1.1 ç†è§£å¤åˆæ•°æ®ç±»å‹](#%28part._.Understanding_the_.Kinds_of_.Compound_.Data%29)
    |'
- en: '| Â Â Â Â Â Â [6.1.1.1Â A First Peek at Structured Data](#%28part._.A_.First_.Peek_at_.Structured_.Data%29)
    |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| [6.1.1.1 ç»“æ„åŒ–æ•°æ®çš„åˆæ­¥äº†è§£](#%28part._.A_.First_.Peek_at_.Structured_.Data%29) |'
- en: '| Â Â Â Â Â Â [6.1.1.2Â A First Peek at Conditional Data](#%28part._.A_.First_.Peek_at_.Conditional_.Data%29)
    |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| [6.1.1.2 æ¡ä»¶æ•°æ®çš„åˆæ­¥äº†è§£](#%28part._.A_.First_.Peek_at_.Conditional_.Data%29) |'
- en: '| Â Â Â Â [6.1.2Â Defining and Creating Structured and Conditional Data](#%28part._.Defining_and_.Creating_.Structured_and_.Conditional_.Data%29)
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| [6.1.2 å®šä¹‰å’Œåˆ›å»ºç»“æ„åŒ–å’Œæ¡ä»¶æ•°æ®](#%28part._.Defining_and_.Creating_.Structured_and_.Conditional_.Data%29)
    |'
- en: '| Â Â Â Â Â Â [6.1.2.1Â Defining and Creating Structured Data](#%28part._struct-data-eg%29)
    |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| [6.1.2.1 å®šä¹‰å’Œåˆ›å»ºç»“æ„åŒ–æ•°æ®](#%28part._struct-data-eg%29) |'
- en: '| Â Â Â Â Â Â [6.1.2.2Â Annotations for Structured Data](#%28part._.Annotations_for_.Structured_.Data%29)
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| [6.1.2.2 ç»“æ„åŒ–æ•°æ®çš„æ³¨é‡Š](#%28part._.Annotations_for_.Structured_.Data%29) |'
- en: '| Â Â Â Â Â Â [6.1.2.3Â Defining and Creating Conditional Data](#%28part._.Defining_and_.Creating_.Conditional_.Data%29)
    |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| [6.1.2.3 å®šä¹‰å’Œåˆ›å»ºæ¡ä»¶æ•°æ®](#%28part._.Defining_and_.Creating_.Conditional_.Data%29)
    |'
- en: '| Â Â Â Â [6.1.3Â Programming with Structured and Conditional Data](#%28part._.Programming_with_.Structured_and_.Conditional_.Data%29)
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| [6.1.3 ä½¿ç”¨ç»“æ„åŒ–å’Œæ¡ä»¶æ•°æ®è¿›è¡Œç¼–ç¨‹](#%28part._.Programming_with_.Structured_and_.Conditional_.Data%29)
    |'
- en: '| Â Â Â Â Â Â [6.1.3.1Â Extracting Fields from Structured Data](#%28part._.Extracting_.Fields_from_.Structured_.Data%29)
    |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| [6.1.3.1 ä»ç»“æ„åŒ–æ•°æ®ä¸­æå–å­—æ®µ](#%28part._.Extracting_.Fields_from_.Structured_.Data%29)
    |'
- en: '| Â Â Â Â Â Â [6.1.3.2Â Telling Apart Variants of Conditional Data](#%28part._telling-apart-variants%29)
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| [6.1.3.2 åŒºåˆ†æ¡ä»¶æ•°æ®çš„å˜ä½“](#%28part._telling-apart-variants%29) |'
- en: '| Â Â Â Â Â Â [6.1.3.3Â Processing Fields of Variants](#%28part._process-fields-variants%29)
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| [6.1.3.3 å¤„ç†å˜ä½“å­—æ®µ](#%28part._process-fields-variants%29) |'
- en: Earlier we had our first look at types. Until now, we have only seen the types
    that Pyret provides us, which is an interesting but nevertheless quite limited
    set. Most programs we write will contain many more kinds of data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹‹å‰æˆ‘ä»¬çœ‹åˆ°äº†æ•°æ®ç±»å‹ã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬åªçœ‹åˆ°äº†Pyretä¸ºæˆ‘ä»¬æä¾›çš„ç±»å‹ï¼Œè¿™æ˜¯ä¸€ä¸ªæœ‰è¶£ä½†ä»ç„¶ç›¸å½“æœ‰é™çš„é›†åˆã€‚æˆ‘ä»¬ç¼–å†™çš„å¤šæ•°ç¨‹åºå°†åŒ…å«æ›´å¤šç§ç±»çš„æ•°æ®ã€‚
- en: 6.1.1Â Understanding the Kinds of Compound Data[ğŸ”—](#(part._.Understanding_the_.Kinds_of_.Compound_.Data)
    "Link to here")
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.1 ç†è§£å¤åˆæ•°æ®ç±»å‹[ğŸ”—](#(part._.Understanding_the_.Kinds_of_.Compound_.Data) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 6.1.1.1Â A First Peek at Structured Data[ğŸ”—](#(part._.A_.First_.Peek_at_.Structured_.Data)
    "Link to here")
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1.1.1 ç»“æ„åŒ–æ•°æ®çš„åˆæ­¥äº†è§£[ğŸ”—](#(part._.A_.First_.Peek_at_.Structured_.Data) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'There are times when a datum has many attributes, or parts. We need to keep
    them all together, and sometimes take them apart. For instance:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰æ—¶å€™ä¸€ä¸ªæ•°æ®é›†ä¼šæœ‰å¾ˆå¤šå±æ€§æˆ–éƒ¨åˆ†ã€‚æˆ‘ä»¬éœ€è¦å°†å®ƒä»¬å…¨éƒ¨ä¿ç•™åœ¨ä¸€èµ·ï¼Œæœ‰æ—¶ä¹Ÿéœ€è¦å°†å®ƒä»¬æ‹†åˆ†ã€‚ä¾‹å¦‚ï¼š
- en: 'An iTunes entry contains a bunch of information about a single song: not only
    its name but also its singer, its length, its genre, and so on.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªiTunesæ¡ç›®åŒ…å«å…³äºä¸€é¦–æ­Œæ›²çš„å¤§é‡ä¿¡æ¯ï¼šä¸ä»…åŒ…æ‹¬å…¶åç§°ï¼Œè¿˜åŒ…æ‹¬æ­Œæ‰‹ã€æ—¶é•¿ã€æµæ´¾ç­‰ã€‚
- en: '![](../Images/72a14943124cb68143f994a2a282a9ac.png)'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](../Images/72a14943124cb68143f994a2a282a9ac.png)'
- en: 'Your GMail application contains a bunch of information about a single message:
    its sender, the subject line, the conversation itâ€™s part of, the body, and quite
    a bit more.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ‚¨çš„GMailåº”ç”¨åŒ…å«å…³äºå•ä¸ªæ¶ˆæ¯çš„å¤§é‡ä¿¡æ¯ï¼šå‘ä»¶äººã€ä¸»é¢˜è¡Œã€å®ƒæ‰€å±çš„å¯¹è¯ã€æ­£æ–‡ä»¥åŠæ›´å¤šã€‚
- en: '![](../Images/17a64e6b5180eb56ebf06a02ffe39113.png)'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](../Images/17a64e6b5180eb56ebf06a02ffe39113.png)'
- en: 'In examples like this, we see the need for structured data: a single datum
    has structure, i.e., it actually consists of many pieces. The number of pieces
    is fixed, but may be of different kinds (some might be numbers, some strings,
    some images, and different types may be mixed together in that one datum). Some
    might even be other structured data: for instance, a date usually has at least
    three parts, the day, month, and year. The parts of a structured datum are called
    its fields.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™æ ·çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°ç»“æ„åŒ–æ•°æ®çš„å¿…è¦æ€§ï¼šå•ä¸ªæ•°æ®é›†å…·æœ‰ç»“æ„ï¼Œå³å®ƒå®é™…ä¸Šç”±è®¸å¤šéƒ¨åˆ†ç»„æˆã€‚è¿™äº›éƒ¨åˆ†çš„æ•°é‡æ˜¯å›ºå®šçš„ï¼Œä½†å¯èƒ½å±äºä¸åŒçš„ç±»å‹ï¼ˆä¸€äº›å¯èƒ½æ˜¯æ•°å­—ï¼Œä¸€äº›æ˜¯å­—ç¬¦ä¸²ï¼Œä¸€äº›æ˜¯å›¾åƒï¼Œå¹¶ä¸”ä¸åŒç±»å‹å¯èƒ½æ··åˆåœ¨ä¸€ä¸ªæ•°æ®é›†ä¸­ï¼‰ã€‚ç”šè‡³å¯èƒ½åŒ…å«å…¶ä»–ç»“æ„åŒ–æ•°æ®ï¼šä¾‹å¦‚ï¼Œæ—¥æœŸé€šå¸¸è‡³å°‘åŒ…å«ä¸‰éƒ¨åˆ†ï¼Œå³æ—¥ã€æœˆå’Œå¹´ã€‚ç»“æ„åŒ–æ•°æ®é›†çš„éƒ¨åˆ†è¢«ç§°ä¸ºå…¶å­—æ®µã€‚
- en: 6.1.1.2Â A First Peek at Conditional Data[ğŸ”—](#(part._.A_.First_.Peek_at_.Conditional_.Data)
    "Link to here")
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1.1.2 æ¡ä»¶æ•°æ®çš„åˆæ­¥äº†è§£[ğŸ”—](#(part._.A_.First_.Peek_at_.Conditional_.Data) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Then there are times when we want to represent different kinds of data under
    a single, collective umbrella. Here are a few examples:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œæœ‰æ—¶æˆ‘ä»¬æƒ³è¦åœ¨å•ä¸€ã€é›†ä½“çš„ä¼ä¸‹è¡¨ç¤ºä¸åŒç±»å‹çš„æ•°æ®ã€‚è¿™é‡Œæœ‰ä¸€äº›ä¾‹å­ï¼š
- en: 'A traffic light can be in different states: red, yellow, or green.Yes, in some
    countries there are different or more colors and color-combinations. Collectively,
    they represent one thing: a new type called a traffic light state.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: äº¤é€šç¯å¯ä»¥å¤„äºä¸åŒçš„çŠ¶æ€ï¼šçº¢è‰²ã€é»„è‰²æˆ–ç»¿è‰²ã€‚æ˜¯çš„ï¼Œåœ¨ä¸€äº›å›½å®¶ï¼Œæœ‰ä¸åŒæˆ–æ›´å¤šçš„é¢œè‰²å’Œé¢œè‰²ç»„åˆã€‚æ€»ä½“æ¥è¯´ï¼Œå®ƒä»¬ä»£è¡¨äº†ä¸€ä»¶äº‹ï¼šä¸€ç§æ–°çš„ç±»å‹ï¼Œç§°ä¸ºäº¤é€šç¯çŠ¶æ€ã€‚
- en: 'A zoo consists of many kinds of animals. Collectively, they represent one thing:
    a new type called an animal. Some condition determines which particular kind of
    animal a zookeeper might be dealing with.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªåŠ¨ç‰©å›­ç”±è®¸å¤šç§ç±»çš„åŠ¨ç‰©ç»„æˆã€‚æ€»ä½“æ¥è¯´ï¼Œå®ƒä»¬ä»£è¡¨äº†ä¸€ä»¶äº‹ï¼šä¸€ç§æ–°çš„ç±»å‹ï¼Œå³åŠ¨ç‰©ã€‚æŸäº›æ¡ä»¶å†³å®šäº†åŠ¨ç‰©å›­ç®¡ç†å‘˜å¯èƒ½æ­£åœ¨å¤„ç†å“ªç§ç‰¹å®šçš„åŠ¨ç‰©ã€‚
- en: 'A social network consists of different kinds of pages. Some pages represent
    individual humans, some places, some organizations, some might stand for activities,
    and so on. Collectively, they represent a new type: a social media page.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªç¤¾äº¤ç½‘ç»œç”±ä¸åŒç§ç±»çš„é¡µé¢ç»„æˆã€‚ä¸€äº›é¡µé¢ä»£è¡¨ä¸ªäººï¼Œä¸€äº›åœ°æ–¹ï¼Œä¸€äº›ç»„ç»‡ï¼Œä¸€äº›å¯èƒ½ä»£è¡¨æ´»åŠ¨ï¼Œç­‰ç­‰ã€‚æ€»ä½“æ¥è¯´ï¼Œå®ƒä»¬ä»£è¡¨äº†ä¸€ç§æ–°çš„ç±»å‹ï¼šç¤¾äº¤åª’ä½“é¡µé¢ã€‚
- en: 'A notification application may report many kinds of events. Some are for email
    messages (which have many fields, as weâ€™ve discussed), some are for reminders
    (which might have a timestamp and a note), some for instant messages (similar
    to an email message, but without a subject), some might even be for the arrival
    of a package by physical mail (with a timestamp, shipper, tracking number, and
    delivery note). Collectively, these all represent a new type: a notification.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªé€šçŸ¥åº”ç”¨å¯èƒ½ä¼šæŠ¥å‘Šè®¸å¤šç§äº‹ä»¶ã€‚å…¶ä¸­ä¸€äº›æ˜¯å…³äºç”µå­é‚®ä»¶æ¶ˆæ¯çš„ï¼ˆæ­£å¦‚æˆ‘ä»¬ä¹‹å‰è®¨è®ºçš„ï¼Œå®ƒä»¬æœ‰è®¸å¤šå­—æ®µï¼‰ï¼Œä¸€äº›æ˜¯å…³äºæé†’çš„ï¼ˆå¯èƒ½åŒ…å«æ—¶é—´æˆ³å’Œå¤‡æ³¨ï¼‰ï¼Œä¸€äº›æ˜¯å…³äºå³æ—¶æ¶ˆæ¯çš„ï¼ˆç±»ä¼¼äºç”µå­é‚®ä»¶æ¶ˆæ¯ï¼Œä½†æ²¡æœ‰ä¸»é¢˜ï¼‰ï¼Œä¸€äº›å¯èƒ½æ˜¯å…³äºé€šè¿‡å®ç‰©é‚®ä»¶åˆ°è¾¾çš„åŒ…è£¹ï¼ˆåŒ…å«æ—¶é—´æˆ³ã€å‘è´§äººã€è·Ÿè¸ªå·å’Œé€è´§å¤‡æ³¨ï¼‰ã€‚æ€»ä½“æ¥è¯´ï¼Œè¿™äº›éƒ½ä»£è¡¨äº†ä¸€ç§æ–°çš„ç±»å‹ï¼šé€šçŸ¥ã€‚
- en: 'We call these â€œconditionalâ€ data because they represent an â€œorâ€: a traffic
    light is red or green or yellow; a social mediumâ€™s page is for a person or location
    or organization; and so on. Sometimes we care exactly which kind of thing weâ€™re
    looking at: a driver behaves differently on different colors, and a zookeeper
    feeds each animal differently. At other times, we might not care: if weâ€™re just
    counting how many animals are in the zoo, or how many pages are on a social network,
    or how many unread notifications we have, their details donâ€™t matter. Therefore,
    there are times when we ignore the conditional and treat the datum as a member
    of the collective, and other times when we do care about the conditional and do
    different things depending on the individual datum. We will make all this concrete
    as we start to write programs.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç§°è¿™äº›ä¸ºâ€œæ¡ä»¶â€æ•°æ®ï¼Œå› ä¸ºå®ƒä»¬ä»£è¡¨äº†ä¸€ä¸ªâ€œæˆ–â€ï¼šäº¤é€šç¯æ˜¯çº¢è‰²ã€ç»¿è‰²æˆ–é»„è‰²ï¼›ç¤¾äº¤åª’ä½“çš„é¡µé¢æ˜¯ä¸ºä¸ªäººã€åœ°ç‚¹æˆ–ç»„ç»‡ï¼›ç­‰ç­‰ã€‚æœ‰æ—¶æˆ‘ä»¬å…³å¿ƒæˆ‘ä»¬ç¡®åˆ‡åœ°æ­£åœ¨çœ‹å“ªç§ç±»å‹çš„ä¸œè¥¿ï¼šé©¾é©¶å‘˜åœ¨ä¸åŒé¢œè‰²ä¸Šçš„è¡Œä¸ºä¸åŒï¼ŒåŠ¨ç‰©å›­ç®¡ç†å‘˜å¯¹æ¯ç§åŠ¨ç‰©å–‚é£Ÿçš„æ–¹å¼ä¹Ÿä¸åŒã€‚åœ¨å…¶ä»–æ—¶å€™ï¼Œæˆ‘ä»¬å¯èƒ½ä¸å…³å¿ƒï¼šå¦‚æœæˆ‘ä»¬åªæ˜¯è®¡ç®—åŠ¨ç‰©å›­ä¸­æœ‰å¤šå°‘åŠ¨ç‰©ï¼Œæˆ–è€…ç¤¾äº¤ç½‘ç»œä¸Šæœ‰å¤šå°‘é¡µé¢ï¼Œæˆ–è€…æˆ‘ä»¬æœ‰å¤šå°‘æœªè¯»é€šçŸ¥ï¼Œå®ƒä»¬çš„ç»†èŠ‚å¹¶ä¸é‡è¦ã€‚å› æ­¤ï¼Œæœ‰æ—¶æˆ‘ä»¬ä¼šå¿½ç•¥æ¡ä»¶ï¼Œå°†æ•°æ®è§†ä¸ºé›†ä½“çš„ä¸€éƒ¨åˆ†ï¼Œè€Œåœ¨å…¶ä»–æ—¶å€™ï¼Œæˆ‘ä»¬ä¼šå…³å¿ƒæ¡ä»¶ï¼Œå¹¶æ ¹æ®ä¸ªåˆ«æ•°æ®æ‰§è¡Œä¸åŒçš„æ“ä½œã€‚å½“æˆ‘ä»¬å¼€å§‹ç¼–å†™ç¨‹åºæ—¶ï¼Œæˆ‘ä»¬å°†ä½¿æ‰€æœ‰è¿™äº›å…·ä½“åŒ–ã€‚
- en: 6.1.2Â Defining and Creating Structured and Conditional Data[ğŸ”—](#(part._.Defining_and_.Creating_.Structured_and_.Conditional_.Data)
    "Link to here")
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.2 å®šä¹‰å’Œåˆ›å»ºç»“æ„åŒ–å’Œæ¡ä»¶æ•°æ®[ğŸ”—](#(part._.Defining_and_.Creating_.Structured_and_.Conditional_.Data)
    "é“¾æ¥è‡³æ­¤")
- en: We have used the word â€œdataâ€ above, but thatâ€™s actually been a bit of a lie.
    As we said earlier, data are how we represent information in the computer. What
    weâ€™ve been discussing above is really different kinds of information, not exactly
    how they are represented. But to write programs, we must wrestle concretely with
    representations. Thatâ€™s what we will do now, i.e., actually show data representations
    of all this information.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨ä¸Šé¢ä½¿ç”¨äº†â€œæ•°æ®â€è¿™ä¸ªè¯ï¼Œä½†å®é™…ä¸Šé‚£æœ‰ç‚¹è¯¯å¯¼ã€‚æ­£å¦‚æˆ‘ä»¬ä¹‹å‰æ‰€è¯´çš„ï¼Œæ•°æ®æ˜¯æˆ‘ä»¬å¦‚ä½•åœ¨è®¡ç®—æœºä¸­è¡¨ç¤ºä¿¡æ¯ã€‚æˆ‘ä»¬ä¸Šé¢è®¨è®ºçš„å®é™…ä¸Šæ˜¯ä¸åŒç±»å‹çš„ä¿¡æ¯ï¼Œè€Œä¸æ˜¯å®ƒä»¬çš„ç¡®åˆ‡è¡¨ç¤ºæ–¹å¼ã€‚ä½†ä¸ºäº†ç¼–å†™ç¨‹åºï¼Œæˆ‘ä»¬å¿…é¡»å…·ä½“åœ°å¤„ç†è¡¨ç¤ºæ–¹å¼ã€‚è¿™å°±æ˜¯æˆ‘ä»¬ç°åœ¨è¦åšçš„ï¼Œå³å®é™…å±•ç¤ºæ‰€æœ‰è¿™äº›ä¿¡æ¯çš„è¡¨ç¤ºå½¢å¼ã€‚
- en: 6.1.2.1Â Defining and Creating Structured Data[ğŸ”—](#(part._struct-data-eg) "Link
    to here")
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1.2.1 å®šä¹‰å’Œåˆ›å»ºç»“æ„åŒ–æ•°æ®[ğŸ”—](#(part._struct-data-eg) "é“¾æ¥è‡³æ­¤")
- en: 'Letâ€™s start with defining structured data, such as an iTunes song record. Hereâ€™s
    a simplified version of the information such an app might store:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä»å®šä¹‰ç»“æ„åŒ–æ•°æ®å¼€å§‹ï¼Œæ¯”å¦‚iTunesæ­Œæ›²è®°å½•ã€‚è¿™é‡Œæ˜¯ä¸€ä¸ªè¿™æ ·çš„åº”ç”¨å¯èƒ½å­˜å‚¨çš„ä¿¡æ¯çš„ç®€åŒ–ç‰ˆæœ¬ï¼š
- en: The songâ€™s name, which is a `String`.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ­Œæ›²çš„åç§°ï¼Œå®ƒæ˜¯ä¸€ä¸ª`String`ã€‚
- en: The songâ€™s singer, which is also a `String`.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ­Œæ›²çš„æ­Œæ‰‹ï¼Œå®ƒä¹Ÿæ˜¯ä¸€ä¸ª `String`ã€‚
- en: The songâ€™s year, which is a `Number`.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ­Œæ›²çš„å¹´ä»½ï¼Œå®ƒæ˜¯ä¸€ä¸ª `Number`ã€‚
- en: 'Letâ€™s now introduce the syntax by which we can teach this to Pyret:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ç°åœ¨ä»‹ç»å¯ä»¥æ•™ Pyret çš„è¯­æ³•ï¼š
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This tells Pyret to introduce a new type of data, in this case called `ITunesSong`We
    follow a convention that types always begin with a capital letter.. The way we
    actually make one of these data is by calling `song` with three parameters; for
    instance:Itâ€™s worth noting that music managers that are capable of making distinctions
    between, say, Dance, Electronica, and Electronic/Dance, classify two of these
    three songs by a single genre: â€œWorldâ€.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å‘Šè¯‰ Pyret å¼•å…¥ä¸€ç§æ–°çš„æ•°æ®ç±»å‹ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ç§°ä¸º `ITunesSong`ã€‚æˆ‘ä»¬éµå¾ªä¸€ä¸ªçº¦å®šï¼Œå³ç±»å‹æ€»æ˜¯ä»¥å¤§å†™å­—æ¯å¼€å¤´ã€‚æˆ‘ä»¬å®é™…ä¸Šé€šè¿‡è°ƒç”¨ `song`
    å¹¶ä¼ é€’ä¸‰ä¸ªå‚æ•°æ¥åˆ›å»ºè¿™äº›æ•°æ®ä¹‹ä¸€ï¼›ä¾‹å¦‚ï¼šå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œèƒ½å¤ŸåŒºåˆ†ä¾‹å¦‚ Danceã€Electronica å’Œ Electronic/Dance çš„éŸ³ä¹ç®¡ç†å™¨ä¼šå°†è¿™ä¸‰é¦–æ­Œæ›²ä¸­çš„ä¸¤é¦–å½’ä¸ºå•ä¸€ç±»å‹ï¼šâ€œWorldâ€ã€‚
- en: <structured-examples> ::=
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <structured-examples> ::=
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Always follow a data definition with a few concrete instances of the data!
    This makes sure you actually do know how to make data of that form. Indeed, itâ€™s
    not essential but a good habit to give names to the data weâ€™ve defined, so that
    we can use them later:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: æ€»æ˜¯è·Ÿéšä¸€ä¸ªæ•°æ®å®šä¹‰ï¼Œç»™å‡ºä¸€äº›å…·ä½“çš„æ•°æ®å®ä¾‹ï¼è¿™ç¡®ä¿äº†ä½ å®é™…ä¸ŠçŸ¥é“å¦‚ä½•åˆ›å»ºè¿™ç§å½¢å¼çš„æ•°æ®ã€‚å®é™…ä¸Šï¼Œç»™å®šä¹‰çš„æ•°æ®å‘½åä¸æ˜¯å¿…éœ€çš„ï¼Œä½†å…»æˆä¸€ä¸ªå¥½ä¹ æƒ¯ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥åœ¨ä»¥åä½¿ç”¨å®ƒä»¬ï¼š
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In terms of the directory, structured data are no different from simple data.
    Each of the three definitions above creates an entry in the directory, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç›®å½•æ–¹é¢ï¼Œç»“æ„åŒ–æ•°æ®ä¸ç®€å•æ•°æ®å¹¶æ— ä¸åŒã€‚ä¸Šè¿°ä¸‰ä¸ªå®šä¹‰ä¸­çš„æ¯ä¸€ä¸ªéƒ½ä¼šåœ¨ç›®å½•ä¸­åˆ›å»ºä¸€ä¸ªæ¡ç›®ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: Directory
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE3]'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE3]'
- en: â†’
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE4]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE5]'
- en: â†’
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE7]'
- en: â†’
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 6.1.2.2Â Annotations for Structured Data[ğŸ”—](#(part._.Annotations_for_.Structured_.Data)
    "Link to here")
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1.2.2 ç»“æ„åŒ–æ•°æ®çš„æ³¨è§£[ğŸ”—](#(part._.Annotations_for_.Structured_.Data) "é“¾æ¥è‡³æ­¤")
- en: 'Recall that in [[Type Annotations](From_Repeated_Expressions_to_Functions.html#%28part._fun-annotations%29)]
    we discussed annotating our functions. Well, we can annotate our data, too! In
    particular, we can annotate both the definition of data and their creation. For
    the former, consider this data definition, which makes the annotation information
    weâ€™d recorded informally in text a formal part of the program:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: å›æƒ³ä¸€ä¸‹ï¼Œåœ¨ [[ç±»å‹æ³¨è§£](From_Repeated_Expressions_to_Functions.html#%28part._fun-annotations%29)]
    ä¸­ï¼Œæˆ‘ä»¬è®¨è®ºäº†å¦‚ä½•æ³¨è§£æˆ‘ä»¬çš„å‡½æ•°ã€‚å—¯ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥æ³¨è§£æˆ‘ä»¬çš„æ•°æ®ï¼ç‰¹åˆ«æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥æ³¨è§£æ•°æ®çš„å®šä¹‰åŠå…¶åˆ›å»ºã€‚å¯¹äºå‰è€…ï¼Œè€ƒè™‘ä»¥ä¸‹æ•°æ®å®šä¹‰ï¼Œå®ƒå°†æˆ‘ä»¬ä»¥å‰éæ­£å¼è®°å½•åœ¨æ–‡æœ¬ä¸­çš„æ³¨è§£ä¿¡æ¯å˜æˆäº†ç¨‹åºçš„ä¸€ä¸ªæ­£å¼éƒ¨åˆ†ï¼š
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Similarly, we can annotate the variables bound to examples of the data. But
    what should we write here?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: åŒæ ·ï¼Œæˆ‘ä»¬å¯ä»¥æ³¨è§£ç»‘å®šåˆ°æ•°æ®ç¤ºä¾‹çš„å˜é‡ã€‚ä½†æˆ‘ä»¬åº”è¯¥åœ¨è¿™é‡Œå†™ä»€ä¹ˆï¼Ÿ
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Recall that annotations takes names of types, and the new type weâ€™ve created
    is called `ITunesSong`. Therefore, we should write
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: å›æƒ³ä¸€ä¸‹ï¼Œæ³¨è§£æ¥å—ç±»å‹çš„åç§°ï¼Œè€Œæˆ‘ä»¬åˆ›å»ºçš„æ–°ç±»å‹ç§°ä¸º `ITunesSong`ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åº”è¯¥å†™
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Do Now!
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if we instead write this?
  id: totrans-63
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æ”¹å†™ä¸ºè¿™ä¸ªæ ·å­ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-65
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What error do we get? How about if instead we write these?
  id: totrans-67
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¼šé‡åˆ°ä»€ä¹ˆé”™è¯¯ï¼Ÿå¦‚æœæˆ‘ä»¬æ”¹å†™è¿™äº›ä¼šæ€æ ·ï¼Ÿ
- en: ''
  id: totrans-68
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-69
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ''
  id: totrans-70
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make sure you familiarize yourself with the error messages that you get.
  id: totrans-71
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¡®ä¿ä½ ç†Ÿæ‚‰ä½ å¾—åˆ°çš„é”™è¯¯ä¿¡æ¯ã€‚
- en: 6.1.2.3Â Defining and Creating Conditional Data[ğŸ”—](#(part._.Defining_and_.Creating_.Conditional_.Data)
    "Link to here")
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1.2.3 å®šä¹‰å’Œåˆ›å»ºæ¡ä»¶æ•°æ®[ğŸ”—](#(part._.Defining_and_.Creating_.Conditional_.Data) "é“¾æ¥è‡³æ­¤")
- en: 'The `data` construct in Pyret also lets us create conditional data, with a
    slightly different syntax. For instance, say we want to define the colors of a
    traffic light:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret ä¸­çš„ `data` æ„é€ ä¹Ÿå…è®¸æˆ‘ä»¬ä½¿ç”¨ç•¥æœ‰ä¸åŒçš„è¯­æ³•åˆ›å»ºæ¡ä»¶æ•°æ®ã€‚ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬æƒ³å®šä¹‰äº¤é€šç¯çš„é¢œè‰²ï¼š
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Conventionally, the names of the options begin in lower-case, but if they have
    no additional structure, we often capitalize the initial to make them look different
    from ordinary variables: i.e., `Red` rather than `red`. Each `|` (pronounced â€œstickâ€)
    introduces another option. You would make instances of traffic light colors as'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ä¼ ç»Ÿä¸Šï¼Œé€‰é¡¹çš„åç§°ä»¥å°å†™å­—æ¯å¼€å¤´ï¼Œä½†å¦‚æœå®ƒä»¬æ²¡æœ‰é¢å¤–çš„ç»“æ„ï¼Œæˆ‘ä»¬é€šå¸¸å°†é¦–å­—æ¯å¤§å†™ä»¥ä½¿å®ƒä»¬çœ‹èµ·æ¥ä¸æ™®é€šå˜é‡ä¸åŒï¼šå³ï¼Œ`Red` è€Œä¸æ˜¯ `red`ã€‚æ¯ä¸ª
    `|`ï¼ˆå‘éŸ³ä¸ºâ€œstickâ€ï¼‰å¼•å…¥å¦ä¸€ä¸ªé€‰é¡¹ã€‚æ‚¨å°†åˆ¶ä½œäº¤é€šç¯é¢œè‰²çš„å®ä¾‹ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A more interesting and common example is when each condition has some structure
    to it; for instance:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæ›´æœ‰è¶£ä¸”æ›´å¸¸è§çš„ä¾‹å­æ˜¯ï¼Œå½“æ¯ä¸ªæ¡ä»¶éƒ½æœ‰ä¸€äº›ç»“æ„æ—¶ï¼›ä¾‹å¦‚ï¼š
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'â€œIn Texas, there ainâ€™t nothinâ€™ in the middle of the road except yellow stripes
    and a dead armadillo.â€â€”<wbr>Jim Hightower We can make examples of them as you
    would expect:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: â€œåœ¨å¾·å…‹è¨æ–¯å·ï¼Œè·¯ä¸Šé™¤äº†é»„è‰²çš„æ¡çº¹å’Œä¸€åªæ­»çŠ°ç‹³å¤–ï¼Œä»€ä¹ˆéƒ½æ²¡æœ‰ã€‚â€â€”â€”<wbr>å‰å§†Â·æµ·ç‰¹æ²ƒæ–¯ æˆ‘ä»¬å¯ä»¥åƒé¢„æœŸçš„é‚£æ ·åˆ¶ä½œå®ƒä»¬çš„ç¤ºä¾‹ï¼š
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We call the different conditions variants.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç§°ä¸åŒçš„æ¡ä»¶ä¸ºå˜ä½“ã€‚
- en: Do Now!
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How would you annotate the three variable bindings?
  id: totrans-84
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ ä¼šå¦‚ä½•æ³¨è§£è¿™ä¸‰ä¸ªå˜é‡ç»‘å®šï¼Ÿ
- en: Notice that the distinction between boas and armadillos is lost in the annotation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨æ³¨é‡Šä¸­ï¼Œ boa å’ŒçŠ°ç‹³ä¹‹é—´çš„åŒºåˆ«æ¶ˆå¤±äº†ã€‚
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When defining a conditional datum the first stick is actually optional, but
    adding it makes the variants line up nicely. This helps us realize that our first
    example
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å®šä¹‰æ¡ä»¶æ•°æ®æ—¶ï¼Œç¬¬ä¸€æ ¹æ£’å®é™…ä¸Šæ˜¯å¯é€‰çš„ï¼Œä½†æ·»åŠ å®ƒå¯ä»¥ä½¿å˜ä½“æ•´é½æ’åˆ—ã€‚è¿™æœ‰åŠ©äºæˆ‘ä»¬æ„è¯†åˆ°æˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªä¾‹å­
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: is really just the same as
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šå°±æ˜¯ç›¸åŒçš„
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: i.e., a conditional type with just one condition, where that one condition is
    structured.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: å³ï¼Œä¸€ä¸ªåªæœ‰ä¸€ä¸ªæ¡ä»¶çš„æ¡ä»¶ç±»å‹ï¼Œå…¶ä¸­é‚£ä¸ªæ¡ä»¶æ˜¯ç»“æ„åŒ–çš„ã€‚
- en: 6.1.3Â Programming with Structured and Conditional Data[ğŸ”—](#(part._.Programming_with_.Structured_and_.Conditional_.Data)
    "Link to here")
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.3 ä½¿ç”¨ç»“æ„å’Œæ¡ä»¶æ•°æ®è¿›è¡Œç¼–ç¨‹[ğŸ”—](#(part._.Programming_with_.Structured_and_.Conditional_.Data)
    "é“¾æ¥åˆ°è¿™é‡Œ")
- en: So far weâ€™ve learned how to create structured and conditional data, but not
    yet how to take them apart or write any expressions that involve them. As you
    might expect, we need to figure out how to
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»å­¦ä¹ äº†å¦‚ä½•åˆ›å»ºç»“æ„å’Œæ¡ä»¶æ•°æ®ï¼Œä½†è¿˜æ²¡æœ‰å­¦ä¹ å¦‚ä½•æ‹†åˆ†å®ƒä»¬æˆ–ç¼–å†™æ¶‰åŠå®ƒä»¬çš„ä»»ä½•è¡¨è¾¾å¼ã€‚æ­£å¦‚ä½ æ‰€é¢„æœŸçš„ï¼Œæˆ‘ä»¬éœ€è¦å¼„æ¸…æ¥šå¦‚ä½•
- en: take apart the fields of a structured datum, and
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ‹†åˆ†ç»“æ„åŒ–æ•°æ®çš„å­—æ®µï¼Œå¹¶ä¸”
- en: tell apart the variants of a conditional datum.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åŒºåˆ†æ¡ä»¶æ•°æ®çš„å˜ä½“ã€‚
- en: As weâ€™ll see, Pyret also gives us a convenient way to do both together.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬å°†çœ‹åˆ°çš„ï¼ŒPyret è¿˜ä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªæ–¹ä¾¿çš„æ–¹å¼æ¥ä¸€èµ·åšè¿™ä¸¤ä»¶äº‹ã€‚
- en: 6.1.3.1Â Extracting Fields from Structured Data[ğŸ”—](#(part._.Extracting_.Fields_from_.Structured_.Data)
    "Link to here")
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1.3.1 ä»ç»“æ„åŒ–æ•°æ®ä¸­æå–å­—æ®µ[ğŸ”—](#(part._.Extracting_.Fields_from_.Structured_.Data) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Letâ€™s write a function that tells us how old a song is. First, letâ€™s think
    about what the function consumes (an `ITunesSong`) and produces (a `Number`).
    This gives us a rough skeleton for the function:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå‘Šè¯‰æˆ‘ä»¬ä¸€é¦–æ­Œçš„å¹´é¾„ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬æ€è€ƒä¸€ä¸‹è¿™ä¸ªå‡½æ•°éœ€è¦ä»€ä¹ˆï¼ˆä¸€ä¸ª`ITunesSong`ï¼‰å’Œäº§ç”Ÿä»€ä¹ˆï¼ˆä¸€ä¸ª`Number`ï¼‰ã€‚è¿™ä¸ºæˆ‘ä»¬æä¾›äº†å‡½æ•°çš„å¤§è‡´æ¡†æ¶ï¼š
- en: <song-age> ::=
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <song-age> ::=
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We know that the form of the body must be roughly:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çŸ¥é“èº«ä½“çš„å½¢å¼å¿…é¡»å¤§è‡´å¦‚ä¸‹ï¼š
- en: <song-age-body> ::=
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <song-age-body> ::=
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can get the song year by using Pyretâ€™s field access, which is a `.` followed
    by a fieldâ€™s nameâ€”<wbr>in this case, `year`â€”<wbr>following the variable that holds
    the structured datum. Thus, we get the `year` field of `s` (the parameter to `song-age`)
    with
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨ Pyret çš„å­—æ®µè®¿é—®æ¥è·å–æ­Œæ›²å¹´ä»½ï¼Œè¿™æ˜¯ä¸€ä¸ª`.`åè·Ÿå­—æ®µåç§°â€”â€”<wbr>åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ`year`â€”â€”<wbr>åœ¨æŒæœ‰ç»“æ„åŒ–æ•°æ®çš„å˜é‡ä¹‹åã€‚å› æ­¤ï¼Œæˆ‘ä»¬é€šè¿‡ä»¥ä¸‹æ–¹å¼è·å–`s`ï¼ˆ`song-age`çš„å‚æ•°ï¼‰çš„`year`å­—æ®µ
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So the entire function body is:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæ•´ä¸ªå‡½æ•°ä½“æ˜¯ï¼š
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It would be good to also record some examples ([<structured-examples>](#%28elem._structured-examples%29)),
    giving us a comprehensive definition of the function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: è®°å½•ä¸€äº›ä¾‹å­ï¼ˆ[<structured-examples>](#%28elem._structured-examples%29))ä¼šå¾ˆå¥½ï¼Œè¿™ä¸ºæˆ‘ä»¬æä¾›äº†å‡½æ•°çš„å…¨é¢å®šä¹‰ï¼š
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 6.1.3.2Â Telling Apart Variants of Conditional Data[ğŸ”—](#(part._telling-apart-variants)
    "Link to here")
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1.3.2 åŒºåˆ†æ¡ä»¶æ•°æ®çš„å˜ä½“[ğŸ”—](#(part._telling-apart-variants) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Now letâ€™s see how we tell apart variants. For this, we again use `cases`, as
    we saw for lists. We create one branch for each of the variants. Thus, if we wanted
    to compute advice for a driver based on a traffic lightâ€™s state, we might write:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æ¥çœ‹çœ‹æˆ‘ä»¬å¦‚ä½•åŒºåˆ†å˜ä½“ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å†æ¬¡ä½¿ç”¨`cases`ï¼Œå°±åƒæˆ‘ä»¬çœ‹åˆ°çš„åˆ—è¡¨ä¸€æ ·ã€‚æˆ‘ä»¬ä¸ºæ¯ä¸ªå˜ä½“åˆ›å»ºä¸€ä¸ªåˆ†æ”¯ã€‚å› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬æƒ³æ ¹æ®äº¤é€šç¯çš„çŠ¶æ€ä¸ºé©¾é©¶å‘˜æä¾›å»ºè®®ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šå†™ï¼š
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Do Now!
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if you leave out the `=>`?
  id: totrans-115
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœä½ çœç•¥äº†`=>`ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
- en: Do Now!
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What if you leave out a variant? Leave out the `Red` variant, then try both
    `advice(Yellow)` and `advice(Red)`.
  id: totrans-118
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœä½ çœç•¥äº†ä¸€ä¸ªå˜ä½“ä¼šæ€æ ·ï¼Ÿçœç•¥`Red`å˜ä½“ï¼Œç„¶åå°è¯•`advice(Yellow)`å’Œ`advice(Red)`ã€‚
- en: 6.1.3.3Â Processing Fields of Variants[ğŸ”—](#(part._process-fields-variants) "Link
    to here")
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1.3.3 å¤„ç†å˜ä½“çš„å­—æ®µ[ğŸ”—](#(part._process-fields-variants) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: In this example, the variants had no fields. But if the variant has fields,
    Pyret expects you to list names of variables for those fields, and will then automatically
    bind those variablesâ€”<wbr>so you donâ€™t need to use the `.`-notation to get the
    field values.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå˜ä½“æ²¡æœ‰å­—æ®µã€‚ä½†å¦‚æœå˜ä½“æœ‰å­—æ®µï¼ŒPyret é¢„æœŸä½ ä¼šåˆ—å‡ºé‚£äº›å­—æ®µå˜é‡çš„åç§°ï¼Œç„¶åä¼šè‡ªåŠ¨ç»‘å®šè¿™äº›å˜é‡â€”â€”<wbr>å› æ­¤ä½ ä¸éœ€è¦ä½¿ç”¨`.`-notationæ¥è·å–å­—æ®µå€¼ã€‚
- en: 'To illustrate this, assume we want to get the name of any animal:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†è¯´æ˜è¿™ä¸€ç‚¹ï¼Œå‡è®¾æˆ‘ä»¬æƒ³è¦è·å–ä»»ä½•åŠ¨ç‰©çš„åç§°ï¼š
- en: <animal-name> ::=
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <animal-name> ::=
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Because an `Animal` is conditionally defined, we know that we are likely to
    want a `cases` to pull it apart; furthermore, we should give names to each of
    the fields:Note that the names of the variables do not have to match the names
    of fields. Conventionally, we give longer, descriptive names to the field definitions
    and short names to the corresponding variables.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äº `Animal` æ˜¯æ¡ä»¶å®šä¹‰çš„ï¼Œæˆ‘ä»¬çŸ¥é“æˆ‘ä»¬å¯èƒ½éœ€è¦ä¸€ä¸ª `cases` æ¥å°†å…¶æ‹†åˆ†ï¼›æ­¤å¤–ï¼Œæˆ‘ä»¬åº”è¯¥ä¸ºæ¯ä¸ªå­—æ®µå‘½åï¼šè¯·æ³¨æ„ï¼Œå˜é‡çš„åç§°ä¸å¿…ä¸å­—æ®µçš„åç§°åŒ¹é…ã€‚ä¼ ç»Ÿä¸Šï¼Œæˆ‘ä»¬ç»™å­—æ®µå®šä¹‰æ›´é•¿çš„ã€æè¿°æ€§çš„åç§°ï¼Œç»™ç›¸åº”çš„å˜é‡è¾ƒçŸ­çš„åç§°ã€‚
- en: <animal-name-body> ::=
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <animal-name-body> ::=
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In both cases, we want to return the field `n`, giving us the complete function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¸Œæœ›è¿”å›å­—æ®µ `n`ï¼Œä»è€Œå¾—åˆ°å®Œæ•´çš„å‡½æ•°ï¼š
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Letâ€™s look at how Pyret would evaluate a function call like
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹çœ‹Pyretå¦‚ä½•è¯„ä¼°åƒè¿™æ ·çš„å‡½æ•°è°ƒç”¨
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The argument `boa("Bonito", 8)` is a value. In the same way as we substitute
    simple data types like strings and numbers for parameters when we evaluate a function,
    we do the same thing here. After substituting, we are left with the following
    expression to evaluate:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: å‚æ•° `boa("Bonito", 8)` æ˜¯ä¸€ä¸ªå€¼ã€‚æ­£å¦‚æˆ‘ä»¬åœ¨è¯„ä¼°å‡½æ•°æ—¶ç”¨å­—ç¬¦ä¸²å’Œæ•°å­—ç­‰ç®€å•æ•°æ®ç±»å‹æ›¿æ¢å‚æ•°ä¸€æ ·ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œä¹ŸåšåŒæ ·çš„äº‹æƒ…ã€‚æ›¿æ¢åï¼Œæˆ‘ä»¬å‰©ä¸‹ä»¥ä¸‹è¡¨è¾¾å¼æ¥è¯„ä¼°ï¼š
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Next, Pyret determines which case matches the data (the first one, for `boa`,
    in this case). It then substitutes the field names with the corresponding components
    of the datum result expression for the matched case. In this case, we will substitute
    uses of `n` with `"Bonito"` and uses of `l` with `8`. In this program, the entire
    result expression is a use of `n`, so the result of the program in this case is
    `"Bonito"`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼ŒPyretç¡®å®šå“ªä¸ªæƒ…å†µä¸æ•°æ®åŒ¹é…ï¼ˆåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯¹äº `boa`ï¼Œæ˜¯ç¬¬ä¸€ä¸ªï¼‰ã€‚ç„¶åï¼Œå®ƒå°†å­—æ®µåç§°æ›¿æ¢ä¸ºåŒ¹é…æƒ…å†µçš„å¯¹åº”æ•°æ®ç»“æœè¡¨è¾¾å¼çš„ç»„ä»¶ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°†
    `n` çš„ä½¿ç”¨æ›¿æ¢ä¸º `"Bonito"`ï¼Œå°† `l` çš„ä½¿ç”¨æ›¿æ¢ä¸º `8`ã€‚åœ¨è¿™ä¸ªç¨‹åºä¸­ï¼Œæ•´ä¸ªç»“æœè¡¨è¾¾å¼æ˜¯ `n` çš„ä½¿ç”¨ï¼Œå› æ­¤åœ¨è¿™ä¸ªæƒ…å†µä¸‹ç¨‹åºçš„ç»“æœæ˜¯
    `"Bonito"`ã€‚
- en: 6.1.1Â Understanding the Kinds of Compound Data[ğŸ”—](#(part._.Understanding_the_.Kinds_of_.Compound_.Data)
    "Link to here")
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.1Â ç†è§£å¤åˆæ•°æ®ç±»å‹[ğŸ”—](#(part._.Understanding_the_.Kinds_of_.Compound_.Data) "é“¾æ¥è‡³æ­¤")
- en: 6.1.1.1Â A First Peek at Structured Data[ğŸ”—](#(part._.A_.First_.Peek_at_.Structured_.Data)
    "Link to here")
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1.1.1Â å¯¹ç»“æ„åŒ–æ•°æ®çš„åˆæ­¥äº†è§£[ğŸ”—](#(part._.A_.First_.Peek_at_.Structured_.Data) "é“¾æ¥è‡³æ­¤")
- en: 'There are times when a datum has many attributes, or parts. We need to keep
    them all together, and sometimes take them apart. For instance:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰æ—¶ä¸€ä¸ªæ•°æ®é¡¹å…·æœ‰è®¸å¤šå±æ€§æˆ–éƒ¨åˆ†ã€‚æˆ‘ä»¬éœ€è¦å°†å®ƒä»¬å…¨éƒ¨ä¿ç•™åœ¨ä¸€èµ·ï¼Œæœ‰æ—¶è¿˜éœ€è¦å°†å®ƒä»¬åˆ†å¼€ã€‚ä¾‹å¦‚ï¼š
- en: 'An iTunes entry contains a bunch of information about a single song: not only
    its name but also its singer, its length, its genre, and so on.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªiTunesæ¡ç›®åŒ…å«å…³äºä¸€é¦–æ­Œæ›²çš„å¤§é‡ä¿¡æ¯ï¼šä¸ä»…åŒ…æ‹¬å…¶åç§°ï¼Œè¿˜æœ‰å…¶æ¼”å”±è€…ã€æ—¶é•¿ã€æµæ´¾ç­‰ã€‚
- en: '![](../Images/72a14943124cb68143f994a2a282a9ac.png)'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](../Images/72a14943124cb68143f994a2a282a9ac.png)'
- en: 'Your GMail application contains a bunch of information about a single message:
    its sender, the subject line, the conversation itâ€™s part of, the body, and quite
    a bit more.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ‚¨çš„Gmailåº”ç”¨ç¨‹åºåŒ…å«å…³äºå•ä¸ªæ¶ˆæ¯çš„å¤§é‡ä¿¡æ¯ï¼šå‘ä»¶äººã€ä¸»é¢˜è¡Œã€å®ƒæ‰€å±çš„å¯¹è¯ã€æ­£æ–‡ä»¥åŠæ›´å¤šã€‚
- en: '![](../Images/17a64e6b5180eb56ebf06a02ffe39113.png)'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](../Images/17a64e6b5180eb56ebf06a02ffe39113.png)'
- en: 'In examples like this, we see the need for structured data: a single datum
    has structure, i.e., it actually consists of many pieces. The number of pieces
    is fixed, but may be of different kinds (some might be numbers, some strings,
    some images, and different types may be mixed together in that one datum). Some
    might even be other structured data: for instance, a date usually has at least
    three parts, the day, month, and year. The parts of a structured datum are called
    its fields.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™æ ·çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°å¯¹ç»“æ„åŒ–æ•°æ®çš„éœ€è¦ï¼šå•ä¸ªæ•°æ®é¡¹å…·æœ‰ç»“æ„ï¼Œå³å®ƒå®é™…ä¸Šç”±è®¸å¤šéƒ¨åˆ†ç»„æˆã€‚è¿™äº›éƒ¨åˆ†çš„æ•°é‡æ˜¯å›ºå®šçš„ï¼Œä½†å¯èƒ½å±äºä¸åŒçš„ç±»å‹ï¼ˆä¸€äº›å¯èƒ½æ˜¯æ•°å­—ï¼Œä¸€äº›æ˜¯å­—ç¬¦ä¸²ï¼Œä¸€äº›æ˜¯å›¾åƒï¼Œå¹¶ä¸”åœ¨ä¸€ä¸ªæ•°æ®é¡¹ä¸­å¯èƒ½æ··åˆäº†ä¸åŒç±»å‹ï¼‰ã€‚ç”šè‡³å¯èƒ½åŒ…å«å…¶ä»–ç»“æ„åŒ–æ•°æ®ï¼šä¾‹å¦‚ï¼Œæ—¥æœŸé€šå¸¸è‡³å°‘åŒ…å«ä¸‰éƒ¨åˆ†ï¼Œå³æ—¥ã€æœˆå’Œå¹´ã€‚ç»“æ„åŒ–æ•°æ®é¡¹çš„éƒ¨åˆ†è¢«ç§°ä¸ºå…¶å­—æ®µã€‚
- en: 6.1.1.2Â A First Peek at Conditional Data[ğŸ”—](#(part._.A_.First_.Peek_at_.Conditional_.Data)
    "Link to here")
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1.1.2Â å¯¹æ¡ä»¶æ•°æ®çš„åˆæ­¥äº†è§£[ğŸ”—](#(part._.A_.First_.Peek_at_.Conditional_.Data) "é“¾æ¥è‡³æ­¤")
- en: 'Then there are times when we want to represent different kinds of data under
    a single, collective umbrella. Here are a few examples:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œæœ‰æ—¶æˆ‘ä»¬å¸Œæœ›åœ¨ä¸€ä¸ªå•ä¸€çš„ã€é›†ä½“çš„ä¼çŠ¶ç»“æ„ä¸‹è¡¨ç¤ºä¸åŒç±»å‹çš„æ•°æ®ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›ä¾‹å­ï¼š
- en: 'A traffic light can be in different states: red, yellow, or green.Yes, in some
    countries there are different or more colors and color-combinations. Collectively,
    they represent one thing: a new type called a traffic light state.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: äº¤é€šç¯å¯ä»¥å¤„äºä¸åŒçš„çŠ¶æ€ï¼šçº¢è‰²ã€é»„è‰²æˆ–ç»¿è‰²ã€‚æ˜¯çš„ï¼Œåœ¨ä¸€äº›å›½å®¶ï¼Œæœ‰ä¸åŒæˆ–æ›´å¤šçš„é¢œè‰²å’Œé¢œè‰²ç»„åˆã€‚æ€»çš„æ¥è¯´ï¼Œå®ƒä»¬ä»£è¡¨äº†ä¸€ä¸ªæ–°ç±»å‹ï¼šäº¤é€šç¯çŠ¶æ€ã€‚
- en: 'A zoo consists of many kinds of animals. Collectively, they represent one thing:
    a new type called an animal. Some condition determines which particular kind of
    animal a zookeeper might be dealing with.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªåŠ¨ç‰©å›­ç”±è®¸å¤šç§ç±»çš„åŠ¨ç‰©ç»„æˆã€‚æ€»çš„æ¥è¯´ï¼Œå®ƒä»¬ä»£è¡¨äº†ä¸€ä¸ªæ–°ç±»å‹ï¼šåŠ¨ç‰©ã€‚æŸäº›æ¡ä»¶å†³å®šäº†åŠ¨ç‰©å›­ç®¡ç†å‘˜å¯èƒ½æ­£åœ¨å¤„ç†å“ªç§ç‰¹å®šçš„åŠ¨ç‰©ã€‚
- en: 'A social network consists of different kinds of pages. Some pages represent
    individual humans, some places, some organizations, some might stand for activities,
    and so on. Collectively, they represent a new type: a social media page.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªç¤¾äº¤ç½‘ç»œç”±ä¸åŒç±»å‹çš„é¡µé¢ç»„æˆã€‚æœ‰äº›é¡µé¢ä»£è¡¨ä¸ªäººï¼Œæœ‰äº›ä»£è¡¨åœ°ç‚¹ï¼Œæœ‰äº›ä»£è¡¨ç»„ç»‡ï¼Œæœ‰äº›å¯èƒ½ä»£è¡¨æ´»åŠ¨ï¼Œç­‰ç­‰ã€‚æ€»çš„æ¥è¯´ï¼Œå®ƒä»¬ä»£è¡¨äº†ä¸€ä¸ªæ–°ç±»å‹ï¼šç¤¾äº¤åª’ä½“é¡µé¢ã€‚
- en: 'A notification application may report many kinds of events. Some are for email
    messages (which have many fields, as weâ€™ve discussed), some are for reminders
    (which might have a timestamp and a note), some for instant messages (similar
    to an email message, but without a subject), some might even be for the arrival
    of a package by physical mail (with a timestamp, shipper, tracking number, and
    delivery note). Collectively, these all represent a new type: a notification.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: é€šçŸ¥åº”ç”¨ç¨‹åºå¯èƒ½ä¼šæŠ¥å‘Šè®¸å¤šç±»å‹çš„äº‹ä»¶ã€‚æœ‰äº›æ˜¯å…³äºç”µå­é‚®ä»¶æ¶ˆæ¯çš„ï¼ˆæ­£å¦‚æˆ‘ä»¬ä¹‹å‰è®¨è®ºçš„ï¼Œå®ƒä»¬æœ‰è®¸å¤šå­—æ®µï¼‰ï¼Œæœ‰äº›æ˜¯å…³äºæé†’çš„ï¼ˆå¯èƒ½åŒ…å«æ—¶é—´æˆ³å’Œå¤‡æ³¨ï¼‰ï¼Œæœ‰äº›æ˜¯å…³äºå³æ—¶æ¶ˆæ¯çš„ï¼ˆç±»ä¼¼äºç”µå­é‚®ä»¶æ¶ˆæ¯ï¼Œä½†æ²¡æœ‰ä¸»é¢˜ï¼‰ï¼Œæœ‰äº›ç”šè‡³å¯èƒ½æ˜¯å…³äºé€šè¿‡å®ç‰©é‚®ä»¶åˆ°è¾¾çš„åŒ…è£¹ï¼ˆåŒ…å«æ—¶é—´æˆ³ã€å‘è´§äººã€è·Ÿè¸ªå·å’ŒæŠ•é€’å¤‡æ³¨ï¼‰ã€‚æ€»çš„æ¥è¯´ï¼Œè¿™äº›éƒ½ä»£è¡¨äº†ä¸€ç§æ–°çš„ç±»å‹ï¼šé€šçŸ¥ã€‚
- en: 'We call these â€œconditionalâ€ data because they represent an â€œorâ€: a traffic
    light is red or green or yellow; a social mediumâ€™s page is for a person or location
    or organization; and so on. Sometimes we care exactly which kind of thing weâ€™re
    looking at: a driver behaves differently on different colors, and a zookeeper
    feeds each animal differently. At other times, we might not care: if weâ€™re just
    counting how many animals are in the zoo, or how many pages are on a social network,
    or how many unread notifications we have, their details donâ€™t matter. Therefore,
    there are times when we ignore the conditional and treat the datum as a member
    of the collective, and other times when we do care about the conditional and do
    different things depending on the individual datum. We will make all this concrete
    as we start to write programs.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†è¿™äº›ç§°ä¸ºâ€œæ¡ä»¶â€æ•°æ®ï¼Œå› ä¸ºå®ƒä»¬ä»£è¡¨äº†ä¸€ä¸ªâ€œæˆ–â€çš„å…³ç³»ï¼šäº¤é€šç¯æ˜¯çº¢è‰²ã€ç»¿è‰²è¿˜æ˜¯é»„è‰²ï¼›ç¤¾äº¤åª’ä½“çš„é¡µé¢æ˜¯ä¸ºä¸ªäººã€åœ°ç‚¹æˆ–ç»„ç»‡è€Œè®¾ï¼›ç­‰ç­‰ã€‚æœ‰æ—¶æˆ‘ä»¬å…³å¿ƒæˆ‘ä»¬æ­£åœ¨æŸ¥çœ‹çš„å…·ä½“ç±»å‹ï¼šé©¾é©¶å‘˜åœ¨ä¸åŒé¢œè‰²çš„äº¤é€šç¯ä¸‹è¡¨ç°ä¸åŒï¼ŒåŠ¨ç‰©å›­ç®¡ç†å‘˜å¯¹æ¯ç§åŠ¨ç‰©å–‚é£Ÿçš„æ–¹å¼ä¹Ÿä¸åŒã€‚åœ¨å…¶ä»–æ—¶å€™ï¼Œæˆ‘ä»¬å¯èƒ½å¹¶ä¸å…³å¿ƒï¼šå¦‚æœæˆ‘ä»¬åªæ˜¯åœ¨ç»Ÿè®¡åŠ¨ç‰©å›­é‡Œæœ‰å¤šå°‘åŠ¨ç‰©ï¼Œæˆ–è€…ç¤¾äº¤ç½‘ç»œä¸Šæœ‰å¤šå°‘é¡µé¢ï¼Œæˆ–è€…æœ‰å¤šå°‘æœªè¯»é€šçŸ¥ï¼Œå®ƒä»¬çš„ç»†èŠ‚å¹¶ä¸é‡è¦ã€‚å› æ­¤ï¼Œæœ‰æ—¶æˆ‘ä»¬ä¼šå¿½ç•¥æ¡ä»¶ï¼Œå°†æ•°æ®è§†ä¸ºé›†ä½“çš„ä¸€éƒ¨åˆ†ï¼Œè€Œåœ¨å…¶ä»–æ—¶å€™ï¼Œæˆ‘ä»¬ä¼šå…³å¿ƒæ¡ä»¶ï¼Œå¹¶æ ¹æ®ä¸ªåˆ«æ•°æ®æ‰§è¡Œä¸åŒçš„æ“ä½œã€‚å½“æˆ‘ä»¬å¼€å§‹ç¼–å†™ç¨‹åºæ—¶ï¼Œæˆ‘ä»¬å°†å…·ä½“è¯´æ˜è¿™ä¸€åˆ‡ã€‚
- en: 6.1.1.1Â A First Peek at Structured Data[ğŸ”—](#(part._.A_.First_.Peek_at_.Structured_.Data)
    "Link to here")
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1.1.1 é¦–æ¬¡äº†è§£ç»“æ„åŒ–æ•°æ®[ğŸ”—](#(part._.A_.First_.Peek_at_.Structured_.Data) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'There are times when a datum has many attributes, or parts. We need to keep
    them all together, and sometimes take them apart. For instance:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰æ—¶ï¼Œä¸€ä¸ªæ•°æ®é¡¹å…·æœ‰è®¸å¤šå±æ€§æˆ–éƒ¨åˆ†ã€‚æˆ‘ä»¬éœ€è¦å°†å®ƒä»¬å…¨éƒ¨ä¿ç•™åœ¨ä¸€èµ·ï¼Œæœ‰æ—¶éœ€è¦å°†å®ƒä»¬æ‹†åˆ†ã€‚ä¾‹å¦‚ï¼š
- en: 'An iTunes entry contains a bunch of information about a single song: not only
    its name but also its singer, its length, its genre, and so on.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªiTunesæ¡ç›®åŒ…å«å…³äºä¸€é¦–æ­Œæ›²çš„å¤§é‡ä¿¡æ¯ï¼šä¸ä»…åŒ…æ‹¬å…¶åç§°ï¼Œè¿˜åŒ…æ‹¬å…¶æ­Œæ‰‹ã€æ—¶é•¿ã€æµæ´¾ç­‰ã€‚
- en: '![](../Images/72a14943124cb68143f994a2a282a9ac.png)'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](../Images/72a14943124cb68143f994a2a282a9ac.png)'
- en: 'Your GMail application contains a bunch of information about a single message:
    its sender, the subject line, the conversation itâ€™s part of, the body, and quite
    a bit more.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ‚¨çš„Gmailåº”ç”¨ç¨‹åºåŒ…å«å…³äºä¸€æ¡æ¶ˆæ¯çš„å¤§é‡ä¿¡æ¯ï¼šå…¶å‘ä»¶äººã€ä¸»é¢˜è¡Œã€å®ƒæ‰€å±çš„å¯¹è¯ã€æ­£æ–‡ï¼Œä»¥åŠæ›´å¤šã€‚
- en: '![](../Images/17a64e6b5180eb56ebf06a02ffe39113.png)'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](../Images/17a64e6b5180eb56ebf06a02ffe39113.png)'
- en: 'In examples like this, we see the need for structured data: a single datum
    has structure, i.e., it actually consists of many pieces. The number of pieces
    is fixed, but may be of different kinds (some might be numbers, some strings,
    some images, and different types may be mixed together in that one datum). Some
    might even be other structured data: for instance, a date usually has at least
    three parts, the day, month, and year. The parts of a structured datum are called
    its fields.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™æ ·çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°å¯¹ç»“æ„åŒ–æ•°æ®çš„éœ€è¦ï¼šå•ä¸ªæ•°æ®é¡¹å…·æœ‰ç»“æ„ï¼Œå³å®ƒå®é™…ä¸Šç”±è®¸å¤šéƒ¨åˆ†ç»„æˆã€‚è¿™äº›éƒ¨åˆ†çš„æ•°é‡æ˜¯å›ºå®šçš„ï¼Œä½†å¯èƒ½å±äºä¸åŒçš„ç±»å‹ï¼ˆæœ‰äº›å¯èƒ½æ˜¯æ•°å­—ï¼Œæœ‰äº›æ˜¯å­—ç¬¦ä¸²ï¼Œæœ‰äº›æ˜¯å›¾åƒï¼Œå¹¶ä¸”ä¸åŒç±»å‹å¯èƒ½æ··åˆåœ¨ä¸€ä¸ªæ•°æ®é¡¹ä¸­ï¼‰ã€‚ç”šè‡³å¯èƒ½åŒ…å«å…¶ä»–ç»“æ„åŒ–æ•°æ®ï¼šä¾‹å¦‚ï¼Œæ—¥æœŸé€šå¸¸è‡³å°‘åŒ…å«ä¸‰éƒ¨åˆ†ï¼Œå³æ—¥ã€æœˆå’Œå¹´ã€‚ç»“æ„åŒ–æ•°æ®çš„éƒ¨åˆ†è¢«ç§°ä¸ºå…¶å­—æ®µã€‚
- en: 6.1.1.2Â A First Peek at Conditional Data[ğŸ”—](#(part._.A_.First_.Peek_at_.Conditional_.Data)
    "Link to here")
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1.1.2 é¦–æ¬¡äº†è§£æ¡ä»¶æ•°æ®[ğŸ”—](#(part._.A_.First_.Peek_at_.Conditional_.Data) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Then there are times when we want to represent different kinds of data under
    a single, collective umbrella. Here are a few examples:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰æ—¶å€™ï¼Œæˆ‘ä»¬å¸Œæœ›åœ¨ä¸€ä¸ªå•ä¸€çš„ã€é›†ä½“çš„èŒƒç•´ä¸‹è¡¨ç¤ºä¸åŒç±»å‹çš„æ•°æ®ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›ä¾‹å­ï¼š
- en: 'A traffic light can be in different states: red, yellow, or green.Yes, in some
    countries there are different or more colors and color-combinations. Collectively,
    they represent one thing: a new type called a traffic light state.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: äº¤é€šç¯å¯ä»¥å¤„äºä¸åŒçš„çŠ¶æ€ï¼šçº¢è‰²ã€é»„è‰²æˆ–ç»¿è‰²ã€‚æ˜¯çš„ï¼Œåœ¨ä¸€äº›å›½å®¶ï¼Œæœ‰ä¸åŒçš„é¢œè‰²æˆ–é¢œè‰²ç»„åˆã€‚æ€»çš„æ¥è¯´ï¼Œå®ƒä»¬ä»£è¡¨äº†ä¸€ä¸ªæ–°ç±»å‹ï¼šäº¤é€šç¯çŠ¶æ€ã€‚
- en: 'A zoo consists of many kinds of animals. Collectively, they represent one thing:
    a new type called an animal. Some condition determines which particular kind of
    animal a zookeeper might be dealing with.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªåŠ¨ç‰©å›­ç”±è®¸å¤šç§ç±»çš„åŠ¨ç‰©ç»„æˆã€‚æ€»çš„æ¥è¯´ï¼Œå®ƒä»¬ä»£è¡¨äº†ä¸€ä¸ªæ–°ç±»å‹ï¼šåŠ¨ç‰©ã€‚æŸäº›æ¡ä»¶å†³å®šäº†ç®¡ç†å‘˜å¯èƒ½æ­£åœ¨å¤„ç†å“ªç§ç‰¹å®šçš„åŠ¨ç‰©ã€‚
- en: 'A social network consists of different kinds of pages. Some pages represent
    individual humans, some places, some organizations, some might stand for activities,
    and so on. Collectively, they represent a new type: a social media page.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç¤¾äº¤ç½‘ç»œç”±ä¸åŒç±»å‹çš„é¡µé¢ç»„æˆã€‚æœ‰äº›é¡µé¢ä»£è¡¨ä¸ªäººï¼Œæœ‰äº›åœ°æ–¹ï¼Œæœ‰äº›ç»„ç»‡ï¼Œæœ‰äº›å¯èƒ½ä»£è¡¨æ´»åŠ¨ï¼Œç­‰ç­‰ã€‚æ€»çš„æ¥è¯´ï¼Œå®ƒä»¬ä»£è¡¨äº†ä¸€ä¸ªæ–°ç±»å‹ï¼šç¤¾äº¤åª’ä½“é¡µé¢ã€‚
- en: 'A notification application may report many kinds of events. Some are for email
    messages (which have many fields, as weâ€™ve discussed), some are for reminders
    (which might have a timestamp and a note), some for instant messages (similar
    to an email message, but without a subject), some might even be for the arrival
    of a package by physical mail (with a timestamp, shipper, tracking number, and
    delivery note). Collectively, these all represent a new type: a notification.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: é€šçŸ¥åº”ç”¨ç¨‹åºå¯èƒ½ä¼šæŠ¥å‘Šè®¸å¤šç±»å‹çš„äº‹ä»¶ã€‚æœ‰äº›æ˜¯å…³äºç”µå­é‚®ä»¶æ¶ˆæ¯çš„ï¼ˆæ­£å¦‚æˆ‘ä»¬ä¹‹å‰è®¨è®ºçš„ï¼Œå®ƒä»¬æœ‰è®¸å¤šå­—æ®µï¼‰ï¼Œæœ‰äº›æ˜¯å…³äºæé†’çš„ï¼ˆå¯èƒ½åŒ…å«æ—¶é—´æˆ³å’Œå¤‡æ³¨ï¼‰ï¼Œæœ‰äº›æ˜¯å…³äºå³æ—¶æ¶ˆæ¯çš„ï¼ˆç±»ä¼¼äºç”µå­é‚®ä»¶æ¶ˆæ¯ï¼Œä½†æ²¡æœ‰ä¸»é¢˜ï¼‰ï¼Œæœ‰äº›ç”šè‡³å¯èƒ½æ˜¯å…³äºé€šè¿‡å®ç‰©é‚®ä»¶åˆ°è¾¾çš„åŒ…è£¹ï¼ˆåŒ…å«æ—¶é—´æˆ³ã€å‘è´§äººã€è·Ÿè¸ªå·å’Œé€è´§å¤‡æ³¨ï¼‰ã€‚æ€»çš„æ¥è¯´ï¼Œè¿™äº›éƒ½ä»£è¡¨äº†ä¸€ç§æ–°çš„ç±»å‹ï¼šé€šçŸ¥ã€‚
- en: 'We call these â€œconditionalâ€ data because they represent an â€œorâ€: a traffic
    light is red or green or yellow; a social mediumâ€™s page is for a person or location
    or organization; and so on. Sometimes we care exactly which kind of thing weâ€™re
    looking at: a driver behaves differently on different colors, and a zookeeper
    feeds each animal differently. At other times, we might not care: if weâ€™re just
    counting how many animals are in the zoo, or how many pages are on a social network,
    or how many unread notifications we have, their details donâ€™t matter. Therefore,
    there are times when we ignore the conditional and treat the datum as a member
    of the collective, and other times when we do care about the conditional and do
    different things depending on the individual datum. We will make all this concrete
    as we start to write programs.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†è¿™äº›ç§°ä¸ºâ€œæ¡ä»¶åŒ–â€æ•°æ®ï¼Œå› ä¸ºå®ƒä»¬ä»£è¡¨äº†ä¸€ä¸ªâ€œæˆ–â€ï¼šäº¤é€šç¯æ˜¯çº¢è‰²ã€ç»¿è‰²æˆ–é»„è‰²ï¼›ç¤¾äº¤åª’ä½“é¡µé¢æ˜¯ä¸ºä¸ªäººã€åœ°ç‚¹æˆ–ç»„ç»‡è€Œè®¾ï¼›ç­‰ç­‰ã€‚æœ‰æ—¶æˆ‘ä»¬å…³å¿ƒæˆ‘ä»¬æ­£åœ¨æŸ¥çœ‹çš„ç¡®åˆ‡ç±»å‹ï¼šé©¾é©¶å‘˜åœ¨ä¸åŒé¢œè‰²ä¸Šçš„è¡Œä¸ºä¸åŒï¼ŒåŠ¨ç‰©å›­ç®¡ç†å‘˜å¯¹æ¯ç§åŠ¨ç‰©å–‚é£Ÿçš„æ–¹å¼ä¹Ÿä¸åŒã€‚åœ¨å…¶ä»–æ—¶å€™ï¼Œæˆ‘ä»¬å¯èƒ½ä¸å…³å¿ƒï¼šå¦‚æœæˆ‘ä»¬åªæ˜¯è®¡ç®—åŠ¨ç‰©å›­ä¸­æœ‰å¤šå°‘åŠ¨ç‰©ï¼Œæˆ–è€…ç¤¾äº¤ç½‘ç»œä¸Šæœ‰å¤šå°‘é¡µé¢ï¼Œæˆ–è€…æˆ‘ä»¬æœ‰å¤šå°‘æœªè¯»é€šçŸ¥ï¼Œå®ƒä»¬çš„ç»†èŠ‚å¹¶ä¸é‡è¦ã€‚å› æ­¤ï¼Œæœ‰æ—¶æˆ‘ä»¬ä¼šå¿½ç•¥æ¡ä»¶ï¼Œå°†æ•°æ®è§†ä¸ºé›†ä½“çš„ä¸€éƒ¨åˆ†ï¼Œè€Œåœ¨å…¶ä»–æ—¶å€™ï¼Œæˆ‘ä»¬ä¼šå…³å¿ƒæ¡ä»¶ï¼Œå¹¶æ ¹æ®ä¸ªåˆ«æ•°æ®æ‰§è¡Œä¸åŒçš„æ“ä½œã€‚å½“æˆ‘ä»¬å¼€å§‹ç¼–å†™ç¨‹åºæ—¶ï¼Œæˆ‘ä»¬å°†ä½¿æ‰€æœ‰è¿™äº›å…·ä½“åŒ–ã€‚
- en: 6.1.2Â Defining and Creating Structured and Conditional Data[ğŸ”—](#(part._.Defining_and_.Creating_.Structured_and_.Conditional_.Data)
    "Link to here")
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.2 å®šä¹‰å’Œåˆ›å»ºç»“æ„åŒ–å’Œæ¡ä»¶åŒ–æ•°æ®[ğŸ”—](#(part._.Defining_and_.Creating_.Structured_and_.Conditional_.Data)
    "é“¾æ¥è‡³æ­¤")
- en: We have used the word â€œdataâ€ above, but thatâ€™s actually been a bit of a lie.
    As we said earlier, data are how we represent information in the computer. What
    weâ€™ve been discussing above is really different kinds of information, not exactly
    how they are represented. But to write programs, we must wrestle concretely with
    representations. Thatâ€™s what we will do now, i.e., actually show data representations
    of all this information.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¸Šé¢ä½¿ç”¨äº†â€œæ•°æ®â€è¿™ä¸ªè¯ï¼Œä½†å®é™…ä¸Šè¿™æœ‰ç‚¹è¯¯å¯¼ã€‚æ­£å¦‚æˆ‘ä»¬ä¹‹å‰æ‰€è¯´çš„ï¼Œæ•°æ®æ˜¯æˆ‘ä»¬å¦‚ä½•åœ¨è®¡ç®—æœºä¸­è¡¨ç¤ºä¿¡æ¯çš„æ–¹å¼ã€‚æˆ‘ä»¬ä¸Šé¢è®¨è®ºçš„å®é™…ä¸Šæ˜¯ä¸åŒç±»å‹çš„ä¿¡æ¯ï¼Œè€Œä¸æ˜¯å®ƒä»¬çš„ç¡®åˆ‡è¡¨ç¤ºæ–¹å¼ã€‚ä½†æ˜¯ä¸ºäº†ç¼–å†™ç¨‹åºï¼Œæˆ‘ä»¬å¿…é¡»å…·ä½“åœ°å¤„ç†è¿™äº›è¡¨ç¤ºã€‚è¿™å°±æ˜¯æˆ‘ä»¬ç°åœ¨è¦åšçš„ï¼Œå³å®é™…å±•ç¤ºæ‰€æœ‰è¿™äº›ä¿¡æ¯çš„è¡¨ç¤ºå½¢å¼ã€‚
- en: 6.1.2.1Â Defining and Creating Structured Data[ğŸ”—](#(part._struct-data-eg) "Link
    to here")
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1.2.1 å®šä¹‰å’Œåˆ›å»ºç»“æ„åŒ–æ•°æ®[ğŸ”—](#(part._struct-data-eg) "é“¾æ¥è‡³æ­¤")
- en: 'Letâ€™s start with defining structured data, such as an iTunes song record. Hereâ€™s
    a simplified version of the information such an app might store:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä»å®šä¹‰ç»“æ„åŒ–æ•°æ®å¼€å§‹ï¼Œä¾‹å¦‚iTunesæ­Œæ›²è®°å½•ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªè¿™æ ·çš„åº”ç”¨ç¨‹åºå¯èƒ½å­˜å‚¨çš„ä¿¡æ¯çš„ç®€åŒ–ç‰ˆæœ¬ï¼š
- en: The songâ€™s name, which is a `String`.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ­Œæ›²åç§°ï¼Œè¿™æ˜¯ä¸€ä¸ª`String`ã€‚
- en: The songâ€™s singer, which is also a `String`.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿™é¦–æ­Œçš„æ­Œæ‰‹ï¼Œå®ƒä¹Ÿæ˜¯ä¸€ä¸ª `String`ã€‚
- en: The songâ€™s year, which is a `Number`.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿™é¦–æ­Œçš„å¹´ä»½ï¼Œå®ƒæ˜¯ä¸€ä¸ª `Number`ã€‚
- en: 'Letâ€™s now introduce the syntax by which we can teach this to Pyret:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬ä»‹ç»ä¸€ç§è¯­æ³•ï¼Œé€šè¿‡å®ƒå¯ä»¥æ•™ Pyret å¦‚ä½•å®ç°è¿™ä¸€ç‚¹ï¼š
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This tells Pyret to introduce a new type of data, in this case called `ITunesSong`We
    follow a convention that types always begin with a capital letter.. The way we
    actually make one of these data is by calling `song` with three parameters; for
    instance:Itâ€™s worth noting that music managers that are capable of making distinctions
    between, say, Dance, Electronica, and Electronic/Dance, classify two of these
    three songs by a single genre: â€œWorldâ€.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å‘Šè¯‰ Pyret å¼•å…¥ä¸€ç§æ–°çš„æ•°æ®ç±»å‹ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ç§°ä¸º `ITunesSong`ã€‚æˆ‘ä»¬éµå¾ªä¸€ä¸ªçº¦å®šï¼Œå³ç±»å‹æ€»æ˜¯ä»¥å¤§å†™å­—æ¯å¼€å¤´ã€‚æˆ‘ä»¬å®é™…ä¸Šé€šè¿‡ç”¨ä¸‰ä¸ªå‚æ•°è°ƒç”¨
    `song` æ¥åˆ›å»ºè¿™äº›æ•°æ®ä¹‹ä¸€ï¼›ä¾‹å¦‚ï¼šå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œèƒ½å¤ŸåŒºåˆ†ä¾‹å¦‚ Danceã€Electronica å’Œ Electronic/Dance çš„éŸ³ä¹ç®¡ç†å™¨ä¼šå°†è¿™ä¸‰é¦–æ­Œæ›²ä¸­çš„ä¸¤é¦–å½’ç±»ä¸ºå•ä¸€ç±»å‹ï¼šâ€œWorldâ€ã€‚
- en: <structured-examples> ::=
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <structured-examples> ::=
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Always follow a data definition with a few concrete instances of the data!
    This makes sure you actually do know how to make data of that form. Indeed, itâ€™s
    not essential but a good habit to give names to the data weâ€™ve defined, so that
    we can use them later:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: æ€»æ˜¯åœ¨æ•°æ®å®šä¹‰ä¹‹åé™„ä¸Šä¸€äº›å…·ä½“çš„æ•°æ®å®ä¾‹ï¼è¿™ç¡®ä¿äº†ä½ å®é™…ä¸ŠçŸ¥é“å¦‚ä½•åˆ›å»ºè¿™ç§å½¢å¼çš„æ•°æ®ã€‚å®é™…ä¸Šï¼Œç»™å®šä¹‰çš„æ•°æ®å‘½åä¸æ˜¯å¿…éœ€çš„ï¼Œä½†å…»æˆä¸€ä¸ªå¥½ä¹ æƒ¯ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥åœ¨ä»¥åä½¿ç”¨å®ƒä»¬ï¼š
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In terms of the directory, structured data are no different from simple data.
    Each of the three definitions above creates an entry in the directory, as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç›®å½•æ–¹é¢ï¼Œç»“æ„åŒ–æ•°æ®ä¸ç®€å•æ•°æ®æ²¡æœ‰åŒºåˆ«ã€‚ä¸Šè¿°ä¸‰ä¸ªå®šä¹‰ä¸­çš„æ¯ä¸€ä¸ªéƒ½ä¼šåœ¨ç›®å½•ä¸­åˆ›å»ºä¸€ä¸ªæ¡ç›®ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: Directory
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE35]'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE35]'
- en: â†’
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE36]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE37]'
- en: â†’
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE38]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE39]'
- en: â†’
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE40]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 6.1.2.2Â Annotations for Structured Data[ğŸ”—](#(part._.Annotations_for_.Structured_.Data)
    "Link to here")
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1.2.2 ç»“æ„åŒ–æ•°æ®çš„æ³¨è§£[ğŸ”—](#(part._.Annotations_for_.Structured_.Data) "é“¾æ¥è‡³æ­¤")
- en: 'Recall that in [[Type Annotations](From_Repeated_Expressions_to_Functions.html#%28part._fun-annotations%29)]
    we discussed annotating our functions. Well, we can annotate our data, too! In
    particular, we can annotate both the definition of data and their creation. For
    the former, consider this data definition, which makes the annotation information
    weâ€™d recorded informally in text a formal part of the program:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: è®°å¾—åœ¨ [[ç±»å‹æ³¨è§£](From_Repeated_Expressions_to_Functions.html#%28part._fun-annotations%29)]
    æˆ‘ä»¬è®¨è®ºäº†ä¸ºæˆ‘ä»¬çš„å‡½æ•°æ·»åŠ æ³¨è§£ã€‚å—¯ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ä¸ºæ•°æ®æ·»åŠ æ³¨è§£ï¼ç‰¹åˆ«æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥æ³¨è§£æ•°æ®çš„å®šä¹‰åŠå…¶åˆ›å»ºã€‚å¯¹äºå‰è€…ï¼Œè€ƒè™‘ä»¥ä¸‹æ•°æ®å®šä¹‰ï¼Œå®ƒå°†æˆ‘ä»¬åœ¨æ–‡æœ¬ä¸­éæ­£å¼è®°å½•çš„æ³¨è§£ä¿¡æ¯å˜æˆäº†ç¨‹åºçš„ä¸€ä¸ªæ­£å¼éƒ¨åˆ†ï¼š
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Similarly, we can annotate the variables bound to examples of the data. But
    what should we write here?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: åŒæ ·ï¼Œæˆ‘ä»¬å¯ä»¥æ³¨è§£ç»‘å®šåˆ°æ•°æ®ç¤ºä¾‹çš„å˜é‡ã€‚ä½†è¿™é‡Œæˆ‘ä»¬åº”è¯¥å†™ä»€ä¹ˆï¼Ÿ
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Recall that annotations takes names of types, and the new type weâ€™ve created
    is called `ITunesSong`. Therefore, we should write
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: è®°å¾—æ³¨è§£æ¥å—ç±»å‹åç§°ï¼Œè€Œæˆ‘ä»¬åˆ›å»ºçš„æ–°ç±»å‹ç§°ä¸º `ITunesSong`ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åº”è¯¥å†™
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Do Now!
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if we instead write this?
  id: totrans-197
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æ”¹å†™ä¸ºè¿™æ ·ä¼šæ€æ ·ï¼Ÿ
- en: ''
  id: totrans-198
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-199
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ''
  id: totrans-200
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What error do we get? How about if instead we write these?
  id: totrans-201
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¼šå¾—åˆ°ä»€ä¹ˆé”™è¯¯ï¼Ÿå¦‚æœæˆ‘ä»¬æ”¹å†™ä¸ºè¿™äº›åˆä¼šæ€æ ·ï¼Ÿ
- en: ''
  id: totrans-202
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-203
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ''
  id: totrans-204
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make sure you familiarize yourself with the error messages that you get.
  id: totrans-205
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¡®ä¿ä½ ç†Ÿæ‚‰ä½ å¾—åˆ°çš„é”™è¯¯ä¿¡æ¯ã€‚
- en: 6.1.2.3Â Defining and Creating Conditional Data[ğŸ”—](#(part._.Defining_and_.Creating_.Conditional_.Data)
    "Link to here")
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1.2.3 å®šä¹‰å’Œåˆ›å»ºæ¡ä»¶æ•°æ®[ğŸ”—](#(part._.Defining_and_.Creating_.Conditional_.Data) "é“¾æ¥è‡³æ­¤")
- en: 'The `data` construct in Pyret also lets us create conditional data, with a
    slightly different syntax. For instance, say we want to define the colors of a
    traffic light:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret ä¸­çš„ `data` æ„é€ ä¹Ÿå…è®¸æˆ‘ä»¬åˆ›å»ºæ¡ä»¶æ•°æ®ï¼Œè¯­æ³•ç•¥æœ‰ä¸åŒã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬æƒ³å®šä¹‰äº¤é€šç¯çš„é¢œè‰²ï¼š
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Conventionally, the names of the options begin in lower-case, but if they have
    no additional structure, we often capitalize the initial to make them look different
    from ordinary variables: i.e., `Red` rather than `red`. Each `|` (pronounced â€œstickâ€)
    introduces another option. You would make instances of traffic light colors as'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: æŒ‰ç…§æƒ¯ä¾‹ï¼Œé€‰é¡¹çš„åç§°ä»¥å°å†™å­—æ¯å¼€å¤´ï¼Œä½†å¦‚æœå®ƒä»¬æ²¡æœ‰é¢å¤–çš„ç»“æ„ï¼Œæˆ‘ä»¬é€šå¸¸å°†é¦–å­—æ¯å¤§å†™ä»¥ä½¿å®ƒä»¬çœ‹èµ·æ¥ä¸æ™®é€šå˜é‡ä¸åŒï¼šå³ `Red` è€Œä¸æ˜¯ `red`ã€‚æ¯ä¸ª
    `|`ï¼ˆå‘éŸ³ä¸ºâ€œstickâ€ï¼‰å¼•å…¥å¦ä¸€ä¸ªé€‰é¡¹ã€‚æ‚¨å°†åˆ›å»ºäº¤é€šç¯é¢œè‰²çš„å®ä¾‹ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'A more interesting and common example is when each condition has some structure
    to it; for instance:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæ›´æœ‰è¶£ä¸”æ›´å¸¸è§çš„ä¾‹å­æ˜¯ï¼Œå½“æ¯ä¸ªæ¡ä»¶éƒ½æœ‰ä¸€äº›ç»“æ„æ—¶ï¼›ä¾‹å¦‚ï¼š
- en: '[PRE48]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'â€œIn Texas, there ainâ€™t nothinâ€™ in the middle of the road except yellow stripes
    and a dead armadillo.â€â€”<wbr>Jim Hightower We can make examples of them as you
    would expect:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: â€œåœ¨å¾·å…‹è¨æ–¯å·ï¼Œè·¯ä¸Šé™¤äº†é»„è‰²çš„æ¡çº¹å’Œä¸€åªæ­»ç”²å£³è™«å¤–ï¼Œä»€ä¹ˆéƒ½æ²¡æœ‰ã€‚â€â€”â€”å‰å§†Â·æµ·ç‰¹æ²ƒæ–¯ æˆ‘ä»¬å¯ä»¥æŒ‰ç…§é¢„æœŸçš„æ–¹å¼åˆ¶ä½œå®ƒä»¬çš„ä¾‹å­ï¼š
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We call the different conditions variants.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç§°ä¸åŒçš„æ¡ä»¶ä¸ºå˜ä½“ã€‚
- en: Do Now!
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How would you annotate the three variable bindings?
  id: totrans-218
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ ä¼šå¦‚ä½•æ³¨è§£è¿™ä¸‰ä¸ªå˜é‡ç»‘å®šï¼Ÿ
- en: Notice that the distinction between boas and armadillos is lost in the annotation.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨æ³¨é‡Šä¸­ï¼Œ boa å’ŒçŠ°ç‹³ä¹‹é—´çš„åŒºåˆ«æ¶ˆå¤±äº†ã€‚
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When defining a conditional datum the first stick is actually optional, but
    adding it makes the variants line up nicely. This helps us realize that our first
    example
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: å½“å®šä¹‰æ¡ä»¶æ•°æ®æ—¶ï¼Œç¬¬ä¸€ä¸ª stick å®é™…ä¸Šæ˜¯å¯é€‰çš„ï¼Œä½†æ·»åŠ å®ƒå¯ä»¥ä½¿å˜ä½“æ•´é½æ’åˆ—ã€‚è¿™æœ‰åŠ©äºæˆ‘ä»¬æ„è¯†åˆ°æˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªä¾‹å­
- en: '[PRE51]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: is really just the same as
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šåªæ˜¯ä¸
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: i.e., a conditional type with just one condition, where that one condition is
    structured.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: å³ï¼Œä¸€ä¸ªåªæœ‰ä¸€ä¸ªæ¡ä»¶çš„æ¡ä»¶ç±»å‹ï¼Œå…¶ä¸­è¯¥æ¡ä»¶æ˜¯ç»“æ„åŒ–çš„ã€‚
- en: 6.1.2.1Â Defining and Creating Structured Data[ğŸ”—](#(part._struct-data-eg) "Link
    to here")
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1.2.1 å®šä¹‰å’Œåˆ›å»ºç»“æ„åŒ–æ•°æ®[ğŸ”—](#(part._struct-data-eg) "é“¾æ¥è‡³æ­¤")
- en: 'Letâ€™s start with defining structured data, such as an iTunes song record. Hereâ€™s
    a simplified version of the information such an app might store:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä»å®šä¹‰ç»“æ„åŒ–æ•°æ®å¼€å§‹ï¼Œä¾‹å¦‚ä¸€ä¸ª iTunes æ­Œæ›²è®°å½•ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªæ­¤ç±»åº”ç”¨ç¨‹åºå¯èƒ½å­˜å‚¨çš„ä¿¡æ¯çš„ç®€åŒ–ç‰ˆæœ¬ï¼š
- en: The songâ€™s name, which is a `String`.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ­Œæ›²çš„åç§°ï¼Œå®ƒæ˜¯ä¸€ä¸ª `String`ã€‚
- en: The songâ€™s singer, which is also a `String`.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ­Œæ›²çš„æ­Œæ‰‹ï¼Œå®ƒä¹Ÿæ˜¯ä¸€ä¸ª `String`ã€‚
- en: The songâ€™s year, which is a `Number`.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ­Œæ›²çš„å¹´ä»½ï¼Œå®ƒæ˜¯ä¸€ä¸ª `Number`ã€‚
- en: 'Letâ€™s now introduce the syntax by which we can teach this to Pyret:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ç°åœ¨ä»‹ç»å¯ä»¥æ•™ Pyret çš„è¯­æ³•ï¼š
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This tells Pyret to introduce a new type of data, in this case called `ITunesSong`We
    follow a convention that types always begin with a capital letter.. The way we
    actually make one of these data is by calling `song` with three parameters; for
    instance:Itâ€™s worth noting that music managers that are capable of making distinctions
    between, say, Dance, Electronica, and Electronic/Dance, classify two of these
    three songs by a single genre: â€œWorldâ€.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å‘Šè¯‰ Pyret å¼•å…¥ä¸€ç§æ–°çš„æ•°æ®ç±»å‹ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ç§°ä¸º `ITunesSong`ã€‚æˆ‘ä»¬éµå¾ªä¸€ä¸ªçº¦å®šï¼Œå³ç±»å‹æ€»æ˜¯ä»¥å¤§å†™å­—æ¯å¼€å¤´ã€‚æˆ‘ä»¬å®é™…ä¸Šé€šè¿‡è°ƒç”¨ `song`
    å¹¶ä¼ é€’ä¸‰ä¸ªå‚æ•°æ¥åˆ›å»ºè¿™äº›æ•°æ®ä¹‹ä¸€ï¼›ä¾‹å¦‚ï¼šå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œèƒ½å¤ŸåŒºåˆ†ä¾‹å¦‚ Danceã€Electronica å’Œ Electronic/Dance çš„éŸ³ä¹ç®¡ç†å™¨ä¼šå°†è¿™ä¸‰é¦–æ­Œæ›²ä¸­çš„ä¸¤é¦–å½’ç±»ä¸ºå•ä¸€ç±»å‹ï¼šâ€œWorldâ€ã€‚
- en: <structured-examples> ::=
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: <structured-examples> ::=
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Always follow a data definition with a few concrete instances of the data!
    This makes sure you actually do know how to make data of that form. Indeed, itâ€™s
    not essential but a good habit to give names to the data weâ€™ve defined, so that
    we can use them later:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: æ€»æ˜¯è·Ÿéšæ•°æ®å®šä¹‰å‡ ä¸ªå…·ä½“çš„æ•°æ®å®ä¾‹ï¼è¿™ç¡®ä¿ä½ å®é™…ä¸ŠçŸ¥é“å¦‚ä½•åˆ›å»ºè¿™ç§å½¢å¼çš„æ•°æ®ã€‚å®é™…ä¸Šï¼Œç»™å®šä¹‰çš„æ•°æ®å‘½åä¸æ˜¯å¿…éœ€çš„ï¼Œä½†è¿™æ˜¯ä¸€ä¸ªå¥½ä¹ æƒ¯ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥åœ¨ä»¥åä½¿ç”¨å®ƒä»¬ï¼š
- en: '[PRE55]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In terms of the directory, structured data are no different from simple data.
    Each of the three definitions above creates an entry in the directory, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç›®å½•æ–¹é¢ï¼Œç»“æ„åŒ–æ•°æ®ä¸ç®€å•æ•°æ®æ²¡æœ‰ä¸åŒã€‚ä¸Šè¿°ä¸‰ä¸ªå®šä¹‰ä¸­çš„æ¯ä¸€ä¸ªéƒ½åœ¨ç›®å½•ä¸­åˆ›å»ºä¸€ä¸ªæ¡ç›®ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: Directory
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE56]'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE56]'
- en: â†’
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE57]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE58]'
- en: â†’
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE59]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE60]'
- en: â†’
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE61]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 6.1.2.2Â Annotations for Structured Data[ğŸ”—](#(part._.Annotations_for_.Structured_.Data)
    "Link to here")
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1.2.2 ç»“æ„åŒ–æ•°æ®çš„æ³¨é‡Š[ğŸ”—](#(part._.Annotations_for_.Structured_.Data) "é“¾æ¥è‡³æ­¤")
- en: 'Recall that in [[Type Annotations](From_Repeated_Expressions_to_Functions.html#%28part._fun-annotations%29)]
    we discussed annotating our functions. Well, we can annotate our data, too! In
    particular, we can annotate both the definition of data and their creation. For
    the former, consider this data definition, which makes the annotation information
    weâ€™d recorded informally in text a formal part of the program:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: è®°å¾—åœ¨ [[ç±»å‹æ³¨é‡Š](From_Repeated_Expressions_to_Functions.html#%28part._fun-annotations%29)]
    ä¸­ï¼Œæˆ‘ä»¬è®¨è®ºäº†æ³¨é‡Šæˆ‘ä»¬çš„å‡½æ•°ã€‚å—¯ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥æ³¨é‡Šæˆ‘ä»¬çš„æ•°æ®ï¼ç‰¹åˆ«æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥æ³¨é‡Šæ•°æ®çš„å®šä¹‰å’Œå®ƒä»¬çš„åˆ›å»ºã€‚å¯¹äºå‰è€…ï¼Œè€ƒè™‘ä»¥ä¸‹æ•°æ®å®šä¹‰ï¼Œå®ƒå°†æˆ‘ä»¬ä»¥éæ­£å¼æ–‡æœ¬å½¢å¼è®°å½•çš„æ³¨é‡Šä¿¡æ¯æ­£å¼çº³å…¥ç¨‹åºçš„ä¸€éƒ¨åˆ†ï¼š
- en: '[PRE62]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Similarly, we can annotate the variables bound to examples of the data. But
    what should we write here?
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: åŒæ ·ï¼Œæˆ‘ä»¬å¯ä»¥æ³¨é‡Šç»‘å®šåˆ°æ•°æ®ç¤ºä¾‹çš„å˜é‡ã€‚ä½†æˆ‘ä»¬åº”è¯¥åœ¨è¿™é‡Œå†™ä»€ä¹ˆï¼Ÿ
- en: '[PRE63]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Recall that annotations takes names of types, and the new type weâ€™ve created
    is called `ITunesSong`. Therefore, we should write
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: è®°å¾—æ³¨é‡Šæ¥å—ç±»å‹åç§°ï¼Œè€Œæˆ‘ä»¬åˆ›å»ºçš„æ–°ç±»å‹ç§°ä¸º `ITunesSong`ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åº”è¯¥å†™
- en: '[PRE64]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Do Now!
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if we instead write this?
  id: totrans-258
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æ”¹å†™ä¸ºè¿™æ ·ä¼šæ€æ ·ï¼Ÿ
- en: ''
  id: totrans-259
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-260
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE65]'
- en: ''
  id: totrans-261
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What error do we get? How about if instead we write these?
  id: totrans-262
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¼šé‡åˆ°ä»€ä¹ˆé”™è¯¯ï¼Ÿå¦‚æœæˆ‘ä»¬æ”¹å†™ä¸ºè¿™äº›åˆä¼šæ€æ ·ï¼Ÿ
- en: ''
  id: totrans-263
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-264
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE66]'
- en: ''
  id: totrans-265
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make sure you familiarize yourself with the error messages that you get.
  id: totrans-266
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¡®ä¿ä½ ç†Ÿæ‚‰ä½ é‡åˆ°çš„é”™è¯¯ä¿¡æ¯ã€‚
- en: 6.1.2.3Â Defining and Creating Conditional Data[ğŸ”—](#(part._.Defining_and_.Creating_.Conditional_.Data)
    "Link to here")
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1.2.3 å®šä¹‰å’Œåˆ›å»ºæ¡ä»¶æ•°æ®[ğŸ”—](#(part._.Defining_and_.Creating_.Conditional_.Data) "é“¾æ¥è‡³æ­¤")
- en: 'The `data` construct in Pyret also lets us create conditional data, with a
    slightly different syntax. For instance, say we want to define the colors of a
    traffic light:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret ä¸­çš„ `data` æ„é€ ä¹Ÿå…è®¸æˆ‘ä»¬åˆ›å»ºæ¡ä»¶æ•°æ®ï¼Œè¯­æ³•ç•¥æœ‰ä¸åŒã€‚ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬æƒ³å®šä¹‰äº¤é€šç¯çš„é¢œè‰²ï¼š
- en: '[PRE67]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Conventionally, the names of the options begin in lower-case, but if they have
    no additional structure, we often capitalize the initial to make them look different
    from ordinary variables: i.e., `Red` rather than `red`. Each `|` (pronounced â€œstickâ€)
    introduces another option. You would make instances of traffic light colors as'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: æŒ‰æƒ¯ä¾‹ï¼Œé€‰é¡¹çš„åç§°ä»¥å°å†™å­—æ¯å¼€å¤´ï¼Œä½†å¦‚æœå®ƒä»¬æ²¡æœ‰é¢å¤–çš„ç»“æ„ï¼Œæˆ‘ä»¬é€šå¸¸å°†é¦–å­—æ¯å¤§å†™ä»¥ä½¿å®ƒä»¬çœ‹èµ·æ¥ä¸æ™®é€šå˜é‡ä¸åŒï¼šå³ï¼Œ`Red`è€Œä¸æ˜¯`red`ã€‚æ¯ä¸ª`|`ï¼ˆå‘éŸ³ä¸ºâ€œstickâ€ï¼‰å¼•å…¥å¦ä¸€ä¸ªé€‰é¡¹ã€‚ä½ å¯ä»¥åˆ›å»ºäº¤é€šç¯é¢œè‰²çš„å®ä¾‹
- en: '[PRE68]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'A more interesting and common example is when each condition has some structure
    to it; for instance:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæ›´æœ‰è¶£ä¸”æ›´å¸¸è§çš„ä¾‹å­æ˜¯ï¼Œæ¯ä¸ªæ¡ä»¶éƒ½æœ‰ä¸€äº›ç»“æ„ï¼›ä¾‹å¦‚ï¼š
- en: '[PRE69]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'â€œIn Texas, there ainâ€™t nothinâ€™ in the middle of the road except yellow stripes
    and a dead armadillo.â€â€”<wbr>Jim Hightower We can make examples of them as you
    would expect:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: â€œåœ¨å¾·å…‹è¨æ–¯å·ï¼Œè·¯ä¸Šé™¤äº†é»„è‰²çš„æ¡çº¹å’Œä¸€åªæ­»ç”²å£³è™«å¤–ï¼Œä»€ä¹ˆéƒ½æ²¡æœ‰ã€‚â€â€”<wbr>å‰å§†Â·æµ·ç‰¹æ²ƒæ–¯ æˆ‘ä»¬å¯ä»¥æŒ‰ç…§é¢„æœŸçš„æ–¹å¼ä¸¾ä¾‹ï¼š
- en: '[PRE70]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We call the different conditions variants.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç§°ä¸åŒçš„æ¡ä»¶ä¸ºå˜ä½“ã€‚
- en: Do Now!
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How would you annotate the three variable bindings?
  id: totrans-279
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ ä¼šå¦‚ä½•æ³¨é‡Šä¸‰ä¸ªå˜é‡ç»‘å®šï¼Ÿ
- en: Notice that the distinction between boas and armadillos is lost in the annotation.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨æ³¨é‡Šä¸­ï¼Œ boa å’Œ armadillo ä¹‹é—´çš„åŒºåˆ«å·²ç»æ¶ˆå¤±äº†ã€‚
- en: '[PRE71]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: When defining a conditional datum the first stick is actually optional, but
    adding it makes the variants line up nicely. This helps us realize that our first
    example
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: å½“å®šä¹‰æ¡ä»¶æ€§æ•°æ®æ—¶ï¼Œç¬¬ä¸€ä¸ªstickå®é™…ä¸Šæ˜¯å¯é€‰çš„ï¼Œä½†æ·»åŠ å®ƒå¯ä»¥ä½¿å˜ä½“æ•´é½æ’åˆ—ã€‚è¿™æœ‰åŠ©äºæˆ‘ä»¬æ„è¯†åˆ°æˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªä¾‹å­
- en: '[PRE72]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: is really just the same as
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šåªæ˜¯ä¸
- en: '[PRE73]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: i.e., a conditional type with just one condition, where that one condition is
    structured.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: å³ï¼Œåªæœ‰ä¸€ä¸ªæ¡ä»¶ä¸”è¯¥æ¡ä»¶æ˜¯ç»“æ„åŒ–çš„æ¡ä»¶ç±»å‹ã€‚
- en: 6.1.3Â Programming with Structured and Conditional Data[ğŸ”—](#(part._.Programming_with_.Structured_and_.Conditional_.Data)
    "Link to here")
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.3 ä½¿ç”¨ç»“æ„åŒ–å’Œæ¡ä»¶æ€§æ•°æ®è¿›è¡Œç¼–ç¨‹[ğŸ”—](#(part._.Programming_with_.Structured_and_.Conditional_.Data)
    "é“¾æ¥åˆ°æ­¤å¤„")
- en: So far weâ€™ve learned how to create structured and conditional data, but not
    yet how to take them apart or write any expressions that involve them. As you
    might expect, we need to figure out how to
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»å­¦ä¼šäº†å¦‚ä½•åˆ›å»ºç»“æ„åŒ–å’Œæ¡ä»¶æ€§æ•°æ®ï¼Œä½†è¿˜æ²¡æœ‰å­¦ä¼šå¦‚ä½•æ‹†åˆ†å®ƒä»¬æˆ–ç¼–å†™æ¶‰åŠå®ƒä»¬çš„ä»»ä½•è¡¨è¾¾å¼ã€‚æ­£å¦‚ä½ æ‰€é¢„æœŸçš„é‚£æ ·ï¼Œæˆ‘ä»¬éœ€è¦å¼„æ¸…æ¥šå¦‚ä½•
- en: take apart the fields of a structured datum, and
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å°†ç»“æ„åŒ–æ•°æ®çš„å­—æ®µæ‹†åˆ†ï¼Œå¹¶
- en: tell apart the variants of a conditional datum.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åŒºåˆ†æ¡ä»¶æ€§æ•°æ®çš„å˜ä½“ã€‚
- en: As weâ€™ll see, Pyret also gives us a convenient way to do both together.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬å°†çœ‹åˆ°çš„ï¼ŒPyret è¿˜ä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªæ–¹ä¾¿çš„æ–¹å¼æ¥åŒæ—¶å®Œæˆè¿™ä¸¤è€…ã€‚
- en: 6.1.3.1Â Extracting Fields from Structured Data[ğŸ”—](#(part._.Extracting_.Fields_from_.Structured_.Data)
    "Link to here")
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1.3.1 ä»ç»“æ„åŒ–æ•°æ®ä¸­æå–å­—æ®µ[ğŸ”—](#(part._.Extracting_.Fields_from_.Structured_.Data) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Letâ€™s write a function that tells us how old a song is. First, letâ€™s think
    about what the function consumes (an `ITunesSong`) and produces (a `Number`).
    This gives us a rough skeleton for the function:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå‘Šè¯‰æˆ‘ä»¬ä¸€é¦–æ­Œæœ‰å¤šè€ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬è€ƒè™‘å‡½æ•°éœ€è¦ä»€ä¹ˆï¼ˆä¸€ä¸ª`ITunesSong`ï¼‰å’Œäº§ç”Ÿä»€ä¹ˆï¼ˆä¸€ä¸ª`Number`ï¼‰ã€‚è¿™ä¸ºæˆ‘ä»¬æä¾›äº†å‡½æ•°çš„å¤§è‡´æ¡†æ¶ï¼š
- en: <song-age> ::=
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: <song-age> ::=
- en: '[PRE74]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We know that the form of the body must be roughly:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çŸ¥é“ï¼Œä¸»ä½“çš„å½¢å¼å¿…é¡»å¤§è‡´å¦‚ä¸‹ï¼š
- en: <song-age-body> ::=
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: <song-age-body> ::=
- en: '[PRE75]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We can get the song year by using Pyretâ€™s field access, which is a `.` followed
    by a fieldâ€™s nameâ€”<wbr>in this case, `year`â€”<wbr>following the variable that holds
    the structured datum. Thus, we get the `year` field of `s` (the parameter to `song-age`)
    with
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨Pyretçš„å­—æ®µè®¿é—®æ¥è·å–æ­Œæ›²å¹´ä»½ï¼Œå­—æ®µè®¿é—®æ˜¯ä¸€ä¸ª`.`åè·Ÿå­—æ®µåç§°â€”<wbr>åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ`year`â€”<wbr>åœ¨æŒæœ‰ç»“æ„åŒ–æ•°æ®çš„å˜é‡ä¹‹åã€‚å› æ­¤ï¼Œæˆ‘ä»¬é€šè¿‡
- en: '[PRE76]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'So the entire function body is:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæ•´ä¸ªå‡½æ•°ä½“æ˜¯ï¼š
- en: '[PRE77]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'It would be good to also record some examples ([<structured-examples>](#%28elem._structured-examples%29)),
    giving us a comprehensive definition of the function:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: è®°å½•ä¸€äº›ä¾‹å­ï¼ˆ[<structured-examples>](#%28elem._structured-examples%29))ï¼Œç»™æˆ‘ä»¬ä¸€ä¸ªå‡½æ•°çš„å…¨é¢å®šä¹‰ï¼š
- en: '[PRE78]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 6.1.3.2Â Telling Apart Variants of Conditional Data[ğŸ”—](#(part._telling-apart-variants)
    "Link to here")
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1.3.2 åŒºåˆ†æ¡ä»¶æ€§æ•°æ®çš„å˜ä½“[ğŸ”—](#(part._telling-apart-variants) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Now letâ€™s see how we tell apart variants. For this, we again use `cases`, as
    we saw for lists. We create one branch for each of the variants. Thus, if we wanted
    to compute advice for a driver based on a traffic lightâ€™s state, we might write:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬å¦‚ä½•åŒºåˆ†å˜ä½“ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å†æ¬¡ä½¿ç”¨`cases`ï¼Œå°±åƒæˆ‘ä»¬ä¸ºåˆ—è¡¨æ‰€åšçš„é‚£æ ·ã€‚æˆ‘ä»¬ä¸ºæ¯ä¸ªå˜ä½“åˆ›å»ºä¸€ä¸ªåˆ†æ”¯ã€‚å› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬æƒ³æ ¹æ®äº¤é€šç¯çš„çŠ¶æ€ä¸ºé©¾é©¶å‘˜è®¡ç®—å»ºè®®ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šå†™ï¼š
- en: '[PRE79]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Do Now!
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if you leave out the `=>`?
  id: totrans-310
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœä½ çœç•¥äº†`=>`ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
- en: Do Now!
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What if you leave out a variant? Leave out the `Red` variant, then try both
    `advice(Yellow)` and `advice(Red)`.
  id: totrans-313
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœä½ çœç•¥äº†ä¸€ä¸ªå˜ä½“ä¼šæ€æ ·ï¼Ÿçœç•¥`Red`å˜ä½“ï¼Œç„¶åå°è¯•`advice(Yellow)`å’Œ`advice(Red)`ã€‚
- en: 6.1.3.3Â Processing Fields of Variants[ğŸ”—](#(part._process-fields-variants) "Link
    to here")
  id: totrans-314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1.3.3 å¤„ç†å˜ä½“çš„å­—æ®µ[ğŸ”—](#(part._process-fields-variants) "é“¾æ¥è‡³æ­¤")
- en: In this example, the variants had no fields. But if the variant has fields,
    Pyret expects you to list names of variables for those fields, and will then automatically
    bind those variablesâ€”<wbr>so you donâ€™t need to use the `.`-notation to get the
    field values.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå˜ä½“æ²¡æœ‰å­—æ®µã€‚ä½†å¦‚æœå˜ä½“æœ‰å­—æ®µï¼ŒPyret é¢„æœŸä½ ä¼šåˆ—å‡ºè¿™äº›å­—æ®µçš„å˜é‡åç§°ï¼Œç„¶åå®ƒä¼šè‡ªåŠ¨ç»‘å®šè¿™äº›å˜é‡â€”â€”å› æ­¤ä½ ä¸éœ€è¦ä½¿ç”¨ `.`-notation
    æ¥è·å–å­—æ®µå€¼ã€‚
- en: 'To illustrate this, assume we want to get the name of any animal:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†è¯´æ˜è¿™ä¸€ç‚¹ï¼Œå‡è®¾æˆ‘ä»¬æƒ³è¦è·å–ä»»ä½•åŠ¨ç‰©çš„åå­—ï¼š
- en: <animal-name> ::=
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`<animal-name> ::='
- en: '[PRE80]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Because an `Animal` is conditionally defined, we know that we are likely to
    want a `cases` to pull it apart; furthermore, we should give names to each of
    the fields:Note that the names of the variables do not have to match the names
    of fields. Conventionally, we give longer, descriptive names to the field definitions
    and short names to the corresponding variables.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äº `Animal` æ˜¯æ¡ä»¶å®šä¹‰çš„ï¼Œæˆ‘ä»¬çŸ¥é“æˆ‘ä»¬å¯èƒ½éœ€è¦ä¸€ä¸ª `cases` æ¥å°†å…¶æ‹†åˆ†ï¼›æ­¤å¤–ï¼Œæˆ‘ä»¬åº”è¯¥ä¸ºæ¯ä¸ªå­—æ®µå‘½åï¼šè¯·æ³¨æ„ï¼Œå˜é‡çš„åç§°ä¸å¿…ä¸å­—æ®µçš„åç§°åŒ¹é…ã€‚ä¼ ç»Ÿä¸Šï¼Œæˆ‘ä»¬ç»™å­—æ®µå®šä¹‰ä½¿ç”¨è¾ƒé•¿çš„ã€æè¿°æ€§çš„åç§°ï¼Œç»™ç›¸åº”çš„å˜é‡ä½¿ç”¨è¾ƒçŸ­çš„åç§°ã€‚
- en: <animal-name-body> ::=
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`<animal-name-body> ::='
- en: '[PRE81]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In both cases, we want to return the field `n`, giving us the complete function:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬æƒ³è¦è¿”å›å­—æ®µ `n`ï¼Œä»è€Œå¾—åˆ°å®Œæ•´çš„å‡½æ•°ï¼š
- en: '[PRE82]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Letâ€™s look at how Pyret would evaluate a function call like
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹çœ‹ Pyret å¦‚ä½•è¯„ä¼°ä¸€ä¸ªå‡½æ•°è°ƒç”¨ï¼Œä¾‹å¦‚
- en: '[PRE83]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The argument `boa("Bonito", 8)` is a value. In the same way as we substitute
    simple data types like strings and numbers for parameters when we evaluate a function,
    we do the same thing here. After substituting, we are left with the following
    expression to evaluate:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: å‚æ•° `boa("Bonito", 8)` æ˜¯ä¸€ä¸ªå€¼ã€‚å°±åƒæˆ‘ä»¬åœ¨è¯„ä¼°å‡½æ•°æ—¶ç”¨ç®€å•çš„æ•°æ®ç±»å‹ï¼ˆå¦‚å­—ç¬¦ä¸²å’Œæ•°å­—ï¼‰æ›¿æ¢å‚æ•°ä¸€æ ·ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œä¹ŸåšåŒæ ·çš„äº‹æƒ…ã€‚æ›¿æ¢åï¼Œæˆ‘ä»¬å‰©ä¸‹ä»¥ä¸‹è¡¨è¾¾å¼æ¥è¯„ä¼°ï¼š
- en: '[PRE84]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Next, Pyret determines which case matches the data (the first one, for `boa`,
    in this case). It then substitutes the field names with the corresponding components
    of the datum result expression for the matched case. In this case, we will substitute
    uses of `n` with `"Bonito"` and uses of `l` with `8`. In this program, the entire
    result expression is a use of `n`, so the result of the program in this case is
    `"Bonito"`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼ŒPyret ç¡®å®šå“ªä¸ªæƒ…å†µä¸æ•°æ®åŒ¹é…ï¼ˆåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯¹äº `boa`ï¼Œæ˜¯ç¬¬ä¸€ä¸ªï¼‰ã€‚ç„¶åï¼Œå®ƒå°†åŒ¹é…æƒ…å†µçš„å­—æ®µåç§°æ›¿æ¢ä¸ºæ•°æ®ç»“æœè¡¨è¾¾å¼çš„ç›¸åº”ç»„ä»¶ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°†
    `n` çš„ä½¿ç”¨æ›¿æ¢ä¸º `"Bonito"`ï¼Œå°† `l` çš„ä½¿ç”¨æ›¿æ¢ä¸º `8`ã€‚åœ¨è¿™ä¸ªç¨‹åºä¸­ï¼Œæ•´ä¸ªç»“æœè¡¨è¾¾å¼éƒ½æ˜¯å¯¹ `n` çš„ä½¿ç”¨ï¼Œå› æ­¤åœ¨è¿™ä¸ªæƒ…å†µä¸‹ç¨‹åºçš„è¾“å‡ºç»“æœæ˜¯
    `"Bonito"`ã€‚
- en: 6.1.3.1Â Extracting Fields from Structured Data[ğŸ”—](#(part._.Extracting_.Fields_from_.Structured_.Data)
    "Link to here")
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1.3.1 ä»ç»“æ„åŒ–æ•°æ®ä¸­æå–å­—æ®µ[ğŸ”—](#(part._.Extracting_.Fields_from_.Structured_.Data) "é“¾æ¥è‡³æ­¤")
- en: 'Letâ€™s write a function that tells us how old a song is. First, letâ€™s think
    about what the function consumes (an `ITunesSong`) and produces (a `Number`).
    This gives us a rough skeleton for the function:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå‘Šè¯‰æˆ‘ä»¬ä¸€é¦–æ­Œæœ‰å¤šè€ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬è€ƒè™‘è¿™ä¸ªå‡½æ•°éœ€è¦ä»€ä¹ˆï¼ˆä¸€ä¸ª `ITunesSong`ï¼‰å’Œäº§ç”Ÿä»€ä¹ˆï¼ˆä¸€ä¸ª `Number`ï¼‰ã€‚è¿™ä¸ºæˆ‘ä»¬æä¾›äº†å‡½æ•°çš„å¤§è‡´æ¡†æ¶ï¼š
- en: <song-age> ::=
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`<song-age> ::='
- en: '[PRE85]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We know that the form of the body must be roughly:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çŸ¥é“èº«ä½“çš„å½¢å¼å¿…é¡»å¤§è‡´å¦‚ä¸‹ï¼š
- en: <song-age-body> ::=
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`<song-age-body> ::='
- en: '[PRE86]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We can get the song year by using Pyretâ€™s field access, which is a `.` followed
    by a fieldâ€™s nameâ€”<wbr>in this case, `year`â€”<wbr>following the variable that holds
    the structured datum. Thus, we get the `year` field of `s` (the parameter to `song-age`)
    with
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨ Pyret çš„å­—æ®µè®¿é—®æ¥è·å–æ­Œæ›²å¹´ä»½ï¼Œè¿™æ˜¯ä¸€ä¸ªå­—æ®µåç§°ï¼ˆåœ¨è¿™ç§æƒ…å†µä¸‹ä¸º `year`ï¼‰åè·Ÿä¸€ä¸ªç‚¹ï¼ˆ`.`ï¼‰çš„è¯­æ³•ï¼Œç´§éšåŒ…å«ç»“æ„åŒ–æ•°æ®çš„å˜é‡ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼è·å–
    `s`ï¼ˆ`song-age` çš„å‚æ•°ï¼‰çš„ `year` å­—æ®µï¼š
- en: '[PRE87]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'So the entire function body is:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæ•´ä¸ªå‡½æ•°ä½“å¦‚ä¸‹ï¼š
- en: '[PRE88]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'It would be good to also record some examples ([<structured-examples>](#%28elem._structured-examples%29)),
    giving us a comprehensive definition of the function:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°†æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„åšæ³•ï¼Œä¹Ÿè®°å½•ä¸€äº›ä¾‹å­ ([<structured-examples>](#%28elem._structured-examples%29))ï¼Œç»™æˆ‘ä»¬ä¸€ä¸ªå‡½æ•°çš„å…¨é¢å®šä¹‰ï¼š
- en: '[PRE89]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 6.1.3.2Â Telling Apart Variants of Conditional Data[ğŸ”—](#(part._telling-apart-variants)
    "Link to here")
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1.3.2 åŒºåˆ†æ¡ä»¶æ•°æ®çš„å˜ä½“[ğŸ”—](#(part._telling-apart-variants) "é“¾æ¥è‡³æ­¤")
- en: 'Now letâ€™s see how we tell apart variants. For this, we again use `cases`, as
    we saw for lists. We create one branch for each of the variants. Thus, if we wanted
    to compute advice for a driver based on a traffic lightâ€™s state, we might write:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬å¦‚ä½•åŒºåˆ†å˜ä½“ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å†æ¬¡ä½¿ç”¨ `cases`ï¼Œå°±åƒæˆ‘ä»¬ä¹‹å‰åœ¨åˆ—è¡¨ä¸­çœ‹åˆ°çš„é‚£æ ·ã€‚æˆ‘ä»¬ä¸ºæ¯ä¸ªå˜ä½“åˆ›å»ºä¸€ä¸ªåˆ†æ”¯ã€‚å› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦æ ¹æ®äº¤é€šç¯çš„çŠ¶æ€ä¸ºé©¾é©¶å‘˜æä¾›å»ºè®®ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šç¼–å†™ï¼š
- en: '[PRE90]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Do Now!
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if you leave out the `=>`?
  id: totrans-347
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœä½ çœç•¥äº† `=>` ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
- en: Do Now!
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What if you leave out a variant? Leave out the `Red` variant, then try both
    `advice(Yellow)` and `advice(Red)`.
  id: totrans-350
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœä½ çœç•¥äº†ä¸€ä¸ªå˜ä½“æ€ä¹ˆåŠï¼Ÿçœç•¥ `Red` å˜ä½“ï¼Œç„¶åå°è¯• `advice(Yellow)` å’Œ `advice(Red)`ã€‚
- en: 6.1.3.3Â Processing Fields of Variants[ğŸ”—](#(part._process-fields-variants) "Link
    to here")
  id: totrans-351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1.3.3 å¤„ç†å˜ä½“çš„å­—æ®µ[ğŸ”—](#(part._process-fields-variants) "é“¾æ¥åˆ°æ­¤å¤„")
- en: In this example, the variants had no fields. But if the variant has fields,
    Pyret expects you to list names of variables for those fields, and will then automatically
    bind those variablesâ€”<wbr>so you donâ€™t need to use the `.`-notation to get the
    field values.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå˜ä½“æ²¡æœ‰å­—æ®µã€‚ä½†å¦‚æœå˜ä½“æœ‰å­—æ®µï¼ŒPyret é¢„æœŸä½ ä¼šåˆ—å‡ºè¿™äº›å­—æ®µçš„å˜é‡åï¼Œç„¶åä¼šè‡ªåŠ¨ç»‘å®šè¿™äº›å˜é‡â€”â€”<wbr>å› æ­¤ä½ ä¸éœ€è¦ä½¿ç”¨ `.`-notation
    æ¥è·å–å­—æ®µå€¼ã€‚
- en: 'To illustrate this, assume we want to get the name of any animal:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†è¯´æ˜è¿™ä¸€ç‚¹ï¼Œå‡è®¾æˆ‘ä»¬æƒ³è¦è·å–ä»»ä½•åŠ¨ç‰©çš„åå­—ï¼š
- en: <animal-name> ::=
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: <animal-name> ::=
- en: '[PRE91]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Because an `Animal` is conditionally defined, we know that we are likely to
    want a `cases` to pull it apart; furthermore, we should give names to each of
    the fields:Note that the names of the variables do not have to match the names
    of fields. Conventionally, we give longer, descriptive names to the field definitions
    and short names to the corresponding variables.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äº `Animal` æ˜¯æ¡ä»¶å®šä¹‰çš„ï¼Œæˆ‘ä»¬çŸ¥é“æˆ‘ä»¬å¯èƒ½æƒ³è¦ä¸€ä¸ª `cases` æ¥å°†å…¶æ‹†åˆ†ï¼›æ­¤å¤–ï¼Œæˆ‘ä»¬åº”è¯¥ç»™æ¯ä¸ªå­—æ®µå‘½åï¼šè¯·æ³¨æ„ï¼Œå˜é‡çš„åç§°ä¸å¿…ä¸å­—æ®µçš„åç§°åŒ¹é…ã€‚ä¼ ç»Ÿä¸Šï¼Œæˆ‘ä»¬ç»™å­—æ®µå®šä¹‰æ›´é•¿çš„ã€æè¿°æ€§çš„åç§°ï¼Œç»™ç›¸åº”çš„å˜é‡è¾ƒçŸ­çš„åç§°ã€‚
- en: <animal-name-body> ::=
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: <animal-name-body> ::=
- en: '[PRE92]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'In both cases, we want to return the field `n`, giving us the complete function:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¸Œæœ›è¿”å›å­—æ®µ `n`ï¼Œä»è€Œå¾—åˆ°å®Œæ•´çš„å‡½æ•°ï¼š
- en: '[PRE93]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Letâ€™s look at how Pyret would evaluate a function call like
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹çœ‹ Pyret å¦‚ä½•è¯„ä¼°ä¸€ä¸ªåƒ
- en: '[PRE94]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The argument `boa("Bonito", 8)` is a value. In the same way as we substitute
    simple data types like strings and numbers for parameters when we evaluate a function,
    we do the same thing here. After substituting, we are left with the following
    expression to evaluate:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: å‚æ•° `boa("Bonito", 8)` æ˜¯ä¸€ä¸ªå€¼ã€‚å°±åƒæˆ‘ä»¬åœ¨è¯„ä¼°å‡½æ•°æ—¶ç”¨ç®€å•çš„æ•°æ®ç±»å‹ï¼ˆå¦‚å­—ç¬¦ä¸²å’Œæ•°å­—ï¼‰æ›¿æ¢å‚æ•°ä¸€æ ·ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œä¹ŸåšåŒæ ·çš„äº‹æƒ…ã€‚æ›¿æ¢åï¼Œæˆ‘ä»¬å‰©ä¸‹ä»¥ä¸‹è¡¨è¾¾å¼æ¥è¯„ä¼°ï¼š
- en: '[PRE95]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Next, Pyret determines which case matches the data (the first one, for `boa`,
    in this case). It then substitutes the field names with the corresponding components
    of the datum result expression for the matched case. In this case, we will substitute
    uses of `n` with `"Bonito"` and uses of `l` with `8`. In this program, the entire
    result expression is a use of `n`, so the result of the program in this case is
    `"Bonito"`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼ŒPyret ç¡®å®šå“ªä¸ªæƒ…å†µä¸æ•°æ®åŒ¹é…ï¼ˆåœ¨è¿™ä¸ªä¾‹å­ä¸­æ˜¯ `boa` çš„ç¬¬ä¸€ä¸ªæƒ…å†µï¼‰ã€‚ç„¶åï¼Œå®ƒå°†å­—æ®µåæ›¿æ¢ä¸ºåŒ¹é…æƒ…å†µçš„ datum ç»“æœè¡¨è¾¾å¼çš„ç›¸åº”ç»„ä»¶ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°†
    `n` çš„ä½¿ç”¨æ›¿æ¢ä¸º `"Bonito"`ï¼Œå°† `l` çš„ä½¿ç”¨æ›¿æ¢ä¸º `8`ã€‚åœ¨è¿™ä¸ªç¨‹åºä¸­ï¼Œæ•´ä¸ªç»“æœè¡¨è¾¾å¼æ˜¯ `n` çš„ä½¿ç”¨ï¼Œæ‰€ä»¥è¿™ä¸ªæƒ…å†µä¸‹ç¨‹åºçš„ç»“æœæ˜¯ `"Bonito"`ã€‚
