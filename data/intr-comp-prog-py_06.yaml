- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: STRUCTURED TYPES AND MUTABILITY
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化类型与可变性
- en: 'The programs we have looked at so far have dealt with three types of objects:
    `int`, `float`, and `str`. The numeric types `int` and `float` are scalar types.
    That is to say, objects of these types have no accessible internal structure.
    In contrast, `str` can be thought of as a structured, or non-scalar, type. We
    can use indexing to extract individual characters from a string and slicing to
    extract substrings.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所查看的程序处理了三种类型的对象：`int`、`float`和`str`。数值类型`int`和`float`是标量类型。也就是说，这些类型的对象没有可访问的内部结构。相比之下，`str`可以被认为是结构化或非标量类型。我们可以使用索引提取字符串中的单个字符，并使用切片提取子字符串。
- en: In this chapter, we introduce four additional structured types. One, `tuple`,
    is a simple generalization of `str`. The other three—`list, range`, and `dict`—are
    more interesting. We also return to the topic of higher-order programming with
    some examples that illustrate the utility of being able to treat functions in
    the same way as other types of objects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍四种额外的结构化类型。其中，`tuple`是对`str`的简单概括。其他三种——`list`、`range`和`dict`——则更有趣。我们还将回到高阶编程的话题，通过一些示例说明能够以与其他类型的对象相同的方式对待函数的实用性。
- en: 5.1 Tuples
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 元组
- en: Like strings, **tuples** are immutable ordered sequences of elements. The difference
    is that the elements of a tuple need not be characters. The individual elements
    can be of any type, and need not be of the same type as each other.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 像字符串一样，**元组**是不可变的有序元素序列。不同之处在于，元组的元素不一定是字符。单个元素可以是任何类型，且不必彼此具有相同类型。
- en: Literals of type `tuple` are written by enclosing a comma-separated list of
    elements within parentheses. For example, we can write
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为`tuple`的字面量是通过将用逗号分隔的元素列表括在圆括号中来书写的。例如，我们可以写
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Unsurprisingly, the `print` statements produce the output
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 不出所料，`print`语句产生的输出是
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Looking at this example, you might think that the tuple containing the single
    value `1` would be written `(1)`. But, to quote H.R. Haldeman quoting Richard
    Nixon, “it would be wrong.” [^(33)](#c5-fn-0001) Since parentheses are used to
    group expressions, `(1)` is merely a verbose way to write the integer `1`. To
    denote the singleton tuple containing this value, we write `(1,)`. Almost everybody
    who uses Python has at one time or another accidentally omitted that annoying
    comma.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 看这个例子，你可能会认为包含单一值`1`的元组应该写作`(1)`。但是，引用H.R. Haldeman引用理查德·尼克松的话，“这样做是错误的。” [^(33)](#c5-fn-0001)
    由于圆括号用于分组表达式，`(1)`仅仅是写整数`1`的一种冗长方式。为了表示包含此值的单例元组，我们写作`(1,)`。几乎所有使用Python的人都有过一次或多次不小心省略那个恼人的逗号的经历。
- en: Repetition can be used on tuples. For example, the expression `3*('a', 2)` evaluates
    to `('a', 2, 'a', 2, 'a', 2)`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 可以对元组使用重复操作。例如，表达式`3*('a', 2)`的值为`('a', 2, 'a', 2, 'a', 2)`。
- en: Like strings, tuples can be concatenated, indexed, and sliced. Consider
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 像字符串一样，元组可以连接、索引和切片。考虑一下
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The second assignment statement binds the name `t2` to a tuple that contains
    the tuple to which `t1` is bound and the floating-point number `3.25`. This is
    possible because a tuple, like everything else in Python, is an object, so tuples
    can contain tuples. Therefore, the first `print` statement produces the output,
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个赋值语句将名称`t2`绑定到一个包含`t1`所绑定的元组和浮点数`3.25`的元组。这是可能的，因为元组和Python中的其他一切一样，都是一个对象，所以元组可以包含元组。因此，第一个`print`语句产生的输出是，
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The second `print` statement prints the value generated by concatenating the
    values bound to `t1` and `t2`, which is a tuple with five elements. It produces
    the output
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`print`语句打印由绑定到`t1`和`t2`的值连接生成的值，这是一个包含五个元素的元组。它产生的输出是
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The next statement selects and prints the fourth element of the concatenated
    tuple (as always in Python, indexing starts at `0`), and the statement after that
    creates and prints a slice of that tuple, producing the output
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个语句选择并打印连接后的元组的第四个元素（与往常一样，在Python中，索引从`0`开始），紧接着的语句创建并打印该元组的切片，产生的输出是
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A `for` statement can be used to iterate over the elements of a tuple. And the
    `in` operator can be used to test if a tuple contains a specific value. For example,
    the following code
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`for`语句遍历元组的元素。并且可以使用`in`运算符测试一个元组是否包含特定值。例如，以下代码
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: "prints `\uFEFF('a', 2)`."
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: "打印`\uFEFF('a', 2)`。"
- en: 5.1.1 Multiple Assignment
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 多重赋值
- en: If you know the length of a sequence (e.g., a tuple or a string), it can be
    convenient to use Python's **multiple assignment** statement to extract the individual
    elements. For example, the statement `x, y = (3, 4)`, will bind `x` to `3` and
    `y` to `4`. Similarly, the statement `a, b, c = 'xyz'` will bind `a` to `'x'`,
    `b` to `'y'`, and `c` to `'z'`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道序列的长度（例如，元组或字符串），使用Python的**多重赋值**语句提取单独元素会很方便。例如，语句`x, y = (3, 4)`会将`x`绑定为`3`，将`y`绑定为`4`。类似地，语句`a,
    b, c = 'xyz'`会将`a`绑定为`'x'`，`b`绑定为`'y'`，`c`绑定为`'z'`。
- en: This mechanism is particularly convenient when used with functions that return
    multiple value. Consider the function definition
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当与返回多个值的函数一起使用时，这种机制特别方便。考虑函数定义
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The multiple assignment statement
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 多重赋值语句
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: will bind `min_divisor` to `2` and `max_divisor` to `200`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将`min_divisor`绑定为`2`，将`max_divisor`绑定为`200`。
- en: 5.2 Ranges and Iterables
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 范围与可迭代对象
- en: As discussed in Section 2.6, the function `range` produces an object of type
    `range`. Like strings and tuples, objects of type `range` are immutable. All of
    the operations on tuples are also available for ranges, except for concatenation
    and repetition. For example, `range(10)[2:6][2`] evaluates to `4`. When the `==`
    operator is used to compare objects of type `range`, it returns `True` if the
    two ranges represent the same sequence of integers. For example, `range(0, 7,
    2) == range(0, 8, 2)` evaluates to `True`. However, `range(0, 7, 2) == range(6,
    -1, -2)` evaluates to `False` because though the two ranges contain the same integers,
    they occur in a different order.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如第2.6节所述，函数`range`生成`range`类型的对象。与字符串和元组一样，`range`类型的对象是不可变的。所有元组上的操作也适用于范围，除了连接和重复。例如，`range(10)[2:6][2]`的结果是`4`。当使用`==`运算符比较`range`类型的对象时，如果两个范围表示相同的整数序列，则返回`True`。例如，`range(0,
    7, 2) == range(0, 8, 2)`的结果为`True`。然而，`range(0, 7, 2) == range(6, -1, -2)`的结果为`False`，因为虽然两个范围包含相同的整数，但它们的顺序不同。
- en: Unlike objects of type `tuple`, the amount of space occupied by an object of
    type `range` is not proportional to its length. Because a range is fully defined
    by its start, stop, and step values, it can be stored in a small amount of space.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与`tuple`类型的对象不同，`range`类型的对象所占用的空间与其长度无关。因为一个范围完全由其起始、结束和步长值定义，所以它可以存储在较小的空间中。
- en: The most common use of `range` is in `for` loops, but objects of type `range`
    can be used anywhere a sequence of integers can be used.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`range`最常见的用法是在`for`循环中，但`range`类型的对象可以在任何可以使用整数序列的地方使用。'
- en: In Python 3, `range` is a special case of an **iterable** **object**. All iterable
    types have a method,[^(34)](#c5-fn-0002) `__iter__` that returns an object of
    **type iterator**. The iterator can then be used in a `for` loop to return a sequence
    of objects, one at a time. For example, tuples are iterable, and the `for` statement
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3中，`range`是**可迭代** **对象**的特例。所有可迭代类型都有一个方法，[^(34)](#c5-fn-0002)`__iter__`，返回**类型迭代器**的对象。然后，可以在`for`循环中使用该迭代器逐个返回对象序列。例如，元组是可迭代的，`for`语句
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: creates an iterator that will return the elements of the tuple one at a time.
    Python has many built-in iterable types, including strings, lists, and dictionaries.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个迭代器，逐个返回元组的元素。Python有许多内置的可迭代类型，包括字符串、列表和字典。
- en: Many useful built-in functions operate on iterables. Among the more useful are
    `sum`, `min`, and `max`. The function `sum` can be applied to iterables of numbers.
    It returns the sum of the elements. The functions `max` and `min` can be applied
    to iterables for which there is a well-defined ordering on the elements.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 许多有用的内置函数可以作用于可迭代对象。其中一些更有用的包括`sum`、`min`和`max`。函数`sum`可以应用于数字的可迭代对象，返回元素的总和。函数`max`和`min`可以应用于有明确定义的元素顺序的可迭代对象。
- en: '**Finger exercise:** Write an expression that evaluates to the mean of a tuple
    of numbers. Use the function `sum`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**指尖练习：** 写一个表达式，计算一个数字元组的均值。使用函数`sum`。'
- en: 5.3 Lists and Mutability
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 列表与可变性
- en: Like a tuple, a **list** is an ordered sequence of values, where each value
    is identified by an index. The syntax for expressing literals of type `list` is
    similar to that used for tuples; the difference is that we use square brackets
    rather than parentheses. The empty list is written as `[]`, and singleton lists
    are written without that (oh so easy to forget) comma before the closing bracket.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 像元组一样，**列表**是值的有序序列，每个值由索引标识。`list`类型的文字表达语法类似于元组；不同之处在于我们使用方括号而不是圆括号。空列表写作`[]`，单例列表则写作不带（很容易忘记的）逗号的形式。
- en: Since lists are iterables, we can use a `for` statement to iterate over the
    elements in list. So, for example, the code
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表是可迭代的，我们可以使用`for`语句来迭代列表中的元素。因此，例如，代码
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: produces the output,
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 产生的输出，
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can also index into lists and slice lists, just as we can for tuples. For
    example, the code
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以像对元组一样对列表进行索引和切片。例如，代码
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: prints
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using square brackets for three different purposes (literals of type `list`,
    indexing into iterables, and slicing iterables), can lead to visual confusion.
    For example, the expression `[1,2,3,4][1:3][1]`, which evaluates to `3`, uses
    square brackets in three ways. This is rarely a problem in practice, because most
    of the time lists are built incrementally rather than written as literals.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 用方括号执行三种不同的用途（`list`类型的文字、对可迭代对象的索引和对可迭代对象的切片）可能导致视觉上的混淆。例如，表达式`[1,2,3,4][1:3][1]`，它的值为`3`，在三种方式中使用了方括号。这在实践中很少成为问题，因为大多数时候，列表是逐步构建的，而不是作为文字书写的。
- en: 'Lists differ from tuples in one hugely important way: lists are **mutable**.
    In contrast, tuples and strings are **immutable**. Many operators can be used
    to create objects of immutable types, and variables can be bound to objects of
    these types. But objects of immutable types cannot be modified after they are
    created. On the other hand, objects of mutable types can be modified after they
    are created.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表与元组在一个重要方面不同：列表是**可变**的。相反，元组和字符串是**不可变**的。许多运算符可用于创建不可变类型的对象，并且变量可以绑定到这些类型的对象。但不可变类型的对象在创建后无法被修改。另一方面，可变类型的对象在创建后可以被修改。
- en: The distinction between mutating an object and assigning an object to a variable
    may, at first, appear subtle. However, if you keep repeating the mantra, “In Python
    a variable is merely a name, i.e., a label that can be attached to an object,”
    it will bring you clarity. And perhaps the following set of examples will also
    help.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 修改对象和将对象赋值给变量之间的区别在开始时可能看起来微妙。然而，如果你不断重复这个咒语：“在Python中，变量仅仅是一个名称，即可以附加到对象上的标签，”这会带来清晰的理解。或许下面的一组示例也会有所帮助。
- en: When the statements
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些语句
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: are executed, the interpreter creates two new lists and binds the appropriate
    variables to them, as pictured in [Figure 5-1](#c5-fig-0001).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些语句执行时，解释器创建两个新列表并将适当的变量绑定到它们，如[图 5-1](#c5-fig-0001)所示。
- en: '![c5-fig-0001.jpg](../images/c5-fig-0001.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0001.jpg](../images/c5-fig-0001.jpg)'
- en: '[Figure 5-1](#c5-fig-0001a) Two lists'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-1](#c5-fig-0001a) 两个列表'
- en: The assignment statements
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值语句
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: also create new lists and bind variables to them. The elements of these lists
    are themselves lists. The three print statements
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以创建新列表并将变量绑定到它们。这些列表的元素本身也是列表。三个打印语句
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: produce the output
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 产生的输出
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It appears as if `Univs` and `Univs1` are bound to the same value. But appearances
    can be deceiving. As [Figure 5-2](#c5-fig-0002) illustrates, `Univs` and `Univs1`
    are bound to quite different values.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来好像`Univs`和`Univs1`绑定到相同的值。但表象可能会欺骗。如[图 5-2](#c5-fig-0002)所示，`Univs`和`Univs1`绑定到完全不同的值。
- en: '![c5-fig-0002.jpg](../images/c5-fig-0002.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0002.jpg](../images/c5-fig-0002.jpg)'
- en: '[Figure 5-2](#c5-fig-0002a) Two lists that appear to have the same value, but
    don''t'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-2](#c5-fig-0002a) 两个看似具有相同值但实际上不相同的列表'
- en: That `Univs` and `Univs1` are bound to different objects can be verified using
    the built-in Python function `**id**`, which returns a unique integer identifier
    for an object. This function allows us to test for **object equality** by comparing
    their id. A simpler way to test for object equality is to use the `**is**` operator.
    When we run the code
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Univs`和`Univs1`绑定到不同对象可以通过内置Python函数`**id**`验证，该函数返回对象的唯一整数标识符。这个函数使我们能够通过比较它们的id来测试**对象相等性**。测试对象相等性的更简单方法是使用`**is**`运算符。当我们运行代码时'
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: it prints
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: (Don't expect to see the same unique identifiers if you run this code. The semantics
    of Python says nothing about what identifier is associated with each object; it
    merely requires that no two objects have the same identifier.)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: （如果你运行这段代码，不要指望看到相同的唯一标识符。Python的语义并未说明每个对象关联的标识符是什么；它仅要求没有两个对象具有相同的标识符。）
- en: Notice that in [Figure 5-2](#c5-fig-0002) the elements of `Univs` are not copies
    of the lists to which `Techs` and `Ivys` are bound, but are rather the lists themselves.
    The elements of `Univs1` are lists that contain the same elements as the lists
    in `Univs`, but they are not the same lists. We can see this by running the code
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在[图 5-2](#c5-fig-0002)中，`Univs`的元素不是与`Techs`和`Ivys`绑定的列表的副本，而是这些列表本身。`Univs1`的元素是包含与`Univs`中列表相同元素的列表，但它们不是相同的列表。我们可以通过运行代码来看到这一点
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: which prints
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 其打印结果为
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Why the big fuss about the difference between value and object equality? It
    matters because lists are mutable. Consider the code
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么值与对象相等之间的差异会引起如此大的关注？这很重要，因为列表是可变的。考虑以下代码
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `append` method for lists has a **side effect**. Rather than create a new
    list, it mutates the existing list, `Techs`, by adding a new element, the string
    `'RPI'` in this example, to the end of it. [Figure 5-3](#c5-fig-0003) depicts
    the state of the computation after `append` is executed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的`append`方法有一个**副作用**。它不是创建一个新列表，而是通过在现有列表`Techs`的末尾添加一个新元素（本例中是字符串`'RPI'`）来修改现有列表。[图
    5-3](#c5-fig-0003) 描绘了执行`append`后计算的状态。
- en: '![c5-fig-0003.jpg](../images/c5-fig-0003.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0003.jpg](../images/c5-fig-0003.jpg)'
- en: '[Figure 5-3](#c5-fig-0003a) Demonstration of mutability'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-3](#c5-fig-0003) 可变性的演示'
- en: The object to which `Univs` is bound still contains the same two lists, but
    the contents of one of those lists has been changed. Consequently, the `print`
    statements
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Univs`绑定的对象仍然包含相同的两个列表，但其中一个列表的内容已被更改。因此，`print`语句
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: now produce the output
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在生成的输出是
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: What we have here is called **aliasing**. There are two distinct paths to the
    same list object. One path is through the variable `Techs` and the other through
    the first element of the `list` object to which `Univs` is bound. We can mutate
    the object via either path, and the effect of the mutation will be visible through
    both paths. This can be convenient, but it can also be treacherous. Unintentional
    aliasing leads to programming errors that are often enormously hard to track down.
    For example, what do you think is printed by
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的叫做**别名**。有两条不同的路径指向同一个列表对象。一条路径通过变量`Techs`，另一条通过与`Univs`绑定的`list`对象的第一个元素。我们可以通过任一条路径修改对象，并且修改的效果将通过两条路径可见。这可能很方便，但也可能是危险的。无意中的别名会导致编程错误，这些错误往往非常难以追踪。例如，你认为以下代码打印什么
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: "It prints `\uFEFFL1 = [[0, 1], [0, 1]] but L2 = [[0], [1]]`. Why? Because the\
    \ first assignment statement creates a list with two elements, each of which is\
    \ the same object, whereas the second assignment statement creates a list with\
    \ two different objects, each of which is initially equal to an empty list."
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: "它打印出`\uFEFFL1 = [[0, 1], [0, 1]]`但`L2 = [[0], [1]]`。为什么？因为第一个赋值语句创建了一个包含两个元素的列表，而这两个元素是同一个对象，而第二个赋值语句创建了一个包含两个不同对象的列表，这两个对象最初都是空列表。"
- en: '**Finger exercise:** What does the following code print?'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**手指练习：** 以下代码打印什么？'
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The interaction of aliasing and mutability with default parameter values is
    something to watch out for. Consider the code
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 别名和可变性与默认参数值的相互作用是需要注意的事项。考虑以下代码
- en: '[PRE27]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: "You might think that the second call to `append_val` would print the list `[4]`\
    \ because it would have appended `4` to the empty list. In fact, it will print\
    \ `\uFEFF[3, 4]`. This happens because, at function definition time, a new object\
    \ of type `list` is created, with an initial value of the empty list. Each time\
    \ `append_val` is invoked without supplying a value for the formal parameter `list_1`,\
    \ the object created at function definition is bound to `list_1`, mutated, and\
    \ then printed. So, the second call to `append_val` mutates and then prints a\
    \ list that was already mutated by the first call to that function."
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: "你可能认为第二次调用`append_val`会打印出列表`[4]`，因为它会将`4`添加到空列表中。实际上，它将打印`\uFEFF[3, 4]`。这是因为在函数定义时，创建了一个新类型为`list`的对象，初始值为空列表。每次调用`append_val`而不提供正式参数`list_1`的值时，函数定义时创建的对象会绑定到`list_1`，被修改，然后被打印。因此，第二次调用`append_val`会修改并打印已经被第一次调用该函数修改过的列表。"
- en: When we append one list to another, e.g., `Techs.append(Ivys)`, the original
    structure is maintained. The result is a list that contains a list. Suppose we
    do not want to maintain this structure, but want to add the elements of one list
    into another list. We can do that by using list concatenation (using the `+` operator)
    or the `extend` method, e.g.,
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将一个列表附加到另一个列表时，例如`Techs.append(Ivys)`，原始结构保持不变。结果是一个包含列表的列表。假设我们不想保持这种结构，而是想将一个列表的元素添加到另一个列表中。我们可以使用列表连接（使用`+`运算符）或`extend`方法来做到这一点，例如，
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: will print
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将打印
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that the operator `+` does not have a side effect. It creates a new list
    and returns it. In contrast, `extend` and `append` each mutate `L1`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，运算符`+`没有副作用。它创建一个新列表并返回它。相反，`extend`和`append`都会改变`L1`。
- en: '[Figure 5-4](#c5-fig-0004) briefly describes some of the methods associated
    with lists. Note that all of these except `count` and `index` mutate the list.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-4](#c5-fig-0004) 简要描述了一些与列表相关的方法。请注意，除了`count`和`index`，所有这些方法都会改变列表。'
- en: '![c5-fig-0004.jpg](../images/c5-fig-0004.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0004.jpg](../images/c5-fig-0004.jpg)'
- en: '[Figure 5-4](#c5-fig-0004a) Common methods associated with lists'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-4](#c5-fig-0004a) 与列表相关的常见方法'
- en: 5.3.1 Cloning
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 克隆
- en: It is usually prudent to avoid mutating a list over which one is iterating.
    Consider the code
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，避免在迭代时改变一个列表是明智的。考虑以下代码
- en: '[PRE30]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You might be surprised to discover that this prints
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶地发现这会打印
- en: '[PRE31]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: During a `for` loop, Python keeps track of where it is in the list using an
    internal counter that is incremented at the end of each iteration. When the value
    of the counter reaches the current length of the list, the loop terminates. This
    works as you might expect if the list is not mutated within the loop, but can
    have surprising consequences if the list is mutated. In this case, the hidden
    counter starts out at `0`, discovers that `L1[0]` is in `L2`, and removes it—reducing
    the length of `L1` to `3`. The counter is then incremented to `1`, and the code
    proceeds to check if the value of `L1[1]` is in `L2`. Notice that this is not
    the original value of `L1[1]` (i.e., `2`), but rather the current value of `L1[1]`
    (i.e., `3`). As you can see, it is possible to figure out what happens when the
    list is modified within the loop. However, it is not easy. And what happens is
    likely to be unintentional, as in this example.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环期间，Python 使用一个内部计数器跟踪当前在列表中的位置，该计数器在每次迭代结束时递增。当计数器的值达到列表的当前长度时，循环终止。如果在循环中列表没有被改变，这样的行为是可以预期的，但如果列表被改变，可能会有意想不到的后果。在这种情况下，隐藏的计数器初始值为`0`，发现`L1[0]`在`L2`中，并将其移除——将`L1`的长度减少到`3`。计数器接着递增到`1`，代码继续检查`L1[1]`的值是否在`L2`中。请注意，这不是`L1[1]`的原始值（即`2`），而是`L1[1]`的当前值（即`3`）。正如你所看到的，弄清楚在循环中修改列表时发生了什么是可能的，但并不容易。而且，发生的事情可能是无意的，就像这个例子一样。
- en: One way to avoid this kind of problem is to use slicing to **clone**[^(35)](#c5-fn-0003)
    (i.e., make a copy of) the list and write `for e1 in L1[:]`. Notice that writing
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这种问题的一种方法是使用切片来**克隆**[^(35)](#c5-fn-0003)（即，创建一个副本）列表，并写作`for e1 in L1[:]`。请注意，写作
- en: '[PRE32]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: would not solve the problem. It would not create a copy of `L1`, but would merely
    introduce a new name for the existing list.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 并不会解决问题。它不会创建`L1`的副本，而仅仅为现有列表引入一个新名称。
- en: Slicing is not the only way to clone lists in Python. The expression `L.copy()`
    has the same value as `L[:]`. Both slicing and `copy` perform what is known as
    a **shallow copy**. A shallow copy creates a new list and then inserts the objects
    (not copies of the objects) of the list to be copied into the new list. The code
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 切片并不是在 Python 中克隆列表的唯一方法。表达式`L.copy()`与`L[:]`的值相同。切片和`copy`都执行所谓的**浅拷贝**。浅拷贝创建一个新列表，然后将要复制列表的对象（而不是对象的副本）插入到新列表中。代码
- en: '[PRE33]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: "prints `\uFEFFL1 = [[2, 3]] L2 = [[2, 3]]` because both `L1` and `L2` contain\
    \ the object that was bound to `L` in the first assignment statement."
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: "打印`\uFEFFL1 = [[2, 3]] L2 = [[2, 3]]`，因为`L1`和`L2`都包含在第一条赋值语句中绑定到`L`的对象。"
- en: "If the list to be copied contains mutable objects that you also want to copy,\
    \ import the standard library module `copy` and use the function `copy.deepcopy`\
    \ to make a **deep copy**. The method `deepcopy` creates a new list and then inserts\
    \ copies of the objects in the list to be copied into the new list. If we replace\
    \ the third line in the above code by \uFEFF`L2 = copy.deepcopy(L1)`, it will\
    \ print `\uFEFFL1 = [[2, 3]], L2 = [[2]]`, because `L1` would not contain the\
    \ object to which `L` is bound."
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要复制的列表包含可变对象且你也希望复制它们，请导入标准库模块`copy`并使用`copy.deepcopy`函数进行**深复制**。方法`deepcopy`创建一个新列表，然后将待复制列表中的对象复制到新列表中。如果我们将上述代码的第三行替换为`L2
    = copy.deepcopy(L1)`，它将打印`L1 = [[2, 3]], L2 = [[2]]`，因为`L1`不会包含`L`所绑定的对象。
- en: Understanding `copy.deepcopy` is tricky if the elements of a list are lists
    containing lists (or any mutable type). Consider
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表的元素是包含列表（或任何可变类型）的列表，理解`copy.deepcopy`会比较棘手。考虑
- en: '[PRE34]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: "The value of `L3` will be `\uFEFF[[[2]]]` because `copy.deepcopy` creates a\
    \ new object not only for the list `[L1]`, but also for the list `L1`. I.e., it\
    \ makes copies all the way to the bottom—most of the time. Why “most of the time?”\
    \ The code"
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`L3`的值将为`[[[2]]]`，因为`copy.deepcopy`不仅为列表`[L1]`创建新对象，也为列表`L1`创建新对象。也就是说，它会复制到最底层——大多数情况下。为什么是“大多数情况下”？代码'
- en: '[PRE35]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: creates a list that contains itself. An attempt to make copies all the way to
    the bottom would never terminate. To avoid this problem, `copy.deepcopy` makes
    exactly one copy of each object, and then uses that copy for each instance of
    the object. This matters even when lists do not contain themselves. For example,
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含自身的列表。尝试复制到最底层将永远不会终止。为了解决这个问题，`copy.deepcopy`对每个对象仅制作一次副本，然后在每个对象实例中使用该副本。即使在列表不包含自身的情况下，这也很重要。例如，
- en: '[PRE36]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: "prints `\uFEFF[[2, 3], [2, 3]]` because `copy.deepcopy` makes one copy of `L1`\
    \ and uses it both times `L1` occurs in `L2`."
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 打印`[[2, 3], [2, 3]]`，因为`copy.deepcopy`对`L1`进行了一次复制，并在`L2`中两次使用。
- en: 5.3.2 List Comprehension
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 列表推导式
- en: '**List comprehension** provides a concise way to apply an operation to the
    sequence values provided by iterating over an iterable value. It creates a new
    list in which each element is the result of applying a given operation to a value
    from an iterable (e.g., the elements in another list). It is an expression of
    the form'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表推导式**提供了一种简洁的方式，通过迭代可迭代对象的值来应用操作。它创建一个新列表，其中每个元素是对可迭代对象中的某个值（例如，另一个列表的元素）应用给定操作的结果。其表达形式为'
- en: '[PRE37]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Evaluating the expression is equivalent to invoking the function
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 评估该表达式等同于调用函数
- en: '[PRE38]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: "For example, `[e**2 for e in range(6)] evaluates to \uFEFF[0, 1, 4, 9, 16,\
    \ 25], [e**2 for e in range(8) if e%2 == 0]` evaluates to `\uFEFF[0, 4, 16, 36]`,\
    \ and `\uFEFF[x**2 for x in [2, 'a', 3, 4.0] if type(x) == int]` evaluates to\
    \ `\uFEFF[4, 9]`."
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`[e**2 for e in range(6)]`评估为`[0, 1, 4, 9, 16, 25]`，`[e**2 for e in range(8)
    if e%2 == 0]`评估为`[0, 4, 16, 36]`，`[x**2 for x in [2, 'a', 3, 4.0] if type(x) ==
    int]`评估为`[4, 9]`。
- en: "List comprehension provides a convenient way to initialize lists. For example,\
    \ `\uFEFF[[] for _ in range(10)]` generates a list containing 10 distinct (i.e.,\
    \ non-aliased) empty lists. The variable name `_` indicates that the values of\
    \ that variable are not used in generating the elements of list, i.e., it is merely\
    \ a placeholder. This convention is common in Python programs."
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式提供了一种方便的方式来初始化列表。例如，`[[] for _ in range(10)]`生成一个包含10个不同（即非别名）空列表的列表。变量名`_`表示该变量的值未在生成列表的元素中使用，即它仅是一个占位符。这种约定在Python程序中很常见。
- en: Python allows multiple `for` statements within a list comprehension. Consider
    the code
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许在列表推导式中使用多个`for`语句。考虑以下代码
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The Python interpreter starts by evaluating the first `for`, assigning to `x`
    the sequence of values `0,2,4`. For each of these three values of `x`, it evaluates
    the second `for` (which generates the sequence of values `0,3` each time). It
    then adds to the list being generated the tuple `(x, y)`, producing the list
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Python解释器首先评估第一个`for`，将值序列`0,2,4`赋给`x`。对于这三个`x`的值，它会评估第二个`for`（每次生成值序列`0,3`）。然后它将元组`(x,
    y)`添加到正在生成的列表中，从而生成列表
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Of course, we can produce the same list without list comprehension, but the
    code is considerably less compact:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以不使用列表推导式生成相同的列表，但代码会显得相对不够简洁：
- en: '[PRE41]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The following code is an example of nesting a list comprehension within a list
    comprehension.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是将列表推导式嵌套在另一个列表推导式中的示例。
- en: '[PRE42]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: "It prints `\uFEFF[[(0, 0), (2, 0), (4, 0)], [(0, 3), (2, 3), (4, 3)]]`."
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印`[[ (0, 0), (2, 0), (4, 0)], [(0, 3), (2, 3), (4, 3)]]`。
- en: It takes practice to get comfortable with nested list comprehensions, but they
    can be quite useful. Let's use nested list comprehensions to generate a list of
    all prime numbers less than 100\. The basic idea is to use one comprehension to
    generate a list of all of the candidate numbers (i.e., 2 through 99), a second
    comprehension to generate a list of the remainders of dividing a candidate prime
    by each potential divisor, and the built-in function `all` to test if any of those
    remainders is 0.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉嵌套列表推导需要实践，但它们可以非常有用。让我们使用嵌套列表推导生成一个小于100的所有质数的列表。基本思想是使用一个推导生成所有候选数字的列表（即2到99），第二个推导生成将候选质数除以每个潜在除数的余数的列表，以及使用内置函数`all`来测试这些余数中是否有任何为0。
- en: '[PRE43]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Evaluating the expression is equivalent to invoking the function
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 评估表达式等同于调用该函数
- en: '[PRE44]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**Finger exercise:** Write a list comprehension that generates all non-primes
    between 2 and 100.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**手指练习**：编写一个列表推导，生成2到100之间的所有非质数。'
- en: Some Python programmers use list comprehensions in marvelous and subtle ways.
    That is not always a great idea. Remember that somebody else may need to read
    your code, and “subtle” is rarely a desirable property for a program.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Python程序员以奇妙而微妙的方式使用列表推导。这并不总是一个好主意。请记住，其他人可能需要阅读你的代码，而“微妙”通常不是程序的理想属性。
- en: 5.4 Higher-Order Operations on Lists
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 列表的高阶操作
- en: In Section 4.4 we introduced the notion of higher-order programming. It can
    be particularly convenient with lists, as shown in [Figure 5-5](#c5-fig-0005).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4.4节中，我们介绍了高阶编程的概念。对于列表来说，它特别方便，如[图 5-5](#c5-fig-0005)所示。
- en: '![c5-fig-0005.jpg](../images/c5-fig-0005.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0005.jpg](../images/c5-fig-0005.jpg)'
- en: '[Figure 5-5](#c5-fig-0005a) Applying a function to elements of a list'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-5](#c5-fig-0005a) 对列表元素应用函数'
- en: The function `apply_to_each` is called **higher-order** because it has an argument
    that is itself a function. The first time it is called, it mutates `L` by applying
    the unary built-in function `abs` to each element. The second time it is called,
    it applies a type conversion to each element. And the third time it is called,
    it replaces each element by the result of applying a function defined using `lambda`.
    It prints
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`apply_to_each`被称为**高阶**，因为它的参数本身就是一个函数。第一次调用时，它通过对每个元素应用一元内置函数`abs`来修改`L`。第二次调用时，它对每个元素进行类型转换。第三次调用时，它通过应用使用`lambda`定义的函数来替换每个元素。它打印
- en: '[PRE45]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: "Python has a built-in higher-order function, `map`, that is similar to, but\
    \ more general than, the `apply_to_each` function defined in [Figure 5-5](#c5-fig-0005).\
    \ In its simplest form the first argument to `map` is a unary function (i.e.,\
    \ a function that has only one parameter) and the second argument is any ordered\
    \ collection of values suitable as arguments to the first argument. It is frequently\
    \ used in lieu of a list comprehension. For example, \uFEFF`list(map(str, range(10)))`\
    \ is equivalent to `\uFEFF[str(e) for e in range(10)]`."
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个内置的高阶函数`map`，它类似于但比[图 5-5](#c5-fig-0005)中定义的`apply_to_each`函数更通用。在它最简单的形式中，`map`的第一个参数是一个一元函数（即只有一个参数的函数），第二个参数是适合作为第一个参数的值的任何有序集合。它通常用作列表推导的替代。例如，`list(map(str,
    range(10)))`等价于`[str(e) for e in range(10)]`。
- en: The `map` function is often used with a `for` loop. When used in a `for` loop,
    `map` behaves like the `range` function in that it returns one value for each
    iteration of the loop. These values are generated by applying the first argument
    to each element of the second argument. For example, the code
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`函数通常与`for`循环一起使用。在`for`循环中使用时，`map`的行为类似于`range`函数，它为循环的每次迭代返回一个值。这些值是通过将第一个参数应用于第二个参数的每个元素生成的。例如，代码'
- en: '[PRE46]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: prints
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '[PRE47]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: More generally, the first argument to `map` can be a function of `n` arguments,
    in which case it must be followed by `n` subsequent ordered collections (each
    of the same length). For example, the code
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地说，`map`的第一个参数可以是一个有`n`个参数的函数，此时它必须后跟`n`个后续有序集合（每个集合长度相同）。例如，代码
- en: '[PRE48]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: prints
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '[PRE49]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '**Finger exercise**: Implement a function satisfying the following specification.
    Hint: it will be convenient to use `lambda` in the body of the implementation.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**手指练习**：实现一个满足以下规范的函数。提示：在实现的主体中使用`lambda`会很方便。'
- en: '[PRE50]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 5.5 Strings, Tuples, Ranges, and Lists
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 字符串、元组、范围和列表
- en: 'We have looked at four iterable sequence types: `str`, `tuple`, `range`, and
    `list`. They are similar in that objects of these types can be operated upon as
    described in [Figure 5-6](#c5-fig-0006). Some of their other similarities and
    differences are summarized in [Figure 5-7](#c5-fig-0007).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过四种可迭代的序列类型：`str`、`tuple`、`range` 和 `list`。它们相似之处在于这些类型的对象可以按照[图 5-6](#c5-fig-0006)中描述的方式进行操作。它们的其他一些相似性和差异在[图
    5-7](#c5-fig-0007)中总结。
- en: '![c5-fig-0006.jpg](../images/c5-fig-0006.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0006.jpg](../images/c5-fig-0006.jpg)'
- en: '[Figure 5-6](#c5-fig-0006a) Common operations on sequence types'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-6](#c5-fig-0006a) 序列类型的常见操作'
- en: '![c5-fig-0007.jpg](../images/c5-fig-0007.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0007.jpg](../images/c5-fig-0007.jpg)'
- en: '[Figure 5-7](#c5-fig-0007a) Comparison of sequence types'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-7](#c5-fig-0007) 序列类型的比较'
- en: Python programmers tend to use lists far more often than tuples. Since lists
    are mutable, they can be constructed incrementally during a computation. For example,
    the following code incrementally builds a list containing all of the even numbers
    in another list.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Python 程序员往往比使用元组更频繁地使用列表。由于列表是可变的，因此可以在计算过程中逐步构建。例如，以下代码逐步构建一个包含另一个列表中所有偶数的列表。
- en: '[PRE51]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Since strings can contain only characters, they are considerably less versatile
    than tuples or lists. On the other hand, when you are working with a string of
    characters, there are many useful built-in methods. [Figure 5-8](#c5-fig-0008)
    contains short descriptions of a few of them. Keep in mind that since strings
    are immutable, these all return values and have no side effect.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串只能包含字符，因此它们的通用性远不如元组或列表。另一方面，当你处理字符字符串时，有许多有用的内置方法。[图 5-8](#c5-fig-0008)包含了其中一些方法的简短描述。请记住，由于字符串是不可变的，这些方法都返回值，并且没有副作用。
- en: '![c5-fig-0008.jpg](../images/c5-fig-0008.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0008.jpg](../images/c5-fig-0008.jpg)'
- en: '[Figure 5-8](#c5-fig-0008a) Some methods on strings'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-8](#c5-fig-0008) 字符串上的一些方法'
- en: One of the more useful built-in methods is `split`, which takes two strings
    as arguments. The second argument specifies a separator that is used to split
    the first argument into a sequence of substrings. For example,
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更有用的内置方法是 `split`，它接受两个字符串作为参数。第二个参数指定一个分隔符，用于将第一个参数拆分为一系列子字符串。例如，
- en: '[PRE52]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: prints
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '[PRE53]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The second argument is optional. If that argument is omitted, the first string
    is split using arbitrary strings of **whitespace characters** (space, tab, newline,
    return, and formfeed).[^(36)](#c5-fn-0004)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是可选的。如果省略该参数，第一个字符串将使用任意的**空白字符**（空格、制表符、换行符、回车和换页）进行分割。[^(36)](#c5-fn-0004)
- en: 5.6 Sets
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6 集合
- en: '**Sets** are yet another kind of collection type. They are similar to the notion
    of a set in mathematics in that they are unordered collections of unique elements.
    They are denoted using what programmers call curly braces and mathematicians call
    set braces, e.g.,'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**集合**是另一种集合类型。它们类似于数学中的集合概念，因为它们是无序的独特元素集合。它们用程序员称之为大括号、数学家称之为集合括号的符号表示，例如，'
- en: '[PRE54]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Since the elements of a set are unordered, attempting to index into a set, e.g.,
    evaluating `baseball_teams[0],` generates a runtime error. We can use a `for`
    statement to iterate over the elements of a set, but unlike the other collection
    types we have seen, the order in which the elements are produced is undefined.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集合的元素是无序的，尝试索引集合，例如，评估 `baseball_teams[0]` 会产生运行时错误。我们可以使用 `for` 语句来迭代集合的元素，但与我们看到的其他集合类型不同，元素产生的顺序是未定义的。
- en: Like lists, sets are mutable. We add a single element to a set using the `add`
    method. We add multiple elements to a set by passing a collection of elements
    (e.g., a list) to the `update` method. For example, the code
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 像列表一样，集合是可变的。我们使用 `add` 方法向集合中添加单个元素。通过将元素集合（例如列表）传递给 `update` 方法来向集合中添加多个元素。例如，代码
- en: '[PRE55]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: prints
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '[PRE56]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: (The order in which the elements appear is not defined by the language, so you
    might get a different output if you run this example.)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: （元素出现的顺序并不由语言定义，因此如果运行此示例，可能会得到不同的输出。）
- en: Elements can be removed from a set using the `remove` method, which raises an
    error if the element is not in the set, or the `discard` method, which does not
    raise an error if the element is not in the set.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `remove` 方法从集合中移除元素，如果元素不在集合中则会引发错误，或者使用 `discard` 方法，如果元素不在集合中则不会引发错误。
- en: "Membership in a set can be tested using the `in` operator. For example, `\uFEFF\
    'Rockies' in baseball_teams` returns `True`. The binary methods `union`, `intersection`,\
    \ `difference`, and `issubset` have their usual mathematical meanings. For example,"
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: "可以使用 `in` 运算符测试一个对象是否属于集合。例如，`\uFEFF'Rockies' in baseball_teams` 返回 `True`。二元方法\
    \ `union`、`intersection`、`difference` 和 `issubset` 具有通常的数学含义。例如，"
- en: '[PRE57]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: prints
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '[PRE58]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: One of the nice things about sets is that there are convenient infix operators
    for many of the methods, including `|` for `union`, `&` for `intersect`, `-` for
    `difference`, `<=` for `subse`t, and `>=` for `superset`. Using these operators
    makes code easier to read. Compare, for example,
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的一个好处是许多方法都有方便的中缀运算符，包括 `|` 表示 `union`，`&` 表示 `intersect`，`-` 表示 `difference`，`<=`
    表示 `subset`，以及 `>=` 表示 `superset`。使用这些运算符可以使代码更易读。例如比较，
- en: '[PRE59]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: to the code presented earlier, which uses dot notation to print the same values.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前呈现的代码相同，它使用点表示法打印相同的值。
- en: Not all types of objects can be elements of sets. All objects in a set must
    be **hashable**. An object is hashable if it has
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有类型的对象都可以成为集合的元素。集合中的所有对象必须是**可哈希的**。一个对象是可哈希的，如果它有
- en: A `__hash__` method that maps the object of the type to an `int`, and the value
    returned by `__hash__` does not change during the lifetime of the object, and
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将对象映射到 `int` 的 `__hash__` 方法，并且 `__hash__` 返回的值在对象生命周期内不会改变，并且
- en: An `__eq__` method that is used to compare it for equality to other objects.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于比较它与其他对象相等的 `__eq__` 方法。
- en: All objects of Python's scalar immutable types are hashable, and no object of
    Python's built-in mutable types is hashable. An object of a non-scalar immutable
    type (e.g., a tuple) is hashable if all of its elements are hashable.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的标量不可变类型的所有对象都是可哈希的，而 Python 内置的可变类型的对象则不可哈希。一个非标量不可变类型的对象（例如，元组）是可哈希的，当且仅当它的所有元素都是可哈希的。
- en: 5.7 Dictionaries
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.7 字典
- en: Objects of type `**dict**` (short for **dictionary**) are like lists except
    that we index them using **keys** rather than integers. Any hashable object can
    be used as a key. Think of a dictionary as a set of key/value pairs. Literals
    of type `dict` are enclosed in curly braces and each element is written as a key
    followed by a colon followed by a **value**. For example, the code,
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`**dict**` 类型的对象（即**字典**的缩写）与列表类似，只不过我们使用**键**而不是整数来索引它们。任何可哈希对象都可以用作键。可以将字典视为键/值对的集合。类型
    `dict` 的字面量用大括号括起来，每个元素写为键后跟冒号再跟**值**。例如，代码'
- en: '[PRE60]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: will print
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将打印
- en: '[PRE61]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The entries in a `dict` cannot be accessed using an index. That's why `month_numbers[1]`
    unambiguously refers to the entry with the key `1` rather than the second entry.
    Whether a key is defined in a dictionary can be tested using the `in` operator.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict` 中的条目不能使用索引访问。这就是为什么 `month_numbers[1]` 明确指向键为 `1` 的条目，而不是第二个条目。可以使用
    `in` 运算符测试一个键是否在字典中定义。'
- en: Like lists, dictionaries are mutable. We can add an entry by writing, for example,
    `month_numbers['June'] = 6` or change an entry by writing, for example, `month_numbers['May']
    = 'V'.`
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 像列表一样，字典是可变的。我们可以通过编写，例如，`month_numbers['June'] = 6` 来添加条目，或通过编写，例如，`month_numbers['May']
    = 'V'.` 来更改条目。
- en: Dictionaries are one of the great things about Python. They greatly reduce the
    difficulty of writing a variety of programs. For example, in [Figure 5-9](#c5-fig-0009)
    we use dictionaries to write a (pretty horrible) program to translate between
    languages.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是 Python 的一大亮点。它们大大减少了编写各种程序的难度。例如，在 [图 5-9](#c5-fig-0009) 中，我们使用字典编写了一个（相当糟糕的）程序来进行语言之间的翻译。
- en: The code in the figure prints
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的代码打印
- en: '[PRE62]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Remember that dictionaries are mutable. So, be careful about side effects. For
    example,
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，字典是可变的。因此，要注意副作用。例如，
- en: '[PRE63]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: will print
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将打印
- en: '[PRE64]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '![c5-fig-0009.jpg](../images/c5-fig-0009.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0009.jpg](../images/c5-fig-0009.jpg)'
- en: '[Figure 5-9](#c5-fig-0009a) Translating text (badly)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-9](#c5-fig-0009a) 翻译文本（糟糕地）'
- en: Many programming languages do not contain a built-in type that provides a mapping
    from keys to values. Instead, programmers use other types to provide similar functionality.
    It is, for example, relatively easy to implement a dictionary by using a list
    in which each element is a tuple representing a key/value pair. We can then write
    a simple function that does the associative retrieval, e.g.,
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言没有内置类型来提供从键到值的映射。相反，程序员使用其他类型来提供类似的功能。例如，使用列表实现字典相对简单，其中每个元素是表示键/值对的元组。然后我们可以编写一个简单的函数来进行关联检索，例如，
- en: '[PRE65]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The problem with such an implementation is that it is computationally inefficient.
    In the worst case, a program might have to examine each element in the list to
    perform a single retrieval. In contrast, the built-in implementation is fast.
    It uses a technique called hashing, described in Chapter 12, to do the lookup
    in time that is nearly independent of the size of the dictionary.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现的问题在于其计算效率低下。在最坏的情况下，程序可能必须检查列表中的每个元素才能执行一次检索。相比之下，内置实现速度很快。它使用了一种称为哈希的技术，如第12章所述，能够在几乎不依赖字典大小的时间内进行查找。
- en: There are multiple ways to use a `for` statement to iterate over the entries
    in a dictionary. If `d` is a dictionary, a loop of the form `for k in d` iterates
    over the keys of `d`. The order in which the keys are chosen is the order in which
    the keys were inserted in the dictionary.[^(37)](#c5-fn-0005) For example,
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以使用`for`语句遍历字典中的条目。如果`d`是一个字典，形式为`for k in d`的循环会遍历`d`的键。选择键的顺序是根据它们在字典中插入的顺序。[^(37)](#c5-fn-0005)
    例如，
- en: '[PRE66]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: prints
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '[PRE67]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: To iterate over the values in a dictionary, we can use the method `values`.
    For example,
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历字典中的值，我们可以使用`values`方法。例如，
- en: '[PRE68]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: "prints `\uFEFF['Paris', 'Rome', 'Kyoto'] is a list of capital cities`."
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: "打印`\uFEFF['巴黎', '罗马', '京都'] 是一个首都城市的列表`。"
- en: The method `values` returns an object of type `dict_values`. This is an example
    of a **view object**. A view object is dynamic in that if the object with which
    it is associated changes, the change is visible through the view object. For example,
    the code
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`values`方法返回类型为`dict_values`的对象。这是一个**视图对象**的示例。视图对象是动态的，如果与之关联的对象发生更改，变化将通过视图对象可见。例如，代码'
- en: '[PRE69]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: prints
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '[PRE70]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: "Similarly, the method `keys` returns a view object of type `dict_keys`. View\
    \ objects can be converted to lists, e.g., `list(capitals.values())` returns \uFEFF\
    a list of the values in capitals."
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`keys`方法返回类型为`dict_keys`的视图对象。视图对象可以转换为列表，例如，`list(capitals.values())`返回一个包含首都值的列表。
- en: To iterate over key/value pairs, we use the method `items`. This method returns
    a view object of type `dict_items`. Each element of an object of type `dict_items`
    is a `tuple` of a key and its associated value. For example, the code
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历键/值对，我们使用`items`方法。此方法返回类型为`dict_items`的视图对象。类型为`dict_items`的对象的每个元素都是一个包含键及其关联值的`tuple`。例如，代码
- en: '[PRE71]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: prints
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '[PRE72]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '**Finger exercise:** Implement a function that meets the specification'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**指尖练习：** 实现一个满足规范的函数'
- en: '[PRE73]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: It is often convenient to use tuples as keys. Imagine, for example, using a
    tuple of the form `(flight_number, day)` to represent airline flights. It would
    then be easy to use such tuples as keys in a dictionary implementing a mapping
    from flights to arrival times. A list cannot be used as key, because objects of
    type list are not hashable.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用元组作为键通常很方便。想象一下，使用形式为`(flight_number, day)`的元组来表示航空公司航班。然后很容易将这些元组作为键用于实现航班与到达时间映射的字典。列表不能用作键，因为列表类型的对象是不可哈希的。
- en: As we have seen, there are many useful methods associated with dictionaries,
    including some for removing elements. We do not enumerate all of them here, but
    will use them as convenient in examples later in the book. [Figure 5-10](#c5-fig-0010)
    contains some of the more useful operations on dictionaries.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，字典有许多有用的方法，包括一些用于删除元素的方法。我们不会在这里列举所有这些方法，但在书中的示例中会方便地使用它们。[图 5-10](#c5-fig-0010)
    包含一些更有用的字典操作。
- en: '![c5-fig-0010.jpg](../images/c5-fig-0010.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0010.jpg](../images/c5-fig-0010.jpg)'
- en: '[Figure 5-10](#c5-fig-0010a) Some common operations on dicts'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-10](#c5-fig-0010a) 字典上的一些常见操作'
- en: 5.8 Dictionary Comprehension
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.8 字典推导式
- en: '**Dictionary comprehension** is similar to list comprehension. The general
    form is'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**字典推导式**类似于列表推导式。一般形式是'
- en: '[PRE74]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The key difference (other than the use of set braces rather than square braces)
    is that it uses two values to create each element of the dictionary, and allows
    (but does not require) the iterable to return two values at a time. Consider a
    dictionary mapping some decimal digits to English words:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 关键区别（除了使用大括号而不是方括号）是它使用两个值来创建字典的每个元素，并允许（但不要求）可迭代对象同时返回两个值。考虑一个将某些十进制数字映射到英语单词的字典：
- en: '[PRE75]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We can easily use dictionary comprehension to produce a dictionary that maps
    words to digits with
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地使用字典推导式来生成一个将单词映射到数字的字典。
- en: '[PRE76]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: If we decide that we only want single digit numbers in `word_to_number`, we
    can use the comprehension
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定只想在`word_to_number`中使用单个数字，我们可以使用推导式。
- en: '[PRE77]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Now, let's try something more ambitious. A cipher is an algorithm that maps
    a plain text (a text that can be easily read by a human) to a crypto text. The
    simplest ciphers are substitution ciphers that replace each character in the plain
    text with a unique string. The mapping from the original characters to the string
    that replaces them is called a key (by analogy with the kind of key used to open
    a lock, not the kind of key used in Python dictionaries). In Python, dictionaries
    provide a convenient way to implement mappings that can be used to code and decode
    text.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一些更有挑战性的内容。**密码**是一种算法，它将**明文**（人类可以轻松阅读的文本）映射到**密文**。最简单的密码是替换密码，它用一个独特的字符串替换明文中的每个字符。从原始字符到替换它们的字符串的映射称为**密钥**（与打开锁所用的钥匙类似，而不是用于Python字典的那种钥匙）。在Python中，字典提供了一种方便的方式来实现可以用于编码和解码文本的映射。
- en: A **book cipher** is a cipher for which the key is derived from a book. For
    example, it might map each character in the plain text to the numeric index of
    the first occurrence of that character in the book (or on a page of the book).
    The assumption is that the sender and receiver of the coded message have previously
    agreed on the book, but an adversary who intercepts the coded message does not
    know what book was used to code it.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**书本密码**是一种密钥来源于书籍的密码。例如，它可能将明文中的每个字符映射到该字符在书中首次出现的数字索引（或书页上的索引）。假设发送者和接收者之前已达成一致使用的书，但拦截编码信息的对手并不知道使用了哪本书。'
- en: The following function definition uses dictionary comprehension to create a
    dictionary that can be used for encoding a plain text using a book cipher.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数定义使用字典推导创建一个字典，该字典可用于使用书本密码编码明文。
- en: '[PRE78]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: If `plain_text` were “no is no” and `book` started with “Once upon a time, in
    a house in a land far away,” the call `gen_code_keys(book, plain_text)` would
    return
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `plain_text` 是 “no is no” 并且 `book` 以 “从前，在一个遥远的地方有一所房子” 开头，则调用 `gen_code_keys(book,
    plain_text)` 会返回。
- en: '[PRE79]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Notice, by the way, that o gets mapped to seven rather than zero because o and
    O are different characters. If `book` were the text of *Don Quixote*,[^(38)](#c5-fn-0006)
    the call `gen_code_keys(book, plain_text)` would return
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，o 映射为七而不是零，因为 o 和 O 是不同的字符。如果 `book` 是 *堂吉诃德* 的文本，[^(38)](#c5-fn-0006)
    调用 `gen_code_keys(book, plain_text)` 将返回。
- en: '[PRE80]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Now that we have our coding dictionary, we can use list comprehension to define
    a function that uses it to encrypt a plain text
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了编码字典，可以使用列表推导定义一个函数，利用它来加密明文。
- en: '[PRE81]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Since characters in the plain text might be replaced by multiple characters
    in the cipher text, we use `*` to separate characters in the cipher text. The
    `.join` operator is used to turn the list of strings into a single string.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 由于明文中的字符可能被多个字符替换为密文中的字符，我们使用 `*` 来分隔密文中的字符。`.join` 操作符用于将字符串列表转换为单个字符串。
- en: The function `encrypt` uses `gen_code_keys` and `encoder` to encrypt a plain
    text
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `encrypt` 使用 `gen_code_keys` 和 `encoder` 来加密明文。
- en: '[PRE82]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The call `encrypt(Don_Quixote, 'no is no')` returns
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `encrypt(Don_Quixote, 'no is no')` 返回。
- en: '[PRE83]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Before we can decode the cipher text, we need to build a decoding dictionary.
    The easy thing to do would be to invert the coding dictionary, but that would
    be cheating. The whole point of a book cipher is that the sender sends an encrypted
    message, but not any information about the keys. The only thing the receiver needs
    to decode the message is access to the book that the encoder used. The following
    function definition uses dictionary comprehension to build a decoding key from
    the book and the coded message.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够解码密文之前，需要构建一个解码字典。简单的做法是反转编码字典，但那样会不诚实。书本密码的核心在于发送者发送加密信息，但没有关于密钥的任何信息。接收者解码信息所需的唯一条件是获得编码者使用的书。以下函数定义使用字典推导从书和编码信息构建解码密钥。
- en: '[PRE84]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: "The call `\uFEFFgen_decode_keys(Don_Quixote, '1*13*2*6*57*2*1*13')` would produce\
    \ the decrypting key"
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `gen_decode_keys(Don_Quixote, '1*13*2*6*57*2*1*13')` 会产生解密密钥。
- en: '[PRE85]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: If a character occurs in the plain text but not in the book, something bad happens.
    The `code_keys` dictionary will map each such character to `-1`, and `decode_keys`
    will map `-1` to whatever the last character in the book happens to be.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果明文中出现的字符在书中不存在，就会发生一些不好的事情。`code_keys` 字典会将每个这样的字符映射到 `-1`，而 `decode_keys`
    会将 `-1` 映射到书中最后一个字符。
- en: '**Finger exercise**: Remedy the problem described in the previous paragraph.
    Hint: a simple way to do this is to create a new book by appending something to
    the original book.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**指尖练习**：解决上一段描述的问题。提示：简单的方法是通过向原始书籍附加内容来创建一本新书。'
- en: '**Finger exercise**: Using `encoder` and `encrypt` as models, implement the
    functions `decoder` and `decrypt`. Use them to decrypt the message'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**指尖练习**：以`encoder`和`encrypt`为模型，实现`decoder`和`decrypt`函数。使用它们解密消息'
- en: '[PRE86]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: which was encrypted using the opening of *Don Quixote*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*唐吉诃德*的开头进行加密。
- en: 5.9 Terms Introduced in Chapter
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.9 章节引入的术语
- en: tuple
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组
- en: multiple assignment
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重赋值
- en: iterable object
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可迭代对象
- en: type iterator
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型迭代器
- en: list
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表
- en: mutable type
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变类型
- en: immutable type
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变类型
- en: id function
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: id函数
- en: object equality
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象相等
- en: side effect
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 副作用
- en: aliasing
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 别名
- en: cloning
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆
- en: shallow copy
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浅拷贝
- en: deep copy
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深拷贝
- en: list comprehension
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表推导式
- en: higher-order function
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数
- en: whitespace character
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空白字符
- en: set
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: hashable type
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可哈希类型
- en: dictionary
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典
- en: keys
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键
- en: value
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值
- en: view object
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图对象
- en: dictionary comprehension
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典推导式
- en: book cipher
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书本密码
