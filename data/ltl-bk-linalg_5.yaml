- en: The LAB
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验室
- en: 原文：[https://little-book-of.github.io/linear-algebra/books/en-US/lab.html](https://little-book-of.github.io/linear-algebra/books/en-US/lab.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://little-book-of.github.io/linear-algebra/books/en-US/lab.html](https://little-book-of.github.io/linear-algebra/books/en-US/lab.html)
- en: Chapter 1\. Vectors, scalars, and geometry
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一章. 向量、标量和几何
- en: 1\. Scalars, Vectors, and Coordinate Systems
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1. 标量、向量和坐标系
- en: 'Let’s get our hands dirty! This lab is about playing with the *building blocks*
    of linear algebra: scalars and vectors. Think of a scalar as just a plain number,
    like `3` or `-1.5`. A vector is a small list of numbers, which you can picture
    as an arrow in space.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们动手实践！这个实验是关于玩线性代数的 *基本构建块*：标量和向量。将标量视为一个普通的数字，比如 `3` 或 `-1.5`。向量是一小串数字，你可以将其想象为空间中的箭头。
- en: We’ll use Python (with NumPy) to explore them. Don’t worry if this is your first
    time with NumPy - we’ll go slowly.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Python（与NumPy一起）来探索它们。如果你是第一次使用NumPy，不要担心——我们会慢慢来。
- en: Set Up Your Lab
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*That’s it - we’re ready! NumPy is the main tool we’ll use for linear algebra.*  *####
    Step-by-Step Code Walkthrough'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*这就完成了——我们准备好了！NumPy是我们将用于线性代数的主要工具。*  *#### 逐步代码讲解'
- en: Scalars are just numbers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 标量只是数字。
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*[PRE2]*  *Vectors are lists of numbers.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE2]*  *向量是数字的列表。'
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*[PRE4]*  *Coordinates tell us where we are. Think of `[2, 3]` as “go 2 steps
    in the x-direction, 3 steps in the y-direction.”'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE4]*  *坐标告诉我们我们在哪里。将 `[2, 3]` 视为“在x方向上走2步，在y方向上走3步。”'
- en: 'We can even *draw* it:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以 *绘制* 它：
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*![](../Images/5a3607f4b32724c983fa329537dcf6fc.png)*  *This makes a little
    arrow from the origin `(0,0)` to `(2,3)`.***  ***#### Try It Yourself'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/5a3607f4b32724c983fa329537dcf6fc.png)*  *这会从原点 `(0,0)` 到 `(2,3)`
    画出一个箭头。***  ***#### 尝试一下'
- en: Change the vector `v` to `[4, 1]`. Where does the arrow point now?
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将向量 `v` 更改为 `[4, 1]`。现在箭头指向哪里？
- en: Try making a 3D vector with 4 numbers, like `[1, 2, 3, 4]`. What happens?
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试制作一个包含4个数字的3D向量，例如 `[1, 2, 3, 4]`。会发生什么？
- en: Replace `np.array([2,3])` with `np.array([0,0])`. What does the arrow look like?****  ***###
    2\. Vector Notation, Components, and Arrows
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `np.array([2,3])` 替换为 `np.array([0,0])`。箭头看起来像什么？****  ***### 2. 向量表示法、分量和箭头
- en: In this lab, we’ll practice reading, writing, and visualizing vectors in different
    ways. A vector can look simple at first - just a list of numbers - but how we
    *write* it and how we *interpret* it really matters. This is where notation and
    components come into play.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们将练习以不同的方式读取、编写和可视化向量。一开始，向量可能看起来很简单——只是一个数字列表——但我们如何 *书写* 它以及我们如何 *解释*
    它真的很重要。这正是符号和分量发挥作用的地方。
- en: 'A vector has:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个向量有：
- en: A symbol (we might call it `v`, `w`, or even `→AB` in geometry).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个符号（我们可能称之为 `v`、`w`，甚至在几何中称之为 `→AB`）。
- en: Components (the individual numbers, like `2` and `3` in `[2, 3]`).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分量（单个数字，如 `[2, 3]` 中的 `2` 和 `3`）。
- en: An arrow picture (a geometric way to see the vector as a directed line segment).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个箭头图（一种将向量视为有向线段的方法）。
- en: Let’s see all three in action with Python.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用Python看看这三个操作。
- en: Set Up Your Lab
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Writing vectors in Python
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python中编写向量
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*[PRE8]*  *Here `v` has components `(2, 3)` and `w` has components `(1, -1,
    4)`.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE8]*  *在这里 `v` 的分量是 `(2, 3)`，而 `w` 的分量是 `(1, -1, 4)`。'
- en: Accessing components Each number in the vector is a *component*. We can pick
    them out using indexing.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问分量 向量中的每个数字都是一个 *分量*。我们可以使用索引来挑选它们。
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*[PRE10]*  *Notice: in Python, indices start at `0`, so `v[0]` is the *first*
    component.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE10]*  *注意：在Python中，索引从 `0` 开始，所以 `v[0]` 是 *第一个* 分量。'
- en: Visualizing vectors as arrows In 2D, it’s easy to draw a vector from the origin
    `(0,0)` to its endpoint `(x,y)`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在2D中，将向量视为箭头很容易，从原点 `(0,0)` 到其终点 `(x,y)`。
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*![](../Images/ec80c79cd6f849d29241fce12f25f133.png)*  *This shows vector v
    as a red arrow from `(0,0)` to `(2,3)`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/ec80c79cd6f849d29241fce12f25f133.png)*  *这显示了向量v作为一个从 `(0,0)`
    到 `(2,3)` 的红色箭头。'
- en: Drawing multiple vectors We can plot several arrows at once to compare them.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制多个向量 我们可以同时绘制几个箭头来比较它们。
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*![](../Images/f68beaac55212c7ba347fee7231081c3.png)*  *Now you’ll see three
    arrows starting at the same point, each pointing in a different direction.****  ***####
    Try It Yourself'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/f68beaac55212c7ba347fee7231081c3.png)*  *现在你会看到三个箭头，它们从同一点开始，每个箭头指向不同的方向。****  ***####
    尝试一下'
- en: Change `v` to `[5, 0]`. What does the arrow look like now?
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `v` 更改为 `[5, 0]`。现在箭头看起来像什么？
- en: Try a vector like `[0, -3]`. Which axis does it line up with?
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试一个向量如 `[0, -3]`。它与哪个轴对齐？
- en: Make a new vector `q = np.array([2, 0, 0])`. What happens if you try to plot
    it with `plt.quiver` in 2D?****  ***### 3\. Vector Addition and Scalar Multiplication
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的向量 `q = np.array([2, 0, 0])`。如果你尝试用 `plt.quiver` 在 2D 中绘制它会发生什么？****  ***###
    3. 向量加法和标量乘法
- en: 'In this lab, we’ll explore the two most fundamental operations you can perform
    with vectors: adding them together and scaling them by a number (a scalar). These
    operations form the basis of everything else in linear algebra, from geometry
    to machine learning. Understanding how they work, both in code and visually, is
    key to building intuition.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验室中，我们将探索你可以对向量执行的两个最基本操作：将它们相加并将它们乘以一个数（标量）。这些操作是线性代数中其他所有内容的基础，从几何学到机器学习。理解它们如何在代码中和视觉上工作，对于建立直觉至关重要。
- en: Set Up Your Lab
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Vector addition When you add two vectors, you simply add their components one
    by one.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向量加法 当你加两个向量时，你只需逐个相加它们的分量。
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*[PRE15]*  *Here, `(2,3) + (1,-1) = (3,2)`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE15]*  *这里，`(2,3) + (1,-1) = (3,2)`。'
- en: Visualizing vector addition (tip-to-tail method) Graphically, vector addition
    means placing the tail of one vector at the head of the other. The resulting vector
    goes from the start of the first to the end of the second.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化向量加法（尾对尾方法）从图形上看，向量加法意味着将一个向量的尾端放在另一个向量的起点。结果向量从第一个向量的起点延伸到第二个向量的终点。
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*![](../Images/24c9b4a14e7428e0011d7e6b7a2945d8.png)*  *The green arrow is
    the result of adding `v` and `u`.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/24c9b4a14e7428e0011d7e6b7a2945d8.png)*  *绿色箭头是 `v` 和 `u` 相加的结果。'
- en: Scalar multiplication Multiplying a vector by a scalar stretches or shrinks
    it. If the scalar is negative, the vector flips direction.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标量乘法 将一个向量乘以一个标量会拉伸或缩小它。如果标量是负数，向量会翻转方向。
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*[PRE18]*  *So `2 * (2,3) = (4,6)` and `-1 * (2,3) = (-2,-3)`.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE18]*  *所以 `2 * (2,3) = (4,6)` 和 `-1 * (2,3) = (-2,-3)`。'
- en: Visualizing scalar multiplication
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化标量乘法
- en: '[PRE19]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*![](../Images/ff749a52dbaf032f6ec065b9394b4c88.png)*  *Here, the blue arrow
    is twice as long as the red arrow, while the green arrow points in the opposite
    direction.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/ff749a52dbaf032f6ec065b9394b4c88.png)*  *这里，蓝色箭头是红色箭头的两倍长，而绿色箭头指向相反的方向。'
- en: Combining both operations We can scale vectors and then add them. This is called
    a linear combination (and it’s the foundation for the next section).
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结合两种操作 我们可以缩放向量然后相加。这被称为线性组合（它是下一节的基础）。
- en: '[PRE20]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*[PRE21]*****  ***#### Try It Yourself'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE21]*****  ***#### 尝试自己操作'
- en: Replace `c = 2` with `c = 0.5`. What happens to the vector?
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `c = 2` 替换为 `c = 0.5`。向量会发生什么变化？
- en: 'Try adding three vectors: `v + u + np.array([-1,2])`. Can you predict the result
    before printing?'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试添加三个向量：`v + u + np.array([-1,2])`。在打印之前你能预测结果吗？
- en: Visualize `3*v + 2*u` using arrows. How does it compare to just `v + u`?****  ***###
    4\. Linear Combinations and Span
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用箭头可视化 `3*v + 2*u`。它与 `v + u` 有何不同？****  ***### 4. 线性组合和范围
- en: 'Now that we know how to add vectors and scale them, we can combine these two
    moves to create linear combinations. A linear combination is just a recipe: multiply
    vectors by scalars, then add them together. The set of all possible results you
    can get from such recipes is called the span.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何添加向量和缩放它们，我们可以结合这两个动作来创建线性组合。线性组合只是一个配方：将向量乘以标量，然后将它们相加。从这样的配方中可以得到的所有可能结果的集合称为范围。
- en: This idea is powerful because span tells us what directions and regions of space
    we can reach using given vectors.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法很强大，因为范围告诉我们我们可以使用给定的向量达到哪些方向和空间区域。
- en: Set Up Your Lab
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Linear combinations in Python
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python 中的线性组合
- en: '[PRE23]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*[PRE24]*  *Here, we multiplied and added vectors using scalars. Each result
    is a new vector.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE24]*  *这里，我们使用了标量乘法和加法来乘法和加法向量。每个结果都是一个新向量。'
- en: Visualizing linear combinations Let’s plot `v`, `u`, and their combinations.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化线性组合 让我们绘制 `v`、`u` 和它们的组合。
- en: '[PRE25]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*![](../Images/917c473dd3d518353b37910186a72b84.png)*  *This shows how new
    arrows can be generated from scaling and adding the original ones.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/917c473dd3d518353b37910186a72b84.png)*  *这显示了如何通过缩放和添加原始箭头来生成新的箭头。'
- en: 'Exploring the span The span of two 2D vectors is either:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 探索范围 两个 2D 向量的范围是：
- en: A line (if one is a multiple of the other).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条线（如果它是另一条线的倍数）。
- en: The whole 2D plane (if they are independent).
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个 2D 平面（如果它们是独立的）。
- en: '[PRE26]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*![](../Images/f0bf1cab2386e70472f7667b98e35c71.png)*  *The gray dots show
    all reachable points with combinations of `v` and `u`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/f0bf1cab2386e70472f7667b98e35c71.png)*  *灰色点显示了使用 `v` 和 `u`
    的组合所能达到的所有点。'
- en: 'Special case: dependent vectors'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特殊情况：相关向量
- en: '[PRE27]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*![](../Images/9a3bff45697a7ebc4a8d4f898ac7022d.png)*  *Here, the span collapses
    to a line because `w` is just a scaled copy of `v`.****  ***#### Try It Yourself'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/9a3bff45697a7ebc4a8d4f898ac7022d.png)*  *在这里，由于`w`只是`v`的缩放副本，所以范围缩小成了一条线。****  ***####
    尝试自己操作'
- en: Replace `u = [1,3]` with `u = [-1,2]`. What does the span look like?
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`u = [1,3]`替换为`u = [-1,2]`。范围看起来像什么？
- en: Try three vectors in 2D (e.g., `v, u, w`). Do you get more than the whole plane?
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在二维空间中用三个向量（例如，`v, u, w`）。你是否得到了整个平面？
- en: Experiment with 3D vectors. Use `np.array([x,y,z])` and check whether different
    vectors span a plane or all of space.****  ***### 5\. Length (Norm) and Distance
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在三维空间中实验向量。使用`np.array([x,y,z])`并检查不同的向量是否跨越一个平面或整个空间。****  ***### 5. 长度（范数）和距离
- en: 'In this lab, we’ll measure how big a vector is (its length, also called its
    norm) and how far apart two vectors are (their distance). These ideas connect
    algebra to geometry: when we compute a norm, we’re measuring the size of an arrow;
    when we compute a distance, we’re measuring the gap between two points in space.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们将测量向量的大小（其长度，也称为其范数）以及两个向量之间的距离。这些想法将代数与几何联系起来：当我们计算范数时，我们是在测量箭头的大小；当我们计算距离时，我们是在测量空间中两点之间的间隔。
- en: Set Up Your Lab
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置你的实验环境
- en: '[PRE28]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Vector length (norm) in 2D The length of a vector is computed using the Pythagorean
    theorem. For a vector `(x, y)`, the length is `sqrt(x² + y²)`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二维空间中的向量长度（范数）向量的长度是通过勾股定理计算的。对于一个向量`(x, y)`，其长度是`sqrt(x² + y²)`。
- en: '[PRE29]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*[PRE30]*  *This prints `5.0`, because `(3,4)` forms a right triangle with
    sides 3 and 4, and `sqrt(3²+4²)=5`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE30]*  *这打印出`5.0`，因为`(3,4)`与边长为3和4的直角三角形形成，且`sqrt(3²+4²)=5`。'
- en: Manual calculation vs NumPy
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动计算与NumPy
- en: '[PRE31]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*[PRE32]*  *Both give the same result.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE32]*  *两者给出相同的结果。'
- en: Visualizing vector length
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化向量长度
- en: '[PRE33]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*![](../Images/04cfb44175ad74ab63140dc3267c160a.png)*  *You’ll see the arrow
    `(3,4)` with its length labeled.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/04cfb44175ad74ab63140dc3267c160a.png)*  *你会看到带有长度标签的箭头`(3,4)`。'
- en: 'Distance between two vectors The distance between `v` and another vector `u`
    is the length of their difference: `‖v - u‖`.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个向量之间的距离 `v` 和另一个向量 `u` 之间的距离是它们差值的长度：`‖v - u‖`。
- en: '[PRE34]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*[PRE35]*  *Since `u` is the origin, this is just the length of `v`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE35]*  *由于`u`是原点，这仅仅是`v`的长度。'
- en: A more interesting distance
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个更有趣的距离
- en: '[PRE36]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*[PRE37]*  *This measures how far `(3,4)` is from `(1,1)`.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE37]*  *这测量了`(3,4)`与`(1,1)`的距离。'
- en: Visualizing distance between points
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化点之间的距离
- en: '[PRE38]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*![](../Images/373a87dc071b7c20ba645a697df4552d.png)*  *The dashed line shows
    the distance between the two points.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/373a87dc071b7c20ba645a697df4552d.png)*  *虚线显示了两个点之间的距离。'
- en: 'Higher-dimensional vectors Norms and distances work the same way in any dimension:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高维向量 范数和距离在任何维度上都是相同的：
- en: '[PRE39]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*[PRE40]*  *Even though we can’t draw 3D easily on paper, the formulas still
    apply.*******  ***#### Try It Yourself'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE40]*  *尽管我们难以在纸上绘制三维图形，但公式仍然适用。*******  ***#### 尝试自己操作'
- en: Compute the length of `np.array([5,12])`. What do you expect?
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算数组`np.array([5,12])`的长度。你期待什么？
- en: Find the distance between `(2,3)` and `(7,7)`. Can you sketch it by hand and
    check?
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`(2,3)`和`(7,7)`之间的距离。你能手动绘制并检查吗？
- en: In 3D, try vectors `(1,1,1)` and `(2,2,2)`. Why is the distance exactly `sqrt(3)`?****  ***###
    6\. Dot Product
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在三维空间中，尝试向量`(1,1,1)`和`(2,2,2)`。为什么距离正好是`sqrt(3)`？****  ***### 6. 点积
- en: The dot product is one of the most important operations in linear algebra. It
    takes two vectors and gives you a single number. That number combines both the
    lengths of the vectors and how much they point in the same direction. In this
    lab, we’ll calculate dot products in several ways, see how they relate to geometry,
    and visualize their meaning.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 点积是线性代数中最重要的运算之一。它接受两个向量并给出一个单一的数字。这个数字结合了向量的长度以及它们指向相同方向的程度。在这个实验中，我们将以几种不同的方式计算点积，了解它们与几何的关系，并可视化其含义。
- en: Set Up Your Lab
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置你的实验环境
- en: '[PRE41]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: 'Algebraic definition The dot product of two vectors is the sum of the products
    of their components:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代数定义 两个向量的点积是它们各分量乘积的和：
- en: '[PRE42]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*[PRE43]*  *Here, `(2*4) + (3*-1) = 8 - 3 = 5`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE43]*  *在这里，`(2*4) + (3*-1) = 8 - 3 = 5`。'
- en: 'Geometric definition The dot product also equals the product of the lengths
    of the vectors times the cosine of the angle between them:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几何定义 点积也等于向量的长度乘以它们之间角度的余弦值：
- en: \[ v \cdot u = \|v\| \|u\| \cos \theta \]
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: \[ v \cdot u = \|v\| \|u\| \cos \theta \]
- en: 'We can compute the angle:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以计算角度：
- en: '[PRE44]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*[PRE45]*  *This gives the angle between `v` and `u`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE45]*  *这给出了`v`和`u`之间的角度。'
- en: 'Visualizing the dot product Let’s draw the two vectors:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化点积 让我们画出这两个向量：
- en: '[PRE46]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*![](../Images/c7afb0b142eec45593b1a3363fccf940.png)*  *The dot product is
    positive if the angle is less than 90°, negative if greater than 90°, and zero
    if the vectors are perpendicular.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/c7afb0b142eec45593b1a3363fccf940.png)*  *点积为正时角度小于90°，为负时角度大于90°，垂直时为零。'
- en: Projections and dot product The dot product lets us compute how much of one
    vector lies in the direction of another.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 投影和点积 点积使我们能够计算一个向量在另一个向量方向上的分量。
- en: '[PRE47]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*[PRE48]*  *This is the length of the shadow of `v` onto `u`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE48]*  *这是向量 `v` 在 `u` 上的影子长度。'
- en: Special cases
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特殊情况
- en: If vectors point in the same direction, the dot product is large and positive.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果向量指向同一方向，点积较大且为正。
- en: If vectors are perpendicular, the dot product is zero.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果向量垂直，点积为零。
- en: If vectors point in opposite directions, the dot product is negative.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果向量指向相反方向，点积为负。
- en: '[PRE49]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '*[PRE50]*****  ***#### Try It Yourself'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE50]*****  ***#### 尝试自己操作'
- en: Compute the dot product of `(3,4)` with `(4,3)`. Is the result larger or smaller
    than the product of their lengths?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 `(3,4)` 与 `(4,3)` 的点积。结果是否大于或小于它们长度的乘积？
- en: Try `(1,2,3) · (4,5,6)`. Does the geometric meaning still work in 3D?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试 `(1,2,3) · (4,5,6)`。在三维空间中几何意义是否仍然有效？
- en: Create two perpendicular vectors (e.g. `(2,0)` and `(0,5)`). Verify the dot
    product is zero.****  ***### 7\. Angles Between Vectors and Cosine
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个垂直向量（例如 `(2,0)` 和 `(0,5)`）。验证点积为零。****  ***### 7. 向量与余弦之间的角度
- en: In this lab, we’ll go deeper into the connection between vectors and geometry
    by calculating angles. Angles tell us how much two vectors “point in the same
    direction.” The bridge between algebra and geometry here is the cosine formula,
    which comes directly from the dot product.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们将通过计算角度来深入了解向量与几何之间的联系。角度告诉我们两个向量“指向同一方向”的程度。代数与几何之间的桥梁是余弦公式，它直接来自点积。
- en: Set Up Your Lab
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验环境
- en: '[PRE51]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: 'Formula for the angle The angle \(\theta\) between two vectors \(v\) and \(u\)
    is given by:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 角度的公式 两个向量 \(v\) 和 \(u\) 之间的角度 \(\theta\) 由以下公式给出：
- en: \[ \cos \theta = \frac{v \cdot u}{\|v\| \, \|u\|} \]
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \cos \theta = \frac{v \cdot u}{\|v\| \, \|u\|} \]
- en: 'This means:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着：
- en: If \(\cos \theta = 1\), the vectors point in exactly the same direction.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 \(\cos \theta = 1\)，向量指向完全相同的方向。
- en: If \(\cos \theta = 0\), they are perpendicular.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 \(\cos \theta = 0\)，它们是垂直的。
- en: If \(\cos \theta = -1\), they point in opposite directions.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 \(\cos \theta = -1\)，它们指向相反方向。
- en: Computing the angle in Python
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Python 中计算角度
- en: '[PRE52]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '*[PRE53]*  *This gives both the cosine value and the actual angle.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE53]*  *这给出了余弦值和实际角度。'
- en: Visualizing the vectors
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化向量
- en: '[PRE54]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '*![](../Images/afb9916f799a2374f1fa1fcf79d592fe.png)*  *You can see the angle
    between `v` and `u` as the gap between the red and blue arrows.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/afb9916f799a2374f1fa1fcf79d592fe.png)*  *你可以看到 `v` 和 `u` 之间的角度是红箭头和蓝箭头之间的间隙。'
- en: Checking special cases
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查特殊情况
- en: '[PRE55]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '*[PRE56]*  **   Angle between `(1,0)` and `(0,1)` is 90°.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE56]*  **   `(1,0)` 和 `(0,1)` 之间的角度是 90°。'
- en: Angle between `(1,0)` and `(-1,0)` is 180°.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(1,0)` 和 `(-1,0)` 之间的角度是 180°。'
- en: 'Using cosine as a similarity measure In data science and machine learning,
    people often use cosine similarity instead of raw angles. It’s just the cosine
    value itself:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用余弦作为相似度度量 在数据科学和机器学习中，人们通常使用余弦相似度而不是原始角度。它只是余弦值本身：
- en: '[PRE57]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '*[PRE58]*  *Values close to `1` mean vectors are aligned, values near `0` mean
    unrelated, and values near `-1` mean opposite.****  ***#### Try It Yourself'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE58]*  *接近 `1` 的值表示向量对齐，接近 `0` 的值表示无关，接近 `-1` 的值表示相反。****  ***#### 尝试自己操作'
- en: Create two random vectors with `np.random.randn(3)` and compute the angle between
    them.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `np.random.randn(3)` 创建两个随机向量并计算它们之间的角度。
- en: Verify that swapping the vectors gives the same angle (symmetry).
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证交换向量是否给出相同的角（对称性）。
- en: Find two vectors where cosine similarity is exactly `0`. Can you come up with
    an example in 2D?****  ***### 8\. Projections and Decompositions
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到两个余弦相似度为 `0` 的向量。你能在二维空间中找到一个例子吗？****  ***### 8. 投影和分解
- en: 'In this lab, we’ll learn how to split one vector into parts: one part that
    lies *along* another vector, and one part that is *perpendicular*. This process
    is called projection and decomposition. Projections let us measure “how much of
    a vector points in a given direction,” and decompositions give us a way to break
    vectors into useful components.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们将学习如何将一个向量分解成两部分：一部分沿着另一个向量，另一部分是垂直的。这个过程称为投影和分解。投影让我们测量“向量在给定方向上的分量”，分解则为我们提供了将向量分解成有用分量的一种方法。
- en: Set Up Your Lab
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置实验环境
- en: '[PRE59]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码解析'
- en: 'Projection formula The projection of vector \(v\) onto vector \(u\) is:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 投影公式 向量 \(v\) 投影到向量 \(u\) 的公式是：
- en: \[ \text{proj}_u(v) = \frac{v \cdot u}{u \cdot u} \, u \]
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \text{proj}_u(v) = \frac{v \cdot u}{u \cdot u} \, u \]
- en: This gives the component of \(v\) that points in the direction of \(u\).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了 \(v\) 指向 \(u\) 方向的分量。
- en: Computing projection in Python
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Python 中计算投影
- en: '[PRE60]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '*[PRE61]*  *Here, \(v = (3,2)\) and \(u = (2,0)\). The projection of `v` onto
    `u` is a vector pointing along the x-axis.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE61]*  *在这里，\(v = (3,2)\) 和 \(u = (2,0)\)。`v` 投影到 `u` 上是一个指向 x 轴的向量。'
- en: Decomposing into parallel and perpendicular parts
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其分解为平行和垂直部分
- en: 'We can write:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以写成：
- en: \[ v = \text{proj}_u(v) + (v - \text{proj}_u(v)) \]
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: \[ v = \text{proj}_u(v) + (v - \text{proj}_u(v)) \]
- en: The first part is parallel to `u`, the second part is perpendicular.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分与 `u` 平行，第二部分是垂直的。
- en: '[PRE62]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '*[PRE63]*  *4.  Visualizing projection and decomposition'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE63]*  *4.  可视化投影和分解'
- en: '[PRE64]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '*![](../Images/16a53f9ebdb01200ad8263dbcf9a3eaa.png)*  *You’ll see `v` (red),
    `u` (blue), the projection (green), and the perpendicular remainder (magenta).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/16a53f9ebdb01200ad8263dbcf9a3eaa.png)*  *您将看到 `v`（红色），`u`（蓝色），投影（绿色），以及垂直余量（洋红色）。'
- en: Projection in higher dimensions
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高维度的投影
- en: 'This formula works in any dimension:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式在任意维度都适用：
- en: '[PRE65]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '*[PRE66]*  *Even in 3D or higher, projections are about splitting into “along”
    and “across.”****  ***#### Try It Yourself'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE66]*  *即使在 3D 或更高维度，投影也是关于“沿着”和“穿过”的分割。****  ***#### 尝试自己操作'
- en: Try projecting `(2,3)` onto `(0,5)`. Where does it land?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将 `(2,3)` 投影到 `(0,5)` 上。它落在哪里？
- en: Take a 3D vector like `(4,2,6)` and project it onto `(1,0,0)`. What does this
    give you?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以 `(4,2,6)` 这样的 3D 向量为例，将其投影到 `(1,0,0)` 上。这会得到什么？
- en: Change the base vector `u` to something not aligned with the axes, like `(1,1)`.
    Does the projection still work?****  ***### 9\. Cauchy–Schwarz and Triangle Inequalities
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将基向量 `u` 改为与轴不对齐的某个值，例如 `(1,1)`。投影是否仍然有效？****  ***### 9. 柯西-施瓦茨不等式和三角不等式
- en: This lab introduces two fundamental inequalities in linear algebra. They may
    look abstract at first, but they provide guarantees that always hold true for
    vectors. We’ll explore them with small examples in Python to see why they matter.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 本实验介绍了线性代数中的两个基本不等式。它们一开始可能看起来很抽象，但它们为向量提供了始终成立的保证。我们将通过 Python 中的小例子来探索它们，看看为什么它们很重要。
- en: Set Up Your Lab
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置实验环境
- en: '[PRE67]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码解析'
- en: Cauchy–Schwarz inequality
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 柯西-施瓦茨不等式
- en: 'The inequality states:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 不等式表明：
- en: \[ |v \cdot u| \leq \|v\| \, \|u\| \]
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: \[ |v \cdot u| \leq \|v\| \, \|u\| \]
- en: It means the dot product is never “bigger” than the product of the vector lengths.
    Equality happens only if the two vectors are pointing in exactly the same (or
    opposite) direction.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着点积永远不会“大于”向量长度的乘积。只有当两个向量指向完全相同（或相反）的方向时，等式才会成立。
- en: '[PRE68]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '*[PRE69]*  *2.  Testing Cauchy–Schwarz with different vectors'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE69]*  *2.  使用不同向量测试柯西-施瓦茨不等式'
- en: '[PRE70]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '*[PRE71]*  **   Perpendicular vectors give `|v·u| = 0`, far less than the product
    of norms.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE71]*  **   垂直向量给出 `|v·u| = 0`，远小于范数的乘积。'
- en: Multiples give equality (`lhs = rhs`).
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 倍数给出等式（`lhs = rhs`）。
- en: Triangle inequality
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三角不等式
- en: 'The triangle inequality states:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 三角不等式表明：
- en: \[ \|v + u\| \leq \|v\| + \|u\| \]
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \|v + u\| \leq \|v\| + \|u\| \]
- en: Geometrically, the length of one side of a triangle can never be longer than
    the sum of the other two sides.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 几何上，三角形的任一边长永远不会超过其他两边之和。
- en: '[PRE72]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '*[PRE73]*  *4.  Visual demonstration with a triangle'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE73]*  *4.  用三角形进行可视化演示'
- en: '[PRE74]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '*![](../Images/f98fd435cf31640d8b4193da3f48f365.png)*  *This triangle shows
    why the inequality is called the “triangle” inequality.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/f98fd435cf31640d8b4193da3f48f365.png)*  *这个三角形显示了为什么这个不等式被称为“三角”不等式。'
- en: Testing triangle inequality with random vectors
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用随机向量测试三角不等式
- en: '[PRE75]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '*[PRE76]*  *No matter what vectors you try, the inequality always holds.*****  ***####
    The Takeaway'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE76]*  *无论尝试什么向量，不等式总是成立的。*****  ***#### 总结'
- en: 'Cauchy–Schwarz: The dot product is always bounded by the product of vector
    lengths.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柯西-施瓦茨不等式：点积始终被向量长度的乘积所界定。
- en: 'Triangle inequality: The length of one side of a triangle can’t exceed the
    sum of the other two.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三角不等式：三角形的任一边长不能超过其他两边之和。
- en: These inequalities form the backbone of geometry, analysis, and many proofs
    in linear algebra.****  ***### 10\. Orthonormal Sets in ℝ²/ℝ³
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些不等式构成了几何、分析和线性代数中许多证明的骨架。****  ***### 10. ℝ²/ℝ³ 中的正交归一集合
- en: In this lab, we’ll explore orthonormal sets - collections of vectors that are
    both orthogonal (perpendicular) and normalized (length = 1). These sets are the
    “nicest” possible bases for vector spaces. In 2D and 3D, they correspond to the
    coordinate axes we already know, but we can also construct and test new ones.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们将探索正交归一集合——一组既是正交（垂直）又是归一化（长度 = 1）的向量。这些集合是向量空间中“最理想”的基。在 2D 和 3D 中，它们对应于我们已知的坐标轴，但我们可以构建和测试新的。
- en: Set Up Your Lab
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE77]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Orthogonal vectors Two vectors are orthogonal if their dot product is zero.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正交向量 如果两个向量的点积为零，则这两个向量是正交的。
- en: '[PRE78]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '*[PRE79]*  *So the standard axes are orthogonal.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE79]*  *因此，标准轴是正交的。'
- en: Normalizing vectors Normalization means dividing a vector by its length to make
    its norm equal to 1.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 归一化向量 归一化意味着将向量除以其长度，使其范数等于 1。
- en: '[PRE80]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '*[PRE81]*  *Now `v_normalized` points in the same direction as `v` but has
    unit length.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE81]*  *现在 `v_normalized` 指向与 `v` 相同的方向，但长度为 1。'
- en: Building an orthonormal set in 2D
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 2D 中构建正交归一集合
- en: '[PRE82]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '*[PRE83]*  *Both have length 1, and their dot product is 0\. That makes `{u1,
    u2}` an orthonormal set in 2D.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE83]*  *它们都有长度 1，并且它们的点积为 0。这使得 `{u1, u2}` 在 2D 中成为一个正交归一集合。'
- en: Visualizing 2D orthonormal vectors
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化 2D 正交归一向量
- en: '[PRE84]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '*![](../Images/cb7ed899fdf67e3f9f3f6c9dcda6f752.png)*  *You’ll see the red
    and blue arrows at right angles, each of length 1.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/cb7ed899fdf67e3f9f3f6c9dcda6f752.png)*  *您将看到右边的红色和蓝色箭头相互垂直，每个箭头的长度都是
    1。'
- en: 'Orthonormal set in 3D In 3D, the standard basis vectors are:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3D 中的正交归一集合 在 3D 中，标准基向量是：
- en: '[PRE85]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '*[PRE86]*  *Lengths are all 1, and dot products are 0\. So `{i, j, k}` is an
    orthonormal set in ℝ³.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE86]*  *长度都是 1，点积为 0。所以 `{i, j, k}` 是 ℝ³ 中的一个正交归一集合。'
- en: 'Testing if a set is orthonormal We can write a helper function:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试一个集合是否是正交归一 我们可以编写一个辅助函数：
- en: '[PRE87]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '*[PRE88]*  *7.  Constructing a new orthonormal pair Not all orthonormal sets
    look like the axes.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE88]*  *7.  构建一个新的正交归一对 并非所有的正交归一集合都看起来像坐标轴。'
- en: '[PRE89]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '*[PRE90]*  *This gives a rotated orthonormal basis in 2D.*******  ***#### Try
    It Yourself'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE90]*  *这给出了 2D 中的一个旋转正交基。*******  ***#### 尝试自己操作'
- en: Normalize `(2,2,1)` to make it a unit vector.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `(2,2,1)` 归一化以使其成为一个单位向量。
- en: Test whether the set `{[1,0,0], [0,2,0], [0,0,3]}` is orthonormal.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试集合 `{[1,0,0], [0,2,0], [0,0,3]}` 是否是正交归一的。
- en: Construct two vectors in 2D that are not perpendicular. Normalize them and check
    if the dot product is still zero.*******************************  ***## Chapter
    2\. Matrices and basic operations
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 2D 中构建两个不垂直的向量。将它们归一化并检查点积是否仍然为零。*******************************  ***## 第二章
    矩阵和基本运算
- en: 11\. Matrices as Tables and as Machines
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11. 矩阵作为表和作为机器
- en: 'Matrices can feel mysterious at first, but there are two simple ways to think
    about them:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵一开始可能感觉神秘，但有两种简单的方法可以思考它们：
- en: As tables of numbers - just a grid you can store and manipulate.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为数字表——只是一个可以存储和操作的网格。
- en: As machines - something that takes a vector in and spits a new vector out.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为机器——接受一个向量并输出一个新向量的东西。
- en: In this lab, we’ll explore both views and see how they connect.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们将探索两种观点并了解它们是如何相互关联的。
- en: Set Up Your Lab
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE91]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: A matrix as a table of numbers
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩阵作为数字表
- en: '[PRE92]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '*[PRE93]*  *Here, `A` is a 2×3 matrix (2 rows, 3 columns).'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE93]*  *在这里，`A` 是一个 2×3 矩阵（2 行，3 列）。'
- en: Rows = horizontal slices → `[1,2,3]` and `[4,5,6]`
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 = 水平切片 → `[1,2,3]` 和 `[4,5,6]`
- en: Columns = vertical slices → `[1,4]`, `[2,5]`, `[3,6]`
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列 = 垂直切片 → `[1,4]`, `[2,5]`, `[3,6]`
- en: Accessing rows and columns
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问行和列
- en: '[PRE94]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '*[PRE95]*  *Rows are whole vectors too, and so are columns.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE95]*  *行也是整个向量，列也是如此。'
- en: A matrix as a machine
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩阵作为机器
- en: A matrix can “act” on a vector. If `x = [x1, x2, x3]`, then `A·x` is computed
    by taking linear combinations of the columns of `A`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵可以对向量“作用”。如果 `x = [x1, x2, x3]`，则 `A·x` 通过取 `A` 的列的线性组合来计算。
- en: '[PRE96]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '*[PRE97]*  *Interpretation: multiply `A` by `x` = combine columns of `A` with
    weights from `x`.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE97]*  *解释：将 `A` 乘以 `x` = 将 `A` 的列与 `x` 的权重组合。'
- en: \[ A \cdot x = 1 \cdot \text{(col 1)} + 0 \cdot \text{(col 2)} + (-1) \cdot
    \text{(col 3)} \]
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: \[ A \cdot x = 1 \cdot \text{(列 1)} + 0 \cdot \text{(列 2)} + (-1) \cdot \text{(列
    3)} \]
- en: Verifying column combination view
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证列组合视图
- en: '[PRE98]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '*[PRE99]*  *They match exactly. This shows the “machine” interpretation is
    just a shortcut for column combinations.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE99]*  *它们完全匹配。这表明“机器”解释只是列组合的快捷方式。'
- en: Geometric intuition (2D example)
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几何直觉（2D 示例）
- en: '[PRE100]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '*[PRE101]*  *Here, `B` scales the x-direction by 2 while leaving the y-direction
    alone. So `(1,2)` becomes `(2,2)`.*****  ***#### Try It Yourself'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE101]*  *在这里，`B` 将 x 方向缩放 2 倍，而 y 方向保持不变。因此 `(1,2)` 变为 `(2,2)`。*****  ***####
    尝试自己操作'
- en: Create a 3×3 identity matrix with `np.eye(3)` and multiply it by different vectors.
    What happens?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `np.eye(3)` 创建一个 3×3 的单位矩阵，并将其与不同的向量相乘。会发生什么？
- en: Build a matrix `[[0,-1],[1,0]]`. Try multiplying it by `(1,0)` and `(0,1)`.
    What transformation is this?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个矩阵 `[[0,-1],[1,0]]`。尝试将其与 `(1,0)` 和 `(0,1)` 相乘。这是哪种变换？
- en: Create your own 2×2 matrix that flips vectors across the x-axis. Test it on
    `(1,2)` and `(−3,4)`.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建你自己的 2×2 矩阵，该矩阵将向量沿 x 轴翻转。在 `(1,2)` 和 `(−3,4)` 上测试它。
- en: The Takeaway
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 总结
- en: A matrix is both a grid of numbers and a machine that transforms vectors.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵既是数字的网格，也是一个转换向量的机器。
- en: Matrix–vector multiplication is the same as combining columns with given weights.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵-向量乘法等同于结合具有给定权重的列。
- en: Thinking of matrices as machines helps build intuition for rotations, scalings,
    and other transformations later.****  ***### 12\. Matrix Shapes, Indexing, and
    Block Views
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将矩阵视为机器有助于建立对旋转、缩放和其他变换的直觉。****  ***### 12. 矩阵形状、索引和块视图
- en: Matrices come in many shapes, and learning to read their structure is essential.
    Shape tells us how many rows and columns a matrix has. Indexing lets us grab specific
    entries, rows, or columns. Block views let us zoom in on submatrices, which is
    extremely useful for both theory and computation.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵有多种形状，学会阅读它们的结构是至关重要的。形状告诉我们矩阵有多少行和列。索引使我们能够获取特定的条目、行或列。块视图允许我们放大子矩阵，这对于理论和计算都非常有用。
- en: Set Up Your Lab
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置你的实验室
- en: '[PRE102]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码解析'
- en: Matrix shapes
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩阵形状
- en: The shape of a matrix is `(rows, columns)`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的形状是 `(行, 列)`。
- en: '[PRE103]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '*[PRE104]*  *Here, `A` is a 3×3 matrix.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE104]*  *在这里，`A` 是一个 3×3 矩阵。'
- en: Indexing elements
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 元素索引
- en: In NumPy, rows and columns are 0-based. The first entry is `A[0,0]`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NumPy 中，行和列是从 0 开始计数的。第一个条目是 `A[0,0]`。
- en: '[PRE105]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '*[PRE106]*  *3.  Extracting rows and columns'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE106]*  *3.  提取行和列'
- en: '[PRE107]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '*[PRE108]*  *Notice: `A[i]` gives a row, `A[:,j]` gives a column.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE108]*  *注意：`A[i]` 返回一行，`A[:,j]` 返回一列。'
- en: Slicing submatrices (block view)
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切割子矩阵（块视图）
- en: You can slice multiple rows and columns to form a smaller matrix.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过切片多行和多列来形成一个较小的矩阵。
- en: '[PRE109]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '*[PRE110]*  *This block is:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE110]*  *此块是：'
- en: \[ \begin{bmatrix} 2 & 3 \\ 5 & 6 \end{bmatrix} \]
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{bmatrix} 2 & 3 \\ 5 & 6 \end{bmatrix} \]
- en: Modifying parts of a matrix
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改矩阵的部分
- en: '[PRE111]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '*[PRE112]*  *6.  Non-square matrices'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE112]*  *6.  非方阵'
- en: Not all matrices are square. Shapes can be rectangular, too.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有矩阵都是方阵。形状也可以是矩形的。
- en: '[PRE113]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '*[PRE114]*  *Here, `B` is 3×2 (3 rows, 2 columns).'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE114]*  *在这里，`B` 是 3×2（3 行，2 列）。'
- en: Block decomposition idea
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 块分解想法
- en: We can think of large matrices as made of smaller blocks. This is common in
    linear algebra proofs and algorithms.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将大型矩阵视为由较小的块组成。这在线性代数证明和算法中很常见。
- en: '[PRE115]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '*[PRE116]*  *This is the start of block matrix notation.*******  ***#### Try
    It Yourself'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE116]*  *这是块矩阵记法的开始。******  ***#### 尝试自己操作'
- en: Create a 4×5 matrix with values 1–20 using `np.arange(1,21).reshape(4,5)`. Find
    its shape.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `np.arange(1,21).reshape(4,5)` 创建一个 4×5 的矩阵，其值为 1–20。找出它的形状。
- en: Extract the middle row and last column.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取中间行和最后一列。
- en: Cut it into four 2×2 blocks. Can you reassemble them in a different order?****  ***###
    13\. Matrix Addition and Scalar Multiplication
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其切成四个 2×2 块。你能以不同的顺序重新组装它们吗？****  ***### 13. 矩阵加法和标量乘法
- en: 'Now that we understand matrix shapes and indexing, let’s practice two of the
    simplest but most important operations: adding matrices and scaling them with
    numbers (scalars). These operations extend the rules we already know for vectors.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了矩阵形状和索引，让我们练习两个最简单但最重要的操作：矩阵相加和用数字（标量）缩放。这些操作扩展了我们已经知道的向量的规则。
- en: Set Up Your Lab
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置你的实验室
- en: '[PRE117]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码解析'
- en: Adding two matrices You can add two matrices if (and only if) they have the
    same shape. Addition happens entry by entry.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个矩阵相加 你可以相加两个矩阵（仅当它们具有相同的形状时）。加法是逐条进行的。
- en: '[PRE118]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '*[PRE119]*  *Each element in `C` is the sum of corresponding elements in `A`
    and `B`.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE119]*  *`C` 中的每个元素都是 `A` 和 `B` 中对应元素的和。'
- en: Scalar multiplication Multiplying a matrix by a scalar multiplies every entry
    by that number.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标量乘法 将矩阵乘以一个标量会将每个元素乘以那个数。
- en: '[PRE120]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '*[PRE121]*  *Here, each element of `A` is tripled.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE121]*  *在这里，`A` 的每个元素都乘以了 3。'
- en: Combining both operations We can mix addition and scaling, just like with vectors.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合两种操作 我们可以混合加法和缩放，就像向量一样。
- en: '[PRE122]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '*[PRE123]*  *This creates new matrices as linear combinations of others.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE123]*  *这会创建新的矩阵，作为其他矩阵的线性组合。'
- en: Zero matrix A matrix of all zeros acts like “nothing happens” for addition.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 零矩阵 所有零的矩阵在加法中就像“没有发生任何事情”。
- en: '[PRE124]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '*[PRE125]*  *5.  Shape mismatch (what fails) If shapes don’t match, NumPy throws
    an error.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE125]*  *5.  形状不匹配（什么失败）如果形状不匹配，NumPy 会抛出一个错误。'
- en: '[PRE126]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '*[PRE127]*  *This shows why shape consistency matters.*****  ***#### Try It
    Yourself'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE127]*  *这显示了形状一致性为什么很重要。*****  ***#### 尝试自己操作'
- en: Create two random 3×3 matrices with `np.random.randint(0,10,(3,3))` and add
    them.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `np.random.randint(0,10,(3,3))` 创建两个随机的 3×3 矩阵并将它们相加。
- en: Multiply a 4×4 matrix by `-1`. What happens to its entries?
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个 4×4 矩阵乘以 `-1`。它的元素会发生什么变化？
- en: Compute `3A + 2B` with the matrices from above. Compare with doing each step
    manually.****  ***### 14\. Matrix–Vector Product (Linear Combinations of Columns)
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上面的矩阵计算 `3A + 2B`。与手动执行每个步骤进行比较。****  ***### 14. 矩阵-向量积（列的线性组合）
- en: This lab introduces the matrix–vector product, one of the most important operations
    in linear algebra. Multiplying a matrix by a vector doesn’t just crunch numbers
    - it produces a new vector by combining the matrix’s columns in a weighted way.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验介绍了矩阵-向量积，这是线性代数中最重要的操作之一。矩阵乘以一个向量不仅仅是计算数字 - 它通过以加权方式组合矩阵的列来产生一个新的向量。
- en: Set Up Your Lab
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置你的实验室
- en: '[PRE128]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码分析'
- en: A simple matrix and vector
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个简单的矩阵和向量
- en: '[PRE129]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '*Here, `A` has 2 columns, so we can multiply it by a 2D vector `x`.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这里，`A` 有 2 列，所以我们可以将它乘以一个 2D 向量 `x`。'
- en: Matrix–vector multiplication in NumPy
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy 中的矩阵-向量乘法
- en: '[PRE130]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '*[PRE131]*  *Result: a 3D vector.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE131]*  *结果：一个 3D 向量。'
- en: Interpreting the result as linear combinations
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果解释为线性组合
- en: 'Matrix `A` has two columns:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵 `A` 有两列：
- en: '[PRE132]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '*[PRE133]*  *This matches `A·x`. In words: *multiply each column by the corresponding
    entry of `x` and then add them up*.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE133]*  *这与 `A·x` 相匹配。用文字来说：*将每一列乘以 `x` 对应的项，然后将它们加起来*。'
- en: Another example (geometry)
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个例子（几何）
- en: '[PRE134]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '*[PRE135]*  *Here, `(1,3)` becomes `(2,3)`. The x-component was doubled, while
    y stayed the same.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE135]*  *在这里，`(1,3)` 变成了 `(2,3)`。x 分量加倍，而 y 保持不变。'
- en: Visualization of matrix action
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩阵作用的可视化
- en: '[PRE136]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '*![](../Images/6b4ad3db5bd6e132804e9f93324cad0f.png)*  *Red arrow = original
    vector, blue arrow = transformed vector.*****  ***#### Try It Yourself'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/6b4ad3db5bd6e132804e9f93324cad0f.png)*  *红色箭头 = 原始向量，蓝色箭头 =
    变换后的向量*****  ***#### 尝试自己操作'
- en: Multiply
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 乘法
- en: \[ A = \begin{bmatrix}1 & 0 \\ 0 & 1 \\ -1 & 2\end{bmatrix},\; x = [3,1] \]
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ A = \begin{bmatrix}1 & 0 \\ 0 & 1 \\ -1 & 2\end{bmatrix},\; x = [3,1] \]
- en: What’s the result?
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果是什么？
- en: Replace `B` with `[[0,-1],[1,0]]`. Multiply it by `(1,0)` and `(0,1)`. What
    geometric transformation does this represent?
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `B` 替换为 `[[0,-1],[1,0]]`。将其乘以 `(1,0)` 和 `(0,1)`。这代表什么几何变换？
- en: For a 4×4 identity matrix (`np.eye(4)`), try multiplying by any 4D vector. What
    do you observe?****  ***### 15\. Matrix–Matrix Product (Composition of Linear
    Steps)
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于一个 4×4 的单位矩阵 (`np.eye(4)`)，尝试将其乘以任何 4D 向量。你观察到什么？****  ***### 15. 矩阵-矩阵积（线性步骤的组合）
- en: Matrix–matrix multiplication is how we combine two linear transformations into
    one. Instead of applying one transformation, then another, we can multiply their
    matrices and get a single matrix that does both at once.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵-矩阵乘法是我们如何将两个线性变换组合成一个。我们不是应用一个变换，然后应用另一个，而是将它们的矩阵相乘，得到一个一次完成两者的单个矩阵。
- en: Set Up Your Lab
  id: totrans-361
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置你的实验室
- en: '[PRE137]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码分析'
- en: Matrix–matrix multiplication in NumPy
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy 中的矩阵-矩阵乘法
- en: '[PRE138]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '*[PRE139]*  *The result `C` is another 2×2 matrix.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE139]*  *结果 `C` 是另一个 2×2 矩阵。'
- en: Manual computation
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动计算
- en: 'Each entry of `C` is computed as a row of A dotted with a column of B:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`C` 的每个元素都是 A 的一个行与 B 的一个列的点积：'
- en: '[PRE140]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '*[PRE141]*  *This should match `A·B`.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE141]*  *这应该匹配 `A·B`。'
- en: Geometric interpretation
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几何解释
- en: Let’s see how two transformations combine.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两个变换是如何组合的。
- en: Matrix `B` scales x by 2 and stretches y by 2.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵 `B` 将 x 缩放 2 倍，将 y 拉伸 2 倍。
- en: Matrix `A` applies another linear transformation.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵 `A` 应用另一个线性变换。
- en: Together, `C = A·B` does both in one step.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 一起，`C = A·B` 在一步中完成这两者。
- en: '[PRE142]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '*[PRE143]*  *The result is the same: applying `B` then `A` is equivalent to
    applying `C`.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE143]*  *结果是相同的：先应用 `B` 再应用 `A` 等价于先应用 `C`。'
- en: Non-square matrices
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非方阵
- en: Matrix multiplication also works for rectangular matrices, as long as the inner
    dimensions match.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵乘法也适用于矩形矩阵，只要内部维度匹配。
- en: '[PRE144]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '*[PRE145]*  *Shape rule: `(2×3)·(3×2) = (2×2)`.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE145]*  *形状规则：`(2×3)·(3×2) = (2×2)`。'
- en: Associativity (but not commutativity)
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结合性（但不是交换性）
- en: 'Matrix multiplication is associative: `(A·B)·C = A·(B·C)`. But it’s not commutative:
    in general, `A·B ≠ B·A`.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵乘法是结合的：`(A·B)·C = A·(B·C)`。但它不是交换的：在一般情况下，`A·B ≠ B·A`。
- en: '[PRE146]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '*[PRE147]*  *The two results are different.*****  ***#### Try It Yourself'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE147]*  *这两个结果不同。*****  ***#### 尝试自己操作'
- en: Multiply
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 乘法
- en: \[ A = \begin{bmatrix}1 & 0 \\ 0 & 1\end{bmatrix},\; B = \begin{bmatrix}0 &
    -1 \\ 1 & 0\end{bmatrix} \]
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ A = \begin{bmatrix}1 & 0 \\ 0 & 1\end{bmatrix},\; B = \begin{bmatrix}0 &
    -1 \\ 1 & 0\end{bmatrix} \]
- en: What transformation does `A·B` represent?
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`A·B` 代表什么变换？'
- en: Create a random 3×2 matrix and a 2×4 matrix. Multiply them. What shape is the
    result?
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 3×2 的随机矩阵和一个 2×4 的矩阵。将它们相乘。结果是什么形状？
- en: Verify with Python that `(A·B)·C = A·(B·C)` for some 3×3 random matrices.****  ***###
    16\. Identity, Inverse, and Transpose
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Python 验证 `(A·B)·C = A·(B·C)` 对于一些 3×3 的随机矩阵。****  ***### 16. 单位矩阵、逆矩阵和转置
- en: 'In this lab, we’ll meet three special matrix operations and objects: the identity
    matrix, the inverse, and the transpose. These are the building blocks of matrix
    algebra, each with a simple meaning but deep importance.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验室中，我们将遇到三种特殊的矩阵操作和对象：单位矩阵、逆矩阵和转置。这些是矩阵代数的构建块，每个都有简单的含义但具有深远的重要性。
- en: Set Up Your Lab
  id: totrans-392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE148]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: 'Identity matrix The identity matrix is like the number `1` for matrices: multiplying
    by it changes nothing.'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单位矩阵 单位矩阵就像矩阵中的数字 `1`：乘以它不会改变任何东西。
- en: '[PRE149]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '*[PRE150]*  *Both equal `A`.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE150]*  *两者都等于 `A`。'
- en: Transpose The transpose flips rows and columns.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转置 转置翻转行和列。
- en: '[PRE151]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '*[PRE152]*  **   Original: 2×3'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE152]*  **   原始：2×3'
- en: 'Transpose: 3×2'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转置：3×2
- en: Geometrically, transpose swaps the axes when vectors are viewed in row/column
    form.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 几何上，转置在以行/列形式查看向量时交换轴。
- en: 'Inverse The inverse matrix is like dividing by a number: multiplying a matrix
    by its inverse gives the identity.'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逆矩阵就像除以一个数：乘以矩阵的逆矩阵给出单位矩阵。
- en: '[PRE153]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '*[PRE154]*  *Both products are (approximately) the identity.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE154]*  *两个乘积都是（近似地）单位矩阵。'
- en: Matrices that don’t have inverses Not every matrix is invertible. If a matrix
    is singular (determinant = 0), it has no inverse.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有逆的矩阵 并非每个矩阵都是可逆的。如果一个矩阵是奇异的（行列式 = 0），它没有逆。
- en: '[PRE155]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '*[PRE156]*  *Here, the second row is a multiple of the first, so `D` can’t
    be inverted.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE156]*  *在这里，第二行是第一行的倍数，所以 `D` 不能求逆。'
- en: Transpose and inverse together For invertible matrices,
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转置和逆矩阵一起 对于可逆矩阵，
- en: \[ (A^T)^{-1} = (A^{-1})^T \]
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: \[ (A^T)^{-1} = (A^{-1})^T \]
- en: 'We can check this numerically:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过数值来检查这一点：
- en: '[PRE157]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '*[PRE158]*****  ***#### Try It Yourself'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE158]*****  ***#### 尝试自己操作'
- en: Create a 4×4 identity matrix. Multiply it by any 4×1 vector. Does it change?
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 4×4 的单位矩阵。将其乘以任何 4×1 的向量。它会改变吗？
- en: Take a random 2×2 matrix with `np.random.randint`. Compute its inverse and check
    if multiplying gives identity.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `np.random.randint` 取一个随机的 2×2 矩阵。计算其逆矩阵并检查乘法是否给出单位矩阵。
- en: Pick a rectangular 3×2 matrix. What happens when you try `np.linalg.inv`? Why?
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个矩形 3×2 矩阵。当你尝试 `np.linalg.inv` 时会发生什么？为什么？
- en: Compute `(A.T).T` for some matrix `A`. What do you notice?****  ***### 17\.
    Symmetric, Diagonal, Triangular, and Permutation Matrices
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于某个矩阵 `A`，计算 `(A.T).T`。你注意到什么？****  ***### 17. 对称矩阵、对角矩阵、三角矩阵和置换矩阵
- en: In this lab, we’ll meet four important families of special matrices. They have
    patterns that make them easier to understand, compute with, and use in algorithms.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验室中，我们将遇到四种重要的特殊矩阵族。它们有使它们更容易理解、计算和使用在算法中的模式。
- en: Set Up Your Lab
  id: totrans-419
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE159]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: 'Symmetric matrices A matrix is symmetric if it equals its transpose: \(A =
    A^T\).'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对称矩阵 如果一个矩阵等于它的转置，则该矩阵是对称的：\(A = A^T\)。
- en: '[PRE160]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '*[PRE161]*  *Symmetric matrices appear in physics, optimization, and statistics
    (e.g., covariance matrices).'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE161]*  *对称矩阵出现在物理学、优化和统计学中（例如，协方差矩阵）。'
- en: Diagonal matrices A diagonal matrix has nonzero entries only on the main diagonal.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对角矩阵 对角矩阵只在主对角线上有非零项。
- en: '[PRE162]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '*[PRE163]*  *Diagonal multiplication simply scales each coordinate separately.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE163]*  *对角乘法只是分别缩放每个坐标。'
- en: 'Triangular matrices Upper triangular: all entries below the diagonal are zero.
    Lower triangular: all entries above the diagonal are zero.'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三角矩阵 上三角：对角线以下的元素都是零。下三角：对角线以上的元素都是零。
- en: '[PRE164]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '*[PRE165]*  *These are important in solving linear systems (e.g., Gaussian
    elimination).'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE165]*  *这些在求解线性系统（例如高斯消元法）中很重要。'
- en: Permutation matrices A permutation matrix rearranges the order of coordinates.
    Each row and each column has exactly one `1`, everything else is `0`.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 置换矩阵 置换矩阵重新排列坐标的顺序。每一行和每一列恰好有一个 `1`，其余都是 `0`。
- en: '[PRE166]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '*[PRE167]*  *Here, `P` cycles `(10,20,30)` into `(20,30,10)`.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE167]*  *在这里，`P` 将 `(10,20,30)` 循环到 `(20,30,10)`。'
- en: Checking properties
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查属性
- en: '[PRE168]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '*[PRE169]*****  ***#### Try It Yourself'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE169]*****  ***#### 尝试自己来做'
- en: Create a random symmetric matrix by generating any matrix `M` and computing
    `(M + M.T)/2`.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过生成任何矩阵 `M` 并计算 `(M + M.T)/2` 来创建一个随机的对称矩阵。
- en: Build a 4×4 diagonal matrix with diagonal entries `[2,4,6,8]` and multiply it
    by `[1,1,1,1]`.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个对角线元素为 `[2,4,6,8]` 的 4×4 对角矩阵，并将其乘以 `[1,1,1,1]`。
- en: Make a permutation matrix that swaps the first and last components of a 3D vector.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个置换矩阵，用于交换 3D 向量的第一个和最后一个分量。
- en: Check whether the identity matrix is diagonal, symmetric, upper triangular,
    and lower triangular all at once.****  ***### 18\. Trace and Basic Matrix Properties
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查单位矩阵是否对角、对称、上三角和下三角。****  ***### 18\. 迹和基本矩阵属性
- en: In this lab, we’ll introduce the trace of a matrix and a few quick properties
    that often appear in proofs, algorithms, and applications. The trace is simple
    to compute but surprisingly powerful.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验室中，我们将介绍矩阵的迹以及一些常出现在证明、算法和应用中的快速属性。迹的计算很简单，但出人意料地强大。
- en: Set Up Your Lab
  id: totrans-442
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE170]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: 'What is the trace? The trace of a square matrix is the sum of its diagonal
    entries:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迹是什么？方阵的迹是其对角线元素的和：
- en: \[ \text{tr}(A) = \sum_i A_{ii} \]
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \text{tr}(A) = \sum_i A_{ii} \]
- en: '[PRE171]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '*[PRE172]*  *Here, trace = \(2 + 4 + 6 = 12\).'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE172]*  *在这里，迹 = \(2 + 4 + 6 = 12\)。'
- en: 'Trace is linear For matrices `A` and `B`:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迹是线性的 对于矩阵 `A` 和 `B`：
- en: \[ \text{tr}(A+B) = \text{tr}(A) + \text{tr}(B) \]
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \text{tr}(A+B) = \text{tr}(A) + \text{tr}(B) \]
- en: \[ \text{tr}(cA) = c \cdot \text{tr}(A) \]
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \text{tr}(cA) = c \cdot \text{tr}(A) \]
- en: '[PRE173]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '*[PRE174]*  *3.  Trace of a product One important property is:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE174]*  *3. 乘积的迹 一个重要性质是：'
- en: \[ \text{tr}(AB) = \text{tr}(BA) \]
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \text{tr}(AB) = \text{tr}(BA) \]
- en: '[PRE175]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '*[PRE176]*  *Both are equal, even though `CD` and `DC` are different matrices.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE176]*  *两者都相等，即使 `CD` 和 `DC` 是不同的矩阵。'
- en: Trace and eigenvalues The trace equals the sum of eigenvalues of a matrix (counting
    multiplicities).
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迹和特征值 迹等于矩阵的特征值之和（考虑重数）。
- en: '[PRE177]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '*[PRE178]*  *The results should match (within rounding error).'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE178]*  *结果应该匹配（在舍入误差范围内）。'
- en: Quick invariants
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速不变量
- en: 'Trace doesn’t change under transpose: `tr(A) = tr(A.T)`'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迹在转置下不变：`tr(A) = tr(A.T)`
- en: 'Trace doesn’t change under similarity transforms: `tr(P^-1 A P) = tr(A)`'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迹在相似变换下不变：`tr(P^-1 A P) = tr(A)`
- en: '[PRE179]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '*[PRE180]*****  ***#### Try It Yourself'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE180]*****  ***#### 尝试自己来做'
- en: 'Create a 2×2 rotation matrix for 90°:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 90° 的 2×2 旋转矩阵：
- en: \[ R = \begin{bmatrix}0 & -1 \\ 1 & 0\end{bmatrix} \]
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ R = \begin{bmatrix}0 & -1 \\ 1 & 0\end{bmatrix} \]
- en: What is its trace? What does that tell you about its eigenvalues?
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它的迹是什么？这告诉你关于其特征值什么？
- en: Make a random 3×3 matrix and compare `tr(A)` with the sum of eigenvalues.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个随机的 3×3 矩阵，并将 `tr(A)` 与特征值的和进行比较。
- en: Test `tr(AB)` and `tr(BA)` with a rectangular matrix `A` (e.g. 2×3) and `B`
    (3×2). Do they still match?****  ***### 19\. Affine Transforms and Homogeneous
    Coordinates
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用矩形矩阵 `A`（例如 2×3）和 `B`（3×2）测试 `tr(AB)` 和 `tr(BA)`。它们是否仍然匹配？****  ***### 19\.仿射变换和齐次坐标
- en: Affine transformations let us do more than just linear operations - they include
    translations (shifting points), which ordinary matrices can’t handle alone. To
    unify rotations, scalings, reflections, and translations, we use homogeneous coordinates.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 仿射变换使我们能够执行不仅仅是线性操作 - 它包括平移（移动点），这是普通矩阵单独无法处理的。为了统一旋转、缩放、反射和平移，我们使用齐次坐标。
- en: Set Up Your Lab
  id: totrans-471
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE181]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Linear transformations vs affine transformations
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线性变换与仿射变换
- en: A linear transformation can rotate, scale, or shear, but always keeps the origin
    fixed.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性变换可以旋转、缩放或扭曲，但始终保持原点固定。
- en: An affine transformation allows translation as well.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仿射变换允许平移。
- en: For example, shifting every point by `(2,3)` is affine but not linear.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将每个点移动 `(2,3)` 是仿射的但不是线性的。
- en: Homogeneous coordinates idea We add an extra coordinate (usually `1`) to vectors.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同质坐标概念 我们向向量添加一个额外的坐标（通常为 `1`）。
- en: A 2D point `(x,y)` becomes `(x,y,1)`.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D 点 `(x,y)` 变为 `(x,y,1)`。
- en: A 3D point `(x,y,z)` becomes `(x,y,z,1)`.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D 点 `(x,y,z)` 变为 `(x,y,z,1)`。
- en: This trick lets us represent translations using matrix multiplication.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧让我们可以用矩阵乘法表示平移。
- en: 2D translation matrix
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2D 平移矩阵
- en: \[ T = \begin{bmatrix} 1 & 0 & t_x \\ 0 & 1 & t_y \\ 0 & 0 & 1 \end{bmatrix}
    \]
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: \[ T = \begin{bmatrix} 1 & 0 & t_x \\ 0 & 1 & t_y \\ 0 & 0 & 1 \end{bmatrix}
    \]
- en: '[PRE182]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '*[PRE183]*  *This shifts `(1,1)` to `(3,4)`.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE183]*  *这将 `(1,1)` 移动到 `(3,4)`。'
- en: Combining rotation and translation
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旋转和平移的组合
- en: 'A 90° rotation around the origin in 2D:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 2D 中围绕原点旋转 90°：
- en: '[PRE184]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '*[PRE185]*  *Now we can apply rotation and translation in one step.'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE185]*  *现在我们可以一步完成旋转和平移。'
- en: Visualization of translation
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 平移的可视化
- en: '[PRE186]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '*![](../Images/4f5db4b64133225a63bedd92cf26ad76.png)*  *You’ll see the red
    unit square moved to a blue unit square shifted by `(2,3)`.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/4f5db4b64133225a63bedd92cf26ad76.png)*  *你会看到红色单位正方形移动到被 `(2,3)`
    平移的蓝色单位正方形。'
- en: Extending to 3D In 3D, homogeneous coordinates use 4×4 matrices. Translations,
    rotations, and scalings all fit the same framework.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展到 3D 在 3D 中，同质坐标使用 4×4 矩阵。平移、旋转和缩放都适合相同的框架。
- en: '[PRE187]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '*[PRE188]*  *This shifts `(1,2,3)` to `(6,0,6)`.****  ***#### Try It Yourself'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE188]*  *这将 `(1,2,3)` 移动到 `(6,0,6)`。****  ***#### 尝试自己操作'
- en: Build a scaling matrix in homogeneous coordinates that doubles both x and y,
    and apply it to `(1,1)`.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同质坐标中构建一个缩放矩阵，使 x 和 y 都加倍，并将其应用于 `(1,1)`。
- en: Create a 2D transform that rotates by 90° and then shifts by `(−2,1)`. Apply
    it to `(0,2)`.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个旋转 90° 并然后平移 `(−2,1)` 的 2D 变换。将其应用于 `(0,2)`。
- en: In 3D, translate `(0,0,0)` by `(10,10,10)`. What homogeneous matrix did you
    use?****  ***### 20\. Computing with Matrices (Cost Counts and Simple Speedups)
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 3D 中，将 `(0,0,0)` 平移 `(10,10,10)`。你使用了什么同质矩阵？****  ***### 20\. 使用矩阵进行计算（成本计算和简单加速）
- en: Working with matrices is not just about theory - in practice, we care about
    how much computation it takes to perform operations, and how we can make them
    faster. This lab introduces basic cost analysis (counting operations) and demonstrates
    simple NumPy optimizations.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 与矩阵一起工作不仅仅是理论 - 在实践中，我们关心执行操作所需的计算量，以及如何使它们更快。这个实验介绍了基本的成本分析（计算操作）并展示了简单的 NumPy
    优化。
- en: Set Up Your Lab
  id: totrans-500
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE189]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Counting operations (matrix–vector multiply)
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算操作（矩阵-向量乘法）
- en: If `A` is an \(m \times n\) matrix and `x` is an \(n\)-dimensional vector, computing
    `A·x` takes about \(m \times n\) multiplications and the same number of additions.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `A` 是一个 \(m \times n\) 矩阵，而 `x` 是一个 \(n\)-维向量，则计算 `A·x` 大约需要 \(m \times n\)
    次乘法和相同数量的加法。
- en: '[PRE190]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '*[PRE191]*  *Here the cost is \(3 \times 4 = 12\) multiplications + 12 additions.'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE191]*  *在这里，成本是 \(3 \times 4 = 12\) 次乘法 + 12 次加法。'
- en: Counting operations (matrix–matrix multiply)
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算操作（矩阵-矩阵乘法）
- en: For an \(m \times n\) times \(n \times p\) multiplication, the cost is about
    \(m \times n \times p\).
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 \(m \times n\) 乘以 \(n \times p\) 的乘法，成本大约是 \(m \times n \times p\)。
- en: '[PRE192]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '*[PRE193]*  *Here the cost is \(3 \times 4 \times 2 = 24\) multiplications
    + 24 additions.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE193]*  *在这里，成本是 \(3 \times 4 \times 2 = 24\) 次乘法 + 24 次加法。'
- en: Timing with NumPy (vectorized vs loop)
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 NumPy 进行计时（向量化与循环）
- en: NumPy is optimized in C and Fortran under the hood. Let’s compare matrix multiplication
    with and without vectorization.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 在底层是用 C 和 Fortran 优化的。让我们比较有向量化和无向量化时的矩阵乘法。
- en: '[PRE194]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '*[PRE195]*  *The vectorized version should be thousands of times faster.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE195]*  *向量化版本应该快数千倍。'
- en: Broadcasting tricks
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 广播技巧
- en: NumPy lets us avoid loops by broadcasting operations across entire rows or columns.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 允许我们通过在整个行或列上广播操作来避免循环。
- en: '[PRE196]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '*[PRE197]*  *5.  Memory and data types'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE197]*  *5.  内存和数据类型'
- en: For large computations, data type matters.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大量计算，数据类型很重要。
- en: '[PRE198]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '*[PRE199]*  *Using `float32` instead of `float64` halves memory use and can
    speed up computation (at the cost of some precision).*****  ***#### Try It Yourself'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE199]*  *使用 `float32` 而不是 `float64` 可以减半内存使用并加快计算速度（以牺牲一些精度为代价）。*****  ***####
    尝试自己操作'
- en: Compute the cost of multiplying a 200×500 matrix with a 500×1000 matrix. How
    many multiplications are needed?
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算将一个 200×500 的矩阵与一个 500×1000 的矩阵相乘的成本。需要多少次乘法？
- en: Time matrix multiplication for sizes 100, 500, 1000 in NumPy. How does the time
    scale?
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 NumPy 中为大小 100、500、1000 的矩阵乘法计时。时间如何缩放？
- en: Experiment with `float32` vs `float64` in NumPy. How do speed and memory change?
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 NumPy 中尝试 `float32` 与 `float64`。速度和内存如何变化？
- en: 'Try broadcasting: multiply each column of a matrix by `[1,2,3,...]`.'
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试广播：将矩阵的每一列乘以 `[1,2,3,...]`。
- en: The Takeaway
  id: totrans-526
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 要点
- en: 'Matrix operations have predictable computational costs: `A·x` ~ \(m \times
    n\), `A·B` ~ \(m \times n \times p\).'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵运算具有可预测的计算成本：`A·x` ~ \(m \times n\)，`A·B` ~ \(m \times n \times p\)。
- en: Vectorized NumPy operations are vastly faster than Python loops.
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量化 NumPy 操作比 Python 循环快得多。
- en: Broadcasting and choosing the right data type are simple speedups every beginner
    should learn.*******************************  ***## Chapter 3\. Linear Systems
    and Elimination
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广播和选择合适的数据类型是每个初学者都应该学习的简单加速方法。*******************************  ***## 第 3 章\.
    线性方程组和消元
- en: 21\. From Equations to Matrices (Augmenting and Encoding)
  id: totrans-530
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21\. 从方程到矩阵（增广和编码）
- en: 'Linear algebra often begins with solving systems of linear equations. For example:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数通常从求解线性方程组开始。例如：
- en: \[ \begin{cases} x + 2y = 5 \\ 3x - y = 4 \end{cases} \]
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{cases} x + 2y = 5 \\ 3x - y = 4 \end{cases} \]
- en: Instead of juggling symbols, we can encode the entire system into a matrix.
    This is the key idea that lets computers handle thousands or millions of equations
    efficiently.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是玩弄符号，我们可以将整个系统编码成一个矩阵。这是让计算机高效处理成千上万方程的关键思想。
- en: Set Up Your Lab
  id: totrans-534
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE200]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Write a system of equations
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个方程组
- en: 'We’ll use this small example:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个小例子：
- en: \[ \begin{cases} 2x + y = 8 \\ -3x + 4y = -11 \end{cases} \]
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{cases} 2x + y = 8 \\ -3x + 4y = -11 \end{cases} \]
- en: Encode coefficients and constants
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编码系数和常数
- en: 'Coefficient matrix \(A\): numbers multiplying variables.'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系数矩阵 \(A\)：乘以变量的数字。
- en: 'Variable vector \(x\): unknowns `[x, y]`.'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量向量 \(x\)：未知数 `[x, y]`。
- en: 'Constant vector \(b\): right-hand side.'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常数向量 \(b\)：右侧。
- en: '[PRE201]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '*[PRE202]*  *So the system is \(A·x = b\).'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE202]*  *因此系统是 \(A·x = b\)。'
- en: Augmented matrix
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增广矩阵
- en: 'We can bundle the system into one compact matrix:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将系统捆绑成一个紧凑的矩阵：
- en: \[ [A|b] = \begin{bmatrix}2 & 1 & | & 8 \\ -3 & 4 & | & -11 \end{bmatrix} \]
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: \[ [A|b] = \begin{bmatrix}2 & 1 & | & 8 \\ -3 & 4 & | & -11 \end{bmatrix} \]
- en: '[PRE203]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '*[PRE204]*  *This format is useful for elimination algorithms.'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE204]*  *这种格式对消元算法很有用。'
- en: Solving directly with NumPy
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接使用 NumPy 求解
- en: '[PRE205]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '*[PRE206]*  *Here NumPy solves the system using efficient algorithms.'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE206]*  *这里 NumPy 使用高效的算法求解系统。'
- en: Checking the solution
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查解
- en: 'Always verify:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 总是验证：
- en: '[PRE207]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '*[PRE208]*  *6.  Another example (3 variables)'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE208]*  *6.  另一个例子（3 个变量）'
- en: \[ \begin{cases} x + y + z = 6 \\ 2x - y + z = 3 \\ - x + 2y - z = 2 \end{cases}
    \]
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{cases} x + y + z = 6 \\ 2x - y + z = 3 \\ - x + 2y - z = 2 \end{cases}
    \]
- en: '[PRE209]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '*[PRE210]*****  ***#### Try It Yourself'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE210]*****  ***#### 尝试自己动手'
- en: 'Encode the system:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对系统进行编码：
- en: \[ \begin{cases} 2x - y = 1 \\ x + 3y = 7 \end{cases} \]
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ \begin{cases} 2x - y = 1 \\ x + 3y = 7 \end{cases} \]
- en: Write `A` and `b`, then solve.
  id: totrans-563
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 写出 `A` 和 `b`，然后求解。
- en: For a 3×3 system, try creating a random coefficient matrix with `np.random.randint(-5,5,(3,3))`
    and a random `b`. Use `np.linalg.solve`.
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于一个 3×3 的系统，尝试使用 `np.random.randint(-5,5,(3,3))` 创建一个随机的系数矩阵和一个随机的 `b`。使用 `np.linalg.solve`。
- en: Modify the constants `b` slightly and see how the solution changes. This introduces
    the idea of sensitivity.
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 稍微修改常数 `b` 并观察解如何变化。这引入了敏感度的概念。
- en: The Takeaway
  id: totrans-566
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 要点
- en: Systems of linear equations can be neatly written as \(A·x = b\).
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性方程组可以整洁地写成 \(A·x = b\)。
- en: The augmented matrix \([A|b]\) is a compact way to set up elimination.
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增广矩阵 \([A|b]\) 是设置消元的一种紧凑方式。
- en: This matrix encoding transforms algebra problems into matrix problems - the
    gateway to all of linear algebra.****  ***### 22\. Row Operations (Legal Moves
    That Keep Solutions)
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种矩阵编码将代数问题转化为矩阵问题 - 这是线性代学的入门。****  ***### 22\. 行运算（保持解的合法移动）
- en: When solving linear systems, we don’t want to change the solutions - just simplify
    the system into an easier form. This is where row operations come in. They are
    the “legal moves” we can do on an augmented matrix \([A|b]\) without changing
    the solution set.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在求解线性系统时，我们不想改变解，只是将系统简化成更简单的形式。这就是行运算发挥作用的地方。它们是在增广矩阵 \([A|b]\) 上可以做的“合法移动”，而不会改变解集。
- en: Set Up Your Lab
  id: totrans-571
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE211]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Three legal row operations
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三种合法的行运算
- en: Swap two rows \((R_i \leftrightarrow R_j)\)
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交换两行 \((R_i \leftrightarrow R_j)\)
- en: Multiply a row by a nonzero scalar \((R_i \to c·R_i)\)
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一行乘以一个非零标量 \((R_i \to c·R_i)\)
- en: Replace a row with itself plus a multiple of another row \((R_i \to R_i + c·R_j)\)
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用另一行的倍数替换一行 \((R_i \to R_i + c·R_j)\)
- en: These preserve the solution set.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 这些保留了解集。
- en: Start with an augmented matrix
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从增广矩阵开始
- en: 'System:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 系统：
- en: \[ \begin{cases} x + 2y = 5 \\ 3x + 4y = 6 \end{cases} \]
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{cases} x + 2y = 5 \\ 3x + 4y = 6 \end{cases} \]
- en: '[PRE212]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '*[PRE213]*  *3.  Row swap'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE213]*  *3.  行交换'
- en: Swap row 0 and row 1.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 交换行 0 和行 1。
- en: '[PRE214]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '*[PRE215]*  *4.  Multiply a row by a scalar'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE215]*  *4.  将一行乘以一个标量'
- en: Make the pivot in row 0 equal to 1.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 使行 0 的主元等于 1。
- en: '[PRE216]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '*[PRE217]*  *5.  Add a multiple of another row'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE217]*  *5.  将另一行的倍数加到一行上'
- en: Eliminate the first column of row 1.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 消除行 1 的第一列。
- en: '[PRE218]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '*[PRE219]*  *Now the system is simpler: second row has only `y`.'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE219]*  *现在系统更简单了：第二行只有 `y`。'
- en: Solving from the new system
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新系统求解
- en: '[PRE220]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '*[PRE221]*  *7.  Using NumPy step-by-step vs solver'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE221]*  *7.  使用 NumPy 步骤与求解器'
- en: '[PRE222]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '*[PRE223]*  *Both methods give the same solution.******  ***#### Try It Yourself'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE223]*  *两种方法给出相同的解。******  ***#### 尝试自己操作'
- en: 'Take the system:'
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下系统：
- en: \[ \begin{cases} 2x + y = 7 \\ x - y = 1 \end{cases} \]
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ \begin{cases} 2x + y = 7 \\ x - y = 1 \end{cases} \]
- en: 'Write its augmented matrix, then:'
  id: totrans-600
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 写出它的增广矩阵，然后：
- en: Swap rows.
  id: totrans-601
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换行。
- en: Scale the first row.
  id: totrans-602
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放第一行。
- en: Eliminate one variable.
  id: totrans-603
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除一个变量。
- en: Create a random 3×3 system with integers between -5 and 5\. Perform at least
    one of each row operation manually in code.
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个随机的 3×3 系统并使用介于 -5 和 5 之间的整数。在代码中至少手动执行每种行操作之一。
- en: Experiment with multiplying a row by `0`. What happens, and why is this not
    allowed as a legal operation?
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将一行乘以 `0`。会发生什么，为什么这不被视为合法操作？
- en: The Takeaway
  id: totrans-606
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**总结**'
- en: The three legal row operations are row swap, row scaling, and row replacement.
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三种合法的行操作是行交换、行缩放和行替换。
- en: These steps preserve the solution set while moving toward a simpler form.
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些步骤在向更简单形式移动的同时保留了解集。
- en: They are the foundation of Gaussian elimination, the standard algorithm for
    solving linear systems.****  ***### 23\. Row-Echelon and Reduced Row-Echelon Forms
    (Target Shapes)
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是高斯消元法的基础，这是解线性系统的标准算法。****  ***### 23\. 行阶梯形和简化行阶梯形（目标形状）
- en: When solving systems, our goal is to simplify the augmented matrix into a standard
    shape where the solutions are easy to read. These shapes are called row-echelon
    form (REF) and reduced row-echelon form (RREF).
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 在解系统时，我们的目标是简化增广矩阵到一个标准形状，其中解容易阅读。这些形状被称为行阶梯形（REF）和简化行阶梯形（RREF）。
- en: Set Up Your Lab
  id: totrans-611
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE224]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '*We’ll use NumPy for basic work and SymPy for exact RREF (since NumPy doesn’t
    have it built-in).*  *#### Step-by-Step Code Walkthrough'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将使用 NumPy 进行基本工作，并使用 SymPy 进行精确的 RREF（因为 NumPy 内置没有它）。*  *#### 逐步代码演示'
- en: Row-Echelon Form (REF)
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行阶梯形（REF）
- en: All nonzero rows are above any zero rows.
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有非零行都在任何零行之上。
- en: Each leading entry (pivot) is to the right of the pivot in the row above.
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个主元（主元）都在上一行的主元右侧。
- en: Pivots are usually scaled to 1, but not strictly required.
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主元通常缩放到 1，但不是严格要求的。
- en: 'Example system:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例系统**：'
- en: \[ \begin{cases} x + 2y + z = 7 \\ 2x + 4y + z = 12 \\ 3x + 6y + 2z = 17 \end{cases}
    \]
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{cases} x + 2y + z = 7 \\ 2x + 4y + z = 12 \\ 3x + 6y + 2z = 17 \end{cases}
    \]
- en: '[PRE225]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '*[PRE226]*  *Perform elimination manually:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE226]*  *手动执行消元：'
- en: '[PRE227]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '*[PRE228]*  *Now the pivots move diagonally across the matrix - this is row-echelon
    form.'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE228]*  *现在主元沿着矩阵对角线移动 - 这是行阶梯形。'
- en: 'Reduced Row-Echelon Form (RREF) In RREF, we go further:'
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简化行阶梯形（RREF）在 RREF 中，我们更进一步：
- en: Every pivot = 1.
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个主元都等于 1。
- en: Every pivot is the only nonzero in its column.
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个主元是其列中唯一的非零值。
- en: 'Instead of coding manually, we’ll let SymPy handle it:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是手动编码，我们将让 SymPy 来处理：
- en: '[PRE229]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '*[PRE230]*  *SymPy shows the final canonical form.'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE230]*  *SymPy 显示了最终的规范形式。'
- en: Reading solutions from RREF
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 RREF 读取解
- en: 'If the RREF looks like:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 RREF 看起来像：
- en: \[ \begin{bmatrix} 1 & 0 & a & b \\ 0 & 1 & c & d \\ 0 & 0 & 0 & 0 \end{bmatrix}
    \]
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{bmatrix} 1 & 0 & a & b \\ 0 & 1 & c & d \\ 0 & 0 & 0 & 0 \end{bmatrix}
    \]
- en: 'It means:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着：
- en: The first two variables are leading (pivots).
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两个变量是主元（主元）。
- en: The third variable is free.
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个变量是自由的。
- en: Solutions can be written in terms of the free variable.
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解可以用自由变量来表示。
- en: A quick example with free variables
  id: totrans-637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个带有自由变量的快速示例
- en: 'System:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 系统：
- en: \[ x + y + z = 3 \\ 2x + y - z = 0 \]
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x + y + z = 3 \\ 2x + y - z = 0 \]
- en: '[PRE231]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '*[PRE232]*  *Here, one column will not have a pivot → that variable is free.****  ***####
    Try It Yourself'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE232]*  *在这里，某一列将没有主元 → 该变量是自由的。****  ***#### 尝试自己操作'
- en: 'Take the system:'
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下系统：
- en: \[ 2x + 3y = 6, \quad 4x + 6y = 12 \]
  id: totrans-643
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ 2x + 3y = 6, \quad 4x + 6y = 12 \]
- en: Write the augmented matrix and compute its RREF. What does it tell you about
    solutions?
  id: totrans-644
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 写出增广矩阵并计算其 RREF。它告诉你关于解的什么信息？
- en: Create a random 3×4 matrix in NumPy. Use SymPy’s `Matrix.rref()` to compute
    its reduced form. Identify the pivot columns.
  id: totrans-645
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 NumPy 中创建一个随机的 3×4 矩阵。使用 SymPy 的 `Matrix.rref()` 来计算其简化形式。识别主元列。
- en: 'For the system:'
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于以下系统：
- en: \[ x + 2y + 3z = 4, \quad 2x + 4y + 6z = 8 \]
  id: totrans-647
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ x + 2y + 3z = 4, \quad 2x + 4y + 6z = 8 \]
- en: Check if the equations are independent or multiples of each other by looking
    at the RREF.
  id: totrans-648
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过查看简化行阶梯形矩阵（RREF）来检查方程是否独立或彼此是倍数。
- en: The Takeaway
  id: totrans-649
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**总结**'
- en: REF organizes equations into a staircase shape.
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化行阶梯形矩阵（REF）将方程组织成阶梯形状。
- en: RREF goes further, making each pivot the only nonzero in its column.
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化行阶梯形矩阵（RREF）进一步简化，使每个主元所在列的其余元素都为零。
- en: These canonical forms make it easy to identify pivot variables, free variables,
    and the solution set structure.****  ***### 24\. Pivots, Free Variables, and Leading
    Ones (Reading Solutions)
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些规范形式使得识别主元变量、自由变量和解集结构变得容易。****  ***### 24\. 主元、自由变量和主元（阅读解）
- en: Once a matrix is in row-echelon or reduced row-echelon form, the solutions to
    the system become visible. The key is identifying pivots, leading ones, and free
    variables.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦矩阵处于行阶梯形或简化行阶梯形矩阵形式，系统的解就变得明显。关键是识别主元、主元和自由变量。
- en: Set Up Your Lab
  id: totrans-654
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE233]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: What are pivots?
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是主元？
- en: A pivot is the first nonzero entry in a row (after elimination).
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主元是行中第一个非零元素（在消元之后）。
- en: In RREF, pivots are scaled to `1` and are called leading ones.
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在简化行阶梯形矩阵（RREF）中，主元被缩放为`1`，并称为主元。
- en: Pivot columns correspond to basic variables.
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主元列对应于基本变量。
- en: Example system
  id: totrans-661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 示例系统
- en: \[ \begin{cases} x + y + z = 6 \\ 2x + 3y + z = 10 \end{cases} \]
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{cases} x + y + z = 6 \\ 2x + 3y + z = 10 \end{cases} \]
- en: '[PRE234]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '*[PRE235]*  *3.  Interpreting the RREF'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE235]*  *3.  解释简化行阶梯形矩阵（RREF）'
- en: 'Suppose the RREF comes out as:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 假设简化行阶梯形矩阵（RREF）的结果如下：
- en: \[ \begin{bmatrix} 1 & 0 & -2 & 4 \\ 0 & 1 & 1 & 2 \end{bmatrix} \]
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{bmatrix} 1 & 0 & -2 & 4 \\ 0 & 1 & 1 & 2 \end{bmatrix} \]
- en: 'This means:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着：
- en: 'Pivot columns: 1 and 2 → variables \(x\) and \(y\) are basic.'
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主元列：1和2 → 变量\(x\)和\(y\)是基本变量。
- en: 'Free variable: \(z\).'
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自由变量：\(z\)。
- en: 'Equations:'
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方程：
- en: \[ x - 2z = 4, \quad y + z = 2 \]
  id: totrans-671
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ x - 2z = 4, \quad y + z = 2 \]
- en: 'Solution in terms of \(z\):'
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以\(z\)为变量的解
- en: \[ x = 4 + 2z, \quad y = 2 - z, \quad z = z \]
  id: totrans-673
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ x = 4 + 2z, \quad y = 2 - z, \quad z = z \]
- en: Coding the solution extraction
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编码解提取
- en: '[PRE236]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '*[PRE237]*  *5.  Another example with infinitely many solutions'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE237]*  *5.  另一个具有无限多解的例子'
- en: \[ x + 2y + 3z = 4, \quad 2x + 4y + 6z = 8 \]
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x + 2y + 3z = 4, \quad 2x + 4y + 6z = 8 \]
- en: '[PRE238]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '*[PRE239]*  *The second row becomes all zeros, showing redundancy. Pivot in
    column 1, free variables in columns 2 and 3.'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE239]*  *第二行全部为零，表明存在冗余。第一列为主元，第二列和第三列为自由变量。'
- en: Solving underdetermined systems
  id: totrans-680
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决欠定系统
- en: 'If you have more variables than equations, expect free variables. Example:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有的变量比方程多，预期会有自由变量。例如：
- en: \[ x + y = 3 \]
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x + y = 3 \]
- en: '[PRE240]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '*[PRE241]*  *Here, \(x = 3 - y\). Variable \(y\) is free.****  ***#### Try
    It Yourself'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE241]*  *这里，\(x = 3 - y\)。变量\(y\)是自由变量。****  ***#### 尝试自己'
- en: 'Take the system:'
  id: totrans-685
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下系统：
- en: \[ x + y + z = 2, \quad y + z = 1 \]
  id: totrans-686
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ x + y + z = 2, \quad y + z = 1 \]
- en: Compute its RREF and identify pivot and free variables.
  id: totrans-687
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算其简化行阶梯形矩阵（RREF）并识别主元和自由变量。
- en: Create a random 3×4 system and compute its pivots. How many free variables do
    you get?
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个随机的3×4系统并计算其主元。你得到多少个自由变量？
- en: 'For the system:'
  id: totrans-689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于以下系统：
- en: \[ x - y = 0, \quad 2x - 2y = 0 \]
  id: totrans-690
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ x - y = 0, \quad 2x - 2y = 0 \]
- en: Verify that the system has infinitely many solutions and describe them in terms
    of a free variable.
  id: totrans-691
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 验证该系统有无穷多解，并用自由变量的术语描述它们。
- en: The Takeaway
  id: totrans-692
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Pivots / leading ones mark the basic variables.
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主元/主元标记基本变量。
- en: Free variables correspond to non-pivot columns.
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自由变量对应于非主元列。
- en: Solutions are written in terms of free variables, showing whether the system
    has a unique, infinite, or no solution.****  ***### 25\. Solving Consistent Systems
    (Unique vs. Infinite Solutions)
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解以自由变量的形式表示，显示系统是否有唯一解、无限解或无解。****  ***### 25\. 解一致系统（唯一解与无限解）
- en: Now that we can spot pivots and free variables, we can classify systems of equations
    as having a unique solution or infinitely many solutions (assuming they’re consistent).
    In this lab, we’ll practice solving both types.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以识别主元和自由变量，我们可以将方程组分类为具有唯一解或无限多解（假设它们是一致的）。在本实验中，我们将练习解决这两种类型。
- en: Set Up Your Lab
  id: totrans-697
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE242]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Unique solution example
  id: totrans-700
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 唯一解示例
- en: 'System:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 系统：
- en: \[ x + y = 3, \quad 2x - y = 0 \]
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x + y = 3, \quad 2x - y = 0 \]
- en: '[PRE243]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '*[PRE244]*  *2.  Infinite solution example'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE244]*  *2.  无限解示例'
- en: 'System:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 系统：
- en: \[ x + y + z = 2, \quad 2x + 2y + 2z = 4 \]
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x + y + z = 2, \quad 2x + 2y + 2z = 4 \]
- en: '[PRE245]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '*[PRE246]*  *Only one pivot → two free variables.'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE246]*  *只有一个主元 → 两个自由变量。'
- en: 'Interpretation:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 解释：
- en: \(x = 2 - y - z\)
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(x = 2 - y - z\)
- en: \(y, z\) are free
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(y, z\)是自由变量
- en: Infinite solutions described by parameters.
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无穷多解由参数描述。
- en: Classifying consistency
  id: totrans-713
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分类一致性
- en: 'A system is consistent if the RREF does *not* have a row like:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 如果简化行形（RREF）**不**包含如下形式的行，则系统是一致的：
- en: \[ [0, 0, 0, c] \quad (c \neq 0) \]
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: \[ [0, 0, 0, c] \quad (c \neq 0) \]
- en: 'Example consistent system:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 示例一致系统：
- en: '[PRE247]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '*[PRE248]*  *Example inconsistent system (no solution):'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE248]*  *示例不一致系统（无解）：'
- en: '[PRE249]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '*[PRE250]*  *The second one ends with `[0,0,1]`, meaning contradiction (0 =
    1).'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE250]*  *第二个以 `[0,0,1]` 结尾，意味着矛盾（0 = 1）。'
- en: Quick NumPy comparison
  id: totrans-721
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速 NumPy 比较
- en: 'For systems with unique solutions:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有唯一解的系统：
- en: '[PRE251]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '*[PRE252]*  *For systems with infinite solutions, `np.linalg.solve` will fail,
    but SymPy handles parametric solutions.*****  ***#### Try It Yourself'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE252]*  *对于具有无穷多解的系统，`np.linalg.solve` 将会失败，但 SymPy 可以处理参数解。*****  ***####
    尝试自己操作'
- en: 'Solve:'
  id: totrans-725
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 求解：
- en: \[ x + y + z = 1, \quad 2x + 3y + z = 2 \]
  id: totrans-726
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ x + y + z = 1, \quad 2x + 3y + z = 2 \]
- en: Is the solution unique or infinite?
  id: totrans-727
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解是唯一的还是无穷多的？
- en: 'Check consistency of:'
  id: totrans-728
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查以下的一致性：
- en: \[ x + 2y = 3, \quad 2x + 4y = 8 \]
  id: totrans-729
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ x + 2y = 3, \quad 2x + 4y = 8 \]
- en: 'Build a random 3×4 augmented matrix and compute its RREF. Identify:'
  id: totrans-730
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个随机的 3×4 增广矩阵并计算其简化行形（RREF）。识别：
- en: Does it have a unique solution, infinitely many, or none?
  id: totrans-731
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个唯一解、无穷多解还是没有解？
- en: The Takeaway
  id: totrans-732
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**总结**'
- en: 'Unique solution: pivot in every variable column.'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一解：每个变量列都有一个主元。
- en: 'Infinite solutions: free variables remain, system is still consistent.'
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无穷多解：自由变量仍然存在，系统仍然是一致的。
- en: 'No solution: an inconsistent row appears.'
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有解：出现不一致的行。
- en: Understanding pivots and free variables gives a complete picture of the solution
    set.****  ***### 26\. Detecting Inconsistency (When No Solution Exists)
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 理解主元和自由变量可以给出解集的完整图景。****  ***### 26. 检测不一致性（当不存在解时）
- en: Not all systems of linear equations can be solved. Some are inconsistent, meaning
    the equations contradict each other. In this lab, we’ll learn how to recognize
    inconsistency using augmented matrices and RREF.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有线性方程组都可以求解。有些是不一致的，意味着方程相互矛盾。在本实验中，我们将学习如何使用增广矩阵和简化行形（RREF）来识别不一致性。
- en: Set Up Your Lab
  id: totrans-738
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置你的实验环境
- en: '[PRE253]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: An inconsistent system
  id: totrans-741
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个不一致的系统
- en: \[ x + y = 2, \quad 2x + 2y = 5 \]
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x + y = 2, \quad 2x + 2y = 5 \]
- en: Notice the second equation looks like a multiple of the first, but the constant
    doesn’t match - contradiction.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第二个方程看起来像是第一个方程的倍数，但常数不匹配 - 矛盾。
- en: '[PRE254]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '*[PRE255]*  *RREF gives:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE255]*  *简化行形（RREF）给出：'
- en: \[ \begin{bmatrix} 1 & 1 & 2 \\ 0 & 0 & 1 \end{bmatrix} \]
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{bmatrix} 1 & 1 & 2 \\ 0 & 0 & 1 \end{bmatrix} \]
- en: The last row means \(0 = 1\), so no solution exists.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行意味着 \(0 = 1\)，所以不存在解。
- en: A consistent system (for contrast)
  id: totrans-748
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个一致的系统（用于对比）
- en: \[ x + y = 2, \quad 2x + 2y = 4 \]
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x + y = 2, \quad 2x + 2y = 4 \]
- en: '[PRE256]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '*[PRE257]*  *This reduces to one equation and a redundant row of zeros → infinitely
    many solutions.'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE257]*  *这简化为一个方程和一个多余的零行 → 无穷多解。'
- en: Visualizing inconsistency (2D case)
  id: totrans-752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化不一致性（2D 情况）
- en: 'System:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 系统：
- en: \[ x + y = 2 \quad \text{and} \quad x + y = 3 \]
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x + y = 2 \quad \text{和} \quad x + y = 3 \]
- en: These are parallel lines that never meet.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是永远不会相交的平行线。
- en: '[PRE258]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '*![](../Images/5025c9114c6fb19aa93f8af5073b3f20.png)*  *The two lines are parallel
    → no solution.'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/5025c9114c6fb19aa93f8af5073b3f20.png)*  *这两条线是平行的 → 没有解。'
- en: Detecting inconsistency automatically
  id: totrans-758
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动检测不一致性
- en: We can scan the RREF for a row of the form \([0, 0, …, c]\) with \(c \neq 0\).
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扫描简化行形（RREF）以查找形式为 \([0, 0, …, c]\) 的行，其中 \(c \neq 0\)。
- en: '[PRE259]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '*[PRE260]****  ***#### Try It Yourself'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE260]****  ***#### 尝试自己操作'
- en: 'Test the system:'
  id: totrans-762
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试系统：
- en: \[ x + 2y = 4, \quad 2x + 4y = 10 \]
  id: totrans-763
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ x + 2y = 4, \quad 2x + 4y = 10 \]
- en: Write the augmented matrix and check if it’s inconsistent.
  id: totrans-764
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 写出增广矩阵并检查它是否不一致。
- en: Build a random 2×3 augmented matrix with integer entries. Use `is_inconsistent`
    to check.
  id: totrans-765
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个随机的 2×3 增广矩阵，并使用 `is_inconsistent` 检查。
- en: Plot two linear equations in 2D. Adjust constants to see when they intersect
    (consistent) vs when they are parallel (inconsistent).
  id: totrans-766
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 2D 中绘制两个线性方程。调整常数以查看它们何时相交（一致）以及何时平行（不一致）。
- en: The Takeaway
  id: totrans-767
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**总结**'
- en: A system is inconsistent if RREF contains a row like \([0,0,…,c]\) with \(c
    \neq 0\).
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果简化行形（RREF）包含形如 \([0,0,…,c]\) 的行且 \(c \neq 0\)，则系统是不一致的。
- en: Geometrically, this means the equations describe parallel lines (2D), parallel
    planes (3D), or higher-dimensional contradictions.
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几何上，这意味着方程描述了平行线（2D）、平行平面（3D）或更高维度的矛盾。
- en: Recognizing inconsistency quickly saves time and avoids chasing impossible solutions.****  ***###
    27\. Gaussian Elimination by Hand (A Disciplined Procedure)
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速识别不一致性可以节省时间并避免追求不可能的解。****  ***### 27. 手动高斯消元（一种纪律性的程序）
- en: Gaussian elimination is the systematic way to solve linear systems using row
    operations. It transforms the augmented matrix into row-echelon form (REF) and
    then uses back substitution to find solutions. In this lab, we’ll walk step by
    step through the process.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯消元法是使用行操作系统地求解线性系统的方法。它将增广矩阵转换为行阶梯形（REF），然后使用回代找到解。在这个实验中，我们将逐步讲解这个过程。
- en: Set Up Your Lab
  id: totrans-772
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置你的实验室
- en: '[PRE261]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Example system
  id: totrans-775
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 示例系统
- en: \[ \begin{cases} x + y + z = 6 \\ 2x + 3y + z = 14 \\ x + 2y + 3z = 14 \end{cases}
    \]
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{cases} x + y + z = 6 \\ 2x + 3y + z = 14 \\ x + 2y + 3z = 14 \end{cases}
    \]
- en: '[PRE262]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '*[PRE263]*  *2.  Step 1: Get a pivot in the first column'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE263]*  *2.  第一步：第一列的枢轴操作'
- en: Make the pivot at (0,0) into 1 (it already is). Now eliminate below it.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 将(0,0)处的枢轴元素设为1（它已经是了）。现在消除它下面的内容。
- en: '[PRE264]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '*[PRE265]*  *3.  Step 2: Pivot in the second column'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE265]*  *3.  第二步：第二列的枢轴操作'
- en: Make the pivot in row 1, col 1 equal to 1.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 将第1行第1列的枢轴元素设为1。
- en: '[PRE266]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '*[PRE267]*  *Now eliminate below:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE267]*  *现在消除以下内容：'
- en: '[PRE268]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '*[PRE269]*  *4.  Step 3: Pivot in the third column'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE269]*  *4.  第三步：第三列的枢轴操作'
- en: Make the bottom-right entry into 1.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 将右下角的元素设为1。
- en: '[PRE270]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '*[PRE271]*  *At this point, the matrix is in row-echelon form (REF).'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE271]*  *此时，矩阵已经处于行阶梯形（REF）。'
- en: Back substitution
  id: totrans-790
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回代
- en: 'Now solve from the bottom up:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从下往上求解：
- en: '[PRE272]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '*[PRE273]*  *6.  Verification'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE273]*  *6.  验证'
- en: '[PRE274]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '*[PRE275]*  *The results match.*******  ***#### Try It Yourself'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE275]*  *结果匹配。*******  ***#### 尝试自己来做'
- en: 'Solve:'
  id: totrans-796
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解：
- en: \[ 2x + y = 5, \quad 4x - 6y = -2 \]
  id: totrans-797
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ 2x + y = 5, \quad 4x - 6y = -2 \]
- en: using Gaussian elimination manually in code.
  id: totrans-798
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用代码手动进行高斯消元。
- en: Create a random 3×4 augmented matrix and reduce it step by step, printing after
    each row operation.
  id: totrans-799
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个随机的3×4增广矩阵，并逐步进行行操作，每次行操作后打印。
- en: Compare your manual elimination to SymPy’s RREF with `Matrix.rref()`.
  id: totrans-800
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的手动消元与SymPy的RREF通过 `Matrix.rref()` 进行比较。
- en: The Takeaway
  id: totrans-801
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Gaussian elimination is a disciplined sequence of row operations.
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高斯消元法是一系列有序的行操作。
- en: It reduces the matrix to row-echelon form, from which back substitution is straightforward.
  id: totrans-803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将矩阵化简为行阶梯形，从那里回代是直接的。
- en: This method is the backbone of solving systems by hand and underlies many numerical
    algorithms.****  ***### 28\. Back Substitution and Solution Sets (Finishing Cleanly)
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法是手动求解系统的基础，也是许多数值算法的基础。****  ***### 28\. 回代和解集（干净利落地完成）
- en: Once Gaussian elimination reduces a system to row-echelon form (REF), the final
    step is back substitution. This means solving variables starting from the last
    equation and working upward. In this lab, we’ll practice both unique and infinite
    solution cases.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦高斯消元法将一个系统化简为行阶梯形（REF），最后一步是回代。这意味着从最后一个方程开始解变量，并向上工作。在这个实验中，我们将练习唯一解和无限解的情况。
- en: Set Up Your Lab
  id: totrans-806
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置你的实验室
- en: '[PRE276]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Unique solution example
  id: totrans-809
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 唯一解示例
- en: 'System:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 系统：
- en: \[ x + y + z = 6, \quad 2y + 5z = -4, \quad z = 3 \]
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x + y + z = 6, \quad 2y + 5z = -4, \quad z = 3 \]
- en: 'Row-echelon form looks like:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 行阶梯形看起来像：
- en: \[ \begin{bmatrix} 1 & 1 & 1 & 6 \\ 0 & 2 & 5 & -4 \\ 0 & 0 & 1 & 3 \end{bmatrix}
    \]
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{bmatrix} 1 & 1 & 1 & 6 \\ 0 & 2 & 5 & -4 \\ 0 & 0 & 1 & 3 \end{bmatrix}
    \]
- en: 'Solve bottom-up:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 从下往上求解：
- en: '[PRE277]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '*[PRE278]*  *2.  Infinite solution example'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE278]*  *2.  无穷多解示例'
- en: 'System:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 系统：
- en: \[ x + y + z = 2, \quad 2x + 2y + 2z = 4 \]
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x + y + z = 2, \quad 2x + 2y + 2z = 4 \]
- en: 'After elimination:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 消元后：
- en: \[ \begin{bmatrix} 1 & 1 & 1 & 2 \\ 0 & 0 & 0 & 0 \end{bmatrix} \]
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{bmatrix} 1 & 1 & 1 & 2 \\ 0 & 0 & 0 & 0 \end{bmatrix} \]
- en: 'This means:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着：
- en: 'Equation: \(x + y + z = 2\).'
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方程：\(x + y + z = 2\)。
- en: 'Free variables: choose \(y\) and \(z\).'
  id: totrans-823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自由变量：选择 \(y\) 和 \(z\)。
- en: 'Let \(y = s, z = t\). Then:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 令 \(y = s, z = t\)。然后：
- en: \[ x = 2 - s - t \]
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x = 2 - s - t \]
- en: 'So the solution set is:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，解集是：
- en: '[PRE279]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '*[PRE280]*  *3.  Consistency check with RREF'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE280]*  *3.  与RREF的一致性检查'
- en: 'We can use SymPy to confirm solution sets:'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用SymPy来确认解集：
- en: '[PRE281]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '*[PRE282]*  *The second row disappears, showing infinite solutions.'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE282]*  *第二行消失，显示出无穷多解。'
- en: Encoding solution sets
  id: totrans-832
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编码解集
- en: General solutions are often written in parametric vector form.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 一般解通常以参数向量形式表示。
- en: 'For the infinite solution above:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上面的无穷多解：
- en: \[ (x,y,z) = (2,0,0) + s(-1,1,0) + t(-1,0,1) \]
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: \[ (x,y,z) = (2,0,0) + s(-1,1,0) + t(-1,0,1) \]
- en: This shows the solution space is a plane in \(\mathbb{R}^3\).***  ***#### Try
    It Yourself
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明解空间是 \(\mathbb{R}^3\) 中的一个平面。***  ***#### 尝试自己来做
- en: 'Solve:'
  id: totrans-837
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解：
- en: \[ x + 2y = 5, \quad y = 1 \]
  id: totrans-838
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ x + 2y = 5, \quad y = 1 \]
- en: Do back substitution by hand and check with NumPy.
  id: totrans-839
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过手动回代并使用NumPy进行验证。
- en: 'Take the system:'
  id: totrans-840
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下系统：
- en: \[ x + y + z = 1, \quad 2x + 2y + 2z = 2 \]
  id: totrans-841
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ x + y + z = 1, \quad 2x + 2y + 2z = 2 \]
- en: Write its solution set in parametric form.
  id: totrans-842
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将其解集写成参数形式。
- en: Use `Matrix.rref()` on a 3×4 random augmented matrix. Identify pivot and free
    variables, then describe the solution set.
  id: totrans-843
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个 3×4 随机增广矩阵上使用 `Matrix.rref()`。识别主元和自由变量，然后描述解集。
- en: The Takeaway
  id: totrans-844
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Back substitution is the cleanup step after Gaussian elimination.
  id: totrans-845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回代是高斯消元后的清理步骤。
- en: It reveals whether the system has a unique solution or infinitely many.
  id: totrans-846
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它揭示了系统是否有唯一解或无限多个解。
- en: Solutions can be expressed explicitly (unique case) or parametrically (infinite
    case).****  ***### 29\. Rank and Its First Meaning (Pivots as Information)
  id: totrans-847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解可以明确表达（唯一情况）或参数化（无限情况）。****  ***### 29. 秩及其第一含义（主元作为信息）
- en: The rank of a matrix tells us how much independent information it contains.
    Rank is one of the most important concepts in linear algebra because it connects
    to pivots, independence, dimension, and the number of solutions to a system.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的秩告诉我们它包含多少独立信息。秩是线性代数中最重要概念之一，因为它与主元、独立性、维度和系统解的数量相关联。
- en: Set Up Your Lab
  id: totrans-849
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE283]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码分析'
- en: Rank definition The rank is the number of pivots (leading ones) in the row-echelon
    form of a matrix.
  id: totrans-852
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 秩的定义 秩是矩阵行阶梯形式中主元（首一）的数量。
- en: 'Example:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE284]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '*[PRE285]*  **   The second row is a multiple of the first, so the rank is
    less than 3.'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE285]*  **   第二行是第一行的倍数，所以秩小于 3。'
- en: Only two independent rows → rank = 2.
  id: totrans-856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有两条独立行 → 秩 = 2。
- en: Rank and solutions to \(A·x = b\)
  id: totrans-857
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 秩和 \(A·x = b\) 的解
- en: 'Consider:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: \[ \begin{cases} x + y + z = 3 \\ 2x + 2y + 2z = 6 \\ x - y = 0 \end{cases}
    \]
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{cases} x + y + z = 3 \\ 2x + 2y + 2z = 6 \\ x - y = 0 \end{cases}
    \]
- en: '[PRE286]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '*[PRE287]*  **   If rank(A) = rank([A|b]) = number of variables → unique solution.'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE287]*  **   如果 rank(A) = rank([A|b]) = 变量的数量 → 唯一解。'
- en: If rank(A) = rank([A|b]) < number of variables → infinite solutions.
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 rank(A) = rank([A|b]) < 变量的数量 → 无穷多解。
- en: If rank(A) < rank([A|b]) → no solution.
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 rank(A) < rank([A|b]) → 无解。
- en: NumPy comparison
  id: totrans-864
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy 比较
- en: '[PRE288]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '*[PRE289]*  *4.  Rank as “dimension of information”'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE289]*  *4.  秩作为“信息维度”'
- en: 'The rank equals:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 秩等于：
- en: The number of independent rows.
  id: totrans-868
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立行的数量。
- en: The number of independent columns.
  id: totrans-869
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立列的数量。
- en: The dimension of the column space.
  id: totrans-870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列空间的维度。
- en: '[PRE290]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '*[PRE291]*  *All columns are multiples → only one independent direction → rank
    = 1.****  ***#### Try It Yourself'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE291]*  *所有列都是倍数 → 只有一个独立方向 → 秩 = 1。****  ***#### 尝试自己'
- en: 'Compute the rank of:'
  id: totrans-873
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算其秩。
- en: \[ \begin{bmatrix} 1 & 2 & 3 \\ 2 & 4 & 6 \\ 3 & 6 & 9 \end{bmatrix} \]
  id: totrans-874
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ \begin{bmatrix} 1 & 2 & 3 \\ 2 & 4 & 6 \\ 3 & 6 & 9 \end{bmatrix} \]
- en: What do you expect?
  id: totrans-875
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你期望什么？
- en: Create a random 4×4 matrix with `np.random.randint`. Compute its rank with both
    SymPy and NumPy.
  id: totrans-876
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `np.random.randint` 创建一个随机的 4×4 矩阵。使用 SymPy 和 NumPy 计算其秩。
- en: 'Test solution consistency using rank: build a system where rank(A) ≠ rank([A|b])
    and show it has no solution.'
  id: totrans-877
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用秩测试解的一致性：构建一个 rank(A) ≠ rank([A|b]) 的系统，并显示它没有解。
- en: The Takeaway
  id: totrans-878
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Rank = number of pivots = dimension of independent information.
  id: totrans-879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rank = 旋转数 = 独立信息的维度。
- en: Rank reveals whether a system has no solution, one solution, or infinitely many.
  id: totrans-880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秩揭示了系统是否有无解、一个解或无限多个解。
- en: Rank connects algebra (pivots) with geometry (dimension of subspaces).****  ***###
    30\. LU Factorization (Elimination Captured as L and U)
  id: totrans-881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秩将代数（主元）与几何（子空间的维度）联系起来。****  ***### 30. LU 分解（消元作为 L 和 U）
- en: 'Gaussian elimination can be recorded in a neat factorization:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯消元可以记录在整洁的分解中：
- en: \[ A = LU \]
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: \[ A = LU \]
- en: where \(L\) is a lower triangular matrix (recording the multipliers we used)
    and \(U\) is an upper triangular matrix (the result of elimination). This is called
    LU factorization. It’s a powerful tool for solving systems efficiently.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(L\) 是一个下三角矩阵（记录我们使用的乘数）和 \(U\) 是一个上三角矩阵（消元的结果）。这被称为 LU 分解。它是解决系统的高效工具。
- en: Set Up Your Lab
  id: totrans-885
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE292]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码分析'
- en: Example matrix
  id: totrans-888
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 示例矩阵
- en: '[PRE293]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '*[PRE294]*  *2.  LU decomposition with SciPy'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE294]*  *2.  使用 SciPy 进行 LU 分解'
- en: '[PRE295]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '*[PRE296]*  *Here, \(P\) handles row swaps (partial pivoting), \(L\) is lower
    triangular, and \(U\) is upper triangular.'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE296]*  *在这里，\(P\) 处理行交换（部分主元），\(L\) 是下三角矩阵，\(U\) 是上三角矩阵。'
- en: Verifying the factorization
  id: totrans-893
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证分解
- en: '[PRE297]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '*[PRE298]*  *4.  Solving a system with LU'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE298]*  *4.  使用 LU 解方程组'
- en: 'Suppose we want to solve \(Ax = b\). Instead of working directly with \(A\),
    we solve in two steps:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要解 \(Ax = b\)。我们不是直接与 \(A\) 一起工作，而是分两步解决：
- en: Solve \(Ly = Pb\) (forward substitution).
  id: totrans-897
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解 \(Ly = Pb\)（前向替换）。
- en: Solve \(Ux = y\) (back substitution).
  id: totrans-898
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解 \(Ux = y\)（回代）。
- en: '[PRE299]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '*[PRE300]*  *5.  Efficiency advantage'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE300]*  *5.  效率优势'
- en: If we have to solve many systems with the same \(A\) but different \(b\), we
    only compute \(LU\) once, then reuse it. This saves a lot of computation.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须解决许多具有相同 \(A\) 但不同 \(b\) 的系统，我们只需计算一次 \(LU\)，然后重复使用它。这可以节省大量的计算。
- en: NumPy’s built-in rank-revealing factorization
  id: totrans-902
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy 的内置秩揭示分解
- en: While NumPy doesn’t have `lu` directly, it works seamlessly with SciPy. For
    large matrices, LU decomposition is the backbone of solvers like `np.linalg.solve`.****  ***####
    Try It Yourself
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 NumPy 没有直接提供 `lu` 函数，但它与 SciPy 工作得非常顺畅。对于大型矩阵，LU 分解是像 `np.linalg.solve` 这样的求解器的基石。****  ***####
    尝试自己操作
- en: Compute LU decomposition for
  id: totrans-904
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对以下矩阵进行 LU 分解：
- en: \[ A = \begin{bmatrix} 1 & 2 & 0 \\ 3 & 4 & 4 \\ 5 & 6 & 3 \end{bmatrix} \]
  id: totrans-905
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ A = \begin{bmatrix} 1 & 2 & 0 \\ 3 & 4 & 4 \\ 5 & 6 & 3 \end{bmatrix} \]
- en: Verify \(P·L·U = A\).
  id: totrans-906
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 验证 \(P·L·U = A\)。
- en: Solve \(Ax = b\) with
  id: totrans-907
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用
- en: \[ b = [3,7,8] \]
  id: totrans-908
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ b = [3,7,8] \]
- en: using LU factorization.
  id: totrans-909
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 LU 分解。
- en: Compare solving with LU factorization vs directly using `np.linalg.solve(A,b)`.
    Are the answers the same?
  id: totrans-910
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将使用 LU 分解求解与直接使用 `np.linalg.solve(A,b)` 进行比较。答案是否相同？
- en: The Takeaway
  id: totrans-911
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: 'LU factorization captures Gaussian elimination in matrix form: \(A = P·L·U\).'
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LU 分解在矩阵形式中捕捉高斯消元法：\(A = P·L·U\)。
- en: It allows fast repeated solving of systems with different right-hand sides.
  id: totrans-913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许快速重复求解具有不同右侧的系统。
- en: LU decomposition is a core technique in numerical linear algebra and the basis
    of many solvers.*******************************  ***## Chapter 4\. Vector Spaces
    and Subspaces
  id: totrans-914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LU 分解是数值线性代数中的一个核心技术，也是许多求解器的基础。*******************************  ***## 第四章\.
    向量空间与子空间
- en: 31\. Axioms of Vector Spaces (What “Space” Really Means)
  id: totrans-915
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31\. 向量空间公理（“空间”真正意味着什么）
- en: Vector spaces generalize what we’ve been doing with vectors and matrices. Instead
    of just \(\mathbb{R}^n\), a vector space is any collection of objects (vectors)
    where addition and scalar multiplication follow specific axioms (rules). In this
    lab, we’ll explore these axioms concretely with Python.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 向量空间推广了我们一直对向量矩阵所做的工作。与 \(\mathbb{R}^n\) 不同，向量空间是任何对象（向量）的集合，其中加法和数乘遵循特定的公理（规则）。在这个实验中，我们将使用
    Python 具体探索这些公理。
- en: Set Up Your Lab
  id: totrans-917
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE301]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: 'Vector space example: \(\mathbb{R}^2\)'
  id: totrans-920
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向量空间示例：\(\mathbb{R}^2\)
- en: 'Let’s check two rules (axioms): closure under addition and scalar multiplication.'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查两个规则（公理）：加法封闭性和数乘封闭性。
- en: '[PRE302]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '*[PRE303]*  *Both results are still in \(\mathbb{R}^2\).'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE303]*  *两个结果仍然在 \(\mathbb{R}^2\) 中。'
- en: Zero vector and additive inverses
  id: totrans-924
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 零向量和加法逆元
- en: Every vector space must contain a zero vector, and every vector must have an
    additive inverse.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 每个向量空间都必须包含一个零向量，每个向量都必须有一个加法逆元。
- en: '[PRE304]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '*[PRE305]*  *3.  Distributive and associative properties'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE305]*  *3.  分配律和结合律'
- en: 'Check:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 检查：
- en: \(a(u+v) = au + av\)
  id: totrans-929
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(a(u+v) = au + av\)
- en: \((a+b)u = au + bu\)
  id: totrans-930
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \((a+b)u = au + bu\)
- en: '[PRE306]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '*[PRE307]*  *Both equalities hold → distributive laws confirmed.'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE307]*  *两个等式都成立 → 分配律得到证实。'
- en: A set that fails to be a vector space
  id: totrans-933
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个不能成为向量空间的集合
- en: Consider only positive numbers with normal addition and scalar multiplication.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑只有正数，使用正常的加法和数乘。
- en: '[PRE308]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '*[PRE309]*  *Negative results leave the set → not a vector space.'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE309]*  *负结果离开集合 → 不是一个向量空间。'
- en: Python helper to check axioms
  id: totrans-937
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python 辅助函数用于检查公理
- en: We can quickly check if a set of vectors is closed under addition and scalar
    multiplication.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速检查一个向量集是否在加法和数乘下封闭。
- en: '[PRE310]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '*[PRE311]*  *This small set is closed → it forms a vector space (a subspace
    of \(\mathbb{R}^2\)).*****  ***#### Try It Yourself'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE311]*  *这个小的集合是封闭的 → 它形成了一个向量空间（\(\mathbb{R}^2\) 的子空间）。*****  ***####
    尝试自己操作'
- en: Verify that \(\mathbb{R}^3\) satisfies the vector space axioms using random
    vectors.
  id: totrans-941
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用随机向量验证 \(\mathbb{R}^3\) 满足向量空间公理。
- en: Test whether the set of all 2×2 matrices forms a vector space under normal addition
    and scalar multiplication.
  id: totrans-942
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试所有 2×2 矩阵的集合在正常加法和数乘下是否形成向量空间。
- en: Find an example of a set that fails closure (e.g., integers under division).
  id: totrans-943
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个不满足封闭性的集合的例子（例如，整数除法）。
- en: The Takeaway
  id: totrans-944
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: A vector space is any set where addition and scalar multiplication satisfy 10
    standard axioms.
  id: totrans-945
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量空间是任何满足 10 个标准公理的加法和数乘集合。
- en: These rules ensure consistent algebraic behavior.
  id: totrans-946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些规则确保了代数行为的连贯性。
- en: Many objects beyond arrows in \(\mathbb{R}^n\) (like polynomials or matrices)
    are vector spaces too.****  ***### 32\. Subspaces, Column Space, and Null Space
    (Where Solutions Live)
  id: totrans-947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多对象（如多项式或矩阵）在\(\mathbb{R}^n\)中（除了箭头之外）也是向量空间。****  ***### 32\. 子空间、列空间和零空间（解的居住地）
- en: 'A subspace is a smaller vector space sitting inside a bigger one. For matrices,
    two subspaces show up all the time:'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 子空间是位于更大向量空间内部的较小向量空间。对于矩阵，两个子空间经常出现：
- en: 'Column space: all combinations of the matrix’s columns (possible outputs of
    \(Ax\)).'
  id: totrans-949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列空间：矩阵列的所有组合（\(Ax\)的可能输出）。
- en: 'Null space: all vectors \(x\) such that \(Ax = 0\) (inputs that vanish).'
  id: totrans-950
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零空间：所有满足\(Ax = 0\)的向量\(x\)（消失的输入）。
- en: This lab explores both in Python.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验在Python中探索了这两个方面。
- en: Set Up Your Lab
  id: totrans-952
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置你的实验室
- en: '[PRE312]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码解析'
- en: Column space basics
  id: totrans-955
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列空间基础
- en: 'Take:'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 取：
- en: \[ A = \begin{bmatrix} 1 & 2 \\ 2 & 4 \\ 3 & 6 \end{bmatrix} \]
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: \[ A = \begin{bmatrix} 1 & 2 \\ 2 & 4 \\ 3 & 6 \end{bmatrix} \]
- en: '[PRE313]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '*[PRE314]*  **   The second column is a multiple of the first → column space
    has dimension 1.'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE314]*  **   第二列是第一列的倍数 → 列空间维度为1。'
- en: All outputs of \(Ax\) lie on a line in \(\mathbb{R}^3\).
  id: totrans-960
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(Ax\)的所有输出都位于\(\mathbb{R}^3\)中的一条线上。
- en: Null space basics
  id: totrans-961
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 零空间基础
- en: '[PRE315]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '*[PRE316]*  *The null space contains all \(x\) where \(Ax=0\). Here, the null
    space is 1-dimensional (vectors like \([-2,1]\)).'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE316]*  *零空间包含所有\(Ax=0\)的\(x\)。在这里，零空间是一维的（如\([-2,1]\)这样的向量）。'
- en: A full-rank example
  id: totrans-964
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完全秩的例子
- en: '[PRE317]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '*[PRE318]*  **   Column space = all of \(\mathbb{R}^3\).'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE318]*  **   列空间 = \(\mathbb{R}^3\)的全部。'
- en: Null space = only the zero vector.
  id: totrans-967
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零空间 = 只有零向量。
- en: Geometry link
  id: totrans-968
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几何链接
- en: 'For \(A\) (rank 1, 2 columns):'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 对于\(A\)（秩1，2列）：
- en: 'Column space: line in \(\mathbb{R}^3\).'
  id: totrans-970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列空间：\(\mathbb{R}^3\)中的线。
- en: 'Null space: line in \(\mathbb{R}^2\).'
  id: totrans-971
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零空间：\(\mathbb{R}^2\)中的线。
- en: 'Together they explain the system \(Ax = b\):'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 一起解释了系统\(Ax = b\)：
- en: If \(b\) is outside the column space, no solution exists.
  id: totrans-973
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果\(b\)在列空间之外，则不存在解。
- en: If \(b\) is inside, solutions differ by a vector in the null space.
  id: totrans-974
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果\(b\)在内部，解将相差零空间中的一个向量。
- en: Quick NumPy version
  id: totrans-975
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速NumPy版本
- en: NumPy doesn’t directly give null space, but we can compute it with SVD.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy不直接给出零空间，但我们可以通过奇异值分解（SVD）来计算它。
- en: '[PRE319]'
  id: totrans-977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '*[PRE320]****  ***#### Try It Yourself'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE320]****  ***#### 尝试自己操作'
- en: Find the column space and null space of
  id: totrans-979
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出以下矩阵的列空间和零空间：
- en: \[ \begin{bmatrix} 1 & 1 \\ 0 & 1 \\ 0 & 0 \end{bmatrix} \]
  id: totrans-980
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ \begin{bmatrix} 1 & 1 \\ 0 & 1 \\ 0 & 0 \end{bmatrix} \]
- en: How many dimensions does each have?
  id: totrans-981
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个有多少维？
- en: Generate a random 3×3 matrix. Compute its rank, column space, and null space.
  id: totrans-982
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个随机的3×3矩阵。计算其秩、列空间和零空间。
- en: Solve \(Ax = b\) with
  id: totrans-983
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下方法求解\(Ax = b\)：
- en: \[ A = \begin{bmatrix} 1 & 2 \\ 2 & 4 \\ 3 & 6 \end{bmatrix}, \quad b = \begin{bmatrix}
    1 \\ 2 \\ 3 \end{bmatrix} \]
  id: totrans-984
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ A = \begin{bmatrix} 1 & 2 \\ 2 & 4 \\ 3 & 6 \end{bmatrix}, \quad b = \begin{bmatrix}
    1 \\ 2 \\ 3 \end{bmatrix} \]
- en: and describe why it has infinitely many solutions.
  id: totrans-985
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并描述为什么它有无限多个解。
- en: The Takeaway
  id: totrans-986
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: The column space = all possible outputs of a matrix.
  id: totrans-987
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列空间 = 矩阵的所有可能输出。
- en: The null space = all inputs that map to zero.
  id: totrans-988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零空间 =映射到零的所有输入。
- en: These subspaces give the complete picture of what a matrix does.****  ***###
    33\. Span and Generating Sets (Coverage of a Space)
  id: totrans-989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些子空间给出了矩阵所做事情的完整图景。****  ***### 33\. 张量和生成集（空间的覆盖）
- en: The span of a set of vectors is all the linear combinations you can make from
    them. If a set of vectors can “cover” a whole space, we call it a generating set.
    This lab shows how to compute and visualize spans.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 向量集的张量是从它们中可以做出的所有线性组合。如果一个向量集可以“覆盖”整个空间，我们称之为生成集。这个实验展示了如何计算和可视化张量。
- en: Set Up Your Lab
  id: totrans-991
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置你的实验室
- en: '[PRE321]'
  id: totrans-992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码解析'
- en: Span in \(\mathbb{R}^2\)
  id: totrans-994
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: \(\mathbb{R}^2\)中的张量
- en: Two vectors that aren’t multiples span the whole plane.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 两个非倍数向量可以张成整个平面。
- en: '[PRE322]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '*[PRE323]*  *Rank = 2 → the span of \(\{u,v\}\) is all of \(\mathbb{R}^2\).'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE323]*  *秩 = 2 → \(\{u,v\}\)的张量是\(\mathbb{R}^2\)的全部。'
- en: Dependent vectors (smaller span)
  id: totrans-998
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖向量（较小的张量）
- en: '[PRE324]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '*[PRE325]*  *Rank = 1 → these vectors only span a line.'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE325]*  *秩 = 1 → 这些向量仅构成一条线。'
- en: Visualizing a span
  id: totrans-1001
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化张量
- en: Let’s see what the span of two vectors looks like.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两个向量的张量看起来像什么。
- en: '[PRE326]'
  id: totrans-1003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '*![](../Images/3be8bde45f66675a1034af9296fd97e5.png)*  *You’ll see a filled
    grid - the entire plane, because the two vectors are independent.'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/3be8bde45f66675a1034af9296fd97e5.png)*  *你会看到一个填充的网格 - 整个平面，因为这两个向量是独立的。'
- en: Generating set of a space
  id: totrans-1005
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 空间的生成集
- en: 'For \(\mathbb{R}^3\):'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 对于\(\mathbb{R}^3\)：
- en: '[PRE327]'
  id: totrans-1007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '*[PRE328]*  *Rank = 3 → this set spans the whole space.'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE328]*  *秩 = 3 → 这个集合张成整个空间。'
- en: Testing if a vector is in the span
  id: totrans-1009
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试向量是否在张量中
- en: 'Example: Is \([3,5]\) in the span of \([1,2]\) and \([2,1]\)?'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：\([3,5]\) 是否在 \([1,2]\) 和 \([2,1]\) 的范围内？
- en: '[PRE329]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '*[PRE330]*  *If a solution exists, the target is in the span.*****  ***####
    Try It Yourself'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE330]*  *如果存在解，目标在范围内。*****  ***#### 尝试自己操作'
- en: Test if \([4,6]\) is in the span of \([1,2]\).
  id: totrans-1013
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试 \([4,6]\) 是否在 \([1,2]\) 的范围内。
- en: Visualize the span of \([1,0,0]\) and \([0,1,0]\) in \(\mathbb{R}^3\). What
    does it look like?
  id: totrans-1014
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 \(\mathbb{R}^3\) 中可视化 \([1,0,0]\) 和 \([0,1,0]\) 的范围。它看起来像什么？
- en: Create a random 3×3 matrix. Use `rank()` to check if its columns span \(\mathbb{R}^3\).
  id: totrans-1015
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个随机的 3×3 矩阵。使用 `rank()` 检查其列是否生成 \(\mathbb{R}^3\)。
- en: The Takeaway
  id: totrans-1016
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Span = all linear combinations of a set of vectors.
  id: totrans-1017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围 = 一组向量的所有线性组合。
- en: Independent vectors span bigger spaces; dependent ones collapse to smaller spaces.
  id: totrans-1018
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立向量生成的空间更大；相关的向量会塌缩到更小的空间。
- en: Generating sets are the foundation of bases and coordinate systems.****  ***###
    34\. Linear Independence and Dependence (No Redundancy vs. Redundancy)
  id: totrans-1019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成集是基和坐标系统的基础。****  ***### 34. 线性独立与相关（无冗余与冗余）
- en: A set of vectors is linearly independent if none of them can be written as a
    combination of the others. If at least one can, the set is dependent. This distinction
    tells us whether a set of vectors has redundancy.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 一组向量是线性独立的，如果其中没有一个可以写成其他向量的组合。如果至少有一个可以，那么这个集合就是相关的。这种区别告诉我们一组向量是否有冗余。
- en: Set Up Your Lab
  id: totrans-1021
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE331]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Independent vectors example
  id: totrans-1024
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**独立向量示例**'
- en: '[PRE332]'
  id: totrans-1025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '*[PRE333]*  *Rank = 3, number of vectors = 3 → all independent.'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE333]*  *秩 = 3，向量数量 = 3 → 所有向量都是独立的。'
- en: Dependent vectors example
  id: totrans-1027
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相关向量示例
- en: '[PRE334]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '*[PRE335]*  *Rank = 1, number of vectors = 3 → they’re dependent (multiples
    of each other).'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE335]*  *秩 = 1，向量数量 = 3 → 它们是相关的（彼此的倍数）。'
- en: Checking dependence automatically
  id: totrans-1030
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动检查依赖性
- en: 'A quick test: if rank < number of vectors → dependent.'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 快速测试：如果秩 < 向量数量 → 相关。
- en: '[PRE336]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '*[PRE337]*  *4.  Solving for dependence relation'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE337]*  *4.  求解依赖关系'
- en: If vectors are dependent, we can find coefficients \(c_1, c_2, …\) such that
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向量是相关的，我们可以找到系数 \(c_1, c_2, …\) 使得
- en: \[ c_1 v_1 + c_2 v_2 + … + c_k v_k = 0 \]
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: \[ c_1 v_1 + c_2 v_2 + … + c_k v_k = 0 \]
- en: with some \(c_i \neq 0\).
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些 \(c_i \neq 0\)。
- en: '[PRE338]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '*[PRE339]*  *This shows the exact linear relation.'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE339]*  *这显示了确切的线性关系。'
- en: Random example
  id: totrans-1039
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机示例
- en: '[PRE340]'
  id: totrans-1040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '*[PRE341]*  *Depending on the rank, the columns may be independent (rank =
    3) or dependent (rank < 3).*****  ***#### Try It Yourself'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE341]*  *根据秩，列可能是独立的（秩 = 3）或相关的（秩 < 3）。*****  ***#### 尝试自己操作'
- en: Test if \([1,1,0], [0,1,1], [1,2,1]\) are independent.
  id: totrans-1042
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试 \([1,1,0], [0,1,1], [1,2,1]\) 是否独立。
- en: Generate 4 random vectors in \(\mathbb{R}^3\). Can they ever be independent?
    Why or why not?
  id: totrans-1043
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 \(\mathbb{R}^3\) 中生成 4 个随机向量。它们是否可以总是独立？为什么或为什么不？
- en: Find the dependence relation for \([2,4], [3,6]\).
  id: totrans-1044
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到 \([2,4], [3,6]\) 的依赖关系。
- en: The Takeaway
  id: totrans-1045
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**总结**'
- en: 'Independent set: no redundancy, each vector adds a new direction.'
  id: totrans-1046
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立集：没有冗余，每个向量增加一个新方向。
- en: 'Dependent set: at least one vector is unnecessary (it lies in the span of others).'
  id: totrans-1047
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关集：至少有一个向量是不必要的（它位于其他向量的范围内）。
- en: Independence is the key to defining basis and dimension.****  ***### 35\. Basis
    and Coordinates (Naming Every Vector Uniquely)
  id: totrans-1048
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立性是定义基和维度的关键。****  ***### 35. 基和坐标（唯一命名每个向量）
- en: 'A basis is a set of independent vectors that span a space. It’s like choosing
    a coordinate system: every vector in the space can be expressed uniquely as a
    combination of basis vectors. In this lab, we’ll see how to find bases and compute
    coordinates relative to them.'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 基是一个生成空间的独立向量集。它就像选择一个坐标系：空间中的每个向量都可以唯一地表示为基向量的组合。在这个实验室中，我们将看到如何找到基并计算相对于它们的坐标。
- en: Set Up Your Lab
  id: totrans-1050
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE342]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Standard basis in \(\mathbb{R}^3\)
  id: totrans-1053
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: \(\mathbb{R}^3\) 中的标准基
- en: '[PRE343]'
  id: totrans-1054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '*[PRE344]*  *These three independent vectors form the standard basis of \(\mathbb{R}^3\).
    Any vector like \([2,5,-1]\) can be expressed as'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE344]*  *这三个独立向量构成了 \(\mathbb{R}^3\) 的标准基。任何像 \([2,5,-1]\) 这样的向量都可以表示为'
- en: \[ 2e_1 + 5e_2 - 1e_3 \]
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: \[ 2e_1 + 5e_2 - 1e_3 \]
- en: Finding a basis from dependent vectors
  id: totrans-1057
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从相关向量中找到基
- en: '[PRE345]'
  id: totrans-1058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '*[PRE346]*  *SymPy extracts independent columns automatically. This gives a
    basis for the column space.'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE346]*  *SymPy 自动提取独立列。这给出了列空间的基。'
- en: Coordinates relative to a basis
  id: totrans-1060
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基础相关的坐标
- en: Suppose basis = \(\{ [1,0], [1,1] \}\). Express vector \([3,5]\) in this basis.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 假设基 = \(\{ [1,0], [1,1] \}\)。用这个基表示向量 \([3,5]\)。
- en: '[PRE347]'
  id: totrans-1062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '*[PRE348]*  *So \([3,5] = 3·[1,0] + 2·[1,1]\).'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE348]*  *所以 \([3,5] = 3·[1,0] + 2·[1,1]\)。'
- en: Basis change
  id: totrans-1064
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基变换
- en: If we switch to a different basis, coordinates change but the vector stays the
    same.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们切换到不同的基，坐标会改变，但向量本身保持不变。
- en: '[PRE349]'
  id: totrans-1066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '*[PRE350]*  *5.  Random example'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE350]*  *5.  随机示例'
- en: Generate 3 random vectors in \(\mathbb{R}^3\). Check if they form a basis.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 在 \(\mathbb{R}^3\) 中生成 3 个随机向量。检查它们是否形成一个基。
- en: '[PRE351]'
  id: totrans-1069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '*[PRE352]*  *If rank = 3 → basis for \(\mathbb{R}^3\). Otherwise, only span
    a subspace.*****  ***#### Try It Yourself'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE352]*  *如果秩 = 3 → \(\mathbb{R}^3\) 的基。否则，只能生成子空间。*****  ***#### 试试看'
- en: Check if \([1,2], [3,4]\) form a basis of \(\mathbb{R}^2\).
  id: totrans-1071
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 \([1,2], [3,4]\) 是否形成 \(\mathbb{R}^2\) 的基。
- en: Express vector \([7,5]\) in that basis.
  id: totrans-1072
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用那个基表示向量 \([7,5]\)。
- en: Create 4 random vectors in \(\mathbb{R}^3\). Find a basis for their span.
  id: totrans-1073
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 \(\mathbb{R}^3\) 中创建 4 个随机向量。找到它们的生成空间的基。
- en: The Takeaway
  id: totrans-1074
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: A basis = minimal set of vectors that span a space.
  id: totrans-1075
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基 = 生成一个空间的向量的最小集合。
- en: Every vector has a unique coordinate representation in a given basis.
  id: totrans-1076
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个向量在给定基中都有一个唯一的坐标表示。
- en: Changing bases changes the coordinates, not the vector itself.****  ***### 36\.
    Dimension (How Many Directions)
  id: totrans-1077
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变基会改变坐标，但不会改变向量本身。****  ***### 36. 维度（有多少方向）
- en: The dimension of a vector space is the number of independent directions it has.
    Formally, it’s the number of vectors in any basis of the space. Dimension tells
    us the “size” of a space in terms of degrees of freedom.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 向量空间的维度是其拥有的独立方向的数目。形式上，它是空间中任何基中向量的数目。维度告诉我们空间在自由度方面的“大小”。
- en: Set Up Your Lab
  id: totrans-1079
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE353]'
  id: totrans-1080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Dimension of \(\mathbb{R}^n\)
  id: totrans-1082
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: \(\mathbb{R}^n\) 的维度
- en: The dimension of \(\mathbb{R}^n\) is \(n\).
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: \(\mathbb{R}^n\) 的维度是 \(n\)。
- en: '[PRE354]'
  id: totrans-1084
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '*[PRE355]*  *Each standard unit vector adds one independent direction → dimension
    = 4.'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE355]*  *每个标准单位向量增加一个独立方向 → 维度 = 4。'
- en: Dimension via rank
  id: totrans-1086
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过秩确定维度
- en: The rank of a matrix equals the dimension of its column space.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的秩等于其列空间的维度。
- en: '[PRE356]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '*[PRE357]*  *Here, rank = 2 → the column space is a 2D plane inside \(\mathbb{R}^3\).'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE357]*  *在这里，秩 = 2 → 列空间是 \(\mathbb{R}^3\) 内的 2D 平面。'
- en: Null space dimension
  id: totrans-1090
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 零空间维度
- en: 'The null space dimension is given by:'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 零空间维度由以下给出：
- en: \[ \text{dim(Null(A))} = \#\text{variables} - \text{rank(A)} \]
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \text{dim(Null(A))} = \text{变量数} - \text{rank(A)} \]
- en: '[PRE358]'
  id: totrans-1093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '*[PRE359]*  *This is the number of free variables in a solution.'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE359]*  *这是解中的自由变量数。'
- en: Dimension in practice
  id: totrans-1095
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际应用中的维度
- en: A line through the origin in \(\mathbb{R}^3\) has dimension 1.
  id: totrans-1096
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(\mathbb{R}^3\) 中通过原点的直线维度为 1。
- en: A plane through the origin has dimension 2.
  id: totrans-1097
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过原点的平面维度为 2。
- en: The whole \(\mathbb{R}^3\) has dimension 3.
  id: totrans-1098
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个 \(\mathbb{R}^3\) 的维度是 3。
- en: 'Example:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE360]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '*[PRE361]*  *Result = 1 → they only generate a line.'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE361]*  *结果 = 1 → 它们只能生成一条线。'
- en: Random example
  id: totrans-1102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机示例
- en: '[PRE362]'
  id: totrans-1103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '*[PRE363]*  *Rank may be 4 (full space) or smaller (collapsed).*****  ***####
    Try It Yourself'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE363]*  *秩可能是 4（满空间）或更小（折叠）。*****  ***#### 试试看'
- en: Find the dimension of the column space of
  id: totrans-1105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 求下列列空间的维度
- en: \[ \begin{bmatrix} 1 & 1 & 1 \\ 0 & 1 & 1 \\ 0 & 0 & 0 \end{bmatrix} \]
  id: totrans-1106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ \begin{bmatrix} 1 & 1 & 1 \\ 0 & 1 & 1 \\ 0 & 0 & 0 \end{bmatrix} \]
- en: Compute the dimension of the null space of a 3×3 singular matrix.
  id: totrans-1107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算一个 3×3 奇异矩阵的零空间维度。
- en: Generate a 5×3 random matrix and compute its column space dimension.
  id: totrans-1108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个 5×3 的随机矩阵并计算其列空间维度。
- en: The Takeaway
  id: totrans-1109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Dimension = number of independent directions.
  id: totrans-1110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维度 = 独立方向的数目。
- en: Found by counting basis vectors (or rank).
  id: totrans-1111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过计算基向量（或秩）得出。
- en: Dimensions describe lines (1D), planes (2D), and higher subspaces inside larger
    spaces.****  ***### 37\. Rank–Nullity Theorem (Dimensions That Add Up)
  id: totrans-1112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维度描述了较大空间内的线（1D）、平面（2D）和更高维度的子空间。****  ***### 37. 秩-零度定理（维度之和）
- en: 'The rank–nullity theorem ties together the dimension of the column space and
    the null space of a matrix. It says:'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 秩-零度定理将矩阵的列空间和零空间的维度联系起来。它说：
- en: \[ \text{rank}(A) + \text{nullity}(A) = \text{number of columns of } A \]
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \text{rank}(A) + \text{nullity}(A) = \text{A 的列数} \]
- en: This is a powerful consistency check in linear algebra.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是线性代数中的一个强大的一致性检查。
- en: Set Up Your Lab
  id: totrans-1116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE364]'
  id: totrans-1117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Simple 3×3 example
  id: totrans-1119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简单的 3×3 示例
- en: '[PRE365]'
  id: totrans-1120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '*[PRE366]*  *You should see that rank + nullity = 3, the number of columns.'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE366]*  *你应该看到秩 + 零度 = 3，即列数。'
- en: Full-rank case
  id: totrans-1122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 满秩情况
- en: '[PRE367]'
  id: totrans-1123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '*[PRE368]*  **   Rank = 3 (all independent).'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE368]*  **   秩 = 3（全部独立）。'
- en: Nullity = 0 (only zero solution to \(Bx=0\)).
  id: totrans-1125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零度 = 0（\(Bx=0\) 只有零解）。
- en: Rank + Nullity = 3 columns.
  id: totrans-1126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秩 + 零度 = 3 列。
- en: Wide matrix (more columns than rows)
  id: totrans-1127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 宽矩阵（列数多于行数）
- en: '[PRE369]'
  id: totrans-1128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '*[PRE370]*  *Here, nullity > 0 because there are more variables than independent
    equations.'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE370]*  *在这里，零度 > 0，因为变量多于独立方程。'
- en: Verifying with random matrices
  id: totrans-1130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用随机矩阵验证
- en: '[PRE371]'
  id: totrans-1131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '*[PRE372]*  *Always consistent: rank + nullity = number of columns.'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE372]*  *始终一致：秩 + 零度 = 列数。'
- en: Geometric interpretation
  id: totrans-1133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几何解释
- en: 'For an \(m \times n\) matrix:'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个 \(m \times n\) 矩阵：
- en: Rank(A) = dimension of outputs (column space).
  id: totrans-1135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rank(A) = 输出维度（列空间）。
- en: Nullity(A) = dimension of hidden directions that collapse to 0.
  id: totrans-1136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nullity(A) = 垮度为0的隐藏方向的维度。
- en: Together, they use up all the “input dimensions” (n).****  ***#### Try It Yourself
  id: totrans-1137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一起，它们用完了所有的“输入维度”（n）。****  ***#### 尝试自己来做
- en: Compute rank and nullity of
  id: totrans-1138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算秩和零度。
- en: \[ \begin{bmatrix} 1 & 1 & 1 \\ 0 & 1 & 1 \end{bmatrix} \]
  id: totrans-1139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ \begin{bmatrix} 1 & 1 & 1 \\ 0 & 1 & 1 \end{bmatrix} \]
- en: Check the theorem.
  id: totrans-1140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查定理。
- en: Create a 2×4 random integer matrix. Confirm that rank + nullity = 4.
  id: totrans-1141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 2×4 的随机整数矩阵。确认秩 + 零度 = 4。
- en: Explain why a tall full-rank \(5 \times 3\) matrix must have nullity = 0.
  id: totrans-1142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释为什么一个高满秩的 \(5 \times 3\) 矩阵必须有零度 = 0。
- en: The Takeaway
  id: totrans-1143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 要点总结
- en: Rank + Nullity = number of columns (always true).
  id: totrans-1144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秩 + 零度 = 列数（始终如此）。
- en: Rank measures independent outputs; nullity measures hidden freedom.
  id: totrans-1145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序度量独立输出；零度度量隐藏的自由度。
- en: This theorem connects solutions of \(Ax=0\) with the structure of \(A\).****  ***###
    38\. Coordinates Relative to a Basis (Changing the “Ruler”)
  id: totrans-1146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个定理将 \(Ax=0\) 的解与 \(A\) 的结构联系起来。****  ***### 38. 基的坐标（改变“尺子”）
- en: Once we choose a basis, every vector can be described with coordinates relative
    to that basis. This is like changing the “ruler” we use to measure vectors. In
    this lab, we’ll practice computing coordinates in different bases.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择了一个基，每个向量都可以用相对于该基的坐标来描述。这就像改变我们用来测量向量的“尺子”。在这个实验室中，我们将练习在不同基中计算坐标。
- en: Set Up Your Lab
  id: totrans-1148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE373]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Standard basis coordinates
  id: totrans-1151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标准基坐标
- en: 'Vector \(v = [4,5]\) in \(\mathbb{R}^2\):'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 向量 \(v = [4,5]\) 在 \(\mathbb{R}^2\) 中：
- en: '[PRE374]'
  id: totrans-1153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '*[PRE375]*  *Result is just \([4,5]\). Easy - the standard basis matches the
    components directly.'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE375]*  *结果是 \([4,5]\)。很简单 - 标准基直接匹配分量。'
- en: Non-standard basis
  id: totrans-1155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非标准基
- en: Suppose basis = \(\{ [1,1], [1,-1] \}\). Express \(v = [4,5]\) in this basis.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 假设基 = \(\{ [1,1], [1,-1] \}\)。用这个基表示 \(v = [4,5]\)。
- en: '[PRE376]'
  id: totrans-1157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '*[PRE377]*  *Now \(v\) has different coordinates.'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE377]*  *现在 \(v\) 有不同的坐标。'
- en: Changing coordinates back
  id: totrans-1159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将坐标转换回
- en: 'To reconstruct the vector from coordinates:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 从坐标重建向量：
- en: '[PRE378]'
  id: totrans-1161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '*[PRE379]*  *It matches the original \([4,5]\).'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE379]*  *它与原始的 \([4,5]\) 匹配。'
- en: Random basis in \(\mathbb{R}^3\)
  id: totrans-1163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: \(\mathbb{R}^3\) 中的随机基
- en: '[PRE380]'
  id: totrans-1164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '*[PRE381]*  *Any independent set of 3 vectors in \(\mathbb{R}^3\) works as
    a basis.'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE381]*  *任何 \(\mathbb{R}^3\) 中的3个独立向量集都可以作为基。'
- en: Visualization in 2D
  id: totrans-1166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2D 可视化
- en: Let’s compare coordinates in two bases.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较两个基中的坐标。
- en: '[PRE382]'
  id: totrans-1168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '*![](../Images/94e45721d91cdb2553ab97d801176784.png)*  *Even though the basis
    vectors look different, they span the same space, and \(v\) can be expressed in
    terms of them.*****  ***#### Try It Yourself'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/94e45721d91cdb2553ab97d801176784.png)*  *尽管基向量看起来不同，但它们覆盖了相同的空间，\(v\)
    可以用它们来表示。*****  ***#### 尝试自己来做'
- en: Express \([7,3]\) in the basis \(\{[2,0], [0,3]\}\).
  id: totrans-1170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 \([7,3]\) 用基 \(\{[2,0], [0,3]\}\) 表示。
- en: Pick three independent random vectors in \(\mathbb{R}^3\). Write down the coordinates
    of \([1,2,3]\) in that basis.
  id: totrans-1171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 \(\mathbb{R}^3\) 中选择三个独立的随机向量。写下在该基中 \([1,2,3]\) 的坐标。
- en: Verify that reconstructing always gives the original vector.
  id: totrans-1172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证重建总是给出原始向量。
- en: The Takeaway
  id: totrans-1173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 要点总结
- en: A basis provides a coordinate system for vectors.
  id: totrans-1174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基为向量提供了一个坐标系。
- en: Coordinates depend on the basis, but the underlying vector doesn’t change.
  id: totrans-1175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坐标取决于基，但底层的向量不会改变。
- en: Changing the basis is like changing the “ruler” you measure vectors with.****  ***###
    39\. Change-of-Basis Matrices (Moving Between Coordinate Systems)
  id: totrans-1176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变基就像改变你用来测量向量的“尺子”。****  ***### 39. 基变换矩阵（在坐标系之间移动）
- en: 'When we switch from one basis to another, we need a change-of-basis matrix.
    This matrix acts like a translator: it converts coordinates in one system to coordinates
    in another.'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从一种基转换到另一种基时，我们需要一个基变换矩阵。这个矩阵就像一个翻译者：它将一个系统的坐标转换成另一个系统的坐标。
- en: Set Up Your Lab
  id: totrans-1178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE383]'
  id: totrans-1179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Two bases in \(\mathbb{R}^2\)
  id: totrans-1181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: \(\mathbb{R}^2\) 中的两个基
- en: 'Let’s define:'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义：
- en: Basis \(B = \{ [1,0], [0,1] \}\) (standard basis).
  id: totrans-1183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基 \(B = \{ [1,0], [0,1] \}\)（标准基）。
- en: Basis \(C = \{ [1,1], [1,-1] \}\).
  id: totrans-1184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基 \(C = \{ [1,1], [1,-1] \}\)。
- en: '[PRE384]'
  id: totrans-1185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '*2.  Change-of-basis matrix'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: '*2.  基变换矩阵'
- en: The matrix that converts C-coordinates → standard coordinates is just \(C\).
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 将 C 坐标转换为标准坐标的矩阵就是 \(C\)。
- en: '[PRE385]'
  id: totrans-1188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '*[PRE386]*  *To go the other way (standard → C), we compute the inverse of
    \(C\).'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE386]*  *要反向操作（标准 → C），我们计算 \(C\) 的逆。'
- en: '[PRE387]'
  id: totrans-1190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '*[PRE388]*  *3.  Converting coordinates'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE388]*  *3.  转换坐标'
- en: Vector \(v = [4,5]\).
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 向量 \(v = [4,5]\)。
- en: 'In standard basis:'
  id: totrans-1193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标准基下：
- en: '[PRE389]'
  id: totrans-1194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '*[PRE390]*  **   In basis \(C\):'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE390]*  **   在基 \(C\) 中：'
- en: '[PRE391]'
  id: totrans-1196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '*[PRE392]*  **   Convert back:'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE392]*  **   转换回：'
- en: '[PRE393]'
  id: totrans-1198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '*[PRE394]*  *The reconstruction matches the original vector.'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE394]*  *重建与原始向量匹配。'
- en: General formula
  id: totrans-1200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一般公式
- en: 'If \(P\) is the change-of-basis matrix from basis \(B\) to basis \(C\):'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 \(P\) 是从基 \(B\) 到基 \(C\) 的基变换矩阵：
- en: \[ [v]_C = P^{-1}[v]_B \]
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: \[ [v]_C = P^{-1}[v]_B \]
- en: \[ [v]_B = P[v]_C \]
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: \[ [v]_B = P[v]_C \]
- en: Here, \(P\) is the matrix of new basis vectors written in terms of the old basis.
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，\(P\) 是用旧基表示的新基向量的矩阵。
- en: Random 3D example
  id: totrans-1205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机 3D 示例
- en: '[PRE395]'
  id: totrans-1206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '*[PRE396]*******  ***#### Try It Yourself'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE396]*******  ***#### 尝试自己操作'
- en: Convert \([7,3]\) from the standard basis to the basis \(\{[2,0], [0,3]\}\).
  id: totrans-1208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 \([7,3]\) 从标准基转换为基 \(\{[2,0], [0,3]\}\)。
- en: Pick a random invertible 3×3 matrix as a basis. Write a vector in that basis,
    then convert it back to the standard basis.
  id: totrans-1209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机选择一个可逆的 3×3 矩阵作为基。在一个基下写一个向量，然后将其转换回标准基。
- en: Prove that converting back and forth always returns the same vector.
  id: totrans-1210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明来回转换总是返回相同的向量。
- en: The Takeaway
  id: totrans-1211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 总结
- en: A change-of-basis matrix converts coordinates between bases.
  id: totrans-1212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基变换矩阵在基之间转换坐标。
- en: Going from new basis → old basis uses the basis matrix.
  id: totrans-1213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从新基到旧基的转换使用基矩阵。
- en: Going from old basis → new basis requires its inverse.
  id: totrans-1214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从旧基到新基需要其逆矩阵。
- en: The vector itself never changes - only the description of it does.****  ***###
    40\. Affine Subspaces (Lines and Planes Not Through the Origin)
  id: totrans-1215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量本身从未改变——只有对它的描述改变了。****  ***### 40\. 仿射子空间（不通过原点的线和平面）
- en: So far, subspaces always passed through the origin. But many familiar objects
    - like lines offset from the origin or planes floating in space - are affine subspaces.
    They look like subspaces, just shifted away from zero.
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，子空间总是通过原点。但许多熟悉的对象——比如偏离原点的线或漂浮在空间中的平面——都是仿射子空间。它们看起来像子空间，只是从零点偏移了。
- en: Set Up Your Lab
  id: totrans-1217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE397]'
  id: totrans-1218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Line through the origin (a subspace)
  id: totrans-1220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过原点的线（一个子空间）
- en: '\[ L = \{ t \cdot [1,2] : t \in \mathbb{R} \} \]'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: '\[ L = \{ t \cdot [1,2] : t \in \mathbb{R} \} \]'
- en: '[PRE398]'
  id: totrans-1222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '*![](../Images/820aa9812ef15d19d89f6dd35fb5c244.png)*  *2.  Line not through
    the origin (affine subspace)'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/820aa9812ef15d19d89f6dd35fb5c244.png)*  *2.  不通过原点的线（仿射子空间）'
- en: '\[ L'' = \{ [3,1] + t \cdot [1,2] : t \in \mathbb{R} \} \]'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: '\[ L'' = \{ [3,1] + t \cdot [1,2] : t \in \mathbb{R} \} \]'
- en: '[PRE399]'
  id: totrans-1225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '*![](../Images/a389be3ce91bf8359bc03aa4241d3597.png)*  *3.  Visualizing together'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/a389be3ce91bf8359bc03aa4241d3597.png)*  *3.  视觉化展示'
- en: '[PRE400]'
  id: totrans-1227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '*![](../Images/4ebc677422d3e91ca65dce027558c6c4.png)*  *One line passes through
    the origin, the other is parallel but shifted.'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/4ebc677422d3e91ca65dce027558c6c4.png)*  *一条线通过原点，另一条线与之平行但偏移。'
- en: Plane example
  id: totrans-1229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 平面示例
- en: 'A plane in \(\mathbb{R}^3\):'
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: \(\mathbb{R}^3\) 中的一个平面：
- en: '\[ P = \{ [1,2,3] + s[1,0,0] + t[0,1,0] : s,t \in \mathbb{R} \} \]'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: '\[ P = \{ [1,2,3] + s[1,0,0] + t[0,1,0] : s,t \in \mathbb{R} \} \]'
- en: This is an affine plane parallel to the \(xy\)-plane, but shifted.
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个平行于 \(xy\) 平面的仿射平面，但偏移了。
- en: '[PRE401]'
  id: totrans-1233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '*![](../Images/0d8f2fc986385977d5126403c4947c3c.png)*  *5.  Algebraic difference'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/0d8f2fc986385977d5126403c4947c3c.png)*  *5.  代数差异'
- en: A subspace must satisfy closure under addition and scalar multiplication, and
    must include 0.
  id: totrans-1235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子空间必须满足加法和数乘的封闭性，并且必须包含 0。
- en: An affine subspace is just a subspace plus a fixed shift vector.****  ***####
    Try It Yourself
  id: totrans-1236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仿射子空间就是一个子空间加上一个固定的平移向量。****  ***#### 尝试自己操作
- en: 'Define a line in \(\mathbb{R}^2\):'
  id: totrans-1237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 \(\mathbb{R}^2\) 中定义一条线：
- en: \[ (x,y) = (2,3) + t(1,-1) \]
  id: totrans-1238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ (x,y) = (2,3) + t(1,-1) \]
- en: Plot it and compare with the subspace spanned by \((1,-1)\).
  id: totrans-1239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 绘制它并与由 \((1,-1)\) 张成的子空间进行比较。
- en: Construct an affine plane in \(\mathbb{R}^3\) shifted by vector \((5,5,5)\).
  id: totrans-1240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 \(\mathbb{R}^3\) 中构建一个由向量 \((5,5,5)\) 平移的仿射平面。
- en: Show algebraically that subtracting the shift point turns an affine subspace
    back into a regular subspace.
  id: totrans-1241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过代数证明，减去偏移点将仿射子空间转换回常规子空间。
- en: The Takeaway
  id: totrans-1242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 总结
- en: Subspaces go through the origin.
  id: totrans-1243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子空间通过原点。
- en: Affine subspaces are shifted copies of subspaces.
  id: totrans-1244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仿射子空间是子空间的平移副本。
- en: They’re essential in geometry, computer graphics, and optimization (e.g., feasible
    regions in linear programming).*******************************  ***## Chapter
    5\. Linear Transformation and Structure
  id: totrans-1245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在几何学、计算机图形学和优化（例如，线性规划中的可行区域）中至关重要。*******************************  ***##
    第 5 章\. 线性变换与结构
- en: 41\. Linear Transformations (Preserving Lines and Sums)
  id: totrans-1246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 41. 线性变换（保持直线和和）
- en: 'A linear transformation is a function between vector spaces that preserves
    two key properties:'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 线性变换是向量空间之间的函数，它保持两个关键属性：
- en: 'Additivity: \(T(u+v) = T(u) + T(v)\)'
  id: totrans-1248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可加性：\(T(u+v) = T(u) + T(v)\)
- en: 'Homogeneity: \(T(cu) = cT(u)\)'
  id: totrans-1249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同质性：\(T(cu) = cT(u)\)
- en: In practice, every linear transformation can be represented by a matrix. This
    lab will help you understand and experiment with linear transformations in Python.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，每个线性变换都可以用矩阵表示。本实验将帮助你理解和在 Python 中实验线性变换。
- en: Set Up Your Lab
  id: totrans-1251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置你的实验室
- en: '[PRE402]'
  id: totrans-1252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Simple linear transformation (scaling)
  id: totrans-1254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简单的线性变换（缩放）
- en: Let’s scale vectors by 2 in the x-direction and by 0.5 in the y-direction.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 x 方向上将向量缩放 2 倍，在 y 方向上缩放 0.5 倍。
- en: '[PRE403]'
  id: totrans-1256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '*[PRE404]*  *2.  Visualizing multiple vectors'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE404]*  *2.  可视化多个向量'
- en: '[PRE405]'
  id: totrans-1258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '*![](../Images/b858df9d6265391c08ceee623c4fdf19.png)*  *Blue arrows are the
    original vectors; red arrows are the transformed ones. Notice how the transformation
    stretches and compresses consistently.'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/b858df9d6265391c08ceee623c4fdf19.png)*  *蓝色箭头是原始向量；红色箭头是变换后的向量。注意变换如何一致地拉伸和压缩。'
- en: Rotation as a linear transformation
  id: totrans-1260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旋转作为线性变换
- en: 'Rotating vectors by \(\theta = 90^\circ\):'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 将向量旋转 \(\theta = 90^\circ\)：
- en: '[PRE406]'
  id: totrans-1262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '*[PRE407]*  *The result is \([0,1]\), a perfect rotation.'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE407]*  *结果是 \([0,1]\)，一个完美的旋转。'
- en: Checking linearity
  id: totrans-1264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查线性性
- en: '[PRE408]'
  id: totrans-1265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '*[PRE409]*  *Both checks return `True`, proving \(T\) is linear.'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE409]*  *两次检查都返回 `True`，证明 \(T\) 是线性的。'
- en: Non-linear example (for contrast)
  id: totrans-1267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非线性示例（用于对比）
- en: A transformation like \(T(x,y) = (x^2, y)\) is not linear.
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 \(T(x,y) = (x^2, y)\) 的变换不是线性的。
- en: '[PRE410]'
  id: totrans-1269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '*[PRE411]*  *This fails the additivity test, so it’s not linear.*****  ***####
    Try It Yourself'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE411]*  *这未通过加法测试，所以它不是线性的。*****  ***#### 尝试自己来做'
- en: Define a shear matrix
  id: totrans-1271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个剪切矩阵
- en: \[ S = \begin{bmatrix} 1 & 1 \\ 0 & 1 \end{bmatrix} \]
  id: totrans-1272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ S = \begin{bmatrix} 1 & 1 \\ 0 & 1 \end{bmatrix} \]
- en: Apply it to vectors and plot before/after.
  id: totrans-1273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用到向量上并绘制前后对比。
- en: Verify linearity for rotation by 45°.
  id: totrans-1274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证旋转 45° 的线性性。
- en: Test whether \(T(x,y) = (x+y, y)\) is linear.
  id: totrans-1275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试 \(T(x,y) = (x+y, y)\) 是否是线性的。
- en: The Takeaway
  id: totrans-1276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸取的经验
- en: A linear transformation preserves vector addition and scalar multiplication.
  id: totrans-1277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性变换保持向量加法和数乘。
- en: Every linear transformation can be represented by a matrix.
  id: totrans-1278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个线性变换都可以用矩阵表示。
- en: 'Visualizing with arrows helps build geometric intuition: stretching, rotating,
    and shearing are all linear.****  ***### 42\. Matrix Representation of a Linear
    Map (Choosing a Basis)'
  id: totrans-1279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用箭头可视化有助于建立几何直觉：拉伸、旋转和剪切都是线性的。****  ***### 42\. 线性映射的矩阵表示（选择基）
- en: Every linear transformation can be written as a matrix, but the exact matrix
    depends on the basis you choose. This lab shows how to build and interpret matrix
    representations.
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线性变换都可以写成矩阵的形式，但确切的矩阵取决于你选择的基。本实验展示了如何构建和解释矩阵表示。
- en: Set Up Your Lab
  id: totrans-1281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置你的实验室
- en: '[PRE412]'
  id: totrans-1282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: From transformation to matrix
  id: totrans-1284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从变换到矩阵
- en: 'Suppose \(T: \mathbb{R}^2 \to \mathbb{R}^2\) is defined by:'
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: '假设 \(T: \mathbb{R}^2 \to \mathbb{R}^2\) 由以下定义：'
- en: \[ T(x,y) = (2x + y, \; x - y) \]
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: \[ T(x,y) = (2x + y, \; x - y) \]
- en: 'To find its matrix in the standard basis, apply \(T\) to each basis vector:'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到其在标准基下的矩阵，将 \(T\) 应用到每个基向量上：
- en: '[PRE413]'
  id: totrans-1288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '*[PRE414]*  *Stacking results as columns gives the matrix:'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE414]*  *将结果作为列堆叠给出矩阵：'
- en: '[PRE415]'
  id: totrans-1290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '*[PRE416]*  *2.  Using the matrix for computations'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE416]*  *2.  使用矩阵进行计算'
- en: '[PRE417]'
  id: totrans-1292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '*[PRE418]*  *Both methods match.'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE418]*  *两种方法都匹配。'
- en: Matrix in a different basis
  id: totrans-1294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不同基下的矩阵
- en: Now suppose we use basis
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们使用基
- en: \[ B = \{ [1,1], [1,-1] \} \]
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: \[ B = \{ [1,1], [1,-1] \} \]
- en: 'To represent \(T\) in this basis:'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 要用这个基表示 \(T\)：
- en: Build the change-of-basis matrix \(P\).
  id: totrans-1298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建基变换矩阵 \(P\)。
- en: Compute \(A_B = P^{-1}AP\).
  id: totrans-1299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 \(A_B = P^{-1}AP\)。
- en: '[PRE419]'
  id: totrans-1300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '*[PRE420]*  *4.  Interpretation'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE420]*  *4.  解释'
- en: In standard basis, \(A\) tells us how \(T\) acts on unit vectors.
  id: totrans-1302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标准基下，\(A\) 告诉我们 \(T\) 如何作用于单位向量。
- en: In basis \(B\), \(A_B\) shows how \(T\) looks when described using different
    coordinates.
  id: totrans-1303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基 \(B\) 中，\(A_B\) 显示了当使用不同坐标描述 \(T\) 时 \(T\) 的样子。
- en: Random linear map in \(\mathbb{R}^3\)
  id: totrans-1304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: \(\mathbb{R}^3\) 中的随机线性映射
- en: '[PRE421]'
  id: totrans-1305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '*[PRE422]*****  ***#### Try It Yourself'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE422]*****  ***#### 尝试自己来做'
- en: Define \(T(x,y) = (x+2y, 3x+y)\). Find its matrix in the standard basis.
  id: totrans-1307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 \(T(x,y) = (x+2y, 3x+y)\)。找到其在标准基下的矩阵。
- en: Use a new basis \(\{[2,0],[0,3]\}\). Compute the representation \(A_B\).
  id: totrans-1308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的基 \(\{[2,0],[0,3]\}\)。计算 \(A_B\) 的表示。
- en: Verify that applying \(T\) directly to a vector matches computing via \(A_B\)
    and change-of-basis.
  id: totrans-1309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证将 \(T\) 直接应用于一个向量与通过 \(A_B\) 和基变换计算相匹配。
- en: The Takeaway
  id: totrans-1310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: A linear transformation becomes a matrix representation once a basis is chosen.
  id: totrans-1311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个基后，线性变换就变成了矩阵表示。
- en: Columns of the matrix = images of basis vectors.
  id: totrans-1312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵的列 = 基础向量的像。
- en: Changing the basis changes the matrix, but the transformation itself stays the
    same.****  ***### 43\. Kernel and Image (Inputs That Vanish; Outputs We Can Reach)
  id: totrans-1313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变基会改变矩阵，但变换本身保持不变。****  ***### 43. 核和像（消失的输入；我们可以达到的输出）
- en: 'Two fundamental subspaces describe any linear transformation \(T(x) = Ax\):'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 任何线性变换 \(T(x) = Ax\) 都可以用两个基本子空间来描述：
- en: 'Kernel (null space): all vectors \(x\) such that \(Ax = 0\).'
  id: totrans-1315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核（零空间）：所有满足 \(Ax = 0\) 的向量 \(x\)。
- en: 'Image (column space): all possible outputs \(Ax\).'
  id: totrans-1316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像空间（列空间）：所有可能的输出 \(Ax\)。
- en: The kernel tells us what inputs collapse to zero, while the image tells us what
    outputs are achievable.
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 核告诉我们哪些输入会塌缩为零，而像告诉我们哪些输出是可以实现的。
- en: Set Up Your Lab
  id: totrans-1318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置你的实验室
- en: '[PRE423]'
  id: totrans-1319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码演示'
- en: Kernel of a matrix
  id: totrans-1321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩阵的核
- en: Consider
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑
- en: \[ A = \begin{bmatrix} 1 & 2 & 3 \\ 2 & 4 & 6 \end{bmatrix} \]
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: \[ A = \begin{bmatrix} 1 & 2 & 3 \\ 2 & 4 & 6 \end{bmatrix} \]
- en: '[PRE424]'
  id: totrans-1324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '*[PRE425]*  *The null space basis shows dependencies among columns. Here, the
    kernel is 2-dimensional because columns are dependent.'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE425]*  *零空间基显示了列之间的依赖关系。在这里，核是二维的，因为列是相关的。'
- en: Image (column space)
  id: totrans-1326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像空间（列空间）
- en: '[PRE426]'
  id: totrans-1327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '*[PRE427]*  *The image is spanned by \([1,2]^T\). So all outputs of \(A\) are
    multiples of this vector.'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE427]*  *像由 \([1,2]^T\) 张成。所以 \(A\) 的所有输出都是这个向量的倍数。'
- en: Interpretation
  id: totrans-1329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释
- en: Kernel vectors → directions that map to zero.
  id: totrans-1330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核向量 → 映射到零的方向。
- en: Image vectors → directions we can actually reach in the output space.
  id: totrans-1331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像向量 → 我们实际上可以在输出空间中达到的方向。
- en: If \(x \in \ker(A)\), then \(Ax = 0\). If \(b\) is not in the image, the system
    \(Ax = b\) has no solution.
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 \(x \in \ker(A)\)，则 \(Ax = 0\)。如果 \(b\) 不在像中，则系统 \(Ax = b\) 没有解。
- en: Example with full rank
  id: totrans-1333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 全秩示例
- en: '[PRE428]'
  id: totrans-1334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '*[PRE429]*  **   Kernel = only zero vector.'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE429]*  **   核 = 只有零向量。'
- en: Image = all of \(\mathbb{R}^3\).
  id: totrans-1336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像空间 = \(\mathbb{R}^3\) 的全部。
- en: NumPy version (image via column space)
  id: totrans-1337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy 版本（通过列空间得到的像）
- en: '[PRE430]'
  id: totrans-1338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '*[PRE431]*  *NumPy doesn’t compute null spaces directly, but we can use SVD
    for that if needed.****  ***#### Try It Yourself'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE431]*  *NumPy 不直接计算零空间，但如果有需要，我们可以使用 SVD 来计算。****  ***#### 尝试自己来做'
- en: Compute kernel and image for
  id: totrans-1340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算以下矩阵的核和像
- en: \[ \begin{bmatrix} 1 & 1 \\ 1 & 1 \end{bmatrix} \]
  id: totrans-1341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ \begin{bmatrix} 1 & 1 \\ 1 & 1 \end{bmatrix} \]
- en: What do they look like?
  id: totrans-1342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它们看起来是什么样子？
- en: Take a random 3×4 matrix and find its kernel and image dimensions.
  id: totrans-1343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机取一个 3×4 矩阵，并找到其核和像的维度。
- en: 'Solve \(Ax = b\) for a matrix \(A\). Try two different \(b\): one inside the
    image, one outside. Observe the difference.'
  id: totrans-1344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解 \(Ax = b\) 的矩阵 \(A\)。尝试两个不同的 \(b\)：一个在像内，一个在像外。观察差异。
- en: The Takeaway
  id: totrans-1345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Kernel = inputs that vanish under \(A\).
  id: totrans-1346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核 = 在 \(A\) 下消失的输入。
- en: Image = outputs that can be reached by \(A\).
  id: totrans-1347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像空间 = 通过 \(A\) 可以达到的输出。
- en: 'Together, they fully describe what a linear map does: what it “kills” and what
    it “produces.”****  ***### 44\. Invertibility and Isomorphisms (Perfectly Reversible
    Maps)'
  id: totrans-1348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一起，它们完全描述了一个线性映射所做的工作：它“杀死”了什么，以及它“产生”了什么。****  ***### 44. 可逆性和同构（完美可逆映射）
- en: A matrix (or linear map) is invertible if it has an inverse \(A^{-1}\) such
    that
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个矩阵（或线性映射）有一个逆 \(A^{-1}\)，那么它是可逆的，使得
- en: \[ A^{-1}A = I \quad \text{and} \quad AA^{-1} = I \]
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: \[ A^{-1}A = I \quad \text{和} \quad AA^{-1} = I \]
- en: An invertible map is also called an isomorphism, because it preserves all information
    - every input has exactly one output, and every output comes from exactly one
    input.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 可逆映射也称为同构，因为它保留所有信息 - 每个输入都有一个确切的输出，每个输出都来自一个确切的输入。
- en: Set Up Your Lab
  id: totrans-1352
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置你的实验室
- en: '[PRE432]'
  id: totrans-1353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码演示'
- en: Checking invertibility
  id: totrans-1355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查可逆性
- en: '[PRE433]'
  id: totrans-1356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '*[PRE434]*  *If determinant ≠ 0 → invertible.'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE434]*  *如果行列式 ≠ 0 → 可逆。'
- en: Computing the inverse
  id: totrans-1358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算逆
- en: '[PRE435]'
  id: totrans-1359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '*[PRE436]*  *3.  Solving systems with inverses'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE436]*  *3. 使用逆解系统'
- en: 'For \(Ax = b\), if \(A\) is invertible:'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 \(Ax = b\)，如果 \(A\) 是可逆的：
- en: '[PRE437]'
  id: totrans-1362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '*[PRE438]*  *This is equivalent to `A.solve(b)` in SymPy or `np.linalg.solve`
    in NumPy.'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE438]*  *这相当于 SymPy 中的 `A.solve(b)` 或 NumPy 中的 `np.linalg.solve`。'
- en: Non-invertible (singular) example
  id: totrans-1364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不可逆（奇异的）示例
- en: '[PRE439]'
  id: totrans-1365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '*[PRE440]*  *Determinant = 0 → no inverse. The matrix collapses space onto
    a line, losing information.'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE440]*  *行列式 = 0 → 无逆。矩阵将空间压缩到一条线，丢失信息。'
- en: NumPy version
  id: totrans-1367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy版本
- en: '[PRE441]'
  id: totrans-1368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '*[PRE442]*  *6.  Geometric intuition'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE442]*  *6.  几何直觉'
- en: Invertible transformation = reversible (like rotating, scaling by nonzero).
  id: totrans-1370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可逆变换 = 可逆的（如旋转，非零缩放）。
- en: Non-invertible transformation = squashing space into a lower dimension (like
    flattening a plane onto a line).*****  ***#### Try It Yourself
  id: totrans-1371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可逆变换 = 将空间压缩到较低维度（如将平面压扁到一条线上）。*****  ***#### 尝试自己动手
- en: Test whether
  id: totrans-1372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试是否
- en: \[ \begin{bmatrix} 1 & 0 \\ 0 & 1 \end{bmatrix} \]
  id: totrans-1373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ \begin{bmatrix} 1 & 0 \\ 0 & 1 \end{bmatrix} \]
- en: is invertible and find its inverse.
  id: totrans-1374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是可逆的并找到它的逆。
- en: Compute the determinant of a 3×3 random integer matrix. If it’s nonzero, find
    its inverse.
  id: totrans-1375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算一个3×3随机整数矩阵的行列式。如果它非零，找到它的逆。
- en: Create a singular 3×3 matrix (make one row a multiple of another). Confirm it
    has no inverse.
  id: totrans-1376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个奇异的3×3矩阵（使一行是另一行的倍数）。确认它没有逆。
- en: The Takeaway
  id: totrans-1377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: 'Invertible matrix ↔︎ isomorphism: perfectly reversible, no information lost.'
  id: totrans-1378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可逆矩阵 ↔︎ 同构：完美可逆，没有信息丢失。
- en: Determinant ≠ 0 → invertible; determinant = 0 → singular.
  id: totrans-1379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行列式 ≠ 0 → 可逆；行列式 = 0 → 矩阵奇异。
- en: Inverses are useful conceptually, but in computation we usually solve systems
    directly instead of calculating \(A^{-1}\).****  ***### 45\. Composition, Powers,
    and Iteration (Doing It Again and Again)
  id: totrans-1380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逆矩阵在概念上是有用的，但在计算中我们通常直接求解系统而不是计算 \(A^{-1}\)。****  ***### 45. 合成、幂和迭代（重复做）
- en: Linear transformations can be chained together. Applying one after another is
    called composition, and in matrix form this becomes multiplication. Repeated application
    of the same transformation leads to powers of a matrix.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 线性变换可以串联起来。一个接一个地应用称为合成，在矩阵形式中这成为乘法。相同变换的重复应用导致矩阵的幂。
- en: Set Up Your Lab
  id: totrans-1382
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE443]'
  id: totrans-1383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Composition of transformations
  id: totrans-1385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变换的合成
- en: 'Suppose we have two linear maps:'
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个线性映射：
- en: '\(T_1\): rotate by 90°'
  id: totrans-1387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '\(T_1\): 旋转90°'
- en: '\(T_2\): scale x by 2'
  id: totrans-1388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '\(T_2\): 将x缩放2倍'
- en: '[PRE444]'
  id: totrans-1389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '*[PRE445]*  *Applying the composite matrix is equivalent to applying both maps
    in sequence.'
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE445]*  *应用组合矩阵相当于按顺序应用两个映射。'
- en: Verifying with a vector
  id: totrans-1391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用向量验证
- en: '[PRE446]'
  id: totrans-1392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '*[PRE447]*  *Both results are the same → composition = matrix multiplication.'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE447]*  *两个结果相同 → 合成 = 矩阵乘法。'
- en: Powers of a matrix
  id: totrans-1394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩阵的幂
- en: Repeatedly applying a transformation corresponds to matrix powers.
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 重复应用一个变换对应于矩阵的幂
- en: 'Example: scaling by 2.'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：缩放2倍。
- en: '[PRE448]'
  id: totrans-1397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '*[PRE449]*  *Each step doubles the scaling effect.'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE449]*  *每一步都会加倍缩放效果。'
- en: Iteration dynamics
  id: totrans-1399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代动力学
- en: Let’s iterate a transformation many times and see what happens.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们多次迭代一个变换，看看会发生什么。
- en: 'Example:'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: \[ A = \begin{bmatrix} 0.5 & 0 \\ 0 & 0.5 \end{bmatrix} \]
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: \[ A = \begin{bmatrix} 0.5 & 0 \\ 0 & 0.5 \end{bmatrix} \]
- en: '[PRE450]'
  id: totrans-1403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '*[PRE451]*  *Each step shrinks the vector → iteration can reveal stability.'
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE451]*  *每一步都会缩小向量 → 迭代可以揭示稳定性。'
- en: Random example
  id: totrans-1405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机示例
- en: '[PRE452]'
  id: totrans-1406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '*[PRE453]*****  ***#### Try It Yourself'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE453]*****  ***#### 尝试自己动手'
- en: 'Create two transformations: reflection across x-axis and scaling by 3\. Compose
    them.'
  id: totrans-1408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个变换：沿x轴的反射和缩放3倍。将它们组合。
- en: Take a shear matrix and compute \(A^5\). What happens to a vector after repeated
    application?
  id: totrans-1409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取一个剪切矩阵并计算 \(A^5\)。重复应用后向量会发生什么？
- en: Experiment with a rotation matrix raised to higher powers. What cycle do you
    see?
  id: totrans-1410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试一个旋转矩阵的更高次幂。你看到了什么周期？
- en: The Takeaway
  id: totrans-1411
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Composition of linear maps = matrix multiplication.
  id: totrans-1412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性映射的合成 = 矩阵乘法。
- en: Powers of a matrix represent repeated application.
  id: totrans-1413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵的幂代表重复应用。
- en: 'Iteration reveals long-term dynamics: shrinking, growing, or oscillating behavior.****  ***###
    46\. Similarity and Conjugation (Same Action, Different Basis)'
  id: totrans-1414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代揭示了长期动力学：收缩、增长或振荡行为。****  ***### 46. 相似性和共轭（相同动作，不同基）
- en: Two matrices \(A\) and \(B\) are called similar if there exists an invertible
    matrix \(P\) such that
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在一个可逆矩阵 \(P\) 使得两个矩阵 \(A\) 和 \(B\) 相似，则称它们为相似。
- en: \[ B = P^{-1} A P \]
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: \[ B = P^{-1} A P \]
- en: This means \(A\) and \(B\) represent the same linear transformation, but in
    different bases. This lab explores similarity and why it matters.
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 \(A\) 和 \(B\) 代表相同的线性变换，但在不同的基下。这个实验探讨了相似性及其重要性。
- en: Set Up Your Lab
  id: totrans-1418
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE454]'
  id: totrans-1419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Example with a change of basis
  id: totrans-1421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基变换的示例
- en: '[PRE455]'
  id: totrans-1422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: '*[PRE456]*  *Here, \(A\) and \(B\) are similar: they describe the same transformation
    in different coordinates.'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE456]*  *在这里，\(A\) 和 \(B\) 是相似的：它们在不同的坐标系中描述了相同的变换。'
- en: Eigenvalues stay the same
  id: totrans-1424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特征值保持不变
- en: Similarity preserves eigenvalues.
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 相似性保持特征值。
- en: '[PRE457]'
  id: totrans-1426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: '*[PRE458]*  *Both matrices have the same eigenvalues, even though their entries
    differ.'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE458]*  *尽管它们的条目不同，但两个矩阵具有相同的特征值。'
- en: Similarity and diagonalization
  id: totrans-1428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相似性和对角化
- en: If a matrix is diagonalizable, there exists \(P\) such that
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个矩阵是可对角化的，那么存在 \(P\) 使得
- en: \[ D = P^{-1} A P \]
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: \[ D = P^{-1} A P \]
- en: where \(D\) is diagonal.
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(D\) 是对角矩阵。
- en: '[PRE459]'
  id: totrans-1432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '*[PRE460]*  *Diagonalization is a special case of similarity, where the new
    matrix is as simple as possible.'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE460]*  *对角化是相似性的特殊情况，其中新矩阵尽可能简单。'
- en: NumPy version
  id: totrans-1434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy 版本
- en: '[PRE461]'
  id: totrans-1435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '*[PRE462]*  *Here, eigenvectors form the change-of-basis matrix \(P\).'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE462]*  *在这里，特征向量形成基变换矩阵 \(P\)。'
- en: Geometric interpretation
  id: totrans-1437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几何解释
- en: Similar matrices = same transformation, different “ruler” (basis).
  id: totrans-1438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相似矩阵 = 相同的变换，不同的“尺子”（基）。
- en: Diagonalization = finding a ruler that makes the transformation look like pure
    stretching along axes.****  ***#### Try It Yourself
  id: totrans-1439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对角化 = 找到一个使变换看起来像沿轴纯拉伸的尺子。****  ***#### 尝试自己操作
- en: Take
  id: totrans-1440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 吸收要点
- en: \[ A = \begin{bmatrix} 1 & 1 \\ 0 & 1 \end{bmatrix} \]
  id: totrans-1441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ A = \begin{bmatrix} 1 & 1 \\ 0 & 1 \end{bmatrix} \]
- en: and find a matrix \(P\) that gives a similar \(B\).
  id: totrans-1442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并找到一个矩阵 \(P\)，它给出相似的 \(B\)。
- en: Show that two similar matrices have the same determinant and trace.
  id: totrans-1443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明两个相似矩阵具有相同的行列式和迹。
- en: For a random 3×3 matrix, check if it is diagonalizable using SymPy’s `.diagonalize()`
    method.
  id: totrans-1444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于一个随机的 3×3 矩阵，使用 SymPy 的 `.diagonalize()` 方法检查它是否可对角化。
- en: The Takeaway
  id: totrans-1445
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Similarity = same linear map, different basis.
  id: totrans-1446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相似性 = 相同的线性映射，不同的基。
- en: Similar matrices share eigenvalues, determinant, and trace.
  id: totrans-1447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相似矩阵共享特征值、行列式和迹。
- en: Diagonalization is the simplest similarity form, making repeated computations
    (like powers) much easier.****  ***### 47\. Projections and Reflections (Idempotent
    and Involutive Maps)
  id: totrans-1448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对角化是最简单的相似形式，使得重复计算（如幂运算）变得容易。****  ***### 47\. 投影和反射（幂等和自反映射）
- en: Two very common geometric linear maps are projections and reflections. They
    show up in graphics, physics, and optimization.
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 两种非常常见的几何线性映射是投影和反射。它们出现在图形、物理和优化中。
- en: A projection squashes vectors onto a subspace (like dropping a shadow).
  id: totrans-1450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投影将向量压缩到子空间（就像投下影子）。
- en: A reflection flips vectors across a line or plane (like a mirror).
  id: totrans-1451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射将向量沿线或平面翻转（就像镜子一样）。
- en: Set Up Your Lab
  id: totrans-1452
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE463]'
  id: totrans-1453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码分析'
- en: Projection onto a line
  id: totrans-1455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 投影到一条线上
- en: 'If we want to project onto the line spanned by \(u\), the projection matrix
    is:'
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要投影到由 \(u\) 张成的线上，投影矩阵是：
- en: \[ P = \frac{uu^T}{u^T u} \]
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: \[ P = \frac{uu^T}{u^T u} \]
- en: '[PRE464]'
  id: totrans-1458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '*[PRE465]*  *Apply projection:'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE465]*  *应用投影：'
- en: '[PRE466]'
  id: totrans-1460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '*[PRE467]*  *2.  Visualization of projection'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE467]*  *2.  投影的可视化'
- en: '[PRE468]'
  id: totrans-1462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: '*![](../Images/96d5f7fe73dc68f2b7bc52a6d4043832.png)*  *The projection is the
    closest point on the line to the original vector.'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/96d5f7fe73dc68f2b7bc52a6d4043832.png)*  *投影是原向量到直线上最近的一点。'
- en: Reflection across a line
  id: totrans-1464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 沿线反射
- en: 'The reflection matrix across the line spanned by \(u\) is:'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: 沿由 \(u\) 张成的线的反射矩阵是：
- en: \[ R = 2P - I \]
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: \[ R = 2P - I \]
- en: '[PRE469]'
  id: totrans-1467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '*[PRE470]*  *4.  Checking algebraic properties'
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE470]*  *4.  检查代数属性'
- en: 'Projection: \(P^2 = P\) (idempotent).'
  id: totrans-1469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投影：\(P^2 = P\)（幂等）。
- en: 'Reflection: \(R^2 = I\) (involutive).'
  id: totrans-1470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射：\(R^2 = I\)（自反）。
- en: '[PRE471]'
  id: totrans-1471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '*[PRE472]*  *5.  Projection in higher dimensions'
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE472]*  *5.  高维投影'
- en: Project onto the plane spanned by two vectors in \(\mathbb{R}^3\).
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 投影到由 \(\mathbb{R}^3\) 中的两个向量张成的平面上。
- en: '[PRE473]'
  id: totrans-1474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: '*[PRE474]******  ***#### Try It Yourself'
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE474]******  ***#### 尝试自己操作'
- en: Project \([4,5]\) onto the x-axis and verify the result.
  id: totrans-1476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目 \([4,5]\) 投影到 x 轴并验证结果。
- en: Reflect \([1,2]\) across the line \(y=x\).
  id: totrans-1477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 \([1,2]\) 反射到线 \(y=x\) 上。
- en: Create a random 3D vector and project it onto the plane spanned by \([1,1,0]\)
    and \([0,1,1]\).
  id: totrans-1478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个随机的 3D 向量并将其投影到由 \([1,1,0]\) 和 \([0,1,1]\) 张成的平面上。
- en: The Takeaway
  id: totrans-1479
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: 'Projection: idempotent (\(P^2 = P\)), finds the closest vector in a subspace.'
  id: totrans-1480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投影：幂等的（\(P^2 = P\)），在子空间中找到最近的向量。
- en: 'Reflection: involutive (\(R^2 = I\)), flips across a line/plane but preserves
    lengths.'
  id: totrans-1481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射：自反的（\(R^2 = I\)），沿线/平面翻转但保持长度。
- en: Both are simple but powerful examples of linear transformations with clear geometry.****  ***###
    48\. Rotations and Shear (Geometric Intuition)
  id: totrans-1482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两个都是简单但强大的线性变换示例，具有清晰的几何意义。****  ***### 48\. 旋转和剪切（几何直觉）
- en: 'Two transformations often used in geometry, graphics, and physics are rotations
    and shears. Both are linear maps, but they behave differently:'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 在几何、图形和物理学中经常使用的两种变换是旋转和拉伸。两者都是线性映射，但它们的行为不同：
- en: Rotation preserves lengths and angles.
  id: totrans-1484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转保持长度和角度。
- en: Shear preserves area (in 2D) but distorts shapes, turning squares into parallelograms.
  id: totrans-1485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉伸保持面积（在2D中）但扭曲形状，将正方形变成平行四边形。
- en: Set Up Your Lab
  id: totrans-1486
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE475]'
  id: totrans-1487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Rotation in 2D
  id: totrans-1489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2D中的旋转
- en: 'The rotation matrix by angle \(\theta\) is:'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 角度为\(\theta\)的旋转矩阵是：
- en: \[ R(\theta) = \begin{bmatrix} \cos\theta & -\sin\theta \\ \sin\theta & \cos\theta
    \end{bmatrix} \]
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: \[ R(\theta) = \begin{bmatrix} \cos\theta & -\sin\theta \\ \sin\theta & \cos\theta
    \end{bmatrix} \]
- en: '[PRE476]'
  id: totrans-1492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '*[PRE477]*  *2.  Visualizing rotation'
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE477]*  *2.  旋转的可视化'
- en: '[PRE478]'
  id: totrans-1494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '*![](../Images/549924f5e5024e5a8c4b9b284dbdcc79.png)*  *The vector rotates
    counterclockwise by 45°.'
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/549924f5e5024e5a8c4b9b284dbdcc79.png)*  *向量逆时针旋转45°。'
- en: Shear in 2D
  id: totrans-1496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2D中的拉伸
- en: 'A shear along the x-axis by factor \(k\):'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: 沿x轴以因子\(k\)的拉伸：
- en: \[ S = \begin{bmatrix} 1 & k \\ 0 & 1 \end{bmatrix} \]
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: \[ S = \begin{bmatrix} 1 & k \\ 0 & 1 \end{bmatrix} \]
- en: '[PRE479]'
  id: totrans-1499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: '*[PRE480]*  *4.  Visualizing shear'
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE480]*  *4.  拉伸的可视化'
- en: '[PRE481]'
  id: totrans-1501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: '*![](../Images/21caaab0832fcb4f9abc360249d10585.png)*  *The shear moves the
    vector sideways, distorting its angle.'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/21caaab0832fcb4f9abc360249d10585.png)*  *拉伸将向量侧向移动，扭曲其角度。'
- en: Properties check
  id: totrans-1503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性检查
- en: 'Rotation preserves length:'
  id: totrans-1504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转保持长度：
- en: '[PRE482]'
  id: totrans-1505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: '*[PRE483]*  **   Shear preserves area (determinant = 1):'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE483]*  **   拉伸保持面积（行列式=1）：'
- en: '[PRE484]'
  id: totrans-1507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '*[PRE485]******  ***#### Try It Yourself'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE485]******  ***#### 尝试自己操作'
- en: Rotate \([1,0]\) by 90° and check it becomes \([0,1]\).
  id: totrans-1509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将\([1,0]\)旋转90°并检查它变成\([0,1]\)。
- en: Apply shear with \(k=2\) to a square (points \((0,0),(1,0),(1,1),(0,1)\)) and
    plot before/after.
  id: totrans-1510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将\(k=2\)的拉伸应用于正方形（点\((0,0),(1,0),(1,1),(0,1)\)）并绘制前后。
- en: 'Combine rotation and shear: apply shear first, then rotation. What happens?'
  id: totrans-1511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结合旋转和拉伸：先应用拉伸，然后旋转。会发生什么？
- en: The Takeaway
  id: totrans-1512
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: 'Rotation: length- and angle-preserving, determinant = 1.'
  id: totrans-1513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转：长度和角度保持，行列式=1。
- en: 'Shear: shape-distorting but area-preserving, determinant = 1.'
  id: totrans-1514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉伸：形状扭曲但面积保持，行列式=1。
- en: Both are linear maps that provide geometric intuition and real-world modeling
    tools.****  ***### 49\. Rank and Operator Viewpoint (Rank Beyond Elimination)
  id: totrans-1515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两种都是线性映射，提供了几何直觉和现实世界的建模工具。****  ***### 49. 秩和算子视角（秩超越消元）
- en: The rank of a matrix tells us how much “information” a linear map carries. Algebraically,
    it is the dimension of the image (column space). Geometrically, it measures how
    many independent directions survive the transformation.
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的秩告诉我们线性映射携带了多少“信息”。从代数上讲，它是像（列空间）的维度。从几何上讲，它衡量了多少独立方向在变换中幸存下来。
- en: 'From the operator viewpoint:'
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: 从算子视角：
- en: A matrix \(A\) is not just a table of numbers - it is a linear operator that
    maps vectors to other vectors.
  id: totrans-1518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵\(A\)不仅仅是一个数字表 - 它是一个线性算子，将向量映射到其他向量。
- en: The rank is the dimension of the output space that \(A\) actually reaches.
  id: totrans-1519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秩是\(A\)实际达到的输出空间的维度。
- en: Set Up Your Lab
  id: totrans-1520
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE486]'
  id: totrans-1521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Rank via elimination (SymPy)
  id: totrans-1523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过消元（SymPy）计算秩
- en: '[PRE487]'
  id: totrans-1524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: '*[PRE488]*  *Here, the second row is a multiple of the first → less independence
    → rank < 3.'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE488]*  *在这里，第二行是第一行的倍数→独立性降低→秩<3。'
- en: Rank via NumPy
  id: totrans-1526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过NumPy计算秩
- en: '[PRE489]'
  id: totrans-1527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '*[PRE490]*  *3.  Operator viewpoint'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE490]*  *3.  算子视角'
- en: 'Let’s apply \(A\) to random vectors:'
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用\(A\)到随机向量：
- en: '[PRE491]'
  id: totrans-1530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '*[PRE492]*  *Even though we started in 3D, all outputs lie in a plane in \(\mathbb{R}^3\).
    That’s why rank = 2.'
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE492]*  *尽管我们开始于3D，所有输出都位于\(\mathbb{R}^3\)中的平面上。这就是为什么秩=2。'
- en: Full rank vs reduced rank
  id: totrans-1532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 满秩与降秩
- en: 'Full rank: the transformation preserves dimension (no collapse).'
  id: totrans-1533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 满秩：变换保持维度（无塌陷）。
- en: 'Reduced rank: the transformation collapses onto a lower-dimensional subspace.'
  id: totrans-1534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降秩：变换塌缩到更低维的子空间。
- en: 'Example full-rank:'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 示例满秩：
- en: '[PRE493]'
  id: totrans-1536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: '*[PRE494]*  *5.  Connection to nullity'
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE494]*  *5.  与零空间的连接'
- en: 'The rank-nullity theorem:'
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 秩-零度定理：
- en: \[ \text{rank}(A) + \text{nullity}(A) = \text{number of columns of } A \]
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \text{rank}(A) + \text{nullity}(A) = A \text{的列数} \]
- en: 'Check with SymPy:'
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SymPy进行验证：
- en: '[PRE495]'
  id: totrans-1541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: '*[PRE496]*****  ***#### Try It Yourself'
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE496]*****  ***#### 尝试自己操作'
- en: Take
  id: totrans-1543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取
- en: \[ \begin{bmatrix} 1 & 1 \\ 1 & 1 \end{bmatrix} \]
  id: totrans-1544
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ \begin{bmatrix} 1 & 1 \\ 1 & 1 \end{bmatrix} \]
- en: and compute its rank. Why is it 1?
  id: totrans-1545
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并计算其秩。为什么是1？
- en: For a random 4×4 matrix, use `np.linalg.matrix_rank` to check if it’s invertible.
  id: totrans-1546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于一个随机的4×4矩阵，使用`np.linalg.matrix_rank`检查它是否可逆。
- en: Verify rank-nullity theorem for a 3×5 random integer matrix.
  id: totrans-1547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证3×5随机整数矩阵的秩-零度定理。
- en: The Takeaway
  id: totrans-1548
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Rank = dimension of the image (how many independent outputs a transformation
    has).
  id: totrans-1549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秩 = 像空间的维度（变换有多少个独立输出）。
- en: 'Operator viewpoint: rank shows how much of the input space survives after transformation.'
  id: totrans-1550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作员视角：秩表示变换后输入空间中保留了多少部分。
- en: Rank-nullity links the image and kernel - together they fully describe a linear
    operator.****  ***### 50\. Block Matrices and Block Maps (Divide and Conquer Structure)
  id: totrans-1551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秩-零度联系了像空间和核空间 - 它们共同完全描述了一个线性算子。****  ***### 50. 分块矩阵和分块映射（分而治之结构）
- en: Sometimes matrices can be arranged in blocks (submatrices). Treating a big matrix
    as smaller pieces helps simplify calculations, especially in systems with structure
    (networks, coupled equations, or partitioned variables).
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: 有时矩阵可以排列成块（子矩阵）。将大矩阵视为更小的部分有助于简化计算，尤其是在具有结构（网络、联合方程或分区变量）的系统。
- en: Set Up Your Lab
  id: totrans-1553
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE497]'
  id: totrans-1554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Constructing block matrices
  id: totrans-1556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建分块矩阵
- en: 'We can build a block matrix from smaller pieces:'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从更小的部分构建分块矩阵：
- en: '[PRE498]'
  id: totrans-1558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '*[PRE499]*  *2.  Block multiplication'
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE499]*  *2. 分块乘法'
- en: 'If a matrix is partitioned into blocks, multiplication follows block rules:'
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个矩阵被分成块，乘法遵循分块规则：
- en: \[ \begin{bmatrix} A & B \\ C & D \end{bmatrix} \begin{bmatrix} x \\ y \end{bmatrix}
    = \begin{bmatrix} Ax + By \\ Cx + Dy \end{bmatrix} \]
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{bmatrix} A & B \\ C & D \end{bmatrix} \begin{bmatrix} x \\ y \end{bmatrix}
    = \begin{bmatrix} Ax + By \\ Cx + Dy \end{bmatrix} \]
- en: 'Example:'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE500]'
  id: totrans-1563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: '*[PRE501]*  *Here the vector is split into blocks \([x,y]\).'
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE501]*  *这里向量被分成块 \([x,y]\)。'
- en: Block diagonal matrices
  id: totrans-1565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分块对角矩阵
- en: 'Block diagonal = independent subproblems:'
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: 分块对角矩阵 = 独立子问题：
- en: '[PRE502]'
  id: totrans-1567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '*[PRE503]*  *Applying this matrix acts separately on each block - like running
    two smaller transformations in parallel.'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE503]*  *应用此矩阵分别对每个块进行操作 - 像是并行运行两个较小的变换。'
- en: Inverse of block diagonal
  id: totrans-1569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分块对角矩阵的逆
- en: 'The inverse of a block diagonal is just the block diagonal of inverses:'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 分块对角矩阵的逆矩阵就是逆矩阵的分块对角矩阵：
- en: '[PRE504]'
  id: totrans-1571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: '*[PRE505]*  *5.  Practical example - coupled equations'
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE505]*  *5. 实际例子 - 联合方程'
- en: 'Suppose we have two independent systems:'
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个独立系统：
- en: 'System 1: \(Ax = b\)'
  id: totrans-1574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '系统 1: \(Ax = b\)'
- en: 'System 2: \(Cy = d\)'
  id: totrans-1575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '系统 2: \(Cy = d\)'
- en: 'We can represent both together:'
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以同时表示它们：
- en: \[ \begin{bmatrix} A & 0 \\ 0 & C \end{bmatrix} \begin{bmatrix} x \\ y \end{bmatrix}
    = \begin{bmatrix} b \\ d \end{bmatrix} \]
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{bmatrix} A & 0 \\ 0 & C \end{bmatrix} \begin{bmatrix} x \\ y \end{bmatrix}
    = \begin{bmatrix} b \\ d \end{bmatrix} \]
- en: This shows how block matrices organize multiple systems in one big equation.****  ***####
    Try It Yourself
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了分块矩阵如何在一个大方程中组织多个系统。****  ***#### 尝试自己操作
- en: Build a block diagonal matrix with three 2×2 blocks. Apply it to a vector.
  id: totrans-1579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个由三个 2×2 块组成的分块对角矩阵。将其应用于一个向量。
- en: Verify block multiplication rule by manually computing \(Ax + By\) and \(Cx
    + Dy\).
  id: totrans-1580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过手动计算 \(Ax + By\) 和 \(Cx + Dy\) 来验证分块乘法规则。
- en: Write two small systems of equations and combine them into one block system.
  id: totrans-1581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写两个小方程组并将它们组合成一个分块方程组。
- en: The Takeaway
  id: totrans-1582
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Block matrices let us break down big systems into smaller parts.
  id: totrans-1583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分块矩阵允许我们将大系统分解成更小的部分。
- en: Block diagonal matrices = independent subsystems.
  id: totrans-1584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分块对角矩阵 = 独立子系统。
- en: Thinking in blocks simplifies algebra, programming, and numerical computation.*******************************  ***##
    Chapter 6\. Determinants and volume
  id: totrans-1585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以块为单位思考简化了代数、编程和数值计算。*******************************  ***## 第 6 章. 矩阵行列式和体积
- en: 51\. Areas, Volumes, and Signed Scale Factors (Geometric Entry Point)
  id: totrans-1586
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 51. 面积、体积和符号缩放因子（几何入口点）
- en: 'The determinant of a matrix has a deep geometric meaning: it tells us how a
    linear transformation scales area (in 2D), volume (in 3D), or higher-dimensional
    content. It can also flip orientation (sign).'
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的行列式具有深刻的几何意义：它告诉我们线性变换如何缩放面积（在 2D 中）、体积（在 3D 中）或更高维度的内容。它还可以翻转方向（符号）。
- en: Set Up Your Lab
  id: totrans-1588
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE506]'
  id: totrans-1589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Determinant in 2D (area scaling)
  id: totrans-1591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2D 中的行列式（面积缩放）
- en: 'Let’s take a matrix that stretches and shears:'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个拉伸和剪切矩阵为例：
- en: '[PRE507]'
  id: totrans-1593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: '*[PRE508]*  *The determinant = 1 → areas are preserved, even though the shape
    is distorted.'
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE508]*  *行列式 = 1 → 面积得到保留，即使形状被扭曲。'
- en: Unit square under transformation
  id: totrans-1595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变换下的单位正方形
- en: 'Transform the square with corners \((0,0),(1,0),(1,1),(0,1)\):'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: 将顶点为 \((0,0),(1,0),(1,1),(0,1)\) 的正方形进行变换：
- en: '[PRE509]'
  id: totrans-1597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: '*[PRE510]*  *The area of the transformed shape equals \(|\det(A)|\).'
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE510]*  *变换后形状的面积等于 \(|\det(A)|\)。'
- en: Determinant in 3D (volume scaling)
  id: totrans-1599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3D 中的行列式（体积缩放）
- en: '[PRE511]'
  id: totrans-1600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: '*[PRE512]*  *\(\det(B)=3\) means that volumes are scaled by 3.'
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE512]*  *\(\det(B)=3\) 表示体积被缩放为 3。'
- en: Negative determinant = orientation flip
  id: totrans-1602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 负行列式 = 旋转
- en: '[PRE513]'
  id: totrans-1603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: '*[PRE514]*  *The determinant = -1 → area preserved but orientation flipped
    (like a mirror reflection).'
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE514]*  *行列式 = -1 → 面积保持但方向翻转（就像镜子反射）。'
- en: NumPy version
  id: totrans-1605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy 版本
- en: '[PRE515]'
  id: totrans-1606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: '*[PRE516]*****  ***#### Try It Yourself'
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE516]*****  ***#### 尝试自己操作'
- en: Take
  id: totrans-1608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取
- en: \[ \begin{bmatrix} 3 & 0 \\ 0 & 2 \end{bmatrix} \]
  id: totrans-1609
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ \begin{bmatrix} 3 & 0 \\ 0 & 2 \end{bmatrix} \]
- en: and compute the determinant. Verify it scales areas by 6.
  id: totrans-1610
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并计算行列式。验证它通过 6 缩放面积。
- en: Build a 3×3 shear matrix and check how it affects volume.
  id: totrans-1611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个 3×3 的剪切矩阵并检查它如何影响体积。
- en: Test a reflection matrix and confirm that the determinant is negative.
  id: totrans-1612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试一个反射矩阵并确认行列式是负的。
- en: The Takeaway
  id: totrans-1613
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Determinant measures how a linear map scales area, volume, or hypervolume.
  id: totrans-1614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行列式衡量线性映射如何缩放面积、体积或超体积。
- en: Positive determinant = preserves orientation; negative = flips it.
  id: totrans-1615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正行列式 = 保持方向；负行列式 = 翻转它。
- en: Magnitude of determinant = scaling factor of geometric content.****  ***###
    52\. Determinant via Linear Rules (Multilinearity, Sign, Normalization)
  id: totrans-1616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行列式的幅度 = 几何内容的缩放因子。****  ***### 52. 通过线性规则计算行列式（多线性、符号、归一化）
- en: The determinant isn’t just a formula; it’s defined by three elegant rules that
    make it unique. These rules capture its geometric meaning as a volume-scaling
    factor.
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: 行列式不仅仅是一个公式；它由三个优雅的规则定义，使其独一无二。这些规则捕捉了其作为体积缩放因子的几何意义。
- en: 'Multilinearity: Linear in each row (or column).'
  id: totrans-1618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多线性：对每一行（或列）是线性的。
- en: 'Sign Change: Swapping two rows flips the sign.'
  id: totrans-1619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 符号变化：交换两行会改变符号。
- en: 'Normalization: The determinant of the identity matrix is 1.'
  id: totrans-1620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 归一化：单位矩阵的行列式是 1。
- en: Set Up Your Lab
  id: totrans-1621
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置你的实验室
- en: '[PRE517]'
  id: totrans-1622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码分析'
- en: Multilinearity
  id: totrans-1624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多线性
- en: If one row is scaled, the determinant scales the same way.
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一行被缩放，行列式也会以相同的方式缩放。
- en: '[PRE518]'
  id: totrans-1626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: '*[PRE519]*  *You’ll see `det(B) = 2 * det(A)`.'
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE519]*  *你会看到 `det(B) = 2 * det(A)`。'
- en: Sign change by row swap
  id: totrans-1628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行交换引起的符号变化
- en: '[PRE520]'
  id: totrans-1629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: '*[PRE521]*  *Swapping rows flips the sign of the determinant.'
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE521]*  *交换行会改变行列式的符号。'
- en: Normalization rule
  id: totrans-1631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 归一化规则
- en: '[PRE522]'
  id: totrans-1632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: '*[PRE523]*  *The determinant of the identity is always 1 - this fixes the scaling
    baseline.'
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE523]*  *单位矩阵的行列式总是 1 - 这固定了缩放基线。'
- en: Combining rules (example in 3×3)
  id: totrans-1634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 规则组合（3×3 中的示例）
- en: '[PRE524]'
  id: totrans-1635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: '*[PRE525]*  *Here, rows are linearly dependent, so the determinant is 0 - consistent
    with multilinearity (since one row can be written as a combo of others).'
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE525]*  *在这里，行是线性相关的，所以行列式是 0 - 与多线性一致（因为一行可以写成其他行的组合）。'
- en: NumPy check
  id: totrans-1637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy 检查
- en: '[PRE526]'
  id: totrans-1638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: '*[PRE527]*  *Both SymPy and NumPy confirm the same result.*****  ***#### Try
    It Yourself'
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE527]*  *SymPy 和 NumPy 确认了相同的结果。*****  ***#### 尝试自己操作'
- en: Scale a row of a 3×3 matrix by 3\. Confirm the determinant scales by 3.
  id: totrans-1640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个 3×3 矩阵的行乘以 3。确认行列式乘以 3。
- en: Swap two rows twice in a row - does the determinant return to its original value?
  id: totrans-1641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连续两次交换两行 - 行列式会回到原始值吗？
- en: Compute determinant of a triangular matrix. What pattern do you see?
  id: totrans-1642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算三角矩阵的行列式。你看到了什么模式？
- en: The Takeaway
  id: totrans-1643
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Determinant is defined by multilinearity, sign change, and normalization.
  id: totrans-1644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行列式由多线性、符号变化和归一化定义。
- en: These rules uniquely pin down the determinant’s behavior.
  id: totrans-1645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些规则独特地确定了行列式的行为。
- en: Every formula (cofactor expansion, row-reduction method, etc.) comes from these
    core principles.****  ***### 53\. Determinant and Row Operations (How Each Move
    Changes det)
  id: totrans-1646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个公式（余子式展开、行简化法等）都源于这些核心原则。****  ***### 53. 行列式与行操作（每个操作如何改变 det）
- en: Row operations are at the heart of Gaussian elimination, and the determinant
    has simple, predictable reactions to them. Understanding these reactions gives
    both computational shortcuts and geometric intuition.
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: 行操作是高斯消元法的心脏，行列式对这些操作有简单、可预测的反应。理解这些反应既提供了计算捷径，又提供了几何直觉。
- en: The Three Key Rules
  id: totrans-1648
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 三条关键规则
- en: 'Row swap: Swapping two rows flips the sign of the determinant.'
  id: totrans-1649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行交换：交换两行会改变行列式的符号。
- en: 'Row scaling: Multiplying a row by a scalar \(c\) multiplies the determinant
    by \(c\).'
  id: totrans-1650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行缩放：将一行乘以标量 \(c\) 会将行列式乘以 \(c\)。
- en: 'Row replacement: Adding a multiple of one row to another leaves the determinant
    unchanged.'
  id: totrans-1651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行替换：将一行的一个倍数加到另一行上不会改变行列式。
- en: Set Up Your Lab
  id: totrans-1652
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置你的实验室
- en: '[PRE528]'
  id: totrans-1653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码分析'
- en: Row swap
  id: totrans-1655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行交换
- en: '[PRE529]'
  id: totrans-1656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: '*[PRE530]*  *The result flips sign.'
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE530]*  *结果会改变符号。'
- en: Row scaling
  id: totrans-1658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行缩放
- en: '[PRE531]'
  id: totrans-1659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: '*[PRE532]*  *Determinant is multiplied by 2.'
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE532]*  *行列式乘以 2。'
- en: Row replacement (no change)
  id: totrans-1661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行替换（无变化）
- en: '[PRE533]'
  id: totrans-1662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: '*[PRE534]*  *Determinant stays the same.'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE534]*  *行列式保持不变。'
- en: Triangular form shortcut
  id: totrans-1664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三角形式快捷方式
- en: Since elimination only uses row replacement (which doesn’t change the determinant)
    and row swaps/scales (which we can track), the determinant of a triangular matrix
    is just the product of its diagonal entries.
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: 由于消元只使用行替换（这不会改变行列式）和行交换/缩放（我们可以跟踪），三角矩阵的行列式就是其对角元素的乘积。
- en: '[PRE535]'
  id: totrans-1666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: '*[PRE536]*  *5.  NumPy confirmation'
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE536]*  *5.  NumPy 验证'
- en: '[PRE537]'
  id: totrans-1668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: '*[PRE538]*****  ***#### Try It Yourself'
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE538]*****  ***#### 尝试自己操作'
- en: Take
  id: totrans-1670
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取
- en: \[ \begin{bmatrix} 2 & 3 \\ 4 & 6 \end{bmatrix} \]
  id: totrans-1671
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ \begin{bmatrix} 2 & 3 \\ 4 & 6 \end{bmatrix} \]
- en: and scale the second row by \(\tfrac{1}{2}\). Compare determinants before and
    after.
  id: totrans-1672
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并将第二行缩放为 \(\tfrac{1}{2}\)。比较缩放前后的行列式。
- en: Do Gaussian elimination on a 3×3 matrix, and track how each row operation changes
    the determinant.
  id: totrans-1673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对一个 3×3 矩阵进行高斯消元，并跟踪每一行操作如何改变行列式。
- en: Compute determinant by reducing to triangular form and compare with SymPy’s
    `.det()`.
  id: totrans-1674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将矩阵化为三角形式来计算行列式，并与 SymPy 的 `.det()` 进行比较。
- en: The Takeaway
  id: totrans-1675
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Determinant reacts predictably to row operations.
  id: totrans-1676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行列式对行操作的反应是可预测的。
- en: Row replacement is “safe” (no change), scaling multiplies by the factor, and
    swapping flips the sign.
  id: totrans-1677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行替换是“安全的”（无变化），缩放乘以因子，交换改变符号。
- en: This makes elimination not just a solving tool, but also a method to compute
    determinants efficiently.****  ***### 54\. Triangular Matrices and Product of
    Diagonals (Fast Wins)
  id: totrans-1678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使得消元不仅是一个求解工具，而且是一种计算行列式的高效方法。****  ***### 54. 三角矩阵和对角线乘积（快速取胜）
- en: For triangular matrices (upper or lower), the determinant is simply the product
    of the diagonal entries. This rule is one of the biggest shortcuts in linear algebra
    - no expansion or elimination needed.
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: 对于三角矩阵（上三角或下三角），行列式就是对角元素的乘积。这是线性代数中最大的捷径之一——无需展开或消元。
- en: Why It Works
  id: totrans-1680
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么它有效
- en: Triangular matrices already look like the end result of Gaussian elimination.
  id: totrans-1681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三角矩阵已经看起来像是高斯消元的最终结果。
- en: Since row replacement operations don’t change the determinant, what’s left is
    just the product of the diagonal.
  id: totrans-1682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于行替换操作不会改变行列式，剩下的只是对角线的乘积。
- en: Set Up Your Lab
  id: totrans-1683
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE539]'
  id: totrans-1684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码解析'
- en: Upper triangular example
  id: totrans-1686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上三角示例
- en: '[PRE540]'
  id: totrans-1687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: '*[PRE541]*  *Both values match exactly.'
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE541]*  *两个值完全匹配。'
- en: Lower triangular example
  id: totrans-1689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下三角示例
- en: '[PRE542]'
  id: totrans-1690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: '*[PRE543]*  *3.  Diagonal matrix (special case)'
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE543]*  *3.  对角矩阵（特殊情况）'
- en: For diagonal matrices, determinant = product of diagonal entries directly.
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对角矩阵，行列式等于对角元素的乘积。
- en: '[PRE544]'
  id: totrans-1693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: '*[PRE545]*  *4.  NumPy version'
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE545]*  *4.  NumPy 版本'
- en: '[PRE546]'
  id: totrans-1695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: '*[PRE547]*  *5.  Quick elimination to triangular form'
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE547]*  *5.  快速消元到三角形式'
- en: Even for non-triangular matrices, elimination reduces them to triangular form,
    where this rule applies.
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是非三角矩阵，消元也会将它们化为三角形式，此时该规则适用。
- en: '[PRE548]'
  id: totrans-1698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: '*[PRE549]*****  ***#### Try It Yourself'
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE549]*****  ***#### 尝试自己操作'
- en: Compute the determinant of a 4×4 diagonal matrix quickly.
  id: totrans-1700
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速计算 4×4 对角矩阵的行列式。
- en: Verify that triangular matrices with a zero on the diagonal always have determinant
    0.
  id: totrans-1701
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证对角线上有零的三角矩阵的行列式总是为 0。
- en: Use SymPy to check that elimination to triangular form preserves determinant
    (except for swaps/scales).
  id: totrans-1702
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 SymPy 检查消元到三角形式是否保持行列式（除了交换/缩放）。
- en: The Takeaway
  id: totrans-1703
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: 'For triangular (and diagonal) matrices:'
  id: totrans-1704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于三角（和对角）矩阵：
- en: \[ \det(A) = \prod_{i} a_{ii} \]
  id: totrans-1705
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ \det(A) = \prod_{i} a_{ii} \]
- en: This shortcut makes determinant computation trivial.
  id: totrans-1706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个捷径使得行列式计算变得非常简单。
- en: 'Gaussian elimination leverages this fact: once reduced to triangular form,
    the determinant is just the product of pivots (with sign adjustments for swaps).****  ***###
    55\. det(AB) = det(A)det(B) (Multiplicative Magic)'
  id: totrans-1707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高斯消元利用了这个事实：一旦化为三角形式，行列式就是对角元素的乘积（考虑交换的符号调整）。****  ***### 55. det(AB) = det(A)det(B)（乘法魔法）
- en: 'One of the most elegant properties of determinants is multiplicativity:'
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: 行列式最优雅的性质之一是乘法性：
- en: \[ \det(AB) = \det(A)\,\det(B) \]
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \det(AB) = \det(A)\,\det(B) \]
- en: This rule is powerful because it connects algebra (matrix multiplication) with
    geometry (volume scaling).
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则非常强大，因为它将代数（矩阵乘法）与几何（体积缩放）联系起来。
- en: Geometric Intuition
  id: totrans-1711
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 几何直觉
- en: If \(A\) scales volumes by factor \(\det(A)\), and \(B\) scales them by \(\det(B)\),
    then applying \(B\) followed by \(A\) scales volumes by \(\det(A)\det(B)\).
  id: totrans-1712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 \(A\) 通过因子 \(\det(A)\) 缩放体积，而 \(B\) 通过 \(\det(B)\) 缩放体积，那么先应用 \(B\) 再应用 \(A\)
    将体积缩放为 \(\det(A)\det(B)\)。
- en: This property works in all dimensions.
  id: totrans-1713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个性质在所有维度上都适用。
- en: Set Up Your Lab
  id: totrans-1714
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE550]'
  id: totrans-1715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码解析'
- en: 2×2 example
  id: totrans-1717
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2×2 示例
- en: '[PRE551]'
  id: totrans-1718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: '*[PRE552]*  *The two results match.'
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE552]*  *两个结果匹配。'
- en: 3×3 random matrix check
  id: totrans-1720
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3×3 随机矩阵检查
- en: '[PRE553]'
  id: totrans-1721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: '*[PRE554]*  *3.  Special cases'
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE554]*  *3.  特殊情况'
- en: If \(\det(A)=0\), then \(\det(AB)=0\).
  id: totrans-1723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 \(\det(A)=0\)，则 \(\det(AB)=0\)。
- en: If \(\det(A)=\pm1\), it acts like a “volume-preserving” transformation (rotation/reflection).
  id: totrans-1724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 \(\det(A)=\pm1\)，它就像一个“体积保持”的变换（旋转/反射）。
- en: '[PRE555]'
  id: totrans-1725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: '*[PRE556]*  *Both are 0.'
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE556]*  *两个都是 0。'
- en: NumPy version
  id: totrans-1727
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy 版本
- en: '[PRE557]'
  id: totrans-1728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: '*[PRE558]****  ***#### Try It Yourself'
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE558]****  ***#### 尝试自己操作'
- en: Construct two triangular matrices and verify multiplicativity (diagonal products
    multiply too).
  id: totrans-1730
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造两个三角形矩阵并验证乘法性（对角线乘积也相乘）。
- en: Test the property with an orthogonal matrix \(Q\) (\(\det(Q)=\pm 1\)). What
    happens?
  id: totrans-1731
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正交矩阵 \(Q\) (\(\det(Q)=\pm 1\)) 测试该属性。会发生什么？
- en: Try with one matrix singular - confirm the product is always singular.
  id: totrans-1732
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用一个奇异的矩阵尝试 - 确认乘积总是奇异的。
- en: The Takeaway
  id: totrans-1733
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 总结
- en: Determinant is multiplicative, not additive.
  id: totrans-1734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行列式是乘法的，而不是加法的。
- en: \(\det(AB) = \det(A)\det(B)\) is a cornerstone identity in linear algebra.
  id: totrans-1735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(\det(AB) = \det(A)\det(B)\) 是线性代数中的一个基石恒等式。
- en: This property connects geometry (volume scaling) with algebra (matrix multiplication).****  ***###
    56\. Invertibility and Zero Determinant (Flat vs. Full Volume)
  id: totrans-1736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个属性将几何（体积缩放）与代数（矩阵乘法）联系起来。****  ***### 56. 可逆性和零行列式（平坦与满体积）
- en: 'The determinant gives a quick test for invertibility:'
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: 行列式为可逆性提供了一个快速测试：
- en: If \(\det(A) \neq 0\), the matrix is invertible.
  id: totrans-1738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 \(\det(A) \neq 0\)，则矩阵是可逆的。
- en: If \(\det(A) = 0\), the matrix is singular (non-invertible).
  id: totrans-1739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 \(\det(A) = 0\)，则矩阵是奇异的（不可逆的）。
- en: 'Geometrically:'
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: 几何上：
- en: Nonzero determinant → transformation keeps full dimension (no collapse).
  id: totrans-1741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非零行列式 → 变换保持完整维度（无塌缩）。
- en: Zero determinant → transformation flattens space into a lower dimension (volume
    = 0).
  id: totrans-1742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零行列式 → 变换将空间压扁到更低维度（体积 = 0）。
- en: Set Up Your Lab
  id: totrans-1743
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE559]'
  id: totrans-1744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码解析'
- en: Invertible example
  id: totrans-1746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可逆示例
- en: '[PRE560]'
  id: totrans-1747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: '*[PRE561]*  *The determinant is nonzero → invertible.'
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE561]*  *行列式非零 → 可逆。'
- en: Singular example (zero determinant)
  id: totrans-1749
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 奇异示例（零行列式）
- en: '[PRE562]'
  id: totrans-1750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: '*[PRE563]*  *Since the second row is a multiple of the first, determinant =
    0 → no inverse.'
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE563]*  *由于第二行是第一行的倍数，行列式 = 0 → 无逆。'
- en: Solving systems with determinant check
  id: totrans-1752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过行列式检查求解系统
- en: If \(\det(A)=0\), the system \(Ax=b\) may have no solutions or infinitely many.
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 \(\det(A)=0\)，则系统 \(Ax=b\) 可能没有解或有无限多个解。
- en: '[PRE564]'
  id: totrans-1754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: '*[PRE565]*  *SymPy indicates inconsistency or multiple solutions.'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE565]*  *SymPy 指示不一致或多个解。'
- en: Higher-dimensional example
  id: totrans-1756
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高维示例
- en: '[PRE566]'
  id: totrans-1757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: '*[PRE567]*  *Diagonal entries all nonzero → invertible.'
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE567]*  *对角线元素全部非零 → 可逆。'
- en: NumPy version
  id: totrans-1759
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy 版本
- en: '[PRE568]'
  id: totrans-1760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: '*[PRE569]*****  ***#### Try It Yourself'
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE569]*****  ***#### 尝试自己操作'
- en: Build a 3×3 matrix with determinant 0 by making one row a multiple of another.
    Confirm singularity.
  id: totrans-1762
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使一行成为另一行的倍数来构建一个行列式为 0 的 3×3 矩阵。确认奇异性。
- en: Generate a random 4×4 matrix and check whether it’s invertible using `.det()`.
  id: totrans-1763
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个随机的 4×4 矩阵并使用 `.det()` 检查它是否可逆。
- en: Test if two different 2×2 matrices are invertible, then multiply them together
    - is the product invertible too?
  id: totrans-1764
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试两个不同的 2×2 矩阵是否可逆，然后将它们相乘 - 积也是可逆的吗？
- en: The Takeaway
  id: totrans-1765
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 总结
- en: \(\det(A) \neq 0 \implies\) invertible (full volume).
  id: totrans-1766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(\det(A) \neq 0 \implies\) 可逆（满体积）。
- en: \(\det(A) = 0 \implies\) singular (space collapsed).
  id: totrans-1767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(\det(A) = 0 \implies\) 奇异（空间塌缩）。
- en: Determinant gives both algebraic and geometric insight into when a matrix is
    reversible.****  ***### 57\. Cofactor Expansion (Laplace’s Method)
  id: totrans-1768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行列式为矩阵何时可逆提供了代数和几何的洞察。****  ***### 57. 余子式展开（拉普拉斯方法）
- en: The cofactor expansion is a systematic way to compute determinants using minors.
    It’s not efficient for large matrices, but it reveals the recursive structure
    of determinants.
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: 余子式展开是使用余子矩阵系统地计算行列式的方法。它对于大矩阵来说并不高效，但它揭示了行列式的递归结构。
- en: Definition
  id: totrans-1770
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义
- en: For an \(n \times n\) matrix \(A\),
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个 \(n \times n\) 的矩阵 \(A\)，
- en: \[ \det(A) = \sum_{j=1}^{n} (-1)^{i+j} a_{ij} \det(M_{ij}) \]
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \det(A) = \sum_{j=1}^{n} (-1)^{i+j} a_{ij} \det(M_{ij}) \]
- en: 'where:'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: \(i\) = chosen row (or column),
  id: totrans-1774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(i\) = 选择行（或列），
- en: \(M_{ij}\) = minor matrix after removing row \(i\), column \(j\).
  id: totrans-1775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(M_{ij}\) = 删除行 \(i\) 和列 \(j\) 后的余子矩阵。
- en: Set Up Your Lab
  id: totrans-1776
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE570]'
  id: totrans-1777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码解析'
- en: 2×2 case (base rule)
  id: totrans-1779
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2×2 情况（基本规则）
- en: '[PRE571]'
  id: totrans-1780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: '*[PRE572]*  *Formula: \(\det(A) = ad - bc\).'
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE572]*  *公式：\(\det(A) = ad - bc\)。'
- en: 3×3 example using cofactor expansion
  id: totrans-1782
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用余子式展开的 3×3 示例
- en: '[PRE573]'
  id: totrans-1783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: '*[PRE574]*  *Let’s compute manually along the first row:'
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE574]*  *让我们手动沿着第一行计算：'
- en: '[PRE575]'
  id: totrans-1785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: '*[PRE576]*  *Both match (here = 0 because rows are dependent).'
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE576]*  *两个匹配（这里 = 0，因为行是相关的）。'
- en: Expansion along different rows/columns
  id: totrans-1787
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 沿不同行/列展开
- en: The result is the same no matter which row/column you expand along.
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你沿哪一行/列展开，结果都是相同的。
- en: '[PRE577]'
  id: totrans-1789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: '*[PRE578]*  *4.  Larger example (4×4)'
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE578]*  *4.  更大的例子（4×4）'
- en: '[PRE579]'
  id: totrans-1791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: '*[PRE580]*  *SymPy handles it directly, but conceptually it’s still the same
    recursive expansion.'
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE580]*  *SymPy 直接处理，但从概念上讲，它仍然是相同的递归展开。'
- en: NumPy vs SymPy
  id: totrans-1793
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy 与 SymPy
- en: '[PRE581]'
  id: totrans-1794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: '*[PRE582]******  ***#### Try It Yourself'
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE582]******  ***#### 尝试自己操作'
- en: Compute a 3×3 determinant manually using cofactor expansion and confirm with
    `.det()`.
  id: totrans-1796
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用余子式展开手动计算 3×3 行列式，并用 `.det()` 进行确认。
- en: Expand along a different row and check that the result is unchanged.
  id: totrans-1797
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 沿不同的行展开并检查结果是否不变。
- en: Build a 4×4 diagonal matrix and expand it - what simplification do you notice?
  id: totrans-1798
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个 4×4 对角矩阵并展开它 - 你注意到了什么简化？
- en: The Takeaway
  id: totrans-1799
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸取的经验
- en: Cofactor expansion defines determinant recursively.
  id: totrans-1800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 余子式展开定义行列式为递归形式。
- en: Works on any row or column, with consistent results.
  id: totrans-1801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何行或列上操作，结果都是一致的。
- en: Important for proofs and theory, though not practical for computation on large
    matrices.****  ***### 58\. Permutations and Sign (The Combinatorial Core)
  id: totrans-1802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然对证明和理论很重要，但对于大型矩阵的计算来说并不实用。****  ***### 58. 排列与符号（组合核心）
- en: 'The determinant can also be defined using permutations of indices. This looks
    abstract, but it’s the most fundamental definition:'
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的行列式也可以通过索引的排列来定义。这看起来很抽象，但这是最基本的规定：
- en: \[ \det(A) = \sum_{\sigma \in S_n} \text{sgn}(\sigma) \prod_{i=1}^n a_{i,\sigma(i)}
    \]
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \det(A) = \sum_{\sigma \in S_n} \text{sgn}(\sigma) \prod_{i=1}^n a_{i,\sigma(i)}
    \]
- en: \(S_n\) = set of all permutations of \(\{1,\dots,n\}\)
  id: totrans-1805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(S_n\) = \(\{1,\dots,n\}\) 的所有排列的集合
- en: \(\text{sgn}(\sigma)\) = +1 if the permutation is even, -1 if odd
  id: totrans-1806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(\text{sgn}(\sigma)\) = 如果排列是偶数，则 +1，如果是奇数，则 -1
- en: Each term = one product of entries, one from each row and column
  id: totrans-1807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每项 = 一个元素的乘积，每个元素来自每一行和每一列
- en: This formula explains why determinants mix signs, why row swaps flip the determinant,
    and why dependence kills it.
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式解释了为什么行列式会混合符号，为什么行交换会翻转行列式，以及为什么相关性会使其消失。
- en: Set Up Your Lab
  id: totrans-1809
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置你的实验室
- en: '[PRE583]'
  id: totrans-1810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Determinant by permutation expansion (3×3)
  id: totrans-1812
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行列式通过排列展开（3×3）
- en: '[PRE584]'
  id: totrans-1813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: '*[PRE585]*  *Both results ≈ 0, since rows are dependent.'
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE585]*  *两个结果 ≈ 0，因为行是相关的。'
- en: Count permutations
  id: totrans-1815
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算排列数
- en: 'For \(n=3\), there are \(3! = 6\) terms:'
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 \(n=3\)，有 \(3! = 6\) 项：
- en: \[ \det(A) = a_{11}a_{22}a_{33} + a_{12}a_{23}a_{31} + a_{13}a_{21}a_{32} -
    a_{13}a_{22}a_{31} - a_{11}a_{23}a_{32} - a_{12}a_{21}a_{33} \]
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \det(A) = a_{11}a_{22}a_{33} + a_{12}a_{23}a_{31} + a_{13}a_{21}a_{32} -
    a_{13}a_{22}a_{31} - a_{11}a_{23}a_{32} - a_{12}a_{21}a_{33} \]
- en: You can see the alternating signs explicitly.
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以明确看到交替的符号。
- en: Verification with SymPy
  id: totrans-1819
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 SymPy 进行验证
- en: '[PRE586]'
  id: totrans-1820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: '*[PRE587]*  *Matches the permutation expansion.'
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE587]*  *与排列展开匹配。'
- en: Growth of terms
  id: totrans-1822
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项的增长
- en: 2×2 → 2 terms
  id: totrans-1823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2×2 → 2 项
- en: 3×3 → 6 terms
  id: totrans-1824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3×3 → 6 项
- en: 4×4 → 24 terms
  id: totrans-1825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4×4 → 24 项
- en: \(n\) → \(n!\) terms (factorial growth!)
  id: totrans-1826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(n\) → \(n!\) 项（阶乘增长！）
- en: This is why cofactor or LU is preferred computationally.**  **#### Try It Yourself
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在计算上更倾向于使用余子式或 LU 分解。**  **#### 尝试自己操作
- en: Write out the 2×2 permutation formula explicitly and check it equals \(ad -
    bc\).
  id: totrans-1828
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 明确写出 2×2 排列公式的具体形式，并检查它是否等于 \(ad - bc\)。
- en: Expand a 3×3 determinant by hand using the six terms.
  id: totrans-1829
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用六个项手动展开 3×3 行列式。
- en: Modify the code to count how many multiplications are required for a 5×5 matrix
    using the permutation definition.
  id: totrans-1830
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改代码以计算使用排列定义所需的 5×5 矩阵的乘法次数。
- en: The Takeaway
  id: totrans-1831
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸取的经验
- en: Determinant = signed sum over all permutations.
  id: totrans-1832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行列式 = 所有排列的符号和。
- en: Signs come from permutation parity (even/odd swaps).
  id: totrans-1833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号来自排列的奇偶性（偶数/奇数交换）。
- en: This definition is the combinatorial foundation that unifies all determinant
    properties.***  ***### 59\. Cramer’s Rule (Solving with Determinants, and When
    Not to Use It)
  id: totrans-1834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个定义是统一所有行列式性质的组合基础。***  ***### 59. 克莱姆法则（使用行列式求解，以及何时不使用它）
- en: Cramer’s Rule gives an explicit formula for solving a system of linear equations
    \(Ax = b\) using determinants. It is elegant but inefficient for large systems.
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: 克莱姆法则给出了使用行列式求解线性方程组 \(Ax = b\) 的显式公式。它很优雅，但对于大型系统来说效率不高。
- en: 'For \(A \in \mathbb{R}^{n \times n}\) with \(\det(A) \neq 0\):'
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 \(A \in \mathbb{R}^{n \times n}\) 且 \(\det(A) \neq 0\)：
- en: \[ x_i = \frac{\det(A_i)}{\det(A)} \]
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x_i = \frac{\det(A_i)}{\det(A)} \]
- en: where \(A_i\) is \(A\) with its \(i\)-th column replaced by \(b\).
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(A_i\) 是 \(A\) 的第 \(i\) 列被 \(b\) 替换后的矩阵。
- en: Set Up Your Lab
  id: totrans-1839
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置你的实验室
- en: '[PRE588]'
  id: totrans-1840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Simple 2×2 example
  id: totrans-1842
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简单的 2×2 示例
- en: 'Solve:'
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
  zh: 解：
- en: \[ \begin{cases} 2x + y = 5 \\ x - y = 1 \end{cases} \]
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{cases} 2x + y = 5 \\ x - y = 1 \end{cases} \]
- en: '[PRE589]'
  id: totrans-1845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: '*[PRE590]*  *Both give the same solution.'
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE590]*  *两者给出相同的解。'
- en: 3×3 example
  id: totrans-1847
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3×3 示例
- en: '[PRE591]'
  id: totrans-1848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: '*[PRE592]*  *3.  NumPy version (inefficient but illustrative)'
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE592]*  *3.  NumPy版本（效率低但具有说明性）'
- en: '[PRE593]'
  id: totrans-1850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: '*[PRE594]*  *4.  Why not use it in practice?'
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE594]*  *4.  为什么在实践中不使用它？'
- en: Requires computing \(n+1\) determinants.
  id: totrans-1852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要计算\(n+1\)个行列式。
- en: Determinant computation via cofactor expansion is factorial-time.
  id: totrans-1853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过余子式展开计算行列式是阶乘时间的。
- en: Gaussian elimination or LU is far more efficient.***  ***#### Try It Yourself
  id: totrans-1854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高斯消元法或LU分解要高效得多。***  ***#### 尝试自己操作
- en: Solve a 3×3 system using Cramer’s Rule and confirm with `A.solve(b)`.
  id: totrans-1855
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用柯西法则解3×3系统，并使用`A.solve(b)`进行确认。
- en: Try Cramer’s Rule when \(\det(A)=0\). What happens?
  id: totrans-1856
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当\(\det(A)=0\)时尝试柯西法则。会发生什么？
- en: Compare runtime of Cramer’s Rule vs LU for a random 5×5 matrix.
  id: totrans-1857
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较随机5×5矩阵的柯西法则和LU分解的运行时间。
- en: The Takeaway
  id: totrans-1858
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸取的教训
- en: Cramer’s Rule gives explicit formulas for solutions using determinants.
  id: totrans-1859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柯西法则给出了使用行列式的解的显式公式。
- en: Beautiful for theory, useful for small cases, but not computationally practical.
  id: totrans-1860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于理论来说很美，对于小案例来说很有用，但计算上并不实用。
- en: It highlights the deep connection between determinants and solving linear systems.****  ***###
    60\. Computing Determinants in Practice (Use LU, Mind Stability)
  id: totrans-1861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它突出了行列式与求解线性系统之间的深层联系。****  ***### 60. 实际计算行列式（使用LU，注意稳定性）
- en: While definitions like cofactor expansion and permutations are beautiful, they
    are too slow for large matrices. In practice, determinants are computed using
    row reduction or LU decomposition, with careful attention to numerical stability.
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然像余子式展开和排列这样的定义很美，但对于大型矩阵来说太慢了。实际上，行列式是通过行简化或LU分解来计算的，同时注意数值稳定性。
- en: Set Up Your Lab
  id: totrans-1863
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE595]'
  id: totrans-1864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Cofactor expansion is too slow
  id: totrans-1866
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 余子式展开太慢
- en: '[PRE596]'
  id: totrans-1867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: '*[PRE597]*  *This works for 3×3, but complexity grows factorially.'
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE597]*  *这适用于3×3，但复杂性呈阶乘增长。'
- en: Determinant via triangular form (LU decomposition)
  id: totrans-1869
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过三角形式（LU分解）计算行列式
- en: LU decomposition factorizes \(A = LU\), where \(L\) is lower triangular and
    \(U\) is upper triangular. Determinant = product of diagonals of \(U\), up to
    sign corrections for row swaps.
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
  zh: LU分解将\(A = LU\)分解，其中\(L\)是下三角矩阵，\(U\)是上三角矩阵。行列式等于\(U\)对角线的乘积，考虑到行交换的符号修正。
- en: '[PRE598]'
  id: totrans-1871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: '*[PRE599]*  *3.  NumPy efficient method'
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE599]*  *3.  NumPy高效方法'
- en: '[PRE600]'
  id: totrans-1873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE600]'
- en: '*[PRE601]*  *NumPy uses optimized routines (LAPACK under the hood).'
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE601]*  *NumPy使用优化例程（底层是LAPACK）。'
- en: Large random matrix
  id: totrans-1875
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大型随机矩阵
- en: '[PRE602]'
  id: totrans-1876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE602]'
- en: '*[PRE603]*  *Computes quickly even for larger matrices.'
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE603]*  *即使对于较大的矩阵也能快速计算。'
- en: Stability issues
  id: totrans-1878
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 稳定性问题
- en: 'Determinants of large or ill-conditioned matrices can suffer from floating-point
    errors. For example, if rows are nearly dependent:'
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: 大型或病态矩阵的行列式可能会受到浮点误差的影响。例如，如果行几乎相关：
- en: '[PRE604]'
  id: totrans-1880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE604]'
- en: '*[PRE605]*  *The result may not be exactly 0 due to floating-point approximations.*****  ***####
    Try It Yourself'
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE605]*  *由于浮点近似，结果可能不会正好是0。*****  ***#### 尝试自己操作'
- en: Compute the determinant of a random 10×10 matrix with `np.linalg.det`.
  id: totrans-1882
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`np.linalg.det`计算随机10×10矩阵的行列式。
- en: Compare results between SymPy (exact rational arithmetic) and NumPy (floating-point).
  id: totrans-1883
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较SymPy（精确有理数算术）和NumPy（浮点数）的结果。
- en: Test determinant of a nearly singular matrix - notice numerical instability.
  id: totrans-1884
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试接近奇异矩阵的行列式 - 注意数值不稳定性。
- en: The Takeaway
  id: totrans-1885
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸取的教训
- en: Determinants in practice are computed with LU decomposition or equivalent.
  id: totrans-1886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上，行列式是通过LU分解或等效方法计算的。
- en: Always be mindful of numerical stability - small errors matter when determinant
    ≈ 0.
  id: totrans-1887
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是注意数值稳定性 - 当行列式≈0时，小误差很重要。
- en: For exact answers (small cases), use symbolic tools like SymPy; for speed, use
    NumPy.*******************************  ***## Chapter 7\. Eigenvalues, Eigenvectors,
    and Dynamics
  id: totrans-1888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于精确答案（小案例），使用符号工具如SymPy；对于速度，使用NumPy。*******************************  ***##
    第7章. 特征值、特征向量和动力学
- en: 61\. Eigenvalues and Eigenvectors (Directions That Stay Put)
  id: totrans-1889
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 61. 特征值和特征向量（保持不变的方向）
- en: An eigenvector of a matrix \(A\) is a special vector that doesn’t change direction
    when multiplied by \(A\). Instead, it only gets stretched or shrunk by a scalar
    called the eigenvalue.
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵\(A\)的特征向量是一个特殊的向量，当乘以\(A\)时不会改变方向。相反，它只被一个称为特征值的标量拉伸或收缩。
- en: 'Formally:'
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
  zh: 形式上：
- en: \[ A v = \lambda v \]
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
  zh: \[ A v = \lambda v \]
- en: where \(v\) is an eigenvector and \(\lambda\) is the eigenvalue.
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: 其中\(v\)是特征向量，\(\lambda\)是特征值。
- en: 'Geometrically: eigenvectors are “preferred directions” of a linear transformation.'
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
  zh: 几何上：特征向量是线性变换的“首选方向”。
- en: Set Up Your Lab
  id: totrans-1895
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE606]'
  id: totrans-1896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE606]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1897
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: A simple 2×2 example
  id: totrans-1898
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个简单的2×2例子
- en: '[PRE607]'
  id: totrans-1899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE607]'
- en: '*[PRE608]*  *This outputs eigenvalues and their associated eigenvectors.'
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE608]*  *这输出了特征值及其相关的特征向量。'
- en: Verify the eigen equation
  id: totrans-1901
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证特征方程
- en: 'Pick one eigenpair \((\lambda, v)\):'
  id: totrans-1902
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个特征对 \((\lambda, v)\)：
- en: '[PRE609]'
  id: totrans-1903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE609]'
- en: '*[PRE610]*  *Both sides match → confirming the eigenpair.'
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE610]*  *两边匹配 → 确认特征对。'
- en: NumPy version
  id: totrans-1905
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy版本
- en: '[PRE611]'
  id: totrans-1906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE611]'
- en: '*[PRE612]*  *Columns of `eigvecs` are eigenvectors.'
  id: totrans-1907
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE612]*  *`eigvecs`的列是特征向量。'
- en: Geometric interpretation (plot)
  id: totrans-1908
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几何解释（绘图）
- en: '[PRE613]'
  id: totrans-1909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE613]'
- en: '*![](../Images/09c3ff333d37228c7b215f249ee63f17.png)*  *Both eigenvectors define
    directions where the transformation acts by scaling only.'
  id: totrans-1910
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/09c3ff333d37228c7b215f249ee63f17.png)*  *两个特征向量定义了仅通过缩放进行变换的方向。'
- en: Random 3×3 matrix example
  id: totrans-1911
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机3×3矩阵示例
- en: '[PRE614]'
  id: totrans-1912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE614]'
- en: '*[PRE615]*****  ***#### Try It Yourself'
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE615]*****  ***#### 尝试自己动手做'
- en: Compute eigenvalues and eigenvectors of
  id: totrans-1914
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算以下矩阵的特征值和特征向量
- en: \[ \begin{bmatrix} 3 & 0 \\ 0 & 2 \end{bmatrix} \]
  id: totrans-1915
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ \begin{bmatrix} 3 & 0 \\ 0 & 2 \end{bmatrix} \]
- en: and verify that they match the diagonal entries.
  id: totrans-1916
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并验证它们与对角线项相匹配。
- en: Use NumPy to find eigenvectors of a rotation matrix by 90°. What do you notice?
  id: totrans-1917
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用NumPy找到旋转矩阵90°的特征向量。你注意到什么？
- en: For a singular matrix, check if 0 is an eigenvalue.
  id: totrans-1918
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于一个奇异矩阵，检查0是否为特征值。
- en: The Takeaway
  id: totrans-1919
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Eigenvalues = scale factors; eigenvectors = directions that stay put.
  id: totrans-1920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征值 = 缩放因子；特征向量 = 保持不变的方向。
- en: The eigen equation \(Av=\lambda v\) captures the essence of a matrix’s action.
  id: totrans-1921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征方程 \(Av=\lambda v\) 捕捉了矩阵作用的本质。
- en: They form the foundation for deeper topics like diagonalization, stability,
    and dynamics.****  ***### 62\. Characteristic Polynomial (Where Eigenvalues Come
    From)
  id: totrans-1922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是深入主题如对角化、稳定性和动力学的基础。****  ***### 62. 特征多项式（特征值从何而来）
- en: Eigenvalues don’t appear out of thin air - they come from the characteristic
    polynomial of a matrix. For a square matrix \(A\),
  id: totrans-1923
  prefs: []
  type: TYPE_NORMAL
  zh: 特征值不是凭空出现的 - 它们来自矩阵的特征多项式。对于一个方阵 \(A\)，
- en: \[ p(\lambda) = \det(A - \lambda I) \]
  id: totrans-1924
  prefs: []
  type: TYPE_NORMAL
  zh: \[ p(\lambda) = \det(A - \lambda I) \]
- en: The roots of this polynomial are the eigenvalues of \(A\).
  id: totrans-1925
  prefs: []
  type: TYPE_NORMAL
  zh: 这个多项式的根是矩阵 \(A\) 的特征值。
- en: Set Up Your Lab
  id: totrans-1926
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE616]'
  id: totrans-1927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE616]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1928
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: 2×2 example
  id: totrans-1929
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2×2示例
- en: \[ A = \begin{bmatrix} 2 & 1 \\ 1 & 2 \end{bmatrix} \]
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
  zh: \[ A = \begin{bmatrix} 2 & 1 \\ 1 & 2 \end{bmatrix} \]
- en: '[PRE617]'
  id: totrans-1931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE617]'
- en: '*[PRE618]*  *Polynomial: \(\lambda^2 - 4\lambda + 3\). Roots: \(\lambda = 3,
    1\).'
  id: totrans-1932
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE618]*  *多项式：\(\lambda^2 - 4\lambda + 3\)。根：\(\lambda = 3, 1\)。'
- en: Verify with eigen computation
  id: totrans-1933
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过特征值计算验证
- en: '[PRE619]'
  id: totrans-1934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE619]'
- en: '*[PRE620]*  *Matches the roots of the polynomial.'
  id: totrans-1935
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE620]*  *与多项式的根相匹配。'
- en: 3×3 example
  id: totrans-1936
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3×3示例
- en: '[PRE621]'
  id: totrans-1937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE621]'
- en: '*[PRE622]*  *4.  NumPy version'
  id: totrans-1938
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE622]*  *4.  NumPy版本'
- en: 'NumPy doesn’t give the polynomial directly, but eigenvalues can be checked:'
  id: totrans-1939
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy不直接给出多项式，但可以检查特征值：
- en: '[PRE623]'
  id: totrans-1940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE623]'
- en: '*[PRE624]*  *5.  Relation to trace and determinant'
  id: totrans-1941
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE624]*  *5.  与迹和行列式的关联'
- en: For a 2×2 matrix
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个2×2矩阵
- en: \[ A = \begin{bmatrix} a & b \\ c & d \end{bmatrix}, \]
  id: totrans-1943
  prefs: []
  type: TYPE_NORMAL
  zh: \[ A = \begin{bmatrix} a & b \\ c & d \end{bmatrix}, \]
- en: the characteristic polynomial is
  id: totrans-1944
  prefs: []
  type: TYPE_NORMAL
  zh: 特征多项式是
- en: \[ \lambda^2 - (a+d)\lambda + (ad - bc). \]
  id: totrans-1945
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \lambda^2 - (a+d)\lambda + (ad - bc). \]
- en: 'Coefficient of \(\lambda\): \(-\text{trace}(A)\).'
  id: totrans-1946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(\lambda\)的系数：\(-\text{trace}(A)\)。
- en: 'Constant term: \(\det(A)\).'
  id: totrans-1947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常数项：\(\det(A)\)。
- en: '[PRE625]'
  id: totrans-1948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE625]'
- en: '*[PRE626]*****  ***#### Try It Yourself'
  id: totrans-1949
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE626]*****  ***#### 尝试自己动手做'
- en: Compute the characteristic polynomial of
  id: totrans-1950
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算以下矩阵的特征多项式
- en: \[ \begin{bmatrix} 4 & 0 \\ 0 & 5 \end{bmatrix} \]
  id: totrans-1951
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ \begin{bmatrix} 4 & 0 \\ 0 & 5 \end{bmatrix} \]
- en: and confirm eigenvalues are 4 and 5.
  id: totrans-1952
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并确认特征值为4和5。
- en: Check the relationship between polynomial coefficients, trace, and determinant
    for a 3×3 case.
  id: totrans-1953
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查3×3情况中多项式系数、迹和行列式之间的关系。
- en: Verify with NumPy that the roots of the polynomial equal the eigenvalues.
  id: totrans-1954
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过NumPy验证多项式的根等于特征值。
- en: The Takeaway
  id: totrans-1955
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**总结**'
- en: The characteristic polynomial encodes eigenvalues as its roots.
  id: totrans-1956
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征多项式将特征值编码为其根。
- en: 'Coefficients are tied to invariants: trace and determinant.'
  id: totrans-1957
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系数与不变量相关联：迹和行列式。
- en: This polynomial viewpoint is the bridge from algebraic formulas to geometric
    eigen-behavior.****  ***### 63\. Algebraic vs. Geometric Multiplicity (How Many
    and How Independent)
  id: totrans-1958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种多项式观点是代数公式到几何特征行为的桥梁。****  ***### 63. 代数重数与几何重数（多少和多少是独立的）
- en: 'Eigenvalues can repeat, and when they do, two notions of multiplicity arise:'
  id: totrans-1959
  prefs: []
  type: TYPE_NORMAL
  zh: 特征值可以重复，当它们重复时，会引发两种多重性的概念：
- en: 'Algebraic multiplicity: how many times the eigenvalue appears as a root of
    the characteristic polynomial.'
  id: totrans-1960
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代数重数：特征值作为特征多项式的根出现的次数。
- en: 'Geometric multiplicity: the dimension of the eigenspace (number of independent
    eigenvectors).'
  id: totrans-1961
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几何重数：特征空间的维度（独立特征向量的数量）。
- en: 'Always:'
  id: totrans-1962
  prefs: []
  type: TYPE_NORMAL
  zh: 总是：
- en: \[ 1 \leq \text{geometric multiplicity} \leq \text{algebraic multiplicity} \]
  id: totrans-1963
  prefs: []
  type: TYPE_NORMAL
  zh: \[ 1 \leq \text{几何重数} \leq \text{代数重数} \]
- en: Set Up Your Lab
  id: totrans-1964
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE627]'
  id: totrans-1965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE627]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1966
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码解析'
- en: Matrix with repeated eigenvalue
  id: totrans-1967
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有重复特征值的矩阵
- en: '[PRE628]'
  id: totrans-1968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE628]'
- en: '*[PRE629]*  **   Eigenvalue 2 has algebraic multiplicity = 2.'
  id: totrans-1969
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE629]*  **特征值 2 的代数重数 = 2。'
- en: But only 1 independent eigenvector → geometric multiplicity = 1.
  id: totrans-1970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但只有一个独立的特征向量 → 几何重数 = 1。
- en: Diagonal matrix with repetition
  id: totrans-1971
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复对角矩阵
- en: '[PRE630]'
  id: totrans-1972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE630]'
- en: '*[PRE631]*  *Here, eigenvalue 3 has algebraic multiplicity = 3, and geometric
    multiplicity = 3.'
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE631]*  *在这里，特征值 3 的代数重数为 3，几何重数也为 3。'
- en: NumPy check
  id: totrans-1974
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy 检查
- en: '[PRE632]'
  id: totrans-1975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE632]'
- en: '*[PRE633]*  *NumPy won’t show multiplicities directly, but you can see repeated
    eigenvalues.'
  id: totrans-1976
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE633]*  *NumPy 不会直接显示重数，但你可以看到重复的特征值。'
- en: Comparing two cases
  id: totrans-1977
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较两种情况
- en: 'Defective matrix: Algebraic > geometric (like the upper triangular \(A\)).'
  id: totrans-1978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺陷矩阵：代数重数 > 几何重数（如上三角矩阵 \(A\)）。
- en: 'Diagonalizable matrix: Algebraic = geometric (like \(B\)).'
  id: totrans-1979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可对角化矩阵：代数重数 = 几何重数（如 \(B\)）。
- en: This distinction determines whether a matrix can be diagonalized.***  ***####
    Try It Yourself
  id: totrans-1980
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区别决定了矩阵是否可以对角化。***  ***#### 尝试自己操作
- en: Compute algebraic and geometric multiplicities of
  id: totrans-1981
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算以下矩阵的代数重数和几何重数
- en: \[ \begin{bmatrix} 1 & 1 \\ 0 & 1 \end{bmatrix} \]
  id: totrans-1982
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ \begin{bmatrix} 1 & 1 \\ 0 & 1 \end{bmatrix} \]
- en: '(hint: only one eigenvector).'
  id: totrans-1983
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （提示：只有一个特征向量）。
- en: Take a diagonal matrix with repeated entries - what happens to multiplicities?
  id: totrans-1984
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑一个具有重复项的对角矩阵——重数会发生什么变化？
- en: Test a random 3×3 singular matrix. Does 0 have algebraic multiplicity > 1?
  id: totrans-1985
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试一个随机的 3×3 非奇异矩阵。0 的代数重数是否大于 1？
- en: The Takeaway
  id: totrans-1986
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Algebraic multiplicity = count of root in characteristic polynomial.
  id: totrans-1987
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代数重数 = 特征多项式中根的计数。
- en: Geometric multiplicity = dimension of eigenspace.
  id: totrans-1988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几何重数 = 特征空间的维度。
- en: If they match for all eigenvalues → matrix is diagonalizable.****  ***### 64\.
    Diagonalization (When a Matrix Becomes Simple)
  id: totrans-1989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对于所有特征值都匹配 → 矩阵是对角化的。****  ***### 64. 对角化（当矩阵变得简单）
- en: A matrix \(A\) is diagonalizable if it can be written as
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
  zh: 如果矩阵 \(A\) 可以写成
- en: \[ A = P D P^{-1} \]
  id: totrans-1991
  prefs: []
  type: TYPE_NORMAL
  zh: \[ A = P D P^{-1} \]
- en: \(D\) is diagonal (containing eigenvalues).
  id: totrans-1992
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(D\) 是对角矩阵（包含特征值）。
- en: Columns of \(P\) are the eigenvectors.
  id: totrans-1993
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(P\) 的列是特征向量。
- en: This means \(A\) acts like simple scaling in a “better” coordinate system.
  id: totrans-1994
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 \(A\) 在一个“更好”的坐标系中表现为简单的缩放。
- en: Set Up Your Lab
  id: totrans-1995
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE634]'
  id: totrans-1996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE634]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-1997
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码解析'
- en: A diagonalizable 2×2 matrix
  id: totrans-1998
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个可对角化的 2×2 矩阵
- en: '[PRE635]'
  id: totrans-1999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE635]'
- en: '*[PRE636]*  *2.  A non-diagonalizable matrix'
  id: totrans-2000
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE636]*  *2.  不可对角化矩阵'
- en: '[PRE637]'
  id: totrans-2001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE637]'
- en: '*[PRE638]*  *This fails because eigenvalue 2 has algebraic multiplicity 2 but
    geometric multiplicity 1.'
  id: totrans-2002
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE638]*  *这失败是因为特征值 2 的代数重数为 2 但几何重数为 1。'
- en: Diagonalization with NumPy
  id: totrans-2003
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 NumPy 进行对角化
- en: 'NumPy doesn’t diagonalize explicitly, but we can build \(P\) and \(D\) ourselves:'
  id: totrans-2004
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 不会显式地进行对角化，但我们可以自己构建 \(P\) 和 \(D\)：
- en: '[PRE639]'
  id: totrans-2005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE639]'
- en: '*[PRE640]*  *4.  Powers of a diagonalizable matrix'
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE640]*  *4.  可对角化矩阵的幂'
- en: 'One reason diagonalization is powerful:'
  id: totrans-2007
  prefs: []
  type: TYPE_NORMAL
  zh: 对角化强大的一个原因：
- en: \[ A^k = P D^k P^{-1} \]
  id: totrans-2008
  prefs: []
  type: TYPE_NORMAL
  zh: \[ A^k = P D^k P^{-1} \]
- en: Since \(D^k\) is trivial (just raise each diagonal entry to power \(k\)).
  id: totrans-2009
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 \(D^k\) 是平凡的（只需将每个对角元素提升到 \(k\) 次幂）。
- en: '[PRE641]'
  id: totrans-2010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE641]'
- en: '*[PRE642]*  *Both match.****  ***#### Try It Yourself'
  id: totrans-2011
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE642]*  *两者匹配。****  ***#### 尝试自己操作'
- en: Check whether
  id: totrans-2012
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查以下
- en: \[ \begin{bmatrix} 5 & 0 \\ 0 & 5 \end{bmatrix} \]
  id: totrans-2013
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ \begin{bmatrix} 5 & 0 \\ 0 & 5 \end{bmatrix} \]
- en: is diagonalizable.
  id: totrans-2014
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是可对角化的。
- en: Try diagonalizing a rotation matrix by 90°. Do you get complex eigenvalues?
  id: totrans-2015
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试通过 90° 旋转矩阵进行对角化。你会得到复数特征值吗？
- en: Verify the formula \(A^k = P D^k P^{-1}\) for a 3×3 diagonalizable matrix.
  id: totrans-2016
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证 3×3 可对角化矩阵的公式 \(A^k = P D^k P^{-1}\)。
- en: The Takeaway
  id: totrans-2017
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Diagonalization rewrites a matrix in its simplest form.
  id: totrans-2018
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对角化将矩阵重写为其最简形式。
- en: Works if there are enough independent eigenvectors.
  id: totrans-2019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有足够的独立特征向量，则有效。
- en: It makes powers of \(A\) easy, and is the gateway to analyzing dynamics.****  ***###
    65\. Powers of a Matrix (Long-Term Behavior via Eigenvalues)
  id: totrans-2020
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使 \(A\) 的幂变得简单，并且是分析动力学的入门。****  ***### 65. 矩阵的幂（通过特征值的长时行为）
- en: 'One of the most useful applications of eigenvalues and diagonalization is computing
    powers of a matrix:'
  id: totrans-2021
  prefs: []
  type: TYPE_NORMAL
  zh: 最有用的特征值和对角化应用之一是计算矩阵的幂：
- en: \[ A^k = P D^k P^{-1} \]
  id: totrans-2022
  prefs: []
  type: TYPE_NORMAL
  zh: \[ A^k = P D^k P^{-1} \]
- en: where \(D\) is diagonal with eigenvalues of \(A\). Each eigenvalue \(\lambda\)
    raised to \(k\) dictates how its eigenvector direction grows, decays, or oscillates
    over time.
  id: totrans-2023
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(D\) 是对角矩阵，具有 \(A\) 的特征值。每个特征值 \(\lambda\) 的 \(k\) 次幂决定了其特征向量方向随时间增长、衰减或振荡的方式。
- en: Set Up Your Lab
  id: totrans-2024
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE643]'
  id: totrans-2025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE643]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2026
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码解析'
- en: Simple diagonal matrix
  id: totrans-2027
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简单的对角矩阵
- en: 'If \(D = \text{diag}(2,3)\):'
  id: totrans-2028
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 \(D = \text{diag}(2,3)\):'
- en: '[PRE644]'
  id: totrans-2029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE644]'
- en: '*[PRE645]*  *Eigenvalues are 2 and 3\. Raising to the 5th power just raises
    each eigenvalue to the 5th: \(2^5, 3^5\).'
  id: totrans-2030
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE645]*  *特征值为 2 和 3。提高到 5 次幂只是将每个特征值提高到 5 次方：\(2^5, 3^5\)。'
- en: Non-diagonal matrix
  id: totrans-2031
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非对角矩阵
- en: '[PRE646]'
  id: totrans-2032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE646]'
- en: '*[PRE647]*  *Much easier than multiplying \(A\) ten times!'
  id: totrans-2033
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE647]*  *比乘以 \(A\) 十次容易得多！'
- en: NumPy version
  id: totrans-2034
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy 版本
- en: '[PRE648]'
  id: totrans-2035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE648]'
- en: '*[PRE649]*  *4.  Long-term behavior'
  id: totrans-2036
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE649]*  *4.  长期行为'
- en: 'Eigenvalues tell us what happens as \(k \to \infty\):'
  id: totrans-2037
  prefs: []
  type: TYPE_NORMAL
  zh: 特征值告诉我们当 \(k \to \infty\) 时会发生什么：
- en: If \(|\lambda| < 1\) → decay to 0.
  id: totrans-2038
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 \(|\lambda| < 1\) → 衰减到 0。
- en: If \(|\lambda| > 1\) → grows unbounded.
  id: totrans-2039
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 \(|\lambda| > 1\) → 无限增长。
- en: If \(|\lambda| = 1\) → oscillates or stabilizes.
  id: totrans-2040
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 \(|\lambda| = 1\) → 振荡或稳定。
- en: '[PRE650]'
  id: totrans-2041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE650]'
- en: '*[PRE651]*  *Here, the component along eigenvalue 0.5 decays, while eigenvalue
    1.2 grows.****  ***#### Try It Yourself'
  id: totrans-2042
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE651]*  *在这里，沿着特征值 0.5 的分量衰减，而特征值 1.2 增加。****  ***#### 尝试自己操作'
- en: Compute \(A^{50}\) for a diagonal matrix with eigenvalues 0.9 and 1.1\. Which
    component dominates?
  id: totrans-2043
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算具有特征值 0.9 和 1.1 的对角矩阵的 \(A^{50}\)。哪个分量占主导地位？
- en: Take a stochastic (Markov) matrix and compute powers. Do the rows stabilize?
  id: totrans-2044
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对一个随机（马尔可夫）矩阵进行幂运算。行是否稳定？
- en: Experiment with complex eigenvalues (like a rotation) and check if the powers
    oscillate.
  id: totrans-2045
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试复数特征值（如旋转）并检查幂是否振荡。
- en: The Takeaway
  id: totrans-2046
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Matrix powers are simple when using eigenvalues.
  id: totrans-2047
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特征值时，矩阵幂运算很简单。
- en: Long-term dynamics are controlled by eigenvalue magnitudes.
  id: totrans-2048
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长期动力学由特征值幅度控制。
- en: This insight is critical in Markov chains, stability analysis, and dynamical
    systems.****  ***### 66\. Real vs. Complex Spectra (Rotations and Oscillations)
  id: totrans-2049
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种洞察在马尔可夫链、稳定性分析和动力系统中至关重要。****  ***### 66. 实数谱与复数谱（旋转和振荡）
- en: Not all eigenvalues are real. Some matrices, especially those involving rotations,
    have complex eigenvalues. Complex eigenvalues often describe oscillations or rotations
    in systems.
  id: totrans-2050
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有特征值都是实数。一些矩阵，特别是涉及旋转的矩阵，具有复数特征值。复数特征值通常描述系统中的振荡或旋转。
- en: Set Up Your Lab
  id: totrans-2051
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE652]'
  id: totrans-2052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE652]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2053
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Rotation matrix in 2D
  id: totrans-2054
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2D 中的旋转矩阵
- en: 'A 90° rotation matrix:'
  id: totrans-2055
  prefs: []
  type: TYPE_NORMAL
  zh: 90° 旋转矩阵：
- en: \[ R = \begin{bmatrix} 0 & -1 \\ 1 & 0 \end{bmatrix} \]
  id: totrans-2056
  prefs: []
  type: TYPE_NORMAL
  zh: \[ R = \begin{bmatrix} 0 & -1 \\ 1 & 0 \end{bmatrix} \]
- en: '[PRE653]'
  id: totrans-2057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE653]'
- en: '*[PRE654]*  *Result: eigenvalues are \(i\) and \(-i\) (purely imaginary).'
  id: totrans-2058
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE654]*  *结果：特征值为 \(i\) 和 \(-i\)（纯虚数）。'
- en: Verify eigen-equation with complex numbers
  id: totrans-2059
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用复数验证特征方程
- en: '[PRE655]'
  id: totrans-2060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE655]'
- en: '*[PRE656]*  *3.  NumPy version'
  id: totrans-2061
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE656]*  *3.  NumPy 版本'
- en: '[PRE657]'
  id: totrans-2062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE657]'
- en: '*[PRE658]*  *NumPy shows complex eigenvalues with `j` (Python’s imaginary unit).'
  id: totrans-2063
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE658]*  *NumPy 使用 `j`（Python 的虚数单位）显示复数特征值。'
- en: Rotation by arbitrary angle
  id: totrans-2064
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任意角度的旋转
- en: 'General 2D rotation:'
  id: totrans-2065
  prefs: []
  type: TYPE_NORMAL
  zh: 一般 2D 旋转：
- en: \[ R(\theta) = \begin{bmatrix} \cos\theta & -\sin\theta \\ \sin\theta & \cos\theta
    \end{bmatrix} \]
  id: totrans-2066
  prefs: []
  type: TYPE_NORMAL
  zh: \[ R(\theta) = \begin{bmatrix} \cos\theta & -\sin\theta \\ \sin\theta & \cos\theta
    \end{bmatrix} \]
- en: 'Eigenvalues:'
  id: totrans-2067
  prefs: []
  type: TYPE_NORMAL
  zh: 特征值：
- en: \[ \lambda = e^{\pm i\theta} = \cos\theta \pm i\sin\theta \]
  id: totrans-2068
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \lambda = e^{\pm i\theta} = \cos\theta \pm i\sin\theta \]
- en: '[PRE659]'
  id: totrans-2069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE659]'
- en: '*[PRE660]*  *5.  Oscillation insight'
  id: totrans-2070
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE660]*  *5.  振荡洞察'
- en: Complex eigenvalues with \(|\lambda|=1\) → pure oscillation (no growth).
  id: totrans-2071
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复数特征值 \(|\lambda|=1\) → 纯振荡（无增长）。
- en: If \(|\lambda|<1\) → decaying spiral.
  id: totrans-2072
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 \(|\lambda|<1\) → 衰减螺旋。
- en: If \(|\lambda|>1\) → growing spiral.
  id: totrans-2073
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 \(|\lambda|>1\) → 增长螺旋。
- en: 'Example:'
  id: totrans-2074
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE661]'
  id: totrans-2075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE661]'
- en: '*[PRE662]*  *These eigenvalues lie inside the unit circle → spiral decay.*****  ***####
    Try It Yourself'
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE662]*  *这些特征值位于单位圆内 → 螺旋衰减。*****  ***#### 尝试自己操作'
- en: Compute eigenvalues of a 180° rotation. What happens?
  id: totrans-2077
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算旋转 180° 的特征值。会发生什么？
- en: Modify the rotation matrix to include scaling (e.g., multiply by 1.1). Do the
    eigenvalues lie outside the unit circle?
  id: totrans-2078
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改旋转矩阵以包含缩放（例如，乘以 1.1）。特征值是否位于单位圆外？
- en: Plot the trajectory of repeatedly applying a rotation matrix to a vector.
  id: totrans-2079
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制重复应用旋转矩阵到向量的轨迹。
- en: The Takeaway
  id: totrans-2080
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Complex eigenvalues naturally appear in rotations and oscillatory systems.
  id: totrans-2081
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复数特征值自然出现在旋转和振荡系统中。
- en: Their magnitude controls growth or decay; their angle controls oscillation.
  id: totrans-2082
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的幅度控制增长或衰减；它们的角控制振荡。
- en: This is a key link between linear algebra and dynamics in physics and engineering.****  ***###
    67\. Defective Matrices and a Peek at Jordan Form (When Diagonalization Fails)
  id: totrans-2083
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是线性代数与物理学和工程学中的动力学的关键联系。****  ***### 67. 破坏矩阵和一瞥约当形式（当对角化失败时）
- en: Not every matrix has enough independent eigenvectors to be diagonalized. Such
    matrices are called defective. To handle them, mathematicians use the Jordan normal
    form, which extends diagonalization with extra structure.
  id: totrans-2084
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个矩阵都有足够的独立特征向量来进行对角化。这样的矩阵被称为病态矩阵。为了处理它们，数学家使用约当标准形，它通过额外的结构扩展了对角化。
- en: Set Up Your Lab
  id: totrans-2085
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE663]'
  id: totrans-2086
  prefs: []
  type: TYPE_PRE
  zh: '[PRE663]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2087
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码解析'
- en: A defective example
  id: totrans-2088
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个病态例子
- en: \[ A = \begin{bmatrix} 2 & 1 \\ 0 & 2 \end{bmatrix} \]
  id: totrans-2089
  prefs: []
  type: TYPE_NORMAL
  zh: \[ A = \begin{bmatrix} 2 & 1 \\ 0 & 2 \end{bmatrix} \]
- en: '[PRE664]'
  id: totrans-2090
  prefs: []
  type: TYPE_PRE
  zh: '[PRE664]'
- en: '*[PRE665]*  **   Eigenvalue 2 has algebraic multiplicity = 2.'
  id: totrans-2091
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE665]*  **   特征值2的代数重数 = 2。'
- en: Only 1 eigenvector exists → geometric multiplicity = 1.
  id: totrans-2092
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只存在1个特征向量 → 几何重数 = 1。
- en: Thus \(A\) is defective, not diagonalizable.
  id: totrans-2093
  prefs: []
  type: TYPE_NORMAL
  zh: 因此 \(A\) 是病态的，不可对角化。
- en: Attempt diagonalization
  id: totrans-2094
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试对角化
- en: '[PRE666]'
  id: totrans-2095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE666]'
- en: '*[PRE667]*  *You’ll see an error - confirming \(A\) is not diagonalizable.'
  id: totrans-2096
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE667]*  *你会看到一个错误 - 确认 \(A\) 不可对角化。'
- en: Jordan form in SymPy
  id: totrans-2097
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用SymPy的约当形式
- en: '[PRE668]'
  id: totrans-2098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE668]'
- en: '*[PRE669]*  *The Jordan form shows a Jordan block:'
  id: totrans-2099
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE669]*  *约当形式显示一个约当块：'
- en: \[ J = \begin{bmatrix} 2 & 1 \\ 0 & 2 \end{bmatrix} \]
  id: totrans-2100
  prefs: []
  type: TYPE_NORMAL
  zh: \[ J = \begin{bmatrix} 2 & 1 \\ 0 & 2 \end{bmatrix} \]
- en: This block structure represents the failure of diagonalization.
  id: totrans-2101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个块结构代表了对角化的失败。
- en: NumPy perspective
  id: totrans-2102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy视角
- en: 'NumPy doesn’t compute Jordan form, but you can see repeated eigenvalues and
    lack of eigenvectors:'
  id: totrans-2103
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy不计算约当形式，但您可以看到重复的特征值和缺乏特征向量：
- en: '[PRE670]'
  id: totrans-2104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE670]'
- en: '*[PRE671]*  *The eigenvectors matrix has fewer independent columns than expected.'
  id: totrans-2105
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE671]*  *特征向量矩阵的独立列数少于预期。'
- en: Generalized eigenvectors
  id: totrans-2106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 广义特征向量
- en: 'Jordan form introduces generalized eigenvectors, which satisfy:'
  id: totrans-2107
  prefs: []
  type: TYPE_NORMAL
  zh: 约当形式引入了广义特征向量，它们满足：
- en: \[ (A - \lambda I)^k v = 0 \quad \text{for some } k>1 \]
  id: totrans-2108
  prefs: []
  type: TYPE_NORMAL
  zh: \[ (A - \lambda I)^k v = 0 \quad \text{for some } k>1 \]
- en: They “fill the gap” when ordinary eigenvectors are insufficient.****  ***####
    Try It Yourself
  id: totrans-2109
  prefs: []
  type: TYPE_NORMAL
  zh: 当普通特征向量不足时，它们“填补了空白”。****  ***#### 尝试自己操作
- en: Test diagonalizability of
  id: totrans-2110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试对角化的
- en: \[ \begin{bmatrix} 3 & 1 \\ 0 & 3 \end{bmatrix} \]
  id: totrans-2111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ \begin{bmatrix} 3 & 1 \\ 0 & 3 \end{bmatrix} \]
- en: and compare with its Jordan form.
  id: totrans-2112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并将其与它的约当形式进行比较。
- en: Try a 3×3 defective matrix with one Jordan block of size 3.
  id: totrans-2113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试一个3×3的病态矩阵，其中有一个3大小的约当块。
- en: Verify that Jordan blocks still capture the correct eigenvalues.
  id: totrans-2114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证约当块仍然捕获正确的特征值。
- en: The Takeaway
  id: totrans-2115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Defective matrices lack enough eigenvectors for diagonalization.
  id: totrans-2116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 病态矩阵缺乏足够的特征向量来进行对角化。
- en: Jordan form replaces diagonalization with blocks, keeping eigenvalues on the
    diagonal.
  id: totrans-2117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约当形式用块代替对角化，保持特征值在主对角线上。
- en: Understanding Jordan blocks is essential for advanced linear algebra and differential
    equations.****  ***### 68\. Stability and Spectral Radius (Grow, Decay, or Oscillate)
  id: totrans-2118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解约当块对于高级线性代数和微分方程至关重要。****  ***### 68. 稳定性和谱半径（增长、衰减或振荡）
- en: The spectral radius of a matrix \(A\) is defined as
  id: totrans-2119
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵 \(A\) 的谱半径定义为
- en: \[ \rho(A) = \max_i |\lambda_i| \]
  id: totrans-2120
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \rho(A) = \max_i |\lambda_i| \]
- en: 'where \(\lambda_i\) are the eigenvalues. It tells us the long-term behavior
    of repeated applications of \(A\):'
  id: totrans-2121
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(\lambda_i\) 是特征值。它告诉我们 \(A\) 的重复应用的长远行为：
- en: If \(\rho(A) < 1\) → powers of \(A\) tend to 0 (stable/decay).
  id: totrans-2122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 \(\rho(A) < 1\) → \(A\) 的幂趋于0（稳定/衰减）。
- en: If \(\rho(A) = 1\) → powers neither blow up nor vanish (neutral, may oscillate).
  id: totrans-2123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 \(\rho(A) = 1\) → 幂既不会爆炸也不会消失（中性，可能振荡）。
- en: If \(\rho(A) > 1\) → powers diverge (unstable/growth).
  id: totrans-2124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 \(\rho(A) > 1\) → 幂发散（不稳定/增长）。
- en: Set Up Your Lab
  id: totrans-2125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE672]'
  id: totrans-2126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE672]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2127
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码解析'
- en: Stable matrix (\(\rho < 1\))
  id: totrans-2128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 稳定矩阵 (\(\rho < 1\))
- en: '[PRE673]'
  id: totrans-2129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE673]'
- en: '*[PRE674]*  *All entries shrink toward zero.'
  id: totrans-2130
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE674]*  *所有元素都缩小到零。'
- en: Unstable matrix (\(\rho > 1\))
  id: totrans-2131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不稳定矩阵 (\(\rho > 1\))
- en: '[PRE675]'
  id: totrans-2132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE675]'
- en: '*[PRE676]*  *The component along eigenvalue 1.2 grows quickly.'
  id: totrans-2133
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE676]*  *沿着特征值1.2的分量增长迅速。'
- en: Neutral/oscillatory case (\(\rho = 1\))
  id: totrans-2134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中性/振荡情况 (\(\rho = 1\))
- en: '90° rotation matrix:'
  id: totrans-2135
  prefs: []
  type: TYPE_NORMAL
  zh: 90°旋转矩阵：
- en: '[PRE677]'
  id: totrans-2136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE677]'
- en: '*[PRE678]*  *Eigenvalues are ±i, with modulus 1 → pure oscillation.'
  id: totrans-2137
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE678]*  *特征值是 ±i，模数为1 → 纯振荡。'
- en: Spectral radius with SymPy
  id: totrans-2138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用SymPy计算谱半径
- en: '[PRE679]'
  id: totrans-2139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE679]'
- en: '*[PRE680]****  ***#### Try It Yourself'
  id: totrans-2140
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE680]****  ***#### 尝试自己操作'
- en: Build a diagonal matrix with entries 0.8, 1.0, and 1.1\. Predict which direction
    dominates as powers grow.
  id: totrans-2141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个包含0.8、1.0和1.1的元素的对角矩阵。预测随着幂的增长哪个方向占主导地位。
- en: Apply a random matrix repeatedly to a vector. Does it shrink, grow, or oscillate?
  id: totrans-2142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将随机矩阵重复应用于一个向量。它会缩小、增长还是振荡？
- en: Check if a Markov chain transition matrix always has spectral radius 1.
  id: totrans-2143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查马尔可夫链转移矩阵是否总是具有谱半径1。
- en: The Takeaway
  id: totrans-2144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: The spectral radius is the key number that predicts growth, decay, or oscillation.
  id: totrans-2145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谱半径是预测增长、衰减或振荡的关键数字。
- en: Long-term stability in dynamical systems is governed entirely by eigenvalue
    magnitudes.
  id: totrans-2146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态系统的长期稳定性完全由特征值的幅度控制。
- en: This connects linear algebra directly to control theory, Markov chains, and
    differential equations.****  ***### 69\. Markov Chains and Steady States (Probabilities
    as Linear Algebra)
  id: totrans-2147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将线性代数直接与控制理论、马尔可夫链和微分方程联系起来。****  ***### 69\. 马尔可夫链和稳态（概率作为线性代数）
- en: 'A Markov chain is a process that moves between states according to probabilities.
    The transitions are encoded in a stochastic matrix \(P\):'
  id: totrans-2148
  prefs: []
  type: TYPE_NORMAL
  zh: 马尔可夫链是一个根据概率在状态之间移动的过程。转换被编码在一个随机矩阵 \(P\) 中：
- en: Each entry \(p_{ij} \geq 0\)
  id: totrans-2149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个条目 \(p_{ij} \geq 0\)
- en: Each row sums to 1
  id: totrans-2150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每行之和为 1
- en: 'If we start with a probability vector \(v_0\), then after \(k\) steps:'
  id: totrans-2151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从一个概率向量 \(v_0\) 开始，那么经过 \(k\) 步后：
- en: \[ v_k = v_0 P^k \]
  id: totrans-2152
  prefs: []
  type: TYPE_NORMAL
  zh: \[ v_k = v_0 P^k \]
- en: A steady state is a probability vector \(v\) such that \(vP = v\). It corresponds
    to eigenvalue \(\lambda = 1\).
  id: totrans-2153
  prefs: []
  type: TYPE_NORMAL
  zh: 稳态是一个概率向量 \(v\)，使得 \(vP = v\)。它对应于特征值 \(\lambda = 1\)。
- en: Set Up Your Lab
  id: totrans-2154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE681]'
  id: totrans-2155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE681]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2156
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码解析'
- en: Simple two-state chain
  id: totrans-2157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简单的两状态链
- en: '[PRE682]'
  id: totrans-2158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE682]'
- en: '*[PRE683]*  *The distribution stabilizes as \(k\) increases.'
  id: totrans-2159
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE683]*  *随着 \(k\) 的增加，分布趋于稳定。'
- en: Steady state via eigenvector
  id: totrans-2160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过特征向量找到稳态
- en: 'Find eigenvector for eigenvalue 1:'
  id: totrans-2161
  prefs: []
  type: TYPE_NORMAL
  zh: 找到特征值为 1 的特征向量：
- en: '[PRE684]'
  id: totrans-2162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE684]'
- en: '*[PRE685]*  *3.  SymPy exact check'
  id: totrans-2163
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE685]*  *3.  SymPy 精确检查'
- en: '[PRE686]'
  id: totrans-2164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE686]'
- en: '*[PRE687]*  *4.  A 3-state example'
  id: totrans-2165
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE687]*  *4.  一个 3 状态的例子'
- en: '[PRE688]'
  id: totrans-2166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE688]'
- en: '*[PRE689]****  ***#### Try It Yourself'
  id: totrans-2167
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE689]****  ***#### 尝试自己来做'
- en: Create a transition matrix where one state is absorbing (e.g., row = [0,0,1]).
    What happens to the steady state?
  id: totrans-2168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个转换矩阵，其中一个状态是吸收的（例如，行 = [0,0,1]）。稳态会发生什么变化？
- en: Simulate a random walk on 3 states. Does the steady state distribute evenly?
  id: totrans-2169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 3 个状态上模拟一个随机游走。稳态分布是否均匀？
- en: Compare long-run simulation with eigenvector computation.
  id: totrans-2170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较长期模拟与特征向量计算。
- en: The Takeaway
  id: totrans-2171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收
- en: Markov chains evolve by repeated multiplication with a stochastic matrix.
  id: totrans-2172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 马尔可夫链通过与一个随机矩阵的重复乘法来演化。
- en: Steady states are eigenvectors with eigenvalue 1.
  id: totrans-2173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳态是特征值为 1 的特征向量。
- en: This framework powers real applications like PageRank, weather models, and queuing
    systems.****  ***### 70\. Linear Differential Systems (Solutions via Eigen-Decomposition)
  id: totrans-2174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个框架为像 PageRank、天气模型和排队系统等实际应用提供了动力。****  ***### 70\. 线性微分系统（通过特征值分解求解）
- en: 'Linear differential equations often reduce to systems of the form:'
  id: totrans-2175
  prefs: []
  type: TYPE_NORMAL
  zh: 线性微分方程通常可以简化为以下形式的系统：
- en: \[ \frac{d}{dt}x(t) = A x(t) \]
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \frac{d}{dt}x(t) = A x(t) \]
- en: 'where \(A\) is a matrix and \(x(t)\) is a vector of functions. The solution
    is given by the matrix exponential:'
  id: totrans-2177
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(A\) 是一个矩阵，\(x(t)\) 是一个函数向量。解由矩阵指数给出：
- en: \[ x(t) = e^{At} x(0) \]
  id: totrans-2178
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x(t) = e^{At} x(0) \]
- en: If \(A\) is diagonalizable, this becomes simple using eigenvalues and eigenvectors.
  id: totrans-2179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 \(A\) 是可对角化的，那么使用特征值和特征向量可以使问题变得简单。
- en: Set Up Your Lab
  id: totrans-2180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE690]'
  id: totrans-2181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE690]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2182
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码解析'
- en: Simple system with diagonal matrix
  id: totrans-2183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简单的对角矩阵系统
- en: \[ A = \begin{bmatrix} -1 & 0 \\ 0 & 2 \end{bmatrix} \]
  id: totrans-2184
  prefs: []
  type: TYPE_NORMAL
  zh: \[ A = \begin{bmatrix} -1 & 0 \\ 0 & 2 \end{bmatrix} \]
- en: '[PRE691]'
  id: totrans-2185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE691]'
- en: '*[PRE692]*  *Solution:'
  id: totrans-2186
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE692]*  *解：'
- en: \[ x(t) = \begin{bmatrix} e^{-t} & 0 \\ 0 & e^{2t} \end{bmatrix} x(0) \]
  id: totrans-2187
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x(t) = \begin{bmatrix} e^{-t} & 0 \\ 0 & e^{2t} \end{bmatrix} x(0) \]
- en: One component decays, the other grows.
  id: totrans-2188
  prefs: []
  type: TYPE_NORMAL
  zh: 一个分量衰减，另一个增长。
- en: Non-diagonal example
  id: totrans-2189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非对角矩阵示例
- en: '[PRE693]'
  id: totrans-2190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE693]'
- en: '*[PRE694]*  *Here the solution involves exponentials and possibly sines/cosines
    (oscillatory behavior).'
  id: totrans-2191
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE694]*  *这里的解涉及指数和可能的正弦/余弦（振荡行为）。'
- en: Numeric computation with SciPy
  id: totrans-2192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 SciPy 进行数值计算
- en: '[PRE695]'
  id: totrans-2193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE695]'
- en: '*[PRE696]*  *This computes \(e^{At}\) numerically.'
  id: totrans-2194
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE696]*  *这通过数值计算 \(e^{At}\)。'
- en: Simulation of a trajectory
  id: totrans-2195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 轨迹的模拟
- en: '[PRE697]'
  id: totrans-2196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE697]'
- en: '*[PRE698]*  *One coordinate decays, the other explodes with time.****  ***####
    Try It Yourself'
  id: totrans-2197
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE698]*  *一个坐标随时间衰减，另一个随时间爆炸。****  ***#### 尝试自己来做'
- en: Solve the system \(\dot{x} = \begin{bmatrix} 0 & 1 \\ -1 & 0 \end{bmatrix}x\).
    What kind of motion do you see?
  id: totrans-2198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解方程组 \(\dot{x} = \begin{bmatrix} 0 & 1 \\ -1 & 0 \end{bmatrix}x\)。你看到了什么样的运动？
- en: Use SciPy to simulate a system with eigenvalues less than 0\. Does it always
    decay?
  id: totrans-2199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 SciPy 模拟一个具有特征值小于 0 的系统。它总是衰减吗？
- en: Try an unstable system with eigenvalues > 0 and watch how trajectories diverge.
  id: totrans-2200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试一个具有特征值 > 0 的不稳定系统，看看轨迹如何发散。
- en: The Takeaway
  id: totrans-2201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收
- en: Linear systems \(\dot{x} = Ax\) are solved via the matrix exponential.
  id: totrans-2202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性系统 \(\dot{x} = Ax\) 通过矩阵指数求解。
- en: 'Eigenvalues determine stability: negative real parts = stable, positive = unstable,
    imaginary = oscillations.'
  id: totrans-2203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征值确定稳定性：负实部 = 稳定，正 = 不稳定，虚部 = 振荡。
- en: This ties linear algebra directly to differential equations and dynamical systems.*******************************  ***##
    Chapter 8\. Orthogonality, least squars, and QR
  id: totrans-2204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将线性代数直接与微分方程和动力系统联系起来。*******************************  ***## 第 8 章. 正交性，最小二乘法和
    QR
- en: 71\. Inner Products Beyond Dot Product (Custom Notions of Angle)
  id: totrans-2205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 71\. 超出点积的内积（自定义角度概念）
- en: The dot product is the standard inner product in \(\mathbb{R}^n\), but linear
    algebra allows us to define more general inner products that measure length and
    angle in different ways.
  id: totrans-2206
  prefs: []
  type: TYPE_NORMAL
  zh: 点积是 \(\mathbb{R}^n\) 中的标准内积，但线性代数允许我们定义更一般的内积，以不同的方式测量长度和角度。
- en: 'An inner product on a vector space is a function \(\langle u, v \rangle\) that
    satisfies:'
  id: totrans-2207
  prefs: []
  type: TYPE_NORMAL
  zh: 向量空间上的内积是一个满足以下条件的函数 \(\langle u, v \rangle\)：
- en: Linearity in the first argument.
  id: totrans-2208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一参数的线性性。
- en: 'Symmetry: \(\langle u, v \rangle = \langle v, u \rangle\).'
  id: totrans-2209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对称性：\(\langle u, v \rangle = \langle v, u \rangle\)。
- en: 'Positive definiteness: \(\langle v, v \rangle \geq 0\) and equals 0 only if
    \(v=0\).'
  id: totrans-2210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正定性：\(\langle v, v \rangle \geq 0\) 且仅在 \(v=0\) 时等于 0。
- en: Set Up Your Lab
  id: totrans-2211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE699]'
  id: totrans-2212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE699]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2213
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Standard dot product
  id: totrans-2214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标准点积
- en: '[PRE700]'
  id: totrans-2215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE700]'
- en: '*[PRE701]*  *This is the familiar formula: \(1·4 + 2·5 + 3·6 = 32\).'
  id: totrans-2216
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE701]*  *这是熟悉的公式：\(1·4 + 2·5 + 3·6 = 32\)。'
- en: Weighted inner product
  id: totrans-2217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加权内积
- en: 'We can define:'
  id: totrans-2218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义：
- en: \[ \langle u, v \rangle_W = u^T W v \]
  id: totrans-2219
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \langle u, v \rangle_W = u^T W v \]
- en: where \(W\) is a positive definite matrix.
  id: totrans-2220
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(W\) 是一个正定矩阵。
- en: '[PRE702]'
  id: totrans-2221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE702]'
- en: '*[PRE703]*  *Here, some coordinates “count more” than others.'
  id: totrans-2222
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE703]*  *在这里，某些坐标“更重要”于其他坐标。'
- en: Check symmetry and positivity
  id: totrans-2223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查对称性和正定性
- en: '[PRE704]'
  id: totrans-2224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE704]'
- en: '*[PRE705]*  *4.  Angle with weighted inner product'
  id: totrans-2225
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE705]*  *4.  加权内积的角度'
- en: \[ \cos\theta = \frac{\langle u,v \rangle_W}{\|u\|_W \, \|v\|_W} \]
  id: totrans-2226
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \cos\theta = \frac{\langle u,v \rangle_W}{\|u\|_W \, \|v\|_W} \]
- en: '[PRE706]'
  id: totrans-2227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE706]'
- en: '*[PRE707]*  *5.  Custom example: correlation inner product'
  id: totrans-2228
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE707]*  *5.  自定义示例：相关内积'
- en: 'For statistics, an inner product can be defined as covariance or correlation.
    Example with mean-centered vectors:'
  id: totrans-2229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于统计学，内积可以定义为协方差或相关系数。以均值中心化向量为例：
- en: '[PRE708]'
  id: totrans-2230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE708]'
- en: '*[PRE709]*****  ***#### Try It Yourself'
  id: totrans-2231
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE709]*****  ***#### 尝试自己来做'
- en: Define a custom inner product with \(W = \text{diag}(1,10,100)\). How does it
    change angles between vectors?
  id: totrans-2232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个具有 \(W = \text{diag}(1,10,100)\) 的自定义内积。它如何改变向量之间的角度？
- en: 'Verify positivity: compute \(\langle v, v \rangle_W\) for a random vector \(v\).'
  id: totrans-2233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证正定性：计算随机向量 \(v\) 的 \(\langle v, v \rangle_W\)。
- en: Compare dot product vs weighted inner product on the same pair of vectors.
  id: totrans-2234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较同一对向量上的点积与加权内积。
- en: The Takeaway
  id: totrans-2235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Inner products generalize the dot product to new “geometries.”
  id: totrans-2236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内积将点积推广到新的“几何”。
- en: By changing the weight matrix \(W\), you change how lengths and angles are measured.
  id: totrans-2237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过改变权重矩阵 \(W\)，可以改变长度和角度的度量方式。
- en: This flexibility is essential in statistics, optimization, and machine learning.****  ***###
    72\. Orthogonality and Orthonormal Bases (Perpendicular Power)
  id: totrans-2238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种灵活性在统计学、优化和机器学习中至关重要。****  ***### 72\. 正交性和正交基（垂直力量）
- en: 'Two vectors are orthogonal if their inner product is zero:'
  id: totrans-2239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个向量的内积为零，则这两个向量是正交的：
- en: \[ \langle u, v \rangle = 0 \]
  id: totrans-2240
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \langle u, v \rangle = 0 \]
- en: 'If, in addition, each vector has length 1, the set is orthonormal. Orthonormal
    bases are extremely useful because they simplify computations: projections, decompositions,
    and coordinate changes all become clean.'
  id: totrans-2241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果，此外，每个向量长度为 1，则该集合是正交的。正交基非常有用，因为它们简化了计算：投影、分解和坐标变换都变得简单。
- en: Set Up Your Lab
  id: totrans-2242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE710]'
  id: totrans-2243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE710]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2244
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Check orthogonality
  id: totrans-2245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查正交性
- en: '[PRE711]'
  id: totrans-2246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE711]'
- en: '*[PRE712]*  *Since the dot product is 0, they’re orthogonal.'
  id: totrans-2247
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE712]*  *由于点积为 0，它们是正交的。'
- en: Normalizing vectors
  id: totrans-2248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 归一化向量
- en: \[ \hat{u} = \frac{u}{\|u\|} \]
  id: totrans-2249
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \hat{u} = \frac{u}{\|u\|} \]
- en: '[PRE713]'
  id: totrans-2250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE713]'
- en: '*[PRE714]*  *Now both have length 1.'
  id: totrans-2251
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE714]*  *现在它们都有长度 1。'
- en: Form an orthonormal basis
  id: totrans-2252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造一个正交基
- en: '[PRE715]'
  id: totrans-2253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE715]'
- en: '*[PRE716]*  *The result is the identity matrix → perfectly orthonormal.'
  id: totrans-2254
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE716]*  *结果是单位矩阵→完美正交。'
- en: Apply to coordinates
  id: totrans-2255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用到坐标
- en: 'If \(x = [2,3]\), coordinates in the orthonormal basis are:'
  id: totrans-2256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 \(x = [2,3]\)，在正交基中的坐标是：
- en: '[PRE717]'
  id: totrans-2257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE717]'
- en: '*[PRE718]*  *It reconstructs exactly.'
  id: totrans-2258
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE718]*  *它精确重建。'
- en: Random example with QR
  id: totrans-2259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 QR 的随机示例
- en: 'Any set of linearly independent vectors can be orthonormalized (Gram–Schmidt,
    or QR decomposition):'
  id: totrans-2260
  prefs: []
  type: TYPE_NORMAL
  zh: 任何一组线性无关的向量都可以正交化（Gram–Schmidt，或 QR 分解）：
- en: '[PRE719]'
  id: totrans-2261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE719]'
- en: '*[PRE720]*****  ***#### Try It Yourself'
  id: totrans-2262
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE720]*****  ***#### 尝试自己来做'
- en: Create two 3D vectors and check if they’re orthogonal.
  id: totrans-2263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个 3D 向量并检查它们是否正交。
- en: Normalize them to form an orthonormal set.
  id: totrans-2264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们归一化以形成一个正交集。
- en: Use `np.linalg.qr` on a 4×3 random matrix and verify that the columns of \(Q\)
    are orthonormal.
  id: totrans-2265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `np.linalg.qr` 对一个 4×3 的随机矩阵进行 QR 分解，并验证 \(Q\) 的列是正交归一的。
- en: The Takeaway
  id: totrans-2266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Orthogonality means perpendicularity; orthonormality adds unit length.
  id: totrans-2267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正交性意味着垂直；正交归一性增加了单位长度。
- en: Orthonormal bases simplify coordinate systems, making inner products and projections
    easy.
  id: totrans-2268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正交归一基简化了坐标系，使得内积和投影变得容易。
- en: QR decomposition is the practical tool to generate orthonormal bases in higher
    dimensions.****  ***### 73\. Gram–Schmidt Process (Constructing Orthonormal Bases)
  id: totrans-2269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QR 分解是生成高维正交基的实用工具。****  ***### 73. Gram–Schmidt 过程（构造正交归一基）
- en: The Gram–Schmidt process takes a set of linearly independent vectors and turns
    them into an orthonormal basis. This is crucial for working with subspaces, projections,
    and numerical stability.
  id: totrans-2270
  prefs: []
  type: TYPE_NORMAL
  zh: Gram–Schmidt 过程将一组线性无关的向量转换成正交归一基。这对于处理子空间、投影和数值稳定性至关重要。
- en: 'Given vectors \(v_1, v_2, \dots, v_n\):'
  id: totrans-2271
  prefs: []
  type: TYPE_NORMAL
  zh: 给定向量 \(v_1, v_2, \dots, v_n\)：
- en: Set \(u_1 = v_1\).
  id: totrans-2272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设 \(u_1 = v_1\)。
- en: 'Subtract projections to make each new vector orthogonal to the earlier ones:'
  id: totrans-2273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减去投影，使每个新向量与之前的向量正交：
- en: \[ u_k = v_k - \sum_{j=1}^{k-1} \frac{\langle v_k, u_j \rangle}{\langle u_j,
    u_j \rangle} u_j \]
  id: totrans-2274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ u_k = v_k - \sum_{j=1}^{k-1} \frac{\langle v_k, u_j \rangle}{\langle u_j,
    u_j \rangle} u_j \]
- en: 'Normalize:'
  id: totrans-2275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 归一化：
- en: \[ e_k = \frac{u_k}{\|u_k\|} \]
  id: totrans-2276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ e_k = \frac{u_k}{\|u_k\|} \]
- en: The set \(\{e_1, e_2, \dots, e_n\}\) is orthonormal.
  id: totrans-2277
  prefs: []
  type: TYPE_NORMAL
  zh: 集合 \(\{e_1, e_2, \dots, e_n\}\) 是正交归一的。
- en: Set Up Your Lab
  id: totrans-2278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE721]'
  id: totrans-2279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE721]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2280
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Define vectors
  id: totrans-2281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义向量
- en: '[PRE722]'
  id: totrans-2282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE722]'
- en: '*2.  Implement Gram–Schmidt'
  id: totrans-2283
  prefs: []
  type: TYPE_NORMAL
  zh: '*2.  实现 Gram–Schmidt'
- en: '[PRE723]'
  id: totrans-2284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE723]'
- en: '*[PRE724]*  *3.  Compare with NumPy QR'
  id: totrans-2285
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE724]*  *3.  与 NumPy QR 进行比较'
- en: '[PRE725]'
  id: totrans-2286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE725]'
- en: '*[PRE726]*  *Both methods give orthonormal bases.'
  id: totrans-2287
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE726]*  *两种方法都给出正交归一基。'
- en: 'Application: projection'
  id: totrans-2288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用：投影
- en: 'To project a vector \(x\) onto the span of \(V\):'
  id: totrans-2289
  prefs: []
  type: TYPE_NORMAL
  zh: 要将向量 \(x\) 投影到 \(V\) 的张成上：
- en: '[PRE727]'
  id: totrans-2290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE727]'
- en: '*[PRE728]****  ***#### Try It Yourself'
  id: totrans-2291
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE728]****  ***#### 尝试自己操作'
- en: Run Gram–Schmidt on two vectors in 2D. Compare with just normalizing and checking
    orthogonality.
  id: totrans-2292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 2D 中对两个向量运行 Gram–Schmidt，并与仅归一化和检查正交性进行比较。
- en: Replace one vector with a linear combination of others. What happens?
  id: totrans-2293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用其他向量的线性组合替换一个向量。会发生什么？
- en: Use QR decomposition on a 4×3 random matrix and compare with Gram–Schmidt.
  id: totrans-2294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个 4×3 的随机矩阵上使用 QR 分解，并与 Gram–Schmidt 方法进行比较。
- en: The Takeaway
  id: totrans-2295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Gram–Schmidt converts arbitrary independent vectors into an orthonormal basis.
  id: totrans-2296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gram–Schmidt 将任意独立向量转换成正交归一基。
- en: Orthonormal bases simplify projections, decompositions, and computations.
  id: totrans-2297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正交归一基简化了投影、分解和计算。
- en: In practice, QR decomposition is often used as a numerically stable implementation.****  ***###
    74\. Orthogonal Projections onto Subspaces (Closest Point Principle)
  id: totrans-2298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实践中，QR 分解通常用作数值稳定的实现。****  ***### 74. 在子空间上的正交投影（最近点原理）
- en: Given a subspace spanned by vectors, the orthogonal projection of a vector \(x\)
    onto the subspace is the point in the subspace that is closest to \(x\). This
    is a cornerstone idea in least squares, data fitting, and signal processing.
  id: totrans-2299
  prefs: []
  type: TYPE_NORMAL
  zh: 给定由向量张成的子空间，向量 \(x\) 在子空间上的正交投影是子空间中离 \(x\) 最近的点。这是最小二乘法、数据拟合和信号处理中的基石思想。
- en: Formula Recap
  id: totrans-2300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 公式回顾
- en: 'If \(Q\) is a matrix with orthonormal columns spanning the subspace, the projection
    of \(x\) is:'
  id: totrans-2301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 \(Q\) 是一个具有正交归一列张成子空间的矩阵，则 \(x\) 的投影是：
- en: \[ \text{proj}(x) = Q Q^T x \]
  id: totrans-2302
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \text{proj}(x) = Q Q^T x \]
- en: Set Up Your Lab
  id: totrans-2303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE729]'
  id: totrans-2304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE729]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2305
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Projection onto a line (1D subspace)
  id: totrans-2306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 投影到一条线（一维子空间）
- en: Suppose the subspace is spanned by \(u = [1,2]\).
  id: totrans-2307
  prefs: []
  type: TYPE_NORMAL
  zh: 假设子空间由 \(u = [1,2]\) 张成。
- en: '[PRE730]'
  id: totrans-2308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE730]'
- en: '*[PRE731]*  *This gives the closest point to \(x\) along the line spanned by
    \(u\).'
  id: totrans-2309
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE731]*  *这给出了沿由 \(u\) 张成的线的 \(x\) 的最近点。'
- en: Projection onto a plane (2D subspace in 3D)
  id: totrans-2310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 投影到平面（三维中的二维子空间）
- en: '[PRE732]'
  id: totrans-2311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE732]'
- en: '*[PRE733]*  *Result drops the z-component → projection onto the plane.'
  id: totrans-2312
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE733]*  *结果丢弃 z 分量 → 投影到平面上。'
- en: General projection using QR
  id: totrans-2313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 QR 进行一般投影
- en: '[PRE734]'
  id: totrans-2314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE734]'
- en: '*[PRE735]*  *4.  Visualization (2D case)'
  id: totrans-2315
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE735]*  *4.  可视化（二维情况）'
- en: '[PRE736]'
  id: totrans-2316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE736]'
- en: '*![](../Images/b692f40e9b624b568a3feb20a645f0dc.png)****  ***#### Try It Yourself'
  id: totrans-2317
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/b692f40e9b624b568a3feb20a645f0dc.png)****  ***#### 尝试自己操作'
- en: Project a vector onto the line spanned by \([2,1]\).
  id: totrans-2318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将向量投影到由 \([2,1]\) 张成的线上。
- en: Project \([1,2,3]\) onto the plane spanned by \([1,0,1]\) and \([0,1,1]\).
  id: totrans-2319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 \([1,2,3]\) 投影到由 \([1,0,1]\) 和 \([0,1,1]\) 张成的平面上。
- en: Compare projection via formula \(Q Q^T x\) with manually solving least squares.
  id: totrans-2320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较通过公式 \(Q Q^T x\) 进行投影与手动求解最小二乘法。
- en: The Takeaway
  id: totrans-2321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Orthogonal projection finds the closest point in a subspace.
  id: totrans-2322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正交投影找到子空间中的最近点。
- en: Formula \(Q Q^T x\) works perfectly when \(Q\) has orthonormal columns.
  id: totrans-2323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公式 \(Q Q^T x\) 当 \(Q\) 有正交归一列时工作得很好。
- en: Projections are the foundation of least squares, PCA, and many geometric algorithms.****  ***###
    75\. Least-Squares Problems (Fit When Exact Solve Is Impossible)
  id: totrans-2324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投影是最小二乘、主成分分析以及许多几何算法的基础。****  ***### 75\. 最小二乘问题（当精确求解不可能时的拟合）
- en: 'Sometimes a system of equations \(Ax = b\) has no exact solution - usually
    because it’s overdetermined (more equations than unknowns). In this case, we look
    for an approximate solution \(x^*\) that minimizes the error:'
  id: totrans-2325
  prefs: []
  type: TYPE_NORMAL
  zh: 有时方程组 \(Ax = b\) 没有精确解 - 通常是因为它是超定的（方程多于未知数）。在这种情况下，我们寻找一个近似解 \(x^*\)，它最小化误差：
- en: \[ x^* = \arg\min_x \|Ax - b\|^2 \]
  id: totrans-2326
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x^* = \arg\min_x \|Ax - b\|^2 \]
- en: This is the least-squares solution, which geometrically is the projection of
    \(b\) onto the column space of \(A\).
  id: totrans-2327
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最小二乘解，从几何上讲是 \(b\) 投影到 \(A\) 的列空间。
- en: Set Up Your Lab
  id: totrans-2328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE737]'
  id: totrans-2329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE737]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2330
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Overdetermined system
  id: totrans-2331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 超定系统
- en: '3 equations, 2 unknowns:'
  id: totrans-2332
  prefs: []
  type: TYPE_NORMAL
  zh: 3 个方程，2 个未知数：
- en: '[PRE738]'
  id: totrans-2333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE738]'
- en: '*2.  Solve least squares with NumPy'
  id: totrans-2334
  prefs: []
  type: TYPE_NORMAL
  zh: '*2.  使用 NumPy 求解最小二乘'
- en: '[PRE739]'
  id: totrans-2335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE739]'
- en: '*[PRE740]*  *3.  Compare with normal equations'
  id: totrans-2336
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE740]*  *3.  与正规方程比较'
- en: \[ A^T A x = A^T b \]
  id: totrans-2337
  prefs: []
  type: TYPE_NORMAL
  zh: \[ A^T A x = A^T b \]
- en: '[PRE741]'
  id: totrans-2338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE741]'
- en: '*[PRE742]*  *4.  Geometric picture'
  id: totrans-2339
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE742]*  *4.  几何图示'
- en: 'The least-squares solution projects \(b\) onto the column space of \(A\):'
  id: totrans-2340
  prefs: []
  type: TYPE_NORMAL
  zh: 最小二乘解将 \(b\) 投影到 \(A\) 的列空间：
- en: '[PRE743]'
  id: totrans-2341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE743]'
- en: '*[PRE744]*  *The error vector is orthogonal to the column space.'
  id: totrans-2342
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE744]*  *错误向量与列空间正交。'
- en: Verify orthogonality condition
  id: totrans-2343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证正交条件
- en: \[ A^T (b - Ax^*) = 0 \]
  id: totrans-2344
  prefs: []
  type: TYPE_NORMAL
  zh: \[ A^T (b - Ax^*) = 0 \]
- en: '[PRE745]'
  id: totrans-2345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE745]'
- en: '*[PRE746]*  *The result should be (close to) zero.*****  ***#### Try It Yourself'
  id: totrans-2346
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE746]*  *结果应该是（接近）零。*****  ***#### 尝试自己来做'
- en: Create a taller \(A\) (say 5×2) with random numbers and solve least squares
    for a random \(b\).
  id: totrans-2347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个更长的 \(A\)（例如 5×2）并用随机数求解最小二乘问题 \(b\)。
- en: Compare the residual from `np.linalg.lstsq` with geometric intuition (projection).
  id: totrans-2348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `np.linalg.lstsq` 的残差与几何直觉（投影）进行比较。
- en: Modify \(b\) so that the system has an exact solution. Check if least squares
    gives it exactly.
  id: totrans-2349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 \(b\) 使得系统有精确解。检查最小二乘是否给出精确解。
- en: The Takeaway
  id: totrans-2350
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Least-squares finds the best-fit solution when no exact solution exists.
  id: totrans-2351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当不存在精确解时，最小二乘法找到最佳拟合解。
- en: It works by projecting \(b\) onto the column space of \(A\).
  id: totrans-2352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过将 \(b\) 投影到 \(A\) 的列空间中来工作。
- en: This principle underlies regression, curve fitting, and countless applications
    in data science.****  ***### 76\. Normal Equations and Geometry of Residuals (Why
    It Works)
  id: totrans-2353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个原理是回归、曲线拟合和数据科学中无数应用的基础。****  ***### 76\. 正规方程和残差的几何（为什么它有效）
- en: 'The least-squares solution can be found by solving the normal equations:'
  id: totrans-2354
  prefs: []
  type: TYPE_NORMAL
  zh: 最小二乘解可以通过求解正规方程找到：
- en: \[ A^T A x = A^T b \]
  id: totrans-2355
  prefs: []
  type: TYPE_NORMAL
  zh: \[ A^T A x = A^T b \]
- en: This comes from the condition that the residual vector
  id: totrans-2356
  prefs: []
  type: TYPE_NORMAL
  zh: 这来自于残差向量
- en: \[ r = b - Ax \]
  id: totrans-2357
  prefs: []
  type: TYPE_NORMAL
  zh: \[ r = b - Ax \]
- en: is orthogonal to the column space of \(A\).
  id: totrans-2358
  prefs: []
  type: TYPE_NORMAL
  zh: 与 \(A\) 的列空间正交。
- en: Set Up Your Lab
  id: totrans-2359
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE747]'
  id: totrans-2360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE747]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2361
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Build an overdetermined system
  id: totrans-2362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个超定系统
- en: '[PRE748]'
  id: totrans-2363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE748]'
- en: '*2.  Solve least squares via normal equations'
  id: totrans-2364
  prefs: []
  type: TYPE_NORMAL
  zh: '*2.  通过正规方程求解最小二乘'
- en: '[PRE749]'
  id: totrans-2365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE749]'
- en: '*[PRE750]*  *3.  Compute residual and check orthogonality'
  id: totrans-2366
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE750]*  *3.  计算残差并检查正交性'
- en: '[PRE751]'
  id: totrans-2367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE751]'
- en: '*[PRE752]*  *This verifies the residual is perpendicular to the column space
    of \(A\).'
  id: totrans-2368
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE752]*  *这验证了残差与 \(A\) 的列空间正交。'
- en: Compare with NumPy’s least squares solver
  id: totrans-2369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与 NumPy 的最小二乘求解器比较
- en: '[PRE753]'
  id: totrans-2370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE753]'
- en: '*[PRE754]*  *The solutions should match (within numerical precision).'
  id: totrans-2371
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE754]*  *解应该匹配（在数值精度范围内）。'
- en: Geometric picture
  id: totrans-2372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几何图示
- en: \(b\) is a point in \(\mathbb{R}^3\).
  id: totrans-2373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(b\) 是 \(\mathbb{R}^3\) 中的一个点。
- en: \(Ax\) is restricted to lie in the 2D column space of \(A\).
  id: totrans-2374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(Ax\) 被限制在 \(A\) 的 2D 列空间中。
- en: The least-squares solution picks the \(Ax\) closest to \(b\).
  id: totrans-2375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小二乘解选择最接近 \(b\) 的 \(Ax\)。
- en: The error vector \(r = b - Ax^*\) is orthogonal to the subspace.
  id: totrans-2376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误向量 \(r = b - Ax^*\) 与子空间正交。
- en: '[PRE755]'
  id: totrans-2377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE755]'
- en: '*[PRE756]*****  ***#### Try It Yourself'
  id: totrans-2378
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE756]*****  ***#### 尝试自己来做'
- en: Change \(b\) to \([1,1,1]\). Solve again and check the residual.
  id: totrans-2379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 \(b\) 改为 \([1,1,1]\)。再次求解并检查残差。
- en: Use a random tall \(A\) (say 6×2) and verify that the residual is always orthogonal.
  id: totrans-2380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用随机的长 \(A\)（例如 6×2）并验证残差始终正交。
- en: Compute \(\|r\|\) and see how it changes when you change \(b\).
  id: totrans-2381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 \(\|r\|\) 并观察当改变 \(b\) 时它如何变化。
- en: The Takeaway
  id: totrans-2382
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Least squares works by making the residual orthogonal to the column space.
  id: totrans-2383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小二乘法通过使残差与列空间正交来工作。
- en: Normal equations are the algebraic way to encode this condition.
  id: totrans-2384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正规方程是编码这个条件的代数方法。
- en: This orthogonality principle is the geometric heart of least-squares fitting.****  ***###
    77\. QR Factorization (Stable Least Squares via Orthogonality)
  id: totrans-2385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个正交原理是最小二乘拟合的几何核心。****  ***### 77. QR分解（通过正交性实现稳定的最小二乘）
- en: 'While normal equations solve least squares, they can be numerically unstable
    if \(A^T A\) is ill-conditioned. A more stable method uses QR factorization:'
  id: totrans-2386
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然正则方程可以解决最小二乘问题，但如果 \(A^T A\) 条件不良，它们在数值上可能是不稳定的。一种更稳定的方法是使用QR分解：
- en: \[ A = Q R \]
  id: totrans-2387
  prefs: []
  type: TYPE_NORMAL
  zh: \[ A = Q R \]
- en: '\(Q\): matrix with orthonormal columns'
  id: totrans-2388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(Q\)：具有正交列的矩阵
- en: '\(R\): upper triangular matrix'
  id: totrans-2389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(R\)：上三角矩阵
- en: 'Then the least-squares problem reduces to solving:'
  id: totrans-2390
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，最小二乘问题简化为求解：
- en: \[ Rx = Q^T b \]
  id: totrans-2391
  prefs: []
  type: TYPE_NORMAL
  zh: \[ Rx = Q^T b \]
- en: Set Up Your Lab
  id: totrans-2392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE757]'
  id: totrans-2393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE757]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2394
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Overdetermined system
  id: totrans-2395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 超定系统
- en: '[PRE758]'
  id: totrans-2396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE758]'
- en: '*2.  QR factorization'
  id: totrans-2397
  prefs: []
  type: TYPE_NORMAL
  zh: '*2.  QR分解'
- en: '[PRE759]'
  id: totrans-2398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE759]'
- en: '*[PRE760]*  *3.  Solve least squares using QR'
  id: totrans-2399
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE760]*  *3.  使用QR解决最小二乘问题'
- en: '[PRE761]'
  id: totrans-2400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE761]'
- en: '*[PRE762]*  *4.  Compare with NumPy’s `lstsq`'
  id: totrans-2401
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE762]*  *4.  与NumPy的`lstsq`比较'
- en: '[PRE763]'
  id: totrans-2402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE763]'
- en: '*[PRE764]*  *The answers should match closely.'
  id: totrans-2403
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE764]*  *答案应该非常接近。'
- en: Residual check
  id: totrans-2404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 残差检查
- en: '[PRE765]'
  id: totrans-2405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE765]'
- en: '*[PRE766]*  *Residual is orthogonal to the column space, confirming correctness.*****  ***####
    Try It Yourself'
  id: totrans-2406
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE766]*  *残差与列空间正交，确认正确性。*****  ***#### 尝试自己操作'
- en: Solve least squares for a 5×2 random matrix using both normal equations and
    QR. Compare results.
  id: totrans-2407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正则方程和QR分别对5×2的随机矩阵求解最小二乘问题。比较结果。
- en: Check stability by making columns of \(A\) nearly dependent - see if QR behaves
    better than normal equations.
  id: totrans-2408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使 \(A\) 的列几乎相互依赖来检查稳定性 - 看看QR是否比正则方程表现得更好。
- en: Compute projection of \(b\) using \(Q Q^T b\) and confirm it equals \(A x^*\).
  id: totrans-2409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 \(Q Q^T b\) 计算向量 \(b\) 的投影，并确认它等于 \(A x^*\)。
- en: The Takeaway
  id: totrans-2410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸取的经验
- en: QR factorization provides a numerically stable way to solve least squares.
  id: totrans-2411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QR分解提供了一种数值上稳定地解决最小二乘问题的方法。
- en: It avoids the instability of normal equations.
  id: totrans-2412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它避免了正则方程的不稳定性。
- en: In practice, modern solvers (like NumPy’s `lstsq`) rely on QR or SVD under the
    hood.****  ***### 78\. Orthogonal Matrices (Length-Preserving Transforms)
  id: totrans-2413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实践中，现代求解器（如NumPy的`lstsq`）在底层依赖于QR或SVD。****  ***### 78. 正交矩阵（长度保持变换）
- en: 'An orthogonal matrix \(Q\) is a square matrix whose columns (and rows) are
    orthonormal vectors. Formally:'
  id: totrans-2414
  prefs: []
  type: TYPE_NORMAL
  zh: 正交矩阵 \(Q\) 是一个方阵，其列（和行）是正交向量。形式上：
- en: \[ Q^T Q = Q Q^T = I \]
  id: totrans-2415
  prefs: []
  type: TYPE_NORMAL
  zh: \[ Q^T Q = Q Q^T = I \]
- en: 'Key properties:'
  id: totrans-2416
  prefs: []
  type: TYPE_NORMAL
  zh: 关键特性：
- en: 'Preserves lengths: \(\|Qx\| = \|x\|\)'
  id: totrans-2417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持长度：\(\|Qx\| = \|x\|\)
- en: 'Preserves dot products: \(\langle Qx, Qy \rangle = \langle x, y \rangle\)'
  id: totrans-2418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持点积：\(\langle Qx, Qy \rangle = \langle x, y \rangle\)
- en: Determinant is either \(+1\) (rotation) or \(-1\) (reflection)
  id: totrans-2419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约束条件是 \(+1\)（旋转）或 \(-1\)（反射）
- en: Set Up Your Lab
  id: totrans-2420
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE767]'
  id: totrans-2421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE767]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2422
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Construct a simple orthogonal matrix
  id: totrans-2423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造一个简单的正交矩阵
- en: '90° rotation in 2D:'
  id: totrans-2424
  prefs: []
  type: TYPE_NORMAL
  zh: 2D中的90°旋转：
- en: '[PRE768]'
  id: totrans-2425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE768]'
- en: '*[PRE769]*  *Result = identity → confirms orthogonality.'
  id: totrans-2426
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE769]*  *结果为恒等矩阵 → 确认正交性。'
- en: Check length preservation
  id: totrans-2427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查长度保持
- en: '[PRE770]'
  id: totrans-2428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE770]'
- en: '*[PRE771]*  *Both lengths match.'
  id: totrans-2429
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE771]*  *两个长度匹配。'
- en: Check dot product preservation
  id: totrans-2430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查点积保持
- en: '[PRE772]'
  id: totrans-2431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE772]'
- en: '*[PRE773]*  *Dot product is preserved.'
  id: totrans-2432
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE773]*  *点积保持。'
- en: Reflection matrix
  id: totrans-2433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反射矩阵
- en: 'Reflection about the x-axis:'
  id: totrans-2434
  prefs: []
  type: TYPE_NORMAL
  zh: 关于x轴的反射：
- en: '[PRE774]'
  id: totrans-2435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE774]'
- en: '*[PRE775]*  *Determinant = -1 → reflection.'
  id: totrans-2436
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE775]*  *行列式 = -1 → 反射。'
- en: Random orthogonal matrix via QR
  id: totrans-2437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过QR得到的随机正交矩阵
- en: '[PRE776]'
  id: totrans-2438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE776]'
- en: '*[PRE777]*****  ***#### Try It Yourself'
  id: totrans-2439
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE777]*****  ***#### 尝试自己操作'
- en: Build a 2D rotation matrix for 45°. Verify it’s orthogonal.
  id: totrans-2440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个45°的二维旋转矩阵。验证它是正交的。
- en: Check whether scaling matrices (e.g., \(\text{diag}(2,1)\)) are orthogonal.
    Why or why not?
  id: totrans-2441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查缩放矩阵（例如，\(\text{diag}(2,1)\)）是否正交。为什么或为什么不？
- en: Generate a random orthogonal matrix with `np.linalg.qr` and test its determinant.
  id: totrans-2442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `np.linalg.qr` 生成一个随机的正交矩阵并测试其行列式。
- en: The Takeaway
  id: totrans-2443
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸取的经验
- en: 'Orthogonal matrices are rigid motions: they rotate or reflect without distorting
    lengths or angles.'
  id: totrans-2444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正交矩阵是刚性运动：它们旋转或反射而不扭曲长度或角度。
- en: They play a key role in numerical stability, geometry, and physics.
  id: totrans-2445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在数值稳定性、几何和物理学中起着关键作用。
- en: Every orthonormal basis corresponds to an orthogonal matrix.****  ***### 79\.
    Fourier Viewpoint (Expanding in Orthogonal Waves)
  id: totrans-2446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个正交基对应一个正交矩阵。****  ***### 79. 傅里叶视角（在正交波中展开）
- en: 'The Fourier viewpoint treats functions or signals as combinations of orthogonal
    waves (sines and cosines). This is just linear algebra: sine and cosine functions
    form an orthogonal basis, and any signal can be expressed as a linear combination
    of them.'
  id: totrans-2447
  prefs: []
  type: TYPE_NORMAL
  zh: 傅里叶视角将函数或信号视为正交波（正弦和余弦）的组合。这仅仅是线性代数：正弦和余弦函数构成一个正交基，任何信号都可以表示为它们的线性组合。
- en: Formula Recap
  id: totrans-2448
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 公式回顾
- en: 'For a discrete signal \(x\), the Discrete Fourier Transform (DFT) is:'
  id: totrans-2449
  prefs: []
  type: TYPE_NORMAL
  zh: 对于离散信号 \(x\)，离散傅里叶变换（DFT）是：
- en: \[ X_k = \sum_{n=0}^{N-1} x_n e^{-2\pi i kn / N}, \quad k=0,\dots,N-1 \]
  id: totrans-2450
  prefs: []
  type: TYPE_NORMAL
  zh: \[ X_k = \sum_{n=0}^{N-1} x_n e^{-2\pi i kn / N}, \quad k=0,\dots,N-1 \]
- en: The inverse DFT reconstructs the signal. Orthogonality of complex exponentials
    makes this work.
  id: totrans-2451
  prefs: []
  type: TYPE_NORMAL
  zh: 逆离散傅里叶变换重建信号。复指数的正交性使得这一点成立。
- en: Set Up Your Lab
  id: totrans-2452
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE778]'
  id: totrans-2453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE778]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2454
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Build a simple signal
  id: totrans-2455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个简单的信号
- en: '[PRE779]'
  id: totrans-2456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE779]'
- en: '*![](../Images/59c7e2adf8a52cda633e1c3496675a81.png)*  *2.  Compute Fourier
    transform (DFT)'
  id: totrans-2457
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/59c7e2adf8a52cda633e1c3496675a81.png)*  *2.  计算傅里叶变换（DFT）'
- en: '[PRE780]'
  id: totrans-2458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE780]'
- en: '*![](../Images/14b51bb53b253c76a4c74d57e671594f.png)*  *Peaks appear at 3Hz
    and 5Hz → the frequencies of the original signal.'
  id: totrans-2459
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/14b51bb53b253c76a4c74d57e671594f.png)*  *峰值出现在 3Hz 和 5Hz → 原始信号的频率。'
- en: Reconstruct signal using inverse FFT
  id: totrans-2460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用逆傅里叶变换重建信号
- en: '[PRE781]'
  id: totrans-2461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE781]'
- en: '*[PRE782]*  *Error is near zero → perfect reconstruction.'
  id: totrans-2462
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE782]*  *误差接近零 → 完美重建。'
- en: Orthogonality check of sinusoids
  id: totrans-2463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正交性检查正弦波
- en: '[PRE783]'
  id: totrans-2464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE783]'
- en: '*[PRE784]*  *The result is ≈ 0 → confirms orthogonality.****  ***#### Try It
    Yourself'
  id: totrans-2465
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE784]*  *结果是 ≈ 0 → 确认正交性。****  ***#### 尝试自己操作'
- en: Change the frequencies to 7Hz and 9Hz. Do the Fourier peaks move accordingly?
  id: totrans-2466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将频率改为 7Hz 和 9Hz。傅里叶峰值是否相应移动？
- en: Mix in some noise and check how the spectrum looks.
  id: totrans-2467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 混入一些噪声并检查频谱看起来如何。
- en: Try cosine signals instead of sine. Do you still see orthogonality?
  id: totrans-2468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用余弦信号而不是正弦信号。你是否仍然看到正交性？
- en: The Takeaway
  id: totrans-2469
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Fourier analysis = linear algebra with orthogonal sinusoidal basis functions.
  id: totrans-2470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 傅里叶分析 = 线性代数与正交正弦波基函数。
- en: Any signal can be decomposed into orthogonal waves.
  id: totrans-2471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何信号都可以分解为正交波。
- en: This orthogonal viewpoint powers audio, image compression, and signal processing.****  ***###
    80\. Polynomial and Multifeature Least Squares (Fitting More Flexibly)
  id: totrans-2472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种正交观点推动了音频、图像压缩和信号处理。****  ***### 80\. 多项式和多特征最小二乘（更灵活的拟合）
- en: Least squares isn’t limited to straight lines. By adding polynomial or multiple
    features, we can fit curves and capture more complex relationships. This is the
    foundation of regression models in data science.
  id: totrans-2473
  prefs: []
  type: TYPE_NORMAL
  zh: 最小二乘法不仅限于直线。通过添加多项式或多个特征，我们可以拟合曲线并捕捉更复杂的关系。这是数据科学中回归模型的基础。
- en: Formula Recap
  id: totrans-2474
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 公式回顾
- en: 'Given data \((x_i, y_i)\), we build a design matrix \(A\):'
  id: totrans-2475
  prefs: []
  type: TYPE_NORMAL
  zh: 给定数据 \((x_i, y_i)\)，我们构建设计矩阵 \(A\)：
- en: 'For polynomial fit of degree \(d\):'
  id: totrans-2476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 \(d\) 次方的多项式拟合：
- en: \[ A = \begin{bmatrix} 1 & x_1 & x_1^2 & \dots & x_1^d \\ 1 & x_2 & x_2^2 &
    \dots & x_2^d \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ 1 & x_n & x_n^2
    & \dots & x_n^d \end{bmatrix} \]
  id: totrans-2477
  prefs: []
  type: TYPE_NORMAL
  zh: \[ A = \begin{bmatrix} 1 & x_1 & x_1^2 & \dots & x_1^d \\ 1 & x_2 & x_2^2 &
    \dots & x_2^d \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ 1 & x_n & x_n^2
    & \dots & x_n^d \end{bmatrix} \]
- en: 'Then solve least squares:'
  id: totrans-2478
  prefs: []
  type: TYPE_NORMAL
  zh: 然后求解最小二乘法：
- en: \[ \hat{c} = \arg\min_c \|Ac - y\|^2 \]
  id: totrans-2479
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \hat{c} = \arg\min_c \|Ac - y\|^2 \]
- en: Set Up Your Lab
  id: totrans-2480
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE785]'
  id: totrans-2481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE785]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2482
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Generate noisy quadratic data
  id: totrans-2483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成带噪声的二次数据
- en: '[PRE786]'
  id: totrans-2484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE786]'
- en: '*![](../Images/d62c3c2981487234fb5812edfd85d7cf.png)*  *2.  Build polynomial
    design matrix (degree 2)'
  id: totrans-2485
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/d62c3c2981487234fb5812edfd85d7cf.png)*  *2.  构建多项式设计矩阵（度数为 2）'
- en: '[PRE787]'
  id: totrans-2486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE787]'
- en: '*[PRE788]*  *3.  Plot fitted polynomial'
  id: totrans-2487
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE788]*  *3.  绘制拟合多项式'
- en: '[PRE789]'
  id: totrans-2488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE789]'
- en: '*![](../Images/e1e010ef63b6e1c56ff13d0f27df2c89.png)*  *4.  Higher-degree fit
    (overfitting demonstration)'
  id: totrans-2489
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/e1e010ef63b6e1c56ff13d0f27df2c89.png)*  *4.  高阶拟合（过拟合演示）'
- en: '[PRE790]'
  id: totrans-2490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE790]'
- en: '*![](../Images/38287a6c0a2feb9d3f00259e90085109.png)*  *5.  Multifeature regression
    example'
  id: totrans-2491
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/38287a6c0a2feb9d3f00259e90085109.png)*  *5.  多特征回归示例'
- en: 'Suppose we predict \(y\) from features \([x, x^2, \sin(x)]\):'
  id: totrans-2492
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们根据特征 \([x, x^2, \sin(x)]\) 预测 \(y\)：
- en: '[PRE791]'
  id: totrans-2493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE791]'
- en: '*[PRE792]*****  ***#### Try It Yourself'
  id: totrans-2494
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE792]*****  ***#### 尝试自己操作'
- en: Fit degree 3, 4, 5 polynomials to the same data. Watch how the curve changes.
  id: totrans-2495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 3 次方、4 次方、5 次方的多项式拟合到相同的数据上。观察曲线如何变化。
- en: Add features like \(\cos(x)\) or \(\exp(x)\) - does the fit improve?
  id: totrans-2496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加特征如 \(\cos(x)\) 或 \(\exp(x)\) - 拟合是否改善？
- en: Compare training error (fit to noisy data) vs error on new test points.
  id: totrans-2497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较训练误差（拟合噪声数据）与新的测试点上的误差。
- en: The Takeaway
  id: totrans-2498
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Least squares can fit polynomials and arbitrary feature combinations.
  id: totrans-2499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小二乘法可以拟合多项式和任意特征组合。
- en: The design matrix encodes how input variables transform into features.
  id: totrans-2500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计矩阵编码了输入变量如何转换为特征。
- en: This is the basis of regression, curve fitting, and many machine learning models.*******************************  ***##
    Chapter 9\. SVD, PCA, and Conditioning
  id: totrans-2501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是回归、曲线拟合以及许多机器学习模型的基础。*******************************  ***## 第 9 章\. SVD、PCA
    和条件数
- en: 81\. Singular Values and SVD (Universal Factorization)
  id: totrans-2502
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 81\. 单位值和 SVD（通用分解）
- en: 'The Singular Value Decomposition (SVD) is one of the most powerful results
    in linear algebra. It says any \(m \times n\) matrix \(A\) can be factored as:'
  id: totrans-2503
  prefs: []
  type: TYPE_NORMAL
  zh: 奇异值分解（SVD）是线性代数中最有力的结果之一。它表明任何 \(m \times n\) 矩阵 \(A\) 都可以分解为：
- en: \[ A = U \Sigma V^T \]
  id: totrans-2504
  prefs: []
  type: TYPE_NORMAL
  zh: \[ A = U \Sigma V^T \]
- en: '\(U\): orthogonal \(m \times m\) matrix (left singular vectors)'
  id: totrans-2505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(U\)：正交的 \(m \times m\) 矩阵（左奇异向量）
- en: '\(\Sigma\): diagonal \(m \times n\) matrix with nonnegative numbers (singular
    values)'
  id: totrans-2506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(\Sigma\)：对角 \(m \times n\) 矩阵，包含非负数（奇异值）
- en: '\(V\): orthogonal \(n \times n\) matrix (right singular vectors)'
  id: totrans-2507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(V\)：正交的 \(n \times n\) 矩阵（右奇异向量）
- en: Singular values are always nonnegative and sorted \(\sigma_1 \geq \sigma_2 \geq
    \dots\).
  id: totrans-2508
  prefs: []
  type: TYPE_NORMAL
  zh: 奇异值始终是非负的，并按顺序排序 \(\sigma_1 \geq \sigma_2 \geq \dots\)。
- en: Set Up Your Lab
  id: totrans-2509
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE793]'
  id: totrans-2510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE793]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2511
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Compute SVD of a matrix
  id: totrans-2512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算矩阵的 SVD
- en: '[PRE794]'
  id: totrans-2513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE794]'
- en: '*[PRE795]*  **   `U`: orthogonal basis in input space.'
  id: totrans-2514
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE795]*  **   `U`：输入空间中的正交基。'
- en: '`S`: singular values (as a 1D array).'
  id: totrans-2515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S`：奇异值（作为一个一维数组）。'
- en: '`V^T`: orthogonal basis in output space.'
  id: totrans-2516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V^T`：输出空间中的正交基。'
- en: Reconstruct \(A\) from decomposition
  id: totrans-2517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从分解中重建 \(A\)
- en: '[PRE796]'
  id: totrans-2518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE796]'
- en: '*[PRE797]*  *The error should be near zero.'
  id: totrans-2519
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE797]*  *误差应该接近零。'
- en: Rank from SVD
  id: totrans-2520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 SVD 中获得秩
- en: Number of nonzero singular values = rank of \(A\).
  id: totrans-2521
  prefs: []
  type: TYPE_NORMAL
  zh: 非零奇异值的数量 = \(A\) 的秩。
- en: '[PRE798]'
  id: totrans-2522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE798]'
- en: '*[PRE799]*  *4.  Geometry: effect of \(A\)'
  id: totrans-2523
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE799]*  *4. 几何：\(A\) 的影响'
- en: 'SVD says:'
  id: totrans-2524
  prefs: []
  type: TYPE_NORMAL
  zh: SVD 表示：
- en: \(V\) rotates input space.
  id: totrans-2525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: \(V\) 旋转输入空间。
- en: \(\Sigma\) scales along orthogonal directions (by singular values).
  id: totrans-2526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: \(\Sigma\) 沿正交方向（通过奇异值）进行缩放。
- en: \(U\) rotates to output space.
  id: totrans-2527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: \(U\) 旋转到输出空间。
- en: This explains why SVD works for any matrix (not just square ones).
  id: totrans-2528
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了为什么 SVD 对任何矩阵都有效（而不仅仅是方阵）。
- en: Low-rank approximation preview
  id: totrans-2529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 低秩近似预览
- en: Keep only the top singular value(s) → best approximation of \(A\).
  id: totrans-2530
  prefs: []
  type: TYPE_NORMAL
  zh: 仅保留最大的奇异值（s）→ \(A\) 的最佳近似。
- en: '[PRE800]'
  id: totrans-2531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE800]'
- en: '*[PRE801]****  ***#### Try It Yourself'
  id: totrans-2532
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE801]****  ***#### 尝试自己操作'
- en: Compute SVD for a random 5×3 matrix. Check if \(U\) and \(V\) are orthogonal.
  id: totrans-2533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对一个随机的 5×3 矩阵计算 SVD。检查 \(U\) 和 \(V\) 是否正交。
- en: Compare singular values of a diagonal matrix vs a rotation matrix.
  id: totrans-2534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较对角矩阵与旋转矩阵的奇异值。
- en: Zero out small singular values and see how much of \(A\) is preserved.
  id: totrans-2535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将小的奇异值置零，看看 \(A\) 保留了多少。
- en: The Takeaway
  id: totrans-2536
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**总结**'
- en: SVD factorizes any matrix into rotations and scalings.
  id: totrans-2537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SVD 将任何矩阵分解为旋转和缩放。
- en: Singular values reveal rank and strength of directions.
  id: totrans-2538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奇异值揭示了秩和方向的力量。
- en: 'It’s the universal tool of numerical linear algebra: the backbone of PCA, compression,
    and stability analysis.****  ***### 82\. Geometry of SVD (Rotations + Stretching)'
  id: totrans-2539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是数值线性代数的通用工具：PCA、压缩和稳定性分析的基础。****  ***### 82. SVD 的几何（旋转 + 拉伸）
- en: 'The Singular Value Decomposition (SVD) has a beautiful geometric interpretation:
    every matrix is just a combination of two rotations (or reflections) and a stretching.'
  id: totrans-2540
  prefs: []
  type: TYPE_NORMAL
  zh: 奇异值分解（SVD）有一个美丽的几何解释：每个矩阵只是两个旋转（或反射）和一个拉伸的组合。
- en: 'For \(A = U \Sigma V^T\):'
  id: totrans-2541
  prefs: []
  type: TYPE_NORMAL
  zh: '对于 \(A = U \Sigma V^T\):'
- en: '\(V^T\): rotates (or reflects) the input space.'
  id: totrans-2542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: \(V^T\)：旋转（或反射）输入空间。
- en: '\(\Sigma\): stretches space along orthogonal axes by singular values \(\sigma_i\).'
  id: totrans-2543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: \(\Sigma\)：通过奇异值 \(\sigma_i\) 沿正交轴拉伸空间。
- en: '\(U\): rotates (or reflects) the result into the output space.'
  id: totrans-2544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: \(U\)：旋转（或反射）结果到输出空间。
- en: This turns any linear transformation into a rotation → stretching → rotation
    pipeline.
  id: totrans-2545
  prefs: []
  type: TYPE_NORMAL
  zh: 这将任何线性变换转换为旋转 → 拉伸 → 旋转管道。
- en: Set Up Your Lab
  id: totrans-2546
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE802]'
  id: totrans-2547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE802]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2548
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Make a 2D matrix
  id: totrans-2549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作一个 2D 矩阵
- en: '[PRE803]'
  id: totrans-2550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE803]'
- en: '*2.  Apply SVD'
  id: totrans-2551
  prefs: []
  type: TYPE_NORMAL
  zh: '*2. 应用 SVD'
- en: '[PRE804]'
  id: totrans-2552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE804]'
- en: '*[PRE805]*  *3.  Visualize effect on the unit circle'
  id: totrans-2553
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE805]*  *3. 可视化对单位圆的影响'
- en: The unit circle is often used to visualize linear transformations.
  id: totrans-2554
  prefs: []
  type: TYPE_NORMAL
  zh: 单位圆常用于可视化线性变换。
- en: '[PRE806]'
  id: totrans-2555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE806]'
- en: '*![](../Images/f55d1900ae2b3fbf2e73df58ab41bb26.png)*  *The circle becomes
    an ellipse. Its axes align with the singular vectors, and its radii are the singular
    values.'
  id: totrans-2556
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/f55d1900ae2b3fbf2e73df58ab41bb26.png)*  *圆变成了椭圆。其轴与奇异向量对齐，其半径是奇异值。'
- en: Compare with decomposition steps
  id: totrans-2557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与分解步骤进行比较
- en: '[PRE807]'
  id: totrans-2558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE807]'
- en: '*![](../Images/c2bdac9342e6dbe5abc212d68cecfa8d.png)*  *Both transformed shapes
    match → confirms SVD’s geometric picture.****  ***#### Try It Yourself'
  id: totrans-2559
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/c2bdac9342e6dbe5abc212d68cecfa8d.png)*  *变换后的形状匹配 → 确认 SVD 的几何图像。****  ***####
    尝试自己操作'
- en: Change \(A\) to a pure shear, like `[[1,2],[0,1]]`. How does the ellipse look?
  id: totrans-2560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 \(A\) 设置为纯剪切，例如 `[[1,2],[0,1]]`。椭圆看起来如何？
- en: Try a diagonal matrix, like `[[3,0],[0,1]]`. Do the singular vectors match the
    coordinate axes?
  id: totrans-2561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试一个对角矩阵，例如 `[[3,0],[0,1]]`。奇异向量是否与坐标轴相匹配？
- en: Scale the input circle to a square and see if geometry still works.
  id: totrans-2562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输入圆缩放到正方形，看看几何是否仍然有效。
- en: The Takeaway
  id: totrans-2563
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: SVD = rotate → stretch → rotate.
  id: totrans-2564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SVD = 旋转 → 拉伸 → 旋转。
- en: 'The unit circle becomes an ellipse: axes = singular vectors, radii = singular
    values.'
  id: totrans-2565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单位圆变成了椭圆：轴 = 奇异向量，半径 = 奇异值。
- en: This geometric lens makes SVD intuitive and explains why it’s so widely used
    in data, graphics, and signal processing.****  ***### 83\. Relation to Eigen-Decompositions
    (ATA and AAT)
  id: totrans-2566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种几何透镜使 SVD 直观，并解释了为什么它在数据、图形和信号处理中如此广泛使用。****  ***### 83. 与特征分解的关系（ATA 和 AAT）
- en: 'Singular values and eigenvalues are closely connected. While eigen-decomposition
    applies only to square matrices, SVD works for any rectangular matrix. The bridge
    between them is:'
  id: totrans-2567
  prefs: []
  type: TYPE_NORMAL
  zh: 奇异值和特征值密切相关。虽然特征分解仅适用于方阵，但 SVD 适用于任何矩形矩阵。它们之间的桥梁是：
- en: \[ A^T A v = \sigma^2 v \quad \text{and} \quad A A^T u = \sigma^2 u \]
  id: totrans-2568
  prefs: []
  type: TYPE_NORMAL
  zh: \[ A^T A v = \sigma^2 v \quad \text{和} \quad A A^T u = \sigma^2 u \]
- en: '\(v\): right singular vector (from eigenvectors of \(A^T A\))'
  id: totrans-2569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(v\)：右奇异向量（来自 \(A^T A\) 的特征向量）
- en: '\(u\): left singular vector (from eigenvectors of \(A A^T\))'
  id: totrans-2570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(u\)：左奇异向量（来自 \(A A^T\) 的特征向量）
- en: '\(\sigma\): singular values (square roots of eigenvalues of \(A^T A\) or \(A
    A^T\))'
  id: totrans-2571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(\sigma\)：奇异值（\(A^T A\) 或 \(A A^T\) 的特征值的平方根）
- en: Set Up Your Lab
  id: totrans-2572
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE808]'
  id: totrans-2573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE808]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2574
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Define a rectangular matrix
  id: totrans-2575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个矩形矩阵
- en: '[PRE809]'
  id: totrans-2576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE809]'
- en: '*2.  Compute SVD directly'
  id: totrans-2577
  prefs: []
  type: TYPE_NORMAL
  zh: '*2.  直接计算 SVD'
- en: '[PRE810]'
  id: totrans-2578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE810]'
- en: '*[PRE811]*  *3.  Compare with eigenvalues of \(A^T A\)'
  id: totrans-2579
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE811]*  *3.  与 \(A^T A\) 的特征值进行比较'
- en: '[PRE812]'
  id: totrans-2580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE812]'
- en: '*[PRE813]*  *Notice: singular values from SVD = square roots of eigenvalues
    of \(A^T A\).'
  id: totrans-2581
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE813]*  *注意：SVD 中的奇异值是 \(A^T A\) 的特征值的平方根。'
- en: Compare with eigenvalues of \(A A^T\)
  id: totrans-2582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与 \(A A^T\) 的特征值进行比较
- en: '[PRE814]'
  id: totrans-2583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE814]'
- en: '*[PRE815]'
  id: totrans-2584
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE815]'
- en: '[PRE816]*  *They match too → confirming the relationship.'
  id: totrans-2585
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE816]*  *它们匹配得太好了 → 确认了关系。'
- en: Verify singular vectors
  id: totrans-2586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证奇异向量
- en: Right singular vectors (\(V\)) = eigenvectors of \(A^T A\).
  id: totrans-2587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右奇异向量（\(V\)）= \(A^T A\) 的特征向量。
- en: Left singular vectors (\(U\)) = eigenvectors of \(A A^T\).
  id: totrans-2588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左奇异向量（\(U\)）= \(A A^T\) 的特征向量。
- en: '[PRE817]'
  id: totrans-2589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE817]'
- en: '*[PRE818]*****  ***#### Try It Yourself'
  id: totrans-2590
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE818]*****  ***#### 尝试自己操作'
- en: Try a square symmetric matrix and compare SVD with eigen-decomposition. Do they
    match?
  id: totrans-2591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试一个平方对称矩阵，并将 SVD 与特征分解进行比较。它们匹配吗？
- en: For a tall vs wide rectangular matrix, check whether \(U\) and \(V\) differ.
  id: totrans-2592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于高宽比不同的矩形矩阵，检查 \(U\) 和 \(V\) 是否不同。
- en: Compute eigenvalues manually with `np.linalg.eig` for a random \(A\) and confirm
    singular values.
  id: totrans-2593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `np.linalg.eig` 手动计算随机 \(A\) 的特征值并确认奇异值。
- en: The Takeaway
  id: totrans-2594
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Singular values = square roots of eigenvalues of \(A^T A\) (or \(A A^T\)).
  id: totrans-2595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奇异值 = \(A^T A\)（或 \(A A^T\)）的特征值的平方根。
- en: Right singular vectors = eigenvectors of \(A^T A\).
  id: totrans-2596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右奇异向量 = \(A^T A\) 的特征向量。
- en: Left singular vectors = eigenvectors of \(A A^T\).
  id: totrans-2597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左奇异向量 = \(A A^T\) 的特征向量。
- en: SVD generalizes eigen-decomposition to all matrices, rectangular or square.****  ***###
    84\. Low-Rank Approximation (Best Small Models)
  id: totrans-2598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SVD 将特征分解推广到所有矩阵，无论是矩形还是平方矩阵。****  ***### 84. 低秩近似（最佳小模型）
- en: 'One of the most useful applications of SVD is low-rank approximation: compressing
    a large matrix into a smaller one while keeping most of the important information.'
  id: totrans-2599
  prefs: []
  type: TYPE_NORMAL
  zh: SVD 最有用的应用之一是低秩近似：将大矩阵压缩成小矩阵，同时保留大部分重要信息。
- en: 'The Eckart–Young theorem says: If \(A = U \Sigma V^T\), then the best rank-\(k\)
    approximation (in least-squares sense) is:'
  id: totrans-2600
  prefs: []
  type: TYPE_NORMAL
  zh: Eckart–Young 定理说：如果 \(A = U \Sigma V^T\)，那么最佳秩-\(k\) 近似（在最小二乘意义上）是：
- en: \[ A_k = U_k \Sigma_k V_k^T \]
  id: totrans-2601
  prefs: []
  type: TYPE_NORMAL
  zh: \[ A_k = U_k \Sigma_k V_k^T \]
- en: where we keep only the top \(k\) singular values (and corresponding vectors).
  id: totrans-2602
  prefs: []
  type: TYPE_NORMAL
  zh: 其中我们只保留前 \(k\) 个奇异值（及其对应的向量）。
- en: Set Up Your Lab
  id: totrans-2603
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE819]'
  id: totrans-2604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE819]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2605
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Create a matrix with hidden low-rank structure
  id: totrans-2606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有隐藏低秩结构的矩阵
- en: '[PRE820]'
  id: totrans-2607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE820]'
- en: '*2.  Full SVD'
  id: totrans-2608
  prefs: []
  type: TYPE_NORMAL
  zh: '*2.  完整 SVD'
- en: '[PRE821]'
  id: totrans-2609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE821]'
- en: '*[PRE822]*  *Only the first ~5 should be large; the rest close to zero.'
  id: totrans-2610
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE822]*  *只有前 ~5 个应该是大的；其余的接近于零。'
- en: Build rank-1 approximation
  id: totrans-2611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建秩-1 近似
- en: '[PRE823]'
  id: totrans-2612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE823]'
- en: '*[PRE824]*  *4.  Rank-5 approximation (should be almost exact)'
  id: totrans-2613
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE824]*  *4.  秩-5 近似（应该几乎是精确的）'
- en: '[PRE825]'
  id: totrans-2614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE825]'
- en: '*[PRE826]*  *5.  Visual comparison (image compression demo)'
  id: totrans-2615
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE826]*  *5.  可视比较（图像压缩演示）'
- en: Let’s see it on an image.
  id: totrans-2616
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个图像上看看。
- en: '[PRE827]'
  id: totrans-2617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE827]'
- en: '*![](../Images/f75e66b7e9f78366778792898f4c6aa2.png)*  *Even with just 2 singular
    values, the digit shape is recognizable.*****  ***#### Try It Yourself'
  id: totrans-2618
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/f75e66b7e9f78366778792898f4c6aa2.png)*  *即使只有两个奇异值，数字形状也是可识别的。*****  ***####
    尝试自己操作'
- en: Vary \(k\) in the image example (1, 2, 5, 10). How much detail do you keep?
  id: totrans-2619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图像示例中改变 \(k\) 的值（1、2、5、10）。你保留了多少细节？
- en: Compare the approximation error \(\|A - A_k\|\) as \(k\) increases.
  id: totrans-2620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较随着 \(k\) 增加的近似误差 \(\|A - A_k\|\)。
- en: Apply low-rank approximation to random noisy data. Does it denoise?
  id: totrans-2621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将低秩近似应用于随机噪声数据。它去噪了吗？
- en: The Takeaway
  id: totrans-2622
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: SVD gives the best possible low-rank approximation in terms of error.
  id: totrans-2623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SVD在误差方面给出最佳可能低秩近似。
- en: By truncating singular values, you compress data while keeping its essential
    structure.
  id: totrans-2624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过截断奇异值，您可以在保持其基本结构的同时压缩数据。
- en: This is the backbone of image compression, recommender systems, and dimensionality
    reduction.****  ***### 85\. Principal Component Analysis (Variance and Directions)
  id: totrans-2625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是图像压缩、推荐系统和降维的骨干技术。****  ***### 85. 主成分分析（方差和方向）
- en: Principal Component Analysis (PCA) is one of the most important applications
    of SVD. It finds the directions (principal components) where data varies the most,
    and projects the data onto them to reduce dimensionality while preserving as much
    information as possible.
  id: totrans-2626
  prefs: []
  type: TYPE_NORMAL
  zh: 主成分分析（PCA）是奇异值分解（SVD）最重要的应用之一。它找到数据变化最大的方向（主成分），并将数据投影到这些方向上以降低维度，同时尽可能保留信息。
- en: 'Mathematically:'
  id: totrans-2627
  prefs: []
  type: TYPE_NORMAL
  zh: 数学上：
- en: Center the data (subtract the mean).
  id: totrans-2628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据居中（减去均值）。
- en: Compute covariance matrix \(C = \frac{1}{n} X^T X\).
  id: totrans-2629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算协方差矩阵 \(C = \frac{1}{n} X^T X\)。
- en: Eigenvectors of \(C\) = principal directions.
  id: totrans-2630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: \(C\) 的特征向量 = 主方向。
- en: Eigenvalues = variance explained.
  id: totrans-2631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特征值 = 解释的方差。
- en: 'Equivalently: PCA = SVD of centered data matrix.'
  id: totrans-2632
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等价地：PCA = 居中数据矩阵的SVD。
- en: Set Up Your Lab
  id: totrans-2633
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE828]'
  id: totrans-2634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE828]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2635
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码解析'
- en: Generate synthetic 2D data
  id: totrans-2636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成合成2D数据
- en: '[PRE829]'
  id: totrans-2637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE829]'
- en: '*![](../Images/4ee496ffc33356435a312affe651f883.png)*  *2.  Center the data'
  id: totrans-2638
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/4ee496ffc33356435a312affe651f883.png)*  *2.  数据居中'
- en: '[PRE830]'
  id: totrans-2639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE830]'
- en: '*3.  Compute SVD'
  id: totrans-2640
  prefs: []
  type: TYPE_NORMAL
  zh: '*3.  计算奇异值分解'
- en: '[PRE831]'
  id: totrans-2641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE831]'
- en: '*[PRE832]*  *Rows of `Vt` are the principal components.'
  id: totrans-2642
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE832]*  *`Vt` 的行是主成分。'
- en: Project data onto first component
  id: totrans-2643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据投影到第一个主成分
- en: '[PRE833]'
  id: totrans-2644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE833]'
- en: '*![](../Images/e185574662ce2d32b63dcf3ba06f5eb9.png)*  *This collapses data
    into 1D, keeping the most variance.'
  id: totrans-2645
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/e185574662ce2d32b63dcf3ba06f5eb9.png)*  *这会将数据折叠成1D，同时保留最多的方差。'
- en: Visualize principal axes
  id: totrans-2646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化主轴
- en: '[PRE834]'
  id: totrans-2647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE834]'
- en: '*![](../Images/22fd7647497edd7133983d6fd85f5096.png)*  *The red arrows show
    where the data spreads most.'
  id: totrans-2648
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/22fd7647497edd7133983d6fd85f5096.png)*  *红色箭头显示数据分布最广的地方。'
- en: PCA on real data (digits)
  id: totrans-2649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在真实数据（数字）上执行PCA
- en: '[PRE835]'
  id: totrans-2650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE835]'
- en: '*[PRE836]******  ***#### Try It Yourself'
  id: totrans-2651
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE836]******  ***#### 尝试自己操作'
- en: Reduce digits dataset to 2D using the top 2 components and plot. Do digit clusters
    separate?
  id: totrans-2652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前两个主成分将数字数据集降低到2D并绘制。数字簇是否分离？
- en: Compare explained variance ratio for top 10 components.
  id: totrans-2653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较前10个主成分的解释方差比。
- en: Add noise to data and check if PCA filters it out when projecting to fewer dimensions.
  id: totrans-2654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向数据添加噪声并检查PCA在投影到较少维度时是否过滤掉噪声。
- en: The Takeaway
  id: totrans-2655
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: PCA finds directions of maximum variance using SVD.
  id: totrans-2656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PCA使用SVD找到最大方差的方向。
- en: By projecting onto top components, you compress data with minimal information
    loss.
  id: totrans-2657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过投影到前几个主成分，您可以在最小信息损失的情况下压缩数据。
- en: PCA is the backbone of dimensionality reduction, visualization, and preprocessing
    in machine learning.****  ***### 86\. Pseudoinverse (Moore–Penrose) and Solving
    Ill-Posed Systems
  id: totrans-2658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PCA是机器学习中降维、可视化和预处理的骨干技术。****  ***### 86. 假逆（摩尔-彭罗斯）和求解病态系统
- en: 'The Moore–Penrose pseudoinverse \(A^+\) generalizes the inverse of a matrix.
    It allows solving systems \(Ax = b\) even when:'
  id: totrans-2659
  prefs: []
  type: TYPE_NORMAL
  zh: 摩尔-彭罗斯伪逆 \(A^+\) 通用矩阵的逆。它允许在以下情况下求解系统 \(Ax = b\)：
- en: \(A\) is not square, or
  id: totrans-2660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(A\) 不是方阵，或者
- en: \(A\) is singular (non-invertible).
  id: totrans-2661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(A\) 是奇异的（不可逆的）。
- en: 'The solution given by the pseudoinverse is the least-squares solution with
    minimum norm:'
  id: totrans-2662
  prefs: []
  type: TYPE_NORMAL
  zh: 伪逆给出的解是最小范数的最小二乘解：
- en: \[ x = A^+ b \]
  id: totrans-2663
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x = A^+ b \]
- en: 'If \(A = U \Sigma V^T\), then:'
  id: totrans-2664
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 \(A = U \Sigma V^T\)，那么：
- en: \[ A^+ = V \Sigma^+ U^T \]
  id: totrans-2665
  prefs: []
  type: TYPE_NORMAL
  zh: \[ A^+ = V \Sigma^+ U^T \]
- en: where \(\Sigma^+\) is obtained by taking reciprocals of nonzero singular values.
  id: totrans-2666
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(\Sigma^+\) 是通过取非零奇异值的倒数获得的。
- en: Set Up Your Lab
  id: totrans-2667
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE837]'
  id: totrans-2668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE837]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2669
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码解析'
- en: Solve an overdetermined system (more equations than unknowns)
  id: totrans-2670
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 求解超定系统（方程数多于未知数）
- en: '[PRE838]'
  id: totrans-2671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE838]'
- en: '*[PRE839]*  *2.  Compute with pseudoinverse'
  id: totrans-2672
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE839]*  *2.  使用伪逆进行计算'
- en: '[PRE840]'
  id: totrans-2673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE840]'
- en: '*[PRE841]*  *Both match → pseudoinverse gives least-squares solution.'
  id: totrans-2674
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE841]*  *两者匹配→伪逆给出最小二乘解。'
- en: Solve an underdetermined system (fewer equations than unknowns)
  id: totrans-2675
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 求解欠定系统（方程数少于未知数）
- en: '[PRE842]'
  id: totrans-2676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE842]'
- en: '*[PRE843]*  *Here, infinitely many solutions exist. The pseudoinverse picks
    the one with smallest norm.'
  id: totrans-2677
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE843]*  *在这里，存在无限多个解。伪逆选择范数最小的那个。'
- en: Compare with singular matrix
  id: totrans-2678
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与单矩阵比较
- en: '[PRE844]'
  id: totrans-2679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE844]'
- en: '*[PRE845]*  *Even when \(A\) is singular, pseudoinverse provides a solution.'
  id: totrans-2680
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE845]*  *即使 \(A\) 是奇异的，伪逆也能提供一个解。'
- en: Manual pseudoinverse via SVD
  id: totrans-2681
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过SVD手动计算假逆。
- en: '[PRE846]'
  id: totrans-2682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE846]'
- en: '*[PRE847]*  *They match.*****  ***#### Try It Yourself'
  id: totrans-2683
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE847]*  *它们匹配。*****  ***#### 尝试自己操作'
- en: Create an overdetermined system with noise and see how pseudoinverse smooths
    the solution.
  id: totrans-2684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带噪声的超定系统并观察伪逆如何平滑解。
- en: Compare pseudoinverse with direct inverse (`np.linalg.inv`) on a square nonsingular
    matrix.
  id: totrans-2685
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个方非奇异矩阵上比较伪逆与直接逆（`np.linalg.inv`）。
- en: Zero out small singular values manually and see how solution changes.
  id: totrans-2686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动将小的奇异值置零并观察解如何变化。
- en: The Takeaway
  id: totrans-2687
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: The pseudoinverse solves any linear system, square or not.
  id: totrans-2688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假逆解可以解决任何线性系统，无论是方阵还是非方阵。
- en: It provides the least-squares solution in overdetermined cases and the minimum-norm
    solution in underdetermined cases.
  id: totrans-2689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在超定情况下提供最小二乘解，在欠定情况下提供最小范数解。
- en: Built on SVD, it is a cornerstone of regression, optimization, and numerical
    methods.****  ***### 87\. Conditioning and Sensitivity (How Errors Amplify)
  id: totrans-2690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立在SVD之上，它是回归、优化和数值方法的一个基石。****  ***### 87\. 病态和敏感性（误差如何放大）
- en: 'Conditioning tells us how sensitive a system is to small changes. For a linear
    system \(Ax = b\):'
  id: totrans-2691
  prefs: []
  type: TYPE_NORMAL
  zh: 病态告诉我们系统对微小变化的敏感性。对于一个线性系统 \(Ax = b\)：
- en: If \(A\) is well-conditioned, small changes in \(b\) or \(A\) → small changes
    in \(x\).
  id: totrans-2692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 \(A\) 是良态的，\(b\) 或 \(A\) 的小变化会导致 \(x\) 的小变化。
- en: If \(A\) is ill-conditioned, tiny changes can cause huge swings in \(x\).
  id: totrans-2693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 \(A\) 是病态的，微小的变化可以导致 \(x\) 的巨大波动。
- en: 'The condition number is defined as:'
  id: totrans-2694
  prefs: []
  type: TYPE_NORMAL
  zh: 条件数定义为：
- en: \[ \kappa(A) = \|A\| \cdot \|A^{-1}\| \]
  id: totrans-2695
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \kappa(A) = \|A\| \cdot \|A^{-1}\| \]
- en: 'For SVD:'
  id: totrans-2696
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SVD：
- en: \[ \kappa(A) = \frac{\sigma_{\max}}{\sigma_{\min}} \]
  id: totrans-2697
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \kappa(A) = \frac{\sigma_{\max}}{\sigma_{\min}} \]
- en: where \(\sigma_{\max}\) and \(\sigma_{\min}\) are the largest and smallest singular
    values.
  id: totrans-2698
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(\sigma_{\max}\) 和 \(\sigma_{\min}\) 是最大和最小的奇异值。
- en: Large \(\kappa(A)\) → unstable system.
  id: totrans-2699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大 \(\kappa(A)\) → 不稳定系统。
- en: Small \(\kappa(A)\) → stable system.
  id: totrans-2700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小 \(\kappa(A)\) → 稳定系统。
- en: Set Up Your Lab
  id: totrans-2701
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE848]'
  id: totrans-2702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE848]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2703
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Well-conditioned system
  id: totrans-2704
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 良态系统
- en: '[PRE849]'
  id: totrans-2705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE849]'
- en: '*[PRE850]*  *Condition number = ratio of singular values → moderate size.'
  id: totrans-2706
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE850]*  *条件数 = 奇异值之比 → 中等大小。'
- en: Ill-conditioned system
  id: totrans-2707
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 病态系统
- en: '[PRE851]'
  id: totrans-2708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE851]'
- en: '*[PRE852]*  *Condition number is very large → instability.'
  id: totrans-2709
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE852]*  *条件数非常大 → 不稳定。'
- en: Perturb the right-hand side
  id: totrans-2710
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扰动右侧
- en: '[PRE853]'
  id: totrans-2711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE853]'
- en: '*[PRE854]*  *The solution changes drastically → shows sensitivity.'
  id: totrans-2712
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE854]*  *解会发生剧烈变化 → 显示敏感性。'
- en: Relation to singular values
  id: totrans-2713
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与奇异值的关系
- en: '[PRE855]'
  id: totrans-2714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE855]'
- en: '*[PRE856]*  *5.  Scaling experiment'
  id: totrans-2715
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE856]*  *5.  缩放实验'
- en: '[PRE857]'
  id: totrans-2716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE857]'
- en: '*[PRE858]*  *As scale shrinks, condition number explodes.*****  ***#### Try
    It Yourself'
  id: totrans-2717
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE858]*  *随着尺度的缩小，条件数会急剧增加。*****  ***#### 尝试自己操作'
- en: Generate random matrices and compute their condition numbers. Which are stable?
  id: totrans-2718
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成随机矩阵并计算它们的条件数。哪些是稳定的？
- en: Compare condition numbers of Hilbert matrices (notoriously ill-conditioned).
  id: totrans-2719
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较希尔伯特矩阵（臭名昭著的病态）的条件数。
- en: Explore how rounding errors grow with high condition numbers.
  id: totrans-2720
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 探索高条件数下舍入误差如何增长。
- en: The Takeaway
  id: totrans-2721
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Condition number = measure of problem sensitivity.
  id: totrans-2722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件数 = 问题敏感性的度量。
- en: \(\kappa(A) = \sigma_{\max}/\sigma_{\min}\).
  id: totrans-2723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(\kappa(A) = \sigma_{\max}/\sigma_{\min}\)。
- en: Ill-conditioned problems amplify errors and are numerically unstable → why scaling,
    regularization, and good formulations matter.****  ***### 88\. Matrix Norms and
    Singular Values (Measuring Size Properly)
  id: totrans-2724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 病态问题放大误差并且数值不稳定 → 为什么缩放、正则化和良好的公式很重要。****  ***### 88\. 矩阵范数和奇异值（正确测量大小）
- en: Matrix norms measure the size or strength of a matrix. They extend the idea
    of vector length to matrices. Norms are crucial for analyzing stability, error
    growth, and performance of algorithms.
  id: totrans-2725
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵范数衡量矩阵的大小或强度。它们将向量长度的概念扩展到矩阵。范数对于分析稳定性、误差增长和算法性能至关重要。
- en: 'Some important norms:'
  id: totrans-2726
  prefs: []
  type: TYPE_NORMAL
  zh: 一些重要的范数：
- en: 'Frobenius norm:'
  id: totrans-2727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弗罗贝尼乌斯范数：
- en: \[ \|A\|_F = \sqrt{\sum_{i,j} |a_{ij}|^2} \]
  id: totrans-2728
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \|A\|_F = \sqrt{\sum_{i,j} |a_{ij}|^2} \]
- en: Equivalent to treating the matrix as a big vector.
  id: totrans-2729
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于将矩阵视为一个大向量。
- en: 'Spectral norm (operator 2-norm):'
  id: totrans-2730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谱范数（算子2-范数）：
- en: \[ \|A\|_2 = \sigma_{\max} \]
  id: totrans-2731
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \|A\|_2 = \sigma_{\max} \]
- en: The largest singular value - tells how much \(A\) can stretch a vector.
  id: totrans-2732
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的奇异值 - 告诉我们 \(A\) 可以将向量拉伸多少。
- en: '1-norm: maximum absolute column sum.'
  id: totrans-2733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1-范数：最大绝对列和。
- en: '∞-norm: maximum absolute row sum.'
  id: totrans-2734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ∞-范数：最大绝对行和。
- en: Set Up Your Lab
  id: totrans-2735
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE859]'
  id: totrans-2736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE859]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2737
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Build a test matrix
  id: totrans-2738
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建测试矩阵
- en: '[PRE860]'
  id: totrans-2739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE860]'
- en: '*2.  Compute different norms'
  id: totrans-2740
  prefs: []
  type: TYPE_NORMAL
  zh: '*2.  计算不同的范数'
- en: '[PRE861]'
  id: totrans-2741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE861]'
- en: '*[PRE862]*  *3.  Compare spectral norm with largest singular value'
  id: totrans-2742
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE862]*  *3.  比较谱范数与最大奇异值'
- en: '[PRE863]'
  id: totrans-2743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE863]'
- en: '*[PRE864]*  *They match → spectral norm = largest singular value.'
  id: totrans-2744
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE864]*  *它们匹配 → 谱范数 = 最大奇异值。'
- en: Frobenius norm from singular values
  id: totrans-2745
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从奇异值计算 Frobenius 范数
- en: \[ \|A\|_F = \sqrt{\sigma_1^2 + \sigma_2^2 + \dots} \]
  id: totrans-2746
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \|A\|_F = \sqrt{\sigma_1^2 + \sigma_2^2 + \dots} \]
- en: '[PRE865]'
  id: totrans-2747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE865]'
- en: '*[PRE866]*  *5.  Stretching effect demonstration'
  id: totrans-2748
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE866]*  *5.  展伸效应演示'
- en: 'Pick a random vector and see how much it grows:'
  id: totrans-2749
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个随机向量并观察其增长程度：
- en: '[PRE867]'
  id: totrans-2750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE867]'
- en: '*[PRE868]*  *The stretch ≤ spectral norm, always.*****  ***#### Try It Yourself'
  id: totrans-2751
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE868]*  *展伸 ≤ 谱范数，总是。*****  ***#### 尝试自己操作'
- en: Compare norms for diagonal matrices - do they match the largest diagonal entry?
  id: totrans-2752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较对角矩阵的范数——它们是否与最大的对角线元素匹配？
- en: Generate random matrices and see how norms differ.
  id: totrans-2753
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成随机矩阵并观察范数如何不同。
- en: Compute Frobenius vs spectral norm for a rank-1 matrix.
  id: totrans-2754
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算一个秩为 1 的矩阵的 Frobenius 范数与谱范数。
- en: The Takeaway
  id: totrans-2755
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Frobenius norm = overall energy of the matrix.
  id: totrans-2756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Frobenius 范数 = 矩阵的整体能量。
- en: Spectral norm = maximum stretching power (largest singular value).
  id: totrans-2757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谱范数 = 最大展伸能力（最大奇异值）。
- en: Other norms (1-norm, ∞-norm) capture row/column dominance.
  id: totrans-2758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他范数（1-范数、∞-范数）捕捉行/列的主导性。
- en: Singular values unify all these views of “matrix size.”****  ***### 89\. Regularization
    (Ridge/Tikhonov to Tame Instability)
  id: totrans-2759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奇异值统一了所有关于“矩阵大小”的看法。****  ***### 89\. 正则化（岭/Tikhonov 平滑不稳定性）
- en: When solving \(Ax = b\), if \(A\) is ill-conditioned (large condition number),
    small errors in data can cause huge errors in the solution. Regularization stabilizes
    the problem by adding a penalty term that discourages extreme solutions.
  id: totrans-2760
  prefs: []
  type: TYPE_NORMAL
  zh: 当求解 \(Ax = b\) 时，如果 \(A\) 是病态的（条件数大），数据中的小误差可能导致解中的巨大误差。正则化通过添加一个惩罚项来稳定问题，该惩罚项会阻止极端解。
- en: 'The most common form: ridge regression (a.k.a. Tikhonov regularization):'
  id: totrans-2761
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的形式：岭回归（也称为 Tikhonov 正则化）：
- en: \[ x_\lambda = \arg\min_x \|Ax - b\|^2 + \lambda \|x\|^2 \]
  id: totrans-2762
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x_\lambda = \arg\min_x \|Ax - b\|^2 + \lambda \|x\|^2 \]
- en: 'Closed form:'
  id: totrans-2763
  prefs: []
  type: TYPE_NORMAL
  zh: 闭式形式：
- en: \[ x_\lambda = (A^T A + \lambda I)^{-1} A^T b \]
  id: totrans-2764
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x_\lambda = (A^T A + \lambda I)^{-1} A^T b \]
- en: 'Here \(\lambda > 0\) controls the amount of regularization:'
  id: totrans-2765
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 \(\lambda > 0\) 控制正则化的程度：
- en: 'Small \(\lambda\): solution close to least-squares.'
  id: totrans-2766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小 \(\lambda\)：解接近最小二乘。
- en: 'Large \(\lambda\): smaller coefficients, more stability.'
  id: totrans-2767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大 \(\lambda\)：较小的系数，更多的稳定性。
- en: Set Up Your Lab
  id: totrans-2768
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE869]'
  id: totrans-2769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE869]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2770
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Build an ill-conditioned system
  id: totrans-2771
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个病态的系统
- en: '[PRE870]'
  id: totrans-2772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE870]'
- en: '*2.  Solve without regularization'
  id: totrans-2773
  prefs: []
  type: TYPE_NORMAL
  zh: '*2.  不使用正则化求解'
- en: '[PRE871]'
  id: totrans-2774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE871]'
- en: '*[PRE872]*  *The result may be unstable.'
  id: totrans-2775
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE872]*  *结果可能是不稳定的。'
- en: Apply ridge regularization
  id: totrans-2776
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用岭正则化
- en: '[PRE873]'
  id: totrans-2777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE873]'
- en: '*[PRE874]*  *4.  Compare effect of different λ'
  id: totrans-2778
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE874]*  *4.  比较不同 \(\lambda\) 的影响'
- en: '[PRE875]'
  id: totrans-2779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE875]'
- en: '*![](../Images/e4f94a0ed50b1e1fec7cb740f6adf8a4.png)*  *As \(\lambda\) increases,
    the solution becomes smaller and more stable.'
  id: totrans-2780
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/e4f94a0ed50b1e1fec7cb740f6adf8a4.png)*  *随着 \(\lambda\) 的增加，解变得越小越稳定。'
- en: Connection to SVD
  id: totrans-2781
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与 SVD 的联系
- en: 'If \(A = U \Sigma V^T\):'
  id: totrans-2782
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 \(A = U \Sigma V^T\)：
- en: \[ x_\lambda = \sum_i \frac{\sigma_i}{\sigma_i^2 + \lambda} (u_i^T b) v_i \]
  id: totrans-2783
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x_\lambda = \sum_i \frac{\sigma_i}{\sigma_i^2 + \lambda} (u_i^T b) v_i \]
- en: Small singular values (causing instability) get damped by \(\frac{\sigma_i}{\sigma_i^2
    + \lambda}\).****  ***#### Try It Yourself
  id: totrans-2784
  prefs: []
  type: TYPE_NORMAL
  zh: 小奇异值（导致不稳定性）被 \(\frac{\sigma_i}{\sigma_i^2 + \lambda}\) 抑制。****  ***#### 尝试自己操作
- en: Experiment with larger and smaller \(\lambda\). What happens to the solution?
  id: totrans-2785
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用较大和较小的 \(\lambda\)。解会发生什么变化？
- en: Add random noise to \(b\). Compare least-squares vs ridge stability.
  id: totrans-2786
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 \(b\) 添加随机噪声。比较最小二乘与岭稳定性。
- en: Plot how each coefficient changes with λ.
  id: totrans-2787
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制每个系数如何随 \(\lambda\) 变化的图。
- en: The Takeaway
  id: totrans-2788
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Regularization controls instability in ill-conditioned problems.
  id: totrans-2789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则化控制病态问题中的不稳定性。
- en: Ridge regression balances fit vs. stability using λ.
  id: totrans-2790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 岭回归通过使用 \(\lambda\) 平衡拟合与稳定性。
- en: In SVD terms, regularization damps small singular values that cause wild solutions.****  ***###
    90\. Rank-Revealing QR and Practical Diagnostics (What Rank Really Is)
  id: totrans-2791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在奇异值分解的术语中，正则化抑制了导致解不稳定的较小奇异值。****  ***### 90\. 求秩 QR 和实用诊断（秩的真正含义）
- en: In practice, we often need to determine the numerical rank of a matrix - not
    just the theoretical rank, but how many directions carry meaningful information
    beyond round-off errors or noise. A useful tool for this is the Rank-Revealing
    QR (RRQR) factorization.
  id: totrans-2792
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我们经常需要确定矩阵的数值秩——不仅仅是理论秩，还有多少方向携带了超出舍入误差或噪声的有意义信息。用于此的有用工具是秩揭示 QR（RRQR）分解。
- en: 'For a matrix \(A\):'
  id: totrans-2793
  prefs: []
  type: TYPE_NORMAL
  zh: 对于矩阵 \(A\)：
- en: \[ A P = Q R \]
  id: totrans-2794
  prefs: []
  type: TYPE_NORMAL
  zh: \[ A P = Q R \]
- en: '\(Q\): orthogonal matrix'
  id: totrans-2795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '\(Q\): 正交矩阵'
- en: '\(R\): upper triangular matrix'
  id: totrans-2796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '\(R\): 上三角矩阵'
- en: '\(P\): column permutation matrix'
  id: totrans-2797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '\(P\): 列置换矩阵'
- en: By reordering columns smartly, the diagonal of \(R\) reveals which directions
    are significant.
  id: totrans-2798
  prefs: []
  type: TYPE_NORMAL
  zh: 通过智能地重新排序列，\(R\) 的对角线揭示了哪些方向是重要的。
- en: Set Up Your Lab
  id: totrans-2799
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE876]'
  id: totrans-2800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE876]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2801
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Build a nearly rank-deficient matrix
  id: totrans-2802
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个几乎秩亏的矩阵
- en: '[PRE877]'
  id: totrans-2803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE877]'
- en: '*[PRE878]*  *This matrix is almost rank 2 but with small perturbations.'
  id: totrans-2804
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE878]*  *这个矩阵几乎秩为 2，但带有小的扰动。'
- en: QR with column pivoting
  id: totrans-2805
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 带列交换的 QR
- en: '[PRE879]'
  id: totrans-2806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE879]'
- en: '*[PRE880]*  *The diagonal entries of \(R\) decrease rapidly → numerical rank
    is determined where they become tiny.'
  id: totrans-2807
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE880]*  *\(R\) 的对角线迅速减小 → 数值秩在它们变得很小时确定。'
- en: Compare with SVD
  id: totrans-2808
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与 SVD 比较
- en: '[PRE881]'
  id: totrans-2809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE881]'
- en: '*[PRE882]*  *The singular values tell the same story: one is very small → effective
    rank ≈ 2.'
  id: totrans-2810
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE882]*  *奇异值讲述同样的故事：一个非常小 → 有效秩 ≈ 2。'
- en: Thresholding for rank
  id: totrans-2811
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 秩的阈值
- en: '[PRE883]'
  id: totrans-2812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE883]'
- en: '*[PRE884]*  *5.  Diagnostics on a noisy matrix'
  id: totrans-2813
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE884]*  *5. 对噪声矩阵进行诊断'
- en: '[PRE885]'
  id: totrans-2814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE885]'
- en: '*![](../Images/50d94d023826abc1ba71dafaccff1e42.png)*  *The drop in singular
    values shows effective rank.*****  ***#### Try It Yourself'
  id: totrans-2815
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/50d94d023826abc1ba71dafaccff1e42.png)*  *奇异值的下降显示了有效的秩。*****  ***####
    尝试自己动手做'
- en: Change the perturbation in \(A\) from 0.001 to 0.000001\. Does the numerical
    rank change?
  id: totrans-2816
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 \(A\) 中的扰动从 0.001 改为 0.000001，数值秩会改变吗？
- en: Test QR with pivoting on random rectangular matrices.
  id: totrans-2817
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在随机矩形矩阵上测试带行交换的 QR。
- en: Compare rank estimates from QR vs SVD for large noisy matrices.
  id: totrans-2818
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较大型噪声矩阵的 QR 与 SVD 的秩估计。
- en: The Takeaway
  id: totrans-2819
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸取的经验
- en: Rank-revealing QR is a practical tool to detect effective rank in real-world
    data.
  id: totrans-2820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rank-revealing QR 是检测现实世界数据中有效秩的实用工具。
- en: SVD gives the most precise picture (singular values), but QR with pivoting is
    faster.
  id: totrans-2821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SVD 提供了最精确的图像（奇异值），但 QR 带行交换更快。
- en: Understanding numerical rank is crucial for diagnostics, stability, and model
    complexity control.*******************************  ***## Chapter 10\. Applications
    and computation
  id: totrans-2822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解数值秩对于诊断、稳定性和模型复杂度控制至关重要。*******************************  ***## 第 10 章. 应用和计算
- en: 91\. 2D/3D Geometry Pipelines (Cameras, Rotations, and Transforms)
  id: totrans-2823
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 91. 2D/3D 几何管道（摄像机、旋转和变换）
- en: Linear algebra powers the geometry pipelines in computer graphics and robotics.
  id: totrans-2824
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数为计算机图形学和机器人学中的几何管道提供动力。
- en: '2D transforms: rotation, scaling, translation.'
  id: totrans-2825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D 变换：旋转、缩放、平移。
- en: '3D transforms: same ideas, but with an extra dimension.'
  id: totrans-2826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D 变换：相同的概念，但多了一个维度。
- en: Homogeneous coordinates let us unify all transforms (even translations) into
    matrix multiplications.
  id: totrans-2827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 齐次坐标使我们能够将所有变换（甚至平移）统一为矩阵乘法。
- en: Set Up Your Lab
  id: totrans-2828
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE886]'
  id: totrans-2829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE886]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2830
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Rotation in 2D
  id: totrans-2831
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2D 中的旋转
- en: \[ R(\theta) = \begin{bmatrix} \cos\theta & -\sin\theta \\ \sin\theta & \cos\theta
    \end{bmatrix} \]
  id: totrans-2832
  prefs: []
  type: TYPE_NORMAL
  zh: \[ R(\theta) = \begin{bmatrix} \cos\theta & -\sin\theta \\ \sin\theta & \cos\theta
    \end{bmatrix} \]
- en: '[PRE887]'
  id: totrans-2833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE887]'
- en: '*[PRE888]*  *2.  Translation using homogeneous coordinates'
  id: totrans-2834
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE888]*  *2. 使用齐次坐标进行平移'
- en: 'In 2D:'
  id: totrans-2835
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2D 中：
- en: \[ T(dx, dy) = \begin{bmatrix} 1 & 0 & dx \\ 0 & 1 & dy \\ 0 & 0 & 1 \end{bmatrix}
    \]
  id: totrans-2836
  prefs: []
  type: TYPE_NORMAL
  zh: \[ T(dx, dy) = \begin{bmatrix} 1 & 0 & dx \\ 0 & 1 & dy \\ 0 & 0 & 1 \end{bmatrix}
    \]
- en: '[PRE889]'
  id: totrans-2837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE889]'
- en: '*[PRE890]*  *3.  Combine rotation + translation'
  id: totrans-2838
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE890]*  *3.  组合旋转 + 平移'
- en: Transformations compose by multiplying matrices.
  id: totrans-2839
  prefs: []
  type: TYPE_NORMAL
  zh: 变换通过矩阵乘法组合。
- en: '[PRE891]'
  id: totrans-2840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE891]'
- en: '*[PRE892]*  *4.  3D rotation (around z-axis)'
  id: totrans-2841
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE892]*  *4.  3D 绕 z 轴旋转'
- en: \[ R_z(\theta) = \begin{bmatrix} \cos\theta & -\sin\theta & 0 \\ \sin\theta
    & \cos\theta & 0 \\ 0 & 0 & 1 \end{bmatrix} \]
  id: totrans-2842
  prefs: []
  type: TYPE_NORMAL
  zh: \[ R_z(\theta) = \begin{bmatrix} \cos\theta & -\sin\theta & 0 \\ \sin\theta
    & \cos\theta & 0 \\ 0 & 0 & 1 \end{bmatrix} \]
- en: '[PRE893]'
  id: totrans-2843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE893]'
- en: '*[PRE894]*  *5.  Camera projection (3D → 2D)'
  id: totrans-2844
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE894]*  *5. 摄像机投影（3D → 2D）'
- en: 'Simple pinhole model:'
  id: totrans-2845
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的针孔模型：
- en: \[ \begin{bmatrix} x' \\ y' \end{bmatrix} = \begin{bmatrix} f \cdot x / z \\
    f \cdot y / z \end{bmatrix} \]
  id: totrans-2846
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{bmatrix} x' \\ y' \end{bmatrix} = \begin{bmatrix} f \cdot x / z \\
    f \cdot y / z \end{bmatrix} \]
- en: '[PRE895]'
  id: totrans-2847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE895]'
- en: '*[PRE896]*****  ***#### Try It Yourself'
  id: totrans-2848
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE896]*****  ***#### 尝试自己动手做'
- en: Rotate a square in 2D, then translate it. Plot before/after.
  id: totrans-2849
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 2D 中旋转一个正方形，然后平移它。绘制前后对比。
- en: Rotate a 3D point cloud around x, y, and z axes.
  id: totrans-2850
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绕 x、y 和 z 轴旋转 3D 点云。
- en: Project a cube into 2D using the pinhole camera model.
  id: totrans-2851
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用针孔相机模型将立方体投影到 2D。
- en: The Takeaway
  id: totrans-2852
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸取的经验
- en: Geometry pipelines = sequences of linear transforms.
  id: totrans-2853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几何管道 = 线性变换的序列。
- en: Homogeneous coordinates unify rotation, scaling, and translation.
  id: totrans-2854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 齐次坐标统一了旋转、缩放和平移。
- en: Camera projection links 3D world to 2D images - a cornerstone of graphics and
    vision.****  ***### 92\. Computer Graphics and Robotics (Homogeneous Tricks in
    Action)
  id: totrans-2855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摄像机投影将 3D 世界与 2D 图像联系起来——这是图形和视觉的基石。****  ***### 92. 计算机图形学和机器人学（齐次技巧的实际应用）
- en: Computer graphics and robotics both rely on homogeneous coordinates to unify
    rotations, translations, scalings, and projections into a single framework. With
    \(4 \times 4\) matrices in 3D, entire transformation pipelines can be built as
    matrix products.
  id: totrans-2856
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机图形学和机器人学都依赖于同质坐标来统一旋转、平移、缩放和投影到一个单一框架。在3D中使用 \(4 \times 4\) 矩阵，整个变换管线可以作为矩阵乘积构建。
- en: Set Up Your Lab
  id: totrans-2857
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE897]'
  id: totrans-2858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE897]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2859
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码解析'
- en: Homogeneous representation of a point
  id: totrans-2860
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点的同质表示
- en: 'In 3D:'
  id: totrans-2861
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D中：
- en: \[ (x, y, z) \mapsto (x, y, z, 1) \]
  id: totrans-2862
  prefs: []
  type: TYPE_NORMAL
  zh: \[ (x, y, z) \mapsto (x, y, z, 1) \]
- en: '[PRE898]'
  id: totrans-2863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE898]'
- en: '*2.  Define translation, rotation, and scaling matrices'
  id: totrans-2864
  prefs: []
  type: TYPE_NORMAL
  zh: '*2.  定义平移、旋转和缩放矩阵'
- en: 'Translation by \((dx,dy,dz)\):'
  id: totrans-2865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平移 \((dx,dy,dz)\)：
- en: '[PRE899]'
  id: totrans-2866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE899]'
- en: '**   Scaling by factors \((sx, sy, sz)\):'
  id: totrans-2867
  prefs: []
  type: TYPE_NORMAL
  zh: '**   按因子 \((sx, sy, sz)\) 缩放：'
- en: '[PRE900]'
  id: totrans-2868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE900]'
- en: '**   Rotation about z-axis (\(\theta = 90^\circ\)):'
  id: totrans-2869
  prefs: []
  type: TYPE_NORMAL
  zh: '**   绕z轴旋转（\(\theta = 90^\circ\))：'
- en: '[PRE901]'
  id: totrans-2870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE901]'
- en: '*3.  Combine transforms into a pipeline'
  id: totrans-2871
  prefs: []
  type: TYPE_NORMAL
  zh: '*3.  将变换组合成管线'
- en: '[PRE902]'
  id: totrans-2872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE902]'
- en: '*[PRE903]*  *4.  Robotics: forward kinematics of a 2-link arm'
  id: totrans-2873
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE903]*  *4.  机器人学：2自由度机械臂的前向运动学'
- en: Each joint is a rotation + translation.
  id: totrans-2874
  prefs: []
  type: TYPE_NORMAL
  zh: 每个关节都是一个旋转 + 平移。
- en: '[PRE904]'
  id: totrans-2875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE904]'
- en: '*[PRE905]*  *5.  Graphics: simple 3D camera projection'
  id: totrans-2876
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE905]*  *5.  图形学：简单的3D相机投影'
- en: '[PRE906]'
  id: totrans-2877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE906]'
- en: '*[PRE907]'
  id: totrans-2878
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE907]'
- en: '![](../Images/5a17e925e049c8e0d299dc3cf53f9c1d.png)*******  ***#### Try It
    Yourself'
  id: totrans-2879
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/5a17e925e049c8e0d299dc3cf53f9c1d.png)*******  ***#### 尝试自己操作'
- en: Change order of transforms (`Rz @ S @ T`). How does the result differ?
  id: totrans-2880
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变变换的顺序（`Rz @ S @ T`）。结果有何不同？
- en: Add a third joint to the robotic arm and compute new end-effector position.
  id: totrans-2881
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向机器人臂添加第三个关节并计算新的末端执行器位置。
- en: Project the cube with different focal lengths \(f\).
  id: totrans-2882
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用不同的焦距 \(f\) 投影立方体。
- en: The Takeaway
  id: totrans-2883
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 要点总结
- en: Homogeneous coordinates unify all transformations.
  id: totrans-2884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同质坐标统一了所有变换。
- en: Robotics uses this framework for forward kinematics.
  id: totrans-2885
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人学使用这个框架进行前向运动学。
- en: Graphics uses it for camera and projection pipelines.
  id: totrans-2886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形学使用它进行相机和投影管线。
- en: Both fields rely on the same linear algebra tricks - just applied differently.****  ***###
    93\. Graphs, Adjacency, and Laplacians (Networks via Matrices)
  id: totrans-2887
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两个领域都依赖于相同的线性代数技巧 - 只是应用方式不同。****  ***### 93. 图、邻接和拉普拉斯（通过矩阵的网络）
- en: 'Graphs can be studied with linear algebra by encoding them into matrices. Two
    of the most important:'
  id: totrans-2888
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将图编码到矩阵中，可以使用线性代数来研究图。其中两个最重要的：
- en: 'Adjacency matrix \(A\):'
  id: totrans-2889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '邻接矩阵 \(A\):'
- en: \[ A_{ij} = \begin{cases} 1 & \text{if edge between i and j exists} \\ 0 & \text{otherwise}
    \end{cases} \]
  id: totrans-2890
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ A_{ij} = \begin{cases} 1 & \text{if edge between i and j exists} \\ 0 & \text{otherwise}
    \end{cases} \]
- en: 'Graph Laplacian \(L\):'
  id: totrans-2891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图拉普拉斯矩阵 \(L\)：
- en: \[ L = D - A \]
  id: totrans-2892
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ L = D - A \]
- en: where \(D\) is the degree matrix ($D_{ii} = $ number of neighbors of node \(i\)).
  id: totrans-2893
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中 \(D\) 是度矩阵（\(D_{ii} = \) 节点 \(i\) 的邻居数量）。
- en: These matrices let us analyze connectivity, diffusion, and clustering.
  id: totrans-2894
  prefs: []
  type: TYPE_NORMAL
  zh: 这些矩阵让我们可以分析连通性、扩散和聚类。
- en: Set Up Your Lab
  id: totrans-2895
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE908]'
  id: totrans-2896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE908]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2897
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码解析'
- en: Build a simple graph
  id: totrans-2898
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个简单的图
- en: '[PRE909]'
  id: totrans-2899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE909]'
- en: '*![](../Images/64454ac990588fc1fce85afd3a8f321c.png)*  *2.  Adjacency matrix'
  id: totrans-2900
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/64454ac990588fc1fce85afd3a8f321c.png)*  *2.  邻接矩阵'
- en: '[PRE910]'
  id: totrans-2901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE910]'
- en: '*[PRE911]*  *3.  Degree and Laplacian matrices'
  id: totrans-2902
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE911]*  *3.  度矩阵和拉普拉斯矩阵'
- en: '[PRE912]'
  id: totrans-2903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE912]'
- en: '*[PRE913]*  *4.  Eigenvalues of Laplacian (connectivity check)'
  id: totrans-2904
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE913]*  *4.  拉普拉斯矩阵的特征值（连通性检查）'
- en: '[PRE914]'
  id: totrans-2905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE914]'
- en: '*[PRE915]*  **   The number of zero eigenvalues = number of connected components.'
  id: totrans-2906
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE915]*  **   零特征值的数量 = 连通分量的数量。'
- en: Spectral embedding (clustering)
  id: totrans-2907
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 谱嵌入（聚类）
- en: Use Laplacian eigenvectors to embed nodes in low dimensions.
  id: totrans-2908
  prefs: []
  type: TYPE_NORMAL
  zh: 使用拉普拉斯特征向量将节点嵌入低维空间。
- en: '[PRE916]'
  id: totrans-2909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE916]'
- en: '*![](../Images/7bf23ee5ccfd5962a5e494691da16e28.png)*****  ***#### Try It Yourself'
  id: totrans-2910
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/7bf23ee5ccfd5962a5e494691da16e28.png)*****  ***#### 尝试自己操作'
- en: Remove one edge from the graph and see how Laplacian eigenvalues change.
  id: totrans-2911
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从图中移除一条边，看看拉普拉斯特征值如何变化。
- en: Add a disconnected node - does an extra zero eigenvalue appear?
  id: totrans-2912
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个断开的节点 - 是否会出现额外的零特征值？
- en: Try a random graph and compare adjacency vs Laplacian spectra.
  id: totrans-2913
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试一个随机图，比较邻接矩阵和拉普拉斯矩阵的谱。
- en: The Takeaway
  id: totrans-2914
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 要点总结
- en: Adjacency matrices describe direct graph structure.
  id: totrans-2915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邻接矩阵描述了直接图结构。
- en: Laplacians capture connectivity and diffusion.
  id: totrans-2916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉普拉斯矩阵捕捉连通性和扩散。
- en: Eigenvalues of \(L\) reveal graph properties like connectedness and clustering
    - bridging networks with linear algebra.****  ***### 94\. Data Preprocessing as
    Linear Ops (Centering, Whitening, Scaling)
  id: totrans-2917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(L\) 的特征值揭示了图属性，如连通性和聚类 - 通过线性代数连接网络。****  ***### 94. 数据预处理作为线性操作（中心化、白化、缩放）
- en: Many machine learning and data analysis workflows begin with preprocessing,
    and linear algebra provides the tools.
  id: totrans-2918
  prefs: []
  type: TYPE_NORMAL
  zh: 许多机器学习和数据分析工作流程从预处理开始，而线性代数提供了工具。
- en: 'Centering: subtract the mean → move data to origin.'
  id: totrans-2919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 居中：减去均值 → 将数据移动到原点。
- en: 'Scaling: divide by standard deviation → normalize feature ranges.'
  id: totrans-2920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放：除以标准差 → 归一化特征范围。
- en: 'Whitening: decorrelate features → make covariance matrix the identity.'
  id: totrans-2921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 白化：去相关特征 → 使协方差矩阵为单位矩阵。
- en: Each step can be written as a matrix operation.
  id: totrans-2922
  prefs: []
  type: TYPE_NORMAL
  zh: 每一步都可以写成矩阵运算。
- en: Set Up Your Lab
  id: totrans-2923
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE917]'
  id: totrans-2924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE917]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2925
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码解析'
- en: Generate correlated data
  id: totrans-2926
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成相关数据
- en: '[PRE918]'
  id: totrans-2927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE918]'
- en: '*![](../Images/83f61c756302ce9f515ff46e0f531b64.png)*  *2.  Centering (subtract
    mean)'
  id: totrans-2928
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/83f61c756302ce9f515ff46e0f531b64.png)*  *2.  居中（减去均值）'
- en: '[PRE919]'
  id: totrans-2929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE919]'
- en: '*[PRE920]*  *3.  Scaling (normalize features)'
  id: totrans-2930
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE920]*  *3.  缩放（归一化特征）'
- en: '[PRE921]'
  id: totrans-2931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE921]'
- en: '*[PRE922]*  *4.  Whitening via eigen-decomposition'
  id: totrans-2932
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE922]*  *4.  通过特征分解进行白化'
- en: 'Covariance of centered data:'
  id: totrans-2933
  prefs: []
  type: TYPE_NORMAL
  zh: 居中数据的协方差：
- en: '[PRE923]'
  id: totrans-2934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE923]'
- en: '*Check covariance:'
  id: totrans-2935
  prefs: []
  type: TYPE_NORMAL
  zh: '*检查协方差：'
- en: '[PRE924]'
  id: totrans-2936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE924]'
- en: '*[PRE925]*  *5.  Compare scatter plots'
  id: totrans-2937
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE925]*  *5.  比较散点图'
- en: '[PRE926]'
  id: totrans-2938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE926]'
- en: '*![](../Images/e4d5724724602e6457dd4b8a6a6d0e8e.png)*  **   Original: elongated
    ellipse.'
  id: totrans-2939
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/e4d5724724602e6457dd4b8a6a6d0e8e.png)*  **   原始：拉长的椭圆。'
- en: 'Scaled: axis-aligned ellipse.'
  id: totrans-2940
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放后的：轴对齐的椭圆。
- en: 'Whitened: circular cloud (uncorrelated, unit variance).******  ***#### Try
    It Yourself'
  id: totrans-2941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 白化：圆形云（去相关，单位方差）。******  ***#### 尝试自己操作
- en: Add a third feature and apply centering, scaling, whitening.
  id: totrans-2942
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第三个特征并应用居中和缩放。
- en: Compare whitening with PCA - they use the same eigen-decomposition.
  id: totrans-2943
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较白化与PCA - 它们使用相同的特征分解。
- en: Test what happens if you skip centering before whitening.
  id: totrans-2944
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试在白化之前跳过居中会发生什么。
- en: The Takeaway
  id: totrans-2945
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Centering → mean zero.
  id: totrans-2946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 居中 → 均值为零。
- en: Scaling → unit variance.
  id: totrans-2947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放 → 单位方差。
- en: Whitening → features uncorrelated, variance = 1\. Linear algebra provides the
    exact matrix operations to make preprocessing systematic and reliable.****  ***###
    95\. Linear Regression and Classification (From Model to Matrix)
  id: totrans-2948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 白化 → 特征去相关，方差 = 1。线性代数提供了精确的矩阵运算，使预处理系统化和可靠。****  ***### 95. 线性回归与分类（从模型到矩阵）
- en: Linear regression and classification problems can be written neatly in matrix
    form. This unifies data, models, and solutions under the framework of least squares
    and linear decision boundaries.
  id: totrans-2949
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归和分类问题可以简洁地写成矩阵形式。这统一了数据、模型和解决方案，在最小二乘法和线性决策边界框架下。
- en: Linear Regression Model
  id: totrans-2950
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 线性回归模型
- en: 'For data \((x_i, y_i)\):'
  id: totrans-2951
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据 \((x_i, y_i)\)：
- en: \[ y \approx X \beta \]
  id: totrans-2952
  prefs: []
  type: TYPE_NORMAL
  zh: \[ y \approx X \beta \]
- en: '\(X\): design matrix (rows = samples, columns = features).'
  id: totrans-2953
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '\(X\): 设计矩阵（行 = 样本，列 = 特征）。'
- en: '\(\beta\): coefficients to solve for.'
  id: totrans-2954
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '\(\beta\): 需要解决的系数。'
- en: 'Solution (least squares):'
  id: totrans-2955
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案（最小二乘法）：
- en: \[ \hat{\beta} = (X^T X)^{-1} X^T y \]
  id: totrans-2956
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \hat{\beta} = (X^T X)^{-1} X^T y \]
- en: Set Up Your Lab
  id: totrans-2957
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE927]'
  id: totrans-2958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE927]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2959
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码解析'
- en: Linear regression example
  id: totrans-2960
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线性回归示例
- en: '[PRE928]'
  id: totrans-2961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE928]'
- en: '*Construct design matrix with bias term:'
  id: totrans-2962
  prefs: []
  type: TYPE_NORMAL
  zh: '*构建包含偏差项的设计矩阵：'
- en: '[PRE929]'
  id: totrans-2963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE929]'
- en: '*[PRE930]*  *2.  Visualize regression line'
  id: totrans-2964
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE930]*  *2.  可视化回归线'
- en: '[PRE931]'
  id: totrans-2965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE931]'
- en: '*![](../Images/6560e0e35a5165b504ed382e39863911.png)*  *3.  Logistic classification
    with linear decision boundary'
  id: totrans-2966
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/6560e0e35a5165b504ed382e39863911.png)*  *3.  使用线性决策边界的逻辑分类'
- en: '[PRE932]'
  id: totrans-2967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE932]'
- en: '*![](../Images/746ac3324b672f64a27d021da35ddb4b.png)*  *4.  Logistic regression
    via gradient descent'
  id: totrans-2968
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/746ac3324b672f64a27d021da35ddb4b.png)*  *4.  通过梯度下降进行逻辑回归'
- en: '[PRE933]'
  id: totrans-2969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE933]'
- en: '*[PRE934]*  *5.  Plot decision boundary'
  id: totrans-2970
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE934]*  *5.  绘制决策边界'
- en: '[PRE935]'
  id: totrans-2971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE935]'
- en: '*![](../Images/1495dc2e5e9463526c81e6ca48ecb775.png)******  ***#### Try It
    Yourself'
  id: totrans-2972
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/1495dc2e5e9463526c81e6ca48ecb775.png)******  ***#### 尝试自己操作'
- en: Add polynomial features to regression and refit. Does the line bend into a curve?
  id: totrans-2973
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将多项式特征添加到回归中并重新拟合。线会弯曲成曲线吗？
- en: Change learning rate in logistic regression - what happens?
  id: totrans-2974
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变逻辑回归中的学习率 - 会发生什么？
- en: Generate data that is not linearly separable. Can a linear model still classify
    well?
  id: totrans-2975
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成非线性可分的数据。线性模型还能很好地分类吗？
- en: The Takeaway
  id: totrans-2976
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Regression and classification fit naturally into linear algebra with matrix
    formulations.
  id: totrans-2977
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回归和分类自然地融入线性代数，使用矩阵公式。
- en: Least squares solves regression directly; logistic regression requires optimization.
  id: totrans-2978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小二乘法直接解决回归问题；逻辑回归需要优化。
- en: Linear models are simple, interpretable, and still form the foundation of modern
    machine learning.****  ***### 96\. PCA in Practice (Dimensionality Reduction Workflow)
  id: totrans-2979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性模型简单、可解释，仍然是现代机器学习的基础。****  ***### 96. 实践中的主成分分析（降维工作流程）
- en: 'Principal Component Analysis (PCA) is widely used to reduce dimensions, compress
    data, and visualize high-dimensional datasets. Here, we’ll walk through a full
    PCA workflow: centering, computing components, projecting, and visualizing.'
  id: totrans-2980
  prefs: []
  type: TYPE_NORMAL
  zh: 主成分分析（PCA）被广泛用于降低维度、压缩数据和可视化高维数据集。在这里，我们将通过完整的PCA工作流程进行讲解：中心化、计算成分、投影和可视化。
- en: Set Up Your Lab
  id: totrans-2981
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE936]'
  id: totrans-2982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE936]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-2983
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Load dataset (digits)
  id: totrans-2984
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载数据集（数字）
- en: '[PRE937]'
  id: totrans-2985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE937]'
- en: '*[PRE938]*  *Each sample is an 8×8 grayscale image flattened into 64 features.'
  id: totrans-2986
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE938]*  *每个样本是一个8×8的灰度图像，展平成64个特征。'
- en: Center the data
  id: totrans-2987
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据中心化
- en: '[PRE939]'
  id: totrans-2988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE939]'
- en: '*3.  Compute PCA via SVD'
  id: totrans-2989
  prefs: []
  type: TYPE_NORMAL
  zh: '*3. 通过SVD计算PCA'
- en: '[PRE940]'
  id: totrans-2990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE940]'
- en: '*4.  Plot explained variance ratio'
  id: totrans-2991
  prefs: []
  type: TYPE_NORMAL
  zh: '*4. 绘制解释方差比'
- en: '[PRE941]'
  id: totrans-2992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE941]'
- en: '*![](../Images/c9dfb11d79fcd239fa71a8fca008b253.png)*  *This shows how many
    components are needed to capture most variance.'
  id: totrans-2993
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/c9dfb11d79fcd239fa71a8fca008b253.png)*  *这显示了需要多少个成分来捕捉大部分方差。'
- en: Project onto top 2 components for visualization
  id: totrans-2994
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 投影到前两个成分进行可视化
- en: '[PRE942]'
  id: totrans-2995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE942]'
- en: '*![](../Images/bba1df82965a0bded492822a0b9ee15c.png)*  *6.  Reconstruct images
    from reduced dimensions'
  id: totrans-2996
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/bba1df82965a0bded492822a0b9ee15c.png)*  *6. 从降低的维度重建图像'
- en: '[PRE943]'
  id: totrans-2997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE943]'
- en: '*![](../Images/95baf6363b8fe5096cf9552d4c46bb36.png)*  *Even with only 20/64
    components, the digits remain recognizable.******  ***#### Try It Yourself'
  id: totrans-2998
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/95baf6363b8fe5096cf9552d4c46bb36.png)*  *即使只有20/64个成分，数字仍然可识别。******  ***####
    尝试自己操作'
- en: Change \(k\) to 5, 10, 30 - how do reconstructions change?
  id: totrans-2999
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将\(k\)改为5，10，30 - 重建如何变化？
- en: Use top 2 PCA components to classify digits with k-NN. How does accuracy compare
    to full 64 features?
  id: totrans-3000
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前两个PCA成分用k-NN对数字进行分类。准确率与完整的64个特征相比如何？
- en: Try PCA on your own dataset (images, tabular data).
  id: totrans-3001
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的数据集（图像、表格数据）上尝试PCA。
- en: The Takeaway
  id: totrans-3002
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**要点**'
- en: PCA reduces dimensions while keeping maximum variance.
  id: totrans-3003
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PCA在保持最大方差的同时减少维度。
- en: 'In practice: center → decompose → select top components → project/reconstruct.'
  id: totrans-3004
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际操作：中心化 → 分解 → 选择前几个成分 → 投影/重建。
- en: PCA enables visualization, compression, and denoising in real-world workflows.****  ***###
    97\. Recommender Systems and Low-Rank Models (Fill the Missing Entries)
  id: totrans-3005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PCA在现实世界的流程中实现了可视化、压缩和去噪。****  ***### 97. 推荐系统和低秩模型（填充缺失条目）
- en: Recommender systems often deal with incomplete matrices - rows are users, columns
    are items, entries are ratings. Most entries are missing, but the matrix is usually
    close to low-rank (because user preferences depend on only a few hidden factors).
    SVD and low-rank approximations are powerful tools to fill in these missing values.
  id: totrans-3006
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐系统通常处理不完整的矩阵 - 行是用户，列是项目，条目是评分。大多数条目是缺失的，但矩阵通常接近低秩（因为用户偏好只依赖于几个隐藏因素）。SVD和低秩近似是填充这些缺失值的有力工具。
- en: Set Up Your Lab
  id: totrans-3007
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE944]'
  id: totrans-3008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE944]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-3009
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Simulate a user–item rating matrix
  id: totrans-3010
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟用户-项目评分矩阵
- en: '[PRE945]'
  id: totrans-3011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE945]'
- en: '*2.  Hide some ratings (simulate missing data)'
  id: totrans-3012
  prefs: []
  type: TYPE_NORMAL
  zh: '*2. 隐藏一些评分（模拟缺失数据）*'
- en: '[PRE946]'
  id: totrans-3013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE946]'
- en: '*[PRE947]*  *3.  Simple mean imputation (baseline)'
  id: totrans-3014
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE947]*  *3. 简单均值填充（基线）'
- en: '[PRE948]'
  id: totrans-3015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE948]'
- en: '*4.  Apply SVD for low-rank approximation'
  id: totrans-3016
  prefs: []
  type: TYPE_NORMAL
  zh: '*4. 应用SVD进行低秩近似'
- en: '[PRE949]'
  id: totrans-3017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE949]'
- en: '*5.  Compare filled matrix with ground truth'
  id: totrans-3018
  prefs: []
  type: TYPE_NORMAL
  zh: '*5. 比较填充矩阵与真实值'
- en: '[PRE950]'
  id: totrans-3019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE950]'
- en: '*[PRE951]*  *6.  Visualize original vs reconstructed'
  id: totrans-3020
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE951]*  *6. 可视化原始与重建'
- en: '[PRE952]'
  id: totrans-3021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE952]'
- en: '*![](../Images/65f1b5f72f46628f26c27205b43af635.png)******  ***#### Try It
    Yourself'
  id: totrans-3022
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/65f1b5f72f46628f26c27205b43af635.png)******  ***#### 尝试自己操作'
- en: Vary \(k\) (2, 3, 5). Does error go down?
  id: totrans-3023
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变\(k\)（2，3，5）。错误会下降吗？
- en: Mask more entries (50%, 80%) - how does SVD reconstruction perform?
  id: totrans-3024
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遮盖更多条目（50%，80%） - SVD重建的表现如何？
- en: 'Use iterative imputation: alternate filling missing entries with low-rank approximations.'
  id: totrans-3025
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用迭代填充：交替使用低秩近似填充缺失条目。
- en: The Takeaway
  id: totrans-3026
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**要点**'
- en: Recommender systems rely on low-rank structure of user–item matrices.
  id: totrans-3027
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐系统依赖于用户-项目矩阵的低秩结构。
- en: SVD provides a natural way to approximate and fill missing ratings.
  id: totrans-3028
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SVD提供了一种自然的方法来近似和填充缺失的评分。
- en: This low-rank modeling idea underpins modern collaborative filtering systems
    like Netflix and Spotify recommenders.****  ***### 98\. PageRank and Random Walks
    (Ranking with Eigenvectors)
  id: totrans-3029
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种低秩建模思想是现代协同过滤系统（如Netflix和Spotify推荐系统）的基础。****  ***### 98. PageRank和随机游走（使用特征向量进行排名）
- en: 'The PageRank algorithm, made famous by Google, uses linear algebra and random
    walks on graphs to rank nodes (webpages, people, items). The idea: importance
    flows through links - being linked by important nodes makes you important.'
  id: totrans-3030
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank算法，由Google使其闻名，使用线性代数和图上的随机游走来对节点（网页、人物、项目）进行排名。思想：重要性通过链接流动 - 被重要节点链接使你变得重要。
- en: The PageRank Idea
  id: totrans-3031
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**PageRank思想**'
- en: 'Start a random walk on a graph: at each step, move to a random neighbor.'
  id: totrans-3032
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图上开始随机游走：在每一步，移动到随机邻居。
- en: Add a “teleportation” step with probability \(1 - \alpha\) to avoid dead ends.
  id: totrans-3033
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个概率为\(1 - \alpha\)的“传送”步骤以避免死胡同。
- en: The steady-state distribution of this walk is the PageRank vector, found as
    the principal eigenvector of the transition matrix.
  id: totrans-3034
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此游走的稳态分布是PageRank向量，它是作为转换矩阵的主特征向量找到的。
- en: Set Up Your Lab
  id: totrans-3035
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE953]'
  id: totrans-3036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE953]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-3037
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Build a small directed graph
  id: totrans-3038
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个小有向图
- en: '[PRE954]'
  id: totrans-3039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE954]'
- en: '*![](../Images/440b6f5f30f2c7ae2cd5fdb8916a4abf.png)*  *2.  Build adjacency
    and transition matrix'
  id: totrans-3040
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/440b6f5f30f2c7ae2cd5fdb8916a4abf.png)*  *2.  构建邻接和转换矩阵'
- en: '[PRE955]'
  id: totrans-3041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE955]'
- en: '*3.  Add teleportation (Google matrix)'
  id: totrans-3042
  prefs: []
  type: TYPE_NORMAL
  zh: '*3.  添加传送（Google矩阵）'
- en: '[PRE956]'
  id: totrans-3043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE956]'
- en: '*4.  Power iteration to compute PageRank'
  id: totrans-3044
  prefs: []
  type: TYPE_NORMAL
  zh: '*4.  功迭代计算PageRank'
- en: '[PRE957]'
  id: totrans-3045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE957]'
- en: '*[PRE958]*  *5.  Compare with NetworkX built-in'
  id: totrans-3046
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE958]*  *5.  与NetworkX内置比较'
- en: '[PRE959]'
  id: totrans-3047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE959]'
- en: '*[PRE960]*  *6.  Visualize node importance'
  id: totrans-3048
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE960]*  *6.  可视化节点重要性'
- en: '[PRE961]'
  id: totrans-3049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE961]'
- en: '*![](../Images/ac7f2dd680a381cbf94a5abf3494be32.png)******  ***#### Try It
    Yourself'
  id: totrans-3050
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/ac7f2dd680a381cbf94a5abf3494be32.png)******  ***#### 尝试自己操作'
- en: Change \(\alpha\) (e.g., 0.6 vs 0.95). Does ranking change?
  id: totrans-3051
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变\(\alpha\)（例如，0.6与0.95）。排名会改变吗？
- en: Add a “dangling node” with no outlinks. How does teleportation handle it?
  id: totrans-3052
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个没有出链的“悬空节点”。传送如何处理它？
- en: Try PageRank on a larger graph (like a random graph with 50 nodes).
  id: totrans-3053
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更大的图（如具有50个节点的随机图）上尝试PageRank。
- en: The Takeaway
  id: totrans-3054
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: PageRank is a random-walk steady state problem.
  id: totrans-3055
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PageRank是一个随机游走稳态问题。
- en: It reduces to finding the dominant eigenvector of the Google matrix.
  id: totrans-3056
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这简化为寻找Google矩阵的主特征向量。
- en: This method generalizes beyond webpages - to influence ranking, recommendation,
    and network analysis.****  ***### 99\. Numerical Linear Algebra Essentials (Floating
    Point, BLAS/LAPACK)
  id: totrans-3057
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法推广到网页之外 - 影响排名、推荐和网络分析。****  ***### 99. 数值线性代数基础（浮点，BLAS/LAPACK）
- en: When working with linear algebra on computers, numbers are not exact. They live
    in floating-point arithmetic, and computations rely on highly optimized libraries
    like BLAS and LAPACK. Understanding these essentials is crucial to doing linear
    algebra at scale.
  id: totrans-3058
  prefs: []
  type: TYPE_NORMAL
  zh: 当在计算机上处理线性代数时，数字并不精确。它们存在于浮点运算中，计算依赖于高度优化的库，如BLAS和LAPACK。理解这些基本知识对于进行大规模线性代数计算至关重要。
- en: Floating Point Basics
  id: totrans-3059
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 浮点基础
- en: 'Numbers are stored in base-2 scientific notation:'
  id: totrans-3060
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字以2为底的科学记数法存储：
- en: \[ x = \pm (1.b_1b_2b_3\ldots) \times 2^e \]
  id: totrans-3061
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[ x = \pm (1.b_1b_2b_3\ldots) \times 2^e \]
- en: Limited precision means rounding errors.
  id: totrans-3062
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有限精度意味着舍入误差。
- en: 'Two key constants:'
  id: totrans-3063
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个关键常数：
- en: 'Machine epsilon ($\(): smallest difference detectable (\)^{-16}$ for double).'
  id: totrans-3064
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器epsilon（$\()：可检测的最小差异（\(2^{-16}\)）对于双精度。
- en: 'Overflow/underflow: too large or too small to represent.'
  id: totrans-3065
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 溢出/下溢：太大或太小以至于无法表示。
- en: Set Up Your Lab
  id: totrans-3066
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置您的实验室
- en: '[PRE962]'
  id: totrans-3067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE962]'
- en: '*#### Step-by-Step Code Walkthrough'
  id: totrans-3068
  prefs: []
  type: TYPE_NORMAL
  zh: '*#### 逐步代码讲解'
- en: Machine epsilon
  id: totrans-3069
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 机器epsilon
- en: '[PRE963]'
  id: totrans-3070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE963]'
- en: '*[PRE964]*  *2.  Round-off error demo'
  id: totrans-3071
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE964]*  *2.  四舍五入误差演示'
- en: '[PRE965]'
  id: totrans-3072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE965]'
- en: '*[PRE966]*  *3.  Stability of matrix inversion'
  id: totrans-3073
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE966]*  *3.  矩阵求逆的稳定性'
- en: '[PRE967]'
  id: totrans-3074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE967]'
- en: '*[PRE968]*  *Notice: using `np.linalg.inv` can be less stable - better to solve
    directly.'
  id: totrans-3075
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE968]*  *注意：使用`np.linalg.inv`可能不太稳定 - 最好直接求解。'
- en: Conditioning of a matrix
  id: totrans-3076
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩阵的条件
- en: '[PRE969]'
  id: totrans-3077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE969]'
- en: '*[PRE970]*  **   Large condition number → small input changes cause big output
    changes.'
  id: totrans-3078
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE970]*  **   大条件数 → 小输入变化导致大输出变化。'
- en: BLAS/LAPACK under the hood
  id: totrans-3079
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BLAS/LAPACK内部
- en: '[PRE971]'
  id: totrans-3080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE971]'
- en: '*This `@` operator is not a naive loop - it calls a highly optimized C/Fortran
    routine.*****  ***#### Try It Yourself'
  id: totrans-3081
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个`@`运算符不是一个简单的循环 - 它调用一个高度优化的C/Fortran例程。*****  ***#### 尝试自己操作'
- en: Compare solving `Ax = b` with `np.linalg.solve` vs `np.linalg.inv(A) @ b` for
    larger, ill-conditioned systems.
  id: totrans-3082
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较解决`Ax = b`与`np.linalg.solve`和`np.linalg.inv(A) @ b`对于更大、条件较差的系统。
- en: Use `np.linalg.svd` on a nearly singular matrix. How stable are the singular
    values?
  id: totrans-3083
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在几乎奇异的矩阵上使用`np.linalg.svd`。奇异值有多稳定？
- en: 'Check performance: time `A @ B` for sizes 100, 500, 1000.'
  id: totrans-3084
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查性能：对于大小为100、500、1000的情况，计算`A @ B`的时间。
- en: The Takeaway
  id: totrans-3085
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: Numerical linear algebra = math + floating-point reality.
  id: totrans-3086
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值线性代数 = 数学 + 浮点现实。
- en: Always prefer stable algorithms (`solve`, `qr`, `svd`) over naive inversion.
  id: totrans-3087
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是优先选择稳定的算法（`solve`、`qr`、`svd`）而不是简单的求逆。
- en: Libraries like BLAS/LAPACK make large computations fast, but understanding precision
    and conditioning prevents nasty surprises.****  ***### 100\. Capstone Problem
    Sets and Next Steps (A Roadmap to Mastery)
  id: totrans-3088
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于BLAS/LAPACK的库可以使大型计算变得快速，但理解精度和条件可以防止出现令人惊讶的问题。****  ***### 100. 终极问题集和下一步（精通之路）
- en: This final section ties everything together. Instead of introducing a new topic,
    it provides capstone labs that combine multiple ideas from the book. Working through
    them will give you confidence that you can apply linear algebra to real problems.
  id: totrans-3089
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将所有内容串联起来。它不是引入一个新主题，而是提供了结合书中多个想法的基石实验室。通过解决这些问题，你会对自己能够将线性代数应用于实际问题充满信心。
- en: Problem Set 1 - Image Compression with SVD
  id: totrans-3090
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 问题集 1 - 使用SVD进行图像压缩
- en: Take an image, treat it as a matrix, and approximate it with low-rank SVD.
  id: totrans-3091
  prefs: []
  type: TYPE_NORMAL
  zh: 将图像视为矩阵，并用低秩奇异值分解（SVD）对其进行近似。
- en: '[PRE972]'
  id: totrans-3092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE972]'
- en: '*![](../Images/c0af6e97c0f8e3944a13019cad97b6ec.png)*  *Try different \(k\)
    values (5, 20, 100). How does quality vs. compression trade off?*  *#### Problem
    Set 2 - Predictive Modeling with PCA + Regression'
  id: totrans-3093
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/c0af6e97c0f8e3944a13019cad97b6ec.png)*  *尝试不同的\(k\)值（5、20、100）。质量和压缩之间的权衡如何？*  *####
    问题集 2 - 使用PCA + 回归进行预测建模'
- en: Combine PCA for dimensionality reduction with linear regression for prediction.
  id: totrans-3094
  prefs: []
  type: TYPE_NORMAL
  zh: 将降维的PCA与预测的线性回归相结合。
- en: '[PRE973]'
  id: totrans-3095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE973]'
- en: '*[PRE974]*  *Does reducing dimensions improve or hurt accuracy?*  *#### Problem
    Set 3 - Graph Analysis with PageRank'
  id: totrans-3096
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE974]*  *降低维度会提高还是损害准确性？*  *#### 问题集 3 - 使用PageRank进行图分析'
- en: Apply PageRank to a custom-built network.
  id: totrans-3097
  prefs: []
  type: TYPE_NORMAL
  zh: 将PageRank应用于自定义网络。
- en: '[PRE975]'
  id: totrans-3098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE975]'
- en: '*![](../Images/81b77d4fb0ee96e5b3ce5fc6ce9a7ac3.png)*  *Which nodes dominate?
    How does structure affect ranking?*  *#### Problem Set 4 - Solving Differential
    Equations with Eigen Decomposition'
  id: totrans-3099
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](../Images/81b77d4fb0ee96e5b3ce5fc6ce9a7ac3.png)*  *哪些节点占主导地位？结构如何影响排名？*  *####
    问题集 4 - 使用特征分解求解微分方程'
- en: Use eigenvalues/eigenvectors to solve a linear dynamical system.
  id: totrans-3100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特征值/特征向量求解线性动态系统。
- en: '[PRE976]'
  id: totrans-3101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE976]'
- en: '*[PRE977]*  *Predict long-term behavior: will the system decay, oscillate,
    or grow?*  *#### Problem Set 5 - Least Squares for Overdetermined Systems'
  id: totrans-3102
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE977]*  *预测长期行为：系统会衰减、振荡还是增长？*  *#### 问题集 5 - 对定系统使用最小二乘法'
- en: '[PRE978]'
  id: totrans-3103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE978]'
- en: '*[PRE979]*  *Compare estimated vs. true coefficients. How close are they?*  *####
    Try It Yourself'
  id: totrans-3104
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE979]*  *比较估计系数与真实系数。它们有多接近？*  *#### 尝试自己来做'
- en: Combine SVD and recommender systems - build a movie recommender with synthetic
    data.
  id: totrans-3105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结合SVD和推荐系统——使用合成数据构建电影推荐系统。
- en: Implement Gram–Schmidt by hand and test it against `np.linalg.qr`.
  id: totrans-3106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动实现Gram-Schmidt过程，并用`np.linalg.qr`进行测试。
- en: Write a mini “linear algebra toolkit” with your favorite helper functions.
  id: totrans-3107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个包含你最喜欢的辅助函数的迷你“线性代数工具包”。
- en: The Takeaway
  id: totrans-3108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 吸收要点
- en: You’ve practiced vectors, matrices, systems, eigenvalues, SVD, PCA, PageRank,
    and more.
  id: totrans-3109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经练习了向量、矩阵、系统、特征值、SVD、PCA、PageRank等内容。
- en: Real problems often combine multiple concepts - the labs show how everything
    fits together.
  id: totrans-3110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真实问题通常结合多个概念——实验室展示了所有这些是如何相互关联的。
- en: 'Next steps: dive deeper into numerical linear algebra, explore machine learning
    applications, or study advanced matrix factorizations (Jordan form, tensor decompositions).'
  id: totrans-3111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一步：深入研究数值线性代数，探索机器学习应用，或研究高级矩阵分解（Jordan形式、张量分解）。
- en: This concludes the hands-on journey. By now, you don’t just know the theory
    - you can use linear algebra as a working tool in Python for data, science, and
    engineering.***********************************************************
  id: totrans-3112
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着动手实践的结束。到现在为止，你不仅了解了理论——你还可以将线性代数作为Python中用于数据、科学和工程的实用工具。
