- en: 5.1Â From Tables to ListsğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.1 ä»è¡¨æ ¼åˆ°åˆ—è¡¨ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/tables-to-lists.html](https://dcic-world.org/2025-08-27/tables-to-lists.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/tables-to-lists.html](https://dcic-world.org/2025-08-27/tables-to-lists.html)
- en: '| Â Â Â Â [5.1.1Â Basic Statistical Questions](#%28part._table-stat-qs%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   [5.1.1 åŸºæœ¬ç»Ÿè®¡é—®é¢˜](#%28part._table-stat-qs%29) |'
- en: '| Â Â Â Â [5.1.2Â Extracting a Column from a Table](#%28part._.Extracting_a_.Column_from_a_.Table%29)
    |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|   [5.1.2 ä»è¡¨æ ¼ä¸­æå–åˆ—](#%28part._.Extracting_a_.Column_from_a_.Table%29) |'
- en: '| Â Â Â Â [5.1.3Â Understanding Lists](#%28part._.Understanding_.Lists%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|   [5.1.3 ç†è§£åˆ—è¡¨](#%28part._.Understanding_.Lists%29) |'
- en: '| Â Â Â Â Â Â [5.1.3.1Â Lists as Anonymous Data](#%28part._lists-generic-data%29)
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|   [5.1.3.1 åˆ—ä½œä¸ºåŒ¿åæ•°æ®](#%28part._lists-generic-data%29) |'
- en: '| Â Â Â Â Â Â [5.1.3.2Â Creating Literal Lists](#%28part._.Creating_.Literal_.Lists%29)
    |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|   [5.1.3.2 åˆ›å»ºæ–‡æœ¬åˆ—è¡¨](#%28part._.Creating_.Literal_.Lists%29) |'
- en: '| Â Â Â Â [5.1.4Â Operating on Lists](#%28part._.Operating_on_.Lists%29) |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|   [5.1.4 æ“ä½œåˆ—è¡¨](#%28part._.Operating_on_.Lists%29) |'
- en: '| Â Â Â Â Â Â [5.1.4.1Â Built-In Operations on Lists of Numbers](#%28part._.Built-.In_.Operations_on_.Lists_of_.Numbers%29)
    |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|   [5.1.4.1 æ•°å­—åˆ—è¡¨çš„å†…ç½®æ“ä½œ](#%28part._.Built-.In_.Operations_on_.Lists_of_.Numbers%29)
    |'
- en: '| Â Â Â Â Â Â [5.1.4.2Â Built-In Operations on Lists in General](#%28part._.Built-.In_.Operations_on_.Lists_in_.General%29)
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|   [5.1.4.2 åˆ—è¡¨çš„ä¸€èˆ¬å†…ç½®æ“ä½œ](#%28part._.Built-.In_.Operations_on_.Lists_in_.General%29)
    |'
- en: '| Â Â Â Â Â Â [5.1.4.3Â An Aside on Naming Conventions](#%28part._.An_.Aside_on_.Naming_.Conventions%29)
    |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|   [5.1.4.3 å…³äºå‘½åçº¦å®šçš„è¯´æ˜](#%28part._.An_.Aside_on_.Naming_.Conventions%29) |'
- en: '| Â Â Â Â Â Â [5.1.4.4Â Getting Elements By Position](#%28part._.Getting_.Elements_.By_.Position%29)
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|   [5.1.4.4 é€šè¿‡ä½ç½®è·å–å…ƒç´ ](#%28part._.Getting_.Elements_.By_.Position%29) |'
- en: '| Â Â Â Â Â Â [5.1.4.5Â Transforming Lists](#%28part._.Transforming_.Lists%29) |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|   [5.1.4.5 åˆ—è¡¨çš„è½¬æ¢](#%28part._.Transforming_.Lists%29) |'
- en: '| Â Â Â Â Â Â [5.1.4.6Â Recap: Summary of List Operations](#%28part._lists-recap%29)
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|   [5.1.4.6 å›é¡¾ï¼šåˆ—è¡¨æ“ä½œæ‘˜è¦](#%28part._lists-recap%29) |'
- en: '| Â Â Â Â [5.1.5Â Lambda: Anonymous Functions](#%28part._.Lambda__.Anonymous_.Functions%29)
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|   [5.1.5 Lambdaï¼šåŒ¿åå‡½æ•°](#%28part._.Lambda__.Anonymous_.Functions%29) |'
- en: '| Â Â Â Â [5.1.6Â Combining Lists and Tables](#%28part._.Combining_.Lists_and_.Tables%29)
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|   [5.1.6 ç»“åˆåˆ—è¡¨å’Œè¡¨æ ¼](#%28part._.Combining_.Lists_and_.Tables%29) |'
- en: Previously [[Introduction to Tabular Data](intro-tabular-data.html)] we began
    to process collective data in the form of tables. Though we saw several powerful
    operations that let us quickly and easily ask sophisticated questions about our
    data, they all had two things in common. First, all were operations by rows. None
    of the operations asked questions about an entire column at a time. Second, all
    the operations not only consumed but also produced tables. However, we already
    know [[Getting Started](getting-started.html)] there are many other kinds of data,
    and sometimes we will want to compute one of them. We will now see how to achieve
    both of these things, introducing an important new type of data in the process.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¹‹å‰ [[è¡¨æ ¼æ•°æ®ç®€ä»‹](intro-tabular-data.html)] æˆ‘ä»¬å¼€å§‹ä»¥è¡¨æ ¼å½¢å¼å¤„ç†é›†ä½“æ•°æ®ã€‚è™½ç„¶æˆ‘ä»¬çœ‹åˆ°äº†å‡ ä¸ªå¼ºå¤§çš„æ“ä½œï¼Œè®©æˆ‘ä»¬èƒ½å¤Ÿå¿«é€Ÿè½»æ¾åœ°æå‡ºå…³äºæ•°æ®çš„é«˜çº§é—®é¢˜ï¼Œä½†å®ƒä»¬æœ‰ä¸¤ä¸ªå…±åŒç‚¹ã€‚é¦–å…ˆï¼Œæ‰€æœ‰æ“ä½œéƒ½æ˜¯æŒ‰è¡Œè¿›è¡Œçš„ã€‚æ²¡æœ‰æ“ä½œä¸€æ¬¡è¯¢é—®æ•´ä¸ªåˆ—çš„é—®é¢˜ã€‚å…¶æ¬¡ï¼Œæ‰€æœ‰æ“ä½œä¸ä»…æ¶ˆè€—äº†æ•°æ®ï¼Œè¿˜äº§ç”Ÿäº†è¡¨æ ¼ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å·²çŸ¥
    [[å…¥é—¨](getting-started.html)] è¿˜æœ‰è®¸å¤šå…¶ä»–ç±»å‹çš„æ•°æ®ï¼Œæœ‰æ—¶æˆ‘ä»¬å¯èƒ½æƒ³è¦è®¡ç®—å…¶ä¸­ä¹‹ä¸€ã€‚ç°åœ¨æˆ‘ä»¬å°†çœ‹åˆ°å¦‚ä½•å®ç°è¿™ä¸¤ä»¶äº‹ï¼Œåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­å¼•å…¥ä¸€ä¸ªé‡è¦çš„æ–°æ•°æ®ç±»å‹ã€‚
- en: 5.1.1Â Basic Statistical Questions[ğŸ”—](#(part._table-stat-qs) "Link to here")
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.1 åŸºæœ¬ç»Ÿè®¡é—®é¢˜[ğŸ”—](#(part._table-stat-qs) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'There are many more questions we might want to ask of our events data. For
    instance:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯èƒ½è¿˜æƒ³å¯¹äº‹ä»¶æ•°æ®æå‡ºæ›´å¤šé—®é¢˜ã€‚ä¾‹å¦‚ï¼š
- en: The most-frequently used discount code.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœ€å¸¸ä½¿ç”¨çš„æŠ˜æ‰£ä»£ç ã€‚
- en: The average number of tickets per order.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¯ä¸ªè®¢å•çš„å¹³å‡ç¥¨æ•°ã€‚
- en: The largest ticket order.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœ€å¤§çš„ç¥¨è®¢å•ã€‚
- en: The most common number of tickets in an order.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è®¢å•ä¸­æœ€å¸¸è§çš„ç¥¨æ•°ã€‚
- en: The collection of unique discount codes that were used (many might have been
    available).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å·²ä½¿ç”¨çš„ç‹¬ç‰¹æŠ˜æ‰£ä»£ç é›†åˆï¼ˆå¯èƒ½æœ‰å¾ˆå¤šï¼‰ã€‚
- en: The collection of distinct email addresses associated with orders, so we can
    contact customers (some customers may have placed multiple orders).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸è®¢å•ç›¸å…³è”çš„ç‹¬ç«‹ç”µå­é‚®ä»¶åœ°å€é›†åˆï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥è”ç³»å®¢æˆ·ï¼ˆä¸€äº›å®¢æˆ·å¯èƒ½å·²ä¸‹è¿‡å¤šä¸ªè®¢å•ï¼‰ã€‚
- en: Which school lead to the largest number of orders with a `"STUDENT"` discount.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å“ªæ‰€å­¦æ ¡å¯¼è‡´äº†å…·æœ‰ `"STUDENT"` æŠ˜æ‰£çš„æœ€å¤§è®¢å•æ•°é‡ã€‚
- en: 'Notice the kinds of operations that we are talking about: computing the maximum,
    minimum, average, median, and other basic statistics.Pyret has several built-in
    statistics functions in the [math](http://www.pyret.org/docs/latest/math.html)
    and [statistics](http://www.pyret.org/docs/latest/statistics.html) packages.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„æˆ‘ä»¬æ­£åœ¨è®¨è®ºçš„æ“ä½œç±»å‹ï¼šè®¡ç®—æœ€å¤§å€¼ã€æœ€å°å€¼ã€å¹³å‡å€¼ã€ä¸­ä½æ•°å’Œå…¶ä»–åŸºæœ¬ç»Ÿè®¡æ•°æ®ã€‚Pyret åœ¨ [math](http://www.pyret.org/docs/latest/math.html)
    å’Œ [statistics](http://www.pyret.org/docs/latest/statistics.html) åŒ…ä¸­æä¾›äº†å‡ ä¸ªå†…ç½®çš„ç»Ÿè®¡å‡½æ•°ã€‚
- en: Do Now!
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Think about whether and how you would express these questions with the operations
    you have already seen.
  id: totrans-29
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ€è€ƒä¸€ä¸‹ä½ æ˜¯å¦ä»¥åŠå¦‚ä½•ä½¿ç”¨ä½ å·²ç»çœ‹åˆ°çš„æ“ä½œæ¥è¡¨è¾¾è¿™äº›é—®é¢˜ã€‚
- en: In each of these cases, we need to perform a computation on a single column
    of data (even in the last question about the `"STUDENT"` discount, as we would
    filter the table to those rows, then do a computation over the `email` column).
    In order to capture these in code, we need to extract a column from the table.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™äº›æƒ…å†µä¸­ï¼Œæˆ‘ä»¬éœ€è¦å¯¹æ•°æ®çš„ä¸€ä¸ªå•ç‹¬åˆ—è¿›è¡Œè®¡ç®—ï¼ˆç”šè‡³åœ¨å…³äº `"STUDENT"` æŠ˜æ‰£çš„æœ€åä¸€ä¸ªé—®é¢˜ä¸­ï¼Œæˆ‘ä»¬ä¼šè¿‡æ»¤è¡¨æ ¼åˆ°é‚£äº›è¡Œï¼Œç„¶åå¯¹ `email`
    åˆ—è¿›è¡Œè®¡ç®—ï¼‰ã€‚ä¸ºäº†åœ¨ä»£ç ä¸­æ•æ‰è¿™äº›ï¼Œæˆ‘ä»¬éœ€è¦ä»è¡¨æ ¼ä¸­æå–ä¸€ä¸ªåˆ—ã€‚
- en: For the rest of this chapter, we will work with a cleaned copy of the `event-data`
    from the previous chapter. The cleaned data, which applies the transformations
    at the end of the previous chapter, is in a different tab of the same Google Sheet
    as the other versions of the event data.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬ç« çš„å‰©ä½™éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ä¸Šä¸€ç« çš„ `event-data` çš„æ¸…ç†å‰¯æœ¬è¿›è¡Œå·¥ä½œã€‚ç»è¿‡ä¸Šä¸€ç« æœ«å°¾è½¬æ¢çš„æ¸…ç†æ•°æ®ä½äºåŒä¸€ Google è¡¨æ ¼çš„å¦ä¸€ä¸ªæ ‡ç­¾é¡µä¸­ï¼Œä¸å…¶ä»–ç‰ˆæœ¬çš„äº‹ä»¶æ•°æ®ä¸åŒã€‚
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 5.1.2Â Extracting a Column from a Table[ğŸ”—](#(part._.Extracting_a_.Column_from_a_.Table)
    "Link to here")
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.2 ä»è¡¨æ ¼ä¸­æå–åˆ—[ğŸ”—](#(part._.Extracting_a_.Column_from_a_.Table) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Our collection of table functions includes one that we havenâ€™t yet used, called
    `select-columns`. As the name suggests, this function produces a new table containing
    only certain columns from an existing table. Letâ€™s extract the `tickcount` column
    so we can compute some statistics over it. We use the following expression:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„è¡¨æ ¼å‡½æ•°é›†åˆä¸­åŒ…æ‹¬ä¸€ä¸ªæˆ‘ä»¬å°šæœªä½¿ç”¨çš„å‡½æ•°ï¼Œç§°ä¸º `select-columns`ã€‚æ­£å¦‚å…¶åç§°æ‰€æš—ç¤ºçš„ï¼Œè¿™ä¸ªå‡½æ•°ä¼šç”Ÿæˆä¸€ä¸ªæ–°çš„è¡¨æ ¼ï¼Œå…¶ä¸­åªåŒ…å«ç°æœ‰è¡¨æ ¼ä¸­çš„æŸäº›åˆ—ã€‚è®©æˆ‘ä»¬æå–
    `tickcount` åˆ—ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥å¯¹å…¶è®¡ç®—ä¸€äº›ç»Ÿè®¡æ•°æ®ã€‚æˆ‘ä»¬ä½¿ç”¨ä»¥ä¸‹è¡¨è¾¾å¼ï¼š
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](../Images/218dbd3d076ef24041ce988f1e4f6c1d.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/218dbd3d076ef24041ce988f1e4f6c1d.png)'
- en: This focuses our attention on the numeric ticket sales, but weâ€™re still stuck
    with a column in a table, and none of the other tables functions let us do the
    kinds of computations we might want over these numbers. Ideally, we want the collection
    of numbers on their own, without being wrapped up in the extra layer of table
    cells.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°†æˆ‘ä»¬çš„æ³¨æ„åŠ›é›†ä¸­åœ¨æ•°å­—é—¨ç¥¨é”€å”®ä¸Šï¼Œä½†æˆ‘ä»¬ä»ç„¶è¢«å›°åœ¨è¡¨æ ¼ä¸­çš„åˆ—ï¼Œè€Œä¸”å…¶ä»–è¡¨æ ¼å‡½æ•°éƒ½ä¸å…è®¸æˆ‘ä»¬å¯¹è¿™äº›æ•°å­—è¿›è¡Œæˆ‘ä»¬å¯èƒ½æƒ³è¦çš„è®¡ç®—ã€‚ç†æƒ³æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¸Œæœ›è¿™äº›æ•°å­—ç‹¬ç«‹å­˜åœ¨ï¼Œè€Œä¸æ˜¯è¢«åŒ…è£¹åœ¨é¢å¤–çš„è¡¨æ ¼å•å…ƒæ ¼å±‚ä¸­ã€‚
- en: In principle, we could have a collection of operations on a single column. In
    some languages that focus solely on tables, such as [SQL](https://en.wikipedia.org/wiki/SQL),
    this is what youâ€™ll find. However, in Pyret we have many more kinds of data than
    just columns (as weâ€™ll soon see [[Introduction to Structured Data](intro-struct-data.html)],
    we can even create our own!), so it makes sense to leave the gentle cocoon of
    tables sooner or later. An extracted column is a more basic kind of datum called
    a list, which can be used to represent a sequence of data outside of a table.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨åŸåˆ™ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å•ä¸ªåˆ—ä¸Šæ‰§è¡Œä¸€ç³»åˆ—æ“ä½œã€‚åœ¨ä¸€äº›åªå…³æ³¨è¡¨æ ¼çš„è¯­è¨€ä¸­ï¼Œä¾‹å¦‚ [SQL](https://en.wikipedia.org/wiki/SQL)ï¼Œä½ å°†æ‰¾åˆ°è¿™æ ·çš„æ“ä½œã€‚ç„¶è€Œï¼Œåœ¨
    Pyret ä¸­ï¼Œæˆ‘ä»¬æ‹¥æœ‰çš„æ•°æ®ç±»å‹è¿œä¸æ­¢åˆ—ï¼ˆæ­£å¦‚æˆ‘ä»¬å¾ˆå¿«å°†åœ¨ [[ç»“æ„åŒ–æ•°æ®ç®€ä»‹](intro-struct-data.html)] ä¸­çœ‹åˆ°çš„é‚£æ ·ï¼Œæˆ‘ä»¬ç”šè‡³å¯ä»¥åˆ›å»ºè‡ªå·±çš„æ•°æ®ç±»å‹ï¼ï¼‰ï¼Œå› æ­¤ï¼Œè¿Ÿæ—©ç¦»å¼€è¡¨æ ¼çš„æ¸©æŸ”èŒ§æˆ¿æ˜¯æœ‰æ„ä¹‰çš„ã€‚æå–å‡ºçš„åˆ—æ˜¯ä¸€ç§æ›´åŸºæœ¬çš„æ•°æ®ç±»å‹ï¼Œç§°ä¸ºåˆ—è¡¨ï¼Œå®ƒå¯ä»¥ç”¨æ¥è¡¨ç¤ºè¡¨æ ¼ä¹‹å¤–çš„æ•°æ®åºåˆ—ã€‚
- en: 'Just as we have used the notation `.row-n` to pull a single row from a table,
    we use a similar dot-based notion to pull out a single column. Hereâ€™s how we extract
    the `tickcount` column:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬ä½¿ç”¨ `.row-n` ç¬¦å·ä»è¡¨æ ¼ä¸­æå–å•è¡Œä¸€æ ·ï¼Œæˆ‘ä»¬ä½¿ç”¨ç±»ä¼¼çš„åŸºäºç‚¹çš„æ¦‚å¿µæ¥æå–å•åˆ—ã€‚ä»¥ä¸‹æ˜¯å¦‚ä½•æå– `tickcount` åˆ—çš„ç¤ºä¾‹ï¼š
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In response, Pyret produces the following value:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºå›åº”ï¼ŒPyret äº§ç”Ÿäº†ä»¥ä¸‹å€¼ï¼š
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we seem to have only the values that were in the cells in the column,
    without the enclosing table. Yet the numbers are still bundled up, this time in
    the `[list: ...]` notation. What is that?'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç°åœ¨ï¼Œæˆ‘ä»¬ä¼¼ä¹åªæœ‰åˆ—ä¸­å•å…ƒæ ¼ä¸­çš„å€¼ï¼Œæ²¡æœ‰åŒ…å«çš„è¡¨æ ¼ã€‚ç„¶è€Œï¼Œè¿™äº›æ•°å­—ä»ç„¶æ†ç»‘åœ¨ä¸€èµ·ï¼Œè¿™æ¬¡æ˜¯åœ¨ `[list: ...]` ç¬¦å·ä¸­ã€‚é‚£æ˜¯ä»€ä¹ˆï¼Ÿ'
- en: 5.1.3Â Understanding Lists[ğŸ”—](#(part._.Understanding_.Lists) "Link to here")
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.3 ç†è§£åˆ—è¡¨[ğŸ”—](#(part._.Understanding_.Lists) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'A list has much in common with a single-column table:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ä¸å•åˆ—è¡¨æ ¼æœ‰å¾ˆå¤šå…±åŒä¹‹å¤„ï¼š
- en: The elements have an order, so it makes sense to talk about the â€œfirstâ€, â€œsecondâ€,
    â€œlastâ€â€”<wbr>and so onâ€”<wbr>element of a list.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å…ƒç´ æ˜¯æœ‰é¡ºåºçš„ï¼Œå› æ­¤è°ˆè®ºåˆ—è¡¨çš„â€œç¬¬ä¸€ä¸ªâ€ã€â€œç¬¬äºŒä¸ªâ€ã€â€œæœ€åä¸€ä¸ªâ€â€”â€”ä»¥åŠç­‰ç­‰â€”â€”å…ƒç´ æ˜¯æœ‰æ„ä¹‰çš„ã€‚
- en: All elements of a list are expected to have the same type.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ—è¡¨çš„æ‰€æœ‰å…ƒç´ éƒ½åº”å…·æœ‰ç›¸åŒçš„ç±»å‹ã€‚
- en: The crucial difference is that a list does not have a â€œcolumn nameâ€; it is anonymous.
    That is, by itself a list does not describe what it represents; this interpretation
    is done by our program.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: å…³é”®çš„åŒºåˆ«æ˜¯åˆ—è¡¨æ²¡æœ‰â€œåˆ—åâ€ï¼›å®ƒæ˜¯åŒ¿åçš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåˆ—è¡¨æœ¬èº«ä¸æè¿°å®ƒæ‰€ä»£è¡¨çš„å†…å®¹ï¼›è¿™ç§è§£é‡Šæ˜¯ç”±æˆ‘ä»¬çš„ç¨‹åºå®Œæˆçš„ã€‚
- en: 5.1.3.1Â Lists as Anonymous Data[ğŸ”—](#(part._lists-generic-data) "Link to here")
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1.3.1Â åˆ—è¡¨ä½œä¸ºåŒ¿åæ•°æ®[ğŸ”—](#(part._lists-generic-data) "é“¾æ¥è‡³æ­¤")
- en: 'This might sound rather abstractâ€”<wbr>and it isâ€”<wbr>but this isnâ€™t actually
    a new idea in our programming experience. Consider a value like `3` or `-1`: what
    is it? Itâ€™s the same sort of thing: an anonymous value that does not describe
    what it represents; the interpretation is done by our program. In one setting
    `3` may represent an age, in another a play count; in one setting `-1` may be
    a temperature, in another the average of several temperatures. Similarly with
    a string: Is `"project"` a noun (an activity that one or more people perform)
    or a verb (as when we display something on a screen)? Likewise with images and
    so on. In fact, tables have been the exception so far in having description built
    into the data rather than being provided by a program!'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯èƒ½å¬èµ·æ¥ç›¸å½“æŠ½è±¡â€”â€”<wbr>ç¡®å®å¦‚æ­¤â€”â€”ä½†è¿™å¹¶ä¸æ˜¯æˆ‘ä»¬ç¼–ç¨‹ç»éªŒä¸­çš„æ–°æƒ³æ³•ã€‚è€ƒè™‘ä¸€ä¸ªåƒ`3`æˆ–`-1`è¿™æ ·çš„å€¼ï¼šå®ƒæ˜¯ä»€ä¹ˆï¼Ÿå®ƒå±äºåŒä¸€ç±»ä¸œè¥¿ï¼šä¸€ä¸ªåŒ¿åå€¼ï¼Œä¸æè¿°å®ƒæ‰€ä»£è¡¨çš„å†…å®¹ï¼›è§£é‡Šæ˜¯ç”±æˆ‘ä»¬çš„ç¨‹åºå®Œæˆçš„ã€‚åœ¨ä¸€ä¸ªè®¾ç½®ä¸­`3`å¯èƒ½ä»£è¡¨å¹´é¾„ï¼Œåœ¨å¦ä¸€ä¸ªä¸­å¯èƒ½ä»£è¡¨æ’­æ”¾æ¬¡æ•°ï¼›åœ¨ä¸€ä¸ªè®¾ç½®ä¸­`-1`å¯èƒ½ä»£è¡¨æ¸©åº¦ï¼Œåœ¨å¦ä¸€ä¸ªä¸­å¯èƒ½æ˜¯å‡ ä¸ªæ¸©åº¦çš„å¹³å‡å€¼ã€‚åŒæ ·ï¼Œå¯¹äºå­—ç¬¦ä¸²ä¹Ÿæ˜¯å¦‚æ­¤ï¼š`"project"`æ˜¯ä¸€ä¸ªåè¯ï¼ˆä¸€ä¸ªäººæˆ–å¤šäººæ‰§è¡Œçš„æ´»åŠ¨ï¼‰è¿˜æ˜¯ä¸€ä¸ªåŠ¨è¯ï¼ˆå½“æˆ‘ä»¬æ˜¾ç¤ºæŸç‰©åœ¨å±å¹•ä¸Šæ—¶ï¼‰ï¼ŸåŒæ ·ï¼Œå¯¹äºå›¾åƒç­‰ç­‰ã€‚äº‹å®ä¸Šï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼Œè¡¨æ ¼æ˜¯ä¾‹å¤–ï¼Œå› ä¸ºæè¿°æ˜¯å†…ç½®äºæ•°æ®ä¸­è€Œä¸æ˜¯ç”±ç¨‹åºæä¾›çš„ï¼
- en: This genericity is both a virtue and a problem. Because, like other anonymous
    data, a list does not provide any interpretation of its use, if we are not careful
    we can accidentally mis-interpret the values. On the other hand, it means we can
    use the same datum in several different contexts, and one operation can be used
    in many settings.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§é€šç”¨æ€§æ—¢æ˜¯ä¼˜ç‚¹ä¹Ÿæ˜¯é—®é¢˜ã€‚å› ä¸ºï¼Œåƒå…¶ä»–åŒ¿åæ•°æ®ä¸€æ ·ï¼Œåˆ—è¡¨ä¸æä¾›å¯¹å…¶ä½¿ç”¨çš„ä»»ä½•è§£é‡Šï¼Œå¦‚æœæˆ‘ä»¬ä¸å°å¿ƒï¼Œå¯èƒ½ä¼šæ„å¤–åœ°è¯¯è§£å€¼ã€‚å¦ä¸€æ–¹é¢ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥åœ¨å‡ ä¸ªä¸åŒçš„ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨ç›¸åŒçš„æ•°æ®ï¼Œä¸€ä¸ªæ“ä½œå¯ä»¥åœ¨è®¸å¤šè®¾ç½®ä¸­ä½¿ç”¨ã€‚
- en: Indeed, if we look at the list of questions we asked earlier, we see that there
    are several common operationsâ€”<wbr>maximum, minimum, average, and so onâ€”<wbr>that
    can be asked of a list of values without regard for what the list represents (heights,
    ages, playcounts). In fact, some are specific to numbers (like average) while
    some (like maximum) can be asked of any type on which we can perform a comparison
    (like strings).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: äº‹å®ä¸Šï¼Œå¦‚æœæˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬ä¹‹å‰æå‡ºçš„é—®é¢˜åˆ—è¡¨ï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ°æœ‰å‡ ä¸ªå¸¸è§çš„æ“ä½œâ€”â€”<wbr>æœ€å¤§å€¼ã€æœ€å°å€¼ã€å¹³å‡å€¼ç­‰ç­‰â€”â€”å¯ä»¥åœ¨ä¸è€ƒè™‘åˆ—è¡¨ä»£è¡¨ä»€ä¹ˆï¼ˆèº«é«˜ã€å¹´é¾„ã€æ’­æ”¾æ¬¡æ•°ï¼‰çš„æƒ…å†µä¸‹å¯¹å€¼åˆ—è¡¨è¿›è¡Œæé—®ã€‚äº‹å®ä¸Šï¼Œæœ‰äº›æ˜¯é’ˆå¯¹æ•°å­—çš„ï¼ˆå¦‚å¹³å‡å€¼ï¼‰ï¼Œè€Œæœ‰äº›ï¼ˆå¦‚æœ€å¤§å€¼ï¼‰å¯ä»¥é’ˆå¯¹æˆ‘ä»¬å¯ä»¥æ‰§è¡Œæ¯”è¾ƒçš„ä»»ä½•ç±»å‹ï¼ˆå¦‚å­—ç¬¦ä¸²ï¼‰è¿›è¡Œæé—®ã€‚
- en: 5.1.3.2Â Creating Literal Lists[ğŸ”—](#(part._.Creating_.Literal_.Lists) "Link to
    here")
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1.3.2Â åˆ›å»ºå­—é¢é‡åˆ—è¡¨[ğŸ”—](#(part._.Creating_.Literal_.Lists) "é“¾æ¥è‡³æ­¤")
- en: 'We have already seen how we can create lists from a table, using `get-column`.
    As you might expect, however, we can also create lists directly:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»çœ‹åˆ°å¦‚ä½•ä½¿ç”¨`get-column`ä»è¡¨æ ¼ä¸­åˆ›å»ºåˆ—è¡¨ã€‚ç„¶è€Œï¼Œæ­£å¦‚ä½ æ‰€é¢„æœŸçš„ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ç›´æ¥åˆ›å»ºåˆ—è¡¨ï¼š
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Of course, lists are values so we can name them using variablesâ€”<wbr>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œåˆ—è¡¨æ˜¯å€¼ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å˜é‡æ¥å‘½åå®ƒä»¬â€”â€”<wbr>
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: â€”<wbr>pass them to functions (as we will soon see), and so on.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: â€”â€”<wbr>å°†å®ƒä»¬ä¼ é€’ç»™å‡½æ•°ï¼ˆæ­£å¦‚æˆ‘ä»¬å¾ˆå¿«å°±ä¼šçœ‹åˆ°çš„ï¼‰ï¼Œç­‰ç­‰ã€‚
- en: Do Now!
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Based on these examples, can you figure out how to create an empty list?
  id: totrans-61
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸºäºè¿™äº›ç¤ºä¾‹ï¼Œä½ èƒ½æ‰¾å‡ºå¦‚ä½•åˆ›å»ºä¸€ä¸ªç©ºåˆ—è¡¨å—ï¼Ÿ
- en: 'As you might have guessed, itâ€™s `[list: ]` (the space isnâ€™t necessary, but
    itâ€™s a useful visual reminder of the void).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ­£å¦‚ä½ å¯èƒ½å·²ç»çŒœåˆ°çš„ï¼Œå®ƒæ˜¯`[list: ]`ï¼ˆç©ºæ ¼ä¸æ˜¯å¿…éœ€çš„ï¼Œä½†å®ƒæ˜¯ä¸€ä¸ªæœ‰ç”¨çš„è§†è§‰æé†’ï¼Œè¡¨ç¤ºç©ºå€¼ï¼‰ã€‚'
- en: 5.1.4Â Operating on Lists[ğŸ”—](#(part._.Operating_on_.Lists) "Link to here")
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.4Â åœ¨åˆ—è¡¨ä¸Šæ“ä½œ[ğŸ”—](#(part._.Operating_on_.Lists) "é“¾æ¥è‡³æ­¤")
- en: 5.1.4.1Â Built-In Operations on Lists of Numbers[ğŸ”—](#(part._.Built-.In_.Operations_on_.Lists_of_.Numbers)
    "Link to here")
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1.4.1Â åˆ—è¡¨æ•°å­—çš„å†…ç½®æ“ä½œ[ğŸ”—](#(part._.Built-.In_.Operations_on_.Lists_of_.Numbers) "é“¾æ¥è‡³æ­¤")
- en: 'Pyret handily provides a useful set of operations we can already perform on
    lists. The [lists documentation](https://www.pyret.org/docs/latest/lists.html)
    describes these operations. As you might have guessed, we can already compute
    most of the answers weâ€™ve asked for at the start of the chapter. First we need
    to include some libraries that contain useful functions:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Pyretä¸ºæˆ‘ä»¬æä¾›äº†ä¸€å¥—æ–¹ä¾¿çš„æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥å¯¹åˆ—è¡¨æ‰§è¡Œè¿™äº›æ“ä½œã€‚[åˆ—è¡¨æ–‡æ¡£](https://www.pyret.org/docs/latest/lists.html)æè¿°äº†è¿™äº›æ“ä½œã€‚æ­£å¦‚ä½ å¯èƒ½å·²ç»çŒœåˆ°çš„ï¼Œæˆ‘ä»¬å·²ç»åœ¨ç« èŠ‚å¼€å¤´è®¡ç®—äº†å¤§å¤šæ•°æˆ‘ä»¬è¦æ±‚çš„é—®é¢˜ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦åŒ…å«ä¸€äº›åŒ…å«æœ‰ç”¨å‡½æ•°çš„åº“ï¼š
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can then access several useful functions:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥è®¿é—®å‡ ä¸ªæœ‰ç”¨çš„å‡½æ•°ï¼š
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `M.` notation means "the function inside the library `M`. The `import` statement
    in the above code gave the name `M` to the `math` library.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`M.`è¡¨ç¤ºâ€œåº“`M`ä¸­çš„å‡½æ•°â€ã€‚ä¸Šè¿°ä»£ç ä¸­çš„`import`è¯­å¥å°†`math`åº“å‘½åä¸º`M`ã€‚'
- en: 5.1.4.2Â Built-In Operations on Lists in General[ğŸ”—](#(part._.Built-.In_.Operations_on_.Lists_in_.General)
    "Link to here")
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1.4.2Â åˆ—è¡¨çš„ä¸€èˆ¬å†…ç½®æ“ä½œ[ğŸ”—](#(part._.Built-.In_.Operations_on_.Lists_in_.General) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Some of the useful computations in our list at the start of the chapter involved
    the `discount` column, which contains strings rather than numbers. Specifically,
    letâ€™s consider the following question:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨ç« èŠ‚å¼€å¤´åˆ—è¡¨ä¸­çš„æŸäº›æœ‰ç”¨è®¡ç®—æ¶‰åŠåˆ°`discount`åˆ—ï¼Œè¯¥åˆ—åŒ…å«å­—ç¬¦ä¸²è€Œä¸æ˜¯æ•°å­—ã€‚å…·ä½“æ¥è¯´ï¼Œè®©æˆ‘ä»¬è€ƒè™‘ä»¥ä¸‹é—®é¢˜ï¼š
- en: Compute the collection of unique discount codes that were used (many might have
    been available).
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è®¡ç®—ä½¿ç”¨è¿‡çš„å”¯ä¸€æŠ˜æ‰£ä»£ç é›†åˆï¼ˆå¯èƒ½æœ‰å¤šä¸ªå¯ç”¨ï¼‰ã€‚
- en: 'None of the table functions handle a question like this. However, this is a
    common kind of question to ask about a collection of values (How many unique artists
    are in your playlist? How many unique faculty are teaching courses?). As such,
    Pyret (as most languages) provides a way to identify the unique elements of a
    list. Hereâ€™s how we get the list of all discount codes that were used in our table:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: æ²¡æœ‰è¡¨æ ¼å‡½æ•°å¯ä»¥å¤„ç†è¿™æ ·çš„é—®é¢˜ã€‚ç„¶è€Œï¼Œå…³äºå€¼é›†åˆçš„é—®é¢˜ï¼ˆä½ çš„æ’­æ”¾åˆ—è¡¨ä¸­æœ‰å¤šå°‘ç‹¬ç‰¹çš„è‰ºæœ¯å®¶ï¼Ÿæœ‰å¤šå°‘ç‹¬ç‰¹çš„æ•™å¸ˆåœ¨æˆè¯¾ï¼Ÿï¼‰æ˜¯å¸¸è§çš„ã€‚å› æ­¤ï¼ŒPyretï¼ˆä»¥åŠå¤§å¤šæ•°è¯­è¨€ï¼‰æä¾›äº†ä¸€ç§è¯†åˆ«åˆ—è¡¨ä¸­å”¯ä¸€å…ƒç´ çš„æ–¹æ³•ã€‚ä»¥ä¸‹æ˜¯è·å–æˆ‘ä»¬è¡¨æ ¼ä¸­æ‰€æœ‰ä½¿ç”¨è¿‡çš„æŠ˜æ‰£ä»£ç åˆ—è¡¨çš„æ–¹æ³•ï¼š
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `distinct` function produces a list of the unique values from the input
    list: every value in the input list appears exactly once in the output list. For
    the above code, Pyret produces:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`distinct`å‡½æ•°ä»è¾“å…¥åˆ—è¡¨ä¸­ç”Ÿæˆä¸€ä¸ªå”¯ä¸€å€¼çš„åˆ—è¡¨ï¼šè¾“å…¥åˆ—è¡¨ä¸­çš„æ¯ä¸ªå€¼åœ¨è¾“å‡ºåˆ—è¡¨ä¸­åªå‡ºç°ä¸€æ¬¡ã€‚å¯¹äºä¸Šè¿°ä»£ç ï¼ŒPyretç”Ÿæˆï¼š'
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What if we wanted to exclude `"none"` from that list? After all, `"none"` isnâ€™t
    an actual discount code, but rather one that we introduced while cleaning up the
    table. Is there a way to easily remove `"none"` from the list?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æƒ³è¦ä»åˆ—è¡¨ä¸­æ’é™¤`"none"`å‘¢ï¼Ÿæ¯•ç«Ÿï¼Œ`"none"`ä¸æ˜¯ä¸€ä¸ªå®é™…çš„æŠ˜æ‰£ä»£ç ï¼Œè€Œæ˜¯ä¸€ä¸ªæˆ‘ä»¬åœ¨æ¸…ç†è¡¨æ ¼æ—¶å¼•å…¥çš„ä»£ç ã€‚æœ‰æ²¡æœ‰ä¸€ç§ç®€å•çš„æ–¹æ³•å¯ä»¥ä»åˆ—è¡¨ä¸­åˆ é™¤`"none"`ï¼Ÿ
- en: 'There are two ways we could do it. In the Pyret lists documentation, we find
    a function called `remove`, which removes a specific element from a list:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ã€‚åœ¨Pyretåˆ—è¡¨æ–‡æ¡£ä¸­ï¼Œæˆ‘ä»¬æ‰¾åˆ°ä¸€ä¸ªåä¸º`remove`çš„å‡½æ•°ï¼Œè¯¥å‡½æ•°å¯ä»¥ä»åˆ—è¡¨ä¸­åˆ é™¤ä¸€ä¸ªç‰¹å®šçš„å…ƒç´ ï¼š
- en: '|'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE10]'
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '&#124;'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'But this operation should also sound familiar: with tables, we used `filter-with`
    to keep only those elements that meet a specific criterion. The filtering idea
    is so common that Pyret (and most other languages) provide a similar operation
    on lists. In the case of the discount codes, we could also have written:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†è¿™ä¸ªæ“ä½œä¹Ÿåº”è¯¥å¬èµ·æ¥å¾ˆç†Ÿæ‚‰ï¼šåœ¨ä½¿ç”¨è¡¨æ ¼æ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†`filter-with`æ¥ä¿ç•™æ»¡è¶³ç‰¹å®šæ ‡å‡†çš„å…ƒç´ ã€‚è¿‡æ»¤æ€æƒ³å¦‚æ­¤å¸¸è§ï¼Œä»¥è‡³äºPyretï¼ˆä»¥åŠå¤§å¤šæ•°å…¶ä»–è¯­è¨€ï¼‰åœ¨åˆ—è¡¨ä¸Šæä¾›äº†ç±»ä¼¼çš„æ“ä½œã€‚åœ¨æŠ˜æ‰£ä»£ç çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥è¿™æ ·å†™ï¼š
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The difference between these two approaches is that `filter` is more flexible:
    we can check any characteristic of a list element using `filter`, but `remove`
    only checks whether the entire element is equal to the value that we provide.
    If instead of removing the specific string `"none"`, we had wanted to remove all
    strings that were in all-lowercase, we would have needed to use `filter`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸¤ç§æ–¹æ³•ä¹‹é—´çš„åŒºåˆ«åœ¨äº`filter`æ›´åŠ çµæ´»ï¼šæˆ‘ä»¬å¯ä»¥ä½¿ç”¨`filter`æ£€æŸ¥åˆ—è¡¨å…ƒç´ çš„ä»»ä½•ç‰¹å¾ï¼Œä½†`remove`åªæ£€æŸ¥æ•´ä¸ªå…ƒç´ æ˜¯å¦ç­‰äºæˆ‘ä»¬æä¾›çš„å€¼ã€‚å¦‚æœæˆ‘ä»¬ä¸æ˜¯è¦åˆ é™¤ç‰¹å®šçš„å­—ç¬¦ä¸²`"none"`ï¼Œè€Œæ˜¯è¦åˆ é™¤æ‰€æœ‰å…¨å°å†™çš„å­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬å°±éœ€è¦ä½¿ç”¨`filter`ã€‚
- en: Exercise
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write a function that takes a list of words and removes those words in which
    all letters are in lowercase. (Hint: combine `string-to-lower` and `==`).'
  id: totrans-92
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ªå•è¯åˆ—è¡¨ï¼Œå¹¶åˆ é™¤æ‰€æœ‰å­—æ¯éƒ½ä¸ºå°å†™çš„å•è¯ã€‚ï¼ˆæç¤ºï¼šç»“åˆ`string-to-lower`å’Œ`==`ï¼‰ã€‚
- en: 5.1.4.3Â An Aside on Naming Conventions[ğŸ”—](#(part._.An_.Aside_on_.Naming_.Conventions)
    "Link to here")
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1.4.3Â å…³äºå‘½åçº¦å®šçš„è¡¥å……[ğŸ”—](#(part._.An_.Aside_on_.Naming_.Conventions) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Our use of the plural `codes` for the list of values in the column named `discount`
    (singular) is deliberate. A list contains multiple values, so a plural is appropriate.
    In a table, in contrast, we think of a column header as naming a single value
    that appears in a specific row. Often, we speak of looking up a value in a specific
    row and column: the singular name for the column supports thinking about lookup
    in an individual row.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨åä¸º `discount`ï¼ˆå•æ•°ï¼‰çš„åˆ—çš„å€¼åˆ—è¡¨ä¸­ä½¿ç”¨å¤æ•° `codes` æ˜¯æ•…æ„çš„ã€‚åˆ—è¡¨åŒ…å«å¤šä¸ªå€¼ï¼Œæ‰€ä»¥å¤æ•°æ˜¯åˆé€‚çš„ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œåœ¨è¡¨æ ¼ä¸­ï¼Œæˆ‘ä»¬è®¤ä¸ºåˆ—æ ‡é¢˜å‘½åçš„æ˜¯åœ¨ç‰¹å®šè¡Œä¸­å‡ºç°çš„å•ä¸ªå€¼ã€‚æˆ‘ä»¬ç»å¸¸è¯´åœ¨ç‰¹å®šè¡Œå’Œåˆ—ä¸­æŸ¥æ‰¾å€¼ï¼šåˆ—çš„å•æ•°åç§°æ”¯æŒåœ¨å•ä¸ªè¡Œä¸­è¿›è¡ŒæŸ¥æ‰¾çš„æƒ³æ³•ã€‚
- en: 5.1.4.4Â Getting Elements By Position[ğŸ”—](#(part._.Getting_.Elements_.By_.Position)
    "Link to here")
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1.4.4Â é€šè¿‡ä½ç½®è·å–å…ƒç´ [ğŸ”—](#(part._.Getting_.Elements_.By_.Position) "é“¾æ¥è‡³æ­¤")
- en: 'Letâ€™s look at a new analysis question: the events company recently ran an advertising
    campaign on `web.com`, and they are curious whether it paid off. To do this, they
    need to determine how many sales were made to people with `web.com` email addresses.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹çœ‹ä¸€ä¸ªæ–°çš„åˆ†æé—®é¢˜ï¼šäº‹ä»¶å…¬å¸æœ€è¿‘åœ¨ `web.com` ä¸Šè¿›è¡Œäº†ä¸€æ¬¡å¹¿å‘Šæ´»åŠ¨ï¼Œä»–ä»¬æƒ³çŸ¥é“è¿™æ˜¯å¦æœ‰æ•ˆã€‚ä¸ºäº†åšåˆ°è¿™ä¸€ç‚¹ï¼Œä»–ä»¬éœ€è¦ç¡®å®šæœ‰å¤šå°‘é”€å”®æ˜¯é’ˆå¯¹å…·æœ‰
    `web.com` ç”µå­é‚®ä»¶åœ°å€çš„äººã€‚
- en: Do Now!
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Propose a task plan ([Task Plans](processing-tables.html#%28part._task-plans%29))
    for this computation.
  id: totrans-99
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æå‡ºä¸€ä¸ªä»»åŠ¡è®¡åˆ’ ([ä»»åŠ¡è®¡åˆ’](processing-tables.html#%28part._task-plans%29)) ç”¨äºæ­¤è®¡ç®—ã€‚
- en: 'Hereâ€™s a proposed plan, annotated with how we might implement each part:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€ä¸ªæå‡ºçš„è®¡åˆ’ï¼Œå¹¶é™„æ³¨äº†å¦‚ä½•å®ç°æ¯ä¸ªéƒ¨åˆ†çš„è¯´æ˜ï¼š
- en: Get the list of email addresses (use `get-column`)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è·å–ç”µå­é‚®ä»¶åœ°å€åˆ—è¡¨ï¼ˆä½¿ç”¨ `get-column`ï¼‰
- en: Extract those that came from `web.com` (use `L.filter`)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æå–æ¥è‡ª `web.com` çš„é‚£äº›ï¼ˆä½¿ç”¨ `L.filter`ï¼‰
- en: Count how many email addresses remain (using `L.length`, which we hadnâ€™t discussed
    yet, but it is in the documentation)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è®¡ç®—å‰©ä½™çš„ç”µå­é‚®ä»¶åœ°å€æ•°é‡ï¼ˆä½¿ç”¨ `L.length`ï¼Œæˆ‘ä»¬å°šæœªè®¨è®ºï¼Œä½†åœ¨æ–‡æ¡£ä¸­æœ‰æ‰€è¯´æ˜ï¼‰
- en: (As a reminder, unless you immediately see how to solve a problem, write out
    a task plan and annotate the parts you know how to do. It helps break down a programming
    problem into more manageable parts.)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆä½œä¸ºæé†’ï¼Œé™¤éä½ ç«‹å³çœ‹åˆ°è§£å†³é—®é¢˜çš„æ–¹æ³•ï¼Œå¦åˆ™å†™å‡ºä»»åŠ¡è®¡åˆ’å¹¶æ ‡æ³¨ä½ çŸ¥é“å¦‚ä½•åšçš„éƒ¨åˆ†ã€‚è¿™æœ‰åŠ©äºå°†ç¼–ç¨‹é—®é¢˜åˆ†è§£æˆæ›´æ˜“äºç®¡ç†çš„éƒ¨åˆ†ã€‚ï¼‰
- en: 'Letâ€™s discuss the second task: identifying messages from `web.com`. We know
    that email addresses are strings, so if we could determine whether an email string
    ends in `@web.com`, weâ€™d be set. You could consider doing this by looking at the
    last 7 characters of the email string. Another option is to use a string operation
    that we havenâ€™t yet seen called `string-split-all`, which splits a string into
    a list of substrings around a given character. For example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è®¨è®ºç¬¬äºŒä¸ªä»»åŠ¡ï¼šè¯†åˆ«æ¥è‡ª `web.com` çš„æ¶ˆæ¯ã€‚æˆ‘ä»¬çŸ¥é“ç”µå­é‚®ä»¶åœ°å€æ˜¯å­—ç¬¦ä¸²ï¼Œæ‰€ä»¥å¦‚æœæˆ‘ä»¬èƒ½ç¡®å®šç”µå­é‚®ä»¶å­—ç¬¦ä¸²æ˜¯å¦ä»¥ `@web.com`
    ç»“å°¾ï¼Œæˆ‘ä»¬å°±æˆåŠŸäº†ã€‚ä½ å¯ä»¥è€ƒè™‘é€šè¿‡æŸ¥çœ‹ç”µå­é‚®ä»¶å­—ç¬¦ä¸²çš„æœ€å 7 ä¸ªå­—ç¬¦æ¥åšè¿™ä»¶äº‹ã€‚å¦ä¸€ä¸ªé€‰æ‹©æ˜¯ä½¿ç”¨æˆ‘ä»¬å°šæœªçœ‹åˆ°çš„å­—ç¬¦ä¸²æ“ä½œ `string-split-all`ï¼Œå®ƒå°†å­—ç¬¦ä¸²åˆ†å‰²æˆä»¥ç»™å®šå­—ç¬¦ä¸ºåˆ†éš”çš„å­å­—ç¬¦ä¸²åˆ—è¡¨ã€‚ä¾‹å¦‚ï¼š
- en: '|'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE13]'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '&#124;'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE15]'
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '&#124;'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: This seems pretty useful. If we split each email string around the `@` sign,
    then we can check whether the second string in the list is `web.com` (since email
    addresses should have only one `@` sign). But how would we get the second element
    out of the list produced by `string-split-all`? Here we dig into the list, as
    we did to extract rows from tables, this time using the `get` operation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™çœ‹èµ·æ¥éå¸¸æœ‰ç”¨ã€‚å¦‚æœæˆ‘ä»¬å›´ç»• `@` ç¬¦å·åˆ†å‰²æ¯ä¸ªç”µå­é‚®ä»¶å­—ç¬¦ä¸²ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥æ£€æŸ¥åˆ—è¡¨ä¸­çš„ç¬¬äºŒä¸ªå­—ç¬¦ä¸²æ˜¯å¦ä¸º `web.com`ï¼ˆå› ä¸ºç”µå­é‚®ä»¶åœ°å€åº”è¯¥åªæœ‰ä¸€ä¸ª
    `@` ç¬¦å·ï¼‰ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬å¦‚ä½•ä» `string-split-all` ç”Ÿæˆçš„åˆ—è¡¨ä¸­è·å–ç¬¬äºŒä¸ªå…ƒç´ å‘¢ï¼Ÿåœ¨è¿™é‡Œï¼Œæˆ‘ä»¬æ·±å…¥åˆ—è¡¨ï¼Œå°±åƒæˆ‘ä»¬æå–è¡¨æ ¼ä¸­çš„è¡Œä¸€æ ·ï¼Œè¿™æ¬¡ä½¿ç”¨
    `get` æ“ä½œã€‚
- en: '|'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE17]'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '&#124;'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Do Now!
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do we use `1` as the input to `get` if we want the second item in the list?
  id: totrans-133
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æƒ³è¦åˆ—è¡¨ä¸­çš„ç¬¬äºŒä¸ªé¡¹ç›®ï¼Œä¸ºä»€ä¹ˆå°† `1` ä½œä¸º `get` çš„è¾“å…¥ï¼Ÿ
- en: 'Hereâ€™s the complete program for doing this check:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯å®Œæˆæ­¤æ£€æŸ¥çš„å®Œæ•´ç¨‹åºï¼š
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Exercise
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if there is a malformed email address string that doesnâ€™t contain
    the `@` string? What would happen? What could you do about that?
  id: totrans-138
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœæœ‰ä¸€ä¸ªæ ¼å¼ä¸æ­£ç¡®çš„ç”µå­é‚®ä»¶åœ°å€å­—ç¬¦ä¸²ä¸åŒ…å« `@` å­—ç¬¦ä¸²ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿä½ èƒ½å¯¹æ­¤åšäº›ä»€ä¹ˆï¼Ÿ
- en: 5.1.4.5Â Transforming Lists[ğŸ”—](#(part._.Transforming_.Lists) "Link to here")
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1.4.5Â è½¬æ¢åˆ—è¡¨[ğŸ”—](#(part._.Transforming_.Lists) "é“¾æ¥è‡³æ­¤")
- en: Imagine now that we had a list of email addresses, but instead just wanted a
    list of usernames. This doesnâ€™t make sense for our event data, but it does make
    sense in other contexts (such as connecting messages to folders organized by studentsâ€™
    usernames).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬ç°åœ¨æœ‰ä¸€ä¸ªç”µå­é‚®ä»¶åœ°å€åˆ—è¡¨ï¼Œä½†æˆ‘ä»¬åªæƒ³æœ‰ä¸€ä¸ªç”¨æˆ·ååˆ—è¡¨ã€‚è¿™åœ¨æˆ‘ä»¬çš„äº‹ä»¶æ•°æ®ä¸­å¯èƒ½æ²¡æœ‰æ„ä¹‰ï¼Œä½†åœ¨å…¶ä»–ä¸Šä¸‹æ–‡ä¸­ï¼ˆä¾‹å¦‚å°†æ¶ˆæ¯è¿æ¥åˆ°æŒ‰å­¦ç”Ÿç”¨æˆ·åç»„ç»‡çš„æ–‡ä»¶å¤¹ï¼‰æ˜¯æœ‰æ„ä¹‰çš„ã€‚
- en: 'Specifcally, we want to start with a list of addresses such as:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬æƒ³è¦ä»ä¸€ä¸ªåœ°å€åˆ—è¡¨å¼€å§‹ï¼Œä¾‹å¦‚ï¼š
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: and convert it to
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¶å°†å…¶è½¬æ¢ä¸º
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Do Now!
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Consider the list functions we have seen so far (`distinct`, `filter`, `length`)
    â€“ are any of them useful for this task? Can you articulate why?
  id: totrans-147
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è€ƒè™‘æˆ‘ä»¬è¿„ä»Šä¸ºæ­¢çœ‹åˆ°çš„åˆ—è¡¨å‡½æ•°ï¼ˆ`distinct`ã€`filter`ã€`length`ï¼‰â€”â€”å®ƒä»¬ä¸­çš„ä»»ä½•ä¸€ä¸ªå¯¹è¿™ä¸ªä»»åŠ¡æœ‰ç”¨å—ï¼Ÿä½ èƒ½é˜è¿°ä¸ºä»€ä¹ˆå—ï¼Ÿ
- en: One way to articulate a precise answer to this is think in terms of the inputs
    and outputs of the existing functions. Both `filter` and `distinct` return a list
    of elements from the input list, not transformed elements. `length` returns a
    number, not a list. So none of these are appropriate.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ç§æ˜ç¡®å›ç­”è¿™ä¸ªé—®é¢˜çš„æ–¹æ³•æ˜¯ä»ç°æœ‰å‡½æ•°çš„è¾“å…¥å’Œè¾“å‡ºè§’åº¦æ€è€ƒã€‚`filter` å’Œ `distinct` éƒ½è¿”å›è¾“å…¥åˆ—è¡¨çš„å…ƒç´ åˆ—è¡¨ï¼Œè€Œä¸æ˜¯è½¬æ¢åçš„å…ƒç´ ã€‚`length`
    è¿”å›ä¸€ä¸ªæ•°å­—ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªåˆ—è¡¨ã€‚å› æ­¤ï¼Œè¿™äº›éƒ½ä¸åˆé€‚ã€‚
- en: 'This idea of transforming elements is similar to the `transform-column` operation
    that we previously saw on tables. The corresponding operation on lists is called
    `map`. Hereâ€™s an example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§å˜æ¢å…ƒç´ çš„æƒ³æ³•ä¸æˆ‘ä»¬ä¹‹å‰åœ¨è¡¨æ ¼ä¸­çœ‹åˆ°çš„ `transform-column` æ“ä½œç±»ä¼¼ã€‚åˆ—è¡¨ä¸Šçš„ç›¸åº”æ“ä½œç§°ä¸º `map`ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼š
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '5.1.4.6Â Recap: Summary of List Operations[ğŸ”—](#(part._lists-recap) "Link to
    here")'
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1.4.6 å›é¡¾ï¼šåˆ—è¡¨æ“ä½œæ€»ç»“[ğŸ”—](#(part._lists-recap) "é“¾æ¥è‡³æ­¤")
- en: 'At this point, we have seen several useful built-in functions for working with
    lists:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»çœ‹åˆ°äº†å‡ ä¸ªç”¨äºå¤„ç†åˆ—è¡¨çš„æœ‰ç”¨å†…ç½®å‡½æ•°ï¼š
- en: '`filter :: (A -> Boolean), List<A> -> List<A>`, which produces a list of elements
    from the input list on which the given function returns `true`.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter :: (A -> Boolean), List<A> -> List<A>`ï¼Œå®ƒç”Ÿæˆä¸€ä¸ªåˆ—è¡¨ï¼Œå…¶ä¸­åŒ…å«åœ¨è¾“å…¥åˆ—è¡¨ä¸­å¯¹ç»™å®šå‡½æ•°è¿”å› `true`
    çš„å…ƒç´ ã€‚'
- en: '`map :: (A -> B), List<A> -> List<B>`, which produces a list of the results
    of calling the given function on each element of the input list.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map :: (A -> B), List<A> -> List<B>`ï¼Œå®ƒç”Ÿæˆä¸€ä¸ªåˆ—è¡¨ï¼Œè¯¥åˆ—è¡¨åŒ…å«å¯¹è¾“å…¥åˆ—è¡¨ä¸­æ¯ä¸ªå…ƒç´ è°ƒç”¨ç»™å®šå‡½æ•°çš„ç»“æœã€‚'
- en: '`distinct :: List<A> -> List<A>`, which produces a list of the unique elements
    that appear in the input list.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distinct :: List<A> -> List<A>`ï¼Œå®ƒç”Ÿæˆä¸€ä¸ªåˆ—è¡¨ï¼Œå…¶ä¸­åŒ…å«åœ¨è¾“å…¥åˆ—è¡¨ä¸­å‡ºç°çš„å”¯ä¸€å…ƒç´ ã€‚'
- en: '`length :: List<A> -> Number`, which produces the number of elements in the
    input list.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length :: List<A> -> Number`ï¼Œå®ƒç”Ÿæˆè¾“å…¥åˆ—è¡¨ä¸­çš„å…ƒç´ æ•°é‡ã€‚'
- en: Here, a type such as `List<A>` says that we have a list whose elements are of
    some (unspecified) type which weâ€™ll call `A`. A type variable such as this is
    useful when we want to show relationships between two types in a function contract.
    Here, the type variable `A` captures that the type of elements is the same in
    the input and output to `filter`. In `map`, however, the type of element in the
    output list could differ from that in the input list.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œï¼Œç±»å‹ `List<A>` è¡¨ç¤ºæˆ‘ä»¬æœ‰ä¸€ä¸ªå…ƒç´ ç±»å‹ä¸ºæŸç§ï¼ˆæœªæŒ‡å®šçš„ï¼‰ç±»å‹çš„åˆ—è¡¨ï¼Œæˆ‘ä»¬å°†ç§°ä¹‹ä¸º `A`ã€‚è¿™ç§ç±»å‹å˜é‡åœ¨å‡½æ•°åˆåŒä¸­æ˜¾ç¤ºä¸¤ä¸ªç±»å‹ä¹‹é—´çš„å…³ç³»æ—¶å¾ˆæœ‰ç”¨ã€‚åœ¨è¿™é‡Œï¼Œç±»å‹å˜é‡
    `A` æ•è·äº†å…ƒç´ ç±»å‹åœ¨ `filter` çš„è¾“å…¥å’Œè¾“å‡ºä¸­æ˜¯ç›¸åŒçš„ã€‚ç„¶è€Œï¼Œåœ¨ `map` ä¸­ï¼Œè¾“å‡ºåˆ—è¡¨ä¸­çš„å…ƒç´ ç±»å‹å¯èƒ½ä¸è¾“å…¥åˆ—è¡¨ä¸­çš„ä¸åŒã€‚
- en: 'One additional built-in function that is quite useful in practice is:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å®è·µä¸­éå¸¸æœ‰ç”¨çš„ä¸€ä¸ªé¢å¤–å†…ç½®å‡½æ•°æ˜¯ï¼š
- en: '`member :: List<A>, Any -> Boolean`, which determines whether the given element
    is in the list. We use the type `Any` when there are no constraints on the type
    of value provided to a function.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`member :: List<A>, Any -> Boolean`ï¼Œå®ƒç¡®å®šç»™å®šå…ƒç´ æ˜¯å¦åœ¨åˆ—è¡¨ä¸­ã€‚å½“æä¾›ç»™å‡½æ•°çš„å€¼çš„ç±»å‹æ²¡æœ‰çº¦æŸæ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨ç±»å‹ `Any`ã€‚'
- en: Many useful computations can be performed by combining these operations.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡ç»„åˆè¿™äº›æ“ä½œï¼Œå¯ä»¥æ‰§è¡Œè®¸å¤šæœ‰ç”¨çš„è®¡ç®—ã€‚
- en: Exercise
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Assume you used a list of strings to represent the ingredients in a recipe.
    Here are three examples:'
  id: totrans-163
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å‡è®¾ä½ ä½¿ç”¨å­—ç¬¦ä¸²åˆ—è¡¨æ¥è¡¨ç¤ºé£Ÿè°±ä¸­çš„æˆåˆ†ã€‚ä»¥ä¸‹æœ‰ä¸‰ä¸ªç¤ºä¾‹ï¼š
- en: ''
  id: totrans-164
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-165
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ''
  id: totrans-166
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write the following functions on ingredient lists:'
  id: totrans-167
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨æˆåˆ†åˆ—è¡¨ä¸Šç¼–å†™ä»¥ä¸‹å‡½æ•°ï¼š
- en: ''
  id: totrans-168
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`recipes-uses`, which takes an ingredient list and an ingredient and determines
    whether the recipe uses the ingredient.'
  id: totrans-169
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recipes-uses`ï¼Œå®ƒæ¥å—ä¸€ä¸ªæˆåˆ†åˆ—è¡¨å’Œä¸€ä¸ªæˆåˆ†ï¼Œå¹¶ç¡®å®šè¯¥é£Ÿè°±æ˜¯å¦ä½¿ç”¨è¯¥æˆåˆ†ã€‚'
- en: ''
  id: totrans-170
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-171
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`make-vegetarian`, which takes an ingredient list and replaces all meat ingredients
    with `"tofu"`. Meat ingredients are `"pork"`, `"chicken"`, and `"beef"`.'
  id: totrans-172
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make-vegetarian`ï¼Œå®ƒæ¥å—ä¸€ä¸ªæˆåˆ†åˆ—è¡¨å¹¶å°†æ‰€æœ‰è‚‰ç±»æˆåˆ†æ›¿æ¢ä¸º `"tofu"`ã€‚è‚‰ç±»æˆåˆ†æ˜¯ `"pork"`ã€`"chicken"`
    å’Œ `"beef"`ã€‚'
- en: ''
  id: totrans-173
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-174
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`protein-veg-count`, which takes an ingredient list and determines how many
    ingredients are in the list that arenâ€™t `"rice"` or `"noodles"`.'
  id: totrans-175
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protein-veg-count`ï¼Œå®ƒæ¥å—ä¸€ä¸ªæˆåˆ†åˆ—è¡¨å¹¶ç¡®å®šåˆ—è¡¨ä¸­æœ‰å¤šå°‘æˆåˆ†ä¸æ˜¯ `"rice"` æˆ– `"noodles"`ã€‚'
- en: Exercise
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'More challenging: Write a function that takes an ingredient and a list of ingredient
    lists and produces a list of all the lists that contain the given ingredient.'
  id: totrans-178
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ›´å…·æŒ‘æˆ˜æ€§ï¼šç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒæ¥å—ä¸€ä¸ªæˆåˆ†å’Œæˆåˆ†åˆ—è¡¨çš„åˆ—è¡¨ï¼Œå¹¶ç”ŸæˆåŒ…å«ç»™å®šæˆåˆ†çš„æ‰€æœ‰åˆ—è¡¨ã€‚
- en: ''
  id: totrans-179
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Hint: write examples first to make sense of the problem as needed.'
  id: totrans-180
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æç¤ºï¼šé¦–å…ˆç¼–å†™ç¤ºä¾‹ï¼Œä»¥ä¾¿åœ¨éœ€è¦æ—¶ç†è§£é—®é¢˜ã€‚
- en: Exercise
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Even more challenging: Try to write a function that takes two ingredient lists
    and returns all of the ingredients that are common to both lists. What issue(s)
    or limitations do you run into?'
  id: totrans-183
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ›´å…·æŒ‘æˆ˜æ€§ï¼šå°è¯•ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸¤ä¸ªæˆåˆ†åˆ—è¡¨ï¼Œå¹¶è¿”å›ä¸¤ä¸ªåˆ—è¡¨ä¸­å…±åŒçš„æ‰€æœ‰æˆåˆ†ã€‚ä½ é‡åˆ°äº†å“ªäº›é—®é¢˜æˆ–é™åˆ¶ï¼Ÿ
- en: ''
  id: totrans-184
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Come back to this problem after you finish the next section.
  id: totrans-185
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨å®Œæˆä¸‹ä¸€èŠ‚ä¹‹åï¼Œå†å›åˆ°è¿™ä¸ªé—®é¢˜ã€‚
- en: '5.1.5Â Lambda: Anonymous Functions[ğŸ”—](#(part._.Lambda__.Anonymous_.Functions)
    "Link to here")'
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '5.1.5 Lambda: åŒ¿åå‡½æ•°[ğŸ”—](#(part._.Lambda__.Anonymous_.Functions) "é“¾æ¥åˆ°è¿™é‡Œ")'
- en: 'NOTE: if you already saw `lam` in [Lambda: Anonymous Functions](intro-tabular-data.html#%28part._sec~3alambda-tables%29),
    feel free to skip this section, or just do the exercises at the end. Here we present
    `lam` using lists and `filter`, rather than tables and `filter-with`.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ³¨æ„ï¼šå¦‚æœä½ å·²ç»åœ¨ [Lambda: åŒ¿åå‡½æ•°](intro-tabular-data.html#%28part._sec~3alambda-tables%29)
    ä¸­çœ‹åˆ°äº† `lam`ï¼Œé‚£ä¹ˆä½ å¯ä»¥è‡ªç”±åœ°è·³è¿‡è¿™ä¸€èŠ‚ï¼Œæˆ–è€…åªéœ€åšç»“å°¾çš„ç»ƒä¹ ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨åˆ—è¡¨å’Œ `filter` æ¥å±•ç¤º `lam`ï¼Œè€Œä¸æ˜¯ä½¿ç”¨è¡¨æ ¼å’Œ `filter-with`ã€‚'
- en: 'Letâ€™s revisit the program we wrote earlier in this chapter for finding all
    of the discount codes that were used in the events table:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹æœ¬ç« å‰é¢ç¼–å†™çš„ç¨‹åºï¼Œç”¨äºæŸ¥æ‰¾åœ¨äº‹ä»¶è¡¨ä¸­ä½¿ç”¨çš„æ‰€æœ‰æŠ˜æ‰£ä»£ç ï¼š
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This program might feel a bit verbose: do we really need to write a helper
    function just to perform something as simple as a `filter`? Wouldnâ€™t it be easier
    to just write something like:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªç¨‹åºå¯èƒ½æ„Ÿè§‰æœ‰ç‚¹å†—é•¿ï¼šæˆ‘ä»¬çœŸçš„éœ€è¦å†™ä¸€ä¸ªè¾…åŠ©å‡½æ•°æ¥æ‰§è¡Œåƒ `filter` è¿™æ ·ç®€å•çš„äº‹æƒ…å—ï¼Ÿç›´æ¥å†™ç‚¹åƒè¿™æ ·ä¸œè¥¿ä¸æ˜¯æ›´å®¹æ˜“å—ï¼Ÿ
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Do Now!
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What will Pyret produce if you run this expression?
  id: totrans-194
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœä½ è¿è¡Œè¿™ä¸ªè¡¨è¾¾å¼ï¼ŒPyret ä¼šäº§ç”Ÿä»€ä¹ˆç»“æœï¼Ÿ
- en: Pyret will produce an `unbound identifier` error around the use of `c` in this
    expression. What is `c`? We mean for `c` to be the elements from `codes` in turn.
    Conceptually, thatâ€™s what `filter` does, but we donâ€™t have the mechanics right.
    When we call a function, we evaluate the arguments before the body of the function.
    Hence, the error regarding `c` being unbound. The whole point of the `real-code`
    helper function is to make `c` a parameter to a function whose body is only evaluated
    once a value for `c` is available.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret ä¼šåœ¨è¯¥è¡¨è¾¾å¼ä¸­ `c` çš„ä½¿ç”¨å¤„äº§ç”Ÿä¸€ä¸ª `æœªç»‘å®šæ ‡è¯†ç¬¦` é”™è¯¯ã€‚`c` æ˜¯ä»€ä¹ˆï¼Ÿæˆ‘ä»¬å¸Œæœ› `c` ä¾æ¬¡æ˜¯ `codes` ä¸­çš„å…ƒç´ ã€‚ä»æ¦‚å¿µä¸Šè®²ï¼Œè¿™å°±æ˜¯
    `filter` æ‰€åšçš„ï¼Œä½†æˆ‘ä»¬æ²¡æœ‰æ­£ç¡®åœ°å¤„ç†æœºåˆ¶ã€‚å½“æˆ‘ä»¬è°ƒç”¨å‡½æ•°æ—¶ï¼Œæˆ‘ä»¬åœ¨å‡½æ•°ä½“ä¹‹å‰è¯„ä¼°å‚æ•°ã€‚å› æ­¤ï¼Œå…³äº `c` æœªç»‘å®šçš„é”™è¯¯ã€‚`real-code` è¾…åŠ©å‡½æ•°çš„å…¨éƒ¨ç›®çš„å°±æ˜¯ä½¿
    `c` æˆä¸ºå‡½æ•°çš„å‚æ•°ï¼Œè¯¥å‡½æ•°çš„ä¸»ä½“åªæœ‰åœ¨ `c` æœ‰å¯ç”¨å€¼æ—¶æ‰ä¼šè¢«è¯„ä¼°ã€‚
- en: 'To tighten the notation as in the one-line `filter` expression, then, we have
    to find a way to tell Pyret to make a temporary function that will get its inputs
    once `filter` is running. The following notation achieves this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ä½¿è®°å·æ›´åŠ ç´§å‡‘ï¼Œå°±åƒä¸€è¡Œ `filter` è¡¨è¾¾å¼é‚£æ ·ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦æ‰¾åˆ°ä¸€ç§æ–¹æ³•å‘Šè¯‰ Pyret åˆ›å»ºä¸€ä¸ªä¸´æ—¶å‡½æ•°ï¼Œè¯¥å‡½æ•°å°†åœ¨ `filter`
    è¿è¡Œæ—¶è·å–å…¶è¾“å…¥ã€‚ä»¥ä¸‹è®°å·å®ç°äº†è¿™ä¸€ç‚¹ï¼š
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We have added `lam(c)` and `end` around the expression that we want to use in
    the `filter`. The `lam(c)` says "make a temporary function that takes `c` as an
    input". The `end` serves to end the function definition, as when we use `fun`.
    `lam` is short for `lambda`, a form of function definition that exists in many,
    though not all, languages.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨æƒ³è¦åœ¨ `filter` ä¸­ä½¿ç”¨çš„è¡¨è¾¾å¼å‘¨å›´æ·»åŠ äº† `lam(c)` å’Œ `end`ã€‚`lam(c)` è¡¨ç¤ºâ€œåˆ›å»ºä¸€ä¸ªä»¥ `c` ä½œä¸ºè¾“å…¥çš„ä¸´æ—¶å‡½æ•°â€ã€‚`end`
    ç”¨äºç»“æŸå‡½æ•°å®šä¹‰ï¼Œå°±åƒæˆ‘ä»¬ä½¿ç”¨ `fun` ä¸€æ ·ã€‚`lam` æ˜¯ `lambda` çš„ç®€ç§°ï¼Œå®ƒæ˜¯ä¸€ç§å­˜åœ¨äºè®¸å¤šè¯­è¨€ä¸­ï¼ˆå°½ç®¡ä¸æ˜¯æ‰€æœ‰è¯­è¨€ï¼‰çš„å‡½æ•°å®šä¹‰å½¢å¼ã€‚
- en: 'The main difference between our original expression (using the `real-code`
    helper) and this new one (using `lam`) can be seen through the program directory.
    To explain this, a little detail about how `filter` is defined under the hood.
    In part, it looks like:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åŸå§‹è¡¨è¾¾å¼ï¼ˆä½¿ç”¨ `real-code` è¾…åŠ©å‡½æ•°ï¼‰å’Œè¿™ä¸ªæ–°è¡¨è¾¾å¼ï¼ˆä½¿ç”¨ `lam`ï¼‰ä¹‹é—´çš„ä¸»è¦åŒºåˆ«å¯ä»¥é€šè¿‡ç¨‹åºç›®å½•æ¥çœ‹åˆ°ã€‚ä¸ºäº†è§£é‡Šè¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦äº†è§£ä¸€ä¸‹
    `filter` åœ¨åº•å±‚æ˜¯å¦‚ä½•å®šä¹‰çš„ã€‚éƒ¨åˆ†åœ°ï¼Œå®ƒçœ‹èµ·æ¥åƒï¼š
- en: '[PRE27]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Whether we pass `real-code` or the `lam` version to `filter`, the `keep` parameter
    ends up referring to a function with the same parameter and body. Since the function
    is only actually called through the `keep` name, it doesnâ€™t matter whether or
    not a name is associated with it when it is initially defined.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: æ— è®ºæˆ‘ä»¬ä¼ é€’ `real-code` è¿˜æ˜¯ `lam` ç‰ˆæœ¬ç»™ `filter`ï¼Œ`keep` å‚æ•°æœ€ç»ˆéƒ½ä¼šæŒ‡å‘ä¸€ä¸ªå…·æœ‰ç›¸åŒå‚æ•°å’Œä¸»ä½“çš„å‡½æ•°ã€‚ç”±äºå‡½æ•°å®é™…ä¸Šæ˜¯é€šè¿‡
    `keep` åç§°è°ƒç”¨çš„ï¼Œå› æ­¤ï¼Œåœ¨æœ€åˆå®šä¹‰æ—¶ï¼Œæ˜¯å¦ä¸å®ƒå…³è”ä¸€ä¸ªåç§°å¹¶ä¸é‡è¦ã€‚
- en: In practice, we use `lam` when we have to pass simple (single line) functions
    to operations like `filter` (or `map`). We could have just as easily used them
    when we were working with tables (`build-column`, `filter-with`, etc). Of course,
    you can continue to write out names for helper functions as we did with `real-code`
    if that makes more sense to you.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šï¼Œå½“æˆ‘ä»¬éœ€è¦å°†ç®€å•çš„ï¼ˆå•è¡Œï¼‰å‡½æ•°ä¼ é€’ç»™`filter`ï¼ˆæˆ–`map`ï¼‰ç­‰æ“ä½œæ—¶ï¼Œæˆ‘ä»¬ä¼šä½¿ç”¨`lam`ã€‚æˆ‘ä»¬åŒæ ·å¯ä»¥åœ¨å¤„ç†è¡¨æ ¼æ—¶ä½¿ç”¨å®ƒä»¬ï¼ˆä¾‹å¦‚`build-column`ã€`filter-with`ç­‰ï¼‰ã€‚å½“ç„¶ï¼Œå¦‚æœæ‚¨è§‰å¾—è¿™æ ·æ›´åˆç†ï¼Œæ‚¨ä¹Ÿå¯ä»¥ç»§ç»­ä¸ºè¾…åŠ©å‡½æ•°ç¼–å†™åç§°ï¼Œå°±åƒæˆ‘ä»¬åœ¨`real-code`ä¸­åšçš„é‚£æ ·ã€‚
- en: Exercise
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write the program to extract the list of usernames from a list of email addresses
    using `lam` rather than a named helper-function.
  id: totrans-205
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ç¨‹åºä»¥ä½¿ç”¨`lam`è€Œä¸æ˜¯å‘½åè¾…åŠ©å‡½æ•°ä»ç”µå­é‚®ä»¶åœ°å€åˆ—è¡¨ä¸­æå–ç”¨æˆ·ååˆ—è¡¨ã€‚
- en: Exercise
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Try again to tackle the problem from the end of the previous section: write
    a function that takes two ingredient lists and returns all of the ingredients
    that are common to both lists.'
  id: totrans-208
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å†æ¬¡å°è¯•ä»ä¸Šä¸€èŠ‚æœ«å°¾å¤„ç†è¿™ä¸ªé—®é¢˜ï¼šç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸¤ä¸ªæˆåˆ†åˆ—è¡¨å¹¶è¿”å›ä¸¤ä¸ªåˆ—è¡¨ä¸­å…±åŒçš„æ‰€æœ‰æˆåˆ†ã€‚
- en: 5.1.6Â Combining Lists and Tables[ğŸ”—](#(part._.Combining_.Lists_and_.Tables) "Link
    to here")
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.6Â åˆå¹¶åˆ—è¡¨å’Œè¡¨æ ¼[ğŸ”—](#(part._.Combining_.Lists_and_.Tables) "é“¾æ¥è‡³æ­¤")
- en: The table functions we studied previously were primarily for processing rows.
    The list functions weâ€™ve learned in this chapter have been primarily for processing
    columns (but there are many more uses in the chapters ahead). If an analysis involves
    working with only some rows and some columns, weâ€™ll use a combination of both
    table and list functions in our program.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¹‹å‰ç ”ç©¶çš„è¡¨æ ¼å‡½æ•°ä¸»è¦ç”¨äºå¤„ç†è¡Œã€‚æˆ‘ä»¬åœ¨è¿™ç« ä¸­å­¦åˆ°çš„åˆ—è¡¨å‡½æ•°ä¸»è¦ç”¨äºå¤„ç†åˆ—ï¼ˆä½†æ¥ä¸‹æ¥çš„ç« èŠ‚ä¸­è¿˜æœ‰æ›´å¤šç”¨é€”ï¼‰ã€‚å¦‚æœä¸€ä¸ªåˆ†æåªæ¶‰åŠå¤„ç†ä¸€äº›è¡Œå’Œä¸€äº›åˆ—ï¼Œæˆ‘ä»¬å°†åœ¨ç¨‹åºä¸­ä½¿ç”¨è¡¨æ ¼å’Œåˆ—è¡¨å‡½æ•°çš„ç»„åˆã€‚
- en: Exercise
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the events table, produce a list of names of all people who will pick
    up their tickets.
  id: totrans-213
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ ¹æ®äº‹ä»¶è¡¨ï¼Œç”Ÿæˆæ‰€æœ‰å°†å–ç¥¨çš„äººçš„å§“ååˆ—è¡¨ã€‚
- en: Exercise
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the events table, produce the average number of tickets that were ordered
    by people with email addresses that end in `".org"`.
  id: totrans-216
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ ¹æ®äº‹ä»¶è¡¨ï¼Œç”Ÿæˆä»¥`".org"`ç»“å°¾çš„ç”µå­é‚®ä»¶åœ°å€çš„äººè®¢è´­çš„ç¥¨æ•°çš„å¹³å‡å€¼ã€‚
- en: 'Sometimes, there will be more than one way to perform a computation:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰æ—¶ï¼Œæ‰§è¡Œè®¡ç®—å¯èƒ½ä¼šæœ‰å¤šç§æ–¹å¼ï¼š
- en: Do Now!
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Consider a question such as "how many people with `".org"` email addresses bought
    more than 8 tickets". Propose multiple task plans that would solve this problem,
    including which table and list functions would accomplish each task.
  id: totrans-220
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è€ƒè™‘ä¸€ä¸ªé—®é¢˜ï¼Œæ¯”å¦‚â€œæœ‰å¤šå°‘äººä½¿ç”¨`".org"`ç”µå­é‚®ä»¶åœ°å€è´­ä¹°äº†è¶…è¿‡8å¼ ç¥¨â€ã€‚æå‡ºå¤šä¸ªä»»åŠ¡è®¡åˆ’æ¥è§£å†³æ­¤é—®é¢˜ï¼ŒåŒ…æ‹¬å“ªäº›è¡¨æ ¼å’Œåˆ—è¡¨å‡½æ•°å¯ä»¥å®Œæˆæ¯ä¸ªä»»åŠ¡ã€‚
- en: 'There are several options here:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰å‡ ä¸ªé€‰é¡¹ï¼š
- en: Get the `event-data` rows with no more than 8 tickets (using `filter-with`),
    get those rows that have `".org"` addresses (another `filter-with`), then ask
    for how many rows are in the table (using `<table>.length()`).
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`filter-with`è·å–ä¸è¶…è¿‡8å¼ ç¥¨çš„`event-data`è¡Œï¼Œè·å–å…·æœ‰`".org"`åœ°å€çš„è¡Œï¼ˆå¦ä¸€ä¸ª`filter-with`ï¼‰ï¼Œç„¶åè¯¢é—®è¡¨æ ¼ä¸­æœ‰å¤šå°‘è¡Œï¼ˆä½¿ç”¨`<table>.length()`ï¼‰ã€‚
- en: Get the `event-data` rows with no more than 8 tickets and `".org"` address (using
    `filter-with` with a function that checks both conditions at once), then ask for
    how many rows are in the table (using `<table>.length()`).
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`filter-with`è·å–ä¸è¶…è¿‡8å¼ ç¥¨å’Œ`".org"`åœ°å€çš„`event-data`è¡Œï¼ˆä½¿ç”¨åŒæ—¶æ£€æŸ¥ä¸¤ä¸ªæ¡ä»¶çš„å‡½æ•°ï¼‰ï¼Œç„¶åè¯¢é—®è¡¨æ ¼ä¸­æœ‰å¤šå°‘è¡Œï¼ˆä½¿ç”¨`<table>.length()`ï¼‰ã€‚
- en: Get the `event-data` rows with no more than 8 tickets (using `filter-with`),
    extract the email addresses (using `get-column`), limit those to `".org"` (using
    `L.filter`), then get the length of the resulting list (using `L.length`).
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`filter-with`è·å–ä¸è¶…è¿‡8å¼ ç¥¨çš„`event-data`è¡Œï¼Œæå–ç”µå­é‚®ä»¶åœ°å€ï¼ˆä½¿ç”¨`get-column`ï¼‰ï¼Œé™åˆ¶ä¸º`".org"`ï¼ˆä½¿ç”¨`L.filter`ï¼‰ï¼Œç„¶åè·å–ç»“æœçš„é•¿åº¦ï¼ˆä½¿ç”¨`L.length`ï¼‰ã€‚
- en: There are others, but you get the idea.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: è¿˜æœ‰å…¶ä»–çš„ï¼Œä½†ä½ åº”è¯¥æ˜ç™½äº†ã€‚
- en: Do Now!
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which approach do you like best? Why?
  id: totrans-228
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ æœ€å–œæ¬¢å“ªç§æ–¹æ³•ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ
- en: 'While there is no single correct answer, there are various considerations:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶æ²¡æœ‰å”¯ä¸€çš„æ­£ç¡®ç­”æ¡ˆï¼Œä½†æœ‰ä¸€äº›è€ƒè™‘å› ç´ ï¼š
- en: Are any of the intermediate results useful for other computations? While the
    second option might seem best because it filters the table once rather than twice,
    perhaps the events company has many computations to perform on larger ticket orders.
    Similarly, the company may want the list of email addresses on large orders for
    other purposes (the third option)
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä»»ä½•ä¸­é—´ç»“æœå¯¹å…¶ä»–è®¡ç®—æœ‰ç”¨å—ï¼Ÿè™½ç„¶ç¬¬äºŒä¸ªé€‰é¡¹çœ‹èµ·æ¥æœ€å¥½ï¼Œå› ä¸ºå®ƒåªè¿‡æ»¤ä¸€æ¬¡è¡¨æ ¼è€Œä¸æ˜¯ä¸¤æ¬¡ï¼Œä½†ä¹Ÿè®¸äº‹ä»¶å…¬å¸éœ€è¦å¯¹å¤§é‡è®¢å•æ‰§è¡Œè®¸å¤šè®¡ç®—ã€‚åŒæ ·ï¼Œå…¬å¸å¯èƒ½éœ€è¦å¤§è®¢å•çš„ç”µå­é‚®ä»¶åœ°å€åˆ—è¡¨ç”¨äºå…¶ä»–ç›®çš„ï¼ˆç¬¬ä¸‰ä¸ªé€‰é¡¹ï¼‰
- en: Do you want to follow a discipline of doing operations on individuals within
    the table, extracting lists only when needed to perform aggregating computations
    that arenâ€™t available on tables?
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½ æ˜¯å¦å¸Œæœ›éµå¾ªåœ¨è¡¨æ ¼ä¸­å¯¹ä¸ªä½“è¿›è¡Œæ“ä½œçš„çºªå¾‹ï¼Œä»…åœ¨éœ€è¦æ‰§è¡Œè¡¨æ ¼ä¸Šä¸å¯ç”¨çš„èšåˆè®¡ç®—æ—¶æå–åˆ—è¡¨ï¼Ÿ
- en: 'Does one approach seem less resource-intensive than the other? This is actually
    a subtle point: you might be tempted to think that filtering over a table uses
    more resources than filtering over a list of values from one column, but this
    actually isnâ€™t the case. Weâ€™ll return to this discussion later.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœ‰ä¸€ç§æ–¹æ³•çœ‹èµ·æ¥æ¯”å¦ä¸€ç§æ–¹æ³•æ›´èŠ‚çœèµ„æºå—ï¼Ÿè¿™å®é™…ä¸Šæ˜¯ä¸€ä¸ªå¾®å¦™çš„é—®é¢˜ï¼šä½ å¯èƒ½å€¾å‘äºè®¤ä¸ºåœ¨è¡¨æ ¼ä¸Šè¿‡æ»¤æ¯”åœ¨æŸä¸€åˆ—çš„å€¼åˆ—è¡¨ä¸Šè¿‡æ»¤ä½¿ç”¨æ›´å¤šèµ„æºï¼Œä½†å®é™…ä¸Šå¹¶éå¦‚æ­¤ã€‚æˆ‘ä»¬ç¨åä¼šå›åˆ°è¿™ä¸ªè®¨è®ºã€‚
- en: A company or project team sometimes sets design standards to help you make those
    decisions. In the absence of that, and especially as you are learning to program,
    consider multiple approaches when faced with such problems, then pick one to implement.
    Maintaining the ability to think flexibly about approaches is a useful skill in
    any form of design.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: å…¬å¸æˆ–é¡¹ç›®å›¢é˜Ÿæœ‰æ—¶ä¼šè®¾å®šè®¾è®¡æ ‡å‡†æ¥å¸®åŠ©ä½ åšå‡ºè¿™äº›å†³å®šã€‚åœ¨æ²¡æœ‰è¿™äº›æ ‡å‡†çš„æƒ…å†µä¸‹ï¼Œå°¤å…¶æ˜¯åœ¨ä½ å­¦ä¹ ç¼–ç¨‹æ—¶ï¼Œé¢å¯¹æ­¤ç±»é—®é¢˜æ—¶ï¼Œè€ƒè™‘å¤šç§æ–¹æ³•ï¼Œç„¶åé€‰æ‹©ä¸€ç§æ¥å®ç°ã€‚ä¿æŒçµæ´»æ€è€ƒæ–¹æ³•çš„èƒ½åŠ›åœ¨ä»»ä½•å½¢å¼çš„è®¾è®¡ä¸­éƒ½æ˜¯ä¸€é¡¹æœ‰ç”¨çš„æŠ€èƒ½ã€‚
- en: Until now weâ€™ve only seen how to use built-in functions over lists. Next [[Processing
    Lists](processing-lists.html)], we will study how to create our own functions
    that process lists. Once we learn that, these list processing functions will remain
    powerful but will no longer seem quite so magical, because weâ€™ll be able to build
    them for ourselves!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬åªçœ‹åˆ°äº†å¦‚ä½•ä½¿ç”¨åˆ—è¡¨ä¸Šçš„å†…ç½®å‡½æ•°ã€‚æ¥ä¸‹æ¥ [[å¤„ç†åˆ—è¡¨](processing-lists.html)]ï¼Œæˆ‘ä»¬å°†ç ”ç©¶å¦‚ä½•åˆ›å»ºæˆ‘ä»¬è‡ªå·±çš„å¤„ç†åˆ—è¡¨çš„å‡½æ•°ã€‚ä¸€æ—¦æˆ‘ä»¬å­¦ä¼šäº†è¿™ä¸€ç‚¹ï¼Œè¿™äº›åˆ—è¡¨å¤„ç†å‡½æ•°å°†ä¿æŒå¼ºå¤§ï¼Œä½†å°†ä¸å†æ˜¾å¾—é‚£ä¹ˆç¥å¥‡ï¼Œå› ä¸ºæˆ‘ä»¬å°†èƒ½å¤Ÿä¸ºè‡ªå·±æ„å»ºå®ƒä»¬ï¼
- en: 5.1.1Â Basic Statistical Questions[ğŸ”—](#(part._table-stat-qs) "Link to here")
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.1 åŸºæœ¬ç»Ÿè®¡é—®é¢˜[ğŸ”—](#(part._table-stat-qs) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'There are many more questions we might want to ask of our events data. For
    instance:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯èƒ½è¿˜æƒ³å¯¹äº‹ä»¶æ•°æ®æå‡ºæ›´å¤šé—®é¢˜ã€‚ä¾‹å¦‚ï¼š
- en: The most-frequently used discount code.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœ€å¸¸ä½¿ç”¨çš„æŠ˜æ‰£ä»£ç ã€‚
- en: The average number of tickets per order.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¯ä¸ªè®¢å•çš„å¹³å‡ç¥¨æ•°ã€‚
- en: The largest ticket order.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœ€å¤§çš„ç¥¨è®¢å•ã€‚
- en: The most common number of tickets in an order.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è®¢å•ä¸­æœ€å¸¸è§çš„ç¥¨æ•°ã€‚
- en: The collection of unique discount codes that were used (many might have been
    available).
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿‡çš„å”¯ä¸€æŠ˜æ‰£ä»£ç é›†åˆï¼ˆå¯èƒ½æœ‰å¾ˆå¤šå¯ç”¨ï¼‰ã€‚
- en: The collection of distinct email addresses associated with orders, so we can
    contact customers (some customers may have placed multiple orders).
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸è®¢å•ç›¸å…³è”çš„ç‹¬ç«‹ç”µå­é‚®ä»¶åœ°å€é›†åˆï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥è”ç³»å®¢æˆ·ï¼ˆä¸€äº›å®¢æˆ·å¯èƒ½ä¸‹äº†å¤šä¸ªè®¢å•ï¼‰ã€‚
- en: Which school lead to the largest number of orders with a `"STUDENT"` discount.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å“ªæ‰€å­¦æ ¡å¯¼è‡´äº†æ‹¥æœ‰æœ€å¤šâ€œSTUDENTâ€æŠ˜æ‰£çš„è®¢å•æ•°é‡ã€‚
- en: 'Notice the kinds of operations that we are talking about: computing the maximum,
    minimum, average, median, and other basic statistics.Pyret has several built-in
    statistics functions in the [math](http://www.pyret.org/docs/latest/math.html)
    and [statistics](http://www.pyret.org/docs/latest/statistics.html) packages.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„æˆ‘ä»¬æ­£åœ¨è®¨è®ºçš„æ“ä½œç±»å‹ï¼šè®¡ç®—æœ€å¤§å€¼ã€æœ€å°å€¼ã€å¹³å‡å€¼ã€ä¸­ä½æ•°å’Œå…¶ä»–åŸºæœ¬ç»Ÿè®¡é‡ã€‚Pyretåœ¨[math](http://www.pyret.org/docs/latest/math.html)å’Œ[statistics](http://www.pyret.org/docs/latest/statistics.html)åŒ…ä¸­æä¾›äº†å‡ ä¸ªå†…ç½®çš„ç»Ÿè®¡å‡½æ•°ã€‚
- en: Do Now!
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Think about whether and how you would express these questions with the operations
    you have already seen.
  id: totrans-247
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ€è€ƒä½ æ˜¯å¦ä»¥åŠå¦‚ä½•ä½¿ç”¨ä½ å·²ç»çœ‹åˆ°çš„æ“ä½œæ¥è¡¨è¾¾è¿™äº›é—®é¢˜ã€‚
- en: In each of these cases, we need to perform a computation on a single column
    of data (even in the last question about the `"STUDENT"` discount, as we would
    filter the table to those rows, then do a computation over the `email` column).
    In order to capture these in code, we need to extract a column from the table.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™äº›æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éœ€è¦å¯¹æ•°æ®çš„ä¸€ä¸ªå•ç‹¬åˆ—è¿›è¡Œè®¡ç®—ï¼ˆç”šè‡³åœ¨å…³äºâ€œSTUDENTâ€æŠ˜æ‰£çš„æœ€åä¸€ä¸ªé—®é¢˜ä¸­ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œå› ä¸ºæˆ‘ä»¬ä¼šè¿‡æ»¤è¡¨æ ¼åˆ°é‚£äº›è¡Œï¼Œç„¶ååœ¨`email`åˆ—ä¸Šæ‰§è¡Œè®¡ç®—ï¼‰ã€‚ä¸ºäº†åœ¨ä»£ç ä¸­æ•è·è¿™äº›ï¼Œæˆ‘ä»¬éœ€è¦ä»è¡¨ä¸­æå–ä¸€åˆ—ã€‚
- en: For the rest of this chapter, we will work with a cleaned copy of the `event-data`
    from the previous chapter. The cleaned data, which applies the transformations
    at the end of the previous chapter, is in a different tab of the same Google Sheet
    as the other versions of the event data.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬ç« çš„å‰©ä½™éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ä¸Šä¸€ç« çš„`event-data`çš„æ¸…ç†å‰¯æœ¬è¿›è¡Œå·¥ä½œã€‚ç»è¿‡ä¸Šä¸€ç« æœ«å°¾è½¬æ¢çš„æ¸…ç†æ•°æ®ä½äºåŒä¸€Googleè¡¨æ ¼çš„ä¸åŒæ ‡ç­¾é¡µä¸­ï¼Œä¸å…¶ä»–ç‰ˆæœ¬çš„äº‹ä»¶æ•°æ®ç›¸åŒã€‚
- en: '[PRE28]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 5.1.2Â Extracting a Column from a Table[ğŸ”—](#(part._.Extracting_a_.Column_from_a_.Table)
    "Link to here")
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.2 ä»è¡¨ä¸­æå–åˆ—[ğŸ”—](#(part._.Extracting_a_.Column_from_a_.Table) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Our collection of table functions includes one that we havenâ€™t yet used, called
    `select-columns`. As the name suggests, this function produces a new table containing
    only certain columns from an existing table. Letâ€™s extract the `tickcount` column
    so we can compute some statistics over it. We use the following expression:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„è¡¨æ ¼å‡½æ•°é›†åˆä¸­åŒ…æ‹¬ä¸€ä¸ªæˆ‘ä»¬å°šæœªä½¿ç”¨çš„å‡½æ•°ï¼Œç§°ä¸º `select-columns`ã€‚æ­£å¦‚å…¶åç§°æ‰€æš—ç¤ºçš„ï¼Œè¿™ä¸ªå‡½æ•°ä¼šç”Ÿæˆä¸€ä¸ªæ–°çš„è¡¨æ ¼ï¼Œå…¶ä¸­åªåŒ…å«ç°æœ‰è¡¨æ ¼ä¸­çš„æŸäº›åˆ—ã€‚è®©æˆ‘ä»¬æå–
    `tickcount` åˆ—ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥å¯¹å…¶è®¡ç®—ä¸€äº›ç»Ÿè®¡æ•°æ®ã€‚æˆ‘ä»¬ä½¿ç”¨ä»¥ä¸‹è¡¨è¾¾å¼ï¼š
- en: '[PRE29]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![](../Images/218dbd3d076ef24041ce988f1e4f6c1d.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/218dbd3d076ef24041ce988f1e4f6c1d.png)'
- en: This focuses our attention on the numeric ticket sales, but weâ€™re still stuck
    with a column in a table, and none of the other tables functions let us do the
    kinds of computations we might want over these numbers. Ideally, we want the collection
    of numbers on their own, without being wrapped up in the extra layer of table
    cells.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä½¿æˆ‘ä»¬ä¸“æ³¨äºæ•°å­—é—¨ç¥¨é”€å”®ï¼Œä½†æˆ‘ä»¬ä»ç„¶è¢«å›°åœ¨è¡¨æ ¼ä¸­çš„åˆ—ä¸­ï¼Œè€Œä¸”å…¶ä»–è¡¨æ ¼å‡½æ•°éƒ½ä¸èƒ½è®©æˆ‘ä»¬å¯¹è¿™äº›æ•°å­—è¿›è¡Œæˆ‘ä»¬å¯èƒ½æƒ³è¦çš„è®¡ç®—ã€‚ç†æƒ³æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¸Œæœ›æ‹¥æœ‰è¿™äº›æ•°å­—çš„é›†åˆï¼Œè€Œä¸éœ€è¦è¢«åŒ…è£¹åœ¨é¢å¤–çš„è¡¨æ ¼å•å…ƒæ ¼å±‚ä¸­ã€‚
- en: In principle, we could have a collection of operations on a single column. In
    some languages that focus solely on tables, such as [SQL](https://en.wikipedia.org/wiki/SQL),
    this is what youâ€™ll find. However, in Pyret we have many more kinds of data than
    just columns (as weâ€™ll soon see [[Introduction to Structured Data](intro-struct-data.html)],
    we can even create our own!), so it makes sense to leave the gentle cocoon of
    tables sooner or later. An extracted column is a more basic kind of datum called
    a list, which can be used to represent a sequence of data outside of a table.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨åŸåˆ™ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å•ä¸ªåˆ—ä¸Šæ‰§è¡Œä¸€ç³»åˆ—æ“ä½œã€‚åœ¨ä¸€äº›åªå…³æ³¨è¡¨æ ¼çš„è¯­è¨€ä¸­ï¼Œä¾‹å¦‚ [SQL](https://en.wikipedia.org/wiki/SQL)ï¼Œä½ å°†å‘ç°è¿™å°±æ˜¯ä½ éœ€è¦çš„ã€‚ç„¶è€Œï¼Œåœ¨
    Pyret ä¸­ï¼Œæˆ‘ä»¬æ‹¥æœ‰çš„æ•°æ®ç±»å‹è¿œä¸æ­¢åˆ—ï¼ˆæ­£å¦‚æˆ‘ä»¬å¾ˆå¿«å°±ä¼šçœ‹åˆ°çš„ [[ç»“æ„åŒ–æ•°æ®ä»‹ç»](intro-struct-data.html)]ï¼Œæˆ‘ä»¬ç”šè‡³å¯ä»¥åˆ›å»ºè‡ªå·±çš„æ•°æ®ç±»å‹ï¼ï¼‰ï¼Œå› æ­¤ï¼Œè¿Ÿæ—©ç¦»å¼€è¡¨æ ¼çš„æ¸©æŸ”èŒ§æˆ¿æ˜¯æœ‰æ„ä¹‰çš„ã€‚æå–å‡ºçš„åˆ—æ˜¯ä¸€ç§æ›´åŸºæœ¬çš„æ•°æ®ç±»å‹ï¼Œç§°ä¸ºåˆ—è¡¨ï¼Œå®ƒå¯ä»¥ç”¨æ¥è¡¨ç¤ºè¡¨æ ¼ä¹‹å¤–çš„æ•°æ®åºåˆ—ã€‚
- en: 'Just as we have used the notation `.row-n` to pull a single row from a table,
    we use a similar dot-based notion to pull out a single column. Hereâ€™s how we extract
    the `tickcount` column:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬ä½¿ç”¨ `.row-n` è¯­æ³•ä»è¡¨æ ¼ä¸­æå–å•è¡Œä¸€æ ·ï¼Œæˆ‘ä»¬ä½¿ç”¨ç±»ä¼¼çš„åŸºäºç‚¹çš„æ¦‚å¿µæ¥æå–å•åˆ—ã€‚ä»¥ä¸‹æ˜¯å¦‚ä½•æå– `tickcount` åˆ—çš„ç¤ºä¾‹ï¼š
- en: '[PRE30]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In response, Pyret produces the following value:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºå›åº”ï¼ŒPyret äº§ç”Ÿäº†ä»¥ä¸‹å€¼ï¼š
- en: '[PRE31]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we seem to have only the values that were in the cells in the column,
    without the enclosing table. Yet the numbers are still bundled up, this time in
    the `[list: ...]` notation. What is that?'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç°åœ¨ï¼Œæˆ‘ä»¬ä¼¼ä¹åªæœ‰åˆ—ä¸­çš„å€¼ï¼Œæ²¡æœ‰åŒ…å«çš„è¡¨æ ¼ã€‚ç„¶è€Œï¼Œæ•°å­—ç°åœ¨è¢«æ†ç»‘åœ¨ä¸€èµ·ï¼Œè¿™æ¬¡æ˜¯åœ¨ `[list: ...]` è¯­æ³•ä¸­ã€‚é‚£æ˜¯ä»€ä¹ˆï¼Ÿ'
- en: 5.1.3Â Understanding Lists[ğŸ”—](#(part._.Understanding_.Lists) "Link to here")
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.3Â ç†è§£åˆ—è¡¨[ğŸ”—](#(part._.Understanding_.Lists) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'A list has much in common with a single-column table:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ä¸å•åˆ—è¡¨æ ¼æœ‰å¾ˆå¤šå…±åŒä¹‹å¤„ï¼š
- en: The elements have an order, so it makes sense to talk about the â€œfirstâ€, â€œsecondâ€,
    â€œlastâ€â€”<wbr>and so onâ€”<wbr>element of a list.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å…ƒç´ å…·æœ‰é¡ºåºï¼Œå› æ­¤è°ˆè®ºåˆ—è¡¨çš„â€œç¬¬ä¸€ä¸ªâ€ã€â€œç¬¬äºŒä¸ªâ€ã€â€œæœ€åä¸€ä¸ªâ€â€”â€”ä»¥åŠç­‰ç­‰â€”â€”å…ƒç´ æ˜¯æœ‰æ„ä¹‰çš„ã€‚
- en: All elements of a list are expected to have the same type.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ—è¡¨çš„æ‰€æœ‰å…ƒç´ éƒ½æœŸæœ›å…·æœ‰ç›¸åŒçš„ç±»å‹ã€‚
- en: The crucial difference is that a list does not have a â€œcolumn nameâ€; it is anonymous.
    That is, by itself a list does not describe what it represents; this interpretation
    is done by our program.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: å…³é”®çš„åŒºåˆ«åœ¨äºåˆ—è¡¨æ²¡æœ‰â€œåˆ—åâ€ï¼›å®ƒæ˜¯åŒ¿åçš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåˆ—è¡¨æœ¬èº«å¹¶ä¸æè¿°å®ƒæ‰€ä»£è¡¨çš„å†…å®¹ï¼›è¿™ç§è§£é‡Šæ˜¯ç”±æˆ‘ä»¬çš„ç¨‹åºå®Œæˆçš„ã€‚
- en: 5.1.3.1Â Lists as Anonymous Data[ğŸ”—](#(part._lists-generic-data) "Link to here")
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1.3.1Â åˆ—è¡¨ä½œä¸ºåŒ¿åæ•°æ®[ğŸ”—](#(part._lists-generic-data) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'This might sound rather abstractâ€”<wbr>and it isâ€”<wbr>but this isnâ€™t actually
    a new idea in our programming experience. Consider a value like `3` or `-1`: what
    is it? Itâ€™s the same sort of thing: an anonymous value that does not describe
    what it represents; the interpretation is done by our program. In one setting
    `3` may represent an age, in another a play count; in one setting `-1` may be
    a temperature, in another the average of several temperatures. Similarly with
    a string: Is `"project"` a noun (an activity that one or more people perform)
    or a verb (as when we display something on a screen)? Likewise with images and
    so on. In fact, tables have been the exception so far in having description built
    into the data rather than being provided by a program!'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯èƒ½å¬èµ·æ¥ç›¸å½“æŠ½è±¡â€”â€”<wbr>ç¡®å®å¦‚æ­¤â€”â€”<wbr>ä½†è¿™å¹¶ä¸æ˜¯æˆ‘ä»¬ç¼–ç¨‹ç»éªŒä¸­çš„æ–°æƒ³æ³•ã€‚è€ƒè™‘ä¸€ä¸ªåƒ `3` æˆ– `-1` è¿™æ ·çš„å€¼ï¼šå®ƒæ˜¯ä»€ä¹ˆï¼Ÿå®ƒå±äºåŒä¸€ç±»ï¼šä¸€ä¸ªåŒ¿åå€¼ï¼Œä¸æè¿°å®ƒæ‰€ä»£è¡¨çš„å†…å®¹ï¼›è§£é‡Šç”±æˆ‘ä»¬çš„ç¨‹åºå®Œæˆã€‚åœ¨ä¸€ä¸ªç¯å¢ƒä¸­ï¼Œ`3`
    å¯èƒ½ä»£è¡¨å¹´é¾„ï¼Œåœ¨å¦ä¸€ä¸ªç¯å¢ƒä¸­å¯èƒ½ä»£è¡¨æ’­æ”¾æ¬¡æ•°ï¼›åœ¨ä¸€ä¸ªç¯å¢ƒä¸­ `-1` å¯èƒ½æ˜¯æ¸©åº¦ï¼Œåœ¨å¦ä¸€ä¸ªç¯å¢ƒä¸­å¯èƒ½æ˜¯å‡ ä¸ªæ¸©åº¦çš„å¹³å‡å€¼ã€‚åŒæ ·ï¼Œå¯¹äºå­—ç¬¦ä¸²ï¼š`"project"`
    æ˜¯åè¯ï¼ˆä¸€ä¸ªäººæˆ–å¤šäººæ‰§è¡Œçš„æ´»åŠ¨ï¼‰è¿˜æ˜¯åŠ¨è¯ï¼ˆä¾‹å¦‚ï¼Œå½“æˆ‘ä»¬æŠŠæŸç‰©æ˜¾ç¤ºåœ¨å±å¹•ä¸Šæ—¶ï¼‰ï¼ŸåŒæ ·ï¼Œå¯¹äºå›¾åƒç­‰ä¹Ÿæ˜¯å¦‚æ­¤ã€‚äº‹å®ä¸Šï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼Œè¡¨æ ¼æ˜¯ä¾‹å¤–ï¼Œæè¿°æ˜¯å†…ç½®äºæ•°æ®ä¸­è€Œä¸æ˜¯ç”±ç¨‹åºæä¾›çš„ï¼
- en: This genericity is both a virtue and a problem. Because, like other anonymous
    data, a list does not provide any interpretation of its use, if we are not careful
    we can accidentally mis-interpret the values. On the other hand, it means we can
    use the same datum in several different contexts, and one operation can be used
    in many settings.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 'è¿™ç§é€šç”¨æ€§æ—¢æ˜¯ä¼˜ç‚¹ä¹Ÿæ˜¯é—®é¢˜ã€‚å› ä¸ºï¼Œåƒå…¶ä»–åŒ¿åæ•°æ®ä¸€æ ·ï¼Œåˆ—è¡¨ä¸æä¾›å¯¹å…¶ä½¿ç”¨çš„ä»»ä½•è§£é‡Šï¼Œå¦‚æœæˆ‘ä»¬ä¸å°å¿ƒï¼Œæˆ‘ä»¬å¯èƒ½ä¼šé”™è¯¯åœ°è§£é‡Šå€¼ã€‚å¦ä¸€æ–¹é¢ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥åœ¨å‡ ä¸ªä¸åŒçš„ç¯å¢ƒä¸­ä½¿ç”¨ç›¸åŒçš„æ•°æ®ï¼Œä¸€ä¸ªæ“ä½œå¯ä»¥åœ¨è®¸å¤šè®¾ç½®ä¸­ä½¿ç”¨ã€‚ '
- en: Indeed, if we look at the list of questions we asked earlier, we see that there
    are several common operationsâ€”<wbr>maximum, minimum, average, and so onâ€”<wbr>that
    can be asked of a list of values without regard for what the list represents (heights,
    ages, playcounts). In fact, some are specific to numbers (like average) while
    some (like maximum) can be asked of any type on which we can perform a comparison
    (like strings).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: äº‹å®ä¸Šï¼Œå¦‚æœæˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬ä¹‹å‰æå‡ºçš„é—®é¢˜åˆ—è¡¨ï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ°æœ‰å‡ ä¸ªå¸¸è§çš„æ“ä½œâ€”â€”<wbr>æœ€å¤§å€¼ã€æœ€å°å€¼ã€å¹³å‡å€¼ç­‰â€”â€”<wbr>å¯ä»¥åœ¨ä¸è€ƒè™‘åˆ—è¡¨ä»£è¡¨ä»€ä¹ˆï¼ˆèº«é«˜ã€å¹´é¾„ã€æ’­æ”¾æ¬¡æ•°ï¼‰çš„æƒ…å†µä¸‹å¯¹å€¼åˆ—è¡¨è¿›è¡Œæé—®ã€‚å®é™…ä¸Šï¼Œæœ‰äº›æ˜¯ç‰¹å®šäºæ•°å­—çš„ï¼ˆå¦‚å¹³å‡å€¼ï¼‰ï¼Œè€Œæœ‰äº›ï¼ˆå¦‚æœ€å¤§å€¼ï¼‰å¯ä»¥é’ˆå¯¹æˆ‘ä»¬å¯ä»¥æ‰§è¡Œæ¯”è¾ƒçš„ä»»ä½•ç±»å‹è¿›è¡Œæé—®ï¼ˆå¦‚å­—ç¬¦ä¸²ï¼‰ã€‚
- en: 5.1.3.2Â Creating Literal Lists[ğŸ”—](#(part._.Creating_.Literal_.Lists) "Link to
    here")
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1.3.2 åˆ›å»ºå­—é¢é‡åˆ—è¡¨[ğŸ”—](#(part._.Creating_.Literal_.Lists) "é“¾æ¥è‡³æ­¤")
- en: 'We have already seen how we can create lists from a table, using `get-column`.
    As you might expect, however, we can also create lists directly:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»çœ‹åˆ°å¦‚ä½•ä½¿ç”¨ `get-column` ä»è¡¨æ ¼åˆ›å»ºåˆ—è¡¨ã€‚ç„¶è€Œï¼Œæ­£å¦‚ä½ æ‰€é¢„æœŸçš„ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ç›´æ¥åˆ›å»ºåˆ—è¡¨ï¼š
- en: '[PRE32]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Of course, lists are values so we can name them using variablesâ€”<wbr>
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œåˆ—è¡¨æ˜¯å€¼ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨å˜é‡æ¥å‘½åå®ƒä»¬â€”â€”<wbr>
- en: '[PRE33]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: â€”<wbr>pass them to functions (as we will soon see), and so on.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: â€”â€”<wbr>å°†å®ƒä»¬ä¼ é€’ç»™å‡½æ•°ï¼ˆæ­£å¦‚æˆ‘ä»¬å¾ˆå¿«å°†çœ‹åˆ°çš„ï¼‰ï¼Œç­‰ç­‰ã€‚
- en: Do Now!
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Based on these examples, can you figure out how to create an empty list?
  id: totrans-279
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ ¹æ®è¿™äº›ä¾‹å­ï¼Œä½ èƒ½æƒ³å‡ºå¦‚ä½•åˆ›å»ºä¸€ä¸ªç©ºåˆ—è¡¨å—ï¼Ÿ
- en: 'As you might have guessed, itâ€™s `[list: ]` (the space isnâ€™t necessary, but
    itâ€™s a useful visual reminder of the void).'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 'å¦‚ä½ æ‰€çŒœæƒ³çš„ï¼Œå®ƒæ˜¯ `[list: ]`ï¼ˆç©ºæ ¼ä¸æ˜¯å¿…éœ€çš„ï¼Œä½†å®ƒæ˜¯ä¸€ä¸ªæœ‰ç”¨çš„è§†è§‰æé†’ï¼Œè¡¨ç¤ºç©ºç™½ï¼‰ã€‚'
- en: 5.1.3.1Â Lists as Anonymous Data[ğŸ”—](#(part._lists-generic-data) "Link to here")
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1.3.1 åˆ—ä½œä¸ºåŒ¿åæ•°æ®[ğŸ”—](#(part._lists-generic-data) "é“¾æ¥è‡³æ­¤")
- en: 'This might sound rather abstractâ€”<wbr>and it isâ€”<wbr>but this isnâ€™t actually
    a new idea in our programming experience. Consider a value like `3` or `-1`: what
    is it? Itâ€™s the same sort of thing: an anonymous value that does not describe
    what it represents; the interpretation is done by our program. In one setting
    `3` may represent an age, in another a play count; in one setting `-1` may be
    a temperature, in another the average of several temperatures. Similarly with
    a string: Is `"project"` a noun (an activity that one or more people perform)
    or a verb (as when we display something on a screen)? Likewise with images and
    so on. In fact, tables have been the exception so far in having description built
    into the data rather than being provided by a program!'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯èƒ½å¬èµ·æ¥ç›¸å½“æŠ½è±¡â€”â€”<wbr>ç¡®å®å¦‚æ­¤â€”â€”<wbr>ä½†è¿™å¹¶ä¸æ˜¯æˆ‘ä»¬ç¼–ç¨‹ç»éªŒä¸­çš„æ–°æƒ³æ³•ã€‚è€ƒè™‘ä¸€ä¸ªåƒ `3` æˆ– `-1` è¿™æ ·çš„å€¼ï¼šå®ƒæ˜¯ä»€ä¹ˆï¼Ÿå®ƒå±äºåŒä¸€ç±»ï¼šä¸€ä¸ªåŒ¿åå€¼ï¼Œä¸æè¿°å®ƒæ‰€ä»£è¡¨çš„å†…å®¹ï¼›è§£é‡Šç”±æˆ‘ä»¬çš„ç¨‹åºå®Œæˆã€‚åœ¨ä¸€ä¸ªç¯å¢ƒä¸­ï¼Œ`3`
    å¯èƒ½ä»£è¡¨å¹´é¾„ï¼Œåœ¨å¦ä¸€ä¸ªç¯å¢ƒä¸­å¯èƒ½ä»£è¡¨æ’­æ”¾æ¬¡æ•°ï¼›åœ¨ä¸€ä¸ªç¯å¢ƒä¸­ `-1` å¯èƒ½æ˜¯æ¸©åº¦ï¼Œåœ¨å¦ä¸€ä¸ªç¯å¢ƒä¸­å¯èƒ½æ˜¯å‡ ä¸ªæ¸©åº¦çš„å¹³å‡å€¼ã€‚åŒæ ·ï¼Œå¯¹äºå­—ç¬¦ä¸²ï¼š`"project"`
    æ˜¯åè¯ï¼ˆä¸€ä¸ªäººæˆ–å¤šäººæ‰§è¡Œçš„æ´»åŠ¨ï¼‰è¿˜æ˜¯åŠ¨è¯ï¼ˆä¾‹å¦‚ï¼Œå½“æˆ‘ä»¬æŠŠæŸç‰©æ˜¾ç¤ºåœ¨å±å¹•ä¸Šæ—¶ï¼‰ï¼ŸåŒæ ·ï¼Œå¯¹äºå›¾åƒç­‰ä¹Ÿæ˜¯å¦‚æ­¤ã€‚äº‹å®ä¸Šï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼Œè¡¨æ ¼æ˜¯ä¾‹å¤–ï¼Œæè¿°æ˜¯å†…ç½®äºæ•°æ®ä¸­è€Œä¸æ˜¯ç”±ç¨‹åºæä¾›çš„ï¼
- en: This genericity is both a virtue and a problem. Because, like other anonymous
    data, a list does not provide any interpretation of its use, if we are not careful
    we can accidentally mis-interpret the values. On the other hand, it means we can
    use the same datum in several different contexts, and one operation can be used
    in many settings.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§é€šç”¨æ€§æ—¢æ˜¯ä¼˜ç‚¹ä¹Ÿæ˜¯é—®é¢˜ã€‚å› ä¸ºï¼Œåƒå…¶ä»–åŒ¿åæ•°æ®ä¸€æ ·ï¼Œåˆ—è¡¨ä¸æä¾›å¯¹å…¶ä½¿ç”¨çš„ä»»ä½•è§£é‡Šï¼Œå¦‚æœæˆ‘ä»¬ä¸å°å¿ƒï¼Œæˆ‘ä»¬å¯èƒ½ä¼šæ„å¤–åœ°è¯¯è§£å€¼ã€‚å¦ä¸€æ–¹é¢ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥åœ¨å‡ ä¸ªä¸åŒçš„ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨ç›¸åŒçš„æ•°æ®ï¼Œä¸€ä¸ªæ“ä½œå¯ä»¥åœ¨è®¸å¤šè®¾ç½®ä¸­ä½¿ç”¨ã€‚
- en: Indeed, if we look at the list of questions we asked earlier, we see that there
    are several common operationsâ€”<wbr>maximum, minimum, average, and so onâ€”<wbr>that
    can be asked of a list of values without regard for what the list represents (heights,
    ages, playcounts). In fact, some are specific to numbers (like average) while
    some (like maximum) can be asked of any type on which we can perform a comparison
    (like strings).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: äº‹å®ä¸Šï¼Œå¦‚æœæˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬ä¹‹å‰æå‡ºçš„é—®é¢˜åˆ—è¡¨ï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ°æœ‰å‡ ä¸ªå¸¸è§çš„æ“ä½œâ€”â€”<wbr>æœ€å¤§å€¼ã€æœ€å°å€¼ã€å¹³å‡å€¼ç­‰ç­‰â€”â€”å¯ä»¥åœ¨ä¸è€ƒè™‘åˆ—è¡¨ä»£è¡¨ä»€ä¹ˆï¼ˆèº«é«˜ã€å¹´é¾„ã€æ’­æ”¾æ¬¡æ•°ï¼‰çš„æƒ…å†µä¸‹å¯¹å€¼åˆ—è¡¨è¿›è¡Œæé—®ã€‚å®é™…ä¸Šï¼Œæœ‰äº›æ˜¯ç‰¹å®šäºæ•°å­—çš„ï¼ˆå¦‚å¹³å‡å€¼ï¼‰ï¼Œè€Œæœ‰äº›ï¼ˆå¦‚æœ€å¤§å€¼ï¼‰å¯ä»¥é’ˆå¯¹æˆ‘ä»¬å¯ä»¥æ‰§è¡Œæ¯”è¾ƒçš„ä»»ä½•ç±»å‹è¿›è¡Œæé—®ï¼ˆå¦‚å­—ç¬¦ä¸²ï¼‰ã€‚
- en: 5.1.3.2Â Creating Literal Lists[ğŸ”—](#(part._.Creating_.Literal_.Lists) "Link to
    here")
  id: totrans-285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1.3.2 åˆ›å»ºå­—é¢é‡åˆ—è¡¨[ğŸ”—](#(part._.Creating_.Literal_.Lists) "é“¾æ¥è‡³æ­¤")
- en: 'We have already seen how we can create lists from a table, using `get-column`.
    As you might expect, however, we can also create lists directly:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»çœ‹åˆ°å¦‚ä½•ä½¿ç”¨`get-column`ä»è¡¨æ ¼ä¸­åˆ›å»ºåˆ—è¡¨ã€‚ç„¶è€Œï¼Œæ­£å¦‚ä½ å¯èƒ½é¢„æ–™çš„é‚£æ ·ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ç›´æ¥åˆ›å»ºåˆ—è¡¨ï¼š
- en: '[PRE34]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Of course, lists are values so we can name them using variablesâ€”<wbr>
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œåˆ—è¡¨æ˜¯å€¼ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨å˜é‡æ¥å‘½åå®ƒä»¬â€”â€”<wbr>
- en: '[PRE35]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: â€”<wbr>pass them to functions (as we will soon see), and so on.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: â€”â€”<wbr>å°†å®ƒä»¬ä¼ é€’ç»™å‡½æ•°ï¼ˆæ­£å¦‚æˆ‘ä»¬å¾ˆå¿«å°†çœ‹åˆ°çš„ï¼‰ï¼Œç­‰ç­‰ã€‚
- en: Do Now!
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Based on these examples, can you figure out how to create an empty list?
  id: totrans-293
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ ¹æ®è¿™äº›ç¤ºä¾‹ï¼Œä½ èƒ½æƒ³å‡ºå¦‚ä½•åˆ›å»ºä¸€ä¸ªç©ºåˆ—è¡¨å—ï¼Ÿ
- en: 'As you might have guessed, itâ€™s `[list: ]` (the space isnâ€™t necessary, but
    itâ€™s a useful visual reminder of the void).'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ­£å¦‚ä½ å¯èƒ½çŒœåˆ°çš„ï¼Œå®ƒæ˜¯`[list: ]`ï¼ˆç©ºæ ¼ä¸æ˜¯å¿…éœ€çš„ï¼Œä½†å®ƒæ˜¯ä¸€ä¸ªæœ‰ç”¨çš„è§†è§‰æé†’ï¼Œè¡¨ç¤ºç©ºæ— ï¼‰ã€‚'
- en: 5.1.4Â Operating on Lists[ğŸ”—](#(part._.Operating_on_.Lists) "Link to here")
  id: totrans-295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.4 åœ¨åˆ—è¡¨ä¸Šæ“ä½œ[ğŸ”—](#(part._.Operating_on_.Lists) "é“¾æ¥è‡³æ­¤")
- en: 5.1.4.1Â Built-In Operations on Lists of Numbers[ğŸ”—](#(part._.Built-.In_.Operations_on_.Lists_of_.Numbers)
    "Link to here")
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1.4.1 æ•°å­—åˆ—è¡¨çš„å†…ç½®æ“ä½œ[ğŸ”—](#(part._.Built-.In_.Operations_on_.Lists_of_.Numbers) "é“¾æ¥è‡³æ­¤")
- en: 'Pyret handily provides a useful set of operations we can already perform on
    lists. The [lists documentation](https://www.pyret.org/docs/latest/lists.html)
    describes these operations. As you might have guessed, we can already compute
    most of the answers weâ€™ve asked for at the start of the chapter. First we need
    to include some libraries that contain useful functions:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Pyretæ–¹ä¾¿åœ°æä¾›äº†ä¸€ç»„æˆ‘ä»¬å¯ä»¥ç›´æ¥åœ¨åˆ—è¡¨ä¸Šæ‰§è¡Œçš„è¿ç®—ã€‚[åˆ—è¡¨æ–‡æ¡£](https://www.pyret.org/docs/latest/lists.html)æè¿°äº†è¿™äº›è¿ç®—ã€‚æ­£å¦‚ä½ å¯èƒ½å·²ç»çŒœåˆ°çš„ï¼Œæˆ‘ä»¬å·²ç»åœ¨ç« èŠ‚å¼€å¤´è®¡ç®—äº†å¤§éƒ¨åˆ†æˆ‘ä»¬è¦æ±‚çš„ç»“æœã€‚é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦åŒ…å«ä¸€äº›åŒ…å«æœ‰ç”¨å‡½æ•°çš„åº“ï¼š
- en: '[PRE36]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can then access several useful functions:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥è®¿é—®å‡ ä¸ªæœ‰ç”¨çš„å‡½æ•°ï¼š
- en: '[PRE37]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `M.` notation means "the function inside the library `M`. The `import` statement
    in the above code gave the name `M` to the `math` library.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`M.`è¡¨ç¤ºâ€œåº“`M`ä¸­çš„å‡½æ•°â€ã€‚ä¸Šè¿°ä»£ç ä¸­çš„`import`è¯­å¥å°†`math`åº“çš„åç§°æŒ‡å®šä¸º`M`ã€‚'
- en: 5.1.4.2Â Built-In Operations on Lists in General[ğŸ”—](#(part._.Built-.In_.Operations_on_.Lists_in_.General)
    "Link to here")
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1.4.2 åˆ—è¡¨é€šç”¨å†…ç½®æ“ä½œ[ğŸ”—](#(part._.Built-.In_.Operations_on_.Lists_in_.General) "é“¾æ¥è‡³æ­¤")
- en: 'Some of the useful computations in our list at the start of the chapter involved
    the `discount` column, which contains strings rather than numbers. Specifically,
    letâ€™s consider the following question:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ç« å¼€å¤´åˆ—è¡¨ä¸­çš„ä¸€äº›æœ‰ç”¨è®¡ç®—æ¶‰åŠåˆ°`discount`åˆ—ï¼Œè¯¥åˆ—åŒ…å«å­—ç¬¦ä¸²è€Œä¸æ˜¯æ•°å­—ã€‚å…·ä½“æ¥è¯´ï¼Œè®©æˆ‘ä»¬è€ƒè™‘ä»¥ä¸‹é—®é¢˜ï¼š
- en: Compute the collection of unique discount codes that were used (many might have
    been available).
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è®¡ç®—ä½¿ç”¨è¿‡çš„å”¯ä¸€æŠ˜æ‰£ä»£ç é›†åˆï¼ˆå¯èƒ½æœ‰å¾ˆå¤šå¯ç”¨ï¼‰ã€‚
- en: 'None of the table functions handle a question like this. However, this is a
    common kind of question to ask about a collection of values (How many unique artists
    are in your playlist? How many unique faculty are teaching courses?). As such,
    Pyret (as most languages) provides a way to identify the unique elements of a
    list. Hereâ€™s how we get the list of all discount codes that were used in our table:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: æ²¡æœ‰è¡¨æ ¼å‡½æ•°å¯ä»¥å¤„ç†è¿™æ ·çš„é—®é¢˜ã€‚ç„¶è€Œï¼Œè¿™æ˜¯ä¸€ä¸ªå…³äºå€¼é›†åˆçš„å¸¸è§é—®é¢˜ï¼ˆä½ çš„æ’­æ”¾åˆ—è¡¨ä¸­æœ‰å¤šå°‘ç‹¬ç‰¹çš„è‰ºæœ¯å®¶ï¼Ÿæœ‰å¤šå°‘ç‹¬ç‰¹çš„æ•™å¸ˆæ­£åœ¨æ•™æˆè¯¾ç¨‹ï¼Ÿï¼‰ã€‚å› æ­¤ï¼ŒPyretï¼ˆä»¥åŠå¤§å¤šæ•°è¯­è¨€ï¼‰æä¾›äº†ä¸€ç§è¯†åˆ«åˆ—è¡¨ä¸­å”¯ä¸€å…ƒç´ çš„æ–¹æ³•ã€‚ä»¥ä¸‹æ˜¯æˆ‘ä»¬å¦‚ä½•è·å–æˆ‘ä»¬è¡¨æ ¼ä¸­ä½¿ç”¨çš„æ‰€æœ‰æŠ˜æ‰£ä»£ç çš„åˆ—è¡¨ï¼š
- en: '[PRE38]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `distinct` function produces a list of the unique values from the input
    list: every value in the input list appears exactly once in the output list. For
    the above code, Pyret produces:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`distinct`å‡½æ•°ä»è¾“å…¥åˆ—è¡¨ç”Ÿæˆä¸€ä¸ªå”¯ä¸€å€¼çš„åˆ—è¡¨ï¼šè¾“å…¥åˆ—è¡¨ä¸­çš„æ¯ä¸ªå€¼åœ¨è¾“å‡ºåˆ—è¡¨ä¸­æ°å¥½å‡ºç°ä¸€æ¬¡ã€‚å¯¹äºä¸Šé¢çš„ä»£ç ï¼ŒPyretç”Ÿæˆï¼š'
- en: '[PRE39]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: What if we wanted to exclude `"none"` from that list? After all, `"none"` isnâ€™t
    an actual discount code, but rather one that we introduced while cleaning up the
    table. Is there a way to easily remove `"none"` from the list?
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æƒ³è¦ä»åˆ—è¡¨ä¸­æ’é™¤`"none"`ï¼Œæ€ä¹ˆåŠï¼Ÿæ¯•ç«Ÿï¼Œ`"none"`ä¸æ˜¯ä¸€ä¸ªå®é™…çš„æŠ˜æ‰£ä»£ç ï¼Œè€Œæ˜¯ä¸€ä¸ªæˆ‘ä»¬åœ¨æ¸…ç†è¡¨æ ¼æ—¶å¼•å…¥çš„ä»£ç ã€‚æœ‰æ²¡æœ‰ä¸€ç§ç®€å•çš„æ–¹æ³•å¯ä»¥ä»åˆ—è¡¨ä¸­ç§»é™¤`"none"`ï¼Ÿ
- en: 'There are two ways we could do it. In the Pyret lists documentation, we find
    a function called `remove`, which removes a specific element from a list:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥æœ‰ä¸¤ç§æ–¹æ³•æ¥åšè¿™ä»¶äº‹ã€‚åœ¨Pyretåˆ—è¡¨æ–‡æ¡£ä¸­ï¼Œæˆ‘ä»¬æ‰¾åˆ°ä¸€ä¸ªåä¸º`remove`çš„å‡½æ•°ï¼Œè¯¥å‡½æ•°å¯ä»¥ä»åˆ—è¡¨ä¸­ç§»é™¤ç‰¹å®šçš„å…ƒç´ ï¼š
- en: '|'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE40]'
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '&#124;'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE41]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '|'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'But this operation should also sound familiar: with tables, we used `filter-with`
    to keep only those elements that meet a specific criterion. The filtering idea
    is so common that Pyret (and most other languages) provide a similar operation
    on lists. In the case of the discount codes, we could also have written:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†è¿™ä¸ªæ“ä½œä¹Ÿåº”è¯¥å¬èµ·æ¥å¾ˆç†Ÿæ‚‰ï¼šåœ¨è¡¨æ ¼ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨`filter-with`æ¥ä¿ç•™æ»¡è¶³ç‰¹å®šæ ‡å‡†çš„å…ƒç´ ã€‚è¿‡æ»¤çš„æƒ³æ³•å¦‚æ­¤å¸¸è§ï¼Œä»¥è‡³äºPyretï¼ˆä»¥åŠå¤§å¤šæ•°å…¶ä»–è¯­è¨€ï¼‰åœ¨åˆ—è¡¨ä¸Šæä¾›äº†ç±»ä¼¼çš„æ“ä½œã€‚åœ¨æŠ˜æ‰£ä»£ç çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥è¿™æ ·å†™ï¼š
- en: '[PRE42]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The difference between these two approaches is that `filter` is more flexible:
    we can check any characteristic of a list element using `filter`, but `remove`
    only checks whether the entire element is equal to the value that we provide.
    If instead of removing the specific string `"none"`, we had wanted to remove all
    strings that were in all-lowercase, we would have needed to use `filter`.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸¤ç§æ–¹æ³•çš„åŒºåˆ«åœ¨äº`filter`æ›´åŠ çµæ´»ï¼šæˆ‘ä»¬å¯ä»¥ä½¿ç”¨`filter`æ£€æŸ¥åˆ—è¡¨å…ƒç´ çš„ä»»ä½•ç‰¹å¾ï¼Œä½†`remove`åªæ£€æŸ¥æ•´ä¸ªå…ƒç´ æ˜¯å¦ç­‰äºæˆ‘ä»¬æä¾›çš„å€¼ã€‚å¦‚æœæˆ‘ä»¬ä¸æ˜¯è¦ç§»é™¤ç‰¹å®šçš„å­—ç¬¦ä¸²`"none"`ï¼Œè€Œæ˜¯è¦ç§»é™¤æ‰€æœ‰å…¨å°å†™çš„å­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬å°±éœ€è¦ä½¿ç”¨`filter`ã€‚
- en: Exercise
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write a function that takes a list of words and removes those words in which
    all letters are in lowercase. (Hint: combine `string-to-lower` and `==`).'
  id: totrans-324
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ªå•è¯åˆ—è¡¨ï¼Œå¹¶ç§»é™¤æ‰€æœ‰å­—æ¯éƒ½ä¸ºå°å†™çš„å•è¯ã€‚ï¼ˆæç¤ºï¼šç»“åˆ`string-to-lower`å’Œ`==`ï¼‰ã€‚
- en: 5.1.4.3Â An Aside on Naming Conventions[ğŸ”—](#(part._.An_.Aside_on_.Naming_.Conventions)
    "Link to here")
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1.4.3 å…³äºå‘½åçº¦å®šçš„è¡¥å……[ğŸ”—](#(part._.An_.Aside_on_.Naming_.Conventions) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Our use of the plural `codes` for the list of values in the column named `discount`
    (singular) is deliberate. A list contains multiple values, so a plural is appropriate.
    In a table, in contrast, we think of a column header as naming a single value
    that appears in a specific row. Often, we speak of looking up a value in a specific
    row and column: the singular name for the column supports thinking about lookup
    in an individual row.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨åä¸º`discount`ï¼ˆå•æ•°ï¼‰çš„åˆ—çš„å€¼åˆ—è¡¨ä¸­ä½¿ç”¨å¤æ•°`codes`æ˜¯æœ‰æ„ä¸ºä¹‹ã€‚åˆ—è¡¨åŒ…å«å¤šä¸ªå€¼ï¼Œæ‰€ä»¥å¤æ•°æ˜¯åˆé€‚çš„ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œåœ¨è¡¨æ ¼ä¸­ï¼Œæˆ‘ä»¬è®¤ä¸ºåˆ—æ ‡é¢˜å‘½åçš„æ˜¯ç‰¹å®šè¡Œä¸­å‡ºç°çš„å•ä¸ªå€¼ã€‚æˆ‘ä»¬ç»å¸¸è°ˆè®ºåœ¨ç‰¹å®šè¡Œå’Œåˆ—ä¸­æŸ¥æ‰¾å€¼ï¼šåˆ—çš„å•æ•°åç§°æ”¯æŒåœ¨å•ä¸ªè¡Œä¸­è¿›è¡ŒæŸ¥æ‰¾çš„æ€è€ƒã€‚
- en: 5.1.4.4Â Getting Elements By Position[ğŸ”—](#(part._.Getting_.Elements_.By_.Position)
    "Link to here")
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1.4.4 é€šè¿‡ä½ç½®è·å–å…ƒç´ [ğŸ”—](#(part._.Getting_.Elements_.By_.Position) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Letâ€™s look at a new analysis question: the events company recently ran an advertising
    campaign on `web.com`, and they are curious whether it paid off. To do this, they
    need to determine how many sales were made to people with `web.com` email addresses.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹çœ‹ä¸€ä¸ªæ–°çš„åˆ†æé—®é¢˜ï¼šäº‹ä»¶å…¬å¸æœ€è¿‘åœ¨`web.com`ä¸Šè¿›è¡Œäº†å¹¿å‘Šå®£ä¼ æ´»åŠ¨ï¼Œä»–ä»¬æƒ³çŸ¥é“è¿™æœ‰æ²¡æœ‰æ•ˆæœã€‚ä¸ºäº†åšåˆ°è¿™ä¸€ç‚¹ï¼Œä»–ä»¬éœ€è¦ç¡®å®šæœ‰å¤šå°‘é”€å”®æ˜¯é€šè¿‡å…·æœ‰`web.com`ç”µå­é‚®ä»¶åœ°å€çš„äººå®Œæˆçš„ã€‚
- en: Do Now!
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Propose a task plan ([Task Plans](processing-tables.html#%28part._task-plans%29))
    for this computation.
  id: totrans-331
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æå‡ºä¸€ä¸ªä»»åŠ¡è®¡åˆ’ï¼ˆ[ä»»åŠ¡è®¡åˆ’](processing-tables.html#%28part._task-plans%29)ï¼‰ç”¨äºè¿™ä¸ªè®¡ç®—ã€‚
- en: 'Hereâ€™s a proposed plan, annotated with how we might implement each part:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€ä¸ªæå‡ºçš„è®¡åˆ’ï¼Œå¹¶æ ‡æ³¨äº†å¦‚ä½•å®ç°æ¯ä¸ªéƒ¨åˆ†ï¼š
- en: Get the list of email addresses (use `get-column`)
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è·å–ç”µå­é‚®ä»¶åœ°å€åˆ—è¡¨ï¼ˆä½¿ç”¨`get-column`ï¼‰
- en: Extract those that came from `web.com` (use `L.filter`)
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æå–æ¥è‡ª`web.com`çš„å…ƒç´ ï¼ˆä½¿ç”¨`L.filter`ï¼‰
- en: Count how many email addresses remain (using `L.length`, which we hadnâ€™t discussed
    yet, but it is in the documentation)
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è®¡ç®—å‰©ä½™çš„ç”µå­é‚®ä»¶åœ°å€æ•°é‡ï¼ˆä½¿ç”¨`L.length`ï¼Œæˆ‘ä»¬å°šæœªè®¨è®ºï¼Œä½†åœ¨æ–‡æ¡£ä¸­æœ‰æ‰€æåŠï¼‰
- en: (As a reminder, unless you immediately see how to solve a problem, write out
    a task plan and annotate the parts you know how to do. It helps break down a programming
    problem into more manageable parts.)
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆä½œä¸ºæé†’ï¼Œé™¤éä½ ç«‹å³çœ‹åˆ°è§£å†³é—®é¢˜çš„æ–¹æ³•ï¼Œå¦åˆ™è¯·å†™å‡ºä»»åŠ¡è®¡åˆ’å¹¶æ ‡æ³¨ä½ å·²çŸ¥å¦‚ä½•åšçš„éƒ¨åˆ†ã€‚è¿™æœ‰åŠ©äºå°†ç¼–ç¨‹é—®é¢˜åˆ†è§£æˆæ›´æ˜“äºç®¡ç†çš„éƒ¨åˆ†ã€‚ï¼‰
- en: 'Letâ€™s discuss the second task: identifying messages from `web.com`. We know
    that email addresses are strings, so if we could determine whether an email string
    ends in `@web.com`, weâ€™d be set. You could consider doing this by looking at the
    last 7 characters of the email string. Another option is to use a string operation
    that we havenâ€™t yet seen called `string-split-all`, which splits a string into
    a list of substrings around a given character. For example:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è®¨è®ºç¬¬äºŒä¸ªä»»åŠ¡ï¼šè¯†åˆ«æ¥è‡ª`web.com`çš„æ¶ˆæ¯ã€‚æˆ‘ä»¬çŸ¥é“ç”µå­é‚®ä»¶åœ°å€æ˜¯å­—ç¬¦ä¸²ï¼Œæ‰€ä»¥å¦‚æœæˆ‘ä»¬èƒ½ç¡®å®šç”µå­é‚®ä»¶å­—ç¬¦ä¸²ä»¥`@web.com`ç»“å°¾ï¼Œæˆ‘ä»¬å°±æˆåŠŸäº†ã€‚ä½ å¯ä»¥è€ƒè™‘é€šè¿‡æŸ¥çœ‹ç”µå­é‚®ä»¶å­—ç¬¦ä¸²çš„æœ€å7ä¸ªå­—ç¬¦æ¥åšè¿™ä»¶äº‹ã€‚å¦ä¸€ç§é€‰æ‹©æ˜¯ä½¿ç”¨æˆ‘ä»¬å°šæœªçœ‹åˆ°çš„å­—ç¬¦ä¸²æ“ä½œ`string-split-all`ï¼Œå®ƒå°†å­—ç¬¦ä¸²åˆ†å‰²æˆä»¥ç»™å®šå­—ç¬¦ä¸ºåˆ†éš”çš„å­å­—ç¬¦ä¸²åˆ—è¡¨ã€‚ä¾‹å¦‚ï¼š
- en: '|'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE43]'
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '&#124;'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE44]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '|'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE45]'
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '&#124;'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE46]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '|'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: This seems pretty useful. If we split each email string around the `@` sign,
    then we can check whether the second string in the list is `web.com` (since email
    addresses should have only one `@` sign). But how would we get the second element
    out of the list produced by `string-split-all`? Here we dig into the list, as
    we did to extract rows from tables, this time using the `get` operation.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™çœ‹èµ·æ¥éå¸¸æœ‰ç”¨ã€‚å¦‚æœæˆ‘ä»¬å›´ç»•`@`ç¬¦å·åˆ†å‰²æ¯ä¸ªç”µå­é‚®ä»¶å­—ç¬¦ä¸²ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥æ£€æŸ¥åˆ—è¡¨ä¸­çš„ç¬¬äºŒä¸ªå­—ç¬¦ä¸²æ˜¯å¦ä¸º`web.com`ï¼ˆå› ä¸ºç”µå­é‚®ä»¶åœ°å€åº”è¯¥åªæœ‰ä¸€ä¸ª`@`ç¬¦å·ï¼‰ã€‚ä½†æˆ‘ä»¬æ˜¯å¦‚ä½•ä»`string-split-all`äº§ç”Ÿçš„åˆ—è¡¨ä¸­è·å–ç¬¬äºŒä¸ªå…ƒç´ çš„ï¼Ÿåœ¨è¿™é‡Œï¼Œæˆ‘ä»¬æ·±å…¥åˆ—è¡¨ï¼Œå°±åƒæˆ‘ä»¬æå–è¡¨æ ¼ä¸­çš„è¡Œä¸€æ ·ï¼Œè¿™æ¬¡ä½¿ç”¨`get`æ“ä½œã€‚
- en: '|'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE47]'
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '&#124;'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE48]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '|'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Do Now!
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do we use `1` as the input to `get` if we want the second item in the list?
  id: totrans-365
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆæˆ‘ä»¬è¦å°†`1`ä½œä¸º`get`çš„è¾“å…¥ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è·å–åˆ—è¡¨ä¸­çš„ç¬¬äºŒä¸ªé¡¹ç›®ï¼Ÿ
- en: 'Hereâ€™s the complete program for doing this check:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯è¿›è¡Œæ­¤æ£€æŸ¥çš„å®Œæ•´ç¨‹åºï¼š
- en: '[PRE49]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Exercise
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if there is a malformed email address string that doesnâ€™t contain
    the `@` string? What would happen? What could you do about that?
  id: totrans-370
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœæœ‰ä¸€ä¸ªæ²¡æœ‰åŒ…å«`@`å­—ç¬¦ä¸²çš„æ ¼å¼ä¸æ­£ç¡®çš„ç”µå­é‚®ä»¶åœ°å€å­—ç¬¦ä¸²ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿä½ èƒ½åšäº›ä»€ä¹ˆï¼Ÿ
- en: 5.1.4.5Â Transforming Lists[ğŸ”—](#(part._.Transforming_.Lists) "Link to here")
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1.4.5 åˆ—è¡¨è½¬æ¢[ğŸ”—](#(part._.Transforming_.Lists) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Imagine now that we had a list of email addresses, but instead just wanted a
    list of usernames. This doesnâ€™t make sense for our event data, but it does make
    sense in other contexts (such as connecting messages to folders organized by studentsâ€™
    usernames).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬ç°åœ¨æœ‰ä¸€ä¸ªç”µå­é‚®ä»¶åœ°å€åˆ—è¡¨ï¼Œä½†æˆ‘ä»¬åªæƒ³æœ‰ä¸€ä¸ªç”¨æˆ·ååˆ—è¡¨ã€‚è¿™åœ¨æˆ‘ä»¬çš„äº‹ä»¶æ•°æ®ä¸­å¹¶ä¸åˆç†ï¼Œä½†åœ¨å…¶ä»–ä¸Šä¸‹æ–‡ä¸­æ˜¯æœ‰æ„ä¹‰çš„ï¼ˆä¾‹å¦‚ï¼Œå°†æ¶ˆæ¯è¿æ¥åˆ°æŒ‰å­¦ç”Ÿç”¨æˆ·åç»„ç»‡çš„æ–‡ä»¶å¤¹ï¼‰ã€‚
- en: 'Specifcally, we want to start with a list of addresses such as:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬æƒ³è¦ä»ä¸€ä¸ªåœ°å€åˆ—è¡¨å¼€å§‹ï¼Œä¾‹å¦‚ï¼š
- en: '[PRE50]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: and convert it to
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¶å°†å…¶è½¬æ¢ä¸º
- en: '[PRE51]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Do Now!
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Consider the list functions we have seen so far (`distinct`, `filter`, `length`)
    â€“ are any of them useful for this task? Can you articulate why?
  id: totrans-379
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è€ƒè™‘æˆ‘ä»¬è¿„ä»Šä¸ºæ­¢çœ‹åˆ°çš„åˆ—è¡¨å‡½æ•°ï¼ˆ`distinct`ã€`filter`ã€`length`ï¼‰â€”â€”å®ƒä»¬ä¸­çš„ä»»ä½•ä¸€ä¸ªå¯¹è¿™ä¸ªä»»åŠ¡æœ‰ç”¨å—ï¼Ÿä½ èƒ½é˜è¿°ä¸ºä»€ä¹ˆå—ï¼Ÿ
- en: One way to articulate a precise answer to this is think in terms of the inputs
    and outputs of the existing functions. Both `filter` and `distinct` return a list
    of elements from the input list, not transformed elements. `length` returns a
    number, not a list. So none of these are appropriate.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ç§æ˜ç¡®å›ç­”è¿™ä¸ªé—®é¢˜çš„æ–¹æ³•æ˜¯ä»ç°æœ‰å‡½æ•°çš„è¾“å…¥å’Œè¾“å‡ºè§’åº¦æ€è€ƒã€‚`filter`å’Œ`distinct`éƒ½è¿”å›è¾“å…¥åˆ—è¡¨ä¸­çš„å…ƒç´ åˆ—è¡¨ï¼Œè€Œä¸æ˜¯è½¬æ¢åçš„å…ƒç´ ã€‚`length`è¿”å›ä¸€ä¸ªæ•°å­—ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªåˆ—è¡¨ã€‚æ‰€ä»¥è¿™äº›éƒ½ä¸åˆé€‚ã€‚
- en: 'This idea of transforming elements is similar to the `transform-column` operation
    that we previously saw on tables. The corresponding operation on lists is called
    `map`. Hereâ€™s an example:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§è½¬æ¢å…ƒç´ çš„æƒ³æ³•ä¸æˆ‘ä»¬åœ¨è¡¨æ ¼ä¸­ä¹‹å‰çœ‹åˆ°çš„`transform-column`æ“ä½œç±»ä¼¼ã€‚åˆ—è¡¨ä¸Šçš„ç›¸åº”æ“ä½œç§°ä¸º`map`ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼š
- en: '[PRE52]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '5.1.4.6Â Recap: Summary of List Operations[ğŸ”—](#(part._lists-recap) "Link to
    here")'
  id: totrans-383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1.4.6 å›é¡¾ï¼šåˆ—è¡¨æ“ä½œæ€»ç»“[ğŸ”—](#(part._lists-recap) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'At this point, we have seen several useful built-in functions for working with
    lists:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œæˆ‘ä»¬å·²ç»çœ‹åˆ°äº†å‡ ä¸ªç”¨äºå¤„ç†åˆ—è¡¨çš„æœ‰ç”¨å†…ç½®å‡½æ•°ï¼š
- en: '`filter :: (A -> Boolean), List<A> -> List<A>`, which produces a list of elements
    from the input list on which the given function returns `true`.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter :: (A -> Boolean), List<A> -> List<A>`ï¼Œå®ƒäº§ç”Ÿä¸€ä¸ªåˆ—è¡¨ï¼Œå…¶ä¸­åŒ…å«è¾“å…¥åˆ—è¡¨ä¸­ç»™å®šå‡½æ•°è¿”å›`true`çš„å…ƒç´ ã€‚'
- en: '`map :: (A -> B), List<A> -> List<B>`, which produces a list of the results
    of calling the given function on each element of the input list.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map :: (A -> B), List<A> -> List<B>`ï¼Œå®ƒäº§ç”Ÿä¸€ä¸ªåˆ—è¡¨ï¼Œå…¶ä¸­åŒ…å«å¯¹è¾“å…¥åˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ è°ƒç”¨ç»™å®šå‡½æ•°çš„ç»“æœã€‚'
- en: '`distinct :: List<A> -> List<A>`, which produces a list of the unique elements
    that appear in the input list.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distinct :: List<A> -> List<A>`ï¼Œå®ƒäº§ç”Ÿä¸€ä¸ªåŒ…å«è¾“å…¥åˆ—è¡¨ä¸­å‡ºç°çš„å”¯ä¸€å…ƒç´ çš„åˆ—è¡¨ã€‚'
- en: '`length :: List<A> -> Number`, which produces the number of elements in the
    input list.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length :: List<A> -> Number`ï¼Œå®ƒäº§ç”Ÿè¾“å…¥åˆ—è¡¨ä¸­çš„å…ƒç´ æ•°é‡ã€‚'
- en: Here, a type such as `List<A>` says that we have a list whose elements are of
    some (unspecified) type which weâ€™ll call `A`. A type variable such as this is
    useful when we want to show relationships between two types in a function contract.
    Here, the type variable `A` captures that the type of elements is the same in
    the input and output to `filter`. In `map`, however, the type of element in the
    output list could differ from that in the input list.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œç±»å‹å¦‚`List<A>`è¡¨ç¤ºæˆ‘ä»¬æœ‰ä¸€ä¸ªå…ƒç´ ç±»å‹ä¸ºæŸç§ï¼ˆæœªæŒ‡å®šçš„ï¼‰ç±»å‹çš„åˆ—è¡¨ï¼Œæˆ‘ä»¬å°†ç§°ä¹‹ä¸º`A`ã€‚è¿™ç§ç±»å‹å˜é‡åœ¨å‡½æ•°å¥‘çº¦ä¸­æ˜¾ç¤ºä¸¤ä¸ªç±»å‹ä¹‹é—´çš„å…³ç³»æ—¶å¾ˆæœ‰ç”¨ã€‚åœ¨è¿™é‡Œï¼Œç±»å‹å˜é‡`A`æ•è·äº†`filter`çš„è¾“å…¥å’Œè¾“å‡ºç±»å‹ç›¸åŒçš„äº‹å®ã€‚ç„¶è€Œï¼Œåœ¨`map`ä¸­ï¼Œè¾“å‡ºåˆ—è¡¨ä¸­çš„å…ƒç´ ç±»å‹å¯èƒ½ä¸è¾“å…¥åˆ—è¡¨ä¸­çš„ä¸åŒã€‚
- en: 'One additional built-in function that is quite useful in practice is:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: å®è·µä¸­éå¸¸æœ‰ç”¨çš„ä¸€é¡¹é™„åŠ å†…ç½®å‡½æ•°æ˜¯ï¼š
- en: '`member :: List<A>, Any -> Boolean`, which determines whether the given element
    is in the list. We use the type `Any` when there are no constraints on the type
    of value provided to a function.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`member :: List<A>, Any -> Boolean`ï¼Œè¯¥å‡½æ•°ç”¨äºç¡®å®šç»™å®šå…ƒç´ æ˜¯å¦åœ¨åˆ—è¡¨ä¸­ã€‚å½“æä¾›ç»™å‡½æ•°çš„å€¼çš„ç±»å‹æ²¡æœ‰çº¦æŸæ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨ç±»å‹`Any`ã€‚'
- en: Many useful computations can be performed by combining these operations.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: å¯ä»¥é€šè¿‡ç»„åˆè¿™äº›æ“ä½œæ‰§è¡Œè®¸å¤šæœ‰ç”¨çš„è®¡ç®—ã€‚
- en: Exercise
  id: totrans-393
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-394
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Assume you used a list of strings to represent the ingredients in a recipe.
    Here are three examples:'
  id: totrans-395
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å‡è®¾ä½ ä½¿ç”¨å­—ç¬¦ä¸²åˆ—è¡¨æ¥è¡¨ç¤ºé£Ÿè°±ä¸­çš„é…æ–™ã€‚ä»¥ä¸‹æœ‰ä¸‰ä¸ªç¤ºä¾‹ï¼š
- en: ''
  id: totrans-396
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-397
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ''
  id: totrans-398
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write the following functions on ingredient lists:'
  id: totrans-399
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨é…æ–™åˆ—è¡¨ä¸Šç¼–å†™ä»¥ä¸‹å‡½æ•°ï¼š
- en: ''
  id: totrans-400
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`recipes-uses`, which takes an ingredient list and an ingredient and determines
    whether the recipe uses the ingredient.'
  id: totrans-401
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recipes-uses`ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ªé…æ–™åˆ—è¡¨å’Œä¸€ä¸ªé…æ–™ï¼Œå¹¶ç¡®å®šé£Ÿè°±æ˜¯å¦ä½¿ç”¨äº†è¯¥é…æ–™ã€‚'
- en: ''
  id: totrans-402
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-403
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`make-vegetarian`, which takes an ingredient list and replaces all meat ingredients
    with `"tofu"`. Meat ingredients are `"pork"`, `"chicken"`, and `"beef"`.'
  id: totrans-404
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make-vegetarian`ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ªé…æ–™åˆ—è¡¨ï¼Œå¹¶å°†æ‰€æœ‰è‚‰ç±»é…æ–™æ›¿æ¢ä¸º`"tofu"`ã€‚è‚‰ç±»é…æ–™åŒ…æ‹¬`"pork"`ã€`"chicken"`å’Œ`"beef"`ã€‚'
- en: ''
  id: totrans-405
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-406
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`protein-veg-count`, which takes an ingredient list and determines how many
    ingredients are in the list that arenâ€™t `"rice"` or `"noodles"`.'
  id: totrans-407
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protein-veg-count`ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ªé…æ–™åˆ—è¡¨ï¼Œå¹¶ç¡®å®šåˆ—è¡¨ä¸­æœ‰å¤šå°‘é…æ–™ä¸æ˜¯`"rice"`æˆ–`"noodles"`ã€‚'
- en: Exercise
  id: totrans-408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-409
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'More challenging: Write a function that takes an ingredient and a list of ingredient
    lists and produces a list of all the lists that contain the given ingredient.'
  id: totrans-410
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ›´å…·æŒ‘æˆ˜æ€§ï¼šç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ªé…æ–™å’Œä¸€ä¸ªé…æ–™åˆ—è¡¨ï¼Œå¹¶ç”ŸæˆåŒ…å«ç»™å®šé…æ–™çš„æ‰€æœ‰åˆ—è¡¨ã€‚
- en: ''
  id: totrans-411
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Hint: write examples first to make sense of the problem as needed.'
  id: totrans-412
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æç¤ºï¼šé¦–å…ˆç¼–å†™ç¤ºä¾‹ï¼Œä»¥ä¾¿åœ¨éœ€è¦æ—¶ç†è§£é—®é¢˜ã€‚
- en: Exercise
  id: totrans-413
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-414
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Even more challenging: Try to write a function that takes two ingredient lists
    and returns all of the ingredients that are common to both lists. What issue(s)
    or limitations do you run into?'
  id: totrans-415
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ›´å…·æŒ‘æˆ˜æ€§ï¼šå°è¯•ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸¤ä¸ªé…æ–™åˆ—è¡¨å¹¶è¿”å›ä¸¤ä¸ªåˆ—è¡¨å…±æœ‰çš„æ‰€æœ‰é…æ–™ã€‚ä½ é‡åˆ°äº†å“ªäº›é—®é¢˜æˆ–é™åˆ¶ï¼Ÿ
- en: ''
  id: totrans-416
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Come back to this problem after you finish the next section.
  id: totrans-417
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨å®Œæˆä¸‹ä¸€èŠ‚ä¹‹åï¼Œå›åˆ°è¿™ä¸ªé—®é¢˜ã€‚
- en: 5.1.4.1Â Built-In Operations on Lists of Numbers[ğŸ”—](#(part._.Built-.In_.Operations_on_.Lists_of_.Numbers)
    "Link to here")
  id: totrans-418
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1.4.1 æ•°å­—åˆ—è¡¨çš„å†…ç½®æ“ä½œ[ğŸ”—](#(part._.Built-.In_.Operations_on_.Lists_of_.Numbers) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Pyret handily provides a useful set of operations we can already perform on
    lists. The [lists documentation](https://www.pyret.org/docs/latest/lists.html)
    describes these operations. As you might have guessed, we can already compute
    most of the answers weâ€™ve asked for at the start of the chapter. First we need
    to include some libraries that contain useful functions:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: Pyretæ–¹ä¾¿åœ°æä¾›äº†ä¸€ç»„æˆ‘ä»¬å¯ä»¥åœ¨åˆ—è¡¨ä¸Šæ‰§è¡Œçš„æœ‰ç”¨æ“ä½œã€‚[åˆ—è¡¨æ–‡æ¡£](https://www.pyret.org/docs/latest/lists.html)æè¿°äº†è¿™äº›æ“ä½œã€‚æ­£å¦‚ä½ å¯èƒ½çŒœåˆ°çš„ï¼Œæˆ‘ä»¬å·²ç»åœ¨ç« èŠ‚å¼€å§‹æ—¶è®¡ç®—äº†å¤§éƒ¨åˆ†æˆ‘ä»¬è¦æ±‚çš„é—®é¢˜çš„ç­”æ¡ˆã€‚é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦åŒ…å«ä¸€äº›åŒ…å«æœ‰ç”¨å‡½æ•°çš„åº“ï¼š
- en: '[PRE54]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can then access several useful functions:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥è®¿é—®å‡ ä¸ªæœ‰ç”¨çš„å‡½æ•°ï¼š
- en: '[PRE55]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `M.` notation means "the function inside the library `M`. The `import` statement
    in the above code gave the name `M` to the `math` library.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`M.`è¡¨ç¤ºâ€œåº“`M`ä¸­çš„å‡½æ•°â€ã€‚ä¸Šè¿°ä»£ç ä¸­çš„`import`è¯­å¥å°†`math`åº“å‘½åä¸º`M`ã€‚'
- en: 5.1.4.2Â Built-In Operations on Lists in General[ğŸ”—](#(part._.Built-.In_.Operations_on_.Lists_in_.General)
    "Link to here")
  id: totrans-424
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1.4.2 åˆ—è¡¨çš„ä¸€èˆ¬å†…ç½®æ“ä½œ[ğŸ”—](#(part._.Built-.In_.Operations_on_.Lists_in_.General) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Some of the useful computations in our list at the start of the chapter involved
    the `discount` column, which contains strings rather than numbers. Specifically,
    letâ€™s consider the following question:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨ç« èŠ‚å¼€å¤´åˆ—è¡¨ä¸­çš„æŸäº›æœ‰ç”¨è®¡ç®—æ¶‰åŠåˆ°`discount`åˆ—ï¼Œè¯¥åˆ—åŒ…å«å­—ç¬¦ä¸²è€Œä¸æ˜¯æ•°å­—ã€‚å…·ä½“æ¥è¯´ï¼Œè®©æˆ‘ä»¬è€ƒè™‘ä»¥ä¸‹é—®é¢˜ï¼š
- en: Compute the collection of unique discount codes that were used (many might have
    been available).
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è®¡ç®—ä½¿ç”¨è¿‡çš„å”¯ä¸€æŠ˜æ‰£ä»£ç é›†åˆï¼ˆå¯èƒ½æœ‰å¾ˆå¤šå¯ç”¨ï¼‰ã€‚
- en: 'None of the table functions handle a question like this. However, this is a
    common kind of question to ask about a collection of values (How many unique artists
    are in your playlist? How many unique faculty are teaching courses?). As such,
    Pyret (as most languages) provides a way to identify the unique elements of a
    list. Hereâ€™s how we get the list of all discount codes that were used in our table:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: æ²¡æœ‰è¡¨æ ¼å‡½æ•°å¯ä»¥å¤„ç†è¿™æ ·çš„é—®é¢˜ã€‚ç„¶è€Œï¼Œè¿™ç±»é—®é¢˜åœ¨è¯¢é—®ä¸€ç»„å€¼æ—¶å¾ˆå¸¸è§ï¼ˆä½ çš„æ’­æ”¾åˆ—è¡¨ä¸­æœ‰å¤šå°‘ç‹¬ç‰¹çš„è‰ºæœ¯å®¶ï¼Ÿæœ‰å¤šå°‘ç‹¬ç‰¹çš„æ•™å‘˜åœ¨æ•™æˆè¯¾ç¨‹ï¼Ÿï¼‰ã€‚å› æ­¤ï¼ŒPyretï¼ˆä»¥åŠå¤§å¤šæ•°è¯­è¨€ï¼‰æä¾›äº†ä¸€ç§æ–¹æ³•æ¥è¯†åˆ«åˆ—è¡¨ä¸­çš„å”¯ä¸€å…ƒç´ ã€‚ä»¥ä¸‹æ˜¯æˆ‘ä»¬å¦‚ä½•è·å–æˆ‘ä»¬è¡¨æ ¼ä¸­ä½¿ç”¨çš„æ‰€æœ‰æŠ˜æ‰£ä»£ç çš„åˆ—è¡¨ï¼š
- en: '[PRE56]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `distinct` function produces a list of the unique values from the input
    list: every value in the input list appears exactly once in the output list. For
    the above code, Pyret produces:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`distinct`å‡½æ•°ä»è¾“å…¥åˆ—è¡¨ä¸­ç”Ÿæˆä¸€ä¸ªå”¯ä¸€å€¼çš„åˆ—è¡¨ï¼šè¾“å…¥åˆ—è¡¨ä¸­çš„æ¯ä¸ªå€¼åœ¨è¾“å‡ºåˆ—è¡¨ä¸­æ°å¥½å‡ºç°ä¸€æ¬¡ã€‚å¯¹äºä¸Šé¢çš„ä»£ç ï¼ŒPyretç”Ÿæˆï¼š'
- en: '[PRE57]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: What if we wanted to exclude `"none"` from that list? After all, `"none"` isnâ€™t
    an actual discount code, but rather one that we introduced while cleaning up the
    table. Is there a way to easily remove `"none"` from the list?
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æƒ³ä»åˆ—è¡¨ä¸­æ’é™¤`"none"`æ€ä¹ˆåŠï¼Ÿæ¯•ç«Ÿï¼Œ`"none"`ä¸æ˜¯ä¸€ä¸ªå®é™…çš„æŠ˜æ‰£ä»£ç ï¼Œè€Œæ˜¯ä¸€ä¸ªæˆ‘ä»¬åœ¨æ¸…ç†è¡¨æ ¼æ—¶å¼•å…¥çš„ä»£ç ã€‚æœ‰æ²¡æœ‰ä¸€ç§ç®€å•çš„æ–¹æ³•å¯ä»¥ä»åˆ—è¡¨ä¸­ç§»é™¤`"none"`ï¼Ÿ
- en: 'There are two ways we could do it. In the Pyret lists documentation, we find
    a function called `remove`, which removes a specific element from a list:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ã€‚åœ¨Pyretåˆ—è¡¨æ–‡æ¡£ä¸­ï¼Œæˆ‘ä»¬æ‰¾åˆ°ä¸€ä¸ªåä¸º`remove`çš„å‡½æ•°ï¼Œè¯¥å‡½æ•°å¯ä»¥ä»åˆ—è¡¨ä¸­ç§»é™¤ä¸€ä¸ªç‰¹å®šçš„å…ƒç´ ï¼š
- en: '|'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE58]'
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '&#124;'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE59]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '|'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'But this operation should also sound familiar: with tables, we used `filter-with`
    to keep only those elements that meet a specific criterion. The filtering idea
    is so common that Pyret (and most other languages) provide a similar operation
    on lists. In the case of the discount codes, we could also have written:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†è¿™ä¸ªæ“ä½œä¹Ÿåº”è¯¥å¬èµ·æ¥å¾ˆç†Ÿæ‚‰ï¼šä½¿ç”¨è¡¨æ ¼æ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†`filter-with`æ¥ä¿ç•™æ»¡è¶³ç‰¹å®šæ ‡å‡†çš„å…ƒç´ ã€‚è¿‡æ»¤çš„æƒ³æ³•éå¸¸å¸¸è§ï¼Œä»¥è‡³äºPyretï¼ˆä»¥åŠå¤§å¤šæ•°å…¶ä»–è¯­è¨€ï¼‰åœ¨åˆ—è¡¨ä¸Šæä¾›äº†ç±»ä¼¼çš„æ“ä½œã€‚åœ¨æŠ˜æ‰£ä»£ç çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥è¿™æ ·å†™ï¼š
- en: '[PRE60]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The difference between these two approaches is that `filter` is more flexible:
    we can check any characteristic of a list element using `filter`, but `remove`
    only checks whether the entire element is equal to the value that we provide.
    If instead of removing the specific string `"none"`, we had wanted to remove all
    strings that were in all-lowercase, we would have needed to use `filter`.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸¤ç§æ–¹æ³•ä¹‹é—´çš„åŒºåˆ«åœ¨äº`filter`æ›´çµæ´»ï¼šæˆ‘ä»¬å¯ä»¥ä½¿ç”¨`filter`æ£€æŸ¥åˆ—è¡¨å…ƒç´ çš„ä»»ä½•ç‰¹å¾ï¼Œä½†`remove`åªæ£€æŸ¥æ•´ä¸ªå…ƒç´ æ˜¯å¦ç­‰äºæˆ‘ä»¬æä¾›çš„å€¼ã€‚å¦‚æœæˆ‘ä»¬ä¸æ˜¯æƒ³ç§»é™¤ç‰¹å®šçš„å­—ç¬¦ä¸²`"none"`ï¼Œè€Œæ˜¯æƒ³ç§»é™¤æ‰€æœ‰å…¨å°å†™çš„å­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬å°±éœ€è¦ä½¿ç”¨`filter`ã€‚
- en: Exercise
  id: totrans-444
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write a function that takes a list of words and removes those words in which
    all letters are in lowercase. (Hint: combine `string-to-lower` and `==`).'
  id: totrans-446
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ªå•è¯åˆ—è¡¨ï¼Œå¹¶ç§»é™¤æ‰€æœ‰å­—æ¯éƒ½ä¸ºå°å†™çš„å•è¯ã€‚ï¼ˆæç¤ºï¼šç»“åˆ`string-to-lower`å’Œ`==`ï¼‰ã€‚
- en: 5.1.4.3Â An Aside on Naming Conventions[ğŸ”—](#(part._.An_.Aside_on_.Naming_.Conventions)
    "Link to here")
  id: totrans-447
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1.4.3 å…³äºå‘½åçº¦å®šçš„è¡¥å……[ğŸ”—](#(part._.An_.Aside_on_.Naming_.Conventions) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Our use of the plural `codes` for the list of values in the column named `discount`
    (singular) is deliberate. A list contains multiple values, so a plural is appropriate.
    In a table, in contrast, we think of a column header as naming a single value
    that appears in a specific row. Often, we speak of looking up a value in a specific
    row and column: the singular name for the column supports thinking about lookup
    in an individual row.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨åä¸º`discount`ï¼ˆå•æ•°ï¼‰çš„åˆ—çš„å€¼åˆ—è¡¨ä¸­ä½¿ç”¨å¤æ•°`codes`æ˜¯æœ‰æ„ä¸ºä¹‹ã€‚åˆ—è¡¨åŒ…å«å¤šä¸ªå€¼ï¼Œæ‰€ä»¥å¤æ•°æ˜¯åˆé€‚çš„ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œåœ¨è¡¨æ ¼ä¸­ï¼Œæˆ‘ä»¬è®¤ä¸ºåˆ—æ ‡é¢˜å‘½åçš„æ˜¯ç‰¹å®šè¡Œä¸­å‡ºç°çš„å•ä¸ªå€¼ã€‚æˆ‘ä»¬ç»å¸¸è°ˆè®ºåœ¨ç‰¹å®šè¡Œå’Œåˆ—ä¸­æŸ¥æ‰¾å€¼ï¼šåˆ—çš„å•æ•°åç§°æ”¯æŒåœ¨å•ä¸ªè¡Œä¸­è¿›è¡ŒæŸ¥æ‰¾çš„æƒ³æ³•ã€‚
- en: 5.1.4.4Â Getting Elements By Position[ğŸ”—](#(part._.Getting_.Elements_.By_.Position)
    "Link to here")
  id: totrans-449
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1.4.4 é€šè¿‡ä½ç½®è·å–å…ƒç´ [ğŸ”—](#(part._.Getting_.Elements_.By_.Position) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Letâ€™s look at a new analysis question: the events company recently ran an advertising
    campaign on `web.com`, and they are curious whether it paid off. To do this, they
    need to determine how many sales were made to people with `web.com` email addresses.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªæ–°çš„åˆ†æé—®é¢˜ï¼šäº‹ä»¶å…¬å¸æœ€è¿‘åœ¨`web.com`ä¸Šåšäº†ä¸€æ¬¡å¹¿å‘Šå®£ä¼ æ´»åŠ¨ï¼Œä»–ä»¬æƒ³çŸ¥é“è¿™æœ‰æ²¡æœ‰å¸¦æ¥å›æŠ¥ã€‚ä¸ºäº†åšåˆ°è¿™ä¸€ç‚¹ï¼Œä»–ä»¬éœ€è¦ç¡®å®šæœ‰å¤šå°‘é”€å”®æ˜¯é€šè¿‡å¸¦æœ‰`web.com`ç”µå­é‚®ä»¶åœ°å€çš„äººå®Œæˆçš„ã€‚
- en: Do Now!
  id: totrans-451
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Propose a task plan ([Task Plans](processing-tables.html#%28part._task-plans%29))
    for this computation.
  id: totrans-453
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æå‡ºä¸€ä¸ªè®¡ç®—ä»»åŠ¡è®¡åˆ’ï¼ˆ[ä»»åŠ¡è®¡åˆ’](processing-tables.html#%28part._task-plans%29)ï¼‰ã€‚
- en: 'Hereâ€™s a proposed plan, annotated with how we might implement each part:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€ä¸ªæå‡ºçš„è®¡åˆ’ï¼Œå¹¶é™„ä¸Šäº†æˆ‘ä»¬å¯èƒ½å¦‚ä½•å®ç°æ¯ä¸€éƒ¨åˆ†çš„è¯´æ˜ï¼š
- en: Get the list of email addresses (use `get-column`)
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è·å–ç”µå­é‚®ä»¶åœ°å€åˆ—è¡¨ï¼ˆä½¿ç”¨`get-column`ï¼‰
- en: Extract those that came from `web.com` (use `L.filter`)
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æå–æ¥è‡ª `web.com` çš„é‚£äº›ï¼ˆä½¿ç”¨ `L.filter`ï¼‰
- en: Count how many email addresses remain (using `L.length`, which we hadnâ€™t discussed
    yet, but it is in the documentation)
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è®¡ç®—å‰©ä½™çš„ç”µå­é‚®ä»¶åœ°å€æ•°é‡ï¼ˆä½¿ç”¨ `L.length`ï¼Œæˆ‘ä»¬è¿˜æ²¡æœ‰è®¨è®ºè¿‡ï¼Œä½†å®ƒå·²åœ¨æ–‡æ¡£ä¸­ï¼‰
- en: (As a reminder, unless you immediately see how to solve a problem, write out
    a task plan and annotate the parts you know how to do. It helps break down a programming
    problem into more manageable parts.)
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆä½œä¸ºæé†’ï¼Œé™¤éä½ ç«‹å³çŸ¥é“å¦‚ä½•è§£å†³é—®é¢˜ï¼Œå¦åˆ™è¯·åˆ—å‡ºä»»åŠ¡è®¡åˆ’å¹¶æ ‡æ³¨ä½ çŸ¥é“å¦‚ä½•åšçš„éƒ¨åˆ†ã€‚è¿™æœ‰åŠ©äºå°†ç¼–ç¨‹é—®é¢˜åˆ†è§£æˆæ›´æ˜“äºç®¡ç†çš„éƒ¨åˆ†ã€‚ï¼‰
- en: 'Letâ€™s discuss the second task: identifying messages from `web.com`. We know
    that email addresses are strings, so if we could determine whether an email string
    ends in `@web.com`, weâ€™d be set. You could consider doing this by looking at the
    last 7 characters of the email string. Another option is to use a string operation
    that we havenâ€™t yet seen called `string-split-all`, which splits a string into
    a list of substrings around a given character. For example:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è®¨è®ºç¬¬äºŒä¸ªä»»åŠ¡ï¼šè¯†åˆ«æ¥è‡ª `web.com` çš„æ¶ˆæ¯ã€‚æˆ‘ä»¬çŸ¥é“ç”µå­é‚®ä»¶åœ°å€æ˜¯å­—ç¬¦ä¸²ï¼Œæ‰€ä»¥å¦‚æœæˆ‘ä»¬èƒ½ç¡®å®šç”µå­é‚®ä»¶å­—ç¬¦ä¸²æ˜¯å¦ä»¥ `@web.com`
    ç»“å°¾ï¼Œæˆ‘ä»¬å°±æˆåŠŸäº†ã€‚ä½ å¯ä»¥è€ƒè™‘é€šè¿‡æŸ¥çœ‹ç”µå­é‚®ä»¶å­—ç¬¦ä¸²çš„æœ€å 7 ä¸ªå­—ç¬¦æ¥åšè¿™ä»¶äº‹ã€‚å¦ä¸€ä¸ªé€‰æ‹©æ˜¯ä½¿ç”¨æˆ‘ä»¬å°šæœªçœ‹åˆ°çš„å­—ç¬¦ä¸²æ“ä½œ `string-split-all`ï¼Œå®ƒå°†å­—ç¬¦ä¸²æ‹†åˆ†ä¸ºå›´ç»•ç»™å®šå­—ç¬¦çš„å­å­—ç¬¦ä¸²åˆ—è¡¨ã€‚ä¾‹å¦‚ï¼š
- en: '|'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE61]'
  id: totrans-462
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '&#124;'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE62]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '|'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE63]'
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '&#124;'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE64]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '|'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: This seems pretty useful. If we split each email string around the `@` sign,
    then we can check whether the second string in the list is `web.com` (since email
    addresses should have only one `@` sign). But how would we get the second element
    out of the list produced by `string-split-all`? Here we dig into the list, as
    we did to extract rows from tables, this time using the `get` operation.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™çœ‹èµ·æ¥éå¸¸æœ‰ç”¨ã€‚å¦‚æœæˆ‘ä»¬å›´ç»• `@` ç¬¦å·æ‹†åˆ†æ¯ä¸ªç”µå­é‚®ä»¶å­—ç¬¦ä¸²ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥æ£€æŸ¥åˆ—è¡¨ä¸­çš„ç¬¬äºŒä¸ªå­—ç¬¦ä¸²æ˜¯å¦ä¸º `web.com`ï¼ˆå› ä¸ºç”µå­é‚®ä»¶åœ°å€åº”è¯¥åªæœ‰ä¸€ä¸ª
    `@` ç¬¦å·ï¼‰ã€‚ä½†æˆ‘ä»¬å¦‚ä½•ä» `string-split-all` ç”Ÿæˆçš„åˆ—è¡¨ä¸­è·å–ç¬¬äºŒä¸ªå…ƒç´ å‘¢ï¼Ÿåœ¨è¿™é‡Œï¼Œæˆ‘ä»¬åƒæå–è¡¨æ ¼ä¸­çš„è¡Œä¸€æ ·æ·±å…¥åˆ—è¡¨ï¼Œè¿™æ¬¡ä½¿ç”¨ `get`
    æ“ä½œã€‚
- en: '|'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE65]'
  id: totrans-479
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '&#124;'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE66]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '|'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Do Now!
  id: totrans-485
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-486
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do we use `1` as the input to `get` if we want the second item in the list?
  id: totrans-487
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æƒ³è¦åˆ—è¡¨ä¸­çš„ç¬¬äºŒä¸ªé¡¹ç›®ï¼Œä¸ºä»€ä¹ˆå°† `1` ä½œä¸º `get` çš„è¾“å…¥ï¼Ÿ
- en: 'Hereâ€™s the complete program for doing this check:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯å®Œæˆæ­¤æ£€æŸ¥çš„å®Œæ•´ç¨‹åºï¼š
- en: '[PRE67]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Exercise
  id: totrans-490
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if there is a malformed email address string that doesnâ€™t contain
    the `@` string? What would happen? What could you do about that?
  id: totrans-492
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœæœ‰ä¸€ä¸ªæ ¼å¼ä¸æ­£ç¡®çš„ç”µå­é‚®ä»¶åœ°å€å­—ç¬¦ä¸²ä¸åŒ…å« `@` å­—ç¬¦ä¸²ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿä½ èƒ½åšäº›ä»€ä¹ˆï¼Ÿ
- en: 5.1.4.5Â Transforming Lists[ğŸ”—](#(part._.Transforming_.Lists) "Link to here")
  id: totrans-493
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1.4.5Â è½¬æ¢åˆ—è¡¨[ğŸ”—](#(part._.Transforming_.Lists) "é“¾æ¥è‡³æ­¤")
- en: Imagine now that we had a list of email addresses, but instead just wanted a
    list of usernames. This doesnâ€™t make sense for our event data, but it does make
    sense in other contexts (such as connecting messages to folders organized by studentsâ€™
    usernames).
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾ç°åœ¨æˆ‘ä»¬æœ‰ä¸€ä¸ªç”µå­é‚®ä»¶åœ°å€åˆ—è¡¨ï¼Œä½†æˆ‘ä»¬åªæƒ³æœ‰ä¸€ä¸ªç”¨æˆ·ååˆ—è¡¨ã€‚è¿™åœ¨æˆ‘ä»¬çš„äº‹ä»¶æ•°æ®ä¸­å¹¶ä¸åˆç†ï¼Œä½†åœ¨å…¶ä»–ä¸Šä¸‹æ–‡ä¸­æ˜¯æœ‰æ„ä¹‰çš„ï¼ˆä¾‹å¦‚ï¼Œå°†æ¶ˆæ¯è¿æ¥åˆ°æŒ‰å­¦ç”Ÿç”¨æˆ·åç»„ç»‡çš„æ–‡ä»¶å¤¹ï¼‰ã€‚
- en: 'Specifcally, we want to start with a list of addresses such as:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬æƒ³è¦ä»ä¸€ä¸ªåœ°å€åˆ—è¡¨å¼€å§‹ï¼Œä¾‹å¦‚ï¼š
- en: '[PRE68]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: and convert it to
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¶å°†å…¶è½¬æ¢ä¸º
- en: '[PRE69]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Do Now!
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-500
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Consider the list functions we have seen so far (`distinct`, `filter`, `length`)
    â€“ are any of them useful for this task? Can you articulate why?
  id: totrans-501
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è€ƒè™‘æˆ‘ä»¬è¿„ä»Šä¸ºæ­¢çœ‹åˆ°çš„åˆ—è¡¨å‡½æ•°ï¼ˆ`distinct`ã€`filter`ã€`length`ï¼‰â€”â€”å®ƒä»¬ä¸­çš„ä»»ä½•ä¸€ä¸ªå¯¹è¿™ä¸ªä»»åŠ¡æœ‰ç”¨å—ï¼Ÿä½ èƒ½é˜è¿°ä¸ºä»€ä¹ˆå—ï¼Ÿ
- en: One way to articulate a precise answer to this is think in terms of the inputs
    and outputs of the existing functions. Both `filter` and `distinct` return a list
    of elements from the input list, not transformed elements. `length` returns a
    number, not a list. So none of these are appropriate.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ç§æ˜ç¡®å›ç­”è¿™ä¸ªé—®é¢˜çš„æ–¹æ³•æ˜¯ä»ç°æœ‰å‡½æ•°çš„è¾“å…¥å’Œè¾“å‡ºè§’åº¦æ€è€ƒã€‚`filter` å’Œ `distinct` éƒ½è¿”å›è¾“å…¥åˆ—è¡¨ä¸­çš„å…ƒç´ åˆ—è¡¨ï¼Œè€Œä¸æ˜¯è½¬æ¢åçš„å…ƒç´ ã€‚`length`
    è¿”å›ä¸€ä¸ªæ•°å­—ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªåˆ—è¡¨ã€‚æ‰€ä»¥è¿™äº›éƒ½ä¸åˆé€‚ã€‚
- en: 'This idea of transforming elements is similar to the `transform-column` operation
    that we previously saw on tables. The corresponding operation on lists is called
    `map`. Hereâ€™s an example:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§è½¬æ¢å…ƒç´ çš„æƒ³æ³•ç±»ä¼¼äºæˆ‘ä»¬åœ¨è¡¨æ ¼ä¸­ä¹‹å‰çœ‹åˆ°çš„ `transform-column` æ“ä½œã€‚åˆ—è¡¨ä¸Šçš„ç›¸åº”æ“ä½œç§°ä¸º `map`ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼š
- en: '[PRE70]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '5.1.4.6Â Recap: Summary of List Operations[ğŸ”—](#(part._lists-recap) "Link to
    here")'
  id: totrans-505
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1.4.6Â å›é¡¾ï¼šåˆ—è¡¨æ“ä½œæ€»ç»“[ğŸ”—](#(part._lists-recap) "é“¾æ¥è‡³æ­¤")
- en: 'At this point, we have seen several useful built-in functions for working with
    lists:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»çœ‹åˆ°äº†å‡ ä¸ªç”¨äºå¤„ç†åˆ—è¡¨çš„æœ‰ç”¨å†…ç½®å‡½æ•°ï¼š
- en: '`filter :: (A -> Boolean), List<A> -> List<A>`, which produces a list of elements
    from the input list on which the given function returns `true`.'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter :: (A -> Boolean), List<A> -> List<A>`ï¼Œå®ƒäº§ç”Ÿä¸€ä¸ªåˆ—è¡¨ï¼ŒåŒ…å«è¾“å…¥åˆ—è¡¨ä¸­ç»™å®šå‡½æ•°è¿”å› `true`
    çš„å…ƒç´ ã€‚'
- en: '`map :: (A -> B), List<A> -> List<B>`, which produces a list of the results
    of calling the given function on each element of the input list.'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map :: (A -> B), List<A> -> List<B>`ï¼Œå®ƒäº§ç”Ÿä¸€ä¸ªåˆ—è¡¨ï¼Œè¯¥åˆ—è¡¨åŒ…å«å¯¹è¾“å…¥åˆ—è¡¨ä¸­æ¯ä¸ªå…ƒç´ è°ƒç”¨ç»™å®šå‡½æ•°çš„ç»“æœã€‚'
- en: '`distinct :: List<A> -> List<A>`, which produces a list of the unique elements
    that appear in the input list.'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distinct :: List<A> -> List<A>`ï¼Œå®ƒäº§ç”Ÿä¸€ä¸ªåˆ—è¡¨ï¼Œå…¶ä¸­åŒ…å«è¾“å…¥åˆ—è¡¨ä¸­å‡ºç°çš„å”¯ä¸€å…ƒç´ ã€‚'
- en: '`length :: List<A> -> Number`, which produces the number of elements in the
    input list.'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length :: List<A> -> Number`ï¼Œå®ƒäº§ç”Ÿè¾“å…¥åˆ—è¡¨ä¸­çš„å…ƒç´ æ•°é‡ã€‚'
- en: Here, a type such as `List<A>` says that we have a list whose elements are of
    some (unspecified) type which weâ€™ll call `A`. A type variable such as this is
    useful when we want to show relationships between two types in a function contract.
    Here, the type variable `A` captures that the type of elements is the same in
    the input and output to `filter`. In `map`, however, the type of element in the
    output list could differ from that in the input list.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œä¸€ä¸ªå¦‚ `List<A>` è¿™æ ·çš„ç±»å‹è¡¨ç¤ºæˆ‘ä»¬æœ‰ä¸€ä¸ªå…ƒç´ ç±»å‹ä¸ºæŸç§ï¼ˆæœªæŒ‡å®šçš„ï¼‰ç±»å‹çš„åˆ—è¡¨ï¼Œæˆ‘ä»¬å°†ç§°ä¹‹ä¸º `A`ã€‚è¿™ç§ç±»å‹å˜é‡åœ¨å‡½æ•°å¥‘çº¦ä¸­æ˜¾ç¤ºä¸¤ä¸ªç±»å‹ä¹‹é—´çš„å…³ç³»æ—¶å¾ˆæœ‰ç”¨ã€‚åœ¨è¿™é‡Œï¼Œç±»å‹å˜é‡
    `A` æ•è·äº†å…ƒç´ ç±»å‹åœ¨ `filter` çš„è¾“å…¥å’Œè¾“å‡ºä¸­æ˜¯ç›¸åŒçš„ã€‚ç„¶è€Œï¼Œåœ¨ `map` ä¸­ï¼Œè¾“å‡ºåˆ—è¡¨ä¸­çš„å…ƒç´ ç±»å‹å¯èƒ½ä¸è¾“å…¥åˆ—è¡¨ä¸­çš„å…ƒç´ ç±»å‹ä¸åŒã€‚
- en: 'One additional built-in function that is quite useful in practice is:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å®è·µä¸­éå¸¸æœ‰ç”¨çš„ä¸€ä¸ªé¢å¤–å†…ç½®å‡½æ•°æ˜¯ï¼š
- en: '`member :: List<A>, Any -> Boolean`, which determines whether the given element
    is in the list. We use the type `Any` when there are no constraints on the type
    of value provided to a function.'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`member :: List<A>, Any -> Boolean`ï¼Œå®ƒç¡®å®šç»™å®šå…ƒç´ æ˜¯å¦åœ¨åˆ—è¡¨ä¸­ã€‚å½“æä¾›ç»™å‡½æ•°çš„å€¼çš„ç±»å‹æ²¡æœ‰çº¦æŸæ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨ç±»å‹ `Any`ã€‚'
- en: Many useful computations can be performed by combining these operations.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: è®¸å¤šæœ‰ç”¨çš„è®¡ç®—å¯ä»¥é€šè¿‡ç»„åˆè¿™äº›æ“ä½œæ¥å®Œæˆã€‚
- en: Exercise
  id: totrans-515
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-516
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Assume you used a list of strings to represent the ingredients in a recipe.
    Here are three examples:'
  id: totrans-517
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å‡è®¾ä½ ä½¿ç”¨å­—ç¬¦ä¸²åˆ—è¡¨æ¥è¡¨ç¤ºé£Ÿè°±ä¸­çš„é…æ–™ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›ç¤ºä¾‹ï¼š
- en: ''
  id: totrans-518
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-519
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE71]'
- en: ''
  id: totrans-520
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write the following functions on ingredient lists:'
  id: totrans-521
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨é…æ–™åˆ—è¡¨ä¸Šç¼–å†™ä»¥ä¸‹å‡½æ•°ï¼š
- en: ''
  id: totrans-522
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`recipes-uses`, which takes an ingredient list and an ingredient and determines
    whether the recipe uses the ingredient.'
  id: totrans-523
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recipes-uses` å‡½æ•°æ¥å—ä¸€ä¸ªé…æ–™åˆ—è¡¨å’Œä¸€ä¸ªé…æ–™ï¼Œå¹¶ç¡®å®šè¯¥é£Ÿè°±æ˜¯å¦ä½¿ç”¨äº†è¯¥é…æ–™ã€‚'
- en: ''
  id: totrans-524
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-525
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`make-vegetarian`, which takes an ingredient list and replaces all meat ingredients
    with `"tofu"`. Meat ingredients are `"pork"`, `"chicken"`, and `"beef"`.'
  id: totrans-526
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make-vegetarian` å‡½æ•°æ¥å—ä¸€ä¸ªé…æ–™åˆ—è¡¨ï¼Œå¹¶å°†æ‰€æœ‰è‚‰ç±»é…æ–™æ›¿æ¢ä¸º `"tofu"`ã€‚è‚‰ç±»é…æ–™æ˜¯ `"pork"`ã€`"chicken"`
    å’Œ `"beef"`ã€‚'
- en: ''
  id: totrans-527
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-528
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`protein-veg-count`, which takes an ingredient list and determines how many
    ingredients are in the list that arenâ€™t `"rice"` or `"noodles"`.'
  id: totrans-529
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protein-veg-count` å‡½æ•°æ¥å—ä¸€ä¸ªé…æ–™åˆ—è¡¨ï¼Œå¹¶ç¡®å®šåˆ—è¡¨ä¸­æœ‰å¤šå°‘é…æ–™ä¸æ˜¯ `"rice"` æˆ– `"noodles"`ã€‚'
- en: Exercise
  id: totrans-530
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-531
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'More challenging: Write a function that takes an ingredient and a list of ingredient
    lists and produces a list of all the lists that contain the given ingredient.'
  id: totrans-532
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ›´å…·æŒ‘æˆ˜æ€§ï¼šç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ªé…æ–™å’Œä¸€ä¸ªé…æ–™åˆ—è¡¨åˆ—è¡¨ï¼Œå¹¶ç”ŸæˆåŒ…å«ç»™å®šé…æ–™çš„æ‰€æœ‰åˆ—è¡¨ã€‚
- en: ''
  id: totrans-533
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Hint: write examples first to make sense of the problem as needed.'
  id: totrans-534
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æç¤ºï¼šé¦–å…ˆç¼–å†™ç¤ºä¾‹ï¼Œä»¥ä¾¿åœ¨éœ€è¦æ—¶ç†è§£é—®é¢˜ã€‚
- en: Exercise
  id: totrans-535
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-536
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Even more challenging: Try to write a function that takes two ingredient lists
    and returns all of the ingredients that are common to both lists. What issue(s)
    or limitations do you run into?'
  id: totrans-537
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ›´åŠ å…·æœ‰æŒ‘æˆ˜æ€§ï¼šå°è¯•ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸¤ä¸ªé…æ–™åˆ—è¡¨å¹¶è¿”å›ä¸¤ä¸ªåˆ—è¡¨ä¸­å…±åŒçš„æ‰€æœ‰é…æ–™ã€‚ä½ é‡åˆ°äº†å“ªäº›é—®é¢˜æˆ–é™åˆ¶ï¼Ÿ
- en: ''
  id: totrans-538
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Come back to this problem after you finish the next section.
  id: totrans-539
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨å®Œæˆä¸‹ä¸€èŠ‚ä¹‹åï¼Œå›åˆ°è¿™ä¸ªé—®é¢˜ã€‚
- en: '5.1.5Â Lambda: Anonymous Functions[ğŸ”—](#(part._.Lambda__.Anonymous_.Functions)
    "Link to here")'
  id: totrans-540
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '5.1.5 Lambda: åŒ¿åå‡½æ•°[ğŸ”—](#(part._.Lambda__.Anonymous_.Functions) "é“¾æ¥åˆ°æ­¤å¤„")'
- en: 'NOTE: if you already saw `lam` in [Lambda: Anonymous Functions](intro-tabular-data.html#%28part._sec~3alambda-tables%29),
    feel free to skip this section, or just do the exercises at the end. Here we present
    `lam` using lists and `filter`, rather than tables and `filter-with`.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ³¨æ„ï¼šå¦‚æœä½ å·²ç»åœ¨ [Lambda: åŒ¿åå‡½æ•°](intro-tabular-data.html#%28part._sec~3alambda-tables%29)
    ä¸­çœ‹åˆ°äº† `lam`ï¼Œä½ å¯ä»¥è‡ªç”±åœ°è·³è¿‡è¿™ä¸€èŠ‚ï¼Œæˆ–è€…åªéœ€åšç»“å°¾çš„ç»ƒä¹ ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨åˆ—è¡¨å’Œ `filter` è€Œä¸æ˜¯è¡¨æ ¼å’Œ `filter-with` æ¥å±•ç¤º
    `lam`ã€‚'
- en: 'Letâ€™s revisit the program we wrote earlier in this chapter for finding all
    of the discount codes that were used in the events table:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹æœ¬ç« å‰é¢ç¼–å†™çš„ç¨‹åºï¼Œç”¨äºæŸ¥æ‰¾åœ¨äº‹ä»¶è¡¨ä¸­ä½¿ç”¨çš„æ‰€æœ‰æŠ˜æ‰£ä»£ç ï¼š
- en: '[PRE72]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This program might feel a bit verbose: do we really need to write a helper
    function just to perform something as simple as a `filter`? Wouldnâ€™t it be easier
    to just write something like:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªç¨‹åºå¯èƒ½æ„Ÿè§‰æœ‰ç‚¹å†—é•¿ï¼šæˆ‘ä»¬çœŸçš„éœ€è¦ç¼–å†™ä¸€ä¸ªè¾…åŠ©å‡½æ•°æ¥æ‰§è¡Œå¦‚æ­¤ç®€å•çš„ `filter` æ“ä½œå—ï¼Ÿç›´æ¥å†™ç‚¹åƒè¿™æ ·çš„äº‹æƒ…ä¸æ˜¯æ›´å®¹æ˜“å—ï¼Ÿ
- en: '[PRE73]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Do Now!
  id: totrans-546
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-547
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What will Pyret produce if you run this expression?
  id: totrans-548
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœä½ è¿è¡Œè¿™ä¸ªè¡¨è¾¾å¼ï¼ŒPyret ä¼šäº§ç”Ÿä»€ä¹ˆç»“æœï¼Ÿ
- en: Pyret will produce an `unbound identifier` error around the use of `c` in this
    expression. What is `c`? We mean for `c` to be the elements from `codes` in turn.
    Conceptually, thatâ€™s what `filter` does, but we donâ€™t have the mechanics right.
    When we call a function, we evaluate the arguments before the body of the function.
    Hence, the error regarding `c` being unbound. The whole point of the `real-code`
    helper function is to make `c` a parameter to a function whose body is only evaluated
    once a value for `c` is available.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: Pyretä¼šåœ¨ä½¿ç”¨`c`çš„è¡¨è¾¾å¼ä¸­äº§ç”Ÿä¸€ä¸ª`æœªç»‘å®šæ ‡è¯†ç¬¦`é”™è¯¯ã€‚`c`æ˜¯ä»€ä¹ˆï¼Ÿæˆ‘ä»¬å¸Œæœ›`c`ä¾æ¬¡æ˜¯`codes`ä¸­çš„å…ƒç´ ã€‚ä»æ¦‚å¿µä¸Šè®²ï¼Œè¿™å°±æ˜¯`filter`æ‰€åšçš„äº‹æƒ…ï¼Œä½†æˆ‘ä»¬æ²¡æœ‰æ­£ç¡®åœ°å®ç°æœºåˆ¶ã€‚å½“æˆ‘ä»¬è°ƒç”¨ä¸€ä¸ªå‡½æ•°æ—¶ï¼Œæˆ‘ä»¬ä¼šå…ˆè¯„ä¼°å‡½æ•°ä½“ä¹‹å‰çš„å‚æ•°ã€‚å› æ­¤ï¼Œå…³äº`c`æœªç»‘å®šçš„é”™è¯¯ã€‚`real-code`è¾…åŠ©å‡½æ•°çš„å…¨éƒ¨ç›®çš„å°±æ˜¯ä½¿`c`æˆä¸ºå‡½æ•°çš„ä¸€ä¸ªå‚æ•°ï¼Œè¯¥å‡½æ•°ä½“åªæœ‰åœ¨`c`çš„å€¼å¯ç”¨æ—¶æ‰ä¼šè¢«è¯„ä¼°ã€‚
- en: 'To tighten the notation as in the one-line `filter` expression, then, we have
    to find a way to tell Pyret to make a temporary function that will get its inputs
    once `filter` is running. The following notation achieves this:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ä½¿ç¬¦å·æ›´åŠ ç´§å‡‘ï¼Œå°±åƒå•è¡Œ`filter`è¡¨è¾¾å¼ä¸­çš„é‚£æ ·ï¼Œæˆ‘ä»¬éœ€è¦æ‰¾åˆ°ä¸€ç§æ–¹æ³•å‘Šè¯‰Pyretåˆ›å»ºä¸€ä¸ªä¸´æ—¶å‡½æ•°ï¼Œè¯¥å‡½æ•°å°†åœ¨`filter`è¿è¡Œæ—¶è·å–å…¶è¾“å…¥ã€‚ä»¥ä¸‹ç¬¦å·å®ç°äº†è¿™ä¸€ç‚¹ï¼š
- en: '[PRE74]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We have added `lam(c)` and `end` around the expression that we want to use in
    the `filter`. The `lam(c)` says "make a temporary function that takes `c` as an
    input". The `end` serves to end the function definition, as when we use `fun`.
    `lam` is short for `lambda`, a form of function definition that exists in many,
    though not all, languages.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨æƒ³è¦åœ¨`filter`ä¸­ä½¿ç”¨çš„è¡¨è¾¾å¼ä¸­æ·»åŠ äº†`lam(c)`å’Œ`end`ã€‚`lam(c)`è¡¨ç¤ºâ€œåˆ›å»ºä¸€ä¸ªä¸´æ—¶å‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—`c`ä½œä¸ºè¾“å…¥â€ã€‚`end`çš„ä½œç”¨æ˜¯ç»“æŸå‡½æ•°å®šä¹‰ï¼Œå°±åƒæˆ‘ä»¬ä½¿ç”¨`fun`æ—¶ä¸€æ ·ã€‚`lam`æ˜¯`lambda`çš„ç¼©å†™ï¼Œå®ƒæ˜¯ä¸€ç§å­˜åœ¨äºè®¸å¤šè¯­è¨€ä¸­ä½†å¹¶éæ‰€æœ‰è¯­è¨€ä¸­çš„å‡½æ•°å®šä¹‰å½¢å¼ã€‚
- en: 'The main difference between our original expression (using the `real-code`
    helper) and this new one (using `lam`) can be seen through the program directory.
    To explain this, a little detail about how `filter` is defined under the hood.
    In part, it looks like:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åŸå§‹è¡¨è¾¾å¼ï¼ˆä½¿ç”¨`real-code`è¾…åŠ©å‡½æ•°ï¼‰å’Œè¿™ä¸ªæ–°è¡¨è¾¾å¼ï¼ˆä½¿ç”¨`lam`ï¼‰ä¹‹é—´çš„ä¸»è¦åŒºåˆ«å¯ä»¥é€šè¿‡ç¨‹åºç›®å½•æ¥çœ‹åˆ°ã€‚ä¸ºäº†è§£é‡Šè¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦äº†è§£ä¸€ä¸‹`filter`åœ¨åº•å±‚æ˜¯å¦‚ä½•å®šä¹‰çš„ã€‚éƒ¨åˆ†åœ°ï¼Œå®ƒçœ‹èµ·æ¥åƒï¼š
- en: '[PRE75]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Whether we pass `real-code` or the `lam` version to `filter`, the `keep` parameter
    ends up referring to a function with the same parameter and body. Since the function
    is only actually called through the `keep` name, it doesnâ€™t matter whether or
    not a name is associated with it when it is initially defined.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: æ— è®ºæˆ‘ä»¬ä¼ é€’`real-code`è¿˜æ˜¯`lam`ç‰ˆæœ¬ç»™`filter`ï¼Œ`keep`å‚æ•°æœ€ç»ˆéƒ½ä¼šæŒ‡å‘ä¸€ä¸ªå…·æœ‰ç›¸åŒå‚æ•°å’Œä½“çš„å‡½æ•°ã€‚ç”±äºå‡½æ•°å®é™…ä¸Šæ˜¯é€šè¿‡`keep`åç§°è°ƒç”¨çš„ï¼Œå› æ­¤å½“å®ƒæœ€åˆå®šä¹‰æ—¶ï¼Œæ˜¯å¦ä¸å®ƒå…³è”ä¸€ä¸ªåç§°å¹¶ä¸é‡è¦ã€‚
- en: In practice, we use `lam` when we have to pass simple (single line) functions
    to operations like `filter` (or `map`). We could have just as easily used them
    when we were working with tables (`build-column`, `filter-with`, etc). Of course,
    you can continue to write out names for helper functions as we did with `real-code`
    if that makes more sense to you.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å®è·µä¸­ï¼Œå½“æˆ‘ä»¬éœ€è¦å°†ç®€å•çš„ï¼ˆå•è¡Œï¼‰å‡½æ•°ä¼ é€’ç»™åƒ`filter`ï¼ˆæˆ–`map`ï¼‰è¿™æ ·çš„æ“ä½œæ—¶ï¼Œæˆ‘ä»¬ä¼šä½¿ç”¨`lam`ã€‚æˆ‘ä»¬åŒæ ·å¯ä»¥åœ¨å¤„ç†è¡¨æ ¼æ—¶ä½¿ç”¨å®ƒä»¬ï¼ˆä¾‹å¦‚`build-column`ã€`filter-with`ç­‰ï¼‰ã€‚å½“ç„¶ï¼Œå¦‚æœæ‚¨è§‰å¾—è¿™æ ·æ›´æœ‰æ„ä¹‰ï¼Œæ‚¨ä¹Ÿå¯ä»¥ç»§ç»­åƒ`real-code`é‚£æ ·ä¸ºè¾…åŠ©å‡½æ•°ç¼–å†™åç§°ã€‚
- en: Exercise
  id: totrans-557
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-558
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write the program to extract the list of usernames from a list of email addresses
    using `lam` rather than a named helper-function.
  id: totrans-559
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œä½¿ç”¨`lam`è€Œä¸æ˜¯å‘½åè¾…åŠ©å‡½æ•°ä»ç”µå­é‚®ä»¶åœ°å€åˆ—è¡¨ä¸­æå–ç”¨æˆ·ååˆ—è¡¨ã€‚
- en: Exercise
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-561
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Try again to tackle the problem from the end of the previous section: write
    a function that takes two ingredient lists and returns all of the ingredients
    that are common to both lists.'
  id: totrans-562
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å†æ¬¡å°è¯•ä»ä¸Šä¸€èŠ‚çš„æœ«å°¾å¼€å§‹è§£å†³è¿™ä¸ªé—®é¢˜ï¼šç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸¤ä¸ªé…æ–™åˆ—è¡¨ï¼Œå¹¶è¿”å›ä¸¤ä¸ªåˆ—è¡¨ä¸­å…±åŒçš„æ‰€æœ‰é…æ–™ã€‚
- en: 5.1.6Â Combining Lists and Tables[ğŸ”—](#(part._.Combining_.Lists_and_.Tables) "Link
    to here")
  id: totrans-563
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.6Â ç»“åˆåˆ—è¡¨å’Œè¡¨æ ¼[ğŸ”—](#(part._.Combining_.Lists_and_.Tables) "é“¾æ¥åˆ°æ­¤å¤„")
- en: The table functions we studied previously were primarily for processing rows.
    The list functions weâ€™ve learned in this chapter have been primarily for processing
    columns (but there are many more uses in the chapters ahead). If an analysis involves
    working with only some rows and some columns, weâ€™ll use a combination of both
    table and list functions in our program.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¹‹å‰ç ”ç©¶çš„è¡¨æ ¼å‡½æ•°ä¸»è¦ç”¨äºå¤„ç†è¡Œã€‚æˆ‘ä»¬åœ¨æœ¬ç« ä¸­å­¦åˆ°çš„åˆ—è¡¨å‡½æ•°ä¸»è¦ç”¨äºå¤„ç†åˆ—ï¼ˆä½†æ¥ä¸‹æ¥çš„ç« èŠ‚ä¸­è¿˜æœ‰æ›´å¤šç”¨é€”ï¼‰ã€‚å¦‚æœä¸€ä¸ªåˆ†æåªæ¶‰åŠå¤„ç†ä¸€äº›è¡Œå’Œä¸€äº›åˆ—ï¼Œæˆ‘ä»¬å°†åœ¨ç¨‹åºä¸­ä½¿ç”¨è¡¨æ ¼å’Œåˆ—è¡¨å‡½æ•°çš„ç»„åˆã€‚
- en: Exercise
  id: totrans-565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the events table, produce a list of names of all people who will pick
    up their tickets.
  id: totrans-567
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»™å®šäº‹ä»¶è¡¨ï¼Œç”Ÿæˆæ‰€æœ‰å°†å–ç¥¨çš„äººçš„å§“ååˆ—è¡¨ã€‚
- en: Exercise
  id: totrans-568
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-569
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the events table, produce the average number of tickets that were ordered
    by people with email addresses that end in `".org"`.
  id: totrans-570
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»™å®šäº‹ä»¶è¡¨ï¼Œè®¡ç®—ä»¥`".org"`ç»“å°¾çš„ç”µå­é‚®ä»¶åœ°å€çš„äººè®¢è´­çš„å¹³å‡ç¥¨æ•°ã€‚
- en: 'Sometimes, there will be more than one way to perform a computation:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰æ—¶ï¼Œæ‰§è¡Œè®¡ç®—å¯èƒ½ä¼šæœ‰å¤šç§æ–¹æ³•ï¼š
- en: Do Now!
  id: totrans-572
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-573
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Consider a question such as "how many people with `".org"` email addresses bought
    more than 8 tickets". Propose multiple task plans that would solve this problem,
    including which table and list functions would accomplish each task.
  id: totrans-574
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è€ƒè™‘ä¸€ä¸ªé—®é¢˜ï¼Œæ¯”å¦‚â€œæœ‰å¤šå°‘äººä½¿ç”¨`".org"`ç”µå­é‚®ä»¶åœ°å€è´­ä¹°äº†è¶…è¿‡8å¼ ç¥¨â€ã€‚æå‡ºå¤šä¸ªè§£å†³è¿™ä¸ªé—®é¢˜çš„ä»»åŠ¡è®¡åˆ’ï¼ŒåŒ…æ‹¬å“ªäº›è¡¨å’Œåˆ—è¡¨å‡½æ•°å¯ä»¥å®Œæˆæ¯ä¸ªä»»åŠ¡ã€‚
- en: 'There are several options here:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰å‡ ä¸ªé€‰é¡¹ï¼š
- en: Get the `event-data` rows with no more than 8 tickets (using `filter-with`),
    get those rows that have `".org"` addresses (another `filter-with`), then ask
    for how many rows are in the table (using `<table>.length()`).
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è·å–æ²¡æœ‰è¶…è¿‡8å¼ ç¥¨çš„`event-data`è¡Œï¼ˆä½¿ç”¨`filter-with`ï¼‰ï¼Œè·å–é‚£äº›æœ‰`".org"`åœ°å€çš„è¡Œï¼ˆå¦ä¸€ä¸ª`filter-with`ï¼‰ï¼Œç„¶åè¯¢é—®è¡¨ä¸­è¡Œæ•°ï¼ˆä½¿ç”¨`<table>.length()`ï¼‰ã€‚
- en: Get the `event-data` rows with no more than 8 tickets and `".org"` address (using
    `filter-with` with a function that checks both conditions at once), then ask for
    how many rows are in the table (using `<table>.length()`).
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è·å–æ²¡æœ‰è¶…è¿‡8å¼ ç¥¨å’Œ`".org"`åœ°å€çš„`event-data`è¡Œï¼ˆä½¿ç”¨`filter-with`åŒæ—¶æ£€æŸ¥è¿™ä¸¤ä¸ªæ¡ä»¶çš„å‡½æ•°ï¼‰ï¼Œç„¶åè¯¢é—®è¡¨ä¸­è¡Œæ•°ï¼ˆä½¿ç”¨`<table>.length()`ï¼‰ã€‚
- en: Get the `event-data` rows with no more than 8 tickets (using `filter-with`),
    extract the email addresses (using `get-column`), limit those to `".org"` (using
    `L.filter`), then get the length of the resulting list (using `L.length`).
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è·å–æ²¡æœ‰è¶…è¿‡8å¼ ç¥¨çš„`event-data`è¡Œï¼ˆä½¿ç”¨`filter-with`ï¼‰ï¼Œæå–ç”µå­é‚®ä»¶åœ°å€ï¼ˆä½¿ç”¨`get-column`ï¼‰ï¼Œé™åˆ¶åˆ°`".org"`ï¼ˆä½¿ç”¨`L.filter`ï¼‰ï¼Œç„¶åè·å–ç»“æœåˆ—è¡¨çš„é•¿åº¦ï¼ˆä½¿ç”¨`L.length`ï¼‰ã€‚
- en: There are others, but you get the idea.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: è¿˜æœ‰å…¶ä»–é€‰é¡¹ï¼Œä½†ä½ åº”è¯¥æ˜ç™½äº†ã€‚
- en: Do Now!
  id: totrans-580
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-581
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which approach do you like best? Why?
  id: totrans-582
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ æœ€å–œæ¬¢å“ªç§æ–¹æ³•ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ
- en: 'While there is no single correct answer, there are various considerations:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶æ²¡æœ‰å”¯ä¸€çš„æ­£ç¡®ç­”æ¡ˆï¼Œä½†æœ‰è®¸å¤šè€ƒè™‘å› ç´ ï¼š
- en: Are any of the intermediate results useful for other computations? While the
    second option might seem best because it filters the table once rather than twice,
    perhaps the events company has many computations to perform on larger ticket orders.
    Similarly, the company may want the list of email addresses on large orders for
    other purposes (the third option)
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä»»ä½•ä¸­é—´ç»“æœå¯¹å…¶ä»–è®¡ç®—æœ‰ç”¨å—ï¼Ÿè™½ç„¶ç¬¬äºŒä¸ªé€‰é¡¹å¯èƒ½çœ‹èµ·æ¥æœ€å¥½ï¼Œå› ä¸ºå®ƒåªè¿‡æ»¤è¡¨æ ¼ä¸€æ¬¡è€Œä¸æ˜¯ä¸¤æ¬¡ï¼Œä½†ä¹Ÿè®¸äº‹ä»¶å…¬å¸éœ€è¦å¯¹æ›´å¤§çš„è®¢å•æ‰§è¡Œè®¸å¤šè®¡ç®—ã€‚åŒæ ·ï¼Œå…¬å¸å¯èƒ½å¸Œæœ›ä¸ºäº†å…¶ä»–ç›®çš„ï¼ˆç¬¬ä¸‰ä¸ªé€‰é¡¹ï¼‰è·å–å¤§è®¢å•çš„ç”µå­é‚®ä»¶åœ°å€åˆ—è¡¨
- en: Do you want to follow a discipline of doing operations on individuals within
    the table, extracting lists only when needed to perform aggregating computations
    that arenâ€™t available on tables?
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½ æ˜¯å¦æƒ³åœ¨è¡¨æ ¼ä¸­å¯¹ä¸ªä½“è¿›è¡Œæ“ä½œï¼Œåªåœ¨éœ€è¦æ‰§è¡Œè¡¨æ ¼ä¸Šä¸å¯ç”¨çš„èšåˆè®¡ç®—æ—¶æå–åˆ—è¡¨ï¼Ÿ
- en: 'Does one approach seem less resource-intensive than the other? This is actually
    a subtle point: you might be tempted to think that filtering over a table uses
    more resources than filtering over a list of values from one column, but this
    actually isnâ€™t the case. Weâ€™ll return to this discussion later.'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœ‰ä¸€ç§æ–¹æ³•çœ‹èµ·æ¥æ¯”å¦ä¸€ç§æ–¹æ³•èµ„æºæ¶ˆè€—æ›´å°‘å—ï¼Ÿè¿™å®é™…ä¸Šæ˜¯ä¸€ä¸ªå¾®å¦™çš„é—®é¢˜ï¼šä½ å¯èƒ½å€¾å‘äºè®¤ä¸ºåœ¨è¡¨æ ¼ä¸Šè¿‡æ»¤æ¯”åœ¨æŸä¸€åˆ—çš„å€¼åˆ—è¡¨ä¸Šè¿‡æ»¤ä½¿ç”¨æ›´å¤šèµ„æºï¼Œä½†å®é™…ä¸Šå¹¶éå¦‚æ­¤ã€‚æˆ‘ä»¬ç¨åä¼šå›åˆ°è¿™ä¸ªè®¨è®ºã€‚
- en: A company or project team sometimes sets design standards to help you make those
    decisions. In the absence of that, and especially as you are learning to program,
    consider multiple approaches when faced with such problems, then pick one to implement.
    Maintaining the ability to think flexibly about approaches is a useful skill in
    any form of design.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: å…¬å¸æˆ–é¡¹ç›®å›¢é˜Ÿæœ‰æ—¶ä¼šè®¾å®šè®¾è®¡æ ‡å‡†æ¥å¸®åŠ©ä½ åšå‡ºè¿™äº›å†³å®šã€‚åœ¨æ²¡æœ‰è¿™äº›æ ‡å‡†çš„æƒ…å†µä¸‹ï¼Œå°¤å…¶æ˜¯åœ¨ä½ å­¦ä¹ ç¼–ç¨‹æ—¶ï¼Œé¢å¯¹æ­¤ç±»é—®é¢˜æ—¶ï¼Œè€ƒè™‘å¤šç§æ–¹æ³•ï¼Œç„¶åé€‰æ‹©ä¸€ä¸ªæ¥å®ç°ã€‚ä¿æŒçµæ´»æ€è€ƒæ–¹æ³•çš„èƒ½åŠ›åœ¨ä»»ä½•å½¢å¼çš„è®¾è®¡ä¸­éƒ½æ˜¯ä¸€é¡¹æœ‰ç”¨çš„æŠ€èƒ½ã€‚
- en: Until now weâ€™ve only seen how to use built-in functions over lists. Next [[Processing
    Lists](processing-lists.html)], we will study how to create our own functions
    that process lists. Once we learn that, these list processing functions will remain
    powerful but will no longer seem quite so magical, because weâ€™ll be able to build
    them for ourselves!
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬åªçœ‹åˆ°äº†å¦‚ä½•ä½¿ç”¨å†…ç½®å‡½æ•°å¤„ç†åˆ—è¡¨ã€‚åœ¨æ¥ä¸‹æ¥çš„ [[å¤„ç†åˆ—è¡¨](processing-lists.html)] ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•åˆ›å»ºæˆ‘ä»¬è‡ªå·±çš„å¤„ç†åˆ—è¡¨çš„å‡½æ•°ã€‚ä¸€æ—¦æˆ‘ä»¬å­¦ä¼šäº†è¿™ä¸€ç‚¹ï¼Œè¿™äº›åˆ—è¡¨å¤„ç†å‡½æ•°å°†ä»ç„¶å¼ºå¤§ï¼Œä½†å°†ä¸å†æ˜¾å¾—é‚£ä¹ˆç¥å¥‡ï¼Œå› ä¸ºæˆ‘ä»¬å°†èƒ½å¤Ÿä¸ºè‡ªå·±æ„å»ºå®ƒä»¬ï¼
