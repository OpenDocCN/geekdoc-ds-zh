- en: Pipeline Hazards
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道风险
- en: 原文：[https://en.algorithmica.org/hpc/pipelining/hazards/](https://en.algorithmica.org/hpc/pipelining/hazards/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://en.algorithmica.org/hpc/pipelining/hazards/](https://en.algorithmica.org/hpc/pipelining/hazards/)'
- en: '[Pipelining](../) lets you hide the latencies of instructions by running them
    concurrently, but also creates some potential obstacles of its own — characteristically
    called *pipeline hazards*, that is, situations when the next instruction cannot
    execute on the following clock cycle.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[管道化](../)让你可以通过并行运行指令来隐藏指令的延迟，但同时也创造了它自己的潜在障碍——通常称为*管道风险*，即下一个指令不能在下一个时钟周期上执行的情况。'
- en: 'There are multiple ways this may happen:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能以多种方式发生：
- en: A *structural hazard* happens when two or more instructions need the same part
    of CPU (e.g., an execution unit).
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当两个或更多指令需要CPU的同一部分（例如，一个执行单元）时，会发生*结构风险*。
- en: A *data hazard* happens when you have to wait for an operand to be computed
    from some previous step.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你必须等待一个操作数从之前的步骤计算出来时，会发生*数据风险*。
- en: A *control hazard* happens when a CPU can’t tell which instructions it needs
    to execute next.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当CPU无法确定它需要执行下一个指令时，会发生*控制风险*。
- en: 'The only way to resolve a hazard is to have a *pipeline stall*: stop the progress
    of all previous steps until the cause of congestion is gone. This creates *bubbles*
    in the pipeline — analogous with air bubbles in fluid pipes — a time-propagating
    condition when execution units are idling and no useful work is done.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 解决风险的唯一方法是有一个*管道停顿*：停止所有之前步骤的进展，直到拥堵的原因消失。这会在管道中产生*气泡*——类似于流体管道中的气泡——一个执行单元空闲且没有进行有用工作的传播条件。
- en: '![](../Images/b5c812bf3b053324998324c493b67e59.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b5c812bf3b053324998324c493b67e59.png)'
- en: Pipeline stall on the execution stage
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 执行阶段的管道停顿
- en: 'Different hazards have different penalties:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的风险有不同的惩罚：
- en: In structural hazards, you have to wait (usually one more cycle) until the execution
    unit is ready. They are fundamental bottlenecks on performance and can’t be avoided
    — you have to engineer around them.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在结构风险中，你必须等待（通常多一个周期）直到执行单元准备好。它们是性能的基本瓶颈，无法避免——你必须围绕它们进行设计。
- en: In data hazards, you have to wait for the required data to be computed (the
    latency of the *critical path*). Data hazards are solved by restructuring computations
    so that the critical path is shorter.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据风险中，你必须等待所需的数据被计算出来（*关键路径*的延迟）。数据风险通过重新结构化计算来解决，使关键路径变短。
- en: In control hazards, you generally have to flush the entire pipeline and start
    over, wasting a whole 15-20 cycles. They are solved by either removing branches
    completely, or making them predictable so that the CPU can effectively *speculate*
    on what is going to be executed next.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制风险中，你通常必须清空整个管道并重新开始，浪费了整整15-20个周期。它们通过完全移除分支或使它们可预测来解决，这样CPU就可以有效地*推测*下一个要执行的操作。
- en: As they have very different impacts on performance, we are going to go in the
    reversed order and start with the more grave ones.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们对性能的影响非常不同，我们将按照相反的顺序进行，从更严重的问题开始。
- en: '[← ../Instruction-Level Parallelism](https://en.algorithmica.org/hpc/pipelining/)[The
    Cost of Branching →](https://en.algorithmica.org/hpc/pipelining/branching/)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[← ../指令级并行](https://en.algorithmica.org/hpc/pipelining/)[分支的成本 →](https://en.algorithmica.org/hpc/pipelining/branching/)'
