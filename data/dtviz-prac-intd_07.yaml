- en: 6 Work with models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 与模型一起工作
- en: 原文：[https://socviz.co/modeling.html](https://socviz.co/modeling.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://socviz.co/modeling.html](https://socviz.co/modeling.html)
- en: Data visualization is about more than generating figures that display the raw
    numbers from a table of data. Right from the beginning, it involves summarizing
    or transforming parts of the data, and then plotting the results. Statistical
    models are a central part of that process. In this Chapter, we will begin by looking
    briefly at how ggplot can use various modeling techniques directly within geoms.
    Then we will see how to use the `broom` and `margins` libraries to tidily extract
    and plot estimates from models that we fit ourselves.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可视化不仅仅是生成显示数据表中原始数字的图表。从一开始，它就涉及到总结或转换数据的一部分，然后绘制结果。统计模型是这个过程的核心部分。在本章中，我们将首先简要地看看ggplot如何直接在geoms中使用各种建模技术。然后我们将看到如何使用`broom`和`margins`库整洁地提取和绘制我们自行拟合的模型的估计值。
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Histograms, density plots, boxplots, and other geoms compute either single numbers
    or new variables before plotting them. As we saw in Section [4.4](groupfacettx.html#statfunctions),
    these calculations are done by `stat_` functions, each of which works hand-in-hand
    with its default `geom_` function, and *vice versa*. Moreover, from the smoothing
    lines we drew from almost the very first plots we made, we have seen that `stat_`
    functions can do a fair amount of calculation and even model estimation on the
    fly. The `geom_smooth()` function can take a range of `method` arguments to fit
    LOESS, OLS, and robust regression lines, amongst others.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图、密度图、箱线图和其他geoms在绘图之前计算单个数字或新变量。正如我们在[4.4](groupfacettx.html#statfunctions)节中看到的，这些计算是通过`stat_`函数完成的，每个函数都与它的默认`geom_`函数紧密合作，反之亦然。此外，从我们几乎从第一张图开始就绘制的平滑线中，我们已经看到`stat_`函数可以在飞行中进行相当数量的计算甚至模型估计。`geom_smooth()`函数可以接受一系列`method`参数来拟合LOESS、OLS和稳健回归线等。
- en: '![From top to bottom: an OLS vs robust regression comparison; a polynomial
    fit; and quantile regression.](../Images/5e0f8a786d35d2776bd2ade9bc6896c2.png)![From
    top to bottom: an OLS vs robust regression comparison; a polynomial fit; and quantile
    regression.](../Images/57342b13ec034d19a24d373e9943a57d.png)![From top to bottom:
    an OLS vs robust regression comparison; a polynomial fit; and quantile regression.](../Images/2ebf7a3136803c7e67df9ae98d103b65.png)
    Figure 6.1: From top to bottom: an OLS vs robust regression comparison; a polynomial
    fit; and quantile regression.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '![从上到下：OLS与稳健回归的比较；多项式拟合；以及分位数回归。](../Images/5e0f8a786d35d2776bd2ade9bc6896c2.png)![从上到下：OLS与稳健回归的比较；多项式拟合；以及分位数回归。](../Images/57342b13ec034d19a24d373e9943a57d.png)![从上到下：OLS与稳健回归的比较；多项式拟合；以及分位数回归。](../Images/2ebf7a3136803c7e67df9ae98d103b65.png)
    图6.1：从上到下：OLS与稳健回归的比较；多项式拟合；以及分位数回归。'
- en: Both the `geom_smooth()` and `geom_quantile()` functions can also be instructed
    to use different formulas to produce their fits. In the top panel of Figure [6.1](modeling.html#fig:ch-06-modeltypes),
    we access the `MASS` library’s `rlm` function to fit a robust regression line.
    In the second panel, the `bs` function is invoked directly from the `splines`
    library in the same way, to fit a polynominal curve to the data. This is the same
    approach to directly accessing functions without loading a whole library that
    we have already used several times when using functions from the `scales` library.
    The `geom_quantile()` function, meanwhile, is like a specialized version of `geom_smooth()`
    that can fit quantile regression lines using a variety of methods. The `quantiles`
    argument takes a vector specifying the quantiles at which to fit the lines.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`geom_smooth()`和`geom_quantile()`函数也可以被指示使用不同的公式来生成它们的拟合。在图[6.1](modeling.html#fig:ch-06-modeltypes)的上半部分，我们访问了`MASS`库的`rlm`函数来拟合稳健回归线。在第二部分，`bs`函数直接从`splines`库中调用，以拟合数据的多项式曲线。这是与我们之前多次使用`scales`库中的函数时直接访问函数而不加载整个库相同的方法。同时，`geom_quantile()`函数类似于`geom_smooth()`的专用版本，可以使用各种方法拟合分位数回归线。`quantiles`参数接受一个向量，指定拟合线的分位数。'
- en: 6.1 Show several fits at once, with a legend
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 同时展示多个拟合，并带有图例
- en: As we just saw in the first panel of Figure [6.1](modeling.html#fig:ch-06-modeltypes),
    where we plotted both an OLS and a robust regression line, we can look at several
    fits at once on the same plot by layering on new smoothers with `geom_smooth()`.
    As long as we set the `color` and `fill` aesthetics to different values for each
    fit, we can easily distinguish them visually. However, ggplot will not draw a
    legend that guides us about which fit is which. This is because the smoothers
    are not logically connected to one another. They exist as separate layers. What
    if we are comparing several different fits and want a legend describing them?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在图 [6.1](modeling.html#fig:ch-06-modeltypes) 的第一个面板中看到的，我们绘制了 OLS 和稳健回归线，我们可以通过在
    `geom_smooth()` 上叠加新的平滑器来同时查看同一图上的几个拟合。只要我们为每个拟合设置不同的 `color` 和 `fill` 美学值，我们就可以轻松地通过视觉来区分它们。然而，ggplot
    不会绘制一个引导我们了解哪个拟合是哪个的图例。这是因为平滑器之间没有逻辑上的联系。它们作为单独的层存在。如果我们正在比较几个不同的拟合并希望有一个描述它们的图例怎么办？
- en: 'As it turns out, `geom_smooth()` can do this via the slightly unusual route
    of mapping the `color` and `fill` aesthetics to a string describing the model
    we are fitting, and then using `scale_color_manual()` and `scale_fill_manual()`
    to create the legend. First we use `brewer.pal()` from the RColorBrewer library
    to extract three qualitatively different colors from a larger palette. The colors
    are represented as hex values. As before use the `::` convention to use the function
    without loading the whole library:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`geom_smooth()` 可以通过将 `color` 和 `fill` 美学映射到描述我们正在拟合的模型的字符串的稍微不寻常的路线来实现这一点，然后使用
    `scale_color_manual()` 和 `scale_fill_manual()` 来创建图例。首先，我们使用 RColorBrewer 库中的
    `brewer.pal()` 从更大的调色板中提取三个质量上不同的颜色。颜色以十六进制值表示。像以前一样，使用 `::` 习惯用法来使用函数而不加载整个库：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then we create a plot with three different smoothers, mapping the color and
    fill *within the `aes()` function* as the name of the smoother:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个包含三个不同平滑器的图表，将颜色和填充映射到 `aes()` 函数内的平滑器名称：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Figure 6.2: Fitting smoothers with a legend.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2：使用图例拟合平滑器。
- en: '![Fitting smoothers with a legend.](../Images/5a99296ca57928e76a48f13a3687d518.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![使用图例拟合平滑器](../Images/5a99296ca57928e76a48f13a3687d518.png)'
- en: In a way we have cheated a little here to make the plot work. Until now, we
    have always mapped aesthetics to the names of variables, not to strings like “OLS”
    or “Cubic Splines”. In Chapter [3](makeplot.html#makeplot), when we discussed
    mapping versus setting aesthetics, we saw what happened when we tried to change
    the color of the points in a scatterplot by setting them to “purple” inside the
    `aes()` function. The result was that the points turned red instead, as ggplot
    in effect created a new variable and labeled it with the word “purple”. We learned
    there that the `aes()` function was for mapping variables to aesthetics.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，我们在这里稍微作弊了一点，让图表工作。到目前为止，我们总是将美学映射到变量的名称，而不是像“OLS”或“Cubic Splines”这样的字符串。在第
    [3](makeplot.html#makeplot) 章，当我们讨论映射与设置美学时，我们看到了当我们尝试通过在 `aes()` 函数内部将它们设置为“紫色”来更改散点图中点的颜色时发生了什么。结果是，点变成了红色，因为
    ggplot 实际上创建了一个新变量并将其标记为“紫色”。我们了解到 `aes()` 函数是用来将变量映射到美学的。
- en: Here we take advantage of that behavior, creating a new single-value variable
    for the name of each of our models. Ggplot will properly construct the relevant
    guide if we call `scale_color_manual()` and `scale_fill_manual()`.Remember that
    we have to call two scale functions because we have two mappings. The result is
    a single plot containing not just our three smoothers, but also an appropriate
    legend to guide the reader.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们利用这种行为，为我们的每个模型创建一个新的单值变量来命名。如果我们调用 `scale_color_manual()` 和 `scale_fill_manual()`，Ggplot
    将正确构建相关的指南。记住，我们必须调用两个缩放函数，因为我们有两个映射。结果是包含我们的三个平滑器，以及一个适当的图例来引导读者的单个图表。
- en: These model-fitting features make ggplot very useful for exploratory work, and
    make it straightforward to generate and compare model-based trends and other summaries
    as part of the process of descriptive data visualization. The various `stat_`
    functions are a flexible way to add summary estimates of various kinds to plots.
    But we will also want more than this, including presenting results from models
    we fit ourselves.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模型拟合功能使 ggplot 非常适用于探索性工作，并且使生成和比较基于模型的趋势和其他摘要作为描述性数据可视化过程的一部分变得简单直接。各种 `stat_`
    函数是向图表添加各种类型总结估计的灵活方式。但我们也希望得到更多，包括展示我们拟合的模型的结果。
- en: 6.2 Look inside model objects
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 查看模型对象内部
- en: Covering the details of fitting statistical models in R is beyond the scope
    of this book. For a comprehensive, modern introduction to that topic you should
    work your way through (Gelman & Hill, 2018). (Harrell, 2016) is also very good
    on the many practical connections between modeling and graphing data. Similarly,
    (Gelman, 2004) provides a detailed discussion of the use of graphics as a tool
    in model-checking and validation. Here we will discuss some ways to take the models
    that you fit and extract information that is easy to work with in ggplot. Our
    goal, as always, is to get from however the object is stored to a tidy table of
    numbers that we can plot. Most classes of statistical model in R will contain
    the information we need, or will have a special set of functions, or methods,
    designed to extract it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，涵盖 R 中拟合统计模型的细节超出了范围。对于该主题的全面、现代介绍，你应该阅读（Gelman & Hill, 2018）。（Harrell,
    2016）在建模与绘图数据之间的许多实际联系方面也非常出色。同样，（Gelman, 2004）详细讨论了将图形作为模型检查和验证工具的使用。在这里，我们将讨论一些方法，通过这些方法可以从你拟合的模型中提取出易于在
    ggplot 中处理的信息。我们的目标，一如既往，是从对象存储的任何方式到我们可以绘制的整洁数字表。R 中大多数统计模型类都将包含我们需要的信息，或者将有一组特殊的函数或方法，用于提取它。
- en: We can start by learning a little more about how the output of models is stored
    in R. Remember, we are always working with objects, and objects have an internal
    structure consisting of named pieces. Sometimes these are single numbers, sometimes
    vectors, and sometimes lists of things like vectors, matrices, or formulas.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先了解一下在 R 中模型输出是如何存储的。记住，我们始终在处理对象，而对象具有由命名部分组成的内部结构。有时这些是单个数字，有时是向量，有时是向量、矩阵或公式等类似列表的事物。
- en: We have been working extensively with tibbles and data frames. These store tables
    of data with named columns, perhaps consisting of different classes of variable,
    such as integers, characters, dates, or factors. Model objects are a little more
    complicated again.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在广泛地使用 tibbles 和数据框。这些存储具有命名列的数据表，可能包含不同类型的变量，如整数、字符、日期或因子。模型对象又更复杂一些。
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Remember, we can use the `str()` function to learn more about the internal
    structure of any object. For example, we can get some information on what class
    (or classes) of object `gapminder` is, how large it is, and what components it
    has. The output from `str(gapminder)` is somewhat dense:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们可以使用 `str()` 函数来了解任何对象的内部结构。例如，我们可以获取一些关于 `gapminder` 对象属于哪个类（或哪些类），它有多大，以及它包含哪些组件的信息。`str(gapminder)`
    的输出有些密集：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There is a lot of information here about the object as a whole and each variable
    in it. In the same way, statistical models in R have an internal structure. But
    because models are more complex entities than data tables, their structure is
    correspondingly more complicated. There are more pieces of information, and more
    kinds of information, that we might want to use. All of this information is generally
    stored in or is computable from parts of a model object.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多关于整个对象及其每个变量的信息。同样，R 中的统计模型也有内部结构。但由于模型比数据表更复杂，其结构也相应地更复杂。有更多的信息片段，以及更多种类的信息，我们可能希望使用。所有这些信息通常都存储在模型对象的部分中，或者可以从模型对象的部分计算得出。
- en: 'We can create a linear model, an ordinary OLS regression, using the `gapminder`
    data. This dataset has a country-year structure that makes an OLS specification
    like this the wrong one to use. But never mind that for now. We use the `lm()`
    function to run the model, and store it in an object called `out`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `gapminder` 数据创建一个线性模型，一个普通的 OLS 回归。这个数据集具有国家-年结构，使得像这样的 OLS 规定是错误的。但现在先不要管这个。我们使用
    `lm()` 函数运行模型，并将其存储在一个名为 `out` 的对象中：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first argument is the formula for the model. `lifeExp` is the dependent
    variable and the tilde `~` operator is used to designate the left- and right-hand
    sides of a model (including in cases, as we saw with `facet_wrap()` where the
    model just has a right-hand side.)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是模型的公式。`lifeExp` 是因变量，波浪号 `~` 操作符用于指定模型的左右两侧（包括在 `facet_wrap()` 中，我们看到的模型只有右侧的情况。）
- en: Let’s look at the results by asking R to print a summary of the model.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过让 R 打印模型摘要来查看结果。
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When we use the `summary()` function on `out`, we are not getting a simple feed
    of what’s in the model object. Instead, like any function, `summary()` takes its
    input, performs some actions, and produces output. In this case, what is printed
    to the console is partly information that is stored inside the model object, and
    partly information that the `summary()` function has calculated and formated for
    display on the screen. Behind the scenes, `summary()` gets help from other functions.
    Objects of different classes have default *methods* associated with them, so that
    when the generic `summary()` function is applied to a linear model object, the
    function knows to pass the work on to a more specialized function that does a
    bunch of calculations and formatting appropriate to a linear model object. We
    use the same generic `summary()` function on data frames, as in `summary(gapminder)`,
    but in that case a different default method is applied.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对`out`使用`summary()`函数时，我们并没有得到模型对象内容的简单反馈。相反，像任何函数一样，`summary()`接收其输入，执行一些操作，并产生输出。在这种情况下，打印到控制台的信息部分是存储在模型对象中的信息，部分是`summary()`函数计算并格式化以在屏幕上显示的信息。幕后，`summary()`从其他函数那里获得帮助。不同类的对象都有与之关联的默认*方法*，因此当通用的`summary()`函数应用于线性模型对象时，该函数知道将工作传递给一个更专业的函数，该函数执行一系列适合线性模型对象的计算和格式化。我们也在数据框上使用相同的通用`summary()`函数，如`summary(gapminder)`，但在那种情况下，应用了一个不同的默认方法。
- en: '![Schematic view of a linear model object.](../Images/f5f123f28f8a54c1faa7cd02545df638.png)
    Figure 6.3: Schematic view of a linear model object.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![线性模型对象的示意图](../Images/f5f123f28f8a54c1faa7cd02545df638.png) 图6.3：线性模型对象的示意图。'
- en: The output from `summary()` gives a precis of the model, but we can’t really
    do any further analysis with it directly. For example, what if we want to plot
    something from the model? The information necessary to make plots is inside the
    `out` object, but it is not obvious how to use it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`summary()`函数的输出提供了模型的一个摘要，但直接使用它进行进一步分析是不可能的。例如，如果我们想从模型中绘制某些内容呢？制作图表所需的信息包含在`out`对象中，但如何使用它并不明显。'
- en: 'If we take a look at the structure of the model object with `str(out)` we will
    find that there is a *lot* of information in there. Like most complex objects
    in R, `out` is organized as a list of components or elements. Several of these
    elements are themselves lists. Figure [6.3](modeling.html#fig:ch-06-lm-object-schematic)
    gives you a schematic view of the contents of a linear model object. In this list
    of items, elements are single values, some are data frames, and some are additional
    lists of simpler items. Again, remember our earlier discussion where we said objects
    could be thought of as being organized like a filing system: cabinets contain
    drawers, and drawer may contain which may contain pages of information, whole
    documents, or groups of folders with more documents inside. As an alternative
    analogy, and sticking with the image of a list, you can think of a master to-do
    list for a project, where the top-level headings lead to contain additional lists
    of tasks of different kinds.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用`str(out)`查看模型对象的内部结构，会发现其中包含大量信息。像R中的大多数复杂对象一样，`out`被组织成一个由组件或元素组成的列表。其中一些元素本身也是列表。图[6.3](modeling.html#fig:ch-06-lm-object-schematic)展示了线性模型对象的内容。在这个项目列表中，元素可以是单个值，有的是数据框，有的是更简单项目的附加列表。再次提醒，根据我们之前的讨论，对象可以被看作是像文件系统一样组织：柜子包含抽屉，抽屉可能包含文件夹，文件夹可能包含信息页、整个文档或包含更多文档的文件夹组。作为另一个类比，保持列表的形象，你可以想象一个项目的总待办事项列表，其中顶级标题引导到包含不同类型任务的附加列表。
- en: The `out` object created by `lm` contains several different named elements.
    Some, like the residual degrees of freedom in the model, are just a single number.Try
    `out$df.residual` at the console. Others are much larger entities, such as the
    data frame used to fit the model, which is retained by default. Try `out$model`,
    but be prepared for a lot of stuff to be printed at the console. Other elements
    have been computed by R and then stored, such as the coefficients of the model
    and other quantities. You can try `out$coefficients`, `out$residuals`, and `out$fitted.values`,
    for instance. Others are lists themselves (like `qr`). So you can see that the
    `summary()` function is selecting and printing only a small amount of core information,
    in comparison to what is stored in the model object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `lm` 创建的 `out` 对象包含几个不同的命名元素。其中一些，例如模型中的残差自由度，只是一个单一的数字。在控制台中尝试 `out$df.residual`。其他的是更大的实体，例如用于拟合模型的DataFrame，默认情况下被保留。尝试
    `out$model`，但要做好准备，因为控制台会打印出很多内容。其他元素是由R计算并存储的，例如模型的系数和其他量。例如，你可以尝试 `out$coefficients`、`out$residuals`
    和 `out$fitted.values`。其他是一些列表本身（如 `qr`）。所以你可以看到，与存储在模型对象中的信息相比，`summary()` 函数只选择并打印了一小部分核心信息。
- en: Just like the tables of data we saw earlier in Section [A.1.3](appendix.html#tidydata),
    the output of `summary()` is presented in a way that is *compact* and *efficient*
    in terms of getting information across, but also *untidy* when considered from
    the point of view of further manipulation. There is a table of coefficients, but
    the variable names are in the rows. The column names are awkward, and some information
    (e.g. at the bottom of the output) has been calculated and printed out, but is
    not stored in the model object.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在第[A.1.3](appendix.html#tidydata)节中看到的早期数据表一样，`summary()` 的输出以一种在传达信息方面*紧凑*和*高效*的方式呈现，但从进一步操作的角度来看，它也是*杂乱无章*的。有一个系数表，但变量名在行中。列名很尴尬，一些信息（例如输出底部）已经被计算并打印出来，但并未存储在模型对象中。
- en: 6.3 Get model-based graphics right
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 正确获取基于模型的图形
- en: Figures based on statistical models face all the ordinary challenges of effective
    data visualization, and then some. This is because model results usually carry
    a considerable extra burden of interpretation and necessary background knowledge.
    The more complex the model, the trickier it becomes to convey this information
    effectively, and the easier it becomes to lead one’s audience or oneself into
    error. Within the social sciences, our ability to clearly and honestly present
    model-based graphics has greatly improved over the past ten or fifteen years.
    Over the same period, it has become clearer that some kinds of models are quite
    tricky to understand, even ones that had previously been seen as straightforward
    elements of the modeling toolkit (Ai & Norton, 2003; Brambor, Clark, & Golder,
    2006).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 基于统计模型的图形面临着所有有效数据可视化的普通挑战，甚至更多。这是因为模型结果通常携带相当多的额外解释负担和必要的背景知识。模型越复杂，有效地传达这些信息就越困难，而且更容易引导听众或自己陷入错误。在社会科学领域，我们过去十年或十五年来在清晰和诚实地展示基于模型的图形方面的能力有了很大提高。在同样的时期，人们越来越清楚地认识到，某些类型的模型很难理解，即使它们以前被视为建模工具包中的简单元素（Ai
    & Norton, 2003; Brambor, Clark, & Golder, 2006）。
- en: Plotting model estimates is closely connected to properly estimating models
    in the first place. This means there is no substitute for learning the statistics.
    You should not use graphical methods as a substitute for understanding the model
    used to produce them. While this book cannot teach you that material, we can make
    a few general points about what good model-based graphics look like, and work
    through some examples of how ggplot and some additional libraries can make it
    easier to get good results.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制模型估计与正确估计模型本身密切相关。这意味着学习统计学是没有替代品的。你不应该将图形方法作为理解产生它们的模型的一种替代。虽然这本书不能教你那些材料，但我们可以提出一些关于好的基于模型图形看起来像什么的一般观点，并探讨一些ggplot和一些附加库如何使获得好结果更容易的例子。
- en: 6.3.1 Present your findings in substantive terms
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 用实质性术语呈现你的发现
- en: Useful model-based plots show results in ways that are substantively meaningful
    and directly interpretable with respect to the questions the analysis is trying
    to answer. This means showing results in a context where other variables in the
    analysis are held at sensible values, such as their means or medians. With continuous
    variables, it can often be useful to generate predicted values that cover some
    substantively meaningful move across the distribution, such as from the 25th to
    the 75th percentile, rather than a single-unit increment in the variable of interest.
    For unordered categorical variables, predicted values might be presented with
    respect to the modal category in the data, or for a particular category of theoretical
    interest. Presenting substantively interpretable findings often also means using
    (and sometimes converting to) a scale that readers can easily understand. If your
    model reports results in log-odds, for example, converting the estimates to predicted
    probabilities will make it easier to interpret. All of this advice is quite general.
    Each of these points applies equally well to the presentation of summary results
    in a table rather than a graph. There is nothing distinctively graphical about
    putting the focus on the substantive meaning of your findings.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的基于模型的图表以实质性有意义的方式展示结果，并且可以直接根据分析试图回答的问题进行解释。这意味着在分析中其他变量保持合理值（如均值或中位数）的背景下展示结果。对于连续变量，生成覆盖分布中实质性有意义变化的预测值通常很有用，例如从第25百分位数到第75百分位数，而不是对感兴趣变量的单单位增量。对于无序分类变量，预测值可能根据数据中的众数类别或对理论上有兴趣的特定类别进行展示。展示实质性可解释的发现通常还意味着使用（有时转换为）读者容易理解的量表。例如，如果你的模型报告的是对数优势，将估计值转换为预测概率将使其更容易解释。所有这些建议都非常通用。这些观点同样适用于在表格而不是图表中展示总结结果。将重点放在你发现的实际意义上并没有什么特别图形化的地方。
- en: 6.3.2 Show your degree of confidence
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 展示你的信心程度
- en: Much the same applies to presenting the degree of uncertainty or confidence
    you have in your results. Model estimates come with various measures of precision,
    confidence, credence, or significance. Presenting and interpreting these measures
    is notoriously prone to misinterpretation, or over-interpretation, as researchers
    and audiences both demand more from things like confidence intervals and p-values
    than these statistics can deliver. At a minimum, having decided on an appropriate
    measure of model fit or the right assessment of confidence, you should show their
    range when you present your results. A family of related ggplot geoms allow you
    to show a range or interval defined by position on the x-axis and then a `ymin`
    and `ymax` range on the y-axis. These geoms include `geom_pointrange()` and `geom_errorbar()`,
    which we will see in action shortly. A related geom, `geom_ribbon()` uses the
    same arguments to draw filled areas, and is useful for plotting ranges of y-axis
    values along some continuously varying x-axis.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的情况也适用于展示你对结果的不确定性或信心程度。模型估计伴随着各种精确度、置信度、可信度或显著性的度量。展示和解释这些度量通常容易误解，或者过度解释，因为研究人员和观众对置信区间和p值等东西的要求超过了这些统计量所能提供的。至少，在决定适当的模型拟合度量或正确的置信度评估后，你应该在展示结果时展示它们的范围。一系列相关的ggplot
    geoms允许你展示由x轴上的位置定义的范围或区间，然后在y轴上展示`ymin`和`ymax`的范围。这些geoms包括`geom_pointrange()`和`geom_errorbar()`，我们很快就会看到它们的应用。相关geom，`geom_ribbon()`使用相同的参数来绘制填充区域，并且对于在某个连续变化的x轴上绘制y轴值范围很有用。
- en: 6.3.3 Show your data when you can
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.3 在可能的情况下展示你的数据
- en: Plotting the results from a multivariate model generally means one of two things.
    First, we can show what is in effect a table of coefficients with associated measures
    of confidence, perhaps organizing the coefficients into meaningful groups, or
    by the size of the predicted association, or both. Second, we can show the predicted
    values of some variables (rather than just a model’s coefficients) across some
    range of interest. The latter approach lets us show the original data points if
    we wish. The way ggplot builds graphics layer by layer allows us to easily combine
    model estimates (e.g. a regression line and an associated range) and the underlying
    data. In effect these are manually-constructed versions of the automatically-generated
    plots that we have been producing with `geom_smooth()` since the beginning of
    this book.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制多元模型的成果通常意味着两种情况之一。首先，我们可以展示一个系数表，其中包含相关的置信度度量，可能将系数组织成有意义的组，或按预测关联的大小，或者两者兼而有之。其次，我们可以展示某些变量（而不仅仅是模型的系数）在感兴趣的范围内的预测值。后一种方法允许我们在需要时展示原始数据点。ggplot通过层层构建图形的方式使我们能够轻松地将模型估计（例如，回归线和相关的范围）与底层数据结合起来。实际上，这些是我们从本书开始就一直在使用
    `geom_smooth()` 产生的自动生成的图形的手动构建版本。
- en: 6.4 Generate predictions to graph
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 生成预测图形
- en: Having fitted a model, then, we might want to get a picture of the estimates
    it produces over the range of some particular variable, holding other covariates
    constant at some sensible values. The `predict()` function is a generic way of
    using model objects to produce this kind of prediction. In R, “generic” functions
    take their inputs and pass them along to more specific functions behind the scenes,
    ones that are suited to working with the particular kind of model object we have.
    The details of getting predicted values from a OLS model, for instance, will be
    somewhat different from getting predictions out of a logistic regression. But
    in each case we can use the same `predict()` function, taking care to check the
    documentation to see what form the results are returned in for the kind of model
    we are working with. Many of the most commonly-used functions in R are generic
    in this way. The `summary()` function, for example, works on objects of many different
    classes, from vectors to data frames and statistical models, producing appropriate
    output in each case by way of a class-specific function in the background.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在拟合了一个模型之后，我们可能想要了解它在某些特定变量的范围内产生的估计值，同时将其他协变量保持在其合理的值上。`predict()` 函数是使用模型对象产生此类预测的一种通用方式。在R中，“通用”函数接收它们的输入并将它们传递给后台的更具体函数，这些函数适合与我们所拥有的特定类型的模型对象一起工作。例如，从OLS模型中获取预测值的细节将会有所不同，从逻辑回归中获取预测值。但在每种情况下，我们都可以使用相同的
    `predict()` 函数，同时注意检查文档以了解我们正在使用的模型类型的结果返回形式。R中许多最常用的函数都是这种通用方式。例如，`summary()`
    函数可以处理许多不同类别的对象，从向量到数据框和统计模型，通过后台的特定类函数产生适当的输出。
- en: For `predict()` to calculate the new values for us, it needs some new data to
    fit the model to. We will generate a new data frame whose columns have the same
    names as the variables in the model’s original data, but where the rows have new
    values. A very useful function called `expand.grid()` will help us do this. We
    will give it a list of variables, specifying the range of values we want each
    variable to take. Then `expand.grid()` will generate the will multiply out theThe
    function calculates the cartesian product of the variables given to it. full range
    of values for all combinations of the values we give it, thus creating a new data
    frame with the new data we need.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 `predict()` 为我们计算新值，它需要一些新数据来拟合模型。我们将生成一个新的数据框，其列与模型原始数据中的变量具有相同的名称，但行具有新的值。一个非常有用的函数
    `expand.grid()` 将帮助我们完成这项工作。我们将给它一个变量列表，指定我们想要每个变量取的值范围。然后 `expand.grid()` 将计算给定变量的笛卡尔积，从而生成所有给定值组合的全范围值，创建一个包含所需新数据的新数据框。
- en: In the following bit of code, we use `min()` and `max()` to get the minimum
    and maximum values for per capita GDP, and then create a vector with one hundred
    evenly-spaced elements between the minimum and the maximum. We hold population
    constant at its median, and we let continent take all of its five available values.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们使用 `min()` 和 `max()` 获取人均GDP的最小值和最大值，然后创建一个在最小值和最大值之间有100个等间距元素的向量。我们保持人口数量恒定在其中位数，并让大洲变量取其五个可用的值。
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now we can use `predict()`. If we give the function our new data and model,
    without any further argument, it will calculate the fitted values for every row
    in the data frame. If we specify `interval = 'predict'` as an argument, it will
    calculate 95% prediction intervals in addition to the point estimate.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`predict()`。如果我们给函数提供我们的新数据和模型，而不提供任何其他参数，它将为数据框中的每一行计算拟合值。如果我们指定`interval
    = 'predict'`作为参数，它将除了点估计外，还会计算95%的预测区间。
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Because we know that, by construction, the cases in `pred_df` and `pred_out`
    correspond row for row, we can bind the two data frames together by column. This
    method of joining or merging tables is *definitely not* recommended when you are
    dealing with data.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们知道，根据构造，`pred_df`和`pred_out`中的案例是行与行对应的，我们可以通过列将这两个数据框绑定在一起。当你处理数据时，这种方法连接或合并表**绝对不推荐**。
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The end result is a tidy data frame, containing the predicted values from the
    model for the range of values we specified. Now we can plot the results. Because
    we produced a full range of predicted values, we can decide whether or not to
    use all of them. Here we further subset the predictions to just those for Europe
    and Africa.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是整洁的数据框，包含模型对我们指定的值范围的预测值。现在我们可以绘制结果。因为我们生成了完整的预测值范围，我们可以决定是否使用所有这些值。在这里，我们进一步将预测子集为仅针对欧洲和非洲的预测。
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Figure 6.4: OLS Predictions.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：OLS预测。
- en: '![OLS Predictions.](../Images/0f85fa49f1edb0321e841e4bdd2d20cc.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![OLS预测。](../Images/0f85fa49f1edb0321e841e4bdd2d20cc.png)'
- en: 'We use a new geom here to draw the area covered by the prediction intervals:
    `geom_ribbon()`. It takes an `x` argument like a line, but a `ymin` and `ymax`
    argument as specified in the `ggplot()` aesthetic mapping. This defines the lower
    and upper limits of the prediction interval.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用一个新的几何形状来绘制预测区间所覆盖的区域：`geom_ribbon()`。它像线条一样接受一个`x`参数，但还需要一个`ymin`和`ymax`参数，这些参数在`ggplot()`的美学映射中指定。这定义了预测区间的上下限。
- en: In practice, you may not use `predict()` directly all that often. Instead, you
    might write code using additional libraries that encapsulate the process of producing
    predictions and plots from models. These are especially useful when your model
    is a little more complex and the interpretation of coefficients becomes trickier.
    This happens, for instance, when you have a binary outcome variable and need to
    convert the results of a logistic regression into predicted probabilities, or
    when you have interaction terms amongst your predictions. We will discuss some
    of these helper libraries in the next few sections. However, bear in mind that
    `predict()` and its ability to work safely with different classes of model underpins
    many of those libraries. So it’s useful to see it in action first hand in order
    to understand what it is doing.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你可能不会经常直接使用`predict()`。相反，你可能会编写使用额外库的代码，这些库封装了从模型生成预测和绘图的过程。这些库特别有用，当你模型稍微复杂一些，系数的解释变得困难时。例如，当你有一个二元结果变量，需要将逻辑回归的结果转换为预测概率，或者当你预测中有交互项时。我们将在下一节讨论一些这些辅助库。然而，请记住，`predict()`及其与不同类别的模型安全交互的能力是许多这些库的基础。因此，首先亲自了解它的实际操作是有用的。
- en: 6.5 Tidy model objects with broom
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 使用broom整理模型对象
- en: The `predict` method is very useful, but there are a lot of other things we
    might want to do with our model output. We will use David Robinson’s `broom` package
    to help us out. It is a library of functions that help us get from the model results
    that R generates to numbers that we can plot. It will take model objects and turn
    pieces of them into data frames that you can use easily with ggplot.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`predict`方法非常有用，但我们可能还想用我们的模型输出做很多其他事情。我们将使用David Robinson的`broom`包来帮助我们。这是一个函数库，帮助我们从R生成的模型结果中得到我们可以用于绘图的数字。它将模型对象的一些部分转换成你可以轻松与ggplot一起使用的数据框。'
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Broom takes ggplot’s approach to tidy data and extends it to the model objects
    that R produces. Its methods can tidily extract three kinds of information. First,
    we can see *component-level* information about aspects of the model itself, such
    as coefficients and t-statistics. Second, we can obtain *observation-level* information
    about the model’s connection to the underlying data. This includes the fitted
    values and residuals for each observation in the data. And finally we can get
    *model-level* information that summarizes the fit as a whole, such as an F-statistic,
    the model deviance, or the r-squared. There is a `broom` function for each of
    these tasks.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Broom库采用了ggplot对整洁数据的处理方法，并将其扩展到R生成的模型对象。其方法可以整洁地提取三种类型的信息。首先，我们可以看到模型本身的*组件级*信息，例如系数和t统计量。其次，我们可以获得模型与底层数据连接的*观测级*信息。这包括数据中每个观测值的拟合值和残差。最后，我们可以获取*模型级*信息，它总结了整个拟合，例如F统计量、模型偏差或r平方。对于这些任务，每个都有`broom`函数。
- en: 6.5.1 Get component-level statistics with tidy()
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1 使用tidy()获取组件级统计量
- en: The `tidy()` function takes a model object and returns a data frame of component-level
    information. We can work with this to make plots in a familiar way, and much more
    easily than fishing inside the model object to extract the various terms. Here
    is an example, using the default results as just returned. For a more convenient
    display of the results, we will pipe the object we create with `tidy()` through
    a function that rounds the numeric columns of the data frame to two decimal places.
    This doesn’t change anything about the object itself, of course.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`tidy()`函数接受一个模型对象，并返回一个包含组件级信息的DataFrame。我们可以用这种方式工作，以熟悉的方式制作图表，比在模型对象内部提取各种项要容易得多。以下是一个示例，使用刚刚返回的默认结果。为了更方便地显示结果，我们将使用`tidy()`创建的对象通过一个函数进行管道处理，该函数将DataFrame的数值列四舍五入到两位小数。当然，这不会改变对象本身。'
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We are now able to treat this data frame just like all the other data that we
    have seen so far.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够将这个数据框当作我们迄今为止看到的所有其他数据来处理。
- en: '![Basic plot of OLS estimates.](../Images/86cb8182688f582ab5bf93d7c02069cb.png)
    Figure 6.5: Basic plot of OLS estimates.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![OLS估计的基本图表](../Images/86cb8182688f582ab5bf93d7c02069cb.png) 图6.5：OLS估计的基本图表。'
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can extend and clean up this plot in a variety of ways. For example, we can
    tell `tidy()` to calculate confidence intervals for the estimates, using R’s `confint()`
    function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用各种方式扩展和清理这个图表。例如，我们可以告诉`tidy()`使用R的`confint()`函数计算估计值的置信区间。
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The convenience “not in” operator `%nin%` is available via the `socviz` library.
    It does the opposite of `%in%` and selects only the items in a first vector of
    characters that are not in the second. We’ll use it to drop the intercept term
    from the table. We also want to something about the labels. When fitting a model
    with categorical variables, R will create coefficient names based on the variable
    name and the category name, like `continentAmericas`. Normally we like to clean
    these up before plotting. Most commonly, we just want to strip away the variable
    name at the beginning of the coefficient label. For this we can use `prefix_strip()`,
    a convenience function in the `socviz` library. We tell it which prefixes to drop,
    using it to create a new column variable in `out_conf` that corresponds to the
    `terms` column, but that has nicer labels.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`socviz`库提供的便利“不在”操作符`%nin%`，我们可以选择仅包含在第一个字符向量中且不在第二个中的项目。我们将使用它从表中删除截距项。我们还想对标签做一些处理。当用分类变量拟合模型时，R会根据变量名和类别名创建系数名称，例如`continentAmericas`。通常，我们希望在绘图之前清理这些名称。最常见的情况是我们只想去除系数标签开头的变量名。为此，我们可以使用`socviz`库中的便利函数`prefix_strip()`。我们告诉它要去除哪些前缀，使用它来在`out_conf`中创建一个新列变量，该变量对应于`terms`列，但具有更好的标签。
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now we can use `geom_pointrange()` to make a figure that displays some information
    about our confidence in the variable estimates, as opposed to just the coefficients.
    As with the boxplots earlier, we use `reorder()` to sort the names of the model’s
    terms by the `estimate` variable, thus arranging our plot of effects from largest
    to smallest in magnitude.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`geom_pointrange()`制作一个显示我们对变量估计的信心信息的图表，而不仅仅是系数。与之前的箱线图一样，我们使用`reorder()`按`estimate`变量对模型的项名进行排序，从而按效应的大小从大到小排列我们的图表。
- en: '![A nicer plot of OLS estimates and confidence intervals.](../Images/388eb72c4d668c76c8c461f3b459c1de.png)
    Figure 6.6: A nicer plot of OLS estimates and confidence intervals.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![OLS 估计和置信区间的更漂亮的图。](../Images/388eb72c4d668c76c8c461f3b459c1de.png) 图 6.6：OLS
    估计和置信区间的更漂亮的图。'
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Dotplots of this kind can be very compact. The vertical axis can often be compressed
    quite a bit, with no loss in comprehension. In fact, they are often easier to
    read with much less room between the rows than given by a default square shape.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的点图可以非常紧凑。垂直轴通常可以压缩很多，而不会影响理解。事实上，它们通常在行与行之间有更少的间隔时更容易阅读，比默认的方形形状给出的间隔要小得多。
- en: 6.5.2 Get observation-level statistics with augment()
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.2 使用 augment() 获取观测级统计信息
- en: 'The values returned by `augment()` are all statistics calculated at the level
    of the original observations. As such, they can be added on to the data frame
    that the model is based on. Working from a call to `augment()` will return a data
    frame with all the original observations used in the estimation of the model,
    together with columns like the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`augment()` 返回的值都是计算在原始观测水平上的统计数据。因此，它们可以添加到模型基于的数据框中。从 `augment()` 的调用开始工作将返回一个数据框，其中包含用于模型估计的所有原始观测值，以及以下列：'
- en: '`.fitted` — The fitted values of the model.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.fitted` — 模型的拟合值。'
- en: '`.se.fit` — The standard errors of the fitted values.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.se.fit` — 拟合值的标准误差。'
- en: '`.resid` — The residuals.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.resid` — 残差。'
- en: '`.hat` — The diagonal of the hat matrix.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.hat` — 帽矩阵的对角线。'
- en: '`.sigma` — An estimate of residual standard deviation when the corresponding
    observation is dropped from the model.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.sigma` — 当从模型中删除相应的观测值时，残差标准差的估计。'
- en: '`.cooksd` — Cook’s distance, a common regression diagnostic; and'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.cooksd` — Cook 距离，一个常见的回归诊断；以及'
- en: '`.std.resid` — The standardized residuals.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.std.resid` — 标准化残差。'
- en: Each of these variables is named with a leading dot, for example `.hat` rather
    than `hat`, and so on. This is to guard against accidentally confusing it with
    (or accidentally overwriting) an existing variable in your data with this name.
    The columns of values return will differ slightly depending on the class of model
    being fitted.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些变量都以一个前置点命名，例如 `.hat` 而不是 `hat`，依此类推。这样做是为了防止意外将其与（或意外覆盖）具有相同名称的现有变量混淆。返回的值列将根据所拟合的模型类别略有不同。
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'By default, `augment()` will extract the available data from the model object.
    This will usually include the variables used in the model itself, but not any
    additional ones contained in the original data frame. Sometimes it is useful to
    have these. We can add them by specifying the `data` argument:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`augment()` 将从模型对象中提取可用的数据。这通常包括模型本身使用的变量，但不包括原始数据框中包含的任何附加变量。有时这些变量是有用的。我们可以通过指定
    `data` 参数来添加它们：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If some rows containing missing data were dropped to fit the model, then these
    will not be carried over to the augmented data frame.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为了拟合模型而删除了一些包含缺失数据的行，那么这些行将不会传递到增强数据框中。
- en: The new columns created by `augment()` can be used to create some standard regression
    plots. For example, we can plot the residuals versus the fitted values. Figure
    [6.7](modeling.html#fig:ch-06-augresid) suggests, unsurprisingly, that our country-year
    data has rather more structure than is captured by our OLS model.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`augment()` 创建的新列可以用来创建一些标准的回归图。例如，我们可以绘制残差与拟合值的关系图。图 [6.7](modeling.html#fig:ch-06-augresid)
    建议的是，不出所料，我们的国家-年数据比我们的 OLS 模型所捕捉的结构要复杂得多。'
- en: '![Residuals vs Fitted Values.](../Images/43cf2a062d66ee897fa121dbf99503c9.png)
    Figure 6.7: Residuals vs Fitted Values.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![残差与拟合值。](../Images/43cf2a062d66ee897fa121dbf99503c9.png) 图 6.7：残差与拟合值。'
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 6.5.3 Get model-level statistics with glance()
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.3 使用 glance() 获取模型级统计信息
- en: This function organizes the information typically presented at the bottom of
    a model’s `summary()` output. By itself, it usually just returns a table with
    a single row in it. But as we shall see in a moment, the real power of `broom`’s
    approach is the way that it can scale up to cases where we are grouping or subsampling
    our data.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数组织通常在模型 `summary()` 输出底部呈现的信息。它本身通常只返回一个包含单行的表格。但正如我们很快将看到的，`broom` 方法真正的力量在于它能够扩展到我们对数据进行分组或子采样的情况。
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Broom is able to tidy (and augment, and glance at) a wide range of model types.
    Not all functions are available for all classes of model. Consult broom’s documentation
    for more details on what is available. For example, here is a plot created from
    the tidied output of an event-history analysis. First we generate a Cox proportional
    hazards model of some survival data.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Broom 能够整理（以及增强和浏览）广泛的模型类型。并非所有函数都适用于所有模型类别。有关可用性的更多详细信息，请参阅 broom 的文档。例如，这里是一个从事件历史分析的整理输出创建的图表。首先，我们生成一些生存数据的
    Cox 比例风险模型。
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The details of the fit are not important here, but in the first step the `Surv()`
    function creates the response or outcome variable for the proportional hazards
    model that is then fitted by the `coxph()` function. Then the `survfit()` function
    creates the survival curve from the model, much like we used `predict()` to generate
    predicted values earlier. Try `summary(out_cph)` to see the model, and `summary(out_surv)`
    to see the table of predicted values that will form the basis for our plot. Next
    we tidy `out_surv` to get a data frame, and plot it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，拟合的细节并不重要，但在第一步中，`Surv()` 函数创建了比例风险模型的响应或结果变量，然后由 `coxph()` 函数进行拟合。然后，`survfit()`
    函数从模型中创建生存曲线，就像我们之前使用 `predict()` 生成预测值一样。尝试 `summary(out_cph)` 来查看模型，以及 `summary(out_surv)`
    来查看将构成我们绘图基础的预测值表。接下来，我们将 `out_surv` 整理成数据框，并绘制它。
- en: '![A Kaplan-Meier plot.](../Images/1e961d36cc805682f5590795a7c245a4.png) Figure
    6.8: A Kaplan-Meier plot.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![Kaplan-Meier 图。](../Images/1e961d36cc805682f5590795a7c245a4.png) 图 6.8：Kaplan-Meier
    图。'
- en: '[PRE35]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 6.6 Grouped analysis and list columns
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 分组分析和列表列
- en: Broom makes it possible to quickly fit models to different subsets of your data
    and get consistent and usable tables of results out the other end. For example,
    let’s say we wanted to look at the gapminder data by examining the relationship
    between life expectancy and GDP by *continent*, for each year in the data.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Broom 使得能够快速将模型拟合到数据的不同子集，并从另一端获得一致且可用的结果表。例如，假设我们想通过检查预期寿命和 GDP 之间的关系来查看 gapminder
    数据，对于数据中的每一年，按大陆进行。
- en: 'The `gapminder` data is at bottom organized by country-years. That is the unit
    of observation in the rows. If we wanted, we could take a slice of the data manually,
    such as “all countries observed in Asia, in 1962” or “all in Africa, 2002”. Here
    is “Europe, 1977”:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`gapminder` 数据在底部按国家-年份组织。这是行中的观测单位。如果我们愿意，我们可以手动截取数据的一部分，例如“1962年观察到的所有亚洲国家”或“2002年的所有非洲国家”。这里是“欧洲，1977年”：'
- en: '[PRE36]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We could then see what the relationship between life expectancy and GDP looked
    like for that continent-year group:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看该大陆-年份组预期寿命和 GDP 之间的关系：
- en: '[PRE37]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'With `dplyr` and `broom` we can do this for every continent-year slice of the
    data in a compact and tidy way. We start with our table of data, and then (`%>%`)
    group the countries by `continent` and `year` using the `group_by()` function.
    We introduced this grouping operation in Chapter [4](groupfacettx.html#groupfacettx).
    Our data is reorganized first by continent, and within continent by year. Here
    we will take one further step and *nest* the data that make up each group:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dplyr` 和 `broom`，我们可以以紧凑和整洁的方式对数据中的每个大陆-年份切片进行操作。我们从一个数据表开始，然后使用 `group_by()`
    函数按 `continent` 和 `year` 对国家进行分组。我们在第 [4](groupfacettx.html#groupfacettx) 章节中介绍了这种分组操作。我们的数据首先按大陆重新组织，然后在大陆内部按年份。这里我们将采取进一步的一步，*嵌套*
    构成每个组的数据：
- en: '[PRE39]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Think of what `nest()` does as a more intensive version what `group_by()` does.
    The resulting object is has the tabular form we expect (it is a tibble) but it
    looks a little unusual. The first two columns are the familiar `continent` and
    `year`. But we now also have a new column, `data`, that contains a small table
    of data corresponding to each continent-year group. This is a *list column*, something
    we have not seen before. It turns out to be very useful for bundling together
    complex objects (structured, in this case, as a list of tibbles, each being a
    33x4 table of data) within the rows of our data (which remains tabular). Our “Europe
    1977” fit is in there. We can look at it, if we like, by filtering the data and
    then *unnesting* the list column.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `nest()` 的作用视为 `group_by()` 的更加强化的版本。结果对象具有我们期望的表格形式（它是一个 tibble），但看起来有些不寻常。前两列是熟悉的
    `continent` 和 `year`。但我们现在还有一个新的列，`data`，它包含对应于每个 continent-year 组的小型数据表。这是一个
    *列表列*，我们之前没有见过。它被证明在将复杂对象（在这种情况下，作为 tibbles 的列表，每个都是一个 33x4 的数据表）捆绑到我们的数据行（保持表格形式）中非常有用。我们的“欧洲
    1977”拟合就在其中。如果我们愿意，可以通过过滤数据然后 *解包* 列表列来查看它。
- en: '[PRE41]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: List columns are useful because we can act on them in a compact and tidy way.
    In particular, we can pass functions along to each row of the list column and
    make something happen. For example, a moment ago we ran a regression of life expectancy
    and logged GDP for European countries in 1977\. We can do that for every continent-year
    combination in the data. We first create a convenience function called `fit_ols()`
    that takes a single argument, `df` (for data frame) and that fits the linear model
    we are interested in. ThenThe map action is an important idea in functional programming.
    If you have written code in other, more imperative languages you can think of
    it as a compact alternative to writing for … next loops. You can of course write
    loops like this in R. Computationally they are often not any less efficient than
    their functional alternatives. But mapping functions to arrays is more easily
    integrated into a sequence of data transformations. we *map* that function to
    each of our list column rows in turn. Recall from Chapter [4](groupfacettx.html#groupfacettx)
    that `mutate` creates new variables or columns on the fly within a pipeline.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表列是有用的，因为我们可以在紧凑且整洁的方式上对其采取行动。特别是，我们可以将函数传递给列表列的每一行，并使其发生一些事情。例如，刚才我们运行了1977年欧洲国家的预期寿命和对数GDP的回归。我们可以对数据中的每个大陆-年份组合都这样做。我们首先创建了一个名为`fit_ols()`的便利函数，它接受一个单一参数`df`（代表数据框）并拟合我们感兴趣的线性模型。然后，映射操作是函数式编程中的一个重要思想。如果你在其他更命令式的语言中编写过代码，你可以将其视为编写for
    … next循环的紧凑替代方案。当然，你可以在R中编写这样的循环。在计算上，它们通常并不比它们的函数式替代方案效率低。但是，将函数映射到数组中更容易集成到一系列数据转换中。我们将该函数依次映射到我们的列表列的每一行。回想一下，在第[4](groupfacettx.html#groupfacettx)章中，`mutate`函数在管道中动态创建新变量或列。
- en: '[PRE43]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Before starting the pipeline we create a new function: It is a convenience
    function whose only job is to estimate a particular OLS model on some data. Like
    almost everything in R, functions are a kind of object. To make a new one, we
    use the slightly special `function()` function. (Nerds love that sort of thing.)
    There is a little more detail on creating functions in the Appendix. To see what
    `fit_ols()` looks like once it is created, type `fit_ols` without parentheses
    at the Console. To see what it does, try `fit_ols(df = gapminder)`, or `summary(fit_ols(gapminder))`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始管道之前，我们创建了一个新函数：这是一个便利函数，它的唯一任务是估计某些数据上的特定OLS模型。像R中的几乎所有东西一样，函数是一种对象。要创建一个新的函数，我们使用稍微特殊的`function()`函数。（极客们喜欢这类东西。）附录中有更多关于创建函数的细节。要查看创建后的`fit_ols()`函数的样子，请在控制台输入`fit_ols`而不带括号。要查看它做什么，尝试`fit_ols(df
    = gapminder)`或`summary(fit_ols(gapminder))`。
- en: 'Now we have two list columns: `data`, and `model`. The latter was created by
    mapping the `fit_ols()` function to each row of `data`. Inside each element of
    `model` is a linear model for that continent-year. So we now have sixty OLS fits,
    one for every continent-year grouping. Having the models inside the list column
    is not much use to us in and of itself. But we can extract the information we
    want while keeping things in a tidy tabular form. For clarity we will run the
    pipeline from the beginning again, this time adding a few new steps.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个列表列：`data`和`model`。后者是通过将`fit_ols()`函数映射到`data`的每一行创建的。`model`中的每个元素都是该大陆-年份的线性模型。因此，我们现在有六十个OLS拟合，每个大陆-年份分组一个。将模型放入列表列本身对我们并没有太大的帮助。但我们可以提取我们想要的信息，同时保持整洁的表格形式。为了清晰起见，我们将从开始再次运行管道，这次添加一些新步骤。
- en: First we extract summary statistics from each model by mapping the `tidy()`
    function from broom to the model list column. Then we unnest the result, dropping
    the other columns in the process. Finally, we filter out all the Intercept terms,
    and also drop all observations from Oceania. In the case of the Intercepts we
    do this just out of convenience. Oceania we drop just because there are so few
    observations. We put the results in an object called `out_tidy`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过将`tidy()`函数从broom映射到模型列表列，从每个模型中提取汇总统计量。然后，我们展开结果，在此过程中删除其他列。最后，我们过滤掉所有截距项，并删除来自大洋洲的所有观测值。在截距的情况下，我们这样做只是为了方便。我们删除大洋洲的数据，只是因为那里观测值很少。我们将结果放入一个名为`out_tidy`的对象中。
- en: '[PRE45]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We now have tidy regression output with an estimate of the association between
    log GDP per capita and life expectancy for each year, within continents. We can
    plot these estimates in a way that takes advantage of their groupiness.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了整洁的回归输出，其中包含了每年大陆间人均GDP对寿命的关联估计。我们可以以利用其分组特性的方式绘制这些估计值。
- en: '[PRE47]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![Yearly estimates of the association between GDP and Life Expectancy, pooled
    by continent.](../Images/23ad9adc4c5e240c3e5b24eb5be2ec2f.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![按大洲汇总的GDP与预期寿命之间的年度估计图](../Images/23ad9adc4c5e240c3e5b24eb5be2ec2f.png)'
- en: 'Figure 6.9: Yearly estimates of the association between GDP and Life Expectancy,
    pooled by continent.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：按大洲汇总的GDP与预期寿命之间的年度估计。
- en: The call to `position_dodge()` within `geom_pointrange()` allows the point ranges
    for each continent to be near each other within years, instead of being plotted
    right on top of one another. We could have faceted the results by continent, but
    doing it this way lets us see differences in the yearly estimates much more easily.
    This technique is very useful not just for cases like this, but also when you
    want to compare the coefficients given by different kinds of statistical model.
    This sometimes happens when we’re interested in seeing how, say, OLS performs
    against some other model specification.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在`geom_pointrange()`中调用`position_dodge()`允许每个大洲的点范围在年份内彼此靠近，而不是直接重叠在一起。我们本可以通过大洲进行分面，但这样做可以让我们更容易地看到年度估计的差异。这种技术不仅对这种案例非常有用，而且在你想比较不同类型的统计模型给出的系数时也非常有用。当我们对比较，比如说，OLS与其他模型规格的表现感兴趣时，这种情况有时会发生。
- en: 6.7 Plot marginal effects
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7 绘制边际效应
- en: Our earlier discussion of `predict()` was about obtaining estimates of the average
    effect of some coefficient, net of the other terms in the model. Over the past
    decade, estimating and plotting *partial* or *marginal effects* from a model has
    become an increasingly common way of presenting accurate and interpretively useful
    predictions. Interest in marginal effects plots was stimulated by the realization
    that the interpretation of terms in logistic regression models, in particular,
    was trickier than it seemed—especially when there were interaction terms in the
    model (Ai & Norton, 2003). Thomas Leeper’s `margins` package can make these plots
    for us.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前关于`predict()`的讨论是关于获得模型中某些系数的平均效应估计，扣除模型中的其他项。在过去十年中，从模型中估计和绘制*部分*或*边际效应*已成为一种越来越常见的准确和具有解释性预测的展示方式。边际效应图的热潮是由意识到逻辑回归模型中的项的解释比看起来要复杂得多的认识所激发的——特别是在模型中有交互项时（Ai
    & Norton, 2003）。托马斯·利珀的`margins`包可以为我们绘制这些图。
- en: '[PRE48]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: To see it in action, we’ll take another look at the General Social Survey data
    in `gss_sm`, this time focusing on the binary variable, `obama`.As is common with
    retrospective questions on elections, rather more people claim to have voted for
    Obama than is consistent with the vote share he received in the election. It is
    coded `1` if the respondent said they voted for Barack Obama in the 2012 presidential
    election, and `0` otherwise. In this case, mostly for convenience here, the zero
    code includes all other answers to the question, including those who said they
    voted for Mitt Romney, those who said they did not vote, those who refused to
    answer, and those who said they didn’t know who they voted for. We will fit a
    logistic regression on `obama`, with `age`, `polviews`, `race`, and `sex` as the
    predictors. The `age` variable is the respondent’s age in years. The `sex` variable
    is coded as “Male” or “Female” with “Male” as the reference category. The `race`
    variable is coded as “White”, “Black”, or “Other” with “White” as the reference
    category. The `polviews` measure is a self-reported scale of the respondent’s
    political orientation from “Extremely Conservative” through “Extremely Liberal”,
    with “Moderate” in the middle. We take `polviews` and create a new variable, `polviews_m`,
    using the `relevel()` function to recode “Moderate” to be the reference category.
    We fit the model with the `glm()` function, and specify an interaction between
    `race` and `sex`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到它的实际应用，我们将再次查看`gss_sm`中的综合社会调查数据，这次重点关注二元变量`obama`。与选举的回顾性问题一样，声称投票给奥巴马的人数比他在选举中获得的选票份额要多得多。如果受访者表示他们在2012年总统选举中投票给了巴拉克·奥巴马，则编码为`1`，否则为`0`。在这种情况下，主要是为了方便，零编码包括所有其他问题的答案，包括表示他们投票给了米特·罗姆尼的人，表示他们没有投票的人，拒绝回答的人，以及表示他们不知道自己投给了谁的人。我们将对`obama`进行逻辑回归，以`age`、`polviews`、`race`和`sex`作为预测变量。`age`变量是受访者的年龄（以年为单位）。`sex`变量编码为“Male”或“Female”，其中“Male”为参考类别。`race`变量编码为“White”、“Black”或“Other”，其中“White”为参考类别。`polviews`衡量标准是受访者政治倾向的自我报告量表，从“极端保守”到“极端自由”，中间为“Moderate”。我们使用`polviews`并创建一个新的变量`polviews_m`，使用`relevel()`函数将“Moderate”重新编码为参考类别。我们使用`glm()`函数拟合模型，并指定`race`和`sex`之间的交互作用。
- en: '[PRE49]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The summary reports the coefficients and other information. We can now graph
    the data in any one of several ways. Using `margins()` we calculate the marginal
    effects for each variable:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要报告了系数和其他信息。我们现在可以用几种方式中的任何一种来绘制数据。使用`margins()`我们计算每个变量的边际效应：
- en: '[PRE51]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `margins` library comes with several plot methods of its own. If you wish,
    at this point you can just try `plot(bo_m)` to see a plot of the average marginal
    effects, produced with the general look of a Stata graphic. Other plot methods
    in the `margins` library include `cplot()`, which visualizes marginal effects
    conditional on a second variable, and `image()`, which shows predictions or marginal
    effects as a filled heatmap or contour plot.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`margins`库自带几种绘图方法。如果你愿意，现在你可以尝试`plot(bo_m)`来查看平均边际效应的图，其外观类似于Stata图形。`margins`库中的其他绘图方法包括`cplot()`，它根据第二个变量可视化边际效应，以及`image()`，它显示预测或边际效应作为填充热图或等高线图。'
- en: Alternatively, we can take results from `margins()` and plot them ourselves.
    To clean up the summary a little a little, we convert it to a tibble, then use
    `prefix_strip()` and `prefix_replace()` to tidy the labels. We want to strip the
    `polviews_m` and `sex` prefixes, and (to avoid ambiguity about “Other”), adjust
    the `race` prefix.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以自己绘制`margins()`的结果。为了稍微整理一下摘要，我们将其转换为tibble，然后使用`prefix_strip()`和`prefix_replace()`来整理标签。我们想要去除`polviews_m`和`sex`的前缀，并且（为了避免关于“Other”的歧义），调整`race`的前缀。
- en: '[PRE53]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now we have a table that we can plot as we have learned:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个表格，我们可以像我们学过的那样绘制：
- en: '[PRE55]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Figure 6.10: Average marginal effects plot.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10：平均边际效应图。
- en: '![Average marginal effects plot.](../Images/2dd558be4bdff7c74737e947984bbc4f.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![平均边际效应图。](../Images/2dd558be4bdff7c74737e947984bbc4f.png)'
- en: 'If we are just interested in getting conditional effects for a particular variable,
    then conveniently we can ask the plot methods in the margins library to do the
    work calculating effects for us but without drawing their plot. Instead, they
    can return the results in a format we can easily use in ggplot, and with less
    need for clean up, for the clean-up. For example, with `cplot()`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想获取特定变量的条件效应，那么方便的是我们可以要求margins库中的绘图方法为我们计算效应，但不需要绘制它们的图。相反，它们可以以我们可以在ggplot中轻松使用的格式返回结果，并且不需要太多清理工作。例如，使用`cplot()`：
- en: '![Conditional effects plot.](../Images/8ac0e7da6d09561016fd87ab560c2c2a.png)
    Figure 6.11: Conditional effects plot.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![条件效应图。](../Images/8ac0e7da6d09561016fd87ab560c2c2a.png) 图6.11：条件效应图。'
- en: '[PRE56]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The margins package is under active development. It can do much more than described
    here. The vignettes that come with the package provide more extensive discussion
    and numerous examples.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`margins`包正在积极开发中。它能够做到比这里描述的更多。该包附带的小节提供了更广泛的讨论和许多示例。'
- en: 6.8 Plots from complex surveys
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.8 复杂调查的图
- en: Social scientists often work with data collected using a complex survey design.
    Survey instruments may be stratified by region or some other characteristic, contain
    replicate weights to make them comparable to a reference population, have a clustered
    structure, and so on. In Chapter [4](groupfacettx.html#groupfacettx) we learned
    how calculate and then plot frequency tables of categorical variables, using some
    data from the General Social Survey (GSS). However, if we want accurate estimates
    of US households from the GSS, we will need to take the survey’s design into account,
    and use the survey weights provided in the dataset. Thomas Lumley’s `survey` library
    provides a comprehensive set of tools for addressing these issues. The tools and
    the theory behind them are discussed in detail in Lumley (2010), and an overview
    of the package is provided in Lumley (2004). While the functions in the `survey`
    package are straightforward to use and return results in a generally tidy form,
    the package predates the tidyverse and its conventions by several years. This
    means we cannot use `survey` functions directly with `dplyr`. However, Greg Freedman
    Ellis has written a helper package, `srvyr`, that solves this problem for us,
    and lets us use the `survey` library’s functions within a data analysis pipeline
    in a familiar way.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 社会科学家经常使用复杂调查设计收集的数据。调查工具可能按地区或其他特征分层，包含复杂数据以使其与参考人口可比，具有集群结构，等等。在第[4](groupfacettx.html#groupfacettx)章中，我们学习了如何使用来自综合社会调查（GSS）的一些数据计算并绘制分类变量的频率表。然而，如果我们想从GSS中获得美国家庭的准确估计，我们需要考虑调查的设计，并使用数据集中提供的调查权重。托马斯·卢米利的`survey`库提供了一套全面的工具来解决这些问题。这些工具及其背后的理论在卢米利（2010）中进行了详细讨论，而在卢米利（2004）中提供了该包的概述。虽然`survey`包中的函数使用简单，并以整洁的形式返回结果，但该包比tidyverse及其惯例早几年。这意味着我们不能直接使用`survey`函数与`dplyr`一起使用。然而，格雷格·弗里德曼·埃利斯编写了一个辅助包`srvyr`，为我们解决了这个问题，并允许我们在熟悉的数据分析管道中使用`survey`库的函数。
- en: For example, the `gss_lon` data contains a small subset of measures from every
    wave of the GSS since its inception in 1972\. It also contains several variables
    that describe the design of the survey and provide replicate weights for observations
    in various years. These technical details are described in the GSS documentation.
    Similar information is typically provided by other complex surveys. Here we will
    use this design information to calculate weighted estimates of the distribution
    of educational attainment by race, for selected survey years from 1976 to 2016.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`gss_lon`数据包含自1972年成立以来GSS每一波次的一小部分测量值。它还包含几个描述调查设计并提供各种年份观测值复杂数据的变量。这些技术细节在GSS文档中有描述。类似的信息通常由其他复杂调查提供。在这里，我们将使用这些设计信息来计算1976年至2016年选定调查年份的教育成就分布的加权估计。
- en: To begin, we load the `survey` and `srvyr` libraries.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们加载`survey`和`srvyr`库。
- en: '[PRE57]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Next, we take our `gss_lon` dataset and use the `survey` tools to create a
    new object that contains the data, as before, but with some additional information
    about the survey’s design:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`gss_lon`数据集，并利用`survey`工具创建一个新的对象，其中包含数据，就像之前一样，但增加了关于调查设计的额外信息：
- en: '[PRE58]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The two `options` set at the beginning provide some information to the `survey`
    library about how to behave. You should consult Lumley (2010) and the `survey`
    package documentation for details. The subsequent operations create `gss_wt`,
    an object with one additional column (`stratvar`), describing the yearly sampling
    strata. We use the `interaction()` function to do this. It multiplies the `vstrat`
    variable by the `year` variable to get a vector of stratum information for each
    year.We have to do this because of the way the GSS codes its stratum information.
    In the next step, we use the `as_survey_design()` function to add the key pieces
    of information about the survey design. It adds information about the sampling
    identifiers (`ids`), the strata (`strata`), and the replicate weights (`weights`).
    With those in place we can take advantage of a large number of specialized functions
    in the `survey` library that allow us to calculate properly weighted survey means
    or estimate models with the correct sampling specification. For example, we can
    easily calculate the distribution of education by race for a series of years from
    1976 to 2016\. We use `survey_mean()` to do this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时设置的两种 `options` 为 `survey` 库提供了有关如何行为的一些信息。您应该查阅 Lumley (2010) 和 `survey`
    包文档以获取详细信息。后续操作创建了一个名为 `gss_wt` 的对象，它有一个额外的列（`stratvar`），描述了每年的抽样层。我们使用 `interaction()`
    函数来完成此操作。它将 `vstrat` 变量乘以 `year` 变量，以获取每年层信息的向量。我们必须这样做，因为 GSS 对其层信息进行编码的方式。在下一步中，我们使用
    `as_survey_design()` 函数添加有关调查设计的关键信息。它添加有关抽样标识符（`ids`）、层（`strata`）和重复权重（`weights`）的信息。有了这些信息，我们可以利用
    `survey` 库中的大量专用函数，这些函数允许我们正确计算加权调查均值或使用正确的抽样规范估计模型。例如，我们可以轻松地计算从 1976 年到 2016
    年的一系列年份中按种族划分的教育分布。我们使用 `survey_mean()` 来完成此操作：
- en: '[PRE59]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The results returned in `out_grp` include standard errors. We can also ask `survey_mean()`
    to calculate confidence intervals for us, if we wish.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 `out_grp` 的结果包括标准误差。如果我们愿意，也可以要求 `survey_mean()` 为我们计算置信区间。
- en: 'Grouping with `group_by()` lets us calculate counts or means for the innermost
    variable, grouped by the next variable “up” or “out”, in this case, `degree` by
    `race`, such that the proportions for `degree` will sum to one for each group
    in `race`, and this will be done separately for each value of `year`. If we want
    the *marginal* frequencies, such that the values for all combinations of `race`
    and `degree` sum to one within each year, we first have to interact the variables
    we are cross-classifying. Then we group by the new interacted variable and do
    the calculation as before:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `group_by()` 进行分组允许我们计算最内层变量的计数或平均值，按下一个变量“向上”或“向外”分组，在这种情况下，按 `degree` 和
    `race` 分组，这样 `degree` 的比例将对于 `race` 中的每个组加起来等于一，并且对于 `year` 的每个值都将单独完成。如果我们想要边际频率，即所有
    `race` 和 `degree` 组合的值在每年内加起来等于一，我们首先必须交叉分类变量。然后按新的交互变量进行分组，并像以前一样进行计算：
- en: '[PRE61]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This gives us the numbers that we want and returns them in a tidy data frame.
    The `interaction()` function produces variable labels that are a compound of the
    two variables we interacted, with each combination of categories separated by
    a period, (such as `White.Graduate`. However, perhaps we would like to see these
    categories as two separate columns, one for race and one for education, as before.
    Because the variable labels are organized in a predictable way, we can use one
    of the convenient functions in the tidyverse’s `tidyr` library to separate the
    single variable into two columns while correctly preserving the row values. Appropriately,
    this function is called `separate()`.The two backslashes before the period in
    the call to `separate` are necessary for R to interpret it literally as a period.
    By default in search and replace operations like this, the search terms are regular
    expressions. The period acts as a special character, a kind of wildcard, meaning
    ‘any character at all’. To make the regular expression engine treat it literally,
    we add one backslash before it. The backslash is an ‘escape’ character. It means
    ‘The next character is going to be treated differently from usual’. However, because
    the backslash is a special character as well, we need to add a second backslash
    to make sure the parser sees it properly.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了我们想要的数字，并以整洁的数据框形式返回。`interaction()` 函数生成的变量标签是由我们交互的两个变量的复合体，每个类别的组合由一个句点分隔（例如
    `White.Graduate`。然而，也许我们希望将这些类别视为两个单独的列，一个用于种族，一个用于教育，就像之前一样。因为变量标签是有序组织的，我们可以使用
    tidyverse 的 `tidyr` 库中的一个方便的函数将单个变量分离成两列，同时正确地保留行值。恰当地，这个函数被称为 `separate()`。在
    `separate` 函数调用中，句点前的两个反斜杠对于 R 将其字面地解释为句点来说是必要的。在默认的搜索和替换操作中，搜索项是正则表达式。句点作为一个特殊字符，一种通配符，意味着“任何字符”。为了使正则表达式引擎将其字面地处理，我们在其前面添加一个反斜杠。反斜杠是一个“转义”字符。它的意思是“下一个字符将被以不同于通常的方式处理”。然而，因为反斜杠本身也是一个特殊字符，我们需要添加第二个反斜杠以确保解析器正确地看到它。
- en: '[PRE63]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The call to `separate()` says to take the `racedeg` column, split each value
    when it sees a period, and reorganize the results into two columns, `race` and
    `degree`. This gives us a tidy table much like `out_grp`, but for the marginal
    frequencies.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`separate()` 函数的调用表示取 `racedeg` 列，在看到句点时分割每个值，并将结果重新组织成两列，`race` 和 `degree`。这给我们一个整洁的表格，类似于
    `out_grp`，但用于边际频率。'
- en: Reasonable people can disagree over how best to plot a small multiple of a frequency
    table while faceting by year, especially when there is some measure of uncertainty
    attached. A barplot is the obvious approach for a single case, but when there
    are many years it can become difficult to compare bars across panels. This is
    especially the case when standard errors or confidence intervals are used in conjunction
    with bars.Sometimes it may be preferable to show that the underlying variable
    is categorical, as a bar chart makes clear, and not continuous, as a line graph
    suggests. Here the trade-off is in favor of the line graphs as the bars are very
    hard to compare across facets. This is sometimes called a “dynamite plot”, not
    because it looks amazing but because the t-shaped error bars on the tops of the
    columns make them look like cartoon dynamite plungers. An alternative is to use
    a line graph to join up the time observations, faceting on educational categories
    instead of year. Figure [6.12](modeling.html#fig:ch-06-svyyears) shows the results
    for our GSS data in dynamite-plot form, where the error bars are defined as twice
    the standard error in either direction around the point estimate.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 合理的人可以在如何最好地通过按年份分面来绘制频率表的小倍数上存在分歧，尤其是在有一些不确定性度量附加的情况下。条形图对于单个案例来说是一个明显的途径，但当有很多年时，比较面板中的条形可能会变得困难。这尤其当标准误差或置信区间与条形一起使用时。有时，可能更倾向于显示基础变量是分类的，就像条形图所清楚显示的那样，而不是连续的，就像线图所暗示的那样。在这里，权衡有利于线图，因为条形在分面之间很难比较。这有时被称为“炸药图”，不是因为它看起来很棒，而是因为柱顶的
    T 形误差条使它们看起来像卡通炸药筒。一个替代方案是使用线图连接时间观察结果，分面在教育类别而不是年份上。图 [6.12](modeling.html#fig:ch-06-svyyears)
    显示了我们的 GSS 数据以炸药图形式的结果，其中误差条定义为点估计周围两个方向的标准误差的两倍。
- en: '[PRE65]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Figure 6.12: Weighted estimates of educational attainment for Whites and Blacks,
    GSS selected years 1976-2016\. Faceting barplots is often a bad idea, and the
    more facets there are the worse an idea it is. With a small-multiple plot the
    viewer wants to compare across panels (in this case, over time), but this is difficult
    to do when the data inside the panels are categorical comparisons shown as bars
    (in this case, education level by group).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12：白人和黑人的教育成就加权估计，GSS选定年份1976-2016。分面条形图通常不是一个好主意，分面越多，这个主意就越糟糕。在小倍数图中，观众想要比较各面板之间的差异（在这种情况下，随时间变化），但当面板内的数据是作为条形图显示的类别比较时（在这种情况下，按群体划分的教育水平），这很难做到。
- en: '![Weighted estimates of educational attainment for Whites and Blacks, GSS selected
    years 1976-2016\. Faceting barplots is often a bad idea, and the more facets there
    are the worse an idea it is. With a small-multiple plot the viewer wants to compare
    across panels (in this case, over time), but this is difficult to do when the
    data inside the panels are categorical comparisons shown as bars (in this case,
    education level by group).](../Images/1fe47b8275a8fdedb0c705fdb59bee6a.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![白人和黑人的教育成就加权估计，GSS选定年份1976-2016。分面条形图通常不是一个好主意，分面越多，这个主意就越糟糕。在小倍数图中，观众想要比较各面板之间的差异（在这种情况下，随时间变化），但当面板内的数据是作为条形图显示的类别比较时（在这种情况下，按群体划分的教育水平），这很难做到。](../Images/1fe47b8275a8fdedb0c705fdb59bee6a.png)'
- en: This plot has a few cosmetic details and adjustments that we will learn more
    about in Chapter [8](refineplots.html#refineplots). As before, I encourage you
    to peel back the plot from the bottom, one instruction at a time, to see what
    changes. One useful adjustment to notice is the new call to the `scales` library
    to adjust the labels on the x-axis. The adjustment on the y-axis is familiar,
    `scales::percent` to convert the proportion to a percentage. On the x-axis, the
    issue is that several of the labels are rather long. If we do not adjust them
    they will print over one another. The `scales::wrap_format()` function will break
    long labels into lines. It takes a single numerical argument (here `10`) that
    is the maxmimum length a string can be before it is wrapped onto a new line.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表有一些外观细节和调整，我们将在第[8](refineplots.html#refineplots)章中了解更多。和之前一样，我鼓励你逐条指令从底部剥开图表，看看发生了什么变化。一个有用的调整是新的对`scales`库的调用，以调整x轴上的标签。y轴的调整是熟悉的，`scales::percent`将比例转换为百分比。在x轴上，问题是几个标签相当长。如果我们不调整它们，它们将相互打印。`scales::wrap_format()`函数会将长标签拆分成多行。它接受一个单一的数值参数（这里为`10`），这是字符串在换行之前可以有的最大长度。
- en: '![Faceting by education instead.](../Images/c4e4a7dbf051feeb43ed1d4a236124ed.png)
    Figure 6.13: Faceting by education instead.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![通过教育进行分面](../Images/c4e4a7dbf051feeb43ed1d4a236124ed.png) 图6.13：通过教育进行分面。'
- en: A graph like this is true to the categorical nature of the data, while showing
    the breakdown of groups within each year. But you should experiment with some
    alternatives. For example, we might decide that it is better to facet by degree
    category instead, and put the year on the x-axis within each panel. If we do that,
    then we can use `geom_line()` to show a time trend, which is more natural, and
    `geom_ribbon()` to show the error range. This is perhaps a better way to show
    the data, especially as it brings out the time trends within each degree category,
    and allows us to see the similarities and differences by racial classification
    at the same time.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这种图表忠实于数据的类别性质，同时显示了每年内各群体的分解情况。但你应该尝试一些替代方案。例如，我们可能会决定，按学位类别分面会更好，并将年份放在每个面板的x轴上。如果我们这样做，那么我们可以使用`geom_line()`来显示时间趋势，这更自然，并使用`geom_ribbon()`来显示误差范围。这可能是一种更好的展示数据的方式，特别是因为它突出了每个学位类别中的时间趋势，并允许我们同时看到种族分类的相似性和差异性。
- en: '[PRE66]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 6.9 Where to go next
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.9 接下来去哪里
- en: In general, when you estimate models and want to plot the results, the difficult
    step is not the plotting but rather calculating and extracting the right numbers.
    Generating predicted values and measures of confidence or uncertainty from models
    requires that you understand the model you are fitting, and the function you use
    to fit it, especially when it involves interactions, cross-level effects, or transformations
    of the predictor or response scales. The details can vary substantially from model
    type to model type, and also with the goals of any particular analysis. It is
    unwise to approach them mechanically. That said, several tools exist to help you
    work with model objects and produce a default set of plots from them.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你估计模型并想要绘制结果时，困难之处不在于绘图，而在于计算和提取正确的数字。从模型中生成预测值和置信度或不确定性的度量需要你理解你正在拟合的模型，以及你用来拟合它的函数，特别是当它涉及交互、跨级效应或预测变量或响应尺度的转换时。这些细节可能从模型类型到模型类型，以及任何特定分析的目标，都有很大的不同。机械地处理它们是不明智的。话虽如此，存在一些工具可以帮助你处理模型对象并从中生成一组默认的绘图。
- en: 6.9.1 Default plots for models
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9.1 模型的默认绘图
- en: Just as model objects in R usually have a default `summary()` method, printing
    out an overview tailored to the type of model it is, they will usually have a
    default `plot()` method, too. Figures produced by `plot()` are typically not generated
    via ggplot, but it is usually worth exploring them. They typically make use of
    either R’s base graphics or the `lattice` library (Sarkar, 2008). These are two
    plotting systems that we do not cover in this book. Default plot methods are easy
    to examine. Let’s take a look again at our simple OLS model.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如R中的模型对象通常有一个默认的`summary()`方法，打印出针对模型类型的概述一样，它们通常也有一个默认的`plot()`方法。`plot()`函数生成的图形通常不是通过ggplot生成的，但通常值得探索。它们通常使用R的基础图形或`lattice`库（Sarkar，2008）。这两个绘图系统我们在这本书中没有涉及。默认绘图方法很容易检查。让我们再次看看我们的简单OLS模型。
- en: '[PRE67]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: To look at some of R’s default plots for this model, use the `plot()` function.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此模型的一些R默认绘图，请使用`plot()`函数。
- en: '[PRE68]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `which()` statement here selects the first two of four default plots for
    this kind of model. If you want to easily reproduce base R’s default model graphics
    using ggplot, the `ggfortify` library is worth examining. It is in some ways similar
    to `broom`, in that it tidies the output of model objects, but it focuses on producing
    a standard plot (or group of plots) for a wide variety of model types. It does
    this by defining a function called `autoplot()`. The idea is to be able to use
    `autoplot()` with the output of many different kinds of model.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`which()`语句选择了这种模型四种默认图中的前两个。如果你想要轻松地使用ggplot重现基础R的默认模型图形，那么`ggfortify`库值得检查。它在某些方面与`broom`相似，因为它整理了模型对象的输出，但它专注于为各种模型类型生成标准图（或图组）。它是通过定义一个名为`autoplot()`的函数来做到这一点的。其想法是能够使用`autoplot()`与许多不同类型的模型输出一起使用。
- en: A second option worth looking at is the `coefplot` library. It provides a quick
    way to produce good-quality plots of point estimates and confidence intervals.
    It has the advantage of managing the estimation of interaction effects and other
    occasionally tricky calculations.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一看的第二个选项是`coefplot`库。它提供了一种快速生成点估计和置信区间高质量图形的方法。它具有管理交互效应和其他偶尔棘手计算的优势。
- en: '![A plot from coefplot.](../Images/33f6d7587e738968b391596c468ee85a.png) Figure
    6.14: A plot from coefplot.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![coefplot的一个图形](../Images/33f6d7587e738968b391596c468ee85a.png) 图6.14：coefplot的一个图形。'
- en: '[PRE69]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 6.9.2 Tools in development
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9.2 开发中的工具
- en: Tidyverse tools for modeling and model exploration are being actively developed.
    The `broom` and `margins` libraries continue to get more and more useful. There
    are also other projects worth paying attention to. The `infer` package`infer.netlify.com`
    is in its early stages but can already do useful things in a pipeline-friendly
    way. You can install it from CRAN with `install.packages("infer")`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Tidyverse建模和模型探索工具正在积极开发中。`broom`和`margins`库继续变得越来越有用。还有其他一些项目值得关注。`infer`包`infer.netlify.com`处于早期阶段，但已经可以通过管道友好的方式做些有用的事情。你可以通过CRAN使用`install.packages("infer")`来安装它。
- en: 6.9.3 Extensions to ggplot
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9.3 ggplot的扩展
- en: The GGally package provides a suite of functions designed to make producing
    standard but somewhat complex plots a little easier. For instance, it can produce
    generalized pairs plots, a useful way of quickly examining possible relationships
    between several different variables at once. This sort of plot is like the visual
    version of a correlation matrix. It shows a bivariate plot for all pairs of variables
    in the data. This is relatively straightforward when all the variables are continuous
    measures. Things get more complex when, as is often the case in the social sciences,
    some or all variables are categorical or otherwise limited in the range of values
    they can take. A generalized pairs plot can handle these cases. For example, Figure
    [**??**](#fig:ch-06-ggallyplot) shows a generalized pairs plot for five variables
    from the `organdata` dataset.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: GGally 包提供了一套旨在使生成标准但相对复杂的图表变得稍微容易一些的函数。例如，它可以生成广义配对图，这是一种快速检查几个不同变量之间可能关系的有用方法。这种图表类似于相关矩阵的视觉版本。它显示了数据中所有变量对的二元图。当所有变量都是连续测量时，这种情况相对简单。当，正如社会科学中经常发生的那样，某些或所有变量是分类的或其值的范围受到限制时，事情会变得更加复杂。广义配对图可以处理这些情况。例如，图
    [**??**](#fig:ch-06-ggallyplot) 展示了 `organdata` 数据集中五个变量的广义配对图。
- en: '[PRE70]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Multi-panel plots like this are intrinsically very rich in information. When
    combined with several within-panel types of representation, or any more than a
    modest number of variables, they can become quite complex. They should be used
    less for the presentation of finished work, although it is possible. More often
    they are a useful tool for the working researcher to quickly investigate aspects
    of a data set. The goal is not to pithily summarize a single point one already
    knows, but to open things up for further exploration.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 类似这样的多面板图在信息上本质上是极其丰富的。当与多个面板内的表示类型相结合，或者变量数量超过适度数量时，它们可以变得相当复杂。它们应该用于展示已完成的工作较少，尽管这是可能的。更常见的是，它们是研究工作者快速调查数据集方面的有用工具。目标不是简洁地总结已知的一个点，而是为进一步的探索打开大门。
- en: 6.1 Show several fits at once, with a legend
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 同时展示多个拟合，并带有图例
- en: As we just saw in the first panel of Figure [6.1](modeling.html#fig:ch-06-modeltypes),
    where we plotted both an OLS and a robust regression line, we can look at several
    fits at once on the same plot by layering on new smoothers with `geom_smooth()`.
    As long as we set the `color` and `fill` aesthetics to different values for each
    fit, we can easily distinguish them visually. However, ggplot will not draw a
    legend that guides us about which fit is which. This is because the smoothers
    are not logically connected to one another. They exist as separate layers. What
    if we are comparing several different fits and want a legend describing them?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在图 [6.1](modeling.html#fig:ch-06-modeltypes) 的第一个面板中看到的那样，我们绘制了 OLS 和稳健回归线，我们可以在同一个图表上同时查看多个拟合，通过在
    `geom_smooth()` 上叠加新的平滑器。只要我们为每个拟合设置不同的 `color` 和 `fill` 美学值，我们就可以很容易地通过视觉来区分它们。然而，ggplot
    不会绘制一个引导我们了解哪个拟合是哪个的图例。这是因为平滑器之间没有逻辑上的联系。它们作为单独的层存在。如果我们正在比较几个不同的拟合并希望有一个描述它们的图例怎么办？
- en: 'As it turns out, `geom_smooth()` can do this via the slightly unusual route
    of mapping the `color` and `fill` aesthetics to a string describing the model
    we are fitting, and then using `scale_color_manual()` and `scale_fill_manual()`
    to create the legend. First we use `brewer.pal()` from the RColorBrewer library
    to extract three qualitatively different colors from a larger palette. The colors
    are represented as hex values. As before use the `::` convention to use the function
    without loading the whole library:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`geom_smooth()` 可以通过将 `color` 和 `fill` 美学映射到描述我们正在拟合的模型的字符串的稍微不寻常的路线来实现这一点，然后使用
    `scale_color_manual()` 和 `scale_fill_manual()` 来创建图例。首先，我们使用 RColorBrewer 库中的
    `brewer.pal()` 函数从更大的调色板中提取三种质量上不同的颜色。颜色以十六进制值表示。与之前一样，使用 `::` 习惯用法来使用函数而不加载整个库：
- en: '[PRE71]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Then we create a plot with three different smoothers, mapping the color and
    fill *within the `aes()` function* as the name of the smoother:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个包含三个不同平滑器的图表，将颜色和填充映射到 `aes()` 函数内的平滑器名称：
- en: '[PRE73]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Figure 6.2: Fitting smoothers with a legend.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2：带有图例的平滑拟合。
- en: '![Fitting smoothers with a legend.](../Images/5a99296ca57928e76a48f13a3687d518.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![带有图例的平滑拟合。](../Images/5a99296ca57928e76a48f13a3687d518.png)'
- en: In a way we have cheated a little here to make the plot work. Until now, we
    have always mapped aesthetics to the names of variables, not to strings like “OLS”
    or “Cubic Splines”. In Chapter [3](makeplot.html#makeplot), when we discussed
    mapping versus setting aesthetics, we saw what happened when we tried to change
    the color of the points in a scatterplot by setting them to “purple” inside the
    `aes()` function. The result was that the points turned red instead, as ggplot
    in effect created a new variable and labeled it with the word “purple”. We learned
    there that the `aes()` function was for mapping variables to aesthetics.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，我们在这里稍微作弊了一下，以便让图例工作。到目前为止，我们总是将美学映射到变量的名称上，而不是像“OLS”或“Cubic Splines”这样的字符串。在第
    [3](makeplot.html#makeplot) 章节中，当我们讨论映射与设置美学时，我们看到了当我们尝试通过在 `aes()` 函数内部将其设置为“紫色”来改变散点图中点的颜色时发生了什么。结果是，点变成了红色，因为
    ggplot 实际上创建了一个新变量，并用“紫色”这个词来标记它。我们当时了解到 `aes()` 函数是用来将变量映射到美学的。
- en: Here we take advantage of that behavior, creating a new single-value variable
    for the name of each of our models. Ggplot will properly construct the relevant
    guide if we call `scale_color_manual()` and `scale_fill_manual()`.Remember that
    we have to call two scale functions because we have two mappings. The result is
    a single plot containing not just our three smoothers, but also an appropriate
    legend to guide the reader.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用这种行为，为每个模型创建一个新的单值变量。如果我们调用 `scale_color_manual()` 和 `scale_fill_manual()`，ggplot
    将正确构建相关的指南。记住，我们必须调用两个尺度函数，因为我们有两个映射。结果是包含我们的三个平滑器，以及一个适当的图例来引导读者的单个图。
- en: These model-fitting features make ggplot very useful for exploratory work, and
    make it straightforward to generate and compare model-based trends and other summaries
    as part of the process of descriptive data visualization. The various `stat_`
    functions are a flexible way to add summary estimates of various kinds to plots.
    But we will also want more than this, including presenting results from models
    we fit ourselves.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模型拟合功能使 ggplot 在探索性工作中非常有用，并且使生成和比较基于模型的趋势和其他摘要作为描述性数据可视化过程的一部分变得简单直接。各种 `stat_`
    函数是向图中添加各种类型总结估计的灵活方式。但我们也希望得到更多，包括展示我们拟合的模型的结果。
- en: 6.2 Look inside model objects
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 查看模型对象内部
- en: Covering the details of fitting statistical models in R is beyond the scope
    of this book. For a comprehensive, modern introduction to that topic you should
    work your way through (Gelman & Hill, 2018). (Harrell, 2016) is also very good
    on the many practical connections between modeling and graphing data. Similarly,
    (Gelman, 2004) provides a detailed discussion of the use of graphics as a tool
    in model-checking and validation. Here we will discuss some ways to take the models
    that you fit and extract information that is easy to work with in ggplot. Our
    goal, as always, is to get from however the object is stored to a tidy table of
    numbers that we can plot. Most classes of statistical model in R will contain
    the information we need, or will have a special set of functions, or methods,
    designed to extract it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中详细说明拟合统计模型的细节超出了本书的范围。对于该主题的全面、现代介绍，你应该阅读 (Gelman & Hill, 2018)。(Harrell,
    2016) 在建模与绘图数据之间的许多实际联系方面也非常出色。同样，(Gelman, 2004) 详细讨论了将图形作为模型检查和验证工具的使用。在这里，我们将讨论一些方法，从你拟合的模型中提取信息，这些信息在
    ggplot 中易于处理。我们的目标，一如既往，是从对象存储的任何方式到我们可以绘制的整洁数字表。R 中大多数统计模型类别将包含我们所需的信息，或者将有一个特殊的函数集或方法，专门用于提取它。
- en: We can start by learning a little more about how the output of models is stored
    in R. Remember, we are always working with objects, and objects have an internal
    structure consisting of named pieces. Sometimes these are single numbers, sometimes
    vectors, and sometimes lists of things like vectors, matrices, or formulas.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先了解一些关于模型输出在 R 中如何存储的更多信息。记住，我们始终在处理对象，而对象具有由命名部分组成的内部结构。有时这些是单个数字，有时是向量，有时是向量、矩阵或公式等事物的列表。
- en: We have been working extensively with tibbles and data frames. These store tables
    of data with named columns, perhaps consisting of different classes of variable,
    such as integers, characters, dates, or factors. Model objects are a little more
    complicated again.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在广泛地使用 tibbles 和数据框。这些存储具有命名列的数据表，可能由不同类别的变量组成，例如整数、字符、日期或因子。模型对象又复杂一些。
- en: '[PRE74]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Remember, we can use the `str()` function to learn more about the internal
    structure of any object. For example, we can get some information on what class
    (or classes) of object `gapminder` is, how large it is, and what components it
    has. The output from `str(gapminder)` is somewhat dense:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们可以使用 `str()` 函数来了解任何对象的内部结构。例如，我们可以获取一些关于 `gapminder` 对象属于哪个类（或哪些类），它有多大，以及它包含哪些组件的信息。`str(gapminder)`
    的输出有些密集：
- en: '[PRE76]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: There is a lot of information here about the object as a whole and each variable
    in it. In the same way, statistical models in R have an internal structure. But
    because models are more complex entities than data tables, their structure is
    correspondingly more complicated. There are more pieces of information, and more
    kinds of information, that we might want to use. All of this information is generally
    stored in or is computable from parts of a model object.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多关于整个对象及其每个变量的信息。同样，R 中的统计模型也有内部结构。但由于模型比数据表更复杂，因此其结构也相应更复杂。有更多的信息片段和更多种类的信息，我们可能希望使用。所有这些信息通常存储在模型对象的部分中，或者可以从模型对象的部分计算得出。
- en: 'We can create a linear model, an ordinary OLS regression, using the `gapminder`
    data. This dataset has a country-year structure that makes an OLS specification
    like this the wrong one to use. But never mind that for now. We use the `lm()`
    function to run the model, and store it in an object called `out`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `gapminder` 数据创建一个线性模型，一个普通的最小二乘回归。这个数据集有一个国家-年结构，使得像这样的 OLS 规定是错误的。但现在先不要管这个。我们使用
    `lm()` 函数运行模型，并将其存储在一个名为 `out` 的对象中：
- en: '[PRE77]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The first argument is the formula for the model. `lifeExp` is the dependent
    variable and the tilde `~` operator is used to designate the left- and right-hand
    sides of a model (including in cases, as we saw with `facet_wrap()` where the
    model just has a right-hand side.)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是模型的公式。`lifeExp` 是因变量，波浪号 `~` 操作符用于指定模型的左右两侧（包括在 `facet_wrap()` 中我们看到的情况，其中模型只有右侧。）
- en: Let’s look at the results by asking R to print a summary of the model.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过让 R 打印模型摘要来查看结果。
- en: '[PRE78]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: When we use the `summary()` function on `out`, we are not getting a simple feed
    of what’s in the model object. Instead, like any function, `summary()` takes its
    input, performs some actions, and produces output. In this case, what is printed
    to the console is partly information that is stored inside the model object, and
    partly information that the `summary()` function has calculated and formated for
    display on the screen. Behind the scenes, `summary()` gets help from other functions.
    Objects of different classes have default *methods* associated with them, so that
    when the generic `summary()` function is applied to a linear model object, the
    function knows to pass the work on to a more specialized function that does a
    bunch of calculations and formatting appropriate to a linear model object. We
    use the same generic `summary()` function on data frames, as in `summary(gapminder)`,
    but in that case a different default method is applied.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 `out` 上使用 `summary()` 函数时，我们并没有得到模型对象中内容的简单反馈。相反，就像任何函数一样，`summary()` 函数接收其输入，执行一些操作，并产生输出。在这种情况下，打印到控制台的信息部分是存储在模型对象中的信息，部分是
    `summary()` 函数计算并格式化以在屏幕上显示的信息。幕后，`summary()` 函数得到了其他函数的帮助。不同类的对象都有与之关联的默认 *方法*，因此当通用的
    `summary()` 函数应用于线性模型对象时，该函数知道将工作传递给一个更专业的函数，该函数执行一系列针对线性模型对象的计算和格式化。我们在数据框上也使用相同的通用
    `summary()` 函数，如 `summary(gapminder)`，但在那种情况下，应用了一个不同的默认方法。
- en: '![Schematic view of a linear model object.](../Images/f5f123f28f8a54c1faa7cd02545df638.png)
    Figure 6.3: Schematic view of a linear model object.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![线性模型对象的示意图](../Images/f5f123f28f8a54c1faa7cd02545df638.png) 图6.3：线性模型对象的示意图。'
- en: The output from `summary()` gives a precis of the model, but we can’t really
    do any further analysis with it directly. For example, what if we want to plot
    something from the model? The information necessary to make plots is inside the
    `out` object, but it is not obvious how to use it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`summary()` 函数的输出提供了模型的摘要，但直接使用它进行进一步分析是不可能的。例如，如果我们想从模型中绘制一些内容呢？制作图表所需的信息在
    `out` 对象中，但并不明显如何使用它。'
- en: 'If we take a look at the structure of the model object with `str(out)` we will
    find that there is a *lot* of information in there. Like most complex objects
    in R, `out` is organized as a list of components or elements. Several of these
    elements are themselves lists. Figure [6.3](modeling.html#fig:ch-06-lm-object-schematic)
    gives you a schematic view of the contents of a linear model object. In this list
    of items, elements are single values, some are data frames, and some are additional
    lists of simpler items. Again, remember our earlier discussion where we said objects
    could be thought of as being organized like a filing system: cabinets contain
    drawers, and drawer may contain which may contain pages of information, whole
    documents, or groups of folders with more documents inside. As an alternative
    analogy, and sticking with the image of a list, you can think of a master to-do
    list for a project, where the top-level headings lead to contain additional lists
    of tasks of different kinds.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用 `str(out)` 查看模型对象的结构，我们会发现其中有很多信息。像R中的大多数复杂对象一样，`out` 是由组件或元素组成的列表。其中一些元素本身也是列表。图
    [6.3](modeling.html#fig:ch-06-lm-object-schematic) 给出了线性模型对象内容的示意图。在这个项目列表中，元素是单个值，一些是DataFrame，一些是更简单项目的附加列表。再次提醒，回想我们之前的讨论，我们说对象可以被看作是像文件系统一样组织：柜子包含抽屉，抽屉可能包含文件夹，文件夹可能包含信息页、整个文档或包含更多文档的文件夹组。作为一个替代的类比，并继续使用列表的图像，你可以想象一个项目的总待办事项列表，其中顶级标题引导到包含不同类型任务的附加列表。
- en: The `out` object created by `lm` contains several different named elements.
    Some, like the residual degrees of freedom in the model, are just a single number.Try
    `out$df.residual` at the console. Others are much larger entities, such as the
    data frame used to fit the model, which is retained by default. Try `out$model`,
    but be prepared for a lot of stuff to be printed at the console. Other elements
    have been computed by R and then stored, such as the coefficients of the model
    and other quantities. You can try `out$coefficients`, `out$residuals`, and `out$fitted.values`,
    for instance. Others are lists themselves (like `qr`). So you can see that the
    `summary()` function is selecting and printing only a small amount of core information,
    in comparison to what is stored in the model object.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `lm` 创建的 `out` 对象包含几个不同的命名元素。其中一些，如模型中的残差自由度，只是一个单一的数字。在控制台中尝试 `out$df.residual`。其他的是更大的实体，例如用于拟合模型的DataFrame，默认情况下被保留。尝试
    `out$model`，但要做好准备，因为控制台会打印出很多内容。其他元素是由R计算并存储的，例如模型的系数和其他量。例如，你可以尝试 `out$coefficients`、`out$residuals`
    和 `out$fitted.values`。其他元素本身是列表（如 `qr`）。所以你可以看到，与存储在模型对象中的信息相比，`summary()` 函数只选择并打印了一小部分核心信息。
- en: Just like the tables of data we saw earlier in Section [A.1.3](appendix.html#tidydata),
    the output of `summary()` is presented in a way that is *compact* and *efficient*
    in terms of getting information across, but also *untidy* when considered from
    the point of view of further manipulation. There is a table of coefficients, but
    the variable names are in the rows. The column names are awkward, and some information
    (e.g. at the bottom of the output) has been calculated and printed out, but is
    not stored in the model object.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在第 [A.1.3](appendix.html#tidydata) 节中看到的早期数据表一样，`summary()` 的输出以一种在传达信息方面既
    *紧凑* 又 *高效* 的方式呈现，但从进一步操作的角度来看，它又是 *杂乱无章* 的。有一个系数表，但变量名在行中。列名不合适，一些信息（例如输出底部）已经被计算并打印出来，但并未存储在模型对象中。
- en: 6.3 Get model-based graphics right
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 正确获取基于模型的图形
- en: Figures based on statistical models face all the ordinary challenges of effective
    data visualization, and then some. This is because model results usually carry
    a considerable extra burden of interpretation and necessary background knowledge.
    The more complex the model, the trickier it becomes to convey this information
    effectively, and the easier it becomes to lead one’s audience or oneself into
    error. Within the social sciences, our ability to clearly and honestly present
    model-based graphics has greatly improved over the past ten or fifteen years.
    Over the same period, it has become clearer that some kinds of models are quite
    tricky to understand, even ones that had previously been seen as straightforward
    elements of the modeling toolkit (Ai & Norton, 2003; Brambor, Clark, & Golder,
    2006).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 基于统计模型的图表面临着所有有效数据可视化的普通挑战，甚至更多。这是因为模型结果通常带有相当大的额外解释负担和必要的背景知识。模型越复杂，有效地传达这些信息就越困难，而且更容易引导听众或自己犯错误。在社会科学领域，我们过去十年或十五年来在清晰和诚实地展示基于模型的图形方面的能力有了很大提高。在相同时期内，也变得清楚，某些类型的模型很难理解，即使它们以前被视为建模工具包中的直接元素（Ai
    & Norton, 2003; Brambor, Clark, & Golder, 2006）。
- en: Plotting model estimates is closely connected to properly estimating models
    in the first place. This means there is no substitute for learning the statistics.
    You should not use graphical methods as a substitute for understanding the model
    used to produce them. While this book cannot teach you that material, we can make
    a few general points about what good model-based graphics look like, and work
    through some examples of how ggplot and some additional libraries can make it
    easier to get good results.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制模型估计值与正确估计模型本身密切相关。这意味着学习统计学没有替代品。你不应该将图形方法作为理解产生它们的模型的一种替代。虽然这本书不能教你那些材料，但我们可以提出一些关于好的基于模型的图形看起来像什么的一般观点，并通过一些ggplot和一些附加库如何使获得好结果更容易的例子来进行分析。
- en: 6.3.1 Present your findings in substantive terms
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 以实质性的术语展示你的发现
- en: Useful model-based plots show results in ways that are substantively meaningful
    and directly interpretable with respect to the questions the analysis is trying
    to answer. This means showing results in a context where other variables in the
    analysis are held at sensible values, such as their means or medians. With continuous
    variables, it can often be useful to generate predicted values that cover some
    substantively meaningful move across the distribution, such as from the 25th to
    the 75th percentile, rather than a single-unit increment in the variable of interest.
    For unordered categorical variables, predicted values might be presented with
    respect to the modal category in the data, or for a particular category of theoretical
    interest. Presenting substantively interpretable findings often also means using
    (and sometimes converting to) a scale that readers can easily understand. If your
    model reports results in log-odds, for example, converting the estimates to predicted
    probabilities will make it easier to interpret. All of this advice is quite general.
    Each of these points applies equally well to the presentation of summary results
    in a table rather than a graph. There is nothing distinctively graphical about
    putting the focus on the substantive meaning of your findings.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的基于模型的图表以实质上有意义的方式展示结果，并且可以直接根据分析试图回答的问题进行解释。这意味着在分析中其他变量保持合理值的情况下展示结果，例如它们的平均值或中位数。对于连续变量，生成覆盖分布中一些实质上有意义的移动的预测值可能很有用，例如从第25百分位数到第75百分位数，而不是对感兴趣变量的单单位增量。对于无序分类变量，预测值可能根据数据中的众数类别或对理论上有兴趣的特定类别进行展示。展示实质上可解释的发现通常还意味着使用（有时转换为）读者容易理解的量表。例如，如果你的模型报告的是对数优势，将估计值转换为预测概率将使其更容易解释。所有这些建议都非常普遍。这些观点同样适用于在表格而不是图表中展示总结结果。将重点放在你发现的实际意义上并没有什么特别图形化的地方。
- en: 6.3.2 Show your degree of confidence
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 展示你的置信度
- en: Much the same applies to presenting the degree of uncertainty or confidence
    you have in your results. Model estimates come with various measures of precision,
    confidence, credence, or significance. Presenting and interpreting these measures
    is notoriously prone to misinterpretation, or over-interpretation, as researchers
    and audiences both demand more from things like confidence intervals and p-values
    than these statistics can deliver. At a minimum, having decided on an appropriate
    measure of model fit or the right assessment of confidence, you should show their
    range when you present your results. A family of related ggplot geoms allow you
    to show a range or interval defined by position on the x-axis and then a `ymin`
    and `ymax` range on the y-axis. These geoms include `geom_pointrange()` and `geom_errorbar()`,
    which we will see in action shortly. A related geom, `geom_ribbon()` uses the
    same arguments to draw filled areas, and is useful for plotting ranges of y-axis
    values along some continuously varying x-axis.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的情况也适用于呈现你对结果的不确定性或置信度的程度。模型估计伴随着各种精确度、置信度、可信度或显著性的度量。呈现和解释这些度量通常容易产生误解，或者过度解读，因为研究人员和听众都期望从诸如置信区间和p值等事物中获得比这些统计数据所能提供的更多。至少，在决定适当的模型拟合度量或正确的置信度评估后，你在呈现结果时应展示其范围。一系列相关的ggplot几何对象允许你展示由x轴上的位置定义的范围或区间，然后在y轴上定义`ymin`和`ymax`范围。这些几何对象包括`geom_pointrange()`和`geom_errorbar()`，我们很快就会看到它们的应用。另一个相关的几何对象`geom_ribbon()`使用相同的参数来绘制填充区域，这对于在某个连续变化的x轴上绘制y轴值的范围非常有用。
- en: 6.3.3 Show your data when you can
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.3 当可能时展示你的数据
- en: Plotting the results from a multivariate model generally means one of two things.
    First, we can show what is in effect a table of coefficients with associated measures
    of confidence, perhaps organizing the coefficients into meaningful groups, or
    by the size of the predicted association, or both. Second, we can show the predicted
    values of some variables (rather than just a model’s coefficients) across some
    range of interest. The latter approach lets us show the original data points if
    we wish. The way ggplot builds graphics layer by layer allows us to easily combine
    model estimates (e.g. a regression line and an associated range) and the underlying
    data. In effect these are manually-constructed versions of the automatically-generated
    plots that we have been producing with `geom_smooth()` since the beginning of
    this book.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制多元模型的成果通常意味着以下两种情况之一。首先，我们可以展示一个包含相关置信度措施的系数表，可能将这些系数组织成有意义的组，或者根据预测关联的大小，或者两者兼而有之。其次，我们可以展示一些变量的预测值（而不仅仅是模型的系数）在某个感兴趣范围内的值。后者允许我们在需要时展示原始数据点。ggplot通过层层构建图形的方式，使我们能够轻松地结合模型估计（例如回归线和相关的范围）以及底层数据。实际上，这些是手动构建的自动生成的图形版本，自从本书开始我们就一直在使用`geom_smooth()`生成这些图形。
- en: 6.3.1 Present your findings in substantive terms
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 以实质性术语呈现你的发现
- en: Useful model-based plots show results in ways that are substantively meaningful
    and directly interpretable with respect to the questions the analysis is trying
    to answer. This means showing results in a context where other variables in the
    analysis are held at sensible values, such as their means or medians. With continuous
    variables, it can often be useful to generate predicted values that cover some
    substantively meaningful move across the distribution, such as from the 25th to
    the 75th percentile, rather than a single-unit increment in the variable of interest.
    For unordered categorical variables, predicted values might be presented with
    respect to the modal category in the data, or for a particular category of theoretical
    interest. Presenting substantively interpretable findings often also means using
    (and sometimes converting to) a scale that readers can easily understand. If your
    model reports results in log-odds, for example, converting the estimates to predicted
    probabilities will make it easier to interpret. All of this advice is quite general.
    Each of these points applies equally well to the presentation of summary results
    in a table rather than a graph. There is nothing distinctively graphical about
    putting the focus on the substantive meaning of your findings.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的基于模型的图表以实质上有意义且可以直接解释的方式展示结果，这些方式与分析试图回答的问题直接相关。这意味着在分析中其他变量保持合理值（如均值或中位数）的上下文中展示结果。对于连续变量，生成覆盖分布中一些实质上有意义的移动的预测值通常很有用，例如从第25百分位数到第75百分位数，而不是对感兴趣变量的单单位增量。对于无序分类变量，预测值可能根据数据中的众数类别或对理论上有兴趣的特定类别来展示。展示实质上可解释的发现通常还意味着使用（有时转换为）读者容易理解的量表。例如，如果你的模型报告的是对数优势，将估计值转换为预测概率将使其更容易解释。所有这些建议都非常普遍。这些观点同样适用于在表格而不是图表中展示总结结果。将重点放在你发现的实际意义上，并没有什么特别图形化的地方。
- en: 6.3.2 Show your degree of confidence
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 展示你的置信度程度
- en: Much the same applies to presenting the degree of uncertainty or confidence
    you have in your results. Model estimates come with various measures of precision,
    confidence, credence, or significance. Presenting and interpreting these measures
    is notoriously prone to misinterpretation, or over-interpretation, as researchers
    and audiences both demand more from things like confidence intervals and p-values
    than these statistics can deliver. At a minimum, having decided on an appropriate
    measure of model fit or the right assessment of confidence, you should show their
    range when you present your results. A family of related ggplot geoms allow you
    to show a range or interval defined by position on the x-axis and then a `ymin`
    and `ymax` range on the y-axis. These geoms include `geom_pointrange()` and `geom_errorbar()`,
    which we will see in action shortly. A related geom, `geom_ribbon()` uses the
    same arguments to draw filled areas, and is useful for plotting ranges of y-axis
    values along some continuously varying x-axis.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的情况也适用于展示你对结果的不确定性或置信度。模型估计伴随着各种精确度、置信度、可信度或显著性的度量。展示和解释这些度量通常容易误解，或者过度解释，因为研究人员和观众对诸如置信区间和p值等事物的期望超过了这些统计数据所能提供的。至少，在决定适当的模型拟合度量或正确的置信度评估后，你应该在展示结果时展示它们的范围。一系列相关的ggplot
    geoms允许你展示由x轴上的位置定义的范围或区间，然后在y轴上展示`ymin`和`ymax`的范围。这些geoms包括`geom_pointrange()`和`geom_errorbar()`，我们很快就会看到它们的应用。一个相关的geom，`geom_ribbon()`使用相同的参数来绘制填充区域，这对于在某个连续变化的x轴上绘制y轴值的范围很有用。
- en: 6.3.3 Show your data when you can
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.3 当可能时展示你的数据
- en: Plotting the results from a multivariate model generally means one of two things.
    First, we can show what is in effect a table of coefficients with associated measures
    of confidence, perhaps organizing the coefficients into meaningful groups, or
    by the size of the predicted association, or both. Second, we can show the predicted
    values of some variables (rather than just a model’s coefficients) across some
    range of interest. The latter approach lets us show the original data points if
    we wish. The way ggplot builds graphics layer by layer allows us to easily combine
    model estimates (e.g. a regression line and an associated range) and the underlying
    data. In effect these are manually-constructed versions of the automatically-generated
    plots that we have been producing with `geom_smooth()` since the beginning of
    this book.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制多元模型的成果通常意味着两种情况之一。首先，我们可以展示一个实际上包含系数及其相关置信度措施的表格，也许将这些系数组织成有意义的组，或者根据预测关联的大小，或者两者兼而有之。其次，我们可以展示一些变量的预测值（而不仅仅是模型的系数）在某个感兴趣的范围。后一种方法允许我们在需要时展示原始数据点。ggplot
    通过层层构建图形的方式允许我们轻松地将模型估计（例如回归线和相关的范围）与底层数据结合起来。实际上，这些是我们从本书开始就一直在使用 `geom_smooth()`
    生成自动生成的图形的手动构建版本。
- en: 6.4 Generate predictions to graph
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 生成用于绘图的预测
- en: Having fitted a model, then, we might want to get a picture of the estimates
    it produces over the range of some particular variable, holding other covariates
    constant at some sensible values. The `predict()` function is a generic way of
    using model objects to produce this kind of prediction. In R, “generic” functions
    take their inputs and pass them along to more specific functions behind the scenes,
    ones that are suited to working with the particular kind of model object we have.
    The details of getting predicted values from a OLS model, for instance, will be
    somewhat different from getting predictions out of a logistic regression. But
    in each case we can use the same `predict()` function, taking care to check the
    documentation to see what form the results are returned in for the kind of model
    we are working with. Many of the most commonly-used functions in R are generic
    in this way. The `summary()` function, for example, works on objects of many different
    classes, from vectors to data frames and statistical models, producing appropriate
    output in each case by way of a class-specific function in the background.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在拟合了一个模型之后，我们可能想要了解它在某个特定变量的范围内产生的估计值，同时将其他协变量保持在其合理的值上。`predict()` 函数是一种通用的使用模型对象来产生此类预测的方法。在
    R 中，“通用”函数将它们的输入传递给后台的更具体函数，这些函数适合与我们所拥有的特定类型的模型对象一起工作。例如，从 OLS 模型获取预测值的细节将与其他类型的逻辑回归有所不同。但在每种情况下，我们都可以使用相同的
    `predict()` 函数，同时注意检查文档以了解我们正在使用的模型类型的结果返回形式。R 中许多最常用的函数都是通用的。例如，`summary()` 函数可以处理许多不同类别的对象，从向量到数据框和统计模型，通过在后台使用特定类别的函数来产生适当的输出。
- en: For `predict()` to calculate the new values for us, it needs some new data to
    fit the model to. We will generate a new data frame whose columns have the same
    names as the variables in the model’s original data, but where the rows have new
    values. A very useful function called `expand.grid()` will help us do this. We
    will give it a list of variables, specifying the range of values we want each
    variable to take. Then `expand.grid()` will generate the will multiply out theThe
    function calculates the cartesian product of the variables given to it. full range
    of values for all combinations of the values we give it, thus creating a new data
    frame with the new data we need.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 `predict()` 函数为我们计算新的值，它需要一些新的数据来拟合模型。我们将生成一个新的数据框，其列名与模型原始数据中的变量名称相同，但行中包含新的值。一个非常有用的函数叫做
    `expand.grid()` 将帮助我们完成这项工作。我们将给它一个变量列表，指定我们希望每个变量取值的范围。然后 `expand.grid()` 将生成所有给定值的组合的全范围，从而创建一个包含所需新数据的新数据框。
- en: In the following bit of code, we use `min()` and `max()` to get the minimum
    and maximum values for per capita GDP, and then create a vector with one hundred
    evenly-spaced elements between the minimum and the maximum. We hold population
    constant at its median, and we let continent take all of its five available values.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们使用 `min()` 和 `max()` 获取人均 GDP 的最小值和最大值，然后创建一个在最小值和最大值之间有 100 个等间距元素的向量。我们保持人口数量恒定在其中位数，并让大陆变量取其五个可用值。
- en: '[PRE80]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Now we can use `predict()`. If we give the function our new data and model,
    without any further argument, it will calculate the fitted values for every row
    in the data frame. If we specify `interval = 'predict'` as an argument, it will
    calculate 95% prediction intervals in addition to the point estimate.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`predict()`。如果我们给函数提供我们的新数据和模型，而不需要任何其他参数，它将为数据框中的每一行计算拟合值。如果我们指定`interval
    = 'predict'`作为参数，它将除了计算点估计值外，还会计算95%预测区间。
- en: '[PRE84]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Because we know that, by construction, the cases in `pred_df` and `pred_out`
    correspond row for row, we can bind the two data frames together by column. This
    method of joining or merging tables is *definitely not* recommended when you are
    dealing with data.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们知道，根据构造，`pred_df`和`pred_out`中的案例是行对行对应的，所以我们可以通过列将这两个数据框绑定在一起。当你处理数据时，这种方法连接或合并表**绝对不推荐**。
- en: '[PRE86]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The end result is a tidy data frame, containing the predicted values from the
    model for the range of values we specified. Now we can plot the results. Because
    we produced a full range of predicted values, we can decide whether or not to
    use all of them. Here we further subset the predictions to just those for Europe
    and Africa.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是包含我们指定范围内模型预测值的整洁数据框。现在我们可以绘制结果。因为我们生成了完整的预测值范围，我们可以决定是否使用所有这些值。在这里，我们进一步将预测子集为仅针对欧洲和非洲的预测。
- en: '[PRE88]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Figure 6.4: OLS Predictions.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：OLS预测。
- en: '![OLS Predictions.](../Images/0f85fa49f1edb0321e841e4bdd2d20cc.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![OLS预测图](../Images/0f85fa49f1edb0321e841e4bdd2d20cc.png)'
- en: 'We use a new geom here to draw the area covered by the prediction intervals:
    `geom_ribbon()`. It takes an `x` argument like a line, but a `ymin` and `ymax`
    argument as specified in the `ggplot()` aesthetic mapping. This defines the lower
    and upper limits of the prediction interval.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用一个新的几何对象来绘制预测区间的覆盖区域：`geom_ribbon()`。它像线条一样接受一个`x`参数，但还接受一个`ymin`和`ymax`参数，这些参数在`ggplot()`美学映射中指定。这定义了预测区间的下限和上限。
- en: In practice, you may not use `predict()` directly all that often. Instead, you
    might write code using additional libraries that encapsulate the process of producing
    predictions and plots from models. These are especially useful when your model
    is a little more complex and the interpretation of coefficients becomes trickier.
    This happens, for instance, when you have a binary outcome variable and need to
    convert the results of a logistic regression into predicted probabilities, or
    when you have interaction terms amongst your predictions. We will discuss some
    of these helper libraries in the next few sections. However, bear in mind that
    `predict()` and its ability to work safely with different classes of model underpins
    many of those libraries. So it’s useful to see it in action first hand in order
    to understand what it is doing.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你可能不会经常直接使用`predict()`。相反，你可能会编写使用额外库的代码，这些库封装了从模型生成预测和绘图的过程。这些库特别有用，当你模型稍微复杂一些，系数的解释变得困难时。例如，当你有一个二元结果变量，需要将逻辑回归的结果转换为预测概率，或者当你预测中有交互项时。我们将在下一节讨论一些这些辅助库。然而，请记住，`predict()`及其与不同类别的模型安全工作的能力是许多这些库的基础。因此，首先亲自看到它的实际操作是有用的，以便了解它在做什么。
- en: 6.5 Tidy model objects with broom
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 使用broom整理模型对象
- en: The `predict` method is very useful, but there are a lot of other things we
    might want to do with our model output. We will use David Robinson’s `broom` package
    to help us out. It is a library of functions that help us get from the model results
    that R generates to numbers that we can plot. It will take model objects and turn
    pieces of them into data frames that you can use easily with ggplot.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`predict`方法非常有用，但我们可能还想用我们的模型输出做很多其他事情。我们将使用David Robinson的`broom`包来帮助我们。这是一个函数库，帮助我们从R生成的模型结果中得到我们可以绘制的数字。它将模型对象的一些部分转换为你可以轻松与ggplot一起使用的数据框。'
- en: '[PRE89]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Broom takes ggplot’s approach to tidy data and extends it to the model objects
    that R produces. Its methods can tidily extract three kinds of information. First,
    we can see *component-level* information about aspects of the model itself, such
    as coefficients and t-statistics. Second, we can obtain *observation-level* information
    about the model’s connection to the underlying data. This includes the fitted
    values and residuals for each observation in the data. And finally we can get
    *model-level* information that summarizes the fit as a whole, such as an F-statistic,
    the model deviance, or the r-squared. There is a `broom` function for each of
    these tasks.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Broom扩展了ggplot对整洁数据的处理方法，并将其应用于R生成的模型对象。它的方法可以整洁地提取三种类型的信息。首先，我们可以看到模型本身的方面（如系数和t统计量）的*组件级*信息。其次，我们可以获得模型与底层数据连接的*观测级*信息。这包括数据中每个观测值的拟合值和残差。最后，我们可以获取总结整个拟合的*模型级*信息，如F统计量、模型偏差或r平方。对于这些任务，都有一个`broom`函数。
- en: 6.5.1 Get component-level statistics with tidy()
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1 使用tidy()获取组件级统计量
- en: The `tidy()` function takes a model object and returns a data frame of component-level
    information. We can work with this to make plots in a familiar way, and much more
    easily than fishing inside the model object to extract the various terms. Here
    is an example, using the default results as just returned. For a more convenient
    display of the results, we will pipe the object we create with `tidy()` through
    a function that rounds the numeric columns of the data frame to two decimal places.
    This doesn’t change anything about the object itself, of course.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`tidy()`函数接受一个模型对象，并返回一个包含组件级信息的data frame。我们可以通过这种方式以熟悉的方式制作图表，比在模型对象内部提取各种项要容易得多。以下是一个示例，使用刚刚返回的默认结果。为了更方便地显示结果，我们将使用`tidy()`创建的对象通过一个函数进行管道处理，该函数将数据框的数值列四舍五入到两位小数。当然，这不会改变对象本身的内容。'
- en: '[PRE90]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: We are now able to treat this data frame just like all the other data that we
    have seen so far.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以像对待迄今为止看到的所有其他数据一样处理这个data frame。
- en: '![Basic plot of OLS estimates.](../Images/86cb8182688f582ab5bf93d7c02069cb.png)
    Figure 6.5: Basic plot of OLS estimates.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '![OLS估计的基本图示](../Images/86cb8182688f582ab5bf93d7c02069cb.png) 图6.5：OLS估计的基本图示。'
- en: '[PRE92]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We can extend and clean up this plot in a variety of ways. For example, we can
    tell `tidy()` to calculate confidence intervals for the estimates, using R’s `confint()`
    function.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过多种方式扩展和清理这个图。例如，我们可以告诉`tidy()`使用R的`confint()`函数计算估计的置信区间。
- en: '[PRE93]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The convenience “not in” operator `%nin%` is available via the `socviz` library.
    It does the opposite of `%in%` and selects only the items in a first vector of
    characters that are not in the second. We’ll use it to drop the intercept term
    from the table. We also want to something about the labels. When fitting a model
    with categorical variables, R will create coefficient names based on the variable
    name and the category name, like `continentAmericas`. Normally we like to clean
    these up before plotting. Most commonly, we just want to strip away the variable
    name at the beginning of the coefficient label. For this we can use `prefix_strip()`,
    a convenience function in the `socviz` library. We tell it which prefixes to drop,
    using it to create a new column variable in `out_conf` that corresponds to the
    `terms` column, but that has nicer labels.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的“不在”操作符`%nin%`通过`socviz`库提供。它与`%in%`相反，只选择第一个字符向量中不在第二个向量中的项。我们将使用它从表中删除截距项。我们还想对标签做一些处理。当用分类变量拟合模型时，R将根据变量名和类别名创建系数名称，例如`continentAmericas`。通常我们希望在绘图之前清理这些名称。最常见的是，我们只想去除系数标签开头的变量名。为此，我们可以使用`prefix_strip()`，这是`socviz`库中的一个方便函数。我们告诉它要删除哪些前缀，使用它来在`out_conf`中创建一个新列变量，该变量对应于`terms`列，但具有更好的标签。
- en: '[PRE95]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Now we can use `geom_pointrange()` to make a figure that displays some information
    about our confidence in the variable estimates, as opposed to just the coefficients.
    As with the boxplots earlier, we use `reorder()` to sort the names of the model’s
    terms by the `estimate` variable, thus arranging our plot of effects from largest
    to smallest in magnitude.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`geom_pointrange()`来制作一个图，显示关于我们对变量估计的信心等信息，而不仅仅是系数。与之前的箱线图一样，我们使用`reorder()`按`estimate`变量对模型的项进行排序，从而将我们的效应图从大到小排列。
- en: '![A nicer plot of OLS estimates and confidence intervals.](../Images/388eb72c4d668c76c8c461f3b459c1de.png)
    Figure 6.6: A nicer plot of OLS estimates and confidence intervals.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '![OLS估计和置信区间的更漂亮的图](../Images/388eb72c4d668c76c8c461f3b459c1de.png) 图6.6：OLS估计和置信区间的更漂亮的图。'
- en: '[PRE96]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Dotplots of this kind can be very compact. The vertical axis can often be compressed
    quite a bit, with no loss in comprehension. In fact, they are often easier to
    read with much less room between the rows than given by a default square shape.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的点图可以非常紧凑。垂直轴通常可以压缩很多，而不会损失理解力。事实上，它们通常在行与行之间有更少的间隔时更容易阅读，而不是默认的方形形状。
- en: 6.5.2 Get observation-level statistics with augment()
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.2 使用augment()获取观测级统计信息
- en: 'The values returned by `augment()` are all statistics calculated at the level
    of the original observations. As such, they can be added on to the data frame
    that the model is based on. Working from a call to `augment()` will return a data
    frame with all the original observations used in the estimation of the model,
    together with columns like the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`augment()`返回的值都是计算在原始观测水平上的统计数据。因此，它们可以添加到模型基于的数据框中。从对`augment()`的调用开始，将返回一个数据框，其中包含用于模型估计的所有原始观测值，以及以下列：'
- en: '`.fitted` — The fitted values of the model.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.fitted` — 模型的拟合值。'
- en: '`.se.fit` — The standard errors of the fitted values.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.se.fit` — 拟合值的标准误差。'
- en: '`.resid` — The residuals.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.resid` — 残差。'
- en: '`.hat` — The diagonal of the hat matrix.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.hat` — 帽矩阵的对角线。'
- en: '`.sigma` — An estimate of residual standard deviation when the corresponding
    observation is dropped from the model.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.sigma` — 当从模型中删除相应的观测值时，残差标准差的估计。'
- en: '`.cooksd` — Cook’s distance, a common regression diagnostic; and'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.cooksd` — 库克距离，一个常见的回归诊断；以及'
- en: '`.std.resid` — The standardized residuals.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.std.resid` — 标准化残差。'
- en: Each of these variables is named with a leading dot, for example `.hat` rather
    than `hat`, and so on. This is to guard against accidentally confusing it with
    (or accidentally overwriting) an existing variable in your data with this name.
    The columns of values return will differ slightly depending on the class of model
    being fitted.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量都是以一个前缀点命名的，例如`.hat`而不是`hat`，等等。这是为了防止意外地将其与（或意外地覆盖）具有此名称的现有变量混淆。返回的值列将根据拟合的模型类别略有不同。
- en: '[PRE97]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'By default, `augment()` will extract the available data from the model object.
    This will usually include the variables used in the model itself, but not any
    additional ones contained in the original data frame. Sometimes it is useful to
    have these. We can add them by specifying the `data` argument:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`augment()`将从模型对象中提取可用的数据。这通常包括模型本身使用的变量，但不包括原始数据框中包含的任何附加变量。有时这些变量是有用的。我们可以通过指定`data`参数来添加它们：
- en: '[PRE99]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: If some rows containing missing data were dropped to fit the model, then these
    will not be carried over to the augmented data frame.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为了拟合模型而删除了一些包含缺失数据的行，那么这些数据将不会传递到增强数据框中。
- en: The new columns created by `augment()` can be used to create some standard regression
    plots. For example, we can plot the residuals versus the fitted values. Figure
    [6.7](modeling.html#fig:ch-06-augresid) suggests, unsurprisingly, that our country-year
    data has rather more structure than is captured by our OLS model.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`augment()`创建的新列可以用来创建一些标准的回归图。例如，我们可以绘制残差与拟合值的对比图。图[6.7](modeling.html#fig:ch-06-augresid)表明，不出所料，我们的国家-年数据比我们的OLS模型所捕捉的结构要复杂得多。'
- en: '![Residuals vs Fitted Values.](../Images/43cf2a062d66ee897fa121dbf99503c9.png)
    Figure 6.7: Residuals vs Fitted Values.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '![残差与拟合值对比图](../Images/43cf2a062d66ee897fa121dbf99503c9.png) 图6.7：残差与拟合值对比图。'
- en: '[PRE101]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 6.5.3 Get model-level statistics with glance()
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.3 使用glance()获取模型级统计信息
- en: This function organizes the information typically presented at the bottom of
    a model’s `summary()` output. By itself, it usually just returns a table with
    a single row in it. But as we shall see in a moment, the real power of `broom`’s
    approach is the way that it can scale up to cases where we are grouping or subsampling
    our data.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数组织了通常在模型`summary()`输出底部的信息。单独使用时，它通常只返回一个包含单行的表格。但正如我们一会儿将要看到的，`broom`方法的真正力量在于它能够扩展到我们分组或子采样数据的情况。
- en: '[PRE102]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Broom is able to tidy (and augment, and glance at) a wide range of model types.
    Not all functions are available for all classes of model. Consult broom’s documentation
    for more details on what is available. For example, here is a plot created from
    the tidied output of an event-history analysis. First we generate a Cox proportional
    hazards model of some survival data.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Broom能够整理（以及增强，以及浏览）广泛的模型类型。并非所有函数都适用于所有模型类别。有关可用性的详细信息，请参阅broom的文档。例如，这里是一个从事件历史分析的整理输出创建的图。首先，我们生成一些生存数据的Cox比例风险模型。
- en: '[PRE104]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The details of the fit are not important here, but in the first step the `Surv()`
    function creates the response or outcome variable for the proportional hazards
    model that is then fitted by the `coxph()` function. Then the `survfit()` function
    creates the survival curve from the model, much like we used `predict()` to generate
    predicted values earlier. Try `summary(out_cph)` to see the model, and `summary(out_surv)`
    to see the table of predicted values that will form the basis for our plot. Next
    we tidy `out_surv` to get a data frame, and plot it.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 适配的细节在这里并不重要，但在第一步中，`Surv()`函数为比例风险模型创建响应或结果变量，然后由`coxph()`函数进行拟合。然后，`survfit()`函数从模型创建生存曲线，就像我们之前使用`predict()`生成预测值一样。尝试`summary(out_cph)`来查看模型，以及`summary(out_surv)`来查看将构成我们图表基础的预测值表。接下来，我们将`out_surv`整理为一个data
    frame，并绘制它。
- en: '![A Kaplan-Meier plot.](../Images/1e961d36cc805682f5590795a7c245a4.png) Figure
    6.8: A Kaplan-Meier plot.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '![Kaplan-Meier图](../Images/1e961d36cc805682f5590795a7c245a4.png) 图6.8：Kaplan-Meier图。'
- en: '[PRE105]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 6.5.1 Get component-level statistics with tidy()
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1 使用tidy()获取组件级统计信息
- en: The `tidy()` function takes a model object and returns a data frame of component-level
    information. We can work with this to make plots in a familiar way, and much more
    easily than fishing inside the model object to extract the various terms. Here
    is an example, using the default results as just returned. For a more convenient
    display of the results, we will pipe the object we create with `tidy()` through
    a function that rounds the numeric columns of the data frame to two decimal places.
    This doesn’t change anything about the object itself, of course.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`tidy()`函数接受一个模型对象，并返回一个包含组件级信息的data frame。我们可以用这种方式与之交互，以熟悉的方式制作图表，比在模型对象内部提取各种术语要容易得多。以下是一个示例，使用刚刚返回的默认结果。为了更方便地显示结果，我们将使用`tidy()`创建的对象通过一个函数进行管道处理，该函数将data
    frame的数值列四舍五入到两位小数。当然，这不会改变对象本身的内容。'
- en: '[PRE106]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: We are now able to treat this data frame just like all the other data that we
    have seen so far.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以像对待迄今为止看到的所有其他数据一样处理这个data frame。
- en: '![Basic plot of OLS estimates.](../Images/86cb8182688f582ab5bf93d7c02069cb.png)
    Figure 6.5: Basic plot of OLS estimates.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '![OLS估计的基本图示](../Images/86cb8182688f582ab5bf93d7c02069cb.png) 图6.5：OLS估计的基本图示。'
- en: '[PRE108]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: We can extend and clean up this plot in a variety of ways. For example, we can
    tell `tidy()` to calculate confidence intervals for the estimates, using R’s `confint()`
    function.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过多种方式扩展和清理这个图表。例如，我们可以告诉`tidy()`使用R的`confint()`函数计算估计的置信区间。
- en: '[PRE109]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The convenience “not in” operator `%nin%` is available via the `socviz` library.
    It does the opposite of `%in%` and selects only the items in a first vector of
    characters that are not in the second. We’ll use it to drop the intercept term
    from the table. We also want to something about the labels. When fitting a model
    with categorical variables, R will create coefficient names based on the variable
    name and the category name, like `continentAmericas`. Normally we like to clean
    these up before plotting. Most commonly, we just want to strip away the variable
    name at the beginning of the coefficient label. For this we can use `prefix_strip()`,
    a convenience function in the `socviz` library. We tell it which prefixes to drop,
    using it to create a new column variable in `out_conf` that corresponds to the
    `terms` column, but that has nicer labels.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: “不在”运算符`%nin%`通过`socviz`库提供。它与`%in%`相反，仅选择第一个字符向量中不在第二个向量中的项。我们将使用它从表中删除截距项。我们还想对标签做一些处理。当拟合包含分类变量的模型时，R将根据变量名和类别名创建系数名称，例如`continentAmericas`。通常，我们在绘图之前会清理这些名称。最常见的是，我们只想从系数标签的开头去除变量名。为此，我们可以使用`prefix_strip()`，这是`socviz`库中的一个便利函数。我们告诉它要删除哪些前缀，使用它来在`out_conf`中创建一个新列变量，该变量对应于`terms`列，但具有更好的标签。
- en: '[PRE111]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Now we can use `geom_pointrange()` to make a figure that displays some information
    about our confidence in the variable estimates, as opposed to just the coefficients.
    As with the boxplots earlier, we use `reorder()` to sort the names of the model’s
    terms by the `estimate` variable, thus arranging our plot of effects from largest
    to smallest in magnitude.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用 `geom_pointrange()` 来制作一个显示我们对变量估计的信心信息的图形，而不是仅仅系数。与前面的箱线图一样，我们使用 `reorder()`
    按照估计变量对模型的项进行排序，从而将我们的效应图从大到小排列。
- en: '![A nicer plot of OLS estimates and confidence intervals.](../Images/388eb72c4d668c76c8c461f3b459c1de.png)
    Figure 6.6: A nicer plot of OLS estimates and confidence intervals.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '![OLS估计和置信区间的更漂亮的图形](../Images/388eb72c4d668c76c8c461f3b459c1de.png) 图6.6：OLS估计和置信区间的更漂亮的图形。'
- en: '[PRE112]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Dotplots of this kind can be very compact. The vertical axis can often be compressed
    quite a bit, with no loss in comprehension. In fact, they are often easier to
    read with much less room between the rows than given by a default square shape.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的点图可以非常紧凑。垂直轴通常可以压缩很多，而不会影响理解。事实上，它们通常在行与行之间有更少的间隔时更容易阅读，而不是默认的方形形状。
- en: 6.5.2 Get observation-level statistics with augment()
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.2 使用 augment() 获取观测级统计信息
- en: 'The values returned by `augment()` are all statistics calculated at the level
    of the original observations. As such, they can be added on to the data frame
    that the model is based on. Working from a call to `augment()` will return a data
    frame with all the original observations used in the estimation of the model,
    together with columns like the following:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`augment()` 返回的值都是计算在原始观测水平上的统计数据。因此，它们可以添加到模型基于的数据框中。从对 `augment()` 的调用开始，将返回一个包含用于模型估计的所有原始观测值的数据框，以及以下列之类的列：'
- en: '`.fitted` — The fitted values of the model.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.fitted` — 模型的拟合值。'
- en: '`.se.fit` — The standard errors of the fitted values.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.se.fit` — 拟合值的标准误差。'
- en: '`.resid` — The residuals.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.resid` — 残差。'
- en: '`.hat` — The diagonal of the hat matrix.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.hat` — 帽子矩阵的对角线。'
- en: '`.sigma` — An estimate of residual standard deviation when the corresponding
    observation is dropped from the model.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.sigma` — 当从模型中删除相应的观测值时，残差标准差的估计。'
- en: '`.cooksd` — Cook’s distance, a common regression diagnostic; and'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.cooksd` — 库克距离，一个常见的回归诊断；以及'
- en: '`.std.resid` — The standardized residuals.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.std.resid` — 标准化残差。'
- en: Each of these variables is named with a leading dot, for example `.hat` rather
    than `hat`, and so on. This is to guard against accidentally confusing it with
    (or accidentally overwriting) an existing variable in your data with this name.
    The columns of values return will differ slightly depending on the class of model
    being fitted.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些变量都以一个前置点命名，例如 `.hat` 而不是 `hat`，依此类推。这样做是为了防止意外将其与（或意外覆盖）具有相同名称的现有变量混淆。返回的值列将根据所拟合模型的类别略有不同。
- en: '[PRE113]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'By default, `augment()` will extract the available data from the model object.
    This will usually include the variables used in the model itself, but not any
    additional ones contained in the original data frame. Sometimes it is useful to
    have these. We can add them by specifying the `data` argument:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`augment()` 将从模型对象中提取可用的数据。这通常包括模型本身使用的变量，但不包括原始数据框中包含的任何附加变量。有时这些变量是有用的。我们可以通过指定
    `data` 参数来添加它们：
- en: '[PRE115]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: If some rows containing missing data were dropped to fit the model, then these
    will not be carried over to the augmented data frame.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为了拟合模型而删除了一些包含缺失数据的行，那么这些行将不会传递到增强数据框中。
- en: The new columns created by `augment()` can be used to create some standard regression
    plots. For example, we can plot the residuals versus the fitted values. Figure
    [6.7](modeling.html#fig:ch-06-augresid) suggests, unsurprisingly, that our country-year
    data has rather more structure than is captured by our OLS model.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`augment()` 创建的新列可以用来创建一些标准的回归图。例如，我们可以绘制残差与拟合值的对比图。图[6.7](modeling.html#fig:ch-06-augresid)表明，不出所料，我们的国家-年数据比我们的OLS模型所捕捉的结构要多得多。'
- en: '![Residuals vs Fitted Values.](../Images/43cf2a062d66ee897fa121dbf99503c9.png)
    Figure 6.7: Residuals vs Fitted Values.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '![残差与拟合值对比图](../Images/43cf2a062d66ee897fa121dbf99503c9.png) 图6.7：残差与拟合值对比图。'
- en: '[PRE117]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 6.5.3 Get model-level statistics with glance()
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.3 使用 glance() 获取模型级统计信息
- en: This function organizes the information typically presented at the bottom of
    a model’s `summary()` output. By itself, it usually just returns a table with
    a single row in it. But as we shall see in a moment, the real power of `broom`’s
    approach is the way that it can scale up to cases where we are grouping or subsampling
    our data.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数组织了通常在模型`summary()`输出底部的信息。它本身通常只返回一个包含单行的表格。但正如我们一会儿将看到的，`broom`方法的真正力量在于它能够扩展到我们分组或子采样数据的情况。
- en: '[PRE118]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Broom is able to tidy (and augment, and glance at) a wide range of model types.
    Not all functions are available for all classes of model. Consult broom’s documentation
    for more details on what is available. For example, here is a plot created from
    the tidied output of an event-history analysis. First we generate a Cox proportional
    hazards model of some survival data.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: Broom能够整理（以及增强、浏览）广泛的模型类型。并非所有函数都适用于所有模型类别。有关可用性的更多详细信息，请参阅broom的文档。例如，这里是一个从事件历史分析整理输出创建的图表。首先，我们生成一些生存数据的Cox比例风险模型。
- en: '[PRE120]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The details of the fit are not important here, but in the first step the `Surv()`
    function creates the response or outcome variable for the proportional hazards
    model that is then fitted by the `coxph()` function. Then the `survfit()` function
    creates the survival curve from the model, much like we used `predict()` to generate
    predicted values earlier. Try `summary(out_cph)` to see the model, and `summary(out_surv)`
    to see the table of predicted values that will form the basis for our plot. Next
    we tidy `out_surv` to get a data frame, and plot it.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 适配的细节在这里并不重要，但在第一步中，`Surv()`函数为比例风险模型创建响应或结果变量，然后由`coxph()`函数进行拟合。然后，`survfit()`函数从模型中创建生存曲线，就像我们之前使用`predict()`生成预测值一样。尝试`summary(out_cph)`来查看模型，以及`summary(out_surv)`来查看将构成我们绘图基础的预测值表格。接下来，我们将`out_surv`整理成数据框，并绘制它。
- en: '![A Kaplan-Meier plot.](../Images/1e961d36cc805682f5590795a7c245a4.png) Figure
    6.8: A Kaplan-Meier plot.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '![一个Kaplan-Meier图。](../Images/1e961d36cc805682f5590795a7c245a4.png) 图6.8：一个Kaplan-Meier图。'
- en: '[PRE121]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 6.6 Grouped analysis and list columns
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 分组分析和列表列
- en: Broom makes it possible to quickly fit models to different subsets of your data
    and get consistent and usable tables of results out the other end. For example,
    let’s say we wanted to look at the gapminder data by examining the relationship
    between life expectancy and GDP by *continent*, for each year in the data.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: Broom使得快速将模型拟合到数据的不同子集，并从另一端获得一致且可用的结果表格成为可能。例如，假设我们想通过检查寿命预期和GDP之间的*大陆*关系来查看gapminder数据，对于数据中的每一年的情况。
- en: 'The `gapminder` data is at bottom organized by country-years. That is the unit
    of observation in the rows. If we wanted, we could take a slice of the data manually,
    such as “all countries observed in Asia, in 1962” or “all in Africa, 2002”. Here
    is “Europe, 1977”:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`gapminder`数据在底部按国家-年份组织。这是行中的观测单位。如果我们想的话，我们可以手动切取数据的一部分，例如“1962年观察到的所有亚洲国家”或“2002年的所有非洲国家”。这里是“1977年的欧洲”：'
- en: '[PRE122]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'We could then see what the relationship between life expectancy and GDP looked
    like for that continent-year group:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以接着看到该大陆-年份组中寿命预期和GDP之间的关系：
- en: '[PRE123]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'With `dplyr` and `broom` we can do this for every continent-year slice of the
    data in a compact and tidy way. We start with our table of data, and then (`%>%`)
    group the countries by `continent` and `year` using the `group_by()` function.
    We introduced this grouping operation in Chapter [4](groupfacettx.html#groupfacettx).
    Our data is reorganized first by continent, and within continent by year. Here
    we will take one further step and *nest* the data that make up each group:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dplyr`和`broom`，我们可以以紧凑和整洁的方式对数据中的每个大陆-年份切片进行此操作。我们从一个数据表开始，然后使用`group_by()`函数按`continent`和`year`对国家进行分组。我们在第[4](groupfacettx.html#groupfacettx)章中介绍了这种分组操作。我们的数据首先按大陆重新组织，然后在大陆内部按年份组织。这里我们将进一步一步，并将构成每个组的数据*嵌套*：
- en: '[PRE125]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Think of what `nest()` does as a more intensive version what `group_by()` does.
    The resulting object is has the tabular form we expect (it is a tibble) but it
    looks a little unusual. The first two columns are the familiar `continent` and
    `year`. But we now also have a new column, `data`, that contains a small table
    of data corresponding to each continent-year group. This is a *list column*, something
    we have not seen before. It turns out to be very useful for bundling together
    complex objects (structured, in this case, as a list of tibbles, each being a
    33x4 table of data) within the rows of our data (which remains tabular). Our “Europe
    1977” fit is in there. We can look at it, if we like, by filtering the data and
    then *unnesting* the list column.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 将`nest()`函数的作用想象成是`group_by()`函数的更加强化的版本。结果对象具有我们预期的表格形式（它是一个tibble），但看起来有点不寻常。前两列是熟悉的`continent`和`year`。但现在我们还有一个新的列`data`，它包含与每个大陆-年份组对应的小型数据表。这是一个列表列，我们之前没有见过。它实际上在将复杂对象（在这种情况下，作为tibbles的列表，每个都是一个33x4的数据表）捆绑到我们的数据行中（数据仍然保持表格形式）时非常有用。我们的“欧洲1977”拟合就在那里。如果我们愿意，可以通过过滤数据然后*解包*列表列来查看它。
- en: '[PRE127]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: List columns are useful because we can act on them in a compact and tidy way.
    In particular, we can pass functions along to each row of the list column and
    make something happen. For example, a moment ago we ran a regression of life expectancy
    and logged GDP for European countries in 1977\. We can do that for every continent-year
    combination in the data. We first create a convenience function called `fit_ols()`
    that takes a single argument, `df` (for data frame) and that fits the linear model
    we are interested in. ThenThe map action is an important idea in functional programming.
    If you have written code in other, more imperative languages you can think of
    it as a compact alternative to writing for … next loops. You can of course write
    loops like this in R. Computationally they are often not any less efficient than
    their functional alternatives. But mapping functions to arrays is more easily
    integrated into a sequence of data transformations. we *map* that function to
    each of our list column rows in turn. Recall from Chapter [4](groupfacettx.html#groupfacettx)
    that `mutate` creates new variables or columns on the fly within a pipeline.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 列表列非常有用，因为我们可以在紧凑和整洁的方式下对它们进行操作。特别是，我们可以将函数传递给列表列的每一行，并使其发生某些变化。例如，刚才我们运行了1977年欧洲国家的预期寿命和GDP的对数回归。我们可以对数据中的每个大陆-年份组合都这样做。我们首先创建了一个方便的函数`fit_ols()`，它接受一个参数`df`（代表数据框）并拟合我们感兴趣的线性模型。然后，映射操作是函数式编程中的一个重要概念。如果你在其他更命令式的语言中编写过代码，你可以将其视为编写for
    … next循环的紧凑替代方案。当然，你可以在R中编写这样的循环。在计算上，它们通常并不比它们的函数式替代方案效率低。但是，将函数映射到数组中更容易集成到一系列数据转换中。我们依次将这个函数映射到我们的列表列的每一行。回想一下第[4](groupfacettx.html#groupfacettx)章，`mutate`函数可以在管道中动态创建新变量或列。
- en: '[PRE129]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Before starting the pipeline we create a new function: It is a convenience
    function whose only job is to estimate a particular OLS model on some data. Like
    almost everything in R, functions are a kind of object. To make a new one, we
    use the slightly special `function()` function. (Nerds love that sort of thing.)
    There is a little more detail on creating functions in the Appendix. To see what
    `fit_ols()` looks like once it is created, type `fit_ols` without parentheses
    at the Console. To see what it does, try `fit_ols(df = gapminder)`, or `summary(fit_ols(gapminder))`.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始管道之前，我们创建了一个新的函数：这是一个方便的函数，它的唯一任务是估计某些数据上的特定OLS模型。像R中的几乎所有东西一样，函数是一种对象。要创建一个新的函数，我们使用稍微特殊的`function()`函数。（极客们喜欢这类东西。）附录中有更多关于创建函数的细节。要查看创建后的`fit_ols()`函数的样子，请在控制台中输入`fit_ols`而不带括号。要查看它做了什么，尝试`fit_ols(df
    = gapminder)`，或者`summary(fit_ols(gapminder))`。
- en: 'Now we have two list columns: `data`, and `model`. The latter was created by
    mapping the `fit_ols()` function to each row of `data`. Inside each element of
    `model` is a linear model for that continent-year. So we now have sixty OLS fits,
    one for every continent-year grouping. Having the models inside the list column
    is not much use to us in and of itself. But we can extract the information we
    want while keeping things in a tidy tabular form. For clarity we will run the
    pipeline from the beginning again, this time adding a few new steps.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个列表列：`data`和`model`。后者是通过将`fit_ols()`函数映射到`data`的每一行来创建的。`model`中的每个元素都是该大陆-年份的线性模型。因此，我们现在有六十个OLS拟合，每个大陆-年份分组一个。仅仅在列表列中拥有模型对我们来说并没有太大的用处。但我们可以提取我们想要的信息，同时保持整洁的表格形式。为了清晰起见，我们将从开始再次运行管道，这次添加了一些新步骤。
- en: First we extract summary statistics from each model by mapping the `tidy()`
    function from broom to the model list column. Then we unnest the result, dropping
    the other columns in the process. Finally, we filter out all the Intercept terms,
    and also drop all observations from Oceania. In the case of the Intercepts we
    do this just out of convenience. Oceania we drop just because there are so few
    observations. We put the results in an object called `out_tidy`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过将broom中的`tidy()`函数映射到模型列表列来从每个模型中提取汇总统计信息。然后我们解包结果，在这个过程中删除了其他列。最后，我们过滤掉所有截距项，并且也删除了所有来自大洋洲的观测值。在截距的情况下，我们这样做只是为了方便。我们删除大洋洲是因为那里观测值很少。我们将结果放入一个名为`out_tidy`的对象中。
- en: '[PRE131]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: We now have tidy regression output with an estimate of the association between
    log GDP per capita and life expectancy for each year, within continents. We can
    plot these estimates in a way that takes advantage of their groupiness.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了整洁的回归输出，其中包含了每个年份、大陆内部每 capita GDP的对数与预期寿命之间的关联估计。我们可以以利用它们分组性的方式绘制这些估计。
- en: '[PRE133]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '![Yearly estimates of the association between GDP and Life Expectancy, pooled
    by continent.](../Images/23ad9adc4c5e240c3e5b24eb5be2ec2f.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![按大陆汇总的GDP与预期寿命之间的年度估计关联](../Images/23ad9adc4c5e240c3e5b24eb5be2ec2f.png)'
- en: 'Figure 6.9: Yearly estimates of the association between GDP and Life Expectancy,
    pooled by continent.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：按大陆汇总的GDP与预期寿命之间的年度估计关联。
- en: The call to `position_dodge()` within `geom_pointrange()` allows the point ranges
    for each continent to be near each other within years, instead of being plotted
    right on top of one another. We could have faceted the results by continent, but
    doing it this way lets us see differences in the yearly estimates much more easily.
    This technique is very useful not just for cases like this, but also when you
    want to compare the coefficients given by different kinds of statistical model.
    This sometimes happens when we’re interested in seeing how, say, OLS performs
    against some other model specification.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在`geom_pointrange()`中的`position_dodge()`调用允许每个大陆的点范围在年份内彼此靠近，而不是直接绘制在彼此之上。我们本可以通过大陆进行分面，但这样做可以让我们更容易地看到年度估计的差异。这种技术不仅对这种情况很有用，而且在你想比较不同类型的统计模型给出的系数时也非常有用。当我们对比较，比如说OLS与其他模型规范的表现感兴趣时，这种情况有时会发生。
- en: 6.7 Plot marginal effects
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7 绘制边缘效应图
- en: Our earlier discussion of `predict()` was about obtaining estimates of the average
    effect of some coefficient, net of the other terms in the model. Over the past
    decade, estimating and plotting *partial* or *marginal effects* from a model has
    become an increasingly common way of presenting accurate and interpretively useful
    predictions. Interest in marginal effects plots was stimulated by the realization
    that the interpretation of terms in logistic regression models, in particular,
    was trickier than it seemed—especially when there were interaction terms in the
    model (Ai & Norton, 2003). Thomas Leeper’s `margins` package can make these plots
    for us.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前关于`predict()`的讨论是关于从模型中获取某些系数的平均效应的估计，扣除模型中的其他项。在过去十年中，从模型中估计和绘制*部分*或*边缘效应*已成为一种越来越常见的准确且具有解释性预测的展示方式。边缘效应图的热潮是由这样一个认识引发的，即逻辑回归模型中项的解释比看起来要复杂——特别是在模型中有交互项时（Ai
    & Norton, 2003）。托马斯·利珀的`margins`包可以为我们制作这些图表。
- en: '[PRE134]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: To see it in action, we’ll take another look at the General Social Survey data
    in `gss_sm`, this time focusing on the binary variable, `obama`.As is common with
    retrospective questions on elections, rather more people claim to have voted for
    Obama than is consistent with the vote share he received in the election. It is
    coded `1` if the respondent said they voted for Barack Obama in the 2012 presidential
    election, and `0` otherwise. In this case, mostly for convenience here, the zero
    code includes all other answers to the question, including those who said they
    voted for Mitt Romney, those who said they did not vote, those who refused to
    answer, and those who said they didn’t know who they voted for. We will fit a
    logistic regression on `obama`, with `age`, `polviews`, `race`, and `sex` as the
    predictors. The `age` variable is the respondent’s age in years. The `sex` variable
    is coded as “Male” or “Female” with “Male” as the reference category. The `race`
    variable is coded as “White”, “Black”, or “Other” with “White” as the reference
    category. The `polviews` measure is a self-reported scale of the respondent’s
    political orientation from “Extremely Conservative” through “Extremely Liberal”,
    with “Moderate” in the middle. We take `polviews` and create a new variable, `polviews_m`,
    using the `relevel()` function to recode “Moderate” to be the reference category.
    We fit the model with the `glm()` function, and specify an interaction between
    `race` and `sex`.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到它的实际应用，我们将再次查看`gss_sm`中的综合社会调查数据，这次重点关注二元变量`obama`。与选举的回顾性问题一样，声称投票给奥巴马的人数比他在选举中获得的选票份额要多得多。如果受访者表示他们在2012年总统选举中投票给了巴拉克·奥巴马，则编码为`1`，否则为`0`。在这种情况下，主要是为了方便，零编码包括所有其他问题的答案，包括那些表示他们投票给了米特·罗姆尼的人，那些表示他们没有投票的人，那些拒绝回答的人，以及那些表示他们不知道自己投给了谁的人。我们将对`obama`进行逻辑回归，以`age`、`polviews`、`race`和`sex`作为预测变量。`age`变量是受访者的年龄（以年为单位）。`sex`变量编码为“Male”或“Female”，其中“Male”为参照类别。`race`变量编码为“White”、“Black”或“Other”，其中“White”为参照类别。`polviews`衡量标准是受访者政治倾向的自我报告量表，从“极端保守”到“极端自由”，中间为“Moderate”。我们使用`polviews`并创建一个新变量`polviews_m`，使用`relevel()`函数将“Moderate”重新编码为参照类别。我们使用`glm()`函数拟合模型，并指定`race`和`sex`之间的交互作用。
- en: '[PRE135]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The summary reports the coefficients and other information. We can now graph
    the data in any one of several ways. Using `margins()` we calculate the marginal
    effects for each variable:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要报告了系数和其他信息。我们现在可以用几种方式中的任何一种来绘制数据。使用`margins()`，我们计算每个变量的边际效应：
- en: '[PRE137]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: The `margins` library comes with several plot methods of its own. If you wish,
    at this point you can just try `plot(bo_m)` to see a plot of the average marginal
    effects, produced with the general look of a Stata graphic. Other plot methods
    in the `margins` library include `cplot()`, which visualizes marginal effects
    conditional on a second variable, and `image()`, which shows predictions or marginal
    effects as a filled heatmap or contour plot.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`margins`库自带几种绘图方法。如果你愿意，现在你可以尝试`plot(bo_m)`来查看平均边际效应的图形，其外观类似于Stata图形。`margins`库中的其他绘图方法包括`cplot()`，它根据第二个变量可视化边际效应，以及`image()`，它显示预测或边际效应作为填充热图或等高线图。'
- en: Alternatively, we can take results from `margins()` and plot them ourselves.
    To clean up the summary a little a little, we convert it to a tibble, then use
    `prefix_strip()` and `prefix_replace()` to tidy the labels. We want to strip the
    `polviews_m` and `sex` prefixes, and (to avoid ambiguity about “Other”), adjust
    the `race` prefix.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以从`margins()`获取结果并自行绘制。为了稍微整理一下摘要，我们将其转换为tibble，然后使用`prefix_strip()`和`prefix_replace()`整理标签。我们想要去除`polviews_m`和`sex`的前缀，并且（为了避免关于“Other”的歧义），调整`race`的前缀。
- en: '[PRE139]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Now we have a table that we can plot as we have learned:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以绘制的表格，就像我们学过的那样：
- en: '[PRE141]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Figure 6.10: Average marginal effects plot.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10：平均边际效应图。
- en: '![Average marginal effects plot.](../Images/2dd558be4bdff7c74737e947984bbc4f.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![平均边际效应图。](../Images/2dd558be4bdff7c74737e947984bbc4f.png)'
- en: 'If we are just interested in getting conditional effects for a particular variable,
    then conveniently we can ask the plot methods in the margins library to do the
    work calculating effects for us but without drawing their plot. Instead, they
    can return the results in a format we can easily use in ggplot, and with less
    need for clean up, for the clean-up. For example, with `cplot()`:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想获取特定变量的条件效应，那么方便的是，我们可以要求 `margins` 库中的绘图方法为我们计算效应，但不需要绘制它们的图。相反，它们可以以我们可以轻松使用的格式返回结果，并且需要较少的清理工作。例如，使用
    `cplot()`：
- en: '![Conditional effects plot.](../Images/8ac0e7da6d09561016fd87ab560c2c2a.png)
    Figure 6.11: Conditional effects plot.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '![条件效应图。](../Images/8ac0e7da6d09561016fd87ab560c2c2a.png) 图 6.11：条件效应图。'
- en: '[PRE142]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The margins package is under active development. It can do much more than described
    here. The vignettes that come with the package provide more extensive discussion
    and numerous examples.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`margins` 包正在积极开发中。它可以做比这里描述的更多的事情。随包提供的示例提供了更广泛的讨论和许多示例。'
- en: 6.8 Plots from complex surveys
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.8 复杂调查的图
- en: Social scientists often work with data collected using a complex survey design.
    Survey instruments may be stratified by region or some other characteristic, contain
    replicate weights to make them comparable to a reference population, have a clustered
    structure, and so on. In Chapter [4](groupfacettx.html#groupfacettx) we learned
    how calculate and then plot frequency tables of categorical variables, using some
    data from the General Social Survey (GSS). However, if we want accurate estimates
    of US households from the GSS, we will need to take the survey’s design into account,
    and use the survey weights provided in the dataset. Thomas Lumley’s `survey` library
    provides a comprehensive set of tools for addressing these issues. The tools and
    the theory behind them are discussed in detail in Lumley (2010), and an overview
    of the package is provided in Lumley (2004). While the functions in the `survey`
    package are straightforward to use and return results in a generally tidy form,
    the package predates the tidyverse and its conventions by several years. This
    means we cannot use `survey` functions directly with `dplyr`. However, Greg Freedman
    Ellis has written a helper package, `srvyr`, that solves this problem for us,
    and lets us use the `survey` library’s functions within a data analysis pipeline
    in a familiar way.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 社会科学家通常使用复杂调查设计收集的数据。调查工具可能按地区或其他特征分层，包含重复权重以使其与参考人群可比，具有集群结构，等等。在第 [4](groupfacettx.html#groupfacettx)
    章节中，我们学习了如何使用来自一般社会调查（GSS）的一些数据计算并绘制分类变量的频率表。然而，如果我们想从 GSS 中获得准确的美国家庭估计值，我们需要考虑调查的设计，并使用数据集中提供的调查权重。Thomas
    Lumley 的 `survey` 库提供了一套全面的工具来解决这些问题。这些工具及其背后的理论在 Lumley (2010) 中有详细讨论，而在 Lumley
    (2004) 中提供了包的概述。虽然 `survey` 包中的函数使用简单，并以整洁的形式返回结果，但该包比 tidyverse 及其惯例早几年。这意味着我们无法直接使用
    `survey` 函数与 `dplyr` 一起使用。然而，Greg Freedman Ellis 编写了一个辅助包 `srvyr`，它为我们解决了这个问题，并允许我们以熟悉的方式在数据分析管道中使用
    `survey` 库的函数。
- en: For example, the `gss_lon` data contains a small subset of measures from every
    wave of the GSS since its inception in 1972\. It also contains several variables
    that describe the design of the survey and provide replicate weights for observations
    in various years. These technical details are described in the GSS documentation.
    Similar information is typically provided by other complex surveys. Here we will
    use this design information to calculate weighted estimates of the distribution
    of educational attainment by race, for selected survey years from 1976 to 2016.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`gss_lon` 数据包含自 1972 年 GSS 成立以来的每一波次的一小部分测量值。它还包含几个描述调查设计和为不同年份的观测值提供重复权重的变量。这些技术细节在
    GSS 文档中有描述。类似的信息通常由其他复杂调查提供。在这里，我们将使用这些设计信息来计算 1976 年至 2016 年选定调查年份的教育成就分布的加权估计值。
- en: To begin, we load the `survey` and `srvyr` libraries.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们加载 `survey` 和 `srvyr` 库。
- en: '[PRE143]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Next, we take our `gss_lon` dataset and use the `survey` tools to create a
    new object that contains the data, as before, but with some additional information
    about the survey’s design:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `survey` 工具将我们的 `gss_lon` 数据集创建为一个新对象，就像之前一样，但包含有关调查设计的一些附加信息：
- en: '[PRE144]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The two `options` set at the beginning provide some information to the `survey`
    library about how to behave. You should consult Lumley (2010) and the `survey`
    package documentation for details. The subsequent operations create `gss_wt`,
    an object with one additional column (`stratvar`), describing the yearly sampling
    strata. We use the `interaction()` function to do this. It multiplies the `vstrat`
    variable by the `year` variable to get a vector of stratum information for each
    year.We have to do this because of the way the GSS codes its stratum information.
    In the next step, we use the `as_survey_design()` function to add the key pieces
    of information about the survey design. It adds information about the sampling
    identifiers (`ids`), the strata (`strata`), and the replicate weights (`weights`).
    With those in place we can take advantage of a large number of specialized functions
    in the `survey` library that allow us to calculate properly weighted survey means
    or estimate models with the correct sampling specification. For example, we can
    easily calculate the distribution of education by race for a series of years from
    1976 to 2016\. We use `survey_mean()` to do this:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时设置的 `two options` 为 `survey` 库提供了有关如何行为的一些信息。您应该查阅 Lumley (2010) 和 `survey`
    包文档以获取详细信息。后续操作创建了一个名为 `gss_wt` 的对象，它有一个额外的列（`stratvar`），描述了每年的抽样层。我们使用 `interaction()`
    函数来完成此操作。它将 `vstrat` 变量乘以 `year` 变量，以获取每年层信息的向量。我们必须这样做，因为 GSS 以这种方式编码层信息。在下一步中，我们使用
    `as_survey_design()` 函数添加有关调查设计的关键信息。它添加有关抽样标识符（`ids`）、层（`strata`）和重复权重（`weights`）的信息。有了这些信息，我们可以利用
    `survey` 库中的大量专用函数，这些函数允许我们正确计算加权调查均值或使用正确的抽样规范估计模型。例如，我们可以轻松地计算从 1976 年到 2016
    年的一系列年份中按种族划分的教育分布。我们使用 `survey_mean()` 来完成此操作：
- en: '[PRE145]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: The results returned in `out_grp` include standard errors. We can also ask `survey_mean()`
    to calculate confidence intervals for us, if we wish.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 `out_grp` 的结果包括标准误差。如果我们希望，我们还可以要求 `survey_mean()` 为我们计算置信区间。
- en: 'Grouping with `group_by()` lets us calculate counts or means for the innermost
    variable, grouped by the next variable “up” or “out”, in this case, `degree` by
    `race`, such that the proportions for `degree` will sum to one for each group
    in `race`, and this will be done separately for each value of `year`. If we want
    the *marginal* frequencies, such that the values for all combinations of `race`
    and `degree` sum to one within each year, we first have to interact the variables
    we are cross-classifying. Then we group by the new interacted variable and do
    the calculation as before:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `group_by()` 进行分组允许我们计算最内层变量的计数或平均值，按下一个“向上”或“向外”的变量分组，在这种情况下，按 `degree`
    和 `race` 分组，这样 `degree` 的比例将对于 `race` 中的每个组加起来等于一，并且对于 `year` 的每个值都将单独完成。如果我们想得到
    *边缘* 频率，即所有 `race` 和 `degree` 组合的值在每年内加起来等于一，我们首先必须交叉分类变量。然后按新的交互变量进行分组，并像以前一样进行计算：
- en: '[PRE147]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: This gives us the numbers that we want and returns them in a tidy data frame.
    The `interaction()` function produces variable labels that are a compound of the
    two variables we interacted, with each combination of categories separated by
    a period, (such as `White.Graduate`. However, perhaps we would like to see these
    categories as two separate columns, one for race and one for education, as before.
    Because the variable labels are organized in a predictable way, we can use one
    of the convenient functions in the tidyverse’s `tidyr` library to separate the
    single variable into two columns while correctly preserving the row values. Appropriately,
    this function is called `separate()`.The two backslashes before the period in
    the call to `separate` are necessary for R to interpret it literally as a period.
    By default in search and replace operations like this, the search terms are regular
    expressions. The period acts as a special character, a kind of wildcard, meaning
    ‘any character at all’. To make the regular expression engine treat it literally,
    we add one backslash before it. The backslash is an ‘escape’ character. It means
    ‘The next character is going to be treated differently from usual’. However, because
    the backslash is a special character as well, we need to add a second backslash
    to make sure the parser sees it properly.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们想要的数字，并以整洁的数据框形式返回。`interaction()`函数产生变量标签，它是我们所交互的两个变量的复合，每个类别的组合由句点分隔（例如`White.Graduate`）。然而，我们可能希望将这些类别作为两个单独的列来查看，一个用于种族，一个用于教育，就像之前一样。由于变量标签以可预测的方式组织，我们可以使用tidyverse的`tidyr`库中的一个方便的函数将单个变量分离成两列，同时正确保留行值。恰当地，这个函数被称为`separate()`。在`separate`调用中句点前的两个反斜杠对于R将其字面地解释为句点来说是必要的。在默认的搜索和替换操作中，搜索项是正则表达式。句点作为特殊字符，是一种通配符，意味着“任何字符”。为了使正则表达式引擎将其字面地处理，我们在其前面添加一个反斜杠。反斜杠是一个“转义”字符。它的意思是“下一个字符将被以不同于通常的方式处理”。然而，因为反斜杠本身也是一个特殊字符，我们需要添加第二个反斜杠以确保解析器正确地看到它。
- en: '[PRE149]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: The call to `separate()` says to take the `racedeg` column, split each value
    when it sees a period, and reorganize the results into two columns, `race` and
    `degree`. This gives us a tidy table much like `out_grp`, but for the marginal
    frequencies.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`separate()`函数的调用表示取`racedeg`列，当遇到句点时分割每个值，并将结果重新组织为两列，`race`和`degree`。这给我们一个整洁的表格，类似于`out_grp`，但用于边际频率。'
- en: Reasonable people can disagree over how best to plot a small multiple of a frequency
    table while faceting by year, especially when there is some measure of uncertainty
    attached. A barplot is the obvious approach for a single case, but when there
    are many years it can become difficult to compare bars across panels. This is
    especially the case when standard errors or confidence intervals are used in conjunction
    with bars.Sometimes it may be preferable to show that the underlying variable
    is categorical, as a bar chart makes clear, and not continuous, as a line graph
    suggests. Here the trade-off is in favor of the line graphs as the bars are very
    hard to compare across facets. This is sometimes called a “dynamite plot”, not
    because it looks amazing but because the t-shaped error bars on the tops of the
    columns make them look like cartoon dynamite plungers. An alternative is to use
    a line graph to join up the time observations, faceting on educational categories
    instead of year. Figure [6.12](modeling.html#fig:ch-06-svyyears) shows the results
    for our GSS data in dynamite-plot form, where the error bars are defined as twice
    the standard error in either direction around the point estimate.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 合理的人可能会对如何在按年份分面时如何最好地绘制频率表的小倍数产生分歧，尤其是在存在某种不确定性的情况下。对于单个案例，条形图是一种明显的方法，但当有很多年时，比较各面板之间的条形可能会变得困难。这尤其在使用标准误差或置信区间与条形结合时更为明显。有时，可能更倾向于显示基础变量是分类的，正如条形图所清楚显示的，而不是连续的，如折线图所暗示的。在这里，权衡倾向于折线图，因为条形在分面之间很难比较。这有时被称为“炸药图”，不是因为它的外观惊人，而是因为柱顶上的T形误差条使它们看起来像卡通炸药筒。一种替代方法是使用折线图连接时间观察结果，而不是按年份分面，而是按教育类别分面。图[6.12](modeling.html#fig:ch-06-svyyears)显示了我们的GSS数据以炸药图形式的结果，其中误差条定义为点估计周围标准误差的两倍。
- en: '[PRE151]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Figure 6.12: Weighted estimates of educational attainment for Whites and Blacks,
    GSS selected years 1976-2016\. Faceting barplots is often a bad idea, and the
    more facets there are the worse an idea it is. With a small-multiple plot the
    viewer wants to compare across panels (in this case, over time), but this is difficult
    to do when the data inside the panels are categorical comparisons shown as bars
    (in this case, education level by group).'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12：白人和黑人的加权教育成就估计，GSS选定年份1976-2016。分面条形图通常不是一个好主意，分面越多，这个主意就越糟糕。在小倍数图中，观众想要比较各面板（在这种情况下，按时间）之间的差异，但当面板内的数据是作为条形图显示的类别比较时，这很难做到。
- en: '![Weighted estimates of educational attainment for Whites and Blacks, GSS selected
    years 1976-2016\. Faceting barplots is often a bad idea, and the more facets there
    are the worse an idea it is. With a small-multiple plot the viewer wants to compare
    across panels (in this case, over time), but this is difficult to do when the
    data inside the panels are categorical comparisons shown as bars (in this case,
    education level by group).](../Images/1fe47b8275a8fdedb0c705fdb59bee6a.png)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![白人和黑人的加权教育成就估计，GSS选定年份1976-2016。分面条形图通常不是一个好主意，分面越多，这个主意就越糟糕。在小倍数图中，观众想要比较各面板（在这种情况下，按时间）之间的差异，但当面板内的数据是作为条形图显示的类别比较时，这很难做到。](../Images/1fe47b8275a8fdedb0c705fdb59bee6a.png)'
- en: This plot has a few cosmetic details and adjustments that we will learn more
    about in Chapter [8](refineplots.html#refineplots). As before, I encourage you
    to peel back the plot from the bottom, one instruction at a time, to see what
    changes. One useful adjustment to notice is the new call to the `scales` library
    to adjust the labels on the x-axis. The adjustment on the y-axis is familiar,
    `scales::percent` to convert the proportion to a percentage. On the x-axis, the
    issue is that several of the labels are rather long. If we do not adjust them
    they will print over one another. The `scales::wrap_format()` function will break
    long labels into lines. It takes a single numerical argument (here `10`) that
    is the maxmimum length a string can be before it is wrapped onto a new line.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表有一些外观细节和调整，我们将在第[8](refineplots.html#refineplots)章中了解更多。和之前一样，我鼓励你从底部开始，一次调整一个指令，看看发生了什么变化。一个有用的调整是新的`scales`库调用，用于调整x轴上的标签。y轴的调整是熟悉的，使用`scales::percent`将比例转换为百分比。在x轴上，问题是几个标签相当长。如果我们不调整它们，它们将相互重叠。`scales::wrap_format()`函数会将长标签拆分成多行。它接受一个单一的数值参数（这里为`10`），这是字符串在换行之前可以有的最大长度。
- en: '![Faceting by education instead.](../Images/c4e4a7dbf051feeb43ed1d4a236124ed.png)
    Figure 6.13: Faceting by education instead.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '![按教育程度分面。](../Images/c4e4a7dbf051feeb43ed1d4a236124ed.png) 图6.13：按教育程度分面。'
- en: A graph like this is true to the categorical nature of the data, while showing
    the breakdown of groups within each year. But you should experiment with some
    alternatives. For example, we might decide that it is better to facet by degree
    category instead, and put the year on the x-axis within each panel. If we do that,
    then we can use `geom_line()` to show a time trend, which is more natural, and
    `geom_ribbon()` to show the error range. This is perhaps a better way to show
    the data, especially as it brings out the time trends within each degree category,
    and allows us to see the similarities and differences by racial classification
    at the same time.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的图表忠实于数据的类别性质，同时展示了每年内各组的分解。但你应该尝试一些替代方案。例如，我们可能会决定按学位类别分面更好，并在每个面板中将年份放在x轴上。如果我们这样做，那么我们可以使用`geom_line()`来显示时间趋势，这更自然，并使用`geom_ribbon()`来显示误差范围。这可能是一种更好的展示数据的方式，特别是因为它突出了每个学位类别中的时间趋势，并允许我们同时看到种族分类的相似性和差异性。
- en: '[PRE152]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 6.9 Where to go next
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.9 接下来去哪里
- en: In general, when you estimate models and want to plot the results, the difficult
    step is not the plotting but rather calculating and extracting the right numbers.
    Generating predicted values and measures of confidence or uncertainty from models
    requires that you understand the model you are fitting, and the function you use
    to fit it, especially when it involves interactions, cross-level effects, or transformations
    of the predictor or response scales. The details can vary substantially from model
    type to model type, and also with the goals of any particular analysis. It is
    unwise to approach them mechanically. That said, several tools exist to help you
    work with model objects and produce a default set of plots from them.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你估计模型并想要绘制结果时，困难之处不在于绘图，而在于计算和提取正确的数字。从模型中生成预测值和置信度或不确定性的度量需要你理解你正在拟合的模型，以及你用来拟合它的函数，尤其是在涉及交互、跨级效应或预测变量或响应尺度变换的情况下。这些细节可能因模型类型而异，也因任何特定分析的目标而异。机械地处理它们是不明智的。话虽如此，仍有一些工具可以帮助你处理模型对象并从中生成默认的图表集。
- en: 6.9.1 Default plots for models
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9.1 模型的默认图表
- en: Just as model objects in R usually have a default `summary()` method, printing
    out an overview tailored to the type of model it is, they will usually have a
    default `plot()` method, too. Figures produced by `plot()` are typically not generated
    via ggplot, but it is usually worth exploring them. They typically make use of
    either R’s base graphics or the `lattice` library (Sarkar, 2008). These are two
    plotting systems that we do not cover in this book. Default plot methods are easy
    to examine. Let’s take a look again at our simple OLS model.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 R 中的模型对象通常有一个默认的 `summary()` 方法，打印出针对模型类型的概述一样，它们通常也有一个默认的 `plot()` 方法。`plot()`
    生成的图表通常不是通过 ggplot 生成的，但通常值得探索。它们通常使用 R 的基础图形或 `lattice` 库（Sarkar，2008）。这两个绘图系统我们在这本书中没有涉及。默认绘图方法很容易检查。让我们再次看看我们的简单
    OLS 模型。
- en: '[PRE153]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: To look at some of R’s default plots for this model, use the `plot()` function.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此模型的一些 R 的默认图表，请使用 `plot()` 函数。
- en: '[PRE154]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: The `which()` statement here selects the first two of four default plots for
    this kind of model. If you want to easily reproduce base R’s default model graphics
    using ggplot, the `ggfortify` library is worth examining. It is in some ways similar
    to `broom`, in that it tidies the output of model objects, but it focuses on producing
    a standard plot (or group of plots) for a wide variety of model types. It does
    this by defining a function called `autoplot()`. The idea is to be able to use
    `autoplot()` with the output of many different kinds of model.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的 `which()` 语句选择了此类模型的前两个默认图表。如果你想要轻松地使用 ggplot 重新生成 base R 的默认模型图形，那么 `ggfortify`
    库值得检查。它在某些方面与 `broom` 类似，因为它整理了模型对象的输出，但它专注于为各种模型类型生成标准图表（或图表组）。它是通过定义一个名为 `autoplot()`
    的函数来做到这一点的。想法是能够使用 `autoplot()` 与许多不同类型的模型输出一起使用。
- en: A second option worth looking at is the `coefplot` library. It provides a quick
    way to produce good-quality plots of point estimates and confidence intervals.
    It has the advantage of managing the estimation of interaction effects and other
    occasionally tricky calculations.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一看的第二个选项是 `coefplot` 库。它提供了一种快速生成高质量点估计和置信区间图表的方法。它具有管理交互效应和其他偶尔棘手计算的优势。
- en: '![A plot from coefplot.](../Images/33f6d7587e738968b391596c468ee85a.png) Figure
    6.14: A plot from coefplot.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '![coefplot 中的一个图表](../Images/33f6d7587e738968b391596c468ee85a.png) 图 6.14：coefplot
    中的一个图表。'
- en: '[PRE155]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 6.9.2 Tools in development
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9.2 开发中的工具
- en: Tidyverse tools for modeling and model exploration are being actively developed.
    The `broom` and `margins` libraries continue to get more and more useful. There
    are also other projects worth paying attention to. The `infer` package`infer.netlify.com`
    is in its early stages but can already do useful things in a pipeline-friendly
    way. You can install it from CRAN with `install.packages("infer")`.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: Tidyverse 的建模和模型探索工具正在积极开发中。`broom` 和 `margins` 库继续变得越来越有用。还有其他一些项目值得关注。`infer`
    包（`infer.netlify.com`）处于早期阶段，但已经可以通过管道友好的方式完成一些有用的事情。你可以通过 CRAN 使用 `install.packages("infer")`
    安装它。
- en: 6.9.3 Extensions to ggplot
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9.3 ggplot 的扩展
- en: The GGally package provides a suite of functions designed to make producing
    standard but somewhat complex plots a little easier. For instance, it can produce
    generalized pairs plots, a useful way of quickly examining possible relationships
    between several different variables at once. This sort of plot is like the visual
    version of a correlation matrix. It shows a bivariate plot for all pairs of variables
    in the data. This is relatively straightforward when all the variables are continuous
    measures. Things get more complex when, as is often the case in the social sciences,
    some or all variables are categorical or otherwise limited in the range of values
    they can take. A generalized pairs plot can handle these cases. For example, Figure
    [**??**](#fig:ch-06-ggallyplot) shows a generalized pairs plot for five variables
    from the `organdata` dataset.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: GGally 包提供了一套旨在使生成标准但相对复杂的图表变得更容易的函数。例如，它可以生成广义配对图，这是一种快速检查几个不同变量之间可能关系的有用方法。这种图表类似于相关矩阵的视觉版本。它显示了数据中所有变量对的二元图表。当所有变量都是连续测量时，这相对简单。当，正如社会科学中经常发生的那样，某些或所有变量是分类的或以其他方式限制了它们可以取的值的范围时，事情会变得更加复杂。广义配对图可以处理这些情况。例如，图[**??**](#fig:ch-06-ggallyplot)显示了
    `organdata` 数据集中五个变量的广义配对图。
- en: '[PRE156]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Multi-panel plots like this are intrinsically very rich in information. When
    combined with several within-panel types of representation, or any more than a
    modest number of variables, they can become quite complex. They should be used
    less for the presentation of finished work, although it is possible. More often
    they are a useful tool for the working researcher to quickly investigate aspects
    of a data set. The goal is not to pithily summarize a single point one already
    knows, but to open things up for further exploration.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 类似这样的多面板图表在信息上本质上是丰富的。当与多个面板内类型的表现方式相结合，或者变量数量超过适度时，它们可以变得相当复杂。虽然它们也可以用于展示已完成的工作，但通常它们是研究工作者快速调查数据集方面的有用工具。目标不是简洁地总结已知的一个点，而是为进一步的探索打开大门。
- en: 6.9.1 Default plots for models
  id: totrans-457
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9.1 模型的默认图表
- en: Just as model objects in R usually have a default `summary()` method, printing
    out an overview tailored to the type of model it is, they will usually have a
    default `plot()` method, too. Figures produced by `plot()` are typically not generated
    via ggplot, but it is usually worth exploring them. They typically make use of
    either R’s base graphics or the `lattice` library (Sarkar, 2008). These are two
    plotting systems that we do not cover in this book. Default plot methods are easy
    to examine. Let’s take a look again at our simple OLS model.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 R 中的模型对象通常有一个默认的 `summary()` 方法，打印出针对模型类型的概述一样，它们通常也有一个默认的 `plot()` 方法。`plot()`
    生成的图表通常不是通过 ggplot 生成的，但通常值得探索。它们通常使用 R 的基础图形或 `lattice` 库（Sarkar，2008）。这两个绘图系统我们在这本书中没有涉及。默认图表方法很容易检查。让我们再次看看我们的简单
    OLS 模型。
- en: '[PRE157]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: To look at some of R’s default plots for this model, use the `plot()` function.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此模型的一些 R 的默认图表，请使用 `plot()` 函数。
- en: '[PRE158]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: The `which()` statement here selects the first two of four default plots for
    this kind of model. If you want to easily reproduce base R’s default model graphics
    using ggplot, the `ggfortify` library is worth examining. It is in some ways similar
    to `broom`, in that it tidies the output of model objects, but it focuses on producing
    a standard plot (or group of plots) for a wide variety of model types. It does
    this by defining a function called `autoplot()`. The idea is to be able to use
    `autoplot()` with the output of many different kinds of model.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `which()` 语句选择了此类模型四个默认图表中的前两个。如果您想轻松地使用 ggplot 重新生成基础 R 的默认模型图形，那么 `ggfortify`
    库值得检查。它在某些方面与 `broom` 类似，因为它整理了模型对象的输出，但它专注于为各种模型类型生成标准图表（或图表组）。它是通过定义一个名为 `autoplot()`
    的函数来做到这一点的。想法是能够使用 `autoplot()` 与许多不同类型的模型输出一起使用。
- en: A second option worth looking at is the `coefplot` library. It provides a quick
    way to produce good-quality plots of point estimates and confidence intervals.
    It has the advantage of managing the estimation of interaction effects and other
    occasionally tricky calculations.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一看的第二个选项是 `coefplot` 库。它提供了一种快速生成高质量点估计和置信区间的图表的方法。它具有管理交互效应和其他偶尔棘手计算的优势。
- en: '![A plot from coefplot.](../Images/33f6d7587e738968b391596c468ee85a.png) Figure
    6.14: A plot from coefplot.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '![coefplot 中的一个图表](../Images/33f6d7587e738968b391596c468ee85a.png) 图6.14：coefplot
    中的一个图表。'
- en: '[PRE159]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 6.9.2 Tools in development
  id: totrans-466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9.2 开发中的工具
- en: Tidyverse tools for modeling and model exploration are being actively developed.
    The `broom` and `margins` libraries continue to get more and more useful. There
    are also other projects worth paying attention to. The `infer` package`infer.netlify.com`
    is in its early stages but can already do useful things in a pipeline-friendly
    way. You can install it from CRAN with `install.packages("infer")`.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: Tidyverse 工具正在积极开发中，用于建模和模型探索。`broom` 和 `margins` 库继续变得越来越有用。还有其他值得注意的项目。`infer`
    包（`infer.netlify.com`）处于早期阶段，但已经可以通过管道友好的方式完成一些有用的工作。您可以从 CRAN 使用 `install.packages("infer")`
    命令进行安装。
- en: 6.9.3 Extensions to ggplot
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9.3 ggplot 的扩展
- en: The GGally package provides a suite of functions designed to make producing
    standard but somewhat complex plots a little easier. For instance, it can produce
    generalized pairs plots, a useful way of quickly examining possible relationships
    between several different variables at once. This sort of plot is like the visual
    version of a correlation matrix. It shows a bivariate plot for all pairs of variables
    in the data. This is relatively straightforward when all the variables are continuous
    measures. Things get more complex when, as is often the case in the social sciences,
    some or all variables are categorical or otherwise limited in the range of values
    they can take. A generalized pairs plot can handle these cases. For example, Figure
    [**??**](#fig:ch-06-ggallyplot) shows a generalized pairs plot for five variables
    from the `organdata` dataset.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: GGally 包提供了一套旨在使生成标准但相对复杂的图表变得更容易的函数。例如，它可以生成广义配对图，这是一种快速检查几个不同变量之间可能关系的有用方法。这种图表类似于相关矩阵的视觉版本。它显示了数据中所有变量对的二元图。当所有变量都是连续测量时，这相对简单。当，正如社会科学中经常发生的那样，某些或所有变量是分类的或其值的范围有限时，事情会变得更加复杂。广义配对图可以处理这些情况。例如，图
    [**??**](#fig:ch-06-ggallyplot) 展示了来自 `organdata` 数据集的五个变量的广义配对图。
- en: '[PRE160]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Multi-panel plots like this are intrinsically very rich in information. When
    combined with several within-panel types of representation, or any more than a
    modest number of variables, they can become quite complex. They should be used
    less for the presentation of finished work, although it is possible. More often
    they are a useful tool for the working researcher to quickly investigate aspects
    of a data set. The goal is not to pithily summarize a single point one already
    knows, but to open things up for further exploration.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 类似这样的多面板图在信息上本质上是十分丰富的。当与多个面板内的表示类型结合，或者变量数量超过适度时，它们可以变得相当复杂。虽然它们也可以用于展示已完成的工作，但它们更常作为工作研究者快速调查数据集方面的有用工具。目标不是简洁地总结已知的一个点，而是为进一步的探索打开空间。
