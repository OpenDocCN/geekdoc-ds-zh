- en: Contract Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合同编程
- en: 原文：[https://en.algorithmica.org/hpc/compilation/contracts/](https://en.algorithmica.org/hpc/compilation/contracts/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/compilation/contracts/](https://en.algorithmica.org/hpc/compilation/contracts/)
- en: In “safe” languages like Java and Rust, you normally have well-defined behavior
    for every possible operation and every possible input. There are some things that
    are *under-defined*, like the order of keys in a hash table or the growth factor
    of an `std::vector`, but these are usually some minor details that are left up
    to implementation for potential performance gains in the future.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在“安全”的语言如Java和Rust中，你通常对每个可能的操作和每个可能的输入都有明确定义的行为。有一些事情是*未定义的*，比如哈希表中键的顺序或`std::vector`的增长因子，但这些通常是些微不足道的小细节，留给实现以备未来可能获得性能提升。
- en: In contrast, C and C++ take the concept of undefined behavior to another level.
    Certain operations don’t cause an error during compilation or runtime but are
    just not *allowed* — in the sense of there being a *contract* between the programmer
    and the compiler, that in case of undefined behavior, the compiler is legally
    allowed to do literally anything, including blowing up your monitor or formatting
    your hard drive. But compiler engineers are not interested in doing that. Instead,
    undefined behavior is used to guarantee a lack of corner cases and help optimization.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，C和C++将未定义行为的概念提升到了另一个层次。某些操作在编译或运行时不会引发错误，但它们是不被*允许的*——在程序员和编译器之间存在一种*合同*，即如果出现未定义行为，编译器在法律上被允许做任何事情，包括炸毁你的显示器或格式化你的硬盘。但编译器工程师对此不感兴趣。相反，未定义行为被用来保证没有边缘情况，并帮助优化。
- en: '### [#](https://en.algorithmica.org/hpc/compilation/contracts/#why-undefined-behavior-exists)Why
    Undefined Behavior Exists'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/compilation/contracts/#why-undefined-behavior-exists)未定义行为存在的原因'
- en: 'There are two major groups of actions that cause undefined behavior:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有两组主要的行为会导致未定义行为：
- en: Operations that are almost certainly unintentional bugs, like dividing by zero,
    dereferencing a null pointer, or reading from uninitialized memory. You want to
    catch these as soon as possible during testing, so crashing or having some non-deterministic
    behavior is better than having them always do a fixed fallback action such as
    returning zero.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎肯定是不小心引入的bug的操作，如除以零、取消对空指针的引用或从未初始化的内存中读取。你希望在测试过程中尽早捕获这些，因此崩溃或有一些非确定性行为比它们总是执行固定的回退操作（如返回零）要好。
- en: You can compile and run a program with *sanitizers* to catch undefined behavior
    early. In GCC and Clang, you can use the `-fsanitize=undefined` flag, and some
    operations that are notorious for causing UB will be instrumented to detect it
    at runtime.
  id: totrans-7
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用*sanitizers*编译和运行程序以在早期捕获未定义行为。在GCC和Clang中，你可以使用`-fsanitize=undefined`标志，并且一些臭名昭著的会导致未定义行为的操作将被仪器化以在运行时检测它。
- en: Operations that have slightly different observable behavior on different platforms.
    For example, the result of left-shifting an integer by more than 31 bits is undefined,
    because the instruction that does it is implemented differently on Arm and x86
    CPUs. If you standardize one specific behavior, then all programs compiled for
    the other platform will have to spend a few more cycles checking for that edge
    case, so it is best to leave it undefined.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同平台上，某些操作会有略微不同的可观察行为。例如，将整数左移超过31位的结果是未定义的，因为执行此操作的指令在Arm和x86 CPU上的实现方式不同。如果你标准化一种特定的行为，那么为其他平台编译的所有程序将不得不多花费几个周期来检查这种边缘情况，因此最好将其留为未定义。
- en: 'Sometimes, when there is a legitimate use case for some platform-specific behavior,
    instead of declaring it undefined, it can be left *implementation-defined*. For
    example, the result of right-shifting a [negative integer](/hpc/arithmetic/integer)
    depends on the platform: it either shifts in zeros or ones (e.g., right-shifting
    `11010110 = -42` by one may mean either `01101011 = 107` or `11101011 = -21`,
    both use cases being realistic).'
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时，当某些平台特定的行为有合法的使用场景时，而不是将其声明为未定义，它可以被留为*实现定义的*。例如，右移负整数的[结果](/hpc/arithmetic/integer)取决于平台：它要么向右移动零，要么向右移动一（例如，将`11010110
    = -42`右移一位可能意味着`01101011 = 107`或`11101011 = -21`，这两种情况都是现实的）。
- en: 'Designating something as undefined instead of implementation-defined behavior
    also helps compilers in optimization. Consider the case of signed integer overflow.
    On almost all architectures, [signed integers](/hpc/arithmetic/integer) overflow
    the same way as unsigned ones, with `INT_MAX + 1 == INT_MIN`, and yet, this is
    undefined behavior according to the C++ standard. This is very much intentional:
    if you disallow signed integer overflow, then `(x + 1) > x` is guaranteed to be
    always true for `int`, but not for `unsigned int`, because `(x + 1)` may overflow.
    For signed types, this lets compilers optimize such checks away.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 将某些内容指定为未定义行为而不是实现定义的行为也有助于编译器进行优化。考虑有符号整数溢出的情况。在几乎所有架构上，[有符号整数](/hpc/arithmetic/integer)的溢出方式与无符号整数相同，`INT_MAX
    + 1 == INT_MIN`，然而，根据 C++ 标准，这是未定义行为。这是故意的：如果你不允许有符号整数溢出，那么对于 `int`，`(x + 1) >
    x` 总是保证为真，但对于 `unsigned int` 则不是，因为 `(x + 1)` 可能会溢出。对于有符号类型，这允许编译器优化掉这样的检查。
- en: 'As a more naturally occurring example, consider the case of a loop with an
    integer control variable. Modern C++ and languages like Rust encourage programmers
    to use an unsigned integer (`size_t` / `usize`), while C programmers stubbornly
    keep using `int`. To understand why, consider the following `for` loop:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 作为更自然发生的例子，考虑一个具有整数控制变量的循环的情况。现代 C++ 和像 Rust 这样的语言鼓励程序员使用无符号整数 (`size_t` / `usize`)，而
    C 程序员则固执地继续使用 `int`。为了理解为什么，考虑以下 `for` 循环：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'How many times does this loop execute? There are technically two valid answers:
    $n$ and infinity, the second being the case if $n$ exceeds $2^{32}$ so that $i$
    keeps resetting to zero every $2^{32}$ iterations. While the former is probably
    the one assumed by the programmer, to comply with the language spec, the compiler
    still has to insert additional runtime checks and consider the two cases, which
    should be optimized differently. Meanwhile, the `int` version would make exactly
    $n$ iterations because the very possibility of a signed overflow is defined out
    of existence.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环执行了多少次？从技术上讲有两个有效的答案：$n$ 和无穷大，后者是 $n$ 超过 $2^{32}$ 的情况，此时 $i$ 每 $2^{32}$
    次迭代就会重置为零。虽然前者可能是程序员假设的，但为了符合语言规范，编译器仍然必须插入额外的运行时检查并考虑两种情况，这些情况应该被优化不同。同时，`int`
    版本将恰好执行 $n$ 次迭代，因为有符号溢出的可能性已经被定义为不存在。
- en: '### [#](https://en.algorithmica.org/hpc/compilation/contracts/#removing-corner-cases)Removing
    Corner Cases'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/compilation/contracts/#removing-corner-cases)
    移除角落案例'
- en: The “safe” programming style usually involves making a lot of runtime checks,
    but they do not have to come at the cost of performance.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: “安全”的编程风格通常涉及进行大量的运行时检查，但它们不必以性能为代价。
- en: 'For example, Rust famously uses bounds checking when indexing arrays and other
    random access structures. In C++ STL, `vector` and `array` have an “unsafe” `[]`
    operator and a “safe” `.at()` method that goes something like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Rust 在索引数组和其他随机访问结构时著名地使用了边界检查。在 C++ STL 中，`vector` 和 `array` 有一个“不安全”的 `[]`
    操作符和一个“安全”的 `.at()` 方法，大致如下：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Interestingly, these checks are rarely actually executed during runtime because
    the compiler can often prove — during compile time — that each access will be
    within bounds. For example, when iterating in a `for` loop from 1 to the array
    size and indexing $i$-th element on each step, nothing illegal can possibly happen,
    so the bounds checks can be safely optimized away.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这些检查在运行时很少真正执行，因为编译器通常可以在编译时证明每个访问都在边界内。例如，当从 1 迭代到数组大小并在每一步索引第 $i$ 个元素时，不可能发生任何非法操作，因此边界检查可以安全地优化掉。
- en: '### [#](https://en.algorithmica.org/hpc/compilation/contracts/#assumptions)Assumptions'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/compilation/contracts/#assumptions)
    假设'
- en: When the compiler can’t prove the inexistence of corner cases, but *you* can,
    this additional information can be provided using the mechanism of undefined behavior.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器无法证明角落案例不存在，但你可以时，可以使用未定义行为的机制提供这些额外信息。
- en: 'Clang has a helpful `__builtin_assume` function where you can put a statement
    that is guaranteed to be true, and the compiler will use this assumption in optimization.
    In GCC, you can do the same with `__builtin_unreachable`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Clang 有一个有用的 `__builtin_assume` 函数，你可以在其中放置一个保证为真的语句，编译器将使用这个假设进行优化。在 GCC 中，你可以使用
    `__builtin_unreachable` 来做同样的事情：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For instance, you can put `assume(k < vector.size())` before `at` in the example
    above, and then the bounds check will be optimized away.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以在上面的例子中的 `at` 之前放置 `assume(k < vector.size())`，然后边界检查将被优化掉。
- en: 'It is also quite useful to combine `assume` with `assert` and `static_assert`
    to find bugs: you can use the same function to check preconditions in the debug
    build and then use them to improve performance in the production build.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `assume` 与 `assert` 和 `static_assert` 结合起来以查找错误也是非常有用的：你可以在调试构建中使用相同的函数来检查先决条件，然后在生产构建中利用它们来提高性能。
- en: '### [#](https://en.algorithmica.org/hpc/compilation/contracts/#arithmetic)Arithmetic'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/compilation/contracts/#arithmetic)算术'
- en: Corner cases are something you should keep in mind, especially when optimizing
    arithmetic.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 边界情况是你应该记住的事情，尤其是在优化算术时。
- en: For [floating-point arithmetic](/hpc/arithmetic/float), this is less of a concern
    because you can just disable strict standard compliance with the `-ffast-math`
    flag (which is also included in `-Ofast`). You almost have to do it anyway because
    otherwise, the compiler can’t do anything but execute arithmetic operations in
    the same order as in the source code without any optimizations.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 [浮点运算](/hpc/arithmetic/float)，这并不是一个很大的问题，因为你可以通过 `-ffast-math` 标志（它也包含在
    `-Ofast` 中）来禁用严格的标准化遵守。你几乎不得不这样做，因为否则编译器除了以与源代码相同的顺序执行算术运算外，别无他法进行优化。
- en: 'For integer arithmetic, this is different because the results always have to
    be exact. Consider the case of division by 2:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于整数运算，这不同，因为结果总是必须精确的。考虑除以 2 的情况：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A widely known optimization is to replace it with a single right shift (`x
    >> 1`):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个广为人知的优化是将它替换为单个右移（`x >> 1`）：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is certainly correct for all *positive* numbers, but what about the general
    case?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然对所有 *正数* 是正确的，但对于一般情况又如何呢？
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If `x` is negative, then simply shifting doesn’t work — regardless of whether
    shifting is done in zeros or sign bits:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `x` 是负数，那么简单的移位操作就不起作用了——无论移位是在零位还是符号位上执行：
- en: If we shift in zeros, we get a non-negative result (the sign bit is zero).
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们移入零，我们会得到一个非负结果（符号位为零）。
- en: If we shift in sign bits, then rounding will happen towards negative infinity
    instead of zero (`-5 / 2` will be equal to `-3` instead of `-2`)^([1](#fn:1)).
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们移入符号位，那么舍入将朝向负无穷大而不是零（`-5 / 2` 将等于 `-3` 而不是 `-2`）^([1](#fn:1))。
- en: 'So, for the general case, we have to insert some crutches to make it work:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于一般情况，我们必须插入一些辅助手段来使其工作：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When only the positive case is what was intended, we can also use the `assume`
    mechanism to eliminate the possibility of negative `x` and avoid handling this
    corner case:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当只有正数情况是我们所期望的，我们也可以使用 `assume` 机制来消除负 `x` 的可能性，并避免处理这个边界情况：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Although in this particular case, perhaps the best syntax to express that we
    only expect non-negative numbers is to use an unsigned integer type.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个特定情况下，可能最好的语法来表示我们只期望非负数是使用无符号整数类型。
- en: Because of nuances like this, it is often beneficial to expand the algebra in
    intermediate functions and manually simplify arithmetic yourself rather than relying
    on the compiler to do it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这样的细微差别，通常在中间函数中展开代数并手动简化算术，而不是依赖编译器来做，这样做往往是有益的。
- en: '### [#](https://en.algorithmica.org/hpc/compilation/contracts/#memory-aliasing)Memory
    Aliasing'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/compilation/contracts/#memory-aliasing)内存别名'
- en: Compilers are quite bad at optimizing operations that involve memory reads and
    writes. This is because they often don’t have enough context for the optimization
    to be correct.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器在优化涉及内存读取和写入的操作方面相当糟糕。这是因为它们通常没有足够的上下文来确保优化是正确的。
- en: 'Consider the following example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since each iteration of this loop is independent, it can be executed in parallel
    and [vectorized](/hpc/simd). But is it, technically?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个循环的每次迭代都是独立的，它可以并行执行并 [向量化](/hpc/simd)。但从技术上讲，它真的可以吗？
- en: There may be a problem if the arrays `a` and `b` intersect. Consider the case
    when `b == a + 1`, that is, if `b` is just a memory view of `a` starting from
    its second element. In this case, the next iteration depends on the previous one,
    and the only correct solution is to execute the loop sequentially. The compiler
    has to check for such possibilities even if the programmer knows they can’t happen.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组 `a` 和 `b` 交叉，可能会出现问题。考虑 `b == a + 1` 的情况，即如果 `b` 只是 `a` 从第二个元素开始的内存视图。在这种情况下，下一次迭代依赖于前一次迭代，唯一的正确解决方案是顺序执行循环。即使程序员知道这种情况不可能发生，编译器也必须检查这种可能性。
- en: This is why we have `const` and `restrict` keywords. The first one enforces
    that we won’t modify memory with the pointer variable, and the second is a way
    to tell the compiler that the memory is guaranteed to not be aliased.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们有 `const` 和 `restrict` 关键字。第一个强制我们不会用指针变量修改内存，第二个是告诉编译器内存保证不会被别名化的方式。
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These keywords are also a good idea to use by themselves for the purpose of
    self-documenting.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关键字单独使用也是为了自文档化的好主意。
- en: '### [#](https://en.algorithmica.org/hpc/compilation/contracts/#c-contracts)C++
    Contracts'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/compilation/contracts/#c-contracts)C++
    合同'
- en: Contract programming is an underused but very powerful technique.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 合同编程是一种使用较少但非常强大的技术。
- en: 'There is a late-stage proposal to add design-by-contract into the C++ standard
    in the form of [contract attributes](http://www.hellenico.gr/cpp/w/cpp/language/attributes/contract.html),
    which are functionally equivalent to our hand-made, compiler-specific `assume`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个后期提案建议将设计-by-contract 以合同属性的形式添加到 C++ 标准[http://www.hellenico.gr/cpp/w/cpp/language/attributes/contract.html]，这些属性在功能上等同于我们手工制作的、针对特定编译器的
    `assume`：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are 3 types of attributes — `expects`, `ensures`, and `assert` — respectively
    used for specifying pre- and post-conditions in functions and general assertions
    that can be put anywhere in the program.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有 3 种类型的属性——`expects`、`ensures` 和 `assert`——分别用于在函数中指定前置和后置条件以及可以在程序中的任何地方放置的一般断言。
- en: 'Unfortunately, this exciting new feature is [not yet finally standardized](https://www.reddit.com/r/cpp/comments/cmk7ek/what_happened_to_c20_contracts/),
    let alone implemented in a major C++ compiler. But maybe, in a few years, we will
    be able to write code like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个令人兴奋的新特性[尚未最终标准化](https://www.reddit.com/r/cpp/comments/cmk7ek/what_happened_to_c20_contracts/)，更不用说在主要的
    C++ 编译器中实现了。但也许，几年后，我们能够写出这样的代码：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Some forms of contract programming are also available in other performance-oriented
    languages such as [Rust](https://docs.rs/contracts/latest/contracts/) and [D](https://dlang.org/spec/contracts.html).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 其他面向性能的语言，如 [Rust](https://docs.rs/contracts/latest/contracts/) 和 [D](https://dlang.org/spec/contracts.html)，也提供了某些形式的合同编程。
- en: A general and language-agnostic advice is to always [inspect the assembly](../stages)
    that the compiler produced, and if it is not what you were hoping for, try to
    think about corner cases that may be limiting the compiler from optimizing it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个通用的、与语言无关的建议是始终检查编译器生成的汇编代码（../stages），如果它不是你所期望的，那么尝试思考可能限制编译器进行优化的边界情况。
- en: '* * *'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Fun fact: in Python, integer-dividing a negative number for some reason floors
    the result, so that `-5 // 2 = -3` and equivalent to `-5 >> 1 = -3`. I doubt that
    Guido van Rossum had this optimization in mind when initially designing the language,
    but, theoretically, a [JIT-compiled](/hpc/complexity/languages/#compiled-languages)
    Python program with many divisions by two may be faster than an analogous C++
    program. [↩︎](#fnref:1) [← Situational Optimizations](https://en.algorithmica.org/hpc/compilation/situational/)[Precomputation
    →](https://en.algorithmica.org/hpc/compilation/precalc/)'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有趣的事实：在 Python 中，由于某种原因，对负数进行整数除法会将结果向下取整，所以 `-5 // 2 = -3` 等同于 `-5 >> 1 = -3`。我怀疑吉多·范罗苏姆在最初设计语言时并没有考虑到这种优化，但从理论上讲，一个包含许多除以二的操作的
    JIT 编译 Python 程序可能比类似的 C++ 程序更快。[↩︎](#fnref:1) [← 情境优化](https://en.algorithmica.org/hpc/compilation/situational/)[预计算
    →](https://en.algorithmica.org/hpc/compilation/precalc/)
