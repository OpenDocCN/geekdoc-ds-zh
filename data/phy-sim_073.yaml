- en: Computing ∂P/∂F or δP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算 ∂P/∂F 或 δP
- en: 原文：[https://phys-sim-book.github.io/lec14.3-compute_stress_deriv.html](https://phys-sim-book.github.io/lec14.3-compute_stress_deriv.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://phys-sim-book.github.io/lec14.3-compute_stress_deriv.html](https://phys-sim-book.github.io/lec14.3-compute_stress_deriv.html)
- en: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
- en: 'To compute the derivative of P with respect to F, we leverage the rotational
    invariance property discussed earlier for P. Consider two arbitrary rotation matrices
    R and Q. From the rotational properties of P, we have:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算 P 对 F 的导数，我们利用之前讨论的 P 的旋转不变性属性。考虑两个任意的旋转矩阵 R 和 Q。从 P 的旋转属性中，我们有：
- en: P(F)=P(RRTFQQT)=RP(RTFQ)QT.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: P(F)=P(RRTFQQT)=RP(RTFQ)QT.
- en: 'Define K=RTFQ, then:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 K=RTFQ，然后：
- en: P(F)=RP(K)QT.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: P(F)=RP(K)QT.
- en: 'Taking the differential of P, while treating R and Q as constants, gives:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 R 和 Q 视为常数的同时对 P 求微分，得到：
- en: δP=R[∂F∂P​(K):δ(K)]QT=R[∂F∂P​(K):(RTδFQ)]QT.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: δP=R[∂F∂P​(K):δ(K)]QT=R[∂F∂P​(K):(RTδFQ)]QT.
- en: 'By setting R=U and Q=V, where K=Σ, the differential expression simplifies to:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置 R=U 和 Q=V，其中 K=Σ，微分表达式简化为：
- en: δP=U[∂F∂P​(Σ):(UTδFV)]VT.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: δP=U[∂F∂P​(Σ):(UTδFV)]VT.
- en: 'The tensorial derivative ∂P/∂F is then expressed in index notation as:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 张量导数 ∂P/∂F 然后用指标符号表示为：
- en: (δP)ij​=Uik​(∂F∂P​(Σ))klmn​Urm​δFrs​Vsn​Vjl​,and(δP)ij​=(∂F∂P​(F))ijrs​δFrs​.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: (δP)ij​=Uik​(∂F∂P​(Σ))klmn​Urm​δFrs​Vsn​Vjl​,and(δP)ij​=(∂F∂P​(F))ijrs​δFrs​.
- en: 'These expressions must hold for any δF, leading to the relationship:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表达式必须对任何 δF 成立，从而得到以下关系：
- en: (∂F∂P​(F))ijrs​=(∂F∂P​(Σ))klmn​Uik​Urm​Vsn​Vjl​.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: (∂F∂P​(F))ijrs​=(∂F∂P​(Σ))klmn​Uik​Urm​Vsn​Vjl​.
- en: So the remaining task is computing ∂F∂P​(Σ). We show how to do it in 3D.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，剩余的任务是计算 ∂F∂P​(Σ)。我们将在 3D 中展示如何进行计算。
- en: 'First, let''s introduce Rodrigues'' rotation formula, which provides a method
    for expressing any rotation matrix in terms of a unit vector k and a rotation
    angle θ. The formula is given by: R=I+sin(θ)K+(1−cos(θ))K2,(14.3.1) where K is
    the skew-symmetric cross-product matrix associated with k. This formula shows
    that any rotation matrix is characterized by just three degrees of freedom, denoted
    as r1​,r2​,r3​. These components are used to define the rotation vector r, from
    which k and θ are derived as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们介绍罗德里格斯旋转公式，该公式提供了一种用单位向量 k 和旋转角 θ 来表示任何旋转矩阵的方法。公式如下：R=I+sin(θ)K+(1−cos(θ))K2,(14.3.1)
    其中 K 是与 k 相关的反对称交叉乘积矩阵。这个公式表明，任何旋转矩阵只由三个自由度来表征，分别表示为 r1​,r2​,r3​。这些分量用于定义旋转向量
    r，从 r 中可以导出 k 和 θ，如下所示：
- en: k=∣r∣r​,θ=∣r∣.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: k=∣r∣r​,θ=∣r∣.
- en: Using this parameterization, rotation matrices U and V can each be described
    by three parameters.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种参数化，旋转矩阵 U 和 V 每个都可以用三个参数来描述。
- en: Now we have the following code for defining F in terms of s1, s2, s3, u1, u2,
    u3, v1, v2, v3, where U and V are defined by ui​ and vi​ with Rodrigues' rotation
    formula, si​ are the singular values from Σ.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有以下代码，用于根据 s1, s2, s3, u1, u2, u3, v1, v2, v3 定义 F，其中 U 和 V 由 ui​ 和 vi​
    通过罗德里格斯旋转公式定义，si​ 是 Σ 中的奇异值。
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: where cp is a function for generating the cross-product matrix (corresponding
    to computing K in Equation [(14.3.1)](#eqn:rodrigues)).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 cp 是一个生成交叉乘积矩阵的函数（对应于计算方程 [(14.3.1)](#eqn:rodrigues) 中的 K）。
- en: From now on, we write the 3×3×3×3 tensor ∂F∂P​(Σ) and any other such tensors
    to 9×9 matrices. That means each 3×3 matrix is now a size-9 vector. It is easy
    to see the old ∂Fkl​∂Pij​​ is now ∂F3(k−1)+l​∂P3(i−1)+j​​. We further call vector
    S={s1,s2,s3,u1,u2,u3,v1,v2,v3} being the parametrization of F. Then we can apply
    the chain rule ∂F∂P​(Σ)=∂S∂P​(Σ)∂F∂S​(Σ)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将 3×3×3×3 张量 ∂F∂P​(Σ) 和任何其他此类张量写成 9×9 矩阵。这意味着每个 3×3 矩阵现在是一个大小为 9 的向量。很容易看出旧的
    ∂Fkl​∂Pij​​ 现在是 ∂F3(k−1)+l​∂P3(i−1)+j​​。我们进一步将向量 S={s1,s2,s3,u1,u2,u3,v1,v2,v3}
    定义为 F 的参数化。然后我们可以应用链式法则 ∂F∂P​(Σ)=∂S∂P​(Σ)∂F∂S​(Σ)
- en: Here are the Mathematica code for computing them. Note that we achieve F=Σ by
    taking the limit {u1,u2,u3,v1,v2,v3}=+ϵ, which correspond to nearly zero rotations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是计算它们的 Mathematica 代码。注意，我们通过取极限 {u1,u2,u3,v1,v2,v3}=+ϵ 来实现 F=Σ，这对应于几乎为零的旋转。
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note 'Direction->-1' in Mathematica means taking the limit from large values
    to the small limit value. The Mathematica computation result will be given in
    terms of the singular values and P^. One can then take the formula for implementing
    them in the code. [[Stomakhin et al. 2012]](bibliography.html#stomakhin2012energetically)
    gives the result where ∂F∂P​(Σ) (size 9×9 matrix) is permuted to be a block diagonal
    matrix with diagonal blocks A3×3,B122×2​,B132×2​,B232×2​, where A=​Ψ^,σ1​σ1​​Ψ^,σ2​σ1​​Ψ^,σ3​σ1​​​Ψ^,σ1​σ2​​Ψ^,σ2​σ2​​Ψ^,σ3​σ2​​​Ψ^,σ1​σ3​​Ψ^,σ2​σ3​​Ψ^,σ3​σ3​​​​
    and Bij​=σi2​−σj2​1​(σi​Ψ^,σi​​−σj​Ψ^,σj​​σj​Ψ^,σi​​−σi​Ψ^,σj​​​σj​Ψ^,σi​​−σi​Ψ^,σj​​σi​Ψ^,σi​​−σj​Ψ^,σj​​​).
    Denominator clamping is needed for terms in B that may introduce division-by-zero
    (after fully simplifying them). Here we denote ∂σi​∂Ψ^​ and ∂σi​∂σj​∂2Ψ^​ as Ψ^,σi​​
    and Ψ^,σi​σj​​ respectively. The division by σi2​−σj2​ is problematic when two
    singular values are nearly equal or when two singular values nearly sum to zero.
    The latter is possible with a convention for permitting negative singular values
    (as in invertible elasticity [[Irving et al. 2004]](bibliography.html#irving2004invertible)
    [[Stomakhin et al. 2012]](bibliography.html#stomakhin2012energetically)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Mathematica 中的 'Direction->-1' 表示从大值到小极限值的极限。Mathematica 的计算结果将以奇异值和 P^ 的形式给出。然后可以取公式在代码中实现它们。[[Stomakhin
    等人 2012]](bibliography.html#stomakhin2012energetically) 给出了 ∂F∂P(Σ)（9×9 矩阵大小）被排列为块对角矩阵的结果，其中对角块为
    A3×3,B122×2,B132×2,B232×2，其中 A=Ψ^,σ1σ1Ψ^,σ2σ1Ψ^,σ3σ1Ψ^,σ1σ2Ψ^,σ2σ2Ψ^,σ3σ2Ψ^,σ1σ3Ψ^,σ2σ3Ψ^,σ3σ3Ψ^,σi2−σj2(σiΨ^,σi−σjΨ^,σjσjΨ^,σi−σiΨ^,σjσjΨ^,σi−σiΨ^,σjσiΨ^,σi−σjΨ^,σj)。对于可能引入除以零的
    B 项，需要分母限制。在这里，我们用 Ψ^,σi 和 Ψ^,σiσj 分别表示 ∂σi∂Ψ^ 和 ∂σi∂σj∂2Ψ^。当两个奇异值几乎相等或两个奇异值几乎相加为零时，除以
    σi2−σj2 是有问题的。后者可以通过允许负奇异值的约定来实现（如可逆弹性 [[Irving 等人 2004]](bibliography.html#irving2004invertible)
    [[Stomakhin 等人 2012]](bibliography.html#stomakhin2012energetically))。
- en: Expanding Bij​ in terms of partial fractions yields the useful decomposition
    Bij​=21​σi​−σj​Ψ^,σi​​−Ψ^,σj​​​(11​11​)+21​σi​+σj​Ψ^,σi​​+Ψ^,σj​​​(1−1​−11​).
    Note that if Ψ^ is invariant under permutation of the singular values, then Ψ^,σi​​→Ψ^,σj​​
    as σi​→σj​. Thus, the first term can normally be computed robustly for an isotropic
    model if implemented carefully. The other fraction can be computed robustly if
    Ψ^,σi​​+Ψ^,σj​​→0 as σi​+σj​→0. But this usually does not hold as it means the
    constitutive model will have difficulty recovering from degenerate or inverted
    configurations. Thus, this term will be unbounded under some circumstances. We
    address this by clamping the magnitude of the denominator to not be smaller than
    10−6 before division to bound the derivatives.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Bij 展开成部分分式得到有用的分解 Bij=21σi−σjΨ^,σi−Ψ^,σj(11−11)+21σi+σjΨ^,σi+Ψ^,σj(1−1−11).
    注意，如果 Ψ^ 在奇异值排列下是不变的，那么当 σi→σj 时，Ψ^,σi→Ψ^,σj. 因此，如果实现得小心，第一个项通常可以稳健地计算一个各向同性模型。如果
    Ψ^,σi+Ψ^,σj→0 当 σi+σj→0 时，其他分数也可以稳健地计算。但这种情况通常不成立，因为这意味着本构模型将难以从退化或倒置配置中恢复。因此，在某些情况下，这个项将是无界的。我们通过在除法之前将分母的幅度限制为不小于
    10−6 来解决这个问题，以限制导数。
- en: For 2D, a rotation matrix is now simply paremetrized with a single θ where the
    reconstruction is
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于二维，旋转矩阵现在仅用单个 θ 参数化，其重建为
- en: R=(cosθsinθ​−sinθcosθ​). The 2D version of the whole Mathematica code is
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: R=(cosθsinθ−sinθcosθ). 整个 Mathematica 代码的二维版本是
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: where A is now also 2×2 and there is only one B.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 A 现在也是 2×2，只有一个 B。
