- en: 13.1Â Mutating VariablesğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.1Â ä¿®æ”¹å˜é‡ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/mutating-variables.html](https://dcic-world.org/2025-08-27/mutating-variables.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/mutating-variables.html](https://dcic-world.org/2025-08-27/mutating-variables.html)
- en: '| Â Â Â Â [13.1.1Â Mutating Variables in Memory](#%28part._mutating-vars-memory%29)
    |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [13.1.1Â å†…å­˜ä¸­ä¿®æ”¹å˜é‡](#%28part._mutating-vars-memory%29) |'
- en: '| Â Â Â Â [13.1.2Â Variable Mutation and Aliasing](#%28part._var-mut-aliasing%29)
    |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [13.1.2Â å˜é‡ä¿®æ”¹å’Œåˆ«å](#%28part._var-mut-aliasing%29) |'
- en: '| Â Â Â Â [13.1.3Â Mutating Variables versus Mutating Data Fields](#%28part._.Mutating_.Variables_versus_.Mutating_.Data_.Fields%29)
    |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [13.1.3Â å˜é‡ä¿®æ”¹ä¸æ•°æ®å­—æ®µä¿®æ”¹](#%28part._.Mutating_.Variables_versus_.Mutating_.Data_.Fields%29)
    |'
- en: '| Â Â Â Â [13.1.4Â Mutating Parameters in Function Calls](#%28part._.Mutating_.Parameters_in_.Function_.Calls%29)
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [13.1.4Â å‡½æ•°è°ƒç”¨ä¸­ä¿®æ”¹å‚æ•°](#%28part._.Mutating_.Parameters_in_.Function_.Calls%29)
    |'
- en: '| Â Â Â Â [13.1.5Â Mutating Top-Level Variables within Functions](#%28part._mut-top-level-vars-in-func%29)
    |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [13.1.5Â å‡½æ•°å†…ä¿®æ”¹é¡¶å±‚å˜é‡](#%28part._mut-top-level-vars-in-func%29) |'
- en: '| Â Â Â Â [13.1.6Â The Many Roles of Variables](#%28part._.The_.Many_.Roles_of_.Variables%29)
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [13.1.6Â å˜é‡çš„å¤šç§è§’è‰²](#%28part._.The_.Many_.Roles_of_.Variables%29) |'
- en: 13.1.1Â Mutating Variables in Memory[ğŸ”—](#(part._mutating-vars-memory) "Link to
    here")
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.1Â å†…å­˜ä¸­ä¿®æ”¹å˜é‡[ğŸ”—](#(part._mutating-vars-memory) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Now that we have introduced the idea of the heap, letâ€™s revisit our use of
    a variable to compute the sum of elements in a list. Here again is the code we
    wrote for this earlier (in [Introducing `For` Loops](intro-python.html#%28part._python-for-loops%29)):'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»ä»‹ç»äº†å †çš„æ¦‚å¿µï¼Œè®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹æˆ‘ä»¬ä½¿ç”¨å˜é‡æ¥è®¡ç®—åˆ—è¡¨ä¸­å…ƒç´ æ€»å’Œçš„ä½¿ç”¨æ–¹æ³•ã€‚ä»¥ä¸‹æ˜¯æˆ‘ä»¬ä¹‹å‰ç¼–å†™çš„ä»£ç ï¼ˆåœ¨[ä»‹ç» `For` å¾ªç¯](intro-python.html#%28part._python-for-loops%29)ä¸­ï¼‰ï¼š
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Letâ€™s see how the directory and heap update as we run this code. In [Basic Data
    and the Heap](mutating-structures.html#%28part._basic-data-heap%29), we pointed
    out that basic data (such as numbers, strings, and booleans) donâ€™t get put in
    the heap because they have no internal structure. Those values are stored in the
    directory itself. Therefore, the initial value for `run_total` is stored within
    the directory.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹çœ‹åœ¨è¿è¡Œæ­¤ä»£ç æ—¶ç›®å½•å’Œå †æ˜¯å¦‚ä½•æ›´æ–°çš„ã€‚åœ¨[åŸºæœ¬æ•°æ®å’Œå †](mutating-structures.html#%28part._basic-data-heap%29)ä¸­ï¼Œæˆ‘ä»¬æŒ‡å‡ºåŸºæœ¬æ•°æ®ï¼ˆå¦‚æ•°å­—ã€å­—ç¬¦ä¸²å’Œå¸ƒå°”å€¼ï¼‰ä¸ä¼šæ”¾å…¥å †ä¸­ï¼Œå› ä¸ºå®ƒä»¬æ²¡æœ‰å†…éƒ¨ç»“æ„ã€‚è¿™äº›å€¼å­˜å‚¨åœ¨ç›®å½•æœ¬èº«ä¸­ã€‚å› æ­¤ï¼Œ`run_total`
    çš„åˆå§‹å€¼å­˜å‚¨åœ¨ç›®å½•ä¸­ã€‚
- en: Directory
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE1]'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE1]'
- en: â†’
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE2]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `for` loop also sets up a directory entry, this time for the variable `num`
    that is used to refer to the list elements. When the loop starts, `num` takes
    on the first value in the list. Thus, the directory appears as:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` å¾ªç¯è¿˜è®¾ç½®äº†ä¸€ä¸ªç›®å½•æ¡ç›®ï¼Œè¿™æ¬¡æ˜¯ä¸ºç”¨äºå¼•ç”¨åˆ—è¡¨å…ƒç´ çš„å˜é‡ `num`ã€‚å½“å¾ªç¯å¼€å§‹æ—¶ï¼Œ`num` å–å¾—åˆ—è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªå€¼ã€‚å› æ­¤ï¼Œç›®å½•çœ‹èµ·æ¥å¦‚ä¸‹ï¼š'
- en: Directory
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE3]'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE3]'
- en: â†’
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE4]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE5]'
- en: â†’
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE6]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Inside the `for` loop, we compute a new value for `run_total`. The use of `=`
    tells Python to modify the value of `run_total`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ `for` å¾ªç¯å†…éƒ¨ï¼Œæˆ‘ä»¬è®¡ç®— `run_total` çš„æ–°å€¼ã€‚ä½¿ç”¨ `=` å‘Šè¯‰ Python ä¿®æ”¹ `run_total` çš„å€¼ã€‚
- en: Do Now!
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does this modification get made in the directory or the heap?
  id: totrans-27
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™ä¸ªä¿®æ”¹æ˜¯åœ¨ç›®å½•è¿˜æ˜¯å †ä¸­è¿›è¡Œçš„ï¼Ÿ
- en: 'Since basic data values are stored only in the directory, this update modifies
    the contents of the directory. The heap isnâ€™t involved:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºåŸºæœ¬æ•°æ®å€¼ä»…å­˜å‚¨åœ¨ç›®å½•ä¸­ï¼Œè¿™æ¬¡æ›´æ–°ä¿®æ”¹äº†ç›®å½•çš„å†…å®¹ã€‚å †ï¼ˆheapï¼‰å¹¶æœªæ¶‰åŠï¼š
- en: Directory
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE7]'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE7]'
- en: â†’
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE8]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE9]'
- en: â†’
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE10]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This process continues: Python advances `num` to the next list element'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤è¿‡ç¨‹ç»§ç»­ï¼šPython å°† `num` ç§»åŠ¨åˆ°åˆ—è¡¨çš„ä¸‹ä¸€ä¸ªå…ƒç´ 
- en: Directory
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE11]'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE11]'
- en: â†’
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE12]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE13]'
- en: â†’
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE14]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: then modifies the value of `run_total`
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åä¿®æ”¹ `run_total` çš„å€¼
- en: Directory
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE15]'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE15]'
- en: â†’
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE16]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE17]'
- en: â†’
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE18]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This process continues until all of the list elements have been processed.
    When the for-loop ends, the directory contents are:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªè¿‡ç¨‹ä¼šä¸€ç›´æŒç»­åˆ°å¤„ç†å®Œæ‰€æœ‰åˆ—è¡¨å…ƒç´ ã€‚å½“ `for` å¾ªç¯ç»“æŸæ—¶ï¼Œç›®å½•å†…å®¹å¦‚ä¸‹ï¼š
- en: Directory
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE19]'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE19]'
- en: â†’
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE20]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE21]'
- en: â†’
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE22]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There are two takeaways from this example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ä»è¿™ä¸ªä¾‹å­ä¸­æˆ‘ä»¬å¯ä»¥å¾—åˆ°ä¸¤ä¸ªè¦ç‚¹ï¼š
- en: When we use `=` to update the value associated with a variable, the variableâ€™s
    entry in the directory changes to reflect the new value.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬ä½¿ç”¨ `=` æ¥æ›´æ–°ä¸å˜é‡å…³è”çš„å€¼æ—¶ï¼Œç›®å½•ä¸­è¯¥å˜é‡çš„æ¡ç›®ä¼šæ”¹å˜ä»¥åæ˜ æ–°å€¼ã€‚
- en: '`For` loops introduce a name into the directory (the one the programmer chose
    to refer to the individual list elements). As the loop progresses, Python updates
    the value associated with that name to refer to each successive element.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`For` å¾ªç¯åœ¨ç›®å½•ä¸­å¼•å…¥äº†ä¸€ä¸ªåç§°ï¼ˆç¨‹åºå‘˜é€‰æ‹©çš„ï¼Œç”¨äºå¼•ç”¨å•ä¸ªåˆ—è¡¨å…ƒç´ ï¼‰ã€‚éšç€å¾ªç¯çš„è¿›è¡Œï¼ŒPython æ›´æ–°ä¸è¯¥åç§°å…³è”çš„å€¼ï¼Œä»¥å¼•ç”¨æ¯ä¸ªåç»­å…ƒç´ ã€‚'
- en: Exercise
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Draw the sequence of directory contents for the following program:'
  id: totrans-65
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»˜åˆ¶ä»¥ä¸‹ç¨‹åºçš„ç›®å½•å†…å®¹åºåˆ—ï¼š
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-67
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Exercise
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Draw the sequence of directory contents for the following program:'
  id: totrans-70
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»˜åˆ¶ä»¥ä¸‹ç¨‹åºçš„ç›®å½•å†…å®¹åºåˆ—ï¼š
- en: ''
  id: totrans-71
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-72
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 13.1.2Â Variable Mutation and Aliasing[ğŸ”—](#(part._var-mut-aliasing) "Link to
    here")
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.2Â å˜é‡å˜å¼‚å’Œåˆ«å[ğŸ”—](#(part._var-mut-aliasing) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'In [Mutating Structures](mutating-structures.html), we saw how a statement
    of the form `elena.acct.balance = 500` resulted in a change to `jorge.acct.balance`.
    Does this same effect occur if we update the value of a variable directly, rather
    than a field? Consider the following example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨[å˜å¼‚ç»“æ„](mutating-structures.html)ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†å½¢å¼ä¸º`elena.acct.balance = 500`çš„è¯­å¥å¦‚ä½•å¯¼è‡´`jorge.acct.balance`å‘ç”Ÿå˜åŒ–ã€‚å¦‚æœæˆ‘ä»¬ç›´æ¥æ›´æ–°å˜é‡çš„å€¼è€Œä¸æ˜¯å­—æ®µï¼Œè¿™ç§ç›¸åŒçš„æ•ˆæœä¼šå‘ç”Ÿå—ï¼Ÿè€ƒè™‘ä»¥ä¸‹ç¤ºä¾‹ï¼š
- en: '[PRE25]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Do Now!
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do the directory and heap look like after running this code?
  id: totrans-78
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿è¡Œæ­¤ä»£ç åï¼Œç›®å½•å’Œå †çœ‹èµ·æ¥æ˜¯ä»€ä¹ˆæ ·å­ï¼Ÿ
- en: 'Since `x` and `y` are assigned basic values, there are no values in the heap:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äº`x`å’Œ`y`è¢«åˆ†é…äº†åŸºæœ¬å€¼ï¼Œå †ä¸­æ²¡æœ‰å€¼ï¼š
- en: Directory
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE26]'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE26]'
- en: â†’
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE27]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE28]'
- en: â†’
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE29]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Do Now!
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If we now evaluate `y = 3`, does the value of `x` change?
  id: totrans-89
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœç°åœ¨è¯„ä¼°`y = 3`ï¼Œ`x`çš„å€¼ä¼šæ”¹å˜å—ï¼Ÿ
- en: 'It does not. The value associated with `y` in the directory changes, but there
    is no connection between `x` and `y` in the directory. The statement `x = y` says
    â€œget the value of `y` and associate it with `x` in the directoryâ€. Immediately
    after this statement, `y` and `x` refer to the same value, but this relationship
    is neither tracked nor maintained. If we associate either variable with a new
    value, as we do with `y = 3`, the directory entry for that variableâ€”<wbr>and only
    the directory entry for that variableâ€”<wbr>are changed to reflect the new value.
    Thus, the directory after we evaluate `y = 3` appears as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒä¸ä¼šã€‚ä¸`y`å…³è”çš„å€¼åœ¨ç›®å½•ä¸­æ”¹å˜ï¼Œä½†ç›®å½•ä¸­æ²¡æœ‰`x`å’Œ`y`ä¹‹é—´çš„è¿æ¥ã€‚è¯­å¥`x = y`è¡¨ç¤ºâ€œè·å–`y`çš„å€¼å¹¶å°†å…¶ä¸ç›®å½•ä¸­çš„`x`å…³è”â€ã€‚åœ¨æ­¤è¯­å¥ä¹‹åï¼Œ`y`å’Œ`x`å¼•ç”¨ç›¸åŒçš„å€¼ï¼Œä½†è¿™ç§å…³ç³»æ—¢æ²¡æœ‰è¢«è·Ÿè¸ªä¹Ÿæ²¡æœ‰è¢«ç»´æŠ¤ã€‚å¦‚æœæˆ‘ä»¬å°†ä»»ä¸€å˜é‡ä¸æ–°çš„å€¼å…³è”ï¼Œå°±åƒæˆ‘ä»¬ç”¨`y
    = 3`åšçš„é‚£æ ·ï¼Œè¯¥å˜é‡çš„ç›®å½•æ¡ç›®â€”â€”ä»…è¯¥å˜é‡çš„ç›®å½•æ¡ç›®â€”â€”å°†è¢«æ›´æ”¹ä¸ºåæ˜ æ–°å€¼ã€‚å› æ­¤ï¼Œåœ¨è¯„ä¼°`y = 3`åï¼Œç›®å½•å¦‚ä¸‹æ‰€ç¤ºï¼š
- en: Directory
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE30]'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE30]'
- en: â†’
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE31]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE32]'
- en: â†’
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE33]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This example highlights that aliasing occurs only when two variables refer to
    the same piece of data with components, not when variables refer to basic data.
    This is because data with components are stored in the heap, with heap address
    stored in the directory. Note, though, that uses of `varname = ...` still affect
    the directory, even when the values are data with components.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªä¾‹å­å¼ºè°ƒäº†åˆ«åä»…åœ¨ä¸¤ä¸ªå˜é‡é€šè¿‡ç»„ä»¶å¼•ç”¨åŒä¸€æ•°æ®ç‰‡æ®µæ—¶å‘ç”Ÿï¼Œè€Œä¸æ˜¯å½“å˜é‡å¼•ç”¨åŸºæœ¬æ•°æ®æ—¶ã€‚è¿™æ˜¯å› ä¸ºå…·æœ‰ç»„ä»¶çš„æ•°æ®å­˜å‚¨åœ¨å †ä¸­ï¼Œå †åœ°å€å­˜å‚¨åœ¨ç›®å½•ä¸­ã€‚æ³¨æ„ï¼Œå°½ç®¡`varname
    = ...`çš„ä½¿ç”¨ä»ç„¶ä¼šå½±å“ç›®å½•ï¼Œå³ä½¿å€¼æ˜¯å…·æœ‰ç»„ä»¶çš„æ•°æ®ã€‚
- en: Do Now!
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After running the following code, what is the value of `ac2.balance`?
  id: totrans-101
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨è¿è¡Œä»¥ä¸‹ä»£ç åï¼Œ`ac2.balance`çš„å€¼æ˜¯å¤šå°‘ï¼Ÿ
- en: ''
  id: totrans-102
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-103
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ''
  id: totrans-104
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Draw the directory and heap contents for this program and check your prediction.
  id: totrans-105
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºæ­¤ç¨‹åºç»˜åˆ¶ç›®å½•å’Œå †å†…å®¹ï¼Œå¹¶æ£€æŸ¥ä½ çš„é¢„æµ‹ã€‚
- en: All three of these lines results in changes in the directory; the first two
    result in changes in the heap, but only because we made new pieces of data. `ac1`
    and `ac2` are alises immediately after running the second line, but the third
    line breaks that relationship.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸‰æ¡è¯­å¥éƒ½ä¼šå¯¼è‡´ç›®å½•å‘ç”Ÿå˜åŒ–ï¼›å‰ä¸¤æ¡ä¼šå¯¼è‡´å †å‘ç”Ÿå˜åŒ–ï¼Œä½†ä»…å› ä¸ºæˆ‘ä»¬åˆ›å»ºäº†æ–°çš„æ•°æ®ç‰‡æ®µã€‚`ac1`å’Œ`ac2`åœ¨æ‰§è¡Œç¬¬äºŒè¡Œåç«‹å³æˆä¸ºåˆ«åï¼Œä½†ç¬¬ä¸‰è¡Œæ‰“ç ´äº†è¿™ç§å…³ç³»ã€‚
- en: Do Now!
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After running the following code, what is the value of `ac3.balance`?
  id: totrans-109
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨è¿è¡Œä»¥ä¸‹ä»£ç åï¼Œ`ac3.balance`çš„å€¼æ˜¯å¤šå°‘ï¼Ÿ
- en: ''
  id: totrans-110
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-111
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ''
  id: totrans-112
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Draw the directory and heap contents for this program and check your prediction.
  id: totrans-113
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºæ­¤ç¨‹åºç»˜åˆ¶ç›®å½•å’Œå †å†…å®¹ï¼Œå¹¶æ£€æŸ¥ä½ çš„é¢„æµ‹ã€‚
- en: Since the value of `savings` is stored in `ac3.balance`, and not the name `savings`
    itself, updating the value of `savings` on the third line does not affect `ac3.balance`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äº`savings`çš„å€¼å­˜å‚¨åœ¨`ac3.balance`ä¸­ï¼Œè€Œä¸æ˜¯åç§°`savings`æœ¬èº«ï¼Œå› æ­¤åœ¨ç¬¬ä¸‰è¡Œæ›´æ–°`savings`çš„å€¼ä¸ä¼šå½±å“`ac3.balance`ã€‚
- en: 13.1.3Â Mutating Variables versus Mutating Data Fields[ğŸ”—](#(part._.Mutating_.Variables_versus_.Mutating_.Data_.Fields)
    "Link to here")
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.3Â å˜å¼‚å˜é‡ä¸å˜å¼‚æ•°æ®å­—æ®µ[ğŸ”—](#(part._.Mutating_.Variables_versus_.Mutating_.Data_.Fields)
    "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Weâ€™ve now seen two different forms of updates in programs: updates to fields
    of structured data in [Mutating Structures](mutating-structures.html), and updates
    to the values associated with names when computing over lists with `for` loops.
    At a quick glance, these two forms of update look similar:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨å·²ç»çœ‹åˆ°äº†ç¨‹åºä¸­ä¸¤ç§ä¸åŒçš„æ›´æ–°å½¢å¼ï¼šåœ¨[å˜å¼‚ç»“æ„](mutating-structures.html)ä¸­å¯¹ç»“æ„åŒ–æ•°æ®å­—æ®µçš„æ›´æ–°ï¼Œä»¥åŠåœ¨ç”¨`for`å¾ªç¯éå†åˆ—è¡¨æ—¶å¯¹ä¸åç§°å…³è”çš„å€¼çš„æ›´æ–°ã€‚ä¹ä¸€çœ‹ï¼Œè¿™ä¸¤ç§æ›´æ–°å½¢å¼çœ‹èµ·æ¥å¾ˆç›¸ä¼¼ï¼š
- en: '[PRE36]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Both use the `=` operator and compute a new value on the right side. The left
    sides, however, are subtly different: one is a field within structured data, while
    the other is a name in the directory. This difference turns out to be significant:
    the first form changes a value stored in the heap but leaves the directory unchanged,
    while the second updates the directory but leaves the heap unchanged.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒä»¬éƒ½ä½¿ç”¨`=`è¿ç®—ç¬¦å¹¶åœ¨å³ä¾§è®¡ç®—æ–°å€¼ã€‚ç„¶è€Œï¼Œå·¦ä¾§å´æœ‰æ‰€ä¸åŒï¼šä¸€ä¸ªæ˜¯ç»“æ„åŒ–æ•°æ®ä¸­çš„å­—æ®µï¼Œè€Œå¦ä¸€ä¸ªæ˜¯ç›®å½•ä¸­çš„åç§°ã€‚è¿™ç§å·®å¼‚æœ€ç»ˆè¯æ˜æ˜¯é‡è¦çš„ï¼šç¬¬ä¸€ç§å½¢å¼æ›´æ”¹äº†å †ä¸­å­˜å‚¨çš„å€¼ï¼Œä½†ç›®å½•ä¿æŒä¸å˜ï¼Œè€Œç¬¬äºŒç§å½¢å¼æ›´æ–°äº†ç›®å½•ï¼Œä½†å †ä¿æŒä¸å˜ã€‚
- en: At this point, you might not appreciate why this difference is significant.
    But for now, letâ€™s summarize how each of these forms impacts each of the directory
    and the heap.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œä½ å¯èƒ½ä¸ä¼šç†è§£è¿™ç§å·®å¼‚çš„é‡è¦æ€§ã€‚ä½†ä¸ºäº†ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ€»ç»“ä¸€ä¸‹è¿™äº›å½¢å¼å¦‚ä½•å½±å“ç›®å½•å’Œå †ã€‚
- en: 'Strategy: Rules for updating the directory and the heap'
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç­–ç•¥ï¼šæ›´æ–°ç›®å½•å’Œå †çš„è§„åˆ™
- en: ''
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Summarizing, the rules for how the directory and memory update are as follows:'
  id: totrans-122
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ€»ç»“æ¥è¯´ï¼Œç›®å½•å’Œå†…å­˜æ›´æ–°çš„è§„åˆ™å¦‚ä¸‹ï¼š
- en: ''
  id: totrans-123
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: We add to the heap when a data constructor is used
  id: totrans-124
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“ä½¿ç”¨æ•°æ®æ„é€ å‡½æ•°æ—¶ï¼Œæˆ‘ä»¬å‘å †ä¸­æ·»åŠ å†…å®¹
- en: ''
  id: totrans-125
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-126
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: We update the heap when a field of existing data is reassigned
  id: totrans-127
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“ç°æœ‰æ•°æ®çš„å­—æ®µè¢«é‡æ–°åˆ†é…æ—¶ï¼Œæˆ‘ä»¬æ›´æ–°å †
- en: ''
  id: totrans-128
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-129
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: We add to the directory when a name is used for the first time (this includes
    parameters and internal variables when a function is called)
  id: totrans-130
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“ç¬¬ä¸€æ¬¡ä½¿ç”¨åç§°æ—¶ï¼Œæˆ‘ä»¬å‘ç›®å½•ä¸­æ·»åŠ å†…å®¹ï¼ˆè¿™åŒ…æ‹¬åœ¨å‡½æ•°è°ƒç”¨æ—¶ä½¿ç”¨çš„å‚æ•°å’Œå†…éƒ¨å˜é‡ï¼‰
- en: ''
  id: totrans-131
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: We update the directory when a name that is already in the directory is subsequently
    assigned a new value)
  id: totrans-133
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“ç›®å½•ä¸­å·²ç»å­˜åœ¨çš„åç§°éšåè¢«èµ‹äºˆæ–°å€¼æ—¶ï¼Œæˆ‘ä»¬ä¼šæ›´æ–°ç›®å½•ï¼‰
- en: Do Now!
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After running the following code, what is the value of `ac3.balance`?
  id: totrans-136
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿è¡Œä»¥ä¸‹ä»£ç åï¼Œ`ac3.balance`çš„å€¼æ˜¯å¤šå°‘ï¼Ÿ
- en: ''
  id: totrans-137
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-138
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ''
  id: totrans-139
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Draw the directory and heap contents for this program and check your prediction.
  id: totrans-140
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºè¿™ä¸ªç¨‹åºç»˜åˆ¶ç›®å½•å’Œå †çš„å†…å®¹ï¼Œå¹¶æ£€æŸ¥ä½ çš„é¢„æµ‹ã€‚
- en: This example combines updates to variables and updates to fields. On the third
    line, `ac2` and `ac3` refer to the same address in the heap (which contains the
    `Account` with id `8728`. Immediately after updating `ac2.balance` on the fourth
    line, the balance in both `ac2` and `ac3` is 500\. Line six, however, creates
    a new `Account` in the heap and updates the directory to have `ac2` refer to that
    new `Account`. From that point on, `ac2` and `ac3` refer to different accounts,
    so the update to the balance in `ac2` on the seventh line does not affect `ac3`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªä¾‹å­ç»“åˆäº†å˜é‡æ›´æ–°å’Œå­—æ®µæ›´æ–°çš„æ“ä½œã€‚åœ¨ç¬¬ä¸‰è¡Œï¼Œ`ac2`å’Œ`ac3`æŒ‡å‘å †ä¸­çš„ç›¸åŒåœ°å€ï¼ˆå…¶ä¸­åŒ…å«idä¸º`8728`çš„`Account`ã€‚åœ¨ç¬¬å››è¡Œç«‹å³æ›´æ–°`ac2.balance`ä¹‹åï¼Œ`ac2`å’Œ`ac3`ä¸­çš„ä½™é¢éƒ½æ˜¯500ã€‚ç„¶è€Œï¼Œç¬¬å…­è¡Œåœ¨å †ä¸­åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„`Account`ï¼Œå¹¶å°†ç›®å½•æ›´æ–°ä¸ºä½¿`ac2`æŒ‡å‘è¿™ä¸ªæ–°çš„`Account`ã€‚ä»é‚£æ—¶èµ·ï¼Œ`ac2`å’Œ`ac3`æŒ‡å‘ä¸åŒçš„è´¦æˆ·ï¼Œå› æ­¤ç¬¬ä¸ƒè¡Œåœ¨`ac2`ä¸­æ›´æ–°ä½™é¢çš„æ›´æ”¹ä¸ä¼šå½±å“`ac3`ã€‚
- en: This example illustrates the subtleties and impacts of different uses of `=`.
    Programs behave differently depending on whether the left side of the `=` is a
    variable name or a field reference, and on whether the right side is basic data
    or data with components. We will continue to work with these various combinations
    to build your understanding of when and how to use each one.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªä¾‹å­è¯´æ˜äº†`=`çš„ä¸åŒç”¨æ³•åŠå…¶ç»†å¾®å·®åˆ«å’Œå½±å“ã€‚ç¨‹åºçš„è¡Œä¸ºå–å†³äº`=`çš„å·¦ä¾§æ˜¯å˜é‡åè¿˜æ˜¯å­—æ®µå¼•ç”¨ï¼Œä»¥åŠå³ä¾§æ˜¯åŸºæœ¬æ•°æ®è¿˜æ˜¯å…·æœ‰ç»„ä»¶çš„æ•°æ®ã€‚æˆ‘ä»¬å°†ç»§ç»­ä½¿ç”¨è¿™äº›ä¸åŒçš„ç»„åˆæ¥æ„å»ºä½ å¯¹ä½•æ—¶ä»¥åŠå¦‚ä½•ä½¿ç”¨æ¯ç§å½¢å¼çš„ç†è§£ã€‚
- en: 13.1.4Â Mutating Parameters in Function Calls[ğŸ”—](#(part._.Mutating_.Parameters_in_.Function_.Calls)
    "Link to here")
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.4 å‡½æ•°è°ƒç”¨ä¸­å‚æ•°çš„ä¿®æ”¹[ğŸ”—](#(part._.Mutating_.Parameters_in_.Function_.Calls) "é“¾æ¥åˆ°æ­¤å¤„")
- en: In [Function Composition and the Directory](Conditionals_and_Booleans.html#%28part._func-comp-directory%29),
    we showed how function calls create their own local directory segments to store
    any names that get introduced while running the function. Now that we have the
    ability to update the values associated with variables, we should revisit this
    topic to understand what happens when these updates occur within functions.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨[å‡½æ•°ç»„åˆå’Œç›®å½•](Conditionals_and_Booleans.html#%28part._func-comp-directory%29)ä¸­ï¼Œæˆ‘ä»¬å±•ç¤ºäº†å‡½æ•°è°ƒç”¨å¦‚ä½•åˆ›å»ºè‡ªå·±çš„å±€éƒ¨ç›®å½•æ®µä»¥å­˜å‚¨åœ¨è¿è¡Œå‡½æ•°æ—¶å¼•å…¥çš„ä»»ä½•åç§°ã€‚ç°åœ¨æˆ‘ä»¬æœ‰äº†æ›´æ–°ä¸å˜é‡ç›¸å…³è”çš„å€¼çš„èƒ½åŠ›ï¼Œæˆ‘ä»¬åº”è¯¥é‡æ–°å®¡è§†è¿™ä¸ªä¸»é¢˜ï¼Œä»¥äº†è§£è¿™äº›æ›´æ–°åœ¨å‡½æ•°å†…éƒ¨å‘ç”Ÿæ—¶ä¼šå‘ç”Ÿä»€ä¹ˆã€‚
- en: 'Consider the following two functions:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘ä»¥ä¸‹ä¸¤ä¸ªå‡½æ•°ï¼š
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Letâ€™s use these two functions in a program:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬åœ¨ä¸€ä¸ªç¨‹åºä¸­ä½¿ç”¨è¿™ä¸¤ä¸ªå‡½æ•°ï¼š
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Do Now!
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are the values of `x` and `a` when the program has finished?
  id: totrans-151
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¨‹åºå®Œæˆåï¼Œ`x`å’Œ`a`çš„å€¼æ˜¯ä»€ä¹ˆï¼Ÿ
- en: Letâ€™s draw out the directory and heap for this program.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä¸ºè¿™ä¸ªç¨‹åºç»˜åˆ¶ç›®å½•å’Œå †ã€‚
- en: We need a way to distinguish local directories from the global one â€“ easiest
    for now might be to add a form for local-env-with-heap that uses the label â€œLocal
    Directory (fun name)â€.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éœ€è¦ä¸€ç§æ–¹æ³•æ¥åŒºåˆ†å±€éƒ¨ç›®å½•å’Œå…¨å±€ç›®å½•â€”â€”ç°åœ¨æœ€ç®€å•çš„æ–¹æ³•å¯èƒ½æ˜¯ä¸º`local-env-with-heap`æ·»åŠ ä¸€ä¸ªä½¿ç”¨æ ‡ç­¾â€œå±€éƒ¨ç›®å½•ï¼ˆå‡½æ•°åï¼‰â€çš„è¡¨å•ã€‚
- en: 'After the first two lines but before the function calls, we have the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å‰ä¸¤æ¡è¯­å¥ä¹‹åä½†åœ¨å‡½æ•°è°ƒç”¨ä¹‹å‰ï¼Œæˆ‘ä»¬æœ‰ä»¥ä¸‹å†…å®¹ï¼š
- en: Directory
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE40]'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE40]'
- en: â†’Â `15`
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â `15`
- en: '[PRE41]'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE41]'
- en: â†’Â 1014
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1014
- en: Heap
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1014:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1014:'
- en: '[PRE42]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Calling `add10` creates a local directory containing the name of the parameter:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: è°ƒç”¨`add10`åˆ›å»ºäº†ä¸€ä¸ªåŒ…å«å‚æ•°åç§°çš„å±€éƒ¨ç›®å½•ï¼š
- en: Directory
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE43]'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE43]'
- en: â†’Â `15`
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â `15`
- en: Heap
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1014:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1014:'
- en: '[PRE44]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Wait â€“ why is the heap listed alongside the local directory? Only the directory
    gets localized during function calls. The same heap is used at all times.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ç­‰ç­‰â€”â€”ä¸ºä»€ä¹ˆå †ä¸å±€éƒ¨ç›®å½•å¹¶åˆ—ï¼Ÿåªæœ‰ç›®å½•åœ¨å‡½æ•°è°ƒç”¨æœŸé—´è¢«æœ¬åœ°åŒ–ã€‚å§‹ç»ˆä½¿ç”¨ç›¸åŒçš„å †ã€‚
- en: The body of `add10` now updates the value of `num` in the directory to 25\.
    This does not affect the value of `x` in the top-level directory, for the same
    reasons we explained in [Variable Mutation and Aliasing](#%28part._var-mut-aliasing%29)
    regarding the lack of aliasing between variables that refer to basic data. Thus,
    once the function finishes and the local directory is deleted, the value associated
    with `x` is unchanged.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`add10`çš„ä¸»ä½“ç°åœ¨å°†ç›®å½•ä¸­`num`çš„å€¼æ›´æ–°ä¸º25ã€‚è¿™ä¸ä¼šå½±å“é¡¶çº§ç›®å½•ä¸­`x`çš„å€¼ï¼ŒåŸå› ä¸æˆ‘ä»¬åœ¨[å˜é‡å˜å¼‚å’Œåˆ«å](#%28part._var-mut-aliasing%29)ä¸­è§£é‡Šçš„ç›¸åŒï¼Œå³åŸºæœ¬æ•°æ®å¼•ç”¨çš„å˜é‡ä¹‹é—´æ²¡æœ‰åˆ«åã€‚å› æ­¤ï¼Œä¸€æ—¦å‡½æ•°å®Œæˆå¹¶ä¸”å±€éƒ¨ç›®å½•è¢«åˆ é™¤ï¼Œä¸`x`ç›¸å…³è”çš„å€¼ä¿æŒä¸å˜ã€‚'
- en: Now, letâ€™s evaluate the call `deposit10(a)`. As with `add10`, we create a local
    directory and create an entry for the parameter. What gets associated with that
    parameter in the directory, however?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬è¯„ä¼°`deposit10(a)`çš„è°ƒç”¨ã€‚ä¸`add10`ä¸€æ ·ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªå±€éƒ¨ç›®å½•å¹¶ä¸ºå‚æ•°åˆ›å»ºäº†ä¸€ä¸ªæ¡ç›®ã€‚ç„¶è€Œï¼Œç›®å½•ä¸­ä¸è¯¥å‚æ•°ç›¸å…³è”çš„æ˜¯ä»€ä¹ˆï¼Ÿ
- en: Directory
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE45]'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE45]'
- en: â†’Â 1014
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1014
- en: Heap
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1014:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1014:'
- en: '[PRE46]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Do Now!
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Do Now!
- en: ''
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why didnâ€™t we create a new `Account` datum when we made the function call?
  id: totrans-181
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆæˆ‘ä»¬åœ¨å‡½æ•°è°ƒç”¨æ—¶æ²¡æœ‰åˆ›å»ºä¸€ä¸ªæ–°çš„`Account`æ•°æ®ï¼Ÿ
- en: 'Remember our rule for when we create new data in the heap: we only create heap
    data when we explicitly use a constructor. The function call does not involve
    creating a new `Account`. Whatever is associated with the name `a` gets associated
    with the parameter name `ac`. In other words, we have created an alias between
    `a` and `ac`.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: è®°ä½æˆ‘ä»¬åˆ›å»ºå †ä¸­æ–°æ•°æ®æ—¶çš„è§„åˆ™ï¼šæˆ‘ä»¬åªåœ¨æ˜¾å¼ä½¿ç”¨æ„é€ å‡½æ•°æ—¶åˆ›å»ºå †æ•°æ®ã€‚å‡½æ•°è°ƒç”¨ä¸æ¶‰åŠåˆ›å»ºä¸€ä¸ªæ–°çš„`Account`ã€‚ä¸åç§°`a`ç›¸å…³è”çš„ä»»ä½•å†…å®¹éƒ½ä¼šä¸å‚æ•°åç§°`ac`ç›¸å…³è”ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬åœ¨`a`å’Œ`ac`ä¹‹é—´åˆ›å»ºäº†ä¸€ä¸ªåˆ«åã€‚
- en: In the body of `deposit10`, we update the balance of `ac`, which is also the
    balance of `a` due to the aliasing. Since there is no local heap, when the function
    call is over, the new balance persists in `a`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨`deposit10`çš„ä¸»ä½“ä¸­ï¼Œæˆ‘ä»¬æ›´æ–°äº†`ac`çš„ä½™é¢ï¼Œç”±äºåˆ«åçš„åŸå› ï¼Œ`ac`ä¹Ÿæ˜¯`a`çš„ä½™é¢ã€‚ç”±äºæ²¡æœ‰å±€éƒ¨å †æ ˆï¼Œå½“å‡½æ•°è°ƒç”¨ç»“æŸæ—¶ï¼Œæ–°çš„ä½™é¢ä¼šæŒç»­å­˜åœ¨äº`a`ä¸­ã€‚
- en: All weâ€™ve done here is put together pieces that weâ€™ve already seen, just in
    a new context. Weâ€™re passing parameters and updating either the (local) directory
    or the heap according to how we have used `=`. But this example highlights a detail
    that initially confuses many people when they start writing functions that update
    variables.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨è¿™é‡Œæ‰€åšçš„åªæ˜¯å°†æˆ‘ä»¬å·²ç»çœ‹åˆ°çš„ç‰‡æ®µç»„åˆåœ¨ä¸€èµ·ï¼Œåªæ˜¯åœ¨ä¸€ä¸ªæ–°çš„ä¸Šä¸‹æ–‡ä¸­ã€‚æˆ‘ä»¬ä¼ é€’å‚æ•°å¹¶æ ¹æ®æˆ‘ä»¬å¦‚ä½•ä½¿ç”¨`=`æ¥æ›´æ–°ï¼ˆå±€éƒ¨ï¼‰ç›®å½•æˆ–å †æ ˆã€‚ä½†è¿™ä¸ªä¾‹å­çªå‡ºäº†ä¸€ä¸ªç»†èŠ‚ï¼Œå½“äººä»¬å¼€å§‹ç¼–å†™æ›´æ–°å˜é‡çš„å‡½æ•°æ—¶ï¼Œè¿™ä¸ªç»†èŠ‚æœ€åˆä¼šè®©ä»–ä»¬æ„Ÿåˆ°å›°æƒ‘ã€‚
- en: 'Strategy: Updating Values within Functions'
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç­–ç•¥ï¼šåœ¨å‡½æ•°ä¸­æ›´æ–°å€¼
- en: ''
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you want a function to update a value and have that update persist after
    the function completes, you must put that value inside a piece of data. You cannot
    have it be basic data associated with a variable name.
  id: totrans-187
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœä½ å¸Œæœ›ä¸€ä¸ªå‡½æ•°æ›´æ–°ä¸€ä¸ªå€¼ï¼Œå¹¶ä¸”è¯¥æ›´æ–°åœ¨å‡½æ•°å®ŒæˆåæŒç»­å­˜åœ¨ï¼Œä½ å¿…é¡»å°†é‚£ä¸ªå€¼æ”¾åœ¨æ•°æ®çš„ä¸€ä¸ªéƒ¨åˆ†ä¸­ã€‚ä½ ä¸èƒ½è®©å®ƒä¸å˜é‡åç§°ç›¸å…³è”çš„åŸºæœ¬æ•°æ®ã€‚
- en: 13.1.5Â Mutating Top-Level Variables within Functions[ğŸ”—](#(part._mut-top-level-vars-in-func)
    "Link to here")
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.5Â åœ¨å‡½æ•°ä¸­ä¿®æ”¹é¡¶çº§å˜é‡[ğŸ”—](#(part._mut-top-level-vars-in-func) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Letâ€™s return to our banking example to illustrate a situation where the ability
    to update variables is extremely useful. Consider our current process for creating
    new accounts in the bank by looking at the following example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å›åˆ°æˆ‘ä»¬çš„é“¶è¡Œç¤ºä¾‹ï¼Œä»¥è¯´æ˜æ›´æ–°å˜é‡èƒ½åŠ›éå¸¸æœ‰ç”¨çš„æƒ…å†µã€‚è€ƒè™‘æˆ‘ä»¬å½“å‰åœ¨é“¶è¡Œåˆ›å»ºæ–°è´¦æˆ·çš„è¿‡ç¨‹ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Notice that each time we create an `Account` we have to take care to increase
    the id number? What if we made a typo or accidentally forgot to do this?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæ¯æ¬¡æˆ‘ä»¬åˆ›å»ºä¸€ä¸ª`Account`æ—¶ï¼Œéƒ½å¿…é¡»å°å¿ƒåœ°å¢åŠ IDå·ï¼Ÿå¦‚æœæˆ‘ä»¬çŠ¯äº†æ‹¼å†™é”™è¯¯æˆ–æ„å¤–å¿˜è®°è¿™æ ·åšæ€ä¹ˆåŠï¼Ÿ
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now weâ€™d have multiple accounts with the same ID number, when we really need
    these numbers to be unique across all accounts. To avoid such problems, we should
    instead have a function for creating accounts that takes the initial balance as
    input and uses a guaranteed-unique ID number.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬ä¼šæœ‰å¤šä¸ªè´¦æˆ·å…·æœ‰ç›¸åŒçš„IDå·ç ï¼Œè€Œå®é™…ä¸Šæˆ‘ä»¬éœ€è¦è¿™äº›å·ç åœ¨æ‰€æœ‰è´¦æˆ·ä¸­éƒ½æ˜¯å”¯ä¸€çš„ã€‚ä¸ºäº†é¿å…è¿™æ ·çš„é—®é¢˜ï¼Œæˆ‘ä»¬åº”è¯¥æœ‰ä¸€ä¸ªåˆ›å»ºè´¦æˆ·çš„å‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—åˆå§‹ä½™é¢ä½œä¸ºè¾“å…¥å¹¶ä½¿ç”¨ä¿è¯å”¯ä¸€çš„IDå·ç ã€‚
- en: 'How might we write such a function? The challenge is to be able to generate
    unique ID numbers each time. What if we used a variable to store the next available
    ID number, updating it each time we created a new account? That function might
    look at follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•ç¼–å†™è¿™æ ·çš„å‡½æ•°ï¼ŸæŒ‘æˆ˜æ˜¯æ¯æ¬¡éƒ½èƒ½ç”Ÿæˆå”¯ä¸€çš„IDå·ç ã€‚å¦‚æœæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªå˜é‡æ¥å­˜å‚¨ä¸‹ä¸€ä¸ªå¯ç”¨çš„IDå·ç ï¼Œå¹¶åœ¨åˆ›å»ºæ–°è´¦æˆ·æ—¶æ›´æ–°å®ƒï¼Œä¼šæ€æ ·ï¼Ÿè¯¥å‡½æ•°å¯èƒ½çœ‹èµ·æ¥å¦‚ä¸‹ï¼š
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Letâ€™s run this program, creating new accounts as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è¿è¡Œè¿™ä¸ªç¨‹åºï¼ŒæŒ‰ç…§ä»¥ä¸‹æ–¹å¼åˆ›å»ºæ–°è´¦æˆ·ï¼š
- en: '[PRE50]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Do Now!
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Copy this code into Python and run it. Check that each of `ac5`, `ac6`, and
    `ac7` have unique ID numbers.
  id: totrans-200
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°†æ­¤ä»£ç å¤åˆ¶åˆ°Pythonä¸­å¹¶è¿è¡Œå®ƒã€‚æ£€æŸ¥`ac5`ã€`ac6`å’Œ`ac7`æ˜¯å¦éƒ½å…·æœ‰å”¯ä¸€çš„IDå·ç ã€‚
- en: What happened? All three of these have the same ID of `8000`. It looks like
    our update to `nextID` just didnâ€™t work. Actually, it did work, but to understand
    how, we have to look at what happened in the directory.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿè¿™ä¸‰ä¸ªéƒ½æ‹¥æœ‰ç›¸åŒçš„ID `8000`ã€‚çœ‹èµ·æ¥æˆ‘ä»¬å¯¹`nextID`çš„æ›´æ–°å¹¶æ²¡æœ‰èµ·ä½œç”¨ã€‚å®é™…ä¸Šï¼Œå®ƒç¡®å®èµ·ä½œç”¨äº†ï¼Œä½†ä¸ºäº†ç†è§£å®ƒæ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Œæˆ‘ä»¬å¿…é¡»çœ‹çœ‹ç›®å½•ä¸­å‘ç”Ÿäº†ä»€ä¹ˆã€‚
- en: Do Now!
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Draw the memory diagram for this example.
  id: totrans-204
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºæ­¤ç¤ºä¾‹ç»˜åˆ¶å†…å­˜å›¾ã€‚
- en: 'After we set up `nextID` and define the function, our memory diagram appears
    as:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬è®¾ç½®`nextID`å¹¶å®šä¹‰å‡½æ•°åï¼Œæˆ‘ä»¬çš„å†…å­˜å›¾å¦‚ä¸‹æ‰€ç¤ºï¼š
- en: Directory
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE51]'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE51]'
- en: â†’Â `8000`
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â `8000`
- en: Now, letâ€™s evaluate `ac5 = create_acct(435)`. We call `create_acct`, which yields
    the following local directory after creating the `Account` but before updating
    `nextID`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬è¯„ä¼°`ac5 = create_acct(435)`ã€‚æˆ‘ä»¬è°ƒç”¨`create_acct`ï¼Œåœ¨åˆ›å»º`Account`ä¹‹åä½†åœ¨æ›´æ–°`nextID`ä¹‹å‰ï¼Œå¾—åˆ°ä»¥ä¸‹å±€éƒ¨ç›®å½•ã€‚
- en: Directory
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE52]'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE52]'
- en: â†’Â `435`
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â `435`
- en: '[PRE53]'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE53]'
- en: â†’Â 1015
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1015
- en: Heap
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: å †æ ˆ
- en: '1015:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1015:'
- en: '[PRE54]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Do Now!
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you think happens when we run `nextID = nextID + 1`?
  id: totrans-220
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ è®¤ä¸ºå½“æˆ‘ä»¬è¿è¡Œ`nextID = nextID + 1`æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
- en: Letâ€™s run this carefully. Python first evaluates the right side of the `=` (`nextID
    + 1`). `nextID` is not in the local directory, so Python retrieves its value (`8000`)
    from the top-level directory. Thus, this computation becomes `nextID = 8001`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä»”ç»†è¿è¡Œè¿™ä¸ªç¨‹åºã€‚Pythoné¦–å…ˆè¯„ä¼°`=`å³ä¾§çš„è¡¨è¾¾å¼ï¼ˆ`nextID + 1`ï¼‰ã€‚`nextID`ä¸åœ¨å±€éƒ¨ç›®å½•ä¸­ï¼Œå› æ­¤Pythonä»é¡¶çº§ç›®å½•æ£€ç´¢å…¶å€¼ï¼ˆ`8000`ï¼‰ã€‚å› æ­¤ï¼Œè¿™ä¸ªè®¡ç®—å˜æˆäº†`nextID
    = 8001`ã€‚
- en: 'The question here is how Python treats `nextID = 8001`: we currently have both
    the local directory for the function call and the top-level directory. Which one
    should get the new value of `nextID`? Since the local directory is active, Python
    sets the value of `nextID` there.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œçš„é—®é¢˜æ˜¯Pythonå¦‚ä½•å¤„ç†`nextID = 8001`ï¼šæˆ‘ä»¬ç›®å‰æ—¢æœ‰å‡½æ•°è°ƒç”¨çš„å±€éƒ¨ç›®å½•ï¼Œä¹Ÿæœ‰é¡¶çº§ç›®å½•ã€‚å“ªä¸ªåº”è¯¥è·å¾—`nextID`çš„æ–°å€¼ï¼Ÿç”±äºå±€éƒ¨ç›®å½•æ˜¯æ´»åŠ¨çš„ï¼ŒPythonå°†`nextID`çš„å€¼è®¾ç½®åœ¨é‚£é‡Œã€‚
- en: Directory
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE55]'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE55]'
- en: â†’Â `435`
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â `435`
- en: '[PRE56]'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE56]'
- en: â†’Â 1015
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1015
- en: '[PRE57]'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE57]'
- en: â†’Â `8001`
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â `8001`
- en: Heap
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: å †æ ˆ
- en: '1015:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1015:'
- en: '[PRE58]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Letâ€™s repeat that: Python computed `nextID + 1` using the `nextID` value from
    the top-level directory since there was no value for `nextID` in the local directory.
    But the setting of the value of `nextID` could and did occur in the local directory.
    Thus, when `create_acct` finishes, the value of `nextID` in the top-level directory
    is unchanged. As a result, all of the accounts get the same value.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬é‡å¤ä¸€ä¸‹ï¼šPythonä½¿ç”¨é¡¶çº§ç›®å½•ä¸­çš„`nextID`å€¼è®¡ç®—äº†`nextID + 1`ï¼Œå› ä¸ºåœ¨å±€éƒ¨ç›®å½•ä¸­æ²¡æœ‰`nextID`çš„å€¼ã€‚ä½†æ˜¯ï¼Œ`nextID`å€¼çš„è®¾ç½®å¯ä»¥åœ¨å±€éƒ¨ç›®å½•ä¸­å‘ç”Ÿã€‚å› æ­¤ï¼Œå½“`create_acct`å®Œæˆæ—¶ï¼Œé¡¶çº§ç›®å½•ä¸­çš„`nextID`å€¼ä¿æŒä¸å˜ã€‚ç»“æœï¼Œæ‰€æœ‰è´¦æˆ·éƒ½è·å¾—äº†ç›¸åŒçš„å€¼ã€‚
- en: 'The computuation we are trying to doâ€”<wbr>updating the top-level variableâ€”<wbr>is
    just fine. The problem is that Python (reasonably) defaults to the local directory.
    To make this work, we need to tell Python that we want to make updates to `next_id`
    in the top-level directory. Hereâ€™s the version of `create_acct` that does that:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¯•å›¾è¿›è¡Œçš„è®¡ç®—â€”â€”æ›´æ–°é¡¶çº§å˜é‡â€”â€”æ˜¯æ­£å¸¸çš„ã€‚é—®é¢˜æ˜¯Pythonï¼ˆåˆç†åœ°ï¼‰é»˜è®¤ä½¿ç”¨å±€éƒ¨ç›®å½•ã€‚ä¸ºäº†ä½¿å…¶å·¥ä½œï¼Œæˆ‘ä»¬éœ€è¦å‘Šè¯‰Pythonæˆ‘ä»¬æƒ³è¦åœ¨é¡¶çº§ç›®å½•ä¸­æ›´æ–°`next_id`ã€‚ä»¥ä¸‹æ˜¯æ‰§è¡Œæ­¤æ“ä½œçš„`create_acct`ç‰ˆæœ¬ï¼š
- en: '[PRE59]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `global` keyword tells Python to make updates to the given variable in the
    top-level directory, not the local directory. Once we make this modification,
    each account we create will get a unique ID number.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`global`å…³é”®å­—å‘Šè¯‰Pythonåœ¨é¡¶çº§ç›®å½•ä¸­æ›´æ–°ç»™å®šçš„å˜é‡ï¼Œè€Œä¸æ˜¯åœ¨å±€éƒ¨ç›®å½•ä¸­ã€‚ä¸€æ—¦æˆ‘ä»¬è¿›è¡Œæ­¤ä¿®æ”¹ï¼Œæˆ‘ä»¬åˆ›å»ºçš„æ¯ä¸ªè´¦æˆ·éƒ½å°†è·å¾—å”¯ä¸€çš„IDå·ç ã€‚'
- en: 'Responsible Computing: Keeping IDs Unpredictable'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è´Ÿè´£ä»»è®¡ç®—ï¼šä¿æŒIDä¸å¯é¢„æµ‹
- en: ''
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'While this general pattern of generating unique IDs works, in practice we shouldnâ€™t
    use consecutive numbers. Consecutive numbers are guessable: if there is an account
    `8000` there must be an account `8001`, and so on. Guessable account numbers could
    make it easier for someone who keeps trying to guess valid IDs to use to log into
    websites or otherwise access information.'
  id: totrans-239
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è™½ç„¶è¿™ç§ç”Ÿæˆå”¯ä¸€IDçš„ä¸€èˆ¬æ¨¡å¼æ˜¯å¯è¡Œçš„ï¼Œä½†åœ¨å®é™…æ“ä½œä¸­æˆ‘ä»¬ä¸åº”è¯¥ä½¿ç”¨è¿ç»­çš„æ•°å­—ã€‚è¿ç»­çš„æ•°å­—æ˜¯å¯ä»¥çŒœæµ‹çš„ï¼šå¦‚æœå­˜åœ¨ä¸€ä¸ªè´¦æˆ·`8000`ï¼Œé‚£ä¹ˆå¿…ç„¶å­˜åœ¨ä¸€ä¸ªè´¦æˆ·`8001`ï¼Œä»¥æ­¤ç±»æ¨ã€‚å¯çŒœæµ‹çš„è´¦æˆ·å·ç å¯èƒ½ä¼šè®©é‚£äº›ä¸æ–­å°è¯•çŒœæµ‹æœ‰æ•ˆIDçš„äººæ›´å®¹æ˜“ç™»å½•ç½‘ç«™æˆ–ä»¥å…¶ä»–æ–¹å¼è®¿é—®ä¿¡æ¯ã€‚
- en: ''
  id: totrans-240
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Instead, we would use a computation that is less predictable than â€œadd 1â€ when
    storing the `nextID` value. For now, the pattern we have shown you is fine. If
    you were building a real system, however, youâ€™d want to make that computation
    a bit more sophisticated.
  id: totrans-241
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç›¸åï¼Œæˆ‘ä»¬ä¼šåœ¨å­˜å‚¨`nextID`å€¼æ—¶ä½¿ç”¨ä¸€ä¸ªæ¯”â€œåŠ 1â€æ›´ä¸å¯é¢„æµ‹çš„è®¡ç®—ã€‚ç›®å‰ï¼Œæˆ‘ä»¬å‘æ‚¨å±•ç¤ºçš„æ¨¡å¼æ˜¯å¯è¡Œçš„ã€‚ç„¶è€Œï¼Œå¦‚æœæ‚¨æ­£åœ¨æ„å»ºä¸€ä¸ªçœŸå®çš„ç³»ç»Ÿï¼Œæ‚¨å¯èƒ½å¸Œæœ›ä½¿è¿™ä¸ªè®¡ç®—æ›´åŠ å¤æ‚ã€‚
- en: 13.1.6Â The Many Roles of Variables[ğŸ”—](#(part._.The_.Many_.Roles_of_.Variables)
    "Link to here")
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.6 å˜é‡çš„å¤šç§è§’è‰²[ğŸ”—](#(part._.The_.Many_.Roles_of_.Variables) "é“¾æ¥è‡³æ­¤")
- en: 'At this point, we have used the single coding construct of a variable in the
    directory for multiple purposes. Itâ€™s worth stepping back and calling those out
    explicitly. In general, variables serve one of the following purposes:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»åœ¨ä¸€ä¸ªç›®å½•ä¸­ä½¿ç”¨äº†å˜é‡çš„å•ä¸€ç¼–ç ç»“æ„æ¥å®Œæˆå¤šä¸ªç›®çš„ã€‚å€¼å¾—é€€ä¸€æ­¥å¹¶æ˜ç¡®æŒ‡å‡ºè¿™äº›ç›®çš„ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œå˜é‡æœåŠ¡äºä»¥ä¸‹ç›®çš„ä¹‹ä¸€ï¼š
- en: Tracking progress of a computation (e.g., the running value of a result in a
    `for`-loop)
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è·Ÿè¸ªè®¡ç®—çš„è¿›åº¦ï¼ˆä¾‹å¦‚ï¼Œ`for`å¾ªç¯ä¸­ç»“æœçš„è¿è¡Œå€¼ï¼‰
- en: Maintaining information across multiple calls to a single function (e.g., the
    `next-id` variable)
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åœ¨å¯¹å•ä¸ªå‡½æ•°çš„å¤šæ¬¡è°ƒç”¨ä¸­ç»´æŠ¤ä¿¡æ¯ï¼ˆä¾‹å¦‚ï¼Œ`next-id`å˜é‡ï¼‰
- en: Naming a local or intermediate value in a computation
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åœ¨è®¡ç®—ä¸­å‘½åå±€éƒ¨æˆ–ä¸­é—´å€¼
- en: Each of these uses involves a different programming pattern. The first creates
    a variable locally within a function. The second two create top-level variables
    and require using `global` in functions that modify the contents. The third is
    different from the second, however, in that the third is only meant to be used
    by a single function. Ideally, there would be a way to not expose the variable
    to all functions in the third case. Indeed, many programming languages (including
    Pyret) make it easy to do that. This is harder to achieve with introductory-level
    concepts in Python, however. The fourth is more about local names rather than
    variables, in that our code never updates the value after the variable is created.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›ç”¨é€”éƒ½æ¶‰åŠä¸åŒçš„ç¼–ç¨‹æ¨¡å¼ã€‚ç¬¬ä¸€ä¸ªæ˜¯åœ¨å‡½æ•°å†…éƒ¨åˆ›å»ºä¸€ä¸ªå±€éƒ¨å˜é‡ã€‚åä¸¤ä¸ªåˆ›å»ºé¡¶å±‚å˜é‡ï¼Œå¹¶åœ¨ä¿®æ”¹å†…å®¹çš„åŠŸèƒ½ä¸­éœ€è¦ä½¿ç”¨`global`ã€‚ç„¶è€Œï¼Œç¬¬ä¸‰ä¸ªä¸ç¬¬äºŒä¸ªä¸åŒï¼Œå› ä¸ºç¬¬ä¸‰ä¸ªåªæ‰“ç®—ç”±ä¸€ä¸ªå‡½æ•°ä½¿ç”¨ã€‚ç†æƒ³æƒ…å†µä¸‹ï¼Œä¼šæœ‰ä¸€ç§æ–¹æ³•ä¸å°†å˜é‡æš´éœ²ç»™æ‰€æœ‰å‡½æ•°ã€‚ç¡®å®ï¼Œè®¸å¤šç¼–ç¨‹è¯­è¨€ï¼ˆåŒ…æ‹¬Pyretï¼‰éƒ½ä½¿è¿™å˜å¾—å¾ˆå®¹æ˜“ã€‚ç„¶è€Œï¼Œåœ¨Pythonçš„å…¥é—¨çº§æ¦‚å¿µä¸­ï¼Œè¿™è¦å›°éš¾å¾—å¤šã€‚ç¬¬å››ä¸ªæ›´å¤šåœ°å…³äºå±€éƒ¨åç§°è€Œä¸æ˜¯å˜é‡ï¼Œå› ä¸ºæˆ‘ä»¬çš„ä»£ç åœ¨å˜é‡åˆ›å»ºåæ°¸è¿œä¸ä¼šæ›´æ–°å…¶å€¼ã€‚
- en: We call out these three roles precisely because they invoke different code patterns,
    despite using the same fine-grained concept (assigning a new value to a variable).
    When you look at a new programming problem, you can ask yourself whether the problem
    involves one of these purposes, and use that to guide your choice of pattern to
    use.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ˜ç¡®æŒ‡å‡ºè¿™ä¸‰ä¸ªè§’è‰²ï¼Œæ­£æ˜¯å› ä¸ºå®ƒä»¬è°ƒç”¨äº†ä¸åŒçš„ä»£ç æ¨¡å¼ï¼Œå°½ç®¡ä½¿ç”¨äº†ç›¸åŒç²¾ç»†çš„æ¦‚å¿µï¼ˆå°†æ–°å€¼èµ‹ç»™å˜é‡ï¼‰ã€‚å½“æ‚¨é¢å¯¹ä¸€ä¸ªæ–°çš„ç¼–ç¨‹é—®é¢˜æ—¶ï¼Œæ‚¨å¯ä»¥é—®è‡ªå·±è¿™ä¸ªé—®é¢˜æ˜¯å¦æ¶‰åŠè¿™äº›ç›®çš„ä¹‹ä¸€ï¼Œå¹¶æ®æ­¤æŒ‡å¯¼æ‚¨é€‰æ‹©ä½¿ç”¨å“ªç§æ¨¡å¼ã€‚
- en: 13.1.1Â Mutating Variables in Memory[ğŸ”—](#(part._mutating-vars-memory) "Link to
    here")
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.1 å†…å­˜ä¸­å˜é‡ä¿®æ”¹[ğŸ”—](#(part._mutating-vars-memory) "é“¾æ¥è‡³æ­¤")
- en: 'Now that we have introduced the idea of the heap, letâ€™s revisit our use of
    a variable to compute the sum of elements in a list. Here again is the code we
    wrote for this earlier (in [Introducing `For` Loops](intro-python.html#%28part._python-for-loops%29)):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»ä»‹ç»äº†å †çš„æ¦‚å¿µï¼Œè®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹æˆ‘ä»¬ä½¿ç”¨å˜é‡æ¥è®¡ç®—åˆ—è¡¨ä¸­å…ƒç´ æ€»å’Œçš„æ–¹æ³•ã€‚ä¸‹é¢æ˜¯æˆ‘ä»¬ä¹‹å‰ç¼–å†™çš„ä»£ç ï¼ˆåœ¨[ä»‹ç»`For`å¾ªç¯](intro-python.html#%28part._python-for-loops%29)ä¸­ï¼‰ï¼š
- en: '[PRE60]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Letâ€™s see how the directory and heap update as we run this code. In [Basic Data
    and the Heap](mutating-structures.html#%28part._basic-data-heap%29), we pointed
    out that basic data (such as numbers, strings, and booleans) donâ€™t get put in
    the heap because they have no internal structure. Those values are stored in the
    directory itself. Therefore, the initial value for `run_total` is stored within
    the directory.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹çœ‹åœ¨è¿è¡Œæ­¤ä»£ç æ—¶ç›®å½•å’Œå †æ˜¯å¦‚ä½•æ›´æ–°çš„ã€‚åœ¨[åŸºæœ¬æ•°æ®å’Œå †](mutating-structures.html#%28part._basic-data-heap%29)ä¸­ï¼Œæˆ‘ä»¬æŒ‡å‡ºåŸºæœ¬æ•°æ®ï¼ˆå¦‚æ•°å­—ã€å­—ç¬¦ä¸²å’Œå¸ƒå°”å€¼ï¼‰ä¸ä¼šæ”¾å…¥å †ä¸­ï¼Œå› ä¸ºå®ƒä»¬æ²¡æœ‰å†…éƒ¨ç»“æ„ã€‚è¿™äº›å€¼å­˜å‚¨åœ¨ç›®å½•æœ¬èº«ä¸­ã€‚å› æ­¤ï¼Œ`run_total`çš„åˆå§‹å€¼å­˜å‚¨åœ¨ç›®å½•ä¸­ã€‚
- en: Directory
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE61]'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE61]'
- en: â†’
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE62]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `for` loop also sets up a directory entry, this time for the variable `num`
    that is used to refer to the list elements. When the loop starts, `num` takes
    on the first value in the list. Thus, the directory appears as:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`å¾ªç¯è¿˜è®¾ç½®äº†ä¸€ä¸ªç›®å½•æ¡ç›®ï¼Œè¿™æ¬¡æ˜¯ä¸ºå˜é‡`num`ï¼Œå®ƒç”¨äºå¼•ç”¨åˆ—è¡¨å…ƒç´ ã€‚å½“å¾ªç¯å¼€å§‹æ—¶ï¼Œ`num`å–åˆ—è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªå€¼ã€‚å› æ­¤ï¼Œç›®å½•çœ‹èµ·æ¥å¦‚ä¸‹ï¼š'
- en: Directory
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE63]'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE63]'
- en: â†’
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE64]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE65]'
- en: â†’
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE66]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Inside the `for` loop, we compute a new value for `run_total`. The use of `=`
    tells Python to modify the value of `run_total`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨`for`å¾ªç¯å†…éƒ¨ï¼Œæˆ‘ä»¬è®¡ç®—`run_total`çš„æ–°å€¼ã€‚ä½¿ç”¨`=`å‘Šè¯‰Pythonä¿®æ”¹`run_total`çš„å€¼ã€‚
- en: Do Now!
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does this modification get made in the directory or the heap?
  id: totrans-268
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™ä¸ªä¿®æ”¹æ˜¯åœ¨ç›®å½•è¿˜æ˜¯å †ä¸­è¿›è¡Œçš„ï¼Ÿ
- en: 'Since basic data values are stored only in the directory, this update modifies
    the contents of the directory. The heap isnâ€™t involved:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºåŸºæœ¬æ•°æ®å€¼åªå­˜å‚¨åœ¨ç›®å½•ä¸­ï¼Œè¿™ä¸ªæ›´æ–°ä¿®æ”¹äº†ç›®å½•çš„å†…å®¹ã€‚å †æ²¡æœ‰å‚ä¸ï¼š
- en: Directory
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE67]'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE67]'
- en: â†’
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE68]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE69]'
- en: â†’
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE70]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This process continues: Python advances `num` to the next list element'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤è¿‡ç¨‹ä¼šç»§ç»­ï¼šPythonå°†`num`æ¨è¿›åˆ°ä¸‹ä¸€ä¸ªåˆ—è¡¨å…ƒç´ 
- en: Directory
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE71]'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE71]'
- en: â†’
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE72]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE73]'
- en: â†’
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE74]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: then modifies the value of `run_total`
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åä¿®æ”¹`run_total`çš„å€¼
- en: Directory
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE75]'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE75]'
- en: â†’
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE76]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE77]'
- en: â†’
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE78]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This process continues until all of the list elements have been processed.
    When the for-loop ends, the directory contents are:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤è¿‡ç¨‹ä¼šä¸€ç›´æŒç»­ï¼Œç›´åˆ°åˆ—è¡¨ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½è¢«å¤„ç†å®Œæ¯•ã€‚å½“forå¾ªç¯ç»“æŸæ—¶ï¼Œç›®å½•å†…å®¹å¦‚ä¸‹ï¼š
- en: Directory
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE79]'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE79]'
- en: â†’
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE80]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE81]'
- en: â†’
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE82]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'There are two takeaways from this example:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ä»è¿™ä¸ªä¾‹å­ä¸­æˆ‘ä»¬å¯ä»¥å¾—åˆ°ä¸¤ä¸ªå¯ç¤ºï¼š
- en: When we use `=` to update the value associated with a variable, the variableâ€™s
    entry in the directory changes to reflect the new value.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬ä½¿ç”¨`=`æ¥æ›´æ–°ä¸å˜é‡å…³è”çš„å€¼æ—¶ï¼Œå˜é‡åœ¨ç›®å½•ä¸­çš„æ¡ç›®ä¼šæ”¹å˜ä»¥åæ˜ æ–°å€¼ã€‚
- en: '`For` loops introduce a name into the directory (the one the programmer chose
    to refer to the individual list elements). As the loop progresses, Python updates
    the value associated with that name to refer to each successive element.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`For`å¾ªç¯åœ¨ç›®å½•ä¸­å¼•å…¥äº†ä¸€ä¸ªåç§°ï¼ˆç¨‹åºå‘˜é€‰æ‹©çš„ï¼Œç”¨äºå¼•ç”¨å•ä¸ªåˆ—è¡¨å…ƒç´ ï¼‰ã€‚éšç€å¾ªç¯çš„è¿›è¡Œï¼ŒPythonä¼šæ›´æ–°ä¸è¯¥åç§°å…³è”çš„å€¼ï¼Œä»¥å¼•ç”¨æ¯ä¸ªåç»­å…ƒç´ ã€‚'
- en: Exercise
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Draw the sequence of directory contents for the following program:'
  id: totrans-306
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»˜åˆ¶ä»¥ä¸‹ç¨‹åºçš„ç›®å½•å†…å®¹åºåˆ—ï¼š
- en: ''
  id: totrans-307
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-308
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Exercise
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Draw the sequence of directory contents for the following program:'
  id: totrans-311
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»˜åˆ¶ä»¥ä¸‹ç¨‹åºçš„ç›®å½•å†…å®¹åºåˆ—ï¼š
- en: ''
  id: totrans-312
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-313
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 13.1.2Â Variable Mutation and Aliasing[ğŸ”—](#(part._var-mut-aliasing) "Link to
    here")
  id: totrans-314
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.2 å˜é‡ä¿®æ”¹å’Œåˆ«å[ğŸ”—](#(part._var-mut-aliasing) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'In [Mutating Structures](mutating-structures.html), we saw how a statement
    of the form `elena.acct.balance = 500` resulted in a change to `jorge.acct.balance`.
    Does this same effect occur if we update the value of a variable directly, rather
    than a field? Consider the following example:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨[ä¿®æ”¹ç»“æ„](mutating-structures.html)ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†å½¢å¼ä¸º`elena.acct.balance = 500`çš„è¯­å¥å¦‚ä½•å¯¼è‡´`jorge.acct.balance`çš„æ”¹å˜ã€‚å¦‚æœæˆ‘ä»¬ç›´æ¥æ›´æ–°å˜é‡çš„å€¼è€Œä¸æ˜¯å­—æ®µï¼Œä¼šå‘ç”ŸåŒæ ·çš„æ•ˆæœå—ï¼Ÿè€ƒè™‘ä»¥ä¸‹ç¤ºä¾‹ï¼š
- en: '[PRE85]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Do Now!
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do the directory and heap look like after running this code?
  id: totrans-319
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿è¡Œæ­¤ä»£ç åï¼Œç›®å½•å’Œå †çœ‹èµ·æ¥æ˜¯ä»€ä¹ˆæ ·å­ï¼Ÿ
- en: 'Since `x` and `y` are assigned basic values, there are no values in the heap:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äº`x`å’Œ`y`è¢«åˆ†é…äº†åŸºæœ¬å€¼ï¼Œå †ä¸­æ²¡æœ‰å€¼ï¼š
- en: Directory
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE86]'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE86]'
- en: â†’
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE87]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE88]'
- en: â†’
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE89]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Do Now!
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If we now evaluate `y = 3`, does the value of `x` change?
  id: totrans-330
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬ç°åœ¨è®¡ç®—`y = 3`ï¼Œ`x`çš„å€¼ä¼šæ”¹å˜å—ï¼Ÿ
- en: 'It does not. The value associated with `y` in the directory changes, but there
    is no connection between `x` and `y` in the directory. The statement `x = y` says
    â€œget the value of `y` and associate it with `x` in the directoryâ€. Immediately
    after this statement, `y` and `x` refer to the same value, but this relationship
    is neither tracked nor maintained. If we associate either variable with a new
    value, as we do with `y = 3`, the directory entry for that variableâ€”<wbr>and only
    the directory entry for that variableâ€”<wbr>are changed to reflect the new value.
    Thus, the directory after we evaluate `y = 3` appears as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒä¸ä¼šã€‚ç›®å½•ä¸­ä¸`y`å…³è”çš„å€¼å‘ç”Ÿäº†å˜åŒ–ï¼Œä½†åœ¨ç›®å½•ä¸­`x`å’Œ`y`ä¹‹é—´æ²¡æœ‰è”ç³»ã€‚è¯­å¥`x = y`è¡¨ç¤ºâ€œè·å–`y`çš„å€¼å¹¶å°†å…¶ä¸ç›®å½•ä¸­çš„`x`å…³è”â€ã€‚åœ¨è¿™æ¡è¯­å¥ä¹‹åï¼Œ`y`å’Œ`x`æŒ‡å‘ç›¸åŒçš„å€¼ï¼Œä½†è¿™ç§å…³ç³»æ—¢æ²¡æœ‰è¢«è·Ÿè¸ªä¹Ÿæ²¡æœ‰è¢«ç»´æŠ¤ã€‚å¦‚æœæˆ‘ä»¬å°†ä»»ä¸€å˜é‡ä¸æ–°çš„å€¼å…³è”ï¼Œå°±åƒæˆ‘ä»¬å¯¹`y
    = 3`æ‰€åšçš„é‚£æ ·ï¼Œè¯¥å˜é‡çš„ç›®å½•æ¡ç›®â€”â€”<wbr>ä»¥åŠä»…è¯¥å˜é‡çš„ç›®å½•æ¡ç›®â€”â€”<wbr>å°†æ›´æ”¹ä¸ºåæ˜ æ–°å€¼ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åœ¨è¯„ä¼°`y = 3`åç›®å½•çœ‹èµ·æ¥å¦‚ä¸‹æ‰€ç¤ºï¼š
- en: Directory
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE90]'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE90]'
- en: â†’
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE91]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE92]'
- en: â†’
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’
- en: '[PRE93]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This example highlights that aliasing occurs only when two variables refer to
    the same piece of data with components, not when variables refer to basic data.
    This is because data with components are stored in the heap, with heap address
    stored in the directory. Note, though, that uses of `varname = ...` still affect
    the directory, even when the values are data with components.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªä¾‹å­å¼ºè°ƒäº†åˆ«åä»…åœ¨ä¸¤ä¸ªå˜é‡é€šè¿‡ç»„ä»¶å¼•ç”¨ç›¸åŒçš„æ•°æ®æ—¶å‘ç”Ÿï¼Œè€Œä¸æ˜¯å½“å˜é‡å¼•ç”¨åŸºæœ¬æ•°æ®æ—¶ã€‚è¿™æ˜¯å› ä¸ºå…·æœ‰ç»„ä»¶çš„æ•°æ®å­˜å‚¨åœ¨å †ä¸­ï¼Œå †åœ°å€å­˜å‚¨åœ¨ç›®å½•ä¸­ã€‚è¯·æ³¨æ„ï¼Œå°½ç®¡å¦‚æ­¤ï¼Œä½¿ç”¨`varname
    = ...`ä»ç„¶ä¼šå½±å“ç›®å½•ï¼Œå³ä½¿å€¼æ˜¯å…·æœ‰ç»„ä»¶çš„æ•°æ®ã€‚
- en: Do Now!
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After running the following code, what is the value of `ac2.balance`?
  id: totrans-342
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨è¿è¡Œä»¥ä¸‹ä»£ç åï¼Œ`ac2.balance`çš„å€¼æ˜¯å¤šå°‘ï¼Ÿ
- en: ''
  id: totrans-343
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-344
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE94]'
- en: ''
  id: totrans-345
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Draw the directory and heap contents for this program and check your prediction.
  id: totrans-346
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºæ­¤ç¨‹åºç»˜åˆ¶ç›®å½•å’Œå †çš„å†…å®¹ï¼Œå¹¶æ£€æŸ¥ä½ çš„é¢„æµ‹ã€‚
- en: All three of these lines results in changes in the directory; the first two
    result in changes in the heap, but only because we made new pieces of data. `ac1`
    and `ac2` are alises immediately after running the second line, but the third
    line breaks that relationship.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸‰æ¡è¯­å¥éƒ½ä¼šå¯¼è‡´ç›®å½•å‘ç”Ÿå˜åŒ–ï¼›å‰ä¸¤æ¡ä¼šå¯¼è‡´å †å‘ç”Ÿå˜åŒ–ï¼Œä½†ä»…å› ä¸ºæˆ‘ä»¬åˆ›å»ºäº†æ–°çš„æ•°æ®ã€‚`ac1`å’Œ`ac2`åœ¨è¿è¡Œç¬¬äºŒæ¡è¯­å¥åç«‹å³æˆä¸ºåˆ«åï¼Œä½†ç¬¬ä¸‰æ¡è¯­å¥æ‰“ç ´äº†è¿™ç§å…³ç³»ã€‚
- en: Do Now!
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After running the following code, what is the value of `ac3.balance`?
  id: totrans-350
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨è¿è¡Œä»¥ä¸‹ä»£ç åï¼Œ`ac3.balance`çš„å€¼æ˜¯å¤šå°‘ï¼Ÿ
- en: ''
  id: totrans-351
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-352
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE95]'
- en: ''
  id: totrans-353
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Draw the directory and heap contents for this program and check your prediction.
  id: totrans-354
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºæ­¤ç¨‹åºç»˜åˆ¶ç›®å½•å’Œå †çš„å†…å®¹ï¼Œå¹¶æ£€æŸ¥ä½ çš„é¢„æµ‹ã€‚
- en: Since the value of `savings` is stored in `ac3.balance`, and not the name `savings`
    itself, updating the value of `savings` on the third line does not affect `ac3.balance`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äº`savings`çš„å€¼å­˜å‚¨åœ¨`ac3.balance`ä¸­ï¼Œè€Œä¸æ˜¯åç§°`savings`æœ¬èº«ï¼Œå› æ­¤åœ¨ç¬¬ä¸‰è¡Œæ›´æ–°`savings`çš„å€¼ä¸ä¼šå½±å“`ac3.balance`ã€‚
- en: 13.1.3Â Mutating Variables versus Mutating Data Fields[ğŸ”—](#(part._.Mutating_.Variables_versus_.Mutating_.Data_.Fields)
    "Link to here")
  id: totrans-356
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.3Â å¯å˜å˜é‡ä¸å¯å˜æ•°æ®å­—æ®µ[ğŸ”—](#(part._.Mutating_.Variables_versus_.Mutating_.Data_.Fields)
    "é“¾æ¥è‡³æ­¤")
- en: 'Weâ€™ve now seen two different forms of updates in programs: updates to fields
    of structured data in [Mutating Structures](mutating-structures.html), and updates
    to the values associated with names when computing over lists with `for` loops.
    At a quick glance, these two forms of update look similar:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨å·²ç»çœ‹åˆ°äº†ç¨‹åºä¸­ä¸¤ç§ä¸åŒçš„æ›´æ–°å½¢å¼ï¼šåœ¨[å¯å˜ç»“æ„](mutating-structures.html)ä¸­æ›´æ–°ç»“æ„åŒ–æ•°æ®çš„å­—æ®µï¼Œä»¥åŠåœ¨`for`å¾ªç¯è®¡ç®—åˆ—è¡¨æ—¶æ›´æ–°ä¸åç§°å…³è”çš„å€¼ã€‚ä¹ä¸€çœ‹ï¼Œè¿™ä¸¤ç§æ›´æ–°å½¢å¼çœ‹èµ·æ¥å¾ˆç›¸ä¼¼ï¼š
- en: '[PRE96]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Both use the `=` operator and compute a new value on the right side. The left
    sides, however, are subtly different: one is a field within structured data, while
    the other is a name in the directory. This difference turns out to be significant:
    the first form changes a value stored in the heap but leaves the directory unchanged,
    while the second updates the directory but leaves the heap unchanged.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸¤ç§éƒ½ä½¿ç”¨`=`è¿ç®—ç¬¦å¹¶åœ¨å³ä¾§è®¡ç®—æ–°å€¼ã€‚ç„¶è€Œï¼Œå·¦ä¾§å´æœ‰æ‰€ä¸åŒï¼šä¸€ä¸ªæ˜¯ç»“æ„åŒ–æ•°æ®ä¸­çš„å­—æ®µï¼Œè€Œå¦ä¸€ä¸ªæ˜¯ç›®å½•ä¸­çš„åç§°ã€‚è¿™ç§å·®å¼‚æœ€ç»ˆè¯æ˜æ˜¯é‡è¦çš„ï¼šç¬¬ä¸€ç§å½¢å¼æ›´æ”¹äº†å †ä¸­å­˜å‚¨çš„å€¼ï¼Œä½†ç›®å½•ä¿æŒä¸å˜ï¼Œè€Œç¬¬äºŒç§æ›´æ–°äº†ç›®å½•ä½†å †ä¿æŒä¸å˜ã€‚
- en: At this point, you might not appreciate why this difference is significant.
    But for now, letâ€™s summarize how each of these forms impacts each of the directory
    and the heap.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œä½ å¯èƒ½ä¸ä¼šæ¬£èµè¿™ç§å·®å¼‚çš„é‡è¦æ€§ã€‚ä½†å°±ç›®å‰è€Œè¨€ï¼Œè®©æˆ‘ä»¬æ€»ç»“ä¸€ä¸‹è¿™äº›å½¢å¼å¦‚ä½•å½±å“ç›®å½•å’Œå †ã€‚
- en: 'Strategy: Rules for updating the directory and the heap'
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç­–ç•¥ï¼šæ›´æ–°ç›®å½•å’Œå †çš„è§„åˆ™
- en: ''
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Summarizing, the rules for how the directory and memory update are as follows:'
  id: totrans-363
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ€»ç»“ï¼Œç›®å½•å’Œå†…å­˜æ›´æ–°çš„è§„åˆ™å¦‚ä¸‹ï¼š
- en: ''
  id: totrans-364
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: We add to the heap when a data constructor is used
  id: totrans-365
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“ä½¿ç”¨æ•°æ®æ„é€ å‡½æ•°æ—¶ï¼Œæˆ‘ä»¬å‘å †ä¸­æ·»åŠ å†…å®¹
- en: ''
  id: totrans-366
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-367
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: We update the heap when a field of existing data is reassigned
  id: totrans-368
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“ç°æœ‰æ•°æ®çš„ä¸€ä¸ªå­—æ®µè¢«é‡æ–°åˆ†é…æ—¶ï¼Œæˆ‘ä»¬æ›´æ–°å †
- en: ''
  id: totrans-369
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-370
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: We add to the directory when a name is used for the first time (this includes
    parameters and internal variables when a function is called)
  id: totrans-371
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“ç¬¬ä¸€æ¬¡ä½¿ç”¨ä¸€ä¸ªåç§°æ—¶ï¼Œæˆ‘ä»¬å‘ç›®å½•ä¸­æ·»åŠ ï¼ˆè¿™åŒ…æ‹¬åœ¨å‡½æ•°è°ƒç”¨æ—¶ä½¿ç”¨çš„å‚æ•°å’Œå†…éƒ¨å˜é‡ï¼‰
- en: ''
  id: totrans-372
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-373
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: We update the directory when a name that is already in the directory is subsequently
    assigned a new value)
  id: totrans-374
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“ç›®å½•ä¸­å·²ç»å­˜åœ¨çš„åç§°éšåè¢«åˆ†é…æ–°å€¼æ—¶ï¼Œæˆ‘ä»¬æ›´æ–°ç›®å½•
- en: Do Now!
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After running the following code, what is the value of `ac3.balance`?
  id: totrans-377
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨è¿è¡Œä»¥ä¸‹ä»£ç åï¼Œ`ac3.balance` çš„å€¼æ˜¯å¤šå°‘ï¼Ÿ
- en: ''
  id: totrans-378
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-379
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE97]'
- en: ''
  id: totrans-380
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Draw the directory and heap contents for this program and check your prediction.
  id: totrans-381
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºè¿™ä¸ªç¨‹åºç»˜åˆ¶ç›®å½•å’Œå †çš„å†…å®¹ï¼Œå¹¶æ£€æŸ¥ä½ çš„é¢„æµ‹ã€‚
- en: This example combines updates to variables and updates to fields. On the third
    line, `ac2` and `ac3` refer to the same address in the heap (which contains the
    `Account` with id `8728`. Immediately after updating `ac2.balance` on the fourth
    line, the balance in both `ac2` and `ac3` is 500\. Line six, however, creates
    a new `Account` in the heap and updates the directory to have `ac2` refer to that
    new `Account`. From that point on, `ac2` and `ac3` refer to different accounts,
    so the update to the balance in `ac2` on the seventh line does not affect `ac3`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªä¾‹å­ç»“åˆäº†å˜é‡æ›´æ–°å’Œå­—æ®µæ›´æ–°çš„å†…å®¹ã€‚åœ¨ç¬¬ä¸‰è¡Œï¼Œ`ac2` å’Œ `ac3` æŒ‡å‘å †ä¸­çš„ç›¸åŒåœ°å€ï¼ˆå…¶ä¸­åŒ…å« id ä¸º `8728` çš„ `Account`ã€‚åœ¨ç¬¬å››è¡Œç«‹å³æ›´æ–°
    `ac2.balance` ä¹‹åï¼Œ`ac2` å’Œ `ac3` ä¸­çš„ä½™é¢éƒ½æ˜¯ 500ã€‚ç„¶è€Œï¼Œç¬¬å…­è¡Œåœ¨å †ä¸­åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„ `Account` å¹¶æ›´æ–°ç›®å½•ï¼Œä½¿ `ac2`
    æŒ‡å‘è¿™ä¸ªæ–°çš„ `Account`ã€‚ä»é‚£æ—¶èµ·ï¼Œ`ac2` å’Œ `ac3` æŒ‡å‘ä¸åŒçš„è´¦æˆ·ï¼Œæ‰€ä»¥ç¬¬ä¸ƒè¡Œåœ¨ `ac2` ä¸­æ›´æ–°çš„ä½™é¢ä¸ä¼šå½±å“ `ac3`ã€‚
- en: This example illustrates the subtleties and impacts of different uses of `=`.
    Programs behave differently depending on whether the left side of the `=` is a
    variable name or a field reference, and on whether the right side is basic data
    or data with components. We will continue to work with these various combinations
    to build your understanding of when and how to use each one.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªä¾‹å­è¯´æ˜äº†ä¸åŒä½¿ç”¨ `=` çš„å¾®å¦™ä¹‹å¤„å’Œå½±å“ã€‚ç¨‹åºçš„è¡Œä¸ºå–å†³äº `=` çš„å·¦ä¾§æ˜¯å˜é‡åè¿˜æ˜¯å­—æ®µå¼•ç”¨ï¼Œä»¥åŠå³ä¾§æ˜¯åŸºæœ¬æ•°æ®è¿˜æ˜¯å…·æœ‰ç»„ä»¶çš„æ•°æ®ã€‚æˆ‘ä»¬å°†ç»§ç»­ä½¿ç”¨è¿™äº›ä¸åŒçš„ç»„åˆæ¥æ„å»ºä½ å¯¹ä½•æ—¶ä»¥åŠå¦‚ä½•ä½¿ç”¨æ¯ä¸ªç»„åˆçš„ç†è§£ã€‚
- en: 13.1.4Â Mutating Parameters in Function Calls[ğŸ”—](#(part._.Mutating_.Parameters_in_.Function_.Calls)
    "Link to here")
  id: totrans-384
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.4 å‡½æ•°è°ƒç”¨ä¸­å‚æ•°çš„ä¿®æ”¹[ğŸ”—](#(part._.Mutating_.Parameters_in_.Function_.Calls) "é“¾æ¥åˆ°æ­¤å¤„")
- en: In [Function Composition and the Directory](Conditionals_and_Booleans.html#%28part._func-comp-directory%29),
    we showed how function calls create their own local directory segments to store
    any names that get introduced while running the function. Now that we have the
    ability to update the values associated with variables, we should revisit this
    topic to understand what happens when these updates occur within functions.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ [å‡½æ•°ç»„åˆå’Œç›®å½•](Conditionals_and_Booleans.html#%28part._func-comp-directory%29)
    ä¸­ï¼Œæˆ‘ä»¬å±•ç¤ºäº†å‡½æ•°è°ƒç”¨å¦‚ä½•åˆ›å»ºè‡ªå·±çš„å±€éƒ¨ç›®å½•æ®µæ¥å­˜å‚¨åœ¨è¿è¡Œå‡½æ•°æ—¶å¼•å…¥çš„ä»»ä½•åç§°ã€‚ç°åœ¨æˆ‘ä»¬æœ‰äº†æ›´æ–°ä¸å˜é‡ç›¸å…³è”çš„å€¼çš„èƒ½åŠ›ï¼Œæˆ‘ä»¬åº”è¯¥é‡æ–°å®¡è§†è¿™ä¸ªè¯é¢˜ï¼Œä»¥äº†è§£è¿™äº›æ›´æ–°åœ¨å‡½æ•°å†…éƒ¨å‘ç”Ÿæ—¶ä¼šå‘ç”Ÿä»€ä¹ˆã€‚
- en: 'Consider the following two functions:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘ä»¥ä¸‹ä¸¤ä¸ªå‡½æ•°ï¼š
- en: '[PRE98]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Letâ€™s use these two functions in a program:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬åœ¨ä¸€ä¸ªç¨‹åºä¸­ä½¿ç”¨è¿™ä¸¤ä¸ªå‡½æ•°ï¼š
- en: '[PRE99]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Do Now!
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are the values of `x` and `a` when the program has finished?
  id: totrans-392
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¨‹åºå®Œæˆåï¼Œ`x` å’Œ `a` çš„å€¼æ˜¯ä»€ä¹ˆï¼Ÿ
- en: Letâ€™s draw out the directory and heap for this program.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ç»˜åˆ¶è¿™ä¸ªç¨‹åºçš„ç›®å½•å’Œå †ã€‚
- en: We need a way to distinguish local directories from the global one â€“ easiest
    for now might be to add a form for local-env-with-heap that uses the label â€œLocal
    Directory (fun name)â€.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éœ€è¦ä¸€ç§æ–¹æ³•æ¥åŒºåˆ†å±€éƒ¨ç›®å½•å’Œå…¨å±€ç›®å½•â€”â€”ç°åœ¨æœ€ç®€å•çš„æ–¹æ³•å¯èƒ½æ˜¯ä¸º `local-env-with-heap` æ·»åŠ ä¸€ä¸ªè¡¨å•ï¼Œä½¿ç”¨æ ‡ç­¾â€œå±€éƒ¨ç›®å½•ï¼ˆæœ‰è¶£çš„åå­—ï¼‰â€ã€‚
- en: 'After the first two lines but before the function calls, we have the following:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å‰ä¸¤è¡Œä¹‹åä½†åœ¨å‡½æ•°è°ƒç”¨ä¹‹å‰ï¼Œæˆ‘ä»¬æœ‰ä»¥ä¸‹å†…å®¹ï¼š
- en: Directory
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE100]'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE100]'
- en: â†’Â `15`
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â `15`
- en: '[PRE101]'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE101]'
- en: â†’Â 1014
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1014
- en: Heap
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1014:'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1014:'
- en: '[PRE102]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Calling `add10` creates a local directory containing the name of the parameter:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: è°ƒç”¨ `add10` åˆ›å»ºäº†ä¸€ä¸ªåŒ…å«å‚æ•°åç§°çš„å±€éƒ¨ç›®å½•ï¼š
- en: Directory
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE103]'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE103]'
- en: â†’Â `15`
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â `15`
- en: Heap
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1014:'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1014:'
- en: '[PRE104]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Wait â€“ why is the heap listed alongside the local directory? Only the directory
    gets localized during function calls. The same heap is used at all times.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: ç­‰ç­‰â€”â€”ä¸ºä»€ä¹ˆå †è¢«åˆ—åœ¨å±€éƒ¨ç›®å½•æ—è¾¹ï¼Ÿåªæœ‰ç›®å½•åœ¨å‡½æ•°è°ƒç”¨æœŸé—´è¢«æœ¬åœ°åŒ–ã€‚å§‹ç»ˆä½¿ç”¨ç›¸åŒçš„å †ã€‚
- en: The body of `add10` now updates the value of `num` in the directory to 25\.
    This does not affect the value of `x` in the top-level directory, for the same
    reasons we explained in [Variable Mutation and Aliasing](#%28part._var-mut-aliasing%29)
    regarding the lack of aliasing between variables that refer to basic data. Thus,
    once the function finishes and the local directory is deleted, the value associated
    with `x` is unchanged.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`add10`çš„ä¸»ä½“ç°åœ¨æ›´æ–°äº†ç›®å½•ä¸­`num`çš„å€¼ä¸º25ã€‚è¿™ä¸ä¼šå½±å“é¡¶å±‚ç›®å½•ä¸­`x`çš„å€¼ï¼ŒåŸå› ä¸æˆ‘ä»¬åœ¨[å˜é‡çªå˜å’Œåˆ«å](#%28part._var-mut-aliasing%29)ä¸­è§£é‡Šçš„ç›¸åŒï¼Œå³åŸºæœ¬æ•°æ®å¼•ç”¨çš„å˜é‡ä¹‹é—´æ²¡æœ‰åˆ«åã€‚å› æ­¤ï¼Œä¸€æ—¦å‡½æ•°å®Œæˆå¹¶ä¸”å±€éƒ¨ç›®å½•è¢«åˆ é™¤ï¼Œä¸`x`å…³è”çš„å€¼ä¿æŒä¸å˜ã€‚'
- en: Now, letâ€™s evaluate the call `deposit10(a)`. As with `add10`, we create a local
    directory and create an entry for the parameter. What gets associated with that
    parameter in the directory, however?
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬è¯„ä¼°`deposit10(a)`çš„è°ƒç”¨ã€‚ä¸`add10`ä¸€æ ·ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªå±€éƒ¨ç›®å½•å¹¶ä¸ºå‚æ•°åˆ›å»ºäº†ä¸€ä¸ªæ¡ç›®ã€‚ç„¶è€Œï¼Œåœ¨ç›®å½•ä¸­ä¸è¯¥å‚æ•°å…³è”çš„æ˜¯ä»€ä¹ˆï¼Ÿ
- en: Directory
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE105]'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE105]'
- en: â†’Â 1014
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’ 1014
- en: Heap
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1014:'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1014:'
- en: '[PRE106]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Do Now!
  id: totrans-420
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹å³è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why didnâ€™t we create a new `Account` datum when we made the function call?
  id: totrans-422
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆæˆ‘ä»¬åœ¨å‡½æ•°è°ƒç”¨æ—¶æ²¡æœ‰åˆ›å»ºä¸€ä¸ªæ–°çš„`Account`æ•°æ®ï¼Ÿ
- en: 'Remember our rule for when we create new data in the heap: we only create heap
    data when we explicitly use a constructor. The function call does not involve
    creating a new `Account`. Whatever is associated with the name `a` gets associated
    with the parameter name `ac`. In other words, we have created an alias between
    `a` and `ac`.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: è®°ä½æˆ‘ä»¬åˆ›å»ºå †ä¸­æ–°æ•°æ®æ—¶çš„è§„åˆ™ï¼šæˆ‘ä»¬åªåœ¨æ˜¾å¼ä½¿ç”¨æ„é€ å‡½æ•°æ—¶åˆ›å»ºå †æ•°æ®ã€‚å‡½æ•°è°ƒç”¨ä¸æ¶‰åŠåˆ›å»ºä¸€ä¸ªæ–°çš„`Account`ã€‚ä¸åç§°`a`å…³è”çš„ä»»ä½•å†…å®¹éƒ½ä¼šä¸å‚æ•°åç§°`ac`å…³è”ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬åœ¨`a`å’Œ`ac`ä¹‹é—´åˆ›å»ºäº†ä¸€ä¸ªåˆ«åã€‚
- en: In the body of `deposit10`, we update the balance of `ac`, which is also the
    balance of `a` due to the aliasing. Since there is no local heap, when the function
    call is over, the new balance persists in `a`.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨`deposit10`çš„ä¸»ä½“ä¸­ï¼Œæˆ‘ä»¬æ›´æ–°äº†`ac`çš„ä½™é¢ï¼Œç”±äºåˆ«åï¼Œ`ac`ä¹Ÿæ˜¯`a`çš„ä½™é¢ã€‚ç”±äºæ²¡æœ‰å±€éƒ¨å †ï¼Œå½“å‡½æ•°è°ƒç”¨ç»“æŸæ—¶ï¼Œæ–°çš„ä½™é¢ä¼šæŒç»­å­˜åœ¨äº`a`ä¸­ã€‚
- en: All weâ€™ve done here is put together pieces that weâ€™ve already seen, just in
    a new context. Weâ€™re passing parameters and updating either the (local) directory
    or the heap according to how we have used `=`. But this example highlights a detail
    that initially confuses many people when they start writing functions that update
    variables.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨è¿™é‡Œæ‰€åšçš„åªæ˜¯å°†æˆ‘ä»¬å·²ç»çœ‹åˆ°çš„ç‰‡æ®µç»„åˆèµ·æ¥ï¼Œåªæ˜¯åœ¨ä¸€ä¸ªæ–°çš„ç¯å¢ƒä¸­ã€‚æˆ‘ä»¬ä¼ é€’å‚æ•°å¹¶æ ¹æ®æˆ‘ä»¬å¦‚ä½•ä½¿ç”¨`=`æ¥æ›´æ–°ï¼ˆå±€éƒ¨ï¼‰ç›®å½•æˆ–å †ã€‚ä½†è¿™ä¸ªä¾‹å­çªå‡ºäº†ä¸€ä¸ªç»†èŠ‚ï¼Œå½“äººä»¬å¼€å§‹ç¼–å†™æ›´æ–°å˜é‡çš„å‡½æ•°æ—¶ï¼Œè¿™ä¸ªç»†èŠ‚æœ€åˆä¼šè®©ä»–ä»¬æ„Ÿåˆ°å›°æƒ‘ã€‚
- en: 'Strategy: Updating Values within Functions'
  id: totrans-426
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç­–ç•¥ï¼šåœ¨å‡½æ•°ä¸­æ›´æ–°å€¼
- en: ''
  id: totrans-427
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you want a function to update a value and have that update persist after
    the function completes, you must put that value inside a piece of data. You cannot
    have it be basic data associated with a variable name.
  id: totrans-428
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœä½ å¸Œæœ›ä¸€ä¸ªå‡½æ•°æ›´æ–°ä¸€ä¸ªå€¼ï¼Œå¹¶ä¸”è¿™ä¸ªæ›´æ–°åœ¨å‡½æ•°å®Œæˆåä»ç„¶æŒç»­ï¼Œä½ å¿…é¡»å°†è¿™ä¸ªå€¼æ”¾åœ¨ä¸€ä¸ªæ•°æ®ç»“æ„ä¸­ã€‚ä½ ä¸èƒ½è®©å®ƒæˆä¸ºä¸å˜é‡åç›¸å…³çš„åŸºæœ¬æ•°æ®ã€‚
- en: 13.1.5Â Mutating Top-Level Variables within Functions[ğŸ”—](#(part._mut-top-level-vars-in-func)
    "Link to here")
  id: totrans-429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.5 åœ¨å‡½æ•°ä¸­ä¿®æ”¹é¡¶å±‚å˜é‡[ğŸ”—](#(part._mut-top-level-vars-in-func) "é“¾æ¥è‡³æ­¤")
- en: 'Letâ€™s return to our banking example to illustrate a situation where the ability
    to update variables is extremely useful. Consider our current process for creating
    new accounts in the bank by looking at the following example:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å›åˆ°æˆ‘ä»¬çš„é“¶è¡Œç¤ºä¾‹ï¼Œä»¥è¯´æ˜åœ¨å“ªç§æƒ…å†µä¸‹æ›´æ–°å˜é‡çš„èƒ½åŠ›éå¸¸æœ‰ç”¨ã€‚è€ƒè™‘æˆ‘ä»¬å½“å‰åœ¨é“¶è¡Œåˆ›å»ºæ–°è´¦æˆ·çš„è¿‡ç¨‹ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE107]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Notice that each time we create an `Account` we have to take care to increase
    the id number? What if we made a typo or accidentally forgot to do this?
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæ¯æ¬¡æˆ‘ä»¬åˆ›å»ºä¸€ä¸ª`Account`æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»å°å¿ƒåœ°å¢åŠ IDå·ç ï¼Ÿå¦‚æœæˆ‘ä»¬çŠ¯äº†æ‹¼å†™é”™è¯¯æˆ–æ„å¤–å¿˜è®°äº†è¿™æ ·åšæ€ä¹ˆåŠï¼Ÿ
- en: '[PRE108]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Now weâ€™d have multiple accounts with the same ID number, when we really need
    these numbers to be unique across all accounts. To avoid such problems, we should
    instead have a function for creating accounts that takes the initial balance as
    input and uses a guaranteed-unique ID number.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬ä¼šæœ‰å¤šä¸ªå…·æœ‰ç›¸åŒIDå·ç çš„è´¦æˆ·ï¼Œè€Œå®é™…ä¸Šæˆ‘ä»¬éœ€è¦è¿™äº›å·ç åœ¨æ‰€æœ‰è´¦æˆ·ä¸­éƒ½æ˜¯å”¯ä¸€çš„ã€‚ä¸ºäº†é¿å…è¿™æ ·çš„é—®é¢˜ï¼Œæˆ‘ä»¬åº”è¯¥æœ‰ä¸€ä¸ªåˆ›å»ºè´¦æˆ·çš„å‡½æ•°ï¼Œå®ƒæ¥å—åˆå§‹ä½™é¢ä½œä¸ºè¾“å…¥å¹¶ä½¿ç”¨ä¸€ä¸ªä¿è¯å”¯ä¸€çš„IDå·ç ã€‚
- en: 'How might we write such a function? The challenge is to be able to generate
    unique ID numbers each time. What if we used a variable to store the next available
    ID number, updating it each time we created a new account? That function might
    look at follows:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•ç¼–å†™è¿™æ ·çš„å‡½æ•°ï¼ŸæŒ‘æˆ˜åœ¨äºæ¯æ¬¡éƒ½èƒ½ç”Ÿæˆå”¯ä¸€çš„IDå·ç ã€‚å¦‚æœæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªå˜é‡æ¥å­˜å‚¨ä¸‹ä¸€ä¸ªå¯ç”¨çš„IDå·ç ï¼Œå¹¶åœ¨åˆ›å»ºæ–°è´¦æˆ·æ—¶æ›´æ–°å®ƒï¼Œè¿™ä¸ªå‡½æ•°å¯èƒ½çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ï¼š
- en: '[PRE109]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Letâ€™s run this program, creating new accounts as follows:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è¿è¡Œè¿™ä¸ªç¨‹åºï¼ŒæŒ‰ç…§ä»¥ä¸‹æ–¹å¼åˆ›å»ºæ–°è´¦æˆ·ï¼š
- en: '[PRE110]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Do Now!
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹å³è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Copy this code into Python and run it. Check that each of `ac5`, `ac6`, and
    `ac7` have unique ID numbers.
  id: totrans-441
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°†æ­¤ä»£ç å¤åˆ¶åˆ° Python ä¸­å¹¶è¿è¡Œå®ƒã€‚æ£€æŸ¥ `ac5`ã€`ac6` å’Œ `ac7` æ˜¯å¦éƒ½æœ‰å”¯ä¸€çš„ ID å·ç ã€‚
- en: What happened? All three of these have the same ID of `8000`. It looks like
    our update to `nextID` just didnâ€™t work. Actually, it did work, but to understand
    how, we have to look at what happened in the directory.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿè¿™ä¸‰ä¸ªéƒ½æœ‰ç›¸åŒçš„ ID `8000`ã€‚çœ‹èµ·æ¥æˆ‘ä»¬çš„ `nextID` æ›´æ–°å¹¶æ²¡æœ‰èµ·ä½œç”¨ã€‚å®é™…ä¸Šï¼Œå®ƒç¡®å®èµ·ä½œç”¨äº†ï¼Œä½†ä¸ºäº†ç†è§£å®ƒæ˜¯å¦‚ä½•èµ·ä½œç”¨çš„ï¼Œæˆ‘ä»¬å¿…é¡»çœ‹çœ‹ç›®å½•ä¸­å‘ç”Ÿäº†ä»€ä¹ˆã€‚
- en: Do Now!
  id: totrans-443
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-444
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Draw the memory diagram for this example.
  id: totrans-445
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºæ­¤ç¤ºä¾‹ç»˜åˆ¶å†…å­˜å›¾ã€‚
- en: 'After we set up `nextID` and define the function, our memory diagram appears
    as:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬è®¾ç½® `nextID` å¹¶å®šä¹‰å‡½æ•°ä¹‹åï¼Œæˆ‘ä»¬çš„å†…å­˜å›¾å¦‚ä¸‹æ‰€ç¤ºï¼š
- en: Directory
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE111]'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE111]'
- en: â†’Â `8000`
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â `8000`
- en: Now, letâ€™s evaluate `ac5 = create_acct(435)`. We call `create_acct`, which yields
    the following local directory after creating the `Account` but before updating
    `nextID`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬è¯„ä¼° `ac5 = create_acct(435)`ã€‚æˆ‘ä»¬è°ƒç”¨ `create_acct`ï¼Œåœ¨åˆ›å»º `Account` ä½†åœ¨æ›´æ–° `nextID`
    ä¹‹å‰ï¼Œå¾—åˆ°ä»¥ä¸‹æœ¬åœ°ç›®å½•ã€‚
- en: Directory
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE112]'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE112]'
- en: â†’Â `435`
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â `435`
- en: '[PRE113]'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE113]'
- en: â†’Â 1015
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1015
- en: Heap
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1015:'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1015:'
- en: '[PRE114]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Do Now!
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-460
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you think happens when we run `nextID = nextID + 1`?
  id: totrans-461
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ è®¤ä¸ºå½“æˆ‘ä»¬è¿è¡Œ `nextID = nextID + 1` æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
- en: Letâ€™s run this carefully. Python first evaluates the right side of the `=` (`nextID
    + 1`). `nextID` is not in the local directory, so Python retrieves its value (`8000`)
    from the top-level directory. Thus, this computation becomes `nextID = 8001`.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä»”ç»†è¿è¡Œè¿™ä¸ªã€‚Python é¦–å…ˆè¯„ä¼° `=` çš„å³ä¾§ï¼ˆ`nextID + 1`ï¼‰ã€‚`nextID` ä¸åœ¨æœ¬åœ°ç›®å½•ä¸­ï¼Œå› æ­¤ Python ä»é¡¶çº§ç›®å½•æ£€ç´¢å…¶å€¼ï¼ˆ`8000`ï¼‰ã€‚å› æ­¤ï¼Œè¿™ä¸ªè®¡ç®—å˜ä¸º
    `nextID = 8001`ã€‚
- en: 'The question here is how Python treats `nextID = 8001`: we currently have both
    the local directory for the function call and the top-level directory. Which one
    should get the new value of `nextID`? Since the local directory is active, Python
    sets the value of `nextID` there.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œçš„é—®é¢˜æ˜¯ Python å¦‚ä½•å¤„ç† `nextID = 8001`ï¼šæˆ‘ä»¬ç›®å‰æ—¢æœ‰å‡½æ•°è°ƒç”¨çš„æœ¬åœ°ç›®å½•ï¼Œä¹Ÿæœ‰é¡¶çº§ç›®å½•ã€‚å“ªä¸ªåº”è¯¥è·å¾— `nextID` çš„æ–°å€¼ï¼Ÿç”±äºæœ¬åœ°ç›®å½•æ˜¯æ´»åŠ¨çš„ï¼ŒPython
    åœ¨é‚£é‡Œè®¾ç½® `nextID` çš„å€¼ã€‚
- en: Directory
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE115]'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE115]'
- en: â†’Â `435`
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â `435`
- en: '[PRE116]'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE116]'
- en: â†’Â 1015
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1015
- en: '[PRE117]'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE117]'
- en: â†’Â `8001`
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â `8001`
- en: Heap
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1015:'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1015:'
- en: '[PRE118]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Letâ€™s repeat that: Python computed `nextID + 1` using the `nextID` value from
    the top-level directory since there was no value for `nextID` in the local directory.
    But the setting of the value of `nextID` could and did occur in the local directory.
    Thus, when `create_acct` finishes, the value of `nextID` in the top-level directory
    is unchanged. As a result, all of the accounts get the same value.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬é‡å¤ä¸€ä¸‹ï¼šPython ä½¿ç”¨é¡¶çº§ç›®å½•ä¸­çš„ `nextID` å€¼æ¥è®¡ç®— `nextID + 1`ï¼Œå› ä¸ºåœ¨æœ¬åœ°ç›®å½•ä¸­æ²¡æœ‰ `nextID` çš„å€¼ã€‚ä½†æ˜¯ï¼Œ`nextID`
    å€¼çš„è®¾ç½®å¯ä»¥åœ¨æœ¬åœ°ç›®å½•ä¸­å‘ç”Ÿã€‚å› æ­¤ï¼Œå½“ `create_acct` å®Œæˆæ—¶ï¼Œé¡¶çº§ç›®å½•ä¸­çš„ `nextID` å€¼ä¿æŒä¸å˜ã€‚ç»“æœï¼Œæ‰€æœ‰è´¦æˆ·éƒ½è·å¾—ç›¸åŒçš„å€¼ã€‚
- en: 'The computuation we are trying to doâ€”<wbr>updating the top-level variableâ€”<wbr>is
    just fine. The problem is that Python (reasonably) defaults to the local directory.
    To make this work, we need to tell Python that we want to make updates to `next_id`
    in the top-level directory. Hereâ€™s the version of `create_acct` that does that:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¯•å›¾è¿›è¡Œçš„è®¡ç®—â€”â€”æ›´æ–°é¡¶çº§å˜é‡â€”â€”æ˜¯å®Œå…¨å¯ä»¥çš„ã€‚é—®é¢˜æ˜¯ Pythonï¼ˆåˆç†åœ°ï¼‰é»˜è®¤ä½¿ç”¨æœ¬åœ°ç›®å½•ã€‚ä¸ºäº†ä½¿è¿™å¯è¡Œï¼Œæˆ‘ä»¬éœ€è¦å‘Šè¯‰ Python æˆ‘ä»¬æƒ³è¦æ›´æ–°é¡¶çº§ç›®å½•ä¸­çš„
    `next_id`ã€‚ä»¥ä¸‹æ˜¯æ‰§è¡Œæ­¤æ“ä½œçš„ `create_acct` ç‰ˆæœ¬ï¼š
- en: '[PRE119]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The `global` keyword tells Python to make updates to the given variable in the
    top-level directory, not the local directory. Once we make this modification,
    each account we create will get a unique ID number.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '`global` å…³é”®å­—å‘Šè¯‰ Python åœ¨é¡¶çº§ç›®å½•ä¸­è€Œä¸æ˜¯åœ¨æœ¬åœ°ç›®å½•ä¸­æ›´æ–°ç»™å®šçš„å˜é‡ã€‚ä¸€æ—¦æˆ‘ä»¬è¿›è¡Œè¿™ç§ä¿®æ”¹ï¼Œæˆ‘ä»¬åˆ›å»ºçš„æ¯ä¸ªè´¦æˆ·éƒ½å°†è·å¾—ä¸€ä¸ªå”¯ä¸€çš„
    ID å·ç ã€‚'
- en: 'Responsible Computing: Keeping IDs Unpredictable'
  id: totrans-478
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è´Ÿè´£ä»»è®¡ç®—ï¼šä¿æŒ ID ä¸å¯é¢„æµ‹
- en: ''
  id: totrans-479
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'While this general pattern of generating unique IDs works, in practice we shouldnâ€™t
    use consecutive numbers. Consecutive numbers are guessable: if there is an account
    `8000` there must be an account `8001`, and so on. Guessable account numbers could
    make it easier for someone who keeps trying to guess valid IDs to use to log into
    websites or otherwise access information.'
  id: totrans-480
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è™½ç„¶è¿™ç§ç”Ÿæˆå”¯ä¸€ ID çš„ä¸€èˆ¬æ¨¡å¼æ˜¯å¯è¡Œçš„ï¼Œä½†åœ¨å®è·µä¸­æˆ‘ä»¬ä¸åº”è¯¥ä½¿ç”¨è¿ç»­çš„æ•°å­—ã€‚è¿ç»­çš„æ•°å­—æ˜¯å¯é¢„æµ‹çš„ï¼šå¦‚æœæœ‰ä¸€ä¸ªè´¦æˆ· `8000`ï¼Œé‚£ä¹ˆè‚¯å®šæœ‰ä¸€ä¸ªè´¦æˆ·
    `8001`ï¼Œä¾æ­¤ç±»æ¨ã€‚å¯é¢„æµ‹çš„è´¦æˆ·å·ç å¯èƒ½ä¼šä½¿é‚£äº›ä¸æ–­å°è¯•çŒœæµ‹æœ‰æ•ˆ ID çš„äººæ›´å®¹æ˜“ç™»å½•ç½‘ç«™æˆ–å…¶ä»–æ–¹å¼è®¿é—®ä¿¡æ¯ã€‚
- en: ''
  id: totrans-481
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Instead, we would use a computation that is less predictable than â€œadd 1â€ when
    storing the `nextID` value. For now, the pattern we have shown you is fine. If
    you were building a real system, however, youâ€™d want to make that computation
    a bit more sophisticated.
  id: totrans-482
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç›¸åï¼Œæˆ‘ä»¬ä¼šä½¿ç”¨ä¸€ä¸ªæ¯”â€œåŠ  1â€æ›´ä¸å¯é¢„æµ‹çš„è®¡ç®—æ¥å­˜å‚¨ `nextID` å€¼ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬å‘ä½ å±•ç¤ºçš„æ¨¡å¼æ˜¯å¥½çš„ã€‚ç„¶è€Œï¼Œå¦‚æœä½ æ­£åœ¨æ„å»ºä¸€ä¸ªçœŸå®çš„ç³»ç»Ÿï¼Œä½ å¯èƒ½ä¼šæƒ³ä½¿è¿™ä¸ªè®¡ç®—æ›´å¤æ‚ä¸€äº›ã€‚
- en: 13.1.6Â The Many Roles of Variables[ğŸ”—](#(part._.The_.Many_.Roles_of_.Variables)
    "Link to here")
  id: totrans-483
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.6 å˜é‡çš„å¤šç§è§’è‰²[ğŸ”—](#(part._.The_.Many_.Roles_of_.Variables) "é“¾æ¥è‡³æ­¤")
- en: 'At this point, we have used the single coding construct of a variable in the
    directory for multiple purposes. Itâ€™s worth stepping back and calling those out
    explicitly. In general, variables serve one of the following purposes:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»ä½¿ç”¨äº†ç›®å½•ä¸­å˜é‡çš„å•ä¸€ç¼–ç ç»“æ„æ¥å®Œæˆå¤šä¸ªç›®çš„ã€‚å€¼å¾—é€€ä¸€æ­¥å¹¶æ˜ç¡®æŒ‡å‡ºè¿™äº›ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œå˜é‡æœåŠ¡äºä»¥ä¸‹ç›®çš„ä¹‹ä¸€ï¼š
- en: Tracking progress of a computation (e.g., the running value of a result in a
    `for`-loop)
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è·Ÿè¸ªè®¡ç®—çš„è¿›åº¦ï¼ˆä¾‹å¦‚ï¼Œ`for` å¾ªç¯ä¸­ç»“æœçš„è¿è¡Œå€¼ï¼‰
- en: Maintaining information across multiple calls to a single function (e.g., the
    `next-id` variable)
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åœ¨å¯¹å•ä¸ªå‡½æ•°å¤šæ¬¡è°ƒç”¨ä¸­ç»´æŠ¤ä¿¡æ¯ï¼ˆä¾‹å¦‚ï¼Œ`next-id` å˜é‡ï¼‰
- en: Naming a local or intermediate value in a computation
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åœ¨è®¡ç®—ä¸­å¯¹å±€éƒ¨æˆ–ä¸­é—´å€¼å‘½å
- en: Each of these uses involves a different programming pattern. The first creates
    a variable locally within a function. The second two create top-level variables
    and require using `global` in functions that modify the contents. The third is
    different from the second, however, in that the third is only meant to be used
    by a single function. Ideally, there would be a way to not expose the variable
    to all functions in the third case. Indeed, many programming languages (including
    Pyret) make it easy to do that. This is harder to achieve with introductory-level
    concepts in Python, however. The fourth is more about local names rather than
    variables, in that our code never updates the value after the variable is created.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›ç”¨é€”ä¸­çš„æ¯ä¸€ä¸ªéƒ½æ¶‰åŠä¸åŒçš„ç¼–ç¨‹æ¨¡å¼ã€‚ç¬¬ä¸€ä¸ªæ˜¯åœ¨å‡½æ•°å†…éƒ¨å±€éƒ¨åˆ›å»ºä¸€ä¸ªå˜é‡ã€‚åä¸¤ä¸ªåˆ›å»ºé¡¶å±‚å˜é‡ï¼Œå¹¶éœ€è¦åœ¨ä¿®æ”¹å†…å®¹çš„å‡½æ•°ä¸­ä½¿ç”¨ `global`ã€‚ç„¶è€Œï¼Œç¬¬ä¸‰ä¸ªä¸ç¬¬äºŒä¸ªä¸åŒï¼Œå› ä¸ºç¬¬ä¸‰ä¸ªä»…æ„å‘³ç€ç”±å•ä¸ªå‡½æ•°ä½¿ç”¨ã€‚ç†æƒ³æƒ…å†µä¸‹ï¼Œä¼šæœ‰ä¸€ç§æ–¹æ³•ä¸å°†å˜é‡æš´éœ²ç»™ç¬¬ä¸‰ä¸ªæƒ…å†µä¸­çš„æ‰€æœ‰å‡½æ•°ã€‚ç¡®å®ï¼Œè®¸å¤šç¼–ç¨‹è¯­è¨€ï¼ˆåŒ…æ‹¬
    Pyretï¼‰éƒ½ä½¿è¿™æ ·åšå˜å¾—å®¹æ˜“ã€‚ç„¶è€Œï¼Œåœ¨ Python çš„å…¥é—¨çº§æ¦‚å¿µä¸­å®ç°è¿™ä¸€ç‚¹æ›´éš¾ã€‚ç¬¬å››ä¸ªæ›´å¤šåœ°å…³äºå±€éƒ¨åç§°è€Œä¸æ˜¯å˜é‡ï¼Œå› ä¸ºæˆ‘ä»¬çš„ä»£ç åœ¨å˜é‡åˆ›å»ºåæ°¸è¿œä¸ä¼šæ›´æ–°å…¶å€¼ã€‚
- en: We call out these three roles precisely because they invoke different code patterns,
    despite using the same fine-grained concept (assigning a new value to a variable).
    When you look at a new programming problem, you can ask yourself whether the problem
    involves one of these purposes, and use that to guide your choice of pattern to
    use.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ˜ç¡®æŒ‡å‡ºè¿™ä¸‰ä¸ªè§’è‰²ï¼Œæ­£æ˜¯å› ä¸ºå®ƒä»¬è°ƒç”¨äº†ä¸åŒçš„ä»£ç æ¨¡å¼ï¼Œå°½ç®¡ä½¿ç”¨äº†ç›¸åŒç²¾ç»†çš„æ¦‚å¿µï¼ˆå°†æ–°å€¼èµ‹ç»™å˜é‡ï¼‰ã€‚å½“ä½ é¢å¯¹ä¸€ä¸ªæ–°çš„ç¼–ç¨‹é—®é¢˜æ—¶ï¼Œä½ å¯ä»¥é—®è‡ªå·±è¿™ä¸ªé—®é¢˜æ˜¯å¦æ¶‰åŠè¿™äº›ç›®çš„ä¹‹ä¸€ï¼Œå¹¶ä½¿ç”¨å®ƒæ¥æŒ‡å¯¼ä½ é€‰æ‹©ä½¿ç”¨å“ªç§æ¨¡å¼ã€‚
