- en: The Cost of Branching
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支的成本
- en: 原文：[https://en.algorithmica.org/hpc/pipelining/branching/](https://en.algorithmica.org/hpc/pipelining/branching/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/pipelining/branching/](https://en.algorithmica.org/hpc/pipelining/branching/)
- en: When a CPU encounters a conditional jump or [any other type of branching](/hpc/architecture/indirect),
    it doesn’t just sit idle until its condition is computed — instead, it starts
    *speculatively executing* the branch that seems more likely to be taken immediately.
    During execution, the CPU computes statistics about branches taken on each instruction,
    and after some time, they start to predict them by recognizing common patterns.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当 CPU 遇到条件跳转或[任何其他类型的分支](/hpc/architecture/indirect)时，它不会只是闲置直到其条件被计算出来——相反，它会开始*推测执行*看起来更有可能立即执行的分支。在执行过程中，CPU
    会计算每个指令上所采取的分支的统计数据，经过一段时间后，它们开始通过识别常见模式来预测它们。
- en: For this reason, the true “cost” of a branch largely depends on how well it
    can be predicted by the CPU. If it is a pure 50/50 coin toss, you have to suffer
    a [control hazard](../hazards) and discard the entire pipeline, taking another
    15-20 cycles to build up again. And if the branch is always or never taken, you
    pay almost nothing except checking the condition.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，分支的真正“成本”在很大程度上取决于 CPU 能否很好地预测它。如果它是一个纯粹的 50/50 的硬币抛掷，你必须忍受[控制冒险](../hazards)并丢弃整个流水线，然后再花费
    15-20 个循环重新建立。如果分支总是或从不被采取，你几乎不需要支付任何费用，只需检查条件即可。
- en: '## [#](https://en.algorithmica.org/hpc/pipelining/branching/#an-experiment)An
    Experiment'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '## [#](https://en.algorithmica.org/hpc/pipelining/branching/#an-experiment)一个实验'
- en: 'As a case study, we are going to create an array of random integers between
    0 and 99 inclusive:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 作为案例研究，我们将创建一个介于 0 和 99（包括）之间的随机整数数组：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then we create a loop where we sum up all its elements under 50:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建一个循环，将所有小于 50 的元素加起来：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We set $N = 10^6$ and run this loop many times over so that the [cold cache](/hpc/cpu-cache/bandwidth)
    effect doesn’t mess up our results. We mark our accumulator variable as `volatile`
    so that the compiler doesn’t vectorize the loop, interleave its iterations, or
    “cheat” in any other way.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 $N = 10^6$ 并多次运行这个循环，这样[冷缓存](/hpc/cpu-cache/bandwidth)效应就不会影响我们的结果。我们将累加变量标记为
    `volatile`，这样编译器就不会向量化循环，交错其迭代，或者以任何其他方式“作弊”。
- en: 'On Clang, this produces assembly that looks like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clang 上，这会产生如下汇编代码：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our goal is to simulate a completely unpredictable branch, and we successfully
    achieve it: the code takes ~14 CPU cycles per element. For a very rough estimate
    of what it is supposed to be, we can assume that the branches alternate between
    `<` and `>=`, and the pipeline is mispredicted every other iteration. Then, every
    two iterations:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是模拟一个完全不可预测的分支，并且我们成功地实现了它：代码对每个元素需要 ~14 个 CPU 循环。为了对它应该是什么样子做一个非常粗略的估计，我们可以假设分支在
    `<` 和 `>=` 之间交替，并且每两次迭代中就有一次流水线预测错误。那么，每两次迭代：
- en: We discard the pipeline, which is 19 cycles deep on Zen 2 (i.e., it has 19 stages,
    each taking one cycle).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们丢弃了流水线，在 Zen 2 上它有 19 个深度（即它有 19 个阶段，每个阶段需要一秒钟）。
- en: We need a memory fetch and a comparison, which costs ~5 cycles. We can check
    the conditions of even and odd iterations concurrently, so let’s assume we only
    pay it once per 2 iterations.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个内存读取和一个比较，这需要 ~5 个循环。我们可以同时检查偶数和奇数迭代的条件，所以让我们假设我们每 2 次迭代只支付一次。
- en: In the case of the `<` branch, we need another ~4 cycles to add `a[i]` to a
    volatile (memory-stored) variable `s`.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `<` 分支的情况下，我们还需要额外的 ~4 个循环来将 `a[i]` 添加到一个易失的（内存存储的）变量 `s` 中。
- en: Therefore, on average, we need to spend $(4 + 5 + 19) / 2 = 14$ cycles per element,
    matching what we measured.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，平均来说，我们需要为每个元素花费 $(4 + 5 + 19) / 2 = 14$ 个循环，这与我们所测量的结果相匹配。
- en: '### [#](https://en.algorithmica.org/hpc/pipelining/branching/#branch-prediction)Branch
    Prediction'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/pipelining/branching/#branch-prediction)分支预测'
- en: 'We can replace the hardcoded `50` with a tweakable parameter `P` that effectively
    sets the probability of the `<` branch:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一个可调整的参数 `P` 来替换硬编码的 `50`，这个参数实际上设置了 `<` 分支的概率：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, if we benchmark it for different values of `P`, we get an interesting-looking
    graph:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们为不同的 `P` 值进行基准测试，我们会得到一个看起来很有趣的图表：
- en: '![](../Images/fcf131b2df49e5a5fa7490ba395ae86a.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/fcf131b2df49e5a5fa7490ba395ae86a.png)'
- en: 'Its peak is at 50-55%, as expected: branch misprediction is the most expensive
    thing here. This graph is asymmetrical: it takes just ~1 cycle to only check conditions
    that are never satisfied (`P = 0`), and ~7 cycles for the sum if the branch is
    always taken (`P = 100`).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，其峰值在50-55%，分支预测错误是最昂贵的事情。此图是不对称的：仅检查条件从未满足的情况（`P = 0`）需要大约1个周期，而如果分支始终被采用（`P
    = 100`），求和需要大约7个周期。
- en: 'This graph is not unimodal: there is another local minimum at around 85-90%.
    We spend ~6.15 cycles per element there or about 10-15% faster than when we always
    take the branch, accounting for the fact that we need to perform fewer additions.
    Branch misprediction stops affecting the performance at this point because when
    it happens, not the whole instruction buffer is discarded, but only the operations
    that were speculatively scheduled. Essentially, that 10-15% mispredict rate is
    the equilibrium point where we can see far enough in the pipeline not to stall
    but still save 10-15% on taking the cheaper `>=` branch.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此图不是单峰的：在约85-90%处还有一个局部最小值。在那里，我们每个元素花费约6.15个周期，或者比始终选择分支快10-15%，考虑到我们需要执行更少的加法。分支预测错误在此点停止影响性能，因为当它发生时，并不是整个指令缓冲区被丢弃，而只是那些被投机性调度的操作。本质上，那个10-15%的预测错误率是我们可以在流水线中看得足够远以避免停顿，同时仍然在采用更便宜的
    `>=` 分支上节省10-15%的平衡点。
- en: 'Note that it costs almost nothing to check for a condition that never or almost
    never occurs. This is why programmers use runtime exceptions and base case checks
    so profusely: if they are indeed rare, they don’t really cost anything.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，检查一个几乎从未或几乎从未发生的情况几乎不花费任何代价。这就是为什么程序员如此频繁地使用运行时异常和基线检查：如果它们确实很少发生，它们实际上并不花费任何代价。
- en: '### [#](https://en.algorithmica.org/hpc/pipelining/branching/#pattern-detection)Pattern
    Detection'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/pipelining/branching/#pattern-detection)模式检测'
- en: In our example, everything that was needed for efficient branch prediction is
    a hardware statistics counter. If we historically took branch A more often than
    branch B, then it makes sense to speculatively execute branch A. But branch predictors
    on modern CPUs are considerably more advanced than that and can detect much more
    complicated patterns.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，对于有效的分支预测所需的一切只是一个硬件统计计数器。如果我们历史上比分支B更频繁地采用分支A，那么投机执行分支A是有意义的。但现代CPU上的分支预测器比这要先进得多，可以检测到更复杂的模式。
- en: 'Let’s fix `P` back at 50, and then sort the array first before the main summation
    loop:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 `P` 重新设置为50，然后在主求和循环之前先对数组进行排序：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are still processing the same elements, but in a different order, and instead
    of 14 cycles, it now runs in a little bit more than 4, which is exactly the average
    of the cost of the pure `<` and `>=` branches.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍在处理相同的元素，但顺序不同，而且不再是14个周期，现在运行时间略多于4个周期，这正好是纯 `<` 和 `>=` 分支成本的平均值。
- en: The branch predictor can pick up on much more complicated patterns than just
    “always left, then always right” or “left-right-left-right.” If we just decrease
    the size of the array $N$ to 1000 (without sorting it), then the branch predictor
    memorizes the entire sequence of comparisons, and the benchmark again measures
    at around 4 cycles — in fact, even slightly fewer than in the sorted array case,
    because in the former case branch predictor needs to spend some time flicking
    between the “always yes” and “always no” states.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 分支预测器可以识别比“始终左，然后始终右”或“左右左右”更复杂的模式。如果我们仅仅将数组 $N$ 的大小减小到1000（不进行排序），那么分支预测器会记住整个比较序列，基准测试再次在约4个周期内完成——实际上，甚至比排序数组的情况略少，因为在前者中，分支预测器需要花费一些时间在“始终是”和“始终不是”状态之间切换。
- en: '### [#](https://en.algorithmica.org/hpc/pipelining/branching/#hinting-likeliness-of-branches)Hinting
    Likeliness of Branches'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/pipelining/branching/#hinting-likeliness-of-branches)提示分支的可能性'
- en: 'If you know beforehand which branch is more likely, it may be beneficial to
    [pass that information](/hpc/compilation/situational) to the compiler:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道哪个分支更有可能，将这个信息[传递给编译器](/hpc/compilation/situational)可能是有益的：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When `P = 75`, it measures around ~7.3 cycles per element, while the original
    version without the hint needs ~8.3.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `P = 75` 时，它每个元素测量约7.3个周期，而原始版本（没有提示）需要约8.3个周期。
- en: This hint does not eliminate the branch or communicate anything to the branch
    predictor, but it changes the [machine code layout](/hpc/architecture/layout)
    in a way that lets the CPU front-end process the more likely branch slightly faster
    (although usually by no more than one cycle).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个提示并没有消除分支或向分支预测器传达任何信息，但它以改变[机器代码布局](/hpc/architecture/layout)的方式，让CPU前端能够稍微更快地处理更有可能的分支（尽管通常不会超过一个周期）。
- en: This optimization is only beneficial when you know which branch is more likely
    to be taken before the compilation stage. When the branch is fundamentally unpredictable,
    we can try to remove it completely using *predication* — a profoundly important
    technique that we are going to explore in [the next section](../branchless).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种优化只有在编译阶段之前你知道哪个分支更有可能被采取时才有益。当分支本质上不可预测时，我们可以尝试使用*预测*——这是一个我们将要在[下一节](../branchless)中探讨的极其重要的技术——来完全移除它。
- en: '### [#](https://en.algorithmica.org/hpc/pipelining/branching/#acknowledgements)Acknowledgements'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '### [致谢](https://en.algorithmica.org/hpc/pipelining/branching/#acknowledgements)'
- en: This case study is inspired by [the most upvoted Stack Overflow question ever](https://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-processing-an-unsorted-array).
    [← Pipeline Hazards](https://en.algorithmica.org/hpc/pipelining/hazards/)[Branchless
    Programming →](https://en.algorithmica.org/hpc/pipelining/branchless/)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本案例研究灵感来源于[史上最高票数的Stack Overflow问题](https://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-processing-an-unsorted-array)。[←流水线危害](https://en.algorithmica.org/hpc/pipelining/hazards/)[无分支编程→](https://en.algorithmica.org/hpc/pipelining/branchless/)
