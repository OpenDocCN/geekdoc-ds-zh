- en: 9.1Â From Pyret to PythonğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.1 ä» Pyret åˆ° PythonğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/intro-python.html](https://dcic-world.org/2025-08-27/intro-python.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/intro-python.html](https://dcic-world.org/2025-08-27/intro-python.html)
- en: '| Â Â Â Â [9.1.1Â Expressions, Functions, and Types](#%28part._.Expressions__.Functions__and_.Types%29)
    |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   [9.1.1 è¡¨è¾¾å¼ã€å‡½æ•°å’Œç±»å‹](#%28part._.Expressions__.Functions__and_.Types%29) |'
- en: '| Â Â Â Â [9.1.2Â Returning Values from Functions](#%28part._.Returning_.Values_from_.Functions%29)
    |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|   [9.1.2 ä»å‡½æ•°è¿”å›å€¼](#%28part._.Returning_.Values_from_.Functions%29) |'
- en: '| Â Â Â Â [9.1.3Â Examples and Test Cases](#%28part._testing-python%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|   [9.1.3 ç¤ºä¾‹å’Œæµ‹è¯•ç”¨ä¾‹](#%28part._testing-python%29) |'
- en: '| Â Â Â Â [9.1.4Â An Aside on Numbers](#%28part._.An_.Aside_on_.Numbers%29) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|   [9.1.4 å…³äºæ•°å­—çš„æ—ç™½](#%28part._.An_.Aside_on_.Numbers%29) |'
- en: '| Â Â Â Â [9.1.5Â Conditionals](#%28part._conditionals-python%29) |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|   [9.1.5 æ¡ä»¶è¯­å¥](#%28part._conditionals-python%29) |'
- en: '| Â Â Â Â [9.1.6Â Creating and Processing Lists](#%28part._python-create-process-lists%29)
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|   [9.1.6 åˆ›å»ºå’Œå¤„ç†åˆ—è¡¨](#%28part._python-create-process-lists%29) |'
- en: '| Â Â Â Â Â Â [9.1.6.1Â Filters, Maps, and Friends](#%28part._.Filters__.Maps__and_.Friends%29)
    |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|   [9.1.6.1 è¿‡æ»¤å™¨ã€æ˜ å°„å’Œæœ‹å‹ä»¬](#%28part._.Filters__.Maps__and_.Friends%29) |'
- en: '| Â Â Â Â [9.1.7Â Data with Components](#%28part._python-data-with-components%29)
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|   [9.1.7 å¸¦æœ‰ç»„ä»¶çš„æ•°æ®](#%28part._python-data-with-components%29) |'
- en: '| Â Â Â Â Â Â [9.1.7.1Â Accessing Fields within Dataclasses](#%28part._.Accessing_.Fields_within_.Dataclasses%29)
    |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|   [9.1.7.1 è®¿é—®æ•°æ®ç±»ä¸­çš„å­—æ®µ](#%28part._.Accessing_.Fields_within_.Dataclasses%29)
    |'
- en: '| Â Â Â Â [9.1.8Â Traversing Lists](#%28part._python-traverse-lists%29) |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|   [9.1.8 éå†åˆ—è¡¨](#%28part._python-traverse-lists%29) |'
- en: '| Â Â Â Â Â Â [9.1.8.1Â Introducing `For` Loops](#%28part._python-for-loops%29) |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|   [9.1.8.1 ä»‹ç» `For` å¾ªç¯](#%28part._python-for-loops%29) |'
- en: '| Â Â Â Â Â Â [9.1.8.2Â An Aside on Order of Processing List Elements](#%28part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements%29)
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|   [9.1.8.2 å…³äºå¤„ç†åˆ—è¡¨å…ƒç´ é¡ºåºçš„æ—ç™½](#%28part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements%29)'
- en: '| Â Â Â Â Â Â [9.1.8.3Â Using `For` Loops in Functions that Produce Lists](#%28part._python-funcs-produce-lists%29)
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|   [9.1.8.3 åœ¨ç”Ÿæˆåˆ—è¡¨çš„å‡½æ•°ä¸­ä½¿ç”¨ `For` å¾ªç¯](#%28part._python-funcs-produce-lists%29)
    |'
- en: '| Â Â Â Â Â Â [9.1.8.4Â Summary: The List-Processing Template for Python](#%28part._.Summary__.The_.List-.Processing_.Template_for_.Python%29)
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|   [9.1.8.4 æ€»ç»“ï¼šPython çš„åˆ—è¡¨å¤„ç†æ¨¡æ¿](#%28part._.Summary__.The_.List-.Processing_.Template_for_.Python%29)
    |'
- en: '| Â Â Â Â Â Â [9.1.8.5Â `for each` loops in Pyret](#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret%29)
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|   [9.1.8.5 Pyret ä¸­çš„ `for each` å¾ªç¯](#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret%29)
    |'
- en: '| Â Â Â Â Â Â Â Â [9.1.8.5.1Â Variables that can change](#%28part._.Variables_that_can_change%29)
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|   [9.1.8.5.1 å¯å˜çš„å˜é‡](#%28part._.Variables_that_can_change%29) |'
- en: '| Â Â Â Â Â Â Â Â [9.1.8.5.2Â block notation](#%28part._block_notation%29) |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|   [9.1.8.5.2 å—æ³¨é‡Š](#%28part._block_notation%29) |'
- en: '| Â Â Â Â Â Â Â Â [9.1.8.5.3Â How `for each` works](#%28part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works%29)
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|   [9.1.8.5.3 `for each` å¦‚ä½•å·¥ä½œ](#%28part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works%29)
    |'
- en: '| Â Â Â Â Â Â Â Â [9.1.8.5.4Â Testing and variables that can change](#%28part._.Testing_and_variables_that_can_change%29)
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|   [9.1.8.5.4 æµ‹è¯•å’Œå¯å˜çš„å˜é‡](#%28part._.Testing_and_variables_that_can_change%29)
    |'
- en: 'Through our work in Pyret to this point, weâ€™ve covered several core programming
    skills: how to work with tables, how to design good examples, the basics of creating
    datatypes, and how to work with the fundamental computational building blocks
    of functions, conditionals, and repetition (through `filter` and `map`, as well
    as recursion). Youâ€™ve got a solid initial toolkit, as well as a wide world of
    other possible programs ahead of you!'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡åˆ°ç›®å‰ä¸ºæ­¢åœ¨ Pyret çš„å·¥ä½œï¼Œæˆ‘ä»¬å·²ç»æ¶µç›–äº†å‡ ä¸ªæ ¸å¿ƒç¼–ç¨‹æŠ€èƒ½ï¼šå¦‚ä½•å¤„ç†è¡¨æ ¼ï¼Œå¦‚ä½•è®¾è®¡å¥½çš„ç¤ºä¾‹ï¼Œåˆ›å»ºæ•°æ®ç±»å‹çš„åŸºç¡€ï¼Œä»¥åŠå¦‚ä½•ä½¿ç”¨å‡½æ•°ã€æ¡ä»¶è¯­å¥å’Œé‡å¤ï¼ˆé€šè¿‡
    `filter` å’Œ `map` ä»¥åŠé€’å½’ï¼‰ç­‰åŸºæœ¬è®¡ç®—æ„å»ºå—ã€‚ä½ å·²ç»æ‹¥æœ‰äº†ä¸€ä¸ªåšå®çš„åˆå§‹å·¥å…·åŒ…ï¼Œä»¥åŠä¸€ä¸ªå¹¿é˜”çš„ä¸–ç•Œï¼Œå…¶ä¸­å……æ»¡äº†å…¶ä»–å¯èƒ½çš„ç¨‹åºï¼
- en: But weâ€™re going to shift gears for a little while and show you how to work in
    Python instead. Why?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æˆ‘ä»¬å°†æš‚æ—¶æ”¹å˜æ–¹å‘ï¼Œå‘ä½ å±•ç¤ºå¦‚ä½•åœ¨ Python ä¸­å·¥ä½œã€‚ä¸ºä»€ä¹ˆï¼Ÿ
- en: 'Seeing how the same concepts play out in multiple languages can help you distinguish
    core computational ideas from the notations and idioms of specific languages.
    If you plan to write programs as part of your professional work, youâ€™ll inevitably
    have to work in different languages at different times: weâ€™re giving you a chance
    to practice that skill in a controlled and gentle setting.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: è§‚å¯Ÿç›¸åŒçš„æ¦‚å¿µå¦‚ä½•åœ¨å¤šç§è¯­è¨€ä¸­ä½“ç°ï¼Œå¯ä»¥å¸®åŠ©ä½ åŒºåˆ†æ ¸å¿ƒè®¡ç®—æ€æƒ³ä¸ç‰¹å®šè¯­è¨€çš„ç¬¦å·å’Œä¹ æƒ¯ç”¨æ³•ã€‚å¦‚æœä½ è®¡åˆ’å°†ç¼–ç¨‹ä½œä¸ºä½ çš„èŒä¸šå·¥ä½œçš„ä¸€éƒ¨åˆ†ï¼Œä½ ä¸å¯é¿å…åœ°ä¼šåœ¨ä¸åŒçš„æ—¶é—´ä½¿ç”¨ä¸åŒçš„è¯­è¨€ï¼šæˆ‘ä»¬ç»™ä½ ä¸€ä¸ªæœºä¼šï¼Œåœ¨ä¸€ä¸ªå—æ§å’Œæ¸©å’Œçš„ç¯å¢ƒä¸­ç»ƒä¹ è¿™é¡¹æŠ€èƒ½ã€‚
- en: Why do we call this gentle? Because the notations in Pyret were designed partly
    with this transition in mind. Youâ€™ll find many similarities between Pyret and
    Python at a notational level, yet also some interesting differences that highlight
    some philosophical differences that underlie languages. The next set of programs
    that we want to write (specifically, data-rich programs where the data must be
    updated and maintained over time) fit nicely with certain features of Python that
    you havenâ€™t seen in Pyret. A future release will contain material that contrasts
    the strengths and weaknesses of the two languages.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆæˆ‘ä»¬ç§°ä¹‹ä¸ºæ¸©å’Œçš„ï¼Ÿå› ä¸º Pyret ä¸­çš„ç¬¦å·éƒ¨åˆ†æ˜¯ä¸ºäº†è¿™ç§è¿‡æ¸¡è€Œè®¾è®¡çš„ã€‚ä½ ä¼šåœ¨ç¬¦å·å±‚é¢ä¸Šå‘ç° Pyret å’Œ Python ä¹‹é—´çš„è®¸å¤šç›¸ä¼¼ä¹‹å¤„ï¼ŒåŒæ—¶ä¹Ÿæœ‰ä¸€äº›æœ‰è¶£çš„ä¸åŒä¹‹å¤„ï¼Œè¿™äº›ä¸åŒä¹‹å¤„çªå‡ºäº†è¯­è¨€èƒŒåçš„å“²å­¦å·®å¼‚ã€‚æˆ‘ä»¬æ¥ä¸‹æ¥æƒ³è¦ç¼–å†™çš„ä¸‹ä¸€ç»„ç¨‹åºï¼ˆç‰¹åˆ«æ˜¯ï¼Œæ•°æ®ä¸°å¯Œçš„ç¨‹åºï¼Œå…¶ä¸­æ•°æ®å¿…é¡»éšç€æ—¶é—´çš„æ¨ç§»è¿›è¡Œæ›´æ–°å’Œç»´æŠ¤ï¼‰ä¸
    Python çš„æŸäº›ç‰¹æ€§éå¸¸å¥‘åˆï¼Œè¿™äº›ç‰¹æ€§ä½ åœ¨ Pyret ä¸­è¿˜æ²¡æœ‰çœ‹åˆ°ã€‚æœªæ¥çš„ç‰ˆæœ¬å°†åŒ…å«å¯¹æ¯”ä¸¤ç§è¯­è¨€ä¼˜ç¼ºç‚¹çš„å†…å®¹ã€‚
- en: We highlight the basic notational differences between Pyret and Python by redoing
    some of our earlier code examples in Python.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é€šè¿‡å°†ä¸€äº›æ—©æœŸçš„ä»£ç ç¤ºä¾‹é‡åšåœ¨ Python ä¸­ï¼Œæ¥å¼ºè°ƒ Pyret å’Œ Python ä¹‹é—´çš„åŸºæœ¬ç¬¦å·å·®å¼‚ã€‚
- en: 9.1.1Â Expressions, Functions, and Types[ğŸ”—](#(part._.Expressions__.Functions__and_.Types)
    "Link to here")
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1 è¡¨è¾¾å¼ã€å‡½æ•°å’Œç±»å‹[ğŸ”—](#(part._.Expressions__.Functions__and_.Types) "é“¾æ¥è‡³æ­¤")
- en: 'Back in [Functions Practice: Cost of pens](From_Repeated_Expressions_to_Functions.html#%28part._pen-cost-pyret%29),
    we introduced the notation for functions and types using an example of computing
    the cost of an order of pens. An order consisted of a number of pens and a message
    to be printed on the pens. Each pen cost 25 cents, plus 2 cents per character
    for the message. Here was the original Pyret code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨[å‡½æ•°ç»ƒä¹ ï¼šç¬”çš„æˆæœ¬](From_Repeated_Expressions_to_Functions.html#%28part._pen-cost-pyret%29)ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡è®¡ç®—ä¸€ç›’ç¬”çš„æˆæœ¬çš„ä¾‹å­ä»‹ç»äº†å‡½æ•°å’Œç±»å‹çš„ç¬¦å·ã€‚ä¸€ç›’ç¬”åŒ…æ‹¬ç¬”çš„æ•°é‡å’Œè¦æ‰“å°åœ¨ç¬”ä¸Šçš„ä¿¡æ¯ã€‚æ¯æ”¯ç¬”çš„æˆæœ¬æ˜¯25ç¾åˆ†ï¼ŒåŠ ä¸Šæ¯å­—ç¬¦2ç¾åˆ†çš„æ¶ˆæ¯è´¹ç”¨ã€‚ä»¥ä¸‹æ˜¯åŸå§‹çš„
    Pyret ä»£ç ï¼š
- en: '[PRE0]total cost for pens, each 25 cents'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE0]æ¯æ”¯ç¬”çš„æ€»æˆæœ¬ï¼Œæ¯æ”¯25ç¾åˆ†'
- en: plus 2 cents per message character[PRE1]
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: åŠ ä¸Šæ¯æ¡æ¶ˆæ¯å­—ç¬¦2ç¾åˆ†[PRE1]
- en: 'Hereâ€™s the corresponding Python code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯ç›¸åº”çš„ Python ä»£ç ï¼š
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Do Now!
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What notational differences do you see between the two versions?
  id: totrans-34
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ åœ¨ä¸¤ä¸ªç‰ˆæœ¬ä¹‹é—´çœ‹åˆ°äº†å“ªäº›ç¬¦å·å·®å¼‚ï¼Ÿ
- en: 'Hereâ€™s a summary of the differences:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯å·®å¼‚çš„æ€»ç»“ï¼š
- en: Python uses `def` instead of `fun`.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python ä½¿ç”¨ `def` è€Œä¸æ˜¯ `fun`ã€‚
- en: Python uses underscores in names (like `pen_cost`) instead of hyphens as in
    Pyret.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python åœ¨åç§°ä¸­ä½¿ç”¨ä¸‹åˆ’çº¿ï¼ˆå¦‚ `pen_cost`ï¼‰ï¼Œè€Œä¸æ˜¯ Pyret ä¸­çš„è¿å­—ç¬¦ã€‚
- en: 'The type names are written differently: Python uses `str` and `int` instead
    of `String` and `Number`. In addition, Python uses only a single colon before
    the type whereas Pyret uses a double colon.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç±»å‹åç§°çš„å†™æ³•ä¸åŒï¼šPython ä½¿ç”¨ `str` å’Œ `int` è€Œä¸æ˜¯ `String` å’Œ `Number`ã€‚æ­¤å¤–ï¼ŒPython åœ¨ç±»å‹ä¹‹å‰åªä½¿ç”¨ä¸€ä¸ªå†’å·ï¼Œè€Œ
    Pyret ä½¿ç”¨ä¸¤ä¸ªå†’å·ã€‚
- en: 'Python has different types for different kinds of numbers: `int` is for integers,
    while `float` is for decimals. Pyret just used a single type (`Number`) for all
    numbers.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python ä¸ºä¸åŒç±»å‹çš„æ•°å­—æœ‰ä¸åŒçš„ç±»å‹ï¼š`int` ç”¨äºæ•´æ•°ï¼Œè€Œ `float` ç”¨äºå°æ•°ã€‚Pyret åªä½¿ç”¨ä¸€ä¸ªç±»å‹ï¼ˆ`Number`ï¼‰æ¥è¡¨ç¤ºæ‰€æœ‰æ•°å­—ã€‚
- en: Python doesnâ€™t label the documentation string (as Pyret does with `doc:`).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python ä¸å¯¹æ–‡æ¡£å­—ç¬¦ä¸²è¿›è¡Œæ ‡è®°ï¼ˆå¦‚ Pyret ä¸­çš„ `doc:` æ‰€åšçš„é‚£æ ·ï¼‰ã€‚
- en: There is no `end` annotation in Python. Instead, Python uses indentation to
    locate the end of an if/else statement, function, or other multi-line construct.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python ä¸­æ²¡æœ‰ `end` æ³¨è§£ã€‚ç›¸åï¼ŒPython ä½¿ç”¨ç¼©è¿›æ¥å®šä½ if/else è¯­å¥ã€å‡½æ•°æˆ–å…¶ä»–å¤šè¡Œç»“æ„çš„ç»“æŸã€‚
- en: Python labels the outputs of functions with `return`.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python ä½¿ç”¨ `return` æ ‡è®°å‡½æ•°çš„è¾“å‡ºã€‚
- en: These are minor differences in notation, which you will get used to as you write
    more programs in Python.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æ˜¯ç¬¦å·ä¸Šçš„ç»†å¾®å·®å¼‚ï¼Œéšç€ä½ åœ¨ Python ä¸­ç¼–å†™æ›´å¤šçš„ç¨‹åºï¼Œä½ ä¼šä¹ æƒ¯è¿™äº›å·®å¼‚ã€‚
- en: There are differences beyond the notational ones. One that arises with this
    sample program arises around how the language uses types. In Pyret, if you put
    a type annotation on a parameter then pass it a value of a different type, youâ€™ll
    get an error message. Python ignores the type annotations (unless you bring in
    additional tools for checking types). Python types are like notes for programmers,
    but they arenâ€™t enforced when programs run.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: é™¤äº†ç¬¦å·å·®å¼‚ä¹‹å¤–ï¼Œè¿˜æœ‰ä¸€äº›å…¶ä»–å·®å¼‚ã€‚è¿™ä¸ªç¤ºä¾‹ç¨‹åºä¸­å‡ºç°çš„å·®å¼‚ä¸è¯­è¨€å¦‚ä½•ä½¿ç”¨ç±»å‹æœ‰å…³ã€‚åœ¨ Pyret ä¸­ï¼Œå¦‚æœä½ å¯¹ä¸€ä¸ªå‚æ•°æ·»åŠ äº†ç±»å‹æ³¨è§£ï¼Œç„¶åä¼ é€’äº†ä¸€ä¸ªä¸åŒç±»å‹çš„å€¼ï¼Œä½ ä¼šå¾—åˆ°ä¸€ä¸ªé”™è¯¯ä¿¡æ¯ã€‚Python
    å¿½ç•¥ç±»å‹æ³¨è§£ï¼ˆé™¤éä½ å¼•å…¥äº†é¢å¤–çš„å·¥å…·æ¥æ£€æŸ¥ç±»å‹ï¼‰ã€‚Python çš„ç±»å‹å°±åƒç¨‹åºå‘˜çš„ç¬”è®°ï¼Œä½†åœ¨ç¨‹åºè¿è¡Œæ—¶å¹¶ä¸å¼ºåˆ¶æ‰§è¡Œã€‚
- en: Exercise
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Convert the following `moon-weight` function from [Functions Practice: Moon
    Weight](From_Repeated_Expressions_to_Functions.html#%28part._moon-weight-pyret%29)
    into Python:'
  id: totrans-47
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°†ä»¥ä¸‹ `moon-weight` å‡½æ•°ä»[å‡½æ•°ç»ƒä¹ ï¼šæœˆçƒé‡é‡](From_Repeated_Expressions_to_Functions.html#%28part._moon-weight-pyret%29)è½¬æ¢ä¸º
    Pythonï¼š
- en: ''
  id: totrans-48
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-49
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 9.1.2Â Returning Values from Functions[ğŸ”—](#(part._.Returning_.Values_from_.Functions)
    "Link to here")
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.2Â ä»å‡½æ•°è¿”å›å€¼[ğŸ”—](#(part._.Returning_.Values_from_.Functions) "é“¾æ¥è‡³æ­¤")
- en: In Pyret, a function body consisted of optional statements to name intermediate
    values, followed by a single expression. The value of that single expression is
    the result of calling the function. In Pyret, every function produces a result,
    so there is no need to label where the result comes from.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Pyret ä¸­ï¼Œå‡½æ•°ä½“ç”±å¯é€‰çš„å‘½åä¸­é—´å€¼çš„è¯­å¥ç»„æˆï¼Œåé¢è·Ÿä¸€ä¸ªå•ç‹¬çš„è¡¨è¾¾å¼ã€‚è¯¥å•ä¸ªè¡¨è¾¾å¼çš„å€¼æ˜¯è°ƒç”¨å‡½æ•°çš„ç»“æœã€‚åœ¨ Pyret ä¸­ï¼Œæ¯ä¸ªå‡½æ•°éƒ½ä¼šäº§ç”Ÿä¸€ä¸ªç»“æœï¼Œå› æ­¤ä¸éœ€è¦æ ‡è®°ç»“æœæ¥è‡ªä½•å¤„ã€‚
- en: 'As we will see, Python is different: not all â€œfunctionsâ€ return results (note
    the name change from `fun` to `def`).In mathematics, functions have results by
    definition. Programmers sometimes distinguish between the terms â€œfunctionâ€ and
    â€œprocedureâ€: both refer to parameterized computations, but only the former returns
    a result to the surrounding computation. Some programmers and languages do, however,
    use the term â€œfunctionâ€ more loosely to cover both kinds of parameterized computations.
    Moreover, the result isnâ€™t necessarily the last expression of the `def`. In Python,
    the keyword `return` explicitly labels the expression whose value serves as the
    result of the function.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬å°†çœ‹åˆ°çš„ï¼ŒPython ä¸ä¹‹ä¸åŒï¼šå¹¶éæ‰€æœ‰â€œå‡½æ•°â€éƒ½ä¼šè¿”å›ç»“æœï¼ˆæ³¨æ„åç§°ä» `fun` æ›´æ”¹ä¸º `def`ï¼‰ã€‚åœ¨æ•°å­¦ä¸­ï¼Œå‡½æ•°çš„å®šä¹‰å°±æ˜¯æœ‰ç»“æœã€‚ç¨‹åºå‘˜æœ‰æ—¶ä¼šåœ¨â€œå‡½æ•°â€å’Œâ€œè¿‡ç¨‹â€è¿™ä¸¤ä¸ªæœ¯è¯­ä¹‹é—´è¿›è¡ŒåŒºåˆ†ï¼šä¸¤è€…éƒ½æŒ‡å‚æ•°åŒ–è®¡ç®—ï¼Œä½†åªæœ‰å‰è€…ä¼šå‘å‘¨å›´è®¡ç®—è¿”å›ç»“æœã€‚ç„¶è€Œï¼Œä¸€äº›ç¨‹åºå‘˜å’Œè¯­è¨€æ›´å®½æ¾åœ°ä½¿ç”¨â€œå‡½æ•°â€è¿™ä¸ªæœ¯è¯­æ¥æ¶µç›–è¿™ä¸¤ç§å‚æ•°åŒ–è®¡ç®—ã€‚æ­¤å¤–ï¼Œç»“æœä¸ä¸€å®šæ˜¯
    `def` çš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼ã€‚åœ¨ Python ä¸­ï¼Œå…³é”®å­— `return` æ˜ç¡®æ ‡è®°äº†å…¶å€¼ä½œä¸ºå‡½æ•°ç»“æœçš„é‚£ä¸ªè¡¨è¾¾å¼ã€‚
- en: Do Now!
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Put these two definitions in a Python file.
  id: totrans-55
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°†è¿™ä¸¤ä¸ªå®šä¹‰æ”¾å…¥ä¸€ä¸ª Python æ–‡ä»¶ä¸­ã€‚
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ''
  id: totrans-58
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: At the Python prompt, call each function in turn. What do you notice about the
    result from using each function?
  id: totrans-59
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨ Python æç¤ºç¬¦ä¸‹ï¼Œä¾æ¬¡è°ƒç”¨æ¯ä¸ªå‡½æ•°ã€‚ä½ æ³¨æ„åˆ°ä½¿ç”¨æ¯ä¸ªå‡½æ•°çš„ç»“æœæœ‰ä»€ä¹ˆä¸åŒå—ï¼Ÿ
- en: Hopefully, you noticed that using `add1v1` displays an answer after the prompt,
    while using `add1v2` does not. This difference has consequences for composing
    functions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: å¸Œæœ›ä½ èƒ½æ³¨æ„åˆ°ï¼Œä½¿ç”¨ `add1v1` åœ¨æç¤ºç¬¦åæ˜¾ç¤ºç­”æ¡ˆï¼Œè€Œä½¿ç”¨ `add1v2` åˆ™ä¸ä¼šã€‚è¿™ç§å·®å¼‚å¯¹å‡½æ•°çš„ç»„åˆæœ‰å½±å“ã€‚
- en: Do Now!
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Try evaluating the following two expressions at the Python prompt: what happens
    in each case?'
  id: totrans-63
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°è¯•åœ¨ Python æç¤ºç¬¦ä¸‹è¯„ä¼°ä»¥ä¸‹ä¸¤ä¸ªè¡¨è¾¾å¼ï¼šæ¯ç§æƒ…å†µä¸‹ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`3 * add1v1(4)`'
  id: totrans-65
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`3 * add1v1(4)`'
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`3 * add1v2(4)`'
  id: totrans-67
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`3 * add1v2(4)`'
- en: 'This example illustrates why `return` is essential in Python: without it, no
    value is returned, which means you canâ€™t use the result of a function within another
    expression. So what use is `add1v2` then? Hold that question; weâ€™ll return to
    it in [Mutating Variables](mutating-variables.html).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªä¾‹å­è¯´æ˜äº†ä¸ºä»€ä¹ˆ `return` åœ¨ Python ä¸­æ˜¯å¿…ä¸å¯å°‘çš„ï¼šæ²¡æœ‰å®ƒï¼Œå°±ä¸ä¼šè¿”å›ä»»ä½•å€¼ï¼Œè¿™æ„å‘³ç€ä½ æ— æ³•åœ¨å¦ä¸€ä¸ªè¡¨è¾¾å¼ä¸­ä½¿ç”¨å‡½æ•°çš„ç»“æœã€‚é‚£ä¹ˆ
    `add1v2` åˆæœ‰ä»€ä¹ˆç”¨å‘¢ï¼Ÿä¿ç•™è¿™ä¸ªé—®é¢˜ï¼›æˆ‘ä»¬å°†åœ¨ [Mutating Variables](mutating-variables.html) ä¸­å›åˆ°å®ƒã€‚
- en: 9.1.3Â Examples and Test Cases[ğŸ”—](#(part._testing-python) "Link to here")
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.3Â ç¤ºä¾‹å’Œæµ‹è¯•ç”¨ä¾‹[ğŸ”—](#(part._testing-python) "é“¾æ¥è‡³æ­¤")
- en: 'In Pyret, we included examples with every function using `where:` blocks. We
    also had the ability to write `check:` blocks for more extensive tests. As a reminder,
    here was the `pen-cost` code including a `where:` block:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Pyret ä¸­ï¼Œæˆ‘ä»¬ä¸ºæ¯ä¸ªå‡½æ•°éƒ½æä¾›äº†ä½¿ç”¨ `where:` å—çš„ç¤ºä¾‹ã€‚æˆ‘ä»¬è¿˜èƒ½å¤Ÿç¼–å†™ `check:` å—æ¥è¿›è¡Œæ›´å¹¿æ³›çš„æµ‹è¯•ã€‚ä½œä¸ºæé†’ï¼Œä»¥ä¸‹æ˜¯åŒ…å«
    `where:` å—çš„ `pen-cost` ä»£ç ï¼š
- en: '[PRE5]total cost for pens, each 25 cents'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE5]æ¯æ”¯é’¢ç¬”çš„æ€»æˆæœ¬ï¼Œæ¯æ”¯25ç¾åˆ†'
- en: plus 2 cents per message character[PRE6]
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: æ¯æ¡æ¶ˆæ¯å­—ç¬¦åŠ 2ç¾åˆ†[PRE6]
- en: 'Python does not have a notion of `where:` blocks, or a distinction between
    examples and tests. There are a couple of different testing packages for Python;
    here we will use `pytest`, a standard lightweight framework that resembles the
    form of testing that we did in Pyret.How you set up pytest and your test file
    contents will vary according to your Python IDE. We assume instructors will provide
    separate instructions that align with their tool choices. To use `pytest`, we
    put both examples and tests in a separate function. Hereâ€™s an example of this
    for the `pen_cost` function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Python æ²¡æœ‰å…³äº `where:` å—çš„æ¦‚å¿µï¼Œä¹Ÿæ²¡æœ‰ç¤ºä¾‹å’Œæµ‹è¯•ä¹‹é—´çš„åŒºåˆ«ã€‚Python æœ‰å‡ ä¸ªä¸åŒçš„æµ‹è¯•åŒ…ï¼›åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ `pytest`ï¼Œè¿™æ˜¯ä¸€ä¸ªæ ‡å‡†çš„è½»é‡çº§æ¡†æ¶ï¼Œç±»ä¼¼äºæˆ‘ä»¬åœ¨
    Pyret ä¸­æ‰€åšçš„æµ‹è¯•å½¢å¼ã€‚å¦‚ä½•è®¾ç½® pytest å’Œä½ çš„æµ‹è¯•æ–‡ä»¶å†…å®¹å°†æ ¹æ®ä½ çš„ Python IDE è€Œæœ‰æ‰€ä¸åŒã€‚æˆ‘ä»¬å‡è®¾è®²å¸ˆå°†æä¾›ä¸ä»–ä»¬çš„å·¥å…·é€‰æ‹©ä¸€è‡´çš„å•ç‹¬è¯´æ˜ã€‚ä¸ºäº†ä½¿ç”¨
    `pytest`ï¼Œæˆ‘ä»¬å°†ç¤ºä¾‹å’Œæµ‹è¯•æ”¾åœ¨ä¸€ä¸ªå•ç‹¬çš„å‡½æ•°ä¸­ã€‚ä»¥ä¸‹æ˜¯å¯¹ `pen_cost` å‡½æ•°çš„ç¤ºä¾‹ï¼š
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Things to note about this code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: å…³äºæ­¤ä»£ç çš„æ³¨æ„äº‹é¡¹ï¼š
- en: Weâ€™ve imported `pytest`, the lightweight Python testing library.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»å¯¼å…¥äº† `pytest`ï¼Œè¿™æ˜¯ä¸€ä¸ªè½»é‡çº§çš„ Python æµ‹è¯•åº“ã€‚
- en: The examples have moved into a function (here `test_pens`) that takes no inputs.
    Note that the names of functions that contain test cases must have names that
    start with `test_` in order for `pytest` to find them.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿™äº›ä¾‹å­å·²ç»ç§»åŠ¨åˆ°ä¸€ä¸ªå‡½æ•°ä¸­ï¼ˆè¿™é‡Œ `test_pens`ï¼‰ï¼Œè¯¥å‡½æ•°ä¸æ¥å—ä»»ä½•è¾“å…¥ã€‚è¯·æ³¨æ„ï¼ŒåŒ…å«æµ‹è¯•ç”¨ä¾‹çš„å‡½æ•°åç§°å¿…é¡»ä»¥ `test_` å¼€å¤´ï¼Œä»¥ä¾¿ `pytest`
    èƒ½å¤Ÿæ‰¾åˆ°å®ƒä»¬ã€‚
- en: In Python, individual tests have the form
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨ Python ä¸­ï¼Œå•ä¸ªæµ‹è¯•çš„å½¢å¼æ˜¯
- en: '[PRE8]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: rather than the `is` form from Pyret.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: è€Œä¸æ˜¯ Pyret ä¸­çš„ `is` å½¢å¼ã€‚
- en: Do Now!
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Add one more test to the Python code, corresponding to the Pyret test
  id: totrans-83
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨ Python ä»£ç ä¸­æ·»åŠ ä¸€ä¸ªé¢å¤–çš„æµ‹è¯•ï¼Œå¯¹åº”äº Pyret æµ‹è¯•
- en: ''
  id: totrans-84
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-85
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make sure to run the test.
  id: totrans-87
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¡®ä¿è¿è¡Œæµ‹è¯•ã€‚
- en: Do Now!
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did you actually try to run the test?
  id: totrans-90
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ çœŸçš„å°è¯•è¿è¡Œæµ‹è¯•äº†å—ï¼Ÿ
- en: 'Whoa! Something weird happened: the test failed. Stop and think about that:
    the same test that worked in Pyret failed in Python. How can that be?'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: å“‡ï¼å‘ç”Ÿäº†ä¸€äº›å¥‡æ€ªçš„äº‹æƒ…ï¼šæµ‹è¯•å¤±è´¥äº†ã€‚åœä¸‹æ¥æƒ³æƒ³ï¼šåœ¨ Pyret ä¸­å·¥ä½œçš„åŒä¸€ä¸ªæµ‹è¯•åœ¨ Python ä¸­å¤±è´¥äº†ã€‚è¿™æ˜¯æ€ä¹ˆå›äº‹ï¼Ÿ
- en: 9.1.4Â An Aside on Numbers[ğŸ”—](#(part._.An_.Aside_on_.Numbers) "Link to here")
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.4 å…³äºæ•°å­—çš„æ—ç™½[ğŸ”—](#(part._.An_.Aside_on_.Numbers) "é“¾æ¥è‡³æ­¤")
- en: 'It turns out that different programming languages make different decisions
    about how to represent and manage real (non-integer) numbers. Sometimes, differences
    in these representations lead to subtle quantitative differences in computed values.
    As a simple example, letâ€™s look at two seemingly simple real numbers `1/2` and
    `1/3`. Hereâ€™s what we get when we type these two numbers at a Pyret prompt:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æœè¡¨æ˜ï¼Œä¸åŒçš„ç¼–ç¨‹è¯­è¨€åœ¨å¦‚ä½•è¡¨ç¤ºå’Œç®¡ç†å®æ•°ï¼ˆéæ•´æ•°ï¼‰æ–¹é¢åšå‡ºäº†ä¸åŒçš„å†³ç­–ã€‚æœ‰æ—¶ï¼Œè¿™äº›è¡¨ç¤ºæ–¹å¼ä¸Šçš„å·®å¼‚ä¼šå¯¼è‡´è®¡ç®—å€¼ä¸­ç»†å¾®çš„å®šé‡å·®å¼‚ã€‚ä½œä¸ºä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹ä¸¤ä¸ªçœ‹ä¼¼ç®€å•çš„å®æ•°
    `1/2` å’Œ `1/3`ã€‚ä»¥ä¸‹æ˜¯æˆ‘ä»¬åœ¨ Pyret æç¤ºç¬¦ä¸­è¾“å…¥è¿™ä¸¤ä¸ªæ•°å­—æ—¶å¾—åˆ°çš„ç»“æœï¼š
- en: '|'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE10]'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '&#124;'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE12]'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '&#124;'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'If we type these same two numbers in a Python console, we instead get:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬åœ¨ Python æ§åˆ¶å°ä¸­è¾“å…¥è¿™ä¸¤ä¸ªç›¸åŒçš„æ•°å­—ï¼Œæˆ‘ä»¬å¾—åˆ°çš„ç»“æœæ˜¯ï¼š
- en: '|'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE14]'
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '&#124;'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE16]'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '&#124;'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Notice that the answers look different for `1/3`. As you may (or may not!) recall
    from an earlier math class, `1/3` is an example of a non-terminating, repeating
    decimal. In plain terms, if we tried to write out the exact value of `1/3` in
    decimal form, we would need to write an infinite sequence of `3`. Mathematicians
    denote this by putting a horizontal bar over the `3`. This is the notation we
    see in Pyret. Python, in contrast, writes out a partial sequence of `3`s.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå¯¹äº `1/3`ï¼Œç­”æ¡ˆçœ‹èµ·æ¥ä¸åŒã€‚ä½ å¯èƒ½ï¼ˆæˆ–è€…å¯èƒ½æ²¡æœ‰ï¼ï¼‰ä»ä¹‹å‰çš„æ•°å­¦è¯¾ç¨‹ä¸­å›å¿†èµ·æ¥ï¼Œ`1/3` æ˜¯ä¸€ä¸ªéç»ˆæ­¢ã€å¾ªç¯å°æ•°çš„ä¾‹å­ã€‚ç®€å•æ¥è¯´ï¼Œå¦‚æœæˆ‘ä»¬å°è¯•ç”¨åè¿›åˆ¶å½¢å¼å†™å‡º
    `1/3` çš„ç¡®åˆ‡å€¼ï¼Œæˆ‘ä»¬éœ€è¦å†™å‡ºæ— é™åºåˆ—çš„ `3`ã€‚æ•°å­¦å®¶é€šè¿‡åœ¨ `3` ä¸Šæ”¾ç½®ä¸€ä¸ªæ°´å¹³çº¿æ¥è¡¨ç¤ºè¿™ä¸€ç‚¹ã€‚è¿™å°±æ˜¯æˆ‘ä»¬åœ¨ Pyret ä¸­çœ‹åˆ°çš„è¡¨ç¤ºæ³•ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼ŒPython
    å†™å‡º `3` çš„éƒ¨åˆ†åºåˆ—ã€‚
- en: 'Underneath this distinction lies some interesting details about representing
    numbers in computers. Computers donâ€™t have infinite space to store numbers (or
    anything else, for that matter): when a program needs to work with a non-terminating
    decimal, the underlying language can either:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªåŒºåˆ«ä¹‹ä¸‹ï¼Œéšè—ç€ä¸€äº›å…³äºè®¡ç®—æœºä¸­æ•°å­—è¡¨ç¤ºçš„æœ‰è¶£ç»†èŠ‚ã€‚è®¡ç®—æœºæ²¡æœ‰æ— é™çš„ç©ºé—´æ¥å­˜å‚¨æ•°å­—ï¼ˆæˆ–è€…ä»»ä½•å…¶ä»–ä¸œè¥¿ï¼‰ï¼šå½“ç¨‹åºéœ€è¦ä¸éç»ˆæ­¢å°æ•°ä¸€èµ·å·¥ä½œæ—¶ï¼Œåº•å±‚è¯­è¨€å¯ä»¥é€‰æ‹©ï¼š
- en: approximate the number (by chopping off the infinite sequence of digits at some
    point), then work only with the approximated value going forward, or
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿‘ä¼¼è¿™ä¸ªæ•°å­—ï¼ˆé€šè¿‡åœ¨æŸä¸ªç‚¹åˆ‡æ–­æ— é™ä½æ•°çš„åºåˆ—ï¼‰ï¼Œç„¶ååªä½¿ç”¨è¿‘ä¼¼å€¼ç»§ç»­å·¥ä½œï¼Œæˆ–è€…
- en: store additional information about the number that may enable doing more precise
    computation with it later (though there are always some numbers that cannot be
    represented exactly in finite space).
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å­˜å‚¨æœ‰å…³æ•°å­—çš„é¢å¤–ä¿¡æ¯ï¼Œè¿™å¯èƒ½å…è®¸ä»¥åç”¨æ›´ç²¾ç¡®çš„è®¡ç®—æ¥ä½¿ç”¨å®ƒï¼ˆå°½ç®¡æ€»æœ‰ä¸€äº›æ•°å­—æ— æ³•åœ¨æœ‰é™ç©ºé—´ä¸­ç²¾ç¡®è¡¨ç¤ºï¼‰ã€‚
- en: Python takes the first approach. As a result, computations with the approximated
    values sometimes yield approximated results. This is what happens with our new
    `pen_cost` test case. While mathematically, the computation should result in `0.93`,
    the approximations yield `0.9299999999999999` instead.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Python é‡‡ç”¨ç¬¬ä¸€ç§æ–¹æ³•ã€‚å› æ­¤ï¼Œä½¿ç”¨è¿‘ä¼¼å€¼è¿›è¡Œçš„è®¡ç®—æœ‰æ—¶ä¼šäº§ç”Ÿè¿‘ä¼¼çš„ç»“æœã€‚è¿™å°±æ˜¯æˆ‘ä»¬æ–°çš„ `pen_cost` æµ‹è¯•ç”¨ä¾‹å‘ç”Ÿçš„æƒ…å†µã€‚ä»æ•°å­¦ä¸Šè®²ï¼Œè®¡ç®—åº”è¯¥å¾—åˆ°
    `0.93`ï¼Œä½†è¿‘ä¼¼å€¼å´å¾—åˆ° `0.9299999999999999`ã€‚
- en: 'So how do we write tests in this situation? We need to tell Python that the
    answer should be â€œcloseâ€ to `0.93`, within the error range of approximations.
    Hereâ€™s what that looks like:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹æˆ‘ä»¬å¦‚ä½•ç¼–å†™æµ‹è¯•ï¼Ÿæˆ‘ä»¬éœ€è¦å‘Šè¯‰ Pythonï¼Œç­”æ¡ˆåº”è¯¥æ˜¯â€œæ¥è¿‘â€ `0.93`ï¼Œåœ¨è¿‘ä¼¼çš„è¯¯å·®èŒƒå›´å†…ã€‚ä¸‹é¢æ˜¯è¿™ä¸ªæ ·å­çš„ï¼š
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We wrapped the exact answer we wanted in `pytest.approx`, to indicate that weâ€™ll
    accept any answer that is nearly the value we specified. You can control the number
    of decimal points of precision if you want to, but the default of `Â± 2.3e-06`
    often suffices.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†æˆ‘ä»¬æƒ³è¦çš„ç²¾ç¡®ç­”æ¡ˆåŒ…è£…åœ¨ `pytest.approx` ä¸­ï¼Œä»¥è¡¨ç¤ºæˆ‘ä»¬å°†æ¥å—ä»»ä½•æ¥è¿‘æˆ‘ä»¬æŒ‡å®šçš„å€¼çš„ç­”æ¡ˆã€‚å¦‚æœæ‚¨æƒ³æ§åˆ¶å°æ•°ç‚¹çš„ç²¾åº¦ä½æ•°ï¼Œå¯ä»¥è¿™æ ·åšï¼Œä½†é»˜è®¤çš„
    `Â± 2.3e-06` é€šå¸¸è¶³å¤Ÿäº†ã€‚
- en: 9.1.5Â Conditionals[ğŸ”—](#(part._conditionals-python) "Link to here")
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.5 æ¡ä»¶è¯­å¥[ğŸ”—](#(part._conditionals-python) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Continuing with our original `pen_cost` example, hereâ€™s the Python version
    of the function that computed shipping costs on an order:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ç»§ç»­æˆ‘ä»¬çš„åŸå§‹ `pen_cost` ç¤ºä¾‹ï¼Œä»¥ä¸‹æ˜¯è®¡ç®—è®¢å•è¿è´¹çš„å‡½æ•°çš„ Python ç‰ˆæœ¬ï¼š
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The main difference to notice here is that `else if` is written as the single-word
    `elif` in Python. We use `return` to mark the functionâ€™s results in each branch
    of the conditional. Otherwise, the conditional constructs are quite similar across
    the two languages.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œè¦æ³¨æ„çš„ä¸»è¦åŒºåˆ«æ˜¯ï¼ŒPython ä¸­å°† `else if` å†™ä½œå•è¯ `elif`ã€‚æˆ‘ä»¬ä½¿ç”¨ `return` æ¥æ ‡è®°æ¯ä¸ªæ¡ä»¶åˆ†æ”¯ä¸­çš„å‡½æ•°ç»“æœã€‚å¦åˆ™ï¼Œä¸¤ç§è¯­è¨€çš„æ¡ä»¶ç»“æ„ç›¸å½“ç›¸ä¼¼ã€‚
- en: You may have noticed that Python does not require an explicit `end` annotation
    on `if`-expressions or functions. Instead, Python looks at the indentation of
    your code to determine when a construct has ended. For example, in the code sample
    for `pen_cost` and `test_pens`, Python determines that the `pen_cost` function
    has ended because it detects a new definition (for `test_pens`) at the left edge
    of the program text. The same principle holds for ending conditionals.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: æ‚¨å¯èƒ½å·²ç»æ³¨æ„åˆ° Python ä¸éœ€è¦åœ¨ `if` è¡¨è¾¾å¼æˆ–å‡½æ•°ä¸Šæ˜¾å¼ä½¿ç”¨ `end` æ³¨è§£ã€‚ç›¸åï¼ŒPython ä¼šæŸ¥çœ‹æ‚¨çš„ä»£ç ç¼©è¿›æ¥ç¡®å®šä½•æ—¶ç»“æŸä¸€ä¸ªç»“æ„ã€‚ä¾‹å¦‚ï¼Œåœ¨
    `pen_cost` å’Œ `test_pens` çš„ä»£ç ç¤ºä¾‹ä¸­ï¼ŒPython ç¡®å®šå‡½æ•° `pen_cost` å·²ç»ç»“æŸï¼Œå› ä¸ºå®ƒåœ¨ç¨‹åºæ–‡æœ¬çš„å·¦ä¾§æ£€æµ‹åˆ°ä¸€ä¸ªæ–°çš„å®šä¹‰ï¼ˆå¯¹äº
    `test_pens`ï¼‰ã€‚åŒæ ·çš„åŸåˆ™ä¹Ÿé€‚ç”¨äºç»“æŸæ¡ä»¶ã€‚
- en: Weâ€™ll return to this point about indentation, and see more examples, as we work
    more with Python.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†å›åˆ°å…³äºç¼©è¿›çš„é—®é¢˜ï¼Œå¹¶åœ¨æˆ‘ä»¬æ›´å¤šåœ°ä½¿ç”¨ Python æ—¶çœ‹åˆ°æ›´å¤šç¤ºä¾‹ã€‚
- en: 9.1.6Â Creating and Processing Lists[ğŸ”—](#(part._python-create-process-lists)
    "Link to here")
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.6 åˆ›å»ºå’Œå¤„ç†åˆ—è¡¨[ğŸ”—](#(part._python-create-process-lists) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'As an example of lists, letâ€™s assume weâ€™ve been playing a game that involves
    making words out of a collection of letters. In Pyret, we could have written a
    sample word list as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºåˆ—è¡¨çš„ä¸€ä¸ªä¾‹å­ï¼Œè®©æˆ‘ä»¬å‡è®¾æˆ‘ä»¬ä¸€ç›´åœ¨ç©ä¸€ä¸ªæ¶‰åŠä»ä¸€ç»„å­—æ¯ä¸­åˆ¶ä½œå•è¯çš„æ¸¸æˆã€‚åœ¨ Pyret ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·ç¼–å†™ä¸€ä¸ªç¤ºä¾‹å•è¯åˆ—è¡¨ï¼š
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In Python, this definition would look like:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Python ä¸­ï¼Œè¿™ä¸ªå®šä¹‰çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ï¼š
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The only difference here is that Python does not use the `list:` label that
    is needed in Pyret.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œçš„å”¯ä¸€åŒºåˆ«æ˜¯ Python ä¸ä½¿ç”¨ Pyret ä¸­éœ€è¦çš„ `list:` æ ‡ç­¾ã€‚
- en: 9.1.6.1Â Filters, Maps, and Friends[ğŸ”—](#(part._.Filters__.Maps__and_.Friends)
    "Link to here")
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.6.1 è¿‡æ»¤å™¨ã€æ˜ å°„å’Œæœ‹å‹ä»¬[ğŸ”—](#(part._.Filters__.Maps__and_.Friends) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'When we first learned about lists in Pyret, we started with common built-in
    functions such as `filter`, `map`, `member` and `length`. We also saw the use
    of `lambda` to help us use some of these functions concisely. These same functions,
    including `lambda`, also exist in Python. Here are some samples (`#` is the comment
    character in Python):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬ç¬¬ä¸€æ¬¡å­¦ä¹  Pyret ä¸­çš„åˆ—è¡¨æ—¶ï¼Œæˆ‘ä»¬ä»å¸¸è§çš„å†…ç½®å‡½æ•°å¼€å§‹ï¼Œä¾‹å¦‚ `filter`ã€`map`ã€`member` å’Œ `length`ã€‚æˆ‘ä»¬è¿˜çœ‹åˆ°äº†ä½¿ç”¨
    `lambda` æ¥å¸®åŠ©æˆ‘ä»¬ç®€æ´åœ°ä½¿ç”¨è¿™äº›å‡½æ•°çš„ä¾‹å­ã€‚è¿™äº›ç›¸åŒçš„å‡½æ•°ï¼ŒåŒ…æ‹¬ `lambda`ï¼Œä¹Ÿå­˜åœ¨äº Python ä¸­ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›ç¤ºä¾‹ï¼ˆ`#` æ˜¯ Python
    ä¸­çš„æ³¨é‡Šå­—ç¬¦ï¼‰ï¼š
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that you have to wrap calls to `filter` (and `map`) with a use of `list()`.
    Internally, Python has these functions return a type of data that we havenâ€™t yet
    discussed (and donâ€™t need). Using `list` converts the returned data into a list.
    If you omit the `list`, you wonâ€™t be able to chain certain functions together.
    For example, if we tried to compute the length of the result of a `map` without
    first converting to a `list`, weâ€™d get an error:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæ‚¨å¿…é¡»ä½¿ç”¨ `list()` çš„æ–¹å¼æ¥åŒ…è£…å¯¹ `filter`ï¼ˆå’Œ `map`ï¼‰çš„è°ƒç”¨ã€‚å†…éƒ¨ï¼ŒPython æœ‰è¿™äº›å‡½æ•°è¿”å›æˆ‘ä»¬å°šæœªè®¨è®ºï¼ˆä¹Ÿä¸éœ€è¦ï¼‰çš„æ•°æ®ç±»å‹ã€‚ä½¿ç”¨
    `list` å°†è¿”å›çš„æ•°æ®è½¬æ¢ä¸ºåˆ—è¡¨ã€‚å¦‚æœæ‚¨çœç•¥ `list`ï¼Œæ‚¨å°†æ— æ³•å°†æŸäº›å‡½æ•°é“¾æ¥åœ¨ä¸€èµ·ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬è¯•å›¾åœ¨ä¸é¦–å…ˆå°†å…¶è½¬æ¢ä¸º `list` çš„æƒ…å†µä¸‹è®¡ç®—
    `map` çš„ç»“æœé•¿åº¦ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä¸€ä¸ªé”™è¯¯ï¼š
- en: '|'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE23]'
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '&#124;'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Donâ€™t worry if this error message makes no sense at the moment (we havenâ€™t yet
    learned what an â€œobjectâ€ is). The point is that if you see an error like this
    while using the result of `filter` or `map`, you likely forgot to wrap the result
    in `list`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœè¿™ä¸ªé”™è¯¯ä¿¡æ¯ç°åœ¨æ²¡æœ‰æ„ä¹‰ï¼Œè¯·ä¸è¦æ‹…å¿ƒï¼ˆæˆ‘ä»¬è¿˜æ²¡æœ‰å­¦ä¹ ä»€ä¹ˆæ˜¯â€œå¯¹è±¡â€ï¼‰ã€‚å…³é”®æ˜¯ï¼Œå¦‚æœæ‚¨åœ¨ä½¿ç”¨ `filter` æˆ– `map` çš„ç»“æœæ—¶çœ‹åˆ°è¿™æ ·çš„é”™è¯¯ï¼Œæ‚¨å¯èƒ½å¿˜è®°å°†ç»“æœåŒ…è£…åœ¨
    `list` ä¸­ã€‚
- en: Exercise
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Practice Pythonâ€™s list functions by writing expressions for the following problems.
    Use only the list functions we have shown you so far.
  id: totrans-162
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: é€šè¿‡ç¼–å†™ä»¥ä¸‹é—®é¢˜çš„è¡¨è¾¾å¼æ¥ç»ƒä¹ Pythonçš„åˆ—è¡¨å‡½æ•°ã€‚è¯·åªä½¿ç”¨æˆ‘ä»¬è¿„ä»Šä¸ºæ­¢å‘æ‚¨å±•ç¤ºçš„åˆ—è¡¨å‡½æ•°ã€‚
- en: ''
  id: totrans-163
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given a list of numbers, convert it to a list of strings `"pos"`, `"neg"`, `"zero"`,
    based on the sign of each number.
  id: totrans-164
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼Œæ ¹æ®æ¯ä¸ªæ•°å­—çš„ç¬¦å·å°†å…¶è½¬æ¢ä¸º`"pos"`ã€`"neg"`ã€`"zero"`å­—ç¬¦ä¸²åˆ—è¡¨ã€‚
- en: ''
  id: totrans-165
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-166
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Given a list of strings, is the length of any string equal to 5?
  id: totrans-167
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ï¼Œæ˜¯å¦æœ‰ä»»ä½•å­—ç¬¦ä¸²çš„é•¿åº¦ç­‰äº5ï¼Ÿ
- en: ''
  id: totrans-168
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-169
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Given a list of numbers, produce a list of the even numbers between 10 and 20
    from that list.
  id: totrans-170
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼Œä»è¯¥åˆ—è¡¨ä¸­ç”Ÿæˆä¸€ä¸ªåŒ…å«10åˆ°20ä¹‹é—´å¶æ•°çš„åˆ—è¡¨ã€‚
- en: Weâ€™re intentionally focusing on computations that use Pythonâ€™s built-in functions
    for processing lists, rather than showing you how to write you own (as we did
    with recursion in Pyret). While you can write recursive functions to process lists
    in Pyret, a different style of program is more conventional for that purpose.
    Weâ€™ll look at that in the chapter on [Mutating Variables](mutating-variables.html).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ•…æ„ä¸“æ³¨äºä½¿ç”¨Pythonå†…ç½®å‡½æ•°å¤„ç†è®¡ç®—ï¼Œè€Œä¸æ˜¯å‘æ‚¨å±•ç¤ºå¦‚ä½•ç¼–å†™è‡ªå·±çš„å‡½æ•°ï¼ˆæ­£å¦‚æˆ‘ä»¬åœ¨Pyretä¸­å¤„ç†é€’å½’é‚£æ ·ï¼‰ã€‚è™½ç„¶æ‚¨å¯ä»¥åœ¨Pyretä¸­ç¼–å†™å¤„ç†åˆ—è¡¨çš„é€’å½’å‡½æ•°ï¼Œä½†ç”¨äºæ­¤ç›®çš„çš„å¦ä¸€ç§ç¨‹åºé£æ ¼æ›´ä¸ºä¼ ç»Ÿã€‚æˆ‘ä»¬å°†åœ¨å…³äº[å¯å˜å˜é‡](mutating-variables.html)çš„ç« èŠ‚ä¸­æ¢è®¨è¿™ä¸€ç‚¹ã€‚
- en: 9.1.7Â Data with Components[ğŸ”—](#(part._python-data-with-components) "Link to
    here")
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.7 æ•°æ®ç»„ä»¶[ğŸ”—](#(part._python-data-with-components) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'An analog to a Pyret data definition (without variants) is called a dataclass
    in Python.Those experienced with Python may wonder why we are using dataclasses
    instead of dictionaries or raw classes. Compared to dictionaries, dataclasses
    allow the use of type hints and capture that our data has a fixed collection of
    fields. Compared to raw classes, dataclasses generate a lot of boilerplate code
    that makes them much lighterweight than raw classes. Hereâ€™s an example of a todo-list
    datatype in Pyret and its corresponding Python code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªç±»ä¼¼äºPyretæ•°æ®å®šä¹‰ï¼ˆæ²¡æœ‰å˜ä½“ï¼‰çš„ç§°ä¸ºPythonä¸­çš„æ•°æ®ç±»ã€‚é‚£äº›ç†Ÿæ‚‰Pythonçš„äººå¯èƒ½ä¼šæƒ³çŸ¥é“ä¸ºä»€ä¹ˆæˆ‘ä»¬ä½¿ç”¨æ•°æ®ç±»è€Œä¸æ˜¯å­—å…¸æˆ–åŸå§‹ç±»ã€‚ä¸å­—å…¸ç›¸æ¯”ï¼Œæ•°æ®ç±»å…è®¸ä½¿ç”¨ç±»å‹æç¤ºå¹¶æ•è·æˆ‘ä»¬çš„æ•°æ®å…·æœ‰å›ºå®šå­—æ®µé›†åˆçš„äº‹å®ã€‚ä¸åŸå§‹ç±»ç›¸æ¯”ï¼Œæ•°æ®ç±»ç”Ÿæˆå¤§é‡çš„æ ·æ¿ä»£ç ï¼Œè¿™ä½¿å¾—å®ƒä»¬æ¯”åŸå§‹ç±»æ›´è½»é‡çº§ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªPyretä¸­çš„å¾…åŠäº‹é¡¹åˆ—è¡¨æ•°æ®ç±»å‹åŠå…¶å¯¹åº”çš„Pythonä»£ç ç¤ºä¾‹ï¼š
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Things to note:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„äº‹é¡¹ï¼š
- en: There is a single name for the type and the constructor, rather than separate
    names as we had in Pyret.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç±»å‹åŠå…¶æ„é€ å‡½æ•°æœ‰ä¸€ä¸ªå•ç‹¬çš„åç§°ï¼Œè€Œä¸æ˜¯åƒæˆ‘ä»¬åœ¨Pyretä¸­é‚£æ ·æœ‰å•ç‹¬çš„åç§°ã€‚
- en: There are no commas between field names (but each has to be on its own line
    in Python)
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å­—æ®µåä¹‹é—´æ²¡æœ‰é€—å·ï¼ˆä½†åœ¨Pythonä¸­æ¯ä¸ªå­—æ®µå¿…é¡»å•ç‹¬å ä¸€è¡Œï¼‰
- en: There is no way to specify the type of the contents of the list in Python (at
    least, not without using more advance packages for writing types)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨Pythonä¸­ï¼Œæ— æ³•æŒ‡å®šåˆ—è¡¨å†…å®¹çš„ç±»å‹ï¼ˆè‡³å°‘ï¼Œä¸ä½¿ç”¨æ›´é«˜çº§çš„åŒ…æ¥ç¼–å†™ç±»å‹ï¼‰
- en: The `@dataclass` annotation is needed before `class`.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨`class`ä¹‹å‰éœ€è¦`@dataclass`æ³¨è§£ã€‚
- en: Dataclasses donâ€™t support creating datatypes with multiple variants, like we
    did frequently in Pyret. Doing that needs more advanced concepts than we will
    cover in this book.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ•°æ®ç±»ä¸æ”¯æŒåˆ›å»ºå…·æœ‰å¤šä¸ªå˜ä½“çš„æ•°æ®ç±»å‹ï¼Œå°±åƒæˆ‘ä»¬åœ¨Pyretä¸­ç»å¸¸åšçš„é‚£æ ·ã€‚è¿™æ ·åšéœ€è¦æ¯”æˆ‘ä»¬åœ¨è¿™æœ¬ä¹¦ä¸­å°†è¦æ¶µç›–çš„æ›´é«˜çº§çš„æ¦‚å¿µã€‚
- en: 9.1.7.1Â Accessing Fields within Dataclasses[ğŸ”—](#(part._.Accessing_.Fields_within_.Dataclasses)
    "Link to here")
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.7.1 åœ¨æ•°æ®ç±»ä¸­è®¿é—®å­—æ®µ[ğŸ”—](#(part._.Accessing_.Fields_within_.Dataclasses) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'In Pyret, we extracted a field from structured data by using a dot (period)
    to â€œdig intoâ€ the datum and access the field. The same notation works in Python:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Pyretä¸­ï¼Œæˆ‘ä»¬é€šè¿‡ä½¿ç”¨ç‚¹ï¼ˆ`.`ï¼‰æ¥â€œæŒ–æ˜â€æ•°æ®å¹¶è®¿é—®å­—æ®µæ¥ä»ç»“æ„åŒ–æ•°æ®ä¸­æå–å­—æ®µã€‚ç›¸åŒçš„ç¬¦å·åœ¨Pythonä¸­åŒæ ·é€‚ç”¨ï¼š
- en: '|'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE28]'
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '&#124;'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 9.1.8Â Traversing Lists[ğŸ”—](#(part._python-traverse-lists) "Link to here")
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.8 éå†åˆ—è¡¨[ğŸ”—](#(part._python-traverse-lists) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 9.1.8.1Â Introducing `For` Loops[ğŸ”—](#(part._python-for-loops) "Link to here")
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.1 ä»‹ç» `For` å¾ªç¯[ğŸ”—](#(part._python-for-loops) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'In Pyret, we typically write recursive functions to compute summary values
    over lists. As a reminder, hereâ€™s a Pyret function that sums the numbers in a
    list:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Pyretä¸­ï¼Œæˆ‘ä»¬é€šå¸¸ç¼–å†™é€’å½’å‡½æ•°æ¥è®¡ç®—åˆ—è¡¨ä¸Šçš„æ±‡æ€»å€¼ã€‚ä½œä¸ºæé†’ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªPyretå‡½æ•°ï¼Œç”¨äºè®¡ç®—åˆ—è¡¨ä¸­çš„æ•°å­—ä¹‹å’Œï¼š
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In Python, it is unusual to break a list into its first and rest components
    and process the rest recursively. Instead, we use a construct called a `for` to
    visit each element of a list in turn. Hereâ€™s the form of `for`, using a concrete
    (example) list of odd numbers:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Pythonä¸­ï¼Œå°†åˆ—è¡¨åˆ†è§£ä¸ºå…¶ç¬¬ä¸€ä¸ªå’Œå…¶ä½™éƒ¨åˆ†å¹¶é€’å½’å¤„ç†å…¶ä½™éƒ¨åˆ†æ˜¯ä¸å¸¸è§çš„ã€‚ç›¸åï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªç§°ä¸º`for`çš„æ„é€ æ¥ä¾æ¬¡è®¿é—®åˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªä½¿ç”¨å…·ä½“ï¼ˆç¤ºä¾‹ï¼‰å¥‡æ•°åˆ—è¡¨çš„`for`çš„å½¢å¼ï¼š
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The name `num` here is of our choosing, just as with the names of parameters
    to a function in Pyret. When a `for` loop evaluates, each item in the list is
    referred to as `num` in turn. Thus, this `for` example is equivalent to writing
    the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œçš„ `num` åç§°æ˜¯æˆ‘ä»¬è‡ªå·±é€‰æ‹©çš„ï¼Œå°±åƒ Pyret ä¸­å‡½æ•°å‚æ•°çš„åç§°ä¸€æ ·ã€‚å½“ `for` å¾ªç¯è¯„ä¼°æ—¶ï¼Œåˆ—è¡¨ä¸­çš„æ¯ä¸ªé¡¹ç›®ä¾æ¬¡è¢«ç§°ä¸º `num`ã€‚å› æ­¤ï¼Œè¿™ä¸ª
    `for` ç¤ºä¾‹ç­‰åŒäºç¼–å†™ä»¥ä¸‹å†…å®¹ï¼š
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `for` construct saves us from writing the common code multiple times, and
    also handles the fact that the lists we are processing can be of arbitrary length
    (so we canâ€™t predict how many times to write the common code).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` æ„é€ èŠ‚çœäº†æˆ‘ä»¬å¤šæ¬¡ç¼–å†™å¸¸è§ä»£ç çš„æ—¶é—´ï¼Œå¹¶ä¸”å¤„ç†äº†æˆ‘ä»¬æ­£åœ¨å¤„ç†çš„åˆ—è¡¨å¯ä»¥æ˜¯ä»»æ„é•¿åº¦çš„äº‹å®ï¼ˆå› æ­¤æˆ‘ä»¬æ— æ³•é¢„æµ‹éœ€è¦ç¼–å†™å¤šå°‘æ¬¡å¸¸è§ä»£ç ï¼‰ã€‚'
- en: 'Letâ€™s now use `for` to compute the running sum of a list. Weâ€™ll start by figuring
    out the repeated computation with our concrete list again. At first, letâ€™s express
    the repeated computation just in prose. In Pyret, our repeated computation was
    along the lines of â€œadd the first item to the sum of the rest of the itemsâ€. Weâ€™ve
    already said that we cannot easily access the â€œrest of the itemsâ€ in Python, so
    we need to rephrase this. Hereâ€™s an alternative:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬ä½¿ç”¨ `for` å¾ªç¯æ¥è®¡ç®—åˆ—è¡¨çš„ç´¯åŠ å’Œã€‚æˆ‘ä»¬é¦–å…ˆé€šè¿‡æˆ‘ä»¬çš„å…·ä½“åˆ—è¡¨å†æ¬¡ç¡®å®šé‡å¤çš„è®¡ç®—ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬ç”¨æ•£æ–‡çš„å½¢å¼è¡¨è¾¾é‡å¤çš„è®¡ç®—ã€‚åœ¨ Pyret
    ä¸­ï¼Œæˆ‘ä»¬çš„é‡å¤è®¡ç®—æ˜¯è¿™æ ·çš„ï¼šâ€œå°†ç¬¬ä¸€ä¸ªå…ƒç´ åŠ åˆ°å…¶ä½™å…ƒç´ çš„å’Œä¸Šâ€ã€‚æˆ‘ä»¬å·²ç»è¯´è¿‡ï¼Œåœ¨ Python ä¸­æˆ‘ä»¬æ— æ³•è½»æ¾è®¿é—®â€œå…¶ä½™çš„å…ƒç´ â€ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦é‡æ–°è¡¨è¿°ã€‚è¿™é‡Œæœ‰ä¸€ä¸ªæ›¿ä»£æ–¹æ¡ˆï¼š
- en: '[PRE33]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Note that this framing refers not to the â€œrest of the computationâ€, but rather
    to the computation that has happened so far (the â€œrunning totalâ€). If you happened
    to work through the chapter on [`my-running-sum`: Examples and Code](processing-lists.html#%28part._running-sum-eg-code%29),
    this framing might be familiar.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè¿™ä¸ªæ¡†æ¶æŒ‡çš„æ˜¯â€œå‰©ä½™çš„è®¡ç®—â€ï¼Œè€Œä¸æ˜¯åˆ°ç›®å‰ä¸ºæ­¢å·²ç»å‘ç”Ÿçš„è®¡ç®—ï¼ˆâ€œç´¯åŠ æ€»åˆâ€ï¼‰ã€‚å¦‚æœä½ æ°å¥½å¤„ç†äº†å…³äº `my-running-sum` çš„ç« èŠ‚ï¼ˆ[æˆ‘çš„ç´¯åŠ å’Œï¼šç¤ºä¾‹å’Œä»£ç ](processing-lists.html#%28part._running-sum-eg-code%29)ï¼‰ï¼Œè¿™ä¸ªæ¡†æ¶å¯èƒ½å¾ˆç†Ÿæ‚‰ã€‚
- en: Letâ€™s convert this prose sketch to code by replacing each line of the sketch
    with concrete code. We do this by setting up a variable named `run_total` and
    updating its value for each element.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å°†è¿™ä¸ªæ•£æ–‡è‰å›¾è½¬æ¢ä¸ºä»£ç ï¼Œé€šè¿‡å°†è‰å›¾ä¸­çš„æ¯ä¸€è¡Œæ›¿æ¢ä¸ºå…·ä½“çš„ä»£ç æ¥å®ç°ã€‚æˆ‘ä»¬é€šè¿‡è®¾ç½®ä¸€ä¸ªåä¸º `run_total` çš„å˜é‡å¹¶æ›´æ–°å…¶å€¼æ¥åšåˆ°è¿™ä¸€ç‚¹ï¼Œå¯¹äºåˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½è¿™æ ·åšã€‚
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This idea that you can give a new value to an existing variable name is something
    we havenâ€™t seen before. In fact, when we first saw how to name values (in [The
    Program Directory](Naming_Values.html#%28part._program-directory%29)), we explicitly
    said that Pyret doesnâ€™t let you do this (at least, not with the constructs that
    we showed you). Python does. Weâ€™ll explore the consequences of this ability in
    more depth shortly (in [Mutating Variables](mutating-variables.html)). For now,
    letâ€™s just use that ability so we can learn the pattern for traversing lists.
    First, letâ€™s collapse the repeated lines of code into a single use of `for`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§å¯ä»¥ç»™ç°æœ‰å˜é‡åèµ‹äºˆæ–°å€¼çš„æ€æƒ³æ˜¯æˆ‘ä»¬ä¹‹å‰æ²¡æœ‰è§è¿‡çš„ã€‚äº‹å®ä¸Šï¼Œå½“æˆ‘ä»¬ç¬¬ä¸€æ¬¡çœ‹åˆ°å¦‚ä½•å‘½åå€¼ï¼ˆåœ¨[ç¨‹åºç›®å½•](Naming_Values.html#%28part._program-directory%29)ï¼‰æ—¶ï¼Œæˆ‘ä»¬æ˜ç¡®è¡¨ç¤º
    Pyret ä¸å…è®¸è¿™æ ·åšï¼ˆè‡³å°‘ï¼Œä¸æ˜¯ç”¨æˆ‘ä»¬å‘æ‚¨å±•ç¤ºçš„æ„é€ ï¼‰ã€‚Python å¯ä»¥ã€‚æˆ‘ä»¬å°†åœ¨ä¸ä¹…çš„å°†æ¥æ›´æ·±å…¥åœ°æ¢è®¨è¿™ç§èƒ½åŠ›çš„å½±å“ï¼ˆåœ¨[ä¿®æ”¹å˜é‡](mutating-variables.html)ï¼‰ã€‚ç°åœ¨ï¼Œè®©æˆ‘ä»¬åˆ©ç”¨è¿™ç§èƒ½åŠ›ï¼Œè¿™æ ·æˆ‘ä»¬å¯ä»¥å­¦ä¹ éå†åˆ—è¡¨çš„æ¨¡å¼ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬å°†é‡å¤çš„ä»£ç è¡Œåˆå¹¶ä¸ºå•ä¸ª
    `for` å¾ªç¯çš„ä½¿ç”¨ï¼š
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This code works fine for a specific list, but our Pyret version took the list
    to sum as a parameter to a function. To achieve this in Python, we wrap the `for`
    in a function as we have done for other examples earlier in this chapter. This
    is the final version.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ®µä»£ç å¯¹äºç‰¹å®šçš„åˆ—è¡¨æ¥è¯´è¿è¡Œè‰¯å¥½ï¼Œä½†æˆ‘ä»¬çš„ Pyret ç‰ˆæœ¬å°†æ±‚å’Œçš„åˆ—è¡¨ä½œä¸ºå‡½æ•°çš„å‚æ•°ã€‚ä¸ºäº†åœ¨ Python ä¸­å®ç°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬åƒæœ¬ç« å‰é¢å…¶ä»–ç¤ºä¾‹ä¸­é‚£æ ·å°†
    `for` å¾ªç¯åŒ…è£¹åœ¨å‡½æ•°ä¸­ã€‚è¿™å°±æ˜¯æœ€ç»ˆç‰ˆæœ¬ã€‚
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Do Now!
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹å³è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a set of tests for `sum_list` (the Python version).
  id: totrans-215
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸º `sum_list`ï¼ˆPython ç‰ˆæœ¬ï¼‰ç¼–å†™ä¸€ç»„æµ‹è¯•ç”¨ä¾‹ã€‚
- en: 'Now that the Python version is done, letâ€™s compare it to the original Pyret
    version:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨Pythonç‰ˆæœ¬å·²ç»å®Œæˆï¼Œè®©æˆ‘ä»¬å°†å…¶ä¸åŸå§‹çš„ Pyret ç‰ˆæœ¬è¿›è¡Œæ¯”è¾ƒï¼š
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here are some things to notice about the two pieces of code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯å…³äºè¿™ä¸¤æ®µä»£ç çš„ä¸€äº›éœ€è¦æ³¨æ„çš„äº‹é¡¹ï¼š
- en: The Python version needs a variable (here `run_total`) to hold the result of
    the computation as we build it up while traversing (working through) the list.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python ç‰ˆæœ¬éœ€è¦ä¸€ä¸ªå˜é‡ï¼ˆè¿™é‡Œ `run_total`ï¼‰æ¥ä¿å­˜æˆ‘ä»¬åœ¨éå†ï¼ˆå¤„ç†ï¼‰åˆ—è¡¨æ—¶é€æ­¥æ„å»ºçš„è®¡ç®—ç»“æœã€‚
- en: The initial value of that variable is the answer we returned in the `empty`
    case in Pyret.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¯¥å˜é‡çš„åˆå§‹å€¼æ˜¯æˆ‘ä»¬ä¹‹å‰åœ¨ Pyret ä¸­çš„ `empty` æƒ…å†µä¸‹è¿”å›çš„ç­”æ¡ˆã€‚
- en: The computation in the `link` case of the Pyret function is used to update that
    variable in the body of the `for`.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pyret å‡½æ•°çš„ `link` æƒ…å†µä¸­çš„è®¡ç®—ç”¨äºåœ¨ `for` å¾ªç¯ä½“ä¸­æ›´æ–°è¯¥å˜é‡ã€‚
- en: After the `for` has finished processing all items in the list, the Python version
    returns the value in the variable as the result of the function.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨`for`å®Œæˆå¤„ç†åˆ—è¡¨ä¸­çš„æ‰€æœ‰é¡¹ç›®åï¼ŒPythonç‰ˆæœ¬å°†å˜é‡ä¸­çš„å€¼ä½œä¸ºå‡½æ•°çš„ç»“æœè¿”å›ã€‚
- en: 9.1.8.2Â An Aside on Order of Processing List Elements[ğŸ”—](#(part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements)
    "Link to here")
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.2Â å…³äºå¤„ç†åˆ—è¡¨å…ƒç´ é¡ºåºçš„æ—ç™½[ğŸ”—](#(part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements)
    "é“¾æ¥è‡³æ­¤")
- en: 'Thereâ€™s another subtlety here if we consider how the two programs run: the
    Python version sums the elements from left to right, whereas the Pyret version
    sums them right to left. Concretely, the sequence of values of `run_total` are
    computed as:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœè€ƒè™‘ä¸¤ä¸ªç¨‹åºçš„è¿è¡Œæ–¹å¼ï¼Œè¿™é‡Œè¿˜æœ‰ä¸€ä¸ªç»†å¾®ä¹‹å¤„ï¼šPythonç‰ˆæœ¬ä»å·¦åˆ°å³æ±‚å’Œå…ƒç´ ï¼Œè€ŒPyretç‰ˆæœ¬ä»å³åˆ°å·¦æ±‚å’Œã€‚å…·ä½“æ¥è¯´ï¼Œ`run_total`çš„å€¼åºåˆ—æ˜¯è¿™æ ·è®¡ç®—çš„ï¼š
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In contrast, the Pyret version unrolls as:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸æ¯”ä¹‹ä¸‹ï¼ŒPyretç‰ˆæœ¬å±•å¼€å¦‚ä¸‹ï¼š
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As a reminder, the Pyret version did this because the `+` in the `link` case
    can only reduce to an answer once the sum of the rest of the list has been computed.
    Even though we as humans see the chain of `+` operations in each line of the Pyret
    unrolling, Pyret sees only the expression `fst + sum-list(rst)`, which requires
    the function call to finish before the `+` executes.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºæé†’ï¼ŒPyretç‰ˆæœ¬è¿™æ ·åšæ˜¯å› ä¸ºåœ¨`link`æƒ…å†µä¸‹ï¼Œ`+`åªèƒ½åœ¨ä¸€æ¬¡è®¡ç®—å®Œå…¶ä½™åˆ—è¡¨çš„æ€»å’Œåæ‰èƒ½å‡å°‘åˆ°ç­”æ¡ˆã€‚å³ä½¿æˆ‘ä»¬ä½œä¸ºäººç±»çœ‹åˆ°Pyretå±•å¼€çš„æ¯ä¸€è¡Œä¸­çš„`+`æ“ä½œé“¾ï¼ŒPyretä¹Ÿåªçœ‹åˆ°è¡¨è¾¾å¼`fst
    + sum-list(rst)`ï¼Œè¿™è¦æ±‚å‡½æ•°è°ƒç”¨åœ¨`+`æ‰§è¡Œä¹‹å‰å®Œæˆã€‚
- en: In the case of summing a list, we donâ€™t notice the difference between the two
    versions because the sum is the same whether we compute it left-to-right or right-to-left.
    In other functions we write, this difference may start to matter.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ±‚å’Œåˆ—è¡¨çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¸ä¼šæ³¨æ„åˆ°ä¸¤ä¸ªç‰ˆæœ¬ä¹‹é—´çš„åŒºåˆ«ï¼Œå› ä¸ºæ— è®ºæˆ‘ä»¬æ˜¯å·¦åˆ°å³è¿˜æ˜¯å³åˆ°å·¦è®¡ç®—ï¼Œæ€»å’Œéƒ½æ˜¯ç›¸åŒçš„ã€‚åœ¨æˆ‘ä»¬ç¼–å†™çš„å…¶ä»–å‡½æ•°ä¸­ï¼Œè¿™ç§å·®å¼‚å¯èƒ½å¼€å§‹å˜å¾—é‡è¦ã€‚
- en: 9.1.8.3Â Using `For` Loops in Functions that Produce Lists[ğŸ”—](#(part._python-funcs-produce-lists)
    "Link to here")
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.3Â åœ¨ç”Ÿæˆåˆ—è¡¨çš„å‡½æ•°ä¸­ä½¿ç”¨`For`å¾ªç¯[ğŸ”—](#(part._python-funcs-produce-lists) "é“¾æ¥è‡³æ­¤")
- en: Letâ€™s practice using `for` loops on another function that traverses lists, this
    time one that produces a list. Specifically, letâ€™s write a program that takes
    a list of strings and produces a list of words within that list that contain the
    letter `"z"`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬åœ¨å¦ä¸€ä¸ªå‡½æ•°ä¸Šç»ƒä¹ ä½¿ç”¨`for`å¾ªç¯ï¼Œè¿™ä¸ªå‡½æ•°ç”Ÿæˆä¸€ä¸ªåˆ—è¡¨ã€‚å…·ä½“æ¥è¯´ï¼Œè®©æˆ‘ä»¬ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œå®ƒæ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ï¼Œå¹¶ç”Ÿæˆä¸€ä¸ªåŒ…å«åˆ—è¡¨ä¸­åŒ…å«å­—æ¯`"z"`çš„å•è¯çš„åˆ—è¡¨ã€‚
- en: As in our `sum_list` function, we will need a variable to store the resulting
    list as we build it up. The following code calls this `zlist`. The code also shows
    how to use `in` to check whether a character is in a string (it also works for
    checking whether an item is in a list) and how to add an element to the end of
    a list (`append`).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬çš„`sum_list`å‡½æ•°ä¸€æ ·ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå˜é‡æ¥å­˜å‚¨æˆ‘ä»¬åœ¨æ„å»ºè¿‡ç¨‹ä¸­å¾—åˆ°çš„åˆ—è¡¨ã€‚ä»¥ä¸‹ä»£ç è°ƒç”¨è¿™ä¸ª`zlist`ã€‚ä»£ç è¿˜å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨`in`æ¥æ£€æŸ¥ä¸€ä¸ªå­—ç¬¦æ˜¯å¦åœ¨å­—ç¬¦ä¸²ä¸­ï¼ˆå®ƒä¹Ÿé€‚ç”¨äºæ£€æŸ¥ä¸€ä¸ªé¡¹ç›®æ˜¯å¦åœ¨åˆ—è¡¨ä¸­ï¼‰ä»¥åŠå¦‚ä½•å°†ä¸€ä¸ªå…ƒç´ æ·»åŠ åˆ°åˆ—è¡¨çš„æœ«å°¾ï¼ˆ`append`ï¼‰ã€‚
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This code follows the structure of `sum_list`, in that we update the value of
    `zlist` using an expression similar to what we would have used in Pyret. For those
    with prior Python experience who would have used `zlist.append` here, hold that
    thought. We will get there in [Mutable Lists](mutable-lists.html).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ®µä»£ç éµå¾ª`sum_list`çš„ç»“æ„ï¼Œå³æˆ‘ä»¬ä½¿ç”¨ç±»ä¼¼äºåœ¨Pyretä¸­ä¼šä½¿ç”¨çš„è¡¨è¾¾å¼æ¥æ›´æ–°`zlist`çš„å€¼ã€‚å¯¹äºé‚£äº›æœ‰å…ˆå‰çš„Pythonç»éªŒï¼Œåœ¨è¿™é‡Œä¼šä½¿ç”¨`zlist.append`çš„äººï¼Œè¯·è®°ä½è¿™ä¸ªæƒ³æ³•ã€‚æˆ‘ä»¬å°†åœ¨[å¯å˜åˆ—è¡¨](mutable-lists.html)ä¸­è¾¾åˆ°é‚£é‡Œã€‚
- en: Exercise
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write tests for `all_z_words`.
  id: totrans-237
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸º`all_z_words`ç¼–å†™æµ‹è¯•ã€‚
- en: Exercise
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a second version of `all_z_words` using `filter`. Be sure to write tests
    for it!
  id: totrans-240
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`filter`ç¼–å†™`all_z_words`çš„ç¬¬äºŒä¸ªç‰ˆæœ¬ã€‚åŠ¡å¿…ä¸ºå…¶ç¼–å†™æµ‹è¯•ï¼
- en: Exercise
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Contrast these two versions and the corresponding tests. Did you notice anything
    interesting?
  id: totrans-243
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¯¹æ¯”è¿™ä¸¤ä¸ªç‰ˆæœ¬åŠå…¶ç›¸åº”çš„æµ‹è¯•ã€‚ä½ æ³¨æ„åˆ°ä»€ä¹ˆæœ‰è¶£çš„åœ°æ–¹äº†å—ï¼Ÿ
- en: '9.1.8.4Â Summary: The List-Processing Template for Python[ğŸ”—](#(part._.Summary__.The_.List-.Processing_.Template_for_.Python)
    "Link to here")'
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.4Â æ€»ç»“ï¼šPythonçš„åˆ—è¡¨å¤„ç†æ¨¡æ¿[ğŸ”—](#(part._.Summary__.The_.List-.Processing_.Template_for_.Python)
    "é“¾æ¥è‡³æ­¤")
- en: 'Just as we had a template for writing list-processing functions in Pyret, there
    is a corresponding template in Python based on `for` loops. As a reminder, that
    pattern is as follow:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬åœ¨Pyretä¸­ç¼–å†™åˆ—è¡¨å¤„ç†å‡½æ•°çš„æ¨¡æ¿ä¸€æ ·ï¼ŒPythonä¸­ä¹Ÿæœ‰ä¸€ä¸ªåŸºäº`for`å¾ªç¯çš„ç›¸åº”æ¨¡æ¿ã€‚ä½œä¸ºæé†’ï¼Œè¯¥æ¨¡å¼å¦‚ä¸‹ï¼š
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Keep this template in mind as you learn to write functions over lists in Python.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å­¦ä¹ å¦‚ä½•åœ¨Pythonä¸­ç¼–å†™åˆ—è¡¨ä¸Šçš„å‡½æ•°æ—¶ï¼Œè¯·è®°ä½è¿™ä¸ªæ¨¡æ¿ã€‚
- en: 9.1.8.5Â `for each` loops in Pyret[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret)
    "Link to here")
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.5Â Pyretä¸­çš„`for each`å¾ªç¯[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret)
    "é“¾æ¥è‡³æ­¤")
- en: This section can be read without reading the rest of this chapter, so if you
    have been directed to it before being introduced to Python, do not worry! While
    the content below mirrors similar constructs that exist in Python, it is introduced
    on its own.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬èŠ‚å¯ä»¥ç‹¬ç«‹é˜…è¯»ï¼Œæ— éœ€é˜…è¯»æœ¬ç« çš„å…¶ä½™éƒ¨åˆ†ï¼Œæ‰€ä»¥å¦‚æœä½ åœ¨ä»‹ç»Pythonä¹‹å‰è¢«å¼•å¯¼åˆ°è¿™é‡Œï¼Œä¸è¦æ‹…å¿ƒï¼è™½ç„¶ä¸‹é¢çš„å†…å®¹ä¸Pythonä¸­å­˜åœ¨çš„ç±»ä¼¼ç»“æ„ç›¸ä¼¼ï¼Œä½†å®ƒæ˜¯åœ¨å…¶è‡ªèº«ä¸­å¼•å…¥çš„ã€‚
- en: 'The previous sections introduced `for` loops in Python, and showed a template
    for processing lists with them. Pyret can do similar, using the following pattern:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: å‰å‡ èŠ‚ä»‹ç»äº†Pythonä¸­çš„`for`å¾ªç¯ï¼Œå¹¶å±•ç¤ºäº†ä½¿ç”¨å®ƒä»¬å¤„ç†åˆ—è¡¨çš„æ¨¡æ¿ã€‚Pyretå¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ¨¡å¼åšç±»ä¼¼çš„äº‹æƒ…ï¼š
- en: '[PRE42]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There are a few new language features used in this example, introduced in the
    following several sections.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªä¾‹å­ä¸­ä½¿ç”¨äº†å‡ ä¸ªæ–°çš„è¯­è¨€ç‰¹æ€§ï¼Œè¿™äº›ç‰¹æ€§å°†åœ¨ä»¥ä¸‹å‡ èŠ‚ä¸­ä»‹ç»ã€‚
- en: 9.1.8.5.1Â Variables that can change[ğŸ”—](#(part._.Variables_that_can_change) "Link
    to here")
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.5.1Â å¯ä»¥æ›´æ”¹çš„å˜é‡[ğŸ”—](#(part._.Variables_that_can_change) "é“¾æ¥è‡³æ­¤")
- en: First, note that we introduce the variable `result` with `var result` â€“ this
    means that it can vary, which is important for the use with `for each`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œè¯·æ³¨æ„ï¼Œæˆ‘ä»¬ä½¿ç”¨`var result`å¼•å…¥å˜é‡`result`â€”â€”è¿™æ„å‘³ç€å®ƒå¯ä»¥å˜åŒ–ï¼Œè¿™å¯¹äºä¸`for each`ä¸€èµ·ä½¿ç”¨å¾ˆé‡è¦ã€‚
- en: 'By default, all variables in the program directory can never be changed. i.e.,
    if I define a variable `x`, I can not redefine it later:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: é»˜è®¤æƒ…å†µä¸‹ï¼Œç¨‹åºç›®å½•ä¸­çš„æ‰€æœ‰å˜é‡éƒ½æ— æ³•æ›´æ”¹ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœæˆ‘å®šä¹‰äº†ä¸€ä¸ªå˜é‡`x`ï¼Œæˆ‘å°±ä¸èƒ½åæ¥é‡æ–°å®šä¹‰å®ƒï¼š
- en: '[PRE43]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If we do want to change (or mutate) a variable in the directory later, we can,
    but we must declare the variable can change â€“ as in, when we define it, rather
    than writing `x = 10`, we must write `var x = 10`. Then, when we want to update
    it, we can do so with the `:=` operator, as is done in the template above.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬ç¡®å®æƒ³åœ¨ä»¥åæ›´æ”¹ï¼ˆæˆ–ä¿®æ”¹ï¼‰ç›®å½•ä¸­çš„å˜é‡ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·åšï¼Œä½†æˆ‘ä»¬å¿…é¡»å£°æ˜å˜é‡å¯ä»¥æ›´æ”¹â€”â€”ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“æˆ‘ä»¬å®šä¹‰å®ƒæ—¶ï¼Œè€Œä¸æ˜¯å†™`x = 10`ï¼Œæˆ‘ä»¬å¿…é¡»å†™`var
    x = 10`ã€‚ç„¶åï¼Œå½“æˆ‘ä»¬æƒ³è¦æ›´æ–°å®ƒæ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨`:=`è¿ç®—ç¬¦ï¼Œå°±åƒä¸Šé¢æ¨¡æ¿ä¸­æ‰€åšçš„é‚£æ ·ã€‚
- en: '[PRE44]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that trying to use `:=` on a variable that was not declared using `var`
    will produce an error, and variables can still only ever be declared once (whether
    with `var x = ...` or `x = ...`).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå°è¯•åœ¨æœªä½¿ç”¨`var`å£°æ˜çš„å˜é‡ä¸Šä½¿ç”¨`:=`ä¼šäº§ç”Ÿé”™è¯¯ï¼Œå¹¶ä¸”å˜é‡ä»ç„¶åªèƒ½å£°æ˜ä¸€æ¬¡ï¼ˆæ— è®ºæ˜¯ä½¿ç”¨`var x = ...`è¿˜æ˜¯`x = ...`ï¼‰ã€‚
- en: 9.1.8.5.2Â block notation[ğŸ”—](#(part._block_notation) "Link to here")
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.5.2Â å—æ³¨é‡Š[ğŸ”—](#(part._block_notation) "é“¾æ¥è‡³æ­¤")
- en: Another new language feature shown in these examples is that since Pyret functions
    by default expect only a single (non-definition) expression, we have to add the
    `block` annotation at the top, indicating that the body of the function is multiple
    expressions, with the final one being what the function evaluates to.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™äº›ç¤ºä¾‹ä¸­å±•ç¤ºçš„å¦ä¸€ä¸ªæ–°è¯­è¨€ç‰¹æ€§æ˜¯ï¼Œç”±äºPyretå‡½æ•°é»˜è®¤åªæœŸæœ›ä¸€ä¸ªï¼ˆéå®šä¹‰ï¼‰è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬å¿…é¡»åœ¨é¡¶éƒ¨æ·»åŠ `block`æ³¨é‡Šï¼Œè¡¨ç¤ºå‡½æ•°ä½“åŒ…å«å¤šä¸ªè¡¨è¾¾å¼ï¼Œå…¶ä¸­æœ€åä¸€ä¸ªè¡¨è¾¾å¼æ˜¯å‡½æ•°è¯„ä¼°åˆ°çš„ç»“æœã€‚
- en: 'As another example, if we tried to write:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºå¦ä¸€ä¸ªä¾‹å­ï¼Œå¦‚æœæˆ‘ä»¬å°è¯•ç¼–å†™ï¼š
- en: '[PRE45]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Pyret would (rightly) error â€“ since the function returns the last expression
    in its body, the `1` will be ignored â€“ and is most likely a mistake! Perhaps the
    goal was to write:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Pyretä¼šï¼ˆæ­£ç¡®åœ°ï¼‰æŠ¥é”™â€”â€”å› ä¸ºå‡½æ•°è¿”å›å…¶ä½“å†…çš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼ï¼Œæ‰€ä»¥`1`å°†è¢«å¿½ç•¥â€”â€”è¿™å¾ˆå¯èƒ½æ˜¯é”™è¯¯ï¼ä¹Ÿè®¸ç›®æ ‡æ˜¯ç¼–å†™ï¼š
- en: '[PRE46]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'However, since a `for each` expression exists only to modify a variable, functions
    that contain them will always have multiple expressions, and so we need to communicate
    to Pyret that this is not a mistake. Adding `block` before the `:` that begins
    the function (or, in general, wrapping any expressions in `block:` and `end`)
    communicates to Pyret that we understand that there are multiple expressions,
    and just want to evaluate to the last one. So, if we truly wanted to write a function
    as our first example, we could do that with:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œç”±äº`for each`è¡¨è¾¾å¼ä»…å­˜åœ¨ä»¥ä¿®æ”¹å˜é‡ï¼ŒåŒ…å«å®ƒä»¬çš„å‡½æ•°å°†å§‹ç»ˆæœ‰å¤šä¸ªè¡¨è¾¾å¼ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦é€šçŸ¥Pyretè¿™ä¸æ˜¯é”™è¯¯ã€‚åœ¨å‡½æ•°å¼€å§‹å¤„çš„å†’å·`:`ä¹‹å‰æ·»åŠ `block`ï¼ˆæˆ–è€…ï¼Œä¸€èˆ¬è€Œè¨€ï¼Œå°†ä»»ä½•è¡¨è¾¾å¼åŒ…è£¹åœ¨`block:`å’Œ`end`ä¸­ï¼‰é€šçŸ¥Pyretæˆ‘ä»¬ç†è§£å­˜åœ¨å¤šä¸ªè¡¨è¾¾å¼ï¼Œæˆ‘ä»¬åªæƒ³è¯„ä¼°åˆ°æœ€åä¸€ä¸ªã€‚æ‰€ä»¥ï¼Œå¦‚æœæˆ‘ä»¬çœŸçš„æƒ³æŒ‰ç…§ç¬¬ä¸€ä¸ªç¤ºä¾‹ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·åšï¼š
- en: '[PRE47]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 9.1.8.5.3Â How `for each` works[ğŸ”—](#(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)
    "Link to here")
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.5.3Â `for each`çš„å·¥ä½œåŸç†[ğŸ”—](#(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)
    "é“¾æ¥è‡³æ­¤")
- en: A `for each` expression runs its body once for each element in the input list,
    adding an entry to the program directory for each element as it goes. It does
    not produce any value directly, so much instead rely on modifying variables (described
    above) to produce a computation.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`for each`è¡¨è¾¾å¼ä¸ºè¾“å…¥åˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ è¿è¡Œå…¶ä¸»ä½“ä¸€æ¬¡ï¼Œåœ¨éå†è¿‡ç¨‹ä¸­ä¸ºæ¯ä¸ªå…ƒç´ æ·»åŠ ä¸€ä¸ªç¨‹åºç›®å½•æ¡ç›®ã€‚å®ƒä¸ä¼šç›´æ¥äº§ç”Ÿä»»ä½•å€¼ï¼Œå› æ­¤æ›´å¤šåœ°ä¾èµ–äºä¿®æ”¹å˜é‡ï¼ˆå¦‚ä¸Šæ‰€è¿°ï¼‰æ¥äº§ç”Ÿè®¡ç®—ã€‚'
- en: 'Consider summing a list of numbers. We could write a function that does this,
    following our pattern, as:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘å¯¹ä¸€ç»„æ•°å­—è¿›è¡Œæ±‚å’Œã€‚æˆ‘ä»¬å¯ä»¥ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥å®Œæˆè¿™ä¸ªä»»åŠ¡ï¼ŒæŒ‰ç…§æˆ‘ä»¬çš„æ¨¡å¼ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE48]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'On the concrete test input `[list: 5, 1, 7, 3]`, the loop runs four times,
    once with `item` set to `5`, then with `item` set to `1`, then with `item` set
    to `7`, and finally with `item` set to `3`.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 'åœ¨å…·ä½“çš„æµ‹è¯•è¾“å…¥`[list: 5, 1, 7, 3]`ä¸Šï¼Œå¾ªç¯è¿è¡Œäº†å››æ¬¡ï¼Œä¸€æ¬¡å°†`item`è®¾ç½®ä¸º`5`ï¼Œç„¶åè®¾ç½®ä¸º`1`ï¼Œç„¶åè®¾ç½®ä¸º`7`ï¼Œæœ€åè®¾ç½®ä¸º`3`ã€‚'
- en: 'The `for each` construct saves us from writing the common code multiple times,
    and also handles the fact that the lists we are processing can be of arbitrary
    length (so we canâ€™t predict how many times to write the common code). Thus, what
    happens is:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`for each`ç»“æ„ä½¿æˆ‘ä»¬å…äºå¤šæ¬¡ç¼–å†™é€šç”¨ä»£ç ï¼Œå¹¶å¤„ç†æˆ‘ä»¬æ­£åœ¨å¤„ç†çš„åˆ—è¡¨å¯ä»¥æ˜¯ä»»æ„é•¿åº¦çš„äº‹å®ï¼ˆå› æ­¤æˆ‘ä»¬æ— æ³•é¢„æµ‹éœ€è¦ç¼–å†™é€šç”¨ä»£ç çš„æ¬¡æ•°ï¼‰ã€‚å› æ­¤ï¼Œå‘ç”Ÿçš„æƒ…å†µæ˜¯ï¼š'
- en: '[PRE49]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 9.1.8.5.4Â Testing and variables that can change[ğŸ”—](#(part._.Testing_and_variables_that_can_change)
    "Link to here")
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.5.4 æµ‹è¯•å’Œå¯å˜å˜é‡[ğŸ”—](#(part._.Testing_and_variables_that_can_change) "é“¾æ¥åˆ°æ­¤å¤„")
- en: We intentionally showed a very particular pattern of using variables that can
    change. While there are other uses (explored in part in [Mutating Variables](mutating-variables.html)),
    a main reason to stay with this particular template is the difficulty in testing
    and correspondingly, understanding, code that uses them in other ways.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ•…æ„å±•ç¤ºäº†ä¸€ç§ç‰¹å®šçš„å˜é‡ä½¿ç”¨æ¨¡å¼ï¼Œè¿™äº›å˜é‡å¯ä»¥æ”¹å˜ã€‚è™½ç„¶è¿˜æœ‰å…¶ä»–ç”¨é€”ï¼ˆéƒ¨åˆ†åœ¨[å¯å˜å˜é‡](mutating-variables.html)ä¸­æ¢è®¨ï¼‰ï¼Œä½†åšæŒä½¿ç”¨è¿™ç§ç‰¹å®šæ¨¡æ¿çš„ä¸»è¦åŸå› åœ¨äºæµ‹è¯•çš„å›°éš¾æ€§ï¼Œç›¸åº”åœ°ï¼Œç†è§£ä½¿ç”¨å®ƒä»¬çš„å…¶ä»–æ–¹å¼çš„ä»£ç ä¹Ÿå¾ˆå›°éš¾ã€‚
- en: In particular, note that the pattern means that we never define a variables
    that can change outside a function, which means it can never be used by different
    functions, or multiple function calls. Each time the function runs, a new variable
    is created, it is modified in the `for each` loop, and then the value is returned,
    and the entry in the program directory is removed.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ç‰¹åˆ«æ³¨æ„ï¼Œè¿™ç§æ¨¡å¼æ„å‘³ç€æˆ‘ä»¬æ°¸è¿œä¸ä¼šåœ¨å‡½æ•°å¤–éƒ¨å®šä¹‰å¯å˜å˜é‡ï¼Œè¿™æ„å‘³ç€å®ƒæ°¸è¿œä¸èƒ½è¢«ä¸åŒçš„å‡½æ•°æˆ–å¤šæ¬¡å‡½æ•°è°ƒç”¨ä½¿ç”¨ã€‚æ¯æ¬¡å‡½æ•°è¿è¡Œæ—¶ï¼Œéƒ½ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„å˜é‡ï¼Œå®ƒåœ¨`for
    each`å¾ªç¯ä¸­è¢«ä¿®æ”¹ï¼Œç„¶åè¿”å›å€¼ï¼Œå¹¶ä¸”ç¨‹åºç›®å½•ä¸­çš„æ¡ç›®è¢«åˆ é™¤ã€‚
- en: 'Consider what happens if we donâ€™t follow our pattern. Letâ€™s say we had the
    following problem:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘å¦‚æœæˆ‘ä»¬ä¸éµå¾ªæ¨¡å¼ä¼šå‘ç”Ÿä»€ä¹ˆã€‚å‡è®¾æˆ‘ä»¬é‡åˆ°äº†ä»¥ä¸‹é—®é¢˜ï¼š
- en: Exercise
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given a list of numbers, return the prefix of the list (i.e., all elements,
    starting from the beginning) that sums to less than 100.
  id: totrans-281
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼Œè¿”å›åˆ—è¡¨çš„å‰ç¼€ï¼ˆå³ä»å¼€å§‹çš„æ‰€æœ‰å…ƒç´ ï¼‰ï¼Œå…¶å’Œå°äº100ã€‚
- en: 'Having learned about mutable variables, but not following the pattern, you
    might come up with code like this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶æˆ‘ä»¬å·²ç»äº†è§£äº†å¯å˜å˜é‡ï¼Œä½†æ²¡æœ‰éµå¾ªæ¨¡å¼ï¼Œä½ å¯èƒ½ä¼šå†™å‡ºè¿™æ ·çš„ä»£ç ï¼š
- en: '[PRE50]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, this might seem reasonable â€“ weâ€™ve used a new construct, `when`, which
    is an `if` expression that has no `else` â€“ this only makes sense to do inside
    of a `for each` block, where we donâ€™t need a value as a result. It is equivalent
    to:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè¿™çœ‹èµ·æ¥å¯èƒ½å¾ˆåˆç†â€”â€”æˆ‘ä»¬ä½¿ç”¨äº†ä¸€ä¸ªæ–°çš„ç»“æ„`when`ï¼Œå®ƒæ˜¯ä¸€ä¸ªæ²¡æœ‰`else`çš„`if`è¡¨è¾¾å¼â€”â€”è¿™åªæœ‰åœ¨`for each`å—å†…éƒ¨æ‰æœ‰æ„ä¹‰ï¼Œåœ¨é‚£é‡Œæˆ‘ä»¬ä¸éœ€è¦ä¸€ä¸ªç»“æœå€¼ã€‚å®ƒç­‰ä»·äºï¼š
- en: '[PRE51]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Where `nothing` is a value that is used in Pyret to indicate that there is no
    particular value of importance.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­`nothing`æ˜¯Pyretä¸­ç”¨æ¥è¡¨ç¤ºæ²¡æœ‰ç‰¹å®šé‡è¦å€¼çš„å€¼ã€‚
- en: But what happens when we use this function?
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†å½“æˆ‘ä»¬ä½¿ç”¨è¿™ä¸ªå‡½æ•°æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆå‘¢ï¼Ÿ
- en: '[PRE52]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The first two tests pass, but the last one doesnâ€™t. Why? If we run the first
    one again, things are even more confusing, i.e., if instead of the above, we ran
    this `check` block:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: å‰ä¸¤ä¸ªæµ‹è¯•é€šè¿‡äº†ï¼Œä½†æœ€åä¸€ä¸ªæ²¡æœ‰é€šè¿‡ã€‚ä¸ºä»€ä¹ˆï¼Ÿå¦‚æœæˆ‘ä»¬å†æ¬¡è¿è¡Œç¬¬ä¸€ä¸ªæµ‹è¯•ï¼Œäº‹æƒ…ä¼šå˜å¾—æ›´åŠ æ··ä¹±ï¼Œå³å¦‚æœæˆ‘ä»¬ä¸æ˜¯è¿è¡Œä¸Šé¢çš„ä»£ç ï¼Œè€Œæ˜¯è¿è¡Œè¿™ä¸ª`check`å—ï¼š
- en: '[PRE53]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now the test that passed at first no longer passes!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æœ€åˆé€šè¿‡æµ‹è¯•çš„æµ‹è¯•ä¸å†é€šè¿‡äº†ï¼
- en: What we are seeing is that since the variable is outside the function, it is
    shared across different calls to the function. It is added to the program directory
    once, and each time we call `prefix-under-100`, the program directory entry is
    changed, but it is never reset.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çœ‹åˆ°çš„æ˜¯ï¼Œç”±äºå˜é‡åœ¨å‡½æ•°å¤–éƒ¨ï¼Œå®ƒåœ¨å‡½æ•°çš„ä¸åŒè°ƒç”¨ä¹‹é—´æ˜¯å…±äº«çš„ã€‚å®ƒåªè¢«æ·»åŠ åˆ°ç¨‹åºç›®å½•ä¸­ä¸€æ¬¡ï¼Œæ¯æ¬¡æˆ‘ä»¬è°ƒç”¨`prefix-under-100`ï¼Œç¨‹åºç›®å½•æ¡ç›®éƒ½ä¼šæ”¹å˜ï¼Œä½†å®ƒæ°¸è¿œä¸ä¼šé‡ç½®ã€‚
- en: Intentionally, all other uses of mutation have been on directory entries that
    were created only for the body of the function, which meant that when the function
    exited, they were removed. But now, we are always modifying the single `count`
    variable. This means that every time we call `prefix-under-100`, it behaves differently,
    because it not only do we have to understand the code in the body of the function,
    we have to know the current value of the count variable, which is not something
    we can figure out by just looking at the code!
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: æ•…æ„ï¼Œæ‰€æœ‰å…¶ä»–å¯¹ç›®å½•æ¡ç›®çš„ä¿®æ”¹éƒ½æ˜¯åœ¨åªä¸ºå‡½æ•°ä½“åˆ›å»ºçš„ç›®å½•æ¡ç›®ä¸Šè¿›è¡Œçš„ï¼Œè¿™æ„å‘³ç€å½“å‡½æ•°é€€å‡ºæ—¶ï¼Œå®ƒä»¬ä¼šè¢«åˆ é™¤ã€‚ä½†ç°åœ¨ï¼Œæˆ‘ä»¬æ€»æ˜¯åœ¨ä¿®æ”¹å•ä¸ª`count`å˜é‡ã€‚è¿™æ„å‘³ç€æ¯æ¬¡æˆ‘ä»¬è°ƒç”¨`prefix-under-100`æ—¶ï¼Œå®ƒçš„è¡Œä¸ºéƒ½ä¸åŒï¼Œå› ä¸ºæˆ‘ä»¬ä¸ä»…å¿…é¡»ç†è§£å‡½æ•°ä½“å†…çš„ä»£ç ï¼Œè¿˜å¿…é¡»çŸ¥é“è®¡æ•°å˜é‡çš„å½“å‰å€¼ï¼Œè€Œè¿™ä¸æ˜¯ä»…é€šè¿‡æŸ¥çœ‹ä»£ç å°±èƒ½å¼„æ¸…æ¥šçš„äº‹æƒ…ï¼
- en: Functions that behave like this are said to have "side effects", and they are
    much harder to test and much harder to understand, and as a result, much more
    likely to have bugs! While the above example is wrong in a relatively straightforward
    way, side effects can cause extremely subtle bugs that only happen when functions
    are called in particular orders â€“ orders that may only arised in very specific
    situations, making them hard to understand or reproduce.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: å…·æœ‰è¿™ç§è¡Œä¸ºçš„å‡½æ•°è¢«ç§°ä¸ºæœ‰â€œå‰¯ä½œç”¨â€ï¼Œå®ƒä»¬å¾ˆéš¾æµ‹è¯•ï¼Œä¹Ÿå¾ˆéš¾ç†è§£ï¼Œå› æ­¤æ›´å®¹æ˜“å‡ºç°é”™è¯¯ï¼è™½ç„¶ä¸Šé¢çš„ä¾‹å­é”™è¯¯çš„æ–¹å¼ç›¸å¯¹ç›´æ¥ï¼Œä½†å‰¯ä½œç”¨å¯èƒ½å¯¼è‡´éå¸¸å¾®å¦™çš„é”™è¯¯ï¼Œè¿™äº›é”™è¯¯åªæœ‰åœ¨ä»¥ç‰¹å®šé¡ºåºè°ƒç”¨å‡½æ•°æ—¶æ‰ä¼šå‘ç”Ÿâ€”â€”è¿™äº›é¡ºåºå¯èƒ½åªåœ¨éå¸¸å…·ä½“çš„æƒ…å†µä¸‹å‡ºç°ï¼Œä½¿å¾—å®ƒä»¬éš¾ä»¥ç†è§£æˆ–é‡ç°ã€‚
- en: While there are some places where doing this is necessary, almost all code can
    be written without side effects, and will be much more reliable. We will explore
    some cases where we might want to do this in [Mutating Variables](mutating-variables.html).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶åœ¨æŸäº›åœ°æ–¹è¿™æ ·åšæ˜¯å¿…è¦çš„ï¼Œä½†å‡ ä¹æ‰€æœ‰ä»£ç éƒ½å¯ä»¥ä¸ä½¿ç”¨å‰¯ä½œç”¨æ¥ç¼–å†™ï¼Œè¿™å°†ä½¿ä»£ç æ›´åŠ å¯é ã€‚æˆ‘ä»¬å°†åœ¨[ä¿®æ”¹å˜é‡](mutating-variables.html)ä¸­æ¢è®¨æˆ‘ä»¬å¯èƒ½æƒ³è¦è¿™æ ·åšçš„ä¸€äº›æƒ…å†µã€‚
- en: 9.1.1Â Expressions, Functions, and Types[ğŸ”—](#(part._.Expressions__.Functions__and_.Types)
    "Link to here")
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1 è¡¨è¾¾å¼ã€å‡½æ•°å’Œç±»å‹[ğŸ”—](#(part._.Expressions__.Functions__and_.Types) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Back in [Functions Practice: Cost of pens](From_Repeated_Expressions_to_Functions.html#%28part._pen-cost-pyret%29),
    we introduced the notation for functions and types using an example of computing
    the cost of an order of pens. An order consisted of a number of pens and a message
    to be printed on the pens. Each pen cost 25 cents, plus 2 cents per character
    for the message. Here was the original Pyret code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨[å‡½æ•°ç»ƒä¹ ï¼šç¬”çš„æˆæœ¬](From_Repeated_Expressions_to_Functions.html#%28part._pen-cost-pyret%29)ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡è®¡ç®—ä¸€ç›’ç¬”çš„æˆæœ¬çš„ä¾‹å­ä»‹ç»äº†å‡½æ•°å’Œç±»å‹çš„ç¬¦å·ã€‚ä¸€ç›’ç¬”åŒ…æ‹¬è‹¥å¹²æ”¯ç¬”å’Œè¦æ‰“å°åœ¨ç¬”ä¸Šçš„ä¿¡æ¯ã€‚æ¯æ”¯ç¬”çš„æˆæœ¬æ˜¯25ç¾åˆ†ï¼ŒåŠ ä¸Šæ¯å­—ç¬¦2ç¾åˆ†çš„æ¶ˆæ¯è´¹ç”¨ã€‚ä»¥ä¸‹æ˜¯åŸå§‹çš„Pyretä»£ç ï¼š
- en: '[PRE54]total cost for pens, each 25 cents'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE54]æ¯æ”¯ç¬”çš„æ€»æˆæœ¬ï¼Œæ¯æ”¯25ç¾åˆ†'
- en: plus 2 cents per message character[PRE55]
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: åŠ ä¸Šæ¯æ¡æ¶ˆæ¯å­—ç¬¦2ç¾åˆ†[PRE55]
- en: 'Hereâ€™s the corresponding Python code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ç›¸åº”çš„Pythonä»£ç ï¼š
- en: '[PRE56]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Do Now!
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What notational differences do you see between the two versions?
  id: totrans-304
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ åœ¨ä¸¤ä¸ªç‰ˆæœ¬ä¹‹é—´çœ‹åˆ°äº†å“ªäº›ç¬¦å·å·®å¼‚ï¼Ÿ
- en: 'Hereâ€™s a summary of the differences:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯å·®å¼‚çš„æ€»ç»“ï¼š
- en: Python uses `def` instead of `fun`.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pythonä½¿ç”¨`def`è€Œä¸æ˜¯`fun`ã€‚
- en: Python uses underscores in names (like `pen_cost`) instead of hyphens as in
    Pyret.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pythonåœ¨åç§°ä¸­ä½¿ç”¨ä¸‹åˆ’çº¿ï¼ˆå¦‚`pen_cost`ï¼‰ï¼Œè€Œä¸æ˜¯åƒPyretä¸­ä½¿ç”¨è¿å­—ç¬¦ã€‚
- en: 'The type names are written differently: Python uses `str` and `int` instead
    of `String` and `Number`. In addition, Python uses only a single colon before
    the type whereas Pyret uses a double colon.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç±»å‹åç§°çš„å†™æ³•ä¸åŒï¼šPythonä½¿ç”¨`str`å’Œ`int`è€Œä¸æ˜¯`String`å’Œ`Number`ã€‚æ­¤å¤–ï¼ŒPythonåœ¨ç±»å‹å‰åªä½¿ç”¨ä¸€ä¸ªå†’å·ï¼Œè€ŒPyretä½¿ç”¨ä¸¤ä¸ªå†’å·ã€‚
- en: 'Python has different types for different kinds of numbers: `int` is for integers,
    while `float` is for decimals. Pyret just used a single type (`Number`) for all
    numbers.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pythonä¸ºä¸åŒç±»å‹çš„æ•°å­—æœ‰ä¸åŒçš„ç±»å‹ï¼š`int`ç”¨äºæ•´æ•°ï¼Œè€Œ`float`ç”¨äºå°æ•°ã€‚Pyretå¯¹æ‰€æœ‰æ•°å­—åªä½¿ç”¨ä¸€ä¸ªç±»å‹ï¼ˆ`Number`ï¼‰ã€‚
- en: Python doesnâ€™t label the documentation string (as Pyret does with `doc:`).
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pythonä¸æ ‡è®°æ–‡æ¡£å­—ç¬¦ä¸²ï¼ˆå¦‚Pyretä½¿ç”¨`doc:`ï¼‰ã€‚
- en: There is no `end` annotation in Python. Instead, Python uses indentation to
    locate the end of an if/else statement, function, or other multi-line construct.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pythonä¸­æ²¡æœ‰`end`æ³¨é‡Šã€‚ç›¸åï¼ŒPythonä½¿ç”¨ç¼©è¿›æ¥å®šä½if/elseè¯­å¥ã€å‡½æ•°æˆ–å…¶ä»–å¤šè¡Œç»“æ„çš„ç»“æŸã€‚
- en: Python labels the outputs of functions with `return`.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pythonä½¿ç”¨`return`æ ‡è®°å‡½æ•°çš„è¾“å‡ºã€‚
- en: These are minor differences in notation, which you will get used to as you write
    more programs in Python.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æ˜¯ç¬¦å·ä¸Šçš„ç»†å¾®å·®å¼‚ï¼Œéšç€ä½ åœ¨Pythonä¸­ç¼–å†™æ›´å¤šç¨‹åºï¼Œä½ ä¼šä¹ æƒ¯è¿™äº›å·®å¼‚ã€‚
- en: There are differences beyond the notational ones. One that arises with this
    sample program arises around how the language uses types. In Pyret, if you put
    a type annotation on a parameter then pass it a value of a different type, youâ€™ll
    get an error message. Python ignores the type annotations (unless you bring in
    additional tools for checking types). Python types are like notes for programmers,
    but they arenâ€™t enforced when programs run.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: é™¤äº†ç¬¦å·ä¸Šçš„å·®å¼‚ä¹‹å¤–ï¼Œè¿˜æœ‰å…¶ä»–å·®å¼‚ã€‚è¿™ä¸ªæ ·æœ¬ç¨‹åºä¸­å‡ºç°çš„å·®å¼‚ä¸è¯­è¨€å¦‚ä½•ä½¿ç”¨ç±»å‹æœ‰å…³ã€‚åœ¨Pyretä¸­ï¼Œå¦‚æœä½ å¯¹ä¸€ä¸ªå‚æ•°æ·»åŠ äº†ç±»å‹æ³¨è§£ï¼Œç„¶åä¼ é€’äº†ä¸€ä¸ªä¸åŒç±»å‹çš„å€¼ï¼Œä½ ä¼šå¾—åˆ°ä¸€ä¸ªé”™è¯¯æ¶ˆæ¯ã€‚Pythonå¿½ç•¥äº†ç±»å‹æ³¨è§£ï¼ˆé™¤éä½ å¼•å…¥äº†é¢å¤–çš„å·¥å…·æ¥æ£€æŸ¥ç±»å‹ï¼‰ã€‚Pythonç±»å‹å°±åƒæ˜¯ç¨‹åºå‘˜çš„ç¬”è®°ï¼Œä½†åœ¨ç¨‹åºè¿è¡Œæ—¶å¹¶ä¸å¼ºåˆ¶æ‰§è¡Œã€‚
- en: Exercise
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Convert the following `moon-weight` function from [Functions Practice: Moon
    Weight](From_Repeated_Expressions_to_Functions.html#%28part._moon-weight-pyret%29)
    into Python:'
  id: totrans-317
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°†ä»¥ä¸‹`moon-weight`å‡½æ•°ä»[å‡½æ•°ç»ƒä¹ ï¼šæœˆçƒé‡é‡](From_Repeated_Expressions_to_Functions.html#%28part._moon-weight-pyret%29)è½¬æ¢ä¸ºPythonï¼š
- en: ''
  id: totrans-318
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-319
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 9.1.2Â Returning Values from Functions[ğŸ”—](#(part._.Returning_.Values_from_.Functions)
    "Link to here")
  id: totrans-320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.2Â ä»å‡½æ•°è¿”å›å€¼[ğŸ”—](#(part._.Returning_.Values_from_.Functions) "é“¾æ¥è‡³æ­¤")
- en: In Pyret, a function body consisted of optional statements to name intermediate
    values, followed by a single expression. The value of that single expression is
    the result of calling the function. In Pyret, every function produces a result,
    so there is no need to label where the result comes from.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Pyretä¸­ï¼Œå‡½æ•°ä½“ç”±å¯é€‰çš„è¯­å¥ç»„æˆï¼Œç”¨äºå‘½åä¸­é—´å€¼ï¼Œç„¶åæ˜¯ä¸€ä¸ªå•ç‹¬çš„è¡¨è¾¾å¼ã€‚è¯¥å•ä¸ªè¡¨è¾¾å¼çš„å€¼æ˜¯è°ƒç”¨å‡½æ•°çš„ç»“æœã€‚åœ¨Pyretä¸­ï¼Œæ¯ä¸ªå‡½æ•°éƒ½ä¼šäº§ç”Ÿä¸€ä¸ªç»“æœï¼Œå› æ­¤ä¸éœ€è¦æ ‡è®°ç»“æœæ¥æºã€‚
- en: 'As we will see, Python is different: not all â€œfunctionsâ€ return results (note
    the name change from `fun` to `def`).In mathematics, functions have results by
    definition. Programmers sometimes distinguish between the terms â€œfunctionâ€ and
    â€œprocedureâ€: both refer to parameterized computations, but only the former returns
    a result to the surrounding computation. Some programmers and languages do, however,
    use the term â€œfunctionâ€ more loosely to cover both kinds of parameterized computations.
    Moreover, the result isnâ€™t necessarily the last expression of the `def`. In Python,
    the keyword `return` explicitly labels the expression whose value serves as the
    result of the function.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬å°†çœ‹åˆ°çš„ï¼ŒPythonæ˜¯ä¸åŒçš„ï¼šå¹¶éæ‰€æœ‰â€œå‡½æ•°â€éƒ½ä¼šè¿”å›ç»“æœï¼ˆæ³¨æ„åç§°ä»`fun`æ›´æ”¹ä¸º`def`ï¼‰ã€‚åœ¨æ•°å­¦ä¸­ï¼Œå‡½æ•°çš„å®šä¹‰å°±æ˜¯æœ‰ç»“æœã€‚ç¨‹åºå‘˜æœ‰æ—¶ä¼šåŒºåˆ†â€œå‡½æ•°â€å’Œâ€œè¿‡ç¨‹â€è¿™ä¸¤ä¸ªæœ¯è¯­ï¼šä¸¤è€…éƒ½æŒ‡å‚æ•°åŒ–è®¡ç®—ï¼Œä½†åªæœ‰å‰è€…ä¼šå‘å‘¨å›´è®¡ç®—è¿”å›ç»“æœã€‚ç„¶è€Œï¼Œä¸€äº›ç¨‹åºå‘˜å’Œè¯­è¨€æ›´å®½æ¾åœ°ä½¿ç”¨â€œå‡½æ•°â€è¿™ä¸ªæœ¯è¯­æ¥æ¶µç›–è¿™ä¸¤ç§å‚æ•°åŒ–è®¡ç®—ã€‚æ­¤å¤–ï¼Œç»“æœä¸ä¸€å®šæ˜¯`def`ä¸­çš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼ã€‚åœ¨Pythonä¸­ï¼Œå…³é”®å­—`return`æ˜ç¡®æ ‡è®°äº†å…¶å€¼ä½œä¸ºå‡½æ•°ç»“æœçš„é‚£ä¸ªè¡¨è¾¾å¼ã€‚
- en: Do Now!
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Put these two definitions in a Python file.
  id: totrans-325
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°†è¿™ä¸¤ä¸ªå®šä¹‰æ”¾å…¥Pythonæ–‡ä»¶ä¸­ã€‚
- en: ''
  id: totrans-326
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-327
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE58]'
- en: ''
  id: totrans-328
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: At the Python prompt, call each function in turn. What do you notice about the
    result from using each function?
  id: totrans-329
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨Pythonæç¤ºç¬¦ä¸‹ï¼Œä¾æ¬¡è°ƒç”¨æ¯ä¸ªå‡½æ•°ã€‚ä½ æ³¨æ„åˆ°ä½¿ç”¨æ¯ä¸ªå‡½æ•°çš„ç»“æœæœ‰ä»€ä¹ˆä¸åŒå—ï¼Ÿ
- en: Hopefully, you noticed that using `add1v1` displays an answer after the prompt,
    while using `add1v2` does not. This difference has consequences for composing
    functions.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: å¸Œæœ›ä½ èƒ½æ³¨æ„åˆ°ï¼Œä½¿ç”¨`add1v1`åœ¨æç¤ºç¬¦åæ˜¾ç¤ºç­”æ¡ˆï¼Œè€Œä½¿ç”¨`add1v2`åˆ™ä¸ä¼šã€‚è¿™ç§å·®å¼‚å¯¹å‡½æ•°çš„ç»„åˆæœ‰å½±å“ã€‚
- en: Do Now!
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Try evaluating the following two expressions at the Python prompt: what happens
    in each case?'
  id: totrans-333
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨Pythonæç¤ºç¬¦ä¸‹å°è¯•è¯„ä¼°ä»¥ä¸‹ä¸¤ä¸ªè¡¨è¾¾å¼ï¼šæ¯ç§æƒ…å†µä¸‹ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
- en: ''
  id: totrans-334
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`3 * add1v1(4)`'
  id: totrans-335
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`3 * add1v1(4)`'
- en: ''
  id: totrans-336
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`3 * add1v2(4)`'
  id: totrans-337
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`3 * add1v2(4)`'
- en: 'This example illustrates why `return` is essential in Python: without it, no
    value is returned, which means you canâ€™t use the result of a function within another
    expression. So what use is `add1v2` then? Hold that question; weâ€™ll return to
    it in [Mutating Variables](mutating-variables.html).'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªä¾‹å­è¯´æ˜äº†ä¸ºä»€ä¹ˆ`return`åœ¨Pythonä¸­æ˜¯å¿…ä¸å¯å°‘çš„ï¼šæ²¡æœ‰å®ƒï¼Œå°±ä¸ä¼šè¿”å›ä»»ä½•å€¼ï¼Œè¿™æ„å‘³ç€ä½ æ— æ³•åœ¨å¦ä¸€ä¸ªè¡¨è¾¾å¼ä¸­ä½¿ç”¨å‡½æ•°çš„ç»“æœã€‚é‚£ä¹ˆ`add1v2`æœ‰ä»€ä¹ˆç”¨å‘¢ï¼Ÿè®°ä½è¿™ä¸ªé—®é¢˜ï¼›æˆ‘ä»¬å°†åœ¨[ä¿®æ”¹å˜é‡](mutating-variables.html)ä¸­å›åˆ°å®ƒã€‚
- en: 9.1.3Â Examples and Test Cases[ğŸ”—](#(part._testing-python) "Link to here")
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.3Â ç¤ºä¾‹å’Œæµ‹è¯•ç”¨ä¾‹[ğŸ”—](#(part._testing-python) "é“¾æ¥è‡³æ­¤")
- en: 'In Pyret, we included examples with every function using `where:` blocks. We
    also had the ability to write `check:` blocks for more extensive tests. As a reminder,
    here was the `pen-cost` code including a `where:` block:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Pyretä¸­ï¼Œæˆ‘ä»¬ä¸ºæ¯ä¸ªå‡½æ•°éƒ½æä¾›äº†ä½¿ç”¨`where:`å—çš„ç¤ºä¾‹ã€‚æˆ‘ä»¬è¿˜æœ‰èƒ½åŠ›ç¼–å†™`check:`å—è¿›è¡Œæ›´å¹¿æ³›çš„æµ‹è¯•ã€‚ä½œä¸ºæé†’ï¼Œä»¥ä¸‹æ˜¯åŒ…å«`where:`å—çš„`pen-cost`ä»£ç ï¼š
- en: '[PRE59]total cost for pens, each 25 cents'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE59]é’¢ç¬”çš„æ€»è´¹ç”¨ï¼Œæ¯æ”¯25ç¾åˆ†'
- en: plus 2 cents per message character[PRE60]
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: æ¯æ¡æ¶ˆæ¯å­—ç¬¦åŠ 2ç¾åˆ†[PRE60]
- en: 'Python does not have a notion of `where:` blocks, or a distinction between
    examples and tests. There are a couple of different testing packages for Python;
    here we will use `pytest`, a standard lightweight framework that resembles the
    form of testing that we did in Pyret.How you set up pytest and your test file
    contents will vary according to your Python IDE. We assume instructors will provide
    separate instructions that align with their tool choices. To use `pytest`, we
    put both examples and tests in a separate function. Hereâ€™s an example of this
    for the `pen_cost` function:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Python æ²¡æœ‰å…³äº `where:` å—çš„æ¦‚å¿µï¼Œä¹Ÿæ²¡æœ‰ç¤ºä¾‹å’Œæµ‹è¯•ä¹‹é—´çš„åŒºåˆ«ã€‚Python æœ‰å‡ ä¸ªä¸åŒçš„æµ‹è¯•åŒ…ï¼›åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ `pytest`ï¼Œè¿™æ˜¯ä¸€ä¸ªæ ‡å‡†çš„è½»é‡çº§æ¡†æ¶ï¼Œç±»ä¼¼äºæˆ‘ä»¬åœ¨
    Pyret ä¸­è¿›è¡Œçš„æµ‹è¯•å½¢å¼ã€‚å¦‚ä½•è®¾ç½® pytest å’Œä½ çš„æµ‹è¯•æ–‡ä»¶å†…å®¹å°†æ ¹æ®ä½ çš„ Python IDE è€Œæœ‰æ‰€ä¸åŒã€‚æˆ‘ä»¬å‡è®¾è®²å¸ˆå°†æä¾›ä¸ä»–ä»¬çš„å·¥å…·é€‰æ‹©ä¸€è‡´çš„å•ç‹¬è¯´æ˜ã€‚ä¸ºäº†ä½¿ç”¨
    `pytest`ï¼Œæˆ‘ä»¬å°†ç¤ºä¾‹å’Œæµ‹è¯•æ”¾åœ¨ä¸€ä¸ªå•ç‹¬çš„å‡½æ•°ä¸­ã€‚ä»¥ä¸‹æ˜¯å¯¹ `pen_cost` å‡½æ•°çš„ç¤ºä¾‹ï¼š
- en: '[PRE61]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Things to note about this code:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: å…³äºæ­¤ä»£ç çš„æ³¨æ„äº‹é¡¹ï¼š
- en: Weâ€™ve imported `pytest`, the lightweight Python testing library.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»å¯¼å…¥äº† `pytest`ï¼Œä¸€ä¸ªè½»é‡çº§çš„ Python æµ‹è¯•åº“ã€‚
- en: The examples have moved into a function (here `test_pens`) that takes no inputs.
    Note that the names of functions that contain test cases must have names that
    start with `test_` in order for `pytest` to find them.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç¤ºä¾‹å·²ç»ç§»åŠ¨åˆ°ä¸€ä¸ªå‡½æ•°ä¸­ï¼ˆè¿™é‡Œ `test_pens`ï¼‰ï¼Œè¯¥å‡½æ•°ä¸æ¥å—ä»»ä½•è¾“å…¥ã€‚è¯·æ³¨æ„ï¼ŒåŒ…å«æµ‹è¯•ç”¨ä¾‹çš„å‡½æ•°åç§°å¿…é¡»ä»¥ `test_` å¼€å¤´ï¼Œä»¥ä¾¿ `pytest`
    èƒ½å¤Ÿæ‰¾åˆ°å®ƒä»¬ã€‚
- en: In Python, individual tests have the form
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨ Python ä¸­ï¼Œå•ä¸ªæµ‹è¯•çš„å½¢å¼å¦‚ä¸‹
- en: '[PRE62]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: rather than the `is` form from Pyret.
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: è€Œä¸æ˜¯ Pyret ä¸­çš„ `is` å½¢å¼ã€‚
- en: Do Now!
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Add one more test to the Python code, corresponding to the Pyret test
  id: totrans-353
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å‘ Python ä»£ç ä¸­æ·»åŠ ä¸€ä¸ªé¢å¤–çš„æµ‹è¯•ï¼Œå¯¹åº”äº Pyret æµ‹è¯•
- en: ''
  id: totrans-354
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-355
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE63]'
- en: ''
  id: totrans-356
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make sure to run the test.
  id: totrans-357
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¡®ä¿è¿è¡Œæµ‹è¯•ã€‚
- en: Do Now!
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did you actually try to run the test?
  id: totrans-360
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ çœŸçš„å°è¯•è¿è¡Œæµ‹è¯•äº†å—ï¼Ÿ
- en: 'Whoa! Something weird happened: the test failed. Stop and think about that:
    the same test that worked in Pyret failed in Python. How can that be?'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: å“‡ï¼å‘ç”Ÿäº†ä¸€äº›å¥‡æ€ªçš„äº‹æƒ…ï¼šæµ‹è¯•å¤±è´¥äº†ã€‚åœä¸‹æ¥æƒ³æƒ³ï¼šåœ¨ Pyret ä¸­è¿è¡Œæ­£å¸¸çš„åŒä¸€ä¸ªæµ‹è¯•åœ¨ Python ä¸­å¤±è´¥äº†ã€‚è¿™æ˜¯æ€ä¹ˆå›äº‹ï¼Ÿ
- en: 9.1.4Â An Aside on Numbers[ğŸ”—](#(part._.An_.Aside_on_.Numbers) "Link to here")
  id: totrans-362
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.4 æ•°å­—çš„è¡¥å……è¯´æ˜[ğŸ”—](#(part._.An_.Aside_on_.Numbers) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'It turns out that different programming languages make different decisions
    about how to represent and manage real (non-integer) numbers. Sometimes, differences
    in these representations lead to subtle quantitative differences in computed values.
    As a simple example, letâ€™s look at two seemingly simple real numbers `1/2` and
    `1/3`. Hereâ€™s what we get when we type these two numbers at a Pyret prompt:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æœè¡¨æ˜ï¼Œä¸åŒçš„ç¼–ç¨‹è¯­è¨€åœ¨è¡¨ç¤ºå’Œç®¡ç†å®æ•°ï¼ˆéæ•´æ•°ï¼‰æ–¹é¢åšå‡ºäº†ä¸åŒçš„å†³å®šã€‚æœ‰æ—¶ï¼Œè¿™äº›è¡¨ç¤ºä¹‹é—´çš„å·®å¼‚ä¼šå¯¼è‡´è®¡ç®—å€¼ä¸­çš„ç»†å¾®æ•°é‡å·®å¼‚ã€‚ä½œä¸ºä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹ä¸¤ä¸ªçœ‹ä¼¼ç®€å•çš„å®æ•°
    `1/2` å’Œ `1/3`ã€‚ä»¥ä¸‹æ˜¯æˆ‘ä»¬åœ¨ Pyret æç¤ºç¬¦ä¸­è¾“å…¥è¿™ä¸¤ä¸ªæ•°å­—æ—¶å¾—åˆ°çš„ç»“æœï¼š
- en: '|'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE64]'
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '&#124;'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE65]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '|'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE66]'
  id: totrans-374
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '&#124;'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE67]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '|'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'If we type these same two numbers in a Python console, we instead get:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬åœ¨ Python æ§åˆ¶å°ä¸­è¾“å…¥è¿™ä¸¤ä¸ªç›¸åŒçš„æ•°å­—ï¼Œæˆ‘ä»¬å¾—åˆ°çš„ç»“æœæ˜¯ï¼š
- en: '|'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE68]'
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '&#124;'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE69]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '|'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE70]'
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '&#124;'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE71]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '|'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Notice that the answers look different for `1/3`. As you may (or may not!) recall
    from an earlier math class, `1/3` is an example of a non-terminating, repeating
    decimal. In plain terms, if we tried to write out the exact value of `1/3` in
    decimal form, we would need to write an infinite sequence of `3`. Mathematicians
    denote this by putting a horizontal bar over the `3`. This is the notation we
    see in Pyret. Python, in contrast, writes out a partial sequence of `3`s.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå¯¹äº `1/3`ï¼Œç­”æ¡ˆçœ‹èµ·æ¥ä¸åŒã€‚ä½ å¯èƒ½ï¼ˆæˆ–è€…å¯èƒ½æ²¡æœ‰ï¼ï¼‰ä»ä¹‹å‰çš„æ•°å­¦è¯¾ä¸­å›å¿†èµ·æ¥ï¼Œ`1/3` æ˜¯ä¸€ä¸ªéç»ˆæ­¢çš„å¾ªç¯å°æ•°çš„ä¾‹å­ã€‚ç®€å•æ¥è¯´ï¼Œå¦‚æœæˆ‘ä»¬è¯•å›¾ç”¨å°æ•°å½¢å¼å†™å‡º
    `1/3` çš„ç¡®åˆ‡å€¼ï¼Œæˆ‘ä»¬éœ€è¦å†™å‡ºæ— é™åºåˆ—çš„ `3`ã€‚æ•°å­¦å®¶é€šè¿‡åœ¨ `3` ä¸Šæ”¾ç½®ä¸€æ¡æ°´å¹³çº¿æ¥è¡¨ç¤ºè¿™ä¸€ç‚¹ã€‚è¿™å°±æ˜¯æˆ‘ä»¬åœ¨ Pyret ä¸­çœ‹åˆ°çš„è¡¨ç¤ºæ³•ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼ŒPython
    ä¼šå†™å‡º `3` çš„éƒ¨åˆ†åºåˆ—ã€‚
- en: 'Underneath this distinction lies some interesting details about representing
    numbers in computers. Computers donâ€™t have infinite space to store numbers (or
    anything else, for that matter): when a program needs to work with a non-terminating
    decimal, the underlying language can either:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªåŒºåˆ«ä¹‹ä¸‹ï¼Œæœ‰ä¸€äº›å…³äºè®¡ç®—æœºä¸­æ•°å­—è¡¨ç¤ºçš„æœ‰è¶£ç»†èŠ‚ã€‚è®¡ç®—æœºæ²¡æœ‰æ— é™çš„ç©ºé—´æ¥å­˜å‚¨æ•°å­—ï¼ˆæˆ–è€…ä»»ä½•å…¶ä»–ä¸œè¥¿ï¼‰ï¼šå½“ç¨‹åºéœ€è¦ä¸éç»ˆæ­¢å°æ•°ä¸€èµ·å·¥ä½œæ—¶ï¼Œåº•å±‚è¯­è¨€å¯ä»¥é€‰æ‹©ï¼š
- en: approximate the number (by chopping off the infinite sequence of digits at some
    point), then work only with the approximated value going forward, or
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿‘ä¼¼æ•°å­—ï¼ˆé€šè¿‡åœ¨æŸä¸ªç‚¹ä¸Šæˆªæ–­æ— é™åºåˆ—çš„æ•°å­—ï¼‰ï¼Œç„¶ååªä½¿ç”¨è¿‘ä¼¼å€¼ç»§ç»­å·¥ä½œï¼Œæˆ–è€…
- en: store additional information about the number that may enable doing more precise
    computation with it later (though there are always some numbers that cannot be
    represented exactly in finite space).
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å­˜å‚¨å…³äºæ•°å­—çš„é¢å¤–ä¿¡æ¯ï¼Œè¿™å¯èƒ½å…è®¸æˆ‘ä»¬åœ¨ä»¥åç”¨å®ƒè¿›è¡Œæ›´ç²¾ç¡®çš„è®¡ç®—ï¼ˆå°½ç®¡æ€»æœ‰ä¸€äº›æ•°å­—åœ¨æœ‰é™ç©ºé—´ä¸­æ— æ³•ç²¾ç¡®è¡¨ç¤ºï¼‰ã€‚
- en: Python takes the first approach. As a result, computations with the approximated
    values sometimes yield approximated results. This is what happens with our new
    `pen_cost` test case. While mathematically, the computation should result in `0.93`,
    the approximations yield `0.9299999999999999` instead.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: Python é‡‡ç”¨ç¬¬ä¸€ç§æ–¹æ³•ã€‚å› æ­¤ï¼Œä½¿ç”¨è¿‘ä¼¼å€¼è¿›è¡Œçš„è®¡ç®—æœ‰æ—¶ä¼šäº§ç”Ÿè¿‘ä¼¼çš„ç»“æœã€‚è¿™å°±æ˜¯æˆ‘ä»¬æ–°çš„ `pen_cost` æµ‹è¯•ç”¨ä¾‹å‘ç”Ÿçš„æƒ…å†µã€‚è™½ç„¶ä»æ•°å­¦ä¸Šè®²ï¼Œè®¡ç®—åº”è¯¥å¾—åˆ°
    `0.93`ï¼Œä½†è¿‘ä¼¼å€¼å´å¾—åˆ°äº† `0.9299999999999999`ã€‚
- en: 'So how do we write tests in this situation? We need to tell Python that the
    answer should be â€œcloseâ€ to `0.93`, within the error range of approximations.
    Hereâ€™s what that looks like:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆï¼Œæˆ‘ä»¬å¦‚ä½•åœ¨è¿™ç§æƒ…å†µå†™ä¸‹æµ‹è¯•ï¼Ÿæˆ‘ä»¬éœ€è¦å‘Šè¯‰ Pythonï¼Œç­”æ¡ˆåº”è¯¥æ˜¯â€œæ¥è¿‘â€ `0.93`ï¼Œåœ¨è¿‘ä¼¼çš„è¯¯å·®èŒƒå›´å†…ã€‚ä¸‹é¢æ˜¯è¿™ä¸ªæ ·å­çš„ï¼š
- en: '[PRE72]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We wrapped the exact answer we wanted in `pytest.approx`, to indicate that weâ€™ll
    accept any answer that is nearly the value we specified. You can control the number
    of decimal points of precision if you want to, but the default of `Â± 2.3e-06`
    often suffices.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç”¨ `pytest.approx` å°†æˆ‘ä»¬æƒ³è¦çš„ç²¾ç¡®ç­”æ¡ˆåŒ…è£…èµ·æ¥ï¼Œä»¥è¡¨æ˜æˆ‘ä»¬å°†æ¥å—ä»»ä½•æ¥è¿‘æˆ‘ä»¬æŒ‡å®šå€¼çš„ç­”æ¡ˆã€‚å¦‚æœä½ æƒ³æ§åˆ¶å°æ•°ç‚¹çš„ç²¾åº¦ä½æ•°ï¼Œä½ å¯ä»¥è¿™æ ·åšï¼Œä½†é»˜è®¤çš„
    `Â± 2.3e-06` é€šå¸¸è¶³å¤Ÿäº†ã€‚
- en: 9.1.5Â Conditionals[ğŸ”—](#(part._conditionals-python) "Link to here")
  id: totrans-405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.5 æ¡ä»¶è¯­å¥[ğŸ”—](#(part._conditionals-python) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Continuing with our original `pen_cost` example, hereâ€™s the Python version
    of the function that computed shipping costs on an order:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: ç»§ç»­ä½¿ç”¨æˆ‘ä»¬åŸæ¥çš„ `pen_cost` ç¤ºä¾‹ï¼Œä¸‹é¢æ˜¯è®¡ç®—è®¢å•è¿è´¹çš„å‡½æ•°çš„ Python ç‰ˆæœ¬ï¼š
- en: '[PRE73]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The main difference to notice here is that `else if` is written as the single-word
    `elif` in Python. We use `return` to mark the functionâ€™s results in each branch
    of the conditional. Otherwise, the conditional constructs are quite similar across
    the two languages.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œè¦æ³¨æ„çš„ä¸»è¦åŒºåˆ«æ˜¯ï¼ŒPython ä¸­çš„ `else if` å†™ä½œå•è¯ `elif`ã€‚æˆ‘ä»¬ä½¿ç”¨ `return` æ¥æ ‡è®°æ¡ä»¶è¯­å¥æ¯ä¸ªåˆ†æ”¯çš„å‡½æ•°ç»“æœã€‚å¦åˆ™ï¼Œä¸¤ç§è¯­è¨€çš„æ¡ä»¶ç»“æ„ç›¸å½“ç›¸ä¼¼ã€‚
- en: You may have noticed that Python does not require an explicit `end` annotation
    on `if`-expressions or functions. Instead, Python looks at the indentation of
    your code to determine when a construct has ended. For example, in the code sample
    for `pen_cost` and `test_pens`, Python determines that the `pen_cost` function
    has ended because it detects a new definition (for `test_pens`) at the left edge
    of the program text. The same principle holds for ending conditionals.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½å·²ç»æ³¨æ„åˆ°ï¼ŒPython ä¸éœ€è¦åœ¨ `if` è¡¨è¾¾å¼æˆ–å‡½æ•°ä¸Šæ˜¾å¼åœ°ä½¿ç”¨ `end` æ³¨è§£ã€‚ç›¸åï¼ŒPython ä¼šæŸ¥çœ‹ä½ ä»£ç çš„ç¼©è¿›æ¥ç¡®å®šä½•æ—¶ä¸€ä¸ªç»“æ„ç»“æŸã€‚ä¾‹å¦‚ï¼Œåœ¨
    `pen_cost` å’Œ `test_pens` çš„ä»£ç ç¤ºä¾‹ä¸­ï¼ŒPython ç¡®å®šå‡½æ•° `pen_cost` å·²ç»ç»“æŸï¼Œå› ä¸ºå®ƒåœ¨ç¨‹åºæ–‡æœ¬çš„å·¦ä¾§è¾¹ç¼˜æ£€æµ‹åˆ°ä¸€ä¸ªæ–°çš„å®šä¹‰ï¼ˆå¯¹äº
    `test_pens`ï¼‰ã€‚åŒæ ·çš„åŸåˆ™ä¹Ÿé€‚ç”¨äºç»“æŸæ¡ä»¶ã€‚
- en: Weâ€™ll return to this point about indentation, and see more examples, as we work
    more with Python.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬ä¸ Python ä¸€èµ·å·¥ä½œæ—¶ï¼Œæˆ‘ä»¬ä¼šå›åˆ°å…³äºç¼©è¿›çš„è¿™ä¸ªç‚¹ï¼Œå¹¶çœ‹åˆ°æ›´å¤šçš„ä¾‹å­ã€‚
- en: 9.1.6Â Creating and Processing Lists[ğŸ”—](#(part._python-create-process-lists)
    "Link to here")
  id: totrans-411
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.6 åˆ›å»ºå’Œå¤„ç†åˆ—è¡¨[ğŸ”—](#(part._python-create-process-lists) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'As an example of lists, letâ€™s assume weâ€™ve been playing a game that involves
    making words out of a collection of letters. In Pyret, we could have written a
    sample word list as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºä¸€ä¸ªåˆ—è¡¨çš„ä¾‹å­ï¼Œè®©æˆ‘ä»¬å‡è®¾æˆ‘ä»¬ä¸€ç›´åœ¨ç©ä¸€ä¸ªéœ€è¦ç”¨ä¸€ç»„åˆå­—ç‰Œæ¥é€ è¯çš„æ¸¸æˆã€‚åœ¨ Pyret ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·å†™ä¸€ä¸ªæ ·æœ¬å•è¯åˆ—è¡¨ï¼š
- en: '[PRE74]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In Python, this definition would look like:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Python ä¸­ï¼Œè¿™ä¸ªå®šä¹‰çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ï¼š
- en: '[PRE75]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The only difference here is that Python does not use the `list:` label that
    is needed in Pyret.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œçš„å”¯ä¸€åŒºåˆ«æ˜¯ Python ä¸ä½¿ç”¨ Pyret ä¸­éœ€è¦çš„ `list:` æ ‡ç­¾ã€‚
- en: 9.1.6.1Â Filters, Maps, and Friends[ğŸ”—](#(part._.Filters__.Maps__and_.Friends)
    "Link to here")
  id: totrans-417
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.6.1 è¿‡æ»¤å™¨ã€æ˜ å°„å’Œæœ‹å‹ä»¬[ğŸ”—](#(part._.Filters__.Maps__and_.Friends) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'When we first learned about lists in Pyret, we started with common built-in
    functions such as `filter`, `map`, `member` and `length`. We also saw the use
    of `lambda` to help us use some of these functions concisely. These same functions,
    including `lambda`, also exist in Python. Here are some samples (`#` is the comment
    character in Python):'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬æœ€åˆå­¦ä¹  Pyret ä¸­çš„åˆ—è¡¨æ—¶ï¼Œæˆ‘ä»¬ä»å¸¸è§çš„å†…ç½®å‡½æ•°å¼€å§‹ï¼Œå¦‚ `filter`ã€`map`ã€`member` å’Œ `length`ã€‚æˆ‘ä»¬è¿˜çœ‹åˆ°äº†
    `lambda` çš„ä½¿ç”¨ï¼Œå¸®åŠ©æˆ‘ä»¬ç®€æ´åœ°ä½¿ç”¨è¿™äº›å‡½æ•°ã€‚è¿™äº›ç›¸åŒçš„å‡½æ•°ï¼ŒåŒ…æ‹¬ `lambda`ï¼Œä¹Ÿå­˜åœ¨äº Python ä¸­ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›ç¤ºä¾‹ï¼ˆ`#` æ˜¯ Python
    ä¸­çš„æ³¨é‡Šå­—ç¬¦ï¼‰ï¼š
- en: '[PRE76]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Note that you have to wrap calls to `filter` (and `map`) with a use of `list()`.
    Internally, Python has these functions return a type of data that we havenâ€™t yet
    discussed (and donâ€™t need). Using `list` converts the returned data into a list.
    If you omit the `list`, you wonâ€™t be able to chain certain functions together.
    For example, if we tried to compute the length of the result of a `map` without
    first converting to a `list`, weâ€™d get an error:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œä½ å¿…é¡»ä½¿ç”¨`list()`æ¥åŒ…è£…å¯¹`filter`ï¼ˆå’Œ`map`ï¼‰çš„è°ƒç”¨ã€‚å†…éƒ¨ï¼ŒPythonæœ‰è¿™äº›å‡½æ•°è¿”å›ä¸€ç§æˆ‘ä»¬å°šæœªè®¨è®ºï¼ˆä¹Ÿä¸éœ€è¦ï¼‰çš„æ•°æ®ç±»å‹ã€‚ä½¿ç”¨`list`å°†è¿”å›çš„æ•°æ®è½¬æ¢ä¸ºåˆ—è¡¨ã€‚å¦‚æœä½ çœç•¥äº†`list`ï¼Œä½ å°†æ— æ³•é“¾å¼è°ƒç”¨æŸäº›å‡½æ•°ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬è¯•å›¾åœ¨ä¸é¦–å…ˆè½¬æ¢ä¸ºåˆ—è¡¨çš„æƒ…å†µä¸‹è®¡ç®—`map`çš„ç»“æœçš„é•¿åº¦ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä¸€ä¸ªé”™è¯¯ï¼š
- en: '|'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE77]'
  id: totrans-423
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '&#124;'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE78]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '|'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Donâ€™t worry if this error message makes no sense at the moment (we havenâ€™t yet
    learned what an â€œobjectâ€ is). The point is that if you see an error like this
    while using the result of `filter` or `map`, you likely forgot to wrap the result
    in `list`.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸è¦æ‹…å¿ƒè¿™ä¸ªé”™è¯¯ä¿¡æ¯ç°åœ¨æ²¡æœ‰æ„ä¹‰ï¼ˆæˆ‘ä»¬è¿˜æ²¡æœ‰å­¦ä¹ ä»€ä¹ˆæ˜¯â€œå¯¹è±¡â€ï¼‰ã€‚å…³é”®æ˜¯ï¼Œå¦‚æœä½ åœ¨ä½¿ç”¨`filter`æˆ–`map`çš„ç»“æœæ—¶çœ‹åˆ°è¿™æ ·çš„é”™è¯¯ï¼Œä½ å¾ˆå¯èƒ½å¿˜è®°å°†ç»“æœåŒ…è£…åœ¨`list`ä¸­ã€‚
- en: Exercise
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Practice Pythonâ€™s list functions by writing expressions for the following problems.
    Use only the list functions we have shown you so far.
  id: totrans-432
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: é€šè¿‡ç¼–å†™ä»¥ä¸‹é—®é¢˜çš„è¡¨è¾¾å¼æ¥ç»ƒä¹ Pythonçš„åˆ—è¡¨å‡½æ•°ã€‚ä»…ä½¿ç”¨æˆ‘ä»¬è¿„ä»Šä¸ºæ­¢å‘æ‚¨å±•ç¤ºçš„åˆ—è¡¨å‡½æ•°ã€‚
- en: ''
  id: totrans-433
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given a list of numbers, convert it to a list of strings `"pos"`, `"neg"`, `"zero"`,
    based on the sign of each number.
  id: totrans-434
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼Œæ ¹æ®æ¯ä¸ªæ•°å­—çš„ç¬¦å·å°†å…¶è½¬æ¢ä¸ºå­—ç¬¦ä¸²åˆ—è¡¨`"pos"`ã€`"neg"`ã€`"zero"`ã€‚
- en: ''
  id: totrans-435
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-436
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Given a list of strings, is the length of any string equal to 5?
  id: totrans-437
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ï¼Œæ˜¯å¦æœ‰ä»»ä½•å­—ç¬¦ä¸²çš„é•¿åº¦ç­‰äº5ï¼Ÿ
- en: ''
  id: totrans-438
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-439
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Given a list of numbers, produce a list of the even numbers between 10 and 20
    from that list.
  id: totrans-440
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼Œä»è¯¥åˆ—è¡¨ä¸­ç”Ÿæˆä¸€ä¸ªåŒ…å«10åˆ°20ä¹‹é—´å¶æ•°çš„åˆ—è¡¨ã€‚
- en: Weâ€™re intentionally focusing on computations that use Pythonâ€™s built-in functions
    for processing lists, rather than showing you how to write you own (as we did
    with recursion in Pyret). While you can write recursive functions to process lists
    in Pyret, a different style of program is more conventional for that purpose.
    Weâ€™ll look at that in the chapter on [Mutating Variables](mutating-variables.html).
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æœ‰æ„ä¸“æ³¨äºä½¿ç”¨Pythonå†…ç½®å‡½æ•°å¤„ç†åˆ—è¡¨çš„è®¡ç®—ï¼Œè€Œä¸æ˜¯å‘æ‚¨å±•ç¤ºå¦‚ä½•ç¼–å†™è‡ªå·±çš„å‡½æ•°ï¼ˆæ­£å¦‚æˆ‘ä»¬åœ¨Pyretä¸­å¤„ç†é€’å½’æ—¶æ‰€åšçš„ï¼‰ã€‚è™½ç„¶æ‚¨å¯ä»¥åœ¨Pyretä¸­ç¼–å†™é€’å½’å‡½æ•°æ¥å¤„ç†åˆ—è¡¨ï¼Œä½†ç”¨äºæ­¤ç›®çš„çš„ç¼–ç¨‹é£æ ¼æ›´ä¸ºä¼ ç»Ÿã€‚æˆ‘ä»¬å°†åœ¨å…³äº[å¯å˜å˜é‡](mutating-variables.html)çš„ç« èŠ‚ä¸­æ¢è®¨è¿™ä¸€ç‚¹ã€‚
- en: 9.1.6.1Â Filters, Maps, and Friends[ğŸ”—](#(part._.Filters__.Maps__and_.Friends)
    "Link to here")
  id: totrans-442
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.6.1 è¿‡æ»¤å™¨ã€æ˜ å°„å’Œæœ‹å‹ä»¬[ğŸ”—](#(part._.Filters__.Maps__and_.Friends) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'When we first learned about lists in Pyret, we started with common built-in
    functions such as `filter`, `map`, `member` and `length`. We also saw the use
    of `lambda` to help us use some of these functions concisely. These same functions,
    including `lambda`, also exist in Python. Here are some samples (`#` is the comment
    character in Python):'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬æœ€åˆåœ¨Pyretä¸­å­¦ä¹ åˆ—è¡¨æ—¶ï¼Œæˆ‘ä»¬ä»å¸¸è§çš„å†…ç½®å‡½æ•°å¼€å§‹ï¼Œä¾‹å¦‚`filter`ã€`map`ã€`member`å’Œ`length`ã€‚æˆ‘ä»¬è¿˜çœ‹åˆ°äº†`lambda`çš„ä½¿ç”¨ï¼Œå¸®åŠ©æˆ‘ä»¬ç®€æ´åœ°ä½¿ç”¨è¿™äº›å‡½æ•°ã€‚è¿™äº›ç›¸åŒçš„å‡½æ•°ï¼ŒåŒ…æ‹¬`lambda`ï¼Œä¹Ÿå­˜åœ¨äºPythonä¸­ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›ç¤ºä¾‹ï¼ˆ`#`æ˜¯Pythonä¸­çš„æ³¨é‡Šå­—ç¬¦ï¼‰ï¼š
- en: '[PRE79]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Note that you have to wrap calls to `filter` (and `map`) with a use of `list()`.
    Internally, Python has these functions return a type of data that we havenâ€™t yet
    discussed (and donâ€™t need). Using `list` converts the returned data into a list.
    If you omit the `list`, you wonâ€™t be able to chain certain functions together.
    For example, if we tried to compute the length of the result of a `map` without
    first converting to a `list`, weâ€™d get an error:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œä½ å¿…é¡»ä½¿ç”¨`list()`æ¥åŒ…è£…å¯¹`filter`ï¼ˆå’Œ`map`ï¼‰çš„è°ƒç”¨ã€‚Pythonå†…éƒ¨ï¼Œè¿™äº›å‡½æ•°è¿”å›ä¸€ç§æˆ‘ä»¬å°šæœªè®¨è®ºï¼ˆä¹Ÿä¸éœ€è¦ï¼‰çš„æ•°æ®ç±»å‹ã€‚ä½¿ç”¨`list`å°†è¿”å›çš„æ•°æ®è½¬æ¢ä¸ºåˆ—è¡¨ã€‚å¦‚æœä½ çœç•¥äº†`list`ï¼Œä½ å°†æ— æ³•é“¾å¼è°ƒç”¨æŸäº›å‡½æ•°ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬è¯•å›¾åœ¨ä¸é¦–å…ˆè½¬æ¢ä¸ºåˆ—è¡¨çš„æƒ…å†µä¸‹è®¡ç®—`map`çš„ç»“æœçš„é•¿åº¦ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä¸€ä¸ªé”™è¯¯ï¼š
- en: '|'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE80]'
  id: totrans-448
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '&#124;'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE81]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '|'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Donâ€™t worry if this error message makes no sense at the moment (we havenâ€™t yet
    learned what an â€œobjectâ€ is). The point is that if you see an error like this
    while using the result of `filter` or `map`, you likely forgot to wrap the result
    in `list`.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸è¦æ‹…å¿ƒè¿™ä¸ªé”™è¯¯ä¿¡æ¯ç°åœ¨æ²¡æœ‰æ„ä¹‰ï¼ˆæˆ‘ä»¬è¿˜æ²¡æœ‰å­¦ä¹ ä»€ä¹ˆæ˜¯â€œå¯¹è±¡â€ï¼‰ã€‚å…³é”®æ˜¯ï¼Œå¦‚æœä½ åœ¨ä½¿ç”¨`filter`æˆ–`map`çš„ç»“æœæ—¶çœ‹åˆ°è¿™æ ·çš„é”™è¯¯ï¼Œä½ å¾ˆå¯èƒ½å¿˜è®°å°†ç»“æœåŒ…è£…åœ¨`list`ä¸­ã€‚
- en: Exercise
  id: totrans-455
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-456
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Practice Pythonâ€™s list functions by writing expressions for the following problems.
    Use only the list functions we have shown you so far.
  id: totrans-457
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: é€šè¿‡ç¼–å†™ä»¥ä¸‹é—®é¢˜çš„è¡¨è¾¾å¼æ¥ç»ƒä¹ Pythonçš„åˆ—è¡¨å‡½æ•°ã€‚ä»…ä½¿ç”¨æˆ‘ä»¬è¿„ä»Šä¸ºæ­¢å‘æ‚¨å±•ç¤ºçš„åˆ—è¡¨å‡½æ•°ã€‚
- en: ''
  id: totrans-458
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given a list of numbers, convert it to a list of strings `"pos"`, `"neg"`, `"zero"`,
    based on the sign of each number.
  id: totrans-459
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼Œæ ¹æ®æ¯ä¸ªæ•°å­—çš„ç¬¦å·å°†å…¶è½¬æ¢ä¸ºå­—ç¬¦ä¸²åˆ—è¡¨`"pos"`ã€`"neg"`ã€`"zero"`ã€‚
- en: ''
  id: totrans-460
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-461
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Given a list of strings, is the length of any string equal to 5?
  id: totrans-462
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ï¼Œä»»ä½•å­—ç¬¦ä¸²çš„é•¿åº¦æ˜¯å¦ç­‰äº 5ï¼Ÿ
- en: ''
  id: totrans-463
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-464
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Given a list of numbers, produce a list of the even numbers between 10 and 20
    from that list.
  id: totrans-465
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼Œä»è¯¥åˆ—è¡¨ä¸­ç”Ÿæˆä¸€ä¸ªä»‹äº 10 å’Œ 20 ä¹‹é—´çš„å¶æ•°åˆ—è¡¨ã€‚
- en: Weâ€™re intentionally focusing on computations that use Pythonâ€™s built-in functions
    for processing lists, rather than showing you how to write you own (as we did
    with recursion in Pyret). While you can write recursive functions to process lists
    in Pyret, a different style of program is more conventional for that purpose.
    Weâ€™ll look at that in the chapter on [Mutating Variables](mutating-variables.html).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æœ‰æ„ä¸“æ³¨äºä½¿ç”¨ Python çš„å†…ç½®å‡½æ•°å¤„ç†åˆ—è¡¨çš„è®¡ç®—ï¼Œè€Œä¸æ˜¯å‘æ‚¨å±•ç¤ºå¦‚ä½•ç¼–å†™è‡ªå·±çš„å‡½æ•°ï¼ˆå°±åƒæˆ‘ä»¬åœ¨ Pyret ä¸­çš„é€’å½’é‚£æ ·ï¼‰ã€‚è™½ç„¶æ‚¨å¯ä»¥åœ¨ Pyret
    ä¸­ç¼–å†™é€’å½’å‡½æ•°æ¥å¤„ç†åˆ—è¡¨ï¼Œä½†ç”¨äºæ­¤ç›®çš„çš„ç¼–ç¨‹é£æ ¼æ›´ä¼ ç»Ÿã€‚æˆ‘ä»¬å°†åœ¨å…³äº [Mutating Variables](mutating-variables.html)
    çš„ç« èŠ‚ä¸­æ¢è®¨è¿™ä¸€ç‚¹ã€‚
- en: 9.1.7Â Data with Components[ğŸ”—](#(part._python-data-with-components) "Link to
    here")
  id: totrans-467
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.7Â å…·æœ‰ç»„ä»¶çš„æ•°æ®[ğŸ”—](#(part._python-data-with-components) "é“¾æ¥è‡³æ­¤")
- en: 'An analog to a Pyret data definition (without variants) is called a dataclass
    in Python.Those experienced with Python may wonder why we are using dataclasses
    instead of dictionaries or raw classes. Compared to dictionaries, dataclasses
    allow the use of type hints and capture that our data has a fixed collection of
    fields. Compared to raw classes, dataclasses generate a lot of boilerplate code
    that makes them much lighterweight than raw classes. Hereâ€™s an example of a todo-list
    datatype in Pyret and its corresponding Python code:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ Pyret ä¸­çš„æ•°æ®å®šä¹‰ï¼ˆæ²¡æœ‰å˜ä½“ï¼‰ç›¸å¯¹åº”çš„æ˜¯ Python ä¸­çš„ dataclassã€‚é‚£äº›ç†Ÿæ‚‰ Python çš„äººå¯èƒ½ä¼š wonder ä¸ºä»€ä¹ˆæˆ‘ä»¬ä½¿ç”¨
    dataclass è€Œä¸æ˜¯å­—å…¸æˆ–åŸå§‹ç±»ã€‚ä¸å­—å…¸ç›¸æ¯”ï¼Œdataclass å…è®¸ä½¿ç”¨ç±»å‹æç¤ºå¹¶æ•è·æˆ‘ä»¬çš„æ•°æ®å…·æœ‰å›ºå®šå­—æ®µé›†åˆçš„äº‹å®ã€‚ä¸åŸå§‹ç±»ç›¸æ¯”ï¼Œdataclass
    ç”Ÿæˆå¤§é‡çš„æ ·æ¿ä»£ç ï¼Œè¿™ä½¿å¾—å®ƒä»¬æ¯”åŸå§‹ç±»æ›´è½»é‡çº§ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ª Pyret ä¸­çš„ todo-list æ•°æ®ç±»å‹åŠå…¶å¯¹åº”çš„ Python ä»£ç ç¤ºä¾‹ï¼š
- en: '[PRE82]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Things to note:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„äº‹é¡¹ï¼š
- en: There is a single name for the type and the constructor, rather than separate
    names as we had in Pyret.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç±»å‹åŠå…¶æ„é€ å‡½æ•°åªæœ‰ä¸€ä¸ªåç§°ï¼Œè€Œä¸æ˜¯åƒ Pyret ä¸­é‚£æ ·æœ‰å•ç‹¬çš„åç§°ã€‚
- en: There are no commas between field names (but each has to be on its own line
    in Python)
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å­—æ®µåç§°ä¹‹é—´æ²¡æœ‰é€—å·ï¼ˆä½†åœ¨ Python ä¸­æ¯ä¸ªå­—æ®µéƒ½å¿…é¡»å•ç‹¬ä¸€è¡Œï¼‰
- en: There is no way to specify the type of the contents of the list in Python (at
    least, not without using more advance packages for writing types)
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨ Python ä¸­æ— æ³•æŒ‡å®šåˆ—è¡¨å†…å®¹çš„ç±»å‹ï¼ˆè‡³å°‘ï¼Œä¸ä½¿ç”¨æ›´é«˜çº§çš„åŒ…æ¥ç¼–å†™ç±»å‹ï¼‰
- en: The `@dataclass` annotation is needed before `class`.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨ `class` å‰é¢éœ€è¦ `@dataclass` æ³¨è§£ã€‚
- en: Dataclasses donâ€™t support creating datatypes with multiple variants, like we
    did frequently in Pyret. Doing that needs more advanced concepts than we will
    cover in this book.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dataclasses ä¸æ”¯æŒåˆ›å»ºå…·æœ‰å¤šä¸ªå˜ä½“çš„æ•°æ®ç±»å‹ï¼Œå°±åƒæˆ‘ä»¬åœ¨ Pyret ä¸­ç»å¸¸åšçš„é‚£æ ·ã€‚è¿™æ ·åšéœ€è¦æ¯”æœ¬ä¹¦ä¸­å°†è¦æ¶µç›–çš„æ›´é«˜çº§çš„æ¦‚å¿µã€‚
- en: 9.1.7.1Â Accessing Fields within Dataclasses[ğŸ”—](#(part._.Accessing_.Fields_within_.Dataclasses)
    "Link to here")
  id: totrans-477
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.7.1Â åœ¨ Dataclasses ä¸­è®¿é—®å­—æ®µ[ğŸ”—](#(part._.Accessing_.Fields_within_.Dataclasses)
    "é“¾æ¥è‡³æ­¤")
- en: 'In Pyret, we extracted a field from structured data by using a dot (period)
    to â€œdig intoâ€ the datum and access the field. The same notation works in Python:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Pyret ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡ä½¿ç”¨ç‚¹ï¼ˆå¥ç‚¹ï¼‰æ¥â€œæ·±å…¥â€æ•°æ®å¹¶è®¿é—®å­—æ®µæ¥ä»ç»“æ„åŒ–æ•°æ®ä¸­æå–å­—æ®µã€‚ç›¸åŒçš„ç¬¦å·åœ¨ Python ä¸­ä¹Ÿé€‚ç”¨ï¼š
- en: '|'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE84]'
  id: totrans-480
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '|'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE85]'
  id: totrans-484
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '&#124;'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE86]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '|'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 9.1.7.1Â Accessing Fields within Dataclasses[ğŸ”—](#(part._.Accessing_.Fields_within_.Dataclasses)
    "Link to here")
  id: totrans-490
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.7.1Â åœ¨ Dataclasses ä¸­è®¿é—®å­—æ®µ[ğŸ”—](#(part._.Accessing_.Fields_within_.Dataclasses)
    "é“¾æ¥è‡³æ­¤")
- en: 'In Pyret, we extracted a field from structured data by using a dot (period)
    to â€œdig intoâ€ the datum and access the field. The same notation works in Python:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Pyret ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡ä½¿ç”¨ç‚¹ï¼ˆå¥ç‚¹ï¼‰æ¥â€œæ·±å…¥â€æ•°æ®å¹¶è®¿é—®å­—æ®µæ¥ä»ç»“æ„åŒ–æ•°æ®ä¸­æå–å­—æ®µã€‚ç›¸åŒçš„ç¬¦å·åœ¨ Python ä¸­ä¹Ÿé€‚ç”¨ï¼š
- en: '|'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE87]'
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '|'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE88]'
  id: totrans-497
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '&#124;'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE89]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '|'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 9.1.8Â Traversing Lists[ğŸ”—](#(part._python-traverse-lists) "Link to here")
  id: totrans-503
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.8Â éå†åˆ—è¡¨[ğŸ”—](#(part._python-traverse-lists) "é“¾æ¥è‡³æ­¤")
- en: 9.1.8.1Â Introducing `For` Loops[ğŸ”—](#(part._python-for-loops) "Link to here")
  id: totrans-504
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.1Â ä»‹ç» `For` å¾ªç¯[ğŸ”—](#(part._python-for-loops) "é“¾æ¥è‡³æ­¤")
- en: 'In Pyret, we typically write recursive functions to compute summary values
    over lists. As a reminder, hereâ€™s a Pyret function that sums the numbers in a
    list:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Pyret ä¸­ï¼Œæˆ‘ä»¬é€šå¸¸ç¼–å†™é€’å½’å‡½æ•°æ¥è®¡ç®—åˆ—è¡¨ä¸Šçš„æ±‡æ€»å€¼ã€‚ä½œä¸ºæé†’ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ª Pyret å‡½æ•°ï¼Œç”¨äºè®¡ç®—åˆ—è¡¨ä¸­çš„æ•°å­—ä¹‹å’Œï¼š
- en: '[PRE90]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In Python, it is unusual to break a list into its first and rest components
    and process the rest recursively. Instead, we use a construct called a `for` to
    visit each element of a list in turn. Hereâ€™s the form of `for`, using a concrete
    (example) list of odd numbers:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Python ä¸­ï¼Œå°†åˆ—è¡¨åˆ†è§£ä¸ºå…¶é¦–å…ƒç´ å’Œå…¶ä½™éƒ¨åˆ†å¹¶é€’å½’å¤„ç†å…¶ä½™éƒ¨åˆ†æ˜¯ä¸å¸¸è§çš„ã€‚ç›¸åï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªç§°ä¸º `for` çš„ç»“æ„æ¥ä¾æ¬¡è®¿é—®åˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªä½¿ç”¨å…·ä½“ï¼ˆç¤ºä¾‹ï¼‰å¥‡æ•°åˆ—è¡¨çš„
    `for` å½¢å¼ï¼š
- en: '[PRE91]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The name `num` here is of our choosing, just as with the names of parameters
    to a function in Pyret. When a `for` loop evaluates, each item in the list is
    referred to as `num` in turn. Thus, this `for` example is equivalent to writing
    the following:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œä½¿ç”¨çš„ `num` åç§°æ˜¯æˆ‘ä»¬è‡ªå·±é€‰æ‹©çš„ï¼Œå°±åƒ Pyret ä¸­å‡½æ•°å‚æ•°çš„åç§°ä¸€æ ·ã€‚å½“ `for` å¾ªç¯è¯„ä¼°æ—¶ï¼Œåˆ—è¡¨ä¸­çš„æ¯ä¸ªé¡¹ç›®ä¾æ¬¡è¢«ç§°ä¸º `num`ã€‚å› æ­¤ï¼Œè¿™ä¸ª
    `for` ç¤ºä¾‹ç­‰åŒäºç¼–å†™ä»¥ä¸‹å†…å®¹ï¼š
- en: '[PRE92]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The `for` construct saves us from writing the common code multiple times, and
    also handles the fact that the lists we are processing can be of arbitrary length
    (so we canâ€™t predict how many times to write the common code).
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` æ„é€ èŠ‚çœäº†æˆ‘ä»¬å¤šæ¬¡ç¼–å†™å¸¸è§ä»£ç çš„æ—¶é—´ï¼Œå¹¶ä¸”å¤„ç†äº†æˆ‘ä»¬æ­£åœ¨å¤„ç†çš„åˆ—è¡¨å¯ä»¥å…·æœ‰ä»»æ„é•¿åº¦çš„äº‹å®ï¼ˆå› æ­¤æˆ‘ä»¬æ— æ³•é¢„æµ‹éœ€è¦ç¼–å†™å¤šå°‘æ¬¡å¸¸è§ä»£ç ï¼‰ã€‚'
- en: 'Letâ€™s now use `for` to compute the running sum of a list. Weâ€™ll start by figuring
    out the repeated computation with our concrete list again. At first, letâ€™s express
    the repeated computation just in prose. In Pyret, our repeated computation was
    along the lines of â€œadd the first item to the sum of the rest of the itemsâ€. Weâ€™ve
    already said that we cannot easily access the â€œrest of the itemsâ€ in Python, so
    we need to rephrase this. Hereâ€™s an alternative:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬ä½¿ç”¨ `for` æ¥è®¡ç®—åˆ—è¡¨çš„ç´¯è®¡æ€»å’Œã€‚æˆ‘ä»¬é¦–å…ˆå†æ¬¡ç¡®å®šæˆ‘ä»¬çš„å…·ä½“åˆ—è¡¨ä¸­çš„é‡å¤è®¡ç®—ã€‚èµ·åˆï¼Œè®©æˆ‘ä»¬åªç”¨æ–‡å­—è¡¨è¾¾é‡å¤çš„è®¡ç®—ã€‚åœ¨ Pyret ä¸­ï¼Œæˆ‘ä»¬çš„é‡å¤è®¡ç®—æ˜¯è¿™æ ·çš„ï¼šâ€œå°†ç¬¬ä¸€ä¸ªå…ƒç´ æ·»åŠ åˆ°å…¶ä½™å…ƒç´ çš„æ€»å’Œâ€ã€‚æˆ‘ä»¬å·²ç»è¯´è¿‡ï¼Œåœ¨
    Python ä¸­æˆ‘ä»¬æ— æ³•è½»æ¾è®¿é—®â€œå…¶ä½™çš„å…ƒç´ â€ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦é‡æ–°è¡¨è¿°ã€‚è¿™é‡Œæœ‰ä¸€ä¸ªæ›¿ä»£æ–¹æ¡ˆï¼š
- en: '[PRE93]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Note that this framing refers not to the â€œrest of the computationâ€, but rather
    to the computation that has happened so far (the â€œrunning totalâ€). If you happened
    to work through the chapter on [`my-running-sum`: Examples and Code](processing-lists.html#%28part._running-sum-eg-code%29),
    this framing might be familiar.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ³¨æ„ï¼Œè¿™ä¸ªæ¡†æ¶æŒ‡çš„æ˜¯â€œå‰©ä½™çš„è®¡ç®—â€ï¼Œè€Œä¸æ˜¯åˆ°ç›®å‰ä¸ºæ­¢å·²ç»å‘ç”Ÿçš„è®¡ç®—ï¼ˆå³â€œç´¯è®¡æ€»å’Œâ€ï¼‰ã€‚å¦‚æœä½ æ°å¥½å·²ç»é˜…è¯»äº†å…³äº[`my-running-sum`: ç¤ºä¾‹å’Œä»£ç ](processing-lists.html#%28part._running-sum-eg-code%29)çš„ç« èŠ‚ï¼Œè¿™ä¸ªæ¡†æ¶å¯èƒ½å¾ˆç†Ÿæ‚‰ã€‚'
- en: Letâ€™s convert this prose sketch to code by replacing each line of the sketch
    with concrete code. We do this by setting up a variable named `run_total` and
    updating its value for each element.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å°†è¿™ä¸ªæ–‡å­—è‰å›¾è½¬æ¢ä¸ºä»£ç ï¼Œé€šè¿‡å°†è‰å›¾ä¸­çš„æ¯ä¸€è¡Œæ›¿æ¢ä¸ºå…·ä½“çš„ä»£ç æ¥å®ç°ã€‚æˆ‘ä»¬è¿™æ ·åšæ˜¯é€šè¿‡è®¾ç½®ä¸€ä¸ªåä¸º `run_total` çš„å˜é‡ï¼Œå¹¶ä¸ºå…¶æ¯ä¸ªå…ƒç´ æ›´æ–°å…¶å€¼ã€‚
- en: '[PRE94]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'This idea that you can give a new value to an existing variable name is something
    we havenâ€™t seen before. In fact, when we first saw how to name values (in [The
    Program Directory](Naming_Values.html#%28part._program-directory%29)), we explicitly
    said that Pyret doesnâ€™t let you do this (at least, not with the constructs that
    we showed you). Python does. Weâ€™ll explore the consequences of this ability in
    more depth shortly (in [Mutating Variables](mutating-variables.html)). For now,
    letâ€™s just use that ability so we can learn the pattern for traversing lists.
    First, letâ€™s collapse the repeated lines of code into a single use of `for`:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§ç»™ç°æœ‰å˜é‡åèµ‹äºˆæ–°å€¼çš„æ€æƒ³æ˜¯æˆ‘ä»¬ä¹‹å‰æ²¡æœ‰è§è¿‡çš„ã€‚å®é™…ä¸Šï¼Œå½“æˆ‘ä»¬ç¬¬ä¸€æ¬¡çœ‹åˆ°å¦‚ä½•å‘½åå€¼ï¼ˆåœ¨[ç¨‹åºç›®å½•](Naming_Values.html#%28part._program-directory%29)ä¸­ï¼‰æ—¶ï¼Œæˆ‘ä»¬æ˜ç¡®è¡¨ç¤º
    Pyret ä¸å…è®¸è¿™æ ·åšï¼ˆè‡³å°‘ï¼Œä¸æ˜¯ç”¨æˆ‘ä»¬å‘æ‚¨å±•ç¤ºçš„æ„é€ ï¼‰ã€‚Python å¯ä»¥ã€‚æˆ‘ä»¬å°†åœ¨ç¨åæ›´æ·±å…¥åœ°æ¢è®¨è¿™ç§èƒ½åŠ›å¸¦æ¥çš„åæœï¼ˆåœ¨[å˜é‡ä¿®æ”¹](mutating-variables.html)ä¸­ï¼‰ã€‚ç°åœ¨ï¼Œè®©æˆ‘ä»¬åªä½¿ç”¨è¿™ç§èƒ½åŠ›ï¼Œè¿™æ ·æˆ‘ä»¬å¯ä»¥å­¦ä¹ éå†åˆ—è¡¨çš„æ¨¡å¼ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬å°†é‡å¤çš„ä»£ç è¡Œåˆå¹¶ä¸ºå•ä¸ª
    `for` çš„ä½¿ç”¨ï¼š
- en: '[PRE95]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This code works fine for a specific list, but our Pyret version took the list
    to sum as a parameter to a function. To achieve this in Python, we wrap the `for`
    in a function as we have done for other examples earlier in this chapter. This
    is the final version.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ®µä»£ç å¯¹äºç‰¹å®šçš„åˆ—è¡¨æ¥è¯´å·¥ä½œå¾—å¾ˆå¥½ï¼Œä½†æˆ‘ä»¬çš„ Pyret ç‰ˆæœ¬å°†æ±‚å’Œçš„åˆ—è¡¨ä½œä¸ºå‡½æ•°çš„å‚æ•°ã€‚è¦åœ¨ Python ä¸­å®ç°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦åƒæœ¬ç« å‰é¢å…¶ä»–ç¤ºä¾‹ä¸­é‚£æ ·å°†
    `for` åŒ…è£¹åœ¨å‡½æ•°ä¸­ã€‚è¿™æ˜¯æœ€ç»ˆç‰ˆæœ¬ã€‚
- en: '[PRE96]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Do Now!
  id: totrans-521
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-522
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a set of tests for `sum_list` (the Python version).
  id: totrans-523
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸º `sum_list`ï¼ˆPython ç‰ˆæœ¬ï¼‰ç¼–å†™ä¸€ç»„æµ‹è¯•ã€‚
- en: 'Now that the Python version is done, letâ€™s compare it to the original Pyret
    version:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨Pythonç‰ˆæœ¬å·²å®Œæˆï¼Œè®©æˆ‘ä»¬å°†å…¶ä¸åŸå§‹Pyretç‰ˆæœ¬è¿›è¡Œæ¯”è¾ƒï¼š
- en: '[PRE97]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Here are some things to notice about the two pieces of code:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯å…³äºè¿™ä¸¤æ®µä»£ç éœ€è¦æ³¨æ„çš„ä¸€äº›äº‹é¡¹ï¼š
- en: The Python version needs a variable (here `run_total`) to hold the result of
    the computation as we build it up while traversing (working through) the list.
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python ç‰ˆæœ¬éœ€è¦ä¸€ä¸ªå˜é‡ï¼ˆè¿™é‡Œä¸º `run_total`ï¼‰æ¥å­˜å‚¨æˆ‘ä»¬åœ¨éå†ï¼ˆå¤„ç†ï¼‰åˆ—è¡¨æ—¶é€æ­¥æ„å»ºçš„è®¡ç®—ç»“æœã€‚
- en: The initial value of that variable is the answer we returned in the `empty`
    case in Pyret.
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¯¥å˜é‡çš„åˆå§‹å€¼æ˜¯ Pyret ä¸­åœ¨ `empty` æƒ…å†µä¸‹è¿”å›çš„ç­”æ¡ˆã€‚
- en: The computation in the `link` case of the Pyret function is used to update that
    variable in the body of the `for`.
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pyret å‡½æ•°çš„ `link` æƒ…å†µä¸­çš„è®¡ç®—ç”¨äºåœ¨ `for` çš„ä¸»ä½“ä¸­æ›´æ–°è¯¥å˜é‡ã€‚
- en: After the `for` has finished processing all items in the list, the Python version
    returns the value in the variable as the result of the function.
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨ `for` å¾ªç¯å¤„ç†å®Œåˆ—è¡¨ä¸­çš„æ‰€æœ‰é¡¹ç›®åï¼ŒPython ç‰ˆæœ¬å°†å˜é‡ä¸­çš„å€¼ä½œä¸ºå‡½æ•°çš„ç»“æœè¿”å›ã€‚
- en: 9.1.8.2Â An Aside on Order of Processing List Elements[ğŸ”—](#(part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements)
    "Link to here")
  id: totrans-531
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.2Â å…³äºå¤„ç†åˆ—è¡¨å…ƒç´ é¡ºåºçš„æ—ç™½[é“¾æ¥](#(part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements)
    "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Thereâ€™s another subtlety here if we consider how the two programs run: the
    Python version sums the elements from left to right, whereas the Pyret version
    sums them right to left. Concretely, the sequence of values of `run_total` are
    computed as:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœè€ƒè™‘ä¸¤ä¸ªç¨‹åºå¦‚ä½•è¿è¡Œï¼Œè¿™é‡Œè¿˜æœ‰ä¸€ä¸ªç»†å¾®ä¹‹å¤„ï¼šPython ç‰ˆæœ¬ä»å·¦åˆ°å³ç´¯åŠ å…ƒç´ ï¼Œè€Œ Pyret ç‰ˆæœ¬åˆ™æ˜¯ä»å³åˆ°å·¦ç´¯åŠ ã€‚å…·ä½“æ¥è¯´ï¼Œ`run_total`
    çš„å€¼åºåˆ—æ˜¯è¿™æ ·è®¡ç®—çš„ï¼š
- en: '[PRE98]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'In contrast, the Pyret version unrolls as:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸æ¯”ä¹‹ä¸‹ï¼ŒPyret ç‰ˆæœ¬å±•å¼€å¦‚ä¸‹ï¼š
- en: '[PRE99]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: As a reminder, the Pyret version did this because the `+` in the `link` case
    can only reduce to an answer once the sum of the rest of the list has been computed.
    Even though we as humans see the chain of `+` operations in each line of the Pyret
    unrolling, Pyret sees only the expression `fst + sum-list(rst)`, which requires
    the function call to finish before the `+` executes.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºæé†’ï¼ŒPyret ç‰ˆæœ¬è¿™æ ·åšæ˜¯å› ä¸ºåœ¨ `link` æƒ…å†µä¸‹ï¼Œ`+` åªèƒ½åœ¨è®¡ç®—å®Œåˆ—è¡¨å‰©ä½™éƒ¨åˆ†çš„å’Œä¹‹åæ‰èƒ½å¾—åˆ°ç­”æ¡ˆã€‚å°½ç®¡æˆ‘ä»¬äººç±»çœ‹åˆ° Pyret å±•å¼€ä¸­æ¯ä¸€è¡Œçš„
    `+` æ“ä½œé“¾ï¼Œä½† Pyret åªçœ‹åˆ°è¡¨è¾¾å¼ `fst + sum-list(rst)`ï¼Œè¿™è¦æ±‚å‡½æ•°è°ƒç”¨å®Œæˆåå†æ‰§è¡Œ `+`ã€‚
- en: In the case of summing a list, we donâ€™t notice the difference between the two
    versions because the sum is the same whether we compute it left-to-right or right-to-left.
    In other functions we write, this difference may start to matter.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ±‚å’Œåˆ—è¡¨çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¸ä¼šæ³¨æ„åˆ°ä¸¤ä¸ªç‰ˆæœ¬ä¹‹é—´çš„åŒºåˆ«ï¼Œå› ä¸ºæ— è®ºæˆ‘ä»¬æ˜¯å·¦åˆ°å³è¿˜æ˜¯å³åˆ°å·¦è®¡ç®—ï¼Œå’Œéƒ½æ˜¯ç›¸åŒçš„ã€‚åœ¨æˆ‘ä»¬ç¼–å†™çš„å…¶ä»–å‡½æ•°ä¸­ï¼Œè¿™ç§å·®å¼‚å¯èƒ½ä¼šå¼€å§‹å˜å¾—é‡è¦ã€‚
- en: 9.1.8.3Â Using `For` Loops in Functions that Produce Lists[ğŸ”—](#(part._python-funcs-produce-lists)
    "Link to here")
  id: totrans-538
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.3Â åœ¨ç”Ÿæˆåˆ—è¡¨çš„å‡½æ•°ä¸­ä½¿ç”¨ `For` å¾ªç¯[é“¾æ¥](#(part._python-funcs-produce-lists) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Letâ€™s practice using `for` loops on another function that traverses lists, this
    time one that produces a list. Specifically, letâ€™s write a program that takes
    a list of strings and produces a list of words within that list that contain the
    letter `"z"`.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬åœ¨å¦ä¸€ä¸ªå‡½æ•°ä¸Šç»ƒä¹ ä½¿ç”¨ `for` å¾ªç¯ï¼Œè¿™ä¸ªå‡½æ•°éå†åˆ—è¡¨å¹¶ç”Ÿæˆä¸€ä¸ªåˆ—è¡¨ã€‚å…·ä½“æ¥è¯´ï¼Œè®©æˆ‘ä»¬ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œå®ƒæ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ï¼Œå¹¶ç”Ÿæˆä¸€ä¸ªåŒ…å«åˆ—è¡¨ä¸­åŒ…å«å­—æ¯
    `"z"` çš„å•è¯çš„åˆ—è¡¨ã€‚
- en: As in our `sum_list` function, we will need a variable to store the resulting
    list as we build it up. The following code calls this `zlist`. The code also shows
    how to use `in` to check whether a character is in a string (it also works for
    checking whether an item is in a list) and how to add an element to the end of
    a list (`append`).
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬åœ¨ `sum_list` å‡½æ•°ä¸­æ‰€åšçš„é‚£æ ·ï¼Œæˆ‘ä»¬åœ¨æ„å»ºåˆ—è¡¨æ—¶éœ€è¦ä¸€ä¸ªå˜é‡æ¥å­˜å‚¨ç»“æœåˆ—è¡¨ã€‚ä»¥ä¸‹ä»£ç ç§°ä¸º `zlist`ã€‚è¯¥ä»£ç è¿˜å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ `in`
    æ¥æ£€æŸ¥ä¸€ä¸ªå­—ç¬¦æ˜¯å¦åœ¨å­—ç¬¦ä¸²ä¸­ï¼ˆå®ƒä¹Ÿé€‚ç”¨äºæ£€æŸ¥ä¸€ä¸ªå…ƒç´ æ˜¯å¦åœ¨åˆ—è¡¨ä¸­ï¼‰ï¼Œä»¥åŠå¦‚ä½•å°†å…ƒç´ æ·»åŠ åˆ°åˆ—è¡¨çš„æœ«å°¾ï¼ˆ`append`ï¼‰ã€‚
- en: '[PRE100]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This code follows the structure of `sum_list`, in that we update the value of
    `zlist` using an expression similar to what we would have used in Pyret. For those
    with prior Python experience who would have used `zlist.append` here, hold that
    thought. We will get there in [Mutable Lists](mutable-lists.html).
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ®µä»£ç éµå¾ª `sum_list` çš„ç»“æ„ï¼Œå³æˆ‘ä»¬ä½¿ç”¨ç±»ä¼¼äºåœ¨ Pyret ä¸­ä¼šä½¿ç”¨çš„è¡¨è¾¾å¼æ›´æ–° `zlist` çš„å€¼ã€‚å¯¹äºé‚£äº›æœ‰å…ˆå‰çš„ Python
    ç»éªŒå¹¶ä¼šåœ¨æ­¤æ—¶ä½¿ç”¨ `zlist.append` çš„äººæ¥è¯´ï¼Œè¯·è®°ä½è¿™ä¸ªæƒ³æ³•ã€‚æˆ‘ä»¬å°†åœ¨ [å¯å˜åˆ—è¡¨](mutable-lists.html) ä¸­åˆ°è¾¾é‚£é‡Œã€‚
- en: Exercise
  id: totrans-543
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-544
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write tests for `all_z_words`.
  id: totrans-545
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸º `all_z_words` ç¼–å†™æµ‹è¯•ã€‚
- en: Exercise
  id: totrans-546
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-547
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a second version of `all_z_words` using `filter`. Be sure to write tests
    for it!
  id: totrans-548
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ `filter` ç¼–å†™ `all_z_words` çš„ç¬¬äºŒä¸ªç‰ˆæœ¬ã€‚åŠ¡å¿…ä¸ºå…¶ç¼–å†™æµ‹è¯•ï¼
- en: Exercise
  id: totrans-549
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-550
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Contrast these two versions and the corresponding tests. Did you notice anything
    interesting?
  id: totrans-551
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¯¹æ¯”è¿™ä¸¤ä¸ªç‰ˆæœ¬åŠå…¶ç›¸åº”çš„æµ‹è¯•ã€‚ä½ æ³¨æ„åˆ°ä»€ä¹ˆæœ‰è¶£çš„åœ°æ–¹äº†å—ï¼Ÿ
- en: '9.1.8.4Â Summary: The List-Processing Template for Python[ğŸ”—](#(part._.Summary__.The_.List-.Processing_.Template_for_.Python)
    "Link to here")'
  id: totrans-552
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.4Â æ€»ç»“ï¼šPython çš„åˆ—è¡¨å¤„ç†æ¨¡æ¿[é“¾æ¥](#(part._.Summary__.The_.List-.Processing_.Template_for_.Python)
    "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Just as we had a template for writing list-processing functions in Pyret, there
    is a corresponding template in Python based on `for` loops. As a reminder, that
    pattern is as follow:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬åœ¨ Pyret ä¸­ç¼–å†™åˆ—è¡¨å¤„ç†å‡½æ•°æœ‰ä¸€ä¸ªæ¨¡æ¿ä¸€æ ·ï¼ŒPython ä¸­åŸºäº `for` å¾ªç¯ä¹Ÿæœ‰ç›¸åº”çš„æ¨¡æ¿ã€‚ä½œä¸ºæé†’ï¼Œè¯¥æ¨¡å¼å¦‚ä¸‹ï¼š
- en: '[PRE101]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Keep this template in mind as you learn to write functions over lists in Python.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å­¦ä¹ å¦‚ä½•åœ¨ Python ä¸­ç¼–å†™åˆ—è¡¨å‡½æ•°æ—¶ï¼Œè¯·è®°ä½è¿™ä¸ªæ¨¡æ¿ã€‚
- en: 9.1.8.5Â `for each` loops in Pyret[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret)
    "Link to here")
  id: totrans-556
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.5Â `for each` å¾ªç¯åœ¨ Pyret ä¸­çš„ä½¿ç”¨[é“¾æ¥](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret)
    "é“¾æ¥åˆ°æ­¤å¤„")
- en: This section can be read without reading the rest of this chapter, so if you
    have been directed to it before being introduced to Python, do not worry! While
    the content below mirrors similar constructs that exist in Python, it is introduced
    on its own.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬èŠ‚å¯ä»¥ç‹¬ç«‹é˜…è¯»ï¼Œæ— éœ€é˜…è¯»æœ¬ç« çš„å…¶ä½™éƒ¨åˆ†ï¼Œæ‰€ä»¥å¦‚æœä½ åœ¨æ¥è§¦ Python ä¹‹å‰è¢«å¼•å¯¼åˆ°è¿™é‡Œï¼Œè¯·ä¸è¦æ‹…å¿ƒï¼è™½ç„¶ä¸‹é¢çš„å†…å®¹åæ˜ äº† Python ä¸­å­˜åœ¨çš„ç±»ä¼¼ç»“æ„ï¼Œä½†å®ƒæ˜¯ä»¥ç‹¬ç«‹çš„æ–¹å¼å¼•å…¥çš„ã€‚
- en: 'The previous sections introduced `for` loops in Python, and showed a template
    for processing lists with them. Pyret can do similar, using the following pattern:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: å‰å‡ èŠ‚ä»‹ç»äº† Python ä¸­çš„ `for` å¾ªç¯ï¼Œå¹¶å±•ç¤ºäº†ä½¿ç”¨å®ƒä»¬å¤„ç†åˆ—è¡¨çš„æ¨¡æ¿ã€‚Pyret å¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ¨¡å¼åšç±»ä¼¼çš„äº‹æƒ…ï¼š
- en: '[PRE102]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: There are a few new language features used in this example, introduced in the
    following several sections.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬ä¾‹ä¸­ä½¿ç”¨äº†å‡ ä¸ªæ–°çš„è¯­è¨€ç‰¹æ€§ï¼Œè¿™äº›ç‰¹æ€§å°†åœ¨ä»¥ä¸‹å‡ èŠ‚ä¸­ä»‹ç»ã€‚
- en: 9.1.8.5.1Â Variables that can change[ğŸ”—](#(part._.Variables_that_can_change) "Link
    to here")
  id: totrans-561
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.5.1Â å¯å˜çš„å˜é‡[ğŸ”—](#(part._.Variables_that_can_change) "é“¾æ¥è‡³æ­¤")
- en: First, note that we introduce the variable `result` with `var result` â€“ this
    means that it can vary, which is important for the use with `for each`.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œè¯·æ³¨æ„ï¼Œæˆ‘ä»¬ä½¿ç”¨ `var result` å¼•å…¥å˜é‡ `result` â€“ è¿™æ„å‘³ç€å®ƒå¯ä»¥å˜åŒ–ï¼Œè¿™å¯¹äºä¸ `for each` çš„ä½¿ç”¨å¾ˆé‡è¦ã€‚
- en: 'By default, all variables in the program directory can never be changed. i.e.,
    if I define a variable `x`, I can not redefine it later:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: é»˜è®¤æƒ…å†µä¸‹ï¼Œç¨‹åºç›®å½•ä¸­çš„æ‰€æœ‰å˜é‡éƒ½ä¸èƒ½æ›´æ”¹ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœæˆ‘å®šä¹‰äº†ä¸€ä¸ªå˜é‡ `x`ï¼Œæˆ‘å°±ä¸èƒ½åæ¥é‡æ–°å®šä¹‰å®ƒï¼š
- en: '[PRE103]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: If we do want to change (or mutate) a variable in the directory later, we can,
    but we must declare the variable can change â€“ as in, when we define it, rather
    than writing `x = 10`, we must write `var x = 10`. Then, when we want to update
    it, we can do so with the `:=` operator, as is done in the template above.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æƒ³åœ¨ä»¥åæ›´æ”¹ï¼ˆæˆ–ä¿®æ”¹ï¼‰ç›®å½•ä¸­çš„å˜é‡ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·åšï¼Œä½†æˆ‘ä»¬å¿…é¡»å£°æ˜å˜é‡å¯ä»¥æ›´æ”¹ â€“ ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“æˆ‘ä»¬å®šä¹‰å®ƒæ—¶ï¼Œè€Œä¸æ˜¯å†™ `x = 10`ï¼Œæˆ‘ä»¬å¿…é¡»å†™
    `var x = 10`ã€‚ç„¶åï¼Œå½“æˆ‘ä»¬æƒ³è¦æ›´æ–°å®ƒæ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `:=` æ“ä½œç¬¦ï¼Œå°±åƒä¸Šé¢æ¨¡æ¿ä¸­æ‰€åšçš„é‚£æ ·ã€‚
- en: '[PRE104]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Note that trying to use `:=` on a variable that was not declared using `var`
    will produce an error, and variables can still only ever be declared once (whether
    with `var x = ...` or `x = ...`).
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå°è¯•åœ¨æœªä½¿ç”¨ `var` å£°æ˜çš„å˜é‡ä¸Šä½¿ç”¨ `:=` ä¼šäº§ç”Ÿé”™è¯¯ï¼Œå¹¶ä¸”å˜é‡ä»ç„¶åªèƒ½å£°æ˜ä¸€æ¬¡ï¼ˆæ— è®ºæ˜¯ä½¿ç”¨ `var x = ...` è¿˜æ˜¯ `x =
    ...`ï¼‰ã€‚
- en: 9.1.8.5.2Â block notation[ğŸ”—](#(part._block_notation) "Link to here")
  id: totrans-568
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.5.2Â å—è¡¨ç¤ºæ³•[ğŸ”—](#(part._block_notation) "é“¾æ¥è‡³æ­¤")
- en: Another new language feature shown in these examples is that since Pyret functions
    by default expect only a single (non-definition) expression, we have to add the
    `block` annotation at the top, indicating that the body of the function is multiple
    expressions, with the final one being what the function evaluates to.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™äº›ç¤ºä¾‹ä¸­å±•ç¤ºçš„å¦ä¸€ä¸ªæ–°è¯­è¨€ç‰¹æ€§æ˜¯ï¼Œç”±äº Pyret å‡½æ•°é»˜è®¤åªæœŸæœ›ä¸€ä¸ªï¼ˆéå®šä¹‰ï¼‰è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬å¿…é¡»åœ¨é¡¶éƒ¨æ·»åŠ  `block` æ³¨è§£ï¼Œè¡¨ç¤ºå‡½æ•°çš„ä¸»ä½“æ˜¯å¤šä¸ªè¡¨è¾¾å¼ï¼Œå…¶ä¸­æœ€åä¸€ä¸ªè¡¨è¾¾å¼æ˜¯å‡½æ•°è¯„ä¼°åˆ°çš„ã€‚
- en: 'As another example, if we tried to write:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºå¦ä¸€ä¸ªä¾‹å­ï¼Œå¦‚æœæˆ‘ä»¬å°è¯•ç¼–å†™ï¼š
- en: '[PRE105]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Pyret would (rightly) error â€“ since the function returns the last expression
    in its body, the `1` will be ignored â€“ and is most likely a mistake! Perhaps the
    goal was to write:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret ä¼šï¼ˆæ­£ç¡®åœ°ï¼‰äº§ç”Ÿé”™è¯¯ â€“ å› ä¸ºå‡½æ•°è¿”å›å…¶ä¸»ä½“ä¸­çš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼ï¼Œæ‰€ä»¥ `1` å°†è¢«å¿½ç•¥ â€“ è¿™å¾ˆå¯èƒ½æ˜¯é”™è¯¯ï¼ä¹Ÿè®¸ç›®æ ‡æ˜¯ç¼–å†™ï¼š
- en: '[PRE106]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'However, since a `for each` expression exists only to modify a variable, functions
    that contain them will always have multiple expressions, and so we need to communicate
    to Pyret that this is not a mistake. Adding `block` before the `:` that begins
    the function (or, in general, wrapping any expressions in `block:` and `end`)
    communicates to Pyret that we understand that there are multiple expressions,
    and just want to evaluate to the last one. So, if we truly wanted to write a function
    as our first example, we could do that with:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œç”±äº `for each` è¡¨è¾¾å¼ä»…ç”¨äºä¿®æ”¹å˜é‡ï¼ŒåŒ…å«å®ƒä»¬çš„å‡½æ•°å°†å§‹ç»ˆæœ‰å¤šä¸ªè¡¨è¾¾å¼ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦é€šçŸ¥ Pyret è¿™ä¸æ˜¯ä¸€ä¸ªé”™è¯¯ã€‚åœ¨å‡½æ•°å¼€å§‹å‰çš„
    `:` å‰æ·»åŠ  `block`ï¼ˆæˆ–è€…ï¼Œä¸€èˆ¬è€Œè¨€ï¼Œå°†ä»»ä½•è¡¨è¾¾å¼åŒ…è£¹åœ¨ `block:` å’Œ `end` ä¸­ï¼‰é€šçŸ¥ Pyret æˆ‘ä»¬ç†è§£å­˜åœ¨å¤šä¸ªè¡¨è¾¾å¼ï¼Œæˆ‘ä»¬åªæƒ³è¯„ä¼°æœ€åä¸€ä¸ªã€‚æ‰€ä»¥ï¼Œå¦‚æœæˆ‘ä»¬çœŸçš„æƒ³æŒ‰ç…§ç¬¬ä¸€ä¸ªç¤ºä¾‹ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·åšï¼š
- en: '[PRE107]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 9.1.8.5.3Â How `for each` works[ğŸ”—](#(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)
    "Link to here")
  id: totrans-576
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.5.3Â `for each` çš„å·¥ä½œåŸç†[ğŸ”—](#(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)
    "é“¾æ¥è‡³æ­¤")
- en: A `for each` expression runs its body once for each element in the input list,
    adding an entry to the program directory for each element as it goes. It does
    not produce any value directly, so much instead rely on modifying variables (described
    above) to produce a computation.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '`for each` è¡¨è¾¾å¼å¯¹è¾“å…¥åˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ è¿è¡Œå…¶ä¸»ä½“ä¸€æ¬¡ï¼Œåœ¨éå†è¿‡ç¨‹ä¸­ä¸ºæ¯ä¸ªå…ƒç´ åœ¨ç¨‹åºç›®å½•ä¸­æ·»åŠ ä¸€ä¸ªæ¡ç›®ã€‚å®ƒä¸ä¼šç›´æ¥äº§ç”Ÿä»»ä½•å€¼ï¼Œå› æ­¤æ›´å¤šåœ°ä¾èµ–äºä¿®æ”¹å˜é‡ï¼ˆå¦‚ä¸Šæ‰€è¿°ï¼‰æ¥äº§ç”Ÿè®¡ç®—ã€‚'
- en: 'Consider summing a list of numbers. We could write a function that does this,
    following our pattern, as:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘å¯¹æ•°å­—åˆ—è¡¨æ±‚å’Œã€‚æˆ‘ä»¬å¯ä»¥ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥å®Œæˆè¿™ä¸ªä»»åŠ¡ï¼Œéµå¾ªæˆ‘ä»¬çš„æ¨¡å¼ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE108]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'On the concrete test input `[list: 5, 1, 7, 3]`, the loop runs four times,
    once with `item` set to `5`, then with `item` set to `1`, then with `item` set
    to `7`, and finally with `item` set to `3`.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 'åœ¨å…·ä½“çš„æµ‹è¯•è¾“å…¥`[list: 5, 1, 7, 3]`ä¸Šï¼Œå¾ªç¯è¿è¡Œäº†å››æ¬¡ï¼Œä¸€æ¬¡å°†`item`è®¾ç½®ä¸º`5`ï¼Œç„¶åè®¾ç½®ä¸º`1`ï¼Œæ¥ç€è®¾ç½®ä¸º`7`ï¼Œæœ€åè®¾ç½®ä¸º`3`ã€‚'
- en: 'The `for each` construct saves us from writing the common code multiple times,
    and also handles the fact that the lists we are processing can be of arbitrary
    length (so we canâ€™t predict how many times to write the common code). Thus, what
    happens is:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '`for each`ç»“æ„ä½¿æˆ‘ä»¬å…äºå¤šæ¬¡ç¼–å†™é€šç”¨ä»£ç ï¼Œå¹¶å¤„ç†æˆ‘ä»¬æ­£åœ¨å¤„ç†çš„åˆ—è¡¨å¯ä»¥å…·æœ‰ä»»æ„é•¿åº¦çš„äº‹å®ï¼ˆå› æ­¤æˆ‘ä»¬æ— æ³•é¢„æµ‹éœ€è¦ç¼–å†™é€šç”¨ä»£ç çš„æ¬¡æ•°ï¼‰ã€‚å› æ­¤ï¼Œå‘ç”Ÿçš„æƒ…å†µæ˜¯ï¼š'
- en: '[PRE109]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 9.1.8.5.4Â Testing and variables that can change[ğŸ”—](#(part._.Testing_and_variables_that_can_change)
    "Link to here")
  id: totrans-583
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.5.4 æµ‹è¯•å’Œå¯å˜å˜é‡[ğŸ”—](#(part._.Testing_and_variables_that_can_change) "é“¾æ¥åˆ°æ­¤å¤„")
- en: We intentionally showed a very particular pattern of using variables that can
    change. While there are other uses (explored in part in [Mutating Variables](mutating-variables.html)),
    a main reason to stay with this particular template is the difficulty in testing
    and correspondingly, understanding, code that uses them in other ways.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ•…æ„å±•ç¤ºäº†ä¸€ç§éå¸¸ç‰¹å®šçš„ä½¿ç”¨å¯å˜å˜é‡çš„æ¨¡å¼ã€‚è™½ç„¶è¿˜æœ‰å…¶ä»–ç”¨é€”ï¼ˆåœ¨[å¯å˜å˜é‡](mutating-variables.html)éƒ¨åˆ†ä¸­éƒ¨åˆ†æ¢ç´¢ï¼‰ï¼Œä½†åšæŒè¿™ä¸ªç‰¹å®šæ¨¡æ¿çš„ä¸»è¦åŸå› æ˜¯åœ¨æµ‹è¯•å’Œç†è§£ä½¿ç”¨å®ƒä»¬çš„ä»£ç æ–¹é¢çš„å›°éš¾ã€‚
- en: In particular, note that the pattern means that we never define a variables
    that can change outside a function, which means it can never be used by different
    functions, or multiple function calls. Each time the function runs, a new variable
    is created, it is modified in the `for each` loop, and then the value is returned,
    and the entry in the program directory is removed.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: å°¤å…¶è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™ä¸ªæ¨¡å¼æ„å‘³ç€æˆ‘ä»¬æ°¸è¿œä¸ä¼šå®šä¹‰å¯ä»¥åœ¨å‡½æ•°å¤–éƒ¨æ”¹å˜çš„å˜é‡ï¼Œè¿™æ„å‘³ç€å®ƒæ°¸è¿œä¸èƒ½è¢«ä¸åŒçš„å‡½æ•°æˆ–å¤šä¸ªå‡½æ•°è°ƒç”¨æ‰€ä½¿ç”¨ã€‚æ¯æ¬¡å‡½æ•°è¿è¡Œæ—¶ï¼Œéƒ½ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„å˜é‡ï¼Œå®ƒåœ¨`for
    each`å¾ªç¯ä¸­è¢«ä¿®æ”¹ï¼Œç„¶åè¿”å›å€¼ï¼Œå¹¶ä¸”ç¨‹åºç›®å½•ä¸­çš„æ¡ç›®è¢«ç§»é™¤ã€‚
- en: 'Consider what happens if we donâ€™t follow our pattern. Letâ€™s say we had the
    following problem:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘å¦‚æœæˆ‘ä»¬ä¸éµå¾ªæˆ‘ä»¬çš„æ¨¡å¼ä¼šå‘ç”Ÿä»€ä¹ˆã€‚å‡è®¾æˆ‘ä»¬é‡åˆ°äº†ä»¥ä¸‹é—®é¢˜ï¼š
- en: Exercise
  id: totrans-587
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-588
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given a list of numbers, return the prefix of the list (i.e., all elements,
    starting from the beginning) that sums to less than 100.
  id: totrans-589
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼Œè¿”å›åˆ—è¡¨çš„å‰ç¼€ï¼ˆå³ä»å¼€å§‹çš„æ‰€æœ‰å…ƒç´ ï¼‰ï¼Œå…¶å’Œå°äº100ã€‚
- en: 'Having learned about mutable variables, but not following the pattern, you
    might come up with code like this:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶æˆ‘ä»¬å·²ç»äº†è§£äº†å¯å˜å˜é‡ï¼Œä½†æ²¡æœ‰éµå¾ªè¿™ä¸ªæ¨¡å¼ï¼Œä½ å¯èƒ½ä¼šå†™å‡ºè¿™æ ·çš„ä»£ç ï¼š
- en: '[PRE110]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Now, this might seem reasonable â€“ weâ€™ve used a new construct, `when`, which
    is an `if` expression that has no `else` â€“ this only makes sense to do inside
    of a `for each` block, where we donâ€™t need a value as a result. It is equivalent
    to:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè¿™çœ‹èµ·æ¥å¯èƒ½å¾ˆåˆç†â€”â€”æˆ‘ä»¬ä½¿ç”¨äº†ä¸€ä¸ªæ–°çš„ç»“æ„`when`ï¼Œè¿™æ˜¯ä¸€ä¸ªæ²¡æœ‰`else`çš„`if`è¡¨è¾¾å¼â€”â€”è¿™åªæœ‰åœ¨`for each`å—å†…éƒ¨æ‰æœ‰æ„ä¹‰ï¼Œåœ¨é‚£é‡Œæˆ‘ä»¬ä¸éœ€è¦ç»“æœå€¼ã€‚å®ƒç­‰ä»·äºï¼š
- en: '[PRE111]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Where `nothing` is a value that is used in Pyret to indicate that there is no
    particular value of importance.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­`nothing`æ˜¯Pyretä¸­ç”¨æ¥è¡¨ç¤ºæ²¡æœ‰ç‰¹å®šé‡è¦å€¼çš„å€¼ã€‚
- en: But what happens when we use this function?
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†å½“æˆ‘ä»¬ä½¿ç”¨è¿™ä¸ªå‡½æ•°æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆå‘¢ï¼Ÿ
- en: '[PRE112]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The first two tests pass, but the last one doesnâ€™t. Why? If we run the first
    one again, things are even more confusing, i.e., if instead of the above, we ran
    this `check` block:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: å‰ä¸¤ä¸ªæµ‹è¯•é€šè¿‡äº†ï¼Œä½†æœ€åä¸€ä¸ªæ²¡æœ‰é€šè¿‡ã€‚ä¸ºä»€ä¹ˆï¼Ÿå¦‚æœæˆ‘ä»¬å†æ¬¡è¿è¡Œç¬¬ä¸€ä¸ªæµ‹è¯•ï¼Œäº‹æƒ…ä¼šå˜å¾—æ›´åŠ æ··ä¹±ï¼Œå³å¦‚æœæˆ‘ä»¬ä¸æ˜¯è¿è¡Œä¸Šé¢çš„ä»£ç ï¼Œè€Œæ˜¯è¿è¡Œè¿™ä¸ª`check`å—ï¼š
- en: '[PRE113]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Now the test that passed at first no longer passes!
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æœ€åˆé€šè¿‡çš„æµ‹è¯•ä¸å†é€šè¿‡äº†ï¼
- en: What we are seeing is that since the variable is outside the function, it is
    shared across different calls to the function. It is added to the program directory
    once, and each time we call `prefix-under-100`, the program directory entry is
    changed, but it is never reset.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ‰€çœ‹åˆ°çš„æ˜¯ï¼Œç”±äºå˜é‡ä½äºå‡½æ•°å¤–éƒ¨ï¼Œå®ƒä¼šåœ¨å‡½æ•°çš„ä¸åŒè°ƒç”¨ä¹‹é—´å…±äº«ã€‚å®ƒåªä¼šåœ¨ç¨‹åºç›®å½•ä¸­æ·»åŠ ä¸€æ¬¡ï¼Œæ¯æ¬¡æˆ‘ä»¬è°ƒç”¨`prefix-under-100`æ—¶ï¼Œç¨‹åºç›®å½•æ¡ç›®éƒ½ä¼šæ”¹å˜ï¼Œä½†å®ƒæ°¸è¿œä¸ä¼šé‡ç½®ã€‚
- en: Intentionally, all other uses of mutation have been on directory entries that
    were created only for the body of the function, which meant that when the function
    exited, they were removed. But now, we are always modifying the single `count`
    variable. This means that every time we call `prefix-under-100`, it behaves differently,
    because it not only do we have to understand the code in the body of the function,
    we have to know the current value of the count variable, which is not something
    we can figure out by just looking at the code!
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: æ•…æ„ï¼Œæ‰€æœ‰å…¶ä»–å¯¹ä¿®æ”¹çš„ç”¨æ³•éƒ½ä»…é™äºä¸ºå‡½æ•°ä½“åˆ›å»ºçš„ç›®å½•æ¡ç›®ï¼Œè¿™æ„å‘³ç€å½“å‡½æ•°é€€å‡ºæ—¶ï¼Œå®ƒä»¬ä¼šè¢«åˆ é™¤ã€‚ä½†ç°åœ¨ï¼Œæˆ‘ä»¬æ€»æ˜¯åœ¨ä¿®æ”¹å•ä¸ª `count` å˜é‡ã€‚è¿™æ„å‘³ç€æ¯æ¬¡æˆ‘ä»¬è°ƒç”¨
    `prefix-under-100` æ—¶ï¼Œå®ƒçš„è¡Œä¸ºéƒ½ä¸åŒï¼Œå› ä¸ºæˆ‘ä»¬ä¸ä»…å¿…é¡»ç†è§£å‡½æ•°ä½“å†…çš„ä»£ç ï¼Œè¿˜å¿…é¡»çŸ¥é“è®¡æ•°å˜é‡çš„å½“å‰å€¼ï¼Œè€Œè¿™å¹¶ä¸æ˜¯ä»…é€šè¿‡æŸ¥çœ‹ä»£ç å°±èƒ½å¼„æ¸…æ¥šçš„äº‹æƒ…ï¼
- en: Functions that behave like this are said to have "side effects", and they are
    much harder to test and much harder to understand, and as a result, much more
    likely to have bugs! While the above example is wrong in a relatively straightforward
    way, side effects can cause extremely subtle bugs that only happen when functions
    are called in particular orders â€“ orders that may only arised in very specific
    situations, making them hard to understand or reproduce.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: å…·æœ‰è¿™ç§è¡Œä¸ºçš„å‡½æ•°è¢«ç§°ä¸ºæœ‰â€œå‰¯ä½œç”¨â€ï¼Œå®ƒä»¬æ›´éš¾æµ‹è¯•å’Œæ›´éš¾ç†è§£ï¼Œå› æ­¤æ›´å®¹æ˜“å‡ºç°é”™è¯¯ï¼è™½ç„¶ä¸Šè¿°ç¤ºä¾‹åœ¨ç›¸å¯¹ç›´æ¥çš„æ–¹å¼ä¸Šæ˜¯é”™è¯¯çš„ï¼Œä½†å‰¯ä½œç”¨å¯ä»¥å¯¼è‡´éå¸¸å¾®å¦™çš„é”™è¯¯ï¼Œè¿™äº›é”™è¯¯ä»…åœ¨ä»¥ç‰¹å®šé¡ºåºè°ƒç”¨å‡½æ•°æ—¶æ‰ä¼šå‘ç”Ÿâ€”â€”è¿™äº›é¡ºåºå¯èƒ½åªåœ¨éå¸¸å…·ä½“çš„æƒ…å†µä¸‹å‡ºç°ï¼Œä½¿å¾—å®ƒä»¬éš¾ä»¥ç†è§£æˆ–é‡ç°ã€‚
- en: While there are some places where doing this is necessary, almost all code can
    be written without side effects, and will be much more reliable. We will explore
    some cases where we might want to do this in [Mutating Variables](mutating-variables.html).
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶åœ¨æŸäº›åœ°æ–¹è¿™æ ·åšæ˜¯å¿…è¦çš„ï¼Œä½†å‡ ä¹æ‰€æœ‰çš„ä»£ç éƒ½å¯ä»¥ä¸äº§ç”Ÿå‰¯ä½œç”¨æ¥ç¼–å†™ï¼Œè¿™å°†ä½¿ä»£ç æ›´åŠ å¯é ã€‚æˆ‘ä»¬å°†åœ¨ [ä¿®æ”¹å˜é‡](mutating-variables.html)
    ä¸­æ¢è®¨æˆ‘ä»¬å¯èƒ½æƒ³è¦è¿™æ ·åšçš„ä¸€äº›æƒ…å†µã€‚
- en: 9.1.8.1Â Introducing `For` Loops[ğŸ”—](#(part._python-for-loops) "Link to here")
  id: totrans-604
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.1Â ä»‹ç» `For` å¾ªç¯[ğŸ”—](#(part._python-for-loops) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'In Pyret, we typically write recursive functions to compute summary values
    over lists. As a reminder, hereâ€™s a Pyret function that sums the numbers in a
    list:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Pyret ä¸­ï¼Œæˆ‘ä»¬é€šå¸¸ç¼–å†™é€’å½’å‡½æ•°æ¥è®¡ç®—åˆ—è¡¨ä¸Šçš„æ±‡æ€»å€¼ã€‚ä½œä¸ºæé†’ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ª Pyret å‡½æ•°ï¼Œç”¨äºè®¡ç®—åˆ—è¡¨ä¸­çš„æ•°å­—ä¹‹å’Œï¼š
- en: '[PRE114]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'In Python, it is unusual to break a list into its first and rest components
    and process the rest recursively. Instead, we use a construct called a `for` to
    visit each element of a list in turn. Hereâ€™s the form of `for`, using a concrete
    (example) list of odd numbers:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Python ä¸­ï¼Œå°†åˆ—è¡¨æ‹†åˆ†ä¸ºå…¶é¦–éƒ¨å’Œå…¶ä½™éƒ¨åˆ†å¹¶é€’å½’å¤„ç†å…¶ä½™éƒ¨åˆ†æ˜¯ä¸å¯»å¸¸çš„ã€‚ç›¸åï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªç§°ä¸º `for` çš„æ„é€ æ¥ä¾æ¬¡è®¿é—®åˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªå…·ä½“çš„ï¼ˆç¤ºä¾‹ï¼‰å¥‡æ•°åˆ—è¡¨çš„
    `for` å½¢å¼ï¼š
- en: '[PRE115]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The name `num` here is of our choosing, just as with the names of parameters
    to a function in Pyret. When a `for` loop evaluates, each item in the list is
    referred to as `num` in turn. Thus, this `for` example is equivalent to writing
    the following:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œ`num` è¿™ä¸ªåå­—æ˜¯æˆ‘ä»¬è‡ªå·±é€‰æ‹©çš„ï¼Œå°±åƒåœ¨ Pyret å‡½æ•°ä¸­å‚æ•°çš„åå­—ä¸€æ ·ã€‚å½“ `for` å¾ªç¯æ‰§è¡Œæ—¶ï¼Œåˆ—è¡¨ä¸­çš„æ¯ä¸ªé¡¹ç›®ä¾æ¬¡è¢«ç§°ä¸º `num`ã€‚å› æ­¤ï¼Œè¿™ä¸ª
    `for` ç¤ºä¾‹ç­‰åŒäºä»¥ä¸‹å†™æ³•ï¼š
- en: '[PRE116]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The `for` construct saves us from writing the common code multiple times, and
    also handles the fact that the lists we are processing can be of arbitrary length
    (so we canâ€™t predict how many times to write the common code).
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` æ„é€ ä½¿æˆ‘ä»¬å…äºå¤šæ¬¡ç¼–å†™å¸¸è§ä»£ç ï¼Œå¹¶å¤„ç†æˆ‘ä»¬æ­£åœ¨å¤„ç†çš„åˆ—è¡¨å¯ä»¥æ˜¯ä»»æ„é•¿åº¦çš„äº‹å®ï¼ˆå› æ­¤æˆ‘ä»¬æ— æ³•é¢„æµ‹éœ€è¦ç¼–å†™å¤šå°‘æ¬¡å¸¸è§ä»£ç ï¼‰ã€‚'
- en: 'Letâ€™s now use `for` to compute the running sum of a list. Weâ€™ll start by figuring
    out the repeated computation with our concrete list again. At first, letâ€™s express
    the repeated computation just in prose. In Pyret, our repeated computation was
    along the lines of â€œadd the first item to the sum of the rest of the itemsâ€. Weâ€™ve
    already said that we cannot easily access the â€œrest of the itemsâ€ in Python, so
    we need to rephrase this. Hereâ€™s an alternative:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬ä½¿ç”¨ `for` æ¥è®¡ç®—åˆ—è¡¨çš„ç´¯ç§¯å’Œã€‚æˆ‘ä»¬é¦–å…ˆå°†å†æ¬¡ä½¿ç”¨æˆ‘ä»¬çš„å…·ä½“åˆ—è¡¨æ¥æ‰¾å‡ºé‡å¤çš„è®¡ç®—ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬ç”¨æ•£æ–‡çš„å½¢å¼è¡¨è¾¾é‡å¤çš„è®¡ç®—ã€‚åœ¨ Pyret
    ä¸­ï¼Œæˆ‘ä»¬çš„é‡å¤è®¡ç®—æ˜¯è¿™æ ·çš„ï¼šâ€œå°†ç¬¬ä¸€ä¸ªé¡¹ç›®æ·»åŠ åˆ°å…¶ä½™é¡¹ç›®çš„å’Œä¸­â€ã€‚æˆ‘ä»¬å·²ç»è¯´è¿‡ï¼Œåœ¨ Python ä¸­æˆ‘ä»¬æ— æ³•è½»æ¾è®¿é—®â€œå…¶ä½™çš„é¡¹ç›®â€ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦é‡æ–°è¡¨è¿°ã€‚ä»¥ä¸‹æ˜¯å¦ä¸€ç§è¡¨è¿°æ–¹å¼ï¼š
- en: '[PRE117]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Note that this framing refers not to the â€œrest of the computationâ€, but rather
    to the computation that has happened so far (the â€œrunning totalâ€). If you happened
    to work through the chapter on [`my-running-sum`: Examples and Code](processing-lists.html#%28part._running-sum-eg-code%29),
    this framing might be familiar.'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ³¨æ„ï¼Œè¿™ä¸ªæ¡†æ¶æŒ‡çš„æ˜¯â€œå‰©ä½™çš„è®¡ç®—â€ï¼Œè€Œä¸æ˜¯åˆ°ç›®å‰ä¸ºæ­¢å·²ç»å‘ç”Ÿçš„è®¡ç®—ï¼ˆå³â€œç´¯è®¡æ€»å’Œâ€ï¼‰ã€‚å¦‚æœæ‚¨æ°å¥½å·²ç»å®Œæˆäº†å…³äº[`my-running-sum`: ç¤ºä¾‹å’Œä»£ç ](processing-lists.html#%28part._running-sum-eg-code%29)çš„ç« èŠ‚ï¼Œè¿™ä¸ªæ¡†æ¶å¯èƒ½å¾ˆç†Ÿæ‚‰ã€‚'
- en: Letâ€™s convert this prose sketch to code by replacing each line of the sketch
    with concrete code. We do this by setting up a variable named `run_total` and
    updating its value for each element.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å°†è¿™ä¸ªæ–‡å­—è‰å›¾è½¬æ¢ä¸ºä»£ç ï¼Œé€šè¿‡å°†è‰å›¾ä¸­çš„æ¯ä¸€è¡Œæ›¿æ¢ä¸ºå…·ä½“çš„ä»£ç æ¥å®ç°ã€‚æˆ‘ä»¬é€šè¿‡è®¾ç½®ä¸€ä¸ªåä¸º `run_total` çš„å˜é‡å¹¶æ›´æ–°å…¶å€¼æ¥ä¸ºæ¯ä¸ªå…ƒç´ æ‰§è¡Œæ­¤æ“ä½œã€‚
- en: '[PRE118]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'This idea that you can give a new value to an existing variable name is something
    we havenâ€™t seen before. In fact, when we first saw how to name values (in [The
    Program Directory](Naming_Values.html#%28part._program-directory%29)), we explicitly
    said that Pyret doesnâ€™t let you do this (at least, not with the constructs that
    we showed you). Python does. Weâ€™ll explore the consequences of this ability in
    more depth shortly (in [Mutating Variables](mutating-variables.html)). For now,
    letâ€™s just use that ability so we can learn the pattern for traversing lists.
    First, letâ€™s collapse the repeated lines of code into a single use of `for`:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§ç»™ç°æœ‰å˜é‡åèµ‹äºˆæ–°å€¼çš„æ€æƒ³æ˜¯æˆ‘ä»¬ä¹‹å‰æ²¡æœ‰è§è¿‡çš„ã€‚äº‹å®ä¸Šï¼Œå½“æˆ‘ä»¬ç¬¬ä¸€æ¬¡çœ‹åˆ°å¦‚ä½•å‘½åå€¼ï¼ˆåœ¨[ç¨‹åºç›®å½•](Naming_Values.html#%28part._program-directory%29)ä¸­ï¼‰æ—¶ï¼Œæˆ‘ä»¬æ˜ç¡®è¡¨ç¤º
    Pyret ä¸å…è®¸è¿™æ ·åšï¼ˆè‡³å°‘ï¼Œä¸æ˜¯ç”¨æˆ‘ä»¬å‘æ‚¨å±•ç¤ºçš„æ„é€ ï¼‰ã€‚Python å¯ä»¥ã€‚æˆ‘ä»¬å°†åœ¨ç¨åæ›´æ·±å…¥åœ°æ¢è®¨è¿™ç§èƒ½åŠ›çš„å½±å“ï¼ˆåœ¨[ä¿®æ”¹å˜é‡](mutating-variables.html)ä¸­ï¼‰ã€‚ç°åœ¨ï¼Œè®©æˆ‘ä»¬åªä½¿ç”¨è¿™ç§èƒ½åŠ›ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å­¦ä¹ éå†åˆ—è¡¨çš„æ¨¡å¼ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬å°†é‡å¤çš„ä»£ç è¡Œåˆå¹¶ä¸ºå•ä¸ª
    `for` çš„ä½¿ç”¨ï¼š
- en: '[PRE119]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: This code works fine for a specific list, but our Pyret version took the list
    to sum as a parameter to a function. To achieve this in Python, we wrap the `for`
    in a function as we have done for other examples earlier in this chapter. This
    is the final version.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ®µä»£ç å¯¹äºç‰¹å®šçš„åˆ—è¡¨æ¥è¯´å·¥ä½œå¾—å¾ˆå¥½ï¼Œä½†æˆ‘ä»¬çš„ Pyret ç‰ˆæœ¬å°†æ±‚å’Œçš„åˆ—è¡¨ä½œä¸ºå‡½æ•°çš„å‚æ•°ã€‚ä¸ºäº†åœ¨ Python ä¸­å®ç°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬åƒæœ¬ç« å‰é¢çš„ä¸€äº›å…¶ä»–ç¤ºä¾‹é‚£æ ·å°†
    `for` åŒ…è£¹åœ¨å‡½æ•°ä¸­ã€‚è¿™æ˜¯æœ€ç»ˆç‰ˆæœ¬ã€‚
- en: '[PRE120]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Do Now!
  id: totrans-621
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-622
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a set of tests for `sum_list` (the Python version).
  id: totrans-623
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸º `sum_list`ï¼ˆPython ç‰ˆæœ¬ï¼‰ç¼–å†™ä¸€ç»„æµ‹è¯•ã€‚
- en: 'Now that the Python version is done, letâ€™s compare it to the original Pyret
    version:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼ŒPython ç‰ˆæœ¬å·²ç»å®Œæˆï¼Œè®©æˆ‘ä»¬å°†å…¶ä¸åŸå§‹ Pyret ç‰ˆæœ¬è¿›è¡Œæ¯”è¾ƒï¼š
- en: '[PRE121]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Here are some things to notice about the two pieces of code:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: å…³äºè¿™ä¸¤æ®µä»£ç ï¼Œæœ‰ä¸€äº›éœ€è¦æ³¨æ„çš„äº‹é¡¹ï¼š
- en: The Python version needs a variable (here `run_total`) to hold the result of
    the computation as we build it up while traversing (working through) the list.
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python ç‰ˆæœ¬éœ€è¦ä¸€ä¸ªå˜é‡ï¼ˆè¿™é‡Œ `run_total`ï¼‰æ¥ä¿å­˜æˆ‘ä»¬åœ¨éå†ï¼ˆå¤„ç†ï¼‰åˆ—è¡¨æ—¶æ„å»ºçš„è®¡ç®—ç»“æœã€‚
- en: The initial value of that variable is the answer we returned in the `empty`
    case in Pyret.
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¯¥å˜é‡çš„åˆå§‹å€¼æ˜¯ Pyret ä¸­ `empty` æƒ…å†µä¸‹æˆ‘ä»¬è¿”å›çš„ç­”æ¡ˆã€‚
- en: The computation in the `link` case of the Pyret function is used to update that
    variable in the body of the `for`.
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pyret å‡½æ•°çš„ `link` æƒ…å†µä¸­çš„è®¡ç®—ç”¨äºæ›´æ–° `for` ä½“ä¸­çš„è¯¥å˜é‡ã€‚
- en: After the `for` has finished processing all items in the list, the Python version
    returns the value in the variable as the result of the function.
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨ `for` å®Œæˆå¤„ç†åˆ—è¡¨ä¸­çš„æ‰€æœ‰é¡¹ç›®åï¼ŒPython ç‰ˆæœ¬å°†å˜é‡ä¸­çš„å€¼ä½œä¸ºå‡½æ•°çš„ç»“æœè¿”å›ã€‚
- en: 9.1.8.2Â An Aside on Order of Processing List Elements[ğŸ”—](#(part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements)
    "Link to here")
  id: totrans-631
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.2Â å…³äºå¤„ç†åˆ—è¡¨å…ƒç´ é¡ºåºçš„æ—ç™½[ğŸ”—](#(part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements)
    "é“¾æ¥è‡³æ­¤")
- en: 'Thereâ€™s another subtlety here if we consider how the two programs run: the
    Python version sums the elements from left to right, whereas the Pyret version
    sums them right to left. Concretely, the sequence of values of `run_total` are
    computed as:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬è€ƒè™‘è¿™ä¸¤ä¸ªç¨‹åºæ˜¯å¦‚ä½•è¿è¡Œçš„ï¼Œè¿™é‡Œè¿˜æœ‰ä¸€ä¸ªç»†å¾®ä¹‹å¤„ï¼šPython ç‰ˆæœ¬æ˜¯ä»å·¦åˆ°å³ç´¯åŠ å…ƒç´ ï¼Œè€Œ Pyret ç‰ˆæœ¬æ˜¯ä»å³åˆ°å·¦ç´¯åŠ ã€‚å…·ä½“æ¥è¯´ï¼Œ`run_total`
    çš„å€¼åºåˆ—æ˜¯è¿™æ ·è®¡ç®—çš„ï¼š
- en: '[PRE122]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'In contrast, the Pyret version unrolls as:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸æ¯”ä¹‹ä¸‹ï¼ŒPyret ç‰ˆæœ¬å±•å¼€å¦‚ä¸‹ï¼š
- en: '[PRE123]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: As a reminder, the Pyret version did this because the `+` in the `link` case
    can only reduce to an answer once the sum of the rest of the list has been computed.
    Even though we as humans see the chain of `+` operations in each line of the Pyret
    unrolling, Pyret sees only the expression `fst + sum-list(rst)`, which requires
    the function call to finish before the `+` executes.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºæé†’ï¼ŒPyret ç‰ˆæœ¬ä¹‹æ‰€ä»¥è¿™æ ·åšï¼Œæ˜¯å› ä¸º `link` æƒ…å†µä¸­çš„ `+` åªèƒ½åœ¨è®¡ç®—äº†åˆ—è¡¨å…¶ä½™éƒ¨åˆ†çš„å’Œä¹‹åæ‰èƒ½ç®€åŒ–ä¸ºç­”æ¡ˆã€‚å°½ç®¡æˆ‘ä»¬ä½œä¸ºäººç±»çœ‹åˆ° Pyret
    å±•å¼€ä¸­æ¯ä¸€è¡Œçš„ `+` æ“ä½œé“¾ï¼Œä½† Pyret åªçœ‹åˆ°è¡¨è¾¾å¼ `fst + sum-list(rst)`ï¼Œè¿™éœ€è¦åœ¨ `+` æ‰§è¡Œä¹‹å‰å®Œæˆå‡½æ•°è°ƒç”¨ã€‚
- en: In the case of summing a list, we donâ€™t notice the difference between the two
    versions because the sum is the same whether we compute it left-to-right or right-to-left.
    In other functions we write, this difference may start to matter.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ±‚å’Œåˆ—è¡¨çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¸ä¼šæ³¨æ„åˆ°ä¸¤ä¸ªç‰ˆæœ¬ä¹‹é—´çš„åŒºåˆ«ï¼Œå› ä¸ºæ— è®ºæˆ‘ä»¬æ˜¯å·¦åˆ°å³è¿˜æ˜¯å³åˆ°å·¦è®¡ç®—ï¼Œæ€»å’Œéƒ½æ˜¯ç›¸åŒçš„ã€‚åœ¨æˆ‘ä»¬ç¼–å†™çš„å…¶ä»–å‡½æ•°ä¸­ï¼Œè¿™ç§å·®å¼‚å¯èƒ½å¼€å§‹å˜å¾—é‡è¦ã€‚
- en: 9.1.8.3Â Using `For` Loops in Functions that Produce Lists[ğŸ”—](#(part._python-funcs-produce-lists)
    "Link to here")
  id: totrans-638
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.3 åœ¨ç”Ÿæˆåˆ—è¡¨çš„å‡½æ•°ä¸­ä½¿ç”¨`For`å¾ªç¯[ğŸ”—](#(part._python-funcs-produce-lists) "é“¾æ¥è‡³æ­¤")
- en: Letâ€™s practice using `for` loops on another function that traverses lists, this
    time one that produces a list. Specifically, letâ€™s write a program that takes
    a list of strings and produces a list of words within that list that contain the
    letter `"z"`.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬åœ¨å¦ä¸€ä¸ªå‡½æ•°ä¸Šç»ƒä¹ ä½¿ç”¨`for`å¾ªç¯ï¼Œè¿™æ¬¡æ˜¯ä¸€ä¸ªç”Ÿæˆåˆ—è¡¨çš„å‡½æ•°ã€‚å…·ä½“æ¥è¯´ï¼Œè®©æˆ‘ä»¬ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œå®ƒæ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ï¼Œå¹¶ç”ŸæˆåŒ…å«å­—æ¯`"z"`çš„å•è¯åˆ—è¡¨ã€‚
- en: As in our `sum_list` function, we will need a variable to store the resulting
    list as we build it up. The following code calls this `zlist`. The code also shows
    how to use `in` to check whether a character is in a string (it also works for
    checking whether an item is in a list) and how to add an element to the end of
    a list (`append`).
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬çš„`sum_list`å‡½æ•°ä¸€æ ·ï¼Œæˆ‘ä»¬å°†åœ¨æ„å»ºåˆ—è¡¨çš„è¿‡ç¨‹ä¸­éœ€è¦ä¸€ä¸ªå˜é‡æ¥å­˜å‚¨ç»“æœã€‚ä»¥ä¸‹ä»£ç è°ƒç”¨è¿™ä¸ª`zlist`ã€‚ä»£ç è¿˜å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨`in`æ¥æ£€æŸ¥ä¸€ä¸ªå­—ç¬¦æ˜¯å¦åœ¨å­—ç¬¦ä¸²ä¸­ï¼ˆå®ƒä¹Ÿé€‚ç”¨äºæ£€æŸ¥ä¸€ä¸ªé¡¹ç›®æ˜¯å¦åœ¨åˆ—è¡¨ä¸­ï¼‰ä»¥åŠå¦‚ä½•å°†ä¸€ä¸ªå…ƒç´ æ·»åŠ åˆ°åˆ—è¡¨çš„æœ«å°¾ï¼ˆ`append`ï¼‰ã€‚
- en: '[PRE124]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: This code follows the structure of `sum_list`, in that we update the value of
    `zlist` using an expression similar to what we would have used in Pyret. For those
    with prior Python experience who would have used `zlist.append` here, hold that
    thought. We will get there in [Mutable Lists](mutable-lists.html).
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤ä»£ç éµå¾ª`sum_list`çš„ç»“æ„ï¼Œå³æˆ‘ä»¬ä½¿ç”¨ç±»ä¼¼äºåœ¨Pyretä¸­ä¼šä½¿ç”¨çš„è¡¨è¾¾å¼æ›´æ–°`zlist`çš„å€¼ã€‚å¯¹äºé‚£äº›æœ‰å…ˆå‰çš„Pythonç»éªŒï¼Œåœ¨è¿™é‡Œä¼šä½¿ç”¨`zlist.append`çš„äººï¼Œè¯·è®°ä½è¿™ä¸ªæƒ³æ³•ã€‚æˆ‘ä»¬å°†åœ¨[å¯å˜åˆ—è¡¨](mutable-lists.html)ä¸­è¾¾åˆ°é‚£é‡Œã€‚
- en: Exercise
  id: totrans-643
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-644
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write tests for `all_z_words`.
  id: totrans-645
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸º`all_z_words`ç¼–å†™æµ‹è¯•ã€‚
- en: Exercise
  id: totrans-646
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-647
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a second version of `all_z_words` using `filter`. Be sure to write tests
    for it!
  id: totrans-648
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`filter`ç¼–å†™`all_z_words`çš„ç¬¬äºŒä¸ªç‰ˆæœ¬ã€‚ç¡®ä¿ä¸ºå…¶ç¼–å†™æµ‹è¯•ï¼
- en: Exercise
  id: totrans-649
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-650
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Contrast these two versions and the corresponding tests. Did you notice anything
    interesting?
  id: totrans-651
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¯¹æ¯”è¿™ä¸¤ä¸ªç‰ˆæœ¬åŠå…¶ç›¸åº”çš„æµ‹è¯•ã€‚ä½ æ³¨æ„åˆ°ä»€ä¹ˆæœ‰è¶£çš„åœ°æ–¹äº†å—ï¼Ÿ
- en: '9.1.8.4Â Summary: The List-Processing Template for Python[ğŸ”—](#(part._.Summary__.The_.List-.Processing_.Template_for_.Python)
    "Link to here")'
  id: totrans-652
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.4 æ‘˜è¦ï¼šPythonçš„åˆ—è¡¨å¤„ç†æ¨¡æ¿[ğŸ”—](#(part._.Summary__.The_.List-.Processing_.Template_for_.Python)
    "é“¾æ¥è‡³æ­¤")
- en: 'Just as we had a template for writing list-processing functions in Pyret, there
    is a corresponding template in Python based on `for` loops. As a reminder, that
    pattern is as follow:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬åœ¨Pyretä¸­ç¼–å†™åˆ—è¡¨å¤„ç†å‡½æ•°æ—¶æœ‰ä¸€ä¸ªæ¨¡æ¿ä¸€æ ·ï¼ŒPythonä¸­ä¹Ÿæœ‰ä¸€ä¸ªåŸºäº`for`å¾ªç¯çš„ç›¸åº”æ¨¡æ¿ã€‚ä½œä¸ºæé†’ï¼Œé‚£ä¸ªæ¨¡å¼å¦‚ä¸‹ï¼š
- en: '[PRE125]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Keep this template in mind as you learn to write functions over lists in Python.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä½ å­¦ä¹ åœ¨Pythonä¸­ç¼–å†™åˆ—è¡¨å‡½æ•°æ—¶ï¼Œè¯·è®°ä½è¿™ä¸ªæ¨¡æ¿ã€‚
- en: 9.1.8.5Â `for each` loops in Pyret[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret)
    "Link to here")
  id: totrans-656
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.5 Pyretä¸­çš„`for each`å¾ªç¯[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret)
    "é“¾æ¥è‡³æ­¤")
- en: This section can be read without reading the rest of this chapter, so if you
    have been directed to it before being introduced to Python, do not worry! While
    the content below mirrors similar constructs that exist in Python, it is introduced
    on its own.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬èŠ‚å¯ä»¥ç‹¬ç«‹é˜…è¯»ï¼Œæ— éœ€é˜…è¯»æœ¬ç« çš„å…¶ä½™éƒ¨åˆ†ï¼Œæ‰€ä»¥å¦‚æœä½ åœ¨ä»‹ç»Pythonä¹‹å‰è¢«å¼•å¯¼åˆ°è¿™é‡Œï¼Œè¯·ä¸è¦æ‹…å¿ƒï¼è™½ç„¶ä¸‹é¢çš„å†…å®¹åæ˜ äº†Pythonä¸­å­˜åœ¨çš„ç±»ä¼¼ç»“æ„ï¼Œä½†å®ƒæ˜¯ä»¥ç‹¬ç«‹çš„æ–¹å¼å¼•å…¥çš„ã€‚
- en: 'The previous sections introduced `for` loops in Python, and showed a template
    for processing lists with them. Pyret can do similar, using the following pattern:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: å‰å‡ èŠ‚ä»‹ç»äº†Pythonä¸­çš„`for`å¾ªç¯ï¼Œå¹¶å±•ç¤ºäº†ä½¿ç”¨å®ƒä»¬å¤„ç†åˆ—è¡¨çš„æ¨¡æ¿ã€‚Pyretå¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ¨¡å¼åšç±»ä¼¼çš„äº‹æƒ…ï¼š
- en: '[PRE126]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: There are a few new language features used in this example, introduced in the
    following several sections.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ­¤ç¤ºä¾‹ä¸­ä½¿ç”¨äº†å‡ ä¸ªæ–°çš„è¯­è¨€ç‰¹æ€§ï¼Œè¿™äº›ç‰¹æ€§å°†åœ¨æ¥ä¸‹æ¥çš„å‡ ä¸ªç« èŠ‚ä¸­ä»‹ç»ã€‚
- en: 9.1.8.5.1Â Variables that can change[ğŸ”—](#(part._.Variables_that_can_change) "Link
    to here")
  id: totrans-661
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.5.1 å¯å˜å˜é‡[ğŸ”—](#(part._.Variables_that_can_change) "é“¾æ¥è‡³æ­¤")
- en: First, note that we introduce the variable `result` with `var result` â€“ this
    means that it can vary, which is important for the use with `for each`.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæ³¨æ„æˆ‘ä»¬ä½¿ç”¨`var result`å¼•å…¥å˜é‡`result`â€”â€”è¿™æ„å‘³ç€å®ƒå¯ä»¥å˜åŒ–ï¼Œè¿™å¯¹äºä¸`for each`ä¸€èµ·ä½¿ç”¨å¾ˆé‡è¦ã€‚
- en: 'By default, all variables in the program directory can never be changed. i.e.,
    if I define a variable `x`, I can not redefine it later:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: é»˜è®¤æƒ…å†µä¸‹ï¼Œç¨‹åºç›®å½•ä¸­çš„æ‰€æœ‰å˜é‡æ°¸è¿œä¸èƒ½æ›´æ”¹ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœæˆ‘å®šä¹‰äº†ä¸€ä¸ªå˜é‡`x`ï¼Œæˆ‘ä»¥åå°±ä¸èƒ½é‡æ–°å®šä¹‰å®ƒï¼š
- en: '[PRE127]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: If we do want to change (or mutate) a variable in the directory later, we can,
    but we must declare the variable can change â€“ as in, when we define it, rather
    than writing `x = 10`, we must write `var x = 10`. Then, when we want to update
    it, we can do so with the `:=` operator, as is done in the template above.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬ç¨åç¡®å®æƒ³è¦æ›´æ”¹ï¼ˆæˆ–å˜å¼‚ï¼‰ç›®å½•ä¸­çš„å˜é‡ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·åšï¼Œä½†æˆ‘ä»¬å¿…é¡»å£°æ˜è¯¥å˜é‡å¯ä»¥æ›´æ”¹â€”â€”ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“æˆ‘ä»¬å®šä¹‰å®ƒæ—¶ï¼Œè€Œä¸æ˜¯å†™`x = 10`ï¼Œæˆ‘ä»¬å¿…é¡»å†™`var
    x = 10`ã€‚ç„¶åï¼Œå½“æˆ‘ä»¬æƒ³è¦æ›´æ–°å®ƒæ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨`:=`è¿ç®—ç¬¦æ¥æ›´æ–°ï¼Œå°±åƒæ¨¡æ¿ä¸Šé¢æ‰€åšçš„é‚£æ ·ã€‚
- en: '[PRE128]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Note that trying to use `:=` on a variable that was not declared using `var`
    will produce an error, and variables can still only ever be declared once (whether
    with `var x = ...` or `x = ...`).
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå°è¯•åœ¨æœªä½¿ç”¨`var`å£°æ˜çš„å˜é‡ä¸Šä½¿ç”¨`:=`ä¼šäº§ç”Ÿé”™è¯¯ï¼Œå¹¶ä¸”å˜é‡ä»ç„¶åªèƒ½å£°æ˜ä¸€æ¬¡ï¼ˆæ— è®ºæ˜¯ä½¿ç”¨`var x = ...`è¿˜æ˜¯`x = ...`ï¼‰ã€‚
- en: 9.1.8.5.2Â block notation[ğŸ”—](#(part._block_notation) "Link to here")
  id: totrans-668
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.5.2Â å—æ³¨é‡Š[ğŸ”—](#(part._block_notation) "é“¾æ¥è‡³æ­¤")
- en: Another new language feature shown in these examples is that since Pyret functions
    by default expect only a single (non-definition) expression, we have to add the
    `block` annotation at the top, indicating that the body of the function is multiple
    expressions, with the final one being what the function evaluates to.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™äº›ç¤ºä¾‹ä¸­å±•ç¤ºçš„å¦ä¸€ä¸ªæ–°è¯­è¨€ç‰¹æ€§æ˜¯ï¼Œç”±äºPyretå‡½æ•°é»˜è®¤åªæœŸæœ›ä¸€ä¸ªï¼ˆéå®šä¹‰ï¼‰è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬å¿…é¡»åœ¨é¡¶éƒ¨æ·»åŠ `block`æ³¨é‡Šï¼Œè¡¨ç¤ºå‡½æ•°çš„ä¸»ä½“æ˜¯å¤šä¸ªè¡¨è¾¾å¼ï¼Œæœ€åä¸€ä¸ªè¡¨è¾¾å¼æ˜¯å‡½æ•°æ±‚å€¼çš„ç»“æœã€‚
- en: 'As another example, if we tried to write:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºå¦ä¸€ä¸ªä¾‹å­ï¼Œå¦‚æœæˆ‘ä»¬å°è¯•ç¼–å†™ï¼š
- en: '[PRE129]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Pyret would (rightly) error â€“ since the function returns the last expression
    in its body, the `1` will be ignored â€“ and is most likely a mistake! Perhaps the
    goal was to write:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: Pyretä¼šï¼ˆæ­£ç¡®åœ°ï¼‰æŠ¥é”™â€”â€”å› ä¸ºå‡½æ•°è¿”å›å…¶ä¸»ä½“ä¸­çš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼ï¼Œæ‰€ä»¥`1`å°†è¢«å¿½ç•¥â€”â€”è¿™å¾ˆå¯èƒ½æ˜¯é”™è¯¯ï¼ä¹Ÿè®¸ç›®æ ‡æ˜¯ç¼–å†™ï¼š
- en: '[PRE130]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'However, since a `for each` expression exists only to modify a variable, functions
    that contain them will always have multiple expressions, and so we need to communicate
    to Pyret that this is not a mistake. Adding `block` before the `:` that begins
    the function (or, in general, wrapping any expressions in `block:` and `end`)
    communicates to Pyret that we understand that there are multiple expressions,
    and just want to evaluate to the last one. So, if we truly wanted to write a function
    as our first example, we could do that with:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œç”±äº`for each`è¡¨è¾¾å¼ä»…ç”¨äºä¿®æ”¹å˜é‡ï¼ŒåŒ…å«å®ƒä»¬çš„å‡½æ•°å°†å§‹ç»ˆæœ‰å¤šä¸ªè¡¨è¾¾å¼ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦é€šçŸ¥Pyretè¿™ä¸æ˜¯é”™è¯¯ã€‚åœ¨å‡½æ•°å¼€å§‹çš„`:`ä¹‹å‰æ·»åŠ `block`ï¼ˆæˆ–è€…ä¸€èˆ¬åœ°ï¼Œå°†ä»»ä½•è¡¨è¾¾å¼åŒ…è£¹åœ¨`block:`å’Œ`end`ä¸­ï¼‰é€šçŸ¥Pyretæˆ‘ä»¬ç†è§£å­˜åœ¨å¤šä¸ªè¡¨è¾¾å¼ï¼Œæˆ‘ä»¬åªæƒ³è¯„ä¼°æœ€åä¸€ä¸ªã€‚å› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬çœŸæ­£æƒ³è¦ç¼–å†™ç¬¬ä¸€ä¸ªç¤ºä¾‹ä¸­çš„å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·åšï¼š
- en: '[PRE131]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 9.1.8.5.3Â How `for each` works[ğŸ”—](#(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)
    "Link to here")
  id: totrans-676
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.5.3Â `for each`å¦‚ä½•å·¥ä½œ[ğŸ”—](#(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)
    "é“¾æ¥è‡³æ­¤")
- en: A `for each` expression runs its body once for each element in the input list,
    adding an entry to the program directory for each element as it goes. It does
    not produce any value directly, so much instead rely on modifying variables (described
    above) to produce a computation.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ª`for each`è¡¨è¾¾å¼å¯¹å…¶è¾“å…¥åˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ è¿è¡Œå…¶ä¸»ä½“ä¸€æ¬¡ï¼Œåœ¨éå†è¿‡ç¨‹ä¸­ä¸ºæ¯ä¸ªå…ƒç´ åœ¨ç¨‹åºç›®å½•ä¸­æ·»åŠ ä¸€ä¸ªæ¡ç›®ã€‚å®ƒä¸ä¼šç›´æ¥äº§ç”Ÿä»»ä½•å€¼ï¼Œå› æ­¤æ›´å¤šåœ°ä¾èµ–äºä¿®æ”¹å˜é‡ï¼ˆå¦‚ä¸Šæ‰€è¿°ï¼‰æ¥äº§ç”Ÿè®¡ç®—ã€‚
- en: 'Consider summing a list of numbers. We could write a function that does this,
    following our pattern, as:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘æ±‚å’Œä¸€ç»„æ•°å­—ã€‚æˆ‘ä»¬å¯ä»¥ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥å®Œæˆè¿™ä¸ªä»»åŠ¡ï¼Œéµå¾ªæˆ‘ä»¬çš„æ¨¡å¼ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE132]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'On the concrete test input `[list: 5, 1, 7, 3]`, the loop runs four times,
    once with `item` set to `5`, then with `item` set to `1`, then with `item` set
    to `7`, and finally with `item` set to `3`.'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 'åœ¨å…·ä½“çš„æµ‹è¯•è¾“å…¥`[list: 5, 1, 7, 3]`ä¸Šï¼Œå¾ªç¯è¿è¡Œå››æ¬¡ï¼Œä¸€æ¬¡å°†`item`è®¾ç½®ä¸º`5`ï¼Œç„¶åè®¾ç½®ä¸º`1`ï¼Œç„¶åè®¾ç½®ä¸º`7`ï¼Œæœ€åè®¾ç½®ä¸º`3`ã€‚'
- en: 'The `for each` construct saves us from writing the common code multiple times,
    and also handles the fact that the lists we are processing can be of arbitrary
    length (so we canâ€™t predict how many times to write the common code). Thus, what
    happens is:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '`for each`æ„é€ é¿å…äº†æˆ‘ä»¬å¤šæ¬¡ç¼–å†™å¸¸è§ä»£ç ï¼Œå¹¶ä¸”è¿˜å¤„ç†äº†æˆ‘ä»¬æ‰€å¤„ç†çš„åˆ—è¡¨å¯ä»¥æ˜¯ä»»æ„é•¿åº¦çš„äº‹å®ï¼ˆå› æ­¤æˆ‘ä»¬æ— æ³•é¢„æµ‹éœ€è¦ç¼–å†™å¤šå°‘æ¬¡å¸¸è§ä»£ç ï¼‰ã€‚å› æ­¤ï¼Œå‘ç”Ÿçš„æƒ…å†µæ˜¯ï¼š'
- en: '[PRE133]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 9.1.8.5.4Â Testing and variables that can change[ğŸ”—](#(part._.Testing_and_variables_that_can_change)
    "Link to here")
  id: totrans-683
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.5.4Â æµ‹è¯•å’Œå¯èƒ½å˜åŒ–çš„å˜é‡[ğŸ”—](#(part._.Testing_and_variables_that_can_change) "é“¾æ¥è‡³æ­¤")
- en: We intentionally showed a very particular pattern of using variables that can
    change. While there are other uses (explored in part in [Mutating Variables](mutating-variables.html)),
    a main reason to stay with this particular template is the difficulty in testing
    and correspondingly, understanding, code that uses them in other ways.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ•…æ„å±•ç¤ºäº†ä½¿ç”¨å¯å˜å˜é‡çš„ç‰¹å®šæ¨¡å¼ã€‚è™½ç„¶è¿˜æœ‰å…¶ä»–ç”¨é€”ï¼ˆéƒ¨åˆ†åœ¨[å¯å˜å˜é‡](mutating-variables.html)ä¸­æ¢è®¨ï¼‰ï¼Œä½†åšæŒä½¿ç”¨è¿™ä¸ªç‰¹å®šæ¨¡æ¿çš„ä¸»è¦åŸå› åœ¨äºæµ‹è¯•çš„å›°éš¾ï¼Œç›¸åº”åœ°ï¼Œç†è§£ä½¿ç”¨å®ƒä»¬çš„ä»£ç ä¹Ÿå¾ˆå›°éš¾ã€‚
- en: In particular, note that the pattern means that we never define a variables
    that can change outside a function, which means it can never be used by different
    functions, or multiple function calls. Each time the function runs, a new variable
    is created, it is modified in the `for each` loop, and then the value is returned,
    and the entry in the program directory is removed.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: ç‰¹åˆ«æ³¨æ„ï¼Œè¿™ä¸ªæ¨¡å¼æ„å‘³ç€æˆ‘ä»¬æ°¸è¿œä¸ä¼šåœ¨å‡½æ•°å¤–éƒ¨å®šä¹‰å¯ä»¥æ”¹å˜çš„å˜é‡ï¼Œè¿™æ„å‘³ç€å®ƒæ°¸è¿œä¸èƒ½è¢«ä¸åŒçš„å‡½æ•°æˆ–å¤šæ¬¡å‡½æ•°è°ƒç”¨ä½¿ç”¨ã€‚æ¯æ¬¡å‡½æ•°è¿è¡Œæ—¶ï¼Œéƒ½ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„å˜é‡ï¼Œå®ƒåœ¨`for
    each`å¾ªç¯ä¸­è¢«ä¿®æ”¹ï¼Œç„¶åè¿”å›å€¼ï¼Œå¹¶ä¸”ç¨‹åºç›®å½•ä¸­çš„æ¡ç›®è¢«åˆ é™¤ã€‚
- en: 'Consider what happens if we donâ€™t follow our pattern. Letâ€™s say we had the
    following problem:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘å¦‚æœæˆ‘ä»¬ä¸éµå¾ªæˆ‘ä»¬çš„æ¨¡å¼ä¼šå‘ç”Ÿä»€ä¹ˆã€‚å‡è®¾æˆ‘ä»¬é‡åˆ°äº†ä»¥ä¸‹é—®é¢˜ï¼š
- en: Exercise
  id: totrans-687
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-688
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given a list of numbers, return the prefix of the list (i.e., all elements,
    starting from the beginning) that sums to less than 100.
  id: totrans-689
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼Œè¿”å›åˆ—è¡¨çš„å‰ç¼€ï¼ˆå³ä»å¼€å§‹çš„æ‰€æœ‰å…ƒç´ ï¼‰ï¼Œå…¶å’Œå°äº100ã€‚
- en: 'Having learned about mutable variables, but not following the pattern, you
    might come up with code like this:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨äº†è§£äº†å¯å˜å˜é‡ä¹‹åï¼Œä½†æ²¡æœ‰éµå¾ªæ¨¡å¼ï¼Œä½ å¯èƒ½ä¼šå†™å‡ºè¿™æ ·çš„ä»£ç ï¼š
- en: '[PRE134]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Now, this might seem reasonable â€“ weâ€™ve used a new construct, `when`, which
    is an `if` expression that has no `else` â€“ this only makes sense to do inside
    of a `for each` block, where we donâ€™t need a value as a result. It is equivalent
    to:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè¿™çœ‹èµ·æ¥å¯èƒ½åˆæƒ…åˆç†â€”â€”æˆ‘ä»¬ä½¿ç”¨äº†ä¸€ä¸ªæ–°çš„æ„é€ ï¼Œ`when`ï¼Œè¿™æ˜¯ä¸€ä¸ªæ²¡æœ‰`else`çš„`if`è¡¨è¾¾å¼â€”â€”è¿™åªæœ‰åœ¨`for each`å—å†…éƒ¨æ‰æœ‰æ„ä¹‰ï¼Œå› ä¸ºæˆ‘ä»¬ä¸éœ€è¦ä¸€ä¸ªç»“æœå€¼ã€‚å®ƒç›¸å½“äºï¼š
- en: '[PRE135]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Where `nothing` is a value that is used in Pyret to indicate that there is no
    particular value of importance.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­`nothing`æ˜¯Pyretä¸­ç”¨æ¥è¡¨ç¤ºæ²¡æœ‰ç‰¹å®šé‡è¦å€¼çš„å€¼ã€‚
- en: But what happens when we use this function?
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†å½“æˆ‘ä»¬ä½¿ç”¨è¿™ä¸ªå‡½æ•°æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆå‘¢ï¼Ÿ
- en: '[PRE136]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The first two tests pass, but the last one doesnâ€™t. Why? If we run the first
    one again, things are even more confusing, i.e., if instead of the above, we ran
    this `check` block:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: å‰ä¸¤ä¸ªæµ‹è¯•é€šè¿‡äº†ï¼Œä½†æœ€åä¸€ä¸ªæ²¡æœ‰é€šè¿‡ã€‚ä¸ºä»€ä¹ˆï¼Ÿå¦‚æœæˆ‘ä»¬å†æ¬¡è¿è¡Œç¬¬ä¸€ä¸ªæµ‹è¯•ï¼Œäº‹æƒ…ä¼šå˜å¾—æ›´åŠ æ··ä¹±ï¼Œå³å¦‚æœæˆ‘ä»¬ä¸æ˜¯è¿è¡Œä¸Šé¢çš„`check`å—ï¼Œè€Œæ˜¯è¿è¡Œè¿™ä¸ªï¼š
- en: '[PRE137]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Now the test that passed at first no longer passes!
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æœ€åˆé€šè¿‡æµ‹è¯•çš„æµ‹è¯•ä¸å†é€šè¿‡äº†ï¼
- en: What we are seeing is that since the variable is outside the function, it is
    shared across different calls to the function. It is added to the program directory
    once, and each time we call `prefix-under-100`, the program directory entry is
    changed, but it is never reset.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çœ‹åˆ°çš„æ˜¯ï¼Œç”±äºå˜é‡åœ¨å‡½æ•°å¤–éƒ¨ï¼Œå®ƒè¢«ä¸åŒå‡½æ•°è°ƒç”¨å…±äº«ã€‚å®ƒè¢«æ·»åŠ åˆ°ç¨‹åºç›®å½•ä¸­ä¸€æ¬¡ï¼Œæ¯æ¬¡æˆ‘ä»¬è°ƒç”¨`prefix-under-100`æ—¶ï¼Œç¨‹åºç›®å½•æ¡ç›®éƒ½ä¼šæ”¹å˜ï¼Œä½†å®ƒæ°¸è¿œä¸ä¼šé‡ç½®ã€‚
- en: Intentionally, all other uses of mutation have been on directory entries that
    were created only for the body of the function, which meant that when the function
    exited, they were removed. But now, we are always modifying the single `count`
    variable. This means that every time we call `prefix-under-100`, it behaves differently,
    because it not only do we have to understand the code in the body of the function,
    we have to know the current value of the count variable, which is not something
    we can figure out by just looking at the code!
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: æ•…æ„åœ°ï¼Œæ‰€æœ‰å…¶ä»–ä½¿ç”¨å˜å¼‚çš„æ–¹æ³•éƒ½åªé’ˆå¯¹ä¸ºå‡½æ•°ä¸»ä½“åˆ›å»ºçš„ç›®å½•æ¡ç›®ï¼Œè¿™æ„å‘³ç€å½“å‡½æ•°é€€å‡ºæ—¶ï¼Œå®ƒä»¬ä¼šè¢«åˆ é™¤ã€‚ä½†ç°åœ¨ï¼Œæˆ‘ä»¬æ€»æ˜¯åœ¨ä¿®æ”¹å•ä¸ª`count`å˜é‡ã€‚è¿™æ„å‘³ç€æ¯æ¬¡æˆ‘ä»¬è°ƒç”¨`prefix-under-100`æ—¶ï¼Œå®ƒçš„è¡Œä¸ºéƒ½ä¸åŒï¼Œå› ä¸ºæˆ‘ä»¬ä¸ä»…å¿…é¡»ç†è§£å‡½æ•°ä¸»ä½“ä¸­çš„ä»£ç ï¼Œè¿˜å¿…é¡»çŸ¥é“è®¡æ•°å˜é‡çš„å½“å‰å€¼ï¼Œè€Œè¿™å¹¶ä¸æ˜¯ä»…ä»…é€šè¿‡æŸ¥çœ‹ä»£ç å°±èƒ½å¼„æ¸…æ¥šçš„äº‹æƒ…ï¼
- en: Functions that behave like this are said to have "side effects", and they are
    much harder to test and much harder to understand, and as a result, much more
    likely to have bugs! While the above example is wrong in a relatively straightforward
    way, side effects can cause extremely subtle bugs that only happen when functions
    are called in particular orders â€“ orders that may only arised in very specific
    situations, making them hard to understand or reproduce.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: å…·æœ‰è¿™ç§è¡Œä¸ºçš„å‡½æ•°è¢«ç§°ä¸ºæœ‰â€œå‰¯ä½œç”¨â€ï¼Œå®ƒä»¬æ›´éš¾æµ‹è¯•ï¼Œä¹Ÿæ›´éš¾ç†è§£ï¼Œå› æ­¤æ›´å®¹æ˜“å‡ºç°é”™è¯¯ï¼è™½ç„¶ä¸Šé¢çš„ä¾‹å­åœ¨ç›¸å¯¹ç›´æ¥çš„æ–¹å¼ä¸Šæ˜¯é”™è¯¯çš„ï¼Œä½†å‰¯ä½œç”¨å¯ä»¥å¯¼è‡´éå¸¸å¾®å¦™çš„é”™è¯¯ï¼Œè¿™äº›é”™è¯¯åªæœ‰åœ¨ä»¥ç‰¹å®šé¡ºåºè°ƒç”¨å‡½æ•°æ—¶æ‰ä¼šå‘ç”Ÿâ€”â€”è¿™äº›é¡ºåºå¯èƒ½åªåœ¨éå¸¸å…·ä½“çš„æƒ…å†µä¸‹å‡ºç°ï¼Œä½¿å¾—å®ƒä»¬éš¾ä»¥ç†è§£æˆ–é‡ç°ã€‚
- en: While there are some places where doing this is necessary, almost all code can
    be written without side effects, and will be much more reliable. We will explore
    some cases where we might want to do this in [Mutating Variables](mutating-variables.html).
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶åœ¨æŸäº›åœ°æ–¹è¿™æ ·åšæ˜¯å¿…è¦çš„ï¼Œä½†å‡ ä¹æ‰€æœ‰ä»£ç éƒ½å¯ä»¥ä¸äº§ç”Ÿå‰¯ä½œç”¨åœ°ç¼–å†™ï¼Œå¹¶ä¸”å°†æ›´åŠ å¯é ã€‚æˆ‘ä»¬å°†åœ¨[ä¿®æ”¹å˜é‡](mutating-variables.html)ä¸­æ¢è®¨æˆ‘ä»¬å¯èƒ½æƒ³è¦è¿™æ ·åšçš„ä¸€äº›æƒ…å†µã€‚
- en: 9.1.8.5.1Â Variables that can change[ğŸ”—](#(part._.Variables_that_can_change) "Link
    to here")
  id: totrans-704
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.5.1 å¯å˜å˜é‡[ğŸ”—](#(part._.Variables_that_can_change) "é“¾æ¥è‡³æ­¤")
- en: First, note that we introduce the variable `result` with `var result` â€“ this
    means that it can vary, which is important for the use with `for each`.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œè¯·æ³¨æ„æˆ‘ä»¬ä½¿ç”¨`var result`å¼•å…¥äº†å˜é‡`result`â€”â€”è¿™æ„å‘³ç€å®ƒå¯ä»¥å˜åŒ–ï¼Œè¿™å¯¹äºä¸`for each`ä¸€èµ·ä½¿ç”¨å¾ˆé‡è¦ã€‚
- en: 'By default, all variables in the program directory can never be changed. i.e.,
    if I define a variable `x`, I can not redefine it later:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: é»˜è®¤æƒ…å†µä¸‹ï¼Œç¨‹åºç›®å½•ä¸­çš„æ‰€æœ‰å˜é‡éƒ½ä¸èƒ½æ›´æ”¹ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœæˆ‘å®šä¹‰äº†ä¸€ä¸ªå˜é‡`x`ï¼Œæˆ‘ä»¥åå°±ä¸èƒ½é‡æ–°å®šä¹‰å®ƒï¼š
- en: '[PRE138]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: If we do want to change (or mutate) a variable in the directory later, we can,
    but we must declare the variable can change â€“ as in, when we define it, rather
    than writing `x = 10`, we must write `var x = 10`. Then, when we want to update
    it, we can do so with the `:=` operator, as is done in the template above.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬ä»¥åç¡®å®æƒ³è¦æ›´æ”¹ï¼ˆæˆ–ä¿®æ”¹ï¼‰ç›®å½•ä¸­çš„å˜é‡ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·åšï¼Œä½†æˆ‘ä»¬å¿…é¡»å£°æ˜è¯¥å˜é‡å¯ä»¥æ›´æ”¹â€”â€”ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“æˆ‘ä»¬å®šä¹‰å®ƒæ—¶ï¼Œè€Œä¸æ˜¯å†™`x = 10`ï¼Œæˆ‘ä»¬å¿…é¡»å†™`var
    x = 10`ã€‚ç„¶åï¼Œå½“æˆ‘ä»¬æƒ³è¦æ›´æ–°å®ƒæ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨`:=`è¿ç®—ç¬¦æ¥æ›´æ–°ï¼Œå°±åƒæ¨¡æ¿ä¸­æ‰€ç¤ºçš„é‚£æ ·ã€‚
- en: '[PRE139]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Note that trying to use `:=` on a variable that was not declared using `var`
    will produce an error, and variables can still only ever be declared once (whether
    with `var x = ...` or `x = ...`).
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå°è¯•åœ¨æœªä½¿ç”¨`var`å£°æ˜çš„å˜é‡ä¸Šä½¿ç”¨`:=`ä¼šäº§ç”Ÿé”™è¯¯ï¼Œå¹¶ä¸”å˜é‡ä»ç„¶åªèƒ½å£°æ˜ä¸€æ¬¡ï¼ˆæ— è®ºæ˜¯ä½¿ç”¨`var x = ...`è¿˜æ˜¯`x = ...`ï¼‰ã€‚
- en: 9.1.8.5.2Â block notation[ğŸ”—](#(part._block_notation) "Link to here")
  id: totrans-711
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.5.2 å—æ³¨é‡Š[ğŸ”—](#(part._block_notation) "é“¾æ¥è‡³æ­¤")
- en: Another new language feature shown in these examples is that since Pyret functions
    by default expect only a single (non-definition) expression, we have to add the
    `block` annotation at the top, indicating that the body of the function is multiple
    expressions, with the final one being what the function evaluates to.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›ç¤ºä¾‹ä¸­å±•ç¤ºçš„å¦ä¸€ä¸ªæ–°è¯­è¨€ç‰¹æ€§æ˜¯ï¼Œç”±äºPyretå‡½æ•°é»˜è®¤åªæœŸæœ›ä¸€ä¸ªï¼ˆéå®šä¹‰ï¼‰è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬å¿…é¡»åœ¨é¡¶éƒ¨æ·»åŠ `block`æ³¨è§£ï¼Œè¡¨ç¤ºå‡½æ•°çš„ä¸»ä½“åŒ…å«å¤šä¸ªè¡¨è¾¾å¼ï¼Œæœ€åä¸€ä¸ªè¡¨è¾¾å¼æ˜¯å‡½æ•°è¯„ä¼°çš„ç»“æœã€‚
- en: 'As another example, if we tried to write:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºå¦ä¸€ä¸ªä¾‹å­ï¼Œå¦‚æœæˆ‘ä»¬å°è¯•ç¼–å†™ï¼š
- en: '[PRE140]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Pyret would (rightly) error â€“ since the function returns the last expression
    in its body, the `1` will be ignored â€“ and is most likely a mistake! Perhaps the
    goal was to write:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: Pyretä¼šï¼ˆæ­£ç¡®åœ°ï¼‰æŠ¥é”™â€”â€”å› ä¸ºå‡½æ•°è¿”å›å…¶ä¸»ä½“ä¸­çš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼ï¼Œæ‰€ä»¥`1`å°†è¢«å¿½ç•¥â€”â€”è¿™å¾ˆå¯èƒ½æ˜¯é”™è¯¯ï¼ä¹Ÿè®¸ç›®æ ‡æ˜¯ç¼–å†™ï¼š
- en: '[PRE141]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'However, since a `for each` expression exists only to modify a variable, functions
    that contain them will always have multiple expressions, and so we need to communicate
    to Pyret that this is not a mistake. Adding `block` before the `:` that begins
    the function (or, in general, wrapping any expressions in `block:` and `end`)
    communicates to Pyret that we understand that there are multiple expressions,
    and just want to evaluate to the last one. So, if we truly wanted to write a function
    as our first example, we could do that with:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œç”±äº`for each`è¡¨è¾¾å¼ä»…ç”¨äºä¿®æ”¹å˜é‡ï¼ŒåŒ…å«å®ƒä»¬çš„å‡½æ•°å°†å§‹ç»ˆæœ‰å¤šä¸ªè¡¨è¾¾å¼ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦é€šçŸ¥Pyretè¿™å¹¶ä¸æ˜¯ä¸€ä¸ªé”™è¯¯ã€‚åœ¨å‡½æ•°å¼€å§‹å¤„çš„å†’å·`:`ä¹‹å‰æ·»åŠ `block`ï¼ˆæˆ–è€…æ›´ä¸€èˆ¬åœ°ï¼Œå°†ä»»ä½•è¡¨è¾¾å¼åŒ…è£¹åœ¨`block:`å’Œ`end`ä¸­ï¼‰ä¼šé€šçŸ¥Pyretæˆ‘ä»¬ç†è§£å­˜åœ¨å¤šä¸ªè¡¨è¾¾å¼ï¼Œæˆ‘ä»¬åªæƒ³è¯„ä¼°æœ€åä¸€ä¸ªã€‚å› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬çœŸæ­£æƒ³è¦æŒ‰ç…§ç¬¬ä¸€ä¸ªç¤ºä¾‹ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·åšï¼š
- en: '[PRE142]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 9.1.8.5.3Â How `for each` works[ğŸ”—](#(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)
    "Link to here")
  id: totrans-719
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.5.3 `for each`å¦‚ä½•å·¥ä½œ[ğŸ”—](#(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)
    "é“¾æ¥è‡³æ­¤")
- en: A `for each` expression runs its body once for each element in the input list,
    adding an entry to the program directory for each element as it goes. It does
    not produce any value directly, so much instead rely on modifying variables (described
    above) to produce a computation.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ª`for each`è¡¨è¾¾å¼ä¼šå¯¹è¾“å…¥åˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ è¿è¡Œä¸€æ¬¡å…¶ä¸»ä½“ï¼Œå¹¶åœ¨éå†è¿‡ç¨‹ä¸­ä¸ºæ¯ä¸ªå…ƒç´ åœ¨ç¨‹åºç›®å½•ä¸­æ·»åŠ ä¸€ä¸ªæ¡ç›®ã€‚å®ƒä¸ä¼šç›´æ¥äº§ç”Ÿä»»ä½•å€¼ï¼Œå› æ­¤æ›´å¤šåœ°ä¾èµ–äºä¿®æ”¹å˜é‡ï¼ˆå¦‚ä¸Šæ‰€è¿°ï¼‰æ¥äº§ç”Ÿè®¡ç®—ç»“æœã€‚
- en: 'Consider summing a list of numbers. We could write a function that does this,
    following our pattern, as:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘å¯¹ä¸€ç»„æ•°å­—è¿›è¡Œæ±‚å’Œã€‚æˆ‘ä»¬å¯ä»¥ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥å®Œæˆè¿™ä¸ªä»»åŠ¡ï¼ŒæŒ‰ç…§æˆ‘ä»¬çš„æ¨¡å¼ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE143]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'On the concrete test input `[list: 5, 1, 7, 3]`, the loop runs four times,
    once with `item` set to `5`, then with `item` set to `1`, then with `item` set
    to `7`, and finally with `item` set to `3`.'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 'åœ¨å…·ä½“çš„æµ‹è¯•è¾“å…¥`[list: 5, 1, 7, 3]`ä¸Šï¼Œå¾ªç¯è¿è¡Œäº†å››æ¬¡ï¼Œä¸€æ¬¡å°†`item`è®¾ç½®ä¸º`5`ï¼Œç„¶åè®¾ç½®ä¸º`1`ï¼Œç„¶åè®¾ç½®ä¸º`7`ï¼Œæœ€åè®¾ç½®ä¸º`3`ã€‚'
- en: 'The `for each` construct saves us from writing the common code multiple times,
    and also handles the fact that the lists we are processing can be of arbitrary
    length (so we canâ€™t predict how many times to write the common code). Thus, what
    happens is:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '`for each` æ„é€ èŠ‚çœäº†æˆ‘ä»¬å¤šæ¬¡ç¼–å†™å¸¸è§ä»£ç çš„æ—¶é—´ï¼Œå¹¶ä¸”å¤„ç†äº†æˆ‘ä»¬æ­£åœ¨å¤„ç†çš„åˆ—è¡¨å¯ä»¥æ˜¯ä»»æ„é•¿åº¦çš„äº‹å®ï¼ˆå› æ­¤æˆ‘ä»¬æ— æ³•é¢„æµ‹éœ€è¦ç¼–å†™å¤šå°‘æ¬¡å¸¸è§ä»£ç ï¼‰ã€‚å› æ­¤ï¼Œå‘ç”Ÿçš„æƒ…å†µæ˜¯ï¼š'
- en: '[PRE144]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 9.1.8.5.4Â Testing and variables that can change[ğŸ”—](#(part._.Testing_and_variables_that_can_change)
    "Link to here")
  id: totrans-726
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1.8.5.4Â æµ‹è¯•å’Œå¯å˜å˜é‡[ğŸ”—](#(part._.Testing_and_variables_that_can_change) "é“¾æ¥åˆ°æ­¤å¤„")
- en: We intentionally showed a very particular pattern of using variables that can
    change. While there are other uses (explored in part in [Mutating Variables](mutating-variables.html)),
    a main reason to stay with this particular template is the difficulty in testing
    and correspondingly, understanding, code that uses them in other ways.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ•…æ„å±•ç¤ºäº†ä¸€ç§ä½¿ç”¨å¯å˜å˜é‡çš„ç‰¹å®šæ¨¡å¼ã€‚è™½ç„¶è¿˜æœ‰å…¶ä»–ç”¨é€”ï¼ˆéƒ¨åˆ†åœ¨[å¯å˜å˜é‡](mutating-variables.html)ä¸­æ¢è®¨ï¼‰ï¼Œä½†åšæŒè¿™ç§ç‰¹å®šæ¨¡æ¿çš„ä¸»è¦åŸå› åœ¨äºä½¿ç”¨å…¶ä»–æ–¹å¼æµ‹è¯•å’Œç›¸åº”åœ°ç†è§£è¿™äº›ä»£ç çš„å›°éš¾ã€‚
- en: In particular, note that the pattern means that we never define a variables
    that can change outside a function, which means it can never be used by different
    functions, or multiple function calls. Each time the function runs, a new variable
    is created, it is modified in the `for each` loop, and then the value is returned,
    and the entry in the program directory is removed.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: ç‰¹åˆ«æ˜¯ï¼Œè¯·æ³¨æ„ï¼Œè¿™ç§æ¨¡å¼æ„å‘³ç€æˆ‘ä»¬æ°¸è¿œä¸ä¼šåœ¨å‡½æ•°å¤–éƒ¨å®šä¹‰å¯ä»¥æ”¹å˜çš„å˜é‡ï¼Œè¿™æ„å‘³ç€å®ƒæ°¸è¿œä¸èƒ½è¢«ä¸åŒçš„å‡½æ•°æˆ–å¤šä¸ªå‡½æ•°è°ƒç”¨ä½¿ç”¨ã€‚æ¯æ¬¡å‡½æ•°è¿è¡Œæ—¶ï¼Œéƒ½ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„å˜é‡ï¼Œå®ƒåœ¨`for
    each`å¾ªç¯ä¸­ä¿®æ”¹ï¼Œç„¶åè¿”å›å…¶å€¼ï¼Œå¹¶ä¸”ç¨‹åºç›®å½•ä¸­çš„æ¡ç›®è¢«åˆ é™¤ã€‚
- en: 'Consider what happens if we donâ€™t follow our pattern. Letâ€™s say we had the
    following problem:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘å¦‚æœæˆ‘ä»¬ä¸éµå¾ªæˆ‘ä»¬çš„æ¨¡å¼ä¼šå‘ç”Ÿä»€ä¹ˆã€‚è®©æˆ‘ä»¬å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªä»¥ä¸‹é—®é¢˜ï¼š
- en: Exercise
  id: totrans-730
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-731
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given a list of numbers, return the prefix of the list (i.e., all elements,
    starting from the beginning) that sums to less than 100.
  id: totrans-732
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼Œè¿”å›åˆ—è¡¨çš„å‰ç¼€ï¼ˆå³ï¼Œä»å¼€å§‹çš„æ‰€æœ‰å…ƒç´ ï¼‰ï¼Œå…¶å’Œå°äº100ã€‚
- en: 'Having learned about mutable variables, but not following the pattern, you
    might come up with code like this:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶å­¦ä¹ äº†å¯å˜å˜é‡ï¼Œä½†æ²¡æœ‰éµå¾ªæ¨¡å¼ï¼Œä½ å¯èƒ½ä¼šå†™å‡ºè¿™æ ·çš„ä»£ç ï¼š
- en: '[PRE145]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Now, this might seem reasonable â€“ weâ€™ve used a new construct, `when`, which
    is an `if` expression that has no `else` â€“ this only makes sense to do inside
    of a `for each` block, where we donâ€™t need a value as a result. It is equivalent
    to:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè¿™çœ‹èµ·æ¥å¯èƒ½æ˜¯æœ‰é“ç†çš„â€”â€”æˆ‘ä»¬ä½¿ç”¨äº†ä¸€ä¸ªæ–°çš„æ„é€ ï¼Œ`when`ï¼Œè¿™æ˜¯ä¸€ä¸ªæ²¡æœ‰`else`çš„`if`è¡¨è¾¾å¼â€”â€”è¿™åªæœ‰åœ¨`for each`å—å†…éƒ¨æ‰æœ‰æ„ä¹‰ï¼Œåœ¨é‚£é‡Œæˆ‘ä»¬ä¸éœ€è¦ç»“æœå€¼ã€‚å®ƒç­‰ä»·äºï¼š
- en: '[PRE146]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Where `nothing` is a value that is used in Pyret to indicate that there is no
    particular value of importance.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­`nothing`æ˜¯Pyretä¸­ç”¨æ¥è¡¨ç¤ºæ²¡æœ‰ç‰¹å®šé‡è¦å€¼çš„å€¼ã€‚
- en: But what happens when we use this function?
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†å½“æˆ‘ä»¬ä½¿ç”¨è¿™ä¸ªå‡½æ•°æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆå‘¢ï¼Ÿ
- en: '[PRE147]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'The first two tests pass, but the last one doesnâ€™t. Why? If we run the first
    one again, things are even more confusing, i.e., if instead of the above, we ran
    this `check` block:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: å‰ä¸¤ä¸ªæµ‹è¯•é€šè¿‡äº†ï¼Œä½†æœ€åä¸€ä¸ªæ²¡æœ‰é€šè¿‡ã€‚ä¸ºä»€ä¹ˆï¼Ÿå¦‚æœæˆ‘ä»¬å†æ¬¡è¿è¡Œç¬¬ä¸€ä¸ªæµ‹è¯•ï¼Œäº‹æƒ…ä¼šå˜å¾—æ›´åŠ æ··ä¹±ï¼Œå³ï¼Œå¦‚æœæˆ‘ä»¬ä¸æ˜¯è¿è¡Œä¸Šé¢çš„`check`å—ï¼Œè€Œæ˜¯è¿è¡Œè¿™ä¸ªï¼š
- en: '[PRE148]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Now the test that passed at first no longer passes!
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æœ€åˆé€šè¿‡æµ‹è¯•çš„æµ‹è¯•ä¸å†é€šè¿‡äº†ï¼
- en: What we are seeing is that since the variable is outside the function, it is
    shared across different calls to the function. It is added to the program directory
    once, and each time we call `prefix-under-100`, the program directory entry is
    changed, but it is never reset.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çœ‹åˆ°çš„æ˜¯ï¼Œç”±äºå˜é‡åœ¨å‡½æ•°å¤–éƒ¨ï¼Œå®ƒä¼šåœ¨å‡½æ•°çš„ä¸åŒè°ƒç”¨ä¹‹é—´å…±äº«ã€‚å®ƒåªè¢«æ·»åŠ åˆ°ç¨‹åºç›®å½•ä¸­ä¸€æ¬¡ï¼Œæ¯æ¬¡æˆ‘ä»¬è°ƒç”¨`prefix-under-100`æ—¶ï¼Œç¨‹åºç›®å½•æ¡ç›®éƒ½ä¼šæ”¹å˜ï¼Œä½†å®ƒæ°¸è¿œä¸ä¼šé‡ç½®ã€‚
- en: Intentionally, all other uses of mutation have been on directory entries that
    were created only for the body of the function, which meant that when the function
    exited, they were removed. But now, we are always modifying the single `count`
    variable. This means that every time we call `prefix-under-100`, it behaves differently,
    because it not only do we have to understand the code in the body of the function,
    we have to know the current value of the count variable, which is not something
    we can figure out by just looking at the code!
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: æ•…æ„åœ°ï¼Œæ‰€æœ‰å…¶ä»–ä½¿ç”¨å˜å¼‚çš„æ–¹æ³•éƒ½åªåº”ç”¨äºä»…ç”¨äºå‡½æ•°ä¸»ä½“çš„ç›®å½•æ¡ç›®ï¼Œè¿™æ„å‘³ç€å½“å‡½æ•°é€€å‡ºæ—¶ï¼Œå®ƒä»¬ä¼šè¢«ç§»é™¤ã€‚ä½†ç°åœ¨ï¼Œæˆ‘ä»¬æ€»æ˜¯åœ¨ä¿®æ”¹å•ä¸ª`count`å˜é‡ã€‚è¿™æ„å‘³ç€æ¯æ¬¡æˆ‘ä»¬è°ƒç”¨`prefix-under-100`æ—¶ï¼Œå®ƒçš„è¡Œä¸ºéƒ½ä¸åŒï¼Œå› ä¸ºæˆ‘ä»¬ä¸ä»…å¿…é¡»ç†è§£å‡½æ•°ä¸»ä½“ä¸­çš„ä»£ç ï¼Œè¿˜å¿…é¡»çŸ¥é“è®¡æ•°å˜é‡çš„å½“å‰å€¼ï¼Œè€Œè¿™å¹¶ä¸æ˜¯ä»…ä»…é€šè¿‡æŸ¥çœ‹ä»£ç å°±èƒ½å¼„æ¸…æ¥šçš„äº‹æƒ…ï¼
- en: Functions that behave like this are said to have "side effects", and they are
    much harder to test and much harder to understand, and as a result, much more
    likely to have bugs! While the above example is wrong in a relatively straightforward
    way, side effects can cause extremely subtle bugs that only happen when functions
    are called in particular orders â€“ orders that may only arised in very specific
    situations, making them hard to understand or reproduce.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: å…·æœ‰è¿™ç§è¡Œä¸ºçš„å‡½æ•°è¢«ç§°ä¸ºæœ‰â€œå‰¯ä½œç”¨â€ï¼Œå®ƒä»¬æ›´éš¾æµ‹è¯•ï¼Œä¹Ÿæ›´éš¾ç†è§£ï¼Œå› æ­¤æ›´å®¹æ˜“å‡ºç°é”™è¯¯ï¼è™½ç„¶ä¸Šè¿°ä¾‹å­åœ¨ç›¸å¯¹ç›´æ¥çš„æ–¹å¼ä¸Šæ˜¯é”™è¯¯çš„ï¼Œä½†å‰¯ä½œç”¨å¯èƒ½å¯¼è‡´éå¸¸å¾®å¦™çš„é”™è¯¯ï¼Œè¿™äº›é”™è¯¯åªæœ‰åœ¨å‡½æ•°ä»¥ç‰¹å®šé¡ºåºè¢«è°ƒç”¨æ—¶æ‰ä¼šå‘ç”Ÿâ€”â€”è¿™äº›é¡ºåºå¯èƒ½åªå‡ºç°åœ¨éå¸¸å…·ä½“çš„æƒ…å†µä¸‹ï¼Œä½¿å¾—å®ƒä»¬éš¾ä»¥ç†è§£æˆ–é‡ç°ã€‚
- en: While there are some places where doing this is necessary, almost all code can
    be written without side effects, and will be much more reliable. We will explore
    some cases where we might want to do this in [Mutating Variables](mutating-variables.html).
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶åœ¨æŸäº›åœ°æ–¹åšè¿™ä»¶äº‹æ˜¯å¿…è¦çš„ï¼Œä½†å‡ ä¹æ‰€æœ‰ä»£ç éƒ½å¯ä»¥åœ¨ä¸äº§ç”Ÿå‰¯ä½œç”¨çš„æƒ…å†µä¸‹ç¼–å†™ï¼Œè¿™å°†ä½¿ä»£ç æ›´åŠ å¯é ã€‚æˆ‘ä»¬å°†åœ¨[ä¿®æ”¹å˜é‡](mutating-variables.html)ä¸­æ¢è®¨ä¸€äº›æˆ‘ä»¬å¯èƒ½æƒ³è¦è¿™æ ·åšçš„æƒ…å†µã€‚
