- en: Chapter 4 Numpy ndarrays Versus R’s matrix and array Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 Numpy 数组与 R 的矩阵和数组类型
- en: 原文：[https://randpythonbook.netlify.app/numpy-ndarrays-versus-rs-matrix-and-array-types](https://randpythonbook.netlify.app/numpy-ndarrays-versus-rs-matrix-and-array-types)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://randpythonbook.netlify.app/numpy-ndarrays-versus-rs-matrix-and-array-types](https://randpythonbook.netlify.app/numpy-ndarrays-versus-rs-matrix-and-array-types)
- en: Sometimes you want a collection of elements that are *all the same type*, but
    you want to store them in a two- or three-dimensional structure. For instance,
    say you need to use matrix multiplication for some linear regression software
    you’re writing, or that you need to use tensors for a computer vision project
    you’re working on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你想要一个所有元素都是同一类型的元素集合，但你希望将它们存储在二维或三维结构中。例如，假设你需要使用矩阵乘法来编写一些线性回归软件，或者你需要使用张量来完成你正在进行的计算机视觉项目。
- en: 4.1 Numpy `ndarray`s In Python
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 Python 中的 Numpy `ndarray`
- en: In Python, you could still use arrays for these kinds of tasks. You will be
    pleased to learn that the Numpy `array`s we discussed earlier are a special case
    of [Numpy’s N-dimensional arrays](https://numpy.org/doc/stable/reference/arrays.ndarray.html).
    Each array will come with an enormous amount of [methods](https://numpy.org/doc/stable/reference/arrays.ndarray.html#array-methods)
    and [attributes](https://numpy.org/doc/stable/reference/arrays.ndarray.html#array-attributes)
    (more on object-oriented program in chapter [14](/an-introduction-to-object-oriented-programming#an-introduction-to-object-oriented-programming))
    attached to it. A few are demonstrated below.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，你仍然可以使用数组来完成这些任务。你将很高兴地了解到我们之前讨论的 Numpy `array`s 是 [Numpy 的 N 维数组](https://numpy.org/doc/stable/reference/arrays.ndarray.html)
    的一个特例。每个数组都将附带大量的 [方法](https://numpy.org/doc/stable/reference/arrays.ndarray.html#array-methods)
    和 [属性](https://numpy.org/doc/stable/reference/arrays.ndarray.html#array-attributes)（更多关于面向对象编程的内容请见第
    [14](/an-introduction-to-object-oriented-programming#an-introduction-to-object-oriented-programming)
    章）。下面演示了一些。
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Matrix and elementwise multiplication is often useful, too.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵和逐元素乘法也非常有用。
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I should mention that there is also a `matrix` type in Numpy; however, this
    is not described in this text because it is preferable to work with Numpy `array`s
    (Albon [2018](#ref-ml_with_python_cookbook)).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该提到，Numpy 中还有一个 `matrix` 类型；然而，本文中并未对其进行描述，因为这更倾向于使用 Numpy `array`s（Albon
    [2018](#ref-ml_with_python_cookbook)）。
- en: In both R and Python, there are `matrix` types and `array` types. In R, it is
    more common to work with `matrix`s than `array`s, and the opposite is true in
    Python!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 和 Python 中，都有 `matrix` 类型和 `array` 类型。在 R 中，更常见的是使用 `matrix`s 而不是 `array`s，而在
    Python 中则相反！
- en: 4.2 The `matrix` and `array` classes in R
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 R 中的 `matrix` 和 `array` 类
- en: In Python, adding a dimension to your “container” is simple. You keep using
    Numpy arrays, and you just change the `.shape` attribute (perhaps with a call
    to `.reshape()` or something similar). In R, there is a stronger distinction between
    1-,2-, and 3-dimensional containers. Each has its own class. 2-dimensional containers
    that store objects of the same type are of the `matrix` class. Containers with
    3 or more dimensions are of the `array` class[⁷](#fn7). In this section, I will
    provide a quick introduction to using these two classes. For more information,
    see chapter 3 of (Matloff [2011](#ref-matloff_r_book)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，向你的“容器”添加维度很简单。你继续使用 Numpy 数组，只需更改 `.shape` 属性（可能通过调用 `.reshape()`
    或类似的方法）。在 R 中，1 维、2 维和 3 维容器之间的区别更为明显。每个都有自己的类。存储相同类型对象的二维容器属于 `matrix` 类。具有 3
    个或更多维度的容器属于 `array` 类[⁷](#fn7)。在本节中，我将简要介绍如何使用这两个类。更多信息，请参阅 (Matloff [2011](#ref-matloff_r_book))
    的第 3 章。
- en: Just like `vector`s, `matrix` objects do not necessarily have to be used to
    perform matrix arithmetic. Yes, they require all the elements are of the same
    type, but it doesn’t really make sense to “multiply” `matrix` objects that hold
    onto `character`s.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `vector`s 一样，`matrix` 对象不一定要用于执行矩阵运算。是的，它们要求所有元素都是同一类型，但将包含 `character`s
    的 `matrix` 对象“相乘”实际上并没有太多意义。
- en: I usually create `matrix` objects with the `matrix()` function or the `as.matrix()`
    function. `matrix()` is to be preferred in my opinion. The first argument is explicitly
    a `vector` of all the flattened data that you want in your `matrix`. On the other
    hand, `as.matrix()` is more flexible; it takes in a variety of R objects (e.g. `data.frame`s),
    and tries to figure out what to do with them on a case-by-case basis. In other
    words, `as.matrix()` is a *generic function*. More information about generic functions
    is provided in [14.2.2](/an-introduction-to-object-oriented-programming#using-s3-objects).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常使用 `matrix()` 函数或 `as.matrix()` 函数创建 `矩阵` 对象。在我看来，`matrix()` 更可取。第一个参数明确是一个包含你想要在
    `矩阵` 中包含的所有展平数据的 `向量`。另一方面，`as.matrix()` 更灵活；它接受各种 R 对象（例如 `data.frame`），并尝试根据具体情况确定如何处理它们。换句话说，`as.matrix()`
    是一个 *通用函数*。有关通用函数的更多信息，请参阅 [14.2.2](/an-introduction-to-object-oriented-programming#using-s3-objects)。
- en: 'Some other things to remember with `matrix()`: `byrow=` is `FALSE` by default,
    and you will also need to specify either `ncol=` and/or `nrow=` if you want anything
    that isn’t a 1-column `matrix`.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `matrix()` 相关的一些其他注意事项：`byrow=` 默认为 `FALSE`，如果你想要任何不是 1 列 `矩阵` 的东西，你还需要指定
    `ncol=` 和/或 `nrow=`。
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`array()` is used to create `array` objects. This type is used less than the
    `matrix` type, but this doesn’t mean you should avoid learning about it. This
    is mostly a reflection of what kind of data sets people prefer to work with, and
    the fact that matrix algebra is generally better understood than tensor algebra.
    You won’t be able to avoid 3-d data sets (3-dimensions, not a 3-column `matrix`)
    forever, though, particularly if you’re working in an area such as neuroimaging
    or computer vision.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`array()` 用于创建 `数组` 对象。这种类型的使用频率低于 `matrix` 类型，但这并不意味着你应该避免学习它。这主要反映了人们更喜欢处理的数据集类型，以及矩阵代数通常比张量代数更容易理解。然而，你将无法永远避免
    3 维数据集（3 维，而不是 3 列 `矩阵`），尤其是如果你在神经影像学或计算机视觉等领域工作。'
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can matrix-multiply `matrix` objects together with the `%*%` operator. If
    you’re working on this, then the transpose operator (i.e. `t()`) comes in handy,
    too. You can still use element-wise (Hadamard) multiplication. This is defined
    with the more familiar multiplication operator `*`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `%*%` 运算符将 `矩阵` 对象相乘。如果你在做这个，那么转置运算符（即 `t()`）也很有用。你仍然可以使用逐元素（Hadamard）乘法。这使用更熟悉的乘法运算符
    `*` 定义。
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Sometimes you need to access or modify individual elements of a `matrix` object.
    You can use the familiar `[` and `[<-` operators to do this. Here is a setting
    example. You don’t need to worry about coercion to different types here.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要访问或修改 `矩阵` 对象的个别元素。你可以使用熟悉的 `[` 和 `[<-` 运算符来完成此操作。这里有一个设置示例。你不需要担心不同类型之间的强制转换。
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here are some extraction examples. Notice that, if it can, `[` will coerce a
    `matrix` to `vector`. If you wish to avoid this, you can specify `drop=FALSE`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些提取示例。请注意，如果可能的话，`[` 将将 `矩阵` 强制转换为 `向量`。如果你希望避免这种情况，可以指定 `drop=FALSE`。
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are other functions that operate on one or more `matrix` objects in more
    interesting ways, but much of this will be covered in future sections. For instance,
    we will describe how `apply()` works with `matrix`s in section [15](/an-introduction-to-functional-programming#an-introduction-to-functional-programming),
    and we will discuss combining `matrix` objects in different ways in section [12](/reshaping-and-combining-data-sets#reshaping-and-combining-data-sets).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他函数以更有趣的方式操作一个或多个 `矩阵` 对象，但其中大部分将在未来的章节中介绍。例如，我们将在第 [15](/an-introduction-to-functional-programming#an-introduction-to-functional-programming)
    节中描述 `apply()` 如何与 `矩阵` 一起工作，我们将在第 [12](/reshaping-and-combining-data-sets#reshaping-and-combining-data-sets)
    节中讨论以不同方式组合 `矩阵` 对象。
- en: 4.3 Exercises
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 练习
- en: 4.3.1 R Questions
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 R 问题
- en: Consider the following data set. Let \(N = 20\) be the number of rows. For \(i=1,\ldots,N\),
    define \(\mathbf{x}_i \in \mathbb{R}^4\) as the data in row \(i\).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下数据集。设 \(N = 20\) 为行数。对于 \(i=1,\ldots,N\)，定义 \(\mathbf{x}_i \in \mathbb{R}^4\)
    为第 \(i\) 行的数据。
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For the following problems, make sure to only use the transpose function `t()`,
    matrix multiplication (i.e. `%*%`), and scalar multiplication/division. You may
    use other functions in interactive mode to check your work, but please do not
    use them in your submission.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下问题，请确保只使用转置函数 `t()`、矩阵乘法（即 `%*%`）和标量乘法/除法。你可以在交互模式下使用其他函数来检查你的工作，但请不要在提交中使用它们。
- en: Calculate the sample mean \(\bar{\mathbf{x}} = \frac{1}{N} \sum_{i=1}^N \mathbf{x}_i\).
    Check your work with `colMeans()`, **but don’t use that function in your submitted
    code.** Assign it to the variable `xbar`. Make sure it is a \(4 \times 1\) `matrix`
    object.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算样本均值 \(\bar{\mathbf{x}} = \frac{1}{N} \sum_{i=1}^N \mathbf{x}_i\)。用 `colMeans()`
    检查你的工作，**但不要在提交的代码中使用该函数**。将其分配给变量 `xbar`。确保它是一个 \(4 \times 1\) 的 `矩阵` 对象。
- en: Calculate the \(4 \times 4\) sample covariance of the following data. Call the
    variable `mySampCov`, and make sure it is also a `matrix` object. **You can check
    your work with `cov()`, but don’t use it in your submitted code.** A formula for
    the sample covariance is \[\begin{equation} \frac{1}{N-1} \sum_{i=1}^N (\mathbf{x}_i
    - \bar{\mathbf{x}})(\mathbf{x}_i - \bar{\mathbf{x}})^\intercal \end{equation}\]
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算以下数据的 \(4 \times 4\) 样本协方差。将变量命名为 `mySampCov`，并确保它也是一个 `矩阵` 对象。**你可以用 `cov()`
    检查你的工作，但不要在提交的代码中使用它**。样本协方差的公式为 \[\begin{equation} \frac{1}{N-1} \sum_{i=1}^N
    (\mathbf{x}_i - \bar{\mathbf{x}})(\mathbf{x}_i - \bar{\mathbf{x}})^\intercal \end{equation}\]
- en: Create a `matrix` called `P` that has one hundred rows, one hundred columns,
    all of its elements nonnegative, \(1/10\) on every diagonal element, and all rows
    summing to one. This matrix is called **stochastic** and it describes how a Markov
    chain moves randomly through time.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `P` 的 `矩阵`，它有一百行，一百列，所有元素非负，每个对角线元素为 \(1/10\)，所有行之和为 \(1\)。这个矩阵被称为**随机矩阵**，它描述了马尔可夫链如何随机随时间移动。
- en: Create a `matrix` called `X` that has one thousand rows, four columns, has every
    element set to either \(0\) or \(1\), has its first column set to all \(1\)s,
    has the second column set to \(1\) in the second \(250\) elements and \(0\) elsewhere,
    has the third column set to \(1\) in the third \(250\) spots and \(0\) elsewhere,
    and has the fourth column set to \(1\) in the last \(250\) spots and \(0\) elsewhere.
    In other words, it looks something like
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `X` 的 `矩阵`，它有一千行，四列，每个元素都设置为 \(0\) 或 \(1\)，其第一列设置为全 \(1\)，第二列在第二 \(250\)
    个元素中设置为 \(1\)，其他地方设置为 \(0\)，第三列在第三 \(250\) 个位置中设置为 \(1\)，其他地方设置为 \(0\)，第四列在最后
    \(250\) 个位置中设置为 \(1\)，其他地方设置为 \(0\)。换句话说，它看起来像这样
- en: \[\begin{equation} \begin{bmatrix} \mathbf{1}_{250} & \mathbf{0}_{250} & \mathbf{0}_{250}
    & \mathbf{0}_{250} \\ \mathbf{1}_{250} & \mathbf{1}_{250} & \mathbf{0}_{250} &
    \mathbf{0}_{250} \\ \mathbf{1}_{250} & \mathbf{0}_{250} & \mathbf{1}_{250} & \mathbf{0}_{250}
    \\ \mathbf{1}_{250} & \mathbf{0}_{250} & \mathbf{0}_{250} & \mathbf{1}_{250} \\
    \end{bmatrix} \end{equation}\] where \(\mathbf{1}_{250}\) and \(\mathbf{0}_{250}\)
    are length \(250\) column vectors with all of their elements set to \(1\) or \(0\),
    respectively.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{equation} \begin{bmatrix} \mathbf{1}_{250} & \mathbf{0}_{250} & \mathbf{0}_{250}
    & \mathbf{0}_{250} \\ \mathbf{1}_{250} & \mathbf{1}_{250} & \mathbf{0}_{250} &
    \mathbf{0}_{250} \\ \mathbf{1}_{250} & \mathbf{0}_{250} & \mathbf{1}_{250} & \mathbf{0}_{250}
    \\ \mathbf{1}_{250} & \mathbf{0}_{250} & \mathbf{0}_{250} & \mathbf{1}_{250} \\
    \end{bmatrix} \end{equation}\] 其中 \(\mathbf{1}_{250}\) 和 \(\mathbf{0}_{250}\)
    是长度为 \(250\) 的列向量，它们的元素分别全部设置为 \(1\) 或 \(0\)。
- en: Compute the **projection (or hat) matrix** \(\mathbf{H} := \mathbf{X}\left(\mathbf{X}^\intercal
    \mathbf{X}\right)^{-1} \mathbf{X}^\intercal\). Make it a `matrix` and call it
    `H`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算投影（或帽）矩阵 \(\mathbf{H} := \mathbf{X}\left(\mathbf{X}^\intercal \mathbf{X}\right)^{-1}
    \mathbf{X}^\intercal\)。将其作为一个 `矩阵`，并命名为 `H`。
- en: 'An **exchangeable** covariance matrix for a random vector is a covariance matrix
    that has all the same variances, and all the same covariances. In other words,
    it has two unique elements: the diagonal elements should be the same, and the
    off-diagonals should be the same. In R, generate ten \(100 \times 100\) **exchangeable**
    covariance matrices, each with \(2\) as the variance, and have the possible covariances
    take values in the collection \(0,.01,.02, ..., .09.\) Store these ten covariance
    matrices in a three-dimensional array. The first index should be each matrix’s
    row index, the second should be the column index of each matrix, and the third
    index should be the “layer” or “slice” indicating which of the \(10\) matrices
    you have. Name this array `myCovMats`'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于一个随机向量，**可交换**的协方差矩阵是一个具有所有相同方差和所有相同协方的协方差矩阵。换句话说，它有两个独特的元素：对角线元素应该相同，非对角线元素也应该相同。在
    R 中，生成十个 \(100 \times 100\) 的**可交换**协方差矩阵，每个矩阵的方差为 \(2\)，可能的协方差取值在集合 \(0,.01,.02,
    ..., .09\) 中。将这些十个协方差矩阵存储在一个三维数组中。第一个索引应该是每个矩阵的行索引，第二个索引应该是每个矩阵的列索引，第三个索引应该是“层”或“切片”，表示你拥有的
    \(10\) 个矩阵中的哪一个。将这个数组命名为 `myCovMats`
- en: In R, generate one hundred \(10 \times 10\) **exchangeable** covariance matrices,
    each with \(2\) as the variance, and have the possible covariances take values
    in the collection \(0,0.0009090909, ..., 0.0890909091, .09.\) Store these \(100\)
    covariance matrices in a three-dimensional array. The first index should be each
    matrix’s row index, the second should be the column index of each matrix, and
    the third index should be the “layer” or “slice” indicating which of the \(100\)
    matrices you have. Name this array `myCovMats2`
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 R 中，生成一百个 \(10 \times 10\) 的**可交换**协方差矩阵，每个矩阵的方差为 \(2\)，可能的协方差值在集合 \(0,0.0009090909,
    ..., 0.0890909091, .09.\) 中。将这些 \(100\) 个协方差矩阵存储在一个三维数组中。第一个索引应该是每个矩阵的行索引，第二个索引应该是每个矩阵的列索引，第三个索引应该是“层”或“切片”，表示你有哪些
    \(100\) 个矩阵。将这个数组命名为 `myCovMats2`
- en: 4.3.2 Python Questions
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 Python 问题
- en: Let \(\mathbf{X}\) be an \(n \times 1\) random vector. It has a multivariate
    normal distribution with mean vector \(\mathbf{m}\) and positive definite covariance
    matrix \(\mathbf{C}\) if its probability density function can be written as
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 设 \(\mathbf{X}\) 是一个 \(n \times 1\) 的随机向量。如果它的概率密度函数可以写成
- en: \[\begin{equation} f(\mathbf{x}; \mathbf{m}, \mathbf{C}) = (2\pi)^{-n/2}\text{det}\left(
    \mathbf{C} \right)^{-1/2}\exp\left[- \frac{1}{2} (\mathbf{x}- \mathbf{m})^\intercal
    \mathbf{C}^{-1} (\mathbf{x}- \mathbf{m}) \right] \end{equation}\]
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{equation} f(\mathbf{x}; \mathbf{m}, \mathbf{C}) = (2\pi)^{-n/2}\text{det}\left(
    \mathbf{C} \right)^{-1/2}\exp\left[- \frac{1}{2} (\mathbf{x}- \mathbf{m})^\intercal
    \mathbf{C}^{-1} (\mathbf{x}- \mathbf{m}) \right] \end{equation}\]
- en: Evaluating this density should be done with care. There is no one function that
    is optimal for all situations. Here are a couple quick things to consider.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 评估这个密度需要小心。没有一种函数对所有情况都是最优的。这里有一些快速考虑的事项。
- en: Inverting very large matrices with either [`np.linalg.solve`](https://numpy.org/doc/stable/reference/generated/numpy.linalg.solve.html)
    or [`np.linalg.inv`](https://numpy.org/doc/stable/reference/generated/numpy.linalg.inv.html)
    becomes very slow if the covariance matrix is high-dimensional. If you have special
    assumptions about the structure of the covariance matrix, use it! Also, it’s a
    good idea to be aware of what happens when you try to invert noninvertible matrices.
    For instance, can you rely on errors to be thrown, or will it return a bogus answer?
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果协方差矩阵是高维的，使用 `np.linalg.solve` 或 `np.linalg.inv` 来求逆非常大的矩阵会变得非常慢。如果你对协方差矩阵的结构有特殊的假设，请使用它！另外，了解当你尝试求不可逆矩阵的逆时会发生什么也是一个好主意。例如，你能依赖错误被抛出，还是它将返回一个错误的结果？
- en: Recall from the last lab that exponentiating numbers close to \(-\infty\) risks
    numerical underflow. It’s better to prefer evaluating log densities (base \(e\),
    the natural logarithm). There are also [special functions that evaluate log determinants](https://numpy.org/doc/stable/reference/generated/numpy.linalg.slogdet.html)
    that are less likely to underflow/overflow, too!
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从上一个实验中回忆起来，对接近 \(-\infty\) 的数字进行指数运算可能会出现数值下溢。最好是优先评估对数密度（以 \(e\) 为底，自然对数）。还有[特殊函数可以评估对数行列式](https://numpy.org/doc/stable/reference/generated/numpy.linalg.slogdet.html)，这些函数不太可能下溢/溢出！
- en: 'Complete the following problems. **Do not use pre-made functions such as [`scipy.stats.norm`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.norm.html)
    and [`scipy.stats.multivariate_normal`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.multivariate_normal.html)
    in your submission, but you may use them to check your work. Use only “standard”
    functions and Numpy n-dimensional arrays.** Use the following definitions for
    \(\mathbf{x}\) and \(\mathbf{m}\):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 完成以下问题。**不要使用预定义的函数，如 `scipy.stats.norm` 和 `scipy.stats.multivariate_normal`，在你的提交中，但你可以使用它们来检查你的工作。只使用“标准”函数和
    Numpy n 维数组。**使用以下定义的 \(\mathbf{x}\) 和 \(\mathbf{m}\)：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let \(\mathbf{C} = \begin{bmatrix} 10 & 0 & 0 \\ 0 & 10 & 0 \\ 0 & 0 & 10 \end{bmatrix}\).
    Evaluate and assign the log density to a `float`-like called `log_dens1`. Can
    you do this without defining a numpy array for \(\mathbf{C}\)?
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设 \(\mathbf{C} = \begin{bmatrix} 10 & 0 & 0 \\ 0 & 10 & 0 \\ 0 & 0 & 10 \end{bmatrix}\)。评估并分配对数密度到一个名为
    `log_dens1` 的 `float` 类型的变量。你能在不定义一个用于 \(\mathbf{C}\) 的 numpy 数组的情况下完成这个任务吗？
- en: Let \(\mathbf{C} = \begin{bmatrix} 10 & 0 & 0 \\ 0 & 11 & 0 \\ 0 & 0 & 12 \end{bmatrix}\).
    Evaluate and assign the log density to a `float`-like called `log_dens2`. Can
    you do this without defining a numpy array for \(\mathbf{C}\)?
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设 \(\mathbf{C} = \begin{bmatrix} 10 & 0 & 0 \\ 0 & 11 & 0 \\ 0 & 0 & 12 \end{bmatrix}\)。评估并将对数密度分配给一个类似
    `float` 的变量 `log_dens2`。你能在不定义 \(\mathbf{C}\) 的 numpy 数组的情况下完成这个任务吗？
- en: Let \(\mathbf{C} = \begin{bmatrix} 10 & -.9 & -.9 \\ -.9 & 11 & -.9 \\ -.9 &
    -.9 & 12 \end{bmatrix}\). Evaluate and assign the log density to a `float`-like
    called `log_dens3`. Can you do this without defining a numpy array for \(\mathbf{C}\)?
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设 \(\mathbf{C} = \begin{bmatrix} 10 & -.9 & -.9 \\ -.9 & 11 & -.9 \\ -.9 & -.9
    & 12 \end{bmatrix}\). 评估并将对数密度分配给一个类似 `float` 的变量 `log_dens3`。你能在不定义 \(\mathbf{C}\)
    的 numpy 数组的情况下完成这个任务吗？
- en: Consider this [wine data set](https://archive.ics.uci.edu/ml/datasets/Wine+Quality)
    from (Cortez et al. [2009](#ref-wine_data)) hosted by (Dua and Graff [2017](#ref-uci_data)).
    Read it in with the following code. Note that you might need to use `os.chdir()`
    first.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个来自 (Cortez 等人 [2009](#ref-wine_data))，由 (Dua 和 Graff [2017](#ref-uci_data))
    提供的 [葡萄酒数据集](https://archive.ics.uci.edu/ml/datasets/Wine+Quality)。使用以下代码读取它。注意，你可能需要先使用
    `os.chdir()`。
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Create the **design matrix** (denoted mathematically by \(\mathbf{X}\)) by removing
    the `"quality"` column, and subtracting the column mean from each element. Call
    the variable `X`, and make sure that it is a Numpy `ndarray`, not a Pandas `DataFrame`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过删除 `"quality"` 列，并从每个元素中减去列均值来创建 **设计矩阵**（在数学上表示为 \(\mathbf{X}\)）。将变量命名为 `X`，并确保它是一个
    Numpy `ndarray`，而不是 Pandas `DataFrame`。
- en: 'Compute the **spectral decomposition** of \(\mathbf{X}^\intercal \mathbf{X}\).
    In other words, find “special” matrices[⁸](#fn8) \(\mathbf{V}\) and \(\boldsymbol{\Lambda}\)
    such that \(\mathbf{X}^\intercal \mathbf{X} = \mathbf{V} \boldsymbol{\Lambda}
    \mathbf{V}^\intercal\). Note that the *eigenvectors* are stored as columns in
    a matrix \(\mathbf{V} := \begin{bmatrix} \mathbf{V}_1 & \cdots & \mathbf{V}_{11}\end{bmatrix}\),
    and the scalar *eigenvalues* are stored as diagonal elements \(\boldsymbol{\Lambda}
    = \text{diag}(\lambda_1, \ldots, \lambda_{11})\). Store the eigenvectors in an
    `ndarray` called `eig_vecs`, and store the eigenvalues in a Numpy `array` called
    `eig_vals`. Hint: use [`np.linalg.eig()`](https://numpy.org/doc/stable/reference/generated/numpy.linalg.eig.html).
    Also, if you’re rusty with your linear algebra, don’t worry too much about refreshing
    your memory about what eigenvectors and eigenvalues are.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 \(\mathbf{X}^\intercal \mathbf{X}\) 的 **谱分解**。换句话说，找到“特殊”矩阵[⁸](#fn8) \(\mathbf{V}\)
    和 \(\boldsymbol{\Lambda}\)，使得 \(\mathbf{X}^\intercal \mathbf{X} = \mathbf{V} \boldsymbol{\Lambda}
    \mathbf{V}^\intercal\)。注意，*特征向量*存储在矩阵 \(\mathbf{V} := \begin{bmatrix} \mathbf{V}_1
    & \cdots & \mathbf{V}_{11}\end{bmatrix}\) 的列中，而标量 *特征值*存储为对角元素 \(\boldsymbol{\Lambda}
    = \text{diag}(\lambda_1, \ldots, \lambda_{11})\)。将特征向量存储在一个名为 `eig_vecs` 的 `ndarray`
    中，并将特征值存储在一个名为 `eig_vals` 的 Numpy `array` 中。提示：使用 `np.linalg.eig()`。如果你对线性代数不太熟悉，不必过于担心刷新你的记忆关于特征向量和特征值是什么。
- en: Compute the **singular value decomposition** of \(\mathbf{X}\). In other words,
    find “special”[⁹](#fn9) matrices \(\mathbf{U}\), \(\mathbf{\Sigma}\), and \(\mathbf{V}\)
    such that \(\mathbf{X} = \mathbf{U} \mathbf{\Sigma} \mathbf{V}^\intercal\). Use
    [`np.linalg.svd`](https://numpy.org/doc/stable/reference/generated/numpy.linalg.svd.html),
    and don’t worry too much about the mathematical details. These two decompositions
    are related. If you do it correctly, the two \(\mathbf{V}\) matrices should be
    the same, and the elements of \(\boldsymbol{\Sigma}\) should be the square roots
    of the elements of \(\boldsymbol{\Lambda}\). Store the eigenvectors as columns
    in an `ndarray` called `eig_vecs_v2`, and store the singular values (diagonal
    elements of \(\boldsymbol{\Sigma}\)) in a Numpy `array` called `sing_vals`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 \(\mathbf{X}\) 的 **奇异值分解**。换句话说，找到“特殊”[⁹](#fn9) 矩阵 \(\mathbf{U}\)，\(\mathbf{\Sigma}\)，和
    \(\mathbf{V}\)，使得 \(\mathbf{X} = \mathbf{U} \mathbf{\Sigma} \mathbf{V}^\intercal\)。使用
    `np.linalg.svd`，并且不必过于担心数学细节。这两个分解是相关的。如果你做对了，两个 \(\mathbf{V}\) 矩阵应该相同，而 \(\boldsymbol{\Sigma}\)
    的元素应该是 \(\boldsymbol{\Lambda}\) 元素的平方根。将特征向量作为名为 `eig_vecs_v2` 的 `ndarray` 的列存储，并将奇异值（\(\boldsymbol{\Sigma}\)
    的对角元素）存储在一个名为 `sing_vals` 的 Numpy `array` 中。
- en: Compute the **first principal component** vector, and call it `first_pc_v1`.
    The mathematical formula is \(\mathbf{X} \mathbf{U}_1\) where \(\mathbf{U}_1\)
    is the eigenvector associated with the largest eigenvalue \(\lambda_1\). This
    can be thought of as, in a sense, the most informative predictor that you can
    create by averaging together all other predictors.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算第一个主成分向量，并将其命名为 `first_pc_v1`。其数学公式是 \(\mathbf{X} \mathbf{U}_1\)，其中 \(\mathbf{U}_1\)
    是与最大特征值 \(\lambda_1\) 相关的特征向量。这可以理解为，在某种意义上，通过平均所有其他预测因子所能创建的最具信息量的预测因子。
- en: References
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Albon, Chris. 2018\. *Machine Learning with Python Cookbook: Practical Solutions
    from Preprocessing to Deep Learning*. 1st ed. O’Reilly Media, Inc.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 'Albon, Chris. 2018. *Machine Learning with Python Cookbook: Practical Solutions
    from Preprocessing to Deep Learning*. 1st ed. O’Reilly Media, Inc.'
- en: 'Cortez, Paulo, António Cerdeira, Fernando Almeida, Telmo Matos, and José Reis.
    2009\. “Modeling Wine Preferences by Data Mining from Physicochemical Properties.”
    *Decis. Support Syst.* 47 (4): 547–53\. [http://dblp.uni-trier.de/db/journals/dss/dss47.html#CortezCAMR09](http://dblp.uni-trier.de/db/journals/dss/dss47.html#CortezCAMR09).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 'Cortez, Paulo, António Cerdeira, Fernando Almeida, Telmo Matos, and José Reis.
    2009. “通过数据挖掘物理化学性质建模葡萄酒偏好。” *Decis. Support Syst.* 47 (4): 547–53. [http://dblp.uni-trier.de/db/journals/dss/dss47.html#CortezCAMR09](http://dblp.uni-trier.de/db/journals/dss/dss47.html#CortezCAMR09).'
- en: Dua, Dheeru, and Casey Graff. 2017\. “UCI Machine Learning Repository.” University
    of California, Irvine, School of Information; Computer Sciences. [http://archive.ics.uci.edu/ml](http://archive.ics.uci.edu/ml).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Dua, Dheeru, and Casey Graff. 2017. “UCI Machine Learning Repository.” University
    of California, Irvine, School of Information; Computer Sciences. [http://archive.ics.uci.edu/ml](http://archive.ics.uci.edu/ml).
- en: 'Matloff, Norman. 2011\. *The Art of R Programming: A Tour of Statistical Software
    Design*. 1st ed. USA: No Starch Press.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 'Matloff, Norman. 2011. *The Art of R Programming: A Tour of Statistical Software
    Design*. 1st ed. USA: No Starch Press.'
- en: '* * *'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Technically, the distinction between all of these containers is more subtle.
    An `array` in R can have one, two or more dimensions, and it is just a vector
    which is stored with additional dimension attributes. Moreover, a 2-dimensional
    array is the same as a `matrix`.[↩](/numpy-ndarrays-versus-rs-matrix-and-array-types#fnref7)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从技术角度来看，这些容器之间的区别更为微妙。在 R 中，一个 `array` 可以有一维、二维或更多维度，它只是一个带有额外维度属性的向量。此外，二维数组与
    `matrix` 是相同的。[↩](/numpy-ndarrays-versus-rs-matrix-and-array-types#fnref7)
- en: Do not worry too much about the properties of these matrices for this problem[↩](/numpy-ndarrays-versus-rs-matrix-and-array-types#fnref8)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个问题，你不必过于担心这些矩阵的性质。[↩](/numpy-ndarrays-versus-rs-matrix-and-array-types#fnref8)
- en: Again, do not worry too much about the properties of these matrices for this
    problem.[↩](/numpy-ndarrays-versus-rs-matrix-and-array-types#fnref9)
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次强调，对于这个问题，你不必过于担心这些矩阵的性质。[↩](/numpy-ndarrays-versus-rs-matrix-and-array-types#fnref9)
