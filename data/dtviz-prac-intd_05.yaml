- en: 4 Show the right numbers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 显示正确的数字
- en: 原文：[https://socviz.co/groupfacettx.html](https://socviz.co/groupfacettx.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://socviz.co/groupfacettx.html](https://socviz.co/groupfacettx.html)
- en: This Chapter will continue to develop your fluency with ggplot’s central workflow,
    while also expanding the range of things you can do with it. One of our goals
    is to learn how to make new kinds of graph. This means learning some new geoms,
    the functions that make particular kinds of plots. But we will also get a better
    sense of what ggplot is doing when it draws plots, and learn more about how to
    write code that prepares our data to be plotted.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续提高您使用ggplot核心工作流程的流畅度，同时扩展您可以使用它完成的事情的范围。我们的一个目标就是学习如何制作新的图表类型。这意味着需要学习一些新的几何对象（geoms），即制作特定类型图表的函数。但我们也将对ggplot在绘制图表时所做的操作有更好的理解，并学习更多关于如何编写准备数据以便绘制的代码。
- en: Code almost never works properly the first time you write it. This is the main
    reason that, when learning a new language, it is important to type out the exercises
    and follow along manually. It gives you a much better sense of how the syntax
    of the language works, where you’re likely to make errors, and what the computer
    does when that happens. Running into bugs and errors is frustrating, but it’s
    also an opportunity to learn a bit more. Errors can be obscure but they are usually
    not malicious or random. If something has gone wrong, you can find out why it
    happened.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 代码几乎永远不会在第一次编写时就正确无误。这就是在学习一门新语言时，重要的是要手动输入练习并跟随操作的原因。这能让你更好地理解语言语法的工作方式，你可能会犯的错误，以及当这种情况发生时计算机做了什么。遇到错误和故障是令人沮丧的，但这也是学习更多知识的机会。错误可能很隐蔽，但通常它们并不是恶意的或随机的。如果出了问题，你可以找出原因。
- en: In R and ggplot, errors in code can result in figures that don’t look right.
    We have already seen the result of one of the most common problems, when an aesthetic
    is mistakenly set to a constant value instead of being mapped to a variable. In
    this chapter we will discuss some useful features of ggplot that also commonly
    cause trouble. They have to do with how to tell ggplot more about the internal
    structure of your data (*grouping*), how to break up your data into pieces for
    a plot (*faceting*), and how to get ggplot to perform some calculations on or
    summarize your data before producing the plot (*transforming*). Some of these
    tasks are part of ggplot proper, and so we will learn more about how geoms, with
    the help of their associated *stat* functions, can act on data before plotting
    it. As we shall also see, while it is possible to do a lot of transformation directly
    in ggplot, there can be more convenient ways to approach the same task.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在R和ggplot中，代码中的错误可能导致看起来不正确的图形。我们已经看到了最常见问题之一的结果，即当美学错误地设置为常量值而不是映射到变量时。在本章中，我们将讨论ggplot的一些有用特性，这些特性也经常引起麻烦。它们与如何让ggplot更多地了解你数据的内部结构（*分组*），如何将数据拆分成用于图表的片段（*分面*），以及如何在生成图表之前让ggplot对数据进行一些计算或汇总有关。其中一些任务属于ggplot本身，因此我们将学习更多关于如何通过其关联的*统计*函数，geoms在绘图之前对数据进行操作。正如我们也将看到的，虽然直接在ggplot中进行大量转换是可能的，但可能会有更方便的方法来完成相同的任务。
- en: 4.1 Colorless green data sleeps furiously
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 无色的绿色数据疯狂地睡觉
- en: When you write ggplot code in R you are in effect trying to “say” something
    visually. It usually takes several iterations to say exactly what you mean. This
    is more than a metaphor here. The ggplot library is an implementation of the “grammar”
    of graphics, an idea developed by Wilkinson (2005). The grammar is a set of rules
    for producing graphics from data, taking pieces of data and mapping them to geometric
    objects (like points and lines) that have aesthetic attributes (like position,
    color and size), together with further rules for transforming the data if needed
    (e.g. to a smoothed line), adjusting scales (e.g. to a log scale),We will see
    some alternatives to cartesian coordinates later. and projecting the results onto
    a different coordinate system (usually cartesian).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在R中编写ggplot代码时，实际上是在尝试“表达”某种视觉上的东西。通常需要多次迭代才能准确地表达你的意图。这里不仅仅是一个比喻。ggplot库是Wilkinson（2005）提出的“图形语法”的实现。语法是一套从数据生成图形的规则，它将数据片段映射到具有美学属性（如位置、颜色和大小）的几何对象（如点和线），以及如果需要的话，对数据进行进一步转换的规则（例如，转换为平滑线），调整刻度（例如，对数刻度），我们将在稍后看到一些替代笛卡尔坐标的方法，并将结果投影到不同的坐标系（通常是笛卡尔坐标系）。
- en: A key point is that, like other rules of syntax, the grammar limits the structure
    of what you can say, but it does not automatically make what you say sensible
    or meaningful. It allows you to produce long “sentences” that begin with mappings
    of data to visual elements and add clauses about what sort of plot it is, how
    the axes are scaled, and so on. But these sentences can easily be garbled. Sometimes
    your code will not produce a plot at all because of some syntax error in R. You
    will forget a `+` sign between `geom_` functions, or lose a parenthesis somewhere
    so that your function statement becomes unbalanced. In those cases R will complain
    (perhaps in an opaque way) that something has gone wrong. At other times, your
    code will successfully produce a plot, but it will not look the way you expected
    it to. Sometimes the results will look very weird indeed. In those cases, the
    chances are you have given ggplot a series of grammatically correct instructions
    that are either nonsensical in some way, or have accidentally twisted what you
    meant to say. These problems often arise when ggplot does not have quite all the
    information it needs in order make your graphic say what you want it to say.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键点是，就像其他语法规则一样，语法限制了你可以说的结构的范围，但它不会自动使你说的话变得合理或有意义。它允许你产生以将数据映射到视觉元素开始的“长句子”，并添加关于它是何种图表、坐标轴如何缩放等子句。但是这些句子很容易被搞乱。有时你的代码在
    R 中会因为一些语法错误而根本无法生成图表。你可能会忘记在 `geom_` 函数之间加上 `+` 符号，或者丢失某个括号，使得你的函数声明变得不平衡。在这些情况下，R
    会抱怨（可能以某种晦涩的方式）说出了些问题。在其他时候，你的代码可能会成功生成图表，但它看起来并不是你预期的样子。有时结果看起来确实非常奇怪。在这些情况下，很可能你给了
    ggplot 一系列语法上正确的指令，但这些指令在某些方面可能是无意义的，或者意外地扭曲了你原本想要表达的意思。这些问题通常出现在 ggplot 没有完全获得它需要的信息来制作你想要它说的图形时。
- en: 4.2 Grouped data and the “group” aesthetic
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 分组数据和“group”美学
- en: 'Let’s begin again with our Gapminder dataset. Imagine we wanted to plot the
    trajectory of life expectancy over time for each country in the data. We map `year`
    to `x` and `lifeExp` to `y`. We take a quick look at the documentation and discover
    that `geom_line()` will draw lines by connecting observations in order of the
    variable on the x-axis, which seems right. We write our code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Gapminder 数据集重新开始。想象一下，我们想要绘制每个国家在数据中生命预期随时间变化的轨迹。我们将 `year` 映射到 `x` 轴，将
    `lifeExp` 映射到 `y` 轴。我们快速查看文档，发现 `geom_line()` 会按照 x 轴上变量的顺序连接观察值来绘制线条，这似乎是正确的。我们编写了以下代码：
- en: '![Trying to plot the data over time by country.](../Images/13e4a87d0b85be4bf9aaa5565bf105ab.png)
    Figure 4.1: Trying to plot the data over time by country.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '![尝试按国家绘制数据随时间的变化。](../Images/13e4a87d0b85be4bf9aaa5565bf105ab.png) 图 4.1：尝试按国家绘制数据随时间的变化。'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Something has gone wrong. What happened? While ggplot will make a pretty good
    guess as to the structure of the data, it does not know that the yearly observations
    in the data are grouped by country. We have to tell it. Because we have not, `geom_line()`
    gamely tries to join up all the lines for each particular year in the order they
    appear in the dataset, as promised. It starts with an observation for 1952 in
    the first row of the data. It doesn’t know this belongs to Afghanistan. Instead
    of going to Afghanistan 1953, it finds there are a series of 1952 observations,
    so it joins all of those up first, alphabetically by country, all the way down
    to the 1952 observation that belongs to Zimbabwe. Then it moves to the first observation
    in the next year, 1957.This would have worked if there were only one country in
    the dataset.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 出了些问题。发生了什么？虽然 ggplot 会根据数据结构做出相当好的猜测，但它并不知道数据中的年度观察值是按国家分组的。我们必须告诉它。因为我们没有这样做，`geom_line()`
    仍然努力按照数据集中出现的顺序连接每个特定年份的所有线条，正如它所承诺的那样。它从数据的第一行中的 1952 年观察值开始。它不知道这属于阿富汗。它没有去阿富汗
    1953 年，而是发现有一系列 1952 年的观察值，所以它首先将这些观察值按国家字母顺序连接起来，一直到最后属于津巴布韦的 1952 年观察值。然后它移动到下一年的第一个观察值，即
    1957 年。如果数据集中只有一个国家，这本来是可以工作的。
- en: The result is meaningless when plotted. Bizarre-looking output in ggplot is
    common enough, because everyone works out their plots one bit at a time, and making
    mistakes is just a feature of puzzling out how you want the plot to look. When
    ggplot successfully makes a plot but the result looks insane, the reason is almost
    always that something has gone wrong in the mapping between the data and aesthetics
    for the geom being used. This is so common there’s even a [Twitter account](https://twitter.com/accidental__art)
    devoted to the “Accidental aRt” that results. So don’t despair!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当绘制时，结果是毫无意义的。在ggplot中，看起来奇怪的输出很常见，因为每个人都是一点一点地解决他们的图表，犯错误只是弄清楚你想要图表看起来怎样的一个特征。当ggplot成功制作了一个图表，但结果看起来疯狂时，几乎总是因为数据与用于几何对象的美学之间的映射出了问题。这种情况很常见，以至于甚至有一个[推特账号](https://twitter.com/accidental__art)专门用于“意外艺术”的结果。所以不要绝望！
- en: In this case, we can use the `group` aesthetic to tell ggplot explicitly about
    this country-level structure.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以使用`group`美学明确告诉ggplot关于这种国家级别结构的信息。
- en: '![Plotting the data over time by country, again.](../Images/96c7456a2639085700e54274b64c86cc.png)
    Figure 4.2: Plotting the data over time by country, again.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![按国家时间序列绘制数据，再次。](../Images/96c7456a2639085700e54274b64c86cc.png) 图4.2：按国家时间序列绘制数据，再次。'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The plot here is still fairly rough, but it is showing the data properly, with
    each line representing the trajectory of a country over time. The gigantic outlier
    is Kuwait, in case you are interested.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的图表仍然相当粗糙，但它正确地显示了数据，每条线代表一个国家随时间变化的轨迹。如果你感兴趣的话，巨大的异常值是科威特。
- en: The `group` aesthetic is usually only needed when the grouping information you
    need to tell ggplot about is not built-in to the variables being mapped. For example,
    when we were plotting the points by continent, mapping `color` to `continent`
    was enough to get the right answer, because `continent` is already a categorical
    variable, so the grouping is clear. When mapping the `x` to `year`, however, there
    is no information in the `year` variable itself to let ggplot know that it is
    grouped by country for the purposes of drawing lines with it. So we need to say
    that explicitly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`group`美学通常只在需要告诉ggplot的分组信息不是映射变量的内置信息时才需要。例如，当我们按大陆绘制点时，将`color`映射到`continent`就足以得到正确答案，因为`continent`已经是一个分类变量，所以分组是清晰的。然而，当我们将`x`映射到`year`时，`year`变量本身没有信息让ggplot知道它按国家分组以绘制线条。因此，我们需要明确地说明这一点。'
- en: 4.3 Facet to make small multiples
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 分面以制作小倍数图表
- en: The plot we just made has a lot of lines on it. While the overall trend is more
    or less clear, it looks a little messy. One option is to *facet* the data by some
    third variable, making a “small multiple” plot. This is a very powerful technique
    that allows a lot of information to be presented compactly, and in a consistently
    comparable way. A separate panel is drawn for each value of the faceting variable.
    Facets are not a geom, but rather a way of organizing a series of geoms. In this
    case we have the `continent` variable available to us. We will use `facet_wrap()`
    to split our plot by `continent`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚制作的图表上有许多线条。虽然整体趋势大致清晰，但看起来有些杂乱。一个选择是使用某个第三变量对数据进行*分面*，制作一个“小倍数”图表。这是一种非常强大的技术，它允许以紧凑和一致可比的方式展示大量信息。为分面变量的每个值绘制一个单独的面板。分面不是一种几何对象，而是一种组织一系列几何对象的方式。在这种情况下，我们有`continent`变量可用。我们将使用`facet_wrap()`按`continent`拆分我们的图表。
- en: 'The `facet_wrap()` function can take a series of arguments, but the most important
    is the first one, which is specified using R’s “formula” syntax, which uses the
    tilde character, `~`. Facets are usually a one-sided formula. Most of the time
    you will just want a single variable on the right side of the formula. But faceting
    is powerful enough to accommodate what are in effect the graphical equivalent
    of multi-way contingency tables, if your data is complex enough to require that.
    For our first example, we will just use a single term in our formula, which is
    the variable we want the data broken up by: `facet_wrap(~ continent)`.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`facet_wrap()`函数可以接受一系列参数，但最重要的是第一个参数，它使用R的“公式”语法指定，该语法使用波浪字符`~`。分面通常是一个单侧公式。大多数时候，你只需要在公式的右侧有一个变量。但是，如果数据足够复杂，需要多向列联表的图形等效，分面足够强大以适应这种情况。在我们的第一个例子中，我们将在公式中使用一个单一术语，这是我们想要数据按其拆分的变量：`facet_wrap(~
    continent)`。'
- en: '![Faceting by continent.](../Images/dca4514d8ec42a6f9aabcba51b2de069.png) Figure
    4.3: Faceting by continent.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![按大陆分面](../Images/dca4514d8ec42a6f9aabcba51b2de069.png) 图4.3：按大陆分面。'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Each facet is labeled at the top. The overall layout minimizes the duplication
    of axis labels and other scales. Remember, too that we can still include other
    geoms as before, and they will be layered within each facet. We can also use the
    `ncol` argument to `facet_wrap()` to control the number of columns used to lay
    out the facets. Because we have only five continents it might be worth seeing
    if we can fit them on a single row (which means we’ll have five columns). In addition,
    we can add a smoother, and a few cosmetic enhancements that make the graph a little
    more effective. In particular we will make the country trends a light gray color.
    We need to write a little more code to make all this happen. If you are unsure
    of what each piece of code does, take advantage of ggplot’s additive character.
    Working backwards from the bottom up, remove each `+ some_function(...)` statement
    one at a time to see how the plot changes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分面都在顶部进行了标注。整体布局最小化了轴标签和其他刻度的重复。记住，我们仍然可以像之前一样包含其他几何形状，并且它们将在每个分面内分层。我们还可以使用`facet_wrap()`函数的`ncol`参数来控制用于布局分面的列数。因为我们只有五个大陆，所以看看我们是否可以将它们放在一行上（这意味着我们将有五列）可能是有意义的。此外，我们可以添加一个平滑器，以及一些使图表更有效的美化增强。特别是，我们将使国家趋势的颜色为浅灰色。我们需要编写更多的代码来实现所有这些。如果你不确定每段代码的作用，可以利用ggplot的累加特性。从底部向上，逐个移除每个`+
    some_function(...)`语句，以查看图表如何变化。
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![Faceting by continent, again.](../Images/ef23f240e741e69c5821cbffcd49744d.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![再次按大陆分面](../Images/ef23f240e741e69c5821cbffcd49744d.png)'
- en: 'Figure 4.4: Faceting by continent, again.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：按大陆进行分面，再次。
- en: This plotWe could also have faceted by country, which would have made the group
    mapping superfluous. But that would make almost a hundred and fifty panels. brings
    together an aesthetic mapping of `x` and `y` variables, a grouping aesthetic (`country`),
    two geoms (a lineplot and a smoother), a log-transformed y-axis with appropriate
    tick labels, a faceting variable (`continent`), and finally axis labels and a
    title.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表我们可以通过国家进行分面，这将使分组映射变得多余。但那样会有近一百五十个面板。它将`x`和`y`变量的美学映射、分组美学（`country`）、两个几何形状（线图和平滑器）、对数变换的y轴和适当的刻度标签、分面变量（`continent`）以及最终的轴标签和标题结合在一起。
- en: The `facet_wrap()` function is best used when you want a series of small multiples
    based on a single categorical variable. Your panels will be laid out in order
    and then wrapped into a grid. If you wish you can specify the number or rows or
    the number of columns in the resulting layout. Facets can be more complex than
    this. For instance, you might want to cross-classify some data by two categorical
    variables. In that case you should try `facet_grid()` instead. This function will
    lay out your plot in a true two-dimensional arrangement, instead of a series of
    panels wrapped into a grid.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想根据单个分类变量得到一系列小倍数时，`facet_wrap()`函数使用得最好。你的面板将按顺序排列，然后包裹成一个网格。如果你愿意，你可以指定结果的行数或列数。分面可以比这更复杂。例如，你可能想通过两个分类变量交叉分类一些数据。在这种情况下，你应该尝试使用`facet_grid()`。这个函数将以真正的二维排列来布局你的图表，而不是一系列包裹在网格中的面板。
- en: To see the difference, let’s introduce `gss_sm`, a new dataset that we will
    use in the next few sections, as well as later on in the book. It is a small subset
    of the questions from the 2016 General Social Survey, or GSS. The GSS is a long-running
    survey of American adults that asks about a range of topics of interest to social
    scientists.To begin with, we will use the GSS data in a slightly naive way. In
    particular we will not consider sample weights when making the figures in this
    chapter. In Chapter 6 we will learn how to calculate frequencies and other statistics
    from data with a complex or weighted survey design. The `gapminder` data consists
    mostly of *continuous* variables measured within countries by year. Measures like
    GDP per capita can take any value across a large range and they vary smoothly.
    The only *categorical* grouping variable is `continent`. It is an unordered categorical
    variable. Each country belongs to one continent, but the continents themselves
    have no natural ordering.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到差异，让我们引入`gss_sm`，这是一个新的数据集，我们将在接下来的几节中以及本书的后续部分使用。它是2016年综合社会调查（GSS）中问题的一个小子集。GSS是对美国成年人进行的一项长期调查，调查了社会科学家感兴趣的一系列主题。首先，我们将以略带天真的方式使用GSS数据。特别是，在制作本章中的图表时，我们不会考虑样本权重。在第6章中，我们将学习如何从具有复杂或加权调查设计的数据中计算频率和其他统计量。`gapminder`数据主要由各国按年份测量的*连续*变量组成。如人均GDP这样的度量可以在一个很大的范围内取任何值，并且它们变化平滑。唯一的*分类*分组变量是`continent`。它是一个无序分类变量。每个国家属于一个大陆，但大陆本身没有自然的顺序。
- en: In social scientific work, especially when analyzing individual-level survey
    data, we very often work with categorical data of various kinds. Sometimes the
    categories are unordered, as with ethnicity or sex. But they may also be ordered,
    as when me measure highest level of education attained on a scale ranging from
    elementary school to postgraduate degree. Opinion questions may be asked in yes-or-no
    terms, or on a five or seven point scale with a neutral value in the middle. Meanwhile,
    many numeric measures, such as number of children, may still only take integer
    values within a relatively narrow range. In practice these too may be treated
    as ordered categorical variables running from zero to some top-coded value such
    as “Six or more”. Even properly continuous measures, such as income, are rarely
    reported to the dollar and are often only obtainable as ordered categories. The
    GSS data in `gss_sm` contains many measures of this sort. You can take a peek
    at it, as usual, by typing its name at the console. You could also try `glimpse(gss_sm)`,
    which will give a very compact summary of all the variables in the data.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在社会科学工作中，尤其是在分析个体层面的调查数据时，我们经常处理各种类型的分类数据。有时类别是无序的，如种族或性别。但它们也可能是有序的，例如当我们测量从小学到研究生学位的最高教育水平时。意见问题可能以是或否的形式提出，或者在一个五点或七点量表上，中间有一个中性值。同时，许多数值度量，如孩子数量，可能仍然只在相对较窄的范围内取整数值。在实践中，这些也可以被视为从零到某些上限值（如“六或以上”）的有序分类变量。即使是适当的连续度量，如收入，也很少按美元报告，并且通常只能作为有序类别获得。`gss_sm`中的GSS数据包含许多此类度量。您可以通过在控制台中输入其名称来查看它，或者尝试`glimpse(gss_sm)`，这将给出数据中所有变量的非常紧凑的摘要。
- en: 'We will make a smoothed scatterplot of the relationship between the age of
    the respondent and the number of children they have. In `gss_sm` the `childs`
    variable is a numeric count of the respondent’s children. (There is also a variable
    named `kids` that is the same measure, but its class is an ordered factor rather
    than a number.) We will then facet this relationship by sex and race of the respondent.
    We use R’s formula notation in the `facet_grid` function to facet sex and race.
    This time, because we are cross-classifying our results, the formula is two-sided:
    `facet_grid(sex ~ race)`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绘制一个平滑的散点图，展示受访者年龄与他们拥有的孩子数量之间的关系。在`gss_sm`中，`childs`变量是受访者孩子数量的数值计数。（还有一个名为`kids`的变量，它与`childs`变量是相同的度量，但其类别是一个有序因子而不是数字。）然后我们将通过受访者的性别和种族来细分这种关系。我们在`facet_grid`函数中使用R的公式表示法来细分性别和种族。这次，因为我们正在进行交叉分类，所以公式是双向的：`facet_grid(sex
    ~ race)`。
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Figure 4.5: Faceting on two categorical variables. Each panel plots the relationship
    between age and number of children, with the facets breaking out the data by sex
    (in the rows) and race (in the columns).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：基于两个分类变量的细分。每个面板绘制了年龄与孩子数量的关系，细分部分通过性别（行）和种族（列）来划分数据。
- en: '![Faceting on two categorical variables. Each panel plots the relationship
    between age and number of children, with the facets breaking out the data by sex
    (in the rows) and race (in the columns).](../Images/1f460868c6045f5292cdf1c6e2d517e0.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![在两个分类变量上进行分面。每个面板绘制了年龄与孩子数量的关系，分面通过性别（行）和种族（列）将数据分开。](../Images/1f460868c6045f5292cdf1c6e2d517e0.png)'
- en: Multi-panel layouts of this kind are especially effective when used to summarize
    continuous variation (as in a scatterplot) across two or more categorical variables,
    with the categories (and hence the panels) ordered in some sensible way. We are
    not limited to two-way comparison. Further categorical variables can be added
    to the formula, too, (e.g. `sex ~ race + degree`) for more complex multi-way plots.
    However, the multiple dimensions of plots like this will become very complicated
    very quickly if the variables have more than a few categories each.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种多面板布局在用于总结两个或更多分类变量上的连续变化（如散点图）时特别有效，其中类别（以及因此的面板）以某种合理的方式排序。我们不仅限于双向比较。还可以将更多的分类变量添加到公式中（例如，`sex
    ~ race + degree`）以创建更复杂的多向图。然而，如果每个变量有多个类别，这种图的多个维度会变得非常复杂。
- en: 4.4 Geoms can transform data
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 几何对象可以转换数据
- en: We have already seen several examples where `geom_smooth()` was included as
    a way to add a trend line to the figure. Sometimes we plotted a LOESS line, sometimes
    a straight line from an OLS regression, and sometimes the result of a Generalized
    Additive Model. We did not have to have any strong idea of the differences between
    these methods. Neither did we have to write any code to specify the underlying
    models, beyond telling the `method` argument in `geom_smooth()` which one we wanted
    to use. The `geom_smooth()` function did the rest.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了几个例子，其中`geom_smooth()`被包括在内，作为向图中添加趋势线的一种方式。有时我们绘制了LOESS线，有时是OLS回归的直线，有时是广义加性模型的结果。我们不必对这三种方法之间的差异有强烈的认识。我们也不必编写任何代码来指定底层模型，除了告诉`geom_smooth()`中的`method`参数我们想要使用哪个。`geom_smooth()`函数完成了其余的工作。
- en: 'Thus, some geoms plot our data directly on the figure, as is the case with
    `geom_point()`, which takes variables designated as `x` and `y` and plots the
    points on a grid. But other geoms clearly do more work on the data before it gets
    plotted.Try `p + stat_smooth()`, for example. Every `geom_` function has an associated
    `stat_` function that it uses by default. The reverse is also the case: every
    `stat_` function has an associated `geom_` function that it will plot by default
    if you ask it to. This is not particularly important to know by itself, but as
    we will see in the next section, we sometimes want to calculate a different statistic
    for the geom from the default.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一些几何对象直接在图上绘制我们的数据，就像`geom_point()`一样，它接受被指定为`x`和`y`的变量，并在网格上绘制点。但其他几何对象在绘图之前对数据进行更多的处理。例如尝试`p
    + stat_smooth()`。每个`geom_`函数都有一个关联的`stat_`函数，它默认使用。反之亦然：每个`stat_`函数都有一个关联的`geom_`函数，如果你要求它，它将默认绘制。这本身并不是特别重要，但正如我们将在下一节中看到的，我们有时希望从几何对象计算不同的统计量，而不是默认的。
- en: Sometimes the calculations being done by the `stat_` functions that work together
    with the `geom_` functions might not be immediately obvious. For example, consider
    this figure produced by a new geom, `geom_bar()`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，与`geom_`函数一起工作的`stat_`函数所进行的计算可能并不立即明显。例如，考虑由新的`geom`函数`geom_bar()`生成的这个图。
- en: '![A bar chart.](../Images/43146b8d2717e9fa73fca324ab1d9701.png) Figure 4.6:
    A bar chart.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![条形图。](../Images/43146b8d2717e9fa73fca324ab1d9701.png) 图4.6：条形图。'
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here we specified just one mapping, `aes(x = bigregion)`. The bar chart produced
    gives us a count of the number of (individual) observations in the data set by
    region of the United States. This seems sensible. But there is a y-axis variable
    here, `count`, that is not in the data. It has been calculated for us. Behind
    the scenes, `geom_bar` called the default `stat_` function associated with it,
    `stat_count()`. This function computes two new variables, `count`, and `prop`
    (short for proportion). The `count` statistic is the one `geom_bar()` uses by
    default.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只指定了一个映射，`aes(x = bigregion)`。生成的条形图给出了美国各地区（个体）观测值的数量。这似乎是合理的。但这里有一个不在数据中的y轴变量，`count`，它已经为我们计算过了。在幕后，`geom_bar`调用了与之关联的默认`stat_`函数，`stat_count()`。此函数计算了两个新变量，`count`和`prop`（比例的简称）。`count`统计量是`geom_bar()`默认使用的。
- en: '![A first go at a bar chart with proportions.](../Images/d895e729bfd30955cff742f410fc027e.png)
    Figure 4.7: A first go at a bar chart with proportions.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![一个带有比例的条形图的初次尝试。](../Images/d895e729bfd30955cff742f410fc027e.png) 图4.7：一个带有比例的条形图的初次尝试。'
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we want a chart of relative frequencies rather than counts, we will need
    to get the `prop` statistic instead. When ggplot calculates the count or the proportion,
    it returns temporary variables that we can use as mappings in our plots. The relevant
    statistic is called `..prop..` rather than `prop`. To make sure these temporary
    variables won’t be confused with others we are working with, their names begin
    and end with two periods. (This is because we might already have a variable called
    `count` or `prop` in our dataset.) So our calls to it from the `aes()` function
    will generically look like this: `<mapping> = <..statistic..>`. In this case,
    we want `y` to use the calculated proportion, so we say `aes(y = ..prop..)`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个相对频率而不是计数的图表，我们需要获取`prop`统计量。当ggplot计算计数或比例时，它返回临时变量，我们可以将其用作绘图中的映射。相关的统计量称为`..prop..`而不是`prop`。为了确保这些临时变量不会与其他我们正在使用的变量混淆，它们的名称以两个点开始和结束。（这是因为我们可能已经在数据集中有一个名为`count`或`prop`的变量。）因此，我们从`aes()`函数对其的调用将普遍看起来像这样：`<mapping>
    = <..statistic..>`。在这种情况下，我们希望`y`使用计算出的比例，所以我们说`aes(y = ..prop..)`。
- en: The resulting plot is still not right. We no longer have a count on the y-axis,
    but the proportions of the bars all have a value of 1, so all the bars are the
    same height. We want them to *sum* to 1, so that we get the number of observations
    per continent as a proportion of the total number of observations. This is a grouping
    issue again. In a sense, it’s the reverse of the earlier grouping problem we faced
    when we needed to tell ggplot that our yearly data was grouped by country. In
    this case, we need to tell ggplot to *ignore* the x-categories when calculating
    denominator of the proportion, and use the total number observations instead.
    To do so we specify `group = 1` inside the `aes()` call. The value of `1` is just
    a kind of “dummy group” that tells ggplot to use the whole dataset when establishing
    the denominator for its `prop` calculations.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '结果图仍然不正确。我们不再在y轴上有计数，但所有条形的比例值都是1，因此所有条形的高度都相同。我们希望它们*总和*为1，这样我们就能得到每个大洲的观察数占总观察数的比例。这又是一个分组问题。从某种意义上说，这是我们在需要告诉ggplot我们的年度数据按国家分组时所面临的早期分组问题的反面。在这种情况下，我们需要告诉ggplot在计算比例的分母时*忽略*x类别，并使用总观察数。为此，我们在`aes()`调用中指定`group
    = 1`。`1`只是一个“虚拟分组”的值，告诉ggplot在建立其`prop`计算的分母时使用整个数据集。 '
- en: '![A bar chart with correct proportions.](../Images/d442715fd8354e2e5dffe326391aa143.png)
    Figure 4.8: A bar chart with correct proportions.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![一个正确的比例条形图。](../Images/d442715fd8354e2e5dffe326391aa143.png) 图4.8：一个正确的比例条形图。'
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let’s look at another question from the survey. The `gss_sm` data contains a
    `religion` variable derived from a question asking “What is your religious preference?
    Is it Protestant, Catholic, Jewish, some other religion, or no religion?”
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看调查中的另一个问题。`gss_sm`数据包含一个由问题“你的宗教偏好是什么？是基督教徒、天主教徒、犹太教徒、其他宗教，还是没有宗教？”派生出的`religion`变量。
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ToRecall that the `$` character is one way of accessing individual columns within
    a data frame or tibble. graph this, we want a bar chart with `religion` on the
    x axis (as a categorical variable), and with the bars in the chart also colored
    by `religion`. If the gray bars look boring and we want to fill them with color
    instead, we can map the `religion` variable to `fill` in addition to mapping it
    to `x`. Remember, `fill` is for painting the insides of shapes. If we map religion
    to `color`, only the border lines of the bars will be assigned colors, and the
    insides will remain gray.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要回忆起`$`字符是访问数据框或tibble中单个列的一种方式，我们想要一个条形图，其中`religion`在x轴上（作为一个分类变量），并且条形图中的条形也按`religion`着色。如果灰色条形看起来很无聊，我们想要用颜色填充它们而不是灰色，我们可以将`religion`变量映射到`fill`，除了映射到`x`。记住，`fill`是用来填充形状内部的。如果我们把宗教映射到`color`，只有条形的边框线会被分配颜色，内部将保持灰色。
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Figure 4.9: GSS Religious Preference mapped to color (left) and both color
    and fill (right).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：GSS宗教偏好映射到颜色（左侧）以及颜色和填充（右侧）。
- en: '![GSS Religious Preference mapped to color (left) and both color and fill (right).](../Images/e1f8eb224fc0ea1a1e230d212dc6b3de.png)![GSS
    Religious Preference mapped to color (left) and both color and fill (right).](../Images/0e14eabd1fe63de92809da7f35e9fa61.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![GSS宗教偏好按颜色映射（左）以及颜色和填充（右）](../Images/e1f8eb224fc0ea1a1e230d212dc6b3de.png)![GSS宗教偏好按颜色映射（左）以及颜色和填充（右）](../Images/0e14eabd1fe63de92809da7f35e9fa61.png)'
- en: By doing this, we have mapped two aesthetics to the same variable. Both `x`
    and `fill` are mapped to `religion`. There is nothing wrong with this. However,
    these are still two separate mappings, and so they get two separate scales. The
    default is to show a legend for the color variable. This legend is redundant,
    because the categories of `religion` are already separated out on the x-axis.
    In its simplest use, the `guides()` function controls whether guiding information
    about any particular mapping appears or not. If we set `guides(fill = FALSE)`,
    the legend is removed, in effect saying that the viewer of the figure does not
    need to be shown any guiding information about this mapping. Setting the guide
    for some mapping to `FALSE` only has an effect if there is a legend to turn off
    to begin with. Trying `x = FALSE` or `y = FALSE` will have no effect, as these
    mappings have no additional guides or legends separate from their scales. It is
    possible to turn the x and y scales off altogether, but this is done though a
    different function, one from the `scale_` family.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们将两个美学映射到同一个变量。`x`和`fill`都映射到`religion`。这并没有什么问题。然而，这仍然是两种独立的映射，因此它们各自有不同的刻度。默认情况下，会显示颜色变量的图例。这个图例是多余的，因为`religion`的类别已经在x轴上分开。在其最简单的使用中，`guides()`函数控制是否显示任何特定映射的引导信息。如果我们设置`guides(fill
    = FALSE)`，则图例将被移除，实际上表示观众不需要看到关于此映射的任何引导信息。将某些映射的引导设置为`FALSE`只有在最初有图例可以关闭的情况下才有效。尝试`x
    = FALSE`或`y = FALSE`将不会有任何效果，因为这些映射没有除其刻度之外的其他引导或图例。有可能完全关闭x和y刻度，但这是通过不同的函数完成的，该函数来自`scale_`家族。
- en: 4.5 Frequency plots the slightly awkward way
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 频率图以略感尴尬的方式呈现
- en: A more appropriate use of the `fill` aesthetic with `geom_bar()` is to cross-classify
    two categorical variables. This is the graphical equivalent of a frequency table
    of counts or proportions. Using the GSS data, for instance, we might want to examine
    the distribution of religious preferences within different regions of the United
    States. In the next few paragraphs we will see how to do this just using ggplot.
    However, as we shall also discover, it is often not the most transparent way to
    make frequency tables of this sort. The next chapter introduces a simpler and
    less error-prone approach where we calculate the table first before passing the
    results along to ggplot to graph. As you work through this section, bear in mind
    that if you find things slightly awkward or confusing it is because that’s exactly
    what they are.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`geom_bar()`的`fill`美学进行更合适的用途是交叉分类两个分类变量。这是计数频率表或比例频率表的图形等价物。例如，使用GSS数据，我们可能想检查美国不同地区的宗教偏好分布。在接下来的几段中，我们将看到如何仅使用ggplot来完成这项工作。然而，正如我们将发现的，这通常不是制作此类频率表最透明的方式。下一章介绍了一种更简单、更不易出错的简单方法，我们首先计算表，然后将结果传递给ggplot进行绘图。在阅读这一部分时，请记住，如果你觉得事情有点尴尬或困惑，那正是因为它们确实如此。
- en: Let’s say we want to look at religious preference by census region. That is,
    we want the `religion` variable broken down proportionally within `bigregion`.
    When we cross-classify categories in bar charts, there are several ways to display
    the results. With `geom_bar()` the output is controlled by the `position` argument.
    Let’s begin by mapping `fill` to `religion`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想按人口普查区域查看宗教偏好。也就是说，我们希望`religion`变量在`bigregion`内按比例分解。当我们对条形图中的类别进行交叉分类时，有几种方式来展示结果。使用`geom_bar()`时，输出由`position`参数控制。让我们首先将`fill`映射到`religion`。
- en: '![A stacked bar chart of Religious Preference by Census Region.](../Images/e414ea7d060124909f69fd5b85452631.png)
    Figure 4.10: A stacked bar chart of Religious Preference by Census Region.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![按人口普查区域宗教偏好的堆叠条形图](../Images/e414ea7d060124909f69fd5b85452631.png) 图4.10：按人口普查区域宗教偏好的堆叠条形图。'
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The default output of `geom_bar()` is a stacked bar chart, with counts on the
    y-axis (and hence counts within the stacked segments of the bars also). Region
    of the country is on the x-axis, and counts of religious preference are stacked
    within the bars. As we saw in Chapter [1](lookatdata.html#lookatdata), it is somewhat
    difficult for readers of the chart to compare lengths an areas on an unaligned
    scale. So while the relative position of the bottom categories are quite clear
    (thanks to them all being aligned on the x-axis), the relative positions of say,
    the “Catholic” category is harder to assess. An alternative choice is to set the
    `position` argument to `"fill"`. (This is different from the `fill` aesthetic.)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`geom_bar()`的默认输出是一个堆叠条形图，y轴上显示计数（因此条形的堆叠部分内的计数也显示）。国家地区在x轴上，宗教偏好的计数在条形内堆叠。正如我们在第[1](lookatdata.html#lookatdata)章中看到的，对于图表的读者来说，在未对齐的刻度上比较长度和面积有些困难。因此，尽管底部类别的相对位置相当清晰（多亏它们都在x轴上对齐），但例如“天主教”类别的相对位置就难以评估。另一种选择是将`position`参数设置为`"fill"`。（这与`fill`美学不同。）'
- en: '![Using the fill position adjustment to show relative proportions across categories.](../Images/73484330223ad56919c8ece2f1c08d48.png)
    Figure 4.11: Using the fill position adjustment to show relative proportions across
    categories.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用填充位置调整来显示类别间的相对比例。](../Images/73484330223ad56919c8ece2f1c08d48.png) 图4.11：使用填充位置调整来显示类别间的相对比例。'
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now the bars are all the same height, which makes it easier to compare proportions
    across groups. But we lose the ability to see the relative size of each cut with
    respect to the overall total. What if we wanted to show the proportion or percentage
    of religions within regions of the country, like in Figure [4.11](groupfacettx.html#fig:ch-04-gss-06A),
    but instead of stacking the bars we wanted separate bars instead? As a first attempt,
    we can use `position="dodge"` to make the bars within each region of the country
    appear side by side. However, if we do it this way (try it), we will find that
    ggplot places the bars side-by-side as intended, but changes the y-axis back to
    a *count* of cases within each category rather than showing us a proportion. We
    saw in Figure [4.8](groupfacettx.html#fig:ch-04-gss-04) that to display a proportion
    we needed to map `y = ..prop..`, so the correct statistic would be calculated.
    Let’s see if that works.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在条形的高度都相同，这使得比较组间的比例更容易。但我们失去了看到每个切割相对于总体总量的相对大小的能力。如果我们想展示国家地区内宗教的比例或百分比，就像图[4.11](groupfacettx.html#fig:ch-04-gss-06A)中那样，但我们不想堆叠条形，而是想使用单独的条形呢？作为一个初步尝试，我们可以使用`position="dodge"`来使国家每个地区的条形并排出现。然而，如果我们这样做（试试看），我们会发现ggplot将条形并排放置，正如预期的那样，但将y轴改回每个类别的案例
    *count* 而不是显示比例。我们在图[4.8](groupfacettx.html#fig:ch-04-gss-04)中看到，为了显示比例，我们需要映射`y
    = ..prop..`，所以正确的统计量会被计算。让我们看看这行不行。
- en: '![A first go at a dodged bar chart with proportional bars.](../Images/122f0ae3696aefaeec2a9fbe35080d45.png)
    Figure 4.12: A first go at a dodged bar chart with proportional bars.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![第一次尝试使用并排条形图和比例条形。](../Images/122f0ae3696aefaeec2a9fbe35080d45.png) 图4.12：第一次尝试使用并排条形图和比例条形。'
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The result is certainly colorful, but not what we wanted. Just as in Figure
    [4.7](groupfacettx.html#fig:ch-04-gss-03), there seems to be an issue with the
    grouping. When we just wanted the overall proportions for one variable, we mapped
    `group = 1` to tell ggplot to calculate the proportions with respect to the overall
    N. In this case our grouping variable is `religion`, so we might try mapping that
    to the `group` aesthetic.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 结果当然很丰富多彩，但不是我们想要的。就像图[4.7](groupfacettx.html#fig:ch-04-gss-03)一样，似乎存在分组问题。当我们只想得到一个变量的总体比例时，我们映射`group
    = 1`来告诉ggplot根据总体N计算比例。在这种情况下，我们的分组变量是`religion`，所以我们可能会尝试将其映射到`group`美学。
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This gives us a bar chart where the values of `religion` are broken down across
    regions, with a proportion showing on the y-axis. If you inspect the bars in Figure
    [4.13](groupfacettx.html#fig:ch-04-gss-08), you will see that they do not sum
    to one within each region. Instead, the bars for any particular religion sum to
    one *across* regions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个条形图，其中`religion`的值按地区分解，y轴上显示比例。如果你检查图[4.13](groupfacettx.html#fig:ch-04-gss-08)中的条形，你会发现它们在每个地区内并不相加至一。相反，任何特定宗教的条形在地区间相加至一
    *across*。
- en: '![A second attempt at a dodged bar chart with proportional bars.](../Images/62ddd4c886912aa5429cf43d7e0aaaee.png)
    Figure 4.13: A second attempt at a dodged bar chart with proportional bars.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![第二次尝试绘制带有比例条的错位条形图。](../Images/62ddd4c886912aa5429cf43d7e0aaaee.png) 图4.13：第二次尝试绘制带有比例条的错位条形图。'
- en: This lets us see that nearly half of those who said they were Protestant live
    in the South, for example. Meanwhile, just over ten percent of those saying they
    were Protestant live in the Northeast. Similarly, it shows that over half of those
    saying they were Jewish live in the Northeast, compared to about a quarter who
    live in the South.Proportions for smaller sub-populations tend to bounce around
    from year to year in the GSS.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们看到，例如，几乎一半声称自己是新教徒的人居住在南方。与此同时，只有超过十 percent的人说他们是新教徒，居住在东北部。同样，它显示说他们是犹太人的超过一半的人居住在东北部，相比之下，大约四分之一的人居住在南方。GSS中较小子群体的比例往往每年都会上下波动。
- en: We are still not quite where we originally wanted to be. Our goal was to take
    the stacked bar chart in Figure [4.10](groupfacettx.html#fig:ch-04-gss-06) but
    have the proportions shown side-by-side instead of on top of one another.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然没有达到最初想要的位置。我们的目标是取图[4.10](groupfacettx.html#fig:ch-04-gss-06)中的堆叠条形图，但比例是并排显示而不是重叠在一起。
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It turns out that the easiest thing to do is to stop trying to force `geom_bar()`
    to do all the work in a single step. Instead, we can ask ggplot to give us a proportional
    bar chart of religious affiliation, and then facet that by region. The proportions
    are calculated within each panel, which is the breakdown we wanted. This has the
    added advantage of not producing too many bars within each category.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，最容易做的事情就是停止试图在单一步骤中强迫`geom_bar()`完成所有工作。相反，我们可以要求ggplot给我们一个宗教归属的比例条形图，然后按地区进行细分。比例是在每个面板内计算的，这正是我们想要的结果。此外，这种方法还有一个优点，就是不会在每个类别中产生过多的条形。
- en: 'Figure 4.14: Faceting proportions within region.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14：按地区细分比例。
- en: '![Faceting proportions within region.](../Images/d67901facd927e98d4056ebe5e2ff2aa.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![按地区细分比例。](../Images/d67901facd927e98d4056ebe5e2ff2aa.png)'
- en: We could polish this plot further, but for the moment we will stop here. When
    constructing frequency plots directly in ggplot, it is a little too easy to get
    stuck in a cycle of not quite getting the marginal comparison that you want, and
    more or less randomly poking at the mappings to try to stumble on the the right
    breakdown. In the next Chapter, we will learn how to use the tidyverse’s `dplyr`
    library to produce the tables we want *before* we try to plot them. This is a
    more reliable approach, and easier to check for errors. It will also give us tools
    that can be used for many more tasks than producing summaries.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步润色这个图表，但暂时就到这里为止。在ggplot中直接构建频率图时，很容易陷入一个循环，即无法得到你想要的边际比较，而且几乎是在随机地尝试映射，试图偶然找到正确的细分。在下一章中，我们将学习如何使用tidyverse的`dplyr`库在尝试绘图之前生成我们想要的表格。这是一个更可靠的方法，并且更容易检查错误。它还将为我们提供可用于许多更多任务的工具。
- en: 4.6 Histograms and density plots
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 直方图和密度图
- en: Different geoms transform data in different ways, but ggplot’s vocabulary for
    them is consistent. We can see similar transformations at work when summarizing
    a continuous variable using a histogram, for example. A histogram is a way of
    summarizing a continuous variable by chopping it up into segments or “bins” and
    counting how many observations are found within each bin. In a bar chart, the
    categories are given to us going in (e.g., regions of the country, or religious
    affiliation). With a histogram, we have to decide how finely to bin the data.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的几何形状以不同的方式转换数据，但ggplot对这些几何形状的词汇是一致的。例如，当我们使用直方图总结连续变量时，我们可以看到类似的转换在起作用。直方图是一种通过将其切割成段或“箱”并计算每个箱内找到的观测值数量来总结连续变量的方法。在条形图中，类别是预先给出的（例如，国家的地区或宗教归属）。在直方图中，我们必须决定如何精细地划分数据。
- en: For example, ggplot comes with a dataset, `midwest`, containing information
    on counties in several midwestern states of the USA. Counties vary in size, so
    we can make a histogram showing the distribution of their geographical areas.
    Area is measured in square miles. Because we are summarizing a continuous variable
    using a series of bars, we need to divide the observations into groups, or bins,
    and count how many are in each one. By default, the `geom_histogram()` function
    will choose a bin size for us based on a rule of thumb.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，ggplot附带一个数据集`midwest`，其中包含美国几个中西部的县信息。县的大小各不相同，因此我们可以制作一个直方图来显示它们的地理面积分布。面积以平方英里为单位。因为我们正在使用一系列条形来总结连续变量，所以我们需要将观测值分成组，或称为箱，并计算每个箱中有多少个。默认情况下，`geom_histogram()`函数将根据经验规则为我们选择箱大小。
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Figure 4.15: Histograms of the same variable, using different numbers of bins.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15：使用不同数量的箱的同一变量的直方图。
- en: '![Histograms of the same variable, using different numbers of bins.](../Images/1d7fb516aa00dbbe85f20728243a9b60.png)![Histograms
    of the same variable, using different numbers of bins.](../Images/afaa4400507757217c75298e5fc5791f.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![使用不同数量的箱的同一变量的直方图](../Images/1d7fb516aa00dbbe85f20728243a9b60.png)![使用不同数量的箱的同一变量的直方图](../Images/afaa4400507757217c75298e5fc5791f.png)'
- en: As with the bar charts, a newly-calculated variable, `count`, appears on the
    x-axis. The notification from R tells us that behind the scenes the `stat_bin()`
    function picked 30 bins, but we might want to try something else. When drawing
    histograms it is worth experimenting with `bins` and also optionally the `origin`
    of the x-axis. Each, and especially `bins`, will make a big difference to how
    the resulting figure looks.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与条形图一样，新计算出的变量`count`出现在x轴上。R的通知告诉我们，在幕后`stat_bin()`函数选择了30个箱，但我们可能想尝试其他方法。在绘制直方图时，尝试`bins`和可选的x轴`origin`是值得的。每个，尤其是`bins`，都会对最终图形的外观产生重大影响。
- en: While histograms summarize single variables, it’s also possible to use several
    at once to compare distributions. We can facet histograms by some variable of
    interest, or as here we can compare them in the same plot using the `fill` mapping.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当直方图总结单个变量时，也可以同时使用多个直方图来比较分布。我们可以通过感兴趣的某个变量对直方图进行分面，或者像这里一样，我们可以使用`fill`映射在同一张图上比较它们。
- en: '![Comparing two histograms.](../Images/f1dd80bb96810898efdb7d0e6eed506a.png)
    Figure 4.16: Comparing two histograms.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![比较两个直方图](../Images/f1dd80bb96810898efdb7d0e6eed506a.png) 图4.16：比较两个直方图。'
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We subset the data here to pick out just two states. To do this we create a
    character vector with just two elements, “OH” and “WI”. Then we use the `subset()`
    function to take our data and filter it so that we only select rows whose `state`
    name is in this vector. The `%in%` operator is a convenient way to filter on more
    than one term in a variable when using `subset()`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里对数据进行子集化，以挑选出仅两个州。为此，我们创建了一个包含两个元素的字符向量，“OH”和“WI”。然后我们使用`subset()`函数来获取我们的数据，并过滤它，以便我们只选择`state`名称在这个向量中的行。`%in%`运算符是使用`subset()`在变量中过滤多个术语的一种方便方式。
- en: When working with a continuous variable, an alternative to binning the data
    and making a histogram is to calculate a kernel density estimate of the underlying
    distribution. The `geom_density()` function will do this for us.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理连续变量时，除了对数据进行分箱并制作直方图外，还可以计算底层分布的核密度估计。`geom_density()`函数会为我们做这件事。
- en: '![Kernel density estimate of county areas.](../Images/d0c2f356c27a2ba25016e64519992e3f.png)
    Figure 4.17: Kernel density estimate of county areas.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![县面积的核密度估计](../Images/d0c2f356c27a2ba25016e64519992e3f.png) 图4.17：县面积的核密度估计。'
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can use `color` (for the lines) and `fill` (for the body of the density curve)
    here, too. These figures often look quite nice. But when there are several filled
    areas on the plot, as in this case, the overlap can become hard to read. If you
    want to make the baselines of the density curves go away, you can use `geom_line(stat
    = "density")` instead. This also removes the possibility of using the `fill` aesthetic.
    But this may be an improvement in some cases. Try it with the plot of state areas
    and see how they compare.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在这里使用`color`（用于线条）和`fill`（用于密度曲线的主体）。这些图形通常看起来相当不错。但是，当图表上有多个填充区域时，如本例所示，重叠可能会变得难以阅读。如果您想使密度曲线的基线消失，可以使用`geom_line(stat
    = "density")`代替。这也会移除使用`fill`美学的可能性。但这在某些情况下可能是一个改进。尝试使用州面积图来查看它们的比较。
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Figure 4.18: Comparing distributions.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18：比较分布。
- en: '![Comparing distributions.](../Images/65ad622a4337f78bd834678e61fc0eee.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![比较分布图](../Images/65ad622a4337f78bd834678e61fc0eee.png)'
- en: Just like `geom_bar()`, the count-based defaults computed by the `stat_` functions
    used by `geom_histogram()` and `geom_density()` will return proportional measures
    if we ask them. For `geom_density()`, the `stat_density()` function can return
    its default `..density..` statistic, or `..scaled..`, which will give a proportional
    density estimate. It can also return a statistic called `..count..`, which is
    the density times the number of points. This can be used in stacked density plots.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `geom_bar()` 一样，`geom_histogram()` 和 `geom_density()` 中使用的 `stat_` 函数基于计数的默认计算会在我们要求时返回比例度量。对于
    `geom_density()`，`stat_density()` 函数可以返回其默认的 `..density..` 统计量，或者 `..scaled..`，这将给出比例密度估计。它还可以返回一个名为
    `..count..` 的统计量，这是密度乘以点的数量。这可以用于堆叠密度图。
- en: '![Scaled densities.](../Images/170a065023026a8f463517a53b7c2297.png) Figure
    4.19: Scaled densities.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![缩放密度图](../Images/170a065023026a8f463517a53b7c2297.png) 图 4.19：缩放密度图。'
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 4.7 Avoid transformations when necessary
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7 在必要时避免变换
- en: 'As we have seen from the beginning, ggplot normally makes its charts starting
    from a full dataset. When we call `geom_bar()` it does its calculations on the
    fly using `stat_count()` behind the scenes to produce the counts or proportions
    it displays. In the previous section, we looked at a case where we wanted to group
    and aggregate our data ourselves before handing it off to ggplot. But often, our
    data is in effect *already* a summary table. This can happen when we have computed
    a table of marginal frequencies or percentages from our original data already.
    Plotting results from statistical models also puts us in this position, as we
    will see later. Or it may be that we just have a finished table of data (from
    the Census, say, or an official report) that we want to make into a graph. For
    example, perhaps we do not have the individual-level data on who survived the
    *Titanic* disaster, but we do have a small table of counts of survivors by sex:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从一开始看到的，ggplot 通常从完整的数据集开始制作图表。当我们调用 `geom_bar()` 时，它会在后台使用 `stat_count()`
    进行即时计算，以产生它显示的计数或比例。在上一节中，我们查看了一个我们希望在将数据交给 ggplot 之前自己进行分组和汇总的案例。但通常，我们的数据实际上已经是汇总表。这可能会发生在我们已经从原始数据中计算出了边际频率或百分比表的情况下。从统计模型中得到的绘图结果也会使我们处于这种位置，我们将在后面看到。或者，可能我们只是有一个完成的数据表（例如，来自人口普查或官方报告），我们希望将其制作成图表。例如，我们可能没有关于谁在
    *泰坦尼克号* 灾难中幸存下来的个体级数据，但我们确实有一个按性别划分的幸存者计数的小表：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Because we are working directly with percentage values in a summary table, we
    no longer have any need for ggplot to count up values for us or perform any other
    calculations. That is, we do not need the services of any `stat_` functions that
    `geom_bar()` would normally call. We can tell `geom_bar()` not to do any work
    on the variable before plotting it. To do this we say `stat = 'identity'` in the
    `geom_bar()` call. We’ll also move the legend to the top of the chart.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们直接在汇总表中处理百分比值，我们不再需要 ggplot 为我们计数或执行任何其他计算。也就是说，我们不需要 `geom_bar()` 通常会调用的任何
    `stat_` 函数的服务。我们可以告诉 `geom_bar()` 在绘图之前不要对变量进行任何操作。为此，我们在 `geom_bar()` 调用中指定 `stat
    = 'identity'`。我们还将图例移动到图表的顶部。
- en: '![Survival on the Titanic, by Sex.](../Images/771b705af5b3db7232da929fdd911d8f.png)
    Figure 4.20: Survival on the Titanic, by Sex.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![泰坦尼克号上的生存情况，按性别划分](../Images/771b705af5b3db7232da929fdd911d8f.png) 图 4.20：泰坦尼克号上的生存情况，按性别划分。'
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For convenience ggplot also provides a related geom, `geom_col()`, which has
    exactly the same effect but assumes that `stat = "identity"`. We will use this
    form in future when we don’t need any calculations done on the plot.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，ggplot 还提供了一个相关的 geom，`geom_col()`，它具有完全相同的效果，但假设 `stat = "identity"`。当我们不需要在图表上进行任何计算时，我们将使用这种形式。
- en: The `position` argument in `geom_bar()` and `geom_col()` can also take the value
    of `"identity"`. Just as `stat = "identity"` means “don’t do any summary calculations”,
    `position = "identity"` means “just plot the values as given”. This allows us
    to do things like, for example, plot a flow of positive and negative values in
    a bar chart. This sort of graph is an alternative to a line plot and is often
    seen in public policy settings where changes relative to some threshold level
    or baseline are of interest. For example, the `oecd_sum` table in `socviz` contains
    information on average life expectancy at birth within the United States, and
    across other OECD countries.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`geom_bar()`和`geom_col()`中的`position`参数也可以取值为`"identity"`。正如`stat = "identity"`意味着“不进行任何汇总计算”，`position
    = "identity"`意味着“仅按给定值绘制”。这允许我们做一些事情，例如，在柱状图中绘制正负值的流动。这种图表是线图的替代品，通常在公共政策环境中可以看到，其中对相对于某个阈值水平或基线的变化感兴趣。例如，`socviz`中的`oecd_sum`表包含了美国及其他经合组织国家平均预期寿命的信息。'
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `other` column is the average life expectancy in a given year for OECD countries,
    excluding the United States. The `usa` column is the US life expectancy, `diff`
    is the difference between the two values, and `hi_lo` indicates whether the US
    value for that year was above or below the OECD average. We will plot the difference
    over time, and use the `hi_lo` variable to color the columns in the chart.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`other`列是经合组织国家在给定年份的平均预期寿命，不包括美国。`usa`列是美国预期寿命，`diff`是两个值的差异，而`hi_lo`表示美国那一年的值是高于还是低于经合组织平均水平。我们将绘制随时间的变化差异，并使用`hi_lo`变量来为图表中的柱子着色。'
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![Using <code>geom\_col()</code> to plot negative and positive values in a
    bar chart.](../Images/06bcc4f1333270280d72e98d90d0a5dc.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![使用`geom_col()`在柱状图中绘制负值和正值。](../Images/06bcc4f1333270280d72e98d90d0a5dc.png)'
- en: 'Figure 4.21: Using `geom_col()` to plot negative and positive values in a bar
    chart.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21：使用`geom_col()`在柱状图中绘制负值和正值。
- en: As with the `titanic` plot, the default action of `geom_col()` is to set both
    `stat` and `position` to “`identity`”. To get the same effect with `geom_bar()`
    we would need to say `geom_bar(position = "identity")`. As before, the `guides(fill=FALSE)`
    instruction at the end tells ggplot to drop the unnecessary legend that would
    otherwise be automatically generated to accompany the `fill` mapping.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与`titanic`图表一样，`geom_col()`的默认操作是设置`stat`和`position`都为“`identity`”。要使用`geom_bar()`获得相同的效果，我们需要说`geom_bar(position
    = "identity")`。与之前一样，最后的`guides(fill=FALSE)`指令告诉ggplot不要生成与`fill`映射一起自动生成的不必要的图例。
- en: At this point, we have a pretty good sense of the core steps we must take to
    visualize our data. In fact, thanks to ggplot’s default settings, we now have
    the ability to make good-looking and informative plots. Starting with a tidy dataset,
    we know how to map variables to aesthetics, to choose from a variety of geoms,
    and make some adjustments to the scales of the plot. We also know more about selecting
    the right sort of computed statistic to show on the graph, if that’s what’s needed,
    and how to facet our core plot by one or more variables. We know how to set descriptive
    labels for axes, and write a title, subtitle, and caption. Now we’re in a position
    to put these skills to work in a more fluent way.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经对必须采取的核心步骤来可视化我们的数据有了相当好的理解。实际上，多亏了ggplot的默认设置，我们现在有能力制作出既美观又富有信息量的图表。从整洁的数据集开始，我们知道如何将变量映射到美学上，从各种几何形状中选择，并对图表的尺度进行一些调整。我们还了解如何选择合适的计算统计量来显示在图上，如果需要的话，以及如何通过一个或多个变量对核心图表进行分面。我们知道如何为坐标轴设置描述性标签，并撰写标题、副标题和图注。现在我们能够更流畅地运用这些技能。
- en: 4.8 Where to go next
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8 接下来去哪里
- en: Revisit the `gapminder` plots at the beginning of the chapter and experiment
    with different ways to facet the data. Try plotting population and per capita
    GDP while faceting on year, or even on country. In the latter case you will get
    a lot of panels, and plotting them straight to the screen may take a long time.
    Instead, assign the plot to an object and save it as a PDF file to your `figures/`
    folder. Experiment with the height and width of the figure.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾本章开头提到的`gapminder`图表，并尝试不同的数据分面方式。尝试在按年份或甚至按国家分面时绘制人口和人均GDP。在后一种情况下，你会得到很多面板，直接在屏幕上绘制它们可能需要很长时间。相反，将图表分配给一个对象，并将其保存为PDF文件到您的`figures/`文件夹中。尝试调整图形的高度和宽度。
- en: Investigate the difference between a formula written as `facet_grid(sex ~ race)`
    versus one written as `facet_grid(~ sex + race)`.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查将公式写成`facet_grid(sex ~ race)`与写成`facet_grid(~ sex + race)`之间的区别。
- en: Experiment to see what happens when you use `facet_wrap()` with more complex
    forumulas like `facet_wrap(~ sex + race)` instead of `facet_grid`. Like `facet_grid()`,
    the `facet_wrap()` function can facet on two or more variables at once. But it
    will do it by laying the results out in a wrapped one-dimensional table instead
    of a fully cross-classified grid.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用更复杂的公式，如`facet_wrap(~ sex + race)`而不是`facet_grid`，来实验一下会发生什么。与`facet_grid()`类似，`facet_wrap()`函数可以同时根据两个或多个变量进行分面。但它将通过将结果布局在一个包裹的一维表中而不是一个完全交叉分类的网格中来实现这一点。
- en: Frequency polygons are closely related to histograms. Instead of displaying
    the count of observations using bars, they display it with a series of connected
    lines instead. You can try the various `geom_histogram()` calls in this chapter
    using `geom_freqpoly()` instead.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频率多边形与直方图密切相关。它们不是用条形显示观察值的计数，而是用一系列连接的线来显示。你可以尝试使用`geom_freqpoly()`代替本章中的各种`geom_histogram()`调用。
- en: A histogram bins observations for one variable and shows a bars with the count
    in each bin. We can do this for two variables at once, too. The `geom_bin2d()`
    function takes two mappings, `x` and `y`. It divides your plot into a grid and
    colors the bins by the count of observations in them. Try using it on the `gapminder`
    data to plot life expectancy versus per capita GDP. Like a histogram, you can
    vary the number or width of the bins for both `x` or `y`. Instead of saying `bins
    = 30` or `binwidth = 1`, provide a number for both `x` and `y` with, for example,
    `bins = c(20, 50)`. If you specify `bindwith` instead, you will need to pick values
    that are on the same scale as the variable you are mapping.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直方图将一个变量的观察值进行分箱，并显示每个箱中的计数。我们也可以同时为两个变量这样做。`geom_bin2d()`函数接受两个映射，`x`和`y`。它将你的绘图分成一个网格，并通过箱中观察值的计数来着色这些箱。尝试使用`gapminder`数据来绘制预期寿命与人均GDP的关系。与直方图一样，你可以为`x`或`y`的箱数或宽度进行调整。而不是说`bins
    = 30`或`binwidth = 1`，你可以为`x`和`y`都提供一个数字，例如`bins = c(20, 50)`。如果你指定`binwidth`，你需要选择与你要映射的变量相同的比例的值。
- en: Density estimates can also be drawn in two dimensions. The `geom_density_2d()`
    function draws contour lines estimating the joint distribution of two variables.
    Try it with the `midwest` data, for example, plotting percent below the poverty
    line (`percbelowpoverty`) against percent college-educated (`percollege`). Try
    it with and without a `geom_point()` layer.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密度估计也可以在二维中绘制。`geom_density_2d()`函数绘制等高线，估计两个变量的联合分布。例如，尝试使用`midwest`数据，绘制贫困线以下百分比（`percbelowpoverty`）与受过大学教育百分比（`percollege`）的关系。尝试添加和删除`geom_point()`层。
- en: 4.1 Colorless green data sleeps furiously
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 无色的绿色数据疯狂地睡觉
- en: When you write ggplot code in R you are in effect trying to “say” something
    visually. It usually takes several iterations to say exactly what you mean. This
    is more than a metaphor here. The ggplot library is an implementation of the “grammar”
    of graphics, an idea developed by Wilkinson (2005). The grammar is a set of rules
    for producing graphics from data, taking pieces of data and mapping them to geometric
    objects (like points and lines) that have aesthetic attributes (like position,
    color and size), together with further rules for transforming the data if needed
    (e.g. to a smoothed line), adjusting scales (e.g. to a log scale),We will see
    some alternatives to cartesian coordinates later. and projecting the results onto
    a different coordinate system (usually cartesian).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在R中编写ggplot代码时，实际上你是在尝试“表达”某种视觉上的信息。通常需要多次迭代才能准确表达你的意图。这里不仅仅是一个比喻。ggplot库是对图形“语法”的实现，这是一个由Wilkinson（2005）提出的概念。语法是一套从数据生成图形的规则，它将数据片段映射到具有美学属性（如位置、颜色和大小）的几何对象（如点和线），以及进一步的数据转换规则（例如，转换为平滑线），调整比例（例如，对数比例），我们稍后会看到一些与笛卡尔坐标不同的替代方案，并将结果投影到不同的坐标系上（通常是笛卡尔坐标系）。
- en: A key point is that, like other rules of syntax, the grammar limits the structure
    of what you can say, but it does not automatically make what you say sensible
    or meaningful. It allows you to produce long “sentences” that begin with mappings
    of data to visual elements and add clauses about what sort of plot it is, how
    the axes are scaled, and so on. But these sentences can easily be garbled. Sometimes
    your code will not produce a plot at all because of some syntax error in R. You
    will forget a `+` sign between `geom_` functions, or lose a parenthesis somewhere
    so that your function statement becomes unbalanced. In those cases R will complain
    (perhaps in an opaque way) that something has gone wrong. At other times, your
    code will successfully produce a plot, but it will not look the way you expected
    it to. Sometimes the results will look very weird indeed. In those cases, the
    chances are you have given ggplot a series of grammatically correct instructions
    that are either nonsensical in some way, or have accidentally twisted what you
    meant to say. These problems often arise when ggplot does not have quite all the
    information it needs in order make your graphic say what you want it to say.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键点是，与其他语法规则一样，语法限制了你可以说的结构的范围，但它不会自动使你说的话变得合理或有意义。它允许你产生长的“句子”，这些句子以将数据映射到视觉元素开始，并添加关于它是何种图表、坐标轴如何缩放等内容的子句。但是这些句子很容易被搞乱。有时你的代码在R中可能根本不会生成图表，因为存在一些语法错误。你可能会忘记在`geom_`函数之间加上一个`+`符号，或者丢失某个地方的括号，使得你的函数声明变得不平衡。在这些情况下，R会抱怨（可能以一种晦涩的方式）说出了问题。在其他时候，你的代码可能会成功生成图表，但它看起来并不是你预期的样子。有时结果看起来确实非常奇怪。在这些情况下，很可能是你给了ggplot一系列语法上正确的指令，但这些指令在某些方面可能是无意义的，或者意外地扭曲了你想要表达的意思。这些问题通常发生在ggplot没有足够的信息来制作你想要它表达的信息的图形时。
- en: 4.2 Grouped data and the “group” aesthetic
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 分组数据和“group”美学
- en: 'Let’s begin again with our Gapminder dataset. Imagine we wanted to plot the
    trajectory of life expectancy over time for each country in the data. We map `year`
    to `x` and `lifeExp` to `y`. We take a quick look at the documentation and discover
    that `geom_line()` will draw lines by connecting observations in order of the
    variable on the x-axis, which seems right. We write our code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的Gapminder数据集重新开始。想象一下，我们想要绘制数据中每个国家随时间推移的生命期望轨迹。我们将`year`映射到`x`轴，将`lifeExp`映射到`y`轴。我们快速查看文档，发现`geom_line()`将按照x轴上变量的顺序连接观测值来绘制线条，这似乎是正确的。我们编写了我们的代码：
- en: '![Trying to plot the data over time by country.](../Images/13e4a87d0b85be4bf9aaa5565bf105ab.png)
    Figure 4.1: Trying to plot the data over time by country.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![尝试按国家绘制数据随时间的变化。](../Images/13e4a87d0b85be4bf9aaa5565bf105ab.png) 图4.1：尝试按国家绘制数据随时间的变化。'
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Something has gone wrong. What happened? While ggplot will make a pretty good
    guess as to the structure of the data, it does not know that the yearly observations
    in the data are grouped by country. We have to tell it. Because we have not, `geom_line()`
    gamely tries to join up all the lines for each particular year in the order they
    appear in the dataset, as promised. It starts with an observation for 1952 in
    the first row of the data. It doesn’t know this belongs to Afghanistan. Instead
    of going to Afghanistan 1953, it finds there are a series of 1952 observations,
    so it joins all of those up first, alphabetically by country, all the way down
    to the 1952 observation that belongs to Zimbabwe. Then it moves to the first observation
    in the next year, 1957.This would have worked if there were only one country in
    the dataset.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了某些问题。发生了什么？虽然ggplot会根据数据结构做出一个相当好的猜测，但它并不知道数据中的年度观测值是按国家分组的。我们必须告诉它。因为我们没有这样做，`geom_line()`就勇敢地试图按照数据集中出现的顺序将每个特定年份的所有线条连接起来，就像它承诺的那样。它从数据的第一行中的1952年的观测值开始。它不知道这属于阿富汗。它没有去阿富汗1953年，而是发现有一系列1952年的观测值，所以它首先将它们全部连接起来，按国家字母顺序排列，一直到最后属于津巴布韦的1952年观测值。然后它移动到下一年第一行的第一个观测值，即1957年。如果数据集中只有一个国家，这本来是可以工作的。
- en: The result is meaningless when plotted. Bizarre-looking output in ggplot is
    common enough, because everyone works out their plots one bit at a time, and making
    mistakes is just a feature of puzzling out how you want the plot to look. When
    ggplot successfully makes a plot but the result looks insane, the reason is almost
    always that something has gone wrong in the mapping between the data and aesthetics
    for the geom being used. This is so common there’s even a [Twitter account](https://twitter.com/accidental__art)
    devoted to the “Accidental aRt” that results. So don’t despair!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当绘制时，结果是毫无意义的。在ggplot中，看起来奇怪的输出很常见，因为每个人都是一步一步地解决他们的图表，犯错误只是弄清楚你想要图表看起来怎样的一个特征。当ggplot成功制作了一个图表，但结果看起来疯狂时，几乎总是因为数据与用于geom的美学之间的映射出了问题。这种情况很常见，以至于甚至有一个[推特账号](https://twitter.com/accidental__art)专门用于“意外艺术”的结果。所以不要绝望！
- en: In this case, we can use the `group` aesthetic to tell ggplot explicitly about
    this country-level structure.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以使用`group`美学来明确告诉ggplot这个国家层面的结构。
- en: '![Plotting the data over time by country, again.](../Images/96c7456a2639085700e54274b64c86cc.png)
    Figure 4.2: Plotting the data over time by country, again.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![按国家绘制数据的时间图，再次。](../Images/96c7456a2639085700e54274b64c86cc.png) 图4.2：再次按国家绘制数据的时间图。'
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The plot here is still fairly rough, but it is showing the data properly, with
    each line representing the trajectory of a country over time. The gigantic outlier
    is Kuwait, in case you are interested.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的图表仍然相当粗糙，但它正确地显示了数据，每条线代表一个国家随时间变化的轨迹。如果你感兴趣的话，巨大的异常值是科威特。
- en: The `group` aesthetic is usually only needed when the grouping information you
    need to tell ggplot about is not built-in to the variables being mapped. For example,
    when we were plotting the points by continent, mapping `color` to `continent`
    was enough to get the right answer, because `continent` is already a categorical
    variable, so the grouping is clear. When mapping the `x` to `year`, however, there
    is no information in the `year` variable itself to let ggplot know that it is
    grouped by country for the purposes of drawing lines with it. So we need to say
    that explicitly.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通常只有在需要告诉ggplot的分组信息不是映射变量的内置信息时，才需要`group`美学。例如，当我们按大陆绘制点时，将`color`映射到`continent`就足以得到正确答案，因为`continent`已经是一个分类变量，所以分组是清晰的。然而，当我们将`x`映射到`year`时，`year`变量本身没有信息可以让ggplot知道它按国家分组以绘制线条。因此，我们需要明确地说明这一点。
- en: 4.3 Facet to make small multiples
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 分面以制作小倍数图
- en: The plot we just made has a lot of lines on it. While the overall trend is more
    or less clear, it looks a little messy. One option is to *facet* the data by some
    third variable, making a “small multiple” plot. This is a very powerful technique
    that allows a lot of information to be presented compactly, and in a consistently
    comparable way. A separate panel is drawn for each value of the faceting variable.
    Facets are not a geom, but rather a way of organizing a series of geoms. In this
    case we have the `continent` variable available to us. We will use `facet_wrap()`
    to split our plot by `continent`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚制作的图表上有许多线条。虽然整体趋势或多或少是清晰的，但它看起来有点杂乱。一个选择是按某个第三个变量分面数据，制作一个“小倍数”图。这是一种非常强大的技术，允许以紧凑和一致可比的方式展示大量信息。为分面变量的每个值绘制一个单独的面板。分面不是geom，而是一种组织一系列geom的方式。在这种情况下，我们有`continent`变量可用。我们将使用`facet_wrap()`按`continent`拆分我们的图表。
- en: 'The `facet_wrap()` function can take a series of arguments, but the most important
    is the first one, which is specified using R’s “formula” syntax, which uses the
    tilde character, `~`. Facets are usually a one-sided formula. Most of the time
    you will just want a single variable on the right side of the formula. But faceting
    is powerful enough to accommodate what are in effect the graphical equivalent
    of multi-way contingency tables, if your data is complex enough to require that.
    For our first example, we will just use a single term in our formula, which is
    the variable we want the data broken up by: `facet_wrap(~ continent)`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`facet_wrap()`函数可以接受一系列参数，但最重要的是第一个参数，它使用R的“公式”语法指定，该语法使用波浪线字符`~`。分面通常是一个单侧公式。大多数情况下，你只需要在公式的右侧有一个变量。但是，分面足够强大，可以容纳实际上是多向列联表图形等价物的数据，如果你的数据足够复杂，需要这样做的话。在我们的第一个例子中，我们将在公式中使用一个单一术语，这是我们想要数据按其拆分的变量：`facet_wrap(~
    continent)`。'
- en: '![Faceting by continent.](../Images/dca4514d8ec42a6f9aabcba51b2de069.png) Figure
    4.3: Faceting by continent.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![按大陆分面。](../Images/dca4514d8ec42a6f9aabcba51b2de069.png) 图 4.3：按大陆分面。'
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Each facet is labeled at the top. The overall layout minimizes the duplication
    of axis labels and other scales. Remember, too that we can still include other
    geoms as before, and they will be layered within each facet. We can also use the
    `ncol` argument to `facet_wrap()` to control the number of columns used to lay
    out the facets. Because we have only five continents it might be worth seeing
    if we can fit them on a single row (which means we’ll have five columns). In addition,
    we can add a smoother, and a few cosmetic enhancements that make the graph a little
    more effective. In particular we will make the country trends a light gray color.
    We need to write a little more code to make all this happen. If you are unsure
    of what each piece of code does, take advantage of ggplot’s additive character.
    Working backwards from the bottom up, remove each `+ some_function(...)` statement
    one at a time to see how the plot changes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分面在顶部都有标签。整体布局最小化了轴标签和其他刻度的重复。记住，我们仍然可以像以前一样包含其他 geom，它们将在每个分面内分层。我们还可以使用
    `facet_wrap()` 的 `ncol` 参数来控制用于布局分面的列数。因为我们只有五个大陆，所以可能值得看看我们是否可以将它们放在一行上（这意味着我们将有五列）。此外，我们可以添加一个平滑器，以及一些使图表更有效的美学增强。特别是，我们将使国家趋势的颜色为浅灰色。我们需要编写更多的代码来实现这一切。如果你不确定每段代码的作用，可以利用
    ggplot 的累加特性。从底部向上，逐个移除每个 `+ some_function(...)` 语句，以查看图表如何变化。
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![Faceting by continent, again.](../Images/ef23f240e741e69c5821cbffcd49744d.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![再次按大陆分面。](../Images/ef23f240e741e69c5821cbffcd49744d.png)'
- en: 'Figure 4.4: Faceting by continent, again.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：再次按大陆分面。
- en: This plotWe could also have faceted by country, which would have made the group
    mapping superfluous. But that would make almost a hundred and fifty panels. brings
    together an aesthetic mapping of `x` and `y` variables, a grouping aesthetic (`country`),
    two geoms (a lineplot and a smoother), a log-transformed y-axis with appropriate
    tick labels, a faceting variable (`continent`), and finally axis labels and a
    title.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表我们可以通过国家来分面，这样就会使分组映射变得多余。但那样会有近一百五十个面板。它将 `x` 和 `y` 变量的美学映射、分组美学（`country`）、两个
    geom（线图和平滑器）、带有适当刻度标签的对数变换的 y 轴、分面变量（`continent`）以及最终的轴标签和标题结合在一起。
- en: The `facet_wrap()` function is best used when you want a series of small multiples
    based on a single categorical variable. Your panels will be laid out in order
    and then wrapped into a grid. If you wish you can specify the number or rows or
    the number of columns in the resulting layout. Facets can be more complex than
    this. For instance, you might want to cross-classify some data by two categorical
    variables. In that case you should try `facet_grid()` instead. This function will
    lay out your plot in a true two-dimensional arrangement, instead of a series of
    panels wrapped into a grid.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`facet_wrap()` 函数最适合当你想要基于单个分类变量的一系列小倍数时使用。你的面板将按顺序排列，然后包裹成一个网格。如果你愿意，你可以指定结果的行数或列数。Facets
    可以比这更复杂。例如，你可能想要通过两个分类变量交叉分类一些数据。在这种情况下，你应该尝试使用 `facet_grid()`。这个函数将你的图表布局在一个真正的二维排列中，而不是一系列包裹在网格中的面板。'
- en: To see the difference, let’s introduce `gss_sm`, a new dataset that we will
    use in the next few sections, as well as later on in the book. It is a small subset
    of the questions from the 2016 General Social Survey, or GSS. The GSS is a long-running
    survey of American adults that asks about a range of topics of interest to social
    scientists.To begin with, we will use the GSS data in a slightly naive way. In
    particular we will not consider sample weights when making the figures in this
    chapter. In Chapter 6 we will learn how to calculate frequencies and other statistics
    from data with a complex or weighted survey design. The `gapminder` data consists
    mostly of *continuous* variables measured within countries by year. Measures like
    GDP per capita can take any value across a large range and they vary smoothly.
    The only *categorical* grouping variable is `continent`. It is an unordered categorical
    variable. Each country belongs to one continent, but the continents themselves
    have no natural ordering.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到差异，让我们介绍 `gss_sm`，这是一个新数据集，我们将在接下来的几节中使用它，以及本书后面的部分。它是2016年一般社会调查（GSS）中问题的一个小子集。GSS是对美国成年人进行的一项长期调查，涉及社会科学家感兴趣的各种主题。首先，我们将以略带天真的方式使用GSS数据。具体来说，在制作本章的图表时，我们不会考虑样本权重。在第6章中，我们将学习如何从具有复杂或加权调查设计的数据中计算频率和其他统计量。`gapminder`
    数据主要由按年份在各国测量的 *连续* 变量组成。如人均GDP这样的度量可以跨越很大范围取任何值，并且变化平滑。唯一的 *分类* 分组变量是 `continent`。它是一个无序分类变量。每个国家属于一个大陆，但大陆本身没有自然顺序。
- en: In social scientific work, especially when analyzing individual-level survey
    data, we very often work with categorical data of various kinds. Sometimes the
    categories are unordered, as with ethnicity or sex. But they may also be ordered,
    as when me measure highest level of education attained on a scale ranging from
    elementary school to postgraduate degree. Opinion questions may be asked in yes-or-no
    terms, or on a five or seven point scale with a neutral value in the middle. Meanwhile,
    many numeric measures, such as number of children, may still only take integer
    values within a relatively narrow range. In practice these too may be treated
    as ordered categorical variables running from zero to some top-coded value such
    as “Six or more”. Even properly continuous measures, such as income, are rarely
    reported to the dollar and are often only obtainable as ordered categories. The
    GSS data in `gss_sm` contains many measures of this sort. You can take a peek
    at it, as usual, by typing its name at the console. You could also try `glimpse(gss_sm)`,
    which will give a very compact summary of all the variables in the data.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在社会科学工作中，尤其是在分析个体层面的调查数据时，我们经常处理各种类型的分类数据。有时类别是无序的，如种族或性别。但它们也可能是有序的，例如当我们测量从小学到研究生学位的学历最高水平时。意见问题可能以是或否的形式提出，或者在一个五点或七点量表上，中间有一个中性值。同时，许多数值度量，如孩子的数量，可能仍然只在相对较窄的范围内取整数值。在实践中，这些也可以被视为从零到某些上限值（如“六或更多”）的有序分类变量。即使是适当的连续度量，如收入，也很少按美元报告，通常只能作为有序类别获得。`gss_sm`
    中的GSS数据包含许多此类度量。您可以通过在控制台中输入其名称来查看它，或者尝试 `glimpse(gss_sm)`，这将给出数据中所有变量的非常紧凑的摘要。
- en: 'We will make a smoothed scatterplot of the relationship between the age of
    the respondent and the number of children they have. In `gss_sm` the `childs`
    variable is a numeric count of the respondent’s children. (There is also a variable
    named `kids` that is the same measure, but its class is an ordered factor rather
    than a number.) We will then facet this relationship by sex and race of the respondent.
    We use R’s formula notation in the `facet_grid` function to facet sex and race.
    This time, because we are cross-classifying our results, the formula is two-sided:
    `facet_grid(sex ~ race)`.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绘制受访者年龄和所拥有的孩子数量之间关系的平滑散点图。在 `gss_sm` 中，`childs` 变量是受访者的孩子数量的数值计数。（还有一个名为
    `kids` 的变量，其度量与 `childs` 相同，但其类别是一个有序因子而不是数字。）然后我们将通过受访者的性别和种族来细分这种关系。我们在 `facet_grid`
    函数中使用R的公式表示法来细分性别和种族。这次，因为我们正在交叉分类我们的结果，所以公式是双向的：`facet_grid(sex ~ race)`。
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Figure 4.5: Faceting on two categorical variables. Each panel plots the relationship
    between age and number of children, with the facets breaking out the data by sex
    (in the rows) and race (in the columns).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：基于两个分类变量的细分。每个面板绘制了年龄和孩子的数量之间的关系，细分通过性别（行）和种族（列）来划分数据。
- en: '![Faceting on two categorical variables. Each panel plots the relationship
    between age and number of children, with the facets breaking out the data by sex
    (in the rows) and race (in the columns).](../Images/1f460868c6045f5292cdf1c6e2d517e0.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![在两个分类变量上进行分面。每个面板绘制年龄与孩子数量之间的关系，分面通过性别（行）和种族（列）将数据分开。](../Images/1f460868c6045f5292cdf1c6e2d517e0.png)'
- en: Multi-panel layouts of this kind are especially effective when used to summarize
    continuous variation (as in a scatterplot) across two or more categorical variables,
    with the categories (and hence the panels) ordered in some sensible way. We are
    not limited to two-way comparison. Further categorical variables can be added
    to the formula, too, (e.g. `sex ~ race + degree`) for more complex multi-way plots.
    However, the multiple dimensions of plots like this will become very complicated
    very quickly if the variables have more than a few categories each.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的多面板布局在用于总结两个或更多分类变量之间的连续变化（如散点图）时特别有效，其中类别（以及因此的面板）以某种合理的方式排序。我们不仅限于双向比较。还可以将更多的分类变量添加到公式中，以创建更复杂的多向图（例如，`sex
    ~ race + degree`）。然而，如果每个变量都有很多类别，那么这种图表的多维性会变得非常复杂。
- en: 4.4 Geoms can transform data
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 几何对象可以转换数据
- en: We have already seen several examples where `geom_smooth()` was included as
    a way to add a trend line to the figure. Sometimes we plotted a LOESS line, sometimes
    a straight line from an OLS regression, and sometimes the result of a Generalized
    Additive Model. We did not have to have any strong idea of the differences between
    these methods. Neither did we have to write any code to specify the underlying
    models, beyond telling the `method` argument in `geom_smooth()` which one we wanted
    to use. The `geom_smooth()` function did the rest.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到几个例子，其中`geom_smooth()`被包括在内，作为向图中添加趋势线的一种方式。有时我们绘制了LOESS线，有时是从OLS回归得到的直线，有时是广义加性模型的结果。我们不必对这几种方法之间的差异有强烈的认识。我们也不必编写任何代码来指定底层模型，只需在`geom_smooth()`中的`method`参数中指定我们想要使用的方法即可。`geom_smooth()`函数会完成剩下的工作。
- en: 'Thus, some geoms plot our data directly on the figure, as is the case with
    `geom_point()`, which takes variables designated as `x` and `y` and plots the
    points on a grid. But other geoms clearly do more work on the data before it gets
    plotted.Try `p + stat_smooth()`, for example. Every `geom_` function has an associated
    `stat_` function that it uses by default. The reverse is also the case: every
    `stat_` function has an associated `geom_` function that it will plot by default
    if you ask it to. This is not particularly important to know by itself, but as
    we will see in the next section, we sometimes want to calculate a different statistic
    for the geom from the default.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一些几何对象直接在图上绘制我们的数据，就像`geom_point()`一样，它接受被指定为`x`和`y`的变量，并在网格上绘制点。但其他几何对象在数据被绘制之前会进行更多的工作。例如尝试`p
    + stat_smooth()`。每个`geom_`函数都有一个相关的`stat_`函数，它默认使用。反之亦然：每个`stat_`函数都有一个相关的`geom_`函数，如果你要求它绘制，它将默认绘制。这本身并不是特别重要，但正如我们将在下一节中看到的，我们有时希望从几何对象计算不同的统计量。
- en: Sometimes the calculations being done by the `stat_` functions that work together
    with the `geom_` functions might not be immediately obvious. For example, consider
    this figure produced by a new geom, `geom_bar()`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，与`geom_`函数一起工作的`stat_`函数所进行的计算可能并不立即明显。例如，考虑由新的`geom`，`geom_bar()`生成的这个图。
- en: '![A bar chart.](../Images/43146b8d2717e9fa73fca324ab1d9701.png) Figure 4.6:
    A bar chart.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![条形图。](../Images/43146b8d2717e9fa73fca324ab1d9701.png) 图4.6：条形图。'
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here we specified just one mapping, `aes(x = bigregion)`. The bar chart produced
    gives us a count of the number of (individual) observations in the data set by
    region of the United States. This seems sensible. But there is a y-axis variable
    here, `count`, that is not in the data. It has been calculated for us. Behind
    the scenes, `geom_bar` called the default `stat_` function associated with it,
    `stat_count()`. This function computes two new variables, `count`, and `prop`
    (short for proportion). The `count` statistic is the one `geom_bar()` uses by
    default.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只指定了一个映射，`aes(x = bigregion)`。生成的条形图给出了数据集中每个（个体）观测值的数量，按美国地区的划分。这似乎是合理的。但这里有一个不在数据中的y轴变量，`count`，它已经被计算出来了。在幕后，`geom_bar`调用了与之关联的默认`stat_`函数，`stat_count()`。此函数计算了两个新变量，`count`和`prop`（简称比例）。`count`统计量是`geom_bar()`默认使用的。
- en: '![A first go at a bar chart with proportions.](../Images/d895e729bfd30955cff742f410fc027e.png)
    Figure 4.7: A first go at a bar chart with proportions.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![第一次尝试绘制带有比例的柱状图。](../Images/d895e729bfd30955cff742f410fc027e.png) 图4.7：第一次尝试绘制带有比例的柱状图。'
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we want a chart of relative frequencies rather than counts, we will need
    to get the `prop` statistic instead. When ggplot calculates the count or the proportion,
    it returns temporary variables that we can use as mappings in our plots. The relevant
    statistic is called `..prop..` rather than `prop`. To make sure these temporary
    variables won’t be confused with others we are working with, their names begin
    and end with two periods. (This is because we might already have a variable called
    `count` or `prop` in our dataset.) So our calls to it from the `aes()` function
    will generically look like this: `<mapping> = <..statistic..>`. In this case,
    we want `y` to use the calculated proportion, so we say `aes(y = ..prop..)`.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个相对频率而不是计数的图表，我们需要获取`prop`统计量。当ggplot计算计数或比例时，它返回临时变量，我们可以将其用作绘图中的映射。相关的统计量称为`..prop..`而不是`prop`。为了确保这些临时变量不会与其他我们正在使用的变量混淆，它们的名称以两个点开始和结束。（这是因为我们可能已经在数据集中有一个名为`count`或`prop`的变量。）因此，我们从`aes()`函数对其的调用将普遍看起来像这样：`<mapping>
    = <..statistic..>`。在这种情况下，我们希望`y`使用计算出的比例，所以我们说`aes(y = ..prop..)`。
- en: The resulting plot is still not right. We no longer have a count on the y-axis,
    but the proportions of the bars all have a value of 1, so all the bars are the
    same height. We want them to *sum* to 1, so that we get the number of observations
    per continent as a proportion of the total number of observations. This is a grouping
    issue again. In a sense, it’s the reverse of the earlier grouping problem we faced
    when we needed to tell ggplot that our yearly data was grouped by country. In
    this case, we need to tell ggplot to *ignore* the x-categories when calculating
    denominator of the proportion, and use the total number observations instead.
    To do so we specify `group = 1` inside the `aes()` call. The value of `1` is just
    a kind of “dummy group” that tells ggplot to use the whole dataset when establishing
    the denominator for its `prop` calculations.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '结果图仍然不正确。我们不再有y轴上的计数，但所有柱子的比例值都是1，所以所有柱子的高度都相同。我们希望它们*总和*为1，这样我们就能得到每个大洲的观测数占总观测数的比例。这又是一个分组问题。从某种意义上说，这是我们在需要告诉ggplot我们的年度数据按国家分组时所面临的早期分组问题的反面。在这种情况下，我们需要告诉ggplot在计算比例的分母时忽略x类别，并使用总观测数。为此，我们在`aes()`调用中指定`group
    = 1`。`1`只是一个“虚拟分组”的值，告诉ggplot在建立其`prop`计算的分母时使用整个数据集。 '
- en: '![A bar chart with correct proportions.](../Images/d442715fd8354e2e5dffe326391aa143.png)
    Figure 4.8: A bar chart with correct proportions.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![带有正确比例的柱状图。](../Images/d442715fd8354e2e5dffe326391aa143.png) 图4.8：带有正确比例的柱状图。'
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Let’s look at another question from the survey. The `gss_sm` data contains a
    `religion` variable derived from a question asking “What is your religious preference?
    Is it Protestant, Catholic, Jewish, some other religion, or no religion?”
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看调查中的另一个问题。`gss_sm`数据包含一个由问题“你的宗教偏好是什么？是基督教徒、天主教徒、犹太教徒、其他宗教，还是无宗教？”派生出的`religion`变量。
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ToRecall that the `$` character is one way of accessing individual columns within
    a data frame or tibble. graph this, we want a bar chart with `religion` on the
    x axis (as a categorical variable), and with the bars in the chart also colored
    by `religion`. If the gray bars look boring and we want to fill them with color
    instead, we can map the `religion` variable to `fill` in addition to mapping it
    to `x`. Remember, `fill` is for painting the insides of shapes. If we map religion
    to `color`, only the border lines of the bars will be assigned colors, and the
    insides will remain gray.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回忆如何绘制图表，我们想要一个柱状图，其中`religion`位于x轴上（作为一个分类变量），并且图表中的柱子也按`religion`着色。如果灰色柱子看起来很无聊，我们想要用颜色填充它们而不是灰色，我们可以将`religion`变量映射到`fill`，除了映射到`x`。记住，`fill`是用来填充形状内部的。如果我们把宗教映射到`color`，只有柱子的边框线会被分配颜色，内部将保持灰色。
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Figure 4.9: GSS Religious Preference mapped to color (left) and both color
    and fill (right).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：GSS宗教偏好映射到颜色（左侧）和颜色及填充（右侧）。
- en: '![GSS Religious Preference mapped to color (left) and both color and fill (right).](../Images/e1f8eb224fc0ea1a1e230d212dc6b3de.png)![GSS
    Religious Preference mapped to color (left) and both color and fill (right).](../Images/0e14eabd1fe63de92809da7f35e9fa61.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![GSS宗教偏好映射到颜色（左）和颜色及填充（右）](../Images/e1f8eb224fc0ea1a1e230d212dc6b3de.png)![GSS宗教偏好映射到颜色（左）和颜色及填充（右）](../Images/0e14eabd1fe63de92809da7f35e9fa61.png)'
- en: By doing this, we have mapped two aesthetics to the same variable. Both `x`
    and `fill` are mapped to `religion`. There is nothing wrong with this. However,
    these are still two separate mappings, and so they get two separate scales. The
    default is to show a legend for the color variable. This legend is redundant,
    because the categories of `religion` are already separated out on the x-axis.
    In its simplest use, the `guides()` function controls whether guiding information
    about any particular mapping appears or not. If we set `guides(fill = FALSE)`,
    the legend is removed, in effect saying that the viewer of the figure does not
    need to be shown any guiding information about this mapping. Setting the guide
    for some mapping to `FALSE` only has an effect if there is a legend to turn off
    to begin with. Trying `x = FALSE` or `y = FALSE` will have no effect, as these
    mappings have no additional guides or legends separate from their scales. It is
    possible to turn the x and y scales off altogether, but this is done though a
    different function, one from the `scale_` family.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们将两个美学映射到同一个变量。`x`和`fill`都映射到`religion`。这并没有什么问题。然而，这些仍然是两个独立的映射，因此它们各自有不同的比例。默认情况下，会显示颜色变量的图例。这个图例是多余的，因为`religion`的类别已经在x轴上分开。在其最简单的使用中，`guides()`函数控制是否显示任何特定映射的引导信息。如果我们设置`guides(fill
    = FALSE)`，则移除图例，实际上表示观众不需要看到关于此映射的任何引导信息。将某些映射的引导设置为`FALSE`只有当最初有图例可以关闭时才有效。尝试`x
    = FALSE`或`y = FALSE`将没有效果，因为这些映射没有除其比例之外的其他额外的引导或图例。可以完全关闭x和y比例，但这是通过一个不同的函数，即`scale_`家族中的一个函数来完成的。
- en: 4.5 Frequency plots the slightly awkward way
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 以略尴尬的方式绘制频率图
- en: A more appropriate use of the `fill` aesthetic with `geom_bar()` is to cross-classify
    two categorical variables. This is the graphical equivalent of a frequency table
    of counts or proportions. Using the GSS data, for instance, we might want to examine
    the distribution of religious preferences within different regions of the United
    States. In the next few paragraphs we will see how to do this just using ggplot.
    However, as we shall also discover, it is often not the most transparent way to
    make frequency tables of this sort. The next chapter introduces a simpler and
    less error-prone approach where we calculate the table first before passing the
    results along to ggplot to graph. As you work through this section, bear in mind
    that if you find things slightly awkward or confusing it is because that’s exactly
    what they are.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`geom_bar()`的`fill`美学属性的一个更合适的用途是交叉分类两个分类变量。这在图形上等同于计数或比例的频率表。例如，使用GSS数据，我们可能想检查美国不同地区的宗教偏好分布。在接下来的几段中，我们将看到如何仅使用ggplot来完成这项工作。然而，正如我们将发现的，这通常不是制作此类频率表最透明的方式。下一章介绍了一种更简单、更不易出错的办法，我们首先计算表格，然后将结果传递给ggplot进行绘图。当你阅读这一部分时，请记住，如果你觉得事情有些尴尬或困惑，那正是因为它们确实如此。
- en: Let’s say we want to look at religious preference by census region. That is,
    we want the `religion` variable broken down proportionally within `bigregion`.
    When we cross-classify categories in bar charts, there are several ways to display
    the results. With `geom_bar()` the output is controlled by the `position` argument.
    Let’s begin by mapping `fill` to `religion`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想按人口普查区域查看宗教偏好。也就是说，我们希望`religion`变量在`bigregion`内按比例分解。当我们用条形图交叉分类类别时，有几种方式来展示结果。使用`geom_bar()`时，输出由`position`参数控制。让我们首先将`fill`映射到`religion`。
- en: '![A stacked bar chart of Religious Preference by Census Region.](../Images/e414ea7d060124909f69fd5b85452631.png)
    Figure 4.10: A stacked bar chart of Religious Preference by Census Region.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![按人口普查区域宗教偏好的堆叠条形图](../Images/e414ea7d060124909f69fd5b85452631.png) 图4.10：按人口普查区域宗教偏好的堆叠条形图。'
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The default output of `geom_bar()` is a stacked bar chart, with counts on the
    y-axis (and hence counts within the stacked segments of the bars also). Region
    of the country is on the x-axis, and counts of religious preference are stacked
    within the bars. As we saw in Chapter [1](lookatdata.html#lookatdata), it is somewhat
    difficult for readers of the chart to compare lengths an areas on an unaligned
    scale. So while the relative position of the bottom categories are quite clear
    (thanks to them all being aligned on the x-axis), the relative positions of say,
    the “Catholic” category is harder to assess. An alternative choice is to set the
    `position` argument to `"fill"`. (This is different from the `fill` aesthetic.)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`geom_bar()`的默认输出是堆叠条形图，y轴上显示计数（因此条形图的堆叠部分内的计数也是）。国家地区在x轴上，宗教偏好的计数在条形图内堆叠。正如我们在第[1](lookatdata.html#lookatdata)章中看到的，对于图表的读者来说，在未对齐的刻度上比较长度和面积有些困难。因此，尽管底部类别的相对位置非常清晰（多亏它们都在x轴上对齐），但例如“天主教”类别的相对位置就难以评估。另一种选择是将`position`参数设置为`"fill"`。（这与`fill`美学不同。）'
- en: '![Using the fill position adjustment to show relative proportions across categories.](../Images/73484330223ad56919c8ece2f1c08d48.png)
    Figure 4.11: Using the fill position adjustment to show relative proportions across
    categories.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用填充位置调整来显示类别间的相对比例](../Images/73484330223ad56919c8ece2f1c08d48.png) 图4.11：使用填充位置调整来显示类别间的相对比例。'
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now the bars are all the same height, which makes it easier to compare proportions
    across groups. But we lose the ability to see the relative size of each cut with
    respect to the overall total. What if we wanted to show the proportion or percentage
    of religions within regions of the country, like in Figure [4.11](groupfacettx.html#fig:ch-04-gss-06A),
    but instead of stacking the bars we wanted separate bars instead? As a first attempt,
    we can use `position="dodge"` to make the bars within each region of the country
    appear side by side. However, if we do it this way (try it), we will find that
    ggplot places the bars side-by-side as intended, but changes the y-axis back to
    a *count* of cases within each category rather than showing us a proportion. We
    saw in Figure [4.8](groupfacettx.html#fig:ch-04-gss-04) that to display a proportion
    we needed to map `y = ..prop..`, so the correct statistic would be calculated.
    Let’s see if that works.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在条形图的高度都一样，这使得比较组间的比例更容易。但我们失去了看到每个切割相对于整体总量的相对大小的能力。如果我们想展示国家不同地区的宗教比例，就像图[4.11](groupfacettx.html#fig:ch-04-gss-06A)所示，但我们不想堆叠条形图，而是想使用单独的条形图呢？作为一个初步尝试，我们可以使用`position="dodge"`来使国家每个地区的条形图并排显示。然而，如果我们这样做（试试看），我们会发现ggplot将条形图并排放置，但将y轴改回每个类别的案例数，而不是显示比例。我们在图[4.8](groupfacettx.html#fig:ch-04-gss-04)中看到，要显示比例，我们需要将`y
    = ..prop..`映射，因此正确的统计量将被计算。让我们看看这行不行。
- en: '![A first go at a dodged bar chart with proportional bars.](../Images/122f0ae3696aefaeec2a9fbe35080d45.png)
    Figure 4.12: A first go at a dodged bar chart with proportional bars.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![第一次尝试绘制带有比例条的避让条形图](../Images/122f0ae3696aefaeec2a9fbe35080d45.png) 图4.12：第一次尝试绘制带有比例条的避让条形图。'
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The result is certainly colorful, but not what we wanted. Just as in Figure
    [4.7](groupfacettx.html#fig:ch-04-gss-03), there seems to be an issue with the
    grouping. When we just wanted the overall proportions for one variable, we mapped
    `group = 1` to tell ggplot to calculate the proportions with respect to the overall
    N. In this case our grouping variable is `religion`, so we might try mapping that
    to the `group` aesthetic.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 结果当然很丰富多彩，但并非我们想要的效果。正如图[4.7](groupfacettx.html#fig:ch-04-gss-03)所示，似乎存在分组问题。当我们只想得到一个变量的整体比例时，我们将`group
    = 1`映射到ggplot，以告诉ggplot根据整体N计算比例。在这种情况下，我们的分组变量是`religion`，所以我们可能会尝试将其映射到`group`美学。
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This gives us a bar chart where the values of `religion` are broken down across
    regions, with a proportion showing on the y-axis. If you inspect the bars in Figure
    [4.13](groupfacettx.html#fig:ch-04-gss-08), you will see that they do not sum
    to one within each region. Instead, the bars for any particular religion sum to
    one *across* regions.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个条形图，其中`religion`的值按地区分解，y轴上显示比例。如果你检查图[4.13](groupfacettx.html#fig:ch-04-gss-08)中的条形图，你会发现它们在每个地区内并不总和为1。相反，任何特定宗教的条形图在地区间总和为1。
- en: '![A second attempt at a dodged bar chart with proportional bars.](../Images/62ddd4c886912aa5429cf43d7e0aaaee.png)
    Figure 4.13: A second attempt at a dodged bar chart with proportional bars.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![第二次尝试制作带有比例条的错位条形图。](../Images/62ddd4c886912aa5429cf43d7e0aaaee.png) 图 4.13：第二次尝试制作带有比例条的错位条形图。'
- en: This lets us see that nearly half of those who said they were Protestant live
    in the South, for example. Meanwhile, just over ten percent of those saying they
    were Protestant live in the Northeast. Similarly, it shows that over half of those
    saying they were Jewish live in the Northeast, compared to about a quarter who
    live in the South.Proportions for smaller sub-populations tend to bounce around
    from year to year in the GSS.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们可以看到，例如，几乎一半声称自己是新教徒的人居住在南方。与此同时，只有超过十 percent 的声称自己是新教徒的人居住在东北部。同样，它显示说他们是犹太人的超过一半的人居住在东北部，相比之下，大约四分之一的人居住在南方。GSS
    中较小子群体比例往往每年都会上下波动。
- en: We are still not quite where we originally wanted to be. Our goal was to take
    the stacked bar chart in Figure [4.10](groupfacettx.html#fig:ch-04-gss-06) but
    have the proportions shown side-by-side instead of on top of one another.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完全达到最初想要的位置。我们的目标是使用图 [4.10](groupfacettx.html#fig:ch-04-gss-06) 中的堆叠条形图，但将比例并排显示而不是重叠在一起。
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It turns out that the easiest thing to do is to stop trying to force `geom_bar()`
    to do all the work in a single step. Instead, we can ask ggplot to give us a proportional
    bar chart of religious affiliation, and then facet that by region. The proportions
    are calculated within each panel, which is the breakdown we wanted. This has the
    added advantage of not producing too many bars within each category.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，最容易做的事情是停止尝试强迫 `geom_bar()` 在一个步骤中完成所有工作。相反，我们可以要求 ggplot 给我们一个宗教归属的比例条形图，然后按地区细分。比例是在每个面板内计算的，这正是我们想要的分解。这还有一个额外的优点，即不会在每个类别中产生过多的条形。
- en: 'Figure 4.14: Faceting proportions within region.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14：在区域内细分比例。
- en: '![Faceting proportions within region.](../Images/d67901facd927e98d4056ebe5e2ff2aa.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![在区域内细分比例。](../Images/d67901facd927e98d4056ebe5e2ff2aa.png)'
- en: We could polish this plot further, but for the moment we will stop here. When
    constructing frequency plots directly in ggplot, it is a little too easy to get
    stuck in a cycle of not quite getting the marginal comparison that you want, and
    more or less randomly poking at the mappings to try to stumble on the the right
    breakdown. In the next Chapter, we will learn how to use the tidyverse’s `dplyr`
    library to produce the tables we want *before* we try to plot them. This is a
    more reliable approach, and easier to check for errors. It will also give us tools
    that can be used for many more tasks than producing summaries.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步润色这个图表，但暂时我们先到这里。当直接在 ggplot 中构建频率图时，很容易陷入一个循环，即无法得到你想要的边际比较，并且或多或少随机地戳映射以试图偶然发现正确的分解。在下一章中，我们将学习如何使用
    tidyverse 的 `dplyr` 库在尝试绘图之前生成我们想要的表格。这是一个更可靠的方法，并且更容易检查错误。它还将为我们提供可用于许多更多任务的工具。
- en: 4.6 Histograms and density plots
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 直方图和密度图
- en: Different geoms transform data in different ways, but ggplot’s vocabulary for
    them is consistent. We can see similar transformations at work when summarizing
    a continuous variable using a histogram, for example. A histogram is a way of
    summarizing a continuous variable by chopping it up into segments or “bins” and
    counting how many observations are found within each bin. In a bar chart, the
    categories are given to us going in (e.g., regions of the country, or religious
    affiliation). With a histogram, we have to decide how finely to bin the data.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的几何形状以不同的方式转换数据，但 ggplot 对它们的词汇是一致的。例如，当我们使用直方图总结连续变量时，我们可以看到类似的转换在起作用。直方图是一种通过将其切割成段或“箱”并计算每个箱中找到的观测值的数量来总结连续变量的方法。在条形图中，类别是预先给出的（例如，国家的地区或宗教归属）。在直方图中，我们必须决定如何精细地划分数据。
- en: For example, ggplot comes with a dataset, `midwest`, containing information
    on counties in several midwestern states of the USA. Counties vary in size, so
    we can make a histogram showing the distribution of their geographical areas.
    Area is measured in square miles. Because we are summarizing a continuous variable
    using a series of bars, we need to divide the observations into groups, or bins,
    and count how many are in each one. By default, the `geom_histogram()` function
    will choose a bin size for us based on a rule of thumb.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，ggplot附带一个数据集`midwest`，其中包含美国几个中西部的县信息。县的大小各不相同，因此我们可以制作一个直方图来显示它们地理面积的分部。面积以平方英里为单位。因为我们正在使用一系列条形来总结连续变量，所以我们需要将观测值分成组，或称为区间，并计算每个区间中有多少个。默认情况下，`geom_histogram()`函数将根据经验规则为我们选择一个区间大小。
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Figure 4.15: Histograms of the same variable, using different numbers of bins.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15：使用不同数量的区间绘制同一变量的直方图。
- en: '![Histograms of the same variable, using different numbers of bins.](../Images/1d7fb516aa00dbbe85f20728243a9b60.png)![Histograms
    of the same variable, using different numbers of bins.](../Images/afaa4400507757217c75298e5fc5791f.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![使用不同数量的区间绘制同一变量的直方图](../Images/1d7fb516aa00dbbe85f20728243a9b60.png)![使用不同数量的区间绘制同一变量的直方图](../Images/afaa4400507757217c75298e5fc5791f.png)'
- en: As with the bar charts, a newly-calculated variable, `count`, appears on the
    x-axis. The notification from R tells us that behind the scenes the `stat_bin()`
    function picked 30 bins, but we might want to try something else. When drawing
    histograms it is worth experimenting with `bins` and also optionally the `origin`
    of the x-axis. Each, and especially `bins`, will make a big difference to how
    the resulting figure looks.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与条形图一样，一个新的变量`count`出现在x轴上。R的通知告诉我们，在幕后`stat_bin()`函数选择了30个区间，但我们可能想尝试其他方法。在绘制直方图时，尝试不同的`bins`以及可选的x轴的`origin`是值得的。每一个，尤其是`bins`，都会对最终图形的外观产生重大影响。
- en: While histograms summarize single variables, it’s also possible to use several
    at once to compare distributions. We can facet histograms by some variable of
    interest, or as here we can compare them in the same plot using the `fill` mapping.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然直方图总结了单个变量，但也可以同时使用几个来比较分布。我们可以通过感兴趣的某个变量对直方图进行分面，或者像这里一样，我们可以使用`fill`映射在同一张图上比较它们。
- en: '![Comparing two histograms.](../Images/f1dd80bb96810898efdb7d0e6eed506a.png)
    Figure 4.16: Comparing two histograms.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![比较两个直方图](../Images/f1dd80bb96810898efdb7d0e6eed506a.png)图4.16：比较两个直方图。'
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We subset the data here to pick out just two states. To do this we create a
    character vector with just two elements, “OH” and “WI”. Then we use the `subset()`
    function to take our data and filter it so that we only select rows whose `state`
    name is in this vector. The `%in%` operator is a convenient way to filter on more
    than one term in a variable when using `subset()`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过创建只包含两个元素“OH”和“WI”的字符向量来对数据进行子集化，以选择仅两个州。为此，我们使用`subset()`函数来获取我们的数据，并过滤它，以便我们只选择`state`名称在这个向量中的行。`%in%`运算符是使用`subset()`在变量中过滤多个术语的一种方便方法。
- en: When working with a continuous variable, an alternative to binning the data
    and making a histogram is to calculate a kernel density estimate of the underlying
    distribution. The `geom_density()` function will do this for us.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理连续变量时，除了对数据进行分箱并制作直方图外，还可以计算底层分布的核密度估计。`geom_density()`函数会为我们做这件事。
- en: '![Kernel density estimate of county areas.](../Images/d0c2f356c27a2ba25016e64519992e3f.png)
    Figure 4.17: Kernel density estimate of county areas.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![县面积核密度估计](../Images/d0c2f356c27a2ba25016e64519992e3f.png)图4.17：县面积核密度估计。'
- en: '[PRE49]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can use `color` (for the lines) and `fill` (for the body of the density curve)
    here, too. These figures often look quite nice. But when there are several filled
    areas on the plot, as in this case, the overlap can become hard to read. If you
    want to make the baselines of the density curves go away, you can use `geom_line(stat
    = "density")` instead. This also removes the possibility of using the `fill` aesthetic.
    But this may be an improvement in some cases. Try it with the plot of state areas
    and see how they compare.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在这里使用`color`（用于线条）和`fill`（用于密度曲线的主体）。这些图形通常看起来相当不错。但当图表上有多个填充区域时，如本例所示，重叠可能会变得难以阅读。如果你想让密度曲线的基线消失，可以使用`geom_line(stat
    = "density")`代替。这也排除了使用`fill`美学的可能性。但这在某些情况下可能是一个改进。尝试使用州面积图来查看它们如何比较。
- en: '[PRE50]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Figure 4.18: Comparing distributions.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18：比较分布。
- en: '![Comparing distributions.](../Images/65ad622a4337f78bd834678e61fc0eee.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![比较分布](../Images/65ad622a4337f78bd834678e61fc0eee.png)'
- en: Just like `geom_bar()`, the count-based defaults computed by the `stat_` functions
    used by `geom_histogram()` and `geom_density()` will return proportional measures
    if we ask them. For `geom_density()`, the `stat_density()` function can return
    its default `..density..` statistic, or `..scaled..`, which will give a proportional
    density estimate. It can also return a statistic called `..count..`, which is
    the density times the number of points. This can be used in stacked density plots.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `geom_bar()` 一样，`geom_histogram()` 和 `geom_density()` 中使用的 `stat_` 函数基于计数的默认计算将返回比例度量，如果我们要求它们这样做。对于
    `geom_density()`，`stat_density()` 函数可以返回其默认的 `..density..` 统计量，或者 `..scaled..`，这将给出一个比例密度估计。它还可以返回一个名为
    `..count..` 的统计量，这是密度乘以点的数量。这可以用于堆叠密度图。
- en: '![Scaled densities.](../Images/170a065023026a8f463517a53b7c2297.png) Figure
    4.19: Scaled densities.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![缩放密度](../Images/170a065023026a8f463517a53b7c2297.png) 图 4.19：缩放密度。'
- en: '[PRE51]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 4.7 Avoid transformations when necessary
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7 在必要时避免转换
- en: 'As we have seen from the beginning, ggplot normally makes its charts starting
    from a full dataset. When we call `geom_bar()` it does its calculations on the
    fly using `stat_count()` behind the scenes to produce the counts or proportions
    it displays. In the previous section, we looked at a case where we wanted to group
    and aggregate our data ourselves before handing it off to ggplot. But often, our
    data is in effect *already* a summary table. This can happen when we have computed
    a table of marginal frequencies or percentages from our original data already.
    Plotting results from statistical models also puts us in this position, as we
    will see later. Or it may be that we just have a finished table of data (from
    the Census, say, or an official report) that we want to make into a graph. For
    example, perhaps we do not have the individual-level data on who survived the
    *Titanic* disaster, but we do have a small table of counts of survivors by sex:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从一开始看到的，ggplot 通常从完整的数据集开始制作图表。当我们调用 `geom_bar()` 时，它会即时计算，在幕后使用 `stat_count()`
    来产生它显示的计数或比例。在前一节中，我们查看了一个我们想要在将数据交给 ggplot 之前自己分组和汇总数据的例子。但通常，我们的数据实际上已经是一个汇总表。这可能会发生在我们已经从原始数据中计算出了边际频率或百分比表的情况下。绘制统计模型的结果也会使我们处于这种位置，正如我们稍后将会看到的。或者，可能我们只是有一个完成的数据表（例如，来自人口普查或官方报告），我们想要将其制作成图表。例如，我们可能没有关于谁在
    *泰坦尼克号* 灾难中幸存下来的个体级数据，但我们有一个按性别划分的幸存者计数的小表：
- en: '[PRE52]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Because we are working directly with percentage values in a summary table, we
    no longer have any need for ggplot to count up values for us or perform any other
    calculations. That is, we do not need the services of any `stat_` functions that
    `geom_bar()` would normally call. We can tell `geom_bar()` not to do any work
    on the variable before plotting it. To do this we say `stat = 'identity'` in the
    `geom_bar()` call. We’ll also move the legend to the top of the chart.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们直接在汇总表中使用百分比值，我们不再需要 ggplot 为我们计数或执行任何其他计算。也就是说，我们不需要 `geom_bar()` 通常会调用的任何
    `stat_` 函数的服务。我们可以告诉 `geom_bar()` 在绘图之前不要对变量进行任何操作。为此，我们在 `geom_bar()` 调用中指定 `stat
    = 'identity'`。我们还将图例移动到图表的顶部。
- en: '![Survival on the Titanic, by Sex.](../Images/771b705af5b3db7232da929fdd911d8f.png)
    Figure 4.20: Survival on the Titanic, by Sex.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![按性别划分的泰坦尼克号幸存率](../Images/771b705af5b3db7232da929fdd911d8f.png) 图 4.20：按性别划分的泰坦尼克号幸存率。'
- en: '[PRE54]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: For convenience ggplot also provides a related geom, `geom_col()`, which has
    exactly the same effect but assumes that `stat = "identity"`. We will use this
    form in future when we don’t need any calculations done on the plot.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，ggplot 还提供了一个相关的几何对象 `geom_col()`，它具有完全相同的效果，但假设 `stat = "identity"`。在将来，当我们不需要在图表上执行任何计算时，我们将使用这种形式。
- en: The `position` argument in `geom_bar()` and `geom_col()` can also take the value
    of `"identity"`. Just as `stat = "identity"` means “don’t do any summary calculations”,
    `position = "identity"` means “just plot the values as given”. This allows us
    to do things like, for example, plot a flow of positive and negative values in
    a bar chart. This sort of graph is an alternative to a line plot and is often
    seen in public policy settings where changes relative to some threshold level
    or baseline are of interest. For example, the `oecd_sum` table in `socviz` contains
    information on average life expectancy at birth within the United States, and
    across other OECD countries.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`geom_bar()`和`geom_col()`中的`position`参数也可以取值为`"identity"`。正如`stat = "identity"`意味着“不进行任何汇总计算”，`position
    = "identity"`意味着“仅按给定值绘制”。这允许我们做一些事情，例如，在柱状图中绘制正负值的流动。这种图表是线图的替代品，通常在公共政策环境中可以看到，其中对相对于某个阈值水平或基线的变化感兴趣。例如，`socviz`中的`oecd_sum`表包含美国及其他OECD国家出生时平均预期寿命的信息。'
- en: '[PRE55]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `other` column is the average life expectancy in a given year for OECD countries,
    excluding the United States. The `usa` column is the US life expectancy, `diff`
    is the difference between the two values, and `hi_lo` indicates whether the US
    value for that year was above or below the OECD average. We will plot the difference
    over time, and use the `hi_lo` variable to color the columns in the chart.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`other`列表示OECD国家在特定年份的平均预期寿命，不包括美国。`usa`列表示美国的预期寿命，`diff`表示这两个值的差异，而`hi_lo`表示美国那一年的值是高于还是低于OECD的平均值。我们将绘制随时间变化的差异，并使用`hi_lo`变量来为图表中的列着色。'
- en: '[PRE57]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '![Using <code>geom\_col()</code> to plot negative and positive values in a
    bar chart.](../Images/06bcc4f1333270280d72e98d90d0a5dc.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![使用`geom_col()`在柱状图中绘制负值和正值](../Images/06bcc4f1333270280d72e98d90d0a5dc.png)'
- en: 'Figure 4.21: Using `geom_col()` to plot negative and positive values in a bar
    chart.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21：使用`geom_col()`在柱状图中绘制负值和正值。
- en: As with the `titanic` plot, the default action of `geom_col()` is to set both
    `stat` and `position` to “`identity`”. To get the same effect with `geom_bar()`
    we would need to say `geom_bar(position = "identity")`. As before, the `guides(fill=FALSE)`
    instruction at the end tells ggplot to drop the unnecessary legend that would
    otherwise be automatically generated to accompany the `fill` mapping.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 与`titanic`图表一样，`geom_col()`的默认操作是设置`stat`和`position`都为“`identity`”。要使用`geom_bar()`获得相同的效果，我们需要说`geom_bar(position
    = "identity")`。与之前一样，最后的`guides(fill=FALSE)`指令告诉ggplot不要生成不必要的图例，否则会自动生成以伴随`fill`映射。
- en: At this point, we have a pretty good sense of the core steps we must take to
    visualize our data. In fact, thanks to ggplot’s default settings, we now have
    the ability to make good-looking and informative plots. Starting with a tidy dataset,
    we know how to map variables to aesthetics, to choose from a variety of geoms,
    and make some adjustments to the scales of the plot. We also know more about selecting
    the right sort of computed statistic to show on the graph, if that’s what’s needed,
    and how to facet our core plot by one or more variables. We know how to set descriptive
    labels for axes, and write a title, subtitle, and caption. Now we’re in a position
    to put these skills to work in a more fluent way.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对必须采取的核心步骤以可视化我们的数据有了相当好的认识。事实上，多亏了ggplot的默认设置，我们现在有能力制作出既美观又富有信息量的图表。从整洁的数据集开始，我们知道如何将变量映射到美学，从各种geom中选择，并对图表的尺度进行一些调整。我们还了解更多关于选择正确的计算统计量在图上显示，如果需要的话，以及如何通过一个或多个变量分面我们的核心图表。我们知道如何设置轴的描述性标签，并编写标题、副标题和图注。现在我们能够更流畅地运用这些技能。
- en: 4.8 Where to go next
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8 接下来去哪里
- en: Revisit the `gapminder` plots at the beginning of the chapter and experiment
    with different ways to facet the data. Try plotting population and per capita
    GDP while faceting on year, or even on country. In the latter case you will get
    a lot of panels, and plotting them straight to the screen may take a long time.
    Instead, assign the plot to an object and save it as a PDF file to your `figures/`
    folder. Experiment with the height and width of the figure.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾章节开头的`gapminder`图表，并尝试不同的数据分面方式。尝试在按年份或甚至按国家分面时绘制人口和人均GDP。在后一种情况下，您将得到很多面板，直接绘制到屏幕上可能需要很长时间。相反，将图表分配给一个对象，并将其保存为PDF文件到您的`figures/`文件夹。尝试调整图形的高度和宽度。
- en: Investigate the difference between a formula written as `facet_grid(sex ~ race)`
    versus one written as `facet_grid(~ sex + race)`.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查将公式写成 `facet_grid(sex ~ race)` 与写成 `facet_grid(~ sex + race)` 之间的差异。
- en: Experiment to see what happens when you use `facet_wrap()` with more complex
    forumulas like `facet_wrap(~ sex + race)` instead of `facet_grid`. Like `facet_grid()`,
    the `facet_wrap()` function can facet on two or more variables at once. But it
    will do it by laying the results out in a wrapped one-dimensional table instead
    of a fully cross-classified grid.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用更复杂的公式，如 `facet_wrap(~ sex + race)` 而不是 `facet_grid`，来实验一下会发生什么。与 `facet_grid()`
    一样，`facet_wrap()` 函数可以同时根据两个或多个变量进行分面。但它将通过将结果布局在一个包裹的一维表中而不是一个完全交叉分类的网格中来实现这一点。
- en: Frequency polygons are closely related to histograms. Instead of displaying
    the count of observations using bars, they display it with a series of connected
    lines instead. You can try the various `geom_histogram()` calls in this chapter
    using `geom_freqpoly()` instead.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频率多边形与直方图密切相关。它们不是使用条形显示观测值的计数，而是使用一系列连接的线条来显示。你可以尝试使用 `geom_freqpoly()` 替代本章中的各种
    `geom_histogram()` 调用。
- en: A histogram bins observations for one variable and shows a bars with the count
    in each bin. We can do this for two variables at once, too. The `geom_bin2d()`
    function takes two mappings, `x` and `y`. It divides your plot into a grid and
    colors the bins by the count of observations in them. Try using it on the `gapminder`
    data to plot life expectancy versus per capita GDP. Like a histogram, you can
    vary the number or width of the bins for both `x` or `y`. Instead of saying `bins
    = 30` or `binwidth = 1`, provide a number for both `x` and `y` with, for example,
    `bins = c(20, 50)`. If you specify `bindwith` instead, you will need to pick values
    that are on the same scale as the variable you are mapping.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直方图将一个变量的观测值进行分组，并显示每个分组中的计数。我们也可以同时为两个变量这样做。`geom_bin2d()` 函数接受两个映射，`x` 和 `y`。它将你的绘图分成一个网格，并通过每个分组中的观测值计数来着色。尝试使用
    `gapminder` 数据来绘制预期寿命与人均 GDP 的对比图。与直方图一样，你可以改变 `x` 或 `y` 的分组数量或宽度。而不是说 `bins =
    30` 或 `binwidth = 1`，你可以为 `x` 和 `y` 提供一个数字，例如 `bins = c(20, 50)`。如果你指定 `binwidth`，你需要选择与你要映射的变量相同尺度的值。
- en: Density estimates can also be drawn in two dimensions. The `geom_density_2d()`
    function draws contour lines estimating the joint distribution of two variables.
    Try it with the `midwest` data, for example, plotting percent below the poverty
    line (`percbelowpoverty`) against percent college-educated (`percollege`). Try
    it with and without a `geom_point()` layer.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密度估计也可以在二维中进行。`geom_density_2d()` 函数绘制等高线，估计两个变量的联合分布。例如，尝试使用 `midwest` 数据，绘制贫困线以下百分比（`percbelowpoverty`）与受过大学教育百分比（`percollege`）的对比图。尝试添加和移除
    `geom_point()` 层。
