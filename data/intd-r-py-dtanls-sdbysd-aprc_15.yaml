- en: Chapter 11 Control Flow
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 控制流
- en: 原文：[https://randpythonbook.netlify.app/control-flow](https://randpythonbook.netlify.app/control-flow)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://randpythonbook.netlify.app/control-flow](https://randpythonbook.netlify.app/control-flow)
- en: 11.1 Conditional Logic
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 条件逻辑
- en: We discussed Boolean/logical objects in [2](/basic-types#basic-types). We used
    these for
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[2](/basic-types#basic-types)中讨论了布尔/逻辑对象。我们使用这些来
- en: counting the number of times a condition appeared, and
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算条件出现的次数，以及
- en: subsetting vectors and data frames.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量子集和数据框。
- en: Another way to use them is to conditionally execute code. You can choose to
    execute code depending on whether or not a Boolean/logical value is true or not.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种使用它们的方法是条件性地执行代码。你可以选择根据布尔/逻辑值是否为真来执行代码。
- en: 'This is what an [if statement looks like In R](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#if):'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是R中[if语句](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#if)的样子：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[In Python](https://docs.python.org/3/tutorial/controlflow.html#if-statements),
    you don’t need curly braces, but the indentation needs to be just right, and you
    need a colon (Lutz [2013](#ref-Lutz13)).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[在Python中](https://docs.python.org/3/tutorial/controlflow.html#if-statements)，你不需要花括号，但缩进必须恰到好处，并且需要冒号（Lutz
    [2013](#ref-Lutz13)）。'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There can be more than one test of truth. To test alternative conditions, you
    can add one or more `else if` (in R) or `elif` (in Python) blocks. The first block
    with a Boolean that is found to be true will execute, and none of the resulting
    conditions will be checked.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 可以有多个真值测试。为了测试替代条件，你可以添加一个或多个`else if`（在R中）或`elif`（在Python中）块。第一个找到为真的布尔值所在的块将被执行，并且不会检查任何产生的条件。
- en: If no `if` block or `else if`/`elif` block executes, an `else` block will always
    execute. That’s why `else` blocks don’t need to look at a Boolean. Whether they
    execute only depends on the Booleans in the previous blocks. If there is no `else`
    block, and none of the previous conditions are true, nothing will execute.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有`if`块或`else if`/`elif`块执行，`else`块将始终执行。这就是为什么`else`块不需要查看布尔值。它们是否执行只取决于前面的布尔值。如果没有`else`块，并且前面的条件都不为真，则不会执行任何操作。
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 11.2 Loops
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 循环
- en: One line of code generally does one “thing,” unless you’re using loops. Code
    written inside a loop will execute many times.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一行代码通常做一件“事情”，除非你使用循环。循环内的代码将执行多次。
- en: The most common loop for us will be a `for` loop. A simple [`for` loop in R](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#for)
    might look like this
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，最常见的循环将是`for`循环。一个简单的R中的`for`循环可能看起来像这样
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`seq_len(myLength)` gives us a `vector`.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`seq_len(myLength)`给我们一个`向量`。'
- en: '`i` is a variable that takes on the values found in `seq_len(myLength)`.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`i`是一个变量，它取`seq_len(myLength)`中找到的值。'
- en: Code inside the loop (inside the curly braces), is repeatedly executed, and
    it may or may not reference the dynamic variable `i`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环（花括号内）中的代码将被反复执行，并且可能或可能不引用动态变量`i`。
- en: '[Here is an example of a for loop in Python](https://docs.python.org/3/tutorial/controlflow.html#for-statements)
    (Lutz [2013](#ref-Lutz13)):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[以下是一个Python中for循环的示例](https://docs.python.org/3/tutorial/controlflow.html#for-statements)（Lutz
    [2013](#ref-Lutz13)）：'
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Unsurprisingly, Python’s syntax opts for indentation and colons instead of curly
    braces and parentheses.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 毫不奇怪，Python的语法选择缩进和冒号而不是花括号和括号。
- en: Code inside the loop (indented underneath the `for` line), is repeatedly executed,
    and it may or may not reference the dynamic variable `i`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环（位于`for`行下缩进）中的代码将被反复执行，并且可能或可能不引用动态变量`i`。
- en: '`for` loops in Python are more flexible because they iterate over many different
    types of data structures–in this case [`range()` returns an object of type `range`](https://docs.python.org/3/library/stdtypes.html#range).'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python中的`for`循环更灵活，因为它们遍历许多不同类型的数据结构——在这个例子中，`range()`返回一个类型为`range`的对象（[https://docs.python.org/3/library/stdtypes.html#range](https://docs.python.org/3/library/stdtypes.html#range)）。
- en: The [`range`](https://docs.python.org/3/tutorial/controlflow.html#the-range-function)
    doesn’t generate all the numbers in the sequence at once, so it saves on memory.
    This can be quite useful if you’re looping over a large collection, and you don’t
    need to store everything all at once. However, in this example, `r` is a list
    that *does* store all the consecutive integers.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`range`函数不会一次性生成序列中的所有数字，因此它节省了内存。如果你正在遍历一个大型集合，并且不需要一次性存储所有内容，这可以非常有用。然而，在这个例子中，`r`是一个列表，它确实存储了所有连续的整数。'
- en: Loops are for repeatedly executing code. `for` loops are great when you know
    the number of iterations needed ahead of time. If the number of iterations is
    not known, then you’ll need a `while` loop. While loops will only terminate after
    a condition is found to be true. Here are some examples [in R](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#while)
    and [in Python](https://docs.python.org/3/reference/compound_stmts.html#while).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 循环用于重复执行代码。当你事先知道所需的迭代次数时，`for`循环非常出色。如果迭代次数未知，那么你需要一个`while`循环。当找到条件为真时，`while`循环才会终止。以下是一些[在R](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#while)和[在Python](https://docs.python.org/3/reference/compound_stmts.html#while)的例子。
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here are some tips for writing loops:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于编写循环的技巧：
- en: If you find yourself copying and pasting code, changing only a small portion
    of text on each line of code, you should consider using a loop.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你发现自己正在复制和粘贴代码，每次只更改代码每一行中的一小部分文本，你应该考虑使用循环。
- en: If a `for` loop works for something you are trying to do, first try to find
    a replacement function that does what you want. The examples above just made a
    `vector`/`list` of consecutive integers. There are many built in functions that
    accomplish this. Avoiding loops in this case would make your program shorter,
    easier to read, and (potentially) much faster.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`for`循环适用于你想要做的事情，首先尝试找到一个可以完成你想要的功能的替换函数。上面的例子只是创建了一个连续整数的`vector`/`list`。有许多内置函数可以完成这个任务。在这种情况下避免循环会使你的程序更短，更容易阅读，并且（可能）运行得更快。
- en: A third option between looping, and a built-in function, is to try the functional
    approach. This will be explained more in the last chapter.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环和内置函数之间还有一个选择，那就是尝试函数式方法。这将在最后一章中进一步解释。
- en: Watch out for [**off-by-one** errors](https://en.wikipedia.org/wiki/Off-by-one_error).
    Iterating over the wrong sequence is a common mistake, considering
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意[**off-by-one**错误](https://en.wikipedia.org/wiki/Off-by-one_error)。迭代错误的序列是一个常见的错误，考虑到
- en: Python starts counting from \(0\), while R starts counting from \(1\)
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python从\(0\)开始计数，而R从\(1\)开始计数
- en: sometimes iteration `i` references the `i-1`th element of a container
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时迭代`i`引用的是容器中的`i-1`个元素
- en: The behavior of loops is sometimes more difficult to understand if they’re using
    [`break`](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Looping)
    or [`continue`/`next` statements](https://docs.python.org/3/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops).
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果循环使用了`break`或`continue`/`next`语句，那么循环的行为有时可能更难以理解。[`break`](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Looping)或[`continue`/`next`语句](https://docs.python.org/3/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops)。
- en: '*Don’t hardcode variables.* In other words, don’t write code that is specific
    to particulars of your script’s current draft. Write code that will still run
    if your program is fed different data, or if you need to calculate something else
    that’s closely-related (e.g. run the same calculations on different data sets,
    or vary the number of simulations, or make the same plot several times in similar
    situations, etc.). I can guarantee that most of the code you write will need to
    be run in many different situations. If, at every time you decide to make a change,
    you need to hunt down multiple places and make multiple changes, there is a nontrivial
    probability you will miss at least one. As a result, you will introduce a bug
    into your program, and waste (sometimes a lot of) time trying to find it.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*不要硬编码变量。*换句话说，不要编写针对脚本当前草稿特定细节的代码。编写即使程序被喂入不同的数据，或者需要计算其他与之密切相关的内容（例如，在不同的数据集上运行相同的计算，或者改变模拟的数量，或者在不同情况下多次制作相同的图形等）时仍然可以运行的代码。我可以保证你写的代码大多数情况下都需要在许多不同的环境中运行。如果你每次决定做出改变时都需要查找多个地方并做出多个更改，那么你至少会错过一个的概率是非平凡的。结果，你会在程序中引入一个错误，并浪费（有时是大量的）时间试图找到它。'
- en: Watch out for infinite `while` loops. Make sure that your stopping criterion
    is guaranteed to eventually become true.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意避免无限`while`循环。确保你的停止条件最终一定会变为真。
- en: Python also provides an alternative way to construct lists similar to the one
    we constructed in the above example. They are called [**list comprehensions**](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions).
    These are convenient because you can incorporate iteration and conditional logic
    in one line of code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Python还提供了一种类似于我们在上面例子中构造的列表的替代构建方式。它们被称为[**列表推导**](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)。这是因为你可以将迭代和条件逻辑合并到一行代码中。
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You might also have a look at [*generator expressions*](https://www.python.org/dev/peps/pep-0289/)
    and [*dictionary comprehensions*](https://www.python.org/dev/peps/pep-0274/).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以看看[*生成表达式*](https://www.python.org/dev/peps/pep-0289/)和[*字典推导式*](https://www.python.org/dev/peps/pep-0274/)。
- en: R can come close to replicating the above behavior with vectorization, but the
    conditional part is hard to achieve without subsetting.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: R可以通过向量化接近复制上述行为，但条件部分没有子集化很难实现。
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 11.3 Exercises
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 练习
- en: 11.3.1 R Questions
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 R问题
- en: 'Suppose you have a `vector` of `numeric` data: \(x_1, \ldots, x_n\). Write
    a function called `cappedMoveAve(dataVector)` that takes in a `vector` and returns
    a 3-period “capped” moving average. Make sure to use a `for` loop. The formula
    you should use is \[\begin{equation} y_t = \min\left(10, \frac{1}{3}\sum_{i=0}^2x_{t-i}
    \right). \end{equation}\] The function should return \(y_1, \ldots, y_n\) as a
    `vector`. Let \(y_1 = y_2 = 0\).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个`vector`类型的`numeric`数据：\(x_1, \ldots, x_n\). 编写一个名为`cappedMoveAve(dataVector)`的函数，该函数接收一个`vector`并返回一个3周期的“上限”移动平均。请确保使用`for`循环。你应该使用的公式是
    \[\begin{equation} y_t = \min\left(10, \frac{1}{3}\sum_{i=0}^2x_{t-i} \right).
    \end{equation}\] 函数应该返回`y_1, \ldots, y_n`作为一个`vector`。设\(y_1 = y_2 = 0\)。
- en: 'Say we have a target[^(20)](#fn20) distribution that we want to sample from:
    \[\begin{equation} p(x) = \begin{cases} \frac{x^2(1-x)}{\int_0^1 y^2(1-y) dy}
    & 0 < x < 1 \\ 0 & \text{otherwise} \end{cases}. \end{equation}\] The denominator,
    \(\int_0^1 y^2(1-y) dy\), is the target’s normalizing constant. You might know
    how to solve this integral (it’s equal to \(1/12\)), but let’s pretend for the
    sake of our example that it’s too difficult for us. We want to sample from \(p(x)\)
    while only being able to evaluate (not sample) from its unnormalized version \(f(x)
    := x^2(1-x)\). This is a situation that arises often–wanting to sample from some
    complicated distribution whose density you can only evaluate up to a constant
    of proportionality.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个目标[^(20)](#fn20)分布，我们想要从中采样：\[\begin{equation} p(x) = \begin{cases} \frac{x^2(1-x)}{\int_0^1
    y^2(1-y) dy} & 0 < x < 1 \\ 0 & \text{otherwise} \end{cases}. \end{equation}\]
    分母\(\int_0^1 y^2(1-y) dy\)是目标分布的归一化常数。你可能知道如何解这个积分（它等于\(1/12\)），但为了我们的例子，让我们假装它对我们来说太难了。我们想要从\(p(x)\)中采样，而只能评估（不能采样）其未归一化的版本\(f(x)
    := x^2(1-x)\)。这种情况经常出现——想要从一些复杂的分布中采样，而你只能评估其密度直到一个比例常数。
- en: 'Next, let’s choose a uniform distribution for our *proposal distribution*:
    \(q(x) = 1\) if \(0 < x < 1\). This means we will sample from this distribution,
    because it’s easier. We just need to “adjust” our samples somehow, because it’s
    not the same as our target.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为我们的**建议分布**选择一个均匀分布：\(q(x) = 1\)如果\(0 < x < 1\)。这意味着我们将从这个分布中采样，因为这更容易。我们只需要“调整”我们的样本，因为它与我们的目标不同。
- en: We can plot all three functions. The area under the \(p(x)\) and \(q(x)\) curves
    is \(1\), because they are true probability density functions. \(f(x)\), however,
    is not.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以绘制所有三个函数。\(p(x)\)和\(q(x)\)曲线下的面积是\(1\)，因为它们是真正的概率密度函数。然而，\(f(x)\)不是。
- en: '![Visualizing Our Three Functions](../Images/6b3064f3480a1014a66fde65807f27a6.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![可视化我们的三个函数](../Images/6b3064f3480a1014a66fde65807f27a6.png)'
- en: 'Figure 11.1: Visualizing Our Three Functions'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：可视化我们的三个函数
- en: Note that this algorithm allows for other proposal distributions. The only requirement
    of a proposal distribution is that its range of possible values must subsume the
    range of possible values of the target.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个算法允许使用其他建议分布。建议分布的唯一要求是其可能值的范围必须包含目标可能值的范围。
- en: Write a function called `arSamp(n)` that samples from \(p(x)\) using accept-reject
    sampling. It should take a single argument that is equal to the number of samples
    desired. Below is one step of the accept-reject algorithm. You will need to do
    many iterations of this. The number of iterations will be random, because some
    of these proposals will not be accepted.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`arSamp(n)`的函数，使用接受-拒绝采样从\(p(x)\)中采样。它应该接受一个参数，该参数等于所需样本的数量。以下是接受-拒绝算法的一步。你需要进行多次迭代，因为一些建议可能不会被接受。
- en: '**Algorithm 1**: Accept-Reject Sampling (One Step)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法1**：接受-拒绝采样（一步）'
- en: Find \(M\) such that \(M > \frac{f(x)}{q(x)}\) for all possible \(x\) (the smaller
    the better).
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到\(M\)，使得对于所有可能的\(x\)，\(M > \frac{f(x)}{q(x)}\)（越小越好）。
- en: Sample \(X\) from \(q(x)\).
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从\(q(x)\)中采样\(X\)。
- en: Sample \(Y \mid X\) from \(\text{Bernoulli}\left(\frac{f(X)}{q(X)M}\right)\).
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从\(\text{Bernoulli}\left(\frac{f(X)}{q(X)M}\right)\)中采样\(Y \mid X\)。
- en: If \(Y = 1\), then return \(X\).
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果\(Y = 1\)，则返回\(X\)。
- en: Otherwise, return nothing.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，返回空值。
- en: 'Write a function called `multiplyTwoMats(A,B)` that performs matrix multiplication.
    It should take two `matrix` arguments: `A` and `B`. Then it should return the
    matrix product `AB`. Use two nested `for` loops to write this function. Make sure
    to test this function against the usual tool you use to multiply matrices together:
    `%*%`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为 `multiplyTwoMats(A,B)` 的函数，该函数执行矩阵乘法。它应该接受两个 `matrix` 参数：`A` 和 `B`。然后它应该返回矩阵乘积
    `AB`。使用两个嵌套的 `for` 循环来编写此函数。确保使用你通常用来乘矩阵的常用工具：`%*%` 进行测试。
- en: Suppose you are trying to predict a value of \(Y\) given some information about
    a corresponding independent variable \(x\). Suppose further that you have a historical
    data set of observations \((x_1, y_1), \ldots, (x_n,y_n)\). One approach for coming
    up with predictions is to use **Nadaraya–Watson Kernel Regression** (Nadaraya
    [1964](#ref-Nadaraya)) (Watson [1964](#ref-Watson)). The prediction this approach
    provides is simply a weighted average of all of the historically-observed data
    points \(y_1, \ldots, y_n\). The weight for a given \(y_i\) will be larger if
    \(x_i\) is “close” to the value \(x\) that you are obtaining predictions for.
    On the other hand, if \(x_j\) is far away from \(x\), then the weight for \(y_j\)
    will be relatively small, and so this data point won’t influence the prediction
    much.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在尝试根据关于相应自变量 \(x\) 的信息预测 \(Y\) 的值。进一步假设你有一个历史观测数据集 \((x_1, y_1), \ldots,
    (x_n,y_n)\)。提出预测的一种方法是使用 **Nadaraya–Watson 核回归** (Nadaraya [1964](#ref-Nadaraya))
    (Watson [1964](#ref-Watson))。这种方法提供的预测只是一个历史观测数据点 \(y_1, \ldots, y_n\) 的加权平均值。如果
    \(x_i\) 与你正在获取预测值的 \(x\) 值“接近”，则给定 \(y_i\) 的权重会更大。另一方面，如果 \(x_j\) 与 \(x\) 相距较远，则
    \(y_j\) 的权重相对较小，因此这个数据点不会对预测产生很大影响。
- en: Write a function called `kernReg(xPred,xData,yData,kernFunc)` that computes
    the Nadaraya–Watson estimate of the prediction of \(Y\) given \(X=x\). Do not
    use a `for` loop in your function definition. The formula is \[\begin{equation}
    \sum_{i=1}^n \frac{K(x-x_i)}{\sum_{j=1}^n K(x-x_j) } y_i, \end{equation}\] where
    \(x\) is the point you’re trying to get a prediction for.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为 `kernReg(xPred,xData,yData,kernFunc)` 的函数，该函数计算给定 \(X=x\) 时 \(Y\) 的 Nadaraya–Watson
    估计值。在函数定义中不要使用 `for` 循环。公式为 \[\begin{equation} \sum_{i=1}^n \frac{K(x-x_i)}{\sum_{j=1}^n
    K(x-x_j) } y_i, \end{equation}\] 其中 \(x\) 是你试图获取预测值的点。
- en: Your function should return one floating point number.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的函数应该返回一个浮点数。
- en: The input `xPred` will be a floating point number.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入 `xPred` 将是一个浮点数。
- en: The input `xData` is a one-dimensional `vector` of numerical data of independent
    variables.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入 `xData` 是一个包含自变量数值数据的单维 `vector`。
- en: The input `yData` is a one-dimensional `vector` of numerical data of dependent
    variables.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入 `yData` 是一个包含依赖变量数值数据的单维 `vector`。
- en: '`kernFunc` is a function that accepts a `numeric` `vector` and returns a floating
    point. It’s vectorized.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kernFunc` 是一个接受 `numeric` `vector` 并返回浮点数的函数。它是向量化的。'
- en: Below is some code that will help you test your predictions. The kernel function,
    `gaussKernel()`, implements the Gaussian kernel function \(K(z) = \exp[-z^2/2]/\sqrt{2\pi}\).
    Notice the creation of `preds` was commented out. Use a `for` loop to generate
    predictions for all elements of `xTest` and store them in the vector `preds`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些可以帮助你测试预测的代码。核函数 `gaussKernel()` 实现高斯核函数 \(K(z) = \exp[-z^2/2]/\sqrt{2\pi}\)。注意
    `preds` 的创建已被注释掉。使用 `for` 循环为 `xTest` 的所有元素生成预测，并将它们存储在向量 `preds` 中。
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 11.3.2 Python Questions
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2 Python 问题
- en: Suppose you go to the casino with \(10\) dollars. You decide that your policy
    is to play until you go broke, or until you triple your money. The only game you
    play costs \(\$1\) to play. If you lose, you lose that dollar. If you win, you
    get another \(\$1\) in addition to getting your money back.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你带着 \(10\) 美元去赌场。你决定你的策略是玩到破产，或者直到你的钱翻三倍。你唯一玩的游戏每次需要支付 \( \$1 \)。如果你输了，你会失去那美元。如果你赢了，你将得到另外
    \( \$1 \)，并且会收回你的钱。
- en: Write a function called `sim_night(p)` that simulates your night of gambling.
    Have it return a Pandas `Series` with the running balance of money you have over
    the course of a night. For example, if you lose \(10\) games in a row, and go
    home early, the returned `Series` contains \(9, \ldots, 1,0\). This function will
    only take one input, `p`, which is the probability of winning any/every game you
    play.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为 `sim_night(p)` 的函数，该函数模拟你的夜晚赌博。让它返回一个 Pandas `Series`，表示你在一夜之间拥有的运行余额。例如，如果你连续输了
    \(10\) 场游戏，并且提前回家，返回的 `Series` 包含 \(9, \ldots, 1,0\)。此函数只接受一个输入 `p`，它是你赢得任何/每场比赛的概率。
- en: Use a `for` loop to call your function \(5000\) times with probability `p=.5`.
    Each time, store the number of games played. Store them all in a Numpy `array`
    or Pandas `Series` called `simulated_durations`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个`for`循环以概率`p=.5`调用你的函数\(5000\)次。每次调用，存储游戏的数量。将它们全部存储在一个名为`simulated_durations`的Numpy
    `array`或Pandas `Series`中。
- en: Take the average of `simulated_durations`. This is your Monte Carlo estimate
    of the expected duration. How does it compare with what you think it should be
    theoretically?
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算`simulated_durations`的平均值。这是你蒙特卡洛估计的预期持续时间。它与你的理论预期相比如何？
- en: Perform the same analysis to estimate the expected duration when \(p=.7\). Store
    your answer as a `float` called `expec_duration`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当\(p=.7\)时，执行相同的分析以估计预期的持续时间。将你的答案存储为名为`expec_duration`的`float`。
- en: Suppose you have the following data set. Please include the following snippet
    in your submission.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个以下数据集。请在你的提交中包含以下片段。
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This question will demonstrate how to implement **The Bootstrap** (Efron [1979](#ref-bootstrap)),
    which is a popular nonparametric approach to understand the distribution of a
    statistic of interest. The main idea is to calculate your statistic over and over
    again on *bootstrapped* data sets, which are data sets randomly chosen, with replacement,
    from your original data set `my_data`. Each bootstrapped data set is of the same
    size as the original data set, and each bootstrapped data set will yield one statistic.
    Collect all of these random statistics, and it is a good approximation to the
    statistic’s theoretical distribution.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此问题将演示如何实现**自举法**（Efron [1979](#ref-bootstrap)），这是一种流行的非参数方法，用于理解感兴趣统计量的分布。主要思想是在从原始数据集`my_data`随机选择、有放回地选择的数据集上反复计算你的统计量，这些数据集与原始数据集大小相同，每个自举数据集将产生一个统计量。收集所有这些随机统计量，这将是统计量理论分布的良好近似。
- en: Calculate the mean of this data set and store it as a floating point number
    called `sample_mean`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算此数据集的均值并将其存储为名为`sample_mean`的浮点数。
- en: Calculate \(5,000\) bootstrap sample means. Store them in a Numpy `array` called
    `bootstrapped_means`. Use a `for` loop, and inside the loop, sample with replacement
    \(1000\) times from the length \(1000\) data set. You can use the function `np.random.choice()`
    to accomplish this.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算样本均值\(5,000\)个自举样本。将它们存储在一个名为`bootstrapped_means`的Numpy `array`中。使用一个`for`循环，并在循环内部，从长度为\(1000\)的数据集中有放回地采样\(1000\)次。你可以使用`np.random.choice()`函数来完成此操作。
- en: Calculate the sample mean of these bootstrapped means. This is a good estimate
    of the *theoretical* mean/expectation of the sample mean. Call it `mean_of_means`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算这些自举均值的样本均值。这是样本均值理论均值/期望的良好估计。将其称为`mean_of_means`。
- en: Calculate the sample variance of these bootstrapped means. This is a good estimate
    of the *theoretical* variance of the sample mean. Call it `var_of_means`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算这些自举均值的样本方差。这是样本均值理论方差的良好估计。将其称为`var_of_means`。
- en: 'Write a function called `ar_samp(n)` that samples from \(p(x)\) using accept-reject
    sampling. Use any proposal distribution that you’d like. It should take a single
    argument that is equal to the number of samples desired. Sample from the following
    target: \[\begin{equation} p(x) \propto f(x) := \exp[\cos(2\pi x)] x^2(1-x), \hspace{5mm}
    0 < x < 1. \end{equation}\]'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`ar_samp(n)`的函数，使用接受-拒绝采样从\(p(x)\)中采样。可以使用你喜欢的任何提议分布。它应该接受一个参数，该参数等于所需的样本数量。从以下目标分布中采样：\[\begin{equation}
    p(x) \propto f(x) := \exp[\cos(2\pi x)] x^2(1-x), \hspace{5mm} 0 < x < 1. \end{equation}\]
- en: References
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Efron, B. 1979\. “Bootstrap Methods: Another Look at the Jackknife.” *The Annals
    of Statistics* 7 (1): 1–26\. [https://doi.org/10.1214/aos/1176344552](https://doi.org/10.1214/aos/1176344552).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 'Efron, B. 1979\. “Bootstrap方法：对Jackknife的另一种看法。” *《统计年鉴》* 7 (1): 1–26\. [https://doi.org/10.1214/aos/1176344552](https://doi.org/10.1214/aos/1176344552).'
- en: 'Lutz, Mark. 2013\. *Learning Python*. 5th ed. Beijing: O’Reilly. [https://www.safaribooksonline.com/library/view/learning-python-5th/9781449355722/](https://www.safaribooksonline.com/library/view/learning-python-5th/9781449355722/).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lutz, Mark. 2013\. *《Python学习》*. 第5版. 北京: O’Reilly. [https://www.safaribooksonline.com/library/view/learning-python-5th/9781449355722/](https://www.safaribooksonline.com/library/view/learning-python-5th/9781449355722/).'
- en: 'Nadaraya, E. A. 1964\. “On Estimating Regression.” *Theory of Probability &
    Its Applications* 9 (1): 141–42\. [https://doi.org/10.1137/1109020](https://doi.org/10.1137/1109020).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 'Nadaraya, E. A. 1964\. “关于回归估计。” *《概率论及其应用理论》* 9 (1): 141–42\. [https://doi.org/10.1137/1109020](https://doi.org/10.1137/1109020).'
- en: 'Watson, Geoffrey S. 1964\. “Smooth Regression Analysis.” *Sankhyā: The Indian
    Journal of Statistics, Series A (1961-2002)* 26 (4): 359–72\. [http://www.jstor.org/stable/25049340](http://www.jstor.org/stable/25049340).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 'Watson, Geoffrey S. 1964\. “Smooth Regression Analysis.” *Sankhyā: The Indian
    Journal of Statistics, Series A (1961-2002)* 26 (4): 359–72\. [http://www.jstor.org/stable/25049340](http://www.jstor.org/stable/25049340).'
- en: '* * *'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: This is the density of a \(\text{Beta}(3,2)\) random variable, if you’re curious.[↩](/control-flow#fnref20)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是 \(\text{Beta}(3,2)\) 随机变量的密度，如果你对此感兴趣。[↩](/control-flow#fnref20)
