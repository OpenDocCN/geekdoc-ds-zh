- en: 16.2Â The Size of a DAGğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.2 DAG çš„å¤§å°ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/size-of-dag.html](https://dcic-world.org/2025-08-27/size-of-dag.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/size-of-dag.html](https://dcic-world.org/2025-08-27/size-of-dag.html)
- en: '| Â Â Â Â [16.2.1Â Stage 1](#%28part._.Stage_1%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [16.2.1 é˜¶æ®µ 1](#%28part._.Stage_1%29) |'
- en: '| Â Â Â Â [16.2.2Â Stage 2](#%28part._.Stage_2%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [16.2.2 é˜¶æ®µ 2](#%28part._.Stage_2%29) |'
- en: '| Â Â Â Â [16.2.3Â Stage 3](#%28part._.Stage_3%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [16.2.3 é˜¶æ®µ 3](#%28part._.Stage_3%29) |'
- en: '| Â Â Â Â [16.2.4Â Stage 4](#%28part._.Stage_4%29) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [16.2.4 é˜¶æ®µ 4](#%28part._.Stage_4%29) |'
- en: '| Â Â Â Â [16.2.5Â Stage 5](#%28part._.Stage_5%29) |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [16.2.5 é˜¶æ®µ 5](#%28part._.Stage_5%29) |'
- en: '| Â Â Â Â [16.2.6Â What Weâ€™ve Learned](#%28part._.What_.We~e2~80~99ve_.Learned%29)
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [16.2.6 æˆ‘ä»¬å­¦åˆ°äº†ä»€ä¹ˆ](#%28part._.What_.We~e2~80~99ve_.Learned%29) |'
- en: '| Â Â Â Â [16.2.7Â More on Value Printing: An Aside from Racket](#%28part._.More_on_.Value_.Printing__.An_.Aside_from_.Racket%29)
    |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [16.2.7 æ›´å¤šå…³äºå€¼æ‰“å°ï¼šæ¥è‡ª Racket çš„æ—ç™½](#%28part._.More_on_.Value_.Printing__.An_.Aside_from_.Racket%29)
    |'
- en: 'Letâ€™s start by defining a function to compute the size of a tree:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä»å®šä¹‰ä¸€ä¸ªè®¡ç®—æ ‘å¤§å°çš„å‡½æ•°å¼€å§‹ï¼š
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is straightforward enough.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¾ˆç®€å•ã€‚
- en: 'But letâ€™s say that our input isnâ€™t actually a tree, but rather a DAG. For instance:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†å‡è®¾æˆ‘ä»¬çš„è¾“å…¥å®é™…ä¸Šä¸æ˜¯ä¸€ä¸ªæ ‘ï¼Œè€Œæ˜¯ä¸€ä¸ª DAGã€‚ä¾‹å¦‚ï¼š
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'where `n4` is the DAG. There are two notions of size here. One is like a â€œprint
    sizeâ€: how much space will it occupy when printed. The current size function computes
    that well. But another is the â€œallocationâ€ size: how many nodes did we allocate.
    How do we fare?'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­ `n4` æ˜¯ DAGã€‚è¿™é‡Œæœ‰ä¸¤ç§å¤§å°æ¦‚å¿µã€‚ä¸€ç§ç±»ä¼¼äºâ€œæ‰“å°å¤§å°â€ï¼šæ‰“å°æ—¶å°†å ç”¨å¤šå°‘ç©ºé—´ã€‚å½“å‰çš„å¤§å°å‡½æ•°å¾ˆå¥½åœ°è®¡ç®—äº†è¿™ä¸€ç‚¹ã€‚ä½†å¦ä¸€ç§æ˜¯â€œåˆ†é…â€å¤§å°ï¼šæˆ‘ä»¬åˆ†é…äº†å¤šå°‘ä¸ªèŠ‚ç‚¹ã€‚æˆ‘ä»¬çš„è¡¨ç°å¦‚ä½•ï¼Ÿ
- en: 16.2.1Â Stage 1[ğŸ”—](#(part._.Stage_1) "Link to here")
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.1 é˜¶æ®µ 1[ğŸ”—](#(part._.Stage_1) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Clearly the answer should be `4`: we can just read off how many `nd` calls
    there are. And clearly the function is wrong.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: æ˜¾ç„¶ï¼Œç­”æ¡ˆåº”è¯¥æ˜¯ `4`ï¼šæˆ‘ä»¬åªéœ€è¯»å–æœ‰å¤šå°‘ `nd` è°ƒç”¨å³å¯ã€‚æ˜¾ç„¶ï¼Œå‡½æ•°æ˜¯é”™è¯¯çš„ã€‚
- en: 'The problem, of course, is that a DAG involves repeating nodes, and we arenâ€™t
    doing anything to track the repetition. So we need a stronger contract: weâ€™ll
    split the problem into two parts, a standard interface function that takes just
    the DAG and returns a number, and a richer helper function, which also takes a
    memory of the nodes already seen.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œé—®é¢˜æ˜¯ DAG æ¶‰åŠé‡å¤çš„èŠ‚ç‚¹ï¼Œè€Œæˆ‘ä»¬å¹¶æ²¡æœ‰åšä»»ä½•è·Ÿè¸ªé‡å¤çš„äº‹æƒ…ã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ›´å¼ºçš„å¥‘çº¦ï¼šæˆ‘ä»¬å°†é—®é¢˜åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œä¸€ä¸ªæ ‡å‡†æ¥å£å‡½æ•°ï¼Œå®ƒåªæ¥å—
    DAG å¹¶è¿”å›ä¸€ä¸ªæ•°å­—ï¼Œä»¥åŠä¸€ä¸ªæ›´ä¸°å¯Œçš„è¾…åŠ©å‡½æ•°ï¼Œå®ƒè¿˜æ¥å—å·²çœ‹åˆ°çš„èŠ‚ç‚¹çš„è®°å¿†ã€‚
- en: 16.2.2Â Stage 2[ğŸ”—](#(part._.Stage_2) "Link to here")
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.2 é˜¶æ®µ 2[ğŸ”—](#(part._.Stage_2) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Exercise
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does this code use `member-identical` rather than `member`?
  id: totrans-23
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆè¿™æ®µä»£ç ä½¿ç”¨ `member-identical` è€Œä¸æ˜¯ `member`ï¼Ÿ
- en: ''
  id: totrans-24
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe that if we replace every `member-identical` with `member` in this chapter,
    the code still behaves the same. Why?
  id: totrans-25
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå¦‚æœæˆ‘ä»¬åœ¨è¿™ä¸ªç« èŠ‚ä¸­å°†æ¯ä¸ª `member-identical` æ›¿æ¢ä¸º `member`ï¼Œä»£ç ä»ç„¶è¡¨ç°ç›¸åŒã€‚ä¸ºä»€ä¹ˆï¼Ÿ
- en: ''
  id: totrans-26
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make changes to demonstrate the need for `member-identical`.
  id: totrans-27
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿›è¡Œæ›´æ”¹ä»¥å±•ç¤ºå¯¹ `member-identical` çš„éœ€æ±‚ã€‚
- en: 'Is it odd that we return `0`? Not if we reinterpret what the function does:
    it doesnâ€™t count the size, it counts the additional contribution to the size (relative
    to what has already been seen) of the `BT` it is given. A node already in `seen`
    makes no marginal contribution; it was already counted earlier.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: è¿”å› `0` æ˜¯å¦å¥‡æ€ªï¼Ÿå¦‚æœæˆ‘ä»¬é‡æ–°è§£é‡Šå‡½æ•°çš„ä½œç”¨ï¼Œå°±ä¸ä¼šå¥‡æ€ªäº†ï¼šå®ƒä¸æ˜¯è®¡ç®—å¤§å°ï¼Œè€Œæ˜¯è®¡ç®—å®ƒæ‰€ç»™çš„ `BT` ç›¸å¯¹äºå·²ç»çœ‹åˆ°çš„é¢å¤–è´¡çŒ®çš„å¤§å°ï¼ˆç›¸å¯¹äºå·²ç»çœ‹åˆ°çš„ï¼‰ã€‚å·²ç»åœ¨
    `seen` ä¸­çš„èŠ‚ç‚¹ä¸ä¼šäº§ç”Ÿè¾¹é™…è´¡çŒ®ï¼›å®ƒä¹‹å‰å·²ç»è¢«è®¡ç®—è¿‡äº†ã€‚
- en: 'Finally, we should not export such a function to the user, who has to deal
    with an unwieldy extra parameter and may send something poorly-formed, thereby
    causing our function to break. Instead, we should write a wrapper for it:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæˆ‘ä»¬ä¸åº”è¯¥å°†æ­¤ç±»å‡½æ•°å¯¼å‡ºç»™ç”¨æˆ·ï¼Œç”¨æˆ·å¿…é¡»å¤„ç†ä¸€ä¸ªéš¾ä»¥é©¾é©­çš„é¢å¤–å‚æ•°ï¼Œå¹¶ä¸”å¯èƒ½ä¼šå‘é€ä¸€äº›æ ¼å¼ä¸ä½³çš„å†…å®¹ï¼Œä»è€Œå¯¼è‡´æˆ‘ä»¬çš„å‡½æ•°å´©æºƒã€‚ç›¸åï¼Œæˆ‘ä»¬åº”è¯¥ä¸ºå…¶ç¼–å†™ä¸€ä¸ªåŒ…è£…å™¨ï¼š
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This also enables us to use our old tests (renamed):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¹Ÿä½¿æˆ‘ä»¬èƒ½å¤Ÿä½¿ç”¨æˆ‘ä»¬çš„æ—§æµ‹è¯•ï¼ˆå·²é‡å‘½åï¼‰ï¼š
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Unfortunately, this still doesnâ€™t work!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼Œè¿™ä»ç„¶ä¸èµ·ä½œç”¨ï¼
- en: Do Now!
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨åšä»€ä¹ˆï¼Ÿ
- en: ''
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use Pyretâ€™s `spy` construct in `size-2-h` to figure out why.
  id: totrans-36
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨ `size-2-h` ä¸­ä½¿ç”¨ Pyret çš„ `spy` æ„é€ æ¥æ‰¾å‡ºåŸå› ã€‚
- en: 16.2.3Â Stage 3[ğŸ”—](#(part._.Stage_3) "Link to here")
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.3 é˜¶æ®µ 3[ğŸ”—](#(part._.Stage_3) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Did you remember to use `spy`? Otherwise you may very well miss the problem!
    Be sure to use `spy` (feel free to elide the first few tests for now) to get a
    feel for the issue.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ è®°å¾—ä½¿ç”¨ `spy` å—ï¼Ÿå¦åˆ™ä½ å¯èƒ½ä¼šå®Œå…¨é”™è¿‡é—®é¢˜ï¼ç¡®ä¿ä½¿ç”¨ `spy`ï¼ˆç°åœ¨å¯ä»¥è‡ªç”±çœç•¥å‰å‡ ä¸ªæµ‹è¯•ï¼‰æ¥äº†è§£é—®é¢˜ã€‚
- en: As you may have noted, the problem is that we want `seen` to be all the nodes
    ever seen. However, every time we return from one sub-computation, we also lose
    track of whatever was seen during its work. Instead, we have to also return everything
    that was seen, so as to properly preserve the idea that weâ€™re computing the marginal
    contribution of each node.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚ä½ å¯èƒ½å·²ç»æ³¨æ„åˆ°çš„ï¼Œé—®é¢˜æ˜¯æˆ‘ä»¬å¸Œæœ›â€œå·²è§â€åŒ…å«æ‰€æœ‰æ›¾ç»è§è¿‡çš„èŠ‚ç‚¹ã€‚ç„¶è€Œï¼Œæ¯æ¬¡æˆ‘ä»¬ä»å­è®¡ç®—è¿”å›æ—¶ï¼Œæˆ‘ä»¬ä¹Ÿä¼šå¤±å»å¯¹å…¶å·¥ä½œæœŸé—´æ‰€çœ‹åˆ°çš„ä»»ä½•å†…å®¹çš„è·Ÿè¸ªã€‚ç›¸åï¼Œæˆ‘ä»¬å¿…é¡»è¿”å›æ‰€çœ‹åˆ°çš„ä¸€åˆ‡ï¼Œä»¥ä¾¿æ­£ç¡®åœ°ä¿ç•™æˆ‘ä»¬æ­£åœ¨è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„è¾¹é™…è´¡çŒ®çš„æƒ³æ³•ã€‚
- en: 'We can do this with the following data structure:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ•°æ®ç»“æ„æ¥å®Œæˆè¿™é¡¹å·¥ä½œï¼š
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'which is returned by the helper function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ç”±è¾…åŠ©å‡½æ•°è¿”å›çš„ï¼š
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note, crucially, how the `seen` argument for the right branch is `rl.sn`: i.e.,
    everything that was already seen in the left branch. This is the crucial step
    that avoids the bug.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå…³é”®çš„æ˜¯ï¼Œå³ä¾§åˆ†æ”¯çš„â€œseenâ€å‚æ•°æ˜¯â€œrl.snâ€ï¼šå³å·¦ä¾§åˆ†æ”¯ä¸­å·²ç»çœ‹åˆ°çš„å…¨éƒ¨å†…å®¹ã€‚è¿™æ˜¯é¿å…é”™è¯¯çš„å…³é”®æ­¥éª¤ã€‚
- en: 'Because of this richer return type, we have to extract the actual answer for
    the purpose of testing:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºè¿™ç§æ›´ä¸°å¯Œçš„è¿”å›ç±»å‹ï¼Œæˆ‘ä»¬å¿…é¡»æå–å®é™…ç­”æ¡ˆä»¥è¿›è¡Œæµ‹è¯•ï¼š
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Exercise
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Must `seen` be a list? What else can it be?
  id: totrans-49
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: â€œå·²è§â€å¿…é¡»æ˜¯åˆ—è¡¨å—ï¼Ÿå®ƒè¿˜å¯ä»¥æ˜¯ä»€ä¹ˆï¼Ÿ
- en: 16.2.4Â Stage 4[ğŸ”—](#(part._.Stage_4) "Link to here")
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.4 ç¬¬4é˜¶æ®µ[ğŸ”—](#(part._.Stage_4) "é“¾æ¥è‡³æ­¤")
- en: 'Observe that the `Ret` data structure is only of local interest. Itâ€™s purely
    internal to the `size-3-h` function; even `size-3` ignores one half, and it will
    never be seen by the rest of the program. That is a good use of tuples, as we
    have seen before: [Using Tuples](queues-from-lists.html#%28part._qfl-tuples%29)!'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„åˆ°â€œRetâ€æ•°æ®ç»“æ„åªå…·æœ‰å±€éƒ¨å…´è¶£ã€‚å®ƒçº¯ç²¹æ˜¯â€œsize-3-hâ€å‡½æ•°å†…éƒ¨çš„ï¼›å³ä½¿æ˜¯â€œsize-3â€ä¹Ÿå¿½ç•¥äº†å…¶ä¸­ä¸€åŠï¼Œå®ƒå°†æ°¸è¿œä¸ä¼šè¢«ç¨‹åºçš„å…¶ä»–éƒ¨åˆ†çœ‹åˆ°ã€‚è¿™å°±æ˜¯æˆ‘ä»¬ä¹‹å‰çœ‹åˆ°çš„å¥½ç”¨å…ƒç»„çš„æ–¹å¼ï¼š[ä½¿ç”¨å…ƒç»„](queues-from-lists.html#%28part._qfl-tuples%29)ï¼
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The notation `{0; seen}` makes an actual tuple; `{Number; List<BT>}` declares
    the contract of a tuple. Also, `.{0}` extracts the `0`th element (the leftmost
    one) of a tuple.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¦å· `{0; seen}` å®é™…ä¸Šåˆ›å»ºäº†ä¸€ä¸ªå…ƒç»„ï¼›`{Number; List<BT>}` å£°æ˜äº†å…ƒç»„çš„å¥‘çº¦ã€‚æ­¤å¤–ï¼Œ`.{0}` æå–å…ƒç»„çš„ç¬¬0ä¸ªå…ƒç´ ï¼ˆæœ€å·¦è¾¹çš„å…ƒç´ ï¼‰ã€‚
- en: 16.2.5Â Stage 5[ğŸ”—](#(part._.Stage_5) "Link to here")
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.5 ç¬¬5é˜¶æ®µ[ğŸ”—](#(part._.Stage_5) "é“¾æ¥è‡³æ­¤")
- en: Notice that we have the two instances of the code `{0; seen}`. Do they have
    to be that? What if we were to return `{0; empty}` instead in both places? Does
    anything break?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬æœ‰ä»£ç çš„ä¸¤ä¸ªå®ä¾‹ `{0; seen}`ã€‚å®ƒä»¬å¿…é¡»æ˜¯è¿™æ ·å—ï¼Ÿå¦‚æœæˆ‘ä»¬åœ¨è¿™ä¸¤ä¸ªåœ°æ–¹éƒ½è¿”å› `{0; empty}` ä¼šæ€æ ·ï¼Ÿä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
- en: We might expect it to break in the case where `member-identical` returns `true`,
    but perhaps not in the `mt` case.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯èƒ½é¢„è®¡å®ƒä¼šåœ¨â€œmember-identicalâ€è¿”å›â€œtrueâ€çš„æƒ…å†µä¸‹å´©æºƒï¼Œä½†åœ¨â€œmtâ€æƒ…å†µä¸‹å¯èƒ½ä¸ä¼šã€‚
- en: Do Now!
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make each of these changes. Does the outcome match your expectations?
  id: totrans-59
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿›è¡Œè¿™äº›æ›´æ”¹ã€‚ç»“æœæ˜¯å¦ç¬¦åˆä½ çš„é¢„æœŸï¼Ÿ
- en: Curiously, no! Making the change in the `mt` case has an effect but making it
    in the `member-identical` case doesnâ€™t! This almost seems counter-intuitive. How
    can we diagnose this?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: å¥‡æ€ªçš„æ˜¯ï¼Œä¸æ˜¯ï¼åœ¨â€œmtâ€æƒ…å†µä¸‹è¿›è¡Œæ›´æ”¹ä¼šäº§ç”Ÿå½±å“ï¼Œä½†åœ¨â€œmember-identicalâ€æƒ…å†µä¸‹è¿›è¡Œæ›´æ”¹åˆ™æ²¡æœ‰ï¼è¿™å‡ ä¹ä¼¼ä¹ä¸ç›´è§‰ç›¸åã€‚æˆ‘ä»¬å¦‚ä½•è¯Šæ–­è¿™ä¸ªé—®é¢˜ï¼Ÿ
- en: Do Now!
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use `spy` to determine what is going on!
  id: totrans-63
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ `spy` æ¥ç¡®å®šå‘ç”Ÿäº†ä»€ä¹ˆï¼
- en: Okay, so it seems like returning `empty` when we revisit a node doesnâ€™t seem
    to do any harm. Does that mean itâ€™s okay to make that change?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½å§ï¼Œæ‰€ä»¥å½“æˆ‘ä»¬é‡æ–°è®¿é—®ä¸€ä¸ªèŠ‚ç‚¹æ—¶è¿”å›â€œç©ºâ€ä¼¼ä¹å¹¶æ²¡æœ‰é€ æˆä»»ä½•ä¼¤å®³ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥åšå‡ºè¿™æ ·çš„æ”¹å˜å—ï¼Ÿ
- en: 'Observe that nothing has actually depended on that seen-list being `empty`.
    Thatâ€™s why it appears to not matter. How can we make it matter? By making it â€œhurtâ€
    the computation by visiting a previously seen, but now forgotten, node yet again.
    So we need to visit a node at least three times: the first time to remember it;
    the second time to forget it; and a third time to incorrectly visit it again.
    Hereâ€™s a DAG that will do that:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„åˆ°å®é™…ä¸Šå¹¶æ²¡æœ‰ä»€ä¹ˆä¾èµ–äºé‚£ä¸ªâ€œå·²è§åˆ—è¡¨â€ä¸ºâ€œç©ºâ€ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆå®ƒçœ‹èµ·æ¥å¹¶ä¸é‡è¦ã€‚æˆ‘ä»¬å¦‚ä½•è®©å®ƒå˜å¾—é‡è¦ï¼Ÿé€šè¿‡è®©å®ƒâ€œä¼¤å®³â€è®¡ç®—ï¼Œå†æ¬¡è®¿é—®ä¸€ä¸ªä¹‹å‰è§è¿‡ä½†ç°åœ¨å·²è¢«é—å¿˜çš„èŠ‚ç‚¹ã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦è‡³å°‘è®¿é—®ä¸€ä¸ªèŠ‚ç‚¹ä¸‰æ¬¡ï¼šç¬¬ä¸€æ¬¡æ˜¯ä¸ºäº†è®°ä½å®ƒï¼›ç¬¬äºŒæ¬¡æ˜¯ä¸ºäº†å¿˜è®°å®ƒï¼›ç¬¬ä¸‰æ¬¡æ˜¯ä¸ºäº†é”™è¯¯åœ°å†æ¬¡è®¿é—®å®ƒã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªèƒ½å¤Ÿåšåˆ°è¿™ä¸€ç‚¹çš„æœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰ï¼š
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Sure enough, if either tuple now returns `empty`, this test fails. Otherwise
    it succeeds.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ç¡®å®å¦‚æ­¤ï¼Œå¦‚æœä»»ä¸€å…ƒç»„ç°åœ¨è¿”å›â€œç©ºâ€ï¼Œåˆ™æ­¤æµ‹è¯•å¤±è´¥ã€‚å¦åˆ™ï¼Œå®ƒå°†æˆåŠŸã€‚
- en: 16.2.6Â What Weâ€™ve Learned[ğŸ”—](#(part._.What_.We~e2~80~99ve_.Learned) "Link to
    here")
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.6 æˆ‘ä»¬å­¦åˆ°äº†ä»€ä¹ˆ[ğŸ”—](#(part._.What_.We~e2~80~99ve_.Learned) "é“¾æ¥è‡³æ­¤")
- en: 'We have learned three important principles here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨è¿™é‡Œå­¦åˆ°äº†ä¸‰ä¸ªé‡è¦çš„åŸåˆ™ï¼š
- en: A pattern for dealing with programs that need â€œmemoryâ€. This is called threading
    (not in the sense of â€œmulti-threadingâ€, which is a kind of parallel computation,
    but rather the pattern of how the seen list gets passed through the program).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¤„ç†éœ€è¦â€œå†…å­˜â€çš„ç¨‹åºçš„æ¨¡å¼ã€‚è¿™è¢«ç§°ä¸ºçº¿ç¨‹ï¼ˆä¸æ˜¯â€œå¤šçº¿ç¨‹â€çš„æ„æ€ï¼Œå¤šçº¿ç¨‹æ˜¯ä¸€ç§å¹¶è¡Œè®¡ç®—ï¼Œè€Œæ˜¯æŒ‡çœ‹åˆ°çš„åˆ—è¡¨å¦‚ä½•é€šè¿‡ç¨‹åºä¼ é€’çš„æ¨¡å¼ï¼‰ã€‚
- en: 'A good example of the use of tuples: local, where the documentation benefit
    of datatypes isnâ€™t necessary (and the extra datatype probably just clutters up
    the program), as opposed to distant, where it is. In general, itâ€™s always okay
    to make a new datatype; itâ€™s only sometimes okay to use tuples in their place.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å…ƒç»„ä½¿ç”¨çš„ä¸€ä¸ªå¥½ä¾‹å­ï¼šåœ¨æœ¬åœ°ï¼Œæ•°æ®ç±»å‹çš„æ–‡æ¡£ä¼˜åŠ¿ä¸æ˜¯å¿…è¦çš„ï¼ˆè€Œä¸”é¢å¤–çš„æ•°æ®ç±»å‹å¯èƒ½åªæ˜¯ä½¿ç¨‹åºå˜å¾—æ‚ä¹±ï¼‰ï¼Œä¸è¿œç¨‹ç›¸å¯¹ï¼Œåœ¨è¿œç¨‹æƒ…å†µä¸‹ï¼Œè¿™æ˜¯å¿…è¦çš„ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œæ€»æ˜¯å¯ä»¥åˆ›å»ºä¸€ä¸ªæ–°çš„æ•°æ®ç±»å‹ï¼›åªæœ‰åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæ‰å¯ä»¥ä½¿ç”¨å…ƒç»„æ¥ä»£æ›¿ã€‚
- en: An important software-engineering principle, called mutation testing. This is
    an odd name because it would seem to be the name of a technique to test programs.
    Actually, itâ€™s a technique to test test suites. You have a tested program; you
    then â€œmutateâ€ some part of your program that you feel must change the output,
    and see whether any tests break. If no tests break, then either youâ€™ve misunderstood
    your program or, more likely, your test suite is not good enough. Improve your
    test suite to catch the error in your program, or convince yourself the change
    didnâ€™t matter.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªé‡è¦çš„è½¯ä»¶å·¥ç¨‹åŸåˆ™ï¼Œç§°ä¸ºå˜å¼‚æµ‹è¯•ã€‚è¿™ä¸ªåå­—å¬èµ·æ¥åƒæ˜¯æµ‹è¯•ç¨‹åºçš„æŠ€æœ¯ï¼Œå®é™…ä¸Šï¼Œå®ƒæ˜¯ä¸€ç§æµ‹è¯•æµ‹è¯•å¥—ä»¶çš„æŠ€æœ¯ã€‚ä½ æœ‰ä¸€ä¸ªç»è¿‡æµ‹è¯•çš„ç¨‹åºï¼›ç„¶åâ€œå˜å¼‚â€ä½ ç¨‹åºä¸­ä½ è®¤ä¸ºå¿…é¡»æ”¹å˜è¾“å‡ºçš„éƒ¨åˆ†ï¼Œå¹¶æŸ¥çœ‹æ˜¯å¦æœ‰æµ‹è¯•å¤±è´¥ã€‚å¦‚æœæ²¡æœ‰æµ‹è¯•å¤±è´¥ï¼Œé‚£ä¹ˆè¦ä¹ˆä½ è¯¯è§£äº†ä½ çš„ç¨‹åºï¼Œè¦ä¹ˆæ›´å¯èƒ½çš„æ˜¯ï¼Œä½ çš„æµ‹è¯•å¥—ä»¶ä¸å¤Ÿå¥½ã€‚æ”¹è¿›ä½ çš„æµ‹è¯•å¥—ä»¶ä»¥æ•è·ä½ ç¨‹åºä¸­çš„é”™è¯¯ï¼Œæˆ–è€…è¯´æœè‡ªå·±è¿™ä¸ªå˜åŒ–å¹¶ä¸é‡è¦ã€‚
- en: There are mutation testing tools that will randomly try to alter your program
    using â€œmutantâ€ strategiesâ€”<wbr>e.g., replacing a `+` with a `-`â€”<wbr>and re-run
    your suites, and then report back on how many potential mutants the suites actually
    caught. But we canâ€™t and shouldnâ€™t only rely on tools; we can also apply the principle
    of mutation testing by hand, as we have above. At the very least, it will help
    us understand our program better!
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: æœ‰ä¸€äº›å˜å¼‚æµ‹è¯•å·¥å…·ä¼šéšæœºå°è¯•ä½¿ç”¨â€œå˜å¼‚â€ç­–ç•¥æ¥æ”¹å˜ä½ çš„ç¨‹åºâ€”â€”ä¾‹å¦‚ï¼Œå°†ä¸€ä¸ª`+`æ›¿æ¢ä¸º`-`â€”â€”ç„¶åé‡æ–°è¿è¡Œä½ çš„æµ‹è¯•å¥—ä»¶ï¼Œå¹¶æŠ¥å‘Šæµ‹è¯•å¥—ä»¶å®é™…æ•è·äº†å¤šå°‘æ½œåœ¨å˜å¼‚ã€‚ä½†æˆ‘ä»¬ä¸èƒ½ï¼Œä¹Ÿä¸åº”è¯¥åªä¾èµ–å·¥å…·ï¼›æˆ‘ä»¬è¿˜å¯ä»¥æ‰‹åŠ¨åº”ç”¨å˜å¼‚æµ‹è¯•çš„åŸåˆ™ï¼Œå°±åƒæˆ‘ä»¬ä¸Šé¢æ‰€åšçš„é‚£æ ·ã€‚è‡³å°‘ï¼Œè¿™å°†å¸®åŠ©æˆ‘ä»¬æ›´å¥½åœ°ç†è§£æˆ‘ä»¬çš„ç¨‹åºï¼
- en: '16.2.7Â More on Value Printing: An Aside from Racket[ğŸ”—](#(part._.More_on_.Value_.Printing__.An_.Aside_from_.Racket)
    "Link to here")'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.7 æ›´å¤šå…³äºå€¼æ‰“å°çš„å†…å®¹ï¼šæ¥è‡ª Racket çš„ä¸€ä¸ªæ—ç™½[ğŸ”—](#(part._.More_on_.Value_.Printing__.An_.Aside_from_.Racket)
    "é“¾æ¥åˆ°æ­¤å¤„")
- en: Earlier, we talked about how the standard recursive size can still be thought
    of as a â€œsize of printed valueâ€ computation. However, that actually depends on
    your languageâ€™s value printer.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹‹å‰ï¼Œæˆ‘ä»¬è®¨è®ºäº†æ ‡å‡†é€’å½’å¤§å°ä»ç„¶å¯ä»¥è¢«è§†ä¸ºâ€œæ‰“å°å€¼çš„å¤§å°â€è®¡ç®—ã€‚ç„¶è€Œï¼Œè¿™å®é™…ä¸Šå–å†³äºä½ çš„è¯­è¨€çš„å€¼æ‰“å°å™¨ã€‚
- en: 'In Racket, you can turn on (itâ€™s slightly more expensive, so off by default)
    a value-printer that shows value sharing: Language | Choose Language â€¦ | Show
    Details | Show sharing in values. So if we take the data definition above and
    translate it into Racket structures'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Racket ä¸­ï¼Œä½ å¯ä»¥æ‰“å¼€ï¼ˆå®ƒç¨å¾®è´µä¸€ç‚¹ï¼Œæ‰€ä»¥é»˜è®¤æ˜¯å…³é—­çš„ï¼‰ä¸€ä¸ªå€¼æ‰“å°å™¨ï¼Œå®ƒæ˜¾ç¤ºå€¼å…±äº«ï¼šè¯­è¨€ | é€‰æ‹©è¯­è¨€ â€¦ | æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯ | æ˜¾ç¤ºå€¼ä¸­çš„å…±äº«ã€‚æ‰€ä»¥å¦‚æœæˆ‘ä»¬æŠŠä¸Šé¢çš„æ•°æ®å®šä¹‰è½¬æ¢æˆ
    Racket ç»“æ„
- en: '| (struct mt () #:transparent) |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| (struct mt () #:transparent) |'
- en: '| (struct nd (v l r) #:transparent) |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| (struct nd (v l r) #:transparent) |'
- en: 'and then construct (almost) the same data as in the first example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæ„å»ºï¼ˆå‡ ä¹ï¼‰ä¸ç¬¬ä¸€ä¸ªä¾‹å­ç›¸åŒçš„æ•°æ®ï¼š
- en: '| (define n1 (nd 1 (mt) (mt))) |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| (define n1 (nd 1 (mt) (mt))) |'
- en: '| (define n2 (nd 2 (mt) n1)) |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| (define n2 (nd 2 (mt) n1)) |'
- en: '| (define n3 (nd 3 n1 (mt))) |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| (define n3 (nd 3 n1 (mt))) |'
- en: '| (define n4 (nd 4 n2 n3)) |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| (define n4 (nd 4 n2 n3)) |'
- en: 'and then ask Racket to print it, we get:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åè¦æ±‚ Racket æ‰“å°å®ƒï¼Œæˆ‘ä»¬å¾—åˆ°ï¼š
- en: '| > n4 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| > n4 |'
- en: '| (nd 4 (nd 2 (mt) #0=(nd 1 (mt) (mt))) (nd 3 #0# (mt))) |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| (nd 4 (nd 2 (mt) #0=(nd 1 (mt) (mt))) (nd 3 #0# (mt))) |'
- en: 'The #0= notation is the moral equivalent of saying, â€œIâ€™m going to refer to
    this value again later, so letâ€™s call it the 0th valueâ€ and #0# is saying â€œHere
    Iâ€™m referring to the aforementioned 0th valueâ€.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '#0=çš„è¡¨ç¤ºæ³•ç›¸å½“äºè¯´ï¼Œâ€œæˆ‘ç¨åä¼šå†æ¬¡å¼•ç”¨è¿™ä¸ªå€¼ï¼Œæ‰€ä»¥è®©æˆ‘ä»¬ç§°å®ƒä¸ºç¬¬0ä¸ªå€¼â€ï¼Œè€Œ#0#åˆ™æ˜¯è¯´â€œè¿™é‡Œæˆ‘æ­£åœ¨å¼•ç”¨å‰é¢æåˆ°çš„ç¬¬0ä¸ªå€¼â€ã€‚'
- en: (Yes, there can be more than one shared value in an output, so each is given
    a different â€œnameâ€. Weâ€™ll see that in a moment.)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: (æ˜¯çš„ï¼Œè¾“å‡ºä¸­å¯ä»¥æœ‰å¤šä¸ªå…±äº«å€¼ï¼Œæ‰€ä»¥æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªä¸åŒçš„â€œåç§°â€ã€‚æˆ‘ä»¬ç¨åä¼šçœ‹åˆ°è¿™ä¸€ç‚¹ã€‚)
- en: The later example above translates to
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šé¢çš„ä¾‹å­å¯ä»¥ç¿»è¯‘ä¸º
- en: '| (define n13 (nd 13 (mt) (mt))) |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| (define n13 (nd 13 (mt) (mt))) |'
- en: '| (define n11 (nd 11 n13 n13)) |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| (define n11 (nd 11 n13 n13)) |'
- en: '| (define n12 (nd 12 n13 (mt))) |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| (define n12 (nd 12 n13 (mt))) |'
- en: '| (define n10 (nd 10 n11 n12)) |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| (define n10 (nd 10 n11 n12)) |'
- en: which prints as
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒæ‰“å°ä¸º
- en: '| > n10 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| > n10 |'
- en: '| (nd 10 (nd 11 #0=(nd 13 (mt) (mt)) #0#) (nd 12 #0# (mt))) |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| (nd 10 (nd 11 #0=(nd 13 (mt) (mt)) #0#) (nd 12 #0# (mt))) |'
- en: So it is possible for a language to reflect the sharing in its output. Itâ€™s
    just that most programming languages choose to not do that, even optionally.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œä¸€ç§è¯­è¨€å¯ä»¥åœ¨å…¶è¾“å‡ºä¸­åæ˜ å…±äº«ã€‚åªæ˜¯å¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€é€‰æ‹©ä¸è¿™æ ·åšï¼Œå³ä½¿ä½œä¸ºå¯é€‰åŠŸèƒ½ã€‚
- en: Remember the â€œalmostâ€ above? What was that about?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: è®°ä½ä¸Šé¢çš„â€œå‡ ä¹â€ï¼Ÿé‚£æ˜¯å…³äºä»€ä¹ˆçš„ï¼Ÿ
- en: 'In Racket, weâ€™ve made a new instance of mt over and over. We can more accurately
    reflect what is happening in Pyret by instantiating it only once:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Racketä¸­ï¼Œæˆ‘ä»¬ä¸€æ¬¡åˆä¸€æ¬¡åœ°åˆ›å»ºäº†mtçš„æ–°å®ä¾‹ã€‚æˆ‘ä»¬å¯ä»¥æ›´å‡†ç¡®åœ°åæ˜ Pyretä¸­å‘ç”Ÿçš„äº‹æƒ…ï¼Œé€šè¿‡åªå®ä¾‹åŒ–ä¸€æ¬¡ï¼š
- en: '| (struct mt () #:transparent) |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| (struct mt () #:transparent) |'
- en: '| (define the-mt (mt)) |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| (define the-mt (mt)) |'
- en: '| (struct nd (v l r) #:transparent) |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| (struct nd (v l r) #:transparent) |'
- en: 'We then rewrite the earlier example to use that one instance only:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬é‡å†™ä¹‹å‰çš„ç¤ºä¾‹ï¼Œåªä½¿ç”¨é‚£ä¸ªå®ä¾‹ï¼š
- en: '| (define n1 (nd 1 the-mt the-mt)) |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| (define n1 (nd 1 the-mt the-mt)) |'
- en: '| (define n2 (nd 2 the-mt n1)) |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| (define n2 (nd 2 the-mt n1)) |'
- en: '| (define n3 (nd 3 n1 the-mt)) |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| (define n3 (nd 3 n1 the-mt)) |'
- en: '| (define n4 (nd 4 n2 n3)) |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| (define n4 (nd 4 n2 n3)) |'
- en: 'And now when we print it:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æ‰“å°å®ƒï¼š
- en: '| > n4 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| > n4 |'
- en: '| (nd 4 (nd 2 #0=(mt) #1=(nd 1 #0# #0#)) (nd 3 #1# #0#)) |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| (nd 4 (nd 2 #0=(mt) #1=(nd 1 #0# #0#)) (nd 3 #1# #0#)) |'
- en: 'And now you can see there are two different shared values, one is the single
    instance of mt, the other is the nd with 1 in it. Thus, Racket uses both #0= /
    #0# and #1= / #1#. Notice how all the leaves are sharing the same mt instance.
    (The numbering is picked in the order in which nodes are encountered while traversing,
    which is why the nd instance was #0 the previous time and is #1 this time.)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç°åœ¨ä½ å¯ä»¥çœ‹åˆ°æœ‰ä¸¤ä¸ªä¸åŒçš„å…±äº«å€¼ï¼Œä¸€ä¸ªæ˜¯mtçš„å•ä¾‹ï¼Œå¦ä¸€ä¸ªæ˜¯åŒ…å«1çš„ndã€‚å› æ­¤ï¼ŒRacketä½¿ç”¨#0= / #0#å’Œ#1= / #1#ã€‚æ³¨æ„æ‰€æœ‰å¶å­éƒ½åœ¨å…±äº«ç›¸åŒçš„mtå®ä¾‹ã€‚ï¼ˆç¼–å·æ˜¯åœ¨éå†èŠ‚ç‚¹æ—¶é‡åˆ°çš„é¡ºåºä¸­é€‰æ‹©çš„ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆndå®ä¾‹ä¸Šæ¬¡æ˜¯#0ï¼Œè¿™æ¬¡æ˜¯#1ã€‚ï¼‰'
- en: 16.2.1Â Stage 1[ğŸ”—](#(part._.Stage_1) "Link to here")
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.1 é˜¶æ®µ 1[ğŸ”—](#(part._.Stage_1) "é“¾æ¥è‡³æ­¤")
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Clearly the answer should be `4`: we can just read off how many `nd` calls
    there are. And clearly the function is wrong.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: æ˜¾ç„¶ç­”æ¡ˆåº”è¯¥æ˜¯`4`ï¼šæˆ‘ä»¬åªéœ€è¯»å–æœ‰å¤šå°‘æ¬¡`nd`è°ƒç”¨ã€‚æ˜¾ç„¶å‡½æ•°æ˜¯é”™è¯¯çš„ã€‚
- en: 'The problem, of course, is that a DAG involves repeating nodes, and we arenâ€™t
    doing anything to track the repetition. So we need a stronger contract: weâ€™ll
    split the problem into two parts, a standard interface function that takes just
    the DAG and returns a number, and a richer helper function, which also takes a
    memory of the nodes already seen.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œé—®é¢˜æ˜¯DAGæ¶‰åŠé‡å¤çš„èŠ‚ç‚¹ï¼Œè€Œæˆ‘ä»¬æ²¡æœ‰åšä»»ä½•è·Ÿè¸ªé‡å¤çš„äº‹æƒ…ã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ›´å¼ºçš„åˆçº¦ï¼šæˆ‘ä»¬å°†é—®é¢˜åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œä¸€ä¸ªæ ‡å‡†æ¥å£å‡½æ•°ï¼Œå®ƒåªæ¥å—DAGå¹¶è¿”å›ä¸€ä¸ªæ•°å­—ï¼Œä»¥åŠä¸€ä¸ªæ›´ä¸°å¯Œçš„è¾…åŠ©å‡½æ•°ï¼Œå®ƒè¿˜æ¥å—å·²çœ‹åˆ°çš„èŠ‚ç‚¹çš„è®°å¿†ã€‚
- en: 16.2.2Â Stage 2[ğŸ”—](#(part._.Stage_2) "Link to here")
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.2 é˜¶æ®µ 2[ğŸ”—](#(part._.Stage_2) "é“¾æ¥è‡³æ­¤")
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Exercise
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does this code use `member-identical` rather than `member`?
  id: totrans-120
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆè¿™æ®µä»£ç ä½¿ç”¨`member-identical`è€Œä¸æ˜¯`member`ï¼Ÿ
- en: ''
  id: totrans-121
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe that if we replace every `member-identical` with `member` in this chapter,
    the code still behaves the same. Why?
  id: totrans-122
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è§‚å¯Ÿåˆ°ï¼Œå¦‚æœæˆ‘ä»¬åœ¨è¿™ä¸ªç« èŠ‚ä¸­å°†æ¯ä¸ª`member-identical`æ›¿æ¢ä¸º`member`ï¼Œä»£ç ä»ç„¶è¡¨ç°ç›¸åŒã€‚ä¸ºä»€ä¹ˆï¼Ÿ
- en: ''
  id: totrans-123
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make changes to demonstrate the need for `member-identical`.
  id: totrans-124
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿›è¡Œæ›´æ”¹ä»¥è¯æ˜`member-identical`çš„å¿…è¦æ€§ã€‚
- en: 'Is it odd that we return `0`? Not if we reinterpret what the function does:
    it doesnâ€™t count the size, it counts the additional contribution to the size (relative
    to what has already been seen) of the `BT` it is given. A node already in `seen`
    makes no marginal contribution; it was already counted earlier.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: è¿”å›`0`æ˜¯å¦å¥‡æ€ªï¼Ÿå¦‚æœä¸æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬é‡æ–°è§£é‡Šå‡½æ•°çš„ä½œç”¨ï¼šå®ƒä¸è®¡ç®—å¤§å°ï¼Œå®ƒè®¡ç®—`BT`ç»™å®šçš„é¢å¤–è´¡çŒ®çš„å¤§å°ï¼ˆç›¸å¯¹äºå·²ç»çœ‹åˆ°çš„ï¼‰ã€‚å·²ç»å­˜åœ¨äº`seen`ä¸­çš„èŠ‚ç‚¹ä¸ä¼šäº§ç”Ÿè¾¹é™…è´¡çŒ®ï¼›å®ƒä¹‹å‰å·²ç»è¢«è®¡ç®—è¿‡ã€‚
- en: 'Finally, we should not export such a function to the user, who has to deal
    with an unwieldy extra parameter and may send something poorly-formed, thereby
    causing our function to break. Instead, we should write a wrapper for it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæˆ‘ä»¬ä¸åº”è¯¥å°†æ­¤ç±»å‡½æ•°å¯¼å‡ºç»™ç”¨æˆ·ï¼Œç”¨æˆ·å¿…é¡»å¤„ç†ä¸€ä¸ªéš¾ä»¥é©¾é©­çš„é¢å¤–å‚æ•°ï¼Œå¹¶ä¸”å¯èƒ½ä¼šå‘é€æ ¼å¼ä¸ä½³çš„å†…å®¹ï¼Œä»è€Œå¯¼è‡´æˆ‘ä»¬çš„å‡½æ•°å´©æºƒã€‚ç›¸åï¼Œæˆ‘ä»¬åº”è¯¥ä¸ºå…¶ç¼–å†™ä¸€ä¸ªåŒ…è£…å™¨ï¼š
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This also enables us to use our old tests (renamed):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¹Ÿä½¿æˆ‘ä»¬èƒ½å¤Ÿä½¿ç”¨æˆ‘ä»¬çš„æ—§æµ‹è¯•ï¼ˆå·²é‡å‘½åï¼‰ï¼š
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Unfortunately, this still doesnâ€™t work!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼Œè¿™ä»ç„¶ä¸èµ·ä½œç”¨ï¼
- en: Do Now!
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use Pyretâ€™s `spy` construct in `size-2-h` to figure out why.
  id: totrans-133
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨`size-2-h`ä¸­ä½¿ç”¨Pyretçš„`spy`æ„é€ æ¥æ‰¾å‡ºåŸå› ã€‚
- en: 16.2.3Â Stage 3[ğŸ”—](#(part._.Stage_3) "Link to here")
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.3 é˜¶æ®µ 3[ğŸ”—](#(part._.Stage_3) "é“¾æ¥è‡³æ­¤")
- en: Did you remember to use `spy`? Otherwise you may very well miss the problem!
    Be sure to use `spy` (feel free to elide the first few tests for now) to get a
    feel for the issue.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ è®°å¾—ä½¿ç”¨`spy`å—ï¼Ÿå¦åˆ™ä½ å¯èƒ½ä¼šå®Œå…¨é”™è¿‡é—®é¢˜ï¼ç¡®ä¿ä½¿ç”¨`spy`ï¼ˆç°åœ¨å¯ä»¥è‡ªç”±çœç•¥å‰å‡ ä¸ªæµ‹è¯•ï¼‰æ¥äº†è§£é—®é¢˜ã€‚
- en: As you may have noted, the problem is that we want `seen` to be all the nodes
    ever seen. However, every time we return from one sub-computation, we also lose
    track of whatever was seen during its work. Instead, we have to also return everything
    that was seen, so as to properly preserve the idea that weâ€™re computing the marginal
    contribution of each node.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æ‚¨æ‰€æ³¨æ„åˆ°çš„ï¼Œé—®é¢˜åœ¨äºæˆ‘ä»¬å¸Œæœ›`seen`åŒ…å«æ‰€æœ‰æ›¾ç»è§è¿‡çš„èŠ‚ç‚¹ã€‚ç„¶è€Œï¼Œæ¯æ¬¡æˆ‘ä»¬ä»å­è®¡ç®—è¿”å›æ—¶ï¼Œæˆ‘ä»¬ä¹Ÿä¼šå¤±å»å¯¹å…¶å·¥ä½œæœŸé—´æ‰€çœ‹åˆ°çš„ä»»ä½•å†…å®¹çš„è·Ÿè¸ªã€‚ç›¸åï¼Œæˆ‘ä»¬å¿…é¡»è¿”å›æ‰€æœ‰çœ‹åˆ°çš„å†…å®¹ï¼Œä»¥ä¾¿æ­£ç¡®åœ°ä¿ç•™æˆ‘ä»¬æ­£åœ¨è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„è¾¹é™…è´¡çŒ®çš„æƒ³æ³•ã€‚
- en: 'We can do this with the following data structure:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ç”¨ä»¥ä¸‹æ•°æ®ç»“æ„æ¥åšè¿™ä»¶äº‹ï¼š
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'which is returned by the helper function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ç”±è¾…åŠ©å‡½æ•°è¿”å›çš„ï¼š
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note, crucially, how the `seen` argument for the right branch is `rl.sn`: i.e.,
    everything that was already seen in the left branch. This is the crucial step
    that avoids the bug.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå…³é”®çš„æ˜¯ï¼Œå³åˆ†æ”¯çš„`seen`å‚æ•°æ˜¯`rl.sn`ï¼šå³å·¦åˆ†æ”¯ä¸­å·²ç»çœ‹åˆ°çš„å…¨éƒ¨å†…å®¹ã€‚è¿™æ˜¯é¿å…é”™è¯¯çš„å…³é”®æ­¥éª¤ã€‚
- en: 'Because of this richer return type, we have to extract the actual answer for
    the purpose of testing:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºè¿™ä¸ªæ›´ä¸°å¯Œçš„è¿”å›ç±»å‹ï¼Œæˆ‘ä»¬å¿…é¡»æå–å®é™…çš„ç­”æ¡ˆæ¥ç”¨äºæµ‹è¯•ï¼š
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Exercise
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Must `seen` be a list? What else can it be?
  id: totrans-146
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`seen`å¿…é¡»æ˜¯åˆ—è¡¨å—ï¼Ÿå®ƒè¿˜å¯ä»¥æ˜¯ä»€ä¹ˆï¼Ÿ'
- en: 16.2.4Â Stage 4[ğŸ”—](#(part._.Stage_4) "Link to here")
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.4 ç¬¬å››é˜¶æ®µ[ğŸ”—](#(part._.Stage_4) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Observe that the `Ret` data structure is only of local interest. Itâ€™s purely
    internal to the `size-3-h` function; even `size-3` ignores one half, and it will
    never be seen by the rest of the program. That is a good use of tuples, as we
    have seen before: [Using Tuples](queues-from-lists.html#%28part._qfl-tuples%29)!'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œ`Ret`æ•°æ®ç»“æ„åªå…·æœ‰å±€éƒ¨å…´è¶£ã€‚å®ƒå®Œå…¨æ˜¯`size-3-h`å‡½æ•°å†…éƒ¨çš„ï¼›ç”šè‡³`size-3`ä¹Ÿå¿½ç•¥äº†å¦ä¸€åŠï¼Œå®ƒæ°¸è¿œä¸ä¼šè¢«ç¨‹åºçš„å…¶ä»–éƒ¨åˆ†çœ‹åˆ°ã€‚è¿™å°±æ˜¯æˆ‘ä»¬ä¹‹å‰çœ‹åˆ°çš„å¥½ç”¨å…ƒç»„çš„æ–¹å¼ï¼š[ä½¿ç”¨å…ƒç»„](queues-from-lists.html#%28part._qfl-tuples%29)!
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The notation `{0; seen}` makes an actual tuple; `{Number; List<BT>}` declares
    the contract of a tuple. Also, `.{0}` extracts the `0`th element (the leftmost
    one) of a tuple.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¦å·`{0; seen}`åˆ›å»ºä¸€ä¸ªå®é™…çš„å…ƒç»„ï¼›`{Number; List<BT>}`å£°æ˜äº†å…ƒç»„çš„å¥‘çº¦ã€‚æ­¤å¤–ï¼Œ`.{0}`ä»å…ƒç»„ä¸­æå–`0`thå…ƒç´ ï¼ˆæœ€å·¦è¾¹çš„å…ƒç´ ï¼‰ã€‚
- en: 16.2.5Â Stage 5[ğŸ”—](#(part._.Stage_5) "Link to here")
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.5 ç¬¬äº”é˜¶æ®µ[ğŸ”—](#(part._.Stage_5) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Notice that we have the two instances of the code `{0; seen}`. Do they have
    to be that? What if we were to return `{0; empty}` instead in both places? Does
    anything break?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬æœ‰ä»£ç çš„ä¸¤ä¸ªå®ä¾‹`{0; seen}`ã€‚å®ƒä»¬å¿…é¡»æ˜¯è¿™æ ·å—ï¼Ÿå¦‚æœæˆ‘ä»¬åœ¨è¿™ä¸¤ä¸ªåœ°æ–¹éƒ½è¿”å›`{0; empty}`ä¼šæ€æ ·ï¼Ÿæœ‰ä»€ä¹ˆä¼šå‡ºé”™å—ï¼Ÿ
- en: We might expect it to break in the case where `member-identical` returns `true`,
    but perhaps not in the `mt` case.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯èƒ½é¢„è®¡åœ¨`member-identical`è¿”å›`true`çš„æƒ…å†µä¸‹ä¼šå‡ºé”™ï¼Œä½†åœ¨`mt`æƒ…å†µä¸‹å¯èƒ½ä¸ä¼šã€‚
- en: Do Now!
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make each of these changes. Does the outcome match your expectations?
  id: totrans-156
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¯¹è¿™äº›æ›´æ”¹è¿›è¡Œæ“ä½œã€‚ç»“æœæ˜¯å¦ç¬¦åˆä½ çš„é¢„æœŸï¼Ÿ
- en: Curiously, no! Making the change in the `mt` case has an effect but making it
    in the `member-identical` case doesnâ€™t! This almost seems counter-intuitive. How
    can we diagnose this?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: å¥‡æ€ªçš„æ˜¯ï¼Œä¸ï¼åœ¨`mt`æƒ…å†µä¸‹åšå‡ºæ”¹å˜ä¼šæœ‰å½±å“ï¼Œä½†åœ¨`member-identical`æƒ…å†µä¸‹åšå‡ºæ”¹å˜å´æ²¡æœ‰ï¼è¿™å‡ ä¹è®©äººæ„Ÿè§‰åç›´è§‰ã€‚æˆ‘ä»¬å¦‚ä½•è¯Šæ–­è¿™ä¸ªé—®é¢˜ï¼Ÿ
- en: Do Now!
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use `spy` to determine what is going on!
  id: totrans-160
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`spy`æ¥ç¡®å®šå‘ç”Ÿäº†ä»€ä¹ˆï¼
- en: Okay, so it seems like returning `empty` when we revisit a node doesnâ€™t seem
    to do any harm. Does that mean itâ€™s okay to make that change?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½å§ï¼Œæ‰€ä»¥å½“æˆ‘ä»¬é‡æ–°è®¿é—®ä¸€ä¸ªèŠ‚ç‚¹æ—¶è¿”å›`empty`ä¼¼ä¹å¹¶æ²¡æœ‰é€ æˆä»»ä½•ä¼¤å®³ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥åšå‡ºè¿™æ ·çš„æ”¹å˜å—ï¼Ÿ
- en: 'Observe that nothing has actually depended on that seen-list being `empty`.
    Thatâ€™s why it appears to not matter. How can we make it matter? By making it â€œhurtâ€
    the computation by visiting a previously seen, but now forgotten, node yet again.
    So we need to visit a node at least three times: the first time to remember it;
    the second time to forget it; and a third time to incorrectly visit it again.
    Hereâ€™s a DAG that will do that:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå®é™…ä¸Šæ²¡æœ‰ä»€ä¹ˆä¾èµ–äºé‚£ä¸ª`seen`åˆ—è¡¨æ˜¯`empty`çš„ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆå®ƒçœ‹èµ·æ¥å¹¶ä¸é‡è¦ã€‚æˆ‘ä»¬å¦‚ä½•è®©å®ƒå˜å¾—é‡è¦ï¼Ÿé€šè¿‡é€šè¿‡å†æ¬¡è®¿é—®ä¸€ä¸ªä¹‹å‰çœ‹åˆ°ä½†ç°åœ¨å·²è¢«é—å¿˜çš„èŠ‚ç‚¹æ¥â€œä¼¤å®³â€è®¡ç®—ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦è‡³å°‘è®¿é—®ä¸€ä¸ªèŠ‚ç‚¹ä¸‰æ¬¡ï¼šç¬¬ä¸€æ¬¡æ˜¯ä¸ºäº†è®°ä½å®ƒï¼›ç¬¬äºŒæ¬¡æ˜¯ä¸ºäº†å¿˜è®°å®ƒï¼›ç¬¬ä¸‰æ¬¡æ˜¯ä¸ºäº†é”™è¯¯åœ°å†æ¬¡è®¿é—®å®ƒã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªä¼šè¿™æ ·åšæœ‰å‘å›¾ï¼š
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Sure enough, if either tuple now returns `empty`, this test fails. Otherwise
    it succeeds.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œå¦‚æœä»»ä¸€å…ƒç»„ç°åœ¨è¿”å›`empty`ï¼Œè¿™ä¸ªæµ‹è¯•å°±ä¼šå¤±è´¥ã€‚å¦åˆ™ï¼Œå®ƒå°±ä¼šæˆåŠŸã€‚
- en: 16.2.6Â What Weâ€™ve Learned[ğŸ”—](#(part._.What_.We~e2~80~99ve_.Learned) "Link to
    here")
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.6 æˆ‘ä»¬å­¦åˆ°äº†ä»€ä¹ˆ[ğŸ”—](#(part._.What_.We~e2~80~99ve_.Learned) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'We have learned three important principles here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨è¿™é‡Œå­¦åˆ°äº†ä¸‰ä¸ªé‡è¦çš„åŸåˆ™ï¼š
- en: A pattern for dealing with programs that need â€œmemoryâ€. This is called threading
    (not in the sense of â€œmulti-threadingâ€, which is a kind of parallel computation,
    but rather the pattern of how the seen list gets passed through the program).
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¤„ç†éœ€è¦â€œå†…å­˜â€çš„ç¨‹åºçš„æ¨¡å¼ã€‚è¿™è¢«ç§°ä¸ºçº¿ç¨‹ï¼ˆä¸æ˜¯â€œå¤šçº¿ç¨‹â€çš„æ„æ€ï¼Œå¤šçº¿ç¨‹æ˜¯ä¸€ç§å¹¶è¡Œè®¡ç®—ï¼Œè€Œæ˜¯æŒ‡å¦‚ä½•å°†çœ‹åˆ°çš„åˆ—è¡¨é€šè¿‡ç¨‹åºä¼ é€’çš„æ¨¡å¼ï¼‰ã€‚
- en: 'A good example of the use of tuples: local, where the documentation benefit
    of datatypes isnâ€™t necessary (and the extra datatype probably just clutters up
    the program), as opposed to distant, where it is. In general, itâ€™s always okay
    to make a new datatype; itâ€™s only sometimes okay to use tuples in their place.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å…ƒç»„ä½¿ç”¨çš„ä¸€ä¸ªå¥½ä¾‹å­ï¼šåœ¨æœ¬åœ°ï¼Œæ•°æ®ç±»å‹çš„æ–‡æ¡£ä¼˜åŠ¿ä¸æ˜¯å¿…è¦çš„ï¼ˆè€Œä¸”é¢å¤–çš„æ•°æ®ç±»å‹å¯èƒ½åªæ˜¯ä½¿ç¨‹åºå˜å¾—æ‚ä¹±ï¼‰ï¼Œä¸è¿œç¨‹ç›¸å¯¹ï¼Œé‚£é‡Œæ˜¯å¿…è¦çš„ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œæ€»æ˜¯å¯ä»¥åˆ›å»ºä¸€ä¸ªæ–°çš„æ•°æ®ç±»å‹ï¼›åªæœ‰åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæ‰å¯ä»¥ä½¿ç”¨å…ƒç»„æ¥ä»£æ›¿ã€‚
- en: An important software-engineering principle, called mutation testing. This is
    an odd name because it would seem to be the name of a technique to test programs.
    Actually, itâ€™s a technique to test test suites. You have a tested program; you
    then â€œmutateâ€ some part of your program that you feel must change the output,
    and see whether any tests break. If no tests break, then either youâ€™ve misunderstood
    your program or, more likely, your test suite is not good enough. Improve your
    test suite to catch the error in your program, or convince yourself the change
    didnâ€™t matter.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªé‡è¦çš„è½¯ä»¶å·¥ç¨‹åŸåˆ™ï¼Œç§°ä¸ºå˜å¼‚æµ‹è¯•ã€‚è¿™ä¸ªåå­—å¬èµ·æ¥åƒæ˜¯æµ‹è¯•ç¨‹åºçš„æŠ€æœ¯ï¼Œå®é™…ä¸Šï¼Œå®ƒæ˜¯ä¸€ç§æµ‹è¯•æµ‹è¯•å¥—ä»¶çš„æŠ€æœ¯ã€‚ä½ æœ‰ä¸€ä¸ªç»è¿‡æµ‹è¯•çš„ç¨‹åºï¼›ç„¶åâ€œå˜å¼‚â€ä½ ç¨‹åºä¸­ä½ è®¤ä¸ºå¿…é¡»æ”¹å˜è¾“å‡ºçš„éƒ¨åˆ†ï¼Œçœ‹çœ‹æ˜¯å¦æœ‰æµ‹è¯•å¤±è´¥ã€‚å¦‚æœæ²¡æœ‰æµ‹è¯•å¤±è´¥ï¼Œé‚£ä¹ˆè¦ä¹ˆæ˜¯ä½ æ²¡æœ‰ç†è§£ä½ çš„ç¨‹åºï¼Œè¦ä¹ˆæ›´å¯èƒ½æ˜¯ä½ çš„æµ‹è¯•å¥—ä»¶ä¸å¤Ÿå¥½ã€‚æ”¹è¿›ä½ çš„æµ‹è¯•å¥—ä»¶ä»¥æ•è·ä½ ç¨‹åºä¸­çš„é”™è¯¯ï¼Œæˆ–è€…è¯´æœè‡ªå·±è¿™ä¸ªå˜åŒ–å¹¶ä¸é‡è¦ã€‚
- en: There are mutation testing tools that will randomly try to alter your program
    using â€œmutantâ€ strategiesâ€”<wbr>e.g., replacing a `+` with a `-`â€”<wbr>and re-run
    your suites, and then report back on how many potential mutants the suites actually
    caught. But we canâ€™t and shouldnâ€™t only rely on tools; we can also apply the principle
    of mutation testing by hand, as we have above. At the very least, it will help
    us understand our program better!
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: æœ‰ä¸€äº›å˜å¼‚æµ‹è¯•å·¥å…·ä¼šéšæœºå°è¯•ä½¿ç”¨â€œå˜å¼‚â€ç­–ç•¥æ¥æ”¹å˜ä½ çš„ç¨‹åºâ€”â€”ä¾‹å¦‚ï¼Œå°†ä¸€ä¸ª`+`æ›¿æ¢ä¸º`-`â€”â€”ç„¶åé‡æ–°è¿è¡Œä½ çš„æµ‹è¯•å¥—ä»¶ï¼Œå¹¶æŠ¥å‘Šæµ‹è¯•å¥—ä»¶å®é™…æ•è·äº†å¤šå°‘æ½œåœ¨å˜å¼‚ã€‚ä½†æˆ‘ä»¬ä¸èƒ½ï¼Œä¹Ÿä¸åº”è¯¥åªä¾èµ–å·¥å…·ï¼›æˆ‘ä»¬è¿˜å¯ä»¥æ‰‹åŠ¨åº”ç”¨å˜å¼‚æµ‹è¯•çš„åŸåˆ™ï¼Œå°±åƒæˆ‘ä»¬ä¸Šé¢æ‰€åšçš„é‚£æ ·ã€‚è‡³å°‘ï¼Œè¿™å°†å¸®åŠ©æˆ‘ä»¬æ›´å¥½åœ°ç†è§£æˆ‘ä»¬çš„ç¨‹åºï¼
- en: '16.2.7Â More on Value Printing: An Aside from Racket[ğŸ”—](#(part._.More_on_.Value_.Printing__.An_.Aside_from_.Racket)
    "Link to here")'
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.7 æ›´å¤šå…³äºå€¼æ‰“å°ï¼šæ¥è‡ªRacketçš„æ—ç™½[ğŸ”—](#(part._.More_on_.Value_.Printing__.An_.Aside_from_.Racket)
    "é“¾æ¥åˆ°æ­¤å¤„")
- en: Earlier, we talked about how the standard recursive size can still be thought
    of as a â€œsize of printed valueâ€ computation. However, that actually depends on
    your languageâ€™s value printer.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹‹å‰ï¼Œæˆ‘ä»¬è®¨è®ºäº†æ ‡å‡†é€’å½’å¤§å°ä»ç„¶å¯ä»¥è¢«è§†ä¸ºâ€œæ‰“å°å€¼çš„å¤§å°â€è®¡ç®—ã€‚ç„¶è€Œï¼Œè¿™å®é™…ä¸Šå–å†³äºä½ çš„è¯­è¨€çš„å€¼æ‰“å°å™¨ã€‚
- en: 'In Racket, you can turn on (itâ€™s slightly more expensive, so off by default)
    a value-printer that shows value sharing: Language | Choose Language â€¦ | Show
    Details | Show sharing in values. So if we take the data definition above and
    translate it into Racket structures'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Racketä¸­ï¼Œä½ å¯ä»¥æ‰“å¼€ï¼ˆå®ƒç¨å¾®è´µä¸€ç‚¹ï¼Œæ‰€ä»¥é»˜è®¤æ˜¯å…³é—­çš„ï¼‰ä¸€ä¸ªå€¼æ‰“å°å™¨ï¼Œæ˜¾ç¤ºå€¼å…±äº«ï¼šè¯­è¨€ | é€‰æ‹©è¯­è¨€ â€¦ | æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯ | æ˜¾ç¤ºå€¼ä¸­çš„å…±äº«ã€‚æ‰€ä»¥å¦‚æœæˆ‘ä»¬æŠŠä¸Šé¢çš„æ•°æ®å®šä¹‰ç¿»è¯‘æˆRacketç»“æ„
- en: '| (struct mt () #:transparent) |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| (struct mt () #:transparent) |'
- en: '| (struct nd (v l r) #:transparent) |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| (struct nd (v l r) #:transparent) |'
- en: 'and then construct (almost) the same data as in the first example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæ„å»ºï¼ˆå‡ ä¹ï¼‰ä¸ç¬¬ä¸€ä¸ªç¤ºä¾‹ç›¸åŒçš„æ•°æ®ï¼š
- en: '| (define n1 (nd 1 (mt) (mt))) |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| (define n1 (nd 1 (mt) (mt))) |'
- en: '| (define n2 (nd 2 (mt) n1)) |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| (define n2 (nd 2 (mt) n1)) |'
- en: '| (define n3 (nd 3 n1 (mt))) |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| (define n3 (nd 3 n1 (mt))) |'
- en: '| (define n4 (nd 4 n2 n3)) |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| (define n4 (nd 4 n2 n3)) |'
- en: 'and then ask Racket to print it, we get:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åè¦æ±‚Racketæ‰“å°å®ƒï¼Œæˆ‘ä»¬å¾—åˆ°ï¼š
- en: '| > n4 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| > n4 |'
- en: '| (nd 4 (nd 2 (mt) #0=(nd 1 (mt) (mt))) (nd 3 #0# (mt))) |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| (nd 4 (nd 2 (mt) #0=(nd 1 (mt) (mt))) (nd 3 #0# (mt))) |'
- en: 'The #0= notation is the moral equivalent of saying, â€œIâ€™m going to refer to
    this value again later, so letâ€™s call it the 0th valueâ€ and #0# is saying â€œHere
    Iâ€™m referring to the aforementioned 0th valueâ€.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '#0=è®°å·æ˜¯â€œæˆ‘ç¨åä¼šå†æ¬¡å¼•ç”¨è¿™ä¸ªå€¼ï¼Œæ‰€ä»¥è®©æˆ‘ä»¬ç§°å®ƒä¸º0thå€¼â€çš„é“å¾·ç­‰ä»·ç‰©ï¼Œè€Œ#0#åˆ™æ˜¯è¯´â€œè¿™é‡Œæˆ‘æ­£åœ¨å¼•ç”¨å‰é¢æåˆ°çš„0thå€¼â€ã€‚'
- en: (Yes, there can be more than one shared value in an output, so each is given
    a different â€œnameâ€. Weâ€™ll see that in a moment.)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆæ˜¯çš„ï¼Œè¾“å‡ºä¸­å¯ä»¥æœ‰ä¸€ä¸ªä»¥ä¸Šçš„å…±äº«å€¼ï¼Œæ‰€ä»¥æ¯ä¸ªå€¼éƒ½ä¼šè¢«èµ‹äºˆä¸€ä¸ªä¸åŒçš„â€œåç§°â€ã€‚æˆ‘ä»¬ç¨åä¼šçœ‹åˆ°ã€‚ï¼‰
- en: The later example above translates to
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šé¢çš„åç»­ç¤ºä¾‹ç¿»è¯‘ä¸º
- en: '| (define n13 (nd 13 (mt) (mt))) |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| (define n13 (nd 13 (mt) (mt))) |'
- en: '| (define n11 (nd 11 n13 n13)) |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| (define n11 (nd 11 n13 n13)) |'
- en: '| (define n12 (nd 12 n13 (mt))) |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| (define n12 (nd 12 n13 (mt))) |'
- en: '| (define n10 (nd 10 n11 n12)) |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| (define n10 (nd 10 n11 n12)) |'
- en: which prints as
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: which prints as
- en: '| > n10 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| > n10 |'
- en: '| (nd 10 (nd 11 #0=(nd 13 (mt) (mt)) #0#) (nd 12 #0# (mt))) |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| (nd 10 (nd 11 #0=(nd 13 (mt) (mt)) #0#) (nd 12 #0# (mt))) |'
- en: So it is possible for a language to reflect the sharing in its output. Itâ€™s
    just that most programming languages choose to not do that, even optionally.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œä¸€ç§è¯­è¨€å¯ä»¥åœ¨å…¶è¾“å‡ºä¸­åæ˜ å…±äº«ã€‚åªæ˜¯å¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€é€‰æ‹©ä¸è¿™æ ·åšï¼Œå³ä½¿æ˜¯æœ‰é€‰é¡¹çš„ã€‚
- en: Remember the â€œalmostâ€ above? What was that about?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: è®°å¾—ä¸Šé¢æåˆ°çš„â€œå‡ ä¹â€å—ï¼Ÿé‚£æ˜¯å…³äºä»€ä¹ˆçš„ï¼Ÿ
- en: 'In Racket, weâ€™ve made a new instance of mt over and over. We can more accurately
    reflect what is happening in Pyret by instantiating it only once:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Racket ä¸­ï¼Œæˆ‘ä»¬åå¤åˆ›å»ºäº† mt çš„æ–°å®ä¾‹ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡åªå®ä¾‹åŒ–ä¸€æ¬¡æ›´å‡†ç¡®åœ°åæ˜  Pyret ä¸­å‘ç”Ÿçš„æƒ…å†µï¼š
- en: '| (struct mt () #:transparent) |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| (struct mt () #:transparent) |'
- en: '| (define the-mt (mt)) |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| (define the-mt (mt)) |'
- en: '| (struct nd (v l r) #:transparent) |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| (struct nd (v l r) #:transparent) |'
- en: 'We then rewrite the earlier example to use that one instance only:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç„¶åå°†ä¹‹å‰çš„ä¾‹å­é‡å†™ä¸ºåªä½¿ç”¨é‚£ä¸ªå®ä¾‹ï¼š
- en: '| (define n1 (nd 1 the-mt the-mt)) |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| (define n1 (nd 1 the-mt the-mt)) |'
- en: '| (define n2 (nd 2 the-mt n1)) |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| (define n2 (nd 2 the-mt n1)) |'
- en: '| (define n3 (nd 3 n1 the-mt)) |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| (define n3 (nd 3 n1 the-mt)) |'
- en: '| (define n4 (nd 4 n2 n3)) |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| (define n4 (nd 4 n2 n3)) |'
- en: 'And now when we print it:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æ‰“å°å®ƒæ—¶ï¼š
- en: '| > n4 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| > n4 |'
- en: '| (nd 4 (nd 2 #0=(mt) #1=(nd 1 #0# #0#)) (nd 3 #1# #0#)) |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| (nd 4 (nd 2 #0=(mt) #1=(nd 1 #0# #0#)) (nd 3 #1# #0#)) |'
- en: 'And now you can see there are two different shared values, one is the single
    instance of mt, the other is the nd with 1 in it. Thus, Racket uses both #0= /
    #0# and #1= / #1#. Notice how all the leaves are sharing the same mt instance.
    (The numbering is picked in the order in which nodes are encountered while traversing,
    which is why the nd instance was #0 the previous time and is #1 this time.)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç°åœ¨ä½ å¯ä»¥çœ‹åˆ°æœ‰ä¸¤ä¸ªä¸åŒçš„å…±äº«å€¼ï¼Œä¸€ä¸ªæ˜¯ mt çš„å•ä¸ªå®ä¾‹ï¼Œå¦ä¸€ä¸ªæ˜¯åŒ…å« 1 çš„ ndã€‚å› æ­¤ï¼ŒRacket ä½¿ç”¨äº† #0= / #0# å’Œ #1= /
    #1#ã€‚æ³¨æ„æ‰€æœ‰å¶å­èŠ‚ç‚¹æ˜¯å¦‚ä½•å…±äº«ç›¸åŒçš„ mt å®ä¾‹çš„ã€‚ï¼ˆç¼–å·æ˜¯åœ¨éå†èŠ‚ç‚¹æ—¶æŒ‰é¡ºåºé€‰å–çš„ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆ nd å®ä¾‹ä¸Šæ¬¡æ˜¯ #0ï¼Œè¿™æ¬¡æ˜¯ #1ã€‚ï¼‰'
