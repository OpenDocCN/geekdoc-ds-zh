- en: Chapter 3 R vectors versus Numpy arrays and Pandas’ Series
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章 R 向量与 Numpy 数组和 Pandas 系列的比较
- en: 原文：[https://randpythonbook.netlify.app/r-vectors-versus-numpy-arrays-and-pandas-series](https://randpythonbook.netlify.app/r-vectors-versus-numpy-arrays-and-pandas-series)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://randpythonbook.netlify.app/r-vectors-versus-numpy-arrays-and-pandas-series](https://randpythonbook.netlify.app/r-vectors-versus-numpy-arrays-and-pandas-series)
- en: This section is for describing the data types that let us store collections
    of elements that all **share the same type**. Data is very commonly stored in
    this fashion, so this section is quite important. Once we have one of these collection
    objects in a program, we will be interested in learning how to extract and modify
    different elements in the collection, as well as how to use the entire collection
    in an efficient calculation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节用于描述允许我们存储具有相同类型的元素集合的数据类型。数据通常以这种方式存储，因此本节非常重要。一旦在程序中有一个这样的集合对象，我们就会对如何提取和修改集合中的不同元素以及如何高效地使用整个集合进行计算感兴趣。
- en: 3.1 Overview of R
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 R 概述
- en: In the previous section, I mentioned that R does not have scalar types–it just
    has [**vectors**](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Vector-objects).
    So, whether you want to store one number (or `logical`, or `character`, or …),
    or many numbers, you will need a `vector`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我提到 R 没有标量类型——它只有 [**向量**](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Vector-objects)。所以，无论你想存储一个数字（或
    `logical`，或 `character`，或……），还是许多数字，你都需要一个 `vector`。
- en: For many, the word “vector” evokes an impression that these objects are designed
    to be used for performing matrix arithmetic (e.g. inner products, transposes,
    etc.). You can perform these operations on `vector`s, but in my opinion, this
    preconception can be misleading, and I recommend avoiding it. Most of the things
    you can do with `vector`s in R have little to do with linear algebra!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多人来说，“向量”这个词会让人联想到这些对象是为了执行矩阵运算（例如内积、转置等）而设计的。你可以在 `vector` 上执行这些操作，但在我看来，这种先入为主的观念可能会误导人，我建议避免它。你可以在
    R 中用 `vector` 做的事情与线性代数几乎无关！
- en: How do we create one of these? There are many ways. One common way is to read
    in elements from an external data set. Another way is to generate `vector`s from
    code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何创建这样的一个呢？有很多方法。一种常见的方法是从外部数据集中读取元素。另一种方法是从代码中生成 `vector`。
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`c()` is short for “combine”. `seq()` and `rep()` are short for “sequence”
    and “replicate”, respectively. `rnorm()` samples normal (or Gaussian) random variables.
    There is plenty more to learn about these functions, so I encourage you to take
    a look at their documentation.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`c()` 是 “组合” 的缩写。`seq()` 和 `rep()` 分别是 “序列” 和 “复制” 的缩写。`rnorm()` 用于抽取正态（或高斯）随机变量。关于这些函数还有很多东西要学习，所以我鼓励你查看它们的文档。'
- en: I should mention that functions such as `rnorm()` don’t create truly random
    numbers, just *pseudorandom* ones. Pseudorandom numbers are nearly indecipherable
    from truly random ones, but the way the computer generates them is actually deterministic.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该提到，像 `rnorm()` 这样的函数并不创建真正的随机数，只是 *伪随机* 数。伪随机数几乎与真正的随机数无法区分，但计算机生成它们的方式实际上是确定性的。
- en: First, a *seed*, or starting number is chosen. Then, the *pseudorandom number
    generator (PRNG)* maps that number to another number. The sequence of all the
    numbers appears to be random, but is actually deterministic.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，选择一个 *种子*，或起始数字。然后，*伪随机数生成器（PRNG）* 将该数字映射到另一个数字。所有数字的序列看起来是随机的，但实际上是确定性的。
- en: Sometimes you will be interested in setting the seed on your own because it
    is a cheap way of sharing and communicating data with others. If two people use
    the same starting seed, and the same PRNG, then they should simulate the same
    data. This can be important if you want to help other people reproduce the results
    of code you share. Most of the time, though, I don’t set the seed, and I don’t
    think about the distinction between random and pseudorandom numbers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能会想自己设置种子，因为这是一种便宜的数据共享和通信方式。如果两个人使用相同的起始种子和相同的 PRNG，那么他们应该模拟相同的数据。如果你想要帮助其他人重现你分享的代码的结果，这可能很重要。不过，大多数时候，我不会设置种子，也不会考虑随机数和伪随机数之间的区别。
- en: 3.2 Overview of Python
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 Python 概述
- en: If you want to store many elements of the same type (and size) in Python, you
    will probably need a Numpy `array`. Numpy is a highly-regarded third party library
    (Harris et al. [2020](#ref-harris2020array)) for Python. Its `array` objects store
    elements of the same type, just as R’s `vector`s do.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在Python中存储许多相同类型（和大小）的元素，你可能需要一个Numpy `数组`。Numpy是一个备受推崇的Python第三方库（Harris等人[2020](#ref-harris2020array)）。它的`数组`对象存储相同类型的元素，就像R的`向量`一样。
- en: There are five ways to create numpy arrays ([source](https://numpy.org/doc/stable/user/basics.creation.html)).
    Here are some examples that complement the examples from above.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 创建numpy数组有五种方法（[来源](https://numpy.org/doc/stable/user/basics.creation.html)）。以下是一些补充上述示例的示例。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Another option for storing a homogeneous collection of elements in Python is
    a [`Series` object](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html#pandas-series)
    from the Pandas library. The benefit of these is that they play nicely with Pandas’
    data frames (more information about Pandas’ data frames can be found in [8.2](/data-frames#data-frames-in-python)),
    and that they have more flexibility with accessing elements by name ( see [here](https://jakevdp.github.io/PythonDataScienceHandbook/03.01-introducing-pandas-objects.html#Series-as-generalized-NumPy-array)
    for more information ).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中存储同质元素集合的另一种选择是来自Pandas库的`Series`对象。这些的优点是它们与Pandas的数据框配合得很好（有关Pandas数据框的更多信息，请参阅[8.2](/data-frames#data-frames-in-python)），并且它们在通过名称访问元素方面具有更大的灵活性（更多信息请参阅[这里](https://jakevdp.github.io/PythonDataScienceHandbook/03.01-introducing-pandas-objects.html#Series-as-generalized-NumPy-array)）。
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 3.3 Vectorization in R
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 R中的向量化
- en: An operation in R is **vectorized** if it applies to all of the elements of
    a `vector` at once. An operator that is not vectorized can only be applied to
    individual elements. In that case, the programmer would need to write more code
    to instruct the function to be applied to all of the elements of a vector. You
    should prefer writing vectorized code because it is usually easier to read. Moreover,
    many of these vectorized functions are written in compiled code, so they can often
    be much faster.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: R中的操作如果是**向量化**的，那么它将一次性应用于`向量`的所有元素。未向量的操作符只能应用于单个元素。在这种情况下，程序员需要编写更多的代码来指示函数应用于向量的所有元素。你应该优先编写向量化代码，因为它通常更容易阅读。此外，许多这些向量化函数是用编译代码编写的，因此它们通常要快得多。
- en: Arithmetic (e.g. `+`, `-`, `*`, `/`, `^`, `%%`, `%/%`, etc.) and logical (e.g. `!`,
    `|`, `&`, `>`, `>=`, `<`, `<=`, `==`, etc.) operators are commonly applied to
    one or two vectors. Arithmetic is usually performed *element-by-element*. Numeric
    vectors are converted to logical vectors if they need to be. Be careful of operator
    precedence if you seek to minimize your use of parentheses.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符（例如`+`、`-`、`*`、`/`、`^`、`%%`、`%/%`等）和逻辑运算符（例如`!`、`|`、`&`、`>`、`>=`、`<`、`<=`、`==`等）通常应用于一个或两个向量。算术运算通常是*逐元素*执行的。如果需要，数值向量会被转换为逻辑向量。如果你试图最小化括号的使用，请注意运算符的优先级。
- en: Note that there are an extraordinary amount of named functions (e.g. `sum()`,
    `length()`, `cumsum()`, etc.) that operate on entire `vector`s, as well. Here
    are some examples.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，还有大量以名称命名的函数（例如`sum()`、`length()`、`cumsum()`等）也作用于整个`向量`。以下是一些示例。
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the last example, there is **recycling** happening. `(2*pi/3)` is taking
    three length-one vectors and producing another length-one vector. The resulting
    length-one vector is multiplied by a length four vector `1:4`. The single element
    in the length one vector gets *recycled* so that its value is multiplied by every
    element of `1:4`. This makes sense most of the time, but sometimes recycling can
    be tricky. Notice that the following code does not produce an error–just a warning:
    `longer object length is not a multiple of shorter object length`. Try running
    it on your machine to confirm this.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个例子中，发生了**循环使用**。`(2*pi/3)`正在处理三个长度为1的向量，并产生另一个长度为1的向量。结果长度为1的向量被乘以长度为四的向量`1:4`。长度为1的向量中的单个元素被*循环使用*，使其值乘以`1:4`中的每个元素。这在大多数情况下是有意义的，但有时循环使用可能会很棘手。请注意，以下代码不会产生错误——只是一个警告：“较长的对象长度不是较短对象长度的倍数”。尝试在您的机器上运行它以确认这一点。
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 3.4 Vectorization in Python
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 Python中的向量化
- en: The Python’s Numpy library makes extensive use of vectorization as well. Vectorization
    in Numpy is accomplished with [**universal functions**](https://numpy.org/doc/stable/reference/ufuncs.html),
    or “ufuncs” for short. Some ufuncs can be invoked using the same syntax as in
    R (e.g. `+`). You can also refer to function by its name (e.g. `np.sum()` instead
    of `+`). Mixing and matching is allowed, too.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 Numpy 库也广泛使用了向量化。Numpy 中的向量化是通过 [**通用函数**](https://numpy.org/doc/stable/reference/ufuncs.html)
    或简称为 “ufuncs” 来实现的。一些 ufunc 可以使用与 R 相同的语法调用（例如 `+`）。你也可以通过其名称来引用函数（例如 `np.sum()`
    而不是 `+`）。混合和匹配也是允许的。
- en: Ufuncs are called *unary* if they take in one array, and *binary* if they take
    in two. At the moment, there are [fewer than \(100\) available](https://numpy.org/doc/stable/reference/ufuncs.html#available-ufuncs),
    all performing either mathematical operations, boolean-emitting comparisons, or
    bit-twiddling operations. For an exhaustive list of Numpy’s universal functions,
    [click here.](https://numpy.org/doc/stable/reference/ufuncs.html#available-ufuncs)
    Here are some code examples.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Ufuncs 只接受一个数组时，它们被称为 *一元*，如果它们接受两个数组，则称为 *二元*。目前，有 [不到 100 个可用](https://numpy.org/doc/stable/reference/ufuncs.html#available-ufuncs)，所有这些都执行数学运算、布尔输出比较或位操作。有关
    Numpy 的通用函数的完整列表，[请点击此处](https://numpy.org/doc/stable/reference/ufuncs.html#available-ufuncs)。以下是一些代码示例。
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Instead of calling it “recycling”, Numpy calls reusing elements of a shorter
    array in a binary operation [**broadcasting**](https://numpy.org/devdocs/user/theory.broadcasting.html).
    It’s the same idea as in R, but in general, Python is stricter and disallows more
    scenarios. For example, try running the following code on your machine. You should
    receive an error: `ValueError: operands could not be broadcast together with shapes
    (2,) (3,)`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '与其称为“回收”，Numpy 将在二元操作中重用较短数组的元素称为 [**广播**](https://numpy.org/devdocs/user/theory.broadcasting.html)。这与
    R 中的想法相同，但通常 Python 更严格，不允许更多场景。例如，尝试在你的机器上运行以下代码。你应该会收到一个错误：`ValueError: operands
    could not be broadcast together with shapes (2,) (3,)`。'
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you are working with string arrays, Numpy has a [`np.char` module with many
    useful functions](https://numpy.org/doc/stable/reference/routines.char.html#module-numpy.char).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理字符串数组，Numpy 有一个包含许多有用函数的 `np.char` 模块](https://numpy.org/doc/stable/reference/routines.char.html#module-numpy.char)。
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then there are the `Series` objects from Pandas. Ufuncs continue to work in
    the same way on `Series` objects, and they [respect common index values](https://jakevdp.github.io/PythonDataScienceHandbook/03.03-operations-in-pandas.html).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是来自 Pandas 的 `Series` 对象。Ufuncs 在 `Series` 对象上继续以相同的方式工作，并且它们 [尊重共同的索引值](https://jakevdp.github.io/PythonDataScienceHandbook/03.03-operations-in-pandas.html)。
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you feel more comfortable, and you want to coerce these `Series` objects
    to Numpy arrays before working with them, you can do that. For example, the following
    works.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感觉更舒适，并且你希望在处理这些 `Series` 对象之前将它们强制转换为 Numpy 数组，你可以这样做。例如，以下操作是可行的。
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In addition, `Series` objects possess many extra [attributes and methods](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html#pandas-series).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Series` 对象还具有许多额外的 [属性和方法](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html#pandas-series)。
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`Series` objects that have [text data](https://pandas.pydata.org/pandas-docs/stable/user_guide/text.html#working-with-text-data)
    are a little bit different. For one, you have to access the `.str` attribute of
    the `Series` before calling any [vectorized methods](https://jakevdp.github.io/PythonDataScienceHandbook/03.10-working-with-strings.html).
    Here are some examples.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 具有文本数据的 `Series` 对象略有不同。首先，在调用任何 [向量化方法](https://jakevdp.github.io/PythonDataScienceHandbook/03.10-working-with-strings.html)
    之前，你必须访问 `Series` 的 `.str` 属性。以下是一些示例。
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: String operations can be a big game changer, and we discuss text processing
    strategies in more detail in section [3.9](/r-vectors-versus-numpy-arrays-and-pandas-series#an-introduction-to-regular-expressions).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串操作可以是一个很大的变革，我们在第 [3.9](/r-vectors-versus-numpy-arrays-and-pandas-series#an-introduction-to-regular-expressions)
    节中更详细地讨论了文本处理策略。
- en: 3.5 Indexing Vectors in R
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 在 R 中索引向量
- en: It is very common to want to extract or modify a subset of elements in a vector.
    There are a few ways to do this. All of the ways I discuss will involve the square
    bracket operator (i.e. `[]`). Feel free to retrieve the documentation by typing
    `?'['`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见的是想要从向量中提取或修改一个子集的元素。我讨论的所有方法都将涉及方括号运算符（即 `[]`）。你可以通过输入 `?'['` 来检索文档。
- en: '[PRE17]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To access the first element, we use the index `1`. To access the second, we
    use `2`, and so on. Also, the `-` sign tells R to remove elements. Both of these
    functionalities are *very different* from Python, as we will see shortly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问第一个元素，我们使用索引 `1`。要访问第二个，我们使用 `2`，依此类推。此外，`-` 符号告诉 R 删除元素。这两个功能与 Python 非常不同，我们很快就会看到。
- en: We can use names to access elements elements, too, but only if the elements
    are named.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用名称来访问元素，但前提是这些元素必须有名称。
- en: '[PRE18]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 3.6 Indexing Numpy arrays
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 索引 Numpy 数组
- en: '[Indexing Numpy arrays](https://numpy.org/doc/stable/user/basics.indexing.html)
    is very similar to indexing vectors in R. You use the square brackets, and you
    can do it with logical arrays or index arrays. There are some important differences,
    though.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[索引 Numpy 数组](https://numpy.org/doc/stable/user/basics.indexing.html)与 R 中的向量索引非常相似。你使用方括号，可以使用逻辑数组或索引数组来完成。尽管如此，还有一些重要的区别。'
- en: For one, indexing is 0-based in Python. The `0`th element is the first element
    of an array. Another key difference is that the `-` isn’t used to remove elements
    like it is in R, but rather to count backwards. Third, using one or two `:` inside
    square brackets is more flexible in Python. This is syntactic sugar for using
    the `slice()` function, which is similar to R’s `seq()` function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Python 中的索引是从 0 开始的。`0` 索引是数组的第一个元素。另一个关键的区别是，Python 中不使用 `-` 来删除元素，就像 R
    中那样，而是用来倒计数。第三，在方括号内使用一个或两个 `:` 在 Python 中更加灵活。这是使用 `slice()` 函数的语法糖，它类似于 R 中的
    `seq()` 函数。
- en: '[PRE19]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 3.7 Indexing Pandas’ Series
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7 索引 Pandas 的 Series
- en: At a minimum, there is little that is new that you *need* to learn to go from
    Numpy arrays to Pandas’ Series objects. They still have the `[]` operator, and
    [many methods are shared across these two types](https://pandas.pydata.org/docs/reference/api/pandas.Series.html).
    The following is almost equivalent to the code above, and the only apparent difference
    is that the results are printed a little differently.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，从 Numpy 数组到 Pandas 的 Series 对象，你需要学习的新内容很少。它们仍然有 `[]` 操作符，并且 [这两个类型之间共享许多方法](https://pandas.pydata.org/docs/reference/api/pandas.Series.html)。以下代码几乎等同于上面的代码，唯一的明显区别是结果打印的方式略有不同。
- en: '[PRE20]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: However, [Pandas’ Series have `.loc` and `.iloc` methods](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#different-choices-for-indexing).
    We won’t talk much about these two methods now, but they will become very important
    when we start to discuss Pandas’ data frames in section [8.2](/data-frames#data-frames-in-python).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，[Pandas 的 Series 有 `.loc` 和 `.iloc` 方法](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#different-choices-for-indexing)。我们现在不会过多地讨论这两个方法，但当我们开始讨论第
    8.2 节中的 Pandas 数据框时，它们将变得非常重要。
- en: '[PRE21]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 3.8 Some Gotchas
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.8 一些注意事项
- en: 3.8.1 Shallow versus Deep Copies
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.8.1 浅拷贝与深拷贝
- en: In R, assignment usually produces a **deep copy.** In the code below, we create
    `b` from `a`. If we modify `b`, these changes don’t affect `a`. This takes up
    more memory, but our program is easier to follow as we don’t have to keep track
    of connections between objects.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，赋值通常会产生一个**深拷贝**。在下面的代码中，我们从 `a` 创建了 `b`。如果我们修改 `b`，这些更改不会影响 `a`。这会占用更多的内存，但我们的程序更容易理解，因为我们不需要跟踪对象之间的连接。
- en: '[PRE22]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With Numpy arrays in Python, [“shallow copies” can be created by simple assignment,
    or by explicitly constructing a **view**](https://numpy.org/devdocs/user/quickstart.html#copies-and-views).
    In the code below, `a`, `b`, `c`, and `d` all share the same data. If you modify
    one, you change all the others. This can make the program more confusing, but
    on the other hand, it can also improve computational efficiency.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 的 Numpy 数组中，可以通过简单的赋值或显式构造一个**视图**来创建“浅拷贝”（[更多信息](https://numpy.org/devdocs/user/quickstart.html#copies-and-views)）。在下面的代码中，`a`、`b`、`c`
    和 `d` 都共享相同的数据。如果你修改其中一个，其他所有数据也会改变。这可能会使程序更复杂，但另一方面，它也可以提高计算效率。
- en: '[PRE23]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It’s the same story with Pandas’ Series objects. You’re usually making a “shallow”
    copy.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 的 Series 对象也是同样的情况。你通常是在创建一个“浅拷贝”。
- en: '[PRE24]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you want a “deep copy” in Python, you usually want a function or method called
    `copy()`. Use `np.copy` or [`np.ndarray.copy`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.copy.html#numpy-ndarray-copy)
    when you have a Numpy array.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在 Python 中创建“深拷贝”，通常需要一个名为 `copy()` 的函数或方法。当你有一个 Numpy 数组时，使用 `np.copy`
    或 `np.ndarray.copy`（[更多详情](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.copy.html#numpy-ndarray-copy)）。
- en: '[PRE25]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Use [`pandas.Series.copy`](https://pandas.pydata.org/docs/reference/api/pandas.Series.copy.html#pandas-series-copy)
    with Pandas’ Series objects. Make sure not to set the `deep` argument to `False`.
    Otherwise you’ll get a shallow copy.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Pandas 的 Series 对象的 `pandas.Series.copy`。确保不要将 `deep` 参数设置为 `False`。否则，你会得到一个浅拷贝。
- en: '[PRE26]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 3.8.2 How R and Python Handle Missing Values
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.8.2 R 和 Python 处理缺失值的方式
- en: R has `NULL`, `NaN`, and `NA`. Python has `None` and `np.nan`. If your eyes
    are glazing over already and you’re thinking “they all look like the same”–they
    are not.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: R 有 `NULL`、`NaN` 和 `NA`。Python 有 `None` 和 `np.nan`。如果你的眼睛已经开始发花，并且你正在想“它们看起来都一样”——它们并不一样。
- en: R’s `NULL` and Python’s `None` are similar. Both represent “nothingness.” This
    is *not* the same as `0`, or an empty string, or `FALSE`/`False`. This is commonly
    used to detect if a user fails to pass in an argument to a function, or if a function
    fails to “return” (more information on functions can be found in section [6](/functions#functions))
    anything meaningful.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: R 的 `NULL` 和 Python 的 `None` 类似。两者都代表“无”。这不同于 `0`，空字符串，或 `FALSE`/`False`。这通常用于检测用户是否未能向函数传递参数，或者函数是否未能“返回”任何有意义的内容（更多关于函数的信息可以在第
    [6](/functions#functions) 节中找到）。
- en: In R, for example, if a function fails to return anything, then it actually
    returns a `NULL`. [A `NULL` object has its own type.](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#NULL-object)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 R 中，如果一个函数未能返回任何内容，那么它实际上返回一个 `NULL`。[一个 `NULL` 对象有其自己的类型。](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#NULL-object)
- en: '[PRE27]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In Python, we have the following.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们有以下内容。
- en: '[PRE28]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: “NaN” stands for “not a number.” `NaN` is an object of type `double` in R, and
    `np.nan` is of type `float` in Python. It can come in handy when you (deliberately
    or accidentally) perform undefined calculations such as \(0/0\) or \(\infty /
    -\infty\).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: “NaN”代表“不是一个数字”。“NaN”在 R 中是类型为“double”的对象，而在 Python 中“np.nan”是类型为“float”。当你在（故意或意外地）执行未定义的计算，例如
    \(0/0\) 或 \(\infty / -\infty\) 时，它可能会很有用。
- en: '[PRE29]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: “NA” is short for “not available.” Missing data is a fact of life in data science.
    Observations are often missing in data sets, introduced after joining/merging
    data sets together (more on this in section [12.3](/reshaping-and-combining-data-sets#merging-or-joining-data-sets)),
    or arise from calculations involving underflow and overflow. There are many techniques
    designed to estimate quantities in the presence of missing data. When you code
    them up, you’ll need to make sure you deal with `NA`s properly.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: “NA”代表“不可用”。“在数据科学中，缺失数据是生活中的一件事。观察值经常在数据集中缺失，这可能是由于在将数据集合并/合并后引入的（更多关于这一点可以在第
    [12.3](/reshaping-and-combining-data-sets#merging-or-joining-data-sets) 节中找到），或者是由涉及下溢和上溢的计算引起的。有许多技术旨在估计缺失数据的存在。当你编写代码时，你需要确保你正确地处理了
    `NA`s。
- en: '[PRE31]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Unfortunately, Python’s support of an `NA`-like object is more limited. There
    is no `NA` object in base Python. And often `NaN`s will appear in place of an
    `NA`. There are a few useful tools, though. The Numpy library offers [“masked
    arrays”](https://numpy.org/devdocs/reference/maskedarray.html), for instance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Python 对类似 `NA` 的对象的支持更为有限。在基础 Python 中没有 `NA` 对象。并且通常 `NaN`s 会出现在 `NA`
    的位置。尽管如此，也有一些有用的工具。例如，Numpy 库提供了[“掩码数组”](https://numpy.org/devdocs/reference/maskedarray.html)。
- en: Also, as of version `1.0.0`, the [pandas library](https://pandas.pydata.org/docs/user_guide/index.html#user-guide)
    has an experimental `pd.NA` object. However, they [warn](https://pandas.pydata.org/pandas-docs/dev/user_guide/missing_data.html#missing-data-na)
    that “the behaviour of `pd.NA` can still change without warning.”
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，截至版本 `1.0.0`，[pandas 库](https://pandas.pydata.org/docs/user_guide/index.html#user-guide)
    有一个实验性的 `pd.NA` 对象。然而，他们 [警告](https://pandas.pydata.org/pandas-docs/dev/user_guide/missing_data.html#missing-data-na)
    “`pd.NA` 的行为可能会在没有警告的情况下改变。”
- en: '[PRE32]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Be careful of using extreme values to stand in for what should be an `NA`. Be
    aware that some data providers will follow this strategy. I recommend that you
    avoid it yourself. Failing to represent a missing value correctly would lead to
    extremely wrong calculations!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用极端值来代替应该是一个 `NA` 的值。请注意，一些数据提供者会遵循这种策略。我建议你自己避免这样做。未能正确表示缺失值会导致极其错误的计算！
- en: 3.9 An Introduction to Regular Expressions
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.9 正则表达式简介
- en: We have already talked a little about how to work with text data in this book.
    Regarding Python, section [3.4](/r-vectors-versus-numpy-arrays-and-pandas-series#vectorization-in-python)
    mentioned that Pandas `Series` objects have a [`.str` accessor attribute](https://pandas.pydata.org/pandas-docs/version/1.3/user_guide/text.html#string-methods)
    that has plenty of special methods that will work on string data. The same tools
    can be used whether or not these `Series` objects are contained in a Pandas `DataFrame`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中已经简要地讨论了如何处理文本数据。关于Python，第[3.4](/r-vectors-versus-numpy-arrays-and-pandas-series#vectorization-in-python)节提到，Pandas
    `Series`对象有一个[`.str`访问器属性](https://pandas.pydata.org/pandas-docs/version/1.3/user_guide/text.html#string-methods)，它包含许多专门用于字符串数据的方法。无论这些`Series`对象是否包含在Pandas
    `DataFrame`中，都可以使用相同的工具。
- en: Regarding R, `character` `vector`s were first mentioned in section [3.1](/r-vectors-versus-numpy-arrays-and-pandas-series#overview-of-r).
    There are many functions that operate on these, too, regardless of whether they
    are held in a `data.frame`. The functions might be a little harder to find because
    they aren’t methods, so pressing `<Tab>` and using your GUI’s autocomplete feature
    doesn’t reveal them as easily.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 关于R，`character` `vector`s首次在第[3.1](/r-vectors-versus-numpy-arrays-and-pandas-series#overview-of-r)节中提到。对这些操作也有很多函数，无论它们是否存储在`data.frame`中。这些函数可能更难找到，因为它们不是方法，所以按
    `<Tab>` 键并使用GUI的自动完成功能并不容易揭示它们。
- en: Suppose you’re interested in replacing lowercase letters with uppercase ones,
    removing certain characters from text, or counting the number of times a certain
    expression appears. Up until now, as long as you can find a function or method
    that performs the task, you were doing just fine. If you need to do something
    with text data, there’s probably a function for it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你感兴趣的是将小写字母替换为大写字母，从文本中删除某些字符，或者计算某个表达式出现的次数。到目前为止，只要你能找到一个执行该任务的函数或方法，你就做得很好。如果你需要对文本数据进行操作，可能有一个函数可以做到这一点。
- en: Notice what all of these tasks have in common–they all require the ability to
    find patterns. When your patterns are easy to describe (e.g. find all lowercase
    “a”s), then all is well. What can make matters more complicated, however, is when
    the patterns are more difficult to describe (e.g. find all valid email addresses).
    That is why this section is primarily concerned with discussing **regular expressions,**
    which are a tool that help you describe the patterns in text (Wickham and Grolemund
    [2017](#ref-rfords)) (López [2014](#ref-pythonregexprs)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意所有这些任务有什么共同点——它们都需要找到模式的能力。当你的模式容易描述时（例如，找到所有小写的“a”），一切都很顺利。然而，当模式更难描述时（例如，找到所有有效的电子邮件地址），事情可能会变得更复杂。这就是为什么本节主要关注讨论**正则表达式**，这是一种帮助你描述文本中模式的工具（Wickham和Grolemund
    [2017](#ref-rfords)) (López [2014](#ref-pythonregexprs))。
- en: 3.9.1 Literal Characters versus Metacharacters
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.9.1 文字字符与元字符
- en: Every character in a regular expression is interpreted in one of two ways. Either
    it is interpreted as a
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式中的每个字符都以两种方式之一进行解释。要么它被解释为一个
- en: literal character, or as a
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文字字符，或者作为一个
- en: metacharacter.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 元字符。
- en: If it is a literal character, then the character is the *literal* pattern. For
    example, in the regular expression “e”, the character “e” has a literal interpretation.
    If you seek to capitalize all instances of “e” in the following phrase, you can
    do it pretty easily. As long as you know which function performs find-and-replace,
    you’re good. The pattern is trivial to specify.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是一个文字字符，那么该字符就是*文字*模式。例如，在正则表达式“e”中，字符“e”有一个文字解释。如果你想要在以下短语中找到所有“e”的大写形式，你可以很容易地做到。只要你知道哪个函数执行查找和替换，你就没问题。模式很容易指定。
- en: On the other hand, if I asked you to remove `$`s from price or salary data,
    you might have a little more difficulty. This is because `$` is a *metacharacter*
    in regular expressions, and so it has a special meaning.[⁶](#fn6) In the examples
    below, if `$` is interpreted as a regular expression, the pattern will not be
    found at all, despite the prevalence of *literal* dollar signs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你让我从价格或薪资数据中删除`$`符号，你可能会有点困难。这是因为`$`是正则表达式中的一个*元字符*，因此它有特殊的意义。[⁶](#fn6)
    在下面的例子中，如果`$`被解释为正则表达式，那么模式将根本找不到，尽管文字美元符号很常见。
- en: There are a few functions in R that perform find-and-replace, but in this case,
    I use `gsub()`. In Pandas, I can use [`.str.replace()`](https://pandas.pydata.org/docs/reference/api/pandas.Series.str.replace.html),
    to do this. Here are the examples that find patterns that are described by literal
    characters.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: R 中有一些函数执行查找和替换，但在这个情况下，我使用 `gsub()`。在 Pandas 中，我可以使用 [`.str.replace()`](https://pandas.pydata.org/docs/reference/api/pandas.Series.str.replace.html)
    来做这个。以下是一些通过文字字符描述模式的示例。
- en: '[PRE33]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: On the other hand, here are a few examples that remove dollar signs. We generally
    have two options to recognize symbols that happen to be metacharacters.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这里有一些移除美元符号的示例。我们通常有两种方法来识别恰好是元字符的符号。
- en: We can *escape* the dollar sign. That means you need to put a backslash (i.e. `\`)
    before the dollar sign. The backslash is a metacharacter looks at the character
    coming after it, and it either removes the special meaning from a metacharacter,
    or adds special meaning to a literal character.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以**转义**美元符号。这意味着你需要在美元符号前加上一个反斜杠（即 `\`）。反斜杠是一个元字符，它会查看其后的字符，要么从元字符中移除特殊含义，要么给文字字符添加特殊含义。
- en: Alternatively, we can tell the function to ignore regular expressions. `gsub()`
    can take `fixed=TRUE`, and `.str.replace()` can take `regex=False`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，我们可以告诉函数忽略正则表达式。`gsub()` 可以接受 `fixed=TRUE`，而 `.str.replace()` 可以接受 `regex=False`。
- en: '[PRE35]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '3.9.2 The Trouble With Backslashes: Escape Sequences'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.9.2 反斜杠的麻烦：转义序列
- en: You might have noticed above and gotten confused–sometimes in Python and in
    R, we need *two* backslashes instead of *one*. This is because backslashes have
    another purpose that can complicate our using them to escape metacharacters. They
    also help us write untypeable characters, also known as **escape sequences**.
    We need to be able to do this even if we aren’t using regular expressions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了并感到困惑——有时在 Python 和 R 中，我们需要**两个**反斜杠而不是**一个**。这是因为反斜杠还有一个可以让我们使用它们来转义元字符的用途。它们还帮助我们编写不可打印的字符，也称为**转义序列**。即使我们不使用正则表达式，我们也需要能够这样做。
- en: For instance, consider the way we type the “newline” character. Even though
    it is understood by the computer as one character, it takes us two keystrokes
    to write it with our keyboard. `\` is one character, and `n` is another, but together
    they are one!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑我们输入“换行符”的方式。尽管计算机将其理解为一个字符，但我们需要用键盘敲击两个键才能写出它。`\` 是一个字符，而 `n` 是另一个，但它们合在一起才是一个字符！
- en: '[PRE37]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`str`s in Python and `character` `vectors` in R will look for these combinations
    by default. When we specify regular expressions with strings, the backslashes
    will be used first for this purpose. Their regular expression purpose is a second
    priority.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的 `str` 和 R 中的 `character` 向量会默认查找这些组合。当我们用字符串指定正则表达式时，反斜杠将首先用于此目的。它们的正则表达式用途是第二优先级。
- en: The reason we used `\\$` in the above example is to escape the second backslash.
    `\$` is not a special character, but Python and R will handle it differently.
    Python will not recognize it, and it won’t complain that it didn’t. On the other
    hand, R will throw an error that it can’t recognize it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上面的例子中使用 `\\$` 的原因是为了转义第二个反斜杠。`$` 不是一个特殊字符，但 Python 和 R 会以不同的方式处理它。Python
    不会识别它，也不会抱怨它没有识别。另一方面，R 会抛出一个错误，表明它无法识别它。
- en: '[PRE39]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There is another way to deal with this issue–**raw strings!** Raw strings make
    life easier because they do not interpret backslashes as the beginning of escape
    sequences. You can make them in R and Python by putting an “r” in front of the
    quotation marks. However, it is slightly more complicated in R because you need
    a delimiter pair inside the quotation marks–for more information type `?Quotes`
    in your R console.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的另一种方法是使用**原始字符串**！原始字符串让生活变得更简单，因为它们不会将反斜杠解释为转义序列的开始。你可以在 R 和 Python
    中通过在引号前加上“r”来创建它们。然而，在 R 中这稍微复杂一些，因为你需要在引号内使用分隔符对——更多信息可以在你的 R 控制台中输入 `?Quotes`。
- en: '[PRE41]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 3.9.3 More Examples of Using Regular Expressions
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.9.3 使用正则表达式的更多示例
- en: Regular expressions that match many different types of characters are often
    very useful–these are called **character classes.** For example, `.` represents
    any character except a newline, `\d` represents any digit, and `\s` represents
    any whitespace character. You can sometimes capitalize the letters in the regular
    expression to get the opposite pattern.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配许多不同类型字符的正则表达式通常非常有用——这些被称为**字符类**。例如，`.` 表示除换行符之外的任何字符，`\d` 表示任何数字，而 `\s`
    表示任何空白字符。你有时可以通过将正则表达式中的字母大写来得到相反的模式。
- en: '[PRE43]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Many character classes feature an opening and closing square brackets. For instance,
    `[1-5]` matches any digit between \(1\) and \(5\) (inclusive), `[aeiouy]` matches
    any lowercase vowel, and `[\^\-]` matches either `^` or `-` (we had to escape
    these two metacharacters because we are only interested in the literal pattern).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 许多字符类都有一个开方括号和闭方括号。例如，`[1-5]` 匹配 \(1\) 到 \(5\) 之间的任何数字（包括），`[aeiouy]` 匹配任何小写元音，而
    `[\^\-]` 匹配 `^` 或 `-`（我们不得不转义这两个元字符，因为我们只对字面模式感兴趣）。
- en: '[PRE45]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Concatenating two patterns, one after another, forms a more specific pattern
    to be matched.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个模式一个接一个地连接起来，形成一个更具体的匹配模式。
- en: '[PRE46]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If you would like one pattern or another to appear, you can use the **alternation
    operator** `|`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望出现某个模式或另一个模式，可以使用**交替运算符** `|`。
- en: '[PRE47]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In addition to concatenation, alternation, and grouping, there are more general
    ways to *quantify* how many times the desired pattern will appear. `?` means zero
    or one time, `*` means zero or more, `+` will mean one or more, and there are
    a variety of ways to be even more specific with curly braces (e.g. `{3,17}` means
    anywhere from three to seventeen times).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 除了连接、交替和分组之外，还有更多通用的方法来*量化*所需模式出现的次数。`?` 表示零次或一次，`*` 表示零次或多次，`+` 表示一次或多次，还有多种方法可以通过花括号（例如
    `{3,17}`）来更加具体地指定（表示从三次到十七次）。
- en: '[PRE48]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Notice in the double “o” example, the word with three matched. To describe that
    not being desirable requires the ability to *look ahead* of the match, to the
    next character, and evaluate that. You can look ahead, or behind, and make assertions
    about what patterns are required or disallowed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在双“o”的例子中，有三个匹配的单词。要描述这不是所希望的，需要能够**向前查看**匹配，到下一个字符，并评估它。你可以向前查看或向后查看，并对所需的或禁止的模式做出断言。
- en: '| Lookaround Regex | Meaning |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 向前查看正则表达式 | 含义 |'
- en: '| --- | --- |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `(?=pattern)` | Positive looking ahead for `pattern` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `(?=pattern)` | 向前查找 `pattern` 的正向前瞻 |'
- en: '| `(?!pattern)` | Negative looking ahead for `pattern` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `(?!pattern)` | 向前查找 `pattern` 的负向前瞻 |'
- en: '| `(?<=pattern)` | Positive looking behind for `pattern` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `(?<=pattern)` | 向后查找 `pattern` 的正向前瞻 |'
- en: '| `(?<!pattern)` | Negative looking behind for `pattern` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `(?<!pattern)` | 向后查找 `pattern` 的负向后瞻 |'
- en: After `oo` we specify `(?!o)` to disallow a third, trailing `o`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `oo` 后面我们指定 `(?!o)` 以禁止第三个尾随的 `o`。
- en: '[PRE50]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: However, this does not successfully remove `"hellooo"` because it will match
    on the *last* two “o”s of the word. To prevent this, we can prepend a `(?<!o)`,
    which disallows a leading “o”, as well. In R, we also have to specify `perl=TRUE`
    to use Perl-compatible regular expressions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不能成功移除 `"hellooo"`，因为它会在单词的最后两个“o”上匹配。为了防止这种情况，我们可以在前面添加一个 `(?<!o)`，这样也就不允许以“o”开头了。在
    R 中，我们还需要指定 `perl=TRUE` 来使用与 Perl 兼容的正则表达式。
- en: '[PRE51]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We also mention *anchoring.* If you only want to find a pattern at the beginning
    of text, use `^`. If you only want to find a pattern at the end of text, use `$`.
    Below we use [`.str.extract()`](https://pandas.pydata.org/docs/reference/api/pandas.Series.str.extract.html),
    whose documentation makes reference to *capture groups.* Capture groups are just
    regular expressions grouped inside parentheses (e.g. `(this)`).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提到了**锚定**。如果你只想在文本的开头找到模式，请使用 `^`。如果你只想在文本的末尾找到模式，请使用 `$`。下面我们使用了 [`.str.extract()`](https://pandas.pydata.org/docs/reference/api/pandas.Series.str.extract.html)，其文档提到了*捕获组*。捕获组只是括号内的正则表达式（例如
    `(this)`）。
- en: '[PRE52]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 3.10 Exercises
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.10 练习
- en: 3.10.1 R Questions
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.10.1 R 问题
- en: Let’s flip some coins! Generate a thousand flips of a fair coin. Use `rbinom`,
    and let heads be coded as `1` and tails coded as `0`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们抛一些硬币！生成一千次公平硬币的翻转。使用 `rbinom`，将正面编码为 `1`，反面编码为 `0`。
- en: Assign the thousand raw coin flips to a variable `flips`. Make sure the elements
    are integers, and make sure you flip a “fair” coin (\(p=.5\)).
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一千次原始的硬币翻转赋值给变量 `flips`。确保元素是整数，并且确保你翻转的是“公平”的硬币（\(p=.5\)）。
- en: Create a length `1000` `logical` `vector` called `isHeads`. Whenever you get
    a heads, make sure the corresponding element is `TRUE` and `FALSE` otherwise.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个长度为 `1000` 的 `logical` 向量 `isHeads`。每次得到正面时，确保相应的元素是 `TRUE`，否则是 `FALSE`。
- en: Create a variable called `numHeads` by tallying up the number of heads.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过计数正面来创建一个变量 `numHeads`。
- en: Calculate the percent of time that the number changes in `flips`. Assign your
    number to `acceptanceRate`. Try to write only one line of code to do this.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算在 `flips` 中数字变化的百分比。将你的数字赋值给 `acceptanceRate`。尽量用一行代码来完成这个操作。
- en: Compute the elements of the tenth order Taylor approximation to \(\exp(3)\)
    and store them in `taylorElems`. Do not sum them. Use only one expression, and
    do not use any loop. The approximation is,
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 计算第十阶泰勒展开到\(\exp(3)\)的元素，并将它们存储在`taylorElems`中。不要求和。使用一个表达式，不要使用任何循环。近似为，
- en: \[ 1 + 3 + 3^2/2! + 3^3/3! + \cdots 3^{10}/10! \] You want to store each of
    those eleven numbers separately in a `numeric` `vector`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: \[ 1 + 3 + 3^2/2! + 3^3/3! + \cdots 3^{10}/10! \] 你希望将这十一个数分别存储在一个`numeric`向量中。
- en: Do the following.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作。
- en: Create a vector called `nums` that contains all consecutive integers from \(-100\)
    to \(100\).
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`nums`的向量，包含从\(-100\)到\(100\)的所有连续整数。
- en: Create a `logical` `vector` that has the same length as the above, and contains
    `TRUE` whenever an element of the above is even, and `FALSE` otherwise. Call it
    `myLogicals`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与上面相同长度的`logical`向量，当上面的元素为偶数时包含`TRUE`，否则为`FALSE`。命名为`myLogicals`。
- en: Assign the total number of `TRUE`s to `totalEven`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`TRUE`的总数分配给`totalEven`。
- en: Create a `vector` called `evens` of all even numbers from the above `vector`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`evens`的向量，包含上面向量中的所有偶数。
- en: Create a `vector` called `reverse` that holds the reversed elements of `nums`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`reverse`的向量，包含`nums`的逆序元素。
- en: Let’s say we wanted to calculate the following sum \(\sum_{i=1}^N x_i\). If
    \(N\) is large, or most of the \(x_i\)s are large, then we might bump up against
    the largest allowable number. This is the problem of *overflow*. The biggest integer
    and biggest floating point can be recovered by typing `.Machine$integer.max` and
    `.Machine$double.xmax`, respectively.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要计算以下和 \(\sum_{i=1}^N x_i\)。如果\(N\)很大，或者大多数的\(x_i\)很大，那么我们可能会遇到允许的最大数字。这是**溢出**的问题。最大的整数和最大的浮点数可以通过输入`.Machine$integer.max`和`.Machine$double.xmax`分别恢复。
- en: Assign `sumThese` to `exp(rep(1000,10))`. Are they finite? Can you sum them?
    If everything is all good, assign `TRUE` to `allGood`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`sumThese`分配给`exp(rep(1000,10))`。它们是有限的吗？你能将它们相加吗？如果一切顺利，将`TRUE`分配给`allGood`。
- en: Theoretically, is the logarithm of the sum less than `.Machine$double.xmax`?
    Assign `TRUE` or `FALSE` to `noOverflowIssue`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从理论上讲，和的对数小于`.Machine$double.xmax`吗？将`TRUE`或`FALSE`分配给`noOverflowIssue`。
- en: Assign the *naive* log-sum of these to `naiveLogSum`. Is the naive log sum finite?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些的**朴素**对数和分配给`naiveLogSum`。朴素的对数和是有限的吗？
- en: 'Compute `betterSum`, one that doesn’t overflow, using the *log-sum-exp* trick:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用对数和指数技巧计算`betterSum`，一个不会溢出的和：
- en: \[ \log\left( \sum_{i=1}^{10} x_i \right) = \log\left( \sum_{i=1}^{10} \exp[
    \log(x_i) - m] \right) + m \] \(m\) is usually chosen to be \(\max_i \log x_i\).
    This is the same formula as above, which is nice. You can use the same code to
    combat both overflow and underflow. e) If you’re writing code, and you have a
    bunch of very large numbers, is it better to store those numbers, or store the
    logarithm of those numbers? Assign your answer to `whichBetter`. Use either the
    phrase `"logs"` or `"nologs"`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \log\left( \sum_{i=1}^{10} x_i \right) = \log\left( \sum_{i=1}^{10} \exp[
    \log(x_i) - m] \right) + m \] \(m\)通常选择为\(\max_i \log x_i\)。这与上面的公式相同，这很好。你可以使用相同的代码来对抗溢出和下溢。e)
    如果你在编写代码，并且有一堆非常大的数字，是存储这些数字更好，还是存储这些数字的对数更好？将你的答案分配给`whichBetter`。使用短语`"logs"`或`"nologs"`。
- en: 'Say you have a `vector` of prices of some financial asset:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个金融资产的`vector`价格：
- en: '[PRE53]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Use the natural logarithm and convert this vector into a vector of *log returns*.
    Call the variable `logReturns`. If \(p_t\) is the price at time \(t\), the log
    return ending at time \(t\) is \[\begin{equation} r_t = \log \left( \frac{p_t}{p_{t-1}}
    \right) = \log p_t - \log p_{t-1} \end{equation}\]
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用自然对数并将此向量转换为对数回报向量。命名为`logReturns`。如果\(p_t\)是时间\(t\)的价格，则时间\(t\)结束的对数回报为 \[\begin{equation}
    r_t = \log \left( \frac{p_t}{p_{t-1}} \right) = \log p_t - \log p_{t-1} \end{equation}\]
- en: Do the same for *arithmetic returns*. These are regular percent changes if you
    scale by \(100\). Call the variable `arithReturns`. The mathematical formula you
    need is \[\begin{equation} a_t = \left( \frac{p_t - p_{t-1} }{p_{t-1}} \right)
    \times 100 \end{equation}\]
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**算术回报**也做同样的事情。如果你按\(100\)的比例缩放，这些是常规的百分比变化。命名为`arithReturns`。所需的数学公式是 \[\begin{equation}
    a_t = \left( \frac{p_t - p_{t-1} }{p_{t-1}} \right) \times 100 \end{equation}\]
- en: Consider the **mixture density** \(f(y) = \int f(y \mid x) f(x) dx\) where
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑**混合密度** \(f(y) = \int f(y \mid x) f(x) dx\) 其中
- en: \[\begin{equation} Y \mid X = x \sim \text{Normal}(0, x^2) \end{equation}\]
    and
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{equation} Y \mid X = x \sim \text{Normal}(0, x^2) \end{equation}\]
    并且
- en: \[\begin{equation} X \sim \text{half-Cauchy}(0, 1). \end{equation}\] This distribution
    is a special case of a prior distribution that is used in Bayesian statistics
    (Carvalho, Polson, and Scott [2009](#ref-horseshoe)). Note that the second parameter
    of the Normal distribution is its variance, not its standard deviation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{equation} X \sim \text{half-Cauchy}(0, 1). \end{equation}\] 这个分布是贝叶斯统计中使用的先验分布的特殊情况（Carvalho,
    Polson, and Scott [2009](#ref-horseshoe)）。注意，正态分布的第二个参数是其方差，而不是其标准差。
- en: 'Suppose further that you are interested in calculating the probability that
    one of these random variables ends up being too far from the median:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你进一步感兴趣于计算这些随机变量中有一个最终距离中位数太远的概率：
- en: '\[\begin{equation} \mathbb{P}[|Y| > 1] = \int_{y : |y| > 1} f(y)dy = \int_{y
    : |y| > 1} \int_{-\infty}^\infty f(y \mid x) f(x) dx dy. \end{equation}\]'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '\[\begin{equation} \mathbb{P}[|Y| > 1] = \int_{y : |y| > 1} f(y)dy = \int_{y
    : |y| > 1} \int_{-\infty}^\infty f(y \mid x) f(x) dx dy. \end{equation}\]'
- en: The following steps will demonstrate how you can use the **Monte-Carlo** (Robert
    and Casella [2005](#ref-monte-carlo-stat-methods)) method to approximate this
    probability.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将演示如何使用 **Monte-Carlo**（Robert 和 Casella [2005](#ref-monte-carlo-stat-methods)）方法来近似这个概率。
- en: 'Simulate \(X_1, \ldots, X_{5000}\) from a \(\text{half-Cauchy}(0, 1)\) and
    call these samples `xSamps`. Hint: you can simulate from a \(t\) distribution
    with one degree of freedom to sample from a Cauchy. Once you have regular Cauchy
    samples, take the absolute value of each one.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 \(\text{half-Cauchy}(0, 1)\) 模拟 \(X_1, \ldots, X_{5000}\)，并将这些样本命名为 `xSamps`。提示：你可以通过模拟一个自由度为
    1 的 \(t\) 分布来从 Cauchy 分布中采样。一旦你有了常规的 Cauchy 样本，取每个样本的绝对值。
- en: Simulate \(Y_1 \mid X_1, \ldots, Y_{5000} \mid X_{5000}\) and call the samples
    `ySamps`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟 \(Y_1 \mid X_1, \ldots, Y_{5000} \mid X_{5000}\)，并将样本命名为 `ySamps`。
- en: Calculate the approximate probability using `ySamps` and call it `approxProbDev1`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ySamps` 计算近似概率，并将其命名为 `approxProbDev1`。
- en: Why is simply “ignoring” `xSamps` (i.e. not using it in the averaging part of
    the computation), the samples you condition on, “equivalent” to “integrating out
    \(x\)”? Store a string response as a length \(1\) character vector called `integratingOutResp`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么简单地“忽略”`xSamps`（即在计算的求平均部分不使用它），即你条件化的样本，“等同于”对 \(x\) 进行积分？将字符串响应存储在一个长度为
    \(1\) 的字符向量 `integratingOutResp` 中。
- en: 'Calculate another **Rao-Blackwellized** Monte Carlo estimate of \(\mathbb{P}[|Y|
    > 1]\) from `xSamps`. Call it `approxProbDev2`. Hint: \(\mathbb{P}[|Y| > 1] =
    \mathbb{E}[\mathbb{P}(|Y| > 1 \mid X) ]\). Calculate \(\mathbb{P}(|Y| > 1 \mid
    X=x)\) with pencil and paper, notice it is a function in \(x\), apply that function
    to each of `xSamps`, and average all of it together.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `xSamps` 计算另一个 **Rao-Blackwellized** Monte Carlo 估计值 \(\mathbb{P}[|Y| > 1]\)。将其命名为
    `approxProbDev2`。提示：\(\mathbb{P}[|Y| > 1] = \mathbb{E}[\mathbb{P}(|Y| > 1 \mid
    X) ]\)。用纸笔计算 \(\mathbb{P}(|Y| > 1 \mid X=x)\)，注意它是一个关于 \(x\) 的函数，将此函数应用于 `xSamps`
    的每个元素，并将所有结果平均。
- en: Are you able to calculate an exact solution to \(\mathbb{P}[|Y| > 1]\)?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能否计算出 \(\mathbb{P}[|Y| > 1]\) 的精确解？
- en: Store the ordered uppercase letters of the alphabet in a length \(26\) `character`
    `vector` called `myUpcaseLetters`. Do not hardcode this. Use a function, along
    with the variable `letters`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将字母表的有序大写字母存储在一个长度为 \(26\) 的 `character` 向量 `myUpcaseLetters` 中。不要硬编码这个操作。使用一个函数，以及变量
    `letters`。
- en: Create a new vector called `withReplacements` that’s the same as the previous
    `vector`, but replace all vowels with `"---"`. Again, do not hardcode this. Find
    a function that searches for patterns and performs a replacement whenever that
    pattern is found.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `withReplacements` 的新向量，它与之前的 `vector` 相同，但将所有元音替换为 `"---"`。同样，不要硬编码这个操作。找到一个函数，用于搜索模式并在找到该模式时进行替换。
- en: Create a length \(26\) logical vector that is `TRUE` whenever an element of
    `letters` is a consonant, and `FALSE` everywhere else. Call it `consonant`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个长度为 \(26\) 的逻辑向量，当 `letters` 的元素是辅音时为 `TRUE`，否则为 `FALSE`。将其命名为 `consonant`。
- en: 3.10.2 Python Questions
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.10.2 Python 问题
- en: Let’s flip some coins (again)! Generate a thousand flips of a fair coin. Use
    `np.random.binomial`, and let heads be coded as `1` and tails coded as `0`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次抛一些硬币！生成一千次公平硬币的翻转。使用 `np.random.binomial`，将正面编码为 `1`，反面编码为 `0`。
- en: Assign the thousand raw coin flips to a variable `flips`. Make sure the elements
    are integers, and make sure you flip a “fair” coin (\(p=.5\)).
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一千次原始硬币翻转分配给变量 `flips`。确保元素是整数，并确保你抛的是一个“公平”的硬币（\(p=.5\)）。
- en: Create a length `1000` `list` of `bool`s called `is_heads`. Whenever you get
    a heads, make sure the corresponding element is `True` and `False` otherwise.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个长度为 `1000` 的 `bool` `list`，名为 `is_heads`。每次得到正面时，确保相应的元素为 `True`，否则为 `False`。
- en: Create a variable called `num_heads` by tallying up the number of heads.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过统计正面的数量来创建一个名为 `num_heads` 的变量。
- en: Calculate the percent of time that the number changes in `flips`. Assign your
    number to `acceptance_rate`. Try to write only one line of code to do this.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算数字在 `flips` 中变化的百分比时间，并将你的数字赋值给 `acceptance_rate`。尽量用一行代码完成这个操作。
- en: Create a Numpy `array` containing the numbers \(1/2, 1/4, 1/8, \ldots, 1/1024\)
    Make sure to call it `my_array`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含数字 \(1/2, 1/4, 1/8, \ldots, 1/1024\) 的 Numpy `array`，确保将其命名为 `my_array`。
- en: 'Do the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作：
- en: Create a `np.array` called `nums` that contains one hundred equally-spaced numbers
    starting from \(-100\) and going to \(100\) (inclusive).
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含从 \(-100\) 到 \(100\)（包含）的 100 个等间距数字的 `np.array`，名为 `nums`。
- en: Create a `bool` `np.array` that has the same length as the above, and contains
    `TRUE` whenever an element of the above is less than ten units away from \(0\),
    and `FALSE` otherwise. Call it `my_logicals`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与上述相同的长度，并且当上述元素小于十个单位远离 \(0\) 时包含 `TRUE`，否则包含 `FALSE` 的 `bool` `np.array`。命名为
    `my_logicals`。
- en: Assign the total number of `True`s to `total_close`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `True` 的总数赋值给 `total_close`。
- en: Create a `np.array` called `evens` of all even numbers from the above `np.array`
    (even numbers are necessarily integers).
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含上述 `np.array` 中所有偶数的 `evens` `np.array`（偶数必然是整数）。
- en: Create a `np.array` called `reverse` that holds the reversed elements of `nums`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `reverse` 的 `np.array`，它包含 `nums` 的反转元素。
- en: Let’s say we wanted to calculate the following sum \(\sum_{i=1}^N x_i\). We
    run into problems when this sum is close to \(0\), too. This is the problem of
    *underflow*. The smallest positive floating point can be recovered by typing `np.nextafter(np.float64(0),np.float64(1))`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要计算以下求和 \(\sum_{i=1}^N x_i\)。当这个和接近 \(0\) 时，我们会遇到问题。这是 *下溢* 的问题。最小的正浮点数可以通过输入
    `np.nextafter(np.float64(0),np.float64(1))` 来恢复。
- en: Assign `sum_these` to the length ten array \((e^{-1000}, \ldots, e^{-1000})\).
    Use `np.exp(np.repeat(-1000,10))`. Are the elements nonzero? Can you sum them?
    Is the sum correct? If everything is all good, assign `True` to `all_good`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `sum_these` 赋值给长度为十的数组 \((e^{-1000}, \ldots, e^{-1000})\)。使用 `np.exp(np.repeat(-1000,10))`。这些元素是非零的吗？你能将它们相加吗？总和是正确的吗？如果一切顺利，将
    `True` 赋值给 `all_good`。
- en: 'Theoretically, for which range of positive numbers is the logarithm of the
    number farther from \(0\) than the number itself? Assign the lower bound to `lower_bound`,
    and the upper bound to `upper_bound`. Hint: `lower_bound` is \(0\) because we’re
    only looking at positive numbers, and because the logarithm is \(-\infty\).'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从理论上讲，对于哪个正数范围，数字的对数比数字本身更远离 \(0\)？将下限赋值给 `lower_bound`，将上限赋值给 `upper_bound`。提示：`lower_bound`
    是 \(0\)，因为我们只看正数，因为对数是 \(-\infty\)。
- en: Assign the *naive* log-sum of `sum_these` to `naive_log_sum`. Is the naive log
    sum finite on your computer? Should it be?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `sum_these` 的 *naive* log-sum 赋值给 `naive_log_sum`。在您的计算机上，naive log sum 是有限的吗？应该是这样的吗？
- en: Compute `better_sum`, one that doesn’t underflow, using the *log-sum-exp* trick.
    This one should be bounded away from \(-\infty\).
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *log-sum-exp* 技巧计算 `better_sum`，一个不会下溢的求和。这个求和应该远离 \(-\infty\)。
- en: \[ \log\left( \sum_{i=1}^{10} x_i \right) = \log\left( \sum_{i=1}^{10} \exp[
    \log(x_i) - m] \right) + m = \] \(m\) is usually chosen to be \(\max_i \log x_i\)
    e) If you’re writing code, and you have a bunch of very small positive numbers
    (e.g. probabilities, densities, etc.), is it better to store those small numbers,
    or store the logarithm of those numbers? Assign your answer to `which_better`.
    Use either the phrase `"logs"` or `"nologs"`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \log\left( \sum_{i=1}^{10} x_i \right) = \log\left( \sum_{i=1}^{10} \exp[
    \log(x_i) - m] \right) + m = \] \(m\) 通常选择为 \(\max_i \log x_i\)。如果你正在编写代码，并且有一系列非常小的正数（例如概率、密度等），是存储这些小数更好，还是存储这些数的对数更好？将你的答案赋值给
    `which_better`。使用短语 `"logs"` 或 `"nologs"`。
- en: Use `pd.read_csv` to correctly read in `"2013-10_Citi_Bike_trip_data_20K.csv"`
    as a data frame called `my_df`. Make sure to read `autograding_tips.html`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `pd.read_csv` 正确读取 `"2013-10_Citi_Bike_trip_data_20K.csv"`，并将其作为名为 `my_df`
    的数据框。确保读取 `autograding_tips.html`。
- en: Extract the `"starttime"` column into a separate `Series` called `s_times`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `"starttime"` 列提取到一个名为 `s_times` 的单独的 `Series` 中。
- en: Extract date strings of those elements into a `Series` called `date_strings`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些元素的日期字符串提取到一个名为 `date_strings` 的 `Series` 中。
- en: Extract time strings of those elements into a `Series` called `time_strings`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些元素的日期字符串提取到一个名为 `time_strings` 的 `Series` 中。
- en: We will make use of the **Monte Carlo** method below. It is a technique to approximate
    expectations and probabilities. If \(n\) is a large number, and \(X_1, \ldots,
    X_n\) is a random sample drawn from the distribution of interest, then \[\begin{equation}
    \mathbb{P}(X > 6) \approx \frac{1}{n}\sum_{i=1}^n \mathbf{1}(X_i > 6). \end{equation}\]
    If you haven’t seen an **indicator function** before, it is defined as
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下面使用 **蒙特卡洛** 方法。这是一种近似期望和概率的技术。如果 \(n\) 是一个很大的数，且 \(X_1, \ldots, X_n\)
    是从感兴趣分布中抽取的随机样本，那么 \[\begin{equation} \mathbb{P}(X > 6) \approx \frac{1}{n}\sum_{i=1}^n
    \mathbf{1}(X_i > 6). \end{equation}\] 如果你之前没有见过 **指示函数**，它被定义为
- en: \[\begin{equation} \mathbf{1}(X_i > 6) = \begin{cases} 1 & X_i > 6 \\ 0 & X_i
    \le 6 \end{cases}. \end{equation}\]
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{equation} \mathbf{1}(X_i > 6) = \begin{cases} 1 & X_i > 6 \\ 0 & X_i
    \le 6 \end{cases}. \end{equation}\]
- en: If you wanted to visualize it, \(\mathbf{1}(x > 6)\) looks like this.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想可视化它，\(\mathbf{1}(x > 6)\) 看起来是这样的。
- en: '![An Indicator Function](../Images/8f24678d24c1b841abe67885ddabd04d.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![指示函数](../Images/8f24678d24c1b841abe67885ddabd04d.png)'
- en: 'Figure 3.1: An Indicator Function'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：指示函数
- en: So, the sum in this expression is just a count of the number of elements that
    are greater than \(6\).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个表达式中的和只是大于 \(6\) 的元素数量的计数。
- en: Evaluate exactly the probability that a normal random variable with mean \(5\)
    and standard deviation \(6\) is greater than \(6\). Assign it to the variable
    `exact_exceedance_prob` in Python.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准确评估均值为 \(5\) 和标准差 \(6\) 的正态随机变量大于 \(6\) 的概率。在 Python 中将其分配给变量 `exact_exceedance_prob`.
- en: Simulate \(1e3\) times from a standard normal distribution (mean 0 and variance
    1). Call the samples `stand_norm_samps`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从标准正态分布（均值 0 和方差 1）中模拟 \(1e3\) 次。将样本命名为 `stand_norm_samps`.
- en: Calculate a Monte Carlo estimate of \(\mathbb{P}(X > 6)\) from these samples.
    Call it `approx_exceedance_prob1`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这些样本中计算 \(\mathbb{P}(X > 6)\) 的蒙特卡洛估计。命名为 `approx_exceedance_prob1`.
- en: Simulate \(1e3\) times from a normal distribution with mean \(5\) and standard
    deviation \(6\). Call the samples `norm_samps`. Don’t use the old samples in any
    way.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从均值为 \(5\) 和标准差 \(6\) 的正态分布中模拟 \(1e3\) 次。将样本命名为 `norm_samps`。不要以任何方式使用旧样本。
- en: Calculate a Monte Carlo estimate of \(\mathbb{P}(X > 6)\) from these new `norm_samps`.
    Call it `approx_exceedance_prob2`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这些新的 `norm_samps` 中计算 \(\mathbb{P}(X > 6)\) 的蒙特卡洛估计。命名为 `approx_exceedance_prob2`.
- en: Alternatively, we can approximate expectations using the same technique as above.
    If \(\mathbb{E}[g(X)]\) exists, \(n\) is a large number, and \(W_1, \ldots, W_n\)
    is a random sample drawn from the distribution of interest, then
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用与上面相同的技术来近似期望。如果 \(\mathbb{E}[g(X)]\) 存在，\(n\) 是一个很大的数，且 \(W_1, \ldots,
    W_n\) 是从感兴趣分布中抽取的随机样本，那么
- en: \[\begin{equation} \mathbb{E}[g(W)] \approx \frac{1}{n}\sum_{i=1}^n g(W_i).
    \end{equation}\]
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{equation} \mathbb{E}[g(W)] \approx \frac{1}{n}\sum_{i=1}^n g(W_i).
    \end{equation}\]
- en: 'Here’s a new distribution. It is a **mixture distribution**, specifically a
    **finite mixture of normal distributions**: \(f(y) = f(y \mid X=1)P(X=1) + f(y
    \mid X=0)P(X=0)\) where'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个新的分布。它是一个 **混合分布**，具体是一个 **有限混合的正态分布**：\(f(y) = f(y \mid X=1)P(X=1) + f(y
    \mid X=0)P(X=0)\) 其中
- en: \[\begin{equation} Y \mid X=0 \sim \text{Normal}(0, 2) \\ Y \mid X=1 \sim \text{Normal}(10,
    2) \end{equation}\] and
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{equation} Y \mid X=0 \sim \text{Normal}(0, 2) \\ Y \mid X=1 \sim \text{Normal}(10,
    2) \end{equation}\] 和
- en: \[\begin{equation} X \sim \text{Bernoulli}(.5). \end{equation}\]
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{equation} X \sim \text{Bernoulli}(.5). \end{equation}\]
- en: Both \(f(y \mid X=0)\) and \(f(y \mid X=1)\) are bell-curved, and \(f(y)\) looks
    like this
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是 \(f(y \mid X=0)\) 还是 \(f(y \mid X=1)\)，都是钟形曲线，而 \(f(y)\) 看起来是这样的
- en: '![The Marginal Density of Y](../Images/a35764c84c5dcc9ea09c93cad9e3d16e.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![Y 的边缘密度](../Images/a35764c84c5dcc9ea09c93cad9e3d16e.png)'
- en: 'Figure 3.2: The Marginal Density of Y'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：Y 的边缘密度
- en: Evaluate exactly \(\mathbb{E}[Y] = \mathbb{E}[ \mathbb{E}(Y \mid X) ]\). Assign
    it to the variable `exact_mean` in Python.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准确评估 \(\mathbb{E}[Y] = \mathbb{E}[ \mathbb{E}(Y \mid X) ]\). 在 Python 中将其分配给变量
    `exact_mean`.
- en: Simulate \(1e3\) times from the Bernoulli distribution. Call the samples `bernoulli_flips`
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从伯努利分布中模拟 \(1e3\) 次。将样本命名为 `bernoulli_flips`
- en: Simulate \(Y_1 \mid X_1, \ldots, Y_{1000} \mid X_{1000}\) and call the samples
    `cond_norm_samps`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟 \(Y_1 \mid X_1, \ldots, Y_{1000} \mid X_{1000}\)，并将样本命名为 `cond_norm_samps`.
- en: Calculate a Monte Carlo estimate of \(\mathbb{E}[Y]\) from `cond_norm_samps`.
    Call it `approx_ave_1`. Why is simply “ignoring” `bernoulli_flips`, the samples
    you condition on, “equivalent” to “integrating them out?”
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`cond_norm_samps`计算\(\mathbb{E}[Y]\)的蒙特卡洛估计值，命名为`approx_ave_1`。为什么“忽略”`bernoulli_flips`，即你条件化的样本，等同于“积分它们”？
- en: 'Calculate a **Rao-Blackwellized** Monte Carlo estimate of \(\mathbb{E}[Y]\)
    from `bernoulli_flips`. Call it `approx_ave_2`. Hint: \(\mathbb{E}[Y] = \mathbb{E}[\mathbb{E}(Y
    \mid X) ]\). Calculate \(\mathbb{E}(Y \mid X_i)\) exactly, and evaluate that function
    on each \(X_i\) sample, and then average them together. Rao-Blackwellization is
    a variance-reduction technique that allows you come up with lower-variance estimates
    given a fixed computational budget.'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`bernoulli_flips`计算**Rao-Blackwellized**的蒙特卡洛估计值\(\mathbb{E}[Y]\)，命名为`approx_ave_2`。提示：\(\mathbb{E}[Y]
    = \mathbb{E}[\mathbb{E}(Y \mid X) ]\)。精确计算\(\mathbb{E}(Y \mid X_i)\)，并在每个\(X_i\)样本上评估该函数，然后将它们平均。Rao-Blackwellization是一种方差减少技术，它允许你在固定的计算预算下得到低方差估计。
- en: References
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Carvalho, Carlos M., Nicholas G. Polson, and James G. Scott. 2009\. “Handling
    Sparsity via the Horseshoe.” In *Proceedings of the Twelth International Conference
    on Artificial Intelligence and Statistics*, edited by David van Dyk and Max Welling,
    5:73–80\. Proceedings of Machine Learning Research. Hilton Clearwater Beach Resort,
    Clearwater Beach, Florida USA: PMLR. [https://proceedings.mlr.press/v5/carvalho09a.html](https://proceedings.mlr.press/v5/carvalho09a.html).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Carvalho, Carlos M., Nicholas G. Polson, and James G. Scott. 2009\. “通过Horseshoe处理稀疏性。”载于*第十二届国际人工智能与统计会议论文集*，由David
    van Dyk和Max Welling编辑，第5卷，第73-80页。机器学习研究论文集。美国佛罗里达州Clearwater Beach的Hilton Clearwater
    Beach Resort：PMLR。[https://proceedings.mlr.press/v5/carvalho09a.html](https://proceedings.mlr.press/v5/carvalho09a.html).
- en: 'Harris, Charles R., K. Jarrod Millman, Stéfan J. van der Walt, Ralf Gommers,
    Pauli Virtanen, David Cournapeau, Eric Wieser, et al. 2020\. “Array Programming
    with NumPy.” *Nature* 585 (7825): 357–62\. [https://doi.org/10.1038/s41586-020-2649-2](https://doi.org/10.1038/s41586-020-2649-2).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 'Harris, Charles R., K. Jarrod Millman, Stéfan J. van der Walt, Ralf Gommers,
    Pauli Virtanen, David Cournapeau, Eric Wieser, et al. 2020\. “使用NumPy进行数组编程。”*自然*
    585 (7825): 357–62\. [https://doi.org/10.1038/s41586-020-2649-2](https://doi.org/10.1038/s41586-020-2649-2).'
- en: 'López, Félix. 2014\. *Mastering Python Regular Expressions : Leverage Regular
    Expressions in Python Even for the Most Complex Features*. Birmingham, UK: Packt
    Pub.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: López, Félix. 2014\. *精通Python正则表达式：利用Python的正则表达式，即使是对于最复杂的功能也能游刃有余*. 英国伯明翰：Packt
    Pub.
- en: 'Robert, Christian P., and George Casella. 2005\. *Monte Carlo Statistical Methods
    (Springer Texts in Statistics)*. Berlin, Heidelberg: Springer-Verlag.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Robert, Christian P., and George Casella. 2005\. *蒙特卡洛统计方法（Springer统计文本系列）*.
    柏林，海德堡：Springer-Verlag.
- en: 'Wickham, Hadley, and Garrett Grolemund. 2017\. *R for Data Science: Import,
    Tidy, Transform, Visualize, and Model Data*. 1st ed. O’Reilly Media, Inc.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Wickham, Hadley, and Garrett Grolemund. 2017\. *R语言数据科学：导入、整理、转换、可视化和建模数据*.
    第1版。O’Reilly Media, Inc.
- en: '* * *'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The dollar sign is useful if you only want to find certain patterns that finish
    a line. It takes the characters preceding it, and says, only look for that pattern
    if it comes at the end of a string.[↩](/r-vectors-versus-numpy-arrays-and-pandas-series#fnref6)
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你只想找到以某行结束的特定模式，美元符号很有用。它取其前面的字符，并说，只有当该模式位于字符串末尾时才寻找该模式。[↩](/r-vectors-versus-numpy-arrays-and-pandas-series#fnref6)
