- en: 9\. Groups and Rings
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. 群与环
- en: 原文：[https://leanprover-community.github.io/mathematics_in_lean/C09_Groups_and_Rings.html](https://leanprover-community.github.io/mathematics_in_lean/C09_Groups_and_Rings.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://leanprover-community.github.io/mathematics_in_lean/C09_Groups_and_Rings.html](https://leanprover-community.github.io/mathematics_in_lean/C09_Groups_and_Rings.html)
- en: '*[Mathematics in Lean](index.html)* **   9\. Groups and Rings'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*[Mathematics in Lean](index.html)* **   9. 群与环'
- en: '[View page source](_sources/C09_Groups_and_Rings.rst.txt)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[查看页面源代码](_sources/C09_Groups_and_Rings.rst.txt)'
- en: '* * *'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: We saw in [Section 2.2](C02_Basics.html#proving-identities-in-algebraic-structures)
    how to reason about operations in groups and rings. Later, in [Section 7.2](C07_Structures.html#section-algebraic-structures),
    we saw how to define abstract algebraic structures, such as group structures,
    as well as concrete instances such as the ring structure on the Gaussian integers.
    [Chapter 8](C08_Hierarchies.html#hierarchies) explained how hierarchies of abstract
    structures are handled in Mathlib.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第2.2节（[C02_Basics.html#proving-identities-in-algebraic-structures](https://leanprover-community.github.io/mathematics_in_lean/C02_Basics.html#proving-identities-in-algebraic-structures)）中看到了如何在群和环中推理操作。后来，在第7.2节（[C07_Structures.html#section-algebraic-structures](https://leanprover-community.github.io/mathematics_in_lean/C07_Structures.html#section-algebraic-structures)）中，我们看到了如何定义抽象代数结构，例如群结构，以及具体的实例，如高斯整数上的环结构。[第8章](https://leanprover-community.github.io/mathematics_in_lean/C08_Hierarchies.html#hierarchies)解释了在Mathlib中如何处理抽象结构的层次。
- en: In this chapter we work with groups and rings in more detail. We won’t be able
    to cover every aspect of the treatment of these topics in Mathlib, especially
    since Mathlib is constantly growing. But we will provide entry points to the library
    and show how the essential concepts are used. There is some overlap with the discussion
    of [Chapter 8](C08_Hierarchies.html#hierarchies), but here we will focus on how
    to use Mathlib instead of the design decisions behind the way the topics are treated.
    So making sense of some of the examples may require reviewing the background from
    [Chapter 8](C08_Hierarchies.html#hierarchies).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更详细地研究群与环。由于Mathlib库不断增长，我们无法涵盖这些主题在Mathlib中处理的各个方面。但我们将提供进入库的入口点，并展示基本概念是如何被使用的。与第8章（[C08_Hierarchies.html#hierarchies](https://leanprover-community.github.io/mathematics_in_lean/C08_Hierarchies.html#hierarchies)）的讨论有一些重叠，但在这里我们将专注于如何使用Mathlib，而不是处理这些主题的设计决策。因此，理解一些示例可能需要回顾第8章的内容。
- en: '## 9.1\. Monoids and Groups[](#monoids-and-groups "Link to this heading")'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '## 9.1. 群与群同态[](#monoids-and-groups "链接到本标题")'
- en: '### 9.1.1\. Monoids and their morphisms[](#monoids-and-their-morphisms "Link
    to this heading")'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '### 9.1.1. 群及其同态[](#monoids-and-their-morphisms "链接到本标题")'
- en: Courses in abstract algebra often start with groups and then progress to rings,
    fields, and vector spaces. This involves some contortions when discussing multiplication
    on rings since the multiplication operation does not come from a group structure
    but many of the proofs carry over verbatim from group theory to this new setting.
    The most common fix, when doing mathematics with pen and paper, is to leave those
    proofs as exercises. A less efficient but safer and more formalization-friendly
    way of proceeding is to use monoids. A *monoid* structure on a type M is an internal
    composition law that is associative and has a neutral element. Monoids are used
    primarily to accommodate both groups and the multiplicative structure of rings.
    But there are also a number of natural examples; for instance, the set of natural
    numbers equipped with addition forms a monoid.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象代数课程通常从群开始，然后过渡到环、域和向量空间。在讨论环上的乘法时，这涉及到一些扭曲，因为乘法操作并不来自群结构，但许多证明可以直接从群理论转移到这个新环境。在用笔和纸做数学时，最常见的解决方案是将这些证明作为练习。一种不太高效但更安全、更符合形式化要求的做法是使用幺半群。在类型M上的*幺半群*结构是一个内部结合律，它是结合的并有一个单位元。幺半群主要用于适应群和环的乘性结构。但也有一些自然例子；例如，自然数集加上加法运算形成一个幺半群。
- en: From a practical point of view, you can mostly ignore monoids when using Mathlib.
    But you need to know they exist when you are looking for a lemma by browsing Mathlib
    files. Otherwise, you might end up looking for a statement in the group theory
    files when it is actually in the found with monoids because it does not require
    elements to be invertible.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际应用的角度来看，在使用Mathlib时，你可以基本上忽略群。但是，当你通过浏览Mathlib文件寻找引理时，你需要知道它们的存在。否则，你可能会在群论文件中寻找一个陈述，而实际上它是在群中找到的，因为群不需要元素可逆。
- en: The type of monoid structures on a type `M` is written `Monoid M`. The function
    `Monoid` is a type class so it will almost always appear as an instance implicit
    argument (in other words, in square brackets). By default, `Monoid` uses multiplicative
    notation for the operation; for additive notation use `AddMonoid` instead. The
    commutative versions of these structures add the prefix `Comm` before `Monoid`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `M` 上的单群结构类型写成 `Monoid M`。函数 `Monoid` 是一个类型类，所以它几乎总是作为一个隐式参数实例出现（换句话说，在方括号中）。默认情况下，`Monoid`
    使用乘法表示法进行操作；对于加法表示法，请使用 `AddMonoid`。这些结构的交换版本在 `Monoid` 前添加 `Comm` 前缀。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that although `AddMonoid` is found in the library, it is generally confusing
    to use additive notation with a non-commutative operation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管 `AddMonoid` 在库中可以找到，但使用非交换操作的加法表示法通常很令人困惑。
- en: The type of morphisms between monoids `M` and `N` is called `MonoidHom M N`
    and written `M →* N`. Lean will automatically see such a morphism as a function
    from `M` to `N` when we apply it to elements of `M`. The additive version is called
    `AddMonoidHom` and written `M →+ N`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 两个单群 `M` 和 `N` 之间的同态类型称为 `MonoidHom M N`，并写成 `M →* N`。当我们将其应用于 `M` 的元素时，Lean
    会自动将其视为从 `M` 到 `N` 的函数。加法版本称为 `AddMonoidHom`，并写成 `M →+ N`。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These morphisms are bundled maps, i.e. they package together a map and some
    of its properties. Remember that [Section 8.2](C08_Hierarchies.html#section-hierarchies-morphisms)
    explains bundled maps; here we simply note the slightly unfortunate consequence
    that we cannot use ordinary function composition to compose maps. Instead, we
    need to use `MonoidHom.comp` and `AddMonoidHom.comp`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些同态是打包映射，即它们将映射及其一些属性打包在一起。记住，[第8.2节](C08_Hierarchies.html#section-hierarchies-morphisms)
    解释了打包映射；这里我们只是简单地指出一个不幸的后果，即我们不能使用普通函数组合来组合映射。相反，我们需要使用 `MonoidHom.comp` 和 `AddMonoidHom.comp`。
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 9.1.2\. Groups and their morphisms[](#groups-and-their-morphisms "Link to this
    heading")
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2. 群及其同态[](#groups-and-their-morphisms "链接到这个标题")
- en: We will have much more to say about groups, which are monoids with the extra
    property that every element has an inverse.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有很多关于群的话要说，群是具有每个元素都有逆元的额外属性的单群。
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Similar to the `ring` tactic that we saw earlier, there is a `group` tactic
    that proves any identity that holds in any group. (Equivalently, it proves the
    identities that hold in free groups.)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前看到的 `ring` 策略类似，有一个 `group` 策略可以证明任何在任何群中成立的恒等式。（等价地，它证明了在自由群中成立的恒等式。）
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There is also a tactic for identities in commutative additive groups called
    `abel`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个用于交换加法群恒等式的策略，称为 `abel`。
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Interestingly, a group morphism is nothing more than a monoid morphism between
    groups. So we can copy and paste one of our earlier examples, replacing `Monoid`
    with `Group`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，群同态不过是在群之间的单群同态。因此，我们可以复制并粘贴我们之前的一个例子，将 `Monoid` 替换为 `Group`。
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Of course we do get some new properties, such as this one:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们确实得到了一些新的属性，例如这个：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You may be worried that constructing group morphisms will require us to do unnecessary
    work since the definition of monoid morphism enforces that neutral elements are
    sent to neutral elements while this is automatic in the case of group morphisms.
    In practice the extra work is not hard, but, to avoid it, there is a function
    building a group morphism from a function between groups that is compatible with
    the composition laws.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能担心构造群同态会让我们做不必要的额外工作，因为单群同态的定义强制要求中性元素被发送到中性元素，而在群同态的情况下这是自动的。在实践中，额外的努力并不困难，但为了避免它，有一个函数可以从群之间的兼容于组合律的函数构建群同态。
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There is also a type `MulEquiv` of group (or monoid) isomorphisms denoted by
    `≃*` (and `AddEquiv` denoted by `≃+` in additive notation). The inverse of `f
    : G ≃* H` is `MulEquiv.symm f : H ≃* G`, composition of `f` and `g` is `MulEquiv.trans
    f g`, and the identity isomorphism of `G` is `M̀ulEquiv.refl G`. Using anonymous
    projector notation, the first two can be written `f.symm` and `f.trans g` respectively.
    Elements of this type are automatically coerced to morphisms and functions when
    necessary.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，还有一种类型 `MulEquiv` 的群（或单群）同构，用 `≃*` 表示（在加法表示法中用 `≃+` 表示）。`f : G ≃* H` 的逆是
    `MulEquiv.symm f : H ≃* G`，`f` 和 `g` 的组合是 `MulEquiv.trans f g`，而 `G` 的恒等同构是 `M̀ulEquiv.refl
    G`。使用匿名投影符号，前两个可以分别写成 `f.symm` 和 `f.trans g`。当需要时，此类元素会自动转换为同态和函数。'
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: One can use `MulEquiv.ofBijective` to build an isomorphism from a bijective
    morphism. Doing so makes the inverse function noncomputable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `MulEquiv.ofBijective` 从双射同态构建同构。这样做会使逆函数不可计算。
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 9.1.3\. Subgroups[](#subgroups "Link to this heading")
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.3\. 子群[](#subgroups "链接到这个标题")
- en: Just as group morphisms are bundled, a subgroup of `G` is also a bundled structure
    consisting of a set in `G` with the relevant closure properties.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如群同态是捆绑在一起的，`G` 的一个子群也是一个捆绑结构，由 `G` 中的一个集合及其相关的闭包性质组成。
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the example above, it is important to understand that `Subgroup G` is the
    type of subgroups of `G`, rather than a predicate `IsSubgroup H` where `H` is
    an element of `Set G`. `Subgroup G` is endowed with a coercion to `Set G` and
    a membership predicate on `G`. See [Section 8.3](C08_Hierarchies.html#section-hierarchies-subobjects)
    for an explanation of how and why this is done.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，重要的是要理解 `Subgroup G` 是 `G` 的子群的类型，而不是一个谓词 `IsSubgroup H`，其中 `H` 是 `Set
    G` 的一个元素。`Subgroup G` 被赋予了到 `Set G` 的强制转换和一个关于 `G` 的成员谓词。参见 [第8.3节](C08_Hierarchies.html#section-hierarchies-subobjects)
    了解如何以及为什么这样做。
- en: Of course, two subgroups are the same if and only if they have the same elements.
    This fact is registered for use with the `ext` tactic, which can be used to prove
    two subgroups are equal in the same way it is used to prove that two sets are
    equal.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果两个子群具有相同的元素，则它们是相同的。这个事实被注册用于与 `ext` 策略一起使用，该策略可以用来证明两个子群相等，就像它被用来证明两个集合相等一样。
- en: To state and prove, for example, that `ℤ` is an additive subgroup of `ℚ`, what
    we really want is to construct a term of type `AddSubgroup ℚ` whose projection
    to `Set ℚ` is `ℤ`, or, more precisely, the image of `ℤ` in `ℚ`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了陈述和证明 `ℤ` 是 `ℚ` 的加法子群，我们真正想要的是构造一个类型为 `AddSubgroup ℚ` 的项，其投影到 `Set ℚ` 是
    `ℤ`，或者更精确地说，是 `ℤ` 在 `ℚ` 中的像。
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using type classes, Mathlib knows that a subgroup of a group inherits a group
    structure.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型类，Mathlib 知道群的一个子群继承了群结构。
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This example is subtle. The object `H` is not a type, but Lean automatically
    coerces it to a type by interpreting it as a subtype of `G`. So the above example
    can be restated more explicitly as:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很微妙。对象 `H` 不是一个类型，但 Lean 会自动将其强制转换为类型，通过将其解释为 `G` 的一个子类型。因此，上面的例子可以更明确地重述为：
- en: '[PRE14]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'An important benefit of having a type `Subgroup G` instead of a predicate `IsSubgroup
    : Set G → Prop` is that one can easily endow `Subgroup G` with additional structure.
    Importantly, it has the structure of a complete lattice structure with respect
    to inclusion. For instance, instead of having a lemma stating that an intersection
    of two subgroups of `G` is again a subgroup, we have used the lattice operation
    `⊓` to construct the intersection. We can then apply arbitrary lemmas about lattices
    to the construction.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '拥有类型 `Subgroup G` 而不是谓词 `IsSubgroup : Set G → Prop` 的重要好处是，可以很容易地为 `Subgroup
    G` 赋予额外的结构。重要的是，它具有关于包含的完备格结构。例如，我们不是有一个断言两个 `G` 的子群的交集仍然是子群的引理，而是使用了格运算 `⊓` 来构造交集。然后我们可以将关于格的任意引理应用于构造。'
- en: Let us check that the set underlying the infimum of two subgroups is indeed,
    by definition, their intersection.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查两个子群的交集的底层集合确实，按照定义，是它们的交集。
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It may look strange to have a different notation for what amounts to the intersection
    of the underlying sets, but the correspondence does not carry over to the supremum
    operation and set union, since a union of subgroups is not, in general, a subgroup.
    Instead one needs to use the subgroup generated by the union, which is done using
    `Subgroup.closure`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于底层集合的交集使用不同的符号可能看起来很奇怪，但这种对应关系并不适用于上确界运算和集合的并集，因为子群的并集在一般情况下不是一个子群。相反，需要使用由并集生成的子群，这是通过
    `Subgroup.closure` 来实现的。
- en: '[PRE16]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Another subtlety is that `G` itself does not have type `Subgroup G`, so we
    need a way to talk about `G` seen as a subgroup of `G`. This is also provided
    by the lattice structure: the full subgroup is the top element of this lattice.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个微妙之处在于 `G` 本身没有类型 `Subgroup G`，因此我们需要一种方法来谈论 `G` 作为 `G` 的子群。这也由格结构提供：全子群是这个格的顶元素。
- en: '[PRE17]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Similarly the bottom element of this lattice is the subgroup whose only element
    is the neutral element.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，这个格的底元素是只有一个元素的子群，即中性元素。
- en: '[PRE18]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As an exercise in manipulating groups and subgroups, you can define the conjugate
    of a subgroup by an element of the ambient group.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 作为操作群和子群的一个练习，你可以通过环境群中的一个元素来定义子群的共轭。
- en: '[PRE19]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tying the previous two topics together, one can push forward and pull back subgroups
    using group morphisms. The naming convention in Mathlib is to call those operations
    `map` and `comap`. These are not the common mathematical terms, but they have
    the advantage of being shorter than “pushforward” and “direct image.”
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将前两个主题结合起来，可以使用群同态来推进和拉回子群。在Mathlib中的命名约定是将这些操作称为`map`和`comap`。这些不是常见的数学术语，但它们的优势是比“推进”和“直接像”更短。
- en: '[PRE20]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In particular, the preimage of the bottom subgroup under a morphism `f` is a
    subgroup called the *kernel* of `f`, and the range of `f` is also a subgroup.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，在映射`f`下的底子群的逆像是称为`f`的*核*的子群，而`f`的值域也是一个子群。
- en: '[PRE21]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As exercises in manipulating group morphisms and subgroups, let us prove some
    elementary properties. They are already proved in Mathlib, so do not use `exact?`
    too quickly if you want to benefit from these exercises.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 作为操作群同态和子群的训练，让我们证明一些基本性质。它们已经在Mathlib中得到了证明，所以如果你想从这些练习中受益，不要急于使用`exact?`。
- en: '[PRE22]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let us finish this introduction to subgroups in Mathlib with two very classical
    results. Lagrange theorem states the cardinality of a subgroup of a finite group
    divides the cardinality of the group. Sylow’s first theorem is a famous partial
    converse to Lagrange’s theorem.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用两个非常经典的结果来结束对Mathlib中子群的介绍。拉格朗日定理表明有限群子群的基数是群基数的因子。西罗第一定理是拉格朗日定理的一个著名的部分逆定理。
- en: While this corner of Mathlib is partly set up to allow computation, we can tell
    Lean to use nonconstructive logic anyway using the following `open scoped` command.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Mathlib的这个角落部分是为了允许计算而设置的，但我们可以使用以下`open scoped`命令告诉Lean使用非构造性逻辑。
- en: '[PRE23]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The next two exercises derive a corollary of Lagrange’s lemma. (This is also
    already in Mathlib, so do not use `exact?` too quickly.)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个练习推导出拉格朗日引理的一个推论。（这也在Mathlib中已经有了，所以不要急于使用`exact?`。）
- en: '[PRE24]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 9.1.4\. Concrete groups[](#concrete-groups "Link to this heading")
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.4\. 具体群[](#concrete-groups "链接到这个标题")
- en: One can also manipulate concrete groups in Mathlib, although this is typically
    more complicated than working with the abstract theory. For instance, given any
    type `X`, the group of permutations of `X` is `Equiv.Perm X`. In particular the
    symmetric group \(\mathfrak{S}_n\) is `Equiv.Perm (Fin n)`. One can state abstract
    results about this group, for instance saying that `Equiv.Perm X` is generated
    by cycles if `X` is finite.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mathlib中也可以操作具体群，尽管这通常比处理抽象理论更复杂。例如，给定任何类型`X`，`X`的排列群是`Equiv.Perm X`。特别是对称群\(\mathfrak{S}_n\)是`Equiv.Perm
    (Fin n)`。可以对这个群陈述抽象结果，例如说如果`X`是有限的，那么`Equiv.Perm X`由循环生成。
- en: '[PRE25]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'One can be fully concrete and compute actual products of cycles. Below we use
    the `#simp` command, which calls the `simp` tactic on a given expression. The
    notation `c[]` is used to define a cyclic permutation. In the example, the result
    is a permutation of `ℕ`. One could use a type ascription such as `(1 : Fin 5)`
    on the first number appearing to make it a computation in `Perm (Fin 5)`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '可以完全具体地计算循环的乘积。下面我们使用`#simp`命令，它在一个给定的表达式中调用`simp`策略。符号`c[]`用于定义循环排列。在例子中，结果是`ℕ`的排列。可以通过在第一个数字上使用类型注解，例如`(1
    : Fin 5)`，使其成为`Perm (Fin 5)`中的计算。'
- en: '[PRE26]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Another way to work with concrete groups is to use free groups and group presentations.
    The free group on a type `α` is `FreeGroup α` and the inclusion map is `FreeGroup.of
    : α → FreeGroup α`. For instance let us define a type `S` with three elements
    denoted by `a`, `b` and `c`, and the element `ab⁻¹` of the corresponding free
    group.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '与此同时，使用自由群和群表示也是处理具体群的一种方法。类型`α`上的自由群是`FreeGroup α`，包含映射是`FreeGroup.of : α
    → FreeGroup α`。例如，让我们定义一个有三个元素`a`、`b`和`c`的类型`S`，以及相应自由群中的元素`ab⁻¹`。'
- en: '[PRE27]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that we gave the expected type of the definition so that Lean knows that
    `.of` means `FreeGroup.of`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们给出了定义的预期类型，这样Lean就知道`.of`意味着`FreeGroup.of`。
- en: The universal property of free groups is embodied as the equivalence `FreeGroup.lift`.
    For example, let us define the group morphism from `FreeGroup S` to `Perm (Fin
    5)` that sends `a` to `c[1, 2, 3]`, `b` to `c[2, 3, 1]`, and `c` to `c[2, 3]`,
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 自由群的通用性质体现在`FreeGroup.lift`等价性中。例如，让我们定义从`FreeGroup S`到`Perm (Fin 5)`的群同态，将`a`映射到`c[1,
    2, 3]`，将`b`映射到`c[2, 3, 1]`，将`c`映射到`c[2, 3]`，
- en: '[PRE28]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As a last concrete example, let us see how to define a group generated by a
    single element whose cube is one (so that group will be isomorphic to \(\mathbb{Z}/3\))
    and build a morphism from that group to `Perm (Fin 5)`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一个具体的例子，让我们看看如何定义一个由单个元素生成且其立方为1的群（因此该群将与 \(\mathbb{Z}/3\) 同构），并构建从该群到 `Perm
    (Fin 5)` 的态射。
- en: As a type with exactly one element, we will use `Unit` whose only element is
    denoted by `()`. The function `PresentedGroup` takes a set of relations, i.e.
    a set of elements of some free group, and returns a group that is this free group
    quotiented by a normal subgroup generated by relations. (We will see how to handle
    more general quotients in [Section 9.1.6](#quotient-groups).) Since we somehow
    hide this behind a definition, we use `deriving Group` to force creation of a
    group instance on `myGroup`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 作为只有一个元素的类型，我们将使用 `Unit`，其唯一元素由 `()` 表示。`PresentedGroup` 函数接受一个关系集，即某个自由群的一组元素，并返回一个群，该群是自由群除以由关系生成的正规子群。（我们将在[第9.1.6节](#quotient-groups)中看到如何处理更一般的商。）由于我们以某种方式将此隐藏在定义之后，我们使用
    `deriving Group` 来强制在 `myGroup` 上创建一个群实例。
- en: '[PRE29]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The universal property of presented groups ensures that morphisms out of this
    group can be built from functions that send the relations to the neutral element
    of the target group. So we need such a function and a proof that the condition
    holds. Then we can feed this proof to `PresentedGroup.toGroup` to get the desired
    group morphism.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 呈现群的全称性质确保可以从将关系映射到目标群中性元的函数构建出从这个群出去的态射。因此，我们需要这样的函数和一个证明该条件成立。然后我们可以将这个证明输入到
    `PresentedGroup.toGroup` 中，以获得所需的群态射。
- en: '[PRE30]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 9.1.5\. Group actions[](#group-actions "Link to this heading")
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.5\. 群作用[](#group-actions "链接到这个标题")
- en: One important way that group theory interacts with the rest of mathematics is
    through the use of group actions. An action of a group `G` on some type `X` is
    nothing more than a morphism from `G` to `Equiv.Perm X`. So in a sense group actions
    are already covered by the previous discussion. But we don’t want to carry this
    morphism around; instead, we want it to be inferred automatically by Lean as much
    as possible. So we have a type class for this, which is `MulAction G X`. The downside
    of this setup is that having multiple actions of the same group on the same type
    requires some contortions, such as defining type synonyms, each of which carries
    different type class instances.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 群论与数学其他部分的一个重要交互方式是通过群作用的使用。一个群 `G` 在某种类型 `X` 上的作用不过是从 `G` 到 `Equiv.Perm X`
    的一个态射。所以在某种意义上，群作用已经被之前的讨论所涵盖。但我们不希望携带这个态射；相反，我们希望尽可能由 Lean 自动推断出来。因此，我们有一个类型类来表示这一点，即
    `MulAction G X`。这种设置的缺点是，在同一个类型上有多个同一群的作用需要一些扭曲，例如定义类型同义词，每个同义词都携带不同的类型类实例。
- en: This allows us in particular to use `g • x` to denote the action of a group
    element `g` on a point `x`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这特别允许我们使用 `g • x` 来表示群元素 `g` 对点 `x` 的作用。
- en: '[PRE31]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There is also a version for additive group called `AddAction`, where the action
    is denoted by `+ᵥ`. This is used for instance in the definition of affine spaces.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个加法群的版本，称为 `AddAction`，其中作用由 `+ᵥ` 表示。这被用于例如仿射空间的定义中。
- en: '[PRE32]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The underlying group morphism is called `MulAction.toPermHom`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 基础群态射被称为 `MulAction.toPermHom`。
- en: '[PRE33]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As an illustration let us see how to define the Cayley isomorphism embedding
    of any group `G` into a permutation group, namely `Perm G`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 作为说明，让我们看看如何定义任何群 `G` 到置换群 `Perm G` 的凯莱同构嵌入。
- en: '[PRE34]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that nothing before the above definition required having a group rather
    than a monoid (or any type endowed with a multiplication operation really).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在上述定义之前，并没有要求必须有群而不是幺半群（或任何带有乘法运算的类型）。
- en: The group condition really enters the picture when we will want to partition
    `X` into orbits. The corresponding equivalence relation on `X` is called `MulAction.orbitRel`.
    It is not declared as a global instance.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将 `X` 划分为轨道时，群条件真正进入画面。`X` 上的对应等价关系称为 `MulAction.orbitRel`。它没有被声明为一个全局实例。
- en: '[PRE35]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Using this we can state that `X` is partitioned into orbits under the action
    of `G`. More precisely, we get a bijection between `X` and the dependent product
    `(ω : orbitRel.Quotient G X) × (orbit G (Quotient.out'' ω))` where `Quotient.out''
    ω` simply chooses an element that projects to `ω`. Recall that elements of this
    dependent product are pairs `⟨ω, x⟩` where the type `orbit G (Quotient.out'' ω)`
    of `x` depends on `ω`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '使用这个结果，我们可以陈述`X`在`G`的作用下被划分为轨道。更精确地说，我们得到一个从`X`到依赖积`(ω : orbitRel.Quotient
    G X) × (orbit G (Quotient.out'' ω))`的双射，其中`Quotient.out'' ω`简单地选择一个投影到`ω`的元素。回想一下，这个依赖积的元素是`⟨ω,
    x⟩`对，其中`x`的类型`orbit G (Quotient.out'' ω)`依赖于`ω`。'
- en: '[PRE36]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In particular, when X is finite, this can be combined with `Fintype.card_congr`
    and `Fintype.card_sigma` to deduce that the cardinality of `X` is the sum of the
    cardinalities of the orbits. Furthermore, the orbits are in bijection with the
    quotient of `G` under the action of the stabilizers by left translation. This
    action of a subgroup by left-translation is used to define quotients of a group
    by a subgroup with notation / so we can use the following concise statement.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，当X是有限集时，这可以与`Fintype.card_congr`和`Fintype.card_sigma`结合，推导出`X`的基数是轨道基数的和。此外，轨道与通过左平移的稳定子群作用下的`G`的商一一对应。这种通过左平移的子群作用被用来定义通过子群进行商的群，用符号/表示，因此我们可以使用以下简洁的陈述。
- en: '[PRE37]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'An important special case of combining the above two results is when `X` is
    a group `G` equipped with the action of a subgroup `H` by translation. In this
    case all stabilizers are trivial so every orbit is in bijection with `H` and we
    get:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述两个结果结合起来，一个重要的特殊情况是当`X`是一个带有子群`H`通过平移作用的群`G`。在这种情况下，所有稳定子群都是平凡的，因此每个轨道都与`H`一一对应，我们得到：
- en: '[PRE38]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is the conceptual variant of the version of Lagrange theorem that we saw
    above. Note this version makes no finiteness assumption.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上面我们看到的拉格朗日定理的概念变体。注意这个版本没有有限性的假设。
- en: As an exercise for this section, let us build the action of a group on its subgroup
    by conjugation, using our definition of `conjugate` from a previous exercise.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节的一个练习，让我们通过共轭作用来构建一个群对其子群的作用，使用我们在前一个练习中定义的`共轭`。
- en: '[PRE39]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '### 9.1.6\. Quotient groups[](#quotient-groups "Link to this heading")'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '### 9.1.6. 商群[](#quotient-groups "链接到这个标题")'
- en: In the above discussion of subgroups acting on groups, we saw the quotient `G
    ⧸ H` appear. In general this is only a type. It can be endowed with a group structure
    such that the quotient map is a group morphism if and only if `H` is a normal
    subgroup (and this group structure is then unique).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面关于子群在群上作用的讨论中，我们看到了商`G ⧸ H`的出现。在一般情况下，这只是一个类型。它可以赋予一个群结构，使得商映射是一个群同态当且仅当`H`是一个正规子群（并且这种群结构是唯一的）。
- en: The normality assumption is a type class `Subgroup.Normal` so that type class
    inference can use it to derive the group structure on the quotient.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正规性假设是一个类型类`Subgroup.Normal`，这样类型类推理就可以用它来推导商上的群结构。
- en: '[PRE40]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The universal property of quotient groups is accessed through `QuotientGroup.lift`:
    a group morphism `φ` descends to `G ⧸ N` as soon as its kernel contains `N`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`QuotientGroup.lift`可以访问商群的全称性质：一旦一个群同态`φ`的核包含`N`，它就会下降到`G ⧸ N`。
- en: '[PRE41]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The fact that the target group is called `M` is the above snippet is a clue
    that having a monoid structure on `M` would be enough.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，目标群被称为`M`是一个线索，表明在`M`上有一个幺半群结构就足够了。
- en: An important special case is when `N = ker φ`. In that case the descended morphism
    is injective and we get a group isomorphism onto its image. This result is often
    called the first isomorphism theorem.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当`N = ker φ`时，这是一个重要的特殊情况。在这种情况下，下降的同态是单射的，我们得到一个到其像上的群同构。这个结果通常被称为第一同构定理。
- en: '[PRE42]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Applying the universal property to a composition of a morphism `φ : G →* G''`
    with a quotient group projection `Quotient.mk'' N''`, we can also aim for a morphism
    from `G ⧸ N` to `G'' ⧸ N''`. The condition required on `φ` is usually formulated
    by saying “`φ` should send `N` inside `N''`.” But this is equivalent to asking
    that `φ` should pull `N''` back over `N`, and the latter condition is nicer to
    work with since the definition of pullback does not involve an existential quantifier.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '将全称性质应用于一个同态`φ : G →* G''`与商群投影`Quotient.mk'' N''`的组合，我们也可以寻求从`G ⧸ N`到`G''
    ⧸ N''`的映射。对`φ`的要求通常表述为“`φ`应该将`N`放入`N''`中。”但这等同于要求`φ`将`N''`拉回到`N`上，而后一种条件更容易处理，因为拉回的定义不涉及存在量词。'
- en: '[PRE43]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: One subtle point to keep in mind is that the type `G ⧸ N` really depends on
    `N` (up to definitional equality), so having a proof that two normal subgroups
    `N` and `M` are equal is not enough to make the corresponding quotients equal.
    However the universal properties does give an isomorphism in this case.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一个微妙之处是，类型`G ⧸ N`实际上依赖于`N`（直到定义等价），因此证明两个正规子群`N`和`M`相等不足以使相应的商相等。然而，普遍性质在这种情况下确实给出了一个同构。
- en: '[PRE44]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As a final series of exercises for this section, we will prove that if `H` and
    `K` are disjoint normal subgroups of a finite group `G` such that the product
    of their cardinalities is equal to the cardinality of `G` then `G` is isomorphic
    to `H × K`. Recall that disjoint in this context means `H ⊓ K = ⊥`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节最后的练习系列，我们将证明如果`H`和`K`是有限群`G`的互斥正规子群，且它们的基数乘积等于`G`的基数，那么`G`同构于`H × K`。请记住，在这个上下文中，“互斥”意味着`H
    ⊓ K = ⊥`。
- en: We start with playing a bit with Lagrange’s lemma, without assuming the subgroups
    are normal or disjoint.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从稍微玩一下拉格朗日引理开始，而不假设子群是正规的或互斥的。
- en: '[PRE45]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: From now on, we assume that our subgroups are normal and disjoint, and we assume
    the cardinality condition. Now we construct the first building block of the desired
    isomorphism.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，我们假设我们的子群是正规的且互斥的，并假设基数条件。现在我们构建所需同构的第一个构建块。
- en: '[PRE46]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now we can define our second building block. We will need `MonoidHom.prod`,
    which builds a morphism from `G₀` to `G₁ × G₂` out of morphisms from `G₀` to `G₁`
    and `G₂`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以定义我们的第二个构建块。我们需要`MonoidHom.prod`，它从`G₀`到`G₁ × G₂`构建一个形态，其中形态是从`G₀`到`G₁`和`G₂`的。
- en: '[PRE47]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We are ready to put all pieces together.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备将所有部件组合在一起。
- en: '[PRE48]  ## 9.2\. Rings[](#rings "Link to this heading")'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE48]  ## 9.2. 环[](#rings "链接到这个标题")'
- en: '### 9.2.1\. Rings, their units, morphisms and subrings[](#rings-their-units-morphisms-and-subrings
    "Link to this heading")'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '### 9.2.1. 环，它们的单位，形态和子环[](#rings-their-units-morphisms-and-subrings "链接到这个标题")'
- en: The type of ring structures on a type `R` is `Ring R`. The variant where multiplication
    is assumed to be commutative is `CommRing R`. We have already seen that the `ring`
    tactic will prove any equality that follows from the axioms of a commutative ring.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 类型`R`上的环结构类型是`Ring R`。假设乘法是交换的变体是`CommRing R`。我们已经看到`ring`策略将证明任何从交换环公理得出的等式。
- en: '[PRE49]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: More exotic variants do not require that the addition on `R` forms a group but
    only an additive monoid. The corresponding type classes are `Semiring R` and `CommSemiring
    R`. The type of natural numbers is an important instance of `CommSemiring R`,
    as is any type of functions taking values in the natural numbers. Another important
    example is the type of ideals in a ring, which will be discussed below. The name
    of the `ring` tactic is doubly misleading, since it assumes commutativity but
    works in semirings as well. In other words, it applies to any `CommSemiring`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 更为奇特的变体不需要`R`上的加法构成一个群，而只需要一个加法幺半群。相应的类型类是`Semiring R`和`CommSemiring R`。自然数的类型是`CommSemiring
    R`的一个重要实例，任何取自然数值的函数的类型也是如此。另一个重要例子是环中的理想类型，将在下面讨论。`ring`策略的名称是双倍误导性的，因为它假设了交换性，但在半环中也能工作。换句话说，它适用于任何`CommSemiring`。
- en: '[PRE50]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There are also versions of the ring and semiring classes that do not assume
    the existence of a multiplicative unit or the associativity of multiplication.
    We will not discuss those here.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 环和半环类的版本也有不假设存在乘法单位元或乘法结合律的情况。我们在这里不会讨论这些情况。
- en: 'Some concepts that are traditionally taught in an introduction to ring theory
    are actually about the underlying multiplicative monoid. A prominent example is
    the definition of the units of a ring. Every (multiplicative) monoid `M` has a
    predicate `IsUnit : M → Prop` asserting existence of a two-sided inverse, a type
    `Units M` of units with notation `Mˣ`, and a coercion to `M`. The type `Units
    M` bundles an invertible element with its inverse as well as properties than ensure
    that each is indeed the inverse of the other. This implementation detail is relevant
    mainly when defining computable functions. In most situations one can use `IsUnit.unit
    {x : M} : IsUnit x → Mˣ` to build a unit. In the commutative case, one also has
    `Units.mkOfMulEqOne (x y : M) : x * y = 1 → Mˣ` which builds `x` seen as unit.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '一些在环论导论中传统上教授的概念实际上是关于底乘法幺半群的。一个突出的例子是环的单位定义。每个（乘法）幺半群 `M` 都有一个谓词 `IsUnit :
    M → Prop`，断言存在一个两边的逆元，一个单位类型 `Units M`，记作 `Mˣ`，以及一个到 `M` 的强制转换。类型 `Units M` 将可逆元素与其逆元以及确保每个确实是另一个的逆元的属性捆绑在一起。这个实现细节主要在定义可计算函数时相关。在大多数情况下，可以使用
    `IsUnit.unit {x : M} : IsUnit x → Mˣ` 来构建一个单位。在交换情况下，还有一个 `Units.mkOfMulEqOne
    (x y : M) : x * y = 1 → Mˣ`，它构建了被视为单位的 `x`。'
- en: '[PRE51]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The type of ring morphisms between two (semi)-rings `R` and `S` is `RingHom
    R S`, with notation `R →+* S`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 两个（半）环 `R` 和 `S` 之间的环同态类型是 `RingHom R S`，记作 `R →+* S`。
- en: '[PRE52]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The isomorphism variant is `RingEquiv`, with notation `≃+*`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 同构变体是 `RingEquiv`，记作 `≃+*`。
- en: As with submonoids and subgroups, there is a `Subring R` type for subrings of
    a ring `R`, but this type is a lot less useful than the type of subgroups since
    one cannot quotient a ring by a subring.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与子幺半群和子群一样，存在一个 `Subring R` 类型，用于表示环 `R` 的子环，但这个类型比子群类型要少用得多，因为不能通过子环来商环。
- en: '[PRE53]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Also notice that `RingHom.range` produces a subring.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`RingHom.range` 产生一个子环。
- en: 9.2.2\. Ideals and quotients[](#ideals-and-quotients "Link to this heading")
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2\. 理想和商[](#ideals-and-quotients "链接到这个标题")
- en: For historical reasons, Mathlib only has a theory of ideals for commutative
    rings. (The ring library was originally developed to make quick progress toward
    the foundations of modern algebraic geometry.) So in this section we will work
    with commutative (semi)rings. Ideals of `R` are defined as submodules of `R` seen
    as `R`-modules. Modules will be covered later in a chapter on linear algebra,
    but this implementation detail can mostly be safely ignored since most (but not
    all) relevant lemmas are restated in the special context of ideals. But anonymous
    projection notation won’t always work as expected. For instance, one cannot replace
    `Ideal.Quotient.mk I` by `I.Quotient.mk` in the snippet below because there are
    two `.`s and so it will parse as `(Ideal.Quotient I).mk`; but `Ideal.Quotient`
    by itself doesn’t exist.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史原因，Mathlib 只为交换环提供了理想理论。（环库最初是为了快速推进现代代数几何的基础而开发的。）因此，在本节中，我们将使用交换（半）环。`R`
    的理想被定义为将 `R` 视为 `R`-模的子模。模将在线性代数章节中稍后介绍，但这个实现细节可以大部分安全忽略，因为大多数（但不是所有）相关引理都在理想的特殊上下文中重新表述。但是匿名投影符号并不总是按预期工作。例如，在下面的片段中不能将
    `Ideal.Quotient.mk I` 替换为 `I.Quotient.mk`，因为有两个 `.`，所以它将被解析为 `(Ideal.Quotient
    I).mk`；但 `Ideal.Quotient` 本身并不存在。
- en: '[PRE54]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The universal property of quotient rings is `Ideal.Quotient.lift`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 商环的泛性质是 `Ideal.Quotient.lift`。
- en: '[PRE55]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In particular it leads to the first isomorphism theorem for rings.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是导致环的第一同构定理。
- en: '[PRE56]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Ideals form a complete lattice structure with the inclusion relation, as well
    as a semiring structure. These two structures interact nicely.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 理想在包含关系下形成一个完全格结构，以及一个半环结构。这两个结构相互作用得很好。
- en: '[PRE57]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: One can use ring morphisms to push ideals forward and pull them back using `Ideal.map`
    and `Ideal.comap`, respectively. As usual, the latter is more convenient to use
    since it does not involve an existential quantifier. This explains why it is used
    to state the condition that allows us to build morphisms between quotient rings.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用环同态通过 `Ideal.map` 推理想前移，通过 `Ideal.comap` 拉回理想。通常，后者更方便使用，因为它不涉及存在量词。这解释了为什么它被用来陈述允许我们在商环之间构建同态的条件。
- en: '[PRE58]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: One subtle point is that the type `R ⧸ I` really depends on `I` (up to definitional
    equality), so having a proof that two ideals `I` and `J` are equal is not enough
    to make the corresponding quotients equal. However, the universal properties do
    provide an isomorphism in this case.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一个微妙之处在于类型`R ⧸ I`实际上依赖于`I`（直到定义等价），因此，两个理想`I`和`J`相等的证明不足以使相应的商相等。然而，普遍性质在这种情况下确实提供了一个同构。
- en: '[PRE59]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We can now present the Chinese remainder isomorphism as an example. Pay attention
    to the difference between the indexed infimum symbol `⨅` and the big product of
    types symbol `Π`. Depending on your font, those can be pretty hard to distinguish.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将中国剩余同构作为一个例子来展示。请注意，索引下确界符号`⨅`和类型的大乘积符号`Π`之间的区别。根据你的字体，这些可能很难区分。
- en: '[PRE60]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The elementary version of the Chinese remainder theorem, a statement about
    `ZMod`, can be easily deduced from the previous one:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 中国剩余定理的初等版本，一个关于`ZMod`的陈述，可以很容易地从先前的定理中推导出来：
- en: '[PRE61]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As a series of exercises, we will reprove the Chinese remainder theorem in the
    general case.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一系列练习，我们将重新证明一般情况下的中国剩余定理。
- en: We first need to define the map appearing in the theorem, as a ring morphism,
    using the universal property of quotient rings.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要定义定理中出现的映射，作为一个环同态，使用商环的普遍性质。
- en: '[PRE62]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Make sure the following next two lemmas can be proven by `rfl`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 确保以下两个引理可以通过`rfl`证明。
- en: '[PRE63]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The next lemma proves the easy half of the Chinese remainder theorem, without
    any assumption on the family of ideals. The proof is less than one line long.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个引理证明了中国剩余定理简单一半的证明，没有任何关于理想族的前提。证明不到一行长。
- en: '[PRE64]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We are now ready for the heart of the theorem, which will show the surjectivity
    of our `chineseMap`. First we need to know the different ways one can express
    the coprimality (also called co-maximality assumption). Only the first two will
    be needed below.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好证明定理的核心，这将展示我们的`chineseMap`的满射性。首先，我们需要知道表达互质（也称为共最大性假设）的不同方式。下面只需要前两种。
- en: '[PRE65]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We take the opportunity to use induction on `Finset`. Relevant lemmas on `Finset`
    are given below. Remember that the `ring` tactic works for semirings and that
    the ideals of a ring form a semiring.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用归纳法于`Finset`。以下给出了`Finset`的相关引理。记住，`ring`策略适用于半环，并且环的理想形成一个半环。
- en: '[PRE66]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We can now prove surjectivity of the map appearing in the Chinese remainder
    theorem.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以证明中国剩余定理中出现的映射的满射性。
- en: '[PRE67]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now all the pieces come together in the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的部分都在以下内容中汇集在一起：
- en: '[PRE68]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 9.2.3\. Algebras and polynomials[](#algebras-and-polynomials "Link to this
    heading")
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3\. 代数和多项式[](#algebras-and-polynomials "链接到这个标题")
- en: 'Given a commutative (semi)ring `R`, an *algebra over* `R` is a semiring `A`
    equipped with a ring morphism whose image commutes with every element of `A`.
    This is encoded as a type class `Algebra R A`. The morphism from `R` to `A` is
    called the structure map and is denoted `algebraMap R A : R →+* A` in Lean. Multiplication
    of `a : A` by `algebraMap R A r` for some `r : R` is called the scalar multiplication
    of `a` by `r` and denoted by `r • a`. Note that this notion of algebra is sometimes
    called an *associative unital algebra* to emphasize the existence of more general
    notions of algebra.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '给定一个交换（半）环`R`，一个在`R`上的代数是一个半环`A`，它配备了一个环同态，其像与`A`的每个元素交换。这被编码为类型类`Algebra R
    A`。从`R`到`A`的态射被称为结构映射，在Lean中表示为`algebraMap R A : R →+* A`。对于某个`r : R`，`a : A`通过`algebraMap
    R A r`的乘法称为`a`通过`r`的标量乘法，表示为`r • a`。请注意，这种代数的概念有时被称为*结合有单位代数*，以强调存在更一般的代数概念。'
- en: 'The fact that `algebraMap R A` is ring morphism packages together a lot of
    properties of scalar multiplication, such as the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`algebraMap R A`是环同态的事实将标量乘法的许多性质打包在一起，如下所示：'
- en: '[PRE69]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The morphisms between two `R`-algebras `A` and `B` are ring morphisms which
    commute with scalar multiplication by elements of `R`. They are bundled morphisms
    with type `AlgHom R A B`, which is denoted by `A →ₐ[R] B`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`R`-代数`A`和`B`之间的态射是环同态，并且与`R`中元素的标量乘法交换。它们是类型为`AlgHom R A B`的打包态射，表示为`A →ₐ[R]
    B`。
- en: Important examples of non-commutative algebras include algebras of endomorphisms
    and algebras of square matrices, both of which will be covered in the chapter
    on linear algebra. In this chapter we will discuss one of the most important examples
    of a commutative algebra, namely, polynomial algebras.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 非交换代数的重要例子包括自同态代数和方阵代数，这两者都将在线性代数章节中介绍。在本章中，我们将讨论一个最重要的交换代数例子，即多项式代数。
- en: The algebra of univariate polynomials with coefficients in `R` is called `Polynomial
    R`, which can be written as `R[X]` as soon as one opens the `Polynomial` namespace.
    The algebra structure map from `R` to `R[X]` is denoted by `C`, which stands for
    “constant” since the corresponding polynomial functions are always constant. The
    indeterminate is denoted by `X`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `R` 中系数的单变量多项式代数称为 `Polynomial R`，一旦打开 `Polynomial` 命名空间，就可以写成 `R[X]`。从 `R`
    到 `R[X]` 的代数结构映射用 `C` 表示，代表“常数”，因为相应的多项式函数始终是常数。不定元用 `X` 表示。
- en: '[PRE70]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In the first example above, it is crucial that we give Lean the expected type
    since it cannot be determined from the body of the definition. In the second example,
    the target polynomial algebra can be inferred from our use of `C r` since the
    type of `r` is known.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述第一个例子中，我们向 Lean 提供预期的类型至关重要，因为它不能从定义的主体中确定。在第二个例子中，目标多项式代数可以通过我们对 `C r` 的使用来推断，因为
    `r` 的类型是已知的。
- en: 'Because `C` is a ring morphism from `R` to `R[X]`, we can use all ring morphisms
    lemmas such as `map_zero`, `map_one`, `map_mul`, and `map_pow` before computing
    in the ring `R[X]`. For example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `C` 是从 `R` 到 `R[X]` 的环同态，所以我们可以在环 `R[X]` 中计算之前，使用所有环同态引理，如 `map_zero`、`map_one`、`map_mul`
    和 `map_pow`。例如：
- en: '[PRE71]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: You can access coefficients using `Polynomial.coeff`
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `Polynomial.coeff` 访问系数。
- en: '[PRE72]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Defining the degree of a polynomial is always tricky because of the special
    case of the zero polynomial. Mathlib has two variants: `Polynomial.natDegree :
    R[X] → ℕ` assigns degree `0` to the zero polynomial, and `Polynomial.degree :
    R[X] → WithBot ℕ` assigns `⊥`. In the latter, `WithBot ℕ` can be seen as `ℕ ∪
    {-∞}`, except that `-∞` is denoted `⊥`, the same symbol as the bottom element
    in a complete lattice. This special value is used as the degree of the zero polynomial,
    and it is absorbent for addition. (It is almost absorbent for multiplication,
    except that `⊥ * 0 = 0`.)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '定义多项式的次数总是很棘手，因为零多项式的特殊情况。Mathlib 有两种变体：`Polynomial.natDegree : R[X] → ℕ` 将零多项式的次数赋值为
    `0`，而 `Polynomial.degree : R[X] → WithBot ℕ` 赋值为 `⊥`。在后一种情况中，`WithBot ℕ` 可以看作是
    `ℕ ∪ {-∞}`，除了 `-∞` 用 `⊥` 表示，这与完备格中的底元素符号相同。这个特殊值被用作零多项式的次数，并且对加法具有吸收性。（对于乘法几乎具有吸收性，除了
    `⊥ * 0 = 0`。）'
- en: Morally speaking, the `degree` version is the correct one. For instance, it
    allows us to state the expected formula for the degree of a product (assuming
    the base ring has no zero divisor).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从道德上讲，`degree` 版本是正确的。例如，它允许我们陈述乘积次数的预期公式（假设基环没有零因子）。
- en: '[PRE73]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Whereas the version for `natDegree` needs to assume non-zero polynomials.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 而 `natDegree` 版本需要假设非零多项式。
- en: '[PRE74]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'However, `ℕ` is much nicer to use than `WithBot ℕ`, so Mathlib makes both versions
    available and provides lemmas to convert between them. Also, `natDegree` is the
    more convenient definition to use when computing the degree of a composition.
    Composition of polynomial is `Polynomial.comp` and we have:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`ℕ` 比使用 `WithBot ℕ` 更方便，所以 Mathlib 提供了这两种版本，并提供引理在它们之间进行转换。此外，`natDegree`
    是在计算复合次数时更方便的定义。多项式的复合是 `Polynomial.comp`，我们有：
- en: '[PRE75]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Polynomials give rise to polynomial functions: any polynomial can be evaluated
    on `R` using `Polynomial.eval`.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式产生了多项式函数：任何多项式都可以使用 `Polynomial.eval` 在 `R` 上进行评估。
- en: '[PRE76]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In particular, there is a predicate, `IsRoot`, that holds for elements `r` in
    `R` where a polynomial vanishes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，存在一个谓词 `IsRoot`，它对多项式在 `R` 中的根元素 `r` 成立。
- en: '[PRE77]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We would like to say that, assuming `R` has no zero divisor, a polynomial has
    at most as many roots as its degree, where the roots are counted with multiplicities.
    But once again the case of the zero polynomial is painful. So Mathlib defines
    `Polynomial.roots` to send a polynomial `P` to a multiset, i.e. the finite set
    that is defined to be empty if `P` is zero and the roots of `P`, with multiplicities,
    otherwise. This is defined only when the underlying ring is a domain since otherwise
    the definition does not have good properties.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想说的是，假设 `R` 没有零因子，一个多项式的根的数量最多与其次数相同，这里的根是按重数计算的。但一旦再次遇到零多项式的情况就令人痛苦。因此，Mathlib
    定义 `Polynomial.roots` 将多项式 `P` 映射到一个多重集，即如果 `P` 为零，则定义为空集，否则为 `P` 的根及其重数。这个定义仅在基础环是整环时才有效，因为否则定义不具有好的性质。
- en: '[PRE78]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Both `Polynomial.eval` and `Polynomial.roots` consider only the coefficients
    ring. They do not allow us to say that `X ^ 2 - 2 : ℚ[X]` has a root in `ℝ` or
    that `X ^ 2 + 1 : ℝ[X]` has a root in `ℂ`. For this, we need `Polynomial.aeval`,
    which will evaluate `P : R[X]` in any `R`-algebra. More precisely, given a semiring
    `A` and an instance of `Algebra R A`, `Polynomial.aeval` sends every element of
    `a` along the `R`-algebra morphism of evaluation at `a`. Since `AlgHom` has a
    coercion to functions, one can apply it to a polynomial. But `aeval` does not
    have a polynomial as an argument, so one cannot use dot notation like in `P.eval`
    above.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Polynomial.eval` 和 `Polynomial.roots` 都只考虑系数环。它们不允许我们说 `X ^ 2 - 2 : ℚ[X]`
    在 `ℝ` 中有一个根，或者 `X ^ 2 + 1 : ℝ[X]` 在 `ℂ` 中有一个根。为此，我们需要 `Polynomial.aeval`，它将在任何
    `R`-代数中评估 `P : R[X]`。更确切地说，给定一个半环 `A` 和一个 `Algebra R A` 实例，`Polynomial.aeval`
    将 `a` 的每个元素通过评估在 `a` 上的 `R`-代数同态发送。由于 `AlgHom` 有一个强制到函数的转换，因此可以将它应用于多项式。但 `aeval`
    没有以多项式作为参数，因此不能使用像上面 `P.eval` 中的点号表示法。'
- en: '[PRE79]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The function corresponding to `roots` in this context is `aroots` which takes
    a polynomial and then an algebra and outputs a multiset (with the same caveat
    about the zero polynomial as for `roots`).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，对应于 `roots` 的函数是 `aroots`，它接受一个多项式和一个代数，然后输出一个多重集（关于零多项式的警告与 `roots`
    相同）。
- en: '[PRE80]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'More generally, given an ring morphism `f : R →+* S` one can evaluate `P :
    R[X]` at a point in `S` using `Polynomial.eval₂`. This one produces an actual
    function from `R[X]` to `S` since it does not assume the existence of a `Algebra
    R S` instance, so dot notation works as you would expect.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '更一般地，给定一个环同态 `f : R →+* S`，可以使用 `Polynomial.eval₂` 在 `S` 中的某个点评估 `P : R[X]`。这个操作产生了一个从
    `R[X]` 到 `S` 的实际函数，因为它不假设存在一个 `Algebra R S` 实例，所以点号表示法按预期工作。'
- en: '[PRE81]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Let us end by mentioning multivariate polynomials briefly. Given a commutative
    semiring `R`, the `R`-algebra of polynomials with coefficients in `R` and indeterminates
    indexed by a type `σ` is `MVPolynomial σ R`. Given `i : σ`, the corresponding
    polynomial is `MvPolynomial.X i`. (As usual, one can open the `MVPolynomial` namespace
    to shorten this to `X i`.) For instance, if we want two indeterminates we can
    use `Fin 2` as `σ` and write the polynomial defining the unit circle in \(\mathbb{R}^2`\)
    as:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们简要地提一下多元多项式。给定一个交换半环 `R`，系数在 `R` 中且不定元由类型 `σ` 索引的 `R`-代数多项式是 `MVPolynomial
    σ R`。给定 `i : σ`，相应的多项式是 `MvPolynomial.X i`。（像往常一样，可以打开 `MVPolynomial` 命名空间以缩短为
    `X i`。）例如，如果我们想要两个不定元，我们可以使用 `Fin 2` 作为 `σ`，并将定义单位圆的 \(\mathbb{R}^2\) 中的多项式写为：'
- en: '[PRE82]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Recall that function application has a very high precedence so the expression
    above is read as `(X 0) ^ 2 + (X 1) ^ 2 - 1`. We can evaluate it to make sure
    the point with coordinates \((1, 0)\) is on the circle. Recall the `![...]` notation
    denotes elements of `Fin n → X` for some natural number `n` determined by the
    number of arguments and some type `X` determined by the type of arguments.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，函数应用具有非常高的优先级，因此上面的表达式读作 `(X 0) ^ 2 + (X 1) ^ 2 - 1`。我们可以评估它来确保坐标为 \((1,
    0)\) 的点在圆上。回想一下，`![...]` 符号表示由自然数 `n` 确定的 `Fin n → X` 的元素，其中 `n` 由参数的数量决定，而 `X`
    由参数的类型决定。
- en: '[PRE83] [Previous](C08_Hierarchies.html "8\. Hierarchies") [Next](C10_Linear_Algebra.html
    "10\. Linear algebra")'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE83] [上一节](C08_Hierarchies.html "8. 层次") [下一节](C10_Linear_Algebra.html "10.
    线性代数")'
- en: '* * *'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: © Copyright 2020-2025, Jeremy Avigad, Patrick Massot. Text licensed under CC
    BY 4.0.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: © 版权所有 2020-2025，Jeremy Avigad，Patrick Massot。文本许可协议为 CC BY 4.0。
- en: Built with [Sphinx](https://www.sphinx-doc.org/) using a [theme](https://github.com/readthedocs/sphinx_rtd_theme)
    provided by [Read the Docs](https://readthedocs.org). We saw in [Section 2.2](C02_Basics.html#proving-identities-in-algebraic-structures)
    how to reason about operations in groups and rings. Later, in [Section 7.2](C07_Structures.html#section-algebraic-structures),
    we saw how to define abstract algebraic structures, such as group structures,
    as well as concrete instances such as the ring structure on the Gaussian integers.
    [Chapter 8](C08_Hierarchies.html#hierarchies) explained how hierarchies of abstract
    structures are handled in Mathlib.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[Sphinx](https://www.sphinx-doc.org/)和[Read the Docs](https://readthedocs.org)提供的[主题](https://github.com/readthedocs/sphinx_rtd_theme)构建。我们在[第2.2节](C02_Basics.html#proving-identities-in-algebraic-structures)中看到了如何在群和环中推理运算。后来，在第7.2节[第7.2节](C07_Structures.html#section-algebraic-structures)中，我们看到了如何定义抽象代数结构，例如群结构，以及具体的实例，如高斯整数上的环结构。[第8章](C08_Hierarchies.html#hierarchies)解释了在Mathlib中如何处理抽象结构的层次。
- en: In this chapter we work with groups and rings in more detail. We won’t be able
    to cover every aspect of the treatment of these topics in Mathlib, especially
    since Mathlib is constantly growing. But we will provide entry points to the library
    and show how the essential concepts are used. There is some overlap with the discussion
    of [Chapter 8](C08_Hierarchies.html#hierarchies), but here we will focus on how
    to use Mathlib instead of the design decisions behind the way the topics are treated.
    So making sense of some of the examples may require reviewing the background from
    [Chapter 8](C08_Hierarchies.html#hierarchies).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更详细地处理群和环。我们无法涵盖Mathlib中这些主题处理的各个方面，特别是由于Mathlib一直在不断增长。但我们将提供库的入口点，并展示基本概念是如何使用的。与[第8章](C08_Hierarchies.html#hierarchies)的讨论有一些重叠，但在这里我们将专注于如何使用Mathlib，而不是处理这些主题的设计决策。因此，理解一些示例可能需要回顾[第8章](C08_Hierarchies.html#hierarchies)中的背景知识。
- en: '## 9.1\. Monoids and Groups[](#monoids-and-groups "Link to this heading")'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '## 9.1\. 幺半群和群[](#monoids-and-groups "链接到这个标题")'
- en: '### 9.1.1\. Monoids and their morphisms[](#monoids-and-their-morphisms "Link
    to this heading")'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '### 9.1.1\. 幺半群及其同态[](#monoids-and-their-morphisms "链接到这个标题")'
- en: Courses in abstract algebra often start with groups and then progress to rings,
    fields, and vector spaces. This involves some contortions when discussing multiplication
    on rings since the multiplication operation does not come from a group structure
    but many of the proofs carry over verbatim from group theory to this new setting.
    The most common fix, when doing mathematics with pen and paper, is to leave those
    proofs as exercises. A less efficient but safer and more formalization-friendly
    way of proceeding is to use monoids. A *monoid* structure on a type M is an internal
    composition law that is associative and has a neutral element. Monoids are used
    primarily to accommodate both groups and the multiplicative structure of rings.
    But there are also a number of natural examples; for instance, the set of natural
    numbers equipped with addition forms a monoid.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象代数课程通常从群开始，然后逐步过渡到环、域和向量空间。在讨论环上的乘法时，这涉及到一些扭曲，因为乘法运算并不来自群结构，但许多证明可以直接从群论转移到这个新环境。在用笔和纸做数学时，最常见的解决方案是将这些证明作为练习。一种不太高效但更安全、更符合形式化要求的做法是使用幺半群。一个类型M上的*幺半群*结构是一个内部组合律，它是结合的并有一个中性元素。幺半群主要用于适应群和环的乘法结构。但也有一些自然例子；例如，自然数集加上加法运算形成一个幺半群。
- en: From a practical point of view, you can mostly ignore monoids when using Mathlib.
    But you need to know they exist when you are looking for a lemma by browsing Mathlib
    files. Otherwise, you might end up looking for a statement in the group theory
    files when it is actually in the found with monoids because it does not require
    elements to be invertible.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际的角度来看，在使用Mathlib时，你可以基本上忽略幺半群。但当你通过浏览Mathlib文件寻找引理时，你需要知道它们的存在。否则，你可能会在群论文件中寻找一个陈述，而实际上它是在与幺半群一起找到的，因为它不需要元素是可逆的。
- en: The type of monoid structures on a type `M` is written `Monoid M`. The function
    `Monoid` is a type class so it will almost always appear as an instance implicit
    argument (in other words, in square brackets). By default, `Monoid` uses multiplicative
    notation for the operation; for additive notation use `AddMonoid` instead. The
    commutative versions of these structures add the prefix `Comm` before `Monoid`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `M` 上的单群结构类型写成 `Monoid M`。函数 `Monoid` 是一个类型类，所以它几乎总是作为隐式参数实例（换句话说，在方括号中）出现。默认情况下，`Monoid`
    使用乘法表示法进行操作；对于加法表示法，请使用 `AddMonoid`。这些结构的交换版本在 `Monoid` 前添加前缀 `Comm`。
- en: '[PRE84]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Note that although `AddMonoid` is found in the library, it is generally confusing
    to use additive notation with a non-commutative operation.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管 `AddMonoid` 在库中可以找到，但使用非交换操作的加法表示法通常很令人困惑。
- en: The type of morphisms between monoids `M` and `N` is called `MonoidHom M N`
    and written `M →* N`. Lean will automatically see such a morphism as a function
    from `M` to `N` when we apply it to elements of `M`. The additive version is called
    `AddMonoidHom` and written `M →+ N`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 两个单群 `M` 和 `N` 之间的同态类型称为 `MonoidHom M N`，并写成 `M →* N`。当我们将其应用于 `M` 的元素时，Lean
    会自动将此类同态视为从 `M` 到 `N` 的函数。加法版本称为 `AddMonoidHom`，并写成 `M →+ N`。
- en: '[PRE85]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: These morphisms are bundled maps, i.e. they package together a map and some
    of its properties. Remember that [Section 8.2](C08_Hierarchies.html#section-hierarchies-morphisms)
    explains bundled maps; here we simply note the slightly unfortunate consequence
    that we cannot use ordinary function composition to compose maps. Instead, we
    need to use `MonoidHom.comp` and `AddMonoidHom.comp`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这些同态是打包映射，即它们将映射及其一些属性打包在一起。记住，[第 8.2 节](C08_Hierarchies.html#section-hierarchies-morphisms)
    解释了打包映射；这里我们只是简单地指出一个不幸的后果，即我们不能使用普通函数组合来组合映射。相反，我们需要使用 `MonoidHom.comp` 和 `AddMonoidHom.comp`。
- en: '[PRE86]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 9.1.2\. Groups and their morphisms[](#groups-and-their-morphisms "Link to this
    heading")
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2\. 群及其同态[](#groups-and-their-morphisms "链接到这个标题")
- en: We will have much more to say about groups, which are monoids with the extra
    property that every element has an inverse.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有很多关于群的话要说，群是具有额外属性的单群，即每个元素都有一个逆元。
- en: '[PRE87]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Similar to the `ring` tactic that we saw earlier, there is a `group` tactic
    that proves any identity that holds in any group. (Equivalently, it proves the
    identities that hold in free groups.)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前看到的 `ring` 策略类似，存在一个 `group` 策略，它可以证明在任意群中成立的任何恒等式。（等价地，它证明了在自由群中成立的恒等式。）
- en: '[PRE88]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: There is also a tactic for identities in commutative additive groups called
    `abel`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个用于交换加法群恒等式的策略，称为 `abel`。
- en: '[PRE89]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Interestingly, a group morphism is nothing more than a monoid morphism between
    groups. So we can copy and paste one of our earlier examples, replacing `Monoid`
    with `Group`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，群同态不过是在群之间的单群同态。因此，我们可以复制并粘贴我们之前的一个例子，将 `Monoid` 替换为 `Group`。
- en: '[PRE90]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Of course we do get some new properties, such as this one:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们确实得到了一些新的属性，例如这个：
- en: '[PRE91]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: You may be worried that constructing group morphisms will require us to do unnecessary
    work since the definition of monoid morphism enforces that neutral elements are
    sent to neutral elements while this is automatic in the case of group morphisms.
    In practice the extra work is not hard, but, to avoid it, there is a function
    building a group morphism from a function between groups that is compatible with
    the composition laws.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能担心构造群同态会让我们做不必要的额外工作，因为单群同态的定义强制要求中性元素被发送到中性元素，而在群同态的情况下这是自动的。在实践中，额外的努力并不困难，但为了避免它，有一个函数可以从群之间的兼容于组合律的函数构建群同态。
- en: '[PRE92]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'There is also a type `MulEquiv` of group (or monoid) isomorphisms denoted by
    `≃*` (and `AddEquiv` denoted by `≃+` in additive notation). The inverse of `f
    : G ≃* H` is `MulEquiv.symm f : H ≃* G`, composition of `f` and `g` is `MulEquiv.trans
    f g`, and the identity isomorphism of `G` is `M̀ulEquiv.refl G`. Using anonymous
    projector notation, the first two can be written `f.symm` and `f.trans g` respectively.
    Elements of this type are automatically coerced to morphisms and functions when
    necessary.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，还有一个表示群（或单群）同构的类型 `MulEquiv`，用 `≃*` 表示（在加法表示法中用 `≃+` 表示 `AddEquiv`）。`f :
    G ≃* H` 的逆是 `MulEquiv.symm f : H ≃* G`，`f` 和 `g` 的组合是 `MulEquiv.trans f g`，恒等同构是
    `MulEquiv.refl G`。使用匿名投影符号，前两个可以分别写成 `f.symm` 和 `f.trans g`。当需要时，此类型中的元素会自动转换为同态和函数。'
- en: '[PRE93]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: One can use `MulEquiv.ofBijective` to build an isomorphism from a bijective
    morphism. Doing so makes the inverse function noncomputable.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `MulEquiv.ofBijective` 从双射同态构建同构。这样做会使逆函数不可计算。
- en: '[PRE94]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 9.1.3\. Subgroups[](#subgroups "Link to this heading")
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.3\. 子群[](#subgroups "链接到本标题")
- en: Just as group morphisms are bundled, a subgroup of `G` is also a bundled structure
    consisting of a set in `G` with the relevant closure properties.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 正如群同态是捆绑在一起一样，`G` 的一个子群也是一个由 `G` 中的集合及其相关闭包性质组成的捆绑结构。
- en: '[PRE95]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: In the example above, it is important to understand that `Subgroup G` is the
    type of subgroups of `G`, rather than a predicate `IsSubgroup H` where `H` is
    an element of `Set G`. `Subgroup G` is endowed with a coercion to `Set G` and
    a membership predicate on `G`. See [Section 8.3](C08_Hierarchies.html#section-hierarchies-subobjects)
    for an explanation of how and why this is done.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，重要的是要理解 `Subgroup G` 是 `G` 的子群类型，而不是一个谓词 `IsSubgroup H`，其中 `H` 是 `Set
    G` 的一个元素。`Subgroup G` 被赋予了到 `Set G` 的强制转换和 `G` 上的成员谓词。参见 [第 8.3 节](C08_Hierarchies.html#section-hierarchies-subobjects)
    了解如何以及为什么这样做。
- en: Of course, two subgroups are the same if and only if they have the same elements.
    This fact is registered for use with the `ext` tactic, which can be used to prove
    two subgroups are equal in the same way it is used to prove that two sets are
    equal.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果两个子群具有相同的元素，则它们是相同的。这个事实被注册用于与 `ext` 策略一起使用，该策略可以用来证明两个子群相等，就像它被用来证明两个集合相等一样。
- en: To state and prove, for example, that `ℤ` is an additive subgroup of `ℚ`, what
    we really want is to construct a term of type `AddSubgroup ℚ` whose projection
    to `Set ℚ` is `ℤ`, or, more precisely, the image of `ℤ` in `ℚ`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了陈述和证明 `ℤ` 是 `ℚ` 的加法子群，我们真正想要的是构造一个类型 `AddSubgroup ℚ` 的项，其投影到 `Set ℚ` 是
    `ℤ`，或者更精确地说，是 `ℤ` 在 `ℚ` 中的像。
- en: '[PRE96]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Using type classes, Mathlib knows that a subgroup of a group inherits a group
    structure.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型类，Mathlib 知道群的一个子群继承了群结构。
- en: '[PRE97]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'This example is subtle. The object `H` is not a type, but Lean automatically
    coerces it to a type by interpreting it as a subtype of `G`. So the above example
    can be restated more explicitly as:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很微妙。对象 `H` 不是一个类型，但 Lean 会自动将其解释为 `G` 的子类型，将其强制转换为类型。因此，上面的例子可以更明确地重述为：
- en: '[PRE98]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'An important benefit of having a type `Subgroup G` instead of a predicate `IsSubgroup
    : Set G → Prop` is that one can easily endow `Subgroup G` with additional structure.
    Importantly, it has the structure of a complete lattice structure with respect
    to inclusion. For instance, instead of having a lemma stating that an intersection
    of two subgroups of `G` is again a subgroup, we have used the lattice operation
    `⊓` to construct the intersection. We can then apply arbitrary lemmas about lattices
    to the construction.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '拥有类型 `Subgroup G` 而不是谓词 `IsSubgroup : Set G → Prop` 的重要好处是，可以轻松地为 `Subgroup
    G` 赋予额外的结构。重要的是，它具有关于包含的完备格结构。例如，我们不是通过一个引理来声明 `G` 的两个子群的交集仍然是子群，而是使用了格运算 `⊓`
    来构造交集。然后我们可以将关于格的任意引理应用于构造过程。'
- en: Let us check that the set underlying the infimum of two subgroups is indeed,
    by definition, their intersection.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证两个子群的交集的底层集合确实，根据定义，是它们的交集。
- en: '[PRE99]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: It may look strange to have a different notation for what amounts to the intersection
    of the underlying sets, but the correspondence does not carry over to the supremum
    operation and set union, since a union of subgroups is not, in general, a subgroup.
    Instead one needs to use the subgroup generated by the union, which is done using
    `Subgroup.closure`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 对于底层集合的交集使用不同的符号可能看起来很奇怪，但这种对应关系并不适用于上确界运算和集合的并集，因为子群的并集在一般情况下不是子群。相反，需要使用由并集生成的子群，这可以通过
    `Subgroup.closure` 来完成。
- en: '[PRE100]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Another subtlety is that `G` itself does not have type `Subgroup G`, so we
    need a way to talk about `G` seen as a subgroup of `G`. This is also provided
    by the lattice structure: the full subgroup is the top element of this lattice.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个微妙之处在于，`G` 本身没有类型 `Subgroup G`，因此我们需要一种方式来谈论 `G` 作为 `G` 的子群。这也由格结构提供：整个子群是这个格的顶元素。
- en: '[PRE101]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Similarly the bottom element of this lattice is the subgroup whose only element
    is the neutral element.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，这个格的底元素是只有一个中性元素的子群。
- en: '[PRE102]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: As an exercise in manipulating groups and subgroups, you can define the conjugate
    of a subgroup by an element of the ambient group.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 作为操作群和子群的一个练习，你可以定义由环境群中的元素生成的子群的共轭。
- en: '[PRE103]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Tying the previous two topics together, one can push forward and pull back subgroups
    using group morphisms. The naming convention in Mathlib is to call those operations
    `map` and `comap`. These are not the common mathematical terms, but they have
    the advantage of being shorter than “pushforward” and “direct image.”
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 将前两个主题结合起来，可以使用群同态来推前和拉回子群。Mathlib 中的命名约定是将这些操作称为 `map` 和 `comap`。这些不是常见的数学术语，但它们的优势是比“推前”和“直接像”更短。
- en: '[PRE104]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: In particular, the preimage of the bottom subgroup under a morphism `f` is a
    subgroup called the *kernel* of `f`, and the range of `f` is also a subgroup.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，映射 `f` 下底子群的逆像是称为 `f` 的 *核* 的子群，而 `f` 的值域也是一个子群。
- en: '[PRE105]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: As exercises in manipulating group morphisms and subgroups, let us prove some
    elementary properties. They are already proved in Mathlib, so do not use `exact?`
    too quickly if you want to benefit from these exercises.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 作为操作群同态和子群的计算练习，让我们证明一些基本性质。它们已经在 Mathlib 中得到了证明，所以如果你想从这些练习中受益，不要急于使用 `exact?`。
- en: '[PRE106]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Let us finish this introduction to subgroups in Mathlib with two very classical
    results. Lagrange theorem states the cardinality of a subgroup of a finite group
    divides the cardinality of the group. Sylow’s first theorem is a famous partial
    converse to Lagrange’s theorem.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用两个非常经典的结果来完成对 Mathlib 中子群的介绍。拉格朗日定理表明有限群子群的基数是群基数的约数。西罗第一定理是拉格朗日定理的一个著名的部分逆定理。
- en: While this corner of Mathlib is partly set up to allow computation, we can tell
    Lean to use nonconstructive logic anyway using the following `open scoped` command.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Mathlib的这个角落部分是为了允许计算而设置的，但我们可以使用以下 `open scoped` 命令告诉 Lean 使用非构造性逻辑。
- en: '[PRE107]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The next two exercises derive a corollary of Lagrange’s lemma. (This is also
    already in Mathlib, so do not use `exact?` too quickly.)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个练习推导出拉格朗日引理的一个推论。（这已经在 Mathlib 中了，所以不要急于使用 `exact?`。）
- en: '[PRE108]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 9.1.4\. Concrete groups[](#concrete-groups "Link to this heading")
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.4\. 具体群[](#concrete-groups "链接到这个标题")
- en: One can also manipulate concrete groups in Mathlib, although this is typically
    more complicated than working with the abstract theory. For instance, given any
    type `X`, the group of permutations of `X` is `Equiv.Perm X`. In particular the
    symmetric group \(\mathfrak{S}_n\) is `Equiv.Perm (Fin n)`. One can state abstract
    results about this group, for instance saying that `Equiv.Perm X` is generated
    by cycles if `X` is finite.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mathlib 中也可以操作具体群，尽管这通常比操作抽象理论更复杂。例如，给定任何类型 `X`，`X` 的排列群是 `Equiv.Perm X`。特别是，对称群
    \(\mathfrak{S}_n\) 是 `Equiv.Perm (Fin n)`。可以对这个群陈述抽象结果，例如，如果 `X` 是有限的，则 `Equiv.Perm
    X` 由循环生成。
- en: '[PRE109]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'One can be fully concrete and compute actual products of cycles. Below we use
    the `#simp` command, which calls the `simp` tactic on a given expression. The
    notation `c[]` is used to define a cyclic permutation. In the example, the result
    is a permutation of `ℕ`. One could use a type ascription such as `(1 : Fin 5)`
    on the first number appearing to make it a computation in `Perm (Fin 5)`.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '可以完全具体并计算循环的实际乘积。以下我们使用 `#simp` 命令，它在一个给定的表达式中调用 `simp` 策略。符号 `c[]` 用于定义循环排列。在示例中，结果是
    `ℕ` 的排列。可以在第一个数字上使用类型注解，如 `(1 : Fin 5)`，使其成为 `Perm (Fin 5)` 中的计算。'
- en: '[PRE110]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Another way to work with concrete groups is to use free groups and group presentations.
    The free group on a type `α` is `FreeGroup α` and the inclusion map is `FreeGroup.of
    : α → FreeGroup α`. For instance let us define a type `S` with three elements
    denoted by `a`, `b` and `c`, and the element `ab⁻¹` of the corresponding free
    group.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '另一种与具体群一起工作的方法是使用自由群和群表示。类型 `α` 上的自由群是 `FreeGroup α`，包含映射是 `FreeGroup.of :
    α → FreeGroup α`。例如，让我们定义一个有三个元素 `a`、`b` 和 `c` 的类型 `S`，以及对应自由群中的元素 `ab⁻¹`。'
- en: '[PRE111]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Note that we gave the expected type of the definition so that Lean knows that
    `.of` means `FreeGroup.of`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们给出了定义的预期类型，这样 Lean 就知道 `.of` 的意思是 `FreeGroup.of`。
- en: The universal property of free groups is embodied as the equivalence `FreeGroup.lift`.
    For example, let us define the group morphism from `FreeGroup S` to `Perm (Fin
    5)` that sends `a` to `c[1, 2, 3]`, `b` to `c[2, 3, 1]`, and `c` to `c[2, 3]`,
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 自由群的通用性质体现在 `FreeGroup.lift` 的等价性中。例如，让我们定义从 `FreeGroup S` 到 `Perm (Fin 5)`
    的群同态，将 `a` 映射到 `c[1, 2, 3]`，`b` 映射到 `c[2, 3, 1]`，`c` 映射到 `c[2, 3]`，
- en: '[PRE112]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: As a last concrete example, let us see how to define a group generated by a
    single element whose cube is one (so that group will be isomorphic to \(\mathbb{Z}/3\))
    and build a morphism from that group to `Perm (Fin 5)`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一个具体的例子，让我们看看如何定义一个由单个元素生成且其立方为1的群（因此该群将与\(\mathbb{Z}/3\)同构），并构建从该群到`Perm
    (Fin 5)`的态射。
- en: As a type with exactly one element, we will use `Unit` whose only element is
    denoted by `()`. The function `PresentedGroup` takes a set of relations, i.e.
    a set of elements of some free group, and returns a group that is this free group
    quotiented by a normal subgroup generated by relations. (We will see how to handle
    more general quotients in [Section 9.1.6](#quotient-groups).) Since we somehow
    hide this behind a definition, we use `deriving Group` to force creation of a
    group instance on `myGroup`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 作为只有一个元素的类型，我们将使用`Unit`，其唯一元素用`()`表示。函数`PresentedGroup`接受一组关系，即某个自由群的一组元素，并返回一个通过由关系生成的正规子群商化的自由群。
    (我们将在[第9.1.6节](#quotient-groups)中看到如何处理更一般化的商。) 由于我们以某种方式将此隐藏在定义之后，我们使用`deriving
    Group`来强制在`myGroup`上创建一个群实例。
- en: '[PRE113]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The universal property of presented groups ensures that morphisms out of this
    group can be built from functions that send the relations to the neutral element
    of the target group. So we need such a function and a proof that the condition
    holds. Then we can feed this proof to `PresentedGroup.toGroup` to get the desired
    group morphism.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 呈现群的全称性质确保了可以从将关系映射到目标群中性元素的函数构建出从这个群的外部态射。因此，我们需要这样的函数和一个证明该条件成立。然后我们可以将这个证明输入到`PresentedGroup.toGroup`中，以获得所需的群态射。
- en: '[PRE114]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 9.1.5\. Group actions[](#group-actions "Link to this heading")
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.5\. 群作用[](#group-actions "链接到本标题")
- en: One important way that group theory interacts with the rest of mathematics is
    through the use of group actions. An action of a group `G` on some type `X` is
    nothing more than a morphism from `G` to `Equiv.Perm X`. So in a sense group actions
    are already covered by the previous discussion. But we don’t want to carry this
    morphism around; instead, we want it to be inferred automatically by Lean as much
    as possible. So we have a type class for this, which is `MulAction G X`. The downside
    of this setup is that having multiple actions of the same group on the same type
    requires some contortions, such as defining type synonyms, each of which carries
    different type class instances.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 群论与数学其他部分的一个重要交互方式是通过群作用的使用。一个群`G`在某个类型`X`上的作用不过是`G`到`Equiv.Perm X`的态射。所以在某种意义上，群作用已经被之前的讨论所涵盖。但我们不希望携带这个态射；相反，我们希望尽可能由Lean自动推断出它。因此，我们有一个类型类来处理这种情况，即`MulAction
    G X`。这种设置的缺点是，在同一个类型上有多个同一群的作用需要一些扭曲，例如定义类型同义词，每个同义词都携带不同的类型类实例。
- en: This allows us in particular to use `g • x` to denote the action of a group
    element `g` on a point `x`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够特别地使用`g • x`来表示群元素`g`对点`x`的作用。
- en: '[PRE115]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: There is also a version for additive group called `AddAction`, where the action
    is denoted by `+ᵥ`. This is used for instance in the definition of affine spaces.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 对于加法群也有一个版本，称为`AddAction`，其中作用用`+ᵥ`表示。这被用于例如仿射空间的定义中。
- en: '[PRE116]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The underlying group morphism is called `MulAction.toPermHom`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 基础群态射被称为`MulAction.toPermHom`。
- en: '[PRE117]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: As an illustration let us see how to define the Cayley isomorphism embedding
    of any group `G` into a permutation group, namely `Perm G`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 作为说明，让我们看看如何定义任何群`G`的凯莱同构嵌入到排列群中，即`Perm G`。
- en: '[PRE118]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Note that nothing before the above definition required having a group rather
    than a monoid (or any type endowed with a multiplication operation really).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在上述定义之前，并没有要求必须有群而不是幺半群（或任何带有乘法运算的类型）。
- en: The group condition really enters the picture when we will want to partition
    `X` into orbits. The corresponding equivalence relation on `X` is called `MulAction.orbitRel`.
    It is not declared as a global instance.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将`X`划分为轨道时，群条件真正进入画面。`X`上的对应等价关系被称为`MulAction.orbitRel`。它没有被声明为全局实例。
- en: '[PRE119]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Using this we can state that `X` is partitioned into orbits under the action
    of `G`. More precisely, we get a bijection between `X` and the dependent product
    `(ω : orbitRel.Quotient G X) × (orbit G (Quotient.out'' ω))` where `Quotient.out''
    ω` simply chooses an element that projects to `ω`. Recall that elements of this
    dependent product are pairs `⟨ω, x⟩` where the type `orbit G (Quotient.out'' ω)`
    of `x` depends on `ω`.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '使用这个，我们可以陈述 `X` 在 `G` 的作用下被划分为轨道。更精确地说，我们得到 `X` 与依赖积 `(ω : orbitRel.Quotient
    G X) × (orbit G (Quotient.out'' ω))` 之间的双射，其中 `Quotient.out'' ω` 简单地选择一个投影到 `ω`
    的元素。回想一下，这个依赖积的元素是 `⟨ω, x⟩` 这样的对，其中 `x` 的类型 `orbit G (Quotient.out'' ω)` 依赖于 `ω`。'
- en: '[PRE120]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: In particular, when X is finite, this can be combined with `Fintype.card_congr`
    and `Fintype.card_sigma` to deduce that the cardinality of `X` is the sum of the
    cardinalities of the orbits. Furthermore, the orbits are in bijection with the
    quotient of `G` under the action of the stabilizers by left translation. This
    action of a subgroup by left-translation is used to define quotients of a group
    by a subgroup with notation / so we can use the following concise statement.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，当 `X` 是有限的，这可以与 `Fintype.card_congr` 和 `Fintype.card_sigma` 结合，推导出 `X` 的基数是轨道基数的和。此外，轨道与通过稳定子群左平移作用下的
    `G` 的商之间存在双射。这种通过左平移作用的子群作用被用来定义通过子群进行商的群，记作 /，因此我们可以使用以下简洁的陈述。
- en: '[PRE121]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'An important special case of combining the above two results is when `X` is
    a group `G` equipped with the action of a subgroup `H` by translation. In this
    case all stabilizers are trivial so every orbit is in bijection with `H` and we
    get:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的两个结果的结合的一个重要特殊情况是当 `X` 是一个带有子群 `H` 通过平移作用的群 `G`。在这种情况下，所有稳定子群都是平凡的，因此每个轨道都与
    `H` 之间存在双射，我们得到：
- en: '[PRE122]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: This is the conceptual variant of the version of Lagrange theorem that we saw
    above. Note this version makes no finiteness assumption.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上面我们看到的拉格朗日定理的概念变体。注意这个版本没有有限性的假设。
- en: As an exercise for this section, let us build the action of a group on its subgroup
    by conjugation, using our definition of `conjugate` from a previous exercise.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节的练习，让我们通过共轭使用我们之前练习中定义的 `共轭` 来构建一个群对其子群的作用。
- en: '[PRE123]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '### 9.1.6\. Quotient groups[](#quotient-groups "Link to this heading")'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '### 9.1.6. 商群[](#quotient-groups "链接到这个标题")'
- en: In the above discussion of subgroups acting on groups, we saw the quotient `G
    ⧸ H` appear. In general this is only a type. It can be endowed with a group structure
    such that the quotient map is a group morphism if and only if `H` is a normal
    subgroup (and this group structure is then unique).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述关于子群在群上作用的讨论中，我们看到了 `G ⧸ H` 的商出现。一般来说，这只是一个类型。它可以赋予一个群结构，使得商映射是一个群同态当且仅当
    `H` 是正规子群（并且这种群结构是唯一的）。
- en: The normality assumption is a type class `Subgroup.Normal` so that type class
    inference can use it to derive the group structure on the quotient.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 正规性假设是一个类型类 `Subgroup.Normal`，这样类型类推理就可以用它来推导商上的群结构。
- en: '[PRE124]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The universal property of quotient groups is accessed through `QuotientGroup.lift`:
    a group morphism `φ` descends to `G ⧸ N` as soon as its kernel contains `N`.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 商群的全称性质通过 `QuotientGroup.lift` 访问：一个群形态 `φ` 只要其核包含 `N`，就会下降到 `G ⧸ N`。
- en: '[PRE125]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The fact that the target group is called `M` is the above snippet is a clue
    that having a monoid structure on `M` would be enough.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，目标群被称为 `M` 是一个线索，表明在 `M` 上有一个幺半群结构就足够了。
- en: An important special case is when `N = ker φ`. In that case the descended morphism
    is injective and we get a group isomorphism onto its image. This result is often
    called the first isomorphism theorem.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的特殊情况是当 `N = ker φ`。在这种情况下，下降的形态是单射的，我们得到一个到其像上的群同构。这个结果通常被称为第一同构定理。
- en: '[PRE126]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Applying the universal property to a composition of a morphism `φ : G →* G''`
    with a quotient group projection `Quotient.mk'' N''`, we can also aim for a morphism
    from `G ⧸ N` to `G'' ⧸ N''`. The condition required on `φ` is usually formulated
    by saying “`φ` should send `N` inside `N''`.” But this is equivalent to asking
    that `φ` should pull `N''` back over `N`, and the latter condition is nicer to
    work with since the definition of pullback does not involve an existential quantifier.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '将通用性质应用于一个形态 `φ : G →* G''` 与商群投影 `Quotient.mk'' N''` 的组合，我们也可以寻求从 `G ⧸ N`
    到 `G'' ⧸ N''` 的形态。对 `φ` 的要求通常表述为“`φ` 应该将 `N` 发送到 `N''` 内部。”但这等同于要求 `φ` 将 `N''`
    拉回到 `N` 上，而后一种条件更容易处理，因为拉回的定义不涉及存在量词。'
- en: '[PRE127]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: One subtle point to keep in mind is that the type `G ⧸ N` really depends on
    `N` (up to definitional equality), so having a proof that two normal subgroups
    `N` and `M` are equal is not enough to make the corresponding quotients equal.
    However the universal properties does give an isomorphism in this case.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一个微妙之处是，类型 `G ⧸ N` 实际上取决于 `N`（直到定义上的等价性），因此仅仅证明两个正规子群 `N` 和 `M` 相等并不足以使相应的商相等。然而，普遍性质在这种情况下确实给出了一个同构。
- en: '[PRE128]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: As a final series of exercises for this section, we will prove that if `H` and
    `K` are disjoint normal subgroups of a finite group `G` such that the product
    of their cardinalities is equal to the cardinality of `G` then `G` is isomorphic
    to `H × K`. Recall that disjoint in this context means `H ⊓ K = ⊥`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节的最后一系列练习，我们将证明如果 `H` 和 `K` 是有限群 `G` 的不相交正规子群，且它们的基数乘积等于 `G` 的基数，那么 `G` 与
    `H × K` 同构。回忆一下，这里的“不相交”意味着 `H ⊓ K = ⊥`。
- en: We start with playing a bit with Lagrange’s lemma, without assuming the subgroups
    are normal or disjoint.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先玩一点拉格朗日引理，而不假设子群是正规的或不相交的。
- en: '[PRE129]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: From now on, we assume that our subgroups are normal and disjoint, and we assume
    the cardinality condition. Now we construct the first building block of the desired
    isomorphism.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们假设我们的子群是正规的且不相交的，并且假设基数条件。现在我们构建所需同构的第一个构建块。
- en: '[PRE130]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Now we can define our second building block. We will need `MonoidHom.prod`,
    which builds a morphism from `G₀` to `G₁ × G₂` out of morphisms from `G₀` to `G₁`
    and `G₂`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以定义我们的第二个构建块。我们需要 `MonoidHom.prod`，它从 `G₀` 到 `G₁ × G₂` 构建一个形态，其中包含从 `G₀`
    到 `G₁` 和 `G₂` 的形态。
- en: '[PRE131]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: We are ready to put all pieces together.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备将所有这些部分组合在一起。
- en: '[PRE132]  ## 9.2\. Rings[](#rings "Link to this heading")'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE132]  ## 9.2. 环[](#rings "链接到这个标题")'
- en: '### 9.2.1\. Rings, their units, morphisms and subrings[](#rings-their-units-morphisms-and-subrings
    "Link to this heading")'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '### 9.2.1. 环、它们的单位、形态和子环[](#rings-their-units-morphisms-and-subrings "链接到这个标题")'
- en: The type of ring structures on a type `R` is `Ring R`. The variant where multiplication
    is assumed to be commutative is `CommRing R`. We have already seen that the `ring`
    tactic will prove any equality that follows from the axioms of a commutative ring.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `R` 上的环结构类型是 `Ring R`。假设乘法是交换的变体是 `CommRing R`。我们已经看到，`ring` 策略将证明任何从交换环公理中得出的等价性。
- en: '[PRE133]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: More exotic variants do not require that the addition on `R` forms a group but
    only an additive monoid. The corresponding type classes are `Semiring R` and `CommSemiring
    R`. The type of natural numbers is an important instance of `CommSemiring R`,
    as is any type of functions taking values in the natural numbers. Another important
    example is the type of ideals in a ring, which will be discussed below. The name
    of the `ring` tactic is doubly misleading, since it assumes commutativity but
    works in semirings as well. In other words, it applies to any `CommSemiring`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 更奇特的变体不需要 `R` 上的加法形成一个群，而只是一个加法幺半群。相应的类型类是 `Semiring R` 和 `CommSemiring R`。自然数的类型是
    `CommSemiring R` 的重要实例，任何取自然数值的函数类型也是如此。另一个重要例子是环中的理想类型，将在下面讨论。`ring` 策略的名称具有双重误导性，因为它假设交换性，但在半环中也能工作。换句话说，它适用于任何
    `CommSemiring`。
- en: '[PRE134]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: There are also versions of the ring and semiring classes that do not assume
    the existence of a multiplicative unit or the associativity of multiplication.
    We will not discuss those here.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 环和半环类也有不假设乘法存在乘法单位或结合律的版本。我们在这里不会讨论那些。
- en: 'Some concepts that are traditionally taught in an introduction to ring theory
    are actually about the underlying multiplicative monoid. A prominent example is
    the definition of the units of a ring. Every (multiplicative) monoid `M` has a
    predicate `IsUnit : M → Prop` asserting existence of a two-sided inverse, a type
    `Units M` of units with notation `Mˣ`, and a coercion to `M`. The type `Units
    M` bundles an invertible element with its inverse as well as properties than ensure
    that each is indeed the inverse of the other. This implementation detail is relevant
    mainly when defining computable functions. In most situations one can use `IsUnit.unit
    {x : M} : IsUnit x → Mˣ` to build a unit. In the commutative case, one also has
    `Units.mkOfMulEqOne (x y : M) : x * y = 1 → Mˣ` which builds `x` seen as unit.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '一些在环论导论中传统上教授的概念实际上是关于底层的乘法幺半群。一个突出的例子是环的单位定义。每个（乘法）幺半群 `M` 都有一个谓词 `IsUnit
    : M → Prop`，断言存在一个两边的逆元，一个单位类型 `Units M`，符号为 `Mˣ`，以及一个到 `M` 的强制转换。类型 `Units M`
    将可逆元素与其逆元捆绑在一起，以及确保每个确实是另一个的逆元的属性。这个实现细节主要在定义可计算函数时相关。在大多数情况下，可以使用 `IsUnit.unit
    {x : M} : IsUnit x → Mˣ` 来构建一个单位。在交换情况下，还有一个 `Units.mkOfMulEqOne (x y : M) : x
    * y = 1 → Mˣ`，它构建了被视为单位的 `x`。'
- en: '[PRE135]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The type of ring morphisms between two (semi)-rings `R` and `S` is `RingHom
    R S`, with notation `R →+* S`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 两个（半）环 `R` 和 `S` 之间的环同态类型是 `RingHom R S`，符号为 `R →+* S`。
- en: '[PRE136]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The isomorphism variant is `RingEquiv`, with notation `≃+*`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 同构变体是 `RingEquiv`，符号为 `≃+*`。
- en: As with submonoids and subgroups, there is a `Subring R` type for subrings of
    a ring `R`, but this type is a lot less useful than the type of subgroups since
    one cannot quotient a ring by a subring.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 与子幺半群和子群一样，存在一个 `Subring R` 类型，用于表示环 `R` 的子环，但这个类型比子群的类型要少用得多，因为不能通过子环来商环。
- en: '[PRE137]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Also notice that `RingHom.range` produces a subring.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`RingHom.range` 产生一个子环。
- en: 9.2.2\. Ideals and quotients[](#ideals-and-quotients "Link to this heading")
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2\. 理想与商[](#ideals-and-quotients "链接到本标题")
- en: For historical reasons, Mathlib only has a theory of ideals for commutative
    rings. (The ring library was originally developed to make quick progress toward
    the foundations of modern algebraic geometry.) So in this section we will work
    with commutative (semi)rings. Ideals of `R` are defined as submodules of `R` seen
    as `R`-modules. Modules will be covered later in a chapter on linear algebra,
    but this implementation detail can mostly be safely ignored since most (but not
    all) relevant lemmas are restated in the special context of ideals. But anonymous
    projection notation won’t always work as expected. For instance, one cannot replace
    `Ideal.Quotient.mk I` by `I.Quotient.mk` in the snippet below because there are
    two `.`s and so it will parse as `(Ideal.Quotient I).mk`; but `Ideal.Quotient`
    by itself doesn’t exist.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史原因，Mathlib 只为交换环提供了一个理想理论。（环库最初是为了快速推进现代代数几何的基础而开发的。）因此，在本节中，我们将使用交换（半）环。`R`
    的理想被定义为将 `R` 视为 `R`-模的子模。模块将在线性代数章节中稍后讨论，但这个实现细节可以大部分安全忽略，因为大多数（但不是所有）相关引理都在理想的特殊上下文中重新表述。但匿名投影符号并不总是按预期工作。例如，在下面的片段中不能将
    `Ideal.Quotient.mk I` 替换为 `I.Quotient.mk`，因为有两个 `.`，所以它将被解析为 `(Ideal.Quotient
    I).mk`；但 `Ideal.Quotient` 本身并不存在。
- en: '[PRE138]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: The universal property of quotient rings is `Ideal.Quotient.lift`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 商环的通用性质是 `Ideal.Quotient.lift`。
- en: '[PRE139]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: In particular it leads to the first isomorphism theorem for rings.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是它导致了环的第一同构定理。
- en: '[PRE140]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Ideals form a complete lattice structure with the inclusion relation, as well
    as a semiring structure. These two structures interact nicely.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 理想在包含关系下形成一个完备格结构，以及一个半环结构。这两个结构相互作用得很好。
- en: '[PRE141]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: One can use ring morphisms to push ideals forward and pull them back using `Ideal.map`
    and `Ideal.comap`, respectively. As usual, the latter is more convenient to use
    since it does not involve an existential quantifier. This explains why it is used
    to state the condition that allows us to build morphisms between quotient rings.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用环同态通过 `Ideal.map` 推理想前移，并通过 `Ideal.comap` 拉回理想。通常，后者更方便使用，因为它不涉及存在量词。这解释了为什么它被用来陈述允许我们在商环之间构建同态的条件。
- en: '[PRE142]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: One subtle point is that the type `R ⧸ I` really depends on `I` (up to definitional
    equality), so having a proof that two ideals `I` and `J` are equal is not enough
    to make the corresponding quotients equal. However, the universal properties do
    provide an isomorphism in this case.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 一个微妙之处在于类型 `R ⧸ I` 实际上依赖于 `I`（直到定义等价），因此仅仅证明两个理想 `I` 和 `J` 相等并不足以使相应的商相等。然而，普遍性质在这种情况下确实提供了一个同构。
- en: '[PRE143]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: We can now present the Chinese remainder isomorphism as an example. Pay attention
    to the difference between the indexed infimum symbol `⨅` and the big product of
    types symbol `Π`. Depending on your font, those can be pretty hard to distinguish.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以以中国剩余同构为例来展示。请注意，索引下确界符号 `⨅` 和类型的大乘积符号 `Π` 之间的区别。根据你的字体，这些可能很难区分。
- en: '[PRE144]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The elementary version of the Chinese remainder theorem, a statement about
    `ZMod`, can be easily deduced from the previous one:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 中国剩余定理的初等版本，一个关于 `ZMod` 的陈述，可以很容易地从先前的定理中推导出来：
- en: '[PRE145]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: As a series of exercises, we will reprove the Chinese remainder theorem in the
    general case.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一系列练习，我们将重新证明一般情况下的中国剩余定理。
- en: We first need to define the map appearing in the theorem, as a ring morphism,
    using the universal property of quotient rings.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要定义定理中出现的映射，作为一个环同态，使用商环的普遍性质。
- en: '[PRE146]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Make sure the following next two lemmas can be proven by `rfl`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 确保以下两个引理可以通过 `rfl` 证明。
- en: '[PRE147]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The next lemma proves the easy half of the Chinese remainder theorem, without
    any assumption on the family of ideals. The proof is less than one line long.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个引理证明了中国剩余定理的简单一半，对理想的集合没有任何假设。证明不到一行长。
- en: '[PRE148]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: We are now ready for the heart of the theorem, which will show the surjectivity
    of our `chineseMap`. First we need to know the different ways one can express
    the coprimality (also called co-maximality assumption). Only the first two will
    be needed below.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好展示定理的核心，这将证明我们的 `chineseMap` 的满射性。首先我们需要知道表达互质（也称为共最大性假设）的不同方式。下面只需要前两种。
- en: '[PRE149]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: We take the opportunity to use induction on `Finset`. Relevant lemmas on `Finset`
    are given below. Remember that the `ring` tactic works for semirings and that
    the ideals of a ring form a semiring.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用归纳法于 `Finset`。下面给出了 `Finset` 的相关引理。记住 `ring` 策略适用于半环，并且环的理想形成一个半环。
- en: '[PRE150]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: We can now prove surjectivity of the map appearing in the Chinese remainder
    theorem.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以证明中国剩余定理中出现的映射的满射性。
- en: '[PRE151]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Now all the pieces come together in the following:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的部分都在以下内容中汇集在一起：
- en: '[PRE152]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 9.2.3\. Algebras and polynomials[](#algebras-and-polynomials "Link to this
    heading")
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3. 代数和多项式[](#algebras-and-polynomials "链接到这个标题")
- en: 'Given a commutative (semi)ring `R`, an *algebra over* `R` is a semiring `A`
    equipped with a ring morphism whose image commutes with every element of `A`.
    This is encoded as a type class `Algebra R A`. The morphism from `R` to `A` is
    called the structure map and is denoted `algebraMap R A : R →+* A` in Lean. Multiplication
    of `a : A` by `algebraMap R A r` for some `r : R` is called the scalar multiplication
    of `a` by `r` and denoted by `r • a`. Note that this notion of algebra is sometimes
    called an *associative unital algebra* to emphasize the existence of more general
    notions of algebra.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '给定一个交换（半）环 `R`，一个 `R` 上的代数是一个半环 `A`，它配备了一个环同态，其像与 `A` 的每个元素交换。这被编码为类型类 `Algebra
    R A`。从 `R` 到 `A` 的映射被称为结构映射，在 Lean 中表示为 `algebraMap R A : R →+* A`。对于某个 `r : R`，`a
    : A` 通过 `algebraMap R A r` 的乘法称为 `a` 通过 `r` 的标量乘法，表示为 `r • a`。请注意，这种代数的概念有时被称为
    *结合有单位代数*，以强调存在更一般的代数概念。'
- en: 'The fact that `algebraMap R A` is ring morphism packages together a lot of
    properties of scalar multiplication, such as the following:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`algebraMap R A` 是环同态的事实将标量乘法的许多性质打包在一起，如下所示：'
- en: '[PRE153]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: The morphisms between two `R`-algebras `A` and `B` are ring morphisms which
    commute with scalar multiplication by elements of `R`. They are bundled morphisms
    with type `AlgHom R A B`, which is denoted by `A →ₐ[R] B`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 `R`-代数 `A` 和 `B` 之间的映射是与 `R` 的元素进行标量乘法交换的环同态。它们被捆绑为具有类型 `AlgHom R A B` 的映射，表示为
    `A →ₐ[R] B`。
- en: Important examples of non-commutative algebras include algebras of endomorphisms
    and algebras of square matrices, both of which will be covered in the chapter
    on linear algebra. In this chapter we will discuss one of the most important examples
    of a commutative algebra, namely, polynomial algebras.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 非交换代数的重要例子包括自同态代数和方阵代数，这两者都将在线性代数章节中介绍。在本章中，我们将讨论一个最重要的交换代数例子，即多项式代数。
- en: The algebra of univariate polynomials with coefficients in `R` is called `Polynomial
    R`, which can be written as `R[X]` as soon as one opens the `Polynomial` namespace.
    The algebra structure map from `R` to `R[X]` is denoted by `C`, which stands for
    “constant” since the corresponding polynomial functions are always constant. The
    indeterminate is denoted by `X`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 单变量多项式代数，其系数在 `R` 中，被称为 `Polynomial R`，一旦打开 `Polynomial` 命名空间，就可以写成 `R[X]`。从
    `R` 到 `R[X]` 的代数结构映射用 `C` 表示，它代表“常数”，因为相应的多项式函数始终是常数。不定元用 `X` 表示。
- en: '[PRE154]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: In the first example above, it is crucial that we give Lean the expected type
    since it cannot be determined from the body of the definition. In the second example,
    the target polynomial algebra can be inferred from our use of `C r` since the
    type of `r` is known.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的第一个例子中，我们给 Lean 提供预期的类型是至关重要的，因为类型不能从定义的主体中确定。在第二个例子中，目标多项式代数可以通过我们使用 `C
    r` 来推断，因为 `r` 的类型是已知的。
- en: 'Because `C` is a ring morphism from `R` to `R[X]`, we can use all ring morphisms
    lemmas such as `map_zero`, `map_one`, `map_mul`, and `map_pow` before computing
    in the ring `R[X]`. For example:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `C` 是从 `R` 到 `R[X]` 的环同态，我们可以在环 `R[X]` 中计算之前使用所有环同态引理，例如 `map_zero`、`map_one`、`map_mul`
    和 `map_pow`。例如：
- en: '[PRE155]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: You can access coefficients using `Polynomial.coeff`
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `Polynomial.coeff` 访问系数。
- en: '[PRE156]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Defining the degree of a polynomial is always tricky because of the special
    case of the zero polynomial. Mathlib has two variants: `Polynomial.natDegree :
    R[X] → ℕ` assigns degree `0` to the zero polynomial, and `Polynomial.degree :
    R[X] → WithBot ℕ` assigns `⊥`. In the latter, `WithBot ℕ` can be seen as `ℕ ∪
    {-∞}`, except that `-∞` is denoted `⊥`, the same symbol as the bottom element
    in a complete lattice. This special value is used as the degree of the zero polynomial,
    and it is absorbent for addition. (It is almost absorbent for multiplication,
    except that `⊥ * 0 = 0`.)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '定义多项式的度数总是很棘手，因为零多项式的特殊情况。Mathlib 有两种变体：`Polynomial.natDegree : R[X] → ℕ` 将零多项式的度数分配为
    `0`，而 `Polynomial.degree : R[X] → WithBot ℕ` 分配 `⊥`。在后一种情况下，`WithBot ℕ` 可以看作是
    `ℕ ∪ {-∞}`，除了 `-∞` 用 `⊥` 表示，它与完备格中的底元素具有相同的符号。这个特殊值用作零多项式的度数，并且对于加法是吸收的。（对于乘法几乎也是吸收的，除了
    `⊥ * 0 = 0`。）'
- en: Morally speaking, the `degree` version is the correct one. For instance, it
    allows us to state the expected formula for the degree of a product (assuming
    the base ring has no zero divisor).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 从道德上讲，`degree` 版本是正确的。例如，它允许我们陈述乘积度数的预期公式（假设基环没有零因子）。
- en: '[PRE157]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Whereas the version for `natDegree` needs to assume non-zero polynomials.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 而 `natDegree` 的版本需要假设非零多项式。
- en: '[PRE158]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'However, `ℕ` is much nicer to use than `WithBot ℕ`, so Mathlib makes both versions
    available and provides lemmas to convert between them. Also, `natDegree` is the
    more convenient definition to use when computing the degree of a composition.
    Composition of polynomial is `Polynomial.comp` and we have:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`ℕ` 比使用 `WithBot ℕ` 更方便，因此 Mathlib 提供了这两种版本，并提供引理在它们之间进行转换。此外，`natDegree`
    是在计算复合多项式的度数时更方便的定义。多项式的复合是 `Polynomial.comp`，我们有：
- en: '[PRE159]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Polynomials give rise to polynomial functions: any polynomial can be evaluated
    on `R` using `Polynomial.eval`.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式产生多项式函数：任何多项式都可以使用 `Polynomial.eval` 在 `R` 上进行评估。
- en: '[PRE160]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: In particular, there is a predicate, `IsRoot`, that holds for elements `r` in
    `R` where a polynomial vanishes.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，有一个谓词 `IsRoot`，它对 `R` 中的元素 `r` 成立，其中多项式为零。
- en: '[PRE161]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: We would like to say that, assuming `R` has no zero divisor, a polynomial has
    at most as many roots as its degree, where the roots are counted with multiplicities.
    But once again the case of the zero polynomial is painful. So Mathlib defines
    `Polynomial.roots` to send a polynomial `P` to a multiset, i.e. the finite set
    that is defined to be empty if `P` is zero and the roots of `P`, with multiplicities,
    otherwise. This is defined only when the underlying ring is a domain since otherwise
    the definition does not have good properties.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望说，假设 `R` 没有零因子，一个多项式的根的数量最多与其次数相同，其中根是按重数计算的。但又一次，零多项式的情况很痛苦。因此，Mathlib
    定义 `Polynomial.roots` 将多项式 `P` 映射到一个多重集，即如果 `P` 是零，则定义为空集，否则是 `P` 的根，带有重数。这个定义仅在基础环是域时才有效，因为否则定义没有好的性质。
- en: '[PRE162]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Both `Polynomial.eval` and `Polynomial.roots` consider only the coefficients
    ring. They do not allow us to say that `X ^ 2 - 2 : ℚ[X]` has a root in `ℝ` or
    that `X ^ 2 + 1 : ℝ[X]` has a root in `ℂ`. For this, we need `Polynomial.aeval`,
    which will evaluate `P : R[X]` in any `R`-algebra. More precisely, given a semiring
    `A` and an instance of `Algebra R A`, `Polynomial.aeval` sends every element of
    `a` along the `R`-algebra morphism of evaluation at `a`. Since `AlgHom` has a
    coercion to functions, one can apply it to a polynomial. But `aeval` does not
    have a polynomial as an argument, so one cannot use dot notation like in `P.eval`
    above.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`Polynomial.eval` 和 `Polynomial.roots` 只考虑系数环。它们不允许我们说 `X ^ 2 - 2 : ℚ[X]` 在
    `ℝ` 中有一个根，或者 `X ^ 2 + 1 : ℝ[X]` 在 `ℂ` 中有一个根。为此，我们需要 `Polynomial.aeval`，它将在任何 `R`-代数中评估
    `P : R[X]`。更精确地说，给定一个半环 `A` 和一个 `Algebra R A` 实例，`Polynomial.aeval` 将 `a` 的每个元素发送到评估在
    `a` 上的 `R`-代数同态。由于 `AlgHom` 有一个到函数的强制转换，因此可以将它应用于多项式。但是 `aeval` 没有以多项式作为参数，因此不能使用如上
    `P.eval` 中的点符号。'
- en: '[PRE163]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: The function corresponding to `roots` in this context is `aroots` which takes
    a polynomial and then an algebra and outputs a multiset (with the same caveat
    about the zero polynomial as for `roots`).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中对应于 `roots` 的函数是 `aroots`，它接受一个多项式然后是一个代数，并输出一个多重集（与 `roots` 相同的关于零多项式的警告）。
- en: '[PRE164]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'More generally, given an ring morphism `f : R →+* S` one can evaluate `P :
    R[X]` at a point in `S` using `Polynomial.eval₂`. This one produces an actual
    function from `R[X]` to `S` since it does not assume the existence of a `Algebra
    R S` instance, so dot notation works as you would expect.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '更一般地，给定一个环同态 `f : R →+* S`，可以使用 `Polynomial.eval₂` 在 `S` 中的某一点评估 `P : R[X]`。这个操作产生了一个从
    `R[X]` 到 `S` 的实际函数，因为它不假设存在一个 `Algebra R S` 实例，所以点符号的使用方式正如你所期望的那样。'
- en: '[PRE165]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Let us end by mentioning multivariate polynomials briefly. Given a commutative
    semiring `R`, the `R`-algebra of polynomials with coefficients in `R` and indeterminates
    indexed by a type `σ` is `MVPolynomial σ R`. Given `i : σ`, the corresponding
    polynomial is `MvPolynomial.X i`. (As usual, one can open the `MVPolynomial` namespace
    to shorten this to `X i`.) For instance, if we want two indeterminates we can
    use `Fin 2` as `σ` and write the polynomial defining the unit circle in \(\mathbb{R}^2`\)
    as:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，让我们简要地提一下多元多项式。给定一个交换半环 `R`，系数在 `R` 中且变量由类型 `σ` 索引的 `R`-代数多项式是 `MVPolynomial
    σ R`。给定 `i : σ`，相应的多项式是 `MvPolynomial.X i`。（如通常一样，可以打开 `MVPolynomial` 命名空间以缩短为
    `X i`。）例如，如果我们想要两个变量，我们可以使用 `Fin 2` 作为 `σ`，并将定义单位圆的 \(\mathbb{R}^2\) 中的多项式写为：'
- en: '[PRE166]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Recall that function application has a very high precedence so the expression
    above is read as `(X 0) ^ 2 + (X 1) ^ 2 - 1`. We can evaluate it to make sure
    the point with coordinates \((1, 0)\) is on the circle. Recall the `![...]` notation
    denotes elements of `Fin n → X` for some natural number `n` determined by the
    number of arguments and some type `X` determined by the type of arguments.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，函数应用有很高的优先级，所以上面的表达式读作 `(X 0) ^ 2 + (X 1) ^ 2 - 1`。我们可以评估它以确保坐标为 \((1,
    0)\) 的点在圆上。回想一下，`![...]` 符号表示 `Fin n → X` 的元素，其中 `n` 是由参数的数量决定的某个自然数，`X` 是由参数的类型决定的某个类型。
- en: '[PRE167]  ## 9.1\. Monoids and Groups[](#monoids-and-groups "Link to this
    heading")'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE167]  ## 9.1. 单群与群[](#monoids-and-groups "链接到本标题")'
- en: '### 9.1.1\. Monoids and their morphisms[](#monoids-and-their-morphisms "Link
    to this heading")'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '### 9.1.1. 单群及其同态[](#monoids-and-their-morphisms "链接到本标题")'
- en: Courses in abstract algebra often start with groups and then progress to rings,
    fields, and vector spaces. This involves some contortions when discussing multiplication
    on rings since the multiplication operation does not come from a group structure
    but many of the proofs carry over verbatim from group theory to this new setting.
    The most common fix, when doing mathematics with pen and paper, is to leave those
    proofs as exercises. A less efficient but safer and more formalization-friendly
    way of proceeding is to use monoids. A *monoid* structure on a type M is an internal
    composition law that is associative and has a neutral element. Monoids are used
    primarily to accommodate both groups and the multiplicative structure of rings.
    But there are also a number of natural examples; for instance, the set of natural
    numbers equipped with addition forms a monoid.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象代数课程通常从群开始，然后逐步过渡到环、域和向量空间。在讨论环上的乘法时，这涉及到一些扭曲，因为乘法运算并不来自群结构，但许多证明可以直接从群论转移到这个新环境。在用笔和纸做数学时，最常见的解决办法是将这些证明作为练习。一种不太高效但更安全、更符合形式化要求的做法是使用幺半群。类型
    M 上的幺半群结构是一个内部结合律，它具有单位元。幺半群主要用于适应群和环的乘性结构。但也有一些自然例子；例如，自然数集加上加法运算形成一个幺半群。
- en: From a practical point of view, you can mostly ignore monoids when using Mathlib.
    But you need to know they exist when you are looking for a lemma by browsing Mathlib
    files. Otherwise, you might end up looking for a statement in the group theory
    files when it is actually in the found with monoids because it does not require
    elements to be invertible.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际观点来看，在使用 Mathlib 时，你可以基本上忽略幺半群。但当你浏览 Mathlib 文件寻找引理时，你需要知道它们的存在。否则，你可能会在群理论文件中寻找一个实际上在幺半群中找到的陈述，因为它们不需要元素是可逆的。
- en: The type of monoid structures on a type `M` is written `Monoid M`. The function
    `Monoid` is a type class so it will almost always appear as an instance implicit
    argument (in other words, in square brackets). By default, `Monoid` uses multiplicative
    notation for the operation; for additive notation use `AddMonoid` instead. The
    commutative versions of these structures add the prefix `Comm` before `Monoid`.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `M` 上的幺半群结构写作 `Monoid M`。函数 `Monoid` 是一个类型类，所以它几乎总是作为一个隐式参数实例（换句话说，在方括号中）出现。默认情况下，`Monoid`
    使用乘法符号表示操作；对于加法符号，请使用 `AddMonoid`。这些结构的交换版本在 `Monoid` 前添加前缀 `Comm`。
- en: '[PRE168]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Note that although `AddMonoid` is found in the library, it is generally confusing
    to use additive notation with a non-commutative operation.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管 `AddMonoid` 在库中可以找到，但使用非交换操作的加法符号通常很令人困惑。
- en: The type of morphisms between monoids `M` and `N` is called `MonoidHom M N`
    and written `M →* N`. Lean will automatically see such a morphism as a function
    from `M` to `N` when we apply it to elements of `M`. The additive version is called
    `AddMonoidHom` and written `M →+ N`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 么半群 `M` 和 `N` 之间的同态类型称为 `MonoidHom M N`，并写作 `M →* N`。当我们将其应用于 `M` 的元素时，Lean
    会自动将此类同态视为从 `M` 到 `N` 的函数。加法版本称为 `AddMonoidHom`，并写作 `M →+ N`。
- en: '[PRE169]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: These morphisms are bundled maps, i.e. they package together a map and some
    of its properties. Remember that [Section 8.2](C08_Hierarchies.html#section-hierarchies-morphisms)
    explains bundled maps; here we simply note the slightly unfortunate consequence
    that we cannot use ordinary function composition to compose maps. Instead, we
    need to use `MonoidHom.comp` and `AddMonoidHom.comp`.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 这些同态是打包映射，即它们将一个映射及其一些属性打包在一起。记住，[第 8.2 节](C08_Hierarchies.html#section-hierarchies-morphisms)
    解释了打包映射；这里我们只是简单地指出一个不太幸运的后果，即我们不能使用普通函数复合来复合映射。相反，我们需要使用 `MonoidHom.comp` 和 `AddMonoidHom.comp`。
- en: '[PRE170]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 9.1.2\. Groups and their morphisms[](#groups-and-their-morphisms "Link to this
    heading")
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2\. 群及其同态[](#groups-and-their-morphisms "链接到本标题")
- en: We will have much more to say about groups, which are monoids with the extra
    property that every element has an inverse.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有很多关于群的内容要讲，群是具有额外性质（每个元素都有一个逆元）的幺半群。
- en: '[PRE171]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Similar to the `ring` tactic that we saw earlier, there is a `group` tactic
    that proves any identity that holds in any group. (Equivalently, it proves the
    identities that hold in free groups.)
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前看到的 `ring` 策略类似，存在一个 `group` 策略可以证明在任意群中成立的任何恒等式。（等价地，它也证明了在自由群中成立的恒等式。）
- en: '[PRE172]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: There is also a tactic for identities in commutative additive groups called
    `abel`.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 对于交换加法群中的恒等式，也存在一个名为 `abel` 的策略。
- en: '[PRE173]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Interestingly, a group morphism is nothing more than a monoid morphism between
    groups. So we can copy and paste one of our earlier examples, replacing `Monoid`
    with `Group`.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，群同态不过是一个群之间的单群同态。因此，我们可以复制并粘贴我们之前的一个例子，将`Monoid`替换为`Group`。
- en: '[PRE174]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Of course we do get some new properties, such as this one:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们确实得到了一些新的属性，例如这个：
- en: '[PRE175]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: You may be worried that constructing group morphisms will require us to do unnecessary
    work since the definition of monoid morphism enforces that neutral elements are
    sent to neutral elements while this is automatic in the case of group morphisms.
    In practice the extra work is not hard, but, to avoid it, there is a function
    building a group morphism from a function between groups that is compatible with
    the composition laws.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能担心构建群同态会让我们做不必要的额外工作，因为单群同态的定义强制要求单位元被映射到单位元，而在群同态的情况下这是自动的。实际上，额外的努力并不困难，但为了避免这种额外的工作，有一个函数可以从群之间的兼容组合律的函数构建群同态。
- en: '[PRE176]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'There is also a type `MulEquiv` of group (or monoid) isomorphisms denoted by
    `≃*` (and `AddEquiv` denoted by `≃+` in additive notation). The inverse of `f
    : G ≃* H` is `MulEquiv.symm f : H ≃* G`, composition of `f` and `g` is `MulEquiv.trans
    f g`, and the identity isomorphism of `G` is `M̀ulEquiv.refl G`. Using anonymous
    projector notation, the first two can be written `f.symm` and `f.trans g` respectively.
    Elements of this type are automatically coerced to morphisms and functions when
    necessary.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，还有一个表示群（或单群）同构的类型`MulEquiv`，用`≃*`表示（在加法表示法中用`≃+`表示`AddEquiv`）。`f : G ≃*
    H`的逆是`MulEquiv.symm f : H ≃* G`，`f`和`g`的组合是`MulEquiv.trans f g`，单位同构是`MulEquiv.refl
    G`。使用匿名投影符号，前两个可以写成`f.symm`和`f.trans g`。当需要时，此类型中的元素会自动强制转换为形态和函数。'
- en: '[PRE177]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: One can use `MulEquiv.ofBijective` to build an isomorphism from a bijective
    morphism. Doing so makes the inverse function noncomputable.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`MulEquiv.ofBijective`从双射同态构建同构。这样做会使逆函数不可计算。
- en: '[PRE178]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 9.1.3\. Subgroups[](#subgroups "Link to this heading")
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.3. 子群[](#subgroups "链接到这个标题")
- en: Just as group morphisms are bundled, a subgroup of `G` is also a bundled structure
    consisting of a set in `G` with the relevant closure properties.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 正如群同态是打包的，`G`的子群也是一个由`G`中的集合及其相关闭包性质组成的打包结构。
- en: '[PRE179]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: In the example above, it is important to understand that `Subgroup G` is the
    type of subgroups of `G`, rather than a predicate `IsSubgroup H` where `H` is
    an element of `Set G`. `Subgroup G` is endowed with a coercion to `Set G` and
    a membership predicate on `G`. See [Section 8.3](C08_Hierarchies.html#section-hierarchies-subobjects)
    for an explanation of how and why this is done.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，重要的是要理解`Subgroup G`是`G`的子群类型，而不是一个谓词`IsSubgroup H`，其中`H`是`Set G`的一个元素。`Subgroup
    G`被赋予了到`Set G`的强制转换和一个在`G`上的成员谓词。参见[第8.3节](C08_Hierarchies.html#section-hierarchies-subobjects)了解如何以及为什么这样做。
- en: Of course, two subgroups are the same if and only if they have the same elements.
    This fact is registered for use with the `ext` tactic, which can be used to prove
    two subgroups are equal in the same way it is used to prove that two sets are
    equal.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果两个子群具有相同的元素，那么它们就是相同的。这个事实被注册用于与`ext`策略一起使用，它可以用来证明两个子群是相同的，就像它被用来证明两个集合是相同的一样。
- en: To state and prove, for example, that `ℤ` is an additive subgroup of `ℚ`, what
    we really want is to construct a term of type `AddSubgroup ℚ` whose projection
    to `Set ℚ` is `ℤ`, or, more precisely, the image of `ℤ` in `ℚ`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了陈述和证明`ℤ`是`ℚ`的加法子群，我们真正想要的是构建一个类型为`AddSubgroup ℚ`的项，其投影到`Set ℚ`是`ℤ`，或者更精确地说，是`ℤ`在`ℚ`中的像。
- en: '[PRE180]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Using type classes, Mathlib knows that a subgroup of a group inherits a group
    structure.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型类，Mathlib知道群的一个子群继承了群结构。
- en: '[PRE181]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'This example is subtle. The object `H` is not a type, but Lean automatically
    coerces it to a type by interpreting it as a subtype of `G`. So the above example
    can be restated more explicitly as:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很微妙。对象`H`不是一个类型，但Lean会自动将其解释为`G`的子类型，并将其强制转换为类型。因此，上述例子可以更明确地重述为：
- en: '[PRE182]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'An important benefit of having a type `Subgroup G` instead of a predicate `IsSubgroup
    : Set G → Prop` is that one can easily endow `Subgroup G` with additional structure.
    Importantly, it has the structure of a complete lattice structure with respect
    to inclusion. For instance, instead of having a lemma stating that an intersection
    of two subgroups of `G` is again a subgroup, we have used the lattice operation
    `⊓` to construct the intersection. We can then apply arbitrary lemmas about lattices
    to the construction.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '拥有 `Subgroup G` 类型而不是谓词 `IsSubgroup : Set G → Prop` 的重要好处是，可以轻松地为 `Subgroup
    G` 赋予额外的结构。重要的是，它具有关于包含的完备格结构。例如，我们不是通过一个断言两个 `G` 的子群的交集仍然是子群的引理，而是使用了格运算 `⊓`
    来构造交集。然后我们可以将关于格的任意引理应用于构造。'
- en: Let us check that the set underlying the infimum of two subgroups is indeed,
    by definition, their intersection.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证两个子群的下确界所对应的集合确实，按照定义，是它们的交集。
- en: '[PRE183]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: It may look strange to have a different notation for what amounts to the intersection
    of the underlying sets, but the correspondence does not carry over to the supremum
    operation and set union, since a union of subgroups is not, in general, a subgroup.
    Instead one needs to use the subgroup generated by the union, which is done using
    `Subgroup.closure`.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 对于底层集合交集的不同表示可能看起来很奇怪，但这个对应关系并不适用于上确界运算和集合的并集，因为子群的并集在一般情况下不是子群。相反，需要使用由并集生成的子群，这是通过
    `Subgroup.closure` 实现的。
- en: '[PRE184]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Another subtlety is that `G` itself does not have type `Subgroup G`, so we
    need a way to talk about `G` seen as a subgroup of `G`. This is also provided
    by the lattice structure: the full subgroup is the top element of this lattice.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个细微之处在于，`G` 本身并没有 `Subgroup G` 类型，因此我们需要一种方式来谈论 `G` 作为 `G` 的子群。这也由格结构提供：全子群是这个格的最高元素。
- en: '[PRE185]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Similarly the bottom element of this lattice is the subgroup whose only element
    is the neutral element.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这个格的底元素是只包含中性元素的子群。
- en: '[PRE186]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: As an exercise in manipulating groups and subgroups, you can define the conjugate
    of a subgroup by an element of the ambient group.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 作为操作群和子群的练习，你可以定义由环境群中的元素对子群进行共轭。
- en: '[PRE187]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Tying the previous two topics together, one can push forward and pull back subgroups
    using group morphisms. The naming convention in Mathlib is to call those operations
    `map` and `comap`. These are not the common mathematical terms, but they have
    the advantage of being shorter than “pushforward” and “direct image.”
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 将前两个主题结合起来，可以使用群同态来推进和拉回子群。在 Mathlib 中的命名约定是将这些操作称为 `map` 和 `comap`。这些不是常见的数学术语，但它们的优势是比“推进”和“直接像”更短。
- en: '[PRE188]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: In particular, the preimage of the bottom subgroup under a morphism `f` is a
    subgroup called the *kernel* of `f`, and the range of `f` is also a subgroup.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，在映射 `f` 下底子群的逆像是一个称为 `f` 的**核**的子群，而 `f` 的值域也是一个子群。
- en: '[PRE189]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: As exercises in manipulating group morphisms and subgroups, let us prove some
    elementary properties. They are already proved in Mathlib, so do not use `exact?`
    too quickly if you want to benefit from these exercises.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 作为操作群同态和子群练习，让我们证明一些基本性质。它们已经在 Mathlib 中得到证明，所以如果你想从这些练习中受益，不要太快地使用 `exact?`。
- en: '[PRE190]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Let us finish this introduction to subgroups in Mathlib with two very classical
    results. Lagrange theorem states the cardinality of a subgroup of a finite group
    divides the cardinality of the group. Sylow’s first theorem is a famous partial
    converse to Lagrange’s theorem.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用两个非常经典的结果来完成对 Mathlib 中子群介绍的介绍。拉格朗日定理表明有限群子群的基数是群基数的约数。西罗第一定理是拉格朗日定理的一个著名的部分逆定理。
- en: While this corner of Mathlib is partly set up to allow computation, we can tell
    Lean to use nonconstructive logic anyway using the following `open scoped` command.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Mathlib的这个角落部分是为了允许计算而设置的，但我们仍然可以使用以下 `open scoped` 命令告诉 Lean 使用非构造性逻辑。
- en: '[PRE191]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: The next two exercises derive a corollary of Lagrange’s lemma. (This is also
    already in Mathlib, so do not use `exact?` too quickly.)
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个练习推导出拉格朗日引理的一个推论。（这已经在 Mathlib 中，所以如果你想快速使用 `exact?`，不要这么做。）
- en: '[PRE192]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 9.1.4\. Concrete groups[](#concrete-groups "Link to this heading")
  id: totrans-475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.4. 具体群[](#concrete-groups "链接到这个标题")
- en: One can also manipulate concrete groups in Mathlib, although this is typically
    more complicated than working with the abstract theory. For instance, given any
    type `X`, the group of permutations of `X` is `Equiv.Perm X`. In particular the
    symmetric group \(\mathfrak{S}_n\) is `Equiv.Perm (Fin n)`. One can state abstract
    results about this group, for instance saying that `Equiv.Perm X` is generated
    by cycles if `X` is finite.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mathlib 中也可以操作具体的群，尽管这通常比操作抽象理论更复杂。例如，给定任何类型 `X`，`X` 的排列群是 `Equiv.Perm X`。特别是对称群
    \(\mathfrak{S}_n\) 是 `Equiv.Perm (Fin n)`。可以对此群陈述抽象结果，例如，如果 `X` 是有限的，则 `Equiv.Perm
    X` 由循环生成。
- en: '[PRE193]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'One can be fully concrete and compute actual products of cycles. Below we use
    the `#simp` command, which calls the `simp` tactic on a given expression. The
    notation `c[]` is used to define a cyclic permutation. In the example, the result
    is a permutation of `ℕ`. One could use a type ascription such as `(1 : Fin 5)`
    on the first number appearing to make it a computation in `Perm (Fin 5)`.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '可以完全具体并计算循环的实际乘积。以下我们使用 `#simp` 命令，该命令在给定的表达式中调用 `simp` 策略。符号 `c[]` 用于定义循环排列。在示例中，结果是
    `ℕ` 的排列。可以在第一个数字上使用类型注解，如 `(1 : Fin 5)`，使其成为 `Perm (Fin 5)` 中的计算。'
- en: '[PRE194]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Another way to work with concrete groups is to use free groups and group presentations.
    The free group on a type `α` is `FreeGroup α` and the inclusion map is `FreeGroup.of
    : α → FreeGroup α`. For instance let us define a type `S` with three elements
    denoted by `a`, `b` and `c`, and the element `ab⁻¹` of the corresponding free
    group.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '另一种处理具体群的方法是使用自由群和群表示。类型 `α` 上的自由群是 `FreeGroup α`，包含映射是 `FreeGroup.of : α →
    FreeGroup α`。例如，让我们定义一个有三个元素 `a`、`b` 和 `c` 的类型 `S`，以及相应自由群中的元素 `ab⁻¹`。'
- en: '[PRE195]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: Note that we gave the expected type of the definition so that Lean knows that
    `.of` means `FreeGroup.of`.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们给出了定义的预期类型，这样 Lean 就知道 `.of` 表示 `FreeGroup.of`。
- en: The universal property of free groups is embodied as the equivalence `FreeGroup.lift`.
    For example, let us define the group morphism from `FreeGroup S` to `Perm (Fin
    5)` that sends `a` to `c[1, 2, 3]`, `b` to `c[2, 3, 1]`, and `c` to `c[2, 3]`,
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 自由群的全称性质体现在 `FreeGroup.lift` 的等价性中。例如，让我们定义从 `FreeGroup S` 到 `Perm (Fin 5)`
    的群同态，该同态将 `a` 映射到 `c[1, 2, 3]`，将 `b` 映射到 `c[2, 3, 1]`，将 `c` 映射到 `c[2, 3]`，
- en: '[PRE196]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: As a last concrete example, let us see how to define a group generated by a
    single element whose cube is one (so that group will be isomorphic to \(\mathbb{Z}/3\))
    and build a morphism from that group to `Perm (Fin 5)`.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一个具体的例子，让我们看看如何定义一个由单个元素生成且该元素的立方为1的群（因此该群将与 \(\mathbb{Z}/3\) 同构）以及如何从该群到
    `Perm (Fin 5)` 构建一个同态。
- en: As a type with exactly one element, we will use `Unit` whose only element is
    denoted by `()`. The function `PresentedGroup` takes a set of relations, i.e.
    a set of elements of some free group, and returns a group that is this free group
    quotiented by a normal subgroup generated by relations. (We will see how to handle
    more general quotients in [Section 9.1.6](#quotient-groups).) Since we somehow
    hide this behind a definition, we use `deriving Group` to force creation of a
    group instance on `myGroup`.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 作为只有一个元素的类型，我们将使用 `Unit`，其唯一元素用 `()` 表示。`PresentedGroup` 函数接受一个关系集，即某个自由群的元素集，并返回一个群，该群是自由群除以由关系生成的正规子群的商。（我们将在
    [第 9.1.6 节](#quotient-groups) 中看到如何处理更一般的商。）由于我们以某种方式将此隐藏在定义之后，我们使用 `deriving
    Group` 来强制在 `myGroup` 上创建群实例。
- en: '[PRE197]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: The universal property of presented groups ensures that morphisms out of this
    group can be built from functions that send the relations to the neutral element
    of the target group. So we need such a function and a proof that the condition
    holds. Then we can feed this proof to `PresentedGroup.toGroup` to get the desired
    group morphism.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 呈现群的全称性质确保可以从将关系映射到目标群中性元素的函数构建出该群的外部同态。因此我们需要这样的函数以及一个证明该条件成立的证明。然后我们可以将这个证明输入到
    `PresentedGroup.toGroup` 中，以获得所需的群同态。
- en: '[PRE198]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 9.1.5\. Group actions[](#group-actions "Link to this heading")
  id: totrans-490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.5. 群作用[](#group-actions "链接到本标题")
- en: One important way that group theory interacts with the rest of mathematics is
    through the use of group actions. An action of a group `G` on some type `X` is
    nothing more than a morphism from `G` to `Equiv.Perm X`. So in a sense group actions
    are already covered by the previous discussion. But we don’t want to carry this
    morphism around; instead, we want it to be inferred automatically by Lean as much
    as possible. So we have a type class for this, which is `MulAction G X`. The downside
    of this setup is that having multiple actions of the same group on the same type
    requires some contortions, such as defining type synonyms, each of which carries
    different type class instances.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 群论与数学其他部分的一个重要交互方式是通过群作用的使用。一个群 `G` 对某些类型 `X` 的作用不过是 `G` 到 `Equiv.Perm X` 的一个同态。所以在某种意义上，群作用已经被之前的讨论所涵盖。但我们不希望携带这个同态；相反，我们希望尽可能由
    Lean 自动推断出来。因此，我们有一个类型类来表示这一点，即 `MulAction G X`。这种设置的缺点是，在同一个类型上有多个相同群的多个作用需要一些扭曲，例如定义类型同义词，每个同义词都携带不同的类型类实例。
- en: This allows us in particular to use `g • x` to denote the action of a group
    element `g` on a point `x`.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们特别可以使用 `g • x` 来表示群元素 `g` 对点 `x` 的作用。
- en: '[PRE199]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: There is also a version for additive group called `AddAction`, where the action
    is denoted by `+ᵥ`. This is used for instance in the definition of affine spaces.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种加法群版本，称为 `AddAction`，其中作用由 `+ᵥ` 表示。这在仿射空间的定义中得到了应用。
- en: '[PRE200]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: The underlying group morphism is called `MulAction.toPermHom`.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 基础群同态被称为 `MulAction.toPermHom`。
- en: '[PRE201]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: As an illustration let us see how to define the Cayley isomorphism embedding
    of any group `G` into a permutation group, namely `Perm G`.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节的练习，让我们看看如何定义任何群 `G` 到排列群 `Perm G` 的凯莱同构嵌入。
- en: '[PRE202]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Note that nothing before the above definition required having a group rather
    than a monoid (or any type endowed with a multiplication operation really).
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，上述定义之前没有任何东西要求必须有群而不是幺半群（或任何带有乘法运算的类型）。
- en: The group condition really enters the picture when we will want to partition
    `X` into orbits. The corresponding equivalence relation on `X` is called `MulAction.orbitRel`.
    It is not declared as a global instance.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将 `X` 划分为轨道时，群条件真正进入画面。`X` 上的对应等价关系被称为 `MulAction.orbitRel`。它没有被声明为全局实例。
- en: '[PRE203]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Using this we can state that `X` is partitioned into orbits under the action
    of `G`. More precisely, we get a bijection between `X` and the dependent product
    `(ω : orbitRel.Quotient G X) × (orbit G (Quotient.out'' ω))` where `Quotient.out''
    ω` simply chooses an element that projects to `ω`. Recall that elements of this
    dependent product are pairs `⟨ω, x⟩` where the type `orbit G (Quotient.out'' ω)`
    of `x` depends on `ω`.'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '使用这种方法，我们可以陈述 `X` 在 `G` 的作用下被划分为轨道。更精确地说，我们得到 `X` 与依赖积 `(ω : orbitRel.Quotient
    G X) × (orbit G (Quotient.out'' ω))` 之间的双射，其中 `Quotient.out'' ω` 简单地选择一个投影到 `ω`
    的元素。回想一下，这个依赖积的元素是成对出现的 `⟨ω, x⟩`，其中 `x` 的类型 `orbit G (Quotient.out'' ω)` 依赖于 `ω`。'
- en: '[PRE204]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: In particular, when X is finite, this can be combined with `Fintype.card_congr`
    and `Fintype.card_sigma` to deduce that the cardinality of `X` is the sum of the
    cardinalities of the orbits. Furthermore, the orbits are in bijection with the
    quotient of `G` under the action of the stabilizers by left translation. This
    action of a subgroup by left-translation is used to define quotients of a group
    by a subgroup with notation / so we can use the following concise statement.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，当 `X` 是有限集时，这可以与 `Fintype.card_congr` 和 `Fintype.card_sigma` 结合，推导出 `X`
    的基数是轨道基数的和。此外，轨道与通过左平移的稳定子群作用下的 `G` 的商一一对应。这种通过左平移的子群作用被用来定义子群下的群商，记作 /，因此我们可以使用以下简洁的陈述。
- en: '[PRE205]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'An important special case of combining the above two results is when `X` is
    a group `G` equipped with the action of a subgroup `H` by translation. In this
    case all stabilizers are trivial so every orbit is in bijection with `H` and we
    get:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述两个结果结合的重要特殊情况是当 `X` 是一个带有子群 `H` 通过平移作用的群 `G`。在这种情况下，所有稳定子群都是平凡的，因此每个轨道都与
    `H` 一一对应，我们得到：
- en: '[PRE206]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: This is the conceptual variant of the version of Lagrange theorem that we saw
    above. Note this version makes no finiteness assumption.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上述拉格朗日定理版本的概念变体。注意这个版本没有有限性的假设。
- en: As an exercise for this section, let us build the action of a group on its subgroup
    by conjugation, using our definition of `conjugate` from a previous exercise.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节的练习，让我们通过使用之前练习中定义的 `conjugate` 来构建群在其子群上的共轭作用。
- en: '[PRE207]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '### 9.1.6\. Quotient groups[](#quotient-groups "Link to this heading")'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '### 9.1.6\. 商群[](#quotient-groups "链接到这个标题")'
- en: In the above discussion of subgroups acting on groups, we saw the quotient `G
    ⧸ H` appear. In general this is only a type. It can be endowed with a group structure
    such that the quotient map is a group morphism if and only if `H` is a normal
    subgroup (and this group structure is then unique).
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述关于子群在群上作用的讨论中，我们看到了商`G ⧸ H`的出现。一般来说，这只是一个类型。它可以赋予一个群结构，使得商映射是一个群同态，当且仅当`H`是一个正规子群（在这种情况下，这种群结构是唯一的）。
- en: The normality assumption is a type class `Subgroup.Normal` so that type class
    inference can use it to derive the group structure on the quotient.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 正规性假设是一个类型类`Subgroup.Normal`，这样类型类推理就可以用它来推导商群上的群结构。
- en: '[PRE208]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'The universal property of quotient groups is accessed through `QuotientGroup.lift`:
    a group morphism `φ` descends to `G ⧸ N` as soon as its kernel contains `N`.'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 商群的全称性质通过`QuotientGroup.lift`访问：一个群同态`φ`一旦其核包含`N`，就会下降到`G ⧸ N`。
- en: '[PRE209]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: The fact that the target group is called `M` is the above snippet is a clue
    that having a monoid structure on `M` would be enough.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 目标群被称为`M`的事实是上述代码片段的一个线索，表明在`M`上有一个单群结构就足够了。
- en: An important special case is when `N = ker φ`. In that case the descended morphism
    is injective and we get a group isomorphism onto its image. This result is often
    called the first isomorphism theorem.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的特殊情况是当`N = ker φ`时。在这种情况下，下降的同态是单射的，我们得到一个到其像上的群同构。这个结果通常被称为第一同构定理。
- en: '[PRE210]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'Applying the universal property to a composition of a morphism `φ : G →* G''`
    with a quotient group projection `Quotient.mk'' N''`, we can also aim for a morphism
    from `G ⧸ N` to `G'' ⧸ N''`. The condition required on `φ` is usually formulated
    by saying “`φ` should send `N` inside `N''`.” But this is equivalent to asking
    that `φ` should pull `N''` back over `N`, and the latter condition is nicer to
    work with since the definition of pullback does not involve an existential quantifier.'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '将全称性质应用于一个同态`φ : G →* G''`与商群投影`Quotient.mk'' N''`的组合，我们也可以寻求一个从`G ⧸ N`到`G''
    ⧸ N''`的同态。对`φ`的要求通常表述为“`φ`应该将`N`放入`N''`内部。”但这等同于要求`φ`将`N''`拉回到`N`上，而后一种条件更容易处理，因为拉回的定义不涉及存在量词。'
- en: '[PRE211]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: One subtle point to keep in mind is that the type `G ⧸ N` really depends on
    `N` (up to definitional equality), so having a proof that two normal subgroups
    `N` and `M` are equal is not enough to make the corresponding quotients equal.
    However the universal properties does give an isomorphism in this case.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一个微妙之处是，类型`G ⧸ N`实际上依赖于`N`（直到定义等价），所以有两个正规子群`N`和`M`相等的证明并不足以使相应的商相等。然而，全称性质在这种情况下确实给出了一个同构。
- en: '[PRE212]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: As a final series of exercises for this section, we will prove that if `H` and
    `K` are disjoint normal subgroups of a finite group `G` such that the product
    of their cardinalities is equal to the cardinality of `G` then `G` is isomorphic
    to `H × K`. Recall that disjoint in this context means `H ⊓ K = ⊥`.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节最后的练习，我们将证明如果`H`和`K`是有限群`G`的互斥正规子群，并且它们的基数乘积等于`G`的基数，那么`G`同构于`H × K`。请记住，在这个上下文中，“互斥”意味着`H
    ⊓ K = ⊥`。
- en: We start with playing a bit with Lagrange’s lemma, without assuming the subgroups
    are normal or disjoint.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先对拉格朗日引理进行一些探索，而不假设子群是正规的或互斥的。
- en: '[PRE213]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: From now on, we assume that our subgroups are normal and disjoint, and we assume
    the cardinality condition. Now we construct the first building block of the desired
    isomorphism.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们假设我们的子群是正规的且互斥的，并且假设基数条件。现在我们构建所需同构的第一个构建块。
- en: '[PRE214]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: Now we can define our second building block. We will need `MonoidHom.prod`,
    which builds a morphism from `G₀` to `G₁ × G₂` out of morphisms from `G₀` to `G₁`
    and `G₂`.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以定义我们的第二个构建块。我们需要`MonoidHom.prod`，它从`G₀`到`G₁ × G₂`的映射中构建一个同态，这些映射是从`G₀`到`G₁`和`G₂`的映射。
- en: '[PRE215]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: We are ready to put all pieces together.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好将所有这些部分组合在一起。
- en: '[PRE216]  ### 9.1.1\. Monoids and their morphisms[](#monoids-and-their-morphisms
    "Link to this heading")'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE216]  ### 9.1.1\. 单群及其同态[](#monoids-and-their-morphisms "链接到这个标题")'
- en: Courses in abstract algebra often start with groups and then progress to rings,
    fields, and vector spaces. This involves some contortions when discussing multiplication
    on rings since the multiplication operation does not come from a group structure
    but many of the proofs carry over verbatim from group theory to this new setting.
    The most common fix, when doing mathematics with pen and paper, is to leave those
    proofs as exercises. A less efficient but safer and more formalization-friendly
    way of proceeding is to use monoids. A *monoid* structure on a type M is an internal
    composition law that is associative and has a neutral element. Monoids are used
    primarily to accommodate both groups and the multiplicative structure of rings.
    But there are also a number of natural examples; for instance, the set of natural
    numbers equipped with addition forms a monoid.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象代数课程通常从群开始，然后逐步过渡到环、域和向量空间。在讨论环上的乘法时，这涉及到一些扭曲，因为乘法运算并不来自群结构，但许多证明可以直接从群论转移到这个新环境。在用笔和纸做数学时，最常见的解决办法是将这些证明作为练习题。一种不太高效但更安全、更符合形式化要求的做法是使用幺半群。在类型
    M 上的幺半群结构是一个内部组合律，它是结合的并且有一个中性元素。幺半群主要用于适应群和环的乘性结构。但也有一些自然例子；例如，自然数集加上加法运算形成一个幺半群。
- en: From a practical point of view, you can mostly ignore monoids when using Mathlib.
    But you need to know they exist when you are looking for a lemma by browsing Mathlib
    files. Otherwise, you might end up looking for a statement in the group theory
    files when it is actually in the found with monoids because it does not require
    elements to be invertible.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际观点来看，在使用 Mathlib 时，你可以基本上忽略幺半群。但当你浏览 Mathlib 文件寻找引理时，你需要知道它们的存在。否则，你可能会在群理论文件中寻找一个陈述，而实际上它是在与幺半群一起找到的，因为它不需要元素是可逆的。
- en: The type of monoid structures on a type `M` is written `Monoid M`. The function
    `Monoid` is a type class so it will almost always appear as an instance implicit
    argument (in other words, in square brackets). By default, `Monoid` uses multiplicative
    notation for the operation; for additive notation use `AddMonoid` instead. The
    commutative versions of these structures add the prefix `Comm` before `Monoid`.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `M` 上的幺半群结构类型写作 `Monoid M`。函数 `Monoid` 是一个类型类，所以它几乎总是作为一个隐式参数实例（换句话说，在方括号中）出现。默认情况下，`Monoid`
    使用乘法符号进行操作；对于加法符号，请使用 `AddMonoid`。这些结构的交换版本在 `Monoid` 前添加前缀 `Comm`。
- en: '[PRE217]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: Note that although `AddMonoid` is found in the library, it is generally confusing
    to use additive notation with a non-commutative operation.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管 `AddMonoid` 在库中可以找到，但使用非交换操作的加法符号通常很令人困惑。
- en: The type of morphisms between monoids `M` and `N` is called `MonoidHom M N`
    and written `M →* N`. Lean will automatically see such a morphism as a function
    from `M` to `N` when we apply it to elements of `M`. The additive version is called
    `AddMonoidHom` and written `M →+ N`.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 么半群 `M` 和 `N` 之间的形态类型称为 `MonoidHom M N`，并写作 `M →* N`。当我们将其应用于 `M` 的元素时，Lean
    会自动将这样的形态视为从 `M` 到 `N` 的函数。加法版本的形态类型称为 `AddMonoidHom`，并写作 `M →+ N`。
- en: '[PRE218]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: These morphisms are bundled maps, i.e. they package together a map and some
    of its properties. Remember that [Section 8.2](C08_Hierarchies.html#section-hierarchies-morphisms)
    explains bundled maps; here we simply note the slightly unfortunate consequence
    that we cannot use ordinary function composition to compose maps. Instead, we
    need to use `MonoidHom.comp` and `AddMonoidHom.comp`.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 这些形态是打包映射，即它们将一个映射及其一些属性打包在一起。记住，[第 8.2 节](C08_Hierarchies.html#section-hierarchies-morphisms)
    解释了打包映射；这里我们只是简单地指出一个不太幸运的后果，即我们不能使用普通函数复合来复合映射。相反，我们需要使用 `MonoidHom.comp` 和 `AddMonoidHom.comp`。
- en: '[PRE219]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 9.1.2\. Groups and their morphisms[](#groups-and-their-morphisms "Link to this
    heading")
  id: totrans-543
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2. 群及其形态[](#groups-and-their-morphisms "链接到本标题")
- en: We will have much more to say about groups, which are monoids with the extra
    property that every element has an inverse.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有很多关于群的内容要讲，群是具有每个元素都有逆元的额外属性的幺半群。
- en: '[PRE220]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: Similar to the `ring` tactic that we saw earlier, there is a `group` tactic
    that proves any identity that holds in any group. (Equivalently, it proves the
    identities that hold in free groups.)
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前看到的 `ring` 策略类似，存在一个 `group` 策略可以证明任何在任意群中成立的恒等式。（等价地，它证明了在自由群中成立的恒等式。）
- en: '[PRE221]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: There is also a tactic for identities in commutative additive groups called
    `abel`.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个用于交换加法群恒等式的策略，称为 `abel`。
- en: '[PRE222]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: Interestingly, a group morphism is nothing more than a monoid morphism between
    groups. So we can copy and paste one of our earlier examples, replacing `Monoid`
    with `Group`.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，群同态不过是一个群之间的幺半群同态。因此，我们可以复制并粘贴我们早期的一个例子，将 `Monoid` 替换为 `Group`。
- en: '[PRE223]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'Of course we do get some new properties, such as this one:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们确实得到了一些新的属性，例如这个：
- en: '[PRE224]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: You may be worried that constructing group morphisms will require us to do unnecessary
    work since the definition of monoid morphism enforces that neutral elements are
    sent to neutral elements while this is automatic in the case of group morphisms.
    In practice the extra work is not hard, but, to avoid it, there is a function
    building a group morphism from a function between groups that is compatible with
    the composition laws.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能担心构建群同态将需要我们做不必要的额外工作，因为幺半群同态的定义强制要求中性元素被发送到中性元素，而在群同态的情况下这是自动的。在实践中，额外的努力并不困难，但为了避免这种情况，有一个函数可以从群之间的函数构建群同态，该函数与组合法则兼容。
- en: '[PRE225]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'There is also a type `MulEquiv` of group (or monoid) isomorphisms denoted by
    `≃*` (and `AddEquiv` denoted by `≃+` in additive notation). The inverse of `f
    : G ≃* H` is `MulEquiv.symm f : H ≃* G`, composition of `f` and `g` is `MulEquiv.trans
    f g`, and the identity isomorphism of `G` is `M̀ulEquiv.refl G`. Using anonymous
    projector notation, the first two can be written `f.symm` and `f.trans g` respectively.
    Elements of this type are automatically coerced to morphisms and functions when
    necessary.'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，还有一个表示群（或幺半群）同构的类型 `MulEquiv`，用 `≃*` 表示（在加法表示法中用 `≃+` 表示 `AddEquiv`）。`f
    : G ≃* H` 的逆是 `MulEquiv.symm f : H ≃* G`，`f` 和 `g` 的复合是 `MulEquiv.trans f g`，而
    `G` 的恒等同构是 `MulEquiv.refl G`。使用匿名投影符号，前两个可以分别写成 `f.symm` 和 `f.trans g`。当需要时，此类型中的元素会自动转换为形态和函数。'
- en: '[PRE226]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: One can use `MulEquiv.ofBijective` to build an isomorphism from a bijective
    morphism. Doing so makes the inverse function noncomputable.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `MulEquiv.ofBijective` 从双射形态构建同构。这样做会使逆函数不可计算。
- en: '[PRE227]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 9.1.3\. Subgroups[](#subgroups "Link to this heading")
  id: totrans-560
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.3. 子群[](#subgroups "链接到本标题")
- en: Just as group morphisms are bundled, a subgroup of `G` is also a bundled structure
    consisting of a set in `G` with the relevant closure properties.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 正如群同态是打包的，`G` 的一个子群也是一个打包的结构，由 `G` 中的一个集合及其相关的闭包性质组成。
- en: '[PRE228]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: In the example above, it is important to understand that `Subgroup G` is the
    type of subgroups of `G`, rather than a predicate `IsSubgroup H` where `H` is
    an element of `Set G`. `Subgroup G` is endowed with a coercion to `Set G` and
    a membership predicate on `G`. See [Section 8.3](C08_Hierarchies.html#section-hierarchies-subobjects)
    for an explanation of how and why this is done.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，重要的是要理解 `Subgroup G` 是 `G` 的子群类型，而不是一个谓词 `IsSubgroup H`，其中 `H` 是 `Set
    G` 的一个元素。`Subgroup G` 被赋予了到 `Set G` 的强制转换和 `G` 上的成员谓词。参见 [第 8.3 节](C08_Hierarchies.html#section-hierarchies-subobjects)
    了解如何以及为什么这样做。
- en: Of course, two subgroups are the same if and only if they have the same elements.
    This fact is registered for use with the `ext` tactic, which can be used to prove
    two subgroups are equal in the same way it is used to prove that two sets are
    equal.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果两个子群具有相同的元素，则它们是相同的。这一事实被注册用于 `ext` 策略，该策略可以用来证明两个子群相等，就像它被用来证明两个集合相等一样。
- en: To state and prove, for example, that `ℤ` is an additive subgroup of `ℚ`, what
    we really want is to construct a term of type `AddSubgroup ℚ` whose projection
    to `Set ℚ` is `ℤ`, or, more precisely, the image of `ℤ` in `ℚ`.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 要陈述和证明，例如，`ℤ` 是 `ℚ` 的加法子群，我们真正想要的是构造一个类型为 `AddSubgroup ℚ` 的项，其投影到 `Set ℚ` 是
    `ℤ`，或者更精确地说，是 `ℤ` 在 `ℚ` 中的像。
- en: '[PRE229]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: Using type classes, Mathlib knows that a subgroup of a group inherits a group
    structure.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型类，Mathlib 知道群的一个子群继承了群结构。
- en: '[PRE230]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'This example is subtle. The object `H` is not a type, but Lean automatically
    coerces it to a type by interpreting it as a subtype of `G`. So the above example
    can be restated more explicitly as:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很微妙。对象 `H` 不是一个类型，但 Lean 会自动将其解释为 `G` 的子类型，从而将其强制转换为类型。因此，上述例子可以更明确地重述为：
- en: '[PRE231]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'An important benefit of having a type `Subgroup G` instead of a predicate `IsSubgroup
    : Set G → Prop` is that one can easily endow `Subgroup G` with additional structure.
    Importantly, it has the structure of a complete lattice structure with respect
    to inclusion. For instance, instead of having a lemma stating that an intersection
    of two subgroups of `G` is again a subgroup, we have used the lattice operation
    `⊓` to construct the intersection. We can then apply arbitrary lemmas about lattices
    to the construction.'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '拥有类型 `Subgroup G` 而不是谓词 `IsSubgroup : Set G → Prop` 的重要好处是，可以轻松地为 `Subgroup
    G` 赋予额外的结构。重要的是，它具有关于包含的完备格结构。例如，我们不是用命题说明 `G` 的两个子群的交集仍然是子群，而是使用了格运算 `⊓` 来构造交集。然后我们可以将关于格的任意引理应用于构造。'
- en: Let us check that the set underlying the infimum of two subgroups is indeed,
    by definition, their intersection.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查两个子群下确界的底层集合确实，按照定义，是它们的交集。
- en: '[PRE232]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: It may look strange to have a different notation for what amounts to the intersection
    of the underlying sets, but the correspondence does not carry over to the supremum
    operation and set union, since a union of subgroups is not, in general, a subgroup.
    Instead one needs to use the subgroup generated by the union, which is done using
    `Subgroup.closure`.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 对于底层集合交集的表示使用不同的符号可能看起来很奇怪，但这个对应关系并不适用于上确界运算和集合的并集，因为子群的并集在一般情况下不是子群。相反，需要使用由并集生成的子群，这可以通过
    `Subgroup.closure` 实现。
- en: '[PRE233]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'Another subtlety is that `G` itself does not have type `Subgroup G`, so we
    need a way to talk about `G` seen as a subgroup of `G`. This is also provided
    by the lattice structure: the full subgroup is the top element of this lattice.'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个细微之处在于，`G` 本身并没有类型 `Subgroup G`，因此我们需要一种方式来谈论 `G` 作为 `G` 的子群。这一点也由格结构提供：全子群是这个格的最高元素。
- en: '[PRE234]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: Similarly the bottom element of this lattice is the subgroup whose only element
    is the neutral element.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，这个格的底部元素是只包含中性元素的子群。
- en: '[PRE235]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: As an exercise in manipulating groups and subgroups, you can define the conjugate
    of a subgroup by an element of the ambient group.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 作为操作群和子群的一个练习，你可以通过环境群中的一个元素定义子群的共轭。
- en: '[PRE236]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: Tying the previous two topics together, one can push forward and pull back subgroups
    using group morphisms. The naming convention in Mathlib is to call those operations
    `map` and `comap`. These are not the common mathematical terms, but they have
    the advantage of being shorter than “pushforward” and “direct image.”
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 将前两个主题结合起来，可以使用群同态来推进和拉回子群。在 Mathlib 中的命名约定是将这些操作称为 `map` 和 `comap`。这些不是常见的数学术语，但它们的优势是比“推进”和“直接像”更短。
- en: '[PRE237]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: In particular, the preimage of the bottom subgroup under a morphism `f` is a
    subgroup called the *kernel* of `f`, and the range of `f` is also a subgroup.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，在映射 `f` 下底子群的逆像是称为 `f` 的 *核* 的子群，而 `f` 的值域也是一个子群。
- en: '[PRE238]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: As exercises in manipulating group morphisms and subgroups, let us prove some
    elementary properties. They are already proved in Mathlib, so do not use `exact?`
    too quickly if you want to benefit from these exercises.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 作为操作群同态和子群的练习，让我们证明一些基本性质。它们已经在 Mathlib 中得到证明，所以如果你想从这些练习中受益，不要太快地使用 `exact?`。
- en: '[PRE239]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: Let us finish this introduction to subgroups in Mathlib with two very classical
    results. Lagrange theorem states the cardinality of a subgroup of a finite group
    divides the cardinality of the group. Sylow’s first theorem is a famous partial
    converse to Lagrange’s theorem.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用两个非常经典的结果来完成对 Mathlib 中子群的介绍。拉格朗日定理表明有限群子群的基数是群基数的约数。西罗第一定理是拉格朗日定理的一个著名的部分逆定理。
- en: While this corner of Mathlib is partly set up to allow computation, we can tell
    Lean to use nonconstructive logic anyway using the following `open scoped` command.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Mathlib的这个角落部分是为了允许计算而设置的，但我们可以使用以下 `open scoped` 命令告诉 Lean 使用非构造性逻辑。
- en: '[PRE240]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: The next two exercises derive a corollary of Lagrange’s lemma. (This is also
    already in Mathlib, so do not use `exact?` too quickly.)
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个练习推导出拉格朗日引理的一个推论。（这也在 Mathlib 中，所以如果你想从这些练习中受益，不要太快地使用 `exact?`。）
- en: '[PRE241]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 9.1.4\. Concrete groups[](#concrete-groups "Link to this heading")
  id: totrans-593
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.4. 具体群[](#concrete-groups "链接到这个标题")
- en: One can also manipulate concrete groups in Mathlib, although this is typically
    more complicated than working with the abstract theory. For instance, given any
    type `X`, the group of permutations of `X` is `Equiv.Perm X`. In particular the
    symmetric group \(\mathfrak{S}_n\) is `Equiv.Perm (Fin n)`. One can state abstract
    results about this group, for instance saying that `Equiv.Perm X` is generated
    by cycles if `X` is finite.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在 Mathlib 中操作具体群，尽管这通常比处理抽象理论更复杂。例如，给定任何类型 `X`，`X` 的排列群是 `Equiv.Perm X`。特别是，对称群
    \(\mathfrak{S}_n\) 是 `Equiv.Perm (Fin n)`。可以对此群陈述抽象结果，例如，如果 `X` 是有限的，则 `Equiv.Perm
    X` 由循环生成。
- en: '[PRE242]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'One can be fully concrete and compute actual products of cycles. Below we use
    the `#simp` command, which calls the `simp` tactic on a given expression. The
    notation `c[]` is used to define a cyclic permutation. In the example, the result
    is a permutation of `ℕ`. One could use a type ascription such as `(1 : Fin 5)`
    on the first number appearing to make it a computation in `Perm (Fin 5)`.'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '可以完全具体，并计算循环的实际乘积。下面我们使用 `#simp` 命令，该命令在给定表达式中调用 `simp` 策略。符号 `c[]` 用于定义循环排列。在示例中，结果是
    `ℕ` 的排列。可以在第一个数字上使用类型注解，如 `(1 : Fin 5)`，使其成为 `Perm (Fin 5)` 中的计算。'
- en: '[PRE243]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'Another way to work with concrete groups is to use free groups and group presentations.
    The free group on a type `α` is `FreeGroup α` and the inclusion map is `FreeGroup.of
    : α → FreeGroup α`. For instance let us define a type `S` with three elements
    denoted by `a`, `b` and `c`, and the element `ab⁻¹` of the corresponding free
    group.'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '另一种处理具体群的方法是使用自由群和群表示。类型 `α` 上的自由群是 `FreeGroup α`，其包含映射是 `FreeGroup.of : α
    → FreeGroup α`。例如，让我们定义一个有三个元素 `a`、`b` 和 `c` 的类型 `S`，以及对应自由群中的元素 `ab⁻¹`。'
- en: '[PRE244]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: Note that we gave the expected type of the definition so that Lean knows that
    `.of` means `FreeGroup.of`.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们给出了定义的预期类型，这样 Lean 就知道 `.of` 表示 `FreeGroup.of`。
- en: The universal property of free groups is embodied as the equivalence `FreeGroup.lift`.
    For example, let us define the group morphism from `FreeGroup S` to `Perm (Fin
    5)` that sends `a` to `c[1, 2, 3]`, `b` to `c[2, 3, 1]`, and `c` to `c[2, 3]`,
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 自由群的泛性质体现在等价 `FreeGroup.lift` 中。例如，让我们定义从 `FreeGroup S` 到 `Perm (Fin 5)` 的群同态，该同态将
    `a` 映射到 `c[1, 2, 3]`，将 `b` 映射到 `c[2, 3, 1]`，将 `c` 映射到 `c[2, 3]`，
- en: '[PRE245]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: As a last concrete example, let us see how to define a group generated by a
    single element whose cube is one (so that group will be isomorphic to \(\mathbb{Z}/3\))
    and build a morphism from that group to `Perm (Fin 5)`.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一个具体的例子，让我们看看如何定义一个由单个元素生成且该元素的立方为1的群（因此该群将与 \(\mathbb{Z}/3\) 同构）以及如何从该群到
    `Perm (Fin 5)` 构建一个同态。
- en: As a type with exactly one element, we will use `Unit` whose only element is
    denoted by `()`. The function `PresentedGroup` takes a set of relations, i.e.
    a set of elements of some free group, and returns a group that is this free group
    quotiented by a normal subgroup generated by relations. (We will see how to handle
    more general quotients in [Section 9.1.6](#quotient-groups).) Since we somehow
    hide this behind a definition, we use `deriving Group` to force creation of a
    group instance on `myGroup`.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 作为只有一个元素的类型，我们将使用 `Unit`，其唯一元素用 `()` 表示。函数 `PresentedGroup` 接受一组关系，即某个自由群的一组元素，并返回一个群，该群是自由群除以由关系生成的正规子群。（我们将在
    [第 9.1.6 节](#quotient-groups) 中看到如何处理更一般的商。）由于我们以某种方式将此隐藏在定义之后，我们使用 `deriving
    Group` 来强制在 `myGroup` 上创建群实例。
- en: '[PRE246]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: The universal property of presented groups ensures that morphisms out of this
    group can be built from functions that send the relations to the neutral element
    of the target group. So we need such a function and a proof that the condition
    holds. Then we can feed this proof to `PresentedGroup.toGroup` to get the desired
    group morphism.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 呈现群的全称性质确保可以从将关系映射到目标群中性元素的函数构建出该群的外部同态。因此我们需要这样的函数和一个证明该条件成立。然后我们可以将这个证明输入到
    `PresentedGroup.toGroup` 中，以获得所需的群同态。
- en: '[PRE247]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: 9.1.5\. Group actions[](#group-actions "Link to this heading")
  id: totrans-608
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.5. 群作用[](#group-actions "链接到本标题")
- en: One important way that group theory interacts with the rest of mathematics is
    through the use of group actions. An action of a group `G` on some type `X` is
    nothing more than a morphism from `G` to `Equiv.Perm X`. So in a sense group actions
    are already covered by the previous discussion. But we don’t want to carry this
    morphism around; instead, we want it to be inferred automatically by Lean as much
    as possible. So we have a type class for this, which is `MulAction G X`. The downside
    of this setup is that having multiple actions of the same group on the same type
    requires some contortions, such as defining type synonyms, each of which carries
    different type class instances.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 群论与数学其他部分的一个重要交互方式是通过群作用的使用。一个群 `G` 在某些类型 `X` 上的作用不过是 `G` 到 `Equiv.Perm X` 的一个同态。所以在某种意义上，群作用已经被之前的讨论所涵盖。但我们不希望携带这个同态；相反，我们希望尽可能多地由
    Lean 自动推断它。因此，我们有一个类型类来表示这一点，即 `MulAction G X`。这种设置的缺点是，在同一个类型上有多个同一群的作用需要一些扭曲，例如定义类型同义词，每个同义词都携带不同的类型类实例。
- en: This allows us in particular to use `g • x` to denote the action of a group
    element `g` on a point `x`.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够特别地使用 `g • x` 来表示群元素 `g` 对点 `x` 的作用。
- en: '[PRE248]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: There is also a version for additive group called `AddAction`, where the action
    is denoted by `+ᵥ`. This is used for instance in the definition of affine spaces.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一个名为 `AddAction` 的加法群版本，其中动作由 `+ᵥ` 表示。这例如用于仿射空间的定义中。
- en: '[PRE249]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: The underlying group morphism is called `MulAction.toPermHom`.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 基础群同态被称为 `MulAction.toPermHom`。
- en: '[PRE250]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: As an illustration let us see how to define the Cayley isomorphism embedding
    of any group `G` into a permutation group, namely `Perm G`.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 作为说明，让我们看看如何定义任何群 `G` 到排列群 `Perm G` 的凯莱同构嵌入。
- en: '[PRE251]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: Note that nothing before the above definition required having a group rather
    than a monoid (or any type endowed with a multiplication operation really).
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在上述定义之前，并不需要有一个群而不是幺半群（或任何带有乘法运算的类型）。
- en: The group condition really enters the picture when we will want to partition
    `X` into orbits. The corresponding equivalence relation on `X` is called `MulAction.orbitRel`.
    It is not declared as a global instance.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将 `X` 划分为轨道时，群条件真正进入画面。`X` 上的对应等价关系被称为 `MulAction.orbitRel`。它没有被声明为一个全局实例。
- en: '[PRE252]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'Using this we can state that `X` is partitioned into orbits under the action
    of `G`. More precisely, we get a bijection between `X` and the dependent product
    `(ω : orbitRel.Quotient G X) × (orbit G (Quotient.out'' ω))` where `Quotient.out''
    ω` simply chooses an element that projects to `ω`. Recall that elements of this
    dependent product are pairs `⟨ω, x⟩` where the type `orbit G (Quotient.out'' ω)`
    of `x` depends on `ω`.'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '使用这个结果，我们可以陈述 `X` 在 `G` 的作用下被划分为轨道。更精确地说，我们得到 `X` 与依赖积 `(ω : orbitRel.Quotient
    G X) × (orbit G (Quotient.out'' ω))` 之间的双射，其中 `Quotient.out'' ω` 简单地选择一个投影到 `ω`
    的元素。回想一下，这个依赖积的元素是 `⟨ω, x⟩` 对，其中 `x` 的类型 `orbit G (Quotient.out'' ω)` 依赖于 `ω`。'
- en: '[PRE253]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: In particular, when X is finite, this can be combined with `Fintype.card_congr`
    and `Fintype.card_sigma` to deduce that the cardinality of `X` is the sum of the
    cardinalities of the orbits. Furthermore, the orbits are in bijection with the
    quotient of `G` under the action of the stabilizers by left translation. This
    action of a subgroup by left-translation is used to define quotients of a group
    by a subgroup with notation / so we can use the following concise statement.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，当 `X` 是有限集时，这可以与 `Fintype.card_congr` 和 `Fintype.card_sigma` 结合，推导出 `X`
    的基数是轨道基数的和。此外，轨道与通过左平移稳定子群作用下的 `G` 的商一一对应。这种子群通过左平移的作用被用来定义群通过子群的商，记作 /，因此我们可以使用以下简洁的陈述。
- en: '[PRE254]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'An important special case of combining the above two results is when `X` is
    a group `G` equipped with the action of a subgroup `H` by translation. In this
    case all stabilizers are trivial so every orbit is in bijection with `H` and we
    get:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述两个结果结合的重要特殊情况是，当 `X` 是一个带有子群 `H` 通过平移作用的群 `G` 时。在这种情况下，所有稳定子群都是平凡的，因此每个轨道都与
    `H` 一一对应，我们得到：
- en: '[PRE255]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: This is the conceptual variant of the version of Lagrange theorem that we saw
    above. Note this version makes no finiteness assumption.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上述拉格朗日定理版本的概念变体。注意这个版本没有有限性的假设。
- en: As an exercise for this section, let us build the action of a group on its subgroup
    by conjugation, using our definition of `conjugate` from a previous exercise.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节的练习，让我们根据之前练习中定义的 `conjugate`，构建群对其子群通过共轭的作用。
- en: '[PRE256]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '### 9.1.6\. Quotient groups[](#quotient-groups "Link to this heading")'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '### 9.1.6. 商群[](#quotient-groups "链接到这个标题")'
- en: In the above discussion of subgroups acting on groups, we saw the quotient `G
    ⧸ H` appear. In general this is only a type. It can be endowed with a group structure
    such that the quotient map is a group morphism if and only if `H` is a normal
    subgroup (and this group structure is then unique).
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述关于子群在群上作用的讨论中，我们看到了商 `G ⧸ H` 出现。在一般情况下，这只是一个类型。它可以赋予一个群结构，使得商映射是一个群同态，当且仅当
    `H` 是正规子群（在这种情况下，这种群结构是唯一的）。
- en: The normality assumption is a type class `Subgroup.Normal` so that type class
    inference can use it to derive the group structure on the quotient.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 正规性假设是一个类型类 `Subgroup.Normal`，这样类型类推理就可以用它来推导商上的群结构。
- en: '[PRE257]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: 'The universal property of quotient groups is accessed through `QuotientGroup.lift`:
    a group morphism `φ` descends to `G ⧸ N` as soon as its kernel contains `N`.'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 商群的泛性质通过 `QuotientGroup.lift` 访问：一个群同态 `φ` 只要其核包含 `N`，就会下降到 `G ⧸ N`。
- en: '[PRE258]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: The fact that the target group is called `M` is the above snippet is a clue
    that having a monoid structure on `M` would be enough.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 目标群被称为 `M` 的这个事实是上述片段的一个线索，表明在 `M` 上有一个幺半群结构就足够了。
- en: An important special case is when `N = ker φ`. In that case the descended morphism
    is injective and we get a group isomorphism onto its image. This result is often
    called the first isomorphism theorem.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的特殊情况是当 `N = ker φ`。在这种情况下，下降的态射是单射的，并且我们得到一个到其像上的群同构。这个结果通常被称为第一同构定理。
- en: '[PRE259]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: 'Applying the universal property to a composition of a morphism `φ : G →* G''`
    with a quotient group projection `Quotient.mk'' N''`, we can also aim for a morphism
    from `G ⧸ N` to `G'' ⧸ N''`. The condition required on `φ` is usually formulated
    by saying “`φ` should send `N` inside `N''`.” But this is equivalent to asking
    that `φ` should pull `N''` back over `N`, and the latter condition is nicer to
    work with since the definition of pullback does not involve an existential quantifier.'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '将泛性质应用于一个态射 `φ : G →* G''` 与商群投影 `Quotient.mk'' N''` 的组合，我们也可以试图得到一个从 `G ⧸
    N` 到 `G'' ⧸ N''` 的态射。对 `φ` 的要求通常表述为“`φ` 应该将 `N` 发送到 `N''` 内部。”但这等价于要求 `φ` 将 `N''`
    拉回到 `N` 上，而后一种条件更容易处理，因为拉回的定义不涉及存在量词。'
- en: '[PRE260]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: One subtle point to keep in mind is that the type `G ⧸ N` really depends on
    `N` (up to definitional equality), so having a proof that two normal subgroups
    `N` and `M` are equal is not enough to make the corresponding quotients equal.
    However the universal properties does give an isomorphism in this case.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一个微妙之处是，类型 `G ⧸ N` 实际上依赖于 `N`（直到定义等价），因此，两个正规子群 `N` 和 `M` 相等的证明不足以使相应的商相等。然而，泛性质在这种情况下确实给出了一个同构。
- en: '[PRE261]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: As a final series of exercises for this section, we will prove that if `H` and
    `K` are disjoint normal subgroups of a finite group `G` such that the product
    of their cardinalities is equal to the cardinality of `G` then `G` is isomorphic
    to `H × K`. Recall that disjoint in this context means `H ⊓ K = ⊥`.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节最后的练习系列，我们将证明如果 `H` 和 `K` 是有限群 `G` 的不相交正规子群，且它们的基数乘积等于 `G` 的基数，那么 `G` 同构于
    `H × K`。回忆一下，在这个上下文中，“不相交”意味着 `H ⊓ K = ⊥`。
- en: We start with playing a bit with Lagrange’s lemma, without assuming the subgroups
    are normal or disjoint.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过不假设子群是正规或不相交的，来玩一点拉格朗日引理。
- en: '[PRE262]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: From now on, we assume that our subgroups are normal and disjoint, and we assume
    the cardinality condition. Now we construct the first building block of the desired
    isomorphism.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们假设我们的子群是正规且不相交的，并假设基数条件。现在我们构建所需同构的第一个构建块。
- en: '[PRE263]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: Now we can define our second building block. We will need `MonoidHom.prod`,
    which builds a morphism from `G₀` to `G₁ × G₂` out of morphisms from `G₀` to `G₁`
    and `G₂`.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以定义我们的第二个构建块。我们需要 `MonoidHom.prod`，它从 `G₀` 到 `G₁ × G₂` 构建一个态射，其中包含从 `G₀`
    到 `G₁` 和 `G₂` 的态射。
- en: '[PRE264]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: We are ready to put all pieces together.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好将所有部件组合在一起。
- en: '[PRE265]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '## 9.2\. Rings[](#rings "Link to this heading")'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '## 9.2. 环[](#rings "链接到这个标题")'
- en: '### 9.2.1\. Rings, their units, morphisms and subrings[](#rings-their-units-morphisms-and-subrings
    "Link to this heading")'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '### 9.2.1. 环、它们的单位、态射和子环[](#rings-their-units-morphisms-and-subrings "链接到这个标题")'
- en: The type of ring structures on a type `R` is `Ring R`. The variant where multiplication
    is assumed to be commutative is `CommRing R`. We have already seen that the `ring`
    tactic will prove any equality that follows from the axioms of a commutative ring.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型 `R` 上的环结构类型是 `Ring R`。假设乘法是交换的变体是 `CommRing R`。我们已经看到，`ring` 策略将证明任何从交换环公理中得出的等式。
- en: '[PRE266]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: More exotic variants do not require that the addition on `R` forms a group but
    only an additive monoid. The corresponding type classes are `Semiring R` and `CommSemiring
    R`. The type of natural numbers is an important instance of `CommSemiring R`,
    as is any type of functions taking values in the natural numbers. Another important
    example is the type of ideals in a ring, which will be discussed below. The name
    of the `ring` tactic is doubly misleading, since it assumes commutativity but
    works in semirings as well. In other words, it applies to any `CommSemiring`.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 更为奇特的变体不需要 `R` 上的加法形成一个群，而只是一个加法幺半群。相应的类型类是 `Semiring R` 和 `CommSemiring R`。自然数的类型是
    `CommSemiring R` 的重要实例，任何取自然数为值的函数类型也是如此。另一个重要例子是环中的理想类型，将在下面讨论。`ring` 策略的名称具有双重误导性，因为它假设了交换性，但在半环中也能工作。换句话说，它适用于任何
    `CommSemiring`。
- en: '[PRE267]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: There are also versions of the ring and semiring classes that do not assume
    the existence of a multiplicative unit or the associativity of multiplication.
    We will not discuss those here.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 环和半环类的版本也有不假设存在乘法单位元或乘法结合律的情况。我们这里不会讨论这些。
- en: 'Some concepts that are traditionally taught in an introduction to ring theory
    are actually about the underlying multiplicative monoid. A prominent example is
    the definition of the units of a ring. Every (multiplicative) monoid `M` has a
    predicate `IsUnit : M → Prop` asserting existence of a two-sided inverse, a type
    `Units M` of units with notation `Mˣ`, and a coercion to `M`. The type `Units
    M` bundles an invertible element with its inverse as well as properties than ensure
    that each is indeed the inverse of the other. This implementation detail is relevant
    mainly when defining computable functions. In most situations one can use `IsUnit.unit
    {x : M} : IsUnit x → Mˣ` to build a unit. In the commutative case, one also has
    `Units.mkOfMulEqOne (x y : M) : x * y = 1 → Mˣ` which builds `x` seen as unit.'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '在环论导论中传统上教授的一些概念实际上与底层的乘法幺半群有关。一个突出的例子是环的单位定义。每个（乘法）幺半群 `M` 都有一个谓词 `IsUnit
    : M → Prop`，断言存在一个两边的逆元，一个单位类型 `Units M`，记作 `Mˣ`，以及一个到 `M` 的强制转换。类型 `Units M`
    将可逆元素与其逆元以及确保每个确实是另一个的逆元的属性捆绑在一起。这个实现细节主要在定义可计算函数时相关。在大多数情况下，可以使用 `IsUnit.unit
    {x : M} : IsUnit x → Mˣ` 来构建一个单位。在交换情况下，还有一个 `Units.mkOfMulEqOne (x y : M) : x
    * y = 1 → Mˣ`，它构建了被视为单位的 `x`。'
- en: '[PRE268]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: The type of ring morphisms between two (semi)-rings `R` and `S` is `RingHom
    R S`, with notation `R →+* S`.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 两个（半）环 `R` 和 `S` 之间的环同态类型是 `RingHom R S`，记作 `R →+* S`。
- en: '[PRE269]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: The isomorphism variant is `RingEquiv`, with notation `≃+*`.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 同构变体是 `RingEquiv`，记作 `≃+*`。
- en: As with submonoids and subgroups, there is a `Subring R` type for subrings of
    a ring `R`, but this type is a lot less useful than the type of subgroups since
    one cannot quotient a ring by a subring.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 与子幺半群和子群一样，存在一个 `Subring R` 类型，用于表示环 `R` 的子环，但这个类型比子群类型要少用得多，因为不能通过子环来商环。
- en: '[PRE270]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: Also notice that `RingHom.range` produces a subring.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`RingHom.range` 产生一个子环。
- en: 9.2.2\. Ideals and quotients[](#ideals-and-quotients "Link to this heading")
  id: totrans-667
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2\. 理想与商[](#ideals-and-quotients "链接到本标题")
- en: For historical reasons, Mathlib only has a theory of ideals for commutative
    rings. (The ring library was originally developed to make quick progress toward
    the foundations of modern algebraic geometry.) So in this section we will work
    with commutative (semi)rings. Ideals of `R` are defined as submodules of `R` seen
    as `R`-modules. Modules will be covered later in a chapter on linear algebra,
    but this implementation detail can mostly be safely ignored since most (but not
    all) relevant lemmas are restated in the special context of ideals. But anonymous
    projection notation won’t always work as expected. For instance, one cannot replace
    `Ideal.Quotient.mk I` by `I.Quotient.mk` in the snippet below because there are
    two `.`s and so it will parse as `(Ideal.Quotient I).mk`; but `Ideal.Quotient`
    by itself doesn’t exist.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史原因，Mathlib只为交换环提供了理想理论。（环库最初是为了快速推进现代代数几何的基础而开发的。）因此，在本节中，我们将使用交换（半）环。`R`的理想被定义为将`R`视为`R`-模的子模。模块将在线性代数章节中稍后讨论，但这个实现细节可以大部分安全忽略，因为大多数（但不是所有）相关的引理都在理想的特殊上下文中重新表述。但匿名投影符号并不总是按预期工作。例如，在下面的片段中不能将`Ideal.Quotient.mk
    I`替换为`I.Quotient.mk`，因为有两个`.`，所以它将被解析为`(Ideal.Quotient I).mk`；但`Ideal.Quotient`本身并不存在。
- en: '[PRE271]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: The universal property of quotient rings is `Ideal.Quotient.lift`.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 商环的泛性性质是`Ideal.Quotient.lift`。
- en: '[PRE272]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: In particular it leads to the first isomorphism theorem for rings.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是它导致了环的第一同构定理。
- en: '[PRE273]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: Ideals form a complete lattice structure with the inclusion relation, as well
    as a semiring structure. These two structures interact nicely.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 理想在包含关系下形成一个完全格结构，以及一个半环结构。这两个结构相互作用得很好。
- en: '[PRE274]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: One can use ring morphisms to push ideals forward and pull them back using `Ideal.map`
    and `Ideal.comap`, respectively. As usual, the latter is more convenient to use
    since it does not involve an existential quantifier. This explains why it is used
    to state the condition that allows us to build morphisms between quotient rings.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用环同态来分别使用`Ideal.map`和`Ideal.comap`将理想前推和后拉。通常，后者更方便使用，因为它不涉及存在量词。这解释了为什么它被用来表述允许我们在商环之间构建同态的条件。
- en: '[PRE275]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: One subtle point is that the type `R ⧸ I` really depends on `I` (up to definitional
    equality), so having a proof that two ideals `I` and `J` are equal is not enough
    to make the corresponding quotients equal. However, the universal properties do
    provide an isomorphism in this case.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 一个微妙之处在于类型`R ⧸ I`实际上依赖于`I`（直到定义等价），因此，两个理想`I`和`J`相等的证明不足以使相应的商相等。然而，泛性性质在这种情况下确实提供了一个同构。
- en: '[PRE276]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: We can now present the Chinese remainder isomorphism as an example. Pay attention
    to the difference between the indexed infimum symbol `⨅` and the big product of
    types symbol `Π`. Depending on your font, those can be pretty hard to distinguish.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以以一个例子来展示中国剩余同构。请注意，索引下确界符号`⨅`和类型的大积符号`Π`之间的区别。根据你的字体，这些可能很难区分。
- en: '[PRE277]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: 'The elementary version of the Chinese remainder theorem, a statement about
    `ZMod`, can be easily deduced from the previous one:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 中国剩余定理的初等版本，关于`ZMod`的陈述，可以很容易地从先前的定理中推导出来：
- en: '[PRE278]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: As a series of exercises, we will reprove the Chinese remainder theorem in the
    general case.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一系列练习，我们将重新证明在一般情况下的中国剩余定理。
- en: We first need to define the map appearing in the theorem, as a ring morphism,
    using the universal property of quotient rings.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要定义定理中出现的映射，作为一个环同态，利用商环的泛性性质。
- en: '[PRE279]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: Make sure the following next two lemmas can be proven by `rfl`.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 确保以下两个引理可以通过`rfl`证明。
- en: '[PRE280]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: The next lemma proves the easy half of the Chinese remainder theorem, without
    any assumption on the family of ideals. The proof is less than one line long.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个引理证明了中国剩余定理的简单一半，对理想的族没有任何假设。证明不到一行长。
- en: '[PRE281]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: We are now ready for the heart of the theorem, which will show the surjectivity
    of our `chineseMap`. First we need to know the different ways one can express
    the coprimality (also called co-maximality assumption). Only the first two will
    be needed below.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好进入定理的核心部分，这将展示我们的`chineseMap`的满射性。首先我们需要知道表达互质（也称为共最大性假设）的不同方式。下面只需要前两种。
- en: '[PRE282]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: We take the opportunity to use induction on `Finset`. Relevant lemmas on `Finset`
    are given below. Remember that the `ring` tactic works for semirings and that
    the ideals of a ring form a semiring.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用这个机会，通过`Finset`进行归纳。以下给出了与`Finset`相关的引理。记住，`ring`策略适用于半环，并且环的理想形成一个半环。
- en: '[PRE283]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: We can now prove surjectivity of the map appearing in the Chinese remainder
    theorem.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以证明中国剩余定理中出现的映射的满射性。
- en: '[PRE284]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: 'Now all the pieces come together in the following:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有这些部分都在以下内容中汇集在一起：
- en: '[PRE285]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: 9.2.3\. Algebras and polynomials[](#algebras-and-polynomials "Link to this
    heading")
  id: totrans-699
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3\. 代数和多项式[](#algebras-and-polynomials "链接到这个标题")
- en: 'Given a commutative (semi)ring `R`, an *algebra over* `R` is a semiring `A`
    equipped with a ring morphism whose image commutes with every element of `A`.
    This is encoded as a type class `Algebra R A`. The morphism from `R` to `A` is
    called the structure map and is denoted `algebraMap R A : R →+* A` in Lean. Multiplication
    of `a : A` by `algebraMap R A r` for some `r : R` is called the scalar multiplication
    of `a` by `r` and denoted by `r • a`. Note that this notion of algebra is sometimes
    called an *associative unital algebra* to emphasize the existence of more general
    notions of algebra.'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '给定一个交换（半）环 `R`，一个在 `R` 上的代数是一个半环 `A`，它配备了一个环同态，其像与 `A` 的每个元素交换。这被编码为类型类 `Algebra
    R A`。从 `R` 到 `A` 的同态被称为结构映射，在 Lean 中表示为 `algebraMap R A : R →+* A`。对于某个 `r : R`，`a
    : A` 通过 `algebraMap R A r` 的乘法称为 `a` 通过 `r` 的标量乘法，表示为 `r • a`。请注意，这种代数的概念有时被称为*结合有单位代数*，以强调存在更一般的代数概念。'
- en: 'The fact that `algebraMap R A` is ring morphism packages together a lot of
    properties of scalar multiplication, such as the following:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '`algebraMap R A` 是环同态的事实将标量乘法的许多属性打包在一起，例如以下内容：'
- en: '[PRE286]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: The morphisms between two `R`-algebras `A` and `B` are ring morphisms which
    commute with scalar multiplication by elements of `R`. They are bundled morphisms
    with type `AlgHom R A B`, which is denoted by `A →ₐ[R] B`.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 `R`-代数 `A` 和 `B` 之间的形态是环同态，它们与 `R` 的元素进行标量乘法时保持交换。它们是带有类型 `AlgHom R A B`
    的打包形态，表示为 `A →ₐ[R] B`。
- en: Important examples of non-commutative algebras include algebras of endomorphisms
    and algebras of square matrices, both of which will be covered in the chapter
    on linear algebra. In this chapter we will discuss one of the most important examples
    of a commutative algebra, namely, polynomial algebras.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 非交换代数的重要例子包括自同态代数和方阵代数，这两者都将在线性代数章节中介绍。在本章中，我们将讨论一个最重要的交换代数例子，即多项式代数。
- en: The algebra of univariate polynomials with coefficients in `R` is called `Polynomial
    R`, which can be written as `R[X]` as soon as one opens the `Polynomial` namespace.
    The algebra structure map from `R` to `R[X]` is denoted by `C`, which stands for
    “constant” since the corresponding polynomial functions are always constant. The
    indeterminate is denoted by `X`.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 具有系数在 `R` 中的单变量多项式代数称为 `Polynomial R`，一旦打开 `Polynomial` 命名空间，就可以写成 `R[X]`。从
    `R` 到 `R[X]` 的代数结构映射表示为 `C`，代表“常数”，因为相应的多项式函数始终是常数。不定元表示为 `X`。
- en: '[PRE287]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: In the first example above, it is crucial that we give Lean the expected type
    since it cannot be determined from the body of the definition. In the second example,
    the target polynomial algebra can be inferred from our use of `C r` since the
    type of `r` is known.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述第一个例子中，我们给 Lean 指定预期的类型至关重要，因为类型不能从定义体中确定。在第二个例子中，由于 `r` 的类型已知，我们可以从我们对 `C
    r` 的使用中推断出目标多项式代数。
- en: 'Because `C` is a ring morphism from `R` to `R[X]`, we can use all ring morphisms
    lemmas such as `map_zero`, `map_one`, `map_mul`, and `map_pow` before computing
    in the ring `R[X]`. For example:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `C` 是从 `R` 到 `R[X]` 的环同态，所以我们可以在计算环 `R[X]` 之前使用所有环同态引理，例如 `map_zero`、`map_one`、`map_mul`
    和 `map_pow`。例如：
- en: '[PRE288]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: You can access coefficients using `Polynomial.coeff`
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `Polynomial.coeff` 访问系数。
- en: '[PRE289]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: 'Defining the degree of a polynomial is always tricky because of the special
    case of the zero polynomial. Mathlib has two variants: `Polynomial.natDegree :
    R[X] → ℕ` assigns degree `0` to the zero polynomial, and `Polynomial.degree :
    R[X] → WithBot ℕ` assigns `⊥`. In the latter, `WithBot ℕ` can be seen as `ℕ ∪
    {-∞}`, except that `-∞` is denoted `⊥`, the same symbol as the bottom element
    in a complete lattice. This special value is used as the degree of the zero polynomial,
    and it is absorbent for addition. (It is almost absorbent for multiplication,
    except that `⊥ * 0 = 0`.)'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '定义多项式的次数总是很棘手，因为零多项式的特殊情况。Mathlib 有两种变体：`Polynomial.natDegree : R[X] → ℕ` 将零多项式的次数分配为
    `0`，而 `Polynomial.degree : R[X] → WithBot ℕ` 分配 `⊥`。在后一种情况下，`WithBot ℕ` 可以看作是
    `ℕ ∪ {-∞}`，除了 `-∞` 被表示为 `⊥`，与完备格中的底元素相同的符号。这个特殊值被用作零多项式的次数，并且对于加法是吸收的。（对于乘法几乎也是吸收的，除了
    `⊥ * 0 = 0`。）'
- en: Morally speaking, the `degree` version is the correct one. For instance, it
    allows us to state the expected formula for the degree of a product (assuming
    the base ring has no zero divisor).
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 从道德上讲，`degree` 版本是正确的。例如，它允许我们陈述乘积的预期公式（假设基环没有零因子）。
- en: '[PRE290]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: Whereas the version for `natDegree` needs to assume non-zero polynomials.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于 `natDegree` 版本需要假设非零多项式。
- en: '[PRE291]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: 'However, `ℕ` is much nicer to use than `WithBot ℕ`, so Mathlib makes both versions
    available and provides lemmas to convert between them. Also, `natDegree` is the
    more convenient definition to use when computing the degree of a composition.
    Composition of polynomial is `Polynomial.comp` and we have:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`ℕ` 比使用 `WithBot ℕ` 更方便，所以 Mathlib 提供了两种版本，并提供了一些引理来在它们之间进行转换。此外，`natDegree`
    是在计算复合的次数时更方便的定义。多项式的复合是 `Polynomial.comp`，我们有：
- en: '[PRE292]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: 'Polynomials give rise to polynomial functions: any polynomial can be evaluated
    on `R` using `Polynomial.eval`.'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式产生了多项式函数：任何多项式都可以使用 `Polynomial.eval` 在 `R` 上进行评估。
- en: '[PRE293]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: In particular, there is a predicate, `IsRoot`, that holds for elements `r` in
    `R` where a polynomial vanishes.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，有一个谓词 `IsRoot`，它对于在 `R` 中使多项式为零的元素 `r` 成立。
- en: '[PRE294]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: We would like to say that, assuming `R` has no zero divisor, a polynomial has
    at most as many roots as its degree, where the roots are counted with multiplicities.
    But once again the case of the zero polynomial is painful. So Mathlib defines
    `Polynomial.roots` to send a polynomial `P` to a multiset, i.e. the finite set
    that is defined to be empty if `P` is zero and the roots of `P`, with multiplicities,
    otherwise. This is defined only when the underlying ring is a domain since otherwise
    the definition does not have good properties.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望说明，假设 `R` 没有零因子，一个多项式的根的数量最多与其次数相同，这里的根是按重数计算的。但一旦再次遇到零多项式的情况就令人痛苦。因此，Mathlib
    定义了 `Polynomial.roots` 来将一个多项式 `P` 映射到一个多重集，即如果 `P` 是零多项式，则定义为空集，否则是 `P` 的根及其重数。这个定义仅在基础环是整环时才有效，因为否则定义不具有好的性质。
- en: '[PRE295]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: 'Both `Polynomial.eval` and `Polynomial.roots` consider only the coefficients
    ring. They do not allow us to say that `X ^ 2 - 2 : ℚ[X]` has a root in `ℝ` or
    that `X ^ 2 + 1 : ℝ[X]` has a root in `ℂ`. For this, we need `Polynomial.aeval`,
    which will evaluate `P : R[X]` in any `R`-algebra. More precisely, given a semiring
    `A` and an instance of `Algebra R A`, `Polynomial.aeval` sends every element of
    `a` along the `R`-algebra morphism of evaluation at `a`. Since `AlgHom` has a
    coercion to functions, one can apply it to a polynomial. But `aeval` does not
    have a polynomial as an argument, so one cannot use dot notation like in `P.eval`
    above.'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '`Polynomial.eval` 和 `Polynomial.roots` 只考虑系数环。它们不允许我们说 `X ^ 2 - 2 : ℚ[X]` 在
    `ℝ` 中有一个根，或者 `X ^ 2 + 1 : ℝ[X]` 在 `ℂ` 中有一个根。为此，我们需要 `Polynomial.aeval`，它将在任何 `R`-代数中评估
    `P : R[X]`。更精确地说，给定一个半环 `A` 和一个 `Algebra R A` 实例，`Polynomial.aeval` 将 `a` 的每个元素沿着在
    `a` 处的评估的 `R`-代数同态发送。由于 `AlgHom` 有一个到函数的强制转换，可以将其应用于多项式。但 `aeval` 没有以多项式作为参数，因此不能使用像上面
    `P.eval` 中的点符号。'
- en: '[PRE296]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: The function corresponding to `roots` in this context is `aroots` which takes
    a polynomial and then an algebra and outputs a multiset (with the same caveat
    about the zero polynomial as for `roots`).
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中对应于 `roots` 的函数是 `aroots`，它接受一个多项式然后是一个代数，并输出一个多重集（与 `roots` 相同，关于零多项式的注意事项）。
- en: '[PRE297]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: 'More generally, given an ring morphism `f : R →+* S` one can evaluate `P :
    R[X]` at a point in `S` using `Polynomial.eval₂`. This one produces an actual
    function from `R[X]` to `S` since it does not assume the existence of a `Algebra
    R S` instance, so dot notation works as you would expect.'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '更普遍地，给定一个环同态 `f : R →+* S`，可以使用 `Polynomial.eval₂` 在 `S` 中的某一点评估 `P : R[X]`。这个操作产生了一个从
    `R[X]` 到 `S` 的实际函数，因为它不假设存在一个 `Algebra R S` 实例，所以点符号的使用方式正如你所期望的那样。'
- en: '[PRE298]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: 'Let us end by mentioning multivariate polynomials briefly. Given a commutative
    semiring `R`, the `R`-algebra of polynomials with coefficients in `R` and indeterminates
    indexed by a type `σ` is `MVPolynomial σ R`. Given `i : σ`, the corresponding
    polynomial is `MvPolynomial.X i`. (As usual, one can open the `MVPolynomial` namespace
    to shorten this to `X i`.) For instance, if we want two indeterminates we can
    use `Fin 2` as `σ` and write the polynomial defining the unit circle in \(\mathbb{R}^2`\)
    as:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们简要地提一下多元多项式。给定一个交换半环 `R`，系数在 `R` 中且变量由类型 `σ` 索引的多项式 `R`-代数是 `MVPolynomial
    σ R`。给定 `i : σ`，相应的多项式是 `MvPolynomial.X i`。（像往常一样，可以打开 `MVPolynomial` 命名空间来缩短表示为
    `X i`。）例如，如果我们想要两个变量，我们可以使用 `Fin 2` 作为 `σ`，并将定义单位圆的 \(\mathbb{R}^2\) 中的多项式写为：'
- en: '[PRE299]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: Recall that function application has a very high precedence so the expression
    above is read as `(X 0) ^ 2 + (X 1) ^ 2 - 1`. We can evaluate it to make sure
    the point with coordinates \((1, 0)\) is on the circle. Recall the `![...]` notation
    denotes elements of `Fin n → X` for some natural number `n` determined by the
    number of arguments and some type `X` determined by the type of arguments.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，函数应用有很高的优先级，所以上面的表达式读作 `(X 0) ^ 2 + (X 1) ^ 2 - 1`。我们可以评估它以确保坐标为 \((1,
    0)\) 的点在圆上。回想一下，`![...]` 符号表示 `Fin n → X` 的元素，其中 `n` 是由参数的数量决定的某个自然数，`X` 是由参数的类型决定的某个类型。
- en: '[PRE300]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '### 9.2.1\. Rings, their units, morphisms and subrings[](#rings-their-units-morphisms-and-subrings
    "Link to this heading")'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '### 9.2.1\. 环、它们的单位、同态和子环[](#rings-their-units-morphisms-and-subrings "链接到本标题")'
- en: The type of ring structures on a type `R` is `Ring R`. The variant where multiplication
    is assumed to be commutative is `CommRing R`. We have already seen that the `ring`
    tactic will prove any equality that follows from the axioms of a commutative ring.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `R` 上的环结构类型是 `Ring R`。假设乘法是交换的变体是 `CommRing R`。我们已经看到，`ring` 策略将证明任何从交换环公理中得出的等式。
- en: '[PRE301]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: More exotic variants do not require that the addition on `R` forms a group but
    only an additive monoid. The corresponding type classes are `Semiring R` and `CommSemiring
    R`. The type of natural numbers is an important instance of `CommSemiring R`,
    as is any type of functions taking values in the natural numbers. Another important
    example is the type of ideals in a ring, which will be discussed below. The name
    of the `ring` tactic is doubly misleading, since it assumes commutativity but
    works in semirings as well. In other words, it applies to any `CommSemiring`.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 更奇特的变体不需要 `R` 上的加法形成一个群，而只需要一个加法幺半群。相应的类型类是 `Semiring R` 和 `CommSemiring R`。自然数的类型是
    `CommSemiring R` 的重要实例，任何取自然数值的函数类型也是如此。另一个重要例子是环中的理想类型，将在下面讨论。`ring` 策略的名称具有双重误导性，因为它假设了交换性，但在半环中也能工作。换句话说，它适用于任何
    `CommSemiring`。
- en: '[PRE302]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: There are also versions of the ring and semiring classes that do not assume
    the existence of a multiplicative unit or the associativity of multiplication.
    We will not discuss those here.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 环和半环类的版本也有不假设存在乘法单位或乘法结合律的情况。我们这里不会讨论这些。
- en: 'Some concepts that are traditionally taught in an introduction to ring theory
    are actually about the underlying multiplicative monoid. A prominent example is
    the definition of the units of a ring. Every (multiplicative) monoid `M` has a
    predicate `IsUnit : M → Prop` asserting existence of a two-sided inverse, a type
    `Units M` of units with notation `Mˣ`, and a coercion to `M`. The type `Units
    M` bundles an invertible element with its inverse as well as properties than ensure
    that each is indeed the inverse of the other. This implementation detail is relevant
    mainly when defining computable functions. In most situations one can use `IsUnit.unit
    {x : M} : IsUnit x → Mˣ` to build a unit. In the commutative case, one also has
    `Units.mkOfMulEqOne (x y : M) : x * y = 1 → Mˣ` which builds `x` seen as unit.'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '一些在环论导论中传统上教授的概念实际上是关于底层乘法幺半群的。一个突出的例子是环的单位定义。每个（乘法）幺半群 `M` 都有一个谓词 `IsUnit
    : M → Prop`，它断言存在一个两边的逆元，一个单位类型 `Units M`，记作 `Mˣ`，以及一个到 `M` 的强制转换。类型 `Units M`
    将可逆元素及其逆元以及确保每个确实是另一个的逆元的属性捆绑在一起。这个实现细节主要在定义可计算函数时相关。在大多数情况下，可以使用 `IsUnit.unit
    {x : M} : IsUnit x → Mˣ` 来构建一个单位。在交换情况下，还有一个 `Units.mkOfMulEqOne (x y : M) : x
    * y = 1 → Mˣ`，它构建了被视为单位的 `x`。'
- en: '[PRE303]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: The type of ring morphisms between two (semi)-rings `R` and `S` is `RingHom
    R S`, with notation `R →+* S`.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 两个（半）环 `R` 和 `S` 之间环同态的类型是 `RingHom R S`，记作 `R →+* S`。
- en: '[PRE304]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: The isomorphism variant is `RingEquiv`, with notation `≃+*`.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 同构变体是 `RingEquiv`，记作 `≃+*`。
- en: As with submonoids and subgroups, there is a `Subring R` type for subrings of
    a ring `R`, but this type is a lot less useful than the type of subgroups since
    one cannot quotient a ring by a subring.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 与子幺半群和子群一样，存在一个 `Subring R` 类型，用于表示环 `R` 的子环，但这个类型比子群类型要少用得多，因为不能通过子环来商环。
- en: '[PRE305]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: Also notice that `RingHom.range` produces a subring.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`RingHom.range` 产生一个子环。
- en: 9.2.2\. Ideals and quotients[](#ideals-and-quotients "Link to this heading")
  id: totrans-749
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2\. 理想与商[](#ideals-and-quotients "链接到本标题")
- en: For historical reasons, Mathlib only has a theory of ideals for commutative
    rings. (The ring library was originally developed to make quick progress toward
    the foundations of modern algebraic geometry.) So in this section we will work
    with commutative (semi)rings. Ideals of `R` are defined as submodules of `R` seen
    as `R`-modules. Modules will be covered later in a chapter on linear algebra,
    but this implementation detail can mostly be safely ignored since most (but not
    all) relevant lemmas are restated in the special context of ideals. But anonymous
    projection notation won’t always work as expected. For instance, one cannot replace
    `Ideal.Quotient.mk I` by `I.Quotient.mk` in the snippet below because there are
    two `.`s and so it will parse as `(Ideal.Quotient I).mk`; but `Ideal.Quotient`
    by itself doesn’t exist.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史原因，Mathlib 只有一种关于交换环的理想理论。（环库最初是为了快速推进现代代数几何的基础而开发的。）因此，在本节中，我们将使用交换（半）环。`R`
    的理想被定义为将 `R` 视为 `R`-模块的子模块。模块将在线性代数章节中稍后介绍，但这个实现细节可以大部分安全忽略，因为大多数（但不是所有）相关引理都在理想的特殊上下文中重新表述。但匿名投影符号并不总是按预期工作。例如，在下面的片段中不能将
    `Ideal.Quotient.mk I` 替换为 `I.Quotient.mk`，因为有两个 `.`，所以它将被解析为 `(Ideal.Quotient
    I).mk`；但 `Ideal.Quotient` 本身并不存在。
- en: '[PRE306]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: The universal property of quotient rings is `Ideal.Quotient.lift`.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 商环的泛性性质是 `Ideal.Quotient.lift`。
- en: '[PRE307]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: In particular it leads to the first isomorphism theorem for rings.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是它导致了环的第一同构定理。
- en: '[PRE308]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: Ideals form a complete lattice structure with the inclusion relation, as well
    as a semiring structure. These two structures interact nicely.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 理想在包含关系下形成一个完全格结构，以及半环结构。这两个结构相互作用得很好。
- en: '[PRE309]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: One can use ring morphisms to push ideals forward and pull them back using `Ideal.map`
    and `Ideal.comap`, respectively. As usual, the latter is more convenient to use
    since it does not involve an existential quantifier. This explains why it is used
    to state the condition that allows us to build morphisms between quotient rings.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用环同态将理想向前推进并使用 `Ideal.map` 和 `Ideal.comap` 分别将其拉回。通常，后者更方便使用，因为它不涉及存在量词。这解释了为什么它被用来表述允许我们在商环之间构建同态的条件。
- en: '[PRE310]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: One subtle point is that the type `R ⧸ I` really depends on `I` (up to definitional
    equality), so having a proof that two ideals `I` and `J` are equal is not enough
    to make the corresponding quotients equal. However, the universal properties do
    provide an isomorphism in this case.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 一个微妙之处在于类型 `R ⧸ I` 实际上依赖于 `I`（直到定义等价），因此，两个理想 `I` 和 `J` 相等的证明不足以使相应的商相等。然而，泛性性质在这种情况下确实提供了一个同构。
- en: '[PRE311]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: We can now present the Chinese remainder isomorphism as an example. Pay attention
    to the difference between the indexed infimum symbol `⨅` and the big product of
    types symbol `Π`. Depending on your font, those can be pretty hard to distinguish.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以以一个例子来展示中国剩余同构。请注意，索引下确界符号 `⨅` 和类型的大积符号 `Π` 之间的区别。根据你的字体，这些可能很难区分。
- en: '[PRE312]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: 'The elementary version of the Chinese remainder theorem, a statement about
    `ZMod`, can be easily deduced from the previous one:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 中国剩余定理的初等版本，一个关于 `ZMod` 的陈述，可以很容易地从先前的定理中推导出来：
- en: '[PRE313]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: As a series of exercises, we will reprove the Chinese remainder theorem in the
    general case.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一系列练习，我们将重新证明一般情况下的中国剩余定理。
- en: We first need to define the map appearing in the theorem, as a ring morphism,
    using the universal property of quotient rings.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要定义定理中出现的映射，作为一个环同态，使用商环的泛性性质。
- en: '[PRE314]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: Make sure the following next two lemmas can be proven by `rfl`.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 确保以下两个引理可以通过 `rfl` 证明。
- en: '[PRE315]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: The next lemma proves the easy half of the Chinese remainder theorem, without
    any assumption on the family of ideals. The proof is less than one line long.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个引理证明了中国剩余定理的简单一半，对理想的族没有任何假设。证明不到一行长。
- en: '[PRE316]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: We are now ready for the heart of the theorem, which will show the surjectivity
    of our `chineseMap`. First we need to know the different ways one can express
    the coprimality (also called co-maximality assumption). Only the first two will
    be needed below.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以准备定理的核心部分，它将展示我们的 `chineseMap` 的满射性。首先我们需要知道表达互质（也称为共最大性假设）的不同方式。下面只需要前两种。
- en: '[PRE317]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: We take the opportunity to use induction on `Finset`. Relevant lemmas on `Finset`
    are given below. Remember that the `ring` tactic works for semirings and that
    the ideals of a ring form a semiring.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用这个机会使用对 `Finset` 的归纳。以下给出了 `Finset` 上的相关引理。记住，`ring` 策略适用于半环，并且环的理想形成一个半环。
- en: '[PRE318]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: We can now prove surjectivity of the map appearing in the Chinese remainder
    theorem.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以证明中国剩余定理中出现的映射的满射性。
- en: '[PRE319]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: 'Now all the pieces come together in the following:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有这些部分都在以下内容中汇集在一起：
- en: '[PRE320]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: 9.2.3\. Algebras and polynomials[](#algebras-and-polynomials "Link to this
    heading")
  id: totrans-781
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3\. 代数与多项式[](#algebras-and-polynomials "链接到这个标题")
- en: 'Given a commutative (semi)ring `R`, an *algebra over* `R` is a semiring `A`
    equipped with a ring morphism whose image commutes with every element of `A`.
    This is encoded as a type class `Algebra R A`. The morphism from `R` to `A` is
    called the structure map and is denoted `algebraMap R A : R →+* A` in Lean. Multiplication
    of `a : A` by `algebraMap R A r` for some `r : R` is called the scalar multiplication
    of `a` by `r` and denoted by `r • a`. Note that this notion of algebra is sometimes
    called an *associative unital algebra* to emphasize the existence of more general
    notions of algebra.'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '给定一个交换（半）环 `R`，`R` 上的代数是一个半环 `A`，它配备了一个环同态，其像与 `A` 的每个元素都交换。这被编码为类型类 `Algebra
    R A`。从 `R` 到 `A` 的映射称为结构映射，在 Lean 中表示为 `algebraMap R A : R →+* A`。对于某个 `r : R`，`a
    : A` 通过 `algebraMap R A r` 的乘法称为 `a` 通过 `r` 的标量乘法，并用 `r • a` 表示。请注意，这种代数的概念有时被称为
    *结合有单位代数*，以强调存在更一般的代数概念。'
- en: 'The fact that `algebraMap R A` is ring morphism packages together a lot of
    properties of scalar multiplication, such as the following:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是 `algebraMap R A` 是一个环同态，它将标量乘法的许多性质打包在一起，例如以下内容：
- en: '[PRE321]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: The morphisms between two `R`-algebras `A` and `B` are ring morphisms which
    commute with scalar multiplication by elements of `R`. They are bundled morphisms
    with type `AlgHom R A B`, which is denoted by `A →ₐ[R] B`.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 `R`-代数 `A` 和 `B` 之间的映射是环同态，它们与 `R` 的元素进行标量乘法时保持交换。它们是带有类型 `AlgHom R A B`
    的打包映射，用 `A →ₐ[R] B` 表示。
- en: Important examples of non-commutative algebras include algebras of endomorphisms
    and algebras of square matrices, both of which will be covered in the chapter
    on linear algebra. In this chapter we will discuss one of the most important examples
    of a commutative algebra, namely, polynomial algebras.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 非交换代数的重要例子包括自同态代数和方阵代数，这两者都将在线性代数章节中介绍。在本章中，我们将讨论一个最重要的交换代数例子，即多项式代数。
- en: The algebra of univariate polynomials with coefficients in `R` is called `Polynomial
    R`, which can be written as `R[X]` as soon as one opens the `Polynomial` namespace.
    The algebra structure map from `R` to `R[X]` is denoted by `C`, which stands for
    “constant” since the corresponding polynomial functions are always constant. The
    indeterminate is denoted by `X`.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 单变量多项式代数，其系数在 `R` 中，被称为 `多项式R`，一旦打开 `多项式` 命名空间，就可以写成 `R[X]`。从 `R` 到 `R[X]` 的代数结构映射用
    `C` 表示，因为相应的多项式函数始终是常数。不定元用 `X` 表示。
- en: '[PRE322]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: In the first example above, it is crucial that we give Lean the expected type
    since it cannot be determined from the body of the definition. In the second example,
    the target polynomial algebra can be inferred from our use of `C r` since the
    type of `r` is known.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述第一个例子中，我们向 Lean 提供预期的类型是至关重要的，因为它不能从定义的主体中确定。在第二个例子中，目标多项式代数可以通过我们对 `C r`
    的使用来推断，因为 `r` 的类型是已知的。
- en: 'Because `C` is a ring morphism from `R` to `R[X]`, we can use all ring morphisms
    lemmas such as `map_zero`, `map_one`, `map_mul`, and `map_pow` before computing
    in the ring `R[X]`. For example:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `C` 是从 `R` 到 `R[X]` 的环同态，所以我们可以在环 `R[X]` 中计算之前，使用所有环同态引理，如 `map_zero`、`map_one`、`map_mul`
    和 `map_pow`。例如：
- en: '[PRE323]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: You can access coefficients using `Polynomial.coeff`
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `Polynomial.coeff` 访问系数。
- en: '[PRE324]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: 'Defining the degree of a polynomial is always tricky because of the special
    case of the zero polynomial. Mathlib has two variants: `Polynomial.natDegree :
    R[X] → ℕ` assigns degree `0` to the zero polynomial, and `Polynomial.degree :
    R[X] → WithBot ℕ` assigns `⊥`. In the latter, `WithBot ℕ` can be seen as `ℕ ∪
    {-∞}`, except that `-∞` is denoted `⊥`, the same symbol as the bottom element
    in a complete lattice. This special value is used as the degree of the zero polynomial,
    and it is absorbent for addition. (It is almost absorbent for multiplication,
    except that `⊥ * 0 = 0`.)'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '定义多项式的次数总是很棘手，因为零多项式的特殊情况。Mathlib 有两种变体：`Polynomial.natDegree : R[X] → ℕ` 将零多项式的次数赋值为
    `0`，而 `Polynomial.degree : R[X] → WithBot ℕ` 赋值为 `⊥`。在后一种情况下，`WithBot ℕ` 可以看作是
    `ℕ ∪ {-∞}`，除了 `-∞` 用 `⊥` 表示，这与完备格中的底元素符号相同。这个特殊值被用作零多项式的次数，并且对加法是吸收的。（对于乘法几乎也是吸收的，除了
    `⊥ * 0 = 0`。）'
- en: Morally speaking, the `degree` version is the correct one. For instance, it
    allows us to state the expected formula for the degree of a product (assuming
    the base ring has no zero divisor).
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 从道德上讲，`degree`版本是正确的。例如，它允许我们陈述乘积的度数的预期公式（假设基环没有零因子）。
- en: '[PRE325]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: Whereas the version for `natDegree` needs to assume non-zero polynomials.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 与`natDegree`版本不同，需要假设多项式不为零。
- en: '[PRE326]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: 'However, `ℕ` is much nicer to use than `WithBot ℕ`, so Mathlib makes both versions
    available and provides lemmas to convert between them. Also, `natDegree` is the
    more convenient definition to use when computing the degree of a composition.
    Composition of polynomial is `Polynomial.comp` and we have:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`ℕ`比`WithBot ℕ`更易于使用，因此Mathlib提供了这两种版本，并提供了将它们之间转换的引理。此外，当计算复合的度数时，`natDegree`是更方便的定义。多项式的复合是`Polynomial.comp`，我们有：
- en: '[PRE327]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: 'Polynomials give rise to polynomial functions: any polynomial can be evaluated
    on `R` using `Polynomial.eval`.'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式产生多项式函数：任何多项式都可以使用`Polynomial.eval`在`R`上评估。
- en: '[PRE328]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: In particular, there is a predicate, `IsRoot`, that holds for elements `r` in
    `R` where a polynomial vanishes.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，存在一个谓词`IsRoot`，它对`R`中的元素`r`成立，其中多项式为零。
- en: '[PRE329]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: We would like to say that, assuming `R` has no zero divisor, a polynomial has
    at most as many roots as its degree, where the roots are counted with multiplicities.
    But once again the case of the zero polynomial is painful. So Mathlib defines
    `Polynomial.roots` to send a polynomial `P` to a multiset, i.e. the finite set
    that is defined to be empty if `P` is zero and the roots of `P`, with multiplicities,
    otherwise. This is defined only when the underlying ring is a domain since otherwise
    the definition does not have good properties.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望说，假设`R`没有零因子，多项式的根的数量最多与其度数相同，其中根是按重数计算的。但又一次，零多项式的情况很痛苦。因此，Mathlib定义`Polynomial.roots`将多项式`P`发送到多重集，即如果`P`为零则定义为空集，否则是`P`的根，带有重数。这个定义仅在基础环是域时才成立，因为否则定义没有良好的性质。
- en: '[PRE330]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: 'Both `Polynomial.eval` and `Polynomial.roots` consider only the coefficients
    ring. They do not allow us to say that `X ^ 2 - 2 : ℚ[X]` has a root in `ℝ` or
    that `X ^ 2 + 1 : ℝ[X]` has a root in `ℂ`. For this, we need `Polynomial.aeval`,
    which will evaluate `P : R[X]` in any `R`-algebra. More precisely, given a semiring
    `A` and an instance of `Algebra R A`, `Polynomial.aeval` sends every element of
    `a` along the `R`-algebra morphism of evaluation at `a`. Since `AlgHom` has a
    coercion to functions, one can apply it to a polynomial. But `aeval` does not
    have a polynomial as an argument, so one cannot use dot notation like in `P.eval`
    above.'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '`Polynomial.eval`和`Polynomial.roots`只考虑系数环。它们不允许我们说`X ^ 2 - 2 : ℚ[X]`在`ℝ`中有根，或者`X
    ^ 2 + 1 : ℝ[X]`在`ℂ`中有根。为此，我们需要`Polynomial.aeval`，它将在任何`R`-代数中评估`P : R[X]`。更精确地说，给定一个半环`A`和一个`Algebra
    R A`实例，`Polynomial.aeval`将`a`中的每个元素沿着在`a`上的评估的`R`-代数同态发送。由于`AlgHom`可以强制转换为函数，因此可以将它应用于多项式。但是`aeval`没有多项式作为参数，因此不能像上面的`P.eval`那样使用点符号。'
- en: '[PRE331]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: The function corresponding to `roots` in this context is `aroots` which takes
    a polynomial and then an algebra and outputs a multiset (with the same caveat
    about the zero polynomial as for `roots`).
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中对应于`roots`的函数是`aroots`，它接受一个多项式然后是一个代数，并输出一个多重集（与`roots`相同的关于零多项式的警告）。
- en: '[PRE332]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: 'More generally, given an ring morphism `f : R →+* S` one can evaluate `P :
    R[X]` at a point in `S` using `Polynomial.eval₂`. This one produces an actual
    function from `R[X]` to `S` since it does not assume the existence of a `Algebra
    R S` instance, so dot notation works as you would expect.'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '更一般地，给定一个环同态`f : R →+* S`，可以使用`Polynomial.eval₂`在`S`中的某个点评估`P : R[X]`。这个操作实际上产生了一个从`R[X]`到`S`的函数，因为它不假设存在一个`Algebra
    R S`实例，所以点符号的使用方式符合预期。'
- en: '[PRE333]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: 'Let us end by mentioning multivariate polynomials briefly. Given a commutative
    semiring `R`, the `R`-algebra of polynomials with coefficients in `R` and indeterminates
    indexed by a type `σ` is `MVPolynomial σ R`. Given `i : σ`, the corresponding
    polynomial is `MvPolynomial.X i`. (As usual, one can open the `MVPolynomial` namespace
    to shorten this to `X i`.) For instance, if we want two indeterminates we can
    use `Fin 2` as `σ` and write the polynomial defining the unit circle in \(\mathbb{R}^2`\)
    as:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们简要地提及多元多项式。给定一个交换半环`R`，系数在`R`中且变量由类型`σ`索引的多项式`R`-代数是`MVPolynomial σ R`。给定`i
    : σ`，相应的多项式是`MvPolynomial.X i`。（像往常一样，可以打开`MVPolynomial`命名空间以缩短为`X i`。）例如，如果我们想要两个变量，我们可以使用`Fin
    2`作为`σ`，并将定义单位圆的`R^2`中的多项式写为：'
- en: '[PRE334]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: Recall that function application has a very high precedence so the expression
    above is read as `(X 0) ^ 2 + (X 1) ^ 2 - 1`. We can evaluate it to make sure
    the point with coordinates \((1, 0)\) is on the circle. Recall the `![...]` notation
    denotes elements of `Fin n → X` for some natural number `n` determined by the
    number of arguments and some type `X` determined by the type of arguments.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，函数应用具有非常高的优先级，因此上述表达式被读取为 `(X 0) ^ 2 + (X 1) ^ 2 - 1`。我们可以对其进行评估以确保坐标为
    \((1, 0)\) 的点位于圆上。回想一下，`![...]` 符号表示由自然数 `n` 确定的 `Fin n → X` 的元素，其中 `n` 由参数的数量决定，而
    `X` 由参数的类型决定。
- en: '[PRE335]*'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE335]*'
