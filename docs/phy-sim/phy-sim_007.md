# 隐式时间积分

> 原文：[`phys-sim-book.github.io/lec1.5-implicit_time_integration.html`](https://phys-sim-book.github.io/lec1.5-implicit_time_integration.html)

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">

与显式时间积分相比，隐式时间积分需要解决一个方程组以确定 \(x^{n+1}\) 和 \(v^{n+1}\) 的值。这种方法的一个显著优点是它有可能大大提高稳定性。隐式积分的最简单形式，即向后欧拉方法，如下所述。

> ****方法 1.5.1（向后欧拉时间积分应用于牛顿第二定律）****。给定当前状态变量、质量矩阵以及从 \(t^n\) 到 \(t^{n+1}\) 的时间间隔，更新规则如下：\(x_{n+1} v_{n+1} = x_n + \Delta t v_n + \Delta t M^{-1} f_{n+1}\)，其中 \(n\) 的范围从 \(0,1,2,\dots\)。

在本书讨论的许多场景中，力是通过位置向量 \(x\) 导出的。因此，我们可以表示 \(f^{n+1} = f(x^{n+1})\)。认识到 \(x^{n+1}\) 的更新依赖于知道 \(v^{n+1}\)，而 \(v^{n+1}\) 的计算又依赖于 \(x^{n+1}\)，这一点至关重要。这种相互依赖性产生了一个循环依赖，需要解决一个方程组来准确找到 \(x^{n+1}\) 和 \(v^{n+1}\)。通过公式 \(v^{n+1} = (x^{n+1} - x^n) / \Delta t\)，方程 (1.5.1) 可以重新表述为：\(M(x_{n+1} - (x_n + \Delta t v_n)) - \Delta t² f(x_{n+1}) = 0\)。(1.5.2) 由于力 \(f\) 通常在位置 \(x\) 方面表现出非线性，方程 (1.5.2) 通常是非线性的，需要使用非线性根查找技术，如**牛顿法**进行求解。

> ****方法 1.5.2（牛顿法应用于向后欧拉时间积分）****。如以下算法所述，牛顿法是一种从解的初始估计 \(x^i\) 开始的迭代技术。在当前迭代 \(x^i\) 时，它线性近似 \(f(x^{n+1}) \approx f(x^i) + (x^{n+1}-x^i) \nabla f(x^i)\)，然后解决一个线性系统并更新迭代。这个过程重复进行，直到达到令人满意的收敛程度。
> 
> **算法 1.5.1（向后欧拉时间积分的牛顿法）** ![](img/886e6bd1c54ee6b52a8aefe0b0295d47.png)

虽然向后欧拉方法确保了对于大的 \(\Delta t\) 值的**无条件稳定性**，但重要的是要认识到增加 \(\Delta t\) 可能会导致系统条件恶化。这种复杂性可能会使解决线性系统更加困难。此外，重要的是要记住，力线性化是一个近似。如果解的初始估计远离实际解，牛顿法的标准迭代可能不会收敛，甚至可能发散。

在后续讨论中，我们将介绍牛顿法的改进版本。这种改进旨在确保对于特定类型的问题，无论初始估计或\(\Delta t\)的大小如何，都能保证收敛。
