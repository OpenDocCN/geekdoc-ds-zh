地图 > 数据科学 > 预测未来 > 建模 > 聚类 > K-Means

# K-Means 聚类

K-Means 聚类旨在将*n*个对象分成*k*个簇，其中每个对象属于具有最近均值的簇。该方法产生最大可能区分的*k*个不同簇。导致最大分离（距离）的最佳簇数*k*事先不知道，必须从数据中计算得出。K-Means 聚类的目标是最小化总内部簇方差，或者说，平方误差函数：

![](img/ed5bbb05ebf413c222a1f376295bf811.jpg)

**算法**

1.  将数据聚类成预定义的*k*组。

1.  随机选择*k*个点作为簇中心。

1.  根据*欧氏距离*函数将对象分配到最近的簇中心。

1.  计算每个簇中所有对象的质心或均值。

1.  重复步骤 2、3 和 4，直到连续轮次中每个簇都分配相同的点。

![](img/e24409d58c4db5126e0ece78b91b09e6.jpg)

K-Means 是一个相对高效的方法。然而，我们需要提前指定簇的数量，并且最终结果对初始化非常敏感，通常在局部最优点终止。不幸的是，没有全局理论方法来找到最佳簇的数量。一个实用的方法是比较多次运行不同*k*的结果，并根据预定义的标准选择最佳结果。一般来说，较大的*k*可能会减少错误但增加过拟合的风险。*示例*：假设我们想要仅使用年龄（一维空间）对网站访问者进行分组如下：15,15,16,19,19,20,20,21,22,28,35,40,41,42,43,44,60,61,65**初始簇：**质心（C1）= 16 [16]

质心（C2）= 22 [22]迭代**1**：C1 = 15.33 [15,15,16]

C2 = 36.25 [19,19,20,20,21,22,28,35,40,41,42,43,44,60,61,65]迭代**2**：C1 = 18.56 [15,15,16,19,19,20,20,21,22]

C2 = 45.90 [28,35,40,41,42,43,44,60,61,65]迭代**3**：C1 = 19.50 [15,15,16,19,19,20,20,21,22,28]

C2 = 47.89 [35,40,41,42,43,44,60,61,65]迭代**4**：C1 = 19.50 [15,15,16,19,19,20,20,21,22,28]

C2 = 47.89 [35,40,41,42,43,44,60,61,65]在第 3 和第 4 次迭代之间没有变化。通过聚类，已经确定了 2 个组 15-28 和 35-65。初始质心的选择会影响输出簇，因此通常以不同的起始条件多次运行算法，以便公平地了解应该是什么样的簇。

| 练习 | ![](img/Kmeans.txt) | [K Means 交互式](http://home.dei.polimi.it/matteucc/Clustering/tutorial_html/AppletKM.html) |
| --- | --- | --- |
