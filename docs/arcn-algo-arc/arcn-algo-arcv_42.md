# 数据压缩

> 原文：[`www.algorithm-archive.org/contents/data_compression/data_compression.html`](https://www.algorithm-archive.org/contents/data_compression/data_compression.html)

我得坦白，数据压缩曾经是一个非常热门的话题，但现在的孩子们通常拥有极其强大的设备，似乎根本不受内存限制。正因为如此，谈论数据压缩作为一个激烈辩论和发展的领域似乎有些奇怪。天真地看来，更好的硬件意味着程序员面临的限制更少，也不需要寻找新的独特方法来压缩他们的数据；然而，事实远非如此。

话虽如此，市场上总会出现需要最小化数据存储的新设备。实际上，今天存在的许多最革命性的算法和方法都属于数据压缩的范畴。从无损数据压缩的 Huffman 编码到遗传压缩算法和机器学习，这个领域有很多东西可以学习，我们将逐一探讨。

所有这些话，不先讨论信息本身，特别是信息在计算机系统中的表示方式，就不可能完成关于数据压缩的讨论。现在，我们已经在位逻辑中深入讨论过这一点，但故事远比我们之前透露的要多。让我们从一个信息的工作定义开始：

*信息是确定性的表示。*

这可能听起来像是一个愚蠢的、挥挥手就过去的定义，但请听我解释。如果我对某事不确定，我会提出问题。这个问题的答案可能是任何东西，但它将包含某个具有一定程度确定性的人的信息。例如，让我们假设你已经连续几个月在你的母亲的地下室里疯狂编码（这种情况确实会发生）。在某个时候，你意识到你没有出去过，完全不知道是哪一天、哪个月，甚至哪一年！有一天，你的母亲从门下塞食物给你，你伸手问她，“今天外面怎么样？”对于孩子终于离开房间感到欣喜若狂的母亲可能会说，“阳光明媚，温暖宜人。是个出去放松的好天气！”这为你提供了很多信息，并且在一定程度上，你可以得出结论，现在是夏天。

当然，在得到答案后，你不会承认你母亲的存在，然后回到编码。你已经得到了你需要的信息。没有必要通过进一步的人际交往来使事情复杂化。

看看，信息因多种原因在不同的地方被定义，所以为了我们的目的，我们将信息单位定义为*比特*，一个简单的二进制 1 或 0。以之前提到的例子为例（假设你可以相信你母亲的话），你得到了 3 个真实陈述：

1.  它很明亮

1.  天气晴朗

1.  天气温暖

有这些信息，你假设可能是夏天。不幸的是，你对它是夏天的假设不是信息。这可能是一个逻辑结论，但它并没有作为“事实”提供。这是我们可能口语描述的信息和信息论所要求的信息之间的重要区别。信息论与测量——二元绝对值。

现在，我们可以清楚地表示，*有一定的概率*它是夏天，但这完全是另一回事，我们无疑会在未来讨论。现在，让我们谈谈计算机系统上信息简单表示的方法。想象一下，你有一个简单的字母表，其中只有两个字符，*a*和*b*。在这种情况下，你可以用很多种方式用比特表示这些字符，但最明显的方式可能看起来像这样：

| 字符 | 比特表示 |
| --- | --- |
| *a* | 0 |
| *b* | 1 |

只要你不向其中添加任何新字符，这组码字就是完全有效的。如果你得到比特串 0111101，你可以轻松地将其解码为*abbbbab*。

但如果你想要添加第三个字符*c*呢？很明显，*c*不能是 0 或 1，但由于我们定义的码字集的方式，它实际上不能是 0 或 1 的任何组合。例如，如果我们定义*c*为 01，并且我们提供了比特串 0111101，我们可以将这个字符串解释为*abbbbab*或*cbbbc*！现在，我们可以使用上下文或其他提供的信息来区分这两种可能的情况，但很明显，我们需要更深入地思考我们的码字集。

首先，让我们稍微思考一下解码。就我们的目的而言，我们不想在解码时思考。无论我们需要解码的比特串是什么，我们都希望能够逐比特读取，直到在我们的码字集中找到匹配项并继续。基本上，我们不想在我们的码字集中有任何歧义。码字*c*不应该包含码字*a*或*b*！这样，我们的码字集应该是*前缀无关的*。没有任何单词应该作为另一个单词的前缀出现。

如果我们想要为 4 个字符(*a*，*b*，*c*和*d*)找到一个好的、前缀无关的码字集，它可能看起来像这样：

| 字符 | 比特表示 |
| --- | --- |
| *a* | 00 |
| *b* | 01 |
| *c* | 10 |
| *d* | 11 |

我们可以用这个集合解码任何偶数比特串。0100101010110100 是*bacccdba*。这很好，但现在我们又有另一个问题：给定一个字符串，我们能否构造一个码字集，使其对应的比特串的位数*最小化*？

*这是数据压缩的核心！*

首先，让我们定义一个简单的度量来衡量数据的压缩程度。让我们考虑以下字符集：*abbcccdddd*。如果我们把这些字母都放在一个袋子里，随机抽取一个，我们会得到以下抽取任何字母的概率：

| 字符 | 概率 |
| --- | --- |
| *a* | .1 |
| *b* | .2 |
| *c* | .3 |
| *d* | .4 |

这基本上意味着我们抽取一个*d*的概率远大于抽取一个*a*的概率，如果我们试图最小化编码位串的长度，那么*d*的位表示长度可能应该比*a*的位表示长度短。最终，为了压缩我们的编码位串，我们希望最小化以下数量：

其中  是我们的字母表中的字符，  是单个字符的码字，  与从袋子中抽取该字符的概率相关，  是获取特定字符的个体概率，  是一个模糊的无量纲量，用于确定整体长度，通常用于确定压缩比。为了展示这是如何工作的，让我们考虑使用两种不同的字母表来编码单词*abbcccdddd*：

| 字符 | 概率 | 位表示 1 | 位表示 2 |
| --- | --- | --- |
| *a* | .1 | 00 | 000 |
| *b* | .2 | 01 | 001 |
| *c* | .3 | 10 | 01 |
| *d* | .4 | 11 | 1 |

在这种情况下：

在这里，很明显，因此第二组码字比第一组更有效地压缩了我们的数据。这个度量可以作为某些简单数据压缩技术的直接测试，特别是那些由香农、法诺和 Huffman 创造的，这些内容将在后面介绍！

## License

##### Code Examples

代码示例受 MIT 许可证（在[LICENSE.md](https://github.com/algorithm-archivists/algorithm-archive/blob/main/LICENSE.md)中找到）许可。

##### Text

本章的文本由[James Schloss](https://github.com/leios)编写，并受[Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/legalcode)许可。

[](https://creativecommons.org/licenses/by-sa/4.0/)

![](https://creativecommons.org/licenses/by-sa/4.0/)

##### Pull Requests

在初始许可([#560](https://github.com/algorithm-archivists/algorithm-archive/pull/560))之后，以下拉取请求已修改本章的文本或图形：

+   none
