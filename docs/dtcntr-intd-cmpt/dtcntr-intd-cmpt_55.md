# 17.5 摩拉维亚生成树

> 原文：[`dcic-world.org/2025-08-27/mst.html`](https://dcic-world.org/2025-08-27/mst.html)

| |   17.5.1 问题 |
| --- | --- |
| |   17.5.2 贪婪算法解决方案 |
| |   17.5.3 另一种贪婪算法解决方案 |
| |   17.5.4 第三种解决方案 |
| |   17.5.5 检查组件连通性 |

在千年之交，美国国家工程院对其成员进行了调查，以确定“20 世纪最伟大的工程成就”。名单上包含了常见的候选者：电子、计算机、互联网等等。但一个可能令人惊讶的想法位居榜首：（农村）电气化。更多关于它的信息[可以在他们的网站上找到](http://www.greatachievements.org/).

#### 17.5.1 问题 "链接至此")

要了解国家电网的历史，回到 20 世纪 20 年代的[摩拉维亚](http://en.wikipedia.org/wiki/Moravia)是有帮助的。像世界上许多其他地区一样，它开始意识到电力的好处，并打算在该地区推广电力。一位名叫奥塔卡尔·博鲁瓦卡的摩拉维亚学者听说了这个问题，在非凡的努力下，他抽象地描述了这个问题，这样就可以在没有参考摩拉维亚或电网的情况下理解它。他将它建模为一个关于图的问题。

博鲁瓦卡观察到，至少最初，任何解决创建网络问题的方案必须具有以下特征：

+   电网必须覆盖所有打算覆盖的城镇。在图论术语中，解决方案必须是生成树，这意味着它必须访问图中的每个节点。

+   冗余是任何网络中的一个宝贵属性：这样，如果一组链接中断，可能会有另一种方式将有效载荷发送到目的地。然而，在开始时，冗余可能过于昂贵，尤其是如果它是以不向某人发送有效载荷为代价的话。因此，最初的解决方案最好设置成没有环路甚至冗余路径。在图论术语中，解决方案必须是一棵树。

+   最后，目标是尽可能以最低的成本解决这个问题。在图论术语中，图将是加权的，解决方案必须是最小值。

因此，博鲁瓦卡定义了摩拉维亚生成树（MST）问题。

#### 17.5.2 贪婪算法解决方案 "链接至此")

博鲁瓦卡发表了这个问题，另一位捷克数学家[沃伊捷赫·亚尼克](http://en.wikipedia.org/wiki/Vojt%C4%9Bch_Jarn%C3%ADk)偶然发现了它。亚尼克提出了一种听起来熟悉的解决方案：

+   从一个由单个节点组成的解决方案开始，这个节点是任意选择的。对于由这个节点组成的图，这个解决方案显然是最小、生成和一棵树。

+   在所有与解决方案中的节点相连且尚未包含在解决方案中的节点相连的边中，选择权重最小的边。请注意，我们只考虑这些边，而不是它们附加到它们所连接的节点的权重。

+   将此边添加到解决方案中。断言是，新的解决方案将是一个树（通过构造），一个生成树（也是通过构造），并且是最小生成树。最小性可以通过与 Dijkstra 算法类似的方法来证明。

Jarník 不幸的是在 1930 年用捷克语发表了这项工作，并且它基本上被忽视了。它被其他人重新发现，最著名的是 R.C. Prim 在 1957 年，现在通常被称为 Prim 算法，尽管称之为 Jarník 算法会正确地归功于他。

实现这个算法相当简单。在每一个点上，我们需要知道当前解决方案树上的最轻边。找到最轻边需要的时间与这些边的数量成线性关系，但最轻的边可能会创建一个环。因此，我们需要有效地检查添加边是否会创建一个环，这是一个我们将多次返回的问题 [检查组件连通性]。假设我们能够有效地做到这一点，然后我们想要添加最轻的边并迭代。即使给出了检查环的有效解决方案，这似乎也需要对每个节点进行线性操作。通过更好的表示，我们可以改进这个复杂性，但让我们先看看其他想法。

#### 17.5.3 另一种贪婪解法 "链接到此处")

回想一下，Jarník 在 1930 年提出了他的算法，当时还没有计算机，而 Prim 在 1957 年提出了他的算法，当时计算机还处于婴儿期。编程计算机跟踪堆栈是一个非平凡的问题，许多算法都是手工实现的，而跟踪复杂的数据结构而不出错则更加困难。需要一种解决方案，它需要的手动记录更少（字面上讲）。

在 1956 年，[约瑟夫·克鲁斯卡尔](http://en.wikipedia.org/wiki/Joseph_Kruskal) 提出了这样的解决方案。他的想法简单而优雅。Jarník 算法的问题在于每次树增长时，我们必须修改堆的内容，而这已经是一个难以跟踪的混乱结构。Kruskal 注意到以下几点。

为了获得最小解，我们当然希望将图中权重最小的边之一包含在内。因为如果不这样做，我们可以取一个其他的最小解，添加这条边，并移除另一条边；图仍然保持连通，但总权重不会更多，如果移除的边更重，则会更少。注意措辞的准确性：可能存在许多权重相同的边，添加其中之一可能会移除另一条，因此不会产生更轻的树；但关键点是，它肯定不会产生更重的树。通过同样的论据，我们可以添加下一个最轻的边，再下一个最轻的边，依此类推。唯一不能添加下一个最轻边的情形是，它会形成一个环（又是这个问题！）。

因此，克鲁斯卡尔算法（Kruskal's algorithm）极其简单明了。我们首先按升序对所有边进行排序。然后，我们按升序顺序取每条边，如果它不会形成环，就将其添加到解中。当我们这样处理完所有边后，我们将得到一个树形解（通过构造），它覆盖了所有连接的顶点（因为每个连接的顶点必须是某条边的端点），并且具有最小权重（根据上述论据）。其复杂度与排序相同（即 \([e \rightarrow e \log e]\)，其中 \(e\) 是边集的大小）。然后我们遍历 \(e\) 中的每个元素，这需要与该集合大小成线性关系的时间——<wbr>减去检查环所需的时间。这个算法也容易在纸上实现，因为我们只对所有的边进行一次排序，然后按顺序检查它们，划掉那些形成环的边——<wbr>无需动态更新列表。

#### 17.5.4 第三个解决方案 "链接至此")

Jarník 和 Kruskal 的解都有一个问题：它们需要一个集中的数据结构（优先堆或排序列表）来逐步构建解。随着并行计算机的出现和图问题规模的扩大，计算机科学家寻找在并行中更有效实现的解决方案——<wbr>这通常意味着避免任何集中的同步点，例如这些集中的数据结构。

在 1965 年，M. Sollin 构建了一个完美满足这些需求的算法。在这个算法中，我们不是构建单个解，而是构建多个解组件（如果愿意，可以并行构建）。每个节点最初都是一个解组件（就像在 Jarník 算法的第一步中那样）。每个节点考虑与其相连的边，并选择连接到不同组件的最轻边（又是这个问题！）。如果可以找到这样的边，该边就成为解的一部分，两个组件合并成为一个组件。整个过程重复进行。

因为每个节点最初都是解决方案的一部分，这个算法自然地扩展。因为它检查循环并避免它们，它自然地形成一个树。请注意，避免循环会产生一个有向无环图（DAG），并不自动保证产生一个树。我们在本节中对此差异有点宽松。最后，最小性通过与我们用于 Jarník 算法的类似推理得出，我们实际上已经从每个节点并行运行，直到并行解决方案组件连接起来产生全局解决方案。

当然，手动维护此算法的数据是一个噩梦。因此，这个算法在数字时代被提出并不令人惊讶。因此，真正的惊喜是它并不是：它最初是由[奥塔卡·博鲁夫卡](http://en.wikipedia.org/wiki/Otakar_Bor%C5%AFvka)本人创建的。

你看，博鲁夫卡已经全部弄明白了。他不仅理解了问题，而且还：

+   准确地指出了电化问题背后的真正问题，使其能够以独立于上下文的方式看待，

+   创建了一种描述性的图论语言来精确地定义它，并且

+   不仅定义了问题，还解决了它。

他提出了一种过于复杂的解决方案，以至于 Jarník 实际上将其去并行化，以便可以顺序执行。因此，这个算法一直未被注意，直到 Sollin 重新发明（实际上[多次](http://en.wikipedia.org/wiki/Bor%C5%AFvka's_algorithm)）它，以便在并行计算人员注意到需要它的时候。但现在我们可以简单地称之为博鲁夫卡算法，这是非常合适的。

如你现在可能已经猜到的，这个问题在其他教科书中确实被称为最小生成树（MST），但“M”不是指摩拉维亚，而是指“最小”。但鉴于博鲁夫卡在历史中的被遗忘地位，我们更喜欢更幽默的名字。

#### 17.5.5 检查组件连通性 "链接至此")

正如我们所见，我们需要能够高效地判断两个节点是否属于同一组件。一种方法是从此节点开始进行深度优先遍历（或广度优先遍历），并检查我们是否曾访问过第二个节点。（使用这些遍历策略之一确保了在存在环的情况下能够终止。）不幸的是，这对每一对节点来说都需要线性时间（与图的大小成正比）——并且根据图和节点的选择，我们可能在每次添加边时对图中的每个节点都这样做！因此，我们显然希望做得更好。

将此问题从图连通性简化为更一般的问题：并集结构（俗称为并查集，原因很快就会清楚）。如果我们把每个连通组件看作一个集合，那么我们就是在询问两个节点是否属于同一个集合。但将其作为集合成员问题提出，它也适用于其他几个应用。

设置如下。对于任意值，我们希望它们被视为集合中的元素。我们感兴趣的两个操作是。一个是显然的 `union`，它将两个集合合并为一个。另一个似乎是 `is-in-same-set`，它接受两个元素并确定它们是否在同一个集合中。然而，随着时间的推移，定义操作符 `find` 已经被证明是有用的，给定一个元素，“命名”该元素所属的集合（稍后我们会详细说明）。为了检查两个元素是否在同一个集合中，我们然后必须获取每个元素的“集合名称”，并检查这些名称是否相同。这确实听起来有些绕，但这意味着我们有一个可能在其他上下文中有用的原始操作，并且我们可以很容易地实现 `is-in-same-set`。

现在的问题是，我们如何命名集合？我们应该问的真正问题是，我们对这些名称关心哪些操作？我们唯一关心的是，给定两个名称，它们代表相同的集合当且仅当名称相同。因此，我们可以构造一个新的字符串、数字或其他东西，但我们还有一个选择：简单地选择集合中的一个元素来代表它，即作为它的名称。因此，我们将每个集合元素与表示该元素的“集合名称”的指示符相关联；如果没有，那么它的名称就是它自己（`parent` 的 `none` 情况）：

```py
data Element<T>:
  | elt(val :: T, parent :: Option<Element>)
end
```

我们将假设我们有一些等价性谓词来检查两个元素是否相同，我们通过比较它们的值部分来实现，忽略它们的父值：

```py
fun is-same-element(e1, e2): e1.val <=> e2.val end
```

> 现在行动！
> 
> > 为什么我们只检查值部分？

我们将假设对于给定的集合，我们总是返回相同的代表元素。（否则，即使我们有相同的集合，等价性也会失败。）因此：我们使用名称 `fynd` 是因为 `find` 在 Pyret 中已经被定义为表示其他含义。如果你不喜欢这个拼写错误，你可以使用更长的名称，比如 `find-root`。

```py
fun is-in-same-set(e1 :: Element, e2 :: Element, s :: Sets)
    -> Boolean:
  s1 = fynd(e1, s)
  s2 = fynd(e2, s)
  identical(s1, s2)
end
```

其中 `Sets` 是所有元素的列表：

```py
type Sets = List<Element>
```

我们如何找到一个集合的代表元素？我们首先使用 `is-same-element` 来找到它；当我们找到它时，我们检查元素的 `parent` 字段。如果它是 `none`，这意味着这个元素本身命名了它的集合；这可能是因为元素是单元素集合（我们将所有元素初始化为 `none`），或者它是某个更大集合的名称。无论如何，我们已经完成了。否则，我们必须递归地找到父元素：

```py
fun fynd(e :: Element, s :: Sets) -> Element:
  cases (List) s:
    | empty => raise("fynd: shouldn't have gotten here")
    | link(f, r) =>
      if is-same-element(f, e):
        cases (Option) f.parent:
          | none => f
          | some(p) => fynd(p, s)
        end
      else:
        fynd(e, r)
      end
  end
end
```

> 练习
> 
> > 为什么在嵌套的 `cases` 中有递归调用？

剩下的就是实现 `union`。为此，我们找到我们想要合并的两个集合的代表元素；如果它们是相同的，那么这两个集合已经在一个联合中；否则，我们必须更新数据结构：

```py
fun union(e1 :: Element, e2 :: Element, s :: Sets) -> Sets:
  s1 = fynd(e1, s)
  s2 = fynd(e2, s)
  if identical(s1, s2):
    s
  else:
    update-set-with(s, s1, s2)
  end
end
```

为了更新，我们任意选择一个集合名称作为新复合集合的名称。然后我们必须更新其他集合名称元素的父元素为这个名称：

```py
fun update-set-with(s :: Sets, child :: Element, parent :: Element)
    -> Sets:
  cases (List) s:
    | empty => raise("update: shouldn't have gotten here")
    | link(f, r) =>
      if is-same-element(f, child):
        link(elt(f.val, some(parent)), r)
      else:
        link(f, update-set-with(r, child, parent))
      end
  end
end
```

这里有一些测试来说明这一点：

```py
check:
  s0 = map(elt(_, none), [list: 0, 1, 2, 3, 4, 5, 6, 7])
  s1 = union(get(s0, 0), get(s0, 2), s0)
  s2 = union(get(s1, 0), get(s1, 3), s1)
  s3 = union(get(s2, 3), get(s2, 5), s2)
  print(s3)
  is-same-element(fynd(get(s0, 0), s3), fynd(get(s0, 5), s3)) is true
  is-same-element(fynd(get(s0, 2), s3), fynd(get(s0, 5), s3)) is true
  is-same-element(fynd(get(s0, 3), s3), fynd(get(s0, 5), s3)) is true
  is-same-element(fynd(get(s0, 5), s3), fynd(get(s0, 5), s3)) is true
  is-same-element(fynd(get(s0, 7), s3), fynd(get(s0, 7), s3)) is true
end
```

不幸的是，这个实现存在两个主要问题：

+   首先，因为我们正在进行函数式更新，`parent`引用的值会“不断变化”，但这些变化对“相同”值的旧副本是不可见的。在并查集的不同阶段，一个元素有不同的父引用，尽管它在整个过程中可以说是相同的元素。这是函数式编程受伤害的地方。

+   相关地，这个实现的性能相当差。`fynd`递归遍历父节点以找到集合的名称，但遍历的元素没有被更新以记录这个新名称。我们当然可以通过每次重新构建集合来更新它们，但这会使实现复杂化，而且正如我们很快就会看到的，我们可以做得更好。

更糟糕的是，它甚至可能不正确！

> 练习
> 
> > 是吗？考虑构建不那么倾斜的`union`，看看你是否能得到预期的结果。

核心问题是纯函数式编程并不非常适合这个问题。我们需要一个更好的实现策略：并查集。

#### 17.5.1 问题 "链接到此处")

要了解国家电网的历史，回到 20 世纪 20 年代的[摩拉维亚](http://en.wikipedia.org/wiki/Moravia)可能会有所帮助。像世界上许多其他地方一样，它开始意识到电力的好处，并打算在该地区推广电力。一位名叫奥塔卡尔·博鲁瓦卡的摩拉维亚学者听说了这个问题，并在一个非凡的努力中，抽象地描述了这个问题，这样就可以在没有参考摩拉维亚或电网的情况下理解它。他将它建模为一个关于图的问题。

博鲁瓦卡观察到，至少最初，任何创建网络的解决方案都必须具有以下特征：

+   电网必须覆盖所有打算覆盖的城镇。在图论术语中，解决方案必须是生成性的，这意味着它必须访问图中的每个节点。

+   冗余是任何网络中的一个宝贵属性：这样，如果一组链接失效，可能会有另一种方式将有效载荷发送到目的地。然而，在开始时，冗余可能过于昂贵，尤其是如果它是以不向某人提供有效载荷为代价的话。因此，最初的解决方案最好设置为没有环路甚至冗余路径。在图论术语中，解决方案必须是一棵树。

+   最后，目标是尽可能以最低的成本解决这个问题。在图论术语中，图将是加权的，解决方案必须是最小值。

因此，博鲁瓦卡定义了摩拉维亚生成树（MST）问题。

#### 17.5.2 贪婪解法 "链接到此处")

博鲁瓦卡已经发表了这个问题，另一位捷克数学家[沃伊捷赫·亚尼克](http://en.wikipedia.org/wiki/Vojt%C4%9Bch_Jarn%C3%ADk)偶然发现了它。亚尼克提出了一个听起来熟悉的解决方案：

+   从一个由单个节点组成的解开始，这个节点是任意选择的。对于由这个节点组成的图，这个解显然是最小生成树、生成树和树。

+   在解中与节点相连且尚未包含在解中的节点之间，选择权重最小的边。请注意，我们只考虑这些边，而不是它们附加到它们所连接的节点的权重。

+   将这条边添加到解中。断言是，对于新的解将是一个树（通过构造），生成树（也通过构造），并且是最小的。最小性可以通过与 Dijkstra 算法中使用的类似论证得出。

Jarník 不幸在 1930 年将这项工作以捷克语发表，并且它几乎被忽视。它后来被其他人重新发现，最著名的是 R.C. Prim 在 1957 年，现在通常被称为 Prim 算法，尽管称之为 Jarník 算法会更准确地归功于正确的人。

实现这个算法相当简单。在每一个点上，我们需要知道当前解树上的最轻边。找到最轻边需要与这些边的数量成线性关系的时间，但最轻的边可能会形成一个环。因此，我们需要有效地检查添加边是否会形成环，这是一个我们将多次返回的问题[检查组件连通性)]。假设我们能够有效地做到这一点，然后我们想要添加最轻的边并迭代。即使给出了检查环的有效解决方案，这似乎也需要对每个节点进行线性于边数的操作。通过更好的表示，我们可以改进这个复杂性，但让我们先看看其他想法。

#### 17.5.3 另一种贪婪解法 "链接到此处")

回想一下，Jarník 在 1930 年提出了他的算法，当时计算机还不存在，而 Prim 在 1957 年提出了他的算法，当时计算机还处于婴儿期。编程计算机跟踪堆是一个非平凡的问题，许多算法都是手工实现的，在没有错误的情况下跟踪复杂的数据结构更加困难。需要一种需要更少手动记录（字面上说）的解决方案。

在 1956 年，[约瑟夫·克鲁斯卡尔](http://en.wikipedia.org/wiki/Joseph_Kruskal)提出了这样的解决方案。他的想法简单而优雅。Jarník 算法的问题在于每次树增长时，我们必须修改堆的内容，这已经是一个难以追踪的混乱结构。Kruskal 注意到了以下几点。

为了获得最小解，我们当然希望将图中权重最小的边之一包含在内。如果不这样做，我们可以取一个其他方面最小的解，添加这条边，并移除另一条边；图仍然保持连通，但总权重不会更多，如果移除的边更重，则更少。注意措辞的谨慎：可能存在许多权重相同的边，添加其中一条可能会移除另一条，因此不会产生更轻的树；但关键点是，它肯定不会产生更重的树。通过同样的论据，我们可以添加下一条最轻的边，再下一条，依此类推。唯一不能添加下一条最轻边的情况是，它会形成一个环（又是这个问题！）。

因此，Kruskal 算法极其简单。我们首先按升序对所有边进行排序。然后，我们按升序顺序取每条边，如果它不会形成环，就将其添加到解决方案中。当我们这样处理所有边后，我们将得到一个树形解决方案（通过构建），它覆盖所有连接的顶点（因为每个连通顶点必须是某条边的端点），并且具有最小权重（如上所述）。其复杂度与排序相同（即 \([e \rightarrow e \log e]\)，其中 \(e\) 是边集的大小）。然后我们遍历 \(e\) 中的每个元素，这需要与该集合大小成线性关系的时间——<wbr>减去检查环所需的时间。这个算法也容易在纸上实现，因为我们只对边进行一次排序，然后按顺序检查它们，划掉那些形成环的边——<wbr>不需要动态更新列表。

#### 17.5.4 第三种解决方案 "链接到此处")

Jarník 和 Kruskal 的解决方案都存在一个缺陷：它们需要集中式数据结构（优先堆或排序列表）来逐步构建解决方案。随着并行计算机的出现和图问题规模的扩大，计算机科学家们寻找能够在并行环境中更高效实现的解决方案——这通常意味着避免任何集中式的同步点，例如这些集中式数据结构。

1965 年，M. Sollin 构建了一个完美满足这些需求的算法。在这个算法中，我们不是构建单个解决方案，而是生长多个解决方案组件（如果愿意，可以并行地这样做）。每个节点最初都是一个解决方案组件（就像 Jarník 算法的第一步一样）。每个节点考虑与其相连的边，并选择连接到不同组件的最轻边（又是这个问题！）。如果可以找到这样的边，这条边就成为解决方案的一部分，两个组件合并成为一个组件。整个过程重复进行。

因为每个节点最初都是解决方案的一部分，这个算法自然地扩展了。因为它检查循环并避免它们，它自然地形成了一棵树。请注意，避免循环会产生一个有向无环图（DAG），并不自动保证产生一棵树。我们在本节中对此差异有点宽松。最后，最小性通过与我们用于 Jarník 算法的类似推理得出，我们实际上是在并行中运行的，每个节点运行一次，直到并行解决方案组件连接起来产生全局解决方案。

当然，手动维护这个算法的数据是一个噩梦。因此，这个算法是在数字时代被提出的这一点并不令人惊讶。因此，真正的惊喜是它并不是：它最初是由[Otakar Borůvka](http://en.wikipedia.org/wiki/Otakar_Bor%C5%AFvka)本人创造的。

你看，Borůvka 已经全部想明白了。他不仅理解了这个问题，他还：

+   准确地指出了电化问题背后的真正问题，以便可以从独立于上下文的方式来看待它，

+   创建了一种图论描述性语言来精确地定义它，

+   不仅定义了问题，还解决了它。

他刚刚想出了一个过于复杂的解决方案，以至于 Jarník 实际上将其去并行化，以便可以顺序执行。因此，这个算法一直未被注意，直到 Sollin 在并行计算人员注意到其需求时重新发明了它（实际上，是多次重新发明了它[several times, actually](http://en.wikipedia.org/wiki/Bor%C5%AFvka's_algorithm)）。但现在我们只需称之为 Borůvka 算法，这非常合适。

如你所猜测的，这个问题在其他教科书中确实被称为 MST，但“M”不是指摩拉维亚，而是指“最小”。但鉴于 Borůvka 在历史上的被遗忘地位，我们更喜欢更幽默的名字。

#### 17.5.5 检查组件连通性 "链接到此处")

正如我们所见，我们需要能够高效地判断两个节点是否属于同一组件。一种方法是进行深度优先遍历（或广度优先遍历），从第一个节点开始，检查我们是否访问过第二个节点。（使用这些遍历策略之一确保了在存在循环的情况下能够终止。）不幸的是，这需要线性时间（以图的大小为基准）来处理每一对节点——并且根据图和节点的选择，我们可能在每次添加边时对图中的每个节点都这样做！因此，我们显然希望做得更好。

将这个问题从图连通性降低到更一般的问题是有帮助的：即不相交集合结构（俗称为并查集，原因很快就会清楚）。如果我们把每个连通组件看作一个集合，那么我们就是在询问两个节点是否属于同一个集合。但将其作为集合成员问题，它也适用于其他几个应用。

设置如下。对于任意值，我们希望能够将它们视为集合中的元素。我们感兴趣的两个操作是显然的 `union`，它将两个集合合并为一个。另一个似乎是 `is-in-same-set`，它接受两个元素并确定它们是否在同一个集合中。然而，随着时间的推移，定义操作符 `find` 已经被证明是有用的，给定一个元素，“命名”该元素所属的集合（稍后会更详细地说明）。为了检查两个元素是否在同一个集合中，我们随后必须获取每个元素的“集合名称”，并检查这些名称是否相同。这确实听起来有些绕，但这意味着我们有一个可能在其他上下文中有用的原始操作，并且我们可以轻松地实现 `is-in-same-set`。

现在的问题是，我们如何命名集合？我们应该真正问的问题是，我们对这些名称关心哪些操作？我们唯一关心的是，给定两个名称，它们代表相同的集合当且仅当名称相同。因此，我们可以构造一个新的字符串、数字或其它东西，但我们还有一个选择：简单地选择集合中的一个元素来代表它，即作为它的名称。因此，我们将每个集合元素与其“集合名称”的指示符关联起来；如果没有，那么它的名称就是它自己（`parent` 的 `none` 情况）：

```py
data Element<T>:
  | elt(val :: T, parent :: Option<Element>)
end
```

我们将假设我们有一个等价谓词来检查两个元素是否相同，我们通过比较它们的值部分来实现，忽略它们的父值：

```py
fun is-same-element(e1, e2): e1.val <=> e2.val end
```

> 立即行动！
> 
> > 为什么我们只检查值部分？

我们将假设对于给定的集合，我们总是返回相同的代表元素。（否则，即使我们有相同的集合，等价性也会失败。）因此：我们使用名称 `fynd` 是因为 `find` 在 Pyret 中已经被定义为其他含义。如果你不喜欢这个拼写错误，你可以使用更长的名称，比如 `find-root`。

```py
fun is-in-same-set(e1 :: Element, e2 :: Element, s :: Sets)
    -> Boolean:
  s1 = fynd(e1, s)
  s2 = fynd(e2, s)
  identical(s1, s2)
end
```

其中 `Sets` 是所有元素的列表：

```py
type Sets = List<Element>
```

我们如何找到一个集合的代表元素？我们首先使用 `is-same-element` 来找到它；当我们找到它时，我们检查元素的 `parent` 字段。如果它是 `none`，这意味着这个元素本身命名了它的集合；这可能是因为元素是一个单元素集合（我们将所有元素初始化为 `none`），或者它是某个更大集合的名称。无论如何，我们已经完成了。否则，我们必须递归地找到父元素：

```py
fun fynd(e :: Element, s :: Sets) -> Element:
  cases (List) s:
    | empty => raise("fynd: shouldn't have gotten here")
    | link(f, r) =>
      if is-same-element(f, e):
        cases (Option) f.parent:
          | none => f
          | some(p) => fynd(p, s)
        end
      else:
        fynd(e, r)
      end
  end
end
```

> 练习
> 
> > 为什么在嵌套的 `cases` 中有递归调用？

剩下的就是实现 `union`。为此，我们需要找到我们想要合并的两个集合的代表元素；如果它们相同，那么这两个集合已经在一个联合中了；否则，我们必须更新数据结构：

```py
fun union(e1 :: Element, e2 :: Element, s :: Sets) -> Sets:
  s1 = fynd(e1, s)
  s2 = fynd(e2, s)
  if identical(s1, s2):
    s
  else:
    update-set-with(s, s1, s2)
  end
end
```

为了更新，我们任意选择一个集合名称作为新复合集合的名称。然后我们必须更新另一个集合名称元素的父元素为这个名称：

```py
fun update-set-with(s :: Sets, child :: Element, parent :: Element)
    -> Sets:
  cases (List) s:
    | empty => raise("update: shouldn't have gotten here")
    | link(f, r) =>
      if is-same-element(f, child):
        link(elt(f.val, some(parent)), r)
      else:
        link(f, update-set-with(r, child, parent))
      end
  end
end
```

这里有一些测试来展示这个功能：

```py
check:
  s0 = map(elt(_, none), [list: 0, 1, 2, 3, 4, 5, 6, 7])
  s1 = union(get(s0, 0), get(s0, 2), s0)
  s2 = union(get(s1, 0), get(s1, 3), s1)
  s3 = union(get(s2, 3), get(s2, 5), s2)
  print(s3)
  is-same-element(fynd(get(s0, 0), s3), fynd(get(s0, 5), s3)) is true
  is-same-element(fynd(get(s0, 2), s3), fynd(get(s0, 5), s3)) is true
  is-same-element(fynd(get(s0, 3), s3), fynd(get(s0, 5), s3)) is true
  is-same-element(fynd(get(s0, 5), s3), fynd(get(s0, 5), s3)) is true
  is-same-element(fynd(get(s0, 7), s3), fynd(get(s0, 7), s3)) is true
end
```

不幸的是，这个实现有两个主要问题：

+   首先，因为我们正在进行函数式更新，`parent` 引用的值会“不断变化”，但这些变化对“相同”值的旧副本是不可见的。在并集的不同阶段，一个元素有不同的父引用，尽管从理论上讲，它始终是相同的元素。这是函数式编程受挫的地方。

+   相关地，这个实现的性能相当糟糕。`fynd` 递归遍历父节点以找到集合的名称，但遍历的元素并未更新以记录这个新名称。我们当然可以通过每次重新构建集合来更新它们，但这会使实现变得复杂，而且正如我们很快就会看到的，我们可以做得更好。

更糟糕的是，它甚至可能不正确！

> 练习
> 
> > 是吗？考虑构建不那么倾斜的 `union`s，看看你是否能得到你预期的结果。

事实上，纯函数式编程并不适合这个问题。我们需要一个更好的实现策略：并查集。
