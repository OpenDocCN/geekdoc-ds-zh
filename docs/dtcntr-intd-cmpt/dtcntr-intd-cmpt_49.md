# 16.2 DAG 的大小🔗

> 原文：[`dcic-world.org/2025-08-27/size-of-dag.html`](https://dcic-world.org/2025-08-27/size-of-dag.html)

| |   16.2.1 阶段 1 |
| --- | --- |
| |   16.2.2 阶段 2 |
| |   16.2.3 阶段 3 |
| |   16.2.4 阶段 4 |
| |   16.2.5 阶段 5 |
| |   16.2.6 我们学到了什么 |
| |   16.2.7 更多关于值打印：来自 Racket 的旁白 |

让我们从定义一个计算树大小的函数开始：

```py
data BT:
  | mt
  | nd(v :: Number, l :: BT, r :: BT)
end

fun size-1(b :: BT) -> Number:
  cases (BT) b:
    | mt => 0
    | nd(v, l, r) => 1 + size-1(l) + size-1(r)
  end
end
```

这很简单。

但假设我们的输入实际上不是一个树，而是一个 DAG。例如：

```py
#|
     4
    / \
   2   3
    \ /
     1
|#

n1 = nd(1, mt, mt)
n2 = nd(2, mt, n1)
n3 = nd(3, n1, mt)
n4 = nd(4, n2, n3)
```

其中 `n4` 是 DAG。这里有两种大小概念。一种类似于“打印大小”：打印时将占用多少空间。当前的大小函数很好地计算了这一点。但另一种是“分配”大小：我们分配了多少个节点。我们的表现如何？

#### 16.2.1 阶段 1🔗 "链接到这里")

```py
check:
  size-1(n1) is 1
  size-1(n2) is 2
  size-1(n3) is 2
  size-1(n4) is 4
end
```

显然，答案应该是 `4`：我们只需读取有多少 `nd` 调用即可。显然，函数是错误的。

当然，问题是 DAG 涉及重复的节点，而我们并没有做任何跟踪重复的事情。因此，我们需要一个更强的契约：我们将问题分为两部分，一个标准接口函数，它只接受 DAG 并返回一个数字，以及一个更丰富的辅助函数，它还接受已看到的节点的记忆。

#### 16.2.2 阶段 2🔗 "链接到这里")

```py
fun size-2-h(b :: BT, seen :: List<BT>) -> Number:
  if member-identical(seen, b):
    0
  else:
    cases (BT) b:
      | mt => 0
      | nd(v, l, r) =>
        new-seen = link(b, seen)
        1 + size-2-h(l, new-seen) + size-2-h(r, new-seen)
    end
  end
end
```

> 练习
> 
> > 为什么这段代码使用 `member-identical` 而不是 `member`？
> > 
> > 注意，如果我们在这个章节中将每个 `member-identical` 替换为 `member`，代码仍然表现相同。为什么？
> > 
> > 进行更改以展示对 `member-identical` 的需求。

返回 `0` 是否奇怪？如果我们重新解释函数的作用，就不会奇怪了：它不是计算大小，而是计算它所给的 `BT` 相对于已经看到的额外贡献的大小（相对于已经看到的）。已经在 `seen` 中的节点不会产生边际贡献；它之前已经被计算过了。

最后，我们不应该将此类函数导出给用户，用户必须处理一个难以驾驭的额外参数，并且可能会发送一些格式不佳的内容，从而导致我们的函数崩溃。相反，我们应该为其编写一个包装器：

```py
fun size-2(b :: BT): size-2-h(b, empty) end
```

这也使我们能够使用我们的旧测试（已重命名）：

```py
check:
  size-2(n1) is 1
  size-2(n2) is 2
  size-2(n3) is 2
  size-2(n4) is 4
end
```

不幸的是，这仍然不起作用！

> 现在做什么？
> 
> > 在 `size-2-h` 中使用 Pyret 的 `spy` 构造来找出原因。

#### 16.2.3 阶段 3🔗 "链接到这里")

你记得使用 `spy` 吗？否则你可能会完全错过问题！确保使用 `spy`（现在可以自由省略前几个测试）来了解问题。

正如你可能已经注意到的，问题是我们希望“已见”包含所有曾经见过的节点。然而，每次我们从子计算返回时，我们也会失去对其工作期间所看到的任何内容的跟踪。相反，我们必须返回所看到的一切，以便正确地保留我们正在计算每个节点的边际贡献的想法。

我们可以使用以下数据结构来完成这项工作：

```py
data Ret: ret(sz :: Number, sn :: List<BT>) end
```

这是由辅助函数返回的：

```py
fun size-3-h(b :: BT, seen :: List<BT>) -> Ret:
  if member-identical(seen, b):
    ret(0, seen)
  else:
    cases (BT) b:
      | mt => ret(0, seen)
      | nd(v, l, r) =>
        new-seen = link(b, seen)
        rl = size-3-h(l, new-seen)
        rr = size-3-h(r, rl.sn)
        ret(1 + rl.sz + rr.sz, rr.sn)
    end
  end
end
```

注意，关键的是，右侧分支的`seen`参数是`rl.sn`：即左侧分支中已经看到的全部内容。这是避免错误的关键步骤。

由于这种更丰富的返回类型，我们必须提取实际答案以进行测试：

```py
fun size-3(b :: BT): size-3-h(b, empty).sz end

check:
  size-3(n1) is 1
  size-3(n2) is 2
  size-3(n3) is 2
  size-3(n4) is 4
end
```

> 练习
> 
> > “已见”必须是列表吗？它还可以是什么？

#### 16.2.4 第 4 阶段🔗 "链接至此")

注意到`Ret`数据结构只具有局部兴趣。它纯粹是`size-3-h`函数内部的；即使是`size-3`也忽略了其中一半，它将永远不会被程序的其他部分看到。这就是我们之前看到的好用元组的方式：使用元组！

```py
fun size-4-h(b :: BT, seen :: List<BT>) -> {Number; List<BT>}:
  if member-identical(seen, b):
    {0; seen}
  else:
    cases (BT) b:
      | mt => {0; seen}
      | nd(v, l, r) =>
        new-seen = link(b, seen)
        {lsz; lsn} = size-4-h(l, new-seen)
        {rsz; rsn} = size-4-h(r, lsn)
        {1 + lsz + rsz; rsn}
    end
  end
end

fun size-4(b :: BT): size-4-h(b, empty).{0} end

check:
  size-4(n1) is 1
  size-4(n2) is 2
  size-4(n3) is 2
  size-4(n4) is 4
end
```

符号 `{0; seen}` 实际上创建了一个元组；`{Number; List<BT>}` 声明了元组的契约。此外，`.{0}` 提取元组的第 0 个元素（最左边的元素）。

#### 16.2.5 第 5 阶段🔗 "链接至此")

注意，我们有代码的两个实例 `{0; seen}`。它们必须是这样吗？如果我们在这两个地方都返回 `{0; empty}` 会怎样？会发生什么？

我们可能预计它会在`member-identical`返回`true`的情况下崩溃，但在`mt`情况下可能不会。

> 立刻行动！
> 
> > 进行这些更改。结果是否符合你的预期？

奇怪的是，不是！在`mt`情况下进行更改会产生影响，但在`member-identical`情况下进行更改则没有！这几乎似乎与直觉相反。我们如何诊断这个问题？

> 立刻行动！
> 
> > 使用 `spy` 来确定发生了什么！

好吧，所以当我们重新访问一个节点时返回“空”似乎并没有造成任何伤害。这意味着我们可以做出这样的改变吗？

注意到实际上并没有什么依赖于那个“已见列表”为“空”。这就是为什么它看起来并不重要。我们如何让它变得重要？通过让它“伤害”计算，再次访问一个之前见过但现在已被遗忘的节点。因此，我们需要至少访问一个节点三次：第一次是为了记住它；第二次是为了忘记它；第三次是为了错误地再次访问它。下面是一个能够做到这一点的有向无环图（DAG）：

```py
#|
    10
    / \
   11 12
  / \ /
 13<--
|#

n13 = nd(13, mt, mt)
n11 = nd(11, n13, n13)
n12 = nd(12, n13, mt)
n10 = nd(10, n11, n12)

check:
  size-4(n10) is 4
end
```

确实如此，如果任一元组现在返回“空”，则此测试失败。否则，它将成功。

#### 16.2.6 我们学到了什么🔗 "链接至此")

我们在这里学到了三个重要的原则：

+   处理需要“内存”的程序的模式。这被称为线程（不是“多线程”的意思，多线程是一种并行计算，而是指看到的列表如何通过程序传递的模式）。

+   元组使用的一个好例子：在本地，数据类型的文档优势不是必要的（而且额外的数据类型可能只是使程序变得杂乱），与远程相对，在远程情况下，这是必要的。一般来说，总是可以创建一个新的数据类型；只有在某些情况下，才可以使用元组来代替。

+   一个重要的软件工程原则，称为变异测试。这个名字听起来像是测试程序的技术，实际上，它是一种测试测试套件的技术。你有一个经过测试的程序；然后“变异”你程序中你认为必须改变输出的部分，并查看是否有测试失败。如果没有测试失败，那么要么你误解了你的程序，要么更可能的是，你的测试套件不够好。改进你的测试套件以捕获你程序中的错误，或者说服自己这个变化并不重要。

    有一些变异测试工具会随机尝试使用“变异”策略来改变你的程序——例如，将一个`+`替换为`-`——然后重新运行你的测试套件，并报告测试套件实际捕获了多少潜在变异。但我们不能，也不应该只依赖工具；我们还可以手动应用变异测试的原则，就像我们上面所做的那样。至少，这将帮助我们更好地理解我们的程序！

#### 16.2.7 更多关于值打印的内容：来自 Racket 的一个旁白🔗 "链接到此处")

之前，我们讨论了标准递归大小仍然可以被视为“打印值的大小”计算。然而，这实际上取决于你的语言的值打印器。

在 Racket 中，你可以打开（它稍微贵一点，所以默认是关闭的）一个值打印器，它显示值共享：语言 | 选择语言 … | 显示详细信息 | 显示值中的共享。所以如果我们把上面的数据定义转换成 Racket 结构

| (struct mt () #:transparent) |
| --- |
| (struct nd (v l r) #:transparent) |

然后构建（几乎）与第一个例子相同的数据：

| (define n1 (nd 1 (mt) (mt))) |
| --- |
| (define n2 (nd 2 (mt) n1)) |
| (define n3 (nd 3 n1 (mt))) |
| (define n4 (nd 4 n2 n3)) |

然后要求 Racket 打印它，我们得到：

| > n4 |
| --- |
| (nd 4 (nd 2 (mt) #0=(nd 1 (mt) (mt))) (nd 3 #0# (mt))) |

#0=的表示法相当于说，“我稍后会再次引用这个值，所以让我们称它为第 0 个值”，而#0#则是说“这里我正在引用前面提到的第 0 个值”。

(是的，输出中可以有多个共享值，所以每个值都有一个不同的“名称”。我们稍后会看到这一点。)

上面的例子可以翻译为

| (define n13 (nd 13 (mt) (mt))) |
| --- |
| (define n11 (nd 11 n13 n13)) |
| (define n12 (nd 12 n13 (mt))) |
| (define n10 (nd 10 n11 n12)) |

它打印为

| > n10 |
| --- |
| (nd 10 (nd 11 #0=(nd 13 (mt) (mt)) #0#) (nd 12 #0# (mt))) |

因此，一种语言可以在其输出中反映共享。只是大多数编程语言选择不这样做，即使作为可选功能。

记住上面的“几乎”？那是关于什么的？

在 Racket 中，我们一次又一次地创建了 mt 的新实例。我们可以更准确地反映 Pyret 中发生的事情，通过只实例化一次：

| (struct mt () #:transparent) |
| --- |
| (define the-mt (mt)) |
| (struct nd (v l r) #:transparent) |

然后我们重写之前的示例，只使用那个实例：

| (define n1 (nd 1 the-mt the-mt)) |
| --- |
| (define n2 (nd 2 the-mt n1)) |
| (define n3 (nd 3 n1 the-mt)) |
| (define n4 (nd 4 n2 n3)) |

现在我们打印它：

| > n4 |
| --- |
| (nd 4 (nd 2 #0=(mt) #1=(nd 1 #0# #0#)) (nd 3 #1# #0#)) |

现在你可以看到有两个不同的共享值，一个是 mt 的单例，另一个是包含 1 的 nd。因此，Racket 使用#0= / #0#和#1= / #1#。注意所有叶子都在共享相同的 mt 实例。（编号是在遍历节点时遇到的顺序中选择的，这就是为什么 nd 实例上次是#0，这次是#1。）

#### 16.2.1 阶段 1🔗 "链接至此")

```py
check:
  size-1(n1) is 1
  size-1(n2) is 2
  size-1(n3) is 2
  size-1(n4) is 4
end
```

显然答案应该是`4`：我们只需读取有多少次`nd`调用。显然函数是错误的。

当然，问题是 DAG 涉及重复的节点，而我们没有做任何跟踪重复的事情。因此，我们需要一个更强的合约：我们将问题分为两部分，一个标准接口函数，它只接受 DAG 并返回一个数字，以及一个更丰富的辅助函数，它还接受已看到的节点的记忆。

#### 16.2.2 阶段 2🔗 "链接至此")

```py
fun size-2-h(b :: BT, seen :: List<BT>) -> Number:
  if member-identical(seen, b):
    0
  else:
    cases (BT) b:
      | mt => 0
      | nd(v, l, r) =>
        new-seen = link(b, seen)
        1 + size-2-h(l, new-seen) + size-2-h(r, new-seen)
    end
  end
end
```

> 练习
> 
> > 为什么这段代码使用`member-identical`而不是`member`？
> > 
> > 观察到，如果我们在这个章节中将每个`member-identical`替换为`member`，代码仍然表现相同。为什么？
> > 
> > 进行更改以证明`member-identical`的必要性。

返回`0`是否奇怪？如果不是，如果我们重新解释函数的作用：它不计算大小，它计算`BT`给定的额外贡献的大小（相对于已经看到的）。已经存在于`seen`中的节点不会产生边际贡献；它之前已经被计算过。

最后，我们不应该将此类函数导出给用户，用户必须处理一个难以驾驭的额外参数，并且可能会发送格式不佳的内容，从而导致我们的函数崩溃。相反，我们应该为其编写一个包装器：

```py
fun size-2(b :: BT): size-2-h(b, empty) end
```

这也使我们能够使用我们的旧测试（已重命名）：

```py
check:
  size-2(n1) is 1
  size-2(n2) is 2
  size-2(n3) is 2
  size-2(n4) is 4
end
```

不幸的是，这仍然不起作用！

> 现在行动！
> 
> > 在`size-2-h`中使用 Pyret 的`spy`构造来找出原因。

#### 16.2.3 阶段 3🔗 "链接至此")

你记得使用`spy`吗？否则你可能会完全错过问题！确保使用`spy`（现在可以自由省略前几个测试）来了解问题。

如您所注意到的，问题在于我们希望`seen`包含所有曾经见过的节点。然而，每次我们从子计算返回时，我们也会失去对其工作期间所看到的任何内容的跟踪。相反，我们必须返回所有看到的内容，以便正确地保留我们正在计算每个节点的边际贡献的想法。

我们可以用以下数据结构来做这件事：

```py
data Ret: ret(sz :: Number, sn :: List<BT>) end
```

这是由辅助函数返回的：

```py
fun size-3-h(b :: BT, seen :: List<BT>) -> Ret:
  if member-identical(seen, b):
    ret(0, seen)
  else:
    cases (BT) b:
      | mt => ret(0, seen)
      | nd(v, l, r) =>
        new-seen = link(b, seen)
        rl = size-3-h(l, new-seen)
        rr = size-3-h(r, rl.sn)
        ret(1 + rl.sz + rr.sz, rr.sn)
    end
  end
end
```

注意，关键的是，右分支的`seen`参数是`rl.sn`：即左分支中已经看到的全部内容。这是避免错误的关键步骤。

由于这个更丰富的返回类型，我们必须提取实际的答案来用于测试：

```py
fun size-3(b :: BT): size-3-h(b, empty).sz end

check:
  size-3(n1) is 1
  size-3(n2) is 2
  size-3(n3) is 2
  size-3(n4) is 4
end
```

> 练习
> 
> > `seen`必须是列表吗？它还可以是什么？

#### 16.2.4 第四阶段🔗 "链接到这里")

注意，`Ret`数据结构只具有局部兴趣。它完全是`size-3-h`函数内部的；甚至`size-3`也忽略了另一半，它永远不会被程序的其他部分看到。这就是我们之前看到的好用元组的方式：使用元组!

```py
fun size-4-h(b :: BT, seen :: List<BT>) -> {Number; List<BT>}:
  if member-identical(seen, b):
    {0; seen}
  else:
    cases (BT) b:
      | mt => {0; seen}
      | nd(v, l, r) =>
        new-seen = link(b, seen)
        {lsz; lsn} = size-4-h(l, new-seen)
        {rsz; rsn} = size-4-h(r, lsn)
        {1 + lsz + rsz; rsn}
    end
  end
end

fun size-4(b :: BT): size-4-h(b, empty).{0} end

check:
  size-4(n1) is 1
  size-4(n2) is 2
  size-4(n3) is 2
  size-4(n4) is 4
end
```

符号`{0; seen}`创建一个实际的元组；`{Number; List<BT>}`声明了元组的契约。此外，`.{0}`从元组中提取`0`th 元素（最左边的元素）。

#### 16.2.5 第五阶段🔗 "链接到这里")

注意，我们有代码的两个实例`{0; seen}`。它们必须是这样吗？如果我们在这两个地方都返回`{0; empty}`会怎样？有什么会出错吗？

我们可能预计在`member-identical`返回`true`的情况下会出错，但在`mt`情况下可能不会。

> 现在行动！
> 
> > 对这些更改进行操作。结果是否符合你的预期？

奇怪的是，不！在`mt`情况下做出改变会有影响，但在`member-identical`情况下做出改变却没有！这几乎让人感觉反直觉。我们如何诊断这个问题？

> 现在行动！
> 
> > 使用`spy`来确定发生了什么！

好吧，所以当我们重新访问一个节点时返回`empty`似乎并没有造成任何伤害。这意味着我们可以做出这样的改变吗？

注意，实际上没有什么依赖于那个`seen`列表是`empty`的。这就是为什么它看起来并不重要。我们如何让它变得重要？通过通过再次访问一个之前看到但现在已被遗忘的节点来“伤害”计算。所以我们需要至少访问一个节点三次：第一次是为了记住它；第二次是为了忘记它；第三次是为了错误地再次访问它。以下是一个会这样做有向图：

```py
#|
    10
    / \
   11 12
  / \ /
 13<--
|#

n13 = nd(13, mt, mt)
n11 = nd(11, n13, n13)
n12 = nd(12, n13, mt)
n10 = nd(10, n11, n12)

check:
  size-4(n10) is 4
end
```

当然，如果任一元组现在返回`empty`，这个测试就会失败。否则，它就会成功。

#### 16.2.6 我们学到了什么🔗 "链接到这里")

我们在这里学到了三个重要的原则：

+   处理需要“内存”的程序的模式。这被称为线程（不是“多线程”的意思，多线程是一种并行计算，而是指如何将看到的列表通过程序传递的模式）。

+   元组使用的一个好例子：在本地，数据类型的文档优势不是必要的（而且额外的数据类型可能只是使程序变得杂乱），与远程相对，那里是必要的。一般来说，总是可以创建一个新的数据类型；只有在某些情况下，才可以使用元组来代替。

+   一个重要的软件工程原则，称为变异测试。这个名字听起来像是测试程序的技术，实际上，它是一种测试测试套件的技术。你有一个经过测试的程序；然后“变异”你程序中你认为必须改变输出的部分，看看是否有测试失败。如果没有测试失败，那么要么是你没有理解你的程序，要么更可能是你的测试套件不够好。改进你的测试套件以捕获你程序中的错误，或者说服自己这个变化并不重要。

    有一些变异测试工具会随机尝试使用“变异”策略来改变你的程序——例如，将一个`+`替换为`-`——然后重新运行你的测试套件，并报告测试套件实际捕获了多少潜在变异。但我们不能，也不应该只依赖工具；我们还可以手动应用变异测试的原则，就像我们上面所做的那样。至少，这将帮助我们更好地理解我们的程序！

#### 16.2.7 更多关于值打印：来自 Racket 的旁白🔗 "链接到此处")

之前，我们讨论了标准递归大小仍然可以被视为“打印值的大小”计算。然而，这实际上取决于你的语言的值打印器。

在 Racket 中，你可以打开（它稍微贵一点，所以默认是关闭的）一个值打印器，显示值共享：语言 | 选择语言 … | 显示详细信息 | 显示值中的共享。所以如果我们把上面的数据定义翻译成 Racket 结构

| (struct mt () #:transparent) |
| --- |
| (struct nd (v l r) #:transparent) |

然后构建（几乎）与第一个示例相同的数据：

| (define n1 (nd 1 (mt) (mt))) |
| --- |
| (define n2 (nd 2 (mt) n1)) |
| (define n3 (nd 3 n1 (mt))) |
| (define n4 (nd 4 n2 n3)) |

然后要求 Racket 打印它，我们得到：

| > n4 |
| --- |
| (nd 4 (nd 2 (mt) #0=(nd 1 (mt) (mt))) (nd 3 #0# (mt))) |

#0=记号是“我稍后会再次引用这个值，所以让我们称它为 0th 值”的道德等价物，而#0#则是说“这里我正在引用前面提到的 0th 值”。

（是的，输出中可以有一个以上的共享值，所以每个值都会被赋予一个不同的“名称”。我们稍后会看到。）

上面的后续示例翻译为

| (define n13 (nd 13 (mt) (mt))) |
| --- |
| (define n11 (nd 11 n13 n13)) |
| (define n12 (nd 12 n13 (mt))) |
| (define n10 (nd 10 n11 n12)) |

which prints as

| > n10 |
| --- |
| (nd 10 (nd 11 #0=(nd 13 (mt) (mt)) #0#) (nd 12 #0# (mt))) |

因此，一种语言可以在其输出中反映共享。只是大多数编程语言选择不这样做，即使是有选项的。

记得上面提到的“几乎”吗？那是关于什么的？

在 Racket 中，我们反复创建了 mt 的新实例。我们可以通过只实例化一次更准确地反映 Pyret 中发生的情况：

| (struct mt () #:transparent) |
| --- |
| (define the-mt (mt)) |
| (struct nd (v l r) #:transparent) |

我们然后将之前的例子重写为只使用那个实例：

| (define n1 (nd 1 the-mt the-mt)) |
| --- |
| (define n2 (nd 2 the-mt n1)) |
| (define n3 (nd 3 n1 the-mt)) |
| (define n4 (nd 4 n2 n3)) |

现在我们打印它时：

| > n4 |
| --- |
| (nd 4 (nd 2 #0=(mt) #1=(nd 1 #0# #0#)) (nd 3 #1# #0#)) |

现在你可以看到有两个不同的共享值，一个是 mt 的单个实例，另一个是包含 1 的 nd。因此，Racket 使用了 #0= / #0# 和 #1= / #1#。注意所有叶子节点是如何共享相同的 mt 实例的。（编号是在遍历节点时按顺序选取的，这就是为什么 nd 实例上次是 #0，这次是 #1。）
