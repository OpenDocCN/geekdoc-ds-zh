# 23 部分域

> 原文：[`dcic-world.org/2025-08-27/partial-domains.html`](https://dcic-world.org/2025-08-27/partial-domains.html)

| |   23.1 一个非解决方案 |
| --- | --- |
| |   23.2 异常 |
| |   23.3 选项类型 |
| |   23.4 动态总域 |
| |   23.5 静态总域 |
| |   23.6 总结 |
| |   23.7 关于符号的说明 |

有时候，我们无法精确地用我们想要的精度来捕捉函数的域。在数学中，如果一个函数不能接受其域中的所有值，它被称为部分函数。这是我们可能在编程中遇到比我们想象的更频繁的问题，所以我们需要知道如何处理它。实际上，我们可以使用几种编程策略，它们有不同的优点和缺点。在这里，我们将检查其中的一些。

考虑一些数字列表上的函数，例如计算中位数或平均值。在这两种情况下，这些函数并不适用于所有数字列表：空列表没有中位数，我们也不能计算它的平均值，因为没有元素（所以尝试计算平均值会导致除以零错误）。因此，虽然将

```py
average :: List<Number> -> Number
```

这只是：有点虚构。函数仅在非空列表上定义。

我们现在将从一个软件工程的角度来看如何处理这个问题。我们将特别通过`average`函数来进行，因为这个函数足够简单，我们可以专注于软件结构，而不会迷失在解决方案的细节中。至少有四种解决方案和一个非解决方案。

### 23.1 一个非解决方案 "链接到此处")

我们将从一个过去程序员经常使用的策略开始，但我们将其拒绝为一个非解决方案。这个策略是通过在错误情况下返回一个值来使上述合同绝对正确；这个值通常被称为哨兵。例如，哨兵可能是`0`。以下是完整的程序：

```py
type LoN = List<Number>

fun sum(l :: LoN) -> Number:
  fold({(a, b): a + b}, 0, l)
end

avg0 :: LoN -> Number

fun avg0(l):
  cases (List) l:
    | empty => 0
    | link(_, _) =>
      s = sum(l)
      c = l.length()
      s / c
  end
end
```

这里有一些测试：

```py
check:
  avg0([list: 1]) is 1
  avg0([list: 1, 2, 3]) is 2
  avg0([list: 1, 2, 3, 10]) is 4
end
```

这里是否遗漏了某个测试？是的，对于空列表！我们应该添加它吗？

```py
check:
  avg0(empty) is 0
end
```

问题是，我们应该对这个“解决方案”感到满意吗？它有两个问题。

首先，每次使用`avg0`都需要检查它是否返回了`0`。如果没有，那么答案是合法的，它可以继续进行计算。但如果它确实返回了`0`，那么它必须假设输入可能是不合法的，并且不能使用该答案。

第二，即使这样也不完全正确。为了理解为什么，我们需要编写一些更多的测试：

```py
check:
  avg0([list: -1, 0, 1]) is 0
  avg0([list: -5, 4, 1]) is 0
end
```

所以问题是，当`avg0`返回`0`时，我们不知道这是否是一个合法的答案或代表“这不是有效输入”的“虚假”答案。所以即使是我们的“检查一切”策略也失败了！

啊，但也许问题是使用了`0`！也许我们可以使用一个不同的数字，它会起作用。比如`1`？或者`-1`？问题是：有没有任何数字合理地不能是实际输入的平均值？（并且对于所有问题，你能确定这一点吗？）当然不是。

这就是为什么这不是一个解决方案。它已经造成了一些问题：

+   我们无法从输出中判断输入是否无效。

+   这意味着每个调用者都需要进行检查。

+   一个忘记检查的调用者可能会用胡言乱语进行计算。

+   组合性被破坏：任何传递给`average`的函数都需要知道检查输出（而且在契约中没有任何警告！）。

事实上，数十年的经验告诉我们，世界上一些最复杂的程序员甚至在没有最关键的时候也无法处理这个问题，导致了许多有害的安全问题。因此，我们现在应该将这种方法视为软件构建中的一个缺陷，并且永远不要自己这样做。

让我们来看看四种实际的解决方案。

### 23.2 异常 "链接到此处")

许多语言，包括 Pyret，提供的一种技术被称为异常。异常是一种特殊的编程结构，它有效地停止了计算，因为程序无法确定如何使用它拥有的数据继续计算。一些语言中有更复杂的异常形式，但在这里我们只关注将它们用作处理部分性的策略。

这里是使用异常编写的平均程序（我们重用了之前的`sum`）：

```py
avg1 :: LoN -> Number

fun avg1(l):
  cases (List) l:
    | empty => raise("no average for empty list")
    | link(_, _) =>
      s = sum(l)
      c = l.length()
      s / c
  end
end

check:
  avg1([list: 1]) is 1
  avg1([list: 1, 2, 3]) is 2
  avg1([list: 1, 2, 3, 10]) is 4
end
```

`raise`工作的方式是终止所有等待发生的事情。例如，如果我们写

```py
1 + avg1(empty)
```

`1 + …`部分永远不会发生：整个计算结束。`raise`创建异常。

同样，我们缺少一个测试。我们如何编写它？

```py
check:
  avg1(empty) raises "no average for empty list"
end
```

`raises`形式接受一个字符串，该字符串与提供的`raise`进行匹配。实际上，为了方便，允许任何原始字符串的子串：例如，我们也可以写`check: avg1(empty) raises "no average" avg1(empty) raises "empty list" end`

在许多编程语言中，使用异常是处理部分性的标准方式。这当然是一个实用的解决方案。观察一下，我们得到了之前重用的`sum`；契约看起来很干净；我们只需要在不知道该做什么的地方使用`raise`。有什么不喜欢的呢？

异常有两个主要问题：

1.  在真实系统中，异常以不可预测的方式停止程序执行。`avg1`的调用者可能正在进行其他事情的一半（例如，它可能已经打开了一个打算关闭的文件），但异常导致调用没有干净地完成，导致剩余的计算没有运行，使系统处于混乱状态。

1.  相关地，我们提出作为一个特性，实际上应该被视为一个问题：契约不成立！契约中根本没有任何迹象表明可能会发生异常。程序员必须阅读整个实现——<wbr>这可能会随时发生变化——<wbr>而不是能够依赖其发布的契约，契约的全部意义在于它们让我们免于阅读整个实现！

事实上，一些为大规模编程设计的现代编程语言（如 Go 和 Rust）不再有异常构造。因此，你不应该假设这将继续是未来的“标准”做法。

注意，可能发生两种异常。一种是我们上面写过的。另一种是我们完全忽略（或忘记考虑）空列表的情况，最终从 Pyret 获得错误，这也是一种异常。如果 Pyret 无论如何都会抛出异常，我们费尽周折自己来做这件事有意义吗？

确实如此！有以下几个原因：

1.  首先，你可以控制异常发生的位置和它所表达的内容。

1.  你可以记录下异常将会发生。

1.  你对 Pyret 或任何底层编程语言的行为的依赖性较低，这些语言可能会以微妙的方式发生变化。

1.  你可以创建一个仅属于你自己的异常，这样它就不会与其他可能潜伏在程序中的除以零错误混淆。

由于这些原因，显式检查和抛出异常比让它“跌入”编程语言更好。相反，这个解决方案的真正问题更为微妙：契约的不诚实，以及对程序执行的影响。

### 23.3 选项类型 "链接到此处")

让我们重新审视 `avg0`。它的问题在于它返回了一个无法与实际答案区分的值。因此，也许另一种方法就是返回一个保证可以区分的值！为此，越来越多的语言（包括 Pyret）都有类似这样的类型：

```py
data Option<T>:
  | none
  | some(value :: T)
end
```

这是一个我们在不确定是否有答案时使用的类型：`none` 表示我们没有答案，而 `some` 表示我们有答案，`value` 就是那个答案。

现在看看我们的程序现在看起来是什么样子：

```py
avg2 :: LoN -> Option<Number>

fun avg2(l):
  cases (List) l:
    | empty => none
    | link(_, _) =>
      s = sum(l)
      c = l.length()
      some(s / c)
  end
end
```

现在测试看起来有些不同：

```py
check:
  avg2([list: 1]) is some(1)
  avg2([list: 1, 2, 3]) is some(2)
  avg2([list: 1, 2, 3, 10]) is some(4)
end

check:
  avg2(empty) is none
end
```

好消息是，契约现在是真的了。只需看一下它，我们就被提醒 `avg0` 可能并不总是能够计算出答案。

不幸的是，这给每个用户都带来了一些成本：他们必须使用 `cases` 来检查返回值，并且只有在它们是合法的情况下才使用它们。然而，这与我们预期的 `avg0` 是同一件事——<wbr>除了我们没有确保不滥用该值的纪律！所以这是以原则方式完成的 `avg0`。

### 23.4 总域，动态 "链接到此处")

所有这些问题都源于我们说 `average`（就像 `median`）是部分的。然而，只有当我们把域作为 `List<Number>` 时，它才是部分的；实际上，它是在数字的非空列表上的一个全函数。但我们如何表示它呢？

在一些语言中，比如 Pyret，我们实际上可以直接表达这一点：

```py
type NeLoND = List<Number>%(is-link)
```

这意味着我们正在细化数值列表，使其始终有一个 `link`，即非空。在 Pyret 中，目前这个检查仅在运行时进行；在其他一些编程语言中，这可以通过类型检查器本身来完成。

这种细化让我们可以假装我们在处理常规列表，并重用所有现有的列表代码，同时确信我们永远不会得到除以零的错误：

```py
avg3 :: NeLoND -> Number

fun avg3(l):
  s = sum(l)
  c = l.length()
  s / c
end

check:
  avg3([list: 1]) is 1
  avg3([list: 1, 2, 3]) is 2
  avg3([list: 1, 2, 3, 10]) is 4
end
```

如果我们尝试传递一个空列表，我们会得到一个内部异常：

```py
check:
  avg3(empty) raises ""
end
```

这是一个相当有趣的解决方案。我们的函数代码很简洁。我们不处理无意义的值。接口是真实的！（然而，它确实需要仔细阅读才能观察到域下面隐藏着一个异常。）而且它让我们能够重用现有代码。

有两个主要弱点：

1.  动态细化在大多数语言中并不常见，因此我们需要做更多手动工作来获得相同的解决方案。

1.  我们无法得到一个静态保证（即在程序运行之前），即我们永远不会得到一个异常。

### 23.5 总域，静态 "链接到此处")

我们如何使函数具有静态保证的全函数？这需要我们确保我们永远无法构造一个空列表！显然，在 Pyret 中现有的列表中这是不可能的。然而，我们可以构造一个新的类似列表的数据类型，它“底部”不是空列表，而是单元素列表：

```py
data NeLoN:
  | one(n :: Number)
  | more(n :: Number, r :: NeLoN)
end
```

观察到我们根本无法创建一个空列表：最小的列表中有一个元素。此外，我们的类型检查器会为我们强制执行这一点。

当然，这与数字列表完全不同的一种数据类型。例如，我们不能使用现有的 `sum` 或 `length` 代码。然而，一个选项是将 `NeLoN` 转换为 `LoN`，这总是安全的，并重用那段代码：

```py
fun nelon-to-lon(nl :: NeLoN):
  cases (NeLoN) nl:
    | one(n) => [list: n]
    | more(n, r) => link(n, nelon-to-lon(r))
  end
end

fun nl-sum(nl :: NeLoN) -> Number:
  sum(nelon-to-lon(nl))
end

fun nl-len(nl :: NeLoN) -> Number:
  nelon-to-lon(nl).length()
end
```

现在，我们可以以有趣的方式编写平均值：

```py
fun avg4(nl :: NeLoN) -> Number:
  s = nl-sum(nl)
  c = nl-len(nl)
  s / c
end
```

再次强调，我们不需要任何处理错误的逻辑。然而，这并不是因为我们粗心大意，或者让 Pyret 处理它，或者运行时进行检查，或者其他任何事情：这是因为空列表根本不可能出现。因此，我们既有最简单的主体，又有最真实的接口！但这也带来了代价：我们需要做一些工作来重用现有函数。

这个问题也扩展到编写测试，现在变得更加痛苦：

```py
check:
  nl1 = one(1)
  nl2 = more(1, more(2, one(3)))
  nl3 = more(1, more(2, more(3, one(10))))

  avg4(nl1) is 1
  avg4(nl2) is 2
  avg4(nl3) is 4
end
```

也就是说，我们失去了方便的编写列表的方式。我们可以通过编写一个创建 `NeLoN`s 的辅助函数来恢复它：

```py
fun lon-to-nelon(l :: LoN) -> NeLoN:
  cases (List) l:
    | empty => raise("can't make an empty NeLoN")
    | link(f, r) =>
      cases (List) r:
        | empty => one(f)
        | else => more(f, lon-to-nelon(r))
      end
  end
end

check:
  avg4(lon-to-nelon([list: 1])) is 1
  avg4(lon-to-nelon([list: 1, 2, 3])) is 2
  avg4(lon-to-nelon([list: 1, 2, 3, 10])) is 4
end
```

注意，如果我们尝试使用空列表，我们会得到一个异常：

```py
check:
  avg4(lon-to-nelon(empty)) raises ""
end
```

然而，了解错误来源非常重要：异常不是来自`avg4`，而是来自`lon-to-nelon`，即“接口”函数。坏数据永远不会到达`avg4`！我们可以验证这一点：

```py
check:
  lon-to-nelon(empty) raises ""
end
```

记住，无法将空列表发送到`avg4`！尽管如此，这表明了一个权衡：我们既可以显式使用`NeLoN`但会带来更多的符号痛苦，或者我们可以使用`list`但冒着一些关于异常混淆的风险。这在一般情况下是一个权衡，但在某些语言中存在更好的选项（关于符号的说明）。

因此，这实际上是一个非常强大的技术：构建一个精确反映我们想要的类型的 datatyp，从而将部分函数转换为全函数。程序员称这个原则为使非法状态不可表示。这可能需要编写一些将转换到和从其他方便表示的例程，以便代码重用。在这些例程中，必须有反映部分性的检查。

### 23.6 总结 "链接到此处")

通常，有一个非解决方案：

+   返回一个哨兵值。除非你首先修复了过去几十年 C 程序中潜伏的所有安全漏洞，否则永远不要这样做。

并且有四种解决方案：

+   使用`raise`。这并不适合一般的软件工程，因为异常笨拙、语义复杂，并且不具有组合性。

+   使用动态细化。动态细化在大多数语言中并不常见。而且，它比其他任何解决方案都要差，但在许多情况下是一个不错的折衷方案。

+   定义一个 datatyp 来使非法状态不可表示。这是一项工作。相当复杂，在某些地方非常有价值，但并不总是值得付出努力。

+   使用`Option`。通常是一个理想的选择，因为：

    +   类型告诉我们可能会出现奇怪的情况。（`raise`隐藏了这个信息。）

    +   我们不可能意外地误用这个值。（哨兵隐藏了这个信息。）

    +   它是组合性的：我们可以创建函数来帮助我们处理它。

    +   它的 overhead 比静态总体解决方案要低得多。

    +   它比动态总体解决方案更静态地稳健。

    +   它是通用的：在实践中，除了`none`和`some`之外，一个真正的程序将会有`some`用于“正常”情况，以及描述可能出现的不同类型错误的多个变体，每个情况都有额外的信息。关于这个的具体例子，请参见集合的从集合中选取元素和队列的合并答案。

### 23.7 关于符号的说明 "链接到此处")

当我们上面说在使用`NeLoN`s 时无法获得编写，比如`[list: 1, 2, 3]`的便利性时，我们是在一般意义上说的。在一些语言中，我们实际上可以创建类似的便利构造器。例如，在 Pyret 中，有一个定义自定义构造器的协议；事实上，像`list`和`set`这样的看似内置构造器就是使用这个协议构建的。执行此操作的代码有点笨拙（部分原因是因为它通过使构造器编写者的生活更困难来节省一些空间和时间），但它只需要写一次。以下是`NeLoN`s 的`nelon`构造器：

```py
fun ra-to-nelon(r :: RawArray<Number>) -> NeLoN:
  len = raw-array-length(r)
  fun make-from-index(n :: Number):
    v = raw-array-get(r, n)
    if n == (len - 1):
      one(v)
    else:
      more(v, make-from-index(n + 1))
    end
  end
  make-from-index(0)
end

nelon = {
  make0: {(): raise("can't make an empty NeLoN")},
  make1: {(a1): one(a1)},
  make2: {(a1, a2): more(a1, one(a2))},
  make3: {(a1, a2, a3): more(a1, more(a2, one(a3)))},
  make4: {(a1, a2, a3, a4): more(a1, more(a2, more(a3, one(a4))))},
  make5: {(a1, a2, a3, a4, a5): more(a1, more(a2, more(a3, more(a4, one(a5)))))},
  make: {(args :: RawArray<Number>): ra-to-nelon(args)} }
```

这些测试表明这个构造器非常类似于内置的`list`：

```py
check:
  [nelon: ] raises "empty"
  [nelon: 1] is one(1)
  [nelon: 1, 2] is more(1, one(2))
  [nelon: 1, 2, 3] is more(1, more(2, one(3)))
  [nelon: 1, 2, 3, 4] is more(1, more(2, more(3, one(4))))
  [nelon: 1, 2, 3, 4, 5] is more(1, more(2, more(3, more(4, one(5)))))
  [nelon: 1, 2, 3, 4, 5, 6] is
  more(1, more(2, more(3, more(4, more(5, one(6))))))
  [nelon: 1, 2, 3, 4, 5, 6, 7] is
  more(1, more(2, more(3, more(4, more(5, more(6, one(7)))))))
end
```

使用这个，我们可以非常方便地重写来自总域，静态的测试：

```py
check:
  avg4([nelon: 1]) is 1
  avg4([nelon: 1, 2, 3]) is 2
  avg4([nelon: 1, 2, 3, 10]) is 4
end
```

因此，我们既得到了蛋糕，又吃了它！

### 23.1 一个非解决方案 "链接到此处")

我们将从一个过去程序员经常使用的策略开始，但我们将其拒绝为非解决方案。这个策略是通过在错误情况下返回一个值来使上述合同绝对正确；这个值通常被称为哨兵。例如，哨兵可能是`0`。以下是完整的程序：

```py
type LoN = List<Number>

fun sum(l :: LoN) -> Number:
  fold({(a, b): a + b}, 0, l)
end

avg0 :: LoN -> Number

fun avg0(l):
  cases (List) l:
    | empty => 0
    | link(_, _) =>
      s = sum(l)
      c = l.length()
      s / c
  end
end
```

下面是一些测试：

```py
check:
  avg0([list: 1]) is 1
  avg0([list: 1, 2, 3]) is 2
  avg0([list: 1, 2, 3, 10]) is 4
end
```

这里缺少测试吗？是的，对于空列表！我们应该添加它吗？

```py
check:
  avg0(empty) is 0
end
```

问题是，我们应该对这个“解决方案”感到满意吗？它有两个问题。

首先，每次使用`avg0`时都需要检查它是否返回了`0`。如果没有，那么答案是合法的，它可以继续进行计算。但如果它返回了，那么它必须假设输入可能是非法的，并且不能使用这个答案。

第二，即使这也不完全正确。要理解为什么，我们需要编写更多的测试：

```py
check:
  avg0([list: -1, 0, 1]) is 0
  avg0([list: -5, 4, 1]) is 0
end
```

所以问题是，当`avg0`返回`0`时，我们不知道这是否是一个合法的答案，或者是一个代表“这不是有效输入”的“虚假”答案。所以即使是我们的“检查一切”的策略也失败了！

啊，但也许问题出在`0`的使用上！或许我们可以使用一个不同的数字，这样它就能正常工作。比如`1`？或者`-1`？问题是：有没有任何数字合理地不能是实际输入的平均值？（并且对于所有问题，你能确定这一点吗？）当然不能。

这就是为什么这是一个非解决方案。它已经造成了一些问题：

+   我们无法从输出中判断输入是否无效。

+   这意味着每个调用者都需要进行检查。

+   忘记检查的调用者可能会进行无意义的计算。

+   组合性被破坏了：任何传递给`average`函数的函数都需要知道要检查输出（并且合同中没有任何警告！）。

事实上，几十年的经验告诉我们，世界上一些最复杂的程序员甚至在没有最关键的时候也无法处理这个问题，导致了许多有害的安全问题。因此，我们现在应该将此视为软件构建的一个有缺陷的方法，永远不要自己这样做。

让我们来看看四个实际解决方案。

### 23.2 异常 "链接到此处")

许多语言，包括 Pyret，提供的一种技术被称为异常。异常是一种特殊的编程结构，它有效地终止了计算，因为程序无法确定如何使用它拥有的数据继续计算。一些语言中有更复杂的异常形式，但在这里我们只关注将它们用作处理部分性的策略。

这里是一个使用异常（我们重用了之前的`sum`）编写的平均程序：

```py
avg1 :: LoN -> Number

fun avg1(l):
  cases (List) l:
    | empty => raise("no average for empty list")
    | link(_, _) =>
      s = sum(l)
      c = l.length()
      s / c
  end
end

check:
  avg1([list: 1]) is 1
  avg1([list: 1, 2, 3]) is 2
  avg1([list: 1, 2, 3, 10]) is 4
end
```

`raise`的工作方式是终止所有等待发生的事情。例如，如果我们写

```py
1 + avg1(empty)
```

`1 + …`部分永远不会发生：整个计算结束。`raise`创建异常。

再次，我们缺少一个测试。我们如何编写它？

```py
check:
  avg1(empty) raises "no average for empty list"
end
```

`raises`形式接受一个字符串，该字符串与提供给`raise`的字符串进行匹配。实际上，为了方便，原始字符串的任何子串都是允许的：例如，我们也可以这样写`check: avg1(empty) raises "no average" avg1(empty) raises "empty list" end`

在许多编程语言中，使用异常是处理部分性的标准方式。这当然是一个实用的解决方案。观察一下，我们得到了重用之前`sum`的机会；合同看起来很干净；我们只需要在不知道该做什么的地方使用`raise`。有什么不喜欢的呢？

异常有两个主要问题：

1.  在实际系统中，异常以不可预测的方式终止程序执行。调用`avg1`的调用者可能正在进行其他事情的一半（例如，它可能已经打开了一个打算关闭的文件），但异常导致调用没有干净地完成，导致剩余的计算没有运行，使系统处于混乱状态。

1.  相关地，我们提出作为特性的事情实际上应该被视为一个问题：合同有误！合同中根本没有任何迹象表明可能会发生异常。程序员必须阅读整个实现——<wbr>这可能会随时改变——<wbr>而不是能够依赖其发布的合同，因为合同的全部要点是它们让我们免于不得不阅读整个实现！

事实上，一些为大规模编程设计的现代编程语言（如 Go 和 Rust）不再有异常结构。因此，你不应该假设这将继续是未来的“标准”做事方式。

注意，可能发生两种类型的异常。一种是我们上面写的那种。另一种是我们完全忽略（或者忘记考虑）空列表的情况，最终从 Pyret 得到错误，这也是一种异常。如果 Pyret 无论如何都会抛出异常，我们自己去处理它有意义吗？

是的，它确实如此！有以下几个原因：

1.  首先，你可以控制异常发生的位置和它所显示的内容。

1.  你可以记录异常将会发生。

1.  你对 Pyret 或任何底层编程语言的行为的依赖性更小，这些语言可能会以微妙的方式发生变化。

1.  你可以创建一个只属于你自己的异常，这样它就不会与其他可能潜伏在程序中的除以零错误混淆。

由于这些原因，最好显式地检查并抛出异常，而不是让它“跌落”到编程语言中。相反，这个解决方案的真正问题更为微妙：不诚实合约和程序执行的影响。

### 23.3 选项类型 "链接到此处")

让我们重新审视`avg0`。它的问题在于它返回了一个无法与实际答案区分的值。所以也许另一种方法就是返回一个保证可以区分的值！为此，越来越多的语言（包括 Pyret）都有类似这样的类型：

```py
data Option<T>:
  | none
  | some(value :: T)
end
```

这是我们不确定是否有答案时使用的一种类型：`none`表示我们没有答案，而`some`表示我们有答案，`value`就是那个答案。

现在我们来看看我们的程序现在是什么样子：

```py
avg2 :: LoN -> Option<Number>

fun avg2(l):
  cases (List) l:
    | empty => none
    | link(_, _) =>
      s = sum(l)
      c = l.length()
      some(s / c)
  end
end
```

现在我们的测试看起来有些不同：

```py
check:
  avg2([list: 1]) is some(1)
  avg2([list: 1, 2, 3]) is some(2)
  avg2([list: 1, 2, 3, 10]) is some(4)
end

check:
  avg2(empty) is none
end
```

好消息是，合约现在是真的。仅仅通过查看它，我们就被提醒`avg0`可能并不总是能够计算出答案。

不幸的是，这给每个用户都带来了一些成本：他们必须使用`cases`来检查返回值，并且只有在它们是合法的情况下才使用它们。然而，这与我们预期的`avg0`是同一件事——只是我们缺乏确保我们不会滥用这个值的纪律！所以这是以原则方式完成的`avg0`。

### 23.4 全域，动态 "链接到此处")

所有这些问题都源于我们说`average`（就像`median`一样）是部分函数。然而，只有当我们把域指定为`List<Number>`时，它才是部分函数；实际上，它是在非空数字列表上的一个全函数。但我们如何表示这一点呢？

在一些语言中，比如 Pyret，我们实际上可以直接表达这一点：

```py
type NeLoND = List<Number>%(is-link)
```

这表示我们正在改进数值列表，使其始终包含一个`link`，即非空。在 Pyret 中，目前这个检查仅在运行时进行；在其他一些编程语言中，这可以通过类型检查器本身来完成。

这种改进让我们可以假装我们在处理常规列表，并重用所有现有的列表代码，同时确信我们永远不会遇到除以零错误：

```py
avg3 :: NeLoND -> Number

fun avg3(l):
  s = sum(l)
  c = l.length()
  s / c
end

check:
  avg3([list: 1]) is 1
  avg3([list: 1, 2, 3]) is 2
  avg3([list: 1, 2, 3, 10]) is 4
end
```

如果我们尝试传递一个空列表，我们会得到一个内部异常：

```py
check:
  avg3(empty) raises ""
end
```

这是一个相当有趣的解决方案。我们的函数代码很干净。我们不处理无意义的值。接口是真实的！（然而，这确实需要仔细阅读才能观察到域下隐藏的异常。）而且它让我们可以重用现有的代码。

有两个主要弱点：

1.  动态细化在大多数语言中都没有找到，因此我们需要做更多手动工作来获得相同的解决方案。

1.  我们不能得到一个静态保证（即在程序运行之前），即我们永远不会得到异常。

### 23.5 总域，静态 "链接到此处")

我们如何使函数具有静态保证的完整性？这需要我们确保我们永远不能构造一个空列表！显然，在 Pyret 的现有列表中这是不可能的。然而，我们可以构造一个新的类似列表的数据类型，它“底部”不是空列表，而是单元素列表：

```py
data NeLoN:
  | one(n :: Number)
  | more(n :: Number, r :: NeLoN)
end
```

注意，根本不可能创建一个空列表：最小的列表中有一个元素。此外，我们的类型检查器会为我们强制执行这一点。

当然，这与数字列表完全不同的数据类型。例如，我们不能在它上面使用现有的 `sum` 或 `length` 代码。然而，一个选项是将 `NeLoN` 转换为 `LoN`，这总是安全的，并且可以重用那段代码：

```py
fun nelon-to-lon(nl :: NeLoN):
  cases (NeLoN) nl:
    | one(n) => [list: n]
    | more(n, r) => link(n, nelon-to-lon(r))
  end
end

fun nl-sum(nl :: NeLoN) -> Number:
  sum(nelon-to-lon(nl))
end

fun nl-len(nl :: NeLoN) -> Number:
  nelon-to-lon(nl).length()
end
```

现在，我们可以以一种有趣的方式写出平均值：

```py
fun avg4(nl :: NeLoN) -> Number:
  s = nl-sum(nl)
  c = nl-len(nl)
  s / c
end
```

一次又一次，我们不需要任何逻辑来处理错误。然而，这并不是因为我们粗心大意，或者让 Pyret 处理它，或者在运行时进行检查，或者其他任何原因：因为没有办法产生一个空列表。因此，我们既有最简单的主体，也有最真实的接口！但是，这也有代价：我们需要做一些工作来重用现有的函数。

这个问题也扩展到编写测试，现在更加痛苦：

```py
check:
  nl1 = one(1)
  nl2 = more(1, more(2, one(3)))
  nl3 = more(1, more(2, more(3, one(10))))

  avg4(nl1) is 1
  avg4(nl2) is 2
  avg4(nl3) is 4
end
```

即，我们失去了编写列表的便利方式。我们可以通过编写一个辅助函数来恢复它，该函数创建 `NeLoN`：

```py
fun lon-to-nelon(l :: LoN) -> NeLoN:
  cases (List) l:
    | empty => raise("can't make an empty NeLoN")
    | link(f, r) =>
      cases (List) r:
        | empty => one(f)
        | else => more(f, lon-to-nelon(r))
      end
  end
end

check:
  avg4(lon-to-nelon([list: 1])) is 1
  avg4(lon-to-nelon([list: 1, 2, 3])) is 2
  avg4(lon-to-nelon([list: 1, 2, 3, 10])) is 4
end
```

注意，如果我们尝试使用一个空列表，我们会得到一个异常：

```py
check:
  avg4(lon-to-nelon(empty)) raises ""
end
```

然而，理解错误来源非常重要：异常不是来自 `avg4`，而是来自 `lon-to-nelon`，即“接口”函数。坏数据永远不会到达 `avg4`！我们可以验证这一点：

```py
check:
  lon-to-nelon(empty) raises ""
end
```

记住，没有方法可以将空列表发送到 `avg4`！尽管如此，这表明了一个权衡：我们既可以显式使用 `NeLoN` 但会带来更多的符号痛苦，或者我们可以使用 `list` 但冒着一些关于异常混淆的风险。这是一个普遍的权衡，但在某些语言中存在更好的选择（关于符号的说明）。

因此，这实际上是一个非常强大的技术：构建一个正好反映我们想要的类型的 dataype，从而将部分函数转换为全函数。程序员称这个原则为使非法状态不可表示。可能需要编写一些过程来转换到和从其他方便的表示形式以实现代码重用。在这些过程中，必须有检查来反映部分性。

### 23.6 概述 "链接到此处")

通常，有一个非解决方案：

+   返回一个哨兵值。除非你首先修复了 C 程序中过去几十年中潜伏的所有安全漏洞，否则永远不要这样做。

并且有四种解决方案：

+   使用`raise`。这并不适合软件工程，因为异常笨拙，语义复杂，并且不具有组合性。

+   使用动态细化。动态细化不在大多数语言中。此外，它比其他任何解决方案都差，但在许多设置中是一个合理的折衷方案。

+   定义一个数据类型来使非法状态不可表示。这是一项工作。相当复杂，在某些地方非常有价值，但并不总是值得付出努力。

+   使用`Option`。通常是一个理想的选项，因为：

    +   类型告诉我们预期会有一些奇怪的事情发生。（`raise`隐藏了这一点。）

    +   我们不会意外地误用这个值。（哨兵隐藏了这一点。）

    +   它是组合性的：我们可以创建函数来帮助我们处理它。

    +   它比静态整体解决方案的开销要低得多。

    +   它比动态整体解决方案更静态稳健。

    +   它进行了推广：在实践中，除了`none`和`some`之外，一个真正的程序将会有`some`用于“正常”情况，以及描述可能出现的不同类型错误的多个变体，每个情况都有额外的信息。关于这个的具体例子，请参阅从集合中选取元素和合并答案。

### 23.7 关于符号的说明 "链接到此处")

当我们上面说我们无法在`NeLoN`s 中使用时获得编写，例如`[list: 1, 2, 3]`的便利性时，我们是在一般意义上说的。在某些语言中，我们实际上可以创建类似的便利构造函数。例如，在 Pyret 中，有一个定义自定义构造函数的协议；实际上，像`list`和`set`这样的看似内置的构造函数就是使用这个协议构建的。执行此操作的代码有点笨拙（部分原因是因为它通过使构造函数编写者的生活更困难来节省一些空间和时间），但只需要编写一次。以下是一个`nelon`构造函数的例子：

```py
fun ra-to-nelon(r :: RawArray<Number>) -> NeLoN:
  len = raw-array-length(r)
  fun make-from-index(n :: Number):
    v = raw-array-get(r, n)
    if n == (len - 1):
      one(v)
    else:
      more(v, make-from-index(n + 1))
    end
  end
  make-from-index(0)
end

nelon = {
  make0: {(): raise("can't make an empty NeLoN")},
  make1: {(a1): one(a1)},
  make2: {(a1, a2): more(a1, one(a2))},
  make3: {(a1, a2, a3): more(a1, more(a2, one(a3)))},
  make4: {(a1, a2, a3, a4): more(a1, more(a2, more(a3, one(a4))))},
  make5: {(a1, a2, a3, a4, a5): more(a1, more(a2, more(a3, more(a4, one(a5)))))},
  make: {(args :: RawArray<Number>): ra-to-nelon(args)} }
```

这些测试表明这个构造函数非常类似于内置的`list`：

```py
check:
  [nelon: ] raises "empty"
  [nelon: 1] is one(1)
  [nelon: 1, 2] is more(1, one(2))
  [nelon: 1, 2, 3] is more(1, more(2, one(3)))
  [nelon: 1, 2, 3, 4] is more(1, more(2, more(3, one(4))))
  [nelon: 1, 2, 3, 4, 5] is more(1, more(2, more(3, more(4, one(5)))))
  [nelon: 1, 2, 3, 4, 5, 6] is
  more(1, more(2, more(3, more(4, more(5, one(6))))))
  [nelon: 1, 2, 3, 4, 5, 6, 7] is
  more(1, more(2, more(3, more(4, more(5, more(6, one(7)))))))
end
```

使用这个，我们可以非常方便地重写总域，静态中的测试：

```py
check:
  avg4([nelon: 1]) is 1
  avg4([nelon: 1, 2, 3]) is 2
  avg4([nelon: 1, 2, 3, 10]) is 4
end
```

因此，我们既得到了蛋糕，又吃了它！
