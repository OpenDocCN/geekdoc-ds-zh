# 18.6 集合作为案例研究🔗

> 原文：[`dcic-world.org/2025-08-27/sets-case-study.html`](https://dcic-world.org/2025-08-27/sets-case-study.html)

| |   18.6.1 数据的本质 |
| --- | --- |
| |   18.6.2 操作的本质 |
| |   18.6.3 保证的本质 |

我们在集合上花费了大量的时间。这不仅是因为它们本身很有用，而且因为它们为我们提供了一扇了解各种可能设计的窗口。特别是，它们说明了我们可以根据我们的需求在数据结构设计中做出的几个权衡。

我们可以根据几个维度来划分我们的设计。

#### 18.6.1 数据的本质🔗 "链接至此")

如果数据甚至不能在质量上进行比较，那么我们就不能从它们中构建集合，因为等价性是集合定义的核心。

如果数据可以在等价性上进行比较，但不能在排序上进行比较，那么我们只能构建具有线性时间复杂性的列表集合[将集合表示为列表]。然而，如果我们可以将值哈希化[将值转换为有序值]，那么我们可以构建树[在树上构建集合]和哈希表[从哈希和数组构建集合]。树为我们提供了最昂贵的原子操作的对数复杂性，而哈希表为我们提供了常数到线性复杂性。

#### 18.6.2 操作的本质🔗 "链接至此")

另一个维度的变化是我们需要的操作集合。我们开始时有一个相当雄心勃勃但标准的操作集合[<set-operations>]，但逐渐忽略了其中许多。特别是，一些集合的解释，如并查集，在牺牲大多数这些操作的情况下实现了优秀的复杂性。布隆过滤器提供了另一个例子。这里有一个通用的计算机科学原则在起作用：我们需要支持的操作越少，我们就能（有时）越好地（有时）使剩余操作的复杂性。

#### 18.6.3 保证的本质🔗 "链接至此")

最微妙的是，还有一个区别：我们是否需要可靠的结果。我们的大多数集合表示都是可靠的。然而，我们也看到了一种情况[布隆过滤器]，我们故意放弃了完全可靠性，用统计保证来代替。作为回报，这给我们（可能）带来了更高的性能。

因此，集合为计算机科学本身提供了一个有用的微观世界。

#### 18.6.1 数据的本质🔗 "链接至此")

如果数据甚至不能进行比较质量，那么我们就不能从它们中构建集合，因为相等是集合定义的核心。

如果数据可以比较相等但不能排序，那么我们只能构建具有线性时间复杂度的列表集合[将集合表示为列表]。然而，如果我们可以将值哈希化[将值转换为有序值]，那么我们可以构建树[在树上构建集合]和哈希表[从哈希和数组构建集合]。树为我们提供了对最昂贵的原子操作的对数复杂度，而哈希表为我们提供了常数到线性复杂度。

#### 18.6.2 操作的本质🔗 "链接至此")

变化的另一个维度是我们需要的操作集合。我们开始时有一个相当雄心勃勃但标准的操作集合[<set-operations>]，但逐渐忽略了其中许多。特别是，一些集合的解释，如并查集，在牺牲大多数这些操作的情况下实现了优秀的复杂度。布隆过滤器是这种实例的另一个例子。这里有一个通用的计算机科学原则在起作用：我们需要支持的操作越少，我们就能（有时）越好地（有时）使剩余操作的复杂度。

#### 18.6.3 保证的本质🔗 "链接至此")

最微妙的是，还有一个区别：我们是否需要可靠的结果。我们的大多数集合表示都是可靠的。然而，我们也看到了一种情况[布隆过滤器]，我们故意放弃了完全可靠性，用统计保证来代替。作为回报，这给我们（可能）带来了更高的性能。

因此，集合为计算机科学本身提供了一个有用的微观世界。
