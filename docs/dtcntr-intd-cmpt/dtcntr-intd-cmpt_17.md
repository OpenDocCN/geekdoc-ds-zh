# 6.2 集合化结构化数据🔗

> 原文：[`dcic-world.org/2025-08-27/Collections_of_Structured_Data.html`](https://dcic-world.org/2025-08-27/Collections_of_Structured_Data.html)

|   6.2.1 列表作为集体数据)] |
| --- |
|   6.2.2 集合作为集体数据)] |
|   6.2.2.1 从集合中选取元素)] |
|   6.2.2.2 使用集合进行计算)] |
|   6.2.3 结合结构化和集体数据)] |
|   6.2.4 数据设计问题：表示测验)] |

当我们查看结构化数据 [结构化数据简介] 时，我们遇到了几种情况，我们不仅仅有一个数据，而是有多个数据：不仅仅是一首歌，而是一张包含这些歌曲的播放列表，不仅仅是一只动物，而是一个充满动物的动物园，不仅仅是一个通知，而是多个，不仅仅是一条消息（我们多么希望是这样！）而是我们收件箱中的多条消息，等等。总的来说，我们很少只有一个结构化数据：一个值得注意的例外：考虑一个系统的配置或偏好信息。这些信息可能存储在一个文件中，并通过用户界面进行更新。尽管通常只有一种配置，但它可能包含如此多的部分，以至于我们不希望我们的程序因为大量变量而变得杂乱无章；相反，我们可能会创建一个表示配置的结构，并只加载一个实例。实际上，原本不相关的变量现在变成了一个链接的字段集。如果我们知道只有一个，我们可能只需要几个单独的变量来表示这些部分，而不必费心创建和拆解一个结构。总的来说，因此，我们想要谈论结构化数据的集合。这里有一些更多的例子：

+   匹配标签的消息集合。

+   对话中的消息列表。

+   用户的友友集合。

> 现在就做！
> 
> > 集合数据与结构化数据有何不同？

在结构化数据中，我们有固定数量的可能不同的值。在集体数据中，我们有可变数量的相同类型的值。例如，我们一开始并不说明播放列表中必须有多少首歌或用户可以有多少页；但它们中的每一个都必须是一首歌或一页。（当然，一页可能是条件定义的，但最终集合中的所有东西仍然是一页。）

注意，我们上面提到了集合和列表。集合和列表之间的区别在于集合没有顺序，而列表有顺序。这种区别现在并不重要，但我们会稍后回到这一点 [集合作为集体数据)]。

当然，集合和列表并不是我们能够拥有的唯一类型的集体数据。这里还有一些其他的例子：

+   人的家谱。

+   您电脑上的文件系统。

+   聚会上的座位图。

+   页面的社交网络。

等等。在大多数情况下，一旦我们有一些经验，这些数据就像之前集体数据一样容易编程和操作，尽管其中一些 [重新审视相等性] 可能涉及更多的微妙之处。

我们之前已经见过表格 [表格数据简介]，它们是一种集体结构化数据。现在我们将探讨更多此类数据，以及如何编程它们。

#### 6.2.1 列表作为集体数据🔗 "链接到此处")

我们之前已经深入探讨过一种集合的例子：列表。列表不仅限于数字或字符串；它可以包含任何类型的值，包括结构化值。例如，使用我们之前的例子 [定义和创建结构化数据]，我们可以创建一个歌曲列表：

```py
song-list = [list: lver, so, wnkkhs]
```

这是一个包含三个元素的列表，每个元素都是一首歌曲：

```py
check:
  song-list.length() is 3
  song-list.first is lver
end
```

因此，我们之前关于在列表上构建函数的内容 [处理列表] 同样适用于这里。为了说明这一点，假设我们希望编写一个名为 `oldest-song-age` 的函数，它接受一个歌曲列表并返回列表中最老的歌曲。（可能有多首歌曲来自同一年；按照我们的衡量标准，所有这些歌曲的年龄将是相同的。如果发生这种情况，我们只需从列表中选择一首歌曲即可。然而，因此，更准确的说法应该是“一个”最老的歌曲，而不是“这个”。）

让我们通过示例来解决这个问题。为了使我们的示例易于编写，我们不会写出歌曲的完整数据，而是仅通过它们的变量名来引用它们。显然，我们列表中最老的歌曲绑定到 `lvar`。

```py
oldest-song([list: lver, so, wnkkhs]) is lvar
oldest-song([list:       so, wnkkhs]) is wnkkhs
oldest-song([list:           wnkkhs]) is wnkkhs
oldest-song([list:                 ]) is ???
```

在最后一种情况下，我们应该写什么？回想一下，我们之前见过这个问题 [`my-max`: 示例]：在空的情况中没有答案。实际上，这里的计算与 `my-max` 的计算非常相似，因为它本质上是一样的计算，只是要求最小年份（这将使歌曲成为最老的）。

从我们的例子中，我们可以看到解决方案的结构与 `my-max` 的结构相呼应。对于空列表，我们发出错误信号。否则，我们计算列表中剩余部分的最老歌曲，并将其年份与第一个进行比较。哪个年份更老，就是答案。

```py
fun oldest-song(sl :: List<ITunesSong>) -> ITunesSong:
  cases (List) sl:
    | empty => raise("not defined for empty song lists")
    | link(f, r) =>
      cases (List) r:
        | empty => f
        | else =>
          osr = oldest-song(r)
          if osr.year < f.year:
            osr
          else:
            f
          end
      end
  end
end
```

注意，没有保证只有一个最老的歌曲，这一点反映在 `osr.year` 可能等于 `f.year` 的可能性上。然而，我们的问题陈述允许我们只选择这样一首歌曲，这正是我们所做的。

> 现在行动起来！
> 
> > 将上述解决方案修改为 `oldest-song-age`，该函数计算最老歌曲的年龄。

哈哈，开个玩笑！你根本不应该修改之前的解决方案！相反，你应该让它保持原样——<wbr>它可能对其他目的有用——<wbr>然后构建一个新的函数来使用它：

```py
fun oldest-song-age(sl :: List<ITunesSong>) -> Number:
  os = oldest-song(sl)
  song-age(os)
where:
  oldest-song-age(song-list) is 71
end
```

#### 6.2.2 集合作为集体数据🔗 "链接到这里")

正如我们已经看到的，对于某些问题，我们不在乎输入的顺序，也不在乎重复项。这里有一些我们不关心顺序或重复项的例子：

+   你的网络浏览器会记录你访问过的网页，并且一些网站会使用这些信息以不同的颜色来区分已访问的链接和未看到的链接。这种颜色通常与您访问页面的次数无关。

+   在选举期间，民意调查代理可能会记录你已经投票，但不需要记录你投票的次数，也不关心人们投票的顺序。

对于这样的问题，列表相对于集合来说不是一个好的选择。在这里，我们将看到 Pyret 的内置集合是如何工作的。在 [集合的几种变体] 中，我们将看到我们如何为自己构建集合。

首先，我们可以像定义列表一样轻松地定义集合：

```py
import sets as S
song-set = [S.set: lver, so, wnkkhs]
```

当然，由于语言语法的本质，我们不得不按某种顺序列出元素。这有关系吗？

> 现在就做！
> 
> > 我们如何判断 Pyret 是否关心顺序？

这里是检查的最简单方法：

```py
check:
  song-set2 = [S.set: so, wnkkhs, lver]
  song-set is song-set2
end
```

如果我们想特别小心，我们可以写下所有其他元素的排列，并看到 Pyret 并不在乎。

> 练习
> 
> > 有多少种不同的顺序？

类似地，对于重复项：

```py
check:
  song-set3 = [S.set: lver, so, wnkkhs, so, so, lver, so]
  song-set is song-set3
  song-set3.size() is 3
end
```

我们可以再次尝试几种不同的重复方式，并确认集合忽略了它们。

##### 6.2.2.1 从集合中选取元素🔗 "链接到这里")

然而，这种无序性带来了一些问题。对于列表来说，谈论“第一个”和相应的“其余部分”是有意义的。根据定义，对于集合来说，没有“第一个”元素。事实上，Pyret 甚至不提供类似于 `first` 和 `rest` 的字段。取而代之的是，它提供了一种更准确但更复杂的机制。

`.pick` 方法返回集合的一个随机元素。它产生一个 `Pick` 类型的值（我们通过 `include pick` 获取）。当我们选择一个元素时，有两种可能性。一种是集合为空（类似于列表为空），这给我们一个 `pick-none` 值。另一种选项称为 `pick-some`，它给我们集合的实际成员。

`Pick` 的 `pick-some` 变体有两个字段，而不是一个。要理解这一点需要一点时间。让我们通过选择集合中的一个元素来探索它：

```py
fun an-elt(s :: S.Set):
  cases (Pick) s.pick():
    | pick-none => raise("empty set")
    | pick-some(e, r) => e
  end
end
```

（注意，在 `pick-some` 情况下，我们没有使用 `r` 字段。）

> 现在就做！
> 
> > 你能猜到我们为什么没有为 `an-elt` 写示例吗？
> > 
> 现在就做！
> 
> > 运行 `an-elt(song-set)`。你得到什么元素？
> > 
> > 再运行一次。再运行五次。
> > 
> > 你每次都得到相同的元素吗？

不，你没有！实际上，你不可能确定你没有。在六次运行中每次都得到完全相同的元素的可能性非常非常小。如果这种情况发生在你身上，请继续运行更多次！Pyret 被设计成在从集合中选择时不会总是返回相同的元素。这是故意的：这是为了强调从集合中选择时的随机性，并防止你的程序意外地依赖于 Pyret 可能使用的特定顺序。

> 现在进行！
> 
> > 既然`an-elt`不返回可预测的元素，我们能为它编写哪些（如果有的话）测试？

注意，虽然我们无法预测`an-elt`将产生哪个元素，但我们确实知道它将产生集合中的一个元素。因此，我们可以编写测试来确保结果元素是集合的成员——尽管在这种情况下，这并不会特别令人惊讶。

##### 6.2.2.2 使用集合进行计算🔗 "链接至此")

一旦我们从集合中选取了一个元素，通常我们还需要获取剩余元素的集合。我们已经看到，选择`pick-some`的第一个字段类似于获取集合的“第一个”元素。因此，我们希望有一种方法来获取集合的“其余”部分。然而，我们希望这部分是排除这个特定的“第一个”元素之后的结果。这就是`pick-some`的第二个字段所代表的内容：集合中剩余的部分。

基于此，我们可以编写在集合上操作的功能，这些功能大致类似于在列表上操作的功能。例如，假设我们想要计算集合的大小。这个函数看起来与`my-len`相似 [一些示例练习]：

```py
fun my-set-size(s :: S.Set) -> Number:
  cases (Pick) s.pick():
    | pick-none => 0
    | pick-some(e, r) =>
      1 + my-set-size(r)
  end
end
```

虽然推导这个过程的步骤与我们用于`my-len`的步骤相似，但随机选择元素的性质使得编写与实际函数行为匹配的示例变得更加困难。

#### 6.2.3 结合结构化和集体数据🔗 "链接至此")

如上例所示，程序的数据组织通常涉及多种类型的复合数据，通常是深度交织的。让我们首先考虑这些成对的情况。

> 练习
> 
> > 想出结合以下内容的示例：
> > 
> > +   结构化和条件数据，
> > +   
> > +   结构化和集体数据，和
> > +   
> > +   条件和集体数据。
> > +   
> > 你实际上已经看到了上述每种示例。请识别它们。

最后，我们甚至可能同时拥有这三个。例如，一个文件系统通常是一个文件和文件夹的列表（集体），每个文件都有几个属性（结构化）。同样，一个社交网络有一个页面集合（集体），每个页面是为一个人、组织或其他事物而设（条件），并且每个页面都有几个属性（结构化）。因此，正如你所看到的，这些组合在我们日常处理的各种应用中自然出现。

> 练习
> 
> > 选择你最喜欢的三个网站或应用程序。确定它们展示的数据类型。将这些数据分类为结构化、条件性和集体性。它们如何组合这些数据？

#### 6.2.4 数据设计问题：表示测验🔗 "链接到此处")

现在你已经可以创建结构化数据的集合，你可以开始创建用于相当复杂应用的数据和程序。让我们尝试一个数据设计问题，我们将专注于创建数据定义，而不是编写实际的函数。

问题陈述：你被雇佣来帮助创建用于给学生进行测验的软件。该软件将向学生展示一个问题，读取学生的答案，将学生的答案与预期答案进行比较（类似于 Pyret 示例！），并产生学生答对问题的百分比。

你的任务是创建一个数据定义来捕捉测验和预期答案。不用担心表示学生的回答。

> 现在行动！
> 
> > 提出一个初始的测验数据结构。首先确定你可能需要的部分，并尝试编写一些示例问题。

我们可以想象提出一个测验问题，比如“3 + 4 等于多少？”。我们期望学生回答`7`。这会捕捉到什么？一个具有两个字段的结构化数据，如下所示：

```py
data Question:
  basic-ques(text :: String, expect :: ???)
end
```

预期答案的好类型是什么？这个特定问题有一个数字答案，但其他问题可能有其他类型的答案。因此，`Any`是答案的适当类型。

我们还需要一个“问题”列表来形成一个完整的测验。

有时，测验软件允许学生请求提示。

> 现在行动！
> 
> > 假设我们想要有一些（但不是全部）问题带有提示，这些提示将是学生可以请求帮助解决问题的文本。修改当前的数据定义以捕捉一些问题带有提示而另一些没有的测验。

一次测验仍然应该是一系列问题，但“问题”数据定义需要另一个变体来处理带有提示的问题。以下是可以工作的方案：

```py
data Question:
  | basic-ques(text :: String, expect :: Any)
  | hint-ques(text :: String, expect :: Any, hint :: String)
end

A `quiz` is a `List<Question>`
```

我们可以想象扩展这个例子来引入问题之间的依赖关系（例如一个问题建立在另一个问题的技能之上），多项选择题、复选框问题等等。

> 负责任计算：考虑被取代的过程
> 
> > 许多公司试图通过自动化教师通常完成的任务的软件系统来改善教育。有些系统向学生展示视频，然后给他们测验（类似于你刚刚开发的），以检查他们学到了什么。更极端的版本将视频和测验交织在一起，从而以规模化的方式教授整个课程，而不需要教师干预。
> > 
> > 大规模在线课程（MOOCs）是一种利用计算机自动化来大量使用课程风格，以实现不需要更多教师就能接触到更多学生的目的。MOOCs 和相关教育技术工具的支持者承诺这些工具将带来变革性的影响，承诺将优质教育扩展到世界各地那些可能无法获得优质教师的学生。技术投资者（以及一些大学）对这些技术投入了大量资金，希望实现规模化的教育革命。
> > 
> > 不幸的是，研究和评估表明，用自动化系统取代教育，即使是基于数据分析预测并识别学生尚未完全掌握的技能的复杂功能，并不能带来承诺的学习收益。为什么？教学不仅仅是选择问题、收集学生作业和给出评分。教师提供鼓励、保证并理解个别学生的状况。今天的计算系统无法做到这一点。关于这些工具的普遍接受的观点（由过去三十年来的研究支持）是，它们最好用于补充人类教师的直接指导。在这样的环境中，一些工具已经导致学生在某些方面取得了坚实的性能提升。
> > 
> > 在社会责任方面，这里的关键是要考虑你可能会用计算方法取代的系统所有功能。算法测验工具在某些特定情境下确实有价值，但它们不能取代所有教学。未能理解教学的许多方面，以及哪些方面使其对学生教育有效，可能会避免许多关于算法教学承诺的不准确炒作。

#### 6.2.1 列表作为集体数据🔗 "链接到此处")

我们已经看到了一个深度集合的例子：列表。列表不仅限于数字或字符串；它可以包含任何类型的值，包括结构化值。例如，使用我们之前的一些例子 [定义和创建结构化数据]，我们可以制作一个歌曲列表：

```py
song-list = [list: lver, so, wnkkhs]
```

这是一个包含三个元素的列表，其中每个元素都是一首歌曲：

```py
check:
  song-list.length() is 3
  song-list.first is lver
end
```

因此，我们之前关于在列表上构建函数 [处理列表] 的内容也适用于这里。为了说明，假设我们希望编写一个名为 `oldest-song-age` 的函数，它接受一个歌曲列表并产生列表中最古老的歌曲。（可能有来自同一年的多首歌曲；这些歌曲的年龄——按照我们的衡量标准——将是相同的。如果发生这种情况，我们只需从列表中选择一首歌曲。然而，由于这个原因，更准确的说法应该是“一个”而不是“最”古老的歌曲。）

让我们通过例子来解决这个问题。为了使我们的例子易于编写，我们不会写出歌曲的完整数据，而是只通过它们的变量名来引用它们。显然，我们列表中最古老的歌绑定在`lvar`上。

```py
oldest-song([list: lver, so, wnkkhs]) is lvar
oldest-song([list:       so, wnkkhs]) is wnkkhs
oldest-song([list:           wnkkhs]) is wnkkhs
oldest-song([list:                 ]) is ???
```

在最后一种情况下我们写什么？回想一下，我们之前看到过这个问题[`my-max`: 示例]：在空情况下没有答案。实际上，这里的计算与`my-max`的计算非常相似，因为它本质上是一样的计算，只是要求最小年份（这将使歌曲成为最古老的）。

从我们的例子中，我们可以看到解决方案的结构与`my-max`的结构相呼应。对于空列表，我们发出错误信号。否则，我们计算列表剩余部分中最古老的歌，并将其年份与第一首歌的年份进行比较。年份较老的那首歌就是答案。

```py
fun oldest-song(sl :: List<ITunesSong>) -> ITunesSong:
  cases (List) sl:
    | empty => raise("not defined for empty song lists")
    | link(f, r) =>
      cases (List) r:
        | empty => f
        | else =>
          osr = oldest-song(r)
          if osr.year < f.year:
            osr
          else:
            f
          end
      end
  end
end
```

注意，没有保证只有一个最古老的歌，这反映在`osr.year`可能等于`f.year`的可能性上。然而，我们的问题陈述允许我们选择其中一首歌，这正是我们所做的。

> 现在行动！
> 
> > 将上述解决方案修改为`oldest-song-age`，该函数计算最古老歌曲的年龄。

哈哈，开个玩笑！你根本不应该修改之前的解决方案！相反，你应该让它保持原样——<wbr>它可能对其他目的有用——<wbr>然后构建一个新的函数来使用它：

```py
fun oldest-song-age(sl :: List<ITunesSong>) -> Number:
  os = oldest-song(sl)
  song-age(os)
where:
  oldest-song-age(song-list) is 71
end
```

#### 6.2.2 集合作为集体数据🔗 "链接到这里")

正如我们已经看到的，对于某些问题，我们不在乎输入的顺序，也不在乎重复项。这里有一些我们不关心顺序或重复项的更多例子：

+   你的网络浏览器记录了你访问过的网页，一些网站会使用这些信息将已访问的链接与未访问的链接区分开来。这种颜色通常与访问页面的次数无关。

+   在选举期间，投票代理可能会记录你已经投票，但不需要记录你投票的次数，也不关心人们投票的顺序。

对于这类问题，列表与集合相比不是一个好的选择。在这里，我们将看到 Pyret 内置的集合是如何工作的。在[集合的几种变体]中，我们将看到我们如何为自己构建集合。

首先，我们可以像定义列表一样轻松地定义集合：

```py
import sets as S
song-set = [S.set: lver, so, wnkkhs]
```

当然，由于语言语法的本质，我们必须按某种顺序列出元素。这有关系吗？

> 现在行动！
> 
> > 我们如何判断 Pyret 是否关心顺序？

这是检查的最简单方法：

```py
check:
  song-set2 = [S.set: so, wnkkhs, lver]
  song-set is song-set2
end
```

如果我们想特别小心，我们可以写下所有其他元素排列，并看到 Pyret 并不关心。

> 练习
> 
> > 有多少种不同的顺序？

对于重复项也是如此：

```py
check:
  song-set3 = [S.set: lver, so, wnkkhs, so, so, lver, so]
  song-set is song-set3
  song-set3.size() is 3
end
```

我们可以再次尝试几种不同的重复方式，并确认集合忽略了它们。

##### 6.2.2.1 从集合中选择元素🔗 "链接到这里")

然而，这种无序性却带来了一个问题。在列表中，谈论“第一个”和相应的“其余部分”是有意义的。根据定义，在集合中不存在“第一个”元素。事实上，Pyret 甚至不提供类似于`first`和`rest`的字段。取而代之的是，它提供了一些更准确但更复杂的替代方案。

`.pick`方法返回集合中的一个随机元素。它产生一个类型为`Pick`的值（我们通过`include pick`获得）。当我们选择一个元素时，有两种可能性。一种是集合为空（类似于列表为空），这给我们一个`pick-none`值。另一种选项称为`pick-some`，它给我们集合的实际成员。

`pick-some`变体的`Pick`有两个字段，而不是一个。要理解这一点需要一点时间。让我们通过选择集合的一个元素来探索它：

```py
fun an-elt(s :: S.Set):
  cases (Pick) s.pick():
    | pick-none => raise("empty set")
    | pick-some(e, r) => e
  end
end
```

（注意，我们在这里没有使用`pick-some`中的`r`字段。）

> 现在行动！
> 
> > 你能猜到为什么我们没有为`an-elt`编写示例吗？
> > 
> 现在行动！
> 
> > 运行`an-elt(song-set)`。你得到什么元素？
> > 
> > 再运行一次。再运行五次。
> > 
> > 你每次都得到相同的元素吗？

不，你没有！实际上，你不可能确定你没有。在六次运行中每次都得到完全相同的元素的可能性非常非常小。如果你遇到了这种情况，继续运行它更多次！Pyret 被设计成在从集合中选择时不会总是返回相同的元素。这是故意的：这是为了强调从集合中选择时的随机性，并防止你的程序意外地依赖于 Pyret 可能使用的特定顺序。

> 现在行动！
> 
> > 由于`an-elt`不返回可预测的元素，我们可以为它编写什么（如果有的话）测试？

注意，虽然我们无法预测`an-elt`将产生哪个元素，但我们确实知道它将产生集合中的一个元素。因此，我们可以编写确保结果元素是集合成员的测试——尽管在这种情况下，这并不会特别令人惊讶。

##### 6.2.2.2 使用集合进行计算🔗 "链接到这里")

一旦我们从集合中选取了一个元素，通常很有用的是获取剩余元素的集合。我们已经看到，选择`pick-some`的第一个字段类似于取集合的“第一个”。因此，我们想要一种方法来获取集合的“其余部分”。然而，我们想要的是排除这个特定的“第一个”之后剩下的部分。这就是`pick-some`的第二个字段：集合剩下的部分。

因此，我们可以编写在集合上看起来与在列表上类似的功能。例如，假设我们想要计算集合的大小。这个函数看起来与`my-len`相似 [一些示例练习]：

```py
fun my-set-size(s :: S.Set) -> Number:
  cases (Pick) s.pick():
    | pick-none => 0
    | pick-some(e, r) =>
      1 + my-set-size(r)
  end
end
```

尽管推导这个过程与我们在`my-len`中使用的类似，但随机选择元素的性质使得编写实际函数行为匹配的示例更加困难。

##### 6.2.2.1 从集合中选取元素🔗 "链接到这里")

然而，这种无序性却带来了一个问题。对于列表来说，谈论“第一个”和相应的“其余部分”是有意义的。根据定义，在集合中不存在“第一个”元素。实际上，Pyret 甚至不提供类似于`first`和`rest`的字段。取而代之的是，它提供了一种更准确但更复杂的方法。

`.pick`方法返回集合的一个随机元素。它产生一个`Pick`类型的值（我们通过`include pick`获得）。当我们选择一个元素时，有两种可能性。一种是集合为空（类似于列表为空），这会给我们一个`pick-none`值。另一种选项称为`pick-some`，它给我们集合的实际成员。

`Pick`的`pick-some`变体有两个字段，而不是一个。要理解这一点需要一点时间。让我们通过选择集合中的一个元素来探索它：

```py
fun an-elt(s :: S.Set):
  cases (Pick) s.pick():
    | pick-none => raise("empty set")
    | pick-some(e, r) => e
  end
end
```

（注意，在`pick-some`情况下，我们没有使用`r`字段。）

> 现在就做！
> 
> > 你能猜到为什么我们没有为`an-elt`编写示例吗？
> > 
> 现在就做！
> 
> > 运行`an-elt(song-set)`。你得到了什么元素？
> > 
> > 再次运行它。再运行五次。
> > 
> > 你每次都能得到相同的元素吗？

不，你不会！实际上，你不可能确定你不会。在六次运行中每次都得到完全相同的元素的可能性非常非常小。如果这种情况发生在你身上，继续运行它更多次！Pyret 被设计成在从集合中选择时不会总是返回相同的元素。这是故意的：这是为了强调从集合中选择是随机的，并且防止你的程序意外地依赖于 Pyret 可能使用的特定顺序。

> 现在就做！
> 
> > 由于`an-elt`不返回可预测的元素，我们能为它编写哪些（如果有的话）测试？

注意，虽然我们无法预测`an-elt`将产生哪个元素，但我们确实知道它将产生集合中的一个元素。因此，我们可以编写测试来确保结果元素是集合的成员——尽管在这种情况下，这并不会特别令人惊讶。

##### 6.2.2.2 使用集合进行计算🔗 "链接到这里")

一旦我们从集合中选取了一个元素，通常来说，获取剩余元素的集合是有用的。我们已经看到，选择`pick-some`的第一个字段类似于取集合的“第一个”。因此，我们想要一种方法来获取集合的“其余部分”。然而，我们想要的是排除这个特定的“第一个”之后剩下的部分。这就是`pick-some`的第二个字段所代表的内容：集合中剩下的部分。

基于此，我们可以在集合上写函数，这些函数看起来大致类似于在列表上的函数。例如，假设我们想要计算集合的大小。这个函数看起来与`my-len` [一些示例练习]相似：

```py
fun my-set-size(s :: S.Set) -> Number:
  cases (Pick) s.pick():
    | pick-none => 0
    | pick-some(e, r) =>
      1 + my-set-size(r)
  end
end
```

虽然推导过程与我们在 `my-len` 中使用的过程类似，但随机选择元素的性质使得编写与实际函数行为匹配的示例变得更加困难。

#### 6.2.3 结合结构化和集体数据🔗 "链接到此处")

如上述示例所示，程序的数据组织通常会涉及多种类型的复合数据，通常这些数据是深度交织的。让我们首先考虑这些数据对。

> 练习
> 
> > 提出一些结合以下内容的示例：
> > 
> > +   结构化和条件数据，
> > +   
> > +   结构化和集体数据，以及
> > +   
> > +   条件化和集体数据。
> > +   
> > 你实际上已经看到了这些示例。识别它们。

最后，我们甚至可能同时拥有所有三种类型。例如，文件系统通常是一个文件和文件夹（条件）的列表（集体），其中每个文件都有几个属性（结构化）。同样，社交网络有一组页面（集体），其中每个页面是为一个人、组织或其他事物（条件）而设，并且每个页面都有几个属性（结构化）。因此，正如你所看到的，这些组合在我们日常处理的各种应用中自然出现。

> 练习
> 
> > 选择你最喜欢的三个网站或应用程序。确定它们展示的数据类型。将这些数据分类为结构化、条件化和集体化。它们是如何结合这些数据的？

#### 6.2.4 数据设计问题：表示测验🔗 "链接到此处")

现在你能够创建结构化数据的集合，你可以着手创建用于相当复杂应用的数据和程序。让我们尝试一个数据设计问题，我们将专注于创建数据定义，但不会编写实际的函数。

问题陈述：你被雇佣来帮助创建用于向学生提供测验的软件。该软件将向学生展示一个问题，读取学生的答案，将学生的答案与期望答案进行比较（有点像 Pyret 的示例！），并产生学生答对问题的百分比。

你的任务是创建一个数据定义来捕捉测验和期望答案。不用担心表示学生的答案。

> 立即行动！
> 
> > 提出一个初始的测验数据结构。首先确定你可能需要的部分，并尝试编写一些示例问题。

我们可以想象提出一个测验问题，比如“3 + 4 等于多少？”我们期望学生回答 `7`。这应该用什么来捕捉？一个具有以下两个字段的具有结构化的数据片段：

```py
data Question:
  basic-ques(text :: String, expect :: ???)
end
```

期望的答案应该是什么类型？这个具体问题有一个数值答案，但其他问题可能有其他类型的答案。"Any" 因此是答案的适当类型。

我们还需要一个 `Question` 列表来形成一个完整的测验。

有时候，测验软件允许学生请求提示。

> 立即行动！
> 
> > 假设我们想要有一些（但不是全部）带有提示的问题，这些提示将是学生可以请求帮助解决问题的文本。修改当前的数据定义以捕捉到一些问题带有提示而另一些没有的测验。

一次测验仍然应该是一系列问题，但“问题”数据定义需要另一个变体来处理带有提示的问题。以下是可以工作的方案：

```py
data Question:
  | basic-ques(text :: String, expect :: Any)
  | hint-ques(text :: String, expect :: Any, hint :: String)
end

A `quiz` is a `List<Question>`
```

我们可以将这个例子扩展到引入问题之间的依赖关系（例如一个问题建立在另一个问题的技能之上），多项选择题，复选框问题等等。

> 负责任的计算：考虑被取代的过程
> 
> > 许多公司都尝试通过自动化教师任务的软件系统来改善教育。有些系统会向学生展示视频，然后给他们测验（类似于你刚刚开发的），以检查他们学到了什么。更极端的版本将视频和测验交织在一起，从而大规模地教授整个课程，而不需要教师的干预。
> > 
> > 大规模在线课程（MOOCs）是一种大量使用计算机自动化的课程风格，以实现不需要更多教师就能接触到更多学生。MOOCs 和相关教育技术工具的支持者承诺这些工具将带来变革性的影响，承诺将优质教育扩展到世界各地那些可能无法获得优质教师的学生。技术投资者（以及一些大学）对这些技术投入了大量资金，希望实现规模化的教育革命。
> > 
> > 不幸的是，研究和评估表明，用自动化系统取代教育，即使这些系统基于数据分析和对学生尚未完全掌握的技能的预测，也不能带来承诺的学习收益。为什么？事实证明，教学不仅仅是选择问题、收集学生作业和给出评分。教师提供鼓励、保证并理解个别学生的状况。今天的计算系统做不到这一点。关于这些工具的普遍接受的观点（由过去三十年来的研究支持）是，它们最好用于补充人类教师的直接指导。在这样的环境中，一些工具已经导致学生在某些方面取得了坚实的成绩提升。
> > 
> > 在社会责任方面，这里的关键是要考虑你可能会用计算方法取代的所有系统功能。在某些特定情境下，算法测验工具确实具有真正的价值，但它们不能取代所有的教学。未能理解教学的许多方面，以及哪些方面对教育学生有效，可能会避免许多关于算法教学承诺的不准确炒作。
