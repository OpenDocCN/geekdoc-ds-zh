# 8.1 函数作为数据

> 原文：[`dcic-world.org/2025-08-27/func-as-data.html`](https://dcic-world.org/2025-08-27/func-as-data.html)

| |   8.1.1 一点微积分 |
| --- | --- |
| |   8.1.2 匿名函数的有用缩写 |
| |   8.1.3 流程从函数中生成 |
| |   8.1.4 结合力量：导数流 |

考虑到我们迄今为止学到的编程的表述能力是很有趣的。为了说明这一点，我们将通过一些有趣的练习来展示我们可以仅使用函数作为值来表述的概念。我们将写两件相当不同的事情，然后展示它们如何很好地收敛。

#### 8.1.1 一点微积分 "链接到此处")

如果你已经学习过微分学，你一定遇到过这样的奇怪语法陈述：

\begin{equation*}{\frac{d}{dx}} x² = 2x\end{equation*}

让我们解开这意味着什么：\(d/dx\)、\(x²\) 和 \(2x\)。

首先，让我们处理这两个表达式；我们将讨论一个，讨论将涵盖另一个。对“\(x²\) 的意思是什么？”的正确回答当然是错误：它没有任何意义，因为 \(x\) 是一个未绑定的标识符。

那么，它的意图是什么？显然，意图是表示一个平方其输入的函数，就像 \(2x\) 意味着是将其输入加倍的那个函数一样。我们有更优雅的方式来写这些：

```py
fun sq(x :: Number) -> Number: x * x end
fun dbl(x :: Number) -> Number: 2 * x end
```

我们真正试图说的其实是 `sq` 的 `d/dx` 是 `dbl`。我们假设的是一元变量中的函数。

因此，现在让我们解开 `d/dx` 的含义，从其类型开始。正如上述示例所示，`d/dx` 实际上是一个从函数到函数的函数。也就是说，我们可以将其类型写成以下形式：

```py
d-dx :: ((Number -> Number) -> (Number -> Number))
```

（这种类型可能解释了为什么你的微积分课程从未以这种方式解释这个操作——<wbr>尽管不清楚掩盖其真正含义是否对你的理解更有益。）

让我们现在实现 `d/dx`。我们将实现数值微分，尽管原则上我们也可以实现符号微分——<wbr>使用你学过的规则，例如，给定一个多项式，乘以指数并减少指数一个——<wbr>使用表达式表示（这个问题将在未来的版本中更详细地介绍）。

通常，函数在一点的数值微分会产生该点的导数值。我们有一个方便的公式：\(f\) 在 \(x\) 处的导数是

\begin{equation*}\frac{f(x + \epsilon) - f(x)}{\epsilon}\end{equation*}

当 \(\epsilon\) 在极限中趋近于零时。现在我们将给无穷小量一个小的但固定的值，稍后 [结合力量：导数流] 我们将看看我们如何可以改进这一点。

```py
epsilon = 0.00001
```

我们现在可以将上述公式转换为一个函数：

```py
d-dx-at :: (Number -> Number), Number -> Number

fun d-dx-at(f, x):
  (f(x + epsilon) - f(x)) / epsilon
end
```

当然，我们可以检查并确保它按预期工作：

```py
check:
  d-dx-at(sq, 10) is-roughly dbl(10)
end
```

倒霉的是，我们选择了`epsilon`的值，以便默认的容差`is-roughly`适用于这个例子。

然而，这还有一些令人不满意的地方。我们编写的函数显然不具有我们之前描述的类型！我们想要的是一个只接受函数的操作，并代表柏拉图式的微分概念；但由于数值微分的性质，我们被迫描述在某个点的导数。我们可能更喜欢写如下：

```py
fun d-dx(f):
  (f(x + epsilon) - f(x)) / epsilon
end
```

> 现在让我们来做一下练习！
> 
> > 上面的定义有什么问题？

如果你没有注意到，Pyret 很快就会告诉你：`x`没有绑定。实际上，`x`是什么？它是我们试图计算数值导数的点。也就是说，`d-dx`需要返回的不是数字，而是一个函数（如类型所示），它将消耗这个`x`：“Lambdas are relegated to relative obscurity until Java makes them popular by not having them.”—<wbr>James Iry, [《编程语言简史：简短、不完整且大多错误》](https://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html)

```py
fun d-dx(f):
  lam(x):
    (f(x + epsilon) - f(x)) / epsilon
  end
end
```

如果我们想更明确一些，我们可以注释内部函数：

```py
fun d-dx(f):
  lam(x :: Number) -> Number:
    (f(x + epsilon) - f(x)) / epsilon
  end
end
```

这是一个在许多编程环境中都很有用的概念的特殊情况，我们将在其他地方更详细地探讨：Staging。

果然，这个定义现在有效了。例如，我们可以这样测试它（注意使用`num-floor`来避免测试中出现的数值精度问题，使测试看起来失败）：

```py
d-dx-sq = d-dx(sq)

check:
  ins = [list: 0, 1, 10, 100]
  for map(n from ins):
    num-floor(d-dx-sq(n))
  end
  is
  for map(n from ins):
    num-floor(dbl(n))
  end
end
```

现在，我们可以回到启动这次调查的原始示例：数学中混乱和神秘的符号真正试图表达的意思是，

```py
d-dx(lam(x): x * x end) = lam(x): 2 * x end
```

或者，在 A Notation for Functions 的记法中，

\begin{equation*}{\frac{d}{dx}} [x \rightarrow x²] = [x \rightarrow 2x]\end{equation*}

惜哉，数学教科书不愿告诉我们真相！

#### 8.1.2 匿名函数的有用缩写 "链接到这里")

Pyret 提供了编写匿名函数的简短语法。尽管从风格上讲，我们通常避免使用它，以免我们的程序变成特殊字符的混乱，但有时它特别方便，如下所示。这种语法是

```py
{(a): b}
```

其中`a`是零个或多个参数，`b`是主体。例如，我们可以将`lam(x): x * x end`写成

```py
{(x): x * x}
```

我们可以在这里看到简洁性的好处。特别是，请注意没有必要使用`end`，因为花括号已经取代了表示表达式开始和结束的位置。同样，我们也可以将`d-dx`写成

```py
fun d-dx-short(f):
  {(x): (f(x + epsilon) - f(x)) / epsilon}
end
```

但许多读者会说这使函数更难阅读，因为突出的`lam`清楚地表明`d-dx`返回一个（匿名）函数，而此语法则掩盖了这一点。因此，我们通常只会使用这种缩写语法来编写“一行代码”。

#### 8.1.3 从函数生成流 "链接到这里")

人们通常认为函数只有一个用途：参数化一个表达式。虽然这是真的，也是函数最常见的使用方式，但这并不能证明没有参数的函数是合理的，因为那显然没有对任何东西进行参数化。然而，没有参数的函数也有其用途，因为函数实际上有两个用途：参数化和在函数被应用之前挂起主体的评估。实际上，这两个用途是正交的，因为可以在不使用另一个功能的情况下使用其中一个功能。下面，我们将关注延迟而不抽象（另一个在其他计算机科学场景中出现）。

让我们考虑一下简单的列表。列表的长度只能是有限的。然而，自然界中有许多没有自然上限的列表（或序列）：从数学对象（自然数的序列）到自然现象（网站访问的序列）。与其试图将这些无界列表压缩成有界列表，不如看看我们如何表示和编程这些无界列表。

首先，让我们编写一个程序来计算自然数的序列：

```py
fun nats-from(n):
  link(n, nats-from(n + 1))
end
```

> 现在行动起来！
> 
> > 这个程序有问题吗？

虽然这代表了我们的意图，但它不起作用：运行它——例如，`nats-from(0)`——会创建一个无限循环，为每个后续的自然数评估 `nats-from`。换句话说，我们想要写一些非常类似上面的东西，但只有在我们需要的时候才会递归，即按需。换句话说，我们希望列表的其余部分是惰性的。

这就是我们对函数的洞察所在。正如我们刚才提到的，函数会延迟其主体的评估，直到它被应用。因此，从原则上讲，函数会推迟调用 `nats-from(n + 1)` 直到它被需要。

除了，这会创建一个类型问题：`link` 的第二个参数需要是一个列表，而不能是一个函数。确实，因为它必须是一个列表，并且每个已经构造的值都必须是有限的，所以每个列表都是有限的，最终会在 `empty` 中终止。因此，我们需要一个新的数据结构来表示这些惰性列表中的链接（也称为流）：

<stream-type-def> ::=

```py
data Stream<T>:
  | lz-link(h :: T, t :: ( -> Stream<T>))
end
```

其中，注释 `( -> Stream<T>)` 表示一个无参数的函数（因此 `->` 前面没有内容），也称为 thunk。注意，我们定义流的方式意味着它们必须是无限的，因为我们没有提供终止它们的方法。

让我们构建一个最简单的例子，一个常量值的流：

```py
ones = lz-link(1, lam(): ones end)
```

Pyret 实际上会对这个定义提出抱怨。注意，这个列表的等价物也不会工作：

```py
ones = link(1, ones)
```

因为 `ones` 在定义点没有定义，所以当 Pyret 评估 `link(1, ones)` 时，它会抱怨 `ones` 没有定义。然而，它对我们的前一个定义过于保守：`ones` 的使用是在 `lam` 下，因此只有在 `ones` 定义完成后才会需要，到那时 `ones` 将被定义。我们可以通过使用关键字 `rec` 来向 Pyret 表明这一点：

```py
rec ones = lz-link(1, lam(): ones end)
```

注意，在 Pyret 中，每个 `fun` 都隐式地有一个 `rec` 在其下方，这就是为什么我们可以轻松地创建递归函数。

> 练习
> 
> > 之前我们说过，我们无法写出
> > 
> > ```py
> > ones = link(1, ones)
> > ```
> > 
> > 如果我们尝试写出
> > 
> > ```py
> > rec ones = link(1, ones)
> > ```
> > 
> > 那么，这样做行得通吗？如果行得通，`ones` 绑定的值是什么？如果不行，它是否因为与没有 `rec` 的定义相同的原因而失败？

从此以后，我们将使用缩写 [匿名函数的有用缩写)] 来代替。因此，我们可以将上述定义重写为：

```py
rec ones = lz-link(1, {(): ones})
```

注意，`{(): …}` 定义了一个无参数的匿名函数。你不能省略 `()`！如果你这样做，Pyret 会对你的程序的含义感到困惑。

因为函数是自动递归的，当我们编写一个函数来创建流时，我们不需要使用 `rec`。考虑以下示例：

```py
fun nats-from(n :: Number):
  lz-link(n, {(): nats-from(n + 1)})
end
```

我们可以用它来定义自然数：

```py
nats = nats-from(0)
```

注意，`nats` 的定义本身不是递归的——递归发生在 `nats-from` 内部——因此我们不需要使用 `rec` 来定义 `nats`。

> 现在行动起来！
> 
> > 之前，我们说过每个列表都是有限的，因此最终会终止。这个评论如何适用于流，例如上面 `ones` 或 `nats` 的定义？

`ones` 的描述仍然是一个有限的描述；它仅仅代表了无限多个值的可能性。注意：

1.  类似的推理不适用于列表，因为列表的其余部分已经被构造好了；相比之下，在那里放置一个函数则可能产生大量尚未到来的计算。

1.  话虽如此，即使对于流，在任何给定的计算中，我们也将只创建流有限的前缀。然而，我们不必过早地决定数量；每个客户端和使用都可以根据需要提取更多或更少。

现在我们已经创建了多个流，但我们仍然没有一种简单的方法来“看到”一个。首先，我们将定义传统的类似列表的选择器。获取第一个元素与列表中的操作完全一样：

```py
fun lz-first<T>(s :: Stream<T>) -> T: s.h end
```

相比之下，当尝试访问流的其余部分时，从数据结构中我们只能得到一个 thunk。要访问实际的其余部分，我们需要强制这个 thunk，当然这意味着将其应用于无参数：

```py
fun lz-rest<T>(s :: Stream<T>) -> Stream<T>: s.t() end
```

这对于检查流的单个值很有用。提取它有限的前缀（给定大小）作为一个（常规）列表也很有用，这对于测试特别有用。让我们编写这个函数：

```py
fun take<T>(n :: Number, s :: Stream<T>) -> List<T>:
  if n == 0:
    empty
  else:
    link(lz-first(s), take(n - 1, lz-rest(s)))
  end
end
```

如果你仔细观察，你会发现这个体不是通过（流）输入的结构来定义的案例——相反，它是通过自然数定义的案例（零或后继）。我们将在下面回到这个问题 (<lz-map2-def>)。

现在我们有了这个，我们可以用它来进行测试。请注意，我们通常使用我们的数据来测试我们的函数；这里，我们使用这个函数来测试我们的数据：

```py
check:
  take(10, ones) is map(lam(_): 1 end, range(0, 10))
  take(10, nats) is range(0, 10)
  take(10, nats-from(1)) is map((_ + 1), range(0, 10))
end
```

符号`(_ + 1)`定义了一个接受一个参数并将`1`加到给定参数上的 Pyret 函数。

让我们定义另一个函数：流的`map`等价函数。由于很快就会变得明显的原因，我们将定义一个版本，它接受两个列表并将第一个参数逐点应用于它们：

<lz-map2-def> ::=

```py
fun lz-map2<A, B, C>(
    f :: (A, B -> C),
    s1 :: Stream<A>,
    s2 :: Stream<B>) -> Stream<C>:
  lz-link(
    f(lz-first(s1), lz-first(s2)),
    {(): lz-map2(f, lz-rest(s1), lz-rest(s2))})
end
```

现在我们可以特别清楚地看到我们之前关于函数结构的评论。而传统的列表`map`有两个案例，这里我们只有一个案例，因为数据定义 (<stream-type-def>)只有一个案例！这有什么后果？在传统的`map`中，一个案例看起来像上面那样，但另一个案例对应于`empty`输入，它产生相同的输出。这里，因为流永远不会终止，所以映射也不会终止，函数的结构反映了这一点。这引发了一个更微妙的问题：如果函数的主体没有基础和归纳案例，我们如何对它进行归纳证明？简短的答案是，我们不能：我们必须改用☛归纳归纳。

为什么我们定义`lz-map2`而不是`lz-map`？因为它使我们能够编写以下内容：

```py
rec fibs =
  lz-link(0,
    {(): lz-link(1,
          {(): lz-map2({(a :: Number, b :: Number): a + b},
                fibs,
            lz-rest(fibs))})})
```

从中，当然，我们可以提取我们想要的任何斐波那契数！

```py
check:
  take(10, fibs) is [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
end
```

> 练习
> 
> > 定义流的`map`和`filter`等价函数。

流和更一般地，按需展开的无限数据结构在编程中非常有价值。考虑，例如，游戏中可能采取的移动。在某些游戏中，这可能无限；即使它是有限的，对于有趣的游戏，组合数学意味着树太大，无法实际存储在内存中。因此，计算机智能的程序员必须按需展开游戏树。使用我们上面描述的编码来编程意味着程序懒惰地描述整个树，树按需自动展开，减轻了程序员实现这种策略的负担。

在某些语言中，例如 Haskell，默认情况下就内置了惰性求值。在这样的语言中，不需要使用 thunks。然而，惰性求值给语言带来了其他负担，你可以在编程语言课程中了解这些。

#### 8.1.4 组合力量：导数流 "链接到这里")

当我们定义`d-dx`时，我们将`epsilon`设置为一个任意的高值。我们也可以将`epsilon`本身看作是一个产生越来越精细值的流；然后，例如，当导数值的差异足够小的时候，我们可以决定我们已经得到了导数的足够近似。

因此，第一步是将`epsilon`变成某种参数，而不是一个全局常数。这留下了它应该是什么类型的参数（数字或流？）以及何时提供的问题。

在我们决定我们想要微分哪个函数以及我们想要其导数的值之后，消费这个参数最有意义；毕竟，`epsilon`值的流可能取决于这两个。因此，我们得到：

```py
fun d-dx(f :: (Number -> Number)) ->
    (Number -> (Number -> Number)):
  lam(x :: Number) -> (Number -> Number):
    lam(epsilon :: Number) -> Number:
      (f(x + epsilon) - f(x)) / epsilon
    end
  end
end
```

通过这个，我们可以回到我们的`square`例子：

```py
d-dx-square = d-dx(square)
```

注意，在这个点上，我们只是重新定义了`d-dx`，而没有提及任何关于流的参考：我们只是将一个常数变成了一个参数。

现在让我们定义十的负幂的流：

```py
tenths = block:
  fun by-ten(d):
    new-denom = d / 10
    lz-link(new-denom, lam(): by-ten(new-denom) end)
  end
  by-ten(1)
end
```

所以

```py
check:
  take(3, tenths) is [list: 1/10, 1/100, 1/1000]
end
```

为了具体化，让我们选择一个横坐标来计算`square`的数值导数——比如说`10`：

```py
d-dx-square-at-10 = d-dx-square(10)
```

回想一下，从类型来看，这现在是一个类型为`(Number -> Number)`的函数：给定一个`epsilon`的值，它使用这个值来计算导数。我们知道，从理论上讲，这个导数的值应该是`20`。现在我们可以（懒散地）将`tenths`映射到提供对`epsilon`的越来越好的近似，并看看会发生什么：

```py
lz-map(d-dx-square-at-10, tenths)
```

果然，我们得到的是`20.1`，`20.01`，`20.001`等等：对`20`的越来越好的数值近似。

> 练习
> 
> > 将上述程序扩展以接受一个容差，并从`epsilon`流中抽取尽可能多的值，直到导数的连续近似之间的差异落在该容差内。

#### 8.1.1 一点微积分 "链接到此处")

如果你研究过微分学，你可能会遇到这样的奇怪语法陈述：

\begin{equation*}{\frac{d}{dx}} x² = 2x\end{equation*}

让我们分析一下这意味着什么：\(d/dx\)，\(x²\)，和\(2x\)。

首先，让我们处理这两个表达式；我们将讨论一个，讨论将涵盖另一个。对“\(x²\)是什么意思？”的正确回答当然是错误：它没有任何意义，因为\(x\)是一个未绑定的标识符。

那它的意图是什么？很明显，意图是表示一个平方其输入的函数，就像\(2x\)意图是表示一个将其输入翻倍的函数一样。我们有更优雅的方式来写这些：

```py
fun sq(x :: Number) -> Number: x * x end
fun dbl(x :: Number) -> Number: 2 * x end
```

我们真正试图说的是，`sq`的\(d/dx\)（无论那是什么）是`dbl`。我们假设的是一元变量中的函数。

因此，现在让我们分析\(d/dx\)，从它的类型开始。正如上面的例子所说明的，\(d/dx\)实际上是从函数到函数的函数。也就是说，我们可以将其类型写成以下形式：

```py
d-dx :: ((Number -> Number) -> (Number -> Number))
```

（这种类型可能解释了为什么你的微积分课程从未这样解释这个操作——尽管不清楚掩盖其真正含义是否对你的理解更有益。）

让我们现在实现 `d-dx`。我们将实现数值微分，尽管原则上我们也可以实现符号微分——使用你学到的规则，例如，给定一个多项式，乘以指数并减去一个指数——使用表达式的表示（这个问题将在未来的版本中更详细地介绍）。

通常，函数在一点的数值微分给出该点的导数值。我们有一个方便的公式：\(f\) 在 \(x\) 处的导数是

\begin{equation*}\frac{f(x + \epsilon) - f(x)}{\epsilon}\end{equation*}

当 \(\epsilon\) 趋于零时。现在我们将给无穷小一个小的但固定的值，稍后 [Combining Forces: Streams of Derivatives] 我们将看看我们如何改进这一点。

```py
epsilon = 0.00001
```

我们现在可以将上述公式转换成一个函数：

```py
d-dx-at :: (Number -> Number), Number -> Number

fun d-dx-at(f, x):
  (f(x + epsilon) - f(x)) / epsilon
end
```

确实，我们可以检查并确保它按预期工作：

```py
check:
  d-dx-at(sq, 10) is-roughly dbl(10)
end
```

坦白说：我们选择了 `epsilon` 的值，以便默认的容差 `is-roughly` 对这个示例有效。

然而，这有点令人不满意。我们编写的函数显然不具有我们之前描述的类型！我们想要的是一个只接受函数的操作，并代表柏拉图式的微分概念；但由于数值微分的性质，我们被迫描述在一点的导数。我们可能更喜欢写这样：

```py
fun d-dx(f):
  (f(x + epsilon) - f(x)) / epsilon
end
```

> 现在行动起来！
> 
> > 上面的定义有什么问题？

如果你没有注意到，Pyret 将很快告诉你：`x` 没有绑定。实际上，`x` 是什么？它是我们试图计算数值导数的点。也就是说，`d-dx` 需要返回一个函数（正如类型所指示的），它将消耗这个 `x`：“Lambdas are relegated to relative obscurity until Java makes them popular by not having them.”—<wbr>James Iry, [A Brief, Incomplete, and Mostly Wrong History of Programming Languages](https://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html)

```py
fun d-dx(f):
  lam(x):
    (f(x + epsilon) - f(x)) / epsilon
  end
end
```

如果我们想更明确一些，我们可以注释内部函数：

```py
fun d-dx(f):
  lam(x :: Number) -> Number:
    (f(x + epsilon) - f(x)) / epsilon
  end
end
```

这是许多编程环境中一个有用概念的特殊情况，我们将在其他地方更详细地探讨：Staging。

确实，这个定义现在可以工作了。例如，我们可以这样测试它（注意使用 `num-floor` 以避免由于测试失败而出现的数值精度问题）：

```py
d-dx-sq = d-dx(sq)

check:
  ins = [list: 0, 1, 10, 100]
  for map(n from ins):
    num-floor(d-dx-sq(n))
  end
  is
  for map(n from ins):
    num-floor(dbl(n))
  end
end
```

现在，我们可以回到启动这次调查的原始示例：数学中混乱且神秘的符号真正试图表达的意思是，

```py
d-dx(lam(x): x * x end) = lam(x): 2 * x end
```

或者，在函数表示法的表示法中，

\begin{equation*}{\frac{d}{dx}} [x \rightarrow x²] = [x \rightarrow 2x]\end{equation*}

惜哉数学教科书不愿告诉我们真相！

#### 8.1.2 匿名函数的有用简写 "链接到此处")

Pyret 提供了一种更短的语法来编写匿名函数。虽然从风格上讲，我们通常避免使用它，以免我们的程序变成特殊字符的混乱，但有时它特别方便，如下所示。此语法是

```py
{(a): b}
```

其中`a`是零个或多个参数，`b`是主体。例如，我们可以将`lam(x): x * x end`写成

```py
{(x): x * x}
```

在这里，我们可以看到简洁性的好处。特别是，请注意没有必要使用`end`，因为花括号取代了显示表达式开始和结束的位置。同样，我们也可以将`d-dx`写成

```py
fun d-dx-short(f):
  {(x): (f(x + epsilon) - f(x)) / epsilon}
end
```

但许多读者会说这使函数更难阅读，因为突出的`lam`清楚地表明`d-dx`返回一个（匿名）函数，而此语法则掩盖了这一点。因此，我们通常只会为“一行代码”使用这种简写语法。

#### 8.1.3 从函数生成流 "链接到此处")

人们通常认为函数只有一个用途：参数化一个表达式。虽然这是真的，也是函数最常见的使用方式，但这并不能证明需要一个无参数的函数，因为那显然什么都没有参数化。然而，无参数的函数也有其用途，因为函数实际上有两个用途：参数化和延迟主体直到函数被应用时的评估。实际上，这两个用途是正交的，因为可以在不使用另一个的情况下使用一个特性。下面，我们将关注延迟而不抽象（另一个在其他计算机科学设置中出现）。

让我们考虑一下简单的列表。列表可以是有限的。然而，自然界中有许多没有自然上限的列表（或序列）：从数学对象（自然数的序列）到自然现象（网站访问的序列）。而不是试图将这些无界的列表压缩成有界的列表，让我们看看我们如何表示和编程这些无界列表。

首先，让我们编写一个程序来计算自然数的序列：

```py
fun nats-from(n):
  link(n, nats-from(n + 1))
end
```

> 现在就做！
> 
> > 这个程序有问题吗？

虽然这代表了我们的意图，但它不起作用：运行它——例如，`nats-from(0)`——会创建一个无限循环，对每个后续的自然数评估`nats-from`。换句话说，我们希望编写类似于上面的内容，但只有在需要时才重复，即按需。换句话说，我们希望列表的其余部分是惰性的。

这就是我们对函数的洞察力所在。正如我们刚才提到的，函数会延迟其主体的评估，直到它被应用。因此，原则上，函数将推迟`nats-from(n + 1)`的调用，直到需要时。

除了，这会创建一个类型问题：`link` 的第二个参数需要是一个列表，而不能是一个函数。确实，因为它必须是一个列表，并且每个已构建的值都必须是有限的，所以每个列表都是有限的，最终会在 `empty` 中终止。因此，我们需要一个新的数据结构来表示这些懒列表（也称为流）中的链接：

`<stream-type-def> ::=

```py
data Stream<T>:
  | lz-link(h :: T, t :: ( -> Stream<T>))
end
```

其中注释 `( -> Stream<T>)` 表示一个无参数的函数（因此 `->` 前面没有其他内容），也称为 thunk。请注意，我们定义的流必须是无限的，因为我们没有提供终止它们的方法。

让我们构建最简单的例子，一个常量值的流：

```py
ones = lz-link(1, lam(): ones end)
```

Pyret 实际上会对此定义提出抱怨。请注意，此列表等价物也不会工作：

```py
ones = link(1, ones)
```

因为 `ones` 在定义点没有定义，所以当 Pyret 计算 `link(1, ones)` 时，它会抱怨 `ones` 没有定义。然而，它对我们的前一个定义过于保守：`ones` 的使用是在 `lam` 下，因此只有在 `ones` 定义完成后才会需要，到那时 `ones` 将被定义。我们可以通过使用关键字 `rec` 来向 Pyret 表明这一点：

```py
rec ones = lz-link(1, lam(): ones end)
```

注意，在 Pyret 中，每个 `fun` 都隐式地有一个 `rec`，这就是为什么我们可以轻松地创建递归函数。

> 练习
> 
> > 之前我们说过，我们不能编写
> > 
> > ```py
> > ones = link(1, ones)
> > ```
> > 
> > 如果我们尝试编写
> > 
> > ```py
> > rec ones = link(1, ones)
> > ```
> > 
> > 这样做可以吗？如果可以，`ones` 绑定的是什么值？如果不行，它是否因为与没有 `rec` 的定义相同的原因而失败？

从此以后，我们将使用缩写 [匿名函数的有用缩写)]。因此，我们可以将上面的定义重写为：

```py
rec ones = lz-link(1, {(): ones})
```

注意 `{(): …}` 定义了一个无参数的匿名函数。你不能省略 `()`！如果你省略了，Pyret 会对你的程序的含义感到困惑。

因为函数是自动递归的，当我们编写一个创建流的函数时，我们不需要使用 `rec`。考虑以下示例：

```py
fun nats-from(n :: Number):
  lz-link(n, {(): nats-from(n + 1)})
end
```

我们可以用它来定义自然数：

```py
nats = nats-from(0)
```

注意，`nats` 的定义本身不是递归的——递归发生在 `nats-from` 内部——因此我们不需要使用 `rec` 来定义 `nats`。

> 现在就做！
> 
> > 之前，我们说过每个列表都是有限的，因此最终会终止。这个评论如何适用于流，例如上面 `ones` 或 `nats` 的定义？

`ones` 的描述仍然是一个有限的描述；它只是代表无限多个值的潜力。请注意：

1.  类似的推理不适用于列表，因为列表的其余部分已经构建完成；相比之下，在那里放置一个函数会创建大量潜在未完成的计算。

1.  话虽如此，即使在使用流的情况下，在任何给定的计算中，我们也将只创建流的一个有限前缀。然而，我们不必提前决定数量；每个客户端和使用者都可以根据需要提取更多或更少。

现在我们已经创建了多个流，但我们仍然没有一种简单的方法来“看到”一个。首先，我们将定义传统的类似列表的选择器。获取第一个元素与列表中的操作完全一样：

```py
fun lz-first<T>(s :: Stream<T>) -> T: s.h end
```

相反，当尝试访问流的其余部分时，我们从数据结构中得到的只是一个 thunk。要访问实际的其余部分，我们需要强制 thunk，这当然意味着将其应用于无参数：

```py
fun lz-rest<T>(s :: Stream<T>) -> Stream<T>: s.t() end
```

这对于检查流的单个值很有用。它还允许我们提取它（给定大小）的一个有限前缀作为（常规）列表，这对于测试特别有用。让我们编写这个函数：

```py
fun take<T>(n :: Number, s :: Stream<T>) -> List<T>:
  if n == 0:
    empty
  else:
    link(lz-first(s), take(n - 1, lz-rest(s)))
  end
end
```

如果你仔细观察，你会发现这个主体不是通过在（流）输入的结构上定义情况来定义的——相反，它是通过自然数（零或后继）的定义的情况来定义的。我们将在下面回到这个问题 (<lz-map2-def>)。

现在我们有了这个，我们可以用它来进行测试。请注意，通常我们使用我们的数据来测试我们的函数；这里，我们正在使用这个函数来测试我们的数据：

```py
check:
  take(10, ones) is map(lam(_): 1 end, range(0, 10))
  take(10, nats) is range(0, 10)
  take(10, nats-from(1)) is map((_ + 1), range(0, 10))
end
```

符号`(_ + 1)`定义了一个接受一个参数的 Pyret 函数，该函数将给定的参数加`1`。

让我们定义另一个函数：流的`map`的等效函数。由于很快就会变得明显的原因，我们将定义一个接受两个列表并将第一个参数逐点应用于它们的版本：

<lz-map2-def> ::=

```py
fun lz-map2<A, B, C>(
    f :: (A, B -> C),
    s1 :: Stream<A>,
    s2 :: Stream<B>) -> Stream<C>:
  lz-link(
    f(lz-first(s1), lz-first(s2)),
    {(): lz-map2(f, lz-rest(s1), lz-rest(s2))})
end
```

现在我们可以特别清楚地看到我们之前关于函数结构的评论。而传统的列表`map`有两个情况，这里我们只有一个情况，因为数据定义 (<stream-type-def>)只有一个情况！这有什么后果？在传统的`map`中，一个情况看起来像上面那样，但另一个情况对应于`empty`输入，它产生相同的输出。这里，因为流永远不会终止，所以映射它也不会终止，函数的结构反映了这一点。这引发了一个更微妙的问题：如果函数的主体没有基础和归纳情况，我们如何对它进行归纳证明？简短的答案是，我们不能：我们必须改用☛归纳归纳。

为什么我们定义了`lz-map2`而不是`lz-map`？因为它使我们能够编写以下内容：

```py
rec fibs =
  lz-link(0,
    {(): lz-link(1,
          {(): lz-map2({(a :: Number, b :: Number): a + b},
                fibs,
            lz-rest(fibs))})})
```

从中，当然，我们可以提取我们想要的任意多的斐波那契数！

```py
check:
  take(10, fibs) is [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
end
```

> 练习
> 
> > 定义流的`map`和`filter`的等效函数。

流和更一般地，按需展开的无限数据结构在编程中非常有价值。例如，考虑游戏中的可能移动。在某些游戏中，这可能无限；即使它是有限的，对于有趣的游戏，组合意味着树太大，无法实际存储在内存中。因此，计算机智能的程序员必须按需展开游戏树。通过使用我们上面描述的编码来编程意味着程序描述了整个树，惰性地，树按需自动展开，减轻了程序员实现这种策略的负担。

在某些语言中，例如 Haskell，惰性求值是默认内置的。在这种语言中，不需要使用 thunks。然而，惰性求值给语言带来了其他负担，你可以在编程语言课程中了解这些。

#### 8.1.4 组合力量：导数流 "链接至此")

当我们定义 `d-dx` 时，我们将 `epsilon` 设置为一个任意的高值。我们也可以将 `epsilon` 视为一个产生越来越精细值的流；然后，例如，当导数值的差异变得足够小，我们可以决定我们已经得到了导数的足够逼近。

因此，第一步是将 `epsilon` 变成一个参数，而不是一个全局常数。这留下了它应该是什么类型的参数（数字或流？）以及何时提供的问题。

在我们决定要微分哪个函数以及其导数在什么值时，消费这个参数最有意义；毕竟，`epsilon` 的流可能取决于这两个因素。因此，我们得到：

```py
fun d-dx(f :: (Number -> Number)) ->
    (Number -> (Number -> Number)):
  lam(x :: Number) -> (Number -> Number):
    lam(epsilon :: Number) -> Number:
      (f(x + epsilon) - f(x)) / epsilon
    end
  end
end
```

通过这个，我们可以回到我们的 `square` 例子：

```py
d-dx-square = d-dx(square)
```

注意，在这个时候，我们只是重新定义了 `d-dx`，而没有提及流：我们只是将一个常数变成了一个参数。

现在，让我们定义负十的幂的流：

```py
tenths = block:
  fun by-ten(d):
    new-denom = d / 10
    lz-link(new-denom, lam(): by-ten(new-denom) end)
  end
  by-ten(1)
end
```

以便

```py
check:
  take(3, tenths) is [list: 1/10, 1/100, 1/1000]
end
```

为了具体化，让我们选择一个横坐标来计算 `square` 的数值导数——比如说 `10`：

```py
d-dx-square-at-10 = d-dx-square(10)
```

从类型中回想起来，现在这是一个 `(Number -> Number)` 类型的函数：给定一个 `epsilon` 的值，它使用该值来计算导数。我们知道，从解析的角度来看，这个导数的值应该是 `20`。现在（惰性地）我们可以将 `tenths` 映射到提供越来越好的 `epsilon` 近似值，并看看会发生什么：

```py
lz-map(d-dx-square-at-10, tenths)
```

果然，我们得到的价值是 `20.1`，`20.01`，`20.001`，等等：对 `20` 的越来越好的数值逼近。

> 练习
> 
> > 将上述程序扩展以接受一个容差，并从 `epsilon` 流中提取尽可能多的值，直到导数的连续逼近之间的差异落在该容差内。
