# 12.2 理解相等🔗

> 原文：[`dcic-world.org/2025-08-27/unified-equality.html`](https://dcic-world.org/2025-08-27/unified-equality.html)

| |   12.2.1 数据的相等 |
| --- | --- |
| |   12.2.2 不同的相等操作 |
| |   12.2.2.1 Python 中的相等 |
| |   12.2.2.2 Pyret 中的相等 |

#### 12.2.1 数据的相等🔗 "链接至此")

现在我们有了修改数据的能力，值得思考两个数据相等意味着什么。我们将通过一个具体的例子来阐述这一点。遵循结构修改和目录的命名规范，我们将只写每个名称一次，使用 Python 的大写名称，但我们所写的一切对 Pyret 也同样适用。

首先，考虑以下三个陈述：

```py
a1 = Account(8603, 500)
a2 = Account(8603, 500)
a3 = Account(8603, 250)
```

> 现在行动！
> 
> > 你认为哪个以上的`Account`是“相等的”？

第三个`Account`的余额与前两个不同，因此不能认为它与前两个相等。前两个具有相同的内容，所以可以说它们可以被认为是相等的。

现在，让我们考虑运行这三个语句后产生的目录和堆：

目录

+   ```py
    a1
    ```

    → 1120

+   ```py
    a2
    ```

    → 1121

+   ```py
    a3
    ```

    → 1122

堆

+   1120:

    ```py
    Account(8603, 500)
    ```

+   1121:

    ```py
    Account(8603, 500)
    ```

+   1122:

    ```py
    Account(8603, 250)
    ```

从堆的角度来看，每个账户最终都会到达自己的地址。这些不同的地址是两个值不同的方式：它们有相同的内容，但没有相同的地址。这有什么相关吗？为了探索这一点，让我们将另一个名称（`a4`）与`a2`相同的地址关联起来，然后更改`a2`的余额。现在我们只展示 Python 版本：

```py
a1 = Account(8603, 500)
a2 = Account(8603, 500)
a3 = Account(8603, 250)
a4 = a2
# checkpoint 1
a2.balance = 800
# checkpoint 2
```

检查点 1 之前和之后内存看起来像什么？在检查点之前：

目录

+   ```py
    a1
    ```

    → 1130

+   ```py
    a2
    ```

    → 1131

+   ```py
    a3
    ```

    → 1132

+   ```py
    a4
    ```

    → 1131

堆

+   1130:

    ```py
    Account(8603, 500)
    ```

+   1131:

    ```py
    Account(8603, 500)
    ```

+   1132:

    ```py
    Account(8603, 250)
    ```

`a1`和`a2`指的是两个具有相同内容的`Account`。在检查点 1 之后，这些内容就不同了，因为我们修改了`a2`中余额字段的含量：

目录

+   ```py
    a1
    ```

    → 1130

+   ```py
    a2
    ```

    → 1131

+   ```py
    a3
    ```

    → 1132

+   ```py
    a4
    ```

    → 1131

堆

+   1130:

    ```py
    Account(8603, 500)
    ```

+   1131:

    ```py
    Account(8603, 800)
    ```

+   1132:

    ```py
    Account(8603, 250)
    ```

相比之下，`a2`和`a4`是同一`Account`的别名。因此，它们的值会同步变化：现在要求显示任何一个的值都会显示一个余额为`800`的账户。

> 现在行动！
> 
> > 你现在怎么想？前两个账户相等吗？

#### 12.2.2 不同的相等操作🔗 "链接至此")

这一系列的例子指出，我们似乎提出了两种可能的相等概念：

1.  两个值是否有相同的内容。这正式称为结构相等；你可以将其视为“打印相等”，即当显示时，两个值看起来是否相同。

1.  两个值是否位于同一地址，即内存中实际上只有一个值。这正式称为引用等价性。通常，我们会用不同的名称来引用这两个值（因此它们可能是不同的），引用等价性检查这些名称是否是别名。观察到一个给定的值总是以相同的方式打印，因此具有引用等价性的任何两个名称也具有结构等价性，但反之则不然。

哪种等价概念是“正确”的？实际上，它们在不同的上下文中都很有价值。因此，编程语言通常提供多种等价操作，让程序员能够表明他们在上下文中指的是哪种等价。

不幸的是，等价操作的名称及其确切含义在不同的语言中各不相同。因此，我们将分别检查 Pyret 和 Python。

##### 12.2.2.1 Pyret 中的等价性🔗 "链接到这里")

在 Pyret 和 Python 中你学到的 `==` 操作符检查结构等价性，与地址无关：

|

&#124;

> ```py
> a1 == a2
> ```

&#124;

|

|

```py
True
```

|

|

&#124;

> ```py
> a2 == a4
> ```

&#124;

|

|

```py
True
```

|

然而，请注意，在检查点 2 时这不再成立：

|

&#124;

> ```py
> a1 == a2
> ```

&#124;

|

|

```py
False
```

|

|

&#124;

> ```py
> a2 == a4
> ```

&#124;

|

|

```py
True
```

|

如果我们想检查别名，我们将使用一个名为 `is` 的操作（不要与 Pyret 的 `is` 混淆，后者用于编写测试）：

|

&#124;

> ```py
> a1 is a2
> ```

&#124;

|

|

```py
False
```

|

|

&#124;

> ```py
> a2 is a4
> ```

&#124;

|

|

```py
True
```

|

这解释了为什么 `a2 == a4` 在变异前后都为真，但 `a1 == a2` 在变异后不再为真。后者似乎违反了“等价”的基本含义；这里的问题是由于引入了变异。

随着我们继续前进，你将更多地练习何时使用每种类型的等价性。`==` 操作符更宽容，因此通常是正确的默认选项。如果你实际上需要知道两个表达式是否评估为同一地址，你应该使用 `is`。

##### 12.2.2.2 Pyret 中的等价性🔗 "链接到这里")

Pyret 中的等价性有些更详细，因为该语言希望你在程序中更深入地思考正在发生的事情。

回想一下，我们正在使用 示例：银行账户 中的数据类型，并编写了以下定义：

```py
a1 = account(8603, 500)
a2 = account(8603, 500)
a3 = account(8603, 250)
a4 = a2
# checkpoint 1
a2!{balance: 800}
# checkpoint 2 
```

在 Python 中，我们在变异之前看到了 `a1 == a2`。然而，在 Pyret 中，这会产生 `false`！为什么？

原因是结构等价性实际上很复杂；我们可以问两个不同的问题：

1.  这两个值现在在结构上相等吗？

1.  这两个值在结构上总是相等吗？

Pyret 在这两个之间做出了区分。

默认情况下，Pyret 倾向于更安全的编程实践。因此，标准的（结构）等价谓词 `==` 只有在这两个值始终相等时才会返回 `true`。因此：

|

&#124;

> ```py
> a2 == a4
> ```

&#124;

|

|

```py
true
```

|

> ```py
> a1 <=> a2
> ```

```py
false
```

> ```py
> a2 <=> a4
> ```

```py
true
```

> ```py
> a1 == a2
> ```

```py
false
```

> ```py
> a1 =~ a2
> ```

```py
true
```

> ```py
> a1 =~ a2
> ```

```py
false
```

> ```py
> equal-now(a1, a2)
> ```

```py
true
```

> ```py
> equal-now(a2, a4)
> ```

```py
true
```

> ```py
> equal-always(a1, a2)
> ```

```py
false
```

> ```py
> equal-always(a2, a4)
> ```

```py
true
```

> ```py
> identical(a1, a2)
> ```

```py
false
```

> ```py
> identical(a2, a4)
> ```

```py
true
```

> ```py
> equal-now(a1, a2)
> ```

```py
false
```

> ```py
> equal-now(a2, a4)
> ```

```py
true
```

值得注意的是，到目前为止，我们一直使用`equal-always`—<wbr>在测试中既使用`==`也使用 Pyret 的`is`—<wbr>而没有真正去理解它是如何工作的，但我们总是得到了可预测的答案。这表明与不可变数据一起工作有一些自然之处。相比之下，在使用可变数据时，必须有所妥协。Pyret 有意识地做出了设计选择，通过`equal-always`和`equal-now`之间的区别来反映这一点。Python 做出了不同的选择，这导致“相等”具有可能令人惊讶的含义。（Python 没有`equal-always`的概念，只有`equal-now`或`=~`，它写成`==`，以及`identical`或`<=>`，它写成`is`。）

#### 12.2.1 数据的相等性🔗 "链接到这里")

现在我们有了修改数据的能力，值得探讨两个数据片段相等意味着什么。我们将通过一个具体的例子来阐述这一点。遵循结构修改和目录的命名惯例，我们将只写每个名称一次，使用 Python 的大写名称，但我们所写的一切对 Pyret 同样适用。

首先，考虑以下三个语句：

```py
a1 = Account(8603, 500)
a2 = Account(8603, 500)
a3 = Account(8603, 250)
```

> 现在行动！
> 
> > 你认为上述哪个`Account`是“相等”的？

第三个`Account`的余额与前两个不同，因此不能认为它与前两个相等。前两个内容相同，所以可以说它们可以被认为是相等的。

现在，让我们考虑运行这三个语句后产生的目录和堆：

目录

+   ```py
    a1
    ```

    → 1120

+   ```py
    a2
    ```

    → 1121

+   ```py
    a3
    ```

    → 1122

堆

+   1120:

    ```py
    Account(8603, 500)
    ```

+   1121:

    ```py
    Account(8603, 500)
    ```

+   1122:

    ```py
    Account(8603, 250)
    ```

从堆的角度来看，每个账户最终都会到达自己的地址。这些不同的地址是两个值不相同的一种方式：它们有相同的内容，但没有相同的地址。这有什么相关吗？为了探索这一点，让我们将另一个名称（`a4`）与`a2`相同的地址关联起来，然后修改`a2`中的余额。现在我们只展示 Python 版本：

```py
a1 = Account(8603, 500)
a2 = Account(8603, 500)
a3 = Account(8603, 250)
a4 = a2
# checkpoint 1
a2.balance = 800
# checkpoint 2
```

在检查点 1 之前和之后的记忆是什么样的？在检查点之前：

目录

+   ```py
    a1
    ```

    → 1130

+   ```py
    a2
    ```

    → 1131

+   ```py
    a3
    ```

    → 1132

+   ```py
    a4
    ```

    → 1131

堆

+   1130:

    ```py
    Account(8603, 500)
    ```

+   1131:

    ```py
    Account(8603, 500)
    ```

+   1132:

    ```py
    Account(8603, 250)
    ```

`a1`和`a2`指的是两个内容相同的不同`Account`。在检查点 1 之后，这些内容变得不同，因为我们修改了`a2`中余额字段的值：

目录

+   ```py
    a1
    ```

    → 1130

+   ```py
    a2
    ```

    → 1131

+   ```py
    a3
    ```

    → 1132

+   ```py
    a4
    ```

    → 1131

堆

+   1130:

    ```py
    Account(8603, 500)
    ```

+   1131:

    ```py
    Account(8603, 800)
    ```

+   1132:

    ```py
    Account(8603, 250)
    ```

相比之下，`a2`和`a4`是同一`Account`的别名。因此，它们的值会同步变化：现在要求显示任一账户的值将显示一个余额为`800`的账户。

> 现在行动！
> 
> > 你现在怎么想？前两个账户相等吗？

#### 12.2.2 不同的相等性操作🔗 "链接到这里")

这一系列的例子指出，我们似乎提出了两种可能的相等性概念：

1.  两个值是否具有相同的内容。这正式称为结构等价性；你可以将其视为“打印等价性”，即当显示时，这两个值看起来是否相同。

1.  两个值是否位于同一地址，即内存中实际上只有一个值。这正式称为引用等价性。通常，我们会用不同的名称来引用这两个值（因此它们可能是不同的），引用等价性检查这些名称是否是别名。观察到一个给定的值总是以相同的方式打印，所以任何具有引用等价性的两个名称也具有结构等价性，但反之则不然。

哪种等价性的概念是“正确的”？实际上，它们在不同的上下文中都很有价值。因此，编程语言通常提供多个等价性操作，让程序员能够表明他们在上下文中指的是哪种等价性。

不幸的是，等价性操作的名称及其确切含义在不同的语言中各不相同。因此，我们将分别检查 Pyret 和 Python。

##### 12.2.2.1 Python 中的等价性🔗 "链接至此")

你在 Pyret 和 Python 中学到的`==`运算符检查结构等价性，与地址无关：

|

&#124;

> ```py
> a1 == a2
> ```

&#124;

|

|

```py
True
```

|

|

&#124;

> ```py
> a2 == a4
> ```

&#124;

|

|

```py
True
```

|

然而，请注意，在检查点 2 时这将不再成立：

|

&#124;

> ```py
> a1 == a2
> ```

&#124;

|

|

```py
False
```

|

|

&#124;

> ```py
> a2 == a4
> ```

&#124;

|

|

```py
True
```

|

如果我们想检查别名，我们则使用一个称为`is`的操作（不要与 Pyret 的`is`混淆，它用于编写测试）：

|

&#124;

> ```py
> a1 is a2
> ```

&#124;

|

|

```py
False
```

|

|

&#124;

> ```py
> a2 is a4
> ```

&#124;

|

|

```py
True
```

|

这解释了为什么在变异前后`a2 == a4`都是真的，但变异后`a1 == a2`不再成立。后者似乎违反了“等价性”的非常基本的意义；这里的问题是引入变异所导致的。

随着我们继续前进，你将获得更多练习何时使用每种等价性的经验。`==`运算符更宽容，因此通常是正确的默认选项。如果你实际上需要知道两个表达式是否评估为相同的地址，你应该使用`is`。

##### 12.2.2.2 Pyret 中的等价性🔗 "链接至此")

Pyret 中的等价性相对更详细，因为该语言希望你在程序中更深入地思考正在发生的事情。

回想一下，我们在示例：银行账户中使用数据类型，并编写了以下定义：

```py
a1 = account(8603, 500)
a2 = account(8603, 500)
a3 = account(8603, 250)
a4 = a2
# checkpoint 1
a2!{balance: 800}
# checkpoint 2 
```

在 Python 中，我们在变异前看到了`a1 == a2`。然而，在 Pyret 中，这会产生`false`！为什么？

原因在于结构等价性实际上很复杂；我们可能提出两个不同的问题：

1.  这两个值现在在结构上等价吗？

1.  这两个值是否始终在结构上等价？

Pyret 在这两点上做出了区分。

默认情况下，Pyret 倾向于更安全的编程实践。因此，标准的（结构）等价谓词`==`只有在两个值将始终相等的情况下才会返回`true`。因此：

|

&#124;

> ```py
> a2 == a4
> ```

&#124;

|

|

```py
true
```

|

因为这两个值实际上是别名，无论其中一个如何变化，另一个也会以相同的方式变化。因此，它们将始终“打印出相同的值”。我们可以通过使用 Pyret 的引用等价运算符`<=>`来确认它们是别名：

|

&#124;

> ```py
> a1 <=> a2
> ```

&#124;

|

|

```py
false
```

|

|

&#124;

> ```py
> a2 <=> a4
> ```

&#124;

|

|

```py
true
```

|

相比之下，这个保证并不适用于`a1`和`a2`；实际上，在检查点 2 时，我们看到它们不再相等。因此

|

&#124;

> ```py
> a1 == a2
> ```

&#124;

|

|

```py
false
```

|

然而，存在一个时刻`a1`和`a2`确实会打印出相同的值，那就是在检查点 1 之前。因此，Pyret 提供了一个额外的等价运算符，用于检查值在当前时刻是否相等，即`=~`。如果我们在这个检查点之前进行询问，我们会得到：

|

&#124;

> ```py
> a1 =~ a2
> ```

&#124;

|

|

```py
true
```

|

但如果我们在这个检查点 2 时提出相同的问题，我们会得到：

|

&#124;

> ```py
> a1 =~ a2
> ```

&#124;

|

|

```py
false
```

|

这些运算符及其有趣的符号可能难以记住，但 Pyret 也给了它们有用的（如果更长）名称，并且它们可以用作普通函数：

| 符号 |  | 函数 |  | 类型 |  | 含义 |
| --- | --- | --- | --- | --- | --- | --- |
| `==` |  | `equal-always` |  | 结构 |  | 如果它返回`true`，它们将始终相等，无论未来的变异如何。 |
| `=~` |  | `equal-now` |  | 结构 |  | 如果它返回`true`，它们目前是相等的，但之后可能会因为未来的变异而改变。 |
| `<=>` |  | `identical` |  | 引用 |  | 如果两个参数是别名，则返回`true`，否则返回`false`。 |

因此，在检查点 1 之前：

|

&#124;

> ```py
> equal-now(a1, a2)
> ```

&#124;

|

|

```py
true
```

|

|

&#124;

> ```py
> equal-now(a2, a4)
> ```

&#124;

|

|

```py
true
```

|

|

&#124;

> ```py
> equal-always(a1, a2)
> ```

&#124;

|

|

```py
false
```

|

|

&#124;

> ```py
> equal-always(a2, a4)
> ```

&#124;

|

|

```py
true
```

|

|

&#124;

> ```py
> identical(a1, a2)
> ```

&#124;

|

|

```py
false
```

|

|

&#124;

> ```py
> identical(a2, a4)
> ```

&#124;

|

|

```py
true
```

|

在检查点 2 之后，我们不再需要再次检查任何`equal-always`或`identical`关系，因为根据定义，它们不能改变。但我们应该再次检查`equal-now`。果然：

|

&#124;

> ```py
> equal-now(a1, a2)
> ```

&#124;

|

|

```py
false
```

|

|

&#124;

> ```py
> equal-now(a2, a4)
> ```

&#124;

|

|

```py
true
```

|

因此，在 Pyret 中，`==`运算符与`equal-always`相同。当数据包含可变字段时，这总是会生成`false`，因为即使值现在在结构上相等，未来的变异也可能改变这一点。这是提醒你在存在变异的情况下要小心。在真正只关心那一刻的等价性的情况下，我们可以使用`=~`，即`equal-now`。

上述示例可能会让人误以为只有别名值才是`equal-always`。这并不正确！如果我们的数据是不可变的（在语言中这是默认设置），那么如果两个值现在在结构上相等，它们必须永远在结构上相等。对于此类数据，即使它们不是别名，`equal-always`也会返回`true`。这是提醒我们关于不可变数据可以得到更强的保证。

值得注意的是，到目前为止，我们一直在使用 `equal-always`——以 `==` 和 Pyret 的 `is`（在测试中使用）的形式——而没有真正去理解它是如何工作的，但我们总是得到了可预测的答案。这表明与不可变数据一起工作有一些自然之处。相比之下，与可变数据一起，必须做出一些妥协。Pyret 有意识地做出了设计选择，在 `equal-always` 和 `equal-now` 之间做出区分。Python 做了不同的选择，这导致“等价性”具有可能令人惊讶的含义。（Python 没有关于 `equal-always` 的概念，只有 `equal-now` 或 `=~`（写作 `==`）和 `identical` 或 `<=>`（写作 `is`）。）

##### 12.2.2.1 Python 中的等价性🔗 "链接至此")

你在 Pyret 中学到的 `==` 操作符以及我们带入 Python 的操作符检查结构等价性，而不考虑地址：

|

&#124;

> ```py
> a1 == a2
> ```

&#124;

|

|

```py
True
```

|

|

&#124;

> ```py
> a2 == a4
> ```

&#124;

|

|

```py
True
```

|

然而，请注意，这将在检查点 2 时不再成立：

|

&#124;

> ```py
> a1 == a2
> ```

&#124;

|

|

```py
False
```

|

|

&#124;

> ```py
> a2 == a4
> ```

&#124;

|

|

```py
True
```

|

如果我们想要检查别名（aliasing），则可以使用一个名为 `is` 的操作（不要与 Pyret 的 `is` 混淆，后者用于编写测试）：

|

&#124;

> ```py
> a1 is a2
> ```

&#124;

|

|

```py
False
```

|

|

&#124;

> ```py
> a2 is a4
> ```

&#124;

|

|

```py
True
```

|

这解释了为什么在变异前后 `a2 == a4` 都是正确的，但 `a1 == a2` 在变异后不再正确。后者似乎违反了“等价性”的基本含义；这里的问题是由变异的引入造成的。

随着我们继续前进，你将更多地练习何时使用每种类型的等价性。`==` 操作符更宽容，因此通常是正确的默认选项。如果你实际上需要知道两个表达式是否评估为相同的地址，你应该使用 `is`。

##### 12.2.2.2 Pyret 中的等价性🔗 "链接至此")

Pyret 中的等价性（Equality）相对更详细，因为这种语言希望你在程序中更深入地思考正在发生的事情。

回想一下，我们正在使用 示例：银行账户 中的数据类型，并编写了以下定义：

```py
a1 = account(8603, 500)
a2 = account(8603, 500)
a3 = account(8603, 250)
a4 = a2
# checkpoint 1
a2!{balance: 800}
# checkpoint 2 
```

在 Python 中，我们在变异之前看到了 `a1 == a2`。然而，在 Pyret 中，这会产生 `false`！为什么？

原因在于结构等价性实际上很复杂；我们可能提出了两个不同的问题：

1.  这些两个值在当前是否在结构上相等？

1.  这两个值在结构上是否总是相等？

Pyret 在这两个方面做出了区分。

默认情况下，Pyret 倾向于更安全的编程实践。因此，标准的（结构性的）等价性谓词 `==` 只有在两个值始终相等时才会返回 `true`。因此：

|

&#124;

> ```py
> a2 == a4
> ```

&#124;

|

|

```py
true
```

|

因为这两个值实际上是别名，无论怎样变化，另一个值总会以相同的方式变化。因此，它们将始终“打印出相同的”。我们可以通过使用 Pyret 的引用相等操作符 `<=>` 来确认它们是别名：

|

&#124;

> ```py
> a1 <=> a2
> ```

&#124;

|

|

```py
false
```

|

|

&#124;

> ```py
> a2 <=> a4
> ```

&#124;

|

|

```py
true
```

|

与此相反，这个保证不适用于 `a1` 和 `a2`；实际上，在检查点 2 时，我们看到它们不再相等。因此

|

&#124;

> ```py
> a1 == a2
> ```

&#124;

|

|

```py
false
```

|

然而，当 `a1` 和 `a2` 打印出相同的内容时，有一个时刻，即在检查点 1 之前。因此，Pyret 提供了另一个相等操作符，用于检查值在那一刻是否相等，即 `=~`。如果我们在此之前提出这个问题，我们会得到：

|

&#124;

> ```py
> a1 =~ a2
> ```

&#124;

|

|

```py
true
```

|

但如果我们检查点 2 时提出相同的问题，我们会得到：

|

&#124;

> ```py
> a1 =~ a2
> ```

&#124;

|

|

```py
false
```

|

这些操作符及其有趣的符号可能难以记住，但 Pyret 也提供了它们有用的（如果更长）名称，并且它们可以用作普通函数：

| 符号 |  | 函数 |  | 类型 |  | 含义 |
| --- | --- | --- | --- | --- | --- | --- |
| `==` |  | `equal-always` |  | 结构性 |  | 如果返回 `true`，它们将始终相等，无论未来的任何变异。 |
| `=~` |  | `equal-now` |  | 结构性 |  | 如果返回 `true`，它们目前相等，但未来的变异可能会改变这一点。 |
| `<=>` |  | `identical` |  | 引用 |  | 如果两个参数是别名，则返回 `true`，否则返回 `false`。 |

因此，在检查点 1 之前：

|

&#124;

> ```py
> equal-now(a1, a2)
> ```

&#124;

|

|

```py
true
```

|

|

&#124;

> ```py
> equal-now(a2, a4)
> ```

&#124;

|

|

```py
true
```

|

|

&#124;

> ```py
> equal-always(a1, a2)
> ```

&#124;

|

|

```py
false
```

|

|

&#124;

> ```py
> equal-always(a2, a4)
> ```

&#124;

|

|

```py
true
```

|

|

&#124;

> ```py
> identical(a1, a2)
> ```

&#124;

|

|

```py
false
```

|

|

&#124;

> ```py
> identical(a2, a4)
> ```

&#124;

|

|

```py
true
```

|

在检查点 2 之后，我们不再需要再次检查任何 `equal-always` 或 `identical` 关系，因为根据定义，它们不能改变。但我们应该再次检查 `equal-now`。果然：

|

&#124;

> ```py
> equal-now(a1, a2)
> ```

&#124;

|

|

```py
false
```

|

|

&#124;

> ```py
> equal-now(a2, a4)
> ```

&#124;

|

|

```py
true
```

|

因此，在 Pyret 中，`==` 操作符与 `equal-always` 相同。当数据包含可变字段时，这总会产生 `false`，因为即使现在在结构上相等，未来的变异也可能改变这一点。这是为了提醒你在存在变异的情况下要小心。在真正只关心那一刻相等性的情况下，我们可以使用 `=~`，即 `equal-now`。

上述示例可能表明只有别名值是 `equal-always`。这并不正确！如果我们的数据是不可变的（这是语言中的默认设置），那么如果两个值现在在结构上相等，它们必须永远在结构上相等。对于此类数据，即使它们不是别名，`equal-always` 也会返回 `true`。这是一个提醒，我们关于不可变数据可以得到更强的保证。

值得注意的是，到目前为止，我们在测试中一直使用`equal-always`——<wbr>无论是使用`==`还是 Pyret 的`is`——<wbr>并没有真正去深入了解它是如何工作的，然而我们总是得到了可预测的答案。这表明，在处理不可变数据时，存在某种自然性。相比之下，在处理可变数据时，必须有所妥协。Pyret 有意识地做出了设计选择，通过在`equal-always`和`equal-now`之间的区别来反映这一点。Python 做出了不同的选择，这导致“相等”具有可能令人惊讶的含义。（Python 没有`equal-always`的概念，只有`equal-now`或`=~`，它被写作`==`，以及`identical`或`<=>`，它被写作`is`。）
