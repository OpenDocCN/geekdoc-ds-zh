# 8.3 示例、测试和程序检查

> 原文：[`dcic-world.org/2025-08-27/testing.html`](https://dcic-world.org/2025-08-27/testing.html)

| |   8.3.1 从示例到测试 |
| --- | --- |
| |   8.3.2 更精细的比较 |
| |   8.3.3 测试失败时 |
| |   8.3.4 测试的预言者 |

在使用示例文档化函数中，我们开始培养你编写函数具体示例的习惯。在任务计划中，我们展示了如何开发中间值的示例，以帮助你规划要编写的代码。正如这些示例所示，记录示例有许多方法。我们可以在黑板上、纸上，甚至作为计算机文档中的注释来编写它们。这些都是合理的方法，实际上，往往是开始解决问题的最佳方式。然而，如果我们能以计算机能理解的确切形式编写示例，我们就能实现两个目标：

+   当我们完成所谓的解决方案的编写后，我们可以让计算机检查我们是否正确。

+   在写下我们的期望的过程中，我们常常发现很难用计算机期望的精确度来表达。有时这是因为我们仍在制定细节，还没有确定下来，但有时是因为我们还不理解问题。在这种情况下，精确的力量实际上对我们有益，因为它帮助我们理解我们理解的弱点。

#### 8.3.1 从示例到测试 "链接到此处")

到目前为止，我们为了两个目的在`where:`块中编写示例：帮助我们弄清楚函数需要做什么，并为阅读我们代码的人提供指导，告诉他们使用我们的函数时可以期待的行为。对于我们现在编写的较小程序，基于`where`的示例已经足够了。然而，随着我们的程序变得更加复杂，一组相关的说明性示例就不够了。我们需要考虑在考虑的输入集合上更加彻底。

例如，考虑一个`count-uses`函数，它计算特定字符串在列表中出现的次数（这可以用来统计选票、计算使用折扣代码的频率等）。在使用我们的函数进行实际选举或商业活动之前，我们需要检查哪些输入场景？

+   对于列表中仅出现一次的字符串的结果

+   对于列表中多次出现的字符串的结果

+   对于列表末尾的较长的字符串的结果（以确保我们检查了所有元素）

+   对于不在列表中的字符串的结果

+   对于列表中但大小写不同的字符串的结果

+   对于列表中与单词拼写有误的字符串的结果

注意，在这里我们正在考虑许多更多的情况，包括相当微妙的那些，这些情况会影响我们的代码在现实情况下的鲁棒性。一旦我们开始考虑这些情况，我们就从用示例来说明我们的代码转向彻底测试我们的代码。

在 Pyret 中，我们使用函数定义内的`where`块作为示例。我们使用函数定义外的`check`块进行测试。例如：

```py
fun count-uses(of-string :: String, in-list :: List<String>) -> Number:
  ...
where:
  count-uses("pepper", [list:]) is 0
  count-uses("pepper", [list: "onion"]) is 0
  count-uses("pepper", [list: "pepper", "onion"]) is 1
  count-uses("pepper", [list: "pepper", "pepper", "onion"]) is 2
end

check:
  count-uses("ppper", [list: "pepper"]) is 0
  count-uses("ONION", [list: "pepper", "onion"]) is 1
  count-uses("tomato",
    [list: "pepper", "onion", "onion", "pepper", "tomato",
      "tomato", "onion", "tomato"])
    is 3
  ...
end
```

作为一条指导原则，我们将有助于他人阅读我们代码的示例案例放入`where`块中，而将我们代码处理的更广泛的使用场景（包括错误情况）的繁琐检查放入`check`块中。有时，这两者之间的界限并不清晰：例如，有人可能会很容易地争论第二个测试（函数处理不同的首字母大小写）应该放在`where`块中。然而，关于使用非常长的列表的第三个测试仍然会保留在`check`块中，因为较长的输入通常对阅读你代码的读者来说不具有指导意义。

将测试放在函数外部独立存在的块中，在专业编程层面还有一个优势：它允许你的测试与代码存储在不同的文件中。这有两个关键的好处。首先，它使得其他人阅读你代码的核心部分变得更加容易（如果他们是在基于你的工作构建）。其次，它使得控制何时运行测试变得更加容易。当你的`check`块与代码位于同一文件中时，当你运行代码时，所有测试都会被执行。当它们位于不同的文件中时，组织可以自行选择何时运行测试。在开发过程中，为了确保没有引入错误，测试会频繁运行。一旦代码经过测试并准备好部署或使用，测试就不会与程序一起运行（除非有修改或有人发现了代码中的错误）。这是软件项目中的标准做法。

值得注意的是，在整个开发过程中，测试集合的增长速度超过了示例集合。在你开发代码的过程中，每次你发现代码中的错误，就在你的`check`块中为它添加一个测试，这样你就不太可能后来再次引入相同的错误。而我们在确定程序要做什么时，会提前开发示例，而我们的测试则是随着我们了解程序实际做什么（以及可能不应该做什么）而增强。在实践中，开发者会在编写代码之前和编写代码的过程中，针对他们想到的场景编写一组初始的检查，然后随着他们尝试更多场景并获得报告代码不工作的用户，扩展这些测试。

几乎所有编程语言都提供了一些结构或包，可以在单独的文件中编写测试。Pyret 的独特之处在于支持示例和测试之间的区别（既适用于学习，也适用于他人阅读代码的可读性）。许多支持专业人士的编程工具都期望你将所有测试放在单独的文件夹和文件中（不提供对示例的支持）。在这本书中，我们强调编程中输入输出对这两种用途之间的区别，因为我们发现它们在专业和教学方面都非常有用。

#### 8.3.2 更精细的比较 "链接到此处")

有时候，通过`is`进行的直接比较不足以进行测试。我们已经在`raises`测试的例子中看到了这一点（从家谱表中计算遗传父母）。作为另一个例子，在进行一些计算，尤其是涉及近似数学的计算时，`is`的精确匹配是不切实际的。例如，考虑以下对`distance-to-origin`的测试：

```py
check:
  distance-to-origin(point(1, 1)) is ???
end
```

我们在这里可以检查什么？将此输入到 REPL 中，我们可以发现答案打印为`1.4142135623730951`。这是真实答案的近似值，Pyret 无法精确表示。但很难知道这个精确答案，到小数点后这么多位，是我们一开始就应该预期的，而且通过思考答案应该是我们首先做的事情！

由于我们知道我们得到的是一个近似值，我们实际上只能检查答案是否大致正确，而不是完全正确。如果我们能检查`distance-to-origin(point(1, 1))`的答案大约是，比如说，`1.41`，并且可以对一些类似的情况做同样的检查，那么这很可能对许多应用以及我们的目的来说已经足够好了。如果我们正在计算轨道动力学，我们可能会要求更高的精度，但请注意，我们仍然需要选择一个截止值！测试不精确的结果是一个必要的任务。

让我们首先用我们能够的最精确的方式定义“大约”的含义，即通过一个函数：

```py
fun around(actual :: Number, expected :: Number) -> Boolean:
  doc: "Return whether actual is within 0.01 of expected"
  num-abs(actual - expected) < 0.01
where:
  around(5, 5.01) is true
  around(5.01, 5) is true
  around(5.02, 5) is false
  around(num-sqrt(2), 1.41) is true
end
```

现在的`is`形式对我们有所帮助。有一种特殊的语法可以用来提供一个用户定义的函数来比较两个值，而不是仅仅检查它们是否相等：

```py
check:
  5 is%(around) 5.01
  num-sqrt(2) is%(around) 1.41
  distance-to-origin(point(1, 1)) is%(around) 1.41
end
```

在`is`之后添加`%(something)`会改变`is`的行为。通常，它会比较左右两边的值是否相等。然而，如果提供了`%`，它就会将左右两边的值传递给提供的函数（在这个例子中是`around`）。如果提供的函数产生`true`，则测试通过，如果产生`false`，则测试失败。这给了我们测试具有可预测近似结果的函数所需的控制。

> 练习
> 
> > 扩展`distance-to-origin`的定义，包括极坐标点。
> > 
> 练习
> 
> > 这可能可以节省你一次谷歌搜索：[极坐标转换](http://en.wikipedia.org/wiki/Polar_coordinate_system#Converting_between_polar_and_Cartesian_coordinates)。使用设计食谱编写 `x-component` 和 `y-component` 函数，它们返回点的 `x` 和 `y` 坐标部分（例如，如果你要在图上绘制它们的话）。在[Pyret 数字文档](http://www.pyret.org/docs/latest/numbers.html)中了解 `num-sin` 和其他你需要使用的函数。
> > 
> 练习
> 
> > 编写一个名为 `Pay` 的数据定义，用于支付类型，包括按小时支付的员工，其支付类型包括小时工资，以及年薪员工，其支付类型包括一年的总工资。使用设计食谱编写一个名为 `expected-weekly-wages` 的函数，它接受一个 `Pay` 参数，并返回预期的每周工资：按小时支付的员工的预期每周工资假设他们工作 40 小时，而年薪员工的预期每周工资是他们年薪的 1/52。

#### 8.3.3 当测试失败 "链接到这里")

假设我们编写了一个名为 `sqrt` 的函数，该函数计算给定数字的平方根。我们为这个函数编写了一些测试。我们运行程序，发现一个测试失败了。有两个明显的理由可能导致这种情况发生。

> 现在就做！
> 
> > 有两个明显的理由吗？

当然，两个原因是测试的两个“方面”：问题可能出在我们写的值上，也可能出在我们写的函数上。例如，如果我们写了

```py
sqrt(4) is 1.75
```

然后，很明显错误出在我们写的值上（因为 \(1.75²\) 明显不是 \(4\)）。另一方面，如果它未能通过测试

```py
sqrt(4) is 2
```

然后，很可能是我们在 `sqrt` 的定义中犯了错误，这是我们需要修复的。

注意，计算机无法知道出了什么问题。当它报告测试失败时，它只是在说程序和测试之间存在不一致。计算机不会对哪个是“正确的”做出判断，因为它做不到。这是一个需要人类判断的问题。因此，我们一直在研究[测试同行评审](http://cs.brown.edu/~sk/Publications/Papers/Published/pkf-ifpr-tests-tf-prog/)，以便学生在开始编写程序之前互相帮助审查他们的测试。

实际上...并不那么快。还有一个我们没有考虑的可能性：第三个不那么明显的理由，那就是测试可能失败的原因。回到这个测试：

```py
sqrt(4) is 2
```

显然输入和输出都是正确的，但可能是 `sqrt` 的定义也是正确的，但测试却失败了。

> 现在就做！
> 
> > 你看懂了吗？

根据我们如何编程`sqrt`，它可能返回`-2`而不是`2`。现在`-2`也是一个完美的答案。也就是说，函数以及我们指定的特定测试值集本身并没有错误；只是函数碰巧是一个关系，即它将一个输入映射到多个输出（即\(\sqrt{4} = \pm 2\))。现在的问题是，如何正确编写测试。

#### 8.3.4 测试的预言者 "链接到此处")

换句话说，有时我们想要表达的不是具体的输入输出对，而是检查输出与输入之间是否有正确的关系。具体来说，在`sqrt`的情况下，这可能是怎样的？我们之前在说`1.75`显然不可能是正确的，因为平方它不会得到`4`时，已经暗示了这一点。这给了我们一般的洞察：一个数是有效的根（注意使用“a”而不是“the”），如果平方它得到原始数字。也就是说，我们可能编写一个像这样的函数：

```py
fun is-sqrt(n):
  n-root = sqrt(n)
  n == (n-root * n-root)
end
```

然后我们的测试看起来是这样的

```py
check:
  is-sqrt(4) is true
end
```

不幸的是，这有一个尴尬的失败案例。如果`sqrt`没有产生实际上是一个根的数字，我们不会被告知实际值是什么；相反，`is-sqrt`返回 false，测试失败只是说`false`（`is-sqrt`返回的）不是`true`（测试期望的）——<wbr>这既是绝对正确的，也是毫无用处的。

幸运的是，Pyret 有更好的方式来表达相同的检查。我们不需要使用`is`，而是可以写`satisfies`，然后左边的值必须满足右边的谓词。具体来说，这看起来是这样的：

```py
fun check-sqrt(n):
  lam(n-root):
    n == (n-root * n-root)
  end
end
```

这让我们可以写出：

```py
check:
  sqrt(4) satisfies check-sqrt(4)
end
```

现在，如果出现失败，我们会了解到`sqrt(4)`未能满足谓词的实际值。

#### 8.3.1 从示例到测试 "链接到此处")

到目前为止，我们已经在`where:`块中编写了示例，用于两个目的：帮助我们弄清楚函数需要做什么，并为阅读我们代码的人提供指导，告诉他们在使用我们的函数时可以期待什么行为。对于到目前为止我们编写的较小程序，基于`where`的示例已经足够了。然而，随着我们的程序变得更加复杂，一组相关说明性示例就不够了。我们需要考虑在考虑输入集时更加彻底。

例如，考虑一个`count-uses`函数，它计算一个特定字符串在列表中出现的次数（这可以用来统计选票，计算使用折扣代码的频率等等）。在使用我们的函数进行实际选举或商业活动之前，我们需要检查哪些输入场景？

+   列表中只出现一次的字符串的结果

+   列表中多次出现的字符串的结果

+   对于位于较长列表末尾的字符串的结果（以确保我们检查了所有元素）

+   不在列表中的字符串的结果

+   当字符串在列表中但大小写不同时的结果

+   当字符串与列表中的单词只有一个拼写错误时的结果

注意，这里我们考虑了许多更多的情况，包括相当微妙的那些，这些情况会影响我们的代码在现实情况下的鲁棒性。一旦我们开始考虑这些情况，我们就从用示例来说明我们的代码转向彻底测试我们的代码。

在 Pyret 中，我们使用函数定义内的 `where` 块作为示例。我们使用函数定义外的 `check` 块进行测试。例如：

```py
fun count-uses(of-string :: String, in-list :: List<String>) -> Number:
  ...
where:
  count-uses("pepper", [list:]) is 0
  count-uses("pepper", [list: "onion"]) is 0
  count-uses("pepper", [list: "pepper", "onion"]) is 1
  count-uses("pepper", [list: "pepper", "pepper", "onion"]) is 2
end

check:
  count-uses("ppper", [list: "pepper"]) is 0
  count-uses("ONION", [list: "pepper", "onion"]) is 1
  count-uses("tomato",
    [list: "pepper", "onion", "onion", "pepper", "tomato",
      "tomato", "onion", "tomato"])
    is 3
  ...
end
```

作为指导原则，我们将有助于其他人阅读我们代码的示例案例放入 `where` 块，而将我们代码处理的更广泛的用法场景（包括错误情况）的繁琐检查放入 `check`。有时，这两者之间的界限并不清晰：例如，有人可能会很容易地争论第二个测试（函数处理不同的大小写）应该放在 `where` 中。然而，关于使用非常长的列表的第三个测试将保留在 `check` 中，因为较长的输入通常对阅读你代码的人不具有指导意义。

将测试放在函数外部的块中，在专业编程层面上还有一个优点：它允许你的测试与代码存储在不同的文件中。这有两个关键的好处。首先，它使得其他人更容易阅读你代码的关键部分（如果他们正在基于你的工作构建）。其次，它使得控制测试运行的时间更容易。当你的 `check` 块与代码在同一文件中时，当你运行代码时，所有测试都会被检查。当它们在不同的文件中时，组织可以决定何时运行测试。在开发过程中，频繁运行测试以确保没有引入错误。一旦代码经过测试并准备好部署或使用，就不会与程序一起运行测试（除非有修改或有人发现代码中的错误）。这是软件项目中的标准做法。

值得注意的是，在整个开发过程中，测试集合的增长速度超过了示例集合。当你开发代码时，每次你在代码中发现错误，就在你的 `check` 块中为它添加一个测试，这样你就不太可能再次意外地引入相同的错误。而我们在确定程序要做什么时，会提前开发示例，但随着我们了解程序实际做什么（以及可能不应该做什么），我们会增强我们的测试。在实践中，开发者会在编写代码之前和编写代码的过程中，对想到的场景编写初始的检查，然后在尝试更多场景并获得报告代码不工作的用户时，扩展这些测试。

几乎所有编程语言都提供了一些结构或包，允许你在单独的文件中编写测试。Pyret 在支持区分示例和测试（既适用于学习，也适用于他人阅读代码的可读性）方面是独一无二的。许多支持专业人士的编程工具都期望你将所有测试放在单独的文件夹和文件中（不提供对示例的支持）。在这本书中，我们强调编程中输入输出对这两种用途之间的区别，因为我们发现它们在专业和教学方面都非常有用。

#### 8.3.2 更精细的比较 "链接到此处")

有时候，通过 `is` 进行直接比较并不足以进行测试。我们已经在 `raises` 测试的例子中看到了这一点（从家谱表中计算遗传父母）。作为另一个例子，在进行一些计算，尤其是涉及近似数学的计算时，`is` 的精确匹配是不切实际的。例如，考虑以下 `distance-to-origin` 的测试：

```py
check:
  distance-to-origin(point(1, 1)) is ???
end
```

我们可以在这里检查什么？在 REPL 中输入这个命令，我们可以发现答案打印为 `1.4142135623730951`。这是真实答案的一个近似值，Pyret 无法精确表示。但很难知道这个精确答案，到小数点后这么多位，是我们一开始就应该预期的，而且通过思考答案应该是我们首先做的事情！

由于我们知道我们得到的是一个近似值，我们只能检查答案是否大致正确，而不是完全正确。如果我们能检查 `distance-to-origin(point(1, 1))` 的答案大约是 `1.41`，并且可以对一些类似的情况做同样的检查，那么这可能是许多应用以及我们这里的用途所足够好的。如果我们正在计算轨道动力学，我们可能需要更高的精度，但请注意，我们仍然需要选择一个截止点！测试不精确的结果是一项必要的任务。

让我们首先用我们能够做到的最精确的方式定义“大约”的含义，即一个函数：

```py
fun around(actual :: Number, expected :: Number) -> Boolean:
  doc: "Return whether actual is within 0.01 of expected"
  num-abs(actual - expected) < 0.01
where:
  around(5, 5.01) is true
  around(5.01, 5) is true
  around(5.02, 5) is false
  around(num-sqrt(2), 1.41) is true
end
```

现在的 `is` 形式帮助我们解决了问题。有一种特殊的语法可以用来提供一个用户定义的函数来比较两个值，而不是仅仅检查它们是否相等：

```py
check:
  5 is%(around) 5.01
  num-sqrt(2) is%(around) 1.41
  distance-to-origin(point(1, 1)) is%(around) 1.41
end
```

在 `is` 后面添加 `%(something)` 会改变 `is` 的行为。通常情况下，它会比较左右两边的值是否相等。然而，如果提供了 `%`，它就会将左右两边的值传递给提供的函数（在这个例子中是 `around`）。如果提供的函数产生 `true`，则测试通过；如果产生 `false`，则测试失败。这为我们提供了测试具有可预测近似结果的函数所需的控制。

> 练习
> 
> > 将 `distance-to-origin` 的定义扩展到包括极坐标点。
> > 
> 练习
> 
> > 这可能可以节省你的谷歌搜索：[极坐标转换](http://en.wikipedia.org/wiki/Polar_coordinate_system#Converting_between_polar_and_Cartesian_coordinates)。使用设计食谱编写 `x-component` 和 `y-component` 函数，它们返回点的 `x` 和 `y` 坐标部分（例如，如果你在图表上绘制它们时需要这些）。在 [Pyret 数字文档](http://www.pyret.org/docs/latest/numbers.html) 中了解 `num-sin` 和其他你需要使用的函数。
> > 
> 练习
> 
> > 编写一个名为 `Pay` 的数据定义，用于支付类型，包括按小时支付的员工，其支付类型包括小时工资，以及年薪员工，其支付类型包括一年的总工资。使用设计食谱编写一个名为 `expected-weekly-wages` 的函数，该函数接受一个 `Pay` 参数，并返回预期的每周工资：按小时支付的员工的预期每周工资假设他们工作 40 小时，而年薪员工的预期每周工资是他们年薪的 1/52。

#### 8.3.3 当测试失败 "链接至此")

假设我们编写了一个名为 `sqrt` 的函数，该函数计算给定数字的平方根。我们为这个函数编写了一些测试。我们运行程序，发现一个测试失败了。这种情况可能有两个明显的原因。

> 现在行动！
> 
> > 有两个明显的原因是什么？

这两个原因当然是测试的“两面”：问题可能是我们编写的数值或我们编写的函数。例如，如果我们编写了

```py
sqrt(4) is 1.75
```

如果错误明显是由于数值（因为 \(1.75²\) 显然不等于 \(4\)），那么问题显然出在这些数值上。另一方面，如果它未能通过测试

```py
sqrt(4) is 2
```

那么很可能是我们在 `sqrt` 的定义中犯了错误，这正是我们需要修复的。

注意，计算机无法知道出了什么问题。当它报告测试失败时，它只是在说程序和测试之间存在不一致。计算机不会对哪一个是“正确的”做出判断，因为它无法做到这一点。这是一个需要人类判断的问题。因此，我们一直在研究 [测试同行评审](http://cs.brown.edu/~sk/Publications/Papers/Published/pkf-ifpr-tests-tf-prog/)，以便学生在开始编写程序之前互相评审他们的测试。

实际上...并不那么快。还有一种我们没有考虑的可能性：第三个不那么明显的测试失败原因。回到这个测试：

```py
sqrt(4) is 2
```

显然输入和输出都是正确的，但可能是 `sqrt` 的定义也是正确的，但测试仍然失败了。

> 现在行动！
> 
> > 你看懂了吗？

根据我们如何编程 `sqrt`，它可能返回 `-2` 而不是 `2`。现在 `-2` 也是一个完全合理的答案。也就是说，函数以及我们指定的特定测试值集本身并没有错误；只是这个函数碰巧是一个关系，即它将一个输入映射到多个输出（也就是说，\(\sqrt{4} = \pm 2\)）。现在的问题是，如何正确地编写测试。

#### 8.3.4 测试的预言者 "链接到此处")

换句话说，有时我们想要表达的不是具体的输入输出对，而是检查输出与输入之间是否具有正确的关系。具体来说，在 `sqrt` 的情况下，这可能会是什么？我们之前在说 `1.75` 明显不正确时已经暗示了这一点，因为平方它不会得到 `4`。这给了我们一个一般的洞察：一个数是有效的根（注意使用“a”而不是“the”），如果平方它得到原始数字。也就是说，我们可能编写一个像这样的函数：

```py
fun is-sqrt(n):
  n-root = sqrt(n)
  n == (n-root * n-root)
end
```

然后我们的测试看起来像

```py
check:
  is-sqrt(4) is true
end
```

不幸的是，这有一个尴尬的失败情况。如果 `sqrt` 不产生实际上是一个根的数字，我们不会被告知实际值是什么；相反，`is-sqrt` 返回 false，测试失败只是说 `false`（`is-sqrt` 返回的）不是 `true`（测试期望的）——<wbr>这既是绝对正确的，也是完全无用的。

幸运的是，Pyret 有一种更好的方式来表达相同的检查。我们不是用 `is`，而是可以写 `satisfies`，然后左边的值必须满足右边的谓词。具体来说，这看起来像：

```py
fun check-sqrt(n):
  lam(n-root):
    n == (n-root * n-root)
  end
end
```

这让我们可以写出：

```py
check:
  sqrt(4) satisfies check-sqrt(4)
end
```

现在，如果出现失败，我们会了解到 `sqrt(4)` 产生的实际值未能满足谓词。
