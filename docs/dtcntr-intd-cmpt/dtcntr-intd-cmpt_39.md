# 12.4 循环数据

> 原文：[`dcic-world.org/2025-08-27/unified-cyclic-data.html`](https://dcic-world.org/2025-08-27/unified-cyclic-data.html)

| |   12.4.1 创建循环数据 |
| --- | --- |
| |   12.4.2 测试循环数据 |
| |   12.4.3 实践中的循环 |

#### 12.4.1 创建循环数据 "链接到此处")

在之前的[别名]中，我们介绍了别名银行账户的概念，即多个客户可以操作同一个账户。有时，银行想要跟踪所有可以访问特定账户的客户。例如，当账户余额不足时，它想要通知所有可以访问该账户的客户。

因此，每个账户都需要维护一个其客户的列表。因为所有者集合可能会随时间变化，我们在 Pyret 中将该字段设置为可变的：

| Python | Pyret |
| --- | --- |



```py
@dataclass
class Account:
    id: int
    balance: int
    owners: list # of Customer

@dataclass
class Customer:
    name: str
    acct: Account 
```



```py
data Account:
    account(id :: Number,
      ref balance :: Number,
      ref owners :: List<Customer>)
end

data Customer:
    cust(name :: String,
      acct :: Account)
end
```



如果你仔细观察，你会看到`Account`指向`Customer`（具体来说，是一个客户列表），而`Customer`反过来又指向`Account`。这可能会变得很有趣。

之前，我们可以创建一个只有一个客户的账户如下：

| Python |  |
| --- | --- |
|  |

```py
elena = Customer("Elena", Account(8404, 500))
```



| Pyret |  |
| --- | --- |
|  |

```py
elena = cust("Elena", account(8404, 500))
```



我们现在该如何做？每个`Account`都需要一个其`Customer`的列表。我们需要编写

| Python |  |
| --- | --- |
|  |

```py
elena = Customer("Elena", Account(8404, 500, [_____]))
```



| Pyret |  |
| --- | --- |
|  |

```py
elena = cust("Elena", account(8404, 500, [list: _____]))
```



但`_____`中应该填什么？它需要指向我们目前正在创建的客户账户。

另一种思考这种方式的方法是：

| Python |  |
| --- | --- |
|  |

```py
acct1 = Account(8404, 500, [_____])
elena = Customer("Elena", acct1)
```



| Pyret |  |
| --- | --- |
|  |

```py
acct1 = account(8404, 500, [list: _____])
elena = cust("Elena", acct1)
```



这并没有解决我们的基本问题——我们仍然需要填写`_____`——但至少我们现在有了可以指代实体的名称。我们希望能够写出

| Python |  |
| --- | --- |
|  |

```py
acct1 = Account(8404, 500, [elena])
elena = Customer("Elena", acct1)
```



| Pyret |  |
| --- | --- |
|  |

```py
acct1 = account(8404, 500, [list: elena])
elena = cust("Elena", acct1)
```



但当我们尝试运行这段代码时，Python 和 Pyret 都会给出错误。这是因为它们试图评估第一行的右侧来创建一个账户，其堆地址将被绑定到目录中的`acct1`。为了做到这一点，它们必须评估那个账户创建表达式。在这样做的时候，它们查找名称`elena`。然而，`elena`尚未在目录中绑定。因此，它们产生了错误。

注意，我们并不能简单地颠倒这两个绑定的顺序。如果我们尝试这样做，我们最终会遇到同样的问题：我们试图创建一个指向`acct1`的客户。但我们还没有定义`acct1`，这会产生相同的错误。

问题是我们正在尝试创建循环数据。这两个数据相互引用。我们早已从数据定义中感觉到这种情况可能发生，现在我们必须面对它。问题是我们必须首先创建一些值，但我们无法正确地创建任何一个，因为它们都依赖于对方。

如你所猜，我们必须妥协。我们必须首先构建其中一个数据，当我们这样做时，它可能并不完全准确。然后我们创建另一个，然后修改第一个以包含正确的内容。

在我们的情况下，Pyret 版本清楚地说明了创建数据时应使用的顺序。`Customer`中的任何内容都不是可变的（也不需要是），而账户所有者列表是（并且应该是，因为客户集可以增长）。因此，我们可以写出：

| Python |  |
| --- | --- |
|  |

```py
acct1 = Account(8404, 500, [])
```



| Pyret |  |
| --- | --- |
|  |

```py
acct1 = account(8404, 500, empty)
```



注意，在这个时候，这实际上是准确的！这个账户没有所有者。

现在我们创建 Elena 的账户：

| Python |  |
| --- | --- |
|  |

```py
elena = Customer("Elena", acct1)
```



| Pyret |  |
| --- | --- |
|  |

```py
elena = cust("Elena", acct1)
```



在这一点上，我们的内存看起来像这样：为了简单起见，我们将显示账户内的所有者列表，而不是将其放在自己的内存位置中。

目录

+   ```py
    acct1
    ```

    → 1001

+   ```py
    elena
    ```

    → 1002

堆栈

+   1001: `Account(8404, 500, [])`

+   1002: `Customer("Elena", 1001)`

现在事情有些不准确：1001 号账户确实有一个所有者，但这还没有反映出来。因此，我们必须更新它以反映这一点：

| Python | Pyret |
| --- | --- |



```py
acct1.owners = [elena]
```



```py
acct1!{owners: [list: elena]}
```



我们现在可以合法地这样做，因为`elena`在字典中是有绑定的。此外，它绑定到有用的东西：Elena 的客户信息。因此，现在值被正确设置：Elena 的客户信息指向账户，账户指向 Elena 的客户信息：

目录

+   ```py
    acct1
    ```

    → 1001

+   ```py
    elena
    ```

    → 1002

堆栈

+   1001: `Account(8404, 500, [1002])`

+   1002: `Customer("Elena", 1001)`

这就是“循环”中的循环：1001 依赖于 1002，而 1002 又依赖于 1001。

注意，如果我们引入另一位客户，名叫 Jorge，他与同一个账户共享，我们可以更新账户以反映这一点：

| Python |  |
| --- | --- |
|  |

```py
jorge = Customer("Jorge", acct1)
```



| Pyret |  |
| --- | --- |
| |

```py
jorge = cust("Jorge", acct1)
```



再次强调，`acct1`中的信息不准确，因为它没有反映新的所有者。我们可以以类似的方式修改它：

| Python |  |
| --- | --- |
|  |

```py
acct1.owners = acct1.owners + [jorge]
```



| Pyret |  |
| --- | --- |
|  |

```py
acct1!{owners: acct1!owners + [list: jorge]}
```



因此，现在我们的内存看起来会是这样：

目录

+   ```py
    acct1
    ```

    → 1001

+   ```py
    elena
    ```

    → 1002

+   ```py
    jorge
    ```

    → 1003

堆栈

+   1001: `Account(8404, 500, [1002, 1003])`

+   1002: `Customer("Elena", 1001)`

+   1003: `Customer("Jorge", 1001)`

> 现在行动！
> 
> > 当添加 Jorge 的账户时，我们编写的代码与添加 Elena 的账户时略有不同。哪一个更好？

为 Elena 添加的代码忽略了之前存在的所有者。也就是说，它只在没有其他所有者的环境中才能正确工作。Jorge 添加的代码考虑了所有之前的所有者。因此，Elena 的代码对于说明简单的情况是完美的，但 Jorge 的代码更通用，因为它将在所有环境中工作（包括当先前的所有者列表为空时）。

> 练习
> 
> > 编写一个函数，用于将客户添加到账户中。

#### 12.4.2 测试循环数据 "链接至此")

当你想编写涉及循环数据的测试时，你不能手动写出循环数据。例如，假设我们想要写出之前提到的`acct1`：

| Python |  |
| --- | --- |
|  |

```py
assert(acct1 = Account(8404, 500, [Customer("Elena", Account(8404, 500, …)]))
```



| Pyret |  |
| --- | --- |
|  |

```py
check:
  acct1 is
    account(8404, 500, [list: cust("Elena", account(8404, 500, …))])
end
```

|  |

然而，由于循环性，我们无法完成数据的编写。我们不能只是用`…`省略一部分。

这给我们留下了两个选择：

你有两个选择：根据数据名称编写测试，或者根据数据的组件编写测试。

这里有一个示例，说明了这两个方面。在设置账户后，我们可能想要检查新账户的所有者是否是新客户：

```py
assert(new_acct.owner is new_cust)
```

在这里，我们不是明确写出`Customer`，而是使用目录中现有项的名称。这不需要你编写省略号。我们还专注于`owner`组件，它是我们期望更改的`Account`值的一部分。

#### 12.4.3 实践中的循环 "链接到此处")

循环数据在真实程序中的许多场景中都会出现。每当两个数据相互关联，并且我们有很好的理由想要从一个转到另一个时，它们就有可能相互引用，这可能导致循环。有时这种联系可能是为了提供更新，如上所述；有时它可能只是为了导航方便。

考虑文档对象模型（DOM），它是表示浏览器中每个网页的数据结构。程序员通常将 DOM 视为层次结构，就像一棵树，因为每个节点都引用构成它的所有节点：例如，一个页面引用了它的每个段落，一个列表引用了每个列表项，等等。然而，这些元素中的每一个也都有一个引用其父元素的引用。这样，程序可以方便地向下或向上遍历。

使用循环数据编程会引入复杂性。如果我们天真地遍历数据，我们就会进入无限循环。相反，我们必须跟踪我们之前访问过的数据，并确保我们不再访问它们（参见有向无环图的大小）。实际上，循环数据是图 [图]，因此处理图的问题在这里变得相关。

编程语言面临的一个有趣的问题是，如何打印循环数据？例如，如果程序员编写

```py
acct1
```

? 为了打印账户，我们必须打印其所有者；为了打印每个所有者，我们必须打印他们的账户；为了打印那个账户…

> 现在行动！
> 
> > 在 Python 和 Pyret 中尝试一下！

不同编程语言以不同的方式处理这个问题。一些语言会尝试打印循环数据而进入无限循环。Python 和 Pyret 都处理这个问题更为智能。确定数据是否循环本身就是一个有趣的问题，我们在检测循环中探讨了这个问题。

#### 12.4.1 创建循环数据 "链接到此处")

在之前的[别名]中，我们介绍了别名银行账户的概念，其中多个客户可以操作同一个账户。有时，银行希望跟踪所有可以访问给定账户的客户。例如，当账户余额不足时，它希望通知所有可以访问它的客户。

因此，每个账户都需要维护其客户的列表。因为所有者的集合可能会随时间变化，我们在 Pyret 中使该字段可变：

| Python | Pyret |
| --- | --- |



```py
@dataclass
class Account:
    id: int
    balance: int
    owners: list # of Customer

@dataclass
class Customer:
    name: str
    acct: Account 
```



```py
data Account:
    account(id :: Number,
      ref balance :: Number,
      ref owners :: List<Customer>)
end

data Customer:
    cust(name :: String,
      acct :: Account)
end
```



如果你仔细观察，你会发现`Account`引用了`Customer`（特别是它们的列表）并且反过来`Customer`也引用了`Account`。这可能会变得很有趣。

以前，我们可以这样创建一个账户：

| Python |  |
| --- | --- |
|  |

```py
elena = Customer("Elena", Account(8404, 500))
```



| Pyret |  |
| --- | --- |
|  |

```py
elena = cust("Elena", account(8404, 500))
```



现在我们该如何做？每个`Account`都需要一个其`Customer`s 的列表。我们需要编写

| Python |  |
| --- | --- |
|  |

```py
elena = Customer("Elena", Account(8404, 500, [_____]))
```



| Pyret |  |
| --- | --- |
|  |

```py
elena = cust("Elena", account(8404, 500, [list: _____]))
```



但`_____`里应该填什么？它需要指代我们目前正在创建的特定客户账户。

另一种思考编写这个的方法是：

| Python |  |
| --- | --- |
|  |

```py
acct1 = Account(8404, 500, [_____])
elena = Customer("Elena", acct1)
```



| Pyret |  |
| --- | --- |
|  |

```py
acct1 = account(8404, 500, [list: _____])
elena = cust("Elena", acct1)
```



这并没有解决我们的基本问题——我们仍然需要填写`_____`——但至少我们现在有了可以指代实体的名称。我们希望能够写出

| Python |  |
| --- | --- |
|  |

```py
acct1 = Account(8404, 500, [elena])
elena = Customer("Elena", acct1)
```



| Pyret |  |
| --- | --- |
|  |

```py
acct1 = account(8404, 500, [list: elena])
elena = cust("Elena", acct1)
```



但当我们尝试运行这个程序时，Python 和 Pyret 都会给我们一个错误。这是因为它们试图评估第一行的右侧来创建一个账户，其堆地址将被绑定到`acct1`。为了做到这一点，它们必须评估那个账户创建表达式。在这样做的时候，它们查找名称`elena`。然而，`elena`尚未在目录中绑定。因此，它们产生了一个错误。

注意，我们无法简单地颠倒这两个绑定的顺序。如果我们尝试这样做，我们最终会遇到相同的问题：我们尝试创建一个引用`acct1`的客户。但我们还没有定义`acct1`，这会产生相同的错误。

问题在于我们正在尝试创建循环数据。这两个数据相互引用。我们早已从数据定义中感觉到可能会发生这种情况，现在我们必须面对它。问题在于我们必须首先创建一些值，但由于每个值都依赖于另一个，我们无法正确地创建任何一个。

如你所猜，我们必须妥协。我们必须首先构建其中一个数据，当我们这样做时，它可能并不完全准确。然后我们创建另一个，然后修改第一个以包含正确的内容。

在我们的情况下，Pyret 版本清楚地说明了创建数据时应使用的顺序。在`Customer`中没有任何内容是可变的（也不需要是），而账户所有者的列表是（并且应该是，因为客户的集合可以增长）。因此，我们可以写出：

| Python |  |
| --- | --- |
|  |

```py
acct1 = Account(8404, 500, [])
```



| Pyret |  |
| --- | --- |
|  |

```py
acct1 = account(8404, 500, empty)
```



注意，在这个阶段，这实际上是准确的！这个账户没有所有者。

现在我们创建伊莲娜的账户：

| Python |  |
| --- | --- |
|  |

```py
elena = Customer("Elena", acct1)
```



| Pyret |  |
| --- | --- |
| |

```py
elena = cust("Elena", acct1)
```



在这一点上，我们的内存看起来像这样：为了简单起见，我们将显示账户内的所有者列表，而不是将其放在自己的内存位置中。

目录

+   ```py
    acct1
    ```

    → 1001

+   ```py
    elena
    ```

    → 1002

堆

+   1001: `Account(8404, 500, [])`

+   1002: `Customer("Elena", 1001)`

现在事情有些不准确：1001 号账户确实有一个所有者，但这还没有反映出来。因此，我们必须更新它以反映这一点：

| Python | Pyret |
| --- | --- |



```py
acct1.owners = [elena]
```



```py
acct1!{owners: [list: elena]}
```



我们现在可以合法地这样做，因为`elena`在字典中是有绑定的。此外，它绑定到有用的东西：伊莲娜的客户信息。因此，现在值被正确设置：伊莲娜的客户信息指向账户，账户指向伊莲娜的客户信息：

目录

+   ```py
    acct1
    ```

    → 1001

+   ```py
    elena
    ```

    → 1002

堆

+   1001: `Account(8404, 500, [1002])`

+   1002: `Customer("Elena", 1001)`

这是在“循环”中的循环：1001 依赖于 1002，而 1002 依赖于 1001。

观察到如果我们引入另一个客户，乔治，他与同一个账户共享，我们可以更新账户以反映这一点：

| Python |  |
| --- | --- |
|  |

```py
jorge = Customer("Jorge", acct1)
```



| Pyret |  |
| --- | --- |
|  |

```py
jorge = cust("Jorge", acct1)
```



再次，`acct1`中的信息不准确，因为它没有反映新的所有者。我们可以以类似的方式修改它：

| Python |  |
| --- | --- |
|  |

```py
acct1.owners = acct1.owners + [jorge]
```



| Pyret |  |
| --- | --- |
|  |

```py
acct1!{owners: acct1!owners + [list: jorge]}
```



因此，现在我们的内存看起来像这样：

目录

+   ```py
    acct1
    ```

    → 1001

+   ```py
    elena
    ```

    → 1002

+   ```py
    jorge
    ```

    → 1003

堆

+   1001: `Account(8404, 500, [1002, 1003])`

+   1002: `Customer("Elena", 1001)`

+   1003: `Customer("Jorge", 1001)`

> 立刻行动！
> 
> > 我们在添加乔治的账户时写的代码与添加伊莲娜的账户时写的代码略有不同。哪一个更好？

伊莲娜增加的代码忽略了之前存在的任何所有者。也就是说，它只在没有其他所有者的环境中才能正确工作。乔治增加的代码考虑了所有之前的所有者。因此，伊莲娜的代码非常适合说明简单的第一种情况，但乔治的代码更通用，因为它将在所有环境中工作（包括当先前所有者的列表为空时）。

> 练习
> 
> > 编写一个函数，用于将客户添加到账户中。

#### 12.4.2 测试循环数据 "链接到此处")

当你想编写涉及循环数据的测试时，你不能手动编写循环数据。例如，想象一下我们想要编写之前提到的`acct1`：

| Python |  |
| --- | --- |
|  |

```py
assert(acct1 = Account(8404, 500, [Customer("Elena", Account(8404, 500, …)]))
```



| Pyret |  |
| --- | --- |
|  |

```py
check:
  acct1 is
    account(8404, 500, [list: cust("Elena", account(8404, 500, …))])
end
```



然而，由于循环性，我们无法完成数据的编写。我们不能只是用`...`来留下部分未指定。

这让我们有两个选择：

你有两个选择：用数据名称编写测试，或者用数据的组成部分编写测试。

这里有一个示例，说明了这两者。在设置账户后，我们可能想要检查新账户的所有者是否是新客户：

```py
assert(new_acct.owner is new_cust)
```

在这里，我们不是明确写出 `Customer`，而是使用目录中现有项目的名称。这不需要你写省略号。我们还专注于 `owner` 组件，它是我们期望改变的 `Account` 值的一部分。

#### 12.4.3 实践中的循环 "链接至此")

循环数据在真实程序中的许多场景中都会出现。每当两个数据相互关联，并且我们有充分的理由想要从一个转到另一个时，它们就有可能相互引用，这可能导致循环。有时这种联系可能是为了提供更新，如上所述；有时它可能只是为了导航方便。

考虑文档对象模型（DOM），它是代表浏览器中每个网页的数据结构。程序员通常将 DOM 视为层次结构，即一棵树，因为每个节点都引用构成它的所有节点：例如，一个页面引用了它的每个段落，一个列表引用了每个列表项，等等。然而，这些元素中的每一个也都有一个引用其父元素的引用。这样，程序可以方便地向下或向上遍历。

使用循环数据编程会引入复杂性。如果我们天真地遍历数据，我们会进入无限循环。相反，我们必须跟踪我们之前访问过的数据，并确保我们不再访问它们（参见有向无环图的大小）。事实上，循环数据是图 [图]，因此处理图的问题在这里变得相关。

编程语言面临的一个有趣问题是，如何打印循环数据？例如，如果程序员编写

```py
acct1
```

? 要打印账户，我们必须打印其所有者；要打印每个所有者，我们必须打印他们的账户；要打印那个账户…

> 现在就做！
> 
> > 在 Python 和 Pyret 中都试一试吧！

不同的编程语言以不同的方式处理这个问题。有些语言会陷入无限循环，试图打印循环数据。Python 和 Pyret 处理这个问题更为智能。甚至确定一个数据是否是循环的也是一个有趣的问题，我们将在检测循环中探讨。
