# 18.5 等价性、顺序和哈希🔗

> 原文：[`dcic-world.org/2025-08-27/orderability.html`](https://dcic-world.org/2025-08-27/orderability.html)

|     18.5.1 将值转换为有序值 |
| --- |
|     18.5.2 实践中的哈希 |
|     18.5.3 等价性和顺序 |

#### 18.5.1 将值转换为有序值🔗 "链接到此处")

在在树上构建集合中，我们注意到单个比较需要消除整个值集。对于数字，我们能够轻松地做到这一点：每个更大或更小的数字都通过比较被排除。但如果集合中的数据实际上不是数字呢？那么我们必须将任意数据转换为允许这种比较的数据类型。这被称为哈希。

哈希函数接受任意值并产生其可比较的表示（其哈希值）——最常见（但不是严格必要），是一个数字。哈希函数必须是确定的：固定的值应该总是产生相同的哈希值（否则，我们可能会得出结论，集合中的某个元素实际上不在其中，等等）。特定的用途可能需要额外的属性，正如我们在等价性和顺序中讨论的那样。

让我们考虑一下如何计算哈希值。如果输入的数据类型是数字，它可以作为自己的哈希值。比较简单地使用数值比较（例如，`<`）。然后，`<` 的传递性确保如果一个元素 \(A\) 小于另一个元素 \(B\)，那么 \(A\) 也小于所有比 \(B\) 大的元素。

假设输入是一个字符串。我们当然可以使用上面的原则来处理字符串：例如，用字符串不等式替换数字不等式。字符串有字典序（或“字母”）顺序，这使得它们可以像数字一样处理。

但如果我们遇到更复杂的数据类型怎么办？

在回答这个问题之前，考虑一下在实践中数字比字符串更高效（因为比较两个数字几乎总是常数时间）。因此，尽管我们可以直接使用字符串，但找到字符串的数值表示可能更方便。我们将字符串的每个字符转换为数字，例如使用其 [码点](https://en.wikipedia.org/wiki/Code_point)。基于此，这里有两个不同的哈希函数：

1.  考虑一个与字符串一样长的素数列表。将每个素数乘以相应的数字，然后乘以结果。例如，如果字符串由字符代码 `[6, 4, 5]` 表示（第一个字符的代码是 `6`，第二个是 `4`，第三个是 `5`），我们得到的哈希值是

    ```py
    num-expt(2, 6) * num-expt(3, 4) * num-expt(5, 5)
    ```

    或 `16200000`。

1.  简单地将所有字符代码相加。对于上面的例子，这对应于哈希值

    ```py
    6 + 4 + 5
    ```

    或 `15`。

第一种表示是可逆的，使用[算术基本定理](http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic)：给定结果数字，我们可以无歧义地重建输入（即，`16200000`只能映射到上面的输入，不能是其他任何输入）。这也被称为哥德尔编码。这是计算上昂贵的。第二种编码当然不可逆（例如，简单地重新排列字符，根据交换律，和将保持不变），但在计算上要便宜得多。它也容易实现：

```py
fun hash-of(s :: String):
  fold({(a :: Number, b :: Number): a + b},
    0,
    string-to-code-points(s))
end

check:
  hash-of("Hello") is 500
  hash-of("World!") is 553
  hash-of("🏴‍☠️") is 195692
end
```

现在，让我们考虑更一般的数据类型。哈希的原则将是相似的。如果我们有一个具有几个变体的数据类型，我们可以按字典顺序对变体进行排序，并使用一个数字标签来表示变体，然后递归地编码数据和变体标签。对于记录的每个字段，我们需要字段的排序——<wbr>字段名称的字典顺序就足够了——<wbr>并且必须递归地哈希它们的内容；这样做之后，我们实际上得到一个数字字符串，我们已经展示了如何处理它。

需要记住的关键点是，我们实际上并不需要一个有意义的操作。观察一下，哥德尔编码也不是“有意义的”。我们实际上并不关心一个哈希函数是否得出结论说`4`的哈希值小于`3`的哈希值！我们需要的只是一个函数，它

+   非平凡的：不是所有东西都应该相等；并且

+   确定的：每次我们请求一个哈希值时，我们都应该得到相同的答案。

> 练习
> 
> > 我们为什么关心这两个属性？想想如果每个属性被违反会发生什么。

#### 18.5.2 实际中的哈希🔗 "链接到此处")

在实践中，程序员不希望哈希函数执行我们上面描述的操作。虽然哥德尔编码非常昂贵，即使计算`hash-of`也需要与字符串大小成线性关系的计算时间，如果字符串很大或者我们经常计算哈希值，或者两者兼而有之，这可能会相当昂贵。

相反，许多编程语言采取了一种非常实用主义的方法。它们需要一个可以用于比较相等性和排序的值 [相等性和排序]。我们已经看到，整数已经非常完美地符合这个要求。但是，如何从任意值，甚至是数据类型实例中快速获得一个整数呢？

简单：它们只是使用数据的内存地址。每个值都有一个内存地址，语言可以通过查找目录在常数时间内获得它。当然，这些值相对于彼此可能被分配在任何地方，但这没关系——我们只想要一致性，而不是“有意义性”。

然而，在实践中，事情并不那么简单。例如，假设我们希望两个结构上等价的价值具有相同的哈希值。如果它们分配在不同的地址，它们的哈希值将不同。因此，许多使用这种策略的语言也允许程序员编写自己的哈希函数，通常与内置的哈希概念一起使用。这些最终看起来与我们上面描述的哈希策略没有太大区别。因此，一些复杂性是不可避免的，尤其是如果程序员想要结构等价而不是引用等价——他们通常是这样做的。

因此，在本材料的其余部分，我们将继续使用上面简单的哈希函数，有多个原因。首先，它足以说明哈希是如何工作的。其次，在实践中，当内置哈希不足时，我们确实会编写（更复杂的版本）像上面那样的函数。最后，因为所有这些都暴露出来，我们很容易进行实验。

#### 18.5.3 等价与排序🔗 "链接至此")

我们在构建平衡二叉搜索树时看到的 [精细平衡：树手术] 是，我们需要一种方式来对元素进行排序。在我们使用的例子中，我们使用了数字，因为它们是一个非常友好的数据类型：它们具有我们视为理所当然的几个属性。然而，并非所有数据都具有这些属性。

数字的关键属性是它们是可排序的。这是因为它们是可比较的，比较结果是三元：它产生三个答案，“小于”、“等于”和“大于”。

然而，并非所有数据都具有这种属性。哪些数据可能不具有这些属性？实际上，这里有多种可能的属性：某物是否可排序？某物是否可比较？

|  |  | 可比较 |  | 可排序 |
| --- | --- | --- | --- | --- |
| 数字 |  | 是（但不是粗略数！） |  | 是 |
| 布尔值 |  | 是 |  | 是 |
| 数据实例 |  | 是 |  | 默认不 |
| 粗略数 |  | 否 |  | 是 |
| 函数 |  | 不太是 |  | 否 |

所以……生活很复杂。

这意味着你可能会在错误类型的数据上误用 BBST。理想情况下，我们希望知道我们是否在进行这项操作。在 Pyret 的类型系统中，我们选择不将其内置，但在某些语言中，类型系统实际上允许你捕获这些属性。

例如，在 Haskell 中，有一个称为类型类的机制；在 Java 中，有接口。它们并不完全相同，但为了我们的目的，将它们合并是有用的。只有满足特定接口或类型类的事物才提供某些操作。例如，在 Haskell 中，如果你想使用 == 或 /=（不等），你必须处于 Eq 类型类中。因此，上述可比较的数据类型将是 Eq 的一部分。同样，还有一个类型类 Ord，它确保了 <、>、<= 和 >= 等操作的可用性和实现。在 Haskell 中，所有是 Ord 的东西也必须是 Eq，即 Eq 比 Ord 弱（事物可以是 Eq 而不是 Ord）。Pyret 的 Roughnums 与此相反……但 Haskell 可以接受它。但是，如果你尝试在 Haskell 中比较两个函数，

| (\x -> x + 1) < (\x -> x) |
| --- |

你可能会遇到如下错误

| * 无法实例化 (Ord (Integer -> Integer)) |
| --- |
|   由使用`<`引起 |

#### 18.5.1 将值转换为有序值🔗 "链接到此处")

在在树上构建集合中，我们提到一个比较需要消除一个整个值集。对于数字，我们能够轻松地做到这一点：每个比它大或小的数字都会被比较排除。但是，如果集合中的数据实际上不是数字呢？那么我们必须将任意数据转换为允许这种比较的数据类型。这被称为哈希。

哈希函数消耗一个任意值并产生其可比较的表示（其哈希值）——最常见（但不严格必要）的是数字。哈希函数必须是自然确定的：固定值应该总是产生相同的哈希值（否则，我们可能会得出结论，集合中的元素实际上不在其中等）。特定的用途可能需要额外的属性，正如我们在等价性和排序中讨论的那样。

现在让我们考虑如何计算哈希值。如果输入的数据类型是数字，它可以作为自己的哈希值。比较仅使用数值比较（例如，`<`）。然后，`<`的传递性确保如果一个元素 \(A\) 比另一个元素 \(B\) 小，那么 \(A\) 也比所有比 \(B\) 大的元素小。

假设输入是一个字符串。我们当然可以使用上述原则来处理字符串：例如，用字符串不等式替换数字不等式。字符串有字典序（或“字母”）排序，这使得它们可以像数字一样处理。

但如果我们被 handed 更复杂的数据类型呢？

在我们回答这个问题之前，考虑一下在实践中，数字比字符串更高效地进行比较（因为比较两个数字几乎接近常数时间）。因此，尽管我们可以直接使用字符串，但找到字符串的数值表示可能更方便。我们将字符串的每个字符转换为数字，例如，使用其 [码点](https://en.wikipedia.org/wiki/Code_point)。基于此，这里有两个不同的哈希函数：

1.  考虑一个与字符串一样长的素数列表。将每个素数提升到相应的数字，然后乘以结果。例如，如果字符串由字符代码 `[6, 4, 5]` 表示（第一个字符的代码是 `6`，第二个是 `4`，第三个是 `5`），我们得到的哈希值

    ```py
    num-expt(2, 6) * num-expt(3, 4) * num-expt(5, 5)
    ```

    或者 `16200000`。

1.  简单地将所有字符代码相加。对于上面的例子，这对应于哈希

    ```py
    6 + 4 + 5
    ```

    或者 `15`。

第一种表示是可逆的，使用[算术基本定理](http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic)：给定结果数字，我们可以无歧义地重建输入（即，`16200000` 只能映射到上面的输入，不能是其他任何输入）。这也被称为哥德尔编码。这是计算上昂贵的。第二种编码当然不可逆（例如，简单地重新排列字符，根据交换律，和将保持不变），但计算上要便宜得多。它也容易实现：

```py
fun hash-of(s :: String):
  fold({(a :: Number, b :: Number): a + b},
    0,
    string-to-code-points(s))
end

check:
  hash-of("Hello") is 500
  hash-of("World!") is 553
  hash-of("🏴‍☠️") is 195692
end
```

现在让我们考虑更一般的数据类型。哈希的原则将类似。如果我们有一个具有几个变体的数据类型，我们可以按字典顺序对变体进行排序，并使用一个数字标签来表示变体，然后递归地编码数据和变体标签。对于记录的每个字段，我们需要字段的排序——<wbr>字段名称的字典顺序就足够了——<wbr>并且必须递归地哈希它们的内容；这样做之后，我们实际上得到一个数字字符串，我们已经展示了如何处理它。

需要记住的关键是，我们实际上不需要一个有意义的操作。观察一下，哥德尔编码也不是“有意义的”。我们实际上并不关心哈希函数是否得出结论说 `4` 的哈希值小于 `3` 的哈希值！我们需要的只是一个函数，它是

+   非平凡的：不是所有东西都应该相等；

+   确定性：每次我们请求哈希值时，都应该得到相同的答案。

> 练习
> 
> > 我们为什么关心这两个属性呢？想想如果每个属性被违反会发生什么。

#### 18.5.2 实践中的哈希🔗 "链接到此处")

在实践中，程序员不希望哈希函数执行我们上面描述的操作。虽然哥德尔编码非常昂贵，即使是计算 `hash-of` 的时间也是与字符串大小成线性关系的，如果字符串很大或者我们经常计算哈希值，或者两者兼而有之，这可能会相当昂贵。

相反，许多编程语言做了一些非常实用的处理。它们需要一个可以用于比较相等性和排序的值 [相等性和排序]）。我们已经看到，整数已经非常适合这个要求。但是如何从任意值，甚至是数据类型实例中快速获得一个整数呢？

简单：它们只是使用数据的内存地址。每个值都有一个内存地址，语言可以通过查找目录在常数时间内获得它。当然，这些值可能相对于彼此分配在任何地方，但这没关系——我们只想要一致性，而不是“有意义”。

在实践中，事情并不那么简单。例如，假设我们希望两个结构上等价的价值具有相同的哈希值。如果它们分配在不同的地址，它们的哈希值将不同。因此，许多使用这种策略的语言也允许程序员编写自己的哈希函数，通常是为了与这种内置的哈希概念协同工作。这些最终看起来并不太不同于我们上面描述的哈希策略。因此，一些复杂性是不可避免的，尤其是如果程序员想要结构上的相等而不是引用相等——他们通常是这样做的。

因此，在接下来的材料中，我们将继续使用上面简单的哈希函数，有多个原因。首先，它足以说明哈希是如何工作的。其次，在实践中，当内置的哈希不足时，我们确实会编写（更复杂版本的）上述函数。最后，因为一切都暴露出来，我们很容易进行实验。

#### 18.5.3 相等与排序🔗 "链接到此处")

我们在构建平衡二叉搜索树时看到的[良好的平衡：树手术】表明，我们需要一种对元素进行排序的方法。在我们使用的例子中，我们使用了数字，因为它们是一个非常友好的数据类型：它们具有我们视为理所当然的几个属性。然而，并非所有数据都具有这些属性。

数字的关键属性是它们是可排序的。这是因为它们是可比较的，比较是三元的：它产生三个答案，“小于”、“等于”和“大于”。

然而，并非所有数据都具有这种属性。哪些数据可能不具有这些属性？实际上，这里有多种可能的属性：某物是否可排序？某物甚至是否可比较？

|  |  | 可比较 |  | 可排序 |
| --- | --- | --- | --- | --- |
| 数字 |  | 是（但不是粗略数！） |  | 是 |
| 布尔值 |  | 是 |  | 是 |
| 数据实例 |  | 是 |  | 默认不 |
| 粗略数 |  | 否 |  | 是 |
| 函数 |  | 不太是 |  | 否 |

所以……生活很复杂。

这意味着你可能会错误地使用 BBST 来处理错误类型的数据。理想情况下，我们希望知道我们是否在这样做。在 Pyret 的类型系统中，我们选择不将其内置，但在某些语言中，类型系统实际上允许你捕获这些属性。

在 Haskell 中，例如，有一个称为类型类的机制；在 Java 中，有接口。它们并不完全相同，但为了我们的目的，将它们合并使用是有用的。只有满足特定接口或类型类的事物才能提供某些操作。例如，在 Haskell 中，如果你想使用 == 或 /=（不等于），你必须属于 Eq 类型类。因此，上述可比较的数据类型将是 Eq 的一部分。同样，还有一个类型类 Ord，它确保了 <、>、<= 和 >= 等操作的可用性并要求实现这些操作。在 Haskell 中，所有属于 Ord 的东西也必须是 Eq，即 Eq 比 Ord 弱（事物可以是 Eq 而不是 Ord）。Pyret 的 Roughnums 与此相反……但 Haskell 对此表示可以接受。但如果你尝试在 Haskell 中比较两个函数，

| (\x -> x + 1) < (\x -> x) |
| --- |

你会得到一个错误，类似于

| * 没有适用于 (Ord (Integer -> Integer)) 的实例 |
| --- |
|    由使用 `<' |
