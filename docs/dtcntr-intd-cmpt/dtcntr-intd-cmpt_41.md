# 13.1 修改变量

> 原文：[`dcic-world.org/2025-08-27/mutating-variables.html`](https://dcic-world.org/2025-08-27/mutating-variables.html)

| |   13.1.1 内存中修改变量 |
| --- | --- |
| |   13.1.2 变量修改和别名 |
| |   13.1.3 变量修改与数据字段修改 |
| |   13.1.4 函数调用中修改参数 |
| |   13.1.5 函数内修改顶层变量 |
| |   13.1.6 变量的多种角色 |

#### 13.1.1 内存中修改变量 "链接到此处")

现在我们已经介绍了堆的概念，让我们回顾一下我们使用变量来计算列表中元素总和的使用方法。以下是我们之前编写的代码（在介绍 `For` 循环中）：

```py
run_total = 0
for num in [5, 1, 7, 3]:
   run_total = run_total + num
```

让我们看看在运行此代码时目录和堆是如何更新的。在基本数据和堆中，我们指出基本数据（如数字、字符串和布尔值）不会放入堆中，因为它们没有内部结构。这些值存储在目录本身中。因此，`run_total` 的初始值存储在目录中。

目录

+   ```py
    run_total
    ```

    →

    ```py
    0
    ```

`for` 循环还设置了一个目录条目，这次是为用于引用列表元素的变量 `num`。当循环开始时，`num` 取得列表中的第一个值。因此，目录看起来如下：

目录

+   ```py
    run_total
    ```

    →

    ```py
    0
    ```

+   ```py
    num
    ```

    →

    ```py
    5
    ```

在 `for` 循环内部，我们计算 `run_total` 的新值。使用 `=` 告诉 Python 修改 `run_total` 的值。

> 现在行动！
> 
> > 这个修改是在目录还是堆中进行的？

由于基本数据值仅存储在目录中，这次更新修改了目录的内容。堆（heap）并未涉及：

目录

+   ```py
    run_total
    ```

    →

    ```py
    5
    ```

+   ```py
    num
    ```

    →

    ```py
    5
    ```

此过程继续：Python 将 `num` 移动到列表的下一个元素

目录

+   ```py
    run_total
    ```

    →

    ```py
    5
    ```

+   ```py
    num
    ```

    →

    ```py
    1
    ```

然后修改 `run_total` 的值

目录

+   ```py
    run_total
    ```

    →

    ```py
    6
    ```

+   ```py
    num
    ```

    →

    ```py
    1
    ```

这个过程会一直持续到处理完所有列表元素。当 `for` 循环结束时，目录内容如下：

目录

+   ```py
    run_total
    ```

    →

    ```py
    16
    ```

+   ```py
    num
    ```

    →

    ```py
    3
    ```

从这个例子中我们可以得到两个要点：

+   当我们使用 `=` 来更新与变量关联的值时，目录中该变量的条目会改变以反映新值。

+   `For` 循环在目录中引入了一个名称（程序员选择的，用于引用单个列表元素）。随着循环的进行，Python 更新与该名称关联的值，以引用每个后续元素。

> 练习
> 
> > 绘制以下程序的目录内容序列：
> > 
> > ```py
> > score = 0
> > score = score + 4
> > score = 10
> > ```
> > 
> 练习
> 
> > 绘制以下程序的目录内容序列：
> > 
> > ```py
> > count_long = 0
> > for word in ["here", "are", "some", "words"]:
> >   if len(word) > 4:
> >     count_long = count_long + 1
> > ```

#### 13.1.2 变量变异和别名 "链接到这里")

在变异结构中，我们看到了形式为`elena.acct.balance = 500`的语句如何导致`jorge.acct.balance`发生变化。如果我们直接更新变量的值而不是字段，这种相同的效果会发生吗？考虑以下示例：

```py
y = 5
x = y
```

> 现在行动！
> 
> > 运行此代码后，目录和堆看起来是什么样子？

由于`x`和`y`被分配了基本值，堆中没有值：

目录

+   ```py
    y
    ```

    →

    ```py
    5
    ```

+   ```py
    x
    ```

    →

    ```py
    5
    ```

> 现在行动！
> 
> > 如果现在评估`y = 3`，`x`的值会改变吗？

它不会。与`y`关联的值在目录中改变，但目录中没有`x`和`y`之间的连接。语句`x = y`表示“获取`y`的值并将其与目录中的`x`关联”。在此语句之后，`y`和`x`引用相同的值，但这种关系既没有被跟踪也没有被维护。如果我们将任一变量与新的值关联，就像我们用`y = 3`做的那样，该变量的目录条目——仅该变量的目录条目——将被更改为反映新值。因此，在评估`y = 3`后，目录如下所示：

目录

+   ```py
    y
    ```

    →

    ```py
    3
    ```

+   ```py
    x
    ```

    →

    ```py
    5
    ```

这个例子强调了别名仅在两个变量通过组件引用同一数据片段时发生，而不是当变量引用基本数据时。这是因为具有组件的数据存储在堆中，堆地址存储在目录中。注意，尽管`varname = ...`的使用仍然会影响目录，即使值是具有组件的数据。

> 现在行动！
> 
> > 在运行以下代码后，`ac2.balance`的值是多少？
> > 
> > ```py
> > ac1 = Account(8623, 600)
> > ac2 = ac1
> > ac1 = Account(8721, 350)
> > ```
> > 
> > 为此程序绘制目录和堆内容，并检查你的预测。

这三条语句都会导致目录发生变化；前两条会导致堆发生变化，但仅因为我们创建了新的数据片段。`ac1`和`ac2`在执行第二行后立即成为别名，但第三行打破了这种关系。

> 现在行动！
> 
> > 在运行以下代码后，`ac3.balance`的值是多少？
> > 
> > ```py
> > savings = 475
> > ac3 = Account(8722, savings)
> > savings = 500
> > ```
> > 
> > 为此程序绘制目录和堆内容，并检查你的预测。

由于`savings`的值存储在`ac3.balance`中，而不是名称`savings`本身，因此在第三行更新`savings`的值不会影响`ac3.balance`。

#### 13.1.3 变异变量与变异数据字段 "链接到这里")

我们现在已经看到了程序中两种不同的更新形式：在变异结构中对结构化数据字段的更新，以及在用`for`循环遍历列表时对与名称关联的值的更新。乍一看，这两种更新形式看起来很相似：

```py
acct1.balance = acct1.balance - 50
run_total = run_total + fst
```

它们都使用`=`运算符并在右侧计算新值。然而，左侧却有所不同：一个是结构化数据中的字段，而另一个是目录中的名称。这种差异最终证明是重要的：第一种形式更改了堆中存储的值，但目录保持不变，而第二种形式更新了目录，但堆保持不变。

在这一点上，你可能不会理解这种差异的重要性。但为了现在，让我们总结一下这些形式如何影响目录和堆。

> 策略：更新目录和堆的规则
> 
> > 总结来说，目录和内存更新的规则如下：
> > 
> > +   当使用数据构造函数时，我们向堆中添加内容
> > +   
> > +   当现有数据的字段被重新分配时，我们更新堆
> > +   
> > +   当第一次使用名称时，我们向目录中添加内容（这包括在函数调用时使用的参数和内部变量）
> > +   
> > +   当目录中已经存在的名称随后被赋予新值时，我们会更新目录）
> > +   
> 现在行动！
> 
> > 运行以下代码后，`ac3.balance`的值是多少？
> > 
> > ```py
> > ac2 = Account(8728, 200)
> > ac3 = ac2
> > print(ac3.balance)
> > ac2.balance = 500
> > print(ac3.balance)
> > ac2 = Account(8734, 350)
> > ac2.balance = 700
> > print(ac3.balance)
> > ```
> > 
> > 为这个程序绘制目录和堆的内容，并检查你的预测。

这个例子结合了变量更新和字段更新的操作。在第三行，`ac2`和`ac3`指向堆中的相同地址（其中包含 id 为`8728`的`Account`。在第四行立即更新`ac2.balance`之后，`ac2`和`ac3`中的余额都是 500。然而，第六行在堆中创建了一个新的`Account`，并将目录更新为使`ac2`指向这个新的`Account`。从那时起，`ac2`和`ac3`指向不同的账户，因此第七行在`ac2`中更新余额的更改不会影响`ac3`。

这个例子说明了`=`的不同用法及其细微差别和影响。程序的行为取决于`=`的左侧是变量名还是字段引用，以及右侧是基本数据还是具有组件的数据。我们将继续使用这些不同的组合来构建你对何时以及如何使用每种形式的理解。

#### 13.1.4 函数调用中参数的修改 "链接到此处")

在函数组合和目录中，我们展示了函数调用如何创建自己的局部目录段以存储在运行函数时引入的任何名称。现在我们有了更新与变量相关联的值的能力，我们应该重新审视这个主题，以了解这些更新在函数内部发生时会发生什么。

考虑以下两个函数：

```py
def add10(num: int):
  num = num + 10

def deposit10(ac: Account)
  ac.balance = ac.balance + 10
```

让我们在一个程序中使用这两个函数：

```py
x = 15
a = Account(8435, 500)
add10(x)
deposit10(a)
```

> 现在行动！
> 
> > 程序完成后，`x`和`a`的值是什么？

让我们为这个程序绘制目录和堆。

我们需要一种方法来区分局部目录和全局目录——现在最简单的方法可能是为`local-env-with-heap`添加一个使用标签“局部目录（函数名）”的表单。

在前两条语句之后但在函数调用之前，我们有以下内容：

目录

+   ```py
    x
    ```

    → `15`

+   ```py
    a
    ```

    → 1014

堆

+   1014:

    ```py
    Account(8435, 500)
    ```

调用`add10`创建了一个包含参数名称的局部目录：

目录

+   ```py
    num
    ```

    → `15`

堆

+   1014:

    ```py
    Account(8435, 500)
    ```

等等——为什么堆与局部目录并列？只有目录在函数调用期间被本地化。始终使用相同的堆。

`add10`的主体现在将目录中`num`的值更新为 25。这不会影响顶级目录中`x`的值，原因与我们在变量变异和别名中解释的相同，即基本数据引用的变量之间没有别名。因此，一旦函数完成并且局部目录被删除，与`x`相关联的值保持不变。

现在，让我们评估`deposit10(a)`的调用。与`add10`一样，我们创建了一个局部目录并为参数创建了一个条目。然而，目录中与该参数相关联的是什么？

目录

+   ```py
    ac
    ```

    → 1014

堆

+   1014:

    ```py
    Account(8435, 500)
    ```

> Do Now!
> 
> > 为什么我们在函数调用时没有创建一个新的`Account`数据？

记住我们创建堆中新数据时的规则：我们只在显式使用构造函数时创建堆数据。函数调用不涉及创建一个新的`Account`。与名称`a`相关联的任何内容都会与参数名称`ac`相关联。换句话说，我们在`a`和`ac`之间创建了一个别名。

在`deposit10`的主体中，我们更新了`ac`的余额，由于别名的原因，`ac`也是`a`的余额。由于没有局部堆栈，当函数调用结束时，新的余额会持续存在于`a`中。

我们在这里所做的只是将我们已经看到的片段组合在一起，只是在一个新的上下文中。我们传递参数并根据我们如何使用`=`来更新（局部）目录或堆栈。但这个例子突出了一个细节，当人们开始编写更新变量的函数时，这个细节最初会让他们感到困惑。

> 策略：在函数中更新值
> 
> > 如果你希望一个函数更新一个值，并且该更新在函数完成后持续存在，你必须将那个值放在数据的一个部分中。你不能让它与变量名称相关联的基本数据。

#### 13.1.5 在函数中修改顶级变量 "链接到这里")

让我们回到我们的银行示例，以说明更新变量能力非常有用的情况。考虑我们当前在银行创建新账户的过程，如下所示：

```py
ac5 = Account(8702, 435)
ac6 = Account(8703, 280)
ac7 = Account(8704, 375)
```

注意，每次我们创建一个`Account`时，都必须小心地增加 ID 号？如果我们犯了拼写错误或意外忘记这样做怎么办？

```py
ac5 = Account(8702, 435)
ac6 = Account(8703, 280)
ac7 = Account(8703, 375)
```

现在我们会有多个账户具有相同的 ID 号码，而实际上我们需要这些号码在所有账户中都是唯一的。为了避免这样的问题，我们应该有一个创建账户的函数，该函数接受初始余额作为输入并使用保证唯一的 ID 号码。

我们如何编写这样的函数？挑战是每次都能生成唯一的 ID 号码。如果我们使用一个变量来存储下一个可用的 ID 号码，并在创建新账户时更新它，会怎样？该函数可能看起来如下：

```py
nextID = 8000 # stores the next available ID number

def create_acct(init_bal: float) -> Account:
  new_acct = Account(nextID, init_bal)
  nextID = nextID + 1
  return(new_acct)
```

让我们运行这个程序，按照以下方式创建新账户：

```py
ac5 = create_acct(435)
ac6 = create_acct(280)
ac7 = create_acct(375)
```

> 现在行动！
> 
> > 将此代码复制到 Python 中并运行它。检查`ac5`、`ac6`和`ac7`是否都具有唯一的 ID 号码。

发生了什么？这三个都拥有相同的 ID `8000`。看起来我们对`nextID`的更新并没有起作用。实际上，它确实起作用了，但为了理解它是如何工作的，我们必须看看目录中发生了什么。

> 现在行动！
> 
> > 为此示例绘制内存图。

在我们设置`nextID`并定义函数后，我们的内存图如下所示：

目录

+   ```py
    nextID
    ```

    → `8000`

现在，让我们评估`ac5 = create_acct(435)`。我们调用`create_acct`，在创建`Account`之后但在更新`nextID`之前，得到以下局部目录。

目录

+   ```py
    init_bal
    ```

    → `435`

+   ```py
    new_acct
    ```

    → 1015

堆栈

+   1015:

    ```py
    Account(8000, 435)
    ```

> 现在行动！
> 
> > 你认为当我们运行`nextID = nextID + 1`时会发生什么？

让我们仔细运行这个程序。Python 首先评估`=`右侧的表达式（`nextID + 1`）。`nextID`不在局部目录中，因此 Python 从顶级目录检索其值（`8000`）。因此，这个计算变成了`nextID = 8001`。

这里的问题是 Python 如何处理`nextID = 8001`：我们目前既有函数调用的局部目录，也有顶级目录。哪个应该获得`nextID`的新值？由于局部目录是活动的，Python 将`nextID`的值设置在那里。

目录

+   ```py
    init_bal
    ```

    → `435`

+   ```py
    new_acct
    ```

    → 1015

+   ```py
    nextID
    ```

    → `8001`

堆栈

+   1015:

    ```py
    Account(8000, 435)
    ```

让我们重复一下：Python 使用顶级目录中的`nextID`值计算了`nextID + 1`，因为在局部目录中没有`nextID`的值。但是，`nextID`值的设置可以在局部目录中发生。因此，当`create_acct`完成时，顶级目录中的`nextID`值保持不变。结果，所有账户都获得了相同的值。

我们试图进行的计算——更新顶级变量——是正常的。问题是 Python（合理地）默认使用局部目录。为了使其工作，我们需要告诉 Python 我们想要在顶级目录中更新`next_id`。以下是执行此操作的`create_acct`版本：

```py
def create_acct(init_bal: float) -> Account:
  global nextID
  new_acct = Account(nextID, init_bal)
  nextID = nextID + 1
  return(new_acct)
```

`global`关键字告诉 Python 在顶级目录中更新给定的变量，而不是在局部目录中。一旦我们进行此修改，我们创建的每个账户都将获得唯一的 ID 号码。

> 负责任计算：保持 ID 不可预测
> 
> > 虽然这种生成唯一 ID 的一般模式是可行的，但在实际操作中我们不应该使用连续的数字。连续的数字是可以猜测的：如果存在一个账户`8000`，那么必然存在一个账户`8001`，以此类推。可猜测的账户号码可能会让那些不断尝试猜测有效 ID 的人更容易登录网站或以其他方式访问信息。
> > 
> > 相反，我们会在存储`nextID`值时使用一个比“加 1”更不可预测的计算。目前，我们向您展示的模式是可行的。然而，如果您正在构建一个真实的系统，您可能希望使这个计算更加复杂。

#### 13.1.6 变量的多种角色 "链接至此")

到目前为止，我们已经在一个目录中使用了变量的单一编码结构来完成多个目的。值得退一步并明确指出这些目的。一般来说，变量服务于以下目的之一：

1.  跟踪计算的进度（例如，`for`循环中结果的运行值）

1.  在对单个函数的多次调用中维护信息（例如，`next-id`变量）

1.  在计算中命名局部或中间值

这些用途都涉及不同的编程模式。第一个是在函数内部创建一个局部变量。后两个创建顶层变量，并在修改内容的功能中需要使用`global`。然而，第三个与第二个不同，因为第三个只打算由一个函数使用。理想情况下，会有一种方法不将变量暴露给所有函数。确实，许多编程语言（包括 Pyret）都使这变得很容易。然而，在 Python 的入门级概念中，这要困难得多。第四个更多地关于局部名称而不是变量，因为我们的代码在变量创建后永远不会更新其值。

我们明确指出这三个角色，正是因为它们调用了不同的代码模式，尽管使用了相同精细的概念（将新值赋给变量）。当您面对一个新的编程问题时，您可以问自己这个问题是否涉及这些目的之一，并据此指导您选择使用哪种模式。

#### 13.1.1 内存中变量修改 "链接至此")

现在我们已经介绍了堆的概念，让我们回顾一下我们使用变量来计算列表中元素总和的方法。下面是我们之前编写的代码（在介绍`For`循环中）：

```py
run_total = 0
for num in [5, 1, 7, 3]:
   run_total = run_total + num
```

让我们看看在运行此代码时目录和堆是如何更新的。在基本数据和堆中，我们指出基本数据（如数字、字符串和布尔值）不会放入堆中，因为它们没有内部结构。这些值存储在目录本身中。因此，`run_total`的初始值存储在目录中。

目录

+   ```py
    run_total
    ```

    →

    ```py
    0
    ```

`for`循环还设置了一个目录条目，这次是为变量`num`，它用于引用列表元素。当循环开始时，`num`取列表中的第一个值。因此，目录看起来如下：

目录

+   ```py
    run_total
    ```

    →

    ```py
    0
    ```

+   ```py
    num
    ```

    →

    ```py
    5
    ```

在`for`循环内部，我们计算`run_total`的新值。使用`=`告诉 Python 修改`run_total`的值。

> 立刻行动！
> 
> > 这个修改是在目录还是堆中进行的？

由于基本数据值只存储在目录中，这个更新修改了目录的内容。堆没有参与：

目录

+   ```py
    run_total
    ```

    →

    ```py
    5
    ```

+   ```py
    num
    ```

    →

    ```py
    5
    ```

此过程会继续：Python 将`num`推进到下一个列表元素

目录

+   ```py
    run_total
    ```

    →

    ```py
    5
    ```

+   ```py
    num
    ```

    →

    ```py
    1
    ```

然后修改`run_total`的值

目录

+   ```py
    run_total
    ```

    →

    ```py
    6
    ```

+   ```py
    num
    ```

    →

    ```py
    1
    ```

此过程会一直持续，直到列表中的所有元素都被处理完毕。当 for 循环结束时，目录内容如下：

目录

+   ```py
    run_total
    ```

    →

    ```py
    16
    ```

+   ```py
    num
    ```

    →

    ```py
    3
    ```

从这个例子中我们可以得到两个启示：

+   当我们使用`=`来更新与变量关联的值时，变量在目录中的条目会改变以反映新值。

+   `For`循环在目录中引入了一个名称（程序员选择的，用于引用单个列表元素）。随着循环的进行，Python 会更新与该名称关联的值，以引用每个后续元素。

> 练习
> 
> > 绘制以下程序的目录内容序列：
> > 
> > ```py
> > score = 0
> > score = score + 4
> > score = 10
> > ```
> > 
> 练习
> 
> > 绘制以下程序的目录内容序列：
> > 
> > ```py
> > count_long = 0
> > for word in ["here", "are", "some", "words"]:
> >   if len(word) > 4:
> >     count_long = count_long + 1
> > ```

#### 13.1.2 变量修改和别名 "链接到这里")

在修改结构中，我们看到了形式为`elena.acct.balance = 500`的语句如何导致`jorge.acct.balance`的改变。如果我们直接更新变量的值而不是字段，会发生同样的效果吗？考虑以下示例：

```py
y = 5
x = y
```

> 立刻行动！
> 
> > 运行此代码后，目录和堆看起来是什么样子？

由于`x`和`y`被分配了基本值，堆中没有值：

目录

+   ```py
    y
    ```

    →

    ```py
    5
    ```

+   ```py
    x
    ```

    →

    ```py
    5
    ```

> 立刻行动！
> 
> > 如果我们现在计算`y = 3`，`x`的值会改变吗？

它不会。目录中与`y`关联的值发生了变化，但在目录中`x`和`y`之间没有联系。语句`x = y`表示“获取`y`的值并将其与目录中的`x`关联”。在这条语句之后，`y`和`x`指向相同的值，但这种关系既没有被跟踪也没有被维护。如果我们将任一变量与新的值关联，就像我们对`y = 3`所做的那样，该变量的目录条目——<wbr>以及仅该变量的目录条目——<wbr>将更改为反映新值。因此，我们在评估`y = 3`后目录看起来如下所示：

目录

+   ```py
    y
    ```

    →

    ```py
    3
    ```

+   ```py
    x
    ```

    →

    ```py
    5
    ```

这个例子强调了别名仅在两个变量通过组件引用相同的数据时发生，而不是当变量引用基本数据时。这是因为具有组件的数据存储在堆中，堆地址存储在目录中。请注意，尽管如此，使用`varname = ...`仍然会影响目录，即使值是具有组件的数据。

> 立刻行动！
> 
> > 在运行以下代码后，`ac2.balance`的值是多少？
> > 
> > ```py
> > ac1 = Account(8623, 600)
> > ac2 = ac1
> > ac1 = Account(8721, 350)
> > ```
> > 
> > 为此程序绘制目录和堆的内容，并检查你的预测。

这三条语句都会导致目录发生变化；前两条会导致堆发生变化，但仅因为我们创建了新的数据。`ac1`和`ac2`在运行第二条语句后立即成为别名，但第三条语句打破了这种关系。

> 立刻行动！
> 
> > 在运行以下代码后，`ac3.balance`的值是多少？
> > 
> > ```py
> > savings = 475
> > ac3 = Account(8722, savings)
> > savings = 500
> > ```
> > 
> > 为此程序绘制目录和堆的内容，并检查你的预测。

由于`savings`的值存储在`ac3.balance`中，而不是名称`savings`本身，因此在第三行更新`savings`的值不会影响`ac3.balance`。

#### 13.1.3 可变变量与可变数据字段 "链接至此")

我们现在已经看到了程序中两种不同的更新形式：在可变结构中更新结构化数据的字段，以及在`for`循环计算列表时更新与名称关联的值。乍一看，这两种更新形式看起来很相似：

```py
acct1.balance = acct1.balance - 50
run_total = run_total + fst
```

这两种都使用`=`运算符并在右侧计算新值。然而，左侧却有所不同：一个是结构化数据中的字段，而另一个是目录中的名称。这种差异最终证明是重要的：第一种形式更改了堆中存储的值，但目录保持不变，而第二种更新了目录但堆保持不变。

在这一点上，你可能不会欣赏这种差异的重要性。但就目前而言，让我们总结一下这些形式如何影响目录和堆。

> 策略：更新目录和堆的规则
> 
> > 总结，目录和内存更新的规则如下：
> > 
> > +   当使用数据构造函数时，我们向堆中添加内容
> > +   
> > +   当现有数据的一个字段被重新分配时，我们更新堆
> > +   
> > +   当第一次使用一个名称时，我们向目录中添加（这包括在函数调用时使用的参数和内部变量）
> > +   
> > +   当目录中已经存在的名称随后被分配新值时，我们更新目录
> > +   
> 现在行动！
> 
> > 在运行以下代码后，`ac3.balance` 的值是多少？
> > 
> > ```py
> > ac2 = Account(8728, 200)
> > ac3 = ac2
> > print(ac3.balance)
> > ac2.balance = 500
> > print(ac3.balance)
> > ac2 = Account(8734, 350)
> > ac2.balance = 700
> > print(ac3.balance)
> > ```
> > 
> > 为这个程序绘制目录和堆的内容，并检查你的预测。

这个例子结合了变量更新和字段更新的内容。在第三行，`ac2` 和 `ac3` 指向堆中的相同地址（其中包含 id 为 `8728` 的 `Account`。在第四行立即更新 `ac2.balance` 之后，`ac2` 和 `ac3` 中的余额都是 500。然而，第六行在堆中创建了一个新的 `Account` 并更新目录，使 `ac2` 指向这个新的 `Account`。从那时起，`ac2` 和 `ac3` 指向不同的账户，所以第七行在 `ac2` 中更新的余额不会影响 `ac3`。

这个例子说明了不同使用 `=` 的微妙之处和影响。程序的行为取决于 `=` 的左侧是变量名还是字段引用，以及右侧是基本数据还是具有组件的数据。我们将继续使用这些不同的组合来构建你对何时以及如何使用每个组合的理解。

#### 13.1.4 函数调用中参数的修改 "链接到此处")

在 函数组合和目录 中，我们展示了函数调用如何创建自己的局部目录段来存储在运行函数时引入的任何名称。现在我们有了更新与变量相关联的值的能力，我们应该重新审视这个话题，以了解这些更新在函数内部发生时会发生什么。

考虑以下两个函数：

```py
def add10(num: int):
  num = num + 10

def deposit10(ac: Account)
  ac.balance = ac.balance + 10
```

让我们在一个程序中使用这两个函数：

```py
x = 15
a = Account(8435, 500)
add10(x)
deposit10(a)
```

> 现在行动！
> 
> > 程序完成后，`x` 和 `a` 的值是什么？

让我们绘制这个程序的目录和堆。

我们需要一种方法来区分局部目录和全局目录——现在最简单的方法可能是为 `local-env-with-heap` 添加一个表单，使用标签“局部目录（有趣的名字）”。

在前两行之后但在函数调用之前，我们有以下内容：

目录

+   ```py
    x
    ```

    → `15`

+   ```py
    a
    ```

    → 1014

堆

+   1014:

    ```py
    Account(8435, 500)
    ```

调用 `add10` 创建了一个包含参数名称的局部目录：

目录

+   ```py
    num
    ```

    → `15`

堆

+   1014:

    ```py
    Account(8435, 500)
    ```

等等——为什么堆被列在局部目录旁边？只有目录在函数调用期间被本地化。始终使用相同的堆。

`add10`的主体现在更新了目录中`num`的值为 25。这不会影响顶层目录中`x`的值，原因与我们在变量突变和别名中解释的相同，即基本数据引用的变量之间没有别名。因此，一旦函数完成并且局部目录被删除，与`x`关联的值保持不变。

现在，让我们评估`deposit10(a)`的调用。与`add10`一样，我们创建了一个局部目录并为参数创建了一个条目。然而，在目录中与该参数关联的是什么？

目录

+   ```py
    ac
    ```

    → 1014

堆

+   1014:

    ```py
    Account(8435, 500)
    ```

> 立即行动！
> 
> > 为什么我们在函数调用时没有创建一个新的`Account`数据？

记住我们创建堆中新数据时的规则：我们只在显式使用构造函数时创建堆数据。函数调用不涉及创建一个新的`Account`。与名称`a`关联的任何内容都会与参数名称`ac`关联。换句话说，我们在`a`和`ac`之间创建了一个别名。

在`deposit10`的主体中，我们更新了`ac`的余额，由于别名，`ac`也是`a`的余额。由于没有局部堆，当函数调用结束时，新的余额会持续存在于`a`中。

我们在这里所做的只是将我们已经看到的片段组合起来，只是在一个新的环境中。我们传递参数并根据我们如何使用`=`来更新（局部）目录或堆。但这个例子突出了一个细节，当人们开始编写更新变量的函数时，这个细节最初会让他们感到困惑。

> 策略：在函数中更新值
> 
> > 如果你希望一个函数更新一个值，并且这个更新在函数完成后仍然持续，你必须将这个值放在一个数据结构中。你不能让它成为与变量名相关的基本数据。

#### 13.1.5 在函数中修改顶层变量 "链接至此")

让我们回到我们的银行示例，以说明在哪种情况下更新变量的能力非常有用。考虑我们当前在银行创建新账户的过程，如下所示：

```py
ac5 = Account(8702, 435)
ac6 = Account(8703, 280)
ac7 = Account(8704, 375)
```

注意，每次我们创建一个`Account`时，我们必须小心地增加 ID 号码？如果我们犯了拼写错误或意外忘记了这样做怎么办？

```py
ac5 = Account(8702, 435)
ac6 = Account(8703, 280)
ac7 = Account(8703, 375)
```

现在我们会有多个具有相同 ID 号码的账户，而实际上我们需要这些号码在所有账户中都是唯一的。为了避免这样的问题，我们应该有一个创建账户的函数，它接受初始余额作为输入并使用一个保证唯一的 ID 号码。

我们如何编写这样的函数？挑战在于每次都能生成唯一的 ID 号码。如果我们使用一个变量来存储下一个可用的 ID 号码，并在创建新账户时更新它，这个函数可能看起来是这样的：

```py
nextID = 8000 # stores the next available ID number

def create_acct(init_bal: float) -> Account:
  new_acct = Account(nextID, init_bal)
  nextID = nextID + 1
  return(new_acct)
```

让我们运行这个程序，按照以下方式创建新账户：

```py
ac5 = create_acct(435)
ac6 = create_acct(280)
ac7 = create_acct(375)
```

> 立即行动！
> 
> > 将此代码复制到 Python 中并运行它。检查 `ac5`、`ac6` 和 `ac7` 是否都有唯一的 ID 号码。

发生了什么？这三个都有相同的 ID `8000`。看起来我们的 `nextID` 更新并没有起作用。实际上，它确实起作用了，但为了理解它是如何起作用的，我们必须看看目录中发生了什么。

> 现在就做！
> 
> > 为此示例绘制内存图。

在我们设置 `nextID` 并定义函数之后，我们的内存图如下所示：

目录

+   ```py
    nextID
    ```

    → `8000`

现在，让我们评估 `ac5 = create_acct(435)`。我们调用 `create_acct`，在创建 `Account` 但在更新 `nextID` 之前，得到以下本地目录。

目录

+   ```py
    init_bal
    ```

    → `435`

+   ```py
    new_acct
    ```

    → 1015

堆

+   1015:

    ```py
    Account(8000, 435)
    ```

> 现在就做！
> 
> > 你认为当我们运行 `nextID = nextID + 1` 时会发生什么？

让我们仔细运行这个。Python 首先评估 `=` 的右侧（`nextID + 1`）。`nextID` 不在本地目录中，因此 Python 从顶级目录检索其值（`8000`）。因此，这个计算变为 `nextID = 8001`。

这里的问题是 Python 如何处理 `nextID = 8001`：我们目前既有函数调用的本地目录，也有顶级目录。哪个应该获得 `nextID` 的新值？由于本地目录是活动的，Python 在那里设置 `nextID` 的值。

目录

+   ```py
    init_bal
    ```

    → `435`

+   ```py
    new_acct
    ```

    → 1015

+   ```py
    nextID
    ```

    → `8001`

堆

+   1015:

    ```py
    Account(8000, 435)
    ```

让我们重复一下：Python 使用顶级目录中的 `nextID` 值来计算 `nextID + 1`，因为在本地目录中没有 `nextID` 的值。但是，`nextID` 值的设置可以在本地目录中发生。因此，当 `create_acct` 完成时，顶级目录中的 `nextID` 值保持不变。结果，所有账户都获得相同的值。

我们试图进行的计算——更新顶级变量——是完全可以的。问题是 Python（合理地）默认使用本地目录。为了使这可行，我们需要告诉 Python 我们想要更新顶级目录中的 `next_id`。以下是执行此操作的 `create_acct` 版本：

```py
def create_acct(init_bal: float) -> Account:
  global nextID
  new_acct = Account(nextID, init_bal)
  nextID = nextID + 1
  return(new_acct)
```

`global` 关键字告诉 Python 在顶级目录中而不是在本地目录中更新给定的变量。一旦我们进行这种修改，我们创建的每个账户都将获得一个唯一的 ID 号码。

> 负责任计算：保持 ID 不可预测
> 
> > 虽然这种生成唯一 ID 的一般模式是可行的，但在实践中我们不应该使用连续的数字。连续的数字是可预测的：如果有一个账户 `8000`，那么肯定有一个账户 `8001`，依此类推。可预测的账户号码可能会使那些不断尝试猜测有效 ID 的人更容易登录网站或其他方式访问信息。
> > 
> > 相反，我们会使用一个比“加 1”更不可预测的计算来存储 `nextID` 值。现在，我们向你展示的模式是好的。然而，如果你正在构建一个真实的系统，你可能会想使这个计算更复杂一些。

#### 13.1.6 变量的多种角色 "链接至此")

到目前为止，我们已经使用了目录中变量的单一编码结构来完成多个目的。值得退一步并明确指出这些。一般来说，变量服务于以下目的之一：

1.  跟踪计算的进度（例如，`for` 循环中结果的运行值）

1.  在对单个函数多次调用中维护信息（例如，`next-id` 变量）

1.  在计算中对局部或中间值命名

这些用途中的每一个都涉及不同的编程模式。第一个是在函数内部局部创建一个变量。后两个创建顶层变量，并需要在修改内容的函数中使用 `global`。然而，第三个与第二个不同，因为第三个仅意味着由单个函数使用。理想情况下，会有一种方法不将变量暴露给第三个情况中的所有函数。确实，许多编程语言（包括 Pyret）都使这样做变得容易。然而，在 Python 的入门级概念中实现这一点更难。第四个更多地关于局部名称而不是变量，因为我们的代码在变量创建后永远不会更新其值。

我们明确指出这三个角色，正是因为它们调用了不同的代码模式，尽管使用了相同精细的概念（将新值赋给变量）。当你面对一个新的编程问题时，你可以问自己这个问题是否涉及这些目的之一，并使用它来指导你选择使用哪种模式。
