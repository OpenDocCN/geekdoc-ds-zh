# 5.2 处理列表

> 原文：[`dcic-world.org/2025-08-27/processing-lists.html`](https://dcic-world.org/2025-08-27/processing-lists.html)

|   5.2.1 制作列表和拆分列表 |
| --- |
|   5.2.2 一些示例练习 |
|   5.2.3 结构化问题具有标量答案 |
|   5.2.3.1 `my-len`: 示例 |
|   5.2.3.2 `my-sum`: 示例 |
|   5.2.3.3 从示例到代码 |
|   5.2.4 结构化问题转换列表 |
|   5.2.4.1 `my-doubles`: 示例和代码 |
|   5.2.4.2 `my-str-len`: 示例和代码 |
|   5.2.5 结构化问题从列表中选择 |
|   5.2.5.1 `my-pos-nums`: 示例和代码 |
|   5.2.5.2 `my-alternating`: 示例和代码 |
|   5.2.6 结构化问题在放宽域上 |
|   5.2.6.1 `my-max`: 示例 |
|   5.2.6.2 `my-max`: 从示例到代码 |
|   5.2.7 更多结构化问题具有标量答案 |
|   5.2.7.1 `my-avg`: 示例 |
|   5.2.8 结构化问题具有累加器 |
|   5.2.8.1 `my-running-sum`: 第一次尝试 |
|   5.2.8.2 `my-running-sum`: 示例和代码 |
|   5.2.8.3 `my-alternating`: 示例和代码 |
|   5.2.9 处理多个答案 |
|   5.2.9.1 `uniq`: 问题设置 |
|   5.2.9.2 `uniq`: 示例 |
|   5.2.9.3 `uniq`: 代码 |
|   5.2.9.4 `uniq`: 减少计算 |
|   5.2.9.5 `uniq`: 示例和代码变体 |
|   5.2.9.6 `uniq`: 为什么生成列表？ |
|   5.2.10 单态列表和多态类型 |

我们已经看到了 [从表格到列表] 几个列表处理函数的例子。它们在高级表格处理中特别有用。然而，列表在程序中经常出现，并且它们自然地出现，因为在我们生活中许多事物——从购物清单到待办事项清单到检查清单——都是自然列表。思考我们在处理列表时可能想要的函数，我们可以观察到关于列表中数据类型的一些有趣的类别：

+   一些列表函数是通用的，可以在任何类型的列表上操作：例如，列表的长度与其包含的值类型无关；

+   一些至少是针对数据类型的特定：例如，总和假设所有值都是数字（尽管它们可能是年龄或价格或其他由数字表示的信息）；并且

+   一些则介于两者之间：例如，最大值函数适用于任何可比较值的列表，如数字或字符串。

这看起来有很多种类，我们可能会担心我们如何处理这么多不同种类的函数。幸运的是，也许令人惊讶的是，有一种标准的方法，我们可以用它来思考编写所有这些函数！理解和内化这个过程是本章的目标。

#### 5.2.1 创建列表和拆分列表 "链接到此处")

到目前为止，我们已经看到了一种创建列表的方法：通过编写 `[list: …]`。虽然有用，但这样编写列表实际上隐藏了它们的真实本质。每个列表实际上都有两部分：一个第一个元素和列表的其余部分。列表的其余部分本身也是一个列表，因此它也有两部分……以此类推。

考虑列表 `[list: 1, 2, 3]`。它的第一个元素是 `1`，其余的是 `[list: 2, 3]`。对于这个第二个列表，第一个元素是 `2`，其余的是 `[list: 3]`。

> 现在就做！
> 
> > 拆分这个第三个列表。

对于第三个列表，第一个元素是 `3`，其余的是 `[list: ]`，即空列表。在 Pyret 中，我们还有另一种编写空列表的方法：`empty`。

列表是结构化数据的一个实例：具有组成部分和组成部分形状的良好定义格式的数据。列表通过第一个元素和其余元素进行格式化。表格在一定程度上是结构化的：它们通过行和列进行格式化，但列名在所有表格中并不一致。结构化数据在编程中很有价值，因为可预测的格式（结构）让我们能够根据该结构编写程序。我们这是什么意思呢？

编程语言可以（并且确实！）提供用于拆分结构化数据的内置操作符。这些操作符被称为访问器。访问器是在数据类型的结构上定义的，与数据内容无关。在列表的情况下，有两个访问器：`first` 和 `rest`。我们通过编写一个表达式，然后是一个点（`.`），然后是访问器名称来使用访问器。正如我们在表格中看到的那样，点意味着“深入挖掘”。因此：

```py
l1 = [list: 1, 2, 3]
e1 = l1.first
l2 = l1.rest
e2 = l2.first
l3 = l2.rest
e3 = l3.first
l4 = l3.rest

check:
  e1 is 1
  e2 is 2
  e3 is 3
  l2 is [list: 2, 3]
  l3 is [list: 3]
  l4 is empty
end
```

> 现在行动起来！
> 
> > 表格的访问器是什么？

访问器提供了一种根据其结构拆分数据的方法（我们很快就会看到另一种方法）。有没有一种方法也可以根据其结构构建数据？到目前为止，我们一直在使用 `[list: ...]` 形式构建列表，但这并没有强调 `rest` 本身也是一个列表的结构约束。用于构建列表的结构化操作符将清楚地显示一个 `first` 元素和一个自身也是列表的 `rest`。用于构建结构化数据的操作符称为构造器。

列表的构造器称为 `link`。它接受两个参数：一个 `first` 元素，以及构建列表的基础（`rest` 部分）。以下是一个使用 `link` 创建三个元素列表的示例。

```py
link(1, link(2, link(3, empty)))
```

`link` 形式创建的底层列表数据与我们的前一个 `[list: ...]` 操作相同，如下面的检查所确认的：

```py
check:
  [list: 1, 2, 3] is link(1, link(2, link(3, empty)))
end
```

> 现在行动起来！
> 
> > 看看这两种写列表的形式：你注意到了什么差异？
> > 
> 现在行动起来！
> 
> > 使用 `link` 形式编写一个包含 `"lychee"`、`"dates"`、`"mango"` 和 `"durian"` 的四个元素列表。

做完这个练习后，你可能会想知道为什么有人会使用 `link` 形式：它更冗长，并且使得单个元素更难辨认。这种形式对人类来说并不方便。但这对程序来说将非常有价值！

尤其是链接形式突出了我们实际上有两种不同的列表结构。有些列表是空的。所有其他列表都是非空列表，这意味着它们至少有一个 `link`。有些列表可能有更复杂的结构（我们稍后会看到），但所有列表都有这个共同点。具体来说，一个列表要么

+   空的（写成 `empty` 或 `[list: ]`），或者

+   非空（写成 `link(…, …)` 或 `[list: ]`，括号内至少有一个值），其中其余部分也是一个列表（因此可能进一步是空的或非空的，……）。

这意味着我们实际上有两个列表的结构特征，这两个特征在编写列表程序时都很重要：

1.  列表可以是空的或非空的

1.  非空列表有一个第一个元素和列表的其余部分

让我们利用这两个结构特征来编写一些处理列表的程序！

#### 5.2.2 一些示例练习 "链接到此处")

为了说明我们的思考过程，让我们通过几个具体的列表处理函数的例子来进行分析。所有这些函数都将消耗列表；其中一些甚至会产生列表。一些会转换它们的输入（如`map`），一些会从它们的输入中选择（如`filter`），还有一些会聚合它们的输入。由于其中一些函数已经在 Pyret 中存在，我们将用前缀`my-`来命名它们以避免错误。请确保在函数体内一致地使用`my-`名称。正如我们将看到的，我们可以使用一种标准策略来编写所有这些函数：学习这种策略是本章的目标。

#### 5.2.3 结构性问题 "链接至此")

让我们为上述描述的几个函数写出一些例子。我们将以非常具体、风格化的方式来编写例子。首先，我们应该始终构造至少两个例子：一个包含`empty`，另一个至少包含一个`link`，这样我们就涵盖了两种非常广泛的列表类型。然后，我们应该有更多针对问题中所述列表类型的特定例子。最后，我们应该有更多例子来说明我们如何思考解决问题。

##### 5.2.3.1 `my-len`：例子 "链接至此")

我们还没有精确地定义列表的“长度”是什么意思。当我们试图编写一个例子时，我们立即面临这个问题。空列表`empty`的长度是多少？

> 现在行动起来！
> 
> > 你认为呢？

两个常见的例子是`0`和`1`。后者`1`看起来是合理的。然而，如果你将列表写成`[list: ]`，现在它看起来就不那么对了：这显然（正如名称`empty`也暗示的）是一个空列表，而空列表中没有任何元素。因此，传统上我们声明

```py
my-len(empty) is 0
```

那么，像`[list: 7]`这样的列表怎么样？很明显，它包含一个元素（`7`），所以

```py
my-len([list: 7]) is 1
```

类似地，对于像`[list: 7, 8, 9]`这样的列表，我们会说

```py
my-len([list: 7, 8, 9]) is 3
```

现在，让我们从不同的角度审视最后一个例子。考虑参数`[list: 7, 8, 9]`。它的第一个元素是`7`，其余的是`[list: 8, 9]`。好吧，`7`是一个数字，不是一个列表；但`[list: 8, 9]`显然是一个列表，因此我们可以询问它的长度。`my-len([list: 8, 9])`是什么？它有两个元素，所以

```py
my-len([list: 8, 9]) is 2
```

该列表的第一个元素是`8`，其余的是`[list: 9]`。它的长度是多少？请注意，我们之前已经提出了一个非常类似的问题，即列表`[list: 7]`的长度。但是`[list: 7]`不是我们从`[list: 7, 8, 9]`开始的子列表，而`[list: 9]`是。并且使用与之前相同的推理，我们可以说

```py
my-len([list: 9]) is 1
```

当然，这个列表的其余部分是空列表，其长度我们已决定是`0`。

将这些例子放在一起，并以其他形式写出`empty`，我们得到以下内容：

```py
my-len([list: 7, 8, 9]) is 3
my-len([list:    8, 9]) is 2
my-len([list:       9]) is 1
my-len([list:        ]) is 0
```

另一种我们可以这样写（注意右侧）的方式是

```py
my-len([list: 7, 8, 9]) is 1 + 2
my-len([list:    8, 9]) is 1 + 1
my-len([list:       9]) is 1 + 0
my-len([list:        ]) is     0
```

每个加法操作右侧的`2`、`1`和`0`是从哪里来的？这些是输入列表`rest`组件的长度。在前面的示例块中，我们将这些长度作为明确的示例写出来。让我们用产生这些长度的`my-len`表达式来替换数字`2`、`1`和`0`：

```py
my-len([list: 7, 8, 9]) is 1 + my-len([list: 8, 9])
my-len([list:    8, 9]) is 1 + my-len([list:    9])
my-len([list:       9]) is 1 + my-len([list:     ])
my-len([list:        ]) is 0
```

从这个例子中，也许你可以开始看到一种模式。对于空列表，长度是`0`。对于非空列表，它是`1`（第一个元素对列表长度的“贡献”）加上剩余列表的长度。换句话说，我们可以使用计算剩余列表的`my-len`的结果来计算整个列表的答案。

> 现在行动起来！
> 
> > 本节中的每个示例都对表达式`my-len([list: 7, 8, 9])`进行了不同的检查。以下是这些示例一起展示，以及一个最后使用`rest`操作的示例：
> > 
> > ```py
> > my-len([list: 7, 8, 9]) is 3
> > my-len([list: 7, 8, 9]) is 1 + 2
> > my-len([list: 7, 8, 9]) is 1 + my-len([list: 8, 9])
> > my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)
> > ```
> > 
> > 确认你同意这些断言中的每一个。也要确认你是否理解了每个`is`表达式的右侧是如何从其上面的右侧推导出来的。这个练习的目的是确保你相信最后一个检查（我们将将其转换为代码）与第一个（我们在理解问题时写下来的）是等价的。

##### 5.2.3.2 `my-sum`：示例 "链接至此")

让我们重复这个过程，在第二个函数上开发示例，这次是一个计算数字列表元素总和的函数。列表`[list: 7, 8, 9]`的总和是多少？通过手工加起来，结果应该是`24`。让我们通过示例看看这是如何实现的。

暂时忽略空列表，以下是一些显示求和计算的示例：

```py
my-sum([list: 7, 8, 9]) is 7 + 8 + 9
my-sum([list:    8, 9]) is     8 + 9
my-sum([list:       9]) is         9
```

通过替换，它与

```py
my-sum([list: 7, 8, 9]) is 7 + my-sum([list: 8, 9])
my-sum([list:    8, 9]) is 8 + my-sum([list:    9])
my-sum([list:       9]) is 9 + my-sum([list:     ])
```

从这个例子中，我们可以看到空列表的总和必须是`0`：零被称为加法恒等元：一种说法，即向任何数字 N 加上零，你得到 N。因此，它有道理会是空列表的长度，因为空列表没有项目可以贡献到总和。你能找出乘法恒等元是什么吗？

```py
my-sum(empty) is 0
```

再次观察，我们如何使用计算列表剩余部分的`my-sum`的结果来计算整个列表的结果。

##### 5.2.3.3 从示例到代码 "链接至此")

在开发这些示例之后，我们现在想利用它们来开发一个程序，该程序可以计算任何列表的长度或总和，而不仅仅是这些示例中使用的特定列表。正如我们在前面的章节中所做的那样，我们将利用示例中的模式来找出如何定义通用函数。

这是`my-len`的最后一个示例版本，这次在`is`的右侧明确使用了`rest`：

```py
my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)
my-len([list:    8, 9]) is 1 + my-len([list:    8, 9].rest)
my-len([list:       9]) is 1 + my-len([list:       9].rest)
my-len([list:        ]) is 0
```

正如我们在图像上开发函数时做的那样，让我们尝试识别这些示例的共同部分。我们首先注意到，大多数示例有很多共同之处，除了 `[list: ]` (`empty`) 情况。所以让我们将它们分成两组示例：

```py
my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)
my-len([list:    8, 9]) is 1 + my-len([list:    8, 9].rest)
my-len([list:       9]) is 1 + my-len([list:       9].rest)

my-len([list:        ]) is 0
```

通过这种分离（遵循我们之前提到的列表的结构特征之一），一个更清晰的模式出现了：对于非空列表（称为 `someList`），我们通过以下表达式计算其长度：

```py
1 + my-len(someList.rest)
```

因此，总的来说，我们的 `my-len` 程序需要确定其输入列表是否为空或非空，在非空情况下使用带有 `.rest` 的此表达式。我们如何根据列表的结构来指示不同的代码？

Pyret 有一个名为 `cases` 的构造，用于区分结构化数据类型中的不同形式。当与列表一起使用时，`cases` 表达式的一般形状是：

```py
cases (List) e:
  | empty      => …
  | link(f, r) => … f … r …
end
```

其中大部分部分是固定的，但有一些你可以自由更改：

+   `e` 是一个需要其值为列表的表达式；它可以是绑定到列表的变量，或者是一个计算结果为列表的复杂表达式。

+   `f` 和 `r` 是分配给列表的首部和剩余部分的名称。你可以选择任何你喜欢的名称，尽管在 Pyret 中，使用 `f` 和 `r` 是一种惯例。偶尔使用不同的名称可以帮助学生记住他们可以选择如何标记 `first` 和 `rest` 组件。这特别有用，因为 `first` 有一个特定问题的含义（例如，在价格列表中的 `price` 等）。

每个 `=>` 的右侧都是一个表达式。

这里是如何在这个实例中使用 `cases` 的。Pyret 首先评估 `e`。然后检查结果值是否确实是一个列表；如果不是，它将因错误而停止。如果是列表，Pyret 会检查它是什么类型的列表。如果是空列表，它将运行 `empty` 子句后面的表达式。否则，列表不为空，这意味着它有一个首部和剩余部分；Pyret 分别将 `f` 和 `r` 绑定到这两部分，然后评估 `link` 子句后面的表达式。

> 练习
> 
> > 尝试在 `e` 位置使用非列表——例如，一个数字——看看会发生什么！

现在让我们使用 `cases` 来定义 `my-len`：

```py
fun my-len(l):
  cases (List) l:
    | empty      => 0
    | link(f, r) => 1 + my-len(r)
  end
end
```

这是从我们的示例中得出的：当列表为空时，`my-len` 产生 `0`；当它不为空时，我们向列表剩余部分的长度（这里，`r`）加一。

注意，虽然我们最近的 `my-len` 示例明确提到了 `.rest`，但在使用 `cases` 时，我们只使用名称 `r`，这是 Pyret 已经定义的（在幕后）为 `l.rest`。

类似地，让我们定义 `my-sum`：

```py
fun my-sum(l):
  cases (List) l:
    | empty      => 0
    | link(f, r) => f + my-sum(r)
  end
end
```

注意它们在代码上的相似性，以及数据结构如何自然而然地建议程序的结构。这将是您很快就会习惯的模式！

> 策略：在列表上开发函数
> 
> > 利用列表的结构和具体示例的强大功能来开发列表处理函数。
> > 
> > +   选择一个具有（至少）三个元素的具体系列。为整个列表和列表的每个后缀（包括空列表）编写一系列示例。
> > +   
> > +   将每个例子重写，用其输入列表的`first`和`rest`数据来表示其预期的答案。你不必在新答案中使用`first`和`rest`运算符，但你应该看到`first`和`rest`值在答案中明确表示。
> > +   
> > +   在例子中的答案中寻找模式。使用这些来开发代码：编写一个`cases`表达式，根据你的例子填写每个`=>`的右侧。
> > +   
> > 这种策略适用于结构化数据，利用每个数据项的组件，而不是像迄今为止所展示的那样具体使用`first`和`rest`。

#### 5.2.4 结构化问题，转换列表 "链接到这里")

现在我们有了开发以列表为输入的函数的系统方法，让我们将相同的策略应用到产生列表作为答案的函数。

##### 5.2.4.1 `my-doubles`：示例和代码 "链接到这里")

和往常一样，我们将从一些例子开始。给定一个数字列表，我们想要一个列表，其中每个数字都翻倍（按照原始列表的顺序）。以下是一个包含三个数字的合理示例：

```py
my-doubles([list: 3, 5, 2]) is [list: 6, 10, 4]
```

和以前一样，让我们写出我们例子列表每个后缀的答案，包括对于`empty`列表：

```py
my-doubles([list:    5, 2]) is [list:    10, 4]
my-doubles([list:       2]) is [list:        4]
my-doubles([list:        ]) is [list:         ]
```

现在，我们将答案表达式重写，包括每个例子的具体`first`和`rest`数据。让我们从只包含`first`数据开始，只针对第一个例子：

```py
my-doubles([list: 3, 5, 2]) is [list: 3 * 2, 10, 4]
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]
```

接下来，让我们在第一个例子中包含`rest`数据（`[list: 5, 2]`）。第一个例子中的当前答案是

```py
[list: 3 * 2, 10, 4]
```

并且`[list: 10, 4]`是使用函数对`[list: 5, 2]`应用的结果。因此，我们可能会想用以下内容替换第一个例子中的右侧：

```py
[list: 3 * 2, my-doubles([list: 5, 2])]
```

> 立刻行动！
> 
> > 这个表达式会产生什么值？你可能想尝试这个不直接使用`my-doubles`的例子：
> > 
> > ```py
> > [list: 3 * 2, [list: 10, 4]]
> > ```

哎呀！我们想要一个单一的（扁平）列表，而不是列表中的列表。从重新构建答案以使用`first`和`rest`值的角度来看，这感觉是正确的方向，但我们显然还没有完全到达那里。

> 立刻行动！
> 
> > 以下表达式会产生什么值？
> > 
> > ```py
> > link(3 * 2, [list: 10, 4])
> > ```

注意这两个最后练习中的两个表达式的区别：后者使用`link`将涉及`first`的值放入`rest`的转换中，而前者试图用`list:`来做这件事。

> 立刻行动！
> 
> > 每个以下表达式产生的列表中有多少个元素？
> > 
> > ```py
> > [list: 25, 16, 32]
> > [list: 25, [list: 16, 32]]
> > link(25, [list: 16, 32])
> > ```
> > 
> 立刻行动！
> 
> > 总结`link`和`list:`如何组合元素和列表之间的区别。如果需要，在交互提示符中尝试额外的例子来探索这些想法。

这里的启示是，我们使用 `link` 将元素插入到现有列表中，而使用 `list:` 来创建一个包含旧列表作为元素的新列表。回到我们的例子，那么，我们在第一个例子中通过以下方式包含 `rest`：

```py
my-doubles([list: 3, 5, 2]) is link(3 * 2, [list: 10, 4])
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]
```

然后将其转换为

```py
my-doubles([list: 3, 5, 2]) is link(3 * 2, my-doubles([list: 5, 2]))
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]
```

将这个想法应用到示例中，我们得到：

```py
my-doubles([list: 3, 5, 2]) is link(3 * 2, my-doubles([list: 5, 2]))
my-doubles([list:    5, 2]) is link(5 * 2, my-doubles([list: 2]))
my-doubles([list:       2]) is link(2 * 2, my-doubles([list: ]))
my-doubles([list:        ]) is [list:             ]
```

现在我们有了明确使用 `first` 和 `rest` 元素的示例，我们可以编写 `my-doubles` 函数：

```py
fun my-doubles(l):
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      link(f * 2, my-doubles(r))
  end
end
```

##### 5.2.4.2 `my-str-len`: 示例和代码 "链接至此")

在 `my-doubles` 中，输入和输出列表具有相同的元素类型。函数也可以生成内容类型与输入列表不同的列表。让我们通过一个例子来分析。给定一个字符串列表，我们想要每个字符串的长度（与输入列表中的顺序相同）。因此，这里有一个合理的例子：

```py
my-str-len([list: "hi", "there", "mateys"]) is [list: 2, 5, 6]
```

如同之前，我们应该考虑上述示例中每个子问题的答案：

```py
my-str-len([list:       "there", "mateys"]) is [list:    5, 6]
my-str-len([list:                "mateys"]) is [list:       6]
```

或者换句话说：

```py
my-str-len([list: "hi", "there", "mateys"]) is link(2, [list: 5, 6])
my-str-len([list:       "there", "mateys"]) is link(5, [list:    6])
my-str-len([list:                "mateys"]) is link(6, [list:     ])
```

这告诉我们空列表的响应应该是 `empty`：

```py
my-str-len(empty) is empty
```

下一步是将示例中的答案重新整理，使 `first` 和 `rest` 部分明确化。希望到现在你已经开始发现一个模式：列表的其余部分的输出明确地作为另一个示例出现。因此，我们将首先获取每个示例输入的 `rest` 值放入答案中：

```py
my-str-len([list: "hi", "there", "mateys"]) is link(2, my-str-len([list: "there", "mateys"]))
my-str-len([list:       "there", "mateys"]) is link(5, my-str-len([list:          "mateys"]))
my-str-len([list:                "mateys"]) is link(6, my-str-len([list:                  ]))
my-str-len([list:                        ]) is [list: ]
```

现在剩下的只是弄清楚如何将 `first` 值整合到输出中。在这个问题的背景下，这意味着我们需要将 `"hi"` 转换为 `2`，将 `"there"` 转换为 `5`，依此类推。从问题陈述中，我们知道 `2` 和 `5` 是指相应字符串的长度（字符计数）。确定字符串长度的操作称为 `string-length`。因此，我们的示例如下所示：

```py
my-str-len([list: "hi", "there", "mateys"]) is link(string-length("hi"), my-str-len([list: "there", "mateys"]))
my-str-len([list:       "there", "mateys"]) is link(string-length("there"), my-str-len([list:          "mateys"]))
my-str-len([list:                "mateys"]) is link(string-length("mateys"), my-str-len([list: ]))
my-str-len([list:                        ]) is [list: ]
```

从这里，我们编写一个函数来捕捉我们在示例中开发的模式：

```py
fun my-str-len(l):
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      link(string-length(f), my-str-len(r))
  end
end
```

#### 5.2.5 从列表中选择的结构性问题 "链接至此")

在上一节中，我们看到了转换列表元素（通过加倍数字或计数字符）的函数。输出列表的类型可能与输入列表的类型相同，也可能不同。其他生成列表而不是选择元素的函数，其输出列表中的每个元素都在输入列表中，但输入列表中的一些元素可能不会出现在输出列表中。本节将我们的从示例推导函数的方法适应元素选择。

##### 5.2.5.1 `my-pos-nums`: 示例和代码 "链接至此")

作为我们的第一个示例，我们将从包含正数和非正数的列表中选择正数。

> 现在行动起来！
> 
> > 构建从输入列表 `[list: 1, -2, 3, -4]` 中获得的示例序列。

我们开始吧：

```py
my-pos-nums([list: 1, -2, 3, -4]) is [list: 1, 3]
my-pos-nums([list:    -2, 3, -4]) is [list:    3]
my-pos-nums([list:        3, -4]) is [list:    3]
my-pos-nums([list:           -4]) is [list:     ]
my-pos-nums([list:             ]) is [list:     ]
```

我们可以写成以下形式：

```py
my-pos-nums([list: 1, -2, 3, -4]) is link(1, [list: 3])
my-pos-nums([list:    -2, 3, -4]) is         [list: 3]
my-pos-nums([list:        3, -4]) is link(3, [list: ])
my-pos-nums([list:           -4]) is         [list: ]
my-pos-nums([list:             ]) is         [list: ]
```

或者，更明确地说，

```py
my-pos-nums([list: 1, -2, 3, -4]) is link(1, my-pos-nums([list: -2, 3, -4]))
my-pos-nums([list:    -2, 3, -4]) is         my-pos-nums([list:     3, -4])
my-pos-nums([list:        3, -4]) is link(3, my-pos-nums([list:        -4]))
my-pos-nums([list:           -4]) is         my-pos-nums([list:          ])
my-pos-nums([list:             ]) is         [list: ]
```

与函数变换列表的示例序列不同，这里我们看到答案有不同的形状：一些涉及一个`链接`，而另一些只是处理列表的`剩余部分`。每当我们需要在一系列示例中输出不同形状时，我们将在代码中使用`if`表达式来区分产生每种形状的条件。

是什么决定了我们得到哪种形状的输出？让我们按照输出形状重新排列示例（除了空列表输入）：

```py
my-pos-nums([list: 1, -2, 3, -4]) is link(1, my-pos-nums([list: -2, 3, -4]))
my-pos-nums([list:        3, -4]) is link(3, my-pos-nums([list:        -4]))

my-pos-nums([list:    -2, 3, -4]) is         my-pos-nums([list:     3, -4])
my-pos-nums([list:           -4]) is         my-pos-nums([list:          ])
```

重新组织后，我们可以看到使用`link`的示例在`first`位置有一个正数，而没有使用`link`的示例只是处理列表的`rest`部分。这表明我们的`if`表达式需要询问列表中的第一个元素是否为正数。这产生了以下程序：

```py
fun my-pos-nums(l):
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      if f > 0:
        link(f, my-pos-nums(r))
      else:
        my-pos-nums(r)
      end
  end
end
```

> 立刻行动！
> 
> > 我们的示例集是否全面？

实际上不是。还有很多我们没有考虑到的示例，例如以正数结尾的列表和包含`0`的列表。

> 练习
> 
> > 逐个分析这些示例，看看它们如何影响程序！

##### 5.2.5.2 `my-alternating`: 示例和代码 "链接至此")

现在，让我们考虑一个问题，它不是通过值而是通过位置选择元素。我们想要编写一个函数，从列表中选择交替元素。我们再次将从示例开始工作。

> 立刻行动！
> 
> > 从列表`[list: 1, 2, 3, 4, 5, 6]`开始，计算`my-alternating`的结果。

这是它们如何工作的：

<alternating-egs-1> ::=

```py
check:
  my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
  my-alternating([list:    2, 3, 4, 5, 6]) is [list: 2, 4, 6]
  my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]
  my-alternating([list:          4, 5, 6]) is [list:    4, 6]
end
```

等等，那是什么？上面的两个答案都是正确的，但第二个答案并不能帮助我们以任何方式构建第一个答案。这意味着我们到目前为止解决问题的方法对于这种新类型的问题还不够。尽管如此，它仍然是有用的：请注意，第一个示例和第三个示例之间，以及第二个示例和第四个示例之间有联系。这个观察结果与我们的选择交替元素的目标一致。

这样的代码会是什么样子？在我们尝试编写函数之前，让我们用第三种方式重写第一个示例：

```py
my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]

my-alternating([list: 1, 2, 3, 4, 5, 6]) is link(1, my-alternating([list: 3, 4, 5, 6]))
```

注意，在重写的版本中，我们在再次使用`my-alternating`之前从列表中删除了两个元素，而不仅仅是删除一个。我们将在代码中找出如何处理这一点。

让我们从我们常用的带有`cases`表达式的函数模式开始：

```py
fun my-alternating(l):
  cases (List) l:
    | empty => [list:]
    | link(f, r) => link(f, … r …)
  end
end
```

注意，我们不能简单地在对`r`调用`my-alternating`，因为`r`只从列表中排除了一个项目，而不是像这个问题所要求的那样排除两个。我们必须将`r`分解，以便到达原始列表的`rest`的`rest`。为此，我们使用另一个`cases`表达式，它嵌套在第一个`cases`表达式中：

```py
fun my-alternating(l):
  cases (List) l:
    | empty => [list:]
    | link(f, r) =>
      cases (List) r:  # note: deconstructing r, not l
        | empty => ??? # note the ???
        | link(fr, rr) =>
          # fr = first of rest, rr = rest of rest
          link(f, my-alternating(rr))
      end
  end
end
```

这段代码与我们刚刚工作的示例一致。但请注意，我们还有一些未完成的工作要做：我们需要决定在内层`cases`表达式的`empty`情况下（在代码中用`???`标记）要做什么。

在这个阶段，一个常见的诱惑是将`???`替换为`[list:]`。毕竟，我们不是总是在`empty`情况下返回`[list:]`吗？

> 现在就做！
> 
> > 将`???`替换为`[list:]`并在我们的原始示例上测试程序：
> > 
> > ```py
> > my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
> > my-alternating([list:    2, 3, 4, 5, 6]) is [list: 2, 4, 6]
> > my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]
> > my-alternating([list:          4, 5, 6]) is [list:    4, 6]
> > ```
> > 
> > 你观察到了什么？

哎呀！我们编写了一个似乎在偶数元素列表上工作但在奇数元素列表上不工作的程序。这是怎么发生的？我们猜测的这部分代码是如何填充内部`cases`的`empty`情况，所以问题肯定在那里。然而，我们与其关注代码，不如关注示例。我们需要一个简单的示例，这样我们就能到达那段代码。当我们列表`l`不为空，但`r`（`l`的其余部分）为空时，我们就到达了那个地方。换句话说，我们需要一个只有一个元素的示例。

> 现在就做！
> 
> > 完成以下示例：
> > 
> > ```py
> > my-alternating([list: 5]) is ???
> > ```

给定一个只有一个元素的列表，该元素应包含在交替元素列表中。因此，我们应该这样完成这个示例

```py
my-alternating([list: 5]) is [list: 5]
```

> 现在就做！
> 
> > 使用这个示例来更新我们代码中`r`为`empty`时`my-alternating`的结果。

利用这个新示例，`my-alternating`的最终版本如下：

```py
fun my-alternating(l):
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      cases (List) r: # note: deconstructing r, not l
        | empty =>    # the list has an odd number of elements
          [list: f]
        | link(fr, rr) =>
          # fr = first of rest, rr = rest of rest
          link(f, my-alternating(rr))
      end
  end
end
```

这个问题的启示是什么？有两个：

+   不要忽略小例子：列表处理函数在`empty`情况下的结果不总是`empty`。

+   如果一个问题要求你处理列表前面的多个元素，你可以嵌套`cases`表达式来访问后面的元素。

这些要点在未来示例中还会很重要：请注意它们！

#### 5.2.6 关于宽松域的结构问题 "链接到这里")

##### 5.2.6.1 `my-max`: 示例 "链接到这里")

现在我们来找出列表中的最大值。为了简单起见，我们假设我们只处理数字列表。我们应该构建什么样的列表呢？显然，我们应该有空列表和非空列表……但是还有什么？一个像`[list: 1, 2, 3]`这样的列表是一个好例子吗？嗯，它没有问题，但我们还应该考虑最大值在开头而不是结尾的列表；最大值可能在中间；最大值可能重复；最大值可能是负数；等等。虽然不是全面的，但这里有一组小而有趣的例子：

```py
my-max([list: 1, 2, 3]) is 3
my-max([list: 3, 2, 1]) is 3
my-max([list: 2, 3, 1]) is 3
my-max([list: 2, 3, 1, 3, 2]) is 3
my-max([list: 2, 1, 4, 3, 2]) is 4
my-max([list: -2, -1, -3]) is -1
```

那么`my-max(empty)`呢？

> 现在就做！
> 
> > 我们能否定义`my-max(empty)`为`0`？对于空列表，返回`0`已经有效两次了！

我们稍后再回到这个问题。

在我们继续之前，了解 Pyret 中已经定义了一个名为`num-max`的函数是有用的，该函数用于比较两个数字：

```py
num-max(1, 2) is 2
num-max(-1, -2) is -1
```

> 练习
> 
> > 假设`num-max`还没有内置。你能定义它吗？你会发现你学到的关于布尔值的知识很有用。记得写一些测试！

现在我们可以看看`my-max`是如何工作的：

```py
my-max([list: 1, 2, 3]) is 3
my-max([list:    2, 3]) is 3
my-max([list:       3]) is 3
```

嗯。这并没有真正教会我们什么，是吗？也许，我们无法确定。我们仍然不知道如何处理`empty`。

让我们尝试第二个示例输入：

```py
my-max([list: 3, 2, 1]) is 3
my-max([list:    2, 1]) is 2
my-max([list:       1]) is 1
```

这实际上也在告诉我们一些有用的信息，但我们可能还没有看到。让我们承担一个更有雄心的任务：

```py
my-max([list: 2, 1, 4, 3, 2]) is 4
my-max([list:    1, 4, 3, 2]) is 4
my-max([list:       4, 3, 2]) is 4
my-max([list:          3, 2]) is 3
my-max([list:             2]) is 2
```

观察到列表剩余部分的最大值给我们提供了一个候选答案，但与第一个元素比较后，我们得到了一个确定的答案：

```py
my-max([list: 2, 1, 4, 3, 2]) is num-max(2, 4)
my-max([list:    1, 4, 3, 2]) is num-max(1, 4)
my-max([list:       4, 3, 2]) is num-max(4, 3)
my-max([list:          3, 2]) is num-max(3, 2)
my-max([list:             2]) is …
```

最后一个是有点尴尬：我们希望写成

```py
my-max([list:             2]) is num-max(2, …)
```

但我们实际上并不知道空列表的最大值（或最小值，或任何其他元素）是什么，我们只能向`num-max`提供数字。因此，排除了那个可疑的情况后，我们只剩下

```py
my-max([list: 2, 1, 4, 3, 2]) is num-max(2, my-max([list: 1, 4, 3, 2]))
my-max([list:    1, 4, 3, 2]) is num-max(1, my-max([list:    4, 3, 2]))
my-max([list:       4, 3, 2]) is num-max(4, my-max([list:       3, 2]))
my-max([list:          3, 2]) is num-max(3, my-max([list:          2]))
```

我们的示例再次帮到了我们：它们揭示了我们可以如何使用列表剩余部分的答案来计算整个列表的答案，而这个答案反过来又是另一个列表的剩余部分，以此类推。如果你回顾一下我们上面写的其他示例列表，你也会看到这个模式在那里同样适用。

然而，现在是时候面对`empty`情况了。真正的问题是，我们没有空列表的最大值：对于我们可能提供的任何数字，总有一个更大的数字（假设我们的计算机足够大）可能是答案。简而言之，要求空列表的最大值（或最小值）是没有意义的：最大值的概念仅在非空列表上定义！也就是说，当要求空列表的最大值时，我们应该发出错误信号：

```py
my-max(empty) raises ""
```

（这是我们如何在 Pyret 中表示它将引发错误的方式；我们不在乎错误的细节，因此是空字符串）。

##### 5.2.6.2 `my-max`: 从示例到代码 "链接到此处")

再次，我们可以将上述示例编码化，即，将它们转换成一个适用于所有实例的统一程序。然而，我们现在有一个转折点。如果我们盲目地遵循之前使用的模式，我们最终会得到：

```py
fun my-max(l):
  cases (List) l:
    | empty      => raise("not defined for empty lists")
    | link(f, r) => num-max(f, my-max(r))
  end
end
```

> 现在行动！
> 
> > 这有什么问题？

考虑列表`[list: 2]`。这变成了

```py
num-max(2, my-max([list: ]))
```

这当然会引发错误。因此，这个函数对任何包含一个或多个元素的列表都不会工作！

这是因为我们需要确保我们不是在尝试计算空列表的最大值。回到我们的示例，我们看到在我们调用`my-max`之前需要做的事情是检查列表的剩余部分是否为空。如果是，我们根本不想调用`my-max`。也就是说：

```py
fun my-max(l):
  cases (List) l:
    | empty      => raise("not defined for empty lists")
    | link(f, r) =>
      cases (List) r:
        | empty => …
        | …
      end
  end
end
```

我们稍后回到当剩余部分不为空时应该做什么。

如果列表的剩余部分`l`为空，我们的上述示例告诉我们最大值是列表中的第一个元素。因此，我们可以这样填写：

```py
fun my-max(l):
  cases (List) l:
    | empty      => raise("not defined for empty lists")
    | link(f, r) =>
      cases (List) r:
        | empty => f
        | …
      end
  end
end
```

特别注意，没有调用`my-max`。然而，如果列表不为空，我们的上述示例告诉我们`my-max`将给出列表剩余部分的最大值，我们只需要将这个答案与第一个元素（`f`）进行比较：

```py
fun my-max(l):
  cases (List) l:
    | empty      => raise("not defined for empty lists")
    | link(f, r) =>
      cases (List) r:
        | empty => f
        | else  => num-max(f, my-max(r))
      end
  end
end
```

当然，这个定义确实完成了任务！

#### 5.2.7 具有标量答案的更多结构化问题 "链接到此处")

##### 5.2.7.1 `my-avg`: 示例 "链接到此处")

现在我们来尝试计算一个数字列表的平均值。让我们从一个例子列表 `[list: 1, 2, 3, 4]` 开始，并从中推导出更多的例子。这个列表中数字的平均值显然是 `(1 + 2 + 3 + 4)/4`，即 `10/4`。

根据列表的结构，我们看到列表的其余部分是 `[list: 2, 3, 4]`，而那部分剩余的是 `[list: 3, 4]`，依此类推。得到的结果平均值是：

```py
my-avg([list: 1, 2, 3, 4]) is 10/4
my-avg([list:    2, 3, 4]) is 9/3
my-avg([list:       3, 4]) is 7/2
my-avg([list:          4]) is 4/1
```

问题在于，我们根本不清楚如何从子列表的答案得到整个列表的答案。也就是说，给定以下两个信息：

+   列表剩余部分的平均值是 `9/3`，即 `3`。

+   列表中的第一个数字是 `1`。

我们如何确定整个列表的平均值必须是 `10/4`？如果你觉得不清楚，不要担心：只有这两条信息，是不可能做到的！

这里有一个更简单的例子，可以解释原因。假设列表中的第一个值是 `1`，列表剩余部分的平均值是 `2`。这里有两组非常不同的列表符合这个描述：

```py
[list: 1, 2]    # the rest has one element with sum 2
[list: 1, 4, 0] # the rest has two elements with sum 4
```

整个第一个列表的平均值是 `3/2`，而整个第二个列表的平均值是 `5/3`，这两个值并不相同。

也就是说，为了计算整个列表的平均值，甚至知道列表剩余部分的平均值都没有用。相反，我们需要知道列表剩余部分的和以及长度。有了这两个，我们可以将第一个值加到和上，并将 `1` 加到长度上，然后计算新的平均值。

从原则上讲，我们可以尝试创建一个 `average` 函数，它返回所有这些信息。然而，将任务分解成两个更小的任务会简单得多。毕竟，我们已经看到了如何计算长度和如何计算和。因此，平均值可以直接使用这些现有的函数：

```py
fun my-avg(l):
  my-sum(l) / my-len(l)
end
```

> 立即行动！
> 
> > 空列表的平均值应该是多少？上面的代码是否产生了你预期的结果？

正如我们之前关于最大[结构化问题在放宽域中]的讨论，空列表的平均值不是一个定义良好的概念。因此，发出一个错误信号是合适的。上面的实现就是这样做的，但做得不好：它在除法时报告错误。更好的编程实践是立即捕获这种情况并报告错误，而不是希望其他函数会报告错误。

> 练习
> 
> > 修改 `my-avg` 以在给定空列表时发出错误信号。

因此，我们看到我们使用的流程——从例子中推断代码——并不总是足够，我们需要更高级的技术来解决一些问题。然而，请注意，从例子开始可以帮助我们快速识别这种方法是否有效。此外，如果你更仔细地观察，你会注意到上述例子确实暗示了如何解决问题：在我们的第一个例子中，我们写出了像`10/4`、`9/3`和`7/2`这样的答案，这些答案对应于数字的总和除以长度。因此，以这种形式（例如，将第二个写成`3`）写出答案已经揭示了解决方案的结构。

#### 5.2.8 累加器的结构问题 "链接到这里")

##### 5.2.8.1 `my-running-sum`: 首次尝试 "链接到这里")

再一次，我们将从一个例子开始。

> 现在行动起来！
> 
> > 计算从列表 `[list: 1, 2, 3, 4, 5]` 开始的`my-running-sum`的结果。

这里是我们前几个例子看起来像这样：

<running-sum-egs-1> ::=

```py
check:
  my-running-sum([list: 1, 2, 3, 4, 5]) is [list: 1, 3, 6, 10, 15]
  my-running-sum([list:    2, 3, 4, 5]) is [list: 2, 5, 9, 14]
  my-running-sum([list:       3, 4, 5]) is [list: 3, 7, 12]
end
```

再次，似乎没有明显的联系存在于列表其余部分的结果和整个列表的结果之间。

（这并不完全正确：我们仍然可以像以下这样排列答案：

```py
my-running-sum([list: 1, 2, 3, 4, 5]) is [list: 1, 3, 6, 10, 15]
my-running-sum([list:    2, 3, 4, 5]) is [list:    2, 5,  9, 14]
my-running-sum([list:       3, 4, 5]) is [list:       3,  7, 12]
```

并观察我们正在计算列表其余部分的答案，然后将第一个元素添加到答案中的每个元素上，并将第一个元素`link`到前面。原则上，我们可以直接计算这个解决方案，但就目前而言，这可能比找到更简单的答案要复杂。

##### 5.2.8.2 `my-running-sum`: 示例和代码 "链接到这里")

回想一下我们是如何在`my-running-sum`: 首次尝试)开始的。我们的例子 [<running-sum-egs-1>)] 展示了以下问题。当我们处理列表的其余部分时，我们已经忘记了之前的一切。也就是说，当我们从`2`开始处理列表时，我们忘记了之前已经看到过`1`；当我们从`3`开始时，我们忘记了之前已经看到过`1`和`2`；以此类推。换句话说，我们一直在忘记过去。我们需要一种避免这种情况的方法。

我们能做的最简单的事情就是简单地改变我们的函数，使其携带这种“记忆”，或者我们称之为累加器。也就是说，想象我们正在定义一个新的函数，称为`my-rs`。它将消耗一个数字列表并产生一个数字列表，但除此之外，它还会也取当前列表之前数字的总和。

> 现在行动起来！
> 
> > 初始总和应该是多少？

初始时没有“先前的列表”，因此我们将使用加法恒等式：`0`。`my-rs`的类型是

```py
my-rs :: Number, List<Number> -> List<Number>
```

让我们现在将我们的例子从 <running-sum-egs-1>) 作为`my-rs`的例子重新工作。这些例子使用`+`运算符将两个列表合并成一个（第一个列表的元素后面跟着第二个列表的元素）：

```py
my-rs( 0, [list: 1, 2, 3, 4, 5]) is [list:  0 + 1] + my-rs( 0 + 1, [list: 2, 3, 4, 5])
my-rs( 1, [list:    2, 3, 4, 5]) is [list:  1 + 2] + my-rs( 1 + 2, [list:    3, 4, 5])
my-rs( 3, [list:       3, 4, 5]) is [list:  3 + 3] + my-rs( 3 + 3, [list:       4, 5])
my-rs( 6, [list:          4, 5]) is [list:  6 + 4] + my-rs( 6 + 4, [list:          5])
my-rs(10, [list:             5]) is [list: 10 + 5] + my-rs(10 + 5, [list:           ])
my-rs(15, [list:              ]) is empty
```

也就是说，`my-rs`转换成以下代码：

```py
fun my-rs(acc, l):
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      new-sum = acc + f
      link(new-sum, my-rs(new-sum, r))
  end
end
```

然后剩下的就是从`my-running-sum`中调用它：

```py
fun my-running-sum(l):
  my-rs(0, l)
end
```

注意，我们没有改变`my-running-sum`本身以接受额外的参数。我们代码的正确性取决于`acc`的初始值为 0。如果我们为`acc`添加了一个参数，任何调用`my-running-sum`的代码都可能提供一个意外的值，这会扭曲结果。此外，由于值是固定的，添加参数相当于将额外的（且不必要的）工作转移到使用我们代码的其他人身上。

##### 5.2.8.3 `my-alternating`：示例和代码 "链接到这里")

回想一下我们在我的交替示例：示例和代码中的例子。在那里，我们注意到代码是基于每隔一个例子构建的。我们可能选择了不同的例子，因此从一个例子到下一个例子我们跳过了两个元素而不是一个。在这里，我们将看到另一种思考相同问题的方法。

回到我们已经看到的例子[<alternating-egs-1>]。我们编写了`my-alternating`来遍历列表，实际上每次两个元素。另一个选择是逐个元素遍历它，但保持跟踪我们是否处于奇数或偶数元素——即，给我们的程序添加“记忆”。由于我们只需要跟踪那一条信息，我们可以使用一个`Boolean`来做到这一点。让我们定义一个新的函数来完成这个目的：

```py
my-alt :: List<Any>, Boolean -> List<Any>
```

额外的参数累积我们是否处于要保留的元素还是要丢弃的元素。

我们可以重用现有的列表函数模板。当我们有一个元素时，我们必须咨询累加器是否要保留它。如果其值为`true`，我们将其`link`到答案；否则我们忽略它。然而，当我们处理列表的其余部分时，我们必须记住更新累加器：如果我们保留了一个我们不希望保留的下一个元素，反之亦然。

```py
fun my-alt(l, keep):
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      if keep:
        link(f, my-alt(r, false))
      else:
        my-alt(r, true)
      end
  end
end
```

最后，我们必须确定累加器的初始值。在这种情况下，因为我们想从第一个元素开始交替元素，所以它的初始值应该是`true`：

```py
fun my-alternating(l):
  my-alt(l, true)
end
```

> 练习
> 
> > 使用累加器定义`my-max`。累加器代表什么？你遇到任何困难吗？

#### 5.2.9 处理多个答案 "链接到这里")

我们上面的讨论假设对于给定的输入只有一个答案。这通常是正确的，但也取决于问题的措辞以及我们如何选择生成例子。我们现在将对此进行详细研究。

##### 5.2.9.1 `uniq`：问题设置 "链接到这里")

考虑编写`uniq`的任务：`uniq`是 Unix 实用工具的一个具有类似行为的名称；因此，名称的拼写。给定一个值列表，它产生一个包含相同元素的集合，同时避免任何重复（因此称为`uniq`，意为“唯一”）。

考虑以下输入：`[list: 1, 2, 1, 3, 1, 2, 4, 1]`。

> 现在就做！
> 
> > 这个输入生成了哪些示例序列？这非常重要，你需要停下来并尝试手动完成这个任务。正如我们将看到的，存在多个解决方案，考虑你生成的结果是有用的。即使你不能生成一个序列，尝试这样做也会更好地为你阅读下一部分做好准备。

你是如何得到你的示例的？如果你只是“思考了一会儿并写下了一些东西”，你可能得到了可以转化为程序的东西，也可能没有。程序只能系统地执行；它们不能“思考”。所以，希望你已经采取了一个明确的路径来计算答案。

##### 5.2.9.2 `uniq`: 示例 "链接至此")

结果是有几个可能的答案，因为我们（故意）没有具体说明问题。假设列表中有两个相同的值实例；我们保留哪一个，第一个还是第二个？一方面，由于这两个实例必须等效，所以这并不重要，但在编写具体示例和推导解决方案时，这很重要。

例如，你可能已经生成了以下序列：

```py
examples:
  uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:    2, 1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:       1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:          3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:             1, 2, 4, 1]) is [list:    2, 4, 1]
  uniq([list:                2, 4, 1]) is [list:    2, 4, 1]
  uniq([list:                   4, 1]) is [list:       4, 1]
  uniq([list:                      1]) is [list:          1]
  uniq([list:                       ]) is [list:           ]
end
```

然而，你也可能生成了以下序列：

```py
uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 1, 2, 3, 4]
```

或者

```py
uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 4, 3, 2, 1]
```

以此类推。让我们处理我们上面已经解决的问题。

##### 5.2.9.3 `uniq`: 代码 "链接至此")

我们如何系统地得到这个答案？当给定一个非空列表时，我们将其分为其第一个元素和其余部分。假设我们已经对列表的其余部分应用了 `uniq`。现在我们可以问：第一个元素是否在列表的其余部分中？如果是，那么我们可以忽略它，因为它肯定会在其余部分的 `uniq` 中。如果不是，那么将这个元素与答案 `link` 是至关重要的。

这转化为以下程序。对于空列表，我们返回空列表。如果列表非空，我们检查第一个元素是否在列表的其余部分中。如果不是，我们包括它；否则，我们现在可以忽略它。

这导致以下程序：

```py
fun uniq-rec(l :: List<Any>) -> List<Any>:
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      if r.member(f):
        uniq-rec(r)
      else:
        link(f, uniq-rec(r))
      end
  end
end
```

我们将其称为 `uniq-rec` 而不是 `uniq`，以区分其他版本的 `uniq`。

> 练习
> 
> > 注意，我们正在使用 `.member` 来检查一个元素是否是列表的成员。编写一个 `member` 函数，它接受一个元素和一个列表，并告诉我们该元素是否是列表的成员。
> > 
> 练习
> 
> > 唯一性检查有许多实际应用。例如，一个人可能有一份注册参加选举的人的名单。为了保持选举的公平性，每人只能投一票，我们应该从列表中删除重复的名字。
> > 
> > 1.  提出一组示例，用于一个名为`rem-duplicate-voters`的函数，该函数接受一个投票者名单列表，并返回一个已移除重复注册的列表。在开发你的示例时，请考虑在识别重复姓名时可能出现的现实世界场景。你能识别出两个姓名可能看起来是同一个人，但实际上不是的情况吗？两个姓名可能看起来不同，但实际上是指同一个人的情况吗？
> > 1.  
> > 1.  你可能需要对我们当前的`uniq-rec`函数进行哪些修改，以处理像移除重复投票者这样的情况？
> > 1.  
> 负责任计算：比较值时上下文很重要
> 
> > 在上述练习中的数据去重上下文提醒我们，不同的上下文可能需要不同的概念来判断两个数据值是否相同。有时，我们希望进行精确匹配以确定两个字符串是否相等。有时，我们需要使用方法来规范化数据，无论是简单的方式（如大写字母）还是更微妙的方式（如基于中间名首字母）。有时，我们需要更多信息（如除了姓名之外还有街道地址）来判断列表中的两个项目是否应该被视为“相同”。
> > 
> > 编写假设我们的数据可能不适用于实践的程序的代码很容易。这又是一个可以通过考虑代码在上下文中需要工作的具体示例来帮助的情况。

##### 5.2.9.4 `uniq`：减少计算 "链接到此处")

注意，这个函数有一个重复的表达式。我们不必写两次，只需调用一次，并在两个地方使用结果：

```py
fun uniq-rec2(l :: List<Any>) -> List<Any>:
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      ur = uniq-rec2(r)
      if r.member(f):
        ur
      else:
        link(f, ur)
      end
  end
end
```

你可能会想，因为我们用一个函数调用替换了两个，所以减少了程序的计算量。但这并不正确！这两个函数调用都在同一个条件语句的两个分支中；因此，对于任何给定的列表元素，只会发生`uniq`的其中一个调用。实际上，在两种情况下，之前都有一个`uniq`的调用，现在仍然有一个。所以我们在源程序中减少了调用次数，但并没有减少程序运行时的调用次数。从这个意义上说，这个章节的名称是有意误导的！

然而，我们可以执行一个有用的简化，这是由`uniq-rec2`的结构所启用的。我们目前检查`f`是否是`r`的成员，即所有剩余元素的列表。在我们的例子中，这意味着在第二次迭代时，我们检查`2`是否是列表`[list: 1, 3, 1, 2, 4, 1]`的成员。这是一个包含六个元素的列表，包括三个`1`的副本。我们将`2`与两个`1`进行比较。然而，第二次比较我们没有得到任何收获。换句话说，我们可以将`uniq(r)`视为列表其余部分的“摘要”，它在检查成员资格方面与`r`本身一样好，而且可能显著更短。这正是`ur`所代表的。因此，我们可以将这种直觉编码如下：

```py
fun uniq-rec3(l :: List<Any>) -> List<Any>:
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      ur = uniq-rec3(r)
      if ur.member(f):
        ur
      else:
        link(f, ur)
      end
  end
end
```

注意，所有改变的就是我们检查`ur`中的成员资格而不是`r`中的。

> 练习
> 
> > 在预测增长中，我们稍后将会研究如何正式研究程序运行所需的时间。根据该节中引入的度量标准，我们刚才所做的更改是否有所影响？请注意您的答案：这取决于我们如何计算“列表的长度”。

注意，如果列表最初就没有重复项，那么检查哪个列表中的成员资格就无关紧要——<wbr>但如果我们知道列表中没有重复项，我们最初就不会使用`uniq`！我们将在表示列表作为集合中返回到列表和重复元素的问题。

##### 5.2.9.5 `uniq`: 示例和代码变化 "链接至此")

如我们之前提到的，你可能已经编写了其他示例序列。这里有一个非常不同的过程：

+   从整个给定的列表和空答案（到目前为止）开始。

+   对于列表中的每个元素，检查它是否已经在到目前为止的答案中。如果是，忽略它，否则用它扩展答案。

+   当列表中没有更多元素时，到目前为止的答案是整个列表的答案。

注意，这个解决方案假设我们将在遍历列表时累积答案。因此，我们甚至不能像以前那样用一个参数编写示例。我们会争辩说，一个自然的解决方案是询问我们是否可以仅使用我们已经在定义的计算从数据结构中解决问题，就像我们上面所做的那样。如果我们不能，那么我们必须求助于累加器。但由于我们可以，累加器在这里是不必要的，并且极大地复杂了示例的编写（试一试！）。

##### 5.2.9.6 `uniq`: 为什么生成一个列表? "链接至此")

如果你回到`uniq`问题的原始陈述[`uniq`: 问题设置]，你会注意到它没有说输出应该有什么顺序；事实上，它甚至没有说输出需要是一个列表（因此有顺序）。在这种情况下，我们应该考虑列表对于这个问题是否有意义。事实上，如果我们不关心顺序并且不想有重复（根据`uniq`的定义），那么有一个更简单的解决方案，那就是生成一个集合。Pyret 已经内置了集合，将列表转换为集合会自动处理重复项。当然，从学习如何编写`uniq`的角度来看，这是一种作弊行为，但值得记住的是，有时产生正确数据结构的方法并不一定是我们给出的那个。此外，在[将集合表示为列表]中，我们将看到如何自己构建集合（到那时，`uniq`将看起来很熟悉，因为它处于集合的核心）。

#### 5.2.10 单形列表和多形类型 "链接到此处")

之前我们编写了像这样的合同：

```py
my-len :: List<Any> -> Number
my-max :: List<Any> -> Any
```

这有几个令人不满意的原因。考虑`my-max`。合同表明输入列表中可以包含任何类型的元素，但实际上并非如此：输入`[list: 1, "two", 3]`是无效的，因为我们不能比较`1`和`"two"`或`"two"`和`3`。

> 练习
> 
> > 如果我们运行`1 > "two"`或`"two" > 3`会发生什么？

相反，我们的意思是一个列表，其中所有元素都是同一类型的，技术上讲，是可比较的元素，并且合同并没有捕捉到这一点。此外，我们的意思并不是`my-max`可以返回任何旧类型：如果我们向它提供一个数字列表，我们不会得到一个字符串作为最大元素！相反，它只会返回列表中存在的元素类型。

简而言之，我们的意思是列表中的所有元素都是同一类型的，但它们可以是任何类型。我们称前者为单形：“mono”意味着一个，而“morphic”意味着形状，即所有值都有一个类型。但`my-max`函数本身可以操作许多这类列表，所以我们称它为多形（“poly”意味着许多）。

因此，我们需要一种更好的方式来编写这些合同。本质上，我们想要表达的是存在一个类型变量（与常规程序变量相对）来表示列表中元素的类型。给定这个类型，`my-max`将返回该类型的元素。我们按照以下语法来编写：

```py
fun my-max<T>(l :: List<T>) -> T: … end
```

`<T>`表示法表示`T`是一个类型变量参数，它将在函数的其余部分（头和体）中使用。

使用这种表示法，我们还可以重新审视`my-len`。其头现在变为：

```py
fun my-len<T>(l :: List<T>) -> Number: … end
```

注意，`my-len` 实际上并不“关心”所有值是否为同一类型：它从不查看单个元素，更不用说一对元素了。然而，作为一种惯例，我们要求列表始终是单态的。这很重要，因为它使我们能够统一处理列表的元素：如果我们知道如何处理类型 `T` 的元素，那么我们就知道如何处理 `List<T>`。如果列表元素可以是真正任何旧类型，我们就无法知道如何处理其元素。

#### 5.2.1 创建列表并拆分它们 "链接到此处")

到目前为止，我们看到了一种创建列表的方法：通过编写 `[list: …]`。虽然这种方法很有用，但这样编写列表实际上隐藏了它们的真正本质。每个列表实际上都有两个部分：一个第一个元素和列表的其余部分。列表的其余部分本身也是一个列表，因此它也有两个部分……以此类推。

考虑列表 `[list: 1, 2, 3]`。它的第一个元素是 `1`，其余的是 `[list: 2, 3]`。对于这个第二个列表，第一个元素是 `2`，其余的是 `[list: 3]`。

> 现在就做！
> 
> > 拆分这个第三个列表。

对于第三个列表，第一个元素是 `3`，其余的是 `[list: ]`，即空列表。在 Pyret 中，我们还有另一种编写空列表的方法：`empty`。

列表是结构化数据的一个实例：具有组成部分和组成部分形状的明确格式。列表通过第一个元素和其余元素进行格式化。表格在一定程度上是结构化的：它们通过行和列进行格式化，但列名在所有表格中并不一致。结构化数据在编程中很有价值，因为可预测的格式（结构）让我们能够根据该结构编写程序。我们这是什么意思呢？

编程语言可以（并且确实！）提供用于拆分结构化数据的内置操作符。这些操作符称为访问器。访问器仅根据数据类型的结构定义，而与数据内容无关。在列表的情况下，有两个访问器：`first` 和 `rest`。我们通过编写一个表达式，然后是一个点（`.`），然后是访问器名称来使用访问器。正如我们在表格中看到的那样，点意味着“深入”。因此：

```py
l1 = [list: 1, 2, 3]
e1 = l1.first
l2 = l1.rest
e2 = l2.first
l3 = l2.rest
e3 = l3.first
l4 = l3.rest

check:
  e1 is 1
  e2 is 2
  e3 is 3
  l2 is [list: 2, 3]
  l3 is [list: 3]
  l4 is empty
end
```

> 现在就做！
> 
> > 表的访问器是什么？

访问器提供了一种根据其结构拆分数据的方法（我们很快就会看到另一种方法）。有没有一种方法也可以根据其结构构建数据？到目前为止，我们一直使用 `[list: ...]` 形式来构建列表，但这并没有强调 `rest` 本身也是一个列表的结构约束。用于构建列表的结构化操作符将清楚地显示一个 `first` 元素和一个本身也是列表的 `rest`。用于构建结构化数据的操作符称为构造器。

列表的构造器称为 `link`。它接受两个参数：一个 `first` 元素，以及构建列表的基础（`rest` 部分）。以下是一个使用 `link` 创建三个元素列表的示例。

```py
link(1, link(2, link(3, empty)))
```

`link`形式创建的底层列表数据与我们的前一个`[list: ...]`操作相同，如下面的检查所确认：

```py
check:
  [list: 1, 2, 3] is link(1, link(2, link(3, empty)))
end
```

> 现在行动！
> 
> > 看看这两种写列表的形式：你注意到什么区别？
> > 
> 现在行动！
> 
> > 使用`link`形式编写一个包含“荔枝”、“枣”、“芒果”和“榴莲”的四个元素的列表。

完成这个练习后，你可能会想知道为什么有人会使用`link`形式：它更冗长，并且使得单独的元素更难辨认。这种形式对人类来说并不方便。但这对程序来说将非常有价值！

尤其是链接形式突出了我们实际上有两种不同的列表结构。有些列表是空的。所有其他列表都是非空列表，这意味着它们至少有一个`link`。有些列表可能有更复杂的结构（我们稍后会看到），但所有列表都有这个共同点。具体来说，一个列表要么是

+   空的（写成`empty`或`[list: ]`），或者

+   非空（写成`link(…, …)`或`[list: ]`，括号内至少有一个值），其中其余部分也是一个列表（因此可能为空或非空，……）。

这意味着我们实际上有两个列表的结构特性，这两个特性在编写列表程序时都很重要：

1.  列表可以是空的或非空的

1.  非空列表有一个第一个元素和列表的其余部分

让我们利用这两个结构特性来编写一些处理列表的程序！

#### 5.2.2 一些示例练习 "链接至此")

为了说明我们的思考方式，让我们通过几个具体的列表处理函数示例来操作。所有这些函数都将消耗列表；其中一些甚至会产生列表。一些会转换它们的输入（如`map`），一些会从它们的输入中选择（如`filter`），还有一些会聚合它们的输入。由于其中一些函数已经在 Pyret 中存在，我们将用前缀`my-`来命名它们以避免错误。请确保在函数体内一致地使用`my-`名称。正如我们将看到的，我们可以使用一种标准策略来编写所有这些函数：本章节的目标就是让你学习这种策略。

#### 5.2.3 结构化问题：标量答案 "链接至此")

让我们为上述描述的几个函数编写一些示例。我们将以非常具体、风格化的方式编写示例。首先，我们应该始终构造至少两个示例：一个使用`empty`，另一个至少有一个`link`，这样我们就涵盖了两种非常广泛的列表类型。然后，我们应该有更多针对问题中所述列表类型的特定示例。最后，我们应该有更多示例来说明我们如何思考解决问题。

##### 5.2.3.1 `my-len`：示例 "链接至此")

我们还没有精确地定义列表的“长度”是什么意思。当我们试图编写一个例子时，我们立即面临这个问题。列表`empty`的长度是多少？

> 现在行动起来！
> 
> > 你认为呢？

两个常见的例子是`0`和`1`。后者`1`看起来是合理的。然而，如果你将列表写成`[list: ]`，现在它看起来就不太对了：这显然（正如名称`empty`所暗示的）是一个空列表，而空列表中没有任何元素。因此，我们通常声明

```py
my-len(empty) is 0
```

那么，像`[list: 7]`这样的列表呢？很明显，它里面有一个元素（`7`），所以

```py
my-len([list: 7]) is 1
```

类似地，对于一个像`[list: 7, 8, 9]`这样的列表，我们会说

```py
my-len([list: 7, 8, 9]) is 3
```

现在，让我们以不同的角度看看最后一个例子。考虑参数`[list: 7, 8, 9]`。它的第一个元素是`7`，其余部分是`[list: 8, 9]`。好吧，`7`是一个数字，不是一个列表；但是`[list: 8, 9]`肯定是一个列表，所以我们可以询问它的长度。`my-len([list: 8, 9])`是多少？它有两个元素，所以

```py
my-len([list: 8, 9]) is 2
```

该列表的第一个元素是`8`，其余部分是`[list: 9]`。它的长度是多少？注意，我们之前已经提出了一个非常类似的问题，即列表`[list: 7]`的长度。但是`[list: 7]`不是我们从`[list: 7, 8, 9]`开始的列表的子列表，而`[list: 9]`是。使用之前的推理，我们可以说

```py
my-len([list: 9]) is 1
```

当然，这个列表的其余部分是空列表，其长度我们已决定是`0`。

结合这些例子，并写出`empty`的其他形式，我们得到以下结果：

```py
my-len([list: 7, 8, 9]) is 3
my-len([list:    8, 9]) is 2
my-len([list:       9]) is 1
my-len([list:        ]) is 0
```

另一种我们可以这样写（注意右侧）的方式是

```py
my-len([list: 7, 8, 9]) is 1 + 2
my-len([list:    8, 9]) is 1 + 1
my-len([list:       9]) is 1 + 0
my-len([list:        ]) is     0
```

每个加法操作右侧的`2`、`1`和`0`是从哪里来的？那些是输入列表`rest`部分的长度。在之前的例子块中，我们将这些长度作为明确的例子写出来。让我们用产生它们的`my-len`表达式来替换数字`2`、`1`和`0`：

```py
my-len([list: 7, 8, 9]) is 1 + my-len([list: 8, 9])
my-len([list:    8, 9]) is 1 + my-len([list:    9])
my-len([list:       9]) is 1 + my-len([list:     ])
my-len([list:        ]) is 0
```

从这个例子中，你可能开始看到一种模式。对于一个空列表，其长度是`0`。对于一个非空列表，它是`1`（第一个元素对列表长度的“贡献”）加上列表其余部分的长度。换句话说，我们可以使用对列表其余部分计算`my-len`的结果来计算整个列表的答案。

> 现在行动起来！
> 
> > 本节中的每个例子都对这个表达式`my-len([list: 7, 8, 9])`进行了不同的检查。以下是这些例子一起呈现，以及一个明确使用`rest`操作的最后一个例子：
> > 
> > ```py
> > my-len([list: 7, 8, 9]) is 3
> > my-len([list: 7, 8, 9]) is 1 + 2
> > my-len([list: 7, 8, 9]) is 1 + my-len([list: 8, 9])
> > my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)
> > ```
> > 
> > 确认你同意这些断言中的每一个。也要确认你是否理解了每个`is`表达式的右侧是如何从其上方右侧推导出来的。这个练习的目的是确保你相信最后一个检查（我们将将其转换为代码）与第一个（我们在理解问题时写下来的）是等价的。

##### 5.2.3.2 `my-sum`: 示例 "链接至此")

让我们在第二个函数上重复开发示例的过程，这次是一个计算数字列表中元素总和的函数。列表`[list: 7, 8, 9]`的总和是多少？只需手动将数字相加，结果应该是`24`。让我们通过示例看看这是如何实现的。

暂时将空列表放在一边，以下是一些展示求和计算的示例：

```py
my-sum([list: 7, 8, 9]) is 7 + 8 + 9
my-sum([list:    8, 9]) is     8 + 9
my-sum([list:       9]) is         9
```

通过替换，它与以下内容相同

```py
my-sum([list: 7, 8, 9]) is 7 + my-sum([list: 8, 9])
my-sum([list:    8, 9]) is 8 + my-sum([list:    9])
my-sum([list:       9]) is 9 + my-sum([list:     ])
```

从这里，我们可以看出空列表的总和必须是`0`：零被称为加法恒等式：一种说法，即向任何数字 N 加上零，你得到 N。因此，它有道理成为空列表的长度，因为空列表没有项目可以贡献到求和。你能找出乘法恒等式是什么吗？

```py
my-sum(empty) is 0
```

再次观察，我们如何使用计算列表其余部分的`my-sum`的结果来计算整个列表的结果。

##### 5.2.3.3 从示例到代码 "链接到此处")

在开发这些示例之后，我们现在想使用它们来开发一个程序，该程序可以计算任何列表的长度或总和，而不仅仅是这些示例中使用的特定列表。正如我们在前面的章节中所做的那样，我们将利用示例中的模式来找出如何定义通用函数。

这里是`my-len`的最后一个示例版本，这次在`is`的右侧明确表示了`rest`：

```py
my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)
my-len([list:    8, 9]) is 1 + my-len([list:    8, 9].rest)
my-len([list:       9]) is 1 + my-len([list:       9].rest)
my-len([list:        ]) is 0
```

就像我们在对图像上的函数进行开发时做的那样，让我们尝试识别这些示例的共同部分。我们首先注意到，大多数示例有很多共同之处，除了`[list: ]`（空）的情况。因此，让我们将它们分为两组示例：

```py
my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)
my-len([list:    8, 9]) is 1 + my-len([list:    8, 9].rest)
my-len([list:       9]) is 1 + my-len([list:       9].rest)

my-len([list:        ]) is 0
```

通过这种分离（这遵循了我们之前提到的列表的结构特征之一），一个更清晰的模式出现了：对于一个非空列表（称为`someList`），我们通过以下表达式计算其长度：

```py
1 + my-len(someList.rest)
```

因此，我们的`my-len`程序需要确定其输入列表是空还是非空，在非空情况下使用这个带有`.rest`的表达式。我们如何根据列表的结构来指示不同的代码？

Pyret 有一个名为`cases`的结构，用于区分结构化数据类型中的不同形式。当处理列表时，`cases`表达式的通用形状是：

```py
cases (List) e:
  | empty      => …
  | link(f, r) => … f … r …
end
```

其中大部分部分是固定的，但有一些你可以自由更改：

+   `e`是一个需要返回列表值的表达式；它可以是绑定到列表的变量，或者是一些计算结果为列表的复杂表达式。

+   `f`和`r`是分配给列表的第一个元素和其余部分的名称。你可以选择任何你喜欢的名称，尽管在 Pyret 中，传统上使用`f`和`r`。偶尔使用不同的名称可以帮助学生记住他们可以选择如何标记`first`和`rest`组件。这对于`first`尤其有用，因为它具有特定的含义（例如，在价格列表中的`price`等）。

每个`=>`的右侧都是一个表达式。

这里是如何在这个实例中使用`cases`的。Pyret 首先评估`e`。然后检查结果值是否确实是一个列表；如果不是，它将因错误而停止。如果是列表，Pyret 检查它是什么类型的列表。如果是空列表，它将运行`empty`子句后的表达式。否则，列表不为空，这意味着它有一个首元素和剩余部分；Pyret 将`f`和`r`分别绑定到两个部分，然后评估`link`子句后的表达式。

> 练习
> 
> > 尝试在`e`位置使用一个非列表——例如，一个数字——看看会发生什么！

现在，让我们使用`cases`来定义`my-len`：

```py
fun my-len(l):
  cases (List) l:
    | empty      => 0
    | link(f, r) => 1 + my-len(r)
  end
end
```

这可以从我们的示例中得出：当列表为空时，`my-len`产生`0`；当列表不为空时，我们给列表剩余部分的长度加一（在这里，`r`）。

注意，虽然我们最新的`my-len`示例明确说了`.rest`，但在使用`cases`时，我们只使用名称`r`，这是 Pyret 已经定义（在底层）为`l.rest`的。

同样，让我们定义`my-sum`：

```py
fun my-sum(l):
  cases (List) l:
    | empty      => 0
    | link(f, r) => f + my-sum(r)
  end
end
```

注意它们在代码上的相似性，以及数据结构如何轻易地暗示程序的结构。你很快就会习惯这种模式！

> 策略：在列表上开发函数
> 
> > 利用列表的结构和具体示例的强大功能来开发列表处理函数。
> > 
> > +   选择一个具有（至少）三个元素的具体列表。为整个列表和每个后缀（包括空列表）编写一系列示例。
> > +   
> > +   将每个示例重写，用输入列表的`first`和`rest`数据来表示其预期的答案。你不必在新答案中使用`first`和`rest`运算符，但你应该看到`first`和`rest`值在答案中明确表示。
> > +   
> > +   在示例的答案中寻找一个模式。使用这些来开发代码：编写一个`cases`表达式，根据你的示例填写每个`=>`的右侧。
> > +   
> > 这种策略适用于结构化数据，利用每个数据项的组件，而不是像之前所展示的那样具体使用`first`和`rest`。

##### 5.2.3.1 `my-len`：示例 "链接到此处")

我们还没有精确地定义列表的“长度”是什么意思。当我们尝试编写示例时，我们立即面临这个问题。空列表`empty`的长度是多少？

> 现在行动起来！
> 
> > 你认为呢？

两个常见的示例是`0`和`1`。后者`1`看起来是合理的。然而，如果你将列表写成`[list: ]`，现在它看起来就不太对了：这显然（正如名称`empty`所暗示的）是一个空列表，而空列表中没有任何元素。因此，通常声明

```py
my-len(empty) is 0
```

那么，像`[list: 7]`这样的列表怎么样？嗯，它显然有一个元素（`7`），所以

```py
my-len([list: 7]) is 1
```

同样，对于像`[list: 7, 8, 9]`这样的列表，我们可以说

```py
my-len([list: 7, 8, 9]) is 3
```

现在，让我们以不同的角度来审视那个最后的例子。考虑参数`[list: 7, 8, 9]`。它的第一个元素是`7`，其余的是`[list: 8, 9]`。嗯，`7`是一个数字，不是一个列表；但`[list: 8, 9]`确实是一个列表，所以我们可以询问它的长度。`my-len([list: 8, 9])`是什么？它有两个元素，所以

```py
my-len([list: 8, 9]) is 2
```

该列表的第一个元素是`8`，其余的是`[list: 9]`。它的长度是多少？注意，我们之前已经提出了一个非常类似的问题，即列表`[list: 7]`的长度。但是`[list: 7]`不是我们从`[list: 7, 8, 9]`开始的子列表，而`[list: 9]`是。并且使用与之前相同的推理，我们可以说

```py
my-len([list: 9]) is 1
```

当然，这个列表的其余部分是空列表，其长度我们已决定是`0`。

结合这些例子，并写出`empty`的其他形式，我们得到以下结果：

```py
my-len([list: 7, 8, 9]) is 3
my-len([list:    8, 9]) is 2
my-len([list:       9]) is 1
my-len([list:        ]) is 0
```

另一种我们可以写这个的方式（注意右侧）是

```py
my-len([list: 7, 8, 9]) is 1 + 2
my-len([list:    8, 9]) is 1 + 1
my-len([list:       9]) is 1 + 0
my-len([list:        ]) is     0
```

每个加法操作右侧的`2`、`1`和`0`是从哪里来的？那些是输入列表`rest`组件的长度。在先前的例子块中，我们将这些长度作为明确的例子写出来。让我们用产生它们的`my-len`表达式替换数字`2`、`1`和`0`：

```py
my-len([list: 7, 8, 9]) is 1 + my-len([list: 8, 9])
my-len([list:    8, 9]) is 1 + my-len([list:    9])
my-len([list:       9]) is 1 + my-len([list:     ])
my-len([list:        ]) is 0
```

从这个例子中，你可能开始看到一种模式。对于一个空列表，其长度是`0`。对于一个非空列表，它是`1`（第一个元素对列表长度的“贡献”）加上列表其余部分的长度。换句话说，我们可以使用对列表其余部分计算`my-len`的结果来计算整个列表的答案。

> 现在行动起来！
> 
> > 在本节中的每个例子中，我们都对表达式`my-len([list: 7, 8, 9])`进行了不同的检查。以下是这些例子一起展示，以及一个明确使用`rest`操作的最后一个例子：
> > 
> > ```py
> > my-len([list: 7, 8, 9]) is 3
> > my-len([list: 7, 8, 9]) is 1 + 2
> > my-len([list: 7, 8, 9]) is 1 + my-len([list: 8, 9])
> > my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)
> > ```
> > 
> > 请确认你同意这些断言中的每一个。也要确认你是否理解了每个`is`表达式的右侧是如何从其上方右侧推导出来的。这个练习的目的是确保你相信最后一个检查（我们将将其转换为代码）与第一个（我们在理解问题时写下来的）是等价的。

##### 5.2.3.2 `my-sum`：示例 "链接至此")

让我们在第二个函数上重复这个开发例子的过程，这次是一个计算数字列表中元素总和的函数。列表`[list: 7, 8, 9]`的总和是多少？手动相加这些数字，结果应该是`24`。让我们通过例子看看这是如何实现的。

暂时忽略空列表，以下是一些展示求和计算的例子：

```py
my-sum([list: 7, 8, 9]) is 7 + 8 + 9
my-sum([list:    8, 9]) is     8 + 9
my-sum([list:       9]) is         9
```

这（通过替换）等同于

```py
my-sum([list: 7, 8, 9]) is 7 + my-sum([list: 8, 9])
my-sum([list:    8, 9]) is 8 + my-sum([list:    9])
my-sum([list:       9]) is 9 + my-sum([list:     ])
```

从这里，我们可以看出空列表的总和必须是`0`：零被称为加法恒等式：一种说法，即向任何数字 N 添加零会得到 N。因此，它有道理成为空列表的长度，因为空列表没有项目可以贡献到总和。你能找出乘法恒等式是什么吗？

```py
my-sum(empty) is 0
```

再次观察，我们可以如何使用计算列表其余部分的`my-sum`的结果来计算整个列表的结果。

##### 5.2.3.3 从示例到代码 "链接到此处")

在开发这些示例之后，我们现在想利用它们来开发一个程序，该程序可以计算任何列表的长度或总和，而不仅仅是我们在这些示例中使用的具体列表。正如我们在前面的章节中所做的那样，我们将利用示例中的模式来找出如何定义通用函数。

这里是`my-len`的最后一个示例版本，这次在`is`的右侧明确显示了`rest`：

```py
my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)
my-len([list:    8, 9]) is 1 + my-len([list:    8, 9].rest)
my-len([list:       9]) is 1 + my-len([list:       9].rest)
my-len([list:        ]) is 0
```

正如我们在开发图像上的函数时所做的，让我们尝试识别这些示例的共同部分。我们首先注意到，大多数示例有很多共同之处，除了`[list: ]`（`empty`）情况。所以让我们将这个分成两组示例：

```py
my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)
my-len([list:    8, 9]) is 1 + my-len([list:    8, 9].rest)
my-len([list:       9]) is 1 + my-len([list:       9].rest)

my-len([list:        ]) is 0
```

通过这种分离（这遵循了我们之前提到的列表的结构特征之一），一个更清晰的模式出现了：对于一个非空列表（称为`someList`），我们通过以下表达式来计算其长度：

```py
1 + my-len(someList.rest)
```

因此，我们的`my-len`程序需要确定其输入列表是空还是非空，在非空情况下使用`.rest`这个表达式。我们如何根据列表的结构来指示不同的代码？

Pyret 有一个名为`cases`的结构，用于区分结构化数据类型中的不同形式。当处理列表时，`cases`表达式的通用形状如下：

```py
cases (List) e:
  | empty      => …
  | link(f, r) => … f … r …
end
```

其中大部分部分是固定的，但有一小部分你可以自由更改：

+   `e`是一个需要其值为列表的表达式；它可以是绑定到列表的变量，或者某些复杂的表达式，其结果为列表。

+   `f`和`r`是分配给列表的第一个元素和其余部分的名称。你可以选择任何你喜欢的名称，尽管在 Pyret 中，传统上使用`f`和`r`。偶尔使用不同的名称可以帮助学生记住他们可以选择如何标记`first`和`rest`组件。这对于`first`尤其有用，因为它具有特定的含义（例如，在价格列表中的`price`等）。

每个`=>`的右侧都是一个表达式。

这就是在这个例子中`cases`是如何工作的。Pyret 首先评估`e`。然后检查结果值是否确实是一个列表；如果不是，它将因错误而停止。如果是列表，Pyret 将检查它是什么类型的列表。如果是空列表，它将运行`empty`子句中`=>`后面的表达式。否则，列表不为空，这意味着它有一个首元素和其余部分；Pyret 将`f`和`r`分别绑定到这两部分，然后评估`link`子句中`=>`后面的表达式。

> 练习
> 
> > 尝试使用非列表——例如，一个数字——在`e`位置，看看会发生什么！

现在，让我们使用`cases`来定义`my-len`：

```py
fun my-len(l):
  cases (List) l:
    | empty      => 0
    | link(f, r) => 1 + my-len(r)
  end
end
```

这是从我们的示例中得出的：当列表为空时，`my-len`产生`0`；当它不为空时，我们将其余列表的长度加一（在这里，`r`）。

注意，虽然我们最近的`my-len`示例明确提到了`.rest`，但在使用`cases`时，我们只使用名称`r`，Pyret 已经（在底层）将其定义为`l.rest`。

类似地，让我们定义`my-sum`：

```py
fun my-sum(l):
  cases (List) l:
    | empty      => 0
    | link(f, r) => f + my-sum(r)
  end
end
```

注意它们在代码上的相似性，以及数据结构如何自然而然地暗示程序的结构。这将是您很快就会习惯的模式！

> 策略：在列表上开发函数
> 
> > 利用列表的结构和具体示例的力量来开发列表处理函数。
> > 
> > +   选择一个具有（至少）三个元素的列表。为整个列表和每个后缀（包括空列表）编写一系列示例。
> > +   
> > +   将每个示例重写，用其输入列表的`first`和`rest`数据来表示预期的答案。您不必在新答案中使用`first`和`rest`运算符，但您应该看到`first`和`rest`值在答案中明确表示。
> > +   
> > +   在示例的答案中寻找模式。使用这些来开发代码：编写一个`cases`表达式，根据您的示例填写每个`=>`的右侧。
> > +   
> > 这种策略适用于结构化数据，利用每个数据项的组件，而不是像迄今为止所展示的那样具体使用`first`和`rest`。

#### 5.2.4 将列表转换为结构化问题的方法 "链接到这里")

现在我们有了开发以列表为输入的函数的系统方法，让我们将相同的策略应用到产生列表作为答案的函数上。

##### 5.2.4.1 `my-doubles`：示例和代码 "链接到这里")

和往常一样，我们将从一些示例开始。给定一个数字列表，我们想要一个列表，它将每个数字翻倍（按照原始列表的顺序）。以下是一个包含三个数字的合理示例：

```py
my-doubles([list: 3, 5, 2]) is [list: 6, 10, 4]
```

如前所述，让我们为示例列表的每个后缀写出答案，包括空列表：

```py
my-doubles([list:    5, 2]) is [list:    10, 4]
my-doubles([list:       2]) is [list:        4]
my-doubles([list:        ]) is [list:         ]
```

现在，我们将重写答案表达式，包括每个示例的`first`和`rest`数据。让我们先从`first`数据开始，只针对第一个示例：

```py
my-doubles([list: 3, 5, 2]) is [list: 3 * 2, 10, 4]
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]
```

接下来，让我们在第一个例子中包含`rest`数据（`[list: 5, 2]`）。第一个例子中的当前答案是

```py
[list: 3 * 2, 10, 4]
```

并且`[list: 10, 4]`是使用函数对`[list: 5, 2]`应用的结果。因此，我们可能会想用以下方式替换第一个例子的右侧：

```py
[list: 3 * 2, my-doubles([list: 5, 2])]
```

> 立刻行动！
> 
> > 这个表达式会产生什么值？你可能想尝试这个不直接使用`my-doubles`的例子：
> > 
> > ```py
> > [list: 3 * 2, [list: 10, 4]]
> > ```

哎呀！我们想要一个单一的（扁平）列表，而不是嵌套列表。从重新构思答案以使用`first`和`rest`值的角度来看，这似乎是正确的方向，但我们显然还没有完全达到目标。

> 立刻行动！
> 
> > 以下表达式会产生什么值？
> > 
> > ```py
> > link(3 * 2, [list: 10, 4])
> > ```

注意这两个最后练习中的两个表达式的区别：后者使用`link`将涉及`first`的值放入`rest`的转换中，而前者尝试使用`list:`来完成这个操作。

> 立刻行动！
> 
> > 每个以下表达式产生的列表中有多少个元素？
> > 
> > ```py
> > [list: 25, 16, 32]
> > [list: 25, [list: 16, 32]]
> > link(25, [list: 16, 32])
> > ```
> > 
> 立刻行动！
> 
> > 总结一下`link`和`list:`如何组合元素和列表之间的区别。如果需要，在交互提示符中尝试额外的示例来探索这些想法。

这里的要点是，我们使用`link`将元素插入到现有列表中，而使用`list:`来创建一个包含旧列表作为元素的新列表。回到我们的例子，那么，我们在第一个例子中通过以下方式包含`rest`：

```py
my-doubles([list: 3, 5, 2]) is link(3 * 2, [list: 10, 4])
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]
```

我们将其转换为

```py
my-doubles([list: 3, 5, 2]) is link(3 * 2, my-doubles([list: 5, 2]))
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]
```

将这个想法应用到示例中，我们得到：

```py
my-doubles([list: 3, 5, 2]) is link(3 * 2, my-doubles([list: 5, 2]))
my-doubles([list:    5, 2]) is link(5 * 2, my-doubles([list: 2]))
my-doubles([list:       2]) is link(2 * 2, my-doubles([list: ]))
my-doubles([list:        ]) is [list:             ]
```

现在我们有了明确使用`first`和`rest`元素的例子，我们可以编写`my-doubles`函数：

```py
fun my-doubles(l):
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      link(f * 2, my-doubles(r))
  end
end
```

##### 5.2.4.2 `my-str-len`：示例和代码 "链接到此处")

在`my-doubles`中，输入和输出列表具有相同类型的元素。函数也可以生成内容类型与输入列表不同的列表。让我们通过一个例子来分析。给定一个字符串列表，我们想要每个字符串的长度（与输入列表中的顺序相同）。因此，这里有一个合理的例子：

```py
my-str-len([list: "hi", "there", "mateys"]) is [list: 2, 5, 6]
```

如同之前，我们应该考虑上述例子中每个子问题的答案：

```py
my-str-len([list:       "there", "mateys"]) is [list:    5, 6]
my-str-len([list:                "mateys"]) is [list:       6]
```

或者换句话说：

```py
my-str-len([list: "hi", "there", "mateys"]) is link(2, [list: 5, 6])
my-str-len([list:       "there", "mateys"]) is link(5, [list:    6])
my-str-len([list:                "mateys"]) is link(6, [list:     ])
```

这告诉我们空列表的响应应该是`empty`：

```py
my-str-len(empty) is empty
```

下一步是将示例中的答案重新构思，使`first`和`rest`部分明确。希望到现在你已经开始发现一个模式：列表的其余部分的输出明确地作为另一个例子出现。因此，我们将首先获取每个示例输入的`rest`值到答案中：

```py
my-str-len([list: "hi", "there", "mateys"]) is link(2, my-str-len([list: "there", "mateys"]))
my-str-len([list:       "there", "mateys"]) is link(5, my-str-len([list:          "mateys"]))
my-str-len([list:                "mateys"]) is link(6, my-str-len([list:                  ]))
my-str-len([list:                        ]) is [list: ]
```

现在剩下的就是弄清楚如何将`first`值整合到输出中。在这个问题的背景下，这意味着我们需要将`"hi"`转换为`2`，将`"there"`转换为`5`等等。从问题陈述中，我们知道`2`和`5`是指对应字符串的长度（字符计数）。确定字符串长度的操作称为`string-length`。因此，我们的例子如下所示：

```py
my-str-len([list: "hi", "there", "mateys"]) is link(string-length("hi"), my-str-len([list: "there", "mateys"]))
my-str-len([list:       "there", "mateys"]) is link(string-length("there"), my-str-len([list:          "mateys"]))
my-str-len([list:                "mateys"]) is link(string-length("mateys"), my-str-len([list: ]))
my-str-len([list:                        ]) is [list: ]
```

从这里，我们编写一个函数来捕捉我们例子中开发的模式：

```py
fun my-str-len(l):
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      link(string-length(f), my-str-len(r))
  end
end
```

##### 5.2.4.1 `my-doubles`: 示例和代码 "链接至此")

总是，我们将从一些例子开始。给定一个数字列表，我们想要一个列表，它将每个数字加倍（按原始列表的顺序）。以下是一个包含三个数字的合理例子：

```py
my-doubles([list: 3, 5, 2]) is [list: 6, 10, 4]
```

如前所述，让我们为我们的例子列表的每个后缀写出答案，包括空列表：

```py
my-doubles([list:    5, 2]) is [list:    10, 4]
my-doubles([list:       2]) is [list:        4]
my-doubles([list:        ]) is [list:         ]
```

现在，我们重写答案表达式，包括每个例子的具体 `first` 和 `rest` 数据。让我们先从 `first` 数据开始，仅针对第一个例子：

```py
my-doubles([list: 3, 5, 2]) is [list: 3 * 2, 10, 4]
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]
```

接下来，让我们在第一个例子中包含 `rest` 数据 (`[list: 5, 2]`)。第一个例子中的当前答案是

```py
[list: 3 * 2, 10, 4]
```

并且 `[list: 10, 4]` 是使用函数 `[list: 5, 2]` 的结果。因此，我们可能会想用以下内容替换第一个例子的右侧：

```py
[list: 3 * 2, my-doubles([list: 5, 2])]
```

> 立刻行动！
> 
> > 这个表达式会产生什么值？你可能想尝试这个不直接使用 `my-doubles` 的例子：
> > 
> > ```py
> > [list: 3 * 2, [list: 10, 4]]
> > ```

哎呀！我们想要一个单一的（扁平）列表，而不是列表中的列表。这感觉在重新设计答案以使用 `first` 和 `rest` 值方面是正确的方向，但我们显然还没有完全做到。

> 立刻行动！
> 
> > 以下表达式会产生什么值？
> > 
> > ```py
> > link(3 * 2, [list: 10, 4])
> > ```

注意这两个最后练习中的两个表达式的区别：后者使用 `link` 将涉及 `first` 的值放入 `rest` 的转换中，而前者试图使用 `list:` 来做这件事。

> 立刻行动！
> 
> > 每个以下表达式产生的列表中有多少个元素？
> > 
> > ```py
> > [list: 25, 16, 32]
> > [list: 25, [list: 16, 32]]
> > link(25, [list: 16, 32])
> > ```
> > 
> 立刻行动！
> 
> > 总结 `link` 和 `list:` 如何组合元素和列表之间的区别。如果需要，在交互提示符中尝试额外的例子来探索这些想法。

这里的要点是，我们使用 `link` 在现有列表中插入一个元素，而使用 `list:` 来创建一个包含旧列表作为元素的新列表。回到我们的例子，那么，我们通过以下方式在第一个例子中包含 `rest`：

```py
my-doubles([list: 3, 5, 2]) is link(3 * 2, [list: 10, 4])
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]
```

然后我们将它转换为

```py
my-doubles([list: 3, 5, 2]) is link(3 * 2, my-doubles([list: 5, 2]))
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]
```

将这个想法应用到例子中，我们得到：

```py
my-doubles([list: 3, 5, 2]) is link(3 * 2, my-doubles([list: 5, 2]))
my-doubles([list:    5, 2]) is link(5 * 2, my-doubles([list: 2]))
my-doubles([list:       2]) is link(2 * 2, my-doubles([list: ]))
my-doubles([list:        ]) is [list:             ]
```

现在我们有了明确使用 `first` 和 `rest` 元素的例子，我们可以编写 `my-doubles` 函数：

```py
fun my-doubles(l):
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      link(f * 2, my-doubles(r))
  end
end
```

##### 5.2.4.2 `my-str-len`: 示例和代码 "链接至此")

在 `my-doubles` 中，输入和输出列表具有相同类型的元素。函数还可以生成内容类型与输入列表不同的列表。让我们通过一个例子来解决这个问题。给定一个字符串列表，我们想要每个字符串的长度（与输入列表中的顺序相同）。因此，这里是一个合理的例子：

```py
my-str-len([list: "hi", "there", "mateys"]) is [list: 2, 5, 6]
```

如我们之前所做的那样，我们应该考虑上述例子中每个子问题的答案：

```py
my-str-len([list:       "there", "mateys"]) is [list:    5, 6]
my-str-len([list:                "mateys"]) is [list:       6]
```

或者，换句话说：

```py
my-str-len([list: "hi", "there", "mateys"]) is link(2, [list: 5, 6])
my-str-len([list:       "there", "mateys"]) is link(5, [list:    6])
my-str-len([list:                "mateys"]) is link(6, [list:     ])
```

这告诉我们空列表的响应应该是 `empty`：

```py
my-str-len(empty) is empty
```

下一步是将示例中的答案重新整理，使`first`和`rest`部分明确。希望到现在为止，你已经开始发现一个模式：列表剩余部分的结果明确地作为另一个示例出现。因此，我们将首先将每个示例输入的`rest`值放入答案中：

```py
my-str-len([list: "hi", "there", "mateys"]) is link(2, my-str-len([list: "there", "mateys"]))
my-str-len([list:       "there", "mateys"]) is link(5, my-str-len([list:          "mateys"]))
my-str-len([list:                "mateys"]) is link(6, my-str-len([list:                  ]))
my-str-len([list:                        ]) is [list: ]
```

现在剩下的就是弄清楚如何将`first`值整合到输出中。在这个问题的背景下，这意味着我们需要将`"hi"`转换为`2`，将`"there"`转换为`5`，依此类推。从问题陈述中，我们知道`2`和`5`是指对应字符串的长度（字符计数）。确定字符串长度的操作称为`string-length`。因此，我们的示例如下所示：

```py
my-str-len([list: "hi", "there", "mateys"]) is link(string-length("hi"), my-str-len([list: "there", "mateys"]))
my-str-len([list:       "there", "mateys"]) is link(string-length("there"), my-str-len([list:          "mateys"]))
my-str-len([list:                "mateys"]) is link(string-length("mateys"), my-str-len([list: ]))
my-str-len([list:                        ]) is [list: ]
```

从这里，我们编写一个函数来捕捉我们在示例中开发的模式：

```py
fun my-str-len(l):
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      link(string-length(f), my-str-len(r))
  end
end
```

#### 5.2.5 结构化问题，从列表中选择 "链接到这里")

在上一节中，我们看到了转换列表元素的函数（通过加倍数字或计算字符）。输出列表的类型可能与输入列表的类型相同，也可能不同。其他产生列表而不是选择元素的函数，输出列表中的每个元素都在输入列表中，但输入列表中的一些元素可能不会出现在输出列表中。本节将我们的从示例推导函数的方法适应元素选择。

##### 5.2.5.1 `my-pos-nums`：示例和代码 "链接到这里")

作为我们的第一个示例，我们将从包含正数和非正数的列表中选择正数。

> 现在行动！
> 
> > 构建从输入`[list: 1, -2, 3, -4]`获得的示例序列。

这里是：

```py
my-pos-nums([list: 1, -2, 3, -4]) is [list: 1, 3]
my-pos-nums([list:    -2, 3, -4]) is [list:    3]
my-pos-nums([list:        3, -4]) is [list:    3]
my-pos-nums([list:           -4]) is [list:     ]
my-pos-nums([list:             ]) is [list:     ]
```

我们可以写成以下形式：

```py
my-pos-nums([list: 1, -2, 3, -4]) is link(1, [list: 3])
my-pos-nums([list:    -2, 3, -4]) is         [list: 3]
my-pos-nums([list:        3, -4]) is link(3, [list: ])
my-pos-nums([list:           -4]) is         [list: ]
my-pos-nums([list:             ]) is         [list: ]
```

或者，更明确地说，

```py
my-pos-nums([list: 1, -2, 3, -4]) is link(1, my-pos-nums([list: -2, 3, -4]))
my-pos-nums([list:    -2, 3, -4]) is         my-pos-nums([list:     3, -4])
my-pos-nums([list:        3, -4]) is link(3, my-pos-nums([list:        -4]))
my-pos-nums([list:           -4]) is         my-pos-nums([list:          ])
my-pos-nums([list:             ]) is         [list: ]
```

与函数转换列表的示例序列不同，这里我们看到答案有不同的形状：一些涉及`link`，而另一些只是处理列表的`rest`部分。每当我们需要在一系列示例中具有不同形状的输出时，我们将在代码中需要一个`if`表达式来区分产生每种形状的条件。

是什么决定了我们得到的输出形状？让我们按照输出形状重新排列示例（除了空列表输入之外）：

```py
my-pos-nums([list: 1, -2, 3, -4]) is link(1, my-pos-nums([list: -2, 3, -4]))
my-pos-nums([list:        3, -4]) is link(3, my-pos-nums([list:        -4]))

my-pos-nums([list:    -2, 3, -4]) is         my-pos-nums([list:     3, -4])
my-pos-nums([list:           -4]) is         my-pos-nums([list:          ])
```

重新组织后，我们可以看到使用`link`的示例在`first`位置有一个正数，而没有使用`link`的示例只是处理列表的`rest`部分。这表明我们的`if`表达式需要询问列表中的`first`元素是否为正数。这产生了以下程序：

```py
fun my-pos-nums(l):
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      if f > 0:
        link(f, my-pos-nums(r))
      else:
        my-pos-nums(r)
      end
  end
end
```

> 现在行动！
> 
> > 我们的示例集是否全面？

实际上不是。还有很多我们没有考虑到的示例，例如以正数结尾的列表和包含`0`的列表。

> 练习
> 
> > 仔细研究这些示例，看看它们如何影响程序！

##### 5.2.5.2 `my-alternating`：示例和代码 "链接到这里")

现在，让我们考虑一个通过位置而不是值选择元素的问题。我们想要编写一个从列表中选择交替元素的功能。再一次，我们将从示例开始工作。

> 现在就做！
> 
> > 从列表`[list: 1, 2, 3, 4, 5, 6]`开始，计算`my-alternating`的结果。

这是它们是如何工作的：

<alternating-egs-1> ::=

```py
check:
  my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
  my-alternating([list:    2, 3, 4, 5, 6]) is [list: 2, 4, 6]
  my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]
  my-alternating([list:          4, 5, 6]) is [list:    4, 6]
end
```

等等，那是什么？上面的两个答案都是正确的，但第二个答案并不能帮助我们构建第一个答案。这意味着我们到目前为止解决问题的方法不足以解决这种新类型的问题。尽管如此，它仍然是有用的：注意，第一个示例和第三个示例之间，以及第二个示例和第四个示例之间，存在联系。这一观察与我们的选择交替元素的目标是一致的。

这在代码中会是什么样子？在我们尝试编写函数之前，让我们用第三个示例来重写第一个示例：

```py
my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]

my-alternating([list: 1, 2, 3, 4, 5, 6]) is link(1, my-alternating([list: 3, 4, 5, 6]))
```

注意，在重写的版本中，我们在再次使用`my-alternating`之前从列表中删除了两个元素，而不仅仅是其中一个。我们将在代码中找出如何处理这一点。

让我们从带有`cases`表达式的常规函数模式开始：

```py
fun my-alternating(l):
  cases (List) l:
    | empty => [list:]
    | link(f, r) => link(f, … r …)
  end
end
```

注意，我们不能简单地调用`my-alternating`在`r`上，因为`r`只从列表中排除一个元素，而不是这个问题的两个元素。我们必须分解`r`，以便到达原始列表的`rest`的`rest`。为此，我们使用另一个`cases`表达式，它嵌套在第一个`cases`表达式中：

```py
fun my-alternating(l):
  cases (List) l:
    | empty => [list:]
    | link(f, r) =>
      cases (List) r:  # note: deconstructing r, not l
        | empty => ??? # note the ???
        | link(fr, rr) =>
          # fr = first of rest, rr = rest of rest
          link(f, my-alternating(rr))
      end
  end
end
```

这段代码与我们刚刚解决的示例一致。但请注意，我们仍然有一些未完成的工作要做：我们需要决定在内层`cases`表达式的`empty`情况下要做什么（在代码中用`???`标记）。 

在这一点上，一个常见的诱惑是将`???`替换为`[list:]`。毕竟，在`empty`情况下，我们不是总是返回`[list:]`吗？

> 现在就做！
> 
> > 将`???`替换为`[list:]`并在我们的原始示例上测试程序：
> > 
> > ```py
> > my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
> > my-alternating([list:    2, 3, 4, 5, 6]) is [list: 2, 4, 6]
> > my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]
> > my-alternating([list:          4, 5, 6]) is [list:    4, 6]
> > ```
> > 
> > 你观察到了什么？

哎呀！我们编写了一个似乎在偶数元素列表上工作但在奇数元素列表上不工作的程序。这是怎么发生的？我们唯一猜测的部分是内层`cases`的`empty`情况，所以问题肯定在那里。然而，与其关注代码，不如关注示例。我们需要一个简单的示例，以便定位到代码的该部分。当列表`l`不为空但`r`（`l`的其余部分）为空时，我们就会到达那个位置。换句话说，我们需要一个只有一个元素的示例。

> 现在就做！
> 
> > 完成以下示例：
> > 
> > ```py
> > my-alternating([list: 5]) is ???
> > ```

给定一个只有一个元素的列表，该元素应包含在交替元素列表中。因此，我们应该将此示例完成如下

```py
my-alternating([list: 5]) is [list: 5]
```

> 现在就做！
> 
> > 使用此示例来更新代码中`r`为空时`my-alternating`的结果。

利用这个新示例，`my-alternating`的最终版本如下：

```py
fun my-alternating(l):
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      cases (List) r: # note: deconstructing r, not l
        | empty =>    # the list has an odd number of elements
          [list: f]
        | link(fr, rr) =>
          # fr = first of rest, rr = rest of rest
          link(f, my-alternating(rr))
      end
  end
end
```

这个问题有什么启示？有两个：

+   不要忽略小例子：列表处理函数在`empty`情况下的结果不总是`empty`。

+   如果一个问题要求你处理列表前面的多个元素，你可以嵌套`cases`表达式来访问后续元素。

这些启示在未来例子中还会很重要：请注意它们！

##### 5.2.5.1 `my-pos-nums`: 示例和代码 "链接到这里")

作为我们的第一个例子，我们将从包含正数和非正数的列表中选择正数。

> 立即行动！
> 
> > 构建从输入`[list: 1, -2, 3, -4]`获得的示例序列。

这里我们开始：

```py
my-pos-nums([list: 1, -2, 3, -4]) is [list: 1, 3]
my-pos-nums([list:    -2, 3, -4]) is [list:    3]
my-pos-nums([list:        3, -4]) is [list:    3]
my-pos-nums([list:           -4]) is [list:     ]
my-pos-nums([list:             ]) is [list:     ]
```

我们可以写成以下形式：

```py
my-pos-nums([list: 1, -2, 3, -4]) is link(1, [list: 3])
my-pos-nums([list:    -2, 3, -4]) is         [list: 3]
my-pos-nums([list:        3, -4]) is link(3, [list: ])
my-pos-nums([list:           -4]) is         [list: ]
my-pos-nums([list:             ]) is         [list: ]
```

或者，甚至更明确地，

```py
my-pos-nums([list: 1, -2, 3, -4]) is link(1, my-pos-nums([list: -2, 3, -4]))
my-pos-nums([list:    -2, 3, -4]) is         my-pos-nums([list:     3, -4])
my-pos-nums([list:        3, -4]) is link(3, my-pos-nums([list:        -4]))
my-pos-nums([list:           -4]) is         my-pos-nums([list:          ])
my-pos-nums([list:             ]) is         [list: ]
```

与变换列表的函数的示例序列不同，这里我们看到答案有不同的形状：一些涉及`link`，而另一些则简单地处理列表的`rest`部分。每当我们需要在一系列示例中获取不同形状的输出时，我们都需要在代码中使用`if`表达式来区分产生每种形状的条件。

是什么决定了我们得到哪种形状的输出？让我们按输出形状重新排列示例（除了空列表输入）：

```py
my-pos-nums([list: 1, -2, 3, -4]) is link(1, my-pos-nums([list: -2, 3, -4]))
my-pos-nums([list:        3, -4]) is link(3, my-pos-nums([list:        -4]))

my-pos-nums([list:    -2, 3, -4]) is         my-pos-nums([list:     3, -4])
my-pos-nums([list:           -4]) is         my-pos-nums([list:          ])
```

重新组织后，我们可以看到使用`link`的例子在`first`位置有一个正数，而没有使用`link`的例子则简单地处理列表的`rest`部分。这表明我们的`if`表达式需要询问列表中的第一个元素是否为正。这导致了以下程序：

```py
fun my-pos-nums(l):
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      if f > 0:
        link(f, my-pos-nums(r))
      else:
        my-pos-nums(r)
      end
  end
end
```

> 立即行动！
> 
> > 我们的示例集是否全面？

实际上并不全面。还有很多我们没有考虑的例子，比如以正数结尾的列表和包含`0`的列表。

> 练习
> 
> > 通过这些例子，看看它们如何影响程序！

##### 5.2.5.2 `my-alternating`: 示例和代码 "链接到这里")

现在，让我们考虑一个问题，它不是根据值而是根据位置选择元素。我们想要编写一个函数，从列表中选择交替元素。再一次，我们将从例子开始工作。

> 立即行动！
> 
> > 从列表`[list: 1, 2, 3, 4, 5, 6]`开始，计算`my-alternating`的结果。

这是它们是如何工作的：

<alternating-egs-1> ::=

```py
check:
  my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
  my-alternating([list:    2, 3, 4, 5, 6]) is [list: 2, 4, 6]
  my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]
  my-alternating([list:          4, 5, 6]) is [list:    4, 6]
end
```

等等，那是什么？上面的两个答案都是正确的，但第二个答案并不能帮助我们构建第一个答案。这意味着我们到目前为止解决问题的方法对于这种新类型的问题还不够。尽管如此，它仍然是有用的：注意第一个例子和第三个例子之间，以及第二个例子和第四个例子之间的联系。这个观察与我们的选择交替元素的目标是一致的。

这样的代码会是什么样子？在我们尝试编写函数之前，让我们用第三个例子来重写第一个例子：

```py
my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]

my-alternating([list: 1, 2, 3, 4, 5, 6]) is link(1, my-alternating([list: 3, 4, 5, 6]))
```

注意，在重写的版本中，我们在再次使用`my-alternating`之前从列表中删除了两个元素，而不仅仅是其中一个。我们将在代码中找出如何处理这一点。

让我们从我们常用的带有`cases`表达式的函数模式开始：

```py
fun my-alternating(l):
  cases (List) l:
    | empty => [list:]
    | link(f, r) => link(f, … r …)
  end
end
```

注意，我们不能简单地调用`my-alternating`在`r`上，因为`r`只排除了列表中的一个元素，而不是这个问题的两个元素。我们必须分解`r`，以便到达原始列表的`rest`的`rest`。为此，我们使用另一个`cases`表达式，嵌套在第一个`cases`表达式内部：

```py
fun my-alternating(l):
  cases (List) l:
    | empty => [list:]
    | link(f, r) =>
      cases (List) r:  # note: deconstructing r, not l
        | empty => ??? # note the ???
        | link(fr, rr) =>
          # fr = first of rest, rr = rest of rest
          link(f, my-alternating(rr))
      end
  end
end
```

这段代码与我们刚刚解决的那个例子一致。但请注意，我们还有一些未完成的工作要做：我们需要决定在内部`cases`表达式的`empty`情况下应该做什么（在代码中用`???`标记）。

在这一点上，一个常见的诱惑是将`???`替换为`[list:]`。毕竟，我们不是总是在`empty`情况下返回`[list:]`吗？

> 现在行动！
> 
> > 将`???`替换为`[list:]`并在我们的原始例子上测试程序：
> > 
> > ```py
> > my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
> > my-alternating([list:    2, 3, 4, 5, 6]) is [list: 2, 4, 6]
> > my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]
> > my-alternating([list:          4, 5, 6]) is [list:    4, 6]
> > ```
> > 
> > 你观察到了什么？

哎呀！我们编写了一个似乎只适用于元素数量为偶数的列表的程序，但不适用于元素数量为奇数的列表。这是怎么发生的？我们唯一猜测的部分是如何填充内部`cases`的`empty`情况，所以问题肯定在那里。然而，与其关注代码，不如关注例子。我们需要一个简单的例子，以便定位到代码的这部分。当列表`l`不为空，但`r`（`l`的其余部分）为空时，我们就到达了那个位置。换句话说，我们需要一个只有一个元素的例子。

> 现在行动！
> 
> > 完成以下例子：
> > 
> > ```py
> > my-alternating([list: 5]) is ???
> > ```

给定一个只有一个元素的列表，该元素应该包含在交替元素列表中。因此，我们应该完成这个例子如下：

```py
my-alternating([list: 5]) is [list: 5]
```

> 现在行动！
> 
> > 使用这个例子来更新我们代码中`r`为`empty`时`my-alternating`的结果。

利用这个新例子，`my-alternating`的最终版本如下：

```py
fun my-alternating(l):
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      cases (List) r: # note: deconstructing r, not l
        | empty =>    # the list has an odd number of elements
          [list: f]
        | link(fr, rr) =>
          # fr = first of rest, rr = rest of rest
          link(f, my-alternating(rr))
      end
  end
end
```

这个问题的启示有哪些？有两个：

+   不要忽略小例子：列表处理函数在`empty`情况下的结果不总是`empty`。

+   如果一个问题要求你处理列表前面的多个元素，你可以嵌套`cases`表达式来访问后续元素。

这些启示在未来例子中还会再次发挥作用：留意它们！

#### 5.2.6 结构化问题在放宽域上 "链接到这里")

##### 5.2.6.1 `my-max`：例子 "链接到这里")

现在我们来找出列表中的最大值。为了简单起见，我们假设我们只处理数字列表。我们应该构建哪些类型的列表？显然，我们应该有空列表和非空列表……但是还有什么？像`[list: 1, 2, 3]`这样的列表是一个好例子吗？嗯，它没有问题，但我们还应该考虑最大值在开头而不是结尾的列表；最大值可能在中间；最大值可能重复；最大值可能是负数；等等。虽然不是全面的，但这里有一组小而有趣的例子：

```py
my-max([list: 1, 2, 3]) is 3
my-max([list: 3, 2, 1]) is 3
my-max([list: 2, 3, 1]) is 3
my-max([list: 2, 3, 1, 3, 2]) is 3
my-max([list: 2, 1, 4, 3, 2]) is 4
my-max([list: -2, -1, -3]) is -1
```

那么`my-max(empty)`呢？

> 现在行动起来！
> 
> > 我们能否定义`my-max(empty)`为`0`？对于空列表返回`0`已经有效两次了！

我们稍后会回到这个问题。

在我们继续之前，了解 Pyret 中已经定义了一个名为`num-max`的函数是有用的，该函数用于比较两个数字：

```py
num-max(1, 2) is 2
num-max(-1, -2) is -1
```

> 练习
> 
> > 假设`num-max`尚未内置。你能定义它吗？你会发现你学到的关于布尔值的知识很有用。记得写一些测试！

现在我们可以看看`my-max`是如何工作的：

```py
my-max([list: 1, 2, 3]) is 3
my-max([list:    2, 3]) is 3
my-max([list:       3]) is 3
```

嗯。这并没有真正教会我们什么，对吧？也许，我们无法确定。而且我们仍然不知道如何处理`empty`。

让我们尝试第二个示例输入：

```py
my-max([list: 3, 2, 1]) is 3
my-max([list:    2, 1]) is 2
my-max([list:       1]) is 1
```

这实际上也在告诉我们一些有用的信息，但我们可能还没有看到。让我们承担一个更有雄心的任务：

```py
my-max([list: 2, 1, 4, 3, 2]) is 4
my-max([list:    1, 4, 3, 2]) is 4
my-max([list:       4, 3, 2]) is 4
my-max([list:          3, 2]) is 3
my-max([list:             2]) is 2
```

观察列表 rest 的最大值如何给我们一个候选答案，但与第一个元素比较则给出了一个确定的答案：

```py
my-max([list: 2, 1, 4, 3, 2]) is num-max(2, 4)
my-max([list:    1, 4, 3, 2]) is num-max(1, 4)
my-max([list:       4, 3, 2]) is num-max(4, 3)
my-max([list:          3, 2]) is num-max(3, 2)
my-max([list:             2]) is …
```

最后一个是有点尴尬：我们希望写

```py
my-max([list:             2]) is num-max(2, …)
```

但我们实际上并不知道空列表的最大值（或最小值，或任何其他元素）是什么，但我们只能向`num-max`提供数字。因此，排除了那个可疑的情况，我们只剩下

```py
my-max([list: 2, 1, 4, 3, 2]) is num-max(2, my-max([list: 1, 4, 3, 2]))
my-max([list:    1, 4, 3, 2]) is num-max(1, my-max([list:    4, 3, 2]))
my-max([list:       4, 3, 2]) is num-max(4, my-max([list:       3, 2]))
my-max([list:          3, 2]) is num-max(3, my-max([list:          2]))
```

我们的示例再次帮到了我们：它们揭示了我们可以如何使用每个 rest 列表的答案来计算整个列表的答案，而这个答案又是另一个列表的 rest，依此类推。如果你回过头去看我们上面写的其他示例列表，你也会看到这个模式。

然而，现在是时候面对`empty`的情况了。真正的问题是，我们没有空列表的最大值：对于我们可能提供的任何数字，总有一个更大的数字（假设我们的计算机足够大）可能是答案。简而言之，询问空列表的最大值（或最小值）是没有意义的：最大值的概念仅在非空列表上定义！也就是说，当询问空列表的最大值时，我们应该引发错误：

```py
my-max(empty) raises ""
```

（这是在 Pyret 中我们说它会生成错误的方式；我们不在乎错误的细节，因此是空字符串）。

##### 5.2.6.2 `my-max`：从示例到代码 "链接到此处")

再次，我们可以将上面的例子编码化，即，将它们转换成一个适用于所有实例的统一程序。然而，我们现在有一个转折。如果我们盲目地遵循之前使用的模式，我们最终会得到：

```py
fun my-max(l):
  cases (List) l:
    | empty      => raise("not defined for empty lists")
    | link(f, r) => num-max(f, my-max(r))
  end
end
```

> 现在就做！
> 
> > 这有什么问题？

考虑列表`[list: 2]`。这变成了

```py
num-max(2, my-max([list: ]))
```

当然，这会引发错误。因此，这个函数对任何包含一个或多个元素的列表都不会工作！

这是因为我们需要确保我们不是在尝试计算空列表的最大值。回到我们的例子，我们看到在我们调用`my-max`之前，我们需要检查列表的剩余部分是否为空。如果是，我们根本不想调用`my-max`。那就是：

```py
fun my-max(l):
  cases (List) l:
    | empty      => raise("not defined for empty lists")
    | link(f, r) =>
      cases (List) r:
        | empty => …
        | …
      end
  end
end
```

我们稍后会回到当剩余部分不为空时应该做什么。

如果列表的剩余部分`l`为空，我们上面的例子告诉我们最大值是列表中的第一个元素。因此，我们可以填写这个空白：

```py
fun my-max(l):
  cases (List) l:
    | empty      => raise("not defined for empty lists")
    | link(f, r) =>
      cases (List) r:
        | empty => f
        | …
      end
  end
end
```

特别注意，没有调用`my-max`。然而，如果列表不为空，我们上面的例子告诉我们`my-max`会给出列表剩余部分的最大值，我们只需要将这个答案与第一个元素（`f`）进行比较：

```py
fun my-max(l):
  cases (List) l:
    | empty      => raise("not defined for empty lists")
    | link(f, r) =>
      cases (List) r:
        | empty => f
        | else  => num-max(f, my-max(r))
      end
  end
end
```

当然，这个定义确实完成了任务！

##### 5.2.6.1 `my-max`: 示例 "链接到这里")

现在让我们找到列表的最大值。为了简单起见，假设我们只处理数字列表。我们应该构建什么样的列表？显然，我们应该有空列表和非空列表……但是还有什么？列表`[list: 1, 2, 3]`是一个好例子吗？嗯，它没有问题，但我们还应该考虑最大值在开头而不是结尾的列表；最大值可能在中间；最大值可能重复；最大值可能是负数；等等。虽然不是全面的，但这里有一组小而有趣的例子：

```py
my-max([list: 1, 2, 3]) is 3
my-max([list: 3, 2, 1]) is 3
my-max([list: 2, 3, 1]) is 3
my-max([list: 2, 3, 1, 3, 2]) is 3
my-max([list: 2, 1, 4, 3, 2]) is 4
my-max([list: -2, -1, -3]) is -1
```

`my-max(empty)`怎么办？

> 现在就做！
> 
> > 我们能否定义`my-max(empty)`为`0`？对于空列表，返回`0`已经有效两次了！

我们稍后会回到这个问题。

在我们继续之前，了解 Pyret 中已经定义了一个名为`num-max`的函数是有用的，该函数比较两个数字：

```py
num-max(1, 2) is 2
num-max(-1, -2) is -1
```

> 练习
> 
> > 假设`num-max`还没有内置。你能定义它吗？你会发现你学到的关于布尔值的知识很有用。记得写一些测试！

现在，我们可以看看`my-max`是如何工作的：

```py
my-max([list: 1, 2, 3]) is 3
my-max([list:    2, 3]) is 3
my-max([list:       3]) is 3
```

嗯。这并没有真正教会我们什么，是吗？也许，我们无法确定。而且我们仍然不知道如何处理`empty`。

让我们尝试第二个示例输入：

```py
my-max([list: 3, 2, 1]) is 3
my-max([list:    2, 1]) is 2
my-max([list:       1]) is 1
```

这实际上在告诉我们一些有用的信息，但我们可能现在还看不到。让我们承担一个更有雄心的任务：

```py
my-max([list: 2, 1, 4, 3, 2]) is 4
my-max([list:    1, 4, 3, 2]) is 4
my-max([list:       4, 3, 2]) is 4
my-max([list:          3, 2]) is 3
my-max([list:             2]) is 2
```

观察列表剩余部分的最大值如何给我们一个候选答案，但与第一个元素比较则给出了一个确定的答案：

```py
my-max([list: 2, 1, 4, 3, 2]) is num-max(2, 4)
my-max([list:    1, 4, 3, 2]) is num-max(1, 4)
my-max([list:       4, 3, 2]) is num-max(4, 3)
my-max([list:          3, 2]) is num-max(3, 2)
my-max([list:             2]) is …
```

最后一个是有点尴尬：我们希望写

```py
my-max([list:             2]) is num-max(2, …)
```

但我们实际上并不知道空列表的最大值（或最小值，或任何其他元素）是什么，但我们只能向 `num-max` 提供数字。因此，排除了那个可疑的情况，我们只剩下

```py
my-max([list: 2, 1, 4, 3, 2]) is num-max(2, my-max([list: 1, 4, 3, 2]))
my-max([list:    1, 4, 3, 2]) is num-max(1, my-max([list:    4, 3, 2]))
my-max([list:       4, 3, 2]) is num-max(4, my-max([list:       3, 2]))
my-max([list:          3, 2]) is num-max(3, my-max([list:          2]))
```

我们的例子再次帮到了我们：它们揭示了我们可以如何使用每个列表其余部分的答案来计算整个列表的答案，而这个答案又是某个其他列表的其余部分，依此类推。如果你回顾一下我们上面写的其他示例列表，你也会看到这个模式在那里成立。

然而，现在是时候我们面对 `empty` 的情况了。真正的问题是，我们没有空列表的最大值：对于我们可能提供的任何数字，总有一个更大的数字（假设我们的计算机足够大）可能是答案。简而言之，询问空列表的最大值（或最小值）是没有意义的：最大值的概念仅在非空列表上定义！也就是说，当询问空列表的最大值时，我们应该引发错误：

```py
my-max(empty) raises ""
```

（这是我们如何在 Pyret 中表示它将生成错误的方式；我们不在乎错误的细节，因此是空字符串）。

##### 5.2.6.2 `my-max`: 从示例到代码 "链接至此")

再次，我们可以将上面的例子编码化，即，将它们转换成一个适用于所有实例的统一程序。然而，我们现在有一个转折。如果我们盲目地遵循我们之前使用的模式，我们最终会得到：

```py
fun my-max(l):
  cases (List) l:
    | empty      => raise("not defined for empty lists")
    | link(f, r) => num-max(f, my-max(r))
  end
end
```

> 现在行动！
> 
> > 这有什么问题？

考虑列表 `[list: 2]`。这变成了

```py
num-max(2, my-max([list: ]))
```

这当然会引发错误。因此，这个函数对于任何包含一个或多个元素的列表都不会工作！

这是因为我们需要确保我们不是在尝试计算空列表的最大值。回到我们的例子，我们看到在调用 `my-max` 之前，我们需要检查列表的其余部分是否为空。如果是，我们根本不想调用 `my-max`。也就是说：

```py
fun my-max(l):
  cases (List) l:
    | empty      => raise("not defined for empty lists")
    | link(f, r) =>
      cases (List) r:
        | empty => …
        | …
      end
  end
end
```

我们稍后会回到当其余部分不为空时应该做什么。

如果列表 `l` 的其余部分为空，我们上面的例子告诉我们最大值是列表中的第一个元素。因此，我们可以这样填写：

```py
fun my-max(l):
  cases (List) l:
    | empty      => raise("not defined for empty lists")
    | link(f, r) =>
      cases (List) r:
        | empty => f
        | …
      end
  end
end
```

特别注意没有调用 `my-max`。然而，如果列表不为空，我们上面的例子告诉我们 `my-max` 将给出列表其余部分的最大值，我们只需要将这个答案与第一个元素（`f`）进行比较：

```py
fun my-max(l):
  cases (List) l:
    | empty      => raise("not defined for empty lists")
    | link(f, r) =>
      cases (List) r:
        | empty => f
        | else  => num-max(f, my-max(r))
      end
  end
end
```

当然，这个定义确实完成了任务！

#### 5.2.7 标量答案的更多结构问题 "链接至此")

##### 5.2.7.1 `my-avg`: 示例 "链接至此")

现在我们尝试计算一个数字列表的平均值。让我们从示例列表 `[list: 1, 2, 3, 4]` 开始，并从中推导出更多示例。这个列表中数字的平均值显然是 `(1 + 2 + 3 + 4)/4`，即 `10/4`。

根据列表的结构，我们看到列表的其余部分是 `[list: 2, 3, 4]`，而那部分中的其余部分是 `[list: 3, 4]`，依此类推。得到的结果平均值是：

```py
my-avg([list: 1, 2, 3, 4]) is 10/4
my-avg([list:    2, 3, 4]) is 9/3
my-avg([list:       3, 4]) is 7/2
my-avg([list:          4]) is 4/1
```

问题在于，我们如何从子列表的答案得到整个列表的答案并不清楚。也就是说，给定以下两条信息：

+   列表剩余部分的平均值为 `9/3`，即 `3`。

+   列表中的第一个数字是 `1`。

如何确定整个列表的平均值必须是 `10/4`？如果您不清楚，请不要担心：仅凭这两条信息，这是不可能的！

这里有一个更简单的例子来说明原因。假设列表中的第一个值是 `1`，而列表其余部分的平均值是 `2`。这里有两组非常不同的列表符合这个描述：

```py
[list: 1, 2]    # the rest has one element with sum 2
[list: 1, 4, 0] # the rest has two elements with sum 4
```

整个第一个列表的平均值是 `3/2`，而整个第二个列表的平均值是 `5/3`，这两个值并不相同。

也就是说，为了计算整个列表的平均值，甚至知道列表其余部分的平均值都没有用。相反，我们需要知道列表其余部分的和和长度。有了这两个，我们可以将第一个数加到总和上，并将 `1` 加到长度上，然后计算新的平均值。

在原则上，我们可以尝试创建一个返回所有这些信息的 `average` 函数。相反，将任务分解成两个更小的任务将简单得多。毕竟，我们已经看到如何计算长度和如何计算总和。因此，平均数只需使用这些现有的函数：

```py
fun my-avg(l):
  my-sum(l) / my-len(l)
end
```

> 立刻行动！
> 
> > 空列表的平均值应该是多少？上述代码产生的是您预期的结果吗？

正如我们之前关于最大值 [结构化问题在放宽域上的问题] 所讨论的那样，空列表的平均值不是一个定义良好的概念。因此，发出错误信号是合适的。上述实现就是这样做的，但做得不好：它在除法时报告错误。更好的编程实践是立即捕获这种情况并报告错误，而不是希望其他函数会报告错误。

> 练习
> 
> > 修改 `my-avg` 以在给定空列表时发出错误信号。

因此，我们看到我们使用的流程——从示例中推断代码——并不总是足够，我们需要更复杂的技巧来解决某些问题。然而，请注意，从示例开始可以帮助我们快速识别这种方法何时有效或无效的情况。此外，如果您更仔细地观察，您会注意到上述示例确实暗示了如何解决问题：在我们的第一个示例中，我们写出了像 `10/4`、`9/3` 和 `7/2` 这样的答案，这些答案对应于数字的总和除以长度。因此，以这种形式（例如，与将第二个答案写成 `3` 相比）写出答案已经揭示了解决方案的结构。

##### 5.2.7.1 `my-avg`: 示例 "链接到此处")

现在我们尝试计算一个数字列表的平均值。让我们从一个例子列表`[list: 1, 2, 3, 4]`开始，并从中推导出更多例子。这个列表中数字的平均值显然是`(1 + 2 + 3 + 4)/4`，即`10/4`。

根据列表的结构，我们看到列表的其余部分是`[list: 2, 3, 4]`，然后是`[list: 3, 4]`，依此类推。得到的平均值如下：

```py
my-avg([list: 1, 2, 3, 4]) is 10/4
my-avg([list:    2, 3, 4]) is 9/3
my-avg([list:       3, 4]) is 7/2
my-avg([list:          4]) is 4/1
```

问题在于，我们并不清楚如何从子列表的答案过渡到整个列表的答案。也就是说，给定以下两个信息点：

+   列表剩余部分的平均值是`9/3`，即`3`。

+   列表中的第一个数字是`1`。

我们如何确定整个列表的平均值必须是`10/4`？如果你觉得不清楚，不要担心：只有这两条信息，这是不可能的！

这里有一个更简单的例子来解释这一点。假设列表中的第一个值是`1`，其余列表的平均值是`2`。这里有两组非常不同的列表符合这个描述：

```py
[list: 1, 2]    # the rest has one element with sum 2
[list: 1, 4, 0] # the rest has two elements with sum 4
```

整个第一个列表的平均值是`3/2`，而整个第二个列表的平均值是`5/3`，这两个值并不相同。

也就是说，为了计算整个列表的平均值，甚至没有必要知道其余列表的平均值。相反，我们需要知道其余列表的总和和长度。有了这两个值，我们可以将第一个值加到总和上，并将`1`加到长度上，然后计算新的平均值。

从原则上讲，我们可以尝试编写一个返回所有这些信息的`average`函数。然而，将任务分解成两个更小的任务会简单得多。毕竟，我们已经看到如何计算长度和如何计算总和。因此，平均值可以直接使用这些现有函数：

```py
fun my-avg(l):
  my-sum(l) / my-len(l)
end
```

> 现在就做！
> 
> > 空列表的平均值应该是多少？上面的代码是否产生了你预期的结果？

正如我们之前关于放松域结构问题[结构问题在放松域)]的论证一样，空列表的平均值不是一个定义良好的概念。因此，发出错误信号是合适的。上面的实现就是这样做的，但做得不好：它在除法时报告错误。更好的编程实践是捕获这种情况并立即报告错误，而不是希望其他函数会报告错误。

> 练习
> 
> > 将`my-avg`上面的代码修改为在给定空列表时发出错误信号。

因此，我们看到我们使用的从例子中推断代码的过程——并不总是足够，我们需要更复杂的技巧来解决一些问题。然而，请注意，从例子开始工作有助于我们快速识别这种方法何时有效，何时无效。此外，如果你更仔细地观察，你会发现上面的例子确实暗示了如何解决这个问题：在我们的第一个例子中，我们写出了像`10/4`、`9/3`和`7/2`这样的答案，这些答案对应于数字的总和除以长度。因此，以这种形式（例如，与将第二个答案写成`3`相比）写出答案已经揭示了解决方案的结构。

#### 5.2.8 结构性问题 "链接到这里")

##### 5.2.8.1 `my-running-sum`: 第一次尝试 "链接到这里")

再来一次，我们从例子开始。

> 现在就做！
> 
> > 从列表`[list: 1, 2, 3, 4, 5]`开始计算`my-running-sum`的结果。

这是我们前几个例子看起来像的：

<running-sum-egs-1> ::=

```py
check:
  my-running-sum([list: 1, 2, 3, 4, 5]) is [list: 1, 3, 6, 10, 15]
  my-running-sum([list:    2, 3, 4, 5]) is [list: 2, 5, 9, 14]
  my-running-sum([list:       3, 4, 5]) is [list: 3, 7, 12]
end
```

再次，似乎没有明显的联系，即列表剩余部分的答案与整个列表的答案之间的联系。

（这并不完全正确：我们仍然可以像下面这样排列答案：

```py
my-running-sum([list: 1, 2, 3, 4, 5]) is [list: 1, 3, 6, 10, 15]
my-running-sum([list:    2, 3, 4, 5]) is [list:    2, 5,  9, 14]
my-running-sum([list:       3, 4, 5]) is [list:       3,  7, 12]
```

观察到我们在计算列表剩余部分的答案后，将第一个元素添加到每个答案元素中，并将第一个元素`link`到前面。原则上，我们可以直接计算这个解决方案，但就目前而言，这可能比找到更简单的方法来回答它要复杂得多。）

##### 5.2.8.2 `my-running-sum`: 示例和代码 "链接到这里")

回想一下我们在`my-running-sum`: 第一次尝试中的开始。我们的例子[<running-sum-egs-1>]展示了以下问题。当我们处理列表的其余部分时，我们已经忘记了之前的一切。也就是说，当我们从`2`开始处理列表时，我们忘记了之前已经看到了一个`1`；当我们从`3`开始时，我们忘记了之前已经看到了`1`和`2`；以此类推。换句话说，我们一直在忘记过去。我们需要一种避免这种情况的方法。

我们能做的最简单的事情就是将我们的函数改为携带这种“记忆”，或者我们称之为累加器。也就是说，想象我们正在定义一个新的函数，称为`my-rs`。它将消耗一个数字列表并生成一个数字列表，但除此之外，它还会计算当前列表之前数字的总和。

> 现在就做！
> 
> > 初始总和应该是多少？

初始时没有“先前列表”，因此我们将使用加法恒等式：`0`。`my-rs`的类型是

```py
my-rs :: Number, List<Number> -> List<Number>
```

现在我们将重新处理来自<running-sum-egs-1>的示例，作为`my-rs`的例子。这些示例使用`+`运算符将两个列表合并成一个（第一个列表的元素后面跟着第二个列表的元素）：

```py
my-rs( 0, [list: 1, 2, 3, 4, 5]) is [list:  0 + 1] + my-rs( 0 + 1, [list: 2, 3, 4, 5])
my-rs( 1, [list:    2, 3, 4, 5]) is [list:  1 + 2] + my-rs( 1 + 2, [list:    3, 4, 5])
my-rs( 3, [list:       3, 4, 5]) is [list:  3 + 3] + my-rs( 3 + 3, [list:       4, 5])
my-rs( 6, [list:          4, 5]) is [list:  6 + 4] + my-rs( 6 + 4, [list:          5])
my-rs(10, [list:             5]) is [list: 10 + 5] + my-rs(10 + 5, [list:           ])
my-rs(15, [list:              ]) is empty
```

也就是说，`my-rs` 转换为以下代码：

```py
fun my-rs(acc, l):
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      new-sum = acc + f
      link(new-sum, my-rs(new-sum, r))
  end
end
```

然后剩下的就是从 `my-running-sum` 中调用它：

```py
fun my-running-sum(l):
  my-rs(0, l)
end
```

注意，我们没有改变 `my-running-sum` 本身以接受额外的参数。我们代码的正确性取决于 `acc` 的初始值是 0。如果我们为 `acc` 添加了一个参数，任何调用 `my-running-sum` 的代码都可能提供一个意外的值，这会扭曲结果。此外，由于值是固定的，添加参数相当于将额外的（且不必要的）工作转移到使用我们代码的其他人身上。

##### 5.2.8.3 `my-alternating`: 示例和代码 "链接至此")

回想一下我们在 `my-alternating`: 示例和代码 中的例子。在那里，我们注意到代码基于每隔一个例子构建。我们可能选择了不同的例子，这样从一个例子到下一个例子我们跳过了两个元素而不是一个。在这里，我们将看到另一种思考相同问题的方法。

回到我们已经看到的例子 [<alternating-egs-1>]。我们编写 `my-alternating` 来基本上每次遍历两个元素。另一个选择是每次只遍历一个元素，但跟踪我们是在奇数元素还是偶数元素——即，给我们的程序添加“记忆”。由于我们只需要跟踪那一条信息，我们可以使用一个 `Boolean` 来实现。让我们定义一个新的函数来完成这个目的：

```py
my-alt :: List<Any>, Boolean -> List<Any>
```

额外的参数会累积，无论我们是在一个要保留的元素还是一个要丢弃的元素。

我们可以重用现有的列表函数模板。当我们有一个元素时，我们必须咨询累加器是否要保留它。如果其值为 `true`，我们将其 `link` 到答案；否则我们忽略它。然而，当我们处理列表的其余部分时，我们必须记住更新累加器：如果我们保留了一个我们不希望保留的下一个元素，反之亦然。

```py
fun my-alt(l, keep):
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      if keep:
        link(f, my-alt(r, false))
      else:
        my-alt(r, true)
      end
  end
end
```

最后，我们必须确定累加器的初始值。在这种情况下，因为我们想从第一个元素开始交替保留元素，所以其初始值应该是 `true`：

```py
fun my-alternating(l):
  my-alt(l, true)
end
```

> 练习
> 
> > 使用累加器定义 `my-max`。累加器代表什么？你遇到任何困难吗？

##### 5.2.8.1 `my-running-sum`: 第一次尝试 "链接至此")

再来一次，我们从例子开始。

> 现在就做！
> 
> > 从列表 `[list: 1, 2, 3, 4, 5]` 开始计算 `my-running-sum` 的结果。

这是我们前几个例子看起来像这样：

<running-sum-egs-1> ::=

```py
check:
  my-running-sum([list: 1, 2, 3, 4, 5]) is [list: 1, 3, 6, 10, 15]
  my-running-sum([list:    2, 3, 4, 5]) is [list: 2, 5, 9, 14]
  my-running-sum([list:       3, 4, 5]) is [list: 3, 7, 12]
end
```

再次，似乎结果与整个列表的结果之间没有明显的联系。

（这并不完全正确：我们仍然可以如下排列答案：

```py
my-running-sum([list: 1, 2, 3, 4, 5]) is [list: 1, 3, 6, 10, 15]
my-running-sum([list:    2, 3, 4, 5]) is [list:    2, 5,  9, 14]
my-running-sum([list:       3, 4, 5]) is [list:       3,  7, 12]
```

并观察我们是在计算列表的其余部分的答案，然后将第一个元素添加到答案中的每个元素上，并将第一个元素`link`到前面。原则上，我们可以直接计算这个解决方案，但就目前而言，这可能比找到更简单的答案要复杂。

##### 5.2.8.2 `my-running-sum`: 示例和代码 "链接至此")

回顾我们是如何在`my-running-sum`: 第一次尝试开始的。我们的例子 [<running-sum-egs-1>] 展示了以下问题。当我们处理列表的其余部分时，我们已经忘记了之前的一切。也就是说，当我们从`2`开始处理列表时，我们忘记了之前已经看到过`1`；当我们从`3`开始时，我们忘记了之前已经看到过`1`和`2`；以此类推。换句话说，我们一直在忘记过去。我们需要一种避免这种情况的方法。

我们能做的最简单的事情就是简单地改变我们的函数，让它携带这种“记忆”，或者我们称之为累加器。也就是说，想象我们正在定义一个新的函数，称为`my-rs`。它将消耗一个数字列表并产生一个数字列表，但除此之外，它还会携带当前列表之前的数字总和。

> 现在行动起来！
> 
> > 初始总和应该是多少？

初始时没有“前一个列表”，因此我们将使用加法恒等元：`0`。`my-rs`的类型是

```py
my-rs :: Number, List<Number> -> List<Number>
```

让我们现在重新处理我们的例子 <running-sum-egs-1>，作为`my-rs`的例子。这些例子使用`+`运算符将两个列表连接成一个（第一个列表的元素后面跟着第二个列表的元素）：

```py
my-rs( 0, [list: 1, 2, 3, 4, 5]) is [list:  0 + 1] + my-rs( 0 + 1, [list: 2, 3, 4, 5])
my-rs( 1, [list:    2, 3, 4, 5]) is [list:  1 + 2] + my-rs( 1 + 2, [list:    3, 4, 5])
my-rs( 3, [list:       3, 4, 5]) is [list:  3 + 3] + my-rs( 3 + 3, [list:       4, 5])
my-rs( 6, [list:          4, 5]) is [list:  6 + 4] + my-rs( 6 + 4, [list:          5])
my-rs(10, [list:             5]) is [list: 10 + 5] + my-rs(10 + 5, [list:           ])
my-rs(15, [list:              ]) is empty
```

也就是说，`my-rs`可以转换为以下代码：

```py
fun my-rs(acc, l):
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      new-sum = acc + f
      link(new-sum, my-rs(new-sum, r))
  end
end
```

然后剩下的就是从`my-running-sum`中调用它：

```py
fun my-running-sum(l):
  my-rs(0, l)
end
```

注意到我们并没有改变`my-running-sum`本身来接受额外的参数。我们代码的正确性依赖于`acc`的初始值为 0。如果我们为`acc`添加一个参数，任何调用`my-running-sum`的代码都可能提供一个意外的值，这会扭曲结果。此外，由于值是固定的，添加参数相当于将额外的（且不必要的）工作转嫁给使用我们代码的其他人。

##### 5.2.8.3 `my-alternating`: 示例和代码 "链接至此")

回顾我们之前在`my-alternating`: 示例和代码中的例子。在那里，我们注意到代码是基于每隔一个例子构建的。我们可能选择了不同的例子，使得从一个例子到下一个例子我们跳过了两个元素而不是一个。在这里，我们将看到另一种思考相同问题的方法。

回到我们之前看到的示例 [<alternating-egs-1>]。我们编写了 `my-alternating` 来遍历列表，基本上是每次两个元素。另一个选择是逐个元素遍历它，但保持跟踪我们是否处于奇数或偶数元素——即，给我们的程序添加“记忆”。由于我们只需要跟踪那一条信息，我们可以使用一个 `Boolean` 来实现。让我们定义一个新的函数来完成这个目的：

```py
my-alt :: List<Any>, Boolean -> List<Any>
```

额外的参数累加器记录我们是否处于要保留的元素或要丢弃的元素。

我们可以重用现有的列表函数模板。当我们有一个元素时，我们必须咨询累加器是否保留它。如果其值为 `true`，我们将其 `link` 到答案；否则我们忽略它。然而，当我们处理列表的其余部分时，我们必须记住更新累加器：如果我们保留了一个元素，我们不想保留下一个元素，反之亦然。

```py
fun my-alt(l, keep):
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      if keep:
        link(f, my-alt(r, false))
      else:
        my-alt(r, true)
      end
  end
end
```

最后，我们必须确定累加器的初始值。在这种情况下，由于我们想要从第一个元素开始保留交替元素，其初始值应该是 `true`：

```py
fun my-alternating(l):
  my-alt(l, true)
end
```

> 练习
> 
> > 使用累加器定义 `my-max`。累加器代表什么？你遇到任何困难吗？

#### 5.2.9 处理多个答案 "链接至此")

我们上面的讨论假设对于给定的输入只有一个答案。这通常是正确的，但也取决于问题的措辞以及我们选择生成示例的方式。我们现在将对此进行一些详细的研究。

##### 5.2.9.1 `uniq`: 问题设置 "链接至此")

考虑编写 `uniq` 的任务：`uniq` 是一个具有类似行为的 Unix 工具，因此名称的拼写。给定一个值列表，它产生一个包含相同元素的集合，同时避免任何重复（因此称为 `uniq`，意为“唯一”）。

考虑以下输入：`[list: 1, 2, 1, 3, 1, 2, 4, 1]`。

> 现在就做！
> 
> > 这个输入生成的示例序列是什么？你真的需要停下来并尝试手动完成这个任务。我们将看到有多个解决方案，考虑你生成的结果将是有用的。即使你不能生成一个序列，尝试这样做也会更好地为你阅读下一部分做好准备。

你是如何得到你的示例的？如果你只是“思考了一会儿并写下了一些东西”，你可能得到了一些可以转化为程序的东西，也可能没有。程序只能系统地推进；它们不能“思考”。所以，希望你已经采取了一个明确的路径来计算答案。

##### 5.2.9.2 `uniq`: 示例 "链接至此")

结果有几个可能的答案，因为我们（有意）没有具体说明问题。假设列表中有两个相同值的实例；我们保留哪一个，第一个还是第二个？一方面，由于这两个实例必须等效，所以这并不重要，但在编写具体示例和推导解决方案时，这很重要。

例如，你可能生成了以下序列：

```py
examples:
  uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:    2, 1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:       1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:          3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:             1, 2, 4, 1]) is [list:    2, 4, 1]
  uniq([list:                2, 4, 1]) is [list:    2, 4, 1]
  uniq([list:                   4, 1]) is [list:       4, 1]
  uniq([list:                      1]) is [list:          1]
  uniq([list:                       ]) is [list:           ]
end
```

然而，你也可能生成了以以下序列开始的序列

```py
uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 1, 2, 3, 4]
```

或者

```py
uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 4, 3, 2, 1]
```

等等。让我们处理我们上面已经解决的问题。

##### 5.2.9.3 `uniq`：代码 "链接到此处")

我们如何系统地得到这个答案？当给定一个非空列表时，我们将其分为其第一个元素和列表的其余部分。假设我们已经得到了对列表其余部分应用`uniq`的答案。现在我们可以问：第一个元素在列表的其余部分中吗？如果是，那么我们可以忽略它，因为它肯定在列表的`uniq`中。然而，如果它不在列表的其余部分中，那么将它们`链接`到答案中是至关重要的。

这转化为以下程序。对于空列表，我们返回空列表。如果列表非空，我们检查第一个元素是否在列表的其余部分中。如果不是，我们将其包括在内；否则，我们现在可以忽略它。

这导致以下程序：

```py
fun uniq-rec(l :: List<Any>) -> List<Any>:
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      if r.member(f):
        uniq-rec(r)
      else:
        link(f, uniq-rec(r))
      end
  end
end
```

我们将其称为`uniq-rec`而不是`uniq`，以区分其他版本的`uniq`。

> 练习
> 
> > 注意，我们正在使用`.member`来检查一个元素是否是列表的成员。编写一个`member`函数，它接受一个元素和一个列表，并告诉我们该元素是否是列表的成员。
> > 
> 练习
> 
> > 唯一性检查有许多实际应用。例如，可能有一份注册参加选举的人名的列表。为了保持选举的公平性，每人只能投一票，我们应该从列表中删除重复的名字。
> > 
> > 1.  提出一组示例，用于函数`rem-duplicate-voters`，该函数接受一个选民名字列表，并返回一个删除了重复注册的列表。在开发你的示例时，请考虑在识别重复名字时可能出现的现实世界场景。你能识别出两个名字可能看起来是同一个人，但实际上不是的情况吗？两个名字可能看起来不同，但实际上是指同一个人的情况？
> > 1.  
> > 1.  我们需要对我们当前的`uniq-rec`函数进行哪些更改才能处理像删除重复选民这样的情况？
> > 1.  
> 责任计算：比较值时，上下文很重要
> 
> > 上面的练习中的数据去重上下文提醒我们，不同的上下文可能需要不同的关于两个数据值何时相同的观念。有时，我们希望进行精确匹配以确定两个字符串是否相等。有时，我们需要使用将数据规范化的方法，无论是简单的如大写字母还是更微妙的方法，如基于中间名首字母。有时，我们需要更多信息（如除了名字之外还有街道地址）来确定列表中的两个项目是否应该被视为“相同”。
> > 
> > 容易编写出编码了关于我们数据的假设的程序，这些假设在实际应用中可能并不适用。这种情况可以通过思考代码需要在什么上下文中工作的具体例子来得到帮助。

##### 5.2.9.4 `uniq`：减少计算 "链接到此处")

注意，这个函数有一个重复的表达式。我们不必写两次，只需调用一次并在两个地方使用结果：

```py
fun uniq-rec2(l :: List<Any>) -> List<Any>:
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      ur = uniq-rec2(r)
      if r.member(f):
        ur
      else:
        link(f, ur)
      end
  end
end
```

你可能会认为，因为我们用一次函数调用替换了两次调用，所以减少了程序的计算量。但这并不正确！这两个函数调用都在同一个条件语句的两个分支中；因此，对于任何给定的列表元素，只会发生一次或另一次对`uniq`的调用。实际上，在两种情况下，之前都调用了一次`uniq`，现在也调用了一次。所以我们在源程序中减少了调用次数，但并没有减少程序运行时的调用次数。从这个意义上说，这个章节的名称是有意误导的！

然而，我们可以执行一个有用的减少操作，这是由`uniq-rec2`的结构所启用的。我们目前检查`f`是否是`r`的成员，`r`是所有剩余元素的列表。在我们的例子中，这意味着在第二次迭代时，我们检查`2`是否是列表`[list: 1, 3, 1, 2, 4, 1]`的成员。这是一个包含六个元素的列表，包括三个`1`的副本。我们将`2`与两个`1`进行比较。然而，第二次比较并没有带来任何好处。换句话说，我们可以将`uniq(r)`视为列表其余部分的“摘要”，它在检查成员资格方面与`r`本身一样好，而且可能显著更短。这正是`ur`所代表的。因此，我们可以将这种直觉编码如下：

```py
fun uniq-rec3(l :: List<Any>) -> List<Any>:
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      ur = uniq-rec3(r)
      if ur.member(f):
        ur
      else:
        link(f, ur)
      end
  end
end
```

注意，唯一改变的是我们检查`ur`而不是`r`中的成员资格。

> 练习
> 
> > 在后面的[预测增长]中，我们将研究如何正式研究程序运行所需的时间。根据该节中引入的度量标准，我们刚才所做的更改有什么影响？请注意你的答案：这取决于我们如何计算“长度”。

注意，如果列表一开始就没有包含重复项，那么检查哪个列表中的成员资格就无关紧要——<wbr>但如果我们知道列表没有包含重复项，我们一开始就不会使用`uniq`！我们将在将集合表示为列表中回到列表和重复元素的问题。

##### 5.2.9.5 `uniq`: 示例和代码变化 "链接到此处")

如我们之前提到的，你可能已经写下了其他示例序列。这里有一个非常不同的过程：

+   从整个给定的列表和空答案（到目前为止）开始。

+   对于列表中的每个元素，检查它是否已经在到目前为止的答案中。如果是，忽略它，否则用它扩展答案。

+   当列表中没有更多元素时，到目前为止的答案就是整个列表的答案。

注意，这个解决方案假设我们将在遍历列表时累积答案。因此，我们甚至不能像以前那样用一个参数写例子。我们会争辩说，一个自然的解决方案是询问我们是否可以使用我们已经在定义的计算仅从数据结构中解决问题，就像我们上面做的那样。如果我们不能，那么我们必须求助于累加器。但由于我们可以，累加器在这里是不必要的，并且极大地复杂了甚至写下例子（试试看！）。

##### 5.2.9.6 `uniq`: 为什么生成一个列表? "链接到此处")

如果你回到`uniq`问题的原始陈述[`uniq`: 问题设置)]，你会注意到它没有提到输出应该有什么顺序；事实上，它甚至没有说输出需要是一个列表（因此有顺序）。在这种情况下，我们应该考虑列表对于这个问题是否有意义。事实上，如果我们不关心顺序并且不想有重复（根据`uniq`的定义），那么有一个更简单的解决方案，那就是生成一个集合。Pyret 已经内置了集合，将列表转换为集合会自动处理重复项。当然，从学习如何编写`uniq`的角度来看，这有点作弊，但值得记住的是，有时产生正确数据结构的方法并不一定是我们给出的那个。此外，在将集合表示为列表中，我们将会看到如何自己构建集合（到那时，`uniq`看起来会熟悉，因为它处于集合的核心）。

##### 5.2.9.1 `uniq`: 问题设置 "链接到此处")

考虑编写`uniq`的任务：`uniq`是 Unix 实用工具的一个名称，具有类似的行为；因此，名称的拼写。给定一个值列表，它产生一个包含相同元素的集合，同时避免任何重复（因此称为`uniq`，意为“唯一”）。

考虑以下输入：`[list: 1, 2, 1, 3, 1, 2, 4, 1]`。

> 立即行动！
> 
> > 这个输入生成的示例序列是什么？这非常重要，你需要停下来尝试手动完成。正如我们将看到的，有多个解决方案，考虑你生成的解决方案是有用的。即使你不能生成一个序列，尝试这样做也会更好地为你阅读下一部分做好准备。

你是如何得到你的示例的？如果你只是“思考了一会儿并写下来”，你可能得到了可以转化为程序的东西，也可能没有。程序只能系统地执行；它们不能“思考”。所以，希望你已经采取了一个明确的路径来计算答案。

##### 5.2.9.2 `uniq`：示例 "链接到这里")

结果表明有多个可能的答案，因为我们（故意）没有具体说明问题。假设列表中有两个相同值的实例；我们保留哪一个，第一个还是第二个？一方面，由于这两个实例必须等效，所以这并不重要，但在编写具体示例和推导解决方案时，这很重要。

例如，你可能已经生成了以下序列：

```py
examples:
  uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:    2, 1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:       1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:          3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:             1, 2, 4, 1]) is [list:    2, 4, 1]
  uniq([list:                2, 4, 1]) is [list:    2, 4, 1]
  uniq([list:                   4, 1]) is [list:       4, 1]
  uniq([list:                      1]) is [list:          1]
  uniq([list:                       ]) is [list:           ]
end
```

然而，你也可能生成了以以下内容开始的序列：

```py
uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 1, 2, 3, 4]
```

或者

```py
uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 4, 3, 2, 1]
```

等等。让我们处理我们上面已经解决的问题。

##### 5.2.9.3 `uniq`：代码 "链接到这里")

我们到达这个答案的系统方法是什么？当给定一个非空列表时，我们将其分为其第一个元素和列表的其余部分。假设我们已经对列表的其余部分应用了`uniq`。现在我们可以问：第一个元素是否在列表的其余部分中？如果是，那么我们可以忽略它，因为它肯定会在列表的`uniq`中。如果不是，那么将这个元素`link`到答案中是至关重要的。

这可以转换为以下程序。对于空列表，我们返回空列表。如果列表非空，我们检查第一个元素是否在列表的其余部分中。如果不是，我们将其包括在内；否则，我们现在可以忽略它。

这导致以下程序：

```py
fun uniq-rec(l :: List<Any>) -> List<Any>:
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      if r.member(f):
        uniq-rec(r)
      else:
        link(f, uniq-rec(r))
      end
  end
end
```

我们将其称为`uniq-rec`而不是`uniq`，以区分其他版本的`uniq`。

> 练习
> 
> > 注意，我们正在使用`.member`来检查一个元素是否是列表的成员。编写一个函数`member`，它接受一个元素和一个列表，并告诉我们该元素是否是列表的成员。
> > 
> 练习
> 
> > 唯一性检查有许多实际应用。例如，一个人可能有一份注册参加选举的人名的列表。为了保持选举的公平性，每人只能投一票，我们应该从列表中删除重复的名字。
> > 
> > 1.  提出一组示例，用于一个名为`rem-duplicate-voters`的函数，该函数接受一个投票者名单列表，并返回一个已移除重复注册的名单列表。在开发你的示例时，请考虑在识别重复名称时可能出现的现实世界场景。你能识别出两种名称可能看起来是同一个人，但实际上不是的情况吗？两种名称可能看起来不同，但实际上是指同一个人的情况吗？
> > 1.  
> > 1.  你可能需要对我们当前的`uniq-rec`函数进行哪些修改，以处理像移除重复投票者这样的情况？
> > 1.  
> 负责任计算：比较值时，上下文很重要
> 
> > 在上述练习中的数据去重上下文提醒我们，不同的上下文可能需要不同的关于两个数据值何时相同的观念。有时，我们希望进行精确匹配以确定两个字符串是否相等。有时，我们需要使用方法来规范化数据，无论是简单的方式（如大写字母）还是基于中间名首字母的微妙方式。有时，我们需要更多信息（如除了姓名之外还有街道地址）来确定列表中的两个项目是否应被视为“相同”。
> > 
> > 编写假设我们数据可能不适用于实践的程序的代码很容易。这又是一个可以通过考虑代码在上下文中需要工作的具体示例来帮助的情况。

##### 5.2.9.4 `uniq`：减少计算 "链接到此处")

注意到这个函数有一个重复的表达式。我们不必写两次，只需调用一次，并在两个地方使用结果：

```py
fun uniq-rec2(l :: List<Any>) -> List<Any>:
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      ur = uniq-rec2(r)
      if r.member(f):
        ur
      else:
        link(f, ur)
      end
  end
end
```

你可能会认为，因为我们用一次函数调用替换了两次，所以减少了程序的计算量。但这并不正确！这两个函数调用都在同一个条件语句的两个分支中；因此，对于任何给定的列表元素，只会发生一次或另一次对`uniq`的调用。实际上，在两种情况下，之前都调用了一次`uniq`，现在也是。所以我们在源程序中减少了调用次数，但并没有减少程序运行时的调用次数。从这个意义上说，这个章节的名称故意具有误导性！

然而，有一个有用的简化我们可以执行，这是由`uniq-rec2`的结构所启用的。我们目前检查`f`是否是`r`的成员，`r`是所有剩余元素的列表。在我们的例子中，这意味着在第二次迭代时，我们检查`2`是否是列表`[list: 1, 3, 1, 2, 4, 1]`的成员。这是一个包含三个`1`副本的六个元素的列表。我们将`2`与两个`1`进行比较。然而，第二次比较我们没有得到任何东西。换句话说，我们可以将`uniq(r)`视为列表其余部分的“摘要”，它在检查成员资格方面与`r`本身一样好，而且它可能显著更短。当然，这正是`ur`所代表的。因此，我们可以将这种直觉编码如下：

```py
fun uniq-rec3(l :: List<Any>) -> List<Any>:
  cases (List) l:
    | empty => empty
    | link(f, r) =>
      ur = uniq-rec3(r)
      if ur.member(f):
        ur
      else:
        link(f, ur)
      end
  end
end
```

注意，唯一改变的是我们检查`ur`中的成员资格而不是`r`中的。

> 练习
> 
> > 在后续的[预测增长]中，我们将研究如何正式研究程序运行所需的时间。根据该节中引入的度量标准，我们刚才所做的更改是否有所影响？请注意您的答案：这取决于我们如何计算“长度”。

注意到，如果列表一开始就没有重复项，那么检查哪个列表中的成员资格就无关紧要了——<wbr>但如果我们知道列表中没有重复项，我们一开始就不会使用`uniq`！我们将在表示列表作为集合中返回到列表和重复元素的问题。

##### 5.2.9.5 `uniq`：示例和代码变化 "链接到此处")

如我们之前提到的，你可能已经写下了其他示例序列。这里有一个非常不同的过程：

+   从整个给定的列表和空答案（到目前为止）开始。

+   对于列表中的每个元素，检查它是否已经在目前的答案中。如果是，忽略它，否则用它扩展答案。

+   当列表中没有更多元素时，目前的答案就是整个列表的答案。

注意，这个解决方案假设我们将在遍历列表时累积答案。因此，我们甚至不能像之前那样用一个参数编写示例。我们会争辩说，一个自然的解决方案是询问我们是否可以仅使用我们已经在定义的计算从数据结构中解决问题，就像我们上面做的那样。如果我们不能，那么我们必须求助于累加器。但由于我们可以，累加器在这里是不必要的，并且极大地复杂了示例的编写（试一试！）

##### 5.2.9.6 `uniq`：为什么产生一个列表? "链接到此处")

如果你回到`uniq`问题的原始陈述[`uniq`: 问题设置]，你会注意到它没有提到输出应该有什么顺序；事实上，它甚至没有说输出需要是一个列表（因此有顺序）。在这种情况下，我们应该考虑列表是否适合这个问题。事实上，如果我们不关心顺序并且不想有重复（根据`uniq`的定义），那么有一个更简单的解决方案，那就是生成一个集合。Pyret 已经内置了集合，将列表转换为集合会自动处理重复项。当然，从学习如何编写`uniq`的角度来看，这有点作弊，但值得记住的是，有时产生正确数据结构的方法并不一定是我们给出的那个。此外，在[将集合表示为列表]中，我们将看到如何自己构建集合（到那时，`uniq`将看起来很熟悉，因为它处于集合的核心）。

#### 5.2.10 单态型列表和多态型类型 "链接至此")

之前我们编写了如下合约：

```py
my-len :: List<Any> -> Number
my-max :: List<Any> -> Any
```

这些合约存在几个不令人满意的原因。以`my-max`为例。合约暗示任何类型的元素都可以在输入列表中，但实际上并非如此：输入`[list: 1, "two", 3]`是无效的，因为我们不能比较`1`与`"two"`或`"two"`与`3`。

> 练习
> 
> > 如果我们运行`1 > "two"`或`"two" > 3`会发生什么？

相反，我们的意思是所有元素都是同一类型的列表，技术上讲，这些元素也是可比较的，而合约并没有捕捉到这一点。此外，我们并不是说`my-max`可能会返回任何旧类型：如果我们向它提供一个数字列表，我们不会得到一个字符串作为最大元素！相反，它只会返回列表中存在的元素类型。

简而言之，我们的意思是列表中的所有元素都是同一类型，但可以是任何类型。我们称前者为单态型：“mono”意味着一个，而“morphic”意味着形状，即所有值都只有一个类型。但函数`my-max`本身可以操作许多这类列表，所以我们称它为多态型（“poly”意味着许多）。

因此，我们需要一种更好的方式来编写这些合约。本质上，我们想要表达的是存在一个类型变量（与常规程序变量相对），它代表列表中元素的类型。给定这种类型，`my-max`将返回该类型的元素。我们按照以下语法来编写：

```py
fun my-max<T>(l :: List<T>) -> T: … end
```

符号`<T>`表示`T`是一个类型变量参数，它将在函数的其余部分（包括头和体）中使用。

使用这种符号，我们还可以回顾`my-len`。它的头现在变为：

```py
fun my-len<T>(l :: List<T>) -> Number: … end
```

注意到`my-len`实际上并不“关心”所有值是否为同一类型：它从不查看单个元素，更不用说成对的元素了。然而，按照惯例，我们要求列表始终是单态型的。这很重要，因为它使我们能够统一处理列表的元素：如果我们知道如何处理类型`T`的元素，那么我们就知道如何处理`List<T>`。如果列表元素可以是真正任何旧类型，我们就无法知道如何处理其元素。
