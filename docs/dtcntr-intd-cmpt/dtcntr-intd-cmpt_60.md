# 18.4 散列、集合和键值🔗

> 原文：[`dcic-world.org/2025-08-27/hash-set-kv.html`](https://dcic-world.org/2025-08-27/hash-set-kv.html)

| |    18.4.1 字符串的散列函数 |
| --- | --- |
| |    18.4.2 从散列构建集合 |
| |    18.4.3 数组 |
| |    18.4.4 从散列和数组构建集合 |
| |    18.4.5 冲突 |
| |    18.4.6 解决冲突 |
| |    18.4.7 复杂度 |
| |    18.4.8 布隆过滤器 |
| |    18.4.9 从集合到键值的一般化 |

我们已经看到了几种设置成员关系的解决方案 [几种集合的变体]。特别是，树 [在树上构建集合] 给我们提供了对交和成员关系的对数复杂度。现在我们将看到集合的另一种实现，具有不同的复杂度。为了设置这个，我们假设你熟悉散列的概念 [将值转换为有序值]，我们看到了它对于构建搜索树是有用的。在这里，我们将用它以非常不同的方式构建集合。然后我们将集合推广到另一个重要的数据结构：键值存储。但首先…

#### 18.4.1 字符串的散列函数🔗 "链接到此处")

正如我们在 将值转换为有序值 中所看到的，我们有多种策略将任意值转换为数字，我们将在这里依赖这些策略。因此，我们可以仅围绕数字编写这些材料。为了使示例更有趣，并更好地说明一些现实世界的问题，我们将改用字符串。为了散列它们，我们将使用那里定义的 `hash-of`，它只是将字符串的代码点相加。

我们出于多个原因使用这个函数。首先，它足以说明散列的一些后果。其次，在实践中，当内置散列不足时，我们确实会编写（更复杂的版本）这样的函数。最后，因为所有内容都暴露无遗，所以我们很容易进行实验。

#### 18.4.2 从散列构建集合🔗 "链接到此处")

假设我们有一个字符串集合。我们可以散列该集合的每个元素。现在每个字符串都映射到一个数字。这些数字中的每一个都是集合的成员；其他任何数字都不是这个集合的成员。

因此，一种简单的表示方法就是只存储这个数字列表。例如，我们可以将列表 `[list: "Hello", "World!", "🏴‍☠️"]` 存储为 `[list: 500, 553, 195692]`。

不幸的是，这并没有太大的帮助。插入可以在常数时间内完成，但检查成员资格需要我们遍历整个列表，在最坏的情况下这需要线性时间。或者，也许我们有一些涉及排序列表的巧妙方案。但请注意：

+   插入元素现在可能需要线性时间；或者，

+   我们将元素存储为树而不是列表，但然后

    1.  我们必须确保树是平衡的，所以

    1.  我们将基本上重建了 BBST。

换句话说，我们正在重述将集合表示为列表和在树上增长集合中的讨论。

注意，这里的问题是遍历：如果我们必须访问超过常数数量的元素，我们可能并没有比 BBST 做得更好。所以，给定一个哈希值，我们如何只做常数量的工作？为此，列表和树都不适用：它们都需要至少一些（非常数）遍历来到达任意元素。因此，我们需要一个不同的数据结构…

#### 18.4.3 数组🔗 "链接至此")

数组是另一种线性数据结构，就像列表一样。列表和数组之间有两个关键的区别，反映了各自的优点和缺点。

数组的主要优点是我们可以在常数时间内访问数组中的任何元素。这与列表形成对比，在列表中，为了到达第\(n\)个元素，我们必须首先遍历前面的\(n-1\)个元素（使用连续的`rest`s）。

然而，这种好处是以代价为代价的。数组可以支持常数时间访问的原因是数组的尺寸在创建时是固定的。因此，虽然我们可以通过链接来扩展列表，但我们不能“就地”增长数组的尺寸；相反，我们必须创建一个新的数组，并将整个数组的内容复制到新数组中，这需要线性时间。（我们可以通过使用万圣节分析做得更好，但这并不是真正的免费之旅。）

Pyret 中的数组在此处[文档化](https://www.pyret.org/docs/latest/arrays.html)。虽然在原则上不是必要的，但传统上认为数组是支持变动的数据结构，我们在这里也将这样使用它们。

#### 18.4.4 从哈希表和数组生成的集合🔗 "链接至此")

好吧，现在我们有一个策略。当我们想要将一个字符串插入到集合中时，我们计算其哈希值，转到数组中的相应位置，并记录该字符串的存在。如果我们想要检查成员资格，我们同样计算其哈希值，看看相应的位置是否已被设置。传统上，数组中的每个位置被称为桶，这种数据结构被称为哈希表。

```py
BUCKET-COUNT = 1000

buckets = array-of(false, BUCKET-COUNT)

fun insert(s :: String):
  h = hash-of(s)
  buckets.set-now(h, true)
end

fun is-in(s :: String):
  h = hash-of(s)
  buckets.get-now(h)
end
```

注意，如果这能起作用，我们将有常数时间的插入和成员资格检查。不幸的是，有两件事使得这个计划在一般情况下不可行。

#### 18.4.5 冲突🔗 "链接至此")

首先，我们的哈希函数选择。为了使上述方案生效，两个不同的字符串必须映射到两个不同的位置。

> Do Now!
> 
> > 上述哈希函数可逆吗？

我们只需找到两个具有相同哈希值的字符串。根据`hash-of`的定义，很容易看出任何字母的重新排列都会产生相同的哈希值：

|

&#124;

> ```py
> hash-of("Hello")
> ```

&#124;

|

|

```py
500
```

|

|

&#124;

> ```py
> hash-of("olleH")
> ```

&#124;

|

|

```py
500
```

|

同样，这个测试套件也通过了：

```py
check:
  hash-of("Hello") is hash-of("olleH")
  hash-of("Where") is hash-of("Weird")
  hash-of("Where") is hash-of("Wired")
  hash-of("Where") is hash-of("Whine")
end
```

当多个值哈希到同一位置时，我们称之为哈希冲突。

哈希冲突是有问题的！使用上述哈希函数，我们得到：

```py
check:
  insert("Hello")
  is-in("Hello") is true
  is-in("Where") is false
  is-in("elloH") is true
end
```

其中两个测试是可取的，但第三个则绝对不可取。

注意，冲突几乎是不可避免的。如果我们有均匀分布的数据，那么冲突的出现会比我们预期的要早。这源于所谓的[生日问题](http://en.wikipedia.org/wiki/Birthday_problem)背后的推理，通常以在房间里有多少人之前两人共享生日的可能性超过某个百分比来呈现。为了使可能性超过一半，只需要 23 个人！因此，为冲突的可能性做好准备是明智的。

关键是要了解哈希值的分布情况。例如，如果我们知道我们的哈希值都是 10 的倍数，那么使用大小为 10 的表将是一个糟糕的主意（因为所有元素都会哈希到同一个桶，将我们的哈希表变成一个列表）。在实践中，通常使用不常见的素数作为表的大小，因为随机值不太可能成为它的除数。这并不带来理论上的改进（除非你可以对输入做出某些假设，或者非常仔细地处理数学），但在实践中效果很好。特别是，由于典型的哈希函数使用堆上对象的内存地址，而在大多数系统中这些地址是 4 的倍数，使用 31 这样的素数通常是一个相当好的选择。

虽然冲突是概率性的，并且取决于哈希函数的选择，但我们有一个更基本且不可避免的冲突原因。我们必须存储一个最大可能哈希大小的数组。然而，哈希值可以非常大（尝试运行`insert("🏴‍☠️")`并看看会发生什么），甚至哈希的大小也没有先验的限制。这从根本上与数组相矛盾，数组必须有固定的大小。

为了处理任意大的数值，我们：

+   使用符合我们内存限制的合理大小的数组

+   使用哈希相对于数组大小的余数来找到桶

那就是：

```py
fun insert(s :: String):
  h = hash-of(s)
  buckets.set-now(num-remainder(h, BUCKET-COUNT), true)
end

fun is-in(s :: String):
  h = hash-of(s)
  buckets.get-now(num-remainder(h, BUCKET-COUNT))
end
```

这解决了第二个问题：我们还可以存储海盗旗帜：

```py
check:
  is-in("🏴‍☠️") is false
  insert("🏴‍☠️")
  is-in("🏴‍☠️") is true
end
```

然而，我们只是又创造了一个冲突的来源：余数计算。如果我们有 10 个桶，那么哈希值 5、15、25、35、……都指向同一个桶。因此，有两个冲突来源，我们必须处理它们。

#### 18.4.6 解决冲突🔗 "链接至此")

意外地或令人失望的是，我们对冲突问题有一个非常简单的解决方案。每个桶不是一个单独的布尔值，而是一系列实际值，这些值被哈希到该桶。然后，我们只需检查该列表中的成员资格即可。

首先，我们将对`insert`和`is-in`中找到的桶号进行抽象：

```py
fun index-of(s :: String):
  num-remainder(hash-of(s), BUCKET-COUNT)
end
```

接下来，我们改变每个桶中存储的内容：不再是布尔值，而是一系列实际字符串：

```py
buckets = array-of(empty, BUCKET-COUNT)
```

现在我们可以编写更细致的成员检查器：

```py
fun is-in(s :: String):
  b = index-of(s)
  member(buckets.get-now(b), s)
end
```

类似地，在插入时，我们首先确保元素尚未存在（以避免由重复项引起的复杂性问题），然后才插入它：

```py
fun insert(s :: String):
  b = index-of(s)
  l = buckets.get-now(b)
  when not(member(l, s)):
    buckets.set-now(b, link(s, l))
  end
end
```

现在我们的测试按预期通过：

```py
check:
  insert("Hello")
  is-in("Hello") is true
  is-in("Where") is false
  is-in("elloH") is false
end
```

#### 18.4.7 复杂性🔗 "链接至此")

现在我们又有了一个（一些原语）集合的工作实现。数组的用法据说使我们能够获得常数时间复杂度。然而，我们至少应该感到一些不适。毕竟，当数组只包含布尔值时，应用的是常数时间。然而，该解决方案有两个弱点：它无法通过不可逆的哈希函数处理哈希冲突，并且需要可能巨大的数组。如果我们放宽任何一个假设，实现就简单地错误，因为它很容易被通过哈希或计算余数引起的冲突值欺骗。

我们上面展示的解决方案被称为哈希链表，其中“链”指的是每个桶中存储的列表。哈希链表的优点是插入仍然可以是常数时间：查找桶需要常数时间，插入可以像链接一样便宜。当然，这假设我们不介意重复项；否则，我们将付出我们在将集合表示为列表中看到的相同代价。但是查找的时间与桶的大小成线性关系（考虑到重复项，这可能与不同元素的数量不成比例地任意大）。即使我们检查重复项，我们也存在风险，即大多数甚至所有元素最终可能都落在同一个桶中（例如，假设元素是 `"Where"`，`"Weird"`，`"Wired"`，`"Whine"`）。在这种情况下，我们复杂的实现简化为基于列表的表示及其复杂度！

这里有一个额外的细微之处。当我们检查字符串是否在字符串列表中时，我们必须考虑比较每一对字符串的成本。在最坏的情况下，这与较短字符串的长度成比例。通常这被限制在一个小的常数范围内，但可以想象出一些设置，其中这并不保证总是成立。然而，这种相同的成本必须由所有集合实现承担；这不是在这里引入的新复杂性。

因此，从理论上讲，基于哈希的集合可以在常数时间内支持插入和成员资格，并且（忽略字符串比较的成本）最多线性时间，其中“线性”具有与基于列表表示相同的关于重复项的警告。在许多情况下——<wbr>取决于数据的性质和为数组设置的参数——<wbr>它们可以更接近常数时间。因此，它们在实践中通常非常受欢迎。

#### 18.4.8 布隆过滤器🔗 "链接到此处")

提高空间和时间复杂性的另一种方法是放宽我们对操作期望的性质。目前，集合成员资格给出完美的答案，即当检查的元素之前被插入到集合中时，它正好回答`true`。但假设我们处于可以接受更宽松的正确性概念的环境中，其中成员资格测试可以稍微“说谎”一个方向或另一个方向（但不能两者都这样做，因为这会使表示几乎无用）。具体来说，让我们说“没有就是没有”（即，如果集合表示说元素不存在，那么它确实不存在）但“有时说是就是不是”（即，如果集合表示说元素存在，有时它可能不存在）。简而言之，如果集合表示元素不在其中，这应该是有保证的；但如果集合表示元素存在，它可能不存在。在后一种情况下，我们可能需要一些其他——<wbr>更昂贵——<wbr>的技术来确定真实性，或者我们可能根本不在乎。

这样的数据结构在哪里有用？假设我们正在构建一个使用基于密码的认证的网站。由于许多密码已经在公开的泄露事件中泄露，可以安全地假设黑客拥有它们并会猜测它们。因此，我们希望不允许用户选择这些密码中的任何一个。我们可以使用哈希表来拒绝已知泄露的密码。但为了效率，我们可以使用这个不完美的哈希。如果它说“没有”，那么我们允许用户使用那个密码。但如果它说“是”，那么他们可能正在使用一个已经泄露的密码，或者他们有一个完全不同的密码，纯粹是偶然地具有相同的哈希值，但没关系；我们也可以禁止那个密码。相关用途是用于过滤掉恶意网站。URL 缩短系统 bitly[用于此目的](http://word.bitly.com/post/28558800777/dablooms-an-open-source-scalable-counting-bloom)。它也被广告网络使用；这里有一个[演讲](https://youtu.be/T3Bt9Tn6P5c?si=t8U33orccRCgkSw0&t=1277)（从大约 20 分钟到大约 45 分钟的段落）关于这个话题。但有时，布隆过滤器可能过于冗余，正如这篇 Cloudflare 博客文章[讨论的](https://blog.cloudflare.com/when-bloom-filters-dont-bloom/)……

另一个例子是在更新数据库或内存存储时。假设我们有一个经常更新的记录数据库。维护一个变化日志通常更有效：即，一个按顺序记录所有已发生变化的列表。在某个间隔（比如夜间），日志被“刷新”，这意味着所有这些变化都应用到数据库本身。但这意味着每个读取操作都变得非常低效，因为它必须首先检查整个日志（以查找更新）然后再访问数据库。再次，我们可以使用这个有缺陷的哈希表概念：如果记录定位器的哈希值说“没有”，那么记录肯定没有被修改，我们可以直接访问数据库；如果它说“有”，那么我们必须检查日志。

我们之前已经看到了这个想法的一个简单示例实现，当时我们使用单个数组，通过模运算来表示集合。当一个元素不在数组中时，我们知道它肯定不在。当数组指示一个元素存在时，我们无法确定存在的确实是我们要找的确切值。为了克服这种不确定性，我们使用了链式操作。

然而，我们还可以做其他事情。链式操作既消耗空间（用于存储所有实际值）也消耗时间（用于遍历所有值）。假设，相反，桶只是一个布尔值。这会导致一个稍微有用但可能非常不准确的数据结构；此外，它还表现出与模数相关的故障。

但假设我们不仅有单个数组，而是有多个数组！当元素被添加到集合中时，它会被添加到每个数组中；在检查成员资格时，会咨询每个数组。只有当所有数组都确认时，集合才会肯定地回答成员资格。

自然地，如果所有数组的大小都相同，使用多个数组绝对没有优势：因为插入和查找都是确定性的，所以所有操作都会得出相同的答案。然而，有一种简单的对策：使用不同的数组大小。特别是，通过使用彼此互质的数组大小，我们可以最小化冲突的概率（只有所有数组大小的乘积的哈希值才能欺骗数组）。

这种称为布隆过滤器（Bloom Filter）的数据结构是一个概率数据结构。与我们的早期集合数据结构不同，这个结构并不保证总是给出正确答案；但与☛空间-时间权衡相反，我们通过稍微改变问题以接受错误答案，从而节省了空间和时间。如果我们了解哈希值的分布，并且我们有可接受的错误界限，我们可以设计哈希表的大小，使得布隆过滤器以高概率位于可接受的错误界限内。

#### 18.4.9 从集合到键值对的泛化🔗 "链接至此")

在上面，我们关注的是集合：也就是说，一个字符串实际上映射到一个布尔值，表示它是否存在。然而，在许多设置中，将一个值与另一个值关联是有价值的。例如，给定一个身份号码，我们可能想要检索一个人的记录；给定一个计算机的名称，我们可能想要检索其路由信息；给定一颗星的目录条目，我们可能想要其天文学信息。这种数据结构如此普遍，以至于它有几个名称，其中一些更通用，一些暗示特定的实现：键值存储、关联数组、哈希表、字典等。

通常，“键值”和“字典”这两个名称是有用的，因为它们暗示了一个行为接口。相比之下，“关联数组”暗示了数组的用法，“哈希表”暗示了数组的用法（以及哈希）。实际上，真实系统使用各种实现策略，包括平衡的二叉搜索树。名称“键值”和“字典”避免了对于特定实现的承诺。在这里，“字典”也唤起了对唯一单词映射到描述的常见心理图像。术语“键值”甚至更有技术上的实用性，因为键都意味着是不同的（即，两个不同的键值对不能有相同的键；或者，一个键只能映射到一个值）。这很有意义，因为我们将其视为集合的推广，所以键是集合元素，它们必然没有重复；值取代了布尔值。

为了将我们的集合表示扩展到处理字典或键值存储，我们需要做一些修改。首先，我们引入键值表示：

```py
data KV<T>: kv(key :: String, value :: T) end
```

每个桶仍然是一个空列表，但我们将其理解为键值对的列表。

之前，我们只有`is-in`来检查一个元素是否存在于集合中。现在，这个元素是键，我们可以有一个类似的功能来检查键是否存在。然而，我们很少只想知道这一点；事实上，因为我们已经知道了键，我们通常想要关联的值。

因此，我们只需要这一个功能：我们使用 Pyret 的命名约定`-now`来表示这个结果可能会稍后改变。

```py
getkv-now :: <T> String -> T
```

当然，`getkv-now`可能会失败：键可能不存在。也就是说，它已经成为一个部分函数 [部分域]。因此，我们有所有处理部分函数的常规策略。在这里，为了简单起见，我们选择在键不存在时返回一个错误，但我们讨论的所有其他处理部分性的策略都是有效的（并且在健壮的实现中通常更好）。

同样，我们有：

```py
setkv-now :: <T> String, T -> Nothing
```

这是 `insert` 的一般化。然而，`insert` 没有理由返回错误：插入元素两次是无害的。但是，由于键现在必须与仅一个值相关联，插入必须检查键是否已存在，否则发出错误信号。简而言之，它也是部分的。这不是由于数学原因而部分，而是因为状态：同一个键可能之前已经被插入。

一旦我们同意了这个接口，获取值就是检查成员资格的自然扩展：

```py
fun getkv-now(k):
  b = index-of(k)
  r = find({(kvp): kvp.key == k}, buckets.get-now(b))
  cases (Option) r:
    | none => raise("getkv-now can't find " + k)
    | some(v) => v.value
  end
end
```

找到索引后，我们在桶中查找是否有任何键值对具有所需的键。如果有，则返回相应的值。否则，我们报错。

将键值对插入同样推广到向集合添加元素：

```py
fun setkv-now(k, v):
  b = index-of(k)
  keys = map(_.key, buckets.get-now(b))
  if member(keys, k):
    raise("setkv-now already has a value for key " + k)
  else:
    buckets.set-now(b, link(kv(k, v), buckets.get-now(b)))
  end
end
```

再次检查桶中是否已经存在该键。如果存在，我们选择错误停止。否则，我们创建键值对并将其链接到现有的桶内容，并修改数组以引用新的列表。

> 练习
> 
> > 上面的这对函数是否进行了所有必要的错误检查？
> > 
> 练习
> 
> > 在上面，`setkv-now` 如果一个键已经与一个名称相关联，则会引发错误。一个自然的变体是覆盖关联的值，使得新的值现在与该键相关联。修改实现以执行此操作，并确保您彻底测试它！请注意，您可能还需要修改 `KV` 数据类型。

这再次结束了我们对集合（以及键值存储或字典）的简要游览。我们选择使用数组来实现两者，这要求我们使用哈希。有关字符串字典的更多信息，请参阅 [Pyret 文档](https://www.pyret.org/docs/latest/string-dict.html)。请注意，Pyret 提供两种类型的字典：一种可变（如我们在此处所示）和一种（默认）函数式。

#### 18.4.1 字符串哈希函数🔗 "链接到此处")

正如我们在将值转换为有序值中看到的，我们有多种策略将任意值转换为数字，我们将依赖于此。因此，我们可以仅围绕数字编写这些材料。为了使示例更有趣，并更好地说明一些现实世界的问题，我们将使用字符串。为了对它们进行哈希，我们将使用那里定义的 `hash-of`，它只是将字符串的代码点相加。

我们出于多个原因使用这个函数。首先，它足以说明一些哈希的后果。其次，在实践中，当内置哈希不足时，我们确实编写了（更复杂的版本）这样的函数。最后，因为所有内容都暴露出来，我们很容易进行实验。

#### 18.4.2 从哈希中创建集合🔗 "链接到此处")

假设我们有一个字符串集合。我们可以对集合中的每个元素进行哈希处理。现在每个字符串都映射到一个数字。这些数字中的每一个都是集合的成员；其他任何数字都不是这个集合的成员。

因此，一种简单的表示方法就是只存储这个数字列表。例如，我们可以将列表 `[list: "Hello", "World!", "🏴‍☠️"]` 存储为 `[list: 500, 553, 195692]`。

不幸的是，这并没有太大的帮助。插入可以在常数时间内完成，但检查成员资格需要我们遍历整个列表，在最坏的情况下需要线性时间。或者，也许我们有一些涉及排序列表的巧妙方案。但请注意：

+   插入元素现在可能需要线性时间；或者，

+   我们将元素存储为树而不是列表，但这样

    1.  我们必须确保树是平衡的，所以

    1.  我们实际上已经重建了二叉搜索树（BBST）。

换句话说，我们正在回顾将集合表示为列表和在树上构建集合的讨论。

注意，这里的问题是遍历：如果我们必须访问超过常数个元素，那么我们可能并没有比 BBST 有所改进。所以，给定一个哈希值，我们如何只做常数量的工作？为此，列表和树都不适用：它们都需要至少一些（非常数）遍历来到达任意元素。因此，我们需要一个不同的数据结构…

#### 18.4.3 数组🔗 "链接到此处")

数组是另一种线性数据结构，就像列表一样。列表和数组之间有两个关键的区别，反映了各自的优点和缺点。

数组的主要好处是我们可以在常数时间内访问数组中的任何元素。这与列表形成对比，在列表中，要到达第 \(n\) 个元素，我们必须首先遍历前面的 \(n-1\) 个元素（使用连续的 `rest`）。

然而，这种好处是有代价的。数组能够支持常数时间访问的原因是数组的尺寸在创建时是固定的。因此，虽然我们可以通过链接来扩展列表，但我们不能“就地”增长数组的尺寸；相反，我们必须创建一个新的数组，并将整个数组的内容复制到新数组中，这需要线性时间。（我们可以通过使用万圣节分析做得更好，但这并不是真正的免费之旅。）

Pyret 中的数组在[这里](https://www.pyret.org/docs/latest/arrays.html)有文档说明。虽然在原则上不是必要的，但传统上认为数组是支持变动的数据结构，我们在这里也将这样使用它们。

#### 18.4.4 从哈希和数组构建集合🔗 "链接到此处")

好的，现在我们有一个策略。当我们想要将一个字符串插入到集合中时，我们计算其哈希值，前往数组中的相应位置，并记录该字符串的存在。如果我们想要检查成员资格，我们同样计算其哈希值，看看相应的位置是否已被设置。传统上，数组中的每个位置被称为桶，这种数据结构被称为哈希表。

```py
BUCKET-COUNT = 1000

buckets = array-of(false, BUCKET-COUNT)

fun insert(s :: String):
  h = hash-of(s)
  buckets.set-now(h, true)
end

fun is-in(s :: String):
  h = hash-of(s)
  buckets.get-now(h)
end
```

观察到，如果这能行得通，我们将有恒定时间的插入和成员资格检查。不幸的是，有两件事使得这个计划在一般情况下不可行。

#### 18.4.5 冲突🔗 "链接至此")

首先，我们的哈希函数选择。为了使上述方案生效，两个不同的字符串必须映射到两个不同的位置。

> 现在行动！
> 
> > 上面的哈希函数可逆吗？

我们只需要找到两个具有相同哈希值的字符串。根据`hash-of`的定义，很容易看出任何字母的重新排列都会产生相同的哈希值：

|

&#124;

> ```py
> hash-of("Hello")
> ```

&#124;

|

|

```py
500
```

|

|

&#124;

> ```py
> hash-of("olleH")
> ```

&#124;

|

|

```py
500
```

|

同样，这个测试套件通过：

```py
check:
  hash-of("Hello") is hash-of("olleH")
  hash-of("Where") is hash-of("Weird")
  hash-of("Where") is hash-of("Wired")
  hash-of("Where") is hash-of("Whine")
end
```

当多个值哈希到同一位置时，我们称之为哈希冲突。

哈希冲突是有问题的！使用上述哈希函数，我们得到：

```py
check:
  insert("Hello")
  is-in("Hello") is true
  is-in("Where") is false
  is-in("elloH") is true
end
```

其中两个测试是可取的，但第三个则绝对不可取。

注意，冲突几乎是不可避免的。如果我们有均匀分布的数据，那么冲突的出现会比我们预期的要早。这源于所谓的[生日问题](http://en.wikipedia.org/wiki/Birthday_problem)背后的推理，通常以在房间里有多少人之前，两人共享生日的可能性超过某个百分比的例子来展示。为了使可能性超过一半，只需要 23 个人！因此，为冲突的可能性做好准备是明智的。

关键是要了解哈希值的分布情况。例如，如果我们知道我们的哈希值都是 10 的倍数，那么使用大小为 10 的表将是一个糟糕的主意（因为所有元素都会哈希到同一个桶中，将我们的哈希表变成一个列表）。在实践中，通常使用不常见的质数作为表的大小，因为随机值不太可能成为其除数。这并不带来理论上的改进（除非你可以对输入做出某些假设，或者非常仔细地处理数学问题），但在实践中效果很好。特别是，由于典型的哈希函数使用堆上对象的内存地址，而在大多数系统中这些地址是 4 的倍数，使用 31 这样的质数通常是一个相当好的选择。

虽然冲突是概率性的，并且依赖于哈希函数的选择，但我们还有一个更基本且不可避免的冲突原因。我们必须存储一个可能的最大哈希大小的数组。然而，哈希值可以非常大（尝试运行`insert("🏴‍☠️")`并看看会发生什么），甚至哈希的大小也没有先验的限制。这从根本上与数组相矛盾，因为数组必须有固定的大小。

为了处理任意大的值，我们：

+   使用考虑到我们的内存限制的合理大小的数组

+   使用哈希相对于数组大小的余数来查找桶

那就是：

```py
fun insert(s :: String):
  h = hash-of(s)
  buckets.set-now(num-remainder(h, BUCKET-COUNT), true)
end

fun is-in(s :: String):
  h = hash-of(s)
  buckets.get-now(num-remainder(h, BUCKET-COUNT))
end
```

这解决了第二个问题：我们还可以存储海盗旗帜：

```py
check:
  is-in("🏴‍☠️") is false
  insert("🏴‍☠️")
  is-in("🏴‍☠️") is true
end
```

然而，我们只是又创造了一个冲突的来源：余数计算。如果我们有 10 个桶，那么哈希值 5、15、25、35、……都指向同一个桶。因此，有两个冲突来源，我们必须处理它们两个。

#### 18.4.6 解决冲突🔗 "链接至此")

惊讶或失望的是，我们对冲突问题有一个非常简单的解决方案。每个桶不是一个单独的布尔值，而是一系列实际值，这些值被哈希到该桶。然后，我们只需检查该列表中的成员资格。

首先，我们将抽象地处理在`insert`和`is-in`中查找桶号的问题：

```py
fun index-of(s :: String):
  num-remainder(hash-of(s), BUCKET-COUNT)
end
```

接下来，我们改变每个桶中存储的内容：不是布尔值，而是一系列实际的字符串：

```py
buckets = array-of(empty, BUCKET-COUNT)
```

现在我们可以编写更细致的成员检查器：

```py
fun is-in(s :: String):
  b = index-of(s)
  member(buckets.get-now(b), s)
end
```

类似地，在插入时，我们首先确保元素不在那里（以避免重复引起的复杂性问题），然后才插入：

```py
fun insert(s :: String):
  b = index-of(s)
  l = buckets.get-now(b)
  when not(member(l, s)):
    buckets.set-now(b, link(s, l))
  end
end
```

现在我们的测试按预期通过：

```py
check:
  insert("Hello")
  is-in("Hello") is true
  is-in("Where") is false
  is-in("elloH") is false
end
```

#### 18.4.7 复杂度🔗 "链接至此")

现在，我们又有了一个（某些原始的）集合的工作实现。使用数组据说可以使我们获得常数时间复杂度。然而，我们至少应该感到一些不适。毕竟，当数组只包含布尔值时，应用的是常数时间。然而，那个解决方案有两个弱点：它不能通过不可逆的哈希函数处理哈希冲突，并且需要可能巨大的数组。如果我们放宽任何一个假设，实现就简单地错误了，因为它很容易被通过哈希或计算余数引起的冲突值欺骗。

我们上面展示的解决方案被称为哈希链，其中“链”指的是每个桶中存储的列表。哈希链的好处是插入仍然可以是常数时间：找到桶需要常数时间，插入可以像链接一样便宜。当然，这假设我们不介意重复项；否则，我们将付出我们在将集合表示为列表中看到的相同代价。但是查找的时间与桶的大小成线性关系（考虑到重复项，这可能与不同元素的数量不成比例地大）。即使我们检查重复项，我们也面临大多数甚至所有元素最终都落入同一个桶的风险（例如，假设元素是`"Where"`、`"Weird"`、`"Wired"`、`"Whine"`）。在这种情况下，我们复杂的实现简化为基于列表的表示及其复杂性！

这里还有一个额外的微妙之处。当我们检查字符串在字符串列表中的成员资格时，我们必须考虑比较每一对字符串的成本。在最坏的情况下，这与较短字符串的长度成比例。通常这被限制在一个小的常数内，但可以想象出这种成本不保证总是成立的环境。然而，所有集合实现都必须承担这种相同的成本；这不是这里引入的新复杂性。

因此，从理论上讲，基于哈希的集合可以在常数时间内支持插入和成员资格，并且（忽略字符串比较的成本）最多线性时间，其中“线性”具有与基于列表表示相同的关于重复项的警告。在许多情况下——<wbr>取决于数据的性质和为数组设置的参数——<wbr>它们可以更接近常数时间。因此，它们在实践中通常非常受欢迎。

#### 18.4.8 布隆过滤器🔗 "链接到此处")

提高空间和时间复杂性的另一种方法是放宽我们对操作所期望的性质。目前，集合成员资格给出完美的答案，即当被检查的元素之前已插入集合时，它正好回答`true`。但假设我们处于可以接受更宽松的正确性概念的环境中，其中成员资格测试可以“说谎”稍微偏向一个方向或另一个方向（但不能两者都偏向，因为这会使表示几乎无用）。具体来说，让我们说“没有就是没有”（即，如果集合表示说元素不存在，那么它确实不存在）但“有时说是就是不是”（即，如果集合表示说元素存在，有时它可能不存在）。简而言之，如果集合表示元素不在其中，这应该是有保证的；但如果集合表示元素存在，它可能不存在。在后一种情况下，我们可能需要一些其他——<wbr>更昂贵——<wbr>的技术来确定真实性，或者我们可能根本不在乎。

这样的数据结构在哪里有用呢？假设我们正在构建一个使用基于密码的认证的网站。由于许多密码已经在公开的泄露事件中泄露，我们可以合理地假设黑客拥有它们并会尝试猜测它们。因此，我们希望不允许用户选择这些密码中的任何一个。我们可以使用哈希表来拒绝所有已知的泄露密码。但为了效率，我们可以使用这个不完美的哈希。如果它说“没有”，那么我们允许用户使用那个密码。但如果它说“有”，那么他们要么正在使用一个已经被泄露的密码，要么他们有一个完全不同的密码，纯粹是偶然地具有相同的哈希值；但无论如何；我们也可以拒绝那个密码。相关的用途是用于过滤掉恶意网站。URL 缩短系统 bitly[就用于这个目的](http://word.bitly.com/post/28558800777/dablooms-an-open-source-scalable-counting-bloom)。广告网络也使用它；这里有一个[演讲](https://youtu.be/T3Bt9Tn6P5c?si=t8U33orccRCgkSw0&t=1277)（从大约 20 分钟到大约 45 分钟的段落）关于这个话题。但有时，布隆过滤器过于强大，就像这篇 Cloudflare 博客文章[讨论的](https://blog.cloudflare.com/when-bloom-filters-dont-bloom/)那样……

另一个例子是在更新数据库或内存存储中。假设我们有一个经常更新的记录数据库。通常，维护一个变化日志会更有效率：即，一个按顺序记录所有已发生变化的列表。在某个时间间隔（比如夜间），日志会被“刷新”，这意味着所有这些变化都会应用到数据库本身。但这也意味着每次读取操作都变得非常低效，因为它必须首先检查整个日志（以查找更新）然后再访问数据库。再次，我们可以使用这个有缺陷的哈希表概念：如果记录定位器的哈希值说“没有”，那么记录肯定没有被修改，我们可以直接访问数据库；如果它说“有”，那么我们必须检查日志。

我们之前已经看到了这个想法的一个简单示例实现，当时我们使用一个单一的数组，通过模运算来表示集合。当一个元素不在数组中时，我们知道它肯定不在。当数组指示一个元素存在时，我们无法确定存在的确实是我们要找的确切值。为了克服这种不确定性，我们使用了链式存储。

然而，我们还可以做其他事情。链式存储既消耗空间（用于存储所有实际值）也消耗时间（用于查找所有值）。假设，相反，桶只是一个布尔值。这会导致一个稍微有用但可能非常不准确的数据结构；此外，它还表现出与模数相关的故障。

但假设我们不仅仅有一个数组，而是有多个数组！当一个元素被添加到集合中时，它会被添加到每个数组中；在检查成员资格时，会咨询每个数组。只有当所有数组都确认时，集合才会肯定地回答成员资格。

自然地，如果所有数组的大小都相同，使用多个数组绝对没有优势：因为插入和查找都是确定性的，所以所有操作都会得到相同的答案。然而，有一种简单的对策：使用不同大小的数组。特别是，通过使用彼此互质的数组大小，我们可以最小化冲突的概率（只有所有数组大小的乘积的哈希值才能欺骗数组）。

这种称为布隆过滤器（Bloom Filter）的数据结构是一种概率数据结构。与我们的早期集合数据结构不同，它不能保证总是给出正确答案；但与☛时空权衡相反，我们通过稍微改变问题以接受错误答案，从而节省了空间和时间。如果我们了解哈希值的分布，并且我们有可接受的错误界限，我们可以设计出哈希表的大小，使得布隆过滤器有很高的概率在可接受的错误界限内。

#### 18.4.9 从集合到键值对的推广🔗 "链接至此")

在上面，我们关注了集合：即，一个字符串有效地映射到一个布尔值，表示它是否存在。然而，有许多情况下将一个值与另一个值关联是有价值的。例如，给定一个身份号码，我们可能想要检索一个人的记录；给定一个计算机的名称，我们可能想要检索其路由信息；给定一颗星的目录条目，我们可能想要其天文学信息。这种数据结构如此普遍，以至于它有几个名称，其中一些更通用，一些暗示了特定的实现：键值存储、关联数组、哈希表、字典等。

通常，“键值”和“字典”这两个名称是有用的，因为它们暗示了一个行为接口。相比之下，“关联数组”暗示了使用数组，而“哈希表”暗示了使用数组（以及哈希）。实际上，真实系统使用各种实现策略，包括平衡二叉搜索树。名称“键值”和“字典”避免了对于特定实现的承诺。在这里，“字典”唤起了对唯一单词映射到描述的常见心理图像。术语“键值”在技术上更加有用，因为键意味着它们都是不同的（即，两个不同的键值对不能有相同的键；或者，一个键只能映射到一个值）。这很有意义，因为我们将其视为集合的推广，因此键是集合元素，它们必然没有重复；值取代了布尔值。

为了将我们的集合表示扩展到处理字典或键值存储，我们需要做一些修改。首先，我们引入键值表示：

```py
data KV<T>: kv(key :: String, value :: T) end
```

每个桶仍然是一个空列表，但我们理解它是一个键值对的列表。

以前，我们只有 `is-in` 来检查一个元素是否存在于集合中。现在这个元素是键，我们可以有一个类似的功能来检查键是否存在。然而，我们很少只想知道这一点；事实上，因为我们已经知道了键，我们通常想要关联的值。

因此，我们只需要这一个函数：我们使用 Pyret 的命名约定 `-now` 来表示这个结果可能会稍后改变。

```py
getkv-now :: <T> String -> T
```

当然，`getkv-now` 可能会失败：键可能不存在。也就是说，它已经变成了一个部分函数 [部分域]。因此，我们有了处理部分函数的所有常用策略。在这里，为了简单起见，我们选择在键不存在时返回一个错误，但所有我们讨论的用于处理部分性的其他策略都是有效的（并且在健壮的实现中通常更好）。

类似地，我们有：

```py
setkv-now :: <T> String, T -> Nothing
```

这是 `insert` 的一般化。然而，`insert` 没有理由返回错误：插入元素两次是无害的。但是，因为键现在必须与仅一个值关联，所以插入必须检查键是否已存在，并在不存在时发出错误。简而言之，它也是部分函数。这不是由于数学原因而是由于状态：同一个键可能之前已经被插入过。

一旦我们同意了这个接口，获取值就是检查成员资格的自然扩展：

```py
fun getkv-now(k):
  b = index-of(k)
  r = find({(kvp): kvp.key == k}, buckets.get-now(b))
  cases (Option) r:
    | none => raise("getkv-now can't find " + k)
    | some(v) => v.value
  end
end
```

找到索引后，我们在桶中查找是否有任何键值对具有所需键。如果有，则返回相应的值。否则，我们返回错误。

以类似的方式，插入键值对可以推广到向集合中添加元素：

```py
fun setkv-now(k, v):
  b = index-of(k)
  keys = map(_.key, buckets.get-now(b))
  if member(keys, k):
    raise("setkv-now already has a value for key " + k)
  else:
    buckets.set-now(b, link(kv(k, v), buckets.get-now(b)))
  end
end
```

再次，我们检查桶以确定键是否已经存在。如果存在，我们选择停止并返回一个错误。否则，我们创建键值对并将其链接到现有的桶内容，并修改数组以引用新的列表。

> 练习
> 
> > 上面的这对函数是否进行了所有必要的错误检查？
> > 
> 练习
> 
> > 在上面，`setkv-now` 如果键已经关联了名称，则会引发错误。一个自然的变体是覆盖关联的值，使新值现在与该键关联。修改实现以执行此操作，并确保彻底测试它！请注意，您可能需要修改 `KV` 数据类型。

这再次结束了我们对集合（以及键值存储或字典）的简要游览。我们选择使用数组来实现它们，这要求我们使用哈希。有关字符串字典的更多信息，请参阅[Pyret 文档](https://www.pyret.org/docs/latest/string-dict.html)。请注意，Pyret 提供了两种类型的字典：一种可变（就像我们在这里所展示的）和一种（默认的）函数式。
