# 17.4 最短（或最轻）路径

> 原文：[`dcic-world.org/2025-08-27/lightest-paths.html`](https://dcic-world.org/2025-08-27/lightest-paths.html)

| |
| --- |

想象规划一次旅行：你自然希望以最短的时间、最少的金钱或其他涉及最小化边权重总和的标准到达目的地。这被称为计算最短路径。

我们应该立即澄清一个不幸的术语混淆。我们真正想要计算的是最短路径——即权重最小的路径。不幸的是，计算机科学术语已经固定了我们在这里使用的术语；只需确保不要字面理解即可。

> 练习
> 
> > 构建一个图，并选择图中的两个节点，使得从一个节点到另一个节点的最短路径不是最轻的，反之亦然。

我们已经看到 [深度优先搜索和广度优先搜索]，广度优先搜索在无权图中构建最短路径。当没有权重（或等价地，所有权重都是相同且正的）时，这些对应于最轻路径。现在我们必须将这一点推广到边有权重的情况。

我们将采用归纳法，逐步定义一个看似这种类型的函数

```py
w :: Key -> Number
```

这反映了从源节点到该节点的最短路径的权重。但让我们考虑这个注释：由于我们是逐个节点构建的，最初大多数节点没有要报告的权重；甚至在最后，一个无法从源节点到达的节点将没有最短（或实际上任何）路径的权重。而不是编造一个数字来假装反映这种情况，我们将使用一个选项类型：

```py
w :: Key -> Option<Number>
```

当存在某个值时，它将是权重；否则，权重将是“无”。

现在让我们归纳地思考一下。我们最初知道什么？好吧，当然，源节点到自身的距离是零（这必须是最短路径，因为我们无法更轻）。这给我们一个（平凡的）节点集合，对于这些节点我们已经知道最短权重。我们的目标是扩展这个节点集合——在每次迭代中适度地增加一个节点——直到我们找到目的地，或者我们没有更多的节点可以添加（在这种情况下，我们的目的地无法从源节点到达）。

归纳地，在每一步中，我们都有所有已知最短路径的节点集合（最初这仅仅是源节点，但这确实意味着这个集合永远不会为空，这在接下来的讨论中会很重要）。现在考虑所有与这个节点集合相邻的边，这些边通向那些我们尚未知道最短路径的节点。选择一个节点，记为 \(q\)，使得到达该节点的路径总权重最小。我们断言这实际上将是到达该节点的最短路径。

如果这个说法是正确的，那么我们就完成了。这是因为我们现在会将 \(q\) 添加到已知最小权重的节点集合中，并从那里重复寻找最轻出边的过程。这个过程因此增加了一个节点。在某个时刻，我们会发现没有边能从已知集合中引出，这时我们可以终止。

有理由相信在这个点上终止是安全的：它对应于已经计算了可达集合。唯一剩下的事情是要证明这个贪心算法为每个节点提供了最短路径。

我们将通过反证法来证明这一点。假设我们有一个从源点 \(s\) 到节点 \(d\) 的路径 \(s \rightarrow d\)，这是通过上述算法找到的，但假设我们还有一个实际上更轻的路径。在每一步，当我们沿着 \(s \rightarrow d\) 路径添加一个节点时，如果存在更轻的路径，算法会添加一个更轻的路径。它没有这样做的事实否定了存在更轻路径的断言（可能存在一个相同权重的不同路径；这会被算法允许，但这也不与我们的断言相矛盾）。因此，算法确实找到了最短路径。

剩下的工作是要确定一种数据结构，使得这个算法能够实现。在每一个节点，我们希望知道从那些我们知道最小权重的节点集合中，到它们所有邻居的最小权重。我们可以通过排序来实现这一点，但这过于复杂了：我们实际上并不需要对所有这些权重进行完全排序，只需要知道最轻的那个。一个堆（见维基百科[Heap (data structure)](https://en.wikipedia.org/wiki/Heap_(data_structure)))可以给我们提供这个。

> 练习
> 
> > 如果我们允许权重为零的边呢？上述算法会有什么变化？
> > 
> 练习
> 
> > 如果我们允许负权重的边呢？上述算法会有什么变化？在思考了一段时间后，请查看[这篇文章](https://www.quantamagazine.org/finally-a-fast-algorithm-for-shortest-paths-on-negative-graphs-20230118/)。

供您参考，这个算法被称为迪杰斯特拉算法（Dijkstra’s Algorithm）。
