# 5.1 从表格到列表

> 原文：[`dcic-world.org/2025-08-27/tables-to-lists.html`](https://dcic-world.org/2025-08-27/tables-to-lists.html)

|   5.1.1 基本统计问题 |
| --- |
|   5.1.2 从表格中提取列 |
|   5.1.3 理解列表 |
|   5.1.3.1 列作为匿名数据 |
|   5.1.3.2 创建文本列表 |
|   5.1.4 操作列表 |
|   5.1.4.1 数字列表的内置操作 |
|   5.1.4.2 列表的一般内置操作 |
|   5.1.4.3 关于命名约定的说明 |
|   5.1.4.4 通过位置获取元素 |
|   5.1.4.5 列表的转换 |
|   5.1.4.6 回顾：列表操作摘要 |
|   5.1.5 Lambda：匿名函数 |
|   5.1.6 结合列表和表格 |

在之前 [表格数据简介] 我们开始以表格形式处理集体数据。虽然我们看到了几个强大的操作，让我们能够快速轻松地提出关于数据的高级问题，但它们有两个共同点。首先，所有操作都是按行进行的。没有操作一次询问整个列的问题。其次，所有操作不仅消耗了数据，还产生了表格。然而，我们已知 [入门] 还有许多其他类型的数据，有时我们可能想要计算其中之一。现在我们将看到如何实现这两件事，在这个过程中引入一个重要的新数据类型。

#### 5.1.1 基本统计问题 "链接到此处")

我们可能还想对事件数据提出更多问题。例如：

+   最常使用的折扣代码。

+   每个订单的平均票数。

+   最大的票订单。

+   订单中最常见的票数。

+   已使用的独特折扣代码集合（可能有很多）。

+   与订单相关联的独立电子邮件地址集合，因此我们可以联系客户（一些客户可能已下过多个订单）。

+   哪所学校导致了具有 `"STUDENT"` 折扣的最大订单数量。

注意我们正在讨论的操作类型：计算最大值、最小值、平均值、中位数和其他基本统计数据。Pyret 在 [math](http://www.pyret.org/docs/latest/math.html) 和 [statistics](http://www.pyret.org/docs/latest/statistics.html) 包中提供了几个内置的统计函数。

> 现在行动！
> 
> > 思考一下你是否以及如何使用你已经看到的操作来表达这些问题。

在这些情况中，我们需要对数据的一个单独列进行计算（甚至在关于 `"STUDENT"` 折扣的最后一个问题中，我们会过滤表格到那些行，然后对 `email` 列进行计算）。为了在代码中捕捉这些，我们需要从表格中提取一个列。

在本章的剩余部分，我们将使用上一章的 `event-data` 的清理副本进行工作。经过上一章末尾转换的清理数据位于同一 Google 表格的另一个标签页中，与其他版本的事件数据不同。

```py
include gdrive-sheets
include data-source

ssid = "1Ks4ll5_8wyYK1zyXMm_21KORhagSMZ59dcr7i3qY6T4"
cleaned-data =
  load-table: name, email, tickcount, discount, delivery, zip
    source: load-spreadsheet(ssid).sheet-by-name("Cleaned", true)
    sanitize name using string-sanitizer
    sanitize email using string-sanitizer
    sanitize tickcount using num-sanitizer
    sanitize discount using string-sanitizer
    sanitize delivery using string-sanitizer
    sanitize zip using string-sanitizer
  end
```

#### 5.1.2 从表格中提取列 "链接到此处")

我们的表格函数集合中包括一个我们尚未使用的函数，称为 `select-columns`。正如其名称所暗示的，这个函数会生成一个新的表格，其中只包含现有表格中的某些列。让我们提取 `tickcount` 列，以便我们可以对其计算一些统计数据。我们使用以下表达式：

```py
select-columns(cleaned-data, [list: "tickcount"])
```

![](img/218dbd3d076ef24041ce988f1e4f6c1d.png)

这将我们的注意力集中在数字门票销售上，但我们仍然被困在表格中的列，而且其他表格函数都不允许我们对这些数字进行我们可能想要的计算。理想情况下，我们希望这些数字独立存在，而不是被包裹在额外的表格单元格层中。

在原则上，我们可以在单个列上执行一系列操作。在一些只关注表格的语言中，例如 [SQL](https://en.wikipedia.org/wiki/SQL)，你将找到这样的操作。然而，在 Pyret 中，我们拥有的数据类型远不止列（正如我们很快将在 [结构化数据简介] 中看到的那样，我们甚至可以创建自己的数据类型！），因此，迟早离开表格的温柔茧房是有意义的。提取出的列是一种更基本的数据类型，称为列表，它可以用来表示表格之外的数据序列。

正如我们使用 `.row-n` 符号从表格中提取单行一样，我们使用类似的基于点的概念来提取单列。以下是如何提取 `tickcount` 列的示例：

```py
cleaned-data.get-column("tickcount")
```

作为回应，Pyret 产生了以下值：

```py
[list: 2, 1, 5, 0, 3, 10, 3]
```

现在，我们似乎只有列中单元格中的值，没有包含的表格。然而，这些数字仍然捆绑在一起，这次是在 `[list: ...]` 符号中。那是什么？

#### 5.1.3 理解列表 "链接到此处")

列表与单列表格有很多共同之处：

+   元素是有顺序的，因此谈论列表的“第一个”、“第二个”、“最后一个”——以及等等——元素是有意义的。

+   列表的所有元素都应具有相同的类型。

关键的区别是列表没有“列名”；它是匿名的。也就是说，列表本身不描述它所代表的内容；这种解释是由我们的程序完成的。

##### 5.1.3.1 列表作为匿名数据 "链接至此")

这可能听起来相当抽象——<wbr>确实如此——但这并不是我们编程经验中的新想法。考虑一个像`3`或`-1`这样的值：它是什么？它属于同一类东西：一个匿名值，不描述它所代表的内容；解释是由我们的程序完成的。在一个设置中`3`可能代表年龄，在另一个中可能代表播放次数；在一个设置中`-1`可能代表温度，在另一个中可能是几个温度的平均值。同样，对于字符串也是如此：`"project"`是一个名词（一个人或多人执行的活动）还是一个动词（当我们显示某物在屏幕上时）？同样，对于图像等等。事实上，到目前为止，表格是例外，因为描述是内置于数据中而不是由程序提供的！

这种通用性既是优点也是问题。因为，像其他匿名数据一样，列表不提供对其使用的任何解释，如果我们不小心，可能会意外地误解值。另一方面，这意味着我们可以在几个不同的上下文中使用相同的数据，一个操作可以在许多设置中使用。

事实上，如果我们看看我们之前提出的问题列表，我们会看到有几个常见的操作——<wbr>最大值、最小值、平均值等等——可以在不考虑列表代表什么（身高、年龄、播放次数）的情况下对值列表进行提问。事实上，有些是针对数字的（如平均值），而有些（如最大值）可以针对我们可以执行比较的任何类型（如字符串）进行提问。

##### 5.1.3.2 创建字面量列表 "链接至此")

我们已经看到如何使用`get-column`从表格中创建列表。然而，正如你所预期的，我们也可以直接创建列表：

```py
[list: 1, 2, 3]
[list: -1, 5, 2.3, 10]
[list: "a", "b", "c"]
[list: "This", "is", "a", "list", "of", "words"]
```

当然，列表是值，因此我们可以使用变量来命名它们——<wbr>

```py
shopping-list = [list: "muesli", "fiddleheads"]
```

——<wbr>将它们传递给函数（正如我们很快就会看到的），等等。

> 现在就做！
> 
> > 基于这些示例，你能找出如何创建一个空列表吗？

正如你可能已经猜到的，它是`[list: ]`（空格不是必需的，但它是一个有用的视觉提醒，表示空值）。

#### 5.1.4 在列表上操作 "链接至此")

##### 5.1.4.1 列表数字的内置操作 "链接至此")

Pyret 为我们提供了一套方便的操作，我们可以对列表执行这些操作。[列表文档](https://www.pyret.org/docs/latest/lists.html)描述了这些操作。正如你可能已经猜到的，我们已经在章节开头计算了大多数我们要求的问题。首先，我们需要包含一些包含有用函数的库：

```py
import math as M
import statistics as S
```

然后，我们可以访问几个有用的函数：

```py
tickcounts = cleaned-data.get-column("tickcount")

M.max(tickcounts)     # largest number in a list
M.sum(tickcounts)     # sum of numbers in a list
S.mean(tickcounts)    # mean (average) of numbers in a list
S.median(tickcounts)  # median of numbers in a list
```

`M.`表示“库`M`中的函数”。上述代码中的`import`语句将`math`库命名为`M`。

##### 5.1.4.2 列表的一般内置操作 "链接到此处")

我们在章节开头列表中的某些有用计算涉及到`discount`列，该列包含字符串而不是数字。具体来说，让我们考虑以下问题：

+   计算使用过的唯一折扣代码集合（可能有多个可用）。

没有表格函数可以处理这样的问题。然而，关于值集合的问题（你的播放列表中有多少独特的艺术家？有多少独特的教师在授课？）是常见的。因此，Pyret（以及大多数语言）提供了一种识别列表中唯一元素的方法。以下是获取我们表格中所有使用过的折扣代码列表的方法：

```py
import lists as L
codes = cleaned-data.get-column("discount")
L.distinct(codes)
```

`distinct`函数从输入列表中生成一个唯一值的列表：输入列表中的每个值在输出列表中只出现一次。对于上述代码，Pyret 生成：

```py
[list: "BIRTHDAY", "STUDENT", "none"]
```

如果我们想要从列表中排除`"none"`呢？毕竟，`"none"`不是一个实际的折扣代码，而是一个我们在清理表格时引入的代码。有没有一种简单的方法可以从列表中删除`"none"`？

我们有两种方法可以做到这一点。在 Pyret 列表文档中，我们找到一个名为`remove`的函数，该函数可以从列表中删除一个特定的元素：





> ```py
> L.remove(L.distinct(codes), "none")
> ```







```py
[list: "BIRTHDAY", "STUDENT"]
```



但这个操作也应该听起来很熟悉：在使用表格时，我们使用了`filter-with`来保留满足特定标准的元素。过滤思想如此常见，以至于 Pyret（以及大多数其他语言）在列表上提供了类似的操作。在折扣代码的情况下，我们也可以这样写：

```py
fun real-code(c :: String) -> Boolean:
  not(c == "none")
end
L.filter(real-code, L.distinct(codes))
```

这两种方法之间的区别在于`filter`更加灵活：我们可以使用`filter`检查列表元素的任何特征，但`remove`只检查整个元素是否等于我们提供的值。如果我们不是要删除特定的字符串`"none"`，而是要删除所有全小写的字符串，我们就需要使用`filter`。

> 练习
> 
> > 编写一个函数，该函数接受一个单词列表，并删除所有字母都为小写的单词。（提示：结合`string-to-lower`和`==`）。

##### 5.1.4.3 关于命名约定的补充 "链接到此处")

我们在名为 `discount`（单数）的列的值列表中使用复数 `codes` 是故意的。列表包含多个值，所以复数是合适的。相比之下，在表格中，我们认为列标题命名的是在特定行中出现的单个值。我们经常说在特定行和列中查找值：列的单数名称支持在单个行中进行查找的想法。

##### 5.1.4.4 通过位置获取元素 "链接至此")

让我们看看一个新的分析问题：事件公司最近在 `web.com` 上进行了一次广告活动，他们想知道这是否有效。为了做到这一点，他们需要确定有多少销售是针对具有 `web.com` 电子邮件地址的人。

> 现在行动！
> 
> > 提出一个任务计划 (任务计划) 用于此计算。

这里有一个提出的计划，并附注了如何实现每个部分的说明：

1.  获取电子邮件地址列表（使用 `get-column`）

1.  提取来自 `web.com` 的那些（使用 `L.filter`）

1.  计算剩余的电子邮件地址数量（使用 `L.length`，我们尚未讨论，但在文档中有所说明）

（作为提醒，除非你立即看到解决问题的方法，否则写出任务计划并标注你知道如何做的部分。这有助于将编程问题分解成更易于管理的部分。）

让我们讨论第二个任务：识别来自 `web.com` 的消息。我们知道电子邮件地址是字符串，所以如果我们能确定电子邮件字符串是否以 `@web.com` 结尾，我们就成功了。你可以考虑通过查看电子邮件字符串的最后 7 个字符来做这件事。另一个选择是使用我们尚未看到的字符串操作 `string-split-all`，它将字符串分割成以给定字符为分隔的子字符串列表。例如：





> ```py
> string-split-all("this-has-hyphens", "-")
> ```







```py
[list: "this", "has", "hyphens"]
```







> ```py
> string-split("bonnie@pyret.org", "@")
> ```







```py
[list: "bonnie", "pyret.org"]
```



这看起来非常有用。如果我们围绕 `@` 符号分割每个电子邮件字符串，那么我们可以检查列表中的第二个字符串是否为 `web.com`（因为电子邮件地址应该只有一个 `@` 符号）。但是，我们如何从 `string-split-all` 生成的列表中获取第二个元素呢？在这里，我们深入列表，就像我们提取表格中的行一样，这次使用 `get` 操作。





> ```py
> string-split("bonnie@pyret.org", "@").get(1)
> ```







```py
"pyret.org"
```



> 现在行动！
> 
> > 如果我们想要列表中的第二个项目，为什么将 `1` 作为 `get` 的输入？

这里是完成此检查的完整程序：

```py
fun web-com-address(email :: String) -> Boolean:
  doc: "determine whether email is from web.com"
  string-split(email, "@").get(1) == "web.com"
where:
  web-com-address("bonnie@pyret.org") is false
  web-com-address("parrot@web.com") is true
end

emails = cleaned-data.get-column("email")
L.length(L.filter(web-com-address, emails))
```

> 练习
> 
> > 如果有一个格式不正确的电子邮件地址字符串不包含 `@` 字符串会发生什么？会发生什么？你能对此做些什么？

##### 5.1.4.5 转换列表 "链接至此")

假设我们现在有一个电子邮件地址列表，但我们只想有一个用户名列表。这在我们的事件数据中可能没有意义，但在其他上下文中（例如将消息连接到按学生用户名组织的文件夹）是有意义的。

具体来说，我们想要从一个地址列表开始，例如：

```py
[list: "parrot@web.com", "bonnie@pyret.org"]
```

并将其转换为

```py
[list: "parrot", "bonnie"]
```

> 现在行动起来！
> 
> > 考虑我们迄今为止看到的列表函数（`distinct`、`filter`、`length`）——它们中的任何一个对这个任务有用吗？你能阐述为什么吗？

一种明确回答这个问题的方法是从现有函数的输入和输出角度思考。`filter` 和 `distinct` 都返回输入列表的元素列表，而不是转换后的元素。`length` 返回一个数字，而不是一个列表。因此，这些都不合适。

这种变换元素的想法与我们之前在表格中看到的 `transform-column` 操作类似。列表上的相应操作称为 `map`。以下是一个示例：

```py
fun extract-username(email :: String) -> String:
  doc: "extract the portion of an email address before the @ sign"
  string-split(email, "@").get(0)
where:
  extract-username("bonnie@pyret.org") is "bonnie"
  extract-username("parrot@web.com") is "parrot"
end

L.map(extract-username,
  [list: "parrot@web.com", "bonnie@pyret.org"])
```

##### 5.1.4.6 回顾：列表操作总结 "链接至此")

到目前为止，我们已经看到了几个用于处理列表的有用内置函数：

+   `filter :: (A -> Boolean), List<A> -> List<A>`，它生成一个列表，其中包含在输入列表中对给定函数返回 `true` 的元素。

+   `map :: (A -> B), List<A> -> List<B>`，它生成一个列表，该列表包含对输入列表中每个元素调用给定函数的结果。

+   `distinct :: List<A> -> List<A>`，它生成一个列表，其中包含在输入列表中出现的唯一元素。

+   `length :: List<A> -> Number`，它生成输入列表中的元素数量。

这里，类型 `List<A>` 表示我们有一个元素类型为某种（未指定的）类型的列表，我们将称之为 `A`。这种类型变量在函数合同中显示两个类型之间的关系时很有用。在这里，类型变量 `A` 捕获了元素类型在 `filter` 的输入和输出中是相同的。然而，在 `map` 中，输出列表中的元素类型可能与输入列表中的不同。

在实践中非常有用的一个额外内置函数是：

+   `member :: List<A>, Any -> Boolean`，它确定给定元素是否在列表中。当提供给函数的值的类型没有约束时，我们使用类型 `Any`。

通过组合这些操作，可以执行许多有用的计算。

> 练习
> 
> > 假设你使用字符串列表来表示食谱中的成分。以下有三个示例：
> > 
> > ```py
> > stir-fry =
> >   [list: "peppers", "pork", "onions", "rice"]
> > dosa = [list: "rice", "lentils", "potato"]
> > misir-wot =
> >   [list: "lentils", "berbere", "tomato"]
> > ```
> > 
> > 在成分列表上编写以下函数：
> > 
> > +   `recipes-uses`，它接受一个成分列表和一个成分，并确定该食谱是否使用该成分。
> > +   
> > +   `make-vegetarian`，它接受一个成分列表并将所有肉类成分替换为 `"tofu"`。肉类成分是 `"pork"`、`"chicken"` 和 `"beef"`。
> > +   
> > +   `protein-veg-count`，它接受一个成分列表并确定列表中有多少成分不是 `"rice"` 或 `"noodles"`。
> > +   
> 练习
> 
> > 更具挑战性：编写一个函数，它接受一个成分和成分列表的列表，并生成包含给定成分的所有列表。
> > 
> > 提示：首先编写示例，以便在需要时理解问题。
> > 
> 练习
> 
> > 更具挑战性：尝试编写一个函数，该函数接受两个成分列表，并返回两个列表中共同的所有成分。你遇到了哪些问题或限制？
> > 
> > 在完成下一节之后，再回到这个问题。

#### 5.1.5 Lambda: 匿名函数 "链接到这里")

注意：如果你已经在 Lambda: 匿名函数 中看到了 `lam`，那么你可以自由地跳过这一节，或者只需做结尾的练习。在这里，我们使用列表和 `filter` 来展示 `lam`，而不是使用表格和 `filter-with`。

让我们回顾一下本章前面编写的程序，用于查找在事件表中使用的所有折扣代码：

```py
fun real-code(c :: String) -> Boolean:
  not(c == "none")
end
L.filter(real-code, codes)
```

这个程序可能感觉有点冗长：我们真的需要写一个辅助函数来执行像 `filter` 这样简单的事情吗？直接写点像这样东西不是更容易吗？

```py
L.filter(not(c == "none"), codes)
```

> 现在行动起来！
> 
> > 如果你运行这个表达式，Pyret 会产生什么结果？

Pyret 会在该表达式中 `c` 的使用处产生一个 `未绑定标识符` 错误。`c` 是什么？我们希望 `c` 依次是 `codes` 中的元素。从概念上讲，这就是 `filter` 所做的，但我们没有正确地处理机制。当我们调用函数时，我们在函数体之前评估参数。因此，关于 `c` 未绑定的错误。`real-code` 辅助函数的全部目的就是使 `c` 成为函数的参数，该函数的主体只有在 `c` 有可用值时才会被评估。

为了使记号更加紧凑，就像一行 `filter` 表达式那样，因此，我们需要找到一种方法告诉 Pyret 创建一个临时函数，该函数将在 `filter` 运行时获取其输入。以下记号实现了这一点：

```py
L.filter(lam(c): not(c == "none") end, codes)
```

我们在想要在 `filter` 中使用的表达式周围添加了 `lam(c)` 和 `end`。`lam(c)` 表示“创建一个以 `c` 作为输入的临时函数”。`end` 用于结束函数定义，就像我们使用 `fun` 一样。`lam` 是 `lambda` 的简称，它是一种存在于许多语言中（尽管不是所有语言）的函数定义形式。

我们原始表达式（使用 `real-code` 辅助函数）和这个新表达式（使用 `lam`）之间的主要区别可以通过程序目录来看到。为了解释这一点，我们需要了解一下 `filter` 在底层是如何定义的。部分地，它看起来像：

```py
fun filter(keep :: (A -> Boolean), lst :: List<A>) -> List<A>:
  if keep(<elt-from-list>):
    ...
  else:
    ...
  end
end
```

无论我们传递 `real-code` 还是 `lam` 版本给 `filter`，`keep` 参数最终都会指向一个具有相同参数和主体的函数。由于函数实际上是通过 `keep` 名称调用的，因此，在最初定义时，是否与它关联一个名称并不重要。

实际上，当我们需要将简单的（单行）函数传递给`filter`（或`map`）等操作时，我们会使用`lam`。我们同样可以在处理表格时使用它们（例如`build-column`、`filter-with`等）。当然，如果您觉得这样更合理，您也可以继续为辅助函数编写名称，就像我们在`real-code`中做的那样。

> 练习
> 
> > 编写程序以使用`lam`而不是命名辅助函数从电子邮件地址列表中提取用户名列表。
> > 
> 练习
> 
> > 再次尝试从上一节末尾处理这个问题：编写一个函数，该函数接受两个成分列表并返回两个列表中共同的所有成分。

#### 5.1.6 合并列表和表格 "链接至此")

我们之前研究的表格函数主要用于处理行。我们在这章中学到的列表函数主要用于处理列（但接下来的章节中还有更多用途）。如果一个分析只涉及处理一些行和一些列，我们将在程序中使用表格和列表函数的组合。

> 练习
> 
> > 根据事件表，生成所有将取票的人的姓名列表。
> > 
> 练习
> 
> > 根据事件表，生成以`".org"`结尾的电子邮件地址的人订购的票数的平均值。

有时，执行计算可能会有多种方式：

> 现在就做！
> 
> > 考虑一个问题，比如“有多少人使用`".org"`电子邮件地址购买了超过 8 张票”。提出多个任务计划来解决此问题，包括哪些表格和列表函数可以完成每个任务。

这里有几个选项：

1.  使用`filter-with`获取不超过 8 张票的`event-data`行，获取具有`".org"`地址的行（另一个`filter-with`），然后询问表格中有多少行（使用`<table>.length()`）。

1.  使用`filter-with`获取不超过 8 张票和`".org"`地址的`event-data`行（使用同时检查两个条件的函数），然后询问表格中有多少行（使用`<table>.length()`）。

1.  使用`filter-with`获取不超过 8 张票的`event-data`行，提取电子邮件地址（使用`get-column`），限制为`".org"`（使用`L.filter`），然后获取结果的长度（使用`L.length`）。

还有其他的，但你应该明白了。

> 现在就做！
> 
> > 你最喜欢哪种方法？为什么？

虽然没有唯一的正确答案，但有一些考虑因素：

+   任何中间结果对其他计算有用吗？虽然第二个选项看起来最好，因为它只过滤一次表格而不是两次，但也许事件公司需要对大量订单执行许多计算。同样，公司可能需要大订单的电子邮件地址列表用于其他目的（第三个选项）

+   你是否希望遵循在表格中对个体进行操作的纪律，仅在需要执行表格上不可用的聚合计算时提取列表？

+   有一种方法看起来比另一种方法更节省资源吗？这实际上是一个微妙的问题：你可能倾向于认为在表格上过滤比在某一列的值列表上过滤使用更多资源，但实际上并非如此。我们稍后会回到这个讨论。

公司或项目团队有时会设定设计标准来帮助你做出这些决定。在没有这些标准的情况下，尤其是在你学习编程时，面对此类问题时，考虑多种方法，然后选择一种来实现。保持灵活思考方法的能力在任何形式的设计中都是一项有用的技能。

到目前为止，我们只看到了如何使用列表上的内置函数。接下来 [处理列表]，我们将研究如何创建我们自己的处理列表的函数。一旦我们学会了这一点，这些列表处理函数将保持强大，但将不再显得那么神奇，因为我们将能够为自己构建它们！

#### 5.1.1 基本统计问题 "链接到这里")

我们可能还想对事件数据提出更多问题。例如：

+   最常使用的折扣代码。

+   每个订单的平均票数。

+   最大的票订单。

+   订单中最常见的票数。

+   使用过的唯一折扣代码集合（可能有很多可用）。

+   与订单相关联的独立电子邮件地址集合，这样我们就可以联系客户（一些客户可能下了多个订单）。

+   哪所学校导致了拥有最多`"STUDENT"`折扣的订单数量。

注意我们正在讨论的操作类型：计算最大值、最小值、平均值、中位数和其他基本统计量。Pyret 在[math](http://www.pyret.org/docs/latest/math.html)和[statistics](http://www.pyret.org/docs/latest/statistics.html)包中提供了几个内置的统计函数。

> 现在就做！
> 
> > 思考你是否以及如何使用你已经看到的操作来表达这些问题。

在这些情况下，我们需要对数据的一个单独列进行计算（甚至在关于`"STUDENT"`折扣的最后一个问题中也是如此，因为我们会过滤表格到那些行，然后在`email`列上执行计算）。为了在代码中捕获这些，我们需要从表中提取一列。

在本章的剩余部分，我们将使用上一章的`event-data`的清理副本进行工作。经过上一章末尾转换的清理数据位于同一 Google 表格的不同标签页中，与其他版本的事件数据相同。

```py
include gdrive-sheets
include data-source

ssid = "1Ks4ll5_8wyYK1zyXMm_21KORhagSMZ59dcr7i3qY6T4"
cleaned-data =
  load-table: name, email, tickcount, discount, delivery, zip
    source: load-spreadsheet(ssid).sheet-by-name("Cleaned", true)
    sanitize name using string-sanitizer
    sanitize email using string-sanitizer
    sanitize tickcount using num-sanitizer
    sanitize discount using string-sanitizer
    sanitize delivery using string-sanitizer
    sanitize zip using string-sanitizer
  end
```

#### 5.1.2 从表中提取列 "链接到这里")

我们的表格函数集合中包括一个我们尚未使用的函数，称为 `select-columns`。正如其名称所暗示的，这个函数会生成一个新的表格，其中只包含现有表格中的某些列。让我们提取 `tickcount` 列，以便我们可以对其计算一些统计数据。我们使用以下表达式：

```py
select-columns(cleaned-data, [list: "tickcount"])
```

![](img/218dbd3d076ef24041ce988f1e4f6c1d.png)

这使我们专注于数字门票销售，但我们仍然被困在表格中的列中，而且其他表格函数都不能让我们对这些数字进行我们可能想要的计算。理想情况下，我们希望拥有这些数字的集合，而不需要被包裹在额外的表格单元格层中。

在原则上，我们可以在单个列上执行一系列操作。在一些只关注表格的语言中，例如 [SQL](https://en.wikipedia.org/wiki/SQL)，你将发现这就是你需要的。然而，在 Pyret 中，我们拥有的数据类型远不止列（正如我们很快就会看到的 [结构化数据介绍]，我们甚至可以创建自己的数据类型！），因此，迟早离开表格的温柔茧房是有意义的。提取出的列是一种更基本的数据类型，称为列表，它可以用来表示表格之外的数据序列。

正如我们使用 `.row-n` 语法从表格中提取单行一样，我们使用类似的基于点的概念来提取单列。以下是如何提取 `tickcount` 列的示例：

```py
cleaned-data.get-column("tickcount")
```

作为回应，Pyret 产生了以下值：

```py
[list: 2, 1, 5, 0, 3, 10, 3]
```

现在，我们似乎只有列中的值，没有包含的表格。然而，数字现在被捆绑在一起，这次是在 `[list: ...]` 语法中。那是什么？

#### 5.1.3 理解列表 "链接到这里")

列表与单列表格有很多共同之处：

+   元素具有顺序，因此谈论列表的“第一个”、“第二个”、“最后一个”——以及等等——元素是有意义的。

+   列表的所有元素都期望具有相同的类型。

关键的区别在于列表没有“列名”；它是匿名的。也就是说，列表本身并不描述它所代表的内容；这种解释是由我们的程序完成的。

##### 5.1.3.1 列表作为匿名数据 "链接到这里")

这可能听起来相当抽象——<wbr>确实如此——<wbr>但这并不是我们编程经验中的新想法。考虑一个像 `3` 或 `-1` 这样的值：它是什么？它属于同一类：一个匿名值，不描述它所代表的内容；解释由我们的程序完成。在一个环境中，`3` 可能代表年龄，在另一个环境中可能代表播放次数；在一个环境中 `-1` 可能是温度，在另一个环境中可能是几个温度的平均值。同样，对于字符串：`"project"` 是名词（一个人或多人执行的活动）还是动词（例如，当我们把某物显示在屏幕上时）？同样，对于图像等也是如此。事实上，到目前为止，表格是例外，描述是内置于数据中而不是由程序提供的！

这种通用性既是优点也是问题。因为，像其他匿名数据一样，列表不提供对其使用的任何解释，如果我们不小心，我们可能会错误地解释值。另一方面，这意味着我们可以在几个不同的环境中使用相同的数据，一个操作可以在许多设置中使用。 

事实上，如果我们看看我们之前提出的问题列表，我们会看到有几个常见的操作——<wbr>最大值、最小值、平均值等——<wbr>可以在不考虑列表代表什么（身高、年龄、播放次数）的情况下对值列表进行提问。实际上，有些是特定于数字的（如平均值），而有些（如最大值）可以针对我们可以执行比较的任何类型进行提问（如字符串）。

##### 5.1.3.2 创建字面量列表 "链接至此")

我们已经看到如何使用 `get-column` 从表格创建列表。然而，正如你所预期的，我们也可以直接创建列表：

```py
[list: 1, 2, 3]
[list: -1, 5, 2.3, 10]
[list: "a", "b", "c"]
[list: "This", "is", "a", "list", "of", "words"]
```

当然，列表是值，所以我们可以用变量来命名它们——<wbr>

```py
shopping-list = [list: "muesli", "fiddleheads"]
```

——<wbr>将它们传递给函数（正如我们很快将看到的），等等。

> 现在行动起来！
> 
> > 根据这些例子，你能想出如何创建一个空列表吗？

如你所猜想的，它是 `[list: ]`（空格不是必需的，但它是一个有用的视觉提醒，表示空白）。

##### 5.1.3.1 列作为匿名数据 "链接至此")

这可能听起来相当抽象——<wbr>确实如此——<wbr>但这并不是我们编程经验中的新想法。考虑一个像 `3` 或 `-1` 这样的值：它是什么？它属于同一类：一个匿名值，不描述它所代表的内容；解释由我们的程序完成。在一个环境中，`3` 可能代表年龄，在另一个环境中可能代表播放次数；在一个环境中 `-1` 可能是温度，在另一个环境中可能是几个温度的平均值。同样，对于字符串：`"project"` 是名词（一个人或多人执行的活动）还是动词（例如，当我们把某物显示在屏幕上时）？同样，对于图像等也是如此。事实上，到目前为止，表格是例外，描述是内置于数据中而不是由程序提供的！

这种通用性既是优点也是问题。因为，像其他匿名数据一样，列表不提供对其使用的任何解释，如果我们不小心，我们可能会意外地误解值。另一方面，这意味着我们可以在几个不同的上下文中使用相同的数据，一个操作可以在许多设置中使用。

事实上，如果我们看看我们之前提出的问题列表，我们会看到有几个常见的操作——<wbr>最大值、最小值、平均值等等——可以在不考虑列表代表什么（身高、年龄、播放次数）的情况下对值列表进行提问。实际上，有些是特定于数字的（如平均值），而有些（如最大值）可以针对我们可以执行比较的任何类型进行提问（如字符串）。

##### 5.1.3.2 创建字面量列表 "链接至此")

我们已经看到如何使用`get-column`从表格中创建列表。然而，正如你可能预料的那样，我们也可以直接创建列表：

```py
[list: 1, 2, 3]
[list: -1, 5, 2.3, 10]
[list: "a", "b", "c"]
[list: "This", "is", "a", "list", "of", "words"]
```

当然，列表是值，所以我们可以用变量来命名它们——<wbr>

```py
shopping-list = [list: "muesli", "fiddleheads"]
```

——<wbr>将它们传递给函数（正如我们很快将看到的），等等。

> 现在行动起来！
> 
> > 根据这些示例，你能想出如何创建一个空列表吗？

正如你可能猜到的，它是`[list: ]`（空格不是必需的，但它是一个有用的视觉提醒，表示空无）。

#### 5.1.4 在列表上操作 "链接至此")

##### 5.1.4.1 数字列表的内置操作 "链接至此")

Pyret 方便地提供了一组我们可以直接在列表上执行的运算。[列表文档](https://www.pyret.org/docs/latest/lists.html)描述了这些运算。正如你可能已经猜到的，我们已经在章节开头计算了大部分我们要求的结果。首先，我们需要包含一些包含有用函数的库：

```py
import math as M
import statistics as S
```

然后，我们可以访问几个有用的函数：

```py
tickcounts = cleaned-data.get-column("tickcount")

M.max(tickcounts)     # largest number in a list
M.sum(tickcounts)     # sum of numbers in a list
S.mean(tickcounts)    # mean (average) of numbers in a list
S.median(tickcounts)  # median of numbers in a list
```

`M.`表示“库`M`中的函数”。上述代码中的`import`语句将`math`库的名称指定为`M`。

##### 5.1.4.2 列表通用内置操作 "链接至此")

本章开头列表中的一些有用计算涉及到`discount`列，该列包含字符串而不是数字。具体来说，让我们考虑以下问题：

+   计算使用过的唯一折扣代码集合（可能有很多可用）。

没有表格函数可以处理这样的问题。然而，这是一个关于值集合的常见问题（你的播放列表中有多少独特的艺术家？有多少独特的教师正在教授课程？）。因此，Pyret（以及大多数语言）提供了一种识别列表中唯一元素的方法。以下是我们如何获取我们表格中使用的所有折扣代码的列表：

```py
import lists as L
codes = cleaned-data.get-column("discount")
L.distinct(codes)
```

`distinct`函数从输入列表生成一个唯一值的列表：输入列表中的每个值在输出列表中恰好出现一次。对于上面的代码，Pyret 生成：

```py
[list: "BIRTHDAY", "STUDENT", "none"]
```

如果我们想要从列表中排除`"none"`，怎么办？毕竟，`"none"`不是一个实际的折扣代码，而是一个我们在清理表格时引入的代码。有没有一种简单的方法可以从列表中移除`"none"`？

我们可以有两种方法来做这件事。在 Pyret 列表文档中，我们找到一个名为`remove`的函数，该函数可以从列表中移除特定的元素：





> ```py
> L.remove(L.distinct(codes), "none")
> ```







```py
[list: "BIRTHDAY", "STUDENT"]
```



但这个操作也应该听起来很熟悉：在表格中，我们使用`filter-with`来保留满足特定标准的元素。过滤的想法如此常见，以至于 Pyret（以及大多数其他语言）在列表上提供了类似的操作。在折扣代码的情况下，我们也可以这样写：

```py
fun real-code(c :: String) -> Boolean:
  not(c == "none")
end
L.filter(real-code, L.distinct(codes))
```

这两种方法的区别在于`filter`更加灵活：我们可以使用`filter`检查列表元素的任何特征，但`remove`只检查整个元素是否等于我们提供的值。如果我们不是要移除特定的字符串`"none"`，而是要移除所有全小写的字符串，我们就需要使用`filter`。

> 练习
> 
> > 编写一个函数，该函数接受一个单词列表，并移除所有字母都为小写的单词。（提示：结合`string-to-lower`和`==`）。

##### 5.1.4.3 关于命名约定的补充 "链接到此处")

我们在名为`discount`（单数）的列的值列表中使用复数`codes`是有意为之。列表包含多个值，所以复数是合适的。相比之下，在表格中，我们认为列标题命名的是特定行中出现的单个值。我们经常谈论在特定行和列中查找值：列的单数名称支持在单个行中进行查找的思考。

##### 5.1.4.4 通过位置获取元素 "链接到此处")

让我们看看一个新的分析问题：事件公司最近在`web.com`上进行了广告宣传活动，他们想知道这有没有效果。为了做到这一点，他们需要确定有多少销售是通过具有`web.com`电子邮件地址的人完成的。

> 现在行动！
> 
> > 提出一个任务计划（任务计划）用于这个计算。

这里有一个提出的计划，并标注了如何实现每个部分：

1.  获取电子邮件地址列表（使用`get-column`）

1.  提取来自`web.com`的元素（使用`L.filter`）

1.  计算剩余的电子邮件地址数量（使用`L.length`，我们尚未讨论，但在文档中有所提及）

（作为提醒，除非你立即看到解决问题的方法，否则请写出任务计划并标注你已知如何做的部分。这有助于将编程问题分解成更易于管理的部分。）

让我们讨论第二个任务：识别来自`web.com`的消息。我们知道电子邮件地址是字符串，所以如果我们能确定电子邮件字符串以`@web.com`结尾，我们就成功了。你可以考虑通过查看电子邮件字符串的最后 7 个字符来做这件事。另一种选择是使用我们尚未看到的字符串操作`string-split-all`，它将字符串分割成以给定字符为分隔的子字符串列表。例如：





> ```py
> string-split-all("this-has-hyphens", "-")
> ```







```py
[list: "this", "has", "hyphens"]
```







> ```py
> string-split("bonnie@pyret.org", "@")
> ```







```py
[list: "bonnie", "pyret.org"]
```



这看起来非常有用。如果我们围绕`@`符号分割每个电子邮件字符串，那么我们可以检查列表中的第二个字符串是否为`web.com`（因为电子邮件地址应该只有一个`@`符号）。但我们是如何从`string-split-all`产生的列表中获取第二个元素的？在这里，我们深入列表，就像我们提取表格中的行一样，这次使用`get`操作。





> ```py
> string-split("bonnie@pyret.org", "@").get(1)
> ```







```py
"pyret.org"
```



> 现在行动！
> 
> > 为什么我们要将`1`作为`get`的输入，如果我们想获取列表中的第二个项目？

这里是进行此检查的完整程序：

```py
fun web-com-address(email :: String) -> Boolean:
  doc: "determine whether email is from web.com"
  string-split(email, "@").get(1) == "web.com"
where:
  web-com-address("bonnie@pyret.org") is false
  web-com-address("parrot@web.com") is true
end

emails = cleaned-data.get-column("email")
L.length(L.filter(web-com-address, emails))
```

> 练习
> 
> > 如果有一个没有包含`@`字符串的格式不正确的电子邮件地址字符串会发生什么？会发生什么？你能做些什么？

##### 5.1.4.5 列表转换 "链接到这里")

假设我们现在有一个电子邮件地址列表，但我们只想有一个用户名列表。这在我们的事件数据中并不合理，但在其他上下文中是有意义的（例如，将消息连接到按学生用户名组织的文件夹）。

具体来说，我们想要从一个地址列表开始，例如：

```py
[list: "parrot@web.com", "bonnie@pyret.org"]
```

并将其转换为

```py
[list: "parrot", "bonnie"]
```

> 现在行动！
> 
> > 考虑我们迄今为止看到的列表函数（`distinct`、`filter`、`length`）——它们中的任何一个对这个任务有用吗？你能阐述为什么吗？

一种明确回答这个问题的方法是从现有函数的输入和输出角度思考。`filter`和`distinct`都返回输入列表中的元素列表，而不是转换后的元素。`length`返回一个数字，而不是一个列表。所以这些都不合适。

这种转换元素的想法与我们在表格中之前看到的`transform-column`操作类似。列表上的相应操作称为`map`。以下是一个示例：

```py
fun extract-username(email :: String) -> String:
  doc: "extract the portion of an email address before the @ sign"
  string-split(email, "@").get(0)
where:
  extract-username("bonnie@pyret.org") is "bonnie"
  extract-username("parrot@web.com") is "parrot"
end

L.map(extract-username,
  [list: "parrot@web.com", "bonnie@pyret.org"])
```

##### 5.1.4.6 回顾：列表操作总结 "链接到这里")

在这一点上，我们已经看到了几个用于处理列表的有用内置函数：

+   `filter :: (A -> Boolean), List<A> -> List<A>`，它产生一个列表，其中包含输入列表中给定函数返回`true`的元素。

+   `map :: (A -> B), List<A> -> List<B>`，它产生一个列表，其中包含对输入列表中的每个元素调用给定函数的结果。

+   `distinct :: List<A> -> List<A>`，它产生一个包含输入列表中出现的唯一元素的列表。

+   `length :: List<A> -> Number`，它产生输入列表中的元素数量。

在这里，类型如`List<A>`表示我们有一个元素类型为某种（未指定的）类型的列表，我们将称之为`A`。这种类型变量在函数契约中显示两个类型之间的关系时很有用。在这里，类型变量`A`捕获了`filter`的输入和输出类型相同的事实。然而，在`map`中，输出列表中的元素类型可能与输入列表中的不同。

实践中非常有用的一项附加内置函数是：

+   `member :: List<A>, Any -> Boolean`，该函数用于确定给定元素是否在列表中。当提供给函数的值的类型没有约束时，我们使用类型`Any`。

可以通过组合这些操作执行许多有用的计算。

> 练习
> 
> > 假设你使用字符串列表来表示食谱中的配料。以下有三个示例：
> > 
> > ```py
> > stir-fry =
> >   [list: "peppers", "pork", "onions", "rice"]
> > dosa = [list: "rice", "lentils", "potato"]
> > misir-wot =
> >   [list: "lentils", "berbere", "tomato"]
> > ```
> > 
> > 在配料列表上编写以下函数：
> > 
> > +   `recipes-uses`，该函数接受一个配料列表和一个配料，并确定食谱是否使用了该配料。
> > +   
> > +   `make-vegetarian`，该函数接受一个配料列表，并将所有肉类配料替换为`"tofu"`。肉类配料包括`"pork"`、`"chicken"`和`"beef"`。
> > +   
> > +   `protein-veg-count`，该函数接受一个配料列表，并确定列表中有多少配料不是`"rice"`或`"noodles"`。
> > +   
> 练习
> 
> > 更具挑战性：编写一个函数，该函数接受一个配料和一个配料列表，并生成包含给定配料的所有列表。
> > 
> > 提示：首先编写示例，以便在需要时理解问题。
> > 
> 练习
> 
> > 更具挑战性：尝试编写一个函数，该函数接受两个配料列表并返回两个列表共有的所有配料。你遇到了哪些问题或限制？
> > 
> > 在完成下一节之后，回到这个问题。

##### 5.1.4.1 数字列表的内置操作 "链接到这里")

Pyret 方便地提供了一组我们可以在列表上执行的有用操作。[列表文档](https://www.pyret.org/docs/latest/lists.html)描述了这些操作。正如你可能猜到的，我们已经在章节开始时计算了大部分我们要求的问题的答案。首先，我们需要包含一些包含有用函数的库：

```py
import math as M
import statistics as S
```

然后，我们可以访问几个有用的函数：

```py
tickcounts = cleaned-data.get-column("tickcount")

M.max(tickcounts)     # largest number in a list
M.sum(tickcounts)     # sum of numbers in a list
S.mean(tickcounts)    # mean (average) of numbers in a list
S.median(tickcounts)  # median of numbers in a list
```

`M.`表示“库`M`中的函数”。上述代码中的`import`语句将`math`库命名为`M`。

##### 5.1.4.2 列表的一般内置操作 "链接到这里")

我们在章节开头列表中的某些有用计算涉及到`discount`列，该列包含字符串而不是数字。具体来说，让我们考虑以下问题：

+   计算使用过的唯一折扣代码集合（可能有很多可用）。

没有表格函数可以处理这样的问题。然而，这类问题在询问一组值时很常见（你的播放列表中有多少独特的艺术家？有多少独特的教员在教授课程？）。因此，Pyret（以及大多数语言）提供了一种方法来识别列表中的唯一元素。以下是我们如何获取我们表格中使用的所有折扣代码的列表：

```py
import lists as L
codes = cleaned-data.get-column("discount")
L.distinct(codes)
```

`distinct`函数从输入列表中生成一个唯一值的列表：输入列表中的每个值在输出列表中恰好出现一次。对于上面的代码，Pyret 生成：

```py
[list: "BIRTHDAY", "STUDENT", "none"]
```

如果我们想从列表中排除`"none"`怎么办？毕竟，`"none"`不是一个实际的折扣代码，而是一个我们在清理表格时引入的代码。有没有一种简单的方法可以从列表中移除`"none"`？

我们有两种方法可以做到这一点。在 Pyret 列表文档中，我们找到一个名为`remove`的函数，该函数可以从列表中移除一个特定的元素：





> ```py
> L.remove(L.distinct(codes), "none")
> ```







```py
[list: "BIRTHDAY", "STUDENT"]
```



但这个操作也应该听起来很熟悉：使用表格时，我们使用了`filter-with`来保留满足特定标准的元素。过滤的想法非常常见，以至于 Pyret（以及大多数其他语言）在列表上提供了类似的操作。在折扣代码的情况下，我们也可以这样写：

```py
fun real-code(c :: String) -> Boolean:
  not(c == "none")
end
L.filter(real-code, L.distinct(codes))
```

这两种方法之间的区别在于`filter`更灵活：我们可以使用`filter`检查列表元素的任何特征，但`remove`只检查整个元素是否等于我们提供的值。如果我们不是想移除特定的字符串`"none"`，而是想移除所有全小写的字符串，我们就需要使用`filter`。

> 练习
> 
> > 编写一个函数，该函数接受一个单词列表，并移除所有字母都为小写的单词。（提示：结合`string-to-lower`和`==`）。

##### 5.1.4.3 关于命名约定的补充 "链接到这里")

我们在名为`discount`（单数）的列的值列表中使用复数`codes`是有意为之。列表包含多个值，所以复数是合适的。相比之下，在表格中，我们认为列标题命名的是特定行中出现的单个值。我们经常谈论在特定行和列中查找值：列的单数名称支持在单个行中进行查找的想法。

##### 5.1.4.4 通过位置获取元素 "链接到这里")

让我们来看一个新的分析问题：事件公司最近在`web.com`上做了一次广告宣传活动，他们想知道这有没有带来回报。为了做到这一点，他们需要确定有多少销售是通过带有`web.com`电子邮件地址的人完成的。

> 现在行动！
> 
> > 提出一个计算任务计划（任务计划）。

这里有一个提出的计划，并附上了我们可能如何实现每一部分的说明：

1.  获取电子邮件地址列表（使用`get-column`）

1.  提取来自 `web.com` 的那些（使用 `L.filter`）

1.  计算剩余的电子邮件地址数量（使用 `L.length`，我们还没有讨论过，但它已在文档中）

（作为提醒，除非你立即知道如何解决问题，否则请列出任务计划并标注你知道如何做的部分。这有助于将编程问题分解成更易于管理的部分。）

让我们讨论第二个任务：识别来自 `web.com` 的消息。我们知道电子邮件地址是字符串，所以如果我们能确定电子邮件字符串是否以 `@web.com` 结尾，我们就成功了。你可以考虑通过查看电子邮件字符串的最后 7 个字符来做这件事。另一个选择是使用我们尚未看到的字符串操作 `string-split-all`，它将字符串拆分为围绕给定字符的子字符串列表。例如：





> ```py
> string-split-all("this-has-hyphens", "-")
> ```







```py
[list: "this", "has", "hyphens"]
```







> ```py
> string-split("bonnie@pyret.org", "@")
> ```







```py
[list: "bonnie", "pyret.org"]
```



这看起来非常有用。如果我们围绕 `@` 符号拆分每个电子邮件字符串，那么我们可以检查列表中的第二个字符串是否为 `web.com`（因为电子邮件地址应该只有一个 `@` 符号）。但我们如何从 `string-split-all` 生成的列表中获取第二个元素呢？在这里，我们像提取表格中的行一样深入列表，这次使用 `get` 操作。





> ```py
> string-split("bonnie@pyret.org", "@").get(1)
> ```







```py
"pyret.org"
```



> 立刻行动！
> 
> > 如果我们想要列表中的第二个项目，为什么将 `1` 作为 `get` 的输入？

这里是完成此检查的完整程序：

```py
fun web-com-address(email :: String) -> Boolean:
  doc: "determine whether email is from web.com"
  string-split(email, "@").get(1) == "web.com"
where:
  web-com-address("bonnie@pyret.org") is false
  web-com-address("parrot@web.com") is true
end

emails = cleaned-data.get-column("email")
L.length(L.filter(web-com-address, emails))
```

> 练习
> 
> > 如果有一个格式不正确的电子邮件地址字符串不包含 `@` 字符串会发生什么？会发生什么？你能做些什么？

##### 5.1.4.5 转换列表 "链接至此")

假设现在我们有一个电子邮件地址列表，但我们只想有一个用户名列表。这在我们的事件数据中并不合理，但在其他上下文中是有意义的（例如，将消息连接到按学生用户名组织的文件夹）。

具体来说，我们想要从一个地址列表开始，例如：

```py
[list: "parrot@web.com", "bonnie@pyret.org"]
```

并将其转换为

```py
[list: "parrot", "bonnie"]
```

> 立刻行动！
> 
> > 考虑我们迄今为止看到的列表函数（`distinct`、`filter`、`length`）——它们中的任何一个对这个任务有用吗？你能阐述为什么吗？

一种明确回答这个问题的方法是从现有函数的输入和输出角度思考。`filter` 和 `distinct` 都返回输入列表中的元素列表，而不是转换后的元素。`length` 返回一个数字，而不是一个列表。所以这些都不合适。

这种转换元素的想法类似于我们在表格中之前看到的 `transform-column` 操作。列表上的相应操作称为 `map`。以下是一个示例：

```py
fun extract-username(email :: String) -> String:
  doc: "extract the portion of an email address before the @ sign"
  string-split(email, "@").get(0)
where:
  extract-username("bonnie@pyret.org") is "bonnie"
  extract-username("parrot@web.com") is "parrot"
end

L.map(extract-username,
  [list: "parrot@web.com", "bonnie@pyret.org"])
```

##### 5.1.4.6 回顾：列表操作总结 "链接至此")

到目前为止，我们已经看到了几个用于处理列表的有用内置函数：

+   `filter :: (A -> Boolean), List<A> -> List<A>`，它产生一个列表，包含输入列表中给定函数返回 `true` 的元素。

+   `map :: (A -> B), List<A> -> List<B>`，它产生一个列表，该列表包含对输入列表中每个元素调用给定函数的结果。

+   `distinct :: List<A> -> List<A>`，它产生一个列表，其中包含输入列表中出现的唯一元素。

+   `length :: List<A> -> Number`，它产生输入列表中的元素数量。

在这里，一个如 `List<A>` 这样的类型表示我们有一个元素类型为某种（未指定的）类型的列表，我们将称之为 `A`。这种类型变量在函数契约中显示两个类型之间的关系时很有用。在这里，类型变量 `A` 捕获了元素类型在 `filter` 的输入和输出中是相同的。然而，在 `map` 中，输出列表中的元素类型可能与输入列表中的元素类型不同。

在实践中非常有用的一个额外内置函数是：

+   `member :: List<A>, Any -> Boolean`，它确定给定元素是否在列表中。当提供给函数的值的类型没有约束时，我们使用类型 `Any`。

许多有用的计算可以通过组合这些操作来完成。

> 练习
> 
> > 假设你使用字符串列表来表示食谱中的配料。以下是一些示例：
> > 
> > ```py
> > stir-fry =
> >   [list: "peppers", "pork", "onions", "rice"]
> > dosa = [list: "rice", "lentils", "potato"]
> > misir-wot =
> >   [list: "lentils", "berbere", "tomato"]
> > ```
> > 
> > 在配料列表上编写以下函数：
> > 
> > +   `recipes-uses` 函数接受一个配料列表和一个配料，并确定该食谱是否使用了该配料。
> > +   
> > +   `make-vegetarian` 函数接受一个配料列表，并将所有肉类配料替换为 `"tofu"`。肉类配料是 `"pork"`、`"chicken"` 和 `"beef"`。
> > +   
> > +   `protein-veg-count` 函数接受一个配料列表，并确定列表中有多少配料不是 `"rice"` 或 `"noodles"`。
> > +   
> 练习
> 
> > 更具挑战性：编写一个函数，该函数接受一个配料和一个配料列表列表，并生成包含给定配料的所有列表。
> > 
> > 提示：首先编写示例，以便在需要时理解问题。
> > 
> 练习
> 
> > 更加具有挑战性：尝试编写一个函数，该函数接受两个配料列表并返回两个列表中共同的所有配料。你遇到了哪些问题或限制？
> > 
> > 在完成下一节之后，回到这个问题。

#### 5.1.5 Lambda: 匿名函数 "链接到此处")

注意：如果你已经在 Lambda: 匿名函数 中看到了 `lam`，你可以自由地跳过这一节，或者只需做结尾的练习。在这里，我们使用列表和 `filter` 而不是表格和 `filter-with` 来展示 `lam`。

让我们回顾一下本章前面编写的程序，用于查找在事件表中使用的所有折扣代码：

```py
fun real-code(c :: String) -> Boolean:
  not(c == "none")
end
L.filter(real-code, codes)
```

这个程序可能感觉有点冗长：我们真的需要编写一个辅助函数来执行如此简单的 `filter` 操作吗？直接写点像这样的事情不是更容易吗？

```py
L.filter(not(c == "none"), codes)
```

> 现在行动！
> 
> > 如果你运行这个表达式，Pyret 会产生什么结果？

Pyret 会在使用`c`的表达式中产生一个`未绑定标识符`错误。`c`是什么？我们希望`c`依次是`codes`中的元素。从概念上讲，这就是`filter`所做的事情，但我们没有正确地实现机制。当我们调用一个函数时，我们会先评估函数体之前的参数。因此，关于`c`未绑定的错误。`real-code`辅助函数的全部目的就是使`c`成为函数的一个参数，该函数体只有在`c`的值可用时才会被评估。

为了使符号更加紧凑，就像单行`filter`表达式中的那样，我们需要找到一种方法告诉 Pyret 创建一个临时函数，该函数将在`filter`运行时获取其输入。以下符号实现了这一点：

```py
L.filter(lam(c): not(c == "none") end, codes)
```

我们在想要在`filter`中使用的表达式中添加了`lam(c)`和`end`。`lam(c)`表示“创建一个临时函数，该函数接受`c`作为输入”。`end`的作用是结束函数定义，就像我们使用`fun`时一样。`lam`是`lambda`的缩写，它是一种存在于许多语言中但并非所有语言中的函数定义形式。

我们原始表达式（使用`real-code`辅助函数）和这个新表达式（使用`lam`）之间的主要区别可以通过程序目录来看到。为了解释这一点，我们需要了解一下`filter`在底层是如何定义的。部分地，它看起来像：

```py
fun filter(keep :: (A -> Boolean), lst :: List<A>) -> List<A>:
  if keep(<elt-from-list>):
    ...
  else:
    ...
  end
end
```

无论我们传递`real-code`还是`lam`版本给`filter`，`keep`参数最终都会指向一个具有相同参数和体的函数。由于函数实际上是通过`keep`名称调用的，因此当它最初定义时，是否与它关联一个名称并不重要。

在实践中，当我们需要将简单的（单行）函数传递给像`filter`（或`map`）这样的操作时，我们会使用`lam`。我们同样可以在处理表格时使用它们（例如`build-column`、`filter-with`等）。当然，如果您觉得这样更有意义，您也可以继续像`real-code`那样为辅助函数编写名称。

> 练习
> 
> > 编写一个程序，使用`lam`而不是命名辅助函数从电子邮件地址列表中提取用户名列表。
> > 
> 练习
> 
> > 再次尝试从上一节的末尾开始解决这个问题：编写一个函数，该函数接受两个配料列表，并返回两个列表中共同的所有配料。

#### 5.1.6 结合列表和表格 "链接到此处")

我们之前研究的表格函数主要用于处理行。我们在本章中学到的列表函数主要用于处理列（但接下来的章节中还有更多用途）。如果一个分析只涉及处理一些行和一些列，我们将在程序中使用表格和列表函数的组合。

> 练习
> 
> > 给定事件表，生成所有将取票的人的姓名列表。
> > 
> 练习
> 
> > 给定事件表，计算以`".org"`结尾的电子邮件地址的人订购的平均票数。

有时，执行计算可能会有多种方法：

> 现在就做！
> 
> > 考虑一个问题，比如“有多少人使用`".org"`电子邮件地址购买了超过 8 张票”。提出多个解决这个问题的任务计划，包括哪些表和列表函数可以完成每个任务。

这里有几个选项：

1.  获取没有超过 8 张票的`event-data`行（使用`filter-with`），获取那些有`".org"`地址的行（另一个`filter-with`），然后询问表中行数（使用`<table>.length()`）。

1.  获取没有超过 8 张票和`".org"`地址的`event-data`行（使用`filter-with`同时检查这两个条件的函数），然后询问表中行数（使用`<table>.length()`）。

1.  获取没有超过 8 张票的`event-data`行（使用`filter-with`），提取电子邮件地址（使用`get-column`），限制到`".org"`（使用`L.filter`），然后获取结果列表的长度（使用`L.length`）。

还有其他选项，但你应该明白了。

> 现在就做！
> 
> > 你最喜欢哪种方法？为什么？

虽然没有唯一的正确答案，但有许多考虑因素：

+   任何中间结果对其他计算有用吗？虽然第二个选项可能看起来最好，因为它只过滤表格一次而不是两次，但也许事件公司需要对更大的订单执行许多计算。同样，公司可能希望为了其他目的（第三个选项）获取大订单的电子邮件地址列表

+   你是否想在表格中对个体进行操作，只在需要执行表格上不可用的聚合计算时提取列表？

+   有一种方法看起来比另一种方法资源消耗更少吗？这实际上是一个微妙的问题：你可能倾向于认为在表格上过滤比在某一列的值列表上过滤使用更多资源，但实际上并非如此。我们稍后会回到这个讨论。

公司或项目团队有时会设定设计标准来帮助你做出这些决定。在没有这些标准的情况下，尤其是在你学习编程时，面对此类问题时，考虑多种方法，然后选择一个来实现。保持灵活思考方法的能力在任何形式的设计中都是一项有用的技能。

到目前为止，我们只看到了如何使用内置函数处理列表。在接下来的 [处理列表] 中，我们将学习如何创建我们自己的处理列表的函数。一旦我们学会了这一点，这些列表处理函数将仍然强大，但将不再显得那么神奇，因为我们将能够为自己构建它们！
