# 25 分解数字

> 原文：[`dcic-world.org/2025-08-27/factoring-numbers.html`](https://dcic-world.org/2025-08-27/factoring-numbers.html)

| |
| --- |

现代密码学的很大一部分建立在分解数字的困难性之上。假设我们想要分解 \(n\)。我们可以简单地检查从 \(2\) 到 \(n-1\)（实际上，直到 \(\sqrt{n}\)）的任何数字是否可以整除 \(n\)：如果可以，那么它就是一个因子，然后我们递归地分解剩下的部分。这只需要线性时间！为什么这很难？

问题在于它在“错误”的事物上呈线性：数字的值。然而，在位表示法中，一个数字的值在最坏情况下是它大小的指数级。因此，我们必须迭代直到至少是大小指数的平方根，即大小除以 2，这属于相同的 big-O 类，即值的指数级。一般来说，我们实际上不知道如何改进因子分解的最坏情况性能，这就是为什么当代密码学工作。（我们也在其他地方讨论了数字 [数字的复杂性]。）

在实践中，拥有快速终止的因子分解算法是有用的。显然，它们不能是完美的；我们不得不在某种程度上在准确性上做出妥协：报告一个非质数为质数，报告一个非因子为因子等。

一个著名的算法被称为 Pollard 的 rho 算法。它将尝试找到一个数字的因子。如果它成功了，我们可以保证它找到的确实是一个因子。如果失败了，然而，我们无法确定该数字实际上是否是质数：可能还有其他隐藏的因子。

该算法的名字来源于一个应该从 检测循环 中熟悉的图片：

![](img/31742a6ba02914cbc2bca965912ea982.png)

如果你稍微旋转一下，你会得到希腊字母 \(\rho\)。这种相似性，正如我们稍后将看到的，不是巧合。

解释这个算法需要比我们这里能涵盖的更多数论：如果你感兴趣，更多关于它 [在维基百科上](https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm) 的信息。相反，我们将专注于代码。

首先，我们需要一个辅助函数来计算最大公约数：

```py
fun gcd(a, b):
  if b == 0:
    a
  else:
    gcd(b, num-modulo(a, b))
  end
end
```

有了这个，我们可以定义 Pollard-rho 实现方法。回想一下，该函数可能成功也可能不成功地在找到因子（特别是，当给定一个质数时，它必须失败！），所以我们使用 `Option` 类型来反映两种可能性：

```py
fun pr(n):
  fun g(x): num-modulo((x * x) + 1, n) end
  fun loop(x, y, d):
    new-x = g(x)
    new-y = g(g(y))
    new-d = gcd(num-abs(new-x - new-y), n)
    ask:
      | new-d == 1 then:
        loop(new-x, new-y, new-d)
      | new-d == n then:
        none
      | otherwise:
        some(new-d)
    end
  end
  loop(2, 2, 1)
end
```

关键步骤是计算 `g(x)` 与 `g(g(x))`。我们可以想象 `x` 是乌龟，所以 `g(x)` 是乌龟的更新，而 `y` 是兔子，所以 `g(g(y))` 是兔子的更新。

尝试在以下值上运行上述代码，看看它会产生什么结果：

```py
pr(6)
pr(14)
pr(35)
pr(37)
pr(41)
pr(8)
pr(44)
```

通常，我们可以检查前几个数字，看看它们如何接近我们的直觉：

```py
for map(n from range(2, 100)):
  cases (Option) pr(n):
    | none => num-to-string(n) + " may be prime"
    | some(v) => num-to-string(n) + " has factor " + num-to-string(v)
  end
end
```

> 练习
> 
> > 你在上面的输出中看到了任何模式吗？这对你对算法做出任何猜想有帮助吗？你能用数学方法证明你的猜想吗？
