# 20 递归与循环从变异

> 原文：[`dcic-world.org/2025-08-27/rec-from-mut.html`](https://dcic-world.org/2025-08-27/rec-from-mut.html)

在早期 [从无环到循环]，我们看到了构建循环数据的困难，并看到了我们如何使用状态 [循环数据]来解决此问题。现在让我们回到之前创建交替颜色循环列表的早期例子。我们曾试图写：

```py
web-colors = link("white", link("grey", web-colors))
```

正如我们所注意到的，这并不符合标准，因为`web-colors`没有绑定在`=`的右侧。（为什么？因为如果我们尝试在右侧替换`web-colors`，我们最终会陷入无限回归。）

这应该让你有点怀疑：我们一直能够轻松地编写递归函数，为什么它们不同？有两个原因：

+   第一个原因是我们在定义一个函数。函数体不是立即评估的——<wbr>只有当我们应用它时——<wbr>因此，语言可以等待体被定义完成。（我们稍后会看到这可能会意味着什么。）

+   第二个原因实际上并不是一个原因：函数定义实际上是特殊的。但我们将揭示它们之所以特殊的原因——<wbr>那就是使用一个框！[框：一个规范的可变结构]——<wbr>这样任何定义都可以利用它。

回到我们上面的例子，回想一下我们无法使用`link`s 来构建我们的列表，因为我们希望列表永远不会终止。因此，让我们首先定义一个新的数据类型来保存循环列表：

```py
data Pair: p(hd, tl) end
```

你应该把它看作与列表类似，其中`hd`是第一个元素，`tl`是其余部分。

注意到我们仔细地避免了为字段编写类型定义；我们将尝试在过程中找出它们。然而，这个定义按现在的写法是无法工作的。

> 现在行动起来！
> 
> > 你看懂为什么不行吗？

让我们将预期的无限列表分解成两部分：以白色开始的列表和以灰色开始的列表。白色之后是什么？一个灰色列表。灰色之后是什么？一个白色列表。很明显，我们无法写下这两个定义，因为其中一个必须先于另一个，但每个定义都依赖于另一个。（这正是尝试在上面写一个单一定义时遇到的问题。）

### 20.1 部分定义 "链接到此处")

我们需要做的是部分定义每个列表，然后使用另一个列表来完成定义。然而，使用上面的定义这是不可能的，因为我们一旦构建了它就不能再改变任何东西。因此，因此，我们需要：

```py
data Pair: p(hd, ref tl) end
```

注意，这个数据类型缺少一个基本情况，这应该让你想起我们在从函数到流中看到的定义。

使用这个，我们可以定义：

```py
white-pair = p("white", "dummy")
grey-pair = p("grey", "dummy")
```

每个这样的定义单独来看都是相当无用的，但它们各自代表了我们的需求，并且都有一个可变字段，目前持有的是一个占位符值。因此，接下来我们必须做的事情很清楚：更新这个可变字段。

```py
white-pair!{tl: grey-pair}
grey-pair!{tl: white-pair}
```

因为我们已经规定我们的颜色必须从白色开始交替，这使我们的定义圆满结束：

```py
web-colors = white-pair
```

如果我们要求 Pyret 检查 `web-colors` 的值，我们会注意到它使用了一个算法来防止遍历无限对象。你可以单独了解它是如何工作的 [检测循环]。

我们可以定义一个辅助函数，`take`，这是我们在流中看到的一种变体 [从函数生成流]，用来检查无限列表的一个有限前缀：

```py
fun ctake(n :: Number, il :: Pair) -> List:
  if n == 0:
    empty
  else:
    link(il.hd, ctake(n - 1, il!tl))
  end
end
```

以至于：

```py
check:
  ctake(4, web-colors) is
  [list: "white", "grey", "white", "grey"]
end
```

### 20.2 递归函数 "链接到这里")

基于此，我们现在可以理解递归函数。考虑一个非常简单的例子，比如这个：

```py
fun sum(n):
  if n > 0:
    n + sum(n - 1)
  else:
    0
  end
end
```

我们可能认为这等同于：

```py
sum =
  lam(n):
    if n > 0:
      n + sum(n - 1)
    else:
      0
    end
  end
```

但如果你输入这个，Pyret 会抱怨 `sum` 未绑定。我们必须改写为

```py
rec sum =
  lam(n):
    if n > 0:
      n + sum(n - 1)
    else:
      0
    end
  end
```

你认为 `rec` 做了什么？它将 `sum` 绑定到一个最初包含占位符值的盒子里；然后它在一个名称已绑定的环境中定义函数，解包名称的使用；最后，它用定义的函数替换盒子的内容，遵循我们之前在 `web-colors` 中看到的相同模式。

### 20.3 提前评估 "链接到这里")

注意到上述描述揭示了在创建名称和为其分配值之间存在一个时间差。这个中间状态可以被观察到吗？当然可以！

通常有三个解决方案来解决这个问题：

1.  确保值足够隐晦，以至于它永远不会在有意义的环境中使用。这意味着像 0 这样的值尤其糟糕，实际上，大多数常见的数据类型都应该避免使用。确实，没有已经使用的值可以在这里使用，这可能会在某些上下文中造成混淆。

1.  语言可能会为这里创建一个新的值类型。例如，想象一下 `CList` 的这个定义：

    ```py
    data CList:
      | undef
      | clink(v, ref r)
    end
    ```

    `undef` 看起来像是一个“基本情况”，这使得 `CList` 非常类似于 `List`。然而，实际上，`undef` 只存在于第一次突变之前，之后将不再存在：意图是 `r` 只包含对其他 `clink` 的引用。

    语言现在可以使用 `undef` 值来检查循环列表的提前使用。然而，虽然这在技术上可行，但它会带来运行时惩罚。因此，这种检查通常只由专注于教学的编程语言执行；假设专业程序员能够自己管理这种提前使用的后果。

1.  允许递归构造函数仅在绑定函数的情况下使用，并确保绑定的右侧在语法上是一个函数。这种解决方案排除了某些合理的程序，但肯定是安全的。

### 20.4 循环列表与流 "链接到这里")

如我们所提到的，上面的颜色列表示例非常类似于流示例。这两种定义无限数据的方式之间有什么关系？

循环列表在其一边有简单性。上面使用的定义模式实际上可以封装成一个语言构造，这样程序员就不需要与可变字段（如上所示）或 thunks（流所要求的）搏斗。然而，这种简单性是有代价的：循环列表只能表示严格重复的数据，即你不能将 `nats` 或 `fibs` 定义为循环列表。相比之下，流中的函数抽象使其具有生成性：每次调用都可以创建一个真正新颖的数据（如下一个自然数或斐波那契数）。因此，将循环列表作为流实现是直接的，但反之则不然。

### 20.1 部分定义 "链接到这里")

我们需要做的相反的是，部分定义每个列表，然后使用另一个列表来完成定义。然而，使用上述定义这是不可能的，因为我们一旦构建了它就不能再改变任何东西。因此，因此，我们需要：

```py
data Pair: p(hd, ref tl) end
```

注意，这个数据类型缺少一个基本情况，这应该让你想起我们在 从函数生成流 中看到的定义。

使用这个，我们可以定义：

```py
white-pair = p("white", "dummy")
grey-pair = p("grey", "dummy")
```

每个这样的定义本身都相当无用，但它们各自代表我们想要的东西，并且它们都有一个可变字段，目前持有占位符值。因此，很明显我们接下来必须做什么：更新可变字段。

```py
white-pair!{tl: grey-pair}
grey-pair!{tl: white-pair}
```

因为我们已经规定我们的颜色必须从白色开始交替，这使我们的定义圆满：

```py
web-colors = white-pair
```

如果我们要求 Pyret 检查 `web-colors` 的值，我们会注意到它使用了一种算法来防止遍历无限对象。你可以单独了解它是如何工作的 [检测循环]。

我们可以定义一个辅助函数，`take`，这是我们在流中看到的一种变体 [从函数生成流]，来检查无限列表的有限前缀：

```py
fun ctake(n :: Number, il :: Pair) -> List:
  if n == 0:
    empty
  else:
    link(il.hd, ctake(n - 1, il!tl))
  end
end
```

使得：

```py
check:
  ctake(4, web-colors) is
  [list: "white", "grey", "white", "grey"]
end
```

### 20.2 递归函数 "链接到这里")

基于此，我们现在可以理解递归函数。考虑一个非常简单的例子，比如这个：

```py
fun sum(n):
  if n > 0:
    n + sum(n - 1)
  else:
    0
  end
end
```

我们可能希望认为这等同于：

```py
sum =
  lam(n):
    if n > 0:
      n + sum(n - 1)
    else:
      0
    end
  end
```

但如果你输入这个，Pyret 会抱怨 `sum` 没有绑定。我们必须改写为

```py
rec sum =
  lam(n):
    if n > 0:
      n + sum(n - 1)
    else:
      0
    end
  end
```

你认为`rec`做了什么？它将`sum`绑定到一个最初包含占位符值的盒子中；然后在绑定名称的环境中定义函数，解包名称的使用；最后，按照我们之前看到的`web-colors`的相同模式，用定义的函数替换盒子的内容。

### 20.3 提前评估 "链接至此")

注意，上面的描述揭示了在名称创建和对其赋值之间有一个时间差。这个中间状态可以被观察到吗？当然可以！

通常有三个解决方案来解决这个问题：

1.  确保值足够隐晦，以至于它永远不会在有意义的环境中使用。这意味着像 0 这样的值特别糟糕，实际上，大多数常见的数据类型都应该避免使用。确实，没有已经使用的值可以在这里使用，这可能在某些上下文中造成混淆。

1.  语言可能会为这里创建一种全新的值类型。例如，想象一下`CList`的定义如下：

    ```py
    data CList:
      | undef
      | clink(v, ref r)
    end
    ```

    `undef`看起来像是一个“基本情况”，这使得`CList`非常类似于`List`。然而，实际上，`undef`只存在于第一次突变之前，之后将不再存在：意图是`r`只包含对其他`clink`的引用。

    现在，`undef`值可以被语言用来检查循环列表的提前使用。然而，虽然这在技术上可行，但它会带来运行时惩罚。因此，这种检查通常只由专注于教学的编程语言执行；假设专业程序员能够自己管理这种提前使用的后果。

1.  允许递归构造函数仅在绑定函数的情况下使用，并确保绑定的右侧是语法上正确的函数。这种解决方案排除了某些合理的程序，但肯定是安全的。

### 20.4 循环列表与流 "链接至此")

如我们所提到的，上面的颜色列表示例非常类似于流示例。这两种定义无限数据的方式之间有什么关系呢？

循环列表在其一侧具有简单性。上面使用的定义模式实际上可以封装成语言构造，这样程序员就不需要与可变字段（如上所述）或延迟执行（如流所要求）进行斗争。然而，这种简单性是有代价的：循环列表只能表示严格重复的数据，即你不能将`nats`或`fibs`定义为循环列表。相比之下，流中的函数抽象使其具有生成性：每次调用都可以创建一个真正新颖的数据（例如下一个自然数或斐波那契数）。因此，将循环列表作为流实现是直接的，但反之则不然。
