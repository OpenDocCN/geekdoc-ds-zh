# 19 状态与等价 "链接到这里")

> 原文：[`dcic-world.org/2025-08-27/state-in-pyret.html`](https://dcic-world.org/2025-08-27/state-in-pyret.html)

|   19.1 盒子：一个规范的可变结构 |
| --- |
|   19.2 变异与类型 |
|   19.3 变异与等价 |
|   19.4 另一个等价谓词 |
|   19.5 等级体系 |
|   19.6 空间和时间复杂度 |
|   19.7 相同意味着什么 |
|   19.8 比较函数 |

在 变异结构 中，我们引入了可变数据的概念。我们还看到了它对测试的影响。测试的基础是某种等价性的概念：当我们使用 `is` 在 Pyret 中编写测试时，我们隐式地做出了关于两边的等价性声明。在这里，我们将更详细地研究存在状态时的等价性。

### 19.1 盒子：一个规范的可变结构 "链接到这里")

在 变异结构 中，我们看到了一个使用银行账户的激励示例。为了集中研究等价性，有一个更简单的可变数据结构可能很方便，称为盒子（你也会在其他编程语言中找到它）。盒子只有一个字段——被封装的值——并且支持仅三个操作：

1.  box 消耗一个值并创建一个包含该值的可变盒子。

1.  unbox-now 消耗一个盒子并返回盒子中的值。

1.  set-box-now 消耗一个盒子、一个新值，并将盒子更改为包含该值。该盒子的所有后续 unbox-now 操作现在将返回新值——除非它再次被变异。

这里是 Pyret 中相应的定义：

```py
data Box<T>:
  | box(ref v :: T)
end

fun unbox-now<T>(b :: Box<T>) -> T:
  b!v
end

fun set-box-now<T>(b :: Box<T>, new-v :: T) -> Box<T>:
  b!{v: new-v}
end
```

注意到我们使用 `b!v` 来提取当前值，并使用 `-now` 的命名约定来明确这些是状态操作，因此现在的值可能不等于以后的值。

### 19.2 变异与类型 "链接到这里")

在类型方面，无论何时我们在盒子中替换值，我们都希望它与之前的内容保持类型一致。否则，针对盒子编程将会非常困难，因为其内容的类型会不断变化。

这些定义遵循以下测试：

```py
check:
  n1 = box(1)
  n2 = box(2)
  set-box-now(n1, 3)
  set-box-now(n2, 4)
  unbox-now(n1) is 3
  unbox-now(n2) is 4
end
```

然而，我们不能写 `set-box-now(n1, "hi")`，因为这会违反 `n1` 的类型，它是 `Box<Number>`。我们可以通过以下方式使其明确：

```py
n1 :: Box<Number> = box(1)
```

如果我们想明确的话。然而，请注意，`n1` 是一个数字的盒子并不意味着我们不能有一个字符串的盒子：

```py
n3 :: Box<String> = box("hello")
```

或者确实是一个任何其他类型的盒子。我们只需要其类型保持一致，无论这个类型是什么。

这是我们希望遵循的可变数据的通用规则：新值必须与旧值相同类型。这为程序提供了一个一致的接口。例如，上面，我们知道我们可以始终对从`n1`提取的值执行数值操作——<wbr>没有突然产生字符串的危险。这种纪律可以通过注释系统强制执行，或者必须由程序员手动维护。

### 19.3 变异和等性 "链接至此")

我们已经看到 [重新审视等性]，等性是微妙的。随着变异的引入，它将变得更加微妙！

作为运行示例，我们将使用：

<three-boxes> ::=

| |   b1 = box(7) |
| --- | --- |
| |   b2 = box(7) |
| |   b3 = b1 |

注意`b1`和`b3`正在引用同一个盒子，而`b2`正在引用另一个盒子。我们可以从内存图中看到这一点：

目录

+   ```py
    b1
    ```

    → 1001

+   ```py
    b2
    ```

    → 1002

+   ```py
    b3
    ```

    → 1001

堆

+   1001: `box(7)`

+   1002: `box(7)`

我们可以使用以下测试来确认这一点：

```py
check:
  b1 is-not%(identical) b2
  b1 is%(identical) b3
  b2 is-not%(identical) b3
end
```

换句话说，`b1`和`b3`是同一盒子的别名，但它们都不是`b2`所引用的盒子的别名。由于`identical`是传递的，从前两个测试可以推断出第三个测试也必须通过（幸运的是，Pyret 为我们确认了这一点！）。

现在，你可能想知道为什么我们使用了`identical`而不是`equal-always` [等性表示法]，即普通的`is`。

> 现在行动！
> 
> > 让我们试试看：
> > 
> > ```py
> > check:
> >   b1 is b3
> >   b1 is b2
> > end
> > ```
> > 
> > 你看到了什么？

第一个测试`b1 is b3`通过并不令人惊讶。然而，第二个测试`b1 is b2`失败了！并且名称暗示了原因：这两个不是总是相等的保证。也就是说，如果我们修改由`b1`引用的盒子：

```py
set-box-now(b1, 8)
```

果然，盒子中的值并不相同，但由于`b1`和`b3`是别名，它们的值会同步变化（更准确地说，只有一个值——<wbr>位于 1001 的盒子）：

```py
check:
  unbox-now(b1) is-not unbox-now(b2)
  unbox-now(b1) is unbox-now(b3)
end
```

### 19.4 另一个相等谓词 "链接至此")

假设我们回到我们定义了三个盒子 [<three-boxes>] 但没有修改`b1`的状态。也就是说，当打印时，所有三个盒子都有相同的值，`box(7)`。我们已经看到`b1`和`b3`都是彼此的`equal-always`和`identical`。然而，我们也看到`b1`和`b2`都不是。这有点令人沮丧，因为显然在某些方面它们是“相等”的：在当前时刻，它们包含相同的值，即使后来其中一个可能不是。

因此，Pyret 提供了一个第三种等性谓词，专为这些情况设计：正如你可能猜到的，它被称为`equal-now`：

```py
check:
  b1 is%(equal-now) b2
  b2 is%(equal-now) b3
end
```

名称中的`-now`提醒我们，这些值在当前时刻是相等的，但以后可能不再相等。果然，如果我们添加

```py
set-box-now(b1, 8)
```

将值放回程序中，上述的`equal-now`测试失败了：现在，它们不再相等了！

回想一下，其他两个等价谓词有一个二进制运算符表示法：`==` 表示 `equal-always`，`<=>` 表示 `identical`。同样，`equal-now` 有二进制运算符 `=~`。你应该把它看作是 `=` 加上一个挥手的 `~`：它现在相等，但不要期望它保持这样。也就是说，我们可以将上述测试重写为：

```py
check:
  equal-now(b1, b2) is true
  (b2 =~ b3) is true
end
```

当然，它们是否通过取决于程序的状态：`b1`、`b2` 或 `b3` 的内容是否已被修改。

### 19.5 等价性层次 "链接至此")

如你所猜，等价运算符有一个蕴涵层次。也就是说，如果一个运算符对两个表达式为真，那么另一个必然为真，但反之则不然。

> 现在行动！
> 
> > 你能找出这个蕴涵层次吗？

注意，如果两个表达式是 `identical`，那么它们是别名，即它们指的是同一个值。因此，这些表达式产生的值必须是 `equal-always`。如果它们始终相等，那么显然在任何给定时刻，它们也必须是 `equal-now`。

即使两个表达式不是 `identical`，它们也可能是 `equal-always`。这对于可变数据来说永远不会是真的（因为存在未来突变的可能性），但对于具有相同结构和内容的不变数据来说可以是真的。在这种情况下，如果它们始终相等，那么它们也必须是 `equal-now`。

然而，逆命题并不成立。

如果两个数据是 `equal-now`，它们可能不是 `equal-always`：如果它们是可变的，未来的突变可能会改变等价性，就像我们上面看到的。同样，两个数据可能 `equal-always` 但不是 `identical`，因为它们位于不同的堆地址，因此是真正不同的数据。

在大多数语言中，通常有两个等价运算符，对应于`identical`（称为引用等价）和`equal-now`（称为结构等价）。Pyret 是少数有几个第三个运算符的语言之一，即 `equal-always`。对于大多数程序来说，这实际上是最有用的等价运算符：它不太关心别名细节，这些细节可能难以预测；同时，它做出的决策经得起时间的考验，从而为各种优化（可能甚至没有意识到它们的时态假设）提供了一个有用的基础。这就是为什么在测试中 `is` 默认使用 `equal-always`，并强制用户明确选择不同的原始运算符，如果他们想要的话。

### 19.6 空间和时间复杂度 "链接至此")

`identical` 总是花费常数时间。确实，一些程序使用 `identical` 正是因为它们想要常数时间的等价性，仔细地构建程序，使得应该被视为等价的价值是同一值的别名。当然，保持这种编程纪律是棘手的。

`equal-always`和`equal-now`都必须至少遍历数据的不变部分。因此，它们的时间与较小的数据量成比例（因为如果两个数据的大小不同，它们肯定不相等，所以没有必要访问额外的数据）。区别在于`equal-always`在引用时简化为`identical`，因此比`equal-now`执行的计算更少。

### 19.7 成为相同意味着什么 "链接至此")

回想一下我们刚刚定义的三个框的状态[<three-boxes>]。我们可以写出以下内容：

```py
hold-b1-value = unbox-now(b1)
set-box-now(b1, hold-b1-value + 1)
```

现在，我们可以比较各个框的内容：

```py
b1-id-b2 = unbox-now(b1) == unbox-now(b2)
b1-id-b3 = unbox-now(b1) == unbox-now(b3)
```

在执行比较之后，我们可以恢复它们：

```py
set-box-now(b1, hold-b1-value)
```

注意，`b1-id-b2`会是`false`，但`b1-id-b3`会是`true`。并且请注意，当两个表达式相同的时候，这始终是正确的，否则则不是。

因此，最终没有发生变化，但通过进行这种改变，我们可以检查哪些值是其他值的别名，哪些则不是。换句话说，这代表了`identical`的本质。

实际上，`identical`并不以这种方式表现：这会太具破坏性。当 Pyret 可以简单地检查内存地址是否相同时，它也不是最有效的实现方式。尽管如此，它确实展示了`identical`背后的基本思想：两个值是`identical`的，当且仅当你对一个值进行更改时，你会在“另一个”值上看到这些更改（即实际上只有一个值，但可能有多个名称）。

### 19.8 比较函数 "链接至此")

我们实际上并没有提供关于等价的全部真相，因为我们还没有讨论函数。定义函数的等价性——特别是外延等价性，即两个函数是否有相同的图，也就是说，对于每个输入产生相同的输出——由于停机问题，这是复杂（一种委婉的说法，即不可能）的。

由于这个原因，大多数语言都倾向于使用函数相等的近似值，最常见的是引用相等。然而，这却是一个非常弱的近似：即使相同的函数文本在相同的环境中分配为两个不同的闭包，它们也不会是引用相等的。至少当这是`identical`定义的一部分时，这样做是有意义的；然而，如果其他操作符这样做，它们就是在撒谎，而这通常不是等价操作符的行为。

我们还可以采取另一种方法：简单地禁止函数比较。这正是 Pyret 所做的事情：如果你尝试比较两个函数，上述所有三个等价操作符都会导致错误。（然而，你可以与一个函数进行比较，你将得到`false`的答案。）这确保了语言的比较操作符永远不会被错误地信任。

Pyret 确实可以选择允许在`identical`内部使用引用相等性，并在其他两种情况下报错。然而，如果它这样做，就会违反上述的推理链 [等价性层次]). 当前的设计可以说是更加优雅。想要在函数上使用引用相等的程序员可以简单地在一个可变结构（如框）内部嵌入函数。

比较两个函数时出错有一个问题：一个完全通用的比较两个任意值的程序可能会在给定的两个值都是函数时出错。因为这可能导致不可预测的程序失败，Pyret 为上述三个运算符（`identical3`、`equal-always3`和`equal-now3`）提供了三值版本，所有这些运算符都返回对应于真、假和未知（当两个参数都是函数时返回）的`EqualityResult`值。如果程序员不确定参数的类型，他们可以使用这些运算符来代替布尔值比较运算符。

### 19.1 框：一个规范的可变结构 "链接到此处")

在修改结构中，我们看到了一个使用银行账户的动机示例。为了集中研究等价性，有一个更简单的可变数据结构可能很有用，称为框（你将在其他编程语言中找到它）。框只有一个字段——<wbr>被装箱的值——<wbr>并支持以下三个操作：

1.  `box`消耗一个值并创建一个包含该值的可变框。

1.  `unbox-now`消耗一个框并返回框中包含的值。

1.  `set-box-now`消耗一个框、一个新值，并将框更改为包含该值。此后对该框的所有`unbox-now`操作现在将返回新值——<wbr>除非它再次被修改。

这里是 Pyret 中的相应定义：

```py
data Box<T>:
  | box(ref v :: T)
end

fun unbox-now<T>(b :: Box<T>) -> T:
  b!v
end

fun set-box-now<T>(b :: Box<T>, new-v :: T) -> Box<T>:
  b!{v: new-v}
end
```

注意我们使用`b!v`来提取当前值，并使用`-now`的命名约定来清楚地表明这些是状态操作，因此现在的值可能不等于以后的值。

### 19.2 修改和类型 "链接到此处")

在类型方面，每次我们在一个框中替换值时，我们都希望它与前一个值保持类型一致。否则，针对一个框进行编程将会非常困难，因为其内容的类型会不断变化。

这些定义遵循以下测试：

```py
check:
  n1 = box(1)
  n2 = box(2)
  set-box-now(n1, 3)
  set-box-now(n2, 4)
  unbox-now(n1) is 3
  unbox-now(n2) is 4
end
```

然而，我们不能编写`set-box-now(n1, "hi")`，因为这会违反`n1`的类型，其类型为`Box<Number>`。我们可以通过以下方式使其更明确：

```py
n1 :: Box<Number> = box(1)
```

如果我们想要明确的话。然而，请注意，`n1`是一个数字的框并不阻止我们有一个字符串的框：

```py
n3 :: Box<String> = box("hello")
```

或者确实是一个任何其他类型的框。我们只需要其类型保持一致，无论该类型是什么。

这是我们希望遵循的可变数据的一般规则：新值必须与旧值相同类型。这为程序提供了一个一致的接口来编程。例如，在上面，我们知道我们可以始终对从 `n1` 提取的值执行数值操作——没有危险它会突然产生一个字符串。这种纪律可以通过注释系统强制执行，或者必须由程序员手动维护。

### 19.3 突变和相等性 "链接到这里")

我们已经看到 [重新审视相等性]，相等性是微妙的。随着突变（mutation）的引入，它将变得更加微妙！

作为运行示例，我们将使用：

<three-boxes> ::=

| |   b1 = box(7) |
| --- | --- |
| |   b2 = box(7) |
| |   b3 = b1 |

注意到 `b1` 和 `b3` 指的是同一个盒子，而 `b2` 指的是另一个盒子。我们可以从内存图中看出这一点：

目录

+   ```py
    b1
    ```

    → 1001

+   ```py
    b2
    ```

    → 1002

+   ```py
    b3
    ```

    → 1001

堆

+   1001: `box(7)`

+   1002: `box(7)`

我们可以使用以下测试来确认这一点：

```py
check:
  b1 is-not%(identical) b2
  b1 is%(identical) b3
  b2 is-not%(identical) b3
end
```

换句话说，`b1` 和 `b3` 是同一盒子的别名，但它们都不是 `b2` 所指的盒子的别名。由于 `identical` 是传递的，从前两个测试可以推断出第三个测试也必须通过（幸运的是，Pyret 为我们确认了这一点！）

现在，你可能会想知道为什么我们使用了 `identical` 而不是 `equal-always` [相等性的表示法]，即普通的 `is`。

> 现在行动！
> 
> > 让我们试试这个：
> > 
> > ```py
> > check:
> >   b1 is b3
> >   b1 is b2
> > end
> > ```
> > 
> > 你看到了什么？

第一个测试，`b1 is b3` 通过，这并不令人惊讶。然而，第二个测试，`b1 is b2` 失败了！而且名字暗示了原因：这两个并不保证总是相等。也就是说，如果我们修改 `b1` 所指的盒子：

```py
set-box-now(b1, 8)
```

果然，盒子中的值并不相同，但由于 `b1` 和 `b3` 是别名，它们的值会同步变化（更准确地说，只有一个值——<wbr>1001 处的盒子）：

```py
check:
  unbox-now(b1) is-not unbox-now(b2)
  unbox-now(b1) is unbox-now(b3)
end
```

### 19.4 另一个相等谓词 "链接到这里")

假设我们回到我们定义了三个盒子 [<three-boxes>] 但没有突变 `b1` 的状态。也就是说，当打印时，所有三个盒子都有相同的值，`box(7)`。我们已经看到 `b1` 和 `b3` 都是彼此的 `equal-always` 和 `identical`。然而，我们也已经看到 `b1` 和 `b2` 都不是这些。这有点令人沮丧，因为显然在某些方面它们是“相等”的：在目前，它们包含相同的值，即使后来其中一个可能不是。

因此，Pyret 提供了第三个相等谓词，专为这些情况设计：正如你可能猜到的，它被称为 `equal-now`：

```py
check:
  b1 is%(equal-now) b2
  b2 is%(equal-now) b3
end
```

`-now` 在名称中提醒我们，这些值在目前是相等的，但以后可能不再相等。果不其然，如果我们添加

```py
set-box-now(b1, 8)
```

将上述 `equal-now` 测试放回程序中，现在它们失败了：现在它们不再相等了！

回想一下，其他两个等价谓词有一个二元运算符表示法：`==`表示“始终相等”和`<=>`表示“相同”。同样，“当前相等”有二元运算符`=~`。你应该将其视为带有挥手`~`的`=`：它现在相等，但不要期望它保持如此。也就是说，我们可以将上述测试重写为：

```py
check:
  equal-now(b1, b2) is true
  (b2 =~ b3) is true
end
```

当然，它们是否通过，取决于程序的状态：`b1`、`b2`或`b3`的内容是否已被修改。

### 19.5 等价性层次 "链接至此")

如你所猜，等价运算符有一个隐含的层次结构。也就是说，如果一个运算符对两个表达式成立，那么另一个运算符必然成立，但反之则不然。

> 现在行动起来！
> 
> > 你能找出这个隐含的层次结构吗？

注意，如果两个表达式是“相同”，那么它们是别名，即它们指向同一个值。因此，这些表达式产生的值必须是“始终相等”。如果它们始终相等，那么显然在任何给定时刻，它们也必须是“当前相等”。

即使两个表达式不是“相同”，它们也可能是“始终相等”。这在可变数据中永远不会成立（因为存在未来变异的可能性），但它可以成立在具有相同结构和内容的不可变数据中。在这种情况下，如果它们始终相等，那么它们再次必须是“当前相等”。

然而，逆命题并不成立。

如果两个数据是“当前相等”，它们可能不是“始终相等”：如果它们是可变的，未来的变异可能会改变等价性，就像我们上面看到的。同样，两个数据可能“始终相等”，但不是“相同”，因为它们位于不同的堆地址，因此确实是不同的数据。

在大多数语言中，通常有两个等价运算符，对应于`identical`（称为引用等价）和`equal-now`（称为结构等价）。Pyret 是罕见的，它有一个第三个运算符，`equal-always`。对于大多数程序来说，这实际上是最有用的等价运算符：它不太关心别名细节，这些细节难以预测；同时，它做出的决策经得起时间的考验，从而为各种优化提供了一个有用的基础（这些优化甚至可能没有意识到它们的时态假设）。这就是为什么在测试中使用`is`默认使用`equal-always`，并强制用户明确选择不同的原始运算符，如果他们想要的话。

### 19.6 空间和时间复杂度 "链接至此")

`identical`总是需要常数时间。事实上，一些程序使用`identical`正是因为它们想要常数时间的等价性，仔细地构建它们的程序，使得应该被视为相等的值是同一值的别名。当然，保持这种编程纪律是棘手的。

`equal-always` 和 `equal-now` 都必须至少遍历数据的不变部分。因此，它们所需的时间与较小的数据量成比例（因为如果两个数据的大小不同，它们肯定不相等，所以没有必要访问额外的数据）。区别在于 `equal-always` 在引用时会减少到 `identical`，因此比 `equal-now` 执行的计算更少。

### 19.7 什么意味着相同 "链接到此处")

回想一下我们刚刚定义的三个盒子 [<three-boxes>] 的状态。我们可以写出以下内容：

```py
hold-b1-value = unbox-now(b1)
set-box-now(b1, hold-b1-value + 1)
```

现在，我们可以比较各个盒子的内容：

```py
b1-id-b2 = unbox-now(b1) == unbox-now(b2)
b1-id-b3 = unbox-now(b1) == unbox-now(b3)
```

在执行比较之后，我们可以恢复它们：

```py
set-box-now(b1, hold-b1-value)
```

注意到 `b1-id-b2` 会是 `false`，但 `b1-id-b3` 会是 `true`。并且请注意，当两个表达式相同的时候，这始终是正确的，但如果不相同则不然。

因此，最终没有发生变化，但通过进行更改，我们可以检查哪些值是其他值的别名，哪些不是。换句话说，这代表了 `identical` 的本质。

在实践中，`identical` 并不这样表现：这会太具破坏性。它也不是可能的最有效实现，因为 Pyret 可以简单地检查内存地址是否相同。尽管如此，它确实展示了 `identical` 背后的基本思想：两个值在且仅在当你对一个值进行更改时，你会在“另一个”值上看到这些更改（即，实际上只有一个值，但可能有多个名称）。

### 19.8 比较函数 "链接到此处")

我们实际上并没有提供关于等价的完整真相，因为我们还没有讨论函数。定义函数的等价——特别是外延等价，即两个函数是否有相同的图，即对于每个输入产生相同的输出——由于停机问题而变得复杂（这是一个委婉的说法，即不可能）。

由于这个原因，大多数语言倾向于使用函数等价的近似值，最常见的是引用等价。然而，这却是一个非常弱的近似：即使在相同的环境中，相同的函数文本被分配为两个不同的闭包，这些闭包也不会是引用等价的。至少当这作为 `identical` 定义的一部分进行时，这是有意义的；然而，如果其他操作符这样做，它们就是在撒谎，而这通常不是等价操作符的行为。

我们还可以采取另一种方法：简单地禁止函数比较。这就是 Pyret 所做的：如果你尝试比较两个函数，上述所有三个等价操作符都会导致错误。（然而，你可以与一个函数进行比较，你将得到 `false` 的答案。）这确保了语言的比较操作符永远不会被错误地信任。

Pyret 确实可以选择在`identical`内部允许引用相等性，并在其他两种情况下报错。然而，如果它这样做，就会违反上述的推理链 [等价性层次)]. 当前的设计可以说是更加优雅。那些确实想要在函数上使用引用相等的程序员可以简单地将函数嵌入到一个可变结构，比如盒子中。

在比较两个函数时有一个问题：一个完全通用的比较两个任意值的程序可能会报错，如果给定的两个值都是函数的话。因为这种情况可能会引起不可预测的程序失败，Pyret 为上述三个操作符中的每一个都提供了一个三值版本（`identical3`、`equal-always3`和`equal-now3`），所有这些操作符都返回对应于真值、假值和未知（当两个参数都是函数时返回）的`EqualityResult`值。如果程序员不确定参数的类型，他们可以使用这些操作符来代替布尔值比较操作符。
