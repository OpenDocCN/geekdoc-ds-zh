# II 编程入门🔗

> 原文：[`dcic-world.org/2025-08-27/booklet_intro-to-programming.html`](https://dcic-world.org/2025-08-27/booklet_intro-to-programming.html)

|   3   基本数据 |
| --- |
|   3.1  开始学习 |
|   3.1.1  动机示例：旗帜 |
|   3.1.2  数字 |
|   3.1.3  表达式 |
|   3.1.4  术语 |
|   3.1.5  字符串 |
|   3.1.6  图像 |
|       3.1.6.1  合并图像 |
|       3.1.6.2  创建旗帜 |
|   3.1.7  回顾：类型、错误和文档 |
|       3.1.7.1  类型与合约 |
|       3.1.7.2  格式和符号错误 |
|       3.1.7.3  查找其他函数：文档 |
|   3.2  命名值 |
|   3.2.1  定义面板 |
|   3.2.2  命名值 |
|       3.2.2.1  名称与字符串 |
|       3.2.2.2  表达式与语句 |
|   3.2.3  程序目录 |
|       3.2.3.1  理解运行按钮 |
|   3.2.4  使用名称简化构建镜像 |
|   3.3  从重复表达式到函数 |
|   3.3.1  示例：类似旗帜 |
|   3.3.2  定义函数 |
|       3.3.2.1  函数如何评估 |
|       3.3.2.2  类型注解 |
|       3.3.2.3  文档 |
|   3.3.3  函数练习：月球重量 |
| |       3.3.4 使用示例文档化函数 |
| |       3.3.5 函数练习：钢笔的成本 |
| |       3.3.6 复习：定义函数 |
| |       3.4 条件语句和布尔值 |
| |       3.4.1 动机示例：运费 |
| |       3.4.2 条件语句：带有决策的计算 |
| |       3.4.3 布尔值 |
| |       3.4.3.1 其他布尔运算 |
| |       3.4.3.2 组合布尔值 |
| |       3.4.4 提出多个问题 |
| |       3.4.5 通过简化表达式进行评估 |
| |       3.4.6 组合函数 |
| |       3.4.6.1 函数组合的评估方式 |
| |       3.4.6.2 函数组合与目录 |
| |       3.4.7 嵌套条件语句 |
| |       3.4.8 复习：布尔值和条件语句 |
| |       4 表格数据 |
| |       4.1 表格数据简介 |
| |       4.1.1 创建表格数据 |
| |       4.1.2 提取行和单元格值 |
| |       4.1.3 行上的函数 |
| |       4.1.4 处理行 |
| |       4.1.4.1 查找行 |
| |       4.1.4.2 排序行 |
| |       4.1.4.3 添加新列 |
| |       4.1.4.4 计算新列值 |
| |       4.1.5 表格生成函数的示例 |
| |           4.1.6 Lambda: 匿名函数 |
| |           4.2 处理表格 |
| |           4.2.1 清理数据表 |
| |           4.2.1.1 加载数据表 |
| |           4.2.1.1.1 在 CPO 中从 Google Sheets 加载数据表 |
| |           4.2.1.1.2 在 VSCode 中从 CSV 文件加载数据表 |
| |           4.2.1.1.3 处理包含多种数据类型的列 |
| |           4.2.1.2 处理缺失条目 |
| |           4.2.1.3 数据标准化 |
| |           4.2.1.4 系统化标准化 |
| |         4.2.1.5 使用程序检测数据错误 |
| |           4.2.2 任务计划 |
| |           4.2.3 准备数据表 |
| |           4.2.3.1 创建数据区间 |
| |         4.2.3.2 分割列 |
| |           4.2.4 管理和命名数据表 |
| |           4.2.5 可视化和绘图 |
| |           4.2.6 摘要：管理数据分析 |
| |           5 列表 |
| |           5.1 从表格到列表 |
| |           5.1.1 基本统计问题 |
| |           5.1.2 从表格中提取列 |
| |           5.1.3 理解列表 |
| |           5.1.3.1 列表作为匿名数据 |
| |           5.1.3.2 创建字面量列表 |
| |           5.1.4 列表操作 |
| |           5.1.4.1 数字列表的内置操作 |
| |           5.1.4.2 列表的一般内置操作 |
| |         5.1.4.3 关于命名约定的旁白 |
| |         5.1.4.4 通过位置获取元素 |
| |         5.1.4.5 列表转换 |
| |         5.1.4.6 回顾：列表操作总结 |
| |       5.1.5 Lambda: 匿名函数 |
| |       5.1.6 合并列表和表格 |
| |     5.2 处理列表 |
| |       5.2.1 制作列表和拆分列表 |
| |       5.2.2 一些示例练习 |
| |       5.2.3 带标量答案的结构化问题 |
| |         5.2.3.1 `my-len`: 示例 |
| |         5.2.3.2 `my-sum`: 示例 |
| |         5.2.3.3 从示例到代码 |
| |       5.2.4 结构化问题转换列表 |
| |         5.2.4.1 `my-doubles`: 示例和代码 |
| |         5.2.4.2 `my-str-len`: 示例和代码 |
| |       5.2.5 从列表中选择的结构化问题 |
| |         5.2.5.1 `my-pos-nums`: 示例和代码 |
| |         5.2.5.2 `my-alternating`: 示例和代码 |
| |       5.2.6 轻松域上的结构化问题 |
| |         5.2.6.1 `my-max`: 示例 |
| |         5.2.6.2 `my-max`: 从示例到代码 |
| |       5.2.7 带标量答案的更多结构化问题 |
| |         5.2.7.1 `my-avg`: 示例 |
| |       5.2.8 带累加器的结构化问题 |
| |         5.2.8.1 `my-running-sum`: 第一次尝试 |
| |         5.2.8.2 `my-running-sum`: 示例和代码 |
| |         5.2.8.3 `my-alternating`: 示例和代码 |
| |         5.2.9 处理多个答案 |
| |         5.2.9.1 `uniq`: 问题设置 |
| |         5.2.9.2 `uniq`: 示例 |
| |         5.2.9.3 `uniq`: 代码 |
| |         5.2.9.4 `uniq`: 减少计算 |
| |         5.2.9.5 `uniq`: 示例和代码变体 |
| |         5.2.9.6 `uniq`: 为什么产生一个列表？ |
| |         5.2.10 单态列表和多态类型 |
| |         5.3 递归数据 |
| |         5.3.1 处理递归数据的函数 |
| |           5.3.2 处理递归数据的模板 |
| |           5.3.3 设计食谱 |
| |         6 结构化数据 |
| |         6.1 结构化数据简介 |
| |         6.1.1 理解复合数据类型 |
| |         6.1.1.1 对结构化数据的初步了解 |
| |         6.1.1.2 对条件数据的初步了解 |
| |           6.1.2 定义和创建结构化和条件数据 |
| |         6.1.2.1 定义和创建结构化数据 |
| |         6.1.2.2 结构化数据的注释 |
| |         6.1.2.3 定义和创建条件数据 |
| |           6.1.3 使用结构化和条件数据编程 |
| |           6.1.3.1 从结构化数据中提取字段 |
| |           6.1.3.2 区分条件数据的变体 |
| |           6.1.3.3 处理变体的字段 |
| |           6.2 结构化数据集合 |
| |           6.2.1 列作为集体数据 |
| |           6.2.2 集合作为集体数据 |
| |           6.2.2.1 从集合中选择元素 |
| |           6.2.2.2 使用集合进行计算 |
| |           6.2.3 结合结构化和集体数据 |
| |           6.2.4 数据设计问题：表示测验 |
| |           7 树 |
| |           7.1 树 |
| |           7.1.1 数据设计问题 – 家谱数据 |
| |           7.1.1.1 从家谱表中计算遗传父母 |
| |         7.1.1.2 从家谱表中计算祖父母 |
| |           7.1.1.3 为家谱树创建数据类型 |
| |           7.1.2 处理家谱树的程序 |
| |           7.1.3 总结如何处理树问题 |
| |           7.1.4 学习问题 |
| |           8 基础：额外材料 |
| |         8.1 函数作为数据 |
| |           8.1.1 一点微积分 |
| |           8.1.2 匿名函数的有用缩写 |
| |           8.1.3 从函数生成流 |
| |           8.1.4 结合力量：导数流 |
| |           8.2 从列表生成队列 |
| |           8.2.1 使用包装数据类型 |
| |           8.2.2 结合答案 |
| |           8.2.3 使用选择器 |
| |       8.2.4 使用元组 |
| |       8.2.5 选择器方法 |
| |     8.3 示例、测试和程序检查 |
| |       8.3.1 从示例到测试 |
| |       8.3.2 更精细的比较 |
| |       8.3.3 当测试失败 |
| |       8.3.4 测试的预言者 |
