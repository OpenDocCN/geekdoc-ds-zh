# 3.4 条件语句和布尔值

> 原文：[`dcic-world.org/2025-08-27/Conditionals_and_Booleans.html`](https://dcic-world.org/2025-08-27/Conditionals_and_Booleans.html)

| |   3.4.1 激励示例：运费 |
| --- | --- |
| |   3.4.2 条件语句：带有决策的计算 |
| |   3.4.3 布尔值 |
| |     3.4.3.1 其他布尔运算 |
| |     3.4.3.2 布尔值的组合 |
| |   3.4.4 提出多个问题 |
| |   3.4.5 通过简化表达式进行评估 |
| |   3.4.6 函数组合 |
| |     3.4.6.1 函数组合的评估方式 |
| |     3.4.6.2 函数组合和目录 |
| |   3.4.7 嵌套条件语句 |
| |   3.4.8 回顾：布尔值和条件语句 |

#### 3.4.1 激励示例：运费 "链接到此处")

在函数练习：钢笔成本中，我们编写了一个程序（`pen-cost`）来计算订购钢笔的成本。继续这个示例，我们现在想要考虑运费。我们将根据订单成本确定运费。

具体来说，我们将编写一个名为`add-shipping`的函数来计算包括运费在内的订单总成本。假设订单价值为 10 美元或以下，运费为 4 美元，而订单价值超过 10 美元的运费为 8 美元。像往常一样，我们将从编写`add-shipping`计算的示例开始。

> 现在行动！
> 
> > 使用`where`块中的`is`表示法编写几个`add-shipping`的示例。你如何在示例中选择输入？你是随机选择输入吗？以某种方式有策略地选择吗？如果是这样，你的策略是什么？

这里是`add-shipping`的示例集合。

```py
add-shipping(10) is 10 + 4
add-shipping(3.95) is 3.95 + 4
add-shipping(20) is 20 + 8
add-shipping(10.01) is 10.01 + 8
```

> 现在行动！
> 
> > 你注意到我们的示例了吗？你在我们的选择中观察到了哪些策略？

我们提出的示例包含几个战略决策：

+   包括`10`，这是基于文本的电荷边界

+   包括`10.01`，这略高于边界

+   包括自然数和实数（小数）

+   包括应该产生问题中提到的每个运费示例（`4`和`8`）

到目前为止，我们使用了一个简单的规则来从示例中创建函数体：找到正在变化的各个部分，用名称替换它们，然后将名称作为函数的参数。

> 现在行动！
> 
> > 在我们的`add-shipping`示例中，有什么在变化？与之前函数的示例相比，你注意到这些变化有什么不同之处吗？

在这个示例集中，有两点是新的：

+   `4` 和 `8` 的值在不同的示例中有所不同，但它们在每个示例中都出现多次。

+   `4` 和 `8` 的值仅出现在计算结果中——<wbr>不是作为输入。我们使用哪一个似乎取决于输入值。

这两个观察结果表明，`add-shipping` 发生了新的变化。特别是，我们有成群的示例，它们共享一个固定的值（运费），但不同的群（a）使用不同的值，并且（b）输入模式（输入值是否小于或等于 `10`）有规律。这需要我们能够在程序中询问有关输入的问题。

#### 3.4.2 条件：带有决策的计算 "链接到这里")

要就我们的输入提出问题，我们使用一种新的表达式类型，称为 if 表达式。以下是 `add-shipping` 的完整定义：

```py
fun add-shipping(order-amt :: Number) -> Number:
  doc: "add shipping costs to order total"
  if order-amt <= 10:
    order-amt + 4
  else:
    order-amt + 8
  end
where:
  add-shipping(10) is 10 + 4
  add-shipping(3.95) is 3.95 + 4
  add-shipping(20) is 20 + 8
  add-shipping(10.01) is 10.01 + 8
end
```

在 `if` 表达式中，我们提出一个问题，该问题可以产生一个答案，该答案可以是真或假（这里 `order-amt <= 10`，我们将在下面的 布尔值 中解释），提供一个表达式，当问题的答案是真时（`order-amt + 4`），另一个表达式，当结果为假时（`order-amt + 8`）。程序中的 `else` 标记了假情况下的答案；我们称之为 else 子句。我们还需要 `end` 来告诉 Pyret 我们已经完成了问题和答案。

#### 3.4.3 布尔值 "链接到这里")

Pyret 中的每个表达式都会评估为一个值。到目前为止，我们已经看到了三种类型的值：`Number`、`String` 和 `Image`。像 `order-amt <= 10` 这样的问题会产生什么类型的值？我们可以使用交互式提示符进行实验并找出答案。

> 现在就做！
> 
> > 在交互式提示符中输入以下每个表达式。你得到了什么类型的值？这些值符合我们迄今为止看到的类型吗？
> > 
> > ```py
> > 3.95 <= 10
> > 20 <= 10
> > ```

`true` 和 `false` 是 Pyret 中一种新类型 `Boolean` 的值。以 [乔治·布尔](https://en.wikipedia.org/wiki/George_Boole) 命名。虽然 `Number` 类型有无限多个值，但 `Boolean` 类型只有两个值：`true` 和 `false`。

> 练习
> 
> > 如果我们在交互式提示符中输入 `order-amt <= 10` 来探索布尔值，会发生什么？为什么会出现这种情况？

##### 3.4.3.1 其他布尔运算 "链接到这里")

有许多其他内置操作返回 `Boolean` 值。比较值以检查相等性是一个常见的操作：我们可以并且应该对相等性说更多，我们将在稍后进行 [重新审视相等性]。





> ```py
> 1 == 1
> ```







```py
true
```







> ```py
> 1 == 2
> ```







```py
false
```







> ```py
> "cat" == "dog"
> ```







```py
false
```







> ```py
> "cat" == "CAT"
> ```







```py
false
```



通常，`==` 检查两个值是否相等。注意这与在目录中将名称与值关联的单个 `=` 不同。

> ```py
> "a" < "b"
> ```

```py
true
```

> ```py
> "a" >= "c"
> ```

```py
false
```

> ```py
> "that" < "this"
> ```

```py
true
```

> ```py
> "alpha" < "beta"
> ```

```py
true
```

> ```py
> "a" >= "C"
> ```

```py
true
```

> ```py
> "a" >= "A"
> ```

```py
true
```

> ```py
> "a" == 1
> ```

```py
false
```

> ```py
> num-equal(1, 1)
> ```

```py
true
```

> ```py
> num-equal(1, 2)
> ```

```py
false
```

> ```py
> string-equal("a", "a")
> ```

```py
true
```

> ```py
> string-equal("a", "b")
> ```

```py
false
```

> > ```py
> > num-equal("a", 1)
> > string-equal("a", 1)
> > ```
> > 
> ```py
> wm = "will.i.am"
> ```
> 
> ```py
> string-contains(wm, "will")
> ```

```py
true
```

> ```py
> string-contains(wm, "Will")
> ```

```py
false
```

> ```py
> (1 < 2) and (2 < 3)
> ```

```py
true
```

> ```py
> (1 < 2) and (3 < 2)
> ```

```py
false
```

> ```py
> (1 < 2) or (2 < 3)
> ```

```py
true
```

> ```py
> (3 < 2) or (1 < 2)
> ```

```py
true
```

> ```py
> not(1 < 2)
> ```

```py
false
```

运费正在上升，因此我们想修改`add-shipping`程序以包括第三个运费级别：`10`到`30`之间的订单运费为`8`美元，但超过`30`美元的订单运费为`12`美元。这需要对我们程序进行两个修改：

+   我们必须能够提出另一个问题来区分运费为`8`和运费为`12`的情况。

+   当运费为`8`时的问题需要检查输入是否在两个值之间。

我们将按顺序处理这些问题。

当前`add-shipping`的主体只问一个问题：`order-amt <= 10`。我们需要为`order-amt <= 30`添加另一个问题，如果这个问题失败，则使用`12`的费用。我们应该把这个问题放在哪里？

使用`else if`的 if 表达式扩展版本允许你提出多个问题：

```py
fun add-shipping(order-amt :: Number) -> Number:
  doc: "add shipping costs to order total"
  if order-amt <= 10:
    order-amt + 4
  else if order-amt <= 30:
    order-amt + 8
  else:
    order-amt + 12
  end
where:
  ...
end
```

在这一点上，你也应该添加使用`12`费用的`where`示例。

Pyret 是如何确定返回哪个答案的？它按顺序评估每个问题表达式，从紧随`if`之后的问题开始。它继续通过问题，返回第一个返回 true 的答案的值。以下是对 if 表达式语法及其评估的总结。

```py
if QUESTION1:
  <result in case first question true>
else if QUESTION2:
  <result in case QUESTION1 false and QUESTION2 true>
else:
  <result in case both QUESTIONs false>
end
```

一个程序可以有多个`else if`情况，从而在程序中容纳任意数量的问题。

> 现在行动！
> 
> > `add-shipping`的问题描述指出，`10`到`30`之间的订单应收取`8`的费用。上述代码是如何捕捉“在...之间”的？

目前这完全是隐含的。它取决于我们理解`if`的评估方式。第一个问题是`order-amt <= 10`，所以如果我们继续到第二个问题，这意味着`order-amt > 10`。在这个上下文中，第二个问题询问`order-amt <= 30`。这就是我们捕捉“在...之间”的方式。

> 现在行动！
> 
> > 你如何修改上述代码，将“在 10 到 30 之间”的要求明确地构建到`8`情况的问题中？

记得布尔值上的`and`运算符吗？我们可以使用它来捕捉“在...之间”的关系，如下所示：

```py
(order-amt > 10) and (order-amt <= 30)
```

> 现在行动！
> 
> > 为什么两个比较周围有括号？如果你用具体的值（例如`20`）替换`order-amt`并去掉括号，当你在这个交互面板中评估这个表达式时会发生什么？

下面是包含`and`运算符的`add-shipping`的样子：

```py
fun add-shipping(order-amt :: Number) -> Number:
  doc: "add shipping costs to order total"
  if order-amt <= 10:
    order-amt + 4
  else if (order-amt > 10) and (order-amt <= 30):
    order-amt + 8
  else:
    order-amt + 12
  end
where:
  add-shipping(10) is 10 + 4
  add-shipping(3.95) is 3.95 + 4
  add-shipping(20) is 20 + 8
  add-shipping(10.01) is 10.01 + 8
  add-shipping(30) is 30 + 8
  add-shipping(32) is 32 + 12
end
```

两个版本的`add-shipping`支持相同的示例。两者都正确吗？是的。虽然第二个问题的前部分（`order-amt > 10`）是多余的，但包含这样的条件可能有以下三个原因：

1.  它们向未来的读者（包括我们自己！）表明覆盖某个情况的条件。

1.  它们确保如果我们写错了早期的问题，我们不会默默地得到意外的输出。

1.  它们防止未来的修改，如果有人修改了早期的问题而没有意识到它对后期问题的影响。

> 练习
> 
> > 一家在线广告公司需要确定是否向网站用户展示滑板公园的广告。编写一个名为`show-ad`的函数，该函数接受一个用户的年龄和发色，如果用户年龄在`9`到`18`岁之间并且有粉色或紫色头发，则返回`true`。
> > 
> > 尝试用两种方式来写这个：一次使用 if 表达式，一次只使用布尔运算。
> > 
> 负责任计算：将人简化为简单数据带来的危害
> 
> > 关于用户的假设甚至编码在最简单的函数中。广告练习展示了这样一个例子，即基于一个人的两条信息做出决策：年龄和发色。虽然有些人可能会刻板地将滑板者与年轻和有彩色头发联系起来，但许多滑板者并不符合这些标准，而许多符合这些标准的人并不滑板。
> > 
> > 虽然将广告与用户匹配的真正程序比这个简单函数更复杂，但即使是最高级的广告程序也归结为跟踪个人特征或信息，并将其与广告内容的信息进行比较。一个真实的广告系统会在跟踪数十个（或更多）特征和使用比简单条件更先进的编程思想来确定广告的适宜性方面有所不同（我们将在本书后面讨论一些这些内容）。这个例子也扩展到比广告更严重的情境：谁被雇佣、获得银行贷款，或[被送进或释放出监狱](https://www.propublica.org/article/machine-bias-risk-assessments-in-criminal-sentencing)都是依赖于将个人数据与程序维护的标准进行比较的真实系统的例子。
> > 
> > 从社会责任的角度来看，这里的问题是关于个人数据应该使用哪些数据来代表他们以供程序处理，以及这些数据可能编码了哪些刻板印象。在某些情况下，个人可以通过数据来表示而不会造成伤害（例如，大学宿舍办公室存储学生的学号和居住的房间号）。但在其他情况下，个人数据会被解释以预测关于他们的某些信息。基于这些预测所做的决策可能是不准确的，因此是有害的。

#### 3.4.5 通过减少表达式进行评估 "链接至此")

在函数评估方式中，我们讨论了 Pyret 如何将表达式和函数调用减少到值。现在让我们回顾这个过程，这次扩展到考虑 if 表达式。假设我们想要计算一个工人的工资。工人每小时工资为 10 美元，直到第一个 40 小时，之后每小时工资为 15 美元。假设`hours`包含他们工作的小时数，并且假设它是`45`：

```py
hours = 45
```

假设计算工资的公式是

```py
if hours <= 40:
  hours * 10
else if hours > 40:
  (40 * 10) + ((hours - 40) * 15)
end
```

现在我们来看一下这是如何得到答案的，使用一个逐步的过程，这个过程应该与您在代数课上看到的过程相匹配（步骤在右侧的边注中描述）：第一步是将 `hours` 替换为 `45`。

```py
if 45 <= 40:
  45 * 10
else if 45 > 40:
  (40 * 10) + ((45 - 40) * 15)
end
```

接下来，评估 `if` 表达式的条件部分，在这种情况下是 `false`。

```py
=>  if false:
      45 * 10
    else if 45 > 40:
      (40 * 10) + ((45 - 40) * 15)
    end
```

由于条件是 `false`，尝试下一个分支。

```py
=>  if 45 > 40:
      (40 * 10) + ((45 - 40) * 15)
    end
```

Pyret 评估条件中的问题，在这种情况下产生 `true`。

```py
=>  if true:
      (40 * 10) + ((45 - 40) * 15)
    end
```

由于条件是 `true`，表达式简化为该分支的主体。之后，只是算术运算。

```py
=>  (40 * 10) + ((45 - 40) * 15)
```

```py
=>  400 + (5 * 15)
=>  475
```

这种简化的方式是思考 Pyret 表达式评估的最佳方式。整个表达式通过简化步骤进行，按照简单规则进行。如果您想尝试手动（或在大脑中）通过评估 Pyret 程序，可以使用这种方式。

#### 3.4.6 函数组合 "链接到这里")

我们开始这一章时想要计算笔订单的运费。到目前为止，我们已经编写了两个函数：

+   `pen-cost` 用于计算笔的成本

+   `add-shipping` 用于向总金额添加运费

如果我们现在想要计算包含运费的笔订单价格呢？我们需要同时使用这两个函数，将 `pen-cost` 的输出传递给 `add-shipping` 的输入

> 现在行动起来！
> 
> > 编写一个表达式来计算包含运费的 10 支写有 `"bravo"` 的笔的订单总成本

有两种方式来构建这个计算。我们可以直接将 `pen-cost` 的结果传递给 `add-shipping`：

```py
add-shipping(pen-cost(10, "bravo"))
```

或者，您可能将 `pen-cost` 的结果命名为一个中间步骤：

```py
pens = pen-cost(10, "bravo")
add-shipping(pens)
```

这两种方法都会产生相同的答案。

##### 3.4.6.1 如何评估函数组合 "链接到这里")

让我们回顾一下这些程序在替换和目录的上下文中的评估方式。我们将从第二个版本开始，在这个版本中我们明确命名了调用 `pen-cost` 的结果。

评估第二个版本：从高层次来看，Pyret 会执行以下步骤：

+   在 `pen-cost` 的主体中将 `10` 替换为 `num-pens`，将 `"bravo"` 替换为 `message`，然后评估替换后的主体

+   将 `pens` 存储在目录中，值为 `3.5`

+   在评估 `add-shipping(pens)` 的第一步中，在目录中查找 `pens` 的值

+   在 `add-shipping` 的主体中将 `3.5` 替换为 `order-amt`，然后评估得到的结果，结果是 `7.5`

评估第一个版本：作为提醒，第一个版本由一个单独的表达式组成：

```py
add-shipping(pen-cost(10, "bravo"))
```

+   由于参数在函数被调用之前被评估，因此首先评估 `pen-cost(10, "bravo")`（再次使用替换），这简化为 `3.5`

+   在 `add-shipping` 的主体中将 `3.5` 替换为 `order-amt`，然后评估得到的结果，结果是 `7.5`

> 现在行动起来！
> 
> > 对比这两个摘要。它们在哪里不同？哪些代码方面的差异导致了这些差异？

差异在于目录的使用：显式命名`pens`的版本使用了目录。另一个版本根本未使用目录。然而，两种方法都得到了相同的结果，因为相同的值（调用`pen-cost`的结果）被替换到`add-shipping`的主体中。

这种分析可能表明，使用目录的版本在某种程度上是浪费的：它似乎只是多走几步就得到了相同的结果。然而，有人可能会争辩说，使用目录的版本更容易阅读（不同的读者会有不同的看法，这是可以的）。那么我们应该使用哪一个？

在给定的问题上，使用您认为更有意义的那个。有时我们会更喜欢这些风格中的每一个。此外，一旦我们了解了程序评估的细微差别，我们会发现这两个版本并不像现在看起来那样不同。

##### 3.4.6.2 函数组合和目录 "链接至此")

让我们尝试对这个问题的另一个变体。也许我们看到我们命名`pen-cost`的中间结果让您希望我们使用中间名称来使`pen-cost`的主体更易于阅读。例如，我们可以这样写：

```py
fun pen-cost(num-pens :: Number, message :: String)
  -> Number:
  doc: ```每支笔的总成本，每支 25 美分

    每条消息字符加 2 美分```py
  message-cost = (string-length(message) * 0.02)
  num-pens * (0.25 + message-cost)
where:
  ...
end
```

> 现在就做！
> 
> > 用高级步骤写出 Pyret 将如何使用这个新版本的`pen-cost`评估以下程序：
> > 
> > ```py
> > pens = pen-cost(10, "bravo")
> > add-shipping(pens)
> > ```

希望您已经在目录中做了两个条目，一个是在`pen-cost`的主体中的`message-cost`，另一个是我们之前提到的`pens`。

> 现在就做！
> 
> > 考虑以下程序。您认为 Pyret 应该产生什么结果？
> > 
> > ```py
> > pens = pen-cost(10, "bravo")
> > cheap-message = (message-cost > 0.5)
> > add-shipping(pens)
> > ```
> > 
> > 使用您为上一个活动构思的目录，您认为您会得到什么答案？

这里发生了一些奇怪的事情。新程序试图使用`message-cost`来定义`cheap-message`。但名称`message-cost`在程序中任何地方都没有出现，除非我们查看函数体内部。但是让代码查看函数体内部是没有意义的：您可能看不到函数内部（如果它们在库中定义，例如），因此这个程序应该报告一个错误，即`message-cost`未定义。

好的，所以这就是应该发生的事情。但是，我们对目录的讨论表明，`pens`和`message-cost`都将包含在目录中，这意味着 Pyret 能够使用`message-cost`。发生了什么？

这个例子促使我们解释关于目录的一个更细微的问题。确切地说，为了避免这里展示的问题（应该产生错误），在函数内部创建的目录条目是局部（私有的）于函数体的。当你调用一个函数时，Pyret 会设置一个局部目录，其他函数无法看到。函数体可以在其局部、私有目录（如`message-cost`）或整体（全局）目录（如`pens`）中添加或引用名称。但在任何情况下，一个函数都不能窥视另一个函数调用的局部目录。一旦函数调用完成，其局部目录就会消失（因为无论如何，其他东西也无法使用它）。 

#### 3.4.7 嵌套条件 "链接到此处")

我们展示了`if`表达式中的结果是表达式本身（如下面函数中的`order-amt + 4`）。

```py
fun add-shipping(order-amt :: Number) -> Number:
  doc: "add shipping costs to order total"
  if order-amt <= 10:
    order-amt + 4
  else:
    order-amt + 8
  end
end
```

结果表达式可能更复杂。事实上，它们可以是完整的`if`表达式！为了看一个例子，让我们开发另一个函数。这次，我们想要一个计算电影票价的函数。让我们从一个简单的版本开始，其中票价为每张$10。

```py
fun buy-tickets1(count :: Number) -> Number:
  doc: "Compute the price of tickets at $10 each"
  count * 10
where:
  buy-tickets1(0) is 0
  buy-tickets1(2) is 2 * 10
  buy-tickets1(6) is 6 * 10
end
```

现在，让我们给函数添加一个额外的参数，以指示购买者是否是享有折扣权的老年人。在这种情况下，我们将整体价格降低 15%。

```py
fun buy-tickets2(count :: Number, is-senior :: Boolean)
  -> Number:
  doc: ```使用$10 每张的价格计算票价

    15%的老年人折扣```py
  if is-senior == true:
    count * 10 * 0.85
  else:
    count * 10
  end
where:
  buy-tickets2(0, false) is 0
  buy-tickets2(0, true) is 0
  buy-tickets2(2, false) is 2 * 10
  buy-tickets2(2, true) is 2 * 10 * 0.85
  buy-tickets2(6, false) is 6 * 10
  buy-tickets2(6, true) is 6 * 10 * 0.85
end
```

这里有几个需要注意的地方：

+   函数现在有一个额外的`Boolean`类型参数，用于指示购买者是否是老年人。

+   我们添加了一个`if`表达式来检查是否应用折扣。

+   我们有更多的例子，因为我们必须同时改变票数和是否适用折扣。

现在，让我们再次扩展程序，这次如果购买者不是老年人但购买了超过 5 张票，也会提供折扣。我们应该在哪里修改代码来实现这一点？一个选项是首先检查是否适用老年人折扣。如果不适用，我们检查票数是否符合折扣条件：

```py
fun buy-tickets3(count :: Number, is-senior :: Boolean)
  -> Number:
  doc: ```使用$10 每张的价格计算票价

    购买超过 5 张票的 15%折扣

    或者成为高级```py
  if is-senior == true:
    count * 10 * 0.85
  else:
    if count > 5:
      count * 10 * 0.85
    else:
      count * 10
    end
  end
where:
  buy-tickets3(0, false) is 0
  buy-tickets3(0, true) is 0
  buy-tickets3(2, false) is 2 * 10
  buy-tickets3(2, true) is 2 * 10 * 0.85
  buy-tickets3(6, false) is 6 * 10 * 0.85
  buy-tickets3(6, true) is 6 * 10 * 0.85
end
```

注意这里，我们在`else`情况下又放入了一个`if`表达式。这是有效的代码。（我们也可以在这里使用`else if`，但我们没有这样做，以便展示嵌套条件也是有效的）。

> 练习
> 
> > 展示这个函数在没有折扣适用的情况下的评估步骤，例如`buy-tickets3(2, false)`。
> > 
> 现在就做！
> 
> > 看看当前的代码：你是否看到了可能需要稍后修改的重复计算？

良好的代码风格的一部分是确保我们的程序在以后更容易维护。例如，如果剧院更改了折扣政策，当前的代码将需要我们在两个地方更改折扣（`0.85`）。最好是将这个计算只写一次。我们可以通过询问哪些条件会导致折扣适用，并将它们作为单个`if`表达式中的检查来实现这一点。

> 现在就做！
> 
> > 在什么条件下应该应用折扣？

在这里，我们可以看到如果购买者是一位老年人或者购买了 5 张以上的票，则可以享受折扣。因此，我们可以通过使用`or`来简化代码，如下所示（我们省略了示例，因为它们与上一个版本没有变化）：

```py
fun buy-tickets4(count :: Number, is-senior :: Boolean)
  -> Number:
  doc: ```计算每张票 10 美元的票价

    5 张以上票享受 15%的折扣

    或者是老年人```py
  if (is-senior == true) or (count > 5):
    count * 10 * 0.85
  else:
    count * 10
  end
end
```

这段代码更加紧凑，所有适用折扣的情况都集中在一个地方描述。尽管如此，我们还想进行两项小的修改来真正清理代码。

> 现在就做！
> 
> > 看一下表达式`is-senior == true`。当`is-senior`的值为`true`时，这将评估为什么？当`is-senior`的值为`false`时，这将评估为什么？

注意到`== true`部分是多余的。由于`is-senior`已经是布尔值，我们可以检查其值而不使用`==`运算符。以下是修改后的代码：

```py
fun buy-tickets5(count :: Number, is-senior :: Boolean)
  -> Number:
  doc: ```计算每张票 10 美元的票价

    5 张以上票享受 15%的折扣

    或者是老年人```py
  if is-senior or (count > 5):
    count * 10 * 0.85
  else:
    count * 10
  end
end
```

注意`if`表达式中的修改后的问题。一般来说，你的代码不应该包含`== true`。你可以总是去掉它，只使用你比较的表达式。

> 现在就做！
> 
> > 你如何编写代码来消除`== false`？例如，你可能会用什么来代替`is-senior == false`？

最后，请注意我们仍然有一个重复的计算：票的基础成本（`count * 10`）：如果票价发生变化，最好只有一个地方可以更新这个价格。我们可以通过首先计算基础价格，然后在适当的时候应用折扣来清理它：

```py
fun buy-tickets6(count :: Number, is-senior :: Boolean)
  -> Number:
  doc: ```计算每张票 10 美元的票价

    5 张以上票享受 15%的折扣

    或者是老年人```py
  base = count * 10
  if is-senior or (count > 5):
    base * 0.85
  else:
    base
  end
end
```

#### 3.4.8 回顾：布尔值和条件语句 "链接到此处")

通过本章，我们的计算可以在不同情况下产生不同的结果。我们使用 if 表达式来提问，其中每个问题或检查都使用产生布尔值的运算符。

+   有两个布尔值：`true`和`false`。

+   简单的检查（产生布尔值）比较值是否相等（`==`）或不等（`<>`）。其他你从数学中知道的运算，如`<`和`>=`，也会产生布尔值。

+   我们可以使用`and`、`or`和`not`运算符构建更大的表达式，这些表达式从较小的表达式生成布尔值。

+   我们可以使用 `if` 表达式在计算中提出真/假问题，并在每种情况下产生不同的结果。

+   如果需要，我们可以嵌套条件。

+   你永远不需要使用 `==` 来比较一个值与 `true` 或 `false`：你只需写下值或表达式本身（可能还需要 `not` 来得到相同的计算）。

#### 3.4.1 动机示例：运费 "链接到这里")

在 函数练习：钢笔成本，我们编写了一个程序（`pen-cost`）来计算订购钢笔的成本。继续这个例子，我们现在想要考虑运费。我们将根据订单成本确定运费。

特别是，我们将编写一个 `add-shipping` 函数来计算包括运费在内的订单总成本。假设价值 $10 或以下的订单运费为 $4，而价值超过 $10 的订单运费为 $8。像往常一样，我们将从编写 `add-shipping` 计算的示例开始。

> 立刻行动！
> 
> > 使用 `where` 块中的 `is` 表示法编写几个 `add-shipping` 的示例。你如何在你的示例中选择输入？你是随机选择输入吗？以某种方式有策略吗？如果是这样，你的策略是什么？

这里是 `add-shipping` 的一个建议示例集合。

```py
add-shipping(10) is 10 + 4
add-shipping(3.95) is 3.95 + 4
add-shipping(20) is 20 + 8
add-shipping(10.01) is 10.01 + 8
```

> 立刻行动！
> 
> > 你注意到我们的示例有什么？你在我们的选择中观察到哪些策略？

我们提出的示例包含几个战略决策：

+   包括 `10`，这是基于文本的电荷边界

+   包括 `10.01`，这刚刚超过边界

+   包括自然数和实数（小数）

+   包括问题中提到的每个运费示例的结果（`4` 和 `8`）

到目前为止，我们使用了一个简单的规则从示例中创建函数体：定位变化的部分，用名称替换它们，然后将这些名称作为函数的参数。

> 立刻行动！
> 
> > 在我们的 `add-shipping` 示例中，有什么在变化？你注意到这些变化与之前函数的示例有什么不同吗？

在这个示例集中有两个新事物：

+   `4` 和 `8` 的值在示例中不同，但它们在每个示例中都出现多次。

+   `4` 和 `8` 的值只出现在计算出的答案中——<wbr>不是作为输入。我们使用哪一个似乎取决于输入值。

这两个观察结果表明，`add-shipping` 中发生了一些新的事情。特别是，我们有共享固定值（运费）的示例集群，但不同的集群（a）使用不同的值，并且（b）输入（输入值是否小于或等于 `10`）有模式。这需要我们能够在程序中询问有关输入的问题。

#### 3.4.2 条件：带有决策的计算 "链接到这里")

为了询问关于我们输入的问题，我们使用一种新的表达式类型，称为 `if` 表达式。以下是 `add-shipping` 的完整定义：

```py
fun add-shipping(order-amt :: Number) -> Number:
  doc: "add shipping costs to order total"
  if order-amt <= 10:
    order-amt + 4
  else:
    order-amt + 8
  end
where:
  add-shipping(10) is 10 + 4
  add-shipping(3.95) is 3.95 + 4
  add-shipping(20) is 20 + 8
  add-shipping(10.01) is 10.01 + 8
end
```

在一个 `if` 表达式中，我们提出一个问题，这个问题可以产生一个真或假的答案（这里 `order-amt <= 10`，我们将在下面的 布尔值 中解释），提供一个当问题的答案是真时的表达式（`order-amt + 4`），以及当结果为假时的另一个表达式（`order-amt + 8`）。程序中的 `else` 标记了假情况下的答案；我们称之为 `else` 子句。我们还需要 `end` 来告诉 Pyret 我们已经完成了问题和答案。

#### 3.4.3 布尔值 "链接到这里")

在 Pyret 中，每个表达式都会评估为一个值。到目前为止，我们已经看到了三种类型的值：`Number`、`String` 和 `Image`。像 `order-amt <= 10` 这样的问题会产生什么类型的值？我们可以使用交互式提示符进行实验并找出答案。

> 现在行动！
> 
> > 在交互式提示符中输入以下每个表达式。你得到了什么类型的值？这些值是否符合我们迄今为止看到的类型？
> > 
> > ```py
> > 3.95 <= 10
> > 20 <= 10
> > ```

值 `true` 和 `false` 属于 Pyret 中的新类型，称为 `Boolean`。以 [乔治·布尔](https://en.wikipedia.org/wiki/George_Boole) 命名。虽然 `Number` 类型有无限多个值，但 `Boolean` 类型只有两个：`true` 和 `false`。

> 练习
> 
> > 如果我们在交互式提示符中输入 `order-amt <= 10` 来探索布尔值，会发生什么？为什么会出现这种情况？

##### 3.4.3.1 其他布尔运算 "链接到这里")

有许多其他内置操作返回 `Boolean` 值。比较值以检查相等性是一个常见的操作：关于相等性，我们有很多可以和应该说的内容，我们将在以后讨论 [重新审视相等性]。





> ```py
> 1 == 1
> ```







```py
true
```







> ```py
> 1 == 2
> ```







```py
false
```







> ```py
> "cat" == "dog"
> ```







```py
false
```







> ```py
> "cat" == "CAT"
> ```







```py
false
```



通常，`==` 检查两个值是否相等。注意这与在目录中用单个 `=` 将名称与值关联起来的用法不同。

最后一个例子是最有趣的：它说明了字符串是区分大小写的，这意味着单个字母的大小写必须匹配，字符串才能被认为是相等的。当我们后面讨论表格时，这一点将变得相关。

有时，我们还想比较字符串以确定它们的字母顺序。以下是一些示例：





> ```py
> "a" < "b"
> ```







```py
true
```







> ```py
> "a" >= "c"
> ```







```py
false
```







> ```py
> "that" < "this"
> ```







```py
true
```







> ```py
> "alpha" < "beta"
> ```







```py
true
```



这是我们所熟悉的字母顺序；但其他一些需要解释：





> ```py
> "a" >= "C"
> ```







```py
true
```







> ```py
> "a" >= "A"
> ```







```py
true
```



这些使用的是很久以前在一种名为 [ASCII](https://en.wikipedia.org/wiki/ASCII) 的系统中制定的传统。对于非 ASCII 字母来说，事情要复杂得多：例如，Pyret 认为 `"Ł"` 比 `"Z"` 更大，但在波兰语中，这应该是 `false`。更糟糕的是，排序 [取决于位置](https://en.wikipedia.org/wiki/Alphabetical_order)（例如，丹麦/挪威与芬兰/瑞典）。

> Do Now!
> 
> > 你能比较 `true` 和 `false` 吗？尝试比较它们的相等性（`==`），然后比较不等性（如 `<`）。

通常，你可以比较任何两个值以检查它们是否相等（几乎是这样，我们稍后会回到这个问题）；例如：





> ```py
> "a" == 1
> ```







```py
false
```



如果你想要比较特定类型的数据值，你可以使用更具体的运算符：





> ```py
> num-equal(1, 1)
> ```







```py
true
```







> ```py
> num-equal(1, 2)
> ```







```py
false
```







> ```py
> string-equal("a", "a")
> ```







```py
true
```







> ```py
> string-equal("a", "b")
> ```







```py
false
```



为什么使用这些运算符而不是更通用的 `==`？

> Do Now!
> 
> > 尝试
> > 
> > ```py
> > num-equal("a", 1)
> > string-equal("a", 1)
> > ```

因此，在期望两个参数具有相同类型的地方使用特定类型的运算符是明智的。然后，如果出错，Pyret 将会发出错误信号，而不是盲目地返回一个答案（`false`），这会让你的程序继续计算一个无意义的值。

甚至还有更多产生布尔值的运算符，例如：



> ```py
> wm = "will.i.am"
> ```







> ```py
> string-contains(wm, "will")
> ```







```py
true
```



注意大写 `W`。





> ```py
> string-contains(wm, "Will")
> ```







```py
false
```



实际上，几乎每种类型的数据都将有一些布尔值运算符来启用比较。

##### 3.4.3.2 布尔值的组合 "链接到这里")

通常，我们希望基于多个布尔值来做出决定。例如，如果你是某个国家的公民并且年龄超过一定限制，你就有权投票。如果你有车票或者公交车有免费乘坐日，你就有权乘坐公交车。我们甚至可以组合条件：如果你年龄超过一定限制，有良好的视力，并且通过测试或持有临时驾照，你就有权驾驶。此外，如果你没有醉酒，你也有权驾驶。

相应于这些组合形式，Pyret 提供了三种主要操作：`and`、`or` 和 `not`。以下是一些它们使用的例子：





> ```py
> (1 < 2) and (2 < 3)
> ```







```py
true
```







> ```py
> (1 < 2) and (3 < 2)
> ```







```py
false
```







> ```py
> (1 < 2) or (2 < 3)
> ```







```py
true
```







> ```py
> (3 < 2) or (1 < 2)
> ```







```py
true
```







> ```py
> not(1 < 2)
> ```







```py
false
```



> 练习
> 
> > 解释为什么数字和字符串不是表达真/假问题答案的好方法。

##### 3.4.3.1 其他布尔运算 "链接到这里")

有许多其他内置操作会返回 `Boolean` 值。比较值以检查相等性是一个常见的例子：我们还可以说很多关于相等性的内容，我们将在以后讨论 [重新审视相等性]。





> ```py
> 1 == 1
> ```







```py
true
```







> ```py
> 1 == 2
> ```







```py
false
```







> ```py
> "cat" == "dog"
> ```







```py
false
```







> ```py
> "cat" == "CAT"
> ```







```py
false
```



通常，`==` 检查两个值是否相等。注意这与在目录中将名称与值关联的单个 `=` 不同。

最后一个例子是最有趣的：它说明了字符串是区分大小写的，这意味着单个字母的大小写必须匹配，字符串才能被认为是相等的。当我们稍后讨论表格时，这一点将变得相关。

有时，我们还想比较字符串以确定它们的字母顺序。以下是一些例子：





> ```py
> "a" < "b"
> ```







```py
true
```







> ```py
> "a" >= "c"
> ```







```py
false
```







> ```py
> "that" < "this"
> ```







```py
true
```







> ```py
> "alpha" < "beta"
> ```







```py
true
```



这是我们熟悉的字母顺序；但其他一些需要解释：





> ```py
> "a" >= "C"
> ```







```py
true
```







> ```py
> "a" >= "A"
> ```







```py
true
```



这些使用的是在很久以前一个名为 [ASCII](https://en.wikipedia.org/wiki/ASCII) 的系统中制定的约定。与非 ASCII 字母相比，事情变得更加复杂：例如，Pyret 认为 `"Ł"` 比 `"Z"` 大，但在波兰语中，这应该是 `false`。更糟糕的是，排序 [取决于位置](https://en.wikipedia.org/wiki/Alphabetical_order)（例如，丹麦/挪威与芬兰/瑞典）。

> Do Now!
> 
> > 你能比较 `true` 和 `false` 吗？尝试比较它们的相等性（`==`），然后比较不等性（例如 `<`）。

通常，你可以比较任意两个值是否相等（嗯，几乎是这样，我们稍后会回到这个问题）；例如：





> ```py
> "a" == 1
> ```







```py
false
```



如果你想要比较特定类型的值，你可以使用更具体的运算符：





> ```py
> num-equal(1, 1)
> ```







```py
true
```







> ```py
> num-equal(1, 2)
> ```







```py
false
```







> ```py
> string-equal("a", "a")
> ```







```py
true
```







> ```py
> string-equal("a", "b")
> ```







```py
false
```



为什么使用这些运算符而不是更通用的 `==`？

> Do Now!
> 
> > 尝试
> > 
> > ```py
> > num-equal("a", 1)
> > string-equal("a", 1)
> > ```

因此，在期望两个参数具有相同类型时使用特定类型的运算符是明智的。这样，如果出错，Pyret 将会发出错误信号，而不是盲目地返回一个答案（`false`），这会让你的程序继续计算一个无意义的值。

甚至还有更多产生布尔值的运算符，例如：



> ```py
> wm = "will.i.am"
> ```







> ```py
> string-contains(wm, "will")
> ```







```py
true
```



注意大写 `W`。





> ```py
> string-contains(wm, "Will")
> ```







```py
false
```



事实上，几乎每种类型的数据都将有一些布尔值运算符来启用比较。

##### 3.4.3.2 组合布尔值 "链接到此处")

通常，我们希望基于多个布尔值来做出决定。例如，如果你是某个国家的公民并且年龄超过一定限制，你就有权投票。如果你有车票或者公交车有免费乘坐日，你就有权乘坐公交车。我们甚至可以组合条件：如果你年龄超过一定限制，有良好的视力，并且通过测试或持有临时执照，你就有权驾驶。此外，如果你没有喝醉，你也有权驾驶。

对应于这些组合形式，Pyret 提供了三种主要操作：`and`、`or` 和 `not`。以下是一些它们使用的例子：





> ```py
> (1 < 2) and (2 < 3)
> ```







```py
true
```







> ```py
> (1 < 2) and (3 < 2)
> ```







```py
false
```







> ```py
> (1 < 2) or (2 < 3)
> ```







```py
true
```







> ```py
> (3 < 2) or (1 < 2)
> ```







```py
true
```







> ```py
> not(1 < 2)
> ```







```py
false
```



> 练习
> 
> > 解释为什么数字和字符串不是表达真/假问题的答案的好方法。

#### 3.4.4 提出多个问题 "链接到此处")

运费正在上升，因此我们希望修改`add-shipping`程序以包括第三个运费级别：`10`到`30`之间的订单运费为`8`，但超过`30`的订单运费为`12`。这需要对我们程序进行两次修改：

+   我们必须能够提出另一个问题，以区分运费为`8`和运费为`12`的情况。

+   当运费为`8`时的问题需要检查输入值是否介于两个数值之间。

我们将按顺序处理这些问题。

当前`add-shipping`的主体只问一个问题：`order-amt <= 10`。我们需要添加另一个问题用于`order-amt <= 30`，如果这个问题失败，则使用`12`的费用。我们应该把这个问题放在哪里？

使用`else if`扩展的 if 表达式允许你提出多个问题：

```py
fun add-shipping(order-amt :: Number) -> Number:
  doc: "add shipping costs to order total"
  if order-amt <= 10:
    order-amt + 4
  else if order-amt <= 30:
    order-amt + 8
  else:
    order-amt + 12
  end
where:
  ...
end
```

在这一点上，你也应该添加使用`12`费用的`where`示例。

Pyret 如何确定返回哪个答案？它按顺序评估每个问题表达式，从紧随`if`之后的表达式开始。它继续通过问题，返回第一个返回 true 的答案的值。以下是对 if 表达式语法及其评估的总结。

```py
if QUESTION1:
  <result in case first question true>
else if QUESTION2:
  <result in case QUESTION1 false and QUESTION2 true>
else:
  <result in case both QUESTIONs false>
end
```

一个程序可以包含多个`else if`情况，从而在程序中容纳任意数量的问题。

> 现在就做！
> 
> > `add-shipping`的问题描述说，`10`到`30`之间的订单应收取`8`的费用。上述代码是如何捕捉“在之间”的？

这目前完全是隐含的。它取决于我们理解`if`的评估方式。第一个问题是`order-amt <= 10`，所以如果我们继续到第二个问题，这意味着`order-amt > 10`。在这个上下文中，第二个问题询问`order-amt <= 30`。这就是我们捕捉“在之间”的方式。

> 现在就做！
> 
> > 你如何修改上述代码，将“在 10 到 30 之间”的要求明确地构建到`8`情况的问题中？

记得布尔值上的`and`运算符吗？我们可以使用它来捕捉“在之间”的关系，如下所示：

```py
(order-amt > 10) and (order-amt <= 30)
```

> 现在就做！
> 
> > 为什么两个比较周围有括号？如果你将`order-amt`替换为具体值（例如`20`）并省略括号，当你在这个交互面板中评估这个表达式时会发生什么？

这是包含`and`的`add-shipping`的样子：

```py
fun add-shipping(order-amt :: Number) -> Number:
  doc: "add shipping costs to order total"
  if order-amt <= 10:
    order-amt + 4
  else if (order-amt > 10) and (order-amt <= 30):
    order-amt + 8
  else:
    order-amt + 12
  end
where:
  add-shipping(10) is 10 + 4
  add-shipping(3.95) is 3.95 + 4
  add-shipping(20) is 20 + 8
  add-shipping(10.01) is 10.01 + 8
  add-shipping(30) is 30 + 8
  add-shipping(32) is 32 + 12
end
```

两个版本的`add-shipping`支持相同的示例。两者都正确吗？是的。虽然第二个问题的第一部分（`order-amt > 10`）是多余的，但包含这样的条件有三个原因：

1.  它们向未来的读者（包括我们自己！）表明了覆盖一个情况的条件。

1.  它们确保如果我们写早期问题时出错，我们不会默默地得到意外的输出。

1.  它们防止未来的修改，以防有人修改早期问题而没有意识到它对后期的影响。

> 练习
> 
> > 一家在线广告公司需要确定是否向网站用户展示滑板公园的广告。编写一个名为`show-ad`的函数，该函数接受一个个人的年龄和发色，如果用户年龄在 9 岁到 18 岁之间，并且有粉色或紫色头发，则返回`true`。
> > 
> > 尝试以两种方式编写这个函数：一次使用 if 表达式，一次仅使用布尔运算。
> > 
> 负责任计算：将人简化为简单数据带来的伤害
> 
> > 用户假设甚至编码在最简单的函数中。广告练习展示了一个例子，其中基于关于一个人的两条信息做出决定：年龄和发色。虽然有些人可能会刻板地将滑板者与年轻和有彩色头发联系起来，但许多滑板者并不符合这些标准，而许多符合这些标准的人并不滑板。
> > 
> > 虽然将广告与用户匹配的真正程序比这个简单函数更复杂，但即使是最复杂的广告程序也归结为跟踪个人特征或信息，并将其与广告内容的信息进行比较。一个真实的广告系统在跟踪数十（或更多）个特征和使用比简单条件更先进的编程思想来确定广告的适宜性方面会有所不同（我们将在本书后面讨论一些这些内容）。这个例子也扩展到比广告更严重的情况：谁被雇佣、获得银行贷款，或[被送进或释放出监狱](https://www.propublica.org/article/machine-bias-risk-assessments-in-criminal-sentencing)都是依赖于将个人的数据与程序维护的标准进行比较的真实系统的例子。
> > 
> > 从社会责任的角度来看，这里的问题是关于个人的哪些数据应该被用来代表他们供程序处理，以及这些数据可能编码了哪些刻板印象。在某些情况下，个人可以通过数据来表示而不会造成伤害（例如，大学宿舍办公室存储学生的 ID 号码和居住的房间）。但在其他情况下，关于个人的数据会被解释以预测关于他们的某些事情。基于这些预测所做的决定可能是不准确的，因此是有害的。

#### 3.4.5 通过减少表达式进行评估 "链接到此处")

在如何评估函数中，我们讨论了 Pyret 如何将表达式和函数调用简化为值。让我们回顾这个过程，这次扩展到考虑 if 表达式。假设我们想要计算一个工人的工资。工人每小时工资为 10 美元，直到第一个 40 小时，之后每小时工资为 15 美元。假设`hours`包含他们工作的小时数，并且假设它是`45`：

```py
hours = 45
```

假设计算工资的公式是

```py
if hours <= 40:
  hours * 10
else if hours > 40:
  (40 * 10) + ((hours - 40) * 15)
end
```

现在我们来看一下这个结果是如何通过一步一步的过程得出的，这个过程应该与你在代数课上看到的过程相匹配（步骤在右侧的边注中描述）：第一步是将`hours`替换为`45`。

```py
if 45 <= 40:
  45 * 10
else if 45 > 40:
  (40 * 10) + ((45 - 40) * 15)
end
```

接下来，评估`if`表达式的条件部分，在这种情况下是`false`。

```py
=>  if false:
      45 * 10
    else if 45 > 40:
      (40 * 10) + ((45 - 40) * 15)
    end
```

由于条件是`false`，因此尝试下一个分支。

```py
=>  if 45 > 40:
      (40 * 10) + ((45 - 40) * 15)
    end
```

Pyret 在条件语句中评估问题，在这种情况下产生`true`。

```py
=>  if true:
      (40 * 10) + ((45 - 40) * 15)
    end
```

由于条件是`true`，表达式简化为该分支的主体。之后，它只是算术运算。

```py
=>  (40 * 10) + ((45 - 40) * 15)
```

```py
=>  400 + (5 * 15)
=>  475
```

这种风格的简化是思考 Pyret 表达式评估的最佳方式。整个表达式通过简化步骤进行，通过简单的规则进行。如果你想尝试手动（或在大脑中）通过评估一个 Pyret 程序，你可以使用这种风格。

#### 3.4.6 函数组合 "链接到这里")

我们开始这一章时，想要计算笔订单的运费。到目前为止，我们已经编写了两个函数：

+   `pen-cost`用于计算笔的成本

+   `add-shipping`用于向总金额添加运费

如果我们现在想要计算包含运费的笔订单价格，我们必须使用这两个函数一起，将`pen-cost`的输出发送到`add-shipping`的输入。

> Do Now！
> 
> > 编写一个表达式，计算包含运费的 10 支笔订单的总成本。

有两种方式来构建这个计算。我们可以直接将`pen-cost`的结果传递给`add-shipping`：

```py
add-shipping(pen-cost(10, "bravo"))
```

或者，你可能会将`pen-cost`的结果命名为一个中间步骤：

```py
pens = pen-cost(10, "bravo")
add-shipping(pens)
```

这两种方法都会得出相同的答案。

##### 3.4.6.1 函数组合的评估方式 "链接到这里")

让我们回顾一下这些程序在替换和目录上下文中的评估情况。我们将从第二个版本开始，在这个版本中，我们明确地命名了调用`pen-cost`的结果。

评估第二个版本：从高层次来看，Pyret 会经过以下步骤：

+   在`pen-cost`的主体中将`10`替换为`num-pens`，将`"bravo"`替换为`message`，然后评估替换后的主体。

+   将`pens`存储在目录中，值为`3.5`。

+   在评估`add-shipping(pens)`的第一步中，在目录中查找`pens`的值。

+   在`add-shipping`的主体中将`3.5`替换为`order-amt`，然后评估得到的表达式，结果为`7.5`。

评估第一个版本：作为提醒，第一个版本由一个单独的表达式组成：

```py
add-shipping(pen-cost(10, "bravo"))
```

+   由于参数在函数被调用之前被评估，因此首先评估`pen-cost(10, "bravo")`（再次使用替换），这简化为`3.5`。

+   在`add-shipping`的主体中将`3.5`替换为`order-amt`，然后评估得到的表达式，结果为`7.5`。

> Do Now！
> 
> > 对比这两个摘要。它们在哪里不同？哪些代码方面的差异导致了这些差异？

差别在于对目录的使用：显式命名`pens`的版本使用了目录。另一个版本根本不使用目录。然而，这两种方法都导致了相同的结果，因为相同的值（调用`pen-cost`的结果）被替换到`add-shipping`的主体中。

这项分析可能表明，使用目录的版本在某种程度上是浪费的：它似乎只是多走几步就能得到相同的结果。然而，有人可能会争辩说，使用目录的版本更容易阅读（不同的读者可能会有不同的看法，这很正常）。那么我们应该使用哪一个呢？

在给定的问题上，使用对你更有意义的任何一种。有时我们可能会更喜欢这些风格中的每一种。此外，一旦我们更多地了解了程序评估的细微差别，我们会发现这两个版本并不像现在看起来那么不同。

##### 3.4.6.2 函数组合和目录 "链接到这里")

让我们再尝试对这个问题的另一个变体。也许看到我们命名`pen-cost`的中间结果让你希望我们使用中间名称来使`pen-cost`的主体更易于阅读。例如，我们可以这样写：

```py
fun pen-cost(num-pens :: Number, message :: String)
  -> Number:
  doc: ```每支笔的总成本，每支 25 美分

    加上每条消息字符 2 美分```py
  message-cost = (string-length(message) * 0.02)
  num-pens * (0.25 + message-cost)
where:
  ...
end
```

> 现在就做！
> 
> > 用高级步骤写出 Pyret 将如何使用这个新的`pen-cost`版本评估以下程序：
> > 
> > ```py
> > pens = pen-cost(10, "bravo")
> > add-shipping(pens)
> > ```

希望你已经将两个条目添加到目录中，一个是在`pen-cost`的主体中的`message-cost`，另一个是我们之前所做的`pens`。

> 现在就做！
> 
> > 考虑以下程序。你认为 Pyret 应该产生什么结果？
> > 
> > ```py
> > pens = pen-cost(10, "bravo")
> > cheap-message = (message-cost > 0.5)
> > add-shipping(pens)
> > ```
> > 
> > 使用你在上一个活动中构想的目录，你认为你会得到什么答案？

这里发生了一些奇怪的事情。新的程序试图使用`message-cost`来定义`cheap-message`。但是，名称`message-cost`在程序中任何地方都没有出现，除非我们查看函数体内部。但是让代码查看函数体内部是没有意义的：你可能看不到函数内部（如果它们定义在库中，例如），所以这个程序应该报告一个错误，即`message-cost`未定义。

好的，所以这就是应该发生的事情。但是，我们对目录的讨论表明，`pens`和`message-cost`都会在目录中，这意味着 Pyret 将能够使用`message-cost`。发生了什么事？

这个例子促使我们解释关于目录的另一个细微差别。为了避免像这里展示的问题（应该产生错误），在函数内部创建的目录条目是局部（私有的）于函数主体的。当你调用一个函数时，Pyret 会设置一个局部目录，其他函数看不到。函数主体可以在其局部、私有目录（如 `message-cost`）或整体（全局）目录（如 `pens`）中添加或引用名称。但无论如何，一个函数不能窥视另一个函数调用的局部目录。一旦函数调用完成，它的局部目录就会消失（因为没有任何其他东西能够使用它）。

##### 3.4.6.1 如何评估函数组合 "链接到这里")

让我们回顾这些程序在替换和目录的背景下是如何评估的。我们将从第二个版本开始，其中我们明确命名了调用 `pen-cost` 的结果。

评估第二个版本：从高层次来看，Pyret 会执行以下步骤：

+   在 `pen-cost` 的主体中将 `10` 替换为 `num-pens`，将 `"bravo"` 替换为 `message`，然后评估替换后的主体

+   将 `pens` 存储在目录中，值为 `3.5`

+   评估 `add-shipping(pens)` 的第一步是查找目录中 `pens` 的值

+   在 `add-shipping` 的主体中将 `3.5` 替换为 `order-amt`，然后评估得到的结果，结果是 `7.5`

评估第一个版本：作为提醒，第一个版本由一个单独的表达式组成：

```py
add-shipping(pen-cost(10, "bravo"))
```

+   由于参数在函数被调用之前被评估，所以首先评估 `pen-cost(10, "bravo")`（再次使用替换），这会减少到 `3.5`

+   在 `add-shipping` 的主体中将 `3.5` 替换为 `order-amt`，然后评估得到的结果，结果是 `7.5`

> 现在行动！
> 
> > 对比这两个摘要。它们在哪里不同？哪些代码方面的差异导致了这些不同？

差异在于对目录的使用：明确命名 `pens` 的版本使用了目录。另一个版本根本不使用目录。然而，两种方法都得到了相同的结果，因为相同的值（调用 `pen-cost` 的结果）被替换到 `add-shipping` 的主体中。

这种分析可能会让人认为使用目录的版本在某种程度上是浪费的：它似乎只是多走了一些步骤才得到相同的结果。然而，有人可能会认为使用目录的版本更容易阅读（不同的读者会有不同的看法，这是可以的）。那么我们应该使用哪一个？

使用在特定问题中对你更有意义的那个。有时我们会更喜欢这些风格中的每一个。此外，一旦我们了解了程序评估的细微差别，我们会发现这两个版本并不像它们现在看起来那样不同。

##### 3.4.6.2 函数组合和目录 "链接到这里")

让我们尝试对这个问题的另一个变体。也许看到我们命名 `pen-cost` 的中间结果让你希望我们使用中间名称来使 `pen-cost` 的主体更易于阅读。例如，我们可以这样写：

```py
fun pen-cost(num-pens :: Number, message :: String)
  -> Number:
  doc: ```每支笔的总成本，每支 25 分

    每条消息字符加 2 分```py
  message-cost = (string-length(message) * 0.02)
  num-pens * (0.25 + message-cost)
where:
  ...
end
```

> Do Now!
> 
> > 使用这个新的 `pen-cost` 版本，列出 Pyret 将如何评估以下程序的高级步骤：
> > 
> > ```py
> > pens = pen-cost(10, "bravo")
> > add-shipping(pens)
> > ```

希望你已经在目录中添加了两个条目，一个是在 `pen-cost` 的主体中的 `message-cost`，另一个是我们之前提到的 `pens`。

> Do Now!
> 
> > 考虑以下程序。你认为 Pyret 应该产生什么结果？
> > 
> > ```py
> > pens = pen-cost(10, "bravo")
> > cheap-message = (message-cost > 0.5)
> > add-shipping(pens)
> > ```
> > 
> > 使用你在上一个活动中构想的目录，你认为你会得到什么答案？

这里发生了一些奇怪的事情。新的程序试图使用 `message-cost` 来定义 `cheap-message`。但名称 `message-cost` 在程序中任何地方都没有出现，除非我们窥视函数体内部。但让代码窥视函数体内部是没有意义的：你可能看不到函数内部（如果它们在库中定义，例如），所以这个程序应该报告一个错误，即 `message-cost` 未定义。

好的，那么这就是应该发生的事情。但是，我们对目录的讨论表明，`pens` 和 `message-cost` 都会在目录中，这意味着 Pyret 能够使用 `message-cost`。发生了什么？

这个例子促使我们解释关于目录的一个更多细微之处。确切地说，为了避免像这里展示的问题（应该产生一个错误），在函数内部创建的目录条目是局部（私有的）于函数体的。当你调用一个函数时，Pyret 会设置一个其他函数无法看到的局部目录。函数体可以在其局部、私有目录（如 `message-cost`）或整体（全局）目录（如 `pens`）中添加或引用名称。但无论如何，一个函数不能窥视另一个函数调用的局部目录。一旦函数调用完成，其局部目录就会消失（因为无论如何，其他东西也无法使用它）。

#### 3.4.7 嵌套条件 "链接到此处")

我们已经展示了 `if` 表达式的结果本身也是表达式（如下面的函数中的 `order-amt + 4`）：

```py
fun add-shipping(order-amt :: Number) -> Number:
  doc: "add shipping costs to order total"
  if order-amt <= 10:
    order-amt + 4
  else:
    order-amt + 8
  end
end
```

结果表达式可以更复杂。实际上，它们可以是整个 `if` 表达式！为了看到这个例子，让我们开发另一个函数。这次，我们想要一个计算电影票价的函数。让我们从一个简单的版本开始，其中票价是每张 `$10`。

```py
fun buy-tickets1(count :: Number) -> Number:
  doc: "Compute the price of tickets at $10 each"
  count * 10
where:
  buy-tickets1(0) is 0
  buy-tickets1(2) is 2 * 10
  buy-tickets1(6) is 6 * 10
end
```

现在，让我们通过一个额外的参数来增强函数，以指示购买者是否是享有折扣资格的老年公民。在这种情况下，我们将整体价格降低 `15%`。

```py
fun buy-tickets2(count :: Number, is-senior :: Boolean)
  -> Number:
  doc: ```计算每张票 $10 的票价

    15% 的老年折扣```py
  if is-senior == true:
    count * 10 * 0.85
  else:
    count * 10
  end
where:
  buy-tickets2(0, false) is 0
  buy-tickets2(0, true) is 0
  buy-tickets2(2, false) is 2 * 10
  buy-tickets2(2, true) is 2 * 10 * 0.85
  buy-tickets2(6, false) is 6 * 10
  buy-tickets2(6, true) is 6 * 10 * 0.85
end
```

这里有几个需要注意的地方：

+   函数现在有一个额外的`Boolean`类型参数，用于指示购买者是否是老年人。

+   我们添加了一个`if`表达式来检查是否应用折扣。

+   我们有更多的示例，因为我们必须改变票数和折扣是否适用。

现在，让我们再次扩展程序，这次如果购买者不是老年人但购买了超过 5 张票，也会提供折扣。我们应该在哪里修改代码来实现这一点？一个选项是首先检查是否适用老年人折扣。如果不适用，我们检查票数是否符合折扣条件：

```py
fun buy-tickets3(count :: Number, is-senior :: Boolean)
  -> Number:
  doc: ```计算每张票 10 美元的价格

    超过 5 张票享受 15%的折扣

    或者是老年人```py
  if is-senior == true:
    count * 10 * 0.85
  else:
    if count > 5:
      count * 10 * 0.85
    else:
      count * 10
    end
  end
where:
  buy-tickets3(0, false) is 0
  buy-tickets3(0, true) is 0
  buy-tickets3(2, false) is 2 * 10
  buy-tickets3(2, true) is 2 * 10 * 0.85
  buy-tickets3(6, false) is 6 * 10 * 0.85
  buy-tickets3(6, true) is 6 * 10 * 0.85
end
```

注意在这里，我们在`else`情况中放入了第二个`if`表达式。这是有效的代码。（我们也可以在这里使用`else if`，但我们没有这样做，以便我们可以展示嵌套条件也是有效的）。

> 练习
> 
> > 展示这个函数在没有折扣适用的情况下的评估步骤，例如`buy-tickets3(2, false)`。
> > 
> 现在就做！
> 
> > 看看当前的代码：你看到我们可能需要稍后修改的重复计算吗？

良好的代码风格的一部分是确保我们的程序在以后易于维护。例如，如果剧院更改了折扣政策，当前的代码将需要我们在两个地方更改折扣（`0.85`）。最好是将这个计算只写一次。我们可以通过询问哪些条件会导致折扣应用，并将它们作为单个`if`表达式中的检查来实现这一点。

> 现在就做！
> 
> > 在什么条件下应该应用折扣？

在这里，我们看到如果购买者是一位老年人或者购买了超过 5 张票，则适用折扣。因此，我们可以通过使用`or`来简化代码，如下所示（我们省略了示例，因为它们与上一个版本没有变化）：

```py
fun buy-tickets4(count :: Number, is-senior :: Boolean)
  -> Number:
  doc: ```计算每张票 10 美元的价格

    超过 5 张票享受 15%的折扣

    或者是老年人```py
  if (is-senior == true) or (count > 5):
    count * 10 * 0.85
  else:
    count * 10
  end
end
```

这段代码更加紧凑，所有适用折扣的情况都在一个地方描述。尽管如此，我们还想进行两个小的修改来真正清理代码。

> 现在就做！
> 
> > 看看表达式`is-senior == true`。当`is-senior`的值为`true`时，这将评估为什么？当`is-senior`的值为`false`时，这将评估为什么？

注意到`== true`部分是多余的。由于`is-senior`已经是布尔值，我们可以不使用`==`运算符来检查其值。以下是修改后的代码：

```py
fun buy-tickets5(count :: Number, is-senior :: Boolean)
  -> Number:
  doc: ```计算每张票 10 美元的价格

    超过 5 张票享受 15%的折扣

    或者是老年人```py
  if is-senior or (count > 5):
    count * 10 * 0.85
  else:
    count * 10
  end
end
```

注意`if`表达式中的修改后的问题。作为一个一般规则，你的代码永远不应该包含`== true`。你总是可以去掉它，只使用你比较到`true`的表达式。

> 现在就做！
> 
> > 你如何编写代码来消除`== false`？例如，你可能会用什么来代替`is-senior == false`？

最后，请注意，我们仍然有一个重复的计算：票的基础成本（`count * 10`）：如果票价发生变化，最好只有一个地方更新该价格。我们可以通过首先计算基础价格，然后在适当的时候应用折扣来清理它：

```py
fun buy-tickets6(count :: Number, is-senior :: Boolean)
  -> Number:
  doc: ```计算每张票 10 美元的票价

    超过 5 张票的 15%折扣

    或者是高级别```py
  base = count * 10
  if is-senior or (count > 5):
    base * 0.85
  else:
    base
  end
end
```

#### 3.4.8 回顾：布尔值和条件语句 "链接至此")

通过本章，我们的计算可以在不同情况下产生不同的结果。我们使用`if`表达式来提问，其中每个问题或检查都使用一个产生布尔值的运算符。

+   有两个布尔值：`true`和`false`。

+   一种简单的检查（产生布尔值）是比较值是否相等（`==`）或不相等（`<>`）。其他你从数学中知道的运算，如`<`和`>=`，也会产生布尔值。

+   我们可以使用`and`、`or`、`not`运算符从较小的表达式构建较大的表达式，这些表达式产生布尔值。

+   我们可以使用`if`表达式在计算中提出真/假问题，每个情况下产生不同的结果。

+   如果需要，我们可以在一个条件语句内部嵌套另一个条件语句。

+   你永远不需要使用`==`来比较一个值与`true`或`false`：你只需写出值或表达式本身（可能还需要`not`来得到相同的计算）。
