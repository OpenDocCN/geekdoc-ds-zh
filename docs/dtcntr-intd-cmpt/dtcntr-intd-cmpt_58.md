# 18.2 在树上生长集合🔗

> 原文：[`dcic-world.org/2025-08-27/sets-from-trees.html`](https://dcic-world.org/2025-08-27/sets-from-trees.html)

| 18.2.1 使用二叉树 |
| --- |
| 18.2.2 检查复杂性 |
| 18.2.3 平衡的艺术：树手术 |
| 18.2.3.1 左左情况 |
| 18.2.3.2 左右情况 |
| 18.2.3.3 其他情况？ |

在 将集合表示为列表 中，我们看到了集合的多种列表表示。它们都至少包含一些具有线性时间复杂性的操作——<wbr>以不同的方式线性，但总是至少与集合中不同元素的数量成线性关系。我们能做得更好吗？

让我们先注意，如果可能的话，避免存储重复项似乎更好。重复项只有在插入时由于需要成员测试而成为问题。但如果我们能便宜地进行成员测试，那么我们就会更乐意用它来检查重复项，并且只存储每个值的单个实例（这也节省了空间）。因此，让我们尝试提高成员测试的时间复杂度（并且，希望如此，其他操作也是如此）。

显然，对于一个（无重复项）的集合列表表示，我们实际上无法在成员检查中击败线性时间。这是因为每一步我们只能消除一个争议元素，在最坏情况下需要线性工作量来检查整个集合。相反，我们需要在每次比较中消除更多的元素——<wbr>而不仅仅是常数。

在我们方便的递归集合 [解决递归] 中，有一个特别突出：\(T(k) = T(k/2) + c\)。它表明，如果我们用恒定的工作量可以消除一半的输入，我们可以在对数时间内执行成员检查。这是我们目标。

在我们继续之前，值得将对数增长放在正确的视角中。从渐近的角度来看，对数显然没有常数那么好。然而，对数增长是非常令人愉快的，因为它增长得如此缓慢。例如，如果输入的大小从 \(k\) 增加到 \(2k\)，其对数——<wbr>因此资源使用——<wbr>仅增长 \(\log 2k - \log k = \log 2\)，这是一个常数。实际上，对于几乎所有问题，从实际的角度来看，输入大小的对数都受一个常数的限制（这个常数甚至不是很大）。因此，在实践中，对于许多程序，如果我们能将我们的资源消耗减少到对数增长，那么可能就是时候继续前进，专注于改进系统的其他部分了。

我们实际上刚刚做出了一个非常微妙的假设。在集合的列表表示中，当我们检查一个元素以确定其成员资格并消除它时，我们只消除了那个元素。为了获得对数复杂度，我们需要比较一个元素以消除整个集合的元素。因为我们正在构建数字的集合，所以我们在这里不需要面对这个问题。相反，我们将在将值转换为有序值中更详细地介绍这个问题。

#### 18.2.1 使用二叉树🔗 "链接到此处")

因为对数来自树。

显然，列表表示法不会让我们通过恒定的工作量消除一半的元素；相反，我们需要一棵树。因此，我们定义一个（为了简单起见）数字的二叉树：

```py
data BT:
  | leaf
  | node(v :: Number, l :: BT, r :: BT)
end
```

给定这个定义，让我们定义成员检查器：

```py
fun is-in-bt(e :: Number, s :: BT) -> Boolean:
  cases (BT) s:
    | leaf => false
    | node(v, l, r) =>
      if e == v:
        true
      else:
        is-in-bt(e, l) or is-in-bt(e, r)
      end
  end
end
```

哦，等等。如果我们寻找的元素不是根节点，我们该怎么办？它可能在左子节点中，也可能在右子节点中；除非我们检查了两者，否则我们无法确定。因此，我们不能丢弃一半的元素；我们唯一可以丢弃的是根节点的值。此外，这个属性在树的每一层都成立。因此，成员检查需要检查整个树，我们仍然有与集合大小成线性复杂度的复杂度。

我们如何改进？比较需要帮助我们消除的不仅是根节点，而且是一个完整的子树。我们只能这样做，如果比较“代表”整个子树。它可以这样做，如果子树中的所有元素都小于或等于根节点的值，而另一个子树中的所有元素都大于或等于它。当然，我们必须一致地确定哪一侧包含哪个子集；传统上，将较小的元素放在左边，较大的元素放在右边。这使我们的二叉树定义更加精确，以给我们一个二叉搜索树（BST）。

> 现在就做！
> 
> > 这里是一个识别二叉树实际上是否为二叉搜索树的候选谓词：
> > 
> > ```py
> > fun is-a-bst-buggy(b :: BT) -> Boolean:
> >   cases (BT) b:
> >     | leaf => true
> >     | node(v, l, r) =>
> >       (is-leaf(l) or (l.v <= v)) and
> >       (is-leaf(r) or (v <= r.v)) and
> >       is-a-bst-buggy(l) and
> >       is-a-bst-buggy(r)
> >   end
> > end
> > ```
> > 
> > 这个定义正确吗？

不正确。要真正丢弃一半的树，我们需要确保左子树中的所有元素都小于根节点的值，同样，右子树中的所有元素都大于根节点的值。我们上面使用了`<=`而不是`<`，因为尽管我们不想在表示集合时允许重复，但在其他情况下我们可能不想如此严格；这样我们就可以重用上面的实现来用于其他目的。但上面的定义只执行了“浅层”比较。因此，我们可能有一个根节点 a，其右子节点 b，使得 b > a；并且 b 节点可能有一个左子节点 c，使得 c < b；但这并不保证 c > a。事实上，很容易构造一个反例来通过这个检查：

```py
check:
  node(5, node(3, leaf, node(6, leaf, leaf)), leaf)
    satisfies is-a-bst-buggy # FALSE!
end
```

> 练习
> 
> > 修复 BST 检查器。

在修正了定义之后，我们现在可以定义一个更精确的二叉搜索树版本：

```py
type BST = BT%(is-a-bst)
```

我们还可以提醒自己，这个练习的目的是定义集合，并将 `TSet` 定义为树集合：

```py
type TSet = BST
mt-set = leaf
```

现在，让我们在 BST 表示上实现我们的操作。首先，我们将编写一个模板：

```py
fun is-in(e :: Number, s :: BST) -> Bool:
  cases (BST) s:
    | leaf => ...
    | node(v, l :: BST, r :: BST) => ...
      ... is-in(l) ...
      ... is-in(r) ...
  end
end
```

注意，BST 的数据定义给我们关于两个子节点的丰富信息：它们各自都是一个 BST，因此我们知道它们的元素遵循排序属性。我们可以利用这一点来定义实际的操作：

```py
fun is-in(e :: Number, s :: BST) -> Boolean:
  cases (BST) s:
    | leaf => false
    | node(v, l, r) =>
      if e == v:
        true
      else if e < v:
        is-in(e, l)
      else if e > v:
        is-in(e, r)
      end
  end
end

fun insert(e :: Number, s :: BST) -> BST:
  cases (BST) s:
    | leaf => node(e, leaf, leaf)
    | node(v, l, r) =>
      if e == v:
        s
      else if e < v:
        node(v, insert(e, l), r)
      else if e > v:
        node(v, l, insert(e, r))
      end
  end
end
```

在这两个函数中，我们严格假设 BST 的不变性，并在后一种情况下确保它。确保你确定在哪里、为什么以及如何做到这一点。

现在，你应该能够定义剩余的操作。在这些操作中，`size` 显然需要线性时间（因为它必须计算所有元素），但由于 `is-in` 和 `insert` 每次递归都会丢弃两个子节点中的一个，所以它们需要对数时间。

> 练习
> 
> > 假设我们经常需要计算集合的大小。我们应该能够通过让每个树 ☛ 缓存 其大小来降低 `size` 的时间复杂度，这样 `size` 就可以在常数时间内完成（注意，树的大小显然符合缓存的准则，因为它总是可以被重建）。更新数据定义和所有受影响的函数，以正确跟踪这些信息。

#### 18.2.2 检查复杂度🔗 "链接至此")

但等等。我们真的完成了吗？我们的递归形式为 \(T(k) = T(k/2) + c\)，但我们的数据定义中有什么保证了 `is-in` 遍历的子节点的大小将是大小的一半？

> 现在行动！
> 
> > 构造一个例子——<wbr>由一系列对空树的 `insert` 操作组成——<wbr>使得得到的树是不平衡的。证明在这个树中搜索某些元素将需要线性时间，而不是对数时间。

想象一下，从一个空树开始，依次插入值 `1`、`2`、`3` 和 `4`。得到的树将是

```py
check:
  insert(4, insert(3, insert(2, insert(1, mt-set)))) is
  node(1, leaf,
    node(2, leaf,
      node(3, leaf,
        node(4, leaf, leaf))))
end
```

在这个树中搜索 `4` 必须检查树中的所有集合元素。换句话说，这个二叉搜索树是退化的——<wbr>它实际上是一个列表，我们回到了之前相同的复杂度。

因此，使用二叉树，甚至 BST，并不能保证我们想要的复杂度：只有在我们的输入恰好以正确的顺序到达时才能保证。然而，我们不能假设任何输入顺序；相反，我们希望有一个在所有情况下都工作的实现。因此，我们必须找到一种方法来确保树始终是平衡的，这样 `is-in` 中的每个递归调用实际上都丢弃了一半的元素。

> 练习
> 
> > 注意，我们还没有讨论如何计算集合的大小。即使我们可以假设二叉树是平衡的，我们如何以对数或更好的时间确定大小？

#### 18.2.3 精细平衡：树手术🔗 "链接至此")

让我们定义一个平衡二叉搜索树（BBST）。显然，它必须是一个搜索树，所以我们关注“平衡”的部分。我们必须小心地精确理解这意味着什么：我们不能简单地期望两边大小相等，因为这要求树（以及集合）有偶数个元素，甚至更严格的是，大小必须是 2 的幂。

> 练习
> 
> > 定义一个针对 BBST 的谓词，它消耗一个`BT`并返回一个`Boolean`值，指示是否为平衡搜索树。

因此，我们将平衡的概念放宽为既适应又充分的平衡。我们用“平衡因子”这个术语来指代一个节点的左子树高度减去其右子树高度（高度是指最深层节点的边数深度）。我们允许 BBST 的每个节点都有一个平衡因子为\(-1\)、\(0\)或\(1\)（但不能是其他值）：也就是说，要么两者高度相同，要么左子树或右子树可以高一个单位。请注意，这是一个递归属性，但它适用于所有级别，因此不平衡不会累积，使得整个树任意不平衡。

> 练习
> 
> > 给定 BBST 的定义，证明节点数是指数级的。因此，总是递归在一条分支上将在经过对数（以节点数为底）的步骤数后终止。

这里有一个明显但有用的观察：每个 BBST 也是一个 BST（这是由 BBST 的定义本身决定的）。这有什么关系？这意味着对 BST 操作的功能同样可以应用于 BBST，而不会丢失正确性。

到目前为止，一切都很简单。剩下的只是一个创建 BBST 的方法，因为它负责确保平衡。很容易看出常量`empty-set`是一个 BBST 值。所以只剩下`insert`。

这里是我们的`insert`情况。假设我们从一个 BBST 开始，我们可以在对数时间内确定元素是否已经在树中，如果是，则忽略它。为了实现一个包，我们计算其中每个元素的数量，这不会影响树的高度。当插入一个元素时，给定平衡树，BST 的`insert`只需要对数时间来完成插入。因此，如果执行插入不会影响树的平衡，我们就完成了。因此，我们只需要考虑执行插入会破坏平衡的情况。

注意到因为 `<` 和 `>` 是对称的（同样，`<=` 和 `>=` 也是对称的），我们可以考虑将元素插入树的一半，并使用对称的论据来处理另一半的插入。因此，假设我们有一个当前平衡的树，我们将元素 `e` 插入其中。假设 `e` 将进入左子树，并且由于插入，整个树将变得不平衡。有些树，如家谱树（数据设计问题 - 家谱数据）代表现实世界的数据。对家谱树进行“平衡”是没有意义的：它必须准确模拟它所代表的现实。相比之下，这些表示集合的树是我们选择的，而不是由外部现实决定的，因此我们可以自由地重新排列它们。

有两种方法可以继续。一种方法是考虑所有可能导致不平衡的插入 `e` 的地方，并确定每种情况应该做什么。

> 练习
> 
> > 列举所有可能导致插入问题的案例，并规定每种情况应该做什么。

情况的数量实际上相当多（如果你没有这样认为，你可能错过了一些...）。因此，我们而是在问题发生后才解决这个问题：允许现有的 BST `insert` 插入元素，假设我们有一个不平衡的树，并展示如何恢复其平衡。一个树可以被做成“自平衡”的洞察力是非常显著的，现在有很多人解决了这个问题。这个特定的解决方案，最古老的之一，归功于 G.M. Adelson-Velskii 和 E.M. Landis。为了纪念他们的首字母缩写，它被称为 AVL 树，尽管树本身是显而易见的；他们的天才在于定义了重新平衡。

因此，在接下来的内容中，我们从一个平衡的树开始；`insert` 使其变得不平衡；我们假设插入发生在左子树中。特别是，假设一个（子）树的平衡因子为 `2`（由于我们假设左子树由于插入而不平衡，所以是正的）。恢复平衡的程序取决于以下关键属性：

> 练习
> 
> > 证明如果树当前是平衡的，即每个节点的平衡因子是 `-1`、`0` 或 `1`，那么 `insert` 最多可以使平衡因子变为 `±2`。

以下算法在 `insert` 从其递归返回时应用，即从插入值返回根的路径上。由于这个路径在集合大小中是对数长度（由于平衡属性），并且（正如我们将看到的）在每一步只执行常数量的工作，这确保了插入也只花费对数时间，从而完成了我们的挑战。

为了可视化算法，让我们使用这个树形图：

| |    p |
| --- | --- |
| |    / \ |
| |    q    C |
|  / \ |
| A    B |

在这里，\(p\) 是根元素的价值（尽管我们也会滥用术语，将根的价值用来指代整个树），\(q\) 是左子树根的价值（因此 \(q < p\)），而 \(A\)、\(B\) 和 \(C\) 分别命名各自的子树。我们假设 \(e\) 正在被插入到左子树中，这意味着 \(e < p\)。

假设 \(C\) 的高度是 \(k\)。在插入之前，以 \(q\) 为根的树必须具有高度 \(k+1\)（否则一次插入不能造成不平衡）。反过来，这意味着 \(A\) 必须具有高度 \(k\) 或 \(k-1\)，对于 \(B\) 也是如此。

假设插入后，以 \(q\) 为根的树的高度是 \(k+2\)。因此，\(A\) 或 \(B\) 必须具有高度 \(k+1\)，而另一个必须具有小于该高度的高度（\(k\) 或 \(k-1\)）。

> 练习
> 
> > 为什么它们在插入后都不能具有高度 \(k+1\) 呢？

这给我们提供了两个需要考虑的情况。

##### 18.2.3.1 左左情况🔗 "链接至此")

假设不平衡出现在 \(A\) 上，即它具有高度 \(k+1\)。让我们展开这棵树：

|       p |
| --- |
|      / \ |
|     q   C |
|    / \ |
|   r   B |
|  / \ |
| A1  A2 |

我们知道子树中的以下数据。我们将使用 \(T < a\) 的符号，其中 \(T\) 是一棵树，\(a\) 是单个值，表示 \(T\) 中的每个值都小于 \(a\)。

+   \(A_1 < r\).

+   \(r < A_2 < q\).

+   \(q < B < p\).

+   \(p < C\).

让我们也提醒一下自己这些大小：

+   \(A_1\) 或 \(A_2\) 的高度是 \(k\)（不平衡的原因）。

+   另一个 \(A_i\) 的高度是 \(k-1\)（参见上面的练习）。

+   \(C\) 的高度是 \(k\)（初始假设；\(k\) 是任意的）。

+   \(B\) 的高度必须是 \(k-1\) 或 \(k\)（如上所述）。

想象这棵树是一个移动的物体，它稍微向左倾斜了一点。你会自然而然地想到将其稍微向左悬挂以恢复平衡。这正是我们将要做的：

|      q |
| --- |
|     / \ |
|   r     p |
|  / \   / \ |
| A1  A2 B  C |

注意，这保留了上述每个排序属性。此外，与 \(B\) 和 \(C\) 相比，\(A\) 子树现在比之前更接近根。这恢复了平衡（如果你计算出 \(A_i\)、\(B\) 和 \(C\) 的每个高度，你会看到这一点）。因此，我们也恢复了平衡。

##### 18.2.3.2 左右情况🔗 "链接至此")

不平衡可能出现在 \(B\) 上。展开：

|     p |
| --- |
|    / \ |
|   q   C |
|  / \ |
| A   r |
|    / \ |
|   B1  B2 |

再次，让我们记录我们所知道的数据顺序：

+   \(A < q\).

+   \(q < B_1 < r\).

+   \(r < B_2 < p\).

+   \(p < C\).

以及大小：

+   假设 \(C\) 的高度是 \(k\)。

+   \(A\) 的高度必须是 \(k-1\) 或 \(k\)。

+   \(B_1\) 或 \(B_2\) 的高度必须是 \(k\)，但不能两者都是（参见上面的练习）。另一个必须是 \(k-1\)。

因此，我们需要以某种方式将 \(B_1\) 和 \(B_2\) 向树根靠近一个层级。通过使用上述数据排序知识，我们可以构建这个树：

|       p |
| --- |
|      / \ |
|     r   C |
|    / \ |
|   q   B2 |
|  / \ |
| A   B1 |

当然，如果 \(B_1\) 是有问题的子树，这仍然没有解决问题。然而，我们现在回到了之前的（左左）情况；旋转使我们到达：

|       r |
| --- |
|    /    \ |
|   q      p |
|  / \    / \ |
| A   B1 B2  C |

现在观察一下，我们恰好保持了数据排序约束。此外，从根节点开始，\(A\) 的最低节点在高度 \(k+1\) 或 \(k+2\)；\(B_1\) 的也是；\(B_2\) 的也是；\(C\) 的也是 \(k+2\)。

##### 18.2.3.3 其他情况？🔗 "链接至此")

我们之前是不是有点过于轻率了？在左右情况下，我们说 \(B_1\) 或 \(B_2\) 中只有一个可以是高度 \(k\)（在插入后）；另一个必须是高度 \(k-1\)。实际上，我们所能肯定的是，另一个最多只能是高度 \(k-2\)。

> 练习
> 
> > +   另一棵树的高度实际上可以是 \(k-2\) 而不是 \(k-1\) 吗？
> > +   
> > +   如果是这样，上面的解决方案仍然成立吗？结果树中不是仍然存在两个不平衡吗？
> > +   
> > +   上面的算法中实际上有错误吗？

#### 18.2.1 使用二叉树🔗 "链接至此")

因为对数来自树。

显然，列表表示法不能让我们通过恒定的工作量消除一半的元素；相反，我们需要一个树。因此，我们定义一个（为了简单起见）数字的二叉树：

```py
data BT:
  | leaf
  | node(v :: Number, l :: BT, r :: BT)
end
```

根据这个定义，让我们定义成员检查器：

```py
fun is-in-bt(e :: Number, s :: BT) -> Boolean:
  cases (BT) s:
    | leaf => false
    | node(v, l, r) =>
      if e == v:
        true
      else:
        is-in-bt(e, l) or is-in-bt(e, r)
      end
  end
end
```

哦，等等。如果我们正在寻找的元素不是根节点，我们该怎么办？它可能在左子节点或右子节点；我们只有在检查了两个子节点之后才能确定。因此，我们不能丢弃一半的元素；我们唯一可以丢弃的是根节点的值。此外，这个属性在树的每一层都成立。因此，成员检查需要检查整个树，我们仍然有与集合大小成线性复杂度的复杂度。

我们如何改进这一点？比较需要帮助我们消除的不仅仅是根节点，还要消除整个子树。我们只能这样做，如果比较“代表”整个子树。如果子树中的所有元素都小于或等于根值，而另一个子树中的所有元素都大于或等于它，那么它可以做到这一点。当然，我们必须一致地确定哪一侧包含哪个子集；惯例是将较小的元素放在左边，较大的元素放在右边。这使我们的二叉树定义更加精确，从而得到二叉搜索树（BST）。

> 现在行动起来！
> 
> > 这里有一个候选谓词，用于识别何时一个二叉树实际上是一个二叉搜索树：
> > 
> > ```py
> > fun is-a-bst-buggy(b :: BT) -> Boolean:
> >   cases (BT) b:
> >     | leaf => true
> >     | node(v, l, r) =>
> >       (is-leaf(l) or (l.v <= v)) and
> >       (is-leaf(r) or (v <= r.v)) and
> >       is-a-bst-buggy(l) and
> >       is-a-bst-buggy(r)
> >   end
> > end
> > ```
> > 
> > 这个定义正确吗？

这不是。要真正丢弃一半的树，我们需要确保左子树中的所有元素都小于根节点的值，同样，右子树中的所有元素都大于根节点。我们上面使用了`<=`而不是`<`，因为尽管我们不希望在表示集合时允许重复，但在其他情况下我们可能不想如此严格；这样我们就可以为其他目的重用上面的实现。但上面的定义只执行了“浅层”比较。因此，我们可能有一个根节点 a，其右子节点 b，使得 b > a；并且 b 节点可能有一个左子节点 c，使得 c < b；但这并不保证 c > a。事实上，很容易构造一个反例来通过这个检查：

```py
check:
  node(5, node(3, leaf, node(6, leaf, leaf)), leaf)
    satisfies is-a-bst-buggy # FALSE!
end
```

> 练习
> 
> > 修复 BST 检查器。

在定义修正后，我们现在可以定义一个更精细的二叉搜索树版本：

```py
type BST = BT%(is-a-bst)
```

我们还可以提醒自己，这个练习的目的是定义集合，并将`TSet`定义为树集合：

```py
type TSet = BST
mt-set = leaf
```

现在我们来实现 BST 表示上的操作。首先我们将编写一个模板：

```py
fun is-in(e :: Number, s :: BST) -> Bool:
  cases (BST) s:
    | leaf => ...
    | node(v, l :: BST, r :: BST) => ...
      ... is-in(l) ...
      ... is-in(r) ...
  end
end
```

注意到 BST 的数据定义为我们提供了关于两个子节点的丰富信息：它们各自都是一个 BST，因此我们知道它们的元素遵循排序属性。我们可以利用这一点来定义实际的操作：

```py
fun is-in(e :: Number, s :: BST) -> Boolean:
  cases (BST) s:
    | leaf => false
    | node(v, l, r) =>
      if e == v:
        true
      else if e < v:
        is-in(e, l)
      else if e > v:
        is-in(e, r)
      end
  end
end

fun insert(e :: Number, s :: BST) -> BST:
  cases (BST) s:
    | leaf => node(e, leaf, leaf)
    | node(v, l, r) =>
      if e == v:
        s
      else if e < v:
        node(v, insert(e, l), r)
      else if e > v:
        node(v, l, insert(e, r))
      end
  end
end
```

在这两个函数中，我们严格假设 BST 的不变性质，并在后一种情况下确保它。确保你确定在哪里、为什么以及如何做到这一点。

你现在应该能够定义剩余的操作。在这些操作中，`size`显然需要线性时间（因为它必须计算所有元素），但由于`is-in`和`insert`每次递归都会丢弃两个子节点中的一个，因此它们需要对数时间。

> 练习
> 
> > 假设我们经常需要计算集合的大小。我们应该能够通过让每个树☛缓存其大小来降低`size`的时间复杂度，这样`size`就可以在常数时间内完成（注意，树的大小显然符合缓存的准则，因为它总是可以被重建）。更新数据定义和所有受影响的函数，以正确跟踪这些信息。

#### 18.2.2 检查复杂度🔗 "链接至此")

但等等。我们真的完成了吗？我们的递归形式为\(T(k) = T(k/2) + c\)，但我们的数据定义中有什么保证了通过`is-in`遍历的子节点的大小将是大小的一半？

> 现在行动起来！
> 
> > 构造一个例子——<wbr>由一系列向空树插入操作组成——<wbr>使得得到的树是不平衡的。证明在这个树中搜索某些元素将需要线性时间，而不是对数时间。

想象一下从空树开始，并按顺序插入值`1`、`2`、`3`和`4`。得到的树将是

```py
check:
  insert(4, insert(3, insert(2, insert(1, mt-set)))) is
  node(1, leaf,
    node(2, leaf,
      node(3, leaf,
        node(4, leaf, leaf))))
end
```

在这棵树中搜索`4`必须检查树中的所有集合元素。换句话说，这个二叉搜索树是退化的——<wbr>它实际上是一个列表，我们回到了之前相同的复杂度。

因此，使用二叉树，甚至是 BST，并不能保证我们想要的复杂度：只有在我们的输入恰好以正确的顺序到达时才能保证。然而，我们不能假设任何输入顺序；相反，我们希望有一个在所有情况下都能工作的实现。因此，我们必须找到一种确保树始终平衡的方法，这样`is-in`中的每个递归调用才能真正丢弃一半的元素。

> 练习
> 
> > 注意，我们还没有讨论计算集合大小的问题。即使我们可以假设二叉树是平衡的，我们如何以对数或更好的时间确定大小？

#### 18.2.3 良好的平衡：树手术🔗 "链接到此处")

让我们定义一个平衡二叉搜索树（BBST）。显然，它必须是一个搜索树，所以让我们关注“平衡”的部分。我们必须小心地理解这究竟意味着什么：我们不能简单地期望两边的大小相等，因为这要求树（以及集合）有偶数个元素，甚至更严格的是，大小必须是 2 的幂。

> 练习
> 
> > 定义一个针对 BBST 的谓词，它消耗一个`BT`并返回一个`Boolean`值，指示它是否是一个平衡搜索树。

因此，我们将平衡的概念放宽，使其既包容又充分。我们使用“平衡因子”这个术语来指代一个节点的左子树高度减去其右子树高度（高度是指最深层节点在边上的深度）。我们允许 BBST 的每个节点都有一个平衡因子为\(-1\)、\(0\)或\(1\)（但不能是其他值）：也就是说，要么两者高度相同，要么左子树或右子树高出一个单位。请注意，这是一个递归属性，但它适用于所有级别，因此不平衡不会累积，使得整个树变得任意不平衡。

> 练习
> 
> > 给定 BBST 的定义，证明节点数是指数级的。因此，总是递归在一条分支上将会在经过对数（以节点数为底）的步骤数后终止。

这里有一个明显但有用的观察：每个二叉平衡搜索树（BBST）也都是一个二叉搜索树（BBST 的定义本身就保证了这一点）。这有什么关系呢？这意味着，对 BST 操作的功能同样可以应用于 BBST，而不会丢失正确性。

到目前为止，一切都很简单。剩下的只是一个创建 BBST 的方法，因为它是负责确保平衡的。很容易看出常量`empty-set`是一个 BBST 值。所以只剩下`insert`操作。

这里是我们的 `insert` 情况。假设我们从一个 BBST 开始，我们可以以对数时间确定元素是否已经在树中，如果是，则忽略它。为了实现一个包，我们计算其中每种元素的数量，这不会影响树的高度。当插入一个元素时，给定平衡的树，BST 的 `insert` 只需要以对数时间完成插入。因此，如果插入操作不会影响树的平衡，我们就完成了。因此，我们只需要考虑那些执行插入操作会破坏平衡的情况。

注意到因为 `<` 和 `>` 是对称的（同样适用于 `<=` 和 `>=`），我们可以考虑将元素插入树的一半，然后通过对称的论证来处理另一半的插入。因此，假设我们有一个当前已经平衡的树，我们将元素 `e` 插入其中。假设 `e` 将进入左子树，并且由于插入，整个树将变得不平衡。有些树，如家谱树（数据设计问题 – 家谱数据）代表现实世界的数据。对家谱树进行“平衡”是没有意义的：它必须准确模拟它所代表的现实。相比之下，这些表示集合的树是我们选择的，而不是由外部现实决定的，因此我们可以自由地重新排列它们。

有两种方法可以继续。一种是我们考虑所有可能导致 `e` 插入并引起不平衡的地方，并确定每种情况下的处理方法。

> 练习
> 
> > 列举所有可能导致问题的插入情况，并规定每种情况下的处理方法。

实际上，情况的数量相当多（如果你没有这样认为，你可能遗漏了一些...）。因此，我们而是在问题发生后才解决这个问题：允许现有的 BST `insert` 插入元素，假设我们有一个不平衡的树，并展示如何恢复其平衡。一个树可以被制成“自平衡”的洞察力相当显著，现在有许多解决方案来解决这个问题。这个特定的解决方案，最古老的之一，归功于 G.M. Adelson-Velskii 和 E.M. Landis。为了纪念他们的首字母缩写，它被称为 AVL 树，尽管树本身相当明显；他们的天才在于定义重新平衡。

因此，在接下来的内容中，我们从一个平衡的树开始；`insert` 使其变得不平衡；我们假设插入发生在左子树中。特别是，假设一个（子）树的平衡因子为 `2`（由于我们假设左子树由于插入而不平衡，所以是正的）。恢复平衡的程序关键取决于以下属性：

> 练习
> 
> > 证明如果树当前是平衡的，即每个节点的平衡因子是 `-1`、`0` 或 `1`，那么 `insert` 最多可以使平衡因子变为 `±2`。

以下算法在 `insert` 从其递归返回时应用，即从插入值返回根的路径上。由于这个路径在集合大小中是对数长度（由于平衡属性），并且（正如我们将看到的）在每一步只执行常数量的工作，因此它确保插入也只花费对数时间，从而完成我们的挑战。

为了可视化算法，让我们使用这个树形图：

| |     p |
| --- | --- |
| |     / \ |
| |     q   C |
| |   / \ |
| A   B |

在这里，\(p\) 是根元素的价值（尽管我们也会滥用术语，将根的值用来指代整个树），\(q\) 是左子树根的值（因此 \(q < p\)），而 \(A\)、\(B\) 和 \(C\) 分别命名各自的子树。我们假设 \(e\) 正在被插入到左子树中，这意味着 \(e < p\)。

假设 \(C\) 的高度是 \(k\)。在插入之前，以 \(q\) 为根的树必须具有高度 \(k+1\)（否则一次插入无法创建不平衡）。反过来，这意味着 \(A\) 必须具有高度 \(k\) 或 \(k-1\)，对于 \(B\) 也是如此。

假设插入后，以 \(q\) 为根的树的高度是 \(k+2\)。因此，\(A\) 或 \(B\) 的高度是 \(k+1\)，而另一个必须小于这个高度（要么是 \(k\)，要么是 \(k-1\)）。

> 练习
> 
> > 为什么它们在插入后都不能有 \(k+1\) 的高度？

这给我们提供了两个需要考虑的情况。

##### 18.2.3.1 左-左情况🔗 "链接至此")

假设不平衡发生在 \(A\) 上，即它的高度是 \(k+1\)。让我们展开这棵树：

| |     p |
| --- | --- |
| |       / \ |
| |   q   C |
| |   / \ |
| |   r   B |
| |     / \ |
| A1  A2 |

我们知道子树中的数据如下。我们将使用 \(T < a\) 的符号，其中 \(T\) 是一棵树，\(a\) 是一个单独的值，表示 \(T\) 中的每个值都小于 \(a\)。

+   \(A_1 < r\)。

+   \(r < A_2 < q\)。

+   \(q < B < p\)。

+   \(p < C\)。

让我们也提醒一下这些大小：

+   \(A_1\) 或 \(A_2\) 的高度是 \(k\)（不平衡的原因）。

+   其他 \(A_i\) 的高度是 \(k-1\)（参见上面的练习）。

+   \(C\) 的高度是 \(k\)（初始假设；\(k\) 是任意的）。

+   \(B\) 的高度必须是 \(k-1\) 或 \(k\)（如上所述）。

想象这棵树是一个可以移动的物体，它稍微向左倾斜了一点。你会自然地想到将其稍微向左悬挂以恢复平衡。这正是我们将要做的：

| |       q |
| --- | --- |
| |       / \ |
| |     r     p |
| |     / \   / \ |
| A1  A2 B  C |

注意这保留了上述每个排序属性。此外，\(A\) 子树相对于 \(B\) 和 \(C\) 已经比之前更接近根了一级。这恢复了平衡（如果你计算出 \(A_i\)、\(B\) 和 \(C\) 的每个高度，你会看到这一点）。因此，我们也恢复了平衡。

##### 18.2.3.2 左-右情况🔗 "链接至此")

不平衡也可能发生在 \(B\) 上。展开：

| |     p |
| --- | --- |
| |     / \ |
|   q   C |
|  / \ |
| A   r |
|    / \ |
| B1  B2 |

再次，让我们记录我们所知道的数据排序：

+   \(A < q\)。

+   \(q < B_1 < r\).

+   \(r < B_2 < p\)。

+   \(p < C\).

和大小：

+   假设 \(C\) 的高度为 \(k\)。

+   \(A\) 的高度必须是 \(k-1\) 或 \(k\)。

+   \(B_1\) 或 \(B_2\) 的高度必须是 \(k\)，但不能两者都是（见上面的练习）。另一个必须是 \(k-1\)。

因此，我们必须以某种方式将 \(B_1\) 和 \(B_2\) 向树根方向提升一级。通过使用上述数据排序知识，我们可以构建这棵树：

|       p |
| --- |
|      / \ |
|     r   C |
|    / \ |
|   q   B2 |
|  / \ |
| A   B1 |

当然，如果 \(B_1\) 是有问题的子树，这仍然没有解决问题。然而，我们现在回到了之前的（左-左）情况；旋转使我们到达：

|       r |
| --- |
|    /    \ |
|   q      p |
|  / \    / \ |
| A   B1 B2  C |

现在观察，我们恰好保持了数据排序约束。此外，从根节点开始，\(A\) 的最低节点位于高度 \(k+1\) 或 \(k+2\)；同样 \(B_1\) 的；同样 \(B_2\) 的；而 \(C\) 的位于 \(k+2\)。

##### 18.2.3.3 其他情况？🔗 "链接到这里")

我们之前是否过于轻率？在左-右情况下，我们说 \(B_1\) 或 \(B_2\) 中只有一个可以是高度 \(k\)（插入后）；另一个必须是高度 \(k-1\)。实际上，我们所能肯定的是，另一个的高度最多是 \(k-2\)。

> 练习
> 
> > +   另一棵树的高度实际上可以是 \(k-2\) 而不是 \(k-1\) 吗？
> > +   
> > +   如果是这样，上述解决方案是否仍然成立？结果树中是否仍然存在两个不平衡？
> > +   
> > +   上面的算法实际上有错误吗？

##### 18.2.3.1 左-左情况🔗 "链接到这里")

假设不平衡发生在 \(A\) 中，即它的高度为 \(k+1\)。让我们展开这棵树：

|       p |
| --- |
|      / \ |
|     q   C |
|    / \ |
|   r   B |
|  / \ |
| A1  A2 |

我们知道子树中的数据如下。我们将使用符号 \(T < a\)，其中 \(T\) 是一棵树，\(a\) 是一个单独的值，表示 \(T\) 中的每个值都小于 \(a\)。

+   \(A_1 < r\).

+   \(r < A_2 < q\)。

+   \(q < B < p\)。

+   \(p < C\).

让我们也提醒自己大小：

+   \(A_1\) 或 \(A_2\) 的高度是 \(k\)（不平衡的原因）。

+   其他 \(A_i\) 的高度是 \(k-1\)（见上面的练习）。

+   \(C\) 的高度是 \(k\)（初始假设；\(k\) 是任意的）。

+   \(B\) 的高度必须是 \(k-1\) 或 \(k\)（上面已论证）。

想象这棵树是一个移动的物体，它稍微向左倾斜了一点。你会自然地想到将其稍微向左悬挂以使其恢复平衡。这正是我们将要做的：

|      q |
| --- |
|     / \ |
|   r     p |
|  / \   / \ |
| A1  A2 B  C |

注意到这保留了上述每个排序属性。此外，与 \(B\) 和 \(C\) 相比，\(A\) 子树已经提升了一个层级，比之前更接近根节点。这恢复了平衡（如果你计算出 \(A_i\)、\(B\) 和 \(C\) 的每个高度，你会看到）。因此，我们也恢复了平衡。

##### 18.2.3.2 左-右情况🔗 "链接至此")

不平衡可能出现在 \(B\) 上。展开：

|     p |
| --- |
|    / \ |
|   q   C |
|  / \ |
| A   r |
|    / \ |
|   B1  B2 |

再次，让我们记录我们所知道的数据排序：

+   \(A < q\)。

+   \(q < B_1 < r\)。

+   \(r < B_2 < p\)。

+   \(p < C\)。

和大小：

+   假设 \(C\) 的高度是 \(k\)。

+   \(A\) 的高度必须是 \(k-1\) 或 \(k\)。

+   \(B_1\) 或 \(B_2\) 的高度必须是 \(k\)，但不能两者都是（参见上面的练习）。另一个必须是 \(k-1\)。

因此，我们需要以某种方式将 \(B_1\) 和 \(B_2\) 的层级提升到树的根节点更近一些。通过使用上述数据排序知识，我们可以构建如下树：

|       p |
| --- |
|      / \ |
|     r   C |
|    / \ |
|   q   B2 |
|  / \ |
| A   B1 |

当然，如果 \(B_1\) 是有问题的子树，这仍然没有解决问题。然而，我们现在回到了之前的（左-左）情况；旋转带我们到：

|       r |
| --- |
|    /    \ |
|   q      p |
|  / \    / \ |
| A   B1 B2  C |

现在观察一下，我们精确地保持了数据排序约束。此外，从根节点开始，\(A\) 的最低节点在高度 \(k+1\) 或 \(k+2\)；\(B_1\) 的也是；\(B_2\) 的也是；\(C\) 的在 \(k+2\)。

##### 18.2.3.3 其他情况?🔗 "链接至此")

我们之前是不是有点过于轻率了？在左-右情况下，我们说 \(B_1\) 或 \(B_2\) 中只有一个可以是高度 \(k\)（在插入后）；另一个必须是高度 \(k-1\)。实际上，我们所能肯定的是，另一个的高度最多是 \(k-2\)。

> 练习
> 
> > +   另一棵树的高度实际上可以是 \(k-2\) 而不是 \(k-1\) 吗？
> > +   
> > +   如果是这样，上面的解决方案是否仍然成立？结果树中不是仍然有两个不平衡吗？
> > +   
> > +   上面的算法实际上是否存在错误？
