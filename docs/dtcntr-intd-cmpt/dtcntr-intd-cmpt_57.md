# 18.1 表示集合为列表🔗

> 原文：[`dcic-world.org/2025-08-27/sets-from-lists.html`](https://dcic-world.org/2025-08-27/sets-from-lists.html)

| 18.1.1 表示选择（#(part._.Representation_.Choices)） |
| --- |
| 18.1.2 时间复杂度（#(part._.Time_.Complexity)） |
| 18.1.3 在表示之间选择（#(part._choosing-set-reps)） |
| 18.1.4 其他操作（#(part._.Other_.Operations)） |

在[集合作为集体数据)]中，我们介绍了集合。回想一下，集合的元素没有特定的顺序，并且忽略重复。如果这些概念不熟悉，请阅读集合作为集体数据)，因为它们在讨论集合表示时将非常重要。当时我们依赖于 Pyret 的内置集合表示。现在我们将讨论如何为自己构建集合。在以下内容中，我们将仅关注数字集合。

我们将首先讨论如何使用列表表示集合。直观上看，使用列表来表示数据集合似乎有问题，因为列表既尊重顺序又允许重复。例如，

```py
check:
  [list: 1, 2, 3] is [list: 3, 2, 1, 1]
end
```

失败，但相应的集合是相等的。

在原则上，我们希望集合遵守以下接口：请注意，名为`Set`的类型已经内置到 Pyret 中，因此以下我们将使用`LSet`来表示列表表示的集合。

<set-operations> ::=

```py
mt-set :: Set
is-in :: (T, Set<T> -> Bool)
insert :: (T, Set<T> -> Set<T>)
union :: (Set<T>, Set<T> -> Set<T>)
size :: (Set<T> -> Number)
to-list :: (Set<T> -> List<T>)
```

我们可能还会发现以下函数也很有用：

```py
insert-many :: (List<T>, Set<T> -> Set<T>)
```

这与`mt-set`结合，可以很容易地给我们一个`to-set`函数。

集合可以包含许多种类的值，但不一定是任何一种：我们需要能够检查两个值是否相等（这是集合的要求，但不是列表的要求！），而并非所有值（如函数）都可以这样做。我们将在其他地方讨论这一问题的细微差别[等价与排序)]。目前，我们可以通过专注于（非粗糙的）数字集合来忽略这些问题。

#### 18.1.1 表示选择🔗 "链接到此处")

空列表可以代表空集合—<wbr>

```py
type LSet = List
mt-set = empty
```

—<wbr>我们可以假设定义`size`为

```py
fun size<T>(s :: LSet<T>) -> Number:
  s.length()
end
```

然而，这种☛减少)（将集合减少到列表）可能是危险的：

1.  列表和集合之间存在细微的差别。列表

    ```py
    [list: 1, 1]
    ```

    并不相同

    ```py
    [list: 1]
    ```

    因为第一个列表长度为两个，而第二个列表长度为一个。然而，如果将它们视为集合，则两者相同：它们的大小都是一。因此，如果我们不考虑重复（无论是在插入时还是在计算大小时），我们上面的`size`实现是不正确的。

1.  由于底层列表表示提供的顺序保证，我们可能会错误地假设从集合中检索元素顺序。这可能会隐藏我们直到更改表示时才发现的 bug。

1.  我们选择集合表示可能是因为我们不需要关心顺序，并且预期会有很多重复项。列表表示可能存储所有重复项，这会导致比预期更多的内存使用（以及更慢的程序）。

为了避免这些危险，我们必须精确地说明我们如何使用列表来表示集合。一个关键问题（但不是唯一的问题，因为我们很快就会看到 [选择表示法]）是关于重复项的处理。一种可能性是让 `insert` 检查一个元素是否已经在集合中，如果是，则保持表示不变；这会在插入时产生成本，但可以避免不必要的重复，并允许我们使用 `length` 来实现 `size`。另一种选择是将 `insert` 定义为 `link`—<wbr>实际上，

```py
insert = link
```

—<wbr>并让其他程序执行重复项的过滤。

#### 18.1.2 时间复杂度🔗 "链接至此")

这种集合表示法的复杂度是多少？让我们考虑一下 `insert`、`is-in` 和 `size`。假设集合的大小是 \(k\)（为了避免歧义，我们让 \(k\) 代表不同元素的数量）。这些操作的复杂度取决于我们是否存储重复项：

+   如果我们不存储重复项，那么 `size` 就是 `length`，它的时间复杂度是线性的 \(k\)。同样，`is-in` 只需要遍历列表一次来确定一个元素是否存在，这也需要线性 \(k\) 的时间。但是 `insert` 需要检查一个元素是否已经存在，这需要线性 \(k\) 的时间，然后最多执行一个常数时间的操作（`link`）。

+   如果我们存储重复项，那么 `insert` 是常数时间：它简单地 `link`s 在新元素上，而不考虑它是否已经在集合表示中。`is-in` 遍历列表一次，但需要访问的元素数量可能比 \(k\) 大得多，这取决于添加了多少重复项。最后，`size` 需要检查每个元素是否重复，然后再进行计数。

> 现在行动！
> 
> > 如果列表中有重复项，`size` 的时间复杂度是多少？

`size` 的一种实现是

```py
fun size<T>(s :: LSet<T>) -> Number:
  cases (List) s:
    | empty => 0
    | link(f, r) =>
      if r.member(f):
        size(r)
      else:
        1 + size(r)
      end
  end
end
```

现在我们来计算函数体的复杂度，假设 `s` 中不同元素的数量是 \(k\)，但 `s` 中实际元素的数量是 \(d\)，其中 \(d \geq k\)。为了计算在 \(d\) 个元素上运行 `size` 的时间 \(T(d)\)，我们应该确定每个问题中的操作数量。第一个问题有常数个操作，第一个答案也是常数。第二个问题也有常数个操作。其答案是条件性的，其第一个问题（`r.member(f)` 需要遍历整个列表，因此有 \(O([k \rightarrow d])\) 个操作。如果成功，我们递归到大小为 \(T(d-1)\) 的某个东西上；否则我们做同样的事情，但执行常数个额外的操作。因此 \(T(0)\) 是常数，而递归（在大 O 表示法中）是

\begin{equation*}T(d) = d + T(d-1)\end{equation*}

因此 \(T \in O([d \rightarrow d²])\)。请注意，这是列表中元素数量的平方，这可能会远大于集合的大小。

#### 18.1.3 在表示之间进行选择🔗 "链接到此处")

现在我们有了两种具有不同复杂度的表示，值得思考如何在这两者之间进行选择。为了做到这一点，让我们构建以下表格。该表格区分了接口（集合）和实现（列表），因为——由于表示中的重复项——这两个可能并不相同。在表格中，我们将考虑最常见操作中的两个：插入和成员检查：

|  |  | 包含重复项 |  | 不包含重复项 |
| --- | --- | --- | --- | --- |
|  |  | `插入` |  | `存在性检查` |  | `插入` |  | `存在性检查` |
| 集合大小 |  | 常数 |  | 线性 |  | 线性 |  | 线性 |
| 列表大小 |  | 常数 |  | 线性 |  | 线性 |  | 线性 |

对此的简单阅读可能会让人认为包含重复项的表示更好，因为它有时是常数，有时是线性，而没有任何重复项的版本始终是线性的。然而，这掩盖了一个非常重要的区别：线性具体意味着什么。当没有重复项时，列表的大小与集合的大小相同。然而，有重复项时，列表的大小可以任意大于集合的大小！

基于此，我们可以得出几个教训：

1.  我们选择哪种表示取决于我们期望有多少重复项。如果不会有很多重复项，那么存储重复项的版本会为一些更快的操作付出少量的额外代价。

1.  我们选择哪种表示法也是一个问题，即我们预计每个操作会执行多少次。没有重复的表示法“处于中间”：在最坏的情况下，所有操作的成本大致相同。有重复的表示法“处于极端”：插入非常便宜，成员资格可能非常昂贵。但如果我们主要只插入而不检查成员资格，尤其是如果我们知道成员资格检查只会在我们愿意等待的情况下发生，那么允许重复实际上可能是一个明智的选择。（我们什么时候会处于这种情况？假设你的集合代表一个备份数据结构；那么我们添加大量数据，但实际上，只有在某些灾难——<wbr>确实，只有在某些灾难——<wbr>的情况下才需要在其中查找东西。）

1.  另一种表达这些见解的方式是我们的分析方法太弱了。在复杂度高度依赖于特定操作序列的情况下，大 O 表示法太宽松了，我们应该研究特定操作序列的复杂度。我们将在稍后精确地解决这个问题 [万圣节分析]。

此外，程序没有理由只使用一种表示法。它完全可以开始使用一种表示法，然后随着它更好地理解其工作负载而切换到另一种表示法。它需要做的唯一事情是将现有数据在表示法之间进行转换。

这在上面会如何表现？注意数据转换在一个方向上非常便宜：由于每个没有重复的列表自动也是一个包含（潜在）重复的列表，所以在那个方向上的转换是微不足道的（表示法保持不变，只是其解释发生了变化）。另一个方向则更困难：我们必须过滤重复项（这需要与列表中元素数量成平方的时间）。因此，程序可以对其工作负载做出初始猜测并相应地选择表示法，但随着程序的运行，如果它发现其假设是错误的，则可以切换表示法——<wbr>并且可以按需多次切换。

#### 18.1.4 其他操作🔗 "链接至此")

> 练习
> 
> > 在每个列表表示法下实现上述列出的剩余操作 (<set-operations>)。
> > 
> 练习
> 
> > 实现这个操作
> > 
> > ```py
> > remove :: (Set<T>, T -> Set<T>)
> > ```
> > 
> > 在每个列表表示法下（适当地重命名`Set`。你看到了什么不同？
> > 
> 现在进行！
> 
> > 假设你被要求扩展集合以包含这些操作，作为`first`和`rest`的集合类似物：
> > 
> > ```py
> > one :: (Set<T> -> T)
> > others :: (Set<T> -> T)
> > ```
> > 
> > 你应该拒绝这样做！你明白为什么吗？

对于列表，“第一个”元素是明确定义的，而集合被定义为没有顺序。实际上，为了确保你的集合用户不会意外地假设你的实现（例如，如果你使用`first`实现`one`，他们可能会注意到`one`总是返回最近添加到列表中的元素），你真的应该在每次调用时返回集合中的一个随机元素。

不幸的是，返回一个随机元素意味着上述接口不可用。假设`s`绑定到一个包含`1`、`2`和`3`的集合。假设第一次调用`one(s)`返回`2`，第二次返回`1`。（这已经意味着`one`不是一个函数。）第三次它可能再次返回`2`。因此`others`必须记住上次调用`one`时返回的元素，并返回没有该元素的集合。假设我们现在在调用`others`的结果上调用`one`。这意味着我们可能有一个情况，其中`one(s)`产生与`one(others(s))`相同的结果。

> 练习
> 
> > 为什么`one(s)`产生与`one(others(s))`相同的结果是不合理的？
> > 
> 练习
> 
> > 假设你想通过一个`subset`操作来扩展集合，该操作根据某些条件对集合进行分区。它的类型会是什么？
> > 
> 练习
> 
> > 我们上面写出的类型不如它们可能的那样清晰。定义一个`has-no-duplicates`谓词，用它来细化相关的类型，并检查函数是否真的满足这个标准。

#### 18.1.1 表示选择🔗 "链接至此")

空列表可以代表空集合—<wbr>

```py
type LSet = List
mt-set = empty
```

—<wbr>并且我们可以假设定义`size`为

```py
fun size<T>(s :: LSet<T>) -> Number:
  s.length()
end
```

然而，这种☛减少（将集合转换为列表）可能是危险的：

1.  列表和集合之间存在微妙的区别。列表

    ```py
    [list: 1, 1]
    ```

    这不同于

    ```py
    [list: 1]
    ```

    因为第一个列表长度为两个，而第二个长度为一个。然而，作为一个集合，这两个是相同的：它们的大小都是一。因此，如果我们不考虑重复项（无论是在插入时还是在计算大小期间），我们上面实现的`size`是不正确的。

1.  我们可能会由于底层列表表示提供的排序保证而错误地假设从集合中检索元素的顺序。这可能会隐藏我们直到更改表示时才发现的错误。

1.  我们可能选择了集合表示，因为我们不需要关心顺序，并且预期会有很多重复项。列表表示可能会存储所有重复项，导致比我们预期的更多内存使用（以及更慢的程序）。

为了避免这些危险，我们必须精确地说明我们将如何使用列表来表示集合。一个关键问题（但不是唯一的问题，因为我们很快就会看到 [选择表示方式]) 是如何处理重复项。一种可能性是让`insert`检查一个元素是否已经在集合中，如果是，则保持表示不变；这会在插入期间产生成本，但可以避免不必要的重复，并允许我们使用`length`来实现`size`。另一种选择是将`insert`定义为`link`—<wbr>实际上，

```py
insert = link
```

—<wbr>并且让其他程序执行重复项的过滤。

#### 18.1.2 时间复杂度🔗 "链接至此")

这种集合表示的复杂度是多少？让我们考虑 `insert`、`is-in` 和 `size`。假设集合的大小是 \(k\)（为了避免歧义，我们让 \(k\) 代表不同元素的数量）。这些操作的时间复杂度取决于我们是否存储重复项：

+   如果我们不存储重复项，那么 `size` 就是 `length`，它的时间复杂度是 \(k\) 的线性时间。同样，`is-in` 只需要遍历列表一次来确定一个元素是否存在，这也需要 \(k\) 的线性时间。但是 `insert` 需要检查一个元素是否已经存在，这需要 \(k\) 的线性时间，然后最多执行一个常数时间的操作（`link`）。

+   如果我们确实存储重复项，那么 `insert` 是常数时间：它简单地 `link` 新元素，而不考虑它是否已经在集合表示法中。`is-in` 遍历列表一次，但它需要访问的元素数量可能显著大于 \(k\)，这取决于添加了多少重复项。最后，`size` 需要检查每个元素是否重复，然后再计数。

> 现在行动！
> 
> > 如果列表中有重复项，`size` 的时间复杂度是多少？

`size` 的一种实现是

```py
fun size<T>(s :: LSet<T>) -> Number:
  cases (List) s:
    | empty => 0
    | link(f, r) =>
      if r.member(f):
        size(r)
      else:
        1 + size(r)
      end
  end
end
```

现在我们来计算函数体的复杂度，假设 `s` 中的不同元素数量是 \(k\)，但 `s` 中的实际元素数量是 \(d\)，其中 \(d \geq k\)。为了计算在 \(d\) 个元素上运行 `size` 的时间 \(T(d)\)，我们应该确定每个问题的操作数。第一个问题有常数个操作，第一个答案也是常数。第二个问题也有常数个操作。它的答案是条件性的，其第一个问题（`r.member(f)` 需要遍历整个列表，因此有 \(O([k \rightarrow d])\) 个操作。如果成功，我们递归到大小为 \(T(d-1)\) 的某个东西上；否则我们做同样的事情，但执行常数个额外的操作。因此 \(T(0)\) 是常数，而递归（在大 O 表示法中）是

\begin{equation*}T(d) = d + T(d-1)\end{equation*}

因此 \(T \in O([d \rightarrow d²])\)。注意，这在列表元素的数量上是二次的，这可能会远大于集合的大小。

#### 18.1.3 选择表示法🔗 "链接到此处")

现在我们有了两种具有不同复杂度的表示法，值得考虑如何在这两者之间进行选择。为了做到这一点，让我们构建以下表格。该表区分了接口（集合）和实现（列表），因为——由于表示法中的重复项——这两个可能不同。在表中，我们将考虑最常见操作中的两个，即插入和成员检查：

|  |  | 有重复项 |  | 无重复项 |
| --- | --- | --- | --- | --- |
|  |  | `insert` |  | `is-in` |  | `insert` |  | `is-in` |
| 集合大小 |  | 常数 |  | 线性 |  | 线性 |  | 线性 |
| 列表大小 |  | 常数 |  | 线性 |  | 线性 |  | 线性 |

对此的直观理解可能会让人认为包含重复项的表示形式更好，因为它有时是常数，有时是线性的，而无需重复的版本始终是线性的。然而，这掩盖了一个非常重要的区别：线性意味着什么。当没有重复项时，列表的大小与集合的大小相同。然而，有重复项时，列表的大小可以任意大于集合的大小！

基于此，我们可以得出几个教训：

1.  我们选择哪种表示形式取决于我们预计会有多少重复。如果没有很多重复项，那么存储重复项的版本在换取一些更快操作的同时，只需支付一小部分额外成本。

1.  我们选择哪种表示形式也是一个问题，即我们预计每种操作会执行多少次。无重复的表示形式“处于中间”：所有操作的成本大致相同（在最坏的情况下）。包含重复项的表示形式“处于极端”：插入非常便宜，而成员资格检查可能非常昂贵。但是，如果我们主要只插入而不检查成员资格，尤其是如果我们知道成员资格检查只会在我们愿意等待的情况下发生，那么允许重复实际上可能是一个明智的选择。（我们何时会处于这种情况？假设你的集合代表一个备份数据结构；那么我们会添加大量数据，但实际上，只有在某些灾难——<wbr>确实，只有在某些灾难——<wbr>的情况下才需要在其中查找东西。）

1.  另一种表达这些见解的方式是，我们的分析方法太弱。在复杂度高度依赖于特定操作序列的情况下，大 O 表示法太宽松了，我们应该研究特定操作序列的复杂度。我们将在稍后精确地解决这个问题 [万圣节分析]。

此外，程序没有理由只使用一种表示形式。它完全可以开始使用一种表示形式，然后随着对其工作负载理解的加深而切换到另一种表示形式。它需要做的唯一一件事就是将现有数据在表示形式之间进行转换。

这种情况会如何发展？观察发现，数据转换在一个方向上非常便宜：由于每个不包含重复项的列表自动也是一个包含（潜在）重复项的列表，所以在那个方向上的转换是微不足道的（表示形式保持不变，只是其解释发生了变化）。另一个方向则更困难：我们必须过滤重复项（这需要与列表中元素数量成平方的时间）。因此，一个程序可以对其工作负载做出初始猜测，并相应地选择表示形式，但随着程序的运行，维护统计数据，当它发现其假设错误时，切换表示形式——<wbr>并且可以按需多次切换。

#### 18.1.4 其他操作🔗 "链接到此处")

> 练习
> 
> > 在每种列表表示法下实现上述列出的剩余操作 (<集合操作>)。
> > 
> 练习
> 
> > 实现操作
> > 
> > ```py
> > remove :: (Set<T>, T -> Set<T>)
> > ```
> > 
> > 在每种列表表示法下（适当地重命名 `Set`。你看到了什么区别？）
> > 
> 现在行动！
> 
> > 假设你被要求扩展集合，以 `first` 和 `rest` 的集合类似物来操作：
> > 
> > ```py
> > one :: (Set<T> -> T)
> > others :: (Set<T> -> T)
> > ```
> > 
> > 你应该拒绝这样做！你明白为什么吗？

对于列表，“第一个”元素是明确定义的，而集合被定义为没有顺序。实际上，为了确保集合的用户不会意外地假设关于你的实现（例如，如果你使用 `first` 实现 `one`，他们可能会注意到 `one` 总是返回最近添加到列表中的元素），你真的应该在每次调用时返回集合中的一个随机元素。

不幸的是，返回一个随机元素意味着上述接口无法使用。假设 `s` 被绑定到一个包含 `1`、`2` 和 `3` 的集合中。假设第一次调用 `one(s)` 返回 `2`，第二次返回 `1`。（这已经意味着 `one` 不是一个函数。）第三次它可能再次返回 `2`。因此 `others` 必须记住上次调用 `one` 时返回的元素，并返回没有该元素的集合。假设我们现在在调用 `others` 的结果上调用 `one`。这意味着我们可能遇到 `one(s)` 和 `one(others(s))` 产生相同结果的情况。

> 练习
> 
> > 为什么 `one(s)` 和 `one(others(s))` 产生相同的结果是不合理的？
> > 
> 练习
> 
> > 假设你想要扩展集合，以一个 `subset` 操作来根据某些条件对集合进行分区。它的类型会是什么？
> > 
> 练习
> 
> > 我们上面写出的类型并不像它们本可以的那样清晰。定义一个 `has-no-duplicates` 断言，用它来细化相关的类型，并检查这些函数是否真的满足这个标准。
