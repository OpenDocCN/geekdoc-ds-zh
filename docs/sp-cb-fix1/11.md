# 十一、NumPy 和 SciPy / 高级主题

*   [NumPy 中视图与副本的对比](ViewsVsCopies.html)

# NumPy 中的视图与副本

# NumPy 中的视图与副本

不时有人写信给！NumPy 列表询问在哪些情况下创建了数组视图，在哪些情况下没有创建。这一页试图澄清这个相当微妙的问题上的一些棘手之处。

## 什么是 NumPy 数组的视图？

顾名思义，这只是**查看**数组数据的另一种方式。从技术上讲，这意味着两个对象的数据是*共享的*。您可以通过选择原始数组的一个**切片**或通过更改**数据类型**(或两者的组合)来创建视图。这些不同类型的视图描述如下。

## 切片视图

这可能是中最常见的视图创作来源！NumPy。创建切片视图的经验法则是，可以用原始数组中的偏移量、步长和计数来处理被查看的元素。例如:

```py
>>> a = numpy.arange(10)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> v1 = a[1:2]
>>> v1
array([1])
>>> a[1] = 2
>>> v1
array([2])
>>> v2 = a[1::3]
>>> v2
array([2, 4, 7])
>>> a[7] = 10
>>> v2
array([ 2,  4, 10]) 
```

在上面的代码片段中，()和()是的视图，因为如果更新，将会反映更改。

## 数据类型视图

创建数组视图的另一种方法是将另一个**数据类型**分配给同一数据区域。例如:

```py
>>> b = numpy.arange(10, dtype='int16')
>>> b
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=int16)
>>> v3 = b.view('int32')
>>> v3 += 1
>>> b
array([1, 1, 3, 3, 5, 5, 7, 7, 9, 9], dtype=int16)
>>> v4 = b.view('int8')
>>> v4
array([1, 0, 1, 0, 3, 0, 3, 0, 5, 0, 5, 0, 7, 0, 7, 0, 9, 0, 9, 0], dtype=int8) 
```

在这种情况下，和是的视图。如您所见，**数据类型视图**不如**切片视图**有用，但在某些情况下会很方便(例如，快速查看泛型数组的字节)。

## 常见问题解答

### 我想我明白什么是视图，但是为什么花哨的索引不返回视图呢？

人们可能会想，做花哨的索引可能会导致视图切片。但这不是真的:

```py
>>> a = numpy.arange(10)
>>> c1 = a[[1,3]]
>>> c2 = a[[3,1,1]]
>>> a[:] = 100
>>> c1
array([1, 3])
>>> c2
array([3, 1, 1]) 
```

花式索引不返回视图的原因是，一般来说，它不能表示为一个**切片**(在上述意义上，可以用偏移量、步长和计数来处理)。

例如，的花式索引可以用来表示，但是不能用切片的方式来表示。所以，这就是为什么会返回一个带有原始数据的*副本*的对象。

### 但是花哨的索引有时确实会返回视图，不是吗？

许多用户被愚弄了，当他们使用这个习惯用法时，他们认为花哨的索引返回视图而不是副本:

```py
>>> a = numpy.arange(10)
>>> a[[1,2]] = 100
>>> a
array([  0, 100, 100,   3,   4,   5,   6,   7,   8,   9]) 
```

所以，看起来一个<1,2>实际上是一个*视图*，因为元素 1 和 2 已经更新了。然而，如果我们一步一步地尝试，这是行不通的:

```py
>>> a = numpy.arange(10)
>>> c1 = a[[1,2]]
>>> c1[:] = 100
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> c1
array([100, 100]) 
```

这里发生的是，在第一个习惯用法()中，python 解释器将其翻译为:

```py
a.__setitem__([1,2], 100) 
```

即不需要创建视图或副本，因为该方法可以在处进行评估*(即不涉及新对象的创建)。*

然而，第二个成语()被翻译成:

```py
c1 = a.__getitem__([1,2])
c1.__setitem__(slice(None, None, None), 100)  # [:] translates into slice(None, None, None) 
```

即在调用之前创建并返回一个新对象，该对象的某些元素具有**副本**(记住，花式索引不返回视图)。

这里的经验法则可以是:在**左值索引**的上下文中(即索引放在赋值的左侧值)，不创建数组的视图或副本(因为不需要)。但是，对于常规值，上述创建视图的规则确实适用。

## 最后的练习

最后，让我们提出一个有些高级的问题。下一个片段如预期的那样工作:

```py
>>> a = numpy.arange(12).reshape(3,4)
>>> ifancy = [0,2]
>>> islice = slice(0,3,2)
>>> a[islice, :][:, ifancy] = 100
>>> a
array([[100,   1, 100,   3],
 [  4,   5,   6,   7],
 [100,   9, 100,  11]]) 
```

但是下一个没有:

```py
>>> a = numpy.arange(12).reshape(3,4)
>>> ifancy = [0,2]
>>> islice = slice(0,3,2)
>>> a[ifancy, :][:, islice] = 100  # note that ifancy and islice are interchanged here
>>> a
array([[ 0,  1,  2,  3],
 [ 4,  5,  6,  7],
 [ 8,  9, 10, 11]]) 
```

读者会发现为什么会有差异吗？' '提示:根据{{ **getitem** ()}}和{{{ **setitem** ()}}调用的顺序以及它们对每个示例的作用来思考。''