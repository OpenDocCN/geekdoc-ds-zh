# Web 上的 MVC

# Web 上的 MVC

解释 HTTP 的独特性。

在网页上，我们有两个实体进行交互：服务器和客户端。服务器是唯一负责保存模型的实体。客户端运行一个 Web 浏览器，向服务器发出请求。这些请求被正确地传送，触发模型的变化，并产生一个响应，客户端将其呈现给用户。一些交互（例如滚动条目列表）可能根本不涉及服务器。

在网页上，控制器负责处理用户事件，准备视图，并将其推送到渲染器。这是一个非常不同的模式。

MVC [](GLOSSARY.html)也可以在网络上使用，并且许多网络开发框架免费提供了设计良好的 MVC 架构，程序员只需填补空白部分，所有网络繁重的工作都会被处理。通常，模型对象代表我们应用程序的业务领域，持久性的任务交给模型或另一个层：它们直接与数据库交互（通常，但不总是，是 SQL 数据库）或通过对象关系映射器将模型类的面向对象特性转换为关系数据库可以处理的内容。同样，控制器接收用户的 HTTP 请求，由 Web 框架分派。它负责应用业务逻辑并协调其他对象以向用户显示最终的网页（或其中的部分）。一般来说，控制器在这一点上的工作是解析请求，选择适当的模型对象来满足请求，选择适合请求的视图，并让视图渲染最终的 HTML 以供浏览器消费。为此，视图通常将控制器提供的数据与模板机制结合起来。

在网络上，视图（即 HTML 和浏览器作为渲染器）与控制器（即代码的服务器端）之间的分离是明显的，并且在通信中存在瓶颈。主要事件是 HTTP 请求（GET/POST）。

控制器可以根据需要切换模型或视图，但通常是初始化的，并且与视图密切相关。控制器如何了解这些不同的模型或视图可以通过访问器方法（外部代码“推送”新模型到控制器）或通过提供者类（例如，控制器知道从哪里获取模型：提供者类在需要时提供）来实现。knockout.js

关于 REST 在 web mvc 中的一些内容。

.. 图片:: web_mvc

视图：从模板中呈现 HTTP 响应和模型的内容。控制器：处理由前端控制器传递的 HTTP 请求，并选择最合适的模型和视图进行渲染。

## 页面控制器

为了保持视图和控制器同步，有两种可能的方法： “推”策略：数据由控制器推送到视图。 “拉”策略：数据由视图从控制器中拉取。

例如，假设用户向论坛添加了评论。一旦他提交请求，其评论现在被控制器接受，该控制器将其添加到模型中。视图和模型现在不同步。控制器现在可以通过将新信息推送到视图来回复，以便用户提交的评论可以出现。添加到模型的任何其他评论也将被推送到视图中，允许用户随着评论的添加而看到其视图变化。

在拉模型中，视图负责在提交请求结束时请求和获取来自控制器的数据，并同步其内容。拉也通常用于响应用户请求从控制器获取任何类型的数据。

spring

ruby on rails

wxpy

在网络上，视图[GLOSSARY.html]被传递到客户端，在浏览器中呈现，而模型[GLOSSARY.html]保留在服务器端。当用户执行操作时，控制器将向模型发出更改请求，然后向视图发出请求以刷新自身。视图现在将向服务器发出 get 请求，以与新的模型内容同步。

用户事件作为 http 请求，通过直接调用或通过 XMLRPC 调用产生。

页面[GLOSSARY.html]控制器：处理对特定网页的请求

前端[GLOSSARY.html]控制器：处理对多个页面的请求

浏览器可以被解释为视图：页面控制器接收 http 请求并呈现 html 结果，但也可以生成 json、xml 或任何其他格式。然后将此结果发送到浏览器进行可视化呈现。控制器选择适当的“视图渲染器”，并根据不同的约束（例如必须为移动设备和浏览器呈现页面）可能会切换

Backbone 路由器

Smalltalk MVC 的原始实现：[`github.com/petermichaux/maria`](https://github.com/petermichaux/maria)

请求模型：传入的 HTTP 请求也可以看作是模型层的一部分对象。其更改通知前端控制器，后者对其进行操作

两个[GLOSSARY.html](https://wiki.example.org/glossary)控制器在 web mvc 中：控制器 1：将 urls 映射到请求处理程序，最终使用中间件处理传入的请求。控制器 2：处理程序。

模型从不计算 html

视图使用模板渲染。控制器将来自模型的状态与模板引擎结合起来，生成最终的视图表示。

模型：[](GLOSSARY.html)服务器[](GLOSSARY.html)负责处理来自不同客户端的可能并发的修改请求到相同的模型数据。

## 浏览器

浏览器基本上是一个 MVC 三元组：它有一个模型（HTML 文档）、一个视图（渲染的内容）和一个控制器（浏览器的部分，解释用户事件并最终修改模型的内容）。

## 服务器端 MVC

最简单的 MVC 形式。客户端发出请求作为 GET http 请求，最终带有 POST 数据/cookies。服务器处理请求并返回完整的 HTML 页面。非常粗粒度，非常全或无交互，迫使客户端经常刷新视觉方面，而不是逐步增量。应用程序对带宽要求高且反应迟缓。

## 富互联网应用

在光谱的另一端，我们有 RIA。 RIA 将模型保留在服务器上，并将其他所有内容移至客户端。客户端模型与服务器模型同步。服务器不执行任何渲染，它只是将数据返回给客户端。

有时在桌面应用程序中，代理委托也被称为“代理委托”

## 其他

验证通常需要两次进行：在客户端上确保数据一致且向用户正确呈现。然而，一旦用户提交数据，服务器端也必须进行验证。请求可能会被强制执行，并且我们从视图设置的所有约束将被绕过。

.. toctree:: :maxdepth: 1

# 前端控制器

## 前端控制器

前端控制器（有时称为 应用程序）是 请求 的 第一个 进入点。它 处理 对 相关 控制器 的 总体 调度，并 处理 常见 需求，如 认证、会话 管理、安全、重定向。它 包含 所有 请求 必须 考虑 的 逻辑，减少 代码 重复。它 还 向 执行 上下文 添加 数据。

将 [](GLOSSARY.html) 调度到 [](GLOSSARY.html) 前端控制器 是 直接 从 网页服务器 执行 的。

通常，前端控制器 可以 托管 一组 拦截 过滤器，旨在 对 请求 进行 特定 操作 的 类。

一个 [](GLOSSARY.html) 前端控制器 可能 是 潜在 的 瓶颈。所有 [](GLOSSARY.html) 请求 都 经过 它。

FIXME: 对前端控制器的不同解释，一个单一的入口点，取代页面控制器设计。前端控制器根据提交的请求创建命令（替代页面控制器），这些命令由前端控制器执行。命令向视图提供信息。

FIXME: Django 的方法有点混合。有一个前端控制器，将分派到实际上成为页面控制器的方法。在分派发生之前，请求会通过过滤器（中间件）传递。

# 页面控制器

## 页面控制器

页面控制器在服务器上处理特定请求，通过结合模型和视图并将渲染的视图发送回客户端。通常，它绑定到特定的 URL。

它通常处理一个逻辑页面，或一个特定的操作。这使得它非常简单。

一旦[](GLOSSARY.html)收到[](GLOSSARY.html)请求，它[](GLOSSARY.html)会从[](GLOSSARY.html)这个请求中提取数据（例如 HTTP 标头、查询[](GLOSSARY.html)参数、cookie、表单[](GLOSSARY.html)内容），对模型执行操作，然后选择适当的视图来执行渲染。通常会使用模板机制来渲染模型数据，同时分离渲染/呈现逻辑。它可以渲染整个页面、页面的子集，或者由客户端[](GLOSSARY.html)javascript 解析的数据。

测试页面控制器可能会很复杂，因为需要模拟 HTTP 请求。理想情况下，应该将与非 HTTP 相关的功能分区，并使其可测试，而无需 HTTP 上下文，否则 Web 框架环境必须存在并设置。

页面控制器通常被实现为基类的重新实现，以提供可重用的功能，这些功能对所有页面控制器都是通用的。

一般来说，像会话管理、身份验证和类似的低级操作等功能不是在页面控制器级别处理的。使用了不同的技术：过滤器（又名中间件）

FIXME: 不同页面控制器之间可能需要继承的常见功能。这可能会强制出现不一定合适的层次结构，并在添加新页面时强制进行重构。

# 模板视图

## 模板视图

为了呈现模型的内容，通常但不一定是在 HTML 中，会使用模板视图。模板是一个蓝图文档，包含了 HTML 和占位符标记。当控制器将模型数据应用于模板时，这些标记会被替换，生成最终的 HTML 内容。

此[](GLOSSARY.html)机制[](GLOSSARY.html)将[](GLOSSARY.html)数据[](GLOSSARY.html)与[](GLOSSARY.html)HTML 的[](GLOSSARY.html)生成[](GLOSSARY.html)隔离开来。它还允许在必要时选择不同的模板（例如，以 JSON 或[](GLOSSARY.html)XML 形式传递相同的数据，或者针对不同的设备（为计算机或手机提供的 HTML）。模板作者不需要了解框架，而是可以专注于视觉结果，而控制器作者则无需担心视觉问题，而是专注于向模板传递所需的数据。

# 中间件过滤器

## 中间件过滤器

有一些在 web 处理中常见且需要大量预处理或后处理的操作。诸如身份验证、会话管理、压缩、提取 cookie、日志记录等等。通常会将处理这些问题的代码提供为可插拔组件，称为拦截过滤器或中间件。这些操作对所有页面都是常见的，将它们集中化是很方便的。它们也倾向于与实际应用程序无关，因此具有巨大的重用潜力。

过滤器通常不依赖于彼此。当它们依赖时，确保它们按正确顺序遍历是很重要的。

它们充当请求的预处理过滤器和响应的后处理过滤器。

考虑到所有请求都经过这些过滤器，它们的性能至关重要。

[图：将分层请求 -> f1 f2 f3 控制器 -> 响应 -> f3 f2 f1]

# Javascript MVC

## Javascript MVC

Web 编程的客户端-服务器性质导致需要在双方都使用 MVC。虽然我们之前一直在服务器端研究 MVC，但现在我们要研究客户端。通常通过 JavaScript 完成。

## 视图

JavaScript 视图通常涉及操作

+   DOM，或

+   一个 canvas 对象

FIXME Maria 实现了真正的 MVC。所有其他框架实现了 MV*的一个派生，其中特别是控制器采用了不同的方法。Backbone 使用路由器。详细研究 JavaScript MVC。

使用**backbone**与 CRUD 操作同步对 JSON/REST 模型进行操作。
