# 分层 MVC

# 分层 MVC

直到现在，我们看到 MVC 应用于单个三元组。这对单个小部件和对话框效果很好，但如何将 MVC 应用和扩展到应用程序级别呢？控制器之间的通信

应用程序由数十个或数百个三元组组成。我们能以某种方式组织它们吗？我们需要吗？是的，我们需要。

# 控制器层次结构

## 传统 MVC 中的控制器层次结构

为了处理用户事件，传统 MVC 必须以层次结构组织控制器。当视图接收到事件时，它会交给其控制器处理。事件根据实际光标位置（基本上指示哪个视图处于焦点）传递，直到它们被交给愿意处理事件的控制器。

一次只有一个控制器处于活动状态。

# HMVC

## 分层模型视图控制器（HMVC，递归 MVC）

分层 MVC 是一种在大型应用程序中应用 MVC 的策略，同时保持对数据和通信粒度的控制。HMVC 通过连接控制器部署了一个三重体系的层次结构。这些三重体系通过处理它们能够处理的事件并在不知道如何处理时将它们转发到层次结构中的上层，共同协作。

[图像]

与传统的 MVC 相比，存在相关的差异：视图负责处理用户输入事件。这些事件被转发给控制器。控制器通常通过直接调用模型对象的方法对模型进行修改。为了刷新视图状态，控制器通知视图需要刷新。视图然后直接与模型通信，从中提取数据，而不再涉及控制器。另外，模型通过提供自己的状态通知视图。控制器还充当控制器层次结构中的中心枢纽。如果控制器从其关联视图接收到无法处理的事件，则将其冒泡到父级，父级可以选择处理它或将其进一步委托给树中的上下级。层次结构中的任何级别的任何模型都可以访问任何范围的数据，模型也可以相互通信。层次结构中的任何级别的控制器都可以共享这些模型。

控制器[](GLOSSARY.html)作为视图控制器[](GLOSSARY.html)处理多个视图[](GLOSSARY.html)或多个子控制器[](GLOSSARY.html)。

在一个观察者模式中的视图-模型[](GLOSSARY.html)

# PAC

## 演示抽象控制（PAC）

PAC [](GLOSSARY.html) 是一个较早的方案，与 HMVC 非常相似。类似于 MVC，PAC 将一个三元组（在 PAC 术语中称为 Agent）定义如下：Presentation，负责处理与用户的所有交互，包括输入（鼠标事件）和输出（可视化）Abstraction，仅表示在三元组内有意义的数据 Control，连接 Presentation 和 Abstraction，并充当控制连接层次结构中的通信中心。Controls 负责在层次结构中转发消息，最终在转换后传递。当一个 agent 想要将事件发送给另一个 agent 时，它将其转发给其父代理。父代理要么处理事件，要么，如果不知道如何处理，将事件发送给其其他子代理之一或其父代理，依此类推。乍一看，HMVC 和 PAC 之间几乎没有区别。如果你这样认为，你并不是唯一一个。然而，两者之间确实存在一些重要的区别。首先，HMVC 基于传统的 MVC，这意味着模型和视图之间存在紧密耦合，视图必须查询模型。在 PAC 中，这种通信完全由控制器中介。通过这种策略，PAC 保持了 MV 的松耦合，而 HMVC 则具有 MV 的紧耦合。

[PAC](https://wiki.example.org/PAC)的第二个主要区别是三元组的访问范围。在 HMVC 中，每个三元组在技术上都被允许访问所有模型。但在 PAC 中不是这样的。在 PAC 中，它只能访问与该三元组有意义的数据。如果需要访问超出其范围的内容，必须将事件转发给控制器，然后由层次结构将其路由到适当的上下文。

PAC：由 Presentation、Abstraction 和 Control 对象组成的 PAC 实体组。组织成网络。

+   抽象：代表业务功能和状态。

控制是一个调解控制器。P 和 A 之间没有交互。
