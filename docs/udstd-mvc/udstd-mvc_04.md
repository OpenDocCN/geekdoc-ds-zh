# 高级 MVC

# 高级 MVC

直到现在，主要关注于 MVC 的基本模式。在本章中，我们将观察 MVC 应用程序的更广泛图景，以及这些模式如何与现实世界互动。

+   模型持久性

+   MVC 测试

+   通知粒度

+   事件驱动编程

+   抖动预防

+   验证

+   过期的监听器问题

+   发布者-订阅者

+   模型分布

+   多线程

+   通知循环预防：防止递归通知事件传播。

+   延迟模型：通过超时中和快速通知。

+   节流：中和快速通知，但立即发出变更。

# 模型持久性

## 模型持久性

领域模型对象

在某些情况下，模型或模型的部分必须持久化（例如，到磁盘，或到数据库）以便在以后恢复。持久性层：有时被视为模型的一部分，但不一定

哪个[GLOSSARY.html](https://wiki.example.org/GLOSSARY.html)组件应负责持久性？最自然的策略是让模型知道如何将自己存储和检索到磁盘或数据库中。这是一种流行的解决方案，被称为“ActiveRecord”。它使用起来简单易懂，相对灵活直观，但并非没有限制。

第一个，也是最大的限制是它偏爱模型和 IO 策略之间的强耦合：放弃本地磁盘存储，转而使用远程数据库将迫使我们重新实现所有模型对象的 IO 策略；

第二个问题是模型对象的生命周期与存储后端相关联。这使得测试模型变得更加困难，因为存储后端必须完全功能，或者模拟。

这种方法的最终问题是，如果模型完全控制其持久性策略，客户端代码无法做出不同的决定，例如，如果它希望将模型对象存储在其他地方。

另一种策略是将持久性委托给控制器。控制器持有对模型的引用，以及对存储子系统的引用。作为对适当触发事件的响应，控制器可以选择相关的模型对象，并将它们推送到存储子系统。这种策略有一些优点：模型对象更轻量，并且对存储策略一无所知，现在可以通过使用不同的存储服务自由更改，可能在测试期间使用模拟对象。主要缺点是额外的灵活性需要更复杂的交互。存储还可以负责其他任务，如搜索和过滤模型对象，或创建（工厂）新对象，存储将其插入数据库并交给控制器。

当谈到数据格式时，有许多选择，从非常简单的 CSV 到更复杂的数据库。一个简单的选择可以是 nosql 数据库，或者是 tinysql。无论你选择什么，重要的是对你的对象进行版本控制。对象通常被序列化为一系列字节流并写入磁盘。恢复意味着对字节字符串进行反序列化，并重建对象的最后状态。

ORM 模型

模型可以分布在网络上，并通过代理类访问，对剩余的主体没有或只有轻微的更改。

持久性层：专门针对模型的持久性服务（以便它们不包含这个逻辑本身）

# MVC 测试

## MVC 测试

详细说明异步组件在测试中的挑战

由于复杂视图带来的一个主要问题是测试的困难。视觉组件往往更难测试，因为它们需要模拟用户交互。工具包提供了以编程方式创建事件的技术，但它们的处理取决于事件循环的执行。其执行的阻塞性质使得在测试环境中变得不切实际。

测试 GUI 应用程序通常是复杂的，因为用户可能选择执行的交互数量很大。手动测试是繁琐且容易出错的，模拟用户事件可能会引发与其固有的异步性质以及结果的视觉性质相关的问题。

一种明智的方法是利用 MVC 结构来解决程序中的测试问题，可能是以编程方式，也可能是同步方式。

一般来说，您应该能够独立测试或甚至使用模型，而不依赖于控制器和视图。实际上，模型应该能够在没有任何控制器或视图的情况下工作。这是一个完全独立的层，没有任何依赖于 GUI 表示、小部件或应用更改的策略。如果不是这种情况，那么您有需要重构的代码异味。然而，这个规则也有例外情况。例如，假设您的模型代表绘图程序的状态。插入模型的形状是实际的图形形状对象，它们是图形化的，将责任分配给这些对象在视图上绘制自己是有意义的。这是实用的，但可能会适得其反：它要求对象了解如何在特定视图上绘制自己的细节，这意味着不同的视图可能不兼容。将表示责任分配给模型对象是一种罕见的情况，总是可以解决，例如将形状的数学描述（例如矩形的角）与绘图逻辑（例如在屏幕上绘制矩形的实际图形调用）分开，并将这种绘图逻辑移动到一个渲染器类中。

一个视图适配器，在不了解模型的情况下对小部件进行操作。

模拟视图：它像普通视图一样附加到模型，但没有 GUI，可以被探测。装置模型：具有定义良好、已知数据的模型，可以附加到视图上。视图应该准确绘制我们从装置模型中知道的东西。

Microsoft 视觉测试发送事件，使用 xtest，或使用小部件级接口。由于布局变化而不定期出现的问题，运行屏幕保护程序。

异步测试往往很慢（您需要执行一个动作，然后等待可能会出现的结果，而且由于竞争条件的存在，结果可能会不定期地中断）。偏爱同步测试，限制异步。

难以测试的组件的测试应该是最小的，这些组件的行为也应该是最小的。

你可以通过将事件推送到 GUI 工具包事件队列来测试图形组件，但它们往往很脆弱和异步。

Watir, WatiN, Selenium

# 事件驱动编程

# 与事件循环的交互

直到现在，关于事件分发机制和事件循环的提及非常有限：我们对 UI 事件如何传递到视图/控制器一直一无所知。在接下来的页面中，我们将研究事件是如何分发的，以及分发机制与 MVC 之间的正确协同作用有多重要。

用最简单的术语来说，基于事件驱动的 UI 程序是建立在事件循环之上的。这个无限循环通常执行以下操作：

1.  等待低级事件，比如鼠标点击、按键按下，或者来自窗口系统的显示请求。

1.  将这些事件放入队列中

1.  完全[](GLOSSARY.html)消耗[](GLOSSARY.html)队列，并将[](GLOSSARY.html)事件分派给适当的处理程序（例如，当前焦点在[](GLOSSARY.html)小部件上的方法）。在这个阶段，线程将遍历，除其他事项外，您的 MVC。

1.  返回 1。

此循环由程序的主线程执行，然后

在事件循环的单次迭代期间执行可能非常复杂，并遍历您的 MVC 应用程序的复杂通知网络。事件处理程序在所有情况下都是原子的。当它开始时，它是您代码中唯一会被执行的部分，并且将完全运行而不会被中断的机会。因此，对于应用程序能够响应等待在循环的下一个迭代中的后续事件至关重要，事件在 200 毫秒内完全处理。

这一要求的后果是，您的 MVC 代码中任何阻塞执行线程的内容都将阻止事件循环的运行，并将减慢或冻结您的应用程序，提供次优的用户体验。

发生上述情况的示例包括以下情况：

+   初始化网络连接（可能会阻塞直到达到超时）。

+   等待状态机切换状态（例如变为空闲）。

+   长时间运行的计算。

+   从磁盘或网络连接读取或写入大文件。

+   运行[](GLOSSARY.html)必须受控制的外部进程，或者必须解析其 stdout 的进程。

您可以将事件循环视为协作式多任务系统。协作式多任务系统是一种允许多个任务运行的系统，只要每个任务在完成时放弃控制，让其他任务有机会运行。

为保持界面的响应性，当事件处理程序需要等待时，必须在程序中创建一个辅助执行线程。主线程生成辅助线程。辅助线程执行长时间运行的任务，而主线程可以返回到事件队列并继续处理事件。这种解决方案现在面临以下困难：

+   辅助线程必须向主线程通知其完成情况，无论是成功还是出现错误条件。

+   辅助线程必须与主线程良好交互。两个线程可以访问相同的共享状态，因此需要同步。

+   作为上述的推论，次要线程不应调用事件循环或主线程基本负责的任何代码（例如 UI 处理），因为它可能不是线程安全的设计。

+   次要线程可能会通过 MVC（例如，通过修改模型状态）触发通知。通知将传播到 View 和 Controller 类，这可能涉及 UI，而 UI 又不是为次要线程设计的。

正如[词汇表](https://wiki.example.org/glossary.html)所示，处理事件驱动系统中的多线程并不是一件简单的事情。

与上述所述的替代方法是挂起执行。该概念要求语言支持挂起例程的执行并将控制权交还给调用者。当恢复挂起的例程时，它将从离开的地方继续执行。

暂停执行允许处理程序将控制权交还给事件循环，允许其他事件被处理，并在原地重新启动。这种方法有以下缺点

+   它需要语言支持（例如 python 中的 yield 关键字）。

+   事件处理程序[](GLOSSARY.html)不再是原子的。处理其他事件可能意味着重新启动处理程序现在正在处理可能不再一致的状态。可以将 yield 点视为任何代码可以任意执行的点。

+   不能解决阻塞调用，但如果可暂停任务可以分解成块，其中一个可以定期放弃控制（例如循环），则可能允许事件处理。

这种方法相当于在 yield 点手动调用 processEvents。

对于[GLOSSARY.html]阻塞[GLOSSARY.html]调用，理想的解决方案将是有一个充当非阻塞并在完成时通知的例程。这是回调的情况，一个在次要线程完成任务时被调用的例程。这种方法最常见的问题是回调也将在次要线程中执行，因此通常无法执行可能与主线程冲突的任何操作。建议的行动方向是，现在运行回调的次要线程通过事件通知主线程。事件队列实现通常意识到这种需求，因此是线程安全。

* * *

MVC 被认为是一种独立的设计方法，没有太多考虑事件系统。严格来说，MVC 不需要事件循环，但其有用性将受到严重限制。

解释 MVC 如何自然地以事件驱动模型结束。解释调试的复杂性（例如，所有回溯都来自事件循环）

行为不再仅仅由代码表征。新兴行为源于对象之间潜在的异步交互，通过事件进行通信。通信网络是可变的。这导致设计变得极其复杂，难以理解，难以调试。

解决这个问题？一个解决方案是生成另一个线程，并让这个其他线程执行繁重、长时间运行的工作，而主线程则返回到事件循环并继续处理事件。但多线程编程很困难，而基于事件驱动的多线程编程更是如此。因此，理想情况下，你会更倾向于只有一个线程，但当它遇到长时间运行的任务时，你可以使用一个技巧来暂停执行点，并稍后恢复它，当长时间运行的任务完成时，或者也许你想分步进行，每一步都很短，但合在一起运行了很长时间。yield 关键字，因此生成器，恰好提供了这种精确的服务：暂停某事并稍后从你离开的地方恢复它。当你达到 yield 时，主线程现在可以返回到事件循环，并继续处理事件。在某种程度上，当执行被暂停等待长时间运行的事物时，会有一些魔法，以便当长时间运行的事物完成时，线程会知道并返回到被暂停的地方。这可以通过一个辅助线程或主线程本身来实现：当它没有要处理的事件时，它会处理长时间运行的任务，也许稍后再次暂停一会。你看到的就是所谓的协作（或合作）多任务处理。事件循环基本上是一个“内核”，而 yield 点相当于对“内核”进行“系统调用”。在这些 yield 点，控制权被返回给内核，现在内核可以自由运行其他东西，交错处理所有处理并保持事件处理活动，而不是被困在一个特定的处理程序中。请注意，这种机制需要协作：各个处理程序必须让出控制权以通知“内核”“我还没有完成这里的工作，但让别人有机会继续”。这与抢占式多任务处理相比，后者是内核在说：“就这样了，你玩够了，让别人接着去吧”，这就是现代真实内核所做的。因此，asyncio 是一种事件循环和协作多任务处理的形式，允许事件驱动的编程，而无需应用程序无响应或处理多个线程、回调和所有由此产生的恐怖在事件驱动环境中处理。

# 避免抖动

为了避免与许多通知一起出现抖动，有三种策略：

```
- disable notifications, to the operations, re-enable the notifications.
  this has the disadavantage that you might not know what notifications to 
  send when they are re-enabled. One solution could be to spool them,
  and at re-enable, merge the duplicates and send out the minimum.
- have coarse grained operations, operating on large sets and sending out 
  only one notification at the end.
- Have fine grained modification routines with an option notify that allows
  to decide when to send the notification and when not to.
- Have the model be a centralizer of the notification delivery, but have notifyObserver called
  externally. 
- have a smart signal that can be put in a "trasaction on" mode, and accumulates the
  notifications, and then release the notification when a "commit" is issued 
```

# 验证

# 验证

谁执行验证？视图？控制器？模型？模型内部数据的一致性？根据应用程序的不同，模型可以容纳无效数据（即对应用程序无效的数据）。

# 过期的监听器问题

# 过期的监听器问题

通知系统引入了一个潜在的内存泄漏问题，称为“过期监听器问题”。当监听器注册到通知器，然后在不取消订阅的情况下超出范围时，就会发生这种情况。由于通知连接的永久性，监听器永远不会被垃圾回收。从技术上讲，它仍在接收通知，如果这些通知很昂贵，则可能会引入额外的问题。在没有垃圾回收的语言中，如果删除了监听器，则通知器现在可能会持有对已释放内存的引用，可能导致崩溃。

有各种选项来解决这个问题。第一种是确保监听器在超出范围或释放之前正确注销。

第二个选项是使用弱引用来建立通知系统。

问题也可能存在于闭包回调或存储异常的情况下。

# 发布者订阅者

# 事件总线/发布订阅

发布者和订阅者之间完全解耦。发布者不知道订阅者，反之亦然。消息是从发送者发送到接收者。接收者无法“回复”给发送者。

例如，wxpython 提供了发布订阅模型的一个很好的例子。

```
 import wx
    from wx.lib.pubsub import Publisher

    class Model:
        def __init__(self):
            self.myMoney = 0

        def addMoney(self, value):
            self.myMoney += value
            Publisher.sendMessage("MONEY CHANGED", self.myMoney) 
```

对于对通知感兴趣的对象，现在可以订阅符合条件的通知如下。处理程序将收到一条带有适当信息的消息。

```
 class Controller:
        def __init__(self, app):
            # <...>
            pub.subscribe(self.moneyChangedHandler, "MONEY CHANGED")

        def moneyChangedHandler(self, message):
            """
            This method is the handler for "MONEY CHANGED" messages,
            which pubsub will call as messages are sent from the model.

            We already know the topic is "MONEY CHANGED", but if we
            didn't, message.topic would tell us.
            """
            self.view.setMoney(message.data) 
```

NSNotificationCenter 是一个发布订阅模式。

+   解耦使得编译时检查变得无用。

+   交付网络可能变得复杂。不正确的设置可能导致意外的监听器接收他们不应该接收的消息。应用程序流程难以理解和调试。

+   仅从代码中，很难发现发布者和订阅者之间的依赖关系，特别是当消息被发出和传递时。

+   交付可以是同步的或异步的，但即使是同步的，也不能依赖交付顺序。

+   消息源可能对接收者不可用。

使用主题将消息类型分组。

# 模型分布

# 模型分布

分片？

# 多线程

# 多线程

多线程问题。发送作为同一线程传递的通知。描述 Qt 如何通过事件循环处理交付，如果两个对象具有不同的线程亲和性。

不要生成线程。这样会使事情更难处理。使用线程池。

模型应该是同步的，这样你可以决定使用哪种线程策略。

有未来。

独立的[](GLOSSARY.html)线程[](GLOSSARY.html)可以[](GLOSSARY.html)独立运行，由在主（事件[](GLOSSARY.html)循环）线程中运行的代码产生。问题在于，它们所做的任何更改都可能通过网络传播，并触及当前由主线程处理的代码的部分。因此，处理这种情况的一般更好的方式是，次要线程以两种方式与主线程通信：

+   设置状态（使用锁进行同步）

+   将事件发布到事件循环中，以便主线程可以处理它们。

一旦触发事件，应用程序大约有 1/60 秒的时间将控制权返回给事件循环，这意味着对象/通知网络遍历必须迅速完成。如果任何事件触发了可能持续超过提到的时间的事情，它必须在一个单独的线程中执行，否则界面响应性将受到影响。拥有一个单独的线程带来了额外的怪癖：通常不能触及 UI 代码，必须同步。

FIXME 与异步单线程编程进行比较。放置一个有用的图片

# 通知循环预防

# 通知循环预防

模型中的通知消息可能因为一系列原因变得棘手

+   视图被通知发生了更改，但这是数据模型的一部分，没有由特定视图表示。即使对于它们没有数据更改，视图也必须经历刷新周期。

+   在模型上执行一系列更改，强制每次更改时刷新所有视图，而在序列结束时进行单次刷新就足够了。

+   更新-更改循环导致无限循环

考虑一个包含值 3 的 SpinBox 的情况，关联的模型值当前也设置为 3。当用户与 SpinBox 交互时，点击上箭头，发生以下事件序列：

1.  SpinBox 发出带有新值 4 的 valueChanged()信号。我们假设 SpinBox 仍然显示旧值，因为它代表的是此刻包含 3 的 Model。

1.  Controller.setValue(4)方法[](GLOSSARY.html)被调用，进而调用 Model.setValue(4)。

1.  模型[](GLOSSARY.html)存储[](GLOSSARY.html)新的值 4，然后发出 _notifyListeners[](GLOSSARY.html)通知所有连接的视图，包括 SpinBox。

1.  SpinBox 接收到 notify()，现在从 Model 中获取新的值，并使用 QSpinBox.setValue(4)设置新的值。

1.  SpinBox 仍然包含值 3。QSpinBox.setValue(4)再次触发 valueChanged()。

1.  Controller.setValue[](GLOSSARY.html)再次被调用，重新产生了点 2 的情况。

使用[](GLOSSARY.html)这个[](GLOSSARY.html)场景，应用程序[](GLOSSARY.html)可能进入了一个潜在的通知循环。一个预防策略是让模型仅在新值与当前存储的值不同时通知侦听器。这个解决方案将在第 3 点终止，从技术上执行无用的 Controller.setValue 和 Model.setValue 调用。一个诱人的替代解决方案是让 SpinBox 独立于模型增加其可视化值，从而使视图在其可视化状态中自主。采用这种方法后，步骤 1 之后 SpinBox 将显示数字 4。事件链将以完全相同的方式展开，直到第 4 步。SpinBox 现在将观察到模型中的新值与其当前显示的值相同，通过不触发 valueChanged()来终止链。根据所使用的工具包，图形视图可能会或可能不会按照描述的方式行为，但这种方法的根本问题是视图假定知道下一个值，并相应地设置它，而不涉及控制器或模型的任何逻辑。例如，模型可以考虑新值 4 为无效，并将自身设置为下一个有效值，例如 27。这将强制视图再次更新其图形表示。

另一个策略是防止视图在同一事件循环中更新两次。这种策略的一个可能实现是在视图上保持一个更新标志。该标志在第 1 步设置为 True。事件链以相同方式发展，直到第 5 步，在那里 setValue 操作将检查标志。如果为真，它将仅更新小部件的图形方面，并跳过触发第二个 valueChanged()信号。另一种策略是在某些条件下不触发 valueChanged 的视图。

关闭模型通知系统？这不是一个好主意。其他方将不会收到事件。另一个选择是从通知中分离视图。它不会接收来自模型的更新通知，只是设置数值。它不会看到来自外部的模型变化。

为了防止通知垃圾，可以依赖事务，关闭模型上的通知，执行一系列更改，然后通过关闭事务来触发通知。当必须按顺序在模型上执行多个独立的修改时，有一个方法来禁用和启用通知是值得的。没有这种技术，每个单独的更改都会触发更新并强制刷新连接的视图，可能破坏性能并使用户通过界面逐步暴露于逐个更改的变化。通过禁用通知，执行更改，然后重新启用通知，将触发单个更新。模型打包多个更改以向视图控制器提供单个刷新，禁用模型的通知。

FIXME: 另一个例子：

一个视图有两个方法，一个是将小部件内容存储在模型中，另一个是从模型中获取数据并将其存储在小部件中。如果 widget.setValue(model.value)触发通知并请求同步（通常在用户写入值时发生），我们需要在调用 modelToWidget()方法时禁用通知，否则它将触发通知到模型中，可能再次调用 modelToWidget()。

我们通常会在 modelToWidget()方法中跳过这一步，通过在其中设置一个标志来阻止递归，如果设置为 true，则立即退出，或者禁用小部件的通知以进行同步。为此制作一个代码示例

# 延迟模型

# 延迟模型

FIXME：异步。将这个移到高级模式中。

### 动机

每次模型发生变化时，视图必须根据新数据进行刷新。这一步骤可能会耗费时间。如果模型在很短的时间内经历了许多变化，短于刷新视图所需的时间，我们可能不希望视图跟随变化。这种机制被称为“防抖”。

我们可以在视图端或模型端中和解这些快速的模型变化。

# 设计

模型持有一个定时器。每当对模型进行更改且定时器未运行时，定时器就会启动。在定时器到期之前，不会向视图发出任何通知。

![](img/delayed_model.png)

由于定时器是异步的，必须特别小心确保在模型正在进行另一个更改时不要传递事件。

在[](GLOSSARY.html)这两种情况下，如果新的更改与先前的更改重叠，旧的更改可以被丢弃（因为它永远不会出现在视图中）。否则，如果通知是合格的，两个更改可以合并。如果不合格，那么当视图最终在计时器结束时被通知时，它将获得当前状态。

# 节流

# 节流

### 动机

类似于去抖动，但通知会立即发出，然后直到计时器到期才会再次发出。然而，在计时器结束时，必须执行检查，如果当前值与首次通知时发出的值不同。如果不同，必须发出新的最终通知，否则视图将与模型不同步。
