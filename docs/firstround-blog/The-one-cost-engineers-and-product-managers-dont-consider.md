# 造价工程师和产品经理不考虑的问题

> 原文：<https://review.firstround.com/The-one-cost-engineers-and-product-managers-dont-consider>

*Yammer 工程副总裁 Kris Gale 最近参加了我们的第一轮首席技术官峰会，他关于“* *[为什么传统的工程组织结构已死”的演讲让所有人大吃一惊。](http://firstround.com/article/Why-Yammer-believes-the-traditional-engineering-organizational-structure-is-dead "null")* *“他现在带着一篇关于功能如何在工程组织中产生复杂性成本的新文章回到第二轮。*

我谈了很多关于成本的问题。我相信好的工程就是找到解决问题的最具成本效益的方案，无论这种成本是以美元、时间、士气还是失去的机会来衡量的。有些成本是立即支付的，有些被认为是债务。商业中的每个人都凭直觉知道这一点，但有些成本没有其他成本那么明显，因此向您的团队指出这些成本非常重要。

其中最危险的未被考虑的成本是我所说的复杂性成本。复杂性成本是您为了解决问题而将功能或技术复杂化所累积的债务。做二十件事的应用程序比做一件事的应用程序更难重构，所以对代码的修改需要更长的时间。有时复杂性是必要的成本，但是只有完全内化了这一概念的组织才有希望防止这一领域的开支失控。

多年来，从产品经理那里听到的最让我沮丧的两件事是“这有多难……”还有“你就不能……”我花了很长时间才明白为什么我对这些短语有如此强烈的本能反应。现在，答案似乎很明显:最初实现一个特性的工作通常只是在产品生命周期中支持该特性的工作的一小部分，是的，我们可以“只是”编写某人想出来的任何逻辑。现在可能需要两周的时间会增加我们将来在这个产品上进行的每个工程项目的边际成本。事实上，我认为在权衡一个特性的成本和收益时，实现该特性的初始时间是最不值得考虑的数据点之一。

从长远来看，往往是细微的或有意隐藏的功能花费最大。Yammer 很早就有一个功能，允许你以“to:”和用户名开始一条消息，向某人发送私人消息，或者后跟一个组名，向一个组发布消息。在 2008 年初，我大概花了一个小时来实现、测试和部署。在这中间的 5 年里，我轻而易举地花了 40 个小时的时间——当然还有其他人的 40 个小时——来解释这一特性及其合理性。即使在我们考虑一旦人们进入代码对他们的影响之前，仅仅是实现这个特性就要花费 40 倍的通信开销。您可能认为文档解决了这个问题，但是我向您保证这在代码中有很好的记录...某处。

一旦你进入代码，复杂性的代价就会变得更加明显。当你第一次打开一个新的代码段时，你需要确定自己的方向。代码做的事情越少，这个过程就越快。如果代码做了很多事情，即使是分解良好、编写良好、干净的代码也需要一段时间才能熟悉。任何遗漏都会造成以后的返工:也许你破坏了一个单元测试；也许你不知道，代码被报告错误的用户发现了，甚至在它回来花费你更多时间之前，就花费了你的支持或 QA 团队的时间。

Yammer 的前产品主管吉姆·帕特森(Jim Patterson)将他的团队的使命确立为加速开发团队。他特别谈到了找出让产品经理和工程师在承担复杂性成本上达成一致的方法。这就是你的产品团队和开发团队之间需要的那种关系。每个人都拥有速度，你的工程团队的速度中最不重要的因素是每个人工作的努力程度。开发人员需要公开讨论他们现在正在支付的复杂性成本，他们担心他们正在采用拟议的规格，并提出可以降低复杂性的替代产品设计。

如果你能降低复杂性成本，你的 QA 和客户服务团队将会更有效率。如果产品的某个区域有两个相互作用的开关，那么有 4 种状态(关-关、开-开、关-开、开-关)必须测试，并且在与客户解决问题时必须理解。如果它有三个开关，你就有 8 种状态。四等于十六。第三个切换增加了 4 个状态，可能和第四个切换一样容易规范和实现，第四个切换增加了 8 个状态。第六次切换也是如此，它增加了 32 个状态。再问一次，“增加这个开关有多难？”表现出对总成本缺乏了解。"这个开关会变得多复杂？"让我们更接近正确的讨论。

一个需要完全从工程团队中驱逐出去的复杂性成本的病态例子，是我见过的人们将 bug 作为特性的奇怪习惯。这通常是这样工作的:原始需求中没有定义的情况下的行为最终会根据附带的实现决策以某种方式工作。最终，用户会发现并适应这些东西，并会在逻辑改变时报告错误，尽管事实上没有人有意将用户期望的行为设计到系统中。我看到过新重构的系统被奇怪的 if/then 条件填充，以显式地添加行为，这些行为曾经是以前实现的隐式副作用。这允许熵成为你的产品经理，并承担复杂性债务。对抗这种本能。你的产品管理、质量保证和开发团队应该运用判断力来决定什么应该继续存在，而不是盲目地添加过去存在的一切。

用户也不想要复杂。除非你有独特的纪律性并热衷于保持产品的简单性，否则你会发现你的绝大多数用户都在使用你的一小部分功能。当你给你的产品添加东西的时候，用户也会以认知开销的形式付出复杂性的代价。你可能认为你已经找到了一种免费获得复杂性的方法，通过制造这些隐藏的或高级的特性，但是你在欺骗你自己。我数不清有多少次不知何故触发了软件中的一个隐藏功能，结果却花了令人讨厌的大量时间试图弄清楚发生了什么或如何恢复它。

在产品方面，消除复杂性成本的最佳工具是数据。研究表明，大多数产品创意都没有显示出价值，许多创意甚至去除了价值。如果您系统地测试您所做的每个变更的影响，您可以丢弃那些负面的，但是同样与复杂性成本相关的，也可以丢弃那些中性的。不损害关键性能指标的变更仍然会损害产品，因为它增加了所有未来项目必须支付的复杂性债务。通常，对一个产品来说最好的事情就是从它身上拿走一些东西。

除了确定变化的影响，数据还可以帮助您随着时间的推移降低复杂性。你的所有功能都应该记录它们的使用情况，并且这种使用情况必须对每个人都是透明的。告诉你的团队在哪里可以找到这些数据，如果不清楚的话，给他们询问如何解释的方法。在 Yammer，几乎每个特性的数据都被收集起来，并提供给每个人，我多次看到这种模式:一个开发人员在代码的一个区域工作，发现在重构或其他更改中将一个特性向前推进需要花费大量的时间。他或她不是盲目地承担这项工作，而是根据使用数据运行报告，以找出某个给定的特性是否经常被使用。这些数据可以交给产品经理，他们可以帮助决定放弃这个特性是否明智。这还可以在某件事情成为提案之前节省时间，因为产品经理会从询问他们打算增强的功能领域的使用情况开始。许多看起来很棒的想法被证明是浪费时间，复杂性被保留了下来。

培训你的整个工程部门，让他们了解复杂性成本，并利用数据来降低成本。

复杂性也是由善意的人在实现方面引入的。软件开发人员喜欢挑战，而构建一个提供简单界面的复杂系统的挑战尤其诱人。考虑 DSL、抽象以及成为构建一个多年来都可以利用的框架的人的吸引力。这促使我们引入了巨大的复杂性债务，我们用“一旦你理解了，它就变得如此简单”和“它将为我们节省如此多的编码”这样的陈述来辩护编写代码很少是工程中的大成本:它是理解、交流和维护。

在你的工程中拥抱简单。最好的工程通常不炫耀或看起来很强烈。给定相同的结果，越简单的代码对您的组织越有价值。这通常会让人们的自尊心感到不满意，但是最好的工程师没有什么需要证明的。我记得在我职业生涯的早期，我陶醉于我项目的文档部分。对于花时间阅读所有这些伟大文档的人来说，这是一个吹嘘代码有多聪明、它能做多少事情以及它有多容易扩展的机会。当我在白板上用方框、箭头和线条画出我设计的复杂系统时，我简直要晕了。我确信这些文件和插图证明了我是一名真正的工程师。当我真的成为一名真正的工程师时，我意识到我能建造的东西越简单，它需要的文档和插图越少，我的同事就越好——我们能更快地建造我们被雇来建造的东西。

在你的产品和代码中拥抱简单。价值在于使用了什么，而不是构建了什么。

即使在你的交流中也要拥抱简单。推行行话、缩略语和夸大描述的文化。庆祝简单有效的沟通。你最好的人能向孩子解释你的组织所做的一切。你认为最糟糕的人是那些听起来很聪明、很官方，却不被广泛理解的人。

简单性是一个非常困难的工程挑战，但是随着时间的推移，复杂性会像兴趣一样增加。不保持简单，你将永远赶不上那些试图扰乱你的竞争对手。确保你的整个团队都知道这一点。