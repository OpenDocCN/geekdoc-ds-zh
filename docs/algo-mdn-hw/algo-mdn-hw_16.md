# 吞吐量计算

> 原文：[`en.algorithmica.org/hpc/pipelining/throughput/`](https://en.algorithmica.org/hpc/pipelining/throughput/)

优化**延迟**通常与优化**吞吐量**有很大不同：

+   当优化数据结构查询或小型一次性或分支算法时，你需要查找其指令的延迟，心理构建计算的执行图，然后尝试重新组织它，使关键路径更短。

+   在优化热点循环和大数据集算法时，你需要查找它们的指令的吞吐量，计算每个指令在每个迭代中被使用的次数，确定哪个是瓶颈，然后尝试重构循环，使其使用频率更低。

最后一条建议仅适用于**数据并行**循环，其中每次迭代完全独立于前一次迭代。当连续迭代之间存在某些依赖关系时，可能会由于下一个迭代正在等待前一个迭代完成而出现由数据冒险引起的潜在流水线停滞。

### [#](https://en.algorithmica.org/hpc/pipelining/throughput/#example)示例

以一个简单的例子，考虑如何计算一个数组的和：

```cpp
int s = 0;   for (int i = 0; i < n; i++)  s += a[i]; 
```

让我们暂时假设编译器没有对这个循环进行向量化，内存带宽不是问题，并且循环被展开，这样我们就不必为维护循环变量支付任何额外的成本。在这种情况下，计算变得非常简单：

```cpp
int s = 0; s += a[0]; s += a[1]; s += a[2]; s += a[3]; // ... 
```

我们能有多快地计算这个？正好是每个元素一个周期——因为我们需要每个周期一个周期来将另一个值加到`s`上。内存读取的延迟并不重要，因为 CPU 可以在之前启动它。

但我们可以做得更好。`add`^(1)的吞吐量在我的 CPU（Zen 2）上是 2，这意味着理论上我们可以在每个周期执行两个。但现在这还不可能：当`s`被用来累加第 i 个元素时，它至少在一个周期内不能用于第(i+1)个。

解决方案是使用**两个**累加器，并分别单独求和奇数和偶数元素：

```cpp
int s0 = 0, s1 = 0; s0 += a[0]; s1 += a[1]; s0 += a[2]; s1 += a[3]; // ... int s = s0 + s1; 
```

现在我们的超标量 CPU 可以同时执行这两个“线程”，我们的计算不再有任何限制吞吐量的关键路径。

### [#](https://en.algorithmica.org/hpc/pipelining/throughput/#the-general-case)一般情况

如果一个指令的延迟是$x$，吞吐量是$y$，那么你需要使用$x \cdot y$个累加器来饱和它。这也意味着你需要$x \cdot y$个逻辑寄存器来保存它们的值，这对于 CPU 设计来说是一个重要的考虑因素，限制了高延迟指令可用的最大执行单元数量。

这种技术主要与 SIMD 一起使用，而不是在标量代码中使用。你可以 泛化 上述代码，并比编译器更快地计算总和和其他缩减操作。

通常在优化循环时，你通常只有一个或几个你想要充分利用的 *执行端口*，然后你围绕它们设计循环的其余部分。由于不同的指令可能使用不同的端口集，因此并不总是清楚哪个会被过度使用。在这种情况下，机器代码分析器 可以非常有助于找到小型汇编循环的瓶颈。

* * *

1.  寄存器到寄存器的 `add` 操作的吞吐量是 4，但由于我们从内存中读取其第二个操作数，它被内存 `mov` 的吞吐量所瓶颈，Zen 2 上的吞吐量是 2。↩︎ [← 指令表](https://en.algorithmica.org/hpc/pipelining/tables/)[../编译 →](https://en.algorithmica.org/hpc/compilation/)
