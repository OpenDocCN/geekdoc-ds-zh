# 模运算

> 原文：[`en.algorithmica.org/hpc/number-theory/modular/`](https://en.algorithmica.org/hpc/number-theory/modular/)

计算机通常将时间存储为自 1970 年 1 月 1 日以来经过的秒数——即“Unix 时代”的开始——并在所有与时间相关的计算中使用这些时间戳。

我们人类也根据过去某个点来追踪时间，这通常具有政治或宗教意义。例如，在写作的时刻，自公元 1 年以来大约已经过去了 63882260594 秒——这是[6 世纪东罗马僧侣对耶稣基督出生日的最佳估计](https://en.wikipedia.org/wiki/Anno_Domini)。

但与计算机不同，我们并不总是需要所有这些信息。根据手头的任务，相关的部分可能是现在正是下午 2 点，是时候去吃晚餐了；或者今天是星期四，因此 Subway 的当日三明治是意大利 BMT。我们不用整个时间戳，而是使用其*余数*，它只包含我们需要的信息：处理 1 位或 2 位数字比处理 11 位数字要容易得多。

**问题**。今天是星期四。一年后将是星期几？

如果我们按顺序从星期一开始，编号从$0$到$6$，星期四的编号是$3$。为了找出一年后将是什么星期，我们需要将$365$加到它上面，然后对$7$取模。方便的是，$365 \bmod 7 = 1$，所以我们知道除非是闰年（在这种情况下将是星期六），否则它将是星期五。

### [余数](https://en.algorithmica.org/hpc/number-theory/modular/#residues)

**定义**。如果整数$a$和$b$的差能被$m$整除，则称这两个整数在模$m$下是**同余**的。

$$ m \mid (a - b) \; \Longleftrightarrow \; a \equiv b \pmod m $$

例如，一年的第 42 天与第 161 天的星期几相同，因为$(161 - 42) = 119 = 17 \times 7$。

模$m$的同余是一个等价关系，它将所有整数分成称为**余数**的等价类。模$m$的每个余数类可以用其任何一个成员来表示——尽管我们通常使用该类中最小的非负整数（对于所有非负$x$等于余数$x \bmod m$）。

*模运算*研究这些余数集合，这些集合对于数论是基本的。

**问题**。我们的“周”现在由$m$天组成，我们的年由$a$天组成（没有闰年）。从现在起一年、两年、三年等等，将有多少不同的星期天？

为了简单起见，假设今天是星期一，因此初始天数$d_0$为零，并且每年之后，它变为

$$ d_{k + 1} = (d_k + a) \bmod m $$ 经过 $k$ 年后，它将是 $$ d_k = k \cdot a \bmod m $$ 由于一周只有 $m$ 天，所以某个时刻，星期一将再次出现，并且天数序列将会循环。不同天数的天数是循环的长度，因此我们需要找到最小的 $k$ 使得 $$ k \cdot a \equiv 0 \pmod m $$

首先，如果 $a \equiv 0$，它将是永恒的星期一。现在，假设非平凡情况 $a \not \equiv 0$：

+   对于一周七天的星期，$m = 7$ 是质数。没有小于 $m$ 的 $k$ 使得 $k \cdot a$ 能被 $m$ 整除，因为根据质数的定义，$m$ 不能通过这样的乘积分解。所以，如果 $m$ 是质数，我们将循环遍历所有的 $m$ 个工作日。

+   如果 $m$ 不是质数，但 $a$ 与它 *互质*（即 $a$ 和 $m$ 没有公约数），那么答案仍然是 $m$，原因相同：$a$ 的因子不会帮助更快地将乘积归零。

+   如果 $a$ 和 $m$ 有一些共同的因子，那么只能得到也是这些因子倍数的余数。例如，如果一周是 $m = 10$ 天，而一年有 $a = 42$ 天或任何其他偶数天，那么我们将循环遍历所有偶数天数，如果天数是 $5$ 的倍数，那么我们将在 $0$ 和 $5$ 之间摆动。否则，我们将遍历所有的 $10$ 个余数。

因此，一般来说，答案是 $\frac{m}{\gcd(a, m)}$，其中 $\gcd(a, m)$ 是 $a$ 和 $m$ 的 最大公约数。

### [#](https://en.algorithmica.org/hpc/number-theory/modular/#fermats-theorem)费马定理

现在，考虑如果我们不是加一个数 $a$，而是反复乘以它，写出一系列

$$ d_n = a^n \bmod m $$

再次，由于余数是有限的，所以必然会有一个循环。但它的长度是多少呢？结果是，如果 $m$ 是质数，它将覆盖所有 $(m - 1)$ 个非零余数。

**定理**。对于任何 $a$ 和质数 $p$：

$$ a^p \equiv a \pmod p $$ **证明**。设 $P(x_1, x_2, \ldots, x_n) = \frac{k}{\prod (x_i!)}$ 为 *多项式系数*：在 $(a_1 + a_2 + \ldots + a_n)^k$ 展开后，元素 $a_1^{x_1} a_2^{x_2} \ldots a_n^{x_n}$ 出现的次数。那么：$$ \begin{aligned} a^p &= (\underbrace{1+1+\ldots+1+1}_\text{$a$ 次})^p & \\\ &= \sum_{x_1+x_2+\ldots+x_a = p} P(x_1, x_2, \ldots, x_a) & \text{(根据定义)} \\\ &= \sum_{x_1+x_2+\ldots+x_a = p} \frac{p!}{x_1! x_2! \ldots x_a!} & \text{(哪些项不能被 $p$ 整除？)} \\\ &\equiv P(p, 0, \ldots, 0) + \ldots + P(0, 0, \ldots, p) & \text{(其他所有项都将被抵消)} \\\ &= a \end{aligned} $$

注意，这仅对质数 $p$ 成立。我们可以利用这个事实来更快地测试一个给定的数是否为质数，而不是通过分解它：我们可以随机选择一个数 $a$，计算 $a^{p} \bmod p$，并检查它是否等于 $a$。

这被称为 *费马素性测试*，它是概率性的——只返回“否”或“可能”——因为可能 $a^p$ 只是恰好等于 $a$，尽管 $p$ 是合数，在这种情况下，你需要用不同的随机 $a$ 重复测试，直到你对假阳性概率满意。

素性测试通常用于生成大素数（用于加密目的）。在第一个 $n$ 个数中大约有 $\frac{n}{\ln n}$ 个素数（我们不会证明这个事实），它们的分布相对均匀。一个人可以从所需范围内随机选择一个数，执行素性检查，直到找到一个素数，平均进行 $O(\ln n)$ 次试验。

费马测试的一个极其糟糕的输入是 [卡迈克尔数](https://en.wikipedia.org/wiki/Carmichael_number)，这些是满足对于所有互质的 $a$ 有 $a^{n-1} \equiv 1 \pmod n$ 的合数 $n$。但它们是 [罕见的](https://oeis.org/A002997)，随机遇到它们的概率很低。

### [#](https://en.algorithmica.org/hpc/number-theory/modular/#modular-division)模除法

使用余数实现大多数“正常”的算术运算很简单。你只需要注意整数溢出并记得取模：

```cpp
c = (a + b) % m; c = (a - b + m) % m; c = a * b % m; 
```

但在除法方面有一个问题：我们不能简单地除以两个余数。例如，$\frac{8}{2} = 4$，但

$$ \frac{8 \bmod 5}{2 \bmod 5} = \frac{3}{2} \neq 4 $$ 要执行模除，我们需要找到一个“作用”像倒数 $\frac{1}{a} = a^{-1}$ 的元素，并乘以它。这个元素被称为 *模乘法逆元*，当模 $p$ 是素数时，费马定理可以帮助我们找到它。当我们用 $a$ 除其等价两次时，我们得到：$$ a^p \equiv a \implies a^{p-1} \equiv 1 \implies a^{p-2} \equiv a^{-1} $$ 因此，$a^{p-2}$ 对于乘法来说就像 $a^{-1}$，这正是我们从 $a$ 的模逆元中需要的。[← ../数论](https://en.algorithmica.org/hpc/number-theory/)[二进制指数运算 →](https://en.algorithmica.org/hpc/number-theory/exponentiation/)
