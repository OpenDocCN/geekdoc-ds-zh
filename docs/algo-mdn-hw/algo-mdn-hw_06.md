# 汇编语言

> 原文：[`en.algorithmica.org/hpc/architecture/assembly/`](https://en.algorithmica.org/hpc/architecture/assembly/)

CPU 使用*机器语言*进行控制，它只是一串二进制编码的指令，用于指定

+   指令编号（称为*操作码*），

+   它的*操作数*是什么（如果有），

+   以及*结果*存储的位置（如果产生了结果）。

一种更符合人类习惯的机器语言版本，称为*汇编语言*，使用助记符来引用机器代码指令，并使用符号名称来引用寄存器和其他存储位置。

直接进入主题，以下是如何在 Arm 汇编中添加两个数字（`*c = *a + *b`）的示例：

```cpp
; *a = x0, *b = x1, *c = x2 ldr w0, [x0]    ; load 4 bytes from wherever x0 points into w0 ldr w1, [x1]    ; load 4 bytes from wherever x1 points into w1 add w0, w0, w1  ; add w0 with w1 and save the result to w0 str w0, [x2]    ; write contents of w0 to wherever x2 points 
```

这是 x86 汇编中的相同操作：

```cpp
; *a = rsi, *b = rdi, *c = rdx mov eax, DWORD PTR [rsi]  ; load 4 bytes from wherever rsi points into eax add eax, DWORD PTR [rdi]  ; add whatever is stored at rdi to eax mov DWORD PTR [rdx], eax  ; write contents of eax to wherever rdx points 
```

汇编语言相对于高级编程语言来说非常简单，因为它不需要复杂。它尽可能地反映了机器语言，直到机器代码和汇编之间几乎达到 1:1 的对应。实际上，你可以使用称为*反汇编*的过程将任何编译程序转换回其汇编形式——尽管非必要的内容，如注释将不会被保留。

+   程序是一系列指令的序列，每个指令都按照其名称后跟可变数量的操作数来编写。

+   `[reg]`语法用于“解引用”存储在寄存器中的指针，在 x86 中，你需要在其前面加上大小信息（这里`DWORD`表示 32 位）。

+   `;`符号用于行注释，类似于其他语言中的`#`和`//`。

汇编语言是一种非常简单的语言，因为它需要尽可能接近机器语言。它反映了机器语言，直到几乎达到机器代码和汇编之间的 1:1 对应。实际上，你可以使用称为*反汇编*的过程将任何编译程序转换回其汇编形式——尽管非必要的内容，如注释将不会被保留。

注意，上述两个代码片段不仅在语法上不同。它们都是编译器产生的优化代码，但 Arm 版本使用了 4 条指令，而 x86 版本使用了 3 条。`add eax, [rdi]`指令被称为*融合指令*，它一次执行加载和加法操作——这是 CISC 方法可以提供的好处之一。

由于架构之间的差异远不止这一点，从现在开始，本书的其余部分我们将只提供 x86 架构的示例，这可能是我们大多数读者将优化的，尽管许多引入的概念将是架构无关的。

### [#](https://en.algorithmica.org/hpc/architecture/assembly/#instructions-and-registers)指令和寄存器

由于历史原因，大多数汇编语言中的指令助记符都非常简短。在人们手工编写汇编代码并反复编写相同的一组常见指令的时代，少打一个字符就少一步接近疯狂。

例如，`mov`用于“存储/加载一个字”，`inc`用于“加 1”，`mul`用于“乘法”，`idiv`用于“整数除法”。你可以通过名称在[一个 x86 参考](https://www.felixcloutier.com/x86/)中查找指令的描述，但大多数指令都做你想象中的事情。

大多数指令将它们的输出写入第一个操作数，这个操作数也可以像在之前的`add eax, [rdi]`示例中那样参与计算。操作数可以是寄存器、常量值或内存位置。

**寄存器**命名为`rax`、`rbx`、`rcx`、`rdx`、`rdi`、`rsi`、`rbp`、`rsp`和`r8`-`r15`，总共有 16 个。这些“字母”寄存器的命名是出于历史原因：`rax`是“累加器”，`rcx`是“计数器”，`rdx`是“数据”等等——但当然，它们不必仅用于这些。

还有 32 位、16 位和 8 位寄存器，它们有类似的名字（`rax` → `eax` → `ax` → `al`）。它们并不是完全独立的，而是**别名**：`rax`的最低 32 位是`eax`，`eax`的最低 16 位是`ax`，以此类推。这样做是为了节省芯片空间同时保持兼容性，这也是为什么编译编程语言中的基本类型转换通常是免费的。

这些只是一些**通用**寄存器，你可以在大多数指令中使用它们，有些例外，但你可以随意使用。还有一个专门的寄存器集用于浮点运算，一些非常宽的寄存器用于向量扩展，以及一些用于控制流的特殊寄存器，但我们会逐步了解。

**常量**只是整数或浮点值：`42`、`0x2a`、`3.14`、`6.02e23`。它们更常见地被称为**立即数**，因为它们直接嵌入到机器代码中。由于这可能会显著增加指令编码的复杂性，一些指令不支持立即数或只支持它们的固定子集。在某些情况下，你必须将常量值加载到寄存器中，然后使用它而不是立即数。

除了数值之外，还有字符串常量，如`hello`或`world\n`，它们有自己的小操作子集，但这汇编语言的一个相对不为人知的角落，我们在这里不会探讨。

### [#](https://en.algorithmica.org/hpc/architecture/assembly/#moving-data)移动数据

一些指令可能有相同的助记符，但操作数类型不同，在这种情况下，它们被视为不同的指令，因为它们可能执行稍微不同的操作，并且执行时间也不同。`mov`指令是一个很好的例子，它有大约 20 种形式，都与移动数据有关：要么在内存和寄存器之间，要么在两个寄存器之间。尽管名称如此，它并不是将值**移动**到寄存器中，而是**复制**它，保留原始值。

当用于在两个寄存器之间复制数据时，`mov` 指令内部实际上执行的是**寄存器重命名**——通知 CPU，由寄存器 X 指代的值实际上存储在寄存器 Y 中——除了可能读取和解析指令本身外，不会造成任何额外的延迟。同样地，用于交换两个寄存器的 `xchg` 指令也不会产生任何开销。

正如我们上面在融合的 `add` 指令中看到的，你不必为每个内存操作都使用 `mov`：一些算术指令方便地支持将内存位置作为操作数。

### [#](https://en.algorithmica.org/hpc/architecture/assembly/#addressing-modes)寻址模式

内存寻址使用 `[]` 操作符进行，但它不仅能将存储在寄存器中的值重新解释为内存位置。地址操作数最多可以包含 4 个参数，这些参数在语法中呈现：

```cpp
SIZE PTR [base + index * scale + displacement] 
```

其中 `displacement` 需要是一个整型常量，而 `scale` 可以是 2、4 或 8。它所做的计算是 `base + index * scale + displacement` 的指针，并对其进行解引用。

使用复杂寻址最多比直接解引用指针慢一个周期，并且当例如你有结构体数组并想要加载其第 $i$ 个元素的特定字段时，它可能很有用。

寻址操作符需要前缀一个大小指定符，以指明需要多少位的数据：

+   `BYTE` 用于 8 位

+   `WORD` 用于 16 位

+   `DWORD` 用于 32 位

+   `QWORD` 用于 64 位

还有更少见的 `TBYTE` 用于 80 位，以及 `XMMWORD`、`YMMWORD` 和 `ZMMWORD` 分别用于 128、256 和 512 位。所有这些类型不必全部大写，但这是大多数编译器生成它们的方式。

地址计算本身通常很有用：`lea`（“加载有效地址”）指令在一个周期内计算操作数的内存地址，并将其存储在寄存器中，而不进行任何实际的内存操作。虽然它的预期用途是实际计算内存地址，但它也经常用作一个算术技巧，否则将涉及 1 次乘法和 2 次加法——例如，你可以用它来乘以 3、5 和 9。

它还经常作为 `add` 的替代品，因为它不需要单独的 `mov` 指令，如果你需要将结果移动到其他地方：`add` 只能在两个寄存器的 `a += b` 模式下工作，而 `lea` 允许你做 `a = b + c`（或者如果其中一个是一个常数，甚至 `a = b + c + d`）。

### [#](https://en.algorithmica.org/hpc/architecture/assembly/#alternative-syntax)替代语法

实际上存在多个**汇编器**（从汇编代码生成机器代码的程序），它们使用不同的汇编语言，但现在广泛使用的只有两种 x86 语法。它们通常以使用它们的两个公司命名，并在那个时代对编程产生了主导影响：

+   默认使用的 *AT&T 语法，由所有 Linux 工具使用。

+   默认使用的 *Intel 语法*，嗯，由 Intel 使用。

这些语法有时也分别被称为 *GAS* 和 *NASM*，分别以使用它们的两个主要汇编器的名称命名（*GNU Assembler* 和 *Netwide Assembler*）。

我们在本章中使用了 Intel 语法，并将继续在本书的其余部分优先使用它。为了比较，以下是在 AT&T 汇编中相同的 `*c = *a + *b` 示例的表示：

```cpp
movl (%rsi), %eax addl (%rdi), %eax movl %eax, (%rdx) 
```

关键区别可以总结如下：

1.  最后一个操作数用于指定目标。

1.  寄存器和常数需要分别以 `%` 和 `$` 前缀（例如，`addl $1, %rdx` 增加了 `rdx`）。

1.  内存寻址看起来像这样：`displacement(%base, %index, scale)`。

1.  `;` 和 `#` 都可以用作行注释，同时也可以使用 `/* */` 进行块注释。

并且，最重要的是，在 AT&T 语法中，指令名称需要“后缀” (`addq`, `movl`, `cmpq`, 等) 以指定正在操作的操作数的大小：

+   `b` = 字节（8 位）

+   `w` = 字（16 位）

+   `l` = 长度（32 位整数或 64 位浮点数）

+   `q` = 四倍（64 位）

+   `s` = 单个（32 位浮点数）

+   `t` = 十字节（80 位浮点数）

在 Intel 语法中，此信息是从操作数推断出来的（这也是为什么你还需要指定指针的大小）。

大多数生成或消费 x86 汇编的工具都可以使用这两种语法，所以你可以选择你更喜欢的一种，不必担心。

***

1.  在 Linux 上，要反汇编编译后的程序，你可以调用 `objdump -d {二进制文件路径}`。↑ [← 指令集架构](https://en.algorithmica.org/hpc/architecture/isa/)[循环和条件语句 →](https://en.algorithmica.org/hpc/architecture/loops/)
