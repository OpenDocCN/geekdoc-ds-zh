# 整数数

> 原文：[`en.algorithmica.org/hpc/arithmetic/integer/`](https://en.algorithmica.org/hpc/arithmetic/integer/)

如果你是从头开始顺序阅读这一章，你可能想知道：为什么在介绍浮点数之后要介绍整数算术？难道它不是应该更容易吗？

真的：纯整数表示更简单。但出人意料的是，它们的简单性使得可以用其他方式表达操作的可能性更多。而且，如果浮点数表示法如此难以处理，以至于大多数操作都在硬件中实现，那么高效地操作整数就需要更富有创造性的指令集使用。

## [#](https://en.algorithmica.org/hpc/arithmetic/integer/#binary-formats)二进制格式

*无符号整数*只是用二进制表示的自然数：

$$ \begin{aligned} 5_{10} &= 101_2 = 4 + 1 \\ 42_{10} &= 101010_2 = 32 + 8 + 2 \\ 256_{10} &= 100000000_2 = 2⁸ \end{aligned} $$

当一个操作的结果无法适应字大小（例如，对于 32 位无符号整数，结果大于或等于 $2^{32}$）时，它将只保留结果的最低 32 位，从而发生*溢出*。同样，如果结果是负值，它将通过加 $2^{32}$ 来*下溢*，这样它始终保持在 $[0, 2^{32})$ 范围内。

这相当于对所有操作执行模 2 的幂次运算：

$$ \begin{aligned} 256 &\equiv 0 \pmod {2⁸} \\ 2021 &\equiv 229 \pmod {2⁸} \\ -42 &\equiv 256 - 42 &\equiv 214 \pmod {2⁸} \end{aligned} $$

在任何情况下，它都会触发一个特殊的标志，你可以检查它，但通常当人们明确使用无符号整数时，他们期望这种行为。

### [#](https://en.algorithmica.org/hpc/arithmetic/integer/#signed-integers)有符号整数

*有符号整数*支持通过将最高位用于表示数字的符号来存储负值，这与浮点数类似。这减半了可表示的非负数的范围：现在可能的 32 位整数的最大值是 $(2^{31}-1)$，而不是 $(2^{32}-1)$。但负值的编码与浮点数并不完全相同。

计算机工程师甚至比程序员还懒惰——这不仅仅是由简化本能欲望所驱动，也是为了节省晶体管空间。这可以通过重用电路来实现，这些电路已经用于其他操作，这就是他们设计有符号整数格式时所追求的目标：

+   对于一个 $n$-位的带符号整数类型，$[0, 2^{n-1})$ 范围内所有数字的编码与它们的无符号二进制表示相同。

+   $[-2^{n-1}, 0)$ 范围内的所有数字都按顺序编码在“正数”范围之后——也就是说，从代码为 $(2^{n-1})$ 的 $(-2^{n - 1})$ 开始，到代码为 $(2^n - 1)$ 的 $(-1)$ 结束。

一种看待这个问题的方式是，所有负数都编码为从 $2^n$ 中减去——这是一种称为*二进制补码*的操作：

$$ \begin{aligned} -x &= 2^{32} - x \\ &= \bar{x} + 1 \end{aligned} $$

这里 $\bar{x}$ 代表位取反，也可以理解为从 $(2^n - 1)$ 中减去 $x$。

作为练习，以下是一些关于有符号整数的知识点：

+   所有正数和零都保持与它们的二进制表示相同。

+   所有负数都将最高位设置为 1。

+   负数的数量比正数的数量多（正好多一个——因为零）。

+   对于 `int`，如果你将 $1$ 加到 $(2^{31}-1)$ 上，结果将是 $-2^{31}$，表示为 `10000000`（为了说明目的，我们只写 8 位而不是 32 位）。

+   知道一个正数 `x` 的二进制表示，你可以得到 `-x` 的二进制表示为 `~x + 1`。

+   `-1` 表示为 `~1 + 1 = 11111110 + 00000001 = 11111111`。

+   `-42` 表示为 `~42 + 1 = 11010101 + 00000001 = 11010110`。

+   数字 `-1 = 11111111` 后面跟着 `0 = -1 + 1 = 11111111 + 00000001 = 00000000`。

这种编码的主要优势是，你不需要做任何事情就可以将无符号整数转换为有符号整数（也许需要检查溢出），并且你可以为大多数操作重用相同的电路，可能只需要翻转符号位来进行比较等操作。

话虽如此，你需要小心处理有符号整数的溢出。尽管它们几乎总是以与无符号整数相同的方式溢出，但编程语言通常将溢出视为未定义行为。如果你需要溢出整数变量，将它们转换为无符号整数：反正也是免费的。

**练习**。哪个整数值是 `std::abs` 产生错误结果的唯一值？这个结果会是什么？

### [#](https://en.algorithmica.org/hpc/arithmetic/integer/#integer-types) 整数类型

整数有不同的尺寸，但它们的功能大致相同。

| 比特 | 字节 | 有符号 C 类型 | 无符号 C 类型 | 汇编 |
| --- | --- | --- | --- | --- |
| 8 | 1 | `signed char`^(1) | `unsigned char` | `byte` |
| 16 | 2 | `short` | `unsigned short` | `word` |
| 32 | 4 | `int` | `unsigned int` | `dword` |
| 64 | 8 | `long long` | `unsigned long long` | `qword` |

整数的比特位是简单地按顺序存储的。这里的唯一歧义是存储它们的顺序——从左到右或从右到左——称为*字节序*。根据架构的不同，格式可以是以下两种之一：

+   *小端序*，它首先列出*低*位。例如，$42_{10}$ 将存储为 $010101$。

+   *大端序*，它首先列出*高*位。本文中的所有先前的例子都遵循它。

这看起来像是一个重要的架构方面，但在大多数情况下，它并没有什么区别：只需选择一种风格并坚持下去。但在某些情况下，它确实有影响：

+   小端序的优点在于，你可以通过只加载更少的字节来将一个值转换为更小的类型（例如，将`long long`转换为`int`），在大多数情况下这意味着什么都不做——多亏了*寄存器别名*，`eax`指向`rax`的第一个 4 字节，因此转换基本上是免费的。这也更容易读取各种类型大小的值——而在大端序架构上，从一个`long long`数组中加载`int`需要将指针移位 2 字节。

+   大端序的优点在于，首先加载高字节，这在理论上可以使最高到最低的例程（如比较和打印）更快。你也可以只加载其第一个字节来执行某些检查，例如找出一个数是否为负。

大端序也更“自然”——这是我们如何在纸上写二进制数的方式——但更快类型转换的优势超过了它。因此，在大多数硬件上默认使用小端序，尽管一些 CPU 是“双端序”的，并且可以配置在需要时切换模式。

### [#](https://en.algorithmica.org/hpc/arithmetic/integer/#128-bit-integers)128 位整数

有时我们需要将两个 64 位整数相乘以得到一个 128 位整数——通常用作临时值，并立即对 64 位整数取模。

没有 128 位寄存器可以存储这种乘积的结果，所以`mul`指令除了正常的`mul r r`形式，其中它将寄存器中的值相乘并保留结果的一半，还有一个`mul r`模式，其中它将`rax`寄存器中存储的任何值与其操作数相乘，并将结果写入两个寄存器——结果的较低 64 位将进入`rax`，较高的 64 位进入`rdx`：

```cpp
; input: 64-bit integers a and b, stored in rsi and rdi
; output: 128-bit product a * b, stored in rax (lower 64-bit) and rdx (higher 64-bit)
mov     rax, rdi
mov     r8, rdx
imul    rsi 
```

一些编译器有支持这种操作的独立类型。在 GCC 和 Clang 中，它可用作`__int128`：

```cpp
void prod(int64_t a, int64_t b, __int128 *c) {
    *c = a * (__int128) b;
} 
```

它的典型用法是立即提取乘积的较低或较高部分，然后忘记它：

```cpp
__int128_t x = 1;
int64_t hi = x >> 64;
int64_t lo = (int64_t) x; // will be just truncated 
```

对于除乘法以外的所有目的，128 位整数只是作为两个寄存器捆绑在一起。这使得拥有一个完整的 128 位类型变得非常奇怪，因此除了基本算术操作之外，对其的支持有限。例如：

```cpp
__int128_t add(__int128_t a, __int128_t b) {
    return a + b;
} 
```

编译成：

```cpp
add:
    mov rax, rdi
    add rax, rdx    ; this sets the carry flag in case of an overflow
    adc rsi, rcx    ; +1 if the carry flag is set
    mov rdx, rsi
    ret 
```

其他平台提供了类似的机制来处理超过字大小的乘法。例如，Arm 有`mulhi`和`mullo`指令，返回乘积的较低和较高部分，而 x86 SIMD 扩展有类似的 32 位指令。

* * *

1.  注意，`char`、`unsigned char`和`signed char`在技术上是有三个不同的类型。C 标准将是否将`char`声明为有符号或无符号留给实现（在大多数编译器中，它是无符号的）。 ↩︎ [← 快速平方根倒数](https://en.algorithmica.org/hpc/arithmetic/rsqrt/)[整数除法 →](https://en.algorithmica.org/hpc/arithmetic/division/)
