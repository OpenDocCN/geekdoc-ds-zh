# 分支的成本

> 原文：[`en.algorithmica.org/hpc/pipelining/branching/`](https://en.algorithmica.org/hpc/pipelining/branching/)

当 CPU 遇到条件跳转或任何其他类型的分支时，它不会只是闲置直到其条件被计算出来——相反，它会开始*推测执行*看起来更有可能立即执行的分支。在执行过程中，CPU 会计算每个指令上所采取的分支的统计数据，经过一段时间后，它们开始通过识别常见模式来预测它们。

因此，分支的真正“成本”在很大程度上取决于 CPU 能否很好地预测它。如果它是一个纯粹的 50/50 的硬币抛掷，你必须忍受控制冒险并丢弃整个流水线，然后再花费 15-20 个循环重新建立。如果分支总是或从不被采取，你几乎不需要支付任何费用，只需检查条件即可。

## [#](https://en.algorithmica.org/hpc/pipelining/branching/#an-experiment)一个实验

作为案例研究，我们将创建一个介于 0 和 99（包括）之间的随机整数数组：

```cpp
for (int i = 0; i < N; i++)  a[i] = rand() % 100; 
```

然后我们创建一个循环，将所有小于 50 的元素加起来：

```cpp
volatile int s;   for (int i = 0; i < N; i++)  if (a[i] < 50) s += a[i]; 
```

我们将 $N = 10⁶$ 并多次运行这个循环，这样冷缓存效应就不会影响我们的结果。我们将累加变量标记为 `volatile`，这样编译器就不会向量化循环，交错其迭代，或者以任何其他方式“作弊”。

在 Clang 上，这会产生如下汇编代码：

```cpp
 mov  rcx, -4000000 jmp  body counter:  add  rcx, 4 jz   finished   ; "jump if rcx became zero" body:  mov  edx, dword ptr [rcx + a + 4000000] cmp  edx, 49 jg   counter add  dword ptr [rsp + 12], edx jmp  counter 
```

我们的目标是模拟一个完全不可预测的分支，并且我们成功地实现了它：代码对每个元素需要 ~14 个 CPU 循环。为了对它应该是什么样子做一个非常粗略的估计，我们可以假设分支在 `<` 和 `>=` 之间交替，并且每两次迭代中就有一次流水线预测错误。那么，每两次迭代：

+   我们丢弃了流水线，在 Zen 2 上它有 19 个深度（即它有 19 个阶段，每个阶段需要一秒钟）。

+   我们需要一个内存读取和一个比较，这需要 ~5 个循环。我们可以同时检查偶数和奇数迭代的条件，所以让我们假设我们每 2 次迭代只支付一次。

+   在 `<` 分支的情况下，我们还需要额外的 ~4 个循环来将 `a[i]` 添加到一个易失的（内存存储的）变量 `s` 中。

因此，平均来说，我们需要为每个元素花费 $(4 + 5 + 19) / 2 = 14$ 个循环，这与我们所测量的结果相匹配。

### [#](https://en.algorithmica.org/hpc/pipelining/branching/#branch-prediction)分支预测

我们可以用一个可调整的参数 `P` 来替换硬编码的 `50`，这个参数实际上设置了 `<` 分支的概率：

```cpp
for (int i = 0; i < N; i++)  if (a[i] < P) s += a[i]; 
```

现在，如果我们为不同的 `P` 值进行基准测试，我们会得到一个看起来很有趣的图表：

![图片](img/fcf131b2df49e5a5fa7490ba395ae86a.png)

如预期，其峰值在 50-55%，分支预测错误是最昂贵的事情。此图是不对称的：仅检查条件从未满足的情况（`P = 0`）需要大约 1 个周期，而如果分支始终被采用（`P = 100`），求和需要大约 7 个周期。

此图不是单峰的：在约 85-90%处还有一个局部最小值。在那里，我们每个元素花费约 6.15 个周期，或者比始终选择分支快 10-15%，考虑到我们需要执行更少的加法。分支预测错误在此点停止影响性能，因为当它发生时，并不是整个指令缓冲区被丢弃，而只是那些被投机性调度的操作。本质上，那个 10-15%的预测错误率是我们可以在流水线中看得足够远以避免停顿，同时仍然在采用更便宜的 `>=` 分支上节省 10-15%的平衡点。

注意，检查一个几乎从未或几乎从未发生的情况几乎不花费任何代价。这就是为什么程序员如此频繁地使用运行时异常和基线检查：如果它们确实很少发生，它们实际上并不花费任何代价。

### [#](https://en.algorithmica.org/hpc/pipelining/branching/#pattern-detection)模式检测

在我们的例子中，对于有效的分支预测所需的一切只是一个硬件统计计数器。如果我们历史上比分支 B 更频繁地采用分支 A，那么投机执行分支 A 是有意义的。但现代 CPU 上的分支预测器比这要先进得多，可以检测到更复杂的模式。

让我们将 `P` 重新设置为 50，然后在主求和循环之前先对数组进行排序：

```cpp
for (int i = 0; i < N; i++)  a[i] = rand() % 100;   std::sort(a, a + n); 
```

我们仍在处理相同的元素，但顺序不同，而且不再是 14 个周期，现在运行时间略多于 4 个周期，这正好是纯 `<` 和 `>=` 分支成本的平均值。

分支预测器可以识别比“始终左，然后始终右”或“左右左右”更复杂的模式。如果我们仅仅将数组 $N$ 的大小减小到 1000（不进行排序），那么分支预测器会记住整个比较序列，基准测试再次在约 4 个周期内完成——实际上，甚至比排序数组的情况略少，因为在前者中，分支预测器需要花费一些时间在“始终是”和“始终不是”状态之间切换。

### [#](https://en.algorithmica.org/hpc/pipelining/branching/#hinting-likeliness-of-branches)提示分支的可能性

如果你知道哪个分支更有可能，将这个信息传递给编译器可能是有益的：

```cpp
for (int i = 0; i < N; i++)  if (a[i] < P) [[likely]] s += a[i]; 
```

当 `P = 75` 时，它每个元素测量约 7.3 个周期，而原始版本（没有提示）需要约 8.3 个周期。

这个提示并没有消除分支或向分支预测器传达任何信息，但它以改变机器代码布局的方式，让 CPU 前端能够稍微更快地处理更有可能的分支（尽管通常不会超过一个周期）。

这种优化只有在编译阶段之前你知道哪个分支更有可能被采取时才有益。当分支本质上不可预测时，我们可以尝试使用*预测*——这是一个我们将要在下一节中探讨的极其重要的技术——来完全移除它。

### [致谢](https://en.algorithmica.org/hpc/pipelining/branching/#acknowledgements)

本案例研究灵感来源于[史上最高票数的 Stack Overflow 问题](https://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-processing-an-unsorted-array)。[←流水线危害](https://en.algorithmica.org/hpc/pipelining/hazards/)[无分支编程→](https://en.algorithmica.org/hpc/pipelining/branchless/)
