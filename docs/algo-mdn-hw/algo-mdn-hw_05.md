# 指令集架构

> 原文：[`en.algorithmica.org/hpc/architecture/isa/`](https://en.algorithmica.org/hpc/architecture/isa/)

作为软件工程师，我们绝对热爱构建和使用抽象。

想象一下当你输入一个 URL 时会发生多少事情。你在键盘上输入一些内容；按键被操作系统检测到并发送到浏览器；浏览器解析 URL 并请求操作系统进行网络请求；然后是 DNS、路由、TCP、HTTP 以及所有其他的 OSI 层；浏览器解析 HTML；JavaScript 施展其魔法；页面的某种表示形式被发送到 GPU 进行渲染；图像帧被发送到显示器……而且这些步骤中的每一个可能都涉及到在过程中执行数十个更具体的事情。

抽象帮助我们把这些复杂性简化为单个*接口*，该接口描述了某个*模块*可以做什么，而不固定具体的实现。这提供了双重好处：

+   在更高层模块上工作的工程师只需要了解（更小的）接口。

+   在模块本身上工作的工程师有权优化和重构其实现，只要它符合其*契约*。

硬件工程师也热爱抽象。CPU 的抽象称为*指令集架构*（ISA），它定义了从程序员的角度来看计算机应该如何工作。类似于软件接口，它赋予计算机工程师改进现有 CPU 设计的能力，同时也给其用户——我们程序员——信心，即之前工作良好的事物在新芯片上不会出问题。

指令集架构（ISA）本质上定义了硬件应该如何解释机器语言。除了指令及其二进制编码外，ISA 还定义了寄存器的数量、大小和用途、内存模型以及输入/输出模型。类似于软件接口，ISA 也可以扩展：事实上，它们通常以向后兼容的方式更新，以添加新的和更专业的指令，从而提高性能。

### [RISC vs CISC](https://en.algorithmica.org/hpc/architecture/isa/#risc-vs-cisc)

历史上，使用过许多相互竞争的 ISA。但与[字符编码和即时通讯协议](https://xkcd.com/927/)不同，开发和维护一个完全独立的 ISA 是昂贵的，因此主流 CPU 设计最终收敛到了两个家族之一：

+   **Arm**芯片，几乎用于所有移动设备，以及其他类似计算机的设备，如电视、智能冰箱、微波炉、[汽车自动驾驶系统](https://en.wikipedia.org/wiki/Tesla_Autopilot)等。它们由同名的英国公司以及包括苹果和三星在内的多家电子产品制造商设计。

+   **x86**^(1) 芯片，几乎用于所有服务器和台式机，一些值得注意的例外包括苹果的 M1 MacBooks、AWS 的 Graviton 处理器以及当前 [世界上最快的超级计算机](https://en.wikipedia.org/wiki/Fugaku_(supercomputer))，所有这些设备都使用了基于 Arm 的处理器。它们由英特尔和 AMD 的双头垄断设计。

他们之间的主要区别在于架构复杂性，这更多的是一种设计哲学，而不是一些严格定义的特性：

+   Arm 处理器是 *精简* 指令集计算机 (RISC)。它们通过保持指令集小且高度优化来提高性能，尽管一些不太常见的操作需要通过涉及多个指令的子程序来实现。

+   x86 处理器是 *复杂* 指令集计算机 (CISC)。它们通过添加许多专用指令来提高性能，其中一些指令在实际程序中可能很少使用。

RISC 设计的主要优势是它们导致芯片更简单、更小，这预示着更低的制造成本和功耗。Arm 在电池供电的通用设备市场占据主导地位，而将复杂的神经网络和伽罗瓦域计算留给服务器级、高度专业化的 x86 处理器，这并不令人惊讶。

* * *

1.  现代版本的 x86 64 位处理器被称为“AMD64”、“Intel 64”，或者更中立的名称“x86-64”或简称为“x64”。类似地，Arm 的 64 位扩展称为“AARCH64”或“ARM64”。在这本书中，我们将只使用“x86”和“Arm”，这暗示了它们是 64 位版本。↩︎ [← ../计算机架构](https://en.algorithmica.org/hpc/architecture/)[汇编语言 →](https://en.algorithmica.org/hpc/architecture/assembly/)
