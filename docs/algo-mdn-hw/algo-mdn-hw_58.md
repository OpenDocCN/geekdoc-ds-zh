# 预取

> 原文：[`en.algorithmica.org/hpc/cpu-cache/prefetching/`](https://en.algorithmica.org/hpc/cpu-cache/prefetching/)

利用内存硬件中可用的自由并发，如果可以预测其位置，则预取可能被访问的数据是有益的。当流水线中没有数据或控制冒险时，CPU 可以提前于指令流运行并执行内存操作，这种情况下很容易做到。

但有时内存位置不在指令流中，但它们仍然可以以高概率预测。在这些情况下，可以通过其他方式预取：

+   显式地，通过单独读取下一个数据字或同一缓存行中的任何字节，以便将其提升到缓存层次结构中。

+   隐式地，通过使用简单的访问模式，如线性迭代，这些模式可以通过能够自动启动预取的内存硬件检测到。

隐藏内存延迟对于实现性能至关重要，因此在本节中，我们将探讨预取技术。

### [#](https://en.algorithmica.org/hpc/cpu-cache/prefetching/#hardware-prefetching) 硬件预取

让我们修改指针追踪基准测试来展示硬件预取的效果。现在，我们以使 CPU 在遍历排列时请求连续的缓存行的方式生成我们的排列，但仍然以随机顺序访问缓存行内的元素：

```cpp
int p[15], q[N];   iota(p, p + 15, 1);   for (int i = 0; i + 16 < N; i += 16) {  random_shuffle(p, p + 15); int k = i; for (int j = 0; j < 15; j++) k = q[k] = i + p[j]; q[k] = i + 16; } 
```

没有必要制作图表，因为这只会是平面的：延迟为 3ns，无论数组大小如何。即使指令调度器仍然无法告诉我们接下来要取什么，内存预取器只需通过查看内存访问就可以检测到一个模式，并在提前加载下一个缓存行，从而减轻延迟。

硬件预取对于大多数用例来说足够智能，但它只能检测到简单的模式。你可以并行地向前和向后遍历多个数组，可能使用小到中等的步长，但这仅限于此。对于更复杂的情况，预取器无法弄清楚发生了什么，我们需要自己帮助它。

### [#](https://en.algorithmica.org/hpc/cpu-cache/prefetching/#software-prefetching) 软件预取

软件预取的最简单方法是使用`mov`或任何其他内存指令加载缓存行中的任何字节，但 CPU 有一个单独的`prefetch`指令，该指令可以提升缓存行而不对其进行任何操作。这个指令不是 C 或 C++标准的一部分，但在大多数编译器中作为`__builtin_prefetch`内建函数可用：

```cpp
__builtin_prefetch(&a[k]); 
```

当它能派上用场时，很难想出一个*简单*的例子。为了让指针追踪基准测试从软件预取中受益，我们需要构建一个排列，它同时绕整个数组循环，不能被硬件预取器预测，并且有容易计算的下一个地址。

幸运的是，[线性同余发生器](https://en.wikipedia.org/wiki/Linear_congruential_generator)具有这样的性质：如果模数$n$是一个素数，那么发生器的周期将正好是$n$。因此，如果我们使用 LCG 生成的排列，其当前索引作为其状态，我们就会得到所有需要的属性：

```cpp
const int n = find_prime(N); // largest prime not exceeding N  for (int i = 0; i < n; i++)  q[i] = (2 * i + 1) % n; 
```

当我们运行它时，性能与正常随机排列相匹配。但现在我们得到了向前窥视的能力：

```cpp
int k = 0;   for (int t = 0; t < K; t++) {  for (int i = 0; i < n; i++) { __builtin_prefetch(&q[(2 * k + 1) % n]); k = q[k]; } } 
```

计算下一个地址时会有一些开销，但对于足够大的数组来说，它几乎快了两倍：

![图片](img/3bfccc02083790ffa4ddd3297d7bf0ea.png)

有趣的是，我们可以预取不止一个元素，利用 LCG 函数中的这个模式：

$$ \begin{aligned} f(x) &= 2 \cdot x + 1 \\ f²(x) &= 4 \cdot x + 2 + 1 \\ f³(x) &= 8 \cdot x + 4 + 2 + 1 \\ &\ldots \\ f^k(x) &= 2^k \cdot x + (2^k - 1) \end{aligned} $$

因此，为了预取前方的第`D`个元素，我们可以这样做：

```cpp
__builtin_prefetch(&q[((1 << D) * k + (1 << D) - 1) % n]); 
```

如果我们在每次迭代上执行此请求，我们将在平均上同时预取`D`个元素，将吞吐量提高`D`倍。忽略一些问题，例如当`D`太大时的整数溢出，我们可以将平均延迟降低到接近计算下一个索引的成本（在这种情况下，由模运算主导）。

![图片](img/77b30bf5058b2fae823154acfdb0c8e6.png)

注意，这是一个人为的例子，实际上在尝试将软件预取插入实际程序时，失败的情况更多。这主要是因为你需要发出一个可能与其他资源竞争的单独内存指令。同时，硬件预取在内存和缓存总线不忙时才激活，因此 100%无害。

在进行软件预取时，你也可以指定数据需要被带到缓存的具体级别——当你不确定是否会使用它，并且不想将 L1 缓存中的内容替换掉时。你可以使用`_mm_prefetch`内建函数，它将一个整数值作为第二个参数，指定缓存级别。这与非临时加载和存储结合使用很有用。[← 存储器级并行性](https://en.algorithmica.org/hpc/cpu-cache/mlp/)[对齐和打包 →](https://en.algorithmica.org/hpc/cpu-cache/alignment/)
