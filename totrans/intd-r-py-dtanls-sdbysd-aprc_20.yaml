- en: Chapter 15 An Introduction to Functional Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 15 章 函数式编程简介
- en: 原文：[https://randpythonbook.netlify.app/an-introduction-to-functional-programming](https://randpythonbook.netlify.app/an-introduction-to-functional-programming)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://randpythonbook.netlify.app/an-introduction-to-functional-programming](https://randpythonbook.netlify.app/an-introduction-to-functional-programming)
- en: '**Functional Programming (FP)** is another way of thinking about how to organize
    programs. We talked about OOP—another way to organize programs—in the last chapter
    (chapter [14](/an-introduction-to-object-oriented-programming#an-introduction-to-object-oriented-programming)).
    So how do OOP and FP differ? To put it simply, FP focuses on functions instead
    of objects. Because we are talking a lot about functions in this chapter, we will
    assume you have read and understood section [6](/functions#functions).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数式编程 (FP)** 是另一种思考如何组织程序的方法。我们在上一章（第 [14](/an-introduction-to-object-oriented-programming#an-introduction-to-object-oriented-programming)
    章节中）讨论了 OOP——另一种组织程序的方法。那么 OOP 和 FP 有何不同？简单来说，FP 专注于函数而不是对象。因为我们本章会大量讨论函数，所以我们将假设你已经阅读并理解了第
    [6](/functions#functions) 章的内容。'
- en: Neither R nor Python is a purely functional language. For us, FP is a style
    that we can choose to let guide us, or that we can disregard. You can choose to
    employ a more functional style, or you can choose to use a more object-oriented
    style, or neither. Some people tend to prefer one style to other styles, and others
    prefer to decide which to use depending on the task at hand.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: R 和 Python 都不是纯函数式语言。对我们来说，FP 是一种我们可以选择让其引导我们的风格，或者我们可以忽略的风格。你可以选择采用更函数式的风格，或者选择使用更面向对象的风格，或者两者都不选。有些人倾向于偏好一种风格而不是其他风格，而其他人则倾向于根据手头的任务来决定使用哪种风格。
- en: More specifically, a functional programming style takes advantage of **first-class
    functions** and favors functions that are **pure**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，函数式编程风格利用 **一等函数** 并倾向于使用 **纯** 函数。
- en: '**First-class functions** are (Abelson and Sussman [1996](#ref-struc_and_interp))
    functions that'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一等函数**是（Abelson 和 Sussman [1996](#ref-struc_and_interp)）函数，它们'
- en: can be passed as arguments to other functions,
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以作为参数传递给其他函数，
- en: can be returned from other functions, and
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以从其他函数返回，并且
- en: can be assigned to variables or stored in data structures.
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以分配给变量或存储在数据结构中。
- en: '**Pure functions**'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**纯函数**'
- en: return the same output if they are given the same input, and
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果给定相同的输入，则返回相同的输出，并且
- en: do not produce **side-effects**.
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不会产生 **副作用**。
- en: Side-effects are changes made to non-temporary variables, to the “state” of
    the program.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用是对非临时变量或程序“状态”所做的更改。
- en: We discussed (1) in the beginning of chapter [6](/functions#functions). If you
    have not used any other programming languages before, you might even take (1)
    for granted. However, using first-class functions can be difficult in other languages
    not mentioned in this text.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 [6](/functions#functions) 章的开头讨论了（1）。如果你之前没有使用过任何其他编程语言，你甚至可能认为（1）是理所当然的。然而，在其他未在本文本中提到的语言中使用一等函数可能会有困难。
- en: There is more to say about definition (2). This means you should keep your functions
    as *modular* as possible, unless you want your overall program to be much more
    difficult to understand. FP stipulates that
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 关于定义（2）还有更多要说的。这意味着你应该尽可能使你的函数保持 *模块化*，除非你希望你的整体程序更难以理解。FP 规定，
- en: '**ideally functions will not refer to non-local variables;**'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理想情况下，函数将不会引用非局部变量；**'
- en: '**ideally functions will not (refer to and) modify non-local variables; and**'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理想情况下，函数将不会（引用和）修改非局部变量；并且**'
- en: '**ideally functions will not modify their arguments.**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理想情况下，函数将不会修改它们的参数。**'
- en: Unfortunately, violating the first of these three criteria is very easy to do
    in both of our languages. Recall our conversation about *dynamic lookup* in subsection
    [6.8](/functions#accessing-and-modifying-captured-variables). Both R and Python
    use dynamic lookup, which means you can’t reliably control *when* functions look
    for variables. Typos in variable names easily go undiscovered, and modified global
    variables can potentially wreak havoc on your overall program.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，违反这三个标准中的第一个在我们的两种语言中都很容易做到。回想一下我们在子节 [6.8](/functions#accessing-and-modifying-captured-variables)
    中关于 *动态查找* 的讨论。R 和 Python 都使用动态查找，这意味着你无法可靠地控制函数查找变量的时间。变量名中的错误很容易被忽视，而修改过的全局变量可能会对你的整体程序造成潜在的破坏。
- en: Fortunately it is difficult to modify global variables inside functions in both
    R and Python. This was also discussed in subsection [6.8](/functions#accessing-and-modifying-captured-variables).
    In Python, you need to make use of the `global` keyword (mentioned in section
    [6.7.2](/functions#passing-by-assignment-in-python)), and in R, you need to use
    the rare super assignment operator (it looks like `<<-`, and it was mentioned
    in [6.7.1](/functions#passing-by-value-in-r)). Because these two symbols are so
    rare, they can serve as signals to viewers of your code about when and where (in
    which functions) global variables are being modified.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在 R 和 Python 中修改函数内的全局变量都很困难。这一点在子节 [6.8](/functions#accessing-and-modifying-captured-variables)
    中也有讨论。在 Python 中，你需要使用 `global` 关键字（在 [6.7.2](/functions#passing-by-assignment-in-python)
    节中提到），而在 R 中，你需要使用罕见的超级赋值运算符（看起来像 `<<-`，在 [6.7.1](/functions#passing-by-value-in-r)
    节中提到过）。由于这两个符号非常罕见，它们可以作为信号，让代码的阅读者了解何时以及在哪里（在哪个函数中）修改了全局变量。
- en: Last, violating the third criterion is easy in Python and difficult in R. This
    was discussed earlier in [6.7](/functions#modifying-a-functions-arguments). Python
    can mutate/change arguments that have a mutable type because it has *pass-by-assignment*
    semantics (mentioned in section [6.7.2](/functions#passing-by-assignment-in-python)),
    and R generally can’t modify its arguments at all because it has *pass-by-value*
    semantics [6.7.1](/functions#passing-by-value-in-r).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，违反第三个标准在 Python 中很容易，而在 R 中很难。这一点在 [6.7](/functions#modifying-a-functions-arguments)
    节中已有讨论。Python 可以修改/改变具有可变类型的参数，因为它具有*按赋值传递*的语义（在 [6.7.2](/functions#passing-by-assignment-in-python)
    节中提到），而 R 通常无法修改其参数，因为它具有*按值传递*的语义 [6.7.1](/functions#passing-by-value-in-r)。
- en: This chapter avoids the philosophical discussion of FP. Instead, it takes the
    applied approach, and provides instructions on how to use FP in your own programs.
    I try to give examples of *how* you can use FP, and *when* these tools are especially
    suitable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章避免了关于 FP 的哲学讨论。相反，它采用应用方法，并提供如何在你的程序中使用 FP 的说明。我试图给出如何使用 FP 的例子，以及何时这些工具特别合适。
- en: One of the biggest tip-offs that you should be using functional programming
    is if you need to evaluate a single function many times, or in many different
    ways. This happens quite frequently in statistical computing. Instead of copy/pasting
    similar-looking lines of code, you might consider *higher-order* functions that
    take your function as an input, and intelligently call it in all the many ways
    you want it to. A third option you might also consider is to use a loop (c.f.
    [11.2](/control-flow#loops)). However, that approach is not very functional, and
    so it will not be heavily-discussed in this section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要多次评估单个函数，或者以许多不同的方式评估，那么这就是使用函数式编程的一个明显迹象。这在统计计算中相当常见。与其复制粘贴类似外观的代码行，你可能会考虑使用*高阶*函数，这些函数将你的函数作为输入，并以你想要的所有多种方式智能地调用它。你也可以考虑的第三种选择是使用循环（参看
    [11.2](/control-flow#loops)）。然而，这种方法并不非常函数式，因此在本节中不会过多讨论。
- en: Another tip-off that you need FP is if you need many different functions that
    are all “related” to one another. Should you define each function separately,
    using excessive copy/paste-ing? Or should you write a function that can elegantly
    generate any function you need?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要许多不同的函数，而这些函数都“相关”于彼此，那么这也是你需要 FP 的一个迹象。你应该分别定义每个函数，使用过度的复制粘贴吗？或者你应该编写一个可以优雅地生成你需要的任何函数的函数？
- en: 'Not repeating yourself and re-using code is a primary motivation, but it is
    not the only one. Another motivation for **functional programming** is clearly
    explained in [Advanced R](https://adv-r.hadley.nz/fp.html)[^(27)](#fn27):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 不重复自己和重用代码是主要动机，但并非唯一。关于**函数式编程**的另一个动机在 [高级 R](https://adv-r.hadley.nz/fp.html)[^(27)](#fn27)
    中有明确的解释：
- en: A functional style tends to create functions that can easily be analysed in
    isolation (i.e. using only local information), and hence is often much easier
    to automatically optimise or parallelise.
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 函数式风格倾向于创建可以很容易独立分析的函数（即仅使用局部信息），因此通常更容易自动优化或并行化。
- en: All of these sound like a good things to have in our code, so let’s get started
    with some examples!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些听起来都是我们代码中应该拥有的好东西，所以让我们从一些示例开始吧！
- en: 15.1 Functions as Function Inputs in R
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1 R 中的函数作为函数输入
- en: Many of the most commonly-used functionals in R have names that end in “apply”.
    The ones I discuss are `sapply()`, `vapply()`, `lapply()`, `apply()`, `tapply()`
    and `mapply()`. Each of these takes a function as one of its arguments. Recall
    that this is made possible by the fact that R has first-class functions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: R中最常用的功能中，许多以“apply”结尾。我讨论的是`sapply()`、`vapply()`、`lapply()`、`apply()`、`tapply()`和`mapply()`。这些中的每一个都接受一个函数作为其参数之一。回想一下，这是由于R具有一等函数的事实而成为可能的。
- en: 15.1.1 `sapply()` and `vapply()`
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.1 `sapply()`和`vapply()`
- en: Suppose we have a `data.frame` that has 10 rows and 100 columns. What if we
    want to take the mean of each column?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个有10行和100列的`data.frame`。如果我们想计算每一列的平均值呢？
- en: An amateurish way to do this would be something like the following.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的一个业余方式可能如下所示。
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will need one line of code for each column in the data frame! For data frames
    with a lot of columns, this becomes quite tedious. You should also ask yourself
    what happens to you and your collaborators when the data frame changes even slightly,
    or if you want to apply a different function to its columns. Third, the results
    are not stored in a single container. You are making it difficult on yourself
    if you want to use these variables in subsequent pieces of code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为数据框中的每一列编写一行代码！对于有很多列的数据框，这会变得相当繁琐。你也应该问问自己，当数据框即使有轻微的变化，或者你想对其列应用不同的函数时，会发生什么。第三，结果不会存储在单个容器中。如果你想在后续的代码中使用这些变量，这会让你自己变得很麻烦。
- en: “Don’t repeat yourself” (DRY) is an idea that’s been around for a while and
    is widely accepted (Hunt and Thomas [2000](#ref-hunt2000pragmatic)). DRY is the
    opposite of [WET](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself#WET).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: “不要重复自己”（DRY）是一个存在已久的想法，并且被广泛接受（Hunt和Thomas [2000](#ref-hunt2000pragmatic)）。DRY是[WET](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself#WET)的对立面。
- en: Instead, prefer the use of `sapply()` in this situation. The “s” in `sapply()`
    stands for “simplified.” In this bit of code `mean()` is called on each column
    of the data frame. `sapply()` applies the function over columns, instead of rows,
    because data frames are internally a `list` of columns.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在这种情况下，最好使用`sapply()`。`sapply()`中的“s”代表“simplified”。在这段代码中，`mean()`被调用在每个数据框的列上。`sapply()`在列上应用函数，而不是在行上，因为数据框在内部是一个列的`list`。
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each call to `mean()` returns a `double` `vector` of length \(1\). This is necessary
    if you want to collect all the results into a `vector`–remember, all elements
    of a `vector` have to have the same type. To get the same behavior, you might
    also consider using `vapply(myDF, mean, numeric(1))`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`mean()`都会返回一个长度为\(1\)的`double` `vector`。如果你想将所有结果收集到一个`vector`中，请记住，`vector`的所有元素必须具有相同的类型。为了获得相同的行为，你也可以考虑使用`vapply(myDF,
    mean, numeric(1))`。
- en: In the above case, “simplify” referred to how one-hundred length-\(1\) vectors
    were simplified into one length-\(100\) `vector`. However, “simplified” does not
    necessarily imply that all elements will be stored in a `vector`. Consider the
    `summary` function, which returns a `double` `vector` of length \(6\). In this
    case, one-hundred length-\(6\) vectors were simplified into one \(6 \times 100\)
    matrix.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，“simplify”指的是如何将一百个长度为\(1\)的向量简化为一个长度为\(100\)的`vector`。然而，“simplified”并不一定意味着所有元素都会存储在`vector`中。考虑`summary`函数，它返回一个长度为\(6\)的`double`
    `vector`。在这种情况下，一百个长度为\(6\)的向量被简化为一个\(6 \times 100\)的矩阵。
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Another function that is worth mentioning is `replicate()`–it is a wrapper for
    `sapply()`. Consider a situation where you want to call a function many times
    with the same inputs. You might try something like `sapply(1:100, function(elem)
    { return(myFunc(someInput)) } )`. Another, more readable, way to do this is `replicate(100,
    myFunc(someInput))`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得提到的函数是`replicate()`，它是`sapply()`的包装器。考虑这样一个情况，你想要多次以相同的输入调用一个函数。你可能尝试以下操作：`sapply(1:100,
    function(elem) { return(myFunc(someInput)) } )`。另一种更易读的方法是`replicate(100, myFunc(someInput))`。
- en: 15.1.2 `lapply()`
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.2 `lapply()`
- en: For functions that do not return amenable types that fit into a `vector`, `matrix`
    or `array`, they might need to be stored in `list`. In this situation, you would
    need `lapply()`. The “l” in `lapply()` stands for “list”. `lapply()` always returns
    a `list` of the same length as the `input`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不返回适合放入`vector`、`matrix`或`array`的类型的函数，它们可能需要存储在`list`中。在这种情况下，你需要使用`lapply()`。`lapply()`中的“l”代表“list”。`lapply()`总是返回一个与`input`长度相同的`list`。
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 15.1.3 `apply()`
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.3 `apply()`
- en: I use `sapply()` and `lapply()` the most, personally. The next most common function
    I use is `apply()`. You can use it to apply functions to *rows* of rectangular
    arrays instead of columns. However, it can also apply functions over columns,
    just as the other functions we discussed can.[^(28)](#fn28)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人最常用的是`sapply()`和`lapply()`。接下来最常用的函数是`apply()`。你可以用它来将函数应用于矩形数组的*行*而不是列。然而，它也可以像我们讨论的其他函数一样，对列应用函数。[^(28)](#fn28)
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Another example where it can be useful to apply a function to rows is **predicate
    functions.** A predicate function is just a fancy name for a function that returns
    a Boolean. I use them to filter out rows of a `data.frame`. Without a predicate
    function, filtering rows might look something like this on our real estate data
    (Albemarle County Geographic Data Services Office [2021](#ref-albemarle_county_gis_web))
    (Ford [2016](#ref-clay_ford)).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，当需要将函数应用于行时，这可能会很有用。谓词函数只是对返回布尔值的函数的一个花哨名称。我使用它们来过滤`data.frame`的行。没有谓词函数，过滤行可能看起来像这样在我们的房地产数据中（阿勒格尼县地理信息服务办公室
    [2021](#ref-albemarle_county_gis_web))（福特 [2016](#ref-clay_ford))。
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Complicated filtering criteria can become quite wide, so I prefer to break the
    above code into three steps.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的过滤条件可能会变得相当宽泛，所以我更倾向于将上述代码分成三个步骤。
- en: 'Step 1: write a predicate function that returns TRUE or FALSE;'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1步：编写一个返回TRUE或FALSE的谓词函数；
- en: 'Step 2: construct a `logical` `vector` by `apply()`ing the predicate over rows;'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2步：通过`apply()`函数对行应用谓词来构建一个`逻辑`向量；
- en: 'Step 3: plug the `logical` `vector` into the `[` operator to remove the rows.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第3步：将`逻辑`向量插入到`[`运算符中以删除行。
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 15.1.4 `tapply()`
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.4 `tapply()`
- en: '`tapply()` can be very handy when you need it. First, we’ve alluded to the
    definition before in subsection [8.1](/data-frames#data-frames-in-r), but a **ragged
    array** is a collection of arrays that all have potentially different lengths.
    I don’t typically construct such an object and then pass it to `tapply()`. Rather,
    I let `tapply()` construct the ragged array for me. The first argument it expects
    is, to quote the documentation, “typically vector-like,” while the second tells
    us how to break that `vector` into chunks. The third argument is a function that
    gets applied to each `vector` chunk.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`tapply()`在需要时非常有用。首先，我们之前在子节[8.1](/data-frames#data-frames-in-r)中提到了定义，但一个**锯齿状数组**是一系列可能具有不同长度的数组。我通常不会构建这样的对象并将其传递给`tapply()`。相反，我让`tapply()`为我构建锯齿状数组。它期望的第一个参数通常是“类似向量的”，而第二个参数告诉我们如何将那个`向量`分成块。第三个参数是一个函数，它被应用于每个`向量`块。'
- en: If I wanted the average home price for each city, I could use something like
    this.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想得到每个城市的平均房价，我可以使用类似这样的方法。
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You might be wondering why we put `albRealEstate$City` into a `list`. That seems
    kind of unnecessary. This is because `tapply()` can be used with multiple `factor`s–this
    will break down the `vector` input into a finer partition. The second argument
    must be one object, though, so all of these `factor`s must be collected into a
    `list`. The following code produces a “pivot table.”
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们将`albRealEstate$City`放入一个`list`中。这似乎有点不必要。这是因为`tapply()`可以与多个`factor`s一起使用——这将把`向量`输入分解成更细的分区。然而，第二个参数必须是一个对象，所以所有这些`factor`s都必须收集到一个`list`中。以下代码生成一个“交叉表”。
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For functions that return higher-dimensional output, you will have to use something
    like `by()` or `aggregate()` in place of `tapply()`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于返回高维输出的函数，你必须使用类似`by()`或`aggregate()`的东西来代替`tapply()`。
- en: 15.1.5 `mapply()`
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.5 `mapply()`
- en: The [documentation of `mapply()`](https://stat.ethz.ch/R-manual/R-devel/library/base/html/mapply.html)
    states `mapply()` is a multivariate version of `sapply()`. `sapply()` worked with
    univariate functions; the function was called multiple times, but each time with
    a single argument. If you have a function that takes *multiple arguments*, and
    you want those arguments to change each time the function is called, then you
    might be able to use `mapply()`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`[mapply()]`的[文档](https://stat.ethz.ch/R-manual/R-devel/library/base/html/mapply.html)说明`mapply()`是`sapply()`的多变量版本。`sapply()`与单变量函数一起工作；函数被多次调用，但每次只带一个参数。如果你有一个需要多个参数的函数，并且你希望这些参数在每次函数调用时都改变，那么你可能能够使用`mapply()`。'
- en: Here is a short example. Regarding the `n=` argument of `rnorm()`, the documentation
    explains, “[i]f `length(n) > 1`, the length is taken to be the number required.”
    This would be a problem if we want to sample three times from a mean \(0\) normal
    first, then twice from a mean \(100\) normal, and then third, once from a mean
    \(42\) normal distribution. We only get three samples when we want six!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简短的例子。关于`rnorm()`函数的`n=`参数，文档解释说，“如果`length(n) > 1`，长度被认为是所需的数量。”如果我们想从均值为\(0\)的正态分布中抽取三次，然后从均值为\(100\)的正态分布中抽取两次，然后第三次，从均值为\(42\)的正态分布中抽取一次，我们会得到三个样本，而我们想要的是六个样本！
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 15.1.6 `Reduce()` and `do.call()`
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.6 `Reduce()`和`do.call()`
- en: Unlike the other examples of functions that take other functions as inputs,
    `Reduce()` and `do.call()` don’t have many outputs. Instead of collecting many
    outputs into a container, they just output one thing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他接受其他函数作为输入的函数示例不同，`Reduce()`和`do.call()`没有很多输出。它们不是将许多输出收集到一个容器中，而是只输出一个东西。
- en: 'Let’s start with an example: “combining” data sets. In section [12](/reshaping-and-combining-data-sets#reshaping-and-combining-data-sets)
    we talked about several different ways of combining data sets. We discussed stacking
    data sets on top of one another with `rbind()` (c.f. subsection [12.2](/reshaping-and-combining-data-sets#stacking-data-sets-and-placing-them-shoulder-to-shoulder)),
    stacking them side-by-side with `cbind()` (also in [12.2](/reshaping-and-combining-data-sets#stacking-data-sets-and-placing-them-shoulder-to-shoulder)),
    and intelligently joining them together with `merge()` (c.f. [12.3](/reshaping-and-combining-data-sets#merging-or-joining-data-sets)).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从例子开始：“合并”数据集。在第[12](/reshaping-and-combining-data-sets#reshaping-and-combining-data-sets)节中，我们讨论了几种不同的合并数据集的方法。我们讨论了使用`rbind()`（参看子节[12.2](/reshaping-and-combining-data-sets#stacking-data-sets-and-placing-them-shoulder-to-shoulder)）将数据集堆叠在一起，使用`cbind()`（也在[12.2](/reshaping-and-combining-data-sets#stacking-data-sets-and-placing-them-shoulder-to-shoulder)）将它们并排堆叠，以及使用`merge()`（参看[12.3](/reshaping-and-combining-data-sets#merging-or-joining-data-sets)）智能地合并它们。
- en: Now consider the task of combining *many* data sets. How can we combine three
    or more data sets into one? Also, how do we write DRY code and abide by the DRY
    principle? As the name of the subsection suggests, we can use either `Reduce()`
    or `do.call()` as a higher-order function. Just like the aforementioned `*apply()`
    functions, they take in either `cbind()`, `rbind()`, or `merge()` as a function
    input. Which one do we pick, though? The answer to that question deals with *how
    many arguments our lower-order function takes.*
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑合并*多个*数据集的任务。我们如何将三个或更多数据集合并成一个？另外，我们如何编写DRY代码并遵守DRY原则？正如子节名称所暗示的，我们可以使用`Reduce()`或`do.call()`作为高阶函数。就像前面提到的`*apply()`函数一样，它们接受`cbind()`、`rbind()`或`merge()`作为函数输入。那么我们选择哪一个呢？这个问题的答案涉及到*我们的低阶函数接受多少个参数*。
- en: Take a look at the documentation to `rbind()`. Its first argument is `...`,
    which is the [dot-dot-dot](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Dot_002ddot_002ddot)
    symbol. This means `rbind()` can take a varying number of `data.frame`s to stack
    on top of each other. In other words, `rbind()` is **variadic**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`rbind()`函数的文档。它的第一个参数是`...`，这是[省略号](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Dot_002ddot_002ddot)符号。这意味着`rbind()`可以接受不同数量的`data.frame`来堆叠在一起。换句话说，`rbind()`是**可变参数**的。
- en: On the other hand, take a look at the documentation of `merge()`. It only takes
    two `data.frame`s at a time[^(29)](#fn29). If we want to combine many data sets,
    `merge()` needs a helper function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，看看`merge()`函数的文档。它一次只接受两个`data.frame`[^(29)](#fn29)。如果我们想合并多个数据集，`merge()`需要一个辅助函数。
- en: This is the difference between `Reduce()` and `do.call()`. `do.call()` calls
    a function once on many arguments, so its function must be able to handle many
    arguments. On the other hand, `Reduce()` calls a binary function many times on
    pairs of arguments. `Reduce()`’s function argument gets called on the first two
    elements, then on the first output and the third element, then on the second output
    and fourth element, and so on.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`Reduce()`和`do.call()`之间的区别。`do.call()`一次在多个参数上调用一个函数，因此它的函数必须能够处理多个参数。另一方面，`Reduce()`在多个参数对的组合上多次调用二元函数。`Reduce()`的函数参数首先在第一个两个元素上调用，然后是第一个输出和第三个元素，接着是第二个输出和第四个元素，以此类推。
- en: Here is an initial example that makes use of four data sets `d1.csv`, `d2.csv`,
    `d3.csv`, and `d4.csv`. To start, ask yourself how we would read all of these
    in. There is a temptation to copy and paste `read.csv` calls, but that would violate
    the DRY principle. Instead, let’s use `lapply()` an anonymous function that constructs
    a file path string, and then uses it to read in the data set the string refers
    to.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个初始示例，它使用了四个数据集 `d1.csv`、`d2.csv`、`d3.csv` 和 `d4.csv`。首先，问问自己我们如何读取所有这些数据。有一种诱惑是复制粘贴
    `read.csv` 调用，但这会违反DRY原则。相反，让我们使用 `lapply()` 和一个匿名函数来构造文件路径字符串，然后使用它来读取该字符串所引用的数据集。
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice how the above code would only need to be changed by one character if
    we wanted to increase the number of data sets being read in![^(30)](#fn30)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们想要增加读取的数据集数量，上述代码只需要更改一个字符![^(30)](#fn30)
- en: Next, `cbind()`ing them all together can be done as follows. `do.call()` will
    call the function only once. `cbind()` takes many arguments at once, so this works.
    This code is even better than the above code in that if `dfs` becomes longer,
    or changes at all, *nothing* will need to be changed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将它们全部 `cbind()` 在一起可以这样做。`do.call()` 将只调用一次函数。`cbind()` 一次可以接受多个参数，所以这可行。这段代码甚至比上面的代码更好，因为如果
    `dfs` 变长或发生任何变化，*则不需要进行任何更改*。
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What if we wanted to `merge()` all these data sets together? After all, the
    `id` column appears to be repeating itself, and some data from `d2` isn’t lining
    up.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将这些数据集 `merge()` 在一起呢？毕竟，`id` 列似乎在重复，而且 `d2` 中的某些数据没有对齐。
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Again, this is very DRY code. Nothing would need to be changed if `dfs` grew.
    Furthermore, trying to `do.call()` the `merge()` function wouldn’t work because
    it can only take two data sets at a time.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是一段非常遵循DRY（Don't Repeat Yourself）原则的代码。如果 `dfs` 增长，则不需要进行任何更改。此外，尝试使用
    `do.call()` 调用 `merge()` 函数不会起作用，因为它一次只能处理两个数据集。
- en: 15.2 Functions as Function Inputs in Python
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2 Python 中的函数作为函数输入
- en: 15.2.1 Functions as Function Inputs in Base Python
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.1 基础 Python 中的函数作为函数输入
- en: I discuss two functions from base Python that take functions as input. Neither
    return a `list` or a `np.array`, but they do return different kinds of **iterables**,
    which are “objects capable of returning their members one at a time,” [according
    to the Python documentation.](https://docs.python.org/3/glossary.html) `map()`,
    the function, will return objects of type `map`. `filter()`, the function, will
    return objects of type `filter`. Often times we will just convert these to the
    container we are more familiar with.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我讨论了两个来自基础 Python 的函数，它们接受函数作为输入。它们既不返回 `list` 或 `np.array`，但它们确实返回不同类型的 **可迭代对象**，这些对象是“能够一次返回其成员的对象”，[根据
    Python 文档所述。](https://docs.python.org/3/glossary.html) `map()` 函数将返回类型为 `map`
    的对象。`filter()` 函数将返回类型为 `filter` 的对象。很多时候，我们只是将它们转换为更熟悉的容器。
- en: 15.2.1.1 `map()`
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.1.1 `map()`
- en: '[`map()`](https://docs.python.org/3/library/functions.html#map) can call a
    function repeatedly using elements of a container as inputs. Here is an example
    of calculating outputs of a *spline* function, which can be useful for coming
    up with predictors in regression models. This particular spline function is \(f(x)
    = (x-k)1(x \ge k)\), where \(k\) is some chosen “knot point.”'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[`map()`](https://docs.python.org/3/library/functions.html#map) 可以通过使用容器中的元素作为输入来重复调用一个函数。以下是一个计算样条函数输出的示例，这对于在回归模型中提出预测因子非常有用。这个特定的样条函数是
    \(f(x) = (x-k)1(x \ge k)\)，其中 \(k\) 是某个选择的“节点点”。'
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can visualize the mathematical function by plotting its outputs against its
    inputs. More information on visualization was given in subsection [13](/visualization#visualization).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将函数的输出与其输入进行绘图来可视化数学函数。有关可视化的更多信息，请参阅子节 [13](/visualization#visualization)。
- en: '![Our Spline Function](../Images/acbd6af29d721e5a76799230cedf28d2.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![我们的样条函数](../Images/acbd6af29d721e5a76799230cedf28d2.png)'
- en: 'Figure 15.1: Our Spline Function'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1：我们的样条函数
- en: '`map()` can also be used like `mapply()`. In other words, you can apply it
    to two containers,'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()` 也可以像 `mapply()` 一样使用。换句话说，你可以将它应用于两个容器，'
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 15.2.1.2 `filter()`
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.1.2 `filter()`
- en: '[`filter()`](https://docs.python.org/3/library/functions.html#filter) helps
    remove unwanted elements from a container. It returns an iterable of type `filter`,
    which we can iterate over or convert to a more familiar type of container. In
    this example, I iterate over it without converting it.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[`filter()`](https://docs.python.org/3/library/functions.html#filter) 帮助从容器中删除不需要的元素。它返回一个类型为
    `filter` 的可迭代对象，我们可以遍历它或将其转换为更熟悉的容器类型。在这个例子中，我遍历它而没有转换它。'
- en: This code also provides our first example of a [**lambda function**](https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions)
    (Lutz [2013](#ref-Lutz13)). Lambda functions are simply another way to define
    functions. Notice that in this example, we didn’t have to name our function. In
    other words, it was **anonymous**. We can also save a few lines of code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码还提供了我们第一个 [**lambda 函数**](https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions)
    的例子（Lutz [2013](#ref-Lutz13)）。Lambda 函数是定义函数的另一种方式。注意，在这个例子中，我们不需要命名我们的函数。换句话说，它是
    **匿名** 的。我们还可以节省一些代码行。
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 15.2.2 Functions as Function Inputs in Numpy
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.2 Numpy 中的函数作为函数输入
- en: Numpy provides a [number of functions](https://numpy.org/doc/stable/reference/routines.functional.html)
    that facilitate working with `np.ndarray`s in a functional style. For example,
    [`np.apply_along_axis()`](https://numpy.org/doc/stable/reference/generated/numpy.apply_along_axis.html)
    is similar to R’s `apply()`. `apply()` had a `MARGIN=` input (`1` sums rows, `2`
    sums columns), whereas this function has a `axis=` input (`0` sums columns, `1`
    sums rows).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Numpy 提供了 [许多函数](https://numpy.org/doc/stable/reference/routines.functional.html)，这些函数有助于以函数式风格处理
    `np.ndarray`。例如，[`np.apply_along_axis()`](https://numpy.org/doc/stable/reference/generated/numpy.apply_along_axis.html)
    与 R 的 `apply()` 类似。`apply()` 有一个 `MARGIN=` 输入（`1` 求和行，`2` 求和列），而此函数有一个 `axis=`
    输入（`0` 求和列，`1` 求和行）。
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 15.2.3 Functional Methods in Pandas
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.3 Pandas 中的函数式方法
- en: Pandas’ `DataFrame`s have an [`.apply()` method](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html)
    that is very similar to `apply()` in R,[^(31)](#fn31) but again, just like the
    above function, you have to think about an `axis=` argument instead of a `MARGIN=`
    argument.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 的 `DataFrame` 有一个 [`.apply()` 方法](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html)，它与
    R 中的 `apply()` 非常相似，[^(31)](#fn31)，但同样，就像上面的函数一样，你必须考虑一个 `axis=` 参数而不是 `MARGIN=`
    参数。
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Another thing to keep in mind is that `DataFrame`s, unlike `ndarray`s, don’t
    have to have the same type for all elements. If you have mixed column types, then
    summing rows, for instance, might not make sense. This just requires subsetting
    columns before `.apply()`ing a function to rows. Here is an example of computing
    each property’s “score”.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要记住的是，`DataFrame` 与 `ndarray` 不同，不需要所有元素具有相同的类型。如果你有混合类型的列，那么例如求和行可能就没有意义。这只需要在
    `.apply()` 函数应用于行之前对列进行子集化。以下是一个计算每个属性“得分”的例子。
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`.apply()` also works with more than one function at a time.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`.apply()` 也可以同时处理多个函数。'
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you do not want to waste two lines defining a function with `def`, you can
    use an anonymous lambda function. Be careful, though–if your function is complex
    enough, then your lines will get quite wide. For instance, this example is pushing
    it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想浪费两行代码来定义一个带有 `def` 的函数，你可以使用匿名 lambda 函数。不过要小心，如果你的函数足够复杂，那么你的代码行将会变得相当宽。例如，这个例子就有点过分了。
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The previous example `.apply()`s a *binary* function to each row. The function
    is binary because it takes two elements at a time. If you want to apply a *unary*
    function (i.e. it takes one argument at a time) function to each row for, and
    for each column, then you can use [`.applymap()`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.applymap.html#pandas.DataFrame.applymap).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子中，`.apply()` 方法将一个 *二进制* 函数应用于每一行。该函数是二进制的，因为它一次处理两个元素。如果你想要将一个 *一元* 函数（即一次处理一个参数）应用于每一行，并且对于每一列，那么你可以使用
    [`.applymap()`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.applymap.html#pandas.DataFrame.applymap)。
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Last, we have a [`.groupby()`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.groupby.html)
    method, which can be used to mirror the behavior of R’s `tapply()`, `aggregate()`
    or `by()`. It can take the `DataFrame` it belongs to, and group its rows into
    multiple sub-`DataFrame`s. The collection of sub-`DataFrames` has a lot of the
    same methods that an individual `DataFrame` has (e.g. the subsetting operators,
    and the `.apply()` method), which can all be used in a second step of calculating
    things on each sub-`DataFrame`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个 [`.groupby()`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.groupby.html)
    方法，它可以用来模拟 R 的 `tapply()`、`aggregate()` 或 `by()` 的行为。它可以接受它所属的 `DataFrame`，并将它的行分组到多个子
    `DataFrame` 中。这些子 `DataFrame` 集合拥有许多与单个 `DataFrame` 相同的方法（例如子集化运算符和 `.apply()`
    方法），这些方法都可以在第二步计算每个子 `DataFrame` 上的事物时使用。
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here is an example that models some pretty typical functionality. It shows two
    ways to get the average home price by city. The first line groups the rows by
    which `City` they are in, extracts the `TotalValue` column in each sub-`DataFrame`,
    and then `.apply()`s the `np.average()` function on the sole column found in each
    sub-`DataFrame`. The second `.apply()`s a lambda function to each sub-`DataFrame`
    directly. More details on this “split-apply-combine” strategy can be found in
    the [Pandas documentation.](https://pandas.pydata.org/pandas-docs/stable/user_guide/groupby.html)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，它模拟了一些相当典型的功能。它展示了两种通过城市获取平均房价的方法。第一行通过`City`将行分组，从每个子`DataFrame`中提取`TotalValue`列，然后对每个子`DataFrame`中找到的单一列应用`np.average()`函数。第二个`.apply()`直接对每个子`DataFrame`应用一个lambda函数。关于这种“拆分-应用-组合”策略的更多细节可以在[Pandas文档](https://pandas.pydata.org/pandas-docs/stable/user_guide/groupby.html)中找到。
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 15.3 Functions as Function Outputs in R
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3 R中作为函数输出的函数
- en: Functions that create and return other functions are sometimes called **function
    factories.** Functions are first-class objects in R, so it’s easy to return them.
    What’s more interesting is that supposedly temporary objects inside the outer
    function can be accessed during the call of the inner function after it’s returned.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并返回其他函数的函数有时被称为**函数工厂**。在R中，函数是一等对象，因此很容易返回它们。更有趣的是，外函数内部的临时对象可以在返回后通过内函数的调用访问。
- en: Here is a first quick example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个初步的快速示例。
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that **the `greetingMessage=` argument that is passed in, `"Hello"`,
    isn’t temporary anymore.** It lives on so it can be used by all the functions
    created by `funcFactory()`. This is the most surprising aspect of writing function
    factories.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，传递的`greetingMessage=`参数，即`"Hello"`，不再是临时的了。它持续存在，因此可以被`funcFactory()`创建的所有函数使用。这是编写函数工厂最令人惊讶的方面。
- en: Let’s now consider a more complicated and realistic example. Let’s implement
    a variance reduction technique called **common random numbers**.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一个更复杂、更现实的例子。让我们实现一种称为**共同随机数**的方差减少技术。
- en: 'Suppose \(X \sim \text{Normal}(\mu, \sigma^2)\), and we are interested in approximating
    an expectation of a function of this random variable. Suppose that we don’t know
    that \[\begin{equation} \mathbb{E}[\sin(X)] = \sin(\mu) \exp\left(-\frac{\sigma^2}{2}\right)
    \end{equation}\] for any particular choice of \(\mu\) and \(\sigma^2\), and instead,
    we choose to use the Monte Carlo method: \[\begin{equation} \hat{\mathbb{E}}[\sin(X)]
    = \frac{1}{n}\sum_{i=1}^n\sin(X^i) \end{equation}\] where \(X^1, \ldots, X^n \overset{\text{iid}}{\sim}
    \text{Normal}(\mu, \sigma^2)\) is a large collection of draws from the appropriate
    normal distribution, probably coming from a call to `rnorm()`. In more realistic
    situations, the theoretical expectation might not be tractable, either because
    the random variable has a complicated distribution, or maybe because the functional
    is very complicated. In these cases, a tool like Monte Carlo might be the only
    available approach.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 假设\(X \sim \text{Normal}(\mu, \sigma^2)\)，我们感兴趣的是近似这个随机变量的函数的期望。假设我们不知道对于任何特定的\(\mu\)和\(\sigma^2\)的选择，\[\begin{equation}
    \mathbb{E}[\sin(X)] = \sin(\mu) \exp\left(-\frac{\sigma^2}{2}\right) \end{equation}\]，而是选择使用蒙特卡洛方法：\[\begin{equation}
    \hat{\mathbb{E}}[\sin(X)] = \frac{1}{n}\sum_{i=1}^n\sin(X^i) \end{equation}\]，其中\(X^1,
    \ldots, X^n \overset{\text{iid}}{\sim} \text{Normal}(\mu, \sigma^2)\)是从适当的正态分布中抽取的大量样本，可能来自对`rnorm()`的调用。在更现实的情况下，理论期望可能不可处理，要么是因为随机变量具有复杂的分布，要么是因为函数非常复杂。在这些情况下，像蒙特卡洛这样的工具可能是唯一可用的方法。
- en: Here are two functions that calculate the above quantities for \(n=1000\). `actualExpectSin()`
    is a function that computes the theoretical expectation for any particular parameter
    pair. `monteCarloSin()` is a function that implements the Monte Carlo approximate
    expectation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个函数，用于计算上述量对于\(n=1000\)的情况。`actualExpectSin()`是一个函数，用于计算任何特定参数对的理论期望。`monteCarloSin()`是一个函数，实现了蒙特卡洛近似期望。
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: One-off approximations aren’t as interesting as visualizing many expectations
    for many parameter inputs. Below we plot the expectations for many different parameter
    vectors/configurations/settings.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 单次近似不如可视化许多参数输入的期望有趣。下面我们绘制了许多不同参数向量/配置/设置的期望。
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![Monte Carlo Approximations versus Exact Evaluations](../Images/6ab7a7c4b06e7de5eb3dc87e7bdaf687.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![蒙特卡洛近似与精确评估](../Images/6ab7a7c4b06e7de5eb3dc87e7bdaf687.png)'
- en: 'Figure 15.2: Monte Carlo Approximations versus Exact Evaluations'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2：蒙特卡洛近似与精确评估
- en: 'There are three problems with this implementation:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现有三个问题：
- en: '`monteCarloSin()` is not pure because it captures the `n` variable,'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`monteCarloSin()` 不是纯函数，因为它捕获了 `n` 变量，'
- en: the only way to increase the accuracy of the plot in the right panel is to increase
    `n`, and
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加右侧面板图表精度的唯一方法是增加 `n`，并且
- en: every time we re-run this code the plot on the right looks different.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次我们重新运行这段代码时，右侧的图表看起来都不同。
- en: If we wanted to use common random numbers, we could generate \(Z^1, \ldots,
    Z^n \overset{\text{iid}}{\sim} \text{Normal}(0, 1)\), and use the fact that
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用常见的随机数，我们可以生成 \(Z^1, \ldots, Z^n \overset{\text{iid}}{\sim} \text{Normal}(0,
    1)\)，并使用以下事实：
- en: \[\begin{equation} X^i = \mu + \sigma Z^i \end{equation}\]
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{equation} X^i = \mu + \sigma Z^i \end{equation}\]
- en: This leads to the Monte Carlo estimate
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了蒙特卡洛估计
- en: \[\begin{equation} \tilde{\mathbb{E}}[\sin(X)] = \frac{1}{n}\sum_{i=1}^n\sin(\mu
    + \sigma Z^i) \end{equation}\]
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{equation} \tilde{\mathbb{E}}[\sin(X)] = \frac{1}{n}\sum_{i=1}^n\sin(\mu
    + \sigma Z^i) \end{equation}\]
- en: Here is one function that naively implements Monte Carlo with common random
    numbers. We generate the collection of standard normal random variables once,
    globally. Each time you call `monteCarloSinCRNv1(c(10,1))`, you get the same answer.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个天真地实现带有共同随机数的蒙特卡洛函数的例子。我们一次全局地生成标准正态随机变量的集合。每次你调用 `monteCarloSinCRNv1(c(10,1))`
    时，你都会得到相同的答案。
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let’s compare using common random numbers to going without. As you can see,
    common random numbers make the plot look “smoother.” In other words, we increase
    our sampling accuracy without spending more computational time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较使用共同随机数和不使用的情况。如您所见，共同随机数使图表看起来“更平滑”。换句话说，我们提高了采样精度，而没有花费更多的计算时间。
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![Monte Carlo: With and Without Common Random Numbers](../Images/9efee9d51a03a72ddb1051c3ebb3d646.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![蒙特卡洛：有和无共同随机数](../Images/9efee9d51a03a72ddb1051c3ebb3d646.png)'
- en: 'Figure 15.3: Monte Carlo: With and Without Common Random Numbers'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3：蒙特卡洛：有和无共同随机数
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'There are some new downsides to this implementation to consider:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现有一些新的缺点需要考虑：
- en: we have another global variable–a bunch of samples called `commonZs` floating
    around, and
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还有一个全局变量——一些称为 `commonZs` 的样本在周围漂浮，并且
- en: the dependence on the global variable for sample size is even further obscured.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对样本大小全局变量的依赖性甚至被进一步掩盖了。
- en: We can fix these two problems very nicely by using a function factory.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用函数工厂非常优雅地解决这两个问题。
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is much better because
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这要更好，因为
- en: the desired sample size must be passed in as a function argument instead of
    being captured,
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需的样本大小必须作为函数参数传递，而不是捕获，
- en: the re-used standard normal variates are not in the global environment anymore,
    and
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新使用的标准正态变量不再在全局环境中了，并且
- en: a sensible default number of samples is provided in the event that the programmer
    forgets to specify one.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当程序员忘记指定一个时，提供了一个合理的默认样本数量。
- en: The inner function did in fact capture `commonZs`, but it captured from the
    enclosing scope, not the global scope. Capturing isn’t always a terrible idea.
    It would be difficult to modify these variables, so we don’t need to worry about
    function behavior changing in unpredictable ways. Actually capturing a variable
    instead of passing it in is an intelligent design choice–now the end-users of
    functions created by this factory don’t need to worry about plugging in extra
    parameters.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 内部函数确实捕获了 `commonZs`，但它是从封装作用域而不是全局作用域捕获的。捕获并不总是糟糕的想法。修改这些变量会有困难，所以我们不需要担心函数行为以不可预测的方式改变。实际上捕获一个变量而不是传递它是一个明智的设计选择——现在，由这个工厂创建的函数的最终用户不需要担心插入额外的参数。
- en: Let’s use \(1000\) samples again and make sure this function works by comparing
    its output to the known true function. Run the following code on your own machine.
    Note the new Greek letters in the axis labels.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次使用 \(1000\) 个样本，并确保这个函数通过将其输出与已知的真函数进行比较来工作。在你的机器上运行以下代码。注意轴标签中的新希腊字母。
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 15.4 Functions as Function Outputs in Python
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.4 Python 中作为函数输出的函数
- en: We can write function factories in Python, too. Here is another implementation
    of the first example from the previous section. Again, just as it did in R, `str`
    passed in as `greeting_message` persists well after `func_factory()` is finished
    working.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在 Python 中编写函数工厂。这是上一节第一个示例的另一种实现。同样，就像在 R 中一样，`str` 作为 `greeting_message`
    传递进去，在 `func_factory()` 完成工作后仍然保持良好。
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let’s consider another less trivial example. Recall the spline function from
    earlier in the chapter:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个不那么平凡的例子。回想一下本章前面提到的样条函数：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This function is limited in that it takes in only one element at a time. Unfortunately,
    we would not be able to provide an entire Numpy array as an argument (e.g. `spline(np.arange(3))`).
    Many functions do possess this behavior, and it is generally advantageous to take
    advantage of it. If you recall our discussion about universal functions in section
    [3.4](/r-vectors-versus-numpy-arrays-and-pandas-series#vectorization-in-python),
    you might have grown accustomed to taking advantage of writing vectorized code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的限制在于它一次只能接受一个元素。不幸的是，我们无法将整个 Numpy 数组作为参数提供（例如 `spline(np.arange(3))`）。许多函数确实具有这种行为，并且通常利用它是有利的。如果你还记得我们在第
    [3.4](/r-vectors-versus-numpy-arrays-and-pandas-series#vectorization-in-python)
    节中关于通用函数的讨论，你可能已经习惯了利用编写向量化代码的优势。
- en: 'Fortunately there’s a way to automatically vectorize functions like the one
    above: [`np.vectorize()`](https://numpy.org/doc/stable/reference/generated/numpy.vectorize.html#numpy.vectorize).
    `np.vectorize()` takes in a unary function, and outputs a vectorized version of
    it that is able to take entire arrays as an input. Here’s an example. Compare
    this to us using `map()` before.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种方法可以自动向量化像上面那样的函数：[`np.vectorize()`](https://numpy.org/doc/stable/reference/generated/numpy.vectorize.html#numpy.vectorize)。`np.vectorize()`
    接受一个一元函数，并输出其向量化版本，该版本能够接受整个数组作为输入。这里有一个例子。与之前我们使用 `map()` 相比。
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The above code doesn’t just demonstrate how to return functions from a function.
    It is also an example of using functions as function inputs. When a function takes
    in and spits out functions, there is an alternative way to use it that is unique
    to Python. You can use **[function decorators](https://www.python.org/dev/peps/pep-0318/).**
    You can *decorate* a function by using the `@` operator (Lutz [2013](#ref-Lutz13)).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码不仅展示了如何从函数中返回函数，而且也是使用函数作为函数输入的一个示例。当一个函数接受并输出函数时，有一种独特于 Python 的使用方式。你可以使用
    **[函数装饰器](https://www.python.org/dev/peps/pep-0318/)**。你可以通过使用 `@` 操作符来 **装饰**
    一个函数（Lutz [2013](#ref-Lutz13)）。
- en: If you decorate a function, it is equivalent to passing that function in to
    a function factory (aka outer function). That function will take the function
    you defined, alter it, and then give it back to you with the same name that you
    chose in the first place.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你装饰了一个函数，那么它相当于将该函数传递给一个函数工厂（也称为外部函数）。该函数将修改你定义的函数，然后以你在最初选择的名字将其返回给你。
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 15.4.1 Writing Our Own Decorators
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.4.1 编写我们自己的装饰器
- en: We can write our own function factory that can be used as decoration. The main
    restriction is that this function factory must take a function as an argument,
    too. This can sometimes be restrictive. You might have noticed that the definition
    of `func_factory()` from earlier in this section did not do that. If you don’t
    believe me, as an exercise, after you read this section, you might consider trying
    to rewrite the example from [15.3](/an-introduction-to-functional-programming#functions-as-function-outputs-in-r)
    that implements Monte Carlo sampling using common random numbers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写自己的函数工厂，它可以用作装饰。主要的限制是，这个函数工厂必须也接受一个函数作为参数。这有时可能很受限制。你可能已经注意到，本节前面 `func_factory()`
    的定义并没有这样做。如果你不相信我，作为练习，在你阅读本节之后，你可以尝试重写 [15.3](/an-introduction-to-functional-programming#functions-as-function-outputs-in-r)
    节中的示例，该示例使用常见随机数实现蒙特卡洛抽样。
- en: Before we get too ahead of ourselves, let’s describe the basics. Here is our
    first decorator function `add_greeting()`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们过于领先之前，让我们描述一下基础知识。这是我们的第一个装饰器函数 `add_greeting()`。
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The decorator `add_greeting()` returns a function that is an embellished version
    of the function it is given. When we decorate a function with it, it looks like
    this.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器 `add_greeting()` 返回一个函数，它是给定函数的装饰版本。当我们用这个装饰器装饰一个函数时，它看起来是这样的。
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You could get the same behavior by typing the following. They are equivalent!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入以下内容获得相同的行为。它们是等价的！
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Things can get a little more complicated when your decorators take additional
    arguments.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的装饰器接受额外的参数时，事情可能会变得稍微复杂一些。
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'So how do we write decorators that accomplish this? The important thing to
    remember is that `@add_greeting("How you doin''")` in the previous code block
    is equivalent to writing this after the function definition: `print_name = add_greeting("How
    you doin''")(print_name)`. This is a function returning a function returning a
    function! The definition of `add_greeting()` could look something like this.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何编写实现这一点的装饰器呢？重要的是要记住，在之前的代码块中的 `@add_greeting("How you doin'")` 等同于在函数定义之后编写以下内容：`print_name
    = add_greeting("How you doin'")(print_name)`。这是一个返回函数的函数，返回函数！`add_greeting()`
    的定义可能看起来像这样。
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now that you know how decorators work, you can feel comfortable using third-party
    ones. You might come across, for example, the `@jit` decorator from [Numba](https://numba.pydata.org/),
    which will translate your Python function into faster machine code, the `@lru_cache`
    decorator from the [`functools` module](https://docs.python.org/3/library/functools.html)–this
    can make your code faster by saving some of its outputs–or decorators that perform
    application specific tasks like [`@tf.function`](https://www.tensorflow.org/api_docs/python/tf/function)
    from Tensorflow.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了装饰器是如何工作的，你可以放心地使用第三方装饰器。例如，你可能会遇到来自 [Numba](https://numba.pydata.org/)
    的 `@jit` 装饰器，它可以将你的 Python 函数转换为更快的机器代码，来自 `functools` 模块的 `@lru_cache` 装饰器——这可以通过保存一些输出来使你的代码更快，或者执行特定应用任务的装饰器，例如来自
    Tensorflow 的 `@tf.function`。
- en: 15.5 Exercises
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.5 练习
- en: 15.5.1 Python Questions
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.5.1 Python 问题
- en: Write a function decorator called `@log_dens_eval(left_bound, right_bound)`.
    When it decorates a function, say `func(x)`, it will not change that function’s
    input or output, but it will verify that the input to the function (in this case
    `x`) is between `left_bound` and `right_bound`. If it is not, it will return negative
    infinity.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为 `@log_dens_eval(left_bound, right_bound)` 的函数装饰器。当它装饰一个函数时，比如 `func(x)`，它不会改变该函数的输入或输出，但它将验证函数的输入（在这种情况下为
    `x`）是否在 `left_bound` 和 `right_bound` 之间。如果不是，它将返回负无穷大。
- en: The Split-Apply-Combine strategy might be useful in writing code for a tree-based
    model (Breiman et al. [1984](#ref-trees)). We won’t discuss how these models are
    estimated, but we will write a function that generates another function that is
    able to generate predictions by stratifying the input/predictor/feature space.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Split-Apply-Combine 策略可能对编写基于树的模型的代码很有用（Breiman 等人 [1984](#ref-trees)）。我们不会讨论这些模型是如何估计的，但我们将编写一个函数，该函数可以生成另一个函数，该函数能够通过分层输入/预测器/特征空间来生成预测。
- en: Import the data `"winequality-red.csv"`, call it `wine`, and remove all columns
    except for `fixed acidity`, `volatile acidity`, and `quality`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入数据 `"winequality-red.csv"`，命名为 `wine`，并删除除 `fixed acidity`、`volatile acidity`
    和 `quality` 之外的所有列。
- en: Write a function called `generate_pred_func(fixed_cutoff, vol_cutoff, dataset)`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为 `generate_pred_func(fixed_cutoff, vol_cutoff, dataset)` 的函数。
- en: The `dataset` argument should be a Pandas `DataFrame` that has three columns
    called `fixed acidity`, `volatile acidity`, and `quality`.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dataset` 参数应该是一个 Pandas `DataFrame`，它有三个名为 `fixed acidity`、`volatile acidity`
    和 `quality` 的列。'
- en: The `fixed_cutoff` argument should be a floating point number that separates
    `fixed acidity` into two regions.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixed_cutoff` 参数应该是一个浮点数，用于将 `fixed acidity` 分为两个区域。'
- en: The `vol_cutoff` argument should be a floating point number that separates `volatile
    acidity` into two regions.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vol_cutoff` 参数应该是一个浮点数，用于将 `volatile acidity` 分为两个区域。'
- en: The function should return a function, say `func(fixed_acidity, volatile_acidity)`.
    The two arguments are floating points. This function should return the most frequent
    `quality` observation out of all points whose inputs lie in in the corresponding
    region in the feature space.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数应该返回一个函数，比如 `func(fixed_acidity, volatile_acidity)`。这两个参数是浮点数。这个函数应该返回所有输入位于特征空间中相应区域的所有点的最频繁的
    `quality` 观察结果。
- en: 'After you finish the problem, you should have a definition of a `generate_pred_func()`
    that could be used as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 完成问题后，你应该有一个 `generate_pred_func()` 的定义，它可以如下使用：
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Let’s predict what type of activity some is doing based on measurements taken
    from their cell phone. We will begin implementing a **K-Nearest Neighbors (KNN)
    classifier** (Fix and Hodges [1989](#ref-knn1)) (Cover and Hart [1967](#ref-knn2)).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们根据从他们的手机中获取的测量数据来预测某人正在做什么活动。我们将开始实现一个 **K-Nearest Neighbors (KNN) 分类器**（Fix
    和 Hodges [1989](#ref-knn1)）（Cover 和 Hart [1967](#ref-knn2)）。
- en: Consider the data files `"X_train.txt"` and `"y_train.txt"` from (Anguita et
    al. [2013](#ref-Anguita2013APD)), which is available from the UCI Machine Learning
    Repository (Dua and Graff [2017](#ref-uci_data)). The first data set consists
    of recorded movements from a cell phone, and the second data set consists of activity
    labels of people. Labels \(1\) through \(6\) correspond to walking, walking upstairs,
    walking downstairs, sitting, standing and laying, respectively.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑来自 (Anguita 等人 [2013](#ref-Anguita2013APD)) 的数据文件 `"X_train.txt"` 和 `"y_train.txt"`，这些文件可以从
    UCI 机器学习仓库 (Dua 和 Graff [2017](#ref-uci_data)) 获取。第一个数据集包含来自手机的记录动作，第二个数据集包含人们的活动标签。标签
    \(1\) 到 \(6\) 分别对应步行、上楼、下楼、坐着、站着和躺着。
- en: Read in `"X_train.txt"` as a `DataFrame` called `x_train`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `"X_train.txt"` 读取为名为 `x_train` 的 `DataFrame`。
- en: Read in `"y_train.txt"` as a `DataFrame` called `y_train`
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `"y_train.txt"` 读取为名为 `y_train` 的 `DataFrame`。
- en: Define a function called `standardize(arr)` that takes in an array-like and
    returns a standardized version of the array-like. Do this by subtracting from
    each element the overall mean and dividing each element by the standard deviation
    (use the length as a denominator, not length minus \(1\)).
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `standardize(arr)` 的函数，它接受一个类似数组的对象，并返回该类似数组的标准化版本。通过从每个元素中减去整体均值并除以标准差（使用长度作为分母，而不是长度减
    \(1\)）来实现这一点。
- en: Apply `standardize()` to each column and transform `x_train` by replacing all
    of its column by their standardized versions. Make sure to overwrite `x_train`.
    Do this in one line of code.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `standardize()` 应用到每一列，并通过用它们的标准化版本替换所有列来转换 `x_train`。确保覆盖 `x_train`。用一行代码完成此操作。
- en: Write a function called `euclid_dist(arr1, arr2)` that calculates Euclidean
    distance between two points/array-likes.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为 `euclid_dist(arr1, arr2)` 的函数，它计算两个点/数组-类似对象的欧几里得距离。
- en: What is the most common label among the 5 rows that are closest to the first
    row? Assign your answer to `my_predict`. Assume that the two data sets you imported
    have the same order. Don’t include the first row in these \(5\) *nearest neighbors*.
    Take care not to modify `x_train` or `y_train`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在距离第一行最近的 5 行中，最常见的标签是什么？将你的答案赋值给 `my_predict`。假设你导入的两个数据集具有相同的顺序。在这些 \(5\)
    个 *最近邻* 中不要包括第一行。注意不要修改 `x_train` 或 `y_train`。
- en: 15.5.2 R Questions
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.5.2 R 问题
- en: The density of a particular bivariate Gaussian distribution is
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 特定的双变量高斯分布的密度是
- en: '\[ f(x,y) = \frac{1}{2 \pi} \exp\left[ -\frac{x ^2 + y^2}{2} \right] \tag{1}.
    \] The random elements \(X\) and \(Y\), in this particular case, are independent,
    each have unit variance, and zero mean. In this case, the marginal for \(X\) is
    a mean \(0\), unit variance normal distribution:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: \[ f(x,y) = \frac{1}{2 \pi} \exp\left[ -\frac{x ^2 + y^2}{2} \right] \tag{1}.
    \] 在这个特定情况下，随机元素 \(X\) 和 \(Y\) 是独立的，每个都有单位方差和零均值。在这种情况下，\(X\) 的边缘分布是一个均值为 \(0\)，单位方差的正态分布：
- en: \[ g(x) = \frac{1}{\sqrt{2\pi}} \exp\left[ -\frac{x ^2 }{2} \right] \tag{2}.
    \]
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: \[ g(x) = \frac{1}{\sqrt{2\pi}} \exp\left[ -\frac{x ^2 }{2} \right] \tag{2}.
    \]
- en: Write a function called `fTwoArgs(x,y)` that takes two arguments, and returns
    the value of the above density in equation (1) at those two points.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为 `fTwoArgs(x,y)` 的函数，它接受两个参数，并返回上述方程（1）在这两个点上的密度值。
- en: 'Write a function called `fOneArg(vec)` that takes one argument: a length two
    `vector`. It should return a density in equation (1) evaluated at that point.'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为 `fOneArg(vec)` 的函数，它接受一个参数：一个长度为二的 `vector`。它应该在这一点上返回方程（1）中的密度。
- en: Write a function called `gOneArg(x)` that evaluates the density in (2).
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为 `gOneArg(x)` 的函数，它评估方程（2）中的密度。
- en: Generate two sequences called `xPoints` and `yPoints`. Have them contain the
    twenty equally-spaced numbers going from \(-3\) to \(3\), inclusive.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成两个序列 `xPoints` 和 `yPoints`。让它们包含从 \(-3\) 到 \(3\) 的二十个等间距的数，包括 \(3\)。
- en: Use `expand.grid()` to create a `data.frame` called `myGrid`. It should have
    two columns, and it should contain in its rows every possible pair of two points
    from the above sequences. The “x” coordinates should be in the first column.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `expand.grid()` 创建一个名为 `myGrid` 的 `data.frame`。它应该有两个列，并且在其行中包含上述序列中每对两个点的所有可能组合。"x"
    坐标应在第一列。
- en: Use `mapply()` to evaluate the bivariate density on every grid point. Store
    your results in a `vector` `mEvals`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `mapply()` 在每个网格点上评估双变量密度。将结果存储在 `vector` `mEvals` 中。
- en: Use `apply()` to evaluate the bivariate density on every grid point. Store your
    results in a `vector` `aEvals`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `apply()` 在每个网格点上评估双变量密度。将结果存储在 `vector` `aEvals` 中。
- en: Use `sapply()` to evaluate the univariate density on every element of `xPoints`.
    Store your results in a `vector` `sEvals`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sapply()`评估`xPoints`中每个元素的单一变量密度。将你的结果存储在`vector` `sEvals`中。
- en: Use `vapply` to evaluate the univariate density on every element of `xPoints`.
    Store your results in `vector` `vEvals`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`vapply`评估`xPoints`中每个元素的单一变量密度。将你的结果存储在`vector` `vEvals`中。
- en: Use `lapply` to evaluate the univariate density on every element of `xPoints`.
    Store your results in a `list` `lEvals`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`lapply`评估`xPoints`中每个元素的单一变量密度。将你的结果存储在`list` `lEvals`中。
- en: Generate two plots of the bivariate density. For one, use `persp()`. For the
    other, use `contour()`. Feel free to revive the code you used in Chapter 13’s
    Exercise 1.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成两个双变量密度的图。对于其中一个，使用`persp()`。对于另一个，使用`contour()`。你可以自由地恢复你在第13章练习1中使用的代码。
- en: Generate a third plot of the univariate density. Feel free to revive the code
    you used in Chapter 13’s Exercises.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成第三个单一变量密度的图。你可以自由地恢复你在第13章练习中使用的代码。
- en: Write a function that reads in all of the data sets contained in any given folder.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，用于读取任何给定文件夹中包含的所有数据集。
- en: The function should be called `readAllData(path, extensions)`.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数应该被调用为`readAllData(path, extensions)`。
- en: The first argument, `path`, should be a string representing which folder you
    would like to search for files.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数，`path`，应该是一个字符串，表示你想要搜索文件的文件夹。
- en: The second argument, `extensions`, should be a `character` `vector` of all the
    file extensions you are interested in reading in (e.g. `c('.txt','.csv')`). Be
    careful about using regular expressions!
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数，`extensions`，应该是一个包含你想要读取的所有文件扩展名的`character` `vector`（例如，`c('.txt','.csv')`）。在使用正则表达式时要小心！
- en: The function should return a `list` of `data.frame`s.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数应该返回一个`data.frame`s的`list`。
- en: 'Consider the Militarized Interstate Disputes (v5.0) (Palmer et al.) data sets
    again: `"MIDA 5.0.csv"`, `"MIDB 5.0.csv"`, `"MIDI 5.0.csv"`, and `"MIDIP 5.0.csv"`.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑军事化国家间争端（v5.0）数据集：`"MIDA 5.0.csv"`，`"MIDB 5.0.csv"`，`"MIDI 5.0.csv"`，和`"MIDIP
    5.0.csv"`。
- en: Read these data sets in as a `list` of `data.frame`s. Call it `dfList`.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些数据集作为`data.frame`s的`list`读取。命名为`dfList`。
- en: Use `lapply()` and `do.call()` to calculate the biggest column average for all
    of these data sets. Store this average as `biggestAve`. Store the name of the
    column that had this biggest average as `whichBiggestAve`. Don’t worry about storing
    which data set this column mean was found in.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`lapply()`和`do.call()`计算所有这些数据集的最大列平均值。将这个平均值存储为`biggestAve`。存储具有这个最大平均值的列的名称作为`whichBiggestAve`。不用担心存储这个列均值所在的数据集。
- en: Use `Reduce()` and `lapply()` to, once again, calculate the biggest column average.
    Store this number as `biggestAve2`
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Reduce()`和`lapply()`再次计算最大的列平均值。将这个数字存储为`biggestAve2`
- en: 'Abelson, Harold, and Gerald J. Sussman. 1996\. *Structure and Interpretation
    of Computer Programs*. 2nd ed. Cambridge, MA, USA: MIT Press.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Abelson, Harold，和Gerald J. Sussman. 1996\. *计算机程序的结构与解释*. 第2版. 美国，马萨诸塞州剑桥：MIT
    Press。
- en: “Adult.” 1996\. UCI Machine Learning Repository.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: “成人。” 1996\. UCI机器学习数据库。
- en: Albemarle County Geographic Data Services Office. 2021\. “Albemarle County GIS
    Web.” [https://www.albemarle.org/government/community-development/gis-mapping/gis-data](https://www.albemarle.org/government/community-development/gis-mapping/gis-data).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Albemarle县地理数据服务办公室。2021\. “Albemarle县GIS网络。” [https://www.albemarle.org/government/community-development/gis-mapping/gis-data](https://www.albemarle.org/government/community-development/gis-mapping/gis-data)。
- en: 'Albon, Chris. 2018\. *Machine Learning with Python Cookbook: Practical Solutions
    from Preprocessing to Deep Learning*. 1st ed. O’Reilly Media, Inc.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Albon, Chris. 2018\. *使用Python进行机器学习食谱：从预处理到深度学习的实用解决方案*. 第1版. O’Reilly Media,
    Inc.
- en: Anguita, D., Alessandro Ghio, L. Oneto, Xavier Parra, and Jorge Luis Reyes-Ortiz.
    2013\. “A Public Domain Dataset for Human Activity Recognition Using Smartphones.”
    In *ESANN*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Anguita, D., Alessandro Ghio, L. Oneto, Xavier Parra, and Jorge Luis Reyes-Ortiz.
    2013\. “使用智能手机进行人类活动识别的公共领域数据集。” In *ESANN*.
- en: 'Beazley, David M., and Brian K. (Brian Kenneth) Jones. 2014\. *Python Cookbook:
    Recipes for Mastering Python 3*. Third. pub-ora-media:adr: pub-ora-media.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 'Beazley, David M.，和Brian K. (Brian Kenneth) Jones. 2014\. *Python食谱：精通Python
    3的秘籍*. 第三版. pub-ora-media:adr: pub-ora-media。'
- en: 'Breiman, L., J. H. Friedman, R. A. Olshen, and C. J. Stone. 1984\. *Classification
    and Regression Trees*. Monterey, CA: Wadsworth; Brooks.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Breiman, L., J. H. Friedman, R. A. Olshen, and C. J. Stone. 1984\. *分类与回归树*.
    加利福尼亚州蒙特雷：Wadsworth; Brooks.
- en: 'Brown, Taylor. 2021\. *CPseudoMaRg: Constructs a Correlated Pseudo-Marginal
    Sampler*. [https://CRAN.R-project.org/package=cPseudoMaRg](https://CRAN.R-project.org/package=cPseudoMaRg).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 'Brown, Taylor. 2021\. *CPseudoMaRg: Constructs a Correlated Pseudo-Marginal
    Sampler*. [https://CRAN.R-project.org/package=cPseudoMaRg](https://CRAN.R-project.org/package=cPseudoMaRg).'
- en: “Car Evaluation.” 1997\. UCI Machine Learning Repository.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: “Car Evaluation.” 1997\. UCI Machine Learning Repository.
- en: 'Carvalho, Carlos M., Nicholas G. Polson, and James G. Scott. 2009\. “Handling
    Sparsity via the Horseshoe.” In *Proceedings of the Twelth International Conference
    on Artificial Intelligence and Statistics*, edited by David van Dyk and Max Welling,
    5:73–80\. Proceedings of Machine Learning Research. Hilton Clearwater Beach Resort,
    Clearwater Beach, Florida USA: PMLR. [https://proceedings.mlr.press/v5/carvalho09a.html](https://proceedings.mlr.press/v5/carvalho09a.html).'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 'Carvalho, Carlos M., Nicholas G. Polson, and James G. Scott. 2009\. “Handling
    Sparsity via the Horseshoe.” In *Proceedings of the Twelth International Conference
    on Artificial Intelligence and Statistics*, edited by David van Dyk and Max Welling,
    5:73–80\. Proceedings of Machine Learning Research. Hilton Clearwater Beach Resort,
    Clearwater Beach, Florida USA: PMLR. [https://proceedings.mlr.press/v5/carvalho09a.html](https://proceedings.mlr.press/v5/carvalho09a.html).'
- en: Chang, Winston. 2013\. *R Graphics Cookbook*. O’Reilly Media, Inc.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Chang, Winston. 2013\. *R Graphics Cookbook*. O’Reilly Media, Inc.
- en: “Chess (King-Rook vs. King-Pawn).” 1989\. UCI Machine Learning Repository.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: “Chess (King-Rook vs. King-Pawn).” 1989\. UCI Machine Learning Repository.
- en: 'Cortez, Paulo, António Cerdeira, Fernando Almeida, Telmo Matos, and José Reis.
    2009\. “Modeling Wine Preferences by Data Mining from Physicochemical Properties.”
    *Decis. Support Syst.* 47 (4): 547–53\. [http://dblp.uni-trier.de/db/journals/dss/dss47.html#CortezCAMR09](http://dblp.uni-trier.de/db/journals/dss/dss47.html#CortezCAMR09).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 'Cortez, Paulo, António Cerdeira, Fernando Almeida, Telmo Matos, and José Reis.
    2009\. “Modeling Wine Preferences by Data Mining from Physicochemical Properties.”
    *Decis. Support Syst.* 47 (4): 547–53\. [http://dblp.uni-trier.de/db/journals/dss/dss47.html#CortezCAMR09](http://dblp.uni-trier.de/db/journals/dss/dss47.html#CortezCAMR09).'
- en: 'Cover, T., and P. Hart. 1967\. “Nearest Neighbor Pattern Classification.” *IEEE
    Transactions on Information Theory* 13 (1): 21–27\. [https://doi.org/10.1109/TIT.1967.1053964](https://doi.org/10.1109/TIT.1967.1053964).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'Cover, T., and P. Hart. 1967\. “Nearest Neighbor Pattern Classification.” *IEEE
    Transactions on Information Theory* 13 (1): 21–27\. [https://doi.org/10.1109/TIT.1967.1053964](https://doi.org/10.1109/TIT.1967.1053964).'
- en: Dua, Dheeru, and Casey Graff. 2017\. “UCI Machine Learning Repository.” University
    of California, Irvine, School of Information; Computer Sciences. [http://archive.ics.uci.edu/ml](http://archive.ics.uci.edu/ml).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Dua, Dheeru, and Casey Graff. 2017\. “UCI Machine Learning Repository.” University
    of California, Irvine, School of Information; Computer Sciences. [http://archive.ics.uci.edu/ml](http://archive.ics.uci.edu/ml).
- en: 'Efron, B. 1979\. “Bootstrap Methods: Another Look at the Jackknife.” *The Annals
    of Statistics* 7 (1): 1–26\. [https://doi.org/10.1214/aos/1176344552](https://doi.org/10.1214/aos/1176344552).'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 'Efron, B. 1979\. “Bootstrap Methods: Another Look at the Jackknife.” *The Annals
    of Statistics* 7 (1): 1–26\. [https://doi.org/10.1214/aos/1176344552](https://doi.org/10.1214/aos/1176344552).'
- en: Fisher, Test, R.A. & Creator. 1988\. “Iris.” UCI Machine Learning Repository.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Fisher, Test, R.A. & Creator. 1988\. “Iris.” UCI Machine Learning Repository.
- en: 'Fix, Evelyn, and J. L. Hodges. 1989\. “Discriminatory Analysis. Nonparametric
    Discrimination: Consistency Properties.” *International Statistical Review / Revue
    Internationale de Statistique* 57 (3): 238–47\. [http://www.jstor.org/stable/1403797](http://www.jstor.org/stable/1403797).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 'Fix, Evelyn, and J. L. Hodges. 1989\. “Discriminatory Analysis. Nonparametric
    Discrimination: Consistency Properties.” *International Statistical Review / Revue
    Internationale de Statistique* 57 (3): 238–47\. [http://www.jstor.org/stable/1403797](http://www.jstor.org/stable/1403797).'
- en: 'Ford, Clay. 2016\. “ggplot: Files for UVA StatLab workshop, Fall 2016.” *GitHub
    Repository*. [https://github.com/clayford/ggplot2](https://github.com/clayford/ggplot2);
    GitHub.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 'Ford, Clay. 2016\. “ggplot: Files for UVA StatLab workshop, Fall 2016.” *GitHub
    Repository*. [https://github.com/clayford/ggplot2](https://github.com/clayford/ggplot2);
    GitHub.'
- en: Gelman, Andrew, and Jennifer Hill. 2007\. *Data Analysis Using Regression and
    Multilevel/Hierarchical Models*. Analytical Methods for Social Research. Cambridge
    University Press.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Gelman, Andrew, and Jennifer Hill. 2007\. *Data Analysis Using Regression and
    Multilevel/Hierarchical Models*. Analytical Methods for Social Research. Cambridge
    University Press.
- en: 'Grolemund, G. 2014\. *Hands-on Programming with R: Write Your Own Functions
    and Simulations*. O’Reilly Media. [https://books.google.com/books?id=S04BBAAAQBAJ](https://books.google.com/books?id=S04BBAAAQBAJ).'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 'Grolemund, G. 2014\. *Hands-on Programming with R: Write Your Own Functions
    and Simulations*. O’Reilly Media. [https://books.google.com/books?id=S04BBAAAQBAJ](https://books.google.com/books?id=S04BBAAAQBAJ).'
- en: “GSPC Data.” 2021\. [https://finance.yahoo.com/quote/%5EGSPC/history?p=%5EGSPC](https://finance.yahoo.com/quote/%5EGSPC/history?p=%5EGSPC).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: “GSPC Data.” 2021\. [https://finance.yahoo.com/quote/%5EGSPC/history?p=%5EGSPC](https://finance.yahoo.com/quote/%5EGSPC/history?p=%5EGSPC).
- en: 'Guttman, Louis. 1946\. “Enlargement Methods for Computing the Inverse Matrix.”
    *The Annals of Mathematical Statistics* 17 (3): 336–43\. [https://doi.org/10.1214/aoms/1177730946](https://doi.org/10.1214/aoms/1177730946).'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Guttman, Louis. 1946\. “计算逆矩阵的扩展方法。” *《数学统计年鉴》* 第17卷（第3期）：336–43。[https://doi.org/10.1214/aoms/1177730946](https://doi.org/10.1214/aoms/1177730946).
- en: 'Harrell Jr, Frank E, with contributions from Charles Dupont, and many others.
    2021\. *Hmisc: Harrell Miscellaneous*. [https://CRAN.R-project.org/package=Hmisc](https://CRAN.R-project.org/package=Hmisc).'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Harrell Jr, Frank E，Charles Dupont等人的贡献。2021\. *《Hmisc：Harrell杂项》*。[https://CRAN.R-project.org/package=Hmisc](https://CRAN.R-project.org/package=Hmisc).
- en: 'Harris, Charles R., K. Jarrod Millman, Stéfan J. van der Walt, Ralf Gommers,
    Pauli Virtanen, David Cournapeau, Eric Wieser, et al. 2020\. “Array Programming
    with NumPy.” *Nature* 585 (7825): 357–62\. [https://doi.org/10.1038/s41586-020-2649-2](https://doi.org/10.1038/s41586-020-2649-2).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Harris, Charles R.，K. Jarrod Millman，Stéfan J. van der Walt，Ralf Gommers，Pauli
    Virtanen，David Cournapeau，Eric Wieser等。2020\. “使用NumPy进行数组编程。” *《自然》* 第585卷（第7825期）：357–62。[https://doi.org/10.1038/s41586-020-2649-2](https://doi.org/10.1038/s41586-020-2649-2).
- en: 'Hunt, Andrew, and David Thomas. 2000\. *The Pragmatic Programmer : From Journeyman
    to Master*. Boston [etc.]: Addison-Wesley. [http://www.amazon.com/The-Pragmatic-Programmer-Journeyman-Master/dp/020161622X](http://www.amazon.com/The-Pragmatic-Programmer-Journeyman-Master/dp/020161622X).'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Hunt, Andrew，David Thomas。2000\. *《实用程序员：从学徒到大师》* 波士顿等地：Addison-Wesley。[http://www.amazon.com/The-Pragmatic-Programmer-Journeyman-Master/dp/020161622X](http://www.amazon.com/The-Pragmatic-Programmer-Journeyman-Master/dp/020161622X).
- en: 'Hunter, J. D. 2007\. “Matplotlib: A 2D Graphics Environment.” *Computing in
    Science & Engineering* 9 (3): 90–95\. [https://doi.org/10.1109/MCSE.2007.55](https://doi.org/10.1109/MCSE.2007.55).'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Hunter, J. D. 2007\. “Matplotlib：一个二维图形环境。” *《科学工程计算》* 第9卷（第3期）：90–95。[https://doi.org/10.1109/MCSE.2007.55](https://doi.org/10.1109/MCSE.2007.55).
- en: Janosi, Andras, William Steinbrunn, Matthias Pfisterer, and Robert Detrano.
    1988\. “Heart Disease.” UCI Machine Learning Repository.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Janosi, Andras，William Steinbrunn，Matthias Pfisterer，Robert Detrano。1988\. “心脏病。”
    UCI机器学习库。
- en: 'Jones, Karen Spärck. 1972\. “A Statistical Interpretation of Term Specificity
    and Its Application in Retrieval.” *Journal of Documentation* 28: 11–21.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Jones, Karen Spärck。1972\. “术语特定性的统计解释及其在检索中的应用。” *《文献学杂志》* 第28卷：11–21。
- en: Kabacoff, Robert I. 2015\. *R in Action*. Second. Manning. [http://www.worldcat.org/isbn/9781617291388](http://www.worldcat.org/isbn/9781617291388).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Kabacoff, Robert I. 2015\. *《R语言实战》* 第二版. Manning。[http://www.worldcat.org/isbn/9781617291388](http://www.worldcat.org/isbn/9781617291388).
- en: Kahn, H. 1950\. “Random Sampling (Monte Carlo) Techniques in Neutron Attenuation
    Problems–I.” *Nucleonics* 6 5.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Kahn, H. 1950\. “随机抽样（蒙特卡洛）技术在中子衰减问题中的应用（一）。” *《核子学》* 第6卷，第5期。
- en: 'Kahn, H. 1950\. “Random Sampling (Monte Carlo) Techniques in Neutron Attenuation
    Problems. II.” *Nucleonics (U.S.) Ceased Publication* Vol: 6, No. 6 (June). [https://www.osti.gov/biblio/4399718](https://www.osti.gov/biblio/4399718).'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Kahn, H. 1950\. “随机抽样（蒙特卡洛）技术在中子衰减问题中的应用（二）。” *《核子学》（美国）已停刊* 第6卷，第6期（六月）。[https://www.osti.gov/biblio/4399718](https://www.osti.gov/biblio/4399718).
- en: 'Kalman, R. E. 1960\. “A New Approach to Linear Filtering and Prediction Problems.”
    *Journal of Basic Engineering* 82 (1): 35–45\. [https://doi.org/10.1115/1.3662552](https://doi.org/10.1115/1.3662552).'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Kalman, R. E. 1960\. “线性滤波和预测问题的新方法。” *《基础工程杂志》* 第82卷（第1期）：35–45。[https://doi.org/10.1115/1.3662552](https://doi.org/10.1115/1.3662552).
- en: 'Lander, Jared P. 2017\. *R for Everyone: Advanced Analytics and Graphics (2nd
    Edition)*. 2nd ed. Addison-Wesley Professional.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Lander, Jared P. 2017\. *《R语言入门：高级分析和图形（第2版）》* 第2版. Addison-Wesley Professional.
- en: 'López, Félix. 2014\. *Mastering Python Regular Expressions : Leverage Regular
    Expressions in Python Even for the Most Complex Features*. Birmingham, UK: Packt
    Pub.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: López, Félix. 2014\. *《精通Python正则表达式：利用Python的正则表达式，即使是复杂特性也能轻松应对》* 伯明翰，英国：Packt
    Pub.
- en: 'Lutz, Mark. 2013\. *Learning Python*. 5th ed. Beijing: O’Reilly. [https://www.safaribooksonline.com/library/view/learning-python-5th/9781449355722/](https://www.safaribooksonline.com/library/view/learning-python-5th/9781449355722/).'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Lutz, Mark. 2013\. *《学习Python》* 第5版. 北京：O’Reilly。[https://www.safaribooksonline.com/library/view/learning-python-5th/9781449355722/](https://www.safaribooksonline.com/library/view/learning-python-5th/9781449355722/).
- en: 'Matloff, Norman. 2011\. *The Art of R Programming: A Tour of Statistical Software
    Design*. 1st ed. USA: No Starch Press.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Matloff, Norman. 2011\. *《R编程艺术：统计软件设计之旅》* 第1版. 美国：No Starch Press.
- en: 'McKinney, Wes. 2017\. *Python for Data Analysis: Data Wrangling with Pandas,
    Numpy, and Ipython*. 2nd ed. O’Reilly Media, Inc.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: McKinney, Wes. 2017\. *《Python数据分析：使用Pandas、Numpy和Ipython进行数据处理》* 第2版. O’Reilly
    Media, Inc.
- en: 'Nadaraya, E. A. 1964\. “On Estimating Regression.” *Theory of Probability &
    Its Applications* 9 (1): 141–42\. [https://doi.org/10.1137/1109020](https://doi.org/10.1137/1109020).'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '纳达拉亚，E. A. 1964\. “关于回归估计。” *概率论及其应用理论* 9 (1): 141–42\. [https://doi.org/10.1137/1109020](https://doi.org/10.1137/1109020).'
- en: 'Palmer, Glenn, Roseanne W McManus, Vito D’Orazio, Michael R Kenwick, Mikaela
    Karstens, Chase Bloch, Nick Dietrich, Kayla Kahn, Kellan Ritter, and Michael J
    Soules“The Mid5 Dataset, 2011–2014: Procedures, Coding Rules, and Description.”
    *Conflict Management and Peace Science* 0 (0): 0738894221995743\. [https://doi.org/10.1177/0738894221995743](https://doi.org/10.1177/0738894221995743).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '帕尔默，格伦，罗莎妮·W·麦克曼斯，维托·多拉齐奥，迈克尔·R·肯威克，米凯拉·卡尔滕斯，查斯·布洛克，尼克·迪特里奇，凯拉·卡恩，凯兰·里特，迈克尔·J·索尔斯“Mid5
    数据集，2011–2014：程序、编码规则和描述。” *冲突管理与和平科学* 0 (0): 0738894221995743\. [https://doi.org/10.1177/0738894221995743](https://doi.org/10.1177/0738894221995743).'
- en: 'Robert, Christian P., and George Casella. 2005\. *Monte Carlo Statistical Methods
    (Springer Texts in Statistics)*. Berlin, Heidelberg: Springer-Verlag.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 罗伯特，克里斯蒂安·P.，和乔治·卡塞拉. 2005\. *蒙特卡洛统计方法（Springer 统计学系列）*. 柏林，海德堡：斯普林格-维尔格.
- en: “SAS ^(Viya ^(Example Data Sets.” 2021\. [https://support.sas.com/documentation/onlinedoc/viya/examples.htm](https://support.sas.com/documentation/onlinedoc/viya/examples.htm).))
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: “SAS^(Viya^(示例数据集)” 2021\. [https://support.sas.com/documentation/onlinedoc/viya/examples.htm](https://support.sas.com/documentation/onlinedoc/viya/examples.htm).))
- en: Socher, Richard, Alex Perelygin, Jean Wu, Jason Chuang, Christopher Manning,
    Andrew Ng, and Christopher Potts. 2013\. “Parsing with Compositional Vector Grammars.”
    In *EMNLP*.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 萨赫，理查德，亚历克斯·佩雷利金，简·吴，贾森·庄，克里斯托弗·曼宁，安德鲁·吴，和克里斯托弗·波茨. 2013\. “使用组合向量语法的解析。” 在
    *EMNLP*.
- en: Student. 1908\. “The Probable Error of a Mean.” *Biometrika*, 1–25.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 学生. 1908\. “均值的可能误差。” *生物计量学*，1–25.
- en: “TensorFlow Datasets, a Collection of Ready-to-Use Datasets.” 2021\. [https://www.tensorflow.org/datasets](https://www.tensorflow.org/datasets).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: “TensorFlow 数据集，一组现成的数据集。” 2021\. [https://www.tensorflow.org/datasets](https://www.tensorflow.org/datasets).
- en: 'VanderPlas, Jake. 2016\. *Python Data Science Handbook: Essential Tools for
    Working with Data*. 1st ed. O’Reilly Media, Inc.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 范德普拉斯，杰克. 2016\. *Python 数据科学手册：处理数据的基本工具*. 第1版. O’Reilly 媒体公司.
- en: 'Watson, Geoffrey S. 1964\. “Smooth Regression Analysis.” *Sankhyā: The Indian
    Journal of Statistics, Series A (1961-2002)* 26 (4): 359–72\. [http://www.jstor.org/stable/25049340](http://www.jstor.org/stable/25049340).'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '沃森，杰弗里·S. 1964\. “平滑回归分析。” *印度统计杂志，系列 A (1961-2002)* 26 (4): 359–72\. [http://www.jstor.org/stable/25049340](http://www.jstor.org/stable/25049340).'
- en: West, Michael A., and Jeff Harrison. 1989\. “Bayesian Forecasting and Dynamic
    Models.” In.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 威斯特，迈克尔·A.，和杰夫·哈里森. 1989\. “贝叶斯预测和动态模型。” 在.
- en: Wickham, H. 2014\. *Advanced R*. Chapman & Hall/Crc the R Series. Taylor & Francis.
    [https://books.google.com/books?id=PFHFNAEACAAJ](https://books.google.com/books?id=PFHFNAEACAAJ).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 惠克姆，H. 2014\. *高级 R*. 查普曼 & 哈尔/CRC R 系列图书. 泰勒 & 弗朗西斯. [https://books.google.com/books?id=PFHFNAEACAAJ](https://books.google.com/books?id=PFHFNAEACAAJ).
- en: 'Wickham, Hadley. 2016\. *Ggplot2: Elegant Graphics for Data Analysis*. Springer-Verlag
    New York. [https://ggplot2.tidyverse.org](https://ggplot2.tidyverse.org).'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 惠克姆，哈德利. 2016\. *Ggplot2：数据分析的优雅图形*. 斯普林格-维尔格纽约. [https://ggplot2.tidyverse.org](https://ggplot2.tidyverse.org).
- en: 'Wickham, Hadley, and Garrett Grolemund. 2017\. *R for Data Science: Import,
    Tidy, Transform, Visualize, and Model Data*. 1st ed. O’Reilly Media, Inc.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 惠克姆，哈德利，和加勒特·格罗勒蒙德. 2017\. *R 数据科学：导入、整理、转换、可视化和建模数据*. 第1版. O’Reilly 媒体公司.
- en: 'Wilkinson, Leland. 2005\. *The Grammar of Graphics (Statistics and Computing)*.
    Berlin, Heidelberg: Springer-Verlag.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 威尔金森，利兰. 2005\. *图形语法（统计学与计算）*. 柏林，海德堡：斯普林格-维尔格.
- en: References
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Abelson, Harold, and Gerald J. Sussman. 1996\. *Structure and Interpretation
    of Computer Programs*. 2nd ed. Cambridge, MA, USA: MIT Press.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 阿贝尔森，哈罗德，和杰拉尔德·J·苏斯曼. 1996\. *计算机程序的结构与解释*. 第2版. 美国，麻省，剑桥：麻省理工学院出版社.
- en: Albemarle County Geographic Data Services Office. 2021\. “Albemarle County GIS
    Web.” [https://www.albemarle.org/government/community-development/gis-mapping/gis-data](https://www.albemarle.org/government/community-development/gis-mapping/gis-data).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 阿尔伯马尔县地理数据服务办公室. 2021\. “阿尔伯马尔县 GIS 网站.” [https://www.albemarle.org/government/community-development/gis-mapping/gis-data](https://www.albemarle.org/government/community-development/gis-mapping/gis-data).
- en: Anguita, D., Alessandro Ghio, L. Oneto, Xavier Parra, and Jorge Luis Reyes-Ortiz.
    2013\. “A Public Domain Dataset for Human Activity Recognition Using Smartphones.”
    In *ESANN*.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 安古伊塔，D.，亚历山德罗·吉奥，L.奥内托， Xavier Parra，和豪尔赫·路易斯·雷耶斯-奥尔特斯. 2013\. “用于智能手机人体活动识别的公共领域数据集。”
    在 *ESANN*.
- en: 'Breiman, L., J. H. Friedman, R. A. Olshen, and C. J. Stone. 1984\. *Classification
    and Regression Trees*. Monterey, CA: Wadsworth; Brooks.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Breiman, L., J. H. Friedman, R. A. Olshen, and C. J. Stone. 1984\. *分类与回归树*.
    加利福尼亚州莫尼特雷：Wadsworth；布鲁克斯。
- en: 'Cover, T., and P. Hart. 1967\. “Nearest Neighbor Pattern Classification.” *IEEE
    Transactions on Information Theory* 13 (1): 21–27\. [https://doi.org/10.1109/TIT.1967.1053964](https://doi.org/10.1109/TIT.1967.1053964).'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 'Cover, T., and P. Hart. 1967\. “最近邻模式分类。” *IEEE信息理论汇刊* 13 (1): 21–27\. [https://doi.org/10.1109/TIT.1967.1053964](https://doi.org/10.1109/TIT.1967.1053964).'
- en: Dua, Dheeru, and Casey Graff. 2017\. “UCI Machine Learning Repository.” University
    of California, Irvine, School of Information; Computer Sciences. [http://archive.ics.uci.edu/ml](http://archive.ics.uci.edu/ml).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Dua, Dheeru, and Casey Graff. 2017\. “UCI机器学习仓库。” 加州大学欧文分校，信息学院；计算机科学系。 [http://archive.ics.uci.edu/ml](http://archive.ics.uci.edu/ml).
- en: 'Fix, Evelyn, and J. L. Hodges. 1989\. “Discriminatory Analysis. Nonparametric
    Discrimination: Consistency Properties.” *International Statistical Review / Revue
    Internationale de Statistique* 57 (3): 238–47\. [http://www.jstor.org/stable/1403797](http://www.jstor.org/stable/1403797).'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 'Fix, Evelyn, and J. L. Hodges. 1989\. “判别分析。非参数判别：一致性属性。” *国际统计评论/国际统计评论* 57
    (3): 238–47\. [http://www.jstor.org/stable/1403797](http://www.jstor.org/stable/1403797).'
- en: 'Ford, Clay. 2016\. “ggplot: Files for UVA StatLab workshop, Fall 2016.” *GitHub
    Repository*. [https://github.com/clayford/ggplot2](https://github.com/clayford/ggplot2);
    GitHub.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 'Ford, Clay. 2016\. “ggplot: UVA StatLab研讨会文件，2016年秋季。” *GitHub仓库*. [https://github.com/clayford/ggplot2](https://github.com/clayford/ggplot2);
    GitHub.'
- en: 'Hunt, Andrew, and David Thomas. 2000\. *The Pragmatic Programmer : From Journeyman
    to Master*. Boston [etc.]: Addison-Wesley. [http://www.amazon.com/The-Pragmatic-Programmer-Journeyman-Master/dp/020161622X](http://www.amazon.com/The-Pragmatic-Programmer-Journeyman-Master/dp/020161622X).'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Hunt, Andrew, and David Thomas. 2000\. *《实用程序员：从学徒到大师》*. 波士顿等地：Addison-Wesley.
    [http://www.amazon.com/The-Pragmatic-Programmer-Journeyman-Master/dp/020161622X](http://www.amazon.com/The-Pragmatic-Programmer-Journeyman-Master/dp/020161622X).
- en: 'Lutz, Mark. 2013\. *Learning Python*. 5th ed. Beijing: O’Reilly. [https://www.safaribooksonline.com/library/view/learning-python-5th/9781449355722/](https://www.safaribooksonline.com/library/view/learning-python-5th/9781449355722/).'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Lutz, Mark. 2013\. *学习Python*. 第5版. 北京：O’Reilly. [https://www.safaribooksonline.com/library/view/learning-python-5th/9781449355722/](https://www.safaribooksonline.com/library/view/learning-python-5th/9781449355722/).
- en: 'Palmer, Glenn, Roseanne W McManus, Vito D’Orazio, Michael R Kenwick, Mikaela
    Karstens, Chase Bloch, Nick Dietrich, Kayla Kahn, Kellan Ritter, and Michael J
    Soules“The Mid5 Dataset, 2011–2014: Procedures, Coding Rules, and Description.”
    *Conflict Management and Peace Science* 0 (0): 0738894221995743\. [https://doi.org/10.1177/0738894221995743](https://doi.org/10.1177/0738894221995743).'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 'Palmer, Glenn, Roseanne W McManus, Vito D’Orazio, Michael R Kenwick, Mikaela
    Karstens, Chase Bloch, Nick Dietrich, Kayla Kahn, Kellan Ritter, and Michael J
    Soules《2011–2014年Mid5数据集：程序、编码规则和描述》。*冲突管理与和平科学* 0 (0): 0738894221995743\. [https://doi.org/10.1177/0738894221995743](https://doi.org/10.1177/0738894221995743).'
- en: '* * *'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Even though this book only discusses *one* of our languages of interest, this
    quote applies to both langauges.[↩](/an-introduction-to-functional-programming#fnref27)
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管这本书只讨论了我们感兴趣的语言之一，但这句话适用于这两种语言。[↩](/an-introduction-to-functional-programming#fnref27)
- en: '`apply()` is everyone’s favorite whipping boy whenever it comes to comparing
    `apply()` against the other `*apply()` functions. This is because it is generally
    a little slower–it is written in R and doesn’t call out to compiled C code. However,
    in my humble opinion, it doesn’t matter all that much because the fractions of
    a second saved don’t always add up in practice. [↩](/an-introduction-to-functional-programming#fnref28)'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`apply()`是每个人在比较`apply()`与其他`*apply()`函数时最喜欢的“替罪羊”。这是因为它通常要慢一点——它是用R编写的，并且没有调用编译的C代码。然而，在我看来，这并不那么重要，因为节省的几秒钟在实际情况中并不总是累积起来。[↩](/an-introduction-to-functional-programming#fnref28)'
- en: Although, it is still variadic. The difference is that the `dot-dot-dot` symbol
    does not refer to a varying number of `data.frame`s, just a varying number of
    other things we don’t care about in this example.[↩](/an-introduction-to-functional-programming#fnref29)
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然，它仍然是可变参数的。区别在于，三个点符号并不指代可变数量的`data.frame`，而是指代在这个例子中我们不关心的其他可变数量的东西。[↩](/an-introduction-to-functional-programming#fnref29)
- en: To make it even more flexible, we could write code that doesn’t assume the functions
    are all named the same way, or in the same directory together.[↩](/an-introduction-to-functional-programming#fnref30)
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其更加灵活，我们可以编写不假设所有函数都使用相同名称或位于同一目录中的代码。[↩](/an-introduction-to-functional-programming#fnref30)
- en: You should know that a lot of special-case functions that you typically apply
    to rows or columns come built-in as `DataFrame` methods. For instance, `.mean()`
    would allow you to do something like `my_df.mean()`.[↩](/an-introduction-to-functional-programming#fnref31)
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该知道，许多通常应用于行或列的特殊情况函数作为`DataFrame`方法内置。例如，`.mean()`允许您执行类似`my_df.mean()`的操作。[↩](/an-introduction-to-functional-programming#fnref31)
