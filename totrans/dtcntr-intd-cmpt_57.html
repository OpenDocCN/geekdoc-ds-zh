<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>18.1Â Representing Sets as ListsğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>18.1Â Representing Sets as ListsğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/sets-from-lists.html">https://dcic-world.org/2025-08-27/sets-from-lists.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._.Representation_.Choices%29" class="toclink" data-pltdoc="x">18.1.1Â Representation Choices</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Time_.Complexity%29" class="toclink" data-pltdoc="x">18.1.2Â Time Complexity</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._choosing-set-reps%29" class="toclink" data-pltdoc="x">18.1.3Â Choosing Between Representations</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Other_.Operations%29" class="toclink" data-pltdoc="x">18.1.4Â Other Operations</a></p></td></tr></table><p>Earlier [<a href="Collections_of_Structured_Data.html#%28part._sets-as-collections%29" data-pltdoc="x">Sets as Collective Data</a>] we introduced sets. Recall
that the elements of a set have no specific order, and ignore
duplicates.If these ideas are not familiar, please read
<a href="Collections_of_Structured_Data.html#%28part._sets-as-collections%29" data-pltdoc="x">Sets as Collective Data</a>, since they will be important when
discussing the representation of sets. At that time we relied on
Pyretâ€™s built-in representation of sets. Now we will discuss how to
build sets for ourselves. In what follows, we will focus only on sets
of numbers.</p><p>We will start by discussing how to represent sets using
lists. Intuitively,
using lists to represent sets of data seems problematic,
because lists respect both order and duplication. For
instance,
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  [list: 1, 2, 3] is [list: 3, 2, 1, 1]
end</code></pre><p>fails, but the corresponding sets are equal.</p><p>In principle, we want sets to obey the following
interface:Note that a type called <code data-lang="pyret" class="sourceCode">Set</code> is already
built into Pyret, so below we will use the name <code data-lang="pyret" class="sourceCode">LSet</code> for a set
represented as a list.
</p><a name="(elem._set-operations)"/>&lt;set-operations&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">mt-set :: Set
is-in :: (T, Set&lt;T&gt; -&gt; Bool)
insert :: (T, Set&lt;T&gt; -&gt; Set&lt;T&gt;)
union :: (Set&lt;T&gt;, Set&lt;T&gt; -&gt; Set&lt;T&gt;)
size :: (Set&lt;T&gt; -&gt; Number)
to-list :: (Set&lt;T&gt; -&gt; List&lt;T&gt;)</code></pre><p>We may also find it also useful to have functions such as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">insert-many :: (List&lt;T&gt;, Set&lt;T&gt; -&gt; Set&lt;T&gt;)</code></pre><p>which, combined with <code data-lang="pyret" class="sourceCode">mt-set</code>, easily gives us a <code data-lang="pyret" class="sourceCode">to-set</code>
function.</p><p>Sets can contain many kinds of values, but not necessarily any kind:
we need to be able to check for two values being equal (which is a
requirement for a set, but not for a list!), which canâ€™t
be done with all values (such as functions). We discuss the nuances of
this elsewhere [<a href="orderability.html#%28part._eq-ord%29" data-pltdoc="x">Equality and Ordering</a>]. For now, we can ignore these
issues by focusing on sets of (non-rough)numbers.</p><section class="SsectionLevel4" id="section 18.1.1"><h4 class="heading">18.1.1Â <a name="(part._.Representation_.Choices)"/>Representation Choices<a href="#(part._.Representation_.Choices)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>The empty list can stand in for the empty setâ€”<wbr/>
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">type LSet = List
mt-set = empty</code></pre><p>â€”<wbr/>and we can presumably define <code data-lang="pyret" class="sourceCode">size</code> as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size&lt;T&gt;(s :: LSet&lt;T&gt;) -&gt; Number:
  s.length()
end</code></pre><p>However, this <a href="glossary.html#%28elem._glossary-reduction%29" data-pltdoc="x">â˜› reduction</a> (of sets to lists) can be
dangerous:
</p><ol><li><p>There is a subtle difference between lists and sets.  The list
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 1]</code></pre><p>is not the same as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1]</code></pre><p>because the first list has length two whereas the second has length
one.  Treated as a set, however, the two are the same: they both have
size one.  Thus, our implementation of <code data-lang="pyret" class="sourceCode">size</code> above is incorrect
if we donâ€™t take into account duplicates (either during insertion or
while computing the size).</p></li><li><p>We might falsely make assumptions about the order in which
elements are retrieved from the set due to the ordering guaranteed
provided by the underlying list representation.  This might hide bugs
that we donâ€™t discover until we change the representation.</p></li><li><p>We might have chosen a set representation because we didnâ€™t need
to care about order, and expected lots of duplicate items.  A list
representation might store all the duplicates, resulting in
significantly more memory use (and slower programs) than we expected.</p></li></ol><p>To avoid these perils, we have to be precise about how weâ€™re going to
use lists to represent sets.  One key question (but not the only one,
as weâ€™ll soon see [<a href="#%28part._choosing-set-reps%29" data-pltdoc="x">Choosing Between Representations</a>]) is what to do about duplicates.  One
possibility is for <code data-lang="pyret" class="sourceCode">insert</code> to check whether an element is
already in the set and, if so, leave the representation unchanged;
this incurs a cost during insertion but avoids unnecessary duplication
and lets us use <code data-lang="pyret" class="sourceCode">length</code> to implement <code data-lang="pyret" class="sourceCode">size</code>.  The other
option is to define <code data-lang="pyret" class="sourceCode">insert</code> as <code data-lang="pyret" class="sourceCode">link</code>â€”<wbr/>literally,
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">insert = link</code></pre><p>â€”<wbr/>and have some other procedure perform the filtering of duplicates.</p></section><section class="SsectionLevel4" id="section 18.1.2"><h4 class="heading">18.1.2Â <a name="(part._.Time_.Complexity)"/>Time Complexity<a href="#(part._.Time_.Complexity)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>What is the complexity of this representation of sets?  Letâ€™s consider
just <code data-lang="pyret" class="sourceCode">insert</code>, <code data-lang="pyret" class="sourceCode">is-in</code>, and <code data-lang="pyret" class="sourceCode">size</code>.
Suppose the size of the set is \(k\) (where, to avoid ambiguity,
we let \(k\) represent the number of distinct elements).
The complexity of these operations depends on whether or not we store
duplicates:
</p><ul><li><p>If we donâ€™t store duplicates, then <code data-lang="pyret" class="sourceCode">size</code> is simply
<code data-lang="pyret" class="sourceCode">length</code>, which takes time linear in \(k\).  Similarly,
<code data-lang="pyret" class="sourceCode">is-in</code> only needs to traverse the list once to determine whether
or not an element is present, which also takes time linear in
\(k\).  But <code data-lang="pyret" class="sourceCode">insert</code> needs to check whether an element is
already present, which takes time linear in \(k\), followed by
at most a constant-time operation (<code data-lang="pyret" class="sourceCode">link</code>).</p></li><li><p>If we do store duplicates, then <code data-lang="pyret" class="sourceCode">insert</code> is constant
time: it simply <code data-lang="pyret" class="sourceCode">link</code>s on the new element without regard to
whether it already is in the set representation.  <code data-lang="pyret" class="sourceCode">is-in</code>
traverses the list once, but the number of elements it needs to visit
could be significantly greater than \(k\), depending on how many
duplicates have been added.  Finally, <code data-lang="pyret" class="sourceCode">size</code> needs to check
whether or not each element is duplicated before counting it.</p></li></ul><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What is the time complexity of <code data-lang="pyret" class="sourceCode">size</code> if the list has duplicates?</p></blockquote></blockquote><p>One implementation of <code data-lang="pyret" class="sourceCode">size</code> is
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size&lt;T&gt;(s :: LSet&lt;T&gt;) -&gt; Number:
  cases (List) s:
    | empty =&gt; 0
    | link(f, r) =&gt;
      if r.member(f):
        size(r)
      else:
        1 + size(r)
      end
  end
end</code></pre><p>Letâ€™s now compute the complexity of the body of the function, assuming
the number of distinct elements in <code data-lang="pyret" class="sourceCode">s</code> is \(k\) but the
actual number of elements in <code data-lang="pyret" class="sourceCode">s</code> is \(d\), where
\(d \geq k\).  To compute the time to run <code data-lang="pyret" class="sourceCode">size</code> on \(d\)
elements, \(T(d)\), we should determine the number of operations in
each question and answer.  The first question has a constant number of
operations,
and the first answer also a constant.  The second question also has
a constant number of
operations.  Its answer is a conditional, whose first question
(<code data-lang="pyret" class="sourceCode">r.member(f)</code> needs to traverse the entire list, and hence has
\(O([k \rightarrow d])\) operations.  If it succeeds, we recur on something of size
\(T(d-1)\); else we do the same but perform a constant more operations.
Thus \(T(0)\) is a constant, while the recurrence (in big-Oh terms) is
</p><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}T(d) = d + T(d-1)\end{equation*}</p><p>Thus \(T \in O([d \rightarrow d^2])\).
Note that this is quadratic in the number of elements in the
list, which may be much bigger than the size of the
set.</p></section><section class="SsectionLevel4" id="section 18.1.3"><h4 class="heading">18.1.3Â <a name="(part._choosing-set-reps)"/>Choosing Between Representations<a href="#(part._choosing-set-reps)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Now that we have two representations with different complexities, itâ€™s
worth thinking about how to choose between them. To do so, letâ€™s build
up the following table. The table distinguishes between the
interface (the set) and the implementation (the list),
becauseâ€”<wbr/>owing to duplicates in the representationâ€”<wbr/>these two may
not be the same. In the table weâ€™ll consider just two of the most
common operations, insertion and membership checking:
</p><table cellspacing="0" cellpadding="0"><tr><td><p> </p></td><td><p>Â Â </p></td><td colspan="3"><p>With Duplicates</p></td><td><p>Â Â </p></td><td colspan="3"><p>Without Duplicates</p></td></tr><tr><td><p> </p></td><td><p>Â Â </p></td><td><p><code data-lang="pyret" class="sourceCode">insert</code></p></td><td><p>Â Â </p></td><td><p><code data-lang="pyret" class="sourceCode">is-in</code></p></td><td><p>Â Â </p></td><td><p><code data-lang="pyret" class="sourceCode">insert</code></p></td><td><p>Â Â </p></td><td><p><code data-lang="pyret" class="sourceCode">is-in</code></p></td></tr><tr><td><p>Size of Set</p></td><td><p>Â Â </p></td><td><p>constant</p></td><td><p>Â Â </p></td><td><p>linear</p></td><td><p>Â Â </p></td><td><p>linear</p></td><td><p>Â Â </p></td><td><p>linear</p></td></tr><tr><td><p>Size of List</p></td><td><p>Â Â </p></td><td><p>constant</p></td><td><p>Â Â </p></td><td><p>linear</p></td><td><p>Â Â </p></td><td><p>linear</p></td><td><p>Â Â </p></td><td><p>linear</p></td></tr></table><p>A naive reading of this would suggest that the representation with
duplicates is better because itâ€™s sometimes constant and sometimes
linear, whereas the version without duplicates is always
linear. However, this masks a very important distinction: what the
linear means. When there are no duplicates, the size of the list is
the same as the size of the set. However, with duplicates, the size
of the list can be arbitrarily larger than that of the set!</p><p>Based on this, we can draw several lessons:
</p><ol><li><p>Which representation we choose is a matter of how much
duplication we expect. If there wonâ€™t be many duplicates, then the
version that stores duplicates pays a small extra price in return for
some faster operations.</p></li><li><p>Which representation we choose is also a matter of how
often we expect each operation to be performed. The representation
without duplication is â€œin the middleâ€: everything is roughly equally
expensive (in the worst case). With duplicates is â€œat the extremesâ€:
very cheap insertion, potentially very expensive membership. But if we
will mostly only insert without checking membership, and especially if
we know membership checking will only occur in situations where weâ€™re
willing to wait, then permitting duplicates may in fact be the smart
choice. (When might we ever be in such a situation? Suppose your set
represents a backup data structure; then we add lots of data but very
rarelyâ€”<wbr/>indeed, only in case of some catastropheâ€”<wbr/>ever need to look
for things in it.)</p></li><li><p>Another way to cast these insights is that our form of analysis
is too weak. In situations where the complexity depends so heavily on
a particular sequence of operations, big-Oh is too loose and we should
instead study the complexity of specific sequences of operations. We
will address precisely this question later
[<a href="amortized-analysis.html" data-pltdoc="x">Halloween Analysis</a>].</p></li></ol><p>Moreover, there is no reason a program should use only one
representation. It could well begin with one representation, then
switch to another as it better understands its workload. The only
thing it would need to do to switch is to convert all existing data
between the representations.</p><p>How might this play out above? Observe that data conversion is very
cheap in one direction: since every list without duplicates is
automatically also a list with (potential) duplicates, converting in
that direction is trivial (the representation stays unchanged, only
its interpretation changes). The other direction is harder: we have to
filter duplicates (which takes time quadratic in the number of
elements in the list). Thus, a program can make an initial guess about
its workload and pick a representation accordingly, but maintain
statistics as it runs and, when it finds its assumption is wrong,
switch representationsâ€”<wbr/>and can do so as many times as needed.</p></section><section class="SsectionLevel4" id="section 18.1.4"><h4 class="heading">18.1.4Â <a name="(part._.Other_.Operations)"/>Other Operations<a href="#(part._.Other_.Operations)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Implement the remaining operations catalogued above
(<a href="#%28elem._set-operations%29" data-pltdoc="x">&lt;set-operations&gt;</a>)
under each list representation.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Implement the operation
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">remove :: (Set&lt;T&gt;, T -&gt; Set&lt;T&gt;)</code></pre><p>under each list representation (renaming <code data-lang="pyret" class="sourceCode">Set</code> appropriately.
What difference do you see?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Suppose youâ€™re asked to extend sets with these operations, as the set
analog of <code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">one :: (Set&lt;T&gt; -&gt; T)
others :: (Set&lt;T&gt; -&gt; T)</code></pre><p>You should refuse to do so!  Do you see why?</p></blockquote></blockquote><p>With lists the â€œfirstâ€ element is well-defined, whereas sets are
defined to have no ordering.  Indeed, just to make sure users of your
sets donâ€™t accidentally assume anything about your implementation
(e.g., if you implement <code data-lang="pyret" class="sourceCode">one</code> using <code data-lang="pyret" class="sourceCode">first</code>, they may notice
that <code data-lang="pyret" class="sourceCode">one</code> always returns the element most recently added to the
list), you really ought to return a random element of the set on each
invocation.</p><p>Unfortunately, returning a random element means the above interface is
unusable.  Suppose <code data-lang="pyret" class="sourceCode">s</code> is bound to a set containing <code data-lang="pyret" class="sourceCode">1</code>,
<code data-lang="pyret" class="sourceCode">2</code>, and <code data-lang="pyret" class="sourceCode">3</code>.  Say the first time <code data-lang="pyret" class="sourceCode">one(s)</code> is invoked
it returns <code data-lang="pyret" class="sourceCode">2</code>, and the second time <code data-lang="pyret" class="sourceCode">1</code>.  (This already
means <code data-lang="pyret" class="sourceCode">one</code> is not a function.)
The third time it may again return <code data-lang="pyret" class="sourceCode">2</code>.  Thus
<code data-lang="pyret" class="sourceCode">others</code> has to remember which element was returned the last time
<code data-lang="pyret" class="sourceCode">one</code> was called, and return the set sans that element.  Suppose
we now invoke <code data-lang="pyret" class="sourceCode">one</code> on the result of calling <code data-lang="pyret" class="sourceCode">others</code>.  That
means we might have a situation where <code data-lang="pyret" class="sourceCode">one(s)</code> produces the same
result as <code data-lang="pyret" class="sourceCode">one(others(s))</code>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Why is it unreasonable for <code data-lang="pyret" class="sourceCode">one(s)</code> to produce the same
result as <code data-lang="pyret" class="sourceCode">one(others(s))</code>?</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Suppose you wanted to extend sets with a <code data-lang="pyret" class="sourceCode">subset</code> operation that
partitioned the set according to some condition.  What would its type
be?</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>The types we have written above are not as crisp as they could
be. Define a <code data-lang="pyret" class="sourceCode">has-no-duplicates</code> predicate, refine the relevant
types with it, and check that the functions really do satisfy this
criterion.</p></blockquote></blockquote></section>&#13;
<h4 class="heading">18.1.1Â <a name="(part._.Representation_.Choices)"/>Representation Choices<a href="#(part._.Representation_.Choices)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>The empty list can stand in for the empty setâ€”<wbr/>
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">type LSet = List
mt-set = empty</code></pre><p>â€”<wbr/>and we can presumably define <code data-lang="pyret" class="sourceCode">size</code> as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size&lt;T&gt;(s :: LSet&lt;T&gt;) -&gt; Number:
  s.length()
end</code></pre><p>However, this <a href="glossary.html#%28elem._glossary-reduction%29" data-pltdoc="x">â˜› reduction</a> (of sets to lists) can be
dangerous:
</p><ol><li><p>There is a subtle difference between lists and sets.  The list
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 1]</code></pre><p>is not the same as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1]</code></pre><p>because the first list has length two whereas the second has length
one.  Treated as a set, however, the two are the same: they both have
size one.  Thus, our implementation of <code data-lang="pyret" class="sourceCode">size</code> above is incorrect
if we donâ€™t take into account duplicates (either during insertion or
while computing the size).</p></li><li><p>We might falsely make assumptions about the order in which
elements are retrieved from the set due to the ordering guaranteed
provided by the underlying list representation.  This might hide bugs
that we donâ€™t discover until we change the representation.</p></li><li><p>We might have chosen a set representation because we didnâ€™t need
to care about order, and expected lots of duplicate items.  A list
representation might store all the duplicates, resulting in
significantly more memory use (and slower programs) than we expected.</p></li></ol><p>To avoid these perils, we have to be precise about how weâ€™re going to
use lists to represent sets.  One key question (but not the only one,
as weâ€™ll soon see [<a href="#%28part._choosing-set-reps%29" data-pltdoc="x">Choosing Between Representations</a>]) is what to do about duplicates.  One
possibility is for <code data-lang="pyret" class="sourceCode">insert</code> to check whether an element is
already in the set and, if so, leave the representation unchanged;
this incurs a cost during insertion but avoids unnecessary duplication
and lets us use <code data-lang="pyret" class="sourceCode">length</code> to implement <code data-lang="pyret" class="sourceCode">size</code>.  The other
option is to define <code data-lang="pyret" class="sourceCode">insert</code> as <code data-lang="pyret" class="sourceCode">link</code>â€”<wbr/>literally,
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">insert = link</code></pre><p>â€”<wbr/>and have some other procedure perform the filtering of duplicates.</p>&#13;
<h4 class="heading">18.1.2Â <a name="(part._.Time_.Complexity)"/>Time Complexity<a href="#(part._.Time_.Complexity)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>What is the complexity of this representation of sets?  Letâ€™s consider
just <code data-lang="pyret" class="sourceCode">insert</code>, <code data-lang="pyret" class="sourceCode">is-in</code>, and <code data-lang="pyret" class="sourceCode">size</code>.
Suppose the size of the set is \(k\) (where, to avoid ambiguity,
we let \(k\) represent the number of distinct elements).
The complexity of these operations depends on whether or not we store
duplicates:
</p><ul><li><p>If we donâ€™t store duplicates, then <code data-lang="pyret" class="sourceCode">size</code> is simply
<code data-lang="pyret" class="sourceCode">length</code>, which takes time linear in \(k\).  Similarly,
<code data-lang="pyret" class="sourceCode">is-in</code> only needs to traverse the list once to determine whether
or not an element is present, which also takes time linear in
\(k\).  But <code data-lang="pyret" class="sourceCode">insert</code> needs to check whether an element is
already present, which takes time linear in \(k\), followed by
at most a constant-time operation (<code data-lang="pyret" class="sourceCode">link</code>).</p></li><li><p>If we do store duplicates, then <code data-lang="pyret" class="sourceCode">insert</code> is constant
time: it simply <code data-lang="pyret" class="sourceCode">link</code>s on the new element without regard to
whether it already is in the set representation.  <code data-lang="pyret" class="sourceCode">is-in</code>
traverses the list once, but the number of elements it needs to visit
could be significantly greater than \(k\), depending on how many
duplicates have been added.  Finally, <code data-lang="pyret" class="sourceCode">size</code> needs to check
whether or not each element is duplicated before counting it.</p></li></ul><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What is the time complexity of <code data-lang="pyret" class="sourceCode">size</code> if the list has duplicates?</p></blockquote></blockquote><p>One implementation of <code data-lang="pyret" class="sourceCode">size</code> is
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size&lt;T&gt;(s :: LSet&lt;T&gt;) -&gt; Number:
  cases (List) s:
    | empty =&gt; 0
    | link(f, r) =&gt;
      if r.member(f):
        size(r)
      else:
        1 + size(r)
      end
  end
end</code></pre><p>Letâ€™s now compute the complexity of the body of the function, assuming
the number of distinct elements in <code data-lang="pyret" class="sourceCode">s</code> is \(k\) but the
actual number of elements in <code data-lang="pyret" class="sourceCode">s</code> is \(d\), where
\(d \geq k\).  To compute the time to run <code data-lang="pyret" class="sourceCode">size</code> on \(d\)
elements, \(T(d)\), we should determine the number of operations in
each question and answer.  The first question has a constant number of
operations,
and the first answer also a constant.  The second question also has
a constant number of
operations.  Its answer is a conditional, whose first question
(<code data-lang="pyret" class="sourceCode">r.member(f)</code> needs to traverse the entire list, and hence has
\(O([k \rightarrow d])\) operations.  If it succeeds, we recur on something of size
\(T(d-1)\); else we do the same but perform a constant more operations.
Thus \(T(0)\) is a constant, while the recurrence (in big-Oh terms) is
</p><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}T(d) = d + T(d-1)\end{equation*}</p><p>Thus \(T \in O([d \rightarrow d^2])\).
Note that this is quadratic in the number of elements in the
list, which may be much bigger than the size of the
set.</p>&#13;
<h4 class="heading">18.1.3Â <a name="(part._choosing-set-reps)"/>Choosing Between Representations<a href="#(part._choosing-set-reps)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Now that we have two representations with different complexities, itâ€™s
worth thinking about how to choose between them. To do so, letâ€™s build
up the following table. The table distinguishes between the
interface (the set) and the implementation (the list),
becauseâ€”<wbr/>owing to duplicates in the representationâ€”<wbr/>these two may
not be the same. In the table weâ€™ll consider just two of the most
common operations, insertion and membership checking:
</p><table cellspacing="0" cellpadding="0"><tr><td><p> </p></td><td><p>Â Â </p></td><td colspan="3"><p>With Duplicates</p></td><td><p>Â Â </p></td><td colspan="3"><p>Without Duplicates</p></td></tr><tr><td><p> </p></td><td><p>Â Â </p></td><td><p><code data-lang="pyret" class="sourceCode">insert</code></p></td><td><p>Â Â </p></td><td><p><code data-lang="pyret" class="sourceCode">is-in</code></p></td><td><p>Â Â </p></td><td><p><code data-lang="pyret" class="sourceCode">insert</code></p></td><td><p>Â Â </p></td><td><p><code data-lang="pyret" class="sourceCode">is-in</code></p></td></tr><tr><td><p>Size of Set</p></td><td><p>Â Â </p></td><td><p>constant</p></td><td><p>Â Â </p></td><td><p>linear</p></td><td><p>Â Â </p></td><td><p>linear</p></td><td><p>Â Â </p></td><td><p>linear</p></td></tr><tr><td><p>Size of List</p></td><td><p>Â Â </p></td><td><p>constant</p></td><td><p>Â Â </p></td><td><p>linear</p></td><td><p>Â Â </p></td><td><p>linear</p></td><td><p>Â Â </p></td><td><p>linear</p></td></tr></table><p>A naive reading of this would suggest that the representation with
duplicates is better because itâ€™s sometimes constant and sometimes
linear, whereas the version without duplicates is always
linear. However, this masks a very important distinction: what the
linear means. When there are no duplicates, the size of the list is
the same as the size of the set. However, with duplicates, the size
of the list can be arbitrarily larger than that of the set!</p><p>Based on this, we can draw several lessons:
</p><ol><li><p>Which representation we choose is a matter of how much
duplication we expect. If there wonâ€™t be many duplicates, then the
version that stores duplicates pays a small extra price in return for
some faster operations.</p></li><li><p>Which representation we choose is also a matter of how
often we expect each operation to be performed. The representation
without duplication is â€œin the middleâ€: everything is roughly equally
expensive (in the worst case). With duplicates is â€œat the extremesâ€:
very cheap insertion, potentially very expensive membership. But if we
will mostly only insert without checking membership, and especially if
we know membership checking will only occur in situations where weâ€™re
willing to wait, then permitting duplicates may in fact be the smart
choice. (When might we ever be in such a situation? Suppose your set
represents a backup data structure; then we add lots of data but very
rarelyâ€”<wbr/>indeed, only in case of some catastropheâ€”<wbr/>ever need to look
for things in it.)</p></li><li><p>Another way to cast these insights is that our form of analysis
is too weak. In situations where the complexity depends so heavily on
a particular sequence of operations, big-Oh is too loose and we should
instead study the complexity of specific sequences of operations. We
will address precisely this question later
[<a href="amortized-analysis.html" data-pltdoc="x">Halloween Analysis</a>].</p></li></ol><p>Moreover, there is no reason a program should use only one
representation. It could well begin with one representation, then
switch to another as it better understands its workload. The only
thing it would need to do to switch is to convert all existing data
between the representations.</p><p>How might this play out above? Observe that data conversion is very
cheap in one direction: since every list without duplicates is
automatically also a list with (potential) duplicates, converting in
that direction is trivial (the representation stays unchanged, only
its interpretation changes). The other direction is harder: we have to
filter duplicates (which takes time quadratic in the number of
elements in the list). Thus, a program can make an initial guess about
its workload and pick a representation accordingly, but maintain
statistics as it runs and, when it finds its assumption is wrong,
switch representationsâ€”<wbr/>and can do so as many times as needed.</p>&#13;
<h4 class="heading">18.1.4Â <a name="(part._.Other_.Operations)"/>Other Operations<a href="#(part._.Other_.Operations)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Implement the remaining operations catalogued above
(<a href="#%28elem._set-operations%29" data-pltdoc="x">&lt;set-operations&gt;</a>)
under each list representation.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Implement the operation
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">remove :: (Set&lt;T&gt;, T -&gt; Set&lt;T&gt;)</code></pre><p>under each list representation (renaming <code data-lang="pyret" class="sourceCode">Set</code> appropriately.
What difference do you see?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Suppose youâ€™re asked to extend sets with these operations, as the set
analog of <code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">one :: (Set&lt;T&gt; -&gt; T)
others :: (Set&lt;T&gt; -&gt; T)</code></pre><p>You should refuse to do so!  Do you see why?</p></blockquote></blockquote><p>With lists the â€œfirstâ€ element is well-defined, whereas sets are
defined to have no ordering.  Indeed, just to make sure users of your
sets donâ€™t accidentally assume anything about your implementation
(e.g., if you implement <code data-lang="pyret" class="sourceCode">one</code> using <code data-lang="pyret" class="sourceCode">first</code>, they may notice
that <code data-lang="pyret" class="sourceCode">one</code> always returns the element most recently added to the
list), you really ought to return a random element of the set on each
invocation.</p><p>Unfortunately, returning a random element means the above interface is
unusable.  Suppose <code data-lang="pyret" class="sourceCode">s</code> is bound to a set containing <code data-lang="pyret" class="sourceCode">1</code>,
<code data-lang="pyret" class="sourceCode">2</code>, and <code data-lang="pyret" class="sourceCode">3</code>.  Say the first time <code data-lang="pyret" class="sourceCode">one(s)</code> is invoked
it returns <code data-lang="pyret" class="sourceCode">2</code>, and the second time <code data-lang="pyret" class="sourceCode">1</code>.  (This already
means <code data-lang="pyret" class="sourceCode">one</code> is not a function.)
The third time it may again return <code data-lang="pyret" class="sourceCode">2</code>.  Thus
<code data-lang="pyret" class="sourceCode">others</code> has to remember which element was returned the last time
<code data-lang="pyret" class="sourceCode">one</code> was called, and return the set sans that element.  Suppose
we now invoke <code data-lang="pyret" class="sourceCode">one</code> on the result of calling <code data-lang="pyret" class="sourceCode">others</code>.  That
means we might have a situation where <code data-lang="pyret" class="sourceCode">one(s)</code> produces the same
result as <code data-lang="pyret" class="sourceCode">one(others(s))</code>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Why is it unreasonable for <code data-lang="pyret" class="sourceCode">one(s)</code> to produce the same
result as <code data-lang="pyret" class="sourceCode">one(others(s))</code>?</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Suppose you wanted to extend sets with a <code data-lang="pyret" class="sourceCode">subset</code> operation that
partitioned the set according to some condition.  What would its type
be?</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>The types we have written above are not as crisp as they could
be. Define a <code data-lang="pyret" class="sourceCode">has-no-duplicates</code> predicate, refine the relevant
types with it, and check that the functions really do satisfy this
criterion.</p></blockquote></blockquote>    
</body>
</html>