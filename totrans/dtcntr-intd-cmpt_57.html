<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>18.1Â Representing Sets as ListsğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>18.1Â Representing Sets as ListsğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/sets-from-lists.html">https://dcic-world.org/2025-08-27/sets-from-lists.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Representation_.Choices%29" class="toclink" data-pltdoc="x">18.1.1<span class="hspace">Â </span>Representation Choices</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Time_.Complexity%29" class="toclink" data-pltdoc="x">18.1.2<span class="hspace">Â </span>Time Complexity</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._choosing-set-reps%29" class="toclink" data-pltdoc="x">18.1.3<span class="hspace">Â </span>Choosing Between Representations</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Other_.Operations%29" class="toclink" data-pltdoc="x">18.1.4<span class="hspace">Â </span>Other Operations</a></p></td></tr></table><p>Earlier [<a href="Collections_of_Structured_Data.html#%28part._sets-as-collections%29" data-pltdoc="x">Sets as Collective Data</a>] we introduced sets. Recall
that the elements of a set have no specific order, and ignore
duplicates.<span class="refelem"><span class="refcolumn"><span class="refcontent">If these ideas are not familiar, please read
<a href="Collections_of_Structured_Data.html#%28part._sets-as-collections%29" data-pltdoc="x">Sets as Collective Data</a>, since they will be important when
discussing the representation of sets.</span></span></span> At that time we relied on
Pyretâ€™s built-in representation of sets. Now we will discuss how to
build sets for ourselves. In what follows, we will focus only on sets
of numbers.</p><p/><div class="SIntrapara">We will start by discussing how to represent sets using
lists. Intuitively,
using lists to represent sets of data seems problematic,
because lists respect both order and duplication. For
instance,
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  [list: 1, 2, 3] is [list: 3, 2, 1, 1]
end</code></pre></div></div></div><div class="SIntrapara">fails, but the corresponding sets are equal.</div><p/><div class="SIntrapara">In principle, we want sets to obey the following
interface:<span class="refelem"><span class="refcolumn"><span class="refcontent">Note that a type called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Set</code></span> is already
built into Pyret, so below we will use the name <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">LSet</code></span> for a set
represented as a list.</span></span></span>
</div><div class="SIntrapara"><a name="(elem._set-operations)"/>&lt;<span style="font-style: italic">set-operations</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">mt-set :: Set
is-in :: (T, Set&lt;T&gt; -&gt; Bool)
insert :: (T, Set&lt;T&gt; -&gt; Set&lt;T&gt;)
union :: (Set&lt;T&gt;, Set&lt;T&gt; -&gt; Set&lt;T&gt;)
size :: (Set&lt;T&gt; -&gt; Number)
to-list :: (Set&lt;T&gt; -&gt; List&lt;T&gt;)</code></pre></div></div></div><div class="SIntrapara">We may also find it also useful to have functions such as
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">insert-many :: (List&lt;T&gt;, Set&lt;T&gt; -&gt; Set&lt;T&gt;)</code></pre></div></div></div><div class="SIntrapara">which, combined with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">mt-set</code></span>, easily gives us a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">to-set</code></span>
function.</div><p>Sets can contain many kinds of values, but not necessarily any kind:
we need to be able to check for two values being equal (which is a
<span class="emph">requirement</span> for a set, but <span class="emph">not</span> for a list!), which canâ€™t
be done with all values (such as functions). We discuss the nuances of
this elsewhere [<a href="orderability.html#%28part._eq-ord%29" data-pltdoc="x">Equality and Ordering</a>]. For now, we can ignore these
issues by focusing on sets of (non-rough)numbers.</p><section class="SsectionLevel4" id="section 18.1.1"><h4 class="heading">18.1.1<span class="stt">Â </span><a name="(part._.Representation_.Choices)"/>Representation Choices<span class="button-group"><a href="#(part._.Representation_.Choices)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">The empty list can stand in for the empty setâ€”<wbr/>
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">type LSet = List
mt-set = empty</code></pre></div></div></div><div class="SIntrapara">â€”<wbr/>and we can presumably define <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size</code></span> as
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size&lt;T&gt;(s :: LSet&lt;T&gt;) -&gt; Number:
  s.length()
end</code></pre></div></div></div><div class="SIntrapara">However, this <a href="glossary.html#%28elem._glossary-reduction%29" data-pltdoc="x">â˜› <span style="font-style: italic">reduction</span></a> (of sets to lists) can be
dangerous:
</div><div class="SIntrapara"><ol><li><p/><div class="SIntrapara">There is a subtle difference between lists and sets.  The list
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 1]</code></pre></div></div></div><div class="SIntrapara">is not the same as
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1]</code></pre></div></div></div><div class="SIntrapara">because the first list has length two whereas the second has length
one.  Treated as a set, however, the two are the same: they both have
size one.  Thus, our implementation of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size</code></span> above is incorrect
if we donâ€™t take into account duplicates (either during insertion or
while computing the size).</div></li><li><p>We might falsely make assumptions about the order in which
elements are retrieved from the set due to the ordering guaranteed
provided by the underlying list representation.  This might hide bugs
that we donâ€™t discover until we change the representation.</p></li><li><p>We might have chosen a set representation because we didnâ€™t need
to care about order, and expected lots of duplicate items.  A list
representation might store all the duplicates, resulting in
significantly more memory use (and slower programs) than we expected.</p></li></ol></div><p/><div class="SIntrapara">To avoid these perils, we have to be precise about how weâ€™re going to
use lists to represent sets.  One key question (but not the only one,
as weâ€™ll soon see [<a href="#%28part._choosing-set-reps%29" data-pltdoc="x">Choosing Between Representations</a>]) is what to do about duplicates.  One
possibility is for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">insert</code></span> to check whether an element is
already in the set and, if so, leave the representation unchanged;
this incurs a cost during insertion but avoids unnecessary duplication
and lets us use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">length</code></span> to implement <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size</code></span>.  The other
option is to define <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">insert</code></span> as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>â€”<wbr/>literally,
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">insert = link</code></pre></div></div></div><div class="SIntrapara">â€”<wbr/>and have some other procedure perform the filtering of duplicates.</div></section><section class="SsectionLevel4" id="section 18.1.2"><h4 class="heading">18.1.2<span class="stt">Â </span><a name="(part._.Time_.Complexity)"/>Time Complexity<span class="button-group"><a href="#(part._.Time_.Complexity)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">What is the complexity of this representation of sets?  Letâ€™s consider
just <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">insert</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-in</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size</code></span>.
Suppose the size of the set is \(k\) (where, to avoid ambiguity,
we let \(k\) represent the number of <span class="emph">distinct</span> elements).
The complexity of these operations depends on whether or not we store
duplicates:
</div><div class="SIntrapara"><ul><li><p>If we <span class="emph">donâ€™t</span> store duplicates, then <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size</code></span> is simply
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">length</code></span>, which takes time linear in \(k\).  Similarly,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-in</code></span> only needs to traverse the list once to determine whether
or not an element is present, which also takes time linear in
\(k\).  But <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">insert</code></span> needs to check whether an element is
already present, which takes time linear in \(k\), followed by
at most a constant-time operation (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>).</p></li><li><p>If we <span class="emph">do</span> store duplicates, then <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">insert</code></span> is constant
time: it simply <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>s on the new element without regard to
whether it already is in the set representation.  <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-in</code></span>
traverses the list once, but the number of elements it needs to visit
could be significantly greater than \(k\), depending on how many
duplicates have been added.  Finally, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size</code></span> needs to check
whether or not each element is duplicated before counting it.</p></li></ul></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What is the time complexity of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size</code></span> if the list has duplicates?</p></blockquote></blockquote><p/><div class="SIntrapara">One implementation of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size</code></span> is
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size&lt;T&gt;(s :: LSet&lt;T&gt;) -&gt; Number:
  cases (List) s:
    | empty =&gt; 0
    | link(f, r) =&gt;
      if r.member(f):
        size(r)
      else:
        1 + size(r)
      end
  end
end</code></pre></div></div></div><p/><div class="SIntrapara">Letâ€™s now compute the complexity of the body of the function, assuming
the number of distinct elements in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">s</code></span> is \(k\) but the
actual number of elements in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">s</code></span> is \(d\), where
\(d \geq k\).  To compute the time to run <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size</code></span> on \(d\)
elements, \(T(d)\), we should determine the number of operations in
each question and answer.  The first question has a constant number of
operations,
and the first answer also a constant.  The second question also has
a constant number of
operations.  Its answer is a conditional, whose first question
(<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r.member(f)</code></span> needs to traverse the entire list, and hence has
\(O([k \rightarrow d])\) operations.  If it succeeds, we recur on something of size
\(T(d-1)\); else we do the same but perform a constant more operations.
Thus \(T(0)\) is a constant, while the recurrence (in big-Oh terms) is
</div><div class="SIntrapara"><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}T(d) = d + T(d-1)\end{equation*}</p></div><div class="SIntrapara">Thus \(T \in O([d \rightarrow d^2])\).
Note that this is quadratic in the number of elements in the
<span class="emph">list</span>, which may be <span class="emph">much</span> bigger than the size of the
set.</div></section><section class="SsectionLevel4" id="section 18.1.3"><h4 class="heading">18.1.3<span class="stt">Â </span><a name="(part._choosing-set-reps)"/>Choosing Between Representations<span class="button-group"><a href="#(part._choosing-set-reps)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">Now that we have two representations with different complexities, itâ€™s
worth thinking about how to choose between them. To do so, letâ€™s build
up the following table. The table distinguishes between the
<span class="emph">interface</span> (the set) and the <span class="emph">implementation</span> (the list),
becauseâ€”<wbr/>owing to duplicates in the representationâ€”<wbr/>these two may
not be the same. In the table weâ€™ll consider just two of the most
common operations, insertion and membership checking:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p> </p></td><td><p><span class="hspace">Â Â </span></p></td><td colspan="3"><p><span style="font-weight: bold">With Duplicates</span></p></td><td><p><span class="hspace">Â Â </span></p></td><td colspan="3"><p><span style="font-weight: bold">Without Duplicates</span></p></td></tr><tr><td><p> </p></td><td><p><span class="hspace">Â Â </span></p></td><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">insert</code></span></p></td><td><p><span class="hspace">Â Â </span></p></td><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-in</code></span></p></td><td><p><span class="hspace">Â Â </span></p></td><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">insert</code></span></p></td><td><p><span class="hspace">Â Â </span></p></td><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-in</code></span></p></td></tr><tr><td><p><span style="font-weight: bold">Size of Set</span></p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>constant</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>linear</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>linear</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>linear</p></td></tr><tr><td><p><span style="font-weight: bold">Size of List</span></p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>constant</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>linear</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>linear</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>linear</p></td></tr></table></div><div class="SIntrapara">A naive reading of this would suggest that the representation with
duplicates is better because itâ€™s sometimes constant and sometimes
linear, whereas the version without duplicates is always
linear. However, this masks a very important distinction: what the
linear means. When there are no duplicates, the size of the list is
the same as the size of the set. However, with duplicates, the size
of the list can be <span class="emph">arbitrarily</span> larger than that of the set!</div><p/><div class="SIntrapara">Based on this, we can draw several lessons:
</div><div class="SIntrapara"><ol><li><p>Which representation we choose is a matter of how much
duplication we expect. If there wonâ€™t be many duplicates, then the
version that stores duplicates pays a small extra price in return for
some faster operations.</p></li><li><p>Which representation we choose is <span class="emph">also</span> a matter of how
often we expect each operation to be performed. The representation
without duplication is â€œin the middleâ€: everything is roughly equally
expensive (in the worst case). With duplicates is â€œat the extremesâ€:
very cheap insertion, potentially very expensive membership. But if we
will mostly only insert without checking membership, and especially if
we know membership checking will only occur in situations where weâ€™re
willing to wait, then permitting duplicates may in fact be the smart
choice. (When might we ever be in such a situation? Suppose your set
represents a backup data structure; then we add lots of data but very
rarelyâ€”<wbr/>indeed, only in case of some catastropheâ€”<wbr/>ever need to look
for things in it.)</p></li><li><p>Another way to cast these insights is that our form of analysis
is too weak. In situations where the complexity depends so heavily on
a particular sequence of operations, big-Oh is too loose and we should
instead study the complexity of specific sequences of operations. We
will address precisely this question later
[<a href="amortized-analysis.html" data-pltdoc="x">Halloween Analysis</a>].</p></li></ol></div><p>Moreover, there is no reason a program should use only one
representation. It could well begin with one representation, then
switch to another as it better understands its workload. The only
thing it would need to do to switch is to convert all existing data
between the representations.</p><p>How might this play out above? Observe that data conversion is very
cheap in one direction: since every list without duplicates is
automatically also a list with (potential) duplicates, converting in
that direction is trivial (the representation stays unchanged, only
its interpretation changes). The other direction is harder: we have to
filter duplicates (which takes time quadratic in the number of
elements in the list). Thus, a program can make an initial guess about
its workload and pick a representation accordingly, but maintain
statistics as it runs and, when it finds its assumption is wrong,
switch representationsâ€”<wbr/>and can do so as many times as needed.</p></section><section class="SsectionLevel4" id="section 18.1.4"><h4 class="heading">18.1.4<span class="stt">Â </span><a name="(part._.Other_.Operations)"/>Other Operations<span class="button-group"><a href="#(part._.Other_.Operations)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Implement the remaining operations catalogued above
(<a href="#%28elem._set-operations%29" data-pltdoc="x">&lt;<span style="font-style: italic">set-operations</span>&gt;</a>)
under each list representation.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p/><div class="SIntrapara">Implement the operation
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">remove :: (Set&lt;T&gt;, T -&gt; Set&lt;T&gt;)</code></pre></div></div></div><div class="SIntrapara">under each list representation (renaming <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Set</code></span> appropriately.
What difference do you see?</div></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">Suppose youâ€™re asked to extend sets with these operations, as the set
analog of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">one :: (Set&lt;T&gt; -&gt; T)
others :: (Set&lt;T&gt; -&gt; T)</code></pre></div></div></div><div class="SIntrapara">You should refuse to do so!  Do you see why?</div></blockquote></blockquote><p>With lists the â€œfirstâ€ element is well-defined, whereas sets are
defined to have no ordering.  Indeed, just to make sure users of your
sets donâ€™t accidentally assume anything about your implementation
(e.g., if you implement <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">one</code></span> using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span>, they may notice
that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">one</code></span> always returns the element most recently added to the
list), you really ought to return a random element of the set on each
invocation.</p><p>Unfortunately, returning a random element means the above interface is
unusable.  Suppose <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">s</code></span> is bound to a set containing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>.  Say the first time <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">one(s)</code></span> is invoked
it returns <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>, and the second time <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>.  (This already
means <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">one</code></span> is not a function.)
The third time it may again return <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>.  Thus
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">others</code></span> has to remember which element was returned the last time
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">one</code></span> was called, and return the set sans that element.  Suppose
we now invoke <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">one</code></span> on the result of calling <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">others</code></span>.  That
means we might have a situation where <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">one(s)</code></span> produces the same
result as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">one(others(s))</code></span>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Why is it unreasonable for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">one(s)</code></span> to produce the same
result as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">one(others(s))</code></span>?</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Suppose you wanted to extend sets with a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">subset</code></span> operation that
partitioned the set according to some condition.  What would its type
be?</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>The types we have written above are not as crisp as they could
be. Define a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">has-no-duplicates</code></span> predicate, refine the relevant
types with it, and check that the functions really do satisfy this
criterion.</p></blockquote></blockquote></section>&#13;
<h4 class="heading">18.1.1<span class="stt">Â </span><a name="(part._.Representation_.Choices)"/>Representation Choices<span class="button-group"><a href="#(part._.Representation_.Choices)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">The empty list can stand in for the empty setâ€”<wbr/>
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">type LSet = List
mt-set = empty</code></pre></div></div></div><div class="SIntrapara">â€”<wbr/>and we can presumably define <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size</code></span> as
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size&lt;T&gt;(s :: LSet&lt;T&gt;) -&gt; Number:
  s.length()
end</code></pre></div></div></div><div class="SIntrapara">However, this <a href="glossary.html#%28elem._glossary-reduction%29" data-pltdoc="x">â˜› <span style="font-style: italic">reduction</span></a> (of sets to lists) can be
dangerous:
</div><div class="SIntrapara"><ol><li><p/><div class="SIntrapara">There is a subtle difference between lists and sets.  The list
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 1]</code></pre></div></div></div><div class="SIntrapara">is not the same as
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1]</code></pre></div></div></div><div class="SIntrapara">because the first list has length two whereas the second has length
one.  Treated as a set, however, the two are the same: they both have
size one.  Thus, our implementation of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size</code></span> above is incorrect
if we donâ€™t take into account duplicates (either during insertion or
while computing the size).</div></li><li><p>We might falsely make assumptions about the order in which
elements are retrieved from the set due to the ordering guaranteed
provided by the underlying list representation.  This might hide bugs
that we donâ€™t discover until we change the representation.</p></li><li><p>We might have chosen a set representation because we didnâ€™t need
to care about order, and expected lots of duplicate items.  A list
representation might store all the duplicates, resulting in
significantly more memory use (and slower programs) than we expected.</p></li></ol></div><p/><div class="SIntrapara">To avoid these perils, we have to be precise about how weâ€™re going to
use lists to represent sets.  One key question (but not the only one,
as weâ€™ll soon see [<a href="#%28part._choosing-set-reps%29" data-pltdoc="x">Choosing Between Representations</a>]) is what to do about duplicates.  One
possibility is for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">insert</code></span> to check whether an element is
already in the set and, if so, leave the representation unchanged;
this incurs a cost during insertion but avoids unnecessary duplication
and lets us use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">length</code></span> to implement <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size</code></span>.  The other
option is to define <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">insert</code></span> as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>â€”<wbr/>literally,
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">insert = link</code></pre></div></div></div><div class="SIntrapara">â€”<wbr/>and have some other procedure perform the filtering of duplicates.</div>&#13;
<h4 class="heading">18.1.2<span class="stt">Â </span><a name="(part._.Time_.Complexity)"/>Time Complexity<span class="button-group"><a href="#(part._.Time_.Complexity)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">What is the complexity of this representation of sets?  Letâ€™s consider
just <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">insert</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-in</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size</code></span>.
Suppose the size of the set is \(k\) (where, to avoid ambiguity,
we let \(k\) represent the number of <span class="emph">distinct</span> elements).
The complexity of these operations depends on whether or not we store
duplicates:
</div><div class="SIntrapara"><ul><li><p>If we <span class="emph">donâ€™t</span> store duplicates, then <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size</code></span> is simply
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">length</code></span>, which takes time linear in \(k\).  Similarly,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-in</code></span> only needs to traverse the list once to determine whether
or not an element is present, which also takes time linear in
\(k\).  But <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">insert</code></span> needs to check whether an element is
already present, which takes time linear in \(k\), followed by
at most a constant-time operation (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>).</p></li><li><p>If we <span class="emph">do</span> store duplicates, then <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">insert</code></span> is constant
time: it simply <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>s on the new element without regard to
whether it already is in the set representation.  <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-in</code></span>
traverses the list once, but the number of elements it needs to visit
could be significantly greater than \(k\), depending on how many
duplicates have been added.  Finally, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size</code></span> needs to check
whether or not each element is duplicated before counting it.</p></li></ul></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What is the time complexity of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size</code></span> if the list has duplicates?</p></blockquote></blockquote><p/><div class="SIntrapara">One implementation of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size</code></span> is
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size&lt;T&gt;(s :: LSet&lt;T&gt;) -&gt; Number:
  cases (List) s:
    | empty =&gt; 0
    | link(f, r) =&gt;
      if r.member(f):
        size(r)
      else:
        1 + size(r)
      end
  end
end</code></pre></div></div></div><p/><div class="SIntrapara">Letâ€™s now compute the complexity of the body of the function, assuming
the number of distinct elements in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">s</code></span> is \(k\) but the
actual number of elements in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">s</code></span> is \(d\), where
\(d \geq k\).  To compute the time to run <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size</code></span> on \(d\)
elements, \(T(d)\), we should determine the number of operations in
each question and answer.  The first question has a constant number of
operations,
and the first answer also a constant.  The second question also has
a constant number of
operations.  Its answer is a conditional, whose first question
(<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r.member(f)</code></span> needs to traverse the entire list, and hence has
\(O([k \rightarrow d])\) operations.  If it succeeds, we recur on something of size
\(T(d-1)\); else we do the same but perform a constant more operations.
Thus \(T(0)\) is a constant, while the recurrence (in big-Oh terms) is
</div><div class="SIntrapara"><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}T(d) = d + T(d-1)\end{equation*}</p></div><div class="SIntrapara">Thus \(T \in O([d \rightarrow d^2])\).
Note that this is quadratic in the number of elements in the
<span class="emph">list</span>, which may be <span class="emph">much</span> bigger than the size of the
set.</div>&#13;
<h4 class="heading">18.1.3<span class="stt">Â </span><a name="(part._choosing-set-reps)"/>Choosing Between Representations<span class="button-group"><a href="#(part._choosing-set-reps)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">Now that we have two representations with different complexities, itâ€™s
worth thinking about how to choose between them. To do so, letâ€™s build
up the following table. The table distinguishes between the
<span class="emph">interface</span> (the set) and the <span class="emph">implementation</span> (the list),
becauseâ€”<wbr/>owing to duplicates in the representationâ€”<wbr/>these two may
not be the same. In the table weâ€™ll consider just two of the most
common operations, insertion and membership checking:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p> </p></td><td><p><span class="hspace">Â Â </span></p></td><td colspan="3"><p><span style="font-weight: bold">With Duplicates</span></p></td><td><p><span class="hspace">Â Â </span></p></td><td colspan="3"><p><span style="font-weight: bold">Without Duplicates</span></p></td></tr><tr><td><p> </p></td><td><p><span class="hspace">Â Â </span></p></td><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">insert</code></span></p></td><td><p><span class="hspace">Â Â </span></p></td><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-in</code></span></p></td><td><p><span class="hspace">Â Â </span></p></td><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">insert</code></span></p></td><td><p><span class="hspace">Â Â </span></p></td><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-in</code></span></p></td></tr><tr><td><p><span style="font-weight: bold">Size of Set</span></p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>constant</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>linear</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>linear</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>linear</p></td></tr><tr><td><p><span style="font-weight: bold">Size of List</span></p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>constant</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>linear</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>linear</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>linear</p></td></tr></table></div><div class="SIntrapara">A naive reading of this would suggest that the representation with
duplicates is better because itâ€™s sometimes constant and sometimes
linear, whereas the version without duplicates is always
linear. However, this masks a very important distinction: what the
linear means. When there are no duplicates, the size of the list is
the same as the size of the set. However, with duplicates, the size
of the list can be <span class="emph">arbitrarily</span> larger than that of the set!</div><p/><div class="SIntrapara">Based on this, we can draw several lessons:
</div><div class="SIntrapara"><ol><li><p>Which representation we choose is a matter of how much
duplication we expect. If there wonâ€™t be many duplicates, then the
version that stores duplicates pays a small extra price in return for
some faster operations.</p></li><li><p>Which representation we choose is <span class="emph">also</span> a matter of how
often we expect each operation to be performed. The representation
without duplication is â€œin the middleâ€: everything is roughly equally
expensive (in the worst case). With duplicates is â€œat the extremesâ€:
very cheap insertion, potentially very expensive membership. But if we
will mostly only insert without checking membership, and especially if
we know membership checking will only occur in situations where weâ€™re
willing to wait, then permitting duplicates may in fact be the smart
choice. (When might we ever be in such a situation? Suppose your set
represents a backup data structure; then we add lots of data but very
rarelyâ€”<wbr/>indeed, only in case of some catastropheâ€”<wbr/>ever need to look
for things in it.)</p></li><li><p>Another way to cast these insights is that our form of analysis
is too weak. In situations where the complexity depends so heavily on
a particular sequence of operations, big-Oh is too loose and we should
instead study the complexity of specific sequences of operations. We
will address precisely this question later
[<a href="amortized-analysis.html" data-pltdoc="x">Halloween Analysis</a>].</p></li></ol></div><p>Moreover, there is no reason a program should use only one
representation. It could well begin with one representation, then
switch to another as it better understands its workload. The only
thing it would need to do to switch is to convert all existing data
between the representations.</p><p>How might this play out above? Observe that data conversion is very
cheap in one direction: since every list without duplicates is
automatically also a list with (potential) duplicates, converting in
that direction is trivial (the representation stays unchanged, only
its interpretation changes). The other direction is harder: we have to
filter duplicates (which takes time quadratic in the number of
elements in the list). Thus, a program can make an initial guess about
its workload and pick a representation accordingly, but maintain
statistics as it runs and, when it finds its assumption is wrong,
switch representationsâ€”<wbr/>and can do so as many times as needed.</p>&#13;
<h4 class="heading">18.1.4<span class="stt">Â </span><a name="(part._.Other_.Operations)"/>Other Operations<span class="button-group"><a href="#(part._.Other_.Operations)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Implement the remaining operations catalogued above
(<a href="#%28elem._set-operations%29" data-pltdoc="x">&lt;<span style="font-style: italic">set-operations</span>&gt;</a>)
under each list representation.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p/><div class="SIntrapara">Implement the operation
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">remove :: (Set&lt;T&gt;, T -&gt; Set&lt;T&gt;)</code></pre></div></div></div><div class="SIntrapara">under each list representation (renaming <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Set</code></span> appropriately.
What difference do you see?</div></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">Suppose youâ€™re asked to extend sets with these operations, as the set
analog of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">one :: (Set&lt;T&gt; -&gt; T)
others :: (Set&lt;T&gt; -&gt; T)</code></pre></div></div></div><div class="SIntrapara">You should refuse to do so!  Do you see why?</div></blockquote></blockquote><p>With lists the â€œfirstâ€ element is well-defined, whereas sets are
defined to have no ordering.  Indeed, just to make sure users of your
sets donâ€™t accidentally assume anything about your implementation
(e.g., if you implement <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">one</code></span> using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span>, they may notice
that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">one</code></span> always returns the element most recently added to the
list), you really ought to return a random element of the set on each
invocation.</p><p>Unfortunately, returning a random element means the above interface is
unusable.  Suppose <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">s</code></span> is bound to a set containing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>.  Say the first time <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">one(s)</code></span> is invoked
it returns <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>, and the second time <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>.  (This already
means <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">one</code></span> is not a function.)
The third time it may again return <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>.  Thus
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">others</code></span> has to remember which element was returned the last time
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">one</code></span> was called, and return the set sans that element.  Suppose
we now invoke <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">one</code></span> on the result of calling <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">others</code></span>.  That
means we might have a situation where <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">one(s)</code></span> produces the same
result as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">one(others(s))</code></span>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Why is it unreasonable for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">one(s)</code></span> to produce the same
result as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">one(others(s))</code></span>?</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Suppose you wanted to extend sets with a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">subset</code></span> operation that
partitioned the set according to some condition.  What would its type
be?</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>The types we have written above are not as crisp as they could
be. Define a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">has-no-duplicates</code></span> predicate, refine the relevant
types with it, and check that the functions really do satisfy this
criterion.</p></blockquote></blockquote>    
</body>
</html>