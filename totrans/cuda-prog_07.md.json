["```cpp\ncudaFuncSetCacheConfig(cudaFuncCachePreferL1);\n```", "```cpp\nint sum=0;\nfor (int i=0; i< 128; i++)\n{\n sum += src_array[i];\n}\n```", "```cpp\nint sum=0;\nint sum1=0, sum2=0, sum3=0, sum4=0;\nfor (int i=0; i< 128; i+=4)\n{\n sum1 += src_array[i];\n sum2 += src_array[i+1];\n sum3 += src_array[i+2];\n sum4 += src_array[i+3];\n}\nsum = sum1 + sum2 + sum3 + sum4;\n```", "```cpp\nint sum=0;\nint sum1=0, sum2=0, sum3=0, sum4=0;\nfor (int i=0; i< 128; i+=4)\n{\n const int a1 = src_array[i];\n const int a2 = src_array[i+1];\n const int a3 = src_array[i+2];\n const int a4 = src_array[i+3];\n sum1 += a1;\n sum2 += a2;\n sum3 += a3;\n sum4 += a4;\n}\nsum = sum1 + sum2 + sum3 + sum4;\n```", "```cpp\nunsigned int __ballot(int predicate);\n```", "```cpp\n__device__ unsigned int __ballot_non_atom(int predicate)\n{\n if (predicate != 0)\n  return (1 << (threadIdx.x % 32));\n else\n  return 0;\n}\n```", "```cpp\nint atomicOr(int ∗ address, int val);\n```", "```cpp\nvolatile __shared__ u32 warp_shared_ballot[MAX_WARPS_PER_BLOCK];\n// Current warp number - divide by 32\nconst u32 warp_num = threadIdx.x >> 5;\natomicOr( &warp_shared_ballot[warp_num],\n```", "```cpp\natomicAdd(&block_shared_accumulate,\n          __popc(warp_shared_ballot[warp_num]));\n```", "```cpp\n__device__ int predicate_gt(const u32 a, const u32 b)\n{\n return (a > b);\n}\n__global__ void kernel_gt_u32(const u32 ∗ const data,\n                              u32 ∗ const block_results,\n                              u32 ∗ const acum,\n                              const u32 num_elements,\n                              const u32 threshold)\n{\n kernel_ballot_u32_acum(data, block_results, acum,\n                        num_elements, threshold,\n                        &predicate_gt);\n}\n```", "```cpp\n// Pad the SM array by 16 elements to ensure alignment\n// on 32 element boundary to avoid bank conflicts\n#define SM_PADDING 16\n// Max threads is 1024 so therefore max warps\n// is 1024 / 32 = 48\n#define MAX_WARPS_PER_BLOCK (48 + (SM_PADDING))\n#define WARP_SIZE 32\n// SM output per warp\nvolatile __shared__ u32 warp_shared_ballot[MAX_WARPS_PER_BLOCK];\n// SM output per block\nvolatile __shared__ u32 block_shared_accumulate;\n// Ballot and accumulate if predicate function is non zero\n__device__ void kernel_ballot_u32_acum(\n const u32 ∗ const data,\n u32 ∗ const block_results,\n u32 ∗ const gmem_acum,\n const u32 num_elements,\n```", "```cpp\n int (∗predicate_func)(const u32 a, const u32 b) )\n{\n // Calculate absolute thread number\n const u32 tid = (blockIdx.x ∗ blockDim.x) + threadIdx.x;\n // Current warp number - divide by 32\n const u32 warp_num = threadIdx.x >> 5;\n // Total number of warp number - divide by 32\n const u32 number_of_warps = blockDim.x >> 5;\n // If not off the end of the array then contribute\n if (tid < num_elements)\n {\n  // Have the first thread of every warp\n  // clear the shared memory entry\n  if ((threadIdx.x % WARP_SIZE) == 0)\n  {\n    warp_shared_ballot[warp_num] = 0;\n  }\n  // Call __ballot to set the N’th bit in the word\n  // with a warp if the predicate is true\n  // OR the bits from all threads in the warp into\n  // one value per warp held in shared memory\n  atomicOr( &warp_shared_ballot[warp_num],\n            __ballot_non_atom( predicate_func(data[tid], threshold)) );\n }\n // Wait for all warps to complete\n __syncthreads();\n // From the first warp, activate up to 32 threads\n // Actual number of threads needed is the number\n // warps in the block\n // All other warps drop out at this point\n if (threadIdx.x < number_of_warps)\n {\n  // Have thread zero, zero the accumulator\n  if (threadIdx.x == 0)\n  {\n   block_shared_accumulate = 0;\n  }\n  // Add to the single accumulator the number\n```", "```cpp\n  // Max threads equals number of warps\n  // which is typically 8 (256 threads), but\n  // max 32 (1024 threads)\n  atomicAdd(&block_shared_accumulate,\n            __popc(warp_shared_ballot[threadIdx.x]));\n  // No sync is required as only warp zero\n  // accumulates\n  // Have thread zero write out the result\n  if (threadIdx.x == 0)\n  {\n   // Read from SMEM the result for the block\n   const u32 block_result = block_shared_accumulate;\n   // Store the value for the block\n   block_results[blockIdx.x] = block_result;\n   // Add the value into GMEM total for all blocks\n   atomicAdd( gmem_acum, block_result );\n  }\n }\n}\n```", "```cpp\n // Calculate absolute thread number\n const u32 tid = (blockIdx.x ∗ blockDim.x) + threadIdx.x;\n```", "```cpp\n // Current warp number - divide by 32\n const u32 warp_num = threadIdx.x >> 5;\n // Total number of warp number - divide by 32\n const u32 number_of_warps = blockDim.x >> 5;\n```", "```cpp\n // If not off the end of the array then contribute\n if (tid < num_elements)\n {\n```", "```cpp\n  // Have the first thread of every warp\n  // clear the shared memory entry\n  if ((threadIdx.x % WARP_SIZE) == 0)\n  {\n   warp_shared_ballot[warp_num] = 0;\n  }\n```", "```cpp\n  // Call __ballot to set the N’th bit in the word\n  // with a warp if the predicate is true\n  // OR the bits from all threads in the warp into\n  // one value per warp held in shared memory\n  atomicOr( &warp_shared_ballot[warp_num],\n           __ballot_non_atom( predicate_func(data[tid], threshold)) );\n```", "```cpp\n // Wait for all warps to complete\n __syncthreads();\n```", "```cpp\n // From the first warp, activate up to 32 threads\n // Actual number of threads needed is the number\n // warps in the block\n // All other warps drop out at this point\n if (threadIdx.x < number_of_warps)\n {\n```", "```cpp\n // Have thread zero, zero the accumulator\n if (threadIdx.x == 0)\n {\n  block_shared_accumulate = 0;\n }\n```", "```cpp\n // Add to the single accumulator the number\n // of bits set from each warp.\n // Max threads equals number of warps\n // which is typically 8 (256 threads), but\n // max 32 (1024 threads)\n atomicAdd(&block_shared_accumulate,\n           __popc(warp_shared_ballot[threadIdx.x]));\n```", "```cpp\n // No sync is required as only warp zero\n // accumulates\n // Have thread zero write out the result\n if (threadIdx.x == 0)\n {\n```", "```cpp\n  // Read from SMEM the result for the block\n  const u32 block_result = block_shared_accumulate;\n  // Store the value for the block\n  block_results[blockIdx.x] = block_result;\n  // Add the value into GMEM total for all blocks\n  atomicAdd( gmem_acum, block_result );\n```", "```cpp\nProcessing 48 MB of data, 12M elements\nID:0 GeForce GTX 470: GPU Reduction Passed. Time 8.34 ms\nID:2 GeForce GTX 260: GPU Reduction Passed. Time 12.49 ms\nID:3 GeForce GTX 460: GPU Reduction Passed. Time 17.35 ms\n```", "```cpp\nProcessing 48 MB of data, 12M elements\nID:0 GeForce GTX 470: GPU Reduction Passed. Time 7.35 ms\nID:2 GeForce GTX 260: GPU Reduction Passed. Time 12.53 ms\nID:3 GeForce GTX 460: GPU Reduction Passed. Time 14.11 ms\nResult: 8742545\n```", "```cpp\n__device__ int predicate_within(const u32 a,\n                                const u32 b,\n                                const u32 c)\n{\n return ( (a > b) && (a < c) );\n}\n```", "```cpp\nProcessing 48 MB of data, 12M elements\nID:0 GeForce GTX 470: GPU Reduction Passed. Time 7.49 ms\nID:2 GeForce GTX 260: GPU Reduction Passed. Time 12.62 ms\nID:3 GeForce GTX 460: GPU Reduction Passed. Time 14.23 ms\nResult: 7679870\n```", "```cpp\nID:0 GeForce GTX 470: Test 16 - Selecting 16384 from 1048576 elements using 64 blocks of 256 threads\nNum Threads:                            32    64   128   256\nSelect Sample Time- CPU:   0.56  GPU: 0.56  0.19  0.06  0.38\nSort Sample Time -  CPU:   5.06  GPU: 5.06  5.06  5.06  5.06\nCount Bins Time -   CPU: 196.88  GPU: 7.28  4.80  4.59  4.47\nCalc. Bin Idx Time- CPU:   0.13  GPU: 1.05  0.71  0.70  0.98\nSort to Bins Time - CPU: 227.56  GPU: 7.63  4.85  4.62  4.49\nSort Bins Time -    CPU:  58.06  GPU:64.77 47.88 60.58 54.51\nTotal Time -        CPU: 488.25  GPU:86.34 63.49 75.61 69.88\nQSORT Time -        CPU: 340.44\nID:0 GeForce GTX 470: Test 16 - Selecting 32768 from 1048576 elements using 128 blocks of 256 threads\nNum Threads:                             32     64    128    256\nSelect Sample Time- CPU:    0.63  GPU: 0.63   0.63   0.75   0.38\nSort Sample Time -  CPU:   10.88  GPU:10.88  11.06  10.63  10.69\nCount Bins Time -   CPU:  222.19  GPU: 7.85   5.51   5.39   5.22\nCalc. Bin Idx Time- CPU:    0.19  GPU: 1.76   0.99   0.98   1.16\nSort to Bins Time - CPU:  266.06  GPU: 8.19   5.53   5.40   5.24\n```", "```cpp\nTotal Time -        CPU: 537.31  GPU:86.88 63.13 67.96 64.35\nQSORT Time -        CPU: 340.44\nID:0 GeForce GTX 470: Test 16 - Selecting 65536 from 1048576 elements using 256 blocks of 256 threads\nNum Threads:                            32    64   128   256\nSelect Sample Time- CPU:   1.00  GPU: 1.00  0.88  0.81  0.94\nSort Sample Time -  CPU:  22.69  GPU:22.69 22.50 22.44 23.00\nCount Bins Time -   CPU: 239.75  GPU: 8.32  5.90  5.79  5.62\nCalc. Bin Idx Time- CPU:   0.25  GPU: 1.49  1.98  1.60  1.65\nSort to Bins Time - CPU: 300.88  GPU: 8.69  5.97  5.82  5.67\nSort Bins Time -    CPU:  24.38  GPU:52.32 33.55 30.85 32.21\nTotal Time -        CPU: 588.94  GPU:94.50 70.78 67.32 69.09\nQSORT Time -        CPU: 340.44\n```", "```cpp\n__device__ void radix_sort(\n u32 ∗ const data,\n const u32 start_idx,\n const u32 end_idx,\n u32 ∗ const sort_tmp_1)\n{\n // Sort into num_list, lists\n // Apply radix sort on 32 bits of data\n for (u32 bit=0;bit<32;bit++)\n {\n  // Mask off all but the bit we’re interested in\n  const u32 bit_mask = (1u << bit);\n  // Set up the zero and one counter\n  u32 base_cnt_0 = start_idx;\n  u32 base_cnt_1 = start_idx;\n  for (u32 i=start_idx; i<end_idx; i++)\n  {\n   // Fetch the test data element\n   const u32 elem = data[i];\n   // If the element is in the one list\n   if ( (elem & bit_mask) > 0u )\n   {\n    // Copy to the one list\n    sort_tmp_1[base_cnt_1++] = elem;\n   }\n```", "```cpp\n   {\n    // Copy to the zero list (inplace)\n    data[base_cnt_0++] = elem;\n   }\n  }\n  // Copy data back to source from the one’s list\n  for (u32 i=start_idx; i<base_cnt_1; i++)\n  {\n   data[base_cnt_0++] = sort_tmp_1[i];\n  }\n }\n}\n```", "```cpp\n  mov.s64 %rd5, %rd2;\n  cvt.u64.u32 %rd6, %r17;\n  mul.wide.u32 %rd7, %r17, 4;\n  add.u64 %rd8, %rd5, %rd7;\n  ld.u32 %r20, [%rd8+0];\n  mov.s32 %r21, %r20;\n```", "```cpp\n// Fetch the test data element\nconst u32 elem = data[i];\n```", "```cpp\n// Fetch the test data element\nconst u32 elem = (∗data_in_ptr);\ndata_in_ptr++;\n```", "```cpp\n; const u32 elem = (∗data_in_ptr);\nmov.s64  %rd20, %rd14;\nld.u32 %r18, [%rd20+0];\nmov.s32  %r19, %r18;\n; data_in_ptr++;\nmov.s64   %rd21, %rd14;\nadd.u64   %rd22, %rd21, 4;\n```", "```cpp\nBin Usage - Max:331 Min:0 Avg:32 Zero:10275\n0000:00000022 0001:00000000 0002:0000003e 0003:0000001d 0004:00000028 0005:00000000 0006:00000018 0007:0000003d\n0008:00000052 0009:00000000 0010:0000001d 0011:00000000 0012:00000061 0013:00000000 0014:00000000 0015:00000000\n0016:00000024 0017:0000009d 0018:00000021 0019:00000000 0020:0000002b 0021:00000021 0022:00000000 0023:00000000\n0024:00000025 0025:00000000 0026:00000056 0027:00000050 0028:00000019 0029:00000000 0030:00000025 0031:0000001d\n```", "```cpp\nfor (u32 i=start_idx; i<end_idx; i++)\n{\n// Fetch the test data element\nconst u32 elem = (∗data_in_ptr);\ndata_in_ptr++;\n```", "```cpp\n// Unroll 4 times\n```", "```cpp\nif ( (end_idx - start_idx) >= 4)\n{\n for (; i< (end_idx-4); i+=4)\n {\n  // Fetch the test first and second data element\n  const u32 elem_1 = (∗data_in_ptr);\n  const u32 elem_2 = (∗(data_in_ptr+1));\n  const u32 elem_3 = (∗(data_in_ptr+2));\n  const u32 elem_4 = (∗(data_in_ptr+3));\n  data_in_ptr+=4;\n```", "```cpp\n;const u32 elem_1 = (∗data_in_ptr);\n  mov.s64 %rd20, %rd14;\n  ld.u32 %r23, [%rd20+0];\n  mov.s32 %r24, %r23;\n;const u32 elem_2 = (∗(data_in_ptr+1));\n  mov.s64 %rd21, %rd14;\n  ld.u32 %r25, [%rd21+4];\n  mov.s32 %r26, %r25;\n;const u32 elem_3 = (∗(data_in_ptr+2));\n  mov.s64 %rd22, %rd14;\n  ld.u32 %r27, [%rd22+8];\n  mov.s32 %r28, %r27;\n;const u32 elem_4 = (∗(data_in_ptr+3));\n  mov.s64 %rd23, %rd14;\n  ld.u32 %r29, [%rd23+12];\n  mov.s32 %r30, %r29;\n;data_in_ptr+=4;\n  mov.s64 %rd24, %rd14;\n  add.u64 %rd25, %rd24, 16;\n  mov.s64 %rd14, %rd25;\n```", "```cpp\nID:0 GeForce GTX 470: Test 16 - Selecting 32768 from 1048576 elements using 128 blocks of 256 threads\nNum Threads:                            32    64   128   256\nSelect Sample Time- CPU:   0.38  GPU: 0.38  0.19  0.50  0.31\nSort Sample Time -  CPU:   4.63  GPU: 4.63  4.69  4.31  4.31\nCount Bins Time -   CPU:  64.50  GPU: 5.71  5.65  5.59  5.31\nCalc. Bin Idx Time- CPU:   0.06  GPU: 1.55  0.79  0.86  0.79\nSort to Bins Time - CPU:  80.44  GPU: 6.25  6.08  5.96  5.71\n```", "```cpp\nTotal Time -        CPU: 212.81  GPU:45.89 42.49 53.50 56.31\nQSORT Time -        CPU: 187.69\nID:0 GeForce GTX 470: Test 16 - Selecting 65536 from 1048576 elements using 256 blocks of 256 threads\nNum Threads:                            32    64   128   256\nSelect Sample Time- CPU:   0.50  GPU: 0.50  0.50  0.44  0.50\nSort Sample Time -  CPU:   9.56  GPU: 9.56  9.63  9.56  9.63\nCount Bins Time -   CPU:  95.88  GPU: 6.70  6.67  6.60  6.34\nCalc. Bin Idx Time- CPU:   0.06  GPU: 1.17  1.22  1.36  1.19\nSort to Bins Time - CPU: 119.88  GPU: 7.27  7.06  6.94  6.73\nSort Bins Time -    CPU:  52.94  GPU:24.23 16.84 25.22 29.95\nTotal Time -        CPU: 278.81  GPU:49.43 41.91 50.12 54.35\nQSORT Time -        CPU: 187.69\n```", "```cpp\nunsigned char s_box[256] =\n{\n/∗   0         1        2        3         4        5         6         7        8         9        A         B         C        D         E         F    ∗/\n 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, /∗ 0 ∗/\n 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, /∗ 1 ∗/\n 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, /∗ 2 ∗/\n 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, /∗ 3 ∗/\n 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, /∗ 4 ∗/\n 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, /∗ 5 ∗/\n 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, /∗ 6 ∗/\n 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, /∗ 7 ∗/\n 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, /∗ 8 ∗/\n 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, /∗ 9 ∗/\n 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, /∗ A ∗/\n```", "```cpp\n 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, /∗ C ∗/\n 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, /∗ D ∗/\n 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, /∗ E ∗/\n 0x8C, 0xA1, 0x89, 0x0D, 0xBF,0xE6, 0x42, 0x68, 0x41,0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16 /∗ F ∗/\n};\n```", "```cpp\nvoid mix_column(unsigned char ∗r)\n{\n unsigned char a[4];\n unsigned char b[4];\n unsigned char c;\n unsigned char h;\n for(c=0;c<4;c++)\n {\n  a[c] = r[c];\n  h = r[c] & 0x80; /∗ hi bit ∗/\n  b[c] = r[c] << 1;\n  if(h == 0x80)\n   b[c] ^= 0x1b; /∗ Rijndael’s Galois field ∗/\n }\n r[0] = b[0] ^ a[3] ^ a[2] ^ b[1] ^ a[1];\n r[1] = b[1] ^ a[0] ^ a[3] ^ b[2] ^ a[2];\n r[2] = b[2] ^ a[1] ^ a[0] ^ b[3] ^ a[3];\n r[3] = b[3] ^ a[2] ^ a[1] ^ b[0] ^ a[0];\n}\n```", "```cpp\n__host__ __device__ void AES_encrypt_4x4_reg(uint4 ∗ const cipher_block,\n                                             KEY_T ∗ const cipher_key,\n                                             const u32 num_rounds)\n{\n```", "```cpp\n const u8 ∗ const s_box_ptr = s_box;\n // Read 4 x 32 bit values from data block\n u32 w0 = cipher_block->w;\n u32 w1 = cipher_block->x;\n u32 w2 = cipher_block->y;\n u32 w3 = cipher_block->z;\n```", "```cpp\n register u8 a0 =  EXTRACT_D0(w0);\n register u8 a1 =  EXTRACT_D0(w1);\n register u8 a2 =  EXTRACT_D0(w2);\n register u8 a3 =  EXTRACT_D0(w3);\n register u8 a4 =  EXTRACT_D1(w0);\n register u8 a5 =  EXTRACT_D1(w1);\n register u8 a6 =  EXTRACT_D1(w2);\n register u8 a7 =  EXTRACT_D1(w3);\n register u8 a8 =  EXTRACT_D2(w0);\n register u8 a9 =  EXTRACT_D2(w1);\n register u8 a10 = EXTRACT_D2(w2);\n register u8 a11 = EXTRACT_D2(w3);\n register u8 a12 = EXTRACT_D3(w0);\n register u8 a13 = EXTRACT_D3(w1);\n register u8 a14 = EXTRACT_D3(w2);\n register u8 a15 = EXTRACT_D3(w3);\n```", "```cpp\n// Initial round - add key only\n u32 round_num = 0;\n // Fetch cipher key from memory\n```", "```cpp\n w1 = (∗cipher_key)[round_num].x;\n w2 = (∗cipher_key)[round_num].y;\n w3 = (∗cipher_key)[round_num].z;\n```", "```cpp\n a0 ^=  EXTRACT_D0(w0);\n a4 ^=  EXTRACT_D1(w0);\n  a8 ^= EXTRACT_D2(w0);\n a12 ^= EXTRACT_D3(w0);\n  a1 ^= EXTRACT_D0(w1);\n  a5 ^= EXTRACT_D1(w1);\n  a9 ^= EXTRACT_D2(w1);\n a13 ^= EXTRACT_D3(w1);\n a2 ^=  EXTRACT_D0(w2);\n a6 ^=  EXTRACT_D1(w2);\n a10 ^= EXTRACT_D2(w2);\n a14 ^= EXTRACT_D3(w2);\n  a3 ^= EXTRACT_D0(w3);\n  a7 ^= EXTRACT_D1(w3);\n a11 ^= EXTRACT_D2(w3);\n a15 ^= EXTRACT_D3(w3);\n round_num++;\n```", "```cpp\n while (round_num <= num_rounds)\n {\n  // Fetch cipher key from memory\n  w0 = (∗cipher_key)[round_num].w;\n  w1 = (∗cipher_key)[round_num].x;\n  w2 = (∗cipher_key)[round_num].y;\n  w3 = (∗cipher_key)[round_num].z;\n   // Substitution step\n   a0 = s_box_ptr[a0];\n   a1 = s_box_ptr[a1];\n   a2 = s_box_ptr[a2];\n   a3 = s_box_ptr[a3];\n   a4 = s_box_ptr[a4];\n   a5 = s_box_ptr[a5];\n   a6 = s_box_ptr[a6];\n   a7 = s_box_ptr[a7];\n   a8 = s_box_ptr[a8];\n```", "```cpp\n  a10 = s_box_ptr[a10];\n  a11 = s_box_ptr[a11];\n  a12 = s_box_ptr[a12];\n  a13 = s_box_ptr[a13];\n  a14 = s_box_ptr[a14];\n  a15 = s_box_ptr[a15];\n```", "```cpp\n // Rotate Rows\n u8 tmp0, tmp1, tmp2, tmp3;\n // a0, a4, a8, a12 remains unchanged\n // a1, a5, a9, a13 rotate 1\n // a5, a9, a13, a1\n tmp0 = a1;\n a1 = a5;\n a5 = a9;\n a9 = a13;\n a13 = tmp0;\n // a2, a6, a10, a14 rotate 2\n // a10, a14, a2, a6\n tmp0 = a14;\n tmp1 = a10;\n a14 = a6;\n a10 = a2;\n a6 = tmp0;\n a2 = tmp1;\n // a3, a7, a11, a15 rotate 3\n // a15, a3, a7, a11\n tmp0 = a3;\n tmp1 = a7;\n tmp2 = a11;\n tmp3 = a15;\n a15 = tmp2;\n a11 = tmp1;\n  a7 = tmp0;\n  a3 = tmp3;\n```", "```cpp\n if (round_num != 10)\n {\n  // Column Mix\n  const u8 b0 =  MIX_COL(a0);\n  const u8 b1 =  MIX_COL(a1);\n  const u8 b2 =  MIX_COL(a2);\n  const u8 b3 =  MIX_COL(a3);\n  const u8 b4 =  MIX_COL(a4);\n  const u8 b5  = MIX_COL(a5);\n  const u8 b6  = MIX_COL(a6);\n  const u8 b7  = MIX_COL(a7);\n  const u8 b8  = MIX_COL(a8);\n  const u8 b9  = MIX_COL(a9);\n  const u8 b10 = MIX_COL(a10);\n  const u8 b11 = MIX_COL(a11);\n  const u8 b12 = MIX_COL(a12);\n  const u8 b13 = MIX_COL(a13);\n  const u8 b14 = MIX_COL(a14);\n  const u8 b15 = MIX_COL(a15);\n   tmp0 = XOR_5(b0, a3, a2, b1, a1 );\n   tmp1 = XOR_5(b1, a0, a3, b2, a2 );\n   tmp2 = XOR_5(b2, a1, a0, b3, a3 );\n   tmp3 = XOR_5(b3, a2, a1, b0, a0 );\n  const u8 tmp4  = XOR_5(b4, a7, a6, b5, a5 );\n  const u8 tmp5  = XOR_5(b5, a4, a7, b6, a6 );\n  const u8 tmp6  = XOR_5(b6, a5, a4, b7, a7 );\n  const u8 tmp7  = XOR_5(b7, a6, a5, b4, a4 );\n  const u8 tmp8  = XOR_5(b8, a11, a10, b9, a9 );\n  const u8 tmp9  = XOR_5(b9, a8, a11, b10, a10 );\n  const u8 tmp10 = XOR_5(b10, a9, a8, b11, a11 );\n  const u8 tmp11 = XOR_5(b11, a10, a9, b8, a8 );\n  const u8 tmp12 = XOR_5(b12, a15, a14, b13, a13 );\n  const u8 tmp13 = XOR_5(b13, a12, a15, b14, a14 );\n  const u8 tmp14 = XOR_5(b14, a13, a12, b15, a15 );\n  const u8 tmp15 = XOR_5(b15, a14, a13, b12, a12 );\n   a0 = tmp0;\n   a1 = tmp1;\n   a2 = tmp2;\n   a3 = tmp3;\n   a4 = tmp4;\n   a5 = tmp5;\n   a6 = tmp6;\n   a7 = tmp7;\n   a8 = tmp8;\n```", "```cpp\n  a10 = tmp10;\n  a11 = tmp11;\n  a12 = tmp12;\n  a13 = tmp13;\n  a14 = tmp14;\n  a15 = tmp15;\n }\n```", "```cpp\n   // Addkey\n   a0 ^= EXTRACT_D0(w0);\n   a4 ^= EXTRACT_D1(w0);\n   a8 ^= EXTRACT_D2(w0);\n  a12 ^= EXTRACT_D3(w0);\n   a1 ^= EXTRACT_D0(w1);\n   a5 ^= EXTRACT_D1(w1);\n   a9 ^= EXTRACT_D2(w1);\n  a13 ^= EXTRACT_D3(w1);\n   a2 ^= EXTRACT_D0(w2);\n   a6 ^= EXTRACT_D1(w2);\n  a10 ^= EXTRACT_D2(w2);\n  a14 ^= EXTRACT_D3(w2);\n   a3 ^= EXTRACT_D0(w3);\n   a7 ^= EXTRACT_D1(w3);\n  a11 ^= EXTRACT_D2(w3);\n  a15 ^= EXTRACT_D3(w3);\n  round_num++;\n }\n```", "```cpp\n cipher_block->w = (ENCODE_D0(a0) | ENCODE_D1(a4) | ENCODE_D2(a8) | ENCODE_D3(a12));\n cipher_block->x = (ENCODE_D0(a1) | ENCODE_D1(a5) | ENCODE_D2(a9) | ENCODE_D3(a13));\n cipher_block->y = (ENCODE_D0(a2) | ENCODE_D1(a6) | ENCODE_D2(a10) | ENCODE_D3(a14));\n cipher_block->z = (ENCODE_D0(a3) | ENCODE_D1(a7) | ENCODE_D2(a11) | ENCODE_D3(a15));\n}\n```", "```cpp\n#define EXTRACT_D0(x) ( ( (x) >> 24uL ) )\n```", "```cpp\n#define EXTRACT_D2(x) ( ( (x) >> 8uL ) & 0xFFuL )\n#define EXTRACT_D3(x) ( ( (x)  ) & 0xFFuL )\n#define ENCODE_D0(x) ( (x) << 24uL )\n#define ENCODE_D1(x) ( (x) << 16uL )\n#define ENCODE_D2(x) ( (x) << 8uL )\n#define ENCODE_D3(x) ( (x)  )\n#define MIX_COL(a) ( ((a) & 0x80uL) ? ((((a) << 1uL) & 0xFFuL) ^ 0x1Bu) : ((a) << 1uL) )\n#define XOR_5(a,b,c,d,e) ( (((a)^(b)) ^ ((c)^(d))) ^ (e) )\n```", "```cpp\n// Encodes multiple blocks based on different key sets\n__global__ void AES_encrypt_gpu(uint4 ∗ const cipher_blocks,\n                                KEY_T ∗ const cipher_keys,\n                                const u32 num_cipher_blocks,\n                                const u32 num_cipher_keys,\n                                const u32 num_rounds)\n{\n```", "```cpp\n if (idx < num_cipher_blocks)\n {\n  AES_encrypt_4x4_reg(&(cipher_blocks[idx]),\n                      &(cipher_keys[0]),\n                      num_rounds);\n }\n}\n```", "```cpp\n// Column Mix\nconst u8 b0 = MIX_COL(a0);\nconst u8 b1 = MIX_COL(a1);\nconst u8 b2 = MIX_COL(a2);\nconst u8 b3 = MIX_COL(a3);\nconst u8 tmp0 = XOR_5(b0, a3, a2, b1, a1 );\nconst u8 tmp1 = XOR_5(b1, a0, a3, b2, a2 );\nconst u8 tmp2 = XOR_5(b2, a1, a0, b3, a3 );\nconst u8 tmp3 = XOR_5(b3, a2, a1, b0, a0 );\na0 = tmp0;\na1 = tmp1;\na2 = tmp2;\na3 = tmp3;\n```", "```cpp\nw0 = (∗cipher_key)[round_num].w;\n```", "```cpp\n// Fetch cipher key from memory\nconst uint4 ∗ const key_ptr = &((∗cipher_key)[0]);\nw0 = key_ptr->w;\nw1 = key_ptr->x;\nw2 = key_ptr->y;\nw3 = key_ptr->z;\n```", "```cpp\nwhile (round_num <= num_rounds)\n```", "```cpp\nwhile (round_num <= NUM_ROUNDS)\n```", "```cpp\nuint4 ∗ cipher_data_host = (uint4 ∗) malloc(size_of_cipher_data_in_bytes);\nKEY_T ∗ cipher_key_host = (KEY_T ∗) malloc(size_of_cipher_key_size_in_bytes);\n```", "```cpp\nuint4 ∗ cipher_data_host;\nKEY_T ∗ cipher_key_host;\nCUDA_CALL(cudaMallocHost(&cipher_data_host, size_of_cipher_data_in_bytes));\nCUDA_CALL(cudaMallocHost(&cipher_key_host, size_of_cipher_key_size_in_bytes));\n```", "```cpp\nfree(cipher_key_host);\nfree(cipher_data_host);\n```", "```cpp\nCUDA_CALL(cudaFreeHost(cipher_data_host));\nCUDA_CALL(cudaFreeHost(cipher_key_host));\n```", "```cpp\ncudaStream_t aes_async_stream;\nCUDA_CALL(cudaStreamCreate(&aes_async_stream));\n```", "```cpp\nCUDA_CALL(cudaStreamDestroy(aes_async_stream));\n```", "```cpp\n// Copy to GPU and then zero host cipher memory\nCUDA_CALL(cudaEventRecord(start_round_timer));\nCUDA_CALL(cudaMemcpyAsync(cipher_data_device, cipher_data_host, size_of_cipher_data_in_bytes, cudaMemcpyHostToDevice));\nCUDA_CALL(cudaMemcpyAsync(cipher_key_device, cipher_key_host, size_of_cipher_key_size_in_bytes, cudaMemcpyHostToDevice));\n```", "```cpp\n// Copy to GPU and then zero host cipher memory\n```", "```cpp\nCUDA_CALL(cudaMemcpyAsync(cipher_data_device, cipher_data_host, size_of_cipher_data_in_bytes, cudaMemcpyHostToDevice, aes_async_stream));\nCUDA_CALL(cudaMemcpyAsync(cipher_key_device, cipher_key_host, size_of_cipher_key_size_in_bytes, cudaMemcpyHostToDevice, aes_async_stream));\n```", "```cpp\nAES_encrypt_gpu<<<num_blocks, num_threads>>> (cipher_data_device, cipher_key_device, num_cipher_blocks, num_cipher_keys);\n```", "```cpp\nAES_encrypt_gpu<<<num_blocks, num_threads, 0, aes_async_stream>>> (cipher_data_device, cipher_key_device, num_cipher_blocks, num_cipher_keys);\n```", "```cpp\nCUDA_CALL(cudaEventSynchronize(stop_round_timer));\n```", "```cpp\nvoid aes_encode_block_aes_ni(const u32 num_cipher_blocks,\n                             const u32 num_cipher_keys,\n                             const u8 ∗ initial_keys,\n                             u8 ∗ src_data_blocks,\n                             u8 ∗ dest_data_blocks)\n{\n  // Encode the data blocks\n  TIMER_T encode_key_time = get_time();\n  // Encode using one or more blocks and single key\n  intel_AES_enc128( (_AES_IN UCHAR ∗) src_data_blocks,\n               (_AES_OUT UCHAR ∗) dest_data_blocks,\n               (_AES_IN UCHAR ∗) initial_keys,\n               (_AES_IN size_t) num_cipher_blocks );\n  encode_key_time = (get_time() - encode_key_time);\n  if (num_cipher_blocks > 1)\n  {\n   printf(\"\\n\\nEncrypting using AES-NI : %.u blocks\", num_cipher_blocks);\n  printf(\"\\nEncrypt Encode : %.3fms\", encode_key_time);\n }\n}\n```", "```cpp\nvoid aes_decode_block_aes_ni(const u32 num_src_cipher_blocks,\n               const u32 num_cipher_keys,\n```", "```cpp\n               const u8 ∗ src_data_blocks,\n               u8 ∗ const dest_data_blocks)\n{\n  // Decode one or more blocks using a single key\n  TIMER_T decode_key_time = get_time();\n  intel_AES_dec128( (_AES_IN UCHAR ∗) src_data_blocks,\n                    (_AES_OUT UCHAR ∗) dest_data_blocks,\n                    (_AES_IN UCHAR ∗ ) key,\n                    (_AES_IN size_t) num_src_cipher_blocks );\n  decode_key_time = (get_time() - decode_key_time);\n  if (num_src_cipher_blocks > 1)\n  {\n   printf(\"\\n\\nDecrypting using AES-NI : %.u blocks\", num_src_cipher_blocks);\n   printf(\"\\nDecrypt Decode   :%.3fms\", decode_key_time);\n  }\n}\n```", "```cpp\n#define AES_U8_DECODE u32\n__host__ __device__ void AES_decrypt_4x4_reg(const uint4 ∗ const src_cipher_block,\n                                             uint4 ∗ const dest_cipher_block,\n                                             KEY_T ∗ const cipher_key)\n{\n // Read 4 x 32 bit values from data block as 128 bit read\n uint4 key = ∗src_cipher_block;\n // Store into four 32 bit registers\n u32 w0 = key.x;\n```", "```cpp\n u32 w2 = key.z;\n u32 w3 = key.w;\n // Allocate room for sixteen 32 bit registers\n register AES_U8_DECODE a0, a4, a8, a12;\n register AES_U8_DECODE a1, a5, a9, a13;\n register AES_U8_DECODE a2, a6, a10, a14;\n register AES_U8_DECODE a3, a7, a11, a15;\n // Expand the 32 bit words into 16 registers\n EXTRACT_WORD(w0, a0, a1, a2, a3);\n EXTRACT_WORD(w1, a4, a5, a6, a7);\n EXTRACT_WORD(w2, a8, a9, a10, a11);\n EXTRACT_WORD(w3, a12, a13, a14, a15);\n // Always start at round ten\n u32 round_num = NUM_ROUNDS;\n // Setup some pointers to the lookup gmul tables\n const GMUL_U8 ∗ const gmul_14_ptr = gmul_tab_14;\n const GMUL_U8 ∗ const gmul_09_ptr = gmul_tab_09;\n const GMUL_U8 ∗ const gmul_13_ptr = gmul_tab_13;\n const GMUL_U8 ∗ const gmul_11_ptr = gmul_tab_11;\n // Define either a host or device point for the s_box function\n#ifdef __CUDA_ARCH__\n  const S_BOX_U8 ∗ const s_box_ptr = s_box_inv_device;\n#else\n  const S_BOX_U8 ∗ const s_box_ptr = s_box_inv_host;\n#endif\n // Count down from round ten to round one\n while (round_num > 0)\n {\n  // Add Round Key\n  {\n   // Fetch cipher key from memory as a 128 bit read\n   key = ((∗cipher_key)[round_num]);\n   // Convert to four 32 bit values\n   w0 = key.x;\n   w1 = key.y;\n   w2 = key.z;\n   w3 = key.w;\n   // Extract the key values, XOR’ing them with\n   // the current values\n   EXTRACT_WORD_XOR(w0, a0, a1, a2, a3);\n```", "```cpp\n   EXTRACT_WORD_XOR(w2, a8, a9, a10, a11);\n   EXTRACT_WORD_XOR(w3, a12, a13, a14, a15);\n  }\n  // Invert Column Mix on every round except the first\n  if (round_num != 10)\n  {\n   AES_U8_DECODE tmp0, tmp1, tmp2, tmp3;\n   // Invert mix column operation on each column\n   INV_MIX_COLUMN_PTR(a0, a1, a2, a3,\n               tmp0, tmp1, tmp2, tmp3,\n               gmul_14_ptr, gmul_09_ptr, gmul_13_ptr, gmul_11_ptr);\n   INV_MIX_COLUMN_PTR(a4, a5, a6, a7,\n               tmp0, tmp1, tmp2, tmp3,\n               gmul_14_ptr, gmul_09_ptr, gmul_13_ptr, gmul_11_ptr);\n   INV_MIX_COLUMN_PTR(a8, a9, a10, a11,\n               tmp0, tmp1, tmp2, tmp3,\n               gmul_14_ptr, gmul_09_ptr, gmul_13_ptr, gmul_11_ptr);\n   INV_MIX_COLUMN_PTR(a12, a13, a14, a15,\n               tmp0, tmp1, tmp2, tmp3,\n               gmul_14_ptr, gmul_09_ptr, gmul_13_ptr, gmul_11_ptr);\n  }\n  // Invert Shift Rows\n  {\n   // a0, a4, a8, a12 remains unchanged\n   // a1, a5, a9, a13 rotate right 1\n   AES_U8_DECODE tmp0;\n   ROTR_1(a1, a5, a9, a13, tmp0);\n   // a2, a6, a10, a14 rotate right 2\n   AES_U8_DECODE tmp1;\n   ROTR_2(a2, a6, a10, a14, tmp0, tmp1);\n   // a3, a7, a11, a15 rotate right 3\n   ROTR_3(a3, a7, a11, a15, tmp0);\n  }\n  // Invert Substitute bytes\n  {\n   SBOX_SUB(s_box_ptr, a0, a4, a8, a12);\n   SBOX_SUB(s_box_ptr, a1, a5, a9, a13);\n   SBOX_SUB(s_box_ptr, a2, a6, a10, a14);\n   SBOX_SUB(s_box_ptr, a3, a7, a11, a15);\n```", "```cpp\n  // Decrement the round counter\n  round_num--;\n }\n // Execute round zero - only an XOR\n // Read ahead of time, round zero of the cipher key\n key = ((∗cipher_key)[0]);\n // Pack the values back into registers\n w0 = ENCODE_WORD( a0, a1, a2, a3 );\n w1 = ENCODE_WORD( a4, a5, a6, a7 );\n w2 = ENCODE_WORD( a8, a9, a10, a11 );\n w3 = ENCODE_WORD( a12, a13, a14, a15 );\n // XOR the results with the last key\n key.x ^= w0;\n key.y ^= w1;\n key.z ^= w2;\n key.w ^= w3;\n // Use a 128 bit memory write to store the decoded block\n ∗dest_cipher_block = key;\n}\n```", "```cpp\nnn bytes stack frame, nn bytes spill stores, nn bytes spill loads\n```", "```cpp\n__global__ void AES_decode_kernel_multi_block_single_key(uint4 ∗ const src_block,\n                                                         uint4 ∗ const dest_blocks,\n                                                         KEY_T ∗ const expanded_key,\n                                                         const u32 num_cipher_blocks)\n{\n```", "```cpp\n if (tid < num_cipher_blocks)\n  AES_decrypt_4x4_reg( &(src_block[tid]), &(dest_blocks[tid]), &(expanded_key[0]) );\n}\n__host__ __device__ void AES_decrypt_4x4_reg(\n const uint4 ∗ const src_cipher_block,\n uint4 ∗ const dest_cipher_block,\n KEY_T ∗ const cipher_key)\n{\n…\n}\n```", "```cpp\n__host__ __device__ __forceinline__ void AES_decrypt_4x4_reg(\n const uint4 ∗ const src_cipher_block,\n uint4 ∗ const dest_cipher_block,\n KEY_T ∗ const cipher_key)\n{\n…\n```", "```cpp\n // Add Round Key\n {\n  // Fetch cipher key from memory as a 128 bit read\n  ∗key_ptr = ((∗cipher_key)[round_num]);\n  // Extract the key values, XOR’ing them with\n  // the current values\n  EXTRACT_WORD_XOR2((key_ptr->x), a0, a1, a2, a3);\n  EXTRACT_WORD_XOR2((key_ptr->y), a4, a5, a6, a7);\n  EXTRACT_WORD_XOR2((key_ptr->z), a8, a9, a10, a11);\n  EXTRACT_WORD_XOR2((key_ptr->w), a12, a13, a14, a15);\n }\n // Invert Column Mix on every round except the first\n if (round_num != 10)\n {\n  INV_MIX_COLUMN_PTR2(a0, a1, a2, a3,\n             gmul_14_ptr, gmul_09_ptr, gmul_13_ptr, gmul_11_ptr);\n  INV_MIX_COLUMN_PTR2(a4, a5, a6, a7,\n             gmul_14_ptr, gmul_09_ptr, gmul_13_ptr, gmul_11_ptr);\n  INV_MIX_COLUMN_PTR2(a8, a9, a10, a11,\n             gmul_14_ptr, gmul_09_ptr, gmul_13_ptr, gmul_11_ptr);\n```", "```cpp\n             gmul_14_ptr, gmul_09_ptr, gmul_13_ptr, gmul_11_ptr);\n }\n```", "```cpp\n // Add Round Key\n {\n  // Fetch cipher key from memory as a 128 bit read\n  ∗key_ptr = ((∗cipher_key)[round_num]);\n  // Extract the key values, XOR’ing them with\n  // the current values\n  EXTRACT_WORD_XOR2((key_ptr->x), a0, a1, a2, a3);\n  if (round_num != 10)\n   INV_MIX_COLUMN_PTR2(a0, a1, a2, a3,\n              gmul_14_ptr, gmul_09_ptr, gmul_13_ptr, gmul_11_ptr);\n  EXTRACT_WORD_XOR2((key_ptr->y), a4, a5, a6, a7);\n  if (round_num != 10)\n   INV_MIX_COLUMN_PTR2(a4, a5, a6, a7,\n              gmul_14_ptr, gmul_09_ptr, gmul_13_ptr, gmul_11_ptr);\n  EXTRACT_WORD_XOR2((key_ptr->z), a8, a9, a10, a11);\n  if (round_num != 10)\n   INV_MIX_COLUMN_PTR2(a8, a9, a10, a11,\n              gmul_14_ptr, gmul_09_ptr, gmul_13_ptr, gmul_11_ptr);\n  EXTRACT_WORD_XOR2((key_ptr->w), a12, a13, a14, a15);\n  if (round_num != 10)\n   INV_MIX_COLUMN_PTR2(a12, a13, a14, a15,\n              gmul_14_ptr, gmul_09_ptr, gmul_13_ptr, gmul_11_ptr);\n }\n```", "```cpp\nIntel AES NI support enabled.\nLogical CUDA device 0 mapped to physical device 0\\. Device ID: GeForce GTX 470 on PCI-E 5\nLogical CUDA device 1 mapped to physical device 1\\. Device ID: GeForce GTX 470 on PCI-E 4\nLogical CUDA device 2 mapped to physical device 2\\. Device ID: GeForce GTX 470 on PCI-E 3\nLogical CUDA device 3 mapped to physical device 3\\. Device ID: GeForce GTX 470 on PCI-E 2\nLogical CUDA device 4 mapped to physical device 4\\. Device ID: GeForce GTX 470 on PCI-E 1\ntest_single_block_single_key_encode_decode\nAES NI Key           :  2b, 7e, 15, 16, 28, ae, d2, a6, ab, f7, 15, 88, 09, cf, 4f, 3c,\nAES NI Plaintext     :  6b, c1, be, e2, 2e, 40, 9f, 96, e9, 3d, 7e, 11, 73, 93, 17, 2a,\nAES NI Ciphertext    :  3a, d7, 7b, b4, 0d, 7a, 36, 60, a8, 9e, ca, f3, 24, 66, ef, 97,\nExpected Ciphertext  :  3a, d7, 7b, b4, 0d, 7a, 36, 60, a8, 9e, ca, f3, 24, 66, ef, 97,\nSingle block single key AES-NI decode Passed\nGPU Intial Key       :  16157e2b,  a6d2ae28,  8815f7ab,  3c4fcf09,\nGPU Plaintext        :  e2bec16b,  969f402e,  117e3de9,  2a179373,\nCPU Ciphertext       :  b47bd73a,  60367a0d,  f3ca9ea8,  97ef6624,\nGPU Ciphertext       :  b47bd73a,  60367a0d,  f3ca9ea8,  97ef6624,\nExpected Ciphertext  :  b47bd73a,  60367a0d,  f3ca9ea8,  97ef6624,\nSingle block single key serial decode Passed\nSingle block single key parallel decode Passed\nSingle block single key parallel decode and AES-NI match Passed\nEncrypting on GPU         :  4194304 blocks (32768 Blocks x 128 Threads)\nEncrypt Copy To Device    :  28.469ms\nEncrypt Expand Key Kernel :   0.025ms\nEncrypt Encode Key Kernel :  45.581ms\n```", "```cpp\nEncrypt Total Time        :  99.503ms\nEncrypting on CPU        :  4194304 blocks\nEncrypt Encode           :  3900.000ms\nEncrypting using AES-NI  :  4194304 blocks\nEncrypt Encode           :  20.000ms\nCPU and GPU encode result Passed.\nCPU and GPU AES-NI encode result Passed.\nDecrypting on GPU         :  4194304 blocks (32768 Blocks x 128 Threads)\nDecrypt Copy To Device    :  27.531ms\nDecrypt Expand Key Kernel :   0.028ms\nDecrypt Decode Key Kernel :  62.027ms\nDecrypt Copy From Device  :  25.914ms\nDecrypt Total Time        : 115.500ms\nDecrypting on CPU  :  4194304 blocks\nDecrypt Decode     :  2760.000ms\nDecrypting using AES-NI  :  4194304 blocks\nDecrypt Decode           :  20.000ms\nCPU and GPU decode result Passed.\nCPU and AES-NI decode result Passed.\n```"]