- en: Scene Setup and Boundary Element Collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://phys-sim-book.github.io/lec21.1-scene_setup.html](https://phys-sim-book.github.io/lec21.1-scene_setup.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, we set up a new scene with two squares falling onto the ground,
    compressed by the ceiling so that self-contact will occur between these squares.
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation 21.1.1 (Simulation setup, simulator.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In line 17, we adapt the DOF index of the ceiling from (n*seg+1)∗(nseg+1) to
    (n*seg+1)∗(nseg+1)∗2, as we now have two squares. Line 26 generates the first
    square on the top, while lines 27 and 28 generate the second square on the bottom
    by creating copies and offsets.**
  prefs: []
  type: TYPE_NORMAL
- en: '**The initial frame, as shown in [Figure 21.1.1](#fig:lec21:initial_frame),
    is now established. However, without handling self-contact, these two squares
    cannot interact with each other yet.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/72510f01c2f90ae7e3f433a71dfd3cf3.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 21.1.1.** The new scene setup with 2 squares to fall.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle contact, we first need to collect all boundary elements. In 2D, this
    involves identifying the nodes and edges on the boundary where contact forces
    will be applied to all close but non-incident point-edge pairs. The following
    function finds all boundary nodes and edges given a triangle mesh:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation 21.1.2 (Collect boundary elements, square_mesh.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This function is called in `simulator.py`, and the boundary elements are then
    passed to the time integrator for energy, gradient, and Hessian evaluations, as
    well as line search filtering.**
  prefs: []
  type: TYPE_NORMAL
