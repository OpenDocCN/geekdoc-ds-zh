- en: Scene Setup and Boundary Element Collection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景设置和边界元素收集
- en: 原文：[https://phys-sim-book.github.io/lec21.1-scene_setup.html](https://phys-sim-book.github.io/lec21.1-scene_setup.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://phys-sim-book.github.io/lec21.1-scene_setup.html](https://phys-sim-book.github.io/lec21.1-scene_setup.html)
- en: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
- en: To begin with, we set up a new scene with two squares falling onto the ground,
    compressed by the ceiling so that self-contact will occur between these squares.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置一个新的场景，其中有两个正方形落在地面上，被天花板压缩，使得这些正方形之间将发生自接触。
- en: '**Implementation 21.1.1 (Simulation setup, simulator.py).**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现21.1.1（模拟设置，simulator.py）。**'
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In line 17, we adapt the DOF index of the ceiling from (n*seg+1)∗(nseg+1) to
    (n*seg+1)∗(nseg+1)∗2, as we now have two squares. Line 26 generates the first
    square on the top, while lines 27 and 28 generate the second square on the bottom
    by creating copies and offsets.**
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在第17行，我们将天花板的自由度指数从(n*seg+1)∗(nseg+1)调整为(n*seg+1)∗(nseg+1)∗2，因为我们现在有两个正方形。第26行生成顶部的第一个正方形，而第27行和第28行通过创建副本和偏移量生成底部的第二个正方形。**
- en: '**The initial frame, as shown in [Figure 21.1.1](#fig:lec21:initial_frame),
    is now established. However, without handling self-contact, these two squares
    cannot interact with each other yet.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**如图[图21.1.1](#fig:lec21:initial_frame)所示，初始帧现在已经建立。然而，如果没有处理自接触，这两个正方形还不能相互交互。**'
- en: '![](../Images/72510f01c2f90ae7e3f433a71dfd3cf3.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/72510f01c2f90ae7e3f433a71dfd3cf3.png)'
- en: '**Figure 21.1.1.** The new scene setup with 2 squares to fall.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**图21.1.1。** 新的场景设置，有两个正方形要落下。'
- en: 'To handle contact, we first need to collect all boundary elements. In 2D, this
    involves identifying the nodes and edges on the boundary where contact forces
    will be applied to all close but non-incident point-edge pairs. The following
    function finds all boundary nodes and edges given a triangle mesh:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理接触，我们首先需要收集所有边界元素。在二维中，这涉及到识别边界上将要施加接触力的节点和边，这些力将作用于所有接近但非对角点-边对的边界节点和边。以下函数根据一个三角形网格找到所有边界节点和边：
- en: '**Implementation 21.1.2 (Collect boundary elements, square_mesh.py).**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现21.1.2（收集边界元素，square_mesh.py）。**'
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function is called in `simulator.py`, and the boundary elements are then
    passed to the time integrator for energy, gradient, and Hessian evaluations, as
    well as line search filtering.**
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在`simulator.py`中被调用，然后边界元素被传递给时间积分器进行能量、梯度、海森矩阵评估，以及线搜索过滤。**
