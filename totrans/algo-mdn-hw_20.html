<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Situational Optimizations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Situational Optimizations</h1>
<blockquote>原文：<a href="https://en.algorithmica.org/hpc/compilation/situational/">https://en.algorithmica.org/hpc/compilation/situational/</a></blockquote><div id="search"><input id="search-bar" type="search" placeholder="Search this book…" oninput="search()"/><div id="search-count"/><div id="search-results"/></div><header><div class="info"/></header><article><p>Most compiler optimizations enabled by <code>-O2</code> and <code>-O3</code> are guaranteed to either improve or at least not seriously hurt performance. Those that aren’t included in <code>-O3</code> are either not strictly standard-compliant, or highly circumstantial and require some additional input from the programmer to help decide whether using them is beneficial.</p><p>Let’s discuss the most frequently used ones that we’ve also previously covered in this book.</p><span class="anchor" id="loop-unrolling"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/compilation/situational/#loop-unrolling">#</a>Loop Unrolling</h3><p><a href="/hpc/architecture/loops#loop-unrolling">Loop unrolling</a> is disabled by default, unless the loop takes a small constant number of iterations known at compile time — in which case it will be replaced with a completely jump-free, repeated sequence of instructions. It can be enabled globally with the <code>-funroll-loops</code> flag, which will unroll all loops whose number of iterations can be determined at compile time or upon entry to the loop.</p><p>You can also use a pragma to target a specific loop:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#pragma GCC unroll 4
</span></span></span><span class="line"><span class="cl"><span class="cp"/><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"/><span class="p">}</span>
</span></span></code></pre></div><p>Loop unrolling makes binary larger, and may or may not make it run faster. Don’t use it fanatically.</p><span class="anchor" id="function-inlining"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/compilation/situational/#function-inlining">#</a>Function Inlining</h3><p><a href="/hpc/architecture/functions#inlining">Inlining</a> is best left for the compiler to decide, but you can influence it with <code>inline</code> keyword:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">square</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The hint may be ignored though if the compiler thinks that the potential performance gains are not worth it. You can force inlining by adding the <code>always_inline</code> attribute:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#define FORCE_INLINE inline __attribute__((always_inline))
</span></span></span></code></pre></div><p>There is also the <code>-finline-limit=n</code> option which lets you set a specific threshold on the size of inlined functions (in terms of the number of instructions). Its Clang equivalent is <code>-inline-threshold</code>.</p><span class="anchor" id="likeliness-of-branches"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/compilation/situational/#likeliness-of-branches">#</a>Likeliness of Branches</h3><p><a href="/hpc/architecture/layout#unequal-branches">Likeliness of branches</a> can be hinted by <code>[[likely]]</code> and <code>[[unlikely]]</code> attributes in <code>if</code>-s and <code>switch</code>-es:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="na">[[likely]]</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="na">[[unlikely]]</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This is a new feature that only appeared in C++20. Before that, there were compiler-specific intrinsics similarly used to wrap condition expressions. The same example in older GCC:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>There are many other cases like this when you need to point the compiler in the right direction, but we will get to them later when they become more relevant.</p><span class="anchor" id="profile-guided-optimization"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/compilation/situational/#profile-guided-optimization">#</a>Profile-Guided Optimization</h3><p>Adding all this metadata to the source code is tedious. People already hate writing C++ even without having to do it.</p><p>It is also not always obvious whether certain optimizations are beneficial or not. To make a decision about branch reordering, function inlining, or loop unrolling, we need answers to questions like these:</p><ul><li>How often is this branch taken?</li><li>How often is this function called?</li><li>What is the average number of iterations in this loop?</li></ul><p>Luckily for us, there is a way to provide this real-world information automatically.</p><p><em>Profile-guided optimization</em> (PGO, also called “pogo” because it’s easier and more fun to pronounce) is a technique that uses <a href="/hpc/profiling">profiling data</a> to improve performance beyond what can be achieved with just static analysis. In a nutshell, it involves adding timers and counters to the points of interest in the program, compiling and running it on real data, and then compiling it again, but this time supplying additional information from the test run.</p><p>The whole process is automated by modern compilers. For example, the <code>-fprofile-generate</code> flag will let GCC instrument the program with profiling code:</p><pre tabindex="0"><code>g++ -fprofile-generate [other flags] source.cc -o binary
</code></pre><p>After we run the program — preferably on input that is as representative of the real use case as possible — it will create a bunch of <code>*.gcda</code> files that contain log data for the test run, after which we can rebuild the program, but now adding the <code>-fprofile-use</code> flag:</p><pre tabindex="0"><code>g++ -fprofile-use [other flags] source.cc -o binary
</code></pre><p>It usually improves performance by 10-20% for large codebases, and for this reason it is commonly included in the build process of performance-critical projects. This is more reason to invest in solid benchmarking code.</p></article><div class="nextprev"><div class="left"><a href="https://en.algorithmica.org/hpc/compilation/flags/" id="prev-article">← Flags and Targets</a></div><div class="right"><a href="https://en.algorithmica.org/hpc/compilation/contracts/" id="next-article">Contract Programming →</a></div></div>    
</body>
</html>