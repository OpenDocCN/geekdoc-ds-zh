["```py\nfrom scipy.stats import multivariate_normal\n\ndef gmm2_pdf(X, Y, mean1, cov1, pi1, mean2, cov2, pi2):\n    xy = np.stack([X.flatten(), Y.flatten()], axis=-1)\n    Z1 = multivariate_normal.pdf(\n        xy, mean=mean1, cov=cov1).reshape(X.shape) \n    Z2 = multivariate_normal.pdf(\n        xy, mean=mean2, cov=cov2).reshape(X.shape) \n    return pi1 * Z1 + pi2 * Z2 \n```", "```py\nstart_point = 6\nstop_point = 6\nnum_samples = 100\npoints = np.linspace(-start_point, stop_point, num_samples)\nX, Y = np.meshgrid(points, points)\n\nmean1 = np.array([-2., -2.])\ncov1 = np.array([[1., 0.], [0., 1.]])\npi1 = 0.5\nmean2 = np.array([2., 2.])\ncov2 = np.array([[1.5 ** 2., -0.75 * 1.5 * 0.5], \n                 [-0.75 * 1.5 * 0.5, 0.5 ** 2.]])\npi2 = 0.5\nZ = gmm2_pdf(X, Y, mean1, cov1, pi1, mean2, cov2, pi2)\nmmids.make_surface_plot(X, Y, Z) \n```", "```py\ndef gmm2(rng, d, n, phi0, phi1, mu0, sigma0, mu1, sigma1):\n\n    phi = np.stack((phi0, phi1))\n    mu = np.stack((mu0, mu1))\n    sigma = np.stack((sigma0,sigma1))\n\n    X = np.zeros((n,d))\n    component = rng.choice(2, size=n, p=phi)\n    for i in range(n):\n        X[i,:] = rng.multivariate_normal(\n            mu[component[i],:],\n            sigma[component[i],:,:])\n\n    return X \n```", "```py\nd = 2\nsigma0 = np.outer(np.array([2., 2.]), np.array([2., 2.])) \nsigma0 += np.outer(np.array([-0.5, 0.5]), np.array([-0.5, 0.5]))\nsigma1 = 2 * np.identity(d)\nsigma = np.stack((sigma0,sigma1))\nprint(sigma[0,:,:]) \n```", "```py\n[[4.25 3.75]\n [3.75 4.25]] \n```", "```py\nprint(sigma[1,:,:]) \n```", "```py\n[[2\\. 0.]\n [0\\. 2.]] \n```", "```py\nseed = 535\nrng = np.random.default_rng(seed) \n\nn, w = 200, 5.\nphi0 = 0.8\nphi1 = 0.2\nmu0 = np.concatenate(([w], np.zeros(d-1)))\nmu1 = np.concatenate(([-w], np.zeros(d-1)))\nX = gmm2(rng, d, n, phi0, phi1, mu0, sigma0, mu1, sigma1)\n\nplt.scatter(X[:,0], X[:,1], s=5, marker='o', c='k')\nplt.axis('equal')\nplt.show() \n```", "```py\ndef responsibility(pi_k, p_km, x):\n\n    K = len(pi_k)\n    score_k = np.zeros(K)\n    for k in range(K):\n\n        score_k[k] -= np.log(pi_k[k])\n        score_k[k] -= np.sum(x * np.log(p_km[k,:]) \n                             + (1 - x) * np.log(1 - p_km[k,:]))\n    r_k = np.exp(-score_k)/(np.sum(np.exp(-score_k)))\n\n    return r_k\n\ndef update_parameters(eta_km, eta_k, eta, alpha, beta):\n\n    K = len(eta_k)\n    pi_k = (eta_k+alpha) / (eta+K*alpha)\n    p_km = (eta_km+beta) / (eta_k[:,np.newaxis]+2*beta)\n\n    return pi_k, p_km \n```", "```py\ndef em_bern(X, K, pi_0, p_0, maxiters = 10, alpha=0., beta=0.):\n\n    n, M = X.shape\n    pi_k = pi_0\n    p_km = p_0\n\n    for _ in range(maxiters):\n\n        # E Step\n        r_ki = np.zeros((K,n))\n        for i in range(n):\n            r_ki[:,i] = responsibility(pi_k, p_km, X[i,:])\n\n        # M Step \n        eta_km = np.zeros((K,M))\n        eta_k = np.sum(r_ki, axis=-1)\n        eta = np.sum(eta_k)\n        for k in range(K):\n            for m in range(M):\n                eta_km[k,m] = np.sum(X[:,m] * r_ki[k,:]) \n        pi_k, p_km = update_parameters(\n            eta_km, eta_k, eta, alpha, beta)\n\n    return pi_k, p_km \n```", "```py\nX = np.array([[1., 1., 1.],[1., 1., 1.],[1., 1., 1.],[1., 0., 1.],\n              [0., 1., 1.],[0., 0., 0.],[0., 0., 0.],[0., 0., 1.]])\nn, M = X.shape\nK = 2\npi_0 = np.ones(K)/K\np_0 = rng.random((K,M))\n\npi_k, p_km = em_bern(\n    X, K, pi_0, p_0, maxiters=100, alpha=0.01, beta=0.01)\n\nprint(pi_k) \n```", "```py\n[0.66500949 0.33499051] \n```", "```py\nprint(p_km) \n```", "```py\n[[0.74982646 0.74982646 0.99800266]\n [0.00496739 0.00496739 0.25487292]] \n```", "```py\nx_test = np.array([0., 0., 1.])\nprint(responsibility(pi_k, p_km, x_test)) \n```", "```py\n[0.32947702 0.67052298] \n```", "```py\nfrom torchvision import datasets, transforms\nfrom torch.utils.data import DataLoader\n\nmnist = datasets.MNIST(root='./data', train=True, \n                       download=True, transform=transforms.ToTensor())\ntrain_loader = DataLoader(mnist, batch_size=len(mnist), shuffle=False)\n\nimgs, labels = next(iter(train_loader))\nimgs = imgs.squeeze().numpy()\nlabels = labels.numpy() \n```", "```py\nimgs = np.round(imgs) \n```", "```py\nmask = labels == 2\nimgs2 = imgs[mask]\nlabels2 = labels[mask] \n```", "```py\nplt.imshow(imgs2[0], cmap='gray_r')\nplt.show() \n```", "```py\nX = imgs2.reshape(len(imgs2), -1) \n```", "```py\nn, M = X.shape\nK = 2\npi_0 = np.ones(K)/K\np_0 = rng.random((K,M))\n\npi_k, p_km = em_bern(\n    X, K, pi_0, p_0, maxiters=10, alpha=1., beta=1.)\n\nprint(pi_k) \n```", "```py\n[nan nan] \n```", "```py\nwarnings.resetwarnings()\nold_settings = np.seterr(all='warn')\n\npi_k, p_km = em_bern(\n    X, K, pi_0, p_0, maxiters=10, alpha=1., beta=1.) \n```", "```py\n/var/folders/k0/7k0fxl7j54q4k8dyqnrc6sz00000gr/T/ipykernel_84428/861379570.py:10: RuntimeWarning: underflow encountered in exp\n  r_k = np.exp(-score_k)/(np.sum(np.exp(-score_k)))\n/var/folders/k0/7k0fxl7j54q4k8dyqnrc6sz00000gr/T/ipykernel_84428/861379570.py:10: RuntimeWarning: invalid value encountered in divide\n  r_k = np.exp(-score_k)/(np.sum(np.exp(-score_k))) \n```", "```py\ndef log_sum_exp_trick(a):\n    min_val = np.min(a)\n    return - min_val + np.log(np.sum(np.exp(- a + min_val))) \n```", "```py\na = np.array([1000, 1001, 1002]) \n```", "```py\nnp.log(np.sum(np.exp(-a))) \n```", "```py\n/var/folders/k0/7k0fxl7j54q4k8dyqnrc6sz00000gr/T/ipykernel_84428/214275762.py:1: RuntimeWarning: underflow encountered in exp\n  np.log(np.sum(np.exp(-a)))\n/var/folders/k0/7k0fxl7j54q4k8dyqnrc6sz00000gr/T/ipykernel_84428/214275762.py:1: RuntimeWarning: divide by zero encountered in log\n  np.log(np.sum(np.exp(-a))) \n```", "```py\n-inf \n```", "```py\nlog_sum_exp_trick(a) \n```", "```py\n-999.5923940355556 \n```", "```py\ndef responsibility(pi_k, p_km, x):\n\n    K = len(pi_k)\n    score_k = np.zeros(K)\n    for k in range(K):\n\n        score_k[k] -= np.log(pi_k[k])\n        score_k[k] -= np.sum(x * np.log(p_km[k,:]) \n                             + (1 - x) * np.log(1 - p_km[k,:]))\n    r_k = np.exp(-score_k - log_sum_exp_trick(score_k))\n\n    return r_k \n```", "```py\npi_k, p_km = em_bern(X, K, pi_0, p_0, maxiters=10, alpha=1., beta=1.) \n```", "```py\nplt.figure()\nplt.imshow(p_km[0,:].reshape((28,28)))\nplt.show() \n```", "```py\nplt.figure()\nplt.imshow(p_km[1,:].reshape((28,28)))\nplt.show() \n```", "```py\nresponsibility(pi_k, p_km, X[0,:]) \n```", "```py\narray([1.00000000e+00, 5.09357087e-17]) \n```", "```py\nG = nx.DiGraph()\nG.add_node(\"X\", shape=\"circle\", style=\"filled\", fillcolor=\"gray\")\nG.add_node(\"C\", shape=\"circle\", style=\"filled\", fillcolor=\"white\")\nG.add_edge(\"C\", \"X\") \n```", "```py\nG = nx.DiGraph()\nG.add_node(\"X\", shape=\"circle\", style=\"filled\", fillcolor=\"white\")\nG.add_node(\"C\", shape=\"circle\", style=\"filled\", fillcolor=\"gray\")\nG.add_edge(\"C\", \"X\") \n```", "```py\nG = nx.DiGraph()\nG.add_node(\"X\", shape=\"circle\", style=\"filled\", fillcolor=\"gray\")\nG.add_node(\"C\", shape=\"circle\", style=\"filled\", fillcolor=\"gray\")\nG.add_edge(\"C\", \"X\") \n```", "```py\nG = nx.DiGraph()\nG.add_node(\"X\", shape=\"circle\", style=\"filled\", fillcolor=\"white\")\nG.add_node(\"C\", shape=\"circle\", style=\"filled\", fillcolor=\"white\")\nG.add_edge(\"C\", \"X\") \n```", "```py\nfrom scipy.stats import multivariate_normal\n\ndef gmm2_pdf(X, Y, mean1, cov1, pi1, mean2, cov2, pi2):\n    xy = np.stack([X.flatten(), Y.flatten()], axis=-1)\n    Z1 = multivariate_normal.pdf(\n        xy, mean=mean1, cov=cov1).reshape(X.shape) \n    Z2 = multivariate_normal.pdf(\n        xy, mean=mean2, cov=cov2).reshape(X.shape) \n    return pi1 * Z1 + pi2 * Z2 \n```", "```py\nstart_point = 6\nstop_point = 6\nnum_samples = 100\npoints = np.linspace(-start_point, stop_point, num_samples)\nX, Y = np.meshgrid(points, points)\n\nmean1 = np.array([-2., -2.])\ncov1 = np.array([[1., 0.], [0., 1.]])\npi1 = 0.5\nmean2 = np.array([2., 2.])\ncov2 = np.array([[1.5 ** 2., -0.75 * 1.5 * 0.5], \n                 [-0.75 * 1.5 * 0.5, 0.5 ** 2.]])\npi2 = 0.5\nZ = gmm2_pdf(X, Y, mean1, cov1, pi1, mean2, cov2, pi2)\nmmids.make_surface_plot(X, Y, Z) \n```", "```py\ndef gmm2(rng, d, n, phi0, phi1, mu0, sigma0, mu1, sigma1):\n\n    phi = np.stack((phi0, phi1))\n    mu = np.stack((mu0, mu1))\n    sigma = np.stack((sigma0,sigma1))\n\n    X = np.zeros((n,d))\n    component = rng.choice(2, size=n, p=phi)\n    for i in range(n):\n        X[i,:] = rng.multivariate_normal(\n            mu[component[i],:],\n            sigma[component[i],:,:])\n\n    return X \n```", "```py\nd = 2\nsigma0 = np.outer(np.array([2., 2.]), np.array([2., 2.])) \nsigma0 += np.outer(np.array([-0.5, 0.5]), np.array([-0.5, 0.5]))\nsigma1 = 2 * np.identity(d)\nsigma = np.stack((sigma0,sigma1))\nprint(sigma[0,:,:]) \n```", "```py\n[[4.25 3.75]\n [3.75 4.25]] \n```", "```py\nprint(sigma[1,:,:]) \n```", "```py\n[[2\\. 0.]\n [0\\. 2.]] \n```", "```py\nseed = 535\nrng = np.random.default_rng(seed) \n\nn, w = 200, 5.\nphi0 = 0.8\nphi1 = 0.2\nmu0 = np.concatenate(([w], np.zeros(d-1)))\nmu1 = np.concatenate(([-w], np.zeros(d-1)))\nX = gmm2(rng, d, n, phi0, phi1, mu0, sigma0, mu1, sigma1)\n\nplt.scatter(X[:,0], X[:,1], s=5, marker='o', c='k')\nplt.axis('equal')\nplt.show() \n```", "```py\ndef responsibility(pi_k, p_km, x):\n\n    K = len(pi_k)\n    score_k = np.zeros(K)\n    for k in range(K):\n\n        score_k[k] -= np.log(pi_k[k])\n        score_k[k] -= np.sum(x * np.log(p_km[k,:]) \n                             + (1 - x) * np.log(1 - p_km[k,:]))\n    r_k = np.exp(-score_k)/(np.sum(np.exp(-score_k)))\n\n    return r_k\n\ndef update_parameters(eta_km, eta_k, eta, alpha, beta):\n\n    K = len(eta_k)\n    pi_k = (eta_k+alpha) / (eta+K*alpha)\n    p_km = (eta_km+beta) / (eta_k[:,np.newaxis]+2*beta)\n\n    return pi_k, p_km \n```", "```py\ndef em_bern(X, K, pi_0, p_0, maxiters = 10, alpha=0., beta=0.):\n\n    n, M = X.shape\n    pi_k = pi_0\n    p_km = p_0\n\n    for _ in range(maxiters):\n\n        # E Step\n        r_ki = np.zeros((K,n))\n        for i in range(n):\n            r_ki[:,i] = responsibility(pi_k, p_km, X[i,:])\n\n        # M Step \n        eta_km = np.zeros((K,M))\n        eta_k = np.sum(r_ki, axis=-1)\n        eta = np.sum(eta_k)\n        for k in range(K):\n            for m in range(M):\n                eta_km[k,m] = np.sum(X[:,m] * r_ki[k,:]) \n        pi_k, p_km = update_parameters(\n            eta_km, eta_k, eta, alpha, beta)\n\n    return pi_k, p_km \n```", "```py\nX = np.array([[1., 1., 1.],[1., 1., 1.],[1., 1., 1.],[1., 0., 1.],\n              [0., 1., 1.],[0., 0., 0.],[0., 0., 0.],[0., 0., 1.]])\nn, M = X.shape\nK = 2\npi_0 = np.ones(K)/K\np_0 = rng.random((K,M))\n\npi_k, p_km = em_bern(\n    X, K, pi_0, p_0, maxiters=100, alpha=0.01, beta=0.01)\n\nprint(pi_k) \n```", "```py\n[0.66500949 0.33499051] \n```", "```py\nprint(p_km) \n```", "```py\n[[0.74982646 0.74982646 0.99800266]\n [0.00496739 0.00496739 0.25487292]] \n```", "```py\nx_test = np.array([0., 0., 1.])\nprint(responsibility(pi_k, p_km, x_test)) \n```", "```py\n[0.32947702 0.67052298] \n```", "```py\nfrom torchvision import datasets, transforms\nfrom torch.utils.data import DataLoader\n\nmnist = datasets.MNIST(root='./data', train=True, \n                       download=True, transform=transforms.ToTensor())\ntrain_loader = DataLoader(mnist, batch_size=len(mnist), shuffle=False)\n\nimgs, labels = next(iter(train_loader))\nimgs = imgs.squeeze().numpy()\nlabels = labels.numpy() \n```", "```py\nimgs = np.round(imgs) \n```", "```py\nmask = labels == 2\nimgs2 = imgs[mask]\nlabels2 = labels[mask] \n```", "```py\nplt.imshow(imgs2[0], cmap='gray_r')\nplt.show() \n```", "```py\nX = imgs2.reshape(len(imgs2), -1) \n```", "```py\nn, M = X.shape\nK = 2\npi_0 = np.ones(K)/K\np_0 = rng.random((K,M))\n\npi_k, p_km = em_bern(\n    X, K, pi_0, p_0, maxiters=10, alpha=1., beta=1.)\n\nprint(pi_k) \n```", "```py\n[nan nan] \n```", "```py\nwarnings.resetwarnings()\nold_settings = np.seterr(all='warn')\n\npi_k, p_km = em_bern(\n    X, K, pi_0, p_0, maxiters=10, alpha=1., beta=1.) \n```", "```py\n/var/folders/k0/7k0fxl7j54q4k8dyqnrc6sz00000gr/T/ipykernel_84428/861379570.py:10: RuntimeWarning: underflow encountered in exp\n  r_k = np.exp(-score_k)/(np.sum(np.exp(-score_k)))\n/var/folders/k0/7k0fxl7j54q4k8dyqnrc6sz00000gr/T/ipykernel_84428/861379570.py:10: RuntimeWarning: invalid value encountered in divide\n  r_k = np.exp(-score_k)/(np.sum(np.exp(-score_k))) \n```", "```py\ndef log_sum_exp_trick(a):\n    min_val = np.min(a)\n    return - min_val + np.log(np.sum(np.exp(- a + min_val))) \n```", "```py\na = np.array([1000, 1001, 1002]) \n```", "```py\nnp.log(np.sum(np.exp(-a))) \n```", "```py\n/var/folders/k0/7k0fxl7j54q4k8dyqnrc6sz00000gr/T/ipykernel_84428/214275762.py:1: RuntimeWarning: underflow encountered in exp\n  np.log(np.sum(np.exp(-a)))\n/var/folders/k0/7k0fxl7j54q4k8dyqnrc6sz00000gr/T/ipykernel_84428/214275762.py:1: RuntimeWarning: divide by zero encountered in log\n  np.log(np.sum(np.exp(-a))) \n```", "```py\n-inf \n```", "```py\nlog_sum_exp_trick(a) \n```", "```py\n-999.5923940355556 \n```", "```py\ndef responsibility(pi_k, p_km, x):\n\n    K = len(pi_k)\n    score_k = np.zeros(K)\n    for k in range(K):\n\n        score_k[k] -= np.log(pi_k[k])\n        score_k[k] -= np.sum(x * np.log(p_km[k,:]) \n                             + (1 - x) * np.log(1 - p_km[k,:]))\n    r_k = np.exp(-score_k - log_sum_exp_trick(score_k))\n\n    return r_k \n```", "```py\npi_k, p_km = em_bern(X, K, pi_0, p_0, maxiters=10, alpha=1., beta=1.) \n```", "```py\nplt.figure()\nplt.imshow(p_km[0,:].reshape((28,28)))\nplt.show() \n```", "```py\nplt.figure()\nplt.imshow(p_km[1,:].reshape((28,28)))\nplt.show() \n```", "```py\nresponsibility(pi_k, p_km, X[0,:]) \n```", "```py\narray([1.00000000e+00, 5.09357087e-17]) \n```", "```py\nG = nx.DiGraph()\nG.add_node(\"X\", shape=\"circle\", style=\"filled\", fillcolor=\"gray\")\nG.add_node(\"C\", shape=\"circle\", style=\"filled\", fillcolor=\"white\")\nG.add_edge(\"C\", \"X\") \n```", "```py\nG = nx.DiGraph()\nG.add_node(\"X\", shape=\"circle\", style=\"filled\", fillcolor=\"white\")\nG.add_node(\"C\", shape=\"circle\", style=\"filled\", fillcolor=\"gray\")\nG.add_edge(\"C\", \"X\") \n```", "```py\nG = nx.DiGraph()\nG.add_node(\"X\", shape=\"circle\", style=\"filled\", fillcolor=\"gray\")\nG.add_node(\"C\", shape=\"circle\", style=\"filled\", fillcolor=\"gray\")\nG.add_edge(\"C\", \"X\") \n```", "```py\nG = nx.DiGraph()\nG.add_node(\"X\", shape=\"circle\", style=\"filled\", fillcolor=\"white\")\nG.add_node(\"C\", shape=\"circle\", style=\"filled\", fillcolor=\"white\")\nG.add_edge(\"C\", \"X\") \n```"]