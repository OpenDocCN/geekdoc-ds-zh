<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Chapter 9 Input and Output</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Chapter 9 Input and Output</h1>
<blockquote>原文：<a href="https://randpythonbook.netlify.app/input-and-output">https://randpythonbook.netlify.app/input-and-output</a></blockquote>
<div id="input-and-output" class="section level1 hasAnchor">

<div id="general-input-considerations" class="section level2 hasAnchor">
<h2><span class="header-section-number">9.1</span> General Input Considerations<a aria-label="Anchor link to header" class="anchor-section" href="/input-and-output#general-input-considerations"/></h2>
<p>So far, this text has been favoring the creation of small pieces of data <em>within our scripts.</em> The avoidance of reading in data from an external file has been avoided primarily for pedagogical purposes. In general, one might have</p>
<ul>
<li>data read in from a plain text file (e.g. <code>"my_data.csv"</code> or <code>"log_file.txt"</code> ),</li>
<li>data read in from a database (e.g. MySQL, PostgreSQL, etc.), or</li>
<li>data created in a script (either deterministically or randomly).</li>
</ul>
<p>When discussing reading in data, this text mostly focuses on the first category. Here are the reasons for its doing so:</p>
<ol style="list-style-type: decimal">
<li>text-files are more readily-available to students than databases,</li>
<li>teaching the second category requires teaching SQL, and that would introduce conceptual overlap, and</li>
<li>the third category is programmatically self-explanatory.</li>
</ol>
<div class="rmd-details">
<p>The third reason does not imply data created by code is unimportant. For example, it is the most common approach to create data used in <strong>simulation studies.</strong> Authors writing statistical papers need to demonstrate that their techniques work on “nice” data: data simulated from a <em>known</em> data-generating process. In a simulation study, unlike in the “real-world,” you have access to the parameters generating your data, and you can examine data that might otherwise be unobserved or hidden. Further, with data from the real-world, there is no guarantee your model correctly matches the true model.</p>
<p>Can your code/technique/algorithm, at the very least, obtain parameter estimates that are “in-line” with the parameters your code is using to simulate data? Are forecasts or predictions obtained by your method accurate? These kinds of questions can often only be answered by simulating fake data. Programmatically, simulating data like this largely involves calling functions that we have seen before (e.g. <code>rnorm()</code> in R or <code>np.random.choice()</code> in Python). This may or may not involve setting a pseudorandom number seed, first, for reproducibility.</p>
<p>Also, <em>benchmark data sets</em> are often readily available through specialized function calls.</p>
</div>
<p>Even though this chapter is written to teach you how to read in files into R and Python, you should not expect that you will know how to read in <em>all</em> data sets after reading this section. For both R and Python, there are an enormous amount of functions, different functions have different return types, different functions are suited for different file types, many functions are spread across a plethora of third party libraries, and many of these functions have an enormous amount of arguments. You will probably not be able to memorize everything. In my very humble opinion, I doubt you should want to.</p>
<p>Instead, <strong>focus on developing your ability to identify and diagnose data input problems.</strong> Reading in a data set correctly is often a process of trial-and-error. After attempting to read in a data set, always check the following items. Many of these points were previously mentioned in section @(data-frames-in-r). Some apply to reading in text data more than reading in structured data from a database, and vice versa.</p>
<ol style="list-style-type: decimal">
<li>Check that <strong>the correct column <em>separator</em> was used, or the correct “fixed-width format” was expected.</strong> If mistakes are made, data frame columns are going to be combined or split apart in weird ways, and often the wrong types are going to be used for pieces of data (e.g. <code>"2,3"</code> instead of <code>2</code> and <code>3</code>.) Also, watch out for when separators are found inside data elements or column names. For example, sometimes it’s unclear whether people’s names in the “last, first” format can be stored in one or two columns. Also, text data might surprise you with unexpected spaces or other whitespace is a common separator.</li>
<li>Check that <strong>the column names were parsed and stored correctly.</strong> Column names should not be stored as data in R/Python. Functions that read in data should not expect column names when they don’t exist in the actual file.</li>
<li>Check that <strong>empty space and metadata was ignored correctly.</strong> Data descriptions are sometimes stored in the same file as the data itself, and that should be skipped over when it’s being read in. Empty space between column names and data shouldn’t be stored. This can occur at the beginning of the file, and even at the end of the file.</li>
<li><strong>Check that type choice and recognition of special characters are performed correctly.</strong> Are letters stored as strings or as something else such as an R <code>factor</code>? Are dates and times stored as a special date/time type, or as strings? Is missing data correctly identified? Sometimes data providers use outrageous numbers like <span class="math inline">\(-9999\)</span> to represent missing data–don’t store that as a float or integer!</li>
<li><strong>Be ready to prompt R or Python to recognize a specific character encoding if you are reading in text data written in another language.</strong> All text data has a character encoding, which is a mapping of numbers to characters. Any specific encoding will dictate what characters are recognizable in a program. If you try to read in data written in another language, the function you are using will likely complain about unrecognized characters. Fortunately, these errors and warnings are easily fixed by specifying a nondefault argument such as <code>encoding=</code> or <code>fileEncoding=</code>.</li>
</ol>
<p>This is no small task. To make matters worse:</p>
<ul>
<li><p>you can’t (or shouldn’t) edit the raw data to suit your needs, to make it easier to read in. You have to work with what you are given. If you were allowed to edit, say, a text file you downloaded onto your own machine, you shouldn’t–it will lead to code that doesn’t run anywhere else. Additionally, if you abuse write privileges on your company’s database, for example–that could be very dangerous as well.</p></li>
<li><p>Data sets are often quite large, so manually checking each element is often impossible. In this situation you will have to resign yourself to checking the top and bottom of a data set, or maybe anticipate a specific place where problems are likely to appear.</p></li>
</ul>
</div>
<div id="reading-in-text-files-with-r" class="section level2 hasAnchor">
<h2><span class="header-section-number">9.2</span> Reading in Text Files with R<a aria-label="Anchor link to header" class="anchor-section" href="/input-and-output#reading-in-text-files-with-r"/></h2>
<p>You’ve seen examples of <code>read.csv()</code> used earlier in the book, so it should not surprise you that this is one of the most common ways to read in data in R. Another important function is <code>read.table()</code>.</p>
<p>If you look at the source code for <code>read.csv()</code> (type the name of the function without parentheses into the console and press the <code>&lt;Enter&gt;</code> key), you will see it calls <code>read.table()</code>. The primary difference between these functions is default arguments. <strong>Mind the default arguments.</strong> Do not be completely averse to writing a long-line of code to read in a data set correctly. Or do, and choose the function with the best default arguments.</p>
<p>Consider the <a href="https://archive.ics.uci.edu/ml/datasets/Challenger+USA+Space+Shuttle+O-Ring">“Challenger USA Space Shuttle O-Ring Data Set”</a> from <span class="citation">(Dua and Graff <a href="#ref-uci_data">2017</a>)</span>. The first few rows of the raw text file<a href="#fn14" class="footnote-ref" id="fnref14"><sup>14</sup></a> looks like this.</p>
<pre><code>6 0 66  50  1
6 1 70  50  2
6 0 69  50  3</code></pre>
<p>It does not use commas as separators, and there is no header information, so <code>read.csv()</code> used with its default arguments will produce an incorrect result. It will miss the first row by counting it as a column name, and store everything in one column with the wrong type.</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb146-1" title="1">d &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">"data/o-ring-erosion-only.data"</span>)</a>
<a class="sourceLine" id="cb146-2" title="2"><span class="kw">dim</span>(d) <span class="co"># one row short, only 1 col</span></a>
<a class="sourceLine" id="cb146-3" title="3"><span class="co">## [1] 22  1</span></a>
<a class="sourceLine" id="cb146-4" title="4"><span class="kw">typeof</span>(d[,<span class="dv">1</span>])</a>
<a class="sourceLine" id="cb146-5" title="5"><span class="co">## [1] "character"</span></a></code></pre></div>
<p>Specifying <code>header=FALSE</code> fixes the column name issue, but <code>sep = " "</code> does not fix the separator issue.</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb147-1" title="1">d &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">"data/o-ring-erosion-only.data"</span>, </a>
<a class="sourceLine" id="cb147-2" title="2">              <span class="dt">header=</span><span class="ot">FALSE</span>, <span class="dt">sep =</span> <span class="st">" "</span>)</a>
<a class="sourceLine" id="cb147-3" title="3"><span class="kw">str</span>(d)</a>
<a class="sourceLine" id="cb147-4" title="4"><span class="co">## 'data.frame':    23 obs. of  7 variables:</span></a>
<a class="sourceLine" id="cb147-5" title="5"><span class="co">##  $ V1: int  6 6 6 6 6 6 6 6 6 6 ...</span></a>
<a class="sourceLine" id="cb147-6" title="6"><span class="co">##  $ V2: int  0 1 0 0 0 0 0 0 1 1 ...</span></a>
<a class="sourceLine" id="cb147-7" title="7"><span class="co">##  $ V3: int  66 70 69 68 67 72 73 70 57 63 ...</span></a>
<a class="sourceLine" id="cb147-8" title="8"><span class="co">##  $ V4: int  NA NA NA NA NA NA 100 100 200 200 ...</span></a>
<a class="sourceLine" id="cb147-9" title="9"><span class="co">##  $ V5: int  50 50 50 50 50 50 NA NA NA 10 ...</span></a>
<a class="sourceLine" id="cb147-10" title="10"><span class="co">##  $ V6: int  NA NA NA NA NA NA 7 8 9 NA ...</span></a>
<a class="sourceLine" id="cb147-11" title="11"><span class="co">##  $ V7: int  1 2 3 4 5 6 NA NA NA NA ...</span></a></code></pre></div>
<p>One space is strictly one space. Some rows have two, though. This causes there to be two too many columns filled with <code>NA</code>s.</p>
<p>After digging into the documentation a bit further, you will notice that <code>""</code> works for “one or more spaces, tabs, newlines or carriage returns.” This is why <code>read.table()</code>, with its default arguments, works well.</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb148-1" title="1">d &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">"data/o-ring-erosion-only.data"</span>)</a>
<a class="sourceLine" id="cb148-2" title="2"><span class="kw">str</span>(d)</a>
<a class="sourceLine" id="cb148-3" title="3"><span class="co">## 'data.frame':    23 obs. of  5 variables:</span></a>
<a class="sourceLine" id="cb148-4" title="4"><span class="co">##  $ V1: int  6 6 6 6 6 6 6 6 6 6 ...</span></a>
<a class="sourceLine" id="cb148-5" title="5"><span class="co">##  $ V2: int  0 1 0 0 0 0 0 0 1 1 ...</span></a>
<a class="sourceLine" id="cb148-6" title="6"><span class="co">##  $ V3: int  66 70 69 68 67 72 73 70 57 63 ...</span></a>
<a class="sourceLine" id="cb148-7" title="7"><span class="co">##  $ V4: int  50 50 50 50 50 50 100 100 200 200 ...</span></a>
<a class="sourceLine" id="cb148-8" title="8"><span class="co">##  $ V5: int  1 2 3 4 5 6 7 8 9 10 ...</span></a></code></pre></div>
<p>This data set has columns whose widths are “fixed”, too. It is in “fixed width format” because any given column has all its elements take up a constant amount of characters. The third column has integers with two or three digits, but no matter what, each row has the same number of characters.</p>
<p>You may choose to exploit this and use a specialized function that reads in data in a fixed width format (e.g. <code>read.fwf()</code>). The frustrating thing about this approach, though, is that you have to specify what those widths are. This can be quite tedious, particularly if your data set has many columns and/or many rows. The upside though, is that the files can be a little bit smaller, because the data provider does not have to waste characters on separators.</p>
<p>In the example below, we specify widths that include blank spaces to the left of the digits. On the other hand, if we specified <code>widths=c(2,2,4,4,1)</code>, which includes spaces to the <em>right</em> of digits, then columns would have been recognized as <code>character</code>s.</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb149-1" title="1">d &lt;-<span class="st"> </span><span class="kw">read.fwf</span>(<span class="st">"data/o-ring-erosion-only.data"</span>, </a>
<a class="sourceLine" id="cb149-2" title="2">              <span class="dt">widths =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">3</span>)) <span class="co"># or try c(2,2,4,4,1)</span></a>
<a class="sourceLine" id="cb149-3" title="3"><span class="kw">str</span>(d)</a>
<a class="sourceLine" id="cb149-4" title="4"><span class="co">## 'data.frame':    23 obs. of  5 variables:</span></a>
<a class="sourceLine" id="cb149-5" title="5"><span class="co">##  $ V1: int  6 6 6 6 6 6 6 6 6 6 ...</span></a>
<a class="sourceLine" id="cb149-6" title="6"><span class="co">##  $ V2: int  0 1 0 0 0 0 0 0 1 1 ...</span></a>
<a class="sourceLine" id="cb149-7" title="7"><span class="co">##  $ V3: int  66 70 69 68 67 72 73 70 57 63 ...</span></a>
<a class="sourceLine" id="cb149-8" title="8"><span class="co">##  $ V4: int  50 50 50 50 50 50 100 100 200 200 ...</span></a>
<a class="sourceLine" id="cb149-9" title="9"><span class="co">##  $ V5: int  1 2 3 4 5 6 7 8 9 10 ...</span></a></code></pre></div>
<p>If you need to read in some text data that does not possess a tabular structure, then you may need <code>readLines()</code>. This function will read in all of the text, separate each line into an element of a <code>character</code> <code>vector</code>, and will not make any attempt to parse lines into columns. Further processing can be accomplished using the techniques from section <a href="/r-vectors-versus-numpy-arrays-and-pandas-series#an-introduction-to-regular-expressions">3.9</a>.</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb150-1" title="1">html_data &lt;-<span class="st"> </span><span class="kw">readLines</span>(<span class="st">"data/Google.html"</span>, <span class="dt">warn =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb150-2" title="2"><span class="kw">head</span>(html_data, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb150-3" title="3"><span class="co">## [1] "&lt;!DOCTYPE html&gt;"</span></a></code></pre></div>
<p>Some of you may have had difficulty reading in the above data. This can happen if your machine’s default character encoding is different than mine. For instance, if your character encoding is <a href="https://en.wikipedia.org/wiki/GBK_(character_encoding)">“GBK”</a>, then you might get a warning message like “invalid input found on input connection.” This message means that your machine didn’t recognize some of the characters in the data set.</p>
<p>These errors are easy to fix, though, so don’t worry. Just specify an encoding argument in your function that reads in data.</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb151-1" title="1">tmp &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">"data/Google.html"</span>, <span class="dt">sep =</span> <span class="st">"~"</span>, </a>
<a class="sourceLine" id="cb151-2" title="2">                  <span class="dt">fileEncoding =</span> <span class="st">"UTF-8"</span>) <span class="co"># makes errors disappear</span></a></code></pre></div>
</div>
<div id="reading-in-text-files-with-pandas" class="section level2 hasAnchor">
<h2><span class="header-section-number">9.3</span> Reading in Text Files with Pandas<a aria-label="Anchor link to header" class="anchor-section" href="/input-and-output#reading-in-text-files-with-pandas"/></h2>
<p>A <a href="https://pandas.pydata.org/pandas-docs/stable/reference/io.html">wide variety of different file formats can be read in with Pandas.</a> I will only mention a few functions here.</p>
<p>Recall R has <code>read.table()</code> and <code>read.csv()</code>, and that they are very similar. In Pandas, <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html"><code>pd.read_csv()</code></a> and <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_table.html"><code>pd.read_table()</code></a> have a lot in common, too. Their primary difference is the default column separator, as well.</p>
<p>Recall the O-Ring data from above. The columns are <em>not</em> separated by commas, so if we treat it as a comma-separated file, the resulting Pandas <code>DataFrame</code> is going to be missing all but one of its columns.</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb152-1" title="1"><span class="im">import</span> pandas <span class="im">as</span> pd</a>
<a class="sourceLine" id="cb152-2" title="2">d <span class="op">=</span> pd.read_csv(<span class="st">"data/o-ring-erosion-only.data"</span>)</a>
<a class="sourceLine" id="cb152-3" title="3">d.shape <span class="co"># one column and missing a row</span></a>
<a class="sourceLine" id="cb152-4" title="4"><span class="co">## (22, 1)</span></a>
<a class="sourceLine" id="cb152-5" title="5">d.columns <span class="co"># column labels are data</span></a>
<a class="sourceLine" id="cb152-6" title="6"><span class="co">## Index(['6 0 66  50  1'], dtype='object')</span></a></code></pre></div>
<p>By default, <code>pd.read_csv()</code> is expecting column labels, which is also a problem. Unlike R, though, the <code>header=</code> argument is not expected to be a Boolean. You will need to provide a <code>None</code>, instead. The separator needs to be just right, too.</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb153-1" title="1">pd.read_csv(<span class="st">"data/o-ring-erosion-only.data"</span>, </a>
<a class="sourceLine" id="cb153-2" title="2">              header<span class="op">=</span><span class="va">None</span>, sep <span class="op">=</span> <span class="st">" "</span>).head(<span class="dv">2</span>) <span class="co"># 1 space: no</span></a>
<a class="sourceLine" id="cb153-3" title="3"><span class="co">##    0  1   2   3     4   5    6</span></a>
<a class="sourceLine" id="cb153-4" title="4"><span class="co">## 0  6  0  66 NaN  50.0 NaN  1.0</span></a>
<a class="sourceLine" id="cb153-5" title="5"><span class="co">## 1  6  1  70 NaN  50.0 NaN  2.0</span></a>
<a class="sourceLine" id="cb153-6" title="6">pd.read_csv(<span class="st">"data/o-ring-erosion-only.data"</span>, </a>
<a class="sourceLine" id="cb153-7" title="7">              header<span class="op">=</span><span class="va">None</span>, sep <span class="op">=</span> <span class="st">"</span><span class="ch">\t</span><span class="st">"</span>).head(<span class="dv">2</span>) <span class="co"># tabs: no</span></a>
<a class="sourceLine" id="cb153-8" title="8"><span class="co">##                0</span></a>
<a class="sourceLine" id="cb153-9" title="9"><span class="co">## 0  6 0 66  50  1</span></a>
<a class="sourceLine" id="cb153-10" title="10"><span class="co">## 1  6 1 70  50  2</span></a>
<a class="sourceLine" id="cb153-11" title="11">pd.read_table(<span class="st">"data/o-ring-erosion-only.data"</span>, </a>
<a class="sourceLine" id="cb153-12" title="12">              header<span class="op">=</span><span class="va">None</span>).head(<span class="dv">2</span>) <span class="co"># default sep is tabs, so no</span></a>
<a class="sourceLine" id="cb153-13" title="13"><span class="co">##                0</span></a>
<a class="sourceLine" id="cb153-14" title="14"><span class="co">## 0  6 0 66  50  1</span></a>
<a class="sourceLine" id="cb153-15" title="15"><span class="co">## 1  6 1 70  50  2</span></a>
<a class="sourceLine" id="cb153-16" title="16">pd.read_csv(<span class="st">"data/o-ring-erosion-only.data"</span>, </a>
<a class="sourceLine" id="cb153-17" title="17">              header<span class="op">=</span><span class="va">None</span>, sep <span class="op">=</span> <span class="st">"\s+"</span>).head(<span class="dv">2</span>) <span class="co"># 1 or more spaces: yes</span></a>
<a class="sourceLine" id="cb153-18" title="18"><span class="co">##    0  1   2   3  4</span></a>
<a class="sourceLine" id="cb153-19" title="19"><span class="co">## 0  6  0  66  50  1</span></a>
<a class="sourceLine" id="cb153-20" title="20"><span class="co">## 1  6  1  70  50  2</span></a></code></pre></div>
<p>Reading in fixed width files can be done in a way that is nearly identical to the way we did it in R. Here is an example.</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb154-1" title="1">d <span class="op">=</span> pd.read_fwf(<span class="st">"data/o-ring-erosion-only.data"</span>, </a>
<a class="sourceLine" id="cb154-2" title="2">                widths <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">3</span>], header<span class="op">=</span><span class="va">None</span>) <span class="co"># try [2,2,4,4,1]</span></a>
<a class="sourceLine" id="cb154-3" title="3">d.info()</a>
<a class="sourceLine" id="cb154-4" title="4"><span class="co">## &lt;class 'pandas.core.frame.DataFrame'&gt;</span></a>
<a class="sourceLine" id="cb154-5" title="5"><span class="co">## RangeIndex: 23 entries, 0 to 22</span></a>
<a class="sourceLine" id="cb154-6" title="6"><span class="co">## Data columns (total 5 columns):</span></a>
<a class="sourceLine" id="cb154-7" title="7"><span class="co">##  #   Column  Non-Null Count  Dtype</span></a>
<a class="sourceLine" id="cb154-8" title="8"><span class="co">## ---  ------  --------------  -----</span></a>
<a class="sourceLine" id="cb154-9" title="9"><span class="co">##  0   0       23 non-null     int64</span></a>
<a class="sourceLine" id="cb154-10" title="10"><span class="co">##  1   1       23 non-null     int64</span></a>
<a class="sourceLine" id="cb154-11" title="11"><span class="co">##  2   2       23 non-null     int64</span></a>
<a class="sourceLine" id="cb154-12" title="12"><span class="co">##  3   3       23 non-null     int64</span></a>
<a class="sourceLine" id="cb154-13" title="13"><span class="co">##  4   4       23 non-null     int64</span></a>
<a class="sourceLine" id="cb154-14" title="14"><span class="co">## dtypes: int64(5)</span></a>
<a class="sourceLine" id="cb154-15" title="15"><span class="co">## memory usage: 1.0 KB</span></a></code></pre></div>
<p>If you had chosen <code>widths=[2,2,4,4,1]</code>, instead, then the trailing whitespace will cause Pandas to recognize a <code>dtype</code> of <code>object</code>. The reason it is not recognized as a string is because strings can be of different length, and all string types specify a maximum length. If you want to enforce a maximum length, there may be some speed advantages. In the below example, we use <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.astype.html"><code>d.astype()</code></a> to convert two columns’ types to <a href="https://pandas.pydata.org/docs/reference/api/pandas.StringDtype.html#pandas.StringDtype"><code>pd.StringDtype</code></a>.</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb155-1" title="1">d <span class="op">=</span> pd.read_fwf(<span class="st">"data/o-ring-erosion-only.data"</span>, </a>
<a class="sourceLine" id="cb155-2" title="2">                  widths <span class="op">=</span> [<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">1</span>], header<span class="op">=</span><span class="va">None</span>)</a>
<a class="sourceLine" id="cb155-3" title="3"><span class="bu">list</span>(d.dtypes)[:<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb155-4" title="4"><span class="co">## [dtype('int64'), dtype('int64'), dtype('O'), dtype('O')]</span></a>
<a class="sourceLine" id="cb155-5" title="5">d <span class="op">=</span> d.astype({<span class="dv">2</span>:<span class="st">'string'</span>, <span class="dv">3</span>:<span class="st">'string'</span>}) </a>
<a class="sourceLine" id="cb155-6" title="6"><span class="bu">list</span>(d.dtypes)[:<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb155-7" title="7"><span class="co">## [dtype('int64'), dtype('int64'), StringDtype, StringDtype]</span></a></code></pre></div>
<p>Just like in R, you may run into an encoding issue with a file. For instance, the following will not work because the file contains Chinese characters. If you mostly work with UTF-8 files, you will receive a <code>UnicodeDecodeError</code> if you try to run the following code.</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb156-1" title="1">pd.read_csv(<span class="st">"data/message.txt"</span>)</a></code></pre></div>
<p>However, the error messages disappear when you specify <code>encoding="gbk"</code>.<a href="#fn15" class="footnote-ref" id="fnref15"><sup>15</sup></a></p>
<div class="sourceCode" id="cb157"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb157-1" title="1">pd.read_csv(<span class="st">"data/message.txt"</span>, encoding <span class="op">=</span> <span class="st">"gbk"</span>)</a>
<a class="sourceLine" id="cb157-2" title="2"><span class="co">## Empty DataFrame</span></a>
<a class="sourceLine" id="cb157-3" title="3"><span class="co">## Columns: [恭喜发财]</span></a>
<a class="sourceLine" id="cb157-4" title="4"><span class="co">## Index: []</span></a></code></pre></div>
<p>You may also read in unstructured, nontabular data with Python. Use the built-in <a href="https://docs.python.org/3/library/functions.html#open"><code>open()</code></a> function to open up a file in read mode, and then use <code>f.readlines()</code> to return a <code>list</code> of strings.</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb158-1" title="1">f <span class="op">=</span> <span class="bu">open</span>(<span class="st">"data/Google.html"</span>, <span class="st">"r"</span>)</a>
<a class="sourceLine" id="cb158-2" title="2">d <span class="op">=</span> f.readlines()</a>
<a class="sourceLine" id="cb158-3" title="3">d[:<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb158-4" title="4"><span class="co">## ['&lt;!DOCTYPE html&gt;\n']</span></a>
<a class="sourceLine" id="cb158-5" title="5"><span class="bu">print</span>(<span class="bu">type</span>(d), <span class="bu">type</span>(d[<span class="dv">0</span>]))</a>
<a class="sourceLine" id="cb158-6" title="6"><span class="co">## &lt;class 'list'&gt; &lt;class 'str'&gt;</span></a></code></pre></div>
</div>
<div id="saving-data-in-r" class="section level2 hasAnchor">
<h2><span class="header-section-number">9.4</span> Saving Data in R<a aria-label="Anchor link to header" class="anchor-section" href="/input-and-output#saving-data-in-r"/></h2>
<p>Storing data is important for saving your progress. For example, sometimes running a script that performs data cleaning can take a very long time. Saving your progress might free you from the responsibility of running that script many times.</p>
<p>In R, there are many options for storing data. I will mention two: writing data out to a plain text file, and saving a serialized object.</p>
<div id="writing-out-tabular-plain-text-data-in-r" class="section level3 hasAnchor">
<h3><span class="header-section-number">9.4.1</span> Writing Out Tabular Plain Text Data in R<a aria-label="Anchor link to header" class="anchor-section" href="/input-and-output#writing-out-tabular-plain-text-data-in-r"/></h3>
<p>If you want to write out tabular data to a text file, use <code>write.table()</code> or <code>write.csv()</code>. There are two arguments that you must specify, at a minimum: the first argument is your R object (typically a <code>matrix</code> or <code>data.frame</code>), and the second argument is the file path on your hard drive.</p>
<p>Here is an example of writing out <code>d</code> to a file called <code>"oring_out.csv"</code>. I choose to include column names, but not row names. I also use commas to separate columns.</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb159-1" title="1"><span class="kw">write.table</span>(d, <span class="dt">file =</span> <span class="st">"data/oring_out.csv"</span>, </a>
<a class="sourceLine" id="cb159-2" title="2">            <span class="dt">col.names =</span> <span class="ot">TRUE</span>, <span class="dt">row.names =</span> <span class="ot">FALSE</span>, <span class="dt">sep =</span> <span class="st">";"</span>)</a></code></pre></div>
<p>The above will not print anything to the R console, but we can use a text editor to take a look at the raw text file on our hard drive. Here are the first three rows.</p>
<pre><code>"V1";"V2";"V3";"V4";"V5"
6;0;66;50;1
6;1;70;50;2</code></pre>
</div>
<div id="serialization-in-r" class="section level3 hasAnchor">
<h3><span class="header-section-number">9.4.2</span> Serialization in R<a aria-label="Anchor link to header" class="anchor-section" href="/input-and-output#serialization-in-r"/></h3>
<p>Alternatively you may choose to store your data in a <strong>serialized</strong> form. With this approach, you are still saving your data in a more permanent way to your hard drive, but it is stored in format that’s usually more memory efficient.</p>
<div class="rmd-details">
<p>Recall that a common reason for writing out data is to save your progress. When you want to save your progress, it is important to ask yourself: “is it better to save my progress as a serialized object, or as a raw text file?”</p>
<p>When making this decision, consider <em>versatility.</em> On the one hand, raw text files are more versatile and can be used in more places. On the other hand, versatility is often bug prone.</p>
<p>For example, suppose you want to save a cleaned up <code>data.frame</code>. Are you sure you will remember to store that column of strings as <code>character</code> and not a <code>factor</code>? Does any code that uses this <code>data.frame</code> require that this column be in this format?</p>
</div>
<p>For instance, let’s save the object <code>d</code> in a file called <code>oring.rds</code>.</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb161-1" title="1"><span class="kw">saveRDS</span>(d, <span class="dt">file =</span> <span class="st">"data/oring.rds"</span>)</a>
<a class="sourceLine" id="cb161-2" title="2"><span class="kw">rm</span>(d)</a>
<a class="sourceLine" id="cb161-3" title="3"><span class="kw">exists</span>(<span class="st">"d"</span>)</a>
<a class="sourceLine" id="cb161-4" title="4"><span class="co">## [1] FALSE</span></a></code></pre></div>
<p>After it is saved with <code>saveRDS()</code>, we are free to delete the variable with <code>rm()</code>, because it can be read back in later on. To do this, call <code>readRDS()</code>. This is file has a special format that is recognized by R, so you will not need to worry about any of the usual struggles that occur when reading in data from a plain text file. Additionally, <code>.rds</code> files are typically smaller–<code>oring.rds</code> is only 248 bytes, while <code>"oring_out.csv"</code> is 332 bytes.</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb162-1" title="1">d2 &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="dt">file =</span> <span class="st">"data/oring.rds"</span>)</a>
<a class="sourceLine" id="cb162-2" title="2"><span class="kw">head</span>(d2, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb162-3" title="3"><span class="co">##   V1 V2 V3 V4 V5</span></a>
<a class="sourceLine" id="cb162-4" title="4"><span class="co">## 1  6  0 66 50  1</span></a>
<a class="sourceLine" id="cb162-5" title="5"><span class="co">## 2  6  1 70 50  2</span></a>
<a class="sourceLine" id="cb162-6" title="6"><span class="co">## 3  6  0 69 50  3</span></a></code></pre></div>
<p>You can serialize multiple objects at once, too! Convention dictates that these files end with the <code>.RData</code> suffix. Save your entire global environment with <code>save()</code> or <code>save.image()</code>, and bring it back with <code>load()</code> or <code>attach()</code>.</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb163-1" title="1"><span class="kw">rm</span>(<span class="dt">list=</span><span class="kw">ls</span>()) <span class="co"># remove everything</span></a>
<a class="sourceLine" id="cb163-2" title="2">a &lt;-<span class="st"> </span><span class="dv">1</span></a>
<a class="sourceLine" id="cb163-3" title="3">b &lt;-<span class="st"> </span><span class="dv">2</span></a>
<a class="sourceLine" id="cb163-4" title="4"><span class="kw">save.image</span>(<span class="dt">file =</span> <span class="st">"data/my-current-workspace.RData"</span>)</a>
<a class="sourceLine" id="cb163-5" title="5"><span class="kw">rm</span>(<span class="dt">list=</span><span class="kw">ls</span>()) </a>
<a class="sourceLine" id="cb163-6" title="6"><span class="kw">load</span>(<span class="st">"data/my-current-workspace.RData"</span>)</a>
<a class="sourceLine" id="cb163-7" title="7"><span class="kw">ls</span>() <span class="co"># print all objects in your workspace</span></a>
<a class="sourceLine" id="cb163-8" title="8"><span class="co">## [1] "a" "b"</span></a></code></pre></div>
</div>
</div>
<div id="saving-data-in-python" class="section level2 hasAnchor">
<h2><span class="header-section-number">9.5</span> Saving Data in Python<a aria-label="Anchor link to header" class="anchor-section" href="/input-and-output#saving-data-in-python"/></h2>
<div id="writing-out-tabular-plain-text-data-in-python" class="section level3 hasAnchor">
<h3><span class="header-section-number">9.5.1</span> Writing Out Tabular Plain Text Data in Python<a aria-label="Anchor link to header" class="anchor-section" href="/input-and-output#writing-out-tabular-plain-text-data-in-python"/></h3>
<p>You can write out tabular data with a variety of <a href="https://pandas.pydata.org/pandas-docs/stable/reference/io.html#input-output"><code>DataFrame</code> methods that are named <code>to_*()</code>.</a>. <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_csv.html#pandas.DataFrame.to_csv"><code>pd.DataFrame.to_csv()</code></a> has a lot of common with <code>write.csv()</code> in R. Below we write out <code>d</code> to a file called <code>oring_out2.csv</code>.</p>
<div class="sourceCode" id="cb164"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb164-1" title="1"><span class="im">import</span> pandas <span class="im">as</span> pd</a>
<a class="sourceLine" id="cb164-2" title="2">d <span class="op">=</span> pd.read_csv(<span class="st">"data/o-ring-erosion-only.data"</span>, </a>
<a class="sourceLine" id="cb164-3" title="3">                  header<span class="op">=</span><span class="va">None</span>, sep <span class="op">=</span> <span class="st">"\s+"</span>)</a>
<a class="sourceLine" id="cb164-4" title="4">d.to_csv(<span class="st">"data/oring_out2.csv"</span>, </a>
<a class="sourceLine" id="cb164-5" title="5">          header<span class="op">=</span><span class="va">True</span>, index<span class="op">=</span><span class="va">False</span>, sep <span class="op">=</span> <span class="st">","</span>)</a></code></pre></div>
<p>Here is how the first few rows of that file looks in a text editor.</p>
<pre><code>0,1,2,3,4
6,0,66,50,1
6,1,70,50,2</code></pre>
</div>
<div id="serialization-in-python" class="section level3 hasAnchor">
<h3><span class="header-section-number">9.5.2</span> Serialization in Python<a aria-label="Anchor link to header" class="anchor-section" href="/input-and-output#serialization-in-python"/></h3>
<p>Serialization functionality is readily available in Python, just like it is in R. In Python, the <a href="https://docs.python.org/3/library/pickle.html"><code>pickle</code></a> and <code>cPickle</code> libraries are probably the most commonly used. Serializing objects with these libraries is known as <em>pickling</em> an object.</p>
<p>Pandas has a <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_pickle.html"><code>.to_pickle()</code></a> wrapper method attached to every <code>DataFrame</code>. Once the pickled object is saved, the file can be read back into Python with <a href="https://pandas.pydata.org/docs/reference/api/pandas.read_pickle.html#pandas.read_pickle"><code>pd.read_pickle()</code></a>. These functions are extremely convenient, because they call all the required <code>pickle</code> code and hide a decent amount of complexity.</p>
<p>Here is an example of writing out <code>d</code> and then reading the pickled object back in. In Python 3, the file suffix for pickled objects is usually <code>.pickle</code>, but there are many other choices.</p>
<div class="sourceCode" id="cb166"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb166-1" title="1">d.to_pickle(<span class="st">"data/oring.pickle"</span>)</a>
<a class="sourceLine" id="cb166-2" title="2"><span class="kw">del</span> d</a>
<a class="sourceLine" id="cb166-3" title="3">d_is_back <span class="op">=</span> pd.read_pickle(<span class="st">"data/oring.pickle"</span>)</a>
<a class="sourceLine" id="cb166-4" title="4">d_is_back.head(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb166-5" title="5"><span class="co">##    0  1   2   3  4</span></a>
<a class="sourceLine" id="cb166-6" title="6"><span class="co">## 0  6  0  66  50  1</span></a>
<a class="sourceLine" id="cb166-7" title="7"><span class="co">## 1  6  1  70  50  2</span></a></code></pre></div>
<div class="rmd-caution">
<p>Unfortunately, <code>"oring.pickle"</code> is much larger (1,676 bytes) than the original text file <code>"o-ring-erosion-only.data"</code> (322 bytes). This is for two reasons. First, the original data set is small, so the overhead of pickling this object is relatively pronounced, and second, we are not taking advantage of any compression. If you use something like <code>d_is_back.to_pickle("data/oring.zip")</code> it will become smaller.</p>
</div>
<p>In Python, unlike in R, it is more difficult to serialize all of the objects you currently have in memory. It is possible, but it will likely require the use of a third-party library.</p>
<p>Speaking of third-party code, there are many that provide alternative serialization solutions in both R and Python. I do not discuss any in this text. However, I will mention that some of them may provide combinations of the following: an increase in read and write speed, a decrease in required memory, improved security<a href="#fn16" class="footnote-ref" id="fnref16"><sup>16</sup></a>, improved human readability and interoperability between multiple programming languages. If any of these sound potentially beneficial, I encourage you to conduct further research.</p>
</div>
</div>
<div id="exercises-7" class="section level2 hasAnchor">
<h2><span class="header-section-number">9.6</span> Exercises<a aria-label="Anchor link to header" class="anchor-section" href="/input-and-output#exercises-7"/></h2>
<div id="r-questions-7" class="section level3 hasAnchor">
<h3><span class="header-section-number">9.6.1</span> R Questions<a aria-label="Anchor link to header" class="anchor-section" href="/input-and-output#r-questions-7"/></h3>
<ol style="list-style-type: decimal">
<li/>
</ol>
<p>Consider again the data set called <code>"gspc.csv"</code>, which contains daily open, high, low and close values for the S&amp;P500 Index.</p>
<ol style="list-style-type: lower-alpha">
<li>Read in this data set as a <code>data.frame</code>, and call it <code>myData</code>. Do not include the code that achieves this in your assignment submission.</li>
<li>Write out this object as <code>myData.rds</code>. After you are finished, remove <code>myData</code> from memory. Do not include the code that achieves this in your assignment submission.</li>
<li>Read in <code>myData.rds</code>, and store the variable as <code>financialData</code>. <em>Do</em> include the code that achieves this in your project submission. Make sure this code assumes that <code>myData.rds</code> is in the same folder as the code file <code>io_lab.R</code>.</li>
</ol>
</div>
<div id="python-questions-7" class="section level3 hasAnchor">
<h3><span class="header-section-number">9.6.2</span> Python Questions<a aria-label="Anchor link to header" class="anchor-section" href="/input-and-output#python-questions-7"/></h3>
<ol style="list-style-type: decimal">
<li/>
</ol>
<p>We will use the <code>"Google.html"</code> data set mentioned in the chapter.</p>
<ol style="list-style-type: lower-alpha">
<li>Use <code>open()</code> to open the <code>"Google.html"</code> file. Store the output of the function as <code>my_file</code>.</li>
<li>Use the <code>.readlines()</code> method of the file to write the contents of the file as a <code>list</code> called <code>html_data</code></li>
<li>Coerce the <code>list</code> to a <code>DataFrame</code> with one column called <code>html</code></li>
<li>Create a <code>Series</code> called <code>nchars_ineach</code> that stores the number of characters in each line of text. Hint: the <a href="https://pandas.pydata.org/pandas-docs/stable/reference/series.html#api-series-str"><code>Series.str</code> attribute has a lot of helpful methods</a>.</li>
<li>Create an <code>int</code>-like variable called <code>num_div_tags</code> that holds the total number of times the phrase “<code>&lt;div&gt;</code>” appears in the file.</li>
</ol>
<ol start="2" style="list-style-type: decimal">
<li/>
</ol>
<p>Consider the data set called <code>"gspc.csv"</code>, which contains daily open, high, low and close values for the S&amp;P500 Index.</p>
<ol style="list-style-type: lower-alpha">
<li>Read in this data set as a <code>DataFrame</code>, and call it <code>my_data</code>. Do not include the code that achieves this in your assignment submission.</li>
<li>Write out this object as <code>"my_data.pickle"</code>. After you are finished, remove <code>my_data</code> from memory. Do not include the code that achieves this in your assignment submission.</li>
<li>Read in <code>"my_data.pickle"</code>, and store the variable as <code>financial_data</code>. <em>Do</em> include the code that achieves this in your project submission. Make sure this code assumes that <code>"my_data.pickle"</code> is in the same folder as the code file <code>io_lab.py</code>.</li>
</ol>

</div>
</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-uci_data">
<p>Dua, Dheeru, and Casey Graff. 2017. “UCI Machine Learning Repository.” University of California, Irvine, School of Information; Computer Sciences. <a href="http://archive.ics.uci.edu/ml">http://archive.ics.uci.edu/ml</a>.</p>
</div>
</div>
<div class="footnotes">
<hr/>
<ol start="14">
<li id="fn14"><p>Open raw text files with text editor programs, not with programs that perform any kind of processing. For instance, if you open it with Microsoft Excel, the appearance of the data will change, and important information helping you to read your data into R or Python will not be available to you.<a class="footnote-back" href="/input-and-output#fnref14">↩</a></p></li>
<li id="fn15"><p>A list of more options of encodings that are built into Python,are available <a href="https://docs.python.org/3/library/codecs.html#standard-encodings">here.</a><a class="footnote-back" href="/input-and-output#fnref15">↩</a></p></li>
<li id="fn16"><p>The <a href="https://docs.python.org/2/library/pickle.html">documentation for <code>pickle</code></a> mentions that the library is “not secure against erroneous or maliciously constructed data” and recommends that you “[n]ever unpickle data received from an untrusted or unauthenticated source.”<a class="footnote-back" href="/input-and-output#fnref16">↩</a></p></li>
</ol>
</div>
                
</body>
</html>