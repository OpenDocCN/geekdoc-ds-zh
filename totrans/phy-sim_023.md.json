["```py\nimport numpy as np\nimport utils\n\ndef val(x, e, l2, k):\n    sum = 0.0\n    for i in range(0, len(e)):\n        diff = x[e[i][0]] - x[e[i][1]]\n        sum += l2[i] * 0.5 * k[i] * (diff.dot(diff) / l2[i] - 1) ** 2\n    return sum\n\ndef grad(x, e, l2, k):\n    g = np.array([[0.0, 0.0]] * len(x))\n    for i in range(0, len(e)):\n        diff = x[e[i][0]] - x[e[i][1]]\n        g_diff = 2 * k[i] * (diff.dot(diff) / l2[i] - 1) * diff\n        g[e[i][0]] += g_diff\n        g[e[i][1]] -= g_diff\n    return g\n\ndef hess(x, e, l2, k):\n    IJV = [[0] * (len(e) * 16), [0] * (len(e) * 16), np.array([0.0] * (len(e) * 16))]\n    for i in range(0, len(e)):\n        diff = x[e[i][0]] - x[e[i][1]]\n        H_diff = 2 * k[i] / l2[i] * (2 * np.outer(diff, diff) + (diff.dot(diff) - l2[i]) * np.identity(2))\n        H_local = utils.make_PSD(np.block([[H_diff, -H_diff], [-H_diff, H_diff]]))\n        # add to global matrix\n        for nI in range(0, 2):\n            for nJ in range(0, 2):\n                indStart = i * 16 + (nI * 2 + nJ) * 4\n                for r in range(0, 2):\n                    for c in range(0, 2):\n                        IJV[0][indStart + r * 2 + c] = e[i][nI] * 2 + r\n                        IJV[1][indStart + r * 2 + c] = e[i][nJ] * 2 + c\n                        IJV[2][indStart + r * 2 + c] = H_local[nI * 2 + r, nJ * 2 + c]\n    return IJV \n```", "```py\nimport numpy as np\nimport numpy.linalg as LA\n\ndef make_PSD(hess):\n    [lam, V] = LA.eigh(hess)    # Eigen decomposition on symmetric matrix\n    # set all negative Eigenvalues to 0\n    for i in range(0, len(lam)):\n        lam[i] = max(0, lam[i])\n    return np.matmul(np.matmul(V, np.diag(lam)), np.transpose(V)) \n```"]