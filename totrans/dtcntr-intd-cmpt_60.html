<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>18.4Â Hashes, Sets, and Key-ValuesğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>18.4Â Hashes, Sets, and Key-ValuesğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/hash-set-kv.html">https://dcic-world.org/2025-08-27/hash-set-kv.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._hash-string%29" class="toclink" data-pltdoc="x">18.4.1Â A Hash Function for Strings</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Sets_from_.Hashing%29" class="toclink" data-pltdoc="x">18.4.2Â Sets from Hashing</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Arrays%29" class="toclink" data-pltdoc="x">18.4.3Â Arrays</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._hash-tables%29" class="toclink" data-pltdoc="x">18.4.4Â Sets from Hashing and Arrays</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Collisions%29" class="toclink" data-pltdoc="x">18.4.5Â Collisions</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Resolving_.Collisions%29" class="toclink" data-pltdoc="x">18.4.6Â Resolving Collisions</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._hash-comp%29" class="toclink" data-pltdoc="x">18.4.7Â Complexity</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._bloom-filters%29" class="toclink" data-pltdoc="x">18.4.8Â Bloom Filters</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Generalizing_from_.Sets_to_.Key-.Values%29" class="toclink" data-pltdoc="x">18.4.9Â Generalizing from Sets to Key-Values</a></p></td></tr></table><p>We have seen several solutions to set membership
[<a href="part_sets.html" data-pltdoc="x">Several Variations on Sets</a>]. In particular, trees
[<a href="sets-from-trees.html" data-pltdoc="x">Making Sets Grow on Trees</a>] gave us logarithmic complexity for
insection and membership.
Now we will see one more implementation of sets, with different
complexity. To set this up, we assume you are familiar with the
concept of hashing [<a href="orderability.html#%28part._hashing-values%29" data-pltdoc="x">Converting Values to Ordered Values</a>], which we saw
was useful for constructing search trees. Here, we
will use it to construct sets in a very different way.
We will then generalize sets to another important data
structure: key-value repositories. But firstâ€¦</p><section class="SsectionLevel4" id="section 18.4.1"><h4 class="heading">18.4.1Â <a name="(part._hash-string)"/>A Hash Function for Strings<a href="#(part._hash-string)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>As we have seen in <a href="orderability.html#%28part._hashing-values%29" data-pltdoc="x">Converting Values to Ordered Values</a>, we have multiple
strategies for converting arbitrary values into numbers, which we will
rely on here. Therefore, we could write this material around numbers
alone. To make the examples more interesting, and to better illustrate
some real-world issues, we will instead use strings. To hash them, we
will use <code data-lang="pyret" class="sourceCode">hash-of</code>, defined there, which simply adds up a
stringâ€™s code points.</p><p>We use this function for multiple reasons. First, it is sufficient to
illustrate some of the consequences of hashing. Second, in practice,
when built-in hashing does not suffice, we do write (more complex
versions of) functions like it. And finally, because itâ€™s all laid
bare, itâ€™s easy for us to experiment with.</p></section><section class="SsectionLevel4" id="section 18.4.2"><h4 class="heading">18.4.2Â <a name="(part._.Sets_from_.Hashing)"/>Sets from Hashing<a href="#(part._.Sets_from_.Hashing)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Suppose we are given a set of strings. We can hash each element of
that set. Each string is now mapped to a number. Each of these numbers
is a member of the set; every other number is not a member of this
set.</p><p>Therefore, a simple representation is to just store this list of numbers. For instance, we can store the list
<code data-lang="pyret" class="sourceCode">[list: "Hello", "World!", "ğŸ´â€â˜ ï¸"] as [list: 500, 553, 195692]</code>.</p><p>Unfortunately, this does not help very much. Insertion can be done in
constant time, but checking membership requires us to traverse the
entire list, which takes linear time in the worst case. Alternatively,
maybe we have some clever scheme that involves sorting the list. But
note:
</p><ul><li><p>inserting the element can now take as much as linear time; or,</p></li><li><p>we store the elements as a tree instead of a list, but then</p><ol><li><p>we have to make sure the tree is balanced, so</p></li><li><p>we will have essentially reconstructed the BBST.</p></li></ol></li></ul><p>In other words, we are recapitulating the discussion from
<a href="sets-from-lists.html" data-pltdoc="x">Representing Sets as Lists</a> and <a href="sets-from-trees.html" data-pltdoc="x">Making Sets Grow on Trees</a>.</p><p>Notice that the problem here is traversal: if we have to visit
more than a constant number of elements, we have probably not
improved anything over the BBST. So, given a hash, how can we perform
only a constant amount of work? For that, lists and trees donâ€™t work:
they both require at least some amount of (non-constant) traversal to
get to an arbitrary element. Instead we need a different data
structureâ€¦</p></section><section class="SsectionLevel4" id="section 18.4.3"><h4 class="heading">18.4.3Â <a name="(part._.Arrays)"/>Arrays<a href="#(part._.Arrays)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Arrays are another linear data structure, like lists. There are two
key differences between lists and arrays that reflect each oneâ€™s
strength and weakness.</p><p>The main benefit to arrays is that we can access any element in the
array in constant time. This is in contrast to lists where, to
get to the \(n\)th element, we have to first traverse the previous
\(n-1\) elements (using successive <code data-lang="pyret" class="sourceCode">rest</code>s).</p><p>However, this benefit comes at a cost. The reason arrays can support
constant-time access is because the size of an array is fixed
at creation time. Thus, while we can keep extending a list using link,
we cannot grow the size of an array â€œin placeâ€; rather, we must make
a new array and copy the entire arrayâ€™s content into the new array,
which takes linear time. (We can do a better job of this by using
<a href="amortized-analysis.html" data-pltdoc="x">Halloween Analysis</a>, but there is no real free ride.)</p><p>The arrays in Pyret are
<a href="https://www.pyret.org/docs/latest/arrays.html">documented here</a>.
While not necessary in principle, it is conventional to think of
arrays as data structures that support mutation, and that is how we
will use them here.</p></section><section class="SsectionLevel4" id="section 18.4.4"><h4 class="heading">18.4.4Â <a name="(part._hash-tables)"/>Sets from Hashing and Arrays<a href="#(part._hash-tables)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Okay, so now we have a strategy. When we want to insert a string into
the set, we compute its hash, go to the corresponding location in the
array, and record the presence of that string. If we want to check for
membership, we similarly compute its hash and see whether the
corresponding location has been set. Traditionally, each location in
the array is called a bucket, and this data structure is called
a hashtable.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">BUCKET-COUNT = 1000

buckets = array-of(false, BUCKET-COUNT)

fun insert(s :: String):
  h = hash-of(s)
  buckets.set-now(h, true)
end

fun is-in(s :: String):
  h = hash-of(s)
  buckets.get-now(h)
end</code></pre><p>Observe that if this were to work, we would have constant time
insertion and membership checking. Unfortunately, two things make this
plan untenable in general.</p></section><section class="SsectionLevel4" id="section 18.4.5"><h4 class="heading">18.4.5Â <a name="(part._.Collisions)"/>Collisions<a href="#(part._.Collisions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>First, our choice of hash function. For the above scheme to work, two
different strings have to map to two different locations.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Is the above hash function invertible?</p></blockquote></blockquote><p>We just need to find two strings that have the same hash. Given the
definition of <code data-lang="pyret" class="sourceCode">hash-of</code>, itâ€™s easy to see that any rearrangement of the
letters produces the same hash:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">hash-of("Hello")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">500</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">hash-of("olleH")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">500</code></pre></td></tr></table><p>Similarly, this test suite passes:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  hash-of("Hello") is hash-of("olleH")
  hash-of("Where") is hash-of("Weird")
  hash-of("Where") is hash-of("Wired")
  hash-of("Where") is hash-of("Whine")
end</code></pre><p>When multiple values hash to the same location, we call this a
hash collision.</p><p>Hash-collisions are problematic! With the above hash function, we get:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  insert("Hello")
  is-in("Hello") is true
  is-in("Where") is false
  is-in("elloH") is true
end</code></pre><p>where two of these tests are desirable but the third is definitely not.</p><p>Note that collisions are virtually inevitable. If we have uniformly
distributed data, then collisions show up sooner than we might
expect.This follows from the reasoning behind what is
known as the
<a href="http://en.wikipedia.org/wiki/Birthday_problem">birthday problem</a>,
commonly presented as how many people need to be in a room before the
likelihood that two of them share a birthday exceeds some
percentage. For the likelihood to exceed half we need just 23 people!
Therefore, it is wise to prepare for the possibility of collisions.</p><p>The key is to know something about the distribution of hash
values. For instance, if we knew our hash values are all multiples of
10, then using a table size of 10 would be a terrible idea (because
all elements would hash to the same bucket, turning our hash table
into a list). In practice, it is common to use uncommon prime numbers
as the table size, since a random value is unlikely to have it as a
divisor. This does not yield a theoretical improvement (unless you can
make certain assumptions about the input, or work through the math
very carefully), but it works well in practice.In
particular, since the typical hashing function uses memory addresses
for objects on the heap, and on most systems these addresses are
multiples of 4, using a prime like 31 is often a fairly good bet.</p><p>While collisions are probabilistic, and depend on the choice of hash
function, we have an even more fundamental and unavoidable reason for
collisions. We have to store an array of the largest possible hash
size. However, not only can hash values be very large (try to run
<code data-lang="pyret" class="sourceCode">insert("ğŸ´â€â˜ ï¸")</code> and see what happens), there isnâ€™t even an a priori
limit to the size of a hash. This fundamentally flies in the face of
arrays, which must have a fixed size.</p><p>To handle arbitrarily large values, we:
</p><ul><li><p>use an array size that is reasonable given our memory
constraints</p></li><li><p>use the remainder of the hash relative to the arrayâ€™s
size to find the bucket</p></li></ul><p>That is:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun insert(s :: String):
  h = hash-of(s)
  buckets.set-now(num-remainder(h, BUCKET-COUNT), true)
end

fun is-in(s :: String):
  h = hash-of(s)
  buckets.get-now(num-remainder(h, BUCKET-COUNT))
end</code></pre><p>This addresses the second problem: we can also store the pirate flag:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  is-in("ğŸ´â€â˜ ï¸") is false
  insert("ğŸ´â€â˜ ï¸")
  is-in("ğŸ´â€â˜ ï¸") is true
end</code></pre><p>Observe, however, we have simply created yet another source of
collisions: the remainder computation. If we have 10 buckets, then the
hashes 5, 15, 25, 35, â€¦ all refer to the same bucket. Thus, there are
two sources of collision, and we have to deal with them both.</p></section><section class="SsectionLevel4" id="section 18.4.6"><h4 class="heading">18.4.6Â <a name="(part._.Resolving_.Collisions)"/>Resolving Collisions<a href="#(part._.Resolving_.Collisions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Surprisingly or disappointingly, we have a very simple solution to the
collision problems. Each bucket is not a single Boolean value, but
rather a list of the actual values that hashed to that bucket. Then,
we just check for membership in that list.</p><p>First, we will abstract over finding the bucket number in
<code data-lang="pyret" class="sourceCode">insert</code> and <code data-lang="pyret" class="sourceCode">is-in</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun index-of(s :: String):
  num-remainder(hash-of(s), BUCKET-COUNT)
end</code></pre><p>Next, we change what is held in each bucket: not a Boolean, but rather
a list of the actual strings:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">buckets = array-of(empty, BUCKET-COUNT)</code></pre><p>Now we can write the more nuanced membership checker:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun is-in(s :: String):
  b = index-of(s)
  member(buckets.get-now(b), s)
end</code></pre><p>Similarly, when inserting, we first make sure the element isnâ€™t already there (to avoid the complexity problems caused by having duplicates), and only then insert it:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun insert(s :: String):
  b = index-of(s)
  l = buckets.get-now(b)
  when not(member(l, s)):
    buckets.set-now(b, link(s, l))
  end
end</code></pre><p>Now our tests pass as intended:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  insert("Hello")
  is-in("Hello") is true
  is-in("Where") is false
  is-in("elloH") is false
end</code></pre></section><section class="SsectionLevel4" id="section 18.4.7"><h4 class="heading">18.4.7Â <a name="(part._hash-comp)"/>Complexity<a href="#(part._hash-comp)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Now we have yet another working implementation for (some primitives
of) sets. The use of arrays supposedly enables us to get constant-time
complexity. Yet we should feel at least some discomfort. After all,
the constant time applied when the arrays contained only Boolean
values. However, that solution was weak in two ways: it could not
handle hash-collisions by non-invertible hash functions, and it
required potentially enormous arrays. If we relaxed either assumption,
the implementation was simply wrong, in that it was easily
fooled by values that caused collisions either through hashing or
through computing the remainder.</p><p>The solution we have shown above is called hash chaining, where
â€œchainâ€ refers to the list stored in each bucket. The benefit of
hash-chaining is that insertion can still be constant-time: it takes a
constant amount of time to find a bucket, and inserting can be as
cheap as link. Of course, this assumes that we donâ€™t mind duplicates;
otherwise we will pay the same price we saw earlier in
<a href="sets-from-lists.html" data-pltdoc="x">Representing Sets as Lists</a>. But lookup takes time linear in the
size of the bucket (which, with duplicates, could be arbitrarily
larger relative to the number of distinct elements). And even if we
check for duplicates, we run the risk that most or even all the
elements could end up in the same bucket (e.g., suppose the elements
are <code data-lang="pyret" class="sourceCode">"Where"</code>, <code data-lang="pyret" class="sourceCode">"Weird"</code>, <code data-lang="pyret" class="sourceCode">"Wired"</code>,
<code data-lang="pyret" class="sourceCode">"Whine"</code>). In that case, our sophisticated implementation
reduces to the list-based representation and its complexity!</p><p>Thereâ€™s an additional subtlety here. When we check membership of the
string in the list of strings, we have to consider the cost of
comparing each pair of strings. In the worst case, that is
proportional to the length of the shorter string. Usually this is
bounded by a small constant, but one can imagine settings where this
is not guaranteed to be true. However, this same cost has to be borne
by all set implementations; it is not a new complexity introduced
here.</p><p>Thus, in theory, hash-based sets can support insertion and membership
in as little as constant time, and (ignoring the cost of string
comparisons) as much as linear time, where â€œlinearâ€ has the same
caveats about duplicates as the list-based representation. In many
casesâ€”<wbr/>depending on the nature of the data and parameters set for the
arrayâ€”<wbr/>they can be much closer to constant time. As a result, they
tend to be very popular in practice.</p></section><section class="SsectionLevel4" id="section 18.4.8"><h4 class="heading">18.4.8Â <a name="(part._bloom-filters)"/>Bloom Filters<a href="#(part._bloom-filters)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Another way to improve the space and time complexity is to relax the
properties we expect of the operations. Right now, set membership
gives perfect answers, in that it answers <code data-lang="pyret" class="sourceCode">true</code> exactly when the
element being checked was previously inserted into the set. But
suppose weâ€™re in a setting where we can accept a more relaxed notion
of correctness, where membership tests can â€œlieâ€ slightly in one
direction or the other (but not both, because that makes the
representation almost useless). Specifically, letâ€™s say that â€œno
means noâ€ (i.e., if the set representation says the element isnâ€™t
present, it really isnâ€™t) but â€œyes sometimes means noâ€ (i.e., if the
set representation says an element is present, sometimes it
might not be). In short, if the set says the element isnâ€™t in it, this
should be guaranteed; but if the set says the element is present,
it may not be. In the latter case, we either need some
otherâ€”<wbr/>more expensiveâ€”<wbr/>technique to determine truth, or we might
just not care.</p><p>Where is such a data structure of use? Suppose we are building a Web
site that uses password-based authentication. Because many passwords
have been leaked in well-publicized breaches, it is safe to assume
that hackers have them and will guess them. As a result, we want to
not allow users to select any of these as passwords. We could use a
hash-table to reject precisely the known leaked passwords. But for
efficiency, we could use this imperfect hash instead. If it says
â€œnoâ€, then we allow the user to use that password. But if it says
â€œyesâ€, then either they are using a password that has been leaked,
or they have an entirely different password that, purely by accident,
has the same hash value, but no matter; we can just disallow that
password as well.A related use is for filtering out
malicious Web sites. The URL shortening system, bitly,
<a href="http://word.bitly.com/post/28558800777/dablooms-an-open-source-scalable-counting-bloom">uses it for this purpose</a>.
Itâ€™s also used by ad networks; hereâ€™s a
<a href="https://youtu.be/T3Bt9Tn6P5c?si=t8U33orccRCgkSw0&amp;t=1277">talk</a>
(the segment from about 20m to about 45m) about that.
            But sometimes, a Bloom filter is overkill,
            as this Cloudflare blog post
            <a href="https://blog.cloudflare.com/when-bloom-filters-dont-bloom/">discusses</a>â€¦</p><p>Another example is in updating databases or memory stores. Suppose we
have a database of records, which we update frequently. It is often
more efficient to maintain a journal of changes: i.e., a list
that sequentially records all the changes that have occurred. At some
interval (say overnight), the journal is â€œflushedâ€, meaning all
these changes are applied to the database proper. But that means every
read operation has become highly inefficient, because it has to check
the entire journal first (for updates) before accessing the
database. Again, here we can use this faulty notion of a hash table:
if the hash of the record locator says â€œnoâ€, then the record
certainly hasnâ€™t been modified and we go directly to the database; if
it says â€œyesâ€ then we have to check the journal.</p><p>We have already seen a simple example implementation of this idea
earlier, when we used a single array, with modular arithmetic, to
represent the set. When an element was not present in the array, we
knew for a fact that it was definitely not present. When the array
indicated an element was present, we couldnâ€™t be sure that what was
present was the exact value we were looking for. To get around this
uncertainty, we used chaining.</p><p>However, there is something else we could have done. Chaining costs
both space (to store all the actual values) and time (to look through
all the values). Suppose, instead, a bucket is only a Boolean
value. This results in a slightly useful, but potentially very
inaccurate, data structure; furthermore, it exhibits correlated
failure tied to the modulus.</p><p>But suppose we have not only one array, but several! When an element
is added to the set, it is added to each array; when checking for
membership, every array is consulted. The set only answers
affirmatively to membership if all the arrays do so.</p><p>Naturally, using multiple arrays offers absolutely no advantage if the
arrays are all the same size: since both insertion and lookup are
deterministic, all will yield the same answer. However, there is a
simple antidote to this: use different array sizes. In particular, by
using array sizes that are relatively prime to one another, we
minimize the odds of a clash (only hashes that are the product of all
the array sizes will fool the array).</p><p>This data structure, called a Bloom Filter, is a
probabilistic data structure. Unlike our earlier set data
structure, this one is not guaranteed to always give the right answer;
but contrary to the
<a href="glossary.html#%28elem._glossary-space-time._tradeoff%29" data-pltdoc="x">â˜› space-time tradeoff</a>, we
save both space and time by changing the
problem slightly to accept incorrect answers. If we know something
about the distribution of hash values, and we have some acceptable
bound of error, we can design hash table sizes so that with high
probability, the Bloom Filter will lie within the acceptable error
bounds.</p></section><section class="SsectionLevel4" id="section 18.4.9"><h4 class="heading">18.4.9Â <a name="(part._.Generalizing_from_.Sets_to_.Key-.Values)"/>Generalizing from Sets to Key-Values<a href="#(part._.Generalizing_from_.Sets_to_.Key-.Values)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Above, we focused on sets: that is, a string effectively mapped to a
Boolean value, indicating whether it was present or not. However,
there are many settings where it is valuable to associate one value
with another. For instance, given an identity number we might want to
pull up a personâ€™s records; given a computerâ€™s name, we might want to
retrieve its routing information; given a starâ€™s catalog entry, we
might want its astronomical information. This kind of data structure
is so ubiquitous that it has several names, some of which are more
general and some implying specific implementations: key-value
store, associative array, hash map, dictionary,
etc.</p><p>In general, the names â€œkey-valueâ€ and â€œdictionaryâ€ are useful
because they suggest a behavioral interface. In contrast,
associative array implies the use of arrays, and hash table suggests
the use of an array (and of hashing). In fact, real systems use a
variety of implementation strategies, including balanced binary search
trees. The names â€œkey-valueâ€ and â€œdictionaryâ€ avoid commitment to
a particular implementation. Here, too, â€œdictionaryâ€ evokes a common
mental image of unique words that map to descriptions. The term â€œkey
valueâ€ is even more technically useful because keys are meant to all
be distinct (i.e., no two different key-value pairs can have the same
key; alternatively, one key can map to only one value). This makes
sense because we view this as a generalization of sets, so the keys
are the set elements, which must necessarily have no duplicates; the
values take the place of the Boolean.</p><p>To extend our set representation to handle a dictionary or key-value
store, we need to make a few changes. First, we introduce the
key-value representation:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data KV&lt;T&gt;: kv(key :: String, value :: T) end</code></pre><p>Each bucket is still an empty list, but we understand it to be a list of key-value pairs.</p><p>Previously, we only had <code data-lang="pyret" class="sourceCode">is-in</code> to check whether an element was
present in a set or not. That element is now the key, and we could
have a similar function to check whether the key is present. However,
we rarely want to know just that; in fact, because we already know the
key, we usually want the associated value.</p><p>Therefore, we can just have this one function:We use Pyretâ€™s naming convention of <code data-lang="pyret" class="sourceCode">-now</code> to indicate that this result might change later.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">getkv-now :: &lt;T&gt; String -&gt; T</code></pre><p>Of course, <code data-lang="pyret" class="sourceCode">getkv-now</code> may fail: the key may not be present. That is,
it has become a partial function [<a href="partial-domains.html" data-pltdoc="x">Partial Domains</a>]. We
therefore have all the usual strategies for dealing with partial
functions. Here, for simplicity we choose to return an error if the
key is not present, but all the other strategies we discuss for
handling partiality are valid (and often better in a robust
implementation).</p><p>Similarly, we have:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">setkv-now :: &lt;T&gt; String, T -&gt; Nothing</code></pre><p>This is the generalization of <code data-lang="pyret" class="sourceCode">insert</code>. However, <code data-lang="pyret" class="sourceCode">insert</code>
had no reason to return an error: inserting an element twice was
harmless. However, because keys must now be associated with only one
value, insertion has to check whether the key is already present, and
signal an error otherwise. In short, it is also
partial.This is not partial due to a mathematical reason,
but rather because of state: the same key may have been inserted
previously.</p><p>Once we have agreed on this interface, getting a value is a natural
extension of checking for membership:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun getkv-now(k):
  b = index-of(k)
  r = find({(kvp): kvp.key == k}, buckets.get-now(b))
  cases (Option) r:
    | none =&gt; raise("getkv-now can't find " + k)
    | some(v) =&gt; v.value
  end
end</code></pre><p>Having found the index, we look in the bucket for whether any
key-value pair has the desired key. If it does, then we return the
corresponding value. Otherwise, we error.</p><p>Inserting a key-value pair similarly generalizes adding an element to the set:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun setkv-now(k, v):
  b = index-of(k)
  keys = map(_.key, buckets.get-now(b))
  if member(keys, k):
    raise("setkv-now already has a value for key " + k)
  else:
    buckets.set-now(b, link(kv(k, v), buckets.get-now(b)))
  end
end</code></pre><p>Once again, we check the bucket for whether the key is already
present. If it is, we choose to halt with an error. Otherwise, we make
the key-value pair and link it to the existing bucket contents, and
modify the array to refer to the new list.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Do the above pair of functions do all the necessary error-checking?</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Above, <code data-lang="pyret" class="sourceCode">setkv-now</code> raises an error if a key already has a name associated with it.
A natural variation is to instead override the associated value, so that
the new value is now associated with that key. Modify the implementation to do that
instead, and make sure you test it thoroughly! Note that you may need to modify the
<code data-lang="pyret" class="sourceCode">KV</code> datatype also.</p></blockquote></blockquote><p>This concludes our brief tour of sets (yet again!) and key-value
stores or dictionaries. We have chosen to implement both using arrays,
which required us to employ hashes. For more on string dictionaries,
see the
<a href="https://www.pyret.org/docs/latest/string-dict.html">Pyret
documentation</a>.  Observe that Pyret offers two kinds of dictionaries:
one mutable (like we have shown here) and one (the default)
functional.</p></section>&#13;
<h4 class="heading">18.4.1Â <a name="(part._hash-string)"/>A Hash Function for Strings<a href="#(part._hash-string)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>As we have seen in <a href="orderability.html#%28part._hashing-values%29" data-pltdoc="x">Converting Values to Ordered Values</a>, we have multiple
strategies for converting arbitrary values into numbers, which we will
rely on here. Therefore, we could write this material around numbers
alone. To make the examples more interesting, and to better illustrate
some real-world issues, we will instead use strings. To hash them, we
will use <code data-lang="pyret" class="sourceCode">hash-of</code>, defined there, which simply adds up a
stringâ€™s code points.</p><p>We use this function for multiple reasons. First, it is sufficient to
illustrate some of the consequences of hashing. Second, in practice,
when built-in hashing does not suffice, we do write (more complex
versions of) functions like it. And finally, because itâ€™s all laid
bare, itâ€™s easy for us to experiment with.</p>&#13;
<h4 class="heading">18.4.2Â <a name="(part._.Sets_from_.Hashing)"/>Sets from Hashing<a href="#(part._.Sets_from_.Hashing)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Suppose we are given a set of strings. We can hash each element of
that set. Each string is now mapped to a number. Each of these numbers
is a member of the set; every other number is not a member of this
set.</p><p>Therefore, a simple representation is to just store this list of numbers. For instance, we can store the list
<code data-lang="pyret" class="sourceCode">[list: "Hello", "World!", "ğŸ´â€â˜ ï¸"] as [list: 500, 553, 195692]</code>.</p><p>Unfortunately, this does not help very much. Insertion can be done in
constant time, but checking membership requires us to traverse the
entire list, which takes linear time in the worst case. Alternatively,
maybe we have some clever scheme that involves sorting the list. But
note:
</p><ul><li><p>inserting the element can now take as much as linear time; or,</p></li><li><p>we store the elements as a tree instead of a list, but then</p><ol><li><p>we have to make sure the tree is balanced, so</p></li><li><p>we will have essentially reconstructed the BBST.</p></li></ol></li></ul><p>In other words, we are recapitulating the discussion from
<a href="sets-from-lists.html" data-pltdoc="x">Representing Sets as Lists</a> and <a href="sets-from-trees.html" data-pltdoc="x">Making Sets Grow on Trees</a>.</p><p>Notice that the problem here is traversal: if we have to visit
more than a constant number of elements, we have probably not
improved anything over the BBST. So, given a hash, how can we perform
only a constant amount of work? For that, lists and trees donâ€™t work:
they both require at least some amount of (non-constant) traversal to
get to an arbitrary element. Instead we need a different data
structureâ€¦</p>&#13;
<h4 class="heading">18.4.3Â <a name="(part._.Arrays)"/>Arrays<a href="#(part._.Arrays)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Arrays are another linear data structure, like lists. There are two
key differences between lists and arrays that reflect each oneâ€™s
strength and weakness.</p><p>The main benefit to arrays is that we can access any element in the
array in constant time. This is in contrast to lists where, to
get to the \(n\)th element, we have to first traverse the previous
\(n-1\) elements (using successive <code data-lang="pyret" class="sourceCode">rest</code>s).</p><p>However, this benefit comes at a cost. The reason arrays can support
constant-time access is because the size of an array is fixed
at creation time. Thus, while we can keep extending a list using link,
we cannot grow the size of an array â€œin placeâ€; rather, we must make
a new array and copy the entire arrayâ€™s content into the new array,
which takes linear time. (We can do a better job of this by using
<a href="amortized-analysis.html" data-pltdoc="x">Halloween Analysis</a>, but there is no real free ride.)</p><p>The arrays in Pyret are
<a href="https://www.pyret.org/docs/latest/arrays.html">documented here</a>.
While not necessary in principle, it is conventional to think of
arrays as data structures that support mutation, and that is how we
will use them here.</p>&#13;
<h4 class="heading">18.4.4Â <a name="(part._hash-tables)"/>Sets from Hashing and Arrays<a href="#(part._hash-tables)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Okay, so now we have a strategy. When we want to insert a string into
the set, we compute its hash, go to the corresponding location in the
array, and record the presence of that string. If we want to check for
membership, we similarly compute its hash and see whether the
corresponding location has been set. Traditionally, each location in
the array is called a bucket, and this data structure is called
a hashtable.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">BUCKET-COUNT = 1000

buckets = array-of(false, BUCKET-COUNT)

fun insert(s :: String):
  h = hash-of(s)
  buckets.set-now(h, true)
end

fun is-in(s :: String):
  h = hash-of(s)
  buckets.get-now(h)
end</code></pre><p>Observe that if this were to work, we would have constant time
insertion and membership checking. Unfortunately, two things make this
plan untenable in general.</p>&#13;
<h4 class="heading">18.4.5Â <a name="(part._.Collisions)"/>Collisions<a href="#(part._.Collisions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>First, our choice of hash function. For the above scheme to work, two
different strings have to map to two different locations.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Is the above hash function invertible?</p></blockquote></blockquote><p>We just need to find two strings that have the same hash. Given the
definition of <code data-lang="pyret" class="sourceCode">hash-of</code>, itâ€™s easy to see that any rearrangement of the
letters produces the same hash:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">hash-of("Hello")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">500</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">hash-of("olleH")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">500</code></pre></td></tr></table><p>Similarly, this test suite passes:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  hash-of("Hello") is hash-of("olleH")
  hash-of("Where") is hash-of("Weird")
  hash-of("Where") is hash-of("Wired")
  hash-of("Where") is hash-of("Whine")
end</code></pre><p>When multiple values hash to the same location, we call this a
hash collision.</p><p>Hash-collisions are problematic! With the above hash function, we get:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  insert("Hello")
  is-in("Hello") is true
  is-in("Where") is false
  is-in("elloH") is true
end</code></pre><p>where two of these tests are desirable but the third is definitely not.</p><p>Note that collisions are virtually inevitable. If we have uniformly
distributed data, then collisions show up sooner than we might
expect.This follows from the reasoning behind what is
known as the
<a href="http://en.wikipedia.org/wiki/Birthday_problem">birthday problem</a>,
commonly presented as how many people need to be in a room before the
likelihood that two of them share a birthday exceeds some
percentage. For the likelihood to exceed half we need just 23 people!
Therefore, it is wise to prepare for the possibility of collisions.</p><p>The key is to know something about the distribution of hash
values. For instance, if we knew our hash values are all multiples of
10, then using a table size of 10 would be a terrible idea (because
all elements would hash to the same bucket, turning our hash table
into a list). In practice, it is common to use uncommon prime numbers
as the table size, since a random value is unlikely to have it as a
divisor. This does not yield a theoretical improvement (unless you can
make certain assumptions about the input, or work through the math
very carefully), but it works well in practice.In
particular, since the typical hashing function uses memory addresses
for objects on the heap, and on most systems these addresses are
multiples of 4, using a prime like 31 is often a fairly good bet.</p><p>While collisions are probabilistic, and depend on the choice of hash
function, we have an even more fundamental and unavoidable reason for
collisions. We have to store an array of the largest possible hash
size. However, not only can hash values be very large (try to run
<code data-lang="pyret" class="sourceCode">insert("ğŸ´â€â˜ ï¸")</code> and see what happens), there isnâ€™t even an a priori
limit to the size of a hash. This fundamentally flies in the face of
arrays, which must have a fixed size.</p><p>To handle arbitrarily large values, we:
</p><ul><li><p>use an array size that is reasonable given our memory
constraints</p></li><li><p>use the remainder of the hash relative to the arrayâ€™s
size to find the bucket</p></li></ul><p>That is:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun insert(s :: String):
  h = hash-of(s)
  buckets.set-now(num-remainder(h, BUCKET-COUNT), true)
end

fun is-in(s :: String):
  h = hash-of(s)
  buckets.get-now(num-remainder(h, BUCKET-COUNT))
end</code></pre><p>This addresses the second problem: we can also store the pirate flag:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  is-in("ğŸ´â€â˜ ï¸") is false
  insert("ğŸ´â€â˜ ï¸")
  is-in("ğŸ´â€â˜ ï¸") is true
end</code></pre><p>Observe, however, we have simply created yet another source of
collisions: the remainder computation. If we have 10 buckets, then the
hashes 5, 15, 25, 35, â€¦ all refer to the same bucket. Thus, there are
two sources of collision, and we have to deal with them both.</p>&#13;
<h4 class="heading">18.4.6Â <a name="(part._.Resolving_.Collisions)"/>Resolving Collisions<a href="#(part._.Resolving_.Collisions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Surprisingly or disappointingly, we have a very simple solution to the
collision problems. Each bucket is not a single Boolean value, but
rather a list of the actual values that hashed to that bucket. Then,
we just check for membership in that list.</p><p>First, we will abstract over finding the bucket number in
<code data-lang="pyret" class="sourceCode">insert</code> and <code data-lang="pyret" class="sourceCode">is-in</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun index-of(s :: String):
  num-remainder(hash-of(s), BUCKET-COUNT)
end</code></pre><p>Next, we change what is held in each bucket: not a Boolean, but rather
a list of the actual strings:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">buckets = array-of(empty, BUCKET-COUNT)</code></pre><p>Now we can write the more nuanced membership checker:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun is-in(s :: String):
  b = index-of(s)
  member(buckets.get-now(b), s)
end</code></pre><p>Similarly, when inserting, we first make sure the element isnâ€™t already there (to avoid the complexity problems caused by having duplicates), and only then insert it:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun insert(s :: String):
  b = index-of(s)
  l = buckets.get-now(b)
  when not(member(l, s)):
    buckets.set-now(b, link(s, l))
  end
end</code></pre><p>Now our tests pass as intended:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  insert("Hello")
  is-in("Hello") is true
  is-in("Where") is false
  is-in("elloH") is false
end</code></pre>&#13;
<h4 class="heading">18.4.7Â <a name="(part._hash-comp)"/>Complexity<a href="#(part._hash-comp)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Now we have yet another working implementation for (some primitives
of) sets. The use of arrays supposedly enables us to get constant-time
complexity. Yet we should feel at least some discomfort. After all,
the constant time applied when the arrays contained only Boolean
values. However, that solution was weak in two ways: it could not
handle hash-collisions by non-invertible hash functions, and it
required potentially enormous arrays. If we relaxed either assumption,
the implementation was simply wrong, in that it was easily
fooled by values that caused collisions either through hashing or
through computing the remainder.</p><p>The solution we have shown above is called hash chaining, where
â€œchainâ€ refers to the list stored in each bucket. The benefit of
hash-chaining is that insertion can still be constant-time: it takes a
constant amount of time to find a bucket, and inserting can be as
cheap as link. Of course, this assumes that we donâ€™t mind duplicates;
otherwise we will pay the same price we saw earlier in
<a href="sets-from-lists.html" data-pltdoc="x">Representing Sets as Lists</a>. But lookup takes time linear in the
size of the bucket (which, with duplicates, could be arbitrarily
larger relative to the number of distinct elements). And even if we
check for duplicates, we run the risk that most or even all the
elements could end up in the same bucket (e.g., suppose the elements
are <code data-lang="pyret" class="sourceCode">"Where"</code>, <code data-lang="pyret" class="sourceCode">"Weird"</code>, <code data-lang="pyret" class="sourceCode">"Wired"</code>,
<code data-lang="pyret" class="sourceCode">"Whine"</code>). In that case, our sophisticated implementation
reduces to the list-based representation and its complexity!</p><p>Thereâ€™s an additional subtlety here. When we check membership of the
string in the list of strings, we have to consider the cost of
comparing each pair of strings. In the worst case, that is
proportional to the length of the shorter string. Usually this is
bounded by a small constant, but one can imagine settings where this
is not guaranteed to be true. However, this same cost has to be borne
by all set implementations; it is not a new complexity introduced
here.</p><p>Thus, in theory, hash-based sets can support insertion and membership
in as little as constant time, and (ignoring the cost of string
comparisons) as much as linear time, where â€œlinearâ€ has the same
caveats about duplicates as the list-based representation. In many
casesâ€”<wbr/>depending on the nature of the data and parameters set for the
arrayâ€”<wbr/>they can be much closer to constant time. As a result, they
tend to be very popular in practice.</p>&#13;
<h4 class="heading">18.4.8Â <a name="(part._bloom-filters)"/>Bloom Filters<a href="#(part._bloom-filters)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Another way to improve the space and time complexity is to relax the
properties we expect of the operations. Right now, set membership
gives perfect answers, in that it answers <code data-lang="pyret" class="sourceCode">true</code> exactly when the
element being checked was previously inserted into the set. But
suppose weâ€™re in a setting where we can accept a more relaxed notion
of correctness, where membership tests can â€œlieâ€ slightly in one
direction or the other (but not both, because that makes the
representation almost useless). Specifically, letâ€™s say that â€œno
means noâ€ (i.e., if the set representation says the element isnâ€™t
present, it really isnâ€™t) but â€œyes sometimes means noâ€ (i.e., if the
set representation says an element is present, sometimes it
might not be). In short, if the set says the element isnâ€™t in it, this
should be guaranteed; but if the set says the element is present,
it may not be. In the latter case, we either need some
otherâ€”<wbr/>more expensiveâ€”<wbr/>technique to determine truth, or we might
just not care.</p><p>Where is such a data structure of use? Suppose we are building a Web
site that uses password-based authentication. Because many passwords
have been leaked in well-publicized breaches, it is safe to assume
that hackers have them and will guess them. As a result, we want to
not allow users to select any of these as passwords. We could use a
hash-table to reject precisely the known leaked passwords. But for
efficiency, we could use this imperfect hash instead. If it says
â€œnoâ€, then we allow the user to use that password. But if it says
â€œyesâ€, then either they are using a password that has been leaked,
or they have an entirely different password that, purely by accident,
has the same hash value, but no matter; we can just disallow that
password as well.A related use is for filtering out
malicious Web sites. The URL shortening system, bitly,
<a href="http://word.bitly.com/post/28558800777/dablooms-an-open-source-scalable-counting-bloom">uses it for this purpose</a>.
Itâ€™s also used by ad networks; hereâ€™s a
<a href="https://youtu.be/T3Bt9Tn6P5c?si=t8U33orccRCgkSw0&amp;t=1277">talk</a>
(the segment from about 20m to about 45m) about that.
            But sometimes, a Bloom filter is overkill,
            as this Cloudflare blog post
            <a href="https://blog.cloudflare.com/when-bloom-filters-dont-bloom/">discusses</a>â€¦</p><p>Another example is in updating databases or memory stores. Suppose we
have a database of records, which we update frequently. It is often
more efficient to maintain a journal of changes: i.e., a list
that sequentially records all the changes that have occurred. At some
interval (say overnight), the journal is â€œflushedâ€, meaning all
these changes are applied to the database proper. But that means every
read operation has become highly inefficient, because it has to check
the entire journal first (for updates) before accessing the
database. Again, here we can use this faulty notion of a hash table:
if the hash of the record locator says â€œnoâ€, then the record
certainly hasnâ€™t been modified and we go directly to the database; if
it says â€œyesâ€ then we have to check the journal.</p><p>We have already seen a simple example implementation of this idea
earlier, when we used a single array, with modular arithmetic, to
represent the set. When an element was not present in the array, we
knew for a fact that it was definitely not present. When the array
indicated an element was present, we couldnâ€™t be sure that what was
present was the exact value we were looking for. To get around this
uncertainty, we used chaining.</p><p>However, there is something else we could have done. Chaining costs
both space (to store all the actual values) and time (to look through
all the values). Suppose, instead, a bucket is only a Boolean
value. This results in a slightly useful, but potentially very
inaccurate, data structure; furthermore, it exhibits correlated
failure tied to the modulus.</p><p>But suppose we have not only one array, but several! When an element
is added to the set, it is added to each array; when checking for
membership, every array is consulted. The set only answers
affirmatively to membership if all the arrays do so.</p><p>Naturally, using multiple arrays offers absolutely no advantage if the
arrays are all the same size: since both insertion and lookup are
deterministic, all will yield the same answer. However, there is a
simple antidote to this: use different array sizes. In particular, by
using array sizes that are relatively prime to one another, we
minimize the odds of a clash (only hashes that are the product of all
the array sizes will fool the array).</p><p>This data structure, called a Bloom Filter, is a
probabilistic data structure. Unlike our earlier set data
structure, this one is not guaranteed to always give the right answer;
but contrary to the
<a href="glossary.html#%28elem._glossary-space-time._tradeoff%29" data-pltdoc="x">â˜› space-time tradeoff</a>, we
save both space and time by changing the
problem slightly to accept incorrect answers. If we know something
about the distribution of hash values, and we have some acceptable
bound of error, we can design hash table sizes so that with high
probability, the Bloom Filter will lie within the acceptable error
bounds.</p>&#13;
<h4 class="heading">18.4.9Â <a name="(part._.Generalizing_from_.Sets_to_.Key-.Values)"/>Generalizing from Sets to Key-Values<a href="#(part._.Generalizing_from_.Sets_to_.Key-.Values)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Above, we focused on sets: that is, a string effectively mapped to a
Boolean value, indicating whether it was present or not. However,
there are many settings where it is valuable to associate one value
with another. For instance, given an identity number we might want to
pull up a personâ€™s records; given a computerâ€™s name, we might want to
retrieve its routing information; given a starâ€™s catalog entry, we
might want its astronomical information. This kind of data structure
is so ubiquitous that it has several names, some of which are more
general and some implying specific implementations: key-value
store, associative array, hash map, dictionary,
etc.</p><p>In general, the names â€œkey-valueâ€ and â€œdictionaryâ€ are useful
because they suggest a behavioral interface. In contrast,
associative array implies the use of arrays, and hash table suggests
the use of an array (and of hashing). In fact, real systems use a
variety of implementation strategies, including balanced binary search
trees. The names â€œkey-valueâ€ and â€œdictionaryâ€ avoid commitment to
a particular implementation. Here, too, â€œdictionaryâ€ evokes a common
mental image of unique words that map to descriptions. The term â€œkey
valueâ€ is even more technically useful because keys are meant to all
be distinct (i.e., no two different key-value pairs can have the same
key; alternatively, one key can map to only one value). This makes
sense because we view this as a generalization of sets, so the keys
are the set elements, which must necessarily have no duplicates; the
values take the place of the Boolean.</p><p>To extend our set representation to handle a dictionary or key-value
store, we need to make a few changes. First, we introduce the
key-value representation:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data KV&lt;T&gt;: kv(key :: String, value :: T) end</code></pre><p>Each bucket is still an empty list, but we understand it to be a list of key-value pairs.</p><p>Previously, we only had <code data-lang="pyret" class="sourceCode">is-in</code> to check whether an element was
present in a set or not. That element is now the key, and we could
have a similar function to check whether the key is present. However,
we rarely want to know just that; in fact, because we already know the
key, we usually want the associated value.</p><p>Therefore, we can just have this one function:We use Pyretâ€™s naming convention of <code data-lang="pyret" class="sourceCode">-now</code> to indicate that this result might change later.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">getkv-now :: &lt;T&gt; String -&gt; T</code></pre><p>Of course, <code data-lang="pyret" class="sourceCode">getkv-now</code> may fail: the key may not be present. That is,
it has become a partial function [<a href="partial-domains.html" data-pltdoc="x">Partial Domains</a>]. We
therefore have all the usual strategies for dealing with partial
functions. Here, for simplicity we choose to return an error if the
key is not present, but all the other strategies we discuss for
handling partiality are valid (and often better in a robust
implementation).</p><p>Similarly, we have:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">setkv-now :: &lt;T&gt; String, T -&gt; Nothing</code></pre><p>This is the generalization of <code data-lang="pyret" class="sourceCode">insert</code>. However, <code data-lang="pyret" class="sourceCode">insert</code>
had no reason to return an error: inserting an element twice was
harmless. However, because keys must now be associated with only one
value, insertion has to check whether the key is already present, and
signal an error otherwise. In short, it is also
partial.This is not partial due to a mathematical reason,
but rather because of state: the same key may have been inserted
previously.</p><p>Once we have agreed on this interface, getting a value is a natural
extension of checking for membership:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun getkv-now(k):
  b = index-of(k)
  r = find({(kvp): kvp.key == k}, buckets.get-now(b))
  cases (Option) r:
    | none =&gt; raise("getkv-now can't find " + k)
    | some(v) =&gt; v.value
  end
end</code></pre><p>Having found the index, we look in the bucket for whether any
key-value pair has the desired key. If it does, then we return the
corresponding value. Otherwise, we error.</p><p>Inserting a key-value pair similarly generalizes adding an element to the set:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun setkv-now(k, v):
  b = index-of(k)
  keys = map(_.key, buckets.get-now(b))
  if member(keys, k):
    raise("setkv-now already has a value for key " + k)
  else:
    buckets.set-now(b, link(kv(k, v), buckets.get-now(b)))
  end
end</code></pre><p>Once again, we check the bucket for whether the key is already
present. If it is, we choose to halt with an error. Otherwise, we make
the key-value pair and link it to the existing bucket contents, and
modify the array to refer to the new list.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Do the above pair of functions do all the necessary error-checking?</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Above, <code data-lang="pyret" class="sourceCode">setkv-now</code> raises an error if a key already has a name associated with it.
A natural variation is to instead override the associated value, so that
the new value is now associated with that key. Modify the implementation to do that
instead, and make sure you test it thoroughly! Note that you may need to modify the
<code data-lang="pyret" class="sourceCode">KV</code> datatype also.</p></blockquote></blockquote><p>This concludes our brief tour of sets (yet again!) and key-value
stores or dictionaries. We have chosen to implement both using arrays,
which required us to employ hashes. For more on string dictionaries,
see the
<a href="https://www.pyret.org/docs/latest/string-dict.html">Pyret
documentation</a>.  Observe that Pyret offers two kinds of dictionaries:
one mutable (like we have shown here) and one (the default)
functional.</p>    
</body>
</html>