<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>17.1Â Introducing GraphsğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>17.1Â Introducing GraphsğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/intro-graphs.html">https://dcic-world.org/2025-08-27/intro-graphs.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Understanding_.Graphs%29" class="toclink" data-pltdoc="x">17.1.1<span class="hspace">Â </span>Understanding Graphs</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Representations%29" class="toclink" data-pltdoc="x">17.1.2<span class="hspace">Â </span>Representations</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._string-keys%29" class="toclink" data-pltdoc="x">17.1.2.1<span class="hspace">Â </span>Links by Name</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Links_by_.Indices%29" class="toclink" data-pltdoc="x">17.1.2.2<span class="hspace">Â </span>Links by Indices</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.A_.List_of_.Edges%29" class="toclink" data-pltdoc="x">17.1.2.3<span class="hspace">Â </span>A List of Edges</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Abstracting_.Representations%29" class="toclink" data-pltdoc="x">17.1.2.4<span class="hspace">Â </span>Abstracting Representations</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._complexity-of-graphs%29" class="toclink" data-pltdoc="x">17.1.3<span class="hspace">Â </span>Measuring Complexity for Graphs</a></p></td></tr></table><p>In <a href="Sharing_and_Equality.html#%28part._acyc-to-cyc%29" data-pltdoc="x">From Acyclicity to Cycles</a> we introduced a special kind of sharing:
when the data become <span style="font-style: italic">cyclic</span>, i.e., there exist values such that
traversing other reachable values from them eventually gets you back
to the value at which you began. Data that have this characteristic
are called <span style="font-style: italic">graphs</span>.<span class="refelem"><span class="refcolumn"><span class="refcontent">Technically, a cycle is not
necessary to be a graph; a tree or a <span class="Smaller">DAG</span> is also regarded as a
(degenerate) graph. In this section, however, we are interested in
graphs that have the potential for cycles.</span></span></span></p><p>Lots of very important data are graphs. For instance, the people and
connections in social media form a graph: the people are <span style="font-style: italic">nodes</span>
or <span style="font-style: italic">vertices</span> and the connections (such as friendships) are
<span style="font-style: italic">links</span> or <span style="font-style: italic">edges</span>. They form a graph because for many
people, if you follow their friends and then the friends of their
friends, you will eventually get back to the person you started
with. (Most simply, this happens when two people are each othersâ€™
friends.) The Web, similarly is a graph: the nodes are pages and the
edges are links between pages. The Internet is a graph: the nodes are
machines and the edges are links between machines. A transportation
network is a graph: e.g., cities are nodes and the edges are
transportation links between them. And so on. Therefore, it is
essential to understand graphs to represent and process a great deal
of interesting real-world data.</p><p>Graphs are important and interesting for not only practical but also
principled reasons. The property that a traversal can end up where it
began means that traditional methods of processing will no longer
work: if it blindly processes every node it visits, it could end up in
an infinite loop. Therefore, we need better structural recipes for our
programs. In addition, graphs have a very rich structure, which lends
itself to several interesting computations over them. We will study
both these aspects of graphs below.</p><section class="SsectionLevel4" id="section 17.1.1"><h4 class="heading">17.1.1<span class="stt">Â </span><a name="(part._.Understanding_.Graphs)"/>Understanding Graphs<span class="button-group"><a href="#(part._.Understanding_.Graphs)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">Consider again the binary trees we saw earlier
[<a href="Sharing_and_Equality.html#%28part._identical-eq%29" data-pltdoc="x">Re-Examining Equality</a>]. Letâ€™s now try to distort the definition of
a â€œtreeâ€ by creating ones with <span class="emph">cycles</span>, i.e., trees with nodes
that point back to themselves (in the sense of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span>). As
we saw earlier [<a href="Sharing_and_Equality.html#%28part._acyc-to-cyc%29" data-pltdoc="x">From Acyclicity to Cycles</a>], it is not completely
straightforward to create such a structure, but what we saw earlier
[<a href="func-as-data.html#%28part._streams-from-funs%29" data-pltdoc="x">Streams From Functions</a>] can help us here, by letting us
<span class="emph">suspend</span> the evaluation of the cyclic link. That is, we have to
not only use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec</code></span>, we must also use a function to delay
evaluation. In turn, we have to update the annotations on the
fields. Since these are not going to be â€œtreesâ€ any more, weâ€™ll use
a name that is suggestive but not outright incorrect:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data BinT:
  | leaf
  | node(v, l :: ( -&gt; BinT), r :: ( -&gt; BinT))
end</code></pre></div></div></div><div class="SIntrapara">Now letâ€™s try to construct some cyclic values. Here are a few
examples:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec tr = node("rec", lam(): tr end, lam(): tr end)
t0 = node(0, lam(): leaf end, lam(): leaf end)
t1 = node(1, lam(): t0 end, lam(): t0 end)
t2 = node(2, lam(): t1 end, lam(): t1 end)</code></pre></div></div></div><div class="SIntrapara">Now letâ€™s try to compute the size of a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">BinT</code></span>. Hereâ€™s the obvious
program:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sizeinf(t :: BinT) -&gt; Number:
  cases (BinT) t:
    | leaf =&gt; 0
    | node(v, l, r) =&gt;
      ls = sizeinf(l())
      rs = sizeinf(r())
      1 + ls + rs
  end
end</code></pre></div></div></div><div class="SIntrapara">(Weâ€™ll see why we call it <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sizeinf</code></span> in a moment.)</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What happens when we call <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sizeinf(tr)</code></span>?</p></blockquote></blockquote><p>It goes into an infinite loop: hence the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">inf</code></span> in its name.</p><p/><div class="SIntrapara">There are two very different meanings for â€œsizeâ€. One is, â€œHow many
times can we traverse an edge?â€ The other is, â€œHow many distinct
nodes were constructed as part of the data structure?â€ With trees,
<span class="emph">by definition</span>, these two are the same. With a <span class="Smaller">DAG</span> the former
exceeds the latter but only by a finite amount. With a general graph,
the former can exceed the latter by an infinite amount. In the case of
a datum like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">tr</code></span>, we can in fact traverse edges an infinite
number of times. But the total number of constructed nodes is only
one! Letâ€™s write this as test cases in terms of a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size</code></span>
function, to be defined:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  size(tr) is 1
  size(t0) is 1
  size(t1) is 2
  size(t2) is 3
end</code></pre></div></div></div><p>Itâ€™s clear that we need to somehow <span class="emph">remember</span> what nodes we have
visited previously: that is, we need a computation with â€œmemoryâ€. In
principle this is easy: we just create an extra data structure that
checks whether a node has already been counted. As long as we update
this data structure correctly, we should be all set. Hereâ€™s an
implementation.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sizect(t :: BinT) -&gt; Number:
  fun szacc(shadow t :: BinT, seen :: List&lt;BinT&gt;) -&gt; Number:
    if has-id(seen, t):
      0
    else:
      cases (BinT) t:
        | leaf =&gt; 0
        | node(v, l, r) =&gt;
          ns = link(t, seen)
          ls = szacc(l(), ns)
          rs = szacc(r(), ns)
          1 + ls + rs
      end
    end
  end
  szacc(t, empty)
end</code></pre></div></div><p/><div class="SIntrapara">The extra parameter, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">seen</code></span>, is called an <span style="font-style: italic">accumulator</span>,
because it â€œaccumulatesâ€ the list of seen nodes.<span class="refelem"><span class="refcolumn"><span class="refcontent">Note
that this could just as well be a set; it doesnâ€™t have to be a list.</span></span></span>
The support function it needs checks whether a given node has already
been seen:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun has-id&lt;A&gt;(seen :: List&lt;A&gt;, t :: A):
  cases (List) seen:
    | empty =&gt; false
    | link(f, r) =&gt;
      if f &lt;=&gt; t: true
      else: has-id(r, t)
      end
  end
end</code></pre></div></div></div><p>How does this do? Well, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sizect(tr)</code></span> is indeed <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>, but
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sizect(t1)</code></span> is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sizect(t2)</code></span> is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">7</code></span>!</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Explain why these answers came out as they did.</p></blockquote></blockquote><p/><div class="SIntrapara">The fundamental problem is that weâ€™re not doing a very good job of
remembering! Look at this pair of lines:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ls = szacc(l(), ns)
rs = szacc(r(), ns)
</code></pre></div></div></div><div class="SIntrapara">The nodes seen while traversing the left branch are effectively
forgotten, because the only nodes we remember when traversing the
right branch are those in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ns</code></span>: namely, the current node and
those visited â€œhigher upâ€. As a result, any nodes that â€œcross
sidesâ€ are counted twice.</div><p>The remedy for this, therefore, is to remember <span class="emph">every</span> node we
visit. Then, when we have no more nodes to process, instead of
returning only the size, we should return <span class="emph">all</span> the nodes visited
until now. This ensures that nodes that have multiple paths to them
are visited on only one path, not more than once. The logic for this
is to return two values from each traversalâ€”<wbr/>the size and all the
visited nodesâ€”<wbr/>and not just one.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size(t :: BinT) -&gt; Number:
  fun szacc(shadow t :: BinT, seen :: List&lt;BinT&gt;)
    -&gt; {n :: Number, s :: List&lt;BinT&gt;}:
    if has-id(seen, t):
      {n: 0, s: seen}
    else:
      cases (BinT) t:
        | leaf =&gt; {n: 0, s: seen}
        | node(v, l, r) =&gt;
          ns = link(t, seen)
          ls = szacc(l(), ns)
          rs = szacc(r(), ls.s)
          {n: 1 + ls.n + rs.n, s: rs.s}
      end
    end
  end
  szacc(t, empty).n
end</code></pre></div></div><p>Sure enough, this function satisfies the above tests.</p></section><section class="SsectionLevel4" id="section 17.1.2"><h4 class="heading">17.1.2<span class="stt">Â </span><a name="(part._.Representations)"/>Representations<span class="button-group"><a href="#(part._.Representations)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>The representation weâ€™ve seen above for graphs is certainly a start
towards creating cyclic data, but itâ€™s not very elegant. Itâ€™s both
error-prone and inelegant to have to write <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span> everywhere, and
remember to apply functions to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">()</code></span> to obtain the actual
values. Therefore, here we explore other representations of graphs
that are more conventional and also much simpler to manipulate.</p><p/><div class="SIntrapara">There are numerous ways to represent graphs, and the choice of
representation depends on several factors:
</div><div class="SIntrapara"><ol><li><p>The structure of the graph, and in particular, its
<span style="font-style: italic">density</span>. We will discuss this further later
[<a href="#%28part._complexity-of-graphs%29" data-pltdoc="x">Measuring Complexity for Graphs</a>].</p></li><li><p>The representation in which the data are provided by external
sources. Sometimes it may be easier to simply adapt to their
representation; in particular, in some cases there may not even be a
choice.</p></li><li><p>The features provided by the programming language, which make
some representations much harder to use than others.</p></li></ol></div><div class="SIntrapara">In [<a href="part_sets.html" data-pltdoc="x">Several Variations on Sets</a>], we explore the idea of having many
different representations for one datatype. As we will see, this is
very true of graphs as well. Therefore, it would be best if we could
arrive at a common <span style="font-style: italic">interface</span> to process graphs, so that all
later programs can be written in terms of this interface, without
overly depending on the underlying representation.</div><p/><div class="SIntrapara">In terms of representations, there are three main things we need:
</div><div class="SIntrapara"><ol><li><p>A way to construct graphs.</p></li><li><p>A way to identify (i.e., tell apart) nodes or vertices in a graph.</p></li><li><p>Given a way to identify nodes, a way to get that nodeâ€™s
neighbors in the graph.</p></li></ol></div><div class="SIntrapara">Any interface that satisfies these properties will suffice. For
simplicity, we will focus on the second and third of these and not
abstract over the process of constructing a graph.</div><p>Our running example will be a graph whose nodes are cities in the
United States and edges are direct flight connections between
them:</p><p><img src="../Images/149f40c8773898400ea9f6d76e084087.png" alt="" width="640" height="412" data-original-src="https://dcic-world.org/2025-08-27/us-flight-map.png"/></p><section class="SsectionLevel5" id="section 17.1.2.1"><h5 class="heading">17.1.2.1<span class="stt">Â </span><a name="(part._string-keys)"/>Links by Name<span class="button-group"><a href="#(part._string-keys)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Hereâ€™s our first representation. We will assume that every node has a
unique name (such a name, when used to look up information in a
repository of data, is sometimes called a <span style="font-style: italic">key</span>). A node is then a
key, some information about that node, and a list of keys that refer
to other nodes:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">type Key = String

data KeyedNode:
  | keyed-node(key :: Key, content, adj :: List&lt;Key&gt;)
end

type KNGraph = List&lt;KeyedNode&gt;

type Node = KeyedNode
type Graph = KNGraph</code></pre></div></div></div><div class="SIntrapara">(Here weâ€™re assuming our keys are strings.)</div><p/><div class="SIntrapara">Hereâ€™s a concrete instance of such a graph:<span class="refelem"><span class="refcolumn"><span class="refcontent">The prefix
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">kn-</code></span> stands for â€œkeyed nodeâ€.</span></span></span>
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">kn-cities :: Graph = block:
  knWAS = keyed-node("was", "Washington", [list: "chi", "den", "saf", "hou", "pvd"])
  knORD = keyed-node("chi", "Chicago", [list: "was", "saf", "pvd"])
  knBLM = keyed-node("bmg", "Bloomington", [list: ])
  knHOU = keyed-node("hou", "Houston", [list: "was", "saf"])
  knDEN = keyed-node("den", "Denver", [list: "was", "saf"])
  knSFO = keyed-node("saf", "San Francisco", [list: "was", "den", "chi", "hou"])
  knPVD = keyed-node("pvd", "Providence", [list: "was", "chi"])
  [list: knWAS, knORD, knBLM, knHOU, knDEN, knSFO, knPVD]
end</code></pre></div></div></div><p/><div class="SIntrapara">Given a key, hereâ€™s how we look up its neighbor:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun find-kn(key :: Key, graph :: Graph) -&gt; Node:
  matches = for filter(n from graph):
    n.key == key
  end
  matches.first # there had better be exactly one!
end</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Convert the comment in the function into an invariant about the
datum. Express this invariant as a refinement and add it to the
declaration of graphs.</p></blockquote></blockquote><p/><div class="SIntrapara">With this support, we can look up neighbors easily:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun kn-neighbors(city :: Key,  graph :: Graph) -&gt; List&lt;Key&gt;:
  city-node = find-kn(city, graph)
  city-node.adj
end</code></pre></div></div></div><p/><div class="SIntrapara">When it comes to testing, some tests are easy to write. Others,
however, might require describing entire nodes, which can be unwieldy,
so for the purpose of checking our implementation it suffices to
examine just a part of the result:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  ns = kn-neighbors("hou", kn-cities)

  ns is [list: "was", "saf"]

  map(_.content, map(find-kn(_, kn-cities), ns)) is
    [list: "Washington", "San Francisco"]
end</code></pre></div></div></div></section><section class="SsectionLevel5" id="section 17.1.2.2"><h5 class="heading">17.1.2.2<span class="stt">Â </span><a name="(part._.Links_by_.Indices)"/>Links by Indices<span class="button-group"><a href="#(part._.Links_by_.Indices)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>In some languages, it is common to use numbers as names. This is
especially useful when numbers can be used to get access to an element
in a constant amount of time (in return for having a bound on the
number of elements that can be accessed). Here, we use a listâ€”<wbr/>which
does not provide constant-time access to arbitrary elementsâ€”<wbr/>to
illustrate this concept. Most of this will look very similar to what
we had before; weâ€™ll comment on a key difference at the end.</p><p/><div class="SIntrapara">First, the datatype:<span class="refelem"><span class="refcolumn"><span class="refcontent">The prefix <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ix-</code></span> stands for
â€œindexedâ€.</span></span></span>
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data IndexedNode:
  | idxed-node(content, adj :: List&lt;Number&gt;)
end

type IXGraph = List&lt;IndexedNode&gt;

type Node = IndexedNode
type Graph = IXGraph</code></pre></div></div></div><div class="SIntrapara">Our graph now looks like this:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ix-cities :: Graph = block:
  inWAS = idxed-node("Washington", [list: 1, 4, 5, 3, 6])
  inORD = idxed-node("Chicago", [list: 0, 5, 6])
  inBLM = idxed-node("Bloomington", [list: ])
  inHOU = idxed-node("Houston", [list: 0, 5])
  inDEN = idxed-node("Denver", [list: 0, 5])
  inSFO = idxed-node("San Francisco", [list: 0, 4, 3])
  inPVD = idxed-node("Providence", [list: 0, 1])
  [list: inWAS, inORD, inBLM, inHOU, inDEN, inSFO, inPVD]
end</code></pre></div></div></div><div class="SIntrapara">where weâ€™re assuming indices begin at <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>. To find a node:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun find-ix(idx :: Key, graph :: Graph) -&gt; Node:
  lists.get(graph, idx)
end</code></pre></div></div></div><div class="SIntrapara">We can then find neighbors almost as before:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun ix-neighbors(city :: Key,  graph :: Graph) -&gt; List&lt;Key&gt;:
  city-node = find-ix(city, graph)
  city-node.adj
end</code></pre></div></div></div><div class="SIntrapara">Finally, our tests also look similar:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  ns = ix-neighbors(3, ix-cities)

  ns is [list: 0, 5]

  map(_.content, map(find-ix(_, ix-cities), ns)) is
    [list: "Washington", "San Francisco"]
end</code></pre></div></div></div><p>Something deeper is going on here. The keyed nodes have
<span style="font-style: italic">intrinsic</span> keys: the key is part of the datum itself. Thus, given
just a node, we can determine its key. In contrast, the indexed nodes
represent <span style="font-style: italic">extrinsic</span> keys: the keys are determined outside the
datum, and in particular by the position in some other data
structure. Given a node and not the entire graph, we cannot know for
what its key is. Even given the entire graph, we can only determine
its key by using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span>, which is a rather unsatisfactory
approach to recovering fundamental information. This highlights a
weakness of using extrinsically keyed representations of
information. (In return, extrinsically keyed representations are
easier to reassemble into new collections of data, because there is no
danger of keys clashing: there are no intrinsic keys to clash.)</p></section><section class="SsectionLevel5" id="section 17.1.2.3"><h5 class="heading">17.1.2.3<span class="stt">Â </span><a name="(part._.A_.List_of_.Edges)"/>A List of Edges<span class="button-group"><a href="#(part._.A_.List_of_.Edges)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">The representations we have seen until now have given priority
to nodes, making edges simply a part of the information in a node. We
could, instead, use a representation that makes edges primary, and
nodes simply be the entities that lie at their
ends:<span class="refelem"><span class="refcolumn"><span class="refcontent">The prefix <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">le-</code></span> stands for â€œlist of edgesâ€.</span></span></span>
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Edge:
  | edge(src :: String, dst :: String)
end

type LEGraph = List&lt;Edge&gt;

type Graph = LEGraph</code></pre></div></div></div><div class="SIntrapara">Then, our flight network becomes:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">le-cities :: Graph =
  [list:
    edge("Washington", "Chicago"),
    edge("Washington", "Denver"),
    edge("Washington", "San Francisco"),
    edge("Washington", "Houston"),
    edge("Washington", "Providence"),
    edge("Chicago", "Washington"),
    edge("Chicago", "San Francisco"),
    edge("Chicago", "Providence"),
    edge("Houston", "Washington"),
    edge("Houston", "San Francisco"),
    edge("Denver", "Washington"),
    edge("Denver", "San Francisco"),
    edge("San Francisco", "Washington"),
    edge("San Francisco", "Denver"),
    edge("San Francisco", "Houston"),
    edge("Providence", "Washington"),
    edge("Providence", "Chicago") ]</code></pre></div></div></div><div class="SIntrapara">Observe that in this representation, nodes that are not connected to
other nodes in the graph simply never show up! Youâ€™d therefore need
an auxilliary data structure to keep track of all the nodes.</div><p/><div class="SIntrapara">To obtain the set of neighbors:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun le-neighbors(city :: Key, graph :: Graph) -&gt; List&lt;Key&gt;:
  neighboring-edges = for filter(e from graph):
    city == e.src
  end
  names = for map(e from neighboring-edges): e.dst end
  names
end</code></pre></div></div></div><div class="SIntrapara">And to be sure:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  le-neighbors("Houston", le-cities) is
    [list: "Washington", "San Francisco"]
end</code></pre></div></div></div><div class="SIntrapara">However, this representation makes it difficult to store complex
information about a node without replicating it. Because nodes usually
have rich information while the information about edges tends to be
weaker, we often prefer node-centric representations. Of course, an
alternative is to think of the node names as keys into some other data
structure from which we can retrieve rich information about nodes.</div></section><section class="SsectionLevel5" id="section 17.1.2.4"><h5 class="heading">17.1.2.4<span class="stt">Â </span><a name="(part._.Abstracting_.Representations)"/>Abstracting Representations<span class="button-group"><a href="#(part._.Abstracting_.Representations)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>We would like a general representation that lets us abstract over the
specific implementations. We will assume that broadly we have
available a notion of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Node</code></span> that has <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">content</code></span>, a notion of
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Key</code></span>s (whether or not intrinsic), and a way to obtain the
neighborsâ€”<wbr/>a list of keysâ€”<wbr/>given a key and a graph. This is
sufficient for what follows. However, we still need to choose concrete
keys to write examples and tests. For simplicity, weâ€™ll use
string keys [<a href="#%28part._string-keys%29" data-pltdoc="x">Links by Name</a>].</p></section></section><section class="SsectionLevel4" id="section 17.1.3"><h4 class="heading">17.1.3<span class="stt">Â </span><a name="(part._complexity-of-graphs)"/>Measuring Complexity for Graphs<span class="button-group"><a href="#(part._complexity-of-graphs)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Before we begin to define algorithms over graphs, we should consider
how to measure the <span class="emph">size</span> of a graph. A graph has two components:
its nodes and its edges. Some algorithms are going to focus on nodes
(e.g., visiting each of them), while others will focus on edges, and
some will care about both. So which do we use as the basis for
counting operations: nodes or edges?</p><p/><div class="SIntrapara">It would help if we can reduce these two measures to one. To see
whether thatâ€™s possible, suppose a graph has \(k\) nodes. Then its
number of edges has a wide range, with these two extremes:
</div><div class="SIntrapara"><ul><li><p>No two nodes are connected. Then there are no edges at all.</p></li><li><p>Every two nodes is connected. Then there are essentially as
many edges as the number of <span class="emph">pairs</span> of nodes.</p></li></ul></div><div class="SIntrapara">The number of nodes can thus be significantly less or even
significantly more than the number of edges. Were this difference a
matter of constants, we could have ignored it; but itâ€™s not. As a
graph tends towards the former extreme, the ratio of nodes to edges
approaches \(k\) (or even exceeds it, in the odd case where there are
no edges, but this graph is not very interesting); as it tends towards
the latter, it is the ratio of edges to nodes that approaches
\(k^2\). In other words, neither measure subsumes the other by a
constant independent of the graph.</div><p>Therefore, when we want to speak of the complexity of algorithms over
graphs, we have to consider the sizes of <span class="emph">both</span> the number of
nodes and edges. In a <span style="font-style: italic">connected</span> graph<span class="refelem"><span class="refcolumn"><span class="refcontent">A graph is
connected if, from every node, we can traverse edges to get to every
other node.</span></span></span>, however, there must be at least as many edges as nodes,
which means the number of edges dominates the number of nodes. Since
we are usually processing connected graphs, or connected parts of
graphs one at a time, we can bound the number of nodes by the number
of edges.</p></section>&#13;
<h4 class="heading">17.1.1<span class="stt">Â </span><a name="(part._.Understanding_.Graphs)"/>Understanding Graphs<span class="button-group"><a href="#(part._.Understanding_.Graphs)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">Consider again the binary trees we saw earlier
[<a href="Sharing_and_Equality.html#%28part._identical-eq%29" data-pltdoc="x">Re-Examining Equality</a>]. Letâ€™s now try to distort the definition of
a â€œtreeâ€ by creating ones with <span class="emph">cycles</span>, i.e., trees with nodes
that point back to themselves (in the sense of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span>). As
we saw earlier [<a href="Sharing_and_Equality.html#%28part._acyc-to-cyc%29" data-pltdoc="x">From Acyclicity to Cycles</a>], it is not completely
straightforward to create such a structure, but what we saw earlier
[<a href="func-as-data.html#%28part._streams-from-funs%29" data-pltdoc="x">Streams From Functions</a>] can help us here, by letting us
<span class="emph">suspend</span> the evaluation of the cyclic link. That is, we have to
not only use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec</code></span>, we must also use a function to delay
evaluation. In turn, we have to update the annotations on the
fields. Since these are not going to be â€œtreesâ€ any more, weâ€™ll use
a name that is suggestive but not outright incorrect:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data BinT:
  | leaf
  | node(v, l :: ( -&gt; BinT), r :: ( -&gt; BinT))
end</code></pre></div></div></div><div class="SIntrapara">Now letâ€™s try to construct some cyclic values. Here are a few
examples:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec tr = node("rec", lam(): tr end, lam(): tr end)
t0 = node(0, lam(): leaf end, lam(): leaf end)
t1 = node(1, lam(): t0 end, lam(): t0 end)
t2 = node(2, lam(): t1 end, lam(): t1 end)</code></pre></div></div></div><div class="SIntrapara">Now letâ€™s try to compute the size of a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">BinT</code></span>. Hereâ€™s the obvious
program:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sizeinf(t :: BinT) -&gt; Number:
  cases (BinT) t:
    | leaf =&gt; 0
    | node(v, l, r) =&gt;
      ls = sizeinf(l())
      rs = sizeinf(r())
      1 + ls + rs
  end
end</code></pre></div></div></div><div class="SIntrapara">(Weâ€™ll see why we call it <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sizeinf</code></span> in a moment.)</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What happens when we call <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sizeinf(tr)</code></span>?</p></blockquote></blockquote><p>It goes into an infinite loop: hence the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">inf</code></span> in its name.</p><p/><div class="SIntrapara">There are two very different meanings for â€œsizeâ€. One is, â€œHow many
times can we traverse an edge?â€ The other is, â€œHow many distinct
nodes were constructed as part of the data structure?â€ With trees,
<span class="emph">by definition</span>, these two are the same. With a <span class="Smaller">DAG</span> the former
exceeds the latter but only by a finite amount. With a general graph,
the former can exceed the latter by an infinite amount. In the case of
a datum like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">tr</code></span>, we can in fact traverse edges an infinite
number of times. But the total number of constructed nodes is only
one! Letâ€™s write this as test cases in terms of a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size</code></span>
function, to be defined:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  size(tr) is 1
  size(t0) is 1
  size(t1) is 2
  size(t2) is 3
end</code></pre></div></div></div><p>Itâ€™s clear that we need to somehow <span class="emph">remember</span> what nodes we have
visited previously: that is, we need a computation with â€œmemoryâ€. In
principle this is easy: we just create an extra data structure that
checks whether a node has already been counted. As long as we update
this data structure correctly, we should be all set. Hereâ€™s an
implementation.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sizect(t :: BinT) -&gt; Number:
  fun szacc(shadow t :: BinT, seen :: List&lt;BinT&gt;) -&gt; Number:
    if has-id(seen, t):
      0
    else:
      cases (BinT) t:
        | leaf =&gt; 0
        | node(v, l, r) =&gt;
          ns = link(t, seen)
          ls = szacc(l(), ns)
          rs = szacc(r(), ns)
          1 + ls + rs
      end
    end
  end
  szacc(t, empty)
end</code></pre></div></div><p/><div class="SIntrapara">The extra parameter, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">seen</code></span>, is called an <span style="font-style: italic">accumulator</span>,
because it â€œaccumulatesâ€ the list of seen nodes.<span class="refelem"><span class="refcolumn"><span class="refcontent">Note
that this could just as well be a set; it doesnâ€™t have to be a list.</span></span></span>
The support function it needs checks whether a given node has already
been seen:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun has-id&lt;A&gt;(seen :: List&lt;A&gt;, t :: A):
  cases (List) seen:
    | empty =&gt; false
    | link(f, r) =&gt;
      if f &lt;=&gt; t: true
      else: has-id(r, t)
      end
  end
end</code></pre></div></div></div><p>How does this do? Well, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sizect(tr)</code></span> is indeed <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>, but
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sizect(t1)</code></span> is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sizect(t2)</code></span> is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">7</code></span>!</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Explain why these answers came out as they did.</p></blockquote></blockquote><p/><div class="SIntrapara">The fundamental problem is that weâ€™re not doing a very good job of
remembering! Look at this pair of lines:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ls = szacc(l(), ns)
rs = szacc(r(), ns)
</code></pre></div></div></div><div class="SIntrapara">The nodes seen while traversing the left branch are effectively
forgotten, because the only nodes we remember when traversing the
right branch are those in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ns</code></span>: namely, the current node and
those visited â€œhigher upâ€. As a result, any nodes that â€œcross
sidesâ€ are counted twice.</div><p>The remedy for this, therefore, is to remember <span class="emph">every</span> node we
visit. Then, when we have no more nodes to process, instead of
returning only the size, we should return <span class="emph">all</span> the nodes visited
until now. This ensures that nodes that have multiple paths to them
are visited on only one path, not more than once. The logic for this
is to return two values from each traversalâ€”<wbr/>the size and all the
visited nodesâ€”<wbr/>and not just one.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size(t :: BinT) -&gt; Number:
  fun szacc(shadow t :: BinT, seen :: List&lt;BinT&gt;)
    -&gt; {n :: Number, s :: List&lt;BinT&gt;}:
    if has-id(seen, t):
      {n: 0, s: seen}
    else:
      cases (BinT) t:
        | leaf =&gt; {n: 0, s: seen}
        | node(v, l, r) =&gt;
          ns = link(t, seen)
          ls = szacc(l(), ns)
          rs = szacc(r(), ls.s)
          {n: 1 + ls.n + rs.n, s: rs.s}
      end
    end
  end
  szacc(t, empty).n
end</code></pre></div></div><p>Sure enough, this function satisfies the above tests.</p>&#13;
<h4 class="heading">17.1.2<span class="stt">Â </span><a name="(part._.Representations)"/>Representations<span class="button-group"><a href="#(part._.Representations)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>The representation weâ€™ve seen above for graphs is certainly a start
towards creating cyclic data, but itâ€™s not very elegant. Itâ€™s both
error-prone and inelegant to have to write <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span> everywhere, and
remember to apply functions to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">()</code></span> to obtain the actual
values. Therefore, here we explore other representations of graphs
that are more conventional and also much simpler to manipulate.</p><p/><div class="SIntrapara">There are numerous ways to represent graphs, and the choice of
representation depends on several factors:
</div><div class="SIntrapara"><ol><li><p>The structure of the graph, and in particular, its
<span style="font-style: italic">density</span>. We will discuss this further later
[<a href="#%28part._complexity-of-graphs%29" data-pltdoc="x">Measuring Complexity for Graphs</a>].</p></li><li><p>The representation in which the data are provided by external
sources. Sometimes it may be easier to simply adapt to their
representation; in particular, in some cases there may not even be a
choice.</p></li><li><p>The features provided by the programming language, which make
some representations much harder to use than others.</p></li></ol></div><div class="SIntrapara">In [<a href="part_sets.html" data-pltdoc="x">Several Variations on Sets</a>], we explore the idea of having many
different representations for one datatype. As we will see, this is
very true of graphs as well. Therefore, it would be best if we could
arrive at a common <span style="font-style: italic">interface</span> to process graphs, so that all
later programs can be written in terms of this interface, without
overly depending on the underlying representation.</div><p/><div class="SIntrapara">In terms of representations, there are three main things we need:
</div><div class="SIntrapara"><ol><li><p>A way to construct graphs.</p></li><li><p>A way to identify (i.e., tell apart) nodes or vertices in a graph.</p></li><li><p>Given a way to identify nodes, a way to get that nodeâ€™s
neighbors in the graph.</p></li></ol></div><div class="SIntrapara">Any interface that satisfies these properties will suffice. For
simplicity, we will focus on the second and third of these and not
abstract over the process of constructing a graph.</div><p>Our running example will be a graph whose nodes are cities in the
United States and edges are direct flight connections between
them:</p><p><img src="../Images/149f40c8773898400ea9f6d76e084087.png" alt="" width="640" height="412" data-original-src="https://dcic-world.org/2025-08-27/us-flight-map.png"/></p><section class="SsectionLevel5" id="section 17.1.2.1"><h5 class="heading">17.1.2.1<span class="stt">Â </span><a name="(part._string-keys)"/>Links by Name<span class="button-group"><a href="#(part._string-keys)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Hereâ€™s our first representation. We will assume that every node has a
unique name (such a name, when used to look up information in a
repository of data, is sometimes called a <span style="font-style: italic">key</span>). A node is then a
key, some information about that node, and a list of keys that refer
to other nodes:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">type Key = String

data KeyedNode:
  | keyed-node(key :: Key, content, adj :: List&lt;Key&gt;)
end

type KNGraph = List&lt;KeyedNode&gt;

type Node = KeyedNode
type Graph = KNGraph</code></pre></div></div></div><div class="SIntrapara">(Here weâ€™re assuming our keys are strings.)</div><p/><div class="SIntrapara">Hereâ€™s a concrete instance of such a graph:<span class="refelem"><span class="refcolumn"><span class="refcontent">The prefix
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">kn-</code></span> stands for â€œkeyed nodeâ€.</span></span></span>
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">kn-cities :: Graph = block:
  knWAS = keyed-node("was", "Washington", [list: "chi", "den", "saf", "hou", "pvd"])
  knORD = keyed-node("chi", "Chicago", [list: "was", "saf", "pvd"])
  knBLM = keyed-node("bmg", "Bloomington", [list: ])
  knHOU = keyed-node("hou", "Houston", [list: "was", "saf"])
  knDEN = keyed-node("den", "Denver", [list: "was", "saf"])
  knSFO = keyed-node("saf", "San Francisco", [list: "was", "den", "chi", "hou"])
  knPVD = keyed-node("pvd", "Providence", [list: "was", "chi"])
  [list: knWAS, knORD, knBLM, knHOU, knDEN, knSFO, knPVD]
end</code></pre></div></div></div><p/><div class="SIntrapara">Given a key, hereâ€™s how we look up its neighbor:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun find-kn(key :: Key, graph :: Graph) -&gt; Node:
  matches = for filter(n from graph):
    n.key == key
  end
  matches.first # there had better be exactly one!
end</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Convert the comment in the function into an invariant about the
datum. Express this invariant as a refinement and add it to the
declaration of graphs.</p></blockquote></blockquote><p/><div class="SIntrapara">With this support, we can look up neighbors easily:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun kn-neighbors(city :: Key,  graph :: Graph) -&gt; List&lt;Key&gt;:
  city-node = find-kn(city, graph)
  city-node.adj
end</code></pre></div></div></div><p/><div class="SIntrapara">When it comes to testing, some tests are easy to write. Others,
however, might require describing entire nodes, which can be unwieldy,
so for the purpose of checking our implementation it suffices to
examine just a part of the result:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  ns = kn-neighbors("hou", kn-cities)

  ns is [list: "was", "saf"]

  map(_.content, map(find-kn(_, kn-cities), ns)) is
    [list: "Washington", "San Francisco"]
end</code></pre></div></div></div></section><section class="SsectionLevel5" id="section 17.1.2.2"><h5 class="heading">17.1.2.2<span class="stt">Â </span><a name="(part._.Links_by_.Indices)"/>Links by Indices<span class="button-group"><a href="#(part._.Links_by_.Indices)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>In some languages, it is common to use numbers as names. This is
especially useful when numbers can be used to get access to an element
in a constant amount of time (in return for having a bound on the
number of elements that can be accessed). Here, we use a listâ€”<wbr/>which
does not provide constant-time access to arbitrary elementsâ€”<wbr/>to
illustrate this concept. Most of this will look very similar to what
we had before; weâ€™ll comment on a key difference at the end.</p><p/><div class="SIntrapara">First, the datatype:<span class="refelem"><span class="refcolumn"><span class="refcontent">The prefix <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ix-</code></span> stands for
â€œindexedâ€.</span></span></span>
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data IndexedNode:
  | idxed-node(content, adj :: List&lt;Number&gt;)
end

type IXGraph = List&lt;IndexedNode&gt;

type Node = IndexedNode
type Graph = IXGraph</code></pre></div></div></div><div class="SIntrapara">Our graph now looks like this:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ix-cities :: Graph = block:
  inWAS = idxed-node("Washington", [list: 1, 4, 5, 3, 6])
  inORD = idxed-node("Chicago", [list: 0, 5, 6])
  inBLM = idxed-node("Bloomington", [list: ])
  inHOU = idxed-node("Houston", [list: 0, 5])
  inDEN = idxed-node("Denver", [list: 0, 5])
  inSFO = idxed-node("San Francisco", [list: 0, 4, 3])
  inPVD = idxed-node("Providence", [list: 0, 1])
  [list: inWAS, inORD, inBLM, inHOU, inDEN, inSFO, inPVD]
end</code></pre></div></div></div><div class="SIntrapara">where weâ€™re assuming indices begin at <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>. To find a node:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun find-ix(idx :: Key, graph :: Graph) -&gt; Node:
  lists.get(graph, idx)
end</code></pre></div></div></div><div class="SIntrapara">We can then find neighbors almost as before:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun ix-neighbors(city :: Key,  graph :: Graph) -&gt; List&lt;Key&gt;:
  city-node = find-ix(city, graph)
  city-node.adj
end</code></pre></div></div></div><div class="SIntrapara">Finally, our tests also look similar:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  ns = ix-neighbors(3, ix-cities)

  ns is [list: 0, 5]

  map(_.content, map(find-ix(_, ix-cities), ns)) is
    [list: "Washington", "San Francisco"]
end</code></pre></div></div></div><p>Something deeper is going on here. The keyed nodes have
<span style="font-style: italic">intrinsic</span> keys: the key is part of the datum itself. Thus, given
just a node, we can determine its key. In contrast, the indexed nodes
represent <span style="font-style: italic">extrinsic</span> keys: the keys are determined outside the
datum, and in particular by the position in some other data
structure. Given a node and not the entire graph, we cannot know for
what its key is. Even given the entire graph, we can only determine
its key by using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span>, which is a rather unsatisfactory
approach to recovering fundamental information. This highlights a
weakness of using extrinsically keyed representations of
information. (In return, extrinsically keyed representations are
easier to reassemble into new collections of data, because there is no
danger of keys clashing: there are no intrinsic keys to clash.)</p></section><section class="SsectionLevel5" id="section 17.1.2.3"><h5 class="heading">17.1.2.3<span class="stt">Â </span><a name="(part._.A_.List_of_.Edges)"/>A List of Edges<span class="button-group"><a href="#(part._.A_.List_of_.Edges)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">The representations we have seen until now have given priority
to nodes, making edges simply a part of the information in a node. We
could, instead, use a representation that makes edges primary, and
nodes simply be the entities that lie at their
ends:<span class="refelem"><span class="refcolumn"><span class="refcontent">The prefix <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">le-</code></span> stands for â€œlist of edgesâ€.</span></span></span>
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Edge:
  | edge(src :: String, dst :: String)
end

type LEGraph = List&lt;Edge&gt;

type Graph = LEGraph</code></pre></div></div></div><div class="SIntrapara">Then, our flight network becomes:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">le-cities :: Graph =
  [list:
    edge("Washington", "Chicago"),
    edge("Washington", "Denver"),
    edge("Washington", "San Francisco"),
    edge("Washington", "Houston"),
    edge("Washington", "Providence"),
    edge("Chicago", "Washington"),
    edge("Chicago", "San Francisco"),
    edge("Chicago", "Providence"),
    edge("Houston", "Washington"),
    edge("Houston", "San Francisco"),
    edge("Denver", "Washington"),
    edge("Denver", "San Francisco"),
    edge("San Francisco", "Washington"),
    edge("San Francisco", "Denver"),
    edge("San Francisco", "Houston"),
    edge("Providence", "Washington"),
    edge("Providence", "Chicago") ]</code></pre></div></div></div><div class="SIntrapara">Observe that in this representation, nodes that are not connected to
other nodes in the graph simply never show up! Youâ€™d therefore need
an auxilliary data structure to keep track of all the nodes.</div><p/><div class="SIntrapara">To obtain the set of neighbors:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun le-neighbors(city :: Key, graph :: Graph) -&gt; List&lt;Key&gt;:
  neighboring-edges = for filter(e from graph):
    city == e.src
  end
  names = for map(e from neighboring-edges): e.dst end
  names
end</code></pre></div></div></div><div class="SIntrapara">And to be sure:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  le-neighbors("Houston", le-cities) is
    [list: "Washington", "San Francisco"]
end</code></pre></div></div></div><div class="SIntrapara">However, this representation makes it difficult to store complex
information about a node without replicating it. Because nodes usually
have rich information while the information about edges tends to be
weaker, we often prefer node-centric representations. Of course, an
alternative is to think of the node names as keys into some other data
structure from which we can retrieve rich information about nodes.</div></section><section class="SsectionLevel5" id="section 17.1.2.4"><h5 class="heading">17.1.2.4<span class="stt">Â </span><a name="(part._.Abstracting_.Representations)"/>Abstracting Representations<span class="button-group"><a href="#(part._.Abstracting_.Representations)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>We would like a general representation that lets us abstract over the
specific implementations. We will assume that broadly we have
available a notion of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Node</code></span> that has <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">content</code></span>, a notion of
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Key</code></span>s (whether or not intrinsic), and a way to obtain the
neighborsâ€”<wbr/>a list of keysâ€”<wbr/>given a key and a graph. This is
sufficient for what follows. However, we still need to choose concrete
keys to write examples and tests. For simplicity, weâ€™ll use
string keys [<a href="#%28part._string-keys%29" data-pltdoc="x">Links by Name</a>].</p></section>&#13;
<h5 class="heading">17.1.2.1<span class="stt">Â </span><a name="(part._string-keys)"/>Links by Name<span class="button-group"><a href="#(part._string-keys)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Hereâ€™s our first representation. We will assume that every node has a
unique name (such a name, when used to look up information in a
repository of data, is sometimes called a <span style="font-style: italic">key</span>). A node is then a
key, some information about that node, and a list of keys that refer
to other nodes:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">type Key = String

data KeyedNode:
  | keyed-node(key :: Key, content, adj :: List&lt;Key&gt;)
end

type KNGraph = List&lt;KeyedNode&gt;

type Node = KeyedNode
type Graph = KNGraph</code></pre></div></div></div><div class="SIntrapara">(Here weâ€™re assuming our keys are strings.)</div><p/><div class="SIntrapara">Hereâ€™s a concrete instance of such a graph:<span class="refelem"><span class="refcolumn"><span class="refcontent">The prefix
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">kn-</code></span> stands for â€œkeyed nodeâ€.</span></span></span>
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">kn-cities :: Graph = block:
  knWAS = keyed-node("was", "Washington", [list: "chi", "den", "saf", "hou", "pvd"])
  knORD = keyed-node("chi", "Chicago", [list: "was", "saf", "pvd"])
  knBLM = keyed-node("bmg", "Bloomington", [list: ])
  knHOU = keyed-node("hou", "Houston", [list: "was", "saf"])
  knDEN = keyed-node("den", "Denver", [list: "was", "saf"])
  knSFO = keyed-node("saf", "San Francisco", [list: "was", "den", "chi", "hou"])
  knPVD = keyed-node("pvd", "Providence", [list: "was", "chi"])
  [list: knWAS, knORD, knBLM, knHOU, knDEN, knSFO, knPVD]
end</code></pre></div></div></div><p/><div class="SIntrapara">Given a key, hereâ€™s how we look up its neighbor:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun find-kn(key :: Key, graph :: Graph) -&gt; Node:
  matches = for filter(n from graph):
    n.key == key
  end
  matches.first # there had better be exactly one!
end</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Convert the comment in the function into an invariant about the
datum. Express this invariant as a refinement and add it to the
declaration of graphs.</p></blockquote></blockquote><p/><div class="SIntrapara">With this support, we can look up neighbors easily:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun kn-neighbors(city :: Key,  graph :: Graph) -&gt; List&lt;Key&gt;:
  city-node = find-kn(city, graph)
  city-node.adj
end</code></pre></div></div></div><p/><div class="SIntrapara">When it comes to testing, some tests are easy to write. Others,
however, might require describing entire nodes, which can be unwieldy,
so for the purpose of checking our implementation it suffices to
examine just a part of the result:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  ns = kn-neighbors("hou", kn-cities)

  ns is [list: "was", "saf"]

  map(_.content, map(find-kn(_, kn-cities), ns)) is
    [list: "Washington", "San Francisco"]
end</code></pre></div></div></div>&#13;
<h5 class="heading">17.1.2.2<span class="stt">Â </span><a name="(part._.Links_by_.Indices)"/>Links by Indices<span class="button-group"><a href="#(part._.Links_by_.Indices)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>In some languages, it is common to use numbers as names. This is
especially useful when numbers can be used to get access to an element
in a constant amount of time (in return for having a bound on the
number of elements that can be accessed). Here, we use a listâ€”<wbr/>which
does not provide constant-time access to arbitrary elementsâ€”<wbr/>to
illustrate this concept. Most of this will look very similar to what
we had before; weâ€™ll comment on a key difference at the end.</p><p/><div class="SIntrapara">First, the datatype:<span class="refelem"><span class="refcolumn"><span class="refcontent">The prefix <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ix-</code></span> stands for
â€œindexedâ€.</span></span></span>
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data IndexedNode:
  | idxed-node(content, adj :: List&lt;Number&gt;)
end

type IXGraph = List&lt;IndexedNode&gt;

type Node = IndexedNode
type Graph = IXGraph</code></pre></div></div></div><div class="SIntrapara">Our graph now looks like this:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ix-cities :: Graph = block:
  inWAS = idxed-node("Washington", [list: 1, 4, 5, 3, 6])
  inORD = idxed-node("Chicago", [list: 0, 5, 6])
  inBLM = idxed-node("Bloomington", [list: ])
  inHOU = idxed-node("Houston", [list: 0, 5])
  inDEN = idxed-node("Denver", [list: 0, 5])
  inSFO = idxed-node("San Francisco", [list: 0, 4, 3])
  inPVD = idxed-node("Providence", [list: 0, 1])
  [list: inWAS, inORD, inBLM, inHOU, inDEN, inSFO, inPVD]
end</code></pre></div></div></div><div class="SIntrapara">where weâ€™re assuming indices begin at <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>. To find a node:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun find-ix(idx :: Key, graph :: Graph) -&gt; Node:
  lists.get(graph, idx)
end</code></pre></div></div></div><div class="SIntrapara">We can then find neighbors almost as before:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun ix-neighbors(city :: Key,  graph :: Graph) -&gt; List&lt;Key&gt;:
  city-node = find-ix(city, graph)
  city-node.adj
end</code></pre></div></div></div><div class="SIntrapara">Finally, our tests also look similar:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  ns = ix-neighbors(3, ix-cities)

  ns is [list: 0, 5]

  map(_.content, map(find-ix(_, ix-cities), ns)) is
    [list: "Washington", "San Francisco"]
end</code></pre></div></div></div><p>Something deeper is going on here. The keyed nodes have
<span style="font-style: italic">intrinsic</span> keys: the key is part of the datum itself. Thus, given
just a node, we can determine its key. In contrast, the indexed nodes
represent <span style="font-style: italic">extrinsic</span> keys: the keys are determined outside the
datum, and in particular by the position in some other data
structure. Given a node and not the entire graph, we cannot know for
what its key is. Even given the entire graph, we can only determine
its key by using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span>, which is a rather unsatisfactory
approach to recovering fundamental information. This highlights a
weakness of using extrinsically keyed representations of
information. (In return, extrinsically keyed representations are
easier to reassemble into new collections of data, because there is no
danger of keys clashing: there are no intrinsic keys to clash.)</p>&#13;
<h5 class="heading">17.1.2.3<span class="stt">Â </span><a name="(part._.A_.List_of_.Edges)"/>A List of Edges<span class="button-group"><a href="#(part._.A_.List_of_.Edges)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">The representations we have seen until now have given priority
to nodes, making edges simply a part of the information in a node. We
could, instead, use a representation that makes edges primary, and
nodes simply be the entities that lie at their
ends:<span class="refelem"><span class="refcolumn"><span class="refcontent">The prefix <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">le-</code></span> stands for â€œlist of edgesâ€.</span></span></span>
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Edge:
  | edge(src :: String, dst :: String)
end

type LEGraph = List&lt;Edge&gt;

type Graph = LEGraph</code></pre></div></div></div><div class="SIntrapara">Then, our flight network becomes:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">le-cities :: Graph =
  [list:
    edge("Washington", "Chicago"),
    edge("Washington", "Denver"),
    edge("Washington", "San Francisco"),
    edge("Washington", "Houston"),
    edge("Washington", "Providence"),
    edge("Chicago", "Washington"),
    edge("Chicago", "San Francisco"),
    edge("Chicago", "Providence"),
    edge("Houston", "Washington"),
    edge("Houston", "San Francisco"),
    edge("Denver", "Washington"),
    edge("Denver", "San Francisco"),
    edge("San Francisco", "Washington"),
    edge("San Francisco", "Denver"),
    edge("San Francisco", "Houston"),
    edge("Providence", "Washington"),
    edge("Providence", "Chicago") ]</code></pre></div></div></div><div class="SIntrapara">Observe that in this representation, nodes that are not connected to
other nodes in the graph simply never show up! Youâ€™d therefore need
an auxilliary data structure to keep track of all the nodes.</div><p/><div class="SIntrapara">To obtain the set of neighbors:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun le-neighbors(city :: Key, graph :: Graph) -&gt; List&lt;Key&gt;:
  neighboring-edges = for filter(e from graph):
    city == e.src
  end
  names = for map(e from neighboring-edges): e.dst end
  names
end</code></pre></div></div></div><div class="SIntrapara">And to be sure:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  le-neighbors("Houston", le-cities) is
    [list: "Washington", "San Francisco"]
end</code></pre></div></div></div><div class="SIntrapara">However, this representation makes it difficult to store complex
information about a node without replicating it. Because nodes usually
have rich information while the information about edges tends to be
weaker, we often prefer node-centric representations. Of course, an
alternative is to think of the node names as keys into some other data
structure from which we can retrieve rich information about nodes.</div>&#13;
<h5 class="heading">17.1.2.4<span class="stt">Â </span><a name="(part._.Abstracting_.Representations)"/>Abstracting Representations<span class="button-group"><a href="#(part._.Abstracting_.Representations)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>We would like a general representation that lets us abstract over the
specific implementations. We will assume that broadly we have
available a notion of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Node</code></span> that has <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">content</code></span>, a notion of
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Key</code></span>s (whether or not intrinsic), and a way to obtain the
neighborsâ€”<wbr/>a list of keysâ€”<wbr/>given a key and a graph. This is
sufficient for what follows. However, we still need to choose concrete
keys to write examples and tests. For simplicity, weâ€™ll use
string keys [<a href="#%28part._string-keys%29" data-pltdoc="x">Links by Name</a>].</p>&#13;
<h4 class="heading">17.1.3<span class="stt">Â </span><a name="(part._complexity-of-graphs)"/>Measuring Complexity for Graphs<span class="button-group"><a href="#(part._complexity-of-graphs)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Before we begin to define algorithms over graphs, we should consider
how to measure the <span class="emph">size</span> of a graph. A graph has two components:
its nodes and its edges. Some algorithms are going to focus on nodes
(e.g., visiting each of them), while others will focus on edges, and
some will care about both. So which do we use as the basis for
counting operations: nodes or edges?</p><p/><div class="SIntrapara">It would help if we can reduce these two measures to one. To see
whether thatâ€™s possible, suppose a graph has \(k\) nodes. Then its
number of edges has a wide range, with these two extremes:
</div><div class="SIntrapara"><ul><li><p>No two nodes are connected. Then there are no edges at all.</p></li><li><p>Every two nodes is connected. Then there are essentially as
many edges as the number of <span class="emph">pairs</span> of nodes.</p></li></ul></div><div class="SIntrapara">The number of nodes can thus be significantly less or even
significantly more than the number of edges. Were this difference a
matter of constants, we could have ignored it; but itâ€™s not. As a
graph tends towards the former extreme, the ratio of nodes to edges
approaches \(k\) (or even exceeds it, in the odd case where there are
no edges, but this graph is not very interesting); as it tends towards
the latter, it is the ratio of edges to nodes that approaches
\(k^2\). In other words, neither measure subsumes the other by a
constant independent of the graph.</div><p>Therefore, when we want to speak of the complexity of algorithms over
graphs, we have to consider the sizes of <span class="emph">both</span> the number of
nodes and edges. In a <span style="font-style: italic">connected</span> graph<span class="refelem"><span class="refcolumn"><span class="refcontent">A graph is
connected if, from every node, we can traverse edges to get to every
other node.</span></span></span>, however, there must be at least as many edges as nodes,
which means the number of edges dominates the number of nodes. Since
we are usually processing connected graphs, or connected parts of
graphs one at a time, we can bound the number of nodes by the number
of edges.</p>    
</body>
</html>