<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>17.1Â Introducing GraphsğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>17.1Â Introducing GraphsğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/intro-graphs.html">https://dcic-world.org/2025-08-27/intro-graphs.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._.Understanding_.Graphs%29" class="toclink" data-pltdoc="x">17.1.1Â Understanding Graphs</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Representations%29" class="toclink" data-pltdoc="x">17.1.2Â Representations</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._string-keys%29" class="toclink" data-pltdoc="x">17.1.2.1Â Links by Name</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Links_by_.Indices%29" class="toclink" data-pltdoc="x">17.1.2.2Â Links by Indices</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.A_.List_of_.Edges%29" class="toclink" data-pltdoc="x">17.1.2.3Â A List of Edges</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Abstracting_.Representations%29" class="toclink" data-pltdoc="x">17.1.2.4Â Abstracting Representations</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._complexity-of-graphs%29" class="toclink" data-pltdoc="x">17.1.3Â Measuring Complexity for Graphs</a></p></td></tr></table><p>In <a href="Sharing_and_Equality.html#%28part._acyc-to-cyc%29" data-pltdoc="x">From Acyclicity to Cycles</a> we introduced a special kind of sharing:
when the data become cyclic, i.e., there exist values such that
traversing other reachable values from them eventually gets you back
to the value at which you began. Data that have this characteristic
are called graphs.Technically, a cycle is not
necessary to be a graph; a tree or a DAG is also regarded as a
(degenerate) graph. In this section, however, we are interested in
graphs that have the potential for cycles.</p><p>Lots of very important data are graphs. For instance, the people and
connections in social media form a graph: the people are nodes
or vertices and the connections (such as friendships) are
links or edges. They form a graph because for many
people, if you follow their friends and then the friends of their
friends, you will eventually get back to the person you started
with. (Most simply, this happens when two people are each othersâ€™
friends.) The Web, similarly is a graph: the nodes are pages and the
edges are links between pages. The Internet is a graph: the nodes are
machines and the edges are links between machines. A transportation
network is a graph: e.g., cities are nodes and the edges are
transportation links between them. And so on. Therefore, it is
essential to understand graphs to represent and process a great deal
of interesting real-world data.</p><p>Graphs are important and interesting for not only practical but also
principled reasons. The property that a traversal can end up where it
began means that traditional methods of processing will no longer
work: if it blindly processes every node it visits, it could end up in
an infinite loop. Therefore, we need better structural recipes for our
programs. In addition, graphs have a very rich structure, which lends
itself to several interesting computations over them. We will study
both these aspects of graphs below.</p><section class="SsectionLevel4" id="section 17.1.1"><h4 class="heading">17.1.1Â <a name="(part._.Understanding_.Graphs)"/>Understanding Graphs<a href="#(part._.Understanding_.Graphs)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Consider again the binary trees we saw earlier
[<a href="Sharing_and_Equality.html#%28part._identical-eq%29" data-pltdoc="x">Re-Examining Equality</a>]. Letâ€™s now try to distort the definition of
a â€œtreeâ€ by creating ones with cycles, i.e., trees with nodes
that point back to themselves (in the sense of <code data-lang="pyret" class="sourceCode">identical</code>). As
we saw earlier [<a href="Sharing_and_Equality.html#%28part._acyc-to-cyc%29" data-pltdoc="x">From Acyclicity to Cycles</a>], it is not completely
straightforward to create such a structure, but what we saw earlier
[<a href="func-as-data.html#%28part._streams-from-funs%29" data-pltdoc="x">Streams From Functions</a>] can help us here, by letting us
suspend the evaluation of the cyclic link. That is, we have to
not only use <code data-lang="pyret" class="sourceCode">rec</code>, we must also use a function to delay
evaluation. In turn, we have to update the annotations on the
fields. Since these are not going to be â€œtreesâ€ any more, weâ€™ll use
a name that is suggestive but not outright incorrect:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data BinT:
  | leaf
  | node(v, l :: ( -&gt; BinT), r :: ( -&gt; BinT))
end</code></pre><p>Now letâ€™s try to construct some cyclic values. Here are a few
examples:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec tr = node("rec", lam(): tr end, lam(): tr end)
t0 = node(0, lam(): leaf end, lam(): leaf end)
t1 = node(1, lam(): t0 end, lam(): t0 end)
t2 = node(2, lam(): t1 end, lam(): t1 end)</code></pre><p>Now letâ€™s try to compute the size of a <code data-lang="pyret" class="sourceCode">BinT</code>. Hereâ€™s the obvious
program:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sizeinf(t :: BinT) -&gt; Number:
  cases (BinT) t:
    | leaf =&gt; 0
    | node(v, l, r) =&gt;
      ls = sizeinf(l())
      rs = sizeinf(r())
      1 + ls + rs
  end
end</code></pre><p>(Weâ€™ll see why we call it <code data-lang="pyret" class="sourceCode">sizeinf</code> in a moment.)</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What happens when we call <code data-lang="pyret" class="sourceCode">sizeinf(tr)</code>?</p></blockquote></blockquote><p>It goes into an infinite loop: hence the <code data-lang="pyret" class="sourceCode">inf</code> in its name.</p><p>There are two very different meanings for â€œsizeâ€. One is, â€œHow many
times can we traverse an edge?â€ The other is, â€œHow many distinct
nodes were constructed as part of the data structure?â€ With trees,
by definition, these two are the same. With a DAG the former
exceeds the latter but only by a finite amount. With a general graph,
the former can exceed the latter by an infinite amount. In the case of
a datum like <code data-lang="pyret" class="sourceCode">tr</code>, we can in fact traverse edges an infinite
number of times. But the total number of constructed nodes is only
one! Letâ€™s write this as test cases in terms of a <code data-lang="pyret" class="sourceCode">size</code>
function, to be defined:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  size(tr) is 1
  size(t0) is 1
  size(t1) is 2
  size(t2) is 3
end</code></pre><p>Itâ€™s clear that we need to somehow remember what nodes we have
visited previously: that is, we need a computation with â€œmemoryâ€. In
principle this is easy: we just create an extra data structure that
checks whether a node has already been counted. As long as we update
this data structure correctly, we should be all set. Hereâ€™s an
implementation.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sizect(t :: BinT) -&gt; Number:
  fun szacc(shadow t :: BinT, seen :: List&lt;BinT&gt;) -&gt; Number:
    if has-id(seen, t):
      0
    else:
      cases (BinT) t:
        | leaf =&gt; 0
        | node(v, l, r) =&gt;
          ns = link(t, seen)
          ls = szacc(l(), ns)
          rs = szacc(r(), ns)
          1 + ls + rs
      end
    end
  end
  szacc(t, empty)
end</code></pre><p>The extra parameter, <code data-lang="pyret" class="sourceCode">seen</code>, is called an accumulator,
because it â€œaccumulatesâ€ the list of seen nodes.Note
that this could just as well be a set; it doesnâ€™t have to be a list.
The support function it needs checks whether a given node has already
been seen:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun has-id&lt;A&gt;(seen :: List&lt;A&gt;, t :: A):
  cases (List) seen:
    | empty =&gt; false
    | link(f, r) =&gt;
      if f &lt;=&gt; t: true
      else: has-id(r, t)
      end
  end
end</code></pre><p>How does this do? Well, <code data-lang="pyret" class="sourceCode">sizect(tr)</code> is indeed <code data-lang="pyret" class="sourceCode">1</code>, but
<code data-lang="pyret" class="sourceCode">sizect(t1)</code> is <code data-lang="pyret" class="sourceCode">3</code> and <code data-lang="pyret" class="sourceCode">sizect(t2)</code> is <code data-lang="pyret" class="sourceCode">7</code>!</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Explain why these answers came out as they did.</p></blockquote></blockquote><p>The fundamental problem is that weâ€™re not doing a very good job of
remembering! Look at this pair of lines:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ls = szacc(l(), ns)
rs = szacc(r(), ns)
</code></pre><p>The nodes seen while traversing the left branch are effectively
forgotten, because the only nodes we remember when traversing the
right branch are those in <code data-lang="pyret" class="sourceCode">ns</code>: namely, the current node and
those visited â€œhigher upâ€. As a result, any nodes that â€œcross
sidesâ€ are counted twice.</p><p>The remedy for this, therefore, is to remember every node we
visit. Then, when we have no more nodes to process, instead of
returning only the size, we should return all the nodes visited
until now. This ensures that nodes that have multiple paths to them
are visited on only one path, not more than once. The logic for this
is to return two values from each traversalâ€”<wbr/>the size and all the
visited nodesâ€”<wbr/>and not just one.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size(t :: BinT) -&gt; Number:
  fun szacc(shadow t :: BinT, seen :: List&lt;BinT&gt;)
    -&gt; {n :: Number, s :: List&lt;BinT&gt;}:
    if has-id(seen, t):
      {n: 0, s: seen}
    else:
      cases (BinT) t:
        | leaf =&gt; {n: 0, s: seen}
        | node(v, l, r) =&gt;
          ns = link(t, seen)
          ls = szacc(l(), ns)
          rs = szacc(r(), ls.s)
          {n: 1 + ls.n + rs.n, s: rs.s}
      end
    end
  end
  szacc(t, empty).n
end</code></pre><p>Sure enough, this function satisfies the above tests.</p></section><section class="SsectionLevel4" id="section 17.1.2"><h4 class="heading">17.1.2Â <a name="(part._.Representations)"/>Representations<a href="#(part._.Representations)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>The representation weâ€™ve seen above for graphs is certainly a start
towards creating cyclic data, but itâ€™s not very elegant. Itâ€™s both
error-prone and inelegant to have to write <code data-lang="pyret" class="sourceCode">lam</code> everywhere, and
remember to apply functions to <code data-lang="pyret" class="sourceCode">()</code> to obtain the actual
values. Therefore, here we explore other representations of graphs
that are more conventional and also much simpler to manipulate.</p><p>There are numerous ways to represent graphs, and the choice of
representation depends on several factors:
</p><ol><li><p>The structure of the graph, and in particular, its
density. We will discuss this further later
[<a href="#%28part._complexity-of-graphs%29" data-pltdoc="x">Measuring Complexity for Graphs</a>].</p></li><li><p>The representation in which the data are provided by external
sources. Sometimes it may be easier to simply adapt to their
representation; in particular, in some cases there may not even be a
choice.</p></li><li><p>The features provided by the programming language, which make
some representations much harder to use than others.</p></li></ol><p>In [<a href="part_sets.html" data-pltdoc="x">Several Variations on Sets</a>], we explore the idea of having many
different representations for one datatype. As we will see, this is
very true of graphs as well. Therefore, it would be best if we could
arrive at a common interface to process graphs, so that all
later programs can be written in terms of this interface, without
overly depending on the underlying representation.</p><p>In terms of representations, there are three main things we need:
</p><ol><li><p>A way to construct graphs.</p></li><li><p>A way to identify (i.e., tell apart) nodes or vertices in a graph.</p></li><li><p>Given a way to identify nodes, a way to get that nodeâ€™s
neighbors in the graph.</p></li></ol><p>Any interface that satisfies these properties will suffice. For
simplicity, we will focus on the second and third of these and not
abstract over the process of constructing a graph.</p><p>Our running example will be a graph whose nodes are cities in the
United States and edges are direct flight connections between
them:</p><p><img src="../Images/149f40c8773898400ea9f6d76e084087.png" alt="" width="640" height="412" data-original-src="https://dcic-world.org/2025-08-27/us-flight-map.png"/></p><section class="SsectionLevel5" id="section 17.1.2.1"><h5 class="heading">17.1.2.1Â <a name="(part._string-keys)"/>Links by Name<a href="#(part._string-keys)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Hereâ€™s our first representation. We will assume that every node has a
unique name (such a name, when used to look up information in a
repository of data, is sometimes called a key). A node is then a
key, some information about that node, and a list of keys that refer
to other nodes:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">type Key = String

data KeyedNode:
  | keyed-node(key :: Key, content, adj :: List&lt;Key&gt;)
end

type KNGraph = List&lt;KeyedNode&gt;

type Node = KeyedNode
type Graph = KNGraph</code></pre><p>(Here weâ€™re assuming our keys are strings.)</p><p>Hereâ€™s a concrete instance of such a graph:The prefix
<code data-lang="pyret" class="sourceCode">kn-</code> stands for â€œkeyed nodeâ€.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">kn-cities :: Graph = block:
  knWAS = keyed-node("was", "Washington", [list: "chi", "den", "saf", "hou", "pvd"])
  knORD = keyed-node("chi", "Chicago", [list: "was", "saf", "pvd"])
  knBLM = keyed-node("bmg", "Bloomington", [list: ])
  knHOU = keyed-node("hou", "Houston", [list: "was", "saf"])
  knDEN = keyed-node("den", "Denver", [list: "was", "saf"])
  knSFO = keyed-node("saf", "San Francisco", [list: "was", "den", "chi", "hou"])
  knPVD = keyed-node("pvd", "Providence", [list: "was", "chi"])
  [list: knWAS, knORD, knBLM, knHOU, knDEN, knSFO, knPVD]
end</code></pre><p>Given a key, hereâ€™s how we look up its neighbor:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun find-kn(key :: Key, graph :: Graph) -&gt; Node:
  matches = for filter(n from graph):
    n.key == key
  end
  matches.first # there had better be exactly one!
end</code></pre><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Convert the comment in the function into an invariant about the
datum. Express this invariant as a refinement and add it to the
declaration of graphs.</p></blockquote></blockquote><p>With this support, we can look up neighbors easily:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun kn-neighbors(city :: Key,  graph :: Graph) -&gt; List&lt;Key&gt;:
  city-node = find-kn(city, graph)
  city-node.adj
end</code></pre><p>When it comes to testing, some tests are easy to write. Others,
however, might require describing entire nodes, which can be unwieldy,
so for the purpose of checking our implementation it suffices to
examine just a part of the result:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  ns = kn-neighbors("hou", kn-cities)

  ns is [list: "was", "saf"]

  map(_.content, map(find-kn(_, kn-cities), ns)) is
    [list: "Washington", "San Francisco"]
end</code></pre></section><section class="SsectionLevel5" id="section 17.1.2.2"><h5 class="heading">17.1.2.2Â <a name="(part._.Links_by_.Indices)"/>Links by Indices<a href="#(part._.Links_by_.Indices)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>In some languages, it is common to use numbers as names. This is
especially useful when numbers can be used to get access to an element
in a constant amount of time (in return for having a bound on the
number of elements that can be accessed). Here, we use a listâ€”<wbr/>which
does not provide constant-time access to arbitrary elementsâ€”<wbr/>to
illustrate this concept. Most of this will look very similar to what
we had before; weâ€™ll comment on a key difference at the end.</p><p>First, the datatype:The prefix <code data-lang="pyret" class="sourceCode">ix-</code> stands for
â€œindexedâ€.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data IndexedNode:
  | idxed-node(content, adj :: List&lt;Number&gt;)
end

type IXGraph = List&lt;IndexedNode&gt;

type Node = IndexedNode
type Graph = IXGraph</code></pre><p>Our graph now looks like this:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ix-cities :: Graph = block:
  inWAS = idxed-node("Washington", [list: 1, 4, 5, 3, 6])
  inORD = idxed-node("Chicago", [list: 0, 5, 6])
  inBLM = idxed-node("Bloomington", [list: ])
  inHOU = idxed-node("Houston", [list: 0, 5])
  inDEN = idxed-node("Denver", [list: 0, 5])
  inSFO = idxed-node("San Francisco", [list: 0, 4, 3])
  inPVD = idxed-node("Providence", [list: 0, 1])
  [list: inWAS, inORD, inBLM, inHOU, inDEN, inSFO, inPVD]
end</code></pre><p>where weâ€™re assuming indices begin at <code data-lang="pyret" class="sourceCode">0</code>. To find a node:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun find-ix(idx :: Key, graph :: Graph) -&gt; Node:
  lists.get(graph, idx)
end</code></pre><p>We can then find neighbors almost as before:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun ix-neighbors(city :: Key,  graph :: Graph) -&gt; List&lt;Key&gt;:
  city-node = find-ix(city, graph)
  city-node.adj
end</code></pre><p>Finally, our tests also look similar:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  ns = ix-neighbors(3, ix-cities)

  ns is [list: 0, 5]

  map(_.content, map(find-ix(_, ix-cities), ns)) is
    [list: "Washington", "San Francisco"]
end</code></pre><p>Something deeper is going on here. The keyed nodes have
intrinsic keys: the key is part of the datum itself. Thus, given
just a node, we can determine its key. In contrast, the indexed nodes
represent extrinsic keys: the keys are determined outside the
datum, and in particular by the position in some other data
structure. Given a node and not the entire graph, we cannot know for
what its key is. Even given the entire graph, we can only determine
its key by using <code data-lang="pyret" class="sourceCode">identical</code>, which is a rather unsatisfactory
approach to recovering fundamental information. This highlights a
weakness of using extrinsically keyed representations of
information. (In return, extrinsically keyed representations are
easier to reassemble into new collections of data, because there is no
danger of keys clashing: there are no intrinsic keys to clash.)</p></section><section class="SsectionLevel5" id="section 17.1.2.3"><h5 class="heading">17.1.2.3Â <a name="(part._.A_.List_of_.Edges)"/>A List of Edges<a href="#(part._.A_.List_of_.Edges)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>The representations we have seen until now have given priority
to nodes, making edges simply a part of the information in a node. We
could, instead, use a representation that makes edges primary, and
nodes simply be the entities that lie at their
ends:The prefix <code data-lang="pyret" class="sourceCode">le-</code> stands for â€œlist of edgesâ€.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Edge:
  | edge(src :: String, dst :: String)
end

type LEGraph = List&lt;Edge&gt;

type Graph = LEGraph</code></pre><p>Then, our flight network becomes:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">le-cities :: Graph =
  [list:
    edge("Washington", "Chicago"),
    edge("Washington", "Denver"),
    edge("Washington", "San Francisco"),
    edge("Washington", "Houston"),
    edge("Washington", "Providence"),
    edge("Chicago", "Washington"),
    edge("Chicago", "San Francisco"),
    edge("Chicago", "Providence"),
    edge("Houston", "Washington"),
    edge("Houston", "San Francisco"),
    edge("Denver", "Washington"),
    edge("Denver", "San Francisco"),
    edge("San Francisco", "Washington"),
    edge("San Francisco", "Denver"),
    edge("San Francisco", "Houston"),
    edge("Providence", "Washington"),
    edge("Providence", "Chicago") ]</code></pre><p>Observe that in this representation, nodes that are not connected to
other nodes in the graph simply never show up! Youâ€™d therefore need
an auxilliary data structure to keep track of all the nodes.</p><p>To obtain the set of neighbors:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun le-neighbors(city :: Key, graph :: Graph) -&gt; List&lt;Key&gt;:
  neighboring-edges = for filter(e from graph):
    city == e.src
  end
  names = for map(e from neighboring-edges): e.dst end
  names
end</code></pre><p>And to be sure:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  le-neighbors("Houston", le-cities) is
    [list: "Washington", "San Francisco"]
end</code></pre><p>However, this representation makes it difficult to store complex
information about a node without replicating it. Because nodes usually
have rich information while the information about edges tends to be
weaker, we often prefer node-centric representations. Of course, an
alternative is to think of the node names as keys into some other data
structure from which we can retrieve rich information about nodes.</p></section><section class="SsectionLevel5" id="section 17.1.2.4"><h5 class="heading">17.1.2.4Â <a name="(part._.Abstracting_.Representations)"/>Abstracting Representations<a href="#(part._.Abstracting_.Representations)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>We would like a general representation that lets us abstract over the
specific implementations. We will assume that broadly we have
available a notion of <code data-lang="pyret" class="sourceCode">Node</code> that has <code data-lang="pyret" class="sourceCode">content</code>, a notion of
<code data-lang="pyret" class="sourceCode">Key</code>s (whether or not intrinsic), and a way to obtain the
neighborsâ€”<wbr/>a list of keysâ€”<wbr/>given a key and a graph. This is
sufficient for what follows. However, we still need to choose concrete
keys to write examples and tests. For simplicity, weâ€™ll use
string keys [<a href="#%28part._string-keys%29" data-pltdoc="x">Links by Name</a>].</p></section></section><section class="SsectionLevel4" id="section 17.1.3"><h4 class="heading">17.1.3Â <a name="(part._complexity-of-graphs)"/>Measuring Complexity for Graphs<a href="#(part._complexity-of-graphs)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Before we begin to define algorithms over graphs, we should consider
how to measure the size of a graph. A graph has two components:
its nodes and its edges. Some algorithms are going to focus on nodes
(e.g., visiting each of them), while others will focus on edges, and
some will care about both. So which do we use as the basis for
counting operations: nodes or edges?</p><p>It would help if we can reduce these two measures to one. To see
whether thatâ€™s possible, suppose a graph has \(k\) nodes. Then its
number of edges has a wide range, with these two extremes:
</p><ul><li><p>No two nodes are connected. Then there are no edges at all.</p></li><li><p>Every two nodes is connected. Then there are essentially as
many edges as the number of pairs of nodes.</p></li></ul><p>The number of nodes can thus be significantly less or even
significantly more than the number of edges. Were this difference a
matter of constants, we could have ignored it; but itâ€™s not. As a
graph tends towards the former extreme, the ratio of nodes to edges
approaches \(k\) (or even exceeds it, in the odd case where there are
no edges, but this graph is not very interesting); as it tends towards
the latter, it is the ratio of edges to nodes that approaches
\(k^2\). In other words, neither measure subsumes the other by a
constant independent of the graph.</p><p>Therefore, when we want to speak of the complexity of algorithms over
graphs, we have to consider the sizes of both the number of
nodes and edges. In a connected graphA graph is
connected if, from every node, we can traverse edges to get to every
other node., however, there must be at least as many edges as nodes,
which means the number of edges dominates the number of nodes. Since
we are usually processing connected graphs, or connected parts of
graphs one at a time, we can bound the number of nodes by the number
of edges.</p></section>&#13;
<h4 class="heading">17.1.1Â <a name="(part._.Understanding_.Graphs)"/>Understanding Graphs<a href="#(part._.Understanding_.Graphs)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Consider again the binary trees we saw earlier
[<a href="Sharing_and_Equality.html#%28part._identical-eq%29" data-pltdoc="x">Re-Examining Equality</a>]. Letâ€™s now try to distort the definition of
a â€œtreeâ€ by creating ones with cycles, i.e., trees with nodes
that point back to themselves (in the sense of <code data-lang="pyret" class="sourceCode">identical</code>). As
we saw earlier [<a href="Sharing_and_Equality.html#%28part._acyc-to-cyc%29" data-pltdoc="x">From Acyclicity to Cycles</a>], it is not completely
straightforward to create such a structure, but what we saw earlier
[<a href="func-as-data.html#%28part._streams-from-funs%29" data-pltdoc="x">Streams From Functions</a>] can help us here, by letting us
suspend the evaluation of the cyclic link. That is, we have to
not only use <code data-lang="pyret" class="sourceCode">rec</code>, we must also use a function to delay
evaluation. In turn, we have to update the annotations on the
fields. Since these are not going to be â€œtreesâ€ any more, weâ€™ll use
a name that is suggestive but not outright incorrect:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data BinT:
  | leaf
  | node(v, l :: ( -&gt; BinT), r :: ( -&gt; BinT))
end</code></pre><p>Now letâ€™s try to construct some cyclic values. Here are a few
examples:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec tr = node("rec", lam(): tr end, lam(): tr end)
t0 = node(0, lam(): leaf end, lam(): leaf end)
t1 = node(1, lam(): t0 end, lam(): t0 end)
t2 = node(2, lam(): t1 end, lam(): t1 end)</code></pre><p>Now letâ€™s try to compute the size of a <code data-lang="pyret" class="sourceCode">BinT</code>. Hereâ€™s the obvious
program:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sizeinf(t :: BinT) -&gt; Number:
  cases (BinT) t:
    | leaf =&gt; 0
    | node(v, l, r) =&gt;
      ls = sizeinf(l())
      rs = sizeinf(r())
      1 + ls + rs
  end
end</code></pre><p>(Weâ€™ll see why we call it <code data-lang="pyret" class="sourceCode">sizeinf</code> in a moment.)</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What happens when we call <code data-lang="pyret" class="sourceCode">sizeinf(tr)</code>?</p></blockquote></blockquote><p>It goes into an infinite loop: hence the <code data-lang="pyret" class="sourceCode">inf</code> in its name.</p><p>There are two very different meanings for â€œsizeâ€. One is, â€œHow many
times can we traverse an edge?â€ The other is, â€œHow many distinct
nodes were constructed as part of the data structure?â€ With trees,
by definition, these two are the same. With a DAG the former
exceeds the latter but only by a finite amount. With a general graph,
the former can exceed the latter by an infinite amount. In the case of
a datum like <code data-lang="pyret" class="sourceCode">tr</code>, we can in fact traverse edges an infinite
number of times. But the total number of constructed nodes is only
one! Letâ€™s write this as test cases in terms of a <code data-lang="pyret" class="sourceCode">size</code>
function, to be defined:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  size(tr) is 1
  size(t0) is 1
  size(t1) is 2
  size(t2) is 3
end</code></pre><p>Itâ€™s clear that we need to somehow remember what nodes we have
visited previously: that is, we need a computation with â€œmemoryâ€. In
principle this is easy: we just create an extra data structure that
checks whether a node has already been counted. As long as we update
this data structure correctly, we should be all set. Hereâ€™s an
implementation.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sizect(t :: BinT) -&gt; Number:
  fun szacc(shadow t :: BinT, seen :: List&lt;BinT&gt;) -&gt; Number:
    if has-id(seen, t):
      0
    else:
      cases (BinT) t:
        | leaf =&gt; 0
        | node(v, l, r) =&gt;
          ns = link(t, seen)
          ls = szacc(l(), ns)
          rs = szacc(r(), ns)
          1 + ls + rs
      end
    end
  end
  szacc(t, empty)
end</code></pre><p>The extra parameter, <code data-lang="pyret" class="sourceCode">seen</code>, is called an accumulator,
because it â€œaccumulatesâ€ the list of seen nodes.Note
that this could just as well be a set; it doesnâ€™t have to be a list.
The support function it needs checks whether a given node has already
been seen:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun has-id&lt;A&gt;(seen :: List&lt;A&gt;, t :: A):
  cases (List) seen:
    | empty =&gt; false
    | link(f, r) =&gt;
      if f &lt;=&gt; t: true
      else: has-id(r, t)
      end
  end
end</code></pre><p>How does this do? Well, <code data-lang="pyret" class="sourceCode">sizect(tr)</code> is indeed <code data-lang="pyret" class="sourceCode">1</code>, but
<code data-lang="pyret" class="sourceCode">sizect(t1)</code> is <code data-lang="pyret" class="sourceCode">3</code> and <code data-lang="pyret" class="sourceCode">sizect(t2)</code> is <code data-lang="pyret" class="sourceCode">7</code>!</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Explain why these answers came out as they did.</p></blockquote></blockquote><p>The fundamental problem is that weâ€™re not doing a very good job of
remembering! Look at this pair of lines:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ls = szacc(l(), ns)
rs = szacc(r(), ns)
</code></pre><p>The nodes seen while traversing the left branch are effectively
forgotten, because the only nodes we remember when traversing the
right branch are those in <code data-lang="pyret" class="sourceCode">ns</code>: namely, the current node and
those visited â€œhigher upâ€. As a result, any nodes that â€œcross
sidesâ€ are counted twice.</p><p>The remedy for this, therefore, is to remember every node we
visit. Then, when we have no more nodes to process, instead of
returning only the size, we should return all the nodes visited
until now. This ensures that nodes that have multiple paths to them
are visited on only one path, not more than once. The logic for this
is to return two values from each traversalâ€”<wbr/>the size and all the
visited nodesâ€”<wbr/>and not just one.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size(t :: BinT) -&gt; Number:
  fun szacc(shadow t :: BinT, seen :: List&lt;BinT&gt;)
    -&gt; {n :: Number, s :: List&lt;BinT&gt;}:
    if has-id(seen, t):
      {n: 0, s: seen}
    else:
      cases (BinT) t:
        | leaf =&gt; {n: 0, s: seen}
        | node(v, l, r) =&gt;
          ns = link(t, seen)
          ls = szacc(l(), ns)
          rs = szacc(r(), ls.s)
          {n: 1 + ls.n + rs.n, s: rs.s}
      end
    end
  end
  szacc(t, empty).n
end</code></pre><p>Sure enough, this function satisfies the above tests.</p>&#13;
<h4 class="heading">17.1.2Â <a name="(part._.Representations)"/>Representations<a href="#(part._.Representations)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>The representation weâ€™ve seen above for graphs is certainly a start
towards creating cyclic data, but itâ€™s not very elegant. Itâ€™s both
error-prone and inelegant to have to write <code data-lang="pyret" class="sourceCode">lam</code> everywhere, and
remember to apply functions to <code data-lang="pyret" class="sourceCode">()</code> to obtain the actual
values. Therefore, here we explore other representations of graphs
that are more conventional and also much simpler to manipulate.</p><p>There are numerous ways to represent graphs, and the choice of
representation depends on several factors:
</p><ol><li><p>The structure of the graph, and in particular, its
density. We will discuss this further later
[<a href="#%28part._complexity-of-graphs%29" data-pltdoc="x">Measuring Complexity for Graphs</a>].</p></li><li><p>The representation in which the data are provided by external
sources. Sometimes it may be easier to simply adapt to their
representation; in particular, in some cases there may not even be a
choice.</p></li><li><p>The features provided by the programming language, which make
some representations much harder to use than others.</p></li></ol><p>In [<a href="part_sets.html" data-pltdoc="x">Several Variations on Sets</a>], we explore the idea of having many
different representations for one datatype. As we will see, this is
very true of graphs as well. Therefore, it would be best if we could
arrive at a common interface to process graphs, so that all
later programs can be written in terms of this interface, without
overly depending on the underlying representation.</p><p>In terms of representations, there are three main things we need:
</p><ol><li><p>A way to construct graphs.</p></li><li><p>A way to identify (i.e., tell apart) nodes or vertices in a graph.</p></li><li><p>Given a way to identify nodes, a way to get that nodeâ€™s
neighbors in the graph.</p></li></ol><p>Any interface that satisfies these properties will suffice. For
simplicity, we will focus on the second and third of these and not
abstract over the process of constructing a graph.</p><p>Our running example will be a graph whose nodes are cities in the
United States and edges are direct flight connections between
them:</p><p><img src="../Images/149f40c8773898400ea9f6d76e084087.png" alt="" width="640" height="412" data-original-src="https://dcic-world.org/2025-08-27/us-flight-map.png"/></p><section class="SsectionLevel5" id="section 17.1.2.1"><h5 class="heading">17.1.2.1Â <a name="(part._string-keys)"/>Links by Name<a href="#(part._string-keys)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Hereâ€™s our first representation. We will assume that every node has a
unique name (such a name, when used to look up information in a
repository of data, is sometimes called a key). A node is then a
key, some information about that node, and a list of keys that refer
to other nodes:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">type Key = String

data KeyedNode:
  | keyed-node(key :: Key, content, adj :: List&lt;Key&gt;)
end

type KNGraph = List&lt;KeyedNode&gt;

type Node = KeyedNode
type Graph = KNGraph</code></pre><p>(Here weâ€™re assuming our keys are strings.)</p><p>Hereâ€™s a concrete instance of such a graph:The prefix
<code data-lang="pyret" class="sourceCode">kn-</code> stands for â€œkeyed nodeâ€.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">kn-cities :: Graph = block:
  knWAS = keyed-node("was", "Washington", [list: "chi", "den", "saf", "hou", "pvd"])
  knORD = keyed-node("chi", "Chicago", [list: "was", "saf", "pvd"])
  knBLM = keyed-node("bmg", "Bloomington", [list: ])
  knHOU = keyed-node("hou", "Houston", [list: "was", "saf"])
  knDEN = keyed-node("den", "Denver", [list: "was", "saf"])
  knSFO = keyed-node("saf", "San Francisco", [list: "was", "den", "chi", "hou"])
  knPVD = keyed-node("pvd", "Providence", [list: "was", "chi"])
  [list: knWAS, knORD, knBLM, knHOU, knDEN, knSFO, knPVD]
end</code></pre><p>Given a key, hereâ€™s how we look up its neighbor:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun find-kn(key :: Key, graph :: Graph) -&gt; Node:
  matches = for filter(n from graph):
    n.key == key
  end
  matches.first # there had better be exactly one!
end</code></pre><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Convert the comment in the function into an invariant about the
datum. Express this invariant as a refinement and add it to the
declaration of graphs.</p></blockquote></blockquote><p>With this support, we can look up neighbors easily:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun kn-neighbors(city :: Key,  graph :: Graph) -&gt; List&lt;Key&gt;:
  city-node = find-kn(city, graph)
  city-node.adj
end</code></pre><p>When it comes to testing, some tests are easy to write. Others,
however, might require describing entire nodes, which can be unwieldy,
so for the purpose of checking our implementation it suffices to
examine just a part of the result:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  ns = kn-neighbors("hou", kn-cities)

  ns is [list: "was", "saf"]

  map(_.content, map(find-kn(_, kn-cities), ns)) is
    [list: "Washington", "San Francisco"]
end</code></pre></section><section class="SsectionLevel5" id="section 17.1.2.2"><h5 class="heading">17.1.2.2Â <a name="(part._.Links_by_.Indices)"/>Links by Indices<a href="#(part._.Links_by_.Indices)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>In some languages, it is common to use numbers as names. This is
especially useful when numbers can be used to get access to an element
in a constant amount of time (in return for having a bound on the
number of elements that can be accessed). Here, we use a listâ€”<wbr/>which
does not provide constant-time access to arbitrary elementsâ€”<wbr/>to
illustrate this concept. Most of this will look very similar to what
we had before; weâ€™ll comment on a key difference at the end.</p><p>First, the datatype:The prefix <code data-lang="pyret" class="sourceCode">ix-</code> stands for
â€œindexedâ€.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data IndexedNode:
  | idxed-node(content, adj :: List&lt;Number&gt;)
end

type IXGraph = List&lt;IndexedNode&gt;

type Node = IndexedNode
type Graph = IXGraph</code></pre><p>Our graph now looks like this:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ix-cities :: Graph = block:
  inWAS = idxed-node("Washington", [list: 1, 4, 5, 3, 6])
  inORD = idxed-node("Chicago", [list: 0, 5, 6])
  inBLM = idxed-node("Bloomington", [list: ])
  inHOU = idxed-node("Houston", [list: 0, 5])
  inDEN = idxed-node("Denver", [list: 0, 5])
  inSFO = idxed-node("San Francisco", [list: 0, 4, 3])
  inPVD = idxed-node("Providence", [list: 0, 1])
  [list: inWAS, inORD, inBLM, inHOU, inDEN, inSFO, inPVD]
end</code></pre><p>where weâ€™re assuming indices begin at <code data-lang="pyret" class="sourceCode">0</code>. To find a node:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun find-ix(idx :: Key, graph :: Graph) -&gt; Node:
  lists.get(graph, idx)
end</code></pre><p>We can then find neighbors almost as before:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun ix-neighbors(city :: Key,  graph :: Graph) -&gt; List&lt;Key&gt;:
  city-node = find-ix(city, graph)
  city-node.adj
end</code></pre><p>Finally, our tests also look similar:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  ns = ix-neighbors(3, ix-cities)

  ns is [list: 0, 5]

  map(_.content, map(find-ix(_, ix-cities), ns)) is
    [list: "Washington", "San Francisco"]
end</code></pre><p>Something deeper is going on here. The keyed nodes have
intrinsic keys: the key is part of the datum itself. Thus, given
just a node, we can determine its key. In contrast, the indexed nodes
represent extrinsic keys: the keys are determined outside the
datum, and in particular by the position in some other data
structure. Given a node and not the entire graph, we cannot know for
what its key is. Even given the entire graph, we can only determine
its key by using <code data-lang="pyret" class="sourceCode">identical</code>, which is a rather unsatisfactory
approach to recovering fundamental information. This highlights a
weakness of using extrinsically keyed representations of
information. (In return, extrinsically keyed representations are
easier to reassemble into new collections of data, because there is no
danger of keys clashing: there are no intrinsic keys to clash.)</p></section><section class="SsectionLevel5" id="section 17.1.2.3"><h5 class="heading">17.1.2.3Â <a name="(part._.A_.List_of_.Edges)"/>A List of Edges<a href="#(part._.A_.List_of_.Edges)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>The representations we have seen until now have given priority
to nodes, making edges simply a part of the information in a node. We
could, instead, use a representation that makes edges primary, and
nodes simply be the entities that lie at their
ends:The prefix <code data-lang="pyret" class="sourceCode">le-</code> stands for â€œlist of edgesâ€.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Edge:
  | edge(src :: String, dst :: String)
end

type LEGraph = List&lt;Edge&gt;

type Graph = LEGraph</code></pre><p>Then, our flight network becomes:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">le-cities :: Graph =
  [list:
    edge("Washington", "Chicago"),
    edge("Washington", "Denver"),
    edge("Washington", "San Francisco"),
    edge("Washington", "Houston"),
    edge("Washington", "Providence"),
    edge("Chicago", "Washington"),
    edge("Chicago", "San Francisco"),
    edge("Chicago", "Providence"),
    edge("Houston", "Washington"),
    edge("Houston", "San Francisco"),
    edge("Denver", "Washington"),
    edge("Denver", "San Francisco"),
    edge("San Francisco", "Washington"),
    edge("San Francisco", "Denver"),
    edge("San Francisco", "Houston"),
    edge("Providence", "Washington"),
    edge("Providence", "Chicago") ]</code></pre><p>Observe that in this representation, nodes that are not connected to
other nodes in the graph simply never show up! Youâ€™d therefore need
an auxilliary data structure to keep track of all the nodes.</p><p>To obtain the set of neighbors:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun le-neighbors(city :: Key, graph :: Graph) -&gt; List&lt;Key&gt;:
  neighboring-edges = for filter(e from graph):
    city == e.src
  end
  names = for map(e from neighboring-edges): e.dst end
  names
end</code></pre><p>And to be sure:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  le-neighbors("Houston", le-cities) is
    [list: "Washington", "San Francisco"]
end</code></pre><p>However, this representation makes it difficult to store complex
information about a node without replicating it. Because nodes usually
have rich information while the information about edges tends to be
weaker, we often prefer node-centric representations. Of course, an
alternative is to think of the node names as keys into some other data
structure from which we can retrieve rich information about nodes.</p></section><section class="SsectionLevel5" id="section 17.1.2.4"><h5 class="heading">17.1.2.4Â <a name="(part._.Abstracting_.Representations)"/>Abstracting Representations<a href="#(part._.Abstracting_.Representations)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>We would like a general representation that lets us abstract over the
specific implementations. We will assume that broadly we have
available a notion of <code data-lang="pyret" class="sourceCode">Node</code> that has <code data-lang="pyret" class="sourceCode">content</code>, a notion of
<code data-lang="pyret" class="sourceCode">Key</code>s (whether or not intrinsic), and a way to obtain the
neighborsâ€”<wbr/>a list of keysâ€”<wbr/>given a key and a graph. This is
sufficient for what follows. However, we still need to choose concrete
keys to write examples and tests. For simplicity, weâ€™ll use
string keys [<a href="#%28part._string-keys%29" data-pltdoc="x">Links by Name</a>].</p></section>&#13;
<h5 class="heading">17.1.2.1Â <a name="(part._string-keys)"/>Links by Name<a href="#(part._string-keys)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Hereâ€™s our first representation. We will assume that every node has a
unique name (such a name, when used to look up information in a
repository of data, is sometimes called a key). A node is then a
key, some information about that node, and a list of keys that refer
to other nodes:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">type Key = String

data KeyedNode:
  | keyed-node(key :: Key, content, adj :: List&lt;Key&gt;)
end

type KNGraph = List&lt;KeyedNode&gt;

type Node = KeyedNode
type Graph = KNGraph</code></pre><p>(Here weâ€™re assuming our keys are strings.)</p><p>Hereâ€™s a concrete instance of such a graph:The prefix
<code data-lang="pyret" class="sourceCode">kn-</code> stands for â€œkeyed nodeâ€.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">kn-cities :: Graph = block:
  knWAS = keyed-node("was", "Washington", [list: "chi", "den", "saf", "hou", "pvd"])
  knORD = keyed-node("chi", "Chicago", [list: "was", "saf", "pvd"])
  knBLM = keyed-node("bmg", "Bloomington", [list: ])
  knHOU = keyed-node("hou", "Houston", [list: "was", "saf"])
  knDEN = keyed-node("den", "Denver", [list: "was", "saf"])
  knSFO = keyed-node("saf", "San Francisco", [list: "was", "den", "chi", "hou"])
  knPVD = keyed-node("pvd", "Providence", [list: "was", "chi"])
  [list: knWAS, knORD, knBLM, knHOU, knDEN, knSFO, knPVD]
end</code></pre><p>Given a key, hereâ€™s how we look up its neighbor:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun find-kn(key :: Key, graph :: Graph) -&gt; Node:
  matches = for filter(n from graph):
    n.key == key
  end
  matches.first # there had better be exactly one!
end</code></pre><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Convert the comment in the function into an invariant about the
datum. Express this invariant as a refinement and add it to the
declaration of graphs.</p></blockquote></blockquote><p>With this support, we can look up neighbors easily:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun kn-neighbors(city :: Key,  graph :: Graph) -&gt; List&lt;Key&gt;:
  city-node = find-kn(city, graph)
  city-node.adj
end</code></pre><p>When it comes to testing, some tests are easy to write. Others,
however, might require describing entire nodes, which can be unwieldy,
so for the purpose of checking our implementation it suffices to
examine just a part of the result:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  ns = kn-neighbors("hou", kn-cities)

  ns is [list: "was", "saf"]

  map(_.content, map(find-kn(_, kn-cities), ns)) is
    [list: "Washington", "San Francisco"]
end</code></pre>&#13;
<h5 class="heading">17.1.2.2Â <a name="(part._.Links_by_.Indices)"/>Links by Indices<a href="#(part._.Links_by_.Indices)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>In some languages, it is common to use numbers as names. This is
especially useful when numbers can be used to get access to an element
in a constant amount of time (in return for having a bound on the
number of elements that can be accessed). Here, we use a listâ€”<wbr/>which
does not provide constant-time access to arbitrary elementsâ€”<wbr/>to
illustrate this concept. Most of this will look very similar to what
we had before; weâ€™ll comment on a key difference at the end.</p><p>First, the datatype:The prefix <code data-lang="pyret" class="sourceCode">ix-</code> stands for
â€œindexedâ€.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data IndexedNode:
  | idxed-node(content, adj :: List&lt;Number&gt;)
end

type IXGraph = List&lt;IndexedNode&gt;

type Node = IndexedNode
type Graph = IXGraph</code></pre><p>Our graph now looks like this:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ix-cities :: Graph = block:
  inWAS = idxed-node("Washington", [list: 1, 4, 5, 3, 6])
  inORD = idxed-node("Chicago", [list: 0, 5, 6])
  inBLM = idxed-node("Bloomington", [list: ])
  inHOU = idxed-node("Houston", [list: 0, 5])
  inDEN = idxed-node("Denver", [list: 0, 5])
  inSFO = idxed-node("San Francisco", [list: 0, 4, 3])
  inPVD = idxed-node("Providence", [list: 0, 1])
  [list: inWAS, inORD, inBLM, inHOU, inDEN, inSFO, inPVD]
end</code></pre><p>where weâ€™re assuming indices begin at <code data-lang="pyret" class="sourceCode">0</code>. To find a node:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun find-ix(idx :: Key, graph :: Graph) -&gt; Node:
  lists.get(graph, idx)
end</code></pre><p>We can then find neighbors almost as before:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun ix-neighbors(city :: Key,  graph :: Graph) -&gt; List&lt;Key&gt;:
  city-node = find-ix(city, graph)
  city-node.adj
end</code></pre><p>Finally, our tests also look similar:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  ns = ix-neighbors(3, ix-cities)

  ns is [list: 0, 5]

  map(_.content, map(find-ix(_, ix-cities), ns)) is
    [list: "Washington", "San Francisco"]
end</code></pre><p>Something deeper is going on here. The keyed nodes have
intrinsic keys: the key is part of the datum itself. Thus, given
just a node, we can determine its key. In contrast, the indexed nodes
represent extrinsic keys: the keys are determined outside the
datum, and in particular by the position in some other data
structure. Given a node and not the entire graph, we cannot know for
what its key is. Even given the entire graph, we can only determine
its key by using <code data-lang="pyret" class="sourceCode">identical</code>, which is a rather unsatisfactory
approach to recovering fundamental information. This highlights a
weakness of using extrinsically keyed representations of
information. (In return, extrinsically keyed representations are
easier to reassemble into new collections of data, because there is no
danger of keys clashing: there are no intrinsic keys to clash.)</p>&#13;
<h5 class="heading">17.1.2.3Â <a name="(part._.A_.List_of_.Edges)"/>A List of Edges<a href="#(part._.A_.List_of_.Edges)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>The representations we have seen until now have given priority
to nodes, making edges simply a part of the information in a node. We
could, instead, use a representation that makes edges primary, and
nodes simply be the entities that lie at their
ends:The prefix <code data-lang="pyret" class="sourceCode">le-</code> stands for â€œlist of edgesâ€.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Edge:
  | edge(src :: String, dst :: String)
end

type LEGraph = List&lt;Edge&gt;

type Graph = LEGraph</code></pre><p>Then, our flight network becomes:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">le-cities :: Graph =
  [list:
    edge("Washington", "Chicago"),
    edge("Washington", "Denver"),
    edge("Washington", "San Francisco"),
    edge("Washington", "Houston"),
    edge("Washington", "Providence"),
    edge("Chicago", "Washington"),
    edge("Chicago", "San Francisco"),
    edge("Chicago", "Providence"),
    edge("Houston", "Washington"),
    edge("Houston", "San Francisco"),
    edge("Denver", "Washington"),
    edge("Denver", "San Francisco"),
    edge("San Francisco", "Washington"),
    edge("San Francisco", "Denver"),
    edge("San Francisco", "Houston"),
    edge("Providence", "Washington"),
    edge("Providence", "Chicago") ]</code></pre><p>Observe that in this representation, nodes that are not connected to
other nodes in the graph simply never show up! Youâ€™d therefore need
an auxilliary data structure to keep track of all the nodes.</p><p>To obtain the set of neighbors:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun le-neighbors(city :: Key, graph :: Graph) -&gt; List&lt;Key&gt;:
  neighboring-edges = for filter(e from graph):
    city == e.src
  end
  names = for map(e from neighboring-edges): e.dst end
  names
end</code></pre><p>And to be sure:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  le-neighbors("Houston", le-cities) is
    [list: "Washington", "San Francisco"]
end</code></pre><p>However, this representation makes it difficult to store complex
information about a node without replicating it. Because nodes usually
have rich information while the information about edges tends to be
weaker, we often prefer node-centric representations. Of course, an
alternative is to think of the node names as keys into some other data
structure from which we can retrieve rich information about nodes.</p>&#13;
<h5 class="heading">17.1.2.4Â <a name="(part._.Abstracting_.Representations)"/>Abstracting Representations<a href="#(part._.Abstracting_.Representations)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>We would like a general representation that lets us abstract over the
specific implementations. We will assume that broadly we have
available a notion of <code data-lang="pyret" class="sourceCode">Node</code> that has <code data-lang="pyret" class="sourceCode">content</code>, a notion of
<code data-lang="pyret" class="sourceCode">Key</code>s (whether or not intrinsic), and a way to obtain the
neighborsâ€”<wbr/>a list of keysâ€”<wbr/>given a key and a graph. This is
sufficient for what follows. However, we still need to choose concrete
keys to write examples and tests. For simplicity, weâ€™ll use
string keys [<a href="#%28part._string-keys%29" data-pltdoc="x">Links by Name</a>].</p>&#13;
<h4 class="heading">17.1.3Â <a name="(part._complexity-of-graphs)"/>Measuring Complexity for Graphs<a href="#(part._complexity-of-graphs)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Before we begin to define algorithms over graphs, we should consider
how to measure the size of a graph. A graph has two components:
its nodes and its edges. Some algorithms are going to focus on nodes
(e.g., visiting each of them), while others will focus on edges, and
some will care about both. So which do we use as the basis for
counting operations: nodes or edges?</p><p>It would help if we can reduce these two measures to one. To see
whether thatâ€™s possible, suppose a graph has \(k\) nodes. Then its
number of edges has a wide range, with these two extremes:
</p><ul><li><p>No two nodes are connected. Then there are no edges at all.</p></li><li><p>Every two nodes is connected. Then there are essentially as
many edges as the number of pairs of nodes.</p></li></ul><p>The number of nodes can thus be significantly less or even
significantly more than the number of edges. Were this difference a
matter of constants, we could have ignored it; but itâ€™s not. As a
graph tends towards the former extreme, the ratio of nodes to edges
approaches \(k\) (or even exceeds it, in the odd case where there are
no edges, but this graph is not very interesting); as it tends towards
the latter, it is the ratio of edges to nodes that approaches
\(k^2\). In other words, neither measure subsumes the other by a
constant independent of the graph.</p><p>Therefore, when we want to speak of the complexity of algorithms over
graphs, we have to consider the sizes of both the number of
nodes and edges. In a connected graphA graph is
connected if, from every node, we can traverse edges to get to every
other node., however, there must be at least as many edges as nodes,
which means the number of edges dominates the number of nodes. Since
we are usually processing connected graphs, or connected parts of
graphs one at a time, we can bound the number of nodes by the number
of edges.</p>    
</body>
</html>