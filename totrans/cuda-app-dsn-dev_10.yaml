- en: Chapter 9\. Mixing CUDA and RenderingWith the focus on the use of CUDA to accelerate
    computational tasks, it is easy to forget that GPU technology is also a splendid
    platform for visualization. In combination with the Open Graphics Library (OpenGL),
    CUDA-enabled GPUs become visualization supercomputers. Even highly experienced
    OpenGL programmers will find this chapter both new and informative, as the examples
    use *primitive restart*—a feature recently added to the OpenGL 3.1 standard—to
    render high-performance, high-quality graphics even when the images require irregular
    meshes. Example kernels demonstrate data sharing between CUDA and OpenGL through
    buffer sharing. Profiling will show that primitive restart is 60 times faster
    than the optimized OpenGL **multiDraw()** method because it avoids performance
    robbing transfers across the PCIe bus. This chapter will also discuss how primitive
    restart can produce images of higher quality than other OpenGL methods and optimize
    texture rendering as well. Readers should note that this chapter is intended only
    to teach how to mix CUDA and OpenGL in the same application and demonstrate the
    speed of the methods used. The provided software framework is quite general and
    can be used for experimentation merely by changing the CUDA kernel. For example,
    [Chapter 12](B9780123884268000124.xhtml#B978-0-12-388426-8.00012-4) will use this
    framework with live video streams from a webcam. Those who wish a more detailed
    discussion of OpenGL should look to the many other, far more detailed books and
    Internet tutorials that teach OpenGL and computer graphics.**Keywords**Primitive
    restart, OpenGL, Perlin noise, rendering, profiling, frames per second, interoperability.With
    the focus on the use of CUDA to accelerate computational tasks, it is easy to
    forget that GPU technology is also a splendid platform for visualization. In combination
    with the Open Graphics Library (OpenGL), CUDA-enabled GPUs become visualization
    supercomputers. Even highly experienced OpenGL programmers will find this chapter
    both new and informative, as the examples use **primitive restart**—a feature
    recently added to the OpenGL 3.1 standard—to render high-performance, high-quality
    graphics even when the images require irregular meshes. Example kernels demonstrate
    data sharing between CUDA and OpenGL through buffer sharing. Profiling will show
    that primitive restart is 60 times faster than the optimized OpenGL **multiDraw()**
    method because it avoids performance robbing transfers across the PCIe bus. This
    chapter will also discuss how primitive restart can produce images of higher quality
    than other OpenGL methods and optimize texture rendering as well. Readers should
    note that this chapter is intended only to teach how to mix CUDA and OpenGL in
    the same application and demonstrate the speed of the methods used. The provided
    software framework is quite general and can be used for experimentation merely
    by changing the CUDA kernel. For example, [Chapter 12](B9780123884268000124.xhtml#B978-0-12-388426-8.00012-4)
    will use this framework with live video streams from a webcam. Those who wish
    a more detailed discussion of OpenGL should look to the many other, far more detailed
    books and Internet tutorials that teach OpenGL and computer graphics.At the end
    of this chapter, the reader will have a basic understanding of:■ Mixing OpenGL
    and CUDA in the same application.■ How to use primitive restart and why it can
    generate images of higher quality than other methods.■ The performance implications
    of primitive restart for CUDA and in comparison to other OpenGL rendering techniques.■
    How to use the simple general OpenGL framework in this chapter for your own kernels.■
    The use of Perlin noise to generate artificial terrain.■ The difference between
    a PBO and VBO.
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL
- en: OpenGL is one of the most common programming interfaces used in visual applications
    from games to HPC (high-performance computing). OpenGL is standards-based and
    gives developers the ability to create graphics and special effects that appear
    nearly identical on any operating system running OpenGL-compliant hardware, making
    it possible for developers of 3D games and programs to port their software to
    multiple platforms.OpenGL is controlled by an Architectural Review Board (ARB)
    composed of members from many institutions, including NVIDIA, SGI, Microsoft,
    AMD, HP, and others. The intention of the board is to:■ Keep the API stable.■
    Ensure that the standard evolves to reflect new hardware capabilities.■ Allow
    for platform-specific features through extensions.There are two very clear benefits
    of the separation (yet efficient interoperability) between CUDA and OpenGL:■ **From
    a programming view:** When not mapped into the CUDA memory space, OpenGL gurus
    are free to exploit existing legacy code bases, their expertise, and the full
    power of all the tools available to them, such as GLSL (the OpenGL Shading Language)
    and Cg. CUDA programmers can demonstrate their computational prowess when the
    buffer is mapped into the CUDA memory space.■ **From an investment view:** The
    mapped approach allows efficient exploitation of existing legacy OpenGL software
    investments. Essentially, CUDA code can be gradually added into existing legacy
    libraries and applications just by mapping the buffer into the CUDA memory space.
    This feature allows organizations to test CUDA code without significant risk and
    then enjoy the benefits of CUDA once they are confident of the performance and
    productivity rewards delivered by this programming model.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'OpenGL 是一种在从游戏到高性能计算（HPC）等可视化应用中广泛使用的编程接口。OpenGL 基于标准，使开发者能够创建图形和特效，这些效果在任何运行
    OpenGL 兼容硬件的操作系统上几乎完全相同，这使得 3D 游戏和程序的开发者能够将他们的软件移植到多个平台。OpenGL 由一个架构评审委员会（ARB）控制，该委员会由来自多个机构的成员组成，包括
    NVIDIA、SGI、Microsoft、AMD、HP 等。该委员会的目标是：  '
- en: GLUT
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GLUT
- en: The OpenGL Utility Toolkit (GLUT) is a programming interface for writing window
    system–independent OpenGL programs. Applications that utilize GLUT can be compiled
    on many platforms. NVIDIA uses GLUT in the CUDA SDK examples.The GLUT toolkit
    provides various functionalities, but only a small subset will be used in this
    chapter:■ Windows for OpenGL rendering.■ Callback-driven event processing.■ Mouse
    and keyboard input devices.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL 工具包 (GLUT) 是一个编程接口，用于编写与窗口系统无关的 OpenGL 程序。利用 GLUT 的应用程序可以在多个平台上进行编译。NVIDIA
    在 CUDA SDK 示例中使用 GLUT。GLUT 工具包提供了多种功能，但本章将只使用其中的一小部分：■ 用于 OpenGL 渲染的窗口。■ 回调驱动的事件处理。■
    鼠标和键盘输入设备。
- en: Mapping GPU Memory with OpenGL
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 OpenGL 映射 GPU 内存
- en: From a CUDA programmer's point of view, OpenGL creates and manages regions of
    memory on the GPU in generic buffers called buffer objects. The CUDA/OpenGL interoperability
    happens when a CUDA kernel maps a buffer into CUDA memory space. Control of the
    buffer is returned to OpenGL when the buffer is released, or unmapped. Mapping
    is a low-overhead operation that happens quickly and provides high-speed interoperability
    with CUDA without requiring any memory copies.Interoperability with OpenGL requires
    that the CUDA device be specified by **cudaGLSetGLDevice()** before any other
    runtime calls. Note that **cudaSetDevice()** and **cudaGLSetGLDevice()** are mutually
    exclusive. [¹](#fn9000) Interoperability with OpenGL requires that the CUDA device
    be specified by **cudaGLSetGLDevice()** before any other runtime calls. Once a
    resource is registered to CUDA, it can be mapped and unmapped as many times as
    necessary using **cudaGraphicsMapResources()** and **cudaGraphicsUnmapResources()**.
    The method **cudaGraphicsResourceSetMapFlags()** can be called to provide hints
    (e.g., read-only, write-only) that the CUDA driver can use to optimize resource
    management.¹Please see section 3.2.7.1 of the NVIDIA C Programming Guide, May
    2011, p. 38).There are two principal OpenGL memory objects that CUDA programmers
    will manipulate:1\. **Pixel buffer objects (PBOs):** A region of memory used by
    OpenGL to store *pixels*. A 2D image is composed of multiple pixels, or dots of
    color. CUDA applications map a PBO to create or modify images on a pixel-by-pixel
    basis and display them using OpenGL.2\. **Vertex buffer objects (VBOs):** A region
    of memory that OpenGL uses for 3D vertices. CUDA applications map a VBO to generate
    or modify 3D information that OpenGL can render meshes as a colored surface, wireframe
    image, or set of 3D points.The following is an outline of the key OpenGL calls
    associated with VBO usage (excerpted from the OpenGL VBO whitepaper on [http://spec.org](http://spec.org)):■
    **glBindBuffer():** This function allows client-state functions to use binding
    buffers instead of working in absolute memory on the client side. Buffer object
    names are unsigned integers. The value zero is reserved. Setting the buffer name
    to zero effectively unbinds any buffer object previously bound, and restores client
    memory usage for that buffer object target.■ **glBufferData(), glBufferSubData(),
    and glGetBufferSubData():** These functions control the size of the buffer data,
    provide usage hints, and allow copying to a buffer.■ **glMapBuffer() and glUnmapBuffer():**
    These functions lock and unlock buffers, allowing data to be loaded into them
    or relinquishing control to the server. A temporary pointer is returned as an
    entry to the beginning of the buffer, which also maps the buffer into client memory.
    OpenGL is responsible for how this mapping into the client's absolute memory occurs.
    Because of this responsibility, mapping must be done for a short operation, and
    the pointer is not persistent and should be stored for further use.More detailed
    information about the CUDA API and OpenGL calls used when mixing CUDA with OpenGL
    can be found in parts 15[²](#fn9005) and 18[³](#fn9010) of my *Doctor Dobb*'s
    tutorial series. Another excellent source of information is Joe Stam's 2009 NVIDIA
    GTC conference presentation, “What Every CUDA Programmer Should Know about OpenGL,”
    (Stam, 2009) which is available in both PDF and video formats. [⁴](#fn9015)²[http://drdobbs.com/cpp/222600097](http://drdobbs.com/cpp/222600097).³[http://drdobbs.com/open-source/225200412](http://drdobbs.com/open-source/225200412).⁴[http://www.nvidia.com/content/GTC/documents/1055_GTC09.pdf](http://www.nvidia.com/content/GTC/documents/1055_GTC09.pdf).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从CUDA程序员的角度来看，OpenGL在GPU上创建并管理称为缓冲对象的通用缓冲区内存区域。CUDA/OpenGL的互操作性发生在CUDA内核将缓冲区映射到CUDA内存空间时。当缓冲区被释放或取消映射时，控制权会返回给OpenGL。映射是一个低开销的操作，发生得非常快，并且提供了与CUDA的高速互操作性，无需进行任何内存复制。与OpenGL的互操作性要求在任何其他运行时调用之前，通过**cudaGLSetGLDevice()**指定CUDA设备。请注意，**cudaSetDevice()**和**cudaGLSetGLDevice()**是互斥的。[¹](#fn9000)
    与OpenGL的互操作性要求在任何其他运行时调用之前，通过**cudaGLSetGLDevice()**指定CUDA设备。一旦资源注册到CUDA，就可以使用**cudaGraphicsMapResources()**和**cudaGraphicsUnmapResources()**多次映射和取消映射资源。可以调用方法**cudaGraphicsResourceSetMapFlags()**来提供提示（例如，只读、只写），供CUDA驱动程序用来优化资源管理。（请参见2011年5月《NVIDIA
    C编程指南》第3.2.7.1节，第38页）。CUDA程序员将操作的两个主要OpenGL内存对象如下：1. **像素缓冲对象（PBOs）：** OpenGL用于存储*像素*的内存区域。二维图像由多个像素或颜色点组成。CUDA应用程序映射PBO，以逐像素的方式创建或修改图像，并通过OpenGL显示它们。2.
    **顶点缓冲对象（VBOs）：** OpenGL用于3D顶点的内存区域。CUDA应用程序映射VBO，以生成或修改OpenGL能够渲染的3D信息，渲染为彩色表面、线框图像或一组3D点。以下是与VBO使用相关的OpenGL调用的概要（摘自OpenGL
    VBO白皮书，[http://spec.org](http://spec.org)）：■ **glBindBuffer()：** 该函数允许客户端状态函数使用绑定缓冲区，而不是在客户端侧操作绝对内存。缓冲区对象名称是无符号整数。值零是保留的。将缓冲区名称设置为零，实际上会解绑之前绑定的任何缓冲区对象，并恢复该缓冲区对象目标的客户端内存使用情况。■
    **glBufferData()、glBufferSubData()和glGetBufferSubData()：** 这些函数控制缓冲区数据的大小，提供使用提示，并允许将数据复制到缓冲区中。■
    **glMapBuffer()和glUnmapBuffer()：** 这些函数锁定和解锁缓冲区，允许将数据加载到缓冲区中，或将控制权交还给服务器。返回一个临时指针，作为指向缓冲区开始位置的入口，同时将缓冲区映射到客户端内存中。OpenGL负责如何将此映射到客户端的绝对内存中。由于这个责任，映射必须在短时间内进行，并且指针不是持久的，应该存储以便进一步使用。关于将CUDA与OpenGL混合使用时所使用的CUDA
    API和OpenGL调用的更详细信息，可以参见我的*Doctor Dobb*教程系列的第15部分[²](#fn9005)和第18部分[³](#fn9010)。另一个极好的信息来源是Joe
    Stam在2009年NVIDIA GTC大会上的演讲《每个CUDA程序员应该了解的OpenGL》 （Stam，2009），该演讲有PDF和视频格式可用。[⁴](#fn9015)²[http://drdobbs.com/cpp/222600097](http://drdobbs.com/cpp/222600097)。³[http://drdobbs.com/open-source/225200412](http://drdobbs.com/open-source/225200412)。⁴[http://www.nvidia.com/content/GTC/documents/1055_GTC09.pdf](http://www.nvidia.com/content/GTC/documents/1055_GTC09.pdf)。
- en: Using Primitive Restart for 3D Performance
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用原始重启优化 3D 性能
- en: As mentioned in the introduction to this chapter, the examples herein utilize
    an OpenGL extension called *primitive restart* to minimize communications across
    the PCIe bus and to speed rendering. Primitive restart gives the programmer the
    ability to specify a data value that is interpreted by the OpenGL state machine
    as a token indicating that the current graphics primitive has completed. The next
    data item is assumed to be at the start of another graphics primitive of the same
    type. Valid graphics primitives include **GL_TRIANGLE_STRIP**, **GL_TRIANGLE_FAN**,
    **GL_LINE_STRIP**, and others.[Figure 9.1](#f0010) illustrates this process for
    two lines containing different numbers of vertices. The figure shows that **glPrimitiveRestartIndexNV()**
    is first called to specify the value of **TAG** to be the primitive restart token.
    The routine **glEnableClientState()** is then called to tell the OpenGL state
    machine to start using primitive restart. The lines are then drawn with **glDrawElements()**.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章介绍所述，本文中的示例利用了一个名为*原始重启*的 OpenGL 扩展，旨在最小化通过 PCIe 总线的通信并加速渲染。原始重启使程序员能够指定一个数据值，OpenGL
    状态机将其解释为一个令牌，表示当前的图形基元已经完成。接下来的数据项将被视为另一个相同类型的图形基元的开始。有效的图形基元包括**GL_TRIANGLE_STRIP**、**GL_TRIANGLE_FAN**、**GL_LINE_STRIP**等。[图
    9.1](#f0010)展示了这个过程，包含不同数量顶点的两条线。图中显示，首先调用**glPrimitiveRestartIndexNV()**来指定**TAG**的值为原始重启令牌。接着调用例程**glEnableClientState()**，指示
    OpenGL 状态机开始使用原始重启。然后使用**glDrawElements()**绘制这些线。
- en: '| ![B9780123884268000094/f09-01-9780123884268.jpg is missing](B9780123884268000094/f09-01-9780123884268.jpg)
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| ![B9780123884268000094/f09-01-9780123884268.jpg is missing](B9780123884268000094/f09-01-9780123884268.jpg)
    |'
- en: '| **Figure 9.1**Drawing two lines with primitive restart. |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| **图 9.1** 使用原始重启绘制两条线。 |'
- en: The advantages of the primitive restart approach include:■ All control tokens
    and data for viewing can be generated and kept on the GPU.■ Variable numbers of
    items can be specified between the primitive restart tokens. This allows irregular
    grids and surfaces to be drawn, as arbitrary numbers of line segments, triangle
    strips, triangle fans, and so on, can be specified depending on the drawing mode
    passed to **glDrawElements()**.■ Rendering performance can be optimized by arranging
    the indices to achieve the highest reuse of data cache in the texture units.■
    Higher-quality images can be created by alternating the direction of tessellation
    as noted in the primitive restart specification and illustrated in [Figure 9.2](#f0015)
    and [Figure 9.3](#f0020). The centers of the triangle fan are marked with dots
    in [Figure 9.3](#f0020).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 原始重启方法的优点包括：■ 所有的控制令牌和查看数据可以在 GPU 上生成并保持。■ 可以在原始重启令牌之间指定不同数量的项目。这允许绘制不规则的网格和表面，因为可以根据传递给**glDrawElements()**的绘制模式指定任意数量的线段、三角带、三角扇等。■
    通过调整索引排列以实现纹理单元中数据缓存的最高复用，可以优化渲染性能。■ 通过如原始重启规范中所述的交替镶嵌方向，并在[图 9.2](#f0015)和[图
    9.3](#f0020)中展示，可以创建更高质量的图像。三角扇的中心在[图 9.3](#f0020)中用点标记。
- en: '| ![B9780123884268000094/f09-02-9780123884268.jpg is missing](B9780123884268000094/f09-02-9780123884268.jpg)
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| ![B9780123884268000094/f09-02-9780123884268.jpg 缺失](B9780123884268000094/f09-02-9780123884268.jpg)
    |'
- en: '| **Figure 9.2**Two triangle strips showing aliasing artifacts. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **图 9.2** 显示别名伪影的两个三角带。 |'
- en: '| ![B9780123884268000094/f09-03-9780123884268.jpg is missing](B9780123884268000094/f09-03-9780123884268.jpg)
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| ![B9780123884268000094/f09-03-9780123884268.jpg 缺失](B9780123884268000094/f09-03-9780123884268.jpg)
    |'
- en: '| **Figure 9.3**Triangle fans (center marked with filled circle). |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **图 9.3** 三角扇（中心用实心圆标记）。 |'
- en: OpenGL offers other optimized rendering methods aside from primitive restart,
    such as **multiDraw()**. However, these methods, as the primitive restart specification
    notes, “still remain more expensive than one would like” ([Craighead, 2002](B978012388426800015X.xhtml#ref26)).Following
    is a performance comparison of primitive restart against other OpenGL rendering
    methods. Primitive restart is clearly faster. These tests were performed using
    an Intel 2.3 GHz Core 2 Duo processor running Linux with an NVIDIA GTX 280 CUDA-enabled
    gaming GPU running the Perlin kernel from this chapter to generate a virtual terrain
    map.When interpreting these numbers, it is important to understand that these
    frame rates include the time required to recompute the 3D position and color for
    every vertex and color in the image. This represents a worst-case frame-rate scenario
    that demonstrates the power and speed possible with hybrid CUDA/OpenGL applications.
    Real applications will undoubtedly deliver much higher performance by recalculating
    only the minimum data necessary to render the scene.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL除了原始重启外，还提供其他优化的渲染方法，例如**multiDraw()**。然而，正如原始重启规范所指出的，“这些方法仍然比预期的更昂贵”([Craighead,
    2002](B978012388426800015X.xhtml#ref26))。以下是原始重启与其他OpenGL渲染方法的性能比较。原始重启显然更快。这些测试是在使用Intel
    2.3 GHz Core 2 Duo处理器运行Linux，并配备NVIDIA GTX 280支持CUDA的游戏GPU进行的，运行本章的Perlin内核生成虚拟地形图。在解读这些数字时，重要的是要理解这些帧率包括了重新计算每个顶点和图像中色彩所需的3D位置和颜色的时间。这代表了一个最坏情况的帧率场景，展示了混合CUDA/OpenGL应用程序的强大功能和速度。实际应用无疑会通过仅重新计算渲染场景所需的最小数据来提供更高的性能。
- en: '**Table 9.1\.** Approximate Performance Number on GTX 280'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**表9.1\.** GTX 280上的大致性能数据'
- en: '|  |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| Method | Observed FPS | Rough Average (FPS) |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 观察到的FPS | 粗略平均（FPS） |'
- en: '| Simple one by one | 470–500 | 500 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 简单逐一 | 470–500 | 500 |'
- en: '| MultiDraw | 490–510 | 508 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| MultiDraw | 490–510 | 508 |'
- en: '| Primitive Restart | 550–590 | 560 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 原始重启 | 550–590 | 560 |'
- en: More details can be found in parts 18[⁵](#fn9020) and 20[⁶](#fn9025) of my freely
    available “Supercomputing for the Masses” CUDA tutorials on the *Doctor Dobb's
    Journal* website.⁵[http://drdobbs.com/open-source/225200412](http://drdobbs.com/open-source/225200412).⁶[http://drdobbs.com/tools/227400145](http://drdobbs.com/tools/227400145).The
    timeline in [Figure 9.4](#f0025) from Parallel Nsight shows that the Perlin kernel
    consumes very little time compared to the OpenGL buffer swapping.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 更多细节可以在我的免费“超级计算为大众”CUDA教程的第18部分[⁵](#fn9020)和第20部分[⁶](#fn9025)中找到，这些教程发布在*Doctor
    Dobb's Journal*网站上。[http://drdobbs.com/open-source/225200412](http://drdobbs.com/open-source/225200412)⁵。[http://drdobbs.com/tools/227400145](http://drdobbs.com/tools/227400145)⁶。从Parallel
    Nsight中的[图9.4](#f0025)可以看到，Perlin内核相比OpenGL缓冲区交换消耗的时间非常少。
- en: '| ![B9780123884268000094/f09-04-9780123884268.jpg is missing](B9780123884268000094/f09-04-9780123884268.jpg)
    |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| ![B9780123884268000094/f09-04-9780123884268.jpg 找不到](B9780123884268000094/f09-04-9780123884268.jpg)
    |'
- en: '| **Figure 9.4**Parallel Nsight showing computation versus rendering time when
    using primitive restart. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **图 9.4** Parallel Nsight 显示使用原始重启时的计算与渲染时间。 |'
- en: 'The OpenGL API Call Summary in Parallel Nsight reports the following time for
    each rendering method.■ Primitive restart: around 60 μs (microseconds).■ Multidraw:
    around 3,900 μs.■ Iteratively drawing each triangle fan: approximately 1,100,000
    μs.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL API 调用汇总在 Parallel Nsight 报告中显示了每种渲染方法的以下时间。■ 原始重启：大约 60 微秒（μs）。■ 多重绘制：大约
    3,900 微秒。■ 逐个绘制每个三角形扇：大约 1,100,000 微秒。
- en: Introduction to the Files in the Framework
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架中文件的介绍
- en: Readers should note that care was taken in the design of the software framework
    so that it could be adapted to new applications. For example, this same framework
    was used in chapter twelve to display and modify live video streams. To compartmentalize
    operations, the framework was broken into four separate files. Merely by changing
    the CUDA kernel, this example code can be used to render an animated sinusoidal
    surface or an artificial terrain that the user can explore and fly around in.
    The examples are known to compile and run on Linux and Windows.For clarity and
    flexibility, separate 3D vertex and color arrays are used within the example code.
    This helps speed understanding and makes data visualization as easy as writing
    a new kernel or loading data from disk to alter the 3D vertex array, color array,
    or both. Those readers who choose to create their own CUDA kernels should gain
    a strong practical sense of how easy and flexible visualization can be with a
    combined CUDA/OpenGL approach.The relationship between the four files used in
    the framework discussed in this chapter is illustrated in [Figure 9.5](#f0030).
    Each of the files is discussed in more detail below.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 读者应注意，在软件框架的设计中，已经考虑到可以将其适应新应用的需求。例如，章十二中使用了相同的框架来显示和修改实时视频流。为了将操作进行模块化，框架被拆分成四个独立的文件。仅通过更改
    CUDA 内核，这段示例代码就可以用来渲染一个动画正弦波表面或一个人工地形，用户可以在其中探索并飞行。已知这些示例可以在 Linux 和 Windows 上编译和运行。为了清晰和灵活性，示例代码中使用了独立的
    3D 顶点和颜色数组。这有助于加速理解，并使数据可视化变得像编写新内核或从磁盘加载数据来修改 3D 顶点数组、颜色数组或两者一样简单。那些选择创建自己 CUDA
    内核的读者，应当获得一个强烈的实践感，了解通过结合 CUDA/OpenGL 方法进行可视化是多么简单和灵活。本章中讨论的框架中使用的四个文件之间的关系如[图
    9.5](#f0030)所示。每个文件将在下文中更详细地讨论。
- en: '| ![B9780123884268000094/f09-05-9780123884268.jpg is missing](B9780123884268000094/f09-05-9780123884268.jpg)
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| ![B9780123884268000094/f09-05-9780123884268.jpg is missing](B9780123884268000094/f09-05-9780123884268.jpg)
    |'
- en: '| **Figure 9.5**Organization of files and activities. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **图 9.5** 文件和活动的组织。 |'
- en: The Demo and Perlin Example Kernels
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 演示和 Perlin 示例内核
- en: Two example kernels are provided in this chapter, demo and Perlin. Each kernel
    generates both 3D vertices and colors.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了两个示例内核：演示内核和 Perlin 内核。每个内核都会生成 3D 顶点和颜色。
- en: The Demo Kernel
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 演示内核
- en: The demo kernel creates an animated sinusoidal surface very similar to the NVIDIA
    simpleGL SDK example. It is a good test case to confirm that the code is working
    and to evaluate the speed of a GPU.[Figure 9.6](#f0035) shows a grayscale screenshot
    of the highly colorful surface generated with the demo kernel. Also, note that
    the colors will evolve with time. Keyboard input allows selecting between rendering
    the surface with triangles (shown in [Figure 9.6](#f0035)), lines (not shown),
    or dots (shown in [Figure 9.7](#f0040)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 演示内核生成的动画正弦波曲面与 NVIDIA simpleGL SDK 示例非常相似。它是一个很好的测试用例，可以确认代码是否正常工作，并评估 GPU
    的速度。[图 9.6](#f0035)显示了使用演示内核生成的色彩丰富的曲面的灰度截图。另外，请注意，颜色会随时间变化。键盘输入可以选择使用三角形（如[图
    9.6](#f0035)所示）、线条（未显示）或点（如[图 9.7](#f0040)所示）来渲染曲面。
- en: '| ![B9780123884268000094/f09-06-9780123884268.jpg is missing](B9780123884268000094/f09-06-9780123884268.jpg)
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| ![B9780123884268000094/f09-06-9780123884268.jpg 文件缺失](B9780123884268000094/f09-06-9780123884268.jpg)
    |'
- en: '| **Figure 9.6**Grayscale example of a surface created with the sinusoidal-surface
    VBO. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **图 9.6**使用正弦波曲面 VBO 创建的表面灰度示例。 |'
- en: '| ![B9780123884268000094/f09-07-9780123884268.jpg is missing](B9780123884268000094/f09-07-9780123884268.jpg)
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| ![B9780123884268000094/f09-07-9780123884268.jpg 文件缺失](B9780123884268000094/f09-07-9780123884268.jpg)
    |'
- en: '| **Figure 9.7**Grayscale of a sinusoid of points (the image colors were inverted
    to increase visibility). |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **图 9.7**点的正弦波灰度图（为了提高可视性，图像颜色已反转）。 |'
- en: The Demo Kernel to Generate a Colored Sinusoidal Surface
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成彩色正弦曲面演示内核
- en: The demo kernel draws a time-varying sinusoidal surface by calculating a height
    value for each location in a 2D mesh. The height value varies by time. See [Example
    9.1](#tb0010), “Calculating the Heights of the Sinusoidal Surface”:`// calculate
    simple sine wave pattern``float freq = 4.0f;``float w = sinf(u*freq + time) *
    cosf(v*freq + time) * 0.5f;`The position and height information is stored in the
    float4 position, or **pos**, array, as shown in [Example 9.2](#tb9000)`// write
    output vertex``pos[y*width+x] = make_float4(u, w, v, 1.0f);`Similarly, the colors
    are calculated based on position in the mesh and the animation time, as shown
    in [Example 9.3](#tb0020), “Calculating the Colors of the Sinusoidal Surface”:`//
    write the color``colorPos[y*width+x].w = 0;``colorPos[y*width+x].x = 255.f *0.5*(1.f+sinf(w+x));``colorPos[y*width+x].y
    = 255.f *0.5*(1.f+sinf(x)*cosf(y));``colorPos[y*width+x].z = 255.f *0.5*(1.f+sinf(w+time/10.f));`The
    complete listing for **kernelVBO** is as shown in [Example 9.4](#tb0025), “The
    Complete Source for the demo Kernel”:`// sinusoidal kernel (Rob Farber)``// Simple
    kernel to modify vertex positions in sine wave pattern``__global__ void kernel(float4*
    pos, uchar4 *colorPos,``unsigned int width, unsigned int height, float time)``{``unsigned
    int x = blockIdx.x*blockDim.x + threadIdx.x;``unsigned int y = blockIdx.y*blockDim.y
    + threadIdx.y;``// calculate uv coordinates``float u = x / (float) width;``float
    v = y / (float) height;``u = u*2.0f - 1.0f;``v = v*2.0f - 1.0f;``// calculate
    simple sine wave pattern``float freq = 4.0f;``float w = sinf(u*freq + time) *
    cosf(v*freq + time) * 0.5f;``// write output vertex``pos[y*width+x] = make_float4(u,
    w, v, 1.0f);``colorPos[y*width+x].w = 0;``colorPos[y*width+x].x = 255.f *0.5*(1.f+sinf(w+x));``colorPos[y*width+x].y
    = 255.f *0.5*(1.f+sinf(x)*cosf(y));``colorPos[y*width+x].z = 255.f *0.5*(1.f+sinf(w+time/10.f));``}`The
    **launch_kernel()** method calculates the execution configuration and queues the
    launch of the demo kernel with the appropriate parameters, as shown in [Example
    9.5](#tb0030), “The Source Showing the Logic to Launch the demo Kernel”:`// Wrapper
    for the __global__ call that sets up the kernel call``extern "C" void launch_kernel(float4*
    pos, uchar4* colorPos,``unsigned int mesh_width, unsigned int mesh_height,``float
    time)``{``// execute the kernel``dim3 block(8, 8, 1);``dim3 grid(mesh_width /
    block.x, mesh_height / block.y, 1);``kernel<<< grid, block>>>(pos, colorPos, mesh_width,
    mesh_height, time);``}`
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 演示内核通过计算二维网格中每个位置的高度值，绘制一个随时间变化的正弦曲面。高度值随时间变化。请参见[示例 9.1](#tb0010)， “计算正弦曲面高度”：`//
    计算简单的正弦波模式``float freq = 4.0f;``float w = sinf(u*freq + time) * cosf(v*freq +
    time) * 0.5f;`位置和高度信息存储在`float4 position`或**pos**数组中，如[示例 9.2](#tb9000)所示：`//
    写入输出顶点``pos[y*width+x] = make_float4(u, w, v, 1.0f);`类似地，颜色根据网格中的位置和动画时间计算，如[示例
    9.3](#tb0020)， “计算正弦曲面颜色”所示：`// 写入颜色``colorPos[y*width+x].w = 0;``colorPos[y*width+x].x
    = 255.f *0.5*(1.f+sinf(w+x));``colorPos[y*width+x].y = 255.f *0.5*(1.f+sinf(x)*cosf(y));``colorPos[y*width+x].z
    = 255.f *0.5*(1.f+sinf(w+time/10.f));`**kernelVBO**的完整代码如[示例 9.4](#tb0025)所示，“演示内核的完整源代码”：`//
    正弦内核 (Rob Farber)``// 简单的内核修改顶点位置，呈正弦波模式``__global__ void kernel(float4* pos,
    uchar4 *colorPos,``unsigned int width, unsigned int height, float time)``{``unsigned
    int x = blockIdx.x*blockDim.x + threadIdx.x;``unsigned int y = blockIdx.y*blockDim.y
    + threadIdx.y;``// 计算 uv 坐标``float u = x / (float) width;``float v = y / (float)
    height;``u = u*2.0f - 1.0f;``v = v*2.0f - 1.0f;``// 计算简单的正弦波模式``float freq = 4.0f;``float
    w = sinf(u*freq + time) * cosf(v*freq + time) * 0.5f;``// 写入输出顶点``pos[y*width+x]
    = make_float4(u, w, v, 1.0f);``colorPos[y*width+x].w = 0;``colorPos[y*width+x].x
    = 255.f *0.5*(1.f+sinf(w+x));``colorPos[y*width+x].y = 255.f *0.5*(1.f+sinf(x)*cosf(y));``colorPos[y*width+x].z
    = 255.f *0.5*(1.f+sinf(w+time/10.f));``}`**launch_kernel()**方法计算执行配置，并使用适当的参数队列启动演示内核，如[示例
    9.5](#tb0030)， “显示启动演示内核逻辑的源代码”所示：`// __global__ 调用的包装器，设置内核调用``extern "C" void
    launch_kernel(float4* pos, uchar4* colorPos,``unsigned int mesh_width, unsigned
    int mesh_height,``float time)``{``// 执行内核``dim3 block(8, 8, 1);``dim3 grid(mesh_width
    / block.x, mesh_height / block.y, 1);``kernel<<< grid, block>>>(pos, colorPos,
    mesh_width, mesh_height, time);``}`
- en: Perlin Noise
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Perlin噪声
- en: Many people use random number generators to add variation and unpredictability
    to their applications. Landscapes exhibit both variation and seeming unpredictability,
    but not purely at random. Instead they vary at different scales, meaning that
    they have various levels of detail. A mountain range demonstrates this variation
    in scale:■ **Large scale:** the outline of the mountain range.■ **Medium scale:**
    various hills, valleys, and other features.■ **Small variation:** boulders and
    rock outcroppings are common examples.■ **Tiny variations:** stones and the bumps
    you see when hiking on a trail.Perlin noise is function for generating *coherent
    noise* over a space. Coherent noise means that for any two points in the space,
    the value of the noise function changes smoothly as you move from one point to
    the other; that is, there are no discontinuities. Natural phenomena tend to exhibit
    the same pattern of large and small variations. The Perlin noise function recreates
    this natural effect by simply adding up noisy functions at a range of different
    scales.In 1997, Ken Perlin received an academy award for developing the Perlin
    noise generator. Perlin noise has a multitude of uses ranging from the creation
    of natural textures to artificial terrain and even worlds! Numerous websites discuss
    Perlin noise. Ken Perlin's homepage is an excellent place to start. [⁷](#fn9030)⁷[http://cs.nyu.edu/~perlin/](http://cs.nyu.edu/~perlin/).The
    Perlin noise kernel will be used to create a height map of virtual terrain shown
    in [Figure 9.8](#f0045), [Figure 9.9](#f0050) and [Figure 9.10](#f0055). The user
    can fly around this virtual world and dynamically alter it with the keyboard commands
    defined in *callbacksVBO.cu*. [Figure 9.8](#f0045) shows the virtual terrain rendered
    as a surface with triangles. [Figure 9.9](#f0050) show the surface rendered as
    a wireframe with lines, and [Figure 9.10](#f0055) shows a pilot's-eye view of
    the artificial terrain during a virtual “flight.”
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '许多人使用随机数生成器为他们的应用程序添加变化和不可预测性。景观展示了变化和看似不可预测性，但并非完全随机。相反，它们在不同的尺度上变化，这意味着它们有不同的细节层次。山脉就展示了这种尺度上的变化：■
    **大尺度：** 山脉轮廓。■ **中尺度：** 各种山丘、山谷和其他地形特征。■ **小变化：** 巨石和岩石突出物是常见的例子。■ **微小变化：**
    石块以及你在徒步旅行时看到的小凸起。Perlin噪声是一种生成*连贯噪声*的函数，适用于空间中的任何位置。连贯噪声意味着，在空间中的任意两点之间，噪声函数的值随着你从一点移动到另一点时平滑变化；也就是说，没有不连续性。自然现象往往表现出相同的大的和小的变化模式。Perlin噪声函数通过在多个不同尺度上简单地叠加噪声函数来重现这一自然效果。  '
- en: '| ![B9780123884268000094/f09-08-9780123884268.jpg is missing](B9780123884268000094/f09-08-9780123884268.jpg)
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| ![B9780123884268000094/f09-08-9780123884268.jpg 丢失](B9780123884268000094/f09-08-9780123884268.jpg)
    |'
- en: '| **Figure 9.8**Grayscale example of a 3D surface created with the Perlin noise
    kernel. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **图 9.8** 使用 Perlin 噪声内核创建的 3D 表面的灰度示例。 |'
- en: '| ![B9780123884268000094/f09-09-9780123884268.jpg is missing](B9780123884268000094/f09-09-9780123884268.jpg)
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| ![B9780123884268000094/f09-09-9780123884268.jpg 丢失](B9780123884268000094/f09-09-9780123884268.jpg)
    |'
- en: '| **Figure 9.9**Grayscale of a terrain wireframe. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **图 9.9** 地形线框的灰度图。 |'
- en: '| ![B9780123884268000094/f09-10-9780123884268.jpg is missing](B9780123884268000094/f09-10-9780123884268.jpg)
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| ![B9780123884268000094/f09-10-9780123884268.jpg 丢失](B9780123884268000094/f09-10-9780123884268.jpg)
    |'
- en: '| **Figure 9.10**Grayscale version of a pilot''s-eye view. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **图 9.10** 飞行员视角的灰度版本。 |'
- en: Using the Perlin Noise Kernel to Generate Artificial Terrain
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Perlin 噪声内核生成人工地形
- en: 'The following example uses the Improved Perlin Noise generator from parts 15[⁸](#fn9035)
    and 18[⁹](#fn9040) of my “Supercomputing for the Masses” tutorial series on the
    *Doctor Dobb''s Journal* website. For implementation simplicity, fBm (Fractal
    Brownian Motion) was chosen to generate the fractal terrain, which is simply a
    weighted sum of multiple scales of an arbitrary basis function, such as noise.
    Better methods exist to create more realistic landscapes, as noted in “Fractal
    Landscape and Texture Generation” on the Max Plank Institute website ([Max Planck
    Institute, 2004](B978012388426800015X.xhtml#ref131)). [^(10)](#fn9045)⁸[http://drdobbs.com/cpp/222600097](http://drdobbs.com/cpp/222600097).⁹[http://drdobbs.com/open-source/225200412](http://drdobbs.com/open-source/225200412).^(10)[http://www.mpi-inf.mpg.de/departments/irg3/ws0405/cg/rcomp/29/x173.html](http://www.mpi-inf.mpg.de/departments/irg3/ws0405/cg/rcomp/29/x173.html).The
    kernel starting in [Example 9.6](#tb0035) is slightly more complicated than the
    demo kernel. The first part of the kernel specifies the include files, variables,
    and methods used in the Perlin noise calculation. A discussion and link to the
    reference paper is found on the NYU Media Research Lab website. [^(11)](#fn0010)^(11)[http://vlg.cs.nyu.edu/](http://vlg.cs.nyu.edu/).`//Perlin
    kernel (Rob Farber)``#include <cutil_math.h>``#include <cutil_inline.h>``#include
    <cutil_gl_inline.h>``#include <cuda_gl_interop.h>``extern float gain, xStart,
    yStart, zOffset, octaves, lacunarity;``#define Z_PLANE 50.f``__constant__ unsigned
    char c_perm[256];``__shared__ unsigned char s_perm[256]; // shared memory copy
    of permuation array``unsigned char* d_perm=NULL; // global memory copy of permutation
    array``// host version of permutation array``const static unsigned char h_perm[]
    = {151,160,137,91,90,15,``131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,
    37,240,21,10,23,190, 6,148,247,120,234,75,0,26,197,62,94,252, 219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,
    136,171,168, 68,175,74,165,71,134,139,48,27,166,77,146,158, 231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,
    40,244,102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187, 208, 89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,
    173,186, 3,64,52,217,226,250,124,123,5,202,38,147,118,126,255, 82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,
    170,213,119,248,152,2,44,154,163, 70,221,153,101,155,167, 43, 172,9,129,22,39,253,
    19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,
    162,241, 81,51,145,235,249,14,239,107,49,192,214, 31,181,199, 106,157,184,84,204,176,115,121,50,45,127,
    4,150,254,138,236, 205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180``};``__device__
    inline int perm(int i) { return(s_perm[i&0xff]); }``__device__ inline float fade(float
    t) { return t * t * t * (t * (t * 6.f − 15.f) + 10.f); }``__device__ inline float
    lerpP(float t, float a, float b) { return a + t * (b − a); }``__device__ inline
    float grad(int hash, float x, float y, float z) {``int h = hash & 15;// CONVERT
    LO 4 BITS OF HASH CODE``float u = h<8 ? x : y,// INTO 12 GRADIENT DIRECTIONS.``v
    = h<4 ? y : h==12||h==14 ? x : z;``return ((h&1) == 0 ? u : −u) + ((h&2) == 0
    ? v : −v);``}``__device__ float inoise(float x, float y, float z) {``int X = ((int)floorf(x))
    & 255,// FIND UNIT CUBE THAT``Y = ((int)floorf(y)) & 255,// CONTAINS POINT.``Z
    = ((int)floorf(z)) & 255;``x −= floorf(x);// FIND RELATIVE X,Y,Z``y −= floorf(y);//
    OF POINT IN CUBE.``z −= floorf(z);``float u = fade(x),// COMPUTE FADE CURVES``v
    = fade(y),// FOR EACH OF X,Y,Z.``w = fade(z);``int A = perm(X)+Y, AA = perm(A)+Z,
    AB = perm(A+1)+Z, // HASH COORDINATES OF``B = perm(X+1)+Y, BA = perm(B)+Z, BB
    = perm(B+1)+Z; // THE 8 CUBE CORNERS,``return lerpP(w, lerpP(v, lerpP(u, grad(perm(AA),
    x , y , z ), // AND ADD``grad(perm(BA), x−1.f, y , z)),// BLENDED``lerpP(u, grad(perm(AB),
    x , y−1.f, z),// RESULTS``grad(perm(BB), x−1.f, y−1.f, z))),// FROM 8``lerpP(v,
    lerpP(u, grad(perm(AA+1), x , y , z−1.f ), // CORNERS``grad(perm(BA+1), x−1.f,
    y , z−1.f )),// OF CUBE``lerpP(u, grad(perm(AB+1), x , y-1.f, z-1.f ),``grad(perm(BB+1),
    x−1.f, y-1.f, z−1.f ))));``}``__device__ float fBm(float x, float y, int octaves,``float
    lacunarity = 2.0f, float gain = 0.5f)``{``float freq = 1.0f, amp = 0.5f;``float
    sum = 0.f;``for(int i=0; i<octaves; i++) {``sum += inoise(x*freq, y*freq, Z_PLANE)*amp;``freq
    *= lacunarity;``amp *= gain;``}``return sum;``}`The **colorElevation()** method
    returns a pixel color based on the elevation in the terrain. The colors were chosen
    to give the user a sense of looking at a map. See [Example 9.7](#tb0040), “Part
    2 of the Improved Perlin Noise Kernel”:`__device__ inline uchar4 colorElevation(float
    texHeight)``{``uchar4 pos;``// color textel (r,g,b,a)``if (texHeight < -1.000f)
    pos = make_uchar4(000, 000, 128, 255); //deeps``else if (texHeight < -.2500f)
    pos = make_uchar4(000, 000, 255, 255); //shallow``else if (texHeight < 0.0000f)
    pos = make_uchar4(000, 128, 255, 255); //shore``else if (texHeight < 0.0125f)
    pos = make_uchar4(240, 240, 064, 255); //sand``else if (texHeight < 0.1250f) pos
    = make_uchar4(032, 160, 000, 255); //grass``else if (texHeight < 0.3750f) pos
    = make_uchar4(224, 224, 000, 255); //dirt``else if (texHeight < 0.7500f) pos =
    make_uchar4(128, 128, 128, 255); //rock``elsepos = make_uchar4(255, 255, 255,
    255); //snow``return(pos);``}`A method to check for errors is shown in [Example
    9.8](#tb0045), “Part 3 of the Improved Perlin Noise Kernel”:`void checkCUDAError(const
    char *msg) {``cudaError_t err = cudaGetLastError();``if( cudaSuccess != err) {``fprintf(stderr,
    "Cuda error: %s: %s.\n", msg, cudaGetErrorString( err) );``exit(EXIT_FAILURE);``}``}`The
    **k_perlin()** kernel calls the Perlin noise to generate the terrain map. Regions
    that are below sea level are set to zero. The call to **cudaThreadSynchronize()**
    is important because it causes the host to wait until after the kernel has completed
    updating the OpenGL buffers. See [Example 9.9](#tb0050), “Part 4 of the Improved
    Perlin Noise Kernel”:`//Simple kernel fills an array with perlin noise``__global__
    void k_perlin(float4* pos, uchar4 *colorPos,``unsigned int width, unsigned int
    height,``float2 start, float2 delta, float gain, float zOffset,``unsigned char*
    d_perm, float octaves, float lacunarity)``{``int idx = blockIdx.x * blockDim.x
    + threadIdx.x;``float xCur = start.x + ((float) (idx%width)) * delta.x;``float
    yCur = start.y + ((float) (idx/width)) * delta.y;``if(threadIdx.x < 256)``// Optimization:
    this causes bank conflicts``s_perm[threadIdx.x] = d_perm[threadIdx.x];``// this
    synchronization can be important if there are more than 256 threads``__syncthreads();``//
    Each thread creates one pixel location in the texture (textel)``if(idx < width*height)
    {``float w = fBm(xCur, yCur, octaves, lacunarity, gain) + zOffset;``colorPos[idx]
    = colorElevation(w);``float u = ((float) (idx%width))/(float) width;``float v
    = ((float) (idx/width))/(float) height;``u = u*2.f - 1.f;``v = v*2.f - 1.f;``w
    = (w>0.f)?w:0.f; // don''t show regions underwater``pos[idx] = make_float4( u,
    w, v, 1.0f);``}``}``uchar4 *eColor=NULL;``// Wrapper for the __global__ call that
    sets up the kernel call``extern "C" void launch_kernel(float4 *pos, uchar4* posColor,``unsigned
    int image_width, unsigned int image_height, float time)``{``int nThreads=256;
    // must be equal or larger than 256! (see s_perm)``int totalThreads = image_height
    * image_width;``int nBlocks = totalThreads/nThreads;``nBlocks += ((totalThreads%nThreads)>0)?1:0;``float
    xExtent = 10.f;``float yExtent = 10.f;``float xDelta = xExtent/(float)image_width;``float
    yDelta = yExtent/(float)image_height;``if(!d_perm) { // for convenience allocate
    and copy d_perm here``cudaMalloc((void**) &d_perm,sizeof(h_perm));``cudaMemcpy(d_perm,h_perm,sizeof(h_perm),cudaMemcpyHostToDevice);``checkCUDAError("d_perm
    malloc or copy failed!");``}``k_perlin<<< nBlocks, nThreads>>>(pos, posColor,
    image_width, image_height,``make_float2(xStart, yStart),``make_float2(xDelta,
    yDelta),``gain, zOffset, d_perm,``octaves, lacunarity);``// make certain the kernel
    has completed``cudaThreadSynchronize();``checkCUDAError("kernel failed!");``}`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '以下示例使用了我在*Doctor Dobb''s Journal*网站上的《面向大众的超级计算》教程系列第15[⁸](#fn9035)和第18[⁹](#fn9040)部分中的改进版Perlin噪声生成器。为了实现简单，选择了fBm（分形布朗运动）来生成分形地形，这仅仅是多个尺度的任意基函数（如噪声）的加权和。正如《分形地形与纹理生成》在马克斯·普朗克研究所网站上所指出的，存在更好的方法来创建更逼真的景观（[Max
    Planck Institute, 2004](B978012388426800015X.xhtml#ref131)）。[^(10)](#fn9045)⁸[http://drdobbs.com/cpp/222600097](http://drdobbs.com/cpp/222600097).⁹[http://drdobbs.com/open-source/225200412](http://drdobbs.com/open-source/225200412).^(10)[http://www.mpi-inf.mpg.de/departments/irg3/ws0405/cg/rcomp/29/x173.html](http://www.mpi-inf.mpg.de/departments/irg3/ws0405/cg/rcomp/29/x173.html)。从[示例9.6](#tb0035)开始的内核比演示内核稍微复杂。内核的第一部分指定了Perlin噪声计算中使用的包含文件、变量和方法。关于该部分的讨论和参考论文的链接可以在NYU媒体研究实验室网站上找到。[^(11)](#fn0010)^(11)[http://vlg.cs.nyu.edu/](http://vlg.cs.nyu.edu/)。`//Perlin内核（Rob
    Farber）``#include <cutil_math.h>``#include <cutil_inline.h>``#include <cutil_gl_inline.h>``#include
    <cuda_gl_interop.h>``extern float gain, xStart, yStart, zOffset, octaves, lacunarity;``#define
    Z_PLANE 50.f``__constant__ unsigned char c_perm[256];``__shared__ unsigned char
    s_perm[256]; // permuation数组的共享内存副本``unsigned char* d_perm=NULL; // permuation数组的全局内存副本``//
    permuation数组的主机版本``const static unsigned char h_perm[] = {151,160,137,91,90,15,``131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,
    37,240,21,10,23,190, 6,148,247,120,234,75,0,26,197,62,94,252, 219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,
    136,171,168, 68,175,74,165,71,134,139,48,27,166,77,146,158, 231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,
    40,244,102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187, 208, 89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,
    173,186, 3,64,52,217,226,250,124,123,5,202,38,147,118,126,255, 82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,
    170,213,119,248,152,2,44,154,163, 70,221,153,101,155,167, 43, 172,9,129,22,39,253,
    19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,
    162,241, 81,51,145,235,249,14,239,107,49,192,214, 31,181,199, 106,157,184,84,204,176,115,121,50,45,127,
    4,150,254,138,236, 205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180``};``__device__
    inline int perm(int i) { return(s_perm[i&0xff]); }``__device__ inline float fade(float
    t) { return t * t * t * (t * (t * 6.f − 15.f) + 10.f); }``__device__ inline float
    lerpP(float t, float a, float b) { return a + t * (b − a); }``__device__ inline
    float grad(int hash, float x, float y, float z) {``int h = hash & 15;// 将哈希代码的低4位转换为12个梯度方向。``float
    u = h<8 ? x : y,// 其中v = h<4 ? y : h==12||h==14 ? x : z;``return ((h&1) == 0 ?
    u : −u) + ((h&2) == 0 ? v : −v);``}``__device__ float inoise(float x, float y,
    float z) {``int X = ((int)floorf(x)) & 255,// 查找包含点的单元立方体。``Y = ((int)floorf(y))
    & 255,// 查找包含点的单元立方体。``Z = ((int)floorf(z)) & 255;``x −= floorf(x);// 查找点在立方体中的相对坐标。``y
    −= floorf(y);// 查找点在立方体中的相对坐标。``z −= floorf(z);``float u = fade(x),// 计算每个坐标轴的淡化曲线``v
    = fade(y),// 计算每个坐标轴的淡化曲线``w = fade(z);``int A = perm(X)+Y, AA = perm(A)+Z, AB
    = perm(A+1)+Z, // 哈希坐标，``B = perm(X+1)+Y, BA = perm(B)+Z, BB = perm(B+1)+Z; //
    8个立方体角的坐标，``return lerpP(w, lerpP(v, lerpP(u, grad(perm(AA), x , y , z ), // 8个角的混合结果``grad(perm(BA),
    x−1.f, y , z)), // 混合结果``lerpP(u, grad(perm(AB), x , y−1.f, z),``grad(perm(BB),
    x−1.f, y−1.f, z))), // 混合结果``lerpP(v, lerpP(u, grad(perm(AA+1), x , y , z−1.f
    ), // 立方体角的渐变结果``grad(perm(BA+1), x−1.f, y , z−1.f )), // 混合结果``lerpP(u, grad(perm(AB+1),
    x , y-1.f, z-1.f ),``grad(perm(BB+1), x−1.f, y−1.f, z−1.f ))));``}``__device__
    float fBm(float x, float y, int octaves,``float lacunarity = 2.0f, float gain
    = 0.5f)``{``float freq = 1.0f, amp = 0.5f;``float sum = 0.f;``for(int i=0; i<octaves;
    i++) {``sum += inoise(x*freq, y*freq, Z_PLANE)*amp;``freq *= lacunarity;``amp
    *= gain;``}``return sum;``}`**colorElevation()**方法根据地形的海拔返回像素颜色。选择的颜色使用户有种查看地图的感觉。见[示例9.7](#tb0040)，《改进版Perlin噪声内核第2部分》:`__device__
    inline uchar4 colorElevation(float texHeight)``{``uchar4 pos;``// 颜色像素（r,g,b,a）``if
    (texHeight < -1.000f) pos = make_uchar4(000, 000, 128, 255); //深海``else if (texHeight
    < -.2500f) pos = make_uchar4(000, 000, 255, 255); //浅海``else if (texHeight < 0.0000f)
    pos = make_'
- en: The simpleGLmain.cpp File
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*simplGLmain.cpp* 文件'
- en: The *simplGLmain.cpp* file opens a window on the screen and sets some basic
    viewing transforms. The call to **gluPerspective()** places a camera in a three-dimensional
    location from which to view the data generated with CUDA.Three-dimensional rendering
    occurs in OpenGL when the programmer:■ Specifies objects in 3D space using simple
    triangles, vertices, and lines.■ Defines a virtual camera position and viewing
    angle.OpenGL can then identify and update the display pixels as the data and/or
    viewing position changes.Rendering requires the following 3D transform:1\. Position
    and point the camera at the scene (a view transformation).2\. Arrange the scene
    composition (a model transform).3\. Adjust the camera zoom (a projection transform).4\.
    Choose the final size (a viewport transform).OpenGL view, model, projection, and
    viewport transforms plus specification of the coordinate system require very detailed
    thinking and explanation. Song Ho Ann[^(12)](#fn0015) has an excellent set of
    tutorials, including visual aids to help understand the details of OpenGL transforms
    and the OpenGL rendering pipeline, the differences between pixel and geometry
    rendering, the OpenGL projection matrix, and much more. Numerous other excellent
    sources are also available, including the online version of the OpenGL Red Book.^(12)[http://songho.ca/opengl](http://songho.ca/opengl).The
    schematic in [Figure 9.11](#f0060) summarizes how the VBO example code interacts
    with GLUT. [^(13)](#fn9050)^(13)[http://www.opengl.org/documentation/red_book/](http://www.opengl.org/documentation/red_book/).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*simplGLmain.cpp* 文件在屏幕上打开一个窗口，并设置一些基本的视图变换。调用**gluPerspective()** 将相机置于一个三维位置，以便从中查看使用
    CUDA 生成的数据。当程序员执行以下操作时，OpenGL 会进行三维渲染：■ 使用简单的三角形、顶点和线条在 3D 空间中指定对象。■ 定义虚拟相机的位置和视角。然后，OpenGL
    可以识别并更新显示像素，随着数据和/或视角的变化。渲染需要以下三维变换：1\. 定位并将相机指向场景（视图变换）。2\. 安排场景构成（模型变换）。3\.
    调整相机的缩放（投影变换）。4\. 选择最终大小（视口变换）。OpenGL 的视图、模型、投影和视口变换加上坐标系的定义需要非常详细的思考和解释。Song
    Ho Ann[^(12)](#fn0015) 提供了一套优秀的教程，包括视觉辅助工具，帮助理解 OpenGL 变换的细节、OpenGL 渲染管线、像素与几何渲染的区别、OpenGL
    投影矩阵等内容。还有许多其他优秀的资源可供参考，包括 OpenGL 红皮书的在线版本。^(12)[http://songho.ca/opengl](http://songho.ca/opengl)。[图
    9.11](#f0060) 中的示意图总结了 VBO 示例代码与 GLUT 的交互。[^(13)](#fn9050)^(13)[http://www.opengl.org/documentation/red_book/](http://www.opengl.org/documentation/red_book/).'
- en: '| ![B9780123884268000094/f09-11-9780123884268.jpg is missing](B9780123884268000094/f09-11-9780123884268.jpg)
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| ![B9780123884268000094/f09-11-9780123884268.jpg 丢失](B9780123884268000094/f09-11-9780123884268.jpg)
    |'
- en: '| **Figure 9.11**Schematic of GLUT VBO code interactions. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **图 9.11** GLUT VBO 代码交互示意图。|'
- en: 'The following example is the complete source code for the VBO version of *simpleGLmain.cpp*.
    This is fairly generic code that should not require modification. The start of
    the file specifies the needed include files and prototypes for the external methods.
    The **main()** routine initializes a timer to calculate frame rates, calls a user-defined
    method to initialize the CUDA kernel(s), registers the user-defined callbacks,
    and calls the GLUT main loop, as shown in [Example 9.10](#tb0055), “Part 1 of
    *simpleGLmain.cpp*”:`// simpleGLmain (Rob Farber)``#include <GL/glew.h>``#include
    <cutil_inline.h>``#include <cutil_gl_inline.h>``#include <cutil_gl_error.h>``#include
    <cuda_gl_interop.h>``#include <rendercheck_gl.h>``// GLUT specific contants``const
    unsigned int window_width = 512;``const unsigned int window_height = 512;``//
    The user must create the following routines:``void initCuda(int argc, char** argv);``CUTBoolean
    initGL(int argc, char** argv);``void fpsDisplay(), display();``void keyboard(unsigned
    char key, int x, int y);``void mouse(int button, int state, int x, int y);``void
    motion(int x, int y);``unsigned int timer = 0; // a timer for FPS calculations``int
    sleepTime=0, sleepInc=100;``// Main program``int main(int argc, char** argv)``{``//
    Create the CUTIL timer``cutilCheckError( cutCreateTimer( &timer));``if (CUTFalse
    == initGL(argc, argv)) { return CUTFalse; }``initCuda(argc, argv);``CUT_CHECK_ERROR_GL();``//
    register callbacks``glutDisplayFunc(fpsDisplay);``glutKeyboardFunc(keyboard);``glutMouseFunc(mouse);``glutMotionFunc(motion);``//
    start rendering mainloop``glutMainLoop();``// clean up``cudaThreadExit();``cutilExit(argc,
    argv);``}`[Example 9.11](#tb0060), “Part 2 of *simpleGLmain.cpp*,” computes the
    frame rate and displays it in the window title.`// Simple method to display the
    frames per second in the window title``void computeFPS()``{``static int fpsCount=0;``static
    int fpsLimit=100;``fpsCount++;``if (fpsCount == fpsLimit) {``char fps[256];``float
    ifps = 1.f / (cutGetAverageTimerValue(timer) / 1000.f);``if(sleepTime)``sprintf(fps,
    "CUDA Interop (Rob Farber): %3.1f fps sleepTime %3.1f ms ",``ifps, sleepTime/1000.);``else``sprintf(fps,
    "CUDA Interop (Rob Farber): %3.1f fps ", ifps);``glutSetWindowTitle(fps);``fpsCount
    = 0;``cutilCheckError(cutResetTimer(timer));``}``}``void fpsDisplay()``{``cutilCheckError(cutStartTimer(timer));``display();``cutilCheckError(cutStopTimer(timer));``computeFPS();``}`The
    GLUT and OpenGL initialization creates a window and specifies a viewing location
    in the 3D space, as shown in [Example 9.12](#tb0065), “Part 3 of *simpleGLmain.cpp*”:`float
    animTime = 0.0;// time the animation has been running``// Initialize OpenGL window``CUTBoolean
    initGL(int argc, char **argv)``{``glutInit(&argc, argv);``glutInitDisplayMode(GLUT_RGBA
    | GLUT_DOUBLE);``glutInitWindowSize(window_width, window_height);``glutCreateWindow("CUDA
    GL Interop Demo (adapted from NVIDIA''s simpleGL)");``glutDisplayFunc(fpsDisplay);``glutKeyboardFunc(keyboard);``glutMotionFunc(motion);``//
    initialize necessary OpenGL extensions``glewInit();``if (! glewIsSupported("GL_VERSION_2_0
    ")) {``fprintf(stderr, "ERROR: Support for necessary OpenGL extensions missing.");``return
    CUTFalse;``}``// default initialization``glClearColor(0.0, 0.0, 0.0, 1.0);``glDisable(GL_DEPTH_TEST);``//
    viewport``glViewport(0, 0, window_width, window_height);``// set view matrix``glMatrixMode(GL_MODELVIEW);``glLoadIdentity();``//
    projection``glMatrixMode(GL_PROJECTION);``glLoadIdentity();``gluPerspective(60.0,
    (GLfloat)window_width/(GLfloat) window_ height,0.10, 10.0);``return CUTTrue;``}`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '以下示例是 *simpleGLmain.cpp* 的 VBO 版本的完整源代码。这是一个相当通用的代码，应该不需要修改。文件的开头指定了所需的包含文件和外部方法的原型。**main()**
    例程初始化了一个定时器来计算帧率，调用用户定义的方法来初始化 CUDA 核心，注册用户定义的回调函数，并调用 GLUT 主循环，如 [示例 9.10](#tb0055)
    所示，“*simpleGLmain.cpp* 的第 1 部分”：`// simpleGLmain (Rob Farber)``#include <GL/glew.h>``#include
    <cutil_inline.h>``#include <cutil_gl_inline.h>``#include <cutil_gl_error.h>``#include
    <cuda_gl_interop.h>``#include <rendercheck_gl.h>``// GLUT 特定常量``const unsigned
    int window_width = 512;``const unsigned int window_height = 512;``// 用户必须创建以下例程:``void
    initCuda(int argc, char** argv);``CUTBoolean initGL(int argc, char** argv);``void
    fpsDisplay(), display();``void keyboard(unsigned char key, int x, int y);``void
    mouse(int button, int state, int x, int y);``void motion(int x, int y);``unsigned
    int timer = 0; // FPS 计算用定时器``int sleepTime=0, sleepInc=100;``// 主程序``int main(int
    argc, char** argv)``{``// 创建 CUTIL 定时器``cutilCheckError( cutCreateTimer( &timer));``if
    (CUTFalse == initGL(argc, argv)) { return CUTFalse; }``initCuda(argc, argv);``CUT_CHECK_ERROR_GL();``//
    注册回调函数``glutDisplayFunc(fpsDisplay);``glutKeyboardFunc(keyboard);``glutMouseFunc(mouse);``glutMotionFunc(motion);``//
    启动渲染主循环``glutMainLoop();``// 清理``cudaThreadExit();``cutilExit(argc, argv);``}`[示例
    9.11](#tb0060), “*simpleGLmain.cpp* 的第 2 部分”，计算帧率并将其显示在窗口标题中。`// 显示每秒帧数的简单方法``void
    computeFPS()``{``static int fpsCount=0;``static int fpsLimit=100;``fpsCount++;``if
    (fpsCount == fpsLimit) {``char fps[256];``float ifps = 1.f / (cutGetAverageTimerValue(timer)
    / 1000.f);``if(sleepTime)``sprintf(fps, "CUDA Interop (Rob Farber): %3.1f fps
    sleepTime %3.1f ms ",``ifps, sleepTime/1000.);``else``sprintf(fps, "CUDA Interop
    (Rob Farber): %3.1f fps ", ifps);``glutSetWindowTitle(fps);``fpsCount = 0;``cutilCheckError(cutResetTimer(timer));``}``}``void
    fpsDisplay()``{``cutilCheckError(cutStartTimer(timer));``display();``cutilCheckError(cutStopTimer(timer));``computeFPS();``}`GLUT
    和 OpenGL 初始化会创建一个窗口，并指定 3D 空间中的视图位置，如 [示例 9.12](#tb0065) 所示，“*simpleGLmain.cpp*
    的第 3 部分”：`float animTime = 0.0;// 动画运行的时间``// 初始化 OpenGL 窗口``CUTBoolean initGL(int
    argc, char **argv)``{``glutInit(&argc, argv);``glutInitDisplayMode(GLUT_RGBA |
    GLUT_DOUBLE);``glutInitWindowSize(window_width, window_height);``glutCreateWindow("CUDA
    GL Interop 演示（改编自 NVIDIA 的 simpleGL）");``glutDisplayFunc(fpsDisplay);``glutKeyboardFunc(keyboard);``glutMotionFunc(motion);``//
    初始化必要的 OpenGL 扩展``glewInit();``if (! glewIsSupported("GL_VERSION_2_0 ")) {``fprintf(stderr,
    "错误：缺少必要的 OpenGL 扩展支持。");``return CUTFalse;``}``// 默认初始化``glClearColor(0.0, 0.0,
    0.0, 1.0);``glDisable(GL_DEPTH_TEST);``// 视口``glViewport(0, 0, window_width, window_height);``//
    设置视图矩阵``glMatrixMode(GL_MODELVIEW);``glLoadIdentity();``// 投影``glMatrixMode(GL_PROJECTION);``glLoadIdentity();``gluPerspective(60.0,
    (GLfloat)window_width/(GLfloat) window_ height,0.10, 10.0);``return CUTTrue;``}`'
- en: The simpleVBO.cpp File
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: simpleVBO.cpp 文件
- en: 'The *simpleVBO.cpp* file contains the logic that creates and maps both the
    color PBO and the vertex VBO. The start of the file specifies the include files
    and the variables used in the file. The variables **mesh_width** and **mesh_height**
    specify the size of the mesh calculated on the GPU. The variable **RestartIndex**
    specifies the integer value used by the OpenGL state machine to restart the user-defined
    graphics primitive. See [Example 9.13](#tb0070), “Part 1 of *simpleVBO.cpp*”:`//simpleVBO
    (Rob Farber)``#include <GL/glew.h>``#include <GL/gl.h>``#include <GL/glext.h>``#include
    <cutil_inline.h>``#include <cutil_gl_inline.h>``#include <cuda_gl_interop.h>``#include
    <rendercheck_gl.h>``extern float animTime;``//////////////////////////////////////////////////////////////////``//
    VBO specific code``#include <cutil_inline.h>``// constants``const unsigned int
    mesh_width = 256;``const unsigned int mesh_height = 256;``const unsigned int RestartIndex
    = 0xffffffff;``typedef struct {``GLuint vbo;``GLuint typeSize;``struct cudaGraphicsResource
    *cudaResource;``} mappedBuffer_t;``extern "C"``void launch_kernel(float4* pos,
    uchar4* posColor,``unsigned int mesh_width, unsigned int mesh_height, float time);``//
    vbo variables``mappedBuffer_t vertexVBO = {NULL, sizeof(float4), NULL};``mappedBuffer_t
    colorVBO = {NULL, sizeof(uchar4), NULL};``GLuint* qIndices=NULL; // index values
    for primitive restart``int qIndexSize=0;`The **createVBO()** method performs the
    actual allocation of the graphics buffer on the GPU through the call to **glBufferData()**.
    The **GL_DYNAMIC_DRAW** flag lets OpenGL know that this data store will be repeatedly
    modified and used. The buffer object is registered for access with CUDA with the
    call to **cudaGraphicsGLRegisterBuffer()**. The **deleteVBO()** method unregisters
    and frees the memory held by the OpenGL buffer object. See [Example 9.14](#tb0075),
    “Part 2 of *simpleVBO.cpp*”:`/////////////////////////////////////////////////////////////////``//!
    Create VBO``/////////////////////////////////////////////////////////////////``void
    createVBO(mappedBuffer_t* mbuf)``{``// create buffer object``glGenBuffers(1, &(mbuf->vbo)
    );``glBindBuffer(GL_ARRAY_BUFFER, mbuf->vbo);``// initialize buffer object``unsigned
    int size = mesh_width * mesh_height * mbuf->typeSize;``glBufferData(GL_ARRAY_BUFFER,
    size, 0, GL_DYNAMIC_DRAW);``glBindBuffer(GL_ARRAY_BUFFER, 0);``cudaGraphicsGLRegisterBuffer(
    &(mbuf->cudaResource), mbuf->vbo,``cudaGraphicsMapFlagsNone );``}``//////////////////////////////////////////////////////////////////``//!
    Delete VBO``//////////////////////////////////////////////////////////////////``void
    deleteVBO(mappedBuffer_t* mbuf)``{``glBindBuffer(1, mbuf->vbo );``glDeleteBuffers(1,
    &(mbuf->vbo) );``cudaGraphicsUnregisterResource( mbuf->cudaResource );``mbuf->cudaResource
    = NULL;``mbuf->vbo = NULL;``}``void cleanupCuda()``{``if(qIndices) free(qIndices);``deleteVBO(&vertexVBO);``deleteVBO(&colorVBO);``}`The
    **runCUDA()** method performs all the work of mapping and retrieving the pointer
    to both the color PBO and the vertex VBO. These addresses are passed to the **launch_kernel()**
    method for use by the user-defined kernel. Note that **launch_kernel()** waits
    for the kernel to complete before returning, which is why it is safe to return
    the OpenGL resources after this method returns. See [Example 9.15](#tb0080), “Part
    3 of *simpleVBO.cpp*”:`//////////////////////////////////////////////////////////////////``//!
    Run the CUDA part of the computation``//////////////////////////////////////////////////////////////////``void
    runCuda()``{``// map OpenGL buffer object for writing from CUDA``float4 *dptr;``uchar4
    *cptr;``uint *iptr;``size_t start;``cudaGraphicsMapResources( 1, &vertexVBO.cudaResource,
    NULL );``cudaGraphicsResourceGetMappedPointer( ( void ** )&dptr, &start,``vertexVBO.cudaResource
    );``cudaGraphicsMapResources( 1, &colorVBO.cudaResource, NULL );``cudaGraphicsResourceGetMappedPointer(
    ( void ** )&cptr, &start,``colorVBO.cudaResource );``// execute the kernel``launch_kernel(dptr,
    cptr, mesh_width, mesh_height, animTime);``// unmap buffer object``cudaGraphicsUnmapResources(
    1, &vertexVBO.cudaResource, NULL );``cudaGraphicsUnmapResources( 1, &colorVBO.cudaResource,
    NULL );``}`The **initCuda()** method chooses the fastest device according to the
    NVIDIA documentation. It makes the appropriate calls to allocate the OpenGL buffers.
    The **qIndices** array needed for rendering with primitive restart is allocated
    and initialized. See [Example 9.16](#tb0085), “Part 4 of *simpleVBO.cpp*”:`void
    initCuda(int argc, char** argv)``{``// First initialize OpenGL context, so we
    can properly set the GL``// for CUDA. NVIDIA notes this is necessary in order
    to achieve``// optimal performance with OpenGL/CUDA interop. Use the command-line``//
    specified CUDA device ; otherwise use device with highest Gflops/s``if( cutCheckCmdLineFlag(argc,
    (const char**)argv, "device") ) {``cutilGLDeviceInit(argc, argv);``} else {``cudaGLSetGLDevice(
    cutGetMaxGflopsDeviceId() );``}``createVBO(&vertexVBO);``createVBO(&colorVBO);``//
    allocate and assign trianglefan indices``qIndexSize = 5*(mesh_height-1)*(mesh_width-1);``qIndices
    = (GLuint *) malloc(qIndexSize*sizeof(GLint));``int index=0;``for(int i=1; i <
    mesh_height; i++) {``for(int j=1; j < mesh_width; j++) {``qIndices[index++] =
    (i)*mesh_width + j;``qIndices[index++] = (i)*mesh_width + j−1;``qIndices[index++]
    = (i−1)*mesh_width + j−1;``qIndices[index++] = (i−1)*mesh_width + j;``qIndices[index++]
    = RestartIndex;``}``}``// make certain the VBO gets cleaned up on program exit``atexit(cleanupCuda);``runCuda();``}`The
    **renderCuda()** method binds the buffers with the appropriate type and size information
    for use in rendering. Rendering is performed as defined by **drawMode**.Note the
    simplicity of the call when rendering triangles with primitive restart. The OpenGL
    state machine is informed of the value of the restart index via the **glPrimitiveRestartIndexNV()**
    method, after which primitive restart is enabled in the OpenGL client state machine.
    The call to **glDrawElements()** causes data to be rendered. Once completed, primitive
    restart is disabled in the OpenGL state machine. See [Example 9.17](#tb0090),
    “Part 5 of *simpleVBO.cpp*”:`void renderCuda(int drawMode)``{``glBindBuffer(GL_ARRAY_BUFFER,
    vertexVBO.vbo);``glVertexPointer(4, GL_FLOAT, 0, 0);``glEnableClientState(GL_VERTEX_ARRAY);``glBindBuffer(GL_ARRAY_BUFFER,
    colorVBO.vbo);``glColorPointer(4, GL_UNSIGNED_BYTE, 0, 0);``glEnableClientState(GL_COLOR_ARRAY);``switch(drawMode)
    {``case GL_LINE_STRIP:``for(int i=0 ; i < mesh_width*mesh_height; i+= mesh_width)``glDrawArrays(GL_LINE_STRIP,
    i, mesh_width);``break;``case GL_TRIANGLE_FAN: {``glPrimitiveRestartIndexNV(RestartIndex);``glEnableClientState(GL_PRIMITIVE_RESTART_NV);``glDrawElements(GL_TRIANGLE_FAN,
    qIndexSize, GL_UNSIGNED_INT, qIndices);``glDisableClientState(GL_PRIMITIVE_RESTART_NV);``}
    break;``default:``glDrawArrays(GL_POINTS, 0, mesh_width * mesh_height);``break;``}``glDisableClientState(GL_VERTEX_ARRAY);``glDisableClientState(GL_COLOR_ARRAY);``}`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*simpleVBO.cpp* 文件包含了创建和映射颜色 PBO 和顶点 VBO 的逻辑。文件开头指定了需要包含的文件和文件中使用的变量。变量 **mesh_width**
    和 **mesh_height** 指定了在 GPU 上计算的网格大小。变量 **RestartIndex** 指定了 OpenGL 状态机用于重新启动用户定义的图形原语的整数值。请参见
    [示例 9.13](#tb0070)，“*simpleVBO.cpp* 的第一部分”:`//simpleVBO (Rob Farber)``#include
    <GL/glew.h>``#include <GL/gl.h>``#include <GL/glext.h>``#include <cutil_inline.h>``#include
    <cutil_gl_inline.h>``#include <cuda_gl_interop.h>``#include <rendercheck_gl.h>``extern
    float animTime;``//////////////////////////////////////////////////////////////////``//
    VBO 特定代码``#include <cutil_inline.h>``// 常量``const unsigned int mesh_width = 256;``const
    unsigned int mesh_height = 256;``const unsigned int RestartIndex = 0xffffffff;``typedef
    struct {``GLuint vbo;``GLuint typeSize;``struct cudaGraphicsResource *cudaResource;``}
    mappedBuffer_t;``extern "C"``void launch_kernel(float4* pos, uchar4* posColor,``unsigned
    int mesh_width, unsigned int mesh_height, float time);``// vbo 变量``mappedBuffer_t
    vertexVBO = {NULL, sizeof(float4), NULL};``mappedBuffer_t colorVBO = {NULL, sizeof(uchar4),
    NULL};``GLuint* qIndices=NULL; // 用于原语重启的索引值``int qIndexSize=0;`**createVBO()**
    方法通过调用 **glBufferData()** 实现了在 GPU 上实际分配图形缓冲区的操作。**GL_DYNAMIC_DRAW** 标志告诉 OpenGL
    该数据存储区将被反复修改和使用。通过调用 **cudaGraphicsGLRegisterBuffer()**，缓冲区对象被注册以便 CUDA 访问。**deleteVBO()**
    方法注销并释放 OpenGL 缓冲区对象所占的内存。请参见 [示例 9.14](#tb0075)，“*simpleVBO.cpp* 的第二部分”:`/////////////////////////////////////////////////////////////////``//!
    创建 VBO``/////////////////////////////////////////////////////////////////``void
    createVBO(mappedBuffer_t* mbuf)``{``// 创建缓冲区对象``glGenBuffers(1, &(mbuf->vbo) );``glBindBuffer(GL_ARRAY_BUFFER,
    mbuf->vbo);``// 初始化缓冲区对象``unsigned int size = mesh_width * mesh_height * mbuf->typeSize;``glBufferData(GL_ARRAY_BUFFER,
    size, 0, GL_DYNAMIC_DRAW);``glBindBuffer(GL_ARRAY_BUFFER, 0);``cudaGraphicsGLRegisterBuffer(
    &(mbuf->cudaResource), mbuf->vbo,``cudaGraphicsMapFlagsNone );``}``//////////////////////////////////////////////////////////////////``//!
    删除 VBO``//////////////////////////////////////////////////////////////////``void
    deleteVBO(mappedBuffer_t* mbuf)``{``glBindBuffer(1, mbuf->vbo );``glDeleteBuffers(1,
    &(mbuf->vbo) );``cudaGraphicsUnregisterResource( mbuf->cudaResource );``mbuf->cudaResource
    = NULL;``mbuf->vbo = NULL;``}``void cleanupCuda()``{``if(qIndices) free(qIndices);``deleteVBO(&vertexVBO);``deleteVBO(&colorVBO);``}`**runCUDA()**
    方法执行了映射和检索颜色 PBO 和顶点 VBO 指针的所有工作。这些地址被传递给 **launch_kernel()** 方法供用户定义的内核使用。请注意，**launch_kernel()**
    会在内核完成之前等待返回，因此在该方法返回后，返回 OpenGL 资源是安全的。请参见 [示例 9.15](#tb0080)，“*simpleVBO.cpp*
    的第三部分”:`//////////////////////////////////////////////////////////////////``//!
    执行 CUDA 计算部分``//////////////////////////////////////////////////////////////////``void
    runCuda()``{``// 将 OpenGL 缓冲区对象映射到 CUDA 进行写操作``float4 *dptr;``uchar4 *cptr;``uint
    *iptr;``size_t start;``cudaGraphicsMapResources( 1, &vertexVBO.cudaResource, NULL
    );``cudaGraphicsResourceGetMappedPointer( ( void ** )&dptr, &start,``vertexVBO.cudaResource
    );``cudaGraphicsMapResources( 1, &colorVBO.cudaResource, NULL );``cudaGraphicsResourceGetMappedPointer(
    ( void ** )&cptr, &start,``colorVBO.cudaResource );``// 执行内核``launch_kernel(dptr,
    cptr, mesh_width, mesh_height, animTime);``// 解除映射缓冲区对象``cudaGraphicsUnmapResources(
    1, &vertexVBO.cudaResource, NULL );``cudaGraphicsUnmapResources( 1, &colorVBO.cudaResource,
    NULL );``}`**initCuda()** 方法根据 NVIDIA 文档选择最快的设备。它进行适当的调用以分配 OpenGL 缓冲区。为使用原语重启进行渲染所需的
    **qIndices** 数组也被分配并初始化。请参见 [示例 9.16](#tb0085)，“*simpleVBO.cpp* 的第四部分”:`void initCuda(int
    argc, char** argv)``{``// 首先初始化 OpenGL 上下文，以便我们能够正确设置 GL``// 供 CUDA 使用。NVIDIA
    提到这对于实现 OpenGL/CUDA 互操作的最佳性能是必要的。``// 使用命令行指定的 CUDA 设备；否则使用具有最高 Gflops/s 的设备``if(
    cutCheckCmdLineFlag(argc, (const char**)argv, "device") ) {``cutilGLDeviceInit(argc,
    argv);``} else {``cudaGLSetGLDevice( cutGetMaxGflopsDeviceId() );``}``createVBO(&vertexVBO);``createVBO(&colorVBO);``//
    分配并赋值三角扇索引``qIndexSize = 5*(mesh_height-1)*(mesh_width-1);``qIndices = (GLuint
    *) malloc(qIndexSize*sizeof(GLint));``int index=0;``for(int i=1; i < mesh_height;
    i++) {``for(int j=1; j < mesh_width; j++) {``qIndices[index++] = (i)*mesh_width
    + j;``qIndices[index++] = (i)*mesh_width + j−1;``qIndices[index++] = (i−1)*mesh_width
    + j−1;``qIndices[index++] = (i−1)*mesh_width + j;``qIndices[index++] = RestartIndex;``}``}``//
    确保程序退出时清理 VBO``atexit(cleanupCuda);``runCuda();``}`**renderCuda()** 方法绑定具有适当类型和大小信息的缓冲区以供渲染使用。渲染是根据
    **drawMode** 定义的。请注意，在使用原语重启渲染三角形时调用的简单性。OpenGL 状态机通过 **glPrimitiveRestartIndexNV()**
    方法获知重启索引的值，之后在 OpenGL 客户端状态机中启用原语重启。调用 **glDrawElements()** 后，数据会被渲染。渲染完成后，OpenGL
    状态机中会禁用原语重启。请参见 [示例 9.17](#tb0090)，“*simpleVBO.cpp* 的第五部分”:`void renderCuda(int
    drawMode)``{``glBindBuffer(GL_ARRAY_BUFFER, vertexVBO.vbo);``glVertexPointer(4,
    GL_FLOAT, 0, 0);``glEnableClientState(GL_VERTEX_ARRAY);``glBindBuffer(GL_ARRAY_BUFFER,
    colorVBO.vbo);``glColorPointer(4, GL_UNSIGNED_BYTE, 0, 0);``glEnableClientState(GL_COLOR_ARRAY);``switch(drawMode)
    {``case GL_LINE_STRIP:``for(int i=0 ; i < mesh_width*mesh_height; i+= mesh_width)``glDrawArrays(GL_LINE_STRIP,
    i, mesh_width);``break;``case GL_TRIANGLE_FAN: {``glPrimitiveRestartIndexNV(RestartIndex);``glEnableClientState(GL_PRIMITIVE_RESTART_NV);``glDrawElements(GL_TRIANGLE_FAN,
    qIndexSize, GL_UNSIGNED_INT, qIndices);``glDisableClientState(GL_PRIMITIVE_RESTART_NV);``}
    break;``default:``glDrawArrays(GL_POINTS, 0, mesh_width * mesh_height);``break;``}``glDisableClientState(GL_VERTEX_ARRAY);``glDisableClientState(GL_COLOR_ARRAY);``}`'
- en: The callbacksVBO.cpp File
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The callbacksVBO.cpp 文件
- en: The keyboard routine is very simple. Basically, it allows the user to toggle
    through the display modes (point, line, surface) by pressing the “d” or “D” key.The
    mouse and motion routines work in concert with each other to modify the values
    of the **rotate_x** and **rotate_y** variables based on user mouse movements and
    the state of the mouse buttons.Most of the work occurs in the display routine
    that defines the view transforms, as shown in [Example 9.18](#tb0095), “Code Snippet
    Showing Where Most of the Work Occurs in the callbacksVBO.cu”:`// set view matrix``glMatrixMode(GL_MODELVIEW);``glLoadIdentity();``glTranslatef(0.0,
    0.0, translate_z);``glRotatef(rotate_x, 1.0, 0.0, 0.0);``glRotatef(rotate_y, 0.0,
    1.0, 0.0);``// run CUDA kernel to generate vertex positions``runCuda();``// render
    the data``renderCuda(drawMode);`The CUDA kernel is then called to create the data
    with **runCuda()** and render it with **renderCuda()**.The buffers are swapped
    so that the latest version can be made visible and GLUT is informed that the display
    needs to be updated. The animation time is also incremented. See [Example 9.19](#tb0100),
    “Logic to Swap the OpenGL Buffers and Post a Redisplay Event to OpenGL”:`glutSwapBuffers();``glutPostRedisplay();``animTime
    += 0.01;`[Table 9.2](#t0015) lists the keyboard commands and the applicable kernels.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘例程非常简单。基本上，它允许用户通过按下“d”或“D”键在显示模式（点、线、面）之间切换。鼠标和运动例程共同工作，根据用户的鼠标移动和鼠标按钮状态来修改
    **rotate_x** 和 **rotate_y** 变量的值。大部分工作发生在显示例程中，该例程定义了视图变换，如 [示例 9.18](#tb0095)
    所示，“代码片段展示了 callbacksVBO.cu 中大部分工作发生的位置”:`// 设置视图矩阵``glMatrixMode(GL_MODELVIEW);``glLoadIdentity();``glTranslatef(0.0,
    0.0, translate_z);``glRotatef(rotate_x, 1.0, 0.0, 0.0);``glRotatef(rotate_y, 0.0,
    1.0, 0.0);``// 运行 CUDA 内核生成顶点位置``runCuda();``// 渲染数据``renderCuda(drawMode);`然后调用
    CUDA 内核通过 **runCuda()** 创建数据，并通过 **renderCuda()** 渲染它。交换缓冲区以使最新版本可见，并通知 GLUT 显示需要更新。动画时间也会递增。请参见
    [示例 9.19](#tb0100)， “交换 OpenGL 缓冲区并向 OpenGL 提交重绘事件的逻辑”:`glutSwapBuffers();``glutPostRedisplay();``animTime
    += 0.01;`[表 9.2](#t0015) 列出了键盘命令和适用的内核。
- en: '**Table 9.2** Keyboard Commands for the Demo and Perlin Examples'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9.2** 演示和 Perlin 示例的键盘命令'
- en: '| Key | Applicable Kernel | Action |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| Key | 适用的内核 | 动作 |'
- en: '| + | Perlin | Lower the ocean level |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| + | Perlin | 降低海洋水平 |'
- en: '| – | Perlin | Raise the ocean level |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| – | Perlin | 提高海洋水平 |'
- en: '| k | Perlin | Vi-type key command to move terrain up |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| k | Perlin | Vi 类型的命令，用于将地形上移 |'
- en: '| J | Perlin | Vi-type command to move terrain down |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| J | Perlin | Vi 类型的命令，用于将地形下移 |'
- en: '| h | Perlin | Vi-type command to move terrain left |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| h | Perlin | Vi 类型的命令，用于将地形向左移动 |'
- en: '| l | Perlin | Vi-type command to move terrain right |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| l | Perlin | Vi 类型的命令，用于将地形向右移动 |'
- en: '| d | Perlin/Demo | Toggle draw mode |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| d | Perlin/Demo | 切换绘制模式 |'
- en: '| D | Perlin/Demo | Toggle draw mode |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| D | Perlin/Demo | 切换绘制模式 |'
- en: '| I | Perlin | Increase gain by 0.25 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| I | Perlin | 增加增益 0.25 |'
- en: '| i | Perlin | Decrease gain by 0.25 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| i | Perlin | 减少增益 0.25 |'
- en: '| O | Perlin | Increase octaves (number of frequencies in the fBm) by 1 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| O | Perlin | 增加倍频（fBm 中的频率数量）1 个 |'
- en: '| o | Perlin | Decrease octaves (number of frequencies in the fBm) by 1 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| o | Perlin | 减少 octaves（fBm 中的频率数量）1 个 |'
- en: '| P | Perlin | Increase lacunarity (the gap between successive frequencies)
    by 0.25 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| P | Perlin | 通过 0.25 增加 lacunarity（连续频率之间的间隙） |'
- en: '| p | Perlin | Decrease lacunarity (the gap between successive frequencies)
    by 0.25 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| p | Perlin | 通过 0.25 降低 lacunarity（连续频率之间的间隙） |'
- en: '| S | Perlin/Demo | Slow down rendering by 100 microseconds per frame |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| S | Perlin/Demo | 每帧慢渲染 100 微秒 |'
- en: '| s | Perlin/Demo | Speed rendering by 100 microseconds per frame |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| s | Perlin/Demo | 每帧加速渲染 100 微秒 |'
- en: 'The complete source code is provided in [Example 9.20](#tb0105), “Part 1 of
    *callbacksVBO.cpp.*” The start of the file defines the include files and required
    variables:`//callbacksVBO (Rob Farber)``#include <GL/glew.h>``#include <cutil_inline.h>``#include
    <cutil_gl_inline.h>``#include <cuda_gl_interop.h>``#include <rendercheck_gl.h>``//
    The user must create the following routines:``void initCuda(int argc, char** argv);``void
    runCuda();``void renderCuda(int);``// Callback variables``extern float animTime;``extern
    int sleepTime, sleepInc;``int drawMode=GL_TRIANGLE_FAN; // the default draw mode``int
    mouse_old_x, mouse_old_y;``int mouse_buttons = 0;``float rotate_x = 0.0, rotate_y
    = 0.0;``float translate_z = −3.0;``// break the file modularity so that both Perlin
    and demo kernels build``// some initial values for Perlin``float gain=0.75f, xStart=2.f,
    yStart=1.f;``float zOffset = 0.0f, octaves = 2.f, lacunarity = 2.0f;`The GLUT
    display callback is called whenever there is a need to draw the screen. The OpenGL
    calls define the 3D transformation and rotation operations. The **runCuda()**
    method is called to generate the data and **renderCuda()** is called to render
    the data. The OpenGL buffers are then swapped to utilize the latest update. This
    use of double buffering allows the screen to be updated causing visual artifacts
    such as screen flicker. See [Example 9.21](#tb0110), “Part 2 of *callbacksVBO.cpp*”:`//
    GLUT callbacks display, keyboard, mouse``void display()``{``glClear(GL_COLOR_BUFFER_BIT
    | GL_DEPTH_BUFFER_BIT);``// set view matrix``glMatrixMode(GL_MODELVIEW);``glLoadIdentity();``glTranslatef(0.0,
    0.0, translate_z);``glRotatef(rotate_x, 1.0, 0.0, 0.0);``glRotatef(rotate_y, 0.0,
    1.0, 0.0);``runCuda(); // run CUDA kernel to generate vertex positions``renderCuda(drawMode);
    // render the data``glutSwapBuffers();``glutPostRedisplay();``animTime += 0.01;``}`The
    keyboard callback is a very straightforward code that implements the logic to
    be performed on each keystroke, as shown in [Example 9.22](#tb0115), “Part 3 of
    *callbacksVBO.cpp*”:`void keyboard(unsigned char key, int x, int y)``{``switch(key)
    {``case(''q'') : case(27) : // exit``exit(0);``break;``case ''d'': case ''D'':
    // Drawmode``switch(drawMode) {``case GL_POINTS: drawMode = GL_LINE_STRIP; break;``case
    GL_LINE_STRIP: drawMode = GL_TRIANGLE_FAN; break;``default: drawMode=GL_POINTS;``}
    break;``case ''+'': // Perlin: lower the ocean level``zOffset += 0.01;``zOffset
    = (zOffset > 1.0)? 1.0:zOffset; // guard input``break;``case ''-'': // Perlin:
    raise the ocean level``zOffset -= 0.01;``zOffset = (zOffset < -1.0)? -1.0:zOffset;
    // guard input``break;``case ''k'': // move within the Perlin function``yStart
    −= 0.1;``break;``case ''j'': // move within the Perlin function``yStart += 0.1;``break;``case
    ''l'': // move within the Perlin function``xStart += 0.1;``break;``case ''h'':
    // move within the Perlin function``xStart −= 0.1;``break;``case ''I'': // Perlin:
    change gain``gain += 0.25;``break;``case ''i'': // Perlin: change gain``gain −=
    0.25;``gain = (gain < 0.25)?0.25:gain; // guard input``break;``case ''O'': //
    Perlin: change octaves``octaves += 1.0f;``octaves = (octaves > 8)?8:octaves; //
    guard input``break;``case ''o'': // Perlin: change octaves``octaves −= 1.0f;``octaves
    = (octaves<2)?2:octaves; // guard input``break;``case ''P'': // Perlin: change
    lacunarity``lacunarity += 0.25;``break;``case ''p'': // Perlin: change lacunarity``lacunarity
    −= 0.25;``lacunarity = (lacunarity<0.2)?0.2:lacunarity; // guard input``break;``case
    ''S'': // Slow the simulation down``sleepTime += 100;``break;``case ''s'': //
    Speed the simulation up``sleepTime = (sleepTime > 0)?sleepTime −= sleepInc:0;``break;``}``glutPostRedisplay();``}`The
    mouse and motion callbacks handle mouse events to enable rotation and scaling.
    The motion callback for a window is called when the mouse moves within the window
    while one or more mouse buttons are pressed, as seen in [Example 9.23](#tb0120),
    “Part 4 of *callbacksVBO.cpp*”:`void mouse(int button, int state, int x, int y)``{``if
    (state == GLUT_DOWN) {``mouse_buttons |= 1<<button;``} else if (state == GLUT_UP)
    {``mouse_buttons = 0;``}``mouse_old_x = x;``mouse_old_y = y;``glutPostRedisplay();``}``void
    motion(int x, int y)``{``float dx, dy;``dx = x - mouse_old_x;``dy = y - mouse_old_y;``if
    (mouse_buttons & 1) {``rotate_x += dy * 0.2;``rotate_y += dx * 0.2;``} else if
    (mouse_buttons & 4) {``translate_z += dy * 0.01;``}``rotate_x = (rotate_x < -60.)?-60.:(rotate_x
    > 60.)?60:rotate_x;``rotate_y = (rotate_y < -60.)?-60.:(rotate_y > 60.)?60:rotate_y;``mouse_old_x
    = x;``mouse_old_y = y;``}`The **testDemo** example can be built with a variation
    of the bash script in [Example 9.24](#tb0125), “An Example Script to Build testDemo.”
    The bold items specify that this is a demo example that will create the **testDemo**
    executable. This script assumes that the callbacks and kernel are kept in the
    *demo* directory:`#/bin/bash``**DIR=demo**``SDK_PATH … /cuda/4.0``SDK_LIB0=$SDK_PATH/C/lib``SDK_LIB1=
    … /4.0/CUDALibraries/common/lib/linux``echo $SDK_PATH``nvcc -O3 -L $SDK_LIB0 -L
    $SDK_LIB1 -I $SDK_PATH/C/common/inc simpleGLmain.cpp simpleVBO.cpp $DIR/callbacksVBO.cpp
    $DIR/kernelVBO.cu -lglut -lGLEW_x86_64 -lGLU -lcutil_x86_64 -o **testDemo**`The
    **testPerlin** example can be built with a variation of the bash script in [Example
    9.25](#tb0130), “An Example Script to Build testPerlin.” The bold items specify
    that this is a demo example that will create the **testPerlin** executable. This
    script assumes that the callbacks and kernel are kept in the *perlin* directory:`#/bin/bash``**DIR=perlin**``SDK_PATH=/ichec/packages/cuda/4.0``SDK_LIB0=$SDK_PATH/C/lib``SDK_LIB1=/ichec/packages/cuda/4.0/CUDALibraries/common/lib/linux``echo
    $SDK_PATH``nvcc -O3 -L $SDK_LIB0 -L $SDK_LIB1 -I $SDK_PATH/C/common/inc simpleGLmain.cpp
    simpleVBO.cpp $DIR/callbacksVBO.cpp $DIR/kernelVBO.cu -lglut -lGLEW_x86_64 -lGLU
    -lcutil_x86_64 -o **testPerlin**`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '完整的源代码提供在[示例 9.20](#tb0105)，“*callbacksVBO.cpp* 的第 1 部分”。文件开始部分定义了包含的文件和所需的变量：`//callbacksVBO
    (Rob Farber)``#include <GL/glew.h>``#include <cutil_inline.h>``#include <cutil_gl_inline.h>``#include
    <cuda_gl_interop.h>``#include <rendercheck_gl.h>``// 用户必须创建以下例程：``void initCuda(int
    argc, char** argv);``void runCuda();``void renderCuda(int);``// 回调变量``extern float
    animTime;``extern int sleepTime, sleepInc;``int drawMode=GL_TRIANGLE_FAN; // 默认绘制模式``int
    mouse_old_x, mouse_old_y;``int mouse_buttons = 0;``float rotate_x = 0.0, rotate_y
    = 0.0;``float translate_z = −3.0;``// 打破文件模块化，使得 Perlin 和 demo 内核都能构建``// 一些 Perlin
    的初始值``float gain=0.75f, xStart=2.f, yStart=1.f;``float zOffset = 0.0f, octaves
    = 2.f, lacunarity = 2.0f;` GLUT 显示回调会在每次需要绘制屏幕时被调用。OpenGL 调用定义了 3D 变换和旋转操作。**runCuda()**
    方法被调用以生成数据，**renderCuda()** 被调用以渲染数据。然后，OpenGL 缓冲区交换以利用最新更新。使用双缓冲可以更新屏幕，从而引起视觉伪影，如屏幕闪烁。请参见[示例
    9.21](#tb0110)，“*callbacksVBO.cpp* 的第 2 部分”：`// GLUT 回调显示，键盘，鼠标``void display()``{``glClear(GL_COLOR_BUFFER_BIT
    | GL_DEPTH_BUFFER_BIT);``// 设置视图矩阵``glMatrixMode(GL_MODELVIEW);``glLoadIdentity();``glTranslatef(0.0,
    0.0, translate_z);``glRotatef(rotate_x, 1.0, 0.0, 0.0);``glRotatef(rotate_y, 0.0,
    1.0, 0.0);``runCuda(); // 运行 CUDA 内核生成顶点位置``renderCuda(drawMode); // 渲染数据``glutSwapBuffers();``glutPostRedisplay();``animTime
    += 0.01;``}` 键盘回调是非常直接的代码，执行每个按键的逻辑，如[示例 9.22](#tb0115)，“*callbacksVBO.cpp* 的第
    3 部分”所示：`void keyboard(unsigned char key, int x, int y)``{``switch(key) {``case(''q'')
    : case(27) : // 退出``exit(0);``break;``case ''d'': case ''D'': // 绘制模式``switch(drawMode)
    {``case GL_POINTS: drawMode = GL_LINE_STRIP; break;``case GL_LINE_STRIP: drawMode
    = GL_TRIANGLE_FAN; break;``default: drawMode=GL_POINTS;``} break;``case ''+'':
    // Perlin: 降低海洋水平``zOffset += 0.01;``zOffset = (zOffset > 1.0)? 1.0:zOffset; //
    输入保护``break;``case ''-'': // Perlin: 提高海洋水平``zOffset -= 0.01;``zOffset = (zOffset
    < -1.0)? -1.0:zOffset; // 输入保护``break;``case ''k'': // 在 Perlin 函数中移动``yStart
    −= 0.1;``break;``case ''j'': // 在 Perlin 函数中移动``yStart += 0.1;``break;``case ''l'':
    // 在 Perlin 函数中移动``xStart += 0.1;``break;``case ''h'': // 在 Perlin 函数中移动``xStart
    −= 0.1;``break;``case ''I'': // Perlin: 改变增益``gain += 0.25;``break;``case ''i'':
    // Perlin: 改变增益``gain −= 0.25;``gain = (gain < 0.25)?0.25:gain; // 输入保护``break;``case
    ''O'': // Perlin: 改变八度``octaves += 1.0f;``octaves = (octaves > 8)?8:octaves; //
    输入保护``break;``case ''o'': // Perlin: 改变八度``octaves −= 1.0f;``octaves = (octaves<2)?2:octaves;
    // 输入保护``break;``case ''P'': // Perlin: 改变裂缝率``lacunarity += 0.25;``break;``case
    ''p'': // Perlin: 改变裂缝率``lacunarity −= 0.25;``lacunarity = (lacunarity<0.2)?0.2:lacunarity;
    // 输入保护``break;``case ''S'': // 放慢仿真速度``sleepTime += 100;``break;``case ''s'':
    // 加快仿真速度``sleepTime = (sleepTime > 0)?sleepTime −= sleepInc:0;``break;``}``glutPostRedisplay();``}`
    鼠标和运动回调处理鼠标事件以启用旋转和缩放。窗口的运动回调会在鼠标在窗口内移动时，且一个或多个鼠标按钮被按下时被调用，如[示例 9.23](#tb0120)，“*callbacksVBO.cpp*
    的第 4 部分”所示：`void mouse(int button, int state, int x, int y)``{``if (state == GLUT_DOWN)
    {``mouse_buttons |= 1<<button;``} else if (state == GLUT_UP) {``mouse_buttons
    = 0;``}``mouse_old_x = x;``mouse_old_y = y;``glutPostRedisplay();``}``void motion(int
    x, int y)``{``float dx, dy;``dx = x - mouse_old_x;``dy = y - mouse_old_y;``if
    (mouse_buttons & 1) {``rotate_x += dy * 0.2;``rotate_y += dx * 0.2;``} else if
    (mouse_buttons & 4) {``translate_z += dy * 0.01;``}``rotate_x = (rotate_x < -60.)?-60.:(rotate_x
    > 60.)?60:rotate_x;``rotate_y = (rotate_y < -60.)?-60.:(rotate_y > 60.)?60:rotate_y;``mouse_old_x
    = x;``mouse_old_y = y;``}` **testDemo** 示例可以通过[示例 9.24](#tb0125)中提供的 Bash 脚本变体构建，“构建
    testDemo 的示例脚本”。加粗的项目表明这是一个演示示例，将创建**testDemo** 可执行文件。此脚本假定回调和内核保存在*demo*目录中：`#/bin/bash``**DIR=demo**``SDK_PATH
    … /cuda/4.0``SDK_LIB0=$SDK_PATH/C/lib``SDK_LIB1= … /4.0/CUDALibraries/common/lib/linux``echo
    $SDK_PATH``nvcc -O3 -L $SDK_LIB0 -L $SDK_LIB1 -I $SDK_PATH/C/common/inc simpleGLmain.cpp
    simpleVBO.cpp $DIR/callbacksVBO.cpp $DIR/kernelVBO.cu -lglut -lGLEW_x86_64 -lGLU
    -lcutil_x86_64 -o **testDemo**` **testPerlin** 示例可以通过[示例 9.25](#tb0130)中提供的 Bash
    脚本变体构建，“构建 testPerlin 的示例脚本”。加粗的项目表明这是一个演示示例，将创建**testPerlin** 可执行文件。此脚本假定回调和内核保存在*perlin*目录中：`#/bin/bash``**DIR=perlin**``SDK_PATH=/ichec/packages/cuda/4.0``SDK_LIB0=$SDK_PATH/C/lib``SDK_LIB1=/ichec/packages/cuda/4.0/CUDALibraries/common/lib/linux``echo
    $SDK_PATH``nvcc -O3 -L $SDK_LIB0 -L $SDK_LIB1 -I $SDK_PATH/C/common/inc simpleGLmain.cpp
    simpleVBO.cpp $DIR/callbacksVBO.cpp $DIR/kernelVBO.cu -lglut -lGLEW_x86_64 -lGLU
    -lcutil_x86_64 -o **testPerlin**`'
- en: Summary
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Mixing CUDA and visualization opens tremendous opportunities for commercial
    games and visual products as well as scientific applications. The examples in
    this article demonstrate that the current generation of CUDA-enabled graphics
    processors can both render and generate very complex data at hundreds of frames
    per second.In particular, this article attempts to point the way to an extraordinarily
    simple and flexible way for CUDA developers to generate and render 3D images using
    the OpenGL standards compliant *primitive restart* capability so that minimal
    host processor interaction is required. As a result, PCIe bottlenecks and latencies
    can be avoided to deliver high-performance, high-quality graphics even when the
    images require irregular meshes and/or computationally expensive data generation.
    Of course, this issue is of interest when generating very realistic images on
    high-end GPUs, but do not forget that this same technique can enable product penetration
    into the mid- and lower-performance markets as well.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 混合使用CUDA和可视化为商业游戏、视觉产品以及科学应用开辟了巨大的机会。本文中的示例展示了当前一代支持CUDA的图形处理器如何以每秒数百帧的速度渲染并生成非常复杂的数据。特别是，本文尝试指出一种极其简单且灵活的方法，供CUDA开发者使用符合OpenGL标准的*primitive
    restart*功能来生成和渲染3D图像，从而最小化主机处理器的交互需求。因此，PCIe瓶颈和延迟问题可以避免，从而在图像需要不规则网格和/或计算密集型数据生成时，仍能提供高性能、高质量的图形。当然，这一问题在高端GPU上生成非常逼真的图像时尤其重要，但不要忘记，这种技术同样可以使产品进入中低性能市场。
