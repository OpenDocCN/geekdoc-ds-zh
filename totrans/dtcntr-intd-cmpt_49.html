<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>16.2Â The Size of a DAGğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>16.2Â The Size of a DAGğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/size-of-dag.html">https://dcic-world.org/2025-08-27/size-of-dag.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Stage_1%29" class="toclink" data-pltdoc="x">16.2.1<span class="hspace">Â </span>Stage 1</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Stage_2%29" class="toclink" data-pltdoc="x">16.2.2<span class="hspace">Â </span>Stage 2</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Stage_3%29" class="toclink" data-pltdoc="x">16.2.3<span class="hspace">Â </span>Stage 3</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Stage_4%29" class="toclink" data-pltdoc="x">16.2.4<span class="hspace">Â </span>Stage 4</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Stage_5%29" class="toclink" data-pltdoc="x">16.2.5<span class="hspace">Â </span>Stage 5</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.What_.We~e2~80~99ve_.Learned%29" class="toclink" data-pltdoc="x">16.2.6<span class="hspace">Â </span>What Weâ€™ve Learned</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.More_on_.Value_.Printing__.An_.Aside_from_.Racket%29" class="toclink" data-pltdoc="x">16.2.7<span class="hspace">Â </span>More on Value Printing: An Aside from Racket</a></p></td></tr></table><p/><div class="SIntrapara">Letâ€™s start by defining a function to compute the size of a tree:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data BT:
  | mt
  | nd(v :: Number, l :: BT, r :: BT)
end

fun size-1(b :: BT) -&gt; Number:
  cases (BT) b:
    | mt =&gt; 0
    | nd(v, l, r) =&gt; 1 + size-1(l) + size-1(r)
  end
end</code></pre></div></div></div><div class="SIntrapara">This is straightforward enough.</div><p/><div class="SIntrapara">But letâ€™s say that our input isnâ€™t actually a tree, but rather a <span class="Smaller">DAG</span>. For
instance:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">#|
     4
    / \
   2   3
    \ /
     1
|#

n1 = nd(1, mt, mt)
n2 = nd(2, mt, n1)
n3 = nd(3, n1, mt)
n4 = nd(4, n2, n3)</code></pre></div></div></div><div class="SIntrapara">where <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">n4</code></span> is the <span class="Smaller">DAG</span>. There are two notions of size here. One is like
a â€œprint sizeâ€: how much space will it occupy when printed. The current size
function computes that well. But another is the â€œallocationâ€ size: how many
nodes did we allocate. How do we fare?</div><section class="SsectionLevel4" id="section 16.2.1"><h4 class="heading">16.2.1<span class="stt">Â </span><a name="(part._.Stage_1)"/>Stage 1<span class="button-group"><a href="#(part._.Stage_1)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  size-1(n1) is 1
  size-1(n2) is 2
  size-1(n3) is 2
  size-1(n4) is 4
end</code></pre></div></div><p>Clearly the answer should be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">4</code></span>: we can just read off how many <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nd</code></span>
calls there are. And clearly the function is wrong.</p><p>The problem, of course, is that a <span class="Smaller">DAG</span> involves repeating nodes, and we
arenâ€™t doing anything to track the repetition. So we need a stronger contract:
weâ€™ll split the problem into two parts, a standard interface function that
takes just the <span class="Smaller">DAG</span> and returns a number, and a richer helper function, which
also takes a memory of the nodes already seen.</p></section><section class="SsectionLevel4" id="section 16.2.2"><h4 class="heading">16.2.2<span class="stt">Â </span><a name="(part._.Stage_2)"/>Stage 2<span class="button-group"><a href="#(part._.Stage_2)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size-2-h(b :: BT, seen :: List&lt;BT&gt;) -&gt; Number:
  if member-identical(seen, b):
    0
  else:
    cases (BT) b:
      | mt =&gt; 0
      | nd(v, l, r) =&gt;
        new-seen = link(b, seen)
        1 + size-2-h(l, new-seen) + size-2-h(r, new-seen)
    end
  end
end</code></pre></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Why does this code use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">member-identical</code></span> rather than <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">member</code></span>?</p><p>Observe that if we replace every <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">member-identical</code></span> with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">member</code></span> in
this chapter, the code still behaves the same. Why?</p><p>Make changes to demonstrate the need for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">member-identical</code></span>.</p></blockquote></blockquote><p>Is it odd that we return <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>? Not if we reinterpret what the function
does: it doesnâ€™t count the <span class="emph">size</span>, it counts the <span class="emph">additional
contribution to the size (relative to what has already been seen)</span> of the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">BT</code></span> it is given. A node already in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">seen</code></span> makes no marginal
contribution; it was already counted earlier.</p><p/><div class="SIntrapara">Finally, we should not export such a function to the user, who has to deal with
an unwieldy extra parameter and may send something poorly-formed, thereby
causing our function to break. Instead, we should write a wrapper for it:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size-2(b :: BT): size-2-h(b, empty) end</code></pre></div></div></div><div class="SIntrapara">This also enables us to use our old tests (renamed):
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  size-2(n1) is 1
  size-2(n2) is 2
  size-2(n3) is 2
  size-2(n4) is 4
end</code></pre></div></div></div><div class="SIntrapara">Unfortunately, this still doesnâ€™t work!</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Use Pyretâ€™s <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">spy</code></span> construct in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size-2-h</code></span> to figure out why.</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 16.2.3"><h4 class="heading">16.2.3<span class="stt">Â </span><a name="(part._.Stage_3)"/>Stage 3<span class="button-group"><a href="#(part._.Stage_3)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Did you remember to use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">spy</code></span>? Otherwise you may very well miss the
problem! Be sure to use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">spy</code></span> (feel free to elide the first few tests for
now) to get a feel for the issue.</p><p>As you may have noted, the problem is that we want <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">seen</code></span> to be all the
nodes <span class="emph">ever</span> seen. However, every time we return from one sub-computation,
we also lose track of whatever was seen during its work. Instead, we have to
also return everything that was seen, so as to properly preserve the idea that
weâ€™re computing the marginal contribution of each node.</p><p/><div class="SIntrapara">We can do this with the following data structure:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Ret: ret(sz :: Number, sn :: List&lt;BT&gt;) end</code></pre></div></div></div><div class="SIntrapara">which is returned by the helper function:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size-3-h(b :: BT, seen :: List&lt;BT&gt;) -&gt; Ret:
  if member-identical(seen, b):
    ret(0, seen)
  else:
    cases (BT) b:
      | mt =&gt; ret(0, seen)
      | nd(v, l, r) =&gt;
        new-seen = link(b, seen)
        rl = size-3-h(l, new-seen)
        rr = size-3-h(r, rl.sn)
        ret(1 + rl.sz + rr.sz, rr.sn)
    end
  end
end</code></pre></div></div></div><div class="SIntrapara">Note, crucially, how the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">seen</code></span> argument for the right branch is
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rl.sn</code></span>: i.e., everything that was already seen in the left branch. This
is the crucial step that avoids the bug.</div><p/><div class="SIntrapara">Because of this richer return type, we have to extract the actual answer for
the purpose of testing:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size-3(b :: BT): size-3-h(b, empty).sz end

check:
  size-3(n1) is 1
  size-3(n2) is 2
  size-3(n3) is 2
  size-3(n4) is 4
end</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Must <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">seen</code></span> be a list? What else can it be?</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 16.2.4"><h4 class="heading">16.2.4<span class="stt">Â </span><a name="(part._.Stage_4)"/>Stage 4<span class="button-group"><a href="#(part._.Stage_4)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Observe that the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Ret</code></span> data structure is only of local interest. Itâ€™s
purely internal to the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size-3-h</code></span> function; even <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size-3</code></span> ignores one
half, and it will never be seen by the rest of the program. That is a good use
of tuples, as we have seen before: <a href="queues-from-lists.html#%28part._qfl-tuples%29" data-pltdoc="x">Using Tuples</a>!</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size-4-h(b :: BT, seen :: List&lt;BT&gt;) -&gt; {Number; List&lt;BT&gt;}:
  if member-identical(seen, b):
    {0; seen}
  else:
    cases (BT) b:
      | mt =&gt; {0; seen}
      | nd(v, l, r) =&gt;
        new-seen = link(b, seen)
        {lsz; lsn} = size-4-h(l, new-seen)
        {rsz; rsn} = size-4-h(r, lsn)
        {1 + lsz + rsz; rsn}
    end
  end
end

fun size-4(b :: BT): size-4-h(b, empty).{0} end

check:
  size-4(n1) is 1
  size-4(n2) is 2
  size-4(n3) is 2
  size-4(n4) is 4
end</code></pre></div></div><p>The notation <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{0; seen}</code></span> makes an actual tuple; <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{Number; List&lt;BT&gt;}</code></span>
declares the <span class="emph">contract</span> of a tuple. Also, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">.{0}</code></span> extracts the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>th element (the leftmost one) of a tuple.</p></section><section class="SsectionLevel4" id="section 16.2.5"><h4 class="heading">16.2.5<span class="stt">Â </span><a name="(part._.Stage_5)"/>Stage 5<span class="button-group"><a href="#(part._.Stage_5)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Notice that we have the two instances of the code <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{0; seen}</code></span>. Do they
have to be that? What if we were to return <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{0; empty}</code></span> instead in both
places? Does anything break?</p><p>We might expect it to break in the case where <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">member-identical</code></span> returns
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span>, but perhaps not in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">mt</code></span> case.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Make each of these changes. Does the outcome match your expectations?</p></blockquote></blockquote><p>Curiously, no! Making the change in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">mt</code></span> case has an effect but making
it in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">member-identical</code></span> case doesnâ€™t! This almost seems
counter-intuitive. How can we diagnose this?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">spy</code></span> to determine what is going on!</p></blockquote></blockquote><p>Okay, so it seems like returning <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> when we revisit a node doesnâ€™t
seem to do any harm. Does that mean itâ€™s okay to make that change?</p><p/><div class="SIntrapara">Observe that nothing has actually depended on that seen-list being
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>. Thatâ€™s why it appears to not matter. How can we make it matter?
By making it â€œhurtâ€ the computation by visiting a previously seen, but now
forgotten, node yet again. So we need to visit a node at least three times: the
first time to remember it; the second time to forget it; and a third time to
incorrectly visit it again. Hereâ€™s a DAG that will do that:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">#|
    10
    / \
   11 12
  / \ /
 13&lt;--
|#

n13 = nd(13, mt, mt)
n11 = nd(11, n13, n13)
n12 = nd(12, n13, mt)
n10 = nd(10, n11, n12)

check:
  size-4(n10) is 4
end</code></pre></div></div></div><div class="SIntrapara">Sure enough, if either tuple now returns <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>, this test
fails. Otherwise it succeeds.</div></section><section class="SsectionLevel4" id="section 16.2.6"><h4 class="heading">16.2.6<span class="stt">Â </span><a name="(part._.What_.We~e2~80~99ve_.Learned)"/>What Weâ€™ve Learned<span class="button-group"><a href="#(part._.What_.We~e2~80~99ve_.Learned)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">We have learned three important principles here:
</div><div class="SIntrapara"><ul><li><p>A pattern for dealing with programs that need â€œmemoryâ€. This is called
<span style="font-style: italic">threading</span> (not in the sense of â€œmulti-threadingâ€, which is a kind of
parallel computation, but rather the pattern of how the seen list gets passed
through the program).</p></li><li><p>A good example of the use of tuples: local, where the documentation
benefit of datatypes isnâ€™t necessary (and the extra datatype probably just
clutters up the program), as opposed to distant, where it is. In general, itâ€™s
always okay to make a new datatype; itâ€™s only sometimes okay to use tuples in
their place.</p></li><li><p>An important software-engineering principle, called
<span style="font-style: italic">mutation testing</span>. This is an odd name because it would seem to be the
name of a technique to test programs. Actually, itâ€™s a technique to test
<span class="emph">test suites</span>. You have a tested program; you then â€œmutateâ€ some part of
your program that you feel must change the output, and see whether any tests
break. If no tests break, then either youâ€™ve misunderstood your program or,
more likely, your test suite is not good enough. Improve your test suite to
catch the error in your program, or convince yourself the change didnâ€™t matter.</p><p>There are mutation testing tools that will randomly try to alter your program
using â€œmutantâ€ strategiesâ€”<wbr/>e.g., replacing a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">+</code></span> with a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">-</code></span>â€”<wbr/>and
re-run your suites, and then report back on how many potential mutants the
suites actually caught. But we canâ€™t and shouldnâ€™t only rely on tools; we can
also apply the principle of mutation testing by hand, as we have above. At the
very least, it will help us understand our program better!</p></li></ul></div></section><section class="SsectionLevel4" id="section 16.2.7"><h4 class="heading">16.2.7<span class="stt">Â </span><a name="(part._.More_on_.Value_.Printing__.An_.Aside_from_.Racket)"/>More on Value Printing: An Aside from Racket<span class="button-group"><a href="#(part._.More_on_.Value_.Printing__.An_.Aside_from_.Racket)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Earlier, we talked about how the standard recursive size can still be thought
of as a â€œsize of printed valueâ€ computation. However, that actually depends on
your languageâ€™s value printer.</p><p/><div class="SIntrapara">In Racket, you can turn on (itâ€™s slightly more expensive, so off by default) a
value-printer that shows value sharing: <span class="stt">Language | Choose Language â€¦ | Show
Details | Show sharing in values</span>. So if we take the data definition above and
translate it into Racket structures
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">(struct mt () #:transparent)</span></p></td></tr><tr><td><p><span class="stt">(struct nd (v l r) #:transparent)</span></p></td></tr></table></div><div class="SIntrapara">and then construct (almost) the same data as in the first example:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">(define n1 (nd 1 (mt) (mt)))</span></p></td></tr><tr><td><p><span class="stt">(define n2 (nd 2 (mt) n1))</span></p></td></tr><tr><td><p><span class="stt">(define n3 (nd 3 n1 (mt)))</span></p></td></tr><tr><td><p><span class="stt">(define n4 (nd 4 n2 n3))</span></p></td></tr></table></div><div class="SIntrapara">and then ask Racket to print it, we get:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">&gt; n4</span></p></td></tr><tr><td><p><span class="stt">(nd 4 (nd 2 (mt) #0=(nd 1 (mt) (mt))) (nd 3 #0# (mt)))</span></p></td></tr></table></div><div class="SIntrapara">The <span class="stt">#0=</span> notation is the moral equivalent of saying, â€œIâ€™m going to refer to
this value again later, so letâ€™s call it the 0th valueâ€ and <span class="stt">#0#</span> is saying â€œHere
Iâ€™m referring to the aforementioned 0th valueâ€.</div><p>(Yes, there can be more than one shared value in an output, so each is given a
different â€œnameâ€. Weâ€™ll see that in a moment.)</p><p/><div class="SIntrapara">The later example above translates to
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">(define n13 (nd 13 (mt) (mt)))</span></p></td></tr><tr><td><p><span class="stt">(define n11 (nd 11 n13 n13))</span></p></td></tr><tr><td><p><span class="stt">(define n12 (nd 12 n13 (mt)))</span></p></td></tr><tr><td><p><span class="stt">(define n10 (nd 10 n11 n12))</span></p></td></tr></table></div><div class="SIntrapara">which prints as
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">&gt; n10</span></p></td></tr><tr><td><p><span class="stt">(nd 10 (nd 11 #0=(nd 13 (mt) (mt)) #0#) (nd 12 #0# (mt)))</span></p></td></tr></table></div><div class="SIntrapara">So it is possible for a language to reflect the sharing in its output. Itâ€™s
just that most programming languages choose to not do that, even optionally.</div><p>Remember the â€œalmostâ€ above? What was that about?</p><p/><div class="SIntrapara">In Racket, weâ€™ve made a new instance of <span class="stt">mt</span> over and over. We can more
accurately reflect what is happening in Pyret by instantiating it only once:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">(struct mt () #:transparent)</span></p></td></tr><tr><td><p><span class="stt">(define the-mt (mt))</span></p></td></tr><tr><td><p><span class="stt">(struct nd (v l r) #:transparent)</span></p></td></tr></table></div><div class="SIntrapara">We then rewrite the earlier example to use that one instance only:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">(define n1 (nd 1 the-mt the-mt))</span></p></td></tr><tr><td><p><span class="stt">(define n2 (nd 2 the-mt n1))</span></p></td></tr><tr><td><p><span class="stt">(define n3 (nd 3 n1 the-mt))</span></p></td></tr><tr><td><p><span class="stt">(define n4 (nd 4 n2 n3))</span></p></td></tr></table></div><div class="SIntrapara">And now when we print it:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">&gt; n4</span></p></td></tr><tr><td><p><span class="stt">(nd 4 (nd 2 #0=(mt) #1=(nd 1 #0# #0#)) (nd 3 #1# #0#))</span></p></td></tr></table></div><div class="SIntrapara">And now you can see there are two different shared values, one is the single
instance of <span class="stt">mt</span>, the other is the <span class="stt">nd</span> with <span class="stt">1</span> in it. Thus, Racket
uses both <span class="stt">#0=</span> / <span class="stt">#0#</span> and <span class="stt">#1=</span> / <span class="stt">#1#</span>. Notice how all the
leaves are sharing the same <span class="stt">mt</span> instance. (The numbering is picked in the
order in which nodes are encountered while traversing, which is why the <span class="stt">nd</span>
instance was <span class="stt">#0</span> the previous time and is <span class="stt">#1</span> this time.)</div></section>&#13;
<h4 class="heading">16.2.1<span class="stt">Â </span><a name="(part._.Stage_1)"/>Stage 1<span class="button-group"><a href="#(part._.Stage_1)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  size-1(n1) is 1
  size-1(n2) is 2
  size-1(n3) is 2
  size-1(n4) is 4
end</code></pre></div></div><p>Clearly the answer should be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">4</code></span>: we can just read off how many <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nd</code></span>
calls there are. And clearly the function is wrong.</p><p>The problem, of course, is that a <span class="Smaller">DAG</span> involves repeating nodes, and we
arenâ€™t doing anything to track the repetition. So we need a stronger contract:
weâ€™ll split the problem into two parts, a standard interface function that
takes just the <span class="Smaller">DAG</span> and returns a number, and a richer helper function, which
also takes a memory of the nodes already seen.</p>&#13;
<h4 class="heading">16.2.2<span class="stt">Â </span><a name="(part._.Stage_2)"/>Stage 2<span class="button-group"><a href="#(part._.Stage_2)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size-2-h(b :: BT, seen :: List&lt;BT&gt;) -&gt; Number:
  if member-identical(seen, b):
    0
  else:
    cases (BT) b:
      | mt =&gt; 0
      | nd(v, l, r) =&gt;
        new-seen = link(b, seen)
        1 + size-2-h(l, new-seen) + size-2-h(r, new-seen)
    end
  end
end</code></pre></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Why does this code use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">member-identical</code></span> rather than <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">member</code></span>?</p><p>Observe that if we replace every <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">member-identical</code></span> with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">member</code></span> in
this chapter, the code still behaves the same. Why?</p><p>Make changes to demonstrate the need for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">member-identical</code></span>.</p></blockquote></blockquote><p>Is it odd that we return <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>? Not if we reinterpret what the function
does: it doesnâ€™t count the <span class="emph">size</span>, it counts the <span class="emph">additional
contribution to the size (relative to what has already been seen)</span> of the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">BT</code></span> it is given. A node already in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">seen</code></span> makes no marginal
contribution; it was already counted earlier.</p><p/><div class="SIntrapara">Finally, we should not export such a function to the user, who has to deal with
an unwieldy extra parameter and may send something poorly-formed, thereby
causing our function to break. Instead, we should write a wrapper for it:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size-2(b :: BT): size-2-h(b, empty) end</code></pre></div></div></div><div class="SIntrapara">This also enables us to use our old tests (renamed):
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  size-2(n1) is 1
  size-2(n2) is 2
  size-2(n3) is 2
  size-2(n4) is 4
end</code></pre></div></div></div><div class="SIntrapara">Unfortunately, this still doesnâ€™t work!</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Use Pyretâ€™s <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">spy</code></span> construct in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size-2-h</code></span> to figure out why.</p></blockquote></blockquote>&#13;
<h4 class="heading">16.2.3<span class="stt">Â </span><a name="(part._.Stage_3)"/>Stage 3<span class="button-group"><a href="#(part._.Stage_3)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Did you remember to use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">spy</code></span>? Otherwise you may very well miss the
problem! Be sure to use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">spy</code></span> (feel free to elide the first few tests for
now) to get a feel for the issue.</p><p>As you may have noted, the problem is that we want <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">seen</code></span> to be all the
nodes <span class="emph">ever</span> seen. However, every time we return from one sub-computation,
we also lose track of whatever was seen during its work. Instead, we have to
also return everything that was seen, so as to properly preserve the idea that
weâ€™re computing the marginal contribution of each node.</p><p/><div class="SIntrapara">We can do this with the following data structure:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Ret: ret(sz :: Number, sn :: List&lt;BT&gt;) end</code></pre></div></div></div><div class="SIntrapara">which is returned by the helper function:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size-3-h(b :: BT, seen :: List&lt;BT&gt;) -&gt; Ret:
  if member-identical(seen, b):
    ret(0, seen)
  else:
    cases (BT) b:
      | mt =&gt; ret(0, seen)
      | nd(v, l, r) =&gt;
        new-seen = link(b, seen)
        rl = size-3-h(l, new-seen)
        rr = size-3-h(r, rl.sn)
        ret(1 + rl.sz + rr.sz, rr.sn)
    end
  end
end</code></pre></div></div></div><div class="SIntrapara">Note, crucially, how the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">seen</code></span> argument for the right branch is
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rl.sn</code></span>: i.e., everything that was already seen in the left branch. This
is the crucial step that avoids the bug.</div><p/><div class="SIntrapara">Because of this richer return type, we have to extract the actual answer for
the purpose of testing:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size-3(b :: BT): size-3-h(b, empty).sz end

check:
  size-3(n1) is 1
  size-3(n2) is 2
  size-3(n3) is 2
  size-3(n4) is 4
end</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Must <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">seen</code></span> be a list? What else can it be?</p></blockquote></blockquote>&#13;
<h4 class="heading">16.2.4<span class="stt">Â </span><a name="(part._.Stage_4)"/>Stage 4<span class="button-group"><a href="#(part._.Stage_4)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Observe that the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Ret</code></span> data structure is only of local interest. Itâ€™s
purely internal to the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size-3-h</code></span> function; even <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size-3</code></span> ignores one
half, and it will never be seen by the rest of the program. That is a good use
of tuples, as we have seen before: <a href="queues-from-lists.html#%28part._qfl-tuples%29" data-pltdoc="x">Using Tuples</a>!</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size-4-h(b :: BT, seen :: List&lt;BT&gt;) -&gt; {Number; List&lt;BT&gt;}:
  if member-identical(seen, b):
    {0; seen}
  else:
    cases (BT) b:
      | mt =&gt; {0; seen}
      | nd(v, l, r) =&gt;
        new-seen = link(b, seen)
        {lsz; lsn} = size-4-h(l, new-seen)
        {rsz; rsn} = size-4-h(r, lsn)
        {1 + lsz + rsz; rsn}
    end
  end
end

fun size-4(b :: BT): size-4-h(b, empty).{0} end

check:
  size-4(n1) is 1
  size-4(n2) is 2
  size-4(n3) is 2
  size-4(n4) is 4
end</code></pre></div></div><p>The notation <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{0; seen}</code></span> makes an actual tuple; <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{Number; List&lt;BT&gt;}</code></span>
declares the <span class="emph">contract</span> of a tuple. Also, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">.{0}</code></span> extracts the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>th element (the leftmost one) of a tuple.</p>&#13;
<h4 class="heading">16.2.5<span class="stt">Â </span><a name="(part._.Stage_5)"/>Stage 5<span class="button-group"><a href="#(part._.Stage_5)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Notice that we have the two instances of the code <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{0; seen}</code></span>. Do they
have to be that? What if we were to return <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{0; empty}</code></span> instead in both
places? Does anything break?</p><p>We might expect it to break in the case where <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">member-identical</code></span> returns
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span>, but perhaps not in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">mt</code></span> case.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Make each of these changes. Does the outcome match your expectations?</p></blockquote></blockquote><p>Curiously, no! Making the change in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">mt</code></span> case has an effect but making
it in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">member-identical</code></span> case doesnâ€™t! This almost seems
counter-intuitive. How can we diagnose this?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">spy</code></span> to determine what is going on!</p></blockquote></blockquote><p>Okay, so it seems like returning <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> when we revisit a node doesnâ€™t
seem to do any harm. Does that mean itâ€™s okay to make that change?</p><p/><div class="SIntrapara">Observe that nothing has actually depended on that seen-list being
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>. Thatâ€™s why it appears to not matter. How can we make it matter?
By making it â€œhurtâ€ the computation by visiting a previously seen, but now
forgotten, node yet again. So we need to visit a node at least three times: the
first time to remember it; the second time to forget it; and a third time to
incorrectly visit it again. Hereâ€™s a DAG that will do that:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">#|
    10
    / \
   11 12
  / \ /
 13&lt;--
|#

n13 = nd(13, mt, mt)
n11 = nd(11, n13, n13)
n12 = nd(12, n13, mt)
n10 = nd(10, n11, n12)

check:
  size-4(n10) is 4
end</code></pre></div></div></div><div class="SIntrapara">Sure enough, if either tuple now returns <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>, this test
fails. Otherwise it succeeds.</div>&#13;
<h4 class="heading">16.2.6<span class="stt">Â </span><a name="(part._.What_.We~e2~80~99ve_.Learned)"/>What Weâ€™ve Learned<span class="button-group"><a href="#(part._.What_.We~e2~80~99ve_.Learned)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">We have learned three important principles here:
</div><div class="SIntrapara"><ul><li><p>A pattern for dealing with programs that need â€œmemoryâ€. This is called
<span style="font-style: italic">threading</span> (not in the sense of â€œmulti-threadingâ€, which is a kind of
parallel computation, but rather the pattern of how the seen list gets passed
through the program).</p></li><li><p>A good example of the use of tuples: local, where the documentation
benefit of datatypes isnâ€™t necessary (and the extra datatype probably just
clutters up the program), as opposed to distant, where it is. In general, itâ€™s
always okay to make a new datatype; itâ€™s only sometimes okay to use tuples in
their place.</p></li><li><p>An important software-engineering principle, called
<span style="font-style: italic">mutation testing</span>. This is an odd name because it would seem to be the
name of a technique to test programs. Actually, itâ€™s a technique to test
<span class="emph">test suites</span>. You have a tested program; you then â€œmutateâ€ some part of
your program that you feel must change the output, and see whether any tests
break. If no tests break, then either youâ€™ve misunderstood your program or,
more likely, your test suite is not good enough. Improve your test suite to
catch the error in your program, or convince yourself the change didnâ€™t matter.</p><p>There are mutation testing tools that will randomly try to alter your program
using â€œmutantâ€ strategiesâ€”<wbr/>e.g., replacing a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">+</code></span> with a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">-</code></span>â€”<wbr/>and
re-run your suites, and then report back on how many potential mutants the
suites actually caught. But we canâ€™t and shouldnâ€™t only rely on tools; we can
also apply the principle of mutation testing by hand, as we have above. At the
very least, it will help us understand our program better!</p></li></ul></div>&#13;
<h4 class="heading">16.2.7<span class="stt">Â </span><a name="(part._.More_on_.Value_.Printing__.An_.Aside_from_.Racket)"/>More on Value Printing: An Aside from Racket<span class="button-group"><a href="#(part._.More_on_.Value_.Printing__.An_.Aside_from_.Racket)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Earlier, we talked about how the standard recursive size can still be thought
of as a â€œsize of printed valueâ€ computation. However, that actually depends on
your languageâ€™s value printer.</p><p/><div class="SIntrapara">In Racket, you can turn on (itâ€™s slightly more expensive, so off by default) a
value-printer that shows value sharing: <span class="stt">Language | Choose Language â€¦ | Show
Details | Show sharing in values</span>. So if we take the data definition above and
translate it into Racket structures
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">(struct mt () #:transparent)</span></p></td></tr><tr><td><p><span class="stt">(struct nd (v l r) #:transparent)</span></p></td></tr></table></div><div class="SIntrapara">and then construct (almost) the same data as in the first example:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">(define n1 (nd 1 (mt) (mt)))</span></p></td></tr><tr><td><p><span class="stt">(define n2 (nd 2 (mt) n1))</span></p></td></tr><tr><td><p><span class="stt">(define n3 (nd 3 n1 (mt)))</span></p></td></tr><tr><td><p><span class="stt">(define n4 (nd 4 n2 n3))</span></p></td></tr></table></div><div class="SIntrapara">and then ask Racket to print it, we get:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">&gt; n4</span></p></td></tr><tr><td><p><span class="stt">(nd 4 (nd 2 (mt) #0=(nd 1 (mt) (mt))) (nd 3 #0# (mt)))</span></p></td></tr></table></div><div class="SIntrapara">The <span class="stt">#0=</span> notation is the moral equivalent of saying, â€œIâ€™m going to refer to
this value again later, so letâ€™s call it the 0th valueâ€ and <span class="stt">#0#</span> is saying â€œHere
Iâ€™m referring to the aforementioned 0th valueâ€.</div><p>(Yes, there can be more than one shared value in an output, so each is given a
different â€œnameâ€. Weâ€™ll see that in a moment.)</p><p/><div class="SIntrapara">The later example above translates to
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">(define n13 (nd 13 (mt) (mt)))</span></p></td></tr><tr><td><p><span class="stt">(define n11 (nd 11 n13 n13))</span></p></td></tr><tr><td><p><span class="stt">(define n12 (nd 12 n13 (mt)))</span></p></td></tr><tr><td><p><span class="stt">(define n10 (nd 10 n11 n12))</span></p></td></tr></table></div><div class="SIntrapara">which prints as
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">&gt; n10</span></p></td></tr><tr><td><p><span class="stt">(nd 10 (nd 11 #0=(nd 13 (mt) (mt)) #0#) (nd 12 #0# (mt)))</span></p></td></tr></table></div><div class="SIntrapara">So it is possible for a language to reflect the sharing in its output. Itâ€™s
just that most programming languages choose to not do that, even optionally.</div><p>Remember the â€œalmostâ€ above? What was that about?</p><p/><div class="SIntrapara">In Racket, weâ€™ve made a new instance of <span class="stt">mt</span> over and over. We can more
accurately reflect what is happening in Pyret by instantiating it only once:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">(struct mt () #:transparent)</span></p></td></tr><tr><td><p><span class="stt">(define the-mt (mt))</span></p></td></tr><tr><td><p><span class="stt">(struct nd (v l r) #:transparent)</span></p></td></tr></table></div><div class="SIntrapara">We then rewrite the earlier example to use that one instance only:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">(define n1 (nd 1 the-mt the-mt))</span></p></td></tr><tr><td><p><span class="stt">(define n2 (nd 2 the-mt n1))</span></p></td></tr><tr><td><p><span class="stt">(define n3 (nd 3 n1 the-mt))</span></p></td></tr><tr><td><p><span class="stt">(define n4 (nd 4 n2 n3))</span></p></td></tr></table></div><div class="SIntrapara">And now when we print it:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">&gt; n4</span></p></td></tr><tr><td><p><span class="stt">(nd 4 (nd 2 #0=(mt) #1=(nd 1 #0# #0#)) (nd 3 #1# #0#))</span></p></td></tr></table></div><div class="SIntrapara">And now you can see there are two different shared values, one is the single
instance of <span class="stt">mt</span>, the other is the <span class="stt">nd</span> with <span class="stt">1</span> in it. Thus, Racket
uses both <span class="stt">#0=</span> / <span class="stt">#0#</span> and <span class="stt">#1=</span> / <span class="stt">#1#</span>. Notice how all the
leaves are sharing the same <span class="stt">mt</span> instance. (The numbering is picked in the
order in which nodes are encountered while traversing, which is why the <span class="stt">nd</span>
instance was <span class="stt">#0</span> the previous time and is <span class="stt">#1</span> this time.)</div>    
</body>
</html>