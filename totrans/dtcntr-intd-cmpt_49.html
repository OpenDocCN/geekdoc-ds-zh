<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>16.2Â The Size of a DAGğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>16.2Â The Size of a DAGğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/size-of-dag.html">https://dcic-world.org/2025-08-27/size-of-dag.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._.Stage_1%29" class="toclink" data-pltdoc="x">16.2.1Â Stage 1</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Stage_2%29" class="toclink" data-pltdoc="x">16.2.2Â Stage 2</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Stage_3%29" class="toclink" data-pltdoc="x">16.2.3Â Stage 3</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Stage_4%29" class="toclink" data-pltdoc="x">16.2.4Â Stage 4</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Stage_5%29" class="toclink" data-pltdoc="x">16.2.5Â Stage 5</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.What_.We~e2~80~99ve_.Learned%29" class="toclink" data-pltdoc="x">16.2.6Â What Weâ€™ve Learned</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.More_on_.Value_.Printing__.An_.Aside_from_.Racket%29" class="toclink" data-pltdoc="x">16.2.7Â More on Value Printing: An Aside from Racket</a></p></td></tr></table><p>Letâ€™s start by defining a function to compute the size of a tree:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data BT:
  | mt
  | nd(v :: Number, l :: BT, r :: BT)
end

fun size-1(b :: BT) -&gt; Number:
  cases (BT) b:
    | mt =&gt; 0
    | nd(v, l, r) =&gt; 1 + size-1(l) + size-1(r)
  end
end</code></pre><p>This is straightforward enough.</p><p>But letâ€™s say that our input isnâ€™t actually a tree, but rather a DAG. For
instance:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">#|
     4
    / \
   2   3
    \ /
     1
|#

n1 = nd(1, mt, mt)
n2 = nd(2, mt, n1)
n3 = nd(3, n1, mt)
n4 = nd(4, n2, n3)</code></pre><p>where <code data-lang="pyret" class="sourceCode">n4</code> is the DAG. There are two notions of size here. One is like
a â€œprint sizeâ€: how much space will it occupy when printed. The current size
function computes that well. But another is the â€œallocationâ€ size: how many
nodes did we allocate. How do we fare?</p><section class="SsectionLevel4" id="section 16.2.1"><h4 class="heading">16.2.1Â <a name="(part._.Stage_1)"/>Stage 1<a href="#(part._.Stage_1)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  size-1(n1) is 1
  size-1(n2) is 2
  size-1(n3) is 2
  size-1(n4) is 4
end</code></pre><p>Clearly the answer should be <code data-lang="pyret" class="sourceCode">4</code>: we can just read off how many <code data-lang="pyret" class="sourceCode">nd</code>
calls there are. And clearly the function is wrong.</p><p>The problem, of course, is that a DAG involves repeating nodes, and we
arenâ€™t doing anything to track the repetition. So we need a stronger contract:
weâ€™ll split the problem into two parts, a standard interface function that
takes just the DAG and returns a number, and a richer helper function, which
also takes a memory of the nodes already seen.</p></section><section class="SsectionLevel4" id="section 16.2.2"><h4 class="heading">16.2.2Â <a name="(part._.Stage_2)"/>Stage 2<a href="#(part._.Stage_2)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size-2-h(b :: BT, seen :: List&lt;BT&gt;) -&gt; Number:
  if member-identical(seen, b):
    0
  else:
    cases (BT) b:
      | mt =&gt; 0
      | nd(v, l, r) =&gt;
        new-seen = link(b, seen)
        1 + size-2-h(l, new-seen) + size-2-h(r, new-seen)
    end
  end
end</code></pre><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Why does this code use <code data-lang="pyret" class="sourceCode">member-identical</code> rather than <code data-lang="pyret" class="sourceCode">member</code>?</p><p>Observe that if we replace every <code data-lang="pyret" class="sourceCode">member-identical</code> with <code data-lang="pyret" class="sourceCode">member</code> in
this chapter, the code still behaves the same. Why?</p><p>Make changes to demonstrate the need for <code data-lang="pyret" class="sourceCode">member-identical</code>.</p></blockquote></blockquote><p>Is it odd that we return <code data-lang="pyret" class="sourceCode">0</code>? Not if we reinterpret what the function
does: it doesnâ€™t count the size, it counts the additional
contribution to the size (relative to what has already been seen) of the
<code data-lang="pyret" class="sourceCode">BT</code> it is given. A node already in <code data-lang="pyret" class="sourceCode">seen</code> makes no marginal
contribution; it was already counted earlier.</p><p>Finally, we should not export such a function to the user, who has to deal with
an unwieldy extra parameter and may send something poorly-formed, thereby
causing our function to break. Instead, we should write a wrapper for it:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size-2(b :: BT): size-2-h(b, empty) end</code></pre><p>This also enables us to use our old tests (renamed):
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  size-2(n1) is 1
  size-2(n2) is 2
  size-2(n3) is 2
  size-2(n4) is 4
end</code></pre><p>Unfortunately, this still doesnâ€™t work!</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Use Pyretâ€™s <code data-lang="pyret" class="sourceCode">spy</code> construct in <code data-lang="pyret" class="sourceCode">size-2-h</code> to figure out why.</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 16.2.3"><h4 class="heading">16.2.3Â <a name="(part._.Stage_3)"/>Stage 3<a href="#(part._.Stage_3)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Did you remember to use <code data-lang="pyret" class="sourceCode">spy</code>? Otherwise you may very well miss the
problem! Be sure to use <code data-lang="pyret" class="sourceCode">spy</code> (feel free to elide the first few tests for
now) to get a feel for the issue.</p><p>As you may have noted, the problem is that we want <code data-lang="pyret" class="sourceCode">seen</code> to be all the
nodes ever seen. However, every time we return from one sub-computation,
we also lose track of whatever was seen during its work. Instead, we have to
also return everything that was seen, so as to properly preserve the idea that
weâ€™re computing the marginal contribution of each node.</p><p>We can do this with the following data structure:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Ret: ret(sz :: Number, sn :: List&lt;BT&gt;) end</code></pre><p>which is returned by the helper function:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size-3-h(b :: BT, seen :: List&lt;BT&gt;) -&gt; Ret:
  if member-identical(seen, b):
    ret(0, seen)
  else:
    cases (BT) b:
      | mt =&gt; ret(0, seen)
      | nd(v, l, r) =&gt;
        new-seen = link(b, seen)
        rl = size-3-h(l, new-seen)
        rr = size-3-h(r, rl.sn)
        ret(1 + rl.sz + rr.sz, rr.sn)
    end
  end
end</code></pre><p>Note, crucially, how the <code data-lang="pyret" class="sourceCode">seen</code> argument for the right branch is
<code data-lang="pyret" class="sourceCode">rl.sn</code>: i.e., everything that was already seen in the left branch. This
is the crucial step that avoids the bug.</p><p>Because of this richer return type, we have to extract the actual answer for
the purpose of testing:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size-3(b :: BT): size-3-h(b, empty).sz end

check:
  size-3(n1) is 1
  size-3(n2) is 2
  size-3(n3) is 2
  size-3(n4) is 4
end</code></pre><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Must <code data-lang="pyret" class="sourceCode">seen</code> be a list? What else can it be?</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 16.2.4"><h4 class="heading">16.2.4Â <a name="(part._.Stage_4)"/>Stage 4<a href="#(part._.Stage_4)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Observe that the <code data-lang="pyret" class="sourceCode">Ret</code> data structure is only of local interest. Itâ€™s
purely internal to the <code data-lang="pyret" class="sourceCode">size-3-h</code> function; even <code data-lang="pyret" class="sourceCode">size-3</code> ignores one
half, and it will never be seen by the rest of the program. That is a good use
of tuples, as we have seen before: <a href="queues-from-lists.html#%28part._qfl-tuples%29" data-pltdoc="x">Using Tuples</a>!</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size-4-h(b :: BT, seen :: List&lt;BT&gt;) -&gt; {Number; List&lt;BT&gt;}:
  if member-identical(seen, b):
    {0; seen}
  else:
    cases (BT) b:
      | mt =&gt; {0; seen}
      | nd(v, l, r) =&gt;
        new-seen = link(b, seen)
        {lsz; lsn} = size-4-h(l, new-seen)
        {rsz; rsn} = size-4-h(r, lsn)
        {1 + lsz + rsz; rsn}
    end
  end
end

fun size-4(b :: BT): size-4-h(b, empty).{0} end

check:
  size-4(n1) is 1
  size-4(n2) is 2
  size-4(n3) is 2
  size-4(n4) is 4
end</code></pre><p>The notation <code data-lang="pyret" class="sourceCode">{0; seen}</code> makes an actual tuple; <code data-lang="pyret" class="sourceCode">{Number; List&lt;BT&gt;}</code>
declares the contract of a tuple. Also, <code data-lang="pyret" class="sourceCode">.{0}</code> extracts the
<code data-lang="pyret" class="sourceCode">0</code>th element (the leftmost one) of a tuple.</p></section><section class="SsectionLevel4" id="section 16.2.5"><h4 class="heading">16.2.5Â <a name="(part._.Stage_5)"/>Stage 5<a href="#(part._.Stage_5)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Notice that we have the two instances of the code <code data-lang="pyret" class="sourceCode">{0; seen}</code>. Do they
have to be that? What if we were to return <code data-lang="pyret" class="sourceCode">{0; empty}</code> instead in both
places? Does anything break?</p><p>We might expect it to break in the case where <code data-lang="pyret" class="sourceCode">member-identical</code> returns
<code data-lang="pyret" class="sourceCode">true</code>, but perhaps not in the <code data-lang="pyret" class="sourceCode">mt</code> case.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Make each of these changes. Does the outcome match your expectations?</p></blockquote></blockquote><p>Curiously, no! Making the change in the <code data-lang="pyret" class="sourceCode">mt</code> case has an effect but making
it in the <code data-lang="pyret" class="sourceCode">member-identical</code> case doesnâ€™t! This almost seems
counter-intuitive. How can we diagnose this?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Use <code data-lang="pyret" class="sourceCode">spy</code> to determine what is going on!</p></blockquote></blockquote><p>Okay, so it seems like returning <code data-lang="pyret" class="sourceCode">empty</code> when we revisit a node doesnâ€™t
seem to do any harm. Does that mean itâ€™s okay to make that change?</p><p>Observe that nothing has actually depended on that seen-list being
<code data-lang="pyret" class="sourceCode">empty</code>. Thatâ€™s why it appears to not matter. How can we make it matter?
By making it â€œhurtâ€ the computation by visiting a previously seen, but now
forgotten, node yet again. So we need to visit a node at least three times: the
first time to remember it; the second time to forget it; and a third time to
incorrectly visit it again. Hereâ€™s a DAG that will do that:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">#|
    10
    / \
   11 12
  / \ /
 13&lt;--
|#

n13 = nd(13, mt, mt)
n11 = nd(11, n13, n13)
n12 = nd(12, n13, mt)
n10 = nd(10, n11, n12)

check:
  size-4(n10) is 4
end</code></pre><p>Sure enough, if either tuple now returns <code data-lang="pyret" class="sourceCode">empty</code>, this test
fails. Otherwise it succeeds.</p></section><section class="SsectionLevel4" id="section 16.2.6"><h4 class="heading">16.2.6Â <a name="(part._.What_.We~e2~80~99ve_.Learned)"/>What Weâ€™ve Learned<a href="#(part._.What_.We~e2~80~99ve_.Learned)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>We have learned three important principles here:
</p><ul><li><p>A pattern for dealing with programs that need â€œmemoryâ€. This is called
threading (not in the sense of â€œmulti-threadingâ€, which is a kind of
parallel computation, but rather the pattern of how the seen list gets passed
through the program).</p></li><li><p>A good example of the use of tuples: local, where the documentation
benefit of datatypes isnâ€™t necessary (and the extra datatype probably just
clutters up the program), as opposed to distant, where it is. In general, itâ€™s
always okay to make a new datatype; itâ€™s only sometimes okay to use tuples in
their place.</p></li><li><p>An important software-engineering principle, called
mutation testing. This is an odd name because it would seem to be the
name of a technique to test programs. Actually, itâ€™s a technique to test
test suites. You have a tested program; you then â€œmutateâ€ some part of
your program that you feel must change the output, and see whether any tests
break. If no tests break, then either youâ€™ve misunderstood your program or,
more likely, your test suite is not good enough. Improve your test suite to
catch the error in your program, or convince yourself the change didnâ€™t matter.</p><p>There are mutation testing tools that will randomly try to alter your program
using â€œmutantâ€ strategiesâ€”<wbr/>e.g., replacing a <code data-lang="pyret" class="sourceCode">+</code> with a <code data-lang="pyret" class="sourceCode">-</code>â€”<wbr/>and
re-run your suites, and then report back on how many potential mutants the
suites actually caught. But we canâ€™t and shouldnâ€™t only rely on tools; we can
also apply the principle of mutation testing by hand, as we have above. At the
very least, it will help us understand our program better!</p></li></ul></section><section class="SsectionLevel4" id="section 16.2.7"><h4 class="heading">16.2.7Â <a name="(part._.More_on_.Value_.Printing__.An_.Aside_from_.Racket)"/>More on Value Printing: An Aside from Racket<a href="#(part._.More_on_.Value_.Printing__.An_.Aside_from_.Racket)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Earlier, we talked about how the standard recursive size can still be thought
of as a â€œsize of printed valueâ€ computation. However, that actually depends on
your languageâ€™s value printer.</p><p>In Racket, you can turn on (itâ€™s slightly more expensive, so off by default) a
value-printer that shows value sharing: Language | Choose Language â€¦ | Show
Details | Show sharing in values. So if we take the data definition above and
translate it into Racket structures
</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p>(struct mt () #:transparent)</p></td></tr><tr><td><p>(struct nd (v l r) #:transparent)</p></td></tr></table><p>and then construct (almost) the same data as in the first example:
</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p>(define n1 (nd 1 (mt) (mt)))</p></td></tr><tr><td><p>(define n2 (nd 2 (mt) n1))</p></td></tr><tr><td><p>(define n3 (nd 3 n1 (mt)))</p></td></tr><tr><td><p>(define n4 (nd 4 n2 n3))</p></td></tr></table><p>and then ask Racket to print it, we get:
</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p>&gt; n4</p></td></tr><tr><td><p>(nd 4 (nd 2 (mt) #0=(nd 1 (mt) (mt))) (nd 3 #0# (mt)))</p></td></tr></table><p>The #0= notation is the moral equivalent of saying, â€œIâ€™m going to refer to
this value again later, so letâ€™s call it the 0th valueâ€ and #0# is saying â€œHere
Iâ€™m referring to the aforementioned 0th valueâ€.</p><p>(Yes, there can be more than one shared value in an output, so each is given a
different â€œnameâ€. Weâ€™ll see that in a moment.)</p><p>The later example above translates to
</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p>(define n13 (nd 13 (mt) (mt)))</p></td></tr><tr><td><p>(define n11 (nd 11 n13 n13))</p></td></tr><tr><td><p>(define n12 (nd 12 n13 (mt)))</p></td></tr><tr><td><p>(define n10 (nd 10 n11 n12))</p></td></tr></table><p>which prints as
</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p>&gt; n10</p></td></tr><tr><td><p>(nd 10 (nd 11 #0=(nd 13 (mt) (mt)) #0#) (nd 12 #0# (mt)))</p></td></tr></table><p>So it is possible for a language to reflect the sharing in its output. Itâ€™s
just that most programming languages choose to not do that, even optionally.</p><p>Remember the â€œalmostâ€ above? What was that about?</p><p>In Racket, weâ€™ve made a new instance of mt over and over. We can more
accurately reflect what is happening in Pyret by instantiating it only once:
</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p>(struct mt () #:transparent)</p></td></tr><tr><td><p>(define the-mt (mt))</p></td></tr><tr><td><p>(struct nd (v l r) #:transparent)</p></td></tr></table><p>We then rewrite the earlier example to use that one instance only:
</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p>(define n1 (nd 1 the-mt the-mt))</p></td></tr><tr><td><p>(define n2 (nd 2 the-mt n1))</p></td></tr><tr><td><p>(define n3 (nd 3 n1 the-mt))</p></td></tr><tr><td><p>(define n4 (nd 4 n2 n3))</p></td></tr></table><p>And now when we print it:
</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p>&gt; n4</p></td></tr><tr><td><p>(nd 4 (nd 2 #0=(mt) #1=(nd 1 #0# #0#)) (nd 3 #1# #0#))</p></td></tr></table><p>And now you can see there are two different shared values, one is the single
instance of mt, the other is the nd with 1 in it. Thus, Racket
uses both #0= / #0# and #1= / #1#. Notice how all the
leaves are sharing the same mt instance. (The numbering is picked in the
order in which nodes are encountered while traversing, which is why the nd
instance was #0 the previous time and is #1 this time.)</p></section>&#13;
<h4 class="heading">16.2.1Â <a name="(part._.Stage_1)"/>Stage 1<a href="#(part._.Stage_1)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  size-1(n1) is 1
  size-1(n2) is 2
  size-1(n3) is 2
  size-1(n4) is 4
end</code></pre><p>Clearly the answer should be <code data-lang="pyret" class="sourceCode">4</code>: we can just read off how many <code data-lang="pyret" class="sourceCode">nd</code>
calls there are. And clearly the function is wrong.</p><p>The problem, of course, is that a DAG involves repeating nodes, and we
arenâ€™t doing anything to track the repetition. So we need a stronger contract:
weâ€™ll split the problem into two parts, a standard interface function that
takes just the DAG and returns a number, and a richer helper function, which
also takes a memory of the nodes already seen.</p>&#13;
<h4 class="heading">16.2.2Â <a name="(part._.Stage_2)"/>Stage 2<a href="#(part._.Stage_2)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size-2-h(b :: BT, seen :: List&lt;BT&gt;) -&gt; Number:
  if member-identical(seen, b):
    0
  else:
    cases (BT) b:
      | mt =&gt; 0
      | nd(v, l, r) =&gt;
        new-seen = link(b, seen)
        1 + size-2-h(l, new-seen) + size-2-h(r, new-seen)
    end
  end
end</code></pre><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Why does this code use <code data-lang="pyret" class="sourceCode">member-identical</code> rather than <code data-lang="pyret" class="sourceCode">member</code>?</p><p>Observe that if we replace every <code data-lang="pyret" class="sourceCode">member-identical</code> with <code data-lang="pyret" class="sourceCode">member</code> in
this chapter, the code still behaves the same. Why?</p><p>Make changes to demonstrate the need for <code data-lang="pyret" class="sourceCode">member-identical</code>.</p></blockquote></blockquote><p>Is it odd that we return <code data-lang="pyret" class="sourceCode">0</code>? Not if we reinterpret what the function
does: it doesnâ€™t count the size, it counts the additional
contribution to the size (relative to what has already been seen) of the
<code data-lang="pyret" class="sourceCode">BT</code> it is given. A node already in <code data-lang="pyret" class="sourceCode">seen</code> makes no marginal
contribution; it was already counted earlier.</p><p>Finally, we should not export such a function to the user, who has to deal with
an unwieldy extra parameter and may send something poorly-formed, thereby
causing our function to break. Instead, we should write a wrapper for it:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size-2(b :: BT): size-2-h(b, empty) end</code></pre><p>This also enables us to use our old tests (renamed):
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  size-2(n1) is 1
  size-2(n2) is 2
  size-2(n3) is 2
  size-2(n4) is 4
end</code></pre><p>Unfortunately, this still doesnâ€™t work!</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Use Pyretâ€™s <code data-lang="pyret" class="sourceCode">spy</code> construct in <code data-lang="pyret" class="sourceCode">size-2-h</code> to figure out why.</p></blockquote></blockquote>&#13;
<h4 class="heading">16.2.3Â <a name="(part._.Stage_3)"/>Stage 3<a href="#(part._.Stage_3)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Did you remember to use <code data-lang="pyret" class="sourceCode">spy</code>? Otherwise you may very well miss the
problem! Be sure to use <code data-lang="pyret" class="sourceCode">spy</code> (feel free to elide the first few tests for
now) to get a feel for the issue.</p><p>As you may have noted, the problem is that we want <code data-lang="pyret" class="sourceCode">seen</code> to be all the
nodes ever seen. However, every time we return from one sub-computation,
we also lose track of whatever was seen during its work. Instead, we have to
also return everything that was seen, so as to properly preserve the idea that
weâ€™re computing the marginal contribution of each node.</p><p>We can do this with the following data structure:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Ret: ret(sz :: Number, sn :: List&lt;BT&gt;) end</code></pre><p>which is returned by the helper function:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size-3-h(b :: BT, seen :: List&lt;BT&gt;) -&gt; Ret:
  if member-identical(seen, b):
    ret(0, seen)
  else:
    cases (BT) b:
      | mt =&gt; ret(0, seen)
      | nd(v, l, r) =&gt;
        new-seen = link(b, seen)
        rl = size-3-h(l, new-seen)
        rr = size-3-h(r, rl.sn)
        ret(1 + rl.sz + rr.sz, rr.sn)
    end
  end
end</code></pre><p>Note, crucially, how the <code data-lang="pyret" class="sourceCode">seen</code> argument for the right branch is
<code data-lang="pyret" class="sourceCode">rl.sn</code>: i.e., everything that was already seen in the left branch. This
is the crucial step that avoids the bug.</p><p>Because of this richer return type, we have to extract the actual answer for
the purpose of testing:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size-3(b :: BT): size-3-h(b, empty).sz end

check:
  size-3(n1) is 1
  size-3(n2) is 2
  size-3(n3) is 2
  size-3(n4) is 4
end</code></pre><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Must <code data-lang="pyret" class="sourceCode">seen</code> be a list? What else can it be?</p></blockquote></blockquote>&#13;
<h4 class="heading">16.2.4Â <a name="(part._.Stage_4)"/>Stage 4<a href="#(part._.Stage_4)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Observe that the <code data-lang="pyret" class="sourceCode">Ret</code> data structure is only of local interest. Itâ€™s
purely internal to the <code data-lang="pyret" class="sourceCode">size-3-h</code> function; even <code data-lang="pyret" class="sourceCode">size-3</code> ignores one
half, and it will never be seen by the rest of the program. That is a good use
of tuples, as we have seen before: <a href="queues-from-lists.html#%28part._qfl-tuples%29" data-pltdoc="x">Using Tuples</a>!</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun size-4-h(b :: BT, seen :: List&lt;BT&gt;) -&gt; {Number; List&lt;BT&gt;}:
  if member-identical(seen, b):
    {0; seen}
  else:
    cases (BT) b:
      | mt =&gt; {0; seen}
      | nd(v, l, r) =&gt;
        new-seen = link(b, seen)
        {lsz; lsn} = size-4-h(l, new-seen)
        {rsz; rsn} = size-4-h(r, lsn)
        {1 + lsz + rsz; rsn}
    end
  end
end

fun size-4(b :: BT): size-4-h(b, empty).{0} end

check:
  size-4(n1) is 1
  size-4(n2) is 2
  size-4(n3) is 2
  size-4(n4) is 4
end</code></pre><p>The notation <code data-lang="pyret" class="sourceCode">{0; seen}</code> makes an actual tuple; <code data-lang="pyret" class="sourceCode">{Number; List&lt;BT&gt;}</code>
declares the contract of a tuple. Also, <code data-lang="pyret" class="sourceCode">.{0}</code> extracts the
<code data-lang="pyret" class="sourceCode">0</code>th element (the leftmost one) of a tuple.</p>&#13;
<h4 class="heading">16.2.5Â <a name="(part._.Stage_5)"/>Stage 5<a href="#(part._.Stage_5)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Notice that we have the two instances of the code <code data-lang="pyret" class="sourceCode">{0; seen}</code>. Do they
have to be that? What if we were to return <code data-lang="pyret" class="sourceCode">{0; empty}</code> instead in both
places? Does anything break?</p><p>We might expect it to break in the case where <code data-lang="pyret" class="sourceCode">member-identical</code> returns
<code data-lang="pyret" class="sourceCode">true</code>, but perhaps not in the <code data-lang="pyret" class="sourceCode">mt</code> case.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Make each of these changes. Does the outcome match your expectations?</p></blockquote></blockquote><p>Curiously, no! Making the change in the <code data-lang="pyret" class="sourceCode">mt</code> case has an effect but making
it in the <code data-lang="pyret" class="sourceCode">member-identical</code> case doesnâ€™t! This almost seems
counter-intuitive. How can we diagnose this?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Use <code data-lang="pyret" class="sourceCode">spy</code> to determine what is going on!</p></blockquote></blockquote><p>Okay, so it seems like returning <code data-lang="pyret" class="sourceCode">empty</code> when we revisit a node doesnâ€™t
seem to do any harm. Does that mean itâ€™s okay to make that change?</p><p>Observe that nothing has actually depended on that seen-list being
<code data-lang="pyret" class="sourceCode">empty</code>. Thatâ€™s why it appears to not matter. How can we make it matter?
By making it â€œhurtâ€ the computation by visiting a previously seen, but now
forgotten, node yet again. So we need to visit a node at least three times: the
first time to remember it; the second time to forget it; and a third time to
incorrectly visit it again. Hereâ€™s a DAG that will do that:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">#|
    10
    / \
   11 12
  / \ /
 13&lt;--
|#

n13 = nd(13, mt, mt)
n11 = nd(11, n13, n13)
n12 = nd(12, n13, mt)
n10 = nd(10, n11, n12)

check:
  size-4(n10) is 4
end</code></pre><p>Sure enough, if either tuple now returns <code data-lang="pyret" class="sourceCode">empty</code>, this test
fails. Otherwise it succeeds.</p>&#13;
<h4 class="heading">16.2.6Â <a name="(part._.What_.We~e2~80~99ve_.Learned)"/>What Weâ€™ve Learned<a href="#(part._.What_.We~e2~80~99ve_.Learned)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>We have learned three important principles here:
</p><ul><li><p>A pattern for dealing with programs that need â€œmemoryâ€. This is called
threading (not in the sense of â€œmulti-threadingâ€, which is a kind of
parallel computation, but rather the pattern of how the seen list gets passed
through the program).</p></li><li><p>A good example of the use of tuples: local, where the documentation
benefit of datatypes isnâ€™t necessary (and the extra datatype probably just
clutters up the program), as opposed to distant, where it is. In general, itâ€™s
always okay to make a new datatype; itâ€™s only sometimes okay to use tuples in
their place.</p></li><li><p>An important software-engineering principle, called
mutation testing. This is an odd name because it would seem to be the
name of a technique to test programs. Actually, itâ€™s a technique to test
test suites. You have a tested program; you then â€œmutateâ€ some part of
your program that you feel must change the output, and see whether any tests
break. If no tests break, then either youâ€™ve misunderstood your program or,
more likely, your test suite is not good enough. Improve your test suite to
catch the error in your program, or convince yourself the change didnâ€™t matter.</p><p>There are mutation testing tools that will randomly try to alter your program
using â€œmutantâ€ strategiesâ€”<wbr/>e.g., replacing a <code data-lang="pyret" class="sourceCode">+</code> with a <code data-lang="pyret" class="sourceCode">-</code>â€”<wbr/>and
re-run your suites, and then report back on how many potential mutants the
suites actually caught. But we canâ€™t and shouldnâ€™t only rely on tools; we can
also apply the principle of mutation testing by hand, as we have above. At the
very least, it will help us understand our program better!</p></li></ul>&#13;
<h4 class="heading">16.2.7Â <a name="(part._.More_on_.Value_.Printing__.An_.Aside_from_.Racket)"/>More on Value Printing: An Aside from Racket<a href="#(part._.More_on_.Value_.Printing__.An_.Aside_from_.Racket)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Earlier, we talked about how the standard recursive size can still be thought
of as a â€œsize of printed valueâ€ computation. However, that actually depends on
your languageâ€™s value printer.</p><p>In Racket, you can turn on (itâ€™s slightly more expensive, so off by default) a
value-printer that shows value sharing: Language | Choose Language â€¦ | Show
Details | Show sharing in values. So if we take the data definition above and
translate it into Racket structures
</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p>(struct mt () #:transparent)</p></td></tr><tr><td><p>(struct nd (v l r) #:transparent)</p></td></tr></table><p>and then construct (almost) the same data as in the first example:
</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p>(define n1 (nd 1 (mt) (mt)))</p></td></tr><tr><td><p>(define n2 (nd 2 (mt) n1))</p></td></tr><tr><td><p>(define n3 (nd 3 n1 (mt)))</p></td></tr><tr><td><p>(define n4 (nd 4 n2 n3))</p></td></tr></table><p>and then ask Racket to print it, we get:
</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p>&gt; n4</p></td></tr><tr><td><p>(nd 4 (nd 2 (mt) #0=(nd 1 (mt) (mt))) (nd 3 #0# (mt)))</p></td></tr></table><p>The #0= notation is the moral equivalent of saying, â€œIâ€™m going to refer to
this value again later, so letâ€™s call it the 0th valueâ€ and #0# is saying â€œHere
Iâ€™m referring to the aforementioned 0th valueâ€.</p><p>(Yes, there can be more than one shared value in an output, so each is given a
different â€œnameâ€. Weâ€™ll see that in a moment.)</p><p>The later example above translates to
</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p>(define n13 (nd 13 (mt) (mt)))</p></td></tr><tr><td><p>(define n11 (nd 11 n13 n13))</p></td></tr><tr><td><p>(define n12 (nd 12 n13 (mt)))</p></td></tr><tr><td><p>(define n10 (nd 10 n11 n12))</p></td></tr></table><p>which prints as
</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p>&gt; n10</p></td></tr><tr><td><p>(nd 10 (nd 11 #0=(nd 13 (mt) (mt)) #0#) (nd 12 #0# (mt)))</p></td></tr></table><p>So it is possible for a language to reflect the sharing in its output. Itâ€™s
just that most programming languages choose to not do that, even optionally.</p><p>Remember the â€œalmostâ€ above? What was that about?</p><p>In Racket, weâ€™ve made a new instance of mt over and over. We can more
accurately reflect what is happening in Pyret by instantiating it only once:
</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p>(struct mt () #:transparent)</p></td></tr><tr><td><p>(define the-mt (mt))</p></td></tr><tr><td><p>(struct nd (v l r) #:transparent)</p></td></tr></table><p>We then rewrite the earlier example to use that one instance only:
</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p>(define n1 (nd 1 the-mt the-mt))</p></td></tr><tr><td><p>(define n2 (nd 2 the-mt n1))</p></td></tr><tr><td><p>(define n3 (nd 3 n1 the-mt))</p></td></tr><tr><td><p>(define n4 (nd 4 n2 n3))</p></td></tr></table><p>And now when we print it:
</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p>&gt; n4</p></td></tr><tr><td><p>(nd 4 (nd 2 #0=(mt) #1=(nd 1 #0# #0#)) (nd 3 #1# #0#))</p></td></tr></table><p>And now you can see there are two different shared values, one is the single
instance of mt, the other is the nd with 1 in it. Thus, Racket
uses both #0= / #0# and #1= / #1#. Notice how all the
leaves are sharing the same mt instance. (The numbering is picked in the
order in which nodes are encountered while traversing, which is why the nd
instance was #0 the previous time and is #1 this time.)</p>    
</body>
</html>