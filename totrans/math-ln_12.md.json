["```py\nopen  Real\n\n/-- The sin function has derivative 1 at 0\\. -/\nexample  :  HasDerivAt  sin  1  0  :=  by  simpa  using  hasDerivAt_sin  0 \n```", "```py\nexample  (x  :  â„)  :  DifferentiableAt  â„  sin  x  :=\n  (hasDerivAt_sin  x).differentiableAt \n```", "```py\nexample  {f  :  â„  â†’  â„}  {x  a  :  â„}  (h  :  HasDerivAt  f  a  x)  :  deriv  f  x  =  a  :=\n  h.deriv\n\nexample  {f  :  â„  â†’  â„}  {x  :  â„}  (h  :  Â¬DifferentiableAt  â„  f  x)  :  deriv  f  x  =  0  :=\n  deriv_zero_of_not_differentiableAt  h \n```", "```py\nexample  {f  g  :  â„  â†’  â„}  {x  :  â„}  (hf  :  DifferentiableAt  â„  f  x)  (hg  :  DifferentiableAt  â„  g  x)  :\n  deriv  (f  +  g)  x  =  deriv  f  x  +  deriv  g  x  :=\n  deriv_add  hf  hg \n```", "```py\nexample  {f  :  â„  â†’  â„}  {a  :  â„}  (h  :  IsLocalMin  f  a)  :  deriv  f  a  =  0  :=\n  h.deriv_eq_zero \n```", "```py\nopen  Set\n\nexample  {f  :  â„  â†’  â„}  {a  b  :  â„}  (hab  :  a  <  b)  (hfc  :  ContinuousOn  f  (Icc  a  b))  (hfI  :  f  a  =  f  b)  :\n  âˆƒ  c  âˆˆ  Ioo  a  b,  deriv  f  c  =  0  :=\n  exists_deriv_eq_zero  hab  hfc  hfI \n```", "```py\nexample  (f  :  â„  â†’  â„)  {a  b  :  â„}  (hab  :  a  <  b)  (hf  :  ContinuousOn  f  (Icc  a  b))\n  (hf'  :  DifferentiableOn  â„  f  (Ioo  a  b))  :  âˆƒ  c  âˆˆ  Ioo  a  b,  deriv  f  c  =  (f  b  -  f  a)  /  (b  -  a)  :=\n  exists_deriv_eq_slope  f  hab  hf  hf' \n```", "```py\nexample  :  deriv  (fun  x  :  â„  â†¦  x  ^  5)  6  =  5  *  6  ^  4  :=  by  simp\n\nexample  :  deriv  sin  Ï€  =  -1  :=  by  simp \n```", "```py\nvariable  {E  :  Type*}  [NormedAddCommGroup  E]\n\nexample  (x  :  E)  :  0  â‰¤  â€–xâ€–  :=\n  norm_nonneg  x\n\nexample  {x  :  E}  :  â€–xâ€–  =  0  â†”  x  =  0  :=\n  norm_eq_zero\n\nexample  (x  y  :  E)  :  â€–x  +  yâ€–  â‰¤  â€–xâ€–  +  â€–yâ€–  :=\n  norm_add_le  x  y \n```", "```py\nexample  :  MetricSpace  E  :=  by  infer_instance\n\nexample  {X  :  Type*}  [TopologicalSpace  X]  {f  :  X  â†’  E}  (hf  :  Continuous  f)  :\n  Continuous  fun  x  â†¦  â€–f  xâ€–  :=\n  hf.norm \n```", "```py\nvariable  [NormedSpace  â„  E]\n\nexample  (a  :  â„)  (x  :  E)  :  â€–a  â€¢  xâ€–  =  |a|  *  â€–xâ€–  :=\n  norm_smul  a  x \n```", "```py\nexample  [FiniteDimensional  â„  E]  :  CompleteSpace  E  :=  by  infer_instance \n```", "```py\nexample  (ğ•œ  :  Type*)  [NontriviallyNormedField  ğ•œ]  (x  y  :  ğ•œ)  :  â€–x  *  yâ€–  =  â€–xâ€–  *  â€–yâ€–  :=\n  norm_mul  x  y\n\nexample  (ğ•œ  :  Type*)  [NontriviallyNormedField  ğ•œ]  :  âˆƒ  x  :  ğ•œ,  1  <  â€–xâ€–  :=\n  NormedField.exists_one_lt_norm  ğ•œ \n```", "```py\nexample  (ğ•œ  :  Type*)  [NontriviallyNormedField  ğ•œ]  (E  :  Type*)  [NormedAddCommGroup  E]\n  [NormedSpace  ğ•œ  E]  [CompleteSpace  ğ•œ]  [FiniteDimensional  ğ•œ  E]  :  CompleteSpace  E  :=\n  FiniteDimensional.complete  ğ•œ  E \n```", "```py\nvariable  {ğ•œ  :  Type*}  [NontriviallyNormedField  ğ•œ]  {E  :  Type*}  [NormedAddCommGroup  E]\n  [NormedSpace  ğ•œ  E]  {F  :  Type*}  [NormedAddCommGroup  F]  [NormedSpace  ğ•œ  F]\n\nexample  :  E  â†’L[ğ•œ]  E  :=\n  ContinuousLinearMap.id  ğ•œ  E\n\nexample  (f  :  E  â†’L[ğ•œ]  F)  :  E  â†’  F  :=\n  f\n\nexample  (f  :  E  â†’L[ğ•œ]  F)  :  Continuous  f  :=\n  f.cont\n\nexample  (f  :  E  â†’L[ğ•œ]  F)  (x  y  :  E)  :  f  (x  +  y)  =  f  x  +  f  y  :=\n  f.map_add  x  y\n\nexample  (f  :  E  â†’L[ğ•œ]  F)  (a  :  ğ•œ)  (x  :  E)  :  f  (a  â€¢  x)  =  a  â€¢  f  x  :=\n  f.map_smul  a  x \n```", "```py\nvariable  (f  :  E  â†’L[ğ•œ]  F)\n\nexample  (x  :  E)  :  â€–f  xâ€–  â‰¤  â€–fâ€–  *  â€–xâ€–  :=\n  f.le_opNorm  x\n\nexample  {M  :  â„}  (hMp  :  0  â‰¤  M)  (hM  :  âˆ€  x,  â€–f  xâ€–  â‰¤  M  *  â€–xâ€–)  :  â€–fâ€–  â‰¤  M  :=\n  f.opNorm_le_bound  hMp  hM \n```", "```py\nvariable  {ğ•œ  :  Type*}  [NontriviallyNormedField  ğ•œ]  {E  :  Type*}  [NormedAddCommGroup  E]\n  [NormedSpace  ğ•œ  E]  {F  :  Type*}  [NormedAddCommGroup  F]  [NormedSpace  ğ•œ  F]\n\nopen  Metric\n\nexample  {Î¹  :  Type*}  [CompleteSpace  E]  {g  :  Î¹  â†’  E  â†’L[ğ•œ]  F}  (h  :  âˆ€  x,  âˆƒ  C,  âˆ€  i,  â€–g  i  xâ€–  â‰¤  C)  :\n  âˆƒ  C',  âˆ€  i,  â€–g  iâ€–  â‰¤  C'  :=  by\n  -- sequence of subsets consisting of those `x : E` with norms `â€–g i xâ€–` bounded by `n`\n  let  e  :  â„•  â†’  Set  E  :=  fun  n  â†¦  â‹‚  i  :  Î¹,  {  x  :  E  |  â€–g  i  xâ€–  â‰¤  n  }\n  -- each of these sets is closed\n  have  hc  :  âˆ€  n  :  â„•,  IsClosed  (e  n)\n  sorry\n  -- the union is the entire space; this is where we use `h`\n  have  hU  :  (â‹ƒ  n  :  â„•,  e  n)  =  univ\n  sorry\n  /- apply the Baire category theorem to conclude that for some `m : â„•`,\n `e m` contains some `x` -/\n  obtain  âŸ¨m,  x,  hxâŸ©  :  âˆƒ  m,  âˆƒ  x,  x  âˆˆ  interior  (e  m)  :=  sorry\n  obtain  âŸ¨Îµ,  Îµ_pos,  hÎµâŸ©  :  âˆƒ  Îµ  >  0,  ball  x  Îµ  âŠ†  interior  (e  m)  :=  sorry\n  obtain  âŸ¨k,  hkâŸ©  :  âˆƒ  k  :  ğ•œ,  1  <  â€–kâ€–  :=  sorry\n  -- show all elements in the ball have norm bounded by `m` after applying any `g i`\n  have  real_norm_le  :  âˆ€  z  âˆˆ  ball  x  Îµ,  âˆ€  (i  :  Î¹),  â€–g  i  zâ€–  â‰¤  m\n  sorry\n  have  Îµk_pos  :  0  <  Îµ  /  â€–kâ€–  :=  sorry\n  refine  âŸ¨(m  +  m  :  â„•)  /  (Îµ  /  â€–kâ€–),  fun  i  â†¦  ContinuousLinearMap.opNorm_le_of_shell  Îµ_pos  ?_  hk  ?_âŸ©\n  sorry\n  sorry \n```", "```py\nopen  Asymptotics\n\nexample  {Î±  :  Type*}  {E  :  Type*}  [NormedGroup  E]  {F  :  Type*}  [NormedGroup  F]  (c  :  â„)\n  (l  :  Filter  Î±)  (f  :  Î±  â†’  E)  (g  :  Î±  â†’  F)  :  IsBigOWith  c  l  f  g  â†”  âˆ€á¶   x  in  l,  â€–f  xâ€–  â‰¤  c  *  â€–g  xâ€–  :=\n  isBigOWith_iff\n\nexample  {Î±  :  Type*}  {E  :  Type*}  [NormedGroup  E]  {F  :  Type*}  [NormedGroup  F]\n  (l  :  Filter  Î±)  (f  :  Î±  â†’  E)  (g  :  Î±  â†’  F)  :  f  =O[l]  g  â†”  âˆƒ  C,  IsBigOWith  C  l  f  g  :=\n  isBigO_iff_isBigOWith\n\nexample  {Î±  :  Type*}  {E  :  Type*}  [NormedGroup  E]  {F  :  Type*}  [NormedGroup  F]\n  (l  :  Filter  Î±)  (f  :  Î±  â†’  E)  (g  :  Î±  â†’  F)  :  f  =o[l]  g  â†”  âˆ€  C  >  0,  IsBigOWith  C  l  f  g  :=\n  isLittleO_iff_forall_isBigOWith\n\nexample  {Î±  :  Type*}  {E  :  Type*}  [NormedAddCommGroup  E]  (l  :  Filter  Î±)  (f  g  :  Î±  â†’  E)  :\n  f  ~[l]  g  â†”  (f  -  g)  =o[l]  g  :=\n  Iff.rfl \n```", "```py\nopen  Topology\n\nvariable  {ğ•œ  :  Type*}  [NontriviallyNormedField  ğ•œ]  {E  :  Type*}  [NormedAddCommGroup  E]\n  [NormedSpace  ğ•œ  E]  {F  :  Type*}  [NormedAddCommGroup  F]  [NormedSpace  ğ•œ  F]\n\nexample  (f  :  E  â†’  F)  (f'  :  E  â†’L[ğ•œ]  F)  (xâ‚€  :  E)  :\n  HasFDerivAt  f  f'  xâ‚€  â†”  (fun  x  â†¦  f  x  -  f  xâ‚€  -  f'  (x  -  xâ‚€))  =o[ğ“  xâ‚€]  fun  x  â†¦  x  -  xâ‚€  :=\n  hasFDerivAtFilter_iff_isLittleO  ..\n\nexample  (f  :  E  â†’  F)  (f'  :  E  â†’L[ğ•œ]  F)  (xâ‚€  :  E)  (hff'  :  HasFDerivAt  f  f'  xâ‚€)  :  fderiv  ğ•œ  f  xâ‚€  =  f'  :=\n  hff'.fderiv \n```", "```py\nexample  (n  :  â„•)  (f  :  E  â†’  F)  :  E  â†’  E[Ã—n]â†’L[ğ•œ]  F  :=\n  iteratedFDeriv  ğ•œ  n  f\n\nexample  (n  :  â„•âˆ)  {f  :  E  â†’  F}  :\n  ContDiff  ğ•œ  n  f  â†”\n  (âˆ€  m  :  â„•,  (m  :  WithTop  â„•)  â‰¤  n  â†’  Continuous  fun  x  â†¦  iteratedFDeriv  ğ•œ  m  f  x)  âˆ§\n  âˆ€  m  :  â„•,  (m  :  WithTop  â„•)  <  n  â†’  Differentiable  ğ•œ  fun  x  â†¦  iteratedFDeriv  ğ•œ  m  f  x  :=\n  contDiff_iff_continuous_differentiable \n```", "```py\nexample  {ğ•‚  :  Type*}  [RCLike  ğ•‚]  {E  :  Type*}  [NormedAddCommGroup  E]  [NormedSpace  ğ•‚  E]  {F  :  Type*}\n  [NormedAddCommGroup  F]  [NormedSpace  ğ•‚  F]  {f  :  E  â†’  F}  {x  :  E}  {n  :  WithTop  â„•âˆ}\n  (hf  :  ContDiffAt  ğ•‚  n  f  x)  (hn  :  1  â‰¤  n)  :  HasStrictFDerivAt  f  (fderiv  ğ•‚  f  x)  x  :=\n  hf.hasStrictFDerivAt  hn \n```", "```py\nsection  LocalInverse\nvariable  [CompleteSpace  E]  {f  :  E  â†’  F}  {f'  :  E  â‰ƒL[ğ•œ]  F}  {a  :  E}\n\nexample  (hf  :  HasStrictFDerivAt  f  (f'  :  E  â†’L[ğ•œ]  F)  a)  :  F  â†’  E  :=\n  HasStrictFDerivAt.localInverse  f  f'  a  hf\n\nexample  (hf  :  HasStrictFDerivAt  f  (f'  :  E  â†’L[ğ•œ]  F)  a)  :\n  âˆ€á¶   x  in  ğ“  a,  hf.localInverse  f  f'  a  (f  x)  =  x  :=\n  hf.eventually_left_inverse\n\nexample  (hf  :  HasStrictFDerivAt  f  (f'  :  E  â†’L[ğ•œ]  F)  a)  :\n  âˆ€á¶   x  in  ğ“  (f  a),  f  (hf.localInverse  f  f'  a  x)  =  x  :=\n  hf.eventually_right_inverse\n\nexample  {f  :  E  â†’  F}  {f'  :  E  â‰ƒL[ğ•œ]  F}  {a  :  E}\n  (hf  :  HasStrictFDerivAt  f  (f'  :  E  â†’L[ğ•œ]  F)  a)  :\n  HasStrictFDerivAt  (HasStrictFDerivAt.localInverse  f  f'  a  hf)  (f'.symm  :  F  â†’L[ğ•œ]  E)  (f  a)  :=\n  HasStrictFDerivAt.to_localInverse  hf\n\nend  LocalInverse \n```", "```py\nopen  Real\n\n/-- The sin function has derivative 1 at 0\\. -/\nexample  :  HasDerivAt  sin  1  0  :=  by  simpa  using  hasDerivAt_sin  0 \n```", "```py\nexample  (x  :  â„)  :  DifferentiableAt  â„  sin  x  :=\n  (hasDerivAt_sin  x).differentiableAt \n```", "```py\nexample  {f  :  â„  â†’  â„}  {x  a  :  â„}  (h  :  HasDerivAt  f  a  x)  :  deriv  f  x  =  a  :=\n  h.deriv\n\nexample  {f  :  â„  â†’  â„}  {x  :  â„}  (h  :  Â¬DifferentiableAt  â„  f  x)  :  deriv  f  x  =  0  :=\n  deriv_zero_of_not_differentiableAt  h \n```", "```py\nexample  {f  g  :  â„  â†’  â„}  {x  :  â„}  (hf  :  DifferentiableAt  â„  f  x)  (hg  :  DifferentiableAt  â„  g  x)  :\n  deriv  (f  +  g)  x  =  deriv  f  x  +  deriv  g  x  :=\n  deriv_add  hf  hg \n```", "```py\nexample  {f  :  â„  â†’  â„}  {a  :  â„}  (h  :  IsLocalMin  f  a)  :  deriv  f  a  =  0  :=\n  h.deriv_eq_zero \n```", "```py\nopen  Set\n\nexample  {f  :  â„  â†’  â„}  {a  b  :  â„}  (hab  :  a  <  b)  (hfc  :  ContinuousOn  f  (Icc  a  b))  (hfI  :  f  a  =  f  b)  :\n  âˆƒ  c  âˆˆ  Ioo  a  b,  deriv  f  c  =  0  :=\n  exists_deriv_eq_zero  hab  hfc  hfI \n```", "```py\nexample  (f  :  â„  â†’  â„)  {a  b  :  â„}  (hab  :  a  <  b)  (hf  :  ContinuousOn  f  (Icc  a  b))\n  (hf'  :  DifferentiableOn  â„  f  (Ioo  a  b))  :  âˆƒ  c  âˆˆ  Ioo  a  b,  deriv  f  c  =  (f  b  -  f  a)  /  (b  -  a)  :=\n  exists_deriv_eq_slope  f  hab  hf  hf' \n```", "```py\nexample  :  deriv  (fun  x  :  â„  â†¦  x  ^  5)  6  =  5  *  6  ^  4  :=  by  simp\n\nexample  :  deriv  sin  Ï€  =  -1  :=  by  simp \n```", "```py\nvariable  {E  :  Type*}  [NormedAddCommGroup  E]\n\nexample  (x  :  E)  :  0  â‰¤  â€–xâ€–  :=\n  norm_nonneg  x\n\nexample  {x  :  E}  :  â€–xâ€–  =  0  â†”  x  =  0  :=\n  norm_eq_zero\n\nexample  (x  y  :  E)  :  â€–x  +  yâ€–  â‰¤  â€–xâ€–  +  â€–yâ€–  :=\n  norm_add_le  x  y \n```", "```py\nexample  :  MetricSpace  E  :=  by  infer_instance\n\nexample  {X  :  Type*}  [TopologicalSpace  X]  {f  :  X  â†’  E}  (hf  :  Continuous  f)  :\n  Continuous  fun  x  â†¦  â€–f  xâ€–  :=\n  hf.norm \n```", "```py\nvariable  [NormedSpace  â„  E]\n\nexample  (a  :  â„)  (x  :  E)  :  â€–a  â€¢  xâ€–  =  |a|  *  â€–xâ€–  :=\n  norm_smul  a  x \n```", "```py\nexample  [FiniteDimensional  â„  E]  :  CompleteSpace  E  :=  by  infer_instance \n```", "```py\nexample  (ğ•œ  :  Type*)  [NontriviallyNormedField  ğ•œ]  (x  y  :  ğ•œ)  :  â€–x  *  yâ€–  =  â€–xâ€–  *  â€–yâ€–  :=\n  norm_mul  x  y\n\nexample  (ğ•œ  :  Type*)  [NontriviallyNormedField  ğ•œ]  :  âˆƒ  x  :  ğ•œ,  1  <  â€–xâ€–  :=\n  NormedField.exists_one_lt_norm  ğ•œ \n```", "```py\nexample  (ğ•œ  :  Type*)  [NontriviallyNormedField  ğ•œ]  (E  :  Type*)  [NormedAddCommGroup  E]\n  [NormedSpace  ğ•œ  E]  [CompleteSpace  ğ•œ]  [FiniteDimensional  ğ•œ  E]  :  CompleteSpace  E  :=\n  FiniteDimensional.complete  ğ•œ  E \n```", "```py\nvariable  {ğ•œ  :  Type*}  [NontriviallyNormedField  ğ•œ]  {E  :  Type*}  [NormedAddCommGroup  E]\n  [NormedSpace  ğ•œ  E]  {F  :  Type*}  [NormedAddCommGroup  F]  [NormedSpace  ğ•œ  F]\n\nexample  :  E  â†’L[ğ•œ]  E  :=\n  ContinuousLinearMap.id  ğ•œ  E\n\nexample  (f  :  E  â†’L[ğ•œ]  F)  :  E  â†’  F  :=\n  f\n\nexample  (f  :  E  â†’L[ğ•œ]  F)  :  Continuous  f  :=\n  f.cont\n\nexample  (f  :  E  â†’L[ğ•œ]  F)  (x  y  :  E)  :  f  (x  +  y)  =  f  x  +  f  y  :=\n  f.map_add  x  y\n\nexample  (f  :  E  â†’L[ğ•œ]  F)  (a  :  ğ•œ)  (x  :  E)  :  f  (a  â€¢  x)  =  a  â€¢  f  x  :=\n  f.map_smul  a  x \n```", "```py\nvariable  (f  :  E  â†’L[ğ•œ]  F)\n\nexample  (x  :  E)  :  â€–f  xâ€–  â‰¤  â€–fâ€–  *  â€–xâ€–  :=\n  f.le_opNorm  x\n\nexample  {M  :  â„}  (hMp  :  0  â‰¤  M)  (hM  :  âˆ€  x,  â€–f  xâ€–  â‰¤  M  *  â€–xâ€–)  :  â€–fâ€–  â‰¤  M  :=\n  f.opNorm_le_bound  hMp  hM \n```", "```py\nvariable  {ğ•œ  :  Type*}  [NontriviallyNormedField  ğ•œ]  {E  :  Type*}  [NormedAddCommGroup  E]\n  [NormedSpace  ğ•œ  E]  {F  :  Type*}  [NormedAddCommGroup  F]  [NormedSpace  ğ•œ  F]\n\nopen  Metric\n\nexample  {Î¹  :  Type*}  [CompleteSpace  E]  {g  :  Î¹  â†’  E  â†’L[ğ•œ]  F}  (h  :  âˆ€  x,  âˆƒ  C,  âˆ€  i,  â€–g  i  xâ€–  â‰¤  C)  :\n  âˆƒ  C',  âˆ€  i,  â€–g  iâ€–  â‰¤  C'  :=  by\n  -- sequence of subsets consisting of those `x : E` with norms `â€–g i xâ€–` bounded by `n`\n  let  e  :  â„•  â†’  Set  E  :=  fun  n  â†¦  â‹‚  i  :  Î¹,  {  x  :  E  |  â€–g  i  xâ€–  â‰¤  n  }\n  -- each of these sets is closed\n  have  hc  :  âˆ€  n  :  â„•,  IsClosed  (e  n)\n  sorry\n  -- the union is the entire space; this is where we use `h`\n  have  hU  :  (â‹ƒ  n  :  â„•,  e  n)  =  univ\n  sorry\n  /- apply the Baire category theorem to conclude that for some `m : â„•`,\n `e m` contains some `x` -/\n  obtain  âŸ¨m,  x,  hxâŸ©  :  âˆƒ  m,  âˆƒ  x,  x  âˆˆ  interior  (e  m)  :=  sorry\n  obtain  âŸ¨Îµ,  Îµ_pos,  hÎµâŸ©  :  âˆƒ  Îµ  >  0,  ball  x  Îµ  âŠ†  interior  (e  m)  :=  sorry\n  obtain  âŸ¨k,  hkâŸ©  :  âˆƒ  k  :  ğ•œ,  1  <  â€–kâ€–  :=  sorry\n  -- show all elements in the ball have norm bounded by `m` after applying any `g i`\n  have  real_norm_le  :  âˆ€  z  âˆˆ  ball  x  Îµ,  âˆ€  (i  :  Î¹),  â€–g  i  zâ€–  â‰¤  m\n  sorry\n  have  Îµk_pos  :  0  <  Îµ  /  â€–kâ€–  :=  sorry\n  refine  âŸ¨(m  +  m  :  â„•)  /  (Îµ  /  â€–kâ€–),  fun  i  â†¦  ContinuousLinearMap.opNorm_le_of_shell  Îµ_pos  ?_  hk  ?_âŸ©\n  sorry\n  sorry \n```", "```py\nopen  Asymptotics\n\nexample  {Î±  :  Type*}  {E  :  Type*}  [NormedGroup  E]  {F  :  Type*}  [NormedGroup  F]  (c  :  â„)\n  (l  :  Filter  Î±)  (f  :  Î±  â†’  E)  (g  :  Î±  â†’  F)  :  IsBigOWith  c  l  f  g  â†”  âˆ€á¶   x  in  l,  â€–f  xâ€–  â‰¤  c  *  â€–g  xâ€–  :=\n  isBigOWith_iff\n\nexample  {Î±  :  Type*}  {E  :  Type*}  [NormedGroup  E]  {F  :  Type*}  [NormedGroup  F]\n  (l  :  Filter  Î±)  (f  :  Î±  â†’  E)  (g  :  Î±  â†’  F)  :  f  =O[l]  g  â†”  âˆƒ  C,  IsBigOWith  C  l  f  g  :=\n  isBigO_iff_isBigOWith\n\nexample  {Î±  :  Type*}  {E  :  Type*}  [NormedGroup  E]  {F  :  Type*}  [NormedGroup  F]\n  (l  :  Filter  Î±)  (f  :  Î±  â†’  E)  (g  :  Î±  â†’  F)  :  f  =o[l]  g  â†”  âˆ€  C  >  0,  IsBigOWith  C  l  f  g  :=\n  isLittleO_iff_forall_isBigOWith\n\nexample  {Î±  :  Type*}  {E  :  Type*}  [NormedAddCommGroup  E]  (l  :  Filter  Î±)  (f  g  :  Î±  â†’  E)  :\n  f  ~[l]  g  â†”  (f  -  g)  =o[l]  g  :=\n  Iff.rfl \n```", "```py\nopen  Topology\n\nvariable  {ğ•œ  :  Type*}  [NontriviallyNormedField  ğ•œ]  {E  :  Type*}  [NormedAddCommGroup  E]\n  [NormedSpace  ğ•œ  E]  {F  :  Type*}  [NormedAddCommGroup  F]  [NormedSpace  ğ•œ  F]\n\nexample  (f  :  E  â†’  F)  (f'  :  E  â†’L[ğ•œ]  F)  (xâ‚€  :  E)  :\n  HasFDerivAt  f  f'  xâ‚€  â†”  (fun  x  â†¦  f  x  -  f  xâ‚€  -  f'  (x  -  xâ‚€))  =o[ğ“  xâ‚€]  fun  x  â†¦  x  -  xâ‚€  :=\n  hasFDerivAtFilter_iff_isLittleO  ..\n\nexample  (f  :  E  â†’  F)  (f'  :  E  â†’L[ğ•œ]  F)  (xâ‚€  :  E)  (hff'  :  HasFDerivAt  f  f'  xâ‚€)  :  fderiv  ğ•œ  f  xâ‚€  =  f'  :=\n  hff'.fderiv \n```", "```py\nexample  (n  :  â„•)  (f  :  E  â†’  F)  :  E  â†’  E[Ã—n]â†’L[ğ•œ]  F  :=\n  iteratedFDeriv  ğ•œ  n  f\n\nexample  (n  :  â„•âˆ)  {f  :  E  â†’  F}  :\n  ContDiff  ğ•œ  n  f  â†”\n  (âˆ€  m  :  â„•,  (m  :  WithTop  â„•)  â‰¤  n  â†’  Continuous  fun  x  â†¦  iteratedFDeriv  ğ•œ  m  f  x)  âˆ§\n  âˆ€  m  :  â„•,  (m  :  WithTop  â„•)  <  n  â†’  Differentiable  ğ•œ  fun  x  â†¦  iteratedFDeriv  ğ•œ  m  f  x  :=\n  contDiff_iff_continuous_differentiable \n```", "```py\nexample  {ğ•‚  :  Type*}  [RCLike  ğ•‚]  {E  :  Type*}  [NormedAddCommGroup  E]  [NormedSpace  ğ•‚  E]  {F  :  Type*}\n  [NormedAddCommGroup  F]  [NormedSpace  ğ•‚  F]  {f  :  E  â†’  F}  {x  :  E}  {n  :  WithTop  â„•âˆ}\n  (hf  :  ContDiffAt  ğ•‚  n  f  x)  (hn  :  1  â‰¤  n)  :  HasStrictFDerivAt  f  (fderiv  ğ•‚  f  x)  x  :=\n  hf.hasStrictFDerivAt  hn \n```", "```py\nsection  LocalInverse\nvariable  [CompleteSpace  E]  {f  :  E  â†’  F}  {f'  :  E  â‰ƒL[ğ•œ]  F}  {a  :  E}\n\nexample  (hf  :  HasStrictFDerivAt  f  (f'  :  E  â†’L[ğ•œ]  F)  a)  :  F  â†’  E  :=\n  HasStrictFDerivAt.localInverse  f  f'  a  hf\n\nexample  (hf  :  HasStrictFDerivAt  f  (f'  :  E  â†’L[ğ•œ]  F)  a)  :\n  âˆ€á¶   x  in  ğ“  a,  hf.localInverse  f  f'  a  (f  x)  =  x  :=\n  hf.eventually_left_inverse\n\nexample  (hf  :  HasStrictFDerivAt  f  (f'  :  E  â†’L[ğ•œ]  F)  a)  :\n  âˆ€á¶   x  in  ğ“  (f  a),  f  (hf.localInverse  f  f'  a  x)  =  x  :=\n  hf.eventually_right_inverse\n\nexample  {f  :  E  â†’  F}  {f'  :  E  â‰ƒL[ğ•œ]  F}  {a  :  E}\n  (hf  :  HasStrictFDerivAt  f  (f'  :  E  â†’L[ğ•œ]  F)  a)  :\n  HasStrictFDerivAt  (HasStrictFDerivAt.localInverse  f  f'  a  hf)  (f'.symm  :  F  â†’L[ğ•œ]  E)  (f  a)  :=\n  HasStrictFDerivAt.to_localInverse  hf\n\nend  LocalInverse \n```", "```py\nopen  Real\n\n/-- The sin function has derivative 1 at 0\\. -/\nexample  :  HasDerivAt  sin  1  0  :=  by  simpa  using  hasDerivAt_sin  0 \n```", "```py\nexample  (x  :  â„)  :  DifferentiableAt  â„  sin  x  :=\n  (hasDerivAt_sin  x).differentiableAt \n```", "```py\nexample  {f  :  â„  â†’  â„}  {x  a  :  â„}  (h  :  HasDerivAt  f  a  x)  :  deriv  f  x  =  a  :=\n  h.deriv\n\nexample  {f  :  â„  â†’  â„}  {x  :  â„}  (h  :  Â¬DifferentiableAt  â„  f  x)  :  deriv  f  x  =  0  :=\n  deriv_zero_of_not_differentiableAt  h \n```", "```py\nexample  {f  g  :  â„  â†’  â„}  {x  :  â„}  (hf  :  DifferentiableAt  â„  f  x)  (hg  :  DifferentiableAt  â„  g  x)  :\n  deriv  (f  +  g)  x  =  deriv  f  x  +  deriv  g  x  :=\n  deriv_add  hf  hg \n```", "```py\nexample  {f  :  â„  â†’  â„}  {a  :  â„}  (h  :  IsLocalMin  f  a)  :  deriv  f  a  =  0  :=\n  h.deriv_eq_zero \n```", "```py\nopen  Set\n\nexample  {f  :  â„  â†’  â„}  {a  b  :  â„}  (hab  :  a  <  b)  (hfc  :  ContinuousOn  f  (Icc  a  b))  (hfI  :  f  a  =  f  b)  :\n  âˆƒ  c  âˆˆ  Ioo  a  b,  deriv  f  c  =  0  :=\n  exists_deriv_eq_zero  hab  hfc  hfI \n```", "```py\nexample  (f  :  â„  â†’  â„)  {a  b  :  â„}  (hab  :  a  <  b)  (hf  :  ContinuousOn  f  (Icc  a  b))\n  (hf'  :  DifferentiableOn  â„  f  (Ioo  a  b))  :  âˆƒ  c  âˆˆ  Ioo  a  b,  deriv  f  c  =  (f  b  -  f  a)  /  (b  -  a)  :=\n  exists_deriv_eq_slope  f  hab  hf  hf' \n```", "```py\nexample  :  deriv  (fun  x  :  â„  â†¦  x  ^  5)  6  =  5  *  6  ^  4  :=  by  simp\n\nexample  :  deriv  sin  Ï€  =  -1  :=  by  simp \n```", "```py\nvariable  {E  :  Type*}  [NormedAddCommGroup  E]\n\nexample  (x  :  E)  :  0  â‰¤  â€–xâ€–  :=\n  norm_nonneg  x\n\nexample  {x  :  E}  :  â€–xâ€–  =  0  â†”  x  =  0  :=\n  norm_eq_zero\n\nexample  (x  y  :  E)  :  â€–x  +  yâ€–  â‰¤  â€–xâ€–  +  â€–yâ€–  :=\n  norm_add_le  x  y \n```", "```py\nexample  :  MetricSpace  E  :=  by  infer_instance\n\nexample  {X  :  Type*}  [TopologicalSpace  X]  {f  :  X  â†’  E}  (hf  :  Continuous  f)  :\n  Continuous  fun  x  â†¦  â€–f  xâ€–  :=\n  hf.norm \n```", "```py\nvariable  [NormedSpace  â„  E]\n\nexample  (a  :  â„)  (x  :  E)  :  â€–a  â€¢  xâ€–  =  |a|  *  â€–xâ€–  :=\n  norm_smul  a  x \n```", "```py\nexample  [FiniteDimensional  â„  E]  :  CompleteSpace  E  :=  by  infer_instance \n```", "```py\nexample  (ğ•œ  :  Type*)  [NontriviallyNormedField  ğ•œ]  (x  y  :  ğ•œ)  :  â€–x  *  yâ€–  =  â€–xâ€–  *  â€–yâ€–  :=\n  norm_mul  x  y\n\nexample  (ğ•œ  :  Type*)  [NontriviallyNormedField  ğ•œ]  :  âˆƒ  x  :  ğ•œ,  1  <  â€–xâ€–  :=\n  NormedField.exists_one_lt_norm  ğ•œ \n```", "```py\nexample  (ğ•œ  :  Type*)  [NontriviallyNormedField  ğ•œ]  (E  :  Type*)  [NormedAddCommGroup  E]\n  [NormedSpace  ğ•œ  E]  [CompleteSpace  ğ•œ]  [FiniteDimensional  ğ•œ  E]  :  CompleteSpace  E  :=\n  FiniteDimensional.complete  ğ•œ  E \n```", "```py\nvariable  {ğ•œ  :  Type*}  [NontriviallyNormedField  ğ•œ]  {E  :  Type*}  [NormedAddCommGroup  E]\n  [NormedSpace  ğ•œ  E]  {F  :  Type*}  [NormedAddCommGroup  F]  [NormedSpace  ğ•œ  F]\n\nexample  :  E  â†’L[ğ•œ]  E  :=\n  ContinuousLinearMap.id  ğ•œ  E\n\nexample  (f  :  E  â†’L[ğ•œ]  F)  :  E  â†’  F  :=\n  f\n\nexample  (f  :  E  â†’L[ğ•œ]  F)  :  Continuous  f  :=\n  f.cont\n\nexample  (f  :  E  â†’L[ğ•œ]  F)  (x  y  :  E)  :  f  (x  +  y)  =  f  x  +  f  y  :=\n  f.map_add  x  y\n\nexample  (f  :  E  â†’L[ğ•œ]  F)  (a  :  ğ•œ)  (x  :  E)  :  f  (a  â€¢  x)  =  a  â€¢  f  x  :=\n  f.map_smul  a  x \n```", "```py\nvariable  (f  :  E  â†’L[ğ•œ]  F)\n\nexample  (x  :  E)  :  â€–f  xâ€–  â‰¤  â€–fâ€–  *  â€–xâ€–  :=\n  f.le_opNorm  x\n\nexample  {M  :  â„}  (hMp  :  0  â‰¤  M)  (hM  :  âˆ€  x,  â€–f  xâ€–  â‰¤  M  *  â€–xâ€–)  :  â€–fâ€–  â‰¤  M  :=\n  f.opNorm_le_bound  hMp  hM \n```", "```py\nvariable  {ğ•œ  :  Type*}  [NontriviallyNormedField  ğ•œ]  {E  :  Type*}  [NormedAddCommGroup  E]\n  [NormedSpace  ğ•œ  E]  {F  :  Type*}  [NormedAddCommGroup  F]  [NormedSpace  ğ•œ  F]\n\nopen  Metric\n\nexample  {Î¹  :  Type*}  [CompleteSpace  E]  {g  :  Î¹  â†’  E  â†’L[ğ•œ]  F}  (h  :  âˆ€  x,  âˆƒ  C,  âˆ€  i,  â€–g  i  xâ€–  â‰¤  C)  :\n  âˆƒ  C',  âˆ€  i,  â€–g  iâ€–  â‰¤  C'  :=  by\n  -- sequence of subsets consisting of those `x : E` with norms `â€–g i xâ€–` bounded by `n`\n  let  e  :  â„•  â†’  Set  E  :=  fun  n  â†¦  â‹‚  i  :  Î¹,  {  x  :  E  |  â€–g  i  xâ€–  â‰¤  n  }\n  -- each of these sets is closed\n  have  hc  :  âˆ€  n  :  â„•,  IsClosed  (e  n)\n  sorry\n  -- the union is the entire space; this is where we use `h`\n  have  hU  :  (â‹ƒ  n  :  â„•,  e  n)  =  univ\n  sorry\n  /- apply the Baire category theorem to conclude that for some `m : â„•`,\n `e m` contains some `x` -/\n  obtain  âŸ¨m,  x,  hxâŸ©  :  âˆƒ  m,  âˆƒ  x,  x  âˆˆ  interior  (e  m)  :=  sorry\n  obtain  âŸ¨Îµ,  Îµ_pos,  hÎµâŸ©  :  âˆƒ  Îµ  >  0,  ball  x  Îµ  âŠ†  interior  (e  m)  :=  sorry\n  obtain  âŸ¨k,  hkâŸ©  :  âˆƒ  k  :  ğ•œ,  1  <  â€–kâ€–  :=  sorry\n  -- show all elements in the ball have norm bounded by `m` after applying any `g i`\n  have  real_norm_le  :  âˆ€  z  âˆˆ  ball  x  Îµ,  âˆ€  (i  :  Î¹),  â€–g  i  zâ€–  â‰¤  m\n  sorry\n  have  Îµk_pos  :  0  <  Îµ  /  â€–kâ€–  :=  sorry\n  refine  âŸ¨(m  +  m  :  â„•)  /  (Îµ  /  â€–kâ€–),  fun  i  â†¦  ContinuousLinearMap.opNorm_le_of_shell  Îµ_pos  ?_  hk  ?_âŸ©\n  sorry\n  sorry \n```", "```py\nopen  Asymptotics\n\nexample  {Î±  :  Type*}  {E  :  Type*}  [NormedGroup  E]  {F  :  Type*}  [NormedGroup  F]  (c  :  â„)\n  (l  :  Filter  Î±)  (f  :  Î±  â†’  E)  (g  :  Î±  â†’  F)  :  IsBigOWith  c  l  f  g  â†”  âˆ€á¶   x  in  l,  â€–f  xâ€–  â‰¤  c  *  â€–g  xâ€–  :=\n  isBigOWith_iff\n\nexample  {Î±  :  Type*}  {E  :  Type*}  [NormedGroup  E]  {F  :  Type*}  [NormedGroup  F]\n  (l  :  Filter  Î±)  (f  :  Î±  â†’  E)  (g  :  Î±  â†’  F)  :  f  =O[l]  g  â†”  âˆƒ  C,  IsBigOWith  C  l  f  g  :=\n  isBigO_iff_isBigOWith\n\nexample  {Î±  :  Type*}  {E  :  Type*}  [NormedGroup  E]  {F  :  Type*}  [NormedGroup  F]\n  (l  :  Filter  Î±)  (f  :  Î±  â†’  E)  (g  :  Î±  â†’  F)  :  f  =o[l]  g  â†”  âˆ€  C  >  0,  IsBigOWith  C  l  f  g  :=\n  isLittleO_iff_forall_isBigOWith\n\nexample  {Î±  :  Type*}  {E  :  Type*}  [NormedAddCommGroup  E]  (l  :  Filter  Î±)  (f  g  :  Î±  â†’  E)  :\n  f  ~[l]  g  â†”  (f  -  g)  =o[l]  g  :=\n  Iff.rfl \n```", "```py\nopen  Topology\n\nvariable  {ğ•œ  :  Type*}  [NontriviallyNormedField  ğ•œ]  {E  :  Type*}  [NormedAddCommGroup  E]\n  [NormedSpace  ğ•œ  E]  {F  :  Type*}  [NormedAddCommGroup  F]  [NormedSpace  ğ•œ  F]\n\nexample  (f  :  E  â†’  F)  (f'  :  E  â†’L[ğ•œ]  F)  (xâ‚€  :  E)  :\n  HasFDerivAt  f  f'  xâ‚€  â†”  (fun  x  â†¦  f  x  -  f  xâ‚€  -  f'  (x  -  xâ‚€))  =o[ğ“  xâ‚€]  fun  x  â†¦  x  -  xâ‚€  :=\n  hasFDerivAtFilter_iff_isLittleO  ..\n\nexample  (f  :  E  â†’  F)  (f'  :  E  â†’L[ğ•œ]  F)  (xâ‚€  :  E)  (hff'  :  HasFDerivAt  f  f'  xâ‚€)  :  fderiv  ğ•œ  f  xâ‚€  =  f'  :=\n  hff'.fderiv \n```", "```py\nexample  (n  :  â„•)  (f  :  E  â†’  F)  :  E  â†’  E[Ã—n]â†’L[ğ•œ]  F  :=\n  iteratedFDeriv  ğ•œ  n  f\n\nexample  (n  :  â„•âˆ)  {f  :  E  â†’  F}  :\n  ContDiff  ğ•œ  n  f  â†”\n  (âˆ€  m  :  â„•,  (m  :  WithTop  â„•)  â‰¤  n  â†’  Continuous  fun  x  â†¦  iteratedFDeriv  ğ•œ  m  f  x)  âˆ§\n  âˆ€  m  :  â„•,  (m  :  WithTop  â„•)  <  n  â†’  Differentiable  ğ•œ  fun  x  â†¦  iteratedFDeriv  ğ•œ  m  f  x  :=\n  contDiff_iff_continuous_differentiable \n```", "```py\nexample  {ğ•‚  :  Type*}  [RCLike  ğ•‚]  {E  :  Type*}  [NormedAddCommGroup  E]  [NormedSpace  ğ•‚  E]  {F  :  Type*}\n  [NormedAddCommGroup  F]  [NormedSpace  ğ•‚  F]  {f  :  E  â†’  F}  {x  :  E}  {n  :  WithTop  â„•âˆ}\n  (hf  :  ContDiffAt  ğ•‚  n  f  x)  (hn  :  1  â‰¤  n)  :  HasStrictFDerivAt  f  (fderiv  ğ•‚  f  x)  x  :=\n  hf.hasStrictFDerivAt  hn \n```", "```py\nsection  LocalInverse\nvariable  [CompleteSpace  E]  {f  :  E  â†’  F}  {f'  :  E  â‰ƒL[ğ•œ]  F}  {a  :  E}\n\nexample  (hf  :  HasStrictFDerivAt  f  (f'  :  E  â†’L[ğ•œ]  F)  a)  :  F  â†’  E  :=\n  HasStrictFDerivAt.localInverse  f  f'  a  hf\n\nexample  (hf  :  HasStrictFDerivAt  f  (f'  :  E  â†’L[ğ•œ]  F)  a)  :\n  âˆ€á¶   x  in  ğ“  a,  hf.localInverse  f  f'  a  (f  x)  =  x  :=\n  hf.eventually_left_inverse\n\nexample  (hf  :  HasStrictFDerivAt  f  (f'  :  E  â†’L[ğ•œ]  F)  a)  :\n  âˆ€á¶   x  in  ğ“  (f  a),  f  (hf.localInverse  f  f'  a  x)  =  x  :=\n  hf.eventually_right_inverse\n\nexample  {f  :  E  â†’  F}  {f'  :  E  â‰ƒL[ğ•œ]  F}  {a  :  E}\n  (hf  :  HasStrictFDerivAt  f  (f'  :  E  â†’L[ğ•œ]  F)  a)  :\n  HasStrictFDerivAt  (HasStrictFDerivAt.localInverse  f  f'  a  hf)  (f'.symm  :  F  â†’L[ğ•œ]  E)  (f  a)  :=\n  HasStrictFDerivAt.to_localInverse  hf\n\nend  LocalInverse \n```", "```py\nvariable  {E  :  Type*}  [NormedAddCommGroup  E]\n\nexample  (x  :  E)  :  0  â‰¤  â€–xâ€–  :=\n  norm_nonneg  x\n\nexample  {x  :  E}  :  â€–xâ€–  =  0  â†”  x  =  0  :=\n  norm_eq_zero\n\nexample  (x  y  :  E)  :  â€–x  +  yâ€–  â‰¤  â€–xâ€–  +  â€–yâ€–  :=\n  norm_add_le  x  y \n```", "```py\nexample  :  MetricSpace  E  :=  by  infer_instance\n\nexample  {X  :  Type*}  [TopologicalSpace  X]  {f  :  X  â†’  E}  (hf  :  Continuous  f)  :\n  Continuous  fun  x  â†¦  â€–f  xâ€–  :=\n  hf.norm \n```", "```py\nvariable  [NormedSpace  â„  E]\n\nexample  (a  :  â„)  (x  :  E)  :  â€–a  â€¢  xâ€–  =  |a|  *  â€–xâ€–  :=\n  norm_smul  a  x \n```", "```py\nexample  [FiniteDimensional  â„  E]  :  CompleteSpace  E  :=  by  infer_instance \n```", "```py\nexample  (ğ•œ  :  Type*)  [NontriviallyNormedField  ğ•œ]  (x  y  :  ğ•œ)  :  â€–x  *  yâ€–  =  â€–xâ€–  *  â€–yâ€–  :=\n  norm_mul  x  y\n\nexample  (ğ•œ  :  Type*)  [NontriviallyNormedField  ğ•œ]  :  âˆƒ  x  :  ğ•œ,  1  <  â€–xâ€–  :=\n  NormedField.exists_one_lt_norm  ğ•œ \n```", "```py\nexample  (ğ•œ  :  Type*)  [NontriviallyNormedField  ğ•œ]  (E  :  Type*)  [NormedAddCommGroup  E]\n  [NormedSpace  ğ•œ  E]  [CompleteSpace  ğ•œ]  [FiniteDimensional  ğ•œ  E]  :  CompleteSpace  E  :=\n  FiniteDimensional.complete  ğ•œ  E \n```", "```py\nvariable  {ğ•œ  :  Type*}  [NontriviallyNormedField  ğ•œ]  {E  :  Type*}  [NormedAddCommGroup  E]\n  [NormedSpace  ğ•œ  E]  {F  :  Type*}  [NormedAddCommGroup  F]  [NormedSpace  ğ•œ  F]\n\nexample  :  E  â†’L[ğ•œ]  E  :=\n  ContinuousLinearMap.id  ğ•œ  E\n\nexample  (f  :  E  â†’L[ğ•œ]  F)  :  E  â†’  F  :=\n  f\n\nexample  (f  :  E  â†’L[ğ•œ]  F)  :  Continuous  f  :=\n  f.cont\n\nexample  (f  :  E  â†’L[ğ•œ]  F)  (x  y  :  E)  :  f  (x  +  y)  =  f  x  +  f  y  :=\n  f.map_add  x  y\n\nexample  (f  :  E  â†’L[ğ•œ]  F)  (a  :  ğ•œ)  (x  :  E)  :  f  (a  â€¢  x)  =  a  â€¢  f  x  :=\n  f.map_smul  a  x \n```", "```py\nvariable  (f  :  E  â†’L[ğ•œ]  F)\n\nexample  (x  :  E)  :  â€–f  xâ€–  â‰¤  â€–fâ€–  *  â€–xâ€–  :=\n  f.le_opNorm  x\n\nexample  {M  :  â„}  (hMp  :  0  â‰¤  M)  (hM  :  âˆ€  x,  â€–f  xâ€–  â‰¤  M  *  â€–xâ€–)  :  â€–fâ€–  â‰¤  M  :=\n  f.opNorm_le_bound  hMp  hM \n```", "```py\nvariable  {ğ•œ  :  Type*}  [NontriviallyNormedField  ğ•œ]  {E  :  Type*}  [NormedAddCommGroup  E]\n  [NormedSpace  ğ•œ  E]  {F  :  Type*}  [NormedAddCommGroup  F]  [NormedSpace  ğ•œ  F]\n\nopen  Metric\n\nexample  {Î¹  :  Type*}  [CompleteSpace  E]  {g  :  Î¹  â†’  E  â†’L[ğ•œ]  F}  (h  :  âˆ€  x,  âˆƒ  C,  âˆ€  i,  â€–g  i  xâ€–  â‰¤  C)  :\n  âˆƒ  C',  âˆ€  i,  â€–g  iâ€–  â‰¤  C'  :=  by\n  -- sequence of subsets consisting of those `x : E` with norms `â€–g i xâ€–` bounded by `n`\n  let  e  :  â„•  â†’  Set  E  :=  fun  n  â†¦  â‹‚  i  :  Î¹,  {  x  :  E  |  â€–g  i  xâ€–  â‰¤  n  }\n  -- each of these sets is closed\n  have  hc  :  âˆ€  n  :  â„•,  IsClosed  (e  n)\n  sorry\n  -- the union is the entire space; this is where we use `h`\n  have  hU  :  (â‹ƒ  n  :  â„•,  e  n)  =  univ\n  sorry\n  /- apply the Baire category theorem to conclude that for some `m : â„•`,\n `e m` contains some `x` -/\n  obtain  âŸ¨m,  x,  hxâŸ©  :  âˆƒ  m,  âˆƒ  x,  x  âˆˆ  interior  (e  m)  :=  sorry\n  obtain  âŸ¨Îµ,  Îµ_pos,  hÎµâŸ©  :  âˆƒ  Îµ  >  0,  ball  x  Îµ  âŠ†  interior  (e  m)  :=  sorry\n  obtain  âŸ¨k,  hkâŸ©  :  âˆƒ  k  :  ğ•œ,  1  <  â€–kâ€–  :=  sorry\n  -- show all elements in the ball have norm bounded by `m` after applying any `g i`\n  have  real_norm_le  :  âˆ€  z  âˆˆ  ball  x  Îµ,  âˆ€  (i  :  Î¹),  â€–g  i  zâ€–  â‰¤  m\n  sorry\n  have  Îµk_pos  :  0  <  Îµ  /  â€–kâ€–  :=  sorry\n  refine  âŸ¨(m  +  m  :  â„•)  /  (Îµ  /  â€–kâ€–),  fun  i  â†¦  ContinuousLinearMap.opNorm_le_of_shell  Îµ_pos  ?_  hk  ?_âŸ©\n  sorry\n  sorry \n```", "```py\nopen  Asymptotics\n\nexample  {Î±  :  Type*}  {E  :  Type*}  [NormedGroup  E]  {F  :  Type*}  [NormedGroup  F]  (c  :  â„)\n  (l  :  Filter  Î±)  (f  :  Î±  â†’  E)  (g  :  Î±  â†’  F)  :  IsBigOWith  c  l  f  g  â†”  âˆ€á¶   x  in  l,  â€–f  xâ€–  â‰¤  c  *  â€–g  xâ€–  :=\n  isBigOWith_iff\n\nexample  {Î±  :  Type*}  {E  :  Type*}  [NormedGroup  E]  {F  :  Type*}  [NormedGroup  F]\n  (l  :  Filter  Î±)  (f  :  Î±  â†’  E)  (g  :  Î±  â†’  F)  :  f  =O[l]  g  â†”  âˆƒ  C,  IsBigOWith  C  l  f  g  :=\n  isBigO_iff_isBigOWith\n\nexample  {Î±  :  Type*}  {E  :  Type*}  [NormedGroup  E]  {F  :  Type*}  [NormedGroup  F]\n  (l  :  Filter  Î±)  (f  :  Î±  â†’  E)  (g  :  Î±  â†’  F)  :  f  =o[l]  g  â†”  âˆ€  C  >  0,  IsBigOWith  C  l  f  g  :=\n  isLittleO_iff_forall_isBigOWith\n\nexample  {Î±  :  Type*}  {E  :  Type*}  [NormedAddCommGroup  E]  (l  :  Filter  Î±)  (f  g  :  Î±  â†’  E)  :\n  f  ~[l]  g  â†”  (f  -  g)  =o[l]  g  :=\n  Iff.rfl \n```", "```py\nopen  Topology\n\nvariable  {ğ•œ  :  Type*}  [NontriviallyNormedField  ğ•œ]  {E  :  Type*}  [NormedAddCommGroup  E]\n  [NormedSpace  ğ•œ  E]  {F  :  Type*}  [NormedAddCommGroup  F]  [NormedSpace  ğ•œ  F]\n\nexample  (f  :  E  â†’  F)  (f'  :  E  â†’L[ğ•œ]  F)  (xâ‚€  :  E)  :\n  HasFDerivAt  f  f'  xâ‚€  â†”  (fun  x  â†¦  f  x  -  f  xâ‚€  -  f'  (x  -  xâ‚€))  =o[ğ“  xâ‚€]  fun  x  â†¦  x  -  xâ‚€  :=\n  hasFDerivAtFilter_iff_isLittleO  ..\n\nexample  (f  :  E  â†’  F)  (f'  :  E  â†’L[ğ•œ]  F)  (xâ‚€  :  E)  (hff'  :  HasFDerivAt  f  f'  xâ‚€)  :  fderiv  ğ•œ  f  xâ‚€  =  f'  :=\n  hff'.fderiv \n```", "```py\nexample  (n  :  â„•)  (f  :  E  â†’  F)  :  E  â†’  E[Ã—n]â†’L[ğ•œ]  F  :=\n  iteratedFDeriv  ğ•œ  n  f\n\nexample  (n  :  â„•âˆ)  {f  :  E  â†’  F}  :\n  ContDiff  ğ•œ  n  f  â†”\n  (âˆ€  m  :  â„•,  (m  :  WithTop  â„•)  â‰¤  n  â†’  Continuous  fun  x  â†¦  iteratedFDeriv  ğ•œ  m  f  x)  âˆ§\n  âˆ€  m  :  â„•,  (m  :  WithTop  â„•)  <  n  â†’  Differentiable  ğ•œ  fun  x  â†¦  iteratedFDeriv  ğ•œ  m  f  x  :=\n  contDiff_iff_continuous_differentiable \n```", "```py\nexample  {ğ•‚  :  Type*}  [RCLike  ğ•‚]  {E  :  Type*}  [NormedAddCommGroup  E]  [NormedSpace  ğ•‚  E]  {F  :  Type*}\n  [NormedAddCommGroup  F]  [NormedSpace  ğ•‚  F]  {f  :  E  â†’  F}  {x  :  E}  {n  :  WithTop  â„•âˆ}\n  (hf  :  ContDiffAt  ğ•‚  n  f  x)  (hn  :  1  â‰¤  n)  :  HasStrictFDerivAt  f  (fderiv  ğ•‚  f  x)  x  :=\n  hf.hasStrictFDerivAt  hn \n```", "```py\nsection  LocalInverse\nvariable  [CompleteSpace  E]  {f  :  E  â†’  F}  {f'  :  E  â‰ƒL[ğ•œ]  F}  {a  :  E}\n\nexample  (hf  :  HasStrictFDerivAt  f  (f'  :  E  â†’L[ğ•œ]  F)  a)  :  F  â†’  E  :=\n  HasStrictFDerivAt.localInverse  f  f'  a  hf\n\nexample  (hf  :  HasStrictFDerivAt  f  (f'  :  E  â†’L[ğ•œ]  F)  a)  :\n  âˆ€á¶   x  in  ğ“  a,  hf.localInverse  f  f'  a  (f  x)  =  x  :=\n  hf.eventually_left_inverse\n\nexample  (hf  :  HasStrictFDerivAt  f  (f'  :  E  â†’L[ğ•œ]  F)  a)  :\n  âˆ€á¶   x  in  ğ“  (f  a),  f  (hf.localInverse  f  f'  a  x)  =  x  :=\n  hf.eventually_right_inverse\n\nexample  {f  :  E  â†’  F}  {f'  :  E  â‰ƒL[ğ•œ]  F}  {a  :  E}\n  (hf  :  HasStrictFDerivAt  f  (f'  :  E  â†’L[ğ•œ]  F)  a)  :\n  HasStrictFDerivAt  (HasStrictFDerivAt.localInverse  f  f'  a  hf)  (f'.symm  :  F  â†’L[ğ•œ]  E)  (f  a)  :=\n  HasStrictFDerivAt.to_localInverse  hf\n\nend  LocalInverse \n```"]