- en: Computing ∂P/∂F or δP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://phys-sim-book.github.io/lec14.3-compute_stress_deriv.html](https://phys-sim-book.github.io/lec14.3-compute_stress_deriv.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute the derivative of P with respect to F, we leverage the rotational
    invariance property discussed earlier for P. Consider two arbitrary rotation matrices
    R and Q. From the rotational properties of P, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: P(F)=P(RRTFQQT)=RP(RTFQ)QT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define K=RTFQ, then:'
  prefs: []
  type: TYPE_NORMAL
- en: P(F)=RP(K)QT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking the differential of P, while treating R and Q as constants, gives:'
  prefs: []
  type: TYPE_NORMAL
- en: δP=R[∂F∂P​(K):δ(K)]QT=R[∂F∂P​(K):(RTδFQ)]QT.
  prefs: []
  type: TYPE_NORMAL
- en: 'By setting R=U and Q=V, where K=Σ, the differential expression simplifies to:'
  prefs: []
  type: TYPE_NORMAL
- en: δP=U[∂F∂P​(Σ):(UTδFV)]VT.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tensorial derivative ∂P/∂F is then expressed in index notation as:'
  prefs: []
  type: TYPE_NORMAL
- en: (δP)ij​=Uik​(∂F∂P​(Σ))klmn​Urm​δFrs​Vsn​Vjl​,and(δP)ij​=(∂F∂P​(F))ijrs​δFrs​.
  prefs: []
  type: TYPE_NORMAL
- en: 'These expressions must hold for any δF, leading to the relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: (∂F∂P​(F))ijrs​=(∂F∂P​(Σ))klmn​Uik​Urm​Vsn​Vjl​.
  prefs: []
  type: TYPE_NORMAL
- en: So the remaining task is computing ∂F∂P​(Σ). We show how to do it in 3D.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s introduce Rodrigues'' rotation formula, which provides a method
    for expressing any rotation matrix in terms of a unit vector k and a rotation
    angle θ. The formula is given by: R=I+sin(θ)K+(1−cos(θ))K2,(14.3.1) where K is
    the skew-symmetric cross-product matrix associated with k. This formula shows
    that any rotation matrix is characterized by just three degrees of freedom, denoted
    as r1​,r2​,r3​. These components are used to define the rotation vector r, from
    which k and θ are derived as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: k=∣r∣r​,θ=∣r∣.
  prefs: []
  type: TYPE_NORMAL
- en: Using this parameterization, rotation matrices U and V can each be described
    by three parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have the following code for defining F in terms of s1, s2, s3, u1, u2,
    u3, v1, v2, v3, where U and V are defined by ui​ and vi​ with Rodrigues' rotation
    formula, si​ are the singular values from Σ.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: where cp is a function for generating the cross-product matrix (corresponding
    to computing K in Equation [(14.3.1)](#eqn:rodrigues)).
  prefs: []
  type: TYPE_NORMAL
- en: From now on, we write the 3×3×3×3 tensor ∂F∂P​(Σ) and any other such tensors
    to 9×9 matrices. That means each 3×3 matrix is now a size-9 vector. It is easy
    to see the old ∂Fkl​∂Pij​​ is now ∂F3(k−1)+l​∂P3(i−1)+j​​. We further call vector
    S={s1,s2,s3,u1,u2,u3,v1,v2,v3} being the parametrization of F. Then we can apply
    the chain rule ∂F∂P​(Σ)=∂S∂P​(Σ)∂F∂S​(Σ)
  prefs: []
  type: TYPE_NORMAL
- en: Here are the Mathematica code for computing them. Note that we achieve F=Σ by
    taking the limit {u1,u2,u3,v1,v2,v3}=+ϵ, which correspond to nearly zero rotations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note 'Direction->-1' in Mathematica means taking the limit from large values
    to the small limit value. The Mathematica computation result will be given in
    terms of the singular values and P^. One can then take the formula for implementing
    them in the code. [[Stomakhin et al. 2012]](bibliography.html#stomakhin2012energetically)
    gives the result where ∂F∂P​(Σ) (size 9×9 matrix) is permuted to be a block diagonal
    matrix with diagonal blocks A3×3,B122×2​,B132×2​,B232×2​, where A=​Ψ^,σ1​σ1​​Ψ^,σ2​σ1​​Ψ^,σ3​σ1​​​Ψ^,σ1​σ2​​Ψ^,σ2​σ2​​Ψ^,σ3​σ2​​​Ψ^,σ1​σ3​​Ψ^,σ2​σ3​​Ψ^,σ3​σ3​​​​
    and Bij​=σi2​−σj2​1​(σi​Ψ^,σi​​−σj​Ψ^,σj​​σj​Ψ^,σi​​−σi​Ψ^,σj​​​σj​Ψ^,σi​​−σi​Ψ^,σj​​σi​Ψ^,σi​​−σj​Ψ^,σj​​​).
    Denominator clamping is needed for terms in B that may introduce division-by-zero
    (after fully simplifying them). Here we denote ∂σi​∂Ψ^​ and ∂σi​∂σj​∂2Ψ^​ as Ψ^,σi​​
    and Ψ^,σi​σj​​ respectively. The division by σi2​−σj2​ is problematic when two
    singular values are nearly equal or when two singular values nearly sum to zero.
    The latter is possible with a convention for permitting negative singular values
    (as in invertible elasticity [[Irving et al. 2004]](bibliography.html#irving2004invertible)
    [[Stomakhin et al. 2012]](bibliography.html#stomakhin2012energetically)).
  prefs: []
  type: TYPE_NORMAL
- en: Expanding Bij​ in terms of partial fractions yields the useful decomposition
    Bij​=21​σi​−σj​Ψ^,σi​​−Ψ^,σj​​​(11​11​)+21​σi​+σj​Ψ^,σi​​+Ψ^,σj​​​(1−1​−11​).
    Note that if Ψ^ is invariant under permutation of the singular values, then Ψ^,σi​​→Ψ^,σj​​
    as σi​→σj​. Thus, the first term can normally be computed robustly for an isotropic
    model if implemented carefully. The other fraction can be computed robustly if
    Ψ^,σi​​+Ψ^,σj​​→0 as σi​+σj​→0. But this usually does not hold as it means the
    constitutive model will have difficulty recovering from degenerate or inverted
    configurations. Thus, this term will be unbounded under some circumstances. We
    address this by clamping the magnitude of the denominator to not be smaller than
    10−6 before division to bound the derivatives.
  prefs: []
  type: TYPE_NORMAL
- en: For 2D, a rotation matrix is now simply paremetrized with a single θ where the
    reconstruction is
  prefs: []
  type: TYPE_NORMAL
- en: R=(cosθsinθ​−sinθcosθ​). The 2D version of the whole Mathematica code is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: where A is now also 2×2 and there is only one B.
  prefs: []
  type: TYPE_NORMAL
