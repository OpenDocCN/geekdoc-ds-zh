- en: Assembly Language
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 汇编语言
- en: 原文：[https://en.algorithmica.org/hpc/architecture/assembly/](https://en.algorithmica.org/hpc/architecture/assembly/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/architecture/assembly/](https://en.algorithmica.org/hpc/architecture/assembly/)
- en: CPUs are controlled with *machine language*, which is just a stream of binary-encoded
    instructions that specify
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: CPU使用*机器语言*进行控制，它只是一串二进制编码的指令，用于指定
- en: the instruction number (called *opcode*),
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令编号（称为*操作码*），
- en: what its *operands* are (if there are any),
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的*操作数*是什么（如果有），
- en: and where to store the *result* (if one is produced).
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及*结果*存储的位置（如果产生了结果）。
- en: A much more human-friendly rendition of machine language, called *assembly language*,
    uses mnemonic codes to refer to machine code instructions and symbolic names to
    refer to registers and other storage locations.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更符合人类习惯的机器语言版本，称为*汇编语言*，使用助记符来引用机器代码指令，并使用符号名称来引用寄存器和其他存储位置。
- en: 'Jumping right into it, here is how you add two numbers (`*c = *a + *b`) in
    Arm assembly:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 直接进入主题，以下是如何在Arm汇编中添加两个数字（`*c = *a + *b`）的示例：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the same operation in x86 assembly:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是x86汇编中的相同操作：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Assembly is very simple in the sense that it doesn’t have many syntactical
    constructions compared to high-level programming languages. From what you can
    observe from the examples above:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言相对于高级编程语言来说非常简单，因为它不需要复杂。它尽可能地反映了机器语言，直到机器代码和汇编之间几乎达到1:1的对应。实际上，你可以使用称为*反汇编*的过程将任何编译程序转换回其汇编形式——尽管非必要的内容，如注释将不会被保留。
- en: A program is a sequence of instructions, each written as its name followed by
    a variable number of operands.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序是一系列指令的序列，每个指令都按照其名称后跟可变数量的操作数来编写。
- en: The `[reg]` syntax is used for “dereferencing” a pointer stored in a register,
    and on x86 you need to prefix it with size information (`DWORD` here means 32
    bit).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[reg]`语法用于“解引用”存储在寄存器中的指针，在x86中，你需要在其前面加上大小信息（这里`DWORD`表示32位）。'
- en: The `;` sign is used for line comments, similar to `#` and `//` in other languages.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`;`符号用于行注释，类似于其他语言中的`#`和`//`。'
- en: Assembly is a very minimal language because it needs to be. It reflects the
    machine language as closely as possible, up to the point where there is almost
    1:1 correspondence between machine code and assembly. In fact, you can turn any
    compiled program back into its assembly form using a process called *disassembly*^([1](#fn:1))
    — although everything non-essential like comments will not be preserved.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言是一种非常简单的语言，因为它需要尽可能接近机器语言。它反映了机器语言，直到几乎达到机器代码和汇编之间的1:1对应。实际上，你可以使用称为*反汇编*的过程将任何编译程序转换回其汇编形式——尽管非必要的内容，如注释将不会被保留。
- en: Note that the two snippets above are not just syntactically different. Both
    are optimized codes produced by a compiler, but the Arm version uses 4 instructions,
    while the x86 version uses 3\. The `add eax, [rdi]` instruction is what’s called
    *fused instruction* that does a load and an add in one go — this is one of the
    perks that the [CISC](../isa#risc-vs-cisc) approach can provide.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，上述两个代码片段不仅在语法上不同。它们都是编译器产生的优化代码，但Arm版本使用了4条指令，而x86版本使用了3条。`add eax, [rdi]`指令被称为*融合指令*，它一次执行加载和加法操作——这是[CISC](../isa#risc-vs-cisc)方法可以提供的好处之一。
- en: Since there are far more differences between the architectures than just this
    one, from here on and for the rest of the book we will only provide examples for
    x86, which is probably what most of our readers will optimize for, although many
    of the introduced concepts will be architecture-agnostic.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于架构之间的差异远不止这一点，从现在开始，本书的其余部分我们将只提供x86架构的示例，这可能是我们大多数读者将优化的，尽管许多引入的概念将是架构无关的。
- en: '### [#](https://en.algorithmica.org/hpc/architecture/assembly/#instructions-and-registers)Instructions
    and Registers'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/architecture/assembly/#instructions-and-registers)指令和寄存器'
- en: For historical reasons, instruction mnemonics in most assembly languages are
    very terse. Back when people used to write assembly by hand and repeatedly wrote
    the same set of common instructions, one less character to type was one step away
    from insanity.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史原因，大多数汇编语言中的指令助记符都非常简短。在人们手工编写汇编代码并反复编写相同的一组常见指令的时代，少打一个字符就少一步接近疯狂。
- en: For example, `mov` is for “store/load a word,” `inc` is for “increment by 1,”
    `mul` is for “multiply,” and `idiv` is for “integer division.” You can look up
    the description of an instruction by its name in [one of x86 references](https://www.felixcloutier.com/x86/),
    but most instructions do what you’d think they do.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`mov`用于“存储/加载一个字”，`inc`用于“加1”，`mul`用于“乘法”，`idiv`用于“整数除法”。你可以通过名称在[一个x86参考](https://www.felixcloutier.com/x86/)中查找指令的描述，但大多数指令都做你想象中的事情。
- en: Most instructions write their result into the first operand, which can also
    be involved in the computation like in the `add eax, [rdi]` example we saw before.
    Operands can be either registers, constant values, or memory locations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数指令将它们的输出写入第一个操作数，这个操作数也可以像在之前的`add eax, [rdi]`示例中那样参与计算。操作数可以是寄存器、常量值或内存位置。
- en: '**Registers** are named `rax`, `rbx`, `rcx`, `rdx`, `rdi`, `rsi`, `rbp`, `rsp`,
    and `r8`-`r15` for a total of 16 of them. The “letter” ones are named like that
    for historical reasons: `rax` is “accumulator,” `rcx` is “counter,” `rdx` is “data”
    and so on — but, of course, they don’t have to be used only for that.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**寄存器**命名为`rax`、`rbx`、`rcx`、`rdx`、`rdi`、`rsi`、`rbp`、`rsp`和`r8`-`r15`，总共有16个。这些“字母”寄存器的命名是出于历史原因：`rax`是“累加器”，`rcx`是“计数器”，`rdx`是“数据”等等——但当然，它们不必仅用于这些。'
- en: 'There are also 32-, 16-bit and 8-bit registers that have similar names (`rax`
    → `eax` → `ax` → `al`). They are not fully separate but *aliased*: the lowest
    32 bits of `rax` are `eax`, the lowest 16 bits of `eax` are `ax`, and so on. This
    is made to save die space while maintaining compatibility, and it is also the
    reason why basic type casts in compiled programming languages are usually free.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 还有32位、16位和8位寄存器，它们有类似的名字（`rax` → `eax` → `ax` → `al`）。它们并不是完全独立的，而是**别名**：`rax`的最低32位是`eax`，`eax`的最低16位是`ax`，以此类推。这样做是为了节省芯片空间同时保持兼容性，这也是为什么编译编程语言中的基本类型转换通常是免费的。
- en: These are just the *general-purpose* registers that you can, with [some exceptions](../functions),
    use however you like in most instructions. There is also a separate set of registers
    for [floating-point arithmetic](/hpc/arithmetic/float), a bunch of very wide registers
    used in [vector extensions](/hpc/simd), and a few special ones that are needed
    for [control flow](../loops), but we’ll get there in time.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是一些**通用**寄存器，你可以在大多数指令中使用它们，[有些例外](../functions)，但你可以随意使用。还有一个专门的寄存器集用于[浮点运算](/hpc/arithmetic/float)，一些非常宽的寄存器用于[向量扩展](/hpc/simd)，以及一些用于[控制流](../loops)的特殊寄存器，但我们会逐步了解。
- en: '**Constants** are just integer or floating-point values: `42`, `0x2a`, `3.14`,
    `6.02e23`. They are more commonly called *immediate values* because they are embedded
    right into the machine code. Because it may considerably increase the complexity
    of the instruction encoding, some instructions don’t support immediate values
    or allow just a fixed subset of them. In some cases, you have to load a constant
    value into a register and then use it instead of an immediate value.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**常量**只是整数或浮点值：`42`、`0x2a`、`3.14`、`6.02e23`。它们更常见地被称为**立即数**，因为它们直接嵌入到机器代码中。由于这可能会显著增加指令编码的复杂性，一些指令不支持立即数或只支持它们的固定子集。在某些情况下，你必须将常量值加载到寄存器中，然后使用它而不是立即数。'
- en: Apart from numeric values, there are also string constants such as `hello` or
    `world\n` with their own little subset of operations, but that is a somewhat obscure
    corner of the assembly language that we are not going to explore here.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数值之外，还有字符串常量，如`hello`或`world\n`，它们有自己的小操作子集，但这汇编语言的一个相对不为人知的角落，我们在这里不会探讨。
- en: '### [#](https://en.algorithmica.org/hpc/architecture/assembly/#moving-data)Moving
    Data'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/architecture/assembly/#moving-data)移动数据'
- en: 'Some instructions may have the same mnemonic, but have different operand types,
    in which case they are considered distinct instructions as they may perform slightly
    different operations and take different times to execute. The `mov` instruction
    is a vivid example of that, as it comes in around 20 different forms, all related
    to moving data: either between the memory and registers or just between two registers.
    Despite the name, it doesn’t *move* a value into a register, but *copies* it,
    preserving the original.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一些指令可能有相同的助记符，但操作数类型不同，在这种情况下，它们被视为不同的指令，因为它们可能执行稍微不同的操作，并且执行时间也不同。`mov`指令是一个很好的例子，它有大约20种形式，都与移动数据有关：要么在内存和寄存器之间，要么在两个寄存器之间。尽管名称如此，它并不是将值**移动**到寄存器中，而是**复制**它，保留原始值。
- en: When used to copy data between two registers, the `mov` instruction instead
    performs *register renaming* internally — informs the CPU that the value referred
    by register X is actually stored in register Y — without causing any additional
    delay except for maybe reading and decoding the instruction itself. For the same
    reason, the `xchg` instruction that swaps two registers also doesn’t cost anything.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当用于在两个寄存器之间复制数据时，`mov` 指令内部实际上执行的是**寄存器重命名**——通知 CPU，由寄存器 X 指代的值实际上存储在寄存器 Y
    中——除了可能读取和解析指令本身外，不会造成任何额外的延迟。同样地，用于交换两个寄存器的 `xchg` 指令也不会产生任何开销。
- en: 'As we’ve seen above with the fused `add`, you don’t have to use `mov` for every
    memory operation: some arithmetic instructions conveniently support memory locations
    as operands.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们上面在融合的 `add` 指令中看到的，你不必为每个内存操作都使用 `mov`：一些算术指令方便地支持将内存位置作为操作数。
- en: '### [#](https://en.algorithmica.org/hpc/architecture/assembly/#addressing-modes)Addressing
    Modes'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/architecture/assembly/#addressing-modes)寻址模式'
- en: 'Memory addressing is done with the `[]` operator, but it can do more than just
    reinterpret a value stored in a register as a memory location. The address operand
    takes up to 4 parameters presented in the syntax:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 内存寻址使用 `[]` 操作符进行，但它不仅能将存储在寄存器中的值重新解释为内存位置。地址操作数最多可以包含 4 个参数，这些参数在语法中呈现：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: where `displacement` needs to be an integer constant and `scale` can be either
    2, 4, or 8\. What it does is calculate the pointer `base + index * scale + displacement`
    and dereferences it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `displacement` 需要是一个整型常量，而 `scale` 可以是 2、4 或 8。它所做的计算是 `base + index * scale
    + displacement` 的指针，并对其进行解引用。
- en: Using complex addressing is [at most one cycle slower](/hpc/cpu-cache/pointers)
    than dereferencing a pointer directly, and it can be useful when you have, for
    example, an array of structures and want to load a specific field of its $i$-th
    element.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用复杂寻址最多比直接解引用指针慢一个周期，并且当例如你有结构体数组并想要加载其第 $i$ 个元素的特定字段时，它可能很有用。
- en: 'Addressing operator needs to be prefixed with a size specifier for how many
    bits of data are needed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 寻址操作符需要前缀一个大小指定符，以指明需要多少位的数据：
- en: '`BYTE` for 8 bits'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BYTE` 用于 8 位'
- en: '`WORD` for 16 bits'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORD` 用于 16 位'
- en: '`DWORD` for 32 bits'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DWORD` 用于 32 位'
- en: '`QWORD` for 64 bits'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QWORD` 用于 64 位'
- en: There is also a more rare `TBYTE` for [80 bits](/hpc/arithmetic/float), and
    `XMMWORD`, `YMMWORD`, and `ZMMWORD` for [128, 256, and 512 bits](/hpc/simd) respectively.
    All these types don’t have to be written in uppercase, but this is how most compilers
    emit them.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更少见的 `TBYTE` 用于 [80 位](/hpc/arithmetic/float)，以及 `XMMWORD`、`YMMWORD` 和 `ZMMWORD`
    分别用于 [128、256 和 512 位](/hpc/simd)。所有这些类型不必全部大写，但这是大多数编译器生成它们的方式。
- en: 'The address computation is often useful by itself: the `lea` (“load effective
    address”) instruction calculates the memory address of the operand and stores
    it in a register in one cycle, without doing any actual memory operations. While
    its intended use is for actually computing memory addresses, it is also often
    used as an arithmetic trick that would otherwise involve 1 multiplication and
    2 additions — for example, you can multiply by 3, 5, and 9 with it.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 地址计算本身通常很有用：`lea`（“加载有效地址”）指令在一个周期内计算操作数的内存地址，并将其存储在寄存器中，而不进行任何实际的内存操作。虽然它的预期用途是实际计算内存地址，但它也经常用作一个算术技巧，否则将涉及
    1 次乘法和 2 次加法——例如，你可以用它来乘以 3、5 和 9。
- en: 'It also frequently serves as a replacement for `add` because it doesn’t need
    a separate `mov` instruction if you need to move the result somewhere else: `add`
    only works in the two-register `a += b` mode, while `lea` lets you do `a = b +
    c` (or even `a = b + c + d` if one of them is a constant).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它还经常作为 `add` 的替代品，因为它不需要单独的 `mov` 指令，如果你需要将结果移动到其他地方：`add` 只能在两个寄存器的 `a += b`
    模式下工作，而 `lea` 允许你做 `a = b + c`（或者如果其中一个是一个常数，甚至 `a = b + c + d`）。
- en: '### [#](https://en.algorithmica.org/hpc/architecture/assembly/#alternative-syntax)Alternative
    Syntax'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/architecture/assembly/#alternative-syntax)替代语法'
- en: 'There are actually multiple *assemblers* (the programs that produce machine
    code from assembly) with different assembly languages, but only two x86 syntaxes
    are widely used now. They are commonly called after the two companies that used
    them and had a dominant influence on programming during that era:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上存在多个**汇编器**（从汇编代码生成机器代码的程序），它们使用不同的汇编语言，但现在广泛使用的只有两种 x86 语法。它们通常以使用它们的两个公司命名，并在那个时代对编程产生了主导影响：
- en: The *AT&T syntax*, used by default by all Linux tools.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认使用的 *AT&T 语法，由所有 Linux 工具使用。
- en: The *Intel syntax*, used by default, well, by Intel.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认使用的 *Intel语法*，嗯，由Intel使用。
- en: These syntaxes are also sometimes called *GAS* and *NASM* respectively, by the
    names of the two primary assemblers that use them (*GNU Assembler* and *Netwide
    Assembler*).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语法有时也分别被称为 *GAS* 和 *NASM*，分别以使用它们的两个主要汇编器的名称命名（*GNU Assembler* 和 *Netwide
    Assembler*）。
- en: 'We used Intel syntax in this chapter and will continue to preferably use it
    for the rest of the book. For comparison, here is how the same `*c = *a + *b`
    example looks like in AT&T asm:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中使用了Intel语法，并将继续在本书的其余部分优先使用它。为了比较，以下是在AT&T汇编中相同的 `*c = *a + *b` 示例的表示：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The key differences can be summarized as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 关键区别可以总结如下：
- en: The *last* operand is used to specify the destination.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个操作数用于指定目标。
- en: Registers and constants need to be prefixed by `%` and `$` respectively (e.g.,
    `addl $1, %rdx` increments `rdx`).
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寄存器和常数需要分别以 `%` 和 `$` 前缀（例如，`addl $1, %rdx` 增加了 `rdx`）。
- en: 'Memory addressing looks like this: `displacement(%base, %index, scale)`.'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内存寻址看起来像这样：`displacement(%base, %index, scale)`。
- en: Both `;` and `#` can be used for line comments, and also `/* */` can be used
    for block comments.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`;` 和 `#` 都可以用作行注释，同时也可以使用 `/* */` 进行块注释。'
- en: 'And, most importantly, in AT&T syntax, the instruction names need to be “suffixed”
    (`addq`, `movl`, `cmpq`, etc.) to specify what size operands are being manipulated:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，最重要的是，在AT&T语法中，指令名称需要“后缀” (`addq`, `movl`, `cmpq`, 等) 以指定正在操作的操作数的大小：
- en: '`b` = byte (8 bit)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b` = 字节（8位）'
- en: '`w` = word (16 bit)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w` = 字（16位）'
- en: '`l` = long (32 bit integer or 64-bit floating-point)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`l` = 长度（32位整数或64位浮点数）'
- en: '`q` = quad (64 bit)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`q` = 四倍（64位）'
- en: '`s` = single (32-bit floating-point)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s` = 单个（32位浮点数）'
- en: '`t` = ten bytes (80-bit floating-point)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t` = 十字节（80位浮点数）'
- en: In Intel syntax, this information is inferred from operands (which is why you
    also need to specify sizes of pointers).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在Intel语法中，此信息是从操作数推断出来的（这也是为什么你还需要指定指针的大小）。
- en: Most tools that produce or consume x86 assembly can do so in both syntaxes,
    so you can just pick the one you like more and don’t worry.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数生成或消费x86汇编的工具都可以使用这两种语法，所以你可以选择你更喜欢的一种，不必担心。
- en: '* * *'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '***'
- en: On Linux, to disassemble a compiled program, you can call `objdump -d {path-to-binary}`. [↩︎](#fnref:1)
    [← Instruction Set Architectures](https://en.algorithmica.org/hpc/architecture/isa/)[Loops
    and Conditionals →](https://en.algorithmica.org/hpc/architecture/loops/)
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Linux上，要反汇编编译后的程序，你可以调用 `objdump -d {二进制文件路径}`。[↑](#fnref:1) [← 指令集架构](https://en.algorithmica.org/hpc/architecture/isa/)[循环和条件语句
    →](https://en.algorithmica.org/hpc/architecture/loops/)
