["```py\nimport utils\nimport numpy as np\nimport math\n\ndef polar_svd(F):\n    [U, s, VT] = np.linalg.svd(F)\n    if np.linalg.det(U) < 0:\n        U[:, 1] = -U[:, 1]\n        s[1] = -s[1]\n    if np.linalg.det(VT) < 0:\n        VT[1, :] = -VT[1, :]\n        s[1] = -s[1]\n    return [U, s, VT]\n\ndef dPsi_div_dsigma(s, mu, lam):\n    ln_sigma_prod = math.log(s[0] * s[1])\n    inv0 = 1.0 / s[0]\n    dPsi_dsigma_0 = mu * (s[0] - inv0) + lam * inv0 * ln_sigma_prod\n    inv1 = 1.0 / s[1]\n    dPsi_dsigma_1 = mu * (s[1] - inv1) + lam * inv1 * ln_sigma_prod\n    return [dPsi_dsigma_0, dPsi_dsigma_1]\n\ndef d2Psi_div_dsigma2(s, mu, lam):\n    ln_sigma_prod = math.log(s[0] * s[1])\n    inv2_0 = 1 / (s[0] * s[0])\n    d2Psi_dsigma2_00 = mu * (1 + inv2_0) - lam * inv2_0 * (ln_sigma_prod - 1)\n    inv2_1 = 1 / (s[1] * s[1])\n    d2Psi_dsigma2_11 = mu * (1 + inv2_1) - lam * inv2_1 * (ln_sigma_prod - 1)\n    d2Psi_dsigma2_01 = lam / (s[0] * s[1])\n    return [[d2Psi_dsigma2_00, d2Psi_dsigma2_01], [d2Psi_dsigma2_01, d2Psi_dsigma2_11]]\n\ndef B_left_coef(s, mu, lam):\n    sigma_prod = s[0] * s[1]\n    return (mu + (mu - lam * math.log(sigma_prod)) / sigma_prod) / 2\n\ndef Psi(F, mu, lam):\n    J = np.linalg.det(F)\n    lnJ = math.log(J)\n    return mu / 2 * (np.trace(np.transpose(F).dot(F)) - 2) - mu * lnJ + lam / 2 * lnJ * lnJ\n\ndef dPsi_div_dF(F, mu, lam):\n    FinvT = np.transpose(np.linalg.inv(F))\n    return mu * (F - FinvT) + lam * math.log(np.linalg.det(F)) * FinvT\n\ndef d2Psi_div_dF2(F, mu, lam):\n    [U, sigma, VT] = polar_svd(F)\n\n    Psi_sigma_sigma = utils.make_PSD(d2Psi_div_dsigma2(sigma, mu, lam))\n\n    B_left = B_left_coef(sigma, mu, lam)\n    Psi_sigma = dPsi_div_dsigma(sigma, mu, lam)\n    B_right = (Psi_sigma[0] + Psi_sigma[1]) / (2 * max(sigma[0] + sigma[1], 1e-6))\n    B = utils.make_PSD([[B_left + B_right, B_left - B_right], [B_left - B_right, B_left + B_right]])\n\n    M = np.array([[0, 0, 0, 0]] * 4)\n    M[0, 0] = Psi_sigma_sigma[0, 0]\n    M[0, 3] = Psi_sigma_sigma[0, 1]\n    M[1, 1] = B[0, 0]\n    M[1, 2] = B[0, 1]\n    M[2, 1] = B[1, 0]\n    M[2, 2] = B[1, 1]\n    M[3, 0] = Psi_sigma_sigma[1, 0]\n    M[3, 3] = Psi_sigma_sigma[1, 1]\n\n    dP_div_dF = np.array([[0, 0, 0, 0]] * 4)\n    for j in range(0, 2):\n        for i in range(0, 2):\n            ij = j * 2 + i\n            for s in range(0, 2):\n                for r in range(0, 2):\n                    rs = s * 2 + r\n                    dP_div_dF[ij, rs] = M[0, 0] * U[i, 0] * VT[0, j] * U[r, 0] * VT[0, s] \\\n                        + M[0, 3] * U[i, 0] * VT[0, j] * U[r, 1] * VT[1, s] \\\n                        + M[1, 1] * U[i, 1] * VT[0, j] * U[r, 1] * VT[0, s] \\\n                        + M[1, 2] * U[i, 1] * VT[0, j] * U[r, 0] * VT[1, s] \\\n                        + M[2, 1] * U[i, 0] * VT[1, j] * U[r, 1] * VT[0, s] \\\n                        + M[2, 2] * U[i, 0] * VT[1, j] * U[r, 0] * VT[1, s] \\\n                        + M[3, 0] * U[i, 1] * VT[1, j] * U[r, 0] * VT[0, s] \\\n                        + M[3, 3] * U[i, 1] * VT[1, j] * U[r, 1] * VT[1, s]\n    return dP_div_dF \n```", "```py\ndef deformation_grad(x, elemVInd, IB):\n    F = [x[elemVInd[1]] - x[elemVInd[0]], x[elemVInd[2]] - x[elemVInd[0]]]\n    return np.transpose(F).dot(IB)\n\ndef dPsi_div_dx(P, IB):  # applying chain-rule, dPsi_div_dx = dPsi_div_dF * dF_div_dx\n    dPsi_dx_2 = P[0, 0] * IB[0, 0] + P[0, 1] * IB[0, 1]\n    dPsi_dx_3 = P[1, 0] * IB[0, 0] + P[1, 1] * IB[0, 1]\n    dPsi_dx_4 = P[0, 0] * IB[1, 0] + P[0, 1] * IB[1, 1]\n    dPsi_dx_5 = P[1, 0] * IB[1, 0] + P[1, 1] * IB[1, 1]\n    return [np.array([-dPsi_dx_2 - dPsi_dx_4, -dPsi_dx_3 - dPsi_dx_5]), np.array([dPsi_dx_2, dPsi_dx_3]), np.array([dPsi_dx_4, dPsi_dx_5])]\n\ndef d2Psi_div_dx2(dP_div_dF, IB):  # applying chain-rule, d2Psi_div_dx2 = dF_div_dx^T * d2Psi_div_dF2 * dF_div_dx (note that d2F_div_dx2 = 0)\n    intermediate = np.array([[0.0, 0.0, 0.0, 0.0]] * 6)\n    for colI in range(0, 4):\n        _000 = dP_div_dF[0, colI] * IB[0, 0]\n        _010 = dP_div_dF[0, colI] * IB[1, 0]\n        _101 = dP_div_dF[2, colI] * IB[0, 1]\n        _111 = dP_div_dF[2, colI] * IB[1, 1]\n        _200 = dP_div_dF[1, colI] * IB[0, 0]\n        _210 = dP_div_dF[1, colI] * IB[1, 0]\n        _301 = dP_div_dF[3, colI] * IB[0, 1]\n        _311 = dP_div_dF[3, colI] * IB[1, 1]\n        intermediate[2, colI] = _000 + _101\n        intermediate[3, colI] = _200 + _301\n        intermediate[4, colI] = _010 + _111\n        intermediate[5, colI] = _210 + _311\n        intermediate[0, colI] = -intermediate[2, colI] - intermediate[4, colI]\n        intermediate[1, colI] = -intermediate[3, colI] - intermediate[5, colI]\n    result = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]] * 6)\n    for colI in range(0, 6):\n        _000 = intermediate[colI, 0] * IB[0, 0]\n        _010 = intermediate[colI, 0] * IB[1, 0]\n        _101 = intermediate[colI, 2] * IB[0, 1]\n        _111 = intermediate[colI, 2] * IB[1, 1]\n        _200 = intermediate[colI, 1] * IB[0, 0]\n        _210 = intermediate[colI, 1] * IB[1, 0]\n        _301 = intermediate[colI, 3] * IB[0, 1]\n        _311 = intermediate[colI, 3] * IB[1, 1]\n        result[2, colI] = _000 + _101\n        result[3, colI] = _200 + _301\n        result[4, colI] = _010 + _111\n        result[5, colI] = _210 + _311\n        result[0, colI] = -_000 - _101 - _010 - _111\n        result[1, colI] = -_200 - _301 - _210 - _311\n    return result \n```", "```py\ndef val(x, e, vol, IB, mu, lam):\n    sum = 0.0\n    for i in range(0, len(e)):\n        F = deformation_grad(x, e[i], IB[i])\n        sum += vol[i] * Psi(F, mu[i], lam[i])\n    return sum\n\ndef grad(x, e, vol, IB, mu, lam):\n    g = np.array([[0.0, 0.0]] * len(x))\n    for i in range(0, len(e)):\n        F = deformation_grad(x, e[i], IB[i])\n        P = vol[i] * dPsi_div_dF(F, mu[i], lam[i])\n        g_local = dPsi_div_dx(P, IB[i])\n        for j in range(0, 3):\n            g[e[i][j]] += g_local[j]\n    return g\n\ndef hess(x, e, vol, IB, mu, lam):\n    IJV = [[0] * (len(e) * 36), [0] * (len(e) * 36), np.array([0.0] * (len(e) * 36))]\n    for i in range(0, len(e)):\n        F = deformation_grad(x, e[i], IB[i])\n        dP_div_dF = vol[i] * d2Psi_div_dF2(F, mu[i], lam[i])\n        local_hess = d2Psi_div_dx2(dP_div_dF, IB[i])\n        for xI in range(0, 3):\n            for xJ in range(0, 3):\n                for dI in range(0, 2):\n                    for dJ in range(0, 2):\n                        ind = i * 36 + (xI * 3 + xJ) * 4 + dI * 2 + dJ\n                        IJV[0][ind] = e[i][xI] * 2 + dI\n                        IJV[1][ind] = e[i][xJ] * 2 + dJ\n                        IJV[2][ind] = local_hess[xI * 2 + dI, xJ * 2 + dJ]\n    return IJV \n```"]