<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>8.1Â Functions as DatağŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>8.1Â Functions as DatağŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/func-as-data.html">https://dcic-world.org/2025-08-27/func-as-data.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._fd-calculus%29" class="toclink" data-pltdoc="x">8.1.1<span class="hspace">Â </span>A Little Calculus</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._lam-shorthand%29" class="toclink" data-pltdoc="x">8.1.2<span class="hspace">Â </span>A Helpful Shorthand for Anonymous Functions</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._streams-from-funs%29" class="toclink" data-pltdoc="x">8.1.3<span class="hspace">Â </span>Streams From Functions</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._d-dx-streams%29" class="toclink" data-pltdoc="x">8.1.4<span class="hspace">Â </span>Combining Forces: Streams of Derivatives</a></p></td></tr></table><p>Itâ€™s interesting to consider how expressive the little programming
weâ€™ve learned so far can be. To illustrate this, weâ€™ll work through a
few exercises of interesting concepts we can express using just
functions as values. Weâ€™ll write two quite different things, then show
how they converge nicely.</p><section class="SsectionLevel4" id="section 8.1.1"><h4 class="heading">8.1.1<span class="stt">Â </span><a name="(part._fd-calculus)"/>A Little Calculus<span class="button-group"><a href="#(part._fd-calculus)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">If youâ€™ve studied the differential calculus, youâ€™ve come across
curious sytactic statements such as this:
</div><div class="SIntrapara"><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}{\frac{d}{dx}} x^2 = 2x\end{equation*}</p></div><div class="SIntrapara">Letâ€™s unpack what this means: the \(d/dx\), the \(x^2\), and the \(2x\).</div><p>First, letâ€™s take on the two expressions; weâ€™ll discuss one, and the
discussion will cover the other as well. The correct response to
â€œwhat does \(x^2\) mean?â€ is, of course, an error: it doesnâ€™t mean
anything, because \(x\) is an unbound identifier.</p><p/><div class="SIntrapara">So what is it <span class="emph">intended</span> to mean? The intent, clearly, is to
represent the function that squares its input, just as \(2x\) is meant
to be the function that doubles its input. We have nicer ways of
writing those:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sq(x :: Number) -&gt; Number: x * x end
fun dbl(x :: Number) -&gt; Number: 2 * x end</code></pre></div></div></div><div class="SIntrapara">and what weâ€™re really trying to say is that the \(d/dx\) (whatever
that is) of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sq</code></span> is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">dbl</code></span>.<span class="refelem"><span class="refcolumn"><span class="refcontent">Weâ€™re
assuming functions of arity one in the variable that is changing.</span></span></span></div><p/><div class="SIntrapara">So now letâ€™s unpack \(d/dx\), starting with its type. As the above
example illustrates, \(d/dx\) is really a <span class="emph">function from
functions to functions</span>. That is, we can write its type as follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx :: ((Number -&gt; Number) -&gt; (Number -&gt; Number))</code></pre></div></div></div><div class="SIntrapara">(This type might explain why your calculus course never explained this
operation this wayâ€”<wbr/>though itâ€™s not clear that obscuring its true
meaning is any better for your understanding.)</div><p>Let us now implement <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx</code></span>. Weâ€™ll implement <span class="emph">numerical</span>
differentiation, though in principle we could also implement
<span class="emph">symbolic </span> differentiationâ€”<wbr/>using rules you learned, e.g.,
given a polynomial, multiply by the exponent and reduce the exponent
by oneâ€”<wbr/>with a representation of expressions (a problem that will be covered in more detail in a future release).</p><p/><div class="SIntrapara">In general, numeric differentiation of a function at a point yields
the value of the derivative at that point. We have a handy formula for
it: the derivative of \(f\) at \(x\) is
</div><div class="SIntrapara"><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}\frac{f(x + \epsilon) - f(x)}{\epsilon}\end{equation*}</p></div><div class="SIntrapara">as \(\epsilon\) goes to zero in the limit. For now weâ€™ll give the
infinitesimal a small but fixed value, and later
[<a href="#%28part._d-dx-streams%29" data-pltdoc="x">Combining Forces: Streams of Derivatives</a>] see how we can improve on this.</div><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">epsilon = 0.00001</code></pre></div></div><p/><div class="SIntrapara">We can now translate the above formula into a function:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx-at :: (Number -&gt; Number), Number -&gt; Number

fun d-dx-at(f, x):
  (f(x + epsilon) - f(x)) / epsilon
end</code></pre></div></div></div><div class="SIntrapara">And sure enough, we can check and make sure it works as expected:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  d-dx-at(sq, 10) is-roughly dbl(10)
end</code></pre></div></div></div><div class="SIntrapara"><span class="refelem"><span class="refcolumn"><span class="refcontent">Confession: We chose the value of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">epsilon</code></span> so that the
default tolerance <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-roughly</code></span> works for this example.</span></span></span></div><p/><div class="SIntrapara">However, there is something unsatisfying about this. The function weâ€™ve written
clearly does not have the type we described earlier! What we wanted was an
operation that takes just a function, and represents the platonic notion of
differentiation; but weâ€™ve been forced, by the nature of numeric
differentiation, to describe the derivative <span class="emph">at a point</span>. We might
instead like to write something like this:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun d-dx(f):
  (f(x + epsilon) - f(x)) / epsilon
end</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Whatâ€™s the problem with the above definition?</p></blockquote></blockquote><p/><div class="SIntrapara">If you didnâ€™t notice, Pyret will soon tell you: <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x</code></span> isnâ€™t
bound. Indeed, what is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x</code></span>? Itâ€™s the point at which weâ€™re trying
to compute the numeric derivative. That is, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx</code></span> needs to
return not a number but a <span class="emph">function</span> (as the type indicates) that
will consume this <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x</code></span>:<span class="refelem"><span class="refcolumn"><span class="refcontent">â€œLambdas are relegated to
relative obscurity until Java makes them popular by not having
them.â€â€”<wbr/>James Iry,
<a href="https://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html">A
Brief, Incomplete, and Mostly Wrong History of Programming Languages</a></span></span></span>
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun d-dx(f):
  lam(x):
    (f(x + epsilon) - f(x)) / epsilon
  end
end</code></pre></div></div></div><div class="SIntrapara">If we want to be a little more explicit we can annotate the inner function:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun d-dx(f):
  lam(x :: Number) -&gt; Number:
    (f(x + epsilon) - f(x)) / epsilon
  end
end</code></pre></div></div></div><div class="SIntrapara">This is a special case of a concept useful in many programming contexts, which
we explore in more detail elsewhere: <a href="staging.html" data-pltdoc="x">Staging</a>.</div><p/><div class="SIntrapara">Sure enough, this definition now works. We can, for instance, test it
as follows (note the use of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-floor</code></span> to avoid numeric precision
issues from making our tests appear to fail):
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx-sq = d-dx(sq)

check:
  ins = [list: 0, 1, 10, 100]
  for map(n from ins):
    num-floor(d-dx-sq(n))
  end
  is
  for map(n from ins):
    num-floor(dbl(n))
  end
end</code></pre></div></div></div><div class="SIntrapara">Now we can return to the original example that launched this
investigation: what the sloppy and mysterious notation of math is
really trying to say is,
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx(lam(x): x * x end) = lam(x): 2 * x end</code></pre></div></div></div><div class="SIntrapara">or, in the notation of <a href="predicting-growth.html#%28part._math-anon-functions%29" data-pltdoc="x">A Notation for Functions</a>,
</div><div class="SIntrapara"><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}{\frac{d}{dx}} [x \rightarrow x^2] = [x \rightarrow 2x]\end{equation*}</p></div><div class="SIntrapara">Pity math textbooks for not wanting to tell us the truth!</div></section><section class="SsectionLevel4" id="section 8.1.2"><h4 class="heading">8.1.2<span class="stt">Â </span><a name="(part._lam-shorthand)"/>A Helpful Shorthand for Anonymous Functions<span class="button-group"><a href="#(part._lam-shorthand)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">Pyret offers a shorter syntax for writing anonymous functions. Though,
stylistically, we generally avoid it so that our programs donâ€™t become
a jumble of special characters, sometimes itâ€™s particularly
convenient, as we will see below. This syntax is
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{(a): b}</code></pre></div></div></div><div class="SIntrapara">where <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a</code></span> is zero or more arguments and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b</code></span> is the body. For
instance, we can write <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam(x): x * x end</code></span> as
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{(x): x * x}</code></pre></div></div></div><div class="SIntrapara">where we can see the benefit of brevity. In particular, note that
there is no need for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">end</code></span>, because the braces take the place of
showing where the expression begins and ends. Similarly, we could have
written <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx</code></span> as
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun d-dx-short(f):
  {(x): (f(x + epsilon) - f(x)) / epsilon}
end</code></pre></div></div></div><div class="SIntrapara">but many readers would say this makes the function harder to read,
because the prominent <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span> makes clear that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx</code></span> returns
an (anonymous) function, whereas this syntax obscures it. Therefore,
we will usually only use this shorthand syntax for â€œone-linersâ€.</div></section><section class="SsectionLevel4" id="section 8.1.3"><h4 class="heading">8.1.3<span class="stt">Â </span><a name="(part._streams-from-funs)"/>Streams From Functions<span class="button-group"><a href="#(part._streams-from-funs)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>People typically think of a function as serving one purpose: to
parameterize an expression. While that is both true and the most
common use of a function, it does not justify having a function of no
arguments, because that clearly parameterizes over nothing at all. Yet
functions of no argument also have a use, because functions actually
serve two purposes: to parameterize, <span class="emph">and to suspend evaluation
of the body until the function is applied</span>. In fact, these two uses
are orthogonal, in that one can employ one feature without the
other. Below, we will focus on delay without abstraction (the other
shows up in other computer science settings).</p><p>Letâ€™s consider the humble list. A list can be only finitely
long. However, there are many lists (or <span style="font-style: italic">sequences</span>) in nature
that have no natural upper bound: from mathematical objects (the
sequence of natural numbers) to natural ones (the sequence of hits to
a Web site). Rather than try to squeeze these unbounded lists into
bounded ones, letâ€™s look at how we might represent and program over
these unbounded lists.</p><p/><div class="SIntrapara">First, letâ€™s write a program to compute the sequence of natural
numbers:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun nats-from(n):
  link(n, nats-from(n + 1))
end</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Does this program have a problem?</p></blockquote></blockquote><p>While this represents our intent, it doesnâ€™t work: running itâ€”<wbr/>e.g.,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nats-from(0)</code></span>â€”<wbr/>creates an infinite loop evaluating
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nats-from</code></span> for every subsequent natural number. In other words,
we want to write something very like the above, but that doesnâ€™t recur
<span class="emph">until we want it to, i.e., on demand</span>. In other words, we want
the rest of the list to be <span style="font-style: italic">lazy</span>.</p><p>This is where our insight into functions comes in. A function, as we
have just noted, delays evaluation of its body until it is
applied. Therefore, a function would, in principle, defer the
invocation of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nats-from(n + 1)</code></span> until itâ€™s needed.</p><p/><div class="SIntrapara">Except, this creates a type problem: the second argument to
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> needs to be a list, and cannot be a function. Indeed,
because it must be a list, and every value that has been constructed
must be finite, every list is finite and eventually terminates in
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>. Therefore, we need a new data structure to represent the
links in these <span style="font-style: italic">lazy lists</span> (also known as <span style="font-style: italic">streams</span>):
</div><div class="SIntrapara"><a name="(elem._stream-type-def)"/>&lt;<span style="font-style: italic">stream-type-def</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Stream&lt;T&gt;:
  | lz-link(h :: T, t :: ( -&gt; Stream&lt;T&gt;))
end</code></pre></div></div></div><div class="SIntrapara">where the annotation <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">( -&gt; Stream&lt;T&gt;)</code></span> means a function from no
arguments (hence the lack of anything before <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">-&gt;</code></span>),
also known as a <span style="font-style: italic">thunk</span>. Note that the way we have
defined streams they <span class="emph">must</span> be infinite, since we have provided
no way to terminate them.</div><p/><div class="SIntrapara">Letâ€™s construct the simplest example we can, a stream of constant
values:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones = lz-link(1, lam(): ones end)</code></pre></div></div></div><div class="SIntrapara">Pyret will actually complain about this definition. Note that
the list equivalent of this also will not work:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones = link(1, ones)</code></pre></div></div></div><div class="SIntrapara">because <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones</code></span> is not defined at the point of
definition, so when Pyret evaluates <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link(1, ones)</code></span>, it complains
that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones</code></span> is not defined. However, it is being overly
conservative with our former definition: the use of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones</code></span> is
â€œunder a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span>â€, and hence wonâ€™t be needed until after the
definition of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones</code></span> is done, at which point <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones</code></span>
<span class="emph">will</span> be defined. We can indicate this to Pyret by using the
keyword <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec ones = lz-link(1, lam(): ones end)</code></pre></div></div></div><div class="SIntrapara">Note that in Pyret, every <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun</code></span>
<span class="emph">implicitly</span> has a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec</code></span> beneath it, which is why we can
create recursive functions with aplomb.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p/><div class="SIntrapara">Earlier we said that we canâ€™t write
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones = link(1, ones)</code></pre></div></div></div><div class="SIntrapara">What if we tried to write
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec ones = link(1, ones)</code></pre></div></div></div><div class="SIntrapara">instead? Does this work and, if so, what value is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones</code></span> bound
to? If it doesnâ€™t work, does it fail to work for the same reason as
the definition without the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec</code></span>?</div></blockquote></blockquote><p/><div class="SIntrapara">Henceforth, we will use the shorthand [<a href="#%28part._lam-shorthand%29" data-pltdoc="x">A Helpful Shorthand for Anonymous Functions</a>]
instead. Therefore, we can rewrite the above definition as:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec ones = lz-link(1, {(): ones})</code></pre></div></div></div><div class="SIntrapara">Notice that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{(): â€¦}</code></span> defines an anonymous function of <span class="emph">no</span>
arguments. You canâ€™t leave out the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">()</code></span>! If you do, Pyret will
get confused about what your program means.</div><p/><div class="SIntrapara">Because functions are automatically recursive, when we write a
function to create a stream, we donâ€™t need to use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec</code></span>. Consider
this example:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun nats-from(n :: Number):
  lz-link(n, {(): nats-from(n + 1)})
end</code></pre></div></div></div><div class="SIntrapara">with which we can define the natural numbers:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nats = nats-from(0)</code></pre></div></div></div><div class="SIntrapara">Note that the definition of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nats</code></span> is not recursive itselfâ€”<wbr/>the
recursion is inside <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nats-from</code></span>â€”<wbr/>so we donâ€™t need to use
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec</code></span> to define <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nats</code></span>.</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Earlier, we said that every list is finite and hence eventually
terminates. How does this remark apply to streams, such as the
definition of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nats</code></span> above?</p></blockquote></blockquote><p/><div class="SIntrapara">The description of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones</code></span> is still a finite one; it simply
represents the <span class="emph">potential</span> for an infinite number of values. Note
that:
</div><div class="SIntrapara"><ol><li><p>A similar reasoning doesnâ€™t apply to lists because the rest of
the list has already been constructed; in contrast, placing a function
there creates the potential for a potentially unbounded amount of
computation to still be forthcoming.</p></li><li><p>That said, even with streams, in any given computation, we will
create only a finite prefix of the stream. However, we donâ€™t have to
prematurely decide how many; each client and use is welcome to extract
less or more, as needed.</p></li></ol></div><p/><div class="SIntrapara">Now weâ€™ve created multiple streams, but we still donâ€™t have an easy
way to â€œseeâ€ one. First weâ€™ll define the traditional list-like
selectors. Getting the first element works exactly as with lists:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun lz-first&lt;T&gt;(s :: Stream&lt;T&gt;) -&gt; T: s.h end</code></pre></div></div></div><div class="SIntrapara">In contrast, when trying to access the rest of the stream, all we get
out of the data structure is a thunk. To access the actual rest, we
need to <span style="font-style: italic">force</span> the thunk, which of course means applying it to no
arguments:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun lz-rest&lt;T&gt;(s :: Stream&lt;T&gt;) -&gt; Stream&lt;T&gt;: s.t() end</code></pre></div></div></div><p/><div class="SIntrapara">This is useful for examining individual values of the
stream. It is also useful to extract a finite prefix of
it (of a given size) as a (regular) list, which would be especially
handy for testing. Letâ€™s write that function:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun take&lt;T&gt;(n :: Number, s :: Stream&lt;T&gt;) -&gt; List&lt;T&gt;:
  if n == 0:
    empty
  else:
    link(lz-first(s), take(n - 1, lz-rest(s)))
  end
end</code></pre></div></div></div><div class="SIntrapara">If you pay close attention, youâ€™ll find that this body is not defined
by cases <span class="emph">over the structure of the (stream) input</span>â€”<wbr/>instead,
itâ€™s defined by the cases of the definition of a natural number (zero
or a successor). Weâ€™ll return to this below (<a href="#%28elem._lz-map2-def%29" data-pltdoc="x">&lt;<span style="font-style: italic">lz-map2-def</span>&gt;</a>).</div><p/><div class="SIntrapara">Now that we have this, we can use it for testing. Note that usually we
use our data to test our functions; here, weâ€™re using this function to
<span class="emph">test our data</span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  take(10, ones) is map(lam(_): 1 end, range(0, 10))
  take(10, nats) is range(0, 10)
  take(10, nats-from(1)) is map((_ + 1), range(0, 10))
end</code></pre></div></div></div><div class="SIntrapara"><span class="refelem"><span class="refcolumn"><span class="refcontent">The notation <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">(_ + 1)</code></span> defines a Pyret function of
one argument that adds <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span> to the given argument.</span></span></span></div><p/><div class="SIntrapara">Letâ€™s define one more function: the equivalent of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span> over
streams. For reasons that will soon become obvious, weâ€™ll define a
version that takes two lists and applies the first argument to them
pointwise:
</div><div class="SIntrapara"><a name="(elem._lz-map2-def)"/>&lt;<span style="font-style: italic">lz-map2-def</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun lz-map2&lt;A, B, C&gt;(
    f :: (A, B -&gt; C),
    s1 :: Stream&lt;A&gt;,
    s2 :: Stream&lt;B&gt;) -&gt; Stream&lt;C&gt;:
  lz-link(
    f(lz-first(s1), lz-first(s2)),
    {(): lz-map2(f, lz-rest(s1), lz-rest(s2))})
end</code></pre></div></div></div><div class="SIntrapara">Now we can see our earlier remark about the structure of the function
driven home especially clearly. Whereas a traditional <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span> over
lists would have two cases, here we have only one case because the
data definition (<a href="#%28elem._stream-type-def%29" data-pltdoc="x">&lt;<span style="font-style: italic">stream-type-def</span>&gt;</a>) has only one case!
What is the consequence of this? In a traditional <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span>, one case
looks like the above, but the other case corresponds to the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>
input, for which it produces the same output. Here, because the stream
never terminates, mapping over it doesnâ€™t either, and the structure of
the function reflects this.<span class="refelem"><span class="refcolumn"><span class="refcontent">This raises a much subtler
problem: if the functionâ€™s body doesnâ€™t have base- and
inductive-cases, how can we perform an inductive proof over it? The
short answer is we canâ€™t: we must instead use
<a href="glossary.html#%28elem._glossary-coinduction%29" data-pltdoc="x">â˜› <span style="font-style: italic">coinduction</span></a>.</span></span></span></div><p/><div class="SIntrapara">Why did we define <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lz-map2</code></span> instead of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lz-map</code></span>? Because it
enables us to write the following:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec fibs =
  lz-link(0,
    {(): lz-link(1,
          {(): lz-map2({(a :: Number, b :: Number): a + b},
                fibs,
            lz-rest(fibs))})})</code></pre></div></div></div><div class="SIntrapara">from which, of course, we can extract as many Fibonacci numbers as we
want!
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  take(10, fibs) is [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
end</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Define the equivalent of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>
for streams.</p></blockquote></blockquote><p>Streams and, more generally, infinite data structures that unfold on
demand are extremely valuable in programming. Consider, for instance,
the possible moves in a game. In some games, this can be infinite;
even if it is finite, for interesting games the combinatorics mean
that the tree is too large to feasibly store in memory. Therefore, the
programmer of the computerâ€™s intelligence must unfold the game tree
<span class="emph">on demand</span>.  Programming it by using the encoding we have
described above means the program describes the <span class="emph">entire</span> tree,
lazily, and the tree unfolds automatically on demand, relieving the
programmer of the burden of implementing such a strategy.</p><p>In some languages, such as Haskell, lazy evaluation is built in
<span class="emph">by default</span>. In such a language, there is no need to use
thunks. However, lazy evaluation places other burdens on the language,
which you can learn about in a programming-languages class.</p></section><section class="SsectionLevel4" id="section 8.1.4"><h4 class="heading">8.1.4<span class="stt">Â </span><a name="(part._d-dx-streams)"/>Combining Forces: Streams of Derivatives<span class="button-group"><a href="#(part._d-dx-streams)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>When we defined <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx</code></span>, we set <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">epsilon</code></span> to an arbitrary, high
value. We could instead think of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">epsilon</code></span> as itself a stream that
produces successively finer values; then, for instance, when the
difference in the value of the derivative becomes small enough, we can
decide we have a sufficient approximation to the derivative.</p><p>The first step is, therefore, to make <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">epsilon</code></span> some kind of
parameter rather than a global constant. That leaves open what kind of
parameter it should be (number or stream?) as well as when it should
be supplied.</p><p/><div class="SIntrapara">It makes most sense to consume this parameter after we have decided
what function we want to differentiate and at what value we want its
derivative; after all, the stream of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">epsilon</code></span> values may depend
on both. Thus, we get:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun d-dx(f :: (Number -&gt; Number)) -&gt;
    (Number -&gt; (Number -&gt; Number)):
  lam(x :: Number) -&gt; (Number -&gt; Number):
    lam(epsilon :: Number) -&gt; Number:
      (f(x + epsilon) - f(x)) / epsilon
    end
  end
end</code></pre></div></div></div><div class="SIntrapara">with which we can return to our <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">square</code></span> example:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx-square = d-dx(square)</code></pre></div></div></div><div class="SIntrapara">Note that at this point we have simply redefined <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx</code></span> without
any reference to streams: we have merely made a constant into a
parameter.</div><p/><div class="SIntrapara">Now letâ€™s define the stream of negative powers of ten:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">tenths = block:
  fun by-ten(d):
    new-denom = d / 10
    lz-link(new-denom, lam(): by-ten(new-denom) end)
  end
  by-ten(1)
end</code></pre></div></div></div><div class="SIntrapara">so that
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  take(3, tenths) is [list: 1/10, 1/100, 1/1000]
end</code></pre></div></div></div><div class="SIntrapara">For concreteness, letâ€™s pick an abscissa at which to compute the
numeric derivative of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">square</code></span>â€”<wbr/>say <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">10</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx-square-at-10 = d-dx-square(10)</code></pre></div></div></div><div class="SIntrapara">Recall, from the types, that this is now a function of type
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">(Number -&gt; Number)</code></span>: given a value for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">epsilon</code></span>, it computes
the derivative using that value.  We know, analytically, that the
value of this derivative should be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">20</code></span>. We can now (lazily) map
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">tenths</code></span> to provide increasingly better approximations for
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">epsilon</code></span> and see what happens:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lz-map(d-dx-square-at-10, tenths)</code></pre></div></div></div><div class="SIntrapara">Sure enough, the values we obtain are <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">20.1</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">20.01</code></span>,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">20.001</code></span>, and so on: progressively better numerical
approximations to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">20</code></span>.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Extend the above program to take a tolerance, and draw as many values
from the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">epsilon</code></span> stream as necessary until the difference
between successive approximations of the derivative fall within this
tolerance.</p></blockquote></blockquote></section>&#13;
<h4 class="heading">8.1.1<span class="stt">Â </span><a name="(part._fd-calculus)"/>A Little Calculus<span class="button-group"><a href="#(part._fd-calculus)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">If youâ€™ve studied the differential calculus, youâ€™ve come across
curious sytactic statements such as this:
</div><div class="SIntrapara"><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}{\frac{d}{dx}} x^2 = 2x\end{equation*}</p></div><div class="SIntrapara">Letâ€™s unpack what this means: the \(d/dx\), the \(x^2\), and the \(2x\).</div><p>First, letâ€™s take on the two expressions; weâ€™ll discuss one, and the
discussion will cover the other as well. The correct response to
â€œwhat does \(x^2\) mean?â€ is, of course, an error: it doesnâ€™t mean
anything, because \(x\) is an unbound identifier.</p><p/><div class="SIntrapara">So what is it <span class="emph">intended</span> to mean? The intent, clearly, is to
represent the function that squares its input, just as \(2x\) is meant
to be the function that doubles its input. We have nicer ways of
writing those:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sq(x :: Number) -&gt; Number: x * x end
fun dbl(x :: Number) -&gt; Number: 2 * x end</code></pre></div></div></div><div class="SIntrapara">and what weâ€™re really trying to say is that the \(d/dx\) (whatever
that is) of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sq</code></span> is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">dbl</code></span>.<span class="refelem"><span class="refcolumn"><span class="refcontent">Weâ€™re
assuming functions of arity one in the variable that is changing.</span></span></span></div><p/><div class="SIntrapara">So now letâ€™s unpack \(d/dx\), starting with its type. As the above
example illustrates, \(d/dx\) is really a <span class="emph">function from
functions to functions</span>. That is, we can write its type as follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx :: ((Number -&gt; Number) -&gt; (Number -&gt; Number))</code></pre></div></div></div><div class="SIntrapara">(This type might explain why your calculus course never explained this
operation this wayâ€”<wbr/>though itâ€™s not clear that obscuring its true
meaning is any better for your understanding.)</div><p>Let us now implement <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx</code></span>. Weâ€™ll implement <span class="emph">numerical</span>
differentiation, though in principle we could also implement
<span class="emph">symbolic </span> differentiationâ€”<wbr/>using rules you learned, e.g.,
given a polynomial, multiply by the exponent and reduce the exponent
by oneâ€”<wbr/>with a representation of expressions (a problem that will be covered in more detail in a future release).</p><p/><div class="SIntrapara">In general, numeric differentiation of a function at a point yields
the value of the derivative at that point. We have a handy formula for
it: the derivative of \(f\) at \(x\) is
</div><div class="SIntrapara"><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}\frac{f(x + \epsilon) - f(x)}{\epsilon}\end{equation*}</p></div><div class="SIntrapara">as \(\epsilon\) goes to zero in the limit. For now weâ€™ll give the
infinitesimal a small but fixed value, and later
[<a href="#%28part._d-dx-streams%29" data-pltdoc="x">Combining Forces: Streams of Derivatives</a>] see how we can improve on this.</div><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">epsilon = 0.00001</code></pre></div></div><p/><div class="SIntrapara">We can now translate the above formula into a function:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx-at :: (Number -&gt; Number), Number -&gt; Number

fun d-dx-at(f, x):
  (f(x + epsilon) - f(x)) / epsilon
end</code></pre></div></div></div><div class="SIntrapara">And sure enough, we can check and make sure it works as expected:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  d-dx-at(sq, 10) is-roughly dbl(10)
end</code></pre></div></div></div><div class="SIntrapara"><span class="refelem"><span class="refcolumn"><span class="refcontent">Confession: We chose the value of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">epsilon</code></span> so that the
default tolerance <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-roughly</code></span> works for this example.</span></span></span></div><p/><div class="SIntrapara">However, there is something unsatisfying about this. The function weâ€™ve written
clearly does not have the type we described earlier! What we wanted was an
operation that takes just a function, and represents the platonic notion of
differentiation; but weâ€™ve been forced, by the nature of numeric
differentiation, to describe the derivative <span class="emph">at a point</span>. We might
instead like to write something like this:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun d-dx(f):
  (f(x + epsilon) - f(x)) / epsilon
end</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Whatâ€™s the problem with the above definition?</p></blockquote></blockquote><p/><div class="SIntrapara">If you didnâ€™t notice, Pyret will soon tell you: <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x</code></span> isnâ€™t
bound. Indeed, what is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x</code></span>? Itâ€™s the point at which weâ€™re trying
to compute the numeric derivative. That is, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx</code></span> needs to
return not a number but a <span class="emph">function</span> (as the type indicates) that
will consume this <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x</code></span>:<span class="refelem"><span class="refcolumn"><span class="refcontent">â€œLambdas are relegated to
relative obscurity until Java makes them popular by not having
them.â€â€”<wbr/>James Iry,
<a href="https://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html">A
Brief, Incomplete, and Mostly Wrong History of Programming Languages</a></span></span></span>
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun d-dx(f):
  lam(x):
    (f(x + epsilon) - f(x)) / epsilon
  end
end</code></pre></div></div></div><div class="SIntrapara">If we want to be a little more explicit we can annotate the inner function:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun d-dx(f):
  lam(x :: Number) -&gt; Number:
    (f(x + epsilon) - f(x)) / epsilon
  end
end</code></pre></div></div></div><div class="SIntrapara">This is a special case of a concept useful in many programming contexts, which
we explore in more detail elsewhere: <a href="staging.html" data-pltdoc="x">Staging</a>.</div><p/><div class="SIntrapara">Sure enough, this definition now works. We can, for instance, test it
as follows (note the use of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-floor</code></span> to avoid numeric precision
issues from making our tests appear to fail):
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx-sq = d-dx(sq)

check:
  ins = [list: 0, 1, 10, 100]
  for map(n from ins):
    num-floor(d-dx-sq(n))
  end
  is
  for map(n from ins):
    num-floor(dbl(n))
  end
end</code></pre></div></div></div><div class="SIntrapara">Now we can return to the original example that launched this
investigation: what the sloppy and mysterious notation of math is
really trying to say is,
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx(lam(x): x * x end) = lam(x): 2 * x end</code></pre></div></div></div><div class="SIntrapara">or, in the notation of <a href="predicting-growth.html#%28part._math-anon-functions%29" data-pltdoc="x">A Notation for Functions</a>,
</div><div class="SIntrapara"><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}{\frac{d}{dx}} [x \rightarrow x^2] = [x \rightarrow 2x]\end{equation*}</p></div><div class="SIntrapara">Pity math textbooks for not wanting to tell us the truth!</div>&#13;
<h4 class="heading">8.1.2<span class="stt">Â </span><a name="(part._lam-shorthand)"/>A Helpful Shorthand for Anonymous Functions<span class="button-group"><a href="#(part._lam-shorthand)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">Pyret offers a shorter syntax for writing anonymous functions. Though,
stylistically, we generally avoid it so that our programs donâ€™t become
a jumble of special characters, sometimes itâ€™s particularly
convenient, as we will see below. This syntax is
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{(a): b}</code></pre></div></div></div><div class="SIntrapara">where <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a</code></span> is zero or more arguments and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b</code></span> is the body. For
instance, we can write <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam(x): x * x end</code></span> as
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{(x): x * x}</code></pre></div></div></div><div class="SIntrapara">where we can see the benefit of brevity. In particular, note that
there is no need for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">end</code></span>, because the braces take the place of
showing where the expression begins and ends. Similarly, we could have
written <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx</code></span> as
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun d-dx-short(f):
  {(x): (f(x + epsilon) - f(x)) / epsilon}
end</code></pre></div></div></div><div class="SIntrapara">but many readers would say this makes the function harder to read,
because the prominent <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span> makes clear that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx</code></span> returns
an (anonymous) function, whereas this syntax obscures it. Therefore,
we will usually only use this shorthand syntax for â€œone-linersâ€.</div>&#13;
<h4 class="heading">8.1.3<span class="stt">Â </span><a name="(part._streams-from-funs)"/>Streams From Functions<span class="button-group"><a href="#(part._streams-from-funs)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>People typically think of a function as serving one purpose: to
parameterize an expression. While that is both true and the most
common use of a function, it does not justify having a function of no
arguments, because that clearly parameterizes over nothing at all. Yet
functions of no argument also have a use, because functions actually
serve two purposes: to parameterize, <span class="emph">and to suspend evaluation
of the body until the function is applied</span>. In fact, these two uses
are orthogonal, in that one can employ one feature without the
other. Below, we will focus on delay without abstraction (the other
shows up in other computer science settings).</p><p>Letâ€™s consider the humble list. A list can be only finitely
long. However, there are many lists (or <span style="font-style: italic">sequences</span>) in nature
that have no natural upper bound: from mathematical objects (the
sequence of natural numbers) to natural ones (the sequence of hits to
a Web site). Rather than try to squeeze these unbounded lists into
bounded ones, letâ€™s look at how we might represent and program over
these unbounded lists.</p><p/><div class="SIntrapara">First, letâ€™s write a program to compute the sequence of natural
numbers:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun nats-from(n):
  link(n, nats-from(n + 1))
end</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Does this program have a problem?</p></blockquote></blockquote><p>While this represents our intent, it doesnâ€™t work: running itâ€”<wbr/>e.g.,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nats-from(0)</code></span>â€”<wbr/>creates an infinite loop evaluating
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nats-from</code></span> for every subsequent natural number. In other words,
we want to write something very like the above, but that doesnâ€™t recur
<span class="emph">until we want it to, i.e., on demand</span>. In other words, we want
the rest of the list to be <span style="font-style: italic">lazy</span>.</p><p>This is where our insight into functions comes in. A function, as we
have just noted, delays evaluation of its body until it is
applied. Therefore, a function would, in principle, defer the
invocation of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nats-from(n + 1)</code></span> until itâ€™s needed.</p><p/><div class="SIntrapara">Except, this creates a type problem: the second argument to
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> needs to be a list, and cannot be a function. Indeed,
because it must be a list, and every value that has been constructed
must be finite, every list is finite and eventually terminates in
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>. Therefore, we need a new data structure to represent the
links in these <span style="font-style: italic">lazy lists</span> (also known as <span style="font-style: italic">streams</span>):
</div><div class="SIntrapara"><a name="(elem._stream-type-def)"/>&lt;<span style="font-style: italic">stream-type-def</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Stream&lt;T&gt;:
  | lz-link(h :: T, t :: ( -&gt; Stream&lt;T&gt;))
end</code></pre></div></div></div><div class="SIntrapara">where the annotation <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">( -&gt; Stream&lt;T&gt;)</code></span> means a function from no
arguments (hence the lack of anything before <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">-&gt;</code></span>),
also known as a <span style="font-style: italic">thunk</span>. Note that the way we have
defined streams they <span class="emph">must</span> be infinite, since we have provided
no way to terminate them.</div><p/><div class="SIntrapara">Letâ€™s construct the simplest example we can, a stream of constant
values:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones = lz-link(1, lam(): ones end)</code></pre></div></div></div><div class="SIntrapara">Pyret will actually complain about this definition. Note that
the list equivalent of this also will not work:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones = link(1, ones)</code></pre></div></div></div><div class="SIntrapara">because <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones</code></span> is not defined at the point of
definition, so when Pyret evaluates <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link(1, ones)</code></span>, it complains
that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones</code></span> is not defined. However, it is being overly
conservative with our former definition: the use of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones</code></span> is
â€œunder a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span>â€, and hence wonâ€™t be needed until after the
definition of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones</code></span> is done, at which point <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones</code></span>
<span class="emph">will</span> be defined. We can indicate this to Pyret by using the
keyword <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec ones = lz-link(1, lam(): ones end)</code></pre></div></div></div><div class="SIntrapara">Note that in Pyret, every <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun</code></span>
<span class="emph">implicitly</span> has a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec</code></span> beneath it, which is why we can
create recursive functions with aplomb.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p/><div class="SIntrapara">Earlier we said that we canâ€™t write
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones = link(1, ones)</code></pre></div></div></div><div class="SIntrapara">What if we tried to write
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec ones = link(1, ones)</code></pre></div></div></div><div class="SIntrapara">instead? Does this work and, if so, what value is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones</code></span> bound
to? If it doesnâ€™t work, does it fail to work for the same reason as
the definition without the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec</code></span>?</div></blockquote></blockquote><p/><div class="SIntrapara">Henceforth, we will use the shorthand [<a href="#%28part._lam-shorthand%29" data-pltdoc="x">A Helpful Shorthand for Anonymous Functions</a>]
instead. Therefore, we can rewrite the above definition as:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec ones = lz-link(1, {(): ones})</code></pre></div></div></div><div class="SIntrapara">Notice that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{(): â€¦}</code></span> defines an anonymous function of <span class="emph">no</span>
arguments. You canâ€™t leave out the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">()</code></span>! If you do, Pyret will
get confused about what your program means.</div><p/><div class="SIntrapara">Because functions are automatically recursive, when we write a
function to create a stream, we donâ€™t need to use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec</code></span>. Consider
this example:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun nats-from(n :: Number):
  lz-link(n, {(): nats-from(n + 1)})
end</code></pre></div></div></div><div class="SIntrapara">with which we can define the natural numbers:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nats = nats-from(0)</code></pre></div></div></div><div class="SIntrapara">Note that the definition of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nats</code></span> is not recursive itselfâ€”<wbr/>the
recursion is inside <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nats-from</code></span>â€”<wbr/>so we donâ€™t need to use
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec</code></span> to define <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nats</code></span>.</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Earlier, we said that every list is finite and hence eventually
terminates. How does this remark apply to streams, such as the
definition of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nats</code></span> above?</p></blockquote></blockquote><p/><div class="SIntrapara">The description of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones</code></span> is still a finite one; it simply
represents the <span class="emph">potential</span> for an infinite number of values. Note
that:
</div><div class="SIntrapara"><ol><li><p>A similar reasoning doesnâ€™t apply to lists because the rest of
the list has already been constructed; in contrast, placing a function
there creates the potential for a potentially unbounded amount of
computation to still be forthcoming.</p></li><li><p>That said, even with streams, in any given computation, we will
create only a finite prefix of the stream. However, we donâ€™t have to
prematurely decide how many; each client and use is welcome to extract
less or more, as needed.</p></li></ol></div><p/><div class="SIntrapara">Now weâ€™ve created multiple streams, but we still donâ€™t have an easy
way to â€œseeâ€ one. First weâ€™ll define the traditional list-like
selectors. Getting the first element works exactly as with lists:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun lz-first&lt;T&gt;(s :: Stream&lt;T&gt;) -&gt; T: s.h end</code></pre></div></div></div><div class="SIntrapara">In contrast, when trying to access the rest of the stream, all we get
out of the data structure is a thunk. To access the actual rest, we
need to <span style="font-style: italic">force</span> the thunk, which of course means applying it to no
arguments:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun lz-rest&lt;T&gt;(s :: Stream&lt;T&gt;) -&gt; Stream&lt;T&gt;: s.t() end</code></pre></div></div></div><p/><div class="SIntrapara">This is useful for examining individual values of the
stream. It is also useful to extract a finite prefix of
it (of a given size) as a (regular) list, which would be especially
handy for testing. Letâ€™s write that function:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun take&lt;T&gt;(n :: Number, s :: Stream&lt;T&gt;) -&gt; List&lt;T&gt;:
  if n == 0:
    empty
  else:
    link(lz-first(s), take(n - 1, lz-rest(s)))
  end
end</code></pre></div></div></div><div class="SIntrapara">If you pay close attention, youâ€™ll find that this body is not defined
by cases <span class="emph">over the structure of the (stream) input</span>â€”<wbr/>instead,
itâ€™s defined by the cases of the definition of a natural number (zero
or a successor). Weâ€™ll return to this below (<a href="#%28elem._lz-map2-def%29" data-pltdoc="x">&lt;<span style="font-style: italic">lz-map2-def</span>&gt;</a>).</div><p/><div class="SIntrapara">Now that we have this, we can use it for testing. Note that usually we
use our data to test our functions; here, weâ€™re using this function to
<span class="emph">test our data</span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  take(10, ones) is map(lam(_): 1 end, range(0, 10))
  take(10, nats) is range(0, 10)
  take(10, nats-from(1)) is map((_ + 1), range(0, 10))
end</code></pre></div></div></div><div class="SIntrapara"><span class="refelem"><span class="refcolumn"><span class="refcontent">The notation <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">(_ + 1)</code></span> defines a Pyret function of
one argument that adds <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span> to the given argument.</span></span></span></div><p/><div class="SIntrapara">Letâ€™s define one more function: the equivalent of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span> over
streams. For reasons that will soon become obvious, weâ€™ll define a
version that takes two lists and applies the first argument to them
pointwise:
</div><div class="SIntrapara"><a name="(elem._lz-map2-def)"/>&lt;<span style="font-style: italic">lz-map2-def</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun lz-map2&lt;A, B, C&gt;(
    f :: (A, B -&gt; C),
    s1 :: Stream&lt;A&gt;,
    s2 :: Stream&lt;B&gt;) -&gt; Stream&lt;C&gt;:
  lz-link(
    f(lz-first(s1), lz-first(s2)),
    {(): lz-map2(f, lz-rest(s1), lz-rest(s2))})
end</code></pre></div></div></div><div class="SIntrapara">Now we can see our earlier remark about the structure of the function
driven home especially clearly. Whereas a traditional <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span> over
lists would have two cases, here we have only one case because the
data definition (<a href="#%28elem._stream-type-def%29" data-pltdoc="x">&lt;<span style="font-style: italic">stream-type-def</span>&gt;</a>) has only one case!
What is the consequence of this? In a traditional <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span>, one case
looks like the above, but the other case corresponds to the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>
input, for which it produces the same output. Here, because the stream
never terminates, mapping over it doesnâ€™t either, and the structure of
the function reflects this.<span class="refelem"><span class="refcolumn"><span class="refcontent">This raises a much subtler
problem: if the functionâ€™s body doesnâ€™t have base- and
inductive-cases, how can we perform an inductive proof over it? The
short answer is we canâ€™t: we must instead use
<a href="glossary.html#%28elem._glossary-coinduction%29" data-pltdoc="x">â˜› <span style="font-style: italic">coinduction</span></a>.</span></span></span></div><p/><div class="SIntrapara">Why did we define <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lz-map2</code></span> instead of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lz-map</code></span>? Because it
enables us to write the following:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec fibs =
  lz-link(0,
    {(): lz-link(1,
          {(): lz-map2({(a :: Number, b :: Number): a + b},
                fibs,
            lz-rest(fibs))})})</code></pre></div></div></div><div class="SIntrapara">from which, of course, we can extract as many Fibonacci numbers as we
want!
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  take(10, fibs) is [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
end</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Define the equivalent of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>
for streams.</p></blockquote></blockquote><p>Streams and, more generally, infinite data structures that unfold on
demand are extremely valuable in programming. Consider, for instance,
the possible moves in a game. In some games, this can be infinite;
even if it is finite, for interesting games the combinatorics mean
that the tree is too large to feasibly store in memory. Therefore, the
programmer of the computerâ€™s intelligence must unfold the game tree
<span class="emph">on demand</span>.  Programming it by using the encoding we have
described above means the program describes the <span class="emph">entire</span> tree,
lazily, and the tree unfolds automatically on demand, relieving the
programmer of the burden of implementing such a strategy.</p><p>In some languages, such as Haskell, lazy evaluation is built in
<span class="emph">by default</span>. In such a language, there is no need to use
thunks. However, lazy evaluation places other burdens on the language,
which you can learn about in a programming-languages class.</p>&#13;
<h4 class="heading">8.1.4<span class="stt">Â </span><a name="(part._d-dx-streams)"/>Combining Forces: Streams of Derivatives<span class="button-group"><a href="#(part._d-dx-streams)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>When we defined <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx</code></span>, we set <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">epsilon</code></span> to an arbitrary, high
value. We could instead think of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">epsilon</code></span> as itself a stream that
produces successively finer values; then, for instance, when the
difference in the value of the derivative becomes small enough, we can
decide we have a sufficient approximation to the derivative.</p><p>The first step is, therefore, to make <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">epsilon</code></span> some kind of
parameter rather than a global constant. That leaves open what kind of
parameter it should be (number or stream?) as well as when it should
be supplied.</p><p/><div class="SIntrapara">It makes most sense to consume this parameter after we have decided
what function we want to differentiate and at what value we want its
derivative; after all, the stream of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">epsilon</code></span> values may depend
on both. Thus, we get:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun d-dx(f :: (Number -&gt; Number)) -&gt;
    (Number -&gt; (Number -&gt; Number)):
  lam(x :: Number) -&gt; (Number -&gt; Number):
    lam(epsilon :: Number) -&gt; Number:
      (f(x + epsilon) - f(x)) / epsilon
    end
  end
end</code></pre></div></div></div><div class="SIntrapara">with which we can return to our <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">square</code></span> example:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx-square = d-dx(square)</code></pre></div></div></div><div class="SIntrapara">Note that at this point we have simply redefined <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx</code></span> without
any reference to streams: we have merely made a constant into a
parameter.</div><p/><div class="SIntrapara">Now letâ€™s define the stream of negative powers of ten:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">tenths = block:
  fun by-ten(d):
    new-denom = d / 10
    lz-link(new-denom, lam(): by-ten(new-denom) end)
  end
  by-ten(1)
end</code></pre></div></div></div><div class="SIntrapara">so that
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  take(3, tenths) is [list: 1/10, 1/100, 1/1000]
end</code></pre></div></div></div><div class="SIntrapara">For concreteness, letâ€™s pick an abscissa at which to compute the
numeric derivative of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">square</code></span>â€”<wbr/>say <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">10</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx-square-at-10 = d-dx-square(10)</code></pre></div></div></div><div class="SIntrapara">Recall, from the types, that this is now a function of type
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">(Number -&gt; Number)</code></span>: given a value for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">epsilon</code></span>, it computes
the derivative using that value.  We know, analytically, that the
value of this derivative should be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">20</code></span>. We can now (lazily) map
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">tenths</code></span> to provide increasingly better approximations for
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">epsilon</code></span> and see what happens:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lz-map(d-dx-square-at-10, tenths)</code></pre></div></div></div><div class="SIntrapara">Sure enough, the values we obtain are <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">20.1</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">20.01</code></span>,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">20.001</code></span>, and so on: progressively better numerical
approximations to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">20</code></span>.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Extend the above program to take a tolerance, and draw as many values
from the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">epsilon</code></span> stream as necessary until the difference
between successive approximations of the derivative fall within this
tolerance.</p></blockquote></blockquote>    
</body>
</html>