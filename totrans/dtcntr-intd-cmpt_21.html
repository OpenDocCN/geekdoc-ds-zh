<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>8.1Â Functions as DatağŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>8.1Â Functions as DatağŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/func-as-data.html">https://dcic-world.org/2025-08-27/func-as-data.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._fd-calculus%29" class="toclink" data-pltdoc="x">8.1.1Â A Little Calculus</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._lam-shorthand%29" class="toclink" data-pltdoc="x">8.1.2Â A Helpful Shorthand for Anonymous Functions</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._streams-from-funs%29" class="toclink" data-pltdoc="x">8.1.3Â Streams From Functions</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._d-dx-streams%29" class="toclink" data-pltdoc="x">8.1.4Â Combining Forces: Streams of Derivatives</a></p></td></tr></table><p>Itâ€™s interesting to consider how expressive the little programming
weâ€™ve learned so far can be. To illustrate this, weâ€™ll work through a
few exercises of interesting concepts we can express using just
functions as values. Weâ€™ll write two quite different things, then show
how they converge nicely.</p><section class="SsectionLevel4" id="section 8.1.1"><h4 class="heading">8.1.1Â <a name="(part._fd-calculus)"/>A Little Calculus<a href="#(part._fd-calculus)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>If youâ€™ve studied the differential calculus, youâ€™ve come across
curious sytactic statements such as this:
</p><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}{\frac{d}{dx}} x^2 = 2x\end{equation*}</p><p>Letâ€™s unpack what this means: the \(d/dx\), the \(x^2\), and the \(2x\).</p><p>First, letâ€™s take on the two expressions; weâ€™ll discuss one, and the
discussion will cover the other as well. The correct response to
â€œwhat does \(x^2\) mean?â€ is, of course, an error: it doesnâ€™t mean
anything, because \(x\) is an unbound identifier.</p><p>So what is it intended to mean? The intent, clearly, is to
represent the function that squares its input, just as \(2x\) is meant
to be the function that doubles its input. We have nicer ways of
writing those:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sq(x :: Number) -&gt; Number: x * x end
fun dbl(x :: Number) -&gt; Number: 2 * x end</code></pre><p>and what weâ€™re really trying to say is that the \(d/dx\) (whatever
that is) of <code data-lang="pyret" class="sourceCode">sq</code> is <code data-lang="pyret" class="sourceCode">dbl</code>.Weâ€™re
assuming functions of arity one in the variable that is changing.</p><p>So now letâ€™s unpack \(d/dx\), starting with its type. As the above
example illustrates, \(d/dx\) is really a function from
functions to functions. That is, we can write its type as follows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx :: ((Number -&gt; Number) -&gt; (Number -&gt; Number))</code></pre><p>(This type might explain why your calculus course never explained this
operation this wayâ€”<wbr/>though itâ€™s not clear that obscuring its true
meaning is any better for your understanding.)</p><p>Let us now implement <code data-lang="pyret" class="sourceCode">d-dx</code>. Weâ€™ll implement numerical
differentiation, though in principle we could also implement
symbolic  differentiationâ€”<wbr/>using rules you learned, e.g.,
given a polynomial, multiply by the exponent and reduce the exponent
by oneâ€”<wbr/>with a representation of expressions (a problem that will be covered in more detail in a future release).</p><p>In general, numeric differentiation of a function at a point yields
the value of the derivative at that point. We have a handy formula for
it: the derivative of \(f\) at \(x\) is
</p><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}\frac{f(x + \epsilon) - f(x)}{\epsilon}\end{equation*}</p><p>as \(\epsilon\) goes to zero in the limit. For now weâ€™ll give the
infinitesimal a small but fixed value, and later
[<a href="#%28part._d-dx-streams%29" data-pltdoc="x">Combining Forces: Streams of Derivatives</a>] see how we can improve on this.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">epsilon = 0.00001</code></pre><p>We can now translate the above formula into a function:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx-at :: (Number -&gt; Number), Number -&gt; Number

fun d-dx-at(f, x):
  (f(x + epsilon) - f(x)) / epsilon
end</code></pre><p>And sure enough, we can check and make sure it works as expected:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  d-dx-at(sq, 10) is-roughly dbl(10)
end</code></pre><p>Confession: We chose the value of <code data-lang="pyret" class="sourceCode">epsilon</code> so that the
default tolerance <code data-lang="pyret" class="sourceCode">is-roughly</code> works for this example.</p><p>However, there is something unsatisfying about this. The function weâ€™ve written
clearly does not have the type we described earlier! What we wanted was an
operation that takes just a function, and represents the platonic notion of
differentiation; but weâ€™ve been forced, by the nature of numeric
differentiation, to describe the derivative at a point. We might
instead like to write something like this:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun d-dx(f):
  (f(x + epsilon) - f(x)) / epsilon
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Whatâ€™s the problem with the above definition?</p></blockquote></blockquote><p>If you didnâ€™t notice, Pyret will soon tell you: <code data-lang="pyret" class="sourceCode">x</code> isnâ€™t
bound. Indeed, what is <code data-lang="pyret" class="sourceCode">x</code>? Itâ€™s the point at which weâ€™re trying
to compute the numeric derivative. That is, <code data-lang="pyret" class="sourceCode">d-dx</code> needs to
return not a number but a function (as the type indicates) that
will consume this <code data-lang="pyret" class="sourceCode">x</code>:â€œLambdas are relegated to
relative obscurity until Java makes them popular by not having
them.â€â€”<wbr/>James Iry,
<a href="https://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html">A
Brief, Incomplete, and Mostly Wrong History of Programming Languages</a>
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun d-dx(f):
  lam(x):
    (f(x + epsilon) - f(x)) / epsilon
  end
end</code></pre><p>If we want to be a little more explicit we can annotate the inner function:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun d-dx(f):
  lam(x :: Number) -&gt; Number:
    (f(x + epsilon) - f(x)) / epsilon
  end
end</code></pre><p>This is a special case of a concept useful in many programming contexts, which
we explore in more detail elsewhere: <a href="staging.html" data-pltdoc="x">Staging</a>.</p><p>Sure enough, this definition now works. We can, for instance, test it
as follows (note the use of <code data-lang="pyret" class="sourceCode">num-floor</code> to avoid numeric precision
issues from making our tests appear to fail):
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx-sq = d-dx(sq)

check:
  ins = [list: 0, 1, 10, 100]
  for map(n from ins):
    num-floor(d-dx-sq(n))
  end
  is
  for map(n from ins):
    num-floor(dbl(n))
  end
end</code></pre><p>Now we can return to the original example that launched this
investigation: what the sloppy and mysterious notation of math is
really trying to say is,
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx(lam(x): x * x end) = lam(x): 2 * x end</code></pre><p>or, in the notation of <a href="predicting-growth.html#%28part._math-anon-functions%29" data-pltdoc="x">A Notation for Functions</a>,
</p><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}{\frac{d}{dx}} [x \rightarrow x^2] = [x \rightarrow 2x]\end{equation*}</p><p>Pity math textbooks for not wanting to tell us the truth!</p></section><section class="SsectionLevel4" id="section 8.1.2"><h4 class="heading">8.1.2Â <a name="(part._lam-shorthand)"/>A Helpful Shorthand for Anonymous Functions<a href="#(part._lam-shorthand)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Pyret offers a shorter syntax for writing anonymous functions. Though,
stylistically, we generally avoid it so that our programs donâ€™t become
a jumble of special characters, sometimes itâ€™s particularly
convenient, as we will see below. This syntax is
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{(a): b}</code></pre><p>where <code data-lang="pyret" class="sourceCode">a</code> is zero or more arguments and <code data-lang="pyret" class="sourceCode">b</code> is the body. For
instance, we can write <code data-lang="pyret" class="sourceCode">lam(x): x * x end</code> as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{(x): x * x}</code></pre><p>where we can see the benefit of brevity. In particular, note that
there is no need for <code data-lang="pyret" class="sourceCode">end</code>, because the braces take the place of
showing where the expression begins and ends. Similarly, we could have
written <code data-lang="pyret" class="sourceCode">d-dx</code> as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun d-dx-short(f):
  {(x): (f(x + epsilon) - f(x)) / epsilon}
end</code></pre><p>but many readers would say this makes the function harder to read,
because the prominent <code data-lang="pyret" class="sourceCode">lam</code> makes clear that <code data-lang="pyret" class="sourceCode">d-dx</code> returns
an (anonymous) function, whereas this syntax obscures it. Therefore,
we will usually only use this shorthand syntax for â€œone-linersâ€.</p></section><section class="SsectionLevel4" id="section 8.1.3"><h4 class="heading">8.1.3Â <a name="(part._streams-from-funs)"/>Streams From Functions<a href="#(part._streams-from-funs)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>People typically think of a function as serving one purpose: to
parameterize an expression. While that is both true and the most
common use of a function, it does not justify having a function of no
arguments, because that clearly parameterizes over nothing at all. Yet
functions of no argument also have a use, because functions actually
serve two purposes: to parameterize, and to suspend evaluation
of the body until the function is applied. In fact, these two uses
are orthogonal, in that one can employ one feature without the
other. Below, we will focus on delay without abstraction (the other
shows up in other computer science settings).</p><p>Letâ€™s consider the humble list. A list can be only finitely
long. However, there are many lists (or sequences) in nature
that have no natural upper bound: from mathematical objects (the
sequence of natural numbers) to natural ones (the sequence of hits to
a Web site). Rather than try to squeeze these unbounded lists into
bounded ones, letâ€™s look at how we might represent and program over
these unbounded lists.</p><p>First, letâ€™s write a program to compute the sequence of natural
numbers:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun nats-from(n):
  link(n, nats-from(n + 1))
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Does this program have a problem?</p></blockquote></blockquote><p>While this represents our intent, it doesnâ€™t work: running itâ€”<wbr/>e.g.,
<code data-lang="pyret" class="sourceCode">nats-from(0)</code>â€”<wbr/>creates an infinite loop evaluating
<code data-lang="pyret" class="sourceCode">nats-from</code> for every subsequent natural number. In other words,
we want to write something very like the above, but that doesnâ€™t recur
until we want it to, i.e., on demand. In other words, we want
the rest of the list to be lazy.</p><p>This is where our insight into functions comes in. A function, as we
have just noted, delays evaluation of its body until it is
applied. Therefore, a function would, in principle, defer the
invocation of <code data-lang="pyret" class="sourceCode">nats-from(n + 1)</code> until itâ€™s needed.</p><p>Except, this creates a type problem: the second argument to
<code data-lang="pyret" class="sourceCode">link</code> needs to be a list, and cannot be a function. Indeed,
because it must be a list, and every value that has been constructed
must be finite, every list is finite and eventually terminates in
<code data-lang="pyret" class="sourceCode">empty</code>. Therefore, we need a new data structure to represent the
links in these lazy lists (also known as streams):
</p><a name="(elem._stream-type-def)"/>&lt;stream-type-def&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Stream&lt;T&gt;:
  | lz-link(h :: T, t :: ( -&gt; Stream&lt;T&gt;))
end</code></pre><p>where the annotation <code data-lang="pyret" class="sourceCode">( -&gt; Stream&lt;T&gt;)</code> means a function from no
arguments (hence the lack of anything before <code data-lang="pyret" class="sourceCode">-&gt;</code>),
also known as a thunk. Note that the way we have
defined streams they must be infinite, since we have provided
no way to terminate them.</p><p>Letâ€™s construct the simplest example we can, a stream of constant
values:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones = lz-link(1, lam(): ones end)</code></pre><p>Pyret will actually complain about this definition. Note that
the list equivalent of this also will not work:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones = link(1, ones)</code></pre><p>because <code data-lang="pyret" class="sourceCode">ones</code> is not defined at the point of
definition, so when Pyret evaluates <code data-lang="pyret" class="sourceCode">link(1, ones)</code>, it complains
that <code data-lang="pyret" class="sourceCode">ones</code> is not defined. However, it is being overly
conservative with our former definition: the use of <code data-lang="pyret" class="sourceCode">ones</code> is
â€œunder a <code data-lang="pyret" class="sourceCode">lam</code>â€, and hence wonâ€™t be needed until after the
definition of <code data-lang="pyret" class="sourceCode">ones</code> is done, at which point <code data-lang="pyret" class="sourceCode">ones</code>
will be defined. We can indicate this to Pyret by using the
keyword <code data-lang="pyret" class="sourceCode">rec</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec ones = lz-link(1, lam(): ones end)</code></pre><p>Note that in Pyret, every <code data-lang="pyret" class="sourceCode">fun</code>
implicitly has a <code data-lang="pyret" class="sourceCode">rec</code> beneath it, which is why we can
create recursive functions with aplomb.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Earlier we said that we canâ€™t write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones = link(1, ones)</code></pre><p>What if we tried to write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec ones = link(1, ones)</code></pre><p>instead? Does this work and, if so, what value is <code data-lang="pyret" class="sourceCode">ones</code> bound
to? If it doesnâ€™t work, does it fail to work for the same reason as
the definition without the <code data-lang="pyret" class="sourceCode">rec</code>?</p></blockquote></blockquote><p>Henceforth, we will use the shorthand [<a href="#%28part._lam-shorthand%29" data-pltdoc="x">A Helpful Shorthand for Anonymous Functions</a>]
instead. Therefore, we can rewrite the above definition as:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec ones = lz-link(1, {(): ones})</code></pre><p>Notice that <code data-lang="pyret" class="sourceCode">{(): â€¦}</code> defines an anonymous function of no
arguments. You canâ€™t leave out the <code data-lang="pyret" class="sourceCode">()</code>! If you do, Pyret will
get confused about what your program means.</p><p>Because functions are automatically recursive, when we write a
function to create a stream, we donâ€™t need to use <code data-lang="pyret" class="sourceCode">rec</code>. Consider
this example:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun nats-from(n :: Number):
  lz-link(n, {(): nats-from(n + 1)})
end</code></pre><p>with which we can define the natural numbers:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nats = nats-from(0)</code></pre><p>Note that the definition of <code data-lang="pyret" class="sourceCode">nats</code> is not recursive itselfâ€”<wbr/>the
recursion is inside <code data-lang="pyret" class="sourceCode">nats-from</code>â€”<wbr/>so we donâ€™t need to use
<code data-lang="pyret" class="sourceCode">rec</code> to define <code data-lang="pyret" class="sourceCode">nats</code>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Earlier, we said that every list is finite and hence eventually
terminates. How does this remark apply to streams, such as the
definition of <code data-lang="pyret" class="sourceCode">ones</code> or <code data-lang="pyret" class="sourceCode">nats</code> above?</p></blockquote></blockquote><p>The description of <code data-lang="pyret" class="sourceCode">ones</code> is still a finite one; it simply
represents the potential for an infinite number of values. Note
that:
</p><ol><li><p>A similar reasoning doesnâ€™t apply to lists because the rest of
the list has already been constructed; in contrast, placing a function
there creates the potential for a potentially unbounded amount of
computation to still be forthcoming.</p></li><li><p>That said, even with streams, in any given computation, we will
create only a finite prefix of the stream. However, we donâ€™t have to
prematurely decide how many; each client and use is welcome to extract
less or more, as needed.</p></li></ol><p>Now weâ€™ve created multiple streams, but we still donâ€™t have an easy
way to â€œseeâ€ one. First weâ€™ll define the traditional list-like
selectors. Getting the first element works exactly as with lists:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun lz-first&lt;T&gt;(s :: Stream&lt;T&gt;) -&gt; T: s.h end</code></pre><p>In contrast, when trying to access the rest of the stream, all we get
out of the data structure is a thunk. To access the actual rest, we
need to force the thunk, which of course means applying it to no
arguments:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun lz-rest&lt;T&gt;(s :: Stream&lt;T&gt;) -&gt; Stream&lt;T&gt;: s.t() end</code></pre><p>This is useful for examining individual values of the
stream. It is also useful to extract a finite prefix of
it (of a given size) as a (regular) list, which would be especially
handy for testing. Letâ€™s write that function:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun take&lt;T&gt;(n :: Number, s :: Stream&lt;T&gt;) -&gt; List&lt;T&gt;:
  if n == 0:
    empty
  else:
    link(lz-first(s), take(n - 1, lz-rest(s)))
  end
end</code></pre><p>If you pay close attention, youâ€™ll find that this body is not defined
by cases over the structure of the (stream) inputâ€”<wbr/>instead,
itâ€™s defined by the cases of the definition of a natural number (zero
or a successor). Weâ€™ll return to this below (<a href="#%28elem._lz-map2-def%29" data-pltdoc="x">&lt;lz-map2-def&gt;</a>).</p><p>Now that we have this, we can use it for testing. Note that usually we
use our data to test our functions; here, weâ€™re using this function to
test our data:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  take(10, ones) is map(lam(_): 1 end, range(0, 10))
  take(10, nats) is range(0, 10)
  take(10, nats-from(1)) is map((_ + 1), range(0, 10))
end</code></pre><p>The notation <code data-lang="pyret" class="sourceCode">(_ + 1)</code> defines a Pyret function of
one argument that adds <code data-lang="pyret" class="sourceCode">1</code> to the given argument.</p><p>Letâ€™s define one more function: the equivalent of <code data-lang="pyret" class="sourceCode">map</code> over
streams. For reasons that will soon become obvious, weâ€™ll define a
version that takes two lists and applies the first argument to them
pointwise:
</p><a name="(elem._lz-map2-def)"/>&lt;lz-map2-def&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun lz-map2&lt;A, B, C&gt;(
    f :: (A, B -&gt; C),
    s1 :: Stream&lt;A&gt;,
    s2 :: Stream&lt;B&gt;) -&gt; Stream&lt;C&gt;:
  lz-link(
    f(lz-first(s1), lz-first(s2)),
    {(): lz-map2(f, lz-rest(s1), lz-rest(s2))})
end</code></pre><p>Now we can see our earlier remark about the structure of the function
driven home especially clearly. Whereas a traditional <code data-lang="pyret" class="sourceCode">map</code> over
lists would have two cases, here we have only one case because the
data definition (<a href="#%28elem._stream-type-def%29" data-pltdoc="x">&lt;stream-type-def&gt;</a>) has only one case!
What is the consequence of this? In a traditional <code data-lang="pyret" class="sourceCode">map</code>, one case
looks like the above, but the other case corresponds to the <code data-lang="pyret" class="sourceCode">empty</code>
input, for which it produces the same output. Here, because the stream
never terminates, mapping over it doesnâ€™t either, and the structure of
the function reflects this.This raises a much subtler
problem: if the functionâ€™s body doesnâ€™t have base- and
inductive-cases, how can we perform an inductive proof over it? The
short answer is we canâ€™t: we must instead use
<a href="glossary.html#%28elem._glossary-coinduction%29" data-pltdoc="x">â˜› coinduction</a>.</p><p>Why did we define <code data-lang="pyret" class="sourceCode">lz-map2</code> instead of <code data-lang="pyret" class="sourceCode">lz-map</code>? Because it
enables us to write the following:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec fibs =
  lz-link(0,
    {(): lz-link(1,
          {(): lz-map2({(a :: Number, b :: Number): a + b},
                fibs,
            lz-rest(fibs))})})</code></pre><p>from which, of course, we can extract as many Fibonacci numbers as we
want!
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  take(10, fibs) is [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
end</code></pre><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Define the equivalent of <code data-lang="pyret" class="sourceCode">map</code> and <code data-lang="pyret" class="sourceCode">filter</code>
for streams.</p></blockquote></blockquote><p>Streams and, more generally, infinite data structures that unfold on
demand are extremely valuable in programming. Consider, for instance,
the possible moves in a game. In some games, this can be infinite;
even if it is finite, for interesting games the combinatorics mean
that the tree is too large to feasibly store in memory. Therefore, the
programmer of the computerâ€™s intelligence must unfold the game tree
on demand.  Programming it by using the encoding we have
described above means the program describes the entire tree,
lazily, and the tree unfolds automatically on demand, relieving the
programmer of the burden of implementing such a strategy.</p><p>In some languages, such as Haskell, lazy evaluation is built in
by default. In such a language, there is no need to use
thunks. However, lazy evaluation places other burdens on the language,
which you can learn about in a programming-languages class.</p></section><section class="SsectionLevel4" id="section 8.1.4"><h4 class="heading">8.1.4Â <a name="(part._d-dx-streams)"/>Combining Forces: Streams of Derivatives<a href="#(part._d-dx-streams)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>When we defined <code data-lang="pyret" class="sourceCode">d-dx</code>, we set <code data-lang="pyret" class="sourceCode">epsilon</code> to an arbitrary, high
value. We could instead think of <code data-lang="pyret" class="sourceCode">epsilon</code> as itself a stream that
produces successively finer values; then, for instance, when the
difference in the value of the derivative becomes small enough, we can
decide we have a sufficient approximation to the derivative.</p><p>The first step is, therefore, to make <code data-lang="pyret" class="sourceCode">epsilon</code> some kind of
parameter rather than a global constant. That leaves open what kind of
parameter it should be (number or stream?) as well as when it should
be supplied.</p><p>It makes most sense to consume this parameter after we have decided
what function we want to differentiate and at what value we want its
derivative; after all, the stream of <code data-lang="pyret" class="sourceCode">epsilon</code> values may depend
on both. Thus, we get:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun d-dx(f :: (Number -&gt; Number)) -&gt;
    (Number -&gt; (Number -&gt; Number)):
  lam(x :: Number) -&gt; (Number -&gt; Number):
    lam(epsilon :: Number) -&gt; Number:
      (f(x + epsilon) - f(x)) / epsilon
    end
  end
end</code></pre><p>with which we can return to our <code data-lang="pyret" class="sourceCode">square</code> example:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx-square = d-dx(square)</code></pre><p>Note that at this point we have simply redefined <code data-lang="pyret" class="sourceCode">d-dx</code> without
any reference to streams: we have merely made a constant into a
parameter.</p><p>Now letâ€™s define the stream of negative powers of ten:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">tenths = block:
  fun by-ten(d):
    new-denom = d / 10
    lz-link(new-denom, lam(): by-ten(new-denom) end)
  end
  by-ten(1)
end</code></pre><p>so that
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  take(3, tenths) is [list: 1/10, 1/100, 1/1000]
end</code></pre><p>For concreteness, letâ€™s pick an abscissa at which to compute the
numeric derivative of <code data-lang="pyret" class="sourceCode">square</code>â€”<wbr/>say <code data-lang="pyret" class="sourceCode">10</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx-square-at-10 = d-dx-square(10)</code></pre><p>Recall, from the types, that this is now a function of type
<code data-lang="pyret" class="sourceCode">(Number -&gt; Number)</code>: given a value for <code data-lang="pyret" class="sourceCode">epsilon</code>, it computes
the derivative using that value.  We know, analytically, that the
value of this derivative should be <code data-lang="pyret" class="sourceCode">20</code>. We can now (lazily) map
<code data-lang="pyret" class="sourceCode">tenths</code> to provide increasingly better approximations for
<code data-lang="pyret" class="sourceCode">epsilon</code> and see what happens:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lz-map(d-dx-square-at-10, tenths)</code></pre><p>Sure enough, the values we obtain are <code data-lang="pyret" class="sourceCode">20.1</code>, <code data-lang="pyret" class="sourceCode">20.01</code>,
<code data-lang="pyret" class="sourceCode">20.001</code>, and so on: progressively better numerical
approximations to <code data-lang="pyret" class="sourceCode">20</code>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Extend the above program to take a tolerance, and draw as many values
from the <code data-lang="pyret" class="sourceCode">epsilon</code> stream as necessary until the difference
between successive approximations of the derivative fall within this
tolerance.</p></blockquote></blockquote></section>&#13;
<h4 class="heading">8.1.1Â <a name="(part._fd-calculus)"/>A Little Calculus<a href="#(part._fd-calculus)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>If youâ€™ve studied the differential calculus, youâ€™ve come across
curious sytactic statements such as this:
</p><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}{\frac{d}{dx}} x^2 = 2x\end{equation*}</p><p>Letâ€™s unpack what this means: the \(d/dx\), the \(x^2\), and the \(2x\).</p><p>First, letâ€™s take on the two expressions; weâ€™ll discuss one, and the
discussion will cover the other as well. The correct response to
â€œwhat does \(x^2\) mean?â€ is, of course, an error: it doesnâ€™t mean
anything, because \(x\) is an unbound identifier.</p><p>So what is it intended to mean? The intent, clearly, is to
represent the function that squares its input, just as \(2x\) is meant
to be the function that doubles its input. We have nicer ways of
writing those:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sq(x :: Number) -&gt; Number: x * x end
fun dbl(x :: Number) -&gt; Number: 2 * x end</code></pre><p>and what weâ€™re really trying to say is that the \(d/dx\) (whatever
that is) of <code data-lang="pyret" class="sourceCode">sq</code> is <code data-lang="pyret" class="sourceCode">dbl</code>.Weâ€™re
assuming functions of arity one in the variable that is changing.</p><p>So now letâ€™s unpack \(d/dx\), starting with its type. As the above
example illustrates, \(d/dx\) is really a function from
functions to functions. That is, we can write its type as follows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx :: ((Number -&gt; Number) -&gt; (Number -&gt; Number))</code></pre><p>(This type might explain why your calculus course never explained this
operation this wayâ€”<wbr/>though itâ€™s not clear that obscuring its true
meaning is any better for your understanding.)</p><p>Let us now implement <code data-lang="pyret" class="sourceCode">d-dx</code>. Weâ€™ll implement numerical
differentiation, though in principle we could also implement
symbolic  differentiationâ€”<wbr/>using rules you learned, e.g.,
given a polynomial, multiply by the exponent and reduce the exponent
by oneâ€”<wbr/>with a representation of expressions (a problem that will be covered in more detail in a future release).</p><p>In general, numeric differentiation of a function at a point yields
the value of the derivative at that point. We have a handy formula for
it: the derivative of \(f\) at \(x\) is
</p><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}\frac{f(x + \epsilon) - f(x)}{\epsilon}\end{equation*}</p><p>as \(\epsilon\) goes to zero in the limit. For now weâ€™ll give the
infinitesimal a small but fixed value, and later
[<a href="#%28part._d-dx-streams%29" data-pltdoc="x">Combining Forces: Streams of Derivatives</a>] see how we can improve on this.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">epsilon = 0.00001</code></pre><p>We can now translate the above formula into a function:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx-at :: (Number -&gt; Number), Number -&gt; Number

fun d-dx-at(f, x):
  (f(x + epsilon) - f(x)) / epsilon
end</code></pre><p>And sure enough, we can check and make sure it works as expected:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  d-dx-at(sq, 10) is-roughly dbl(10)
end</code></pre><p>Confession: We chose the value of <code data-lang="pyret" class="sourceCode">epsilon</code> so that the
default tolerance <code data-lang="pyret" class="sourceCode">is-roughly</code> works for this example.</p><p>However, there is something unsatisfying about this. The function weâ€™ve written
clearly does not have the type we described earlier! What we wanted was an
operation that takes just a function, and represents the platonic notion of
differentiation; but weâ€™ve been forced, by the nature of numeric
differentiation, to describe the derivative at a point. We might
instead like to write something like this:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun d-dx(f):
  (f(x + epsilon) - f(x)) / epsilon
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Whatâ€™s the problem with the above definition?</p></blockquote></blockquote><p>If you didnâ€™t notice, Pyret will soon tell you: <code data-lang="pyret" class="sourceCode">x</code> isnâ€™t
bound. Indeed, what is <code data-lang="pyret" class="sourceCode">x</code>? Itâ€™s the point at which weâ€™re trying
to compute the numeric derivative. That is, <code data-lang="pyret" class="sourceCode">d-dx</code> needs to
return not a number but a function (as the type indicates) that
will consume this <code data-lang="pyret" class="sourceCode">x</code>:â€œLambdas are relegated to
relative obscurity until Java makes them popular by not having
them.â€â€”<wbr/>James Iry,
<a href="https://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html">A
Brief, Incomplete, and Mostly Wrong History of Programming Languages</a>
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun d-dx(f):
  lam(x):
    (f(x + epsilon) - f(x)) / epsilon
  end
end</code></pre><p>If we want to be a little more explicit we can annotate the inner function:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun d-dx(f):
  lam(x :: Number) -&gt; Number:
    (f(x + epsilon) - f(x)) / epsilon
  end
end</code></pre><p>This is a special case of a concept useful in many programming contexts, which
we explore in more detail elsewhere: <a href="staging.html" data-pltdoc="x">Staging</a>.</p><p>Sure enough, this definition now works. We can, for instance, test it
as follows (note the use of <code data-lang="pyret" class="sourceCode">num-floor</code> to avoid numeric precision
issues from making our tests appear to fail):
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx-sq = d-dx(sq)

check:
  ins = [list: 0, 1, 10, 100]
  for map(n from ins):
    num-floor(d-dx-sq(n))
  end
  is
  for map(n from ins):
    num-floor(dbl(n))
  end
end</code></pre><p>Now we can return to the original example that launched this
investigation: what the sloppy and mysterious notation of math is
really trying to say is,
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx(lam(x): x * x end) = lam(x): 2 * x end</code></pre><p>or, in the notation of <a href="predicting-growth.html#%28part._math-anon-functions%29" data-pltdoc="x">A Notation for Functions</a>,
</p><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}{\frac{d}{dx}} [x \rightarrow x^2] = [x \rightarrow 2x]\end{equation*}</p><p>Pity math textbooks for not wanting to tell us the truth!</p>&#13;
<h4 class="heading">8.1.2Â <a name="(part._lam-shorthand)"/>A Helpful Shorthand for Anonymous Functions<a href="#(part._lam-shorthand)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Pyret offers a shorter syntax for writing anonymous functions. Though,
stylistically, we generally avoid it so that our programs donâ€™t become
a jumble of special characters, sometimes itâ€™s particularly
convenient, as we will see below. This syntax is
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{(a): b}</code></pre><p>where <code data-lang="pyret" class="sourceCode">a</code> is zero or more arguments and <code data-lang="pyret" class="sourceCode">b</code> is the body. For
instance, we can write <code data-lang="pyret" class="sourceCode">lam(x): x * x end</code> as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{(x): x * x}</code></pre><p>where we can see the benefit of brevity. In particular, note that
there is no need for <code data-lang="pyret" class="sourceCode">end</code>, because the braces take the place of
showing where the expression begins and ends. Similarly, we could have
written <code data-lang="pyret" class="sourceCode">d-dx</code> as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun d-dx-short(f):
  {(x): (f(x + epsilon) - f(x)) / epsilon}
end</code></pre><p>but many readers would say this makes the function harder to read,
because the prominent <code data-lang="pyret" class="sourceCode">lam</code> makes clear that <code data-lang="pyret" class="sourceCode">d-dx</code> returns
an (anonymous) function, whereas this syntax obscures it. Therefore,
we will usually only use this shorthand syntax for â€œone-linersâ€.</p>&#13;
<h4 class="heading">8.1.3Â <a name="(part._streams-from-funs)"/>Streams From Functions<a href="#(part._streams-from-funs)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>People typically think of a function as serving one purpose: to
parameterize an expression. While that is both true and the most
common use of a function, it does not justify having a function of no
arguments, because that clearly parameterizes over nothing at all. Yet
functions of no argument also have a use, because functions actually
serve two purposes: to parameterize, and to suspend evaluation
of the body until the function is applied. In fact, these two uses
are orthogonal, in that one can employ one feature without the
other. Below, we will focus on delay without abstraction (the other
shows up in other computer science settings).</p><p>Letâ€™s consider the humble list. A list can be only finitely
long. However, there are many lists (or sequences) in nature
that have no natural upper bound: from mathematical objects (the
sequence of natural numbers) to natural ones (the sequence of hits to
a Web site). Rather than try to squeeze these unbounded lists into
bounded ones, letâ€™s look at how we might represent and program over
these unbounded lists.</p><p>First, letâ€™s write a program to compute the sequence of natural
numbers:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun nats-from(n):
  link(n, nats-from(n + 1))
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Does this program have a problem?</p></blockquote></blockquote><p>While this represents our intent, it doesnâ€™t work: running itâ€”<wbr/>e.g.,
<code data-lang="pyret" class="sourceCode">nats-from(0)</code>â€”<wbr/>creates an infinite loop evaluating
<code data-lang="pyret" class="sourceCode">nats-from</code> for every subsequent natural number. In other words,
we want to write something very like the above, but that doesnâ€™t recur
until we want it to, i.e., on demand. In other words, we want
the rest of the list to be lazy.</p><p>This is where our insight into functions comes in. A function, as we
have just noted, delays evaluation of its body until it is
applied. Therefore, a function would, in principle, defer the
invocation of <code data-lang="pyret" class="sourceCode">nats-from(n + 1)</code> until itâ€™s needed.</p><p>Except, this creates a type problem: the second argument to
<code data-lang="pyret" class="sourceCode">link</code> needs to be a list, and cannot be a function. Indeed,
because it must be a list, and every value that has been constructed
must be finite, every list is finite and eventually terminates in
<code data-lang="pyret" class="sourceCode">empty</code>. Therefore, we need a new data structure to represent the
links in these lazy lists (also known as streams):
</p><a name="(elem._stream-type-def)"/>&lt;stream-type-def&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Stream&lt;T&gt;:
  | lz-link(h :: T, t :: ( -&gt; Stream&lt;T&gt;))
end</code></pre><p>where the annotation <code data-lang="pyret" class="sourceCode">( -&gt; Stream&lt;T&gt;)</code> means a function from no
arguments (hence the lack of anything before <code data-lang="pyret" class="sourceCode">-&gt;</code>),
also known as a thunk. Note that the way we have
defined streams they must be infinite, since we have provided
no way to terminate them.</p><p>Letâ€™s construct the simplest example we can, a stream of constant
values:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones = lz-link(1, lam(): ones end)</code></pre><p>Pyret will actually complain about this definition. Note that
the list equivalent of this also will not work:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones = link(1, ones)</code></pre><p>because <code data-lang="pyret" class="sourceCode">ones</code> is not defined at the point of
definition, so when Pyret evaluates <code data-lang="pyret" class="sourceCode">link(1, ones)</code>, it complains
that <code data-lang="pyret" class="sourceCode">ones</code> is not defined. However, it is being overly
conservative with our former definition: the use of <code data-lang="pyret" class="sourceCode">ones</code> is
â€œunder a <code data-lang="pyret" class="sourceCode">lam</code>â€, and hence wonâ€™t be needed until after the
definition of <code data-lang="pyret" class="sourceCode">ones</code> is done, at which point <code data-lang="pyret" class="sourceCode">ones</code>
will be defined. We can indicate this to Pyret by using the
keyword <code data-lang="pyret" class="sourceCode">rec</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec ones = lz-link(1, lam(): ones end)</code></pre><p>Note that in Pyret, every <code data-lang="pyret" class="sourceCode">fun</code>
implicitly has a <code data-lang="pyret" class="sourceCode">rec</code> beneath it, which is why we can
create recursive functions with aplomb.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Earlier we said that we canâ€™t write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ones = link(1, ones)</code></pre><p>What if we tried to write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec ones = link(1, ones)</code></pre><p>instead? Does this work and, if so, what value is <code data-lang="pyret" class="sourceCode">ones</code> bound
to? If it doesnâ€™t work, does it fail to work for the same reason as
the definition without the <code data-lang="pyret" class="sourceCode">rec</code>?</p></blockquote></blockquote><p>Henceforth, we will use the shorthand [<a href="#%28part._lam-shorthand%29" data-pltdoc="x">A Helpful Shorthand for Anonymous Functions</a>]
instead. Therefore, we can rewrite the above definition as:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec ones = lz-link(1, {(): ones})</code></pre><p>Notice that <code data-lang="pyret" class="sourceCode">{(): â€¦}</code> defines an anonymous function of no
arguments. You canâ€™t leave out the <code data-lang="pyret" class="sourceCode">()</code>! If you do, Pyret will
get confused about what your program means.</p><p>Because functions are automatically recursive, when we write a
function to create a stream, we donâ€™t need to use <code data-lang="pyret" class="sourceCode">rec</code>. Consider
this example:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun nats-from(n :: Number):
  lz-link(n, {(): nats-from(n + 1)})
end</code></pre><p>with which we can define the natural numbers:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nats = nats-from(0)</code></pre><p>Note that the definition of <code data-lang="pyret" class="sourceCode">nats</code> is not recursive itselfâ€”<wbr/>the
recursion is inside <code data-lang="pyret" class="sourceCode">nats-from</code>â€”<wbr/>so we donâ€™t need to use
<code data-lang="pyret" class="sourceCode">rec</code> to define <code data-lang="pyret" class="sourceCode">nats</code>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Earlier, we said that every list is finite and hence eventually
terminates. How does this remark apply to streams, such as the
definition of <code data-lang="pyret" class="sourceCode">ones</code> or <code data-lang="pyret" class="sourceCode">nats</code> above?</p></blockquote></blockquote><p>The description of <code data-lang="pyret" class="sourceCode">ones</code> is still a finite one; it simply
represents the potential for an infinite number of values. Note
that:
</p><ol><li><p>A similar reasoning doesnâ€™t apply to lists because the rest of
the list has already been constructed; in contrast, placing a function
there creates the potential for a potentially unbounded amount of
computation to still be forthcoming.</p></li><li><p>That said, even with streams, in any given computation, we will
create only a finite prefix of the stream. However, we donâ€™t have to
prematurely decide how many; each client and use is welcome to extract
less or more, as needed.</p></li></ol><p>Now weâ€™ve created multiple streams, but we still donâ€™t have an easy
way to â€œseeâ€ one. First weâ€™ll define the traditional list-like
selectors. Getting the first element works exactly as with lists:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun lz-first&lt;T&gt;(s :: Stream&lt;T&gt;) -&gt; T: s.h end</code></pre><p>In contrast, when trying to access the rest of the stream, all we get
out of the data structure is a thunk. To access the actual rest, we
need to force the thunk, which of course means applying it to no
arguments:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun lz-rest&lt;T&gt;(s :: Stream&lt;T&gt;) -&gt; Stream&lt;T&gt;: s.t() end</code></pre><p>This is useful for examining individual values of the
stream. It is also useful to extract a finite prefix of
it (of a given size) as a (regular) list, which would be especially
handy for testing. Letâ€™s write that function:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun take&lt;T&gt;(n :: Number, s :: Stream&lt;T&gt;) -&gt; List&lt;T&gt;:
  if n == 0:
    empty
  else:
    link(lz-first(s), take(n - 1, lz-rest(s)))
  end
end</code></pre><p>If you pay close attention, youâ€™ll find that this body is not defined
by cases over the structure of the (stream) inputâ€”<wbr/>instead,
itâ€™s defined by the cases of the definition of a natural number (zero
or a successor). Weâ€™ll return to this below (<a href="#%28elem._lz-map2-def%29" data-pltdoc="x">&lt;lz-map2-def&gt;</a>).</p><p>Now that we have this, we can use it for testing. Note that usually we
use our data to test our functions; here, weâ€™re using this function to
test our data:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  take(10, ones) is map(lam(_): 1 end, range(0, 10))
  take(10, nats) is range(0, 10)
  take(10, nats-from(1)) is map((_ + 1), range(0, 10))
end</code></pre><p>The notation <code data-lang="pyret" class="sourceCode">(_ + 1)</code> defines a Pyret function of
one argument that adds <code data-lang="pyret" class="sourceCode">1</code> to the given argument.</p><p>Letâ€™s define one more function: the equivalent of <code data-lang="pyret" class="sourceCode">map</code> over
streams. For reasons that will soon become obvious, weâ€™ll define a
version that takes two lists and applies the first argument to them
pointwise:
</p><a name="(elem._lz-map2-def)"/>&lt;lz-map2-def&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun lz-map2&lt;A, B, C&gt;(
    f :: (A, B -&gt; C),
    s1 :: Stream&lt;A&gt;,
    s2 :: Stream&lt;B&gt;) -&gt; Stream&lt;C&gt;:
  lz-link(
    f(lz-first(s1), lz-first(s2)),
    {(): lz-map2(f, lz-rest(s1), lz-rest(s2))})
end</code></pre><p>Now we can see our earlier remark about the structure of the function
driven home especially clearly. Whereas a traditional <code data-lang="pyret" class="sourceCode">map</code> over
lists would have two cases, here we have only one case because the
data definition (<a href="#%28elem._stream-type-def%29" data-pltdoc="x">&lt;stream-type-def&gt;</a>) has only one case!
What is the consequence of this? In a traditional <code data-lang="pyret" class="sourceCode">map</code>, one case
looks like the above, but the other case corresponds to the <code data-lang="pyret" class="sourceCode">empty</code>
input, for which it produces the same output. Here, because the stream
never terminates, mapping over it doesnâ€™t either, and the structure of
the function reflects this.This raises a much subtler
problem: if the functionâ€™s body doesnâ€™t have base- and
inductive-cases, how can we perform an inductive proof over it? The
short answer is we canâ€™t: we must instead use
<a href="glossary.html#%28elem._glossary-coinduction%29" data-pltdoc="x">â˜› coinduction</a>.</p><p>Why did we define <code data-lang="pyret" class="sourceCode">lz-map2</code> instead of <code data-lang="pyret" class="sourceCode">lz-map</code>? Because it
enables us to write the following:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec fibs =
  lz-link(0,
    {(): lz-link(1,
          {(): lz-map2({(a :: Number, b :: Number): a + b},
                fibs,
            lz-rest(fibs))})})</code></pre><p>from which, of course, we can extract as many Fibonacci numbers as we
want!
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  take(10, fibs) is [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
end</code></pre><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Define the equivalent of <code data-lang="pyret" class="sourceCode">map</code> and <code data-lang="pyret" class="sourceCode">filter</code>
for streams.</p></blockquote></blockquote><p>Streams and, more generally, infinite data structures that unfold on
demand are extremely valuable in programming. Consider, for instance,
the possible moves in a game. In some games, this can be infinite;
even if it is finite, for interesting games the combinatorics mean
that the tree is too large to feasibly store in memory. Therefore, the
programmer of the computerâ€™s intelligence must unfold the game tree
on demand.  Programming it by using the encoding we have
described above means the program describes the entire tree,
lazily, and the tree unfolds automatically on demand, relieving the
programmer of the burden of implementing such a strategy.</p><p>In some languages, such as Haskell, lazy evaluation is built in
by default. In such a language, there is no need to use
thunks. However, lazy evaluation places other burdens on the language,
which you can learn about in a programming-languages class.</p>&#13;
<h4 class="heading">8.1.4Â <a name="(part._d-dx-streams)"/>Combining Forces: Streams of Derivatives<a href="#(part._d-dx-streams)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>When we defined <code data-lang="pyret" class="sourceCode">d-dx</code>, we set <code data-lang="pyret" class="sourceCode">epsilon</code> to an arbitrary, high
value. We could instead think of <code data-lang="pyret" class="sourceCode">epsilon</code> as itself a stream that
produces successively finer values; then, for instance, when the
difference in the value of the derivative becomes small enough, we can
decide we have a sufficient approximation to the derivative.</p><p>The first step is, therefore, to make <code data-lang="pyret" class="sourceCode">epsilon</code> some kind of
parameter rather than a global constant. That leaves open what kind of
parameter it should be (number or stream?) as well as when it should
be supplied.</p><p>It makes most sense to consume this parameter after we have decided
what function we want to differentiate and at what value we want its
derivative; after all, the stream of <code data-lang="pyret" class="sourceCode">epsilon</code> values may depend
on both. Thus, we get:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun d-dx(f :: (Number -&gt; Number)) -&gt;
    (Number -&gt; (Number -&gt; Number)):
  lam(x :: Number) -&gt; (Number -&gt; Number):
    lam(epsilon :: Number) -&gt; Number:
      (f(x + epsilon) - f(x)) / epsilon
    end
  end
end</code></pre><p>with which we can return to our <code data-lang="pyret" class="sourceCode">square</code> example:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx-square = d-dx(square)</code></pre><p>Note that at this point we have simply redefined <code data-lang="pyret" class="sourceCode">d-dx</code> without
any reference to streams: we have merely made a constant into a
parameter.</p><p>Now letâ€™s define the stream of negative powers of ten:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">tenths = block:
  fun by-ten(d):
    new-denom = d / 10
    lz-link(new-denom, lam(): by-ten(new-denom) end)
  end
  by-ten(1)
end</code></pre><p>so that
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  take(3, tenths) is [list: 1/10, 1/100, 1/1000]
end</code></pre><p>For concreteness, letâ€™s pick an abscissa at which to compute the
numeric derivative of <code data-lang="pyret" class="sourceCode">square</code>â€”<wbr/>say <code data-lang="pyret" class="sourceCode">10</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx-square-at-10 = d-dx-square(10)</code></pre><p>Recall, from the types, that this is now a function of type
<code data-lang="pyret" class="sourceCode">(Number -&gt; Number)</code>: given a value for <code data-lang="pyret" class="sourceCode">epsilon</code>, it computes
the derivative using that value.  We know, analytically, that the
value of this derivative should be <code data-lang="pyret" class="sourceCode">20</code>. We can now (lazily) map
<code data-lang="pyret" class="sourceCode">tenths</code> to provide increasingly better approximations for
<code data-lang="pyret" class="sourceCode">epsilon</code> and see what happens:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lz-map(d-dx-square-at-10, tenths)</code></pre><p>Sure enough, the values we obtain are <code data-lang="pyret" class="sourceCode">20.1</code>, <code data-lang="pyret" class="sourceCode">20.01</code>,
<code data-lang="pyret" class="sourceCode">20.001</code>, and so on: progressively better numerical
approximations to <code data-lang="pyret" class="sourceCode">20</code>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Extend the above program to take a tolerance, and draw as many values
from the <code data-lang="pyret" class="sourceCode">epsilon</code> stream as necessary until the difference
between successive approximations of the derivative fall within this
tolerance.</p></blockquote></blockquote>    
</body>
</html>