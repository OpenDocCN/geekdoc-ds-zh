["```cpp\nconst int N = (1 << 16); alignas(32) int a[N];   for (int i = 0; i < N; i++)  a[i] = rand(); \n```", "```cpp\nint argmin(int *a, int n) {  int k = 0;   for (int i = 0; i < n; i++) if (a[i] < a[k]) k = i;  return k; } \n```", "```cpp\nint argmin(int *a, int n) {  int k = std::min_element(a, a + n) - a; return k; } \n```", "```cpp\ntypedef __m256i reg;   int argmin(int *a, int n) {  // indices on the current iteration reg cur = _mm256_setr_epi32(0, 1, 2, 3, 4, 5, 6, 7); // the current minimum for each slice reg min = _mm256_set1_epi32(INT_MAX); // its index (argmin) for each slice reg idx = _mm256_setzero_si256();   for (int i = 0; i < n; i += 8) { // load a new SIMD block reg x = _mm256_load_si256((reg*) &a[i]); // find the slices where the minimum is updated reg mask = _mm256_cmpgt_epi32(min, x); // update the indices idx = _mm256_blendv_epi8(idx, cur, mask); // update the minimum (can also similarly use a \"blend\" here, but min is faster) min = _mm256_min_epi32(x, min); // update the current indices const reg eight = _mm256_set1_epi32(8); cur = _mm256_add_epi32(cur, eight);       // // can also use a \"blend\" here, but min is faster }   // find the argmin in the \"min\" register and return its real index  int min_arr[8], idx_arr[8];  _mm256_storeu_si256((reg*) min_arr, min); _mm256_storeu_si256((reg*) idx_arr, idx);   int k = 0, m = min_arr[0];   for (int i = 1; i < 8; i++) if (min_arr[i] < m) m = min_arr[k = i];   return idx_arr[k]; } \n```", "```cpp\nint argmin(int *a, int n) {  int k = 0;   for (int i = 0; i < n; i++) if (a[i] < a[k]) [[unlikely]] k = i;  return k; } \n```", "```cpp\nint argmin(int *a, int n) {  int min = INT_MAX, idx = 0;  reg p = _mm256_set1_epi32(min);   for (int i = 0; i < n; i += 8) { reg y = _mm256_load_si256((reg*) &a[i]); reg mask = _mm256_cmpgt_epi32(p, y); if (!_mm256_testz_si256(mask, mask)) { [[unlikely]] for (int j = i; j < i + 8; j++) if (a[j] < min) min = a[idx = j]; p = _mm256_set1_epi32(min); } }  return idx; } \n```", "```cpp\nint argmin(int *a, int n) {  int min = INT_MAX, idx = 0;  reg p = _mm256_set1_epi32(min);   for (int i = 0; i < n; i += 16) { reg y1 = _mm256_load_si256((reg*) &a[i]); reg y2 = _mm256_load_si256((reg*) &a[i + 8]); reg y = _mm256_min_epi32(y1, y2); reg mask = _mm256_cmpgt_epi32(p, y); if (!_mm256_testz_si256(mask, mask)) { [[unlikely]] for (int j = i; j < i + 16; j++) if (a[j] < min) min = a[idx = j]; p = _mm256_set1_epi32(min); } }  return idx; } \n```", "```cpp\nint argmin(int *a, int n) {  int min = INT_MAX, idx = 0;  reg p = _mm256_set1_epi32(min);   for (int i = 0; i < n; i += 32) { reg y1 = _mm256_load_si256((reg*) &a[i]); reg y2 = _mm256_load_si256((reg*) &a[i + 8]); reg y3 = _mm256_load_si256((reg*) &a[i + 16]); reg y4 = _mm256_load_si256((reg*) &a[i + 24]); y1 = _mm256_min_epi32(y1, y2); y3 = _mm256_min_epi32(y3, y4); y1 = _mm256_min_epi32(y1, y3); reg mask = _mm256_cmpgt_epi32(p, y1); if (!_mm256_testz_si256(mask, mask)) { [[unlikely]] idx = i; for (int j = i; j < i + 32; j++) min = (a[j] < min ? a[j] : min); p = _mm256_set1_epi32(min); } }   for (int i = idx; i < idx + 31; i++) if (a[i] == min) return i;  return idx + 31; } \n```", "```cpp\nint argmin(int *a, int n) {  int needle = min(a, n); int idx = find(a, n, needle); return idx; } \n```", "```cpp\nconst int B = 256;   // returns the minimum and its first block pair<int, int> approx_argmin(int *a, int n) {  int res = INT_MAX, idx = 0; for (int i = 0; i < n; i += B) { int val = min(a + i, B); if (val < res) { res = val; idx = i; } } return {res, idx}; }   int argmin(int *a, int n) {  auto [needle, base] = approx_argmin(a, n); int idx = find(a + base, B, needle); return base + idx; } \n```", "```cpp\nalgorithm    rand   decr   reason for the performance difference\n-----------  -----  -----  -------------------------------------------------------------\nstd          0.28   0.28   \nscalar       1.54   1.89   efficient branch prediction\n+ hinted     1.95   0.75   wrong hint\nindex        8.17   8.12\nsimd         8.51   1.65   scalar-based argmin on each iteration\n+ ilp        10.22  1.74   ^ same\n+ optimized  22.44  2.70   ^ same, but faster because there are less inter-dependencies\nmin+find     18.21  12.92  find() has to scan the entire array\n+ blocked    22.23  19.29  we still have an optional horizontal minimum every B elements \n```"]