<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Branchless Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Branchless Programming</h1>
<blockquote>原文：<a href="https://en.algorithmica.org/hpc/pipelining/branchless/">https://en.algorithmica.org/hpc/pipelining/branchless/</a></blockquote><div id="search"><input id="search-bar" type="search" placeholder="Search this book…" oninput="search()"/><div id="search-count"/><div id="search-results"/></div><header><div class="info"/></header><article><p>As we established in <a href="../branching">the previous section</a>, branches that can’t be effectively predicted by the CPU are expensive as they may cause a long pipeline stall to fetch new instructions after a branch mispredict. In this section, we discuss the means of removing branches in the first place.</p><span class="anchor" id="predication"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/pipelining/branchless/#predication">#</a>Predication</h3><p>We are going to continue the same case study we’ve started before — we create an array of random numbers and sum up all its elements below 50:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">volatile</span> <span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span></code></pre></div><p>Our goal is to eliminate the branch caused by the <code>if</code> statement. We can try to get rid of it like this:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span></code></pre></div><p>The loop now takes ~7 cycles per element instead of the original ~14. Also, the performance remains constant if we change <code>50</code> to some other threshold, so it doesn’t depend on the branch probability.</p><p>But wait… shouldn’t there still be a branch? How does <code>(a[i] &lt; 50)</code> map to assembly?</p><p>There are no Boolean types in assembly, nor any instructions that yield either one or zero based on the result of the comparison, but we can compute it indirectly like this: <code>(a[i] - 50) &gt;&gt; 31</code>. This trick relies on the <a href="/hpc/arithmetic/integer">binary representation of integers</a>, specifically on the fact that if the expression <code>a[i] - 50</code> is negative (implying <code>a[i] &lt; 50</code>), then the highest bit of the result will be set to one, which we can then extract using a right-shift.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nf">mov</span>  <span class="nb">ebx</span><span class="p">,</span> <span class="nb">eax</span>   <span class="c1">; t = x</span>
</span></span><span class="line"><span class="cl"><span class="nf">sub</span>  <span class="nb">ebx</span><span class="p">,</span> <span class="mi">50</span>    <span class="c1">; t -= 50</span>
</span></span><span class="line"><span class="cl"><span class="nf">sar</span>  <span class="nb">ebx</span><span class="p">,</span> <span class="mi">31</span>    <span class="c1">; t &gt;&gt;= 31</span>
</span></span><span class="line"><span class="cl"><span class="nf">imul</span>  <span class="nb">eax</span><span class="p">,</span> <span class="nb">ebx</span>   <span class="c1">; x *= t</span>
</span></span></code></pre></div><p>Another, more complicated way to implement this whole sequence is to convert this sign bit into a mask and then use bitwise <code>and</code> instead of multiplication: <code>((a[i] - 50) &gt;&gt; 31 - 1) &amp; a[i]</code>. This makes the whole sequence one cycle faster, considering that, unlike other instructions, <code>imul</code> takes 3 cycles:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nf">mov</span>  <span class="nb">ebx</span><span class="p">,</span> <span class="nb">eax</span>   <span class="c1">; t = x</span>
</span></span><span class="line"><span class="cl"><span class="nf">sub</span>  <span class="nb">ebx</span><span class="p">,</span> <span class="mi">50</span>    <span class="c1">; t -= 50</span>
</span></span><span class="line"><span class="cl"><span class="nf">sar</span>  <span class="nb">ebx</span><span class="p">,</span> <span class="mi">31</span>    <span class="c1">; t &gt;&gt;= 31</span>
</span></span><span class="line"><span class="cl"><span class="c1">; imul  eax, ebx ; x *= t</span>
</span></span><span class="line"><span class="cl"><span class="nf">sub</span>  <span class="nb">ebx</span><span class="p">,</span> <span class="mi">1</span>     <span class="c1">; t -= 1 (causing underflow if t = 0)</span>
</span></span><span class="line"><span class="cl"><span class="nf">and</span>  <span class="nb">eax</span><span class="p">,</span> <span class="nb">ebx</span>   <span class="c1">; x &amp;= t</span>
</span></span></code></pre></div><p>Note that this optimization is not technically correct from the compiler’s perspective: for the 50 lowest representable integers — those in the $[-2^{31}, - 2^{31} + 49]$ range — the result will be wrong due to underflow. We know that all numbers are all between 0 and 100, and this won’t happen, but the compiler doesn’t.</p><p>But the compiler actually elects to do something different. Instead of going with this arithmetic trick, it used a special <code>cmov</code> (“conditional move”) instruction that assigns a value based on a condition (which is computed and checked using the flags register, the same way as for jumps):</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">0</span>      <span class="c1">; cmov doesn't support immediate values, so we need a zero register</span>
</span></span><span class="line"><span class="cl"><span class="nf">cmp</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">50</span>
</span></span><span class="line"><span class="cl"><span class="nf">cmovge</span>  <span class="nb">eax</span><span class="p">,</span> <span class="nb">ebx</span>    <span class="c1">; eax = (eax &gt;= 50 ? eax : ebx=0)</span>
</span></span></code></pre></div><p>So the code above is actually closer to using a ternary operator like this:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">50</span> <span class="o">?</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
</span></span></code></pre></div><p>Both variants are optimized by the compiler and produce the following assembly:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl">    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="o">-</span><span class="mi">4000000</span>
</span></span><span class="line"><span class="cl"><span class="nl">loop:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span>     <span class="nb">esi</span><span class="p">,</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rdx</span> <span class="o">+</span> <span class="nv">a</span> <span class="o">+</span> <span class="mi">4000000</span><span class="p">]</span>  <span class="c1">; load a[i]</span>
</span></span><span class="line"><span class="cl">    <span class="nf">cmp</span>     <span class="nb">esi</span><span class="p">,</span> <span class="mi">50</span>
</span></span><span class="line"><span class="cl">    <span class="nf">cmovge</span>  <span class="nb">esi</span><span class="p">,</span> <span class="nb">eax</span>                            <span class="c1">; esi = (esi &gt;= 50 ? esi : eax=0)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">add</span>     <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mi">12</span><span class="p">],</span> <span class="nb">esi</span>           <span class="c1">; s += esi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">add</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl">    <span class="nf">jnz</span>     <span class="nv">loop</span>                                <span class="c1">; "iterate while rdx is not zero"</span>
</span></span></code></pre></div><p>This general technique is called <em>predication</em>, and it is roughly equivalent to this algebraic trick:</p>$$
x = c \cdot a + (1 - c) \cdot b
$$<p>This way you can eliminate branching, but this comes at the cost of evaluating <em>both</em> branches and the <code>cmov</code> itself. Because evaluating the “&gt;=” branch costs nothing, the performance is exactly equal to <a href="../branching/#branch-prediction">the “always yes” case</a> in the branchy version.</p><span class="anchor" id="when-predication-is-beneficial"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/pipelining/branchless/#when-predication-is-beneficial">#</a>When Predication Is Beneficial</h3><p>Using predication eliminates <a href="../hazards">a control hazard</a> but introduces a data hazard. There is still a pipeline stall, but it is a cheaper one: you only need to wait for <code>cmov</code> to be resolved and not flush the entire pipeline in case of a mispredict.</p><p>However, there are many situations when it is more efficient to leave branchy code as it is. This is the case when the cost of computing <em>both</em> branches instead of just <em>one</em> outweighs the penalty for the potential branch mispredictions.</p><p>In our example, the branchy code wins when the branch can be predicted with a probability of more than ~75%.</p><p><figure><img src="../Images/2310bb67e7bb9ec6ac10dff44f8498e4.png" data-original-src="https://en.algorithmica.org/hpc/pipelining/img/branchy-vs-branchless.svg"/><figcaption/></figure></p><p>This 75% threshold is commonly used by the compilers as a heuristic for determining whether to use the <code>cmov</code> or not. Unfortunately, this probability is usually unknown at the compile time, so it needs to be provided in one of several ways:</p><ul><li>We can use <a href="/hpc/compilation/situational/#profile-guided-optimization">profile-guided optimization</a> which will decide for itself whether to use predication or not.</li><li>We can use <a href="../branching#hinting-likeliness-of-branches">likeliness attributes</a> and <a href="/hpc/compilation/situational">compiler-specific intrinsics</a> to hint at the likeliness of branches: <code>__builtin_expect_with_probability</code> in GCC and <code>__builtin_unpredictable</code> in Clang.</li><li>We can rewrite branchy code using the ternary operator or various arithmetic tricks, which acts as sort of an implicit contract between programmers and compilers: if the programmer wrote the code this way, then it was probably meant to be branchless.</li></ul><p>The “right way” is to use branching hints, but unfortunately, the support for them is lacking. Right now <a href="https://bugs.llvm.org/show_bug.cgi?id=40027">these hints seem to be lost</a> by the time the compiler back-end decides whether a <code>cmov</code> is more beneficial. There is <a href="https://discourse.llvm.org/t/rfc-cmov-vs-branch-optimization/6040">some progress</a> towards making it possible, but currently, there is no good way of forcing the compiler to generate branch-free code, so sometimes the best hope is to just write a small snippet in assembly.</p><span class="anchor" id="larger-examples"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/pipelining/branchless/#larger-examples">#</a>Larger Examples</h3><p><strong>Strings.</strong> Oversimplifying things, an <code>std::string</code> is comprised of a pointer to a null-terminated <code>char</code> array (also known as a “C-string”) allocated somewhere on the heap and one integer containing the string size.</p><p>A common value for a string is the empty string — which is also its default value. You also need to handle them somehow, and the idiomatic approach is to assign <code>nullptr</code> as the pointer and <code>0</code> as the string size, and then check if the pointer is null or if the size is zero at the beginning of every procedure involving strings.</p><p>However, this requires a separate branch, which is costly (unless the majority of strings are either empty or non-empty). To remove the check and thus also the branch, we can allocate a “zero C-string,” which is just a zero byte allocated somewhere, and then simply point all empty strings there. Now all string operations with empty strings have to read this useless zero byte, but this is still much cheaper than a branch misprediction.</p><p><strong>Binary search.</strong> The standard binary search <a href="/hpc/data-structures/binary-search">can be implemented</a> without branches, and on small arrays (that fit into cache) it works ~4x faster than the branchy <code>std::lower_bound</code>:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">lower_bound</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">t</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">half</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">base</span> <span class="o">+=</span> <span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">half</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">half</span><span class="p">;</span> <span class="c1">// will be replaced with a "cmov"
</span></span></span><span class="line"><span class="cl"><span class="c1"/>        <span class="n">len</span> <span class="o">-=</span> <span class="n">half</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Other than being more complex, it has another slight drawback in that it potentially does more comparisons (constant $\lceil \log_2 n \rceil$ instead of either $\lfloor \log_2 n \rfloor$ or $\lceil \log_2 n \rceil$) and can’t speculate on future memory reads (which acts as prefetching, so it loses on very large arrays).</p><p>In general, data structures are made branchless by implicitly or explicitly <em>padding</em> them so that their operations take a constant number of iterations. Refer to <a href="/hpc/data-structures/binary-search">the article</a> for more complex examples.</p><p><strong>Data-parallel programming.</strong> Branchless programming is very important for <a href="/hpc/simd">SIMD</a> applications because they don’t have branching in the first place.</p><p>In our array sum example, removing the <code>volatile</code> type qualifier from the accumulator allows the compiler to <a href="/hpc/simd/auto-vectorization">vectorize</a> the loop:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/* volatile */</span> <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span></code></pre></div><p>It now works in ~0.3 per element, which is mainly <a href="/hpc/cpu-cache/bandwidth">bottlenecked by the memory</a>.</p><p>The compiler is usually able to vectorize any loop that doesn’t have branches or dependencies between the iterations — and some specific small deviations from that, such as <a href="/hpc/simd/reduction">reductions</a> or simple loops that contain just one if-without-else. Vectorization of anything more complex is a very nontrivial problem, which may involve various techniques such as <a href="/hpc/simd/masking">masking</a> and <a href="/hpc/simd/shuffling">in-register permutations</a>.</p></article><div class="nextprev"><div class="left"><a href="https://en.algorithmica.org/hpc/pipelining/branching/" id="prev-article">← The Cost of Branching</a></div><div class="right"><a href="https://en.algorithmica.org/hpc/pipelining/tables/" id="next-article">Instruction Tables →</a></div></div>    
</body>
</html>