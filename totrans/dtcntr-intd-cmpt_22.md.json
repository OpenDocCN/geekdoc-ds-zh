["```py\ndata Queue<T>:\n  | queue(l :: List<T>)\nend\n```", "```py\nfun mk-mtq<T>() -> Queue<T>:\n  queue(empty)\nend\n\nfun is-mtq<T>(q :: Queue<T>) -> Boolean:\n  is-empty(q.l)\nend\n```", "```py\nenqueue :: <T> Queue<T>, T -> Queue<T>\n```", "```py\nfun enqueue(q, e):\n  queue(link(e, q.l))\nend\n```", "```py\nqpeek :: <T> Queue<T> -> T\nqrest :: <T> Queue<T> -> Queue<T>\n```", "```py\nq_ = mk-mtq()\nq3 = enqueue(q_, 3)\nm43 = enqueue(q3, 4)\nm543 = enqueue(m43, 5)\n\ncheck:\n  qpeek(q3) is 3\n  qpeek(m43) is 3\n  qpeek(m543) is 3\nend\n\ncheck:\n  qrest(q3) is mk-mtq()\n  qrest(m43) is enqueue(mk-mtq(), 4)\n  qrest(m543) is enqueue(enqueue(mk-mtq(), 4), 5)\nend\n```", "```py\nfun qpeek(q):\n  if is-mtq(q):\n    raise(\"can't peek an empty queue\")\n  else:\n    q.l.get(q.l.length() - 1)\n  end\nend\n\nfun qrest(q):\n  fun safe-rest(l :: List<T>) -> List<T>:\n    cases (List) l:\n      | empty => raise(\"can't dequeue an empty queue\")\n      | link(f, r) => r\n    end\n  end\n  queue(safe-rest(q.l.reverse()).reverse())\nend\n```", "```py\ndata Dequeued<T>:\n  | none-left\n  | elt-and-q(e :: T, q :: Queue<T>)\nend\n```", "```py\ninclude pick\n```", "```py\ndequeue :: <T> Queue<T> -> Pick<T, Queue<T>>\n```", "```py\ncheck:\n  dequeue(q_) is pick-none\n  dequeue(q3) is pick-some(3, mk-mtq())\n  dequeue(m43) is pick-some(3, enqueue(mk-mtq(), 4))\n  dequeue(m543) is pick-some(3, enqueue(enqueue(mk-mtq(), 4), 5))\nend\n```", "```py\nfun dequeue<T>(q):\n  rev = q.l.reverse()\n  cases (List) rev:\n    | empty => pick-none\n    | link(f, r) =>\n      pick-some(f, queue(r.reverse()))\n  end\nend\n```", "```py\n{1; 2}\n{3; 4; 5}\n{1 + 2; 3}\n{6}\n{}\n```", "```py\n{a; b} = {1; 2}\n```", "```py\n{c; d; e} = {1 + 2; 6 - 2; 5}\n```", "```py\n> > {p; q} = {1}\n> > {p} = {1; 2}\n> > {p} = 1\n> > ```", "```py\n> > p = {1; 2}\n> > ```", "```py\nfun dequeue-tuple<T>(q :: Queue<T>) -> {T; Queue<T>}:\n  rev = q.l.reverse()\n  cases (List) rev:\n    | empty => raise(\"can't dequeue an empty queue\")\n    | link(f, r) =>\n      {f; queue(r.reverse())}\n  end\nend\n\ncheck:\n  dequeue-tuple(q3) is {3; mk-mtq()}\n  dequeue-tuple(m43) is {3; enqueue(mk-mtq(), 4)}\n  dequeue-tuple(m543) is {3; enqueue(enqueue(mk-mtq(), 4), 5)}\nend\n```", "```py\nfun q2l<T>(q :: Queue<T>) -> List<T>:\n  if is-mtq(q):\n    empty\n  else:\n    {e; rq} = dequeue-tuple(q)\n    link(e, q2l(rq))\n  end\nend\n\ncheck:\n  q2l(mk-mtq()) is empty\n  q2l(q3) is [list: 3]\n  q2l(m43) is [list: 3, 4]\n  q2l(m543) is [list: 3, 4, 5]\nend\n```", "```py\ndata Queue<T>:\n  | queue(l :: List<T>) with:\n    method pick(self):\n      rev = self.l.reverse()\n      cases (List) rev:\n        | empty => pick-none\n        | link(f, r) =>\n          pick-some(f, queue(r.reverse()))\n      end\n    end\nend\n```", "```py\nfun q2lm<T>(c :: Queue<T>) -> List<T>:\n  cases (Pick) c.pick():\n    | pick-none => empty\n    | pick-some(e, r) => link(e, q2lm(r))\n  end\nend\n\ncheck:\n  q2lm(m543)\nend\n```", "```py\nfun pick2l<T>(c) -> List<T>:\n  cases (Pick) c.pick():\n    | pick-none => empty\n    | pick-some(e, r) => link(e, pick2l(r))\n  end\nend\n```", "```py\nimport sets as S    # put this at the top of the file\n\ncheck:\n  pick2l([S.set: 3, 4, 5]).sort() is [list: 3, 4, 5]\n  pick2l(m543) is [list: 3, 4, 5]\nend\n```", "```py\ndata Queue<T>:\n  | queue(l :: List<T>)\nend\n```", "```py\nfun mk-mtq<T>() -> Queue<T>:\n  queue(empty)\nend\n\nfun is-mtq<T>(q :: Queue<T>) -> Boolean:\n  is-empty(q.l)\nend\n```", "```py\nenqueue :: <T> Queue<T>, T -> Queue<T>\n```", "```py\nfun enqueue(q, e):\n  queue(link(e, q.l))\nend\n```", "```py\nqpeek :: <T> Queue<T> -> T\nqrest :: <T> Queue<T> -> Queue<T>\n```", "```py\nq_ = mk-mtq()\nq3 = enqueue(q_, 3)\nm43 = enqueue(q3, 4)\nm543 = enqueue(m43, 5)\n\ncheck:\n  qpeek(q3) is 3\n  qpeek(m43) is 3\n  qpeek(m543) is 3\nend\n\ncheck:\n  qrest(q3) is mk-mtq()\n  qrest(m43) is enqueue(mk-mtq(), 4)\n  qrest(m543) is enqueue(enqueue(mk-mtq(), 4), 5)\nend\n```", "```py\nfun qpeek(q):\n  if is-mtq(q):\n    raise(\"can't peek an empty queue\")\n  else:\n    q.l.get(q.l.length() - 1)\n  end\nend\n\nfun qrest(q):\n  fun safe-rest(l :: List<T>) -> List<T>:\n    cases (List) l:\n      | empty => raise(\"can't dequeue an empty queue\")\n      | link(f, r) => r\n    end\n  end\n  queue(safe-rest(q.l.reverse()).reverse())\nend\n```", "```py\ndata Dequeued<T>:\n  | none-left\n  | elt-and-q(e :: T, q :: Queue<T>)\nend\n```", "```py\ninclude pick\n```", "```py\ndequeue :: <T> Queue<T> -> Pick<T, Queue<T>>\n```", "```py\ncheck:\n  dequeue(q_) is pick-none\n  dequeue(q3) is pick-some(3, mk-mtq())\n  dequeue(m43) is pick-some(3, enqueue(mk-mtq(), 4))\n  dequeue(m543) is pick-some(3, enqueue(enqueue(mk-mtq(), 4), 5))\nend\n```", "```py\nfun dequeue<T>(q):\n  rev = q.l.reverse()\n  cases (List) rev:\n    | empty => pick-none\n    | link(f, r) =>\n      pick-some(f, queue(r.reverse()))\n  end\nend\n```", "```py\n{1; 2}\n{3; 4; 5}\n{1 + 2; 3}\n{6}\n{}\n```", "```py\n{a; b} = {1; 2}\n```", "```py\n{c; d; e} = {1 + 2; 6 - 2; 5}\n```", "```py\n> > {p; q} = {1}\n> > {p} = {1; 2}\n> > {p} = 1\n> > ```", "```py\n> > p = {1; 2}\n> > ```", "```py\nfun dequeue-tuple<T>(q :: Queue<T>) -> {T; Queue<T>}:\n  rev = q.l.reverse()\n  cases (List) rev:\n    | empty => raise(\"can't dequeue an empty queue\")\n    | link(f, r) =>\n      {f; queue(r.reverse())}\n  end\nend\n\ncheck:\n  dequeue-tuple(q3) is {3; mk-mtq()}\n  dequeue-tuple(m43) is {3; enqueue(mk-mtq(), 4)}\n  dequeue-tuple(m543) is {3; enqueue(enqueue(mk-mtq(), 4), 5)}\nend\n```", "```py\nfun q2l<T>(q :: Queue<T>) -> List<T>:\n  if is-mtq(q):\n    empty\n  else:\n    {e; rq} = dequeue-tuple(q)\n    link(e, q2l(rq))\n  end\nend\n\ncheck:\n  q2l(mk-mtq()) is empty\n  q2l(q3) is [list: 3]\n  q2l(m43) is [list: 3, 4]\n  q2l(m543) is [list: 3, 4, 5]\nend\n```", "```py\ndata Queue<T>:\n  | queue(l :: List<T>) with:\n    method pick(self):\n      rev = self.l.reverse()\n      cases (List) rev:\n        | empty => pick-none\n        | link(f, r) =>\n          pick-some(f, queue(r.reverse()))\n      end\n    end\nend\n```", "```py\nfun q2lm<T>(c :: Queue<T>) -> List<T>:\n  cases (Pick) c.pick():\n    | pick-none => empty\n    | pick-some(e, r) => link(e, q2lm(r))\n  end\nend\n\ncheck:\n  q2lm(m543)\nend\n```", "```py\nfun pick2l<T>(c) -> List<T>:\n  cases (Pick) c.pick():\n    | pick-none => empty\n    | pick-some(e, r) => link(e, pick2l(r))\n  end\nend\n```", "```py\nimport sets as S    # put this at the top of the file\n\ncheck:\n  pick2l([S.set: 3, 4, 5]).sort() is [list: 3, 4, 5]\n  pick2l(m543) is [list: 3, 4, 5]\nend\n```"]