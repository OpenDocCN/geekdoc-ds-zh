- en: Getting Accurate Results
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取准确结果
- en: 原文：[https://en.algorithmica.org/hpc/profiling/noise/](https://en.algorithmica.org/hpc/profiling/noise/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/profiling/noise/](https://en.algorithmica.org/hpc/profiling/noise/)
- en: It is not an uncommon for there to be two library algorithm implementations,
    each maintaining its own benchmarking code, and each claiming to be faster than
    the other. This confuses everyone involved, especially the users, who have to
    somehow choose between the two.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个库算法实现并不罕见，每个都维护自己的基准测试代码，并声称比对方更快。这会让所有相关人员感到困惑，尤其是用户，他们必须在这两个之间做出某种选择。
- en: Situations like these are usually not caused by fraudulent actions by their
    authors; they just have different definitions of what “faster” means, and indeed,
    defining and using just one performance metric is often very problematic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况通常不是由其作者的欺诈行为引起的；他们只是对“更快”的定义不同，而且确实，定义和使用单一的性能指标通常非常有问题。
- en: '### [#](https://en.algorithmica.org/hpc/profiling/noise/#measuring-the-right-thing)Measuring
    the Right Thing'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/profiling/noise/#measuring-the-right-thing)正确测量事物'
- en: There are many things that can introduce bias into benchmarks.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多事情可能会引入基准的偏差。
- en: '**Differing datasets.** There are many algorithms whose performance somehow
    depends on the dataset distribution. In order to define, for example, what the
    fastest sorting, shortest path, or binary search algorithms are, you have to fix
    the dataset on which the algorithm is run.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**不同的数据集。**有许多算法的性能在某些方面依赖于数据集的分布。为了定义，例如，最快的排序、最短路径或二分搜索算法是什么，你必须固定算法运行的数据集。'
- en: 'This sometimes applies even to algorithms that process a single piece of input.
    For example, it is not a good idea to feed GCD implementations sequential numbers
    because it makes branches very predictable:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这有时甚至适用于处理单个输入的算法。例如，给GCD实现提供连续数字不是一个好主意，因为它使得分支非常可预测：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, if we sample these same numbers randomly, branch prediction becomes
    much harder, and the benchmark takes longer time, despite processing the same
    input, but in altered order:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们随机采样这些相同的数字，分支预测变得困难得多，尽管处理相同的输入，但顺序改变后，基准测试需要更长的时间：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Although the most logical choices for most cases is to just sample data uniformly
    at random, many real-world applications have distributions that are far from uniform,
    so you can’t pick just one. In general, a good benchmark should be application-specific,
    and use the dataset that is as representing of your real use case as possible.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管对于大多数情况来说，最合理的做法是随机均匀地采样数据，但许多现实世界的应用具有远非均匀的分布，因此不能只选择一个。一般来说，一个好的基准应该针对特定应用，并尽可能使用代表你实际用例的数据集。
- en: '**Multiple objectives.** Some algorithm design problems have more than one
    key objective. For example, hash tables, in addition to being highly dependant
    on the distribution of keys, also need to carefully balance:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**多个目标。**一些算法设计问题有多个关键目标。例如，除了高度依赖于键的分布外，哈希表还需要仔细平衡：'
- en: memory usage,
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存使用，
- en: latency of add query,
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加查询的延迟，
- en: latency of positive membership query,
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正成员查询的延迟，
- en: latency of negative membership query.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负成员查询的延迟。
- en: The only way to choose between hash table implementations is to try and put
    multiple variants into the application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 选择哈希表实现的方法是尝试将多个变体放入应用程序中。
- en: '**Latency vs Throughput.** Another aspect that people often overlook is that
    the execution time can be defined in more than one way, even for a single query.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**延迟与吞吐量。**人们常常忽视的另一个方面是，执行时间可以以多种方式定义，即使是针对单个查询。'
- en: 'When you write code like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写如下代码时：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: and then time the whole thing and divide it by the number of iterations, you
    are actually measuring the *throughput* of the query — how many operations it
    can process per unit of time. This is usually less than the time it actually takes
    to process one operation separately because of interleaving.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后测量整个过程并除以迭代次数，你实际上是在测量查询的*吞吐量*——它在单位时间内可以处理多少操作。由于交错，这通常小于单独处理一个操作所需的时间。
- en: 'To measure actual *latency*, you need to introduce a dependency between the
    invocations:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测量实际的*延迟*，你需要引入调用之间的依赖关系：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It usually makes the most difference in algorithms with possible pipeline stall
    issues, e.g., when comparing branchy and branch-free algorithms.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常在可能存在流水线停滞问题的算法中影响最大，例如，在比较有分支和无分支算法时。
- en: '**Cold cache.** Another source of bias is the *cold cache effect*, when memory
    reads initially take longer time because the required data is not in cache yet.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**冷缓存。**另一个偏差来源是**冷缓存效应**，当所需数据尚未在缓存中时，内存读取最初会花费更长的时间。'
- en: 'This is solved by making a *warm-up run* before starting measurements:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过在开始测量之前进行一次**预热运行**来解决：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It is also sometimes convenient to combine the warm-up run with answer validation,
    if it is more complicated than just computing some sort of checksum.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果答案验证比仅仅计算某种校验和更复杂，有时将预热运行与答案验证结合起来也很方便。
- en: '**Over-optimization.** Sometimes the benchmark is outright erroneous because
    the compiler just optimized the benchmarked code away. To prevent the compiler
    from cutting corners, you need to add checksums and either print them somewhere
    or add the `volatile` qualifier, which also prevents any sort of interleaving
    of loop iterations.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**过度优化。**有时基准测试完全是错误的，因为编译器只是优化了被基准测试的代码。为了防止编译器走捷径，你需要添加校验和，或者将其打印到某个地方，或者添加`volatile`限定符，这也会防止任何类型的循环迭代交错。'
- en: For algorithms that only write data, you can use the `__sync_synchronize()`
    intrinsic to add a memory fence and prevent the compiler from accumulating updates.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只写入数据的算法，你可以使用`__sync_synchronize()`内建函数来添加内存栅栏，并防止编译器累积更新。
- en: '### [#](https://en.algorithmica.org/hpc/profiling/noise/#reducing-noise)Reducing
    Noise'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/profiling/noise/#reducing-noise) 减少噪声'
- en: 'The issues we’ve described produce *bias* in measurements: they consistently
    give advantage to one algorithm over the other. There are other types of possible
    problems with benchmarking that result in either unpredictable skews or just completely
    random noise, thus increasing *variance*.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所描述的问题会在测量中产生**偏差**：它们始终使一个算法相对于另一个算法具有优势。基准测试中可能存在其他类型的问题，导致不可预测的偏差或完全随机的噪声，从而增加**方差**。
- en: 'These types of issues are caused by side effects and some sort of external
    noise, mostly due to noisy neighbors and CPU frequency scaling:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的问题是由副作用和某种外部噪声引起的，主要由于噪声邻居和CPU频率缩放：
- en: 'If you benchmark a compute-bound algorithm, measure its performance in cycles
    using `perf stat`: this way it will be independent of clock frequency, fluctuations
    of which is usually the main source of noise.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你基准测试一个计算密集型算法，使用`perf stat`来测量其性能（以周期为单位）：这样它将独立于时钟频率，而时钟频率的波动通常是噪声的主要来源。
- en: Otherwise, set core frequency to what you expect it to be and make sure nothing
    interferes with it. On Linux you can do it with `cpupower` (e.g., `sudo cpupower
    frequency-set -g powersave` to put it to minimum or `sudo cpupower frequency-set
    -g ondemand` to enable turbo boost). I use a [convenient GNOME shell extension](https://extensions.gnome.org/extension/1082/cpufreq/)
    that has a separate button to do it.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，将核心频率设置为预期的值，并确保没有任何东西干扰它。在Linux上，你可以使用`cpupower`（例如，使用`sudo cpupower frequency-set
    -g powersave`将其设置为最小或使用`sudo cpupower frequency-set -g ondemand`来启用超频）。我使用一个[方便的GNOME
    shell扩展](https://extensions.gnome.org/extension/1082/cpufreq/)，它有一个单独的按钮来执行此操作。
- en: If applicable, turn hyper-threading off and attach jobs to specific cores. Make
    sure no other jobs are running on the system, turn off networking and try not
    to fiddle with the mouse.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果适用，关闭超线程并将作业附加到特定核心。确保系统上没有其他作业运行，关闭网络，并尽量避免摆弄鼠标。
- en: 'You can’t remove noises and biases completely. Even a program’s name can affect
    its speed: the executable’s name ends up in an environment variable, environment
    variables end up on the call stack, and so the length of the name affects stack
    alignment, which can result in data accesses slowing down due to crossing cache
    line or memory page boundaries.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你无法完全消除噪声和偏差。甚至一个程序的名字也可能影响其速度：可执行文件的名字最终会出现在环境变量中，环境变量最终会出现在调用栈上，因此名字的长度会影响栈对齐，这可能导致由于跨越缓存行或内存页面边界而减慢数据访问速度。
- en: It is important to account for the noise when guiding optimizations and especially
    when reporting results to someone else. Unless you are expecting a 2x kind of
    improvement, treat all microbenchmarks the same way as A/B testing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在指导优化和尤其是向他人报告结果时，考虑噪声是很重要的。除非你期待有2倍以上的改进，否则对待所有微基准测试的方式应与A/B测试相同。
- en: When you run a program on a laptop for under a second, a ±5% fluctuation in
    performance is completely normal. So, if you want to decide whether to revert
    or keep a potential +1% improvement, run it until you reach statistical significance,
    which you can determine by calculating variances and p-values.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在一台笔记本电脑上运行程序不到一秒钟时，性能的±5%波动是完全正常的。因此，如果您想决定是否撤销或保留潜在的+1%改进，请运行它直到达到统计显著性，这可以通过计算方差和p值来确定。
- en: '### [#](https://en.algorithmica.org/hpc/profiling/noise/#further-reading)Further
    Reading'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/profiling/noise/#further-reading)进一步阅读'
- en: Interested readers can explore this comprehensive [list of experimental computer
    science resources](https://www.cs.huji.ac.il/w~feit/exp/related.html) by Dror
    Feitelson, perhaps starting with “[Producing Wrong Data Without Doing Anything
    Obviously Wrong](http://eecs.northwestern.edu/~robby/courses/322-2013-spring/mytkowicz-wrong-data.pdf)”
    by Todd Mytkowicz et al.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 感兴趣的读者可以探索 Dror Feitelson 编制的这个全面的[实验计算机科学资源列表](https://www.cs.huji.ac.il/w~feit/exp/related.html)，也许可以从
    Todd Mytkowicz 等人的“[在不做任何明显错误的情况下产生错误数据](http://eecs.northwestern.edu/~robby/courses/322-2013-spring/mytkowicz-wrong-data.pdf)”开始。
- en: You can also watch [this great talk](https://www.youtube.com/watch?v=r-TLSBdHe1A)
    by Emery Berger on how to do statistically sound performance evaluation. [← Benchmarking](https://en.algorithmica.org/hpc/profiling/benchmarking/)[../Arithmetic
    →](https://en.algorithmica.org/hpc/arithmetic/)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以观看 Emery Berger 关于如何进行统计性能评估的[这场精彩演讲](https://www.youtube.com/watch?v=r-TLSBdHe1A)。[←
    基准测试](https://en.algorithmica.org/hpc/profiling/benchmarking/)[../算术 →](https://en.algorithmica.org/hpc/arithmetic/)
