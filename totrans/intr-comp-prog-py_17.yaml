- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RANDOM WALKS AND MORE ABOUT DATA VISUALIZATION
  prefs: []
  type: TYPE_NORMAL
- en: This book is about using computation to solve problems. Thus far, we have focused
    our attention on problems that can be solved by a **deterministic program**. A
    program is deterministic if whenever it is run on the same input, it produces
    the same output. Such computations are highly useful, but clearly not sufficient
    to tackle some kinds of problems. Many aspects of the world in which we live can
    be accurately modeled only as **stochastic processes**.[^(100)](#c16-fn-0001)
    A process is stochastic if its next state can depend upon some random element.
    The outcome of a stochastic process is usually uncertain. Therefore, we can rarely
    make definitive statements about what a stochastic process will do. Instead, we
    make probabilistic statements about what they might do. Much of the rest of this
    book deals with building programs that help to understand uncertain situations.
    Many of these programs will be simulation models.
  prefs: []
  type: TYPE_NORMAL
- en: A simulation mimics the activity of a real system. For example, the code in
    Figure 10-11 simulates a person making a series of mortgage payments. Think of
    that code as an experimental device, called a **simulation** **model**, that provides
    useful information about the possible behaviors of the system being modeled. Among
    other things, simulations are widely used to predict a future state of a physical
    system (e.g., the temperature of the planet `50` years from now), and in lieu
    of real-world experiments that would be too expensive, time consuming, or dangerous
    to perform (e.g., the impact of a change in the tax code).
  prefs: []
  type: TYPE_NORMAL
- en: It is important to always remember that simulation models, like all models,
    are only an approximation of reality. We can never be sure that the actual system
    will behave in the way predicted by the model. In fact, we can usually be pretty
    confident that the actual system will not behave exactly as predicted by the model.
    For example, not every borrower will make all mortgage payments on time. It is
    a commonly quoted truism that “all models are wrong, but some are useful.” [^(101)](#c16-fn-0002)
  prefs: []
  type: TYPE_NORMAL
- en: 16.1 Random Walks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In 1827, the Scottish botanist Robert Brown observed that pollen particles suspended
    in water seemed to float around at random. He had no plausible explanation for
    what came to be known as Brownian motion, and made no attempt to model it mathematically.[^(102)](#c16-fn-0003)
    A clear mathematical model of the phenomenon was first presented in 1900 in Louis
    Bachelier's doctoral thesis, *The Theory of Speculation*. However, since this
    thesis dealt with the then disreputable problem of understanding financial markets,
    it was largely ignored by respectable academics. Five years later, a young Albert
    Einstein brought this kind of stochastic thinking to the world of physics with
    a mathematical model almost the same as Bachelier's and a description of how it
    could be used to confirm the existence of atoms.[^(103)](#c16-fn-0004) For some
    reason, people seemed to think that understanding physics was more important than
    making money, and the world started paying attention. Times were certainly different.
  prefs: []
  type: TYPE_NORMAL
- en: Brownian motion is an example of a **random walk**. Random walks are widely
    used to model physical processes (e.g., diffusion), biological processes (e.g.,
    the kinetics of displacement of RNA from heteroduplexes by DNA), and social processes
    (e.g., movements of the stock market).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we look at random walks for three reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Random walks are intrinsically interesting and widely used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They provide us with a good example of how to use abstract data types and inheritance
    to structure programs in general and simulation models in particular.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They provide an opportunity to introduce a few more features of Python and to
    demonstrate some additional techniques for producing plots.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.2 The Drunkard's Walk
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at a random walk that actually involves walking. A drunken farmer
    is standing in the middle of a field, and every second the farmer takes one step
    in a random direction. What is her (or his) expected distance from the origin
    in `1000` seconds? If she takes many steps, is she likely to move ever farther
    from the origin, or is she more likely to wander back to the origin over and over,
    and end up not far from where she started? Let's write a simulation to find out.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting to design a program, it is always a good idea to try to develop
    some intuition about the situation the program is intended to model. Let's start
    by sketching a simple model of the situation using Cartesian coordinates. Assume
    that the farmer is standing in a field where the grass has, mysteriously, been
    cut to resemble a piece of graph paper. Assume further that each step the farmer
    takes is of length one and is parallel to either the x-axis or y-axis.
  prefs: []
  type: TYPE_NORMAL
- en: The picture on the left of [Figure 16-1](#c16-fig-0001) depicts a farmer[^(104)](#c16-fn-0005)
    standing in the middle of the field. The smiley faces indicate all the places
    the farmer might be after one step. Notice that after one step she is always exactly
    one unit away from where she started. Let's assume that she wanders eastward from
    her initial location on her first step. How far away might she be from her initial
    location after her second step?
  prefs: []
  type: TYPE_NORMAL
- en: '![c16-fig-0001.jpg](../images/c16-fig-0001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](#c16-fig-0001a) An unusual farmer'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the smiley faces in the picture on the right, we see that with a
    probability of `0.25` she will be `0` units away, with a probability of `0.25`
    she will be `2` units away, and with a probability of `0.5` she will be ![c16-fig-5001.jpg](../images/c16-fig-5001.jpg)
    units away.[^(105)](#c16-fn-0006) So, on average she will be farther away after
    two steps than after one step. What about the third step? If the second step is
    to the top or bottom smiley face, the third step will bring the farmer closer
    to the origin half the time and farther half the time. If the second step is to
    the left smiley face (the origin), the third step will be away from the origin.
    If the second step is to the right smiley face, the third step will be closer
    to the origin a quarter of the time, and farther away three quarters of the time.
  prefs: []
  type: TYPE_NORMAL
- en: It seems as if the more steps the drunk takes, the greater the expected distance
    from the origin. We could continue this exhaustive enumeration of possibilities
    and perhaps develop a pretty good intuition about how this distance grows with
    respect to the number of steps. However, it is getting tedious, so it seems like
    a better idea to write a program to do it for us.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin the design process by thinking about some data abstractions that
    are likely to be useful in building this simulation and perhaps simulations of
    other kinds of random walks. As usual, we should try to invent types that correspond
    to the kinds of things that appear in the situation we are attempting to model.
    Three obvious types are `Location`, `Field`, and `Drunk`. As we look at the classes
    providing these types, it is worthwhile to think about what each might imply about
    the kinds of simulation models they will allow us to build.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with `Location`, [Figure 16-2](#c16-fig-0002). This is a simple
    class, but it does embody two important decisions. It tells us that the simulation
    will involve at most two dimensions. This is consistent with the pictures above.
    Also, since the values supplied for `delta_x` and `delta_y` could be floats rather
    than integers, there is no built-in assumption in this class about the set of
    directions in which a drunk might move. This is a generalization of the informal
    model in which each step was of length one and was parallel to the x-axis or y-axis.
  prefs: []
  type: TYPE_NORMAL
- en: Class `Field`, [Figure 16-2](#c16-fig-0002), is also quite simple, but it too
    embodies notable decisions. It simply maintains a mapping of drunks to locations.
    It places no constraints on locations, so presumably a `Field` is of unbounded
    size. It allows multiple drunks to be added into a `Field` at random locations.
    It says nothing about the patterns in which drunks move, nor does it prohibit
    multiple drunks from occupying the same location or moving through spaces occupied
    by other drunks.
  prefs: []
  type: TYPE_NORMAL
- en: '![c16-fig-0002.jpg](../images/c16-fig-0002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-2](#c16-fig-0002a) `Location` and `Field` classes'
  prefs: []
  type: TYPE_NORMAL
- en: The classes `Drunk` and `Usual_drunk` in [Figure 16-3](#c16-fig-0003) define
    ways in which a drunk might wander through the field. In particular, the value
    of `step_choices` in `Usual_drunk` introduces the restriction that each step is
    of length one and is parallel to either the x-axis or y-axis. Since the function
    `random.choice` returns a randomly chosen member of the sequence that it is passed,
    each kind of step is equally likely and not influenced by previous steps. Later
    we will look at subclasses of `Drunk` with different kinds of behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: '![c16-fig-0003.jpg](../images/c16-fig-0003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-3](#c16-fig-0003a) Classes defining Drunks'
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to use these classes to build a simulation that answers the
    original question. [Figure 16-4](#c16-fig-0004) contains three functions used
    in this simulation.
  prefs: []
  type: TYPE_NORMAL
- en: '![c16-fig-0004.jpg](../images/c16-fig-0004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-4](#c16-fig-0004a) The drunkard''s walk (with a bug)'
  prefs: []
  type: TYPE_NORMAL
- en: The function `walk` simulates one walk of `num_steps` steps. The function `sim_walks`
    calls `walk` to simulate `num_trials` walks of `num_steps` steps each. The function
    `drunk_test` calls `sim_walks` to simulate walks of varying lengths.
  prefs: []
  type: TYPE_NORMAL
- en: The parameter `d_class` of `sim_walks` is of type `class`, and is used in the
    first line of code to create a `Drunk` of the appropriate subclass. Later, when
    `drunk.take_step` is invoked from `Field.move_drunk`, the method from the appropriate
    subclass is automatically selected.
  prefs: []
  type: TYPE_NORMAL
- en: The function `drunk_test` also has a parameter, `d_class`, of type `class`.
    It is used twice, once in the call to `sim_walks` and once in the first `print`
    statement. In the `print` statement, the built-in `class` attribute `__name__`
    is used to get a string with the name of the class.
  prefs: []
  type: TYPE_NORMAL
- en: When we executed `drunk_test((10, 100, 1000, 10000), 100, Usual_drunk)`, it
    printed
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is surprising, given the intuition we developed earlier that the mean distance
    should grow with the number of steps. It could mean that our intuition is wrong,
    or it could mean that our simulation is buggy, or both.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do at this point is to run the simulation on values for which
    we already think we know the answer, and make sure that what the simulation produces
    matches the expected result. Let's try walks of zero steps (for which the mean,
    minimum and maximum distances from the origin should all be `0`) and one step
    (for which the mean, minimum and maximum distances from the origin should all
    be `1`).
  prefs: []
  type: TYPE_NORMAL
- en: When we ran `drunk_test((0,1), 100, Usual_drunk)`, we got the highly suspect
    result
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How on earth can the mean distance of a walk of zero steps be over `8`? We must
    have at least one bug in our simulation. After some investigation, the problem
    is clear. In `sim_walks`, the function call `walk(f, Homer, num_trials)` should
    have been `walk(f, Homer, num_steps)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The moral here is an important one: Always bring some skepticism to bear when
    looking at the results of a simulation. First ask if the results pass the smell
    test (i.e., are plausible). And always **smoke test**[^(106)](#c16-fn-0007) the
    simulation on parameters for which you have a strong intuition about what the
    results should be.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the corrected version of the simulation is run on our two simple cases,
    it yields exactly the expected answers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When run on longer walks it printed
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As anticipated, the mean distance from the origin grows with the number of steps.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at a plot of the mean distances from the origin, [Figure 16-5](#c16-fig-0005).
    To give a sense of how fast the distance is growing, we have placed on the plot
    a line showing the square root of the number of steps (and increased the number
    of steps to `100,000`).
  prefs: []
  type: TYPE_NORMAL
- en: '![c16-fig-0005.jpg](../images/c16-fig-0005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-5](#c16-fig-0005a) Distance from starting point versus steps taken'
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise:** Write code to produce the plot in [Figure 16-5](#c16-fig-0005).'
  prefs: []
  type: TYPE_NORMAL
- en: Does this plot provide any information about the expected final location of
    a drunk? It does tell us that on average the drunk will be somewhere on a circle
    with its center at the origin and with a radius equal to the expected distance
    from the origin. However, it tells us little about where we might actually find
    the drunk at the end of any particular walk. We return to this topic in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 16.3 Biased Random Walks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a working simulation, we can start modifying it to investigate
    other kinds of random walks. Suppose, for example, that we want to consider the
    behavior of a drunken farmer in the northern hemisphere who hates the cold, and
    even in his drunken stupor is able to move twice as fast when his random movements
    take him in a southward direction. Or maybe a phototropic drunk who always moves
    towards the sun (east in the morning and west in the afternoon). These are examples
    of **biased random walks**. The walk is still stochastic, but there is a bias
    in the outcome.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 16-6](#c16-fig-0006) defines two additional subclasses of `Drunk`.
    In each case the specialization involves choosing an appropriate value for `step_choices`.
    The function `sim_all` iterates over a sequence of subclasses of `Drunk` to generate
    information about how each kind behaves.'
  prefs: []
  type: TYPE_NORMAL
- en: '![c16-fig-0006.jpg](../images/c16-fig-0006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-6](#c16-fig-0006a) Subclasses of `Drunk` base class'
  prefs: []
  type: TYPE_NORMAL
- en: When we ran
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: it printed
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It appears that our heat-seeking drunk moves away from the origin faster than
    the other two kinds of drunk. However, it is not easy to digest all of the information
    in this output. It is once again time to move away from textual output and start
    using plots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are showing different kinds of drunks on the same plot, we will associate
    a distinct style with each type of drunk so that it is easy to differentiate among
    them. The style will have three aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: The color of the line and marker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shape of the marker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kind of the line, e.g., solid or dotted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class `style_iterator`, [Figure 16-7](#c16-fig-0007), rotates through a
    sequence of styles defined by the argument to `style_iterator.__init__`.
  prefs: []
  type: TYPE_NORMAL
- en: '![c16-fig-0007.jpg](../images/c16-fig-0007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-7](#c16-fig-0007a) Iterating over styles'
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Figure 16-8](#c16-fig-0008) is similar in structure to that in
    [Figure 16-4](#c16-fig-0004).
  prefs: []
  type: TYPE_NORMAL
- en: '![c16-fig-0008.jpg](../images/c16-fig-0008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-8](#c16-fig-0008a) Plotting the walks of different drunks'
  prefs: []
  type: TYPE_NORMAL
- en: The `print` statements in `sim_drunk` and `sim_all_plot` contribute nothing
    to the result of the simulation. They are there because this simulation can take
    a rather long time to complete, and printing an occasional message indicating
    that progress is being made can be reassuring to a user who might be wondering
    if the program is actually making progress.
  prefs: []
  type: TYPE_NORMAL
- en: The plot in [Figure 16-9](#c16-fig-0009) was produced by executing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![c16-fig-0009.jpg](../images/c16-fig-0009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-9](#c16-fig-0009a) Mean distance for different kinds of drunks'
  prefs: []
  type: TYPE_NORMAL
- en: The usual drunk and the phototropic drunk (`EW_drunk`) seem to be moving away
    from the origin at approximately the same pace, but the heat-seeking drunk (`Cold_drunk`)
    seems to be moving away orders of magnitude faster. This is interesting, since
    on average he is only moving `25%` faster (he takes, on average, five steps for
    every four taken by the others).
  prefs: []
  type: TYPE_NORMAL
- en: Let's construct a different plot to help us get more insight into the behavior
    of these three classes. Instead of plotting the change in distance over time for
    an increasing number of steps, the code in [Figure 16-10](#c16-fig-0010) plots
    the distribution of final locations for a single number of steps.
  prefs: []
  type: TYPE_NORMAL
- en: '![c16-fig-0010.jpg](../images/c16-fig-0010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-10](#c16-fig-0010a) Plotting final locations'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing `plot_locs` does is create an instance of `style_iterator` with
    three styles of markers. It then uses `plt.plot` to place a marker at a location
    corresponding to the end of each trial. The call to `plt.plot` sets the color
    and shape of the marker to be plotted using the values returned by the iterator
    `style_iterator`.
  prefs: []
  type: TYPE_NORMAL
- en: The call `plot_locs((Usual_drunk, Cold_drunk, EW_drunk), 100, 200)` produces
    the plot in [Figure 16-11](#c16-fig-0011).
  prefs: []
  type: TYPE_NORMAL
- en: '![c16-fig-0011.jpg](../images/c16-fig-0011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-11](#c16-fig-0011a) Where the drunk stops'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to say is that our drunks seem to be behaving as advertised.
    The `EW_drunk` ends up on the x-axis, the `Cold_drunk` seem to have made progress
    southwards, and the `Usual_drunk` seem to have wandered aimlessly.
  prefs: []
  type: TYPE_NORMAL
- en: But why do there appear to be far fewer circle markers than triangle or + markers?
    Because many of the `EW_drunk`'s walks ended up at the same place. This is not
    surprising, given the small number of possible endpoints (`200`) for the `EW_drunk`.
    Also the circle markers seem to be fairly uniformly spaced across the x-axis.
  prefs: []
  type: TYPE_NORMAL
- en: It is still not immediately obvious, at least to us, why the `Cold_drunk` manages,
    on average, to get so much farther from the origin than the other kinds of drunks.
    Perhaps it's time to look not at the endpoints of many walks, but at the path
    followed by a single walk. The code in [Figure 16-12](#c16-fig-0012) produces
    the plot in [Figure 16-13](#c16-fig-0013).
  prefs: []
  type: TYPE_NORMAL
- en: '![c16-fig-0012.jpg](../images/c16-fig-0012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-12](#c16-fig-0012a) Tracing walks'
  prefs: []
  type: TYPE_NORMAL
- en: '![c16-fig-0013.jpg](../images/c16-fig-0013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-13](#c16-fig-0013a) Trajectory of walks'
  prefs: []
  type: TYPE_NORMAL
- en: Since the walk is `200` steps long and the `EW_drunk`'s walk visits fewer than
    `30` different locations, it's clear that he is spending a lot of time retracing
    his steps. The same kind of observation holds for the `Usual_drunk`. In contrast,
    while the `Cold_drunk` is not exactly making a beeline for Florida, he is managing
    to spend relatively less time visiting places he has already been.
  prefs: []
  type: TYPE_NORMAL
- en: 'None of these simulations is interesting in its own right. (In Chapter 18,
    we will look at more intrinsically interesting simulations.) But there are some
    points worth taking away:'
  prefs: []
  type: TYPE_NORMAL
- en: Initially we divided our simulation code into four separate chunks. Three of
    them were classes (`Location`, `Field`, and `Drunk`) corresponding to abstract
    data types that appeared in the informal description of the problem. The fourth
    chunk was a group of functions that used these classes to perform a simple simulation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then elaborated `Drunk` into a hierarchy of classes so that we could observe
    different kinds of biased random walks. The code for `Location` and `Field` remained
    untouched, but the simulation code was changed to iterate through the different
    subclasses of `Drunk`. In doing this, we took advantage of the fact that a class
    is itself an object, and therefore can be passed as an argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we made a series of incremental changes to the simulation that did
    not involve any changes to the classes representing the abstract types. These
    changes mostly involved introducing plots designed to provide insight into the
    different walks. This is typical of the way in which simulations are developed.
    Get the basic simulation working first, and then start adding features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.4 Treacherous Fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Did you ever play the board game known as *Chutes and Ladders* in the U.S. and
    *Snakes and Ladders* in the UK? This children's game originated in India (perhaps
    in the second century BCE), where it was called *Moksha-patamu*. Landing on a
    square representing virtue (e.g., generosity) sent a player up a ladder to a higher
    tier of life. Landing on a square representing evil (e.g., lust), sent a player
    back to a lower tier of life.
  prefs: []
  type: TYPE_NORMAL
- en: We can easily add this kind of feature to our random walks by creating a `Field`
    with wormholes,[^(107)](#c16-fn-0008) as shown in [Figure 16-14](#c16-fig-0014),
    and replacing the second line of code in the function `trace_walk` by the line
    of code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In an `Odd_field`, a drunk who steps into a wormhole location is transported
    to the location at the other end of the wormhole.
  prefs: []
  type: TYPE_NORMAL
- en: '![c16-fig-0014.jpg](../images/c16-fig-0014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-14](#c16-fig-0014a) Fields with strange properties'
  prefs: []
  type: TYPE_NORMAL
- en: When we ran `trace_walk((Usual_drunk, Cold_drunk, EW_drunk), 500)`, we got the
    rather odd-looking plot in [Figure 16-15](#c16-fig-0015).
  prefs: []
  type: TYPE_NORMAL
- en: '![c16-fig-0015.jpg](../images/c16-fig-0015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-15](#c16-fig-0015a) A strange walk'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clearly changing the properties of the field has had a dramatic effect. However,
    that is not the point of this example. The main points are:'
  prefs: []
  type: TYPE_NORMAL
- en: Because of the way we structured our code, it was easy to accommodate a significant
    change to the situation being modeled. Just as we could add different kinds of
    drunks without touching `Field`, we can add a new kind of `Field` without touching
    `Drunk` or any of its subclasses. (Had we been sufficiently prescient to make
    the field a parameter of `trace_walk`, we wouldn't have had to change `trace_walk`
    either.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While it would have been feasible to analytically derive different kinds of
    information about the expected behavior of the simple random walk and even the
    biased random walks, it would have been challenging to do so once the wormholes
    were introduced. Yet it was exceedingly simple to change the simulation to model
    the new situation. Simulation models often enjoy this advantage relative to analytic
    models.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.5 Terms Introduced in Chapterdeterministic program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: stochastic process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: simulation model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: random walk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: smoke test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: biased random walks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: logarithmic scale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
