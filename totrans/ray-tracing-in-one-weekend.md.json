["```\n#include <iostream>\n\nint main() {\n\n    // Image\n\n    int image_width = 256;\n    int image_height = 256;\n\n    // Render\n\n    std::cout << \"P3\\n\" << image_width << ' ' << image_height << \"\\n255\\n\";\n\n    for (int j = 0; j < image_height; j++) {\n        for (int i = 0; i < image_width; i++) {\n            auto r = double(i) / (image_width-1);\n            auto g = double(j) / (image_height-1);\n            auto b = 0.0;\n\n            int ir = int(255.999 * r);\n            int ig = int(255.999 * g);\n            int ib = int(255.999 * b);\n\n            std::cout << ir << ' ' << ig << ' ' << ib << '\\n';\n        }\n    }\n}\n```", "```\ncmake -B build\ncmake --build build\n```", "```\nbuild\\Debug\\inOneWeekend.exe > image.ppm\n```", "```\ncmake --build build --config release\n```", "```\nbuild\\Release\\inOneWeekend.exe > image.ppm\n```", "```\nbuild/inOneWeekend > image.ppm\n```", "```\nP3\n256 256\n255\n0 0 0\n1 0 0\n2 0 0\n3 0 0\n4 0 0\n5 0 0\n6 0 0\n7 0 0\n8 0 0\n9 0 0\n10 0 0\n11 0 0\n12 0 0\n...\n```", "```\n for (int j = 0; j < image_height; ++j) {        std::clog << \"\\rScanlines remaining: \" << (image_height - j) << ' ' << std::flush;        for (int i = 0; i < image_width; i++) {\n            auto r = double(i) / (image_width-1);\n            auto g = double(j) / (image_height-1);\n            auto b = 0.0;\n\n            int ir = int(255.999 * r);\n            int ig = int(255.999 * g);\n            int ib = int(255.999 * b);\n\n            std::cout << ir << ' ' << ig << ' ' << ib << '\\n';\n        }\n    }\n\n    std::clog << \"\\rDone.                 \\n\";\n```", "```\n#ifndef VEC3_H\n#define VEC3_H\n\n#include <cmath>\n#include <iostream>\n\nclass vec3 {\n  public:\n    double e[3];\n\n    vec3() : e{0,0,0} {}\n    vec3(double e0, double e1, double e2) : e{e0, e1, e2} {}\n\n    double x() const { return e[0]; }\n    double y() const { return e[1]; }\n    double z() const { return e[2]; }\n\n    vec3 operator-() const { return vec3(-e[0], -e[1], -e[2]); }\n    double operator[](int i) const { return e[i]; }\n    double& operator[](int i) { return e[i]; }\n\n    vec3& operator+=(const vec3& v) {\n        e[0] += v.e[0];\n        e[1] += v.e[1];\n        e[2] += v.e[2];\n        return *this;\n    }\n\n    vec3& operator*=(double t) {\n        e[0] *= t;\n        e[1] *= t;\n        e[2] *= t;\n        return *this;\n    }\n\n    vec3& operator/=(double t) {\n        return *this *= 1/t;\n    }\n\n    double length() const {\n        return std::sqrt(length_squared());\n    }\n\n    double length_squared() const {\n        return e[0]*e[0] + e[1]*e[1] + e[2]*e[2];\n    }\n};\n\n// point3 is just an alias for vec3, but useful for geometric clarity in the code.\nusing point3 = vec3;\n\n// Vector Utility Functions\n\ninline std::ostream& operator<<(std::ostream& out, const vec3& v) {\n    return out << v.e[0] << ' ' << v.e[1] << ' ' << v.e[2];\n}\n\ninline vec3 operator+(const vec3& u, const vec3& v) {\n    return vec3(u.e[0] + v.e[0], u.e[1] + v.e[1], u.e[2] + v.e[2]);\n}\n\ninline vec3 operator-(const vec3& u, const vec3& v) {\n    return vec3(u.e[0] - v.e[0], u.e[1] - v.e[1], u.e[2] - v.e[2]);\n}\n\ninline vec3 operator*(const vec3& u, const vec3& v) {\n    return vec3(u.e[0] * v.e[0], u.e[1] * v.e[1], u.e[2] * v.e[2]);\n}\n\ninline vec3 operator*(double t, const vec3& v) {\n    return vec3(t*v.e[0], t*v.e[1], t*v.e[2]);\n}\n\ninline vec3 operator*(const vec3& v, double t) {\n    return t * v;\n}\n\ninline vec3 operator/(const vec3& v, double t) {\n    return (1/t) * v;\n}\n\ninline double dot(const vec3& u, const vec3& v) {\n    return u.e[0] * v.e[0]\n         + u.e[1] * v.e[1]\n         + u.e[2] * v.e[2];\n}\n\ninline vec3 cross(const vec3& u, const vec3& v) {\n    return vec3(u.e[1] * v.e[2] - u.e[2] * v.e[1],\n                u.e[2] * v.e[0] - u.e[0] * v.e[2],\n                u.e[0] * v.e[1] - u.e[1] * v.e[0]);\n}\n\ninline vec3 unit_vector(const vec3& v) {\n    return v / v.length();\n}\n\n#endif\n```", "```\n#ifndef COLOR_H\n#define COLOR_H\n\n#include \"vec3.h\"\n\n#include <iostream>\n\nusing color = vec3;\n\nvoid write_color(std::ostream& out, const color& pixel_color) {\n    auto r = pixel_color.x();\n    auto g = pixel_color.y();\n    auto b = pixel_color.z();\n\n    // Translate the [0,1] component values to the byte range [0,255].\n    int rbyte = int(255.999 * r);\n    int gbyte = int(255.999 * g);\n    int bbyte = int(255.999 * b);\n\n    // Write out the pixel color components.\n    out << rbyte << ' ' << gbyte << ' ' << bbyte << '\\n';\n}\n\n#endif\n```", "```\n#include \"color.h\"\n#include \"vec3.h\"\n#include <iostream>\n\nint main() {\n\n    // Image\n\n    int image_width = 256;\n    int image_height = 256;\n\n    // Render\n\n    std::cout << \"P3\\n\" << image_width << ' ' << image_height << \"\\n255\\n\";\n\n    for (int j = 0; j < image_height; j++) {\n        std::clog << \"\\rScanlines remaining: \" << (image_height - j) << ' ' << std::flush;\n        for (int i = 0; i < image_width; i++) {            auto pixel_color = color(double(i)/(image_width-1), double(j)/(image_height-1), 0);\n            write_color(std::cout, pixel_color);        }\n    }\n\n    std::clog << \"\\rDone.                 \\n\";\n}\n```", "```\n#ifndef RAY_H\n#define RAY_H\n\n#include \"vec3.h\"\n\nclass ray {\n  public:\n    ray() {}\n\n    ray(const point3& origin, const vec3& direction) : orig(origin), dir(direction) {}\n\n    const point3& origin() const { return orig; }\n    const vec3& direction() const { return dir; }\n\n    point3 at(double t) const {\n        return orig + t*dir;\n    }\n\n  private:\n    point3 orig;\n    vec3 dir;\n};\n\n#endif\n```", "```\nauto aspect_ratio = 16.0 / 9.0;\nint image_width = 400;\n\n// Calculate the image height, and ensure that it's at least 1.\nint image_height = int(image_width / aspect_ratio);\nimage_height = (image_height < 1) ? 1 : image_height;\n\n// Viewport widths less than one are ok since they are real valued.\nauto viewport_height = 2.0;\nauto viewport_width = viewport_height * (double(image_width)/image_height);\n```", "```\n#include \"color.h\"#include \"ray.h\"#include \"vec3.h\"\n\n#include <iostream>\n\ncolor ray_color(const ray& r) {\n    return color(0,0,0);\n}\nint main() {\n\n    // Image\n\n    auto aspect_ratio = 16.0 / 9.0;\n    int image_width = 400;\n\n    // Calculate the image height, and ensure that it's at least 1.\n    int image_height = int(image_width / aspect_ratio);\n    image_height = (image_height < 1) ? 1 : image_height;\n\n    // Camera\n\n    auto focal_length = 1.0;\n    auto viewport_height = 2.0;\n    auto viewport_width = viewport_height * (double(image_width)/image_height);\n    auto camera_center = point3(0, 0, 0);\n\n    // Calculate the vectors across the horizontal and down the vertical viewport edges.\n    auto viewport_u = vec3(viewport_width, 0, 0);\n    auto viewport_v = vec3(0, -viewport_height, 0);\n\n    // Calculate the horizontal and vertical delta vectors from pixel to pixel.\n    auto pixel_delta_u = viewport_u / image_width;\n    auto pixel_delta_v = viewport_v / image_height;\n\n    // Calculate the location of the upper left pixel.\n    auto viewport_upper_left = camera_center\n                             - vec3(0, 0, focal_length) - viewport_u/2 - viewport_v/2;\n    auto pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);\n    // Render\n\n    std::cout << \"P3\\n\" << image_width << \" \" << image_height << \"\\n255\\n\";\n\n    for (int j = 0; j < image_height; j++) {\n        std::clog << \"\\rScanlines remaining: \" << (image_height - j) << ' ' << std::flush;\n        for (int i = 0; i < image_width; i++) {            auto pixel_center = pixel00_loc + (i * pixel_delta_u) + (j * pixel_delta_v);\n            auto ray_direction = pixel_center - camera_center;\n            ray r(camera_center, ray_direction);\n\n            color pixel_color = ray_color(r);            write_color(std::cout, pixel_color);\n        }\n    }\n\n    std::clog << \"\\rDone.                 \\n\";\n}\n```", "```\n#include \"color.h\"\n#include \"ray.h\"\n#include \"vec3.h\"\n\n#include <iostream>\n\ncolor ray_color(const ray& r) {    vec3 unit_direction = unit_vector(r.direction());\n    auto a = 0.5*(unit_direction.y() + 1.0);\n    return (1.0-a)*color(1.0, 1.0, 1.0) + a*color(0.5, 0.7, 1.0);}\n\n...\n```", "```\nbool hit_sphere(const point3& center, double radius, const ray& r) {\n    vec3 oc = center - r.origin();\n    auto a = dot(r.direction(), r.direction());\n    auto b = -2.0 * dot(r.direction(), oc);\n    auto c = dot(oc, oc) - radius*radius;\n    auto discriminant = b*b - 4*a*c;\n    return (discriminant >= 0);\n}\ncolor ray_color(const ray& r) {    if (hit_sphere(point3(0,0,-1), 0.5, r))\n        return color(1, 0, 0);\n    vec3 unit_direction = unit_vector(r.direction());\n    auto a = 0.5*(unit_direction.y() + 1.0);\n    return (1.0-a)*color(1.0, 1.0, 1.0) + a*color(0.5, 0.7, 1.0);\n}\n```", "```\ndouble hit_sphere(const point3& center, double radius, const ray& r) {    vec3 oc = center - r.origin();\n    auto a = dot(r.direction(), r.direction());\n    auto b = -2.0 * dot(r.direction(), oc);\n    auto c = dot(oc, oc) - radius*radius;\n    auto discriminant = b*b - 4*a*c;\n\n    if (discriminant < 0) {\n        return -1.0;\n    } else {\n        return (-b - std::sqrt(discriminant) ) / (2.0*a);\n    }}\n\ncolor ray_color(const ray& r) {    auto t = hit_sphere(point3(0,0,-1), 0.5, r);\n    if (t > 0.0) {\n        vec3 N = unit_vector(r.at(t) - vec3(0,0,-1));\n        return 0.5*color(N.x()+1, N.y()+1, N.z()+1);\n    }\n    vec3 unit_direction = unit_vector(r.direction());\n    auto a = 0.5*(unit_direction.y() + 1.0);\n    return (1.0-a)*color(1.0, 1.0, 1.0) + a*color(0.5, 0.7, 1.0);\n}\n```", "```\ndouble hit_sphere(const point3& center, double radius, const ray& r) {\n    vec3 oc = center - r.origin();\n    auto a = dot(r.direction(), r.direction());\n    auto b = -2.0 * dot(r.direction(), oc);\n    auto c = dot(oc, oc) - radius*radius;\n    auto discriminant = b*b - 4*a*c;\n\n    if (discriminant < 0) {\n        return -1.0;\n    } else {\n        return (-b - std::sqrt(discriminant) ) / (2.0*a);\n    }\n}\n```", "```\ndouble hit_sphere(const point3& center, double radius, const ray& r) {\n    vec3 oc = center - r.origin();    auto a = r.direction().length_squared();\n    auto h = dot(r.direction(), oc);\n    auto c = oc.length_squared() - radius*radius;\n    auto discriminant = h*h - a*c;\n    if (discriminant < 0) {\n        return -1.0;\n    } else {        return (h - std::sqrt(discriminant)) / a;    }\n}\n```", "```\n#ifndef HITTABLE_H\n#define HITTABLE_H\n\n#include \"ray.h\"\n\nclass hit_record {\n  public:\n    point3 p;\n    vec3 normal;\n    double t;\n};\n\nclass hittable {\n  public:\n    virtual ~hittable() = default;\n\n    virtual bool hit(const ray& r, double ray_tmin, double ray_tmax, hit_record& rec) const = 0;\n};\n\n#endif\n```", "```\n#ifndef SPHERE_H\n#define SPHERE_H\n\n#include \"hittable.h\"\n#include \"vec3.h\"\n\nclass sphere : public hittable {\n  public:\n    sphere(const point3& center, double radius) : center(center), radius(std::fmax(0,radius)) {}\n\n    bool hit(const ray& r, double ray_tmin, double ray_tmax, hit_record& rec) const override {\n        vec3 oc = center - r.origin();\n        auto a = r.direction().length_squared();\n        auto h = dot(r.direction(), oc);\n        auto c = oc.length_squared() - radius*radius;\n\n        auto discriminant = h*h - a*c;\n        if (discriminant < 0)\n            return false;\n\n        auto sqrtd = std::sqrt(discriminant);\n\n        // Find the nearest root that lies in the acceptable range.\n        auto root = (h - sqrtd) / a;\n        if (root <= ray_tmin || ray_tmax <= root) {\n            root = (h + sqrtd) / a;\n            if (root <= ray_tmin || ray_tmax <= root)\n                return false;\n        }\n\n        rec.t = root;\n        rec.p = r.at(rec.t);\n        rec.normal = (rec.p - center) / radius;\n\n        return true;\n    }\n\n  private:\n    point3 center;\n    double radius;\n};\n\n#endif\n```", "```\nif (dot(ray_direction, outward_normal) > 0.0) {\n    // ray is inside the sphere\n    ...\n} else {\n    // ray is outside the sphere\n    ...\n}\n```", "```\nbool front_face;\nif (dot(ray_direction, outward_normal) > 0.0) {\n    // ray is inside the sphere\n    normal = -outward_normal;\n    front_face = false;\n} else {\n    // ray is outside the sphere\n    normal = outward_normal;\n    front_face = true;\n}\n```", "```\nclass hit_record {\n  public:\n    point3 p;\n    vec3 normal;\n    double t;    bool front_face;\n\n    void set_face_normal(const ray& r, const vec3& outward_normal) {\n        // Sets the hit record normal vector.\n        // NOTE: the parameter `outward_normal` is assumed to have unit length.\n\n        front_face = dot(r.direction(), outward_normal) < 0;\n        normal = front_face ? outward_normal : -outward_normal;\n    }};\n```", "```\nclass sphere : public hittable {\n  public:\n    ...\n    bool hit(const ray& r, double ray_tmin, double ray_tmax, hit_record& rec) const {\n        ...\n\n        rec.t = root;\n        rec.p = r.at(rec.t);        vec3 outward_normal = (rec.p - center) / radius;\n        rec.set_face_normal(r, outward_normal);\n        return true;\n    }\n    ...\n};\n```", "```\n#ifndef HITTABLE_LIST_H\n#define HITTABLE_LIST_H\n\n#include \"hittable.h\"\n\n#include <memory>\n#include <vector>\n\nusing std::make_shared;\nusing std::shared_ptr;\n\nclass hittable_list : public hittable {\n  public:\n    std::vector<shared_ptr<hittable>> objects;\n\n    hittable_list() {}\n    hittable_list(shared_ptr<hittable> object) { add(object); }\n\n    void clear() { objects.clear(); }\n\n    void add(shared_ptr<hittable> object) {\n        objects.push_back(object);\n    }\n\n    bool hit(const ray& r, double ray_tmin, double ray_tmax, hit_record& rec) const override {\n        hit_record temp_rec;\n        bool hit_anything = false;\n        auto closest_so_far = ray_tmax;\n\n        for (const auto& object : objects) {\n            if (object->hit(r, ray_tmin, closest_so_far, temp_rec)) {\n                hit_anything = true;\n                closest_so_far = temp_rec.t;\n                rec = temp_rec;\n            }\n        }\n\n        return hit_anything;\n    }\n};\n\n#endif\n```", "```\nshared_ptr<double> double_ptr = make_shared<double>(0.37);\nshared_ptr<vec3>   vec3_ptr   = make_shared<vec3>(1.414214, 2.718281, 1.618034);\nshared_ptr<sphere> sphere_ptr = make_shared<sphere>(point3(0,0,0), 1.0);\n```", "```\nauto double_ptr = make_shared<double>(0.37);\nauto vec3_ptr   = make_shared<vec3>(1.414214, 2.718281, 1.618034);\nauto sphere_ptr = make_shared<sphere>(point3(0,0,0), 1.0);\n```", "```\n#ifndef RTWEEKEND_H\n#define RTWEEKEND_H\n\n#include <cmath>\n#include <iostream>\n#include <limits>\n#include <memory>\n\n// C++ Std Usings\n\nusing std::make_shared;\nusing std::shared_ptr;\n\n// Constants\n\nconst double infinity = std::numeric_limits<double>::infinity();\nconst double pi = 3.1415926535897932385;\n\n// Utility Functions\n\ninline double degrees_to_radians(double degrees) {\n    return degrees * pi / 180.0;\n}\n\n// Common Headers\n\n#include \"color.h\"\n#include \"ray.h\"\n#include \"vec3.h\"\n\n#endif\n```", "```\n#include <iostream>\n```", "```\n#include \"ray.h\"\n```", "```\n#include <memory>#include <vector>\n\nusing std::make_shared;\nusing std::shared_ptr;\n```", "```\n#include \"vec3.h\"\n```", "```\n#include <cmath>\n#include <iostream>\n```", "```\n#include \"rtweekend.h\"\n#include \"color.h\"\n#include \"ray.h\"\n#include \"vec3.h\"#include \"hittable.h\"\n#include \"hittable_list.h\"\n#include \"sphere.h\"\n#include <iostream>\ndouble hit_sphere(const point3& center, double radius, const ray& r) {\n    ...\n}\ncolor ray_color(const ray& r, const hittable& world) {\n    hit_record rec;\n    if (world.hit(r, 0, infinity, rec)) {\n        return 0.5 * (rec.normal + color(1,1,1));\n    }\n    vec3 unit_direction = unit_vector(r.direction());\n    auto a = 0.5*(unit_direction.y() + 1.0);\n    return (1.0-a)*color(1.0, 1.0, 1.0) + a*color(0.5, 0.7, 1.0);\n}\n\nint main() {\n\n    // Image\n\n    auto aspect_ratio = 16.0 / 9.0;\n    int image_width = 400;\n\n    // Calculate the image height, and ensure that it's at least 1.\n    int image_height = int(image_width / aspect_ratio);\n    image_height = (image_height < 1) ? 1 : image_height;\n\n    // World\n\n    hittable_list world;\n\n    world.add(make_shared<sphere>(point3(0,0,-1), 0.5));\n    world.add(make_shared<sphere>(point3(0,-100.5,-1), 100));\n    // Camera\n\n    auto focal_length = 1.0;\n    auto viewport_height = 2.0;\n    auto viewport_width = viewport_height * (double(image_width)/image_height);\n    auto camera_center = point3(0, 0, 0);\n\n    // Calculate the vectors across the horizontal and down the vertical viewport edges.\n    auto viewport_u = vec3(viewport_width, 0, 0);\n    auto viewport_v = vec3(0, -viewport_height, 0);\n\n    // Calculate the horizontal and vertical delta vectors from pixel to pixel.\n    auto pixel_delta_u = viewport_u / image_width;\n    auto pixel_delta_v = viewport_v / image_height;\n\n    // Calculate the location of the upper left pixel.\n    auto viewport_upper_left = camera_center\n                             - vec3(0, 0, focal_length) - viewport_u/2 - viewport_v/2;\n    auto pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);\n\n    // Render\n\n    std::cout << \"P3\\n\" << image_width << ' ' << image_height << \"\\n255\\n\";\n\n    for (int j = 0; j < image_height; j++) {\n        std::clog << \"\\rScanlines remaining: \" << (image_height - j) << ' ' << std::flush;\n        for (int i = 0; i < image_width; i++) {\n            auto pixel_center = pixel00_loc + (i * pixel_delta_u) + (j * pixel_delta_v);\n            auto ray_direction = pixel_center - camera_center;\n            ray r(camera_center, ray_direction);\n\n            color pixel_color = ray_color(r, world);            write_color(std::cout, pixel_color);\n        }\n    }\n\n    std::clog << \"\\rDone.                 \\n\";\n}\n```", "```\n#ifndef INTERVAL_H\n#define INTERVAL_H\n\nclass interval {\n  public:\n    double min, max;\n\n    interval() : min(+infinity), max(-infinity) {} // Default interval is empty\n\n    interval(double min, double max) : min(min), max(max) {}\n\n    double size() const {\n        return max - min;\n    }\n\n    bool contains(double x) const {\n        return min <= x && x <= max;\n    }\n\n    bool surrounds(double x) const {\n        return min < x && x < max;\n    }\n\n    static const interval empty, universe;\n};\n\nconst interval interval::empty    = interval(+infinity, -infinity);\nconst interval interval::universe = interval(-infinity, +infinity);\n\n#endif\n```", "```\n// Common Headers\n\n#include \"color.h\"#include \"interval.h\"#include \"ray.h\"\n#include \"vec3.h\"\n```", "```\nclass hittable {\n  public:\n    ...    virtual bool hit(const ray& r, interval ray_t, hit_record& rec) const = 0;};\n```", "```\nclass hittable_list : public hittable {\n  public:\n    ...    bool hit(const ray& r, interval ray_t, hit_record& rec) const override {        hit_record temp_rec;\n        bool hit_anything = false;        auto closest_so_far = ray_t.max;\n        for (const auto& object : objects) {            if (object->hit(r, interval(ray_t.min, closest_so_far), temp_rec)) {                hit_anything = true;\n                closest_so_far = temp_rec.t;\n                rec = temp_rec;\n            }\n        }\n\n        return hit_anything;\n    }\n    ...\n};\n```", "```\nclass sphere : public hittable {\n  public:\n    ...    bool hit(const ray& r, interval ray_t, hit_record& rec) const override {        ...\n\n        // Find the nearest root that lies in the acceptable range.\n        auto root = (h - sqrtd) / a;        if (!ray_t.surrounds(root)) {            root = (h + sqrtd) / a;            if (!ray_t.surrounds(root))                return false;\n        }\n        ...\n    }\n    ...\n};\n```", "```\ncolor ray_color(const ray& r, const hittable& world) {\n    hit_record rec;    if (world.hit(r, interval(0, infinity), rec)) {        return 0.5 * (rec.normal + color(1,1,1));\n    }\n\n    vec3 unit_direction = unit_vector(r.direction());\n    auto a = 0.5*(unit_direction.y() + 1.0);\n    return (1.0-a)*color(1.0, 1.0, 1.0) + a*color(0.5, 0.7, 1.0);\n}\n```", "```\n#ifndef CAMERA_H\n#define CAMERA_H\n\n#include \"hittable.h\"\n\nclass camera {\n  public:\n    /* Public Camera Parameters Here */\n\n    void render(const hittable& world) {\n        ...\n    }\n\n  private:\n    /* Private Camera Variables Here */\n\n    void initialize() {\n        ...\n    }\n\n    color ray_color(const ray& r, const hittable& world) const {\n        ...\n    }\n};\n\n#endif\n```", "```\nclass camera {\n  ...\n\n  private:\n    ...\n\n    color ray_color(const ray& r, const hittable& world) const {        hit_record rec;\n\n        if (world.hit(r, interval(0, infinity), rec)) {\n            return 0.5 * (rec.normal + color(1,1,1));\n        }\n\n        vec3 unit_direction = unit_vector(r.direction());\n        auto a = 0.5*(unit_direction.y() + 1.0);\n        return (1.0-a)*color(1.0, 1.0, 1.0) + a*color(0.5, 0.7, 1.0);    }\n};\n\n#endif\n```", "```\nclass camera {\n  public:    double aspect_ratio = 1.0;  // Ratio of image width over height\n    int    image_width  = 100;  // Rendered image width in pixel count\n\n    void render(const hittable& world) {\n        initialize();\n\n        std::cout << \"P3\\n\" << image_width << ' ' << image_height << \"\\n255\\n\";\n\n        for (int j = 0; j < image_height; j++) {\n            std::clog << \"\\rScanlines remaining: \" << (image_height - j) << ' ' << std::flush;\n            for (int i = 0; i < image_width; i++) {\n                auto pixel_center = pixel00_loc + (i * pixel_delta_u) + (j * pixel_delta_v);\n                auto ray_direction = pixel_center - center;\n                ray r(center, ray_direction);\n\n                color pixel_color = ray_color(r, world);\n                write_color(std::cout, pixel_color);\n            }\n        }\n\n        std::clog << \"\\rDone.                 \\n\";\n    }\n  private:    int    image_height;   // Rendered image height\n    point3 center;         // Camera center\n    point3 pixel00_loc;    // Location of pixel 0, 0\n    vec3   pixel_delta_u;  // Offset to pixel to the right\n    vec3   pixel_delta_v;  // Offset to pixel below\n\n    void initialize() {\n        image_height = int(image_width / aspect_ratio);\n        image_height = (image_height < 1) ? 1 : image_height;\n\n        center = point3(0, 0, 0);\n\n        // Determine viewport dimensions.\n        auto focal_length = 1.0;\n        auto viewport_height = 2.0;\n        auto viewport_width = viewport_height * (double(image_width)/image_height);\n\n        // Calculate the vectors across the horizontal and down the vertical viewport edges.\n        auto viewport_u = vec3(viewport_width, 0, 0);\n        auto viewport_v = vec3(0, -viewport_height, 0);\n\n        // Calculate the horizontal and vertical delta vectors from pixel to pixel.\n        pixel_delta_u = viewport_u / image_width;\n        pixel_delta_v = viewport_v / image_height;\n\n        // Calculate the location of the upper left pixel.\n        auto viewport_upper_left =\n            center - vec3(0, 0, focal_length) - viewport_u/2 - viewport_v/2;\n        pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);\n    }\n    color ray_color(const ray& r, const hittable& world) const {\n        ...\n    }\n};\n\n#endif\n```", "```\n#include \"rtweekend.h\"\n\n#include \"camera.h\"#include \"hittable.h\"\n#include \"hittable_list.h\"\n#include \"sphere.h\"\n\ncolor ray_color(const ray& r, const hittable& world) {\n    ...\n}\nint main() {    hittable_list world;\n\n    world.add(make_shared<sphere>(point3(0,0,-1), 0.5));\n    world.add(make_shared<sphere>(point3(0,-100.5,-1), 100));\n\n    camera cam;\n\n    cam.aspect_ratio = 16.0 / 9.0;\n    cam.image_width  = 400;\n\n    cam.render(world);}\n```", "```\n#include <cmath>#include <cstdlib>#include <iostream>\n#include <limits>\n#include <memory>\n...\n\n// Utility Functions\n\ninline double degrees_to_radians(double degrees) {\n    return degrees * pi / 180.0;\n}\n\ninline double random_double() {\n    // Returns a random real in [0,1).\n    return std::rand() / (RAND_MAX + 1.0);\n}\n\ninline double random_double(double min, double max) {\n    // Returns a random real in [min,max).\n    return min + (max-min)*random_double();\n}\n```", "```\n...\n\n#include <random>\n...\n\ninline double random_double() {\n    static std::uniform_real_distribution<double> distribution(0.0, 1.0);\n    static std::mt19937 generator;\n    return distribution(generator);\n}\ninline double random_double(double min, double max) {\n    // Returns a random real in [min,max).\n    return min + (max-min)*random_double();\n}\n\n... \n```", "```\nclass interval {\n  public:\n    ...\n\n    bool surrounds(double x) const {\n        return min < x && x < max;\n    }\n\n    double clamp(double x) const {\n        if (x < min) return min;\n        if (x > max) return max;\n        return x;\n    }    ...\n};\n```", "```\n#include \"interval.h\"#include \"vec3.h\"\n\nusing color = vec3;\n\nvoid write_color(std::ostream& out, const color& pixel_color) {\n    auto r = pixel_color.x();\n    auto g = pixel_color.y();\n    auto b = pixel_color.z();\n\n    // Translate the [0,1] component values to the byte range [0,255].    static const interval intensity(0.000, 0.999);\n    int rbyte = int(256 * intensity.clamp(r));\n    int gbyte = int(256 * intensity.clamp(g));\n    int bbyte = int(256 * intensity.clamp(b));\n    // Write out the pixel color components.\n    out << rbyte << ' ' << gbyte << ' ' << bbyte << '\\n';\n}\n```", "```\nclass camera {\n  public:\n    double aspect_ratio      = 1.0;  // Ratio of image width over height\n    int    image_width       = 100;  // Rendered image width in pixel count    int    samples_per_pixel = 10;   // Count of random samples for each pixel\n    void render(const hittable& world) {\n        initialize();\n\n        std::cout << \"P3\\n\" << image_width << ' ' << image_height << \"\\n255\\n\";\n\n        for (int j = 0; j < image_height; j++) {\n            std::clog << \"\\rScanlines remaining: \" << (image_height - j) << ' ' << std::flush;\n            for (int i = 0; i < image_width; i++) {                color pixel_color(0,0,0);\n                for (int sample = 0; sample < samples_per_pixel; sample++) {\n                    ray r = get_ray(i, j);\n                    pixel_color += ray_color(r, world);\n                }\n                write_color(std::cout, pixel_samples_scale * pixel_color);            }\n        }\n\n        std::clog << \"\\rDone.                 \\n\";\n    }\n    ...\n  private:\n    int    image_height;         // Rendered image height    double pixel_samples_scale;  // Color scale factor for a sum of pixel samples    point3 center;               // Camera center\n    point3 pixel00_loc;          // Location of pixel 0, 0\n    vec3   pixel_delta_u;        // Offset to pixel to the right\n    vec3   pixel_delta_v;        // Offset to pixel below\n\n    void initialize() {\n        image_height = int(image_width / aspect_ratio);\n        image_height = (image_height < 1) ? 1 : image_height;\n\n        pixel_samples_scale = 1.0 / samples_per_pixel;\n        center = point3(0, 0, 0);\n        ...\n    }\n\n    ray get_ray(int i, int j) const {\n        // Construct a camera ray originating from the origin and directed at randomly sampled\n        // point around the pixel location i, j.\n\n        auto offset = sample_square();\n        auto pixel_sample = pixel00_loc\n                          + ((i + offset.x()) * pixel_delta_u)\n                          + ((j + offset.y()) * pixel_delta_v);\n\n        auto ray_origin = center;\n        auto ray_direction = pixel_sample - ray_origin;\n\n        return ray(ray_origin, ray_direction);\n    }\n\n    vec3 sample_square() const {\n        // Returns the vector to a random point in the [-.5,-.5]-[+.5,+.5] unit square.\n        return vec3(random_double() - 0.5, random_double() - 0.5, 0);\n    }\n    color ray_color(const ray& r, const hittable& world) const {\n        ...\n    }\n};\n\n#endif\n```", "```\nint main() {\n    ...\n\n    camera cam;\n\n    cam.aspect_ratio      = 16.0 / 9.0;\n    cam.image_width       = 400;    cam.samples_per_pixel = 100;\n    cam.render(world);\n}\n```", "```\nclass vec3 {\n  public:\n    ...\n\n    double length_squared() const {\n        return e[0]*e[0] + e[1]*e[1] + e[2]*e[2];\n    }\n\n    static vec3 random() {\n        return vec3(random_double(), random_double(), random_double());\n    }\n\n    static vec3 random(double min, double max) {\n        return vec3(random_double(min,max), random_double(min,max), random_double(min,max));\n    }};\n```", "```\n...\n\ninline vec3 unit_vector(const vec3& v) {\n    return v / v.length();\n}\n\ninline vec3 random_unit_vector() {\n    while (true) {\n        auto p = vec3::random(-1,1);\n        auto lensq = p.length_squared();\n        if (lensq <= 1)\n            return p / sqrt(lensq);\n    }\n}\n```", "```\ninline vec3 random_unit_vector() {\n    while (true) {\n        auto p = vec3::random(-1,1);\n        auto lensq = p.length_squared();        if (1e-160 < lensq && lensq <= 1)            return p / sqrt(lensq);\n    }\n}\n```", "```\n...\n\ninline vec3 random_unit_vector() {\n    while (true) {\n        auto p = vec3::random(-1,1);\n        auto lensq = p.length_squared();\n        if (1e-160 < lensq && lensq <= 1)\n            return p / sqrt(lensq);\n    }\n}\n\ninline vec3 random_on_hemisphere(const vec3& normal) {\n    vec3 on_unit_sphere = random_unit_vector();\n    if (dot(on_unit_sphere, normal) > 0.0) // In the same hemisphere as the normal\n        return on_unit_sphere;\n    else\n        return -on_unit_sphere;\n}\n```", "```\nclass camera {\n  ...\n  private:\n    ...\n    color ray_color(const ray& r, const hittable& world) const {\n        hit_record rec;\n\n        if (world.hit(r, interval(0, infinity), rec)) {            vec3 direction = random_on_hemisphere(rec.normal);\n            return 0.5 * ray_color(ray(rec.p, direction), world);        }\n\n        vec3 unit_direction = unit_vector(r.direction());\n        auto a = 0.5*(unit_direction.y() + 1.0);\n        return (1.0-a)*color(1.0, 1.0, 1.0) + a*color(0.5, 0.7, 1.0);\n    }\n};\n```", "```\nclass camera {\n  public:\n    double aspect_ratio      = 1.0;  // Ratio of image width over height\n    int    image_width       = 100;  // Rendered image width in pixel count\n    int    samples_per_pixel = 10;   // Count of random samples for each pixel    int    max_depth         = 10;   // Maximum number of ray bounces into scene\n    void render(const hittable& world) {\n        initialize();\n\n        std::cout << \"P3\\n\" << image_width << ' ' << image_height << \"\\n255\\n\";\n\n        for (int j = 0; j < image_height; j++) {\n            std::clog << \"\\rScanlines remaining: \" << (image_height - j) << ' ' << std::flush;\n            for (int i = 0; i < image_width; i++) {\n                color pixel_color(0,0,0);\n                for (int sample = 0; sample < samples_per_pixel; sample++) {\n                    ray r = get_ray(i, j);                    pixel_color += ray_color(r, max_depth, world);                }\n                write_color(std::cout, pixel_samples_scale * pixel_color);\n            }\n        }\n\n        std::clog << \"\\rDone.                 \\n\";\n    }\n    ...\n  private:\n    ...    color ray_color(const ray& r, int depth, const hittable& world) const {\n        // If we've exceeded the ray bounce limit, no more light is gathered.\n        if (depth <= 0)\n            return color(0,0,0);\n        hit_record rec;\n\n        if (world.hit(r, interval(0, infinity), rec)) {\n            vec3 direction = random_on_hemisphere(rec.normal);            return 0.5 * ray_color(ray(rec.p, direction), depth-1, world);        }\n\n        vec3 unit_direction = unit_vector(r.direction());\n        auto a = 0.5*(unit_direction.y() + 1.0);\n        return (1.0-a)*color(1.0, 1.0, 1.0) + a*color(0.5, 0.7, 1.0);\n    }\n};\n```", "```\nint main() {\n    ...\n\n    camera cam;\n\n    cam.aspect_ratio      = 16.0 / 9.0;\n    cam.image_width       = 400;\n    cam.samples_per_pixel = 100;    cam.max_depth         = 50;\n    cam.render(world);\n}\n```", "```\nclass camera {\n  ...\n  private:\n    ...\n    color ray_color(const ray& r, int depth, const hittable& world) const {\n        // If we've exceeded the ray bounce limit, no more light is gathered.\n        if (depth <= 0)\n            return color(0,0,0);\n\n        hit_record rec;\n\n        if (world.hit(r, interval(0.001, infinity), rec)) {            vec3 direction = random_on_hemisphere(rec.normal);\n            return 0.5 * ray_color(ray(rec.p, direction), depth-1, world);\n        }\n\n        vec3 unit_direction = unit_vector(r.direction());\n        auto a = 0.5*(unit_direction.y() + 1.0);\n        return (1.0-a)*color(1.0, 1.0, 1.0) + a*color(0.5, 0.7, 1.0);\n    }\n};\n```", "```\nclass camera {\n    ...\n    color ray_color(const ray& r, int depth, const hittable& world) const {\n        // If we've exceeded the ray bounce limit, no more light is gathered.\n        if (depth <= 0)\n            return color(0,0,0);\n\n        hit_record rec;\n\n        if (world.hit(r, interval(0.001, infinity), rec)) {            vec3 direction = rec.normal + random_unit_vector();            return 0.5 * ray_color(ray(rec.p, direction), depth-1, world);\n        }\n\n        vec3 unit_direction = unit_vector(r.direction());\n        auto a = 0.5*(unit_direction.y() + 1.0);\n        return (1.0-a)*color(1.0, 1.0, 1.0) + a*color(0.5, 0.7, 1.0);\n    }\n};\n```", "```\nclass camera {\n    ...\n    color ray_color(const ray& r, int depth, const hittable& world) const {\n        // If we've exceeded the ray bounce limit, no more light is gathered.\n        if (depth <= 0)\n            return color(0,0,0);\n\n        hit_record rec;\n\n        if (world.hit(r, interval(0.001, infinity), rec)) {\n            vec3 direction = rec.normal + random_unit_vector();            return 0.1 * ray_color(ray(rec.p, direction), depth-1, world);        }\n\n        vec3 unit_direction = unit_vector(r.direction());\n        auto a = 0.5*(unit_direction.y() + 1.0);\n        return (1.0-a)*color(1.0, 1.0, 1.0) + a*color(0.5, 0.7, 1.0);\n    }\n};\n```", "```\ninline double linear_to_gamma(double linear_component) {\n    if (linear_component > 0)\n        return std::sqrt(linear_component);\n\n    return 0;\n}\nvoid write_color(std::ostream& out, const color& pixel_color) {\n    auto r = pixel_color.x();\n    auto g = pixel_color.y();\n    auto b = pixel_color.z();\n\n    // Apply a linear to gamma transform for gamma 2\n    r = linear_to_gamma(r);\n    g = linear_to_gamma(g);\n    b = linear_to_gamma(b);\n    // Translate the [0,1] component values to the byte range [0,255].\n    static const interval intensity(0.000, 0.999);\n    int rbyte = int(256 * intensity.clamp(r));\n    int gbyte = int(256 * intensity.clamp(g));\n    int bbyte = int(256 * intensity.clamp(b));\n\n    // Write out the pixel color components.\n    out << rbyte << ' ' << gbyte << ' ' << bbyte << '\\n';\n}\n```", "```\n#ifndef MATERIAL_H\n#define MATERIAL_H\n\n#include \"hittable.h\"\n\nclass material {\n  public:\n    virtual ~material() = default;\n\n    virtual bool scatter(\n        const ray& r_in, const hit_record& rec, color& attenuation, ray& scattered\n    ) const {\n        return false;\n    }\n};\n\n#endif\n```", "```\nclass material;\nclass hit_record {\n  public:\n    point3 p;\n    vec3 normal;    shared_ptr<material> mat;    double t;\n    bool front_face;\n\n    void set_face_normal(const ray& r, const vec3& outward_normal) {\n        front_face = dot(r.direction(), outward_normal) < 0;\n        normal = front_face ? outward_normal : -outward_normal;\n    }\n};\n```", "```\nclass sphere : public hittable {\n  public:    sphere(const point3& center, double radius) : center(center), radius(std::fmax(0,radius)) {\n        // TODO: Initialize the material pointer `mat`.\n    }\n    bool hit(const ray& r, interval ray_t, hit_record& rec) const override {\n        ...\n\n        rec.t = root;\n        rec.p = r.at(rec.t);\n        vec3 outward_normal = (rec.p - center) / radius;\n        rec.set_face_normal(r, outward_normal);        rec.mat = mat;\n        return true;\n    }\n\n  private:\n    point3 center;\n    double radius;    shared_ptr<material> mat;};\n```", "```\nclass material {\n    ...\n};\n\nclass lambertian : public material {\n  public:\n    lambertian(const color& albedo) : albedo(albedo) {}\n\n    bool scatter(const ray& r_in, const hit_record& rec, color& attenuation, ray& scattered)\n    const override {\n        auto scatter_direction = rec.normal + random_unit_vector();\n        scattered = ray(rec.p, scatter_direction);\n        attenuation = albedo;\n        return true;\n    }\n\n  private:\n    color albedo;\n};\n```", "```\nclass vec3 {\n    ...\n\n    double length_squared() const {\n        return e[0]*e[0] + e[1]*e[1] + e[2]*e[2];\n    }\n\n    bool near_zero() const {\n        // Return true if the vector is close to zero in all dimensions.\n        auto s = 1e-8;\n        return (std::fabs(e[0]) < s) && (std::fabs(e[1]) < s) && (std::fabs(e[2]) < s);\n    }\n    ...\n};\n```", "```\nclass lambertian : public material {\n  public:\n    lambertian(const color& albedo) : albedo(albedo) {}\n\n    bool scatter(const ray& r_in, const hit_record& rec, color& attenuation, ray& scattered)\n    const override {\n        auto scatter_direction = rec.normal + random_unit_vector();\n\n        // Catch degenerate scatter direction\n        if (scatter_direction.near_zero())\n            scatter_direction = rec.normal;\n        scattered = ray(rec.p, scatter_direction);\n        attenuation = albedo;\n        return true;\n    }\n\n  private:\n    color albedo;\n};\n```", "```\n...\n\ninline vec3 random_on_hemisphere(const vec3& normal) {\n    ...\n}\n\ninline vec3 reflect(const vec3& v, const vec3& n) {\n    return v - 2*dot(v,n)*n;\n}\n```", "```\n...\n\nclass lambertian : public material {\n    ...\n};\n\nclass metal : public material {\n  public:\n    metal(const color& albedo) : albedo(albedo) {}\n\n    bool scatter(const ray& r_in, const hit_record& rec, color& attenuation, ray& scattered)\n    const override {\n        vec3 reflected = reflect(r_in.direction(), rec.normal);\n        scattered = ray(rec.p, reflected);\n        attenuation = albedo;\n        return true;\n    }\n\n  private:\n    color albedo;\n};\n```", "```\n#include \"hittable.h\"#include \"material.h\"...\n\nclass camera {\n  ...\n  private:\n    ...\n    color ray_color(const ray& r, int depth, const hittable& world) const {\n        // If we've exceeded the ray bounce limit, no more light is gathered.\n        if (depth <= 0)\n            return color(0,0,0);\n\n        hit_record rec;\n\n        if (world.hit(r, interval(0.001, infinity), rec)) {            ray scattered;\n            color attenuation;\n            if (rec.mat->scatter(r, rec, attenuation, scattered))\n                return attenuation * ray_color(scattered, depth-1, world);\n            return color(0,0,0);        }\n\n        vec3 unit_direction = unit_vector(r.direction());\n        auto a = 0.5*(unit_direction.y() + 1.0);\n        return (1.0-a)*color(1.0, 1.0, 1.0) + a*color(0.5, 0.7, 1.0);\n    }\n};\n```", "```\nclass sphere : public hittable {\n  public:    sphere(const point3& center, double radius, shared_ptr<material> mat)\n      : center(center), radius(std::fmax(0,radius)), mat(mat) {}\n    ...\n};\n```", "```\n#include \"rtweekend.h\"\n\n#include \"camera.h\"\n#include \"hittable.h\"\n#include \"hittable_list.h\"#include \"material.h\"#include \"sphere.h\"\n\nint main() {\n    hittable_list world;\n\n    auto material_ground = make_shared<lambertian>(color(0.8, 0.8, 0.0));\n    auto material_center = make_shared<lambertian>(color(0.1, 0.2, 0.5));\n    auto material_left   = make_shared<metal>(color(0.8, 0.8, 0.8));\n    auto material_right  = make_shared<metal>(color(0.8, 0.6, 0.2));\n\n    world.add(make_shared<sphere>(point3( 0.0, -100.5, -1.0), 100.0, material_ground));\n    world.add(make_shared<sphere>(point3( 0.0,    0.0, -1.2),   0.5, material_center));\n    world.add(make_shared<sphere>(point3(-1.0,    0.0, -1.0),   0.5, material_left));\n    world.add(make_shared<sphere>(point3( 1.0,    0.0, -1.0),   0.5, material_right));\n    camera cam;\n\n    cam.aspect_ratio      = 16.0 / 9.0;\n    cam.image_width       = 400;\n    cam.samples_per_pixel = 100;\n    cam.max_depth         = 50;\n\n    cam.render(world);\n}\n```", "```\nclass metal : public material {\n  public:    metal(const color& albedo, double fuzz) : albedo(albedo), fuzz(fuzz < 1 ? fuzz : 1) {}\n    bool scatter(const ray& r_in, const hit_record& rec, color& attenuation, ray& scattered)\n    const override {\n        vec3 reflected = reflect(r_in.direction(), rec.normal);        reflected = unit_vector(reflected) + (fuzz * random_unit_vector());        scattered = ray(rec.p, reflected);\n        attenuation = albedo;        return (dot(scattered.direction(), rec.normal) > 0);    }\n\n  private:\n    color albedo;    double fuzz;};\n```", "```\nint main() {\n    ...\n    auto material_ground = make_shared<lambertian>(color(0.8, 0.8, 0.0));\n    auto material_center = make_shared<lambertian>(color(0.1, 0.2, 0.5));    auto material_left   = make_shared<metal>(color(0.8, 0.8, 0.8), 0.3);\n    auto material_right  = make_shared<metal>(color(0.8, 0.6, 0.2), 1.0);    ...\n}\n```", "```\n...\n\ninline vec3 reflect(const vec3& v, const vec3& n) {\n    return v - 2*dot(v,n)*n;\n}\n\ninline vec3 refract(const vec3& uv, const vec3& n, double etai_over_etat) {\n    auto cos_theta = std::fmin(dot(-uv, n), 1.0);\n    vec3 r_out_perp =  etai_over_etat * (uv + cos_theta*n);\n    vec3 r_out_parallel = -std::sqrt(std::fabs(1.0 - r_out_perp.length_squared())) * n;\n    return r_out_perp + r_out_parallel;\n}\n```", "```\n...\n\nclass metal : public material {\n    ...\n};\n\nclass dielectric : public material {\n  public:\n    dielectric(double refraction_index) : refraction_index(refraction_index) {}\n\n    bool scatter(const ray& r_in, const hit_record& rec, color& attenuation, ray& scattered)\n    const override {\n        attenuation = color(1.0, 1.0, 1.0);\n        double ri = rec.front_face ? (1.0/refraction_index) : refraction_index;\n\n        vec3 unit_direction = unit_vector(r_in.direction());\n        vec3 refracted = refract(unit_direction, rec.normal, ri);\n\n        scattered = ray(rec.p, refracted);\n        return true;\n    }\n\n  private:\n    // Refractive index in vacuum or air, or the ratio of the material's refractive index over\n    // the refractive index of the enclosing media\n    double refraction_index;\n};\n```", "```\nauto material_ground = make_shared<lambertian>(color(0.8, 0.8, 0.0));\nauto material_center = make_shared<lambertian>(color(0.1, 0.2, 0.5));auto material_left   = make_shared<dielectric>(1.50);auto material_right  = make_shared<metal>(color(0.8, 0.6, 0.2), 1.0);\n```", "```\nif (ri * sin_theta > 1.0) {\n    // Must Reflect\n    ...\n} else {\n    // Can Refract\n    ...\n}\n```", "```\ndouble cos_theta = std::fmin(dot(-unit_direction, rec.normal), 1.0);\ndouble sin_theta = std::sqrt(1.0 - cos_theta*cos_theta);\n\nif (ri * sin_theta > 1.0) {\n    // Must Reflect\n    ...\n} else {\n    // Can Refract\n    ...\n}\n```", "```\nclass dielectric : public material {\n  public:\n    dielectric(double refraction_index) : refraction_index(refraction_index) {}\n\n    bool scatter(const ray& r_in, const hit_record& rec, color& attenuation, ray& scattered)\n    const override {\n        attenuation = color(1.0, 1.0, 1.0);\n        double ri = rec.front_face ? (1.0/refraction_index) : refraction_index;\n\n        vec3 unit_direction = unit_vector(r_in.direction());        double cos_theta = std::fmin(dot(-unit_direction, rec.normal), 1.0);\n        double sin_theta = std::sqrt(1.0 - cos_theta*cos_theta);\n\n        bool cannot_refract = ri * sin_theta > 1.0;\n        vec3 direction;\n\n        if (cannot_refract)\n            direction = reflect(unit_direction, rec.normal);\n        else\n            direction = refract(unit_direction, rec.normal, ri);\n\n        scattered = ray(rec.p, direction);        return true;\n    }\n\n  private:\n    // Refractive index in vacuum or air, or the ratio of the material's refractive index over\n    // the refractive index of the enclosing media\n    double refraction_index;\n};\n```", "```\nauto material_ground = make_shared<lambertian>(color(0.8, 0.8, 0.0));\nauto material_center = make_shared<lambertian>(color(0.1, 0.2, 0.5));auto material_left   = make_shared<dielectric>(1.00 / 1.33);auto material_right  = make_shared<metal>(color(0.8, 0.6, 0.2), 1.0);\n```", "```\nclass dielectric : public material {\n  public:\n    dielectric(double refraction_index) : refraction_index(refraction_index) {}\n\n    bool scatter(const ray& r_in, const hit_record& rec, color& attenuation, ray& scattered)\n    const override {\n        attenuation = color(1.0, 1.0, 1.0);\n        double ri = rec.front_face ? (1.0/refraction_index) : refraction_index;\n\n        vec3 unit_direction = unit_vector(r_in.direction());\n        double cos_theta = std::fmin(dot(-unit_direction, rec.normal), 1.0);\n        double sin_theta = std::sqrt(1.0 - cos_theta*cos_theta);\n\n        bool cannot_refract = ri * sin_theta > 1.0;\n        vec3 direction;\n\n        if (cannot_refract || reflectance(cos_theta, ri) > random_double())            direction = reflect(unit_direction, rec.normal);\n        else\n            direction = refract(unit_direction, rec.normal, ri);\n\n        scattered = ray(rec.p, direction);\n        return true;\n    }\n\n  private:\n    // Refractive index in vacuum or air, or the ratio of the material's refractive index over\n    // the refractive index of the enclosing media\n    double refraction_index;\n\n    static double reflectance(double cosine, double refraction_index) {\n        // Use Schlick's approximation for reflectance.\n        auto r0 = (1 - refraction_index) / (1 + refraction_index);\n        r0 = r0*r0;\n        return r0 + (1-r0)*std::pow((1 - cosine),5);\n    }};\n```", "```\n...\nauto material_ground = make_shared<lambertian>(color(0.8, 0.8, 0.0));\nauto material_center = make_shared<lambertian>(color(0.1, 0.2, 0.5));auto material_left   = make_shared<dielectric>(1.50);\nauto material_bubble = make_shared<dielectric>(1.00 / 1.50);auto material_right  = make_shared<metal>(color(0.8, 0.6, 0.2), 0.0);\n\nworld.add(make_shared<sphere>(point3( 0.0, -100.5, -1.0), 100.0, material_ground));\nworld.add(make_shared<sphere>(point3( 0.0,    0.0, -1.2),   0.5, material_center));\nworld.add(make_shared<sphere>(point3(-1.0,    0.0, -1.0),   0.5, material_left));world.add(make_shared<sphere>(point3(-1.0,    0.0, -1.0),   0.4, material_bubble));world.add(make_shared<sphere>(point3( 1.0,    0.0, -1.0),   0.5, material_right));\n...\n```", "```\nclass camera {\n  public:\n    double aspect_ratio      = 1.0;  // Ratio of image width over height\n    int    image_width       = 100;  // Rendered image width in pixel count\n    int    samples_per_pixel = 10;   // Count of random samples for each pixel\n    int    max_depth         = 10;   // Maximum number of ray bounces into scene\n\n    double vfov = 90;  // Vertical view angle (field of view)\n    void render(const hittable& world) {\n    ...\n\n  private:\n    ...\n\n    void initialize() {\n        image_height = int(image_width / aspect_ratio);\n        image_height = (image_height < 1) ? 1 : image_height;\n\n        pixel_samples_scale = 1.0 / samples_per_pixel;\n\n        center = point3(0, 0, 0);\n\n        // Determine viewport dimensions.\n        auto focal_length = 1.0;        auto theta = degrees_to_radians(vfov);\n        auto h = std::tan(theta/2);\n        auto viewport_height = 2 * h * focal_length;        auto viewport_width = viewport_height * (double(image_width)/image_height);\n\n        // Calculate the vectors across the horizontal and down the vertical viewport edges.\n        auto viewport_u = vec3(viewport_width, 0, 0);\n        auto viewport_v = vec3(0, -viewport_height, 0);\n\n        // Calculate the horizontal and vertical delta vectors from pixel to pixel.\n        pixel_delta_u = viewport_u / image_width;\n        pixel_delta_v = viewport_v / image_height;\n\n        // Calculate the location of the upper left pixel.\n        auto viewport_upper_left =\n            center - vec3(0, 0, focal_length) - viewport_u/2 - viewport_v/2;\n        pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);\n    }\n\n    ...\n};\n```", "```\nint main() {\n    hittable_list world;\n\n    auto R = std::cos(pi/4);\n\n    auto material_left  = make_shared<lambertian>(color(0,0,1));\n    auto material_right = make_shared<lambertian>(color(1,0,0));\n\n    world.add(make_shared<sphere>(point3(-R, 0, -1), R, material_left));\n    world.add(make_shared<sphere>(point3( R, 0, -1), R, material_right));\n    camera cam;\n\n    cam.aspect_ratio      = 16.0 / 9.0;\n    cam.image_width       = 400;\n    cam.samples_per_pixel = 100;\n    cam.max_depth         = 50;\n\n    cam.vfov = 90;\n    cam.render(world);\n}\n```", "```\nclass camera {\n  public:\n    double aspect_ratio      = 1.0;  // Ratio of image width over height\n    int    image_width       = 100;  // Rendered image width in pixel count\n    int    samples_per_pixel = 10;   // Count of random samples for each pixel\n    int    max_depth         = 10;   // Maximum number of ray bounces into scene\n\n    double vfov     = 90;              // Vertical view angle (field of view)    point3 lookfrom = point3(0,0,0);   // Point camera is looking from\n    point3 lookat   = point3(0,0,-1);  // Point camera is looking at\n    vec3   vup      = vec3(0,1,0);     // Camera-relative \"up\" direction\n    ...\n\n  private:\n    int    image_height;         // Rendered image height\n    double pixel_samples_scale;  // Color scale factor for a sum of pixel samples\n    point3 center;               // Camera center\n    point3 pixel00_loc;          // Location of pixel 0, 0\n    vec3   pixel_delta_u;        // Offset to pixel to the right\n    vec3   pixel_delta_v;        // Offset to pixel below    vec3   u, v, w;              // Camera frame basis vectors\n    void initialize() {\n        image_height = int(image_width / aspect_ratio);\n        image_height = (image_height < 1) ? 1 : image_height;\n\n        pixel_samples_scale = 1.0 / samples_per_pixel;\n\n        center = lookfrom;\n        // Determine viewport dimensions.        auto focal_length = (lookfrom - lookat).length();        auto theta = degrees_to_radians(vfov);\n        auto h = std::tan(theta/2);\n        auto viewport_height = 2 * h * focal_length;\n        auto viewport_width = viewport_height * (double(image_width)/image_height);\n\n        // Calculate the u,v,w unit basis vectors for the camera coordinate frame.\n        w = unit_vector(lookfrom - lookat);\n        u = unit_vector(cross(vup, w));\n        v = cross(w, u);\n        // Calculate the vectors across the horizontal and down the vertical viewport edges.        vec3 viewport_u = viewport_width * u;    // Vector across viewport horizontal edge\n        vec3 viewport_v = viewport_height * -v;  // Vector down viewport vertical edge\n        // Calculate the horizontal and vertical delta vectors from pixel to pixel.\n        pixel_delta_u = viewport_u / image_width;\n        pixel_delta_v = viewport_v / image_height;\n\n        // Calculate the location of the upper left pixel.        auto viewport_upper_left = center - (focal_length * w) - viewport_u/2 - viewport_v/2;        pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);\n    }\n\n    ...\n\n  private:\n};\n```", "```\nint main() {\n    hittable_list world;\n\n    auto material_ground = make_shared<lambertian>(color(0.8, 0.8, 0.0));\n    auto material_center = make_shared<lambertian>(color(0.1, 0.2, 0.5));\n    auto material_left   = make_shared<dielectric>(1.50);\n    auto material_bubble = make_shared<dielectric>(1.00 / 1.50);\n    auto material_right  = make_shared<metal>(color(0.8, 0.6, 0.2), 1.0);\n\n    world.add(make_shared<sphere>(point3( 0.0, -100.5, -1.0), 100.0, material_ground));\n    world.add(make_shared<sphere>(point3( 0.0,    0.0, -1.2),   0.5, material_center));\n    world.add(make_shared<sphere>(point3(-1.0,    0.0, -1.0),   0.5, material_left));\n    world.add(make_shared<sphere>(point3(-1.0,    0.0, -1.0),   0.4, material_bubble));\n    world.add(make_shared<sphere>(point3( 1.0,    0.0, -1.0),   0.5, material_right));\n    camera cam;\n\n    cam.aspect_ratio      = 16.0 / 9.0;\n    cam.image_width       = 400;\n    cam.samples_per_pixel = 100;\n    cam.max_depth         = 50;\n\n    cam.vfov     = 90;    cam.lookfrom = point3(-2,2,1);\n    cam.lookat   = point3(0,0,-1);\n    cam.vup      = vec3(0,1,0);\n    cam.render(world);\n}\n```", "```\n cam.vfov     = 20;\n```", "```\n...\n\ninline vec3 unit_vector(const vec3& u) {\n    return v / v.length();\n}\n\ninline vec3 random_in_unit_disk() {\n    while (true) {\n        auto p = vec3(random_double(-1,1), random_double(-1,1), 0);\n        if (p.length_squared() < 1)\n            return p;\n    }\n}\n...\n```", "```\nclass camera {\n  public:\n    double aspect_ratio      = 1.0;  // Ratio of image width over height\n    int    image_width       = 100;  // Rendered image width in pixel count\n    int    samples_per_pixel = 10;   // Count of random samples for each pixel\n    int    max_depth         = 10;   // Maximum number of ray bounces into scene\n\n    double vfov     = 90;              // Vertical view angle (field of view)\n    point3 lookfrom = point3(0,0,0);   // Point camera is looking from\n    point3 lookat   = point3(0,0,-1);  // Point camera is looking at\n    vec3   vup      = vec3(0,1,0);     // Camera-relative \"up\" direction\n\n    double defocus_angle = 0;  // Variation angle of rays through each pixel\n    double focus_dist = 10;    // Distance from camera lookfrom point to plane of perfect focus\n    ...\n\n  private:\n    int    image_height;         // Rendered image height\n    double pixel_samples_scale;  // Color scale factor for a sum of pixel samples\n    point3 center;               // Camera center\n    point3 pixel00_loc;          // Location of pixel 0, 0\n    vec3   pixel_delta_u;        // Offset to pixel to the right\n    vec3   pixel_delta_v;        // Offset to pixel below\n    vec3   u, v, w;              // Camera frame basis vectors    vec3   defocus_disk_u;       // Defocus disk horizontal radius\n    vec3   defocus_disk_v;       // Defocus disk vertical radius\n    void initialize() {\n        image_height = int(image_width / aspect_ratio);\n        image_height = (image_height < 1) ? 1 : image_height;\n\n        pixel_samples_scale = 1.0 / samples_per_pixel;\n\n        center = lookfrom;\n\n        // Determine viewport dimensions.        auto focal_length = (lookfrom - lookat).length();        auto theta = degrees_to_radians(vfov);\n        auto h = std::tan(theta/2);        auto viewport_height = 2 * h * focus_dist;        auto viewport_width = viewport_height * (double(image_width)/image_height);\n\n        // Calculate the u,v,w unit basis vectors for the camera coordinate frame.\n        w = unit_vector(lookfrom - lookat);\n        u = unit_vector(cross(vup, w));\n        v = cross(w, u);\n\n        // Calculate the vectors across the horizontal and down the vertical viewport edges.\n        vec3 viewport_u = viewport_width * u;    // Vector across viewport horizontal edge\n        vec3 viewport_v = viewport_height * -v;  // Vector down viewport vertical edge\n\n        // Calculate the horizontal and vertical delta vectors to the next pixel.\n        pixel_delta_u = viewport_u / image_width;\n        pixel_delta_v = viewport_v / image_height;\n\n        // Calculate the location of the upper left pixel.        auto viewport_upper_left = center - (focus_dist * w) - viewport_u/2 - viewport_v/2;        pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);\n\n        // Calculate the camera defocus disk basis vectors.\n        auto defocus_radius = focus_dist * std::tan(degrees_to_radians(defocus_angle / 2));\n        defocus_disk_u = u * defocus_radius;\n        defocus_disk_v = v * defocus_radius;    }\n\n    ray get_ray(int i, int j) const {        // Construct a camera ray originating from the defocus disk and directed at a randomly\n        // sampled point around the pixel location i, j.\n        auto offset = sample_square();\n        auto pixel_sample = pixel00_loc\n                          + ((i + offset.x()) * pixel_delta_u)\n                          + ((j + offset.y()) * pixel_delta_v);\n\n        auto ray_origin = (defocus_angle <= 0) ? center : defocus_disk_sample();        auto ray_direction = pixel_sample - ray_origin;\n\n        return ray(ray_origin, ray_direction);\n    }\n\n    vec3 sample_square() const {\n        ...\n    }\n\n    point3 defocus_disk_sample() const {\n        // Returns a random point in the camera defocus disk.\n        auto p = random_in_unit_disk();\n        return center + (p[0] * defocus_disk_u) + (p[1] * defocus_disk_v);\n    }\n    color ray_color(const ray& r, int depth, const hittable& world) const {\n        ...\n    }\n};\n```", "```\nint main() {\n    ...\n\n    camera cam;\n\n    cam.aspect_ratio      = 16.0 / 9.0;\n    cam.image_width       = 400;\n    cam.samples_per_pixel = 100;\n    cam.max_depth         = 50;\n\n    cam.vfov     = 20;\n    cam.lookfrom = point3(-2,2,1);\n    cam.lookat   = point3(0,0,-1);\n    cam.vup      = vec3(0,1,0);\n\n    cam.defocus_angle = 10.0;\n    cam.focus_dist    = 3.4;\n    cam.render(world);\n}\n```", "```\nint main() {\n    hittable_list world;\n\n    auto ground_material = make_shared<lambertian>(color(0.5, 0.5, 0.5));\n    world.add(make_shared<sphere>(point3(0,-1000,0), 1000, ground_material));\n\n    for (int a = -11; a < 11; a++) {\n        for (int b = -11; b < 11; b++) {\n            auto choose_mat = random_double();\n            point3 center(a + 0.9*random_double(), 0.2, b + 0.9*random_double());\n\n            if ((center - point3(4, 0.2, 0)).length() > 0.9) {\n                shared_ptr<material> sphere_material;\n\n                if (choose_mat < 0.8) {\n                    // diffuse\n                    auto albedo = color::random() * color::random();\n                    sphere_material = make_shared<lambertian>(albedo);\n                    world.add(make_shared<sphere>(center, 0.2, sphere_material));\n                } else if (choose_mat < 0.95) {\n                    // metal\n                    auto albedo = color::random(0.5, 1);\n                    auto fuzz = random_double(0, 0.5);\n                    sphere_material = make_shared<metal>(albedo, fuzz);\n                    world.add(make_shared<sphere>(center, 0.2, sphere_material));\n                } else {\n                    // glass\n                    sphere_material = make_shared<dielectric>(1.5);\n                    world.add(make_shared<sphere>(center, 0.2, sphere_material));\n                }\n            }\n        }\n    }\n\n    auto material1 = make_shared<dielectric>(1.5);\n    world.add(make_shared<sphere>(point3(0, 1, 0), 1.0, material1));\n\n    auto material2 = make_shared<lambertian>(color(0.4, 0.2, 0.1));\n    world.add(make_shared<sphere>(point3(-4, 1, 0), 1.0, material2));\n\n    auto material3 = make_shared<metal>(color(0.7, 0.6, 0.5), 0.0);\n    world.add(make_shared<sphere>(point3(4, 1, 0), 1.0, material3));\n    camera cam;\n\n    cam.aspect_ratio      = 16.0 / 9.0;\n    cam.image_width       = 1200;\n    cam.samples_per_pixel = 500;\n    cam.max_depth         = 50;\n\n    cam.vfov     = 20;\n    cam.lookfrom = point3(13,2,3);\n    cam.lookat   = point3(0,0,0);\n    cam.vup      = vec3(0,1,0);\n\n    cam.defocus_angle = 0.6;\n    cam.focus_dist    = 10.0;\n    cam.render(world);\n}\n```", "```\n[_Ray Tracing in One Weekend_](https://raytracing.github.io/books/RayTracingInOneWeekend.html)\n```", "```\n<a href=\"https://raytracing.github.io/books/RayTracingInOneWeekend.html\">\n    <cite>Ray Tracing in One Weekend</cite>\n</a>\n```", "```\n~\\cite{Shirley2025RTW1}\n\n@misc{Shirley2025RTW1,\n   title = {Ray Tracing in One Weekend},\n   author = {Peter Shirley, Trevor David Black, Steve Hollasch},\n   year = {2025},\n   month = {April},\n   note = {\\small \\texttt{https://raytracing.github.io/books/RayTracingInOneWeekend.html}},\n   url = {https://raytracing.github.io/books/RayTracingInOneWeekend.html}\n}\n```", "```\n\\usepackage{biblatex}\n\n~\\cite{Shirley2025RTW1}\n\n@online{Shirley2025RTW1,\n   title = {Ray Tracing in One Weekend},\n   author = {Peter Shirley, Trevor David Black, Steve Hollasch},\n   year = {2025},\n   month = {April},\n   url = {https://raytracing.github.io/books/RayTracingInOneWeekend.html}\n}\n```", "```\nRay Tracing in One Weekend. raytracing.github.io/books/RayTracingInOneWeekend.html\n(accessed MMM. DD, YYYY)\n```", "```\nRay Tracing in One Weekend. raytracing.github.io/books/RayTracingInOneWeekend.html\nAccessed DD MMM. YYYY.\n```"]