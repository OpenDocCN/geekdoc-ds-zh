- en: 17.2¬†Basic Graph Traversalsüîó
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://dcic-world.org/2025-08-27/basic-graph-trav.html](https://dcic-world.org/2025-08-27/basic-graph-trav.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| ¬†¬†¬†¬†[17.2.1¬†Reachability](#%28part._.Reachability%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[17.2.1.1¬†Simple Recursion](#%28part._.Simple_.Recursion%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[17.2.1.2¬†Cleaning up the Loop](#%28part._.Cleaning_up_the_.Loop%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[17.2.1.3¬†Traversal with Memory](#%28part._.Traversal_with_.Memory%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[17.2.1.4¬†A Better Interface](#%28part._.A_.Better_.Interface%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[17.2.2¬†Depth- and Breadth-First Traversals](#%28part._dfs-bfs%29) |'
  prefs: []
  type: TYPE_TB
- en: As with all the data we have seen so far, to process a datum we have to traverse
    it‚Äî<wbr>i.e., visit the constituent data. With graphs, that can be quite interesting!
  prefs: []
  type: TYPE_NORMAL
- en: 17.2.1¬†Reachability[üîó](#(part._.Reachability) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Many uses of graphs need to address reachability: whether we can, using edges
    in the graph, get from one node to another. For instance, a social network might
    suggest as contacts all those who are reachable from existing contacts. On the
    Internet, traffic engineers care about whether packets can get from one machine
    to another. On the Web, we care about whether all public pages on a site are reachable
    from the home page. We will study how to compute reachability using our travel
    graph as a running example.'
  prefs: []
  type: TYPE_NORMAL
- en: 17.2.1.1¬†Simple Recursion[üîó](#(part._.Simple_.Recursion) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'At its simplest, reachability is easy. We want to know whether there exists
    a pathA path is a sequence of zero or more linked edges. between a pair of nodes,
    a source and a destination. (A more sophisticated version of reachability might
    compute the actual path, but we‚Äôll ignore this for now.) There are two possibilities:
    the source and destintion nodes are the same, or they‚Äôre not.'
  prefs: []
  type: TYPE_NORMAL
- en: If they are the same, then clearly reachability is trivially satisfied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If they are not, we have to iterate through the neighbors of the source node
    and ask whether the destination is reachable from each of those neighbors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This translates into the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: <graph-reach-1-main> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'where the loop through the neighbors of `src` is:'
  prefs: []
  type: TYPE_NORMAL
- en: <graph-reach-1-loop> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <graph-reach-tests> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, we don‚Äôt find out about how these tests fare, because some of
    them don‚Äôt complete at all. That‚Äôs because we have an infinite loop, due to the
    cyclic nature of graphs!
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the above examples leads to a cycle? Why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 17.2.1.2¬†Cleaning up the Loop[üîó](#(part._.Cleaning_up_the_.Loop) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Before we continue, let‚Äôs try to improve the expression of the loop. While the
    nested function above is a perfectly reasonable definition, we can use Pyret‚Äôs
    `for` to improve its readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The essence of the above loop is to iterate over a list of boolean values;
    if one of them is true, the entire loop evaluates to true; if they are all false,
    then we haven‚Äôt found a path to the destination node, so the loop evaluates to
    false. Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can replace the loop definition and use with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 17.2.1.3¬†Traversal with Memory[üîó](#(part._.Traversal_with_.Memory) "Link to
    here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Because we have cyclic data, we have to remember what nodes we‚Äôve already visited
    and avoid traversing them again. Then, every time we begin traversing a new node,
    we add it to the set of nodes we‚Äôve already started to visit so that. If we return
    to that node, because we can assume the graph has not changed in the meanwhile,
    we know that additional traversals from that node won‚Äôt make any difference to
    the outcome.This property is known as [‚òõ idempotence](glossary.html#%28elem._glossary-idempotence%29).
  prefs: []
  type: TYPE_NORMAL
- en: 'We therefore define a second attempt at reachability that take an extra argument:
    the set of nodes we have begun visiting (where the set is represented as a graph).
    The key difference from [<graph-reach-1-main>](#%28elem._graph-reach-1-main%29)
    is, before we begin to traverse edges, we should check whether we‚Äôve begun processing
    the node or not. This results in the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: <graph-reach-2> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In particular, note the extra new conditional: if the reachability check has
    already visited this node before, there is no point traversing further from here,
    so it returns `false`. (There may still be other parts of the graph to explore,
    which other recursive calls will do.)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does it matter if the first two conditions were swapped, i.e., the beginning
    of `reach-2` began with
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '? Explain concretely with examples.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We repeatedly talk about remembering the nodes that we have begun to visit,
    not the ones we‚Äôve finished visiting. Does this distinction matter? How?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 17.2.1.4¬†A Better Interface[üîó](#(part._.A_.Better_.Interface) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As the process of testing `reach-2` shows, we may have a better implementation,
    but we‚Äôve changed the function‚Äôs interface; now it has a needless extra argument,
    which is not only a nuisance but might also result in errors if we accidentally
    misuse it. Therefore, we should clean up our definition by moving the core code
    to an internal function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We have now restored the original interface while correctly implementing reachability.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does this really gives us a correct implementation? In particular, does this
    address the problem that the `size` function above addressed? Create a test case
    that demonstrates the problem, and then fix it.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 17.2.2¬†Depth- and Breadth-First Traversals[üîó](#(part._dfs-bfs) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is conventional for computer science texts to call these depth- and breadth-first
    search. However, searching is just a specific purpose; traversal is a general
    task that can be used for many purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reachability algorithm we have seen above has a special property. At every
    node it visits, there is usually a set of adjacent nodes at which it can continue
    the traversal. It has at least two choices: it can either visit each immediate
    neighbor first, then visit all of the neighbors‚Äô neighbors; or it can choose a
    neighbor, recur, and visit the next immediate neighbor only after that visit is
    done. The former is known as breadth-first traversal, while the latter is depth-first
    traversal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm we have designed uses a depth-first strategy: inside [<graph-reach-1-loop>](#%28elem._graph-reach-1-loop%29),
    we recur on the first element of the list of neighbors before we visit the second
    neighbor, and so on. The alternative would be to have a data structure into which
    we insert all the neighbors, then pull out an element at a time such that we first
    visit all the neighbors before their neighbors, and so on. This naturally corresponds
    to a queue [[An Example: Queues from Lists](amortized-analysis.html#%28part._queue-data-structure%29)].'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using a queue, implement breadth-first traversal.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If we correctly check to ensure we don‚Äôt re-visit nodes, then both breadth-
    and depth-first traversal will properly visit the entire reachable graph without
    repetition (and hence not get into an infinite loop). Each one traverses from
    a node only once, from which it considers every single edge. Thus, if a graph
    has \(N\) nodes and \(E\) edges, then a lower-bound on the complexity of traversal
    is \(O([N, E \rightarrow N + E])\). We must also consider the cost of checking
    whether we have already visited a node before (which is a set membership problem,
    which we address elsewhere: [Several Variations on Sets](part_sets.html)). Finally,
    we have to consider the cost of maintaining the data structure that keeps track
    of our traversal. In the case of depth-first traversal, recursion‚Äî<wbr>which uses
    the machine‚Äôs stack‚Äî<wbr>does it automatically at constant overhead. In the case
    of breadth-first traversal, the program must manage the queue, which can add more
    than constant overhead.In practice, too, the stack will usually perform much better
    than a queue, because it is supported by machine hardware.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This would suggest that depth-first traversal is always better than breadth-first
    traversal. However, breadth-first traversal has one very important and valuable
    property. Starting from a node \(N\), when it visits a node \(P\), count the number
    of edges taken to get to \(P\). Breadth-first traversal guarantees that there
    cannot have been a shorter path to \(P\): that is, it finds a shortest path to
    \(P\).'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why ‚Äúa‚Äù rather than ‚Äúthe‚Äù shortest path?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Prove that breadth-first traversal finds a shortest path.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 17.2.1¬†Reachability[üîó](#(part._.Reachability) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Many uses of graphs need to address reachability: whether we can, using edges
    in the graph, get from one node to another. For instance, a social network might
    suggest as contacts all those who are reachable from existing contacts. On the
    Internet, traffic engineers care about whether packets can get from one machine
    to another. On the Web, we care about whether all public pages on a site are reachable
    from the home page. We will study how to compute reachability using our travel
    graph as a running example.'
  prefs: []
  type: TYPE_NORMAL
- en: 17.2.1.1¬†Simple Recursion[üîó](#(part._.Simple_.Recursion) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'At its simplest, reachability is easy. We want to know whether there exists
    a pathA path is a sequence of zero or more linked edges. between a pair of nodes,
    a source and a destination. (A more sophisticated version of reachability might
    compute the actual path, but we‚Äôll ignore this for now.) There are two possibilities:
    the source and destintion nodes are the same, or they‚Äôre not.'
  prefs: []
  type: TYPE_NORMAL
- en: If they are the same, then clearly reachability is trivially satisfied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If they are not, we have to iterate through the neighbors of the source node
    and ask whether the destination is reachable from each of those neighbors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This translates into the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: <graph-reach-1-main> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'where the loop through the neighbors of `src` is:'
  prefs: []
  type: TYPE_NORMAL
- en: <graph-reach-1-loop> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <graph-reach-tests> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, we don‚Äôt find out about how these tests fare, because some of
    them don‚Äôt complete at all. That‚Äôs because we have an infinite loop, due to the
    cyclic nature of graphs!
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the above examples leads to a cycle? Why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 17.2.1.2¬†Cleaning up the Loop[üîó](#(part._.Cleaning_up_the_.Loop) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Before we continue, let‚Äôs try to improve the expression of the loop. While the
    nested function above is a perfectly reasonable definition, we can use Pyret‚Äôs
    `for` to improve its readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The essence of the above loop is to iterate over a list of boolean values;
    if one of them is true, the entire loop evaluates to true; if they are all false,
    then we haven‚Äôt found a path to the destination node, so the loop evaluates to
    false. Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can replace the loop definition and use with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 17.2.1.3¬†Traversal with Memory[üîó](#(part._.Traversal_with_.Memory) "Link to
    here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Because we have cyclic data, we have to remember what nodes we‚Äôve already visited
    and avoid traversing them again. Then, every time we begin traversing a new node,
    we add it to the set of nodes we‚Äôve already started to visit so that. If we return
    to that node, because we can assume the graph has not changed in the meanwhile,
    we know that additional traversals from that node won‚Äôt make any difference to
    the outcome.This property is known as [‚òõ idempotence](glossary.html#%28elem._glossary-idempotence%29).
  prefs: []
  type: TYPE_NORMAL
- en: 'We therefore define a second attempt at reachability that take an extra argument:
    the set of nodes we have begun visiting (where the set is represented as a graph).
    The key difference from [<graph-reach-1-main>](#%28elem._graph-reach-1-main%29)
    is, before we begin to traverse edges, we should check whether we‚Äôve begun processing
    the node or not. This results in the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: <graph-reach-2> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In particular, note the extra new conditional: if the reachability check has
    already visited this node before, there is no point traversing further from here,
    so it returns `false`. (There may still be other parts of the graph to explore,
    which other recursive calls will do.)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does it matter if the first two conditions were swapped, i.e., the beginning
    of `reach-2` began with
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '? Explain concretely with examples.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We repeatedly talk about remembering the nodes that we have begun to visit,
    not the ones we‚Äôve finished visiting. Does this distinction matter? How?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 17.2.1.4¬†A Better Interface[üîó](#(part._.A_.Better_.Interface) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As the process of testing `reach-2` shows, we may have a better implementation,
    but we‚Äôve changed the function‚Äôs interface; now it has a needless extra argument,
    which is not only a nuisance but might also result in errors if we accidentally
    misuse it. Therefore, we should clean up our definition by moving the core code
    to an internal function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We have now restored the original interface while correctly implementing reachability.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does this really gives us a correct implementation? In particular, does this
    address the problem that the `size` function above addressed? Create a test case
    that demonstrates the problem, and then fix it.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 17.2.1.1¬†Simple Recursion[üîó](#(part._.Simple_.Recursion) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'At its simplest, reachability is easy. We want to know whether there exists
    a pathA path is a sequence of zero or more linked edges. between a pair of nodes,
    a source and a destination. (A more sophisticated version of reachability might
    compute the actual path, but we‚Äôll ignore this for now.) There are two possibilities:
    the source and destintion nodes are the same, or they‚Äôre not.'
  prefs: []
  type: TYPE_NORMAL
- en: If they are the same, then clearly reachability is trivially satisfied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If they are not, we have to iterate through the neighbors of the source node
    and ask whether the destination is reachable from each of those neighbors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This translates into the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: <graph-reach-1-main> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'where the loop through the neighbors of `src` is:'
  prefs: []
  type: TYPE_NORMAL
- en: <graph-reach-1-loop> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <graph-reach-tests> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, we don‚Äôt find out about how these tests fare, because some of
    them don‚Äôt complete at all. That‚Äôs because we have an infinite loop, due to the
    cyclic nature of graphs!
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the above examples leads to a cycle? Why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 17.2.1.2¬†Cleaning up the Loop[üîó](#(part._.Cleaning_up_the_.Loop) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Before we continue, let‚Äôs try to improve the expression of the loop. While the
    nested function above is a perfectly reasonable definition, we can use Pyret‚Äôs
    `for` to improve its readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The essence of the above loop is to iterate over a list of boolean values;
    if one of them is true, the entire loop evaluates to true; if they are all false,
    then we haven‚Äôt found a path to the destination node, so the loop evaluates to
    false. Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can replace the loop definition and use with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 17.2.1.3¬†Traversal with Memory[üîó](#(part._.Traversal_with_.Memory) "Link to
    here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Because we have cyclic data, we have to remember what nodes we‚Äôve already visited
    and avoid traversing them again. Then, every time we begin traversing a new node,
    we add it to the set of nodes we‚Äôve already started to visit so that. If we return
    to that node, because we can assume the graph has not changed in the meanwhile,
    we know that additional traversals from that node won‚Äôt make any difference to
    the outcome.This property is known as [‚òõ idempotence](glossary.html#%28elem._glossary-idempotence%29).
  prefs: []
  type: TYPE_NORMAL
- en: 'We therefore define a second attempt at reachability that take an extra argument:
    the set of nodes we have begun visiting (where the set is represented as a graph).
    The key difference from [<graph-reach-1-main>](#%28elem._graph-reach-1-main%29)
    is, before we begin to traverse edges, we should check whether we‚Äôve begun processing
    the node or not. This results in the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: <graph-reach-2> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In particular, note the extra new conditional: if the reachability check has
    already visited this node before, there is no point traversing further from here,
    so it returns `false`. (There may still be other parts of the graph to explore,
    which other recursive calls will do.)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does it matter if the first two conditions were swapped, i.e., the beginning
    of `reach-2` began with
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '? Explain concretely with examples.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We repeatedly talk about remembering the nodes that we have begun to visit,
    not the ones we‚Äôve finished visiting. Does this distinction matter? How?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 17.2.1.4¬†A Better Interface[üîó](#(part._.A_.Better_.Interface) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As the process of testing `reach-2` shows, we may have a better implementation,
    but we‚Äôve changed the function‚Äôs interface; now it has a needless extra argument,
    which is not only a nuisance but might also result in errors if we accidentally
    misuse it. Therefore, we should clean up our definition by moving the core code
    to an internal function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We have now restored the original interface while correctly implementing reachability.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does this really gives us a correct implementation? In particular, does this
    address the problem that the `size` function above addressed? Create a test case
    that demonstrates the problem, and then fix it.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 17.2.2¬†Depth- and Breadth-First Traversals[üîó](#(part._dfs-bfs) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is conventional for computer science texts to call these depth- and breadth-first
    search. However, searching is just a specific purpose; traversal is a general
    task that can be used for many purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reachability algorithm we have seen above has a special property. At every
    node it visits, there is usually a set of adjacent nodes at which it can continue
    the traversal. It has at least two choices: it can either visit each immediate
    neighbor first, then visit all of the neighbors‚Äô neighbors; or it can choose a
    neighbor, recur, and visit the next immediate neighbor only after that visit is
    done. The former is known as breadth-first traversal, while the latter is depth-first
    traversal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm we have designed uses a depth-first strategy: inside [<graph-reach-1-loop>](#%28elem._graph-reach-1-loop%29),
    we recur on the first element of the list of neighbors before we visit the second
    neighbor, and so on. The alternative would be to have a data structure into which
    we insert all the neighbors, then pull out an element at a time such that we first
    visit all the neighbors before their neighbors, and so on. This naturally corresponds
    to a queue [[An Example: Queues from Lists](amortized-analysis.html#%28part._queue-data-structure%29)].'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using a queue, implement breadth-first traversal.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If we correctly check to ensure we don‚Äôt re-visit nodes, then both breadth-
    and depth-first traversal will properly visit the entire reachable graph without
    repetition (and hence not get into an infinite loop). Each one traverses from
    a node only once, from which it considers every single edge. Thus, if a graph
    has \(N\) nodes and \(E\) edges, then a lower-bound on the complexity of traversal
    is \(O([N, E \rightarrow N + E])\). We must also consider the cost of checking
    whether we have already visited a node before (which is a set membership problem,
    which we address elsewhere: [Several Variations on Sets](part_sets.html)). Finally,
    we have to consider the cost of maintaining the data structure that keeps track
    of our traversal. In the case of depth-first traversal, recursion‚Äî<wbr>which uses
    the machine‚Äôs stack‚Äî<wbr>does it automatically at constant overhead. In the case
    of breadth-first traversal, the program must manage the queue, which can add more
    than constant overhead.In practice, too, the stack will usually perform much better
    than a queue, because it is supported by machine hardware.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This would suggest that depth-first traversal is always better than breadth-first
    traversal. However, breadth-first traversal has one very important and valuable
    property. Starting from a node \(N\), when it visits a node \(P\), count the number
    of edges taken to get to \(P\). Breadth-first traversal guarantees that there
    cannot have been a shorter path to \(P\): that is, it finds a shortest path to
    \(P\).'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why ‚Äúa‚Äù rather than ‚Äúthe‚Äù shortest path?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Prove that breadth-first traversal finds a shortest path.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
