- en: 17.2Â Basic Graph TraversalsğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.2Â åŸºæœ¬å›¾éå†ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/basic-graph-trav.html](https://dcic-world.org/2025-08-27/basic-graph-trav.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/basic-graph-trav.html](https://dcic-world.org/2025-08-27/basic-graph-trav.html)
- en: '| Â Â Â Â [17.2.1Â Reachability](#%28part._.Reachability%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [17.2.1Â å¯è¾¾æ€§](#%28part._.Reachability%29) |'
- en: '| Â Â Â Â Â Â [17.2.1.1Â Simple Recursion](#%28part._.Simple_.Recursion%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [17.2.1.1Â ç®€å•é€’å½’](#%28part._.Simple_.Recursion%29) |'
- en: '| Â Â Â Â Â Â [17.2.1.2Â Cleaning up the Loop](#%28part._.Cleaning_up_the_.Loop%29)
    |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [17.2.1.2Â æ¸…ç†å¾ªç¯](#%28part._.Cleaning_up_the_.Loop%29) |'
- en: '| Â Â Â Â Â Â [17.2.1.3Â Traversal with Memory](#%28part._.Traversal_with_.Memory%29)
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [17.2.1.3Â å¸¦è®°å¿†çš„éå†](#%28part._.Traversal_with_.Memory%29) |'
- en: '| Â Â Â Â Â Â [17.2.1.4Â A Better Interface](#%28part._.A_.Better_.Interface%29) |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [17.2.1.4Â æ›´å¥½çš„æ¥å£](#%28part._.A_.Better_.Interface%29) |'
- en: '| Â Â Â Â [17.2.2Â Depth- and Breadth-First Traversals](#%28part._dfs-bfs%29) |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [17.2.2Â æ·±åº¦ä¼˜å…ˆéå†å’Œå¹¿åº¦ä¼˜å…ˆéå†](#%28part._dfs-bfs%29) |'
- en: As with all the data we have seen so far, to process a datum we have to traverse
    itâ€”<wbr>i.e., visit the constituent data. With graphs, that can be quite interesting!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: å°±åƒæˆ‘ä»¬è¿„ä»Šä¸ºæ­¢çœ‹åˆ°çš„æ‰€æœ‰æ•°æ®ä¸€æ ·ï¼Œä¸ºäº†å¤„ç†ä¸€ä¸ªæ•°æ®é¡¹ï¼Œæˆ‘ä»¬å¿…é¡»éå†å®ƒâ€”â€”å³ï¼Œè®¿é—®æ„æˆæ•°æ®çš„æ•°æ®ã€‚å¯¹äºå›¾æ¥è¯´ï¼Œè¿™å¯ä»¥éå¸¸æœ‰è¶£ï¼
- en: 17.2.1Â Reachability[ğŸ”—](#(part._.Reachability) "Link to here")
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.2.1Â å¯è¾¾æ€§[ğŸ”—](#(part._.Reachability) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Many uses of graphs need to address reachability: whether we can, using edges
    in the graph, get from one node to another. For instance, a social network might
    suggest as contacts all those who are reachable from existing contacts. On the
    Internet, traffic engineers care about whether packets can get from one machine
    to another. On the Web, we care about whether all public pages on a site are reachable
    from the home page. We will study how to compute reachability using our travel
    graph as a running example.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾çš„è®¸å¤šç”¨é€”éƒ½éœ€è¦è§£å†³å¯è¾¾æ€§é—®é¢˜ï¼šæˆ‘ä»¬æ˜¯å¦å¯ä»¥ä½¿ç”¨å›¾ä¸­çš„è¾¹ä»èŠ‚ç‚¹ A åˆ°èŠ‚ç‚¹ Bã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªç¤¾äº¤ç½‘ç»œå¯èƒ½ä¼šå»ºè®®æ‰€æœ‰å¯ä»¥ä»ç°æœ‰è”ç³»äººåˆ°è¾¾çš„äººä½œä¸ºè”ç³»äººã€‚åœ¨äº’è”ç½‘ä¸Šï¼Œäº¤é€šå·¥ç¨‹å¸ˆå…³å¿ƒæ•°æ®åŒ…æ˜¯å¦å¯ä»¥ä»ä¸€å°æœºå™¨åˆ°è¾¾å¦ä¸€å°æœºå™¨ã€‚åœ¨ç½‘ç»œä¸Šï¼Œæˆ‘ä»¬å…³å¿ƒç½‘ç«™ä¸Šçš„æ‰€æœ‰å…¬å…±é¡µé¢æ˜¯å¦å¯ä»¥ä»ä¸»é¡µåˆ°è¾¾ã€‚æˆ‘ä»¬å°†ä»¥æˆ‘ä»¬çš„æ—…è¡Œå›¾ä½œä¸ºè¿è¡Œç¤ºä¾‹æ¥ç ”ç©¶å¦‚ä½•è®¡ç®—å¯è¾¾æ€§ã€‚
- en: 17.2.1.1Â Simple Recursion[ğŸ”—](#(part._.Simple_.Recursion) "Link to here")
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 17.2.1.1Â ç®€å•é€’å½’[ğŸ”—](#%28part._.Simple_.Recursion) "é“¾æ¥åˆ°è¿™é‡Œ"
- en: 'At its simplest, reachability is easy. We want to know whether there exists
    a pathA path is a sequence of zero or more linked edges. between a pair of nodes,
    a source and a destination. (A more sophisticated version of reachability might
    compute the actual path, but weâ€™ll ignore this for now.) There are two possibilities:
    the source and destintion nodes are the same, or theyâ€™re not.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ€ç®€å•çš„æƒ…å†µä¸‹ï¼Œå¯è¾¾æ€§æ˜¯å®¹æ˜“çš„ã€‚æˆ‘ä»¬æƒ³çŸ¥é“æ˜¯å¦å­˜åœ¨ä¸€æ¡è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„æ˜¯ä¸€ä¸ªæˆ–å¤šä¸ªé“¾æ¥è¾¹çš„åºåˆ—ã€‚ä»ä¸€ä¸ªèŠ‚ç‚¹å¯¹ï¼Œå³æºèŠ‚ç‚¹å’Œç›®æ ‡èŠ‚ç‚¹ä¹‹é—´ã€‚ï¼ˆå¯è¾¾æ€§çš„æ›´å¤æ‚ç‰ˆæœ¬å¯èƒ½ä¼šè®¡ç®—å®é™…çš„è·¯å¾„ï¼Œä½†æˆ‘ä»¬ç°åœ¨å°†å¿½ç•¥è¿™ä¸€ç‚¹ã€‚ï¼‰æœ‰ä¸¤ç§å¯èƒ½æ€§ï¼šæºèŠ‚ç‚¹å’Œç›®æ ‡èŠ‚ç‚¹ç›¸åŒï¼Œæˆ–è€…å®ƒä»¬ä¸åŒã€‚
- en: If they are the same, then clearly reachability is trivially satisfied.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœå®ƒä»¬ç›¸åŒï¼Œé‚£ä¹ˆæ˜¾ç„¶å¯è¾¾æ€§æ˜¯æ˜¾è€Œæ˜“è§çš„ã€‚
- en: If they are not, we have to iterate through the neighbors of the source node
    and ask whether the destination is reachable from each of those neighbors.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœå®ƒä»¬ä¸æ˜¯ï¼Œæˆ‘ä»¬å¿…é¡»éå†æºèŠ‚ç‚¹çš„é‚»å±…å¹¶è¯¢é—®ç›®çš„åœ°æ˜¯å¦å¯ä»¥ä»è¿™äº›é‚»å±…ä¸­çš„æ¯ä¸€ä¸ªåˆ°è¾¾ã€‚
- en: 'This translates into the following function:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è½¬åŒ–ä¸ºä»¥ä¸‹å‡½æ•°ï¼š
- en: <graph-reach-1-main> ::=
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <graph-reach-1-main> ::=
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'where the loop through the neighbors of `src` is:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­ï¼Œé€šè¿‡ `src` çš„é‚»å±…çš„å¾ªç¯æ˜¯ï¼š
- en: <graph-reach-1-loop> ::=
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <graph-reach-1-loop> ::=
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can test this as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥è¿™æ ·æµ‹è¯•ï¼š
- en: <graph-reach-tests> ::=
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <graph-reach-tests> ::=
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Unfortunately, we donâ€™t find out about how these tests fare, because some of
    them donâ€™t complete at all. Thatâ€™s because we have an infinite loop, due to the
    cyclic nature of graphs!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼Œæˆ‘ä»¬æ— æ³•å¾—çŸ¥è¿™äº›æµ‹è¯•çš„ç»“æœï¼Œå› ä¸ºå…¶ä¸­ä¸€äº›æ ¹æœ¬å°±æ²¡æœ‰å®Œæˆã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬æœ‰ä¸€ä¸ªæ— é™å¾ªç¯ï¼Œè¿™æ˜¯ç”±äºå›¾çš„å¾ªç¯æ€§è´¨é€ æˆçš„ï¼
- en: Exercise
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the above examples leads to a cycle? Why?
  id: totrans-27
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å“ªä¸ªä¸Šé¢çš„ä¾‹å­ä¼šå¯¼è‡´å¾ªç¯ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ
- en: 17.2.1.2Â Cleaning up the Loop[ğŸ”—](#(part._.Cleaning_up_the_.Loop) "Link to here")
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 17.2.1.2Â æ¸…ç†å¾ªç¯[ğŸ”—](#(part._.Cleaning_up_the_.Loop) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Before we continue, letâ€™s try to improve the expression of the loop. While the
    nested function above is a perfectly reasonable definition, we can use Pyretâ€™s
    `for` to improve its readability.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬ç»§ç»­ä¹‹å‰ï¼Œè®©æˆ‘ä»¬å°è¯•æ”¹è¿›å¾ªç¯çš„è¡¨è¾¾å¼ã€‚è™½ç„¶ä¸Šé¢çš„åµŒå¥—å‡½æ•°æ˜¯ä¸€ä¸ªå®Œå…¨åˆç†çš„å®šä¹‰ï¼Œä½†æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ Pyret çš„ `for` æ¥æé«˜å…¶å¯è¯»æ€§ã€‚
- en: 'The essence of the above loop is to iterate over a list of boolean values;
    if one of them is true, the entire loop evaluates to true; if they are all false,
    then we havenâ€™t found a path to the destination node, so the loop evaluates to
    false. Thus:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šé¢çš„å¾ªç¯çš„æœ¬è´¨æ˜¯éå†ä¸€ä¸ªå¸ƒå°”å€¼çš„åˆ—è¡¨ï¼›å¦‚æœå…¶ä¸­ä¹‹ä¸€ä¸ºçœŸï¼Œåˆ™æ•´ä¸ªå¾ªç¯è¯„ä¼°ä¸ºçœŸï¼›å¦‚æœå®ƒä»¬éƒ½æ˜¯å‡çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ²¡æœ‰æ‰¾åˆ°åˆ°è¾¾ç›®æ ‡èŠ‚ç‚¹çš„è·¯å¾„ï¼Œæ‰€ä»¥å¾ªç¯è¯„ä¼°ä¸ºå‡ã€‚å› æ­¤ï¼š
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With this, we can replace the loop definition and use with:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ç§æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥æ›¿æ¢å¾ªç¯å®šä¹‰å’Œä½¿ç”¨ï¼š
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 17.2.1.3Â Traversal with Memory[ğŸ”—](#(part._.Traversal_with_.Memory) "Link to
    here")
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 17.2.1.3 å¸¦è®°å¿†çš„éå†[ğŸ”—](#(part._.Traversal_with_.Memory) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Because we have cyclic data, we have to remember what nodes weâ€™ve already visited
    and avoid traversing them again. Then, every time we begin traversing a new node,
    we add it to the set of nodes weâ€™ve already started to visit so that. If we return
    to that node, because we can assume the graph has not changed in the meanwhile,
    we know that additional traversals from that node wonâ€™t make any difference to
    the outcome.This property is known as [â˜› idempotence](glossary.html#%28elem._glossary-idempotence%29).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸ºæˆ‘ä»¬æœ‰å¾ªç¯æ•°æ®ï¼Œæˆ‘ä»¬å¿…é¡»è®°ä½æˆ‘ä»¬å·²ç»è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œä»¥é¿å…å†æ¬¡éå†å®ƒä»¬ã€‚ç„¶åï¼Œæ¯æ¬¡æˆ‘ä»¬å¼€å§‹éå†ä¸€ä¸ªæ–°çš„èŠ‚ç‚¹ï¼Œæˆ‘ä»¬å°±å°†å®ƒæ·»åŠ åˆ°æˆ‘ä»¬å·²ç»å¼€å§‹è®¿é—®çš„èŠ‚ç‚¹é›†åˆä¸­ï¼Œä»¥ä¾¿ã€‚å¦‚æœæˆ‘ä»¬è¿”å›åˆ°è¯¥èŠ‚ç‚¹ï¼Œå› ä¸ºæˆ‘ä»¬å‡è®¾å›¾åœ¨æ­¤æœŸé—´æ²¡æœ‰æ”¹å˜ï¼Œæˆ‘ä»¬çŸ¥é“ä»è¿™ä¸ªèŠ‚ç‚¹è¿›è¡Œçš„é¢å¤–éå†ä¸ä¼šå¯¹ç»“æœäº§ç”Ÿä»»ä½•å½±å“ã€‚è¿™ä¸ªç‰¹æ€§è¢«ç§°ä¸º[â˜›
    å¹‚ç­‰æ€§](glossary.html#%28elem._glossary-idempotence%29)ã€‚
- en: 'We therefore define a second attempt at reachability that take an extra argument:
    the set of nodes we have begun visiting (where the set is represented as a graph).
    The key difference from [<graph-reach-1-main>](#%28elem._graph-reach-1-main%29)
    is, before we begin to traverse edges, we should check whether weâ€™ve begun processing
    the node or not. This results in the following definition:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬å®šä¹‰äº†ç¬¬äºŒæ¬¡å°è¯•å¯è¾¾æ€§ï¼Œå®ƒæ¥å—ä¸€ä¸ªé¢å¤–çš„å‚æ•°ï¼šæˆ‘ä»¬å·²ç»å¼€å§‹è®¿é—®çš„èŠ‚ç‚¹é›†åˆï¼ˆé›†åˆç”±å›¾è¡¨ç¤ºï¼‰ã€‚ä¸[<graph-reach-1-main>](#%28elem._graph-reach-1-main%29)çš„å…³é”®åŒºåˆ«åœ¨äºï¼Œåœ¨æˆ‘ä»¬å¼€å§‹éå†è¾¹ä¹‹å‰ï¼Œæˆ‘ä»¬åº”è¯¥æ£€æŸ¥æˆ‘ä»¬æ˜¯å¦å·²ç»å¼€å§‹å¤„ç†è¯¥èŠ‚ç‚¹ã€‚è¿™å¯¼è‡´äº†ä»¥ä¸‹å®šä¹‰ï¼š
- en: <graph-reach-2> ::=
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <graph-reach-2> ::=
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In particular, note the extra new conditional: if the reachability check has
    already visited this node before, there is no point traversing further from here,
    so it returns `false`. (There may still be other parts of the graph to explore,
    which other recursive calls will do.)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ç‰¹åˆ«æ˜¯ï¼Œæ³¨æ„é¢å¤–çš„æ–°çš„æ¡ä»¶ï¼šå¦‚æœå¯è¾¾æ€§æ£€æŸ¥ä¹‹å‰å·²ç»è®¿é—®è¿‡è¿™ä¸ªèŠ‚ç‚¹ï¼Œå°±æ²¡æœ‰å¿…è¦ä»è¿™é‡Œè¿›ä¸€æ­¥éå†ï¼Œæ‰€ä»¥å®ƒè¿”å›`false`ã€‚ï¼ˆå¯èƒ½è¿˜æœ‰å…¶ä»–å›¾çš„éƒ¨åˆ†éœ€è¦æ¢ç´¢ï¼Œå…¶ä»–é€’å½’è°ƒç”¨å°†å®Œæˆè¿™äº›å·¥ä½œã€‚ï¼‰
- en: Exercise
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does it matter if the first two conditions were swapped, i.e., the beginning
    of `reach-2` began with
  id: totrans-42
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœå‰ä¸¤ä¸ªæ¡ä»¶è¢«äº¤æ¢äº†ï¼Œå³`reach-2`çš„å¼€å§‹æ˜¯ä»¥
- en: ''
  id: totrans-43
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '? Explain concretely with examples.'
  id: totrans-46
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '? è¯·å…·ä½“ä¸¾ä¾‹è¯´æ˜ã€‚'
- en: Exercise
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We repeatedly talk about remembering the nodes that we have begun to visit,
    not the ones weâ€™ve finished visiting. Does this distinction matter? How?
  id: totrans-49
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åå¤è°ˆè®ºè®°ä½æˆ‘ä»¬å·²ç»å¼€å§‹è®¿é—®çš„èŠ‚ç‚¹ï¼Œè€Œä¸æ˜¯æˆ‘ä»¬å·²ç»å®Œæˆè®¿é—®çš„èŠ‚ç‚¹ã€‚è¿™ç§åŒºåˆ«é‡è¦å—ï¼Ÿä¸ºä»€ä¹ˆé‡è¦ï¼Ÿ
- en: 17.2.1.4Â A Better Interface[ğŸ”—](#(part._.A_.Better_.Interface) "Link to here")
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 17.2.1.4 æ›´å¥½çš„æ¥å£[ğŸ”—](#(part._.A_.Better_.Interface) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'As the process of testing `reach-2` shows, we may have a better implementation,
    but weâ€™ve changed the functionâ€™s interface; now it has a needless extra argument,
    which is not only a nuisance but might also result in errors if we accidentally
    misuse it. Therefore, we should clean up our definition by moving the core code
    to an internal function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æµ‹è¯•`reach-2`çš„è¿‡ç¨‹æ‰€æ˜¾ç¤ºçš„ï¼Œæˆ‘ä»¬å¯èƒ½æœ‰ä¸€ä¸ªæ›´å¥½çš„å®ç°ï¼Œä½†æˆ‘ä»¬å·²ç»æ”¹å˜äº†å‡½æ•°çš„æ¥å£ï¼›ç°åœ¨å®ƒæœ‰ä¸€ä¸ªä¸å¿…è¦çš„é¢å¤–å‚æ•°ï¼Œè¿™ä¸ä»…æ˜¯ä¸€ä¸ªéº»çƒ¦ï¼Œå¦‚æœæˆ‘ä»¬ä¸å°å¿ƒè¯¯ç”¨å®ƒï¼Œè¿˜å¯èƒ½å¯¼è‡´é”™è¯¯ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åº”è¯¥é€šè¿‡å°†æ ¸å¿ƒä»£ç ç§»åŠ¨åˆ°å†…éƒ¨å‡½æ•°æ¥æ¸…ç†æˆ‘ä»¬çš„å®šä¹‰ï¼š
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have now restored the original interface while correctly implementing reachability.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨å·²ç»æ¢å¤äº†åŸå§‹æ¥å£ï¼Œå¹¶æ­£ç¡®å®ç°äº†å¯è¾¾æ€§ã€‚
- en: Exercise
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does this really gives us a correct implementation? In particular, does this
    address the problem that the `size` function above addressed? Create a test case
    that demonstrates the problem, and then fix it.
  id: totrans-56
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™çœŸçš„ç»™æˆ‘ä»¬æä¾›äº†ä¸€ä¸ªæ­£ç¡®çš„å®ç°å—ï¼Ÿç‰¹åˆ«æ˜¯ï¼Œè¿™è§£å†³äº†ä¸Šé¢`size`å‡½æ•°è§£å†³çš„é—®é¢˜å—ï¼Ÿåˆ›å»ºä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹æ¥å±•ç¤ºè¿™ä¸ªé—®é¢˜ï¼Œç„¶åä¿®å¤å®ƒã€‚
- en: 17.2.2Â Depth- and Breadth-First Traversals[ğŸ”—](#(part._dfs-bfs) "Link to here")
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.2.2 æ·±åº¦ä¼˜å…ˆå’Œå¹¿åº¦ä¼˜å…ˆéå†[ğŸ”—](#(part._dfs-bfs) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: It is conventional for computer science texts to call these depth- and breadth-first
    search. However, searching is just a specific purpose; traversal is a general
    task that can be used for many purposes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: è®¡ç®—æœºç§‘å­¦æ–‡æœ¬ä¸­é€šå¸¸å°†è¿™äº›ç§°ä¸ºæ·±åº¦ä¼˜å…ˆå’Œå¹¿åº¦ä¼˜å…ˆæœç´¢ã€‚ç„¶è€Œï¼Œæœç´¢åªæ˜¯ä¸€ä¸ªç‰¹å®šç›®çš„ï¼›éå†æ˜¯ä¸€ä¸ªé€šç”¨ä»»åŠ¡ï¼Œå¯ä»¥ç”¨äºè®¸å¤šç›®çš„ã€‚
- en: 'The reachability algorithm we have seen above has a special property. At every
    node it visits, there is usually a set of adjacent nodes at which it can continue
    the traversal. It has at least two choices: it can either visit each immediate
    neighbor first, then visit all of the neighborsâ€™ neighbors; or it can choose a
    neighbor, recur, and visit the next immediate neighbor only after that visit is
    done. The former is known as breadth-first traversal, while the latter is depth-first
    traversal.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¸Šé¢çœ‹åˆ°çš„å¯è¾¾æ€§ç®—æ³•æœ‰ä¸€ä¸ªç‰¹æ®Šå±æ€§ã€‚åœ¨å®ƒè®¿é—®çš„æ¯ä¸ªèŠ‚ç‚¹ä¸Šï¼Œé€šå¸¸æœ‰ä¸€ä¸ªç›¸é‚»èŠ‚ç‚¹çš„é›†åˆï¼Œå®ƒå¯ä»¥åœ¨é‚£é‡Œç»§ç»­éå†ã€‚å®ƒè‡³å°‘æœ‰ä¸¤ä¸ªé€‰æ‹©ï¼šå®ƒè¦ä¹ˆé¦–å…ˆè®¿é—®æ¯ä¸ªç›´æ¥é‚»å±…ï¼Œç„¶åè®¿é—®æ‰€æœ‰é‚»å±…çš„é‚»å±…ï¼›è¦ä¹ˆé€‰æ‹©ä¸€ä¸ªé‚»å±…ï¼Œé€’å½’ï¼Œç„¶ååœ¨è®¿é—®å®Œæˆä¹‹ååªè®¿é—®ä¸‹ä¸€ä¸ªç›´æ¥é‚»å±…ã€‚å‰è€…è¢«ç§°ä¸ºå¹¿åº¦ä¼˜å…ˆéå†ï¼Œè€Œåè€…æ˜¯æ·±åº¦ä¼˜å…ˆéå†ã€‚
- en: 'The algorithm we have designed uses a depth-first strategy: inside [<graph-reach-1-loop>](#%28elem._graph-reach-1-loop%29),
    we recur on the first element of the list of neighbors before we visit the second
    neighbor, and so on. The alternative would be to have a data structure into which
    we insert all the neighbors, then pull out an element at a time such that we first
    visit all the neighbors before their neighbors, and so on. This naturally corresponds
    to a queue [[An Example: Queues from Lists](amortized-analysis.html#%28part._queue-data-structure%29)].'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è®¾è®¡çš„ç®—æ³•ä½¿ç”¨æ·±åº¦ä¼˜å…ˆç­–ç•¥ï¼šåœ¨ [<graph-reach-1-loop>](#%28elem._graph-reach-1-loop%29) å†…ï¼Œæˆ‘ä»¬åœ¨è®¿é—®ç¬¬äºŒä¸ªé‚»å±…ä¹‹å‰ï¼Œå…ˆé€’å½’è®¿é—®é‚»å±…åˆ—è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œä¾æ­¤ç±»æ¨ã€‚å¦ä¸€ç§é€‰æ‹©æ˜¯æœ‰ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œæˆ‘ä»¬å°†æ‰€æœ‰é‚»å±…æ’å…¥å…¶ä¸­ï¼Œç„¶åä¸€æ¬¡å–å‡ºä¸€ä¸ªå…ƒç´ ï¼Œè¿™æ ·æˆ‘ä»¬é¦–å…ˆè®¿é—®æ‰€æœ‰é‚»å±…çš„é‚»å±…ï¼Œä¾æ­¤ç±»æ¨ã€‚è¿™è‡ªç„¶å¯¹åº”äºä¸€ä¸ªé˜Ÿåˆ—
    [[ä¸€ä¸ªä¾‹å­ï¼šä»åˆ—è¡¨ä¸­å¾—åˆ°çš„é˜Ÿåˆ—](amortized-analysis.html#%28part._queue-data-structure%29)]ã€‚
- en: Exercise
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using a queue, implement breadth-first traversal.
  id: totrans-63
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨é˜Ÿåˆ—å®ç°å¹¿åº¦ä¼˜å…ˆéå†ã€‚
- en: 'If we correctly check to ensure we donâ€™t re-visit nodes, then both breadth-
    and depth-first traversal will properly visit the entire reachable graph without
    repetition (and hence not get into an infinite loop). Each one traverses from
    a node only once, from which it considers every single edge. Thus, if a graph
    has \(N\) nodes and \(E\) edges, then a lower-bound on the complexity of traversal
    is \(O([N, E \rightarrow N + E])\). We must also consider the cost of checking
    whether we have already visited a node before (which is a set membership problem,
    which we address elsewhere: [Several Variations on Sets](part_sets.html)). Finally,
    we have to consider the cost of maintaining the data structure that keeps track
    of our traversal. In the case of depth-first traversal, recursionâ€”<wbr>which uses
    the machineâ€™s stackâ€”<wbr>does it automatically at constant overhead. In the case
    of breadth-first traversal, the program must manage the queue, which can add more
    than constant overhead.In practice, too, the stack will usually perform much better
    than a queue, because it is supported by machine hardware.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æ­£ç¡®æ£€æŸ¥ä»¥ç¡®ä¿æˆ‘ä»¬ä¸é‡å¤è®¿é—®èŠ‚ç‚¹ï¼Œé‚£ä¹ˆå¹¿åº¦å’Œæ·±åº¦ä¼˜å…ˆéå†éƒ½å°†æ­£ç¡®åœ°éå†æ•´ä¸ªå¯è¾¾å›¾ï¼Œè€Œä¸é‡å¤ï¼ˆå› æ­¤ä¸ä¼šè¿›å…¥æ— é™å¾ªç¯ï¼‰ã€‚æ¯ä¸ªéå†åªä»ä¸€ä¸ªèŠ‚ç‚¹å¼€å§‹ï¼Œä»è¯¥èŠ‚ç‚¹è€ƒè™‘æ¯ä¸€æ¡è¾¹ã€‚å› æ­¤ï¼Œå¦‚æœä¸€ä¸ªå›¾æœ‰
    \(N\) ä¸ªèŠ‚ç‚¹å’Œ \(E\) æ¡è¾¹ï¼Œé‚£ä¹ˆéå†çš„å¤æ‚åº¦ä¸‹é™æ˜¯ \(O([N, E \rightarrow N + E])\)ã€‚æˆ‘ä»¬è¿˜å¿…é¡»è€ƒè™‘æ£€æŸ¥æˆ‘ä»¬æ˜¯å¦å·²ç»è®¿é—®è¿‡èŠ‚ç‚¹ä¹‹å‰çš„èŠ±è´¹ï¼ˆè¿™æ˜¯ä¸€ä¸ªé›†åˆæˆå‘˜é—®é¢˜ï¼Œæˆ‘ä»¬å°†åœ¨å…¶ä»–åœ°æ–¹è§£å†³ï¼š[é›†åˆçš„å‡ ç§å˜ä½“](part_sets.html)ï¼‰ã€‚æœ€åï¼Œæˆ‘ä»¬å¿…é¡»è€ƒè™‘ç»´æŠ¤è·Ÿè¸ªæˆ‘ä»¬éå†çš„æ•°æ®ç»“æ„çš„æˆæœ¬ã€‚åœ¨æ·±åº¦ä¼˜å…ˆéå†çš„æƒ…å†µä¸‹ï¼Œé€’å½’â€”â€”<wbr>å®ƒä½¿ç”¨æœºå™¨çš„å †æ ˆâ€”â€”<wbr>è‡ªåŠ¨ä»¥æ’å®šå¼€é”€å®Œæˆã€‚åœ¨å¹¿åº¦ä¼˜å…ˆéå†çš„æƒ…å†µä¸‹ï¼Œç¨‹åºå¿…é¡»ç®¡ç†é˜Ÿåˆ—ï¼Œè¿™å¯èƒ½ä¼šå¢åŠ è¶…è¿‡æ’å®šå¼€é”€ã€‚åœ¨å®è·µä¸­ï¼Œå †æ ˆé€šå¸¸ä¼šæ¯”é˜Ÿåˆ—è¡¨ç°å¾—æ›´å¥½ï¼Œå› ä¸ºå®ƒæ˜¯å—æœºå™¨ç¡¬ä»¶æ”¯æŒçš„ã€‚
- en: 'This would suggest that depth-first traversal is always better than breadth-first
    traversal. However, breadth-first traversal has one very important and valuable
    property. Starting from a node \(N\), when it visits a node \(P\), count the number
    of edges taken to get to \(P\). Breadth-first traversal guarantees that there
    cannot have been a shorter path to \(P\): that is, it finds a shortest path to
    \(P\).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯èƒ½ä¼šè¡¨æ˜æ·±åº¦ä¼˜å…ˆéå†æ€»æ˜¯ä¼˜äºå¹¿åº¦ä¼˜å…ˆéå†ã€‚ç„¶è€Œï¼Œå¹¿åº¦ä¼˜å…ˆéå†æœ‰ä¸€ä¸ªéå¸¸é‡è¦ä¸”å®è´µçš„å±æ€§ã€‚ä»ä¸€ä¸ªèŠ‚ç‚¹ \(N\) å¼€å§‹ï¼Œå½“å®ƒè®¿é—®ä¸€ä¸ªèŠ‚ç‚¹ \(P\)
    æ—¶ï¼Œè®¡ç®—åˆ°è¾¾ \(P\) æ‰€ç»è¿‡çš„è¾¹çš„æ•°é‡ã€‚å¹¿åº¦ä¼˜å…ˆéå†ä¿è¯ä¸å¯èƒ½æœ‰æ›´çŸ­çš„è·¯å¾„åˆ°è¾¾ \(P\)ï¼šä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒæ‰¾åˆ°äº†åˆ°è¾¾ \(P\) çš„æœ€çŸ­è·¯å¾„ã€‚
- en: Exercise
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why â€œaâ€ rather than â€œtheâ€ shortest path?
  id: totrans-68
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆæ˜¯â€œaâ€è€Œä¸æ˜¯â€œtheâ€æœ€çŸ­è·¯å¾„ï¼Ÿ
- en: Exercise
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Prove that breadth-first traversal finds a shortest path.
  id: totrans-71
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¯æ˜å¹¿åº¦ä¼˜å…ˆéå†å¯ä»¥æ‰¾åˆ°æœ€çŸ­è·¯å¾„ã€‚
- en: 17.2.1Â Reachability[ğŸ”—](#(part._.Reachability) "Link to here")
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.2.1 å¯è¾¾æ€§[ğŸ”—](#(part._.Reachability) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Many uses of graphs need to address reachability: whether we can, using edges
    in the graph, get from one node to another. For instance, a social network might
    suggest as contacts all those who are reachable from existing contacts. On the
    Internet, traffic engineers care about whether packets can get from one machine
    to another. On the Web, we care about whether all public pages on a site are reachable
    from the home page. We will study how to compute reachability using our travel
    graph as a running example.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: è®¸å¤šä½¿ç”¨å›¾çš„åº”ç”¨éƒ½éœ€è¦å¤„ç†å¯è¾¾æ€§ï¼šæˆ‘ä»¬æ˜¯å¦å¯ä»¥ä½¿ç”¨å›¾ä¸­çš„è¾¹ä»ä¸€ä¸ªèŠ‚ç‚¹åˆ°è¾¾å¦ä¸€ä¸ªèŠ‚ç‚¹ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªç¤¾äº¤ç½‘ç»œå¯èƒ½ä¼šå»ºè®®æ‰€æœ‰å¯ä»¥ä»ç°æœ‰è”ç³»äººåˆ°è¾¾çš„äººä½œä¸ºè”ç³»äººã€‚åœ¨äº’è”ç½‘ä¸Šï¼Œäº¤é€šå·¥ç¨‹å¸ˆå…³å¿ƒæ•°æ®åŒ…æ˜¯å¦å¯ä»¥ä»ä¸€å°æœºå™¨åˆ°è¾¾å¦ä¸€å°æœºå™¨ã€‚åœ¨ç½‘ç»œä¸Šï¼Œæˆ‘ä»¬å…³å¿ƒç½‘ç«™ä¸Šçš„æ‰€æœ‰å…¬å…±é¡µé¢æ˜¯å¦å¯ä»¥ä»ä¸»é¡µåˆ°è¾¾ã€‚æˆ‘ä»¬å°†ä»¥æˆ‘ä»¬çš„æ—…è¡Œå›¾ä½œä¸ºè¿è¡Œç¤ºä¾‹æ¥ç ”ç©¶å¦‚ä½•è®¡ç®—å¯è¾¾æ€§ã€‚
- en: 17.2.1.1Â Simple Recursion[ğŸ”—](#(part._.Simple_.Recursion) "Link to here")
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 17.2.1.1Â ç®€å•é€’å½’[ğŸ”—](#(part._.Simple_.Recursion) "é“¾æ¥è‡³æ­¤")
- en: 'At its simplest, reachability is easy. We want to know whether there exists
    a pathA path is a sequence of zero or more linked edges. between a pair of nodes,
    a source and a destination. (A more sophisticated version of reachability might
    compute the actual path, but weâ€™ll ignore this for now.) There are two possibilities:
    the source and destintion nodes are the same, or theyâ€™re not.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ€ç®€å•çš„æƒ…å†µä¸‹ï¼Œå¯è¾¾æ€§æ˜¯å®¹æ˜“çš„ã€‚æˆ‘ä»¬æƒ³çŸ¥é“æ˜¯å¦å­˜åœ¨ä¸€æ¡è·¯å¾„ï¼Œä¸€æ¡ç”±é›¶ä¸ªæˆ–å¤šä¸ªé“¾æ¥è¾¹ç»„æˆçš„è·¯å¾„ï¼Œä»ä¸€ä¸ªèŠ‚ç‚¹å¯¹ï¼Œä¸€ä¸ªæºèŠ‚ç‚¹å’Œä¸€ä¸ªç›®æ ‡èŠ‚ç‚¹ä¹‹é—´ã€‚ (æ›´å¤æ‚çš„å¯è¾¾æ€§ç‰ˆæœ¬å¯èƒ½ä¼šè®¡ç®—å®é™…çš„è·¯å¾„ï¼Œä½†æˆ‘ä»¬ç°åœ¨å°†å¿½ç•¥è¿™ä¸€ç‚¹ã€‚)æœ‰ä¸¤ç§å¯èƒ½æ€§ï¼šæºèŠ‚ç‚¹å’Œç›®æ ‡èŠ‚ç‚¹ç›¸åŒï¼Œæˆ–è€…å®ƒä»¬ä¸åŒã€‚
- en: If they are the same, then clearly reachability is trivially satisfied.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœå®ƒä»¬ç›¸åŒï¼Œé‚£ä¹ˆæ˜¾ç„¶å¯è¾¾æ€§æ˜¯æ˜¾è€Œæ˜“è§çš„ã€‚
- en: If they are not, we have to iterate through the neighbors of the source node
    and ask whether the destination is reachable from each of those neighbors.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœå®ƒä»¬ä¸åŒï¼Œæˆ‘ä»¬å¿…é¡»éå†æºèŠ‚ç‚¹çš„é‚»å±…å¹¶è¯¢é—®ç›®æ ‡èŠ‚ç‚¹æ˜¯å¦å¯ä»¥ä»è¿™äº›é‚»å±…ä¸­çš„æ¯ä¸€ä¸ªåˆ°è¾¾ã€‚
- en: 'This translates into the following function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è½¬åŒ–ä¸ºä»¥ä¸‹å‡½æ•°ï¼š
- en: <graph-reach-1-main> ::=
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <graph-reach-1-main> ::=
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'where the loop through the neighbors of `src` is:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­ `src` çš„é‚»å±…éå†å¾ªç¯æ˜¯ï¼š
- en: <graph-reach-1-loop> ::=
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <graph-reach-1-loop> ::=
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can test this as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥è¿™æ ·æµ‹è¯•ï¼š
- en: <graph-reach-tests> ::=
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <graph-reach-tests> ::=
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Unfortunately, we donâ€™t find out about how these tests fare, because some of
    them donâ€™t complete at all. Thatâ€™s because we have an infinite loop, due to the
    cyclic nature of graphs!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼Œæˆ‘ä»¬ä¸çŸ¥é“è¿™äº›æµ‹è¯•çš„ç»“æœå¦‚ä½•ï¼Œå› ä¸ºå…¶ä¸­ä¸€äº›æ ¹æœ¬å°±æ²¡æœ‰å®Œæˆã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬æœ‰ä¸€ä¸ªæ— é™å¾ªç¯ï¼Œè¿™æ˜¯ç”±äºå›¾çš„å¾ªç¯æ€§è´¨é€ æˆçš„ï¼
- en: Exercise
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the above examples leads to a cycle? Why?
  id: totrans-90
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸Šè¿°å“ªä¸ªä¾‹å­ä¼šå¯¼è‡´å¾ªç¯ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ
- en: 17.2.1.2Â Cleaning up the Loop[ğŸ”—](#(part._.Cleaning_up_the_.Loop) "Link to here")
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 17.2.1.2Â æ¸…ç†å¾ªç¯[ğŸ”—](#(part._.Cleaning_up_the_.Loop) "é“¾æ¥è‡³æ­¤")
- en: Before we continue, letâ€™s try to improve the expression of the loop. While the
    nested function above is a perfectly reasonable definition, we can use Pyretâ€™s
    `for` to improve its readability.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬ç»§ç»­ä¹‹å‰ï¼Œè®©æˆ‘ä»¬å°è¯•æ”¹è¿›å¾ªç¯çš„è¡¨è¾¾å¼ã€‚è™½ç„¶ä¸Šé¢çš„åµŒå¥—å‡½æ•°æ˜¯ä¸€ä¸ªå®Œå…¨åˆç†çš„å®šä¹‰ï¼Œä½†æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ Pyret çš„ `for` æ¥æé«˜å…¶å¯è¯»æ€§ã€‚
- en: 'The essence of the above loop is to iterate over a list of boolean values;
    if one of them is true, the entire loop evaluates to true; if they are all false,
    then we havenâ€™t found a path to the destination node, so the loop evaluates to
    false. Thus:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šé¢çš„å¾ªç¯çš„æœ¬è´¨æ˜¯éå†ä¸€ä¸ªå¸ƒå°”å€¼åˆ—è¡¨ï¼›å¦‚æœå…¶ä¸­ä¹‹ä¸€ä¸ºçœŸï¼Œåˆ™æ•´ä¸ªå¾ªç¯è¯„ä¼°ä¸ºçœŸï¼›å¦‚æœå®ƒä»¬éƒ½ä¸ºå‡ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ²¡æœ‰æ‰¾åˆ°åˆ°è¾¾ç›®æ ‡èŠ‚ç‚¹çš„è·¯å¾„ï¼Œæ‰€ä»¥å¾ªç¯è¯„ä¼°ä¸ºå‡ã€‚å› æ­¤ï¼š
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With this, we can replace the loop definition and use with:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥æ›¿æ¢å¾ªç¯å®šä¹‰å¹¶ä½¿ç”¨ï¼š
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 17.2.1.3Â Traversal with Memory[ğŸ”—](#(part._.Traversal_with_.Memory) "Link to
    here")
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 17.2.1.3Â ä½¿ç”¨è®°å¿†è¿›è¡Œéå†[ğŸ”—](#(part._.Traversal_with_.Memory) "é“¾æ¥è‡³æ­¤")
- en: Because we have cyclic data, we have to remember what nodes weâ€™ve already visited
    and avoid traversing them again. Then, every time we begin traversing a new node,
    we add it to the set of nodes weâ€™ve already started to visit so that. If we return
    to that node, because we can assume the graph has not changed in the meanwhile,
    we know that additional traversals from that node wonâ€™t make any difference to
    the outcome.This property is known as [â˜› idempotence](glossary.html#%28elem._glossary-idempotence%29).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºæˆ‘ä»¬å…·æœ‰å¾ªç¯æ•°æ®ï¼Œæˆ‘ä»¬å¿…é¡»è®°ä½æˆ‘ä»¬å·²ç»è®¿é—®è¿‡çš„èŠ‚ç‚¹å¹¶é¿å…å†æ¬¡éå†å®ƒä»¬ã€‚ç„¶åï¼Œæ¯æ¬¡æˆ‘ä»¬å¼€å§‹éå†ä¸€ä¸ªæ–°çš„èŠ‚ç‚¹æ—¶ï¼Œæˆ‘ä»¬å°†å…¶æ·»åŠ åˆ°æˆ‘ä»¬å·²ç»å¼€å§‹è®¿é—®çš„èŠ‚ç‚¹é›†åˆä¸­ï¼Œä»¥ä¾¿ã€‚å¦‚æœæˆ‘ä»¬è¿”å›åˆ°è¯¥èŠ‚ç‚¹ï¼Œå› ä¸ºæˆ‘ä»¬å¯ä»¥å‡è®¾åœ¨æ­¤æœŸé—´å›¾æ²¡æœ‰æ”¹å˜ï¼Œæˆ‘ä»¬çŸ¥é“ä»è¯¥èŠ‚ç‚¹è¿›è¡Œçš„é¢å¤–éå†ä¸ä¼šå¯¹ç»“æœäº§ç”Ÿä»»ä½•å½±å“ã€‚è¿™ä¸ªç‰¹æ€§è¢«ç§°ä¸º[â˜›
    å¹‚ç­‰æ€§](glossary.html#%28elem._glossary-idempotence%29)ã€‚
- en: 'We therefore define a second attempt at reachability that take an extra argument:
    the set of nodes we have begun visiting (where the set is represented as a graph).
    The key difference from [<graph-reach-1-main>](#%28elem._graph-reach-1-main%29)
    is, before we begin to traverse edges, we should check whether weâ€™ve begun processing
    the node or not. This results in the following definition:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬å®šä¹‰äº†ç¬¬äºŒæ¬¡å°è¯•çš„å¯è¾¾æ€§ï¼Œå®ƒæ¥å—ä¸€ä¸ªé¢å¤–çš„å‚æ•°ï¼šæˆ‘ä»¬å·²ç»å¼€å§‹è®¿é—®çš„èŠ‚ç‚¹é›†ï¼ˆå…¶ä¸­é›†åˆç”±å›¾è¡¨ç¤ºï¼‰ã€‚ä¸[<graph-reach-1-main>](#%28elem._graph-reach-1-main%29)çš„å…³é”®åŒºåˆ«åœ¨äºï¼Œåœ¨æˆ‘ä»¬å¼€å§‹éå†è¾¹ä¹‹å‰ï¼Œæˆ‘ä»¬åº”è¯¥æ£€æŸ¥æˆ‘ä»¬æ˜¯å¦å·²ç»å¼€å§‹å¤„ç†è¯¥èŠ‚ç‚¹ã€‚è¿™å¯¼è‡´äº†ä»¥ä¸‹å®šä¹‰ï¼š
- en: <graph-reach-2> ::=
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <graph-reach-2> ::=
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In particular, note the extra new conditional: if the reachability check has
    already visited this node before, there is no point traversing further from here,
    so it returns `false`. (There may still be other parts of the graph to explore,
    which other recursive calls will do.)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ç‰¹åˆ«æ³¨æ„é¢å¤–çš„æ¡ä»¶ï¼šå¦‚æœå¯è¾¾æ€§æ£€æŸ¥ä¹‹å‰å·²ç»è®¿é—®è¿‡è¿™ä¸ªèŠ‚ç‚¹ï¼Œå°±æ²¡æœ‰å¿…è¦ä»è¿™é‡Œè¿›ä¸€æ­¥éå†ï¼Œå› æ­¤å®ƒè¿”å›`false`ã€‚ï¼ˆå¯èƒ½è¿˜æœ‰å…¶ä»–å›¾çš„éƒ¨åˆ†éœ€è¦æ¢ç´¢ï¼Œè¿™å°†ç”±å…¶ä»–é€’å½’è°ƒç”¨å®Œæˆã€‚ï¼‰
- en: Exercise
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does it matter if the first two conditions were swapped, i.e., the beginning
    of `reach-2` began with
  id: totrans-105
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœå‰ä¸¤ä¸ªæ¡ä»¶è¢«äº¤æ¢äº†ï¼Œå³`reach-2`çš„å¼€å§‹æ˜¯
- en: ''
  id: totrans-106
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-107
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ''
  id: totrans-108
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '? Explain concretely with examples.'
  id: totrans-109
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¯·ç”¨å…·ä½“çš„ä¾‹å­å…·ä½“è¯´æ˜ã€‚
- en: Exercise
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We repeatedly talk about remembering the nodes that we have begun to visit,
    not the ones weâ€™ve finished visiting. Does this distinction matter? How?
  id: totrans-112
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åå¤è®¨è®ºè®°ä½æˆ‘ä»¬å·²ç»å¼€å§‹è®¿é—®çš„èŠ‚ç‚¹ï¼Œè€Œä¸æ˜¯æˆ‘ä»¬å·²ç»å®Œæˆè®¿é—®çš„èŠ‚ç‚¹ã€‚è¿™ç§åŒºåˆ«é‡è¦å—ï¼Ÿå¦‚ä½•é‡è¦ï¼Ÿ
- en: 17.2.1.4Â A Better Interface[ğŸ”—](#(part._.A_.Better_.Interface) "Link to here")
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 17.2.1.4Â æ›´å¥½çš„æ¥å£[ğŸ”—](#(part._.A_.Better_.Interface) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'As the process of testing `reach-2` shows, we may have a better implementation,
    but weâ€™ve changed the functionâ€™s interface; now it has a needless extra argument,
    which is not only a nuisance but might also result in errors if we accidentally
    misuse it. Therefore, we should clean up our definition by moving the core code
    to an internal function:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æµ‹è¯•`reach-2`çš„è¿‡ç¨‹æ‰€ç¤ºï¼Œæˆ‘ä»¬å¯èƒ½æœ‰ä¸€ä¸ªæ›´å¥½çš„å®ç°ï¼Œä½†æˆ‘ä»¬å·²ç»æ”¹å˜äº†å‡½æ•°çš„æ¥å£ï¼›ç°åœ¨å®ƒæœ‰ä¸€ä¸ªä¸å¿…è¦çš„é¢å¤–å‚æ•°ï¼Œè¿™ä¸ä»…æ˜¯ä¸€ä¸ªéº»çƒ¦ï¼Œå¦‚æœæˆ‘ä»¬ä¸å°å¿ƒè¯¯ç”¨å®ƒï¼Œè¿˜å¯èƒ½å¯¼è‡´é”™è¯¯ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åº”è¯¥é€šè¿‡å°†æ ¸å¿ƒä»£ç ç§»åŠ¨åˆ°å†…éƒ¨å‡½æ•°æ¥æ¸…ç†æˆ‘ä»¬çš„å®šä¹‰ï¼š
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have now restored the original interface while correctly implementing reachability.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨å·²ç»æ¢å¤äº†åŸå§‹æ¥å£ï¼ŒåŒæ—¶æ­£ç¡®å®ç°äº†å¯è¾¾æ€§ã€‚
- en: Exercise
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does this really gives us a correct implementation? In particular, does this
    address the problem that the `size` function above addressed? Create a test case
    that demonstrates the problem, and then fix it.
  id: totrans-119
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™çœŸçš„ç»™æˆ‘ä»¬æä¾›äº†ä¸€ä¸ªæ­£ç¡®çš„å®ç°å—ï¼Ÿç‰¹åˆ«æ˜¯ï¼Œè¿™è§£å†³äº†ä¸Šé¢`size`å‡½æ•°æ‰€è§£å†³çš„é—®é¢˜å—ï¼Ÿåˆ›å»ºä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹æ¥å±•ç¤ºè¿™ä¸ªé—®é¢˜ï¼Œç„¶åä¿®å¤å®ƒã€‚
- en: 17.2.1.1Â Simple Recursion[ğŸ”—](#(part._.Simple_.Recursion) "Link to here")
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 17.2.1.1Â ç®€å•é€’å½’[ğŸ”—](#(part._.Simple_.Recursion) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'At its simplest, reachability is easy. We want to know whether there exists
    a pathA path is a sequence of zero or more linked edges. between a pair of nodes,
    a source and a destination. (A more sophisticated version of reachability might
    compute the actual path, but weâ€™ll ignore this for now.) There are two possibilities:
    the source and destintion nodes are the same, or theyâ€™re not.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ€ç®€å•çš„æƒ…å†µä¸‹ï¼Œå¯è¾¾æ€§å¾ˆå®¹æ˜“ã€‚æˆ‘ä»¬æƒ³çŸ¥é“æ˜¯å¦å­˜åœ¨ä¸€æ¡è·¯å¾„ï¼Œä¸€æ¡è·¯å¾„æ˜¯ç”±é›¶ä¸ªæˆ–å¤šä¸ªé“¾æ¥è¾¹ç»„æˆçš„åºåˆ—ã€‚ä»ä¸€ä¸ªèŠ‚ç‚¹å¯¹ï¼Œä¸€ä¸ªæºèŠ‚ç‚¹å’Œä¸€ä¸ªç›®æ ‡èŠ‚ç‚¹ã€‚ (ä¸€ä¸ªæ›´å¤æ‚çš„å¯è¾¾æ€§ç‰ˆæœ¬å¯èƒ½ä¼šè®¡ç®—å®é™…çš„è·¯å¾„ï¼Œä½†æˆ‘ä»¬ç°åœ¨å¿½ç•¥è¿™ä¸€ç‚¹ã€‚)æœ‰ä¸¤ç§å¯èƒ½æ€§ï¼šæºèŠ‚ç‚¹å’Œç›®æ ‡èŠ‚ç‚¹æ˜¯ç›¸åŒçš„ï¼Œæˆ–è€…å®ƒä»¬ä¸æ˜¯ã€‚
- en: If they are the same, then clearly reachability is trivially satisfied.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœå®ƒä»¬ç›¸åŒï¼Œé‚£ä¹ˆæ˜¾ç„¶å¯è¾¾æ€§æ˜¯æ˜¾è€Œæ˜“è§çš„ã€‚
- en: If they are not, we have to iterate through the neighbors of the source node
    and ask whether the destination is reachable from each of those neighbors.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœå®ƒä»¬ä¸ç›¸åŒï¼Œæˆ‘ä»¬å¿…é¡»éå†æºèŠ‚ç‚¹çš„é‚»å±…ï¼Œå¹¶è¯¢é—®ä»æ¯ä¸ªé‚»å±…æ˜¯å¦å¯ä»¥åˆ°è¾¾ç›®æ ‡ã€‚
- en: 'This translates into the following function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è½¬åŒ–ä¸ºä»¥ä¸‹å‡½æ•°ï¼š
- en: <graph-reach-1-main> ::=
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <graph-reach-1-main> ::=
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'where the loop through the neighbors of `src` is:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­é€šè¿‡`src`çš„é‚»å±…çš„å¾ªç¯æ˜¯ï¼š
- en: <graph-reach-1-loop> ::=
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <graph-reach-1-loop> ::=
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can test this as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥è¿™æ ·æµ‹è¯•ï¼š
- en: <graph-reach-tests> ::=
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <graph-reach-tests> ::=
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Unfortunately, we donâ€™t find out about how these tests fare, because some of
    them donâ€™t complete at all. Thatâ€™s because we have an infinite loop, due to the
    cyclic nature of graphs!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: å¾ˆé—æ†¾ï¼Œæˆ‘ä»¬æ— æ³•å¾—çŸ¥è¿™äº›æµ‹è¯•çš„ç»“æœï¼Œå› ä¸ºå…¶ä¸­ä¸€äº›æ ¹æœ¬æ— æ³•å®Œæˆã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬æœ‰ä¸€ä¸ªæ— é™å¾ªç¯ï¼Œè¿™æ˜¯ç”±äºå›¾çš„å¾ªç¯æ€§è´¨é€ æˆçš„ï¼
- en: Exercise
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the above examples leads to a cycle? Why?
  id: totrans-136
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸Šè¿°å“ªä¸ªç¤ºä¾‹ä¼šå¯¼è‡´å¾ªç¯ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ
- en: 17.2.1.2Â Cleaning up the Loop[ğŸ”—](#(part._.Cleaning_up_the_.Loop) "Link to here")
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 17.2.1.2Â æ¸…ç†å¾ªç¯[ğŸ”—](#(part._.Cleaning_up_the_.Loop) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Before we continue, letâ€™s try to improve the expression of the loop. While the
    nested function above is a perfectly reasonable definition, we can use Pyretâ€™s
    `for` to improve its readability.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬ç»§ç»­ä¹‹å‰ï¼Œè®©æˆ‘ä»¬å°è¯•æ”¹è¿›å¾ªç¯çš„è¡¨è¾¾å¼ã€‚è™½ç„¶ä¸Šé¢çš„åµŒå¥—å‡½æ•°æ˜¯ä¸€ä¸ªå®Œå…¨åˆç†çš„å®šä¹‰ï¼Œä½†æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ Pyret çš„ `for` æ¥æé«˜å…¶å¯è¯»æ€§ã€‚
- en: 'The essence of the above loop is to iterate over a list of boolean values;
    if one of them is true, the entire loop evaluates to true; if they are all false,
    then we havenâ€™t found a path to the destination node, so the loop evaluates to
    false. Thus:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šé¢çš„å¾ªç¯çš„æœ¬è´¨æ˜¯éå†ä¸€ä¸ªå¸ƒå°”å€¼åˆ—è¡¨ï¼›å¦‚æœå…¶ä¸­ä¹‹ä¸€ä¸ºçœŸï¼Œåˆ™æ•´ä¸ªå¾ªç¯è¯„ä¼°ä¸ºçœŸï¼›å¦‚æœå®ƒä»¬éƒ½æ˜¯å‡çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ²¡æœ‰æ‰¾åˆ°åˆ°è¾¾ç›®æ ‡èŠ‚ç‚¹çš„è·¯å¾„ï¼Œæ‰€ä»¥å¾ªç¯è¯„ä¼°ä¸ºå‡ã€‚å› æ­¤ï¼š
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With this, we can replace the loop definition and use with:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ä¸ªæ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥æ›¿æ¢å¾ªç¯å®šä¹‰å’Œç”¨æ³•ï¼š
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 17.2.1.3Â Traversal with Memory[ğŸ”—](#(part._.Traversal_with_.Memory) "Link to
    here")
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 17.2.1.3 ä½¿ç”¨è®°å¿†è¿›è¡Œéå†[ğŸ”—](#(part._.Traversal_with_.Memory) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Because we have cyclic data, we have to remember what nodes weâ€™ve already visited
    and avoid traversing them again. Then, every time we begin traversing a new node,
    we add it to the set of nodes weâ€™ve already started to visit so that. If we return
    to that node, because we can assume the graph has not changed in the meanwhile,
    we know that additional traversals from that node wonâ€™t make any difference to
    the outcome.This property is known as [â˜› idempotence](glossary.html#%28elem._glossary-idempotence%29).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºæˆ‘ä»¬æœ‰å¾ªç¯æ•°æ®ï¼Œæˆ‘ä»¬å¿…é¡»è®°ä½æˆ‘ä»¬å·²ç»è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œä»¥é¿å…å†æ¬¡éå†å®ƒä»¬ã€‚ç„¶åï¼Œæ¯æ¬¡æˆ‘ä»¬å¼€å§‹éå†ä¸€ä¸ªæ–°çš„èŠ‚ç‚¹æ—¶ï¼Œæˆ‘ä»¬å°†å…¶æ·»åŠ åˆ°æˆ‘ä»¬å·²ç»å¼€å§‹è®¿é—®çš„èŠ‚ç‚¹é›†åˆä¸­ã€‚å¦‚æœæˆ‘ä»¬å›åˆ°é‚£ä¸ªèŠ‚ç‚¹ï¼Œå› ä¸ºæˆ‘ä»¬å¯ä»¥å‡è®¾åœ¨æ­¤æœŸé—´å›¾æ²¡æœ‰æ”¹å˜ï¼Œæˆ‘ä»¬çŸ¥é“ä»è¿™ä¸ªèŠ‚ç‚¹è¿›è¡Œçš„é¢å¤–éå†ä¸ä¼šå¯¹ç»“æœäº§ç”Ÿå½±å“ã€‚è¿™ä¸ªç‰¹æ€§è¢«ç§°ä¸º[â˜›
    å¹‚ç­‰æ€§](glossary.html#%28elem._glossary-idempotence%29)ã€‚
- en: 'We therefore define a second attempt at reachability that take an extra argument:
    the set of nodes we have begun visiting (where the set is represented as a graph).
    The key difference from [<graph-reach-1-main>](#%28elem._graph-reach-1-main%29)
    is, before we begin to traverse edges, we should check whether weâ€™ve begun processing
    the node or not. This results in the following definition:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªæ–°çš„å¯è¾¾æ€§å°è¯•ï¼Œå®ƒæ¥å—ä¸€ä¸ªé¢å¤–çš„å‚æ•°ï¼šæˆ‘ä»¬å·²ç»å¼€å§‹è®¿é—®çš„èŠ‚ç‚¹é›†åˆï¼ˆå…¶ä¸­é›†åˆä»¥å›¾çš„å½¢å¼è¡¨ç¤ºï¼‰ã€‚ä¸[<graph-reach-1-main>](#%28elem._graph-reach-1-main%29)çš„å…³é”®åŒºåˆ«åœ¨äºï¼Œåœ¨æˆ‘ä»¬å¼€å§‹éå†è¾¹ä¹‹å‰ï¼Œæˆ‘ä»¬åº”è¯¥æ£€æŸ¥æ˜¯å¦å·²ç»å¼€å§‹å¤„ç†è¯¥èŠ‚ç‚¹ã€‚è¿™å¯¼è‡´äº†ä»¥ä¸‹å®šä¹‰ï¼š
- en: <graph-reach-2> ::=
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <graph-reach-2> ::=
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In particular, note the extra new conditional: if the reachability check has
    already visited this node before, there is no point traversing further from here,
    so it returns `false`. (There may still be other parts of the graph to explore,
    which other recursive calls will do.)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ç‰¹åˆ«æ³¨æ„é¢å¤–çš„æ¡ä»¶ï¼šå¦‚æœå¯è¾¾æ€§æ£€æŸ¥ä¹‹å‰å·²ç»è®¿é—®è¿‡è¿™ä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆä»è¿™é‡Œè¿›ä¸€æ­¥éå†å°±æ²¡æœ‰æ„ä¹‰äº†ï¼Œæ‰€ä»¥å®ƒè¿”å›`false`ã€‚ï¼ˆå¯èƒ½è¿˜æœ‰å…¶ä»–å›¾çš„éƒ¨åˆ†éœ€è¦æ¢ç´¢ï¼Œè¿™å°†ç”±å…¶ä»–é€’å½’è°ƒç”¨å®Œæˆã€‚ï¼‰
- en: Exercise
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does it matter if the first two conditions were swapped, i.e., the beginning
    of `reach-2` began with
  id: totrans-151
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœå‰ä¸¤ä¸ªæ¡ä»¶è¢«äº¤æ¢äº†ï¼Œå³`reach-2`çš„å¼€å§‹æ˜¯
- en: ''
  id: totrans-152
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-153
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ''
  id: totrans-154
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '? Explain concretely with examples.'
  id: totrans-155
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¯·å…·ä½“ä¸¾ä¾‹è¯´æ˜ã€‚
- en: Exercise
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We repeatedly talk about remembering the nodes that we have begun to visit,
    not the ones weâ€™ve finished visiting. Does this distinction matter? How?
  id: totrans-158
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åå¤è°ˆè®ºè®°ä½æˆ‘ä»¬å·²ç»å¼€å§‹è®¿é—®çš„èŠ‚ç‚¹ï¼Œè€Œä¸æ˜¯æˆ‘ä»¬å·²ç»å®Œæˆè®¿é—®çš„èŠ‚ç‚¹ã€‚è¿™ç§åŒºåˆ«é‡è¦å—ï¼Ÿå¦‚ä½•é‡è¦ï¼Ÿ
- en: 17.2.1.4Â A Better Interface[ğŸ”—](#(part._.A_.Better_.Interface) "Link to here")
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 17.2.1.4 æ›´å¥½çš„æ¥å£[ğŸ”—](#(part._.A_.Better_.Interface) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'As the process of testing `reach-2` shows, we may have a better implementation,
    but weâ€™ve changed the functionâ€™s interface; now it has a needless extra argument,
    which is not only a nuisance but might also result in errors if we accidentally
    misuse it. Therefore, we should clean up our definition by moving the core code
    to an internal function:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æµ‹è¯•`reach-2`çš„è¿‡ç¨‹æ‰€ç¤ºï¼Œæˆ‘ä»¬å¯èƒ½æœ‰ä¸€ä¸ªæ›´å¥½çš„å®ç°ï¼Œä½†æˆ‘ä»¬æ”¹å˜äº†å‡½æ•°çš„æ¥å£ï¼›ç°åœ¨å®ƒæœ‰ä¸€ä¸ªä¸å¿…è¦çš„é¢å¤–å‚æ•°ï¼Œè¿™ä¸ä»…æ˜¯ä¸€ä¸ªéº»çƒ¦ï¼Œå¦‚æœæˆ‘ä»¬ä¸å°å¿ƒè¯¯ç”¨å®ƒï¼Œè¿˜å¯èƒ½å¯¼è‡´é”™è¯¯ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åº”è¯¥é€šè¿‡å°†æ ¸å¿ƒä»£ç ç§»åŠ¨åˆ°å†…éƒ¨å‡½æ•°æ¥æ¸…ç†æˆ‘ä»¬çš„å®šä¹‰ï¼š
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have now restored the original interface while correctly implementing reachability.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨å·²ç»æ¢å¤äº†åŸå§‹æ¥å£ï¼ŒåŒæ—¶æ­£ç¡®å®ç°äº†å¯è¾¾æ€§ã€‚
- en: Exercise
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does this really gives us a correct implementation? In particular, does this
    address the problem that the `size` function above addressed? Create a test case
    that demonstrates the problem, and then fix it.
  id: totrans-165
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™çœŸçš„ç»™äº†æˆ‘ä»¬ä¸€ä¸ªæ­£ç¡®çš„å®ç°å—ï¼Ÿç‰¹åˆ«æ˜¯ï¼Œè¿™è§£å†³äº†ä¸Šé¢`size`å‡½æ•°è§£å†³çš„é—®é¢˜å—ï¼Ÿåˆ›å»ºä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹æ¥å±•ç¤ºè¿™ä¸ªé—®é¢˜ï¼Œç„¶åä¿®å¤å®ƒã€‚
- en: 17.2.2Â Depth- and Breadth-First Traversals[ğŸ”—](#(part._dfs-bfs) "Link to here")
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.2.2 æ·±åº¦ä¼˜å…ˆå’Œå¹¿åº¦ä¼˜å…ˆéå†[ğŸ”—](#(part._dfs-bfs) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: It is conventional for computer science texts to call these depth- and breadth-first
    search. However, searching is just a specific purpose; traversal is a general
    task that can be used for many purposes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: è®¡ç®—æœºç§‘å­¦æ–‡æœ¬ä¸­é€šå¸¸å°†è¿™äº›ç§°ä¸ºæ·±åº¦ä¼˜å…ˆæœç´¢å’Œå¹¿åº¦ä¼˜å…ˆæœç´¢ã€‚ç„¶è€Œï¼Œæœç´¢åªæ˜¯ç‰¹å®šç›®çš„ï¼›éå†æ˜¯ä¸€ä¸ªé€šç”¨ä»»åŠ¡ï¼Œå¯ä»¥ç”¨äºè®¸å¤šç›®çš„ã€‚
- en: 'The reachability algorithm we have seen above has a special property. At every
    node it visits, there is usually a set of adjacent nodes at which it can continue
    the traversal. It has at least two choices: it can either visit each immediate
    neighbor first, then visit all of the neighborsâ€™ neighbors; or it can choose a
    neighbor, recur, and visit the next immediate neighbor only after that visit is
    done. The former is known as breadth-first traversal, while the latter is depth-first
    traversal.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¸Šé¢çœ‹åˆ°çš„å¯è¾¾æ€§ç®—æ³•æœ‰ä¸€ä¸ªç‰¹æ®Šæ€§è´¨ã€‚åœ¨å®ƒè®¿é—®çš„æ¯ä¸ªèŠ‚ç‚¹ä¸Šï¼Œé€šå¸¸æœ‰ä¸€ç»„ç›¸é‚»èŠ‚ç‚¹ï¼Œå®ƒå¯ä»¥åœ¨è¿™äº›èŠ‚ç‚¹ä¸Šç»§ç»­éå†ã€‚å®ƒè‡³å°‘æœ‰ä¸¤ä¸ªé€‰æ‹©ï¼šå®ƒå¯ä»¥å…ˆè®¿é—®æ¯ä¸ªç›´æ¥é‚»å±…ï¼Œç„¶åè®¿é—®æ‰€æœ‰é‚»å±…çš„é‚»å±…ï¼›æˆ–è€…å®ƒå¯ä»¥é€‰æ‹©ä¸€ä¸ªé‚»å±…ï¼Œé€’å½’ï¼Œç„¶ååœ¨è®¿é—®å®Œæˆä¹‹åæ‰è®¿é—®ä¸‹ä¸€ä¸ªç›´æ¥é‚»å±…ã€‚å‰è€…è¢«ç§°ä¸ºå¹¿åº¦ä¼˜å…ˆéå†ï¼Œè€Œåè€…è¢«ç§°ä¸ºæ·±åº¦ä¼˜å…ˆéå†ã€‚
- en: 'The algorithm we have designed uses a depth-first strategy: inside [<graph-reach-1-loop>](#%28elem._graph-reach-1-loop%29),
    we recur on the first element of the list of neighbors before we visit the second
    neighbor, and so on. The alternative would be to have a data structure into which
    we insert all the neighbors, then pull out an element at a time such that we first
    visit all the neighbors before their neighbors, and so on. This naturally corresponds
    to a queue [[An Example: Queues from Lists](amortized-analysis.html#%28part._queue-data-structure%29)].'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è®¾è®¡çš„ç®—æ³•é‡‡ç”¨æ·±åº¦ä¼˜å…ˆç­–ç•¥ï¼šåœ¨ [<graph-reach-1-loop>](#%28elem._graph-reach-1-loop%29) å†…ï¼Œæˆ‘ä»¬åœ¨è®¿é—®ç¬¬äºŒä¸ªé‚»å±…ä¹‹å‰ï¼Œå…ˆé€’å½’è®¿é—®é‚»å±…åˆ—è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œä¾æ­¤ç±»æ¨ã€‚å¦ä¸€ç§é€‰æ‹©æ˜¯åˆ›å»ºä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œå°†æ‰€æœ‰é‚»å±…æ’å…¥å…¶ä¸­ï¼Œç„¶åæ¯æ¬¡å–å‡ºä¸€ä¸ªå…ƒç´ ï¼Œè¿™æ ·æˆ‘ä»¬é¦–å…ˆè®¿é—®æ‰€æœ‰é‚»å±…ï¼Œç„¶åå†è®¿é—®ä»–ä»¬çš„é‚»å±…ï¼Œä¾æ­¤ç±»æ¨ã€‚è¿™è‡ªç„¶å¯¹åº”äºé˜Ÿåˆ—
    [[ä¸€ä¸ªä¾‹å­ï¼šä»åˆ—è¡¨ä¸­å¾—åˆ°çš„é˜Ÿåˆ—](amortized-analysis.html#%28part._queue-data-structure%29)]ã€‚
- en: Exercise
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using a queue, implement breadth-first traversal.
  id: totrans-172
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨é˜Ÿåˆ—å®ç°å¹¿åº¦ä¼˜å…ˆéå†ã€‚
- en: 'If we correctly check to ensure we donâ€™t re-visit nodes, then both breadth-
    and depth-first traversal will properly visit the entire reachable graph without
    repetition (and hence not get into an infinite loop). Each one traverses from
    a node only once, from which it considers every single edge. Thus, if a graph
    has \(N\) nodes and \(E\) edges, then a lower-bound on the complexity of traversal
    is \(O([N, E \rightarrow N + E])\). We must also consider the cost of checking
    whether we have already visited a node before (which is a set membership problem,
    which we address elsewhere: [Several Variations on Sets](part_sets.html)). Finally,
    we have to consider the cost of maintaining the data structure that keeps track
    of our traversal. In the case of depth-first traversal, recursionâ€”<wbr>which uses
    the machineâ€™s stackâ€”<wbr>does it automatically at constant overhead. In the case
    of breadth-first traversal, the program must manage the queue, which can add more
    than constant overhead.In practice, too, the stack will usually perform much better
    than a queue, because it is supported by machine hardware.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æ­£ç¡®åœ°æ£€æŸ¥ä»¥ç¡®ä¿æˆ‘ä»¬ä¸é‡å¤è®¿é—®èŠ‚ç‚¹ï¼Œé‚£ä¹ˆå¹¿åº¦å’Œæ·±åº¦ä¼˜å…ˆéå†éƒ½å°†æ­£ç¡®åœ°éå†æ•´ä¸ªå¯è¾¾å›¾ï¼Œè€Œä¸é‡å¤ï¼ˆå› æ­¤ä¸ä¼šé™·å…¥æ— é™å¾ªç¯ï¼‰ã€‚æ¯ä¸ªéå†åªä»ä¸€ä¸ªèŠ‚ç‚¹å¼€å§‹ï¼Œè€ƒè™‘æ¯ä¸€æ¡è¾¹ã€‚å› æ­¤ï¼Œå¦‚æœä¸€ä¸ªå›¾æœ‰
    \(N\) ä¸ªèŠ‚ç‚¹å’Œ \(E\) æ¡è¾¹ï¼Œé‚£ä¹ˆéå†çš„å¤æ‚åº¦ä¸‹é™æ˜¯ \(O([N, E \rightarrow N + E])\)ã€‚æˆ‘ä»¬è¿˜å¿…é¡»è€ƒè™‘æ£€æŸ¥æˆ‘ä»¬æ˜¯å¦å·²ç»è®¿é—®è¿‡èŠ‚ç‚¹çš„æˆæœ¬ï¼ˆè¿™æ˜¯ä¸€ä¸ªé›†åˆæˆå‘˜é—®é¢˜ï¼Œæˆ‘ä»¬å°†åœ¨å…¶ä»–åœ°æ–¹è§£å†³ï¼š[é›†åˆçš„å‡ ç§å˜ä½“](part_sets.html)ï¼‰ã€‚æœ€åï¼Œæˆ‘ä»¬å¿…é¡»è€ƒè™‘ç»´æŠ¤è·Ÿè¸ªæˆ‘ä»¬éå†çš„æ•°æ®ç»“æ„çš„æˆæœ¬ã€‚åœ¨æ·±åº¦ä¼˜å…ˆéå†çš„æƒ…å†µä¸‹ï¼Œé€’å½’â€”â€”<wbr>å®ƒä½¿ç”¨æœºå™¨çš„æ ˆâ€”â€”<wbr>è‡ªåŠ¨ä»¥æ’å®šå¼€é”€å®Œæˆã€‚åœ¨å¹¿åº¦ä¼˜å…ˆéå†çš„æƒ…å†µä¸‹ï¼Œç¨‹åºå¿…é¡»ç®¡ç†é˜Ÿåˆ—ï¼Œè¿™å¯èƒ½ä¼šå¢åŠ è¶…è¿‡æ’å®šå¼€é”€ã€‚åœ¨å®è·µä¸­ï¼Œå †æ ˆé€šå¸¸ä¼šæ¯”é˜Ÿåˆ—è¡¨ç°å¾—æ›´å¥½ï¼Œå› ä¸ºå®ƒæ˜¯å—æœºå™¨ç¡¬ä»¶æ”¯æŒçš„ã€‚
- en: 'This would suggest that depth-first traversal is always better than breadth-first
    traversal. However, breadth-first traversal has one very important and valuable
    property. Starting from a node \(N\), when it visits a node \(P\), count the number
    of edges taken to get to \(P\). Breadth-first traversal guarantees that there
    cannot have been a shorter path to \(P\): that is, it finds a shortest path to
    \(P\).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯èƒ½ä¼šè®©äººè®¤ä¸ºæ·±åº¦ä¼˜å…ˆéå†æ€»æ˜¯ä¼˜äºå¹¿åº¦ä¼˜å…ˆéå†ã€‚ç„¶è€Œï¼Œå¹¿åº¦ä¼˜å…ˆéå†æœ‰ä¸€ä¸ªéå¸¸é‡è¦çš„ç‰¹æ€§ã€‚ä»ä¸€ä¸ªèŠ‚ç‚¹ \(N\) å¼€å§‹ï¼Œå½“å®ƒè®¿é—®ä¸€ä¸ªèŠ‚ç‚¹ \(P\) æ—¶ï¼Œè®¡ç®—åˆ°è¾¾
    \(P\) æ‰€ç»è¿‡çš„è¾¹çš„æ•°é‡ã€‚å¹¿åº¦ä¼˜å…ˆéå†ä¿è¯ä¸å­˜åœ¨åˆ°è¾¾ \(P\) çš„æ›´çŸ­è·¯å¾„ï¼šä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒæ‰¾åˆ°äº†åˆ°è¾¾ \(P\) çš„æœ€çŸ­è·¯å¾„ã€‚
- en: Exercise
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why â€œaâ€ rather than â€œtheâ€ shortest path?
  id: totrans-177
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆæ˜¯â€œaâ€è€Œä¸æ˜¯â€œtheâ€æœ€çŸ­è·¯å¾„ï¼Ÿ
- en: Exercise
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Prove that breadth-first traversal finds a shortest path.
  id: totrans-180
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¯æ˜å¹¿åº¦ä¼˜å…ˆéå†æ‰¾åˆ°æœ€çŸ­è·¯å¾„ã€‚
