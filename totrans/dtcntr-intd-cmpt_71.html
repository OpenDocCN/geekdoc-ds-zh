<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>26Â Deconstructing LoopsğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>26Â Deconstructing LoopsğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/deconstructing-loops.html">https://dcic-world.org/2025-08-27/deconstructing-loops.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._.Setup__.Two_.Functions%29" class="toclink" data-pltdoc="x">26.1Â Setup: Two Functions</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Abstracting_a_.Loop%29" class="toclink" data-pltdoc="x">26.2Â Abstracting a Loop</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Is_.It_.Really_a_.Loop_%29" class="toclink" data-pltdoc="x">26.3Â Is It Really a Loop?</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Re-.Examining___struct_traverse-element___procedure____lib_render-cond_rkt_38_12__%29" class="toclink" data-pltdoc="x">26.4Â Re-Examining <code data-lang="pyret" class="sourceCode">for</code></a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Rewriting_.Pollard-.Rho%29" class="toclink" data-pltdoc="x">26.5Â Rewriting Pollard-Rho</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Nested_.Loops%29" class="toclink" data-pltdoc="x">26.6Â Nested Loops</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Loops__.Values__and_.Customization%29" class="toclink" data-pltdoc="x">26.7Â Loops, Values, and Customization</a></p></td></tr></table><section class="SsectionLevel3" id="section 26.1"><h3 class="heading">26.1Â <a name="(part._.Setup__.Two_.Functions)"/>Setup: Two Functions<a href="#(part._.Setup__.Two_.Functions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Letâ€™s look at two functions we wrote earlier in <a href="factoring-numbers.html" data-pltdoc="x">Factoring Numbers</a>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun gcd(a, b):
  if b == 0:
    a
  else:
    gcd(b, num-modulo(a, b))
  end
end

fun pr(n):
  fun g(x): num-modulo((x * x) + 1, n) end
  fun iter(x, y, d):
    new-x = g(x)
    new-y = g(g(y))
    new-d = gcd(num-abs(new-x - new-y), n)
    ask:
      | new-d == 1 then:
        iter(new-x, new-y, new-d)
      | new-d == n then:
        none
      | otherwise:
        some(new-d)
    end
  end
  iter(2, 2, 1)
end</code></pre><p>Weâ€™ve written both recursively: <code data-lang="pyret" class="sourceCode">gcd</code> by calling itself and
<code data-lang="pyret" class="sourceCode">pr</code> with recursion on its inner function. But if youâ€™ve
programmed before, youâ€™ve probably written similar programs with
loops.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Because we donâ€™t have loops in Pyret, the best we can do is to use a
higher-order function; which ones would you use?</p></blockquote></blockquote><p>But letâ€™s see if we can do something â€œbetterâ€, i.e., get closer to a
traditional-looking program.</p><p>Before we start changing any code, letâ€™s make sure we have some tests
for <code data-lang="pyret" class="sourceCode">gcd</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  gcd(4, 5) is 1
  gcd(5, 7) is 1
  gcd(21, 21) is 21
  gcd(12, 24) is 12
  gcd(12, 9) is 3
end</code></pre></section><section class="SsectionLevel3" id="section 26.2"><h3 class="heading">26.2Â <a name="(part._.Abstracting_a_.Loop)"/>Abstracting a Loop<a href="#(part._.Abstracting_a_.Loop)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Now letâ€™s think about how we can create a loop. At each iteration, a
loop has a status: whether itâ€™s done or whether it should
continue. Since we have two parameters here, letâ€™s record two
parameters for continuing:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data LoopStatus:
  | done(final-value)
  | next-2(new-arg-1, new-arg-2)
end</code></pre><p>Now we can write a function that does the actual iteration:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun loop-2(f, arg-1, arg-2):
  r = f(arg-1, arg-2)
  cases (LoopStatus) r:
    | done(v) =&gt; v
    | next-2(new-arg-1, new-arg-2) =&gt; loop-2(f, new-arg-1, new-arg-2)
  end
end</code></pre><p>Note that this is completely generic: it has nothing to do with
<code data-lang="pyret" class="sourceCode">gcd</code>. (It is generic in the same way that higher-order functions
like <code data-lang="pyret" class="sourceCode">map</code> and <code data-lang="pyret" class="sourceCode">filter</code> are generic.)  It just repeats if
<code data-lang="pyret" class="sourceCode">f</code> says to repeat, stops if <code data-lang="pyret" class="sourceCode">f</code> says to stop. This is the
essence of a loop.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Observe also that we could, if we wanted, stage [<a href="staging.html" data-pltdoc="x">Staging</a>]
<code data-lang="pyret" class="sourceCode">loop-2</code>, because <code data-lang="pyret" class="sourceCode">f</code> never changes. Rewrite it that way.</p></blockquote></blockquote><p>With <code data-lang="pyret" class="sourceCode">loop-2</code>, we can rewrite <code data-lang="pyret" class="sourceCode">gcd</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun gcd(p, q):
  loop-2(
    {(a, b):
      if b == 0:
        done(a)
      else:
        next-2(b, num-modulo(a, b))
      end},
    p,
    q)
end</code></pre><p>Now it might seem to you we havenâ€™t done anything useful at all. In
fact, this looks like a significant step backward. At least before we
just had simple, clean recursion, the way Euclid intended it. Now we
have a higher-order function and weâ€™re passing it the erstwhile
<code data-lang="pyret" class="sourceCode">gcd</code> code as a function and thereâ€™s this <code data-lang="pyret" class="sourceCode">LoopStatus</code>
datatype andâ€¦everythingâ€™s gotten much more complicated.</p><p>But, not really. The reason we put it in this form is because weâ€™re
about to exploit a feature of Pyret. The <code data-lang="pyret" class="sourceCode">for</code> construct in Pyret
actually rewrites as follows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for F(a from a_i, b from b_i, â€¦): BODY end</code></pre><p>gets rewritten to
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">F({(a, b, â€¦): BODY}, a_i, b_i, â€¦)</code></pre><p>For example, if we write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for map(i from range(0, 10)): i + 1 end</code></pre><p>this becomes
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map({(i): i + 1}, range(0, 10))</code></pre><p>Now you may see why we rewrote <code data-lang="pyret" class="sourceCode">gcd</code>.
Going in reverse, we can rewrite
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">F({(a, b, â€¦): BODY}, a_i, b_i, â€¦)</code></pre><p>as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for F(a from a_i, b from b_i, â€¦): BODY end</code></pre><p>so the function becomes just
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun gcd(p, q):
  for loop-2(a from p, b from q):
    if b == 0:
      done(a)
    else:
      next-2(b, num-modulo(a, b))
    end
  end
end</code></pre><p>and now closely resembles a traditional â€œloopâ€ program.</p></section><section class="SsectionLevel3" id="section 26.3"><h3 class="heading">26.3Â <a name="(part._.Is_.It_.Really_a_.Loop_)"/>Is It Really a Loop?<a href="#(part._.Is_.It_.Really_a_.Loop_)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>This whole section should be considered an aside for people with more
advanced computing knowledge.</p><p>If you know something about language implementation, you may know that
loops have the property that the iteration does not consume extra
space (beyond what the program already needs), and the repetition
takes place very quickly (a â€œjump instructionâ€). In principle, our
<code data-lang="pyret" class="sourceCode">loop-2</code> function does not have this property: every iteration is
a function call, which is more expensive and builds additional stack
context. However, one or both of these does not actually occur in
practice.</p><p>In terms of space, the recursive call to <code data-lang="pyret" class="sourceCode">loop-2</code> is the
last thing that a call to <code data-lang="pyret" class="sourceCode">loop-2</code> does. Furthermore,
nothing in <code data-lang="pyret" class="sourceCode">loop-2</code> consumes and manipulates the return from that
recursive call. This is therefore called a tail call.
Pyretâ€”<wbr/>like some other languagesâ€”<wbr/>causes tail calls to not
take any extra stack space. In principle, Pyret can also turn some
tail calls into jumps. Therefore, this version has close to the same
performance as a traditional loop.</p></section><section class="SsectionLevel3" id="section 26.4"><h3 class="heading">26.4Â <a name="(part._.Re-.Examining___struct_traverse-element___procedure____lib_render-cond_rkt_38_12__)"/>Re-Examining <code data-lang="pyret" class="sourceCode">for</code><a href="#(part._.Re-.Examining___struct_traverse-element___procedure____lib_render-cond_rkt_38_12__)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>The definition of <code data-lang="pyret" class="sourceCode">for</code> given above should make you suspicious:
Whereâ€™s the loop?!? In fact, Pyretâ€™s <code data-lang="pyret" class="sourceCode">for</code> does not do any
looping at all: itâ€™s simply a fancy way of writing <code data-lang="pyret" class="sourceCode">lam</code>. Any
â€œloopingâ€ behavior is in the function written after <code data-lang="pyret" class="sourceCode">for</code>. To
see that, letâ€™s use for with a non-looping function.</p><p>Recall that
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for F(a from a_i, b from b_i, â€¦): BODY end</code></pre><p>gets rewritten to
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">F({(a, b, â€¦): BODY}, a_i, b_i, â€¦)</code></pre><p>Thus, suppose we have this function (from <a href="func-as-data.html" data-pltdoc="x">Functions as Data</a>):
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">delta-x = 0.0001
fun d-dx-at(f, x):
  (f(x + delta-x) - f(x)) / delta-x
end</code></pre><p>We can call it like this to get approximately 20:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx-at({(n): n * n}, 10)</code></pre><p>That means we can also call it like this:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for d-dx-at(n from 10): n * n end</code></pre><p>Indeed:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  for d-dx-at(n from 10): n * n end
  is
  d-dx-at({(n): n * n}, 10)
end</code></pre><p>Since <code data-lang="pyret" class="sourceCode">d-dx-at</code> has no iterative behavior, no iteration
occurs. The looping behavior is given entirely by the function
specified after <code data-lang="pyret" class="sourceCode">for</code>, such as <code data-lang="pyret" class="sourceCode">map</code>, <code data-lang="pyret" class="sourceCode">filter</code>, or
<code data-lang="pyret" class="sourceCode">loop-2</code> above.</p></section><section class="SsectionLevel3" id="section 26.5"><h3 class="heading">26.5Â <a name="(part._.Rewriting_.Pollard-.Rho)"/>Rewriting Pollard-Rho<a href="#(part._.Rewriting_.Pollard-.Rho)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Now letâ€™s tackle Pollard-rho. Notice that itâ€™s a three-parameter
function, so we canâ€™t use the <code data-lang="pyret" class="sourceCode">loop-2</code> we had before: thatâ€™s only
a suitable loop when we have two arguments that change on each
iteration (often the iteration variable and an accumulator). It would
be easy to design a 3-argument version of loop, say <code data-lang="pyret" class="sourceCode">loop-3</code>, but
we could also have a more general solution, using a tuple:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data LoopStatus:
  | done(v)
  | nextâ€“2(new-x, new-y)
  | next-n(new-t)
end

fun loop-n(f, t):
  r = f(t)
  cases (LoopStatus) r:
    | done(v) =&gt; v
    | next-n(new-t) =&gt; loop-n(f, new-t)
  end
end</code></pre><p>where <code data-lang="pyret" class="sourceCode">t</code> is a tuple.</p><p>So now we can rewrite <code data-lang="pyret" class="sourceCode">pr</code>. Letâ€™s first rename the old <code data-lang="pyret" class="sourceCode">pr</code>
function as <code data-lang="pyret" class="sourceCode">pr-old</code> so we can keep it around for testing. Now we
can define a â€œloopâ€-based <code data-lang="pyret" class="sourceCode">pr</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pr(n):
  fun g(x): num-modulo((x * x) + 1, n) end
  for loop-n({x; y; d} from {2; 2; 1}):
    new-x = g(x)
    new-y = g(g(y))
    new-d = gcd(num-abs(new-x - new-y), n)
    ask:
      | new-d == 1 then:
        next-n({new-x; new-y; new-d})
      | new-d == n then:
        done(none)
      | otherwise:
        done(some(new-d))
    end
  end
end</code></pre><p>Indeed, we can test that the two behave in exactly the same way:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  ns = range(2, 100)
  l1 = map(pr-old, ns)
  l2 = map(pr, ns)
  l1 is l2
end</code></pre></section><section class="SsectionLevel3" id="section 26.6"><h3 class="heading">26.6Â <a name="(part._.Nested_.Loops)"/>Nested Loops<a href="#(part._.Nested_.Loops)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>We can also write a nested loop this way. Suppose we have a list like
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lol = [list: [list: 1, 2], [list: 3], [list:], [list: 4, 5, 6]]</code></pre><p>and we want to sum the whole thing by summing each sub-list. Here it is:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for loop-2(ll from lol, sum from 0):
  cases (List) ll:
    | empty =&gt; done(sum)
    | link(l, rl) =&gt;
      l-sum =
        for loop-2(es from l, sub-sum from 0):
          cases (List) es:
            | empty =&gt; done(sub-sum)
            | link(e, r) =&gt; next-2(r, e + sub-sum)
          end
        end
      next-2(rl, sum + l-sum)
  end
end</code></pre><p>We can simplify this by writing it as two functions:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-a-lon(lon :: List&lt;Number&gt;):
  for loop-2(es from lon, sum from 0):
    cases (List) es:
      | empty =&gt; done(sum)
      | link(e, r) =&gt;
        next-2(r, e + sum)
    end
  end
end

fun sum-a-lolon(lolon :: List&lt;List&lt;Number&gt;&gt;):
  for loop-2(l from lolon, sum from 0):
    cases (List) l:
      | empty =&gt; done(sum)
      | link(lon, r) =&gt;
        next-2(r, sum-a-lon(lon) + sum)
    end
  end
end

check:
  sum-a-lolon(lol) is 21
end</code></pre><p>Notice that the two functions are remarkably similar. This suggests an abstraction:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-a-list(f, L):
  for loop-2(e from L, sum from 0):
    cases (List) e:
      | empty =&gt; done(sum)
      | link(elt, r) =&gt;
        next-2(r, f(elt) + sum)
    end
  end
end</code></pre><p>Using this, we can rewrite the two previous functions as:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-a-lon(lon :: List&lt;Number&gt;):
  sum-a-list({(e): e}, lon)
end

fun sum-a-lolon(lolon :: List&lt;List&lt;Number&gt;&gt;):
  sum-a-list(sum-a-lon, lolon)
end

check:
  sum-a-lolon(lol) is 21
end</code></pre><p>With the annotations, it becomes clear what each function does. In
<code data-lang="pyret" class="sourceCode">sum-a-lon</code>, each element is a number, so it â€œcontributes
itselfâ€ to the overall sum. In <code data-lang="pyret" class="sourceCode">sum-a-lolon</code>, each element is a
list of numbers, so it â€œcontributes its <code data-lang="pyret" class="sourceCode">sum-a-lon</code>â€ to the
overall sum.</p><p>Finally, to bring this full circle, we can rewrite the above the
functions as follows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-a-lon(lon :: List&lt;Number&gt;):
  for sum-a-list(e :: Number from lon): e end
end

fun sum-a-lolon(lolon :: List&lt;List&lt;Number&gt;&gt;):
  for sum-a-list(l :: List&lt;Number&gt; from lolon): sum-a-lon(l) end
end</code></pre><p>Arguably this makes even clearer what each element contributes. In
<code data-lang="pyret" class="sourceCode">sum-a-lon</code> each element is a number, so it contributes just that
number. In <code data-lang="pyret" class="sourceCode">sum-a-lolon</code>, each element is a list of numbers, so
it must contribute <code data-lang="pyret" class="sourceCode">sum-a-lon</code> of that list.</p></section><section class="SsectionLevel3" id="section 26.7"><h3 class="heading">26.7Â <a name="(part._.Loops__.Values__and_.Customization)"/>Loops, Values, and Customization<a href="#(part._.Loops__.Values__and_.Customization)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Observe two important ways in which the loops above differ from
traditional loops:
</p><ol><li><p>Every loop produces a value. This is consistent with the rest of
the language, whereâ€”<wbr/>as much as possibleâ€”<wbr/>computations try to
produce answers. We donâ€™t have to produce a value; for
instance, the following program, reminiscent of looping programs in
many other languages, will work just fine in Pyret:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each(i from range(0, 10)): print(i) end</code></pre><p>However, this is the unusual case. In general, we want expressions to
produce values so that we can compose them together.</p></li><li><p>Many languages have strong opinions on exactly how many looping
constructs there should be: two? three? four? In Pyret, there are no
built-in looping constructs at all; thereâ€™s just a syntax (<code data-lang="pyret" class="sourceCode">for</code>)
that serves as a proxy for creating a specific <code data-lang="pyret" class="sourceCode">lam</code>. With it, we
can reuse existing iterative functions (like <code data-lang="pyret" class="sourceCode">map</code> and
<code data-lang="pyret" class="sourceCode">filter</code>), but also define new ones. Some can be very generic,
like <code data-lang="pyret" class="sourceCode">loop-2</code> or <code data-lang="pyret" class="sourceCode">loop-n</code>, but others can be very specific,
like <code data-lang="pyret" class="sourceCode">sum-a-list</code>. The language designers donâ€™t prevent you from
writing a loop that is useful to your situation, and sometimes the
loop can be very expressive, as we see from rewriting <code data-lang="pyret" class="sourceCode">sum-a-lon</code>
and <code data-lang="pyret" class="sourceCode">sum-a-lolon</code> atop <code data-lang="pyret" class="sourceCode">for</code> and <code data-lang="pyret" class="sourceCode">sum-a-list</code>.</p></li></ol></section>&#13;
<h3 class="heading">26.1Â <a name="(part._.Setup__.Two_.Functions)"/>Setup: Two Functions<a href="#(part._.Setup__.Two_.Functions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Letâ€™s look at two functions we wrote earlier in <a href="factoring-numbers.html" data-pltdoc="x">Factoring Numbers</a>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun gcd(a, b):
  if b == 0:
    a
  else:
    gcd(b, num-modulo(a, b))
  end
end

fun pr(n):
  fun g(x): num-modulo((x * x) + 1, n) end
  fun iter(x, y, d):
    new-x = g(x)
    new-y = g(g(y))
    new-d = gcd(num-abs(new-x - new-y), n)
    ask:
      | new-d == 1 then:
        iter(new-x, new-y, new-d)
      | new-d == n then:
        none
      | otherwise:
        some(new-d)
    end
  end
  iter(2, 2, 1)
end</code></pre><p>Weâ€™ve written both recursively: <code data-lang="pyret" class="sourceCode">gcd</code> by calling itself and
<code data-lang="pyret" class="sourceCode">pr</code> with recursion on its inner function. But if youâ€™ve
programmed before, youâ€™ve probably written similar programs with
loops.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Because we donâ€™t have loops in Pyret, the best we can do is to use a
higher-order function; which ones would you use?</p></blockquote></blockquote><p>But letâ€™s see if we can do something â€œbetterâ€, i.e., get closer to a
traditional-looking program.</p><p>Before we start changing any code, letâ€™s make sure we have some tests
for <code data-lang="pyret" class="sourceCode">gcd</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  gcd(4, 5) is 1
  gcd(5, 7) is 1
  gcd(21, 21) is 21
  gcd(12, 24) is 12
  gcd(12, 9) is 3
end</code></pre>&#13;
<h3 class="heading">26.2Â <a name="(part._.Abstracting_a_.Loop)"/>Abstracting a Loop<a href="#(part._.Abstracting_a_.Loop)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Now letâ€™s think about how we can create a loop. At each iteration, a
loop has a status: whether itâ€™s done or whether it should
continue. Since we have two parameters here, letâ€™s record two
parameters for continuing:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data LoopStatus:
  | done(final-value)
  | next-2(new-arg-1, new-arg-2)
end</code></pre><p>Now we can write a function that does the actual iteration:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun loop-2(f, arg-1, arg-2):
  r = f(arg-1, arg-2)
  cases (LoopStatus) r:
    | done(v) =&gt; v
    | next-2(new-arg-1, new-arg-2) =&gt; loop-2(f, new-arg-1, new-arg-2)
  end
end</code></pre><p>Note that this is completely generic: it has nothing to do with
<code data-lang="pyret" class="sourceCode">gcd</code>. (It is generic in the same way that higher-order functions
like <code data-lang="pyret" class="sourceCode">map</code> and <code data-lang="pyret" class="sourceCode">filter</code> are generic.)  It just repeats if
<code data-lang="pyret" class="sourceCode">f</code> says to repeat, stops if <code data-lang="pyret" class="sourceCode">f</code> says to stop. This is the
essence of a loop.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Observe also that we could, if we wanted, stage [<a href="staging.html" data-pltdoc="x">Staging</a>]
<code data-lang="pyret" class="sourceCode">loop-2</code>, because <code data-lang="pyret" class="sourceCode">f</code> never changes. Rewrite it that way.</p></blockquote></blockquote><p>With <code data-lang="pyret" class="sourceCode">loop-2</code>, we can rewrite <code data-lang="pyret" class="sourceCode">gcd</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun gcd(p, q):
  loop-2(
    {(a, b):
      if b == 0:
        done(a)
      else:
        next-2(b, num-modulo(a, b))
      end},
    p,
    q)
end</code></pre><p>Now it might seem to you we havenâ€™t done anything useful at all. In
fact, this looks like a significant step backward. At least before we
just had simple, clean recursion, the way Euclid intended it. Now we
have a higher-order function and weâ€™re passing it the erstwhile
<code data-lang="pyret" class="sourceCode">gcd</code> code as a function and thereâ€™s this <code data-lang="pyret" class="sourceCode">LoopStatus</code>
datatype andâ€¦everythingâ€™s gotten much more complicated.</p><p>But, not really. The reason we put it in this form is because weâ€™re
about to exploit a feature of Pyret. The <code data-lang="pyret" class="sourceCode">for</code> construct in Pyret
actually rewrites as follows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for F(a from a_i, b from b_i, â€¦): BODY end</code></pre><p>gets rewritten to
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">F({(a, b, â€¦): BODY}, a_i, b_i, â€¦)</code></pre><p>For example, if we write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for map(i from range(0, 10)): i + 1 end</code></pre><p>this becomes
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map({(i): i + 1}, range(0, 10))</code></pre><p>Now you may see why we rewrote <code data-lang="pyret" class="sourceCode">gcd</code>.
Going in reverse, we can rewrite
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">F({(a, b, â€¦): BODY}, a_i, b_i, â€¦)</code></pre><p>as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for F(a from a_i, b from b_i, â€¦): BODY end</code></pre><p>so the function becomes just
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun gcd(p, q):
  for loop-2(a from p, b from q):
    if b == 0:
      done(a)
    else:
      next-2(b, num-modulo(a, b))
    end
  end
end</code></pre><p>and now closely resembles a traditional â€œloopâ€ program.</p>&#13;
<h3 class="heading">26.3Â <a name="(part._.Is_.It_.Really_a_.Loop_)"/>Is It Really a Loop?<a href="#(part._.Is_.It_.Really_a_.Loop_)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>This whole section should be considered an aside for people with more
advanced computing knowledge.</p><p>If you know something about language implementation, you may know that
loops have the property that the iteration does not consume extra
space (beyond what the program already needs), and the repetition
takes place very quickly (a â€œjump instructionâ€). In principle, our
<code data-lang="pyret" class="sourceCode">loop-2</code> function does not have this property: every iteration is
a function call, which is more expensive and builds additional stack
context. However, one or both of these does not actually occur in
practice.</p><p>In terms of space, the recursive call to <code data-lang="pyret" class="sourceCode">loop-2</code> is the
last thing that a call to <code data-lang="pyret" class="sourceCode">loop-2</code> does. Furthermore,
nothing in <code data-lang="pyret" class="sourceCode">loop-2</code> consumes and manipulates the return from that
recursive call. This is therefore called a tail call.
Pyretâ€”<wbr/>like some other languagesâ€”<wbr/>causes tail calls to not
take any extra stack space. In principle, Pyret can also turn some
tail calls into jumps. Therefore, this version has close to the same
performance as a traditional loop.</p>&#13;
<h3 class="heading">26.4Â <a name="(part._.Re-.Examining___struct_traverse-element___procedure____lib_render-cond_rkt_38_12__)"/>Re-Examining <code data-lang="pyret" class="sourceCode">for</code><a href="#(part._.Re-.Examining___struct_traverse-element___procedure____lib_render-cond_rkt_38_12__)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>The definition of <code data-lang="pyret" class="sourceCode">for</code> given above should make you suspicious:
Whereâ€™s the loop?!? In fact, Pyretâ€™s <code data-lang="pyret" class="sourceCode">for</code> does not do any
looping at all: itâ€™s simply a fancy way of writing <code data-lang="pyret" class="sourceCode">lam</code>. Any
â€œloopingâ€ behavior is in the function written after <code data-lang="pyret" class="sourceCode">for</code>. To
see that, letâ€™s use for with a non-looping function.</p><p>Recall that
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for F(a from a_i, b from b_i, â€¦): BODY end</code></pre><p>gets rewritten to
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">F({(a, b, â€¦): BODY}, a_i, b_i, â€¦)</code></pre><p>Thus, suppose we have this function (from <a href="func-as-data.html" data-pltdoc="x">Functions as Data</a>):
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">delta-x = 0.0001
fun d-dx-at(f, x):
  (f(x + delta-x) - f(x)) / delta-x
end</code></pre><p>We can call it like this to get approximately 20:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx-at({(n): n * n}, 10)</code></pre><p>That means we can also call it like this:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for d-dx-at(n from 10): n * n end</code></pre><p>Indeed:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  for d-dx-at(n from 10): n * n end
  is
  d-dx-at({(n): n * n}, 10)
end</code></pre><p>Since <code data-lang="pyret" class="sourceCode">d-dx-at</code> has no iterative behavior, no iteration
occurs. The looping behavior is given entirely by the function
specified after <code data-lang="pyret" class="sourceCode">for</code>, such as <code data-lang="pyret" class="sourceCode">map</code>, <code data-lang="pyret" class="sourceCode">filter</code>, or
<code data-lang="pyret" class="sourceCode">loop-2</code> above.</p>&#13;
<h3 class="heading">26.5Â <a name="(part._.Rewriting_.Pollard-.Rho)"/>Rewriting Pollard-Rho<a href="#(part._.Rewriting_.Pollard-.Rho)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Now letâ€™s tackle Pollard-rho. Notice that itâ€™s a three-parameter
function, so we canâ€™t use the <code data-lang="pyret" class="sourceCode">loop-2</code> we had before: thatâ€™s only
a suitable loop when we have two arguments that change on each
iteration (often the iteration variable and an accumulator). It would
be easy to design a 3-argument version of loop, say <code data-lang="pyret" class="sourceCode">loop-3</code>, but
we could also have a more general solution, using a tuple:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data LoopStatus:
  | done(v)
  | nextâ€“2(new-x, new-y)
  | next-n(new-t)
end

fun loop-n(f, t):
  r = f(t)
  cases (LoopStatus) r:
    | done(v) =&gt; v
    | next-n(new-t) =&gt; loop-n(f, new-t)
  end
end</code></pre><p>where <code data-lang="pyret" class="sourceCode">t</code> is a tuple.</p><p>So now we can rewrite <code data-lang="pyret" class="sourceCode">pr</code>. Letâ€™s first rename the old <code data-lang="pyret" class="sourceCode">pr</code>
function as <code data-lang="pyret" class="sourceCode">pr-old</code> so we can keep it around for testing. Now we
can define a â€œloopâ€-based <code data-lang="pyret" class="sourceCode">pr</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pr(n):
  fun g(x): num-modulo((x * x) + 1, n) end
  for loop-n({x; y; d} from {2; 2; 1}):
    new-x = g(x)
    new-y = g(g(y))
    new-d = gcd(num-abs(new-x - new-y), n)
    ask:
      | new-d == 1 then:
        next-n({new-x; new-y; new-d})
      | new-d == n then:
        done(none)
      | otherwise:
        done(some(new-d))
    end
  end
end</code></pre><p>Indeed, we can test that the two behave in exactly the same way:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  ns = range(2, 100)
  l1 = map(pr-old, ns)
  l2 = map(pr, ns)
  l1 is l2
end</code></pre>&#13;
<h3 class="heading">26.6Â <a name="(part._.Nested_.Loops)"/>Nested Loops<a href="#(part._.Nested_.Loops)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>We can also write a nested loop this way. Suppose we have a list like
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lol = [list: [list: 1, 2], [list: 3], [list:], [list: 4, 5, 6]]</code></pre><p>and we want to sum the whole thing by summing each sub-list. Here it is:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for loop-2(ll from lol, sum from 0):
  cases (List) ll:
    | empty =&gt; done(sum)
    | link(l, rl) =&gt;
      l-sum =
        for loop-2(es from l, sub-sum from 0):
          cases (List) es:
            | empty =&gt; done(sub-sum)
            | link(e, r) =&gt; next-2(r, e + sub-sum)
          end
        end
      next-2(rl, sum + l-sum)
  end
end</code></pre><p>We can simplify this by writing it as two functions:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-a-lon(lon :: List&lt;Number&gt;):
  for loop-2(es from lon, sum from 0):
    cases (List) es:
      | empty =&gt; done(sum)
      | link(e, r) =&gt;
        next-2(r, e + sum)
    end
  end
end

fun sum-a-lolon(lolon :: List&lt;List&lt;Number&gt;&gt;):
  for loop-2(l from lolon, sum from 0):
    cases (List) l:
      | empty =&gt; done(sum)
      | link(lon, r) =&gt;
        next-2(r, sum-a-lon(lon) + sum)
    end
  end
end

check:
  sum-a-lolon(lol) is 21
end</code></pre><p>Notice that the two functions are remarkably similar. This suggests an abstraction:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-a-list(f, L):
  for loop-2(e from L, sum from 0):
    cases (List) e:
      | empty =&gt; done(sum)
      | link(elt, r) =&gt;
        next-2(r, f(elt) + sum)
    end
  end
end</code></pre><p>Using this, we can rewrite the two previous functions as:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-a-lon(lon :: List&lt;Number&gt;):
  sum-a-list({(e): e}, lon)
end

fun sum-a-lolon(lolon :: List&lt;List&lt;Number&gt;&gt;):
  sum-a-list(sum-a-lon, lolon)
end

check:
  sum-a-lolon(lol) is 21
end</code></pre><p>With the annotations, it becomes clear what each function does. In
<code data-lang="pyret" class="sourceCode">sum-a-lon</code>, each element is a number, so it â€œcontributes
itselfâ€ to the overall sum. In <code data-lang="pyret" class="sourceCode">sum-a-lolon</code>, each element is a
list of numbers, so it â€œcontributes its <code data-lang="pyret" class="sourceCode">sum-a-lon</code>â€ to the
overall sum.</p><p>Finally, to bring this full circle, we can rewrite the above the
functions as follows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-a-lon(lon :: List&lt;Number&gt;):
  for sum-a-list(e :: Number from lon): e end
end

fun sum-a-lolon(lolon :: List&lt;List&lt;Number&gt;&gt;):
  for sum-a-list(l :: List&lt;Number&gt; from lolon): sum-a-lon(l) end
end</code></pre><p>Arguably this makes even clearer what each element contributes. In
<code data-lang="pyret" class="sourceCode">sum-a-lon</code> each element is a number, so it contributes just that
number. In <code data-lang="pyret" class="sourceCode">sum-a-lolon</code>, each element is a list of numbers, so
it must contribute <code data-lang="pyret" class="sourceCode">sum-a-lon</code> of that list.</p>&#13;
<h3 class="heading">26.7Â <a name="(part._.Loops__.Values__and_.Customization)"/>Loops, Values, and Customization<a href="#(part._.Loops__.Values__and_.Customization)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Observe two important ways in which the loops above differ from
traditional loops:
</p><ol><li><p>Every loop produces a value. This is consistent with the rest of
the language, whereâ€”<wbr/>as much as possibleâ€”<wbr/>computations try to
produce answers. We donâ€™t have to produce a value; for
instance, the following program, reminiscent of looping programs in
many other languages, will work just fine in Pyret:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each(i from range(0, 10)): print(i) end</code></pre><p>However, this is the unusual case. In general, we want expressions to
produce values so that we can compose them together.</p></li><li><p>Many languages have strong opinions on exactly how many looping
constructs there should be: two? three? four? In Pyret, there are no
built-in looping constructs at all; thereâ€™s just a syntax (<code data-lang="pyret" class="sourceCode">for</code>)
that serves as a proxy for creating a specific <code data-lang="pyret" class="sourceCode">lam</code>. With it, we
can reuse existing iterative functions (like <code data-lang="pyret" class="sourceCode">map</code> and
<code data-lang="pyret" class="sourceCode">filter</code>), but also define new ones. Some can be very generic,
like <code data-lang="pyret" class="sourceCode">loop-2</code> or <code data-lang="pyret" class="sourceCode">loop-n</code>, but others can be very specific,
like <code data-lang="pyret" class="sourceCode">sum-a-list</code>. The language designers donâ€™t prevent you from
writing a loop that is useful to your situation, and sometimes the
loop can be very expressive, as we see from rewriting <code data-lang="pyret" class="sourceCode">sum-a-lon</code>
and <code data-lang="pyret" class="sourceCode">sum-a-lolon</code> atop <code data-lang="pyret" class="sourceCode">for</code> and <code data-lang="pyret" class="sourceCode">sum-a-list</code>.</p></li></ol>    
</body>
</html>