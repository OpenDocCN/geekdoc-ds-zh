<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>26Â Deconstructing LoopsğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>26Â Deconstructing LoopsğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/deconstructing-loops.html">https://dcic-world.org/2025-08-27/deconstructing-loops.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Setup__.Two_.Functions%29" class="toclink" data-pltdoc="x">26.1<span class="hspace">Â </span>Setup: Two Functions</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Abstracting_a_.Loop%29" class="toclink" data-pltdoc="x">26.2<span class="hspace">Â </span>Abstracting a Loop</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Is_.It_.Really_a_.Loop_%29" class="toclink" data-pltdoc="x">26.3<span class="hspace">Â </span>Is It Really a Loop?</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Re-.Examining___struct_traverse-element___procedure____lib_render-cond_rkt_38_12__%29" class="toclink" data-pltdoc="x">26.4<span class="hspace">Â </span>Re-Examining <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for</code></span></a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Rewriting_.Pollard-.Rho%29" class="toclink" data-pltdoc="x">26.5<span class="hspace">Â </span>Rewriting Pollard-Rho</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Nested_.Loops%29" class="toclink" data-pltdoc="x">26.6<span class="hspace">Â </span>Nested Loops</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Loops__.Values__and_.Customization%29" class="toclink" data-pltdoc="x">26.7<span class="hspace">Â </span>Loops, Values, and Customization</a></p></td></tr></table><section class="SsectionLevel3" id="section 26.1"><h3 class="heading">26.1<span class="stt">Â </span><a name="(part._.Setup__.Two_.Functions)"/>Setup: Two Functions<span class="button-group"><a href="#(part._.Setup__.Two_.Functions)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">Letâ€™s look at two functions we wrote earlier in <a href="factoring-numbers.html" data-pltdoc="x">Factoring Numbers</a>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun gcd(a, b):
  if b == 0:
    a
  else:
    gcd(b, num-modulo(a, b))
  end
end

fun pr(n):
  fun g(x): num-modulo((x * x) + 1, n) end
  fun iter(x, y, d):
    new-x = g(x)
    new-y = g(g(y))
    new-d = gcd(num-abs(new-x - new-y), n)
    ask:
      | new-d == 1 then:
        iter(new-x, new-y, new-d)
      | new-d == n then:
        none
      | otherwise:
        some(new-d)
    end
  end
  iter(2, 2, 1)
end</code></pre></div></div></div><div class="SIntrapara">Weâ€™ve written both recursively: <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">gcd</code></span> by calling itself and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pr</code></span> with recursion on its inner function. But if youâ€™ve
programmed before, youâ€™ve probably written similar programs with
<span style="font-style: italic">loops</span>.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Because we donâ€™t have loops in Pyret, the best we can do is to use a
higher-order function; which ones would you use?</p></blockquote></blockquote><p>But letâ€™s see if we can do something â€œbetterâ€, i.e., get closer to a
traditional-looking program.</p><p/><div class="SIntrapara">Before we start changing any code, letâ€™s make sure we have some tests
for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">gcd</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  gcd(4, 5) is 1
  gcd(5, 7) is 1
  gcd(21, 21) is 21
  gcd(12, 24) is 12
  gcd(12, 9) is 3
end</code></pre></div></div></div></section><section class="SsectionLevel3" id="section 26.2"><h3 class="heading">26.2<span class="stt">Â </span><a name="(part._.Abstracting_a_.Loop)"/>Abstracting a Loop<span class="button-group"><a href="#(part._.Abstracting_a_.Loop)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">Now letâ€™s think about how we can create a loop. At each iteration, a
loop has a <span class="emph">status</span>: whether itâ€™s done or whether it should
continue. Since we have two parameters here, letâ€™s record two
parameters for continuing:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data LoopStatus:
  | done(final-value)
  | next-2(new-arg-1, new-arg-2)
end</code></pre></div></div></div><div class="SIntrapara">Now we can write a function that does the actual iteration:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun loop-2(f, arg-1, arg-2):
  r = f(arg-1, arg-2)
  cases (LoopStatus) r:
    | done(v) =&gt; v
    | next-2(new-arg-1, new-arg-2) =&gt; loop-2(f, new-arg-1, new-arg-2)
  end
end</code></pre></div></div></div><div class="SIntrapara">Note that this is completely generic: it has nothing to do with
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">gcd</code></span>. (It is generic in the same way that higher-order functions
like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span> are generic.)  It just repeats if
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">f</code></span> says to repeat, stops if <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">f</code></span> says to stop. This is the
essence of a loop.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Observe also that we could, if we wanted, stage [<a href="staging.html" data-pltdoc="x">Staging</a>]
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">loop-2</code></span>, because <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">f</code></span> never changes. Rewrite it that way.</p></blockquote></blockquote><p/><div class="SIntrapara">With <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">loop-2</code></span>, we can rewrite <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">gcd</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun gcd(p, q):
  loop-2(
    {(a, b):
      if b == 0:
        done(a)
      else:
        next-2(b, num-modulo(a, b))
      end},
    p,
    q)
end</code></pre></div></div></div><div class="SIntrapara">Now it might seem to you we havenâ€™t done anything useful at all. In
fact, this looks like a significant step backward. At least before we
just had simple, clean recursion, the way Euclid intended it. Now we
have a higher-order function and weâ€™re passing it the erstwhile
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">gcd</code></span> code as a function and thereâ€™s this <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">LoopStatus</code></span>
datatype andâ€¦everythingâ€™s gotten much more complicated.</div><p/><div class="SIntrapara">But, not really. The reason we put it in this form is because weâ€™re
about to exploit a feature of Pyret. The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for</code></span> construct in Pyret
actually rewrites as follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for F(a from a_i, b from b_i, â€¦): BODY end</code></pre></div></div></div><div class="SIntrapara">gets rewritten to
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">F({(a, b, â€¦): BODY}, a_i, b_i, â€¦)</code></pre></div></div></div><div class="SIntrapara">For example, if we write
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for map(i from range(0, 10)): i + 1 end</code></pre></div></div></div><div class="SIntrapara">this becomes
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map({(i): i + 1}, range(0, 10))</code></pre></div></div></div><p/><div class="SIntrapara">Now you may see why we rewrote <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">gcd</code></span>.
Going in reverse, we can rewrite
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">F({(a, b, â€¦): BODY}, a_i, b_i, â€¦)</code></pre></div></div></div><div class="SIntrapara">as
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for F(a from a_i, b from b_i, â€¦): BODY end</code></pre></div></div></div><div class="SIntrapara">so the function becomes just
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun gcd(p, q):
  for loop-2(a from p, b from q):
    if b == 0:
      done(a)
    else:
      next-2(b, num-modulo(a, b))
    end
  end
end</code></pre></div></div></div><div class="SIntrapara">and now closely resembles a traditional â€œloopâ€ program.</div></section><section class="SsectionLevel3" id="section 26.3"><h3 class="heading">26.3<span class="stt">Â </span><a name="(part._.Is_.It_.Really_a_.Loop_)"/>Is It Really a Loop?<span class="button-group"><a href="#(part._.Is_.It_.Really_a_.Loop_)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>This whole section should be considered an aside for people with more
advanced computing knowledge.</p><p>If you know something about language implementation, you may know that
loops have the property that the iteration does not consume extra
space (beyond what the program already needs), and the repetition
takes place very quickly (a â€œjump instructionâ€). In principle, our
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">loop-2</code></span> function does not have this property: every iteration is
a function call, which is more expensive and builds additional stack
context. However, one or both of these does not actually occur in
practice.</p><p>In terms of space, the recursive call to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">loop-2</code></span> is the
<span class="emph">last</span> thing that a call to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">loop-2</code></span> does. Furthermore,
nothing in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">loop-2</code></span> consumes and manipulates the return from that
recursive call. This is therefore called a <span style="font-style: italic">tail call</span>.
Pyretâ€”<wbr/>like some other languagesâ€”<wbr/>causes tail calls to not
take any extra stack space. In principle, Pyret can also turn some
tail calls into jumps. Therefore, this version has close to the same
performance as a traditional loop.</p></section><section class="SsectionLevel3" id="section 26.4"><h3 class="heading">26.4<span class="stt">Â </span><a name="(part._.Re-.Examining___struct_traverse-element___procedure____lib_render-cond_rkt_38_12__)"/>Re-Examining <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for</code></span><span class="button-group"><a href="#(part._.Re-.Examining___struct_traverse-element___procedure____lib_render-cond_rkt_38_12__)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>The definition of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for</code></span> given above should make you suspicious:
<span class="emph">Whereâ€™s the loop?!?</span> In fact, Pyretâ€™s <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for</code></span> does not do any
looping at all: itâ€™s simply a fancy way of writing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span>. Any
â€œloopingâ€ behavior is in the function written after <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for</code></span>. To
see that, letâ€™s use for with a non-looping function.</p><p/><div class="SIntrapara">Recall that
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for F(a from a_i, b from b_i, â€¦): BODY end</code></pre></div></div></div><div class="SIntrapara">gets rewritten to
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">F({(a, b, â€¦): BODY}, a_i, b_i, â€¦)</code></pre></div></div></div><div class="SIntrapara">Thus, suppose we have this function (from <a href="func-as-data.html" data-pltdoc="x">Functions as Data</a>):
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">delta-x = 0.0001
fun d-dx-at(f, x):
  (f(x + delta-x) - f(x)) / delta-x
end</code></pre></div></div></div><div class="SIntrapara">We can call it like this to get approximately 20:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx-at({(n): n * n}, 10)</code></pre></div></div></div><div class="SIntrapara">That means we can also call it like this:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for d-dx-at(n from 10): n * n end</code></pre></div></div></div><div class="SIntrapara">Indeed:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  for d-dx-at(n from 10): n * n end
  is
  d-dx-at({(n): n * n}, 10)
end</code></pre></div></div></div><div class="SIntrapara">Since <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx-at</code></span> has no iterative behavior, no iteration
occurs. The <span class="emph">looping</span> behavior is given entirely by the function
specified after <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for</code></span>, such as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>, or
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">loop-2</code></span> above.</div></section><section class="SsectionLevel3" id="section 26.5"><h3 class="heading">26.5<span class="stt">Â </span><a name="(part._.Rewriting_.Pollard-.Rho)"/>Rewriting Pollard-Rho<span class="button-group"><a href="#(part._.Rewriting_.Pollard-.Rho)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">Now letâ€™s tackle Pollard-rho. Notice that itâ€™s a three-parameter
function, so we canâ€™t use the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">loop-2</code></span> we had before: thatâ€™s only
a suitable loop when we have two arguments that change on each
iteration (often the iteration variable and an accumulator). It would
be easy to design a 3-argument version of loop, say <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">loop-3</code></span>, but
we could also have a more general solution, using a tuple:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data LoopStatus:
  | done(v)
  | nextâ€“2(new-x, new-y)
  | next-n(new-t)
end

fun loop-n(f, t):
  r = f(t)
  cases (LoopStatus) r:
    | done(v) =&gt; v
    | next-n(new-t) =&gt; loop-n(f, new-t)
  end
end</code></pre></div></div></div><div class="SIntrapara">where <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">t</code></span> is a tuple.</div><p/><div class="SIntrapara">So now we can rewrite <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pr</code></span>. Letâ€™s first rename the old <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pr</code></span>
function as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pr-old</code></span> so we can keep it around for testing. Now we
can define a â€œloopâ€-based <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pr</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pr(n):
  fun g(x): num-modulo((x * x) + 1, n) end
  for loop-n({x; y; d} from {2; 2; 1}):
    new-x = g(x)
    new-y = g(g(y))
    new-d = gcd(num-abs(new-x - new-y), n)
    ask:
      | new-d == 1 then:
        next-n({new-x; new-y; new-d})
      | new-d == n then:
        done(none)
      | otherwise:
        done(some(new-d))
    end
  end
end</code></pre></div></div></div><div class="SIntrapara">Indeed, we can test that the two behave in exactly the same way:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  ns = range(2, 100)
  l1 = map(pr-old, ns)
  l2 = map(pr, ns)
  l1 is l2
end</code></pre></div></div></div></section><section class="SsectionLevel3" id="section 26.6"><h3 class="heading">26.6<span class="stt">Â </span><a name="(part._.Nested_.Loops)"/>Nested Loops<span class="button-group"><a href="#(part._.Nested_.Loops)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">We can also write a nested loop this way. Suppose we have a list like
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lol = [list: [list: 1, 2], [list: 3], [list:], [list: 4, 5, 6]]</code></pre></div></div></div><div class="SIntrapara">and we want to sum the whole thing by summing each sub-list. Here it is:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for loop-2(ll from lol, sum from 0):
  cases (List) ll:
    | empty =&gt; done(sum)
    | link(l, rl) =&gt;
      l-sum =
        for loop-2(es from l, sub-sum from 0):
          cases (List) es:
            | empty =&gt; done(sub-sum)
            | link(e, r) =&gt; next-2(r, e + sub-sum)
          end
        end
      next-2(rl, sum + l-sum)
  end
end</code></pre></div></div></div><div class="SIntrapara">We can simplify this by writing it as two functions:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-a-lon(lon :: List&lt;Number&gt;):
  for loop-2(es from lon, sum from 0):
    cases (List) es:
      | empty =&gt; done(sum)
      | link(e, r) =&gt;
        next-2(r, e + sum)
    end
  end
end

fun sum-a-lolon(lolon :: List&lt;List&lt;Number&gt;&gt;):
  for loop-2(l from lolon, sum from 0):
    cases (List) l:
      | empty =&gt; done(sum)
      | link(lon, r) =&gt;
        next-2(r, sum-a-lon(lon) + sum)
    end
  end
end

check:
  sum-a-lolon(lol) is 21
end</code></pre></div></div></div><p/><div class="SIntrapara">Notice that the two functions are remarkably similar. This suggests an abstraction:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-a-list(f, L):
  for loop-2(e from L, sum from 0):
    cases (List) e:
      | empty =&gt; done(sum)
      | link(elt, r) =&gt;
        next-2(r, f(elt) + sum)
    end
  end
end</code></pre></div></div></div><div class="SIntrapara">Using this, we can rewrite the two previous functions as:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-a-lon(lon :: List&lt;Number&gt;):
  sum-a-list({(e): e}, lon)
end

fun sum-a-lolon(lolon :: List&lt;List&lt;Number&gt;&gt;):
  sum-a-list(sum-a-lon, lolon)
end

check:
  sum-a-lolon(lol) is 21
end</code></pre></div></div></div><div class="SIntrapara">With the annotations, it becomes clear what each function does. In
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum-a-lon</code></span>, each element is a number, so it â€œcontributes
itselfâ€ to the overall sum. In <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum-a-lolon</code></span>, each element is a
list of numbers, so it â€œcontributes its <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum-a-lon</code></span>â€ to the
overall sum.</div><p/><div class="SIntrapara">Finally, to bring this full circle, we can rewrite the above the
functions as follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-a-lon(lon :: List&lt;Number&gt;):
  for sum-a-list(e :: Number from lon): e end
end

fun sum-a-lolon(lolon :: List&lt;List&lt;Number&gt;&gt;):
  for sum-a-list(l :: List&lt;Number&gt; from lolon): sum-a-lon(l) end
end</code></pre></div></div></div><p>Arguably this makes even clearer what each element contributes. In
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum-a-lon</code></span> each element is a number, so it contributes just that
number. In <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum-a-lolon</code></span>, each element is a list of numbers, so
it must contribute <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum-a-lon</code></span> of that list.</p></section><section class="SsectionLevel3" id="section 26.7"><h3 class="heading">26.7<span class="stt">Â </span><a name="(part._.Loops__.Values__and_.Customization)"/>Loops, Values, and Customization<span class="button-group"><a href="#(part._.Loops__.Values__and_.Customization)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">Observe two important ways in which the loops above differ from
traditional loops:
</div><div class="SIntrapara"><ol><li><p/><div class="SIntrapara">Every loop produces a value. This is consistent with the rest of
the language, whereâ€”<wbr/>as much as possibleâ€”<wbr/>computations try to
produce answers. We donâ€™t <span class="emph">have</span> to produce a value; for
instance, the following program, reminiscent of looping programs in
many other languages, will work just fine in Pyret:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each(i from range(0, 10)): print(i) end</code></pre></div></div></div><div class="SIntrapara">However, this is the unusual case. In general, we want expressions to
produce values so that we can compose them together.</div></li><li><p>Many languages have strong opinions on exactly how many looping
constructs there should be: two? three? four? In Pyret, there are no
built-in looping constructs at all; thereâ€™s just a syntax (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for</code></span>)
that serves as a proxy for creating a specific <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span>. With it, we
can reuse existing iterative functions (like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>), but also define new ones. Some can be very generic,
like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">loop-2</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">loop-n</code></span>, but others can be very specific,
like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum-a-list</code></span>. The language designers donâ€™t prevent you from
writing a loop that is useful to your situation, and sometimes the
loop can be very expressive, as we see from rewriting <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum-a-lon</code></span>
and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum-a-lolon</code></span> atop <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum-a-list</code></span>.</p></li></ol></div></section>&#13;
<h3 class="heading">26.1<span class="stt">Â </span><a name="(part._.Setup__.Two_.Functions)"/>Setup: Two Functions<span class="button-group"><a href="#(part._.Setup__.Two_.Functions)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">Letâ€™s look at two functions we wrote earlier in <a href="factoring-numbers.html" data-pltdoc="x">Factoring Numbers</a>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun gcd(a, b):
  if b == 0:
    a
  else:
    gcd(b, num-modulo(a, b))
  end
end

fun pr(n):
  fun g(x): num-modulo((x * x) + 1, n) end
  fun iter(x, y, d):
    new-x = g(x)
    new-y = g(g(y))
    new-d = gcd(num-abs(new-x - new-y), n)
    ask:
      | new-d == 1 then:
        iter(new-x, new-y, new-d)
      | new-d == n then:
        none
      | otherwise:
        some(new-d)
    end
  end
  iter(2, 2, 1)
end</code></pre></div></div></div><div class="SIntrapara">Weâ€™ve written both recursively: <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">gcd</code></span> by calling itself and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pr</code></span> with recursion on its inner function. But if youâ€™ve
programmed before, youâ€™ve probably written similar programs with
<span style="font-style: italic">loops</span>.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Because we donâ€™t have loops in Pyret, the best we can do is to use a
higher-order function; which ones would you use?</p></blockquote></blockquote><p>But letâ€™s see if we can do something â€œbetterâ€, i.e., get closer to a
traditional-looking program.</p><p/><div class="SIntrapara">Before we start changing any code, letâ€™s make sure we have some tests
for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">gcd</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  gcd(4, 5) is 1
  gcd(5, 7) is 1
  gcd(21, 21) is 21
  gcd(12, 24) is 12
  gcd(12, 9) is 3
end</code></pre></div></div></div>&#13;
<h3 class="heading">26.2<span class="stt">Â </span><a name="(part._.Abstracting_a_.Loop)"/>Abstracting a Loop<span class="button-group"><a href="#(part._.Abstracting_a_.Loop)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">Now letâ€™s think about how we can create a loop. At each iteration, a
loop has a <span class="emph">status</span>: whether itâ€™s done or whether it should
continue. Since we have two parameters here, letâ€™s record two
parameters for continuing:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data LoopStatus:
  | done(final-value)
  | next-2(new-arg-1, new-arg-2)
end</code></pre></div></div></div><div class="SIntrapara">Now we can write a function that does the actual iteration:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun loop-2(f, arg-1, arg-2):
  r = f(arg-1, arg-2)
  cases (LoopStatus) r:
    | done(v) =&gt; v
    | next-2(new-arg-1, new-arg-2) =&gt; loop-2(f, new-arg-1, new-arg-2)
  end
end</code></pre></div></div></div><div class="SIntrapara">Note that this is completely generic: it has nothing to do with
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">gcd</code></span>. (It is generic in the same way that higher-order functions
like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span> are generic.)  It just repeats if
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">f</code></span> says to repeat, stops if <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">f</code></span> says to stop. This is the
essence of a loop.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Observe also that we could, if we wanted, stage [<a href="staging.html" data-pltdoc="x">Staging</a>]
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">loop-2</code></span>, because <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">f</code></span> never changes. Rewrite it that way.</p></blockquote></blockquote><p/><div class="SIntrapara">With <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">loop-2</code></span>, we can rewrite <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">gcd</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun gcd(p, q):
  loop-2(
    {(a, b):
      if b == 0:
        done(a)
      else:
        next-2(b, num-modulo(a, b))
      end},
    p,
    q)
end</code></pre></div></div></div><div class="SIntrapara">Now it might seem to you we havenâ€™t done anything useful at all. In
fact, this looks like a significant step backward. At least before we
just had simple, clean recursion, the way Euclid intended it. Now we
have a higher-order function and weâ€™re passing it the erstwhile
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">gcd</code></span> code as a function and thereâ€™s this <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">LoopStatus</code></span>
datatype andâ€¦everythingâ€™s gotten much more complicated.</div><p/><div class="SIntrapara">But, not really. The reason we put it in this form is because weâ€™re
about to exploit a feature of Pyret. The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for</code></span> construct in Pyret
actually rewrites as follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for F(a from a_i, b from b_i, â€¦): BODY end</code></pre></div></div></div><div class="SIntrapara">gets rewritten to
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">F({(a, b, â€¦): BODY}, a_i, b_i, â€¦)</code></pre></div></div></div><div class="SIntrapara">For example, if we write
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for map(i from range(0, 10)): i + 1 end</code></pre></div></div></div><div class="SIntrapara">this becomes
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map({(i): i + 1}, range(0, 10))</code></pre></div></div></div><p/><div class="SIntrapara">Now you may see why we rewrote <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">gcd</code></span>.
Going in reverse, we can rewrite
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">F({(a, b, â€¦): BODY}, a_i, b_i, â€¦)</code></pre></div></div></div><div class="SIntrapara">as
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for F(a from a_i, b from b_i, â€¦): BODY end</code></pre></div></div></div><div class="SIntrapara">so the function becomes just
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun gcd(p, q):
  for loop-2(a from p, b from q):
    if b == 0:
      done(a)
    else:
      next-2(b, num-modulo(a, b))
    end
  end
end</code></pre></div></div></div><div class="SIntrapara">and now closely resembles a traditional â€œloopâ€ program.</div>&#13;
<h3 class="heading">26.3<span class="stt">Â </span><a name="(part._.Is_.It_.Really_a_.Loop_)"/>Is It Really a Loop?<span class="button-group"><a href="#(part._.Is_.It_.Really_a_.Loop_)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>This whole section should be considered an aside for people with more
advanced computing knowledge.</p><p>If you know something about language implementation, you may know that
loops have the property that the iteration does not consume extra
space (beyond what the program already needs), and the repetition
takes place very quickly (a â€œjump instructionâ€). In principle, our
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">loop-2</code></span> function does not have this property: every iteration is
a function call, which is more expensive and builds additional stack
context. However, one or both of these does not actually occur in
practice.</p><p>In terms of space, the recursive call to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">loop-2</code></span> is the
<span class="emph">last</span> thing that a call to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">loop-2</code></span> does. Furthermore,
nothing in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">loop-2</code></span> consumes and manipulates the return from that
recursive call. This is therefore called a <span style="font-style: italic">tail call</span>.
Pyretâ€”<wbr/>like some other languagesâ€”<wbr/>causes tail calls to not
take any extra stack space. In principle, Pyret can also turn some
tail calls into jumps. Therefore, this version has close to the same
performance as a traditional loop.</p>&#13;
<h3 class="heading">26.4<span class="stt">Â </span><a name="(part._.Re-.Examining___struct_traverse-element___procedure____lib_render-cond_rkt_38_12__)"/>Re-Examining <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for</code></span><span class="button-group"><a href="#(part._.Re-.Examining___struct_traverse-element___procedure____lib_render-cond_rkt_38_12__)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>The definition of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for</code></span> given above should make you suspicious:
<span class="emph">Whereâ€™s the loop?!?</span> In fact, Pyretâ€™s <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for</code></span> does not do any
looping at all: itâ€™s simply a fancy way of writing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span>. Any
â€œloopingâ€ behavior is in the function written after <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for</code></span>. To
see that, letâ€™s use for with a non-looping function.</p><p/><div class="SIntrapara">Recall that
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for F(a from a_i, b from b_i, â€¦): BODY end</code></pre></div></div></div><div class="SIntrapara">gets rewritten to
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">F({(a, b, â€¦): BODY}, a_i, b_i, â€¦)</code></pre></div></div></div><div class="SIntrapara">Thus, suppose we have this function (from <a href="func-as-data.html" data-pltdoc="x">Functions as Data</a>):
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">delta-x = 0.0001
fun d-dx-at(f, x):
  (f(x + delta-x) - f(x)) / delta-x
end</code></pre></div></div></div><div class="SIntrapara">We can call it like this to get approximately 20:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx-at({(n): n * n}, 10)</code></pre></div></div></div><div class="SIntrapara">That means we can also call it like this:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for d-dx-at(n from 10): n * n end</code></pre></div></div></div><div class="SIntrapara">Indeed:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  for d-dx-at(n from 10): n * n end
  is
  d-dx-at({(n): n * n}, 10)
end</code></pre></div></div></div><div class="SIntrapara">Since <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d-dx-at</code></span> has no iterative behavior, no iteration
occurs. The <span class="emph">looping</span> behavior is given entirely by the function
specified after <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for</code></span>, such as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>, or
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">loop-2</code></span> above.</div>&#13;
<h3 class="heading">26.5<span class="stt">Â </span><a name="(part._.Rewriting_.Pollard-.Rho)"/>Rewriting Pollard-Rho<span class="button-group"><a href="#(part._.Rewriting_.Pollard-.Rho)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">Now letâ€™s tackle Pollard-rho. Notice that itâ€™s a three-parameter
function, so we canâ€™t use the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">loop-2</code></span> we had before: thatâ€™s only
a suitable loop when we have two arguments that change on each
iteration (often the iteration variable and an accumulator). It would
be easy to design a 3-argument version of loop, say <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">loop-3</code></span>, but
we could also have a more general solution, using a tuple:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data LoopStatus:
  | done(v)
  | nextâ€“2(new-x, new-y)
  | next-n(new-t)
end

fun loop-n(f, t):
  r = f(t)
  cases (LoopStatus) r:
    | done(v) =&gt; v
    | next-n(new-t) =&gt; loop-n(f, new-t)
  end
end</code></pre></div></div></div><div class="SIntrapara">where <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">t</code></span> is a tuple.</div><p/><div class="SIntrapara">So now we can rewrite <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pr</code></span>. Letâ€™s first rename the old <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pr</code></span>
function as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pr-old</code></span> so we can keep it around for testing. Now we
can define a â€œloopâ€-based <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pr</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pr(n):
  fun g(x): num-modulo((x * x) + 1, n) end
  for loop-n({x; y; d} from {2; 2; 1}):
    new-x = g(x)
    new-y = g(g(y))
    new-d = gcd(num-abs(new-x - new-y), n)
    ask:
      | new-d == 1 then:
        next-n({new-x; new-y; new-d})
      | new-d == n then:
        done(none)
      | otherwise:
        done(some(new-d))
    end
  end
end</code></pre></div></div></div><div class="SIntrapara">Indeed, we can test that the two behave in exactly the same way:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  ns = range(2, 100)
  l1 = map(pr-old, ns)
  l2 = map(pr, ns)
  l1 is l2
end</code></pre></div></div></div>&#13;
<h3 class="heading">26.6<span class="stt">Â </span><a name="(part._.Nested_.Loops)"/>Nested Loops<span class="button-group"><a href="#(part._.Nested_.Loops)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">We can also write a nested loop this way. Suppose we have a list like
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lol = [list: [list: 1, 2], [list: 3], [list:], [list: 4, 5, 6]]</code></pre></div></div></div><div class="SIntrapara">and we want to sum the whole thing by summing each sub-list. Here it is:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for loop-2(ll from lol, sum from 0):
  cases (List) ll:
    | empty =&gt; done(sum)
    | link(l, rl) =&gt;
      l-sum =
        for loop-2(es from l, sub-sum from 0):
          cases (List) es:
            | empty =&gt; done(sub-sum)
            | link(e, r) =&gt; next-2(r, e + sub-sum)
          end
        end
      next-2(rl, sum + l-sum)
  end
end</code></pre></div></div></div><div class="SIntrapara">We can simplify this by writing it as two functions:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-a-lon(lon :: List&lt;Number&gt;):
  for loop-2(es from lon, sum from 0):
    cases (List) es:
      | empty =&gt; done(sum)
      | link(e, r) =&gt;
        next-2(r, e + sum)
    end
  end
end

fun sum-a-lolon(lolon :: List&lt;List&lt;Number&gt;&gt;):
  for loop-2(l from lolon, sum from 0):
    cases (List) l:
      | empty =&gt; done(sum)
      | link(lon, r) =&gt;
        next-2(r, sum-a-lon(lon) + sum)
    end
  end
end

check:
  sum-a-lolon(lol) is 21
end</code></pre></div></div></div><p/><div class="SIntrapara">Notice that the two functions are remarkably similar. This suggests an abstraction:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-a-list(f, L):
  for loop-2(e from L, sum from 0):
    cases (List) e:
      | empty =&gt; done(sum)
      | link(elt, r) =&gt;
        next-2(r, f(elt) + sum)
    end
  end
end</code></pre></div></div></div><div class="SIntrapara">Using this, we can rewrite the two previous functions as:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-a-lon(lon :: List&lt;Number&gt;):
  sum-a-list({(e): e}, lon)
end

fun sum-a-lolon(lolon :: List&lt;List&lt;Number&gt;&gt;):
  sum-a-list(sum-a-lon, lolon)
end

check:
  sum-a-lolon(lol) is 21
end</code></pre></div></div></div><div class="SIntrapara">With the annotations, it becomes clear what each function does. In
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum-a-lon</code></span>, each element is a number, so it â€œcontributes
itselfâ€ to the overall sum. In <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum-a-lolon</code></span>, each element is a
list of numbers, so it â€œcontributes its <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum-a-lon</code></span>â€ to the
overall sum.</div><p/><div class="SIntrapara">Finally, to bring this full circle, we can rewrite the above the
functions as follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-a-lon(lon :: List&lt;Number&gt;):
  for sum-a-list(e :: Number from lon): e end
end

fun sum-a-lolon(lolon :: List&lt;List&lt;Number&gt;&gt;):
  for sum-a-list(l :: List&lt;Number&gt; from lolon): sum-a-lon(l) end
end</code></pre></div></div></div><p>Arguably this makes even clearer what each element contributes. In
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum-a-lon</code></span> each element is a number, so it contributes just that
number. In <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum-a-lolon</code></span>, each element is a list of numbers, so
it must contribute <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum-a-lon</code></span> of that list.</p>&#13;
<h3 class="heading">26.7<span class="stt">Â </span><a name="(part._.Loops__.Values__and_.Customization)"/>Loops, Values, and Customization<span class="button-group"><a href="#(part._.Loops__.Values__and_.Customization)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">Observe two important ways in which the loops above differ from
traditional loops:
</div><div class="SIntrapara"><ol><li><p/><div class="SIntrapara">Every loop produces a value. This is consistent with the rest of
the language, whereâ€”<wbr/>as much as possibleâ€”<wbr/>computations try to
produce answers. We donâ€™t <span class="emph">have</span> to produce a value; for
instance, the following program, reminiscent of looping programs in
many other languages, will work just fine in Pyret:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each(i from range(0, 10)): print(i) end</code></pre></div></div></div><div class="SIntrapara">However, this is the unusual case. In general, we want expressions to
produce values so that we can compose them together.</div></li><li><p>Many languages have strong opinions on exactly how many looping
constructs there should be: two? three? four? In Pyret, there are no
built-in looping constructs at all; thereâ€™s just a syntax (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for</code></span>)
that serves as a proxy for creating a specific <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span>. With it, we
can reuse existing iterative functions (like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>), but also define new ones. Some can be very generic,
like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">loop-2</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">loop-n</code></span>, but others can be very specific,
like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum-a-list</code></span>. The language designers donâ€™t prevent you from
writing a loop that is useful to your situation, and sometimes the
loop can be very expressive, as we see from rewriting <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum-a-lon</code></span>
and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum-a-lolon</code></span> atop <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum-a-list</code></span>.</p></li></ol></div>    
</body>
</html>