- en: 'Case Study: Compressing Square'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://phys-sim-book.github.io/lec11.2-compress_square.html](https://phys-sim-book.github.io/lec11.2-compress_square.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  prefs: []
  type: TYPE_NORMAL
- en: We simulate compressing an elastic square using a ceiling. The excutable Python
    project for this section can be found at [https://github.com/phys-sim-book/solid-sim-tutorial](https://github.com/phys-sim-book/solid-sim-tutorial)
    under the `5_mov_dirichlet` folder. [MUDA](https://github.com/MuGdxy/muda) GPU
    implementations can be found at [https://github.com/phys-sim-book/solid-sim-tutorial-gpu](https://github.com/phys-sim-book/solid-sim-tutorial-gpu)
    under the `simulators/5_mov_dirichlet` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The ceiling in our simulation is modeled as a half-space with a downward normal
    vector n=(0,−1). The distance from the ceiling to other simulated Degrees of Freedom
    (DOFs) can be calculated using Equation [(7.1.1)](lec7.1-signed_dists.html#eq:lec7:half_space_dist).
    To effectively apply the penalty method, it's necessary that the ceiling's height
    also serves as a DOF.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the approach used in the [Square on Slope](lec10-square_on_slope.html)
    project, we choose the origin o on the ceiling as the DOF and incorporate it into
    the variable x:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation 11.2.1 (Ceiling DOF setup, simulator.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The ceiling is initially positioned directly above the elastic square, as shown
    in the left image of [Figure 11.2.1](#fig:lec11:compress_square). By doing so,
    we ensure that the nodal mass of this newly added DOF is consistent with the other
    simulated nodes on the square, as per our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this additional DOF, we can straightforwardly model the contact between
    the ceiling and the square. This is done by enhancing the existing functions that
    compute the barrier energy value, gradient, Hessian, and the initial step size:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation 11.2.2 (Barrier energy value, BarrierEnergy.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Implementation 11.2.3 (Barrier energy gradient, BarrierEnergy.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Implementation 11.2.4 (Barrier energy Hessian, BarrierEnergy.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Implementation 11.2.5 (Initial step size calculation, BarrierEnergy.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here for the distance between the ceiling o and a node x, we have the stacked
    quantities locally: d(x,o)=nT(x−o),∇d(x,o)=[n−n​],∇2d(x,o)=0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we apply the moving BC on the ceiling to compress the elastic square. We
    set the ceiling''s DOF, identified by the node index `(n_seg+1)*(n_seg+1)`, as
    the sole Dirichlet Boundary Condition (DBC) in this scene. We assign it a downward
    velocity of (0,−0.5). The movement is stopped when the ceiling reaches a height
    of −0.6:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation 11.2.6 (DBC setup, simulator.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we implement the penalty term according to Equation [(11.1.1)](lec11.1-penalty_method.html#eq:lec11:DBC_penalty),
    which is essentially a quadratic spring energy for controlling the motion of the
    ceiling:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation 11.2.7 (Spring energy computation, SpringEnergy.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we focus on optimizing with the spring energies while properly handling
    the convergence check and penalty stiffness adjustments. At the start of each
    time step, the target position for each DBC node is computed, and the penalty
    stiffness, kM​, is initialized to 10. If certain nodes reach their preset limit,
    we then set the target as their current position:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation 11.2.8 (DBC initialization, time_integrator.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Entering the Newton loop, in each iteration, just before computing the search
    direction, we assess how many DBC nodes are close enough to their target positions.
    We store these results in the variable `DBC_satisfied`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation 11.2.9 (DBC satisfaction check, time_integrator.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we only eliminate the DOFs of those DBC nodes that already satisfy the
    boundary condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation 11.2.10 (DOF elimination, time_integrator.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The BC satisfaction information stored in `DBC_satisfied` is also used to check
    convergence and update kM​ when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation 11.2.11 (Convergence criteria, time_integrator.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, we proceed to run the simulation, which involves severely compressing the
    dropped elastic square as depicted in ([Figure 11.2.1](#fig:lec11:compress_square)).
    From the final static frame, we observe that the elastic springs on the edges
    are inverted due to extreme compression. This artifact is typical in mass-spring
    models of elasticity. In future chapters, we will explore how applying finite-element
    discretization to barrier-type elasticity models, such as the Neo-Hookean model,
    can prevent such issues. That approach is akin to the enforcement of non-interpenetrations
    in our current simulations.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ecfbf5f9f0ecec91763be32bf418d4c2.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.2.1.** A square is dropped onto the ground and compressed by a
    ceiling until inverted.'
  prefs: []
  type: TYPE_NORMAL
