- en: Loops and Conditionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://en.algorithmica.org/hpc/architecture/loops/](https://en.algorithmica.org/hpc/architecture/loops/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let’s consider a slightly more complex example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It calculates the sum of a 32-bit integer array, just as a simple `for` loop
    would.
  prefs: []
  type: TYPE_NORMAL
- en: 'The “body” of the loop is `add edx, DWORD PTR [rax]`: this instruction loads
    data from the iterator `rax` and adds it to the accumulator `edx`. Next, we move
    the iterator 4 bytes forward with `add rax, 4`. Then, a slightly more complicated
    thing happens.'
  prefs: []
  type: TYPE_NORMAL
- en: '### [#](https://en.algorithmica.org/hpc/architecture/loops/#jumps)Jumps'
  prefs: []
  type: TYPE_NORMAL
- en: Assembly doesn’t have if-s, for-s, functions, or other control flow structures
    that high-level languages have. What it does have is `goto`, or “jump,” how it
    is known in the world of low-level programming.
  prefs: []
  type: TYPE_NORMAL
- en: '**Jump** moves the instruction pointer to a location specified by its operand.
    This location may be either an absolute address in memory, relative to the current
    address or even [computed during runtime](../indirect). To avoid the headache
    of managing these addresses directly, you can mark any instruction with a string
    followed by `:`, and then use this string as a label which gets replaced by the
    relative address of this instruction when converted to machine code.'
  prefs: []
  type: TYPE_NORMAL
- en: Labels can be any string, but compilers don’t get creative and [typically](https://godbolt.org/z/T45x8GKa5)
    just use the line numbers in the source code and function names with their signatures
    when picking names for labels.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unconditional** jump `jmp` can only be used to implement `while (true)` kind
    of loops or stitch parts of a program together. A family of **conditional** jumps
    is used to implement actual control flow.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is reasonable to think that these conditions are computed as `bool`-s somewhere
    and passed to conditional jumps as operands: after all, this is how it works in
    programming languages. But that is not how it is implemented in hardware. Conditional
    operations use a special `FLAGS` register, which first needs to be populated by
    executing instructions that perform some kind of check.'
  prefs: []
  type: TYPE_NORMAL
- en: In our example, `cmp rax, rcx` compares the iterator `rax` with the end-of-array
    pointer `rcx`. This updates the `FLAGS` register, and now it can be used by `jne
    loop`, which looks up a certain bit there that tells whether the two values are
    equal or not, and then either jumps back to the beginning or continues to the
    next instruction, thus breaking the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '### [#](https://en.algorithmica.org/hpc/architecture/loops/#loop-unrolling)Loop
    Unrolling'
  prefs: []
  type: TYPE_NORMAL
- en: One thing you might have noticed about the loop above is that there is a lot
    of overhead to process a single element. During each cycle, there is only one
    useful instruction executed, and the other 3 are incrementing the iterator and
    trying to find out if we are done yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we can do is to *unroll* the loop by grouping iterations together — equivalent
    to writing something like this in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In assembly, it would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now we only need 3 loop control instructions for 4 useful ones (an improvement
    from $\frac{1}{4}$ to $\frac{4}{7}$ in terms of efficiency), and this can be continued
    to reduce the overhead almost to zero.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, unrolling loops isn’t always necessary for performance because
    modern processors don’t actually execute instructions one-by-one, but maintain
    a [queue of pending instructions](/hpc/pipelining) so that two independent operations
    can be executed concurrently without waiting for each other to finish.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is our case too: the real speedup from unrolling won’t be fourfold, because
    the operations of incrementing the counter and checking if we are done are independent
    from the loop body, and can be scheduled to run concurrently with it. But may
    still be beneficial to [ask the compiler](/hpc/compilation/situational) to unroll
    it to some extent.'
  prefs: []
  type: TYPE_NORMAL
- en: '### [#](https://en.algorithmica.org/hpc/architecture/loops/#an-alternative-approach)An
    Alternative Approach'
  prefs: []
  type: TYPE_NORMAL
- en: You don’t have to explicitly use `cmp` or a similar instruction to make a conditional
    jump. Many other instructions either read or modify the `FLAGS` register, sometimes
    as a by-product enabling optional exception checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `add` always sets a number of flags, denoting whether the result
    is zero, is negative, whether an overflow or an underflow occurred, and so on.
    Taking advantage of this mechanism, compilers often produce loops like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This code is a bit harder to read for a human, but it is one instruction shorter
    in the repeated part, which may meaningfully affect performance. [← Assembly Language](https://en.algorithmica.org/hpc/architecture/assembly/)[Functions
    and Recursion →](https://en.algorithmica.org/hpc/architecture/functions/)
  prefs: []
  type: TYPE_NORMAL
