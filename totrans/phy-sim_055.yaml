- en: Slope Friction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://phys-sim-book.github.io/lec10.2-slope_fric.html](https://phys-sim-book.github.io/lec10.2-slope_fric.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  prefs: []
  type: TYPE_NORMAL
- en: Now to implement friction for the slope, we start by implementing the functions
    that calculate f0​(∥vˉk​∥h^), f1​(∥vˉk​∥)/∥vˉk​∥, and (f1′​(∥vˉk​∥)∥vˉk​∥−f1​(∥vˉk​∥))/∥vˉk​∥2
    according to Equation [(9.2.2)](lec9.2-semi_imp_fric.html#eq:lec9:f0), Equation
    [(9.2.5)](lec9.2-semi_imp_fric.html#eq:lec9:f1_term), and Equation [(9.2.6)](lec9.2-semi_imp_fric.html#eq:lec9:hess_term)
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation 10.2.1 (Friction helper functions, FrictionEnergy.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With these terms available, we can then implement the semi-implicit friction
    energy value, gradient, and Hessian computations according to Equation [(9.2.1)](lec9.2-semi_imp_fric.html#eq:lec9:fric_potential),
    Equation [(9.2.3)](lec9.2-semi_imp_fric.html#eq:lec9:fric_grad), and Equation
    [(9.2.4)](lec9.2-semi_imp_fric.html#eq:lec9:fric_hess) respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation 10.2.2 (Friction value, gradient, and Hessian, FrictionEnergy.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that in Numpy, matrix-matrix and matrix-vector products are realized by
    the `dot()` function. For implicit Euler, v=(x−xn)/h and so h^=h. Here `mu_lambda`
    stores μλkn​ for each node, where the normal force magnitude λkn​ is calculated
    using xn at the beginning of each time step.
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation 10.2.3 (Use mu and lambda, time_integrator.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Implementation 10.2.4 (Compute mu and lambda, BarrierEnergy.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Since the slope is static, and the normal direction is the same everywhere,
    T is constant and so can be discretized accurately.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set friction coefficient μ and pass it to the time integrator where
    we add friction energy to model semi-implicit friction on the slope.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now we are ready to test the simulation with different friction coefficients.
    Since our slope has an inclined angle θ with tan(θ)=0.1, we test μ=0.1, 0.11,
    and 0.2 ([Figure 10.2.1](#fig:lec10:diff_mu_exp)). Here we see that when μ=0.1,
    the critical value that provides dynamic friction forces in the same magnitude
    with that of the gravity component on the slope, the square keeps sliding after
    gaining the initial momentum ([Figure 10.2.1](#fig:lec10:diff_mu_exp) top). When
    we set μ=0.11, right above the critical value, the square slides a while and then
    stopped, showing that static friction is properly resolved ([Figure 10.2.1](#fig:lec10:diff_mu_exp)
    middle). With μ=0.2, the square stops even earlier ([Figure 10.2.1](#fig:lec10:diff_mu_exp)
    bottom).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/340f4734630be9cb0d2b4c9cbc90e704.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.2.1.** With friction coefficient μ=0.1 (top), 0.11 (middle), and
    0.2 (bottom), we simulate an elastic square dropped onto a slope. Except the top
    one that the square keeps sliding, the lower two with larger μ both end up with
    a static equilibrium.'
  prefs: []
  type: TYPE_NORMAL
