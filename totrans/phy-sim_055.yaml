- en: Slope Friction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 斜坡摩擦
- en: 原文：[https://phys-sim-book.github.io/lec10.2-slope_fric.html](https://phys-sim-book.github.io/lec10.2-slope_fric.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://phys-sim-book.github.io/lec10.2-slope_fric.html](https://phys-sim-book.github.io/lec10.2-slope_fric.html)
- en: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
- en: Now to implement friction for the slope, we start by implementing the functions
    that calculate f0​(∥vˉk​∥h^), f1​(∥vˉk​∥)/∥vˉk​∥, and (f1′​(∥vˉk​∥)∥vˉk​∥−f1​(∥vˉk​∥))/∥vˉk​∥2
    according to Equation [(9.2.2)](lec9.2-semi_imp_fric.html#eq:lec9:f0), Equation
    [(9.2.5)](lec9.2-semi_imp_fric.html#eq:lec9:f1_term), and Equation [(9.2.6)](lec9.2-semi_imp_fric.html#eq:lec9:hess_term)
    respectively.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为了实现斜坡的摩擦力，我们首先根据方程[(9.2.2)](lec9.2-semi_imp_fric.html#eq:lec9:f0)，方程[(9.2.5)](lec9.2-semi_imp_fric.html#eq:lec9:f1_term)和方程[(9.2.6)](lec9.2-semi_imp_fric.html#eq:lec9:hess_term)分别实现函数f0(∥vˉk∥h^)，f1(∥vˉk∥)/∥vˉk∥和(f1′(∥vˉk∥)∥vˉk∥−f1(∥vˉk∥))/∥vˉk∥^2。
- en: '**Implementation 10.2.1 (Friction helper functions, FrictionEnergy.py).**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现10.2.1（摩擦辅助函数，FrictionEnergy.py）。**'
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With these terms available, we can then implement the semi-implicit friction
    energy value, gradient, and Hessian computations according to Equation [(9.2.1)](lec9.2-semi_imp_fric.html#eq:lec9:fric_potential),
    Equation [(9.2.3)](lec9.2-semi_imp_fric.html#eq:lec9:fric_grad), and Equation
    [(9.2.4)](lec9.2-semi_imp_fric.html#eq:lec9:fric_hess) respectively.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有这些术语可用后，我们可以根据方程[(9.2.1)](lec9.2-semi_imp_fric.html#eq:lec9:fric_potential)，方程[(9.2.3)](lec9.2-semi_imp_fric.html#eq:lec9:fric_grad)和方程[(9.2.4)](lec9.2-semi_imp_fric.html#eq:lec9:fric_hess)分别实现半隐式摩擦能量值、梯度和Hessian计算。
- en: '**Implementation 10.2.2 (Friction value, gradient, and Hessian, FrictionEnergy.py).**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现10.2.2（摩擦值、梯度和Hessian，FrictionEnergy.py）。**'
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that in Numpy, matrix-matrix and matrix-vector products are realized by
    the `dot()` function. For implicit Euler, v=(x−xn)/h and so h^=h. Here `mu_lambda`
    stores μλkn​ for each node, where the normal force magnitude λkn​ is calculated
    using xn at the beginning of each time step.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在Numpy中，矩阵-矩阵和矩阵-向量积是通过`dot()`函数实现的。对于隐式欧拉法，v=(x−xn)/h，因此h^=h。这里`mu_lambda`存储每个节点的μλkn，其中法向力大小λkn在每一步的开始使用xn计算。
- en: '**Implementation 10.2.3 (Use mu and lambda, time_integrator.py).**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现10.2.3（使用μ和λ，time_integrator.py）。**'
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Implementation 10.2.4 (Compute mu and lambda, BarrierEnergy.py).**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现10.2.4（计算μ和λ，BarrierEnergy.py）。**'
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since the slope is static, and the normal direction is the same everywhere,
    T is constant and so can be discretized accurately.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于斜率是静态的，且法线方向在所有地方都相同，因此T是恒定的，因此可以精确地离散化。
- en: Finally, we set friction coefficient μ and pass it to the time integrator where
    we add friction energy to model semi-implicit friction on the slope.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们设置摩擦系数μ并将其传递给时间积分器，我们在其中添加摩擦能量以模拟斜坡上的半隐式摩擦。
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now we are ready to test the simulation with different friction coefficients.
    Since our slope has an inclined angle θ with tan(θ)=0.1, we test μ=0.1, 0.11,
    and 0.2 ([Figure 10.2.1](#fig:lec10:diff_mu_exp)). Here we see that when μ=0.1,
    the critical value that provides dynamic friction forces in the same magnitude
    with that of the gravity component on the slope, the square keeps sliding after
    gaining the initial momentum ([Figure 10.2.1](#fig:lec10:diff_mu_exp) top). When
    we set μ=0.11, right above the critical value, the square slides a while and then
    stopped, showing that static friction is properly resolved ([Figure 10.2.1](#fig:lec10:diff_mu_exp)
    middle). With μ=0.2, the square stops even earlier ([Figure 10.2.1](#fig:lec10:diff_mu_exp)
    bottom).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备用不同的摩擦系数测试模拟。由于我们的斜坡有一个倾斜角θ，tan(θ)=0.1，我们测试μ=0.1，0.11和0.2（[图10.2.1](#fig:lec10:diff_mu_exp)）。在这里，我们可以看到当μ=0.1时，提供与斜坡重力分量相同大小动态摩擦力的临界值，正方形在获得初始动量后继续滑动（[图10.2.1](#fig:lec10:diff_mu_exp)顶部）。当我们设置μ=0.11，略高于临界值时，正方形滑动了一段时间后停止，表明静摩擦力得到了适当的解决（[图10.2.1](#fig:lec10:diff_mu_exp)中部）。当μ=0.2时，正方形甚至更早停止（[图10.2.1](#fig:lec10:diff_mu_exp)底部）。
- en: '![](../Images/340f4734630be9cb0d2b4c9cbc90e704.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/340f4734630be9cb0d2b4c9cbc90e704.png)'
- en: '**Figure 10.2.1.** With friction coefficient μ=0.1 (top), 0.11 (middle), and
    0.2 (bottom), we simulate an elastic square dropped onto a slope. Except the top
    one that the square keeps sliding, the lower two with larger μ both end up with
    a static equilibrium.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.2.1**。当摩擦系数μ=0.1（顶部），0.11（中部）和0.2（底部）时，我们模拟了一个弹性正方形被投掷到斜坡上。除了顶部的一个正方形持续滑动外，摩擦系数较大的底部两个最终都达到了静态平衡。'
