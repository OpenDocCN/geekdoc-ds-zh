- en: Integer Division
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://en.algorithmica.org/hpc/arithmetic/division/](https://en.algorithmica.org/hpc/arithmetic/division/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Compared to other arithmetic operations, division works very poorly on x86 and
    computers in general. Both floating-point and integer division is notoriously
    hard to implement in hardware. The circuitry takes a lot of space in the ALU,
    the computation has a lot of stages, and as the result, `div` and its siblings
    routinely take 10-20 cycles to complete, with latency being slightly less on smaller
    data type sizes.
  prefs: []
  type: TYPE_NORMAL
- en: '### [#](https://en.algorithmica.org/hpc/arithmetic/division/#division-and-modulo-in-x86)Division
    and Modulo in x86'
  prefs: []
  type: TYPE_NORMAL
- en: Since nobody wants to duplicate all this mess for a separate modulo operation,
    the `div` instruction serves both purposes. To perform a 32-bit integer division,
    you need to put the dividend *specifically* in the `eax` register and call `div`
    with the divisor as its sole operand. After this, the quotient will be stored
    in `eax` and the remainder will be stored in `edx`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only caveat is that the dividend actually needs to be stored in *two* registers,
    `eax` and `edx`: this mechanism enables 64-by-32 or even 128-by-64 division, similar
    to how [128-bit multiplication](../integer) works. When performing the usual 32-by-32
    signed division, we need to sign-extend `eax` to 64 bits and store its higher
    part in `edx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For unsigned division, you can just set `edx` to zero so that it doesn’t interfere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'An in both cases, in addition to the quotient in `eax`, you can also access
    the remainder as `edx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also divide 128-bit integer (stored in `rdx:rax`) by a 64-bit integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The high part of the dividend should be less than the divisor, otherwise an
    overflow occurs. Because of this constraint, it is [hard](https://danlark.org/2020/06/14/128-bit-division/)
    to get compilers to produce this code by themselves: if you divide a [128-bit
    integer type](../integer) by a 64-bit integer, the compiler will bubble-wrap it
    with additional checks which may actually be unnecessary.'
  prefs: []
  type: TYPE_NORMAL
- en: '### [#](https://en.algorithmica.org/hpc/arithmetic/division/#division-by-constants)Division
    by Constants'
  prefs: []
  type: TYPE_NORMAL
- en: 'Integer division is painfully slow, even when fully implemented in hardware,
    but it can be avoided in certain cases if the divisor is constant. A well-known
    example is the division by a power of two, which can be replaced by a one-cycle
    binary shift: the [binary GCD algorithm](/hpc/algorithms/gcd) is a delightful
    showcase of this technique.'
  prefs: []
  type: TYPE_NORMAL
- en: In the general case, there are several clever tricks that replace division with
    multiplication at the cost of a bit of precomputation. All these tricks are based
    on the following idea. Consider the task of dividing one floating-point number
    $x$ by another floating-point number $y$, when $y$ is known in advance. What we
    can do is to calculate a constant
  prefs: []
  type: TYPE_NORMAL
- en: $$ d \approx y^{-1} $$ and then, during runtime, we will calculate $$ x / y
    = x \cdot y^{-1} \approx x \cdot d $$
  prefs: []
  type: TYPE_NORMAL
- en: The result of $\frac{1}{y}$ will be at most $\epsilon$ off, and the multiplication
    $x \cdot d$ will only add another $\epsilon$ and therefore will be at most $2
    \epsilon + \epsilon^2 = O(\epsilon)$ off, which is tolerable for the floating-point
    case.
  prefs: []
  type: TYPE_NORMAL
- en: '### [#](https://en.algorithmica.org/hpc/arithmetic/division/#barrett-reduction)Barrett
    Reduction'
  prefs: []
  type: TYPE_NORMAL
- en: How to generalize this trick for integers? Calculating `int d = 1 / y` doesn’t
    seem to work, because it will just be zero. The best thing we can do is to express
    it as
  prefs: []
  type: TYPE_NORMAL
- en: $$ d = \frac{m}{2^s} $$ and then find a “magic” number $m$ and a binary shift
    $s$ such that `x / y == (x * m) >> s` for all `x` within range. $$ \lfloor x /
    y \rfloor = \lfloor x \cdot y^{-1} \rfloor = \lfloor x \cdot d \rfloor = \lfloor
    x \cdot \frac{m}{2^s} \rfloor $$
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be shown that such a pair always exists, and compilers actually perform
    an optimization like that by themselves. Every time they encounter a division
    by a constant, they replace it with a multiplication and a binary shift. Here
    is the generated assembly for dividing an `unsigned long long` by $(10^9 + 7)$:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This technique is called *Barrett reduction*, and it’s called “reduction” because
    it is mostly used for modulo operations, which can be replaced with a single division,
    multiplication and subtraction by the virtue of this formula:'
  prefs: []
  type: TYPE_NORMAL
- en: $$ r = x - \lfloor x / y \rfloor \cdot y $$
  prefs: []
  type: TYPE_NORMAL
- en: This method requires some precomputation, including performing one actual division.
    Therefore, this is only beneficial when you perform not just one but a few divisions,
    all with the same constant divisor.
  prefs: []
  type: TYPE_NORMAL
- en: '### [#](https://en.algorithmica.org/hpc/arithmetic/division/#why-it-works)Why
    It Works'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is not very clear why such $m$ and $s$ always exist, let alone how to find
    them. But given a fixed $s$, intuition tells us that $m$ should be as close to
    $2^s/y$ as possible for $2^s$ to cancel out. So there are two natural choices:
    $\lfloor 2^s/y \rfloor$ and $\lceil 2^s/y \rceil$. The first one doesn’t work,
    because if you substitute'
  prefs: []
  type: TYPE_NORMAL
- en: '$$ \Bigl \lfloor \frac{x \cdot \lfloor 2^s/y \rfloor}{2^s} \Bigr \rfloor $$
    then for any integer $\frac{x}{y}$ where $y$ is not even, the result will be strictly
    less than the truth. This only leaves the other case, $m = \lceil 2^s/y \rceil$.
    Now, let’s try to derive the lower and upper bounds for the result of the computation:
    $$ \lfloor x / y \rfloor = \Bigl \lfloor \frac{x \cdot m}{2^s} \Bigr \rfloor =
    \Bigl \lfloor \frac{x \cdot \lceil 2^s /y \rceil}{2^s} \Bigr \rfloor $$ Let’s
    start with the bounds for $m$: $$ 2^s / y \le \lceil 2^s / y \rceil < 2^s / y
    + 1 $$ And now for the whole expression: $$ x / y - 1 < \Bigl \lfloor \frac{x
    \cdot \lceil 2^s /y \rceil}{2^s} \Bigr \rfloor < x / y + x / 2^s $$'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the result falls somewhere in a range of size $(1 + \frac{x}{2^s})$,
    and if this range always has exactly one integer for all possible $x / y$, then
    the algorithm is guaranteed to give the right answer. Turns out, we can always
    set $s$ to be high enough to achieve it.
  prefs: []
  type: TYPE_NORMAL
- en: 'What will be the worst case here? How to pick $x$ and $y$ so that the $(x/y
    - 1, x/y + x / 2^s)$ range contains two integers? We can see that integer ratios
    don’t work because the left border is not included, and assuming $x/2^s < 1$,
    only $x/y$ itself will be in the range. The worst case is actually the $x/y$ that
    comes closest to $1$ without exceeding it. For $n$-bit integers, that is the second-largest
    possible integer divided by the first-largest:'
  prefs: []
  type: TYPE_NORMAL
- en: $$ \begin{aligned} x = 2^n - 2 \\ y = 2^n - 1 \end{aligned} $$
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the lower bound will be $(\frac{2^n-2}{2^n-1} - 1)$ and the upper
    bound will be $(\frac{2^n-2}{2^n-1} + \frac{2^n-2}{2^s})$. The left border is
    as close to a whole number as possible, and the size of the whole range is the
    second largest possible. And here is the punchline: if $s \ge n$, then the only
    integer contained in this range is $1$, and so the algorithm will always return
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: '### [#](https://en.algorithmica.org/hpc/arithmetic/division/#lemire-reduction)Lemire
    Reduction'
  prefs: []
  type: TYPE_NORMAL
- en: Barrett reduction is a bit complicated, and also generates a length instruction
    sequence for modulo because it is computed indirectly. There is a new ([2019](https://arxiv.org/pdf/1902.01961.pdf))
    method, which is simpler and actually faster for modulo in some cases. It doesn’t
    have a conventional name yet, but I am going to refer to it as [Lemire](https://lemire.me/blog/)
    reduction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the main idea. Consider the floating-point representation of some integer
    fraction:'
  prefs: []
  type: TYPE_NORMAL
- en: $$ \frac{179}{6} = 11101.1101010101\ldots = 29\tfrac{5}{6} \approx 29.83 $$
  prefs: []
  type: TYPE_NORMAL
- en: How can we “dissect” it to get the parts we need?
  prefs: []
  type: TYPE_NORMAL
- en: To get the integer part (29), we can just floor or truncate it before the dot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get the fractional part (⅚), we can just take what is after the dots.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get the remainder (5), we can multiply the fractional part by the divisor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, for 32-bit integers, we can set $s = 64$ and look at the computation that
    we do in the multiply-and-shift scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: $$ \lfloor x / y \rfloor = \Bigl \lfloor \frac{x \cdot m}{2^s} \Bigr \rfloor
    = \Bigl \lfloor \frac{x \cdot \lceil 2^s /y \rceil}{2^s} \Bigr \rfloor $$
  prefs: []
  type: TYPE_NORMAL
- en: What we really do here is we multiply $x$ by a floating-point constant ($x \cdot
    m$) and then truncate the result $(\lfloor \frac{\cdot}{2^s} \rfloor)$.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we took not the highest bits but the lowest? This would correspond
    to the fractional part — and if we multiply it back by $y$ and truncate the result,
    this will be exactly the remainder:'
  prefs: []
  type: TYPE_NORMAL
- en: $$ r = \Bigl \lfloor \frac{ (x \cdot \lceil 2^s /y \rceil \bmod 2^s) \cdot y
    }{2^s} \Bigr \rfloor $$
  prefs: []
  type: TYPE_NORMAL
- en: This works perfectly because what we do here can be interpreted as just three
    chained floating-point multiplications with the total relative error of $O(\epsilon)$.
    Since $\epsilon = O(\frac{1}{2^s})$ and $s = 2n$, the error will always be less
    than one, and hence the result will be exact.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can also check divisibility of $x$ by $y$ with just one multiplication using
    the fact that the remainder of division is zero if and only if the fractional
    part (the lower 64 bits of $m \cdot x$) does not exceed $m$ (otherwise, it would
    become a nonzero number when multiplied back by $y$ and right-shifted by 64).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The only downside of this method is that it needs integer types four times the
    original size to perform the multiplication, while other reduction methods can
    work with just the double.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a way to compute 64x64 modulo by carefully manipulating the halves
    of intermediate results; the implementation is left as an exercise to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: '### [#](https://en.algorithmica.org/hpc/arithmetic/division/#further-reading)Further
    Reading'
  prefs: []
  type: TYPE_NORMAL
- en: Check out [libdivide](https://github.com/ridiculousfish/libdivide) and [GMP](https://gmplib.org/)
    for more general implementations of optimized integer division.
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth reading [Hacker’s Delight](https://www.amazon.com/Hackers-Delight-2nd-Henry-Warren/dp/0321842685),
    which has a whole chapter dedicated to integer division. [← Integer Numbers](https://en.algorithmica.org/hpc/arithmetic/integer/)[../Number
    Theory →](https://en.algorithmica.org/hpc/number-theory/)
  prefs: []
  type: TYPE_NORMAL
