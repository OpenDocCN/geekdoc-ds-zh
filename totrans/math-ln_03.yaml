- en: 3\. Logic
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 逻辑
- en: 原文：[https://leanprover-community.github.io/mathematics_in_lean/C03_Logic.html](https://leanprover-community.github.io/mathematics_in_lean/C03_Logic.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://leanprover-community.github.io/mathematics_in_lean/C03_Logic.html](https://leanprover-community.github.io/mathematics_in_lean/C03_Logic.html)
- en: '*[Mathematics in Lean](index.html)* **   3\. Logic'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*[数学在Lean中](index.html)* **   3. 逻辑'
- en: '[View page source](_sources/C03_Logic.rst.txt)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[查看页面源代码](_sources/C03_Logic.rst.txt)'
- en: '* * *'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: In the last chapter, we dealt with equations, inequalities, and basic mathematical
    statements like “\(x\) divides \(y\).” Complex mathematical statements are built
    up from simple ones like these using logical terms like “and,” “or,” “not,” and
    “if … then,” “every,” and “some.” In this chapter, we show you how to work with
    statements that are built up in this way.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们处理了方程、不等式和像“\(x\) 整除 \(y\)”这样的基本数学陈述。复杂的数学陈述是通过使用逻辑术语“和”、“或”、“非”、“如果…那么”、“每个”和“一些”从这些简单的陈述构建而成的。在本章中，我们将向您展示如何处理以这种方式构建的陈述。
- en: '## 3.1\. Implication and the Universal Quantifier[](#implication-and-the-universal-quantifier
    "Link to this heading")'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '## 3.1. 蕴含和全称量词[](#implication-and-the-universal-quantifier "链接到本标题")'
- en: 'Consider the statement after the `#check`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 `#check` 之后的陈述：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In words, we would say “for every real number `x`, if `0 ≤ x` then the absolute
    value of `x` equals `x`”. We can also have more complicated statements like:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 用文字来说，我们会说“对于每一个实数 `x`，如果 `0 ≤ x`，那么 `x` 的绝对值等于 `x`”。我们也可以有更复杂的陈述，例如：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In words, we would say “for every `x`, `y`, and `ε`, if `0 < ε ≤ 1`, the absolute
    value of `x` is less than `ε`, and the absolute value of `y` is less than `ε`,
    then the absolute value of `x * y` is less than `ε`.” In Lean, in a sequence of
    implications there are implicit parentheses grouped to the right. So the expression
    above means “if `0 < ε` then if `ε ≤ 1` then if `|x| < ε` …” As a result, the
    expression says that all the assumptions together imply the conclusion.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 用文字来说，我们会说“对于每一个 `x`、`y` 和 `ε`，如果 `0 < ε ≤ 1`，则 `x` 的绝对值小于 `ε`，`y` 的绝对值小于 `ε`，那么
    `x * y` 的绝对值小于 `ε`。”在Lean中，在一系列蕴含中，有隐式的括号分组到右边。所以上面的表达式意味着“如果 `0 < ε`，那么如果 `ε
    ≤ 1`，那么如果 `|x| < ε`…” 因此，这个表达式表明所有的假设共同蕴含了结论。
- en: 'You have already seen that even though the universal quantifier in this statement
    ranges over objects and the implication arrows introduce hypotheses, Lean treats
    the two in very similar ways. In particular, if you have proved a theorem of that
    form, you can apply it to objects and hypotheses in the same way. We will use
    as an example the following statement that we will help you to prove a bit later:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到，尽管这个陈述中的全称量词遍历对象，而蕴含箭头引入假设，但Lean以非常相似的方式处理这两个概念。特别是，如果您已经证明了这种形式的定理，您可以用相同的方式将其应用于对象和假设。我们将以下陈述作为例子，我们将在稍后帮助您证明：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You have also already seen that it is common in Lean to use curly brackets to
    make quantified variables implicit when they can be inferred from subsequent hypotheses.
    When we do that, we can just apply a lemma to the hypotheses without mentioning
    the objects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您也已经看到，在Lean中，当量词可以从后续的假设中推断出来时，通常使用花括号来使量词变量隐式。当我们这样做时，我们只需将引理应用于假设，而不必提及对象。
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At this stage, you also know that if you use the `apply` tactic to apply `my_lemma`
    to a goal of the form `|a * b| < δ`, you are left with new goals that require
    you to prove each of the hypotheses.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，您也知道，如果您使用 `apply` 策略将 `my_lemma` 应用到形式为 `|a * b| < δ` 的目标上，您将剩下需要证明每个假设的新目标。
- en: 'To prove a statement like this, use the `intro` tactic. Take a look at what
    it does in this example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要证明这样的陈述，使用 `intro` 策略。看看它在以下示例中的表现：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can use any names we want for the universally quantified variables; they
    do not have to be `x`, `y`, and `ε`. Notice that we have to introduce the variables
    even though they are marked implicit: making them implicit means that we leave
    them out when we write an expression *using* `my_lemma`, but they are still an
    essential part of the statement that we are proving. After the `intro` command,
    the goal is what it would have been at the start if we listed all the variables
    and hypotheses *before* the colon, as we did in the last section. In a moment,
    we will see why it is sometimes necessary to introduce variables and hypotheses
    after the proof begins.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为全称量词变量使用任何我们想要的名称；它们不必是 `x`、`y` 和 `ε`。注意，即使它们被标记为隐式，我们也必须引入这些变量：使它们隐式意味着在编写使用
    `my_lemma` 的表达式时我们可以省略它们，但它们仍然是我们正在证明的陈述的一个基本部分。在 `intro` 命令之后，目标是如果在冒号之前列出了所有变量和假设，它将是什么，就像我们在上一节中所做的那样。一会儿我们将看到为什么有时需要在证明开始后引入变量和假设。
- en: 'To help you prove the lemma, we will start you off:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你证明引理，我们将从以下步骤开始：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finish the proof using the theorems `abs_mul`, `mul_le_mul`, `abs_nonneg`, `mul_lt_mul_right`,
    and `one_mul`. Remember that you can find theorems like these using Ctrl-space
    completion (or Cmd-space completion on a Mac). Remember also that you can use
    `.mp` and `.mpr` or `.1` and `.2` to extract the two directions of an if-and-only-if
    statement.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用定理 `abs_mul`、`mul_le_mul`、`abs_nonneg`、`mul_lt_mul_right` 和 `one_mul` 完成证明。记住，你可以使用
    Ctrl-space 完成提示（或在 Mac 上使用 Cmd-space 完成提示）找到这样的定理。还要记住，你可以使用 `.mp` 和 `.mpr` 或
    `.1` 和 `.2` 来提取双向条件语句的两个方向。
- en: Universal quantifiers are often hidden in definitions, and Lean will unfold
    definitions to expose them when necessary. For example, let’s define two predicates,
    `FnUb f a` and `FnLb f a`, where `f` is a function from the real numbers to the
    real numbers and `a` is a real number. The first says that `a` is an upper bound
    on the values of `f`, and the second says that `a` is a lower bound on the values
    of `f`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 全称量词通常隐藏在定义中，当需要时 Lean 会展开定义来暴露它们。例如，让我们定义两个谓词，`FnUb f a` 和 `FnLb f a`，其中 `f`
    是从实数到实数的函数，而 `a` 是一个实数。第一个谓词表示 `a` 是 `f` 的值的上界，第二个谓词表示 `a` 是 `f` 的值的下界。
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the next example, `fun x ↦ f x + g x` is the function that maps `x` to `f
    x + g x`. Going from the expression `f x + g x` to this function is called a lambda
    abstraction in type theory.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，`fun x ↦ f x + g x` 是将 `x` 映射到 `f x + g x` 的函数。从表达式 `f x + g x` 到这个函数的过程在类型理论中被称为
    lambda 抽象。
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Applying `intro` to the goal `FnUb (fun x ↦ f x + g x) (a + b)` forces Lean
    to unfold the definition of `FnUb` and introduce `x` for the universal quantifier.
    The goal is then `(fun (x : ℝ) ↦ f x + g x) x ≤ a + b`. But applying `(fun x ↦
    f x + g x)` to `x` should result in `f x + g x`, and the `dsimp` command performs
    that simplification. (The “d” stands for “definitional.”) You can delete that
    command and the proof still works; Lean would have to perform that contraction
    anyhow to make sense of the next `apply`. The `dsimp` command simply makes the
    goal more readable and helps us figure out what to do next. Another option is
    to use the `change` tactic by writing `change f x + g x ≤ a + b`. This helps make
    the proof more readable, and gives you more control over how the goal is transformed.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '将 `intro` 应用到目标 `FnUb (fun x ↦ f x + g x) (a + b)` 迫使 Lean 展开定义 `FnUb` 并引入
    `x` 作为全称量词。目标变为 `(fun (x : ℝ) ↦ f x + g x) x ≤ a + b`。但是将 `(fun x ↦ f x + g x)`
    应用到 `x` 应该得到 `f x + g x`，而 `dsimp` 命令执行了这种简化。（“d”代表“定义性的。”）你可以删除那个命令，证明仍然有效；Lean
    无论如何都必须执行那个收缩来理解下一个 `apply`。`dsimp` 命令只是使目标更易于阅读，并帮助我们确定下一步该做什么。另一个选择是使用 `change`
    策略，通过编写 `change f x + g x ≤ a + b` 来实现。这有助于使证明更易于阅读，并让你对目标如何转换有更多的控制。'
- en: 'The rest of the proof is routine. The last two `apply` commands force Lean
    to unfold the definitions of `FnUb` in the hypotheses. Try carrying out similar
    proofs of these:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 证明的其余部分是常规的。最后两个 `apply` 命令迫使 Lean 在假设中展开 `FnUb` 的定义。尝试进行类似的证明：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Even though we have defined `FnUb` and `FnLb` for functions from the reals to
    the reals, you should recognize that the definitions and proofs are much more
    general. The definitions make sense for functions between any two types for which
    there is a notion of order on the codomain. Checking the type of the theorem `add_le_add`
    shows that it holds of any structure that is an “ordered additive commutative
    monoid”; the details of what that means don’t matter now, but it is worth knowing
    that the natural numbers, integers, rationals, and real numbers are all instances.
    So if we prove the theorem `fnUb_add` at that level of generality, it will apply
    in all these instances.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经为从实数到实数的函数定义了 `FnUb` 和 `FnLb`，但你应该认识到定义和证明要更通用。这些定义对于任何在值域上有序概念的类型之间的函数都是有意义的。检查定理
    `add_le_add` 的类型显示，它适用于任何“有序加法交换幺半群”的结构；现在不需要知道这意味着什么，但值得知道自然数、整数、有理数和实数都是实例。因此，如果我们在这个普遍性级别上证明定理
    `fnUb_add`，它将适用于所有这些实例。
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You have already seen square brackets like these in Section [Section 2.2](C02_Basics.html#proving-identities-in-algebraic-structures),
    though we still haven’t explained what they mean. For concreteness, we will stick
    to the real numbers for most of our examples, but it is worth knowing that Mathlib
    contains definitions and theorems that work at a high level of generality.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在 [第 2.2 节](C02_Basics.html#proving-identities-in-algebraic-structures) 中看到了这样的方括号，尽管我们还没有解释它们的意义。为了具体化，我们将在大多数例子中坚持使用实数，但值得知道
    Mathlib 包含定义和定理，它们在高度普遍的层面上工作。
- en: 'For another example of a hidden universal quantifier, Mathlib defines a predicate
    `Monotone`, which says that a function is nondecreasing in its arguments:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个隐藏的全称量词的例子，Mathlib 定义了一个谓词 `Monotone`，它表示函数在其参数上是非递减的：
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The property `Monotone f` is defined to be exactly the expression after the
    colon. We need to put the `@` symbol before `h` because if we don’t, Lean expands
    the implicit arguments to `h` and inserts placeholders.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 谓词 `Monotone f` 被定义为冒号后面的确切表达式。我们需要在 `h` 前面放置 `@` 符号，因为如果不这样做，Lean 会扩展 `h` 的隐含参数并插入占位符。
- en: Proving statements about monotonicity involves using `intro` to introduce two
    variables, say, `a` and `b`, and the hypothesis `a ≤ b`. To *use* a monotonicity
    hypothesis, you can apply it to suitable arguments and hypotheses, and then apply
    the resulting expression to the goal. Or you can apply it to the goal and let
    Lean help you work backwards by displaying the remaining hypotheses as new subgoals.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 证明关于单调性的陈述涉及使用 `intro` 引入两个变量，例如，`a` 和 `b`，以及假设 `a ≤ b`。要 *使用* 单调性假设，你可以将其应用于合适的论点和假设，然后将结果表达式应用于目标。或者，你可以将其应用于目标，让
    Lean 通过显示剩余的假设作为新的子目标来帮助你反向工作。
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When a proof is this short, it is often convenient to give a proof term instead.
    To describe a proof that temporarily introduces objects `a` and `b` and a hypothesis
    `aleb`, Lean uses the notation `fun a b aleb ↦ ...`. This is analogous to the
    way that an expression like `fun x ↦ x^2` describes a function by temporarily
    naming an object, `x`, and then using it to describe a value. So the `intro` command
    in the previous proof corresponds to the lambda abstraction in the next proof
    term. The `apply` commands then correspond to building the application of the
    theorem to its arguments.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当证明如此简短时，通常更方便给出一个证明项。为了描述一个临时引入对象 `a` 和 `b` 以及假设 `aleb` 的证明，Lean 使用记号 `fun
    a b aleb ↦ ...`。这与像 `fun x ↦ x^2` 这样的表达式通过临时命名一个对象 `x` 然后用它来描述一个值的方式来描述一个函数类似。因此，前一个证明中的
    `intro` 命令对应于下一个证明项中的 lambda 抽象。然后的 `apply` 命令对应于构建定理对其参数的应用。
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is a useful trick: if you start writing the proof term `fun a b aleb ↦
    _` using an underscore where the rest of the expression should go, Lean will flag
    an error, indicating that it can’t guess the value of that expression. If you
    check the Lean Goal window in VS Code or hover over the squiggly error marker,
    Lean will show you the goal that the remaining expression has to solve.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有用的技巧：如果你开始使用下划线 `_` 来编写证明项 `fun a b aleb ↦ _`，在表达式应该放置的地方，Lean 会标记一个错误，表明它无法猜测该表达式的值。如果你在
    VS Code 中的 Lean Goal 窗口检查或悬停在波浪形错误标记上，Lean 会显示剩余表达式必须解决的目標。
- en: 'Try proving these, with either tactics or proof terms:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用策略或证明项来证明这些：
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here are some more examples. A function \(f\) from \(\Bbb R\) to \(\Bbb R\)
    is said to be *even* if \(f(-x) = f(x)\) for every \(x\), and *odd* if \(f(-x)
    = -f(x)\) for every \(x\). The following example defines these two notions formally
    and establishes one fact about them. You can complete the proofs of the others.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些更多的例子。从 \(\Bbb R\) 到 \(\Bbb R\) 的函数 \(f\) 被称为 *偶函数*，如果对于每个 \(x\)，\(f(-x)
    = f(x)\)；如果对于每个 \(x\)，\(f(-x) = -f(x)\)，则称为 *奇函数*。以下示例正式定义了这两个概念，并建立了一个关于它们的命题。你可以完成其他命题的证明。
- en: '[PRE14]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first proof can be shortened using `dsimp` or `change` to get rid of the
    lambda abstraction. But you can check that the subsequent `rw` won’t work unless
    we get rid of the lambda abstraction explicitly, because otherwise it cannot find
    the patterns `f x` and `g x` in the expression. Contrary to some other tactics,
    `rw` operates on the syntactic level, it won’t unfold definitions or apply reductions
    for you (it has a variant called `erw` that tries a little harder in this direction,
    but not much harder).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个证明可以使用 `dsimp` 或 `change` 来缩短，以消除 lambda 抽象。但你可以检查，除非我们明确地消除 lambda 抽象，否则随后的
    `rw` 不会工作，因为否则它无法在表达式中找到 `f x` 和 `g x` 的模式。与一些其他策略相反，`rw` 在句法层面上操作，它不会为你展开定义或应用简化（它有一个名为
    `erw` 的变体，在这个方向上尝试得稍微努力一些，但不是很多）。
- en: You can find implicit universal quantifiers all over the place, once you know
    how to spot them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道如何找到它们，你可以在任何地方找到隐含的全称量词。
- en: Mathlib includes a good library for manipulating sets. Recall that Lean does
    not use foundations based on set theory, so here the word set has its mundane
    meaning of a collection of mathematical objects of some given type `α`. If `x`
    has type `α` and `s` has type `Set α`, then `x ∈ s` is a proposition that asserts
    that `x` is an element of `s`. If `y` has some different type `β` then the expression
    `y ∈ s` makes no sense. Here “makes no sense” means “has no type hence Lean does
    not accept it as a well-formed statement”. This contrasts with Zermelo-Fraenkel
    set theory for instance where `a ∈ b` is a well-formed statement for every mathematical
    objects `a` and `b`. For instance `sin ∈ cos` is a well-formed statement in ZF.
    This defect of set theoretic foundations is an important motivation for not using
    it in a proof assistant which is meant to assist us by detecting meaningless expressions.
    In Lean `sin` has type `ℝ → ℝ` and `cos` has type `ℝ → ℝ` which is not equal to
    `Set (ℝ → ℝ)`, even after unfolding definitions, so the statement `sin ∈ cos`
    makes no sense. One can also use Lean to work on set theory itself. For instance
    the independence of the continuum hypothesis from the axioms of Zermelo-Fraenkel
    has been formalized in Lean. But such a meta-theory of set theory is completely
    beyond the scope of this book.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib 包含了一个用于操作集合的良好库。回想一下，Lean 不使用基于集合论的公理系统，因此这里的“集合”一词具有其平凡的意义，即某些给定类型
    `α` 的数学对象的集合。如果 `x` 的类型是 `α`，而 `s` 的类型是 `Set α`，那么 `x ∈ s` 是一个命题，它断言 `x` 是 `s`
    的一个元素。如果 `y` 具有某种不同的类型 `β`，那么表达式 `y ∈ s` 就没有意义。这里的“没有意义”是指“没有类型，因此 Lean 不接受它作为一个有效的语句”。这与例如
    Zermelo-Fraenkel 集合论形成对比，在 Zermelo-Fraenkel 集合论中，对于每一个数学对象 `a` 和 `b`，`a ∈ b` 都是一个有效的语句。例如，在
    ZF 中，“sin ∈ cos”是一个有效的语句。集合论基础的这一缺陷是重要的动机，即不在旨在通过检测无意义表达式来协助我们的证明辅助工具中使用它。在 Lean
    中，“sin”的类型是 `ℝ → ℝ`，而“cos”的类型是 `ℝ → ℝ`，这并不等于 `Set (ℝ → ℝ)`，即使展开定义之后也是如此，因此语句“sin
    ∈ cos”没有意义。人们也可以使用 Lean 来研究集合论本身。例如，连续假设与 Zermelo-Fraenkel 公理的独立性已经在 Lean 中形式化。但这样的集合论元理论完全超出了本书的范围。
- en: 'If `s` and `t` are of type `Set α`, then the subset relation `s ⊆ t` is defined
    to mean `∀ {x : α}, x ∈ s → x ∈ t`. The variable in the quantifier is marked implicit
    so that given `h : s ⊆ t` and `h'' : x ∈ s`, we can write `h h''` as justification
    for `x ∈ t`. The following example provides a tactic proof and a proof term justifying
    the reflexivity of the subset relation, and asks you to do the same for transitivity.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 `s` 和 `t` 的类型都是 `Set α`，那么子集关系 `s ⊆ t` 被定义为意味着 `∀ {x : α}, x ∈ s → x ∈ t`。量词中的变量被标记为隐式，这样给定
    `h : s ⊆ t` 和 `h'' : x ∈ s`，我们可以将 `h h''` 写作 `x ∈ t` 的理由。以下示例提供了一个策略证明和一个证明项，以证明子集关系的自反性，并要求你为传递性做同样的工作。'
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Just as we defined `FnUb` for functions, we can define `SetUb s a` to mean that
    `a` is an upper bound on the set `s`, assuming `s` is a set of elements of some
    type that has an order associated with it. In the next example, we ask you to
    prove that if `a` is a bound on `s` and `a ≤ b`, then `b` is a bound on `s` as
    well.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们为函数定义了 `FnUb` 一样，我们可以定义 `SetUb s a` 来表示 `a` 是集合 `s` 的上界，假设 `s` 是具有某种类型元素的集合，并且与它相关联一个顺序。在下一个例子中，我们要求你证明如果
    `a` 是 `s` 的一个界且 `a ≤ b`，那么 `b` 也是 `s` 的一个界。
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We close this section with one last important example. A function \(f\) is said
    to be *injective* if for every \(x_1\) and \(x_2\), if \(f(x_1) = f(x_2)\) then
    \(x_1 = x_2\). Mathlib defines `Function.Injective f` with `x₁` and `x₂` implicit.
    The next example shows that, on the real numbers, any function that adds a constant
    is injective. We then ask you to show that multiplication by a nonzero constant
    is also injective, using the lemma name in the example as a source of inspiration.
    Recall you should use Ctrl-space completion after guessing the beginning of a
    lemma name.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一个最后的、非常重要的例子结束本节。如果一个函数 \(f\) 对于每一个 \(x_1\) 和 \(x_2\)，如果 \(f(x_1) = f(x_2)\)
    则 \(x_1 = x_2\)，那么称这个函数为 *单射*。Mathlib 使用 `Function.Injective f` 并隐含地定义 `x₁` 和
    `x₂`。下一个例子展示了在实数上，任何加常数的函数都是单射的。然后我们要求你使用例子中的引理名称作为灵感来源，证明乘以非零常数也是单射的。回忆一下，在猜测引理名称的开始后，你应该使用
    Ctrl-space 完成提示。
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, show that the composition of two injective functions is injective:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，证明两个单射函数的复合也是单射：
- en: '[PRE18]  ## 3.2\. The Existential Quantifier[](#the-existential-quantifier
    "Link to this heading")'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE18]  ## 3.2\. 存在量词[](#the-existential-quantifier "链接到这个标题")'
- en: 'The existential quantifier, which can be entered as `\ex` in VS Code, is used
    to represent the phrase “there exists.” The formal expression `∃ x : ℝ, 2 < x
    ∧ x < 3` in Lean says that there is a real number between 2 and 3. (We will discuss
    the conjunction symbol, `∧`, in [Section 3.4](#conjunction-and-biimplication).)
    The canonical way to prove such a statement is to exhibit a real number and show
    that it has the stated property. The number 2.5, which we can enter as `5 / 2`
    or `(5 : ℝ) / 2` when Lean cannot infer from context that we have the real numbers
    in mind, has the required property, and the `norm_num` tactic can prove that it
    meets the description.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '存在量词，在 VS Code 中可以输入为 `\ex`，用来表示“存在”这个短语。在 Lean 中的形式表达式 `∃ x : ℝ, 2 < x ∧ x
    < 3` 表示存在一个实数在 2 和 3 之间。（我们将在 [第 3.4 节](#conjunction-and-biimplication) 中讨论合取符号
    `∧`。）证明此类陈述的规范方法是展示一个实数并证明它具有所述的性质。数字 2.5，当我们不能从上下文中推断出我们指的是实数时，可以输入为 `5 / 2`
    或 `(5 : ℝ) / 2`，它具有所需性质，而 `norm_num` 战术可以证明它符合描述。'
- en: There are a few ways we can put the information together. Given a goal that
    begins with an existential quantifier, the `use` tactic is used to provide the
    object, leaving the goal of proving the property.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方法可以将信息组合起来。给定一个以存在量词开始的目標，`use` 战术用于提供对象，留下证明性质的目標。
- en: '[PRE19]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can give the `use` tactic proofs as well as data:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以给出 `use` 战术的证明以及数据：
- en: '[PRE20]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In fact, the `use` tactic automatically tries to use available assumptions as
    well.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`use` 战术会自动尝试使用可用的假设。
- en: '[PRE21]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Alternatively, we can use Lean’s *anonymous constructor* notation to construct
    a proof of an existential quantifier.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 Lean 的 *匿名构造函数* 符号来构造存在量词的证明。
- en: '[PRE22]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Notice that there is no `by`; here we are giving an explicit proof term. The
    left and right angle brackets, which can be entered as `\<` and `\>` respectively,
    tell Lean to put together the given data using whatever construction is appropriate
    for the current goal. We can use the notation without going first into tactic
    mode:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里没有 `by`；我们在这里给出一个明确的证明项。左右尖括号，分别可以用 `\<` 和 `\>` 输入，告诉 Lean 使用适合当前目标的任何构造来组合给定的数据。我们可以在不首先进入战术模式的情况下使用这种符号：
- en: '[PRE23]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So now we know how to *prove* an exists statement. But how do we *use* one?
    If we know that there exists an object with a certain property, we should be able
    to give a name to an arbitrary one and reason about it. For example, remember
    the predicates `FnUb f a` and `FnLb f a` from the last section, which say that
    `a` is an upper bound or lower bound on `f`, respectively. We can use the existential
    quantifier to say that “`f` is bounded” without specifying the bound:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在知道了如何 *证明* 存在语句。但我们如何 *使用* 它呢？如果我们知道存在具有某种性质的物体，我们应该能够给它一个任意的名字并对它进行推理。例如，记住上一节中的谓词
    `FnUb f a` 和 `FnLb f a`，它们分别表示 `a` 是 `f` 的上界或下界。我们可以使用存在量词来说明“`f` 有界”，而不必指定界限：
- en: '[PRE24]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can use the theorem `FnUb_add` from the last section to prove that if `f`
    and `g` have upper bounds, then so does `fun x ↦ f x + g x`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用上一节中的定理 `FnUb_add` 来证明，如果 `f` 和 `g` 有上界，那么 `fun x ↦ f x + g x` 也有上界。
- en: '[PRE25]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `rcases` tactic unpacks the information in the existential quantifier.
    The annotations like `⟨a, ubfa⟩`, written with the same angle brackets as the
    anonymous constructors, are known as *patterns*, and they describe the information
    that we expect to find when we unpack the main argument. Given the hypothesis
    `ubf` that there is an upper bound for `f`, `rcases ubf with ⟨a, ubfa⟩` adds a
    new variable `a` for an upper bound to the context, together with the hypothesis
    `ubfa` that it has the given property. The goal is left unchanged; what *has*
    changed is that we can now use the new object and the new hypothesis to prove
    the goal. This is a common method of reasoning in mathematics: we unpack objects
    whose existence is asserted or implied by some hypothesis, and then use it to
    establish the existence of something else.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`rcases` 策略解包存在量词中的信息。像 `⟨a, ubfa⟩` 这样的注释，用与匿名构造函数相同的尖括号书写，被称为 *模式*，它们描述了我们解包主参数时预期找到的信息。给定存在上界的假设
    `ubf`，`rcases ubf with ⟨a, ubfa⟩` 将一个新的变量 `a`（上界）添加到上下文中，以及具有给定属性的假设 `ubfa`。目标保持不变；*改变*的是，我们现在可以使用新的对象和新的假设来证明目标。这是数学中常见的推理方法：我们解包由某些假设断言或暗示存在的对象，然后使用它来建立其他事物的存在。'
- en: Try using this method to establish the following. You might find it useful to
    turn some of the examples from the last section into named theorems, as we did
    with `fn_ub_add`, or you can insert the arguments directly into the proofs.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用这种方法来建立以下内容。你可能发现将上一节中的某些示例转换为命名定理很有用，就像我们对待 `fn_ub_add` 一样，或者你可以直接将参数插入到证明中。
- en: '[PRE26]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The “r” in `rcases` stands for “recursive,” because it allows us to use arbitrarily
    complex patterns to unpack nested data. The `rintro` tactic is a combination of
    `intro` and `rcases`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`rcases` 中的“r”代表“递归”，因为它允许我们使用任意复杂的模式来解包嵌套数据。`rintro` 策略是 `intro` 和 `rcases`
    的组合：'
- en: '[PRE27]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In fact, Lean also supports a pattern-matching fun in expressions and proof
    terms:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Lean 还支持在表达式和证明项中使用模式匹配函数：
- en: '[PRE28]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The task of unpacking information in a hypothesis is so important that Lean
    and Mathlib provide a number of ways to do it. For example, the `obtain` tactic
    provides suggestive syntax:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在假设中解包信息这项任务非常重要，以至于 Lean 和 Mathlib 提供了多种方法来完成它。例如，`obtain` 策略提供了提示性语法：
- en: '[PRE29]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Think of the first `obtain` instruction as matching the “contents” of `ubf`
    with the given pattern and assigning the components to the named variables. `rcases`
    and `obtain` are said to `destruct` their arguments.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将第一个 `obtain` 指令视为将 `ubf` 的“内容”与给定的模式进行匹配，并将组件分配给命名变量。`rcases` 和 `obtain` 被说成是“破坏”它们的参数。
- en: 'Lean also supports syntax that is similar to that used in other functional
    programming languages:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 还支持与其它函数式编程语言中使用的语法类似的语法：
- en: '[PRE30]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the first example, if you put your cursor after `cases ubf`, you will see
    that the tactic produces a single goal, which Lean has tagged `intro`. (The particular
    name chosen comes from the internal name for the axiomatic primitive that builds
    a proof of an existential statement.) The `case` tactic then names the components.
    The second example is similar, except using `next` instead of `case` means that
    you can avoid mentioning `intro`. The word `match` in the last two examples highlights
    that what we are doing here is what computer scientists call “pattern matching.”
    Notice that the third proof begins by `by`, after which the tactic version of
    `match` expects a tactic proof on the right side of the arrow. The last example
    is a proof term: there are no tactics in sight.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，如果你将光标放在 `cases ubf` 之后，你会看到这个策略产生了一个单一的目标，Lean 将其标记为 `intro`。（所选择的特定名称来自构建存在性陈述证明的公理原语的内部名称。）然后
    `case` 策略命名了组件。第二个例子与第一个类似，只是使用 `next` 而不是 `case` 意味着你不必提到 `intro`。在最后两个例子中，单词
    `match` 突出了我们在这里所做的是计算机科学家所说的“模式匹配”。请注意，第三个证明以 `by` 开头，之后 `match` 的策略版本期望箭头右侧有一个策略证明。最后一个例子是一个证明项：没有看到任何策略。
- en: For the rest of this book, we will stick to `rcases`, `rintro`, and `obtain`,
    as the preferred ways of using an existential quantifier. But it can’t hurt to
    see the alternative syntax, especially if there is a chance you will find yourself
    in the company of computer scientists.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将坚持使用 `rcases`、`rintro` 和 `obtain` 作为使用存在量词的首选方式。但看看替代语法也无妨，尤其是如果你有可能与计算机科学家为伍的话。
- en: 'To illustrate one way that `rcases` can be used, we prove an old mathematical
    chestnut: if two integers `x` and `y` can each be written as a sum of two squares,
    then so can their product, `x * y`. In fact, the statement is true for any commutative
    ring, not just the integers. In the next example, `rcases` unpacks two existential
    quantifiers at once. We then provide the magic values needed to express `x * y`
    as a sum of squares as a list to the `use` statement, and we use `ring` to verify
    that they work.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 `rcases` 可以使用的一种方式，我们证明了一个古老的数学难题：如果两个整数 `x` 和 `y` 可以分别表示为两个平方的和，那么它们的乘积
    `x * y` 也可以。实际上，这个陈述对于任何交换环都成立，而不仅仅是整数。在下一个例子中，`rcases` 一次展开两个存在量词。然后我们提供一个列表，其中包含将
    `x * y` 表示为平方和所需的神奇值，并将其作为 `use` 语句的参数，并使用 `ring` 来验证它们是否有效。
- en: '[PRE31]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This proof doesn’t provide much insight, but here is one way to motivate it.
    A *Gaussian integer* is a number of the form \(a + bi\) where \(a\) and \(b\)
    are integers and \(i = \sqrt{-1}\). The *norm* of the Gaussian integer \(a + bi\)
    is, by definition, \(a^2 + b^2\). So the norm of a Gaussian integer is a sum of
    squares, and any sum of squares can be expressed in this way. The theorem above
    reflects the fact that norm of a product of Gaussian integers is the product of
    their norms: if \(x\) is the norm of \(a + bi\) and \(y\) in the norm of \(c +
    di\), then \(xy\) is the norm of \((a + bi) (c + di)\). Our cryptic proof illustrates
    the fact that the proof that is easiest to formalize isn’t always the most perspicuous
    one. In [Section 7.3](C07_Structures.html#section-building-the-gaussian-integers),
    we will provide you with the means to define the Gaussian integers and use them
    to provide an alternative proof.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个证明并没有提供很多洞见，但这里有一种激发它的方法。一个**高斯整数**是形如 \(a + bi\) 的数，其中 \(a\) 和 \(b\) 是整数，\(i
    = \sqrt{-1}\)。根据定义，高斯整数 \(a + bi\) 的**范数**是 \(a^2 + b^2\)。因此，高斯整数的范数是平方和，任何平方和都可以用这种方式表示。上述定理反映了高斯整数乘积的范数是它们范数的乘积这一事实：如果
    \(x\) 是 \(a + bi\) 的范数，\(y\) 是 \(c + di\) 的范数，那么 \(xy\) 就是 \((a + bi) (c + di)\)
    的范数。我们神秘的证明说明了这样一个事实：最容易形式化的证明并不总是最清晰的。在[第7.3节](C07_Structures.html#section-building-the-gaussian-integers)中，我们将提供定义高斯整数并使用它们提供另一种证明的方法。
- en: 'The pattern of unpacking an equation inside an existential quantifier and then
    using it to rewrite an expression in the goal comes up often, so much so that
    the `rcases` tactic provides an abbreviation: if you use the keyword `rfl` in
    place of a new identifier, `rcases` does the rewriting automatically (this trick
    doesn’t work with pattern-matching lambdas).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在存在量词内部展开方程并使用它来重写目标表达式的模式经常出现，以至于 `rcases` 策略提供了一个缩写：如果你用关键字 `rfl` 代替新标识符，`rcases`
    会自动进行重写（这个技巧与模式匹配的lambda表达式不兼容）。
- en: '[PRE32]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As with the universal quantifier, you can find existential quantifiers hidden
    all over if you know how to spot them. For example, divisibility is implicitly
    an “exists” statement.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 就像全称量词一样，如果你知道如何识别，你可以在任何地方找到隐藏的存在量词。例如，可除性隐含地是一个“存在”陈述。
- en: '[PRE33]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: And once again, this provides a nice setting for using `rcases` with `rfl`.
    Try it out in the proof above. It feels pretty good!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这为使用 `rcases` 和 `rfl` 提供了一个很好的环境。在上面的证明中尝试一下。感觉非常好！
- en: 'Then try proving the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后尝试证明以下内容：
- en: '[PRE34]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For another important example, a function \(f : \alpha \to \beta\) is said
    to be *surjective* if for every \(y\) in the codomain, \(\beta\), there is an
    \(x\) in the domain, \(\alpha\), such that \(f(x) = y\). Notice that this statement
    includes both a universal and an existential quantifier, which explains why the
    next example makes use of both `intro` and `use`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '对于另一个重要的例子，一个函数 \(f : \alpha \to \beta\) 被称为 *外射*，如果对于域 \(\alpha\) 中的每个 \(y\)，在陪域
    \(\beta\) 中都有一个 \(x\)，使得 \(f(x) = y\)。注意，这个陈述包括全称量词和存在量词，这也解释了为什么下一个例子会同时使用 `intro`
    和 `use`。'
- en: '[PRE35]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Try this example yourself using the theorem `mul_div_cancel₀`.:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用定理 `mul_div_cancel₀` 自己做这个例子。
- en: '[PRE36]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: At this point, it is worth mentioning that there is a tactic, `field_simp`,
    that will often clear denominators in a useful way. It can be used in conjunction
    with the `ring` tactic.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，值得提到的是，有一个策略 `field_simp`，它通常会以有用的方式消除分母。它可以与 `ring` 策略一起使用。
- en: '[PRE37]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The next example uses a surjectivity hypothesis by applying it to a suitable
    value. Note that you can use `rcases` with any expression, not just a hypothesis.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子通过应用到一个合适的值来使用外射性假设。请注意，你可以用 `rcases` 与任何表达式一起使用，而不仅仅是假设。
- en: '[PRE38]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: See if you can use these methods to show that the composition of surjective
    functions is surjective.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用这些方法来证明外射函数的合成仍然是外射的。
- en: '[PRE39]  ## 3.3\. Negation[](#negation "Link to this heading")'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE39]  ## 3.3\. 否定[](#negation "链接到这个标题")'
- en: 'The symbol `¬` is meant to express negation, so `¬ x < y` says that `x` is
    not less than `y`, `¬ x = y` (or, equivalently, `x ≠ y`) says that `x` is not
    equal to `y`, and `¬ ∃ z, x < z ∧ z < y` says that there does not exist a `z`
    strictly between `x` and `y`. In Lean, the notation `¬ A` abbreviates `A → False`,
    which you can think of as saying that `A` implies a contradiction. Practically
    speaking, this means that you already know something about how to work with negations:
    you can prove `¬ A` by introducing a hypothesis `h : A` and proving `False`, and
    if you have `h : ¬ A` and `h'' : A`, then applying `h` to `h''` yields `False`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '符号 `¬` 用于表示否定，所以 `¬ x < y` 表示 `x` 不小于 `y`，`¬ x = y`（或等价地，`x ≠ y`）表示 `x` 不等于
    `y`，而 `¬ ∃ z, x < z ∧ z < y` 表示不存在一个 `z` 在 `x` 和 `y` 之间。在 Lean 中，符号 `¬ A` 缩写为
    `A → False`，你可以将其视为 `A` 导致矛盾。实际上，这意味着你已经知道如何处理否定：你可以通过引入一个假设 `h : A` 并证明 `False`
    来证明 `¬ A`，如果你有 `h : ¬ A` 和 `h'' : A`，那么将 `h` 应用到 `h''` 上会产生 `False`。'
- en: To illustrate, consider the irreflexivity principle `lt_irrefl` for a strict
    order, which says that we have `¬ a < a` for every `a`. The asymmetry principle
    `lt_asymm` says that we have `a < b → ¬ b < a`. Let’s show that `lt_asymm` follows
    from `lt_irrefl`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，考虑严格顺序的不自反原理 `lt_irrefl`，它表示对于每个 `a`，我们有 `¬ a < a`。不对称原理 `lt_asymm` 表示
    `a < b → ¬ b < a`。让我们证明 `lt_asymm` 可以从 `lt_irrefl` 推导出来。
- en: '[PRE40]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This example introduces a couple of new tricks. First, when you use `have` without
    providing a label, Lean uses the name `this`, providing a convenient way to refer
    back to it. Because the proof is so short, we provide an explicit proof term.
    But what you should really be paying attention to in this proof is the result
    of the `intro` tactic, which leaves a goal of `False`, and the fact that we eventually
    prove `False` by applying `lt_irrefl` to a proof of `a < a`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子介绍了一些新的技巧。首先，当你使用 `have` 而不提供标签时，Lean 使用名称 `this`，提供了一种方便的回指方式。因为证明非常简短，所以我们提供了一个显式的证明项。但在这个证明中，你应该真正关注的是
    `intro` 策略的结果，它留下一个 `False` 的目标，以及我们最终通过将 `lt_irrefl` 应用到 `a < a` 的证明上来证明 `False`
    的事实。
- en: Here is another example, which uses the predicate `FnHasUb` defined in the last
    section, which says that a function has an upper bound.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子，它使用了上一节中定义的谓词 `FnHasUb`，它表示一个函数有一个上界。
- en: '[PRE41]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Remember that it is often convenient to use `linarith` when a goal follows from
    linear equations and inequalities that are in the context.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当目标可以从上下文中的线性方程和不等式推导出来时，使用 `linarith` 通常很方便。
- en: 'See if you can prove these in a similar way:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以类似的方式证明这些：
- en: '[PRE42]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Mathlib offers a number of useful theorems for relating orders and negations:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib提供了一些有用的定理，用于关联顺序和否定：
- en: '[PRE43]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Recall the predicate `Monotone f`, which says that `f` is nondecreasing. Use
    some of the theorems just enumerated to prove the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 回忆一下谓词`Monotone f`，它表示`f`是非递减的。使用刚刚列举的一些定理来证明以下结论：
- en: '[PRE44]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We can show that the first example in the last snippet cannot be proved if we
    replace `<` by `≤`. Notice that we can prove the negation of a universally quantified
    statement by giving a counterexample. Complete the proof.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以证明，如果我们将最后一段代码中的`<`替换为`≤`，那么第一个例子无法被证明。注意，我们可以通过给出反例来证明全称量化语句的否定。完成证明。
- en: '[PRE45]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This example introduces the `let` tactic, which adds a *local definition* to
    the context. If you put the cursor after the `let` command, in the goal window
    you will see that the definition `f : ℝ → ℝ := fun x ↦ 0` has been added to the
    context. Lean will unfold the definition of `f` when it has to. In particular,
    when we prove `f 1 ≤ f 0` with `le_refl`, Lean reduces `f 1` and `f 0` to `0`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '本例介绍了`let`策略，该策略向上下文中添加一个*局部定义*。如果你将光标放在`let`命令之后，在目标窗口中你会看到定义`f : ℝ → ℝ :=
    fun x ↦ 0`已经被添加到上下文中。当Lean需要时，它会展开`f`的定义。特别是，当我们使用`le_refl`证明`f 1 ≤ f 0`时，Lean会将`f
    1`和`f 0`简化为`0`。'
- en: 'Use `le_of_not_gt` to prove the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`le_of_not_gt`来证明以下结论：
- en: '[PRE46]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Implicit in many of the proofs we have just done is the fact that if `P` is
    any property, saying that there is nothing with property `P` is the same as saying
    that everything fails to have property `P`, and saying that not everything has
    property `P` is equivalent to saying that something fails to have property `P`.
    In other words, all four of the following implications are valid (but one of them
    cannot be proved with what we explained so far):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚做的许多证明中隐含的事实是，如果`P`是任何属性，说没有任何具有属性`P`的东西等同于说所有东西都没有属性`P`，而说不是所有东西都有属性`P`等同于说有些东西没有属性`P`。换句话说，以下四个蕴含都是有效的（但其中之一不能使用我们之前解释的方法来证明）：
- en: '[PRE47]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The first, second, and fourth are straightforward to prove using the methods
    you have already seen. We encourage you to try it. The third is more difficult,
    however, because it concludes that an object exists from the fact that its nonexistence
    is contradictory. This is an instance of *classical* mathematical reasoning. We
    can use proof by contradiction to prove the third implication as follows.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第一、第二和第四个结论使用你已见过的方法证明起来很简单。我们鼓励你尝试一下。然而，第三个结论比较困难，因为它从其不存在是矛盾的这一事实中得出一个对象存在的结论。这是一个*经典*数学推理的例子。我们可以通过反证法证明第三个蕴含如下。
- en: '[PRE48]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Make sure you understand how this works. The `by_contra` tactic allows us to
    prove a goal `Q` by assuming `¬ Q` and deriving a contradiction. In fact, it is
    equivalent to using the equivalence `not_not : ¬ ¬ Q ↔ Q`. Confirm that you can
    prove the forward direction of this equivalence using `by_contra`, while the reverse
    direction follows from the ordinary rules for negation.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '确保你理解这是如何工作的。`by_contra`策略允许我们通过假设`¬ Q`并推导出矛盾来证明目标`Q`。实际上，它等价于使用等价性`not_not
    : ¬ ¬ Q ↔ Q`。确认你可以使用`by_contra`证明这个等价性的正向方向，而反向方向则遵循普通的否定规则。'
- en: '[PRE49]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Use proof by contradiction to establish the following, which is the converse
    of one of the implications we proved above. (Hint: use `intro` first.)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反证法来证明以下结论，这是我们之前证明的一个蕴含的逆命题。（提示：首先使用`intro`。）
- en: '[PRE50]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: It is often tedious to work with compound statements with a negation in front,
    and it is a common mathematical pattern to replace such statements with equivalent
    forms in which the negation has been pushed inward. To facilitate this, Mathlib
    offers a `push_neg` tactic, which restates the goal in this way. The command `push_neg
    at h` restates the hypothesis `h`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 处理带有否定前缀的复合语句通常很繁琐，将这样的语句替换为等价形式，其中否定已经被推向内部，是一种常见的数学模式。为了方便这一操作，Mathlib提供了一个`push_neg`策略，它以这种方式重新表述目标。命令`push_neg
    at h`重新表述了假设`h`。
- en: '[PRE51]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the second example, we use dsimp to expand the definitions of `FnHasUb`
    and `FnUb`. (We need to use `dsimp` rather than `rw` to expand `FnUb`, because
    it appears in the scope of a quantifier.) You can verify that in the examples
    above with `¬∃ x, P x` and `¬∀ x, P x`, the `push_neg` tactic does the expected
    thing. Without even knowing how to use the conjunction symbol, you should be able
    to use `push_neg` to prove the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，我们使用 `dsimp` 来展开 `FnHasUb` 和 `FnUb` 的定义。（我们需要使用 `dsimp` 而不是 `rw` 来展开
    `FnUb`，因为它出现在量词的作用域内。）你可以验证在上述示例中，使用 `¬∃ x, P x` 和 `¬∀ x, P x`，`push_neg` 策略做了预期的事情。即使不知道如何使用合取符号，你也应该能够使用
    `push_neg` 来证明以下内容：
- en: '[PRE52]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Mathlib also has a tactic, `contrapose`, which transforms a goal `A → B` to
    `¬B → ¬A`. Similarly, given a goal of proving `B` from hypothesis `h : A`, `contrapose
    h` leaves you with a goal of proving `¬A` from hypothesis `¬B`. Using `contrapose!`
    instead of `contrapose` applies `push_neg` to the goal and the relevant hypothesis
    as well.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 'Mathlib 还有一个策略，`contrapose`，它将目标 `A → B` 转换为 `¬B → ¬A`。同样，给定一个从假设 `h : A` 证明
    `B` 的目标，`contrapose h` 使你留下一个从假设 `¬B` 证明 `¬A` 的目标。使用 `contrapose!` 而不是 `contrapose`
    将 `push_neg` 应用到目标和相关假设上。'
- en: '[PRE53]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We have not yet explained the `constructor` command or the use of the semicolon
    after it, but we will do that in the next section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有解释 `constructor` 命令或其后分号的用法，但我们将在这下一节中解释。
- en: We close this section with the principle of *ex falso*, which says that anything
    follows from a contradiction. In Lean, this is represented by `False.elim`, which
    establishes `False → P` for any proposition `P`. This may seem like a strange
    principle, but it comes up fairly often. We often prove a theorem by splitting
    on cases, and sometimes we can show that one of the cases is contradictory. In
    that case, we need to assert that the contradiction establishes the goal so we
    can move on to the next one. (We will see instances of reasoning by cases in [Section
    3.5](#disjunction).)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以 *ex falso* 原则结束本节，该原则表明任何东西都可以从矛盾中得出。在 Lean 中，这表示为 `False.elim`，它为任何命题 `P`
    建立了 `False → P`。这看起来可能像是一个奇怪的原则，但它相当常见。我们经常通过分情况证明定理，有时我们可以表明其中一种情况是矛盾的。在这种情况下，我们需要断言矛盾建立了目标，这样我们就可以继续下一个目标。（我们将在
    [第 3.5 节](#disjunction) 中看到推理的例子。）
- en: Lean provides a number of ways of closing a goal once a contradiction has been
    reached.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 提供了多种在达到矛盾后关闭目标的方法。
- en: '[PRE54]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `exfalso` tactic replaces the current goal with the goal of proving `False`.
    Given `h : P` and `h'' : ¬ P`, the term `absurd h h''` establishes any proposition.
    Finally, the `contradiction` tactic tries to close a goal by finding a contradiction
    in the hypotheses, such as a pair of the form `h : P` and `h'' : ¬ P`. Of course,
    in this example, `linarith` also works.  ## 3.4\. Conjunction and Iff[](#conjunction-and-iff
    "Link to this heading")'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`exfalso` 策略将当前目标替换为证明 `False` 的目标。给定 `h : P` 和 `h'' : ¬ P`，项 `absurd h h''`
    建立了任何命题。最后，`contradiction` 策略试图通过在假设中找到一个矛盾来关闭目标，例如形式为 `h : P` 和 `h'' : ¬ P` 的一对。当然，在这个例子中，`linarith`
    也同样有效。## 3.4. 合取与双条件[](#conjunction-and-iff "链接到本标题")'
- en: You have already seen that the conjunction symbol, `∧`, is used to express “and.”
    The `constructor` tactic allows you to prove a statement of the form `A ∧ B` by
    proving `A` and then proving `B`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到合取符号 `∧` 用于表示“和”。`constructor` 策略允许你通过先证明 `A` 然后证明 `B` 来证明形式为 `A ∧ B` 的陈述。
- en: '[PRE55]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In this example, the `assumption` tactic tells Lean to find an assumption that
    will solve the goal. Notice that the final `rw` finishes the goal by applying
    the reflexivity of `≤`. The following are alternative ways of carrying out the
    previous examples using the anonymous constructor angle brackets. The first is
    a slick proof-term version of the previous proof, which drops into tactic mode
    at the keyword `by`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`assumption` 策略告诉 Lean 寻找一个假设来解决问题。注意，最后的 `rw` 通过应用 `≤` 的自反性来完成目标。以下是通过匿名构造器尖括号执行先前示例的替代方法。第一种是先前证明的简洁证明术语版本，它在
    `by` 关键字处进入策略模式。
- en: '[PRE56]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '*Using* a conjunction instead of proving one involves unpacking the proofs
    of the two parts. You can use the `rcases` tactic for that, as well as `rintro`
    or a pattern-matching `fun`, all in a manner similar to the way they are used
    with the existential quantifier.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用* 合取而不是证明一个合取涉及展开两个部分的证明。你可以使用 `rcases` 策略，以及 `rintro` 或模式匹配的 `fun`，所有这些都在与存在量词使用类似的方式下进行。'
- en: '[PRE57]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In analogy to the `obtain` tactic, there is also a pattern-matching `have`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `obtain` 策略，还有一个模式匹配的 `have`：
- en: '[PRE58]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In contrast to `rcases`, here the `have` tactic leaves `h` in the context.
    And even though we won’t use them, once again we have the computer scientists’
    pattern-matching syntax:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `rcases` 不同，这里 `have` 策略将 `h` 留在上下文中。即使我们不会使用它们，我们再次有了计算机科学家的模式匹配语法：
- en: '[PRE59]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In contrast to using an existential quantifier, you can also extract proofs
    of the two components of a hypothesis `h : A ∧ B` by writing `h.left` and `h.right`,
    or, equivalently, `h.1` and `h.2`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '与使用存在量词相比，你还可以通过编写 `h.left` 和 `h.right`，或者等价地，`h.1` 和 `h.2` 来提取假设 `h : A ∧
    B` 的两个组成部分的证明。'
- en: '[PRE60]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Try using these techniques to come up with various ways of proving of the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用这些技术来提出证明以下内容的各种方法：
- en: '[PRE61]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: You can nest uses of `∃` and `∧` with anonymous constructors, `rintro`, and
    `rcases`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用匿名构造函数、`rintro` 和 `rcases` 嵌套使用 `∃` 和 `∧`。
- en: '[PRE62]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You can also use the `use` tactic:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `use` 策略：
- en: '[PRE63]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the first example, the semicolon after the `constructor` command tells Lean
    to use the `norm_num` tactic on both of the goals that result.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，`constructor` 命令后面的分号告诉 Lean 对产生的两个目标都使用 `norm_num` 策略。
- en: 'In Lean, `A ↔ B` is *not* defined to be `(A → B) ∧ (B → A)`, but it could have
    been, and it behaves roughly the same way. You have already seen that you can
    write `h.mp` and `h.mpr` or `h.1` and `h.2` for the two directions of `h : A ↔
    B`. You can also use `cases` and friends. To prove an if-and-only-if statement,
    you can use `constructor` or angle brackets, just as you would if you were proving
    a conjunction.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '在 Lean 中，`A ↔ B` 并不是定义为 `(A → B) ∧ (B → A)`，但它本来可以是，并且其行为大致相同。你已经看到你可以为 `h
    : A ↔ B` 的两个方向编写 `h.mp` 和 `h.mpr` 或 `h.1` 和 `h.2`。你也可以使用 `cases` 和相关工具。为了证明一个“如果且仅如果”的陈述，你可以使用
    `constructor` 或尖括号，就像你证明合取一样。'
- en: '[PRE64]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The last proof term is inscrutable. Remember that you can use underscores while
    writing an expression like that to see what Lean expects.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个证明项难以理解。记住，在编写这样的表达式时，你可以使用下划线来查看 Lean 期望的内容。
- en: 'Try out the various techniques and gadgets you have just seen in order to prove
    the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用你刚刚看到的各种技术和工具来证明以下内容：
- en: '[PRE65]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: For a more interesting exercise, show that for any two real numbers `x` and
    `y`, `x^2 + y^2 = 0` if and only if `x = 0` and `y = 0`. We suggest proving an
    auxiliary lemma using `linarith`, `pow_two_nonneg`, and `pow_eq_zero`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个更有趣的练习，证明对于任何两个实数 `x` 和 `y`，`x^2 + y^2 = 0` 当且仅当 `x = 0` 和 `y = 0`。我们建议使用
    `linarith`、`pow_two_nonneg` 和 `pow_eq_zero` 证明一个辅助引理。
- en: '[PRE66]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In Lean, bi-implication leads a double-life. You can treat it like a conjunction
    and use its two parts separately. But Lean also knows that it is a reflexive,
    symmetric, and transitive relation between propositions, and you can also use
    it with `calc` and `rw`. It is often convenient to rewrite a statement to an equivalent
    one. In the next example, we use `abs_lt` to replace an expression of the form
    `|x| < y` by the equivalent expression `- y < x ∧ x < y`, and in the one after
    that we use `Nat.dvd_gcd_iff` to replace an expression of the form `m ∣ Nat.gcd
    n k` by the equivalent expression `m ∣ n ∧ m ∣ k`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lean 中，双条件具有双重生命。你可以将其视为合取，并分别使用其两部分。但 Lean 也知道它是一个命题之间的自反、对称和传递关系，你也可以使用它与
    `calc` 和 `rw` 一起。将一个陈述重写为等价陈述通常很方便。在下一个例子中，我们使用 `abs_lt` 将形式为 `|x| < y` 的表达式替换为等价表达式
    `- y < x ∧ x < y`，在下一个例子中，我们使用 `Nat.dvd_gcd_iff` 将形式为 `m ∣ Nat.gcd n k` 的表达式替换为等价表达式
    `m ∣ n ∧ m ∣ k`。
- en: '[PRE67]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: See if you can use `rw` with the theorem below to provide a short proof that
    negation is not a nondecreasing function. (Note that `push_neg` won’t unfold definitions
    for you, so the `rw [Monotone]` in the proof of the theorem is needed.)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否可以使用下面的定理中的 `rw` 来提供一个简短的证明，证明否定不是一个非递减函数。（注意，`push_neg` 不会为你展开定义，所以定理证明中的
    `rw [Monotone]` 是必需的。）
- en: '[PRE68]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The remaining exercises in this section are designed to give you some more
    practice with conjunction and bi-implication. Remember that a *partial order*
    is a binary relation that is transitive, reflexive, and antisymmetric. An even
    weaker notion sometimes arises: a *preorder* is just a reflexive, transitive relation.
    For any pre-order `≤`, Lean axiomatizes the associated strict pre-order by `a
    < b ↔ a ≤ b ∧ ¬ b ≤ a`. Show that if `≤` is a partial order, then `a < b` is equivalent
    to `a ≤ b ∧ a ≠ b`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本节剩余的练习旨在让你在合取和双条件方面获得更多实践。记住，一个**偏序**是一个传递的、自反的和反对称的二进制关系。有时会出现一个更弱的概念：**预序**只是一个自反的、传递的关系。对于任何预序
    `≤`，Lean 通过 `a < b ↔ a ≤ b ∧ ¬ b ≤ a` 来公理化相关的严格预序。证明如果 `≤` 是一个偏序，那么 `a < b` 等价于
    `a ≤ b ∧ a ≠ b`：
- en: '[PRE69]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Beyond logical operations, you do not need anything more than `le_refl` and
    `le_trans`. Show that even in the case where `≤` is only assumed to be a preorder,
    we can prove that the strict order is irreflexive and transitive. In the second
    example, for convenience, we use the simplifier rather than `rw` to express `<`
    in terms of `≤` and `¬`. We will come back to the simplifier later, but here we
    are only relying on the fact that it will use the indicated lemma repeatedly,
    even if it needs to be instantiated to different values.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 除了逻辑运算之外，你不需要比 `le_refl` 和 `le_trans` 更多的东西。证明即使 `≤` 只被假设为偏序，我们也可以证明严格顺序是不可自反的和传递的。在第二个例子中，为了方便起见，我们使用简化器而不是
    `rw` 来用 `≤` 和 `¬` 表达 `<`。我们稍后会回到简化器，但在这里我们只依赖于这样一个事实，即它将反复使用指定的引理，即使它需要实例化为不同的值。
- en: '[PRE70]  ## 3.5\. Disjunction[](#disjunction "Link to this heading")'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE70]  ## 3.5\. 析取[](#disjunction "链接到本标题")'
- en: The canonical way to prove a disjunction `A ∨ B` is to prove `A` or to prove
    `B`. The `left` tactic chooses `A`, and the `right` tactic chooses `B`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 证明析取 `A ∨ B` 的标准方法是证明 `A` 或证明 `B`。`left` 策略选择 `A`，而 `right` 策略选择 `B`。
- en: '[PRE71]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We cannot use an anonymous constructor to construct a proof of an “or” because
    Lean would have to guess which disjunct we are trying to prove. When we write
    proof terms we can use `Or.inl` and `Or.inr` instead to make the choice explicitly.
    Here, `inl` is short for “introduction left” and `inr` is short for “introduction
    right.”
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用匿名构造函数来构造“或”的证明，因为 Lean 必须猜测我们正在尝试证明哪个析取项。当我们编写证明项时，我们可以使用 `Or.inl` 和
    `Or.inr` 来代替，以明确做出选择。在这里，`inl` 是“引入左”的简称，而 `inr` 是“引入右”的简称。
- en: '[PRE72]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: It may seem strange to prove a disjunction by proving one side or the other.
    In practice, which case holds usually depends on a case distinction that is implicit
    or explicit in the assumptions and the data. The `rcases` tactic allows us to
    make use of a hypothesis of the form `A ∨ B`. In contrast to the use of `rcases`
    with conjunction or an existential quantifier, here the `rcases` tactic produces
    *two* goals. Both have the same conclusion, but in the first case, `A` is assumed
    to be true, and in the second case, `B` is assumed to be true. In other words,
    as the name suggests, the `rcases` tactic carries out a proof by cases. As usual,
    we can tell Lean what names to use for the hypotheses. In the next example, we
    tell Lean to use the name `h` on each branch.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过证明析取的一侧或另一侧来证明析取可能看起来很奇怪。在实践中，哪个情况成立通常取决于假设和数据中隐含或显含的情况区分。`rcases` 策略允许我们利用形式为
    `A ∨ B` 的假设。与 `rcases` 与合取或存在量词的使用相比，这里 `rcases` 策略产生 *两个* 目标。这两个目标有相同的结论，但在第一种情况下，假设
    `A` 为真，在第二种情况下，假设 `B` 为真。换句话说，正如其名称所暗示的，`rcases` 策略通过分情况证明。像往常一样，我们可以告诉 Lean 使用哪些名称来命名假设。在下一个例子中，我们告诉
    Lean 在每个分支上使用名称 `h`。
- en: '[PRE73]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Notice that the pattern changes from `⟨h₀, h₁⟩` in the case of a conjunction
    to `h₀ | h₁` in the case of a disjunction. Think of the first pattern as matching
    against data the contains *both* an `h₀` and a `h₁`, whereas second pattern, with
    the bar, matches against data that contains *either* an `h₀` or `h₁`. In this
    case, because the two goals are separate, we have chosen to use the same name,
    `h`, in each case.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，模式从合取的情况中的 `⟨h₀, h₁⟩` 变为析取的情况中的 `h₀ | h₁`。将第一个模式视为与包含 `h₀` 和 `h₁` 的数据匹配，而第二个模式，带有竖线，与包含
    `h₀` 或 `h₁` 的数据匹配。在这种情况下，因为两个目标是独立的，所以我们选择在每个情况下使用相同的名称，即 `h`。
- en: The absolute value function is defined in such a way that we can immediately
    prove that `x ≥ 0` implies `|x| = x` (this is the theorem `abs_of_nonneg`) and
    `x < 0` implies `|x| = -x` (this is `abs_of_neg`). The expression `le_or_gt 0
    x` establishes `0 ≤ x ∨ x < 0`, allowing us to split on those two cases.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对值函数被定义为一种方式，我们可以立即证明 `x ≥ 0` 蕴含 `|x| = x`（这是定理 `abs_of_nonneg`），以及 `x < 0`
    蕴含 `|x| = -x`（这是 `abs_of_neg`）。表达式 `le_or_gt 0 x` 建立了 `0 ≤ x ∨ x < 0`，允许我们对这两种情况分别进行分割。
- en: Lean also supports the computer scientists’ pattern-matching syntax for disjunction.
    Now the `cases` tactic is more attractive, because it allows us to name each `case`,
    and name the hypothesis that is introduced closer to where it is used.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 也支持计算机科学家用于析取的匹配语法。现在 `cases` 策略更具吸引力，因为它允许我们为每个 `case` 命名，并为引入的假设命名，使其更接近使用位置。
- en: '[PRE74]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The names `inl` and `inr` are short for “intro left” and “intro right,” respectively.
    Using `case` has the advantage that you can prove the cases in either order; Lean
    uses the tag to find the relevant goal. If you don’t care about that, you can
    use `next`, or `match`, or even a pattern-matching `have`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`inl`和`inr`的名字分别代表“引入左”和“引入右”。使用`case`的优点是你可以在任意顺序证明情况；Lean使用标签来找到相关的目标。如果你不在乎这一点，你可以使用`next`，或者`match`，甚至是一个模式匹配的`have`。'
- en: '[PRE75]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In the case of `match`, we need to use the full names `Or.inl` and `Or.inr`
    of the canonical ways to prove a disjunction. In this textbook, we will generally
    use `rcases` to split on the cases of a disjunction.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在`match`的情况下，我们需要使用证明析取的规范方式`Or.inl`和`Or.inr`的全称。在这本教科书中，我们将一般使用`rcases`来分情况讨论析取。
- en: Try proving the triangle inequality using the first two theorems in the next
    snippet. They are given the same names they have in Mathlib.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用下一个片段中的前两个定理来证明三角不等式。它们在Mathlib中具有相同的名称。
- en: '[PRE76]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In case you enjoyed these (pun intended) and you want more practice with disjunction,
    try these.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢这些（当然，是字面意义上的喜欢）并且想要更多关于析取的练习，试试这些。
- en: '[PRE77]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You can also use `rcases` and `rintro` with nested disjunctions. When these
    result in a genuine case split with multiple goals, the patterns for each new
    goal are separated by a vertical bar.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用嵌套析取的`rcases`和`rintro`。当这些导致具有多个目标的真正情况分割时，每个新目标的模式由一个竖线分隔。
- en: '[PRE78]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'You can still nest patterns and use the `rfl` keyword to substitute equations:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以嵌套模式并使用`rfl`关键字替换方程：
- en: '[PRE79]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: See if you can prove the following with a single (long) line. Use `rcases` to
    unpack the hypotheses and split on cases, and use a semicolon and `linarith` to
    solve each branch.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否可以用一行（长）来证明以下内容。使用`rcases`来展开假设并分情况讨论，并使用分号和`linarith`来解决每个分支。
- en: '[PRE80]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'On the real numbers, an equation `x * y = 0` tells us that `x = 0` or `y =
    0`. In Mathlib, this fact is known as `eq_zero_or_eq_zero_of_mul_eq_zero`, and
    it is another nice example of how a disjunction can arise. See if you can use
    it to prove the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在实数上，一个方程`x * y = 0`告诉我们`x = 0`或`y = 0`。在Mathlib中，这个事实被称为`eq_zero_or_eq_zero_of_mul_eq_zero`，它是析取如何出现的另一个很好的例子。看看你是否可以用它来证明以下内容：
- en: '[PRE81]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Remember that you can use the `ring` tactic to help with calculations.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 记住你可以使用`ring`策略来帮助计算。
- en: 'In an arbitrary ring \(R\), an element \(x\) such that \(x y = 0\) for some
    nonzero \(y\) is called a *left zero divisor*, an element \(x\) such that \(y
    x = 0\) for some nonzero \(y\) is called a *right zero divisor*, and an element
    that is either a left or right zero divisor is called simply a *zero divisor*.
    The theorem `eq_zero_or_eq_zero_of_mul_eq_zero` says that the real numbers have
    no nontrivial zero divisors. A commutative ring with this property is called an
    *integral domain*. Your proofs of the two theorems above should work equally well
    in any integral domain:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在任意环\(R\)中，一个元素\(x\)，如果存在某个非零元素\(y\)使得\(x y = 0\)，则称为**左零因子**；一个元素\(x\)，如果存在某个非零元素\(y\)使得\(y
    x = 0\)，则称为**右零因子**；如果一个元素是左零因子或右零因子，则简单地称为**零因子**。定理`eq_zero_or_eq_zero_of_mul_eq_zero`表明实数没有非平凡零因子。具有这种性质的交换环称为**整环**。你上面两个定理的证明在任意整环中同样适用：
- en: '[PRE82]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In fact, if you are careful, you can prove the first theorem without using commutativity
    of multiplication. In that case, it suffices to assume that `R` is a `Ring` instead
    of an `CommRing`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果你小心的话，可以不用乘法的交换性来证明第一个定理。在这种情况下，只需假设\(R\)是一个`Ring`而不是`CommRing`。
- en: 'Sometimes in a proof we want to split on cases depending on whether some statement
    is true or not. For any proposition `P`, we can use `em P : P ∨ ¬ P`. The name
    `em` is short for “excluded middle.”'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '有时在证明中，我们想要根据某个陈述是否为真来分情况讨论。对于任何命题\(P\)，我们可以使用`em P : P ∨ ¬ P`。`em`这个名字是“排中律”的缩写。'
- en: '[PRE83]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Alternatively, you can use the `by_cases` tactic.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用`by_cases`策略。
- en: '[PRE84]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Notice that the `by_cases` tactic lets you specify a label for the hypothesis
    that is introduced in each branch, in this case, `h'' : P` in one and `h'' : ¬
    P` in the other. If you leave out the label, Lean uses `h` by default. Try proving
    the following equivalence, using `by_cases` to establish one direction.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '注意到`by_cases`策略允许你为每个分支中引入的假设指定一个标签，在这种情况下，`h'' : P`在一个分支中，`h'' : ¬ P`在另一个分支中。如果你省略了标签，Lean默认使用`h`。尝试使用`by_cases`来证明以下等价性，以建立其中一个方向。'
- en: '[PRE85]  ## 3.6\. Sequences and Convergence[](#sequences-and-convergence "Link
    to this heading")'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE85]  ## 3.6\. 序列与收敛[](#sequences-and-convergence "链接到这个标题")'
- en: 'We now have enough skills at our disposal to do some real mathematics. In Lean,
    we can represent a sequence \(s_0, s_1, s_2, \ldots\) of real numbers as a function
    `s : ℕ → ℝ`. Such a sequence is said to *converge* to a number \(a\) if for every
    \(\varepsilon > 0\) there is a point beyond which the sequence remains within
    \(\varepsilon\) of \(a\), that is, there is a number \(N\) such that for every
    \(n \ge N\), \(| s_n - a | < \varepsilon\). In Lean, we can render this as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们已经掌握了足够的技能来做一些真正的数学。在 Lean 中，我们可以将一个实数序列 \(s_0, s_1, s_2, \ldots\) 表示为一个函数
    `s : ℕ → ℝ`。这样的序列被称为 *收敛* 到一个数 \(a\)，如果对于每一个 \(\varepsilon > 0\)，都有一个点，在此点之后序列始终保持在
    \(a\) 的 \(\varepsilon\) 范围内，也就是说，存在一个数 \(N\)，使得对于每一个 \(n \ge N\)，\(| s_n - a |
    < \varepsilon\)。在 Lean 中，我们可以这样表示：'
- en: '[PRE86]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The notation `∀ ε > 0, ...` is a convenient abbreviation for `∀ ε, ε > 0 → ...`,
    and, similarly, `∀ n ≥ N, ...` abbreviates `∀ n, n ≥ N →  ...`. And remember that
    `ε > 0`, in turn, is defined as `0 < ε`, and `n ≥ N` is defined as `N ≤ n`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 `∀ ε > 0, ...` 是 `∀ ε, ε > 0 → ...` 的方便缩写，同样地，`∀ n ≥ N, ...` 缩写为 `∀ n, n
    ≥ N → ...`。并且记住，`ε > 0`，反过来，定义为 `0 < ε`，而 `n ≥ N` 定义为 `N ≤ n`。
- en: In this section, we’ll establish some properties of convergence. But first,
    we will discuss three tactics for working with equality that will prove useful.
    The first, the `ext` tactic, gives us a way of proving that two functions are
    equal. Let \(f(x) = x + 1\) and \(g(x) = 1 + x\) be functions from reals to reals.
    Then, of course, \(f = g\), because they return the same value for every \(x\).
    The `ext` tactic enables us to prove an equation between functions by proving
    that their values are the same at all the values of their arguments.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将建立一些关于收敛的性质。但首先，我们将讨论三种用于处理等式的策略，这些策略将非常有用。第一个，`ext` 策略，为我们提供了一种证明两个函数相等的方法。设
    \(f(x) = x + 1\) 和 \(g(x) = 1 + x\) 是从实数到实数的函数。当然，\(f = g\)，因为它们对于每一个 \(x\) 都返回相同的值。`ext`
    策略使我们能够通过证明在所有参数值上它们的值都相同来证明函数之间的等式。
- en: '[PRE87]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We’ll see later that `ext` is actually more general, and also one can specify
    the name of the variables that appear. For instance you can try to replace `ext`
    with `ext u v` in the above proof. The second tactic, the `congr` tactic, allows
    us to prove an equation between two expressions by reconciling the parts that
    are different:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会看到，`ext` 实际上更通用，并且还可以指定出现的变量的名称。例如，你可以在上面的证明中尝试用 `ext u v` 替换 `ext`。第二个策略，`congr`
    策略，允许我们通过协调不同的部分来证明两个表达式之间的等式：
- en: '[PRE88]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Here the `congr` tactic peels off the `abs` on each side, leaving us to prove
    `a = a - b + b`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`congr` 策略从每一边剥去 `abs`，留下我们证明 `a = a - b + b`。
- en: Finally, the `convert` tactic is used to apply a theorem to a goal when the
    conclusion of the theorem doesn’t quite match. For example, suppose we want to
    prove `a < a * a` from `1 < a`. A theorem in the library, `mul_lt_mul_right`,
    will let us prove `1 * a < a * a`. One possibility is to work backwards and rewrite
    the goal so that it has that form. Instead, the `convert` tactic lets us apply
    the theorem as it is, and leaves us with the task of proving the equations that
    are needed to make the goal match.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`convert` 策略用于在定理的结论不完全匹配目标时应用定理。例如，假设我们想从 `1 < a` 证明 `a < a * a`。库中的一个定理
    `mul_lt_mul_right` 将允许我们证明 `1 * a < a * a`。一种可能的方法是反向工作并重写目标，使其具有那种形式。相反，`convert`
    策略允许我们直接应用定理，并留下证明目标匹配所需方程的任务。
- en: '[PRE89]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'This example illustrates another useful trick: when we apply an expression
    with an underscore and Lean can’t fill it in for us automatically, it simply leaves
    it for us as another goal.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了另一个有用的技巧：当我们应用一个带有下划线的表达式，而 Lean 无法自动为我们填充它时，它就简单地将其留给我们作为另一个目标。
- en: The following shows that any constant sequence \(a, a, a, \ldots\) converges.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子表明，任何常数序列 \(a, a, a, \ldots\) 都会收敛。
- en: '[PRE90]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Lean has a tactic, `simp`, which can often save you the trouble of carrying
    out steps like `rw [sub_self, abs_zero]` by hand. We will tell you more about
    it soon.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 有一个策略，`simp`，它经常可以帮你省去手动执行 `rw [sub_self, abs_zero]` 等步骤的麻烦。我们很快就会告诉你更多关于它的信息。
- en: For a more interesting theorem, let’s show that if `s` converges to `a` and
    `t` converges to `b`, then `fun n ↦ s n + t n` converges to `a + b`. It is helpful
    to have a clear pen-and-paper proof in mind before you start writing a formal
    one. Given `ε` greater than `0`, the idea is to use the hypotheses to obtain an
    `Ns` such that beyond that point, `s` is within `ε / 2` of `a`, and an `Nt` such
    that beyond that point, `t` is within `ε / 2` of `b`. Then, whenever `n` is greater
    than or equal to the maximum of `Ns` and `Nt`, the sequence `fun n ↦ s n + t n`
    should be within `ε` of `a + b`. The following example begins to implement this
    strategy. See if you can finish it off.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个更有趣的定理，让我们证明如果 `s` 收敛到 `a` 且 `t` 收敛到 `b`，那么 `fun n ↦ s n + t n` 收敛到 `a +
    b`。在开始编写正式证明之前，有一个清晰的笔和纸证明是有帮助的。给定大于 `0` 的 `ε`，想法是使用假设来获得一个 `Ns`，使得在那个点之后，`s`
    在 `a` 的 `ε / 2` 范围内，以及一个 `Nt`，使得在那个点之后，`t` 在 `b` 的 `ε / 2` 范围内。然后，每当 `n` 大于或等于
    `Ns` 和 `Nt` 的最大值时，序列 `fun n ↦ s n + t n` 应该在 `a + b` 的 `ε` 范围内。以下示例开始实施这一策略。看看你是否可以完成它。
- en: '[PRE91]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: As hints, you can use `le_of_max_le_left` and `le_of_max_le_right`, and `norm_num`
    can prove `ε / 2 + ε / 2 = ε`. Also, it is helpful to use the `congr` tactic to
    show that `|s n + t n - (a + b)|` is equal to `|(s n - a) + (t n - b)|,` since
    then you can use the triangle inequality. Notice that we marked all the variables
    `s`, `t`, `a`, and `b` implicit because they can be inferred from the hypotheses.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提示，你可以使用 `le_of_max_le_left` 和 `le_of_max_le_right`，并且 `norm_num` 可以证明 `ε
    / 2 + ε / 2 = ε`。此外，使用 `congr` 策略来证明 `|s n + t n - (a + b)|` 等于 `|(s n - a) +
    (t n - b)|` 是有帮助的，因为这样你就可以使用三角不等式。注意，我们标记了所有变量 `s`、`t`、`a` 和 `b` 为隐含的，因为它们可以从假设中推断出来。
- en: Proving the same theorem with multiplication in place of addition is tricky.
    We will get there by proving some auxiliary statements first. See if you can also
    finish off the next proof, which shows that if `s` converges to `a`, then `fun
    n ↦ c * s n` converges to `c * a`. It is helpful to split into cases depending
    on whether `c` is equal to zero or not. We have taken care of the zero case, and
    we have left you to prove the result with the extra assumption that `c` is nonzero.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 用乘法代替加法来证明相同的定理是棘手的。我们将通过首先证明一些辅助陈述来达到这一点。看看你是否也可以完成下一个证明，该证明表明如果 `s` 收敛到 `a`，那么
    `fun n ↦ c * s n` 收敛到 `c * a`。根据 `c` 是否为零来分情况考虑是有帮助的。我们已经处理了零的情况，并留下了额外的假设 `c`
    不为零来证明结果。
- en: '[PRE92]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The next theorem is also independently interesting: it shows that a convergent
    sequence is eventually bounded in absolute value. We have started you off; see
    if you can finish it.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个定理也是独立有趣的：它表明收敛序列最终在绝对值上是有限的。我们已经为你开始了；看看你是否可以完成它。
- en: '[PRE93]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: In fact, the theorem could be strengthened to assert that there is a bound `b`
    that holds for all values of `n`. But this version is strong enough for our purposes,
    and we will see at the end of this section that it holds more generally.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，该定理可以加强到断言存在一个对所有 `n` 的值都成立的界限 `b`。但这个版本对我们来说已经足够强大，我们将在本节末尾看到它具有更一般的适用性。
- en: 'The next lemma is auxiliary: we prove that if `s` converges to `a` and `t`
    converges to `0`, then `fun n ↦ s n * t n` converges to `0`. To do so, we use
    the previous theorem to find a `B` that bounds `s` beyond some point `N₀`. See
    if you can understand the strategy we have outlined and finish the proof.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个引理是辅助性的：我们证明如果 `s` 收敛到 `a` 且 `t` 收敛到 `0`，那么 `fun n ↦ s n * t n` 收敛到 `0`。为此，我们使用前面的定理找到一个
    `B` 来限制 `s` 在某个点 `N₀` 之后。看看你是否能理解我们所概述的策略并完成证明。
- en: '[PRE94]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: If you have made it this far, congratulations! We are now within striking distance
    of our theorem. The following proof finishes it off.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经走到这一步，恭喜你！我们现在已经接近我们的定理了。以下证明完成了它。
- en: '[PRE95]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: For another challenging exercise, try filling out the following sketch of a
    proof that limits are unique. (If you are feeling bold, you can delete the proof
    sketch and try proving it from scratch.)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于另一个具有挑战性的练习，尝试完成以下关于极限唯一的证明草稿。（如果你感到大胆，你可以删除证明草稿并尝试从头开始证明。）
- en: '[PRE96]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We close the section with the observation that our proofs can be generalized.
    For example, the only properties that we have used of the natural numbers is that
    their structure carries a partial order with `min` and `max`. You can check that
    everything still works if you replace `ℕ` everywhere by any linear order `α`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以观察结束本节，即我们的证明可以推广。例如，我们使用的自然数的唯一性质是它们的结构携带一个具有 `min` 和 `max` 的偏序。你可以检查，如果你将
    `ℕ` 在任何地方都替换为任何线性序 `α`，一切仍然有效：
- en: '[PRE97]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: In [Section 11.1](C11_Topology.html#filters), we will see that Mathlib has mechanisms
    for dealing with convergence in vastly more general terms, not only abstracting
    away particular features of the domain and codomain, but also abstracting over
    different types of convergence. [Previous](C02_Basics.html "2\. Basics") [Next](C04_Sets_and_Functions.html
    "4\. Sets and Functions")
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11.1节](C11_Topology.html#filters)中，我们将看到Mathlib有处理收敛性的机制，这些机制在更广泛的范围内，不仅抽象掉了定义域和值域的特定特征，而且还抽象了不同类型的收敛。
    [上一节](C02_Basics.html "2\. Basics") [下一节](C04_Sets_and_Functions.html "4\. Sets
    and Functions")
- en: '* * *'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: © Copyright 2020-2025, Jeremy Avigad, Patrick Massot. Text licensed under CC
    BY 4.0.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: © 版权所有 2020-2025，Jeremy Avigad，Patrick Massot。文本许可协议为CC BY 4.0。
- en: Built with [Sphinx](https://www.sphinx-doc.org/) using a [theme](https://github.com/readthedocs/sphinx_rtd_theme)
    provided by [Read the Docs](https://readthedocs.org). In the last chapter, we
    dealt with equations, inequalities, and basic mathematical statements like “\(x\)
    divides \(y\).” Complex mathematical statements are built up from simple ones
    like these using logical terms like “and,” “or,” “not,” and “if … then,” “every,”
    and “some.” In this chapter, we show you how to work with statements that are
    built up in this way.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[Sphinx](https://www.sphinx-doc.org/)构建，使用[主题](https://github.com/readthedocs/sphinx_rtd_theme)由[Read
    the Docs](https://readthedocs.org)提供。在上一章中，我们处理了方程、不等式和像“\(x\) divides \(y\)”这样的基本数学陈述。复杂的数学陈述是通过使用像“and”、“or”、“not”、“if
    … then”、“every”和“some”这样的逻辑术语从这些简单的陈述构建而成的。在本章中，我们向你展示如何处理以这种方式构建的陈述。
- en: '## 3.1\. Implication and the Universal Quantifier[](#implication-and-the-universal-quantifier
    "Link to this heading")'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '## 3.1\. 蕴涵和全称量词[](#implication-and-the-universal-quantifier "链接到这个标题")'
- en: 'Consider the statement after the `#check`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`#check`之后的陈述：
- en: '[PRE98]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'In words, we would say “for every real number `x`, if `0 ≤ x` then the absolute
    value of `x` equals `x`”. We can also have more complicated statements like:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 用话来说，我们会说“对于每一个实数`x`，如果`0 ≤ x`则`x`的绝对值等于`x`”。我们也可以有更复杂的陈述，例如：
- en: '[PRE99]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: In words, we would say “for every `x`, `y`, and `ε`, if `0 < ε ≤ 1`, the absolute
    value of `x` is less than `ε`, and the absolute value of `y` is less than `ε`,
    then the absolute value of `x * y` is less than `ε`.” In Lean, in a sequence of
    implications there are implicit parentheses grouped to the right. So the expression
    above means “if `0 < ε` then if `ε ≤ 1` then if `|x| < ε` …” As a result, the
    expression says that all the assumptions together imply the conclusion.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 用话来说，我们会说“对于每一个`x`，`y`和`ε`，如果`0 < ε ≤ 1`，则`x`的绝对值小于`ε`，`y`的绝对值也小于`ε`，那么`x *
    y`的绝对值也小于`ε`。”在Lean中，在一系列蕴涵中，有隐式的括号分组到右边。所以上面的表达式意味着“如果`0 < ε`那么如果`ε ≤ 1`那么如果`|x|
    < ε`…”因此，这个表达式表明所有假设共同蕴涵结论。
- en: 'You have already seen that even though the universal quantifier in this statement
    ranges over objects and the implication arrows introduce hypotheses, Lean treats
    the two in very similar ways. In particular, if you have proved a theorem of that
    form, you can apply it to objects and hypotheses in the same way. We will use
    as an example the following statement that we will help you to prove a bit later:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，尽管这个陈述中的全称量词在对象上取值，而蕴涵箭头引入了假设，但Lean以非常相似的方式处理这两者。特别是，如果你已经证明了这种形式的定理，你可以以相同的方式将其应用于对象和假设。我们将以下陈述作为例子，稍后我们将帮助你证明它：
- en: '[PRE100]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: You have also already seen that it is common in Lean to use curly brackets to
    make quantified variables implicit when they can be inferred from subsequent hypotheses.
    When we do that, we can just apply a lemma to the hypotheses without mentioning
    the objects.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你也已经看到，在Lean中，当量词可以从后续假设中推断出来时，通常使用花括号来使量词隐式化。当我们这样做时，我们只需将引理应用于假设，而不必提及对象。
- en: '[PRE101]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: At this stage, you also know that if you use the `apply` tactic to apply `my_lemma`
    to a goal of the form `|a * b| < δ`, you are left with new goals that require
    you to prove each of the hypotheses.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你也知道，如果你使用`apply`策略将`my_lemma`应用于形式为`|a * b| < δ`的目标，你将留下新的目标，需要你证明每个假设。
- en: 'To prove a statement like this, use the `intro` tactic. Take a look at what
    it does in this example:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要证明这样的陈述，请使用`intro`策略。看看它在以下示例中的表现：
- en: '[PRE102]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'We can use any names we want for the universally quantified variables; they
    do not have to be `x`, `y`, and `ε`. Notice that we have to introduce the variables
    even though they are marked implicit: making them implicit means that we leave
    them out when we write an expression *using* `my_lemma`, but they are still an
    essential part of the statement that we are proving. After the `intro` command,
    the goal is what it would have been at the start if we listed all the variables
    and hypotheses *before* the colon, as we did in the last section. In a moment,
    we will see why it is sometimes necessary to introduce variables and hypotheses
    after the proof begins.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为全称量化的变量使用任何我们想要的名称；它们不必是 `x`、`y` 和 `ε`。注意，即使它们被标记为隐式，我们也必须引入这些变量：使它们成为隐式意味着在写一个使用
    `my_lemma` 的表达式时，我们可以省略它们，但它们仍然是我们要证明的陈述的一个基本部分。在 `intro` 命令之后，目标是如果在冒号之前列出了所有变量和假设，就像我们在上一节中做的那样，那么它将是什么。在不久的将来，我们将看到为什么有时在证明开始之后引入变量和假设是必要的。
- en: 'To help you prove the lemma, we will start you off:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你证明这个引理，我们将从以下步骤开始：
- en: '[PRE103]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Finish the proof using the theorems `abs_mul`, `mul_le_mul`, `abs_nonneg`, `mul_lt_mul_right`,
    and `one_mul`. Remember that you can find theorems like these using Ctrl-space
    completion (or Cmd-space completion on a Mac). Remember also that you can use
    `.mp` and `.mpr` or `.1` and `.2` to extract the two directions of an if-and-only-if
    statement.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用定理 `abs_mul`、`mul_le_mul`、`abs_nonneg`、`mul_lt_mul_right` 和 `one_mul` 完成证明。记住，你可以使用
    Ctrl-space 完成提示（或在 Mac 上使用 Cmd-space 完成提示）来找到这样的定理。还要记住，你可以使用 `.mp` 和 `.mpr` 或
    `.1` 和 `.2` 来提取双向条件语句的两个方向。
- en: Universal quantifiers are often hidden in definitions, and Lean will unfold
    definitions to expose them when necessary. For example, let’s define two predicates,
    `FnUb f a` and `FnLb f a`, where `f` is a function from the real numbers to the
    real numbers and `a` is a real number. The first says that `a` is an upper bound
    on the values of `f`, and the second says that `a` is a lower bound on the values
    of `f`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 全称量词通常隐藏在定义中，当需要时 Lean 会展开定义来揭示它们。例如，让我们定义两个谓词，`FnUb f a` 和 `FnLb f a`，其中 `f`
    是从实数到实数的函数，而 `a` 是一个实数。第一个谓词表示 `a` 是 `f` 的值的上界，第二个谓词表示 `a` 是 `f` 的值的下界。
- en: '[PRE104]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: In the next example, `fun x ↦ f x + g x` is the function that maps `x` to `f
    x + g x`. Going from the expression `f x + g x` to this function is called a lambda
    abstraction in type theory.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，`fun x ↦ f x + g x` 是将 `x` 映射到 `f x + g x` 的函数。从表达式 `f x + g x` 到这个函数的转换在类型理论中被称为
    lambda 抽象。
- en: '[PRE105]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Applying `intro` to the goal `FnUb (fun x ↦ f x + g x) (a + b)` forces Lean
    to unfold the definition of `FnUb` and introduce `x` for the universal quantifier.
    The goal is then `(fun (x : ℝ) ↦ f x + g x) x ≤ a + b`. But applying `(fun x ↦
    f x + g x)` to `x` should result in `f x + g x`, and the `dsimp` command performs
    that simplification. (The “d” stands for “definitional.”) You can delete that
    command and the proof still works; Lean would have to perform that contraction
    anyhow to make sense of the next `apply`. The `dsimp` command simply makes the
    goal more readable and helps us figure out what to do next. Another option is
    to use the `change` tactic by writing `change f x + g x ≤ a + b`. This helps make
    the proof more readable, and gives you more control over how the goal is transformed.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '将 `intro` 应用到目标 `FnUb (fun x ↦ f x + g x) (a + b)` 迫使 Lean 展开定义 `FnUb` 并引入
    `x` 作为全称量词。目标随后变为 `(fun (x : ℝ) ↦ f x + g x) x ≤ a + b`。但是将 `(fun x ↦ f x + g
    x)` 应用到 `x` 应该得到 `f x + g x`，而 `dsimp` 命令执行了这种简化。（“d”代表“定义性的。”）你可以删除那个命令，证明仍然有效；Lean
    无论如何都必须执行那个收缩，以便理解下一个 `apply`。`dsimp` 命令只是使目标更易于阅读，并帮助我们确定下一步要做什么。另一个选择是使用 `change`
    策略，通过编写 `change f x + g x ≤ a + b` 来实现。这有助于使证明更易于阅读，并让你能够更好地控制目标是如何转换的。'
- en: 'The rest of the proof is routine. The last two `apply` commands force Lean
    to unfold the definitions of `FnUb` in the hypotheses. Try carrying out similar
    proofs of these:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 证明的其余部分是常规的。最后的两个 `apply` 命令迫使 Lean 在假设中展开 `FnUb` 的定义。尝试执行类似的证明：
- en: '[PRE106]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Even though we have defined `FnUb` and `FnLb` for functions from the reals to
    the reals, you should recognize that the definitions and proofs are much more
    general. The definitions make sense for functions between any two types for which
    there is a notion of order on the codomain. Checking the type of the theorem `add_le_add`
    shows that it holds of any structure that is an “ordered additive commutative
    monoid”; the details of what that means don’t matter now, but it is worth knowing
    that the natural numbers, integers, rationals, and real numbers are all instances.
    So if we prove the theorem `fnUb_add` at that level of generality, it will apply
    in all these instances.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经为从实数到实数的函数定义了 `FnUb` 和 `FnLb`，但你应该认识到定义和证明要更通用。这些定义适用于任何两个类型之间的函数，其中在值域上有有序的概念。检查定理
    `add_le_add` 的类型显示，它适用于任何“有序加法交换幺半群”的结构；现在不需要详细说明这意味着什么，但值得知道自然数、整数、有理数和实数都是实例。因此，如果我们在这个普遍性级别上证明定理
    `fnUb_add`，它将适用于所有这些实例。
- en: '[PRE107]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: You have already seen square brackets like these in Section [Section 2.2](C02_Basics.html#proving-identities-in-algebraic-structures),
    though we still haven’t explained what they mean. For concreteness, we will stick
    to the real numbers for most of our examples, but it is worth knowing that Mathlib
    contains definitions and theorems that work at a high level of generality.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在 [第 2.2 节](C02_Basics.html#proving-identities-in-algebraic-structures) 中看到了这样的方括号，尽管我们还没有解释它们的含义。为了具体化，我们将在大多数示例中坚持使用实数，但值得知道
    Mathlib 包含在高度普遍性级别上工作的定义和定理。
- en: 'For another example of a hidden universal quantifier, Mathlib defines a predicate
    `Monotone`, which says that a function is nondecreasing in its arguments:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个隐藏的全称量词的例子：Mathlib 定义了一个谓词 `Monotone`，它表示一个函数在其参数上是单调递增的：
- en: '[PRE108]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The property `Monotone f` is defined to be exactly the expression after the
    colon. We need to put the `@` symbol before `h` because if we don’t, Lean expands
    the implicit arguments to `h` and inserts placeholders.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 属性 `Monotone f` 被定义为冒号后面的确切表达式。我们需要在 `h` 前面放置 `@` 符号，因为如果不这样做，Lean 会扩展 `h` 的隐含参数并插入占位符。
- en: Proving statements about monotonicity involves using `intro` to introduce two
    variables, say, `a` and `b`, and the hypothesis `a ≤ b`. To *use* a monotonicity
    hypothesis, you can apply it to suitable arguments and hypotheses, and then apply
    the resulting expression to the goal. Or you can apply it to the goal and let
    Lean help you work backwards by displaying the remaining hypotheses as new subgoals.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 证明关于单调性的陈述涉及使用 `intro` 引入两个变量，例如 `a` 和 `b`，以及假设 `a ≤ b`。要使用单调性假设，你可以将其应用于合适的参数和假设，然后将结果表达式应用于目标。或者，你可以将其应用于目标，让
    Lean 通过显示剩余假设作为新的子目标来帮助你反向工作。
- en: '[PRE109]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: When a proof is this short, it is often convenient to give a proof term instead.
    To describe a proof that temporarily introduces objects `a` and `b` and a hypothesis
    `aleb`, Lean uses the notation `fun a b aleb ↦ ...`. This is analogous to the
    way that an expression like `fun x ↦ x^2` describes a function by temporarily
    naming an object, `x`, and then using it to describe a value. So the `intro` command
    in the previous proof corresponds to the lambda abstraction in the next proof
    term. The `apply` commands then correspond to building the application of the
    theorem to its arguments.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当证明非常简短时，通常方便给出一个证明项。为了描述一个临时引入对象 `a` 和 `b` 以及假设 `aleb` 的证明，Lean 使用了 `fun a
    b aleb ↦ ...` 的符号。这与像 `fun x ↦ x^2` 这样的表达式通过临时命名一个对象 `x` 并使用它来描述一个值的方式来描述函数类似。因此，前一个证明中的
    `intro` 命令对应于下一个证明项中的 lambda 抽象。然后 `apply` 命令对应于构建定理对其参数的应用。
- en: '[PRE110]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Here is a useful trick: if you start writing the proof term `fun a b aleb ↦
    _` using an underscore where the rest of the expression should go, Lean will flag
    an error, indicating that it can’t guess the value of that expression. If you
    check the Lean Goal window in VS Code or hover over the squiggly error marker,
    Lean will show you the goal that the remaining expression has to solve.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有用的技巧：如果你开始编写证明项 `fun a b aleb ↦ _`，在表达式其余部分应该放置的地方使用下划线，Lean 会标记一个错误，表明它无法猜测该表达式的值。如果你在
    VS Code 中的 Lean 目标窗口中检查或悬停在波浪形错误标记上，Lean 会显示剩余表达式需要解决的目標。
- en: 'Try proving these, with either tactics or proof terms:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用策略或证明项证明以下内容：
- en: '[PRE111]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Here are some more examples. A function \(f\) from \(\Bbb R\) to \(\Bbb R\)
    is said to be *even* if \(f(-x) = f(x)\) for every \(x\), and *odd* if \(f(-x)
    = -f(x)\) for every \(x\). The following example defines these two notions formally
    and establishes one fact about them. You can complete the proofs of the others.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些更多的例子。从 \(\Bbb R\) 到 \(\Bbb R\) 的函数 \(f\) 被称为 *偶函数*，如果对于每个 \(x\)，有 \(f(-x)
    = f(x)\)；如果对于每个 \(x\)，有 \(f(-x) = -f(x)\)，则称为 *奇函数*。以下示例正式定义了这两个概念，并确立了一个关于它们的定理。你可以完成其他定理的证明。
- en: '[PRE112]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The first proof can be shortened using `dsimp` or `change` to get rid of the
    lambda abstraction. But you can check that the subsequent `rw` won’t work unless
    we get rid of the lambda abstraction explicitly, because otherwise it cannot find
    the patterns `f x` and `g x` in the expression. Contrary to some other tactics,
    `rw` operates on the syntactic level, it won’t unfold definitions or apply reductions
    for you (it has a variant called `erw` that tries a little harder in this direction,
    but not much harder).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 首个证明可以使用 `dsimp` 或 `change` 来缩短，从而去除 lambda 抽象。但你可以检查，除非我们明确去除 lambda 抽象，否则后续的
    `rw` 不会起作用，因为否则它无法在表达式中找到 `f x` 和 `g x` 这两个模式。与一些其他策略相反，`rw` 在句法层面上操作，它不会展开定义或为你应用简化（它有一个名为
    `erw` 的变体，在这个方向上尝试得稍微努力一些，但并不太多）。
- en: You can find implicit universal quantifiers all over the place, once you know
    how to spot them.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道如何找到它们，你可以在任何地方找到隐含的全称量词。
- en: Mathlib includes a good library for manipulating sets. Recall that Lean does
    not use foundations based on set theory, so here the word set has its mundane
    meaning of a collection of mathematical objects of some given type `α`. If `x`
    has type `α` and `s` has type `Set α`, then `x ∈ s` is a proposition that asserts
    that `x` is an element of `s`. If `y` has some different type `β` then the expression
    `y ∈ s` makes no sense. Here “makes no sense” means “has no type hence Lean does
    not accept it as a well-formed statement”. This contrasts with Zermelo-Fraenkel
    set theory for instance where `a ∈ b` is a well-formed statement for every mathematical
    objects `a` and `b`. For instance `sin ∈ cos` is a well-formed statement in ZF.
    This defect of set theoretic foundations is an important motivation for not using
    it in a proof assistant which is meant to assist us by detecting meaningless expressions.
    In Lean `sin` has type `ℝ → ℝ` and `cos` has type `ℝ → ℝ` which is not equal to
    `Set (ℝ → ℝ)`, even after unfolding definitions, so the statement `sin ∈ cos`
    makes no sense. One can also use Lean to work on set theory itself. For instance
    the independence of the continuum hypothesis from the axioms of Zermelo-Fraenkel
    has been formalized in Lean. But such a meta-theory of set theory is completely
    beyond the scope of this book.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib 包含了一个用于操作集合的良好库。回想一下，Lean 不使用基于集合论的公理系统，因此这里的“集合”一词具有其平凡的数学对象集合的含义，这些对象属于某个给定的类型
    `α`。如果 `x` 的类型是 `α`，而 `s` 的类型是 `Set α`，那么 `x ∈ s` 是一个命题，它断言 `x` 是 `s` 的一个元素。如果
    `y` 有某种不同的类型 `β`，那么表达式 `y ∈ s` 就没有意义。这里的“没有意义”是指“没有类型，因此 Lean 不接受它作为一个有效的语句”。这与例如
    Zermelo-Fraenkel 集合论不同，在 ZF 中，`a ∈ b` 对于每个数学对象 `a` 和 `b` 都是一个有效的语句。例如，`sin ∈ cos`
    在 ZF 中是一个有效的语句。集合论基础的这个缺陷是重要的动机，即不在旨在通过检测无意义表达式来帮助我们证明辅助工具中使用它。在 Lean 中，`sin`
    的类型是 `ℝ → ℝ`，而 `cos` 的类型是 `ℝ → ℝ`，这并不等于 `Set (ℝ → ℝ)`，即使展开定义后也是如此，因此语句 `sin ∈
    cos` 没有意义。人们也可以使用 Lean 来处理集合论本身。例如，连续假设与 Zermelo-Fraenkel 公理的独立性已经在 Lean 中形式化。但这样的集合论元理论完全超出了本书的范围。
- en: 'If `s` and `t` are of type `Set α`, then the subset relation `s ⊆ t` is defined
    to mean `∀ {x : α}, x ∈ s → x ∈ t`. The variable in the quantifier is marked implicit
    so that given `h : s ⊆ t` and `h'' : x ∈ s`, we can write `h h''` as justification
    for `x ∈ t`. The following example provides a tactic proof and a proof term justifying
    the reflexivity of the subset relation, and asks you to do the same for transitivity.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 `s` 和 `t` 的类型都是 `Set α`，那么子集关系 `s ⊆ t` 被定义为 `∀ {x : α}, x ∈ s → x ∈ t`。量词中的变量被标记为隐式，这样给定
    `h : s ⊆ t` 和 `h'' : x ∈ s`，我们可以将 `h h''` 写作 `x ∈ t` 的理由。以下示例提供了一个策略证明和一个证明项，以证明子集关系的自反性，并要求你为传递性做同样的工作。'
- en: '[PRE113]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Just as we defined `FnUb` for functions, we can define `SetUb s a` to mean that
    `a` is an upper bound on the set `s`, assuming `s` is a set of elements of some
    type that has an order associated with it. In the next example, we ask you to
    prove that if `a` is a bound on `s` and `a ≤ b`, then `b` is a bound on `s` as
    well.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们为函数定义了`FnUb`，我们也可以定义`SetUb s a`，表示`a`是集合`s`的上界，假设`s`是某种类型元素的集合，并且与它相关联一个顺序。在下一个例子中，我们要求你证明如果`a`是`s`的界限且`a
    ≤ b`，那么`b`也是`s`的界限。
- en: '[PRE114]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: We close this section with one last important example. A function \(f\) is said
    to be *injective* if for every \(x_1\) and \(x_2\), if \(f(x_1) = f(x_2)\) then
    \(x_1 = x_2\). Mathlib defines `Function.Injective f` with `x₁` and `x₂` implicit.
    The next example shows that, on the real numbers, any function that adds a constant
    is injective. We then ask you to show that multiplication by a nonzero constant
    is also injective, using the lemma name in the example as a source of inspiration.
    Recall you should use Ctrl-space completion after guessing the beginning of a
    lemma name.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一个最后的例子来结束本节。一个函数 \(f\) 被称为**单射**，如果对于每一个 \(x_1\) 和 \(x_2\)，如果 \(f(x_1) =
    f(x_2)\) 则 \(x_1 = x_2\)。Mathlib 使用 `Function.Injective f` 定义 `x₁` 和 `x₂` 是隐式的。下一个例子显示，在实数上，任何加常数的函数都是单射。然后我们要求你证明乘以一个非零常数也是单射，可以使用例子中的引理名称作为灵感来源。回想一下，在猜测引理名称的开头后，你应该使用
    Ctrl-space 完成提示。
- en: '[PRE115]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Finally, show that the composition of two injective functions is injective:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，证明两个单射函数的复合也是单射：
- en: '[PRE116]  ## 3.2\. The Existential Quantifier[](#the-existential-quantifier
    "Link to this heading")'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE116]  ## 3.2\. 存在量词[](#the-existential-quantifier "链接到这个标题")'
- en: 'The existential quantifier, which can be entered as `\ex` in VS Code, is used
    to represent the phrase “there exists.” The formal expression `∃ x : ℝ, 2 < x
    ∧ x < 3` in Lean says that there is a real number between 2 and 3. (We will discuss
    the conjunction symbol, `∧`, in [Section 3.4](#conjunction-and-biimplication).)
    The canonical way to prove such a statement is to exhibit a real number and show
    that it has the stated property. The number 2.5, which we can enter as `5 / 2`
    or `(5 : ℝ) / 2` when Lean cannot infer from context that we have the real numbers
    in mind, has the required property, and the `norm_num` tactic can prove that it
    meets the description.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '存在量词，在 VS Code 中可以输入为`\ex`，用于表示“存在”这个短语。在 Lean 中的形式表达式 `∃ x : ℝ, 2 < x ∧ x
    < 3` 表示存在一个实数在 2 和 3 之间。（我们将在[第 3.4 节](#conjunction-and-biimplication)中讨论合取符号`∧`。）证明此类陈述的规范方法是展示一个实数并证明它具有所述属性。数字
    2.5，我们可以输入为 `5 / 2` 或 `(5 : ℝ) / 2` 当 Lean 无法从上下文中推断出我们指的是实数时，具有所需的属性，并且`norm_num`策略可以证明它符合描述。'
- en: There are a few ways we can put the information together. Given a goal that
    begins with an existential quantifier, the `use` tactic is used to provide the
    object, leaving the goal of proving the property.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方法可以将信息组合起来。给定一个以存在量词开始的目標，使用`use`策略来提供对象，留下证明属性的目標。
- en: '[PRE117]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'You can give the `use` tactic proofs as well as data:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以给出`use`策略的证明以及数据：
- en: '[PRE118]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: In fact, the `use` tactic automatically tries to use available assumptions as
    well.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`use`策略会自动尝试使用可用的假设。
- en: '[PRE119]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Alternatively, we can use Lean’s *anonymous constructor* notation to construct
    a proof of an existential quantifier.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 Lean 的**匿名构造函数**符号来构造存在量词的证明。
- en: '[PRE120]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Notice that there is no `by`; here we are giving an explicit proof term. The
    left and right angle brackets, which can be entered as `\<` and `\>` respectively,
    tell Lean to put together the given data using whatever construction is appropriate
    for the current goal. We can use the notation without going first into tactic
    mode:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里没有`by`；我们在这里给出一个明确的证明项。左和右尖括号，分别可以输入为`\<`和`\>`，告诉 Lean 使用适合当前目標的任何构造来组合给定数据。我们可以使用这种符号而不必首先进入策略模式：
- en: '[PRE121]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'So now we know how to *prove* an exists statement. But how do we *use* one?
    If we know that there exists an object with a certain property, we should be able
    to give a name to an arbitrary one and reason about it. For example, remember
    the predicates `FnUb f a` and `FnLb f a` from the last section, which say that
    `a` is an upper bound or lower bound on `f`, respectively. We can use the existential
    quantifier to say that “`f` is bounded” without specifying the bound:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们知道了如何 *证明* 一个存在语句。但如何 *使用* 它呢？如果我们知道存在具有某种属性的对象，我们应该能够为任意一个对象命名并对其进行推理。例如，记住上一节中的谓词
    `FnUb f a` 和 `FnLb f a`，它们分别表示 `a` 是 `f` 的上界或下界。我们可以使用存在量词来说明“`f` 有界”，而不指定界限：
- en: '[PRE122]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: We can use the theorem `FnUb_add` from the last section to prove that if `f`
    and `g` have upper bounds, then so does `fun x ↦ f x + g x`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用上一节中的定理 `FnUb_add` 来证明，如果 `f` 和 `g` 有上界，那么 `fun x ↦ f x + g x` 也有上界。
- en: '[PRE123]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The `rcases` tactic unpacks the information in the existential quantifier.
    The annotations like `⟨a, ubfa⟩`, written with the same angle brackets as the
    anonymous constructors, are known as *patterns*, and they describe the information
    that we expect to find when we unpack the main argument. Given the hypothesis
    `ubf` that there is an upper bound for `f`, `rcases ubf with ⟨a, ubfa⟩` adds a
    new variable `a` for an upper bound to the context, together with the hypothesis
    `ubfa` that it has the given property. The goal is left unchanged; what *has*
    changed is that we can now use the new object and the new hypothesis to prove
    the goal. This is a common method of reasoning in mathematics: we unpack objects
    whose existence is asserted or implied by some hypothesis, and then use it to
    establish the existence of something else.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`rcases` 策略解包存在量词中的信息。像 `⟨a, ubfa⟩` 这样的注释，使用与匿名构造函数相同的尖括号书写，被称为 *模式*，它们描述了我们解包主论点时预期找到的信息。给定存在上界
    `f` 的假设 `ubf`，`rcases ubf with ⟨a, ubfa⟩` 将一个新的变量 `a` 添加到上下文中，以及具有给定属性的假设 `ubfa`。目标保持不变；*改变*的是，我们现在可以使用新的对象和新的假设来证明目标。这是数学中常见的推理方法：我们解包由某些假设断言或暗示存在的对象，然后使用它来建立其他事物的存在。'
- en: Try using this method to establish the following. You might find it useful to
    turn some of the examples from the last section into named theorems, as we did
    with `fn_ub_add`, or you can insert the arguments directly into the proofs.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用这种方法来建立以下内容。你可能发现将上一节的一些示例转换为命名定理很有用，就像我们对 `fn_ub_add` 所做的那样，或者你可以直接将参数插入到证明中。
- en: '[PRE124]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The “r” in `rcases` stands for “recursive,” because it allows us to use arbitrarily
    complex patterns to unpack nested data. The `rintro` tactic is a combination of
    `intro` and `rcases`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`rcases` 中的“r”代表“递归”，因为它允许我们使用任意复杂的模式来解包嵌套数据。`rintro` 策略是 `intro` 和 `rcases`
    的组合：'
- en: '[PRE125]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'In fact, Lean also supports a pattern-matching fun in expressions and proof
    terms:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Lean 还支持在表达式和证明项中使用模式匹配函数：
- en: '[PRE126]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The task of unpacking information in a hypothesis is so important that Lean
    and Mathlib provide a number of ways to do it. For example, the `obtain` tactic
    provides suggestive syntax:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在假设中解包信息是一项如此重要的任务，以至于 Lean 和 Mathlib 提供了多种方法来完成它。例如，`obtain` 策略提供了提示性语法：
- en: '[PRE127]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Think of the first `obtain` instruction as matching the “contents” of `ubf`
    with the given pattern and assigning the components to the named variables. `rcases`
    and `obtain` are said to `destruct` their arguments.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 将第一个 `obtain` 指令视为将 `ubf` 的“内容”与给定的模式匹配，并将组件分配给命名变量。`rcases` 和 `obtain` 被说成是
    `destruct` 它们的参数。
- en: 'Lean also supports syntax that is similar to that used in other functional
    programming languages:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 还支持与其它函数式编程语言类似的语法：
- en: '[PRE128]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'In the first example, if you put your cursor after `cases ubf`, you will see
    that the tactic produces a single goal, which Lean has tagged `intro`. (The particular
    name chosen comes from the internal name for the axiomatic primitive that builds
    a proof of an existential statement.) The `case` tactic then names the components.
    The second example is similar, except using `next` instead of `case` means that
    you can avoid mentioning `intro`. The word `match` in the last two examples highlights
    that what we are doing here is what computer scientists call “pattern matching.”
    Notice that the third proof begins by `by`, after which the tactic version of
    `match` expects a tactic proof on the right side of the arrow. The last example
    is a proof term: there are no tactics in sight.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，如果你将光标放在`cases ubf`之后，你会看到这个策略产生了一个单一的目标，Lean将其标记为`intro`。（所选择的特定名称来自构建存在性陈述证明的公理原语的内部名称。）然后`case`策略命名了组件。第二个例子与第一个类似，只是使用`next`代替`case`意味着你可以避免提及`intro`。在最后两个例子中，单词`match`突出了我们在这里所做的是计算机科学家所说的“模式匹配”。请注意，第三个证明以`by`开始，之后`match`的策略版本期望箭头右侧有一个策略证明。最后一个例子是一个证明项：没有可见的策略。
- en: For the rest of this book, we will stick to `rcases`, `rintro`, and `obtain`,
    as the preferred ways of using an existential quantifier. But it can’t hurt to
    see the alternative syntax, especially if there is a chance you will find yourself
    in the company of computer scientists.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的剩余部分，我们将坚持使用`rcases`、`rintro`和`obtain`作为使用存在量词的首选方式。但看看备选语法也无妨，尤其是如果你有可能与计算机科学家为伍的话。
- en: 'To illustrate one way that `rcases` can be used, we prove an old mathematical
    chestnut: if two integers `x` and `y` can each be written as a sum of two squares,
    then so can their product, `x * y`. In fact, the statement is true for any commutative
    ring, not just the integers. In the next example, `rcases` unpacks two existential
    quantifiers at once. We then provide the magic values needed to express `x * y`
    as a sum of squares as a list to the `use` statement, and we use `ring` to verify
    that they work.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明`rcases`可以用来证明的一种方式，我们证明了一个古老的数学难题：如果两个整数`x`和`y`都可以写成两个平方的和，那么它们的乘积`x *
    y`也可以。实际上，这个陈述对于任何交换环都成立，而不仅仅是整数。在下一个例子中，`rcases`同时展开两个存在量词。然后我们提供一个列表，包含将`x *
    y`表示为平方和所需的神奇值，并将其作为`use`语句的参数，并使用`ring`来验证它们是否有效。
- en: '[PRE129]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'This proof doesn’t provide much insight, but here is one way to motivate it.
    A *Gaussian integer* is a number of the form \(a + bi\) where \(a\) and \(b\)
    are integers and \(i = \sqrt{-1}\). The *norm* of the Gaussian integer \(a + bi\)
    is, by definition, \(a^2 + b^2\). So the norm of a Gaussian integer is a sum of
    squares, and any sum of squares can be expressed in this way. The theorem above
    reflects the fact that norm of a product of Gaussian integers is the product of
    their norms: if \(x\) is the norm of \(a + bi\) and \(y\) in the norm of \(c +
    di\), then \(xy\) is the norm of \((a + bi) (c + di)\). Our cryptic proof illustrates
    the fact that the proof that is easiest to formalize isn’t always the most perspicuous
    one. In [Section 7.3](C07_Structures.html#section-building-the-gaussian-integers),
    we will provide you with the means to define the Gaussian integers and use them
    to provide an alternative proof.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这个证明并没有提供很多洞见，但这里有一种激发它的方法。一个**高斯整数**是形如 \(a + bi\) 的数，其中 \(a\) 和 \(b\) 是整数，且
    \(i = \sqrt{-1}\)。根据定义，高斯整数 \(a + bi\) 的**范数**是 \(a^2 + b^2\)。因此，高斯整数的范数是平方和，任何平方和都可以用这种方式表示。上述定理反映了这样一个事实：高斯整数乘积的范数是它们范数的乘积：如果
    \(x\) 是 \(a + bi\) 的范数，\(y\) 是 \(c + di\) 的范数，那么 \(xy\) 就是 \((a + bi) (c + di)\)
    的范数。我们晦涩的证明说明了这样一个事实：最易于形式化的证明并不总是最清晰的。在[第7.3节](C07_Structures.html#section-building-the-gaussian-integers)中，我们将提供定义高斯整数并使用它们提供另一种证明的方法。
- en: 'The pattern of unpacking an equation inside an existential quantifier and then
    using it to rewrite an expression in the goal comes up often, so much so that
    the `rcases` tactic provides an abbreviation: if you use the keyword `rfl` in
    place of a new identifier, `rcases` does the rewriting automatically (this trick
    doesn’t work with pattern-matching lambdas).'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在存在量词内部展开方程并使用它来重写目标表达式的模式经常出现，以至于`rcases`策略提供了一个缩写：如果你用关键字`rfl`代替一个新标识符，`rcases`会自动进行重写（这个技巧与模式匹配lambda不兼容）。
- en: '[PRE130]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: As with the universal quantifier, you can find existential quantifiers hidden
    all over if you know how to spot them. For example, divisibility is implicitly
    an “exists” statement.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 就像全称量词一样，如果你知道如何找到它们，你可以在任何地方找到隐藏的存在量词。例如，可除性隐含地是一个“存在”陈述。
- en: '[PRE131]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: And once again, this provides a nice setting for using `rcases` with `rfl`.
    Try it out in the proof above. It feels pretty good!
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这为使用 `rcases` 和 `rfl` 提供了一个很好的环境。在上面的证明中试一试。感觉相当不错！
- en: 'Then try proving the following:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 然后尝试证明以下内容：
- en: '[PRE132]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'For another important example, a function \(f : \alpha \to \beta\) is said
    to be *surjective* if for every \(y\) in the codomain, \(\beta\), there is an
    \(x\) in the domain, \(\alpha\), such that \(f(x) = y\). Notice that this statement
    includes both a universal and an existential quantifier, which explains why the
    next example makes use of both `intro` and `use`.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '对于另一个重要的例子，如果函数 \(f : \alpha \to \beta\) 被称为 *外射*，那么对于域 \(\alpha\) 中的每个 \(y\)，在陪域
    \(\beta\) 中都有一个 \(x\)，使得 \(f(x) = y\)。注意，这个陈述包括全称量词和存在量词，这就是为什么下一个例子同时使用了 `intro`
    和 `use` 的原因。'
- en: '[PRE133]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Try this example yourself using the theorem `mul_div_cancel₀`.:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用定理 `mul_div_cancel₀` 自己做这个例子。
- en: '[PRE134]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: At this point, it is worth mentioning that there is a tactic, `field_simp`,
    that will often clear denominators in a useful way. It can be used in conjunction
    with the `ring` tactic.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，值得提到的是，有一个策略 `field_simp`，它通常会以有用的方式消除分母。它可以与 `ring` 策略一起使用。
- en: '[PRE135]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The next example uses a surjectivity hypothesis by applying it to a suitable
    value. Note that you can use `rcases` with any expression, not just a hypothesis.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子通过应用到一个合适的值来使用外射假设。注意，你可以用 `rcases` 对任何表达式进行操作，而不仅仅是假设。
- en: '[PRE136]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: See if you can use these methods to show that the composition of surjective
    functions is surjective.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否可以使用这些方法来证明外射函数的复合仍然是外射的。
- en: '[PRE137]  ## 3.3\. Negation[](#negation "Link to this heading")'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE137]  ## 3.3. 否定[](#negation "链接到这个标题")'
- en: 'The symbol `¬` is meant to express negation, so `¬ x < y` says that `x` is
    not less than `y`, `¬ x = y` (or, equivalently, `x ≠ y`) says that `x` is not
    equal to `y`, and `¬ ∃ z, x < z ∧ z < y` says that there does not exist a `z`
    strictly between `x` and `y`. In Lean, the notation `¬ A` abbreviates `A → False`,
    which you can think of as saying that `A` implies a contradiction. Practically
    speaking, this means that you already know something about how to work with negations:
    you can prove `¬ A` by introducing a hypothesis `h : A` and proving `False`, and
    if you have `h : ¬ A` and `h'' : A`, then applying `h` to `h''` yields `False`.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '符号 `¬` 用于表示否定，所以 `¬ x < y` 表示 `x` 不小于 `y`，`¬ x = y`（或等价地，`x ≠ y`）表示 `x` 不等于
    `y`，而 `¬ ∃ z, x < z ∧ z < y` 表示不存在一个 `z` 在 `x` 和 `y` 之间。在 Lean 中，记法 `¬ A` 简写为
    `A → False`，你可以将其视为说 `A` 导致矛盾。实际上，这意味着你已经知道如何处理否定：你可以通过引入一个假设 `h : A` 并证明 `False`
    来证明 `¬ A`，如果你有 `h : ¬ A` 和 `h'' : A`，那么将 `h` 应用到 `h''` 上会产生 `False`。'
- en: To illustrate, consider the irreflexivity principle `lt_irrefl` for a strict
    order, which says that we have `¬ a < a` for every `a`. The asymmetry principle
    `lt_asymm` says that we have `a < b → ¬ b < a`. Let’s show that `lt_asymm` follows
    from `lt_irrefl`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，考虑严格顺序的不可自反原理 `lt_irrefl`，它表示对于每个 `a`，我们有 `¬ a < a`。不对称原理 `lt_asymm` 表示我们有
    `a < b → ¬ b < a`。让我们证明 `lt_asymm` 可以从 `lt_irrefl` 推出。
- en: '[PRE138]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: This example introduces a couple of new tricks. First, when you use `have` without
    providing a label, Lean uses the name `this`, providing a convenient way to refer
    back to it. Because the proof is so short, we provide an explicit proof term.
    But what you should really be paying attention to in this proof is the result
    of the `intro` tactic, which leaves a goal of `False`, and the fact that we eventually
    prove `False` by applying `lt_irrefl` to a proof of `a < a`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子介绍了一些新技巧。首先，当你使用 `have` 而不提供标签时，Lean 使用名称 `this`，这提供了一个方便的方式来引用它。因为证明非常简短，所以我们提供了一个显式的证明项。但在这个证明中，你应该真正关注的是
    `intro` 策略的结果，它留下一个 `False` 的目标，以及我们最终通过将 `lt_irrefl` 应用到一个 `a < a` 的证明上证明 `False`
    的事实。
- en: Here is another example, which uses the predicate `FnHasUb` defined in the last
    section, which says that a function has an upper bound.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子，它使用了上一节中定义的谓词 `FnHasUb`，该谓词表示一个函数有一个上界。
- en: '[PRE139]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Remember that it is often convenient to use `linarith` when a goal follows from
    linear equations and inequalities that are in the context.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当目标从上下文中的线性方程和不等式得出时，使用 `linarith` 通常很方便。
- en: 'See if you can prove these in a similar way:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否可以用类似的方法证明以下内容：
- en: '[PRE140]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Mathlib offers a number of useful theorems for relating orders and negations:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib 提供了多个有用的定理，用于关联顺序和否定：
- en: '[PRE141]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Recall the predicate `Monotone f`, which says that `f` is nondecreasing. Use
    some of the theorems just enumerated to prove the following:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 回忆谓词 `Monotone f`，它表示 `f` 是非递减的。使用你刚刚列举的一些定理来证明以下内容：
- en: '[PRE142]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: We can show that the first example in the last snippet cannot be proved if we
    replace `<` by `≤`. Notice that we can prove the negation of a universally quantified
    statement by giving a counterexample. Complete the proof.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `<` 替换为 `≤`，我们可以证明最后一段代码中的第一个例子是无法证明的。注意，我们可以通过给出一个反例来证明全称量化语句的否定。完成证明。
- en: '[PRE143]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'This example introduces the `let` tactic, which adds a *local definition* to
    the context. If you put the cursor after the `let` command, in the goal window
    you will see that the definition `f : ℝ → ℝ := fun x ↦ 0` has been added to the
    context. Lean will unfold the definition of `f` when it has to. In particular,
    when we prove `f 1 ≤ f 0` with `le_refl`, Lean reduces `f 1` and `f 0` to `0`.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '这个例子介绍了 `let` 策略，它向上下文中添加一个 *局部定义*。如果你在 `let` 命令后放置光标，在目标窗口中你会看到已经添加到上下文中的定义
    `f : ℝ → ℝ := fun x ↦ 0`。当 Lean 需要时，它会展开 `f` 的定义。特别是，当我们使用 `le_refl` 证明 `f 1 ≤
    f 0` 时，Lean 会将 `f 1` 和 `f 0` 简化为 `0`。'
- en: 'Use `le_of_not_gt` to prove the following:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `le_of_not_gt` 来证明以下内容：
- en: '[PRE144]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Implicit in many of the proofs we have just done is the fact that if `P` is
    any property, saying that there is nothing with property `P` is the same as saying
    that everything fails to have property `P`, and saying that not everything has
    property `P` is equivalent to saying that something fails to have property `P`.
    In other words, all four of the following implications are valid (but one of them
    cannot be proved with what we explained so far):'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚证明的许多证明中隐含的事实是，如果 `P` 是任何属性，说没有任何具有属性 `P` 的东西等同于说所有东西都没有属性 `P`，而说并非所有东西都有属性
    `P` 等价于说有些东西没有属性 `P`。换句话说，以下四个蕴含都是有效的（但其中之一不能使用我们迄今为止所解释的方法来证明）：
- en: '[PRE145]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: The first, second, and fourth are straightforward to prove using the methods
    you have already seen. We encourage you to try it. The third is more difficult,
    however, because it concludes that an object exists from the fact that its nonexistence
    is contradictory. This is an instance of *classical* mathematical reasoning. We
    can use proof by contradiction to prove the third implication as follows.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个、第二个和第四个定理使用你已经看到的方法很容易证明。我们鼓励你尝试一下。然而，第三个定理更难证明，因为它从其不存在是矛盾的这一事实得出存在一个对象。这是一个
    *经典* 数学推理的例子。我们可以通过以下方式使用反证法来证明第三个蕴含：
- en: '[PRE146]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Make sure you understand how this works. The `by_contra` tactic allows us to
    prove a goal `Q` by assuming `¬ Q` and deriving a contradiction. In fact, it is
    equivalent to using the equivalence `not_not : ¬ ¬ Q ↔ Q`. Confirm that you can
    prove the forward direction of this equivalence using `by_contra`, while the reverse
    direction follows from the ordinary rules for negation.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '确保你理解这是如何工作的。`by_contra` 策略允许我们通过假设 `¬ Q` 并推导出矛盾来证明目标 `Q`。实际上，它等价于使用等价性 `not_not
    : ¬ ¬ Q ↔ Q`。确认你可以使用 `by_contra` 来证明这个等价的正向方向，而反向方向则遵循否定规则的普通规则。'
- en: '[PRE147]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Use proof by contradiction to establish the following, which is the converse
    of one of the implications we proved above. (Hint: use `intro` first.)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反证法来证明以下内容，这是我们上面证明的一个蕴含的逆命题。（提示：首先使用 `intro`。）
- en: '[PRE148]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: It is often tedious to work with compound statements with a negation in front,
    and it is a common mathematical pattern to replace such statements with equivalent
    forms in which the negation has been pushed inward. To facilitate this, Mathlib
    offers a `push_neg` tactic, which restates the goal in this way. The command `push_neg
    at h` restates the hypothesis `h`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 处理带有前面否定词的复合语句通常很繁琐，并且将否定词推入等价形式的数学模式是一种常见的数学模式。为了方便这样做，Mathlib 提供了一个 `push_neg`
    策略，它以这种方式重新表述目标。命令 `push_neg at h` 重新表述假设 `h`。
- en: '[PRE149]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'In the second example, we use dsimp to expand the definitions of `FnHasUb`
    and `FnUb`. (We need to use `dsimp` rather than `rw` to expand `FnUb`, because
    it appears in the scope of a quantifier.) You can verify that in the examples
    above with `¬∃ x, P x` and `¬∀ x, P x`, the `push_neg` tactic does the expected
    thing. Without even knowing how to use the conjunction symbol, you should be able
    to use `push_neg` to prove the following:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，我们使用`dsimp`展开`FnHasUb`和`FnUb`的定义。（我们需要使用`dsimp`而不是`rw`来展开`FnUb`，因为它出现在量词的作用域中。）你可以验证在上述例子中，使用`¬∃
    x, P x`和`¬∀ x, P x`时，`push_neg`策略做了预期的事情。即使不知道如何使用合取符号，你也应该能够使用`push_neg`来证明以下内容：
- en: '[PRE150]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Mathlib also has a tactic, `contrapose`, which transforms a goal `A → B` to
    `¬B → ¬A`. Similarly, given a goal of proving `B` from hypothesis `h : A`, `contrapose
    h` leaves you with a goal of proving `¬A` from hypothesis `¬B`. Using `contrapose!`
    instead of `contrapose` applies `push_neg` to the goal and the relevant hypothesis
    as well.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 'Mathlib还有一个策略，`contrapose`，它将目标`A → B`转换为`¬B → ¬A`。同样，给定一个从假设`h : A`证明`B`的目标，`contrapose
    h`让你有一个从假设`¬B`证明`¬A`的目标。使用`contrapose!`而不是`contrapose`将`push_neg`应用于目标和相关假设。'
- en: '[PRE151]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: We have not yet explained the `constructor` command or the use of the semicolon
    after it, but we will do that in the next section.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有解释`constructor`命令及其后的分号的使用，但将在下一节中解释。
- en: We close this section with the principle of *ex falso*, which says that anything
    follows from a contradiction. In Lean, this is represented by `False.elim`, which
    establishes `False → P` for any proposition `P`. This may seem like a strange
    principle, but it comes up fairly often. We often prove a theorem by splitting
    on cases, and sometimes we can show that one of the cases is contradictory. In
    that case, we need to assert that the contradiction establishes the goal so we
    can move on to the next one. (We will see instances of reasoning by cases in [Section
    3.5](#disjunction).)
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以*ex falso*原则结束本节，该原则指出，任何东西都可以从矛盾中得出。在Lean中，这由`False.elim`表示，它为任何命题`P`建立了`False
    → P`。这看起来可能像一条奇怪的原则，但它出现的频率相当高。我们经常通过分情况证明定理，有时我们可以证明其中一种情况是矛盾的。在这种情况下，我们需要断言矛盾建立了目标，这样我们就可以继续下一个目标。（我们将在[第3.5节](#disjunction)中看到通过分情况推理的例子。）
- en: Lean provides a number of ways of closing a goal once a contradiction has been
    reached.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Lean提供了一些方法来关闭目标，一旦达到矛盾。
- en: '[PRE152]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The `exfalso` tactic replaces the current goal with the goal of proving `False`.
    Given `h : P` and `h'' : ¬ P`, the term `absurd h h''` establishes any proposition.
    Finally, the `contradiction` tactic tries to close a goal by finding a contradiction
    in the hypotheses, such as a pair of the form `h : P` and `h'' : ¬ P`. Of course,
    in this example, `linarith` also works.  ## 3.4\. Conjunction and Iff[](#conjunction-and-iff
    "Link to this heading")'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`exfalso`策略将当前目标替换为证明`False`的目标。给定`h : P`和`h'' : ¬ P`，项`absurd h h''`建立了任何命题。最后，`contradiction`策略试图通过在假设中找到矛盾来关闭目标，例如形式为`h
    : P`和`h'' : ¬ P`的一对。当然，在这个例子中，`linarith`也有效。## 3.4. 合取与双条件[](#conjunction-and-iff
    "链接到本标题")'
- en: You have already seen that the conjunction symbol, `∧`, is used to express “and.”
    The `constructor` tactic allows you to prove a statement of the form `A ∧ B` by
    proving `A` and then proving `B`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到合取符号`∧`用于表达“和”。`constructor`策略允许你通过先证明`A`然后证明`B`来证明形式为`A ∧ B`的陈述。
- en: '[PRE153]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: In this example, the `assumption` tactic tells Lean to find an assumption that
    will solve the goal. Notice that the final `rw` finishes the goal by applying
    the reflexivity of `≤`. The following are alternative ways of carrying out the
    previous examples using the anonymous constructor angle brackets. The first is
    a slick proof-term version of the previous proof, which drops into tactic mode
    at the keyword `by`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`assumption`策略告诉Lean找到一个假设来解决目标。注意，最后的`rw`通过应用`≤`的反射性来完成目标。以下是以匿名构造函数尖括号的形式执行先前例子的替代方法。第一种是先前证明的整洁证明项版本，它在`by`关键字处进入策略模式。
- en: '[PRE154]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '*Using* a conjunction instead of proving one involves unpacking the proofs
    of the two parts. You can use the `rcases` tactic for that, as well as `rintro`
    or a pattern-matching `fun`, all in a manner similar to the way they are used
    with the existential quantifier.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用*合取而不是证明一个合取涉及展开两个部分的证明。你可以使用`rcases`策略来做到这一点，以及`rintro`或模式匹配的`fun`，所有这些都在与存在量词使用类似的方式中使用。'
- en: '[PRE155]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'In analogy to the `obtain` tactic, there is also a pattern-matching `have`:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 与`obtain`策略类似，还有一个模式匹配的`have`：
- en: '[PRE156]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'In contrast to `rcases`, here the `have` tactic leaves `h` in the context.
    And even though we won’t use them, once again we have the computer scientists’
    pattern-matching syntax:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 与`rcases`不同，这里`have`策略将`h`留在上下文中。即使我们不会使用它们，我们再次有了计算机科学家的模式匹配语法：
- en: '[PRE157]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'In contrast to using an existential quantifier, you can also extract proofs
    of the two components of a hypothesis `h : A ∧ B` by writing `h.left` and `h.right`,
    or, equivalently, `h.1` and `h.2`.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '与使用存在量词相比，你也可以通过编写`h.left`和`h.right`，或者等价地，`h.1`和`h.2`来提取假设`h : A ∧ B`的两个组成部分的证明。'
- en: '[PRE158]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Try using these techniques to come up with various ways of proving of the following:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用这些技术来提出证明以下命题的各种方法：
- en: '[PRE159]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: You can nest uses of `∃` and `∧` with anonymous constructors, `rintro`, and
    `rcases`.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用匿名构造函数、`rintro`和`rcases`来嵌套使用`∃`和`∧`。
- en: '[PRE160]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'You can also use the `use` tactic:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`use`策略：
- en: '[PRE161]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: In the first example, the semicolon after the `constructor` command tells Lean
    to use the `norm_num` tactic on both of the goals that result.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，`constructor`命令后面的分号告诉Lean对产生的两个目标都使用`norm_num`策略。
- en: 'In Lean, `A ↔ B` is *not* defined to be `(A → B) ∧ (B → A)`, but it could have
    been, and it behaves roughly the same way. You have already seen that you can
    write `h.mp` and `h.mpr` or `h.1` and `h.2` for the two directions of `h : A ↔
    B`. You can also use `cases` and friends. To prove an if-and-only-if statement,
    you can use `constructor` or angle brackets, just as you would if you were proving
    a conjunction.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '在Lean中，`A ↔ B`不是定义为`(A → B) ∧ (B → A)`，但它本来可以是，并且它的行为大致相同。你已经看到，你可以为`h : A
    ↔ B`的两个方向编写`h.mp`和`h.mpr`或`h.1`和`h.2`。你也可以使用`cases`和相关工具。为了证明一个如果且仅如果的陈述，你可以使用`constructor`或尖括号，就像你证明合取一样。'
- en: '[PRE162]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: The last proof term is inscrutable. Remember that you can use underscores while
    writing an expression like that to see what Lean expects.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的证明项难以理解。记住，在编写类似的表达式时，你可以使用下划线来查看Lean期望的内容。
- en: 'Try out the various techniques and gadgets you have just seen in order to prove
    the following:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用你刚刚看到的各种技术和工具来证明以下命题：
- en: '[PRE163]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: For a more interesting exercise, show that for any two real numbers `x` and
    `y`, `x^2 + y^2 = 0` if and only if `x = 0` and `y = 0`. We suggest proving an
    auxiliary lemma using `linarith`, `pow_two_nonneg`, and `pow_eq_zero`.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个更有趣的练习，证明对于任何两个实数`x`和`y`，如果`x^2 + y^2 = 0`，则`x = 0`且`y = 0`。我们建议使用`linarith`、`pow_two_nonneg`和`pow_eq_zero`证明一个辅助引理。
- en: '[PRE164]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: In Lean, bi-implication leads a double-life. You can treat it like a conjunction
    and use its two parts separately. But Lean also knows that it is a reflexive,
    symmetric, and transitive relation between propositions, and you can also use
    it with `calc` and `rw`. It is often convenient to rewrite a statement to an equivalent
    one. In the next example, we use `abs_lt` to replace an expression of the form
    `|x| < y` by the equivalent expression `- y < x ∧ x < y`, and in the one after
    that we use `Nat.dvd_gcd_iff` to replace an expression of the form `m ∣ Nat.gcd
    n k` by the equivalent expression `m ∣ n ∧ m ∣ k`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lean中，双条件有两种生活。你可以将其视为合取并分别使用其两部分。但Lean也知道它是一个命题之间的自反、对称和传递关系，你也可以使用`calc`和`rw`。将一个陈述重写为等价陈述通常很方便。在下一个例子中，我们使用`abs_lt`将形式为`|x|
    < y`的表达式替换为等价表达式`- y < x ∧ x < y`，在下一个例子中，我们使用`Nat.dvd_gcd_iff`将形式为`m ∣ Nat.gcd
    n k`的表达式替换为等价表达式`m ∣ n ∧ m ∣ k`。
- en: '[PRE165]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: See if you can use `rw` with the theorem below to provide a short proof that
    negation is not a nondecreasing function. (Note that `push_neg` won’t unfold definitions
    for you, so the `rw [Monotone]` in the proof of the theorem is needed.)
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否可以使用`rw`与下面的定理一起提供否定不是非递增函数的简短证明。（注意，`push_neg`不会为你展开定义，所以定理证明中的`rw [Monotone]`是必需的。）
- en: '[PRE166]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'The remaining exercises in this section are designed to give you some more
    practice with conjunction and bi-implication. Remember that a *partial order*
    is a binary relation that is transitive, reflexive, and antisymmetric. An even
    weaker notion sometimes arises: a *preorder* is just a reflexive, transitive relation.
    For any pre-order `≤`, Lean axiomatizes the associated strict pre-order by `a
    < b ↔ a ≤ b ∧ ¬ b ≤ a`. Show that if `≤` is a partial order, then `a < b` is equivalent
    to `a ≤ b ∧ a ≠ b`:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 本节剩余的练习旨在让你在合取和双条件方面获得更多实践。记住，*偏序*是一个传递的、自反的和反对称的二元关系。有时会出现一个更弱的概念：*预序*只是一个自反的和传递的关系。对于任何预序`≤`，Lean通过`a
    < b ↔ a ≤ b ∧ ¬ b ≤ a`来公理化相关的严格预序。证明如果`≤`是一个偏序，那么`a < b`等价于`a ≤ b ∧ a ≠ b`：
- en: '[PRE167]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Beyond logical operations, you do not need anything more than `le_refl` and
    `le_trans`. Show that even in the case where `≤` is only assumed to be a preorder,
    we can prove that the strict order is irreflexive and transitive. In the second
    example, for convenience, we use the simplifier rather than `rw` to express `<`
    in terms of `≤` and `¬`. We will come back to the simplifier later, but here we
    are only relying on the fact that it will use the indicated lemma repeatedly,
    even if it needs to be instantiated to different values.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 除了逻辑运算之外，你不需要比 `le_refl` 和 `le_trans` 更多的东西。证明即使 `≤` 只被假设为偏序，我们也可以证明严格顺序是不可自反的和传递的。在第二个例子中，为了方便起见，我们使用简化器而不是
    `rw` 来用 `≤` 和 `¬` 表达 `<`。我们稍后会回到简化器，但在这里我们只依赖于这样一个事实，即它将反复使用指定的引理，即使它需要实例化为不同的值。
- en: '[PRE168]  ## 3.5\. Disjunction[](#disjunction "Link to this heading")'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE168]  ## 3.5\. 析取[](#disjunction "链接到这个标题")'
- en: The canonical way to prove a disjunction `A ∨ B` is to prove `A` or to prove
    `B`. The `left` tactic chooses `A`, and the `right` tactic chooses `B`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 证明析取 `A ∨ B` 的规范方法是证明 `A` 或证明 `B`。`left` 策略选择 `A`，而 `right` 策略选择 `B`。
- en: '[PRE169]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: We cannot use an anonymous constructor to construct a proof of an “or” because
    Lean would have to guess which disjunct we are trying to prove. When we write
    proof terms we can use `Or.inl` and `Or.inr` instead to make the choice explicitly.
    Here, `inl` is short for “introduction left” and `inr` is short for “introduction
    right.”
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用匿名构造函数来构造一个“或”的证明，因为 Lean 需要猜测我们正在尝试证明哪个析取支。当我们编写证明项时，我们可以使用 `Or.inl`
    和 `Or.inr` 来明确地做出选择。在这里，`inl` 是“引入左”的缩写，而 `inr` 是“引入右”的缩写。
- en: '[PRE170]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: It may seem strange to prove a disjunction by proving one side or the other.
    In practice, which case holds usually depends on a case distinction that is implicit
    or explicit in the assumptions and the data. The `rcases` tactic allows us to
    make use of a hypothesis of the form `A ∨ B`. In contrast to the use of `rcases`
    with conjunction or an existential quantifier, here the `rcases` tactic produces
    *two* goals. Both have the same conclusion, but in the first case, `A` is assumed
    to be true, and in the second case, `B` is assumed to be true. In other words,
    as the name suggests, the `rcases` tactic carries out a proof by cases. As usual,
    we can tell Lean what names to use for the hypotheses. In the next example, we
    tell Lean to use the name `h` on each branch.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 通过证明析取的一侧或另一侧来证明析取可能看起来很奇怪。在实践中，哪个情况成立通常取决于假设和数据中隐含或显含的情况区分。`rcases` 策略允许我们利用形式为
    `A ∨ B` 的假设。与 `rcases` 与合取或存在量词的使用相比，这里 `rcases` 策略产生 *两个* 目标。这两个目标有相同的结论，但在第一种情况下，假设
    `A` 为真，在第二种情况下，假设 `B` 为真。换句话说，正如其名称所暗示的，`rcases` 策略通过分情况进行证明。像往常一样，我们可以告诉 Lean
    使用哪些名称来命名假设。在下一个例子中，我们告诉 Lean 在每个分支上使用名称 `h`。
- en: '[PRE171]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Notice that the pattern changes from `⟨h₀, h₁⟩` in the case of a conjunction
    to `h₀ | h₁` in the case of a disjunction. Think of the first pattern as matching
    against data the contains *both* an `h₀` and a `h₁`, whereas second pattern, with
    the bar, matches against data that contains *either* an `h₀` or `h₁`. In this
    case, because the two goals are separate, we have chosen to use the same name,
    `h`, in each case.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，模式从合取的情况中的 `⟨h₀, h₁⟩` 变为析取的情况中的 `h₀ | h₁`。将第一个模式视为与包含 *两个* `h₀` 和 `h₁` 的数据匹配，而第二个模式，带有竖线，与包含
    *一个* `h₀` 或 `h₁` 的数据匹配。在这种情况下，因为两个目标是分开的，所以我们选择在每个情况下使用相同的名称，即 `h`。
- en: The absolute value function is defined in such a way that we can immediately
    prove that `x ≥ 0` implies `|x| = x` (this is the theorem `abs_of_nonneg`) and
    `x < 0` implies `|x| = -x` (this is `abs_of_neg`). The expression `le_or_gt 0
    x` establishes `0 ≤ x ∨ x < 0`, allowing us to split on those two cases.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对值函数被定义为这样的方式，我们可以立即证明 `x ≥ 0` 蕴含 `|x| = x`（这是定理 `abs_of_nonneg`），以及 `x < 0`
    蕴含 `|x| = -x`（这是 `abs_of_neg`）。表达式 `le_or_gt 0 x` 建立了 `0 ≤ x ∨ x < 0`，允许我们在这两种情况下进行拆分。
- en: Lean also supports the computer scientists’ pattern-matching syntax for disjunction.
    Now the `cases` tactic is more attractive, because it allows us to name each `case`,
    and name the hypothesis that is introduced closer to where it is used.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 还支持计算机科学家的析取模式匹配语法。现在 `cases` 策略更具吸引力，因为它允许我们为每个 `case` 命名，并为引入的假设命名，使其更接近使用位置。
- en: '[PRE172]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: The names `inl` and `inr` are short for “intro left” and “intro right,” respectively.
    Using `case` has the advantage that you can prove the cases in either order; Lean
    uses the tag to find the relevant goal. If you don’t care about that, you can
    use `next`, or `match`, or even a pattern-matching `have`.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`inl` 和 `inr` 的名字是“intro left”和“intro right”的简称。使用 `case` 的优点是你可以按任意顺序证明情况；Lean
    使用标签来找到相关的目标。如果你不在乎这一点，你可以使用 `next`，或者 `match`，甚至是一个模式匹配的 `have`。'
- en: '[PRE173]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: In the case of `match`, we need to use the full names `Or.inl` and `Or.inr`
    of the canonical ways to prove a disjunction. In this textbook, we will generally
    use `rcases` to split on the cases of a disjunction.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `match` 的情况下，我们需要使用证明析取的规范方式 `Or.inl` 和 `Or.inr` 的全名。在这本教科书中，我们将通常使用 `rcases`
    来分割析取的情况。
- en: Try proving the triangle inequality using the first two theorems in the next
    snippet. They are given the same names they have in Mathlib.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用下一个片段中的前两个定理来证明三角不等式。它们在 Mathlib 中的名称与数学中的名称相同。
- en: '[PRE174]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: In case you enjoyed these (pun intended) and you want more practice with disjunction,
    try these.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢这些（故意为之）并且想要更多关于析取的练习，试试这些。
- en: '[PRE175]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: You can also use `rcases` and `rintro` with nested disjunctions. When these
    result in a genuine case split with multiple goals, the patterns for each new
    goal are separated by a vertical bar.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `rcases` 和 `rintro` 与嵌套析取一起使用。当这些导致具有多个目标的真正情况分割时，每个新目标的模式由一个垂直线分隔。
- en: '[PRE176]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'You can still nest patterns and use the `rfl` keyword to substitute equations:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以嵌套模式并使用 `rfl` 关键字来替换等式：
- en: '[PRE177]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: See if you can prove the following with a single (long) line. Use `rcases` to
    unpack the hypotheses and split on cases, and use a semicolon and `linarith` to
    solve each branch.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能用一行（长）代码证明以下内容。使用 `rcases` 来展开假设并按情况分割，并使用分号和 `linarith` 来解决每个分支。
- en: '[PRE178]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'On the real numbers, an equation `x * y = 0` tells us that `x = 0` or `y =
    0`. In Mathlib, this fact is known as `eq_zero_or_eq_zero_of_mul_eq_zero`, and
    it is another nice example of how a disjunction can arise. See if you can use
    it to prove the following:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在实数上，方程 `x * y = 0` 告诉我们 `x = 0` 或 `y = 0`。在 Mathlib 中，这个事实被称为 `eq_zero_or_eq_zero_of_mul_eq_zero`，它是如何从析取中产生的一个很好的例子。看看你是否可以用它来证明以下内容：
- en: '[PRE179]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Remember that you can use the `ring` tactic to help with calculations.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你可以使用 `ring` 策略来帮助计算。
- en: 'In an arbitrary ring \(R\), an element \(x\) such that \(x y = 0\) for some
    nonzero \(y\) is called a *left zero divisor*, an element \(x\) such that \(y
    x = 0\) for some nonzero \(y\) is called a *right zero divisor*, and an element
    that is either a left or right zero divisor is called simply a *zero divisor*.
    The theorem `eq_zero_or_eq_zero_of_mul_eq_zero` says that the real numbers have
    no nontrivial zero divisors. A commutative ring with this property is called an
    *integral domain*. Your proofs of the two theorems above should work equally well
    in any integral domain:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在任意环 \(R\) 中，一个元素 \(x\)，使得对于某个非零的 \(y\) 有 \(x y = 0\)，被称为 *左零因子*，一个元素 \(x\)，使得对于某个非零的
    \(y\) 有 \(y x = 0\)，被称为 *右零因子*，而一个既是左零因子又是右零因子的元素被称为简单的 *零因子*。定理 `eq_zero_or_eq_zero_of_mul_eq_zero`
    表明实数没有非平凡零因子。具有这种性质的交换环被称为 *整环*。你上面两个定理的证明在任意整环中同样有效：
- en: '[PRE180]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: In fact, if you are careful, you can prove the first theorem without using commutativity
    of multiplication. In that case, it suffices to assume that `R` is a `Ring` instead
    of an `CommRing`.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果你小心，你可以不使用乘法的交换性来证明第一个定理。在这种情况下，只需假设 `R` 是一个 `Ring` 而不是 `CommRing`。
- en: 'Sometimes in a proof we want to split on cases depending on whether some statement
    is true or not. For any proposition `P`, we can use `em P : P ∨ ¬ P`. The name
    `em` is short for “excluded middle.”'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '有时在证明中，我们想要根据某个陈述是否为真来分割情况。对于任何命题 `P`，我们可以使用 `em P : P ∨ ¬ P`。`em` 的名字是“excluded
    middle”的简称。'
- en: '[PRE181]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Alternatively, you can use the `by_cases` tactic.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用 `by_cases` 策略。
- en: '[PRE182]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Notice that the `by_cases` tactic lets you specify a label for the hypothesis
    that is introduced in each branch, in this case, `h'' : P` in one and `h'' : ¬
    P` in the other. If you leave out the label, Lean uses `h` by default. Try proving
    the following equivalence, using `by_cases` to establish one direction.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '注意到 `by_cases` 策略允许你为每个分支中引入的假设指定一个标签，在这种情况下，一个分支是 `h'' : P`，另一个分支是 `h'' :
    ¬ P`。如果你省略了标签，Lean 默认使用 `h`。尝试使用 `by_cases` 来证明以下等价性，以建立其中一个方向。'
- en: '[PRE183]  ## 3.6\. Sequences and Convergence[](#sequences-and-convergence
    "Link to this heading")'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE183]  ## 3.6\. 序列与收敛[](#sequences-and-convergence "链接到这个标题")'
- en: 'We now have enough skills at our disposal to do some real mathematics. In Lean,
    we can represent a sequence \(s_0, s_1, s_2, \ldots\) of real numbers as a function
    `s : ℕ → ℝ`. Such a sequence is said to *converge* to a number \(a\) if for every
    \(\varepsilon > 0\) there is a point beyond which the sequence remains within
    \(\varepsilon\) of \(a\), that is, there is a number \(N\) such that for every
    \(n \ge N\), \(| s_n - a | < \varepsilon\). In Lean, we can render this as follows:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们已经有足够的技能来做一些真正的数学了。在 Lean 中，我们可以将实数序列 \(s_0, s_1, s_2, \ldots\) 表示为一个函数
    `s : ℕ → ℝ`。这样的序列被称为*收敛*到数字 \(a\)，如果对于每一个 \(\varepsilon > 0\)，都有一个点，在此点之后序列始终保持在
    \(a\) 的 \(\varepsilon\) 范围内，也就是说，存在一个数字 \(N\)，使得对于每一个 \(n \ge N\)，\(| s_n - a
    | < \varepsilon\)。在 Lean 中，我们可以这样表示：'
- en: '[PRE184]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: The notation `∀ ε > 0, ...` is a convenient abbreviation for `∀ ε, ε > 0 → ...`,
    and, similarly, `∀ n ≥ N, ...` abbreviates `∀ n, n ≥ N →  ...`. And remember that
    `ε > 0`, in turn, is defined as `0 < ε`, and `n ≥ N` is defined as `N ≤ n`.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 `∀ ε > 0, ...` 是 `∀ ε, ε > 0 → ...` 的方便缩写，同样，`∀ n ≥ N, ...` 缩写为 `∀ n, n ≥
    N → ...`。并且记住，`ε > 0`，反过来，定义为 `0 < ε`，而 `n ≥ N` 定义为 `N ≤ n`。
- en: In this section, we’ll establish some properties of convergence. But first,
    we will discuss three tactics for working with equality that will prove useful.
    The first, the `ext` tactic, gives us a way of proving that two functions are
    equal. Let \(f(x) = x + 1\) and \(g(x) = 1 + x\) be functions from reals to reals.
    Then, of course, \(f = g\), because they return the same value for every \(x\).
    The `ext` tactic enables us to prove an equation between functions by proving
    that their values are the same at all the values of their arguments.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将建立一些收敛的性质。但首先，我们将讨论三个用于处理等式的策略，这些策略将非常有用。第一个，`ext` 策略，为我们提供了一种证明两个函数相等的方法。设
    \(f(x) = x + 1\) 和 \(g(x) = 1 + x\) 是从实数到实数的函数。当然，\(f = g\)，因为它们对每个 \(x\) 返回相同的值。`ext`
    策略使我们能够通过证明在所有参数值上它们的值都相同来证明函数之间的等式。
- en: '[PRE185]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'We’ll see later that `ext` is actually more general, and also one can specify
    the name of the variables that appear. For instance you can try to replace `ext`
    with `ext u v` in the above proof. The second tactic, the `congr` tactic, allows
    us to prove an equation between two expressions by reconciling the parts that
    are different:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会看到，`ext` 实际上更加通用，并且也可以指定出现变量的名称。例如，你可以在上面的证明中将 `ext` 替换为 `ext u v`。第二个策略，`congr`
    策略，允许我们通过协调不同的部分来证明两个表达式之间的等式：
- en: '[PRE186]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: Here the `congr` tactic peels off the `abs` on each side, leaving us to prove
    `a = a - b + b`.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`congr` 策略剥去了每一侧的 `abs`，留下我们证明 `a = a - b + b`。
- en: Finally, the `convert` tactic is used to apply a theorem to a goal when the
    conclusion of the theorem doesn’t quite match. For example, suppose we want to
    prove `a < a * a` from `1 < a`. A theorem in the library, `mul_lt_mul_right`,
    will let us prove `1 * a < a * a`. One possibility is to work backwards and rewrite
    the goal so that it has that form. Instead, the `convert` tactic lets us apply
    the theorem as it is, and leaves us with the task of proving the equations that
    are needed to make the goal match.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`convert` 策略用于在定理的结论与目标不完全匹配时将定理应用于目标。例如，假设我们想从 `1 < a` 证明 `a < a * a`。库中的一个定理
    `mul_lt_mul_right` 将允许我们证明 `1 * a < a * a`。一种可能性是反向工作并重写目标，使其具有那种形式。相反，`convert`
    策略允许我们按照原样应用定理，并留下证明目标匹配所需方程的任务。
- en: '[PRE187]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'This example illustrates another useful trick: when we apply an expression
    with an underscore and Lean can’t fill it in for us automatically, it simply leaves
    it for us as another goal.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了另一个有用的技巧：当我们应用一个带有下划线的表达式，而 Lean 无法自动填充它时，它就简单地将其留给我们作为另一个目标。
- en: The following shows that any constant sequence \(a, a, a, \ldots\) converges.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子表明，任何常数序列 \(a, a, a, \ldots\) 都会收敛。
- en: '[PRE188]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: Lean has a tactic, `simp`, which can often save you the trouble of carrying
    out steps like `rw [sub_self, abs_zero]` by hand. We will tell you more about
    it soon.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 有一个策略，`simp`，它经常可以节省我们手动执行 `rw [sub_self, abs_zero]` 等步骤的麻烦。我们很快就会告诉你更多关于它的信息。
- en: For a more interesting theorem, let’s show that if `s` converges to `a` and
    `t` converges to `b`, then `fun n ↦ s n + t n` converges to `a + b`. It is helpful
    to have a clear pen-and-paper proof in mind before you start writing a formal
    one. Given `ε` greater than `0`, the idea is to use the hypotheses to obtain an
    `Ns` such that beyond that point, `s` is within `ε / 2` of `a`, and an `Nt` such
    that beyond that point, `t` is within `ε / 2` of `b`. Then, whenever `n` is greater
    than or equal to the maximum of `Ns` and `Nt`, the sequence `fun n ↦ s n + t n`
    should be within `ε` of `a + b`. The following example begins to implement this
    strategy. See if you can finish it off.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个更有趣的定理，让我们证明如果`s`收敛到`a`且`t`收敛到`b`，那么`fun n ↦ s n + t n`收敛到`a + b`。在开始写正式证明之前，有一个清晰的笔和纸证明是有帮助的。给定大于`0`的`ε`，想法是使用假设来获得一个`Ns`，这样在这一点之后，`s`就在`a`的`ε
    / 2`范围内，以及一个`Nt`，这样在这一点之后，`t`就在`b`的`ε / 2`范围内。然后，每当`n`大于或等于`Ns`和`Nt`的最大值时，序列`fun
    n ↦ s n + t n`应该在`a + b`的`ε`范围内。以下示例开始实施这一策略。看看你是否能完成它。
- en: '[PRE189]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: As hints, you can use `le_of_max_le_left` and `le_of_max_le_right`, and `norm_num`
    can prove `ε / 2 + ε / 2 = ε`. Also, it is helpful to use the `congr` tactic to
    show that `|s n + t n - (a + b)|` is equal to `|(s n - a) + (t n - b)|,` since
    then you can use the triangle inequality. Notice that we marked all the variables
    `s`, `t`, `a`, and `b` implicit because they can be inferred from the hypotheses.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提示，你可以使用`le_of_max_le_left`和`le_of_max_le_right`，以及`norm_num`可以证明`ε / 2 +
    ε / 2 = ε`。此外，使用`congr`策略来证明`|s n + t n - (a + b)|`等于`|(s n - a) + (t n - b)|`是有帮助的，因为这样你就可以使用三角不等式。注意，我们标记了所有变量`s`、`t`、`a`和`b`为隐含的，因为它们可以从假设中推断出来。
- en: Proving the same theorem with multiplication in place of addition is tricky.
    We will get there by proving some auxiliary statements first. See if you can also
    finish off the next proof, which shows that if `s` converges to `a`, then `fun
    n ↦ c * s n` converges to `c * a`. It is helpful to split into cases depending
    on whether `c` is equal to zero or not. We have taken care of the zero case, and
    we have left you to prove the result with the extra assumption that `c` is nonzero.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 用乘法代替加法来证明同一个定理是棘手的。我们将通过首先证明一些辅助命题来达到这个目标。看看你是否也能完成下一个证明，它表明如果`s`收敛到`a`，那么`fun
    n ↦ c * s n`收敛到`c * a`。根据`c`是否等于零来分情况讨论是有帮助的。我们已经处理了零的情况，并留下你来证明在`c`非零的额外假设下得到的结果。
- en: '[PRE190]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'The next theorem is also independently interesting: it shows that a convergent
    sequence is eventually bounded in absolute value. We have started you off; see
    if you can finish it.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个定理也是独立有趣的：它表明收敛序列最终在绝对值上是有界的。我们已经为你奠定了基础；看看你是否能完成它。
- en: '[PRE191]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: In fact, the theorem could be strengthened to assert that there is a bound `b`
    that holds for all values of `n`. But this version is strong enough for our purposes,
    and we will see at the end of this section that it holds more generally.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这个定理可以被加强，断言存在一个对所有`n`值都成立的界限`b`。但这个版本对我们来说已经足够强大，我们将在本节末尾看到它更普遍地成立。
- en: 'The next lemma is auxiliary: we prove that if `s` converges to `a` and `t`
    converges to `0`, then `fun n ↦ s n * t n` converges to `0`. To do so, we use
    the previous theorem to find a `B` that bounds `s` beyond some point `N₀`. See
    if you can understand the strategy we have outlined and finish the proof.'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个引理是辅助性的：我们证明如果`s`收敛到`a`且`t`收敛到`0`，那么`fun n ↦ s n * t n`收敛到`0`。为此，我们使用前面的定理找到一个`B`，它从某个点`N₀`开始限制`s`。看看你是否能理解我们所概述的策略并完成证明。
- en: '[PRE192]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: If you have made it this far, congratulations! We are now within striking distance
    of our theorem. The following proof finishes it off.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经走到这一步，恭喜你！我们现在已经接近我们的定理了。以下证明完成了它。
- en: '[PRE193]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: For another challenging exercise, try filling out the following sketch of a
    proof that limits are unique. (If you are feeling bold, you can delete the proof
    sketch and try proving it from scratch.)
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 对于另一个具有挑战性的练习，尝试填写以下关于极限唯一性的证明草稿。（如果你感到自信，你可以删除证明草稿，并尝试从头开始证明。）
- en: '[PRE194]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'We close the section with the observation that our proofs can be generalized.
    For example, the only properties that we have used of the natural numbers is that
    their structure carries a partial order with `min` and `max`. You can check that
    everything still works if you replace `ℕ` everywhere by any linear order `α`:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节结束时注意到我们的证明可以推广。例如，我们使用的自然数的唯一属性是它们的结构携带一个具有`min`和`max`的偏序。你可以检查，如果你在所有地方用任何线性序`α`替换`ℕ`，一切仍然有效。
- en: '[PRE195]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'In [Section 11.1](C11_Topology.html#filters), we will see that Mathlib has
    mechanisms for dealing with convergence in vastly more general terms, not only
    abstracting away particular features of the domain and codomain, but also abstracting
    over different types of convergence.  ## 3.1\. Implication and the Universal Quantifier[](#implication-and-the-universal-quantifier
    "Link to this heading")'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11.1节](C11_Topology.html#filters)中，我们将看到Mathlib有处理收敛性的机制，这些机制在更广泛的范围内，不仅抽象了定义域和值域的特定特征，而且还抽象了不同类型的收敛。##
    3.1. 蕴含和全称量词[](#implication-and-the-universal-quantifier "链接到这个标题")
- en: 'Consider the statement after the `#check`:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`#check`之后的陈述：
- en: '[PRE196]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'In words, we would say “for every real number `x`, if `0 ≤ x` then the absolute
    value of `x` equals `x`”. We can also have more complicated statements like:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 用文字来说，我们会说“对于每一个实数`x`，如果`0 ≤ x`，那么`x`的绝对值等于`x`”。我们也可以有更复杂的陈述，例如：
- en: '[PRE197]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: In words, we would say “for every `x`, `y`, and `ε`, if `0 < ε ≤ 1`, the absolute
    value of `x` is less than `ε`, and the absolute value of `y` is less than `ε`,
    then the absolute value of `x * y` is less than `ε`.” In Lean, in a sequence of
    implications there are implicit parentheses grouped to the right. So the expression
    above means “if `0 < ε` then if `ε ≤ 1` then if `|x| < ε` …” As a result, the
    expression says that all the assumptions together imply the conclusion.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 用文字来说，我们会说“对于每一个`x`、`y`和`ε`，如果`0 < ε ≤ 1`，`x`的绝对值小于`ε`，`y`的绝对值小于`ε`，那么`x * y`的绝对值小于`ε`。”在Lean中，在一系列蕴含中，有隐式的括号分组到右边。所以上面的表达式意味着“如果`0
    < ε`，那么如果`ε ≤ 1`，那么如果`|x| < ε`……”因此，这个表达式表明所有假设共同蕴含结论。
- en: 'You have already seen that even though the universal quantifier in this statement
    ranges over objects and the implication arrows introduce hypotheses, Lean treats
    the two in very similar ways. In particular, if you have proved a theorem of that
    form, you can apply it to objects and hypotheses in the same way. We will use
    as an example the following statement that we will help you to prove a bit later:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，尽管这个陈述中的全称量词在对象上取值，而蕴含箭头引入了假设，但Lean以非常相似的方式处理这两者。特别是，如果你已经证明了这种形式的定理，你可以以相同的方式将其应用于对象和假设。我们将以下陈述作为例子，稍后我们将帮助你证明它：
- en: '[PRE198]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: You have also already seen that it is common in Lean to use curly brackets to
    make quantified variables implicit when they can be inferred from subsequent hypotheses.
    When we do that, we can just apply a lemma to the hypotheses without mentioning
    the objects.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 你也已经看到，在Lean中，当量化的变量可以从后续的假设中推断出来时，通常使用花括号使量化的变量隐式。当我们这样做时，我们只需将引理应用于假设，而无需提及对象。
- en: '[PRE199]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: At this stage, you also know that if you use the `apply` tactic to apply `my_lemma`
    to a goal of the form `|a * b| < δ`, you are left with new goals that require
    you to prove each of the hypotheses.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你也知道，如果你使用`apply`策略将`my_lemma`应用于形式为`|a * b| < δ`的目标，你将面临新的目标，需要你证明每个假设。
- en: 'To prove a statement like this, use the `intro` tactic. Take a look at what
    it does in this example:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 要证明这样的陈述，使用`intro`策略。看看它在下面的例子中做了什么：
- en: '[PRE200]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'We can use any names we want for the universally quantified variables; they
    do not have to be `x`, `y`, and `ε`. Notice that we have to introduce the variables
    even though they are marked implicit: making them implicit means that we leave
    them out when we write an expression *using* `my_lemma`, but they are still an
    essential part of the statement that we are proving. After the `intro` command,
    the goal is what it would have been at the start if we listed all the variables
    and hypotheses *before* the colon, as we did in the last section. In a moment,
    we will see why it is sometimes necessary to introduce variables and hypotheses
    after the proof begins.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为全称量化的变量使用任何我们想要的名称；它们不必是`x`、`y`和`ε`。请注意，即使它们被标记为隐式，我们也必须引入这些变量：使它们隐式意味着在写一个表达式*使用*`my_lemma`时我们可以省略它们，但它们仍然是我们正在证明的陈述的一个基本部分。在`intro`命令之后，目标是如果我们在冒号之前列出了所有变量和假设，它将是什么，就像我们在上一节中做的那样。一会儿我们将看到为什么有时在证明开始后引入变量和假设是必要的。
- en: 'To help you prove the lemma, we will start you off:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你证明引理，我们将从以下内容开始：
- en: '[PRE201]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: Finish the proof using the theorems `abs_mul`, `mul_le_mul`, `abs_nonneg`, `mul_lt_mul_right`,
    and `one_mul`. Remember that you can find theorems like these using Ctrl-space
    completion (or Cmd-space completion on a Mac). Remember also that you can use
    `.mp` and `.mpr` or `.1` and `.2` to extract the two directions of an if-and-only-if
    statement.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 使用定理 `abs_mul`、`mul_le_mul`、`abs_nonneg`、`mul_lt_mul_right` 和 `one_mul` 完成证明。记住，你可以使用
    Ctrl-space 完成提示（或在 Mac 上使用 Cmd-space 完成提示）来找到这样的定理。还要记住，你可以使用 `.mp` 和 `.mpr` 或
    `.1` 和 `.2` 来提取双向条件语句的两个方向。
- en: Universal quantifiers are often hidden in definitions, and Lean will unfold
    definitions to expose them when necessary. For example, let’s define two predicates,
    `FnUb f a` and `FnLb f a`, where `f` is a function from the real numbers to the
    real numbers and `a` is a real number. The first says that `a` is an upper bound
    on the values of `f`, and the second says that `a` is a lower bound on the values
    of `f`.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 全称量词通常隐藏在定义中，当需要时 Lean 会展开定义来揭示它们。例如，让我们定义两个谓词，`FnUb f a` 和 `FnLb f a`，其中 `f`
    是从实数到实数的函数，而 `a` 是一个实数。第一个谓词表示 `a` 是 `f` 的值的上界，第二个谓词表示 `a` 是 `f` 的值的下界。
- en: '[PRE202]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: In the next example, `fun x ↦ f x + g x` is the function that maps `x` to `f
    x + g x`. Going from the expression `f x + g x` to this function is called a lambda
    abstraction in type theory.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，`fun x ↦ f x + g x` 是将 `x` 映射到 `f x + g x` 的函数。从表达式 `f x + g x` 到这个函数的转换在类型理论中称为
    lambda 抽象。
- en: '[PRE203]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Applying `intro` to the goal `FnUb (fun x ↦ f x + g x) (a + b)` forces Lean
    to unfold the definition of `FnUb` and introduce `x` for the universal quantifier.
    The goal is then `(fun (x : ℝ) ↦ f x + g x) x ≤ a + b`. But applying `(fun x ↦
    f x + g x)` to `x` should result in `f x + g x`, and the `dsimp` command performs
    that simplification. (The “d” stands for “definitional.”) You can delete that
    command and the proof still works; Lean would have to perform that contraction
    anyhow to make sense of the next `apply`. The `dsimp` command simply makes the
    goal more readable and helps us figure out what to do next. Another option is
    to use the `change` tactic by writing `change f x + g x ≤ a + b`. This helps make
    the proof more readable, and gives you more control over how the goal is transformed.'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '将 `intro` 应用于目标 `FnUb (fun x ↦ f x + g x) (a + b)` 迫使 Lean 展开对 `FnUb` 的定义并引入
    `x` 作为全称量词。目标变为 `(fun (x : ℝ) ↦ f x + g x) x ≤ a + b`。但是将 `(fun x ↦ f x + g x)`
    应用于 `x` 应该得到 `f x + g x`，而 `dsimp` 命令执行了这种简化。（“d”代表“定义性的。”）你可以删除该命令，证明仍然有效；Lean
    无论如何都必须执行这种收缩以使下一个 `apply` 有意义。`dsimp` 命令只是使目标更易于阅读，并帮助我们确定下一步该做什么。另一个选择是使用 `change`
    策略，通过编写 `change f x + g x ≤ a + b` 来实现。这有助于使证明更易于阅读，并让你对目标如何转换有更多的控制。'
- en: 'The rest of the proof is routine. The last two `apply` commands force Lean
    to unfold the definitions of `FnUb` in the hypotheses. Try carrying out similar
    proofs of these:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 证明的其余部分是常规的。最后的两个 `apply` 命令迫使 Lean 在假设中展开 `FnUb` 的定义。尝试执行类似的证明：
- en: '[PRE204]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Even though we have defined `FnUb` and `FnLb` for functions from the reals to
    the reals, you should recognize that the definitions and proofs are much more
    general. The definitions make sense for functions between any two types for which
    there is a notion of order on the codomain. Checking the type of the theorem `add_le_add`
    shows that it holds of any structure that is an “ordered additive commutative
    monoid”; the details of what that means don’t matter now, but it is worth knowing
    that the natural numbers, integers, rationals, and real numbers are all instances.
    So if we prove the theorem `fnUb_add` at that level of generality, it will apply
    in all these instances.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经为从实数到实数的函数定义了 `FnUb` 和 `FnLb`，但你应该认识到定义和证明要普遍得多。这些定义适用于任何两个类型之间的函数，其中目标域上有序的概念。检查定理
    `add_le_add` 的类型显示，它适用于任何“有序加法交换幺半群”的结构；现在不需要详细说明这意味着什么，但值得知道自然数、整数、有理数和实数都是实例。因此，如果我们在这个普遍性级别上证明定理
    `fnUb_add`，它将适用于所有这些实例。
- en: '[PRE205]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: You have already seen square brackets like these in Section [Section 2.2](C02_Basics.html#proving-identities-in-algebraic-structures),
    though we still haven’t explained what they mean. For concreteness, we will stick
    to the real numbers for most of our examples, but it is worth knowing that Mathlib
    contains definitions and theorems that work at a high level of generality.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在 [第 2.2 节](C02_Basics.html#proving-identities-in-algebraic-structures) 中看到过这样的方括号，尽管我们还没有解释它们的意义。为了具体化，我们将大部分例子都坚持使用实数，但值得知道
    Mathlib 包含在高度普遍性级别上工作的定义和定理。
- en: 'For another example of a hidden universal quantifier, Mathlib defines a predicate
    `Monotone`, which says that a function is nondecreasing in its arguments:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 对于另一个隐藏的全称量词的例子，Mathlib 定义了一个谓词 `Monotone`，它表示函数在其参数上是非递减的：
- en: '[PRE206]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: The property `Monotone f` is defined to be exactly the expression after the
    colon. We need to put the `@` symbol before `h` because if we don’t, Lean expands
    the implicit arguments to `h` and inserts placeholders.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 属性 `Monotone f` 被定义为冒号后面的确切表达式。我们需要在 `h` 前面放置 `@` 符号，因为我们不这样做的话，Lean 会将隐含的参数扩展到
    `h` 并插入占位符。
- en: Proving statements about monotonicity involves using `intro` to introduce two
    variables, say, `a` and `b`, and the hypothesis `a ≤ b`. To *use* a monotonicity
    hypothesis, you can apply it to suitable arguments and hypotheses, and then apply
    the resulting expression to the goal. Or you can apply it to the goal and let
    Lean help you work backwards by displaying the remaining hypotheses as new subgoals.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 证明关于单调性的命题涉及使用 `intro` 引入两个变量，例如 `a` 和 `b`，以及假设 `a ≤ b`。要 *使用* 单调性假设，你可以将其应用于合适的参数和假设，然后将结果表达式应用于目標。或者，你可以将其应用于目標，让
    Lean 通过显示剩余假设作为新的子目標来帮助你反向工作。
- en: '[PRE207]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: When a proof is this short, it is often convenient to give a proof term instead.
    To describe a proof that temporarily introduces objects `a` and `b` and a hypothesis
    `aleb`, Lean uses the notation `fun a b aleb ↦ ...`. This is analogous to the
    way that an expression like `fun x ↦ x^2` describes a function by temporarily
    naming an object, `x`, and then using it to describe a value. So the `intro` command
    in the previous proof corresponds to the lambda abstraction in the next proof
    term. The `apply` commands then correspond to building the application of the
    theorem to its arguments.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 当证明如此简短时，通常方便给出一个证明术语。为了描述一个临时引入对象 `a` 和 `b` 以及假设 `aleb` 的证明，Lean 使用了 `fun a
    b aleb ↦ ...` 的符号。这与像 `fun x ↦ x^2` 这样的表达式通过临时命名一个对象 `x` 并用它来描述一个值的方式来描述一个函数是相似的。因此，前一个证明中的
    `intro` 命令对应于下一个证明术语中的 lambda 抽象。然后，`apply` 命令对应于将定理应用于其参数的构造。
- en: '[PRE208]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'Here is a useful trick: if you start writing the proof term `fun a b aleb ↦
    _` using an underscore where the rest of the expression should go, Lean will flag
    an error, indicating that it can’t guess the value of that expression. If you
    check the Lean Goal window in VS Code or hover over the squiggly error marker,
    Lean will show you the goal that the remaining expression has to solve.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有用的技巧：如果你开始编写证明术语 `fun a b aleb ↦ _` 并在表达式其余部分应该放置的地方使用下划线，Lean 将会标记一个错误，表明它无法猜测该表达式的值。如果你在
    VS Code 中的 Lean Goal 窗口或悬停在波浪形错误标记上，Lean 将会显示剩余表达式需要解决的目標。
- en: 'Try proving these, with either tactics or proof terms:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用策略或证明术语来证明这些命题：
- en: '[PRE209]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: Here are some more examples. A function \(f\) from \(\Bbb R\) to \(\Bbb R\)
    is said to be *even* if \(f(-x) = f(x)\) for every \(x\), and *odd* if \(f(-x)
    = -f(x)\) for every \(x\). The following example defines these two notions formally
    and establishes one fact about them. You can complete the proofs of the others.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些更多的例子。从 \(\Bbb R\) 到 \(\Bbb R\) 的函数 \(f\) 被称为 *偶函数*，如果对于每个 \(x\)，\(f(-x)
    = f(x)\)；如果对于每个 \(x\)，\(f(-x) = -f(x)\)，则称为 *奇函数*。以下示例正式定义了这两个概念并建立了一个关于它们的命题。你可以完成其他命题的证明。
- en: '[PRE210]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: The first proof can be shortened using `dsimp` or `change` to get rid of the
    lambda abstraction. But you can check that the subsequent `rw` won’t work unless
    we get rid of the lambda abstraction explicitly, because otherwise it cannot find
    the patterns `f x` and `g x` in the expression. Contrary to some other tactics,
    `rw` operates on the syntactic level, it won’t unfold definitions or apply reductions
    for you (it has a variant called `erw` that tries a little harder in this direction,
    but not much harder).
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个证明可以使用 `dsimp` 或 `change` 来缩短，以消除 lambda 抽象。但你可以检查，除非我们明确地消除 lambda 抽象，否则后续的
    `rw` 不会工作，因为否则它无法在表达式中找到 `f x` 和 `g x` 的模式。与一些其他策略不同，`rw` 在句法级别上操作，它不会展开定义或为你应用简化（它有一个名为
    `erw` 的变体，在这个方向上尝试得稍微努力一些，但不是很多）。
- en: You can find implicit universal quantifiers all over the place, once you know
    how to spot them.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道如何找到它们，你可以在任何地方找到隐含的全称量词。
- en: Mathlib includes a good library for manipulating sets. Recall that Lean does
    not use foundations based on set theory, so here the word set has its mundane
    meaning of a collection of mathematical objects of some given type `α`. If `x`
    has type `α` and `s` has type `Set α`, then `x ∈ s` is a proposition that asserts
    that `x` is an element of `s`. If `y` has some different type `β` then the expression
    `y ∈ s` makes no sense. Here “makes no sense” means “has no type hence Lean does
    not accept it as a well-formed statement”. This contrasts with Zermelo-Fraenkel
    set theory for instance where `a ∈ b` is a well-formed statement for every mathematical
    objects `a` and `b`. For instance `sin ∈ cos` is a well-formed statement in ZF.
    This defect of set theoretic foundations is an important motivation for not using
    it in a proof assistant which is meant to assist us by detecting meaningless expressions.
    In Lean `sin` has type `ℝ → ℝ` and `cos` has type `ℝ → ℝ` which is not equal to
    `Set (ℝ → ℝ)`, even after unfolding definitions, so the statement `sin ∈ cos`
    makes no sense. One can also use Lean to work on set theory itself. For instance
    the independence of the continuum hypothesis from the axioms of Zermelo-Fraenkel
    has been formalized in Lean. But such a meta-theory of set theory is completely
    beyond the scope of this book.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib 包含了一个用于操作集合的良好库。回想一下，Lean 不使用基于集合理论的公理系统，因此在这里，“集合”一词具有平凡的意义，即某种给定类型
    `α` 的数学对象的集合。如果 `x` 具有类型 `α` 且 `s` 具有类型 `Set α`，那么 `x ∈ s` 是一个命题，它断言 `x` 是 `s`
    的一个元素。如果 `y` 具有某种不同的类型 `β`，那么表达式 `y ∈ s` 就没有意义。这里的“没有意义”意味着“没有类型，因此 Lean 不接受它作为一个有效的语句”。这与例如
    Zermelo-Fraenkel 集合理论形成对比，在 ZF 中，对于每个数学对象 `a` 和 `b`，`a ∈ b` 都是一个有效的语句。例如，在 ZF
    中 `sin ∈ cos` 是一个有效的语句。集合理论基础的这种缺陷是重要的动机，即不在旨在通过检测无意义表达式来帮助我们证明辅助工具中使用它。在 Lean
    中，`sin` 具有类型 `ℝ → ℝ`，`cos` 也具有类型 `ℝ → ℝ`，这并不等于 `Set (ℝ → ℝ)`，即使展开定义之后也是如此，因此语句
    `sin ∈ cos` 没有意义。人们也可以使用 Lean 来研究集合理论本身。例如，连续性假设与 Zermelo-Fraenkel 公理的独立性已经在 Lean
    中形式化。但这样的集合理论元理论完全超出了本书的范围。
- en: 'If `s` and `t` are of type `Set α`, then the subset relation `s ⊆ t` is defined
    to mean `∀ {x : α}, x ∈ s → x ∈ t`. The variable in the quantifier is marked implicit
    so that given `h : s ⊆ t` and `h'' : x ∈ s`, we can write `h h''` as justification
    for `x ∈ t`. The following example provides a tactic proof and a proof term justifying
    the reflexivity of the subset relation, and asks you to do the same for transitivity.'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 `s` 和 `t` 都是类型 `Set α`，那么子集关系 `s ⊆ t` 被定义为 `∀ {x : α}, x ∈ s → x ∈ t`。量词中的变量被标记为隐含的，这样给定
    `h : s ⊆ t` 和 `h'' : x ∈ s`，我们可以写出 `h h''` 作为 `x ∈ t` 的理由。以下例子提供了一个策略证明和一个证明项，以证明子集关系的自反性，并要求你为传递性做同样的证明。'
- en: '[PRE211]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Just as we defined `FnUb` for functions, we can define `SetUb s a` to mean that
    `a` is an upper bound on the set `s`, assuming `s` is a set of elements of some
    type that has an order associated with it. In the next example, we ask you to
    prove that if `a` is a bound on `s` and `a ≤ b`, then `b` is a bound on `s` as
    well.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们为函数定义了 `FnUb`，我们也可以定义 `SetUb s a` 来表示 `a` 是集合 `s` 的上界，假设 `s` 是某种具有关联顺序的元素集合。在下一个例子中，我们要求你证明如果
    `a` 是 `s` 的一个界且 `a ≤ b`，那么 `b` 也是 `s` 的一个界。
- en: '[PRE212]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: We close this section with one last important example. A function \(f\) is said
    to be *injective* if for every \(x_1\) and \(x_2\), if \(f(x_1) = f(x_2)\) then
    \(x_1 = x_2\). Mathlib defines `Function.Injective f` with `x₁` and `x₂` implicit.
    The next example shows that, on the real numbers, any function that adds a constant
    is injective. We then ask you to show that multiplication by a nonzero constant
    is also injective, using the lemma name in the example as a source of inspiration.
    Recall you should use Ctrl-space completion after guessing the beginning of a
    lemma name.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一个最后的、重要的例子结束本节。一个函数 \(f\) 被称为 *注入的*，如果对于每一个 \(x_1\) 和 \(x_2\)，如果 \(f(x_1)
    = f(x_2)\)，那么 \(x_1 = x_2\)。Mathlib 使用隐含的 `x₁` 和 `x₂` 定义 `Function.Injective f`。下一个例子展示了在实数上，任何添加常数的函数都是注入的。然后我们要求你使用例子中的引理名称作为灵感来源，证明乘以非零常数也是注入的。回想一下，你应该在猜测引理名称的开头后使用
    Ctrl-space 完成功能。
- en: '[PRE213]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'Finally, show that the composition of two injective functions is injective:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，证明两个注入函数的复合是注入的：
- en: '[PRE214]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '## 3.2\. The Existential Quantifier[](#the-existential-quantifier "Link to
    this heading")'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '## 3.2\. 存在量词[](#the-existential-quantifier "链接到本标题")'
- en: 'The existential quantifier, which can be entered as `\ex` in VS Code, is used
    to represent the phrase “there exists.” The formal expression `∃ x : ℝ, 2 < x
    ∧ x < 3` in Lean says that there is a real number between 2 and 3. (We will discuss
    the conjunction symbol, `∧`, in [Section 3.4](#conjunction-and-biimplication).)
    The canonical way to prove such a statement is to exhibit a real number and show
    that it has the stated property. The number 2.5, which we can enter as `5 / 2`
    or `(5 : ℝ) / 2` when Lean cannot infer from context that we have the real numbers
    in mind, has the required property, and the `norm_num` tactic can prove that it
    meets the description.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '存在量词，可以在 VS Code 中输入为 `\ex`，用来表示“存在”这个短语。在 Lean 中，形式表达式 `∃ x : ℝ, 2 < x ∧ x
    < 3` 表示存在一个实数在 2 和 3 之间。（我们将在 [第 3.4 节](#conjunction-and-biimplication) 讨论合取符号
    `∧`。）证明此类陈述的规范方法是展示一个实数并证明它具有所述的性质。数字 2.5，我们可以在 Lean 中输入为 `5 / 2` 或 `(5 : ℝ) /
    2`（当 Lean 无法从上下文中推断出我们指的是实数时），具有所需的性质，而 `norm_num` 策略可以证明它符合描述。'
- en: There are a few ways we can put the information together. Given a goal that
    begins with an existential quantifier, the `use` tactic is used to provide the
    object, leaving the goal of proving the property.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方法可以将信息组合起来。给定一个以存在量词开始的目標，使用 `use` 策略来提供对象，留下证明该属性的目标。
- en: '[PRE215]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'You can give the `use` tactic proofs as well as data:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以提供 `use` 策略的证明以及数据：
- en: '[PRE216]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: In fact, the `use` tactic automatically tries to use available assumptions as
    well.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`use` 策略会自动尝试使用可用的假设。
- en: '[PRE217]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: Alternatively, we can use Lean’s *anonymous constructor* notation to construct
    a proof of an existential quantifier.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 Lean 的 *匿名构造函数* 符号来构造一个存在量词的证明。
- en: '[PRE218]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'Notice that there is no `by`; here we are giving an explicit proof term. The
    left and right angle brackets, which can be entered as `\<` and `\>` respectively,
    tell Lean to put together the given data using whatever construction is appropriate
    for the current goal. We can use the notation without going first into tactic
    mode:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里没有 `by`；我们在这里提供了一个明确的证明项。左右尖括号，分别可以输入为 `\<` 和 `\>`，告诉 Lean 使用适当的构造将给定数据组合起来。我们可以使用这种符号而不必首先进入策略模式：
- en: '[PRE219]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'So now we know how to *prove* an exists statement. But how do we *use* one?
    If we know that there exists an object with a certain property, we should be able
    to give a name to an arbitrary one and reason about it. For example, remember
    the predicates `FnUb f a` and `FnLb f a` from the last section, which say that
    `a` is an upper bound or lower bound on `f`, respectively. We can use the existential
    quantifier to say that “`f` is bounded” without specifying the bound:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们知道了如何 *证明* 一个存在陈述。但如何 *使用* 它呢？如果我们知道存在具有某种性质的某个对象，我们应该能够给它命名并对其进行分析。例如，记住上一节中的谓词
    `FnUb f a` 和 `FnLb f a`，它们分别表示 `a` 是 `f` 的上界或下界。我们可以使用存在量词来说明“`f` 有界”，而不必指定界限：
- en: '[PRE220]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: We can use the theorem `FnUb_add` from the last section to prove that if `f`
    and `g` have upper bounds, then so does `fun x ↦ f x + g x`.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用上一节中的定理 `FnUb_add` 来证明，如果 `f` 和 `g` 有上界，那么 `fun x ↦ f x + g x` 也有上界。
- en: '[PRE221]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'The `rcases` tactic unpacks the information in the existential quantifier.
    The annotations like `⟨a, ubfa⟩`, written with the same angle brackets as the
    anonymous constructors, are known as *patterns*, and they describe the information
    that we expect to find when we unpack the main argument. Given the hypothesis
    `ubf` that there is an upper bound for `f`, `rcases ubf with ⟨a, ubfa⟩` adds a
    new variable `a` for an upper bound to the context, together with the hypothesis
    `ubfa` that it has the given property. The goal is left unchanged; what *has*
    changed is that we can now use the new object and the new hypothesis to prove
    the goal. This is a common method of reasoning in mathematics: we unpack objects
    whose existence is asserted or implied by some hypothesis, and then use it to
    establish the existence of something else.'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '`rcases` 策略解包存在量词中的信息。像 `⟨a, ubfa⟩` 这样的注释，使用与匿名构造函数相同的尖括号，被称为 *模式*，它们描述了我们解包主论点时预期找到的信息。给定存在
    `f` 的上界的假设 `ubf`，`rcases ubf with ⟨a, ubfa⟩` 将一个新的变量 `a`（上界）添加到上下文中，以及具有给定性质的假设
    `ubfa`。目标保持不变；真正改变的是，我们现在可以使用新的对象和新的假设来证明目标。这是数学中常见的推理方法：我们解包那些被某些假设断言或暗示存在性的对象，然后使用它来建立其他事物的存在。'
- en: Try using this method to establish the following. You might find it useful to
    turn some of the examples from the last section into named theorems, as we did
    with `fn_ub_add`, or you can insert the arguments directly into the proofs.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用这种方法来建立以下内容。你可能发现将上一节的一些示例转换为命名定理很有用，就像我们对 `fn_ub_add` 所做的那样，或者你可以直接将参数插入到证明中。
- en: '[PRE222]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'The “r” in `rcases` stands for “recursive,” because it allows us to use arbitrarily
    complex patterns to unpack nested data. The `rintro` tactic is a combination of
    `intro` and `rcases`:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '`rcases` 中的 “r” 代表 “recursive”，因为它允许我们使用任意复杂的模式来解包嵌套数据。`rintro` 策略是 `intro`
    和 `rcases` 的结合：'
- en: '[PRE223]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'In fact, Lean also supports a pattern-matching fun in expressions and proof
    terms:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Lean 也支持在表达式和证明项中使用模式匹配函数：
- en: '[PRE224]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'The task of unpacking information in a hypothesis is so important that Lean
    and Mathlib provide a number of ways to do it. For example, the `obtain` tactic
    provides suggestive syntax:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在假设中解包信息这项任务非常重要，以至于 Lean 和 Mathlib 提供了多种方法来完成它。例如，`obtain` 策略提供了提示性语法：
- en: '[PRE225]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: Think of the first `obtain` instruction as matching the “contents” of `ubf`
    with the given pattern and assigning the components to the named variables. `rcases`
    and `obtain` are said to `destruct` their arguments.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 将第一个 `obtain` 指令视为将 `ubf` 的“内容”与给定的模式匹配，并将组件分配给命名变量的过程。`rcases` 和 `obtain` 被说成是“破坏”它们的参数。
- en: 'Lean also supports syntax that is similar to that used in other functional
    programming languages:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 还支持与其他函数式编程语言中使用的语法相似的语法：
- en: '[PRE226]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'In the first example, if you put your cursor after `cases ubf`, you will see
    that the tactic produces a single goal, which Lean has tagged `intro`. (The particular
    name chosen comes from the internal name for the axiomatic primitive that builds
    a proof of an existential statement.) The `case` tactic then names the components.
    The second example is similar, except using `next` instead of `case` means that
    you can avoid mentioning `intro`. The word `match` in the last two examples highlights
    that what we are doing here is what computer scientists call “pattern matching.”
    Notice that the third proof begins by `by`, after which the tactic version of
    `match` expects a tactic proof on the right side of the arrow. The last example
    is a proof term: there are no tactics in sight.'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，如果你将光标放在 `cases ubf` 之后，你会看到该策略产生了一个单一的目标，Lean 已经将其标记为 `intro`。（所选名称来自构建存在性陈述证明的公理原语的内部名称。）然后
    `case` 策略命名了组件。第二个例子与第一个类似，只是使用 `next` 而不是 `case` 意味着你不必提到 `intro`。在最后两个例子中，“match”一词突出了我们在这里所做的是计算机科学家所说的“模式匹配”。注意，第三个证明从
    `by` 开始，之后 `match` 的策略版本期望箭头右侧有一个策略证明。最后一个例子是一个证明项：没有看到任何策略。
- en: For the rest of this book, we will stick to `rcases`, `rintro`, and `obtain`,
    as the preferred ways of using an existential quantifier. But it can’t hurt to
    see the alternative syntax, especially if there is a chance you will find yourself
    in the company of computer scientists.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将坚持使用 `rcases`、`rintro` 和 `obtain`，作为使用存在量词的首选方式。但看看替代语法也无妨，尤其是如果你有可能发现自己与计算机科学家在一起。
- en: 'To illustrate one way that `rcases` can be used, we prove an old mathematical
    chestnut: if two integers `x` and `y` can each be written as a sum of two squares,
    then so can their product, `x * y`. In fact, the statement is true for any commutative
    ring, not just the integers. In the next example, `rcases` unpacks two existential
    quantifiers at once. We then provide the magic values needed to express `x * y`
    as a sum of squares as a list to the `use` statement, and we use `ring` to verify
    that they work.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 `rcases` 可以用的一种方式，我们证明了一个古老的数学难题：如果两个整数 `x` 和 `y` 都可以写成两个平方数的和，那么它们的乘积
    `x * y` 也可以。实际上，这个陈述对于任何交换环都成立，而不仅仅是整数。在下一个例子中，`rcases` 一次解包了两个存在量词。然后我们提供一个列表，其中包含将
    `x * y` 表示为平方数和所需的魔法值，并将其作为参数传递给 `use` 语句，并使用 `ring` 来验证它们是否有效。
- en: '[PRE227]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'This proof doesn’t provide much insight, but here is one way to motivate it.
    A *Gaussian integer* is a number of the form \(a + bi\) where \(a\) and \(b\)
    are integers and \(i = \sqrt{-1}\). The *norm* of the Gaussian integer \(a + bi\)
    is, by definition, \(a^2 + b^2\). So the norm of a Gaussian integer is a sum of
    squares, and any sum of squares can be expressed in this way. The theorem above
    reflects the fact that norm of a product of Gaussian integers is the product of
    their norms: if \(x\) is the norm of \(a + bi\) and \(y\) in the norm of \(c +
    di\), then \(xy\) is the norm of \((a + bi) (c + di)\). Our cryptic proof illustrates
    the fact that the proof that is easiest to formalize isn’t always the most perspicuous
    one. In [Section 7.3](C07_Structures.html#section-building-the-gaussian-integers),
    we will provide you with the means to define the Gaussian integers and use them
    to provide an alternative proof.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 这个证明并没有提供很多见解，但这里有一种激发它的方法。高斯整数是一种形式为 \(a + bi\) 的数，其中 \(a\) 和 \(b\) 是整数，\(i
    = \sqrt{-1}\)。高斯整数 \(a + bi\) 的**范数**，根据定义，是 \(a^2 + b^2\)。因此，高斯整数的范数是平方和，任何平方和都可以用这种方式表示。上述定理反映了高斯整数乘积的范数是它们范数的乘积这一事实：如果
    \(x\) 是 \(a + bi\) 的范数，\(y\) 是 \(c + di\) 的范数，那么 \(xy\) 是 \((a + bi) (c + di)\)
    的范数。我们晦涩的证明说明了这样一个事实：最容易形式化的证明并不总是最清晰的。在[第7.3节](C07_Structures.html#section-building-the-gaussian-integers)中，我们将提供定义高斯整数并使用它们提供另一种证明的方法。
- en: 'The pattern of unpacking an equation inside an existential quantifier and then
    using it to rewrite an expression in the goal comes up often, so much so that
    the `rcases` tactic provides an abbreviation: if you use the keyword `rfl` in
    place of a new identifier, `rcases` does the rewriting automatically (this trick
    doesn’t work with pattern-matching lambdas).'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在存在量词内部展开方程的模式，然后使用它来重写目标表达式，这种模式经常出现，以至于 `rcases` 策略提供了一个缩写：如果你用关键字 `rfl` 代替一个新标识符，`rcases`
    会自动进行重写（这个技巧与模式匹配的lambda不兼容）。
- en: '[PRE228]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: As with the universal quantifier, you can find existential quantifiers hidden
    all over if you know how to spot them. For example, divisibility is implicitly
    an “exists” statement.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 正如全称量词一样，如果你知道如何识别它们，你可以在任何地方找到隐藏的存在量词。例如，可除性隐含地是一个“存在”陈述。
- en: '[PRE229]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: And once again, this provides a nice setting for using `rcases` with `rfl`.
    Try it out in the proof above. It feels pretty good!
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这为使用 `rcases` 和 `rfl` 提供了一个很好的环境。在上面的证明中试一试。感觉相当不错！
- en: 'Then try proving the following:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 然后尝试证明以下内容：
- en: '[PRE230]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'For another important example, a function \(f : \alpha \to \beta\) is said
    to be *surjective* if for every \(y\) in the codomain, \(\beta\), there is an
    \(x\) in the domain, \(\alpha\), such that \(f(x) = y\). Notice that this statement
    includes both a universal and an existential quantifier, which explains why the
    next example makes use of both `intro` and `use`.'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '对于另一个重要的例子，一个函数 \(f : \alpha \to \beta\) 被称为**满射**，如果对于域 \(\alpha\) 中的每一个 \(x\)，在值域
    \(\beta\) 中都存在一个 \(y\)，使得 \(f(x) = y\)。注意，这个陈述包含了全称量词和存在量词，这也解释了为什么下一个例子会同时使用
    `intro` 和 `use`。'
- en: '[PRE231]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'Try this example yourself using the theorem `mul_div_cancel₀`.:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用定理 `mul_div_cancel₀` 自己做这个例子。
- en: '[PRE232]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: At this point, it is worth mentioning that there is a tactic, `field_simp`,
    that will often clear denominators in a useful way. It can be used in conjunction
    with the `ring` tactic.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，值得提到的是，有一个策略 `field_simp`，它通常会以有用的方式消除分母。它可以与 `ring` 策略一起使用。
- en: '[PRE233]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: The next example uses a surjectivity hypothesis by applying it to a suitable
    value. Note that you can use `rcases` with any expression, not just a hypothesis.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子通过应用适当的值来使用满射假设。请注意，你可以用 `rcases` 与任何表达式一起使用，而不仅仅是假设。
- en: '[PRE234]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: See if you can use these methods to show that the composition of surjective
    functions is surjective.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否可以使用这些方法来证明满射函数的复合是满射的。
- en: '[PRE235]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '## 3.3\. Negation[](#negation "Link to this heading")'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '## 3.3. 否定[](#negation "链接到这个标题")'
- en: 'The symbol `¬` is meant to express negation, so `¬ x < y` says that `x` is
    not less than `y`, `¬ x = y` (or, equivalently, `x ≠ y`) says that `x` is not
    equal to `y`, and `¬ ∃ z, x < z ∧ z < y` says that there does not exist a `z`
    strictly between `x` and `y`. In Lean, the notation `¬ A` abbreviates `A → False`,
    which you can think of as saying that `A` implies a contradiction. Practically
    speaking, this means that you already know something about how to work with negations:
    you can prove `¬ A` by introducing a hypothesis `h : A` and proving `False`, and
    if you have `h : ¬ A` and `h'' : A`, then applying `h` to `h''` yields `False`.'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '符号 `¬` 用于表示否定，因此 `¬ x < y` 表示 `x` 不小于 `y`，`¬ x = y`（或等价地，`x ≠ y`）表示 `x` 不等于
    `y`，而 `¬ ∃ z, x < z ∧ z < y` 表示不存在一个 `z` 在 `x` 和 `y` 之间。在 Lean 中，符号 `¬ A` 简写为
    `A → False`，你可以将其理解为 `A` 导致矛盾。实际上，这意味着你已经了解了一些关于如何处理否定的方法：你可以通过引入假设 `h : A` 并证明
    `False` 来证明 `¬ A`，如果你有 `h : ¬ A` 和 `h'' : A`，那么将 `h` 应用到 `h''` 上会得到 `False`。'
- en: To illustrate, consider the irreflexivity principle `lt_irrefl` for a strict
    order, which says that we have `¬ a < a` for every `a`. The asymmetry principle
    `lt_asymm` says that we have `a < b → ¬ b < a`. Let’s show that `lt_asymm` follows
    from `lt_irrefl`.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，考虑严格顺序的不自反性原理 `lt_irrefl`，它表示对于每个 `a`，我们有 `¬ a < a`。不对称性原理 `lt_asymm` 表示
    `a < b → ¬ b < a`。让我们证明 `lt_asymm` 可以从 `lt_irrefl` 推导出来。
- en: '[PRE236]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: This example introduces a couple of new tricks. First, when you use `have` without
    providing a label, Lean uses the name `this`, providing a convenient way to refer
    back to it. Because the proof is so short, we provide an explicit proof term.
    But what you should really be paying attention to in this proof is the result
    of the `intro` tactic, which leaves a goal of `False`, and the fact that we eventually
    prove `False` by applying `lt_irrefl` to a proof of `a < a`.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子介绍了一些新的技巧。首先，当你使用 `have` 而不提供标签时，Lean 使用名称 `this`，提供了一种方便的回指方式。因为证明非常简短，所以我们提供了一个显式的证明项。但你应该真正关注这个证明的是
    `intro` 策略的结果，它留下一个 `False` 的目标，以及我们最终通过将 `lt_irrefl` 应用到一个 `a < a` 的证明上证明 `False`
    的事实。
- en: Here is another example, which uses the predicate `FnHasUb` defined in the last
    section, which says that a function has an upper bound.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子，它使用了上一节中定义的谓词 `FnHasUb`，它表示一个函数有一个上界。
- en: '[PRE237]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: Remember that it is often convenient to use `linarith` when a goal follows from
    linear equations and inequalities that are in the context.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当目标由上下文中的线性方程和不等式推导出来时，使用 `linarith` 通常很方便。
- en: 'See if you can prove these in a similar way:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否可以用类似的方式证明这些定理：
- en: '[PRE238]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'Mathlib offers a number of useful theorems for relating orders and negations:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib 提供了多个有用的定理，用于关联顺序和否定：
- en: '[PRE239]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'Recall the predicate `Monotone f`, which says that `f` is nondecreasing. Use
    some of the theorems just enumerated to prove the following:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 回忆一下谓词 `Monotone f`，它表示 `f` 是非递减的。使用刚刚列举的一些定理来证明以下内容：
- en: '[PRE240]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: We can show that the first example in the last snippet cannot be proved if we
    replace `<` by `≤`. Notice that we can prove the negation of a universally quantified
    statement by giving a counterexample. Complete the proof.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以证明，如果我们将 `<` 替换为 `≤`，则上一段代码中的第一个例子无法被证明。注意，我们可以通过给出反例来证明全称量化语句的否定。完成证明。
- en: '[PRE241]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'This example introduces the `let` tactic, which adds a *local definition* to
    the context. If you put the cursor after the `let` command, in the goal window
    you will see that the definition `f : ℝ → ℝ := fun x ↦ 0` has been added to the
    context. Lean will unfold the definition of `f` when it has to. In particular,
    when we prove `f 1 ≤ f 0` with `le_refl`, Lean reduces `f 1` and `f 0` to `0`.'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '这个例子引入了 `let` 策略，它向上下文中添加一个 *局部定义*。如果你将光标放在 `let` 命令之后，在目标窗口中你会看到已经添加到上下文中的定义
    `f : ℝ → ℝ := fun x ↦ 0`。当 Lean 需要时，它会展开 `f` 的定义。特别是，当我们使用 `le_refl` 证明 `f 1 ≤
    f 0` 时，Lean 会将 `f 1` 和 `f 0` 简化为 `0`。'
- en: 'Use `le_of_not_gt` to prove the following:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `le_of_not_gt` 来证明以下内容：
- en: '[PRE242]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'Implicit in many of the proofs we have just done is the fact that if `P` is
    any property, saying that there is nothing with property `P` is the same as saying
    that everything fails to have property `P`, and saying that not everything has
    property `P` is equivalent to saying that something fails to have property `P`.
    In other words, all four of the following implications are valid (but one of them
    cannot be proved with what we explained so far):'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚做的许多证明中隐含的事实是，如果 `P` 是任何属性，说没有任何具有属性 `P` 的东西等同于说所有东西都未能具有属性 `P`，而说并非所有东西都具有属性
    `P` 等价于说有些东西未能具有属性 `P`。换句话说，以下四个蕴涵都是有效的（但其中之一不能使用我们之前解释的方法来证明）：
- en: '[PRE243]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: The first, second, and fourth are straightforward to prove using the methods
    you have already seen. We encourage you to try it. The third is more difficult,
    however, because it concludes that an object exists from the fact that its nonexistence
    is contradictory. This is an instance of *classical* mathematical reasoning. We
    can use proof by contradiction to prove the third implication as follows.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 第一、第二和第四个可以通过你已经看到的方法直接证明。我们鼓励你尝试一下。然而，第三个比较困难，因为它从其不存在是矛盾的这一事实中得出一个对象存在的结论。这是一个
    *经典* 数学推理的例子。我们可以通过以下方式使用反证法来证明第三个蕴涵：
- en: '[PRE244]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'Make sure you understand how this works. The `by_contra` tactic allows us to
    prove a goal `Q` by assuming `¬ Q` and deriving a contradiction. In fact, it is
    equivalent to using the equivalence `not_not : ¬ ¬ Q ↔ Q`. Confirm that you can
    prove the forward direction of this equivalence using `by_contra`, while the reverse
    direction follows from the ordinary rules for negation.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '确保你理解这是如何工作的。`by_contra` 策略允许我们通过假设 `¬ Q` 并推导出矛盾来证明目标 `Q`。实际上，这等价于使用等价性 `not_not
    : ¬ ¬ Q ↔ Q`。确认你可以使用 `by_contra` 证明这个等价的正向方向，而反向方向则遵循否定规则的普通规则。'
- en: '[PRE245]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'Use proof by contradiction to establish the following, which is the converse
    of one of the implications we proved above. (Hint: use `intro` first.)'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反证法来建立以下内容，这是我们之前证明的一个蕴涵的逆命题。（提示：首先使用 `intro`。）
- en: '[PRE246]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: It is often tedious to work with compound statements with a negation in front,
    and it is a common mathematical pattern to replace such statements with equivalent
    forms in which the negation has been pushed inward. To facilitate this, Mathlib
    offers a `push_neg` tactic, which restates the goal in this way. The command `push_neg
    at h` restates the hypothesis `h`.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 处理带有否定前缀的复合语句通常很繁琐，将否定推入等价形式是常见的数学模式。为了方便这一点，Mathlib 提供了一个 `push_neg` 策略，它以这种方式重新表述目标。命令
    `push_neg at h` 重新表述假设 `h`。
- en: '[PRE247]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: 'In the second example, we use dsimp to expand the definitions of `FnHasUb`
    and `FnUb`. (We need to use `dsimp` rather than `rw` to expand `FnUb`, because
    it appears in the scope of a quantifier.) You can verify that in the examples
    above with `¬∃ x, P x` and `¬∀ x, P x`, the `push_neg` tactic does the expected
    thing. Without even knowing how to use the conjunction symbol, you should be able
    to use `push_neg` to prove the following:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，我们使用 `dsimp` 来展开 `FnHasUb` 和 `FnUb` 的定义。（我们需要使用 `dsimp` 而不是 `rw` 来展开
    `FnUb`，因为它出现在量词的作用域内。）你可以验证在上面的例子中，使用 `¬∃ x, P x` 和 `¬∀ x, P x` 时，`push_neg` 策略做了预期的事情。即使不知道如何使用合取符号，你也应该能够使用
    `push_neg` 来证明以下内容：
- en: '[PRE248]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: 'Mathlib also has a tactic, `contrapose`, which transforms a goal `A → B` to
    `¬B → ¬A`. Similarly, given a goal of proving `B` from hypothesis `h : A`, `contrapose
    h` leaves you with a goal of proving `¬A` from hypothesis `¬B`. Using `contrapose!`
    instead of `contrapose` applies `push_neg` to the goal and the relevant hypothesis
    as well.'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 'Mathlib 还有一个策略，`contrapose`，它将目标 `A → B` 转换为 `¬B → ¬A`。同样，给定一个从假设 `h : A` 证明
    `B` 的目标，`contrapose h` 会让你留下一个从假设 `¬B` 证明 `¬A` 的目标。使用 `contrapose!` 而不是 `contrapose`
    将 `push_neg` 应用到目标和相关假设上。'
- en: '[PRE249]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: We have not yet explained the `constructor` command or the use of the semicolon
    after it, but we will do that in the next section.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有解释 `constructor` 命令及其后的分号的使用，但将在下一节中解释。
- en: We close this section with the principle of *ex falso*, which says that anything
    follows from a contradiction. In Lean, this is represented by `False.elim`, which
    establishes `False → P` for any proposition `P`. This may seem like a strange
    principle, but it comes up fairly often. We often prove a theorem by splitting
    on cases, and sometimes we can show that one of the cases is contradictory. In
    that case, we need to assert that the contradiction establishes the goal so we
    can move on to the next one. (We will see instances of reasoning by cases in [Section
    3.5](#disjunction).)
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以 *ex falso* 原则结束本节，该原则表明任何东西都从矛盾中得出。在 Lean 中，这表示为 `False.elim`，它为任何命题 `P`
    建立 `False → P`。这看起来可能像是一个奇怪的原则，但它相当常见。我们经常通过分情况证明定理，有时我们可以表明其中一种情况是矛盾的。在这种情况下，我们需要断言矛盾建立了目标，这样我们就可以继续进行下一个。（我们将在
    [第 3.5 节](#disjunction) 中看到推理的例子。）
- en: Lean provides a number of ways of closing a goal once a contradiction has been
    reached.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 提供了多种在达到矛盾后关闭目标的方法。
- en: '[PRE250]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'The `exfalso` tactic replaces the current goal with the goal of proving `False`.
    Given `h : P` and `h'' : ¬ P`, the term `absurd h h''` establishes any proposition.
    Finally, the `contradiction` tactic tries to close a goal by finding a contradiction
    in the hypotheses, such as a pair of the form `h : P` and `h'' : ¬ P`. Of course,
    in this example, `linarith` also works.'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '`exfalso` 策略将当前目标替换为证明 `False` 的目标。给定 `h : P` 和 `h'' : ¬ P`，术语 `absurd h h''`
    建立任何命题。最后，`contradiction` 策略试图通过在假设中找到矛盾来关闭目标，例如形式为 `h : P` 和 `h'' : ¬ P` 的成对。当然，在这个例子中，`linarith`
    也有效。'
- en: '## 3.4\. Conjunction and Iff[](#conjunction-and-iff "Link to this heading")'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '## 3.4. 联合与Iff[](#conjunction-and-iff "链接到本标题")'
- en: You have already seen that the conjunction symbol, `∧`, is used to express “and.”
    The `constructor` tactic allows you to prove a statement of the form `A ∧ B` by
    proving `A` and then proving `B`.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到，合取符号 `∧` 用于表示“和”。`constructor` 策略允许您通过先证明 `A` 然后证明 `B` 来证明形式为 `A ∧ B`
    的陈述。
- en: '[PRE251]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: In this example, the `assumption` tactic tells Lean to find an assumption that
    will solve the goal. Notice that the final `rw` finishes the goal by applying
    the reflexivity of `≤`. The following are alternative ways of carrying out the
    previous examples using the anonymous constructor angle brackets. The first is
    a slick proof-term version of the previous proof, which drops into tactic mode
    at the keyword `by`.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，`assumption` 策略告诉 Lean 寻找一个假设来解决问题。注意，最后的 `rw` 通过应用 `≤` 的自反性来完成目标。以下是通过匿名构造器尖括号执行先前示例的替代方法。第一种是先前证明的简洁证明术语版本，它在
    `by` 关键字处进入策略模式。
- en: '[PRE252]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '*Using* a conjunction instead of proving one involves unpacking the proofs
    of the two parts. You can use the `rcases` tactic for that, as well as `rintro`
    or a pattern-matching `fun`, all in a manner similar to the way they are used
    with the existential quantifier.'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用* 联合而不是证明一个部分涉及展开两个部分的证明。您可以使用 `rcases` 策略来完成此操作，以及 `rintro` 或模式匹配 `fun`，所有这些都与存在量词的使用方式相似。'
- en: '[PRE253]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'In analogy to the `obtain` tactic, there is also a pattern-matching `have`:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `obtain` 策略，还有一个模式匹配的 `have`：
- en: '[PRE254]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'In contrast to `rcases`, here the `have` tactic leaves `h` in the context.
    And even though we won’t use them, once again we have the computer scientists’
    pattern-matching syntax:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `rcases` 相比，这里的 `have` 策略将 `h` 留在上下文中。即使我们不会使用它们，我们再次有了计算机科学家的模式匹配语法：
- en: '[PRE255]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: 'In contrast to using an existential quantifier, you can also extract proofs
    of the two components of a hypothesis `h : A ∧ B` by writing `h.left` and `h.right`,
    or, equivalently, `h.1` and `h.2`.'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '与使用存在量词相比，您还可以通过编写 `h.left` 和 `h.right`，或等价地，`h.1` 和 `h.2`，来提取假设 `h : A ∧ B`
    的两个组成部分的证明。'
- en: '[PRE256]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'Try using these techniques to come up with various ways of proving of the following:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用这些技术来想出证明以下内容的各种方法：
- en: '[PRE257]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: You can nest uses of `∃` and `∧` with anonymous constructors, `rintro`, and
    `rcases`.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用匿名构造器、`rintro` 和 `rcases` 来嵌套使用 `∃` 和 `∧`。
- en: '[PRE258]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'You can also use the `use` tactic:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `use` 策略：
- en: '[PRE259]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: In the first example, the semicolon after the `constructor` command tells Lean
    to use the `norm_num` tactic on both of the goals that result.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，`constructor` 命令后面的分号告诉 Lean 对产生的两个目标都使用 `norm_num` 策略。
- en: 'In Lean, `A ↔ B` is *not* defined to be `(A → B) ∧ (B → A)`, but it could have
    been, and it behaves roughly the same way. You have already seen that you can
    write `h.mp` and `h.mpr` or `h.1` and `h.2` for the two directions of `h : A ↔
    B`. You can also use `cases` and friends. To prove an if-and-only-if statement,
    you can use `constructor` or angle brackets, just as you would if you were proving
    a conjunction.'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '在 Lean 中，`A ↔ B` 并不是定义为 `(A → B) ∧ (B → A)`，但它本来可以是这样的，并且它的行为大致相同。你已经看到你可以为
    `h : A ↔ B` 的两个方向写 `h.mp` 和 `h.mpr` 或 `h.1` 和 `h.2`。你也可以使用 `cases` 和相关工具。为了证明一个“如果且仅如果”的命题，你可以使用
    `constructor` 或尖括号，就像你证明合取命题一样。'
- en: '[PRE260]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: The last proof term is inscrutable. Remember that you can use underscores while
    writing an expression like that to see what Lean expects.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的证明项难以理解。记住，在编写这样的表达式时，你可以使用下划线来查看 Lean 期望的内容。
- en: 'Try out the various techniques and gadgets you have just seen in order to prove
    the following:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用你刚刚看到的各种技术和工具来证明以下内容：
- en: '[PRE261]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: For a more interesting exercise, show that for any two real numbers `x` and
    `y`, `x^2 + y^2 = 0` if and only if `x = 0` and `y = 0`. We suggest proving an
    auxiliary lemma using `linarith`, `pow_two_nonneg`, and `pow_eq_zero`.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行更有趣的练习，证明对于任何两个实数 `x` 和 `y`，如果 `x^2 + y^2 = 0`，则 `x = 0` 且 `y = 0`。我们建议使用
    `linarith`、`pow_two_nonneg` 和 `pow_eq_zero` 来证明一个辅助引理。
- en: '[PRE262]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: In Lean, bi-implication leads a double-life. You can treat it like a conjunction
    and use its two parts separately. But Lean also knows that it is a reflexive,
    symmetric, and transitive relation between propositions, and you can also use
    it with `calc` and `rw`. It is often convenient to rewrite a statement to an equivalent
    one. In the next example, we use `abs_lt` to replace an expression of the form
    `|x| < y` by the equivalent expression `- y < x ∧ x < y`, and in the one after
    that we use `Nat.dvd_gcd_iff` to replace an expression of the form `m ∣ Nat.gcd
    n k` by the equivalent expression `m ∣ n ∧ m ∣ k`.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lean 中，双条件命题过着双重生活。你可以将其视为合取并分别使用其两部分。但 Lean 也知道它是一个命题之间的自反、对称和传递关系，你也可以使用
    `calc` 和 `rw`。将一个命题重写为等价命题通常很方便。在下一个例子中，我们使用 `abs_lt` 将形式为 `|x| < y` 的表达式替换为等价表达式
    `- y < x ∧ x < y`，在之后的例子中，我们使用 `Nat.dvd_gcd_iff` 将形式为 `m ∣ Nat.gcd n k` 的表达式替换为等价表达式
    `m ∣ n ∧ m ∣ k`。
- en: '[PRE263]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: See if you can use `rw` with the theorem below to provide a short proof that
    negation is not a nondecreasing function. (Note that `push_neg` won’t unfold definitions
    for you, so the `rw [Monotone]` in the proof of the theorem is needed.)
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否可以使用下面的定理与 `rw` 结合来提供一个简短的证明，证明否定不是一个不减函数。（注意，`push_neg` 不会为你展开定义，因此定理证明中的
    `rw [Monotone]` 是必需的。）
- en: '[PRE264]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: 'The remaining exercises in this section are designed to give you some more
    practice with conjunction and bi-implication. Remember that a *partial order*
    is a binary relation that is transitive, reflexive, and antisymmetric. An even
    weaker notion sometimes arises: a *preorder* is just a reflexive, transitive relation.
    For any pre-order `≤`, Lean axiomatizes the associated strict pre-order by `a
    < b ↔ a ≤ b ∧ ¬ b ≤ a`. Show that if `≤` is a partial order, then `a < b` is equivalent
    to `a ≤ b ∧ a ≠ b`:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 本节剩余的练习旨在让你在合取和双条件命题方面获得更多实践。记住，*偏序* 是一个传递、自反且反对称的二进制关系。有时会出现一个更弱的概念：*偏序* 只是一个自反且传递的关系。对于任何偏序
    `≤`，Lean 通过 `a < b ↔ a ≤ b ∧ ¬ b ≤ a` 公理化相关的严格偏序。证明如果 `≤` 是一个偏序，那么 `a < b` 等价于
    `a ≤ b ∧ a ≠ b`：
- en: '[PRE265]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: Beyond logical operations, you do not need anything more than `le_refl` and
    `le_trans`. Show that even in the case where `≤` is only assumed to be a preorder,
    we can prove that the strict order is irreflexive and transitive. In the second
    example, for convenience, we use the simplifier rather than `rw` to express `<`
    in terms of `≤` and `¬`. We will come back to the simplifier later, but here we
    are only relying on the fact that it will use the indicated lemma repeatedly,
    even if it needs to be instantiated to different values.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算之外，你不需要比 `le_refl` 和 `le_trans` 更多的东西。证明即使在 `≤` 只被假设为偏序的情况下，我们也可以证明严格序是不可自反的且传递的。在第二个例子中，为了方便起见，我们使用简化器而不是
    `rw` 来用 `≤` 和 `¬` 表达 `<`。我们稍后会回到简化器，但在这里我们只依赖于这样一个事实，即它将反复使用所指示的引理，即使它需要实例化为不同的值。
- en: '[PRE266]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '## 3.5\. Disjunction[](#disjunction "Link to this heading")'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '## 3.5. 析取[](#disjunction "链接到这个标题")'
- en: The canonical way to prove a disjunction `A ∨ B` is to prove `A` or to prove
    `B`. The `left` tactic chooses `A`, and the `right` tactic chooses `B`.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 证明析取 `A ∨ B` 的规范方法是证明 `A` 或证明 `B`。`left` 策略选择 `A`，而 `right` 策略选择 `B`。
- en: '[PRE267]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: We cannot use an anonymous constructor to construct a proof of an “or” because
    Lean would have to guess which disjunct we are trying to prove. When we write
    proof terms we can use `Or.inl` and `Or.inr` instead to make the choice explicitly.
    Here, `inl` is short for “introduction left” and `inr` is short for “introduction
    right.”
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用匿名构造函数来构造“或”的证明，因为Lean必须猜测我们正在尝试证明哪个析取项。当我们编写证明项时，我们可以使用`Or.inl`和`Or.inr`来明确选择。在这里，`inl`代表“引入左”，`inr`代表“引入右”。
- en: '[PRE268]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: It may seem strange to prove a disjunction by proving one side or the other.
    In practice, which case holds usually depends on a case distinction that is implicit
    or explicit in the assumptions and the data. The `rcases` tactic allows us to
    make use of a hypothesis of the form `A ∨ B`. In contrast to the use of `rcases`
    with conjunction or an existential quantifier, here the `rcases` tactic produces
    *two* goals. Both have the same conclusion, but in the first case, `A` is assumed
    to be true, and in the second case, `B` is assumed to be true. In other words,
    as the name suggests, the `rcases` tactic carries out a proof by cases. As usual,
    we can tell Lean what names to use for the hypotheses. In the next example, we
    tell Lean to use the name `h` on each branch.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 通过证明一个析取项的任一边来证明析取似乎很奇怪。在实践中，哪个情况成立通常取决于假设和数据中的隐式或显式的情况区分。`rcases`策略允许我们利用形式为`A
    ∨ B`的假设。与使用`rcases`与合取或存在量词相比，这里的`rcases`策略产生*两个*目标。这两个目标有相同的结论，但在第一种情况下，假设`A`为真，在第二种情况下，假设`B`为真。换句话说，正如其名称所暗示的，`rcases`策略通过分情况进行证明。像往常一样，我们可以告诉Lean使用哪些名称作为假设。在下一个例子中，我们告诉Lean在每个分支上使用名称`h`。
- en: '[PRE269]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: Notice that the pattern changes from `⟨h₀, h₁⟩` in the case of a conjunction
    to `h₀ | h₁` in the case of a disjunction. Think of the first pattern as matching
    against data the contains *both* an `h₀` and a `h₁`, whereas second pattern, with
    the bar, matches against data that contains *either* an `h₀` or `h₁`. In this
    case, because the two goals are separate, we have chosen to use the same name,
    `h`, in each case.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，模式从合取的情况中的`⟨h₀, h₁⟩`变为析取的情况中的`h₀ | h₁`。将第一个模式视为与包含`h₀`和`h₁`的*两者*的数据匹配，而第二个模式，带有竖线，与包含*任一*`h₀`或`h₁`的数据匹配。在这种情况下，因为两个目标是独立的，所以我们选择在每个情况下使用相同的名称，即`h`。
- en: The absolute value function is defined in such a way that we can immediately
    prove that `x ≥ 0` implies `|x| = x` (this is the theorem `abs_of_nonneg`) and
    `x < 0` implies `|x| = -x` (this is `abs_of_neg`). The expression `le_or_gt 0
    x` establishes `0 ≤ x ∨ x < 0`, allowing us to split on those two cases.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对值函数被定义为一种方式，我们可以立即证明`x ≥ 0`意味着`|x| = x`（这是定理`abs_of_nonneg`），以及`x < 0`意味着`|x|
    = -x`（这是`abs_of_neg`）。表达式`le_or_gt 0 x`建立了`0 ≤ x ∨ x < 0`，允许我们在这两种情况下进行拆分。
- en: Lean also supports the computer scientists’ pattern-matching syntax for disjunction.
    Now the `cases` tactic is more attractive, because it allows us to name each `case`,
    and name the hypothesis that is introduced closer to where it is used.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: Lean还支持计算机科学家的析取模式匹配语法。现在`cases`策略更有吸引力，因为它允许我们为每个`case`命名，并为引入的假设命名，使其更接近使用位置。
- en: '[PRE270]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: The names `inl` and `inr` are short for “intro left” and “intro right,” respectively.
    Using `case` has the advantage that you can prove the cases in either order; Lean
    uses the tag to find the relevant goal. If you don’t care about that, you can
    use `next`, or `match`, or even a pattern-matching `have`.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '`inl`和`inr`的名称分别代表“intro left”和“intro right”。使用`case`的优点是你可以按任意顺序证明情况；Lean使用标签来找到相关的目标。如果你不关心这一点，你可以使用`next`，或者`match`，甚至是一个模式匹配的`have`。'
- en: '[PRE271]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: In the case of `match`, we need to use the full names `Or.inl` and `Or.inr`
    of the canonical ways to prove a disjunction. In this textbook, we will generally
    use `rcases` to split on the cases of a disjunction.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 在`match`的情况下，我们需要使用规范方式证明析取的完整名称`Or.inl`和`Or.inr`。在这本教科书中，我们将通常使用`rcases`来根据析取的情况进行拆分。
- en: Try proving the triangle inequality using the first two theorems in the next
    snippet. They are given the same names they have in Mathlib.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用下一片段中的前两个定理来证明三角不等式。它们在Mathlib中的名称与它们相同。
- en: '[PRE272]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: In case you enjoyed these (pun intended) and you want more practice with disjunction,
    try these.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢这些（有意为之）并且想要更多关于析取的练习，请尝试这些。
- en: '[PRE273]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: You can also use `rcases` and `rintro` with nested disjunctions. When these
    result in a genuine case split with multiple goals, the patterns for each new
    goal are separated by a vertical bar.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `rcases` 和 `rintro` 与嵌套析取一起使用。当这些导致具有多个目标的真正情况分割时，每个新目标的模式由一个垂直线分隔。
- en: '[PRE274]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'You can still nest patterns and use the `rfl` keyword to substitute equations:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以嵌套模式并使用 `rfl` 关键字来替换等式：
- en: '[PRE275]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: See if you can prove the following with a single (long) line. Use `rcases` to
    unpack the hypotheses and split on cases, and use a semicolon and `linarith` to
    solve each branch.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否可以用一行（长）来证明以下内容。使用 `rcases` 来展开假设并分情况讨论，并使用分号和 `linarith` 来解决每个分支。
- en: '[PRE276]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: 'On the real numbers, an equation `x * y = 0` tells us that `x = 0` or `y =
    0`. In Mathlib, this fact is known as `eq_zero_or_eq_zero_of_mul_eq_zero`, and
    it is another nice example of how a disjunction can arise. See if you can use
    it to prove the following:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 在实数上，等式 `x * y = 0` 告诉我们 `x = 0` 或 `y = 0`。在 Mathlib 中，这个事实被称为 `eq_zero_or_eq_zero_of_mul_eq_zero`，它是另一个很好的例子，说明了析取是如何产生的。看看你是否可以用它来证明以下内容：
- en: '[PRE277]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: Remember that you can use the `ring` tactic to help with calculations.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你可以使用 `ring` 策略来帮助计算。
- en: 'In an arbitrary ring \(R\), an element \(x\) such that \(x y = 0\) for some
    nonzero \(y\) is called a *left zero divisor*, an element \(x\) such that \(y
    x = 0\) for some nonzero \(y\) is called a *right zero divisor*, and an element
    that is either a left or right zero divisor is called simply a *zero divisor*.
    The theorem `eq_zero_or_eq_zero_of_mul_eq_zero` says that the real numbers have
    no nontrivial zero divisors. A commutative ring with this property is called an
    *integral domain*. Your proofs of the two theorems above should work equally well
    in any integral domain:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个任意的环 \(R\) 中，一个元素 \(x\)，使得对于某个非零的 \(y\) 有 \(x y = 0\)，被称为 *左零因子*，一个元素 \(x\)，使得对于某个非零的
    \(y\) 有 \(y x = 0\)，被称为 *右零因子*，而一个既是左零因子又是右零因子的元素被称为简单的 *零因子*。定理 `eq_zero_or_eq_zero_of_mul_eq_zero`
    表明实数没有非平凡的零因子。具有这种性质的交换环被称为 *整环*。你上面两个定理的证明在任意整环中同样有效：
- en: '[PRE278]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: In fact, if you are careful, you can prove the first theorem without using commutativity
    of multiplication. In that case, it suffices to assume that `R` is a `Ring` instead
    of an `CommRing`.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果你小心的话，你可以不用乘法的交换律就能证明第一个定理。在这种情况下，只需假设 `R` 是一个 `Ring` 而不是 `CommRing` 即可。
- en: 'Sometimes in a proof we want to split on cases depending on whether some statement
    is true or not. For any proposition `P`, we can use `em P : P ∨ ¬ P`. The name
    `em` is short for “excluded middle.”'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '有时在证明中，我们希望根据某个陈述是否为真来分情况讨论。对于任何命题 `P`，我们可以使用 `em P : P ∨ ¬ P`。名称 `em` 是“排中律”的缩写。'
- en: '[PRE279]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: Alternatively, you can use the `by_cases` tactic.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用 `by_cases` 策略。
- en: '[PRE280]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: 'Notice that the `by_cases` tactic lets you specify a label for the hypothesis
    that is introduced in each branch, in this case, `h'' : P` in one and `h'' : ¬
    P` in the other. If you leave out the label, Lean uses `h` by default. Try proving
    the following equivalence, using `by_cases` to establish one direction.'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，`by_cases` 策略允许你为每个分支中引入的假设指定一个标签，在这种情况下，`h'' : P` 在一个分支中，而在另一个分支中是 `h''
    : ¬ P`。如果你省略了标签，Lean 默认使用 `h`。尝试使用 `by_cases` 来证明以下等价性，以建立其中一个方向。'
- en: '[PRE281]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '## 3.6\. Sequences and Convergence[](#sequences-and-convergence "Link to this
    heading")'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '## 3.6\. 序列和收敛[](#sequences-and-convergence "链接到这个标题")'
- en: 'We now have enough skills at our disposal to do some real mathematics. In Lean,
    we can represent a sequence \(s_0, s_1, s_2, \ldots\) of real numbers as a function
    `s : ℕ → ℝ`. Such a sequence is said to *converge* to a number \(a\) if for every
    \(\varepsilon > 0\) there is a point beyond which the sequence remains within
    \(\varepsilon\) of \(a\), that is, there is a number \(N\) such that for every
    \(n \ge N\), \(| s_n - a | < \varepsilon\). In Lean, we can render this as follows:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们已经掌握了足够的技能来进行一些真正的数学。在 Lean 中，我们可以将实数序列 \(s_0, s_1, s_2, \ldots\) 表示为一个函数
    `s : ℕ → ℝ`。这样的序列被称为 *收敛到* 一个数 \(a\)，如果对于每一个 \(\varepsilon > 0\)，存在一个点，在此点之后序列始终保持在
    \(a\) 的 \(\varepsilon\) 范围内，也就是说，存在一个数 \(N\)，使得对于每一个 \(n \ge N\)，\(| s_n - a |
    < \varepsilon\)。在 Lean 中，我们可以这样表示：'
- en: '[PRE282]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: The notation `∀ ε > 0, ...` is a convenient abbreviation for `∀ ε, ε > 0 → ...`,
    and, similarly, `∀ n ≥ N, ...` abbreviates `∀ n, n ≥ N →  ...`. And remember that
    `ε > 0`, in turn, is defined as `0 < ε`, and `n ≥ N` is defined as `N ≤ n`.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 `∀ ε > 0, ...` 是 `∀ ε, ε > 0 → ...` 的方便缩写，同样地，`∀ n ≥ N, ...` 缩写为 `∀ n, n
    ≥ N → ...`。并且记住，`ε > 0`，反过来，定义为 `0 < ε`，而 `n ≥ N` 定义为 `N ≤ n`。
- en: In this section, we’ll establish some properties of convergence. But first,
    we will discuss three tactics for working with equality that will prove useful.
    The first, the `ext` tactic, gives us a way of proving that two functions are
    equal. Let \(f(x) = x + 1\) and \(g(x) = 1 + x\) be functions from reals to reals.
    Then, of course, \(f = g\), because they return the same value for every \(x\).
    The `ext` tactic enables us to prove an equation between functions by proving
    that their values are the same at all the values of their arguments.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将建立一些收敛性的性质。但首先，我们将讨论三种处理等式的方法，这些方法将非常有用。第一种，`ext` 方法，为我们提供了一种证明两个函数相等的方法。设
    \(f(x) = x + 1\) 和 \(g(x) = 1 + x\) 是从实数到实数的函数。那么，当然，\(f = g\)，因为它们对每个 \(x\) 都返回相同的值。`ext`
    方法使我们能够通过证明在所有参数值上它们的值都相同来证明函数之间的等式。
- en: '[PRE283]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: 'We’ll see later that `ext` is actually more general, and also one can specify
    the name of the variables that appear. For instance you can try to replace `ext`
    with `ext u v` in the above proof. The second tactic, the `congr` tactic, allows
    us to prove an equation between two expressions by reconciling the parts that
    are different:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面看到，`ext` 实际上更通用，并且还可以指定出现变量的名称。例如，你可以在上面的证明中尝试将 `ext` 替换为 `ext u v`。第二种方法，`congr`
    方法，允许我们通过协调不同的部分来证明两个表达式之间的等式：
- en: '[PRE284]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: Here the `congr` tactic peels off the `abs` on each side, leaving us to prove
    `a = a - b + b`.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`congr` 方法剥去了每边的 `abs`，留下我们证明 `a = a - b + b`。
- en: Finally, the `convert` tactic is used to apply a theorem to a goal when the
    conclusion of the theorem doesn’t quite match. For example, suppose we want to
    prove `a < a * a` from `1 < a`. A theorem in the library, `mul_lt_mul_right`,
    will let us prove `1 * a < a * a`. One possibility is to work backwards and rewrite
    the goal so that it has that form. Instead, the `convert` tactic lets us apply
    the theorem as it is, and leaves us with the task of proving the equations that
    are needed to make the goal match.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`convert` 方法用于在定理的结论与目标不完全匹配时将定理应用于目标。例如，假设我们想从 `1 < a` 证明 `a < a * a`。库中的一个定理
    `mul_lt_mul_right` 将使我们能够证明 `1 * a < a * a`。一种可能性是反向工作并重写目标，使其具有那种形式。相反，`convert`
    方法允许我们按原样应用定理，并留下证明所需方程的任务。
- en: '[PRE285]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: 'This example illustrates another useful trick: when we apply an expression
    with an underscore and Lean can’t fill it in for us automatically, it simply leaves
    it for us as another goal.'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了另一个有用的技巧：当我们应用一个带有下划线的表达式，而 Lean 不能自动为我们填充它时，它简单地将其留给我们作为另一个目标。
- en: The following shows that any constant sequence \(a, a, a, \ldots\) converges.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子表明，任何常数序列 \(a, a, a, \ldots\) 都会收敛。
- en: '[PRE286]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: Lean has a tactic, `simp`, which can often save you the trouble of carrying
    out steps like `rw [sub_self, abs_zero]` by hand. We will tell you more about
    it soon.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 有一个名为 `simp` 的方法，它经常可以节省你手动执行 `rw [sub_self, abs_zero]` 等步骤的麻烦。我们很快就会告诉你更多关于它的信息。
- en: For a more interesting theorem, let’s show that if `s` converges to `a` and
    `t` converges to `b`, then `fun n ↦ s n + t n` converges to `a + b`. It is helpful
    to have a clear pen-and-paper proof in mind before you start writing a formal
    one. Given `ε` greater than `0`, the idea is to use the hypotheses to obtain an
    `Ns` such that beyond that point, `s` is within `ε / 2` of `a`, and an `Nt` such
    that beyond that point, `t` is within `ε / 2` of `b`. Then, whenever `n` is greater
    than or equal to the maximum of `Ns` and `Nt`, the sequence `fun n ↦ s n + t n`
    should be within `ε` of `a + b`. The following example begins to implement this
    strategy. See if you can finish it off.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个更有趣的定理，让我们证明如果 `s` 收敛到 `a` 且 `t` 收敛到 `b`，那么 `fun n ↦ s n + t n` 收敛到 `a +
    b`。在开始编写正式证明之前，有一个清晰的笔和纸证明是有帮助的。给定大于 `0` 的 `ε`，想法是使用假设来获得一个 `Ns`，这样在这一点之后，`s`
    就在 `a` 的 `ε / 2` 范围内，以及一个 `Nt`，这样在这一点之后，`t` 就在 `b` 的 `ε / 2` 范围内。然后，每当 `n` 大于或等于
    `Ns` 和 `Nt` 的最大值时，序列 `fun n ↦ s n + t n` 应该在 `a + b` 的 `ε` 范围内。以下示例开始实施这种策略。看看你是否能完成它。
- en: '[PRE287]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: As hints, you can use `le_of_max_le_left` and `le_of_max_le_right`, and `norm_num`
    can prove `ε / 2 + ε / 2 = ε`. Also, it is helpful to use the `congr` tactic to
    show that `|s n + t n - (a + b)|` is equal to `|(s n - a) + (t n - b)|,` since
    then you can use the triangle inequality. Notice that we marked all the variables
    `s`, `t`, `a`, and `b` implicit because they can be inferred from the hypotheses.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提示，你可以使用 `le_of_max_le_left` 和 `le_of_max_le_right`，以及 `norm_num` 可以证明 `ε
    / 2 + ε / 2 = ε`。此外，使用 `congr` 方法来证明 `|s n + t n - (a + b)|` 等于 `|(s n - a) +
    (t n - b)|` 是有帮助的，因为这样你就可以使用三角不等式。注意，我们标记了所有变量 `s`、`t`、`a` 和 `b` 为隐式，因为它们可以从假设中推断出来。
- en: Proving the same theorem with multiplication in place of addition is tricky.
    We will get there by proving some auxiliary statements first. See if you can also
    finish off the next proof, which shows that if `s` converges to `a`, then `fun
    n ↦ c * s n` converges to `c * a`. It is helpful to split into cases depending
    on whether `c` is equal to zero or not. We have taken care of the zero case, and
    we have left you to prove the result with the extra assumption that `c` is nonzero.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 用乘法代替加法来证明相同的定理是棘手的。我们将通过首先证明一些辅助命题来达到这一点。看看你是否也能完成下一个证明，该证明表明如果`s`收敛到`a`，那么`fun
    n ↦ c * s n`收敛到`c * a`。根据`c`是否为零来分情况考虑是有帮助的。我们已经处理了零的情况，并留下了额外的假设`c`不为零来证明结果。
- en: '[PRE288]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: 'The next theorem is also independently interesting: it shows that a convergent
    sequence is eventually bounded in absolute value. We have started you off; see
    if you can finish it.'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个定理也是独立有趣的：它表明收敛序列最终在绝对值上是有限的。我们已经给你开了一个头；看看你是否能完成它。
- en: '[PRE289]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: In fact, the theorem could be strengthened to assert that there is a bound `b`
    that holds for all values of `n`. But this version is strong enough for our purposes,
    and we will see at the end of this section that it holds more generally.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这个定理可以被加强，以断言存在一个对所有`n`值都成立的界限`b`。但这个版本对我们来说已经足够强大，我们将在本节的末尾看到它具有更一般的适用性。
- en: 'The next lemma is auxiliary: we prove that if `s` converges to `a` and `t`
    converges to `0`, then `fun n ↦ s n * t n` converges to `0`. To do so, we use
    the previous theorem to find a `B` that bounds `s` beyond some point `N₀`. See
    if you can understand the strategy we have outlined and finish the proof.'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个引理是辅助性的：我们证明如果`s`收敛到`a`且`t`收敛到`0`，那么`fun n ↦ s n * t n`收敛到`0`。为此，我们使用前面的定理找到一个`B`，它从某个点`N₀`开始限制`s`。看看你是否能理解我们所概述的策略并完成证明。
- en: '[PRE290]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: If you have made it this far, congratulations! We are now within striking distance
    of our theorem. The following proof finishes it off.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经走到这一步，恭喜你！我们现在已经接近我们的定理了。下面的证明将把它完成。
- en: '[PRE291]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: For another challenging exercise, try filling out the following sketch of a
    proof that limits are unique. (If you are feeling bold, you can delete the proof
    sketch and try proving it from scratch.)
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 对于另一个挑战性的练习，尝试填写以下极限唯一的证明草稿。（如果你有勇气，你可以删除证明草稿，并尝试从头开始证明。）
- en: '[PRE292]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: 'We close the section with the observation that our proofs can be generalized.
    For example, the only properties that we have used of the natural numbers is that
    their structure carries a partial order with `min` and `max`. You can check that
    everything still works if you replace `ℕ` everywhere by any linear order `α`:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节结束时注意到，我们的证明可以推广。例如，我们使用的自然数的唯一属性是它们的结构携带一个具有`min`和`max`的偏序。你可以检查，如果你在所有地方用任何线性序`α`替换`ℕ`，一切仍然有效：
- en: '[PRE293]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: In [Section 11.1](C11_Topology.html#filters), we will see that Mathlib has mechanisms
    for dealing with convergence in vastly more general terms, not only abstracting
    away particular features of the domain and codomain, but also abstracting over
    different types of convergence.*
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11.1节](C11_Topology.html#filters)中，我们将看到Mathlib有处理收敛的机制，这些机制在极其一般化的术语下进行，不仅抽象掉了定义域和值域的特定特征，而且还抽象了不同类型的收敛。
