- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: STRUCTURED TYPES AND MUTABILITY
  prefs: []
  type: TYPE_NORMAL
- en: 'The programs we have looked at so far have dealt with three types of objects:
    `int`, `float`, and `str`. The numeric types `int` and `float` are scalar types.
    That is to say, objects of these types have no accessible internal structure.
    In contrast, `str` can be thought of as a structured, or non-scalar, type. We
    can use indexing to extract individual characters from a string and slicing to
    extract substrings.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we introduce four additional structured types. One, `tuple`,
    is a simple generalization of `str`. The other three—`list, range`, and `dict`—are
    more interesting. We also return to the topic of higher-order programming with
    some examples that illustrate the utility of being able to treat functions in
    the same way as other types of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like strings, **tuples** are immutable ordered sequences of elements. The difference
    is that the elements of a tuple need not be characters. The individual elements
    can be of any type, and need not be of the same type as each other.
  prefs: []
  type: TYPE_NORMAL
- en: Literals of type `tuple` are written by enclosing a comma-separated list of
    elements within parentheses. For example, we can write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Unsurprisingly, the `print` statements produce the output
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Looking at this example, you might think that the tuple containing the single
    value `1` would be written `(1)`. But, to quote H.R. Haldeman quoting Richard
    Nixon, “it would be wrong.” [^(33)](#c5-fn-0001) Since parentheses are used to
    group expressions, `(1)` is merely a verbose way to write the integer `1`. To
    denote the singleton tuple containing this value, we write `(1,)`. Almost everybody
    who uses Python has at one time or another accidentally omitted that annoying
    comma.
  prefs: []
  type: TYPE_NORMAL
- en: Repetition can be used on tuples. For example, the expression `3*('a', 2)` evaluates
    to `('a', 2, 'a', 2, 'a', 2)`.
  prefs: []
  type: TYPE_NORMAL
- en: Like strings, tuples can be concatenated, indexed, and sliced. Consider
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The second assignment statement binds the name `t2` to a tuple that contains
    the tuple to which `t1` is bound and the floating-point number `3.25`. This is
    possible because a tuple, like everything else in Python, is an object, so tuples
    can contain tuples. Therefore, the first `print` statement produces the output,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The second `print` statement prints the value generated by concatenating the
    values bound to `t1` and `t2`, which is a tuple with five elements. It produces
    the output
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The next statement selects and prints the fourth element of the concatenated
    tuple (as always in Python, indexing starts at `0`), and the statement after that
    creates and prints a slice of that tuple, producing the output
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A `for` statement can be used to iterate over the elements of a tuple. And the
    `in` operator can be used to test if a tuple contains a specific value. For example,
    the following code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: "prints `\uFEFF('a', 2)`."
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.1 Multiple Assignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you know the length of a sequence (e.g., a tuple or a string), it can be
    convenient to use Python's **multiple assignment** statement to extract the individual
    elements. For example, the statement `x, y = (3, 4)`, will bind `x` to `3` and
    `y` to `4`. Similarly, the statement `a, b, c = 'xyz'` will bind `a` to `'x'`,
    `b` to `'y'`, and `c` to `'z'`.
  prefs: []
  type: TYPE_NORMAL
- en: This mechanism is particularly convenient when used with functions that return
    multiple value. Consider the function definition
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The multiple assignment statement
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: will bind `min_divisor` to `2` and `max_divisor` to `200`.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 Ranges and Iterables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in Section 2.6, the function `range` produces an object of type
    `range`. Like strings and tuples, objects of type `range` are immutable. All of
    the operations on tuples are also available for ranges, except for concatenation
    and repetition. For example, `range(10)[2:6][2`] evaluates to `4`. When the `==`
    operator is used to compare objects of type `range`, it returns `True` if the
    two ranges represent the same sequence of integers. For example, `range(0, 7,
    2) == range(0, 8, 2)` evaluates to `True`. However, `range(0, 7, 2) == range(6,
    -1, -2)` evaluates to `False` because though the two ranges contain the same integers,
    they occur in a different order.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike objects of type `tuple`, the amount of space occupied by an object of
    type `range` is not proportional to its length. Because a range is fully defined
    by its start, stop, and step values, it can be stored in a small amount of space.
  prefs: []
  type: TYPE_NORMAL
- en: The most common use of `range` is in `for` loops, but objects of type `range`
    can be used anywhere a sequence of integers can be used.
  prefs: []
  type: TYPE_NORMAL
- en: In Python 3, `range` is a special case of an **iterable** **object**. All iterable
    types have a method,[^(34)](#c5-fn-0002) `__iter__` that returns an object of
    **type iterator**. The iterator can then be used in a `for` loop to return a sequence
    of objects, one at a time. For example, tuples are iterable, and the `for` statement
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: creates an iterator that will return the elements of the tuple one at a time.
    Python has many built-in iterable types, including strings, lists, and dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: Many useful built-in functions operate on iterables. Among the more useful are
    `sum`, `min`, and `max`. The function `sum` can be applied to iterables of numbers.
    It returns the sum of the elements. The functions `max` and `min` can be applied
    to iterables for which there is a well-defined ordering on the elements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise:** Write an expression that evaluates to the mean of a tuple
    of numbers. Use the function `sum`.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.3 Lists and Mutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like a tuple, a **list** is an ordered sequence of values, where each value
    is identified by an index. The syntax for expressing literals of type `list` is
    similar to that used for tuples; the difference is that we use square brackets
    rather than parentheses. The empty list is written as `[]`, and singleton lists
    are written without that (oh so easy to forget) comma before the closing bracket.
  prefs: []
  type: TYPE_NORMAL
- en: Since lists are iterables, we can use a `for` statement to iterate over the
    elements in list. So, for example, the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: produces the output,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can also index into lists and slice lists, just as we can for tuples. For
    example, the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using square brackets for three different purposes (literals of type `list`,
    indexing into iterables, and slicing iterables), can lead to visual confusion.
    For example, the expression `[1,2,3,4][1:3][1]`, which evaluates to `3`, uses
    square brackets in three ways. This is rarely a problem in practice, because most
    of the time lists are built incrementally rather than written as literals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lists differ from tuples in one hugely important way: lists are **mutable**.
    In contrast, tuples and strings are **immutable**. Many operators can be used
    to create objects of immutable types, and variables can be bound to objects of
    these types. But objects of immutable types cannot be modified after they are
    created. On the other hand, objects of mutable types can be modified after they
    are created.'
  prefs: []
  type: TYPE_NORMAL
- en: The distinction between mutating an object and assigning an object to a variable
    may, at first, appear subtle. However, if you keep repeating the mantra, “In Python
    a variable is merely a name, i.e., a label that can be attached to an object,”
    it will bring you clarity. And perhaps the following set of examples will also
    help.
  prefs: []
  type: TYPE_NORMAL
- en: When the statements
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: are executed, the interpreter creates two new lists and binds the appropriate
    variables to them, as pictured in [Figure 5-1](#c5-fig-0001).
  prefs: []
  type: TYPE_NORMAL
- en: '![c5-fig-0001.jpg](../images/c5-fig-0001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 5-1](#c5-fig-0001a) Two lists'
  prefs: []
  type: TYPE_NORMAL
- en: The assignment statements
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: also create new lists and bind variables to them. The elements of these lists
    are themselves lists. The three print statements
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: produce the output
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It appears as if `Univs` and `Univs1` are bound to the same value. But appearances
    can be deceiving. As [Figure 5-2](#c5-fig-0002) illustrates, `Univs` and `Univs1`
    are bound to quite different values.
  prefs: []
  type: TYPE_NORMAL
- en: '![c5-fig-0002.jpg](../images/c5-fig-0002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 5-2](#c5-fig-0002a) Two lists that appear to have the same value, but
    don''t'
  prefs: []
  type: TYPE_NORMAL
- en: That `Univs` and `Univs1` are bound to different objects can be verified using
    the built-in Python function `**id**`, which returns a unique integer identifier
    for an object. This function allows us to test for **object equality** by comparing
    their id. A simpler way to test for object equality is to use the `**is**` operator.
    When we run the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: it prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: (Don't expect to see the same unique identifiers if you run this code. The semantics
    of Python says nothing about what identifier is associated with each object; it
    merely requires that no two objects have the same identifier.)
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in [Figure 5-2](#c5-fig-0002) the elements of `Univs` are not copies
    of the lists to which `Techs` and `Ivys` are bound, but are rather the lists themselves.
    The elements of `Univs1` are lists that contain the same elements as the lists
    in `Univs`, but they are not the same lists. We can see this by running the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: which prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Why the big fuss about the difference between value and object equality? It
    matters because lists are mutable. Consider the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `append` method for lists has a **side effect**. Rather than create a new
    list, it mutates the existing list, `Techs`, by adding a new element, the string
    `'RPI'` in this example, to the end of it. [Figure 5-3](#c5-fig-0003) depicts
    the state of the computation after `append` is executed.
  prefs: []
  type: TYPE_NORMAL
- en: '![c5-fig-0003.jpg](../images/c5-fig-0003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 5-3](#c5-fig-0003a) Demonstration of mutability'
  prefs: []
  type: TYPE_NORMAL
- en: The object to which `Univs` is bound still contains the same two lists, but
    the contents of one of those lists has been changed. Consequently, the `print`
    statements
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: now produce the output
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: What we have here is called **aliasing**. There are two distinct paths to the
    same list object. One path is through the variable `Techs` and the other through
    the first element of the `list` object to which `Univs` is bound. We can mutate
    the object via either path, and the effect of the mutation will be visible through
    both paths. This can be convenient, but it can also be treacherous. Unintentional
    aliasing leads to programming errors that are often enormously hard to track down.
    For example, what do you think is printed by
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: "It prints `\uFEFFL1 = [[0, 1], [0, 1]] but L2 = [[0], [1]]`. Why? Because the\
    \ first assignment statement creates a list with two elements, each of which is\
    \ the same object, whereas the second assignment statement creates a list with\
    \ two different objects, each of which is initially equal to an empty list."
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise:** What does the following code print?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The interaction of aliasing and mutability with default parameter values is
    something to watch out for. Consider the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: "You might think that the second call to `append_val` would print the list `[4]`\
    \ because it would have appended `4` to the empty list. In fact, it will print\
    \ `\uFEFF[3, 4]`. This happens because, at function definition time, a new object\
    \ of type `list` is created, with an initial value of the empty list. Each time\
    \ `append_val` is invoked without supplying a value for the formal parameter `list_1`,\
    \ the object created at function definition is bound to `list_1`, mutated, and\
    \ then printed. So, the second call to `append_val` mutates and then prints a\
    \ list that was already mutated by the first call to that function."
  prefs: []
  type: TYPE_NORMAL
- en: When we append one list to another, e.g., `Techs.append(Ivys)`, the original
    structure is maintained. The result is a list that contains a list. Suppose we
    do not want to maintain this structure, but want to add the elements of one list
    into another list. We can do that by using list concatenation (using the `+` operator)
    or the `extend` method, e.g.,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: will print
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the operator `+` does not have a side effect. It creates a new list
    and returns it. In contrast, `extend` and `append` each mutate `L1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-4](#c5-fig-0004) briefly describes some of the methods associated
    with lists. Note that all of these except `count` and `index` mutate the list.'
  prefs: []
  type: TYPE_NORMAL
- en: '![c5-fig-0004.jpg](../images/c5-fig-0004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 5-4](#c5-fig-0004a) Common methods associated with lists'
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.1 Cloning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is usually prudent to avoid mutating a list over which one is iterating.
    Consider the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You might be surprised to discover that this prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: During a `for` loop, Python keeps track of where it is in the list using an
    internal counter that is incremented at the end of each iteration. When the value
    of the counter reaches the current length of the list, the loop terminates. This
    works as you might expect if the list is not mutated within the loop, but can
    have surprising consequences if the list is mutated. In this case, the hidden
    counter starts out at `0`, discovers that `L1[0]` is in `L2`, and removes it—reducing
    the length of `L1` to `3`. The counter is then incremented to `1`, and the code
    proceeds to check if the value of `L1[1]` is in `L2`. Notice that this is not
    the original value of `L1[1]` (i.e., `2`), but rather the current value of `L1[1]`
    (i.e., `3`). As you can see, it is possible to figure out what happens when the
    list is modified within the loop. However, it is not easy. And what happens is
    likely to be unintentional, as in this example.
  prefs: []
  type: TYPE_NORMAL
- en: One way to avoid this kind of problem is to use slicing to **clone**[^(35)](#c5-fn-0003)
    (i.e., make a copy of) the list and write `for e1 in L1[:]`. Notice that writing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: would not solve the problem. It would not create a copy of `L1`, but would merely
    introduce a new name for the existing list.
  prefs: []
  type: TYPE_NORMAL
- en: Slicing is not the only way to clone lists in Python. The expression `L.copy()`
    has the same value as `L[:]`. Both slicing and `copy` perform what is known as
    a **shallow copy**. A shallow copy creates a new list and then inserts the objects
    (not copies of the objects) of the list to be copied into the new list. The code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: "prints `\uFEFFL1 = [[2, 3]] L2 = [[2, 3]]` because both `L1` and `L2` contain\
    \ the object that was bound to `L` in the first assignment statement."
  prefs: []
  type: TYPE_NORMAL
- en: "If the list to be copied contains mutable objects that you also want to copy,\
    \ import the standard library module `copy` and use the function `copy.deepcopy`\
    \ to make a **deep copy**. The method `deepcopy` creates a new list and then inserts\
    \ copies of the objects in the list to be copied into the new list. If we replace\
    \ the third line in the above code by \uFEFF`L2 = copy.deepcopy(L1)`, it will\
    \ print `\uFEFFL1 = [[2, 3]], L2 = [[2]]`, because `L1` would not contain the\
    \ object to which `L` is bound."
  prefs: []
  type: TYPE_NORMAL
- en: Understanding `copy.deepcopy` is tricky if the elements of a list are lists
    containing lists (or any mutable type). Consider
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: "The value of `L3` will be `\uFEFF[[[2]]]` because `copy.deepcopy` creates a\
    \ new object not only for the list `[L1]`, but also for the list `L1`. I.e., it\
    \ makes copies all the way to the bottom—most of the time. Why “most of the time?”\
    \ The code"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: creates a list that contains itself. An attempt to make copies all the way to
    the bottom would never terminate. To avoid this problem, `copy.deepcopy` makes
    exactly one copy of each object, and then uses that copy for each instance of
    the object. This matters even when lists do not contain themselves. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: "prints `\uFEFF[[2, 3], [2, 3]]` because `copy.deepcopy` makes one copy of `L1`\
    \ and uses it both times `L1` occurs in `L2`."
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.2 List Comprehension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**List comprehension** provides a concise way to apply an operation to the
    sequence values provided by iterating over an iterable value. It creates a new
    list in which each element is the result of applying a given operation to a value
    from an iterable (e.g., the elements in another list). It is an expression of
    the form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Evaluating the expression is equivalent to invoking the function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: "For example, `[e**2 for e in range(6)] evaluates to \uFEFF[0, 1, 4, 9, 16,\
    \ 25], [e**2 for e in range(8) if e%2 == 0]` evaluates to `\uFEFF[0, 4, 16, 36]`,\
    \ and `\uFEFF[x**2 for x in [2, 'a', 3, 4.0] if type(x) == int]` evaluates to\
    \ `\uFEFF[4, 9]`."
  prefs: []
  type: TYPE_NORMAL
- en: "List comprehension provides a convenient way to initialize lists. For example,\
    \ `\uFEFF[[] for _ in range(10)]` generates a list containing 10 distinct (i.e.,\
    \ non-aliased) empty lists. The variable name `_` indicates that the values of\
    \ that variable are not used in generating the elements of list, i.e., it is merely\
    \ a placeholder. This convention is common in Python programs."
  prefs: []
  type: TYPE_NORMAL
- en: Python allows multiple `for` statements within a list comprehension. Consider
    the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The Python interpreter starts by evaluating the first `for`, assigning to `x`
    the sequence of values `0,2,4`. For each of these three values of `x`, it evaluates
    the second `for` (which generates the sequence of values `0,3` each time). It
    then adds to the list being generated the tuple `(x, y)`, producing the list
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we can produce the same list without list comprehension, but the
    code is considerably less compact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The following code is an example of nesting a list comprehension within a list
    comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: "It prints `\uFEFF[[(0, 0), (2, 0), (4, 0)], [(0, 3), (2, 3), (4, 3)]]`."
  prefs: []
  type: TYPE_NORMAL
- en: It takes practice to get comfortable with nested list comprehensions, but they
    can be quite useful. Let's use nested list comprehensions to generate a list of
    all prime numbers less than 100\. The basic idea is to use one comprehension to
    generate a list of all of the candidate numbers (i.e., 2 through 99), a second
    comprehension to generate a list of the remainders of dividing a candidate prime
    by each potential divisor, and the built-in function `all` to test if any of those
    remainders is 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Evaluating the expression is equivalent to invoking the function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '**Finger exercise:** Write a list comprehension that generates all non-primes
    between 2 and 100.'
  prefs: []
  type: TYPE_NORMAL
- en: Some Python programmers use list comprehensions in marvelous and subtle ways.
    That is not always a great idea. Remember that somebody else may need to read
    your code, and “subtle” is rarely a desirable property for a program.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4 Higher-Order Operations on Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Section 4.4 we introduced the notion of higher-order programming. It can
    be particularly convenient with lists, as shown in [Figure 5-5](#c5-fig-0005).
  prefs: []
  type: TYPE_NORMAL
- en: '![c5-fig-0005.jpg](../images/c5-fig-0005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 5-5](#c5-fig-0005a) Applying a function to elements of a list'
  prefs: []
  type: TYPE_NORMAL
- en: The function `apply_to_each` is called **higher-order** because it has an argument
    that is itself a function. The first time it is called, it mutates `L` by applying
    the unary built-in function `abs` to each element. The second time it is called,
    it applies a type conversion to each element. And the third time it is called,
    it replaces each element by the result of applying a function defined using `lambda`.
    It prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: "Python has a built-in higher-order function, `map`, that is similar to, but\
    \ more general than, the `apply_to_each` function defined in [Figure 5-5](#c5-fig-0005).\
    \ In its simplest form the first argument to `map` is a unary function (i.e.,\
    \ a function that has only one parameter) and the second argument is any ordered\
    \ collection of values suitable as arguments to the first argument. It is frequently\
    \ used in lieu of a list comprehension. For example, \uFEFF`list(map(str, range(10)))`\
    \ is equivalent to `\uFEFF[str(e) for e in range(10)]`."
  prefs: []
  type: TYPE_NORMAL
- en: The `map` function is often used with a `for` loop. When used in a `for` loop,
    `map` behaves like the `range` function in that it returns one value for each
    iteration of the loop. These values are generated by applying the first argument
    to each element of the second argument. For example, the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: More generally, the first argument to `map` can be a function of `n` arguments,
    in which case it must be followed by `n` subsequent ordered collections (each
    of the same length). For example, the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '**Finger exercise**: Implement a function satisfying the following specification.
    Hint: it will be convenient to use `lambda` in the body of the implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 5.5 Strings, Tuples, Ranges, and Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have looked at four iterable sequence types: `str`, `tuple`, `range`, and
    `list`. They are similar in that objects of these types can be operated upon as
    described in [Figure 5-6](#c5-fig-0006). Some of their other similarities and
    differences are summarized in [Figure 5-7](#c5-fig-0007).'
  prefs: []
  type: TYPE_NORMAL
- en: '![c5-fig-0006.jpg](../images/c5-fig-0006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 5-6](#c5-fig-0006a) Common operations on sequence types'
  prefs: []
  type: TYPE_NORMAL
- en: '![c5-fig-0007.jpg](../images/c5-fig-0007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 5-7](#c5-fig-0007a) Comparison of sequence types'
  prefs: []
  type: TYPE_NORMAL
- en: Python programmers tend to use lists far more often than tuples. Since lists
    are mutable, they can be constructed incrementally during a computation. For example,
    the following code incrementally builds a list containing all of the even numbers
    in another list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Since strings can contain only characters, they are considerably less versatile
    than tuples or lists. On the other hand, when you are working with a string of
    characters, there are many useful built-in methods. [Figure 5-8](#c5-fig-0008)
    contains short descriptions of a few of them. Keep in mind that since strings
    are immutable, these all return values and have no side effect.
  prefs: []
  type: TYPE_NORMAL
- en: '![c5-fig-0008.jpg](../images/c5-fig-0008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 5-8](#c5-fig-0008a) Some methods on strings'
  prefs: []
  type: TYPE_NORMAL
- en: One of the more useful built-in methods is `split`, which takes two strings
    as arguments. The second argument specifies a separator that is used to split
    the first argument into a sequence of substrings. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The second argument is optional. If that argument is omitted, the first string
    is split using arbitrary strings of **whitespace characters** (space, tab, newline,
    return, and formfeed).[^(36)](#c5-fn-0004)
  prefs: []
  type: TYPE_NORMAL
- en: 5.6 Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Sets** are yet another kind of collection type. They are similar to the notion
    of a set in mathematics in that they are unordered collections of unique elements.
    They are denoted using what programmers call curly braces and mathematicians call
    set braces, e.g.,'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Since the elements of a set are unordered, attempting to index into a set, e.g.,
    evaluating `baseball_teams[0],` generates a runtime error. We can use a `for`
    statement to iterate over the elements of a set, but unlike the other collection
    types we have seen, the order in which the elements are produced is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: Like lists, sets are mutable. We add a single element to a set using the `add`
    method. We add multiple elements to a set by passing a collection of elements
    (e.g., a list) to the `update` method. For example, the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: (The order in which the elements appear is not defined by the language, so you
    might get a different output if you run this example.)
  prefs: []
  type: TYPE_NORMAL
- en: Elements can be removed from a set using the `remove` method, which raises an
    error if the element is not in the set, or the `discard` method, which does not
    raise an error if the element is not in the set.
  prefs: []
  type: TYPE_NORMAL
- en: "Membership in a set can be tested using the `in` operator. For example, `\uFEFF\
    'Rockies' in baseball_teams` returns `True`. The binary methods `union`, `intersection`,\
    \ `difference`, and `issubset` have their usual mathematical meanings. For example,"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: One of the nice things about sets is that there are convenient infix operators
    for many of the methods, including `|` for `union`, `&` for `intersect`, `-` for
    `difference`, `<=` for `subse`t, and `>=` for `superset`. Using these operators
    makes code easier to read. Compare, for example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: to the code presented earlier, which uses dot notation to print the same values.
  prefs: []
  type: TYPE_NORMAL
- en: Not all types of objects can be elements of sets. All objects in a set must
    be **hashable**. An object is hashable if it has
  prefs: []
  type: TYPE_NORMAL
- en: A `__hash__` method that maps the object of the type to an `int`, and the value
    returned by `__hash__` does not change during the lifetime of the object, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `__eq__` method that is used to compare it for equality to other objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All objects of Python's scalar immutable types are hashable, and no object of
    Python's built-in mutable types is hashable. An object of a non-scalar immutable
    type (e.g., a tuple) is hashable if all of its elements are hashable.
  prefs: []
  type: TYPE_NORMAL
- en: 5.7 Dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Objects of type `**dict**` (short for **dictionary**) are like lists except
    that we index them using **keys** rather than integers. Any hashable object can
    be used as a key. Think of a dictionary as a set of key/value pairs. Literals
    of type `dict` are enclosed in curly braces and each element is written as a key
    followed by a colon followed by a **value**. For example, the code,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: will print
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The entries in a `dict` cannot be accessed using an index. That's why `month_numbers[1]`
    unambiguously refers to the entry with the key `1` rather than the second entry.
    Whether a key is defined in a dictionary can be tested using the `in` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Like lists, dictionaries are mutable. We can add an entry by writing, for example,
    `month_numbers['June'] = 6` or change an entry by writing, for example, `month_numbers['May']
    = 'V'.`
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries are one of the great things about Python. They greatly reduce the
    difficulty of writing a variety of programs. For example, in [Figure 5-9](#c5-fig-0009)
    we use dictionaries to write a (pretty horrible) program to translate between
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: The code in the figure prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Remember that dictionaries are mutable. So, be careful about side effects. For
    example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: will print
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '![c5-fig-0009.jpg](../images/c5-fig-0009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 5-9](#c5-fig-0009a) Translating text (badly)'
  prefs: []
  type: TYPE_NORMAL
- en: Many programming languages do not contain a built-in type that provides a mapping
    from keys to values. Instead, programmers use other types to provide similar functionality.
    It is, for example, relatively easy to implement a dictionary by using a list
    in which each element is a tuple representing a key/value pair. We can then write
    a simple function that does the associative retrieval, e.g.,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The problem with such an implementation is that it is computationally inefficient.
    In the worst case, a program might have to examine each element in the list to
    perform a single retrieval. In contrast, the built-in implementation is fast.
    It uses a technique called hashing, described in Chapter 12, to do the lookup
    in time that is nearly independent of the size of the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple ways to use a `for` statement to iterate over the entries
    in a dictionary. If `d` is a dictionary, a loop of the form `for k in d` iterates
    over the keys of `d`. The order in which the keys are chosen is the order in which
    the keys were inserted in the dictionary.[^(37)](#c5-fn-0005) For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: To iterate over the values in a dictionary, we can use the method `values`.
    For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: "prints `\uFEFF['Paris', 'Rome', 'Kyoto'] is a list of capital cities`."
  prefs: []
  type: TYPE_NORMAL
- en: The method `values` returns an object of type `dict_values`. This is an example
    of a **view object**. A view object is dynamic in that if the object with which
    it is associated changes, the change is visible through the view object. For example,
    the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: "Similarly, the method `keys` returns a view object of type `dict_keys`. View\
    \ objects can be converted to lists, e.g., `list(capitals.values())` returns \uFEFF\
    a list of the values in capitals."
  prefs: []
  type: TYPE_NORMAL
- en: To iterate over key/value pairs, we use the method `items`. This method returns
    a view object of type `dict_items`. Each element of an object of type `dict_items`
    is a `tuple` of a key and its associated value. For example, the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '**Finger exercise:** Implement a function that meets the specification'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: It is often convenient to use tuples as keys. Imagine, for example, using a
    tuple of the form `(flight_number, day)` to represent airline flights. It would
    then be easy to use such tuples as keys in a dictionary implementing a mapping
    from flights to arrival times. A list cannot be used as key, because objects of
    type list are not hashable.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, there are many useful methods associated with dictionaries,
    including some for removing elements. We do not enumerate all of them here, but
    will use them as convenient in examples later in the book. [Figure 5-10](#c5-fig-0010)
    contains some of the more useful operations on dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: '![c5-fig-0010.jpg](../images/c5-fig-0010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 5-10](#c5-fig-0010a) Some common operations on dicts'
  prefs: []
  type: TYPE_NORMAL
- en: 5.8 Dictionary Comprehension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Dictionary comprehension** is similar to list comprehension. The general
    form is'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The key difference (other than the use of set braces rather than square braces)
    is that it uses two values to create each element of the dictionary, and allows
    (but does not require) the iterable to return two values at a time. Consider a
    dictionary mapping some decimal digits to English words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: We can easily use dictionary comprehension to produce a dictionary that maps
    words to digits with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: If we decide that we only want single digit numbers in `word_to_number`, we
    can use the comprehension
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's try something more ambitious. A cipher is an algorithm that maps
    a plain text (a text that can be easily read by a human) to a crypto text. The
    simplest ciphers are substitution ciphers that replace each character in the plain
    text with a unique string. The mapping from the original characters to the string
    that replaces them is called a key (by analogy with the kind of key used to open
    a lock, not the kind of key used in Python dictionaries). In Python, dictionaries
    provide a convenient way to implement mappings that can be used to code and decode
    text.
  prefs: []
  type: TYPE_NORMAL
- en: A **book cipher** is a cipher for which the key is derived from a book. For
    example, it might map each character in the plain text to the numeric index of
    the first occurrence of that character in the book (or on a page of the book).
    The assumption is that the sender and receiver of the coded message have previously
    agreed on the book, but an adversary who intercepts the coded message does not
    know what book was used to code it.
  prefs: []
  type: TYPE_NORMAL
- en: The following function definition uses dictionary comprehension to create a
    dictionary that can be used for encoding a plain text using a book cipher.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: If `plain_text` were “no is no” and `book` started with “Once upon a time, in
    a house in a land far away,” the call `gen_code_keys(book, plain_text)` would
    return
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Notice, by the way, that o gets mapped to seven rather than zero because o and
    O are different characters. If `book` were the text of *Don Quixote*,[^(38)](#c5-fn-0006)
    the call `gen_code_keys(book, plain_text)` would return
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our coding dictionary, we can use list comprehension to define
    a function that uses it to encrypt a plain text
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Since characters in the plain text might be replaced by multiple characters
    in the cipher text, we use `*` to separate characters in the cipher text. The
    `.join` operator is used to turn the list of strings into a single string.
  prefs: []
  type: TYPE_NORMAL
- en: The function `encrypt` uses `gen_code_keys` and `encoder` to encrypt a plain
    text
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The call `encrypt(Don_Quixote, 'no is no')` returns
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Before we can decode the cipher text, we need to build a decoding dictionary.
    The easy thing to do would be to invert the coding dictionary, but that would
    be cheating. The whole point of a book cipher is that the sender sends an encrypted
    message, but not any information about the keys. The only thing the receiver needs
    to decode the message is access to the book that the encoder used. The following
    function definition uses dictionary comprehension to build a decoding key from
    the book and the coded message.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: "The call `\uFEFFgen_decode_keys(Don_Quixote, '1*13*2*6*57*2*1*13')` would produce\
    \ the decrypting key"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: If a character occurs in the plain text but not in the book, something bad happens.
    The `code_keys` dictionary will map each such character to `-1`, and `decode_keys`
    will map `-1` to whatever the last character in the book happens to be.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise**: Remedy the problem described in the previous paragraph.
    Hint: a simple way to do this is to create a new book by appending something to
    the original book.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise**: Using `encoder` and `encrypt` as models, implement the
    functions `decoder` and `decrypt`. Use them to decrypt the message'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: which was encrypted using the opening of *Don Quixote*.
  prefs: []
  type: TYPE_NORMAL
- en: 5.9 Terms Introduced in Chapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: tuple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: multiple assignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iterable object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: type iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mutable type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: immutable type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: id function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: object equality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: side effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: aliasing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cloning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: shallow copy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: deep copy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: list comprehension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: higher-order function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: whitespace character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: hashable type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: view object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: dictionary comprehension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: book cipher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
