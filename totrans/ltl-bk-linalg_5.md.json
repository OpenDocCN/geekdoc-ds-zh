["```py\nimport numpy as np\n```", "```py\na = 5       # a scalar\nb = -2.5    # another scalar\n\nprint(a + b)   # add them\nprint(a * b)   # multiply them\n```", "```py\n2.5\n-12.5\n```", "```py\nv = np.array([2, 3])      # a vector in 2D\nw = np.array([1, -1, 4])  # a vector in 3D\n\nprint(v)\nprint(w)\n```", "```py\n[2 3]\n[ 1 -1  4]\n```", "```py\nimport matplotlib.pyplot as plt\n\n# plot vector v\nplt.quiver(0, 0, v[0], v[1], angles='xy', scale_units='xy', scale=1, color='r')\nplt.xlim(0, 4)\nplt.ylim(0, 4)\nplt.grid()\nplt.show()\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n```", "```py\n# Two-dimensional vector\nv = np.array([2, 3])\n\n# Three-dimensional vector\nw = np.array([1, -1, 4])\n\nprint(\"v =\", v)\nprint(\"w =\", w)\n```", "```py\nv = [2 3]\nw = [ 1 -1  4]\n```", "```py\nprint(\"First component of v:\", v[0])\nprint(\"Second component of v:\", v[1])\n```", "```py\nFirst component of v: 2\nSecond component of v: 3\n```", "```py\nplt.quiver(0, 0, v[0], v[1], angles='xy', scale_units='xy', scale=1, color='r')\nplt.xlim(-1, 4)\nplt.ylim(-2, 4)\nplt.axhline(0, color='black', linewidth=0.5)\nplt.axvline(0, color='black', linewidth=0.5)\nplt.grid()\nplt.show()\n```", "```py\nu = np.array([3, 1])\nz = np.array([-1, 2])\n\n# Draw v, u, z in different colors\nplt.quiver(0, 0, v[0], v[1], angles='xy', scale_units='xy', scale=1, color='r', label='v')\nplt.quiver(0, 0, u[0], u[1], angles='xy', scale_units='xy', scale=1, color='b', label='u')\nplt.quiver(0, 0, z[0], z[1], angles='xy', scale_units='xy', scale=1, color='g', label='z')\n\nplt.xlim(-2, 4)\nplt.ylim(-2, 4)\nplt.axhline(0, color='black', linewidth=0.5)\nplt.axvline(0, color='black', linewidth=0.5)\nplt.grid()\nplt.show()\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n```", "```py\nv = np.array([2, 3])\nu = np.array([1, -1])\n\nsum_vector = v + u\nprint(\"v + u =\", sum_vector)\n```", "```py\nv + u = [3 2]\n```", "```py\nplt.quiver(0, 0, v[0], v[1], angles='xy', scale_units='xy', scale=1, color='r', label='v')\nplt.quiver(v[0], v[1], u[0], u[1], angles='xy', scale_units='xy', scale=1, color='b', label='u placed at end of v')\nplt.quiver(0, 0, sum_vector[0], sum_vector[1], angles='xy', scale_units='xy', scale=1, color='g', label='v + u')\n\nplt.xlim(-1, 5)\nplt.ylim(-2, 5)\nplt.axhline(0, color='black', linewidth=0.5)\nplt.axvline(0, color='black', linewidth=0.5)\nplt.grid()\nplt.show()\n```", "```py\nc = 2\nscaled_v = c * v\nprint(\"2 * v =\", scaled_v)\n\nd = -1\nscaled_v_neg = d * v\nprint(\"-1 * v =\", scaled_v_neg)\n```", "```py\n2 * v = [4 6]\n-1 * v = [-2 -3]\n```", "```py\nplt.quiver(0, 0, v[0], v[1], angles='xy', scale_units='xy', scale=1, color='r', label='v')\nplt.quiver(0, 0, scaled_v[0], scaled_v[1], angles='xy', scale_units='xy', scale=1, color='b', label='2 * v')\nplt.quiver(0, 0, scaled_v_neg[0], scaled_v_neg[1], angles='xy', scale_units='xy', scale=1, color='g', label='-1 * v')\n\nplt.xlim(-5, 5)\nplt.ylim(-5, 7)\nplt.axhline(0, color='black', linewidth=0.5)\nplt.axvline(0, color='black', linewidth=0.5)\nplt.grid()\nplt.show()\n```", "```py\ncombo = 3*v + (-2)*u\nprint(\"3*v - 2*u =\", combo)\n```", "```py\n3*v - 2*u = [ 4 11]\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n```", "```py\nv = np.array([2, 1])\nu = np.array([1, 3])\n\ncombo1 = 2*v + 3*u\ncombo2 = -1*v + 4*u\n\nprint(\"2*v + 3*u =\", combo1)\nprint(\"-v + 4*u =\", combo2)\n```", "```py\n2*v + 3*u = [ 7 11]\n-v + 4*u = [ 2 11]\n```", "```py\nplt.quiver(0, 0, v[0], v[1], angles='xy', scale_units='xy', scale=1, color='r', label='v')\nplt.quiver(0, 0, u[0], u[1], angles='xy', scale_units='xy', scale=1, color='b', label='u')\nplt.quiver(0, 0, combo1[0], combo1[1], angles='xy', scale_units='xy', scale=1, color='g', label='2v + 3u')\nplt.quiver(0, 0, combo2[0], combo2[1], angles='xy', scale_units='xy', scale=1, color='m', label='-v + 4u')\n\nplt.xlim(-5, 10)\nplt.ylim(-5, 10)\nplt.axhline(0, color='black', linewidth=0.5)\nplt.axvline(0, color='black', linewidth=0.5)\nplt.grid()\nplt.show()\n```", "```py\n# Generate many combinations\ncoeffs = range(-5, 6)\npoints = []\nfor a in coeffs:\n for b in coeffs:\n point = a*v + b*u\n points.append(point)\n\npoints = np.array(points)\n\nplt.scatter(points[:,0], points[:,1], s=10, color='gray')\nplt.quiver(0, 0, v[0], v[1], angles='xy', scale_units='xy', scale=1, color='r')\nplt.quiver(0, 0, u[0], u[1], angles='xy', scale_units='xy', scale=1, color='b')\n\nplt.xlim(-10, 10)\nplt.ylim(-10, 10)\nplt.axhline(0, color='black', linewidth=0.5)\nplt.axvline(0, color='black', linewidth=0.5)\nplt.grid()\nplt.show()\n```", "```py\nw = np.array([4, 2])  # notice w = 2*v\ncoeffs = range(-5, 6)\npoints = []\nfor a in coeffs:\n for b in coeffs:\n points.append(a*v + b*w)\n\npoints = np.array(points)\n\nplt.scatter(points[:,0], points[:,1], s=10, color='gray')\nplt.quiver(0, 0, v[0], v[1], angles='xy', scale_units='xy', scale=1, color='r')\nplt.quiver(0, 0, w[0], w[1], angles='xy', scale_units='xy', scale=1, color='b')\n\nplt.xlim(-10, 10)\nplt.ylim(-10, 10)\nplt.axhline(0, color='black', linewidth=0.5)\nplt.axvline(0, color='black', linewidth=0.5)\nplt.grid()\nplt.show()\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n```", "```py\nv = np.array([3, 4])\nlength = np.linalg.norm(v)\nprint(\"Length of v =\", length)\n```", "```py\nLength of v = 5.0\n```", "```py\nmanual_length = (v[0]**2 + v[1]**2)**0.5\nprint(\"Manual length =\", manual_length)\nprint(\"NumPy length =\", np.linalg.norm(v))\n```", "```py\nManual length = 5.0\nNumPy length = 5.0\n```", "```py\nplt.quiver(0, 0, v[0], v[1], angles='xy', scale_units='xy', scale=1, color='r')\nplt.xlim(0, 5)\nplt.ylim(0, 5)\nplt.axhline(0, color='black', linewidth=0.5)\nplt.axvline(0, color='black', linewidth=0.5)\nplt.text(v[0]/2, v[1]/2, f\"Length={length}\", fontsize=10, color='blue')\nplt.grid()\nplt.show()\n```", "```py\nu = np.array([0, 0])   # the origin\ndist = np.linalg.norm(v - u)\nprint(\"Distance between v and u =\", dist)\n```", "```py\nDistance between v and u = 5.0\n```", "```py\nu = np.array([1, 1])\ndist = np.linalg.norm(v - u)\nprint(\"Distance between v and u =\", dist)\n```", "```py\nDistance between v and u = 3.605551275463989\n```", "```py\nplt.scatter([v[0], u[0]], [v[1], u[1]], color=['red','blue'])\nplt.plot([v[0], u[0]], [v[1], u[1]], 'k--')\nplt.text(v[0], v[1], 'v', fontsize=12, color='red')\nplt.text(u[0], u[1], 'u', fontsize=12, color='blue')\nplt.grid()\nplt.show()\n```", "```py\na = np.array([1,2,3])\nb = np.array([4,0,8])\nprint(\"‖a‖ =\", np.linalg.norm(a))\nprint(\"‖b‖ =\", np.linalg.norm(b))\nprint(\"Distance between a and b =\", np.linalg.norm(a-b))\n```", "```py\n‖a‖ = 3.7416573867739413\n‖b‖ = 8.94427190999916\nDistance between a and b = 6.164414002968976\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n```", "```py\nv = np.array([2, 3])\nu = np.array([4, -1])\n\ndot_manual = v[0]*u[0] + v[1]*u[1]\ndot_numpy = np.dot(v, u)\n\nprint(\"Manual dot product:\", dot_manual)\nprint(\"NumPy dot product:\", dot_numpy)\n```", "```py\nManual dot product: 5\nNumPy dot product: 5\n```", "```py\nnorm_v = np.linalg.norm(v)\nnorm_u = np.linalg.norm(u)\n\ncos_theta = np.dot(v, u) / (norm_v * norm_u)\ntheta = np.arccos(cos_theta)\n\nprint(\"cos(theta) =\", cos_theta)\nprint(\"theta (in radians) =\", theta)\nprint(\"theta (in degrees) =\", np.degrees(theta))\n```", "```py\ncos(theta) = 0.33633639699815626\ntheta (in radians) = 1.2277723863741932\ntheta (in degrees) = 70.3461759419467\n```", "```py\nplt.quiver(0,0,v[0],v[1],angles='xy',scale_units='xy',scale=1,color='r',label='v')\nplt.quiver(0,0,u[0],u[1],angles='xy',scale_units='xy',scale=1,color='b',label='u')\nplt.xlim(-1,5)\nplt.ylim(-2,4)\nplt.axhline(0,color='black',linewidth=0.5)\nplt.axvline(0,color='black',linewidth=0.5)\nplt.grid()\nplt.show()\n```", "```py\nproj_length = np.dot(v, u) / np.linalg.norm(u)\nprint(\"Projection length of v onto u:\", proj_length)\n```", "```py\nProjection length of v onto u: 1.212678125181665\n```", "```py\na = np.array([1,0])\nb = np.array([0,1])\nc = np.array([-1,0])\n\nprint(\"a · b =\", np.dot(a,b))   # perpendicular\nprint(\"a · a =\", np.dot(a,a))   # length squared\nprint(\"a · c =\", np.dot(a,c))   # opposite\n```", "```py\na · b = 0\na · a = 1\na · c = -1\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n```", "```py\nv = np.array([2, 3])\nu = np.array([3, -1])\n\ndot = np.dot(v, u)\nnorm_v = np.linalg.norm(v)\nnorm_u = np.linalg.norm(u)\n\ncos_theta = dot / (norm_v * norm_u)\ntheta = np.arccos(cos_theta)\n\nprint(\"cos(theta) =\", cos_theta)\nprint(\"theta in radians =\", theta)\nprint(\"theta in degrees =\", np.degrees(theta))\n```", "```py\ncos(theta) = 0.2631174057921088\ntheta in radians = 1.3045442776439713\ntheta in degrees = 74.74488129694222\n```", "```py\nplt.quiver(0,0,v[0],v[1],angles='xy',scale_units='xy',scale=1,color='r',label='v')\nplt.quiver(0,0,u[0],u[1],angles='xy',scale_units='xy',scale=1,color='b',label='u')\n\nplt.xlim(-1,4)\nplt.ylim(-2,4)\nplt.axhline(0,color='black',linewidth=0.5)\nplt.axvline(0,color='black',linewidth=0.5)\nplt.grid()\nplt.show()\n```", "```py\na = np.array([1,0])\nb = np.array([0,1])\nc = np.array([-1,0])\n\nprint(\"Angle between a and b =\", np.degrees(np.arccos(np.dot(a,b)/(np.linalg.norm(a)*np.linalg.norm(b)))))\nprint(\"Angle between a and c =\", np.degrees(np.arccos(np.dot(a,c)/(np.linalg.norm(a)*np.linalg.norm(c)))))\n```", "```py\nAngle between a and b = 90.0\nAngle between a and c = 180.0\n```", "```py\ncosine_similarity = np.dot(v,u)/(np.linalg.norm(v)*np.linalg.norm(u))\nprint(\"Cosine similarity =\", cosine_similarity)\n```", "```py\nCosine similarity = 0.2631174057921088\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n```", "```py\nv = np.array([3, 2])\nu = np.array([2, 0])\n\nproj_u_v = (np.dot(v, u) / np.dot(u, u)) * u\nprint(\"Projection of v onto u:\", proj_u_v)\n```", "```py\nProjection of v onto u: [3\\. 0.]\n```", "```py\nperp = v - proj_u_v\nprint(\"Parallel part:\", proj_u_v)\nprint(\"Perpendicular part:\", perp)\n```", "```py\nParallel part: [3\\. 0.]\nPerpendicular part: [0\\. 2.]\n```", "```py\nplt.quiver(0, 0, v[0], v[1], angles='xy', scale_units='xy', scale=1, color='r', label='v')\nplt.quiver(0, 0, u[0], u[1], angles='xy', scale_units='xy', scale=1, color='b', label='u')\nplt.quiver(0, 0, proj_u_v[0], proj_u_v[1], angles='xy', scale_units='xy', scale=1, color='g', label='proj_u(v)')\nplt.quiver(proj_u_v[0], proj_u_v[1], perp[0], perp[1], angles='xy', scale_units='xy', scale=1, color='m', label='perpendicular')\n\nplt.xlim(-1, 5)\nplt.ylim(-1, 4)\nplt.axhline(0, color='black', linewidth=0.5)\nplt.axvline(0, color='black', linewidth=0.5)\nplt.grid()\nplt.show()\n```", "```py\na = np.array([1,2,3])\nb = np.array([0,1,0])\n\nproj = (np.dot(a,b)/np.dot(b,b)) * b\nperp = a - proj\n\nprint(\"Projection of a onto b:\", proj)\nprint(\"Perpendicular component:\", perp)\n```", "```py\nProjection of a onto b: [0\\. 2\\. 0.]\nPerpendicular component: [1\\. 0\\. 3.]\n```", "```py\nimport numpy as np\n```", "```py\nv = np.array([3, 4])\nu = np.array([1, 2])\n\nlhs = abs(np.dot(v, u))\nrhs = np.linalg.norm(v) * np.linalg.norm(u)\n\nprint(\"Left-hand side (|v·u|):\", lhs)\nprint(\"Right-hand side (‖v‖‖u‖):\", rhs)\nprint(\"Inequality holds?\", lhs <= rhs)\n```", "```py\nLeft-hand side (|v·u|): 11\nRight-hand side (‖v‖‖u‖): 11.180339887498949\nInequality holds? True\n```", "```py\npairs = [\n (np.array([1,0]), np.array([0,1])),  # perpendicular\n (np.array([2,3]), np.array([4,6])),  # multiples\n (np.array([-1,2]), np.array([3,-6])) # opposite multiples\n]\n\nfor v,u in pairs:\n lhs = abs(np.dot(v, u))\n rhs = np.linalg.norm(v) * np.linalg.norm(u)\n print(f\"v={v}, u={u} -> |v·u|={lhs}, ‖v‖‖u‖={rhs}, holds={lhs<=rhs}\")\n```", "```py\nv=[1 0], u=[0 1] -> |v·u|=0, ‖v‖‖u‖=1.0, holds=True\nv=[2 3], u=[4 6] -> |v·u|=26, ‖v‖‖u‖=25.999999999999996, holds=False\nv=[-1  2], u=[ 3 -6] -> |v·u|=15, ‖v‖‖u‖=15.000000000000002, holds=True\n```", "```py\nv = np.array([3, 4])\nu = np.array([1, 2])\n\nlhs = np.linalg.norm(v + u)\nrhs = np.linalg.norm(v) + np.linalg.norm(u)\n\nprint(\"‖v+u‖ =\", lhs)\nprint(\"‖v‖ + ‖u‖ =\", rhs)\nprint(\"Inequality holds?\", lhs <= rhs)\n```", "```py\n‖v+u‖ = 7.211102550927978\n‖v‖ + ‖u‖ = 7.23606797749979\nInequality holds? True\n```", "```py\nimport matplotlib.pyplot as plt\n\norigin = np.array([0,0])\npoints = np.array([origin, v, v+u, origin])\n\nplt.plot(points[:,0], points[:,1], 'ro-')  # triangle outline\nplt.text(v[0], v[1], 'v')\nplt.text(v[0]+u[0], v[1]+u[1], 'v+u')\nplt.text(u[0], u[1], 'u')\n\nplt.grid()\nplt.axhline(0,color='black',linewidth=0.5)\nplt.axvline(0,color='black',linewidth=0.5)\nplt.axis('equal')\nplt.show()\n```", "```py\nfor _ in range(5):\n v = np.random.randn(2)\n u = np.random.randn(2)\n lhs = np.linalg.norm(v+u)\n rhs = np.linalg.norm(v) + np.linalg.norm(u)\n print(f\"‖v+u‖={lhs:.3f}, ‖v‖+‖u‖={rhs:.3f}, holds={lhs <= rhs}\")\n```", "```py\n‖v+u‖=0.778, ‖v‖+‖u‖=2.112, holds=True\n‖v+u‖=1.040, ‖v‖+‖u‖=2.621, holds=True\n‖v+u‖=1.632, ‖v‖+‖u‖=2.482, holds=True\n‖v+u‖=1.493, ‖v‖+‖u‖=2.250, holds=True\n‖v+u‖=2.653, ‖v‖+‖u‖=2.692, holds=True\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n```", "```py\nx_axis = np.array([1, 0])\ny_axis = np.array([0, 1])\n\nprint(\"x_axis · y_axis =\", np.dot(x_axis, y_axis))  # should be 0\n```", "```py\nx_axis · y_axis = 0\n```", "```py\nv = np.array([3, 4])\nv_normalized = v / np.linalg.norm(v)\n\nprint(\"Original v:\", v)\nprint(\"Normalized v:\", v_normalized)\nprint(\"Length of normalized v:\", np.linalg.norm(v_normalized))\n```", "```py\nOriginal v: [3 4]\nNormalized v: [0.6 0.8]\nLength of normalized v: 1.0\n```", "```py\nu1 = np.array([1, 0])\nu2 = np.array([0, 1])\n\nprint(\"u1 length:\", np.linalg.norm(u1))\nprint(\"u2 length:\", np.linalg.norm(u2))\nprint(\"u1 · u2 =\", np.dot(u1,u2))\n```", "```py\nu1 length: 1.0\nu2 length: 1.0\nu1 · u2 = 0\n```", "```py\nplt.quiver(0,0,u1[0],u1[1],angles='xy',scale_units='xy',scale=1,color='r')\nplt.quiver(0,0,u2[0],u2[1],angles='xy',scale_units='xy',scale=1,color='b')\n\nplt.xlim(-1.5,1.5)\nplt.ylim(-1.5,1.5)\nplt.axhline(0,color='black',linewidth=0.5)\nplt.axvline(0,color='black',linewidth=0.5)\nplt.grid()\nplt.show()\n```", "```py\ni = np.array([1,0,0])\nj = np.array([0,1,0])\nk = np.array([0,0,1])\n\nprint(\"‖i‖ =\", np.linalg.norm(i))\nprint(\"‖j‖ =\", np.linalg.norm(j))\nprint(\"‖k‖ =\", np.linalg.norm(k))\nprint(\"i·j =\", np.dot(i,j))\nprint(\"j·k =\", np.dot(j,k))\nprint(\"i·k =\", np.dot(i,k))\n```", "```py\n‖i‖ = 1.0\n‖j‖ = 1.0\n‖k‖ = 1.0\ni·j = 0\nj·k = 0\ni·k = 0\n```", "```py\ndef is_orthonormal(vectors):\n for i in range(len(vectors)):\n for j in range(len(vectors)):\n dot = np.dot(vectors[i], vectors[j])\n if i == j:\n if not np.isclose(dot, 1): return False\n else:\n if not np.isclose(dot, 0): return False\n return True\n\nprint(is_orthonormal([i, j, k]))  # True\n```", "```py\nTrue\n```", "```py\nu1 = np.array([1,1]) / np.sqrt(2)\nu2 = np.array([-1,1]) / np.sqrt(2)\n\nprint(\"u1·u2 =\", np.dot(u1,u2))\nprint(\"‖u1‖ =\", np.linalg.norm(u1))\nprint(\"‖u2‖ =\", np.linalg.norm(u2))\n```", "```py\nu1·u2 = 0.0\n‖u1‖ = 0.9999999999999999\n‖u2‖ = 0.9999999999999999\n```", "```py\nimport numpy as np\n```", "```py\nA = np.array([\n [1, 2, 3],\n [4, 5, 6]\n])\n\nprint(\"Matrix A:\\n\", A)\nprint(\"Shape of A:\", A.shape)\n```", "```py\nMatrix A:\n [[1 2 3]\n [4 5 6]]\nShape of A: (2, 3)\n```", "```py\nfirst_row = A[0]        # row 0\nsecond_column = A[:,1]  # column 1\n\nprint(\"First row:\", first_row)\nprint(\"Second column:\", second_column)\n```", "```py\nFirst row: [1 2 3]\nSecond column: [2 5]\n```", "```py\nx = np.array([1, 0, -1])  # a 3D vector\nresult = A.dot(x)\n\nprint(\"A·x =\", result)\n```", "```py\nA·x = [-2 -2]\n```", "```py\ncol1 = A[:,0]\ncol2 = A[:,1]\ncol3 = A[:,2]\n\nmanual = 1*col1 + 0*col2 + (-1)*col3\nprint(\"Manual combination:\", manual)\nprint(\"A·x result:\", result)\n```", "```py\nManual combination: [-2 -2]\nA·x result: [-2 -2]\n```", "```py\nB = np.array([\n [2, 0],\n [0, 1]\n])\n\nv = np.array([1,2])\nprint(\"B·v =\", B.dot(v))\n```", "```py\nB·v = [2 2]\n```", "```py\nimport numpy as np\n```", "```py\nA = np.array([\n [1, 2, 3],\n [4, 5, 6],\n [7, 8, 9]\n])\n\nprint(\"Matrix A:\\n\", A)\nprint(\"Shape of A:\", A.shape)\n```", "```py\nMatrix A:\n [[1 2 3]\n [4 5 6]\n [7 8 9]]\nShape of A: (3, 3)\n```", "```py\nprint(\"A[0,0] =\", A[0,0])  # top-left element\nprint(\"A[1,2] =\", A[1,2])  # second row, third column\n```", "```py\nA[0,0] = 1\nA[1,2] = 6\n```", "```py\nrow1 = A[0]       # first row\ncol2 = A[:,1]     # second column\n\nprint(\"First row:\", row1)\nprint(\"Second column:\", col2)\n```", "```py\nFirst row: [1 2 3]\nSecond column: [2 5 8]\n```", "```py\nblock = A[0:2, 1:3]  # rows 0–1, columns 1–2\nprint(\"Block submatrix:\\n\", block)\n```", "```py\nBlock submatrix:\n [[2 3]\n [5 6]]\n```", "```py\nA[0,0] = 99\nprint(\"Modified A:\\n\", A)\n\nA[1,:] = [10, 11, 12]   # replace row 1\nprint(\"After replacing row 1:\\n\", A)\n```", "```py\nModified A:\n [[99  2  3]\n [ 4  5  6]\n [ 7  8  9]]\nAfter replacing row 1:\n [[99  2  3]\n [10 11 12]\n [ 7  8  9]]\n```", "```py\nB = np.array([\n [1, 2],\n [3, 4],\n [5, 6]\n])\n\nprint(\"Matrix B:\\n\", B)\nprint(\"Shape of B:\", B.shape)\n```", "```py\nMatrix B:\n [[1 2]\n [3 4]\n [5 6]]\nShape of B: (3, 2)\n```", "```py\nC = np.array([\n [1,2,3,4],\n [5,6,7,8],\n [9,10,11,12],\n [13,14,15,16]\n])\n\ntop_left = C[0:2, 0:2]\nbottom_right = C[2:4, 2:4]\n\nprint(\"Top-left block:\\n\", top_left)\nprint(\"Bottom-right block:\\n\", bottom_right)\n```", "```py\nTop-left block:\n [[1 2]\n [5 6]]\nBottom-right block:\n [[11 12]\n [15 16]]\n```", "```py\nimport numpy as np\n```", "```py\nA = np.array([\n [1, 2],\n [3, 4]\n])\n\nB = np.array([\n [5, 6],\n [7, 8]\n])\n\nC = A + B\nprint(\"A + B =\\n\", C)\n```", "```py\nA + B =\n [[ 6  8]\n [10 12]]\n```", "```py\nk = 3\nD = k * A\nprint(\"3 * A =\\n\", D)\n```", "```py\n3 * A =\n [[ 3  6]\n [ 9 12]]\n```", "```py\ncombo = 2*A - B\nprint(\"2A - B =\\n\", combo)\n```", "```py\n2A - B =\n [[-3 -2]\n [-1  0]]\n```", "```py\nzero = np.zeros((2,2))\nprint(\"Zero matrix:\\n\", zero)\nprint(\"A + Zero =\\n\", A + zero)\n```", "```py\nZero matrix:\n [[0\\. 0.]\n [0\\. 0.]]\nA + Zero =\n [[1\\. 2.]\n [3\\. 4.]]\n```", "```py\nX = np.array([\n [1,2,3],\n [4,5,6]\n])\n\ntry:\n print(A + X)\nexcept ValueError as e:\n print(\"Error:\", e)\n```", "```py\nError: operands could not be broadcast together with shapes (2,2) (2,3) \n```", "```py\nimport numpy as np\n```", "```py\nA = np.array([\n [1, 2],\n [3, 4],\n [5, 6]\n])  # 3×2 matrix\n\nx = np.array([2, -1])  # 2D vector\n```", "```py\ny = A.dot(x)\nprint(\"A·x =\", y)\n```", "```py\nA·x = [0 2 4]\n```", "```py\ncol1 = A[:,0]   # first column\ncol2 = A[:,1]   # second column\n\nmanual = 2*col1 + (-1)*col2\nprint(\"Manual linear combination:\", manual)\n```", "```py\nManual linear combination: [0 2 4]\n```", "```py\nB = np.array([\n [2, 0],\n [0, 1]\n])  # stretches x-axis by 2\n\nv = np.array([1, 3])\nprint(\"B·v =\", B.dot(v))\n```", "```py\nB·v = [2 3]\n```", "```py\nimport matplotlib.pyplot as plt\n\n# draw original vector\nplt.quiver(0,0,v[0],v[1],angles='xy',scale_units='xy',scale=1,color='r',label='v')\n\n# draw transformed vector\nv_transformed = B.dot(v)\nplt.quiver(0,0,v_transformed[0],v_transformed[1],angles='xy',scale_units='xy',scale=1,color='b',label='B·v')\n\nplt.xlim(-1,4)\nplt.ylim(-1,4)\nplt.axhline(0,color='black',linewidth=0.5)\nplt.axvline(0,color='black',linewidth=0.5)\nplt.grid()\nplt.show()\n```", "```py\nimport numpy as np\n```", "```py\nA = np.array([\n [1, 2],\n [3, 4]\n])  # 2×2\n\nB = np.array([\n [2, 0],\n [1, 2]\n])  # 2×2\n\nC = A.dot(B)   # or A @ B\nprint(\"A·B =\\n\", C)\n```", "```py\nA·B =\n [[ 4  4]\n [10  8]]\n```", "```py\nc11 = A[0,:].dot(B[:,0])\nc12 = A[0,:].dot(B[:,1])\nc21 = A[1,:].dot(B[:,0])\nc22 = A[1,:].dot(B[:,1])\n\nprint(\"Manual C =\\n\", np.array([[c11,c12],[c21,c22]]))\n```", "```py\nManual C =\n [[ 4  4]\n [10  8]]\n```", "```py\nv = np.array([1,1])\n\nprint(\"First apply B:\", B.dot(v))\nprint(\"Then apply A:\", A.dot(B.dot(v)))\nprint(\"Directly with C:\", C.dot(v))\n```", "```py\nFirst apply B: [2 3]\nThen apply A: [ 8 18]\nDirectly with C: [ 8 18]\n```", "```py\nM = np.array([\n [1, 0, 2],\n [0, 1, 3]\n])  # 2×3\n\nN = np.array([\n [1, 2],\n [0, 1],\n [4, 0]\n])  # 3×2\n\nP = M.dot(N)  # result is 2×2\nprint(\"M·N =\\n\", P)\n```", "```py\nM·N =\n [[ 9  2]\n [12  1]]\n```", "```py\nA = np.array([[1,2],[3,4]])\nB = np.array([[0,1],[1,0]])\n\nprint(\"A·B =\\n\", A.dot(B))\nprint(\"B·A =\\n\", B.dot(A))\n```", "```py\nA·B =\n [[2 1]\n [4 3]]\nB·A =\n [[3 4]\n [1 2]]\n```", "```py\nimport numpy as np\n```", "```py\nI = np.eye(3)  # 3×3 identity matrix\nprint(\"Identity matrix:\\n\", I)\n\nA = np.array([\n [2, 1, 0],\n [0, 1, 3],\n [4, 0, 1]\n])\n\nprint(\"A·I =\\n\", A.dot(I))\nprint(\"I·A =\\n\", I.dot(A))\n```", "```py\nIdentity matrix:\n [[1\\. 0\\. 0.]\n [0\\. 1\\. 0.]\n [0\\. 0\\. 1.]]\nA·I =\n [[2\\. 1\\. 0.]\n [0\\. 1\\. 3.]\n [4\\. 0\\. 1.]]\nI·A =\n [[2\\. 1\\. 0.]\n [0\\. 1\\. 3.]\n [4\\. 0\\. 1.]]\n```", "```py\nB = np.array([\n [1, 2, 3],\n [4, 5, 6]\n])\n\nprint(\"B:\\n\", B)\nprint(\"B.T:\\n\", B.T)\n```", "```py\nB:\n [[1 2 3]\n [4 5 6]]\nB.T:\n [[1 4]\n [2 5]\n [3 6]]\n```", "```py\nC = np.array([\n [2, 1],\n [5, 3]\n])\n\nC_inv = np.linalg.inv(C)\nprint(\"Inverse of C:\\n\", C_inv)\n\nprint(\"C·C_inv =\\n\", C.dot(C_inv))\nprint(\"C_inv·C =\\n\", C_inv.dot(C))\n```", "```py\nInverse of C:\n [[ 3\\. -1.]\n [-5\\.  2.]]\nC·C_inv =\n [[ 1.00000000e+00  2.22044605e-16]\n [-8.88178420e-16  1.00000000e+00]]\nC_inv·C =\n [[1.00000000e+00 3.33066907e-16]\n [0.00000000e+00 1.00000000e+00]]\n```", "```py\nD = np.array([\n [1, 2],\n [2, 4]\n])\n\ntry:\n np.linalg.inv(D)\nexcept np.linalg.LinAlgError as e:\n print(\"Error:\", e)\n```", "```py\nError: Singular matrix\n```", "```py\nA = np.array([\n [1, 2],\n [3, 5]\n])\n\nlhs = np.linalg.inv(A.T)\nrhs = np.linalg.inv(A).T\n\nprint(\"Do they match?\", np.allclose(lhs, rhs))\n```", "```py\nDo they match? True\n```", "```py\nimport numpy as np\n```", "```py\nA = np.array([\n [2, 3, 4],\n [3, 5, 6],\n [4, 6, 8]\n])\n\nprint(\"A:\\n\", A)\nprint(\"A.T:\\n\", A.T)\nprint(\"Is symmetric?\", np.allclose(A, A.T))\n```", "```py\nA:\n [[2 3 4]\n [3 5 6]\n [4 6 8]]\nA.T:\n [[2 3 4]\n [3 5 6]\n [4 6 8]]\nIs symmetric? True\n```", "```py\nD = np.diag([1, 5, 9])\nprint(\"Diagonal matrix:\\n\", D)\n\nx = np.array([2, 3, 4])\nprint(\"D·x =\", D.dot(x))  # scales each component\n```", "```py\nDiagonal matrix:\n [[1 0 0]\n [0 5 0]\n [0 0 9]]\nD·x = [ 2 15 36]\n```", "```py\nU = np.array([\n [1, 2, 3],\n [0, 4, 5],\n [0, 0, 6]\n])\n\nL = np.array([\n [7, 0, 0],\n [8, 9, 0],\n [1, 2, 3]\n])\n\nprint(\"Upper triangular U:\\n\", U)\nprint(\"Lower triangular L:\\n\", L)\n```", "```py\nUpper triangular U:\n [[1 2 3]\n [0 4 5]\n [0 0 6]]\nLower triangular L:\n [[7 0 0]\n [8 9 0]\n [1 2 3]]\n```", "```py\nP = np.array([\n [0, 1, 0],\n [0, 0, 1],\n [1, 0, 0]\n])\n\nprint(\"Permutation matrix P:\\n\", P)\n\nv = np.array([10, 20, 30])\nprint(\"P·v =\", P.dot(v))\n```", "```py\nPermutation matrix P:\n [[0 1 0]\n [0 0 1]\n [1 0 0]]\nP·v = [20 30 10]\n```", "```py\ndef is_symmetric(M): return np.allclose(M, M.T)\ndef is_diagonal(M): return np.count_nonzero(M - np.diag(np.diag(M))) == 0\ndef is_upper_triangular(M): return np.allclose(M, np.triu(M))\ndef is_lower_triangular(M): return np.allclose(M, np.tril(M))\n\nprint(\"A symmetric?\", is_symmetric(A))\nprint(\"D diagonal?\", is_diagonal(D))\nprint(\"U upper triangular?\", is_upper_triangular(U))\nprint(\"L lower triangular?\", is_lower_triangular(L))\n```", "```py\nA symmetric? True\nD diagonal? True\nU upper triangular? True\nL lower triangular? True\n```", "```py\nimport numpy as np\n```", "```py\nA = np.array([\n [2, 1, 3],\n [0, 4, 5],\n [7, 8, 6]\n])\n\ntrace_A = np.trace(A)\nprint(\"Matrix A:\\n\", A)\nprint(\"Trace of A =\", trace_A)\n```", "```py\nMatrix A:\n [[2 1 3]\n [0 4 5]\n [7 8 6]]\nTrace of A = 12\n```", "```py\nB = np.array([\n [1, 0, 0],\n [0, 2, 0],\n [0, 0, 3]\n])\n\nprint(\"tr(A+B) =\", np.trace(A+B))\nprint(\"tr(A) + tr(B) =\", np.trace(A) + np.trace(B))\n\nprint(\"tr(3A) =\", np.trace(3*A))\nprint(\"3 * tr(A) =\", 3*np.trace(A))\n```", "```py\ntr(A+B) = 18\ntr(A) + tr(B) = 18\ntr(3A) = 36\n3 * tr(A) = 36\n```", "```py\nC = np.array([\n [0,1],\n [2,3]\n])\n\nD = np.array([\n [4,5],\n [6,7]\n])\n\nprint(\"tr(CD) =\", np.trace(C.dot(D)))\nprint(\"tr(DC) =\", np.trace(D.dot(C)))\n```", "```py\ntr(CD) = 37\ntr(DC) = 37\n```", "```py\nvals, vecs = np.linalg.eig(A)\nprint(\"Eigenvalues:\", vals)\nprint(\"Sum of eigenvalues =\", np.sum(vals))\nprint(\"Trace =\", np.trace(A))\n```", "```py\nEigenvalues: [12.83286783  2.13019807 -2.9630659 ]\nSum of eigenvalues = 12.000000000000007\nTrace = 12\n```", "```py\nprint(\"tr(A) =\", np.trace(A))\nprint(\"tr(A.T) =\", np.trace(A.T))\n```", "```py\ntr(A) = 12\ntr(A.T) = 12\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n```", "```py\nT = np.array([\n [1, 0, 2],\n [0, 1, 3],\n [0, 0, 1]\n])\n\np = np.array([1, 1, 1])  # point at (1,1)\np_translated = T.dot(p)\n\nprint(\"Original point:\", p)\nprint(\"Translated point:\", p_translated)\n```", "```py\nOriginal point: [1 1 1]\nTranslated point: [3 4 1]\n```", "```py\nR = np.array([\n [0, -1, 0],\n [1,  0, 0],\n [0,  0, 1]\n])\n\nM = T.dot(R)  # rotate then translate\nprint(\"Combined transform:\\n\", M)\n\np = np.array([1, 0, 1])\nprint(\"Rotated + translated point:\", M.dot(p))\n```", "```py\nCombined transform:\n [[ 0 -1  2]\n [ 1  0  3]\n [ 0  0  1]]\nRotated + translated point: [2 4 1]\n```", "```py\npoints = np.array([\n [0,0,1],\n [1,0,1],\n [1,1,1],\n [0,1,1]\n])  # a unit square\n\ntransformed = points.dot(T.T)\n\nplt.scatter(points[:,0], points[:,1], color='r', label='original')\nplt.scatter(transformed[:,0], transformed[:,1], color='b', label='translated')\n\nfor i in range(len(points)):\n plt.arrow(points[i,0], points[i,1],\n transformed[i,0]-points[i,0],\n transformed[i,1]-points[i,1],\n head_width=0.05, color='gray')\n\nplt.legend()\nplt.axis('equal')\nplt.grid()\nplt.show()\n```", "```py\nT3 = np.array([\n [1,0,0,5],\n [0,1,0,-2],\n [0,0,1,3],\n [0,0,0,1]\n])\n\np3 = np.array([1,2,3,1])\nprint(\"Translated 3D point:\", T3.dot(p3))\n```", "```py\nTranslated 3D point: [6 0 6 1]\n```", "```py\nimport numpy as np\nimport time\n```", "```py\nm, n = 3, 4\nA = np.random.randint(1,10,(m,n))\nx = np.random.randint(1,10,n)\n\nprint(\"Matrix A:\\n\", A)\nprint(\"Vector x:\", x)\nprint(\"A·x =\", A.dot(x))\n```", "```py\nMatrix A:\n [[6 6 6 2]\n [1 1 1 1]\n [1 8 7 4]]\nVector x: [6 5 4 5]\nA·x = [100  20  94]\n```", "```py\nm, n, p = 3, 4, 2\nA = np.random.randint(1,10,(m,n))\nB = np.random.randint(1,10,(n,p))\n\nC = A.dot(B)\nprint(\"A·B =\\n\", C)\n```", "```py\nA·B =\n [[ 59  92]\n [ 43  81]\n [ 65 102]]\n```", "```py\nn = 50\nA = np.random.randn(n,n)\nB = np.random.randn(n,n)\n\n# Vectorized\nstart = time.time()\nC1 = A.dot(B)\nend = time.time()\nprint(\"Vectorized dot:\", round(end-start,3), \"seconds\")\n\n# Manual loops\nC2 = np.zeros((n,n))\nstart = time.time()\nfor i in range(n):\n for j in range(n):\n for k in range(n):\n C2[i,j] += A[i,k]*B[k,j]\nend = time.time()\nprint(\"Triple loop:\", round(end-start,3), \"seconds\")\n```", "```py\nVectorized dot: 0.0 seconds\nTriple loop: 0.026 seconds\n```", "```py\nA = np.array([\n [1,2,3],\n [4,5,6]\n])\n\n# Add 10 to every entry\nprint(\"A+10 =\\n\", A+10)\n\n# Multiply each row by a different scalar\nscales = np.array([1,10])[:,None]\nprint(\"Row-scaled A =\\n\", A*scales)\n```", "```py\nA+10 =\n [[11 12 13]\n [14 15 16]]\nRow-scaled A =\n [[ 1  2  3]\n [40 50 60]]\n```", "```py\nA = np.random.randn(1000,1000).astype(np.float32)  # 32-bit floats\nB = np.random.randn(1000,1000).astype(np.float32)\n\nstart = time.time()\nC = A.dot(B)\nprint(\"Result shape:\", C.shape, \"dtype:\", C.dtype)\nprint(\"Time:\", round(time.time()-start,3), \"seconds\")\n```", "```py\nResult shape: (1000, 1000) dtype: float32\nTime: 0.002 seconds\n```", "```py\nimport numpy as np\n```", "```py\nA = np.array([\n [2, 1],\n [-3, 4]\n])\n\nb = np.array([8, -11])\n\nprint(\"Coefficient matrix A:\\n\", A)\nprint(\"Constants vector b:\", b)\n```", "```py\nCoefficient matrix A:\n [[ 2  1]\n [-3  4]]\nConstants vector b: [  8 -11]\n```", "```py\naugmented = np.column_stack((A, b))\nprint(\"Augmented matrix:\\n\", augmented)\n```", "```py\nAugmented matrix:\n [[  2   1   8]\n [ -3   4 -11]]\n```", "```py\nsolution = np.linalg.solve(A, b)\nprint(\"Solution (x,y):\", solution)\n```", "```py\nSolution (x,y): [3.90909091 0.18181818]\n```", "```py\ncheck = A.dot(solution)\nprint(\"A·x =\", check, \"should equal b =\", b)\n```", "```py\nA·x = [  8\\. -11.] should equal b = [  8 -11]\n```", "```py\nA = np.array([\n [1, 1, 1],\n [2, -1, 1],\n [-1, 2, -1]\n])\n\nb = np.array([6, 3, 2])\n\nprint(\"Augmented matrix:\\n\", np.column_stack((A, b)))\nprint(\"Solution:\", np.linalg.solve(A, b))\n```", "```py\nAugmented matrix:\n [[ 1  1  1  6]\n [ 2 -1  1  3]\n [-1  2 -1  2]]\nSolution: [2.33333333 2.66666667 1\\.        ]\n```", "```py\nimport numpy as np\n```", "```py\nA = np.array([\n [1, 2, 5],\n [3, 4, 6]\n], dtype=float)\n\nprint(\"Initial augmented matrix:\\n\", A)\n```", "```py\nInitial augmented matrix:\n [[1\\. 2\\. 5.]\n [3\\. 4\\. 6.]]\n```", "```py\nA[[0,1]] = A[[1,0]]\nprint(\"After swapping rows:\\n\", A)\n```", "```py\nAfter swapping rows:\n [[3\\. 4\\. 6.]\n [1\\. 2\\. 5.]]\n```", "```py\nA[0] = A[0] / A[0,0]\nprint(\"After scaling first row:\\n\", A)\n```", "```py\nAfter scaling first row:\n [[1\\.         1.33333333 2\\.        ]\n [1\\.         2\\.         5\\.        ]]\n```", "```py\nA[1] = A[1] - 3*A[0]\nprint(\"After eliminating x from second row:\\n\", A)\n```", "```py\nAfter eliminating x from second row:\n [[ 1\\.          1.33333333  2\\.        ]\n [-2\\.         -2\\.         -1\\.        ]]\n```", "```py\ny = A[1,2] / A[1,1]\nx = (A[0,2] - A[0,1]*y) / A[0,0]\nprint(\"Solution: x =\", x, \", y =\", y)\n```", "```py\nSolution: x = 1.3333333333333335 , y = 0.5\n```", "```py\ncoeff = np.array([[1,2],[3,4]])\nconst = np.array([5,6])\nprint(\"np.linalg.solve result:\", np.linalg.solve(coeff,const))\n```", "```py\nnp.linalg.solve result: [-4\\.   4.5]\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nA = np.array([\n [1, 2, 1, 7],\n [2, 4, 1, 12],\n [3, 6, 2, 17]\n], dtype=float)\n\nprint(\"Augmented matrix:\\n\", A)\n```", "```py\nAugmented matrix:\n [[ 1\\.  2\\.  1\\.  7.]\n [ 2\\.  4\\.  1\\. 12.]\n [ 3\\.  6\\.  2\\. 17.]]\n```", "```py\n# eliminate first column entries below pivot\nA[1] = A[1] - 2*A[0]\nA[2] = A[2] - 3*A[0]\nprint(\"After eliminating first column:\\n\", A)\n```", "```py\nAfter eliminating first column:\n [[ 1\\.  2\\.  1\\.  7.]\n [ 0\\.  0\\. -1\\. -2.]\n [ 0\\.  0\\. -1\\. -4.]]\n```", "```py\nM = Matrix([\n [1, 2, 1, 7],\n [2, 4, 1, 12],\n [3, 6, 2, 17]\n])\n\nM_rref = M.rref()\nprint(\"RREF form:\\n\", M_rref[0])\n```", "```py\nRREF form:\n Matrix([[1, 2, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]])\n```", "```py\nM2 = Matrix([\n [1,1,1,3],\n [2,1,-1,0]\n])\n\nM2_rref = M2.rref()\nprint(\"RREF form:\\n\", M2_rref[0])\n```", "```py\nRREF form:\n Matrix([[1, 0, -2, -3], [0, 1, 3, 6]])\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nM = Matrix([\n [1,1,1,6],\n [2,3,1,10]\n])\n\nM_rref = M.rref()\nprint(\"RREF form:\\n\", M_rref[0])\n```", "```py\nRREF form:\n Matrix([[1, 0, 2, 8], [0, 1, -1, -2]])\n```", "```py\nrref_matrix, pivots = M_rref\nprint(\"Pivot columns:\", pivots)\n\n# free variables are the columns not in pivots\nall_vars = set(range(rref_matrix.shape[1]-1))  # exclude last column (constants)\nfree_vars = all_vars - set(pivots)\nprint(\"Free variable indices:\", free_vars)\n```", "```py\nPivot columns: (0, 1)\nFree variable indices: {2}\n```", "```py\nM2 = Matrix([\n [1,2,3,4],\n [2,4,6,8]\n])\n\nM2_rref = M2.rref()\nprint(\"RREF form:\\n\", M2_rref[0])\n```", "```py\nRREF form:\n Matrix([[1, 2, 3, 4], [0, 0, 0, 0]])\n```", "```py\nM3 = Matrix([[1,1,3]])\nprint(\"RREF form:\\n\", M3.rref()[0])\n```", "```py\nRREF form:\n Matrix([[1, 1, 3]])\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nfrom sympy import Matrix\n\nM = Matrix([\n [1, 1, 3],\n [2, -1, 0]\n])\n\nM_rref = M.rref()\nprint(\"RREF form:\\n\", M_rref[0])\n\n# Split into coefficient matrix A and right-hand side b\nA = M[:, :2]\nb = M[:, 2]\n\nsolution = A.solve_least_squares(b)\nprint(\"Solution:\", solution)\n```", "```py\nRREF form:\n Matrix([[1, 0, 1], [0, 1, 2]])\nSolution: Matrix([[1], [2]])\n```", "```py\nM2 = Matrix([\n [1, 1, 1, 2],\n [2, 2, 2, 4]\n])\n\nM2_rref = M2.rref()\nprint(\"RREF form:\\n\", M2_rref[0])\n```", "```py\nRREF form:\n Matrix([[1, 1, 1, 2], [0, 0, 0, 0]])\n```", "```py\nM3 = Matrix([\n [1, 2, 3],\n [0, 1, 4]\n])\nprint(\"RREF:\\n\", M3.rref()[0])\n```", "```py\nRREF:\n Matrix([[1, 0, -5], [0, 1, 4]])\n```", "```py\nM4 = Matrix([\n [1, 1, 2],\n [2, 2, 5]\n])\nprint(\"RREF:\\n\", M4.rref()[0])\n```", "```py\nRREF:\n Matrix([[1, 1, 0], [0, 0, 1]])\n```", "```py\nA = np.array([[1,1],[2,-1]], dtype=float)\nb = np.array([3,0], dtype=float)\nprint(\"Unique solution with np.linalg.solve:\", np.linalg.solve(A,b))\n```", "```py\nUnique solution with np.linalg.solve: [1\\. 2.]\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nM = Matrix([\n [1, 1, 2],\n [2, 2, 5]\n])\n\nM_rref = M.rref()\nprint(\"RREF:\\n\", M_rref[0])\n```", "```py\nRREF:\n Matrix([[1, 1, 0], [0, 0, 1]])\n```", "```py\nM2 = Matrix([\n [1, 1, 2],\n [2, 2, 4]\n])\n\nprint(\"RREF:\\n\", M2.rref()[0])\n```", "```py\nRREF:\n Matrix([[1, 1, 2], [0, 0, 0]])\n```", "```py\nimport matplotlib.pyplot as plt\n\nx_vals = np.linspace(-1, 3, 100)\ny1 = 2 - x_vals\ny2 = 3 - x_vals\n\nplt.plot(x_vals, y1, label=\"x+y=2\")\nplt.plot(x_vals, y2, label=\"x+y=3\")\n\nplt.legend()\nplt.axhline(0,color='black',linewidth=0.5)\nplt.axvline(0,color='black',linewidth=0.5)\nplt.grid()\nplt.show()\n```", "```py\ndef is_inconsistent(M):\n rref_matrix, _ = M.rref()\n for row in rref_matrix.tolist():\n if all(v == 0 for v in row[:-1]) and row[-1] != 0:\n return True\n return False\n\nprint(\"System 1 inconsistent?\", is_inconsistent(M))\nprint(\"System 2 inconsistent?\", is_inconsistent(M2))\n```", "```py\nSystem 1 inconsistent? True\nSystem 2 inconsistent? False\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nA = np.array([\n [1, 1, 1, 6],\n [2, 3, 1, 14],\n [1, 2, 3, 14]\n], dtype=float)\n\nprint(\"Initial augmented matrix:\\n\", A)\n```", "```py\nInitial augmented matrix:\n [[ 1\\.  1\\.  1\\.  6.]\n [ 2\\.  3\\.  1\\. 14.]\n [ 1\\.  2\\.  3\\. 14.]]\n```", "```py\nA[1] = A[1] - 2*A[0]   # Row2 → Row2 - 2*Row1\nA[2] = A[2] - A[0]     # Row3 → Row3 - Row1\nprint(\"After eliminating first column:\\n\", A)\n```", "```py\nAfter eliminating first column:\n [[ 1\\.  1\\.  1\\.  6.]\n [ 0\\.  1\\. -1\\.  2.]\n [ 0\\.  1\\.  2\\.  8.]]\n```", "```py\nA[1] = A[1] / A[1,1]\nprint(\"After scaling second row:\\n\", A)\n```", "```py\nAfter scaling second row:\n [[ 1\\.  1\\.  1\\.  6.]\n [ 0\\.  1\\. -1\\.  2.]\n [ 0\\.  1\\.  2\\.  8.]]\n```", "```py\nA[2] = A[2] - A[2,1]*A[1]\nprint(\"After eliminating second column:\\n\", A)\n```", "```py\nAfter eliminating second column:\n [[ 1\\.  1\\.  1\\.  6.]\n [ 0\\.  1\\. -1\\.  2.]\n [ 0\\.  0\\.  3\\.  6.]]\n```", "```py\nA[2] = A[2] / A[2,2]\nprint(\"After scaling third row:\\n\", A)\n```", "```py\nAfter scaling third row:\n [[ 1\\.  1\\.  1\\.  6.]\n [ 0\\.  1\\. -1\\.  2.]\n [ 0\\.  0\\.  1\\.  2.]]\n```", "```py\nz = A[2,3]\ny = A[1,3] - A[1,2]*z\nx = A[0,3] - A[0,1]*y - A[0,2]*z\n\nprint(f\"Solution: x={x}, y={y}, z={z}\")\n```", "```py\nSolution: x=0.0, y=4.0, z=2.0\n```", "```py\ncoeff = np.array([\n [1,1,1],\n [2,3,1],\n [1,2,3]\n], dtype=float)\nconst = np.array([6,14,14], dtype=float)\n\nprint(\"Check with np.linalg.solve:\", np.linalg.solve(coeff,const))\n```", "```py\nCheck with np.linalg.solve: [0\\. 4\\. 2.]\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nz = 3\ny = (-4 - 5*z)/2\nx = 6 - y - z\nprint(f\"Solution: x={x}, y={y}, z={z}\")\n```", "```py\nSolution: x=12.5, y=-9.5, z=3\n```", "```py\nfrom sympy import symbols\ns, t = symbols('s t')\nx = 2 - s - t\ny = s\nz = t\nprint(\"General solution:\")\nprint(\"x =\", x, \", y =\", y, \", z =\", z)\n```", "```py\nGeneral solution:\nx = -s - t + 2 , y = s , z = t\n```", "```py\nM = Matrix([\n [1,1,1,2],\n [2,2,2,4]\n])\n\nprint(\"RREF form:\\n\", M.rref()[0])\n```", "```py\nRREF form:\n Matrix([[1, 1, 1, 2], [0, 0, 0, 0]])\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nA = Matrix([\n [1, 2, 3],\n [2, 4, 6],\n [1, 1, 1]\n])\n\nprint(\"RREF:\\n\", A.rref()[0])\nprint(\"Rank of A:\", A.rank())\n```", "```py\nRREF:\n Matrix([[1, 0, -1], [0, 1, 2], [0, 0, 0]])\nRank of A: 2\n```", "```py\nM = Matrix([\n [1, 1, 1, 3],\n [2, 2, 2, 6],\n [1, -1, 0, 0]\n])\n\nprint(\"RREF:\\n\", M.rref()[0])\nprint(\"Rank of coefficient matrix:\", M[:, :-1].rank())\nprint(\"Rank of augmented matrix:\", M.rank())\n```", "```py\nRREF:\n Matrix([[1, 0, 1/2, 3/2], [0, 1, 1/2, 3/2], [0, 0, 0, 0]])\nRank of coefficient matrix: 2\nRank of augmented matrix: 2\n```", "```py\nA = np.array([\n [1, 2, 3],\n [2, 4, 6],\n [1, 1, 1]\n], dtype=float)\n\nprint(\"Rank with NumPy:\", np.linalg.matrix_rank(A))\n```", "```py\nRank with NumPy: 2\n```", "```py\nB = Matrix([\n [1,2],\n [2,4],\n [3,6]\n])\n\nprint(\"Rank of B:\", B.rank())\n```", "```py\nRank of B: 1\n```", "```py\nimport numpy as np\nfrom scipy.linalg import lu\n```", "```py\nA = np.array([\n [2, 3, 1],\n [4, 7, 7],\n [6, 18, 22]\n], dtype=float)\n\nprint(\"Matrix A:\\n\", A)\n```", "```py\nMatrix A:\n [[ 2\\.  3\\.  1.]\n [ 4\\.  7\\.  7.]\n [ 6\\. 18\\. 22.]]\n```", "```py\nP, L, U = lu(A)\n\nprint(\"Permutation matrix P:\\n\", P)\nprint(\"Lower triangular L:\\n\", L)\nprint(\"Upper triangular U:\\n\", U)\n```", "```py\nPermutation matrix P:\n [[0\\. 0\\. 1.]\n [0\\. 1\\. 0.]\n [1\\. 0\\. 0.]]\nLower triangular L:\n [[1\\.         0\\.         0\\.        ]\n [0.66666667 1\\.         0\\.        ]\n [0.33333333 0.6        1\\.        ]]\nUpper triangular U:\n [[ 6\\.         18\\.         22\\.        ]\n [ 0\\.         -5\\.         -7.66666667]\n [ 0\\.          0\\.         -1.73333333]]\n```", "```py\nreconstructed = P @ L @ U\nprint(\"Does P·L·U equal A?\\n\", np.allclose(reconstructed, A))\n```", "```py\nDoes P·L·U equal A?\n True\n```", "```py\nb = np.array([1, 2, 3], dtype=float)\n\n# Step 1: Pb\nPb = P @ b\n\n# Step 2: forward substitution Ly = Pb\ny = np.linalg.solve(L, Pb)\n\n# Step 3: back substitution Ux = y\nx = np.linalg.solve(U, y)\n\nprint(\"Solution x:\", x)\n```", "```py\nSolution x: [ 0.5 -0\\.  -0\\. ]\n```", "```py\nimport numpy as np\n```", "```py\nu = np.array([1, 2])\nv = np.array([3, -1])\n\n# Closure under addition\nprint(\"u + v =\", u + v)\n\n# Closure under scalar multiplication\nk = 5\nprint(\"k * u =\", k * u)\n```", "```py\nu + v = [4 1]\nk * u = [ 5 10]\n```", "```py\nzero = np.array([0, 0])\ninverse_u = -u\nprint(\"Zero vector:\", zero)\nprint(\"u + (-u) =\", u + inverse_u)\n```", "```py\nZero vector: [0 0]\nu + (-u) = [0 0]\n```", "```py\na, b = 2, 3\n\nlhs1 = a * (u + v)\nrhs1 = a*u + a*v\nprint(\"a(u+v) =\", lhs1, \", au+av =\", rhs1)\n\nlhs2 = (a+b) * u\nrhs2 = a*u + b*u\nprint(\"(a+b)u =\", lhs2, \", au+bu =\", rhs2)\n```", "```py\na(u+v) = [8 2] , au+av = [8 2]\n(a+b)u = [ 5 10] , au+bu = [ 5 10]\n```", "```py\npositive_numbers = [1, 2, 3]\ntry:\n print(\"Closure under negatives?\", -1 * np.array(positive_numbers))\nexcept Exception as e:\n print(\"Error:\", e)\n```", "```py\nClosure under negatives? [-1 -2 -3]\n```", "```py\ndef check_closure(vectors, scalars):\n for v in vectors:\n for u in vectors:\n if not any(np.array_equal(v+u, w) for w in vectors):\n return False\n for k in scalars:\n if not any(np.array_equal(k*v, w) for w in vectors):\n return False\n return True\n\nvectors = [np.array([0,0]), np.array([1,0]), np.array([0,1]), np.array([1,1])]\nscalars = [0,1,-1]\nprint(\"Closed under addition and scalar multiplication?\", check_closure(vectors, scalars))\n```", "```py\nClosed under addition and scalar multiplication? False\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nA = Matrix([\n [1,2],\n [2,4],\n [3,6]\n])\n\nprint(\"Matrix A:\\n\", A)\nprint(\"Column space basis:\\n\", A.columnspace())\nprint(\"Rank (dimension of column space):\", A.rank())\n```", "```py\nMatrix A:\n Matrix([[1, 2], [2, 4], [3, 6]])\nColumn space basis:\n [Matrix([\n[1],\n[2],\n[3]])]\nRank (dimension of column space): 1\n```", "```py\nprint(\"Null space basis:\\n\", A.nullspace())\n```", "```py\nNull space basis:\n [Matrix([\n[-2],\n[ 1]])]\n```", "```py\nB = Matrix([\n [1,0,0],\n [0,1,0],\n [0,0,1]\n])\n\nprint(\"Column space basis:\\n\", B.columnspace())\nprint(\"Null space basis:\\n\", B.nullspace())\n```", "```py\nColumn space basis:\n [Matrix([\n[1],\n[0],\n[0]]), Matrix([\n[0],\n[1],\n[0]]), Matrix([\n[0],\n[0],\n[1]])]\nNull space basis:\n []\n```", "```py\nfrom numpy.linalg import svd\n\nA = np.array([[1,2],[2,4],[3,6]], dtype=float)\nU, S, Vt = svd(A)\n\ntol = 1e-10\nnull_mask = (S <= tol)\nnull_space = Vt.T[:, null_mask]\nprint(\"Null space (via SVD):\\n\", null_space)\n```", "```py\nNull space (via SVD):\n [[-0.89442719]\n [ 0.4472136 ]]\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\nimport matplotlib.pyplot as plt\n```", "```py\nu = np.array([1, 0])\nv = np.array([0, 1])\n\nM = Matrix.hstack(Matrix(u), Matrix(v))\nprint(\"Rank:\", M.rank())\n```", "```py\nRank: 2\n```", "```py\nu = np.array([1, 2])\nv = np.array([2, 4])\n\nM = Matrix.hstack(Matrix(u), Matrix(v))\nprint(\"Rank:\", M.rank())\n```", "```py\nRank: 1\n```", "```py\nu = np.array([1, 2])\nv = np.array([2, 1])\n\ncoeffs = np.linspace(-2, 2, 11)\npoints = []\nfor a in coeffs:\n for b in coeffs:\n points.append(a*u + b*v)\npoints = np.array(points)\n\nplt.scatter(points[:,0], points[:,1], s=10)\nplt.axhline(0,color='black',linewidth=0.5)\nplt.axvline(0,color='black',linewidth=0.5)\nplt.title(\"Span of {u,v}\")\nplt.grid()\nplt.show()\n```", "```py\nbasis = [Matrix([1,0,0]), Matrix([0,1,0]), Matrix([0,0,1])]\nM = Matrix.hstack(*basis)\nprint(\"Rank:\", M.rank())\n```", "```py\nRank: 3\n```", "```py\nu = Matrix([1,2])\nv = Matrix([2,1])\ntarget = Matrix([3,5])\n\nM = Matrix.hstack(u,v)\nsolution = M.gauss_jordan_solve(target)\nprint(\"Coefficients (a,b):\", solution)\n```", "```py\nCoefficients (a,b): (Matrix([\n[7/3],\n[1/3]]), Matrix(0, 1, []))\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nv1 = Matrix([1, 0, 0])\nv2 = Matrix([0, 1, 0])\nv3 = Matrix([0, 0, 1])\n\nM = Matrix.hstack(v1, v2, v3)\nprint(\"Rank:\", M.rank(), \" Number of vectors:\", M.shape[1])\n```", "```py\nRank: 3  Number of vectors: 3\n```", "```py\nv1 = Matrix([1, 2, 3])\nv2 = Matrix([2, 4, 6])\nv3 = Matrix([3, 6, 9])\n\nM = Matrix.hstack(v1, v2, v3)\nprint(\"Rank:\", M.rank(), \" Number of vectors:\", M.shape[1])\n```", "```py\nRank: 1  Number of vectors: 3\n```", "```py\ndef check_independence(vectors):\n M = Matrix.hstack(*vectors)\n return M.rank() == M.shape[1]\n\nprint(\"Independent?\", check_independence([Matrix([1,0]), Matrix([0,1])]))\nprint(\"Independent?\", check_independence([Matrix([1,2]), Matrix([2,4])]))\n```", "```py\nIndependent? True\nIndependent? False\n```", "```py\nM = Matrix.hstack(Matrix([1,2]), Matrix([2,4]))\nnull_space = M.nullspace()\nprint(\"Dependence relation (coefficients):\", null_space)\n```", "```py\nDependence relation (coefficients): [Matrix([\n[-2],\n[ 1]])]\n```", "```py\nnp.random.seed(0)\nR = Matrix(np.random.randint(-3, 4, (3,3)))\nprint(\"Random matrix:\\n\", R)\nprint(\"Rank:\", R.rank())\n```", "```py\nRandom matrix:\n Matrix([[1, 2, -3], [0, 0, 0], [-2, 0, 2]])\nRank: 2\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\ne1 = Matrix([1,0,0])\ne2 = Matrix([0,1,0])\ne3 = Matrix([0,0,1])\n\nM = Matrix.hstack(e1, e2, e3)\nprint(\"Rank:\", M.rank())\n```", "```py\nRank: 3\n```", "```py\nv1 = Matrix([1,2,3])\nv2 = Matrix([2,4,6])\nv3 = Matrix([1,0,1])\n\nM = Matrix.hstack(v1,v2,v3)\nprint(\"Column space basis:\", M.columnspace())\n```", "```py\nColumn space basis: [Matrix([\n[1],\n[2],\n[3]]), Matrix([\n[1],\n[0],\n[1]])]\n```", "```py\nB = Matrix.hstack(Matrix([1,0]), Matrix([1,1]))\ntarget = Matrix([3,5])\n\ncoords = B.solve_least_squares(target)\nprint(\"Coordinates in basis B:\", coords)\n```", "```py\nCoordinates in basis B: Matrix([[-2], [5]])\n```", "```py\nnew_basis = Matrix.hstack(Matrix([2,1]), Matrix([1,2]))\ncoords_new = new_basis.solve_least_squares(target)\nprint(\"Coordinates in new basis:\", coords_new)\n```", "```py\nCoordinates in new basis: Matrix([[1/3], [7/3]])\n```", "```py\nnp.random.seed(1)\nR = Matrix(np.random.randint(-3,4,(3,3)))\nprint(\"Random matrix:\\n\", R)\nprint(\"Rank:\", R.rank())\n```", "```py\nRandom matrix:\n Matrix([[2, 0, 1], [-3, -2, 0], [2, -3, -3]])\nRank: 3\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nn = 4\nbasis = [Matrix.eye(n)[:,i] for i in range(n)]\nprint(\"Basis for R^4:\", basis)\nprint(\"Dimension of R^4:\", len(basis))\n```", "```py\nBasis for R^4: [Matrix([\n[1],\n[0],\n[0],\n[0]]), Matrix([\n[0],\n[1],\n[0],\n[0]]), Matrix([\n[0],\n[0],\n[1],\n[0]]), Matrix([\n[0],\n[0],\n[0],\n[1]])]\nDimension of R^4: 4\n```", "```py\nA = Matrix([\n [1,2,3],\n [2,4,6],\n [1,0,1]\n])\n\nprint(\"Rank (dimension of column space):\", A.rank())\n```", "```py\nRank (dimension of column space): 2\n```", "```py\nprint(\"Null space basis:\", A.nullspace())\nprint(\"Dimension of null space:\", len(A.nullspace()))\n```", "```py\nNull space basis: [Matrix([\n[-1],\n[-1],\n[ 1]])]\nDimension of null space: 1\n```", "```py\nv1 = Matrix([1,2,3])\nv2 = Matrix([2,4,6])\nspan = Matrix.hstack(v1,v2)\nprint(\"Dimension of span:\", span.rank())\n```", "```py\nDimension of span: 1\n```", "```py\nnp.random.seed(2)\nR = Matrix(np.random.randint(-3,4,(4,4)))\nprint(\"Random 4x4 matrix:\\n\", R)\nprint(\"Column space dimension:\", R.rank())\n```", "```py\nRandom 4x4 matrix:\n Matrix([[-3, 2, -3, 3], [0, -1, 0, -3], [-1, -2, 0, 2], [-1, 1, 1, 1]])\nColumn space dimension: 4\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nA = Matrix([\n [1, 2, 3],\n [2, 4, 6],\n [1, 0, 1]\n])\n\nrank = A.rank()\nnullity = len(A.nullspace())\nprint(\"Rank:\", rank)\nprint(\"Nullity:\", nullity)\nprint(\"Rank + Nullity =\", rank + nullity)\nprint(\"Number of columns =\", A.shape[1])\n```", "```py\nRank: 2\nNullity: 1\nRank + Nullity = 3\nNumber of columns = 3\n```", "```py\nB = Matrix([\n [1,0,0],\n [0,1,0],\n [0,0,1]\n])\n\nprint(\"Rank:\", B.rank())\nprint(\"Nullity:\", len(B.nullspace()))\n```", "```py\nRank: 3\nNullity: 0\n```", "```py\nC = Matrix([\n [1,2,3,4],\n [0,1,1,2],\n [0,0,0,0]\n])\n\nrank = C.rank()\nnullity = len(C.nullspace())\nprint(\"Rank:\", rank, \" Nullity:\", nullity, \" Columns:\", C.shape[1])\n```", "```py\nRank: 2  Nullity: 2  Columns: 4\n```", "```py\nnp.random.seed(3)\nR = Matrix(np.random.randint(-3,4,(4,5)))\nprint(\"Random 4x5 matrix:\\n\", R)\nprint(\"Rank + Nullity =\", R.rank() + len(R.nullspace()))\nprint(\"Number of columns =\", R.shape[1])\n```", "```py\nRandom 4x5 matrix:\n Matrix([[-1, -3, -2, 0, -3], [-3, -3, 2, 2, 0], [-1, 0, -2, -2, -1], [2, 3, -3, 1, 1]])\nRank + Nullity = 5\nNumber of columns = 5\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nv = Matrix([4,5])\ne1 = Matrix([1,0])\ne2 = Matrix([0,1])\n\nB = Matrix.hstack(e1,e2)\ncoords = B.solve_least_squares(v)\nprint(\"Coordinates in standard basis:\", coords)\n```", "```py\nCoordinates in standard basis: Matrix([[4], [5]])\n```", "```py\nB2 = Matrix.hstack(Matrix([1,1]), Matrix([1,-1]))\ncoords2 = B2.solve_least_squares(v)\nprint(\"Coordinates in new basis:\", coords2)\n```", "```py\nCoordinates in new basis: Matrix([[9/2], [-1/2]])\n```", "```py\nreconstructed = B2 * coords2\nprint(\"Reconstructed vector:\", reconstructed)\n```", "```py\nReconstructed vector: Matrix([[4], [5]])\n```", "```py\nbasis = Matrix.hstack(\n Matrix([1,0,1]),\n Matrix([0,1,1]),\n Matrix([1,1,0])\n)\nv = Matrix([2,3,4])\n\ncoords = basis.solve_least_squares(v)\nprint(\"Coordinates of v in random basis:\", coords)\n```", "```py\nCoordinates of v in random basis: Matrix([[3/2], [5/2], [1/2]])\n```", "```py\nimport matplotlib.pyplot as plt\n\nv = np.array([4,5])\nb1 = np.array([1,1])\nb2 = np.array([1,-1])\n\nplt.quiver(0,0,v[0],v[1],angles='xy',scale_units='xy',scale=1,color='blue',label='v')\nplt.quiver(0,0,b1[0],b1[1],angles='xy',scale_units='xy',scale=1,color='red',label='basis1')\nplt.quiver(0,0,b2[0],b2[1],angles='xy',scale_units='xy',scale=1,color='green',label='basis2')\n\nplt.xlim(-1,6)\nplt.ylim(-6,6)\nplt.legend()\nplt.grid()\nplt.show()\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nB = Matrix.hstack(Matrix([1,0]), Matrix([0,1]))\nC = Matrix.hstack(Matrix([1,1]), Matrix([1,-1]))\n```", "```py\nprint(\"C (basis matrix):\\n\", C)\n```", "```py\nC (basis matrix):\n Matrix([[1, 1], [1, -1]])\n```", "```py\nC_inv = C.inv()\nprint(\"C inverse:\\n\", C_inv)\n```", "```py\nC inverse:\n Matrix([[1/2, 1/2], [1/2, -1/2]])\n```", "```py\nv = Matrix([4,5])\ncoords_in_standard = v\nprint(\"Coordinates in standard basis:\", coords_in_standard)\n```", "```py\nCoordinates in standard basis: Matrix([[4], [5]])\n```", "```py\ncoords_in_C = C_inv * v\nprint(\"Coordinates in C basis:\", coords_in_C)\n```", "```py\nCoordinates in C basis: Matrix([[9/2], [-1/2]])\n```", "```py\nreconstructed = C * coords_in_C\nprint(\"Reconstructed vector:\", reconstructed)\n```", "```py\nReconstructed vector: Matrix([[4], [5]])\n```", "```py\nB = Matrix.eye(3)  # standard basis\nC = Matrix.hstack(\n Matrix([1,0,1]),\n Matrix([0,1,1]),\n Matrix([1,1,0])\n)\n\nv = Matrix([2,3,4])\n\nC_inv = C.inv()\ncoords_in_C = C_inv * v\nprint(\"Coordinates in new basis C:\", coords_in_C)\n\nprint(\"Back to standard:\", C * coords_in_C)\n```", "```py\nCoordinates in new basis C: Matrix([[3/2], [5/2], [1/2]])\nBack to standard: Matrix([[2], [3], [4]])\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sympy import Matrix\n```", "```py\nt = np.linspace(-3,3,20)\nline_origin = np.array([t, 2*t]).T\nplt.plot(line_origin[:,0], line_origin[:,1], label=\"Through origin\")\n```", "```py\npoint = np.array([3,1])\ndirection = np.array([1,2])\nline_shifted = np.array([point + k*direction for k in t])\nplt.plot(line_shifted[:,0], line_shifted[:,1], label=\"Shifted line\")\n```", "```py\nplt.scatter(*point, color=\"red\", label=\"Shift point\")\nplt.axhline(0,color='black',linewidth=0.5)\nplt.axvline(0,color='black',linewidth=0.5)\nplt.legend()\nplt.grid()\nplt.show()\n```", "```py\ns_vals = np.linspace(-2,2,10)\nt_vals = np.linspace(-2,2,10)\n\npoints = []\nfor s in s_vals:\n for t in t_vals:\n points.append([1,2,3] + s*np.array([1,0,0]) + t*np.array([0,1,0]))\n\npoints = np.array(points)\n\nfrom mpl_toolkits.mplot3d import Axes3D\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.scatter(points[:,0], points[:,1], points[:,2])\nax.set_title(\"Affine plane in R^3\")\nplt.show()\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n```", "```py\nA = np.array([\n [2, 0],\n [0, 0.5]\n])\n\nv = np.array([1, 2])\nTv = A @ v\nprint(\"Original v:\", v)\nprint(\"Transformed Tv:\", Tv)\n```", "```py\nOriginal v: [1 2]\nTransformed Tv: [2\\. 1.]\n```", "```py\nvectors = [np.array([1,1]), np.array([2,0]), np.array([-1,2])]\n\nfor v in vectors:\n Tv = A @ v\n plt.arrow(0,0,v[0],v[1],head_width=0.1,color='blue',length_includes_head=True)\n plt.arrow(0,0,Tv[0],Tv[1],head_width=0.1,color='red',length_includes_head=True)\n\nplt.axhline(0,color='black',linewidth=0.5)\nplt.axvline(0,color='black',linewidth=0.5)\nplt.xlim(-3,5)\nplt.ylim(-1,5)\nplt.grid()\nplt.title(\"Blue = original, Red = transformed\")\nplt.show()\n```", "```py\ntheta = np.pi/2\nR = np.array([\n [np.cos(theta), -np.sin(theta)],\n [np.sin(theta),  np.cos(theta)]\n])\n\nv = np.array([1,0])\nprint(\"Rotate [1,0] by 90°:\", R @ v)\n```", "```py\nRotate [1,0] by 90°: [6.123234e-17 1.000000e+00]\n```", "```py\nu = np.array([1,2])\nv = np.array([3,4])\nc = 5\n\nlhs = A @ (u+v)\nrhs = A@u + A@v\nprint(\"Additivity holds?\", np.allclose(lhs,rhs))\n\nlhs = A @ (c*u)\nrhs = c*(A@u)\nprint(\"Homogeneity holds?\", np.allclose(lhs,rhs))\n```", "```py\nAdditivity holds? True\nHomogeneity holds? True\n```", "```py\ndef nonlinear(v):\n return np.array([v[0]**2, v[1]])\n\nprint(\"T([2,3]) =\", nonlinear(np.array([2,3])))\nprint(\"Check additivity:\", nonlinear(np.array([1,2])+np.array([3,4])) == (nonlinear([1,2])+nonlinear([3,4])))\n```", "```py\nT([2,3]) = [4 3]\nCheck additivity: [False  True]\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\ne1 = Matrix([1,0])\ne2 = Matrix([0,1])\n\ndef T(v):\n x, y = v\n return Matrix([2*x + y, x - y])\n\nprint(\"T(e1):\", T(e1))\nprint(\"T(e2):\", T(e2))\n```", "```py\nT(e1): Matrix([[2], [1]])\nT(e2): Matrix([[1], [-1]])\n```", "```py\nA = Matrix.hstack(T(e1), T(e2))\nprint(\"Matrix representation in standard basis:\\n\", A)\n```", "```py\nMatrix representation in standard basis:\n Matrix([[2, 1], [1, -1]])\n```", "```py\nv = Matrix([3,4])\nprint(\"T(v) via definition:\", T(v))\nprint(\"T(v) via matrix:\", A*v)\n```", "```py\nT(v) via definition: Matrix([[10], [-1]])\nT(v) via matrix: Matrix([[10], [-1]])\n```", "```py\nB = Matrix.hstack(Matrix([1,1]), Matrix([1,-1]))\nP = B\nA_B = P.inv() * A * P\nprint(\"Matrix representation in new basis:\\n\", A_B)\n```", "```py\nMatrix representation in new basis:\n Matrix([[3/2, 3/2], [3/2, -1/2]])\n```", "```py\nnp.random.seed(1)\nA3 = Matrix(np.random.randint(-3,4,(3,3)))\nprint(\"Random transformation matrix:\\n\", A3)\n\nB3 = Matrix.hstack(Matrix([1,0,1]), Matrix([0,1,1]), Matrix([1,1,0]))\nA3_B = B3.inv() * A3 * B3\nprint(\"Representation in new basis:\\n\", A3_B)\n```", "```py\nRandom transformation matrix:\n Matrix([[2, 0, 1], [-3, -2, 0], [2, -3, -3]])\nRepresentation in new basis:\n Matrix([[5/2, -3/2, 3], [-7/2, -9/2, -4], [1/2, 5/2, -1]])\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nA = Matrix([\n [1,2,3],\n [2,4,6]\n])\n\nprint(\"Null space (kernel):\", A.nullspace())\n```", "```py\nNull space (kernel): [Matrix([\n[-2],\n[ 1],\n[ 0]]), Matrix([\n[-3],\n[ 0],\n[ 1]])]\n```", "```py\nprint(\"Column space (image):\", A.columnspace())\nprint(\"Rank (dimension of image):\", A.rank())\n```", "```py\nColumn space (image): [Matrix([\n[1],\n[2]])]\nRank (dimension of image): 1\n```", "```py\nB = Matrix([\n [1,0,0],\n [0,1,0],\n [0,0,1]\n])\n\nprint(\"Kernel of B:\", B.nullspace())\nprint(\"Image of B:\", B.columnspace())\n```", "```py\nKernel of B: []\nImage of B: [Matrix([\n[1],\n[0],\n[0]]), Matrix([\n[0],\n[1],\n[0]]), Matrix([\n[0],\n[0],\n[1]])]\n```", "```py\nA = np.array([[1,2,3],[2,4,6]], dtype=float)\nrank = np.linalg.matrix_rank(A)\nprint(\"Rank with NumPy:\", rank)\n```", "```py\nRank with NumPy: 1\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nA = Matrix([\n [2,1],\n [5,3]\n])\n\nprint(\"Determinant:\", A.det())\nprint(\"Is invertible?\", A.det() != 0)\n```", "```py\nDeterminant: 1\nIs invertible? True\n```", "```py\nA_inv = A.inv()\nprint(\"Inverse matrix:\\n\", A_inv)\n\nprint(\"Check A*A_inv = I:\\n\", A * A_inv)\n```", "```py\nInverse matrix:\n Matrix([[3, -1], [-5, 2]])\nCheck A*A_inv = I:\n Matrix([[1, 0], [0, 1]])\n```", "```py\nb = Matrix([1,2])\nx = A_inv * b\nprint(\"Solution x:\", x)\n```", "```py\nSolution x: Matrix([[1], [-1]])\n```", "```py\nB = Matrix([\n [1,2],\n [2,4]\n])\n\nprint(\"Determinant:\", B.det())\nprint(\"Is invertible?\", B.det() != 0)\n```", "```py\nDeterminant: 0\nIs invertible? False\n```", "```py\nA = np.array([[2,1],[5,3]], dtype=float)\nprint(\"Determinant:\", np.linalg.det(A))\nprint(\"Inverse:\\n\", np.linalg.inv(A))\n```", "```py\nDeterminant: 1.0000000000000002\nInverse:\n [[ 3\\. -1.]\n [-5\\.  2.]]\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\ntheta = np.pi/2\nR = np.array([\n [np.cos(theta), -np.sin(theta)],\n [np.sin(theta),  np.cos(theta)]\n])\nS = np.array([\n [2,0],\n [0,1]\n])\n\n# Compose: apply R then S\nC = S @ R\nprint(\"Composite matrix:\\n\", C)\n```", "```py\nComposite matrix:\n [[ 1.2246468e-16 -2.0000000e+00]\n [ 1.0000000e+00  6.1232340e-17]]\n```", "```py\nv = np.array([1,1])\nstep1 = R @ v\nstep2 = S @ step1\ncomposite = C @ v\n\nprint(\"Step-by-step:\", step2)\nprint(\"Composite:\", composite)\n```", "```py\nStep-by-step: [-2\\.  1.]\nComposite: [-2\\.  1.]\n```", "```py\nA = np.array([[2,0],[0,2]])\nv = np.array([1,1])\n\nprint(\"A @ v =\", A @ v)\nprint(\"A^2 @ v =\", np.linalg.matrix_power(A,2) @ v)\nprint(\"A^5 @ v =\", np.linalg.matrix_power(A,5) @ v)\n```", "```py\nA @ v = [2 2]\nA^2 @ v = [4 4]\nA^5 @ v = [32 32]\n```", "```py\nA = np.array([[0.5,0],[0,0.5]])\nv = np.array([4,4])\n\nfor i in range(5):\n v = A @ v\n print(f\"Step {i+1}:\", v)\n```", "```py\nStep 1: [2\\. 2.]\nStep 2: [1\\. 1.]\nStep 3: [0.5 0.5]\nStep 4: [0.25 0.25]\nStep 5: [0.125 0.125]\n```", "```py\nnp.random.seed(0)\nM = np.random.randint(-2,3,(2,2))\nprint(\"Random matrix:\\n\", M)\n\nprint(\"M^2:\\n\", np.linalg.matrix_power(M,2))\nprint(\"M^3:\\n\", np.linalg.matrix_power(M,3))\n```", "```py\nRandom matrix:\n [[ 2 -2]\n [ 1  1]]\nM^2:\n [[ 2 -6]\n [ 3 -1]]\nM^3:\n [[ -2 -10]\n [  5  -7]]\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nA = Matrix([\n [2,1],\n [0,2]\n])\n\nP = Matrix([\n [1,1],\n [0,1]\n])\n\nB = P.inv() * A * P\nprint(\"Original A:\\n\", A)\nprint(\"Similar matrix B:\\n\", B)\n```", "```py\nOriginal A:\n Matrix([[2, 1], [0, 2]])\nSimilar matrix B:\n Matrix([[2, 1], [0, 2]])\n```", "```py\nprint(\"Eigenvalues of A:\", A.eigenvals())\nprint(\"Eigenvalues of B:\", B.eigenvals())\n```", "```py\nEigenvalues of A: {2: 2}\nEigenvalues of B: {2: 2}\n```", "```py\nC = Matrix([\n [4,1],\n [0,2]\n])\n\nP, D = C.diagonalize()\nprint(\"Diagonal form D:\\n\", D)\nprint(\"Check similarity (P^-1 C P = D):\\n\", P.inv()*C*P)\n```", "```py\nDiagonal form D:\n Matrix([[2, 0], [0, 4]])\nCheck similarity (P^-1 C P = D):\n Matrix([[2, 0], [0, 4]])\n```", "```py\nA = np.array([[2,1],[0,2]], dtype=float)\neigvals, eigvecs = np.linalg.eig(A)\nprint(\"Eigenvalues:\", eigvals)\nprint(\"Eigenvectors (basis P):\\n\", eigvecs)\n```", "```py\nEigenvalues: [2\\. 2.]\nEigenvectors (basis P):\n [[ 1.0000000e+00 -1.0000000e+00]\n [ 0.0000000e+00  4.4408921e-16]]\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\nimport matplotlib.pyplot as plt\n```", "```py\nu = np.array([2,1], dtype=float)\nu = u / np.linalg.norm(u)   # normalize\nP = np.outer(u,u)\n\nprint(\"Projection matrix:\\n\", P)\n```", "```py\nProjection matrix:\n [[0.8 0.4]\n [0.4 0.2]]\n```", "```py\nv = np.array([3,4], dtype=float)\nproj_v = P @ v\nprint(\"Original v:\", v)\nprint(\"Projection of v onto u:\", proj_v)\n```", "```py\nOriginal v: [3\\. 4.]\nProjection of v onto u: [4\\. 2.]\n```", "```py\nplt.arrow(0,0,v[0],v[1],head_width=0.1,color=\"blue\",length_includes_head=True)\nplt.arrow(0,0,proj_v[0],proj_v[1],head_width=0.1,color=\"red\",length_includes_head=True)\nplt.arrow(proj_v[0],proj_v[1],v[0]-proj_v[0],v[1]-proj_v[1],head_width=0.1,color=\"gray\",linestyle=\"dashed\")\n\nplt.axhline(0,color='black',linewidth=0.5)\nplt.axvline(0,color='black',linewidth=0.5)\nplt.grid()\nplt.title(\"Blue = original, Red = projection, Gray = error vector\")\nplt.show()\n```", "```py\nI = np.eye(2)\nR = 2*P - I\n\nreflect_v = R @ v\nprint(\"Reflection of v across line u:\", reflect_v)\n```", "```py\nReflection of v across line u: [ 5.0000000e+00 -4.4408921e-16]\n```", "```py\nprint(\"P^2 =\\n\", P @ P)\nprint(\"R^2 =\\n\", R @ R)\n```", "```py\nP^2 =\n [[0.8 0.4]\n [0.4 0.2]]\nR^2 =\n [[ 1.00000000e+00 -1.59872116e-16]\n [-1.59872116e-16  1.00000000e+00]]\n```", "```py\nu1 = np.array([1,0,0], dtype=float)\nu2 = np.array([0,1,0], dtype=float)\n\nU = np.column_stack((u1,u2))   # basis for plane\nP_plane = U @ np.linalg.inv(U.T @ U) @ U.T\n\nv = np.array([1,2,3], dtype=float)\nproj_plane = P_plane @ v\nprint(\"Projection onto xy-plane:\", proj_plane)\n```", "```py\nProjection onto xy-plane: [1\\. 2\\. 0.]\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n```", "```py\ndef rotation_matrix(theta):\n return np.array([\n [np.cos(theta), -np.sin(theta)],\n [np.sin(theta),  np.cos(theta)]\n ])\n\ntheta = np.pi/4   # 45 degrees\nR = rotation_matrix(theta)\n\nv = np.array([2,1])\nrotated_v = R @ v\nprint(\"Original v:\", v)\nprint(\"Rotated v (45°):\", rotated_v)\n```", "```py\nOriginal v: [2 1]\nRotated v (45°): [0.70710678 2.12132034]\n```", "```py\nplt.arrow(0,0,v[0],v[1],head_width=0.1,color=\"blue\",length_includes_head=True)\nplt.arrow(0,0,rotated_v[0],rotated_v[1],head_width=0.1,color=\"red\",length_includes_head=True)\n\nplt.axhline(0,color='black',linewidth=0.5)\nplt.axvline(0,color='black',linewidth=0.5)\nplt.grid()\nplt.title(\"Blue = original, Red = rotated (45°)\")\nplt.axis(\"equal\")\nplt.show()\n```", "```py\nk = 1.0\nS = np.array([\n [1,k],\n [0,1]\n])\n\nsheared_v = S @ v\nprint(\"Sheared v:\", sheared_v)\n```", "```py\nSheared v: [3\\. 1.]\n```", "```py\nplt.arrow(0,0,v[0],v[1],head_width=0.1,color=\"blue\",length_includes_head=True)\nplt.arrow(0,0,sheared_v[0],sheared_v[1],head_width=0.1,color=\"green\",length_includes_head=True)\n\nplt.axhline(0,color='black',linewidth=0.5)\nplt.axvline(0,color='black',linewidth=0.5)\nplt.grid()\nplt.title(\"Blue = original, Green = sheared\")\nplt.axis(\"equal\")\nplt.show()\n```", "```py\nprint(\"||v|| =\", np.linalg.norm(v))\nprint(\"||R v|| =\", np.linalg.norm(rotated_v))\n```", "```py\n||v|| = 2.23606797749979\n||R v|| = 2.2360679774997894\n```", "```py\nprint(\"det(S) =\", np.linalg.det(S))\n```", "```py\ndet(S) = 1.0\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nA = Matrix([\n [1,2,3],\n [2,4,6],\n [1,1,1]\n])\n\nprint(\"Matrix A:\\n\", A)\nprint(\"Rank of A:\", A.rank())\n```", "```py\nMatrix A:\n Matrix([[1, 2, 3], [2, 4, 6], [1, 1, 1]])\nRank of A: 2\n```", "```py\nA_np = np.array([[1,2,3],[2,4,6],[1,1,1]], dtype=float)\nprint(\"Rank (NumPy):\", np.linalg.matrix_rank(A_np))\n```", "```py\nRank (NumPy): 2\n```", "```py\nfor v in [np.array([1,0,0]), np.array([0,1,0]), np.array([0,0,1])]:\n print(\"A @\", v, \"=\", A_np @ v)\n```", "```py\nA @ [1 0 0] = [1\\. 2\\. 1.]\nA @ [0 1 0] = [2\\. 4\\. 1.]\nA @ [0 0 1] = [3\\. 6\\. 1.]\n```", "```py\nB = Matrix([\n [1,0,0],\n [0,1,0],\n [0,0,1]\n])\n\nprint(\"Rank of B:\", B.rank())\n```", "```py\nRank of B: 3\n```", "```py\nprint(\"Null space (basis):\", A.nullspace())\nprint(\"Nullity:\", len(A.nullspace()))\nprint(\"Rank + Nullity =\", A.rank() + len(A.nullspace()))\n```", "```py\nNull space (basis): [Matrix([\n[ 1],\n[-2],\n[ 1]])]\nNullity: 1\nRank + Nullity = 3\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nA11 = Matrix([[1,2],[3,4]])\nA12 = Matrix([[5,6],[7,8]])\nA21 = Matrix([[9,10]])\nA22 = Matrix([[11,12]])\n\n# Combine into a block matrix\nA = Matrix.vstack(\n Matrix.hstack(A11, A12),\n Matrix.hstack(A21, A22)\n)\nprint(\"Block matrix A:\\n\", A)\n```", "```py\nBlock matrix A:\n Matrix([[1, 2, 5, 6], [3, 4, 7, 8], [9, 10, 11, 12]])\n```", "```py\nA = Matrix([\n [1,2,5,6],\n [3,4,7,8],\n [9,10,11,12]\n])\n\nx = Matrix([1,1,2,2])\nprint(\"A * x =\", A*x)\n```", "```py\nA * x = Matrix([[25], [37], [65]])\n```", "```py\nB1 = Matrix([[2,0],[0,2]])\nB2 = Matrix([[3,1],[0,3]])\n\nBlockDiag = Matrix([\n [2,0,0,0],\n [0,2,0,0],\n [0,0,3,1],\n [0,0,0,3]\n])\n\nprint(\"Block diagonal matrix:\\n\", BlockDiag)\n```", "```py\nBlock diagonal matrix:\n Matrix([[2, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 1], [0, 0, 0, 3]])\n```", "```py\nB1_inv = B1.inv()\nB2_inv = B2.inv()\nBlockDiagInv = Matrix([\n [B1_inv[0,0],0,0,0],\n [0,B1_inv[1,1],0,0],\n [0,0,B2_inv[0,0],B2_inv[0,1]],\n [0,0,B2_inv[1,0],B2_inv[1,1]]\n])\nprint(\"Inverse block diag:\\n\", BlockDiagInv)\n```", "```py\nInverse block diag:\n Matrix([[1/2, 0, 0, 0], [0, 1/2, 0, 0], [0, 0, 1/3, -1/9], [0, 0, 0, 1/3]])\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nA = Matrix([\n [2,1],\n [1,1]\n])\n\nprint(\"Determinant:\", A.det())\n```", "```py\nDeterminant: 1\n```", "```py\nsquare = Matrix([\n [0,0],\n [1,0],\n [1,1],\n [0,1]\n])\n\ntransformed = (A * square.T).T\nprint(\"Original square:\\n\", square)\nprint(\"Transformed square:\\n\", transformed)\n```", "```py\nOriginal square:\n Matrix([[0, 0], [1, 0], [1, 1], [0, 1]])\nTransformed square:\n Matrix([[0, 0], [2, 1], [3, 2], [1, 1]])\n```", "```py\nB = Matrix([\n [1,2,0],\n [0,1,0],\n [0,0,3]\n])\n\nprint(\"Determinant:\", B.det())\n```", "```py\nDeterminant: 3\n```", "```py\nC = Matrix([\n [0,1],\n [1,0]\n])\n\nprint(\"Determinant:\", C.det())\n```", "```py\nDeterminant: -1\n```", "```py\nA = np.array([[2,1],[1,1]], dtype=float)\nprint(\"Det (NumPy):\", np.linalg.det(A))\n```", "```py\nDet (NumPy): 1.0\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nA = Matrix([[1,2],[3,4]])\nprint(\"det(A):\", A.det())\n\nB = Matrix([[2,4],[3,4]])  # first row doubled\nprint(\"det(B):\", B.det())\n```", "```py\ndet(A): -2\ndet(B): -4\n```", "```py\nC = Matrix([[1,2],[3,4]])\nC_swapped = Matrix([[3,4],[1,2]])\n\nprint(\"det(C):\", C.det())\nprint(\"det(C_swapped):\", C_swapped.det())\n```", "```py\ndet(C): -2\ndet(C_swapped): 2\n```", "```py\nI = Matrix.eye(3)\nprint(\"det(I):\", I.det())\n```", "```py\ndet(I): 1\n```", "```py\nM = Matrix([[1,2,3],[4,5,6],[7,8,9]])\nprint(\"det(M):\", M.det())\n```", "```py\ndet(M): 0\n```", "```py\nA = np.array([[1,2],[3,4]], dtype=float)\nprint(\"det(A) NumPy:\", np.linalg.det(A))\n```", "```py\ndet(A) NumPy: -2.0000000000000004\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nA = Matrix([[1,2],[3,4]])\nprint(\"det(A):\", A.det())\n\nA_swapped = Matrix([[3,4],[1,2]])\nprint(\"det(after swap):\", A_swapped.det())\n```", "```py\ndet(A): -2\ndet(after swap): 2\n```", "```py\nB = Matrix([[1,2],[3,4]])\nB_scaled = Matrix([[2,4],[3,4]])  # first row × 2\n\nprint(\"det(B):\", B.det())\nprint(\"det(after scaling row 1 by 2):\", B_scaled.det())\n```", "```py\ndet(B): -2\ndet(after scaling row 1 by 2): -4\n```", "```py\nC = Matrix([[1,2],[3,4]])\nC_replaced = Matrix([[1,2],[3-2*1, 4-2*2]])  # row2 → row2 - 2*row1\n\nprint(\"det(C):\", C.det())\nprint(\"det(after row replacement):\", C_replaced.det())\n```", "```py\ndet(C): -2\ndet(after row replacement): -2\n```", "```py\nD = Matrix([[2,1,3],[0,4,5],[0,0,6]])\nprint(\"det(D):\", D.det())\nprint(\"Product of diagonals:\", 2*4*6)\n```", "```py\ndet(D): 48\nProduct of diagonals: 48\n```", "```py\nA = np.array([[1,2,3],[0,4,5],[1,0,6]], dtype=float)\nprint(\"det(A):\", np.linalg.det(A))\n```", "```py\ndet(A): 22.000000000000004\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nA = Matrix([\n [2,1,3],\n [0,4,5],\n [0,0,6]\n])\n\nprint(\"det(A):\", A.det())\nprint(\"Product of diagonals:\", 2*4*6)\n```", "```py\ndet(A): 48\nProduct of diagonals: 48\n```", "```py\nB = Matrix([\n [7,0,0],\n [2,5,0],\n [3,4,9]\n])\n\nprint(\"det(B):\", B.det())\nprint(\"Product of diagonals:\", 7*5*9)\n```", "```py\ndet(B): 315\nProduct of diagonals: 315\n```", "```py\nC = Matrix.diag(3,5,7)\nprint(\"det(C):\", C.det())\nprint(\"Product of diagonals:\", 3*5*7)\n```", "```py\ndet(C): 105\nProduct of diagonals: 105\n```", "```py\nA = np.array([[2,1,3],[0,4,5],[0,0,6]], dtype=float)\nprint(\"det(A):\", np.linalg.det(A))\nprint(\"Product of diagonals:\", np.prod(np.diag(A)))\n```", "```py\ndet(A): 47.999999999999986\nProduct of diagonals: 48.0\n```", "```py\nD = Matrix([[1,2,3],[4,5,6],[7,8,10]])\nprint(\"det(D) via SymPy:\", D.det())\nprint(\"det(D) via LU decomposition:\", D.LUdecomposition()[0].det() * D.LUdecomposition()[1].det())\n```", "```py\ndet(D) via SymPy: -3\ndet(D) via LU decomposition: -3\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nA = Matrix([[2,1],[0,3]])\nB = Matrix([[1,4],[2,5]])\n\ndetA = A.det()\ndetB = B.det()\ndetAB = (A*B).det()\n\nprint(\"det(A):\", detA)\nprint(\"det(B):\", detB)\nprint(\"det(AB):\", detAB)\nprint(\"det(A)*det(B):\", detA*detB)\n```", "```py\ndet(A): 6\ndet(B): -3\ndet(AB): -18\ndet(A)*det(B): -18\n```", "```py\nnp.random.seed(1)\nA = Matrix(np.random.randint(-3,4,(3,3)))\nB = Matrix(np.random.randint(-3,4,(3,3)))\n\nprint(\"det(A):\", A.det())\nprint(\"det(B):\", B.det())\nprint(\"det(AB):\", (A*B).det())\nprint(\"det(A)*det(B):\", A.det()*B.det())\n```", "```py\ndet(A): 25\ndet(B): -15\ndet(AB): -375\ndet(A)*det(B): -375\n```", "```py\nA = Matrix([[1,0],[0,0]])  # singular\nB = Matrix([[2,3],[4,5]])\n\nprint(\"det(A):\", A.det())\nprint(\"det(AB):\", (A*B).det())\n```", "```py\ndet(A): 0\ndet(AB): 0\n```", "```py\nA = np.array([[2,1],[0,3]], dtype=float)\nB = np.array([[1,4],[2,5]], dtype=float)\n\nlhs = np.linalg.det(A @ B)\nrhs = np.linalg.det(A) * np.linalg.det(B)\n\nprint(\"det(AB) =\", lhs)\nprint(\"det(A)*det(B) =\", rhs)\n```", "```py\ndet(AB) = -17.999999999999996\ndet(A)*det(B) = -17.999999999999996\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\nfrom sympy.matrices.common import NonInvertibleMatrixError\n```", "```py\nA = Matrix([[2,1],[5,3]])\nprint(\"det(A):\", A.det())\nprint(\"Inverse exists?\", A.det() != 0)\nprint(\"A inverse:\\n\", A.inv())\n```", "```py\ndet(A): 1\nInverse exists? True\nA inverse:\n Matrix([[3, -1], [-5, 2]])\n```", "```py\nB = Matrix([[1,2],[2,4]])\nprint(\"det(B):\", B.det())\nprint(\"Inverse exists?\", B.det() != 0)\n```", "```py\ndet(B): 0\nInverse exists? False\n```", "```py\n# 3\\. Solving systems with determinant check\nb = Matrix([1,2])\ntry:\n print(\"Solve Ax=b with singular B:\", B.solve(b))\nexcept NonInvertibleMatrixError as e:\n print(\"Error when solving Ax=b:\", e)\n```", "```py\nError when solving Ax=b: Matrix det == 0; not invertible.\n```", "```py\nC = Matrix([\n [1,0,0],\n [0,2,0],\n [0,0,3]\n])\nprint(\"det(C):\", C.det())\nprint(\"Invertible?\", C.det() != 0)\n```", "```py\ndet(C): 6\nInvertible? True\n```", "```py\nA = np.array([[2,1],[5,3]], dtype=float)\nprint(\"det(A):\", np.linalg.det(A))\nprint(\"Inverse:\\n\", np.linalg.inv(A))\n\nB = np.array([[1,2],[2,4]], dtype=float)\nprint(\"det(B):\", np.linalg.det(B))\n# np.linalg.inv(B) would fail because det=0\n```", "```py\ndet(A): 1.0000000000000002\nInverse:\n [[ 3\\. -1.]\n [-5\\.  2.]]\ndet(B): 0.0\n```", "```py\nimport numpy as np\nfrom sympy import Matrix, symbols\n```", "```py\n# declare symbols\na, b, c, d = symbols('a b c d')\n\n# build the matrix\nA = Matrix([[a, b],[c, d]])\n\n# compute determinant\ndetA = A.det()\nprint(\"Determinant 2x2:\", detA)\n```", "```py\nDeterminant 2x2: a*d - b*c\n```", "```py\nA = Matrix([\n [1,2,3],\n [4,5,6],\n [7,8,9]\n])\n\ndetA = A.det()\nprint(\"Determinant via SymPy:\", detA)\n```", "```py\nDeterminant via SymPy: 0\n```", "```py\ncofactor_expansion = (\n 1 * Matrix([[5,6],[8,9]]).det()\n - 2 * Matrix([[4,6],[7,9]]).det()\n + 3 * Matrix([[4,5],[7,8]]).det()\n)\nprint(\"Cofactor expansion result:\", cofactor_expansion)\n```", "```py\nCofactor expansion result: 0\n```", "```py\ncofactor_col1 = (\n 1 * Matrix([[2,3],[8,9]]).det()\n - 4 * Matrix([[2,3],[5,6]]).det()\n + 7 * Matrix([[2,3],[5,6]]).det()\n)\nprint(\"Expansion along col1:\", cofactor_col1)\n```", "```py\nExpansion along col1: -15\n```", "```py\nB = Matrix([\n [2,0,1,3],\n [1,2,0,4],\n [0,1,1,0],\n [3,0,2,1]\n])\n\nprint(\"Determinant 4x4:\", B.det())\n```", "```py\nDeterminant 4x4: -15\n```", "```py\nB_np = np.array([[2,0,1,3],[1,2,0,4],[0,1,1,0],[3,0,2,1]], dtype=float)\nprint(\"NumPy determinant:\", np.linalg.det(B_np))\n```", "```py\nNumPy determinant: -15.0\n```", "```py\nimport itertools\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\ndef determinant_permutation(A):\n n = A.shape[0]\n total = 0\n for perm in itertools.permutations(range(n)):\n sign = (-1)**(sum(1 for i in range(n) for j in range(i) if perm[j] > perm[i]))\n product = 1\n for i in range(n):\n product *= A[i, perm[i]]\n total += sign * product\n return total\n\nA = np.array([[1,2,3],\n [4,5,6],\n [7,8,9]])\n\nprint(\"Permutation formula det:\", determinant_permutation(A))\nprint(\"NumPy det:\", np.linalg.det(A))\n```", "```py\nPermutation formula det: 0\nNumPy det: -9.51619735392994e-16\n```", "```py\nM = Matrix([[2,1,0],\n [1,3,4],\n [0,2,5]])\nprint(\"SymPy det:\", M.det())\n```", "```py\nSymPy det: 9\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nA = Matrix([[2,1],[1,-1]])\nb = Matrix([5,1])\n\ndetA = A.det()\nprint(\"det(A):\", detA)\n\n# Replace columns\nA1 = A.copy()\nA1[:,0] = b\nA2 = A.copy()\nA2[:,1] = b\n\nx1 = A1.det() / detA\nx2 = A2.det() / detA\nprint(\"Solution via Cramer's Rule:\", [x1, x2])\n\n# Check with built-in solver\nprint(\"SymPy solve:\", A.LUsolve(b))\n```", "```py\ndet(A): -3\nSolution via Cramer's Rule: [2, 1]\nSymPy solve: Matrix([[2], [1]])\n```", "```py\nA = Matrix([\n [1,2,3],\n [0,1,4],\n [5,6,0]\n])\nb = Matrix([7,8,9])\n\ndetA = A.det()\nprint(\"det(A):\", detA)\n\nsolutions = []\nfor i in range(A.shape[1]):\n Ai = A.copy()\n Ai[:,i] = b\n solutions.append(Ai.det()/detA)\n\nprint(\"Solution via Cramer's Rule:\", solutions)\nprint(\"SymPy solve:\", A.LUsolve(b))\n```", "```py\ndet(A): 1\nSolution via Cramer's Rule: [21, -16, 6]\nSymPy solve: Matrix([[21], [-16], [6]])\n```", "```py\nA = np.array([[2,1],[1,-1]], dtype=float)\nb = np.array([5,1], dtype=float)\n\ndetA = np.linalg.det(A)\n\nsolutions = []\nfor i in range(A.shape[1]):\n Ai = A.copy()\n Ai[:,i] = b\n solutions.append(np.linalg.det(Ai)/detA)\n\nprint(\"Solution:\", solutions)\n```", "```py\nSolution: [np.float64(2.0000000000000004), np.float64(1.0)]\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nA = Matrix([\n [1,2,3],\n [4,5,6],\n [7,8,10]\n])\nprint(\"det via cofactor expansion:\", A.det())\n```", "```py\ndet via cofactor expansion: -3\n```", "```py\nL, U, perm = A.LUdecomposition()\ndetA = A.det()\nprint(\"L:\\n\", L)\nprint(\"U:\\n\", U)\nprint(\"Permutation matrix:\\n\", perm)\nprint(\"det via LU product:\", detA)\n```", "```py\nL:\n Matrix([[1, 0, 0], [4, 1, 0], [7, 2, 1]])\nU:\n Matrix([[1, 2, 3], [0, -3, -6], [0, 0, 1]])\nPermutation matrix:\n []\ndet via LU product: -3\n```", "```py\nA_np = np.array([[1,2,3],[4,5,6],[7,8,10]], dtype=float)\nprint(\"NumPy det:\", np.linalg.det(A_np))\n```", "```py\nNumPy det: -3.000000000000001\n```", "```py\nnp.random.seed(0)\nB = np.random.rand(5,5)\nprint(\"NumPy det (5x5):\", np.linalg.det(B))\n```", "```py\nNumPy det (5x5): 0.009658225505885114\n```", "```py\nC = np.array([[1,2,3],[2,4.0000001,6],[3,6,9]], dtype=float)\nprint(\"det(C):\", np.linalg.det(C))\n```", "```py\ndet(C): -4.996003624823549e-23\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nA = Matrix([\n [2,1],\n [1,2]\n])\n\neigs = A.eigenvects()\nprint(\"Eigenvalues and eigenvectors:\", eigs)\n```", "```py\nEigenvalues and eigenvectors: [(1, 1, [Matrix([\n[-1],\n[ 1]])]), (3, 1, [Matrix([\n[1],\n[1]])])]\n```", "```py\nlam = eigs[0][0]\nv = eigs[0][2][0]\nprint(\"Check Av = λv:\", A*v, lam*v)\n```", "```py\nCheck Av = λv: Matrix([[-1], [1]]) Matrix([[-1], [1]])\n```", "```py\nA_np = np.array([[2,1],[1,2]], dtype=float)\neigvals, eigvecs = np.linalg.eig(A_np)\n\nprint(\"Eigenvalues:\", eigvals)\nprint(\"Eigenvectors:\\n\", eigvecs)\n```", "```py\nEigenvalues: [3\\. 1.]\nEigenvectors:\n [[ 0.70710678 -0.70710678]\n [ 0.70710678  0.70710678]]\n```", "```py\nimport matplotlib.pyplot as plt\n\nv1 = np.array(eigvecs[:,0])\nv2 = np.array(eigvecs[:,1])\n\nplt.arrow(0,0,v1[0],v1[1],head_width=0.1,color=\"blue\",length_includes_head=True)\nplt.arrow(0,0,v2[0],v2[1],head_width=0.1,color=\"red\",length_includes_head=True)\n\nplt.axhline(0,color=\"black\",linewidth=0.5)\nplt.axvline(0,color=\"black\",linewidth=0.5)\nplt.axis(\"equal\")\nplt.grid()\nplt.title(\"Eigenvectors: directions that stay put\")\nplt.show()\n```", "```py\nnp.random.seed(1)\nB = Matrix(np.random.randint(-2,3,(3,3)))\nprint(\"Matrix B:\\n\", B)\nprint(\"Eigenvalues/vectors:\", B.eigenvects())\n```", "```py\nMatrix B:\n Matrix([[1, 2, -2], [-1, 1, -2], [-2, -1, 2]])\nEigenvalues/vectors: [(4/3 + (-1/2 - sqrt(3)*I/2)*(2*sqrt(43)/3 + 127/27)**(1/3) + 13/(9*(-1/2 - sqrt(3)*I/2)*(2*sqrt(43)/3 + 127/27)**(1/3)), 1, [Matrix([\n[ -16/27 - 91/(81*(-1/2 - sqrt(3)*I/2)*(2*sqrt(43)/3 + 127/27)**(1/3)) + (4/3 + (-1/2 - sqrt(3)*I/2)*(2*sqrt(43)/3 + 127/27)**(1/3) + 13/(9*(-1/2 - sqrt(3)*I/2)*(2*sqrt(43)/3 + 127/27)**(1/3)))**2/9 - 7*(-1/2 - sqrt(3)*I/2)*(2*sqrt(43)/3 + 127/27)**(1/3)/9],\n[50/27 + 5*(-1/2 - sqrt(3)*I/2)*(2*sqrt(43)/3 + 127/27)**(1/3)/9 - 2*(4/3 + (-1/2 - sqrt(3)*I/2)*(2*sqrt(43)/3 + 127/27)**(1/3) + 13/(9*(-1/2 - sqrt(3)*I/2)*(2*sqrt(43)/3 + 127/27)**(1/3)))**2/9 + 65/(81*(-1/2 - sqrt(3)*I/2)*(2*sqrt(43)/3 + 127/27)**(1/3))],\n[                                                                                                                                                                                                                                                              1]])]), (4/3 + 13/(9*(-1/2 + sqrt(3)*I/2)*(2*sqrt(43)/3 + 127/27)**(1/3)) + (-1/2 + sqrt(3)*I/2)*(2*sqrt(43)/3 + 127/27)**(1/3), 1, [Matrix([\n[ -16/27 - 7*(-1/2 + sqrt(3)*I/2)*(2*sqrt(43)/3 + 127/27)**(1/3)/9 + (4/3 + 13/(9*(-1/2 + sqrt(3)*I/2)*(2*sqrt(43)/3 + 127/27)**(1/3)) + (-1/2 + sqrt(3)*I/2)*(2*sqrt(43)/3 + 127/27)**(1/3))**2/9 - 91/(81*(-1/2 + sqrt(3)*I/2)*(2*sqrt(43)/3 + 127/27)**(1/3))],\n[50/27 + 65/(81*(-1/2 + sqrt(3)*I/2)*(2*sqrt(43)/3 + 127/27)**(1/3)) - 2*(4/3 + 13/(9*(-1/2 + sqrt(3)*I/2)*(2*sqrt(43)/3 + 127/27)**(1/3)) + (-1/2 + sqrt(3)*I/2)*(2*sqrt(43)/3 + 127/27)**(1/3))**2/9 + 5*(-1/2 + sqrt(3)*I/2)*(2*sqrt(43)/3 + 127/27)**(1/3)/9],\n[                                                                                                                                                                                                                                                              1]])]), (13/(9*(2*sqrt(43)/3 + 127/27)**(1/3)) + 4/3 + (2*sqrt(43)/3 + 127/27)**(1/3), 1, [Matrix([\n[  -7*(2*sqrt(43)/3 + 127/27)**(1/3)/9 - 16/27 - 91/(81*(2*sqrt(43)/3 + 127/27)**(1/3)) + (13/(9*(2*sqrt(43)/3 + 127/27)**(1/3)) + 4/3 + (2*sqrt(43)/3 + 127/27)**(1/3))**2/9],\n[-2*(13/(9*(2*sqrt(43)/3 + 127/27)**(1/3)) + 4/3 + (2*sqrt(43)/3 + 127/27)**(1/3))**2/9 + 65/(81*(2*sqrt(43)/3 + 127/27)**(1/3)) + 5*(2*sqrt(43)/3 + 127/27)**(1/3)/9 + 50/27],\n[                                                                                                                                                                           1]])])]\n```", "```py\nimport numpy as np\nfrom sympy import Matrix, symbols\n```", "```py\nλ = symbols('λ')\nA = Matrix([[2,1],[1,2]])\nchar_poly = A.charpoly(λ)\nprint(\"Characteristic polynomial:\", char_poly.as_expr())\nprint(\"Eigenvalues (roots):\", char_poly.all_roots())\n```", "```py\nCharacteristic polynomial: λ**2 - 4*λ + 3\nEigenvalues (roots): [1, 3]\n```", "```py\nprint(\"Eigenvalues directly:\", A.eigenvals())\n```", "```py\nEigenvalues directly: {3: 1, 1: 1}\n```", "```py\nB = Matrix([\n [1,2,3],\n [0,1,4],\n [5,6,0]\n])\n\nchar_poly_B = B.charpoly(λ)\nprint(\"Characteristic polynomial of B:\", char_poly_B.as_expr())\nprint(\"Eigenvalues of B:\", char_poly_B.all_roots())\n```", "```py\nCharacteristic polynomial of B: λ**3 - 2*λ**2 - 38*λ - 1\nEigenvalues of B: [CRootOf(x**3 - 2*x**2 - 38*x - 1, 0), CRootOf(x**3 - 2*x**2 - 38*x - 1, 1), CRootOf(x**3 - 2*x**2 - 38*x - 1, 2)]\n```", "```py\nB_np = np.array([[1,2,3],[0,1,4],[5,6,0]], dtype=float)\neigvals = np.linalg.eigvals(B_np)\nprint(\"NumPy eigenvalues:\", eigvals)\n```", "```py\nNumPy eigenvalues: [-5.2296696  -0.02635282  7.25602242]\n```", "```py\nprint(\"Trace:\", A.trace())\nprint(\"Determinant:\", A.det())\n```", "```py\nTrace: 4\nDeterminant: 3\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nA = Matrix([\n [2,1],\n [0,2]\n])\n\nprint(\"Eigenvalues and algebraic multiplicity:\", A.eigenvals())\nprint(\"Eigenvectors:\", A.eigenvects())\n```", "```py\nEigenvalues and algebraic multiplicity: {2: 2}\nEigenvectors: [(2, 2, [Matrix([\n[1],\n[0]])])]\n```", "```py\nB = Matrix([\n [3,0,0],\n [0,3,0],\n [0,0,3]\n])\n\nprint(\"Eigenvalues:\", B.eigenvals())\nprint(\"Eigenvectors:\", B.eigenvects())\n```", "```py\nEigenvalues: {3: 3}\nEigenvectors: [(3, 3, [Matrix([\n[1],\n[0],\n[0]]), Matrix([\n[0],\n[1],\n[0]]), Matrix([\n[0],\n[0],\n[1]])])]\n```", "```py\nA_np = np.array([[2,1],[0,2]], dtype=float)\neigvals, eigvecs = np.linalg.eig(A_np)\nprint(\"Eigenvalues:\", eigvals)\nprint(\"Eigenvectors:\\n\", eigvecs)\n```", "```py\nEigenvalues: [2\\. 2.]\nEigenvectors:\n [[ 1.0000000e+00 -1.0000000e+00]\n [ 0.0000000e+00  4.4408921e-16]]\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nA = Matrix([\n [4,1],\n [2,3]\n])\n\nP, D = A.diagonalize()\nprint(\"P (eigenvectors):\")\nprint(P)\nprint(\"D (eigenvalues on diagonal):\")\nprint(D)\n\n# Verify A = P D P^-1\nprint(\"Check:\", P*D*P.inv())\n```", "```py\nP (eigenvectors):\nMatrix([[-1, 1], [2, 1]])\nD (eigenvalues on diagonal):\nMatrix([[2, 0], [0, 5]])\nCheck: Matrix([[4, 1], [2, 3]])\n```", "```py\nB = Matrix([\n [2,1],\n [0,2]\n])\n\ntry:\n P, D = B.diagonalize()\n print(\"Diagonalization successful\")\nexcept Exception as e:\n print(\"Not diagonalizable:\", e)\n```", "```py\nNot diagonalizable: Matrix is not diagonalizable\n```", "```py\nA_np = np.array([[4,1],[2,3]], dtype=float)\neigvals, eigvecs = np.linalg.eig(A_np)\n\nP = eigvecs\nD = np.diag(eigvals)\nPinv = np.linalg.inv(P)\n\nprint(\"Check A = PDP^-1:\\n\", P @ D @ Pinv)\n```", "```py\nCheck A = PDP^-1:\n [[4\\. 1.]\n [2\\. 3.]]\n```", "```py\nk = 5\n\nA_power = np.linalg.matrix_power(A, k)\nD_power = np.linalg.matrix_power(D, k)\nA_via_diag = P @ D_power @ np.linalg.inv(P)\n\nprint(\"A^5 via diagonalization:\\n\", A_via_diag)\nprint(\"Direct A^5:\\n\", A_power)\n```", "```py\nA^5 via diagonalization:\n [[2094\\. 1031.]\n [2062\\. 1063.]]\nDirect A^5:\n [[2094 1031]\n [2062 1063]]\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nD = Matrix([[2,0],[0,3]])\nprint(\"D^5 =\")\nprint(D**5)\n```", "```py\nD^5 =\nMatrix([[32, 0], [0, 243]])\n```", "```py\nA = Matrix([\n [4,1],\n [2,3]\n])\n\nP, D = A.diagonalize()\nprint(\"D (eigenvalues):\")\nprint(D)\n\n# Compute A^10 via diagonalization\nA10 = P * (D**10) * P.inv()\nprint(\"A^10 =\")\nprint(A10)\n```", "```py\nD (eigenvalues):\nMatrix([[2, 0], [0, 5]])\nA^10 =\nMatrix([[6510758, 3254867], [6509734, 3255891]])\n```", "```py\nA_np = np.array([[4,1],[2,3]], dtype=float)\neigvals, eigvecs = np.linalg.eig(A_np)\n\nk = 10\nD_power = np.diag(eigvals**k)\nA10_np = eigvecs @ D_power @ np.linalg.inv(eigvecs)\n\nprint(\"A^10 via eigen-decomposition:\\n\", A10_np)\n```", "```py\nA^10 via eigen-decomposition:\n [[6510758\\. 3254867.]\n [6509734\\. 3255891.]]\n```", "```py\nB = Matrix([\n [0.5,0],\n [0,1.2]\n])\n\nP, D = B.diagonalize()\nprint(\"Eigenvalues:\", D)\nprint(\"B^20:\", P*(D**20)*P.inv())\n```", "```py\nEigenvalues: Matrix([[0.500000000000000, 0], [0, 1.20000000000000]])\nB^20: Matrix([[9.53674316406250e-7, 0], [0, 38.3375999244747]])\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nR = Matrix([[0, -1],\n [1,  0]])\n\nprint(\"Characteristic polynomial:\", R.charpoly())\nprint(\"Eigenvalues:\", R.eigenvals())\n```", "```py\nCharacteristic polynomial: PurePoly(lambda**2 + 1, lambda, domain='ZZ')\nEigenvalues: {-I: 1, I: 1}\n```", "```py\neigs = R.eigenvects()\nfor eig in eigs:\n lam = eig[0]\n v = eig[2][0]\n print(f\"λ = {lam}, Av = {R*v}, λv = {lam*v}\")\n```", "```py\nλ = -I, Av = Matrix([[-1], [-I]]), λv = Matrix([[-1], [-I]])\nλ = I, Av = Matrix([[-1], [I]]), λv = Matrix([[-1], [I]])\n```", "```py\nR_np = np.array([[0,-1],[1,0]], dtype=float)\neigvals, eigvecs = np.linalg.eig(R_np)\nprint(\"Eigenvalues:\", eigvals)\nprint(\"Eigenvectors:\\n\", eigvecs)\n```", "```py\nEigenvalues: [0.+1.j 0.-1.j]\nEigenvectors:\n [[0.70710678+0.j         0.70710678-0.j        ]\n [0\\.        -0.70710678j 0\\.        +0.70710678j]]\n```", "```py\ntheta = np.pi/4  # 45 degrees\nR_theta = np.array([[np.cos(theta), -np.sin(theta)],\n [np.sin(theta),  np.cos(theta)]])\n\neigvals, eigvecs = np.linalg.eig(R_theta)\nprint(\"Eigenvalues (rotation 45°):\", eigvals)\n```", "```py\nEigenvalues (rotation 45°): [0.70710678+0.70710678j 0.70710678-0.70710678j]\n```", "```py\nA = np.array([[0.8, -0.6],\n [0.6,  0.8]])\n\neigvals, _ = np.linalg.eig(A)\nprint(\"Eigenvalues:\", eigvals)\n```", "```py\nEigenvalues: [0.8+0.6j 0.8-0.6j]\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nA = Matrix([[2,1],\n [0,2]])\n\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Eigenvectors:\", A.eigenvects())\n```", "```py\nEigenvalues: {2: 2}\nEigenvectors: [(2, 2, [Matrix([\n[1],\n[0]])])]\n```", "```py\ntry:\n P, D = A.diagonalize()\n print(\"Diagonal form:\", D)\nexcept Exception as e:\n print(\"Diagonalization failed:\", e)\n```", "```py\nDiagonalization failed: Matrix is not diagonalizable\n```", "```py\nJ, P = A.jordan_form()\nprint(\"Jordan form J:\")\nprint(J)\nprint(\"P (generalized eigenvectors):\")\nprint(P)\n```", "```py\nJordan form J:\nMatrix([[1, 0], [0, 1]])\nP (generalized eigenvectors):\nMatrix([[2, 1], [0, 2]])\n```", "```py\nA_np = np.array([[2,1],[0,2]], dtype=float)\neigvals, eigvecs = np.linalg.eig(A_np)\nprint(\"Eigenvalues:\", eigvals)\nprint(\"Eigenvectors:\\n\", eigvecs)\n```", "```py\nEigenvalues: [2\\. 2.]\nEigenvectors:\n [[ 1.0000000e+00 -1.0000000e+00]\n [ 0.0000000e+00  4.4408921e-16]]\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nA = np.array([[0.5, 0],\n [0, 0.3]])\n\neigvals = np.linalg.eigvals(A)\nspectral_radius = max(abs(eigvals))\n\nprint(\"Eigenvalues:\", eigvals)\nprint(\"Spectral radius:\", spectral_radius)\n\nprint(\"A^10:\\n\", np.linalg.matrix_power(A, 10))\n```", "```py\nEigenvalues: [0.5 0.3]\nSpectral radius: 0.5\nA^10:\n [[9.765625e-04 0.000000e+00]\n [0.000000e+00 5.904900e-06]]\n```", "```py\nB = np.array([[1.2, 0],\n [0, 0.9]])\n\neigvals = np.linalg.eigvals(B)\nprint(\"Eigenvalues:\", eigvals, \"Spectral radius:\", max(abs(eigvals)))\nprint(\"B^10:\\n\", np.linalg.matrix_power(B, 10))\n```", "```py\nEigenvalues: [1.2 0.9] Spectral radius: 1.2\nB^10:\n [[6.19173642 0\\.        ]\n [0\\.         0.34867844]]\n```", "```py\nR = np.array([[0, -1],\n [1,  0]])\n\neigvals = np.linalg.eigvals(R)\nprint(\"Eigenvalues:\", eigvals)\nprint(\"Spectral radius:\", max(abs(eigvals)))\nprint(\"R^4:\\n\", np.linalg.matrix_power(R, 4))\n```", "```py\nEigenvalues: [0.+1.j 0.-1.j]\nSpectral radius: 1.0\nR^4:\n [[1 0]\n [0 1]]\n```", "```py\nM = Matrix([[2,1],[1,2]])\neigs = M.eigenvals()\nprint(\"Eigenvalues:\", eigs)\nprint(\"Spectral radius:\", max(abs(ev) for ev in eigs))\n```", "```py\nEigenvalues: {3: 1, 1: 1}\nSpectral radius: 3\n```", "```py\nimport numpy as np\nfrom sympy import Matrix\n```", "```py\nP = np.array([\n [0.9, 0.1],\n [0.5, 0.5]\n])\n\nv0 = np.array([1.0, 0.0])  # start in state 1\nfor k in [1, 2, 5, 10, 50]:\n vk = v0 @ np.linalg.matrix_power(P, k)\n print(f\"Step {k}: {vk}\")\n```", "```py\nStep 1: [0.9 0.1]\nStep 2: [0.86 0.14]\nStep 5: [0.83504 0.16496]\nStep 10: [0.83335081 0.16664919]\nStep 50: [0.83333333 0.16666667]\n```", "```py\neigvals, eigvecs = np.linalg.eig(P.T)\nsteady_state = eigvecs[:, np.isclose(eigvals, 1)]\nsteady_state = steady_state / steady_state.sum()\nprint(\"Steady state:\", steady_state.real.flatten())\n```", "```py\nSteady state: [0.83333333 0.16666667]\n```", "```py\nP_sym = Matrix([[0.9,0.1],[0.5,0.5]])\nsteady = P_sym.eigenvects()\nprint(\"Eigen info:\", steady)\n```", "```py\nEigen info: [(1.00000000000000, 1, [Matrix([\n[0.707106781186548],\n[0.707106781186547]])]), (0.400000000000000, 1, [Matrix([\n[-0.235702260395516],\n[  1.17851130197758]])])]\n```", "```py\nQ = np.array([\n [0.3, 0.7, 0.0],\n [0.2, 0.5, 0.3],\n [0.1, 0.2, 0.7]\n])\n\neigvals, eigvecs = np.linalg.eig(Q.T)\nsteady = eigvecs[:, np.isclose(eigvals, 1)]\nsteady = steady / steady.sum()\nprint(\"Steady state for Q:\", steady.real.flatten())\n```", "```py\nSteady state for Q: [0.17647059 0.41176471 0.41176471]\n```", "```py\nimport numpy as np\nfrom sympy import Matrix, exp, symbols\nfrom scipy.linalg import expm\n```", "```py\nA = Matrix([[-1,0],\n [0, 2]])\nt = symbols('t')\nexpAt = (A*t).exp()\nprint(\"e^{At} =\")\nprint(expAt)\n```", "```py\ne^{At} =\nMatrix([[exp(-t), 0], [0, exp(2*t)]])\n```", "```py\nB = Matrix([[0,1],\n [-2,-3]])\nexpBt = (B*t).exp()\nprint(\"e^{Bt} =\")\nprint(expBt)\n```", "```py\ne^{Bt} =\nMatrix([[2*exp(-t) - exp(-2*t), exp(-t) - exp(-2*t)], [-2*exp(-t) + 2*exp(-2*t), -exp(-t) + 2*exp(-2*t)]])\n```", "```py\nimport numpy as np\nfrom scipy.linalg import expm\n\nA = np.array([[-1,0],[0,2]], dtype=float)\nt = 1.0\nprint(\"Matrix exponential e^{At} at t=1:\\n\", expm(A*t))\n```", "```py\nMatrix exponential e^{At} at t=1:\n [[0.36787944 0\\.        ]\n [0\\.         7.3890561 ]]\n```", "```py\nx0 = np.array([1.0, 1.0])\nfor t in [0, 0.5, 1, 2]:\n xt = expm(A*t) @ x0\n print(f\"x({t}) = {xt}\")\n```", "```py\nx(0) = [1\\. 1.]\nx(0.5) = [0.60653066 2.71828183]\nx(1) = [0.36787944 7.3890561 ]\nx(2) = [ 0.13533528 54.59815003]\n```", "```py\nimport numpy as np\n```", "```py\nu = np.array([1,2,3])\nv = np.array([4,5,6])\n\nprint(\"Dot product:\", np.dot(u,v))\n```", "```py\nDot product: 32\n```", "```py\nW = np.array([[2,0,0],\n [0,1,0],\n [0,0,3]])\n\ndef weighted_inner(u,v,W):\n return u.T @ W @ v\n\nprint(\"Weighted inner product:\", weighted_inner(u,v,W))\n```", "```py\nWeighted inner product: 72\n```", "```py\nprint(\"⟨u,v⟩ == ⟨v,u⟩ ?\", weighted_inner(u,v,W) == weighted_inner(v,u,W))\nprint(\"⟨u,u⟩ (should be >0):\", weighted_inner(u,u,W))\n```", "```py\n⟨u,v⟩ == ⟨v,u⟩ ? True\n⟨u,u⟩ (should be >0): 33\n```", "```py\ndef weighted_norm(u,W):\n return np.sqrt(weighted_inner(u,u,W))\n\ncos_theta = weighted_inner(u,v,W) / (weighted_norm(u,W) * weighted_norm(v,W))\nprint(\"Cosine of angle (weighted):\", cos_theta)\n```", "```py\nCosine of angle (weighted): 0.97573875381809\n```", "```py\nx = np.array([2,4,6])\ny = np.array([1,3,5])\n\nx_centered = x - x.mean()\ny_centered = y - y.mean()\n\ncorr_inner = np.dot(x_centered,y_centered)\nprint(\"Correlation-style inner product:\", corr_inner)\n```", "```py\nCorrelation-style inner product: 8.0\n```", "```py\nimport numpy as np\n```", "```py\nu = np.array([1, -1])\nv = np.array([1, 1])\n\nprint(\"Dot product:\", np.dot(u,v))\n```", "```py\nDot product: 0\n```", "```py\ndef normalize(vec):\n return vec / np.linalg.norm(vec)\n\nu_norm = normalize(u)\nv_norm = normalize(v)\n\nprint(\"Normalized u:\", u_norm)\nprint(\"Normalized v:\", v_norm)\n```", "```py\nNormalized u: [ 0.70710678 -0.70710678]\nNormalized v: [0.70710678 0.70710678]\n```", "```py\nbasis = np.column_stack((u_norm, v_norm))\nprint(\"Orthonormal basis:\\n\", basis)\n\nprint(\"Check inner products:\\n\", basis.T @ basis)\n```", "```py\nOrthonormal basis:\n [[ 0.70710678  0.70710678]\n [-0.70710678  0.70710678]]\nCheck inner products:\n [[ 1.00000000e+00 -2.23711432e-17]\n [-2.23711432e-17  1.00000000e+00]]\n```", "```py\nx = np.array([2,3])\ncoords = basis.T @ x\nprint(\"Coordinates in new basis:\", coords)\nprint(\"Reconstruction:\", basis @ coords)\n```", "```py\nCoordinates in new basis: [-0.70710678  3.53553391]\nReconstruction: [2\\. 3.]\n```", "```py\nM = np.random.rand(3,3)\nQ, R = np.linalg.qr(M)\nprint(\"Q (orthonormal basis):\\n\", Q)\nprint(\"Check Q^T Q = I:\\n\", Q.T @ Q)\n```", "```py\nQ (orthonormal basis):\n [[-0.37617518  0.91975919 -0.111961  ]\n [-0.82070726 -0.38684608 -0.42046368]\n [-0.430037   -0.06628079  0.90037494]]\nCheck Q^T Q = I:\n [[1.00000000e+00 5.55111512e-17 5.55111512e-17]\n [5.55111512e-17 1.00000000e+00 3.47849792e-17]\n [5.55111512e-17 3.47849792e-17 1.00000000e+00]]\n```", "```py\nimport numpy as np\n```", "```py\nv1 = np.array([1.0, 1.0, 0.0])\nv2 = np.array([1.0, 0.0, 1.0])\nv3 = np.array([0.0, 1.0, 1.0])\nV = [v1, v2, v3]\n```", "```py\ndef gram_schmidt(V):\n U = []\n for v in V:\n u = v.copy()\n for uj in U:\n u -= np.dot(v, uj) / np.dot(uj, uj) * uj\n U.append(u)\n # Normalize\n E = [u/np.linalg.norm(u) for u in U]\n return np.array(E)\n\nE = gram_schmidt(V)\nprint(\"Orthonormal basis:\\n\", E)\nprint(\"Check orthonormality:\\n\", np.round(E @ E.T, 6))\n```", "```py\nOrthonormal basis:\n [[ 0.70710678  0.70710678  0\\.        ]\n [ 0.40824829 -0.40824829  0.81649658]\n [-0.57735027  0.57735027  0.57735027]]\nCheck orthonormality:\n [[1\\. 0\\. 0.]\n [0\\. 1\\. 0.]\n [0\\. 0\\. 1.]]\n```", "```py\nQ, R = np.linalg.qr(np.column_stack(V))\nprint(\"QR-based orthonormal basis:\\n\", Q)\nprint(\"Check Q^T Q = I:\\n\", np.round(Q.T @ Q, 6))\n```", "```py\nQR-based orthonormal basis:\n [[-0.70710678  0.40824829 -0.57735027]\n [-0.70710678 -0.40824829  0.57735027]\n [-0\\.          0.81649658  0.57735027]]\nCheck Q^T Q = I:\n [[ 1\\.  0\\. -0.]\n [ 0\\.  1\\. -0.]\n [-0\\. -0\\.  1.]]\n```", "```py\nx = np.array([2.0, 2.0, 2.0])\nproj = sum((x @ e) * e for e in E)\nprint(\"Projection of x onto span(V):\", proj)\n```", "```py\nProjection of x onto span(V): [2\\. 2\\. 2.]\n```", "```py\nimport numpy as np\n```", "```py\nu = np.array([1.0,2.0])\nx = np.array([3.0,1.0])\n\nu_norm = u / np.linalg.norm(u)\nproj = np.dot(x, u_norm) * u_norm\nprint(\"Projection of x onto span(u):\", proj)\n```", "```py\nProjection of x onto span(u): [1\\. 2.]\n```", "```py\nu1 = np.array([1.0,0.0,0.0])\nu2 = np.array([0.0,1.0,0.0])\nQ = np.column_stack([u1,u2])   # Orthonormal basis for xy-plane\n\nx = np.array([2.0,3.0,5.0])\nproj = Q @ Q.T @ x\nprint(\"Projection of x onto xy-plane:\", proj)\n```", "```py\nProjection of x onto xy-plane: [2\\. 3\\. 0.]\n```", "```py\nA = np.array([[1,1,0],\n [0,1,1],\n [1,0,1]], dtype=float)\n\nQ, R = np.linalg.qr(A)\nQ = Q[:, :2]   # take first 2 independent columns\nx = np.array([2,2,2], dtype=float)\n\nproj = Q @ Q.T @ x\nprint(\"Projection of x onto span(A):\", proj)\n```", "```py\nProjection of x onto span(A): [2.66666667 1.33333333 1.33333333]\n```", "```py\nimport matplotlib.pyplot as plt\n\nplt.quiver(0,0,x[0],x[1],angles='xy',scale_units='xy',scale=1,color='red',label=\"x\")\nplt.quiver(0,0,proj[0],proj[1],angles='xy',scale_units='xy',scale=1,color='blue',label=\"Projection\")\nplt.quiver(0,0,u[0],u[1],angles='xy',scale_units='xy',scale=1,color='green',label=\"Subspace\")\nplt.axis('equal'); plt.grid(); plt.legend(); plt.show()\n```", "```py\nimport numpy as np\n```", "```py\nA = np.array([[1,1],\n [1,2],\n [1,3]], dtype=float)\nb = np.array([6, 0, 0], dtype=float)\n```", "```py\nx_star, residuals, rank, s = np.linalg.lstsq(A, b, rcond=None)\nprint(\"Least squares solution:\", x_star)\nprint(\"Residual norm squared:\", residuals)\n```", "```py\nLeast squares solution: [ 8\\. -3.]\nResidual norm squared: [6.]\n```", "```py\nx_normal = np.linalg.inv(A.T @ A) @ (A.T @ b)\nprint(\"Solution via normal equations:\", x_normal)\n```", "```py\nSolution via normal equations: [ 8\\. -3.]\n```", "```py\nproj = A @ x_star\nprint(\"Projection of b onto Col(A):\", proj)\nprint(\"Original b:\", b)\nprint(\"Error vector (b - proj):\", b - proj)\n```", "```py\nProjection of b onto Col(A): [ 5\\.  2\\. -1.]\nOriginal b: [6\\. 0\\. 0.]\nError vector (b - proj): [ 1\\. -2\\.  1.]\n```", "```py\nprint(\"Check orthogonality:\", A.T @ (b - A @ x_star))\n```", "```py\nCheck orthogonality: [0\\. 0.]\n```", "```py\nimport numpy as np\n```", "```py\nA = np.array([[1,1],\n [1,2],\n [1,3]], dtype=float)\nb = np.array([6, 0, 0], dtype=float)\n```", "```py\nATA = A.T @ A\nATb = A.T @ b\nx_star = np.linalg.solve(ATA, ATb)\n\nprint(\"Least-squares solution x*:\", x_star)\n```", "```py\nLeast-squares solution x*: [ 8\\. -3.]\n```", "```py\nresidual = b - A @ x_star\nprint(\"Residual vector:\", residual)\nprint(\"Check A^T r ≈ 0:\", A.T @ residual)\n```", "```py\nResidual vector: [ 1\\. -2\\.  1.]\nCheck A^T r ≈ 0: [0\\. 0.]\n```", "```py\nx_lstsq, *_ = np.linalg.lstsq(A, b, rcond=None)\nprint(\"NumPy lstsq solution:\", x_lstsq)\n```", "```py\nNumPy lstsq solution: [ 8\\. -3.]\n```", "```py\nproj = A @ x_star\nprint(\"Projection of b onto Col(A):\", proj)\n```", "```py\nProjection of b onto Col(A): [ 5\\.  2\\. -1.]\n```", "```py\nimport numpy as np\n```", "```py\nA = np.array([[1,1],\n [1,2],\n [1,3]], dtype=float)\nb = np.array([6, 0, 0], dtype=float)\n```", "```py\nQ, R = np.linalg.qr(A)\nprint(\"Q (orthonormal basis):\\n\", Q)\nprint(\"R (upper triangular):\\n\", R)\n```", "```py\nQ (orthonormal basis):\n [[-5.77350269e-01  7.07106781e-01]\n [-5.77350269e-01 -1.73054947e-16]\n [-5.77350269e-01 -7.07106781e-01]]\nR (upper triangular):\n [[-1.73205081 -3.46410162]\n [ 0\\.         -1.41421356]]\n```", "```py\ny = Q.T @ b\nx_star = np.linalg.solve(R[:2,:], y[:2])  # only top rows matter\nprint(\"Least squares solution via QR:\", x_star)\n```", "```py\nLeast squares solution via QR: [ 8\\. -3.]\n```", "```py\nx_lstsq, *_ = np.linalg.lstsq(A, b, rcond=None)\nprint(\"NumPy lstsq:\", x_lstsq)\n```", "```py\nNumPy lstsq: [ 8\\. -3.]\n```", "```py\nresidual = b - A @ x_star\nprint(\"Residual vector:\", residual)\nprint(\"Check orthogonality (Q^T r):\", Q.T @ residual)\n```", "```py\nResidual vector: [ 1\\. -2\\.  1.]\nCheck orthogonality (Q^T r): [0.00000000e+00 3.46109895e-16]\n```", "```py\nimport numpy as np\n```", "```py\nQ = np.array([[0, -1],\n [1,  0]])\n\nprint(\"Q^T Q =\\n\", Q.T @ Q)\n```", "```py\nQ^T Q =\n [[1 0]\n [0 1]]\n```", "```py\nx = np.array([3,4])\nprint(\"Original length:\", np.linalg.norm(x))\nprint(\"Transformed length:\", np.linalg.norm(Q @ x))\n```", "```py\nOriginal length: 5.0\nTransformed length: 5.0\n```", "```py\nu = np.array([1,0])\nv = np.array([0,1])\n\nprint(\"Dot(u,v):\", np.dot(u,v))\nprint(\"Dot(Q u, Q v):\", np.dot(Q @ u, Q @ v))\n```", "```py\nDot(u,v): 0\nDot(Q u, Q v): 0\n```", "```py\nR = np.array([[1,0],\n [0,-1]])\n\nprint(\"R^T R =\\n\", R.T @ R)\nprint(\"Determinant of R:\", np.linalg.det(R))\n```", "```py\nR^T R =\n [[1 0]\n [0 1]]\nDeterminant of R: -1.0\n```", "```py\nM = np.random.rand(3,3)\nQ, _ = np.linalg.qr(M)\nprint(\"Q (random orthogonal):\\n\", Q)\nprint(\"Check Q^T Q ≈ I:\\n\", np.round(Q.T @ Q, 6))\n```", "```py\nQ (random orthogonal):\n [[-0.59472353  0.03725157 -0.80306677]\n [-0.61109913 -0.67000966  0.42147943]\n [-0.52236172  0.74141714  0.42123492]]\nCheck Q^T Q ≈ I:\n [[ 1\\.  0\\. -0.]\n [ 0\\.  1\\. -0.]\n [-0\\. -0\\.  1.]]\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n```", "```py\nt = np.linspace(0, 1, 100, endpoint=False)\nsignal = np.sin(2*np.pi*3*t) + 0.5*np.sin(2*np.pi*5*t)\nplt.plot(t, signal)\nplt.title(\"Signal = sin(3Hz) + 0.5 sin(5Hz)\")\nplt.xlabel(\"Time\")\nplt.ylabel(\"Amplitude\")\nplt.show()\n```", "```py\nX = np.fft.fft(signal)\nfreqs = np.fft.fftfreq(len(t), d=1/100)  # sampling rate = 100Hz\n\nplt.stem(freqs[:50], np.abs(X[:50]), basefmt=\" \")\nplt.title(\"Fourier spectrum\")\nplt.xlabel(\"Frequency (Hz)\")\nplt.ylabel(\"Magnitude\")\nplt.show()\n```", "```py\nsignal_reconstructed = np.fft.ifft(X).real\nprint(\"Reconstruction error:\", np.linalg.norm(signal - signal_reconstructed))\n```", "```py\nReconstruction error: 1.4664679821708477e-15\n```", "```py\nu = np.sin(2*np.pi*3*t)\nv = np.sin(2*np.pi*5*t)\n\ninner = np.dot(u, v)\nprint(\"Inner product of 3Hz and 5Hz sinusoids:\", inner)\n```", "```py\nInner product of 3Hz and 5Hz sinusoids: 1.2961853812498703e-14\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n```", "```py\nnp.random.seed(0)\nx = np.linspace(-3, 3, 30)\ny_true = 1 - 2*x + 0.5*x**2\ny_noisy = y_true + np.random.normal(scale=2.0, size=x.shape)\n\nplt.scatter(x, y_noisy, label=\"Noisy data\")\nplt.plot(x, y_true, \"g--\", label=\"True curve\")\nplt.legend()\nplt.show()\n```", "```py\nA = np.column_stack([np.ones_like(x), x, x**2])\ncoeffs, *_ = np.linalg.lstsq(A, y_noisy, rcond=None)\nprint(\"Fitted coefficients:\", coeffs)\n```", "```py\nFitted coefficients: [ 1.15666306 -2.25753954  0.72733812]\n```", "```py\ny_fit = A @ coeffs\nplt.scatter(x, y_noisy, label=\"Noisy data\")\nplt.plot(x, y_fit, \"r-\", label=\"Fitted quadratic\")\nplt.legend()\nplt.show()\n```", "```py\nA_high = np.column_stack([x**i for i in range(6)])  # degree 5\ncoeffs_high, *_ = np.linalg.lstsq(A_high, y_noisy, rcond=None)\n\ny_fit_high = A_high @ coeffs_high\nplt.scatter(x, y_noisy, label=\"Noisy data\")\nplt.plot(x, y_fit_high, \"r-\", label=\"Degree 5 polynomial\")\nplt.plot(x, y_true, \"g--\", label=\"True curve\")\nplt.legend()\nplt.show()\n```", "```py\nA_multi = np.column_stack([np.ones_like(x), x, x**2, np.sin(x)])\ncoeffs_multi, *_ = np.linalg.lstsq(A_multi, y_noisy, rcond=None)\nprint(\"Multi-feature coefficients:\", coeffs_multi)\n```", "```py\nMulti-feature coefficients: [ 1.15666306 -2.0492999   0.72733812 -0.65902274]\n```", "```py\nimport numpy as np\n```", "```py\nA = np.array([[3,1,1],\n [-1,3,1]])\n\nU, S, Vt = np.linalg.svd(A, full_matrices=True)\n\nprint(\"U:\\n\", U)\nprint(\"Singular values:\", S)\nprint(\"V^T:\\n\", Vt)\n```", "```py\nU:\n [[-0.70710678 -0.70710678]\n [-0.70710678  0.70710678]]\nSingular values: [3.46410162 3.16227766]\nV^T:\n [[-4.08248290e-01 -8.16496581e-01 -4.08248290e-01]\n [-8.94427191e-01  4.47213595e-01  5.27355937e-16]\n [-1.82574186e-01 -3.65148372e-01  9.12870929e-01]]\n```", "```py\nSigma = np.zeros((U.shape[1], Vt.shape[0]))\nSigma[:len(S), :len(S)] = np.diag(S)\n\nA_reconstructed = U @ Sigma @ Vt\nprint(\"Reconstruction error:\", np.linalg.norm(A - A_reconstructed))\n```", "```py\nReconstruction error: 1.5895974606912448e-15\n```", "```py\nrank = np.sum(S > 1e-10)\nprint(\"Rank of A:\", rank)\n```", "```py\nRank of A: 2\n```", "```py\nk = 1\nA_approx = np.outer(U[:,0], Vt[0]) * S[0]\nprint(\"Rank-1 approximation:\\n\", A_approx)\n```", "```py\nRank-1 approximation:\n [[1\\. 2\\. 1.]\n [1\\. 2\\. 1.]]\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n```", "```py\nA = np.array([[2, 1],\n [1, 3]])\n```", "```py\nU, S, Vt = np.linalg.svd(A)\n\nprint(\"U:\\n\", U)\nprint(\"Singular values:\", S)\nprint(\"V^T:\\n\", Vt)\n```", "```py\nU:\n [[-0.52573111 -0.85065081]\n [-0.85065081  0.52573111]]\nSingular values: [3.61803399 1.38196601]\nV^T:\n [[-0.52573111 -0.85065081]\n [-0.85065081  0.52573111]]\n```", "```py\ntheta = np.linspace(0, 2*np.pi, 200)\ncircle = np.vstack((np.cos(theta), np.sin(theta)))\n\ntransformed = A @ circle\n\nplt.plot(circle[0], circle[1], 'b--', label=\"Unit circle\")\nplt.plot(transformed[0], transformed[1], 'r-', label=\"Transformed\")\nplt.axis(\"equal\")\nplt.legend()\nplt.title(\"Action of A on the unit circle\")\nplt.show()\n```", "```py\n# Apply V^T\nstep1 = Vt @ circle\n# Apply Σ\nSigma = np.diag(S)\nstep2 = Sigma @ step1\n# Apply U\nstep3 = U @ step2\n\nplt.plot(circle[0], circle[1], 'b--', label=\"Unit circle\")\nplt.plot(step3[0], step3[1], 'g-', label=\"U Σ V^T circle\")\nplt.axis(\"equal\")\nplt.legend()\nplt.title(\"SVD decomposition of transformation\")\nplt.show()\n```", "```py\nimport numpy as np\n```", "```py\nA = np.array([[2, 0],\n [1, 1],\n [0, 1]])  # shape 3x2\n```", "```py\nU, S, Vt = np.linalg.svd(A)\nprint(\"Singular values:\", S)\n```", "```py\nSingular values: [2.30277564 1.30277564]\n```", "```py\nATA = A.T @ A\neigvals, eigvecs = np.linalg.eig(ATA)\n\nprint(\"Eigenvalues of A^T A:\", eigvals)\nprint(\"Square roots (sorted):\", np.sqrt(np.sort(eigvals)[::-1]))\n```", "```py\nEigenvalues of A^T A: [5.30277564 1.69722436]\nSquare roots (sorted): [2.30277564 1.30277564]\n```", "```py\nAAT = A @ A.T\neigvals2, eigvecs2 = np.linalg.eig(AAT)\n\nprint(\"Eigenvalues of A A^T:\", eigvals2)\nprint(\"Square roots:\", np.sqrt(np.sort(eigvals2)[::-1]))\n```", "```py\nEigenvalues of A A^T: [ 5.30277564e+00  1.69722436e+00 -2.01266546e-17]\nSquare roots: [2.30277564 1.30277564        nan]\n```", "```py\n/var/folders/_g/lq_pglm508df70x751kkxrl80000gp/T/ipykernel_31637/436251338.py:5: RuntimeWarning: invalid value encountered in sqrt\n  print(\"Square roots:\", np.sqrt(np.sort(eigvals2)[::-1]))\n```", "```py\nprint(\"Right singular vectors (V):\\n\", Vt.T)\nprint(\"Eigenvectors of A^T A:\\n\", eigvecs)\n\nprint(\"Left singular vectors (U):\\n\", U)\nprint(\"Eigenvectors of A A^T:\\n\", eigvecs2)\n```", "```py\nRight singular vectors (V):\n [[-0.95709203  0.28978415]\n [-0.28978415 -0.95709203]]\nEigenvectors of A^T A:\n [[ 0.95709203 -0.28978415]\n [ 0.28978415  0.95709203]]\nLeft singular vectors (U):\n [[-0.83125078  0.44487192  0.33333333]\n [-0.54146663 -0.51222011 -0.66666667]\n [-0.12584124 -0.73465607  0.66666667]]\nEigenvectors of A A^T:\n [[-0.83125078  0.44487192  0.33333333]\n [-0.54146663 -0.51222011 -0.66666667]\n [-0.12584124 -0.73465607  0.66666667]]\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n```", "```py\nnp.random.seed(0)\nU = np.random.randn(50, 5)   # 50 x 5\nV = np.random.randn(5, 30)   # 5 x 30\nA = U @ V  # true rank ≤ 5\n```", "```py\nU, S, Vt = np.linalg.svd(A, full_matrices=False)\nprint(\"Singular values:\", S[:10])\n```", "```py\nSingular values: [4.90672194e+01 4.05935057e+01 3.39228766e+01 3.07883338e+01\n 2.29261740e+01 3.97150036e-15 3.97150036e-15 3.97150036e-15\n 3.97150036e-15 3.97150036e-15]\n```", "```py\nk = 1\nA1 = U[:, :k] @ np.diag(S[:k]) @ Vt[:k, :]\nerror1 = np.linalg.norm(A - A1)\nprint(\"Rank-1 approximation error:\", error1)\n```", "```py\nRank-1 approximation error: 65.36149641872869\n```", "```py\nk = 5\nA5 = U[:, :k] @ np.diag(S[:k]) @ Vt[:k, :]\nerror5 = np.linalg.norm(A - A5)\nprint(\"Rank-5 approximation error:\", error5)\n```", "```py\nRank-5 approximation error: 5.756573247253659e-14\n```", "```py\nfrom sklearn.datasets import load_digits\ndigits = load_digits()\nimg = digits.images[0]  # 8x8 grayscale digit\n\nU, S, Vt = np.linalg.svd(img, full_matrices=False)\n\n# Keep only top 2 singular values\nk = 2\nimg2 = U[:, :k] @ np.diag(S[:k]) @ Vt[:k, :]\n\nplt.subplot(1,2,1)\nplt.imshow(img, cmap=\"gray\")\nplt.title(\"Original\")\n\nplt.subplot(1,2,2)\nplt.imshow(img2, cmap=\"gray\")\nplt.title(\"Rank-2 Approximation\")\nplt.show()\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.datasets import load_digits\n```", "```py\nnp.random.seed(0)\nX = np.random.randn(200, 2) @ np.array([[3,1],[1,0.5]])  # stretched cloud\n\nplt.scatter(X[:,0], X[:,1], alpha=0.3)\nplt.title(\"Original data\")\nplt.axis(\"equal\")\nplt.show()\n```", "```py\nX_centered = X - X.mean(axis=0)\n```", "```py\nU, S, Vt = np.linalg.svd(X_centered, full_matrices=False)\nprint(\"Principal directions (V):\\n\", Vt)\n```", "```py\nPrincipal directions (V):\n [[-0.94430098 -0.32908307]\n [ 0.32908307 -0.94430098]]\n```", "```py\nX_pca1 = X_centered @ Vt.T[:,0]\n\nplt.scatter(X_pca1, np.zeros_like(X_pca1), alpha=0.3)\nplt.title(\"Data projected on first principal component\")\nplt.show()\n```", "```py\nplt.scatter(X_centered[:,0], X_centered[:,1], alpha=0.3)\nfor length, vector in zip(S, Vt):\n plt.plot([0, vector[0]*length], [0, vector[1]*length], 'r-', linewidth=3)\nplt.title(\"Principal components (directions of max variance)\")\nplt.axis(\"equal\")\nplt.show()\n```", "```py\ndigits = load_digits()\nX = digits.data  # 1797 samples, 64 features\nX_centered = X - X.mean(axis=0)\n\nU, S, Vt = np.linalg.svd(X_centered, full_matrices=False)\n\nexplained_variance = (S**2) / np.sum(S**2)\nprint(\"Explained variance ratio (first 5):\", explained_variance[:5])\n```", "```py\nExplained variance ratio (first 5): [0.14890594 0.13618771 0.11794594 0.08409979 0.05782415]\n```", "```py\nimport numpy as np\n```", "```py\nA = np.array([[1,1],\n [1,2],\n [1,3]])  # 3x2 system\nb = np.array([1,2,2])\n\nx_ls, *_ = np.linalg.lstsq(A, b, rcond=None)\nprint(\"Least-squares solution:\", x_ls)\n```", "```py\nLeast-squares solution: [0.66666667 0.5       ]\n```", "```py\nA_pinv = np.linalg.pinv(A)\nx_pinv = A_pinv @ b\nprint(\"Pseudoinverse solution:\", x_pinv)\n```", "```py\nPseudoinverse solution: [0.66666667 0.5       ]\n```", "```py\nA = np.array([[1,2,3]])  # 1x3\nb = np.array([1])\n\nx_pinv = np.linalg.pinv(A) @ b\nprint(\"Minimum norm solution:\", x_pinv)\n```", "```py\nMinimum norm solution: [0.07142857 0.14285714 0.21428571]\n```", "```py\nA = np.array([[1,2],\n [2,4]])  # rank deficient\nb = np.array([1,2])\n\nx_pinv = np.linalg.pinv(A) @ b\nprint(\"Solution with pseudoinverse:\", x_pinv)\n```", "```py\nSolution with pseudoinverse: [0.2 0.4]\n```", "```py\nA = np.array([[1,2],\n [3,4]])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.zeros((Vt.shape[0], U.shape[0]))\nfor i in range(len(S)):\n if S[i] > 1e-10:\n S_inv[i,i] = 1/S[i]\n\nA_pinv_manual = Vt.T @ S_inv @ U.T\nprint(\"Manual pseudoinverse:\\n\", A_pinv_manual)\nprint(\"NumPy pseudoinverse:\\n\", np.linalg.pinv(A))\n```", "```py\nManual pseudoinverse:\n [[-2\\.   1\\. ]\n [ 1.5 -0.5]]\nNumPy pseudoinverse:\n [[-2\\.   1\\. ]\n [ 1.5 -0.5]]\n```", "```py\nimport numpy as np\n```", "```py\nA = np.array([[2,0],\n [0,1]])\nb = np.array([1,1])\n\nx = np.linalg.solve(A, b)\ncond = np.linalg.cond(A)\nprint(\"Solution:\", x)\nprint(\"Condition number:\", cond)\n```", "```py\nSolution: [0.5 1\\. ]\nCondition number: 2.0\n```", "```py\nA = np.array([[1, 1.0001],\n [1, 1.0000]])\nb = np.array([2,2])\n\nx = np.linalg.lstsq(A, b, rcond=None)[0]\ncond = np.linalg.cond(A)\nprint(\"Solution:\", x)\nprint(\"Condition number:\", cond)\n```", "```py\nSolution: [ 2.00000000e+00 -5.73526099e-13]\nCondition number: 40002.000075017124\n```", "```py\nb2 = np.array([2, 2.001])  # tiny change\nx2 = np.linalg.lstsq(A, b2, rcond=None)[0]\nprint(\"Solution after tiny change:\", x2)\n```", "```py\nSolution after tiny change: [ 12.001 -10\\.   ]\n```", "```py\nU, S, Vt = np.linalg.svd(A)\nprint(\"Singular values:\", S)\nprint(\"Condition number (SVD):\", S[0]/S[-1])\n```", "```py\nSingular values: [2.000050e+00 4.999875e-05]\nCondition number (SVD): 40002.00007501713\n```", "```py\nfor scale in [1,1e-2,1e-4,1e-6]:\n A = np.array([[1,0],[0,scale]])\n print(f\"Scale={scale}, condition number={np.linalg.cond(A)}\")\n```", "```py\nScale=1, condition number=1.0\nScale=0.01, condition number=100.0\nScale=0.0001, condition number=10000.0\nScale=1e-06, condition number=1000000.0\n```", "```py\nimport numpy as np\n```", "```py\nA = np.array([[1, -2, 3],\n [0,  4, 5],\n [-1, 2, 1]])\n```", "```py\nfro = np.linalg.norm(A, 'fro')\nspec = np.linalg.norm(A, 2)\none_norm = np.linalg.norm(A, 1)\ninf_norm = np.linalg.norm(A, np.inf)\n\nprint(\"Frobenius norm:\", fro)\nprint(\"Spectral norm:\", spec)\nprint(\"1-norm:\", one_norm)\nprint(\"Infinity norm:\", inf_norm)\n```", "```py\nFrobenius norm: 7.810249675906654\nSpectral norm: 6.813953458914004\n1-norm: 9.0\nInfinity norm: 9.0\n```", "```py\nU, S, Vt = np.linalg.svd(A)\nprint(\"Largest singular value:\", S[0])\nprint(\"Spectral norm:\", spec)\n```", "```py\nLargest singular value: 6.813953458914004\nSpectral norm: 6.813953458914004\n```", "```py\nfro_from_svd = np.sqrt(np.sum(S**2))\nprint(\"Frobenius norm (from SVD):\", fro_from_svd)\n```", "```py\nFrobenius norm (from SVD): 7.810249675906654\n```", "```py\nx = np.random.randn(3)\nstretch = np.linalg.norm(A @ x) / np.linalg.norm(x)\nprint(\"Stretch factor:\", stretch)\nprint(\"Spectral norm (max possible stretch):\", spec)\n```", "```py\nStretch factor: 2.7537463268177698\nSpectral norm (max possible stretch): 6.813953458914004\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n```", "```py\nA = np.array([[1, 1.001],\n [1, 0.999]])\nb = np.array([2, 2])\n```", "```py\nx_ls, *_ = np.linalg.lstsq(A, b, rcond=None)\nprint(\"Least squares solution:\", x_ls)\n```", "```py\nLeast squares solution: [ 2.00000000e+00 -2.84186735e-14]\n```", "```py\nlam = 0.1\nx_ridge = np.linalg.inv(A.T @ A + lam*np.eye(2)) @ A.T @ b\nprint(\"Ridge solution (λ=0.1):\", x_ridge)\n```", "```py\nRidge solution (λ=0.1): [0.97561927 0.97559976]\n```", "```py\nlambdas = np.logspace(-4, 2, 20)\nsolutions = []\nfor lam in lambdas:\n x_reg = np.linalg.inv(A.T @ A + lam*np.eye(2)) @ A.T @ b\n solutions.append(np.linalg.norm(x_reg))\n\nplt.semilogx(lambdas, solutions, 'o-')\nplt.xlabel(\"λ (regularization strength)\")\nplt.ylabel(\"Solution norm\")\nplt.title(\"Effect of ridge regularization\")\nplt.show()\n```", "```py\nimport numpy as np\nfrom scipy.linalg import qr\n```", "```py\nA = np.array([[1, 2, 3],\n [2, 4.001, 6],\n [3, 6, 9.001]])\nprint(\"Rank (theoretical):\", np.linalg.matrix_rank(A))\n```", "```py\nRank (theoretical): 3\n```", "```py\nQ, R, P = qr(A, pivoting=True)\nprint(\"R:\\n\", R)\nprint(\"Column permutation:\", P)\n```", "```py\nR:\n [[-1.12257740e+01 -7.48384925e+00 -3.74165738e+00]\n [ 0.00000000e+00 -1.20185042e-03 -1.84886859e-04]\n [ 0.00000000e+00  0.00000000e+00 -7.41196374e-05]]\nColumn permutation: [2 1 0]\n```", "```py\nU, S, Vt = np.linalg.svd(A)\nprint(\"Singular values:\", S)\n```", "```py\nSingular values: [1.40009286e+01 1.00000000e-03 7.14238341e-05]\n```", "```py\ntol = 1e-3\nrank_est = np.sum(S > tol)\nprint(\"Estimated rank:\", rank_est)\n```", "```py\nEstimated rank: 2\n```", "```py\nnp.random.seed(0)\nB = np.random.randn(50, 10) @ np.random.randn(10, 10)  # rank ≤ 10\nB[:, -1] += 1e-6 * np.random.randn(50)  # tiny noise\n\nU, S, Vt = np.linalg.svd(B)\nplt.semilogy(S, 'o-')\nplt.title(\"Singular values (log scale)\")\nplt.xlabel(\"Index\")\nplt.ylabel(\"Value\")\nplt.show()\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n```", "```py\ntheta = np.pi/4  # 45 degrees\nR = np.array([[np.cos(theta), -np.sin(theta)],\n [np.sin(theta),  np.cos(theta)]])\n\npoint = np.array([1, 0])\nrotated = R @ point\n\nprint(\"Original:\", point)\nprint(\"Rotated:\", rotated)\n```", "```py\nOriginal: [1 0]\nRotated: [0.70710678 0.70710678]\n```", "```py\nT = np.array([[1,0,2],\n [0,1,1],\n [0,0,1]])\n\np_h = np.array([1,1,1])  # homogeneous (x=1,y=1)\ntranslated = T @ p_h\nprint(\"Translated point:\", translated)\n```", "```py\nTranslated point: [3 2 1]\n```", "```py\nM = T @ np.block([[R, np.zeros((2,1))],\n [np.zeros((1,2)), 1]])\ncombined = M @ p_h\nprint(\"Combined transform (rotation+translation):\", combined)\n```", "```py\nCombined transform (rotation+translation): [2\\.         2.41421356 1\\.        ]\n```", "```py\ntheta = np.pi/3\nRz = np.array([[np.cos(theta), -np.sin(theta), 0],\n [np.sin(theta),  np.cos(theta), 0],\n [0,              0,             1]])\n\npoint3d = np.array([1,0,0])\nrotated3d = Rz @ point3d\nprint(\"3D rotated point:\", rotated3d)\n```", "```py\n3D rotated point: [0.5       0.8660254 0\\.       ]\n```", "```py\nf = 1.0  # focal length\nP = np.array([[f,0,0],\n [0,f,0],\n [0,0,1]])  # projection matrix\n\npoint3d = np.array([2,3,5])\np_proj = P @ point3d\np_proj = p_proj[:2] / p_proj[2]  # divide by z\nprint(\"Projected 2D point:\", p_proj)\n```", "```py\nProjected 2D point: [0.4 0.6]\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n```", "```py\np = np.array([1,2,3,1])  # homogeneous point\n```", "```py\nT = np.array([[1,0,0,2],\n [0,1,0,1],\n [0,0,1,3],\n [0,0,0,1]])\n```", "```py\nS = np.diag([2, 0.5, 1.5, 1])\n```", "```py\ntheta = np.pi/2\nRz = np.array([[np.cos(theta), -np.sin(theta), 0, 0],\n [np.sin(theta),  np.cos(theta), 0, 0],\n [0,              0,             1, 0],\n [0,              0,             0, 1]])\n```", "```py\nM = T @ Rz @ S  # first scale, then rotate, then translate\np_transformed = M @ p\nprint(\"Transformed point:\", p_transformed)\n```", "```py\nTransformed point: [1\\.  3\\.  7.5 1\\. ]\n```", "```py\ndef link(theta, length):\n return np.array([[np.cos(theta), -np.sin(theta), 0, length*np.cos(theta)],\n [np.sin(theta),  np.cos(theta), 0, length*np.sin(theta)],\n [0,              0,             1, 0],\n [0,              0,             0, 1]])\n\ntheta1, theta2 = np.pi/4, np.pi/6\nL1, L2 = 2, 1.5\n\nM1 = link(theta1, L1)\nM2 = link(theta2, L2)\n\nend_effector = M1 @ M2 @ np.array([0,0,0,1])\nprint(\"End effector position:\", end_effector[:3])\n```", "```py\nEnd effector position: [1.80244213 2.8631023  0\\.        ]\n```", "```py\nf = 2.0\nP = np.array([[f,0,0,0],\n [0,f,0,0],\n [0,0,1,0]])\n\ncube = np.array([[x,y,z,1] for x in [0,1] for y in [0,1] for z in [0,1]])\nproj = (P @ cube.T).T\nproj2d = proj[:,:2] / proj[:,2:3]\n\nplt.scatter(proj2d[:,0], proj2d[:,1])\nplt.title(\"Projected cube\")\nplt.show()\n```", "```py\n/var/folders/_g/lq_pglm508df70x751kkxrl80000gp/T/ipykernel_31637/2038614107.py:8: RuntimeWarning: divide by zero encountered in divide\n  proj2d = proj[:,:2] / proj[:,2:3]\n/var/folders/_g/lq_pglm508df70x751kkxrl80000gp/T/ipykernel_31637/2038614107.py:8: RuntimeWarning: invalid value encountered in divide\n  proj2d = proj[:,:2] / proj[:,2:3]\n```", "```py\nimport numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n```", "```py\nG = nx.Graph()\nG.add_edges_from([(0,1), (1,2), (2,3), (3,0), (0,2)])  # square with diagonal\n\nnx.draw(G, with_labels=True, node_color=\"lightblue\", node_size=800)\nplt.show()\n```", "```py\nA = nx.to_numpy_array(G)\nprint(\"Adjacency matrix:\\n\", A)\n```", "```py\nAdjacency matrix:\n [[0\\. 1\\. 1\\. 1.]\n [1\\. 0\\. 1\\. 0.]\n [1\\. 1\\. 0\\. 1.]\n [1\\. 0\\. 1\\. 0.]]\n```", "```py\nD = np.diag(A.sum(axis=1))\nL = D - A\nprint(\"Degree matrix:\\n\", D)\nprint(\"Graph Laplacian:\\n\", L)\n```", "```py\nDegree matrix:\n [[3\\. 0\\. 0\\. 0.]\n [0\\. 2\\. 0\\. 0.]\n [0\\. 0\\. 3\\. 0.]\n [0\\. 0\\. 0\\. 2.]]\nGraph Laplacian:\n [[ 3\\. -1\\. -1\\. -1.]\n [-1\\.  2\\. -1\\.  0.]\n [-1\\. -1\\.  3\\. -1.]\n [-1\\.  0\\. -1\\.  2.]]\n```", "```py\neigvals, eigvecs = np.linalg.eigh(L)\nprint(\"Laplacian eigenvalues:\", eigvals)\n```", "```py\nLaplacian eigenvalues: [1.11022302e-16 2.00000000e+00 4.00000000e+00 4.00000000e+00]\n```", "```py\ncoords = eigvecs[:,1:3]  # skip the trivial first eigenvector\nplt.scatter(coords[:,0], coords[:,1], c=range(len(coords)), cmap=\"tab10\", s=200)\nfor i, (x,y) in enumerate(coords):\n plt.text(x, y, str(i), fontsize=12, ha=\"center\", va=\"center\", color=\"white\")\nplt.title(\"Spectral embedding of graph\")\nplt.show()\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n```", "```py\nnp.random.seed(0)\nX = np.random.randn(200, 2) @ np.array([[3,1],[1,0.5]])\nplt.scatter(X[:,0], X[:,1], alpha=0.4)\nplt.title(\"Original correlated data\")\nplt.axis(\"equal\")\nplt.show()\n```", "```py\nX_centered = X - X.mean(axis=0)\nprint(\"Mean after centering:\", X_centered.mean(axis=0))\n```", "```py\nMean after centering: [ 8.88178420e-18 -1.22124533e-17]\n```", "```py\nX_scaled = X_centered / X_centered.std(axis=0)\nprint(\"Std after scaling:\", X_scaled.std(axis=0))\n```", "```py\nStd after scaling: [1\\. 1.]\n```", "```py\nC = np.cov(X_centered.T)\neigvals, eigvecs = np.linalg.eigh(C)\n\nW = eigvecs @ np.diag(1/np.sqrt(eigvals)) @ eigvecs.T\nX_white = X_centered @ W\n```", "```py\nprint(\"Whitened covariance:\\n\", np.cov(X_white.T))\n```", "```py\nWhitened covariance:\n [[1.00000000e+00 2.54402864e-15]\n [2.54402864e-15 1.00000000e+00]]\n```", "```py\nplt.subplot(1,3,1)\nplt.scatter(X[:,0], X[:,1], alpha=0.4)\nplt.title(\"Original\")\n\nplt.subplot(1,3,2)\nplt.scatter(X_scaled[:,0], X_scaled[:,1], alpha=0.4)\nplt.title(\"Scaled\")\n\nplt.subplot(1,3,3)\nplt.scatter(X_white[:,0], X_white[:,1], alpha=0.4)\nplt.title(\"Whitened\")\n\nplt.tight_layout()\nplt.show()\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.datasets import make_classification\n```", "```py\nnp.random.seed(0)\nX = np.linspace(0, 10, 30).reshape(-1,1)\ny = 3*X.squeeze() + 5 + np.random.randn(30)*2\n```", "```py\nX_design = np.column_stack([np.ones_like(X), X])\nbeta_hat, *_ = np.linalg.lstsq(X_design, y, rcond=None)\nprint(\"Fitted coefficients:\", beta_hat)\n```", "```py\nFitted coefficients: [6.65833151 2.84547628]\n```", "```py\ny_pred = X_design @ beta_hat\n\nplt.scatter(X, y, label=\"Data\")\nplt.plot(X, y_pred, 'r-', label=\"Fitted line\")\nplt.legend()\nplt.show()\n```", "```py\nXc, yc = make_classification(n_features=2, n_redundant=0, n_informative=2,\n n_clusters_per_class=1, n_samples=100, random_state=0)\n\nplt.scatter(Xc[:,0], Xc[:,1], c=yc, cmap=\"bwr\", alpha=0.7)\nplt.title(\"Classification data\")\nplt.show()\n```", "```py\ndef sigmoid(z):\n return 1/(1+np.exp(-z))\n\nX_design = np.column_stack([np.ones(len(Xc)), Xc])\ny = yc\n\nw = np.zeros(X_design.shape[1])\nlr = 0.1\n\nfor _ in range(2000):\n preds = sigmoid(X_design @ w)\n grad = X_design.T @ (preds - y) / len(y)\n w -= lr * grad\n\nprint(\"Learned weights:\", w)\n```", "```py\nLearned weights: [-2.10451116  0.70752542  4.13295129]\n```", "```py\nxx, yy = np.meshgrid(np.linspace(Xc[:,0].min()-1, Xc[:,0].max()+1, 200),\n np.linspace(Xc[:,1].min()-1, Xc[:,1].max()+1, 200))\n\ngrid = np.c_[np.ones(xx.size), xx.ravel(), yy.ravel()]\nprobs = sigmoid(grid @ w).reshape(xx.shape)\n\nplt.contourf(xx, yy, probs, levels=[0,0.5,1], alpha=0.3, cmap=\"bwr\")\nplt.scatter(Xc[:,0], Xc[:,1], c=yc, cmap=\"bwr\", edgecolor=\"k\")\nplt.title(\"Linear decision boundary\")\nplt.show()\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.datasets import load_digits\n```", "```py\ndigits = load_digits()\nX = digits.data  # shape (1797, 64)\ny = digits.target\nprint(\"Data shape:\", X.shape)\n```", "```py\nData shape: (1797, 64)\n```", "```py\nX_centered = X - X.mean(axis=0)\n```", "```py\nU, S, Vt = np.linalg.svd(X_centered, full_matrices=False)\nexplained_variance = (S**2) / (len(X) - 1)\nexplained_ratio = explained_variance / explained_variance.sum()\n```", "```py\nplt.plot(np.cumsum(explained_ratio[:30]), 'o-')\nplt.xlabel(\"Number of components\")\nplt.ylabel(\"Cumulative explained variance\")\nplt.title(\"PCA explained variance\")\nplt.grid(True)\nplt.show()\n```", "```py\nX_pca2 = X_centered @ Vt[:2].T\nplt.scatter(X_pca2[:,0], X_pca2[:,1], c=y, cmap=\"tab10\", alpha=0.6, s=15)\nplt.colorbar()\nplt.title(\"Digits dataset (PCA 2D projection)\")\nplt.show()\n```", "```py\nk = 20\nX_pca20 = X_centered @ Vt[:k].T\nX_reconstructed = X_pca20 @ Vt[:k]\n\nfig, axes = plt.subplots(2, 10, figsize=(10,2))\nfor i in range(10):\n axes[0,i].imshow(X[i].reshape(8,8), cmap=\"gray\")\n axes[0,i].axis(\"off\")\n axes[1,i].imshow(X_reconstructed[i].reshape(8,8), cmap=\"gray\")\n axes[1,i].axis(\"off\")\nplt.suptitle(\"Original (top) vs PCA reconstruction (bottom, 20 comps)\")\nplt.show()\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n```", "```py\nnp.random.seed(0)\ntrue_users = np.random.randn(10, 3)   # 10 users, 3 latent features\ntrue_items = np.random.randn(3, 8)    # 8 items\nR_full = true_users @ true_items      # true low-rank ratings\n```", "```py\nmask = np.random.rand(*R_full.shape) > 0.3  # keep 70% of entries\nR_obs = np.where(mask, R_full, np.nan)\n\nprint(\"Observed ratings:\\n\", R_obs)\n```", "```py\nObserved ratings:\n [[-1.10781465         nan -3.56526968         nan -2.1729387   1.43510077\n   1.46641178  0.79023284]\n [ 0.84819453         nan         nan         nan         nan         nan\n   2.30434358  3.03008138]\n [        nan  0.32479187 -0.51818422         nan  0.02013802         nan\n   1.29874918  1.33053637]\n [-1.81407786  1.24241182         nan -1.32723907         nan         nan\n  -0.31110699         nan]\n [-0.48527696         nan -1.51957106         nan -0.86984941  0.52807989\n          nan  0.33771451]\n [-0.26997359 -0.48498966         nan -2.73891459 -2.48167957  2.88740609\n  -0.24614835         nan]\n [ 3.57769701 -1.608339    4.73789234  1.13583164  3.63451505 -2.60495928\n   2.12453635  3.76472563]\n [ 0.69623809 -0.59117353 -0.28890188 -2.36431192         nan  1.50136796\n   0.74268078         nan]\n [ 0.85768141  1.33357168         nan         nan  1.65089037 -2.46456289\n   3.51030491  3.31220347]\n [-2.463496    0.60826298 -3.81241599 -2.11839267 -3.86597359  3.52934055\n  -1.76203083 -2.63130953]]\n```", "```py\nR_mean = np.where(np.isnan(R_obs), np.nanmean(R_obs), R_obs)\n```", "```py\n# Replace NaNs with zeros for SVD step\nR_filled = np.nan_to_num(R_obs, nan=0.0)\n\nU, S, Vt = np.linalg.svd(R_filled, full_matrices=False)\n\nk = 3  # latent dimension\nR_approx = U[:, :k] @ np.diag(S[:k]) @ Vt[:k, :]\n```", "```py\nerror = np.nanmean((R_full - R_approx)**2)\nprint(\"Approximation error (MSE):\", error)\n```", "```py\nApproximation error (MSE): 1.4862378490976202\n```", "```py\nfig, axes = plt.subplots(1, 2, figsize=(8,4))\naxes[0].imshow(R_full, cmap=\"viridis\")\naxes[0].set_title(\"True ratings\")\naxes[1].imshow(R_approx, cmap=\"viridis\")\naxes[1].set_title(\"Low-rank approximation\")\nplt.show()\n```", "```py\nimport numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n```", "```py\nG = nx.DiGraph()\nG.add_edges_from([\n (0,1), (1,2), (2,0),  # cycle among 0–1–2\n (2,3), (3,2),         # back-and-forth 2–3\n (1,3), (3,4), (4,1)   # small loop with 1–3–4\n])\nnx.draw_circular(G, with_labels=True, node_color=\"lightblue\", node_size=800, arrowsize=15)\nplt.show()\n```", "```py\nn = G.number_of_nodes()\nA = nx.to_numpy_array(G, nodelist=range(n))\nP = A / A.sum(axis=1, keepdims=True)  # row-stochastic transition matrix\n```", "```py\nalpha = 0.85  # damping factor\nG_matrix = alpha * P + (1 - alpha) * np.ones((n,n)) / n\n```", "```py\nr = np.ones(n) / n  # start uniform\nfor _ in range(100):\n r = r @ G_matrix\nr /= r.sum()\nprint(\"PageRank vector:\", r)\n```", "```py\nPageRank vector: [0.13219034 0.25472358 0.24044787 0.24044787 0.13219034]\n```", "```py\npr = nx.pagerank(G, alpha=alpha)\nprint(\"NetworkX PageRank:\", pr)\n```", "```py\nNetworkX PageRank: {0: 0.13219008157546333, 1: 0.2547244023837789, 2: 0.24044771723264727, 3: 0.24044771723264727, 4: 0.13219008157546333}\n```", "```py\nsizes = [5000 * r_i for r_i in r]\nnx.draw_circular(G, with_labels=True, node_size=sizes, node_color=\"lightblue\", arrowsize=15)\nplt.title(\"PageRank visualization (node size ~ importance)\")\nplt.show()\n```", "```py\nimport numpy as np\n```", "```py\neps = np.finfo(float).eps\nprint(\"Machine epsilon:\", eps)\n```", "```py\nMachine epsilon: 2.220446049250313e-16\n```", "```py\na = 1e16\nb = 1.0\nprint(\"a + b - a:\", (a + b) - a)  # may lose b due to precision limits\n```", "```py\na + b - a: 0.0\n```", "```py\nA = np.array([[1, 1.0001], [1.0001, 1]])\nb = np.array([2, 2.0001])\n\nx_direct = np.linalg.solve(A, b)\nx_via_inv = np.linalg.inv(A) @ b\n\nprint(\"Solve:\", x_direct)\nprint(\"Inverse method:\", x_via_inv)\n```", "```py\nSolve: [1.499975 0.499975]\nInverse method: [1.499975 0.499975]\n```", "```py\ncond = np.linalg.cond(A)\nprint(\"Condition number:\", cond)\n```", "```py\nCondition number: 20001.00000000417\n```", "```py\nA = np.random.randn(500, 500)\nB = np.random.randn(500, 500)\n\n# Matrix multiplication (calls optimized BLAS under the hood)\nC = A @ B\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom skimage import data, color\n\n# Load grayscale image\nimg = color.rgb2gray(data.astronaut())\nU, S, Vt = np.linalg.svd(img, full_matrices=False)\n\n# Approximate with rank-k\nk = 50\nimg_approx = U[:, :k] @ np.diag(S[:k]) @ Vt[:k, :]\n\nplt.subplot(1,2,1)\nplt.imshow(img, cmap=\"gray\")\nplt.title(\"Original\")\nplt.axis(\"off\")\n\nplt.subplot(1,2,2)\nplt.imshow(img_approx, cmap=\"gray\")\nplt.title(f\"Rank-{k} Approximation\")\nplt.axis(\"off\")\n\nplt.show()\n```", "```py\nfrom sklearn.datasets import load_diabetes\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.decomposition import PCA\n\n# Load dataset\nX, y = load_diabetes(return_X_y=True)\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0)\n\n# PCA reduce features\npca = PCA(n_components=5)\nX_train_pca = pca.fit_transform(X_train)\nX_test_pca = pca.transform(X_test)\n\n# Regression on reduced space\nmodel = LinearRegression().fit(X_train_pca, y_train)\nprint(\"R^2 on test set:\", model.score(X_test_pca, y_test))\n```", "```py\nR^2 on test set: 0.3691398497153573\n```", "```py\nimport networkx as nx\n\nG = nx.barabasi_albert_graph(20, 2)  # 20 nodes, scale-free graph\npr = nx.pagerank(G, alpha=0.85)\n\nnx.draw(G, with_labels=True, node_size=[5000*pr[n] for n in G], node_color=\"lightblue\")\nplt.title(\"PageRank on a scale-free graph\")\nplt.show()\n```", "```py\nA = np.array([[0,1],[-2,-3]])\neigvals, eigvecs = np.linalg.eig(A)\n\nprint(\"Eigenvalues:\", eigvals)\nprint(\"Eigenvectors:\\n\", eigvecs)\n```", "```py\nEigenvalues: [-1\\. -2.]\nEigenvectors:\n [[ 0.70710678 -0.4472136 ]\n [-0.70710678  0.89442719]]\n```", "```py\nnp.random.seed(0)\nX = np.random.randn(100, 3)\nbeta_true = np.array([2, -1, 0.5])\ny = X @ beta_true + np.random.randn(100)*0.1\n\nbeta_hat, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(\"Estimated coefficients:\", beta_hat)\n```", "```py\nEstimated coefficients: [ 1.99371939 -1.00708947  0.50661857]\n```"]