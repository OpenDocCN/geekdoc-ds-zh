- en: 9.1¬†From Pyret to Pythonüîó
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://dcic-world.org/2025-08-27/intro-python.html](https://dcic-world.org/2025-08-27/intro-python.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| ¬†¬†¬†¬†[9.1.1¬†Expressions, Functions, and Types](#%28part._.Expressions__.Functions__and_.Types%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[9.1.2¬†Returning Values from Functions](#%28part._.Returning_.Values_from_.Functions%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[9.1.3¬†Examples and Test Cases](#%28part._testing-python%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[9.1.4¬†An Aside on Numbers](#%28part._.An_.Aside_on_.Numbers%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[9.1.5¬†Conditionals](#%28part._conditionals-python%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[9.1.6¬†Creating and Processing Lists](#%28part._python-create-process-lists%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[9.1.6.1¬†Filters, Maps, and Friends](#%28part._.Filters__.Maps__and_.Friends%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[9.1.7¬†Data with Components](#%28part._python-data-with-components%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[9.1.7.1¬†Accessing Fields within Dataclasses](#%28part._.Accessing_.Fields_within_.Dataclasses%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[9.1.8¬†Traversing Lists](#%28part._python-traverse-lists%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[9.1.8.1¬†Introducing `For` Loops](#%28part._python-for-loops%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[9.1.8.2¬†An Aside on Order of Processing List Elements](#%28part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[9.1.8.3¬†Using `For` Loops in Functions that Produce Lists](#%28part._python-funcs-produce-lists%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[9.1.8.4¬†Summary: The List-Processing Template for Python](#%28part._.Summary__.The_.List-.Processing_.Template_for_.Python%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[9.1.8.5¬†`for each` loops in Pyret](#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†¬†¬†[9.1.8.5.1¬†Variables that can change](#%28part._.Variables_that_can_change%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†¬†¬†[9.1.8.5.2¬†block notation](#%28part._block_notation%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†¬†¬†[9.1.8.5.3¬†How `for each` works](#%28part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†¬†¬†[9.1.8.5.4¬†Testing and variables that can change](#%28part._.Testing_and_variables_that_can_change%29)
    |'
  prefs: []
  type: TYPE_TB
- en: 'Through our work in Pyret to this point, we‚Äôve covered several core programming
    skills: how to work with tables, how to design good examples, the basics of creating
    datatypes, and how to work with the fundamental computational building blocks
    of functions, conditionals, and repetition (through `filter` and `map`, as well
    as recursion). You‚Äôve got a solid initial toolkit, as well as a wide world of
    other possible programs ahead of you!'
  prefs: []
  type: TYPE_NORMAL
- en: But we‚Äôre going to shift gears for a little while and show you how to work in
    Python instead. Why?
  prefs: []
  type: TYPE_NORMAL
- en: 'Seeing how the same concepts play out in multiple languages can help you distinguish
    core computational ideas from the notations and idioms of specific languages.
    If you plan to write programs as part of your professional work, you‚Äôll inevitably
    have to work in different languages at different times: we‚Äôre giving you a chance
    to practice that skill in a controlled and gentle setting.'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we call this gentle? Because the notations in Pyret were designed partly
    with this transition in mind. You‚Äôll find many similarities between Pyret and
    Python at a notational level, yet also some interesting differences that highlight
    some philosophical differences that underlie languages. The next set of programs
    that we want to write (specifically, data-rich programs where the data must be
    updated and maintained over time) fit nicely with certain features of Python that
    you haven‚Äôt seen in Pyret. A future release will contain material that contrasts
    the strengths and weaknesses of the two languages.
  prefs: []
  type: TYPE_NORMAL
- en: We highlight the basic notational differences between Pyret and Python by redoing
    some of our earlier code examples in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.1¬†Expressions, Functions, and Types[üîó](#(part._.Expressions__.Functions__and_.Types)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Back in [Functions Practice: Cost of pens](From_Repeated_Expressions_to_Functions.html#%28part._pen-cost-pyret%29),
    we introduced the notation for functions and types using an example of computing
    the cost of an order of pens. An order consisted of a number of pens and a message
    to be printed on the pens. Each pen cost 25 cents, plus 2 cents per character
    for the message. Here was the original Pyret code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]total cost for pens, each 25 cents'
  prefs: []
  type: TYPE_NORMAL
- en: plus 2 cents per message character[PRE1]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here‚Äôs the corresponding Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What notational differences do you see between the two versions?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here‚Äôs a summary of the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: Python uses `def` instead of `fun`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python uses underscores in names (like `pen_cost`) instead of hyphens as in
    Pyret.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The type names are written differently: Python uses `str` and `int` instead
    of `String` and `Number`. In addition, Python uses only a single colon before
    the type whereas Pyret uses a double colon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python has different types for different kinds of numbers: `int` is for integers,
    while `float` is for decimals. Pyret just used a single type (`Number`) for all
    numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python doesn‚Äôt label the documentation string (as Pyret does with `doc:`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no `end` annotation in Python. Instead, Python uses indentation to
    locate the end of an if/else statement, function, or other multi-line construct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python labels the outputs of functions with `return`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are minor differences in notation, which you will get used to as you write
    more programs in Python.
  prefs: []
  type: TYPE_NORMAL
- en: There are differences beyond the notational ones. One that arises with this
    sample program arises around how the language uses types. In Pyret, if you put
    a type annotation on a parameter then pass it a value of a different type, you‚Äôll
    get an error message. Python ignores the type annotations (unless you bring in
    additional tools for checking types). Python types are like notes for programmers,
    but they aren‚Äôt enforced when programs run.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Convert the following `moon-weight` function from [Functions Practice: Moon
    Weight](From_Repeated_Expressions_to_Functions.html#%28part._moon-weight-pyret%29)
    into Python:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: 9.1.2¬†Returning Values from Functions[üîó](#(part._.Returning_.Values_from_.Functions)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Pyret, a function body consisted of optional statements to name intermediate
    values, followed by a single expression. The value of that single expression is
    the result of calling the function. In Pyret, every function produces a result,
    so there is no need to label where the result comes from.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we will see, Python is different: not all ‚Äúfunctions‚Äù return results (note
    the name change from `fun` to `def`).In mathematics, functions have results by
    definition. Programmers sometimes distinguish between the terms ‚Äúfunction‚Äù and
    ‚Äúprocedure‚Äù: both refer to parameterized computations, but only the former returns
    a result to the surrounding computation. Some programmers and languages do, however,
    use the term ‚Äúfunction‚Äù more loosely to cover both kinds of parameterized computations.
    Moreover, the result isn‚Äôt necessarily the last expression of the `def`. In Python,
    the keyword `return` explicitly labels the expression whose value serves as the
    result of the function.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Put these two definitions in a Python file.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: At the Python prompt, call each function in turn. What do you notice about the
    result from using each function?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Hopefully, you noticed that using `add1v1` displays an answer after the prompt,
    while using `add1v2` does not. This difference has consequences for composing
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Try evaluating the following two expressions at the Python prompt: what happens
    in each case?'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`3 * add1v1(4)`'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`3 * add1v2(4)`'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This example illustrates why `return` is essential in Python: without it, no
    value is returned, which means you can‚Äôt use the result of a function within another
    expression. So what use is `add1v2` then? Hold that question; we‚Äôll return to
    it in [Mutating Variables](mutating-variables.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.3¬†Examples and Test Cases[üîó](#(part._testing-python) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In Pyret, we included examples with every function using `where:` blocks. We
    also had the ability to write `check:` blocks for more extensive tests. As a reminder,
    here was the `pen-cost` code including a `where:` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]total cost for pens, each 25 cents'
  prefs: []
  type: TYPE_NORMAL
- en: plus 2 cents per message character[PRE6]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Python does not have a notion of `where:` blocks, or a distinction between
    examples and tests. There are a couple of different testing packages for Python;
    here we will use `pytest`, a standard lightweight framework that resembles the
    form of testing that we did in Pyret.How you set up pytest and your test file
    contents will vary according to your Python IDE. We assume instructors will provide
    separate instructions that align with their tool choices. To use `pytest`, we
    put both examples and tests in a separate function. Here‚Äôs an example of this
    for the `pen_cost` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Things to note about this code:'
  prefs: []
  type: TYPE_NORMAL
- en: We‚Äôve imported `pytest`, the lightweight Python testing library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The examples have moved into a function (here `test_pens`) that takes no inputs.
    Note that the names of functions that contain test cases must have names that
    start with `test_` in order for `pytest` to find them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Python, individual tests have the form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: rather than the `is` form from Pyret.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Add one more test to the Python code, corresponding to the Pyret test
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make sure to run the test.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did you actually try to run the test?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Whoa! Something weird happened: the test failed. Stop and think about that:
    the same test that worked in Pyret failed in Python. How can that be?'
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.4¬†An Aside on Numbers[üîó](#(part._.An_.Aside_on_.Numbers) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It turns out that different programming languages make different decisions
    about how to represent and manage real (non-integer) numbers. Sometimes, differences
    in these representations lead to subtle quantitative differences in computed values.
    As a simple example, let‚Äôs look at two seemingly simple real numbers `1/2` and
    `1/3`. Here‚Äôs what we get when we type these two numbers at a Pyret prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we type these same two numbers in a Python console, we instead get:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the answers look different for `1/3`. As you may (or may not!) recall
    from an earlier math class, `1/3` is an example of a non-terminating, repeating
    decimal. In plain terms, if we tried to write out the exact value of `1/3` in
    decimal form, we would need to write an infinite sequence of `3`. Mathematicians
    denote this by putting a horizontal bar over the `3`. This is the notation we
    see in Pyret. Python, in contrast, writes out a partial sequence of `3`s.
  prefs: []
  type: TYPE_NORMAL
- en: 'Underneath this distinction lies some interesting details about representing
    numbers in computers. Computers don‚Äôt have infinite space to store numbers (or
    anything else, for that matter): when a program needs to work with a non-terminating
    decimal, the underlying language can either:'
  prefs: []
  type: TYPE_NORMAL
- en: approximate the number (by chopping off the infinite sequence of digits at some
    point), then work only with the approximated value going forward, or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: store additional information about the number that may enable doing more precise
    computation with it later (though there are always some numbers that cannot be
    represented exactly in finite space).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python takes the first approach. As a result, computations with the approximated
    values sometimes yield approximated results. This is what happens with our new
    `pen_cost` test case. While mathematically, the computation should result in `0.93`,
    the approximations yield `0.9299999999999999` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'So how do we write tests in this situation? We need to tell Python that the
    answer should be ‚Äúclose‚Äù to `0.93`, within the error range of approximations.
    Here‚Äôs what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We wrapped the exact answer we wanted in `pytest.approx`, to indicate that we‚Äôll
    accept any answer that is nearly the value we specified. You can control the number
    of decimal points of precision if you want to, but the default of `¬± 2.3e-06`
    often suffices.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.5¬†Conditionals[üîó](#(part._conditionals-python) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Continuing with our original `pen_cost` example, here‚Äôs the Python version
    of the function that computed shipping costs on an order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The main difference to notice here is that `else if` is written as the single-word
    `elif` in Python. We use `return` to mark the function‚Äôs results in each branch
    of the conditional. Otherwise, the conditional constructs are quite similar across
    the two languages.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that Python does not require an explicit `end` annotation
    on `if`-expressions or functions. Instead, Python looks at the indentation of
    your code to determine when a construct has ended. For example, in the code sample
    for `pen_cost` and `test_pens`, Python determines that the `pen_cost` function
    has ended because it detects a new definition (for `test_pens`) at the left edge
    of the program text. The same principle holds for ending conditionals.
  prefs: []
  type: TYPE_NORMAL
- en: We‚Äôll return to this point about indentation, and see more examples, as we work
    more with Python.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.6¬†Creating and Processing Lists[üîó](#(part._python-create-process-lists)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As an example of lists, let‚Äôs assume we‚Äôve been playing a game that involves
    making words out of a collection of letters. In Pyret, we could have written a
    sample word list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python, this definition would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The only difference here is that Python does not use the `list:` label that
    is needed in Pyret.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.6.1¬†Filters, Maps, and Friends[üîó](#(part._.Filters__.Maps__and_.Friends)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When we first learned about lists in Pyret, we started with common built-in
    functions such as `filter`, `map`, `member` and `length`. We also saw the use
    of `lambda` to help us use some of these functions concisely. These same functions,
    including `lambda`, also exist in Python. Here are some samples (`#` is the comment
    character in Python):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you have to wrap calls to `filter` (and `map`) with a use of `list()`.
    Internally, Python has these functions return a type of data that we haven‚Äôt yet
    discussed (and don‚Äôt need). Using `list` converts the returned data into a list.
    If you omit the `list`, you won‚Äôt be able to chain certain functions together.
    For example, if we tried to compute the length of the result of a `map` without
    first converting to a `list`, we‚Äôd get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Don‚Äôt worry if this error message makes no sense at the moment (we haven‚Äôt yet
    learned what an ‚Äúobject‚Äù is). The point is that if you see an error like this
    while using the result of `filter` or `map`, you likely forgot to wrap the result
    in `list`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Practice Python‚Äôs list functions by writing expressions for the following problems.
    Use only the list functions we have shown you so far.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given a list of numbers, convert it to a list of strings `"pos"`, `"neg"`, `"zero"`,
    based on the sign of each number.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Given a list of strings, is the length of any string equal to 5?
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Given a list of numbers, produce a list of the even numbers between 10 and 20
    from that list.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: We‚Äôre intentionally focusing on computations that use Python‚Äôs built-in functions
    for processing lists, rather than showing you how to write you own (as we did
    with recursion in Pyret). While you can write recursive functions to process lists
    in Pyret, a different style of program is more conventional for that purpose.
    We‚Äôll look at that in the chapter on [Mutating Variables](mutating-variables.html).
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.7¬†Data with Components[üîó](#(part._python-data-with-components) "Link to
    here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An analog to a Pyret data definition (without variants) is called a dataclass
    in Python.Those experienced with Python may wonder why we are using dataclasses
    instead of dictionaries or raw classes. Compared to dictionaries, dataclasses
    allow the use of type hints and capture that our data has a fixed collection of
    fields. Compared to raw classes, dataclasses generate a lot of boilerplate code
    that makes them much lighterweight than raw classes. Here‚Äôs an example of a todo-list
    datatype in Pyret and its corresponding Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a single name for the type and the constructor, rather than separate
    names as we had in Pyret.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no commas between field names (but each has to be on its own line
    in Python)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no way to specify the type of the contents of the list in Python (at
    least, not without using more advance packages for writing types)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@dataclass` annotation is needed before `class`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dataclasses don‚Äôt support creating datatypes with multiple variants, like we
    did frequently in Pyret. Doing that needs more advanced concepts than we will
    cover in this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9.1.7.1¬†Accessing Fields within Dataclasses[üîó](#(part._.Accessing_.Fields_within_.Dataclasses)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In Pyret, we extracted a field from structured data by using a dot (period)
    to ‚Äúdig into‚Äù the datum and access the field. The same notation works in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.8¬†Traversing Lists[üîó](#(part._python-traverse-lists) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 9.1.8.1¬†Introducing `For` Loops[üîó](#(part._python-for-loops) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In Pyret, we typically write recursive functions to compute summary values
    over lists. As a reminder, here‚Äôs a Pyret function that sums the numbers in a
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python, it is unusual to break a list into its first and rest components
    and process the rest recursively. Instead, we use a construct called a `for` to
    visit each element of a list in turn. Here‚Äôs the form of `for`, using a concrete
    (example) list of odd numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The name `num` here is of our choosing, just as with the names of parameters
    to a function in Pyret. When a `for` loop evaluates, each item in the list is
    referred to as `num` in turn. Thus, this `for` example is equivalent to writing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `for` construct saves us from writing the common code multiple times, and
    also handles the fact that the lists we are processing can be of arbitrary length
    (so we can‚Äôt predict how many times to write the common code).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs now use `for` to compute the running sum of a list. We‚Äôll start by figuring
    out the repeated computation with our concrete list again. At first, let‚Äôs express
    the repeated computation just in prose. In Pyret, our repeated computation was
    along the lines of ‚Äúadd the first item to the sum of the rest of the items‚Äù. We‚Äôve
    already said that we cannot easily access the ‚Äúrest of the items‚Äù in Python, so
    we need to rephrase this. Here‚Äôs an alternative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this framing refers not to the ‚Äúrest of the computation‚Äù, but rather
    to the computation that has happened so far (the ‚Äúrunning total‚Äù). If you happened
    to work through the chapter on [`my-running-sum`: Examples and Code](processing-lists.html#%28part._running-sum-eg-code%29),
    this framing might be familiar.'
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs convert this prose sketch to code by replacing each line of the sketch
    with concrete code. We do this by setting up a variable named `run_total` and
    updating its value for each element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This idea that you can give a new value to an existing variable name is something
    we haven‚Äôt seen before. In fact, when we first saw how to name values (in [The
    Program Directory](Naming_Values.html#%28part._program-directory%29)), we explicitly
    said that Pyret doesn‚Äôt let you do this (at least, not with the constructs that
    we showed you). Python does. We‚Äôll explore the consequences of this ability in
    more depth shortly (in [Mutating Variables](mutating-variables.html)). For now,
    let‚Äôs just use that ability so we can learn the pattern for traversing lists.
    First, let‚Äôs collapse the repeated lines of code into a single use of `for`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This code works fine for a specific list, but our Pyret version took the list
    to sum as a parameter to a function. To achieve this in Python, we wrap the `for`
    in a function as we have done for other examples earlier in this chapter. This
    is the final version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a set of tests for `sum_list` (the Python version).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now that the Python version is done, let‚Äôs compare it to the original Pyret
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some things to notice about the two pieces of code:'
  prefs: []
  type: TYPE_NORMAL
- en: The Python version needs a variable (here `run_total`) to hold the result of
    the computation as we build it up while traversing (working through) the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initial value of that variable is the answer we returned in the `empty`
    case in Pyret.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The computation in the `link` case of the Pyret function is used to update that
    variable in the body of the `for`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the `for` has finished processing all items in the list, the Python version
    returns the value in the variable as the result of the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9.1.8.2¬†An Aside on Order of Processing List Elements[üîó](#(part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There‚Äôs another subtlety here if we consider how the two programs run: the
    Python version sums the elements from left to right, whereas the Pyret version
    sums them right to left. Concretely, the sequence of values of `run_total` are
    computed as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, the Pyret version unrolls as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As a reminder, the Pyret version did this because the `+` in the `link` case
    can only reduce to an answer once the sum of the rest of the list has been computed.
    Even though we as humans see the chain of `+` operations in each line of the Pyret
    unrolling, Pyret sees only the expression `fst + sum-list(rst)`, which requires
    the function call to finish before the `+` executes.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of summing a list, we don‚Äôt notice the difference between the two
    versions because the sum is the same whether we compute it left-to-right or right-to-left.
    In other functions we write, this difference may start to matter.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.8.3¬†Using `For` Loops in Functions that Produce Lists[üîó](#(part._python-funcs-produce-lists)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let‚Äôs practice using `for` loops on another function that traverses lists, this
    time one that produces a list. Specifically, let‚Äôs write a program that takes
    a list of strings and produces a list of words within that list that contain the
    letter `"z"`.
  prefs: []
  type: TYPE_NORMAL
- en: As in our `sum_list` function, we will need a variable to store the resulting
    list as we build it up. The following code calls this `zlist`. The code also shows
    how to use `in` to check whether a character is in a string (it also works for
    checking whether an item is in a list) and how to add an element to the end of
    a list (`append`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This code follows the structure of `sum_list`, in that we update the value of
    `zlist` using an expression similar to what we would have used in Pyret. For those
    with prior Python experience who would have used `zlist.append` here, hold that
    thought. We will get there in [Mutable Lists](mutable-lists.html).
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write tests for `all_z_words`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a second version of `all_z_words` using `filter`. Be sure to write tests
    for it!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Contrast these two versions and the corresponding tests. Did you notice anything
    interesting?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '9.1.8.4¬†Summary: The List-Processing Template for Python[üîó](#(part._.Summary__.The_.List-.Processing_.Template_for_.Python)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Just as we had a template for writing list-processing functions in Pyret, there
    is a corresponding template in Python based on `for` loops. As a reminder, that
    pattern is as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Keep this template in mind as you learn to write functions over lists in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.8.5¬†`for each` loops in Pyret[üîó](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This section can be read without reading the rest of this chapter, so if you
    have been directed to it before being introduced to Python, do not worry! While
    the content below mirrors similar constructs that exist in Python, it is introduced
    on its own.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous sections introduced `for` loops in Python, and showed a template
    for processing lists with them. Pyret can do similar, using the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: There are a few new language features used in this example, introduced in the
    following several sections.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.8.5.1¬†Variables that can change[üîó](#(part._.Variables_that_can_change) "Link
    to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: First, note that we introduce the variable `result` with `var result` ‚Äì this
    means that it can vary, which is important for the use with `for each`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, all variables in the program directory can never be changed. i.e.,
    if I define a variable `x`, I can not redefine it later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If we do want to change (or mutate) a variable in the directory later, we can,
    but we must declare the variable can change ‚Äì as in, when we define it, rather
    than writing `x = 10`, we must write `var x = 10`. Then, when we want to update
    it, we can do so with the `:=` operator, as is done in the template above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note that trying to use `:=` on a variable that was not declared using `var`
    will produce an error, and variables can still only ever be declared once (whether
    with `var x = ...` or `x = ...`).
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.8.5.2¬†block notation[üîó](#(part._block_notation) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another new language feature shown in these examples is that since Pyret functions
    by default expect only a single (non-definition) expression, we have to add the
    `block` annotation at the top, indicating that the body of the function is multiple
    expressions, with the final one being what the function evaluates to.
  prefs: []
  type: TYPE_NORMAL
- en: 'As another example, if we tried to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Pyret would (rightly) error ‚Äì since the function returns the last expression
    in its body, the `1` will be ignored ‚Äì and is most likely a mistake! Perhaps the
    goal was to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'However, since a `for each` expression exists only to modify a variable, functions
    that contain them will always have multiple expressions, and so we need to communicate
    to Pyret that this is not a mistake. Adding `block` before the `:` that begins
    the function (or, in general, wrapping any expressions in `block:` and `end`)
    communicates to Pyret that we understand that there are multiple expressions,
    and just want to evaluate to the last one. So, if we truly wanted to write a function
    as our first example, we could do that with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.8.5.3¬†How `for each` works[üîó](#(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A `for each` expression runs its body once for each element in the input list,
    adding an entry to the program directory for each element as it goes. It does
    not produce any value directly, so much instead rely on modifying variables (described
    above) to produce a computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider summing a list of numbers. We could write a function that does this,
    following our pattern, as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'On the concrete test input `[list: 5, 1, 7, 3]`, the loop runs four times,
    once with `item` set to `5`, then with `item` set to `1`, then with `item` set
    to `7`, and finally with `item` set to `3`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for each` construct saves us from writing the common code multiple times,
    and also handles the fact that the lists we are processing can be of arbitrary
    length (so we can‚Äôt predict how many times to write the common code). Thus, what
    happens is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.8.5.4¬†Testing and variables that can change[üîó](#(part._.Testing_and_variables_that_can_change)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We intentionally showed a very particular pattern of using variables that can
    change. While there are other uses (explored in part in [Mutating Variables](mutating-variables.html)),
    a main reason to stay with this particular template is the difficulty in testing
    and correspondingly, understanding, code that uses them in other ways.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, note that the pattern means that we never define a variables
    that can change outside a function, which means it can never be used by different
    functions, or multiple function calls. Each time the function runs, a new variable
    is created, it is modified in the `for each` loop, and then the value is returned,
    and the entry in the program directory is removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider what happens if we don‚Äôt follow our pattern. Let‚Äôs say we had the
    following problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given a list of numbers, return the prefix of the list (i.e., all elements,
    starting from the beginning) that sums to less than 100.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Having learned about mutable variables, but not following the pattern, you
    might come up with code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this might seem reasonable ‚Äì we‚Äôve used a new construct, `when`, which
    is an `if` expression that has no `else` ‚Äì this only makes sense to do inside
    of a `for each` block, where we don‚Äôt need a value as a result. It is equivalent
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Where `nothing` is a value that is used in Pyret to indicate that there is no
    particular value of importance.
  prefs: []
  type: TYPE_NORMAL
- en: But what happens when we use this function?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two tests pass, but the last one doesn‚Äôt. Why? If we run the first
    one again, things are even more confusing, i.e., if instead of the above, we ran
    this `check` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now the test that passed at first no longer passes!
  prefs: []
  type: TYPE_NORMAL
- en: What we are seeing is that since the variable is outside the function, it is
    shared across different calls to the function. It is added to the program directory
    once, and each time we call `prefix-under-100`, the program directory entry is
    changed, but it is never reset.
  prefs: []
  type: TYPE_NORMAL
- en: Intentionally, all other uses of mutation have been on directory entries that
    were created only for the body of the function, which meant that when the function
    exited, they were removed. But now, we are always modifying the single `count`
    variable. This means that every time we call `prefix-under-100`, it behaves differently,
    because it not only do we have to understand the code in the body of the function,
    we have to know the current value of the count variable, which is not something
    we can figure out by just looking at the code!
  prefs: []
  type: TYPE_NORMAL
- en: Functions that behave like this are said to have "side effects", and they are
    much harder to test and much harder to understand, and as a result, much more
    likely to have bugs! While the above example is wrong in a relatively straightforward
    way, side effects can cause extremely subtle bugs that only happen when functions
    are called in particular orders ‚Äì orders that may only arised in very specific
    situations, making them hard to understand or reproduce.
  prefs: []
  type: TYPE_NORMAL
- en: While there are some places where doing this is necessary, almost all code can
    be written without side effects, and will be much more reliable. We will explore
    some cases where we might want to do this in [Mutating Variables](mutating-variables.html).
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.1¬†Expressions, Functions, and Types[üîó](#(part._.Expressions__.Functions__and_.Types)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Back in [Functions Practice: Cost of pens](From_Repeated_Expressions_to_Functions.html#%28part._pen-cost-pyret%29),
    we introduced the notation for functions and types using an example of computing
    the cost of an order of pens. An order consisted of a number of pens and a message
    to be printed on the pens. Each pen cost 25 cents, plus 2 cents per character
    for the message. Here was the original Pyret code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]total cost for pens, each 25 cents'
  prefs: []
  type: TYPE_NORMAL
- en: plus 2 cents per message character[PRE55]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here‚Äôs the corresponding Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What notational differences do you see between the two versions?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here‚Äôs a summary of the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: Python uses `def` instead of `fun`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python uses underscores in names (like `pen_cost`) instead of hyphens as in
    Pyret.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The type names are written differently: Python uses `str` and `int` instead
    of `String` and `Number`. In addition, Python uses only a single colon before
    the type whereas Pyret uses a double colon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python has different types for different kinds of numbers: `int` is for integers,
    while `float` is for decimals. Pyret just used a single type (`Number`) for all
    numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python doesn‚Äôt label the documentation string (as Pyret does with `doc:`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no `end` annotation in Python. Instead, Python uses indentation to
    locate the end of an if/else statement, function, or other multi-line construct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python labels the outputs of functions with `return`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are minor differences in notation, which you will get used to as you write
    more programs in Python.
  prefs: []
  type: TYPE_NORMAL
- en: There are differences beyond the notational ones. One that arises with this
    sample program arises around how the language uses types. In Pyret, if you put
    a type annotation on a parameter then pass it a value of a different type, you‚Äôll
    get an error message. Python ignores the type annotations (unless you bring in
    additional tools for checking types). Python types are like notes for programmers,
    but they aren‚Äôt enforced when programs run.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Convert the following `moon-weight` function from [Functions Practice: Moon
    Weight](From_Repeated_Expressions_to_Functions.html#%28part._moon-weight-pyret%29)
    into Python:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: 9.1.2¬†Returning Values from Functions[üîó](#(part._.Returning_.Values_from_.Functions)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Pyret, a function body consisted of optional statements to name intermediate
    values, followed by a single expression. The value of that single expression is
    the result of calling the function. In Pyret, every function produces a result,
    so there is no need to label where the result comes from.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we will see, Python is different: not all ‚Äúfunctions‚Äù return results (note
    the name change from `fun` to `def`).In mathematics, functions have results by
    definition. Programmers sometimes distinguish between the terms ‚Äúfunction‚Äù and
    ‚Äúprocedure‚Äù: both refer to parameterized computations, but only the former returns
    a result to the surrounding computation. Some programmers and languages do, however,
    use the term ‚Äúfunction‚Äù more loosely to cover both kinds of parameterized computations.
    Moreover, the result isn‚Äôt necessarily the last expression of the `def`. In Python,
    the keyword `return` explicitly labels the expression whose value serves as the
    result of the function.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Put these two definitions in a Python file.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: At the Python prompt, call each function in turn. What do you notice about the
    result from using each function?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Hopefully, you noticed that using `add1v1` displays an answer after the prompt,
    while using `add1v2` does not. This difference has consequences for composing
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Try evaluating the following two expressions at the Python prompt: what happens
    in each case?'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`3 * add1v1(4)`'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`3 * add1v2(4)`'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This example illustrates why `return` is essential in Python: without it, no
    value is returned, which means you can‚Äôt use the result of a function within another
    expression. So what use is `add1v2` then? Hold that question; we‚Äôll return to
    it in [Mutating Variables](mutating-variables.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.3¬†Examples and Test Cases[üîó](#(part._testing-python) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In Pyret, we included examples with every function using `where:` blocks. We
    also had the ability to write `check:` blocks for more extensive tests. As a reminder,
    here was the `pen-cost` code including a `where:` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]total cost for pens, each 25 cents'
  prefs: []
  type: TYPE_NORMAL
- en: plus 2 cents per message character[PRE60]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Python does not have a notion of `where:` blocks, or a distinction between
    examples and tests. There are a couple of different testing packages for Python;
    here we will use `pytest`, a standard lightweight framework that resembles the
    form of testing that we did in Pyret.How you set up pytest and your test file
    contents will vary according to your Python IDE. We assume instructors will provide
    separate instructions that align with their tool choices. To use `pytest`, we
    put both examples and tests in a separate function. Here‚Äôs an example of this
    for the `pen_cost` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Things to note about this code:'
  prefs: []
  type: TYPE_NORMAL
- en: We‚Äôve imported `pytest`, the lightweight Python testing library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The examples have moved into a function (here `test_pens`) that takes no inputs.
    Note that the names of functions that contain test cases must have names that
    start with `test_` in order for `pytest` to find them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Python, individual tests have the form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: rather than the `is` form from Pyret.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Add one more test to the Python code, corresponding to the Pyret test
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make sure to run the test.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did you actually try to run the test?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Whoa! Something weird happened: the test failed. Stop and think about that:
    the same test that worked in Pyret failed in Python. How can that be?'
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.4¬†An Aside on Numbers[üîó](#(part._.An_.Aside_on_.Numbers) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It turns out that different programming languages make different decisions
    about how to represent and manage real (non-integer) numbers. Sometimes, differences
    in these representations lead to subtle quantitative differences in computed values.
    As a simple example, let‚Äôs look at two seemingly simple real numbers `1/2` and
    `1/3`. Here‚Äôs what we get when we type these two numbers at a Pyret prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we type these same two numbers in a Python console, we instead get:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the answers look different for `1/3`. As you may (or may not!) recall
    from an earlier math class, `1/3` is an example of a non-terminating, repeating
    decimal. In plain terms, if we tried to write out the exact value of `1/3` in
    decimal form, we would need to write an infinite sequence of `3`. Mathematicians
    denote this by putting a horizontal bar over the `3`. This is the notation we
    see in Pyret. Python, in contrast, writes out a partial sequence of `3`s.
  prefs: []
  type: TYPE_NORMAL
- en: 'Underneath this distinction lies some interesting details about representing
    numbers in computers. Computers don‚Äôt have infinite space to store numbers (or
    anything else, for that matter): when a program needs to work with a non-terminating
    decimal, the underlying language can either:'
  prefs: []
  type: TYPE_NORMAL
- en: approximate the number (by chopping off the infinite sequence of digits at some
    point), then work only with the approximated value going forward, or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: store additional information about the number that may enable doing more precise
    computation with it later (though there are always some numbers that cannot be
    represented exactly in finite space).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python takes the first approach. As a result, computations with the approximated
    values sometimes yield approximated results. This is what happens with our new
    `pen_cost` test case. While mathematically, the computation should result in `0.93`,
    the approximations yield `0.9299999999999999` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'So how do we write tests in this situation? We need to tell Python that the
    answer should be ‚Äúclose‚Äù to `0.93`, within the error range of approximations.
    Here‚Äôs what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: We wrapped the exact answer we wanted in `pytest.approx`, to indicate that we‚Äôll
    accept any answer that is nearly the value we specified. You can control the number
    of decimal points of precision if you want to, but the default of `¬± 2.3e-06`
    often suffices.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.5¬†Conditionals[üîó](#(part._conditionals-python) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Continuing with our original `pen_cost` example, here‚Äôs the Python version
    of the function that computed shipping costs on an order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The main difference to notice here is that `else if` is written as the single-word
    `elif` in Python. We use `return` to mark the function‚Äôs results in each branch
    of the conditional. Otherwise, the conditional constructs are quite similar across
    the two languages.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that Python does not require an explicit `end` annotation
    on `if`-expressions or functions. Instead, Python looks at the indentation of
    your code to determine when a construct has ended. For example, in the code sample
    for `pen_cost` and `test_pens`, Python determines that the `pen_cost` function
    has ended because it detects a new definition (for `test_pens`) at the left edge
    of the program text. The same principle holds for ending conditionals.
  prefs: []
  type: TYPE_NORMAL
- en: We‚Äôll return to this point about indentation, and see more examples, as we work
    more with Python.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.6¬†Creating and Processing Lists[üîó](#(part._python-create-process-lists)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As an example of lists, let‚Äôs assume we‚Äôve been playing a game that involves
    making words out of a collection of letters. In Pyret, we could have written a
    sample word list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python, this definition would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The only difference here is that Python does not use the `list:` label that
    is needed in Pyret.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.6.1¬†Filters, Maps, and Friends[üîó](#(part._.Filters__.Maps__and_.Friends)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When we first learned about lists in Pyret, we started with common built-in
    functions such as `filter`, `map`, `member` and `length`. We also saw the use
    of `lambda` to help us use some of these functions concisely. These same functions,
    including `lambda`, also exist in Python. Here are some samples (`#` is the comment
    character in Python):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you have to wrap calls to `filter` (and `map`) with a use of `list()`.
    Internally, Python has these functions return a type of data that we haven‚Äôt yet
    discussed (and don‚Äôt need). Using `list` converts the returned data into a list.
    If you omit the `list`, you won‚Äôt be able to chain certain functions together.
    For example, if we tried to compute the length of the result of a `map` without
    first converting to a `list`, we‚Äôd get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Don‚Äôt worry if this error message makes no sense at the moment (we haven‚Äôt yet
    learned what an ‚Äúobject‚Äù is). The point is that if you see an error like this
    while using the result of `filter` or `map`, you likely forgot to wrap the result
    in `list`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Practice Python‚Äôs list functions by writing expressions for the following problems.
    Use only the list functions we have shown you so far.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given a list of numbers, convert it to a list of strings `"pos"`, `"neg"`, `"zero"`,
    based on the sign of each number.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Given a list of strings, is the length of any string equal to 5?
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Given a list of numbers, produce a list of the even numbers between 10 and 20
    from that list.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: We‚Äôre intentionally focusing on computations that use Python‚Äôs built-in functions
    for processing lists, rather than showing you how to write you own (as we did
    with recursion in Pyret). While you can write recursive functions to process lists
    in Pyret, a different style of program is more conventional for that purpose.
    We‚Äôll look at that in the chapter on [Mutating Variables](mutating-variables.html).
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.6.1¬†Filters, Maps, and Friends[üîó](#(part._.Filters__.Maps__and_.Friends)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When we first learned about lists in Pyret, we started with common built-in
    functions such as `filter`, `map`, `member` and `length`. We also saw the use
    of `lambda` to help us use some of these functions concisely. These same functions,
    including `lambda`, also exist in Python. Here are some samples (`#` is the comment
    character in Python):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you have to wrap calls to `filter` (and `map`) with a use of `list()`.
    Internally, Python has these functions return a type of data that we haven‚Äôt yet
    discussed (and don‚Äôt need). Using `list` converts the returned data into a list.
    If you omit the `list`, you won‚Äôt be able to chain certain functions together.
    For example, if we tried to compute the length of the result of a `map` without
    first converting to a `list`, we‚Äôd get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Don‚Äôt worry if this error message makes no sense at the moment (we haven‚Äôt yet
    learned what an ‚Äúobject‚Äù is). The point is that if you see an error like this
    while using the result of `filter` or `map`, you likely forgot to wrap the result
    in `list`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Practice Python‚Äôs list functions by writing expressions for the following problems.
    Use only the list functions we have shown you so far.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given a list of numbers, convert it to a list of strings `"pos"`, `"neg"`, `"zero"`,
    based on the sign of each number.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Given a list of strings, is the length of any string equal to 5?
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Given a list of numbers, produce a list of the even numbers between 10 and 20
    from that list.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: We‚Äôre intentionally focusing on computations that use Python‚Äôs built-in functions
    for processing lists, rather than showing you how to write you own (as we did
    with recursion in Pyret). While you can write recursive functions to process lists
    in Pyret, a different style of program is more conventional for that purpose.
    We‚Äôll look at that in the chapter on [Mutating Variables](mutating-variables.html).
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.7¬†Data with Components[üîó](#(part._python-data-with-components) "Link to
    here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An analog to a Pyret data definition (without variants) is called a dataclass
    in Python.Those experienced with Python may wonder why we are using dataclasses
    instead of dictionaries or raw classes. Compared to dictionaries, dataclasses
    allow the use of type hints and capture that our data has a fixed collection of
    fields. Compared to raw classes, dataclasses generate a lot of boilerplate code
    that makes them much lighterweight than raw classes. Here‚Äôs an example of a todo-list
    datatype in Pyret and its corresponding Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a single name for the type and the constructor, rather than separate
    names as we had in Pyret.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no commas between field names (but each has to be on its own line
    in Python)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no way to specify the type of the contents of the list in Python (at
    least, not without using more advance packages for writing types)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@dataclass` annotation is needed before `class`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dataclasses don‚Äôt support creating datatypes with multiple variants, like we
    did frequently in Pyret. Doing that needs more advanced concepts than we will
    cover in this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9.1.7.1¬†Accessing Fields within Dataclasses[üîó](#(part._.Accessing_.Fields_within_.Dataclasses)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In Pyret, we extracted a field from structured data by using a dot (period)
    to ‚Äúdig into‚Äù the datum and access the field. The same notation works in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.7.1¬†Accessing Fields within Dataclasses[üîó](#(part._.Accessing_.Fields_within_.Dataclasses)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In Pyret, we extracted a field from structured data by using a dot (period)
    to ‚Äúdig into‚Äù the datum and access the field. The same notation works in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.8¬†Traversing Lists[üîó](#(part._python-traverse-lists) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 9.1.8.1¬†Introducing `For` Loops[üîó](#(part._python-for-loops) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In Pyret, we typically write recursive functions to compute summary values
    over lists. As a reminder, here‚Äôs a Pyret function that sums the numbers in a
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python, it is unusual to break a list into its first and rest components
    and process the rest recursively. Instead, we use a construct called a `for` to
    visit each element of a list in turn. Here‚Äôs the form of `for`, using a concrete
    (example) list of odd numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The name `num` here is of our choosing, just as with the names of parameters
    to a function in Pyret. When a `for` loop evaluates, each item in the list is
    referred to as `num` in turn. Thus, this `for` example is equivalent to writing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The `for` construct saves us from writing the common code multiple times, and
    also handles the fact that the lists we are processing can be of arbitrary length
    (so we can‚Äôt predict how many times to write the common code).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs now use `for` to compute the running sum of a list. We‚Äôll start by figuring
    out the repeated computation with our concrete list again. At first, let‚Äôs express
    the repeated computation just in prose. In Pyret, our repeated computation was
    along the lines of ‚Äúadd the first item to the sum of the rest of the items‚Äù. We‚Äôve
    already said that we cannot easily access the ‚Äúrest of the items‚Äù in Python, so
    we need to rephrase this. Here‚Äôs an alternative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this framing refers not to the ‚Äúrest of the computation‚Äù, but rather
    to the computation that has happened so far (the ‚Äúrunning total‚Äù). If you happened
    to work through the chapter on [`my-running-sum`: Examples and Code](processing-lists.html#%28part._running-sum-eg-code%29),
    this framing might be familiar.'
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs convert this prose sketch to code by replacing each line of the sketch
    with concrete code. We do this by setting up a variable named `run_total` and
    updating its value for each element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'This idea that you can give a new value to an existing variable name is something
    we haven‚Äôt seen before. In fact, when we first saw how to name values (in [The
    Program Directory](Naming_Values.html#%28part._program-directory%29)), we explicitly
    said that Pyret doesn‚Äôt let you do this (at least, not with the constructs that
    we showed you). Python does. We‚Äôll explore the consequences of this ability in
    more depth shortly (in [Mutating Variables](mutating-variables.html)). For now,
    let‚Äôs just use that ability so we can learn the pattern for traversing lists.
    First, let‚Äôs collapse the repeated lines of code into a single use of `for`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: This code works fine for a specific list, but our Pyret version took the list
    to sum as a parameter to a function. To achieve this in Python, we wrap the `for`
    in a function as we have done for other examples earlier in this chapter. This
    is the final version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a set of tests for `sum_list` (the Python version).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now that the Python version is done, let‚Äôs compare it to the original Pyret
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some things to notice about the two pieces of code:'
  prefs: []
  type: TYPE_NORMAL
- en: The Python version needs a variable (here `run_total`) to hold the result of
    the computation as we build it up while traversing (working through) the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initial value of that variable is the answer we returned in the `empty`
    case in Pyret.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The computation in the `link` case of the Pyret function is used to update that
    variable in the body of the `for`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the `for` has finished processing all items in the list, the Python version
    returns the value in the variable as the result of the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9.1.8.2¬†An Aside on Order of Processing List Elements[üîó](#(part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There‚Äôs another subtlety here if we consider how the two programs run: the
    Python version sums the elements from left to right, whereas the Pyret version
    sums them right to left. Concretely, the sequence of values of `run_total` are
    computed as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, the Pyret version unrolls as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: As a reminder, the Pyret version did this because the `+` in the `link` case
    can only reduce to an answer once the sum of the rest of the list has been computed.
    Even though we as humans see the chain of `+` operations in each line of the Pyret
    unrolling, Pyret sees only the expression `fst + sum-list(rst)`, which requires
    the function call to finish before the `+` executes.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of summing a list, we don‚Äôt notice the difference between the two
    versions because the sum is the same whether we compute it left-to-right or right-to-left.
    In other functions we write, this difference may start to matter.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.8.3¬†Using `For` Loops in Functions that Produce Lists[üîó](#(part._python-funcs-produce-lists)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let‚Äôs practice using `for` loops on another function that traverses lists, this
    time one that produces a list. Specifically, let‚Äôs write a program that takes
    a list of strings and produces a list of words within that list that contain the
    letter `"z"`.
  prefs: []
  type: TYPE_NORMAL
- en: As in our `sum_list` function, we will need a variable to store the resulting
    list as we build it up. The following code calls this `zlist`. The code also shows
    how to use `in` to check whether a character is in a string (it also works for
    checking whether an item is in a list) and how to add an element to the end of
    a list (`append`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: This code follows the structure of `sum_list`, in that we update the value of
    `zlist` using an expression similar to what we would have used in Pyret. For those
    with prior Python experience who would have used `zlist.append` here, hold that
    thought. We will get there in [Mutable Lists](mutable-lists.html).
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write tests for `all_z_words`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a second version of `all_z_words` using `filter`. Be sure to write tests
    for it!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Contrast these two versions and the corresponding tests. Did you notice anything
    interesting?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '9.1.8.4¬†Summary: The List-Processing Template for Python[üîó](#(part._.Summary__.The_.List-.Processing_.Template_for_.Python)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Just as we had a template for writing list-processing functions in Pyret, there
    is a corresponding template in Python based on `for` loops. As a reminder, that
    pattern is as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Keep this template in mind as you learn to write functions over lists in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.8.5¬†`for each` loops in Pyret[üîó](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This section can be read without reading the rest of this chapter, so if you
    have been directed to it before being introduced to Python, do not worry! While
    the content below mirrors similar constructs that exist in Python, it is introduced
    on its own.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous sections introduced `for` loops in Python, and showed a template
    for processing lists with them. Pyret can do similar, using the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: There are a few new language features used in this example, introduced in the
    following several sections.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.8.5.1¬†Variables that can change[üîó](#(part._.Variables_that_can_change) "Link
    to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: First, note that we introduce the variable `result` with `var result` ‚Äì this
    means that it can vary, which is important for the use with `for each`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, all variables in the program directory can never be changed. i.e.,
    if I define a variable `x`, I can not redefine it later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: If we do want to change (or mutate) a variable in the directory later, we can,
    but we must declare the variable can change ‚Äì as in, when we define it, rather
    than writing `x = 10`, we must write `var x = 10`. Then, when we want to update
    it, we can do so with the `:=` operator, as is done in the template above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Note that trying to use `:=` on a variable that was not declared using `var`
    will produce an error, and variables can still only ever be declared once (whether
    with `var x = ...` or `x = ...`).
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.8.5.2¬†block notation[üîó](#(part._block_notation) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another new language feature shown in these examples is that since Pyret functions
    by default expect only a single (non-definition) expression, we have to add the
    `block` annotation at the top, indicating that the body of the function is multiple
    expressions, with the final one being what the function evaluates to.
  prefs: []
  type: TYPE_NORMAL
- en: 'As another example, if we tried to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Pyret would (rightly) error ‚Äì since the function returns the last expression
    in its body, the `1` will be ignored ‚Äì and is most likely a mistake! Perhaps the
    goal was to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'However, since a `for each` expression exists only to modify a variable, functions
    that contain them will always have multiple expressions, and so we need to communicate
    to Pyret that this is not a mistake. Adding `block` before the `:` that begins
    the function (or, in general, wrapping any expressions in `block:` and `end`)
    communicates to Pyret that we understand that there are multiple expressions,
    and just want to evaluate to the last one. So, if we truly wanted to write a function
    as our first example, we could do that with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.8.5.3¬†How `for each` works[üîó](#(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A `for each` expression runs its body once for each element in the input list,
    adding an entry to the program directory for each element as it goes. It does
    not produce any value directly, so much instead rely on modifying variables (described
    above) to produce a computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider summing a list of numbers. We could write a function that does this,
    following our pattern, as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'On the concrete test input `[list: 5, 1, 7, 3]`, the loop runs four times,
    once with `item` set to `5`, then with `item` set to `1`, then with `item` set
    to `7`, and finally with `item` set to `3`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for each` construct saves us from writing the common code multiple times,
    and also handles the fact that the lists we are processing can be of arbitrary
    length (so we can‚Äôt predict how many times to write the common code). Thus, what
    happens is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.8.5.4¬†Testing and variables that can change[üîó](#(part._.Testing_and_variables_that_can_change)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We intentionally showed a very particular pattern of using variables that can
    change. While there are other uses (explored in part in [Mutating Variables](mutating-variables.html)),
    a main reason to stay with this particular template is the difficulty in testing
    and correspondingly, understanding, code that uses them in other ways.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, note that the pattern means that we never define a variables
    that can change outside a function, which means it can never be used by different
    functions, or multiple function calls. Each time the function runs, a new variable
    is created, it is modified in the `for each` loop, and then the value is returned,
    and the entry in the program directory is removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider what happens if we don‚Äôt follow our pattern. Let‚Äôs say we had the
    following problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given a list of numbers, return the prefix of the list (i.e., all elements,
    starting from the beginning) that sums to less than 100.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Having learned about mutable variables, but not following the pattern, you
    might come up with code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this might seem reasonable ‚Äì we‚Äôve used a new construct, `when`, which
    is an `if` expression that has no `else` ‚Äì this only makes sense to do inside
    of a `for each` block, where we don‚Äôt need a value as a result. It is equivalent
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Where `nothing` is a value that is used in Pyret to indicate that there is no
    particular value of importance.
  prefs: []
  type: TYPE_NORMAL
- en: But what happens when we use this function?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two tests pass, but the last one doesn‚Äôt. Why? If we run the first
    one again, things are even more confusing, i.e., if instead of the above, we ran
    this `check` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Now the test that passed at first no longer passes!
  prefs: []
  type: TYPE_NORMAL
- en: What we are seeing is that since the variable is outside the function, it is
    shared across different calls to the function. It is added to the program directory
    once, and each time we call `prefix-under-100`, the program directory entry is
    changed, but it is never reset.
  prefs: []
  type: TYPE_NORMAL
- en: Intentionally, all other uses of mutation have been on directory entries that
    were created only for the body of the function, which meant that when the function
    exited, they were removed. But now, we are always modifying the single `count`
    variable. This means that every time we call `prefix-under-100`, it behaves differently,
    because it not only do we have to understand the code in the body of the function,
    we have to know the current value of the count variable, which is not something
    we can figure out by just looking at the code!
  prefs: []
  type: TYPE_NORMAL
- en: Functions that behave like this are said to have "side effects", and they are
    much harder to test and much harder to understand, and as a result, much more
    likely to have bugs! While the above example is wrong in a relatively straightforward
    way, side effects can cause extremely subtle bugs that only happen when functions
    are called in particular orders ‚Äì orders that may only arised in very specific
    situations, making them hard to understand or reproduce.
  prefs: []
  type: TYPE_NORMAL
- en: While there are some places where doing this is necessary, almost all code can
    be written without side effects, and will be much more reliable. We will explore
    some cases where we might want to do this in [Mutating Variables](mutating-variables.html).
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.8.1¬†Introducing `For` Loops[üîó](#(part._python-for-loops) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In Pyret, we typically write recursive functions to compute summary values
    over lists. As a reminder, here‚Äôs a Pyret function that sums the numbers in a
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python, it is unusual to break a list into its first and rest components
    and process the rest recursively. Instead, we use a construct called a `for` to
    visit each element of a list in turn. Here‚Äôs the form of `for`, using a concrete
    (example) list of odd numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'The name `num` here is of our choosing, just as with the names of parameters
    to a function in Pyret. When a `for` loop evaluates, each item in the list is
    referred to as `num` in turn. Thus, this `for` example is equivalent to writing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The `for` construct saves us from writing the common code multiple times, and
    also handles the fact that the lists we are processing can be of arbitrary length
    (so we can‚Äôt predict how many times to write the common code).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs now use `for` to compute the running sum of a list. We‚Äôll start by figuring
    out the repeated computation with our concrete list again. At first, let‚Äôs express
    the repeated computation just in prose. In Pyret, our repeated computation was
    along the lines of ‚Äúadd the first item to the sum of the rest of the items‚Äù. We‚Äôve
    already said that we cannot easily access the ‚Äúrest of the items‚Äù in Python, so
    we need to rephrase this. Here‚Äôs an alternative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this framing refers not to the ‚Äúrest of the computation‚Äù, but rather
    to the computation that has happened so far (the ‚Äúrunning total‚Äù). If you happened
    to work through the chapter on [`my-running-sum`: Examples and Code](processing-lists.html#%28part._running-sum-eg-code%29),
    this framing might be familiar.'
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs convert this prose sketch to code by replacing each line of the sketch
    with concrete code. We do this by setting up a variable named `run_total` and
    updating its value for each element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'This idea that you can give a new value to an existing variable name is something
    we haven‚Äôt seen before. In fact, when we first saw how to name values (in [The
    Program Directory](Naming_Values.html#%28part._program-directory%29)), we explicitly
    said that Pyret doesn‚Äôt let you do this (at least, not with the constructs that
    we showed you). Python does. We‚Äôll explore the consequences of this ability in
    more depth shortly (in [Mutating Variables](mutating-variables.html)). For now,
    let‚Äôs just use that ability so we can learn the pattern for traversing lists.
    First, let‚Äôs collapse the repeated lines of code into a single use of `for`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: This code works fine for a specific list, but our Pyret version took the list
    to sum as a parameter to a function. To achieve this in Python, we wrap the `for`
    in a function as we have done for other examples earlier in this chapter. This
    is the final version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a set of tests for `sum_list` (the Python version).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now that the Python version is done, let‚Äôs compare it to the original Pyret
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some things to notice about the two pieces of code:'
  prefs: []
  type: TYPE_NORMAL
- en: The Python version needs a variable (here `run_total`) to hold the result of
    the computation as we build it up while traversing (working through) the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initial value of that variable is the answer we returned in the `empty`
    case in Pyret.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The computation in the `link` case of the Pyret function is used to update that
    variable in the body of the `for`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the `for` has finished processing all items in the list, the Python version
    returns the value in the variable as the result of the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9.1.8.2¬†An Aside on Order of Processing List Elements[üîó](#(part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There‚Äôs another subtlety here if we consider how the two programs run: the
    Python version sums the elements from left to right, whereas the Pyret version
    sums them right to left. Concretely, the sequence of values of `run_total` are
    computed as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, the Pyret version unrolls as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: As a reminder, the Pyret version did this because the `+` in the `link` case
    can only reduce to an answer once the sum of the rest of the list has been computed.
    Even though we as humans see the chain of `+` operations in each line of the Pyret
    unrolling, Pyret sees only the expression `fst + sum-list(rst)`, which requires
    the function call to finish before the `+` executes.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of summing a list, we don‚Äôt notice the difference between the two
    versions because the sum is the same whether we compute it left-to-right or right-to-left.
    In other functions we write, this difference may start to matter.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.8.3¬†Using `For` Loops in Functions that Produce Lists[üîó](#(part._python-funcs-produce-lists)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let‚Äôs practice using `for` loops on another function that traverses lists, this
    time one that produces a list. Specifically, let‚Äôs write a program that takes
    a list of strings and produces a list of words within that list that contain the
    letter `"z"`.
  prefs: []
  type: TYPE_NORMAL
- en: As in our `sum_list` function, we will need a variable to store the resulting
    list as we build it up. The following code calls this `zlist`. The code also shows
    how to use `in` to check whether a character is in a string (it also works for
    checking whether an item is in a list) and how to add an element to the end of
    a list (`append`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: This code follows the structure of `sum_list`, in that we update the value of
    `zlist` using an expression similar to what we would have used in Pyret. For those
    with prior Python experience who would have used `zlist.append` here, hold that
    thought. We will get there in [Mutable Lists](mutable-lists.html).
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write tests for `all_z_words`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a second version of `all_z_words` using `filter`. Be sure to write tests
    for it!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Contrast these two versions and the corresponding tests. Did you notice anything
    interesting?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '9.1.8.4¬†Summary: The List-Processing Template for Python[üîó](#(part._.Summary__.The_.List-.Processing_.Template_for_.Python)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Just as we had a template for writing list-processing functions in Pyret, there
    is a corresponding template in Python based on `for` loops. As a reminder, that
    pattern is as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Keep this template in mind as you learn to write functions over lists in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.8.5¬†`for each` loops in Pyret[üîó](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This section can be read without reading the rest of this chapter, so if you
    have been directed to it before being introduced to Python, do not worry! While
    the content below mirrors similar constructs that exist in Python, it is introduced
    on its own.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous sections introduced `for` loops in Python, and showed a template
    for processing lists with them. Pyret can do similar, using the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: There are a few new language features used in this example, introduced in the
    following several sections.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.8.5.1¬†Variables that can change[üîó](#(part._.Variables_that_can_change) "Link
    to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: First, note that we introduce the variable `result` with `var result` ‚Äì this
    means that it can vary, which is important for the use with `for each`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, all variables in the program directory can never be changed. i.e.,
    if I define a variable `x`, I can not redefine it later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: If we do want to change (or mutate) a variable in the directory later, we can,
    but we must declare the variable can change ‚Äì as in, when we define it, rather
    than writing `x = 10`, we must write `var x = 10`. Then, when we want to update
    it, we can do so with the `:=` operator, as is done in the template above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Note that trying to use `:=` on a variable that was not declared using `var`
    will produce an error, and variables can still only ever be declared once (whether
    with `var x = ...` or `x = ...`).
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.8.5.2¬†block notation[üîó](#(part._block_notation) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another new language feature shown in these examples is that since Pyret functions
    by default expect only a single (non-definition) expression, we have to add the
    `block` annotation at the top, indicating that the body of the function is multiple
    expressions, with the final one being what the function evaluates to.
  prefs: []
  type: TYPE_NORMAL
- en: 'As another example, if we tried to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Pyret would (rightly) error ‚Äì since the function returns the last expression
    in its body, the `1` will be ignored ‚Äì and is most likely a mistake! Perhaps the
    goal was to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'However, since a `for each` expression exists only to modify a variable, functions
    that contain them will always have multiple expressions, and so we need to communicate
    to Pyret that this is not a mistake. Adding `block` before the `:` that begins
    the function (or, in general, wrapping any expressions in `block:` and `end`)
    communicates to Pyret that we understand that there are multiple expressions,
    and just want to evaluate to the last one. So, if we truly wanted to write a function
    as our first example, we could do that with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.8.5.3¬†How `for each` works[üîó](#(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A `for each` expression runs its body once for each element in the input list,
    adding an entry to the program directory for each element as it goes. It does
    not produce any value directly, so much instead rely on modifying variables (described
    above) to produce a computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider summing a list of numbers. We could write a function that does this,
    following our pattern, as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'On the concrete test input `[list: 5, 1, 7, 3]`, the loop runs four times,
    once with `item` set to `5`, then with `item` set to `1`, then with `item` set
    to `7`, and finally with `item` set to `3`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for each` construct saves us from writing the common code multiple times,
    and also handles the fact that the lists we are processing can be of arbitrary
    length (so we can‚Äôt predict how many times to write the common code). Thus, what
    happens is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.8.5.4¬†Testing and variables that can change[üîó](#(part._.Testing_and_variables_that_can_change)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We intentionally showed a very particular pattern of using variables that can
    change. While there are other uses (explored in part in [Mutating Variables](mutating-variables.html)),
    a main reason to stay with this particular template is the difficulty in testing
    and correspondingly, understanding, code that uses them in other ways.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, note that the pattern means that we never define a variables
    that can change outside a function, which means it can never be used by different
    functions, or multiple function calls. Each time the function runs, a new variable
    is created, it is modified in the `for each` loop, and then the value is returned,
    and the entry in the program directory is removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider what happens if we don‚Äôt follow our pattern. Let‚Äôs say we had the
    following problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given a list of numbers, return the prefix of the list (i.e., all elements,
    starting from the beginning) that sums to less than 100.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Having learned about mutable variables, but not following the pattern, you
    might come up with code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this might seem reasonable ‚Äì we‚Äôve used a new construct, `when`, which
    is an `if` expression that has no `else` ‚Äì this only makes sense to do inside
    of a `for each` block, where we don‚Äôt need a value as a result. It is equivalent
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Where `nothing` is a value that is used in Pyret to indicate that there is no
    particular value of importance.
  prefs: []
  type: TYPE_NORMAL
- en: But what happens when we use this function?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two tests pass, but the last one doesn‚Äôt. Why? If we run the first
    one again, things are even more confusing, i.e., if instead of the above, we ran
    this `check` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Now the test that passed at first no longer passes!
  prefs: []
  type: TYPE_NORMAL
- en: What we are seeing is that since the variable is outside the function, it is
    shared across different calls to the function. It is added to the program directory
    once, and each time we call `prefix-under-100`, the program directory entry is
    changed, but it is never reset.
  prefs: []
  type: TYPE_NORMAL
- en: Intentionally, all other uses of mutation have been on directory entries that
    were created only for the body of the function, which meant that when the function
    exited, they were removed. But now, we are always modifying the single `count`
    variable. This means that every time we call `prefix-under-100`, it behaves differently,
    because it not only do we have to understand the code in the body of the function,
    we have to know the current value of the count variable, which is not something
    we can figure out by just looking at the code!
  prefs: []
  type: TYPE_NORMAL
- en: Functions that behave like this are said to have "side effects", and they are
    much harder to test and much harder to understand, and as a result, much more
    likely to have bugs! While the above example is wrong in a relatively straightforward
    way, side effects can cause extremely subtle bugs that only happen when functions
    are called in particular orders ‚Äì orders that may only arised in very specific
    situations, making them hard to understand or reproduce.
  prefs: []
  type: TYPE_NORMAL
- en: While there are some places where doing this is necessary, almost all code can
    be written without side effects, and will be much more reliable. We will explore
    some cases where we might want to do this in [Mutating Variables](mutating-variables.html).
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.8.5.1¬†Variables that can change[üîó](#(part._.Variables_that_can_change) "Link
    to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: First, note that we introduce the variable `result` with `var result` ‚Äì this
    means that it can vary, which is important for the use with `for each`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, all variables in the program directory can never be changed. i.e.,
    if I define a variable `x`, I can not redefine it later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: If we do want to change (or mutate) a variable in the directory later, we can,
    but we must declare the variable can change ‚Äì as in, when we define it, rather
    than writing `x = 10`, we must write `var x = 10`. Then, when we want to update
    it, we can do so with the `:=` operator, as is done in the template above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Note that trying to use `:=` on a variable that was not declared using `var`
    will produce an error, and variables can still only ever be declared once (whether
    with `var x = ...` or `x = ...`).
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.8.5.2¬†block notation[üîó](#(part._block_notation) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another new language feature shown in these examples is that since Pyret functions
    by default expect only a single (non-definition) expression, we have to add the
    `block` annotation at the top, indicating that the body of the function is multiple
    expressions, with the final one being what the function evaluates to.
  prefs: []
  type: TYPE_NORMAL
- en: 'As another example, if we tried to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Pyret would (rightly) error ‚Äì since the function returns the last expression
    in its body, the `1` will be ignored ‚Äì and is most likely a mistake! Perhaps the
    goal was to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'However, since a `for each` expression exists only to modify a variable, functions
    that contain them will always have multiple expressions, and so we need to communicate
    to Pyret that this is not a mistake. Adding `block` before the `:` that begins
    the function (or, in general, wrapping any expressions in `block:` and `end`)
    communicates to Pyret that we understand that there are multiple expressions,
    and just want to evaluate to the last one. So, if we truly wanted to write a function
    as our first example, we could do that with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.8.5.3¬†How `for each` works[üîó](#(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A `for each` expression runs its body once for each element in the input list,
    adding an entry to the program directory for each element as it goes. It does
    not produce any value directly, so much instead rely on modifying variables (described
    above) to produce a computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider summing a list of numbers. We could write a function that does this,
    following our pattern, as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'On the concrete test input `[list: 5, 1, 7, 3]`, the loop runs four times,
    once with `item` set to `5`, then with `item` set to `1`, then with `item` set
    to `7`, and finally with `item` set to `3`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for each` construct saves us from writing the common code multiple times,
    and also handles the fact that the lists we are processing can be of arbitrary
    length (so we can‚Äôt predict how many times to write the common code). Thus, what
    happens is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.8.5.4¬†Testing and variables that can change[üîó](#(part._.Testing_and_variables_that_can_change)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We intentionally showed a very particular pattern of using variables that can
    change. While there are other uses (explored in part in [Mutating Variables](mutating-variables.html)),
    a main reason to stay with this particular template is the difficulty in testing
    and correspondingly, understanding, code that uses them in other ways.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, note that the pattern means that we never define a variables
    that can change outside a function, which means it can never be used by different
    functions, or multiple function calls. Each time the function runs, a new variable
    is created, it is modified in the `for each` loop, and then the value is returned,
    and the entry in the program directory is removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider what happens if we don‚Äôt follow our pattern. Let‚Äôs say we had the
    following problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given a list of numbers, return the prefix of the list (i.e., all elements,
    starting from the beginning) that sums to less than 100.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Having learned about mutable variables, but not following the pattern, you
    might come up with code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this might seem reasonable ‚Äì we‚Äôve used a new construct, `when`, which
    is an `if` expression that has no `else` ‚Äì this only makes sense to do inside
    of a `for each` block, where we don‚Äôt need a value as a result. It is equivalent
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Where `nothing` is a value that is used in Pyret to indicate that there is no
    particular value of importance.
  prefs: []
  type: TYPE_NORMAL
- en: But what happens when we use this function?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two tests pass, but the last one doesn‚Äôt. Why? If we run the first
    one again, things are even more confusing, i.e., if instead of the above, we ran
    this `check` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Now the test that passed at first no longer passes!
  prefs: []
  type: TYPE_NORMAL
- en: What we are seeing is that since the variable is outside the function, it is
    shared across different calls to the function. It is added to the program directory
    once, and each time we call `prefix-under-100`, the program directory entry is
    changed, but it is never reset.
  prefs: []
  type: TYPE_NORMAL
- en: Intentionally, all other uses of mutation have been on directory entries that
    were created only for the body of the function, which meant that when the function
    exited, they were removed. But now, we are always modifying the single `count`
    variable. This means that every time we call `prefix-under-100`, it behaves differently,
    because it not only do we have to understand the code in the body of the function,
    we have to know the current value of the count variable, which is not something
    we can figure out by just looking at the code!
  prefs: []
  type: TYPE_NORMAL
- en: Functions that behave like this are said to have "side effects", and they are
    much harder to test and much harder to understand, and as a result, much more
    likely to have bugs! While the above example is wrong in a relatively straightforward
    way, side effects can cause extremely subtle bugs that only happen when functions
    are called in particular orders ‚Äì orders that may only arised in very specific
    situations, making them hard to understand or reproduce.
  prefs: []
  type: TYPE_NORMAL
- en: While there are some places where doing this is necessary, almost all code can
    be written without side effects, and will be much more reliable. We will explore
    some cases where we might want to do this in [Mutating Variables](mutating-variables.html).
  prefs: []
  type: TYPE_NORMAL
