<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>5.2. Background: basic concepts in graph theory#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>5.2. Background: basic concepts in graph theory#</h1>
<blockquote>原文：<a href="https://mmids-textbook.github.io/chap05_specgraph/02_graph/roch-mmids-specgraph-graph.html">https://mmids-textbook.github.io/chap05_specgraph/02_graph/roch-mmids-specgraph-graph.html</a></blockquote>

<p>In this section, we cover the basics of graph theory. We also introduce the <code class="docutils literal notranslate"><span class="pre">NetworkX</span></code> package.</p>
<section id="undirected-graphs">
<h2><span class="section-number">5.2.1. </span>Undirected graphs<a class="headerlink" href="#undirected-graphs" title="Link to this heading">#</a></h2>
<p>We start with undirected graphs.</p>
<p><strong>DEFINITION</strong> <strong>(Undirected Graph)</strong> <span class="math notranslate nohighlight">\(\idx{graph}\xdi\)</span> <span class="math notranslate nohighlight">\(\idx{undirected graph}\xdi\)</span> An undirected graph (or graph for short)
is a pair <span class="math notranslate nohighlight">\(G = (V,E)\)</span> where <span class="math notranslate nohighlight">\(V\)</span> is the set of vertices (or nodes) and</p>
<div class="math notranslate nohighlight">
\[
E \subseteq \{\{u,v\}\,:\, u,v \in V,\ u \neq v\}
\]</div>
<p>is the set of edges. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p>Note that, unless otherwise stated, we typically do not allow self-loops, i.e., edges that connect a vertex to itself.</p>
<p><img alt="Petersen graph (with help from Claude and ChatGPT)" src="../Images/bb1b1affc87320417edc1f5aca37b365.png" data-original-src="https://mmids-textbook.github.io/_images/petersen.png"/></p>
<p>We occasionally write <span class="math notranslate nohighlight">\(V(G)\)</span> and <span class="math notranslate nohighlight">\(E(G)\)</span> for the vertices and edges
of the graph <span class="math notranslate nohighlight">\(G\)</span>. In our case, the set of vertices <span class="math notranslate nohighlight">\(V\)</span> is always finite.</p>
<p><strong>DEFINITION</strong> <strong>(Incidence and Adjacency)</strong> A vertex <span class="math notranslate nohighlight">\(v \in V\)</span> is incident<span class="math notranslate nohighlight">\(\idx{incident}\xdi\)</span> with an edge <span class="math notranslate nohighlight">\(e \in E\)</span> if <span class="math notranslate nohighlight">\(v \in e\)</span>. The incident vertices of an edge are called its endvertices. Two vertices <span class="math notranslate nohighlight">\(u,v \in V\)</span> are adjacent<span class="math notranslate nohighlight">\(\idx{adjacent}\xdi\)</span> (or neighbors), which we denote by <span class="math notranslate nohighlight">\(u \sim v\)</span>, if <span class="math notranslate nohighlight">\(\{u,v\} \in E\)</span>. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>DEFINITION</strong> <strong>(Neighborhood and Degree)</strong> The set of adjacent vertices of <span class="math notranslate nohighlight">\(v\)</span>, denoted by <span class="math notranslate nohighlight">\(N(v)\)</span>, is called the neighborhood<span class="math notranslate nohighlight">\(\idx{neighborhood}\xdi\)</span> of <span class="math notranslate nohighlight">\(v\)</span> and its size, i.e., <span class="math notranslate nohighlight">\(\delta(v):=|N(v)|\)</span>, is the degree<span class="math notranslate nohighlight">\(\idx{degree}\xdi\)</span> of <span class="math notranslate nohighlight">\(v\)</span>. A vertex <span class="math notranslate nohighlight">\(v\)</span> with <span class="math notranslate nohighlight">\(\delta(v) = 0\)</span> is called isolated<span class="math notranslate nohighlight">\(\idx{isolated}\xdi\)</span>. A graph is called <span class="math notranslate nohighlight">\(d\)</span>-regular<span class="math notranslate nohighlight">\(\idx{regular}\xdi\)</span> if all its degrees are <span class="math notranslate nohighlight">\(d\)</span>. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p>A well-known result, sometimes referred to as the <a class="reference external" href="https://en.wikipedia.org/wiki/Handshaking_lemma">Handshaking Lemma</a><span class="math notranslate nohighlight">\(\idx{handshaking lemma}\xdi\)</span>, says that the sum of all degrees is twice the number of edges (prove it!).</p>
<p><strong>EXAMPLE:</strong> <strong>(Petersen)</strong> The Petersen graph is shown above. All its vertices have degree <span class="math notranslate nohighlight">\(3\)</span>, that is, it is <span class="math notranslate nohighlight">\(3\)</span>-regular. In particular there is no isolated vertex. <span class="math notranslate nohighlight">\(\lhd\)</span></p>
<p><strong>DEFINITION</strong> <strong>(Path)</strong> A path<span class="math notranslate nohighlight">\(\idx{path}\xdi\)</span> in <span class="math notranslate nohighlight">\(G\)</span> is a sequence of (not necessarily distinct)
vertices <span class="math notranslate nohighlight">\(x_0 \sim x_1 \sim \cdots \sim x_k\)</span> with each consecutive pair being adjacent. The number of edges, <span class="math notranslate nohighlight">\(k\)</span>, is called the length of the path. If the endvertices <span class="math notranslate nohighlight">\(x_0\)</span>, <span class="math notranslate nohighlight">\(x_k\)</span> coincide, that is, <span class="math notranslate nohighlight">\(x_0 = x_k\)</span>, we call the path a cycle<span class="math notranslate nohighlight">\(\idx{cycle}\xdi\)</span>. If the vertices are all distinct (except possibly for the endvertices), we say that the path (or cycle) is self-avoiding. The length of the shortest self-avoiding path connecting two distinct vertices <span class="math notranslate nohighlight">\(u, v\)</span> is called the graph distance<span class="math notranslate nohighlight">\(\idx{graph distance}\xdi\)</span> between <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span>, denoted by <span class="math notranslate nohighlight">\(\rho(u,v)\)</span>. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>DEFINITION</strong> <strong>(Connected)</strong> We write <span class="math notranslate nohighlight">\(u \leftrightarrow v\)</span> if there is a path between <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span>. (By convention <span class="math notranslate nohighlight">\(u \leftrightarrow u\)</span>.) A graph is connected if there is a path between any two of its vertices, that is, if <span class="math notranslate nohighlight">\(u \leftrightarrow v\)</span> for all <span class="math notranslate nohighlight">\(u, v \in V\)</span>. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>EXAMPLE:</strong> <strong>(Petersen, continued)</strong> The Petersen graph is connected. <span class="math notranslate nohighlight">\(\lhd\)</span></p>
<p><strong>LEMMA</strong> The relation <span class="math notranslate nohighlight">\(\leftrightarrow\)</span> is an <a class="reference external" href="https://en.wikipedia.org/wiki/Equivalence_relation">equivalence relation</a>, that is, <span class="math notranslate nohighlight">\(u \leftrightarrow u\)</span> for all <span class="math notranslate nohighlight">\(u\)</span> (reflexivity), <span class="math notranslate nohighlight">\(u \leftrightarrow v\)</span> if and only if <span class="math notranslate nohighlight">\(v \leftrightarrow u\)</span> (symmetry), and <span class="math notranslate nohighlight">\(u \leftrightarrow v\)</span> and <span class="math notranslate nohighlight">\(v \leftrightarrow w\)</span> implies <span class="math notranslate nohighlight">\(u \leftrightarrow w\)</span> (transitivity). <span class="math notranslate nohighlight">\(\flat\)</span></p>
<p><em>Proof:</em> The first one is immediate from the definition. The second one is obtained by noting that we can reverse the path between <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> to construct a path between <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(u\)</span>. The third one is obtained by noting that we can add a path between <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(w\)</span> to a path between <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> to construct a path between <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(w\)</span>. <span class="math notranslate nohighlight">\(\square\)</span></p>
<p><strong>DEFINITION</strong> <strong>(Connected Components)</strong> The <a class="reference external" href="https://en.wikipedia.org/wiki/Equivalence_class">equivalence class</a> <span class="math notranslate nohighlight">\(C[u] = \{v \in V\,:\, u \leftrightarrow v\}\)</span>, that is, the set of all vertices reachable from <span class="math notranslate nohighlight">\(u\)</span> through a path, is called a connected component<span class="math notranslate nohighlight">\(\idx{connected component}\xdi\)</span>. A graph is connected if and only if it has only one connected component. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p>We show next that the (distinct) connected components form a partition of <span class="math notranslate nohighlight">\(V\)</span>. It holds more generally for the equivalence classes of any equivalence relation.</p>
<p><strong>LEMMA</strong> The following statements are equivalent:</p>
<p>a) <span class="math notranslate nohighlight">\(u \leftrightarrow v\)</span></p>
<p>b) <span class="math notranslate nohighlight">\(C[u] = C[v]\)</span></p>
<p>c) <span class="math notranslate nohighlight">\(C[u] \cap C[v] \neq \emptyset\)</span></p>
<p><span class="math notranslate nohighlight">\(\flat\)</span></p>
<p>As a consequence, either <span class="math notranslate nohighlight">\(C[u] = C[v]\)</span> or <span class="math notranslate nohighlight">\(C[u] \cap C[v] = \emptyset\)</span>.</p>
<p><em>Proof:</em></p>
<p>a) <span class="math notranslate nohighlight">\(\implies\)</span> b): Let <span class="math notranslate nohighlight">\(w \in C[u]\)</span>. So <span class="math notranslate nohighlight">\(u \leftrightarrow w\)</span>. Symmetry and transitivity imply that <span class="math notranslate nohighlight">\(v \leftrightarrow w\)</span>, which proves the claim.</p>
<p>b) <span class="math notranslate nohighlight">\(\implies\)</span> c): Since <span class="math notranslate nohighlight">\(u \in C[u]\)</span> by reflexivity, we have <span class="math notranslate nohighlight">\(\emptyset \neq C[u] = C[v] = C[u] \cap C[v]\)</span>.</p>
<p>c) <span class="math notranslate nohighlight">\(\implies\)</span> a): Let <span class="math notranslate nohighlight">\(w \in C[u] \cap C[v]\)</span>. Then <span class="math notranslate nohighlight">\(u \leftrightarrow w\)</span> and <span class="math notranslate nohighlight">\(v \leftrightarrow w\)</span>. Symmetry and transitivity imply that <span class="math notranslate nohighlight">\(u \leftrightarrow v\)</span>.</p>
<p><span class="math notranslate nohighlight">\(\square\)</span></p>
<p><img alt="Connected components (with help from Claude; inspired by (Source))" src="../Images/2a49e5b611d0cb3744fbc9f044ea23ea.png" data-original-src="https://mmids-textbook.github.io/_images/connected_components.png"/></p>
<p><em>Subgraphs and special graphs:</em> In network analysis, one is often interested in finding or counting interesting motifs or subgraphs within a much larger graph. We will not cover this important problem in network analysis much here, but see the <em>Exercises</em> section.</p>
<p><strong>DEFINITION</strong> <strong>(Subgraph)</strong> A subgraph<span class="math notranslate nohighlight">\(\idx{subgraph}\xdi\)</span> of <span class="math notranslate nohighlight">\(G = (V,E)\)</span> is a graph <span class="math notranslate nohighlight">\(G' = (V',E')\)</span> with <span class="math notranslate nohighlight">\(V' \subseteq V\)</span> and <span class="math notranslate nohighlight">\(E' \subseteq E\)</span>. Implicit in this definition is the fact that the edges in <span class="math notranslate nohighlight">\(E'\)</span> are incident only to <span class="math notranslate nohighlight">\(V'\)</span>. The subgraph <span class="math notranslate nohighlight">\(G'\)</span> is said
to be induced if</p>
<div class="math notranslate nohighlight">
\[
E' = \{\{x,y\}\,:\, x,y \in V',\ \{x,y\}\in E\},
\]</div>
<p>that is, if it contains exactly the edges of <span class="math notranslate nohighlight">\(G\)</span> between the vertices
of <span class="math notranslate nohighlight">\(V'\)</span>. In that case the notation <span class="math notranslate nohighlight">\(G' := G[V']\)</span> is used. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>DEFINITION</strong> <strong>(Spanning Subgraph)</strong> A subgraph is said to be spanning<span class="math notranslate nohighlight">\(\idx{spanning subgraph}\xdi\)</span> if <span class="math notranslate nohighlight">\(V' = V\)</span>. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>DEFINITION</strong> <strong>(Clique)</strong> A subgraph containing all possible edges between its vertices is called a complete subgraph or clique<span class="math notranslate nohighlight">\(\idx{clique}\xdi\)</span>. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>EXAMPLE:</strong> <strong>(continued)</strong> The Petersen graph contains no triangle (that is, complete subgraphs with <span class="math notranslate nohighlight">\(3\)</span> vertices), induced or not. <span class="math notranslate nohighlight">\(\lhd\)</span></p>
<p><strong>DEFINITION</strong> <strong>(Tree and forest)</strong> A forest<span class="math notranslate nohighlight">\(\idx{forest}\xdi\)</span> is a graph with no self-avoiding cycle. A tree<span class="math notranslate nohighlight">\(\idx{tree}\xdi\)</span> is a connected forest. Vertices of degree <span class="math notranslate nohighlight">\(1\)</span> are called leaves. A spanning tree of <span class="math notranslate nohighlight">\(G\)</span> is a subgraph which is a tree and is also spanning. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>NUMERICAL CORNER:</strong> In Python, the <a class="reference external" href="https://networkx.org"><code class="docutils literal notranslate"><span class="pre">NetworkX</span></code></a> package provides many functionalities for defining, modifying and plotting graphs. For instance, many standard graphs can be defined conveniently. The <a class="reference external" href="https://networkx.org/documentation/stable/reference/generated/networkx.generators.small.petersen_graph.html"><code class="docutils literal notranslate"><span class="pre">networkx.petersen_graph</span></code></a> function defines the Petersen graph.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">petersen_graph</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>The graph can be plotted using the function <a class="reference external" href="https://networkx.org/documentation/stable/reference/generated/networkx.drawing.nx_pylab.draw_networkx.html"><code class="docutils literal notranslate"><span class="pre">networkx.draw_networkx</span></code></a>. Recall that in NumPy array indices start at <span class="math notranslate nohighlight">\(0\)</span>. Consistently, NetworkX also names vertices starting at <span class="math notranslate nohighlight">\(0\)</span>. Note, however, that this conflicts with our mathematical conventions.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">'black'</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="s1">'white'</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/b53a9db8d5538d64f42bd14671febcad7f9801f9c64feeb480cf242cab186e45.png" src="../Images/4434125a080ae08f69c60c5836805cf2.png" data-original-src="https://mmids-textbook.github.io/_images/b53a9db8d5538d64f42bd14671febcad7f9801f9c64feeb480cf242cab186e45.png"/>
</div>
</div>
<p>Other standard graphs can be generated with special functions, e.g. complete graphs using <a class="reference external" href="https://networkx.org/documentation/stable/reference/generated/networkx.generators.classic.complete_graph.html#networkx.generators.classic.complete_graph"><code class="docutils literal notranslate"><span class="pre">networkx.complete_graph</span></code></a>. See <a class="reference external" href="https://networkx.org/documentation/stable/reference/generators.html#module-networkx.generators.classic">here</a> for a complete list.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">'black'</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="s1">'white'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/a0ee95b038fed18e1bd3a19d39f2d8562dfdec2878e5499be0781d4ec4e98765.png" src="../Images/4951724a3717cf440027639708f0c5b6.png" data-original-src="https://mmids-textbook.github.io/_images/a0ee95b038fed18e1bd3a19d39f2d8562dfdec2878e5499be0781d4ec4e98765.png"/>
</div>
</div>
<p>See <a class="reference external" href="https://networkx.org/documentation/stable/reference/functions.html">here</a> and <a class="reference external" href="https://networkx.org/documentation/stable/reference/algorithms/index.html">here</a> for a list of functions to access various properties of a graph. Here are a few examples:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">'black'</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="s1">'white'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/4605ef8508b3a99c72677f416a1f6a860fe362bf231d2d54576c0e5561fa46bc.png" src="../Images/6f7735aad7868ed2feba3968e26cdcc4.png" data-original-src="https://mmids-textbook.github.io/_images/4605ef8508b3a99c72677f416a1f6a860fe362bf231d2d54576c0e5561fa46bc.png"/>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span> <span class="c1"># number of nodes</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>10
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span> <span class="c1"># number of edges</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>9
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span> <span class="c1"># checks whether the graph has a particular vertex</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>False
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># checks whether the graph has a particular edge</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>False
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span> <span class="c1"># returns a list of neighbors of the specified vertex</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>[1, 3]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">nx</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="c1"># checks whether the graph is connected</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="p">[</span><span class="n">cc</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)]</span> <span class="c1"># returns the connected components</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>[{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>(0, 1)
(1, 2)
(2, 3)
(3, 4)
(4, 5)
(5, 6)
(6, 7)
(7, 8)
(8, 9)
</pre></div>
</div>
</div>
</div>
<p>Another way of specifying a graph is to start with an empty graph with a given number of vertices and then add edges one by one. The following command creates a graph with <span class="math notranslate nohighlight">\(4\)</span> vertices and no edge (see <a class="reference external" href="https://networkx.org/documentation/stable/reference/generated/networkx.generators.classic.empty_graph.html#networkx.generators.classic.empty_graph"><code class="docutils literal notranslate"><span class="pre">networkx.empty_graph</span></code></a>).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">empty_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">'black'</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="s1">'white'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/a3dc8726731b499bf9695196650263cddae7d0f54b7777ab0f81cec8ffcd4605.png" src="../Images/9aaa661c7b224a4913156a9b27bf7d17.png" data-original-src="https://mmids-textbook.github.io/_images/a3dc8726731b499bf9695196650263cddae7d0f54b7777ab0f81cec8ffcd4605.png"/>
</div>
</div>
<p><span class="math notranslate nohighlight">\(\unlhd\)</span></p>
</section>
<section id="directed-graphs">
<h2><span class="section-number">5.2.2. </span>Directed graphs<a class="headerlink" href="#directed-graphs" title="Link to this heading">#</a></h2>
<p>We will also need directed graphs.</p>
<p><strong>DEFINITION</strong> <strong>(Directed Graph)</strong> A directed graph<span class="math notranslate nohighlight">\(\idx{directed graph}\xdi\)</span> (or digraph for short) is a pair <span class="math notranslate nohighlight">\(G = (V,E)\)</span> where <span class="math notranslate nohighlight">\(V\)</span> is a set of vertices (or nodes) and</p>
<div class="math notranslate nohighlight">
\[
E \subseteq V^2 = \{(u,v)\,:\, u,v \in V\}
\]</div>
<p>is a set of directed edges (or arcs). <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p>Note that, in the directed case, we explicitly allow self-loops<span class="math notranslate nohighlight">\(\idx{self-loop}\xdi\)</span>, i.e., edges of the form <span class="math notranslate nohighlight">\((u,u)\)</span> that connect a vertex to itself.</p>
<p>Note that, unlike the undirected case, in a digraph the edges are ordered pairs – which is taken to mean that they have an orientation. If <span class="math notranslate nohighlight">\(e = (i,j) \in E\)</span> is an edge in a digraph <span class="math notranslate nohighlight">\(G = (V,E)\)</span>, then <span class="math notranslate nohighlight">\(i\)</span> is called the source of <span class="math notranslate nohighlight">\(e\)</span> and <span class="math notranslate nohighlight">\(j\)</span> is the destination.</p>
<p><img alt="A directed graph (with help from Claude; inspired by (Source)" src="../Images/4bfde8866fba5b421fe07eb19bd03caa.png" data-original-src="https://mmids-textbook.github.io/_images/directed.png"/></p>
<p>The definitions discussed in the undirected case can be adapted to the directed case.</p>
<p>In the directed case, one distinguishes between the out-degree and the in-degree.</p>
<p><strong>DEFINITION</strong> <strong>(Out-degree and in-degree)</strong> Let <span class="math notranslate nohighlight">\(G = (V,E)\)</span> be a digraph. The out-degree<span class="math notranslate nohighlight">\(\idx{out-degree}\xdi\)</span> of <span class="math notranslate nohighlight">\(v \in V\)</span>, denoted by <span class="math notranslate nohighlight">\(\delta^+(v)\)</span>, is the number of edges with source <span class="math notranslate nohighlight">\(v\)</span>. The in-degree<span class="math notranslate nohighlight">\(\idx{in-degree}\xdi\)</span> of <span class="math notranslate nohighlight">\(v\)</span>, denoted by <span class="math notranslate nohighlight">\(\delta^-(v)\)</span>, is the number of edges with destination <span class="math notranslate nohighlight">\(v\)</span>. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p>Paths and connectivity are also generalized naturally.</p>
<p><strong>DEFINITION</strong> <strong>(Directed Path)</strong> A directed path<span class="math notranslate nohighlight">\(\idx{directed path}\xdi\)</span> is a sequence of vertices <span class="math notranslate nohighlight">\(x_0, \ldots, x_k\)</span> with <span class="math notranslate nohighlight">\((x_{i-1},x_i) \in E\)</span> for all <span class="math notranslate nohighlight">\(i=1,\ldots,k\)</span>. We write <span class="math notranslate nohighlight">\(u \to v\)</span> if there is such a path with <span class="math notranslate nohighlight">\(x_0 = u\)</span> and <span class="math notranslate nohighlight">\(x_k = v\)</span>. If the endvertices <span class="math notranslate nohighlight">\(x_0\)</span>, <span class="math notranslate nohighlight">\(x_k\)</span> coincide, that is, <span class="math notranslate nohighlight">\(x_0 = x_k\)</span>, we call it a directed cycle<span class="math notranslate nohighlight">\(\idx{directed cycle}\xdi\)</span>. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>DEFINITION</strong> <strong>(Communication)</strong> We say that <span class="math notranslate nohighlight">\(u,v \in V\)</span> communicate<span class="math notranslate nohighlight">\(\idx{communicate}\xdi\)</span>, which we denote by <span class="math notranslate nohighlight">\(u \leftrightarrow v\)</span>, if <span class="math notranslate nohighlight">\(u \to v\)</span> and <span class="math notranslate nohighlight">\(v \to u\)</span>. The <span class="math notranslate nohighlight">\(\leftrightarrow\)</span>
relation is again an equivalence relation. The equivalence classes of <span class="math notranslate nohighlight">\(\leftrightarrow\)</span> are called the strongly connected components of <span class="math notranslate nohighlight">\(G\)</span>. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>DEFINITION</strong> <strong>(Strongly Connected)</strong> A digraph is strongly connected<span class="math notranslate nohighlight">\(\idx{strongly connected}\xdi\)</span> if any two of its vertices communicate, that is, if <span class="math notranslate nohighlight">\(u \leftrightarrow v\)</span> for all <span class="math notranslate nohighlight">\(u, v \in V\)</span>. Or put differently, if there is only one strongly connected component<span class="math notranslate nohighlight">\(\idx{strongly connected component}\xdi\)</span>. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>DEFINITION</strong> <strong>(Directed Acyclic Graph)</strong> A digraph is said to be a directed acyclic graph (DAG)<span class="math notranslate nohighlight">\(\idx{directed acyclic graph}\xdi\)</span> if it contains no directed cycle. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>NUMERICAL CORNER:</strong> The package <code class="docutils literal notranslate"><span class="pre">NetworkX</span></code> also supports digraphs.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
<span class="n">nx</span><span class="o">.</span><span class="n">add_star</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">'black'</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="s1">'white'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/76496f7965b537752105f87147188bd9a867acc87bfe4a3bb470fa702f7f8318.png" src="../Images/7e89c31acd337f7f5cf9d59692d3384e.png" data-original-src="https://mmids-textbook.github.io/_images/76496f7965b537752105f87147188bd9a867acc87bfe4a3bb470fa702f7f8318.png"/>
</div>
</div>
<p>Another way of specifying a digraph is to start with an empty graph with a given number of vertices and then add edges one by one (compare to the undirected case above).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">'black'</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="s1">'white'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/a6d3376c0f4544e54bd68776231c1245e7c427e45f332216b1264ff1c72601fb.png" src="../Images/f441f64d7ae78b107fc30916e169944b.png" data-original-src="https://mmids-textbook.github.io/_images/a6d3376c0f4544e54bd68776231c1245e7c427e45f332216b1264ff1c72601fb.png"/>
</div>
</div>
<p>Note that edges in both directions are depicted here with a double-arrow. Also the self-loop is often awkwardly drawn. We can use
<a class="reference external" href="https://networkx.org/documentation/stable/reference/generated/networkx.drawing.nx_pylab.draw_networkx_edges.html#networkx.drawing.nx_pylab.draw_networkx_edges"><code class="docutils literal notranslate"><span class="pre">networkx.draw_networkx_edges</span></code></a> (together with
<a class="reference external" href="https://networkx.org/documentation/stable/reference/generated/networkx.drawing.nx_pylab.draw_networkx_nodes.html#networkx.drawing.nx_pylab.draw_networkx_nodes"><code class="docutils literal notranslate"><span class="pre">networkx.draw_networkx_nodes</span></code></a> and
<a class="reference external" href="https://networkx.org/documentation/stable/reference/generated/networkx.drawing.nx_pylab.draw_networkx_labels.html#networkx.drawing.nx_pylab.draw_networkx_labels"><code class="docutils literal notranslate"><span class="pre">networkx.draw_networkx_labels</span></code></a>)
to have more control over the drawing of the edges.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">'black'</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_labels</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="s1">'white'</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">connectionstyle</span><span class="o">=</span><span class="s2">"arc3,rad=0.3"</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/967e543bbc3ca52cb02fc4d243fa5c68225aeebf075a3a99dc0292a20e89d648.png" src="../Images/453a50cc0a38fab0c952936c0df69d32.png" data-original-src="https://mmids-textbook.github.io/_images/967e543bbc3ca52cb02fc4d243fa5c68225aeebf075a3a99dc0292a20e89d648.png"/>
</div>
</div>
<p><span class="math notranslate nohighlight">\(\unlhd\)</span></p>
</section>
<section id="matrix-representations-of-graphs">
<h2><span class="section-number">5.2.3. </span>Matrix representations of graphs<a class="headerlink" href="#matrix-representations-of-graphs" title="Link to this heading">#</a></h2>
<p>A convenient and useful way of specifying a graph is through a matrix representation. There are many such representations.</p>
<p>We start with the adjacency matrix.</p>
<p><strong>DEFINITION</strong> <strong>(Adjacency Matrix)</strong> Assume the (undirected) graph <span class="math notranslate nohighlight">\(G = (V,E)\)</span> has
<span class="math notranslate nohighlight">\(n = |V|\)</span> vertices numbered <span class="math notranslate nohighlight">\(1,\ldots,n\)</span>.
The adjacency matrix<span class="math notranslate nohighlight">\(\idx{adjacency matrix}\xdi\)</span> <span class="math notranslate nohighlight">\(A\)</span> of <span class="math notranslate nohighlight">\(G\)</span> is the <span class="math notranslate nohighlight">\(n\times n\)</span> symmetric matrix
defined as</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
A_{xy} 
= 
\begin{cases}
1 &amp; \text{if $\{x,y\} \in E$}\\ 
0 &amp; \text{o.w.}
\end{cases}
\end{align*}\]</div>
<p><span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>EXAMPLE:</strong> The adjancency matrix of the following graph:</p>
<p><img alt="A graph with four edges (with help form Claude; inspired by (Source))" src="../Images/640c523edb11f10372db2c89d5d5d801.png" data-original-src="https://mmids-textbook.github.io/_images/incidence.png"/></p>
<p>is</p>
<div class="math notranslate nohighlight">
\[\begin{split}
A=
\begin{pmatrix}
0 &amp; 1 &amp; 1 &amp; 1\\
1 &amp; 0 &amp; 0 &amp; 0\\
1 &amp; 0 &amp; 0 &amp; 1\\
1 &amp; 0 &amp; 1 &amp; 0
\end{pmatrix}.
\end{split}\]</div>
<p>Note that it is indeed symmetric. <span class="math notranslate nohighlight">\(\lhd\)</span></p>
<p>Another useful matrix associated to a graph is its incidence matrix. For convenience, we assume again that the vertices of <span class="math notranslate nohighlight">\(G = (V,E)\)</span> are numbered <span class="math notranslate nohighlight">\(1, \ldots, n\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of vertices. We assume further that the edges are labeled <span class="math notranslate nohighlight">\(e_1, \ldots, e_{m}\)</span>, where <span class="math notranslate nohighlight">\(m\)</span> is the number of edges.</p>
<p><strong>DEFINITION</strong> <strong>(Incidence Matrix)</strong> The incidence matrix<span class="math notranslate nohighlight">\(\idx{incidence matrix}\xdi\)</span> of an undirected graph <span class="math notranslate nohighlight">\(G = (V, E)\)</span> is the <span class="math notranslate nohighlight">\(n \times m\)</span> matrix <span class="math notranslate nohighlight">\(B\)</span>, where <span class="math notranslate nohighlight">\(n = |V|\)</span> and <span class="math notranslate nohighlight">\(m =|E|\)</span> are the numbers of vertices and edges respectively, such that <span class="math notranslate nohighlight">\(B_{ij} = 1\)</span> if the vertex <span class="math notranslate nohighlight">\(i\)</span> and edge <span class="math notranslate nohighlight">\(e_j\)</span> are incident and 0 otherwise. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>EXAMPLE:</strong> <strong>(continued)</strong> The incidence matrix of the graph from the previous example is given by</p>
<div class="math notranslate nohighlight">
\[\begin{split}
B 
= 
\begin{pmatrix}
1 &amp; 1 &amp; 1 &amp; 0\\
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 1\\
0 &amp; 0 &amp; 1 &amp; 1
\end{pmatrix}.
\end{split}\]</div>
<p>This matrix is not symmetric. In fact, in general, it is not even square. <span class="math notranslate nohighlight">\(\lhd\)</span></p>
<p><strong>NUMERICAL CORNER:</strong> Using NetworkX, the adjacency matrix of a graph can be obtained with <a class="reference external" href="https://networkx.org/documentation/stable/reference/generated/networkx.linalg.graphmatrix.adjacency_matrix.html"><code class="docutils literal notranslate"><span class="pre">networkx.adjacency_matrix</span></code></a>. By default, it returns a SciPy sparse matrix. Alternatively, one can get a regular array with <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.toarray.html"><code class="docutils literal notranslate"><span class="pre">toarray</span></code></a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>  (0, 1)	1
  (0, 2)	1
  (0, 3)	1
  (1, 0)	1
  (1, 2)	1
  (1, 3)	1
  (2, 0)	1
  (2, 1)	1
  (2, 3)	1
  (3, 0)	1
  (3, 1)	1
  (3, 2)	1
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">A</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>[[0 1 1 1]
 [1 0 1 1]
 [1 1 0 1]
 [1 1 1 0]]
</pre></div>
</div>
</div>
</div>
<p>The incidence matrix is obtained with <a class="reference external" href="https://networkx.org/documentation/stable/reference/generated/networkx.linalg.graphmatrix.incidence_matrix.html"><code class="docutils literal notranslate"><span class="pre">networkx.incidence_matrix</span></code></a> – again as a sparse array.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">B</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>  (0, 0)	1.0
  (1, 0)	1.0
  (0, 1)	1.0
  (2, 1)	1.0
  (0, 2)	1.0
  (3, 2)	1.0
  (1, 3)	1.0
  (2, 3)	1.0
  (1, 4)	1.0
  (3, 4)	1.0
  (2, 5)	1.0
  (3, 5)	1.0
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">B</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>[[1. 1. 1. 0. 0. 0.]
 [1. 0. 0. 1. 1. 0.]
 [0. 1. 0. 1. 0. 1.]
 [0. 0. 1. 0. 1. 1.]]
</pre></div>
</div>
</div>
</div>
<p><span class="math notranslate nohighlight">\(\unlhd\)</span></p>
<p>In the digraph case, the definitions are adapted as follows. The adjacency matrix<span class="math notranslate nohighlight">\(\idx{adjacency matrix}\xdi\)</span> <span class="math notranslate nohighlight">\(A\)</span> of a digraph <span class="math notranslate nohighlight">\(G = (V, E)\)</span> is the matrix
defined as</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
A_{xy} 
= 
\begin{cases}
1 &amp; \text{if $(x,y) \in E$}\\ 
0 &amp; \text{o.w.}
\end{cases}
\end{align*}\]</div>
<p>The incidence matrix<span class="math notranslate nohighlight">\(\idx{incidence matrix}\xdi\)</span> of a digraph <span class="math notranslate nohighlight">\(G\)</span> with vertices <span class="math notranslate nohighlight">\(1,\ldots,n\)</span> and edges <span class="math notranslate nohighlight">\(e_1, \ldots, e_m\)</span> is the matrix <span class="math notranslate nohighlight">\(B\)</span> such that <span class="math notranslate nohighlight">\(B_{ij} = -1\)</span> if egde <span class="math notranslate nohighlight">\(e_j\)</span> leaves vertex <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(B_{ij} = 1\)</span> if egde <span class="math notranslate nohighlight">\(e_j\)</span> enters vertex <span class="math notranslate nohighlight">\(i\)</span>, and 0 otherwise.</p>
<p>Returning to undirected graphs, an orientation of an (undirected) graph <span class="math notranslate nohighlight">\(G = (V, E)\)</span> is a choice of direction for each of its edges, turning it into a digraph.</p>
<p><strong>DEFINITION</strong> <strong>(Oriented Incidence Matrix)</strong> An oriented incidence matrix<span class="math notranslate nohighlight">\(\idx{oriented incidence matrix}\xdi\)</span> of an undirected graph <span class="math notranslate nohighlight">\(G = (V, E)\)</span> is the incidence matrix of an orientation of <span class="math notranslate nohighlight">\(G\)</span>. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><img alt="An orientation of the Petersen graph (with help from ChatGPT and Claude)" src="../Images/f5685424aea999de21af27623ec5db76.png" data-original-src="https://mmids-textbook.github.io/_images/oriented_petersen.png"/></p>
<p><strong>NUMERICAL CORNER:</strong> We revisit an earlier directed graph.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We compute the adjacency and incidence matrices. For the incidence matrix, one must specify <code class="docutils literal notranslate"><span class="pre">oriented=True</span></code> for the oriented version.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">A</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>[[0 1 0 1]
 [0 1 0 0]
 [0 0 0 1]
 [1 0 0 0]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">B</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">oriented</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>[[-1. -1.  0.  0.  1.]
 [ 1.  0.  0.  0.  0.]
 [ 0.  0.  0. -1.  0.]
 [ 0.  1.  0.  1. -1.]]
</pre></div>
</div>
</div>
</div>
<p>Revisiting an ealier undirected graph, we note that <code class="docutils literal notranslate"><span class="pre">incidence_matrix()</span></code> can also produce an arbitrary oriented incidence matrix by using the <code class="docutils literal notranslate"><span class="pre">oriented=True</span></code> option.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">empty_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">B</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">oriented</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>[[-1. -1.  0.]
 [ 1.  0.  0.]
 [ 0.  0. -1.]
 [ 0.  1.  1.]]
</pre></div>
</div>
</div>
</div>
<p><span class="math notranslate nohighlight">\(\unlhd\)</span></p>
</section>
<section id="laplacian-matrix">
<h2><span class="section-number">5.2.4. </span>Laplacian matrix<a class="headerlink" href="#laplacian-matrix" title="Link to this heading">#</a></h2>
<p>A main matrix of interest for us will be the Laplacian matrix.
It is a graph analogue of the <a class="reference external" href="https://en.wikipedia.org/wiki/Laplace%E2%80%93Beltrami_operator">Laplace-Beltrami operator</a> in differential geometry. We will show in particular that it contains useful information about the connectedness of the graph and we will describe an application to graph partitioning in a later section. But first some theory.</p>
<p>Recall that, given a graph <span class="math notranslate nohighlight">\(G = (V, E)\)</span>, the quantity <span class="math notranslate nohighlight">\(\delta(v)\)</span> denotes the degree of <span class="math notranslate nohighlight">\(v \in V\)</span>.</p>
<p><strong>DEFINITION</strong> <strong>(Degree Matrix)</strong> Let <span class="math notranslate nohighlight">\(G = (V,E)\)</span> be a graph with vertices <span class="math notranslate nohighlight">\(V = \{1, \ldots, n\}\)</span>. The degree matrix<span class="math notranslate nohighlight">\(\idx{degree matrix}\xdi\)</span> is the diagonal matrix with the degrees on the diagonal, i.e., <span class="math notranslate nohighlight">\(D = \mathrm{diag}(\delta(1), \ldots, \delta(n))\)</span>. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p>The key definition is the following.</p>
<p><strong>DEFINITION</strong> <strong>(Laplacian Matrix)</strong> Let <span class="math notranslate nohighlight">\(G = (V,E)\)</span> be a graph with vertices <span class="math notranslate nohighlight">\(V = \{1, \ldots, n\}\)</span> adjacency matrix <span class="math notranslate nohighlight">\(A \in \mathbb{R}^{n \times n}\)</span> and degree matrix <span class="math notranslate nohighlight">\(D = \mathrm{diag}(\delta(1), \ldots, \delta(n))\)</span>. The Laplacian matrix<span class="math notranslate nohighlight">\(\idx{Laplacian matrix}\xdi\)</span> associated to <span class="math notranslate nohighlight">\(G\)</span> is defined as <span class="math notranslate nohighlight">\(L = D - A\)</span>. Its entries are</p>
<div class="math notranslate nohighlight">
\[\begin{split}
l_{ij}
=
\begin{cases}
\delta(i) &amp; \text{if $i = j$}\\
-1 &amp; \text{if $\{i,j\} \in E$}\\
0 &amp; \text{o.w.}
\end{cases}
\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(\natural\)</span></p>
<p>Like the adjacency matrix, the Laplacian matrix is symmetric. Unlike the adjacency matrix, however, it is also positive semidefinite.</p>
<p><strong>THEOREM</strong> <strong>(Properties of the Laplacian)</strong> <span class="math notranslate nohighlight">\(\idx{properties of the Laplacian theorem}\xdi\)</span> For any graph <span class="math notranslate nohighlight">\(G\)</span>, the Laplacian matrix is symmetric and positive semidefinite. <span class="math notranslate nohighlight">\(\sharp\)</span></p>
<p><em>Proof:</em> Observe that the Laplacian matrix <span class="math notranslate nohighlight">\(L\)</span> of a graph <span class="math notranslate nohighlight">\(G\)</span> is indeed symmetric:</p>
<div class="math notranslate nohighlight">
\[
L^T = (D- A)^T = D^T - A^T = D - A
\]</div>
<p>where we used that both <span class="math notranslate nohighlight">\(D\)</span> and <span class="math notranslate nohighlight">\(A\)</span> are themselves symmetric.</p>
<p>To prove the second claim, we need a lemma.</p>
<p><strong>LEMMA</strong> <strong>(Laplacian and Incidence)</strong> <span class="math notranslate nohighlight">\(\idx{Laplacian and incidence lemma}\xdi\)</span> Let <span class="math notranslate nohighlight">\(L\)</span> be the Laplacian matrix of a graph <span class="math notranslate nohighlight">\(G\)</span>. Let <span class="math notranslate nohighlight">\(B\)</span> be any oriented incidence matrix of <span class="math notranslate nohighlight">\(G\)</span>. Then</p>
<div class="math notranslate nohighlight">
\[
L = B B^T.
\]</div>
<p><span class="math notranslate nohighlight">\(\flat\)</span></p>
<p><em>Proof idea:</em> We just check the claim entry by entry.</p>
<p><em>Proof:</em> Enumerate the edges <span class="math notranslate nohighlight">\(e_1,\ldots,e_m\)</span>. Let <span class="math notranslate nohighlight">\(b_{ik}\)</span> be entry <span class="math notranslate nohighlight">\((i,k)\)</span> of <span class="math notranslate nohighlight">\(B\)</span>. For <span class="math notranslate nohighlight">\(i \neq j\)</span>, entry <span class="math notranslate nohighlight">\((i,j)\)</span> of <span class="math notranslate nohighlight">\(B B^T\)</span></p>
<div class="math notranslate nohighlight">
\[
(B B^T)_{ij} 
= \sum_{k=1}^m b_{ik} b_{jk}.
\]</div>
<p>Note that <span class="math notranslate nohighlight">\(b_{ik} b_{jk}\)</span> is equal to (a) <span class="math notranslate nohighlight">\(0\)</span> if <span class="math notranslate nohighlight">\(i\)</span> or <span class="math notranslate nohighlight">\(j\)</span> (or both) are not incident with <span class="math notranslate nohighlight">\(e_k\)</span> or (b) <span class="math notranslate nohighlight">\(-1\)</span> if both <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> are incident with <span class="math notranslate nohighlight">\(e_k\)</span> (since one of <span class="math notranslate nohighlight">\(i\)</span> or <span class="math notranslate nohighlight">\(j\)</span> has a <span class="math notranslate nohighlight">\(1\)</span> in the column of <span class="math notranslate nohighlight">\(B\)</span> corresponding to <span class="math notranslate nohighlight">\(e_k\)</span> and the other one has a <span class="math notranslate nohighlight">\(-1\)</span>). So <span class="math notranslate nohighlight">\((B B^T)_{ij} = -1\)</span> when <span class="math notranslate nohighlight">\(\{i,j\} \in E\)</span> and is otherwise <span class="math notranslate nohighlight">\(0\)</span>. So it coincides with the corresponding entry of the Laplacian matrix there.</p>
<p>For <span class="math notranslate nohighlight">\(i = j\)</span>,</p>
<div class="math notranslate nohighlight">
\[
(B B^T)_{ii}
= \sum_{k=1}^m b_{ik}^2
= 
\sum_{e = \{x, y\} \in E: i \in e} b_{xy}^2  
= 
\sum_{e = \{x, y\} \in E: i \in e} 1  
= \delta(i),
\]</div>
<p>where we used that <span class="math notranslate nohighlight">\(b_{xy}^2 = 1\)</span> because <span class="math notranslate nohighlight">\(b_{xy} \in \{-1,1\}\)</span> when <span class="math notranslate nohighlight">\(\{x,y\} \in E\)</span>. Again it coincides with the corresponding entry of the Laplacian matrix. <span class="math notranslate nohighlight">\(\square\)</span></p>
<p>We return to the proof of the theorem. By the previous lemma, for any <span class="math notranslate nohighlight">\(\mathbf{x} \in \mathbb{R}^n\)</span>,</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}^T L \mathbf{x}
= \mathbf{x}^T B B^T \mathbf{x}
= \|B^T \mathbf{x}\|^2
\geq 0.
\]</div>
<p>That proves positive semidefiniteness. <span class="math notranslate nohighlight">\(\square\)</span></p>
<p><em><strong>Self-assessment quiz</strong></em> <em>(with help from Claude, Gemini, and ChatGPT)</em></p>
<p><strong>1</strong> Which of the following is NOT a valid definition of an undirected graph?</p>
<p>a) A pair <span class="math notranslate nohighlight">\(G = (V, E)\)</span>, where <span class="math notranslate nohighlight">\(V\)</span> is the set of vertices and <span class="math notranslate nohighlight">\(E\)</span> is a set of unordered pairs of vertices.</p>
<p>b) A collection of nodes connected by edges, where the edges have no direction.</p>
<p>c) A pair <span class="math notranslate nohighlight">\(G = (V, E)\)</span>, where <span class="math notranslate nohighlight">\(V\)</span> is the set of vertices and <span class="math notranslate nohighlight">\(E\)</span> is a set of ordered pairs of vertices.</p>
<p>d) A mathematical structure used to model pairwise relations between objects.</p>
<p><strong>2</strong> In a graph, what does the equivalence relation <span class="math notranslate nohighlight">\(\leftrightarrow\)</span> signify?</p>
<p>a) Two vertices are in the same connected component.</p>
<p>b) Two vertices have the same degree.</p>
<p>c) Two vertices are adjacent.</p>
<p>d) Two vertices are part of a cycle.</p>
<p><strong>3</strong> In a directed graph, what is the relationship between the in-degree and out-degree of a vertex?</p>
<p>a) The in-degree is always greater than or equal to the out-degree.</p>
<p>b) The out-degree is always greater than or equal to the in-degree.</p>
<p>c) The in-degree and out-degree are always equal.</p>
<p>d) There is no fixed relationship between the in-degree and out-degree.</p>
<p><strong>4</strong> Which of the following is NOT a property of the Laplacian matrix of a graph?</p>
<p>a) It is symmetric</p>
<p>b) It is positive semidefinite</p>
<p>c) It is always invertible</p>
<p>d) Its entries sum to zero in each row and column</p>
<p><strong>5</strong> Which matrix representation of a graph is typically symmetric?</p>
<p>a) Adjacency matrix of an undirected graph.</p>
<p>b) Incidence matrix of an undirected graph.</p>
<p>c) Adjacency matrix of a directed graph.</p>
<p>d) All of the above.</p>
<p>Answer for 1: c. Justification: The text defines an undirected graph as a pair <span class="math notranslate nohighlight">\(G = (V, E)\)</span>, where <span class="math notranslate nohighlight">\(E\)</span> is a set of unordered pairs of vertices, not ordered pairs.</p>
<p>Answer for 2: a. Justification: The text defines the relation <span class="math notranslate nohighlight">\(\leftrightarrow\)</span> as an equivalence relation that indicates two vertices are in the same connected component.</p>
<p>Answer for 3: d. Justification: The in-degree and out-degree of a vertex in a directed graph depend on the number of edges entering and leaving the vertex, respectively, and there is no fixed relationship between them.</p>
<p>Answer for 4: c. Justification: The text proves that the Laplacian matrix is symmetric and positive semidefinite, but does not claim that it is always invertible.</p>
<p>Answer for 5: a. Justification: The text states that the adjacency matrix of an undirected graph is symmetric.</p>
</section>
&#13;

<h2><span class="section-number">5.2.1. </span>Undirected graphs<a class="headerlink" href="#undirected-graphs" title="Link to this heading">#</a></h2>
<p>We start with undirected graphs.</p>
<p><strong>DEFINITION</strong> <strong>(Undirected Graph)</strong> <span class="math notranslate nohighlight">\(\idx{graph}\xdi\)</span> <span class="math notranslate nohighlight">\(\idx{undirected graph}\xdi\)</span> An undirected graph (or graph for short)
is a pair <span class="math notranslate nohighlight">\(G = (V,E)\)</span> where <span class="math notranslate nohighlight">\(V\)</span> is the set of vertices (or nodes) and</p>
<div class="math notranslate nohighlight">
\[
E \subseteq \{\{u,v\}\,:\, u,v \in V,\ u \neq v\}
\]</div>
<p>is the set of edges. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p>Note that, unless otherwise stated, we typically do not allow self-loops, i.e., edges that connect a vertex to itself.</p>
<p><img alt="Petersen graph (with help from Claude and ChatGPT)" src="../Images/bb1b1affc87320417edc1f5aca37b365.png" data-original-src="https://mmids-textbook.github.io/_images/petersen.png"/></p>
<p>We occasionally write <span class="math notranslate nohighlight">\(V(G)\)</span> and <span class="math notranslate nohighlight">\(E(G)\)</span> for the vertices and edges
of the graph <span class="math notranslate nohighlight">\(G\)</span>. In our case, the set of vertices <span class="math notranslate nohighlight">\(V\)</span> is always finite.</p>
<p><strong>DEFINITION</strong> <strong>(Incidence and Adjacency)</strong> A vertex <span class="math notranslate nohighlight">\(v \in V\)</span> is incident<span class="math notranslate nohighlight">\(\idx{incident}\xdi\)</span> with an edge <span class="math notranslate nohighlight">\(e \in E\)</span> if <span class="math notranslate nohighlight">\(v \in e\)</span>. The incident vertices of an edge are called its endvertices. Two vertices <span class="math notranslate nohighlight">\(u,v \in V\)</span> are adjacent<span class="math notranslate nohighlight">\(\idx{adjacent}\xdi\)</span> (or neighbors), which we denote by <span class="math notranslate nohighlight">\(u \sim v\)</span>, if <span class="math notranslate nohighlight">\(\{u,v\} \in E\)</span>. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>DEFINITION</strong> <strong>(Neighborhood and Degree)</strong> The set of adjacent vertices of <span class="math notranslate nohighlight">\(v\)</span>, denoted by <span class="math notranslate nohighlight">\(N(v)\)</span>, is called the neighborhood<span class="math notranslate nohighlight">\(\idx{neighborhood}\xdi\)</span> of <span class="math notranslate nohighlight">\(v\)</span> and its size, i.e., <span class="math notranslate nohighlight">\(\delta(v):=|N(v)|\)</span>, is the degree<span class="math notranslate nohighlight">\(\idx{degree}\xdi\)</span> of <span class="math notranslate nohighlight">\(v\)</span>. A vertex <span class="math notranslate nohighlight">\(v\)</span> with <span class="math notranslate nohighlight">\(\delta(v) = 0\)</span> is called isolated<span class="math notranslate nohighlight">\(\idx{isolated}\xdi\)</span>. A graph is called <span class="math notranslate nohighlight">\(d\)</span>-regular<span class="math notranslate nohighlight">\(\idx{regular}\xdi\)</span> if all its degrees are <span class="math notranslate nohighlight">\(d\)</span>. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p>A well-known result, sometimes referred to as the <a class="reference external" href="https://en.wikipedia.org/wiki/Handshaking_lemma">Handshaking Lemma</a><span class="math notranslate nohighlight">\(\idx{handshaking lemma}\xdi\)</span>, says that the sum of all degrees is twice the number of edges (prove it!).</p>
<p><strong>EXAMPLE:</strong> <strong>(Petersen)</strong> The Petersen graph is shown above. All its vertices have degree <span class="math notranslate nohighlight">\(3\)</span>, that is, it is <span class="math notranslate nohighlight">\(3\)</span>-regular. In particular there is no isolated vertex. <span class="math notranslate nohighlight">\(\lhd\)</span></p>
<p><strong>DEFINITION</strong> <strong>(Path)</strong> A path<span class="math notranslate nohighlight">\(\idx{path}\xdi\)</span> in <span class="math notranslate nohighlight">\(G\)</span> is a sequence of (not necessarily distinct)
vertices <span class="math notranslate nohighlight">\(x_0 \sim x_1 \sim \cdots \sim x_k\)</span> with each consecutive pair being adjacent. The number of edges, <span class="math notranslate nohighlight">\(k\)</span>, is called the length of the path. If the endvertices <span class="math notranslate nohighlight">\(x_0\)</span>, <span class="math notranslate nohighlight">\(x_k\)</span> coincide, that is, <span class="math notranslate nohighlight">\(x_0 = x_k\)</span>, we call the path a cycle<span class="math notranslate nohighlight">\(\idx{cycle}\xdi\)</span>. If the vertices are all distinct (except possibly for the endvertices), we say that the path (or cycle) is self-avoiding. The length of the shortest self-avoiding path connecting two distinct vertices <span class="math notranslate nohighlight">\(u, v\)</span> is called the graph distance<span class="math notranslate nohighlight">\(\idx{graph distance}\xdi\)</span> between <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span>, denoted by <span class="math notranslate nohighlight">\(\rho(u,v)\)</span>. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>DEFINITION</strong> <strong>(Connected)</strong> We write <span class="math notranslate nohighlight">\(u \leftrightarrow v\)</span> if there is a path between <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span>. (By convention <span class="math notranslate nohighlight">\(u \leftrightarrow u\)</span>.) A graph is connected if there is a path between any two of its vertices, that is, if <span class="math notranslate nohighlight">\(u \leftrightarrow v\)</span> for all <span class="math notranslate nohighlight">\(u, v \in V\)</span>. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>EXAMPLE:</strong> <strong>(Petersen, continued)</strong> The Petersen graph is connected. <span class="math notranslate nohighlight">\(\lhd\)</span></p>
<p><strong>LEMMA</strong> The relation <span class="math notranslate nohighlight">\(\leftrightarrow\)</span> is an <a class="reference external" href="https://en.wikipedia.org/wiki/Equivalence_relation">equivalence relation</a>, that is, <span class="math notranslate nohighlight">\(u \leftrightarrow u\)</span> for all <span class="math notranslate nohighlight">\(u\)</span> (reflexivity), <span class="math notranslate nohighlight">\(u \leftrightarrow v\)</span> if and only if <span class="math notranslate nohighlight">\(v \leftrightarrow u\)</span> (symmetry), and <span class="math notranslate nohighlight">\(u \leftrightarrow v\)</span> and <span class="math notranslate nohighlight">\(v \leftrightarrow w\)</span> implies <span class="math notranslate nohighlight">\(u \leftrightarrow w\)</span> (transitivity). <span class="math notranslate nohighlight">\(\flat\)</span></p>
<p><em>Proof:</em> The first one is immediate from the definition. The second one is obtained by noting that we can reverse the path between <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> to construct a path between <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(u\)</span>. The third one is obtained by noting that we can add a path between <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(w\)</span> to a path between <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> to construct a path between <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(w\)</span>. <span class="math notranslate nohighlight">\(\square\)</span></p>
<p><strong>DEFINITION</strong> <strong>(Connected Components)</strong> The <a class="reference external" href="https://en.wikipedia.org/wiki/Equivalence_class">equivalence class</a> <span class="math notranslate nohighlight">\(C[u] = \{v \in V\,:\, u \leftrightarrow v\}\)</span>, that is, the set of all vertices reachable from <span class="math notranslate nohighlight">\(u\)</span> through a path, is called a connected component<span class="math notranslate nohighlight">\(\idx{connected component}\xdi\)</span>. A graph is connected if and only if it has only one connected component. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p>We show next that the (distinct) connected components form a partition of <span class="math notranslate nohighlight">\(V\)</span>. It holds more generally for the equivalence classes of any equivalence relation.</p>
<p><strong>LEMMA</strong> The following statements are equivalent:</p>
<p>a) <span class="math notranslate nohighlight">\(u \leftrightarrow v\)</span></p>
<p>b) <span class="math notranslate nohighlight">\(C[u] = C[v]\)</span></p>
<p>c) <span class="math notranslate nohighlight">\(C[u] \cap C[v] \neq \emptyset\)</span></p>
<p><span class="math notranslate nohighlight">\(\flat\)</span></p>
<p>As a consequence, either <span class="math notranslate nohighlight">\(C[u] = C[v]\)</span> or <span class="math notranslate nohighlight">\(C[u] \cap C[v] = \emptyset\)</span>.</p>
<p><em>Proof:</em></p>
<p>a) <span class="math notranslate nohighlight">\(\implies\)</span> b): Let <span class="math notranslate nohighlight">\(w \in C[u]\)</span>. So <span class="math notranslate nohighlight">\(u \leftrightarrow w\)</span>. Symmetry and transitivity imply that <span class="math notranslate nohighlight">\(v \leftrightarrow w\)</span>, which proves the claim.</p>
<p>b) <span class="math notranslate nohighlight">\(\implies\)</span> c): Since <span class="math notranslate nohighlight">\(u \in C[u]\)</span> by reflexivity, we have <span class="math notranslate nohighlight">\(\emptyset \neq C[u] = C[v] = C[u] \cap C[v]\)</span>.</p>
<p>c) <span class="math notranslate nohighlight">\(\implies\)</span> a): Let <span class="math notranslate nohighlight">\(w \in C[u] \cap C[v]\)</span>. Then <span class="math notranslate nohighlight">\(u \leftrightarrow w\)</span> and <span class="math notranslate nohighlight">\(v \leftrightarrow w\)</span>. Symmetry and transitivity imply that <span class="math notranslate nohighlight">\(u \leftrightarrow v\)</span>.</p>
<p><span class="math notranslate nohighlight">\(\square\)</span></p>
<p><img alt="Connected components (with help from Claude; inspired by (Source))" src="../Images/2a49e5b611d0cb3744fbc9f044ea23ea.png" data-original-src="https://mmids-textbook.github.io/_images/connected_components.png"/></p>
<p><em>Subgraphs and special graphs:</em> In network analysis, one is often interested in finding or counting interesting motifs or subgraphs within a much larger graph. We will not cover this important problem in network analysis much here, but see the <em>Exercises</em> section.</p>
<p><strong>DEFINITION</strong> <strong>(Subgraph)</strong> A subgraph<span class="math notranslate nohighlight">\(\idx{subgraph}\xdi\)</span> of <span class="math notranslate nohighlight">\(G = (V,E)\)</span> is a graph <span class="math notranslate nohighlight">\(G' = (V',E')\)</span> with <span class="math notranslate nohighlight">\(V' \subseteq V\)</span> and <span class="math notranslate nohighlight">\(E' \subseteq E\)</span>. Implicit in this definition is the fact that the edges in <span class="math notranslate nohighlight">\(E'\)</span> are incident only to <span class="math notranslate nohighlight">\(V'\)</span>. The subgraph <span class="math notranslate nohighlight">\(G'\)</span> is said
to be induced if</p>
<div class="math notranslate nohighlight">
\[
E' = \{\{x,y\}\,:\, x,y \in V',\ \{x,y\}\in E\},
\]</div>
<p>that is, if it contains exactly the edges of <span class="math notranslate nohighlight">\(G\)</span> between the vertices
of <span class="math notranslate nohighlight">\(V'\)</span>. In that case the notation <span class="math notranslate nohighlight">\(G' := G[V']\)</span> is used. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>DEFINITION</strong> <strong>(Spanning Subgraph)</strong> A subgraph is said to be spanning<span class="math notranslate nohighlight">\(\idx{spanning subgraph}\xdi\)</span> if <span class="math notranslate nohighlight">\(V' = V\)</span>. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>DEFINITION</strong> <strong>(Clique)</strong> A subgraph containing all possible edges between its vertices is called a complete subgraph or clique<span class="math notranslate nohighlight">\(\idx{clique}\xdi\)</span>. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>EXAMPLE:</strong> <strong>(continued)</strong> The Petersen graph contains no triangle (that is, complete subgraphs with <span class="math notranslate nohighlight">\(3\)</span> vertices), induced or not. <span class="math notranslate nohighlight">\(\lhd\)</span></p>
<p><strong>DEFINITION</strong> <strong>(Tree and forest)</strong> A forest<span class="math notranslate nohighlight">\(\idx{forest}\xdi\)</span> is a graph with no self-avoiding cycle. A tree<span class="math notranslate nohighlight">\(\idx{tree}\xdi\)</span> is a connected forest. Vertices of degree <span class="math notranslate nohighlight">\(1\)</span> are called leaves. A spanning tree of <span class="math notranslate nohighlight">\(G\)</span> is a subgraph which is a tree and is also spanning. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>NUMERICAL CORNER:</strong> In Python, the <a class="reference external" href="https://networkx.org"><code class="docutils literal notranslate"><span class="pre">NetworkX</span></code></a> package provides many functionalities for defining, modifying and plotting graphs. For instance, many standard graphs can be defined conveniently. The <a class="reference external" href="https://networkx.org/documentation/stable/reference/generated/networkx.generators.small.petersen_graph.html"><code class="docutils literal notranslate"><span class="pre">networkx.petersen_graph</span></code></a> function defines the Petersen graph.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">petersen_graph</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>The graph can be plotted using the function <a class="reference external" href="https://networkx.org/documentation/stable/reference/generated/networkx.drawing.nx_pylab.draw_networkx.html"><code class="docutils literal notranslate"><span class="pre">networkx.draw_networkx</span></code></a>. Recall that in NumPy array indices start at <span class="math notranslate nohighlight">\(0\)</span>. Consistently, NetworkX also names vertices starting at <span class="math notranslate nohighlight">\(0\)</span>. Note, however, that this conflicts with our mathematical conventions.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">'black'</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="s1">'white'</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/b53a9db8d5538d64f42bd14671febcad7f9801f9c64feeb480cf242cab186e45.png" src="../Images/4434125a080ae08f69c60c5836805cf2.png" data-original-src="https://mmids-textbook.github.io/_images/b53a9db8d5538d64f42bd14671febcad7f9801f9c64feeb480cf242cab186e45.png"/>
</div>
</div>
<p>Other standard graphs can be generated with special functions, e.g. complete graphs using <a class="reference external" href="https://networkx.org/documentation/stable/reference/generated/networkx.generators.classic.complete_graph.html#networkx.generators.classic.complete_graph"><code class="docutils literal notranslate"><span class="pre">networkx.complete_graph</span></code></a>. See <a class="reference external" href="https://networkx.org/documentation/stable/reference/generators.html#module-networkx.generators.classic">here</a> for a complete list.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">'black'</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="s1">'white'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/a0ee95b038fed18e1bd3a19d39f2d8562dfdec2878e5499be0781d4ec4e98765.png" src="../Images/4951724a3717cf440027639708f0c5b6.png" data-original-src="https://mmids-textbook.github.io/_images/a0ee95b038fed18e1bd3a19d39f2d8562dfdec2878e5499be0781d4ec4e98765.png"/>
</div>
</div>
<p>See <a class="reference external" href="https://networkx.org/documentation/stable/reference/functions.html">here</a> and <a class="reference external" href="https://networkx.org/documentation/stable/reference/algorithms/index.html">here</a> for a list of functions to access various properties of a graph. Here are a few examples:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">'black'</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="s1">'white'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/4605ef8508b3a99c72677f416a1f6a860fe362bf231d2d54576c0e5561fa46bc.png" src="../Images/6f7735aad7868ed2feba3968e26cdcc4.png" data-original-src="https://mmids-textbook.github.io/_images/4605ef8508b3a99c72677f416a1f6a860fe362bf231d2d54576c0e5561fa46bc.png"/>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span> <span class="c1"># number of nodes</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>10
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span> <span class="c1"># number of edges</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>9
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span> <span class="c1"># checks whether the graph has a particular vertex</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>False
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># checks whether the graph has a particular edge</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>False
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span> <span class="c1"># returns a list of neighbors of the specified vertex</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>[1, 3]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">nx</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="c1"># checks whether the graph is connected</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="p">[</span><span class="n">cc</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)]</span> <span class="c1"># returns the connected components</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>[{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>(0, 1)
(1, 2)
(2, 3)
(3, 4)
(4, 5)
(5, 6)
(6, 7)
(7, 8)
(8, 9)
</pre></div>
</div>
</div>
</div>
<p>Another way of specifying a graph is to start with an empty graph with a given number of vertices and then add edges one by one. The following command creates a graph with <span class="math notranslate nohighlight">\(4\)</span> vertices and no edge (see <a class="reference external" href="https://networkx.org/documentation/stable/reference/generated/networkx.generators.classic.empty_graph.html#networkx.generators.classic.empty_graph"><code class="docutils literal notranslate"><span class="pre">networkx.empty_graph</span></code></a>).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">empty_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">'black'</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="s1">'white'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/a3dc8726731b499bf9695196650263cddae7d0f54b7777ab0f81cec8ffcd4605.png" src="../Images/9aaa661c7b224a4913156a9b27bf7d17.png" data-original-src="https://mmids-textbook.github.io/_images/a3dc8726731b499bf9695196650263cddae7d0f54b7777ab0f81cec8ffcd4605.png"/>
</div>
</div>
<p><span class="math notranslate nohighlight">\(\unlhd\)</span></p>
&#13;

<h2><span class="section-number">5.2.2. </span>Directed graphs<a class="headerlink" href="#directed-graphs" title="Link to this heading">#</a></h2>
<p>We will also need directed graphs.</p>
<p><strong>DEFINITION</strong> <strong>(Directed Graph)</strong> A directed graph<span class="math notranslate nohighlight">\(\idx{directed graph}\xdi\)</span> (or digraph for short) is a pair <span class="math notranslate nohighlight">\(G = (V,E)\)</span> where <span class="math notranslate nohighlight">\(V\)</span> is a set of vertices (or nodes) and</p>
<div class="math notranslate nohighlight">
\[
E \subseteq V^2 = \{(u,v)\,:\, u,v \in V\}
\]</div>
<p>is a set of directed edges (or arcs). <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p>Note that, in the directed case, we explicitly allow self-loops<span class="math notranslate nohighlight">\(\idx{self-loop}\xdi\)</span>, i.e., edges of the form <span class="math notranslate nohighlight">\((u,u)\)</span> that connect a vertex to itself.</p>
<p>Note that, unlike the undirected case, in a digraph the edges are ordered pairs – which is taken to mean that they have an orientation. If <span class="math notranslate nohighlight">\(e = (i,j) \in E\)</span> is an edge in a digraph <span class="math notranslate nohighlight">\(G = (V,E)\)</span>, then <span class="math notranslate nohighlight">\(i\)</span> is called the source of <span class="math notranslate nohighlight">\(e\)</span> and <span class="math notranslate nohighlight">\(j\)</span> is the destination.</p>
<p><img alt="A directed graph (with help from Claude; inspired by (Source)" src="../Images/4bfde8866fba5b421fe07eb19bd03caa.png" data-original-src="https://mmids-textbook.github.io/_images/directed.png"/></p>
<p>The definitions discussed in the undirected case can be adapted to the directed case.</p>
<p>In the directed case, one distinguishes between the out-degree and the in-degree.</p>
<p><strong>DEFINITION</strong> <strong>(Out-degree and in-degree)</strong> Let <span class="math notranslate nohighlight">\(G = (V,E)\)</span> be a digraph. The out-degree<span class="math notranslate nohighlight">\(\idx{out-degree}\xdi\)</span> of <span class="math notranslate nohighlight">\(v \in V\)</span>, denoted by <span class="math notranslate nohighlight">\(\delta^+(v)\)</span>, is the number of edges with source <span class="math notranslate nohighlight">\(v\)</span>. The in-degree<span class="math notranslate nohighlight">\(\idx{in-degree}\xdi\)</span> of <span class="math notranslate nohighlight">\(v\)</span>, denoted by <span class="math notranslate nohighlight">\(\delta^-(v)\)</span>, is the number of edges with destination <span class="math notranslate nohighlight">\(v\)</span>. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p>Paths and connectivity are also generalized naturally.</p>
<p><strong>DEFINITION</strong> <strong>(Directed Path)</strong> A directed path<span class="math notranslate nohighlight">\(\idx{directed path}\xdi\)</span> is a sequence of vertices <span class="math notranslate nohighlight">\(x_0, \ldots, x_k\)</span> with <span class="math notranslate nohighlight">\((x_{i-1},x_i) \in E\)</span> for all <span class="math notranslate nohighlight">\(i=1,\ldots,k\)</span>. We write <span class="math notranslate nohighlight">\(u \to v\)</span> if there is such a path with <span class="math notranslate nohighlight">\(x_0 = u\)</span> and <span class="math notranslate nohighlight">\(x_k = v\)</span>. If the endvertices <span class="math notranslate nohighlight">\(x_0\)</span>, <span class="math notranslate nohighlight">\(x_k\)</span> coincide, that is, <span class="math notranslate nohighlight">\(x_0 = x_k\)</span>, we call it a directed cycle<span class="math notranslate nohighlight">\(\idx{directed cycle}\xdi\)</span>. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>DEFINITION</strong> <strong>(Communication)</strong> We say that <span class="math notranslate nohighlight">\(u,v \in V\)</span> communicate<span class="math notranslate nohighlight">\(\idx{communicate}\xdi\)</span>, which we denote by <span class="math notranslate nohighlight">\(u \leftrightarrow v\)</span>, if <span class="math notranslate nohighlight">\(u \to v\)</span> and <span class="math notranslate nohighlight">\(v \to u\)</span>. The <span class="math notranslate nohighlight">\(\leftrightarrow\)</span>
relation is again an equivalence relation. The equivalence classes of <span class="math notranslate nohighlight">\(\leftrightarrow\)</span> are called the strongly connected components of <span class="math notranslate nohighlight">\(G\)</span>. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>DEFINITION</strong> <strong>(Strongly Connected)</strong> A digraph is strongly connected<span class="math notranslate nohighlight">\(\idx{strongly connected}\xdi\)</span> if any two of its vertices communicate, that is, if <span class="math notranslate nohighlight">\(u \leftrightarrow v\)</span> for all <span class="math notranslate nohighlight">\(u, v \in V\)</span>. Or put differently, if there is only one strongly connected component<span class="math notranslate nohighlight">\(\idx{strongly connected component}\xdi\)</span>. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>DEFINITION</strong> <strong>(Directed Acyclic Graph)</strong> A digraph is said to be a directed acyclic graph (DAG)<span class="math notranslate nohighlight">\(\idx{directed acyclic graph}\xdi\)</span> if it contains no directed cycle. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>NUMERICAL CORNER:</strong> The package <code class="docutils literal notranslate"><span class="pre">NetworkX</span></code> also supports digraphs.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
<span class="n">nx</span><span class="o">.</span><span class="n">add_star</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">'black'</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="s1">'white'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/76496f7965b537752105f87147188bd9a867acc87bfe4a3bb470fa702f7f8318.png" src="../Images/7e89c31acd337f7f5cf9d59692d3384e.png" data-original-src="https://mmids-textbook.github.io/_images/76496f7965b537752105f87147188bd9a867acc87bfe4a3bb470fa702f7f8318.png"/>
</div>
</div>
<p>Another way of specifying a digraph is to start with an empty graph with a given number of vertices and then add edges one by one (compare to the undirected case above).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">'black'</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="s1">'white'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/a6d3376c0f4544e54bd68776231c1245e7c427e45f332216b1264ff1c72601fb.png" src="../Images/f441f64d7ae78b107fc30916e169944b.png" data-original-src="https://mmids-textbook.github.io/_images/a6d3376c0f4544e54bd68776231c1245e7c427e45f332216b1264ff1c72601fb.png"/>
</div>
</div>
<p>Note that edges in both directions are depicted here with a double-arrow. Also the self-loop is often awkwardly drawn. We can use
<a class="reference external" href="https://networkx.org/documentation/stable/reference/generated/networkx.drawing.nx_pylab.draw_networkx_edges.html#networkx.drawing.nx_pylab.draw_networkx_edges"><code class="docutils literal notranslate"><span class="pre">networkx.draw_networkx_edges</span></code></a> (together with
<a class="reference external" href="https://networkx.org/documentation/stable/reference/generated/networkx.drawing.nx_pylab.draw_networkx_nodes.html#networkx.drawing.nx_pylab.draw_networkx_nodes"><code class="docutils literal notranslate"><span class="pre">networkx.draw_networkx_nodes</span></code></a> and
<a class="reference external" href="https://networkx.org/documentation/stable/reference/generated/networkx.drawing.nx_pylab.draw_networkx_labels.html#networkx.drawing.nx_pylab.draw_networkx_labels"><code class="docutils literal notranslate"><span class="pre">networkx.draw_networkx_labels</span></code></a>)
to have more control over the drawing of the edges.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">'black'</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_labels</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="s1">'white'</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">connectionstyle</span><span class="o">=</span><span class="s2">"arc3,rad=0.3"</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/967e543bbc3ca52cb02fc4d243fa5c68225aeebf075a3a99dc0292a20e89d648.png" src="../Images/453a50cc0a38fab0c952936c0df69d32.png" data-original-src="https://mmids-textbook.github.io/_images/967e543bbc3ca52cb02fc4d243fa5c68225aeebf075a3a99dc0292a20e89d648.png"/>
</div>
</div>
<p><span class="math notranslate nohighlight">\(\unlhd\)</span></p>
&#13;

<h2><span class="section-number">5.2.3. </span>Matrix representations of graphs<a class="headerlink" href="#matrix-representations-of-graphs" title="Link to this heading">#</a></h2>
<p>A convenient and useful way of specifying a graph is through a matrix representation. There are many such representations.</p>
<p>We start with the adjacency matrix.</p>
<p><strong>DEFINITION</strong> <strong>(Adjacency Matrix)</strong> Assume the (undirected) graph <span class="math notranslate nohighlight">\(G = (V,E)\)</span> has
<span class="math notranslate nohighlight">\(n = |V|\)</span> vertices numbered <span class="math notranslate nohighlight">\(1,\ldots,n\)</span>.
The adjacency matrix<span class="math notranslate nohighlight">\(\idx{adjacency matrix}\xdi\)</span> <span class="math notranslate nohighlight">\(A\)</span> of <span class="math notranslate nohighlight">\(G\)</span> is the <span class="math notranslate nohighlight">\(n\times n\)</span> symmetric matrix
defined as</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
A_{xy} 
= 
\begin{cases}
1 &amp; \text{if $\{x,y\} \in E$}\\ 
0 &amp; \text{o.w.}
\end{cases}
\end{align*}\]</div>
<p><span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>EXAMPLE:</strong> The adjancency matrix of the following graph:</p>
<p><img alt="A graph with four edges (with help form Claude; inspired by (Source))" src="../Images/640c523edb11f10372db2c89d5d5d801.png" data-original-src="https://mmids-textbook.github.io/_images/incidence.png"/></p>
<p>is</p>
<div class="math notranslate nohighlight">
\[\begin{split}
A=
\begin{pmatrix}
0 &amp; 1 &amp; 1 &amp; 1\\
1 &amp; 0 &amp; 0 &amp; 0\\
1 &amp; 0 &amp; 0 &amp; 1\\
1 &amp; 0 &amp; 1 &amp; 0
\end{pmatrix}.
\end{split}\]</div>
<p>Note that it is indeed symmetric. <span class="math notranslate nohighlight">\(\lhd\)</span></p>
<p>Another useful matrix associated to a graph is its incidence matrix. For convenience, we assume again that the vertices of <span class="math notranslate nohighlight">\(G = (V,E)\)</span> are numbered <span class="math notranslate nohighlight">\(1, \ldots, n\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of vertices. We assume further that the edges are labeled <span class="math notranslate nohighlight">\(e_1, \ldots, e_{m}\)</span>, where <span class="math notranslate nohighlight">\(m\)</span> is the number of edges.</p>
<p><strong>DEFINITION</strong> <strong>(Incidence Matrix)</strong> The incidence matrix<span class="math notranslate nohighlight">\(\idx{incidence matrix}\xdi\)</span> of an undirected graph <span class="math notranslate nohighlight">\(G = (V, E)\)</span> is the <span class="math notranslate nohighlight">\(n \times m\)</span> matrix <span class="math notranslate nohighlight">\(B\)</span>, where <span class="math notranslate nohighlight">\(n = |V|\)</span> and <span class="math notranslate nohighlight">\(m =|E|\)</span> are the numbers of vertices and edges respectively, such that <span class="math notranslate nohighlight">\(B_{ij} = 1\)</span> if the vertex <span class="math notranslate nohighlight">\(i\)</span> and edge <span class="math notranslate nohighlight">\(e_j\)</span> are incident and 0 otherwise. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>EXAMPLE:</strong> <strong>(continued)</strong> The incidence matrix of the graph from the previous example is given by</p>
<div class="math notranslate nohighlight">
\[\begin{split}
B 
= 
\begin{pmatrix}
1 &amp; 1 &amp; 1 &amp; 0\\
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 1\\
0 &amp; 0 &amp; 1 &amp; 1
\end{pmatrix}.
\end{split}\]</div>
<p>This matrix is not symmetric. In fact, in general, it is not even square. <span class="math notranslate nohighlight">\(\lhd\)</span></p>
<p><strong>NUMERICAL CORNER:</strong> Using NetworkX, the adjacency matrix of a graph can be obtained with <a class="reference external" href="https://networkx.org/documentation/stable/reference/generated/networkx.linalg.graphmatrix.adjacency_matrix.html"><code class="docutils literal notranslate"><span class="pre">networkx.adjacency_matrix</span></code></a>. By default, it returns a SciPy sparse matrix. Alternatively, one can get a regular array with <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.toarray.html"><code class="docutils literal notranslate"><span class="pre">toarray</span></code></a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>  (0, 1)	1
  (0, 2)	1
  (0, 3)	1
  (1, 0)	1
  (1, 2)	1
  (1, 3)	1
  (2, 0)	1
  (2, 1)	1
  (2, 3)	1
  (3, 0)	1
  (3, 1)	1
  (3, 2)	1
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">A</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>[[0 1 1 1]
 [1 0 1 1]
 [1 1 0 1]
 [1 1 1 0]]
</pre></div>
</div>
</div>
</div>
<p>The incidence matrix is obtained with <a class="reference external" href="https://networkx.org/documentation/stable/reference/generated/networkx.linalg.graphmatrix.incidence_matrix.html"><code class="docutils literal notranslate"><span class="pre">networkx.incidence_matrix</span></code></a> – again as a sparse array.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">B</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>  (0, 0)	1.0
  (1, 0)	1.0
  (0, 1)	1.0
  (2, 1)	1.0
  (0, 2)	1.0
  (3, 2)	1.0
  (1, 3)	1.0
  (2, 3)	1.0
  (1, 4)	1.0
  (3, 4)	1.0
  (2, 5)	1.0
  (3, 5)	1.0
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">B</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>[[1. 1. 1. 0. 0. 0.]
 [1. 0. 0. 1. 1. 0.]
 [0. 1. 0. 1. 0. 1.]
 [0. 0. 1. 0. 1. 1.]]
</pre></div>
</div>
</div>
</div>
<p><span class="math notranslate nohighlight">\(\unlhd\)</span></p>
<p>In the digraph case, the definitions are adapted as follows. The adjacency matrix<span class="math notranslate nohighlight">\(\idx{adjacency matrix}\xdi\)</span> <span class="math notranslate nohighlight">\(A\)</span> of a digraph <span class="math notranslate nohighlight">\(G = (V, E)\)</span> is the matrix
defined as</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
A_{xy} 
= 
\begin{cases}
1 &amp; \text{if $(x,y) \in E$}\\ 
0 &amp; \text{o.w.}
\end{cases}
\end{align*}\]</div>
<p>The incidence matrix<span class="math notranslate nohighlight">\(\idx{incidence matrix}\xdi\)</span> of a digraph <span class="math notranslate nohighlight">\(G\)</span> with vertices <span class="math notranslate nohighlight">\(1,\ldots,n\)</span> and edges <span class="math notranslate nohighlight">\(e_1, \ldots, e_m\)</span> is the matrix <span class="math notranslate nohighlight">\(B\)</span> such that <span class="math notranslate nohighlight">\(B_{ij} = -1\)</span> if egde <span class="math notranslate nohighlight">\(e_j\)</span> leaves vertex <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(B_{ij} = 1\)</span> if egde <span class="math notranslate nohighlight">\(e_j\)</span> enters vertex <span class="math notranslate nohighlight">\(i\)</span>, and 0 otherwise.</p>
<p>Returning to undirected graphs, an orientation of an (undirected) graph <span class="math notranslate nohighlight">\(G = (V, E)\)</span> is a choice of direction for each of its edges, turning it into a digraph.</p>
<p><strong>DEFINITION</strong> <strong>(Oriented Incidence Matrix)</strong> An oriented incidence matrix<span class="math notranslate nohighlight">\(\idx{oriented incidence matrix}\xdi\)</span> of an undirected graph <span class="math notranslate nohighlight">\(G = (V, E)\)</span> is the incidence matrix of an orientation of <span class="math notranslate nohighlight">\(G\)</span>. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><img alt="An orientation of the Petersen graph (with help from ChatGPT and Claude)" src="../Images/f5685424aea999de21af27623ec5db76.png" data-original-src="https://mmids-textbook.github.io/_images/oriented_petersen.png"/></p>
<p><strong>NUMERICAL CORNER:</strong> We revisit an earlier directed graph.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We compute the adjacency and incidence matrices. For the incidence matrix, one must specify <code class="docutils literal notranslate"><span class="pre">oriented=True</span></code> for the oriented version.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">A</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>[[0 1 0 1]
 [0 1 0 0]
 [0 0 0 1]
 [1 0 0 0]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">B</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">oriented</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>[[-1. -1.  0.  0.  1.]
 [ 1.  0.  0.  0.  0.]
 [ 0.  0.  0. -1.  0.]
 [ 0.  1.  0.  1. -1.]]
</pre></div>
</div>
</div>
</div>
<p>Revisiting an ealier undirected graph, we note that <code class="docutils literal notranslate"><span class="pre">incidence_matrix()</span></code> can also produce an arbitrary oriented incidence matrix by using the <code class="docutils literal notranslate"><span class="pre">oriented=True</span></code> option.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">empty_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">B</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">oriented</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>[[-1. -1.  0.]
 [ 1.  0.  0.]
 [ 0.  0. -1.]
 [ 0.  1.  1.]]
</pre></div>
</div>
</div>
</div>
<p><span class="math notranslate nohighlight">\(\unlhd\)</span></p>
&#13;

<h2><span class="section-number">5.2.4. </span>Laplacian matrix<a class="headerlink" href="#laplacian-matrix" title="Link to this heading">#</a></h2>
<p>A main matrix of interest for us will be the Laplacian matrix.
It is a graph analogue of the <a class="reference external" href="https://en.wikipedia.org/wiki/Laplace%E2%80%93Beltrami_operator">Laplace-Beltrami operator</a> in differential geometry. We will show in particular that it contains useful information about the connectedness of the graph and we will describe an application to graph partitioning in a later section. But first some theory.</p>
<p>Recall that, given a graph <span class="math notranslate nohighlight">\(G = (V, E)\)</span>, the quantity <span class="math notranslate nohighlight">\(\delta(v)\)</span> denotes the degree of <span class="math notranslate nohighlight">\(v \in V\)</span>.</p>
<p><strong>DEFINITION</strong> <strong>(Degree Matrix)</strong> Let <span class="math notranslate nohighlight">\(G = (V,E)\)</span> be a graph with vertices <span class="math notranslate nohighlight">\(V = \{1, \ldots, n\}\)</span>. The degree matrix<span class="math notranslate nohighlight">\(\idx{degree matrix}\xdi\)</span> is the diagonal matrix with the degrees on the diagonal, i.e., <span class="math notranslate nohighlight">\(D = \mathrm{diag}(\delta(1), \ldots, \delta(n))\)</span>. <span class="math notranslate nohighlight">\(\natural\)</span></p>
<p>The key definition is the following.</p>
<p><strong>DEFINITION</strong> <strong>(Laplacian Matrix)</strong> Let <span class="math notranslate nohighlight">\(G = (V,E)\)</span> be a graph with vertices <span class="math notranslate nohighlight">\(V = \{1, \ldots, n\}\)</span> adjacency matrix <span class="math notranslate nohighlight">\(A \in \mathbb{R}^{n \times n}\)</span> and degree matrix <span class="math notranslate nohighlight">\(D = \mathrm{diag}(\delta(1), \ldots, \delta(n))\)</span>. The Laplacian matrix<span class="math notranslate nohighlight">\(\idx{Laplacian matrix}\xdi\)</span> associated to <span class="math notranslate nohighlight">\(G\)</span> is defined as <span class="math notranslate nohighlight">\(L = D - A\)</span>. Its entries are</p>
<div class="math notranslate nohighlight">
\[\begin{split}
l_{ij}
=
\begin{cases}
\delta(i) &amp; \text{if $i = j$}\\
-1 &amp; \text{if $\{i,j\} \in E$}\\
0 &amp; \text{o.w.}
\end{cases}
\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(\natural\)</span></p>
<p>Like the adjacency matrix, the Laplacian matrix is symmetric. Unlike the adjacency matrix, however, it is also positive semidefinite.</p>
<p><strong>THEOREM</strong> <strong>(Properties of the Laplacian)</strong> <span class="math notranslate nohighlight">\(\idx{properties of the Laplacian theorem}\xdi\)</span> For any graph <span class="math notranslate nohighlight">\(G\)</span>, the Laplacian matrix is symmetric and positive semidefinite. <span class="math notranslate nohighlight">\(\sharp\)</span></p>
<p><em>Proof:</em> Observe that the Laplacian matrix <span class="math notranslate nohighlight">\(L\)</span> of a graph <span class="math notranslate nohighlight">\(G\)</span> is indeed symmetric:</p>
<div class="math notranslate nohighlight">
\[
L^T = (D- A)^T = D^T - A^T = D - A
\]</div>
<p>where we used that both <span class="math notranslate nohighlight">\(D\)</span> and <span class="math notranslate nohighlight">\(A\)</span> are themselves symmetric.</p>
<p>To prove the second claim, we need a lemma.</p>
<p><strong>LEMMA</strong> <strong>(Laplacian and Incidence)</strong> <span class="math notranslate nohighlight">\(\idx{Laplacian and incidence lemma}\xdi\)</span> Let <span class="math notranslate nohighlight">\(L\)</span> be the Laplacian matrix of a graph <span class="math notranslate nohighlight">\(G\)</span>. Let <span class="math notranslate nohighlight">\(B\)</span> be any oriented incidence matrix of <span class="math notranslate nohighlight">\(G\)</span>. Then</p>
<div class="math notranslate nohighlight">
\[
L = B B^T.
\]</div>
<p><span class="math notranslate nohighlight">\(\flat\)</span></p>
<p><em>Proof idea:</em> We just check the claim entry by entry.</p>
<p><em>Proof:</em> Enumerate the edges <span class="math notranslate nohighlight">\(e_1,\ldots,e_m\)</span>. Let <span class="math notranslate nohighlight">\(b_{ik}\)</span> be entry <span class="math notranslate nohighlight">\((i,k)\)</span> of <span class="math notranslate nohighlight">\(B\)</span>. For <span class="math notranslate nohighlight">\(i \neq j\)</span>, entry <span class="math notranslate nohighlight">\((i,j)\)</span> of <span class="math notranslate nohighlight">\(B B^T\)</span></p>
<div class="math notranslate nohighlight">
\[
(B B^T)_{ij} 
= \sum_{k=1}^m b_{ik} b_{jk}.
\]</div>
<p>Note that <span class="math notranslate nohighlight">\(b_{ik} b_{jk}\)</span> is equal to (a) <span class="math notranslate nohighlight">\(0\)</span> if <span class="math notranslate nohighlight">\(i\)</span> or <span class="math notranslate nohighlight">\(j\)</span> (or both) are not incident with <span class="math notranslate nohighlight">\(e_k\)</span> or (b) <span class="math notranslate nohighlight">\(-1\)</span> if both <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> are incident with <span class="math notranslate nohighlight">\(e_k\)</span> (since one of <span class="math notranslate nohighlight">\(i\)</span> or <span class="math notranslate nohighlight">\(j\)</span> has a <span class="math notranslate nohighlight">\(1\)</span> in the column of <span class="math notranslate nohighlight">\(B\)</span> corresponding to <span class="math notranslate nohighlight">\(e_k\)</span> and the other one has a <span class="math notranslate nohighlight">\(-1\)</span>). So <span class="math notranslate nohighlight">\((B B^T)_{ij} = -1\)</span> when <span class="math notranslate nohighlight">\(\{i,j\} \in E\)</span> and is otherwise <span class="math notranslate nohighlight">\(0\)</span>. So it coincides with the corresponding entry of the Laplacian matrix there.</p>
<p>For <span class="math notranslate nohighlight">\(i = j\)</span>,</p>
<div class="math notranslate nohighlight">
\[
(B B^T)_{ii}
= \sum_{k=1}^m b_{ik}^2
= 
\sum_{e = \{x, y\} \in E: i \in e} b_{xy}^2  
= 
\sum_{e = \{x, y\} \in E: i \in e} 1  
= \delta(i),
\]</div>
<p>where we used that <span class="math notranslate nohighlight">\(b_{xy}^2 = 1\)</span> because <span class="math notranslate nohighlight">\(b_{xy} \in \{-1,1\}\)</span> when <span class="math notranslate nohighlight">\(\{x,y\} \in E\)</span>. Again it coincides with the corresponding entry of the Laplacian matrix. <span class="math notranslate nohighlight">\(\square\)</span></p>
<p>We return to the proof of the theorem. By the previous lemma, for any <span class="math notranslate nohighlight">\(\mathbf{x} \in \mathbb{R}^n\)</span>,</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}^T L \mathbf{x}
= \mathbf{x}^T B B^T \mathbf{x}
= \|B^T \mathbf{x}\|^2
\geq 0.
\]</div>
<p>That proves positive semidefiniteness. <span class="math notranslate nohighlight">\(\square\)</span></p>
<p><em><strong>Self-assessment quiz</strong></em> <em>(with help from Claude, Gemini, and ChatGPT)</em></p>
<p><strong>1</strong> Which of the following is NOT a valid definition of an undirected graph?</p>
<p>a) A pair <span class="math notranslate nohighlight">\(G = (V, E)\)</span>, where <span class="math notranslate nohighlight">\(V\)</span> is the set of vertices and <span class="math notranslate nohighlight">\(E\)</span> is a set of unordered pairs of vertices.</p>
<p>b) A collection of nodes connected by edges, where the edges have no direction.</p>
<p>c) A pair <span class="math notranslate nohighlight">\(G = (V, E)\)</span>, where <span class="math notranslate nohighlight">\(V\)</span> is the set of vertices and <span class="math notranslate nohighlight">\(E\)</span> is a set of ordered pairs of vertices.</p>
<p>d) A mathematical structure used to model pairwise relations between objects.</p>
<p><strong>2</strong> In a graph, what does the equivalence relation <span class="math notranslate nohighlight">\(\leftrightarrow\)</span> signify?</p>
<p>a) Two vertices are in the same connected component.</p>
<p>b) Two vertices have the same degree.</p>
<p>c) Two vertices are adjacent.</p>
<p>d) Two vertices are part of a cycle.</p>
<p><strong>3</strong> In a directed graph, what is the relationship between the in-degree and out-degree of a vertex?</p>
<p>a) The in-degree is always greater than or equal to the out-degree.</p>
<p>b) The out-degree is always greater than or equal to the in-degree.</p>
<p>c) The in-degree and out-degree are always equal.</p>
<p>d) There is no fixed relationship between the in-degree and out-degree.</p>
<p><strong>4</strong> Which of the following is NOT a property of the Laplacian matrix of a graph?</p>
<p>a) It is symmetric</p>
<p>b) It is positive semidefinite</p>
<p>c) It is always invertible</p>
<p>d) Its entries sum to zero in each row and column</p>
<p><strong>5</strong> Which matrix representation of a graph is typically symmetric?</p>
<p>a) Adjacency matrix of an undirected graph.</p>
<p>b) Incidence matrix of an undirected graph.</p>
<p>c) Adjacency matrix of a directed graph.</p>
<p>d) All of the above.</p>
<p>Answer for 1: c. Justification: The text defines an undirected graph as a pair <span class="math notranslate nohighlight">\(G = (V, E)\)</span>, where <span class="math notranslate nohighlight">\(E\)</span> is a set of unordered pairs of vertices, not ordered pairs.</p>
<p>Answer for 2: a. Justification: The text defines the relation <span class="math notranslate nohighlight">\(\leftrightarrow\)</span> as an equivalence relation that indicates two vertices are in the same connected component.</p>
<p>Answer for 3: d. Justification: The in-degree and out-degree of a vertex in a directed graph depend on the number of edges entering and leaving the vertex, respectively, and there is no fixed relationship between them.</p>
<p>Answer for 4: c. Justification: The text proves that the Laplacian matrix is symmetric and positive semidefinite, but does not claim that it is always invertible.</p>
<p>Answer for 5: a. Justification: The text states that the adjacency matrix of an undirected graph is symmetric.</p>
    
</body>
</html>