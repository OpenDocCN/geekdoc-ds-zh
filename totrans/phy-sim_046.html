<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Case Study: Square Drop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Case Study: Square Drop</h1>
<blockquote>原文：<a href="https://phys-sim-book.github.io/lec8.3-square_drop.html">https://phys-sim-book.github.io/lec8.3-square_drop.html</a></blockquote>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"/>

<p>To conclude, let's consider a case study where we simulate a square dropped onto a fixed planar ground. Building on our previous mass-spring model for an elastic square, we augment a barrier potential into its Incremental Potential and apply the filter line search scheme to manage the contact between the square's degrees of freedom (DOFs) and the ground.</p>
<p>The excutable Python project for this section can be found at <a href="https://github.com/phys-sim-book/solid-sim-tutorial">https://github.com/phys-sim-book/solid-sim-tutorial</a> under the <code>3_contact</code> folder.
<a href="https://github.com/MuGdxy/muda">MUDA</a> GPU implementations can be found at <a href="https://github.com/phys-sim-book/solid-sim-tutorial-gpu">https://github.com/phys-sim-book/solid-sim-tutorial-gpu</a> under the <code>simulators/3_contact</code> folder.</p>
<p>If we further limit the planar ground to be horizontal, e.g. at \(y=y_0\), its signed distance function can be made even simpler than Equation <a href="lec7.1-signed_dists.html#eq:lec7:half_space_dist">(7.1.1)</a>:
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.8694em;vertical-align:-0.2861em;"/><span class="mord"><span class="mord mathbf">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"/><span class="mspace" style="margin-right:0.1667em;"/><span class="mord">∇</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"/><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"/><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"/><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span/></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.1667em;"/><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"/><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord">∇</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord mathbf">0</span><span class="mord">.</span><span class="enclosing" id="eq:lec8:dist_ground"/></span><span class="tag"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"/><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">8.3.1</span></span><span class="mord">)</span></span></span></span></span></span>
Combining it with Equation <a href="lec7.2-dist_barrier_formulation.html#eq:lec7:barrier_grad">(7.2.4)</a> and Equation <a href="lec7.2-dist_barrier_formulation.html#eq:lec7:barrier_hess">(7.2.5)</a>, we can conveniently implement the gradient and Hessian computation for the barrier potential of this horizontal ground:</p>
<p><a name="imp:lec8:barrier_val_grad_hess"/>
<strong>Implementation 8.3.1 (Barrier energy value, gradient, and Hessian, BarrierEnergy.py).</strong></p>
<pre><code class="language-python">import math
import numpy as np

dhat = 0.01
kappa = 1e5

def val(x, y_ground, contact_area):
    sum = 0.0
    for i in range(0, len(x)):
        d = x[i][1] - y_ground
        if d &lt; dhat:
            s = d / dhat
            sum += contact_area[i] * dhat * kappa / 2 * (s - 1) * math.log(s)
    return sum

def grad(x, y_ground, contact_area):
    g = np.array([[0.0, 0.0]] * len(x))
    for i in range(0, len(x)):
        d = x[i][1] - y_ground
        if d &lt; dhat:
            s = d / dhat
            g[i][1] = contact_area[i] * dhat * (kappa / 2 * (math.log(s) / dhat + (s - 1) / d))
    return g

def hess(x, y_ground, contact_area):
    IJV = [[0] * len(x), [0] * len(x), np.array([0.0] * len(x))]
    for i in range(0, len(x)):
        IJV[0][i] = i * 2 + 1
        IJV[1][i] = i * 2 + 1
        d = x[i][1] - y_ground
        if d &lt; dhat:
            IJV[2][i] = contact_area[i] * dhat * kappa / (2 * d * d * dhat) * (d + dhat)
        else:
            IJV[2][i] = 0.0
    return IJV
</code></pre>
<p>For the filter line search, with the position in the last iteration \(\mathbf{x}\) and a search direction \(\mathbf{p}\) of a specific node, the signed distance function is simply
\[
d(\mathbf{x} + \alpha \mathbf{p}) = \mathbf{x}_y + \alpha \mathbf{p}_y - y_0,
\]
where \(\alpha\) is the step size, and there is only one positive real root \(\alpha = (y_0 - \mathbf{x}_y) / \mathbf{p}_y\) when \(\mathbf{p}_y &lt; 0\) since \(\mathbf{x}_y &gt; y_0\) (no interpenetration up to current iteration). Taking the minimum of the positive real root per node then gives us the step size upper bound \(\alpha_C\) defined in Equation <a href="lec8.2-nonpenetration_traj.html#eq:lec8:alpha_CCD">(8.2.1)</a>:</p>
<p><a name="imp:lec8:ground_CCD"/>
<strong>Implementation 8.3.2 (Ground CCD, BarrierEnergy.py).</strong></p>
<pre><code class="language-python">def init_step_size(x, y_ground, p):
    alpha = 1
    for i in range(0, len(x)):
        if p[i][1] &lt; 0:
            alpha = min(alpha, 0.9 * (y_ground - x[i][1]) / p[i][1])
    return alpha
</code></pre>
<p>Here we scale the upper bound by \(0.9\times\) so that exact touching configurations with \(d=0\) and \(b = \infty\) (floating-point number overflow) can be avoided.</p>
<p>Then once we make sure the step size upper bound is used to initialize the line search</p>
<p><a name="imp:lec8:filter_ls"/>
<strong>Implementation 8.3.3 (Filter line search, time_integrator.py).</strong></p>
<pre><code class="language-python">        # filter line search
        alpha = BarrierEnergy.init_step_size(x, y_ground, p)  # avoid interpenetration and tunneling
        while IP_val(x + alpha * p, e, x_tilde, m, l2, k, y_ground, contact_area, h) &gt; E_last:
            alpha /= 2
</code></pre>
<p>and that the contact area weights for all nodes are calculated</p>
<p><a name="imp:lec8:contact_area"/>
<strong>Implementation 8.3.4 (Contact area, simulator.py).</strong></p>
<pre><code class="language-python">contact_area = [side_len / n_seg] * len(x)     # perimeter split to each node
</code></pre>
<p>and passed to our simulator, we can simulate the square drop with mass-spring stiffness <code>k=2e4</code> and time step size <code>h=0.01</code> as shown in <a href="#fig:lec8:square_drop">Figure 8.3.1</a>.</p>
<figure>
    <center>
    <img src="../Images/fe71ac94bc531fb47471684d96a9cc21.png" data-original-src="https://phys-sim-book.github.io/img/lec8/square_drop.jpg"/>
    </center>
    <figcaption><b><a name="fig:lec8:square_drop"/>
Figure 8.3.1.</b> A mass-spring elastic square is dropped onto the ground with <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">0</span></span></span></span> initial velocity under gravity. Here we show the frames when the square is: just dropped, first touching the ground, compressed to the maximum in this simulation, and becoming static. </figcaption>
</figure>
<blockquote>
<p><strong><a name="rm:lec8:contact_layer_integration"/>
<em>Remark 8.3.1 (Contact Layer Integration).</em></strong>
Since in practice, contact forces are only exerted on the boundary of the solids, the barrier potential should be integrated only on the boundary as well.
This also explains why in our case study the contact area weight per node is simply calculated as the diameter of the square evenly distributed onto each boundary node.
However, as mass-spring elasticity cannot guarantee that all interior nodes will stay inside the boundary of the solid, we simply apply the barrier potential to all nodal DOFs of the square.</p>
</blockquote>

                        
</body>
</html>