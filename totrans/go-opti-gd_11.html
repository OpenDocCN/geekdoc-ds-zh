<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Stack Allocations and Escape Analysis¶</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Stack Allocations and Escape Analysis¶</h1>
<blockquote>原文：<a href="https://goperf.dev/01-common-patterns/stack-alloc/">https://goperf.dev/01-common-patterns/stack-alloc/</a></blockquote>
                
                  


  
  



<p>When writing performance-critical Go applications, one of the subtle but significant optimizations you can make is encouraging values to be allocated on the stack rather than the heap. Stack allocations are cheaper, faster, and garbage-free—but Go doesn't always put your variables there automatically. That decision is made by the Go compiler during <strong>escape analysis</strong>.</p>
<p>In this article, we’ll explore what escape analysis is, how to read the compiler’s escape diagnostics, what causes values to escape, and how to structure your code to minimize unnecessary heap allocations. We'll also benchmark different scenarios to show the real-world impact.</p>
<h2 id="what-is-escape-analysis">What Is Escape Analysis?<a class="headerlink" href="#what-is-escape-analysis" title="Permanent link">¶</a></h2>
<p>Escape analysis is a static analysis performed by the Go compiler to determine whether a variable can be safely allocated on the stack or if it must be moved ("escape") to the heap.</p>
<h3 id="why-does-it-matter">Why does it matter?<a class="headerlink" href="#why-does-it-matter" title="Permanent link">¶</a></h3>
<ul>
<li><strong>Stack allocations</strong> are cheap: the memory is automatically freed when the function returns.</li>
<li><strong>Heap allocations</strong> are more expensive: they involve garbage collection overhead.</li>
</ul>
<p>The compiler decides where to place each variable based on how it's used. If a variable can be guaranteed to not outlive its declaring function, it can stay on the stack. If not, it escapes to the heap.</p>
<h3 id="example-stack-vs-heap">Example: Stack vs Heap<a class="headerlink" href="#example-stack-vs-heap" title="Permanent link">¶</a></h3>
<div class="highlight"><pre><code>func allocate() *int {
    x := 42
    return &amp;x // x escapes to the heap
}

func noEscape() int {
    x := 42
    return x // x stays on the stack
}
</code></pre></div>
<p>In <code>allocate</code>, <code>x</code> is returned as a pointer. Since the pointer escapes the function, the Go compiler places <code>x</code> on the heap. In <code>noEscape</code>, <code>x</code> is a plain value and doesn’t escape.</p>
<h2 id="how-to-view-escape-analysis-output">How to View Escape Analysis Output<a class="headerlink" href="#how-to-view-escape-analysis-output" title="Permanent link">¶</a></h2>
<p>You can inspect escape analysis with the <code>-gcflags</code> compiler option:</p>
<div class="highlight"><pre><code>go build -gcflags="-m" ./path/to/pkg
</code></pre></div>
<p>Or for a specific file:</p>
<div class="highlight"><pre><code>go run -gcflags="-m" main.go
</code></pre></div>
<p>This will print lines like:</p>
<div class="highlight"><pre><code>main.go:10:6: moved to heap: x
main.go:14:6: can inline noEscape
</code></pre></div>
<p>Look for messages like <code>moved to heap</code> to identify escape points.</p>
<h2 id="what-causes-variables-to-escape">What Causes Variables to Escape?<a class="headerlink" href="#what-causes-variables-to-escape" title="Permanent link">¶</a></h2>
<p>Here are common scenarios that force heap allocation:</p>
<h3 id="returning-pointers-to-local-variables">Returning Pointers to Local Variables<a class="headerlink" href="#returning-pointers-to-local-variables" title="Permanent link">¶</a></h3>
<div class="highlight"><pre><code>func escape() *int {
    x := 10
    return &amp;x // escapes
}
</code></pre></div>
<h3 id="capturing-variables-in-closures">Capturing Variables in Closures<a class="headerlink" href="#capturing-variables-in-closures" title="Permanent link">¶</a></h3>
<div class="highlight"><pre><code>func closureEscape() func() int {
    x := 5
    return func() int { return x } // x escapes
}
</code></pre></div>
<h3 id="interface-conversions">Interface Conversions<a class="headerlink" href="#interface-conversions" title="Permanent link">¶</a></h3>
<p>When a value is stored in an interface, it may escape:</p>
<div class="highlight"><pre><code>func toInterface(i int) interface{} {
    return i // escapes if type info needed at runtime
}
</code></pre></div>
<h3 id="assignments-to-global-variables-or-struct-fields">Assignments to Global Variables or Struct Fields<a class="headerlink" href="#assignments-to-global-variables-or-struct-fields" title="Permanent link">¶</a></h3>
<div class="highlight"><pre><code>var global *int

func assignGlobal() {
    x := 7
    global = &amp;x // escapes
}
</code></pre></div>
<h3 id="large-composite-literals">Large Composite Literals<a class="headerlink" href="#large-composite-literals" title="Permanent link">¶</a></h3>
<p>Go may allocate large structs or slices on the heap even if they don’t strictly escape.</p>
<div class="highlight"><pre><code>func makeLargeSlice() []int {
    s := make([]int, 10000) // may escape due to size
    return s
}
</code></pre></div>
<h2 id="benchmarking-stack-vs-heap-allocations">Benchmarking Stack vs Heap Allocations<a class="headerlink" href="#benchmarking-stack-vs-heap-allocations" title="Permanent link">¶</a></h2>
<p>Let’s run a benchmark to explore when heap allocations actually occur—and when they don’t, even if we return a pointer.</p>
<div class="highlight"><pre><code>func StackAlloc() Data {
    return Data{1, 2, 3} // stays on stack
}

func HeapAlloc() *Data {
    return &amp;Data{1, 2, 3} // escapes to heap
}

func BenchmarkStackAlloc(b *testing.B) {
    for b.Loop() {
        _ = StackAlloc()
    }
}

func BenchmarkHeapAlloc(b *testing.B) {
    for b.Loop() {
        _ = HeapAlloc()
    }
}
</code></pre></div>
<p>Benchmark Results</p>
<table>
<thead>
<tr>
<th>Benchmark</th>
<th>Iterations</th>
<th>Time per op (ns)</th>
<th>Bytes per op</th>
<th>Allocs per op</th>
</tr>
</thead>
<tbody>
<tr>
<td>BenchmarkStackAlloc-14</td>
<td>1,000,000,000</td>
<td>0.2604 ns</td>
<td>0 B</td>
<td>0</td>
</tr>
<tr>
<td>BenchmarkHeapAlloc-14</td>
<td>1,000,000,000</td>
<td>0.2692 ns</td>
<td>0 B</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>You might expect <code>HeapAlloc</code> to always allocate memory on the heap—but it doesn’t here. That’s because the compiler is smart: in this isolated benchmark, the pointer returned by <code>HeapAlloc</code> doesn’t escape the function in any meaningful way. The compiler can see it’s only used within the benchmark and short-lived, so it safely places it on the stack too.</p>
<h3 id="forcing-a-heap-allocation">Forcing a Heap Allocation<a class="headerlink" href="#forcing-a-heap-allocation" title="Permanent link">¶</a></h3>
<div class="highlight"><pre><code>var sink *Data

func HeapAllocEscape() {
    d := &amp;Data{1, 2, 3}
    sink = d // d escapes to heap
}

func BenchmarkHeapAllocEscape(b *testing.B) {
    for b.Loop() {
        HeapAllocEscape()
    }
}
</code></pre></div>
<table>
<thead>
<tr>
<th>Benchmark</th>
<th>Iterations</th>
<th>Time per op (ns)</th>
<th>Bytes per op</th>
<th>Allocs per op</th>
</tr>
</thead>
<tbody>
<tr>
<td>BenchmarkHeapAllocEscape-14</td>
<td>331,469,049</td>
<td>10.55 ns</td>
<td>24 B</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>As shown in <code>BenchmarkHeapAllocEscape</code>, assigning the pointer to a global variable causes a real heap escape. This introduces real overhead: a 40x slower call, a 24-byte allocation, and one garbage-collected object per call.</p>
<details class="example">
<summary>Show the benchmark file</summary>
<div class="highlight"><pre><code>package main

import "testing"

type Data struct {
    A, B, C int
}

// heap-alloc-start
func StackAlloc() Data {
    return Data{1, 2, 3} // stays on stack
}

func HeapAlloc() *Data {
    return &amp;Data{1, 2, 3} // escapes to heap
}

func BenchmarkStackAlloc(b *testing.B) {
    for b.Loop() {
        _ = StackAlloc()
    }
}

func BenchmarkHeapAlloc(b *testing.B) {
    for b.Loop() {
        _ = HeapAlloc()
    }
}
// heap-alloc-end

// escape-start
var sink *Data

func HeapAllocEscape() {
    d := &amp;Data{1, 2, 3}
    sink = d // d escapes to heap
}

func BenchmarkHeapAllocEscape(b *testing.B) {
    for b.Loop() {
        HeapAllocEscape()
    }
}
// escape-end
</code></pre></div>
</details>
<h2 id="when-to-optimize-for-stack-allocation">When to Optimize for Stack Allocation<a class="headerlink" href="#when-to-optimize-for-stack-allocation" title="Permanent link">¶</a></h2>
<p>Not all escapes are worth preventing. Here’s when it makes sense to focus on stack allocation—and when it’s better to let values escape.</p>
<p><svg viewbox="0 0 24 24"><path d="M20 12a8 8 0 0 1-8 8 8 8 0 0 1-8-8 8 8 0 0 1 8-8c.76 0 1.5.11 2.2.31l1.57-1.57A9.8 9.8 0 0 0 12 2 10 10 0 0 0 2 12a10 10 0 0 0 10 10 10 10 0 0 0 10-10M7.91 10.08 6.5 11.5 11 16 21 6l-1.41-1.42L11 13.17z"/></svg> When to Avoid Escape</p>
<ul>
<li>In performance-critical paths. Reducing heap usage in tight loops or latency-sensitive code lowers GC pressure and speeds up execution.</li>
<li>For short-lived, small objects. These can be efficiently stack-allocated without involving the garbage collector, reducing memory churn.</li>
<li>When you control the full call chain. If the object stays within your code and you can restructure it to avoid escape, it’s often worth the small refactor.</li>
<li>If profiling reveals GC bottlenecks. Escape analysis helps you target and shrink memory-heavy allocations identified in real-world traces.</li>
</ul>
<p><svg viewbox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M448 128H270.4c1 5.2 1.6 10.5 1.6 16v16h176c8.8 0 16-7.2 16-16s-7.2-16-16-16m-224 16c0-17.7-14.3-32-32-32h-24c-66.3 0-120 53.7-120 120v48c0 52.5 33.7 97.1 80.7 113.4-.5-3.1-.7-6.2-.7-9.4 0-20 9.2-37.9 23.6-49.7-4.9-9-7.6-19.4-7.6-30.3 0-15.1 5.3-29 14-40-8.8-11-14-24.9-14-40v-40c0-13.3 10.7-24 24-24s24 10.7 24 24v40c0 8.8 7.2 16 16 16s16-7.2 16-16zm-32-80c18 0 34.6 6 48 16h208c35.3 0 64 28.7 64 64s-28.7 64-64 64h-82c1.3 5.1 2 10.5 2 16 0 25.3-14.7 47.2-36 57.6 2.6 7 4 14.5 4 22.4 0 20-9.2 37.9-23.6 49.7 4.9 9 7.6 19.4 7.6 30.3 0 35.3-28.7 64-64 64h-88C75.2 448 0 372.8 0 280v-48C0 139.2 75.2 64 168 64zm64 336c8.8 0 16-7.2 16-16s-7.2-16-16-16h-64c-8.8 0-16 7.2-16 16s7.2 16 16 16zm16-176c0 5.5-.7 10.9-2 16h34c8.8 0 16-7.2 16-16s-7.2-16-16-16h-32zm-24 64h-40c-8.8 0-16 7.2-16 16s7.2 16 16 16h64c8.8 0 16-7.2 16-16s-7.2-16-16-16z"/></svg> When It’s Fine to Let Values Escape</p>
<ul>
<li>When returning values from constructors or factories. Returning a pointer from <code>NewThing()</code> is idiomatic Go—even if it causes an escape, it improves clarity and usability.</li>
<li>When objects must outlive the function. If you're storing data in a global, sending to a goroutine, or saving it in a struct, escaping is necessary and correct.</li>
<li>When allocation size is small and infrequent. If the heap allocation isn’t in a hot path, the benefit of avoiding it is often negligible.</li>
<li>When preventing escape hurts readability. Writing awkward code to keep everything on the stack can reduce maintainability for a micro-optimization that won’t matter.</li>
</ul>









  




                
                  
</body>
</html>