<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Getting Accurate Results</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Getting Accurate Results</h1>
<blockquote>原文：<a href="https://en.algorithmica.org/hpc/profiling/noise/">https://en.algorithmica.org/hpc/profiling/noise/</a></blockquote><div id="search"><input id="search-bar" type="search" placeholder="Search this book…" oninput="search()"/><div id="search-count"/><div id="search-results"/></div><header><div class="info"/></header><article><p>It is not an uncommon for there to be two library algorithm implementations, each maintaining its own benchmarking code, and each claiming to be faster than the other. This confuses everyone involved, especially the users, who have to somehow choose between the two.</p><p>Situations like these are usually not caused by fraudulent actions by their authors; they just have different definitions of what “faster” means, and indeed, defining and using just one performance metric is often very problematic.</p><span class="anchor" id="measuring-the-right-thing"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/profiling/noise/#measuring-the-right-thing">#</a>Measuring the Right Thing</h3><p>There are many things that can introduce bias into benchmarks.</p><p><strong>Differing datasets.</strong> There are many algorithms whose performance somehow depends on the dataset distribution. In order to define, for example, what the fastest sorting, shortest path, or binary search algorithms are, you have to fix the dataset on which the algorithm is run.</p><p>This sometimes applies even to algorithms that process a single piece of input. For example, it is not a good idea to feed GCD implementations sequential numbers because it makes branches very predictable:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// don't do this
</span></span></span><span class="line"><span class="cl"><span class="c1"/><span class="kt">int</span> <span class="n">checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">a</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">b</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">checksum</span> <span class="o">^=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</span></span></code></pre></div><p>However, if we sample these same numbers randomly, branch prediction becomes much harder, and the benchmark takes longer time, despite processing the same input, but in altered order:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">1000</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">checksum</span> <span class="o">+=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span></code></pre></div><p>Although the most logical choices for most cases is to just sample data uniformly at random, many real-world applications have distributions that are far from uniform, so you can’t pick just one. In general, a good benchmark should be application-specific, and use the dataset that is as representing of your real use case as possible.</p><p><strong>Multiple objectives.</strong> Some algorithm design problems have more than one key objective. For example, hash tables, in addition to being highly dependant on the distribution of keys, also need to carefully balance:</p><ul><li>memory usage,</li><li>latency of add query,</li><li>latency of positive membership query,</li><li>latency of negative membership query.</li></ul><p>The only way to choose between hash table implementations is to try and put multiple variants into the application.</p><p><strong>Latency vs Throughput.</strong> Another aspect that people often overlook is that the execution time can be defined in more than one way, even for a single query.</p><p>When you write code like this:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">checksum</span> <span class="o">^=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span></code></pre></div><p>and then time the whole thing and divide it by the number of iterations, you are actually measuring the <em>throughput</em> of the query — how many operations it can process per unit of time. This is usually less than the time it actually takes to process one operation separately because of interleaving.</p><p>To measure actual <em>latency</em>, you need to introduce a dependency between the invocations:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">checksum</span> <span class="o">^=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">checksum</span> <span class="o">^</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span></code></pre></div><p>It usually makes the most difference in algorithms with possible pipeline stall issues, e.g., when comparing branchy and branch-free algorithms.</p><p><strong>Cold cache.</strong> Another source of bias is the <em>cold cache effect</em>, when memory reads initially take longer time because the required data is not in cache yet.</p><p>This is solved by making a <em>warm-up run</em> before starting measurements:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// warm-up run
</span></span></span><span class="line"><span class="cl"><span class="c1"/>
</span></span><span class="line"><span class="cl"><span class="k">volatile</span> <span class="n">checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">checksum</span> <span class="o">^=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// actual run
</span></span></span><span class="line"><span class="cl"><span class="c1"/>
</span></span><span class="line"><span class="cl"><span class="n">clock_t</span> <span class="n">start</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">checksum</span> <span class="o">^=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span></code></pre></div><p>It is also sometimes convenient to combine the warm-up run with answer validation, if it is more complicated than just computing some sort of checksum.</p><p><strong>Over-optimization.</strong> Sometimes the benchmark is outright erroneous because the compiler just optimized the benchmarked code away. To prevent the compiler from cutting corners, you need to add checksums and either print them somewhere or add the <code>volatile</code> qualifier, which also prevents any sort of interleaving of loop iterations.</p><p>For algorithms that only write data, you can use the <code>__sync_synchronize()</code> intrinsic to add a memory fence and prevent the compiler from accumulating updates.</p><span class="anchor" id="reducing-noise"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/profiling/noise/#reducing-noise">#</a>Reducing Noise</h3><p>The issues we’ve described produce <em>bias</em> in measurements: they consistently give advantage to one algorithm over the other. There are other types of possible problems with benchmarking that result in either unpredictable skews or just completely random noise, thus increasing <em>variance</em>.</p><p>These types of issues are caused by side effects and some sort of external noise, mostly due to noisy neighbors and CPU frequency scaling:</p><ul><li>If you benchmark a compute-bound algorithm, measure its performance in cycles using <code>perf stat</code>: this way it will be independent of clock frequency, fluctuations of which is usually the main source of noise.</li><li>Otherwise, set core frequency to what you expect it to be and make sure nothing interferes with it. On Linux you can do it with <code>cpupower</code> (e.g., <code>sudo cpupower frequency-set -g powersave</code> to put it to minimum or <code>sudo cpupower frequency-set -g ondemand</code> to enable turbo boost). I use a <a href="https://extensions.gnome.org/extension/1082/cpufreq/">convenient GNOME shell extension</a> that has a separate button to do it.</li><li>If applicable, turn hyper-threading off and attach jobs to specific cores. Make sure no other jobs are running on the system, turn off networking and try not to fiddle with the mouse.</li></ul><p>You can’t remove noises and biases completely. Even a program’s name can affect its speed: the executable’s name ends up in an environment variable, environment variables end up on the call stack, and so the length of the name affects stack alignment, which can result in data accesses slowing down due to crossing cache line or memory page boundaries.</p><p>It is important to account for the noise when guiding optimizations and especially when reporting results to someone else. Unless you are expecting a 2x kind of improvement, treat all microbenchmarks the same way as A/B testing.</p><p>When you run a program on a laptop for under a second, a ±5% fluctuation in performance is completely normal. So, if you want to decide whether to revert or keep a potential +1% improvement, run it until you reach statistical significance, which you can determine by calculating variances and p-values.</p><span class="anchor" id="further-reading"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/profiling/noise/#further-reading">#</a>Further Reading</h3><p>Interested readers can explore this comprehensive <a href="https://www.cs.huji.ac.il/w~feit/exp/related.html">list of experimental computer science resources</a> by Dror Feitelson, perhaps starting with “<a href="http://eecs.northwestern.edu/~robby/courses/322-2013-spring/mytkowicz-wrong-data.pdf">Producing Wrong Data Without Doing Anything Obviously Wrong</a>” by Todd Mytkowicz et al.</p><p>You can also watch <a href="https://www.youtube.com/watch?v=r-TLSBdHe1A">this great talk</a> by Emery Berger on how to do statistically sound performance evaluation.</p></article><div class="nextprev"><div class="left"><a href="https://en.algorithmica.org/hpc/profiling/benchmarking/" id="prev-article">← Benchmarking</a></div><div class="right"><a href="https://en.algorithmica.org/hpc/arithmetic/" id="next-article">../Arithmetic →</a></div></div>    
</body>
</html>