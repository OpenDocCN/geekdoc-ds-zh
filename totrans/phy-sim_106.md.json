["```py\n# simulation setup\nside_len = 0.45\nrho = 1000      # density of square\nE = 1e5         # Young's modulus\nnu = 0.4        # Poisson's ratio\nn_seg = 2       # num of segments per side of the square\nh = 0.01        # time step size in s\nDBC = [(n_seg + 1) * (n_seg + 1) * 2]   # dirichlet node index\nDBC_v = [np.array([0.0, -0.5])]         # dirichlet node velocity\nDBC_limit = [np.array([0.0, -0.7])]     # dirichlet node limit position\nground_n = np.array([0.0, 1.0])         # normal of the slope\nground_n /= np.linalg.norm(ground_n)    # normalize ground normal vector just in case\nground_o = np.array([0.0, -1.0])        # a point on the slope  \nmu = 0.4        # friction coefficient of the slope\n\n# initialize simulation\n[x, e] = square_mesh.generate(side_len, n_seg)       # node positions and triangle node indices of the top square\ne = np.append(e, np.array(e) + [len(x)] * 3, axis=0) # add triangle node indices of the bottom square\nx = np.append(x, x + [side_len * 0.1, -side_len * 1.1], axis=0) # add node positions of the bottom square \n```", "```py\ndef find_boundary(e):\n    # index all half-edges for fast query\n    edge_set = set()\n    for i in range(0, len(e)):\n        for j in range(0, 3):\n            edge_set.add((e[i][j], e[i][(j + 1) % 3]))\n\n    # find boundary points and edges\n    bp_set = set()\n    be = []\n    for eI in edge_set:\n        if (eI[1], eI[0]) not in edge_set:\n            # if the inverse edge of a half-edge does not exist,\n            # then it is a boundary edge\n            be.append([eI[0], eI[1]])\n            bp_set.add(eI[0])\n            bp_set.add(eI[1])\n    return [list(bp_set), be] \n```"]