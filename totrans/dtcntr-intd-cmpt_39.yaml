- en: 12.4Â Cyclic DatağŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.4 å¾ªç¯æ•°æ®ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/unified-cyclic-data.html](https://dcic-world.org/2025-08-27/unified-cyclic-data.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/unified-cyclic-data.html](https://dcic-world.org/2025-08-27/unified-cyclic-data.html)
- en: '| Â Â Â Â [12.4.1Â Creating Cyclic Data](#%28part._.Creating_.Cyclic_.Data%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [12.4.1 åˆ›å»ºå¾ªç¯æ•°æ®](#%28part._.Creating_.Cyclic_.Data%29) |'
- en: '| Â Â Â Â [12.4.2Â Testing Cyclic Data](#%28part._.Testing_.Cyclic_.Data%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [12.4.2 æµ‹è¯•å¾ªç¯æ•°æ®](#%28part._.Testing_.Cyclic_.Data%29) |'
- en: '| Â Â Â Â [12.4.3Â Cycles in Practice](#%28part._.Cycles_in_.Practice%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [12.4.3 å®è·µä¸­çš„å¾ªç¯](#(part._.Cycles_in_.Practice%29) |'
- en: 12.4.1Â Creating Cyclic Data[ğŸ”—](#(part._.Creating_.Cyclic_.Data) "Link to here")
  id: totrans-5
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.1 åˆ›å»ºå¾ªç¯æ•°æ®[ğŸ”—](#(part._.Creating_.Cyclic_.Data) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Earlier [[Aliasing](mutating-structures.html#%28part._mult-bank-acct%29)], we
    introduced the idea of aliased bank accounts, where multiple customers can operate
    the same account. Sometimes, a bank wants to keep track of all the customers who
    have access to a given account. For instance, when the account balance runs low,
    it would want to notify all the customers who have access to it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¹‹å‰çš„[[åˆ«å](mutating-structures.html#%28part._mult-bank-acct%29)]ä¸­ï¼Œæˆ‘ä»¬ä»‹ç»äº†åˆ«åé“¶è¡Œè´¦æˆ·çš„æ¦‚å¿µï¼Œå³å¤šä¸ªå®¢æˆ·å¯ä»¥æ“ä½œåŒä¸€ä¸ªè´¦æˆ·ã€‚æœ‰æ—¶ï¼Œé“¶è¡Œæƒ³è¦è·Ÿè¸ªæ‰€æœ‰å¯ä»¥è®¿é—®ç‰¹å®šè´¦æˆ·çš„å®¢æˆ·ã€‚ä¾‹å¦‚ï¼Œå½“è´¦æˆ·ä½™é¢ä¸è¶³æ—¶ï¼Œå®ƒæƒ³è¦é€šçŸ¥æ‰€æœ‰å¯ä»¥è®¿é—®è¯¥è´¦æˆ·çš„å®¢æˆ·ã€‚
- en: 'Therefore, each account needs to maintain a list of its customers. Because
    the set of owners can change over time, we make that field mutable in Pyret:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæ¯ä¸ªè´¦æˆ·éƒ½éœ€è¦ç»´æŠ¤ä¸€ä¸ªå…¶å®¢æˆ·çš„åˆ—è¡¨ã€‚å› ä¸ºæ‰€æœ‰è€…é›†åˆå¯èƒ½ä¼šéšæ—¶é—´å˜åŒ–ï¼Œæˆ‘ä»¬åœ¨Pyretä¸­å°†è¯¥å­—æ®µè®¾ç½®ä¸ºå¯å˜çš„ï¼š
- en: '| Python | Pyret |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| Python | Pyret |'
- en: '|'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If you look closely, youâ€™ll see that `Account` refers to `Customer` (specifically,
    a list of them) and in turn `Customer` refers to `Account`. This could get interesting.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ ä»”ç»†è§‚å¯Ÿï¼Œä½ ä¼šçœ‹åˆ°`Account`æŒ‡å‘`Customer`ï¼ˆå…·ä½“æ¥è¯´ï¼Œæ˜¯ä¸€ä¸ªå®¢æˆ·åˆ—è¡¨ï¼‰ï¼Œè€Œ`Customer`åè¿‡æ¥åˆæŒ‡å‘`Account`ã€‚è¿™å¯èƒ½ä¼šå˜å¾—å¾ˆæœ‰è¶£ã€‚
- en: 'Previously, we could create an account with one customer as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹‹å‰ï¼Œæˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªåªæœ‰ä¸€ä¸ªå®¢æˆ·çš„è´¦æˆ·å¦‚ä¸‹ï¼š
- en: '| Python |  |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| Python |  |'
- en: '|  |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Pyret |  |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| Pyret |  |'
- en: '|  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: How do we do that now? Every `Account` requires a list of its `Customer`s. We
    need to write
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨è¯¥å¦‚ä½•åšï¼Ÿæ¯ä¸ª`Account`éƒ½éœ€è¦ä¸€ä¸ªå…¶`Customer`çš„åˆ—è¡¨ã€‚æˆ‘ä»¬éœ€è¦ç¼–å†™
- en: '| Python |  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| Python |  |'
- en: '|  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Pyret |  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| Pyret |  |'
- en: '|  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: But what goes in `_____`? It needs to refer to the very customer account that
    we are presently creating.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†`_____`ä¸­åº”è¯¥å¡«ä»€ä¹ˆï¼Ÿå®ƒéœ€è¦æŒ‡å‘æˆ‘ä»¬ç›®å‰æ­£åœ¨åˆ›å»ºçš„å®¢æˆ·è´¦æˆ·ã€‚
- en: 'Another way to think about writing this is:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€ç§æ€è€ƒè¿™ç§æ–¹å¼çš„æ–¹æ³•æ˜¯ï¼š
- en: '| Python |  |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| Python |  |'
- en: '|  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Pyret |  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| Pyret |  |'
- en: '|  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: This hasnâ€™t solved our fundamental problemâ€”<wbr>we still need to fill in `_____`â€”<wbr>but
    at least we now have names to refer to entities. We would like to be able to write
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¹¶æ²¡æœ‰è§£å†³æˆ‘ä»¬çš„åŸºæœ¬é—®é¢˜â€”â€”æˆ‘ä»¬ä»ç„¶éœ€è¦å¡«å†™`_____`â€”â€”ä½†è‡³å°‘æˆ‘ä»¬ç°åœ¨æœ‰äº†å¯ä»¥æŒ‡ä»£å®ä½“çš„åç§°ã€‚æˆ‘ä»¬å¸Œæœ›èƒ½å¤Ÿå†™å‡º
- en: '| Python |  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| Python |  |'
- en: '|  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Pyret |  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| Pyret |  |'
- en: '|  |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: But when we try to run this, both Python and Pyret will give us an error. That
    is because they try to evaluate the right-hand-side of the first line to create
    an account, whose heap address will be bound in the directory to `acct1`. To do
    so, they must evaluate that account-creation expression. In doing so, they look
    up the name `elena`. However, `elena` has not yet been bound in the directory.
    Therefore, they produce an error.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†å½“æˆ‘ä»¬å°è¯•è¿è¡Œè¿™æ®µä»£ç æ—¶ï¼ŒPythonå’ŒPyretéƒ½ä¼šç»™å‡ºé”™è¯¯ã€‚è¿™æ˜¯å› ä¸ºå®ƒä»¬è¯•å›¾è¯„ä¼°ç¬¬ä¸€è¡Œçš„å³ä¾§æ¥åˆ›å»ºä¸€ä¸ªè´¦æˆ·ï¼Œå…¶å †åœ°å€å°†è¢«ç»‘å®šåˆ°ç›®å½•ä¸­çš„`acct1`ã€‚ä¸ºäº†åšåˆ°è¿™ä¸€ç‚¹ï¼Œå®ƒä»¬å¿…é¡»è¯„ä¼°é‚£ä¸ªè´¦æˆ·åˆ›å»ºè¡¨è¾¾å¼ã€‚åœ¨è¿™æ ·åšçš„æ—¶å€™ï¼Œå®ƒä»¬æŸ¥æ‰¾åç§°`elena`ã€‚ç„¶è€Œï¼Œ`elena`å°šæœªåœ¨ç›®å½•ä¸­ç»‘å®šã€‚å› æ­¤ï¼Œå®ƒä»¬äº§ç”Ÿäº†é”™è¯¯ã€‚
- en: 'Observe that we canâ€™t just reverse the order of these two bindings. If we try
    that, we end up with the same problem: we try to create a customer that refers
    to `acct1`. But we havenâ€™t yet defined `acct1`, producing the same error.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬å¹¶ä¸èƒ½ç®€å•åœ°é¢ å€’è¿™ä¸¤ä¸ªç»‘å®šçš„é¡ºåºã€‚å¦‚æœæˆ‘ä»¬å°è¯•è¿™æ ·åšï¼Œæˆ‘ä»¬æœ€ç»ˆä¼šé‡åˆ°åŒæ ·çš„é—®é¢˜ï¼šæˆ‘ä»¬è¯•å›¾åˆ›å»ºä¸€ä¸ªæŒ‡å‘`acct1`çš„å®¢æˆ·ã€‚ä½†æˆ‘ä»¬è¿˜æ²¡æœ‰å®šä¹‰`acct1`ï¼Œè¿™ä¼šäº§ç”Ÿç›¸åŒçš„é”™è¯¯ã€‚
- en: The problem is we are trying to create cyclic data. The two data refer to one
    another. We could already sense that this might happen from the data definitions,
    and now we must confront it. The problem is that we have to create some value
    first, and we canâ€™t produce either one correctly since each one depends on the
    other.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: é—®é¢˜æ˜¯æˆ‘ä»¬æ­£åœ¨å°è¯•åˆ›å»ºå¾ªç¯æ•°æ®ã€‚è¿™ä¸¤ä¸ªæ•°æ®ç›¸äº’å¼•ç”¨ã€‚æˆ‘ä»¬æ—©å·²ä»æ•°æ®å®šä¹‰ä¸­æ„Ÿè§‰åˆ°è¿™ç§æƒ…å†µå¯èƒ½å‘ç”Ÿï¼Œç°åœ¨æˆ‘ä»¬å¿…é¡»é¢å¯¹å®ƒã€‚é—®é¢˜æ˜¯æˆ‘ä»¬å¿…é¡»é¦–å…ˆåˆ›å»ºä¸€äº›å€¼ï¼Œä½†æˆ‘ä»¬æ— æ³•æ­£ç¡®åœ°åˆ›å»ºä»»ä½•ä¸€ä¸ªï¼Œå› ä¸ºå®ƒä»¬éƒ½ä¾èµ–äºå¯¹æ–¹ã€‚
- en: As you might guess, we have to compromise. We have to construct one of the data
    first, and when we do so, it might not be entirely accurate. Then we create the
    other, and then modify the first one to have the correct contents.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚ä½ æ‰€çŒœï¼Œæˆ‘ä»¬å¿…é¡»å¦¥åã€‚æˆ‘ä»¬å¿…é¡»é¦–å…ˆæ„å»ºå…¶ä¸­ä¸€ä¸ªæ•°æ®ï¼Œå½“æˆ‘ä»¬è¿™æ ·åšæ—¶ï¼Œå®ƒå¯èƒ½å¹¶ä¸å®Œå…¨å‡†ç¡®ã€‚ç„¶åæˆ‘ä»¬åˆ›å»ºå¦ä¸€ä¸ªï¼Œç„¶åä¿®æ”¹ç¬¬ä¸€ä¸ªä»¥åŒ…å«æ­£ç¡®çš„å†…å®¹ã€‚
- en: 'In our case, the Pyret version makes clear what order to use in creating the
    data. Nothing in a `Customer` is mutable (nor needs to be), whereas the list of
    account owners is (and should be, because the set of customers can grow). Therefore,
    we can write:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬çš„æƒ…å†µä¸‹ï¼ŒPyretç‰ˆæœ¬æ¸…æ¥šåœ°è¯´æ˜äº†åˆ›å»ºæ•°æ®æ—¶åº”ä½¿ç”¨çš„é¡ºåºã€‚`Customer`ä¸­çš„ä»»ä½•å†…å®¹éƒ½ä¸æ˜¯å¯å˜çš„ï¼ˆä¹Ÿä¸éœ€è¦æ˜¯ï¼‰ï¼Œè€Œè´¦æˆ·æ‰€æœ‰è€…åˆ—è¡¨æ˜¯ï¼ˆå¹¶ä¸”åº”è¯¥æ˜¯ï¼Œå› ä¸ºå®¢æˆ·é›†å¯ä»¥å¢é•¿ï¼‰ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å†™å‡ºï¼š
- en: '| Python |  |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| Python |  |'
- en: '|  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Pyret |  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| Pyret |  |'
- en: '|  |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Note that at this point, this is actually accurate! There are no owners of this
    account.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨è¿™ä¸ªæ—¶å€™ï¼Œè¿™å®é™…ä¸Šæ˜¯å‡†ç¡®çš„ï¼è¿™ä¸ªè´¦æˆ·æ²¡æœ‰æ‰€æœ‰è€…ã€‚
- en: 'Now we create Elenaâ€™s account:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬åˆ›å»ºElenaçš„è´¦æˆ·ï¼š
- en: '| Python |  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| Python |  |'
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Pyret |  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| Pyret |  |'
- en: '|  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: At this point, our memory looks like this:For simplicity, we will show the list
    of owners inside the account instead of putting it in its own memory location(s).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œæˆ‘ä»¬çš„å†…å­˜çœ‹èµ·æ¥åƒè¿™æ ·ï¼šä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬å°†æ˜¾ç¤ºè´¦æˆ·å†…çš„æ‰€æœ‰è€…åˆ—è¡¨ï¼Œè€Œä¸æ˜¯å°†å…¶æ”¾åœ¨è‡ªå·±çš„å†…å­˜ä½ç½®ä¸­ã€‚
- en: Directory
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE14]'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE14]'
- en: â†’Â 1001
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1001
- en: '[PRE15]'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE15]'
- en: â†’Â 1002
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1002
- en: Heap
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: å †æ ˆ
- en: 1001:Â `Account(8404, 500, [])`
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1001:Â `Account(8404, 500, [])`
- en: 1002:Â `Customer("Elena", 1001)`
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1002:Â `Customer("Elena", 1001)`
- en: 'Now things are slightly inaccurate: the account at 1001 does have an owner,
    which is not yet reflected. So we have to update it to reflect that:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨äº‹æƒ…æœ‰äº›ä¸å‡†ç¡®ï¼š1001å·è´¦æˆ·ç¡®å®æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼Œä½†è¿™è¿˜æ²¡æœ‰åæ˜ å‡ºæ¥ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¿…é¡»æ›´æ–°å®ƒä»¥åæ˜ è¿™ä¸€ç‚¹ï¼š
- en: '| Python | Pyret |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| Python | Pyret |'
- en: '|'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'We can legitimately do this now because `elena` is bound in the dictionary.
    Furthermore, it is bound to something useful: Elenaâ€™s customer information. So
    now the values are properly set up: Elenaâ€™s customer information refers to the
    account, and the account refers to Elenaâ€™s customer information:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨å¯ä»¥åˆæ³•åœ°è¿™æ ·åšï¼Œå› ä¸º`elena`åœ¨å­—å…¸ä¸­æ˜¯æœ‰ç»‘å®šçš„ã€‚æ­¤å¤–ï¼Œå®ƒç»‘å®šåˆ°æœ‰ç”¨çš„ä¸œè¥¿ï¼šElenaçš„å®¢æˆ·ä¿¡æ¯ã€‚å› æ­¤ï¼Œç°åœ¨å€¼è¢«æ­£ç¡®è®¾ç½®ï¼šElenaçš„å®¢æˆ·ä¿¡æ¯æŒ‡å‘è´¦æˆ·ï¼Œè´¦æˆ·æŒ‡å‘Elenaçš„å®¢æˆ·ä¿¡æ¯ï¼š
- en: Directory
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE18]'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE18]'
- en: â†’Â 1001
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1001
- en: '[PRE19]'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE19]'
- en: â†’Â 1002
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1002
- en: Heap
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: å †æ ˆ
- en: 1001:Â `Account(8404, 500, [1002])`
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1001:Â `Account(8404, 500, [1002])`
- en: 1002:Â `Customer("Elena", 1001)`
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1002:Â `Customer("Elena", 1001)`
- en: 'This is the cycle in â€œcyclicâ€: 1001 depends on 1002 and 1002 depends on 1001.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯â€œå¾ªç¯â€ä¸­çš„å¾ªç¯ï¼š1001ä¾èµ–äº1002ï¼Œè€Œ1002åˆä¾èµ–äº1001ã€‚
- en: 'Observe that if we introduce another customer, Jorge, who shares the same account,
    we can update the account to reflect that also:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå¦‚æœæˆ‘ä»¬å¼•å…¥å¦ä¸€ä½å®¢æˆ·ï¼Œåå«Jorgeï¼Œä»–ä¸åŒä¸€ä¸ªè´¦æˆ·å…±äº«ï¼Œæˆ‘ä»¬å¯ä»¥æ›´æ–°è´¦æˆ·ä»¥åæ˜ è¿™ä¸€ç‚¹ï¼š
- en: '| Python |  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| Python |  |'
- en: '|  |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Pyret |  |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| Pyret |  |'
- en: '|  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Again, the information in `acct1` is inaccurate because it does not reflect
    the new owner. We can modify it in a similar way:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡å¼ºè°ƒï¼Œ`acct1`ä¸­çš„ä¿¡æ¯ä¸å‡†ç¡®ï¼Œå› ä¸ºå®ƒæ²¡æœ‰åæ˜ æ–°çš„æ‰€æœ‰è€…ã€‚æˆ‘ä»¬å¯ä»¥ä»¥ç±»ä¼¼çš„æ–¹å¼ä¿®æ”¹å®ƒï¼š
- en: '| Python |  |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| Python |  |'
- en: '|  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Pyret |  |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| Pyret |  |'
- en: '|  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'So now our memory would look like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œç°åœ¨æˆ‘ä»¬çš„å†…å­˜çœ‹èµ·æ¥ä¼šæ˜¯è¿™æ ·ï¼š
- en: Directory
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE24]'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE24]'
- en: â†’Â 1001
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1001
- en: '[PRE25]'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE25]'
- en: â†’Â 1002
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1002
- en: '[PRE26]'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE26]'
- en: â†’Â 1003
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1003
- en: Heap
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: å †æ ˆ
- en: 1001:Â `Account(8404, 500, [1002, 1003])`
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1001:Â `Account(8404, 500, [1002, 1003])`
- en: 1002:Â `Customer("Elena", 1001)`
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1002:Â `Customer("Elena", 1001)`
- en: 1003:Â `Customer("Jorge", 1001)`
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1003:Â `Customer("Jorge", 1001)`
- en: Do Now!
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We wrote slightly different code when adding Jorgeâ€™s account than when adding
    Elenaâ€™s account. Is one better than the other?
  id: totrans-133
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å½“æ·»åŠ Jorgeçš„è´¦æˆ·æ—¶ï¼Œæˆ‘ä»¬ç¼–å†™çš„ä»£ç ä¸æ·»åŠ Elenaçš„è´¦æˆ·æ—¶ç•¥æœ‰ä¸åŒã€‚å“ªä¸€ä¸ªæ›´å¥½ï¼Ÿ
- en: The code for Elenaâ€™s addition ignored whatever owners there previously were.
    That is, it would only work correctly in a setting where there were no other owners.
    The code for Jorgeâ€™s addition takes into account all the previous owners. Therefore,
    Elenaâ€™s code was perfectly fine for illustrating the simple first case, but Jorgeâ€™s
    code is more general in that it will work in all settings (including when the
    prior list of owners is empty).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºElenaæ·»åŠ çš„ä»£ç å¿½ç•¥äº†ä¹‹å‰å­˜åœ¨çš„æ‰€æœ‰è€…ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒåªåœ¨æ²¡æœ‰å…¶ä»–æ‰€æœ‰è€…çš„ç¯å¢ƒä¸­æ‰èƒ½æ­£ç¡®å·¥ä½œã€‚Jorgeæ·»åŠ çš„ä»£ç è€ƒè™‘äº†æ‰€æœ‰ä¹‹å‰çš„æ‰€æœ‰è€…ã€‚å› æ­¤ï¼ŒElenaçš„ä»£ç å¯¹äºè¯´æ˜ç®€å•çš„æƒ…å†µæ˜¯å®Œç¾çš„ï¼Œä½†Jorgeçš„ä»£ç æ›´é€šç”¨ï¼Œå› ä¸ºå®ƒå°†åœ¨æ‰€æœ‰ç¯å¢ƒä¸­å·¥ä½œï¼ˆåŒ…æ‹¬å½“å…ˆå‰çš„æ‰€æœ‰è€…åˆ—è¡¨ä¸ºç©ºæ—¶ï¼‰ã€‚
- en: Exercise
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function that takes care of adding a customer to an account.
  id: totrans-137
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºå°†å®¢æˆ·æ·»åŠ åˆ°è´¦æˆ·ä¸­ã€‚
- en: 12.4.2Â Testing Cyclic Data[ğŸ”—](#(part._.Testing_.Cyclic_.Data) "Link to here")
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.2Â æµ‹è¯•å¾ªç¯æ•°æ®[ğŸ”—](#(part._.Testing_.Cyclic_.Data) "é“¾æ¥è‡³æ­¤")
- en: 'When you want to write a test involving circular data, you canâ€™t write out
    the circular data manually. For example, imagine that we wanted to write out `acct1`
    from earlier:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä½ æƒ³ç¼–å†™æ¶‰åŠå¾ªç¯æ•°æ®çš„æµ‹è¯•æ—¶ï¼Œä½ ä¸èƒ½æ‰‹åŠ¨å†™å‡ºå¾ªç¯æ•°æ®ã€‚ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬æƒ³è¦å†™å‡ºä¹‹å‰æåˆ°çš„`acct1`ï¼š
- en: '| Python |  |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| Python |  |'
- en: '|  |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Pyret |  |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| Pyret |  |'
- en: '|  |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '|  |'
- en: However, because of the circularity, we canâ€™t finish writing down the data.
    We canâ€™t just leave part of it unspecified with `â€¦`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œç”±äºå¾ªç¯æ€§ï¼Œæˆ‘ä»¬æ— æ³•å®Œæˆæ•°æ®çš„ç¼–å†™ã€‚æˆ‘ä»¬ä¸èƒ½åªæ˜¯ç”¨`â€¦`çœç•¥ä¸€éƒ¨åˆ†ã€‚
- en: 'This leaves us with two choices:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç»™æˆ‘ä»¬ç•™ä¸‹äº†ä¸¤ä¸ªé€‰æ‹©ï¼š
- en: 'You have two options: write tests in terms of the names of data, or write tests
    on the components of the data.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ æœ‰ä¸¤ä¸ªé€‰æ‹©ï¼šæ ¹æ®æ•°æ®åç§°ç¼–å†™æµ‹è¯•ï¼Œæˆ–è€…æ ¹æ®æ•°æ®çš„ç»„ä»¶ç¼–å†™æµ‹è¯•ã€‚
- en: 'Hereâ€™s an example that illustrates both. After setting up the account, we might
    want to check that the owner of the new account is the new customer:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€ä¸ªç¤ºä¾‹ï¼Œè¯´æ˜äº†è¿™ä¸¤ä¸ªæ–¹é¢ã€‚åœ¨è®¾ç½®è´¦æˆ·åï¼Œæˆ‘ä»¬å¯èƒ½æƒ³è¦æ£€æŸ¥æ–°è´¦æˆ·çš„æ‰€æœ‰è€…æ˜¯å¦æ˜¯æ–°å®¢æˆ·ï¼š
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, rather than write out the `Customer` explicitly, we use the name of the
    existing item in the directory. This doesnâ€™t require you to write ellipses. We
    also focused on just the `owner` component, as a part of the `Account` value that
    we expected to change.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä¸æ˜¯æ˜ç¡®å†™å‡º`Customer`ï¼Œè€Œæ˜¯ä½¿ç”¨ç›®å½•ä¸­ç°æœ‰é¡¹çš„åç§°ã€‚è¿™ä¸éœ€è¦ä½ ç¼–å†™çœç•¥å·ã€‚æˆ‘ä»¬è¿˜ä¸“æ³¨äº`owner`ç»„ä»¶ï¼Œå®ƒæ˜¯æˆ‘ä»¬æœŸæœ›æ›´æ”¹çš„`Account`å€¼çš„ä¸€éƒ¨åˆ†ã€‚
- en: 12.4.3Â Cycles in Practice[ğŸ”—](#(part._.Cycles_in_.Practice) "Link to here")
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.3 å®è·µä¸­çš„å¾ªç¯[ğŸ”—](#(part._.Cycles_in_.Practice) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Cyclic data show up in many settings in real programs. Whenever two data are
    interrelated, and we have good reason to want to get from either one to the other,
    they have the potential to have references to each other, which can lead to cycles.
    Sometimes the connection can be to provide updates, as above; other times it can
    simply be for navigational convenience.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: å¾ªç¯æ•°æ®åœ¨çœŸå®ç¨‹åºä¸­çš„è®¸å¤šåœºæ™¯ä¸­éƒ½ä¼šå‡ºç°ã€‚æ¯å½“ä¸¤ä¸ªæ•°æ®ç›¸äº’å…³è”ï¼Œå¹¶ä¸”æˆ‘ä»¬æœ‰å¾ˆå¥½çš„ç†ç”±æƒ³è¦ä»ä¸€ä¸ªè½¬åˆ°å¦ä¸€ä¸ªæ—¶ï¼Œå®ƒä»¬å°±æœ‰å¯èƒ½ç›¸äº’å¼•ç”¨ï¼Œè¿™å¯èƒ½å¯¼è‡´å¾ªç¯ã€‚æœ‰æ—¶è¿™ç§è”ç³»å¯èƒ½æ˜¯ä¸ºäº†æä¾›æ›´æ–°ï¼Œå¦‚ä¸Šæ‰€è¿°ï¼›æœ‰æ—¶å®ƒå¯èƒ½åªæ˜¯ä¸ºäº†å¯¼èˆªæ–¹ä¾¿ã€‚
- en: 'Consider the Document Object Model (DOM), which is the data structure that
    represents every Web page in a Web browser. Programmers usually think of the DOM
    hierarchically, as a tree, because every note refers to all the nodes that constitute
    it: e.g., a page has references to each of its paragraphs, a list has references
    to each list item, and so forth. However, every one of these elements also has
    a reference to its parent. This way, a program can conveniently traverse â€œdownwardâ€
    or â€œupwardâ€.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘æ–‡æ¡£å¯¹è±¡æ¨¡å‹ï¼ˆDOMï¼‰ï¼Œå®ƒæ˜¯è¡¨ç¤ºæµè§ˆå™¨ä¸­æ¯ä¸ªç½‘é¡µçš„æ•°æ®ç»“æ„ã€‚ç¨‹åºå‘˜é€šå¸¸å°†DOMè§†ä¸ºå±‚æ¬¡ç»“æ„ï¼Œå°±åƒä¸€æ£µæ ‘ï¼Œå› ä¸ºæ¯ä¸ªèŠ‚ç‚¹éƒ½å¼•ç”¨æ„æˆå®ƒçš„æ‰€æœ‰èŠ‚ç‚¹ï¼šä¾‹å¦‚ï¼Œä¸€ä¸ªé¡µé¢å¼•ç”¨äº†å®ƒçš„æ¯ä¸ªæ®µè½ï¼Œä¸€ä¸ªåˆ—è¡¨å¼•ç”¨äº†æ¯ä¸ªåˆ—è¡¨é¡¹ï¼Œç­‰ç­‰ã€‚ç„¶è€Œï¼Œè¿™äº›å…ƒç´ ä¸­çš„æ¯ä¸€ä¸ªä¹Ÿéƒ½æœ‰ä¸€ä¸ªå¼•ç”¨å…¶çˆ¶å…ƒç´ çš„å¼•ç”¨ã€‚è¿™æ ·ï¼Œç¨‹åºå¯ä»¥æ–¹ä¾¿åœ°å‘ä¸‹æˆ–å‘ä¸Šéå†ã€‚
- en: Programming with cyclic data introduces complications. If we traverse the data
    naÃ¯vely, we would go into an infinite loop. Rather, we have to keep track of the
    data we have previously visited, and make sure we donâ€™t visit them again (see
    [The Size of a DAG](size-of-dag.html)). Indeed, cyclic data are graphs [[Graphs](part_graphs.html)],
    so issues in processing graphs become relevant here.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨å¾ªç¯æ•°æ®ç¼–ç¨‹ä¼šå¼•å…¥å¤æ‚æ€§ã€‚å¦‚æœæˆ‘ä»¬å¤©çœŸåœ°éå†æ•°æ®ï¼Œæˆ‘ä»¬å°±ä¼šè¿›å…¥æ— é™å¾ªç¯ã€‚ç›¸åï¼Œæˆ‘ä»¬å¿…é¡»è·Ÿè¸ªæˆ‘ä»¬ä¹‹å‰è®¿é—®è¿‡çš„æ•°æ®ï¼Œå¹¶ç¡®ä¿æˆ‘ä»¬ä¸å†è®¿é—®å®ƒä»¬ï¼ˆå‚è§[æœ‰å‘æ— ç¯å›¾çš„å¤§å°](size-of-dag.html)ï¼‰ã€‚å®é™…ä¸Šï¼Œå¾ªç¯æ•°æ®æ˜¯å›¾
    [[å›¾](part_graphs.html)]ï¼Œå› æ­¤å¤„ç†å›¾çš„é—®é¢˜åœ¨è¿™é‡Œå˜å¾—ç›¸å…³ã€‚
- en: One interesting question that programming languages face is, how do you print
    cyclic data? For instance, what happens if the programmer writes
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ç¼–ç¨‹è¯­è¨€é¢ä¸´çš„ä¸€ä¸ªæœ‰è¶£çš„é—®é¢˜æ˜¯ï¼Œå¦‚ä½•æ‰“å°å¾ªç¯æ•°æ®ï¼Ÿä¾‹å¦‚ï¼Œå¦‚æœç¨‹åºå‘˜ç¼–å†™
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '? To print the account we must print its owners; to print each owner, we must
    print their account; to print that accountâ€¦'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '? ä¸ºäº†æ‰“å°è´¦æˆ·ï¼Œæˆ‘ä»¬å¿…é¡»æ‰“å°å…¶æ‰€æœ‰è€…ï¼›ä¸ºäº†æ‰“å°æ¯ä¸ªæ‰€æœ‰è€…ï¼Œæˆ‘ä»¬å¿…é¡»æ‰“å°ä»–ä»¬çš„è´¦æˆ·ï¼›ä¸ºäº†æ‰“å°é‚£ä¸ªè´¦æˆ·â€¦'
- en: Do Now!
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try it out in both Python and Pyret!
  id: totrans-163
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨Pythonå’ŒPyretä¸­å°è¯•ä¸€ä¸‹ï¼
- en: Different programming languages handle this problem in different ways. Some
    languages will go into an infinite loop trying to print cyclic data. Both Python
    and Pyret handle this more intelligently. Determining even whether a datum is
    cyclic is an interesting question, which we take up in [Detecting Cycles](cycle-detection.html).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸åŒç¼–ç¨‹è¯­è¨€ä»¥ä¸åŒçš„æ–¹å¼å¤„ç†è¿™ä¸ªé—®é¢˜ã€‚ä¸€äº›è¯­è¨€ä¼šå°è¯•æ‰“å°å¾ªç¯æ•°æ®è€Œè¿›å…¥æ— é™å¾ªç¯ã€‚Pythonå’ŒPyretéƒ½å¤„ç†è¿™ä¸ªé—®é¢˜æ›´ä¸ºæ™ºèƒ½ã€‚ç¡®å®šæ•°æ®æ˜¯å¦å¾ªç¯æœ¬èº«å°±æ˜¯ä¸€ä¸ªæœ‰è¶£çš„é—®é¢˜ï¼Œæˆ‘ä»¬åœ¨[æ£€æµ‹å¾ªç¯](cycle-detection.html)ä¸­æ¢è®¨äº†è¿™ä¸ªé—®é¢˜ã€‚
- en: 12.4.1Â Creating Cyclic Data[ğŸ”—](#(part._.Creating_.Cyclic_.Data) "Link to here")
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.1 åˆ›å»ºå¾ªç¯æ•°æ®[ğŸ”—](#(part._.Creating_.Cyclic_.Data) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Earlier [[Aliasing](mutating-structures.html#%28part._mult-bank-acct%29)], we
    introduced the idea of aliased bank accounts, where multiple customers can operate
    the same account. Sometimes, a bank wants to keep track of all the customers who
    have access to a given account. For instance, when the account balance runs low,
    it would want to notify all the customers who have access to it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¹‹å‰çš„[[åˆ«å](mutating-structures.html#%28part._mult-bank-acct%29)]ä¸­ï¼Œæˆ‘ä»¬ä»‹ç»äº†åˆ«åé“¶è¡Œè´¦æˆ·çš„æ¦‚å¿µï¼Œå…¶ä¸­å¤šä¸ªå®¢æˆ·å¯ä»¥æ“ä½œåŒä¸€ä¸ªè´¦æˆ·ã€‚æœ‰æ—¶ï¼Œé“¶è¡Œå¸Œæœ›è·Ÿè¸ªæ‰€æœ‰å¯ä»¥è®¿é—®ç»™å®šè´¦æˆ·çš„å®¢æˆ·ã€‚ä¾‹å¦‚ï¼Œå½“è´¦æˆ·ä½™é¢ä¸è¶³æ—¶ï¼Œå®ƒå¸Œæœ›é€šçŸ¥æ‰€æœ‰å¯ä»¥è®¿é—®å®ƒçš„å®¢æˆ·ã€‚
- en: 'Therefore, each account needs to maintain a list of its customers. Because
    the set of owners can change over time, we make that field mutable in Pyret:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæ¯ä¸ªè´¦æˆ·éƒ½éœ€è¦ç»´æŠ¤å…¶å®¢æˆ·çš„åˆ—è¡¨ã€‚å› ä¸ºæ‰€æœ‰è€…çš„é›†åˆå¯èƒ½ä¼šéšæ—¶é—´å˜åŒ–ï¼Œæˆ‘ä»¬åœ¨Pyretä¸­ä½¿è¯¥å­—æ®µå¯å˜ï¼š
- en: '| Python | Pyret |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| Python | Pyret |'
- en: '|'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If you look closely, youâ€™ll see that `Account` refers to `Customer` (specifically,
    a list of them) and in turn `Customer` refers to `Account`. This could get interesting.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ ä»”ç»†è§‚å¯Ÿï¼Œä½ ä¼šå‘ç°`Account`å¼•ç”¨äº†`Customer`ï¼ˆç‰¹åˆ«æ˜¯å®ƒä»¬çš„åˆ—è¡¨ï¼‰å¹¶ä¸”åè¿‡æ¥`Customer`ä¹Ÿå¼•ç”¨äº†`Account`ã€‚è¿™å¯èƒ½ä¼šå˜å¾—å¾ˆæœ‰è¶£ã€‚
- en: 'Previously, we could create an account with one customer as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥å‰ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·åˆ›å»ºä¸€ä¸ªè´¦æˆ·ï¼š
- en: '| Python |  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| Python |  |'
- en: '|  |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Pyret |  |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| Pyret |  |'
- en: '|  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: How do we do that now? Every `Account` requires a list of its `Customer`s. We
    need to write
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬è¯¥å¦‚ä½•åšï¼Ÿæ¯ä¸ª`Account`éƒ½éœ€è¦ä¸€ä¸ªå…¶`Customer`sçš„åˆ—è¡¨ã€‚æˆ‘ä»¬éœ€è¦ç¼–å†™
- en: '| Python |  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| Python |  |'
- en: '|  |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '|'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Pyret |  |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| Pyret |  |'
- en: '|  |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '|'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: But what goes in `_____`? It needs to refer to the very customer account that
    we are presently creating.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†`_____`é‡Œåº”è¯¥å¡«ä»€ä¹ˆï¼Ÿå®ƒéœ€è¦æŒ‡ä»£æˆ‘ä»¬ç›®å‰æ­£åœ¨åˆ›å»ºçš„ç‰¹å®šå®¢æˆ·è´¦æˆ·ã€‚
- en: 'Another way to think about writing this is:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€ç§æ€è€ƒç¼–å†™è¿™ä¸ªçš„æ–¹æ³•æ˜¯ï¼š
- en: '| Python |  |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| Python |  |'
- en: '|  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '|'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Pyret |  |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| Pyret |  |'
- en: '|  |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '|'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: This hasnâ€™t solved our fundamental problemâ€”<wbr>we still need to fill in `_____`â€”<wbr>but
    at least we now have names to refer to entities. We would like to be able to write
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¹¶æ²¡æœ‰è§£å†³æˆ‘ä»¬çš„åŸºæœ¬é—®é¢˜â€”â€”æˆ‘ä»¬ä»ç„¶éœ€è¦å¡«å†™`_____`â€”â€”ä½†è‡³å°‘æˆ‘ä»¬ç°åœ¨æœ‰äº†å¯ä»¥æŒ‡ä»£å®ä½“çš„åç§°ã€‚æˆ‘ä»¬å¸Œæœ›èƒ½å¤Ÿå†™å‡º
- en: '| Python |  |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| Python |  |'
- en: '|  |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '|'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Pyret |  |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| Pyret |  |'
- en: '|  |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: But when we try to run this, both Python and Pyret will give us an error. That
    is because they try to evaluate the right-hand-side of the first line to create
    an account, whose heap address will be bound in the directory to `acct1`. To do
    so, they must evaluate that account-creation expression. In doing so, they look
    up the name `elena`. However, `elena` has not yet been bound in the directory.
    Therefore, they produce an error.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†å½“æˆ‘ä»¬å°è¯•è¿è¡Œè¿™ä¸ªç¨‹åºæ—¶ï¼ŒPythonå’ŒPyretéƒ½ä¼šç»™æˆ‘ä»¬ä¸€ä¸ªé”™è¯¯ã€‚è¿™æ˜¯å› ä¸ºå®ƒä»¬è¯•å›¾è¯„ä¼°ç¬¬ä¸€è¡Œçš„å³ä¾§æ¥åˆ›å»ºä¸€ä¸ªè´¦æˆ·ï¼Œå…¶å †åœ°å€å°†è¢«ç»‘å®šåˆ°`acct1`ã€‚ä¸ºäº†åšåˆ°è¿™ä¸€ç‚¹ï¼Œå®ƒä»¬å¿…é¡»è¯„ä¼°é‚£ä¸ªè´¦æˆ·åˆ›å»ºè¡¨è¾¾å¼ã€‚åœ¨è¿™æ ·åšçš„æ—¶å€™ï¼Œå®ƒä»¬æŸ¥æ‰¾åç§°`elena`ã€‚ç„¶è€Œï¼Œ`elena`å°šæœªåœ¨ç›®å½•ä¸­ç»‘å®šã€‚å› æ­¤ï¼Œå®ƒä»¬äº§ç”Ÿäº†ä¸€ä¸ªé”™è¯¯ã€‚
- en: 'Observe that we canâ€™t just reverse the order of these two bindings. If we try
    that, we end up with the same problem: we try to create a customer that refers
    to `acct1`. But we havenâ€™t yet defined `acct1`, producing the same error.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬æ— æ³•ç®€å•åœ°é¢ å€’è¿™ä¸¤ä¸ªç»‘å®šçš„é¡ºåºã€‚å¦‚æœæˆ‘ä»¬å°è¯•è¿™æ ·åšï¼Œæˆ‘ä»¬æœ€ç»ˆä¼šé‡åˆ°ç›¸åŒçš„é—®é¢˜ï¼šæˆ‘ä»¬å°è¯•åˆ›å»ºä¸€ä¸ªå¼•ç”¨`acct1`çš„å®¢æˆ·ã€‚ä½†æˆ‘ä»¬è¿˜æ²¡æœ‰å®šä¹‰`acct1`ï¼Œè¿™ä¼šäº§ç”Ÿç›¸åŒçš„é”™è¯¯ã€‚
- en: The problem is we are trying to create cyclic data. The two data refer to one
    another. We could already sense that this might happen from the data definitions,
    and now we must confront it. The problem is that we have to create some value
    first, and we canâ€™t produce either one correctly since each one depends on the
    other.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: é—®é¢˜åœ¨äºæˆ‘ä»¬æ­£åœ¨å°è¯•åˆ›å»ºå¾ªç¯æ•°æ®ã€‚è¿™ä¸¤ä¸ªæ•°æ®ç›¸äº’å¼•ç”¨ã€‚æˆ‘ä»¬æ—©å·²ä»æ•°æ®å®šä¹‰ä¸­æ„Ÿè§‰åˆ°å¯èƒ½ä¼šå‘ç”Ÿè¿™ç§æƒ…å†µï¼Œç°åœ¨æˆ‘ä»¬å¿…é¡»é¢å¯¹å®ƒã€‚é—®é¢˜åœ¨äºæˆ‘ä»¬å¿…é¡»é¦–å…ˆåˆ›å»ºä¸€äº›å€¼ï¼Œä½†ç”±äºæ¯ä¸ªå€¼éƒ½ä¾èµ–äºå¦ä¸€ä¸ªï¼Œæˆ‘ä»¬æ— æ³•æ­£ç¡®åœ°åˆ›å»ºä»»ä½•ä¸€ä¸ªã€‚
- en: As you might guess, we have to compromise. We have to construct one of the data
    first, and when we do so, it might not be entirely accurate. Then we create the
    other, and then modify the first one to have the correct contents.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚ä½ æ‰€çŒœï¼Œæˆ‘ä»¬å¿…é¡»å¦¥åã€‚æˆ‘ä»¬å¿…é¡»é¦–å…ˆæ„å»ºå…¶ä¸­ä¸€ä¸ªæ•°æ®ï¼Œå½“æˆ‘ä»¬è¿™æ ·åšæ—¶ï¼Œå®ƒå¯èƒ½å¹¶ä¸å®Œå…¨å‡†ç¡®ã€‚ç„¶åæˆ‘ä»¬åˆ›å»ºå¦ä¸€ä¸ªï¼Œç„¶åä¿®æ”¹ç¬¬ä¸€ä¸ªä»¥åŒ…å«æ­£ç¡®çš„å†…å®¹ã€‚
- en: 'In our case, the Pyret version makes clear what order to use in creating the
    data. Nothing in a `Customer` is mutable (nor needs to be), whereas the list of
    account owners is (and should be, because the set of customers can grow). Therefore,
    we can write:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬çš„æƒ…å†µä¸‹ï¼ŒPyretç‰ˆæœ¬æ¸…æ¥šåœ°è¯´æ˜äº†åˆ›å»ºæ•°æ®æ—¶åº”ä½¿ç”¨çš„é¡ºåºã€‚åœ¨`Customer`ä¸­æ²¡æœ‰ä»»ä½•å†…å®¹æ˜¯å¯å˜çš„ï¼ˆä¹Ÿä¸éœ€è¦æ˜¯ï¼‰ï¼Œè€Œè´¦æˆ·æ‰€æœ‰è€…çš„åˆ—è¡¨æ˜¯ï¼ˆå¹¶ä¸”åº”è¯¥æ˜¯ï¼Œå› ä¸ºå®¢æˆ·çš„é›†åˆå¯ä»¥å¢é•¿ï¼‰ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å†™å‡ºï¼š
- en: '| Python |  |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| Python |  |'
- en: '|  |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '|'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Pyret |  |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| Pyret |  |'
- en: '|  |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '|'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Note that at this point, this is actually accurate! There are no owners of this
    account.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨è¿™ä¸ªé˜¶æ®µï¼Œè¿™å®é™…ä¸Šæ˜¯å‡†ç¡®çš„ï¼è¿™ä¸ªè´¦æˆ·æ²¡æœ‰æ‰€æœ‰è€…ã€‚
- en: 'Now we create Elenaâ€™s account:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬åˆ›å»ºä¼Šè²å¨œçš„è´¦æˆ·ï¼š
- en: '| Python |  |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| Python |  |'
- en: '|  |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '|'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Pyret |  |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| Pyret |  |'
- en: '|  |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '|'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: At this point, our memory looks like this:For simplicity, we will show the list
    of owners inside the account instead of putting it in its own memory location(s).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œæˆ‘ä»¬çš„å†…å­˜çœ‹èµ·æ¥åƒè¿™æ ·ï¼šä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬å°†æ˜¾ç¤ºè´¦æˆ·å†…çš„æ‰€æœ‰è€…åˆ—è¡¨ï¼Œè€Œä¸æ˜¯å°†å…¶æ”¾åœ¨è‡ªå·±çš„å†…å­˜ä½ç½®ä¸­ã€‚
- en: Directory
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE45]'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE45]'
- en: â†’Â 1001
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’ 1001
- en: '[PRE46]'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE46]'
- en: â†’Â 1002
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’ 1002
- en: Heap
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: 1001:Â `Account(8404, 500, [])`
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1001: `Account(8404, 500, [])`'
- en: 1002:Â `Customer("Elena", 1001)`
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1002: `Customer("Elena", 1001)`'
- en: 'Now things are slightly inaccurate: the account at 1001 does have an owner,
    which is not yet reflected. So we have to update it to reflect that:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨äº‹æƒ…æœ‰äº›ä¸å‡†ç¡®ï¼š1001å·è´¦æˆ·ç¡®å®æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼Œä½†è¿™è¿˜æ²¡æœ‰åæ˜ å‡ºæ¥ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¿…é¡»æ›´æ–°å®ƒä»¥åæ˜ è¿™ä¸€ç‚¹ï¼š
- en: '| Python | Pyret |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| Python | Pyret |'
- en: '|'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '|'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE48]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '|'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'We can legitimately do this now because `elena` is bound in the dictionary.
    Furthermore, it is bound to something useful: Elenaâ€™s customer information. So
    now the values are properly set up: Elenaâ€™s customer information refers to the
    account, and the account refers to Elenaâ€™s customer information:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨å¯ä»¥åˆæ³•åœ°è¿™æ ·åšï¼Œå› ä¸º`elena`åœ¨å­—å…¸ä¸­æ˜¯æœ‰ç»‘å®šçš„ã€‚æ­¤å¤–ï¼Œå®ƒç»‘å®šåˆ°æœ‰ç”¨çš„ä¸œè¥¿ï¼šä¼Šè²å¨œçš„å®¢æˆ·ä¿¡æ¯ã€‚å› æ­¤ï¼Œç°åœ¨å€¼è¢«æ­£ç¡®è®¾ç½®ï¼šä¼Šè²å¨œçš„å®¢æˆ·ä¿¡æ¯æŒ‡å‘è´¦æˆ·ï¼Œè´¦æˆ·æŒ‡å‘ä¼Šè²å¨œçš„å®¢æˆ·ä¿¡æ¯ï¼š
- en: Directory
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE49]'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE49]'
- en: â†’Â 1001
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’ 1001
- en: '[PRE50]'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE50]'
- en: â†’Â 1002
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’ 1002
- en: Heap
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: 1001:Â `Account(8404, 500, [1002])`
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1001: `Account(8404, 500, [1002])`'
- en: 1002:Â `Customer("Elena", 1001)`
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1002: `Customer("Elena", 1001)`'
- en: 'This is the cycle in â€œcyclicâ€: 1001 depends on 1002 and 1002 depends on 1001.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯åœ¨â€œå¾ªç¯â€ä¸­çš„å¾ªç¯ï¼š1001ä¾èµ–äº1002ï¼Œè€Œ1002ä¾èµ–äº1001ã€‚
- en: 'Observe that if we introduce another customer, Jorge, who shares the same account,
    we can update the account to reflect that also:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: è§‚å¯Ÿåˆ°å¦‚æœæˆ‘ä»¬å¼•å…¥å¦ä¸€ä¸ªå®¢æˆ·ï¼Œä¹”æ²»ï¼Œä»–ä¸åŒä¸€ä¸ªè´¦æˆ·å…±äº«ï¼Œæˆ‘ä»¬å¯ä»¥æ›´æ–°è´¦æˆ·ä»¥åæ˜ è¿™ä¸€ç‚¹ï¼š
- en: '| Python |  |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| Python |  |'
- en: '|  |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE51]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '|'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Pyret |  |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| Pyret |  |'
- en: '|  |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '|'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Again, the information in `acct1` is inaccurate because it does not reflect
    the new owner. We can modify it in a similar way:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡ï¼Œ`acct1`ä¸­çš„ä¿¡æ¯ä¸å‡†ç¡®ï¼Œå› ä¸ºå®ƒæ²¡æœ‰åæ˜ æ–°çš„æ‰€æœ‰è€…ã€‚æˆ‘ä»¬å¯ä»¥ä»¥ç±»ä¼¼çš„æ–¹å¼ä¿®æ”¹å®ƒï¼š
- en: '| Python |  |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| Python |  |'
- en: '|  |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE53]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '|'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Pyret |  |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| Pyret |  |'
- en: '|  |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE54]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '|'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'So now our memory would look like this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œç°åœ¨æˆ‘ä»¬çš„å†…å­˜çœ‹èµ·æ¥åƒè¿™æ ·ï¼š
- en: Directory
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE55]'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE55]'
- en: â†’Â 1001
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’ 1001
- en: '[PRE56]'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE56]'
- en: â†’Â 1002
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’ 1002
- en: '[PRE57]'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE57]'
- en: â†’Â 1003
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’ 1003
- en: Heap
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: 1001:Â `Account(8404, 500, [1002, 1003])`
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1001: `Account(8404, 500, [1002, 1003])`'
- en: 1002:Â `Customer("Elena", 1001)`
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1002: `Customer("Elena", 1001)`'
- en: 1003:Â `Customer("Jorge", 1001)`
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1003: `Customer("Jorge", 1001)`'
- en: Do Now!
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We wrote slightly different code when adding Jorgeâ€™s account than when adding
    Elenaâ€™s account. Is one better than the other?
  id: totrans-293
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨æ·»åŠ ä¹”æ²»çš„è´¦æˆ·æ—¶å†™çš„ä»£ç ä¸æ·»åŠ ä¼Šè²å¨œçš„è´¦æˆ·æ—¶å†™çš„ä»£ç ç•¥æœ‰ä¸åŒã€‚å“ªä¸€ä¸ªæ›´å¥½ï¼Ÿ
- en: The code for Elenaâ€™s addition ignored whatever owners there previously were.
    That is, it would only work correctly in a setting where there were no other owners.
    The code for Jorgeâ€™s addition takes into account all the previous owners. Therefore,
    Elenaâ€™s code was perfectly fine for illustrating the simple first case, but Jorgeâ€™s
    code is more general in that it will work in all settings (including when the
    prior list of owners is empty).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ä¼Šè²å¨œå¢åŠ çš„ä»£ç å¿½ç•¥äº†ä¹‹å‰å­˜åœ¨çš„ä»»ä½•æ‰€æœ‰è€…ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒåªåœ¨æ²¡æœ‰å…¶ä»–æ‰€æœ‰è€…çš„ç¯å¢ƒä¸­æ‰èƒ½æ­£ç¡®å·¥ä½œã€‚ä¹”æ²»å¢åŠ çš„ä»£ç è€ƒè™‘äº†æ‰€æœ‰ä¹‹å‰çš„æ‰€æœ‰è€…ã€‚å› æ­¤ï¼Œä¼Šè²å¨œçš„ä»£ç éå¸¸é€‚åˆè¯´æ˜ç®€å•çš„ç¬¬ä¸€ç§æƒ…å†µï¼Œä½†ä¹”æ²»çš„ä»£ç æ›´é€šç”¨ï¼Œå› ä¸ºå®ƒå°†åœ¨æ‰€æœ‰ç¯å¢ƒä¸­å·¥ä½œï¼ˆåŒ…æ‹¬å½“å…ˆå‰æ‰€æœ‰è€…çš„åˆ—è¡¨ä¸ºç©ºæ—¶ï¼‰ã€‚
- en: Exercise
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function that takes care of adding a customer to an account.
  id: totrans-297
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºå°†å®¢æˆ·æ·»åŠ åˆ°è´¦æˆ·ä¸­ã€‚
- en: 12.4.2Â Testing Cyclic Data[ğŸ”—](#(part._.Testing_.Cyclic_.Data) "Link to here")
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.2 æµ‹è¯•å¾ªç¯æ•°æ®[ğŸ”—](#(part._.Testing_.Cyclic_.Data) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'When you want to write a test involving circular data, you canâ€™t write out
    the circular data manually. For example, imagine that we wanted to write out `acct1`
    from earlier:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä½ æƒ³ç¼–å†™æ¶‰åŠå¾ªç¯æ•°æ®çš„æµ‹è¯•æ—¶ï¼Œä½ ä¸èƒ½æ‰‹åŠ¨ç¼–å†™å¾ªç¯æ•°æ®ã€‚ä¾‹å¦‚ï¼Œæƒ³è±¡ä¸€ä¸‹æˆ‘ä»¬æƒ³è¦ç¼–å†™ä¹‹å‰æåˆ°çš„`acct1`ï¼š
- en: '| Python |  |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| Python |  |'
- en: '|  |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE58]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '|'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Pyret |  |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| Pyret |  |'
- en: '|  |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE59]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '|'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: However, because of the circularity, we canâ€™t finish writing down the data.
    We canâ€™t just leave part of it unspecified with `â€¦`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œç”±äºå¾ªç¯æ€§ï¼Œæˆ‘ä»¬æ— æ³•å®Œæˆæ•°æ®çš„ç¼–å†™ã€‚æˆ‘ä»¬ä¸èƒ½åªæ˜¯ç”¨`...`æ¥ç•™ä¸‹éƒ¨åˆ†æœªæŒ‡å®šã€‚
- en: 'This leaves us with two choices:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è®©æˆ‘ä»¬æœ‰ä¸¤ä¸ªé€‰æ‹©ï¼š
- en: 'You have two options: write tests in terms of the names of data, or write tests
    on the components of the data.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ æœ‰ä¸¤ä¸ªé€‰æ‹©ï¼šç”¨æ•°æ®åç§°ç¼–å†™æµ‹è¯•ï¼Œæˆ–è€…ç”¨æ•°æ®çš„ç»„æˆéƒ¨åˆ†ç¼–å†™æµ‹è¯•ã€‚
- en: 'Hereâ€™s an example that illustrates both. After setting up the account, we might
    want to check that the owner of the new account is the new customer:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€ä¸ªç¤ºä¾‹ï¼Œè¯´æ˜äº†è¿™ä¸¤è€…ã€‚åœ¨è®¾ç½®è´¦æˆ·åï¼Œæˆ‘ä»¬å¯èƒ½æƒ³è¦æ£€æŸ¥æ–°è´¦æˆ·çš„æ‰€æœ‰è€…æ˜¯å¦æ˜¯æ–°å®¢æˆ·ï¼š
- en: '[PRE60]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, rather than write out the `Customer` explicitly, we use the name of the
    existing item in the directory. This doesnâ€™t require you to write ellipses. We
    also focused on just the `owner` component, as a part of the `Account` value that
    we expected to change.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä¸æ˜¯æ˜ç¡®å†™å‡º `Customer`ï¼Œè€Œæ˜¯ä½¿ç”¨ç›®å½•ä¸­ç°æœ‰é¡¹ç›®çš„åç§°ã€‚è¿™ä¸éœ€è¦ä½ å†™çœç•¥å·ã€‚æˆ‘ä»¬è¿˜ä¸“æ³¨äº `owner` ç»„ä»¶ï¼Œå®ƒæ˜¯æˆ‘ä»¬æœŸæœ›æ”¹å˜çš„
    `Account` å€¼çš„ä¸€éƒ¨åˆ†ã€‚
- en: 12.4.3Â Cycles in Practice[ğŸ”—](#(part._.Cycles_in_.Practice) "Link to here")
  id: totrans-314
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.3 å®è·µä¸­çš„å¾ªç¯[ğŸ”—](#(part._.Cycles_in_.Practice) "é“¾æ¥è‡³æ­¤")
- en: Cyclic data show up in many settings in real programs. Whenever two data are
    interrelated, and we have good reason to want to get from either one to the other,
    they have the potential to have references to each other, which can lead to cycles.
    Sometimes the connection can be to provide updates, as above; other times it can
    simply be for navigational convenience.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: å¾ªç¯æ•°æ®åœ¨çœŸå®ç¨‹åºä¸­çš„è®¸å¤šåœºæ™¯ä¸­éƒ½ä¼šå‡ºç°ã€‚æ¯å½“ä¸¤ä¸ªæ•°æ®ç›¸äº’å…³è”ï¼Œå¹¶ä¸”æˆ‘ä»¬æœ‰å……åˆ†çš„ç†ç”±æƒ³è¦ä»ä¸€ä¸ªè½¬åˆ°å¦ä¸€ä¸ªæ—¶ï¼Œå®ƒä»¬å°±æœ‰å¯èƒ½ç›¸äº’å¼•ç”¨ï¼Œè¿™å¯èƒ½å¯¼è‡´å¾ªç¯ã€‚æœ‰æ—¶è¿™ç§è”ç³»å¯èƒ½æ˜¯ä¸ºäº†æä¾›æ›´æ–°ï¼Œå¦‚ä¸Šæ‰€è¿°ï¼›æœ‰æ—¶å®ƒå¯èƒ½åªæ˜¯ä¸ºäº†å¯¼èˆªæ–¹ä¾¿ã€‚
- en: 'Consider the Document Object Model (DOM), which is the data structure that
    represents every Web page in a Web browser. Programmers usually think of the DOM
    hierarchically, as a tree, because every note refers to all the nodes that constitute
    it: e.g., a page has references to each of its paragraphs, a list has references
    to each list item, and so forth. However, every one of these elements also has
    a reference to its parent. This way, a program can conveniently traverse â€œdownwardâ€
    or â€œupwardâ€.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘æ–‡æ¡£å¯¹è±¡æ¨¡å‹ï¼ˆDOMï¼‰ï¼Œå®ƒæ˜¯ä»£è¡¨æµè§ˆå™¨ä¸­æ¯ä¸ªç½‘é¡µçš„æ•°æ®ç»“æ„ã€‚ç¨‹åºå‘˜é€šå¸¸å°† DOM è§†ä¸ºå±‚æ¬¡ç»“æ„ï¼Œå³ä¸€æ£µæ ‘ï¼Œå› ä¸ºæ¯ä¸ªèŠ‚ç‚¹éƒ½å¼•ç”¨æ„æˆå®ƒçš„æ‰€æœ‰èŠ‚ç‚¹ï¼šä¾‹å¦‚ï¼Œä¸€ä¸ªé¡µé¢å¼•ç”¨äº†å®ƒçš„æ¯ä¸ªæ®µè½ï¼Œä¸€ä¸ªåˆ—è¡¨å¼•ç”¨äº†æ¯ä¸ªåˆ—è¡¨é¡¹ï¼Œç­‰ç­‰ã€‚ç„¶è€Œï¼Œè¿™äº›å…ƒç´ ä¸­çš„æ¯ä¸€ä¸ªä¹Ÿéƒ½æœ‰ä¸€ä¸ªå¼•ç”¨å…¶çˆ¶å…ƒç´ çš„å¼•ç”¨ã€‚è¿™æ ·ï¼Œç¨‹åºå¯ä»¥æ–¹ä¾¿åœ°å‘ä¸‹æˆ–å‘ä¸Šéå†ã€‚
- en: Programming with cyclic data introduces complications. If we traverse the data
    naÃ¯vely, we would go into an infinite loop. Rather, we have to keep track of the
    data we have previously visited, and make sure we donâ€™t visit them again (see
    [The Size of a DAG](size-of-dag.html)). Indeed, cyclic data are graphs [[Graphs](part_graphs.html)],
    so issues in processing graphs become relevant here.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨å¾ªç¯æ•°æ®ç¼–ç¨‹ä¼šå¼•å…¥å¤æ‚æ€§ã€‚å¦‚æœæˆ‘ä»¬å¤©çœŸåœ°éå†æ•°æ®ï¼Œæˆ‘ä»¬ä¼šè¿›å…¥æ— é™å¾ªç¯ã€‚ç›¸åï¼Œæˆ‘ä»¬å¿…é¡»è·Ÿè¸ªæˆ‘ä»¬ä¹‹å‰è®¿é—®è¿‡çš„æ•°æ®ï¼Œå¹¶ç¡®ä¿æˆ‘ä»¬ä¸å†è®¿é—®å®ƒä»¬ï¼ˆå‚è§[æœ‰å‘æ— ç¯å›¾çš„å¤§å°](size-of-dag.html)ï¼‰ã€‚äº‹å®ä¸Šï¼Œå¾ªç¯æ•°æ®æ˜¯å›¾
    [[å›¾](part_graphs.html)]ï¼Œå› æ­¤å¤„ç†å›¾çš„é—®é¢˜åœ¨è¿™é‡Œå˜å¾—ç›¸å…³ã€‚
- en: One interesting question that programming languages face is, how do you print
    cyclic data? For instance, what happens if the programmer writes
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ç¼–ç¨‹è¯­è¨€é¢ä¸´çš„ä¸€ä¸ªæœ‰è¶£é—®é¢˜æ˜¯ï¼Œå¦‚ä½•æ‰“å°å¾ªç¯æ•°æ®ï¼Ÿä¾‹å¦‚ï¼Œå¦‚æœç¨‹åºå‘˜ç¼–å†™
- en: '[PRE61]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '? To print the account we must print its owners; to print each owner, we must
    print their account; to print that accountâ€¦'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '? è¦æ‰“å°è´¦æˆ·ï¼Œæˆ‘ä»¬å¿…é¡»æ‰“å°å…¶æ‰€æœ‰è€…ï¼›è¦æ‰“å°æ¯ä¸ªæ‰€æœ‰è€…ï¼Œæˆ‘ä»¬å¿…é¡»æ‰“å°ä»–ä»¬çš„è´¦æˆ·ï¼›è¦æ‰“å°é‚£ä¸ªè´¦æˆ·â€¦'
- en: Do Now!
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try it out in both Python and Pyret!
  id: totrans-323
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨ Python å’Œ Pyret ä¸­éƒ½è¯•ä¸€è¯•å§ï¼
- en: Different programming languages handle this problem in different ways. Some
    languages will go into an infinite loop trying to print cyclic data. Both Python
    and Pyret handle this more intelligently. Determining even whether a datum is
    cyclic is an interesting question, which we take up in [Detecting Cycles](cycle-detection.html).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸åŒçš„ç¼–ç¨‹è¯­è¨€ä»¥ä¸åŒçš„æ–¹å¼å¤„ç†è¿™ä¸ªé—®é¢˜ã€‚æœ‰äº›è¯­è¨€ä¼šé™·å…¥æ— é™å¾ªç¯ï¼Œè¯•å›¾æ‰“å°å¾ªç¯æ•°æ®ã€‚Python å’Œ Pyret å¤„ç†è¿™ä¸ªé—®é¢˜æ›´ä¸ºæ™ºèƒ½ã€‚ç”šè‡³ç¡®å®šä¸€ä¸ªæ•°æ®æ˜¯å¦æ˜¯å¾ªç¯çš„ä¹Ÿæ˜¯ä¸€ä¸ªæœ‰è¶£çš„é—®é¢˜ï¼Œæˆ‘ä»¬å°†åœ¨[æ£€æµ‹å¾ªç¯](cycle-detection.html)ä¸­æ¢è®¨ã€‚
