["```cpp\nconst int R = 1e8; alignas(64) int tree[R]; \n```", "```cpp\nfor (int i = 0; i < R; i++)  tree[i] = INT_MAX; \n```", "```cpp\nconst int B = 32;   int root = 0;   // where the keys of the root start int n_tree = B; // number of allocated array cells int H = 1;      // current tree height \n```", "```cpp\ntypedef __m256i reg;   reg cmp(reg x, int *node) {  reg y = _mm256_load_si256((reg*) node); return _mm256_cmpgt_epi32(x, y); }   // returns how many keys are less than x unsigned rank32(reg x, int *node) {  reg m1 = cmp(x, node); reg m2 = cmp(x, node + 8); reg m3 = cmp(x, node + 16); reg m4 = cmp(x, node + 24);   // take lower 16 bits from m1/m3 and higher 16 bits from m2/m4 m1 = _mm256_blend_epi16(m1, m2, 0b01010101); m3 = _mm256_blend_epi16(m3, m4, 0b01010101); m1 = _mm256_packs_epi16(m1, m3); // can also use blendv here, but packs is simpler  unsigned mask = _mm256_movemask_epi8(m1); return __builtin_popcount(mask); } \n```", "```cpp\nint lower_bound(int _x) {  unsigned k = root; reg x = _mm256_set1_epi32(_x);  for (int h = 0; h < H - 1; h++) { unsigned i = rank32(x, &tree[k]); k = tree[k + B + i]; }   unsigned i = rank32(x, &tree[k]);   return tree[k + i]; } \n```", "```cpp\nstruct Precalc {  alignas(64) int mask[B][B];   constexpr Precalc() : mask{} { for (int i = 0; i < B; i++) for (int j = i; j < B - 1; j++) // everything from i to B - 2 inclusive needs to be moved mask[i][j] = -1; } };   constexpr Precalc P;   void insert(int *node, int i, int x) {  // need to iterate right-to-left to not overwrite the first element of the next lane for (int j = B - 8; j >= 0; j -= 8) { // load the keys reg t = _mm256_load_si256((reg*) &node[j]); // load the corresponding mask reg mask = _mm256_load_si256((reg*) &P.mask[i][j]); // mask-write them one position to the right _mm256_maskstore_epi32(&node[j + 1], mask, t); } node[i] = x; // finally, write the element itself } \n```", "```cpp\n// move the second half of a node and fill it with infinities void move(int *from, int *to) {  const reg infs = _mm256_set1_epi32(INT_MAX); for (int i = 0; i < B / 2; i += 8) { reg t = _mm256_load_si256((reg*) &from[B / 2 + i]); _mm256_store_si256((reg*) &to[i], t); _mm256_store_si256((reg*) &from[B / 2 + i], infs); } } \n```", "```cpp\nvoid insert(int _x) {  // the beginning of the procedure is the same as in lower_bound, // except that we save the path in case we need to update some of our ancestors unsigned sk[10], si[10]; // k and i on each iteration //           ^------^ We assume that the tree height does not exceed 10 //                    (which would require at least 16^10 elements) unsigned k = root; reg x = _mm256_set1_epi32(_x);   for (int h = 0; h < H - 1; h++) { unsigned i = rank32(x, &tree[k]);   // optionally update the key i right away tree[k + i] = (_x > tree[k + i] ? _x : tree[k + i]); sk[h] = k, si[h] = i; // and save the path k = tree[k + B + i]; }   unsigned i = rank32(x, &tree[k]);   // we can start computing the is-full check before insertion completes bool filled  = (tree[k + B - 2] != INT_MAX);   insert(tree + k, i, _x);   if (filled) { // the node needs to be split, so we create a new leaf node move(tree + k, tree + n_tree);  int v = tree[k + B / 2 - 1]; // new key to be inserted int p = n_tree;              // pointer to the newly created node n_tree += B;   for (int h = H - 2; h >= 0; h--) { // ascend and repeat until we reach the root or find a the node is not split k = sk[h], i = si[h];   filled = (tree[k + B - 3] != INT_MAX);   // the node already has a correct key (the right one) //                  and a correct pointer (the left one) insert(tree + k,     i,     v); insert(tree + k + B, i + 1, p);  if (!filled) return; // we're done  // create a new internal node move(tree + k,     tree + n_tree);     // move keys move(tree + k + B, tree + n_tree + B); // move pointers  v = tree[k + B / 2 - 1]; tree[k + B / 2 - 1] = INT_MAX;   p = n_tree; n_tree += 2 * B; }   // if reach here, this means we've reached the root, // and it was split into two, so we need a new root tree[n_tree] = v;   tree[n_tree + B] = root; tree[n_tree + B + 1] = p;   root = n_tree; n_tree += 2 * B; H++; } } \n```", "```cpp\nvoid (*insert_ptr)(int); int (*lower_bound_ptr)(int);   void insert(int x) {  insert_ptr(x); }   int lower_bound(int x) {  return lower_bound_ptr(x); } \n```", "```cpp\ntemplate <int H> void insert_impl(int _x) {  // ... }   template <int H> void insert_impl(int _x) {  // ... if (/* tree grows */) { // ... insert_ptr = &insert_impl<H + 1>; lower_bound_ptr = &lower_bound_impl<H + 1>; } }   template <> void insert_impl<10>(int x) {  std::cerr << \"This depth was not supposed to be reached\" << std::endl; exit(1); } \n```"]