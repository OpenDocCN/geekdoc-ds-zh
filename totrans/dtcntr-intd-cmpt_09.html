<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>4.1¬†Introduction to Tabular Dataüîó</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>4.1¬†Introduction to Tabular Dataüîó</h1>
<blockquote>ÂéüÊñáÔºö<a href="https://dcic-world.org/2025-08-27/intro-tabular-data.html">https://dcic-world.org/2025-08-27/intro-tabular-data.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>¬†¬†¬†¬†<a href="#%28part._.Creating_.Tabular_.Data%29" class="toclink" data-pltdoc="x">4.1.1¬†Creating Tabular Data</a></p></td></tr><tr><td><p>¬†¬†¬†¬†<a href="#%28part._.Extracting_.Rows_and_.Cell_.Values%29" class="toclink" data-pltdoc="x">4.1.2¬†Extracting Rows and Cell Values</a></p></td></tr><tr><td><p>¬†¬†¬†¬†<a href="#%28part._.Functions_over_.Rows%29" class="toclink" data-pltdoc="x">4.1.3¬†Functions over Rows</a></p></td></tr><tr><td><p>¬†¬†¬†¬†<a href="#%28part._.Processing_.Rows%29" class="toclink" data-pltdoc="x">4.1.4¬†Processing Rows</a></p></td></tr><tr><td><p>¬†¬†¬†¬†¬†¬†<a href="#%28part._subsec~3afinding-rows%29" class="toclink" data-pltdoc="x">4.1.4.1¬†Finding Rows</a></p></td></tr><tr><td><p>¬†¬†¬†¬†¬†¬†<a href="#%28part._.Ordering_.Rows%29" class="toclink" data-pltdoc="x">4.1.4.2¬†Ordering Rows</a></p></td></tr><tr><td><p>¬†¬†¬†¬†¬†¬†<a href="#%28part._.Adding_.New_.Columns%29" class="toclink" data-pltdoc="x">4.1.4.3¬†Adding New Columns</a></p></td></tr><tr><td><p>¬†¬†¬†¬†¬†¬†<a href="#%28part._.Calculating_.New_.Column_.Values%29" class="toclink" data-pltdoc="x">4.1.4.4¬†Calculating New Column Values</a></p></td></tr><tr><td><p>¬†¬†¬†¬†<a href="#%28part._.Examples_for_.Table-.Producing_.Functions%29" class="toclink" data-pltdoc="x">4.1.5¬†Examples for Table-Producing Functions</a></p></td></tr><tr><td><p>¬†¬†¬†¬†<a href="#%28part._sec~3alambda-tables%29" class="toclink" data-pltdoc="x">4.1.6¬†Lambda: Anonymous Functions</a></p></td></tr></table><p>Many interesting data in computing are tabular‚Äî<wbr/>i.e., like a
table‚Äî<wbr/>in form. First we‚Äôll see a few examples of them, before we try
to identify what they have in common. Here are some of them:
</p><ul><li><p>An email inbox is a list of messages. For each message, your
inbox stores a bunch of information: its sender, the subject line, the
conversation it‚Äôs part of, the body, and quite a bit more.</p><p><img src="../Images/17a64e6b5180eb56ebf06a02ffe39113.png" alt="" width="1136" height="46" data-original-src="https://dcic-world.org/2025-08-27/gmail-1.png"/></p></li><li><p>A music playlist. For each song, your music player maintains a
bunch of information: its name, the singer, its length, its genre, and
so on.</p><p><img src="../Images/c49e8b34342ce5900ea7036fda0dff30.png" alt="" width="740" height="91" data-original-src="https://dcic-world.org/2025-08-27/itunes-2.png"/></p></li><li><p>A filesystem folder or directory. For each file, your filesystem
records a name, a modification date, size, and other information.</p><p><img src="../Images/b73acd1cfa429053983b7085ec7786c9.png" alt="" width="733" height="119" data-original-src="https://dcic-world.org/2025-08-27/filesystem-1.png"/></p></li></ul><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Can you come up with more examples?</p></blockquote></blockquote><p>How about:
</p><ul><li><p>Responses to a party invitation.</p></li><li><p>A gradebook.</p></li><li><p>A calendar agenda.</p></li></ul><p>You can think of many more in your life!</p><p>What do all these have in common? The characteristics of tabular data are:
</p><ul><li><p>They contain information about zero or more items (i.e.,
individuals or artifacts) that share
characteristics. Each item is stored in a row. Each column tracks one of
the shared attributes across the rows. For example, each song or
email message or file is a row. Each of their characteristics‚Äî<wbr/>the
song title, the message subject, the filename‚Äî<wbr/>is a column.
While some spreadsheets might swap the roles of rows and
columns, we stick to this organization as it aligns with the design of
data-science software libraries. This is an example of what Hadley
Wickham calls
<a href="https://vita.had.co.nz/papers/tidy-data.pdf">tidy
data</a>.</p></li><li><p>Each row has the same columns as the other rows, in the same
order.</p></li><li><p>A given column has the same type, but different columns can have
different types. For instance, an email message has a sender‚Äôs name,
which is a string; a subject line, which is a string; a sent date,
which is a date; whether it‚Äôs been read, which is a Boolean; and so
on.</p></li><li><p>The rows might be in some particular order. For instance, the
emails are ordered by which was most recently sent.</p></li></ul><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Find the characteristics of tabular data in the other examples
described above, as well as in the ones you described.</p></blockquote></blockquote><p>We will now learn how to program with tables and to how to
decompose tasks that process them. To access the functions that we‚Äôll
use to do this, you need to set the context (at the top of the
definitions window) to dcic2024. Earlier editions of the
book had you use <code data-lang="pyret" class="sourceCode">shared-gdrive</code> to load a file to access these
functions. This is no longer necessary when using the dcic2024
context. In
CPO, click on the down arrow at the top left of the screen (left of
the Pyret logo), select ‚ÄùChoose Context‚Äú, then enter dcic2024
in the box, as shown in this screenshot:</p><p><img src="../Images/710c9c4fd77163faf8376fe746fdec28.png" alt="" width="615" height="329" data-original-src="https://dcic-world.org/2025-08-27/choose-context.png"/></p><p>After you click the Submit button, the definitions window will show
the name of the context as in the following image:</p><p><img src="../Images/6d810094e710d0cc7fbef1bae2a68941.png" alt="" width="340" height="90" data-original-src="https://dcic-world.org/2025-08-27/context-in-use.png"/></p><p><a href="https://hackmd.io/@cs111/table">Documentation on the
function-based table operators</a> is available on a separate
page outside of the Pyret documentation.</p><section class="SsectionLevel4" id="section 4.1.1"><h4 class="heading">4.1.1¬†<a name="(part._.Creating_.Tabular_.Data)"/>Creating Tabular Data<a href="#(part._.Creating_.Tabular_.Data)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>Pyret provides multiple easy ways of creating tabular data. The
simplest is to define the datum in a program as follows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">table: name, age
  row: "Alicia", 30
  row: "Meihui", 40
  row: "Jamal", 25
end</code></pre><p>That is, a <code data-lang="pyret" class="sourceCode">table</code> is followed by the names of the columns in
their desired order, followed by a sequence of <code data-lang="pyret" class="sourceCode">row</code>s. Each row
must contain as many data as the column declares, and in the same
order.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Change different parts of the above example‚Äî<wbr/>e.g., remove a necessary
value from a row, add an extraneous one, remove a comma, add an extra
comma, leave an extra comma at the end of a row‚Äî<wbr/>and see what errors
you get.</p></blockquote></blockquote><p>Note that in a table, the order of columns matters: two tables that
are otherwise identical but with different column orders are not
considered equal.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  table: name, age
    row: "Alicia", 30
    row: "Meihui", 40
    row: "Jamal", 25
  end
  is-not
  table: age, name
    row: 30, "Alicia"
    row: 40, "Meihui"
    row: 25, "Jamal"
  end
end</code></pre><p>Observe that the example above uses <code data-lang="pyret" class="sourceCode">is-not</code>, i.e., the test
passes, meaning that the tables are not equal.</p><p>The <code data-lang="pyret" class="sourceCode">check:</code> annotation here is a way of writing <code data-lang="pyret" class="sourceCode">is</code>
assertions about expressions outside of the context of a function (and
its <code data-lang="pyret" class="sourceCode">where</code> block). We‚Äôll learn more about <code data-lang="pyret" class="sourceCode">check</code> in
<a href="testing.html#%28part._from-examples-to-tests%29" data-pltdoc="x">From Examples to Tests</a>.</p><p>Table expressions create table values. These can be stored in variables just
like numbers, strings, and images:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">people = table: name, age
  row: "Alicia", 30
  row: "Meihui", 40
  row: "Jamal", 25
end</code></pre><p>We call these literal tables when we create them with <code data-lang="pyret" class="sourceCode">table</code>.
Pyret provides other ways to get tabular data, too! In
particular, you can <a href="https://www.pyret.org/docs/latest/gdrive-sheets.html">import tabular data from a spreadsheet</a>, so
any mechanism that lets you create such a sheet can also be used. You
might:
</p><ul><li><p>create the sheet on your own,</p></li><li><p>create a sheet collaboratively with friends,</p></li><li><p>find data on the Web that you can import into a sheet,</p></li><li><p>create a Google Form that you get others to fill out, and obtain
a sheet out of their responses</p></li></ul><p>and so on. Let your imagination run wild! Once the data are in Pyret,
it doesn‚Äôt matter where they came from.</p><p>With tables, we begin to explore data that contain other
(smaller) pieces of data. We‚Äôll refer to such data as structured data.
Structured data organize their inner data in a structured
way (here, rows and columns). As with images, when we wrote code that
reflected the structure of the final image, we will see that code that
works with tables also follows the structure of the data.</p></section><section class="SsectionLevel4" id="section 4.1.2"><h4 class="heading">4.1.2¬†<a name="(part._.Extracting_.Rows_and_.Cell_.Values)"/>Extracting Rows and Cell Values<a href="#(part._.Extracting_.Rows_and_.Cell_.Values)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>Given a table, we sometimes want to look up the value of a particular
cell. We‚Äôll work with the following table showing the number of riders
on a shuttle service over several months:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle = table: month, riders
  row: "Jan", 1123
  row: "Feb", 1045
  row: "Mar", 1087
  row: "Apr", 999
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>If you put this table in the definitions pane and press Run, what
will be in the Pyret directory once the interactions prompt appears?
Would the column names be listed in the directory?</p></blockquote></blockquote><p>As a reminder, the directory contains only those names that we assign
values to using the form <code data-lang="pyret" class="sourceCode">name = </code>. The directory here would
contain <code data-lang="pyret" class="sourceCode">shuttle</code>, which would be bound to the table (yes, the
entire table would be in the directory!). The column names would not
have their own entries in the directory. At the low level, this is because we
never wrote anything of the form <code data-lang="pyret" class="sourceCode">colname = ...</code>.  At the high
level, we don‚Äôt usually build tables by creating individual columns
and putting them together side by side. (If anything, it is more common
to create individual rows, since rows correspond to individual
observations, events, or entities; we didn‚Äôt do that in this
example, however).</p><p>Starting from the name associated with a table, we can lookup the
value in a given cell (row and column) in the table. Concretely,
assume we want to extract the number of riders in March (<code data-lang="pyret" class="sourceCode">1087</code>)
so we can use it in another computation. How do we do that?</p><p>Pyret (and most other programming languages designed for data
analysis) organizes tables as collections of rows with shared
columns. Given that organization, we get to a specific cell by first
isolating the row we are interested in, then retrieving the contents
of the cell.</p><p>Pyret numbers the rows of a table from top to bottom starting at 0
(most programming languages use 0 as the first position in a piece of
data, for reasons we will see later). So if we want to see the data
for March, we need to isolate row 2. We write:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle.row-n(2)</code></pre><p>We use the period notation to dig into a piece of structured data. Here,
we are saying "dig into the <code data-lang="pyret" class="sourceCode">shuttle</code> table, extracting row
number <code data-lang="pyret" class="sourceCode">2</code>" (which is really the third row since Pyret counts
positions from 0).</p><p>If we run this expression at the prompt, we get</p><p><img src="../Images/d60ae702af1ad3975e72ce720628831a.png" alt="" width="347" height="70" data-original-src="https://dcic-world.org/2025-08-27/shuttle-row.png"/></p><p>This is a new type of data called a <code data-lang="pyret" class="sourceCode">Row</code>. When Pyret displays a
<code data-lang="pyret" class="sourceCode">Row</code> value, it shows you the column names and the corresponding
values within the row.</p><p>To extract the value of a specific column within a row, we write the
row followed by the name of the column (as a string) in square
brackets. Here are two equivalent ways of getting the value of the
<code data-lang="pyret" class="sourceCode">riders</code> column from the row for March:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle.row-n(2)["riders"]</code></pre><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">march-row = shuttle.row-n(2)
march-row["riders"]</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What names would be in the Pyret directory when using each of these
approaches?</p></blockquote></blockquote><p>Once we have the cell value (here a <code data-lang="pyret" class="sourceCode">Number</code>), we can use it in
any other computation, such as</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle.row-n(2)["riders"] &gt;= 1000</code></pre><p>(which checks whether there were at least <code data-lang="pyret" class="sourceCode">1000</code> riders in March).</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do you expect would happen if you forgot the quotation marks and
instead wrote:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle.row-n(2)[riders]</code></pre><p>What would Pyret do and why?</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 4.1.3"><h4 class="heading">4.1.3¬†<a name="(part._.Functions_over_.Rows)"/>Functions over Rows<a href="#(part._.Functions_over_.Rows)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>Now that we have the ability to isolate Rows from tables, we can write
functions that ask questions about individual rows. We just saw an
example of doing a computation over row data, when we checked whether
the row for March had more than 1000 riders. What if we wanted to do
this comparison for an arbitrary row of this table? Let‚Äôs write a
function! We‚Äôll call it <code data-lang="pyret" class="sourceCode">cleared-1K</code>.</p><p>Let‚Äôs start with a function header and some examples:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun cleared-1K(r :: Row) -&gt; Boolean:
  doc: "determine whether given row has at least 1000 riders"
  ...
where:
  cleared-1K(shuttle.row-n(2)) is true
  cleared-1K(shuttle.row-n(3)) is false
end</code></pre><p>This shows you what examples for <code data-lang="pyret" class="sourceCode">Row</code> functions look like, as
well as how we use <code data-lang="pyret" class="sourceCode">Row</code> as an input type.</p><p>To fill in the body of the function, we extract the content of the
<code data-lang="pyret" class="sourceCode">"riders"</code> cell and compare it to <code data-lang="pyret" class="sourceCode">1000</code>:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun cleared-1K(r :: Row) -&gt; Boolean:
  doc: "determine whether given row has at least 1000 riders"
  r["riders"] &gt;= 1000
where:
  cleared-1K(shuttle.row-n(2)) is true
  cleared-1K(shuttle.row-n(3)) is false
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Looking at the examples, both of them share the <code data-lang="pyret" class="sourceCode">shuttle.row-n</code>
portion. Would it have been better to instead make <code data-lang="pyret" class="sourceCode">cleared-1K</code> a
function that takes just the row position as input, such as:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun cleared-1K(row-pos :: Number) -&gt; Boolean:
  ...
where:
  cleared-1K(2) is true
  cleared-1K(3) is false
end</code></pre><p>What are the benefits and limitations to doing this?</p></blockquote></blockquote><p>In general, the version that takes the <code data-lang="pyret" class="sourceCode">Row</code> input is more
flexible because it can work with a row from any table that has
a column named <code data-lang="pyret" class="sourceCode">"riders"</code>. We might have another table with more
columns of information or different data tables for different
years. If we modify <code data-lang="pyret" class="sourceCode">cleared-1K</code> to only take the row position as
input, that function will have to fix which table it works with. In
contrast, our original version leaves the specific table
(<code data-lang="pyret" class="sourceCode">shuttle</code>) outside the function, which leads to flexibility.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a function <code data-lang="pyret" class="sourceCode">is-winter</code> that takes a <code data-lang="pyret" class="sourceCode">Row</code> with a
<code data-lang="pyret" class="sourceCode">"month"</code> column as input and produces a <code data-lang="pyret" class="sourceCode">Boolean</code>
indicating whether the month in that row is one of <code data-lang="pyret" class="sourceCode">"Jan"</code>,
<code data-lang="pyret" class="sourceCode">"Feb"</code>, or <code data-lang="pyret" class="sourceCode">"Mar"</code>.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a function <code data-lang="pyret" class="sourceCode">low-winter</code> that takes in <code data-lang="pyret" class="sourceCode">Row</code> with both
<code data-lang="pyret" class="sourceCode">"month"</code> and <code data-lang="pyret" class="sourceCode">"riders"</code> columns and produces a
<code data-lang="pyret" class="sourceCode">Boolean</code> indicating whether the row is a winter row with fewer
than 1050 riders.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Practice with the program directory! Take a <code data-lang="pyret" class="sourceCode">Row</code> function and
one of its <code data-lang="pyret" class="sourceCode">where</code> examples, and show how the program directory
evolves as you evaluate the example.</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 4.1.4"><h4 class="heading">4.1.4¬†<a name="(part._.Processing_.Rows)"/>Processing Rows<a href="#(part._.Processing_.Rows)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>So far, we have looked at extracting individual rows by their position
in the table and computing over them. Extracting rows by position
isn‚Äôt always convenient: we might have hundreds or thousands of rows,
and we might not know where the data we want even is in the table. We
would much rather be able to write a small program that identifies the
row (or rows!) that meets a specific criterion.</p><p>Pyret offers three different notations for processing
tables: one uses functions, one uses methods, and one uses a SQL-like
notation. This chapter uses the function-based notation. The SQL-like
notation and the methods-based notation are shown in the Pyret
Documentation. To use the function-based notation, you‚Äôll need to
include the file specified in the main narrative.</p><p>The rest of this section assumes that you have loaded the functions
notations for working with tables.</p><section class="SsectionLevel5" id="section 4.1.4.1"><h5 class="heading">4.1.4.1¬†<a name="(part._subsec~3afinding-rows)"/>Finding Rows<a href="#(part._subsec~3afinding-rows)" class="heading-anchor" title="Link to here">üîó</a> </h5><p>Imagine that we wanted to write a program to locate a row that has
fewer than <code data-lang="pyret" class="sourceCode">1000</code> riders from our <code data-lang="pyret" class="sourceCode">shuttle</code> table. With what
we‚Äôve studied so far, how might we try to write this? We could imagine
using a conditional, like follows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if shuttle.row-n(0)["riders"] &lt; 1000:
  shuttle.row-n(0)
else if shuttle.row-n(1)["riders"] &lt; 1000:
  shuttle.row-n(1)
else if shuttle.row-n(2)["riders"] &lt; 1000:
  shuttle.row-n(2)
else if shuttle.row-n(3)["riders"] &lt; 1000:
  shuttle.row-n(3)
else: ... # not clear what to do here
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What benefits and limitations do you see to this approach?</p></blockquote></blockquote><p>There are a couple of reasons why we might not care for this
solution. First, if we have thousands of rows, this will be terribly
painful to write. Second, there‚Äôs a lot of repetition here (only the
row positions are changing). Third, it isn‚Äôt clear what to do if there
aren‚Äôt any matching rows. In addition, what happens if there are
multiple rows that meet our criterion? In some cases, we might want to
be able to identify all of the rows that meet a condition and
use them for a subsequent computation (like seeing whether some months
have more low-ridership days than others).</p><p>This conditional is, however, the spirit of what we want to do:
go through the rows of the table one at a time, identifying those that
match some criterion. We just don‚Äôt want to be responsible for
manually checking each row. Fortunately for us, Pyret knows how to do
that. Pyret knows which rows are in a given table. Pyret can pull
out those rows one position at a time and check a criterion about
each one.</p><p>We just need to tell Pyret what criterion we want to use.</p><p>As before, we can express our criterion as a function that takes a
<code data-lang="pyret" class="sourceCode">Row</code> and produces a <code data-lang="pyret" class="sourceCode">Boolean</code> (a Boolean because our
criterion was used as the question part of an <code data-lang="pyret" class="sourceCode">if</code> expression in
our code sketch). In this case, we want:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun below-1K(r :: Row) -&gt; Boolean:
  doc: "determine whether row has fewer than 1000 riders"
  r["riders"] &lt; 1000
where:
  below-1K(shuttle.row-n(2)) is false
  below-1K(shuttle.row-n(3)) is true
end</code></pre><p>Now, we just need a way to tell Pyret to use this criterion as it
searches through the rows. We do this with a function called
<code data-lang="pyret" class="sourceCode">filter-with</code> which takes two inputs: the table to process and the
criterion to check on each row of the table.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with(shuttle, below-1K)</code></pre><p>Under the hood, <code data-lang="pyret" class="sourceCode">filter-with</code> works roughly like the <code data-lang="pyret" class="sourceCode">if</code>
statement we outlined above: it takes each row one at a time and calls
the given criterion function on it. But what does it do with the
results?</p><p>If you run the above expression, you‚Äôll see that <code data-lang="pyret" class="sourceCode">filter-with</code>
produces a table containing the matching row, not the row by
itself. This behavior is handy if multiple rows match the
criterion. For example, try:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with(shuttle, is-winter)</code></pre><p>(using the <code data-lang="pyret" class="sourceCode">is-winter</code> function from an exercise earlier in this
chapter). Now we get a table with the three rows corresponding to winter
months. If we want to be able to name this table for use in future
computations, we can do so with our usual notation for naming values:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">winter = filter-with(shuttle, is-winter)</code></pre></section><section class="SsectionLevel5" id="section 4.1.4.2"><h5 class="heading">4.1.4.2¬†<a name="(part._.Ordering_.Rows)"/>Ordering Rows<a href="#(part._.Ordering_.Rows)" class="heading-anchor" title="Link to here">üîó</a> </h5><p>Let‚Äôs ask a new question: which winter month had the fewest number
of riders?. This question requires us to identify a specific row,
namely, the winter row with the smallest value in the <code data-lang="pyret" class="sourceCode">"riders"</code>
column.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Can we do this with <code data-lang="pyret" class="sourceCode">filter-with</code>? Why or why not?</p></blockquote></blockquote><p>Think back to the <code data-lang="pyret" class="sourceCode">if</code> expression that motivated
<code data-lang="pyret" class="sourceCode">filter-with</code>: each row is evaluated independently of the
others. Our current question, however, requires comparing across
rows. That‚Äôs a different operation, so we will need more than
<code data-lang="pyret" class="sourceCode">filter-with</code>.</p><p>Tools for analyzing data (whether programming languages or
spreadsheets) provide ways for users to sort rows of a table
based on the values in a single column. That would help us here: we
could sort the winter rows from smallest to largest value in the
<code data-lang="pyret" class="sourceCode">"riders"</code> column, then extract the <code data-lang="pyret" class="sourceCode">"riders"</code> value from
the first row. First, let‚Äôs sort the rows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">order-by(winter, "riders", true)</code></pre><p>The <code data-lang="pyret" class="sourceCode">order-by</code> function takes three inputs: the table to sort
(<code data-lang="pyret" class="sourceCode">winter</code>), the column to sort on (<code data-lang="pyret" class="sourceCode">"riders"</code>), and a
<code data-lang="pyret" class="sourceCode">Boolean</code> to indicate whether we want to sort in increasing
order. (Had the third argument been <code data-lang="pyret" class="sourceCode">false</code>, the rows would be
sorted in decreasing order of the values in the named column.)</p><p><img src="../Images/50fd4ee1a960ed4942030557bea37389.png" alt="" width="178" height="151" data-original-src="https://dcic-world.org/2025-08-27/sorted-winter.png"/></p><p>In the sorted table, the row with the fewest riders is in the first
position. Our original question asked us to lookup the month with the
fewest riders. We did this earlier.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write the code to extract the name of the winter month with the fewest
riders.</p></blockquote></blockquote><p>Here are two ways to write that computation:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">order-by(winter, "riders", true).row-n(0)["month"]</code></pre><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sorted = order-by(winter, "riders", true)
least-row = sorted.row-n(0)
least-row["month"]</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Which of these two ways do you prefer? Why?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How does each of these programs affect the program
directory?</p></blockquote></blockquote><p>Note that this problem asked us to combine several actions that we‚Äôve
already seen on rows: we identify rows from within a table
(<code data-lang="pyret" class="sourceCode">filter-with</code>), order the rows (<code data-lang="pyret" class="sourceCode">order-by</code>), extract a
specific row (<code data-lang="pyret" class="sourceCode">row-n</code>), then extract a cell (with square brackets
and a column name). This is typical of how we will operate on tables,
combining multiple operations to compute a result (much as we did with
programs that manipulate images).</p></section><section class="SsectionLevel5" id="section 4.1.4.3"><h5 class="heading">4.1.4.3¬†<a name="(part._.Adding_.New_.Columns)"/>Adding New Columns<a href="#(part._.Adding_.New_.Columns)" class="heading-anchor" title="Link to here">üîó</a> </h5><p>Sometimes, we want to create a new column whose value is based on
those of existing columns. For instance, our table might reflect
employee records, and have columns named <code data-lang="pyret" class="sourceCode">hourly-wage</code> and
<code data-lang="pyret" class="sourceCode">hours-worked</code>, representing the corresponding quantities. We
would now like to extend this table with a new column to reflect each
employee‚Äôs total wage. Assume we started with the following table:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees =
  table: name,   hourly-wage, hours-worked
    row: "Harley",  15,          40
    row: "Obi",     20,          45
    row: "Anjali",  18,          39
    row: "Miyako",  18,          40
  end</code></pre><p>The table we want to end up with is:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees =
  table: name, hourly-wage, hours-worked, total-wage
    row: "Harley", 15,         40,         15 * 40
    row: "Obi",    20, 	       45,         20 * 45
    row: "Anjali", 18, 	       39,         18 * 39
    row: "Miyako", 18, 	       40,         18 * 40
  end</code></pre><p>(with the expressions in the <code data-lang="pyret" class="sourceCode">total-wage</code> column computed to
their numeric equivalents: we used the expressions here to illustrate
what we are trying to do).</p><p>Previously, when we have had a computation that we performed multiple
times, we created a helper function to do the computation.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Propose a helper function for computing total wages given the hourly
wage and number of hours worked.</p></blockquote></blockquote><p>Perhaps you came up with something like:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun compute-wages(wage :: Number, hours :: Number) -&gt; Number:
  wage * hours
end</code></pre><p>which we could use as follows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees =
  table: name, hourly-wage, hours-worked, total-wage
    row: "Harley", 15, 40, compute-wages(15, 40)
    row: "Obi",    20, 45, compute-wages(20, 45)
    row: "Anjali", 18, 39, compute-wages(18, 39)
    row: "Miyako", 18, 40, compute-wages(18, 40)
  end</code></pre><p>This is the right idea, but we can actually have this function do a
bit more work for us. The <code data-lang="pyret" class="sourceCode">wage</code> and <code data-lang="pyret" class="sourceCode">hours</code> values are in
cells within the same row. So if we could instead get the current row
as an input, we could write:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun compute-wages(r :: Row) -&gt; Number:
  r["hourly-wage"] * r["hours-worked"]
end

employees =
  table: name, hourly-wage, hours-worked, total-wage
    row: "Harley", 15, 40, compute-wages(&lt;row0&gt;)
    row: "Obi",    20, 45, compute-wages(&lt;row1&gt;)
    row: "Anjali", 18, 39, compute-wages(&lt;row2&gt;)
    row: "Miyako", 18, 40, compute-wages(&lt;row3&gt;)
  end</code></pre><p>But now, we are writing calls to <code data-lang="pyret" class="sourceCode">compute-wages</code> over and over!
Adding computed columns is a sufficiently common operation that Pyret
provides a table function called <code data-lang="pyret" class="sourceCode">build-column</code> for this
purpose. We use it by providing the function to use to populate values
in the new column as an input:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun compute-wages(r :: Row) -&gt; Number:
  doc: "compute total wages based on wage and hours worked"
  r["hourly-wage"] * r["hours-worked"]
end

build-column(employees, "total-wage", compute-wages)</code></pre><p>This creates a new column, <code data-lang="pyret" class="sourceCode">total-wage</code>, whose value in each row
is the product of the two named columns in that row. Pyret will put
the new column at the right end.</p></section><section class="SsectionLevel5" id="section 4.1.4.4"><h5 class="heading">4.1.4.4¬†<a name="(part._.Calculating_.New_.Column_.Values)"/>Calculating New Column Values<a href="#(part._.Calculating_.New_.Column_.Values)" class="heading-anchor" title="Link to here">üîó</a> </h5><p>Sometimes, we just want to calculate new values for an existing
column, rather than create an entirely new column. Giving raises to
employees is one such example. Assume we wanted to give a <code data-lang="pyret" class="sourceCode">10%</code> raise to
all employees making less than <code data-lang="pyret" class="sourceCode">20</code> an hour. We could write:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun new-rate(rate :: Number) -&gt; Number:
  doc: "Raise rates under 20 by 10%"
  if rate &lt; 20:
    rate * 1.1
  else:
    rate
  end
where:
  new-rate(20) is 20
  new-rate(10) is 11
  new-rate(0) is 0
end

fun give-raises(t :: Table) -&gt; Table:
  doc: "Give a 10% raise to anyone making under 20"
  transform-column(t, "hourly-wage", new-rate)
end</code></pre><p>Here, <code data-lang="pyret" class="sourceCode">transform-column</code> takes a table, the name of an existing
column in the table, and a function to update the value. The updating
function takes the current value in the column as input and produces
the new value for the column as output.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Run <code data-lang="pyret" class="sourceCode">give-raises</code> on the <code data-lang="pyret" class="sourceCode">employees</code> table. What wage will
show for <code data-lang="pyret" class="sourceCode">"Miyako"</code> in the <code data-lang="pyret" class="sourceCode">employees</code> table after
<code data-lang="pyret" class="sourceCode">give-raises</code> completes. Why?</p></blockquote></blockquote><p>Like all other Pyret <code data-lang="pyret" class="sourceCode">Table</code> operations, <code data-lang="pyret" class="sourceCode">transform-column</code>
produces a new table, leaving the original intact. Editing the
original table could be problematic‚Äìwhat if you made a mistake? How
would you recover the original table in that case? In general,
producing new tables with any modifications, then creating a new name
for the updated table once you have the one you want, is a less
error-prone way of working with datasets.</p></section></section><section class="SsectionLevel4" id="section 4.1.5"><h4 class="heading">4.1.5¬†<a name="(part._.Examples_for_.Table-.Producing_.Functions)"/>Examples for Table-Producing Functions<a href="#(part._.Examples_for_.Table-.Producing_.Functions)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>How do we write examples for functions that produce tables? Conceptually,
the answer is simply "make sure you got the output table that you
expected". Logistically, writing examples for table functions seems
more painful because writing out an expected output tables is more
work than simply writing the output of a function that produces
numbers or strings. What can we do to manage that complexity?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How might you write the <code data-lang="pyret" class="sourceCode">where</code> block for <code data-lang="pyret" class="sourceCode">give-raises</code>?</p></blockquote></blockquote><p>Here are some ideas for writing the examples practically:</p><ul><li><p>Simplify the input table. Rather than work with a large
table with all of the columns you have, create a small table that has
sufficient variety only in the columns that the function uses. For our
example, we might use:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">wages-test =
  table: hourly-wage
    row: 15
    row: 20
    row: 18
    row: 18
  end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Would any table with a column of numbers work here? Or are there some
constraints on the rows or columns of the table?</p></blockquote></blockquote><p>The only constraint is that your input table has to have the column
names used in your function.</p></li><li><p>Remember that you can write computations in the code to
construct tables. This saves you from doing calculations by hand.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where:
  give-raises(wages-test) is
  table: hourly-wage
    row: 15 * 1.1
    row: 20
    row: 18 * 1.1
    row: 18 * 1.1
  end</code></pre><p>This example shows that you can write an output table directly in the
<code data-lang="pyret" class="sourceCode">where:</code> block ‚Äì the table doesn‚Äôt need to be named outside the
function. </p></li><li><p>Create a new table by taking rows from an existing table.
If you were instead writing examples for a function that involves filtering out rows
of a table, it helps to know how to create a new table using rows of
an existing one. For example, if we were writing a function to find
all rows in which employees were working exactly 40 hours, we‚Äôd like
to make sure that the resulting table had the first and fourth rows of
the <code data-lang="pyret" class="sourceCode">employees</code> table. Rather than write a new <code data-lang="pyret" class="sourceCode">table</code>
expression to create that table, we could write it as follows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">emps-at-40 =
  add-row(
    add-row(employees.empty(),
      employees.row-n(0)),
    employees.row-n(3))</code></pre><p>Here, <code data-lang="pyret" class="sourceCode">employees.empty()</code> creates a new, empty table with the
same column headers as <code data-lang="pyret" class="sourceCode">employees</code>. We‚Äôve already seen how
<code data-lang="pyret" class="sourceCode">row-n</code> extracts a row from a table. The <code data-lang="pyret" class="sourceCode">add-row</code> function
places the given row at the end of the given table.</p></li></ul><p>Another tip to keep in mind: when the only thing your function does is call
a built-in function like <code data-lang="pyret" class="sourceCode">transform-column</code> it usually suffices
to write examples for the function you wrote to compute the new column
value. It is only when your code is combining table operations, or
doing more complex processing than a single call to a built-in table
operation that you really need to present your own examples to a
reader of your code.</p></section><section class="SsectionLevel4" id="section 4.1.6"><h4 class="heading">4.1.6¬†<a name="(part._sec~3alambda-tables)"/>Lambda: Anonymous Functions<a href="#(part._sec~3alambda-tables)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>Let‚Äôs revisit the program we wrote in <a href="#%28part._subsec~3afinding-rows%29" data-pltdoc="x">Finding Rows</a> for
finding all of the months in a table with fewer than 1000 riders:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle = table: month, riders
  row: "Jan", 1123
  row: "Feb", 1045
  row: "Mar", 1087
  row: "Apr", 999
end
fun below-1K(r :: Row) -&gt; Boolean:
  doc: "determine whether row has fewer than 1000 riders"
  r["riders"] &lt; 1000
where:
  below-1K(shuttle.row-n(2)) is false
  below-1K(shuttle.row-n(3)) is true
end
filter-with(shuttle, below-1K)</code></pre><p>This program might feel a bit verbose: do we really need to write a
helper function just to perform something as simple as a
<code data-lang="pyret" class="sourceCode">filter-with</code>? Wouldn‚Äôt it be easier to just write something like:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with(shuttle, r["riders"] &lt; 1000)</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What will Pyret produce if you run this expression?</p></blockquote></blockquote><p>Pyret will produce an <code data-lang="pyret" class="sourceCode">unbound identifier</code> error around the use
of <code data-lang="pyret" class="sourceCode">r</code> in this expression. What is <code data-lang="pyret" class="sourceCode">r</code>? We mean for <code data-lang="pyret" class="sourceCode">r</code>
to be the elements from <code data-lang="pyret" class="sourceCode">shuttle</code> in turn. Conceptually, that‚Äôs
what <code data-lang="pyret" class="sourceCode">filter-with</code> does, but we don‚Äôt have the mechanics right. When
we call a function, we evaluate the arguments before the body
of the function. Hence, the error regarding <code data-lang="pyret" class="sourceCode">r</code> being unbound.
The whole point of the <code data-lang="pyret" class="sourceCode">below-1K</code> helper function is to make
<code data-lang="pyret" class="sourceCode">r</code> a parameter to a function whose body is only evaluated once
a value for <code data-lang="pyret" class="sourceCode">r</code> is available.</p><p>To tighten the notation as in the one-line <code data-lang="pyret" class="sourceCode">filter-with</code> expression,
then, we have to find a way to tell Pyret to make a temporary function
that will get its inputs once <code data-lang="pyret" class="sourceCode">filter-with</code> is running. The following
notation achieves this:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with(shuttle, lam(r): r["riders"] &lt; 1000 end)</code></pre><p>We have added <code data-lang="pyret" class="sourceCode">lam(r)</code> and <code data-lang="pyret" class="sourceCode">end</code> around the expression that
we want to use in the <code data-lang="pyret" class="sourceCode">filter-with</code>. The <code data-lang="pyret" class="sourceCode">lam(r)</code> says "make a
temporary function that takes <code data-lang="pyret" class="sourceCode">r</code> as an input". The <code data-lang="pyret" class="sourceCode">end</code>
serves to end the function definition, as when we use
<code data-lang="pyret" class="sourceCode">fun</code>. <code data-lang="pyret" class="sourceCode">lam</code> is short for <code data-lang="pyret" class="sourceCode">lambda</code>, a form of function
definition that exists in many, though not all, languages.</p><p>The main difference between our original expression (using the
<code data-lang="pyret" class="sourceCode">below-1K</code> helper) and this new one (using <code data-lang="pyret" class="sourceCode">lam</code>) can be
seen through the program directory. To explain this, a little detail
about how <code data-lang="pyret" class="sourceCode">filter-with</code> is defined under the hood. In part, it looks
like:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun filter-with(tbl :: Table, keep :: (Row -&gt; Boolean)) -&gt; Table:
  if keep(&lt;row-from-table&gt;):
    ...
  else:
    ...
  end
end</code></pre><p>Whether we pass <code data-lang="pyret" class="sourceCode">below-1K</code> or the <code data-lang="pyret" class="sourceCode">lam</code> version to
<code data-lang="pyret" class="sourceCode">filter-with</code>, the <code data-lang="pyret" class="sourceCode">keep</code> parameter ends up referring to a
function with the same parameter and body. Since the function is only
actually called through the <code data-lang="pyret" class="sourceCode">keep</code> name, it doesn‚Äôt matter
whether or not a name is associated with it when it is initially
defined.</p><p>In practice, we use <code data-lang="pyret" class="sourceCode">lam</code> when we have to pass simple (single line)
functions to operations like <code data-lang="pyret" class="sourceCode">filter-with</code> (or <code data-lang="pyret" class="sourceCode">transform-column</code>,
<code data-lang="pyret" class="sourceCode">build-column</code>, etc). Of course, you can continue to write out names for
helper functions as we did with <code data-lang="pyret" class="sourceCode">below-1K</code> if that makes more sense to
you.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write the program to add 10 riders to each row in the <code data-lang="pyret" class="sourceCode">shuttle</code>
table above, using <code data-lang="pyret" class="sourceCode">lam</code> rather than a named helper-function.</p></blockquote></blockquote></section>&#13;
<h4 class="heading">4.1.1¬†<a name="(part._.Creating_.Tabular_.Data)"/>Creating Tabular Data<a href="#(part._.Creating_.Tabular_.Data)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>Pyret provides multiple easy ways of creating tabular data. The
simplest is to define the datum in a program as follows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">table: name, age
  row: "Alicia", 30
  row: "Meihui", 40
  row: "Jamal", 25
end</code></pre><p>That is, a <code data-lang="pyret" class="sourceCode">table</code> is followed by the names of the columns in
their desired order, followed by a sequence of <code data-lang="pyret" class="sourceCode">row</code>s. Each row
must contain as many data as the column declares, and in the same
order.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Change different parts of the above example‚Äî<wbr/>e.g., remove a necessary
value from a row, add an extraneous one, remove a comma, add an extra
comma, leave an extra comma at the end of a row‚Äî<wbr/>and see what errors
you get.</p></blockquote></blockquote><p>Note that in a table, the order of columns matters: two tables that
are otherwise identical but with different column orders are not
considered equal.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  table: name, age
    row: "Alicia", 30
    row: "Meihui", 40
    row: "Jamal", 25
  end
  is-not
  table: age, name
    row: 30, "Alicia"
    row: 40, "Meihui"
    row: 25, "Jamal"
  end
end</code></pre><p>Observe that the example above uses <code data-lang="pyret" class="sourceCode">is-not</code>, i.e., the test
passes, meaning that the tables are not equal.</p><p>The <code data-lang="pyret" class="sourceCode">check:</code> annotation here is a way of writing <code data-lang="pyret" class="sourceCode">is</code>
assertions about expressions outside of the context of a function (and
its <code data-lang="pyret" class="sourceCode">where</code> block). We‚Äôll learn more about <code data-lang="pyret" class="sourceCode">check</code> in
<a href="testing.html#%28part._from-examples-to-tests%29" data-pltdoc="x">From Examples to Tests</a>.</p><p>Table expressions create table values. These can be stored in variables just
like numbers, strings, and images:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">people = table: name, age
  row: "Alicia", 30
  row: "Meihui", 40
  row: "Jamal", 25
end</code></pre><p>We call these literal tables when we create them with <code data-lang="pyret" class="sourceCode">table</code>.
Pyret provides other ways to get tabular data, too! In
particular, you can <a href="https://www.pyret.org/docs/latest/gdrive-sheets.html">import tabular data from a spreadsheet</a>, so
any mechanism that lets you create such a sheet can also be used. You
might:
</p><ul><li><p>create the sheet on your own,</p></li><li><p>create a sheet collaboratively with friends,</p></li><li><p>find data on the Web that you can import into a sheet,</p></li><li><p>create a Google Form that you get others to fill out, and obtain
a sheet out of their responses</p></li></ul><p>and so on. Let your imagination run wild! Once the data are in Pyret,
it doesn‚Äôt matter where they came from.</p><p>With tables, we begin to explore data that contain other
(smaller) pieces of data. We‚Äôll refer to such data as structured data.
Structured data organize their inner data in a structured
way (here, rows and columns). As with images, when we wrote code that
reflected the structure of the final image, we will see that code that
works with tables also follows the structure of the data.</p>&#13;
<h4 class="heading">4.1.2¬†<a name="(part._.Extracting_.Rows_and_.Cell_.Values)"/>Extracting Rows and Cell Values<a href="#(part._.Extracting_.Rows_and_.Cell_.Values)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>Given a table, we sometimes want to look up the value of a particular
cell. We‚Äôll work with the following table showing the number of riders
on a shuttle service over several months:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle = table: month, riders
  row: "Jan", 1123
  row: "Feb", 1045
  row: "Mar", 1087
  row: "Apr", 999
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>If you put this table in the definitions pane and press Run, what
will be in the Pyret directory once the interactions prompt appears?
Would the column names be listed in the directory?</p></blockquote></blockquote><p>As a reminder, the directory contains only those names that we assign
values to using the form <code data-lang="pyret" class="sourceCode">name = </code>. The directory here would
contain <code data-lang="pyret" class="sourceCode">shuttle</code>, which would be bound to the table (yes, the
entire table would be in the directory!). The column names would not
have their own entries in the directory. At the low level, this is because we
never wrote anything of the form <code data-lang="pyret" class="sourceCode">colname = ...</code>.  At the high
level, we don‚Äôt usually build tables by creating individual columns
and putting them together side by side. (If anything, it is more common
to create individual rows, since rows correspond to individual
observations, events, or entities; we didn‚Äôt do that in this
example, however).</p><p>Starting from the name associated with a table, we can lookup the
value in a given cell (row and column) in the table. Concretely,
assume we want to extract the number of riders in March (<code data-lang="pyret" class="sourceCode">1087</code>)
so we can use it in another computation. How do we do that?</p><p>Pyret (and most other programming languages designed for data
analysis) organizes tables as collections of rows with shared
columns. Given that organization, we get to a specific cell by first
isolating the row we are interested in, then retrieving the contents
of the cell.</p><p>Pyret numbers the rows of a table from top to bottom starting at 0
(most programming languages use 0 as the first position in a piece of
data, for reasons we will see later). So if we want to see the data
for March, we need to isolate row 2. We write:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle.row-n(2)</code></pre><p>We use the period notation to dig into a piece of structured data. Here,
we are saying "dig into the <code data-lang="pyret" class="sourceCode">shuttle</code> table, extracting row
number <code data-lang="pyret" class="sourceCode">2</code>" (which is really the third row since Pyret counts
positions from 0).</p><p>If we run this expression at the prompt, we get</p><p><img src="../Images/d60ae702af1ad3975e72ce720628831a.png" alt="" width="347" height="70" data-original-src="https://dcic-world.org/2025-08-27/shuttle-row.png"/></p><p>This is a new type of data called a <code data-lang="pyret" class="sourceCode">Row</code>. When Pyret displays a
<code data-lang="pyret" class="sourceCode">Row</code> value, it shows you the column names and the corresponding
values within the row.</p><p>To extract the value of a specific column within a row, we write the
row followed by the name of the column (as a string) in square
brackets. Here are two equivalent ways of getting the value of the
<code data-lang="pyret" class="sourceCode">riders</code> column from the row for March:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle.row-n(2)["riders"]</code></pre><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">march-row = shuttle.row-n(2)
march-row["riders"]</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What names would be in the Pyret directory when using each of these
approaches?</p></blockquote></blockquote><p>Once we have the cell value (here a <code data-lang="pyret" class="sourceCode">Number</code>), we can use it in
any other computation, such as</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle.row-n(2)["riders"] &gt;= 1000</code></pre><p>(which checks whether there were at least <code data-lang="pyret" class="sourceCode">1000</code> riders in March).</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do you expect would happen if you forgot the quotation marks and
instead wrote:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle.row-n(2)[riders]</code></pre><p>What would Pyret do and why?</p></blockquote></blockquote>&#13;
<h4 class="heading">4.1.3¬†<a name="(part._.Functions_over_.Rows)"/>Functions over Rows<a href="#(part._.Functions_over_.Rows)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>Now that we have the ability to isolate Rows from tables, we can write
functions that ask questions about individual rows. We just saw an
example of doing a computation over row data, when we checked whether
the row for March had more than 1000 riders. What if we wanted to do
this comparison for an arbitrary row of this table? Let‚Äôs write a
function! We‚Äôll call it <code data-lang="pyret" class="sourceCode">cleared-1K</code>.</p><p>Let‚Äôs start with a function header and some examples:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun cleared-1K(r :: Row) -&gt; Boolean:
  doc: "determine whether given row has at least 1000 riders"
  ...
where:
  cleared-1K(shuttle.row-n(2)) is true
  cleared-1K(shuttle.row-n(3)) is false
end</code></pre><p>This shows you what examples for <code data-lang="pyret" class="sourceCode">Row</code> functions look like, as
well as how we use <code data-lang="pyret" class="sourceCode">Row</code> as an input type.</p><p>To fill in the body of the function, we extract the content of the
<code data-lang="pyret" class="sourceCode">"riders"</code> cell and compare it to <code data-lang="pyret" class="sourceCode">1000</code>:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun cleared-1K(r :: Row) -&gt; Boolean:
  doc: "determine whether given row has at least 1000 riders"
  r["riders"] &gt;= 1000
where:
  cleared-1K(shuttle.row-n(2)) is true
  cleared-1K(shuttle.row-n(3)) is false
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Looking at the examples, both of them share the <code data-lang="pyret" class="sourceCode">shuttle.row-n</code>
portion. Would it have been better to instead make <code data-lang="pyret" class="sourceCode">cleared-1K</code> a
function that takes just the row position as input, such as:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun cleared-1K(row-pos :: Number) -&gt; Boolean:
  ...
where:
  cleared-1K(2) is true
  cleared-1K(3) is false
end</code></pre><p>What are the benefits and limitations to doing this?</p></blockquote></blockquote><p>In general, the version that takes the <code data-lang="pyret" class="sourceCode">Row</code> input is more
flexible because it can work with a row from any table that has
a column named <code data-lang="pyret" class="sourceCode">"riders"</code>. We might have another table with more
columns of information or different data tables for different
years. If we modify <code data-lang="pyret" class="sourceCode">cleared-1K</code> to only take the row position as
input, that function will have to fix which table it works with. In
contrast, our original version leaves the specific table
(<code data-lang="pyret" class="sourceCode">shuttle</code>) outside the function, which leads to flexibility.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a function <code data-lang="pyret" class="sourceCode">is-winter</code> that takes a <code data-lang="pyret" class="sourceCode">Row</code> with a
<code data-lang="pyret" class="sourceCode">"month"</code> column as input and produces a <code data-lang="pyret" class="sourceCode">Boolean</code>
indicating whether the month in that row is one of <code data-lang="pyret" class="sourceCode">"Jan"</code>,
<code data-lang="pyret" class="sourceCode">"Feb"</code>, or <code data-lang="pyret" class="sourceCode">"Mar"</code>.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a function <code data-lang="pyret" class="sourceCode">low-winter</code> that takes in <code data-lang="pyret" class="sourceCode">Row</code> with both
<code data-lang="pyret" class="sourceCode">"month"</code> and <code data-lang="pyret" class="sourceCode">"riders"</code> columns and produces a
<code data-lang="pyret" class="sourceCode">Boolean</code> indicating whether the row is a winter row with fewer
than 1050 riders.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Practice with the program directory! Take a <code data-lang="pyret" class="sourceCode">Row</code> function and
one of its <code data-lang="pyret" class="sourceCode">where</code> examples, and show how the program directory
evolves as you evaluate the example.</p></blockquote></blockquote>&#13;
<h4 class="heading">4.1.4¬†<a name="(part._.Processing_.Rows)"/>Processing Rows<a href="#(part._.Processing_.Rows)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>So far, we have looked at extracting individual rows by their position
in the table and computing over them. Extracting rows by position
isn‚Äôt always convenient: we might have hundreds or thousands of rows,
and we might not know where the data we want even is in the table. We
would much rather be able to write a small program that identifies the
row (or rows!) that meets a specific criterion.</p><p>Pyret offers three different notations for processing
tables: one uses functions, one uses methods, and one uses a SQL-like
notation. This chapter uses the function-based notation. The SQL-like
notation and the methods-based notation are shown in the Pyret
Documentation. To use the function-based notation, you‚Äôll need to
include the file specified in the main narrative.</p><p>The rest of this section assumes that you have loaded the functions
notations for working with tables.</p><section class="SsectionLevel5" id="section 4.1.4.1"><h5 class="heading">4.1.4.1¬†<a name="(part._subsec~3afinding-rows)"/>Finding Rows<a href="#(part._subsec~3afinding-rows)" class="heading-anchor" title="Link to here">üîó</a> </h5><p>Imagine that we wanted to write a program to locate a row that has
fewer than <code data-lang="pyret" class="sourceCode">1000</code> riders from our <code data-lang="pyret" class="sourceCode">shuttle</code> table. With what
we‚Äôve studied so far, how might we try to write this? We could imagine
using a conditional, like follows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if shuttle.row-n(0)["riders"] &lt; 1000:
  shuttle.row-n(0)
else if shuttle.row-n(1)["riders"] &lt; 1000:
  shuttle.row-n(1)
else if shuttle.row-n(2)["riders"] &lt; 1000:
  shuttle.row-n(2)
else if shuttle.row-n(3)["riders"] &lt; 1000:
  shuttle.row-n(3)
else: ... # not clear what to do here
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What benefits and limitations do you see to this approach?</p></blockquote></blockquote><p>There are a couple of reasons why we might not care for this
solution. First, if we have thousands of rows, this will be terribly
painful to write. Second, there‚Äôs a lot of repetition here (only the
row positions are changing). Third, it isn‚Äôt clear what to do if there
aren‚Äôt any matching rows. In addition, what happens if there are
multiple rows that meet our criterion? In some cases, we might want to
be able to identify all of the rows that meet a condition and
use them for a subsequent computation (like seeing whether some months
have more low-ridership days than others).</p><p>This conditional is, however, the spirit of what we want to do:
go through the rows of the table one at a time, identifying those that
match some criterion. We just don‚Äôt want to be responsible for
manually checking each row. Fortunately for us, Pyret knows how to do
that. Pyret knows which rows are in a given table. Pyret can pull
out those rows one position at a time and check a criterion about
each one.</p><p>We just need to tell Pyret what criterion we want to use.</p><p>As before, we can express our criterion as a function that takes a
<code data-lang="pyret" class="sourceCode">Row</code> and produces a <code data-lang="pyret" class="sourceCode">Boolean</code> (a Boolean because our
criterion was used as the question part of an <code data-lang="pyret" class="sourceCode">if</code> expression in
our code sketch). In this case, we want:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun below-1K(r :: Row) -&gt; Boolean:
  doc: "determine whether row has fewer than 1000 riders"
  r["riders"] &lt; 1000
where:
  below-1K(shuttle.row-n(2)) is false
  below-1K(shuttle.row-n(3)) is true
end</code></pre><p>Now, we just need a way to tell Pyret to use this criterion as it
searches through the rows. We do this with a function called
<code data-lang="pyret" class="sourceCode">filter-with</code> which takes two inputs: the table to process and the
criterion to check on each row of the table.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with(shuttle, below-1K)</code></pre><p>Under the hood, <code data-lang="pyret" class="sourceCode">filter-with</code> works roughly like the <code data-lang="pyret" class="sourceCode">if</code>
statement we outlined above: it takes each row one at a time and calls
the given criterion function on it. But what does it do with the
results?</p><p>If you run the above expression, you‚Äôll see that <code data-lang="pyret" class="sourceCode">filter-with</code>
produces a table containing the matching row, not the row by
itself. This behavior is handy if multiple rows match the
criterion. For example, try:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with(shuttle, is-winter)</code></pre><p>(using the <code data-lang="pyret" class="sourceCode">is-winter</code> function from an exercise earlier in this
chapter). Now we get a table with the three rows corresponding to winter
months. If we want to be able to name this table for use in future
computations, we can do so with our usual notation for naming values:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">winter = filter-with(shuttle, is-winter)</code></pre></section><section class="SsectionLevel5" id="section 4.1.4.2"><h5 class="heading">4.1.4.2¬†<a name="(part._.Ordering_.Rows)"/>Ordering Rows<a href="#(part._.Ordering_.Rows)" class="heading-anchor" title="Link to here">üîó</a> </h5><p>Let‚Äôs ask a new question: which winter month had the fewest number
of riders?. This question requires us to identify a specific row,
namely, the winter row with the smallest value in the <code data-lang="pyret" class="sourceCode">"riders"</code>
column.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Can we do this with <code data-lang="pyret" class="sourceCode">filter-with</code>? Why or why not?</p></blockquote></blockquote><p>Think back to the <code data-lang="pyret" class="sourceCode">if</code> expression that motivated
<code data-lang="pyret" class="sourceCode">filter-with</code>: each row is evaluated independently of the
others. Our current question, however, requires comparing across
rows. That‚Äôs a different operation, so we will need more than
<code data-lang="pyret" class="sourceCode">filter-with</code>.</p><p>Tools for analyzing data (whether programming languages or
spreadsheets) provide ways for users to sort rows of a table
based on the values in a single column. That would help us here: we
could sort the winter rows from smallest to largest value in the
<code data-lang="pyret" class="sourceCode">"riders"</code> column, then extract the <code data-lang="pyret" class="sourceCode">"riders"</code> value from
the first row. First, let‚Äôs sort the rows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">order-by(winter, "riders", true)</code></pre><p>The <code data-lang="pyret" class="sourceCode">order-by</code> function takes three inputs: the table to sort
(<code data-lang="pyret" class="sourceCode">winter</code>), the column to sort on (<code data-lang="pyret" class="sourceCode">"riders"</code>), and a
<code data-lang="pyret" class="sourceCode">Boolean</code> to indicate whether we want to sort in increasing
order. (Had the third argument been <code data-lang="pyret" class="sourceCode">false</code>, the rows would be
sorted in decreasing order of the values in the named column.)</p><p><img src="../Images/50fd4ee1a960ed4942030557bea37389.png" alt="" width="178" height="151" data-original-src="https://dcic-world.org/2025-08-27/sorted-winter.png"/></p><p>In the sorted table, the row with the fewest riders is in the first
position. Our original question asked us to lookup the month with the
fewest riders. We did this earlier.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write the code to extract the name of the winter month with the fewest
riders.</p></blockquote></blockquote><p>Here are two ways to write that computation:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">order-by(winter, "riders", true).row-n(0)["month"]</code></pre><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sorted = order-by(winter, "riders", true)
least-row = sorted.row-n(0)
least-row["month"]</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Which of these two ways do you prefer? Why?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How does each of these programs affect the program
directory?</p></blockquote></blockquote><p>Note that this problem asked us to combine several actions that we‚Äôve
already seen on rows: we identify rows from within a table
(<code data-lang="pyret" class="sourceCode">filter-with</code>), order the rows (<code data-lang="pyret" class="sourceCode">order-by</code>), extract a
specific row (<code data-lang="pyret" class="sourceCode">row-n</code>), then extract a cell (with square brackets
and a column name). This is typical of how we will operate on tables,
combining multiple operations to compute a result (much as we did with
programs that manipulate images).</p></section><section class="SsectionLevel5" id="section 4.1.4.3"><h5 class="heading">4.1.4.3¬†<a name="(part._.Adding_.New_.Columns)"/>Adding New Columns<a href="#(part._.Adding_.New_.Columns)" class="heading-anchor" title="Link to here">üîó</a> </h5><p>Sometimes, we want to create a new column whose value is based on
those of existing columns. For instance, our table might reflect
employee records, and have columns named <code data-lang="pyret" class="sourceCode">hourly-wage</code> and
<code data-lang="pyret" class="sourceCode">hours-worked</code>, representing the corresponding quantities. We
would now like to extend this table with a new column to reflect each
employee‚Äôs total wage. Assume we started with the following table:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees =
  table: name,   hourly-wage, hours-worked
    row: "Harley",  15,          40
    row: "Obi",     20,          45
    row: "Anjali",  18,          39
    row: "Miyako",  18,          40
  end</code></pre><p>The table we want to end up with is:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees =
  table: name, hourly-wage, hours-worked, total-wage
    row: "Harley", 15,         40,         15 * 40
    row: "Obi",    20, 	       45,         20 * 45
    row: "Anjali", 18, 	       39,         18 * 39
    row: "Miyako", 18, 	       40,         18 * 40
  end</code></pre><p>(with the expressions in the <code data-lang="pyret" class="sourceCode">total-wage</code> column computed to
their numeric equivalents: we used the expressions here to illustrate
what we are trying to do).</p><p>Previously, when we have had a computation that we performed multiple
times, we created a helper function to do the computation.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Propose a helper function for computing total wages given the hourly
wage and number of hours worked.</p></blockquote></blockquote><p>Perhaps you came up with something like:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun compute-wages(wage :: Number, hours :: Number) -&gt; Number:
  wage * hours
end</code></pre><p>which we could use as follows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees =
  table: name, hourly-wage, hours-worked, total-wage
    row: "Harley", 15, 40, compute-wages(15, 40)
    row: "Obi",    20, 45, compute-wages(20, 45)
    row: "Anjali", 18, 39, compute-wages(18, 39)
    row: "Miyako", 18, 40, compute-wages(18, 40)
  end</code></pre><p>This is the right idea, but we can actually have this function do a
bit more work for us. The <code data-lang="pyret" class="sourceCode">wage</code> and <code data-lang="pyret" class="sourceCode">hours</code> values are in
cells within the same row. So if we could instead get the current row
as an input, we could write:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun compute-wages(r :: Row) -&gt; Number:
  r["hourly-wage"] * r["hours-worked"]
end

employees =
  table: name, hourly-wage, hours-worked, total-wage
    row: "Harley", 15, 40, compute-wages(&lt;row0&gt;)
    row: "Obi",    20, 45, compute-wages(&lt;row1&gt;)
    row: "Anjali", 18, 39, compute-wages(&lt;row2&gt;)
    row: "Miyako", 18, 40, compute-wages(&lt;row3&gt;)
  end</code></pre><p>But now, we are writing calls to <code data-lang="pyret" class="sourceCode">compute-wages</code> over and over!
Adding computed columns is a sufficiently common operation that Pyret
provides a table function called <code data-lang="pyret" class="sourceCode">build-column</code> for this
purpose. We use it by providing the function to use to populate values
in the new column as an input:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun compute-wages(r :: Row) -&gt; Number:
  doc: "compute total wages based on wage and hours worked"
  r["hourly-wage"] * r["hours-worked"]
end

build-column(employees, "total-wage", compute-wages)</code></pre><p>This creates a new column, <code data-lang="pyret" class="sourceCode">total-wage</code>, whose value in each row
is the product of the two named columns in that row. Pyret will put
the new column at the right end.</p></section><section class="SsectionLevel5" id="section 4.1.4.4"><h5 class="heading">4.1.4.4¬†<a name="(part._.Calculating_.New_.Column_.Values)"/>Calculating New Column Values<a href="#(part._.Calculating_.New_.Column_.Values)" class="heading-anchor" title="Link to here">üîó</a> </h5><p>Sometimes, we just want to calculate new values for an existing
column, rather than create an entirely new column. Giving raises to
employees is one such example. Assume we wanted to give a <code data-lang="pyret" class="sourceCode">10%</code> raise to
all employees making less than <code data-lang="pyret" class="sourceCode">20</code> an hour. We could write:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun new-rate(rate :: Number) -&gt; Number:
  doc: "Raise rates under 20 by 10%"
  if rate &lt; 20:
    rate * 1.1
  else:
    rate
  end
where:
  new-rate(20) is 20
  new-rate(10) is 11
  new-rate(0) is 0
end

fun give-raises(t :: Table) -&gt; Table:
  doc: "Give a 10% raise to anyone making under 20"
  transform-column(t, "hourly-wage", new-rate)
end</code></pre><p>Here, <code data-lang="pyret" class="sourceCode">transform-column</code> takes a table, the name of an existing
column in the table, and a function to update the value. The updating
function takes the current value in the column as input and produces
the new value for the column as output.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Run <code data-lang="pyret" class="sourceCode">give-raises</code> on the <code data-lang="pyret" class="sourceCode">employees</code> table. What wage will
show for <code data-lang="pyret" class="sourceCode">"Miyako"</code> in the <code data-lang="pyret" class="sourceCode">employees</code> table after
<code data-lang="pyret" class="sourceCode">give-raises</code> completes. Why?</p></blockquote></blockquote><p>Like all other Pyret <code data-lang="pyret" class="sourceCode">Table</code> operations, <code data-lang="pyret" class="sourceCode">transform-column</code>
produces a new table, leaving the original intact. Editing the
original table could be problematic‚Äìwhat if you made a mistake? How
would you recover the original table in that case? In general,
producing new tables with any modifications, then creating a new name
for the updated table once you have the one you want, is a less
error-prone way of working with datasets.</p></section>&#13;
<h5 class="heading">4.1.4.1¬†<a name="(part._subsec~3afinding-rows)"/>Finding Rows<a href="#(part._subsec~3afinding-rows)" class="heading-anchor" title="Link to here">üîó</a> </h5><p>Imagine that we wanted to write a program to locate a row that has
fewer than <code data-lang="pyret" class="sourceCode">1000</code> riders from our <code data-lang="pyret" class="sourceCode">shuttle</code> table. With what
we‚Äôve studied so far, how might we try to write this? We could imagine
using a conditional, like follows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if shuttle.row-n(0)["riders"] &lt; 1000:
  shuttle.row-n(0)
else if shuttle.row-n(1)["riders"] &lt; 1000:
  shuttle.row-n(1)
else if shuttle.row-n(2)["riders"] &lt; 1000:
  shuttle.row-n(2)
else if shuttle.row-n(3)["riders"] &lt; 1000:
  shuttle.row-n(3)
else: ... # not clear what to do here
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What benefits and limitations do you see to this approach?</p></blockquote></blockquote><p>There are a couple of reasons why we might not care for this
solution. First, if we have thousands of rows, this will be terribly
painful to write. Second, there‚Äôs a lot of repetition here (only the
row positions are changing). Third, it isn‚Äôt clear what to do if there
aren‚Äôt any matching rows. In addition, what happens if there are
multiple rows that meet our criterion? In some cases, we might want to
be able to identify all of the rows that meet a condition and
use them for a subsequent computation (like seeing whether some months
have more low-ridership days than others).</p><p>This conditional is, however, the spirit of what we want to do:
go through the rows of the table one at a time, identifying those that
match some criterion. We just don‚Äôt want to be responsible for
manually checking each row. Fortunately for us, Pyret knows how to do
that. Pyret knows which rows are in a given table. Pyret can pull
out those rows one position at a time and check a criterion about
each one.</p><p>We just need to tell Pyret what criterion we want to use.</p><p>As before, we can express our criterion as a function that takes a
<code data-lang="pyret" class="sourceCode">Row</code> and produces a <code data-lang="pyret" class="sourceCode">Boolean</code> (a Boolean because our
criterion was used as the question part of an <code data-lang="pyret" class="sourceCode">if</code> expression in
our code sketch). In this case, we want:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun below-1K(r :: Row) -&gt; Boolean:
  doc: "determine whether row has fewer than 1000 riders"
  r["riders"] &lt; 1000
where:
  below-1K(shuttle.row-n(2)) is false
  below-1K(shuttle.row-n(3)) is true
end</code></pre><p>Now, we just need a way to tell Pyret to use this criterion as it
searches through the rows. We do this with a function called
<code data-lang="pyret" class="sourceCode">filter-with</code> which takes two inputs: the table to process and the
criterion to check on each row of the table.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with(shuttle, below-1K)</code></pre><p>Under the hood, <code data-lang="pyret" class="sourceCode">filter-with</code> works roughly like the <code data-lang="pyret" class="sourceCode">if</code>
statement we outlined above: it takes each row one at a time and calls
the given criterion function on it. But what does it do with the
results?</p><p>If you run the above expression, you‚Äôll see that <code data-lang="pyret" class="sourceCode">filter-with</code>
produces a table containing the matching row, not the row by
itself. This behavior is handy if multiple rows match the
criterion. For example, try:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with(shuttle, is-winter)</code></pre><p>(using the <code data-lang="pyret" class="sourceCode">is-winter</code> function from an exercise earlier in this
chapter). Now we get a table with the three rows corresponding to winter
months. If we want to be able to name this table for use in future
computations, we can do so with our usual notation for naming values:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">winter = filter-with(shuttle, is-winter)</code></pre>&#13;
<h5 class="heading">4.1.4.2¬†<a name="(part._.Ordering_.Rows)"/>Ordering Rows<a href="#(part._.Ordering_.Rows)" class="heading-anchor" title="Link to here">üîó</a> </h5><p>Let‚Äôs ask a new question: which winter month had the fewest number
of riders?. This question requires us to identify a specific row,
namely, the winter row with the smallest value in the <code data-lang="pyret" class="sourceCode">"riders"</code>
column.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Can we do this with <code data-lang="pyret" class="sourceCode">filter-with</code>? Why or why not?</p></blockquote></blockquote><p>Think back to the <code data-lang="pyret" class="sourceCode">if</code> expression that motivated
<code data-lang="pyret" class="sourceCode">filter-with</code>: each row is evaluated independently of the
others. Our current question, however, requires comparing across
rows. That‚Äôs a different operation, so we will need more than
<code data-lang="pyret" class="sourceCode">filter-with</code>.</p><p>Tools for analyzing data (whether programming languages or
spreadsheets) provide ways for users to sort rows of a table
based on the values in a single column. That would help us here: we
could sort the winter rows from smallest to largest value in the
<code data-lang="pyret" class="sourceCode">"riders"</code> column, then extract the <code data-lang="pyret" class="sourceCode">"riders"</code> value from
the first row. First, let‚Äôs sort the rows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">order-by(winter, "riders", true)</code></pre><p>The <code data-lang="pyret" class="sourceCode">order-by</code> function takes three inputs: the table to sort
(<code data-lang="pyret" class="sourceCode">winter</code>), the column to sort on (<code data-lang="pyret" class="sourceCode">"riders"</code>), and a
<code data-lang="pyret" class="sourceCode">Boolean</code> to indicate whether we want to sort in increasing
order. (Had the third argument been <code data-lang="pyret" class="sourceCode">false</code>, the rows would be
sorted in decreasing order of the values in the named column.)</p><p><img src="../Images/50fd4ee1a960ed4942030557bea37389.png" alt="" width="178" height="151" data-original-src="https://dcic-world.org/2025-08-27/sorted-winter.png"/></p><p>In the sorted table, the row with the fewest riders is in the first
position. Our original question asked us to lookup the month with the
fewest riders. We did this earlier.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write the code to extract the name of the winter month with the fewest
riders.</p></blockquote></blockquote><p>Here are two ways to write that computation:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">order-by(winter, "riders", true).row-n(0)["month"]</code></pre><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sorted = order-by(winter, "riders", true)
least-row = sorted.row-n(0)
least-row["month"]</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Which of these two ways do you prefer? Why?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How does each of these programs affect the program
directory?</p></blockquote></blockquote><p>Note that this problem asked us to combine several actions that we‚Äôve
already seen on rows: we identify rows from within a table
(<code data-lang="pyret" class="sourceCode">filter-with</code>), order the rows (<code data-lang="pyret" class="sourceCode">order-by</code>), extract a
specific row (<code data-lang="pyret" class="sourceCode">row-n</code>), then extract a cell (with square brackets
and a column name). This is typical of how we will operate on tables,
combining multiple operations to compute a result (much as we did with
programs that manipulate images).</p>&#13;
<h5 class="heading">4.1.4.3¬†<a name="(part._.Adding_.New_.Columns)"/>Adding New Columns<a href="#(part._.Adding_.New_.Columns)" class="heading-anchor" title="Link to here">üîó</a> </h5><p>Sometimes, we want to create a new column whose value is based on
those of existing columns. For instance, our table might reflect
employee records, and have columns named <code data-lang="pyret" class="sourceCode">hourly-wage</code> and
<code data-lang="pyret" class="sourceCode">hours-worked</code>, representing the corresponding quantities. We
would now like to extend this table with a new column to reflect each
employee‚Äôs total wage. Assume we started with the following table:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees =
  table: name,   hourly-wage, hours-worked
    row: "Harley",  15,          40
    row: "Obi",     20,          45
    row: "Anjali",  18,          39
    row: "Miyako",  18,          40
  end</code></pre><p>The table we want to end up with is:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees =
  table: name, hourly-wage, hours-worked, total-wage
    row: "Harley", 15,         40,         15 * 40
    row: "Obi",    20, 	       45,         20 * 45
    row: "Anjali", 18, 	       39,         18 * 39
    row: "Miyako", 18, 	       40,         18 * 40
  end</code></pre><p>(with the expressions in the <code data-lang="pyret" class="sourceCode">total-wage</code> column computed to
their numeric equivalents: we used the expressions here to illustrate
what we are trying to do).</p><p>Previously, when we have had a computation that we performed multiple
times, we created a helper function to do the computation.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Propose a helper function for computing total wages given the hourly
wage and number of hours worked.</p></blockquote></blockquote><p>Perhaps you came up with something like:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun compute-wages(wage :: Number, hours :: Number) -&gt; Number:
  wage * hours
end</code></pre><p>which we could use as follows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees =
  table: name, hourly-wage, hours-worked, total-wage
    row: "Harley", 15, 40, compute-wages(15, 40)
    row: "Obi",    20, 45, compute-wages(20, 45)
    row: "Anjali", 18, 39, compute-wages(18, 39)
    row: "Miyako", 18, 40, compute-wages(18, 40)
  end</code></pre><p>This is the right idea, but we can actually have this function do a
bit more work for us. The <code data-lang="pyret" class="sourceCode">wage</code> and <code data-lang="pyret" class="sourceCode">hours</code> values are in
cells within the same row. So if we could instead get the current row
as an input, we could write:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun compute-wages(r :: Row) -&gt; Number:
  r["hourly-wage"] * r["hours-worked"]
end

employees =
  table: name, hourly-wage, hours-worked, total-wage
    row: "Harley", 15, 40, compute-wages(&lt;row0&gt;)
    row: "Obi",    20, 45, compute-wages(&lt;row1&gt;)
    row: "Anjali", 18, 39, compute-wages(&lt;row2&gt;)
    row: "Miyako", 18, 40, compute-wages(&lt;row3&gt;)
  end</code></pre><p>But now, we are writing calls to <code data-lang="pyret" class="sourceCode">compute-wages</code> over and over!
Adding computed columns is a sufficiently common operation that Pyret
provides a table function called <code data-lang="pyret" class="sourceCode">build-column</code> for this
purpose. We use it by providing the function to use to populate values
in the new column as an input:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun compute-wages(r :: Row) -&gt; Number:
  doc: "compute total wages based on wage and hours worked"
  r["hourly-wage"] * r["hours-worked"]
end

build-column(employees, "total-wage", compute-wages)</code></pre><p>This creates a new column, <code data-lang="pyret" class="sourceCode">total-wage</code>, whose value in each row
is the product of the two named columns in that row. Pyret will put
the new column at the right end.</p>&#13;
<h5 class="heading">4.1.4.4¬†<a name="(part._.Calculating_.New_.Column_.Values)"/>Calculating New Column Values<a href="#(part._.Calculating_.New_.Column_.Values)" class="heading-anchor" title="Link to here">üîó</a> </h5><p>Sometimes, we just want to calculate new values for an existing
column, rather than create an entirely new column. Giving raises to
employees is one such example. Assume we wanted to give a <code data-lang="pyret" class="sourceCode">10%</code> raise to
all employees making less than <code data-lang="pyret" class="sourceCode">20</code> an hour. We could write:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun new-rate(rate :: Number) -&gt; Number:
  doc: "Raise rates under 20 by 10%"
  if rate &lt; 20:
    rate * 1.1
  else:
    rate
  end
where:
  new-rate(20) is 20
  new-rate(10) is 11
  new-rate(0) is 0
end

fun give-raises(t :: Table) -&gt; Table:
  doc: "Give a 10% raise to anyone making under 20"
  transform-column(t, "hourly-wage", new-rate)
end</code></pre><p>Here, <code data-lang="pyret" class="sourceCode">transform-column</code> takes a table, the name of an existing
column in the table, and a function to update the value. The updating
function takes the current value in the column as input and produces
the new value for the column as output.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Run <code data-lang="pyret" class="sourceCode">give-raises</code> on the <code data-lang="pyret" class="sourceCode">employees</code> table. What wage will
show for <code data-lang="pyret" class="sourceCode">"Miyako"</code> in the <code data-lang="pyret" class="sourceCode">employees</code> table after
<code data-lang="pyret" class="sourceCode">give-raises</code> completes. Why?</p></blockquote></blockquote><p>Like all other Pyret <code data-lang="pyret" class="sourceCode">Table</code> operations, <code data-lang="pyret" class="sourceCode">transform-column</code>
produces a new table, leaving the original intact. Editing the
original table could be problematic‚Äìwhat if you made a mistake? How
would you recover the original table in that case? In general,
producing new tables with any modifications, then creating a new name
for the updated table once you have the one you want, is a less
error-prone way of working with datasets.</p>&#13;
<h4 class="heading">4.1.5¬†<a name="(part._.Examples_for_.Table-.Producing_.Functions)"/>Examples for Table-Producing Functions<a href="#(part._.Examples_for_.Table-.Producing_.Functions)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>How do we write examples for functions that produce tables? Conceptually,
the answer is simply "make sure you got the output table that you
expected". Logistically, writing examples for table functions seems
more painful because writing out an expected output tables is more
work than simply writing the output of a function that produces
numbers or strings. What can we do to manage that complexity?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How might you write the <code data-lang="pyret" class="sourceCode">where</code> block for <code data-lang="pyret" class="sourceCode">give-raises</code>?</p></blockquote></blockquote><p>Here are some ideas for writing the examples practically:</p><ul><li><p>Simplify the input table. Rather than work with a large
table with all of the columns you have, create a small table that has
sufficient variety only in the columns that the function uses. For our
example, we might use:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">wages-test =
  table: hourly-wage
    row: 15
    row: 20
    row: 18
    row: 18
  end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Would any table with a column of numbers work here? Or are there some
constraints on the rows or columns of the table?</p></blockquote></blockquote><p>The only constraint is that your input table has to have the column
names used in your function.</p></li><li><p>Remember that you can write computations in the code to
construct tables. This saves you from doing calculations by hand.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where:
  give-raises(wages-test) is
  table: hourly-wage
    row: 15 * 1.1
    row: 20
    row: 18 * 1.1
    row: 18 * 1.1
  end</code></pre><p>This example shows that you can write an output table directly in the
<code data-lang="pyret" class="sourceCode">where:</code> block ‚Äì the table doesn‚Äôt need to be named outside the
function. </p></li><li><p>Create a new table by taking rows from an existing table.
If you were instead writing examples for a function that involves filtering out rows
of a table, it helps to know how to create a new table using rows of
an existing one. For example, if we were writing a function to find
all rows in which employees were working exactly 40 hours, we‚Äôd like
to make sure that the resulting table had the first and fourth rows of
the <code data-lang="pyret" class="sourceCode">employees</code> table. Rather than write a new <code data-lang="pyret" class="sourceCode">table</code>
expression to create that table, we could write it as follows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">emps-at-40 =
  add-row(
    add-row(employees.empty(),
      employees.row-n(0)),
    employees.row-n(3))</code></pre><p>Here, <code data-lang="pyret" class="sourceCode">employees.empty()</code> creates a new, empty table with the
same column headers as <code data-lang="pyret" class="sourceCode">employees</code>. We‚Äôve already seen how
<code data-lang="pyret" class="sourceCode">row-n</code> extracts a row from a table. The <code data-lang="pyret" class="sourceCode">add-row</code> function
places the given row at the end of the given table.</p></li></ul><p>Another tip to keep in mind: when the only thing your function does is call
a built-in function like <code data-lang="pyret" class="sourceCode">transform-column</code> it usually suffices
to write examples for the function you wrote to compute the new column
value. It is only when your code is combining table operations, or
doing more complex processing than a single call to a built-in table
operation that you really need to present your own examples to a
reader of your code.</p>&#13;
<h4 class="heading">4.1.6¬†<a name="(part._sec~3alambda-tables)"/>Lambda: Anonymous Functions<a href="#(part._sec~3alambda-tables)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>Let‚Äôs revisit the program we wrote in <a href="#%28part._subsec~3afinding-rows%29" data-pltdoc="x">Finding Rows</a> for
finding all of the months in a table with fewer than 1000 riders:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle = table: month, riders
  row: "Jan", 1123
  row: "Feb", 1045
  row: "Mar", 1087
  row: "Apr", 999
end
fun below-1K(r :: Row) -&gt; Boolean:
  doc: "determine whether row has fewer than 1000 riders"
  r["riders"] &lt; 1000
where:
  below-1K(shuttle.row-n(2)) is false
  below-1K(shuttle.row-n(3)) is true
end
filter-with(shuttle, below-1K)</code></pre><p>This program might feel a bit verbose: do we really need to write a
helper function just to perform something as simple as a
<code data-lang="pyret" class="sourceCode">filter-with</code>? Wouldn‚Äôt it be easier to just write something like:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with(shuttle, r["riders"] &lt; 1000)</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What will Pyret produce if you run this expression?</p></blockquote></blockquote><p>Pyret will produce an <code data-lang="pyret" class="sourceCode">unbound identifier</code> error around the use
of <code data-lang="pyret" class="sourceCode">r</code> in this expression. What is <code data-lang="pyret" class="sourceCode">r</code>? We mean for <code data-lang="pyret" class="sourceCode">r</code>
to be the elements from <code data-lang="pyret" class="sourceCode">shuttle</code> in turn. Conceptually, that‚Äôs
what <code data-lang="pyret" class="sourceCode">filter-with</code> does, but we don‚Äôt have the mechanics right. When
we call a function, we evaluate the arguments before the body
of the function. Hence, the error regarding <code data-lang="pyret" class="sourceCode">r</code> being unbound.
The whole point of the <code data-lang="pyret" class="sourceCode">below-1K</code> helper function is to make
<code data-lang="pyret" class="sourceCode">r</code> a parameter to a function whose body is only evaluated once
a value for <code data-lang="pyret" class="sourceCode">r</code> is available.</p><p>To tighten the notation as in the one-line <code data-lang="pyret" class="sourceCode">filter-with</code> expression,
then, we have to find a way to tell Pyret to make a temporary function
that will get its inputs once <code data-lang="pyret" class="sourceCode">filter-with</code> is running. The following
notation achieves this:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with(shuttle, lam(r): r["riders"] &lt; 1000 end)</code></pre><p>We have added <code data-lang="pyret" class="sourceCode">lam(r)</code> and <code data-lang="pyret" class="sourceCode">end</code> around the expression that
we want to use in the <code data-lang="pyret" class="sourceCode">filter-with</code>. The <code data-lang="pyret" class="sourceCode">lam(r)</code> says "make a
temporary function that takes <code data-lang="pyret" class="sourceCode">r</code> as an input". The <code data-lang="pyret" class="sourceCode">end</code>
serves to end the function definition, as when we use
<code data-lang="pyret" class="sourceCode">fun</code>. <code data-lang="pyret" class="sourceCode">lam</code> is short for <code data-lang="pyret" class="sourceCode">lambda</code>, a form of function
definition that exists in many, though not all, languages.</p><p>The main difference between our original expression (using the
<code data-lang="pyret" class="sourceCode">below-1K</code> helper) and this new one (using <code data-lang="pyret" class="sourceCode">lam</code>) can be
seen through the program directory. To explain this, a little detail
about how <code data-lang="pyret" class="sourceCode">filter-with</code> is defined under the hood. In part, it looks
like:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun filter-with(tbl :: Table, keep :: (Row -&gt; Boolean)) -&gt; Table:
  if keep(&lt;row-from-table&gt;):
    ...
  else:
    ...
  end
end</code></pre><p>Whether we pass <code data-lang="pyret" class="sourceCode">below-1K</code> or the <code data-lang="pyret" class="sourceCode">lam</code> version to
<code data-lang="pyret" class="sourceCode">filter-with</code>, the <code data-lang="pyret" class="sourceCode">keep</code> parameter ends up referring to a
function with the same parameter and body. Since the function is only
actually called through the <code data-lang="pyret" class="sourceCode">keep</code> name, it doesn‚Äôt matter
whether or not a name is associated with it when it is initially
defined.</p><p>In practice, we use <code data-lang="pyret" class="sourceCode">lam</code> when we have to pass simple (single line)
functions to operations like <code data-lang="pyret" class="sourceCode">filter-with</code> (or <code data-lang="pyret" class="sourceCode">transform-column</code>,
<code data-lang="pyret" class="sourceCode">build-column</code>, etc). Of course, you can continue to write out names for
helper functions as we did with <code data-lang="pyret" class="sourceCode">below-1K</code> if that makes more sense to
you.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write the program to add 10 riders to each row in the <code data-lang="pyret" class="sourceCode">shuttle</code>
table above, using <code data-lang="pyret" class="sourceCode">lam</code> rather than a named helper-function.</p></blockquote></blockquote>    
</body>
</html>