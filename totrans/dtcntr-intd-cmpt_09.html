<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>4.1Â Introduction to Tabular DatağŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>4.1Â Introduction to Tabular DatağŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/intro-tabular-data.html">https://dcic-world.org/2025-08-27/intro-tabular-data.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Creating_.Tabular_.Data%29" class="toclink" data-pltdoc="x">4.1.1<span class="hspace">Â </span>Creating Tabular Data</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Extracting_.Rows_and_.Cell_.Values%29" class="toclink" data-pltdoc="x">4.1.2<span class="hspace">Â </span>Extracting Rows and Cell Values</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Functions_over_.Rows%29" class="toclink" data-pltdoc="x">4.1.3<span class="hspace">Â </span>Functions over Rows</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Processing_.Rows%29" class="toclink" data-pltdoc="x">4.1.4<span class="hspace">Â </span>Processing Rows</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._subsec~3afinding-rows%29" class="toclink" data-pltdoc="x">4.1.4.1<span class="hspace">Â </span>Finding Rows</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Ordering_.Rows%29" class="toclink" data-pltdoc="x">4.1.4.2<span class="hspace">Â </span>Ordering Rows</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Adding_.New_.Columns%29" class="toclink" data-pltdoc="x">4.1.4.3<span class="hspace">Â </span>Adding New Columns</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Calculating_.New_.Column_.Values%29" class="toclink" data-pltdoc="x">4.1.4.4<span class="hspace">Â </span>Calculating New Column Values</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Examples_for_.Table-.Producing_.Functions%29" class="toclink" data-pltdoc="x">4.1.5<span class="hspace">Â </span>Examples for Table-Producing Functions</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._sec~3alambda-tables%29" class="toclink" data-pltdoc="x">4.1.6<span class="hspace">Â </span>Lambda: Anonymous Functions</a></p></td></tr></table><p/><div class="SIntrapara">Many interesting data in computing are <span style="font-style: italic">tabular</span>â€”<wbr/>i.e., like a
tableâ€”<wbr/>in form. First weâ€™ll see a few examples of them, before we try
to identify what they have in common. Here are some of them:
</div><div class="SIntrapara"><ul><li><p>An email inbox is a list of messages. For each message, your
inbox stores a bunch of information: its sender, the subject line, the
conversation itâ€™s part of, the body, and quite a bit more.</p><p><img src="../Images/17a64e6b5180eb56ebf06a02ffe39113.png" alt="" width="1136" height="46" data-original-src="https://dcic-world.org/2025-08-27/gmail-1.png"/></p></li><li><p>A music playlist. For each song, your music player maintains a
bunch of information: its name, the singer, its length, its genre, and
so on.</p><p><img src="../Images/c49e8b34342ce5900ea7036fda0dff30.png" alt="" width="740" height="91" data-original-src="https://dcic-world.org/2025-08-27/itunes-2.png"/></p></li><li><p>A filesystem folder or directory. For each file, your filesystem
records a name, a modification date, size, and other information.</p><p><img src="../Images/b73acd1cfa429053983b7085ec7786c9.png" alt="" width="733" height="119" data-original-src="https://dcic-world.org/2025-08-27/filesystem-1.png"/></p></li></ul></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Can you come up with more examples?</p></blockquote></blockquote><p/><div class="SIntrapara">How about:
</div><div class="SIntrapara"><ul><li><p>Responses to a party invitation.</p></li><li><p>A gradebook.</p></li><li><p>A calendar agenda.</p></li></ul></div><div class="SIntrapara">You can think of many more in your life!</div><p/><div class="SIntrapara">What do all these have in common? The characteristics of tabular data are:
</div><div class="SIntrapara"><ul><li><p>They contain information about zero or more items (i.e.,
individuals or artifacts) that share
characteristics. Each item is stored in a row. Each column tracks one of
the shared attributes across the rows. For example, each song or
email message or file is a row. Each of their characteristicsâ€”<wbr/>the
song title, the message subject, the filenameâ€”<wbr/>is a column.
<span class="refelem"><span class="refcolumn"><span class="refcontent">While some spreadsheets might swap the roles of rows and
columns, we stick to this organization as it aligns with the design of
data-science software libraries. This is an example of what Hadley
Wickham calls
<a href="https://vita.had.co.nz/papers/tidy-data.pdf">tidy
data</a>.</span></span></span></p></li><li><p>Each row has the same columns as the other rows, in the same
order.</p></li><li><p>A given column has the same type, but different columns can have
different types. For instance, an email message has a senderâ€™s name,
which is a string; a subject line, which is a string; a sent date,
which is a date; whether itâ€™s been read, which is a Boolean; and so
on.</p></li><li><p>The rows might be in some particular order. For instance, the
emails are ordered by which was most recently sent.</p></li></ul></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Find the characteristics of tabular data in the other examples
described above, as well as in the ones you described.</p></blockquote></blockquote><p>We will now learn how to program with tables and to how to
decompose tasks that process them. To access the functions that weâ€™ll
use to do this, you need to set the context (at the top of the
definitions window) to <span class="RktSym">dcic2024</span><span class="RktMeta"/>. <span class="refelem"><span class="refcolumn"><span class="refcontent">Earlier editions of the
book had you use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shared-gdrive</code></span> to load a file to access these
functions. This is no longer necessary when using the <span class="RktSym">dcic2024</span><span class="RktMeta"/>
context.</span></span></span> In
<span class="Smaller">CPO</span>, click on the down arrow at the top left of the screen (left of
the Pyret logo), select â€Choose Contextâ€œ, then enter <span class="RktSym">dcic2024</span><span class="RktMeta"/>
in the box, as shown in this screenshot:</p><p><img src="../Images/710c9c4fd77163faf8376fe746fdec28.png" alt="" width="615" height="329" data-original-src="https://dcic-world.org/2025-08-27/choose-context.png"/></p><p>After you click the Submit button, the definitions window will show
the name of the context as in the following image:</p><p><img src="../Images/6d810094e710d0cc7fbef1bae2a68941.png" alt="" width="340" height="90" data-original-src="https://dcic-world.org/2025-08-27/context-in-use.png"/></p><p><a href="https://hackmd.io/@cs111/table">Documentation on the
function-based table operators</a> is available on a separate
page outside of the Pyret documentation.</p><section class="SsectionLevel4" id="section 4.1.1"><h4 class="heading">4.1.1<span class="stt">Â </span><a name="(part._.Creating_.Tabular_.Data)"/>Creating Tabular Data<span class="button-group"><a href="#(part._.Creating_.Tabular_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">Pyret provides multiple easy ways of creating tabular data. The
simplest is to define the datum in a program as follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">table: name, age
  row: "Alicia", 30
  row: "Meihui", 40
  row: "Jamal", 25
end</code></pre></div></div></div><div class="SIntrapara">That is, a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">table</code></span> is followed by the names of the columns in
their desired order, followed by a sequence of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">row</code></span>s. Each row
must contain as many data as the column declares, and in the same
order.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Change different parts of the above exampleâ€”<wbr/>e.g., remove a necessary
value from a row, add an extraneous one, remove a comma, add an extra
comma, leave an extra comma at the end of a rowâ€”<wbr/>and see what errors
you get.</p></blockquote></blockquote><p/><div class="SIntrapara">Note that in a table, the order of columns matters: two tables that
are otherwise identical but with different column orders are not
considered equal.
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  table: name, age
    row: "Alicia", 30
    row: "Meihui", 40
    row: "Jamal", 25
  end
  is-not
  table: age, name
    row: 30, "Alicia"
    row: 40, "Meihui"
    row: 25, "Jamal"
  end
end</code></pre></div></div></div><div class="SIntrapara">Observe that the example above uses <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-not</code></span>, i.e., the test
passes, meaning that the tables are <span class="emph">not</span> equal.</div><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:</code></span> annotation here is a way of writing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span>
assertions about expressions outside of the context of a function (and
its <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where</code></span> block). Weâ€™ll learn more about <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check</code></span> in
<a href="testing.html#%28part._from-examples-to-tests%29" data-pltdoc="x">From Examples to Tests</a>.</p><p/><div class="SIntrapara">Table expressions create table values. These can be stored in variables just
like numbers, strings, and images:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">people = table: name, age
  row: "Alicia", 30
  row: "Meihui", 40
  row: "Jamal", 25
end</code></pre></div></div></div><p/><div class="SIntrapara">We call these <span style="font-style: italic">literal</span> tables when we create them with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">table</code></span>.
Pyret provides other ways to get tabular data, too! In
particular, you can <a href="https://www.pyret.org/docs/latest/gdrive-sheets.html">import tabular data from a spreadsheet</a>, so
any mechanism that lets you create such a sheet can also be used. You
might:
</div><div class="SIntrapara"><ul><li><p>create the sheet on your own,</p></li><li><p>create a sheet collaboratively with friends,</p></li><li><p>find data on the Web that you can import into a sheet,</p></li><li><p>create a Google Form that you get others to fill out, and obtain
a sheet out of their responses</p></li></ul></div><div class="SIntrapara">and so on. Let your imagination run wild! Once the data are in Pyret,
it doesnâ€™t matter where they came from.</div><p>With tables, we begin to explore data that <span class="emph">contain other
(smaller) pieces of data</span>. Weâ€™ll refer to such data as <span style="font-style: italic">structured data</span>.
Structured data <span class="emph">organize their inner data in a structured
way</span> (here, rows and columns). As with images, when we wrote code that
reflected the structure of the final image, we will see that code that
works with tables also follows the structure of the data.</p></section><section class="SsectionLevel4" id="section 4.1.2"><h4 class="heading">4.1.2<span class="stt">Â </span><a name="(part._.Extracting_.Rows_and_.Cell_.Values)"/>Extracting Rows and Cell Values<span class="button-group"><a href="#(part._.Extracting_.Rows_and_.Cell_.Values)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Given a table, we sometimes want to look up the value of a particular
cell. Weâ€™ll work with the following table showing the number of riders
on a shuttle service over several months:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle = table: month, riders
  row: "Jan", 1123
  row: "Feb", 1045
  row: "Mar", 1087
  row: "Apr", 999
end</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>If you put this table in the definitions pane and press Run, what
will be in the Pyret directory once the interactions prompt appears?
Would the column names be listed in the directory?</p></blockquote></blockquote><p>As a reminder, the directory contains only those names that we assign
values to using the form <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">name = </code></span>. The directory here would
contain <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle</code></span>, which would be bound to the table (yes, the
entire table would be in the directory!). The column names would not
have their own entries in the directory. At the low level, this is because we
never wrote anything of the form <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">colname = ...</code></span>.  At the high
level, we donâ€™t usually build tables by creating individual columns
and putting them together side by side. (If anything, it is more common
to create individual rows, since rows correspond to individual
observations, events, or entities; we didnâ€™t do that in this
example, however).</p><p>Starting from the name associated with a table, we can lookup the
value in a given cell (row and column) in the table. Concretely,
assume we want to extract the number of riders in March (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1087</code></span>)
so we can use it in another computation. How do we do that?</p><p>Pyret (and most other programming languages designed for data
analysis) organizes tables as collections of rows with shared
columns. Given that organization, we get to a specific cell by first
isolating the row we are interested in, then retrieving the contents
of the cell.</p><p/><div class="SIntrapara">Pyret numbers the rows of a table from top to bottom starting at 0
(most programming languages use 0 as the first position in a piece of
data, for reasons we will see later). So if we want to see the data
for March, we need to isolate row 2. We write:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle.row-n(2)</code></pre></div></div></div><div class="SIntrapara">We use the period notation to dig into a piece of structured data. Here,
we are saying "dig into the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle</code></span> table, extracting row
number <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>" (which is really the third row since Pyret counts
positions from 0).</div><p>If we run this expression at the prompt, we get</p><p><img src="../Images/d60ae702af1ad3975e72ce720628831a.png" alt="" width="347" height="70" data-original-src="https://dcic-world.org/2025-08-27/shuttle-row.png"/></p><p>This is a new type of data called a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Row</code></span>. When Pyret displays a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Row</code></span> value, it shows you the column names and the corresponding
values within the row.</p><p>To extract the value of a specific column within a row, we write the
row followed by the name of the column (as a string) in square
brackets. Here are two equivalent ways of getting the value of the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">riders</code></span> column from the row for March:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle.row-n(2)["riders"]</code></pre></div></div><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">march-row = shuttle.row-n(2)
march-row["riders"]</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What names would be in the Pyret directory when using each of these
approaches?</p></blockquote></blockquote><p>Once we have the cell value (here a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Number</code></span>), we can use it in
any other computation, such as</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle.row-n(2)["riders"] &gt;= 1000</code></pre></div></div></div><div class="SIntrapara">(which checks whether there were at least <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1000</code></span> riders in March).</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do you expect would happen if you forgot the quotation marks and
instead wrote:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle.row-n(2)[riders]</code></pre></div></div></div><div class="SIntrapara">What would Pyret do and why?</div></blockquote></blockquote></section><section class="SsectionLevel4" id="section 4.1.3"><h4 class="heading">4.1.3<span class="stt">Â </span><a name="(part._.Functions_over_.Rows)"/>Functions over Rows<span class="button-group"><a href="#(part._.Functions_over_.Rows)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Now that we have the ability to isolate Rows from tables, we can write
functions that ask questions about individual rows. We just saw an
example of doing a computation over row data, when we checked whether
the row for March had more than 1000 riders. What if we wanted to do
this comparison for an arbitrary row of this table? Letâ€™s write a
function! Weâ€™ll call it <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cleared-1K</code></span>.</p><p>Letâ€™s start with a function header and some examples:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun cleared-1K(r :: Row) -&gt; Boolean:
  doc: "determine whether given row has at least 1000 riders"
  ...
where:
  cleared-1K(shuttle.row-n(2)) is true
  cleared-1K(shuttle.row-n(3)) is false
end</code></pre></div></div></div><div class="SIntrapara">This shows you what examples for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Row</code></span> functions look like, as
well as how we use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Row</code></span> as an input type.</div><p>To fill in the body of the function, we extract the content of the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"riders"</code></span> cell and compare it to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1000</code></span>:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun cleared-1K(r :: Row) -&gt; Boolean:
  doc: "determine whether given row has at least 1000 riders"
  r["riders"] &gt;= 1000
where:
  cleared-1K(shuttle.row-n(2)) is true
  cleared-1K(shuttle.row-n(3)) is false
end</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Looking at the examples, both of them share the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle.row-n</code></span>
portion. Would it have been better to instead make <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cleared-1K</code></span> a
function that takes just the row position as input, such as:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun cleared-1K(row-pos :: Number) -&gt; Boolean:
  ...
where:
  cleared-1K(2) is true
  cleared-1K(3) is false
end</code></pre></div></div></div><div class="SIntrapara">What are the benefits and limitations to doing this?</div></blockquote></blockquote><p>In general, the version that takes the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Row</code></span> input is more
flexible because it can work with a row from <span class="emph">any</span> table that has
a column named <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"riders"</code></span>. We might have another table with more
columns of information or different data tables for different
years. If we modify <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cleared-1K</code></span> to only take the row position as
input, that function will have to fix which table it works with. In
contrast, our original version leaves the specific table
(<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle</code></span>) outside the function, which leads to flexibility.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-winter</code></span> that takes a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Row</code></span> with a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"month"</code></span> column as input and produces a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Boolean</code></span>
indicating whether the month in that row is one of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"Jan"</code></span>,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"Feb"</code></span>, or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"Mar"</code></span>.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">low-winter</code></span> that takes in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Row</code></span> with both
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"month"</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"riders"</code></span> columns and produces a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Boolean</code></span> indicating whether the row is a winter row with fewer
than 1050 riders.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Practice with the program directory! Take a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Row</code></span> function and
one of its <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where</code></span> examples, and show how the program directory
evolves as you evaluate the example.</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 4.1.4"><h4 class="heading">4.1.4<span class="stt">Â </span><a name="(part._.Processing_.Rows)"/>Processing Rows<span class="button-group"><a href="#(part._.Processing_.Rows)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>So far, we have looked at extracting individual rows by their position
in the table and computing over them. Extracting rows by position
isnâ€™t always convenient: we might have hundreds or thousands of rows,
and we might not know where the data we want even is in the table. We
would much rather be able to write a small program that identifies the
row (or rows!) that meets a specific criterion.</p><p><span class="refelem"><span class="refcolumn"><span class="refcontent">Pyret offers three different notations for processing
tables: one uses functions, one uses methods, and one uses a SQL-like
notation. This chapter uses the function-based notation. The SQL-like
notation and the methods-based notation are shown in the Pyret
Documentation. To use the function-based notation, youâ€™ll need to
include the file specified in the main narrative.</span></span></span></p><p>The rest of this section assumes that you have loaded the functions
notations for working with tables.</p><section class="SsectionLevel5" id="section 4.1.4.1"><h5 class="heading">4.1.4.1<span class="stt">Â </span><a name="(part._subsec~3afinding-rows)"/>Finding Rows<span class="button-group"><a href="#(part._subsec~3afinding-rows)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Imagine that we wanted to write a program to locate a row that has
fewer than <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1000</code></span> riders from our <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle</code></span> table. With what
weâ€™ve studied so far, how might we try to write this? We could imagine
using a conditional, like follows:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if shuttle.row-n(0)["riders"] &lt; 1000:
  shuttle.row-n(0)
else if shuttle.row-n(1)["riders"] &lt; 1000:
  shuttle.row-n(1)
else if shuttle.row-n(2)["riders"] &lt; 1000:
  shuttle.row-n(2)
else if shuttle.row-n(3)["riders"] &lt; 1000:
  shuttle.row-n(3)
else: ... # not clear what to do here
end</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What benefits and limitations do you see to this approach?</p></blockquote></blockquote><p>There are a couple of reasons why we might not care for this
solution. First, if we have thousands of rows, this will be terribly
painful to write. Second, thereâ€™s a lot of repetition here (only the
row positions are changing). Third, it isnâ€™t clear what to do if there
arenâ€™t any matching rows. In addition, what happens if there are
multiple rows that meet our criterion? In some cases, we might want to
be able to identify <span class="emph">all</span> of the rows that meet a condition and
use them for a subsequent computation (like seeing whether some months
have more low-ridership days than others).</p><p>This conditional is, however, the <span class="emph">spirit</span> of what we want to do:
go through the rows of the table one at a time, identifying those that
match some criterion. We just donâ€™t want to be responsible for
manually checking each row. Fortunately for us, Pyret knows how to do
that. Pyret knows which rows are in a given table. Pyret can pull
out those rows one position at a time and check a criterion about
each one.</p><p>We just need to tell Pyret what criterion we want to use.</p><p>As before, we can express our criterion as a function that takes a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Row</code></span> and produces a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Boolean</code></span> (a Boolean because our
criterion was used as the question part of an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if</code></span> expression in
our code sketch). In this case, we want:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun below-1K(r :: Row) -&gt; Boolean:
  doc: "determine whether row has fewer than 1000 riders"
  r["riders"] &lt; 1000
where:
  below-1K(shuttle.row-n(2)) is false
  below-1K(shuttle.row-n(3)) is true
end</code></pre></div></div><p>Now, we just need a way to tell Pyret to use this criterion as it
searches through the rows. We do this with a function called
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span> which takes two inputs: the table to process and the
criterion to check on each row of the table.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with(shuttle, below-1K)</code></pre></div></div><p>Under the hood, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span> works roughly like the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if</code></span>
statement we outlined above: it takes each row one at a time and calls
the given criterion function on it. But what does it do with the
results?</p><p/><div class="SIntrapara">If you run the above expression, youâ€™ll see that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>
produces a table containing the matching row, not the row by
itself. This behavior is handy if multiple rows match the
criterion. For example, try:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with(shuttle, is-winter)</code></pre></div></div></div><div class="SIntrapara">(using the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-winter</code></span> function from an exercise earlier in this
chapter). Now we get a table with the three rows corresponding to winter
months. If we want to be able to name this table for use in future
computations, we can do so with our usual notation for naming values:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">winter = filter-with(shuttle, is-winter)</code></pre></div></div></div></section><section class="SsectionLevel5" id="section 4.1.4.2"><h5 class="heading">4.1.4.2<span class="stt">Â </span><a name="(part._.Ordering_.Rows)"/>Ordering Rows<span class="button-group"><a href="#(part._.Ordering_.Rows)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Letâ€™s ask a new question: <span class="emph">which winter month had the fewest number
of riders?</span>. This question requires us to identify a specific row,
namely, the winter row with the smallest value in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"riders"</code></span>
column.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Can we do this with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>? Why or why not?</p></blockquote></blockquote><p>Think back to the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if</code></span> expression that motivated
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>: each row is evaluated independently of the
others. Our current question, however, requires <span class="emph">comparing across
rows</span>. Thatâ€™s a different operation, so we will need more than
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>.</p><p>Tools for analyzing data (whether programming languages or
spreadsheets) provide ways for users to <span class="emph">sort</span> rows of a table
based on the values in a single column. That would help us here: we
could sort the winter rows from smallest to largest value in the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"riders"</code></span> column, then extract the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"riders"</code></span> value from
the first row. First, letâ€™s sort the rows:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">order-by(winter, "riders", true)</code></pre></div></div><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">order-by</code></span> function takes three inputs: the table to sort
(<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">winter</code></span>), the column to sort on (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"riders"</code></span>), and a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Boolean</code></span> to indicate whether we want to sort in increasing
order. (Had the third argument been <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span>, the rows would be
sorted in decreasing order of the values in the named column.)</p><p><img src="../Images/50fd4ee1a960ed4942030557bea37389.png" alt="" width="178" height="151" data-original-src="https://dcic-world.org/2025-08-27/sorted-winter.png"/></p><p>In the sorted table, the row with the fewest riders is in the first
position. Our original question asked us to lookup the month with the
fewest riders. We did this earlier.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write the code to extract the name of the winter month with the fewest
riders.</p></blockquote></blockquote><p>Here are two ways to write that computation:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">order-by(winter, "riders", true).row-n(0)["month"]</code></pre></div></div><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sorted = order-by(winter, "riders", true)
least-row = sorted.row-n(0)
least-row["month"]</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Which of these two ways do you prefer? Why?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How does each of these programs affect the program
directory?</p></blockquote></blockquote><p>Note that this problem asked us to combine several actions that weâ€™ve
already seen on rows: we identify rows from within a table
(<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>), order the rows (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">order-by</code></span>), extract a
specific row (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">row-n</code></span>), then extract a cell (with square brackets
and a column name). This is typical of how we will operate on tables,
combining multiple operations to compute a result (much as we did with
programs that manipulate images).</p></section><section class="SsectionLevel5" id="section 4.1.4.3"><h5 class="heading">4.1.4.3<span class="stt">Â </span><a name="(part._.Adding_.New_.Columns)"/>Adding New Columns<span class="button-group"><a href="#(part._.Adding_.New_.Columns)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Sometimes, we want to create a new column whose value is based on
those of existing columns. For instance, our table might reflect
employee records, and have columns named <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">hourly-wage</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">hours-worked</code></span>, representing the corresponding quantities. We
would now like to extend this table with a new column to reflect each
employeeâ€™s total wage. Assume we started with the following table:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees =
  table: name,   hourly-wage, hours-worked
    row: "Harley",  15,          40
    row: "Obi",     20,          45
    row: "Anjali",  18,          39
    row: "Miyako",  18,          40
  end</code></pre></div></div></div><p/><div class="SIntrapara">The table we want to end up with is:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees =
  table: name, hourly-wage, hours-worked, total-wage
    row: "Harley", 15,         40,         15 * 40
    row: "Obi",    20, 	       45,         20 * 45
    row: "Anjali", 18, 	       39,         18 * 39
    row: "Miyako", 18, 	       40,         18 * 40
  end</code></pre></div></div></div><div class="SIntrapara">(with the expressions in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">total-wage</code></span> column computed to
their numeric equivalents: we used the expressions here to illustrate
what we are trying to do).</div><p>Previously, when we have had a computation that we performed multiple
times, we created a helper function to do the computation.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Propose a helper function for computing total wages given the hourly
wage and number of hours worked.</p></blockquote></blockquote><p>Perhaps you came up with something like:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun compute-wages(wage :: Number, hours :: Number) -&gt; Number:
  wage * hours
end</code></pre></div></div></div><div class="SIntrapara">which we could use as follows:</div><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees =
  table: name, hourly-wage, hours-worked, total-wage
    row: "Harley", 15, 40, compute-wages(15, 40)
    row: "Obi",    20, 45, compute-wages(20, 45)
    row: "Anjali", 18, 39, compute-wages(18, 39)
    row: "Miyako", 18, 40, compute-wages(18, 40)
  end</code></pre></div></div><p>This is the right idea, but we can actually have this function do a
bit more work for us. The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">wage</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">hours</code></span> values are in
cells within the same row. So if we could instead get the current row
as an input, we could write:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun compute-wages(r :: Row) -&gt; Number:
  r["hourly-wage"] * r["hours-worked"]
end

employees =
  table: name, hourly-wage, hours-worked, total-wage
    row: "Harley", 15, 40, compute-wages(&lt;row0&gt;)
    row: "Obi",    20, 45, compute-wages(&lt;row1&gt;)
    row: "Anjali", 18, 39, compute-wages(&lt;row2&gt;)
    row: "Miyako", 18, 40, compute-wages(&lt;row3&gt;)
  end</code></pre></div></div><p>But now, we are writing calls to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">compute-wages</code></span> over and over!
Adding computed columns is a sufficiently common operation that Pyret
provides a table function called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">build-column</code></span> for this
purpose. We use it by providing the function to use to populate values
in the new column as an input:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun compute-wages(r :: Row) -&gt; Number:
  doc: "compute total wages based on wage and hours worked"
  r["hourly-wage"] * r["hours-worked"]
end

build-column(employees, "total-wage", compute-wages)</code></pre></div></div></div><div class="SIntrapara">This creates a new column, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">total-wage</code></span>, whose value in each row
is the product of the two named columns in that row. Pyret will put
the new column at the right end.</div></section><section class="SsectionLevel5" id="section 4.1.4.4"><h5 class="heading">4.1.4.4<span class="stt">Â </span><a name="(part._.Calculating_.New_.Column_.Values)"/>Calculating New Column Values<span class="button-group"><a href="#(part._.Calculating_.New_.Column_.Values)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Sometimes, we just want to calculate new values for an existing
column, rather than create an entirely new column. Giving raises to
employees is one such example. Assume we wanted to give a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">10%</code></span> raise to
all employees making less than <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">20</code></span> an hour. We could write:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun new-rate(rate :: Number) -&gt; Number:
  doc: "Raise rates under 20 by 10%"
  if rate &lt; 20:
    rate * 1.1
  else:
    rate
  end
where:
  new-rate(20) is 20
  new-rate(10) is 11
  new-rate(0) is 0
end

fun give-raises(t :: Table) -&gt; Table:
  doc: "Give a 10% raise to anyone making under 20"
  transform-column(t, "hourly-wage", new-rate)
end</code></pre></div></div></div><div class="SIntrapara">Here, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">transform-column</code></span> takes a table, the name of an existing
column in the table, and a function to update the value. The updating
function takes the current value in the column as input and produces
the new value for the column as output.</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Run <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">give-raises</code></span> on the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees</code></span> table. What wage will
show for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"Miyako"</code></span> in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees</code></span> table after
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">give-raises</code></span> completes. Why?</p></blockquote></blockquote><p>Like all other Pyret <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Table</code></span> operations, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">transform-column</code></span>
produces a new table, leaving the original intact. Editing the
original table could be problematicâ€“what if you made a mistake? How
would you recover the original table in that case? In general,
producing new tables with any modifications, then creating a new name
for the updated table once you have the one you want, is a less
error-prone way of working with datasets.</p></section></section><section class="SsectionLevel4" id="section 4.1.5"><h4 class="heading">4.1.5<span class="stt">Â </span><a name="(part._.Examples_for_.Table-.Producing_.Functions)"/>Examples for Table-Producing Functions<span class="button-group"><a href="#(part._.Examples_for_.Table-.Producing_.Functions)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>How do we write examples for functions that produce tables? Conceptually,
the answer is simply "make sure you got the output table that you
expected". Logistically, writing examples for table functions seems
more painful because writing out an expected output tables is more
work than simply writing the output of a function that produces
numbers or strings. What can we do to manage that complexity?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How might you write the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where</code></span> block for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">give-raises</code></span>?</p></blockquote></blockquote><p>Here are some ideas for writing the examples practically:</p><ul><li><p><span class="emph">Simplify the input table</span>. Rather than work with a large
table with all of the columns you have, create a small table that has
sufficient variety only in the columns that the function uses. For our
example, we might use:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">wages-test =
  table: hourly-wage
    row: 15
    row: 20
    row: 18
    row: 18
  end</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Would any table with a column of numbers work here? Or are there some
constraints on the rows or columns of the table?</p></blockquote></blockquote><p>The only constraint is that your input table has to have the column
names used in your function.</p></li><li><p><span class="emph">Remember that you can write computations in the code to
construct tables</span>. This saves you from doing calculations by hand.</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where:
  give-raises(wages-test) is
  table: hourly-wage
    row: 15 * 1.1
    row: 20
    row: 18 * 1.1
    row: 18 * 1.1
  end</code></pre></div></div></div><div class="SIntrapara">This example shows that you can write an output table directly in the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where:</code></span> block â€“ the table doesnâ€™t need to be named outside the
function. </div></li><li><p><span class="emph">Create a new table by taking rows from an existing table</span>.
If you were instead writing examples for a function that involves filtering out rows
of a table, it helps to know how to create a new table using rows of
an existing one. For example, if we were writing a function to find
all rows in which employees were working exactly 40 hours, weâ€™d like
to make sure that the resulting table had the first and fourth rows of
the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees</code></span> table. Rather than write a new <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">table</code></span>
expression to create that table, we could write it as follows:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">emps-at-40 =
  add-row(
    add-row(employees.empty(),
      employees.row-n(0)),
    employees.row-n(3))</code></pre></div></div></div><div class="SIntrapara">Here, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees.empty()</code></span> creates a new, empty table with the
same column headers as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees</code></span>. Weâ€™ve already seen how
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">row-n</code></span> extracts a row from a table. The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">add-row</code></span> function
places the given row at the end of the given table.</div></li></ul><p>Another tip to keep in mind: when the only thing your function does is call
a built-in function like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">transform-column</code></span> it usually suffices
to write examples for the function you wrote to compute the new column
value. It is only when your code is combining table operations, or
doing more complex processing than a single call to a built-in table
operation that you really need to present your own examples to a
reader of your code.</p></section><section class="SsectionLevel4" id="section 4.1.6"><h4 class="heading">4.1.6<span class="stt">Â </span><a name="(part._sec~3alambda-tables)"/>Lambda: Anonymous Functions<span class="button-group"><a href="#(part._sec~3alambda-tables)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Letâ€™s revisit the program we wrote in <a href="#%28part._subsec~3afinding-rows%29" data-pltdoc="x">Finding Rows</a> for
finding all of the months in a table with fewer than 1000 riders:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle = table: month, riders
  row: "Jan", 1123
  row: "Feb", 1045
  row: "Mar", 1087
  row: "Apr", 999
end
fun below-1K(r :: Row) -&gt; Boolean:
  doc: "determine whether row has fewer than 1000 riders"
  r["riders"] &lt; 1000
where:
  below-1K(shuttle.row-n(2)) is false
  below-1K(shuttle.row-n(3)) is true
end
filter-with(shuttle, below-1K)</code></pre></div></div><p>This program might feel a bit verbose: do we really need to write a
helper function just to perform something as simple as a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>? Wouldnâ€™t it be easier to just write something like:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with(shuttle, r["riders"] &lt; 1000)</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What will Pyret produce if you run this expression?</p></blockquote></blockquote><p>Pyret will produce an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">unbound identifier</code></span> error around the use
of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> in this expression. What is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span>? We mean for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span>
to be the elements from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle</code></span> in turn. Conceptually, thatâ€™s
what <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span> does, but we donâ€™t have the mechanics right. When
we call a function, we evaluate the arguments <span class="emph">before</span> the body
of the function. Hence, the error regarding <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> being unbound.
The whole point of the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">below-1K</code></span> helper function is to make
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> a parameter to a function whose body is only evaluated once
a value for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> is available.</p><p>To tighten the notation as in the one-line <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span> expression,
then, we have to find a way to tell Pyret to make a temporary function
that will get its inputs once <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span> is running. The following
notation achieves this:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with(shuttle, lam(r): r["riders"] &lt; 1000 end)</code></pre></div></div><p>We have added <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam(r)</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">end</code></span> around the expression that
we want to use in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>. The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam(r)</code></span> says "make a
temporary function that takes <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> as an input". The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">end</code></span>
serves to end the function definition, as when we use
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun</code></span>. <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span> is short for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lambda</code></span>, a form of function
definition that exists in many, though not all, languages.</p><p>The main difference between our original expression (using the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">below-1K</code></span> helper) and this new one (using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span>) can be
seen through the program directory. To explain this, a little detail
about how <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span> is defined under the hood. In part, it looks
like:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun filter-with(tbl :: Table, keep :: (Row -&gt; Boolean)) -&gt; Table:
  if keep(&lt;row-from-table&gt;):
    ...
  else:
    ...
  end
end</code></pre></div></div><p>Whether we pass <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">below-1K</code></span> or the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span> version to
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>, the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">keep</code></span> parameter ends up referring to a
function with the same parameter and body. Since the function is only
actually called through the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">keep</code></span> name, it doesnâ€™t matter
whether or not a name is associated with it when it is initially
defined.</p><p>In practice, we use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span> when we have to pass simple (single line)
functions to operations like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span> (or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">transform-column</code></span>,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">build-column</code></span>, etc). Of course, you can continue to write out names for
helper functions as we did with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">below-1K</code></span> if that makes more sense to
you.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write the program to add 10 riders to each row in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle</code></span>
table above, using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span> rather than a named helper-function.</p></blockquote></blockquote></section>&#13;
<h4 class="heading">4.1.1<span class="stt">Â </span><a name="(part._.Creating_.Tabular_.Data)"/>Creating Tabular Data<span class="button-group"><a href="#(part._.Creating_.Tabular_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">Pyret provides multiple easy ways of creating tabular data. The
simplest is to define the datum in a program as follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">table: name, age
  row: "Alicia", 30
  row: "Meihui", 40
  row: "Jamal", 25
end</code></pre></div></div></div><div class="SIntrapara">That is, a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">table</code></span> is followed by the names of the columns in
their desired order, followed by a sequence of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">row</code></span>s. Each row
must contain as many data as the column declares, and in the same
order.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Change different parts of the above exampleâ€”<wbr/>e.g., remove a necessary
value from a row, add an extraneous one, remove a comma, add an extra
comma, leave an extra comma at the end of a rowâ€”<wbr/>and see what errors
you get.</p></blockquote></blockquote><p/><div class="SIntrapara">Note that in a table, the order of columns matters: two tables that
are otherwise identical but with different column orders are not
considered equal.
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  table: name, age
    row: "Alicia", 30
    row: "Meihui", 40
    row: "Jamal", 25
  end
  is-not
  table: age, name
    row: 30, "Alicia"
    row: 40, "Meihui"
    row: 25, "Jamal"
  end
end</code></pre></div></div></div><div class="SIntrapara">Observe that the example above uses <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-not</code></span>, i.e., the test
passes, meaning that the tables are <span class="emph">not</span> equal.</div><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:</code></span> annotation here is a way of writing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span>
assertions about expressions outside of the context of a function (and
its <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where</code></span> block). Weâ€™ll learn more about <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check</code></span> in
<a href="testing.html#%28part._from-examples-to-tests%29" data-pltdoc="x">From Examples to Tests</a>.</p><p/><div class="SIntrapara">Table expressions create table values. These can be stored in variables just
like numbers, strings, and images:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">people = table: name, age
  row: "Alicia", 30
  row: "Meihui", 40
  row: "Jamal", 25
end</code></pre></div></div></div><p/><div class="SIntrapara">We call these <span style="font-style: italic">literal</span> tables when we create them with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">table</code></span>.
Pyret provides other ways to get tabular data, too! In
particular, you can <a href="https://www.pyret.org/docs/latest/gdrive-sheets.html">import tabular data from a spreadsheet</a>, so
any mechanism that lets you create such a sheet can also be used. You
might:
</div><div class="SIntrapara"><ul><li><p>create the sheet on your own,</p></li><li><p>create a sheet collaboratively with friends,</p></li><li><p>find data on the Web that you can import into a sheet,</p></li><li><p>create a Google Form that you get others to fill out, and obtain
a sheet out of their responses</p></li></ul></div><div class="SIntrapara">and so on. Let your imagination run wild! Once the data are in Pyret,
it doesnâ€™t matter where they came from.</div><p>With tables, we begin to explore data that <span class="emph">contain other
(smaller) pieces of data</span>. Weâ€™ll refer to such data as <span style="font-style: italic">structured data</span>.
Structured data <span class="emph">organize their inner data in a structured
way</span> (here, rows and columns). As with images, when we wrote code that
reflected the structure of the final image, we will see that code that
works with tables also follows the structure of the data.</p>&#13;
<h4 class="heading">4.1.2<span class="stt">Â </span><a name="(part._.Extracting_.Rows_and_.Cell_.Values)"/>Extracting Rows and Cell Values<span class="button-group"><a href="#(part._.Extracting_.Rows_and_.Cell_.Values)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Given a table, we sometimes want to look up the value of a particular
cell. Weâ€™ll work with the following table showing the number of riders
on a shuttle service over several months:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle = table: month, riders
  row: "Jan", 1123
  row: "Feb", 1045
  row: "Mar", 1087
  row: "Apr", 999
end</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>If you put this table in the definitions pane and press Run, what
will be in the Pyret directory once the interactions prompt appears?
Would the column names be listed in the directory?</p></blockquote></blockquote><p>As a reminder, the directory contains only those names that we assign
values to using the form <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">name = </code></span>. The directory here would
contain <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle</code></span>, which would be bound to the table (yes, the
entire table would be in the directory!). The column names would not
have their own entries in the directory. At the low level, this is because we
never wrote anything of the form <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">colname = ...</code></span>.  At the high
level, we donâ€™t usually build tables by creating individual columns
and putting them together side by side. (If anything, it is more common
to create individual rows, since rows correspond to individual
observations, events, or entities; we didnâ€™t do that in this
example, however).</p><p>Starting from the name associated with a table, we can lookup the
value in a given cell (row and column) in the table. Concretely,
assume we want to extract the number of riders in March (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1087</code></span>)
so we can use it in another computation. How do we do that?</p><p>Pyret (and most other programming languages designed for data
analysis) organizes tables as collections of rows with shared
columns. Given that organization, we get to a specific cell by first
isolating the row we are interested in, then retrieving the contents
of the cell.</p><p/><div class="SIntrapara">Pyret numbers the rows of a table from top to bottom starting at 0
(most programming languages use 0 as the first position in a piece of
data, for reasons we will see later). So if we want to see the data
for March, we need to isolate row 2. We write:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle.row-n(2)</code></pre></div></div></div><div class="SIntrapara">We use the period notation to dig into a piece of structured data. Here,
we are saying "dig into the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle</code></span> table, extracting row
number <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>" (which is really the third row since Pyret counts
positions from 0).</div><p>If we run this expression at the prompt, we get</p><p><img src="../Images/d60ae702af1ad3975e72ce720628831a.png" alt="" width="347" height="70" data-original-src="https://dcic-world.org/2025-08-27/shuttle-row.png"/></p><p>This is a new type of data called a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Row</code></span>. When Pyret displays a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Row</code></span> value, it shows you the column names and the corresponding
values within the row.</p><p>To extract the value of a specific column within a row, we write the
row followed by the name of the column (as a string) in square
brackets. Here are two equivalent ways of getting the value of the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">riders</code></span> column from the row for March:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle.row-n(2)["riders"]</code></pre></div></div><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">march-row = shuttle.row-n(2)
march-row["riders"]</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What names would be in the Pyret directory when using each of these
approaches?</p></blockquote></blockquote><p>Once we have the cell value (here a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Number</code></span>), we can use it in
any other computation, such as</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle.row-n(2)["riders"] &gt;= 1000</code></pre></div></div></div><div class="SIntrapara">(which checks whether there were at least <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1000</code></span> riders in March).</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do you expect would happen if you forgot the quotation marks and
instead wrote:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle.row-n(2)[riders]</code></pre></div></div></div><div class="SIntrapara">What would Pyret do and why?</div></blockquote></blockquote>&#13;
<h4 class="heading">4.1.3<span class="stt">Â </span><a name="(part._.Functions_over_.Rows)"/>Functions over Rows<span class="button-group"><a href="#(part._.Functions_over_.Rows)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Now that we have the ability to isolate Rows from tables, we can write
functions that ask questions about individual rows. We just saw an
example of doing a computation over row data, when we checked whether
the row for March had more than 1000 riders. What if we wanted to do
this comparison for an arbitrary row of this table? Letâ€™s write a
function! Weâ€™ll call it <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cleared-1K</code></span>.</p><p>Letâ€™s start with a function header and some examples:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun cleared-1K(r :: Row) -&gt; Boolean:
  doc: "determine whether given row has at least 1000 riders"
  ...
where:
  cleared-1K(shuttle.row-n(2)) is true
  cleared-1K(shuttle.row-n(3)) is false
end</code></pre></div></div></div><div class="SIntrapara">This shows you what examples for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Row</code></span> functions look like, as
well as how we use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Row</code></span> as an input type.</div><p>To fill in the body of the function, we extract the content of the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"riders"</code></span> cell and compare it to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1000</code></span>:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun cleared-1K(r :: Row) -&gt; Boolean:
  doc: "determine whether given row has at least 1000 riders"
  r["riders"] &gt;= 1000
where:
  cleared-1K(shuttle.row-n(2)) is true
  cleared-1K(shuttle.row-n(3)) is false
end</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Looking at the examples, both of them share the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle.row-n</code></span>
portion. Would it have been better to instead make <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cleared-1K</code></span> a
function that takes just the row position as input, such as:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun cleared-1K(row-pos :: Number) -&gt; Boolean:
  ...
where:
  cleared-1K(2) is true
  cleared-1K(3) is false
end</code></pre></div></div></div><div class="SIntrapara">What are the benefits and limitations to doing this?</div></blockquote></blockquote><p>In general, the version that takes the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Row</code></span> input is more
flexible because it can work with a row from <span class="emph">any</span> table that has
a column named <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"riders"</code></span>. We might have another table with more
columns of information or different data tables for different
years. If we modify <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cleared-1K</code></span> to only take the row position as
input, that function will have to fix which table it works with. In
contrast, our original version leaves the specific table
(<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle</code></span>) outside the function, which leads to flexibility.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-winter</code></span> that takes a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Row</code></span> with a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"month"</code></span> column as input and produces a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Boolean</code></span>
indicating whether the month in that row is one of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"Jan"</code></span>,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"Feb"</code></span>, or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"Mar"</code></span>.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">low-winter</code></span> that takes in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Row</code></span> with both
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"month"</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"riders"</code></span> columns and produces a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Boolean</code></span> indicating whether the row is a winter row with fewer
than 1050 riders.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Practice with the program directory! Take a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Row</code></span> function and
one of its <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where</code></span> examples, and show how the program directory
evolves as you evaluate the example.</p></blockquote></blockquote>&#13;
<h4 class="heading">4.1.4<span class="stt">Â </span><a name="(part._.Processing_.Rows)"/>Processing Rows<span class="button-group"><a href="#(part._.Processing_.Rows)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>So far, we have looked at extracting individual rows by their position
in the table and computing over them. Extracting rows by position
isnâ€™t always convenient: we might have hundreds or thousands of rows,
and we might not know where the data we want even is in the table. We
would much rather be able to write a small program that identifies the
row (or rows!) that meets a specific criterion.</p><p><span class="refelem"><span class="refcolumn"><span class="refcontent">Pyret offers three different notations for processing
tables: one uses functions, one uses methods, and one uses a SQL-like
notation. This chapter uses the function-based notation. The SQL-like
notation and the methods-based notation are shown in the Pyret
Documentation. To use the function-based notation, youâ€™ll need to
include the file specified in the main narrative.</span></span></span></p><p>The rest of this section assumes that you have loaded the functions
notations for working with tables.</p><section class="SsectionLevel5" id="section 4.1.4.1"><h5 class="heading">4.1.4.1<span class="stt">Â </span><a name="(part._subsec~3afinding-rows)"/>Finding Rows<span class="button-group"><a href="#(part._subsec~3afinding-rows)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Imagine that we wanted to write a program to locate a row that has
fewer than <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1000</code></span> riders from our <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle</code></span> table. With what
weâ€™ve studied so far, how might we try to write this? We could imagine
using a conditional, like follows:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if shuttle.row-n(0)["riders"] &lt; 1000:
  shuttle.row-n(0)
else if shuttle.row-n(1)["riders"] &lt; 1000:
  shuttle.row-n(1)
else if shuttle.row-n(2)["riders"] &lt; 1000:
  shuttle.row-n(2)
else if shuttle.row-n(3)["riders"] &lt; 1000:
  shuttle.row-n(3)
else: ... # not clear what to do here
end</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What benefits and limitations do you see to this approach?</p></blockquote></blockquote><p>There are a couple of reasons why we might not care for this
solution. First, if we have thousands of rows, this will be terribly
painful to write. Second, thereâ€™s a lot of repetition here (only the
row positions are changing). Third, it isnâ€™t clear what to do if there
arenâ€™t any matching rows. In addition, what happens if there are
multiple rows that meet our criterion? In some cases, we might want to
be able to identify <span class="emph">all</span> of the rows that meet a condition and
use them for a subsequent computation (like seeing whether some months
have more low-ridership days than others).</p><p>This conditional is, however, the <span class="emph">spirit</span> of what we want to do:
go through the rows of the table one at a time, identifying those that
match some criterion. We just donâ€™t want to be responsible for
manually checking each row. Fortunately for us, Pyret knows how to do
that. Pyret knows which rows are in a given table. Pyret can pull
out those rows one position at a time and check a criterion about
each one.</p><p>We just need to tell Pyret what criterion we want to use.</p><p>As before, we can express our criterion as a function that takes a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Row</code></span> and produces a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Boolean</code></span> (a Boolean because our
criterion was used as the question part of an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if</code></span> expression in
our code sketch). In this case, we want:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun below-1K(r :: Row) -&gt; Boolean:
  doc: "determine whether row has fewer than 1000 riders"
  r["riders"] &lt; 1000
where:
  below-1K(shuttle.row-n(2)) is false
  below-1K(shuttle.row-n(3)) is true
end</code></pre></div></div><p>Now, we just need a way to tell Pyret to use this criterion as it
searches through the rows. We do this with a function called
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span> which takes two inputs: the table to process and the
criterion to check on each row of the table.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with(shuttle, below-1K)</code></pre></div></div><p>Under the hood, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span> works roughly like the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if</code></span>
statement we outlined above: it takes each row one at a time and calls
the given criterion function on it. But what does it do with the
results?</p><p/><div class="SIntrapara">If you run the above expression, youâ€™ll see that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>
produces a table containing the matching row, not the row by
itself. This behavior is handy if multiple rows match the
criterion. For example, try:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with(shuttle, is-winter)</code></pre></div></div></div><div class="SIntrapara">(using the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-winter</code></span> function from an exercise earlier in this
chapter). Now we get a table with the three rows corresponding to winter
months. If we want to be able to name this table for use in future
computations, we can do so with our usual notation for naming values:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">winter = filter-with(shuttle, is-winter)</code></pre></div></div></div></section><section class="SsectionLevel5" id="section 4.1.4.2"><h5 class="heading">4.1.4.2<span class="stt">Â </span><a name="(part._.Ordering_.Rows)"/>Ordering Rows<span class="button-group"><a href="#(part._.Ordering_.Rows)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Letâ€™s ask a new question: <span class="emph">which winter month had the fewest number
of riders?</span>. This question requires us to identify a specific row,
namely, the winter row with the smallest value in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"riders"</code></span>
column.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Can we do this with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>? Why or why not?</p></blockquote></blockquote><p>Think back to the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if</code></span> expression that motivated
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>: each row is evaluated independently of the
others. Our current question, however, requires <span class="emph">comparing across
rows</span>. Thatâ€™s a different operation, so we will need more than
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>.</p><p>Tools for analyzing data (whether programming languages or
spreadsheets) provide ways for users to <span class="emph">sort</span> rows of a table
based on the values in a single column. That would help us here: we
could sort the winter rows from smallest to largest value in the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"riders"</code></span> column, then extract the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"riders"</code></span> value from
the first row. First, letâ€™s sort the rows:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">order-by(winter, "riders", true)</code></pre></div></div><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">order-by</code></span> function takes three inputs: the table to sort
(<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">winter</code></span>), the column to sort on (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"riders"</code></span>), and a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Boolean</code></span> to indicate whether we want to sort in increasing
order. (Had the third argument been <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span>, the rows would be
sorted in decreasing order of the values in the named column.)</p><p><img src="../Images/50fd4ee1a960ed4942030557bea37389.png" alt="" width="178" height="151" data-original-src="https://dcic-world.org/2025-08-27/sorted-winter.png"/></p><p>In the sorted table, the row with the fewest riders is in the first
position. Our original question asked us to lookup the month with the
fewest riders. We did this earlier.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write the code to extract the name of the winter month with the fewest
riders.</p></blockquote></blockquote><p>Here are two ways to write that computation:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">order-by(winter, "riders", true).row-n(0)["month"]</code></pre></div></div><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sorted = order-by(winter, "riders", true)
least-row = sorted.row-n(0)
least-row["month"]</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Which of these two ways do you prefer? Why?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How does each of these programs affect the program
directory?</p></blockquote></blockquote><p>Note that this problem asked us to combine several actions that weâ€™ve
already seen on rows: we identify rows from within a table
(<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>), order the rows (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">order-by</code></span>), extract a
specific row (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">row-n</code></span>), then extract a cell (with square brackets
and a column name). This is typical of how we will operate on tables,
combining multiple operations to compute a result (much as we did with
programs that manipulate images).</p></section><section class="SsectionLevel5" id="section 4.1.4.3"><h5 class="heading">4.1.4.3<span class="stt">Â </span><a name="(part._.Adding_.New_.Columns)"/>Adding New Columns<span class="button-group"><a href="#(part._.Adding_.New_.Columns)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Sometimes, we want to create a new column whose value is based on
those of existing columns. For instance, our table might reflect
employee records, and have columns named <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">hourly-wage</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">hours-worked</code></span>, representing the corresponding quantities. We
would now like to extend this table with a new column to reflect each
employeeâ€™s total wage. Assume we started with the following table:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees =
  table: name,   hourly-wage, hours-worked
    row: "Harley",  15,          40
    row: "Obi",     20,          45
    row: "Anjali",  18,          39
    row: "Miyako",  18,          40
  end</code></pre></div></div></div><p/><div class="SIntrapara">The table we want to end up with is:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees =
  table: name, hourly-wage, hours-worked, total-wage
    row: "Harley", 15,         40,         15 * 40
    row: "Obi",    20, 	       45,         20 * 45
    row: "Anjali", 18, 	       39,         18 * 39
    row: "Miyako", 18, 	       40,         18 * 40
  end</code></pre></div></div></div><div class="SIntrapara">(with the expressions in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">total-wage</code></span> column computed to
their numeric equivalents: we used the expressions here to illustrate
what we are trying to do).</div><p>Previously, when we have had a computation that we performed multiple
times, we created a helper function to do the computation.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Propose a helper function for computing total wages given the hourly
wage and number of hours worked.</p></blockquote></blockquote><p>Perhaps you came up with something like:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun compute-wages(wage :: Number, hours :: Number) -&gt; Number:
  wage * hours
end</code></pre></div></div></div><div class="SIntrapara">which we could use as follows:</div><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees =
  table: name, hourly-wage, hours-worked, total-wage
    row: "Harley", 15, 40, compute-wages(15, 40)
    row: "Obi",    20, 45, compute-wages(20, 45)
    row: "Anjali", 18, 39, compute-wages(18, 39)
    row: "Miyako", 18, 40, compute-wages(18, 40)
  end</code></pre></div></div><p>This is the right idea, but we can actually have this function do a
bit more work for us. The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">wage</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">hours</code></span> values are in
cells within the same row. So if we could instead get the current row
as an input, we could write:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun compute-wages(r :: Row) -&gt; Number:
  r["hourly-wage"] * r["hours-worked"]
end

employees =
  table: name, hourly-wage, hours-worked, total-wage
    row: "Harley", 15, 40, compute-wages(&lt;row0&gt;)
    row: "Obi",    20, 45, compute-wages(&lt;row1&gt;)
    row: "Anjali", 18, 39, compute-wages(&lt;row2&gt;)
    row: "Miyako", 18, 40, compute-wages(&lt;row3&gt;)
  end</code></pre></div></div><p>But now, we are writing calls to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">compute-wages</code></span> over and over!
Adding computed columns is a sufficiently common operation that Pyret
provides a table function called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">build-column</code></span> for this
purpose. We use it by providing the function to use to populate values
in the new column as an input:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun compute-wages(r :: Row) -&gt; Number:
  doc: "compute total wages based on wage and hours worked"
  r["hourly-wage"] * r["hours-worked"]
end

build-column(employees, "total-wage", compute-wages)</code></pre></div></div></div><div class="SIntrapara">This creates a new column, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">total-wage</code></span>, whose value in each row
is the product of the two named columns in that row. Pyret will put
the new column at the right end.</div></section><section class="SsectionLevel5" id="section 4.1.4.4"><h5 class="heading">4.1.4.4<span class="stt">Â </span><a name="(part._.Calculating_.New_.Column_.Values)"/>Calculating New Column Values<span class="button-group"><a href="#(part._.Calculating_.New_.Column_.Values)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Sometimes, we just want to calculate new values for an existing
column, rather than create an entirely new column. Giving raises to
employees is one such example. Assume we wanted to give a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">10%</code></span> raise to
all employees making less than <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">20</code></span> an hour. We could write:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun new-rate(rate :: Number) -&gt; Number:
  doc: "Raise rates under 20 by 10%"
  if rate &lt; 20:
    rate * 1.1
  else:
    rate
  end
where:
  new-rate(20) is 20
  new-rate(10) is 11
  new-rate(0) is 0
end

fun give-raises(t :: Table) -&gt; Table:
  doc: "Give a 10% raise to anyone making under 20"
  transform-column(t, "hourly-wage", new-rate)
end</code></pre></div></div></div><div class="SIntrapara">Here, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">transform-column</code></span> takes a table, the name of an existing
column in the table, and a function to update the value. The updating
function takes the current value in the column as input and produces
the new value for the column as output.</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Run <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">give-raises</code></span> on the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees</code></span> table. What wage will
show for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"Miyako"</code></span> in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees</code></span> table after
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">give-raises</code></span> completes. Why?</p></blockquote></blockquote><p>Like all other Pyret <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Table</code></span> operations, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">transform-column</code></span>
produces a new table, leaving the original intact. Editing the
original table could be problematicâ€“what if you made a mistake? How
would you recover the original table in that case? In general,
producing new tables with any modifications, then creating a new name
for the updated table once you have the one you want, is a less
error-prone way of working with datasets.</p></section>&#13;
<h5 class="heading">4.1.4.1<span class="stt">Â </span><a name="(part._subsec~3afinding-rows)"/>Finding Rows<span class="button-group"><a href="#(part._subsec~3afinding-rows)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Imagine that we wanted to write a program to locate a row that has
fewer than <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1000</code></span> riders from our <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle</code></span> table. With what
weâ€™ve studied so far, how might we try to write this? We could imagine
using a conditional, like follows:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if shuttle.row-n(0)["riders"] &lt; 1000:
  shuttle.row-n(0)
else if shuttle.row-n(1)["riders"] &lt; 1000:
  shuttle.row-n(1)
else if shuttle.row-n(2)["riders"] &lt; 1000:
  shuttle.row-n(2)
else if shuttle.row-n(3)["riders"] &lt; 1000:
  shuttle.row-n(3)
else: ... # not clear what to do here
end</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What benefits and limitations do you see to this approach?</p></blockquote></blockquote><p>There are a couple of reasons why we might not care for this
solution. First, if we have thousands of rows, this will be terribly
painful to write. Second, thereâ€™s a lot of repetition here (only the
row positions are changing). Third, it isnâ€™t clear what to do if there
arenâ€™t any matching rows. In addition, what happens if there are
multiple rows that meet our criterion? In some cases, we might want to
be able to identify <span class="emph">all</span> of the rows that meet a condition and
use them for a subsequent computation (like seeing whether some months
have more low-ridership days than others).</p><p>This conditional is, however, the <span class="emph">spirit</span> of what we want to do:
go through the rows of the table one at a time, identifying those that
match some criterion. We just donâ€™t want to be responsible for
manually checking each row. Fortunately for us, Pyret knows how to do
that. Pyret knows which rows are in a given table. Pyret can pull
out those rows one position at a time and check a criterion about
each one.</p><p>We just need to tell Pyret what criterion we want to use.</p><p>As before, we can express our criterion as a function that takes a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Row</code></span> and produces a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Boolean</code></span> (a Boolean because our
criterion was used as the question part of an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if</code></span> expression in
our code sketch). In this case, we want:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun below-1K(r :: Row) -&gt; Boolean:
  doc: "determine whether row has fewer than 1000 riders"
  r["riders"] &lt; 1000
where:
  below-1K(shuttle.row-n(2)) is false
  below-1K(shuttle.row-n(3)) is true
end</code></pre></div></div><p>Now, we just need a way to tell Pyret to use this criterion as it
searches through the rows. We do this with a function called
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span> which takes two inputs: the table to process and the
criterion to check on each row of the table.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with(shuttle, below-1K)</code></pre></div></div><p>Under the hood, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span> works roughly like the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if</code></span>
statement we outlined above: it takes each row one at a time and calls
the given criterion function on it. But what does it do with the
results?</p><p/><div class="SIntrapara">If you run the above expression, youâ€™ll see that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>
produces a table containing the matching row, not the row by
itself. This behavior is handy if multiple rows match the
criterion. For example, try:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with(shuttle, is-winter)</code></pre></div></div></div><div class="SIntrapara">(using the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-winter</code></span> function from an exercise earlier in this
chapter). Now we get a table with the three rows corresponding to winter
months. If we want to be able to name this table for use in future
computations, we can do so with our usual notation for naming values:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">winter = filter-with(shuttle, is-winter)</code></pre></div></div></div>&#13;
<h5 class="heading">4.1.4.2<span class="stt">Â </span><a name="(part._.Ordering_.Rows)"/>Ordering Rows<span class="button-group"><a href="#(part._.Ordering_.Rows)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Letâ€™s ask a new question: <span class="emph">which winter month had the fewest number
of riders?</span>. This question requires us to identify a specific row,
namely, the winter row with the smallest value in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"riders"</code></span>
column.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Can we do this with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>? Why or why not?</p></blockquote></blockquote><p>Think back to the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if</code></span> expression that motivated
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>: each row is evaluated independently of the
others. Our current question, however, requires <span class="emph">comparing across
rows</span>. Thatâ€™s a different operation, so we will need more than
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>.</p><p>Tools for analyzing data (whether programming languages or
spreadsheets) provide ways for users to <span class="emph">sort</span> rows of a table
based on the values in a single column. That would help us here: we
could sort the winter rows from smallest to largest value in the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"riders"</code></span> column, then extract the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"riders"</code></span> value from
the first row. First, letâ€™s sort the rows:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">order-by(winter, "riders", true)</code></pre></div></div><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">order-by</code></span> function takes three inputs: the table to sort
(<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">winter</code></span>), the column to sort on (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"riders"</code></span>), and a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Boolean</code></span> to indicate whether we want to sort in increasing
order. (Had the third argument been <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span>, the rows would be
sorted in decreasing order of the values in the named column.)</p><p><img src="../Images/50fd4ee1a960ed4942030557bea37389.png" alt="" width="178" height="151" data-original-src="https://dcic-world.org/2025-08-27/sorted-winter.png"/></p><p>In the sorted table, the row with the fewest riders is in the first
position. Our original question asked us to lookup the month with the
fewest riders. We did this earlier.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write the code to extract the name of the winter month with the fewest
riders.</p></blockquote></blockquote><p>Here are two ways to write that computation:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">order-by(winter, "riders", true).row-n(0)["month"]</code></pre></div></div><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sorted = order-by(winter, "riders", true)
least-row = sorted.row-n(0)
least-row["month"]</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Which of these two ways do you prefer? Why?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How does each of these programs affect the program
directory?</p></blockquote></blockquote><p>Note that this problem asked us to combine several actions that weâ€™ve
already seen on rows: we identify rows from within a table
(<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>), order the rows (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">order-by</code></span>), extract a
specific row (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">row-n</code></span>), then extract a cell (with square brackets
and a column name). This is typical of how we will operate on tables,
combining multiple operations to compute a result (much as we did with
programs that manipulate images).</p>&#13;
<h5 class="heading">4.1.4.3<span class="stt">Â </span><a name="(part._.Adding_.New_.Columns)"/>Adding New Columns<span class="button-group"><a href="#(part._.Adding_.New_.Columns)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Sometimes, we want to create a new column whose value is based on
those of existing columns. For instance, our table might reflect
employee records, and have columns named <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">hourly-wage</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">hours-worked</code></span>, representing the corresponding quantities. We
would now like to extend this table with a new column to reflect each
employeeâ€™s total wage. Assume we started with the following table:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees =
  table: name,   hourly-wage, hours-worked
    row: "Harley",  15,          40
    row: "Obi",     20,          45
    row: "Anjali",  18,          39
    row: "Miyako",  18,          40
  end</code></pre></div></div></div><p/><div class="SIntrapara">The table we want to end up with is:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees =
  table: name, hourly-wage, hours-worked, total-wage
    row: "Harley", 15,         40,         15 * 40
    row: "Obi",    20, 	       45,         20 * 45
    row: "Anjali", 18, 	       39,         18 * 39
    row: "Miyako", 18, 	       40,         18 * 40
  end</code></pre></div></div></div><div class="SIntrapara">(with the expressions in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">total-wage</code></span> column computed to
their numeric equivalents: we used the expressions here to illustrate
what we are trying to do).</div><p>Previously, when we have had a computation that we performed multiple
times, we created a helper function to do the computation.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Propose a helper function for computing total wages given the hourly
wage and number of hours worked.</p></blockquote></blockquote><p>Perhaps you came up with something like:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun compute-wages(wage :: Number, hours :: Number) -&gt; Number:
  wage * hours
end</code></pre></div></div></div><div class="SIntrapara">which we could use as follows:</div><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees =
  table: name, hourly-wage, hours-worked, total-wage
    row: "Harley", 15, 40, compute-wages(15, 40)
    row: "Obi",    20, 45, compute-wages(20, 45)
    row: "Anjali", 18, 39, compute-wages(18, 39)
    row: "Miyako", 18, 40, compute-wages(18, 40)
  end</code></pre></div></div><p>This is the right idea, but we can actually have this function do a
bit more work for us. The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">wage</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">hours</code></span> values are in
cells within the same row. So if we could instead get the current row
as an input, we could write:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun compute-wages(r :: Row) -&gt; Number:
  r["hourly-wage"] * r["hours-worked"]
end

employees =
  table: name, hourly-wage, hours-worked, total-wage
    row: "Harley", 15, 40, compute-wages(&lt;row0&gt;)
    row: "Obi",    20, 45, compute-wages(&lt;row1&gt;)
    row: "Anjali", 18, 39, compute-wages(&lt;row2&gt;)
    row: "Miyako", 18, 40, compute-wages(&lt;row3&gt;)
  end</code></pre></div></div><p>But now, we are writing calls to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">compute-wages</code></span> over and over!
Adding computed columns is a sufficiently common operation that Pyret
provides a table function called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">build-column</code></span> for this
purpose. We use it by providing the function to use to populate values
in the new column as an input:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun compute-wages(r :: Row) -&gt; Number:
  doc: "compute total wages based on wage and hours worked"
  r["hourly-wage"] * r["hours-worked"]
end

build-column(employees, "total-wage", compute-wages)</code></pre></div></div></div><div class="SIntrapara">This creates a new column, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">total-wage</code></span>, whose value in each row
is the product of the two named columns in that row. Pyret will put
the new column at the right end.</div>&#13;
<h5 class="heading">4.1.4.4<span class="stt">Â </span><a name="(part._.Calculating_.New_.Column_.Values)"/>Calculating New Column Values<span class="button-group"><a href="#(part._.Calculating_.New_.Column_.Values)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Sometimes, we just want to calculate new values for an existing
column, rather than create an entirely new column. Giving raises to
employees is one such example. Assume we wanted to give a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">10%</code></span> raise to
all employees making less than <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">20</code></span> an hour. We could write:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun new-rate(rate :: Number) -&gt; Number:
  doc: "Raise rates under 20 by 10%"
  if rate &lt; 20:
    rate * 1.1
  else:
    rate
  end
where:
  new-rate(20) is 20
  new-rate(10) is 11
  new-rate(0) is 0
end

fun give-raises(t :: Table) -&gt; Table:
  doc: "Give a 10% raise to anyone making under 20"
  transform-column(t, "hourly-wage", new-rate)
end</code></pre></div></div></div><div class="SIntrapara">Here, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">transform-column</code></span> takes a table, the name of an existing
column in the table, and a function to update the value. The updating
function takes the current value in the column as input and produces
the new value for the column as output.</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Run <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">give-raises</code></span> on the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees</code></span> table. What wage will
show for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"Miyako"</code></span> in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees</code></span> table after
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">give-raises</code></span> completes. Why?</p></blockquote></blockquote><p>Like all other Pyret <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Table</code></span> operations, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">transform-column</code></span>
produces a new table, leaving the original intact. Editing the
original table could be problematicâ€“what if you made a mistake? How
would you recover the original table in that case? In general,
producing new tables with any modifications, then creating a new name
for the updated table once you have the one you want, is a less
error-prone way of working with datasets.</p>&#13;
<h4 class="heading">4.1.5<span class="stt">Â </span><a name="(part._.Examples_for_.Table-.Producing_.Functions)"/>Examples for Table-Producing Functions<span class="button-group"><a href="#(part._.Examples_for_.Table-.Producing_.Functions)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>How do we write examples for functions that produce tables? Conceptually,
the answer is simply "make sure you got the output table that you
expected". Logistically, writing examples for table functions seems
more painful because writing out an expected output tables is more
work than simply writing the output of a function that produces
numbers or strings. What can we do to manage that complexity?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How might you write the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where</code></span> block for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">give-raises</code></span>?</p></blockquote></blockquote><p>Here are some ideas for writing the examples practically:</p><ul><li><p><span class="emph">Simplify the input table</span>. Rather than work with a large
table with all of the columns you have, create a small table that has
sufficient variety only in the columns that the function uses. For our
example, we might use:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">wages-test =
  table: hourly-wage
    row: 15
    row: 20
    row: 18
    row: 18
  end</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Would any table with a column of numbers work here? Or are there some
constraints on the rows or columns of the table?</p></blockquote></blockquote><p>The only constraint is that your input table has to have the column
names used in your function.</p></li><li><p><span class="emph">Remember that you can write computations in the code to
construct tables</span>. This saves you from doing calculations by hand.</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where:
  give-raises(wages-test) is
  table: hourly-wage
    row: 15 * 1.1
    row: 20
    row: 18 * 1.1
    row: 18 * 1.1
  end</code></pre></div></div></div><div class="SIntrapara">This example shows that you can write an output table directly in the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where:</code></span> block â€“ the table doesnâ€™t need to be named outside the
function. </div></li><li><p><span class="emph">Create a new table by taking rows from an existing table</span>.
If you were instead writing examples for a function that involves filtering out rows
of a table, it helps to know how to create a new table using rows of
an existing one. For example, if we were writing a function to find
all rows in which employees were working exactly 40 hours, weâ€™d like
to make sure that the resulting table had the first and fourth rows of
the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees</code></span> table. Rather than write a new <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">table</code></span>
expression to create that table, we could write it as follows:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">emps-at-40 =
  add-row(
    add-row(employees.empty(),
      employees.row-n(0)),
    employees.row-n(3))</code></pre></div></div></div><div class="SIntrapara">Here, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees.empty()</code></span> creates a new, empty table with the
same column headers as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">employees</code></span>. Weâ€™ve already seen how
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">row-n</code></span> extracts a row from a table. The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">add-row</code></span> function
places the given row at the end of the given table.</div></li></ul><p>Another tip to keep in mind: when the only thing your function does is call
a built-in function like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">transform-column</code></span> it usually suffices
to write examples for the function you wrote to compute the new column
value. It is only when your code is combining table operations, or
doing more complex processing than a single call to a built-in table
operation that you really need to present your own examples to a
reader of your code.</p>&#13;
<h4 class="heading">4.1.6<span class="stt">Â </span><a name="(part._sec~3alambda-tables)"/>Lambda: Anonymous Functions<span class="button-group"><a href="#(part._sec~3alambda-tables)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Letâ€™s revisit the program we wrote in <a href="#%28part._subsec~3afinding-rows%29" data-pltdoc="x">Finding Rows</a> for
finding all of the months in a table with fewer than 1000 riders:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle = table: month, riders
  row: "Jan", 1123
  row: "Feb", 1045
  row: "Mar", 1087
  row: "Apr", 999
end
fun below-1K(r :: Row) -&gt; Boolean:
  doc: "determine whether row has fewer than 1000 riders"
  r["riders"] &lt; 1000
where:
  below-1K(shuttle.row-n(2)) is false
  below-1K(shuttle.row-n(3)) is true
end
filter-with(shuttle, below-1K)</code></pre></div></div><p>This program might feel a bit verbose: do we really need to write a
helper function just to perform something as simple as a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>? Wouldnâ€™t it be easier to just write something like:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with(shuttle, r["riders"] &lt; 1000)</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What will Pyret produce if you run this expression?</p></blockquote></blockquote><p>Pyret will produce an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">unbound identifier</code></span> error around the use
of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> in this expression. What is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span>? We mean for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span>
to be the elements from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle</code></span> in turn. Conceptually, thatâ€™s
what <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span> does, but we donâ€™t have the mechanics right. When
we call a function, we evaluate the arguments <span class="emph">before</span> the body
of the function. Hence, the error regarding <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> being unbound.
The whole point of the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">below-1K</code></span> helper function is to make
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> a parameter to a function whose body is only evaluated once
a value for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> is available.</p><p>To tighten the notation as in the one-line <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span> expression,
then, we have to find a way to tell Pyret to make a temporary function
that will get its inputs once <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span> is running. The following
notation achieves this:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with(shuttle, lam(r): r["riders"] &lt; 1000 end)</code></pre></div></div><p>We have added <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam(r)</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">end</code></span> around the expression that
we want to use in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>. The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam(r)</code></span> says "make a
temporary function that takes <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> as an input". The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">end</code></span>
serves to end the function definition, as when we use
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun</code></span>. <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span> is short for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lambda</code></span>, a form of function
definition that exists in many, though not all, languages.</p><p>The main difference between our original expression (using the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">below-1K</code></span> helper) and this new one (using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span>) can be
seen through the program directory. To explain this, a little detail
about how <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span> is defined under the hood. In part, it looks
like:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun filter-with(tbl :: Table, keep :: (Row -&gt; Boolean)) -&gt; Table:
  if keep(&lt;row-from-table&gt;):
    ...
  else:
    ...
  end
end</code></pre></div></div><p>Whether we pass <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">below-1K</code></span> or the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span> version to
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>, the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">keep</code></span> parameter ends up referring to a
function with the same parameter and body. Since the function is only
actually called through the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">keep</code></span> name, it doesnâ€™t matter
whether or not a name is associated with it when it is initially
defined.</p><p>In practice, we use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span> when we have to pass simple (single line)
functions to operations like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span> (or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">transform-column</code></span>,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">build-column</code></span>, etc). Of course, you can continue to write out names for
helper functions as we did with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">below-1K</code></span> if that makes more sense to
you.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write the program to add 10 riders to each row in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shuttle</code></span>
table above, using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span> rather than a named helper-function.</p></blockquote></blockquote>    
</body>
</html>