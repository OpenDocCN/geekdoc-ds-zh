["```py\n#print  Nat.Coprime\n\nexample  (m  n  :  Nat)  (h  :  m.Coprime  n)  :  m.gcd  n  =  1  :=\n  h\n\nexample  (m  n  :  Nat)  (h  :  m.Coprime  n)  :  m.gcd  n  =  1  :=  by\n  rw  [Nat.Coprime]  at  h\n  exact  h\n\nexample  :  Nat.Coprime  12  7  :=  by  norm_num\n\nexample  :  Nat.gcd  12  8  =  4  :=  by  norm_num \n```", "```py\n#check  Nat.prime_def_lt\n\nexample  (p  :  ℕ)  (prime_p  :  Nat.Prime  p)  :  2  ≤  p  ∧  ∀  m  :  ℕ,  m  <  p  →  m  ∣  p  →  m  =  1  :=  by\n  rwa  [Nat.prime_def_lt]  at  prime_p\n\n#check  Nat.Prime.eq_one_or_self_of_dvd\n\nexample  (p  :  ℕ)  (prime_p  :  Nat.Prime  p)  :  ∀  m  :  ℕ,  m  ∣  p  →  m  =  1  ∨  m  =  p  :=\n  prime_p.eq_one_or_self_of_dvd\n\nexample  :  Nat.Prime  17  :=  by  norm_num\n\n-- commonly used\nexample  :  Nat.Prime  2  :=\n  Nat.prime_two\n\nexample  :  Nat.Prime  3  :=\n  Nat.prime_three \n```", "```py\n#check  Nat.Prime.dvd_mul\n#check  Nat.Prime.dvd_mul  Nat.prime_two\n#check  Nat.prime_two.dvd_mul\n\ntheorem  even_of_even_sqr  {m  :  ℕ}  (h  :  2  ∣  m  ^  2)  :  2  ∣  m  :=  by\n  rw  [pow_two,  Nat.prime_two.dvd_mul]  at  h\n  cases  h  <;>  assumption\n\nexample  {m  :  ℕ}  (h  :  2  ∣  m  ^  2)  :  2  ∣  m  :=\n  Nat.Prime.dvd_of_dvd_pow  Nat.prime_two  h \n```", "```py\nexample  (a  b  c  :  Nat)  (h  :  a  *  b  =  a  *  c)  (h'  :  a  ≠  0)  :  b  =  c  :=\n  -- apply? suggests the following:\n  (mul_right_inj'  h').mp  h \n```", "```py\nexample  {m  n  :  ℕ}  (coprime_mn  :  m.Coprime  n)  :  m  ^  2  ≠  2  *  n  ^  2  :=  by\n  intro  sqr_eq\n  have  :  2  ∣  m  :=  by\n  sorry\n  obtain  ⟨k,  meq⟩  :=  dvd_iff_exists_eq_mul_left.mp  this\n  have  :  2  *  (2  *  k  ^  2)  =  2  *  n  ^  2  :=  by\n  rw  [←  sqr_eq,  meq]\n  ring\n  have  :  2  *  k  ^  2  =  n  ^  2  :=\n  sorry\n  have  :  2  ∣  n  :=  by\n  sorry\n  have  :  2  ∣  m.gcd  n  :=  by\n  sorry\n  have  :  2  ∣  1  :=  by\n  sorry\n  norm_num  at  this \n```", "```py\nexample  {m  n  p  :  ℕ}  (coprime_mn  :  m.Coprime  n)  (prime_p  :  p.Prime)  :  m  ^  2  ≠  p  *  n  ^  2  :=  by\n  sorry \n```", "```py\n#check  Nat.primeFactorsList\n#check  Nat.prime_of_mem_primeFactorsList\n#check  Nat.prod_primeFactorsList\n#check  Nat.primeFactorsList_unique \n```", "```py\ntheorem  factorization_mul'  {m  n  :  ℕ}  (mnez  :  m  ≠  0)  (nnez  :  n  ≠  0)  (p  :  ℕ)  :\n  (m  *  n).factorization  p  =  m.factorization  p  +  n.factorization  p  :=  by\n  rw  [Nat.factorization_mul  mnez  nnez]\n  rfl\n\ntheorem  factorization_pow'  (n  k  p  :  ℕ)  :\n  (n  ^  k).factorization  p  =  k  *  n.factorization  p  :=  by\n  rw  [Nat.factorization_pow]\n  rfl\n\ntheorem  Nat.Prime.factorization'  {p  :  ℕ}  (prime_p  :  p.Prime)  :\n  p.factorization  p  =  1  :=  by\n  rw  [prime_p.factorization]\n  simp \n```", "```py\nexample  {m  n  p  :  ℕ}  (nnz  :  n  ≠  0)  (prime_p  :  p.Prime)  :  m  ^  2  ≠  p  *  n  ^  2  :=  by\n  intro  sqr_eq\n  have  nsqr_nez  :  n  ^  2  ≠  0  :=  by  simpa\n  have  eq1  :  Nat.factorization  (m  ^  2)  p  =  2  *  m.factorization  p  :=  by\n  sorry\n  have  eq2  :  (p  *  n  ^  2).factorization  p  =  2  *  n.factorization  p  +  1  :=  by\n  sorry\n  have  :  2  *  m.factorization  p  %  2  =  (2  *  n.factorization  p  +  1)  %  2  :=  by\n  rw  [←  eq1,  sqr_eq,  eq2]\n  rw  [add_comm,  Nat.add_mul_mod_self_left,  Nat.mul_mod_right]  at  this\n  norm_num  at  this \n```", "```py\nexample  {m  n  k  r  :  ℕ}  (nnz  :  n  ≠  0)  (pow_eq  :  m  ^  k  =  r  *  n  ^  k)  {p  :  ℕ}  :\n  k  ∣  r.factorization  p  :=  by\n  rcases  r  with  _  |  r\n  ·  simp\n  have  npow_nz  :  n  ^  k  ≠  0  :=  fun  npowz  ↦  nnz  (pow_eq_zero  npowz)\n  have  eq1  :  (m  ^  k).factorization  p  =  k  *  m.factorization  p  :=  by\n  sorry\n  have  eq2  :  ((r  +  1)  *  n  ^  k).factorization  p  =\n  k  *  n.factorization  p  +  (r  +  1).factorization  p  :=  by\n  sorry\n  have  :  r.succ.factorization  p  =  k  *  m.factorization  p  -  k  *  n.factorization  p  :=  by\n  rw  [←  eq1,  pow_eq,  eq2,  add_comm,  Nat.add_sub_cancel]\n  rw  [this]\n  sorry \n```", "```py\ninductive  Nat  where\n  |  zero  :  Nat\n  |  succ  (n  :  Nat)  :  Nat \n```", "```py\nexample  (n  :  Nat)  :  n.succ  ≠  Nat.zero  :=\n  Nat.succ_ne_zero  n\n\nexample  (m  n  :  Nat)  (h  :  m.succ  =  n.succ)  :  m  =  n  :=\n  Nat.succ.inj  h \n```", "```py\ndef  fac  :  ℕ  →  ℕ\n  |  0  =>  1\n  |  n  +  1  =>  (n  +  1)  *  fac  n \n```", "```py\nexample  :  fac  0  =  1  :=\n  rfl\n\nexample  :  fac  0  =  1  :=  by\n  rw  [fac]\n\nexample  :  fac  0  =  1  :=  by\n  simp  [fac]\n\nexample  (n  :  ℕ)  :  fac  (n  +  1)  =  (n  +  1)  *  fac  n  :=\n  rfl\n\nexample  (n  :  ℕ)  :  fac  (n  +  1)  =  (n  +  1)  *  fac  n  :=  by\n  rw  [fac]\n\nexample  (n  :  ℕ)  :  fac  (n  +  1)  =  (n  +  1)  *  fac  n  :=  by\n  simp  [fac] \n```", "```py\ntheorem  fac_pos  (n  :  ℕ)  :  0  <  fac  n  :=  by\n  induction'  n  with  n  ih\n  ·  rw  [fac]\n  exact  zero_lt_one\n  rw  [fac]\n  exact  mul_pos  n.succ_pos  ih \n```", "```py\ntheorem  dvd_fac  {i  n  :  ℕ}  (ipos  :  0  <  i)  (ile  :  i  ≤  n)  :  i  ∣  fac  n  :=  by\n  induction'  n  with  n  ih\n  ·  exact  absurd  ipos  (not_lt_of_ge  ile)\n  rw  [fac]\n  rcases  Nat.of_le_succ  ile  with  h  |  h\n  ·  apply  dvd_mul_of_dvd_right  (ih  h)\n  rw  [h]\n  apply  dvd_mul_right \n```", "```py\ntheorem  pow_two_le_fac  (n  :  ℕ)  :  2  ^  (n  -  1)  ≤  fac  n  :=  by\n  rcases  n  with  _  |  n\n  ·  simp  [fac]\n  sorry \n```", "```py\nvariable  {α  :  Type*}  (s  :  Finset  ℕ)  (f  :  ℕ  →  ℕ)  (n  :  ℕ)\n\n#check  Finset.sum  s  f\n#check  Finset.prod  s  f\n\nopen  BigOperators\nopen  Finset\n\nexample  :  s.sum  f  =  ∑  x  ∈  s,  f  x  :=\n  rfl\n\nexample  :  s.prod  f  =  ∏  x  ∈  s,  f  x  :=\n  rfl\n\nexample  :  (range  n).sum  f  =  ∑  x  ∈  range  n,  f  x  :=\n  rfl\n\nexample  :  (range  n).prod  f  =  ∏  x  ∈  range  n,  f  x  :=\n  rfl \n```", "```py\nexample  (f  :  ℕ  →  ℕ)  :  ∑  x  ∈  range  0,  f  x  =  0  :=\n  Finset.sum_range_zero  f\n\nexample  (f  :  ℕ  →  ℕ)  (n  :  ℕ)  :  ∑  x  ∈  range  n.succ,  f  x  =  ∑  x  ∈  range  n,  f  x  +  f  n  :=\n  Finset.sum_range_succ  f  n\n\nexample  (f  :  ℕ  →  ℕ)  :  ∏  x  ∈  range  0,  f  x  =  1  :=\n  Finset.prod_range_zero  f\n\nexample  (f  :  ℕ  →  ℕ)  (n  :  ℕ)  :  ∏  x  ∈  range  n.succ,  f  x  =  (∏  x  ∈  range  n,  f  x)  *  f  n  :=\n  Finset.prod_range_succ  f  n \n```", "```py\nexample  (n  :  ℕ)  :  fac  n  =  ∏  i  ∈  range  n,  (i  +  1)  :=  by\n  induction'  n  with  n  ih\n  ·  simp  [fac,  prod_range_zero]\n  simp  [fac,  ih,  prod_range_succ,  mul_comm] \n```", "```py\nexample  (a  b  c  d  e  f  :  ℕ)  :  a  *  (b  *  c  *  f  *  (d  *  e))  =  d  *  (a  *  f  *  e)  *  (c  *  b)  :=  by\n  simp  [mul_assoc,  mul_comm,  mul_left_comm] \n```", "```py\ntheorem  sum_id  (n  :  ℕ)  :  ∑  i  ∈  range  (n  +  1),  i  =  n  *  (n  +  1)  /  2  :=  by\n  symm;  apply  Nat.div_eq_of_eq_mul_right  (by  norm_num  :  0  <  2)\n  induction'  n  with  n  ih\n  ·  simp\n  rw  [Finset.sum_range_succ,  mul_add  2,  ←  ih]\n  ring \n```", "```py\ntheorem  sum_sqr  (n  :  ℕ)  :  ∑  i  ∈  range  (n  +  1),  i  ^  2  =  n  *  (n  +  1)  *  (2  *  n  +  1)  /  6  :=  by\n  sorry \n```", "```py\ninductive  MyNat  where\n  |  zero  :  MyNat\n  |  succ  :  MyNat  →  MyNat\n\nnamespace  MyNat\n\ndef  add  :  MyNat  →  MyNat  →  MyNat\n  |  x,  zero  =>  x\n  |  x,  succ  y  =>  succ  (add  x  y)\n\ndef  mul  :  MyNat  →  MyNat  →  MyNat\n  |  x,  zero  =>  zero\n  |  x,  succ  y  =>  add  (mul  x  y)  x\n\ntheorem  zero_add  (n  :  MyNat)  :  add  zero  n  =  n  :=  by\n  induction'  n  with  n  ih\n  ·  rfl\n  rw  [add,  ih]\n\ntheorem  succ_add  (m  n  :  MyNat)  :  add  (succ  m)  n  =  succ  (add  m  n)  :=  by\n  induction'  n  with  n  ih\n  ·  rfl\n  rw  [add,  ih]\n  rfl\n\ntheorem  add_comm  (m  n  :  MyNat)  :  add  m  n  =  add  n  m  :=  by\n  induction'  n  with  n  ih\n  ·  rw  [zero_add]\n  rfl\n  rw  [add,  succ_add,  ih]\n\ntheorem  add_assoc  (m  n  k  :  MyNat)  :  add  (add  m  n)  k  =  add  m  (add  n  k)  :=  by\n  sorry\ntheorem  mul_add  (m  n  k  :  MyNat)  :  mul  m  (add  n  k)  =  add  (mul  m  n)  (mul  m  k)  :=  by\n  sorry\ntheorem  zero_mul  (n  :  MyNat)  :  mul  zero  n  =  zero  :=  by\n  sorry\ntheorem  succ_mul  (m  n  :  MyNat)  :  mul  (succ  m)  n  =  add  (mul  m  n)  n  :=  by\n  sorry\ntheorem  mul_comm  (m  n  :  MyNat)  :  mul  m  n  =  mul  n  m  :=  by\n  sorry\nend  MyNat \n```", "```py\ntheorem  two_le  {m  :  ℕ}  (h0  :  m  ≠  0)  (h1  :  m  ≠  1)  :  2  ≤  m  :=  by\n  cases  m;  contradiction\n  case  succ  m  =>\n  cases  m;  contradiction\n  repeat  apply  Nat.succ_le_succ\n  apply  zero_le \n```", "```py\nexample  {m  :  ℕ}  (h0  :  m  ≠  0)  (h1  :  m  ≠  1)  :  2  ≤  m  :=  by\n  by_contra  h\n  push_neg  at  h\n  interval_cases  m  <;>  contradiction \n```", "```py\nexample  {m  :  ℕ}  (h0  :  m  ≠  0)  (h1  :  m  ≠  1)  :  2  ≤  m  :=  by\n  by_contra  h\n  push_neg  at  h\n  revert  h0  h1\n  revert  h  m\n  decide \n```", "```py\ntheorem  exists_prime_factor  {n  :  Nat}  (h  :  2  ≤  n)  :  ∃  p  :  Nat,  p.Prime  ∧  p  ∣  n  :=  by\n  by_cases  np  :  n.Prime\n  ·  use  n,  np\n  induction'  n  using  Nat.strong_induction_on  with  n  ih\n  rw  [Nat.prime_def_lt]  at  np\n  push_neg  at  np\n  rcases  np  h  with  ⟨m,  mltn,  mdvdn,  mne1⟩\n  have  :  m  ≠  0  :=  by\n  intro  mz\n  rw  [mz,  zero_dvd_iff]  at  mdvdn\n  linarith\n  have  mgt2  :  2  ≤  m  :=  two_le  this  mne1\n  by_cases  mp  :  m.Prime\n  ·  use  m,  mp\n  ·  rcases  ih  m  mltn  mgt2  mp  with  ⟨p,  pp,  pdvd⟩\n  use  p,  pp\n  apply  pdvd.trans  mdvdn \n```", "```py\ntheorem  primes_infinite  :  ∀  n,  ∃  p  >  n,  Nat.Prime  p  :=  by\n  intro  n\n  have  :  2  ≤  Nat.factorial  n  +  1  :=  by\n  sorry\n  rcases  exists_prime_factor  this  with  ⟨p,  pp,  pdvd⟩\n  refine  ⟨p,  ?_,  pp⟩\n  show  p  >  n\n  by_contra  ple\n  push_neg  at  ple\n  have  :  p  ∣  Nat.factorial  n  :=  by\n  sorry\n  have  :  p  ∣  1  :=  by\n  sorry\n  show  False\n  sorry \n```", "```py\nopen  Finset\n\nsection\nvariable  {α  :  Type*}  [DecidableEq  α]  (r  s  t  :  Finset  α)\n\nexample  :  r  ∩  (s  ∪  t)  ⊆  r  ∩  s  ∪  r  ∩  t  :=  by\n  rw  [subset_iff]\n  intro  x\n  rw  [mem_inter,  mem_union,  mem_union,  mem_inter,  mem_inter]\n  tauto\n\nexample  :  r  ∩  (s  ∪  t)  ⊆  r  ∩  s  ∪  r  ∩  t  :=  by\n  simp  [subset_iff]\n  intro  x\n  tauto\n\nexample  :  r  ∩  s  ∪  r  ∩  t  ⊆  r  ∩  (s  ∪  t)  :=  by\n  simp  [subset_iff]\n  intro  x\n  tauto\n\nexample  :  r  ∩  s  ∪  r  ∩  t  =  r  ∩  (s  ∪  t)  :=  by\n  ext  x\n  simp\n  tauto\n\nend \n```", "```py\nexample  :  (r  ∪  s)  ∩  (r  ∪  t)  =  r  ∪  s  ∩  t  :=  by\n  sorry\nexample  :  (r  \\  s)  \\  t  =  r  \\  (s  ∪  t)  :=  by\n  sorry \n```", "```py\nexample  (s  :  Finset  ℕ)  (n  :  ℕ)  (h  :  n  ∈  s)  :  n  ∣  ∏  i  ∈  s,  i  :=\n  Finset.dvd_prod_of_mem  _  h \n```", "```py\ntheorem  _root_.Nat.Prime.eq_of_dvd_of_prime  {p  q  :  ℕ}\n  (prime_p  :  Nat.Prime  p)  (prime_q  :  Nat.Prime  q)  (h  :  p  ∣  q)  :\n  p  =  q  :=  by\n  sorry \n```", "```py\ntheorem  mem_of_dvd_prod_primes  {s  :  Finset  ℕ}  {p  :  ℕ}  (prime_p  :  p.Prime)  :\n  (∀  n  ∈  s,  Nat.Prime  n)  →  (p  ∣  ∏  n  ∈  s,  n)  →  p  ∈  s  :=  by\n  intro  h₀  h₁\n  induction'  s  using  Finset.induction_on  with  a  s  ans  ih\n  ·  simp  at  h₁\n  linarith  [prime_p.two_le]\n  simp  [Finset.prod_insert  ans,  prime_p.dvd_mul]  at  h₀  h₁\n  rw  [mem_insert]\n  sorry \n```", "```py\nexample  (s  :  Finset  ℕ)  (x  :  ℕ)  :  x  ∈  s.filter  Nat.Prime  ↔  x  ∈  s  ∧  x.Prime  :=\n  mem_filter \n```", "```py\ntheorem  primes_infinite'  :  ∀  s  :  Finset  Nat,  ∃  p,  Nat.Prime  p  ∧  p  ∉  s  :=  by\n  intro  s\n  by_contra  h\n  push_neg  at  h\n  set  s'  :=  s.filter  Nat.Prime  with  s'_def\n  have  mem_s'  :  ∀  {n  :  ℕ},  n  ∈  s'  ↔  n.Prime  :=  by\n  intro  n\n  simp  [s'_def]\n  apply  h\n  have  :  2  ≤  (∏  i  ∈  s',  i)  +  1  :=  by\n  sorry\n  rcases  exists_prime_factor  this  with  ⟨p,  pp,  pdvd⟩\n  have  :  p  ∣  ∏  i  ∈  s',  i  :=  by\n  sorry\n  have  :  p  ∣  1  :=  by\n  convert  Nat.dvd_sub  pdvd  this\n  simp\n  show  False\n  sorry \n```", "```py\ntheorem  bounded_of_ex_finset  (Q  :  ℕ  →  Prop)  :\n  (∃  s  :  Finset  ℕ,  ∀  k,  Q  k  →  k  ∈  s)  →  ∃  n,  ∀  k,  Q  k  →  k  <  n  :=  by\n  rintro  ⟨s,  hs⟩\n  use  s.sup  id  +  1\n  intro  k  Qk\n  apply  Nat.lt_succ_of_le\n  show  id  k  ≤  s.sup  id\n  apply  le_sup  (hs  k  Qk)\n\ntheorem  ex_finset_of_bounded  (Q  :  ℕ  →  Prop)  [DecidablePred  Q]  :\n  (∃  n,  ∀  k,  Q  k  →  k  ≤  n)  →  ∃  s  :  Finset  ℕ,  ∀  k,  Q  k  ↔  k  ∈  s  :=  by\n  rintro  ⟨n,  hn⟩\n  use  (range  (n  +  1)).filter  Q\n  intro  k\n  simp  [Nat.lt_succ_iff]\n  exact  hn  k \n```", "```py\nexample  :  27  %  4  =  3  :=  by  norm_num \n```", "```py\nexample  (n  :  ℕ)  :  (4  *  n  +  3)  %  4  =  3  :=  by\n  rw  [add_comm,  Nat.add_mul_mod_self_left]\n\ntheorem  mod_4_eq_3_or_mod_4_eq_3  {m  n  :  ℕ}  (h  :  m  *  n  %  4  =  3)  :  m  %  4  =  3  ∨  n  %  4  =  3  :=  by\n  revert  h\n  rw  [Nat.mul_mod]\n  have  :  m  %  4  <  4  :=  Nat.mod_lt  m  (by  norm_num)\n  interval_cases  m  %  4  <;>  simp  [-Nat.mul_mod_mod]\n  have  :  n  %  4  <  4  :=  Nat.mod_lt  n  (by  norm_num)\n  interval_cases  n  %  4  <;>  simp\n\ntheorem  two_le_of_mod_4_eq_3  {n  :  ℕ}  (h  :  n  %  4  =  3)  :  2  ≤  n  :=  by\n  apply  two_le  <;>\n  ·  intro  neq\n  rw  [neq]  at  h\n  norm_num  at  h \n```", "```py\ntheorem  aux  {m  n  :  ℕ}  (h₀  :  m  ∣  n)  (h₁  :  2  ≤  m)  (h₂  :  m  <  n)  :  n  /  m  ∣  n  ∧  n  /  m  <  n  :=  by\n  sorry \n```", "```py\ntheorem  exists_prime_factor_mod_4_eq_3  {n  :  Nat}  (h  :  n  %  4  =  3)  :\n  ∃  p  :  Nat,  p.Prime  ∧  p  ∣  n  ∧  p  %  4  =  3  :=  by\n  by_cases  np  :  n.Prime\n  ·  use  n\n  induction'  n  using  Nat.strong_induction_on  with  n  ih\n  rw  [Nat.prime_def_lt]  at  np\n  push_neg  at  np\n  rcases  np  (two_le_of_mod_4_eq_3  h)  with  ⟨m,  mltn,  mdvdn,  mne1⟩\n  have  mge2  :  2  ≤  m  :=  by\n  apply  two_le  _  mne1\n  intro  mz\n  rw  [mz,  zero_dvd_iff]  at  mdvdn\n  linarith\n  have  neq  :  m  *  (n  /  m)  =  n  :=  Nat.mul_div_cancel'  mdvdn\n  have  :  m  %  4  =  3  ∨  n  /  m  %  4  =  3  :=  by\n  apply  mod_4_eq_3_or_mod_4_eq_3\n  rw  [neq,  h]\n  rcases  this  with  h1  |  h1\n  .  sorry\n  .  sorry \n```", "```py\nexample  (m  n  :  ℕ)  (s  :  Finset  ℕ)  (h  :  m  ∈  erase  s  n)  :  m  ≠  n  ∧  m  ∈  s  :=  by\n  rwa  [mem_erase]  at  h\n\nexample  (m  n  :  ℕ)  (s  :  Finset  ℕ)  (h  :  m  ∈  erase  s  n)  :  m  ≠  n  ∧  m  ∈  s  :=  by\n  simp  at  h\n  assumption \n```", "```py\ntheorem  primes_mod_4_eq_3_infinite  :  ∀  n,  ∃  p  >  n,  Nat.Prime  p  ∧  p  %  4  =  3  :=  by\n  by_contra  h\n  push_neg  at  h\n  rcases  h  with  ⟨n,  hn⟩\n  have  :  ∃  s  :  Finset  Nat,  ∀  p  :  ℕ,  p.Prime  ∧  p  %  4  =  3  ↔  p  ∈  s  :=  by\n  apply  ex_finset_of_bounded\n  use  n\n  contrapose!  hn\n  rcases  hn  with  ⟨p,  ⟨pp,  p4⟩,  pltn⟩\n  exact  ⟨p,  pltn,  pp,  p4⟩\n  rcases  this  with  ⟨s,  hs⟩\n  have  h₁  :  ((4  *  ∏  i  ∈  erase  s  3,  i)  +  3)  %  4  =  3  :=  by\n  sorry\n  rcases  exists_prime_factor_mod_4_eq_3  h₁  with  ⟨p,  pp,  pdvd,  p4eq⟩\n  have  ps  :  p  ∈  s  :=  by\n  sorry\n  have  pne3  :  p  ≠  3  :=  by\n  sorry\n  have  :  p  ∣  4  *  ∏  i  ∈  erase  s  3,  i  :=  by\n  sorry\n  have  :  p  ∣  3  :=  by\n  sorry\n  have  :  p  =  3  :=  by\n  sorry\n  contradiction \n```", "```py\ndef  fac  :  ℕ  →  ℕ\n  |  0  =>  1\n  |  n  +  1  =>  (n  +  1)  *  fac  n \n```", "```py\ntheorem  fac_pos  (n  :  ℕ)  :  0  <  fac  n  :=  by\n  induction'  n  with  n  ih\n  ·  rw  [fac]\n  exact  zero_lt_one\n  rw  [fac]\n  exact  mul_pos  n.succ_pos  ih \n```", "```py\nexample  (n  :  ℕ)  :  0  <  fac  n  :=  by\n  induction  n\n  case  zero  =>\n  rw  [fac]\n  exact  zero_lt_one\n  case  succ  n  ih  =>\n  rw  [fac]\n  exact  mul_pos  n.succ_pos  ih\n\nexample  (n  :  ℕ)  :  0  <  fac  n  :=  by\n  induction  n  with\n  |  zero  =>\n  rw  [fac]\n  exact  zero_lt_one\n  |  succ  n  ih  =>\n  rw  [fac]\n  exact  mul_pos  n.succ_pos  ih \n```", "```py\ntheorem  fac_pos'  :  ∀  n,  0  <  fac  n\n  |  0  =>  by\n  rw  [fac]\n  exact  zero_lt_one\n  |  n  +  1  =>  by\n  rw  [fac]\n  exact  mul_pos  n.succ_pos  (fac_pos'  n) \n```", "```py\n@[simp]  def  fib  :  ℕ  →  ℕ\n  |  0  =>  0\n  |  1  =>  1\n  |  n  +  2  =>  fib  n  +  fib  (n  +  1) \n```", "```py\ntheorem  fib_add_two  (n  :  ℕ)  :  fib  (n  +  2)  =  fib  n  +  fib  (n  +  1)  :=  rfl\n\nexample  (n  :  ℕ)  :  fib  (n  +  2)  =  fib  n  +  fib  (n  +  1)  :=  by  rw  [fib] \n```", "```py\nnoncomputable  section\n\ndef  phi  :  ℝ  :=  (1  +  √5)  /  2\ndef  phi'  :  ℝ  :=  (1  -  √5)  /  2\n\ntheorem  phi_sq  :  phi^2  =  phi  +  1  :=  by\n  field_simp  [phi,  add_sq];  ring\n\ntheorem  phi'_sq  :  phi'^2  =  phi'  +  1  :=  by\n  field_simp  [phi',  sub_sq];  ring\n\ntheorem  fib_eq  :  ∀  n,  fib  n  =  (phi^n  -  phi'^n)  /  √5\n  |  0  =>  by  simp\n  |  1  =>  by  field_simp  [phi,  phi']\n  |  n+2  =>  by  field_simp  [fib_eq,  pow_add,  phi_sq,  phi'_sq];  ring\n\nend \n```", "```py\ntheorem  fib_coprime_fib_succ  (n  :  ℕ)  :  Nat.Coprime  (fib  n)  (fib  (n  +  1))  :=  by\n  induction  n  with\n  |  zero  =>  simp\n  |  succ  n  ih  =>\n  simp  only  [fib,  Nat.coprime_add_self_right]\n  exact  ih.symm \n```", "```py\n#eval  fib  6\n#eval  List.range  20  |>.map  fib \n```", "```py\ndef  fib'  (n  :  Nat)  :  Nat  :=\n  aux  n  0  1\nwhere  aux\n  |  0,  x,  _  =>  x\n  |  n+1,  x,  y  =>  aux  n  y  (x  +  y)\n\ntheorem  fib'.aux_eq  (m  n  :  ℕ)  :  fib'.aux  n  (fib  m)  (fib  (m  +  1))  =  fib  (n  +  m)  :=  by\n  induction  n  generalizing  m  with\n  |  zero  =>  simp  [fib'.aux]\n  |  succ  n  ih  =>  rw  [fib'.aux,  ←fib_add_two,  ih,  add_assoc,  add_comm  1]\n\ntheorem  fib'_eq_fib  :  fib'  =  fib  :=  by\n  ext  n\n  erw  [fib',  fib'.aux_eq  0  n];  rfl\n\n#eval  fib'  10000 \n```", "```py\ntheorem  fib_add  (m  n  :  ℕ)  :  fib  (m  +  n  +  1)  =  fib  m  *  fib  n  +  fib  (m  +  1)  *  fib  (n  +  1)  :=  by\n  induction  n  generalizing  m  with\n  |  zero  =>  simp\n  |  succ  n  ih  =>\n  specialize  ih  (m  +  1)\n  rw  [add_assoc  m  1  n,  add_comm  1  n]  at  ih\n  simp  only  [fib_add_two,  Nat.succ_eq_add_one,  ih]\n  ring\n\ntheorem  fib_add'  :  ∀  m  n,  fib  (m  +  n  +  1)  =  fib  m  *  fib  n  +  fib  (m  +  1)  *  fib  (n  +  1)\n  |  _,  0  =>  by  simp\n  |  m,  n  +  1  =>  by\n  have  :=  fib_add'  (m  +  1)  n\n  rw  [add_assoc  m  1  n,  add_comm  1  n]  at  this\n  simp  only  [fib_add_two,  Nat.succ_eq_add_one,  this]\n  ring \n```", "```py\nexample  (n  :  ℕ):  (fib  n)  ^  2  +  (fib  (n  +  1))  ^  2  =  fib  (2  *  n  +  1)  :=  by  sorry \n```", "```py\n#check  (@Nat.not_prime_iff_exists_dvd_lt  :\n  ∀  {n  :  ℕ},  2  ≤  n  →  (¬Nat.Prime  n  ↔  ∃  m,  m  ∣  n  ∧  2  ≤  m  ∧  m  <  n))\n\ntheorem  ne_one_iff_exists_prime_dvd  :  ∀  {n},  n  ≠  1  ↔  ∃  p  :  ℕ,  p.Prime  ∧  p  ∣  n\n  |  0  =>  by  simpa  using  Exists.intro  2  Nat.prime_two\n  |  1  =>  by  simp  [Nat.not_prime_one]\n  |  n  +  2  =>  by\n  have  hn  :  n+2  ≠  1  :=  by  omega\n  simp  only  [Ne,  not_false_iff,  true_iff,  hn]\n  by_cases  h  :  Nat.Prime  (n  +  2)\n  ·  use  n+2,  h\n  ·  have  :  2  ≤  n  +  2  :=  by  omega\n  rw  [Nat.not_prime_iff_exists_dvd_lt  this]  at  h\n  rcases  h  with  ⟨m,  mdvdn,  mge2,  -⟩\n  have  :  m  ≠  1  :=  by  omega\n  rw  [ne_one_iff_exists_prime_dvd]  at  this\n  rcases  this  with  ⟨p,  primep,  pdvdm⟩\n  use  p,  primep\n  exact  pdvdm.trans  mdvdn \n```", "```py\ntheorem  zero_lt_of_mul_eq_one  (m  n  :  ℕ)  :  n  *  m  =  1  →  0  <  n  ∧  0  <  m  :=  by\n  cases  n  <;>  cases  m  <;>  simp\n\nexample  (m  n  :  ℕ)  :  n*m  =  1  →  0  <  n  ∧  0  <  m  :=  by\n  rcases  m  with  (_  |  m);  simp\n  rcases  n  with  (_  |  n)  <;>  simp \n```", "```py\n#print  Nat.Coprime\n\nexample  (m  n  :  Nat)  (h  :  m.Coprime  n)  :  m.gcd  n  =  1  :=\n  h\n\nexample  (m  n  :  Nat)  (h  :  m.Coprime  n)  :  m.gcd  n  =  1  :=  by\n  rw  [Nat.Coprime]  at  h\n  exact  h\n\nexample  :  Nat.Coprime  12  7  :=  by  norm_num\n\nexample  :  Nat.gcd  12  8  =  4  :=  by  norm_num \n```", "```py\n#check  Nat.prime_def_lt\n\nexample  (p  :  ℕ)  (prime_p  :  Nat.Prime  p)  :  2  ≤  p  ∧  ∀  m  :  ℕ,  m  <  p  →  m  ∣  p  →  m  =  1  :=  by\n  rwa  [Nat.prime_def_lt]  at  prime_p\n\n#check  Nat.Prime.eq_one_or_self_of_dvd\n\nexample  (p  :  ℕ)  (prime_p  :  Nat.Prime  p)  :  ∀  m  :  ℕ,  m  ∣  p  →  m  =  1  ∨  m  =  p  :=\n  prime_p.eq_one_or_self_of_dvd\n\nexample  :  Nat.Prime  17  :=  by  norm_num\n\n-- commonly used\nexample  :  Nat.Prime  2  :=\n  Nat.prime_two\n\nexample  :  Nat.Prime  3  :=\n  Nat.prime_three \n```", "```py\n#check  Nat.Prime.dvd_mul\n#check  Nat.Prime.dvd_mul  Nat.prime_two\n#check  Nat.prime_two.dvd_mul\n\ntheorem  even_of_even_sqr  {m  :  ℕ}  (h  :  2  ∣  m  ^  2)  :  2  ∣  m  :=  by\n  rw  [pow_two,  Nat.prime_two.dvd_mul]  at  h\n  cases  h  <;>  assumption\n\nexample  {m  :  ℕ}  (h  :  2  ∣  m  ^  2)  :  2  ∣  m  :=\n  Nat.Prime.dvd_of_dvd_pow  Nat.prime_two  h \n```", "```py\nexample  (a  b  c  :  Nat)  (h  :  a  *  b  =  a  *  c)  (h'  :  a  ≠  0)  :  b  =  c  :=\n  -- apply? suggests the following:\n  (mul_right_inj'  h').mp  h \n```", "```py\nexample  {m  n  :  ℕ}  (coprime_mn  :  m.Coprime  n)  :  m  ^  2  ≠  2  *  n  ^  2  :=  by\n  intro  sqr_eq\n  have  :  2  ∣  m  :=  by\n  sorry\n  obtain  ⟨k,  meq⟩  :=  dvd_iff_exists_eq_mul_left.mp  this\n  have  :  2  *  (2  *  k  ^  2)  =  2  *  n  ^  2  :=  by\n  rw  [←  sqr_eq,  meq]\n  ring\n  have  :  2  *  k  ^  2  =  n  ^  2  :=\n  sorry\n  have  :  2  ∣  n  :=  by\n  sorry\n  have  :  2  ∣  m.gcd  n  :=  by\n  sorry\n  have  :  2  ∣  1  :=  by\n  sorry\n  norm_num  at  this \n```", "```py\nexample  {m  n  p  :  ℕ}  (coprime_mn  :  m.Coprime  n)  (prime_p  :  p.Prime)  :  m  ^  2  ≠  p  *  n  ^  2  :=  by\n  sorry \n```", "```py\n#check  Nat.primeFactorsList\n#check  Nat.prime_of_mem_primeFactorsList\n#check  Nat.prod_primeFactorsList\n#check  Nat.primeFactorsList_unique \n```", "```py\ntheorem  factorization_mul'  {m  n  :  ℕ}  (mnez  :  m  ≠  0)  (nnez  :  n  ≠  0)  (p  :  ℕ)  :\n  (m  *  n).factorization  p  =  m.factorization  p  +  n.factorization  p  :=  by\n  rw  [Nat.factorization_mul  mnez  nnez]\n  rfl\n\ntheorem  factorization_pow'  (n  k  p  :  ℕ)  :\n  (n  ^  k).factorization  p  =  k  *  n.factorization  p  :=  by\n  rw  [Nat.factorization_pow]\n  rfl\n\ntheorem  Nat.Prime.factorization'  {p  :  ℕ}  (prime_p  :  p.Prime)  :\n  p.factorization  p  =  1  :=  by\n  rw  [prime_p.factorization]\n  simp \n```", "```py\nexample  {m  n  p  :  ℕ}  (nnz  :  n  ≠  0)  (prime_p  :  p.Prime)  :  m  ^  2  ≠  p  *  n  ^  2  :=  by\n  intro  sqr_eq\n  have  nsqr_nez  :  n  ^  2  ≠  0  :=  by  simpa\n  have  eq1  :  Nat.factorization  (m  ^  2)  p  =  2  *  m.factorization  p  :=  by\n  sorry\n  have  eq2  :  (p  *  n  ^  2).factorization  p  =  2  *  n.factorization  p  +  1  :=  by\n  sorry\n  have  :  2  *  m.factorization  p  %  2  =  (2  *  n.factorization  p  +  1)  %  2  :=  by\n  rw  [←  eq1,  sqr_eq,  eq2]\n  rw  [add_comm,  Nat.add_mul_mod_self_left,  Nat.mul_mod_right]  at  this\n  norm_num  at  this \n```", "```py\nexample  {m  n  k  r  :  ℕ}  (nnz  :  n  ≠  0)  (pow_eq  :  m  ^  k  =  r  *  n  ^  k)  {p  :  ℕ}  :\n  k  ∣  r.factorization  p  :=  by\n  rcases  r  with  _  |  r\n  ·  simp\n  have  npow_nz  :  n  ^  k  ≠  0  :=  fun  npowz  ↦  nnz  (pow_eq_zero  npowz)\n  have  eq1  :  (m  ^  k).factorization  p  =  k  *  m.factorization  p  :=  by\n  sorry\n  have  eq2  :  ((r  +  1)  *  n  ^  k).factorization  p  =\n  k  *  n.factorization  p  +  (r  +  1).factorization  p  :=  by\n  sorry\n  have  :  r.succ.factorization  p  =  k  *  m.factorization  p  -  k  *  n.factorization  p  :=  by\n  rw  [←  eq1,  pow_eq,  eq2,  add_comm,  Nat.add_sub_cancel]\n  rw  [this]\n  sorry \n```", "```py\ninductive  Nat  where\n  |  zero  :  Nat\n  |  succ  (n  :  Nat)  :  Nat \n```", "```py\nexample  (n  :  Nat)  :  n.succ  ≠  Nat.zero  :=\n  Nat.succ_ne_zero  n\n\nexample  (m  n  :  Nat)  (h  :  m.succ  =  n.succ)  :  m  =  n  :=\n  Nat.succ.inj  h \n```", "```py\ndef  fac  :  ℕ  →  ℕ\n  |  0  =>  1\n  |  n  +  1  =>  (n  +  1)  *  fac  n \n```", "```py\nexample  :  fac  0  =  1  :=\n  rfl\n\nexample  :  fac  0  =  1  :=  by\n  rw  [fac]\n\nexample  :  fac  0  =  1  :=  by\n  simp  [fac]\n\nexample  (n  :  ℕ)  :  fac  (n  +  1)  =  (n  +  1)  *  fac  n  :=\n  rfl\n\nexample  (n  :  ℕ)  :  fac  (n  +  1)  =  (n  +  1)  *  fac  n  :=  by\n  rw  [fac]\n\nexample  (n  :  ℕ)  :  fac  (n  +  1)  =  (n  +  1)  *  fac  n  :=  by\n  simp  [fac] \n```", "```py\ntheorem  fac_pos  (n  :  ℕ)  :  0  <  fac  n  :=  by\n  induction'  n  with  n  ih\n  ·  rw  [fac]\n  exact  zero_lt_one\n  rw  [fac]\n  exact  mul_pos  n.succ_pos  ih \n```", "```py\ntheorem  dvd_fac  {i  n  :  ℕ}  (ipos  :  0  <  i)  (ile  :  i  ≤  n)  :  i  ∣  fac  n  :=  by\n  induction'  n  with  n  ih\n  ·  exact  absurd  ipos  (not_lt_of_ge  ile)\n  rw  [fac]\n  rcases  Nat.of_le_succ  ile  with  h  |  h\n  ·  apply  dvd_mul_of_dvd_right  (ih  h)\n  rw  [h]\n  apply  dvd_mul_right \n```", "```py\ntheorem  pow_two_le_fac  (n  :  ℕ)  :  2  ^  (n  -  1)  ≤  fac  n  :=  by\n  rcases  n  with  _  |  n\n  ·  simp  [fac]\n  sorry \n```", "```py\nvariable  {α  :  Type*}  (s  :  Finset  ℕ)  (f  :  ℕ  →  ℕ)  (n  :  ℕ)\n\n#check  Finset.sum  s  f\n#check  Finset.prod  s  f\n\nopen  BigOperators\nopen  Finset\n\nexample  :  s.sum  f  =  ∑  x  ∈  s,  f  x  :=\n  rfl\n\nexample  :  s.prod  f  =  ∏  x  ∈  s,  f  x  :=\n  rfl\n\nexample  :  (range  n).sum  f  =  ∑  x  ∈  range  n,  f  x  :=\n  rfl\n\nexample  :  (range  n).prod  f  =  ∏  x  ∈  range  n,  f  x  :=\n  rfl \n```", "```py\nexample  (f  :  ℕ  →  ℕ)  :  ∑  x  ∈  range  0,  f  x  =  0  :=\n  Finset.sum_range_zero  f\n\nexample  (f  :  ℕ  →  ℕ)  (n  :  ℕ)  :  ∑  x  ∈  range  n.succ,  f  x  =  ∑  x  ∈  range  n,  f  x  +  f  n  :=\n  Finset.sum_range_succ  f  n\n\nexample  (f  :  ℕ  →  ℕ)  :  ∏  x  ∈  range  0,  f  x  =  1  :=\n  Finset.prod_range_zero  f\n\nexample  (f  :  ℕ  →  ℕ)  (n  :  ℕ)  :  ∏  x  ∈  range  n.succ,  f  x  =  (∏  x  ∈  range  n,  f  x)  *  f  n  :=\n  Finset.prod_range_succ  f  n \n```", "```py\nexample  (n  :  ℕ)  :  fac  n  =  ∏  i  ∈  range  n,  (i  +  1)  :=  by\n  induction'  n  with  n  ih\n  ·  simp  [fac,  prod_range_zero]\n  simp  [fac,  ih,  prod_range_succ,  mul_comm] \n```", "```py\nexample  (a  b  c  d  e  f  :  ℕ)  :  a  *  (b  *  c  *  f  *  (d  *  e))  =  d  *  (a  *  f  *  e)  *  (c  *  b)  :=  by\n  simp  [mul_assoc,  mul_comm,  mul_left_comm] \n```", "```py\ntheorem  sum_id  (n  :  ℕ)  :  ∑  i  ∈  range  (n  +  1),  i  =  n  *  (n  +  1)  /  2  :=  by\n  symm;  apply  Nat.div_eq_of_eq_mul_right  (by  norm_num  :  0  <  2)\n  induction'  n  with  n  ih\n  ·  simp\n  rw  [Finset.sum_range_succ,  mul_add  2,  ←  ih]\n  ring \n```", "```py\ntheorem  sum_sqr  (n  :  ℕ)  :  ∑  i  ∈  range  (n  +  1),  i  ^  2  =  n  *  (n  +  1)  *  (2  *  n  +  1)  /  6  :=  by\n  sorry \n```", "```py\ninductive  MyNat  where\n  |  zero  :  MyNat\n  |  succ  :  MyNat  →  MyNat\n\nnamespace  MyNat\n\ndef  add  :  MyNat  →  MyNat  →  MyNat\n  |  x,  zero  =>  x\n  |  x,  succ  y  =>  succ  (add  x  y)\n\ndef  mul  :  MyNat  →  MyNat  →  MyNat\n  |  x,  zero  =>  zero\n  |  x,  succ  y  =>  add  (mul  x  y)  x\n\ntheorem  zero_add  (n  :  MyNat)  :  add  zero  n  =  n  :=  by\n  induction'  n  with  n  ih\n  ·  rfl\n  rw  [add,  ih]\n\ntheorem  succ_add  (m  n  :  MyNat)  :  add  (succ  m)  n  =  succ  (add  m  n)  :=  by\n  induction'  n  with  n  ih\n  ·  rfl\n  rw  [add,  ih]\n  rfl\n\ntheorem  add_comm  (m  n  :  MyNat)  :  add  m  n  =  add  n  m  :=  by\n  induction'  n  with  n  ih\n  ·  rw  [zero_add]\n  rfl\n  rw  [add,  succ_add,  ih]\n\ntheorem  add_assoc  (m  n  k  :  MyNat)  :  add  (add  m  n)  k  =  add  m  (add  n  k)  :=  by\n  sorry\ntheorem  mul_add  (m  n  k  :  MyNat)  :  mul  m  (add  n  k)  =  add  (mul  m  n)  (mul  m  k)  :=  by\n  sorry\ntheorem  zero_mul  (n  :  MyNat)  :  mul  zero  n  =  zero  :=  by\n  sorry\ntheorem  succ_mul  (m  n  :  MyNat)  :  mul  (succ  m)  n  =  add  (mul  m  n)  n  :=  by\n  sorry\ntheorem  mul_comm  (m  n  :  MyNat)  :  mul  m  n  =  mul  n  m  :=  by\n  sorry\nend  MyNat \n```", "```py\ntheorem  two_le  {m  :  ℕ}  (h0  :  m  ≠  0)  (h1  :  m  ≠  1)  :  2  ≤  m  :=  by\n  cases  m;  contradiction\n  case  succ  m  =>\n  cases  m;  contradiction\n  repeat  apply  Nat.succ_le_succ\n  apply  zero_le \n```", "```py\nexample  {m  :  ℕ}  (h0  :  m  ≠  0)  (h1  :  m  ≠  1)  :  2  ≤  m  :=  by\n  by_contra  h\n  push_neg  at  h\n  interval_cases  m  <;>  contradiction \n```", "```py\nexample  {m  :  ℕ}  (h0  :  m  ≠  0)  (h1  :  m  ≠  1)  :  2  ≤  m  :=  by\n  by_contra  h\n  push_neg  at  h\n  revert  h0  h1\n  revert  h  m\n  decide \n```", "```py\ntheorem  exists_prime_factor  {n  :  Nat}  (h  :  2  ≤  n)  :  ∃  p  :  Nat,  p.Prime  ∧  p  ∣  n  :=  by\n  by_cases  np  :  n.Prime\n  ·  use  n,  np\n  induction'  n  using  Nat.strong_induction_on  with  n  ih\n  rw  [Nat.prime_def_lt]  at  np\n  push_neg  at  np\n  rcases  np  h  with  ⟨m,  mltn,  mdvdn,  mne1⟩\n  have  :  m  ≠  0  :=  by\n  intro  mz\n  rw  [mz,  zero_dvd_iff]  at  mdvdn\n  linarith\n  have  mgt2  :  2  ≤  m  :=  two_le  this  mne1\n  by_cases  mp  :  m.Prime\n  ·  use  m,  mp\n  ·  rcases  ih  m  mltn  mgt2  mp  with  ⟨p,  pp,  pdvd⟩\n  use  p,  pp\n  apply  pdvd.trans  mdvdn \n```", "```py\ntheorem  primes_infinite  :  ∀  n,  ∃  p  >  n,  Nat.Prime  p  :=  by\n  intro  n\n  have  :  2  ≤  Nat.factorial  n  +  1  :=  by\n  sorry\n  rcases  exists_prime_factor  this  with  ⟨p,  pp,  pdvd⟩\n  refine  ⟨p,  ?_,  pp⟩\n  show  p  >  n\n  by_contra  ple\n  push_neg  at  ple\n  have  :  p  ∣  Nat.factorial  n  :=  by\n  sorry\n  have  :  p  ∣  1  :=  by\n  sorry\n  show  False\n  sorry \n```", "```py\nopen  Finset\n\nsection\nvariable  {α  :  Type*}  [DecidableEq  α]  (r  s  t  :  Finset  α)\n\nexample  :  r  ∩  (s  ∪  t)  ⊆  r  ∩  s  ∪  r  ∩  t  :=  by\n  rw  [subset_iff]\n  intro  x\n  rw  [mem_inter,  mem_union,  mem_union,  mem_inter,  mem_inter]\n  tauto\n\nexample  :  r  ∩  (s  ∪  t)  ⊆  r  ∩  s  ∪  r  ∩  t  :=  by\n  simp  [subset_iff]\n  intro  x\n  tauto\n\nexample  :  r  ∩  s  ∪  r  ∩  t  ⊆  r  ∩  (s  ∪  t)  :=  by\n  simp  [subset_iff]\n  intro  x\n  tauto\n\nexample  :  r  ∩  s  ∪  r  ∩  t  =  r  ∩  (s  ∪  t)  :=  by\n  ext  x\n  simp\n  tauto\n\nend \n```", "```py\nexample  :  (r  ∪  s)  ∩  (r  ∪  t)  =  r  ∪  s  ∩  t  :=  by\n  sorry\nexample  :  (r  \\  s)  \\  t  =  r  \\  (s  ∪  t)  :=  by\n  sorry \n```", "```py\nexample  (s  :  Finset  ℕ)  (n  :  ℕ)  (h  :  n  ∈  s)  :  n  ∣  ∏  i  ∈  s,  i  :=\n  Finset.dvd_prod_of_mem  _  h \n```", "```py\ntheorem  _root_.Nat.Prime.eq_of_dvd_of_prime  {p  q  :  ℕ}\n  (prime_p  :  Nat.Prime  p)  (prime_q  :  Nat.Prime  q)  (h  :  p  ∣  q)  :\n  p  =  q  :=  by\n  sorry \n```", "```py\ntheorem  mem_of_dvd_prod_primes  {s  :  Finset  ℕ}  {p  :  ℕ}  (prime_p  :  p.Prime)  :\n  (∀  n  ∈  s,  Nat.Prime  n)  →  (p  ∣  ∏  n  ∈  s,  n)  →  p  ∈  s  :=  by\n  intro  h₀  h₁\n  induction'  s  using  Finset.induction_on  with  a  s  ans  ih\n  ·  simp  at  h₁\n  linarith  [prime_p.two_le]\n  simp  [Finset.prod_insert  ans,  prime_p.dvd_mul]  at  h₀  h₁\n  rw  [mem_insert]\n  sorry \n```", "```py\nexample  (s  :  Finset  ℕ)  (x  :  ℕ)  :  x  ∈  s.filter  Nat.Prime  ↔  x  ∈  s  ∧  x.Prime  :=\n  mem_filter \n```", "```py\ntheorem  primes_infinite'  :  ∀  s  :  Finset  Nat,  ∃  p,  Nat.Prime  p  ∧  p  ∉  s  :=  by\n  intro  s\n  by_contra  h\n  push_neg  at  h\n  set  s'  :=  s.filter  Nat.Prime  with  s'_def\n  have  mem_s'  :  ∀  {n  :  ℕ},  n  ∈  s'  ↔  n.Prime  :=  by\n  intro  n\n  simp  [s'_def]\n  apply  h\n  have  :  2  ≤  (∏  i  ∈  s',  i)  +  1  :=  by\n  sorry\n  rcases  exists_prime_factor  this  with  ⟨p,  pp,  pdvd⟩\n  have  :  p  ∣  ∏  i  ∈  s',  i  :=  by\n  sorry\n  have  :  p  ∣  1  :=  by\n  convert  Nat.dvd_sub  pdvd  this\n  simp\n  show  False\n  sorry \n```", "```py\ntheorem  bounded_of_ex_finset  (Q  :  ℕ  →  Prop)  :\n  (∃  s  :  Finset  ℕ,  ∀  k,  Q  k  →  k  ∈  s)  →  ∃  n,  ∀  k,  Q  k  →  k  <  n  :=  by\n  rintro  ⟨s,  hs⟩\n  use  s.sup  id  +  1\n  intro  k  Qk\n  apply  Nat.lt_succ_of_le\n  show  id  k  ≤  s.sup  id\n  apply  le_sup  (hs  k  Qk)\n\ntheorem  ex_finset_of_bounded  (Q  :  ℕ  →  Prop)  [DecidablePred  Q]  :\n  (∃  n,  ∀  k,  Q  k  →  k  ≤  n)  →  ∃  s  :  Finset  ℕ,  ∀  k,  Q  k  ↔  k  ∈  s  :=  by\n  rintro  ⟨n,  hn⟩\n  use  (range  (n  +  1)).filter  Q\n  intro  k\n  simp  [Nat.lt_succ_iff]\n  exact  hn  k \n```", "```py\nexample  :  27  %  4  =  3  :=  by  norm_num \n```", "```py\nexample  (n  :  ℕ)  :  (4  *  n  +  3)  %  4  =  3  :=  by\n  rw  [add_comm,  Nat.add_mul_mod_self_left]\n\ntheorem  mod_4_eq_3_or_mod_4_eq_3  {m  n  :  ℕ}  (h  :  m  *  n  %  4  =  3)  :  m  %  4  =  3  ∨  n  %  4  =  3  :=  by\n  revert  h\n  rw  [Nat.mul_mod]\n  have  :  m  %  4  <  4  :=  Nat.mod_lt  m  (by  norm_num)\n  interval_cases  m  %  4  <;>  simp  [-Nat.mul_mod_mod]\n  have  :  n  %  4  <  4  :=  Nat.mod_lt  n  (by  norm_num)\n  interval_cases  n  %  4  <;>  simp\n\ntheorem  two_le_of_mod_4_eq_3  {n  :  ℕ}  (h  :  n  %  4  =  3)  :  2  ≤  n  :=  by\n  apply  two_le  <;>\n  ·  intro  neq\n  rw  [neq]  at  h\n  norm_num  at  h \n```", "```py\ntheorem  aux  {m  n  :  ℕ}  (h₀  :  m  ∣  n)  (h₁  :  2  ≤  m)  (h₂  :  m  <  n)  :  n  /  m  ∣  n  ∧  n  /  m  <  n  :=  by\n  sorry \n```", "```py\ntheorem  exists_prime_factor_mod_4_eq_3  {n  :  Nat}  (h  :  n  %  4  =  3)  :\n  ∃  p  :  Nat,  p.Prime  ∧  p  ∣  n  ∧  p  %  4  =  3  :=  by\n  by_cases  np  :  n.Prime\n  ·  use  n\n  induction'  n  using  Nat.strong_induction_on  with  n  ih\n  rw  [Nat.prime_def_lt]  at  np\n  push_neg  at  np\n  rcases  np  (two_le_of_mod_4_eq_3  h)  with  ⟨m,  mltn,  mdvdn,  mne1⟩\n  have  mge2  :  2  ≤  m  :=  by\n  apply  two_le  _  mne1\n  intro  mz\n  rw  [mz,  zero_dvd_iff]  at  mdvdn\n  linarith\n  have  neq  :  m  *  (n  /  m)  =  n  :=  Nat.mul_div_cancel'  mdvdn\n  have  :  m  %  4  =  3  ∨  n  /  m  %  4  =  3  :=  by\n  apply  mod_4_eq_3_or_mod_4_eq_3\n  rw  [neq,  h]\n  rcases  this  with  h1  |  h1\n  .  sorry\n  .  sorry \n```", "```py\nexample  (m  n  :  ℕ)  (s  :  Finset  ℕ)  (h  :  m  ∈  erase  s  n)  :  m  ≠  n  ∧  m  ∈  s  :=  by\n  rwa  [mem_erase]  at  h\n\nexample  (m  n  :  ℕ)  (s  :  Finset  ℕ)  (h  :  m  ∈  erase  s  n)  :  m  ≠  n  ∧  m  ∈  s  :=  by\n  simp  at  h\n  assumption \n```", "```py\ntheorem  primes_mod_4_eq_3_infinite  :  ∀  n,  ∃  p  >  n,  Nat.Prime  p  ∧  p  %  4  =  3  :=  by\n  by_contra  h\n  push_neg  at  h\n  rcases  h  with  ⟨n,  hn⟩\n  have  :  ∃  s  :  Finset  Nat,  ∀  p  :  ℕ,  p.Prime  ∧  p  %  4  =  3  ↔  p  ∈  s  :=  by\n  apply  ex_finset_of_bounded\n  use  n\n  contrapose!  hn\n  rcases  hn  with  ⟨p,  ⟨pp,  p4⟩,  pltn⟩\n  exact  ⟨p,  pltn,  pp,  p4⟩\n  rcases  this  with  ⟨s,  hs⟩\n  have  h₁  :  ((4  *  ∏  i  ∈  erase  s  3,  i)  +  3)  %  4  =  3  :=  by\n  sorry\n  rcases  exists_prime_factor_mod_4_eq_3  h₁  with  ⟨p,  pp,  pdvd,  p4eq⟩\n  have  ps  :  p  ∈  s  :=  by\n  sorry\n  have  pne3  :  p  ≠  3  :=  by\n  sorry\n  have  :  p  ∣  4  *  ∏  i  ∈  erase  s  3,  i  :=  by\n  sorry\n  have  :  p  ∣  3  :=  by\n  sorry\n  have  :  p  =  3  :=  by\n  sorry\n  contradiction \n```", "```py\ndef  fac  :  ℕ  →  ℕ\n  |  0  =>  1\n  |  n  +  1  =>  (n  +  1)  *  fac  n \n```", "```py\ntheorem  fac_pos  (n  :  ℕ)  :  0  <  fac  n  :=  by\n  induction'  n  with  n  ih\n  ·  rw  [fac]\n  exact  zero_lt_one\n  rw  [fac]\n  exact  mul_pos  n.succ_pos  ih \n```", "```py\nexample  (n  :  ℕ)  :  0  <  fac  n  :=  by\n  induction  n\n  case  zero  =>\n  rw  [fac]\n  exact  zero_lt_one\n  case  succ  n  ih  =>\n  rw  [fac]\n  exact  mul_pos  n.succ_pos  ih\n\nexample  (n  :  ℕ)  :  0  <  fac  n  :=  by\n  induction  n  with\n  |  zero  =>\n  rw  [fac]\n  exact  zero_lt_one\n  |  succ  n  ih  =>\n  rw  [fac]\n  exact  mul_pos  n.succ_pos  ih \n```", "```py\ntheorem  fac_pos'  :  ∀  n,  0  <  fac  n\n  |  0  =>  by\n  rw  [fac]\n  exact  zero_lt_one\n  |  n  +  1  =>  by\n  rw  [fac]\n  exact  mul_pos  n.succ_pos  (fac_pos'  n) \n```", "```py\n@[simp]  def  fib  :  ℕ  →  ℕ\n  |  0  =>  0\n  |  1  =>  1\n  |  n  +  2  =>  fib  n  +  fib  (n  +  1) \n```", "```py\ntheorem  fib_add_two  (n  :  ℕ)  :  fib  (n  +  2)  =  fib  n  +  fib  (n  +  1)  :=  rfl\n\nexample  (n  :  ℕ)  :  fib  (n  +  2)  =  fib  n  +  fib  (n  +  1)  :=  by  rw  [fib] \n```", "```py\nnoncomputable  section\n\ndef  phi  :  ℝ  :=  (1  +  √5)  /  2\ndef  phi'  :  ℝ  :=  (1  -  √5)  /  2\n\ntheorem  phi_sq  :  phi^2  =  phi  +  1  :=  by\n  field_simp  [phi,  add_sq];  ring\n\ntheorem  phi'_sq  :  phi'^2  =  phi'  +  1  :=  by\n  field_simp  [phi',  sub_sq];  ring\n\ntheorem  fib_eq  :  ∀  n,  fib  n  =  (phi^n  -  phi'^n)  /  √5\n  |  0  =>  by  simp\n  |  1  =>  by  field_simp  [phi,  phi']\n  |  n+2  =>  by  field_simp  [fib_eq,  pow_add,  phi_sq,  phi'_sq];  ring\n\nend \n```", "```py\ntheorem  fib_coprime_fib_succ  (n  :  ℕ)  :  Nat.Coprime  (fib  n)  (fib  (n  +  1))  :=  by\n  induction  n  with\n  |  zero  =>  simp\n  |  succ  n  ih  =>\n  simp  only  [fib,  Nat.coprime_add_self_right]\n  exact  ih.symm \n```", "```py\n#eval  fib  6\n#eval  List.range  20  |>.map  fib \n```", "```py\ndef  fib'  (n  :  Nat)  :  Nat  :=\n  aux  n  0  1\nwhere  aux\n  |  0,  x,  _  =>  x\n  |  n+1,  x,  y  =>  aux  n  y  (x  +  y)\n\ntheorem  fib'.aux_eq  (m  n  :  ℕ)  :  fib'.aux  n  (fib  m)  (fib  (m  +  1))  =  fib  (n  +  m)  :=  by\n  induction  n  generalizing  m  with\n  |  zero  =>  simp  [fib'.aux]\n  |  succ  n  ih  =>  rw  [fib'.aux,  ←fib_add_two,  ih,  add_assoc,  add_comm  1]\n\ntheorem  fib'_eq_fib  :  fib'  =  fib  :=  by\n  ext  n\n  erw  [fib',  fib'.aux_eq  0  n];  rfl\n\n#eval  fib'  10000 \n```", "```py\ntheorem  fib_add  (m  n  :  ℕ)  :  fib  (m  +  n  +  1)  =  fib  m  *  fib  n  +  fib  (m  +  1)  *  fib  (n  +  1)  :=  by\n  induction  n  generalizing  m  with\n  |  zero  =>  simp\n  |  succ  n  ih  =>\n  specialize  ih  (m  +  1)\n  rw  [add_assoc  m  1  n,  add_comm  1  n]  at  ih\n  simp  only  [fib_add_two,  Nat.succ_eq_add_one,  ih]\n  ring\n\ntheorem  fib_add'  :  ∀  m  n,  fib  (m  +  n  +  1)  =  fib  m  *  fib  n  +  fib  (m  +  1)  *  fib  (n  +  1)\n  |  _,  0  =>  by  simp\n  |  m,  n  +  1  =>  by\n  have  :=  fib_add'  (m  +  1)  n\n  rw  [add_assoc  m  1  n,  add_comm  1  n]  at  this\n  simp  only  [fib_add_two,  Nat.succ_eq_add_one,  this]\n  ring \n```", "```py\nexample  (n  :  ℕ):  (fib  n)  ^  2  +  (fib  (n  +  1))  ^  2  =  fib  (2  *  n  +  1)  :=  by  sorry \n```", "```py\n#check  (@Nat.not_prime_iff_exists_dvd_lt  :\n  ∀  {n  :  ℕ},  2  ≤  n  →  (¬Nat.Prime  n  ↔  ∃  m,  m  ∣  n  ∧  2  ≤  m  ∧  m  <  n))\n\ntheorem  ne_one_iff_exists_prime_dvd  :  ∀  {n},  n  ≠  1  ↔  ∃  p  :  ℕ,  p.Prime  ∧  p  ∣  n\n  |  0  =>  by  simpa  using  Exists.intro  2  Nat.prime_two\n  |  1  =>  by  simp  [Nat.not_prime_one]\n  |  n  +  2  =>  by\n  have  hn  :  n+2  ≠  1  :=  by  omega\n  simp  only  [Ne,  not_false_iff,  true_iff,  hn]\n  by_cases  h  :  Nat.Prime  (n  +  2)\n  ·  use  n+2,  h\n  ·  have  :  2  ≤  n  +  2  :=  by  omega\n  rw  [Nat.not_prime_iff_exists_dvd_lt  this]  at  h\n  rcases  h  with  ⟨m,  mdvdn,  mge2,  -⟩\n  have  :  m  ≠  1  :=  by  omega\n  rw  [ne_one_iff_exists_prime_dvd]  at  this\n  rcases  this  with  ⟨p,  primep,  pdvdm⟩\n  use  p,  primep\n  exact  pdvdm.trans  mdvdn \n```", "```py\ntheorem  zero_lt_of_mul_eq_one  (m  n  :  ℕ)  :  n  *  m  =  1  →  0  <  n  ∧  0  <  m  :=  by\n  cases  n  <;>  cases  m  <;>  simp\n\nexample  (m  n  :  ℕ)  :  n*m  =  1  →  0  <  n  ∧  0  <  m  :=  by\n  rcases  m  with  (_  |  m);  simp\n  rcases  n  with  (_  |  n)  <;>  simp \n```", "```py\n#print  Nat.Coprime\n\nexample  (m  n  :  Nat)  (h  :  m.Coprime  n)  :  m.gcd  n  =  1  :=\n  h\n\nexample  (m  n  :  Nat)  (h  :  m.Coprime  n)  :  m.gcd  n  =  1  :=  by\n  rw  [Nat.Coprime]  at  h\n  exact  h\n\nexample  :  Nat.Coprime  12  7  :=  by  norm_num\n\nexample  :  Nat.gcd  12  8  =  4  :=  by  norm_num \n```", "```py\n#check  Nat.prime_def_lt\n\nexample  (p  :  ℕ)  (prime_p  :  Nat.Prime  p)  :  2  ≤  p  ∧  ∀  m  :  ℕ,  m  <  p  →  m  ∣  p  →  m  =  1  :=  by\n  rwa  [Nat.prime_def_lt]  at  prime_p\n\n#check  Nat.Prime.eq_one_or_self_of_dvd\n\nexample  (p  :  ℕ)  (prime_p  :  Nat.Prime  p)  :  ∀  m  :  ℕ,  m  ∣  p  →  m  =  1  ∨  m  =  p  :=\n  prime_p.eq_one_or_self_of_dvd\n\nexample  :  Nat.Prime  17  :=  by  norm_num\n\n-- commonly used\nexample  :  Nat.Prime  2  :=\n  Nat.prime_two\n\nexample  :  Nat.Prime  3  :=\n  Nat.prime_three \n```", "```py\n#check  Nat.Prime.dvd_mul\n#check  Nat.Prime.dvd_mul  Nat.prime_two\n#check  Nat.prime_two.dvd_mul\n\ntheorem  even_of_even_sqr  {m  :  ℕ}  (h  :  2  ∣  m  ^  2)  :  2  ∣  m  :=  by\n  rw  [pow_two,  Nat.prime_two.dvd_mul]  at  h\n  cases  h  <;>  assumption\n\nexample  {m  :  ℕ}  (h  :  2  ∣  m  ^  2)  :  2  ∣  m  :=\n  Nat.Prime.dvd_of_dvd_pow  Nat.prime_two  h \n```", "```py\nexample  (a  b  c  :  Nat)  (h  :  a  *  b  =  a  *  c)  (h'  :  a  ≠  0)  :  b  =  c  :=\n  -- apply? suggests the following:\n  (mul_right_inj'  h').mp  h \n```", "```py\nexample  {m  n  :  ℕ}  (coprime_mn  :  m.Coprime  n)  :  m  ^  2  ≠  2  *  n  ^  2  :=  by\n  intro  sqr_eq\n  have  :  2  ∣  m  :=  by\n  sorry\n  obtain  ⟨k,  meq⟩  :=  dvd_iff_exists_eq_mul_left.mp  this\n  have  :  2  *  (2  *  k  ^  2)  =  2  *  n  ^  2  :=  by\n  rw  [←  sqr_eq,  meq]\n  ring\n  have  :  2  *  k  ^  2  =  n  ^  2  :=\n  sorry\n  have  :  2  ∣  n  :=  by\n  sorry\n  have  :  2  ∣  m.gcd  n  :=  by\n  sorry\n  have  :  2  ∣  1  :=  by\n  sorry\n  norm_num  at  this \n```", "```py\nexample  {m  n  p  :  ℕ}  (coprime_mn  :  m.Coprime  n)  (prime_p  :  p.Prime)  :  m  ^  2  ≠  p  *  n  ^  2  :=  by\n  sorry \n```", "```py\n#check  Nat.primeFactorsList\n#check  Nat.prime_of_mem_primeFactorsList\n#check  Nat.prod_primeFactorsList\n#check  Nat.primeFactorsList_unique \n```", "```py\ntheorem  factorization_mul'  {m  n  :  ℕ}  (mnez  :  m  ≠  0)  (nnez  :  n  ≠  0)  (p  :  ℕ)  :\n  (m  *  n).factorization  p  =  m.factorization  p  +  n.factorization  p  :=  by\n  rw  [Nat.factorization_mul  mnez  nnez]\n  rfl\n\ntheorem  factorization_pow'  (n  k  p  :  ℕ)  :\n  (n  ^  k).factorization  p  =  k  *  n.factorization  p  :=  by\n  rw  [Nat.factorization_pow]\n  rfl\n\ntheorem  Nat.Prime.factorization'  {p  :  ℕ}  (prime_p  :  p.Prime)  :\n  p.factorization  p  =  1  :=  by\n  rw  [prime_p.factorization]\n  simp \n```", "```py\nexample  {m  n  p  :  ℕ}  (nnz  :  n  ≠  0)  (prime_p  :  p.Prime)  :  m  ^  2  ≠  p  *  n  ^  2  :=  by\n  intro  sqr_eq\n  have  nsqr_nez  :  n  ^  2  ≠  0  :=  by  simpa\n  have  eq1  :  Nat.factorization  (m  ^  2)  p  =  2  *  m.factorization  p  :=  by\n  sorry\n  have  eq2  :  (p  *  n  ^  2).factorization  p  =  2  *  n.factorization  p  +  1  :=  by\n  sorry\n  have  :  2  *  m.factorization  p  %  2  =  (2  *  n.factorization  p  +  1)  %  2  :=  by\n  rw  [←  eq1,  sqr_eq,  eq2]\n  rw  [add_comm,  Nat.add_mul_mod_self_left,  Nat.mul_mod_right]  at  this\n  norm_num  at  this \n```", "```py\nexample  {m  n  k  r  :  ℕ}  (nnz  :  n  ≠  0)  (pow_eq  :  m  ^  k  =  r  *  n  ^  k)  {p  :  ℕ}  :\n  k  ∣  r.factorization  p  :=  by\n  rcases  r  with  _  |  r\n  ·  simp\n  have  npow_nz  :  n  ^  k  ≠  0  :=  fun  npowz  ↦  nnz  (pow_eq_zero  npowz)\n  have  eq1  :  (m  ^  k).factorization  p  =  k  *  m.factorization  p  :=  by\n  sorry\n  have  eq2  :  ((r  +  1)  *  n  ^  k).factorization  p  =\n  k  *  n.factorization  p  +  (r  +  1).factorization  p  :=  by\n  sorry\n  have  :  r.succ.factorization  p  =  k  *  m.factorization  p  -  k  *  n.factorization  p  :=  by\n  rw  [←  eq1,  pow_eq,  eq2,  add_comm,  Nat.add_sub_cancel]\n  rw  [this]\n  sorry \n```", "```py\ninductive  Nat  where\n  |  zero  :  Nat\n  |  succ  (n  :  Nat)  :  Nat \n```", "```py\nexample  (n  :  Nat)  :  n.succ  ≠  Nat.zero  :=\n  Nat.succ_ne_zero  n\n\nexample  (m  n  :  Nat)  (h  :  m.succ  =  n.succ)  :  m  =  n  :=\n  Nat.succ.inj  h \n```", "```py\ndef  fac  :  ℕ  →  ℕ\n  |  0  =>  1\n  |  n  +  1  =>  (n  +  1)  *  fac  n \n```", "```py\nexample  :  fac  0  =  1  :=\n  rfl\n\nexample  :  fac  0  =  1  :=  by\n  rw  [fac]\n\nexample  :  fac  0  =  1  :=  by\n  simp  [fac]\n\nexample  (n  :  ℕ)  :  fac  (n  +  1)  =  (n  +  1)  *  fac  n  :=\n  rfl\n\nexample  (n  :  ℕ)  :  fac  (n  +  1)  =  (n  +  1)  *  fac  n  :=  by\n  rw  [fac]\n\nexample  (n  :  ℕ)  :  fac  (n  +  1)  =  (n  +  1)  *  fac  n  :=  by\n  simp  [fac] \n```", "```py\ntheorem  fac_pos  (n  :  ℕ)  :  0  <  fac  n  :=  by\n  induction'  n  with  n  ih\n  ·  rw  [fac]\n  exact  zero_lt_one\n  rw  [fac]\n  exact  mul_pos  n.succ_pos  ih \n```", "```py\ntheorem  dvd_fac  {i  n  :  ℕ}  (ipos  :  0  <  i)  (ile  :  i  ≤  n)  :  i  ∣  fac  n  :=  by\n  induction'  n  with  n  ih\n  ·  exact  absurd  ipos  (not_lt_of_ge  ile)\n  rw  [fac]\n  rcases  Nat.of_le_succ  ile  with  h  |  h\n  ·  apply  dvd_mul_of_dvd_right  (ih  h)\n  rw  [h]\n  apply  dvd_mul_right \n```", "```py\ntheorem  pow_two_le_fac  (n  :  ℕ)  :  2  ^  (n  -  1)  ≤  fac  n  :=  by\n  rcases  n  with  _  |  n\n  ·  simp  [fac]\n  sorry \n```", "```py\nvariable  {α  :  Type*}  (s  :  Finset  ℕ)  (f  :  ℕ  →  ℕ)  (n  :  ℕ)\n\n#check  Finset.sum  s  f\n#check  Finset.prod  s  f\n\nopen  BigOperators\nopen  Finset\n\nexample  :  s.sum  f  =  ∑  x  ∈  s,  f  x  :=\n  rfl\n\nexample  :  s.prod  f  =  ∏  x  ∈  s,  f  x  :=\n  rfl\n\nexample  :  (range  n).sum  f  =  ∑  x  ∈  range  n,  f  x  :=\n  rfl\n\nexample  :  (range  n).prod  f  =  ∏  x  ∈  range  n,  f  x  :=\n  rfl \n```", "```py\nexample  (f  :  ℕ  →  ℕ)  :  ∑  x  ∈  range  0,  f  x  =  0  :=\n  Finset.sum_range_zero  f\n\nexample  (f  :  ℕ  →  ℕ)  (n  :  ℕ)  :  ∑  x  ∈  range  n.succ,  f  x  =  ∑  x  ∈  range  n,  f  x  +  f  n  :=\n  Finset.sum_range_succ  f  n\n\nexample  (f  :  ℕ  →  ℕ)  :  ∏  x  ∈  range  0,  f  x  =  1  :=\n  Finset.prod_range_zero  f\n\nexample  (f  :  ℕ  →  ℕ)  (n  :  ℕ)  :  ∏  x  ∈  range  n.succ,  f  x  =  (∏  x  ∈  range  n,  f  x)  *  f  n  :=\n  Finset.prod_range_succ  f  n \n```", "```py\nexample  (n  :  ℕ)  :  fac  n  =  ∏  i  ∈  range  n,  (i  +  1)  :=  by\n  induction'  n  with  n  ih\n  ·  simp  [fac,  prod_range_zero]\n  simp  [fac,  ih,  prod_range_succ,  mul_comm] \n```", "```py\nexample  (a  b  c  d  e  f  :  ℕ)  :  a  *  (b  *  c  *  f  *  (d  *  e))  =  d  *  (a  *  f  *  e)  *  (c  *  b)  :=  by\n  simp  [mul_assoc,  mul_comm,  mul_left_comm] \n```", "```py\ntheorem  sum_id  (n  :  ℕ)  :  ∑  i  ∈  range  (n  +  1),  i  =  n  *  (n  +  1)  /  2  :=  by\n  symm;  apply  Nat.div_eq_of_eq_mul_right  (by  norm_num  :  0  <  2)\n  induction'  n  with  n  ih\n  ·  simp\n  rw  [Finset.sum_range_succ,  mul_add  2,  ←  ih]\n  ring \n```", "```py\ntheorem  sum_sqr  (n  :  ℕ)  :  ∑  i  ∈  range  (n  +  1),  i  ^  2  =  n  *  (n  +  1)  *  (2  *  n  +  1)  /  6  :=  by\n  sorry \n```", "```py\ninductive  MyNat  where\n  |  zero  :  MyNat\n  |  succ  :  MyNat  →  MyNat\n\nnamespace  MyNat\n\ndef  add  :  MyNat  →  MyNat  →  MyNat\n  |  x,  zero  =>  x\n  |  x,  succ  y  =>  succ  (add  x  y)\n\ndef  mul  :  MyNat  →  MyNat  →  MyNat\n  |  x,  zero  =>  zero\n  |  x,  succ  y  =>  add  (mul  x  y)  x\n\ntheorem  zero_add  (n  :  MyNat)  :  add  zero  n  =  n  :=  by\n  induction'  n  with  n  ih\n  ·  rfl\n  rw  [add,  ih]\n\ntheorem  succ_add  (m  n  :  MyNat)  :  add  (succ  m)  n  =  succ  (add  m  n)  :=  by\n  induction'  n  with  n  ih\n  ·  rfl\n  rw  [add,  ih]\n  rfl\n\ntheorem  add_comm  (m  n  :  MyNat)  :  add  m  n  =  add  n  m  :=  by\n  induction'  n  with  n  ih\n  ·  rw  [zero_add]\n  rfl\n  rw  [add,  succ_add,  ih]\n\ntheorem  add_assoc  (m  n  k  :  MyNat)  :  add  (add  m  n)  k  =  add  m  (add  n  k)  :=  by\n  sorry\ntheorem  mul_add  (m  n  k  :  MyNat)  :  mul  m  (add  n  k)  =  add  (mul  m  n)  (mul  m  k)  :=  by\n  sorry\ntheorem  zero_mul  (n  :  MyNat)  :  mul  zero  n  =  zero  :=  by\n  sorry\ntheorem  succ_mul  (m  n  :  MyNat)  :  mul  (succ  m)  n  =  add  (mul  m  n)  n  :=  by\n  sorry\ntheorem  mul_comm  (m  n  :  MyNat)  :  mul  m  n  =  mul  n  m  :=  by\n  sorry\nend  MyNat \n```", "```py\ntheorem  two_le  {m  :  ℕ}  (h0  :  m  ≠  0)  (h1  :  m  ≠  1)  :  2  ≤  m  :=  by\n  cases  m;  contradiction\n  case  succ  m  =>\n  cases  m;  contradiction\n  repeat  apply  Nat.succ_le_succ\n  apply  zero_le \n```", "```py\nexample  {m  :  ℕ}  (h0  :  m  ≠  0)  (h1  :  m  ≠  1)  :  2  ≤  m  :=  by\n  by_contra  h\n  push_neg  at  h\n  interval_cases  m  <;>  contradiction \n```", "```py\nexample  {m  :  ℕ}  (h0  :  m  ≠  0)  (h1  :  m  ≠  1)  :  2  ≤  m  :=  by\n  by_contra  h\n  push_neg  at  h\n  revert  h0  h1\n  revert  h  m\n  decide \n```", "```py\ntheorem  exists_prime_factor  {n  :  Nat}  (h  :  2  ≤  n)  :  ∃  p  :  Nat,  p.Prime  ∧  p  ∣  n  :=  by\n  by_cases  np  :  n.Prime\n  ·  use  n,  np\n  induction'  n  using  Nat.strong_induction_on  with  n  ih\n  rw  [Nat.prime_def_lt]  at  np\n  push_neg  at  np\n  rcases  np  h  with  ⟨m,  mltn,  mdvdn,  mne1⟩\n  have  :  m  ≠  0  :=  by\n  intro  mz\n  rw  [mz,  zero_dvd_iff]  at  mdvdn\n  linarith\n  have  mgt2  :  2  ≤  m  :=  two_le  this  mne1\n  by_cases  mp  :  m.Prime\n  ·  use  m,  mp\n  ·  rcases  ih  m  mltn  mgt2  mp  with  ⟨p,  pp,  pdvd⟩\n  use  p,  pp\n  apply  pdvd.trans  mdvdn \n```", "```py\ntheorem  primes_infinite  :  ∀  n,  ∃  p  >  n,  Nat.Prime  p  :=  by\n  intro  n\n  have  :  2  ≤  Nat.factorial  n  +  1  :=  by\n  sorry\n  rcases  exists_prime_factor  this  with  ⟨p,  pp,  pdvd⟩\n  refine  ⟨p,  ?_,  pp⟩\n  show  p  >  n\n  by_contra  ple\n  push_neg  at  ple\n  have  :  p  ∣  Nat.factorial  n  :=  by\n  sorry\n  have  :  p  ∣  1  :=  by\n  sorry\n  show  False\n  sorry \n```", "```py\nopen  Finset\n\nsection\nvariable  {α  :  Type*}  [DecidableEq  α]  (r  s  t  :  Finset  α)\n\nexample  :  r  ∩  (s  ∪  t)  ⊆  r  ∩  s  ∪  r  ∩  t  :=  by\n  rw  [subset_iff]\n  intro  x\n  rw  [mem_inter,  mem_union,  mem_union,  mem_inter,  mem_inter]\n  tauto\n\nexample  :  r  ∩  (s  ∪  t)  ⊆  r  ∩  s  ∪  r  ∩  t  :=  by\n  simp  [subset_iff]\n  intro  x\n  tauto\n\nexample  :  r  ∩  s  ∪  r  ∩  t  ⊆  r  ∩  (s  ∪  t)  :=  by\n  simp  [subset_iff]\n  intro  x\n  tauto\n\nexample  :  r  ∩  s  ∪  r  ∩  t  =  r  ∩  (s  ∪  t)  :=  by\n  ext  x\n  simp\n  tauto\n\nend \n```", "```py\nexample  :  (r  ∪  s)  ∩  (r  ∪  t)  =  r  ∪  s  ∩  t  :=  by\n  sorry\nexample  :  (r  \\  s)  \\  t  =  r  \\  (s  ∪  t)  :=  by\n  sorry \n```", "```py\nexample  (s  :  Finset  ℕ)  (n  :  ℕ)  (h  :  n  ∈  s)  :  n  ∣  ∏  i  ∈  s,  i  :=\n  Finset.dvd_prod_of_mem  _  h \n```", "```py\ntheorem  _root_.Nat.Prime.eq_of_dvd_of_prime  {p  q  :  ℕ}\n  (prime_p  :  Nat.Prime  p)  (prime_q  :  Nat.Prime  q)  (h  :  p  ∣  q)  :\n  p  =  q  :=  by\n  sorry \n```", "```py\ntheorem  mem_of_dvd_prod_primes  {s  :  Finset  ℕ}  {p  :  ℕ}  (prime_p  :  p.Prime)  :\n  (∀  n  ∈  s,  Nat.Prime  n)  →  (p  ∣  ∏  n  ∈  s,  n)  →  p  ∈  s  :=  by\n  intro  h₀  h₁\n  induction'  s  using  Finset.induction_on  with  a  s  ans  ih\n  ·  simp  at  h₁\n  linarith  [prime_p.two_le]\n  simp  [Finset.prod_insert  ans,  prime_p.dvd_mul]  at  h₀  h₁\n  rw  [mem_insert]\n  sorry \n```", "```py\nexample  (s  :  Finset  ℕ)  (x  :  ℕ)  :  x  ∈  s.filter  Nat.Prime  ↔  x  ∈  s  ∧  x.Prime  :=\n  mem_filter \n```", "```py\ntheorem  primes_infinite'  :  ∀  s  :  Finset  Nat,  ∃  p,  Nat.Prime  p  ∧  p  ∉  s  :=  by\n  intro  s\n  by_contra  h\n  push_neg  at  h\n  set  s'  :=  s.filter  Nat.Prime  with  s'_def\n  have  mem_s'  :  ∀  {n  :  ℕ},  n  ∈  s'  ↔  n.Prime  :=  by\n  intro  n\n  simp  [s'_def]\n  apply  h\n  have  :  2  ≤  (∏  i  ∈  s',  i)  +  1  :=  by\n  sorry\n  rcases  exists_prime_factor  this  with  ⟨p,  pp,  pdvd⟩\n  have  :  p  ∣  ∏  i  ∈  s',  i  :=  by\n  sorry\n  have  :  p  ∣  1  :=  by\n  convert  Nat.dvd_sub  pdvd  this\n  simp\n  show  False\n  sorry \n```", "```py\ntheorem  bounded_of_ex_finset  (Q  :  ℕ  →  Prop)  :\n  (∃  s  :  Finset  ℕ,  ∀  k,  Q  k  →  k  ∈  s)  →  ∃  n,  ∀  k,  Q  k  →  k  <  n  :=  by\n  rintro  ⟨s,  hs⟩\n  use  s.sup  id  +  1\n  intro  k  Qk\n  apply  Nat.lt_succ_of_le\n  show  id  k  ≤  s.sup  id\n  apply  le_sup  (hs  k  Qk)\n\ntheorem  ex_finset_of_bounded  (Q  :  ℕ  →  Prop)  [DecidablePred  Q]  :\n  (∃  n,  ∀  k,  Q  k  →  k  ≤  n)  →  ∃  s  :  Finset  ℕ,  ∀  k,  Q  k  ↔  k  ∈  s  :=  by\n  rintro  ⟨n,  hn⟩\n  use  (range  (n  +  1)).filter  Q\n  intro  k\n  simp  [Nat.lt_succ_iff]\n  exact  hn  k \n```", "```py\nexample  :  27  %  4  =  3  :=  by  norm_num \n```", "```py\nexample  (n  :  ℕ)  :  (4  *  n  +  3)  %  4  =  3  :=  by\n  rw  [add_comm,  Nat.add_mul_mod_self_left]\n\ntheorem  mod_4_eq_3_or_mod_4_eq_3  {m  n  :  ℕ}  (h  :  m  *  n  %  4  =  3)  :  m  %  4  =  3  ∨  n  %  4  =  3  :=  by\n  revert  h\n  rw  [Nat.mul_mod]\n  have  :  m  %  4  <  4  :=  Nat.mod_lt  m  (by  norm_num)\n  interval_cases  m  %  4  <;>  simp  [-Nat.mul_mod_mod]\n  have  :  n  %  4  <  4  :=  Nat.mod_lt  n  (by  norm_num)\n  interval_cases  n  %  4  <;>  simp\n\ntheorem  two_le_of_mod_4_eq_3  {n  :  ℕ}  (h  :  n  %  4  =  3)  :  2  ≤  n  :=  by\n  apply  two_le  <;>\n  ·  intro  neq\n  rw  [neq]  at  h\n  norm_num  at  h \n```", "```py\ntheorem  aux  {m  n  :  ℕ}  (h₀  :  m  ∣  n)  (h₁  :  2  ≤  m)  (h₂  :  m  <  n)  :  n  /  m  ∣  n  ∧  n  /  m  <  n  :=  by\n  sorry \n```", "```py\ntheorem  exists_prime_factor_mod_4_eq_3  {n  :  Nat}  (h  :  n  %  4  =  3)  :\n  ∃  p  :  Nat,  p.Prime  ∧  p  ∣  n  ∧  p  %  4  =  3  :=  by\n  by_cases  np  :  n.Prime\n  ·  use  n\n  induction'  n  using  Nat.strong_induction_on  with  n  ih\n  rw  [Nat.prime_def_lt]  at  np\n  push_neg  at  np\n  rcases  np  (two_le_of_mod_4_eq_3  h)  with  ⟨m,  mltn,  mdvdn,  mne1⟩\n  have  mge2  :  2  ≤  m  :=  by\n  apply  two_le  _  mne1\n  intro  mz\n  rw  [mz,  zero_dvd_iff]  at  mdvdn\n  linarith\n  have  neq  :  m  *  (n  /  m)  =  n  :=  Nat.mul_div_cancel'  mdvdn\n  have  :  m  %  4  =  3  ∨  n  /  m  %  4  =  3  :=  by\n  apply  mod_4_eq_3_or_mod_4_eq_3\n  rw  [neq,  h]\n  rcases  this  with  h1  |  h1\n  .  sorry\n  .  sorry \n```", "```py\nexample  (m  n  :  ℕ)  (s  :  Finset  ℕ)  (h  :  m  ∈  erase  s  n)  :  m  ≠  n  ∧  m  ∈  s  :=  by\n  rwa  [mem_erase]  at  h\n\nexample  (m  n  :  ℕ)  (s  :  Finset  ℕ)  (h  :  m  ∈  erase  s  n)  :  m  ≠  n  ∧  m  ∈  s  :=  by\n  simp  at  h\n  assumption \n```", "```py\ntheorem  primes_mod_4_eq_3_infinite  :  ∀  n,  ∃  p  >  n,  Nat.Prime  p  ∧  p  %  4  =  3  :=  by\n  by_contra  h\n  push_neg  at  h\n  rcases  h  with  ⟨n,  hn⟩\n  have  :  ∃  s  :  Finset  Nat,  ∀  p  :  ℕ,  p.Prime  ∧  p  %  4  =  3  ↔  p  ∈  s  :=  by\n  apply  ex_finset_of_bounded\n  use  n\n  contrapose!  hn\n  rcases  hn  with  ⟨p,  ⟨pp,  p4⟩,  pltn⟩\n  exact  ⟨p,  pltn,  pp,  p4⟩\n  rcases  this  with  ⟨s,  hs⟩\n  have  h₁  :  ((4  *  ∏  i  ∈  erase  s  3,  i)  +  3)  %  4  =  3  :=  by\n  sorry\n  rcases  exists_prime_factor_mod_4_eq_3  h₁  with  ⟨p,  pp,  pdvd,  p4eq⟩\n  have  ps  :  p  ∈  s  :=  by\n  sorry\n  have  pne3  :  p  ≠  3  :=  by\n  sorry\n  have  :  p  ∣  4  *  ∏  i  ∈  erase  s  3,  i  :=  by\n  sorry\n  have  :  p  ∣  3  :=  by\n  sorry\n  have  :  p  =  3  :=  by\n  sorry\n  contradiction \n```", "```py\ndef  fac  :  ℕ  →  ℕ\n  |  0  =>  1\n  |  n  +  1  =>  (n  +  1)  *  fac  n \n```", "```py\ntheorem  fac_pos  (n  :  ℕ)  :  0  <  fac  n  :=  by\n  induction'  n  with  n  ih\n  ·  rw  [fac]\n  exact  zero_lt_one\n  rw  [fac]\n  exact  mul_pos  n.succ_pos  ih \n```", "```py\nexample  (n  :  ℕ)  :  0  <  fac  n  :=  by\n  induction  n\n  case  zero  =>\n  rw  [fac]\n  exact  zero_lt_one\n  case  succ  n  ih  =>\n  rw  [fac]\n  exact  mul_pos  n.succ_pos  ih\n\nexample  (n  :  ℕ)  :  0  <  fac  n  :=  by\n  induction  n  with\n  |  zero  =>\n  rw  [fac]\n  exact  zero_lt_one\n  |  succ  n  ih  =>\n  rw  [fac]\n  exact  mul_pos  n.succ_pos  ih \n```", "```py\ntheorem  fac_pos'  :  ∀  n,  0  <  fac  n\n  |  0  =>  by\n  rw  [fac]\n  exact  zero_lt_one\n  |  n  +  1  =>  by\n  rw  [fac]\n  exact  mul_pos  n.succ_pos  (fac_pos'  n) \n```", "```py\n@[simp]  def  fib  :  ℕ  →  ℕ\n  |  0  =>  0\n  |  1  =>  1\n  |  n  +  2  =>  fib  n  +  fib  (n  +  1) \n```", "```py\ntheorem  fib_add_two  (n  :  ℕ)  :  fib  (n  +  2)  =  fib  n  +  fib  (n  +  1)  :=  rfl\n\nexample  (n  :  ℕ)  :  fib  (n  +  2)  =  fib  n  +  fib  (n  +  1)  :=  by  rw  [fib] \n```", "```py\nnoncomputable  section\n\ndef  phi  :  ℝ  :=  (1  +  √5)  /  2\ndef  phi'  :  ℝ  :=  (1  -  √5)  /  2\n\ntheorem  phi_sq  :  phi^2  =  phi  +  1  :=  by\n  field_simp  [phi,  add_sq];  ring\n\ntheorem  phi'_sq  :  phi'^2  =  phi'  +  1  :=  by\n  field_simp  [phi',  sub_sq];  ring\n\ntheorem  fib_eq  :  ∀  n,  fib  n  =  (phi^n  -  phi'^n)  /  √5\n  |  0  =>  by  simp\n  |  1  =>  by  field_simp  [phi,  phi']\n  |  n+2  =>  by  field_simp  [fib_eq,  pow_add,  phi_sq,  phi'_sq];  ring\n\nend \n```", "```py\ntheorem  fib_coprime_fib_succ  (n  :  ℕ)  :  Nat.Coprime  (fib  n)  (fib  (n  +  1))  :=  by\n  induction  n  with\n  |  zero  =>  simp\n  |  succ  n  ih  =>\n  simp  only  [fib,  Nat.coprime_add_self_right]\n  exact  ih.symm \n```", "```py\n#eval  fib  6\n#eval  List.range  20  |>.map  fib \n```", "```py\ndef  fib'  (n  :  Nat)  :  Nat  :=\n  aux  n  0  1\nwhere  aux\n  |  0,  x,  _  =>  x\n  |  n+1,  x,  y  =>  aux  n  y  (x  +  y)\n\ntheorem  fib'.aux_eq  (m  n  :  ℕ)  :  fib'.aux  n  (fib  m)  (fib  (m  +  1))  =  fib  (n  +  m)  :=  by\n  induction  n  generalizing  m  with\n  |  zero  =>  simp  [fib'.aux]\n  |  succ  n  ih  =>  rw  [fib'.aux,  ←fib_add_two,  ih,  add_assoc,  add_comm  1]\n\ntheorem  fib'_eq_fib  :  fib'  =  fib  :=  by\n  ext  n\n  erw  [fib',  fib'.aux_eq  0  n];  rfl\n\n#eval  fib'  10000 \n```", "```py\ntheorem  fib_add  (m  n  :  ℕ)  :  fib  (m  +  n  +  1)  =  fib  m  *  fib  n  +  fib  (m  +  1)  *  fib  (n  +  1)  :=  by\n  induction  n  generalizing  m  with\n  |  zero  =>  simp\n  |  succ  n  ih  =>\n  specialize  ih  (m  +  1)\n  rw  [add_assoc  m  1  n,  add_comm  1  n]  at  ih\n  simp  only  [fib_add_two,  Nat.succ_eq_add_one,  ih]\n  ring\n\ntheorem  fib_add'  :  ∀  m  n,  fib  (m  +  n  +  1)  =  fib  m  *  fib  n  +  fib  (m  +  1)  *  fib  (n  +  1)\n  |  _,  0  =>  by  simp\n  |  m,  n  +  1  =>  by\n  have  :=  fib_add'  (m  +  1)  n\n  rw  [add_assoc  m  1  n,  add_comm  1  n]  at  this\n  simp  only  [fib_add_two,  Nat.succ_eq_add_one,  this]\n  ring \n```", "```py\nexample  (n  :  ℕ):  (fib  n)  ^  2  +  (fib  (n  +  1))  ^  2  =  fib  (2  *  n  +  1)  :=  by  sorry \n```", "```py\n#check  (@Nat.not_prime_iff_exists_dvd_lt  :\n  ∀  {n  :  ℕ},  2  ≤  n  →  (¬Nat.Prime  n  ↔  ∃  m,  m  ∣  n  ∧  2  ≤  m  ∧  m  <  n))\n\ntheorem  ne_one_iff_exists_prime_dvd  :  ∀  {n},  n  ≠  1  ↔  ∃  p  :  ℕ,  p.Prime  ∧  p  ∣  n\n  |  0  =>  by  simpa  using  Exists.intro  2  Nat.prime_two\n  |  1  =>  by  simp  [Nat.not_prime_one]\n  |  n  +  2  =>  by\n  have  hn  :  n+2  ≠  1  :=  by  omega\n  simp  only  [Ne,  not_false_iff,  true_iff,  hn]\n  by_cases  h  :  Nat.Prime  (n  +  2)\n  ·  use  n+2,  h\n  ·  have  :  2  ≤  n  +  2  :=  by  omega\n  rw  [Nat.not_prime_iff_exists_dvd_lt  this]  at  h\n  rcases  h  with  ⟨m,  mdvdn,  mge2,  -⟩\n  have  :  m  ≠  1  :=  by  omega\n  rw  [ne_one_iff_exists_prime_dvd]  at  this\n  rcases  this  with  ⟨p,  primep,  pdvdm⟩\n  use  p,  primep\n  exact  pdvdm.trans  mdvdn \n```", "```py\ntheorem  zero_lt_of_mul_eq_one  (m  n  :  ℕ)  :  n  *  m  =  1  →  0  <  n  ∧  0  <  m  :=  by\n  cases  n  <;>  cases  m  <;>  simp\n\nexample  (m  n  :  ℕ)  :  n*m  =  1  →  0  <  n  ∧  0  <  m  :=  by\n  rcases  m  with  (_  |  m);  simp\n  rcases  n  with  (_  |  n)  <;>  simp \n```"]