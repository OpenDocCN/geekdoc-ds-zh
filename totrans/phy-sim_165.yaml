- en: Constraint Solver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://phys-sim-book.github.io/lec31.4-solver.html](https://phys-sim-book.github.io/lec31.4-solver.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  prefs: []
  type: TYPE_NORMAL
- en: The heart of the PBD algorithm is the constraint solver, which iteratively projects
    the predicted particle positions to satisfy the defined constraints. Since this
    projection must be done in a physically plausible manner, ideally conserving the
    system's total linear and angular momentum for internal constraints, we employ
    a nonlinear Gauss-Seidel Solver.
  prefs: []
  type: TYPE_NORMAL
- en: '[Constraint Projection: Momentum Conservation](#constraint-projection-momentum-conservation)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To keep things as physically plausible as possible we make sure that for any
    internal constraint, the correction step should not introduce fictitious external
    forces, often referred to as "ghost forces." This is achieved by ensuring that
    the net change in linear and angular momentum is zero. Let Δpi​ be the position
    correction for particle i. Linear momentum is conserved if the center of mass
    remains unchanged by the correction:'
  prefs: []
  type: TYPE_NORMAL
- en: i∑​mi​Δpi​=0
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular momentum is conserved if the net torque produced by the corrections
    is zero with respect to a common center of rotation c:'
  prefs: []
  type: TYPE_NORMAL
- en: i∑​(pi​−c)×(mi​Δpi​)=0
  prefs: []
  type: TYPE_NORMAL
- en: '***Remark 32.4.1 (Constraint Gradient).*** A key insight is that if the correction
    vector for the concatenated particle positions, Δp=[Δp1T​,…,ΔpnT​]T, is chosen
    to be parallel to the constraint gradient ∇p​C, that is: Δp⊤∇p​C=0 then for many
    common internal constraints (which are independent of rigid body transformations),
    both momenta are automatically conserved when particle masses are equal.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As such the correction for each particle will be assumed to be parallel to the
    constraint gradient. This choice is supported by the fact that since the gradient
    points in the direction of the steepest ascent of the constraint function, and
    thus moving in the opposite direction is the most direct way to reduce the constraint
    error.
  prefs: []
  type: TYPE_NORMAL
- en: '[Position Correction (General Constraints)](#position-correction-general-constraints)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider a single constraint C(p1​,…,pn​)=0 involving n particles. Given a
    set of predicted positions p that violate this constraint (i.e., C(p)=0), we
    seek a correction Δp such that C(p+Δp)=0. To make this tractable, we linearize
    the constraint function using a first-order Taylor expansion around the current
    positions p: C(p+Δp)C(p+Δp)​=C(p)+∇p​C(p)⊤Δp+O(∥Δp∥2)≻0,≈C(p)+∇p​C(p)⊤Δp≻0.​(32.4.1)​'
  prefs: []
  type: TYPE_NORMAL
- en: 'As established above, we restrict the correction to be in the direction of
    the constraint gradient. This allows us to define the correction for a single
    particle i in terms of a single unknown scalar λ, which acts as a Lagrange multiplier:
    Δpi​=−λwi​∇pi​​C(p)(32.4.2) where wi​=1/mi​ is the inverse mass, ensuring that
    lighter particles are displaced more. The negative sign is a convention to align
    λ with the concept of a repulsive force for a positive constraint violation. In
    vector form for all involved particles, this is Δp=−λM−1∇p​C, where M is the diagonal
    mass matrix.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the value of λ, we substitute the correction from Equation [(32.4.2)](#eq:solver:correction_form)
    back into the linearized constraint, Equation [(32.4.1)](#eq:pbd:linearized_constraint).
    For an equality constraint, this becomes: C(p)+∇p​C(p)⊤(−λM−1∇p​C(p))=0 Solving
    for the Lagrange multiplier λ yields: λ=∑j=1n​wj​∥∇pj​​C(p)∥2C(p)​(32.4.3) With
    λ determined, the position correction Δpi​ for each particle is fully defined.
    We can also write the full correction in a single expression by substituting Equation
    [(32.4.3)](#eq:solver:lambda) into Equation [(32.4.2)](#eq:solver:correction_form):
    Δpi​=−∑j=1n​wj​∥∇pj​​C∥2C(p1​,…,pn​)​wi​∇pi​​C(p)(32.4.4) This equation is the
    cornerstone of the PBD solver. It provides a direct, computationally efficient
    method to calculate the position corrections required to satisfy a single linearized
    constraint while respecting particle masses. This projection is solved multiple
    times for each constraint within a single time step. It is important to note that
    for constraints that are linear along their gradient, such as a simple distance
    constraint, this linearization is exact, and the constraint can be satisfied in
    a single step.'
  prefs: []
  type: TYPE_NORMAL
- en: '****Example 32.4.1 (Distance Constraint).**** Let us consider one of the most
    fundamental constraints: the distance constraint, which enforces a fixed separation
    d between two particles, p1​ and p2​. This is a common building block used to
    model stretching resistance in springs, the edges of a cloth mesh, or rigid links
    between objects.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The constraint function is defined as the difference between the current distance
    and the desired rest distance d: C(p1​,p2​)=∥p1​−p2​∥−d This function directly
    measures the error that needs to be corrected. While the general projection method
    from Equation [(32.4.4)](#eq:pbd:final_correction) can be applied, for this specific
    and common case, the result simplifies to a very intuitive form. The final position
    corrections for each particle are given directly by: Δp1​Δp2​​=−w1​+w2​w1​​(∥p1​−p2​∥−d)∥p1​−p2​∥p1​−p2​​=+w1​+w2​w2​​(∥p1​−p2​∥−d)∥p1​−p2​∥p1​−p2​​​​​
    The term (∥p1​−p2​∥−d) represents the total correction magnitude needed along
    the vector connecting the particles. This total correction is then distributed
    between the two particles based on their inverse mass ratio, wi​/(w1​+w2​). The
    correction is applied along the unit vector (p1​−p2​)/∥p1​−p2​∥, moving the particles
    towards each other if they are too far apart (C>0) and away from each other if
    they are too close (C<0). This formulation directly satisfies the conservation
    of linear momentum!'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Hierarchical Solver](#hierarchical-solver)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The standard Gauss-Seidel solver in PBD exhibits slow convergence for low-frequency,
    large-scale deformations because corrections propagate only locally. To accelerate
    this, Hierarchical Position Based Dynamics (HPBD) [[Müller 2008]](bibliography.html#muller2008hierarchical)
    introduces a multi-resolution approach. The system is represented as a hierarchy
    of meshes, from coarse to fine. The solver operates first on the coarsest levels,
    allowing corrections for large-scale errors to propagate rapidly across the entire
    object. These corrections are then transferred and refined on successively finer
    levels in a single coarse-to-fine pass via interpolation (prolongation). This
    multigrid-inspired technique significantly improves convergence speed. For this
    to work correctly, constraints on the coarse levels must be unilateral (inequality
    constraints), resisting only stretching, to avoid artificially restricting large-scale
    bending and folding of the object.
  prefs: []
  type: TYPE_NORMAL
