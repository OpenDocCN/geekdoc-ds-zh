["```py\n#check  ∀  x  :  ℝ,  0  ≤  x  →  |x|  =  x \n```", "```py\n#check  ∀  x  y  ε  :  ℝ,  0  <  ε  →  ε  ≤  1  →  |x|  <  ε  →  |y|  <  ε  →  |x  *  y|  <  ε \n```", "```py\ntheorem  my_lemma  :  ∀  x  y  ε  :  ℝ,  0  <  ε  →  ε  ≤  1  →  |x|  <  ε  →  |y|  <  ε  →  |x  *  y|  <  ε  :=\n  sorry\n\nsection\nvariable  (a  b  δ  :  ℝ)\nvariable  (h₀  :  0  <  δ)  (h₁  :  δ  ≤  1)\nvariable  (ha  :  |a|  <  δ)  (hb  :  |b|  <  δ)\n\n#check  my_lemma  a  b  δ\n#check  my_lemma  a  b  δ  h₀  h₁\n#check  my_lemma  a  b  δ  h₀  h₁  ha  hb\n\nend \n```", "```py\ntheorem  my_lemma2  :  ∀  {x  y  ε  :  ℝ},  0  <  ε  →  ε  ≤  1  →  |x|  <  ε  →  |y|  <  ε  →  |x  *  y|  <  ε  :=\n  sorry\n\nsection\nvariable  (a  b  δ  :  ℝ)\nvariable  (h₀  :  0  <  δ)  (h₁  :  δ  ≤  1)\nvariable  (ha  :  |a|  <  δ)  (hb  :  |b|  <  δ)\n\n#check  my_lemma2  h₀  h₁  ha  hb\n\nend \n```", "```py\ntheorem  my_lemma3  :\n  ∀  {x  y  ε  :  ℝ},  0  <  ε  →  ε  ≤  1  →  |x|  <  ε  →  |y|  <  ε  →  |x  *  y|  <  ε  :=  by\n  intro  x  y  ε  epos  ele1  xlt  ylt\n  sorry \n```", "```py\ntheorem  my_lemma4  :\n  ∀  {x  y  ε  :  ℝ},  0  <  ε  →  ε  ≤  1  →  |x|  <  ε  →  |y|  <  ε  →  |x  *  y|  <  ε  :=  by\n  intro  x  y  ε  epos  ele1  xlt  ylt\n  calc\n  |x  *  y|  =  |x|  *  |y|  :=  sorry\n  _  ≤  |x|  *  ε  :=  sorry\n  _  <  1  *  ε  :=  sorry\n  _  =  ε  :=  sorry \n```", "```py\ndef  FnUb  (f  :  ℝ  →  ℝ)  (a  :  ℝ)  :  Prop  :=\n  ∀  x,  f  x  ≤  a\n\ndef  FnLb  (f  :  ℝ  →  ℝ)  (a  :  ℝ)  :  Prop  :=\n  ∀  x,  a  ≤  f  x \n```", "```py\nexample  (hfa  :  FnUb  f  a)  (hgb  :  FnUb  g  b)  :  FnUb  (fun  x  ↦  f  x  +  g  x)  (a  +  b)  :=  by\n  intro  x\n  dsimp\n  apply  add_le_add\n  apply  hfa\n  apply  hgb \n```", "```py\nexample  (hfa  :  FnLb  f  a)  (hgb  :  FnLb  g  b)  :  FnLb  (fun  x  ↦  f  x  +  g  x)  (a  +  b)  :=\n  sorry\n\nexample  (nnf  :  FnLb  f  0)  (nng  :  FnLb  g  0)  :  FnLb  (fun  x  ↦  f  x  *  g  x)  0  :=\n  sorry\n\nexample  (hfa  :  FnUb  f  a)  (hgb  :  FnUb  g  b)  (nng  :  FnLb  g  0)  (nna  :  0  ≤  a)  :\n  FnUb  (fun  x  ↦  f  x  *  g  x)  (a  *  b)  :=\n  sorry \n```", "```py\nvariable  {α  :  Type*}  {R  :  Type*}  [AddCommMonoid  R]  [PartialOrder  R]  [IsOrderedCancelAddMonoid  R]\n\n#check  add_le_add\n\ndef  FnUb'  (f  :  α  →  R)  (a  :  R)  :  Prop  :=\n  ∀  x,  f  x  ≤  a\n\ntheorem  fnUb_add  {f  g  :  α  →  R}  {a  b  :  R}  (hfa  :  FnUb'  f  a)  (hgb  :  FnUb'  g  b)  :\n  FnUb'  (fun  x  ↦  f  x  +  g  x)  (a  +  b)  :=  fun  x  ↦  add_le_add  (hfa  x)  (hgb  x) \n```", "```py\nexample  (f  :  ℝ  →  ℝ)  (h  :  Monotone  f)  :  ∀  {a  b},  a  ≤  b  →  f  a  ≤  f  b  :=\n  @h \n```", "```py\nexample  (mf  :  Monotone  f)  (mg  :  Monotone  g)  :  Monotone  fun  x  ↦  f  x  +  g  x  :=  by\n  intro  a  b  aleb\n  apply  add_le_add\n  apply  mf  aleb\n  apply  mg  aleb \n```", "```py\nexample  (mf  :  Monotone  f)  (mg  :  Monotone  g)  :  Monotone  fun  x  ↦  f  x  +  g  x  :=\n  fun  a  b  aleb  ↦  add_le_add  (mf  aleb)  (mg  aleb) \n```", "```py\nexample  {c  :  ℝ}  (mf  :  Monotone  f)  (nnc  :  0  ≤  c)  :  Monotone  fun  x  ↦  c  *  f  x  :=\n  sorry\n\nexample  (mf  :  Monotone  f)  (mg  :  Monotone  g)  :  Monotone  fun  x  ↦  f  (g  x)  :=\n  sorry \n```", "```py\ndef  FnEven  (f  :  ℝ  →  ℝ)  :  Prop  :=\n  ∀  x,  f  x  =  f  (-x)\n\ndef  FnOdd  (f  :  ℝ  →  ℝ)  :  Prop  :=\n  ∀  x,  f  x  =  -f  (-x)\n\nexample  (ef  :  FnEven  f)  (eg  :  FnEven  g)  :  FnEven  fun  x  ↦  f  x  +  g  x  :=  by\n  intro  x\n  calc\n  (fun  x  ↦  f  x  +  g  x)  x  =  f  x  +  g  x  :=  rfl\n  _  =  f  (-x)  +  g  (-x)  :=  by  rw  [ef,  eg]\n\nexample  (of  :  FnOdd  f)  (og  :  FnOdd  g)  :  FnEven  fun  x  ↦  f  x  *  g  x  :=  by\n  sorry\n\nexample  (ef  :  FnEven  f)  (og  :  FnOdd  g)  :  FnOdd  fun  x  ↦  f  x  *  g  x  :=  by\n  sorry\n\nexample  (ef  :  FnEven  f)  (og  :  FnOdd  g)  :  FnEven  fun  x  ↦  f  (g  x)  :=  by\n  sorry \n```", "```py\nvariable  {α  :  Type*}  (r  s  t  :  Set  α)\n\nexample  :  s  ⊆  s  :=  by\n  intro  x  xs\n  exact  xs\n\ntheorem  Subset.refl  :  s  ⊆  s  :=  fun  x  xs  ↦  xs\n\ntheorem  Subset.trans  :  r  ⊆  s  →  s  ⊆  t  →  r  ⊆  t  :=  by\n  sorry \n```", "```py\nvariable  {α  :  Type*}  [PartialOrder  α]\nvariable  (s  :  Set  α)  (a  b  :  α)\n\ndef  SetUb  (s  :  Set  α)  (a  :  α)  :=\n  ∀  x,  x  ∈  s  →  x  ≤  a\n\nexample  (h  :  SetUb  s  a)  (h'  :  a  ≤  b)  :  SetUb  s  b  :=\n  sorry \n```", "```py\nopen  Function\n\nexample  (c  :  ℝ)  :  Injective  fun  x  ↦  x  +  c  :=  by\n  intro  x₁  x₂  h'\n  exact  (add_left_inj  c).mp  h'\n\nexample  {c  :  ℝ}  (h  :  c  ≠  0)  :  Injective  fun  x  ↦  c  *  x  :=  by\n  sorry \n```", "```py\nvariable  {α  :  Type*}  {β  :  Type*}  {γ  :  Type*}\nvariable  {g  :  β  →  γ}  {f  :  α  →  β}\n\nexample  (injg  :  Injective  g)  (injf  :  Injective  f)  :  Injective  fun  x  ↦  g  (f  x)  :=  by\n  sorry \n```", "```py\nexample  :  ∃  x  :  ℝ,  2  <  x  ∧  x  <  3  :=  by\n  use  5  /  2\n  norm_num \n```", "```py\nexample  :  ∃  x  :  ℝ,  2  <  x  ∧  x  <  3  :=  by\n  have  h1  :  2  <  (5  :  ℝ)  /  2  :=  by  norm_num\n  have  h2  :  (5  :  ℝ)  /  2  <  3  :=  by  norm_num\n  use  5  /  2,  h1,  h2 \n```", "```py\nexample  :  ∃  x  :  ℝ,  2  <  x  ∧  x  <  3  :=  by\n  have  h  :  2  <  (5  :  ℝ)  /  2  ∧  (5  :  ℝ)  /  2  <  3  :=  by  norm_num\n  use  5  /  2 \n```", "```py\nexample  :  ∃  x  :  ℝ,  2  <  x  ∧  x  <  3  :=\n  have  h  :  2  <  (5  :  ℝ)  /  2  ∧  (5  :  ℝ)  /  2  <  3  :=  by  norm_num\n  ⟨5  /  2,  h⟩ \n```", "```py\nexample  :  ∃  x  :  ℝ,  2  <  x  ∧  x  <  3  :=\n  ⟨5  /  2,  by  norm_num⟩ \n```", "```py\ndef  FnUb  (f  :  ℝ  →  ℝ)  (a  :  ℝ)  :  Prop  :=\n  ∀  x,  f  x  ≤  a\n\ndef  FnLb  (f  :  ℝ  →  ℝ)  (a  :  ℝ)  :  Prop  :=\n  ∀  x,  a  ≤  f  x\n\ndef  FnHasUb  (f  :  ℝ  →  ℝ)  :=\n  ∃  a,  FnUb  f  a\n\ndef  FnHasLb  (f  :  ℝ  →  ℝ)  :=\n  ∃  a,  FnLb  f  a \n```", "```py\nvariable  {f  g  :  ℝ  →  ℝ}\n\nexample  (ubf  :  FnHasUb  f)  (ubg  :  FnHasUb  g)  :  FnHasUb  fun  x  ↦  f  x  +  g  x  :=  by\n  rcases  ubf  with  ⟨a,  ubfa⟩\n  rcases  ubg  with  ⟨b,  ubgb⟩\n  use  a  +  b\n  apply  fnUb_add  ubfa  ubgb \n```", "```py\nexample  (lbf  :  FnHasLb  f)  (lbg  :  FnHasLb  g)  :  FnHasLb  fun  x  ↦  f  x  +  g  x  :=  by\n  sorry\n\nexample  {c  :  ℝ}  (ubf  :  FnHasUb  f)  (h  :  c  ≥  0)  :  FnHasUb  fun  x  ↦  c  *  f  x  :=  by\n  sorry \n```", "```py\nexample  :  FnHasUb  f  →  FnHasUb  g  →  FnHasUb  fun  x  ↦  f  x  +  g  x  :=  by\n  rintro  ⟨a,  ubfa⟩  ⟨b,  ubgb⟩\n  exact  ⟨a  +  b,  fnUb_add  ubfa  ubgb⟩ \n```", "```py\nexample  :  FnHasUb  f  →  FnHasUb  g  →  FnHasUb  fun  x  ↦  f  x  +  g  x  :=\n  fun  ⟨a,  ubfa⟩  ⟨b,  ubgb⟩  ↦  ⟨a  +  b,  fnUb_add  ubfa  ubgb⟩ \n```", "```py\nexample  (ubf  :  FnHasUb  f)  (ubg  :  FnHasUb  g)  :  FnHasUb  fun  x  ↦  f  x  +  g  x  :=  by\n  obtain  ⟨a,  ubfa⟩  :=  ubf\n  obtain  ⟨b,  ubgb⟩  :=  ubg\n  exact  ⟨a  +  b,  fnUb_add  ubfa  ubgb⟩ \n```", "```py\nexample  (ubf  :  FnHasUb  f)  (ubg  :  FnHasUb  g)  :  FnHasUb  fun  x  ↦  f  x  +  g  x  :=  by\n  cases  ubf\n  case  intro  a  ubfa  =>\n  cases  ubg\n  case  intro  b  ubgb  =>\n  exact  ⟨a  +  b,  fnUb_add  ubfa  ubgb⟩\n\nexample  (ubf  :  FnHasUb  f)  (ubg  :  FnHasUb  g)  :  FnHasUb  fun  x  ↦  f  x  +  g  x  :=  by\n  cases  ubf\n  next  a  ubfa  =>\n  cases  ubg\n  next  b  ubgb  =>\n  exact  ⟨a  +  b,  fnUb_add  ubfa  ubgb⟩\n\nexample  (ubf  :  FnHasUb  f)  (ubg  :  FnHasUb  g)  :  FnHasUb  fun  x  ↦  f  x  +  g  x  :=  by\n  match  ubf,  ubg  with\n  |  ⟨a,  ubfa⟩,  ⟨b,  ubgb⟩  =>\n  exact  ⟨a  +  b,  fnUb_add  ubfa  ubgb⟩\n\nexample  (ubf  :  FnHasUb  f)  (ubg  :  FnHasUb  g)  :  FnHasUb  fun  x  ↦  f  x  +  g  x  :=\n  match  ubf,  ubg  with\n  |  ⟨a,  ubfa⟩,  ⟨b,  ubgb⟩  =>\n  ⟨a  +  b,  fnUb_add  ubfa  ubgb⟩ \n```", "```py\nvariable  {α  :  Type*}  [CommRing  α]\n\ndef  SumOfSquares  (x  :  α)  :=\n  ∃  a  b,  x  =  a  ^  2  +  b  ^  2\n\ntheorem  sumOfSquares_mul  {x  y  :  α}  (sosx  :  SumOfSquares  x)  (sosy  :  SumOfSquares  y)  :\n  SumOfSquares  (x  *  y)  :=  by\n  rcases  sosx  with  ⟨a,  b,  xeq⟩\n  rcases  sosy  with  ⟨c,  d,  yeq⟩\n  rw  [xeq,  yeq]\n  use  a  *  c  -  b  *  d,  a  *  d  +  b  *  c\n  ring \n```", "```py\ntheorem  sumOfSquares_mul'  {x  y  :  α}  (sosx  :  SumOfSquares  x)  (sosy  :  SumOfSquares  y)  :\n  SumOfSquares  (x  *  y)  :=  by\n  rcases  sosx  with  ⟨a,  b,  rfl⟩\n  rcases  sosy  with  ⟨c,  d,  rfl⟩\n  use  a  *  c  -  b  *  d,  a  *  d  +  b  *  c\n  ring \n```", "```py\nexample  (divab  :  a  ∣  b)  (divbc  :  b  ∣  c)  :  a  ∣  c  :=  by\n  rcases  divab  with  ⟨d,  beq⟩\n  rcases  divbc  with  ⟨e,  ceq⟩\n  rw  [ceq,  beq]\n  use  d  *  e;  ring \n```", "```py\nexample  (divab  :  a  ∣  b)  (divac  :  a  ∣  c)  :  a  ∣  b  +  c  :=  by\n  sorry \n```", "```py\nexample  {c  :  ℝ}  :  Surjective  fun  x  ↦  x  +  c  :=  by\n  intro  x\n  use  x  -  c\n  dsimp;  ring \n```", "```py\nexample  {c  :  ℝ}  (h  :  c  ≠  0)  :  Surjective  fun  x  ↦  c  *  x  :=  by\n  sorry \n```", "```py\nexample  (x  y  :  ℝ)  (h  :  x  -  y  ≠  0)  :  (x  ^  2  -  y  ^  2)  /  (x  -  y)  =  x  +  y  :=  by\n  field_simp  [h]\n  ring \n```", "```py\nexample  {f  :  ℝ  →  ℝ}  (h  :  Surjective  f)  :  ∃  x,  f  x  ^  2  =  4  :=  by\n  rcases  h  2  with  ⟨x,  hx⟩\n  use  x\n  rw  [hx]\n  norm_num \n```", "```py\nvariable  {α  :  Type*}  {β  :  Type*}  {γ  :  Type*}\nvariable  {g  :  β  →  γ}  {f  :  α  →  β}\n\nexample  (surjg  :  Surjective  g)  (surjf  :  Surjective  f)  :  Surjective  fun  x  ↦  g  (f  x)  :=  by\n  sorry \n```", "```py\nexample  (h  :  a  <  b)  :  ¬b  <  a  :=  by\n  intro  h'\n  have  :  a  <  a  :=  lt_trans  h  h'\n  apply  lt_irrefl  a  this \n```", "```py\nexample  (h  :  ∀  a,  ∃  x,  f  x  >  a)  :  ¬FnHasUb  f  :=  by\n  intro  fnub\n  rcases  fnub  with  ⟨a,  fnuba⟩\n  rcases  h  a  with  ⟨x,  hx⟩\n  have  :  f  x  ≤  a  :=  fnuba  x\n  linarith \n```", "```py\nexample  (h  :  ∀  a,  ∃  x,  f  x  <  a)  :  ¬FnHasLb  f  :=\n  sorry\n\nexample  :  ¬FnHasUb  fun  x  ↦  x  :=\n  sorry \n```", "```py\n#check  (not_le_of_gt  :  a  >  b  →  ¬a  ≤  b)\n#check  (not_lt_of_ge  :  a  ≥  b  →  ¬a  <  b)\n#check  (lt_of_not_ge  :  ¬a  ≥  b  →  a  <  b)\n#check  (le_of_not_gt  :  ¬a  >  b  →  a  ≤  b) \n```", "```py\nexample  (h  :  Monotone  f)  (h'  :  f  a  <  f  b)  :  a  <  b  :=  by\n  sorry\n\nexample  (h  :  a  ≤  b)  (h'  :  f  b  <  f  a)  :  ¬Monotone  f  :=  by\n  sorry \n```", "```py\nexample  :  ¬∀  {f  :  ℝ  →  ℝ},  Monotone  f  →  ∀  {a  b},  f  a  ≤  f  b  →  a  ≤  b  :=  by\n  intro  h\n  let  f  :=  fun  x  :  ℝ  ↦  (0  :  ℝ)\n  have  monof  :  Monotone  f  :=  by  sorry\n  have  h'  :  f  1  ≤  f  0  :=  le_refl  _\n  sorry \n```", "```py\nexample  (x  :  ℝ)  (h  :  ∀  ε  >  0,  x  <  ε)  :  x  ≤  0  :=  by\n  sorry \n```", "```py\nvariable  {α  :  Type*}  (P  :  α  →  Prop)  (Q  :  Prop)\n\nexample  (h  :  ¬∃  x,  P  x)  :  ∀  x,  ¬P  x  :=  by\n  sorry\n\nexample  (h  :  ∀  x,  ¬P  x)  :  ¬∃  x,  P  x  :=  by\n  sorry\n\nexample  (h  :  ¬∀  x,  P  x)  :  ∃  x,  ¬P  x  :=  by\n  sorry\n\nexample  (h  :  ∃  x,  ¬P  x)  :  ¬∀  x,  P  x  :=  by\n  sorry \n```", "```py\nexample  (h  :  ¬∀  x,  P  x)  :  ∃  x,  ¬P  x  :=  by\n  by_contra  h'\n  apply  h\n  intro  x\n  show  P  x\n  by_contra  h''\n  exact  h'  ⟨x,  h''⟩ \n```", "```py\nexample  (h  :  ¬¬Q)  :  Q  :=  by\n  sorry\n\nexample  (h  :  Q)  :  ¬¬Q  :=  by\n  sorry \n```", "```py\nexample  (h  :  ¬FnHasUb  f)  :  ∀  a,  ∃  x,  f  x  >  a  :=  by\n  sorry \n```", "```py\nexample  (h  :  ¬∀  a,  ∃  x,  f  x  >  a)  :  FnHasUb  f  :=  by\n  push_neg  at  h\n  exact  h\n\nexample  (h  :  ¬FnHasUb  f)  :  ∀  a,  ∃  x,  f  x  >  a  :=  by\n  dsimp  only  [FnHasUb,  FnUb]  at  h\n  push_neg  at  h\n  exact  h \n```", "```py\nexample  (h  :  ¬Monotone  f)  :  ∃  x  y,  x  ≤  y  ∧  f  y  <  f  x  :=  by\n  sorry \n```", "```py\nexample  (h  :  ¬FnHasUb  f)  :  ∀  a,  ∃  x,  f  x  >  a  :=  by\n  contrapose!  h\n  exact  h\n\nexample  (x  :  ℝ)  (h  :  ∀  ε  >  0,  x  ≤  ε)  :  x  ≤  0  :=  by\n  contrapose!  h\n  use  x  /  2\n  constructor  <;>  linarith \n```", "```py\nexample  (h  :  0  <  0)  :  a  >  37  :=  by\n  exfalso\n  apply  lt_irrefl  0  h\n\nexample  (h  :  0  <  0)  :  a  >  37  :=\n  absurd  h  (lt_irrefl  0)\n\nexample  (h  :  0  <  0)  :  a  >  37  :=  by\n  have  h'  :  ¬0  <  0  :=  lt_irrefl  0\n  contradiction \n```", "```py\nexample  {x  y  :  ℝ}  (h₀  :  x  ≤  y)  (h₁  :  ¬y  ≤  x)  :  x  ≤  y  ∧  x  ≠  y  :=  by\n  constructor\n  ·  assumption\n  intro  h\n  apply  h₁\n  rw  [h] \n```", "```py\nexample  {x  y  :  ℝ}  (h₀  :  x  ≤  y)  (h₁  :  ¬y  ≤  x)  :  x  ≤  y  ∧  x  ≠  y  :=\n  ⟨h₀,  fun  h  ↦  h₁  (by  rw  [h])⟩\n\nexample  {x  y  :  ℝ}  (h₀  :  x  ≤  y)  (h₁  :  ¬y  ≤  x)  :  x  ≤  y  ∧  x  ≠  y  :=\n  have  h  :  x  ≠  y  :=  by\n  contrapose!  h₁\n  rw  [h₁]\n  ⟨h₀,  h⟩ \n```", "```py\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y  ∧  x  ≠  y)  :  ¬y  ≤  x  :=  by\n  rcases  h  with  ⟨h₀,  h₁⟩\n  contrapose!  h₁\n  exact  le_antisymm  h₀  h₁\n\nexample  {x  y  :  ℝ}  :  x  ≤  y  ∧  x  ≠  y  →  ¬y  ≤  x  :=  by\n  rintro  ⟨h₀,  h₁⟩  h'\n  exact  h₁  (le_antisymm  h₀  h')\n\nexample  {x  y  :  ℝ}  :  x  ≤  y  ∧  x  ≠  y  →  ¬y  ≤  x  :=\n  fun  ⟨h₀,  h₁⟩  h'  ↦  h₁  (le_antisymm  h₀  h') \n```", "```py\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y  ∧  x  ≠  y)  :  ¬y  ≤  x  :=  by\n  have  ⟨h₀,  h₁⟩  :=  h\n  contrapose!  h₁\n  exact  le_antisymm  h₀  h₁ \n```", "```py\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y  ∧  x  ≠  y)  :  ¬y  ≤  x  :=  by\n  cases  h\n  case  intro  h₀  h₁  =>\n  contrapose!  h₁\n  exact  le_antisymm  h₀  h₁\n\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y  ∧  x  ≠  y)  :  ¬y  ≤  x  :=  by\n  cases  h\n  next  h₀  h₁  =>\n  contrapose!  h₁\n  exact  le_antisymm  h₀  h₁\n\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y  ∧  x  ≠  y)  :  ¬y  ≤  x  :=  by\n  match  h  with\n  |  ⟨h₀,  h₁⟩  =>\n  contrapose!  h₁\n  exact  le_antisymm  h₀  h₁ \n```", "```py\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y  ∧  x  ≠  y)  :  ¬y  ≤  x  :=  by\n  intro  h'\n  apply  h.right\n  exact  le_antisymm  h.left  h'\n\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y  ∧  x  ≠  y)  :  ¬y  ≤  x  :=\n  fun  h'  ↦  h.right  (le_antisymm  h.left  h') \n```", "```py\nexample  {m  n  :  ℕ}  (h  :  m  ∣  n  ∧  m  ≠  n)  :  m  ∣  n  ∧  ¬n  ∣  m  :=\n  sorry \n```", "```py\nexample  :  ∃  x  :  ℝ,  2  <  x  ∧  x  <  4  :=\n  ⟨5  /  2,  by  norm_num,  by  norm_num⟩\n\nexample  (x  y  :  ℝ)  :  (∃  z  :  ℝ,  x  <  z  ∧  z  <  y)  →  x  <  y  :=  by\n  rintro  ⟨z,  xltz,  zlty⟩\n  exact  lt_trans  xltz  zlty\n\nexample  (x  y  :  ℝ)  :  (∃  z  :  ℝ,  x  <  z  ∧  z  <  y)  →  x  <  y  :=\n  fun  ⟨z,  xltz,  zlty⟩  ↦  lt_trans  xltz  zlty \n```", "```py\nexample  :  ∃  x  :  ℝ,  2  <  x  ∧  x  <  4  :=  by\n  use  5  /  2\n  constructor  <;>  norm_num\n\nexample  :  ∃  m  n  :  ℕ,  4  <  m  ∧  m  <  n  ∧  n  <  10  ∧  Nat.Prime  m  ∧  Nat.Prime  n  :=  by\n  use  5\n  use  7\n  norm_num\n\nexample  {x  y  :  ℝ}  :  x  ≤  y  ∧  x  ≠  y  →  x  ≤  y  ∧  ¬y  ≤  x  :=  by\n  rintro  ⟨h₀,  h₁⟩\n  use  h₀\n  exact  fun  h'  ↦  h₁  (le_antisymm  h₀  h') \n```", "```py\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y)  :  ¬y  ≤  x  ↔  x  ≠  y  :=  by\n  constructor\n  ·  contrapose!\n  rintro  rfl\n  rfl\n  contrapose!\n  exact  le_antisymm  h\n\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y)  :  ¬y  ≤  x  ↔  x  ≠  y  :=\n  ⟨fun  h₀  h₁  ↦  h₀  (by  rw  [h₁]),  fun  h₀  h₁  ↦  h₀  (le_antisymm  h  h₁)⟩ \n```", "```py\nexample  {x  y  :  ℝ}  :  x  ≤  y  ∧  ¬y  ≤  x  ↔  x  ≤  y  ∧  x  ≠  y  :=\n  sorry \n```", "```py\ntheorem  aux  {x  y  :  ℝ}  (h  :  x  ^  2  +  y  ^  2  =  0)  :  x  =  0  :=\n  have  h'  :  x  ^  2  =  0  :=  by  sorry\n  pow_eq_zero  h'\n\nexample  (x  y  :  ℝ)  :  x  ^  2  +  y  ^  2  =  0  ↔  x  =  0  ∧  y  =  0  :=\n  sorry \n```", "```py\nexample  (x  :  ℝ)  :  |x  +  3|  <  5  →  -8  <  x  ∧  x  <  2  :=  by\n  rw  [abs_lt]\n  intro  h\n  constructor  <;>  linarith\n\nexample  :  3  ∣  Nat.gcd  6  15  :=  by\n  rw  [Nat.dvd_gcd_iff]\n  constructor  <;>  norm_num \n```", "```py\ntheorem  not_monotone_iff  {f  :  ℝ  →  ℝ}  :  ¬Monotone  f  ↔  ∃  x  y,  x  ≤  y  ∧  f  x  >  f  y  :=  by\n  rw  [Monotone]\n  push_neg\n  rfl\n\nexample  :  ¬Monotone  fun  x  :  ℝ  ↦  -x  :=  by\n  sorry \n```", "```py\nvariable  {α  :  Type*}  [PartialOrder  α]\nvariable  (a  b  :  α)\n\nexample  :  a  <  b  ↔  a  ≤  b  ∧  a  ≠  b  :=  by\n  rw  [lt_iff_le_not_ge]\n  sorry \n```", "```py\nvariable  {α  :  Type*}  [Preorder  α]\nvariable  (a  b  c  :  α)\n\nexample  :  ¬a  <  a  :=  by\n  rw  [lt_iff_le_not_ge]\n  sorry\n\nexample  :  a  <  b  →  b  <  c  →  a  <  c  :=  by\n  simp  only  [lt_iff_le_not_ge]\n  sorry \n```", "```py\nvariable  {x  y  :  ℝ}\n\nexample  (h  :  y  >  x  ^  2)  :  y  >  0  ∨  y  <  -1  :=  by\n  left\n  linarith  [pow_two_nonneg  x]\n\nexample  (h  :  -y  >  x  ^  2  +  1)  :  y  >  0  ∨  y  <  -1  :=  by\n  right\n  linarith  [pow_two_nonneg  x] \n```", "```py\nexample  (h  :  y  >  0)  :  y  >  0  ∨  y  <  -1  :=\n  Or.inl  h\n\nexample  (h  :  y  <  -1)  :  y  >  0  ∨  y  <  -1  :=\n  Or.inr  h \n```", "```py\nexample  :  x  <  |y|  →  x  <  y  ∨  x  <  -y  :=  by\n  rcases  le_or_gt  0  y  with  h  |  h\n  ·  rw  [abs_of_nonneg  h]\n  intro  h;  left;  exact  h\n  ·  rw  [abs_of_neg  h]\n  intro  h;  right;  exact  h \n```", "```py\nexample  :  x  <  |y|  →  x  <  y  ∨  x  <  -y  :=  by\n  cases  le_or_gt  0  y\n  case  inl  h  =>\n  rw  [abs_of_nonneg  h]\n  intro  h;  left;  exact  h\n  case  inr  h  =>\n  rw  [abs_of_neg  h]\n  intro  h;  right;  exact  h \n```", "```py\nexample  :  x  <  |y|  →  x  <  y  ∨  x  <  -y  :=  by\n  cases  le_or_gt  0  y\n  next  h  =>\n  rw  [abs_of_nonneg  h]\n  intro  h;  left;  exact  h\n  next  h  =>\n  rw  [abs_of_neg  h]\n  intro  h;  right;  exact  h\n\nexample  :  x  <  |y|  →  x  <  y  ∨  x  <  -y  :=  by\n  match  le_or_gt  0  y  with\n  |  Or.inl  h  =>\n  rw  [abs_of_nonneg  h]\n  intro  h;  left;  exact  h\n  |  Or.inr  h  =>\n  rw  [abs_of_neg  h]\n  intro  h;  right;  exact  h \n```", "```py\nnamespace  MyAbs\n\ntheorem  le_abs_self  (x  :  ℝ)  :  x  ≤  |x|  :=  by\n  sorry\n\ntheorem  neg_le_abs_self  (x  :  ℝ)  :  -x  ≤  |x|  :=  by\n  sorry\n\ntheorem  abs_add  (x  y  :  ℝ)  :  |x  +  y|  ≤  |x|  +  |y|  :=  by\n  sorry \n```", "```py\ntheorem  lt_abs  :  x  <  |y|  ↔  x  <  y  ∨  x  <  -y  :=  by\n  sorry\n\ntheorem  abs_lt  :  |x|  <  y  ↔  -y  <  x  ∧  x  <  y  :=  by\n  sorry \n```", "```py\nexample  {x  :  ℝ}  (h  :  x  ≠  0)  :  x  <  0  ∨  x  >  0  :=  by\n  rcases  lt_trichotomy  x  0  with  xlt  |  xeq  |  xgt\n  ·  left\n  exact  xlt\n  ·  contradiction\n  ·  right;  exact  xgt \n```", "```py\nexample  {m  n  k  :  ℕ}  (h  :  m  ∣  n  ∨  m  ∣  k)  :  m  ∣  n  *  k  :=  by\n  rcases  h  with  ⟨a,  rfl⟩  |  ⟨b,  rfl⟩\n  ·  rw  [mul_assoc]\n  apply  dvd_mul_right\n  ·  rw  [mul_comm,  mul_assoc]\n  apply  dvd_mul_right \n```", "```py\nexample  {z  :  ℝ}  (h  :  ∃  x  y,  z  =  x  ^  2  +  y  ^  2  ∨  z  =  x  ^  2  +  y  ^  2  +  1)  :  z  ≥  0  :=  by\n  sorry \n```", "```py\nexample  {x  :  ℝ}  (h  :  x  ^  2  =  1)  :  x  =  1  ∨  x  =  -1  :=  by\n  sorry\n\nexample  {x  y  :  ℝ}  (h  :  x  ^  2  =  y  ^  2)  :  x  =  y  ∨  x  =  -y  :=  by\n  sorry \n```", "```py\nvariable  {R  :  Type*}  [CommRing  R]  [IsDomain  R]\nvariable  (x  y  :  R)\n\nexample  (h  :  x  ^  2  =  1)  :  x  =  1  ∨  x  =  -1  :=  by\n  sorry\n\nexample  (h  :  x  ^  2  =  y  ^  2)  :  x  =  y  ∨  x  =  -y  :=  by\n  sorry \n```", "```py\nexample  (P  :  Prop)  :  ¬¬P  →  P  :=  by\n  intro  h\n  cases  em  P\n  ·  assumption\n  ·  contradiction \n```", "```py\nexample  (P  :  Prop)  :  ¬¬P  →  P  :=  by\n  intro  h\n  by_cases  h'  :  P\n  ·  assumption\n  contradiction \n```", "```py\nexample  (P  Q  :  Prop)  :  P  →  Q  ↔  ¬P  ∨  Q  :=  by\n  sorry \n```", "```py\ndef  ConvergesTo  (s  :  ℕ  →  ℝ)  (a  :  ℝ)  :=\n  ∀  ε  >  0,  ∃  N,  ∀  n  ≥  N,  |s  n  -  a|  <  ε \n```", "```py\nexample  :  (fun  x  y  :  ℝ  ↦  (x  +  y)  ^  2)  =  fun  x  y  :  ℝ  ↦  x  ^  2  +  2  *  x  *  y  +  y  ^  2  :=  by\n  ext\n  ring \n```", "```py\nexample  (a  b  :  ℝ)  :  |a|  =  |a  -  b  +  b|  :=  by\n  congr\n  ring \n```", "```py\nexample  {a  :  ℝ}  (h  :  1  <  a)  :  a  <  a  *  a  :=  by\n  convert  (mul_lt_mul_right  _).2  h\n  ·  rw  [one_mul]\n  exact  lt_trans  zero_lt_one  h \n```", "```py\ntheorem  convergesTo_const  (a  :  ℝ)  :  ConvergesTo  (fun  x  :  ℕ  ↦  a)  a  :=  by\n  intro  ε  εpos\n  use  0\n  intro  n  nge\n  rw  [sub_self,  abs_zero]\n  apply  εpos \n```", "```py\ntheorem  convergesTo_add  {s  t  :  ℕ  →  ℝ}  {a  b  :  ℝ}\n  (cs  :  ConvergesTo  s  a)  (ct  :  ConvergesTo  t  b)  :\n  ConvergesTo  (fun  n  ↦  s  n  +  t  n)  (a  +  b)  :=  by\n  intro  ε  εpos\n  dsimp  -- this line is not needed but cleans up the goal a bit.\n  have  ε2pos  :  0  <  ε  /  2  :=  by  linarith\n  rcases  cs  (ε  /  2)  ε2pos  with  ⟨Ns,  hs⟩\n  rcases  ct  (ε  /  2)  ε2pos  with  ⟨Nt,  ht⟩\n  use  max  Ns  Nt\n  sorry \n```", "```py\ntheorem  convergesTo_mul_const  {s  :  ℕ  →  ℝ}  {a  :  ℝ}  (c  :  ℝ)  (cs  :  ConvergesTo  s  a)  :\n  ConvergesTo  (fun  n  ↦  c  *  s  n)  (c  *  a)  :=  by\n  by_cases  h  :  c  =  0\n  ·  convert  convergesTo_const  0\n  ·  rw  [h]\n  ring\n  rw  [h]\n  ring\n  have  acpos  :  0  <  |c|  :=  abs_pos.mpr  h\n  sorry \n```", "```py\ntheorem  exists_abs_le_of_convergesTo  {s  :  ℕ  →  ℝ}  {a  :  ℝ}  (cs  :  ConvergesTo  s  a)  :\n  ∃  N  b,  ∀  n,  N  ≤  n  →  |s  n|  <  b  :=  by\n  rcases  cs  1  zero_lt_one  with  ⟨N,  h⟩\n  use  N,  |a|  +  1\n  sorry \n```", "```py\ntheorem  aux  {s  t  :  ℕ  →  ℝ}  {a  :  ℝ}  (cs  :  ConvergesTo  s  a)  (ct  :  ConvergesTo  t  0)  :\n  ConvergesTo  (fun  n  ↦  s  n  *  t  n)  0  :=  by\n  intro  ε  εpos\n  dsimp\n  rcases  exists_abs_le_of_convergesTo  cs  with  ⟨N₀,  B,  h₀⟩\n  have  Bpos  :  0  <  B  :=  lt_of_le_of_lt  (abs_nonneg  _)  (h₀  N₀  (le_refl  _))\n  have  pos₀  :  ε  /  B  >  0  :=  div_pos  εpos  Bpos\n  rcases  ct  _  pos₀  with  ⟨N₁,  h₁⟩\n  sorry \n```", "```py\ntheorem  convergesTo_mul  {s  t  :  ℕ  →  ℝ}  {a  b  :  ℝ}\n  (cs  :  ConvergesTo  s  a)  (ct  :  ConvergesTo  t  b)  :\n  ConvergesTo  (fun  n  ↦  s  n  *  t  n)  (a  *  b)  :=  by\n  have  h₁  :  ConvergesTo  (fun  n  ↦  s  n  *  (t  n  +  -b))  0  :=  by\n  apply  aux  cs\n  convert  convergesTo_add  ct  (convergesTo_const  (-b))\n  ring\n  have  :=  convergesTo_add  h₁  (convergesTo_mul_const  b  cs)\n  convert  convergesTo_add  h₁  (convergesTo_mul_const  b  cs)  using  1\n  ·  ext;  ring\n  ring \n```", "```py\ntheorem  convergesTo_unique  {s  :  ℕ  →  ℝ}  {a  b  :  ℝ}\n  (sa  :  ConvergesTo  s  a)  (sb  :  ConvergesTo  s  b)  :\n  a  =  b  :=  by\n  by_contra  abne\n  have  :  |a  -  b|  >  0  :=  by  sorry\n  let  ε  :=  |a  -  b|  /  2\n  have  εpos  :  ε  >  0  :=  by\n  change  |a  -  b|  /  2  >  0\n  linarith\n  rcases  sa  ε  εpos  with  ⟨Na,  hNa⟩\n  rcases  sb  ε  εpos  with  ⟨Nb,  hNb⟩\n  let  N  :=  max  Na  Nb\n  have  absa  :  |s  N  -  a|  <  ε  :=  by  sorry\n  have  absb  :  |s  N  -  b|  <  ε  :=  by  sorry\n  have  :  |a  -  b|  <  |a  -  b|  :=  by  sorry\n  exact  lt_irrefl  _  this \n```", "```py\nvariable  {α  :  Type*}  [LinearOrder  α]\n\ndef  ConvergesTo'  (s  :  α  →  ℝ)  (a  :  ℝ)  :=\n  ∀  ε  >  0,  ∃  N,  ∀  n  ≥  N,  |s  n  -  a|  <  ε \n```", "```py\n#check  ∀  x  :  ℝ,  0  ≤  x  →  |x|  =  x \n```", "```py\n#check  ∀  x  y  ε  :  ℝ,  0  <  ε  →  ε  ≤  1  →  |x|  <  ε  →  |y|  <  ε  →  |x  *  y|  <  ε \n```", "```py\ntheorem  my_lemma  :  ∀  x  y  ε  :  ℝ,  0  <  ε  →  ε  ≤  1  →  |x|  <  ε  →  |y|  <  ε  →  |x  *  y|  <  ε  :=\n  sorry\n\nsection\nvariable  (a  b  δ  :  ℝ)\nvariable  (h₀  :  0  <  δ)  (h₁  :  δ  ≤  1)\nvariable  (ha  :  |a|  <  δ)  (hb  :  |b|  <  δ)\n\n#check  my_lemma  a  b  δ\n#check  my_lemma  a  b  δ  h₀  h₁\n#check  my_lemma  a  b  δ  h₀  h₁  ha  hb\n\nend \n```", "```py\ntheorem  my_lemma2  :  ∀  {x  y  ε  :  ℝ},  0  <  ε  →  ε  ≤  1  →  |x|  <  ε  →  |y|  <  ε  →  |x  *  y|  <  ε  :=\n  sorry\n\nsection\nvariable  (a  b  δ  :  ℝ)\nvariable  (h₀  :  0  <  δ)  (h₁  :  δ  ≤  1)\nvariable  (ha  :  |a|  <  δ)  (hb  :  |b|  <  δ)\n\n#check  my_lemma2  h₀  h₁  ha  hb\n\nend \n```", "```py\ntheorem  my_lemma3  :\n  ∀  {x  y  ε  :  ℝ},  0  <  ε  →  ε  ≤  1  →  |x|  <  ε  →  |y|  <  ε  →  |x  *  y|  <  ε  :=  by\n  intro  x  y  ε  epos  ele1  xlt  ylt\n  sorry \n```", "```py\ntheorem  my_lemma4  :\n  ∀  {x  y  ε  :  ℝ},  0  <  ε  →  ε  ≤  1  →  |x|  <  ε  →  |y|  <  ε  →  |x  *  y|  <  ε  :=  by\n  intro  x  y  ε  epos  ele1  xlt  ylt\n  calc\n  |x  *  y|  =  |x|  *  |y|  :=  sorry\n  _  ≤  |x|  *  ε  :=  sorry\n  _  <  1  *  ε  :=  sorry\n  _  =  ε  :=  sorry \n```", "```py\ndef  FnUb  (f  :  ℝ  →  ℝ)  (a  :  ℝ)  :  Prop  :=\n  ∀  x,  f  x  ≤  a\n\ndef  FnLb  (f  :  ℝ  →  ℝ)  (a  :  ℝ)  :  Prop  :=\n  ∀  x,  a  ≤  f  x \n```", "```py\nexample  (hfa  :  FnUb  f  a)  (hgb  :  FnUb  g  b)  :  FnUb  (fun  x  ↦  f  x  +  g  x)  (a  +  b)  :=  by\n  intro  x\n  dsimp\n  apply  add_le_add\n  apply  hfa\n  apply  hgb \n```", "```py\nexample  (hfa  :  FnLb  f  a)  (hgb  :  FnLb  g  b)  :  FnLb  (fun  x  ↦  f  x  +  g  x)  (a  +  b)  :=\n  sorry\n\nexample  (nnf  :  FnLb  f  0)  (nng  :  FnLb  g  0)  :  FnLb  (fun  x  ↦  f  x  *  g  x)  0  :=\n  sorry\n\nexample  (hfa  :  FnUb  f  a)  (hgb  :  FnUb  g  b)  (nng  :  FnLb  g  0)  (nna  :  0  ≤  a)  :\n  FnUb  (fun  x  ↦  f  x  *  g  x)  (a  *  b)  :=\n  sorry \n```", "```py\nvariable  {α  :  Type*}  {R  :  Type*}  [AddCommMonoid  R]  [PartialOrder  R]  [IsOrderedCancelAddMonoid  R]\n\n#check  add_le_add\n\ndef  FnUb'  (f  :  α  →  R)  (a  :  R)  :  Prop  :=\n  ∀  x,  f  x  ≤  a\n\ntheorem  fnUb_add  {f  g  :  α  →  R}  {a  b  :  R}  (hfa  :  FnUb'  f  a)  (hgb  :  FnUb'  g  b)  :\n  FnUb'  (fun  x  ↦  f  x  +  g  x)  (a  +  b)  :=  fun  x  ↦  add_le_add  (hfa  x)  (hgb  x) \n```", "```py\nexample  (f  :  ℝ  →  ℝ)  (h  :  Monotone  f)  :  ∀  {a  b},  a  ≤  b  →  f  a  ≤  f  b  :=\n  @h \n```", "```py\nexample  (mf  :  Monotone  f)  (mg  :  Monotone  g)  :  Monotone  fun  x  ↦  f  x  +  g  x  :=  by\n  intro  a  b  aleb\n  apply  add_le_add\n  apply  mf  aleb\n  apply  mg  aleb \n```", "```py\nexample  (mf  :  Monotone  f)  (mg  :  Monotone  g)  :  Monotone  fun  x  ↦  f  x  +  g  x  :=\n  fun  a  b  aleb  ↦  add_le_add  (mf  aleb)  (mg  aleb) \n```", "```py\nexample  {c  :  ℝ}  (mf  :  Monotone  f)  (nnc  :  0  ≤  c)  :  Monotone  fun  x  ↦  c  *  f  x  :=\n  sorry\n\nexample  (mf  :  Monotone  f)  (mg  :  Monotone  g)  :  Monotone  fun  x  ↦  f  (g  x)  :=\n  sorry \n```", "```py\ndef  FnEven  (f  :  ℝ  →  ℝ)  :  Prop  :=\n  ∀  x,  f  x  =  f  (-x)\n\ndef  FnOdd  (f  :  ℝ  →  ℝ)  :  Prop  :=\n  ∀  x,  f  x  =  -f  (-x)\n\nexample  (ef  :  FnEven  f)  (eg  :  FnEven  g)  :  FnEven  fun  x  ↦  f  x  +  g  x  :=  by\n  intro  x\n  calc\n  (fun  x  ↦  f  x  +  g  x)  x  =  f  x  +  g  x  :=  rfl\n  _  =  f  (-x)  +  g  (-x)  :=  by  rw  [ef,  eg]\n\nexample  (of  :  FnOdd  f)  (og  :  FnOdd  g)  :  FnEven  fun  x  ↦  f  x  *  g  x  :=  by\n  sorry\n\nexample  (ef  :  FnEven  f)  (og  :  FnOdd  g)  :  FnOdd  fun  x  ↦  f  x  *  g  x  :=  by\n  sorry\n\nexample  (ef  :  FnEven  f)  (og  :  FnOdd  g)  :  FnEven  fun  x  ↦  f  (g  x)  :=  by\n  sorry \n```", "```py\nvariable  {α  :  Type*}  (r  s  t  :  Set  α)\n\nexample  :  s  ⊆  s  :=  by\n  intro  x  xs\n  exact  xs\n\ntheorem  Subset.refl  :  s  ⊆  s  :=  fun  x  xs  ↦  xs\n\ntheorem  Subset.trans  :  r  ⊆  s  →  s  ⊆  t  →  r  ⊆  t  :=  by\n  sorry \n```", "```py\nvariable  {α  :  Type*}  [PartialOrder  α]\nvariable  (s  :  Set  α)  (a  b  :  α)\n\ndef  SetUb  (s  :  Set  α)  (a  :  α)  :=\n  ∀  x,  x  ∈  s  →  x  ≤  a\n\nexample  (h  :  SetUb  s  a)  (h'  :  a  ≤  b)  :  SetUb  s  b  :=\n  sorry \n```", "```py\nopen  Function\n\nexample  (c  :  ℝ)  :  Injective  fun  x  ↦  x  +  c  :=  by\n  intro  x₁  x₂  h'\n  exact  (add_left_inj  c).mp  h'\n\nexample  {c  :  ℝ}  (h  :  c  ≠  0)  :  Injective  fun  x  ↦  c  *  x  :=  by\n  sorry \n```", "```py\nvariable  {α  :  Type*}  {β  :  Type*}  {γ  :  Type*}\nvariable  {g  :  β  →  γ}  {f  :  α  →  β}\n\nexample  (injg  :  Injective  g)  (injf  :  Injective  f)  :  Injective  fun  x  ↦  g  (f  x)  :=  by\n  sorry \n```", "```py\nexample  :  ∃  x  :  ℝ,  2  <  x  ∧  x  <  3  :=  by\n  use  5  /  2\n  norm_num \n```", "```py\nexample  :  ∃  x  :  ℝ,  2  <  x  ∧  x  <  3  :=  by\n  have  h1  :  2  <  (5  :  ℝ)  /  2  :=  by  norm_num\n  have  h2  :  (5  :  ℝ)  /  2  <  3  :=  by  norm_num\n  use  5  /  2,  h1,  h2 \n```", "```py\nexample  :  ∃  x  :  ℝ,  2  <  x  ∧  x  <  3  :=  by\n  have  h  :  2  <  (5  :  ℝ)  /  2  ∧  (5  :  ℝ)  /  2  <  3  :=  by  norm_num\n  use  5  /  2 \n```", "```py\nexample  :  ∃  x  :  ℝ,  2  <  x  ∧  x  <  3  :=\n  have  h  :  2  <  (5  :  ℝ)  /  2  ∧  (5  :  ℝ)  /  2  <  3  :=  by  norm_num\n  ⟨5  /  2,  h⟩ \n```", "```py\nexample  :  ∃  x  :  ℝ,  2  <  x  ∧  x  <  3  :=\n  ⟨5  /  2,  by  norm_num⟩ \n```", "```py\ndef  FnUb  (f  :  ℝ  →  ℝ)  (a  :  ℝ)  :  Prop  :=\n  ∀  x,  f  x  ≤  a\n\ndef  FnLb  (f  :  ℝ  →  ℝ)  (a  :  ℝ)  :  Prop  :=\n  ∀  x,  a  ≤  f  x\n\ndef  FnHasUb  (f  :  ℝ  →  ℝ)  :=\n  ∃  a,  FnUb  f  a\n\ndef  FnHasLb  (f  :  ℝ  →  ℝ)  :=\n  ∃  a,  FnLb  f  a \n```", "```py\nvariable  {f  g  :  ℝ  →  ℝ}\n\nexample  (ubf  :  FnHasUb  f)  (ubg  :  FnHasUb  g)  :  FnHasUb  fun  x  ↦  f  x  +  g  x  :=  by\n  rcases  ubf  with  ⟨a,  ubfa⟩\n  rcases  ubg  with  ⟨b,  ubgb⟩\n  use  a  +  b\n  apply  fnUb_add  ubfa  ubgb \n```", "```py\nexample  (lbf  :  FnHasLb  f)  (lbg  :  FnHasLb  g)  :  FnHasLb  fun  x  ↦  f  x  +  g  x  :=  by\n  sorry\n\nexample  {c  :  ℝ}  (ubf  :  FnHasUb  f)  (h  :  c  ≥  0)  :  FnHasUb  fun  x  ↦  c  *  f  x  :=  by\n  sorry \n```", "```py\nexample  :  FnHasUb  f  →  FnHasUb  g  →  FnHasUb  fun  x  ↦  f  x  +  g  x  :=  by\n  rintro  ⟨a,  ubfa⟩  ⟨b,  ubgb⟩\n  exact  ⟨a  +  b,  fnUb_add  ubfa  ubgb⟩ \n```", "```py\nexample  :  FnHasUb  f  →  FnHasUb  g  →  FnHasUb  fun  x  ↦  f  x  +  g  x  :=\n  fun  ⟨a,  ubfa⟩  ⟨b,  ubgb⟩  ↦  ⟨a  +  b,  fnUb_add  ubfa  ubgb⟩ \n```", "```py\nexample  (ubf  :  FnHasUb  f)  (ubg  :  FnHasUb  g)  :  FnHasUb  fun  x  ↦  f  x  +  g  x  :=  by\n  obtain  ⟨a,  ubfa⟩  :=  ubf\n  obtain  ⟨b,  ubgb⟩  :=  ubg\n  exact  ⟨a  +  b,  fnUb_add  ubfa  ubgb⟩ \n```", "```py\nexample  (ubf  :  FnHasUb  f)  (ubg  :  FnHasUb  g)  :  FnHasUb  fun  x  ↦  f  x  +  g  x  :=  by\n  cases  ubf\n  case  intro  a  ubfa  =>\n  cases  ubg\n  case  intro  b  ubgb  =>\n  exact  ⟨a  +  b,  fnUb_add  ubfa  ubgb⟩\n\nexample  (ubf  :  FnHasUb  f)  (ubg  :  FnHasUb  g)  :  FnHasUb  fun  x  ↦  f  x  +  g  x  :=  by\n  cases  ubf\n  next  a  ubfa  =>\n  cases  ubg\n  next  b  ubgb  =>\n  exact  ⟨a  +  b,  fnUb_add  ubfa  ubgb⟩\n\nexample  (ubf  :  FnHasUb  f)  (ubg  :  FnHasUb  g)  :  FnHasUb  fun  x  ↦  f  x  +  g  x  :=  by\n  match  ubf,  ubg  with\n  |  ⟨a,  ubfa⟩,  ⟨b,  ubgb⟩  =>\n  exact  ⟨a  +  b,  fnUb_add  ubfa  ubgb⟩\n\nexample  (ubf  :  FnHasUb  f)  (ubg  :  FnHasUb  g)  :  FnHasUb  fun  x  ↦  f  x  +  g  x  :=\n  match  ubf,  ubg  with\n  |  ⟨a,  ubfa⟩,  ⟨b,  ubgb⟩  =>\n  ⟨a  +  b,  fnUb_add  ubfa  ubgb⟩ \n```", "```py\nvariable  {α  :  Type*}  [CommRing  α]\n\ndef  SumOfSquares  (x  :  α)  :=\n  ∃  a  b,  x  =  a  ^  2  +  b  ^  2\n\ntheorem  sumOfSquares_mul  {x  y  :  α}  (sosx  :  SumOfSquares  x)  (sosy  :  SumOfSquares  y)  :\n  SumOfSquares  (x  *  y)  :=  by\n  rcases  sosx  with  ⟨a,  b,  xeq⟩\n  rcases  sosy  with  ⟨c,  d,  yeq⟩\n  rw  [xeq,  yeq]\n  use  a  *  c  -  b  *  d,  a  *  d  +  b  *  c\n  ring \n```", "```py\ntheorem  sumOfSquares_mul'  {x  y  :  α}  (sosx  :  SumOfSquares  x)  (sosy  :  SumOfSquares  y)  :\n  SumOfSquares  (x  *  y)  :=  by\n  rcases  sosx  with  ⟨a,  b,  rfl⟩\n  rcases  sosy  with  ⟨c,  d,  rfl⟩\n  use  a  *  c  -  b  *  d,  a  *  d  +  b  *  c\n  ring \n```", "```py\nexample  (divab  :  a  ∣  b)  (divbc  :  b  ∣  c)  :  a  ∣  c  :=  by\n  rcases  divab  with  ⟨d,  beq⟩\n  rcases  divbc  with  ⟨e,  ceq⟩\n  rw  [ceq,  beq]\n  use  d  *  e;  ring \n```", "```py\nexample  (divab  :  a  ∣  b)  (divac  :  a  ∣  c)  :  a  ∣  b  +  c  :=  by\n  sorry \n```", "```py\nexample  {c  :  ℝ}  :  Surjective  fun  x  ↦  x  +  c  :=  by\n  intro  x\n  use  x  -  c\n  dsimp;  ring \n```", "```py\nexample  {c  :  ℝ}  (h  :  c  ≠  0)  :  Surjective  fun  x  ↦  c  *  x  :=  by\n  sorry \n```", "```py\nexample  (x  y  :  ℝ)  (h  :  x  -  y  ≠  0)  :  (x  ^  2  -  y  ^  2)  /  (x  -  y)  =  x  +  y  :=  by\n  field_simp  [h]\n  ring \n```", "```py\nexample  {f  :  ℝ  →  ℝ}  (h  :  Surjective  f)  :  ∃  x,  f  x  ^  2  =  4  :=  by\n  rcases  h  2  with  ⟨x,  hx⟩\n  use  x\n  rw  [hx]\n  norm_num \n```", "```py\nvariable  {α  :  Type*}  {β  :  Type*}  {γ  :  Type*}\nvariable  {g  :  β  →  γ}  {f  :  α  →  β}\n\nexample  (surjg  :  Surjective  g)  (surjf  :  Surjective  f)  :  Surjective  fun  x  ↦  g  (f  x)  :=  by\n  sorry \n```", "```py\nexample  (h  :  a  <  b)  :  ¬b  <  a  :=  by\n  intro  h'\n  have  :  a  <  a  :=  lt_trans  h  h'\n  apply  lt_irrefl  a  this \n```", "```py\nexample  (h  :  ∀  a,  ∃  x,  f  x  >  a)  :  ¬FnHasUb  f  :=  by\n  intro  fnub\n  rcases  fnub  with  ⟨a,  fnuba⟩\n  rcases  h  a  with  ⟨x,  hx⟩\n  have  :  f  x  ≤  a  :=  fnuba  x\n  linarith \n```", "```py\nexample  (h  :  ∀  a,  ∃  x,  f  x  <  a)  :  ¬FnHasLb  f  :=\n  sorry\n\nexample  :  ¬FnHasUb  fun  x  ↦  x  :=\n  sorry \n```", "```py\n#check  (not_le_of_gt  :  a  >  b  →  ¬a  ≤  b)\n#check  (not_lt_of_ge  :  a  ≥  b  →  ¬a  <  b)\n#check  (lt_of_not_ge  :  ¬a  ≥  b  →  a  <  b)\n#check  (le_of_not_gt  :  ¬a  >  b  →  a  ≤  b) \n```", "```py\nexample  (h  :  Monotone  f)  (h'  :  f  a  <  f  b)  :  a  <  b  :=  by\n  sorry\n\nexample  (h  :  a  ≤  b)  (h'  :  f  b  <  f  a)  :  ¬Monotone  f  :=  by\n  sorry \n```", "```py\nexample  :  ¬∀  {f  :  ℝ  →  ℝ},  Monotone  f  →  ∀  {a  b},  f  a  ≤  f  b  →  a  ≤  b  :=  by\n  intro  h\n  let  f  :=  fun  x  :  ℝ  ↦  (0  :  ℝ)\n  have  monof  :  Monotone  f  :=  by  sorry\n  have  h'  :  f  1  ≤  f  0  :=  le_refl  _\n  sorry \n```", "```py\nexample  (x  :  ℝ)  (h  :  ∀  ε  >  0,  x  <  ε)  :  x  ≤  0  :=  by\n  sorry \n```", "```py\nvariable  {α  :  Type*}  (P  :  α  →  Prop)  (Q  :  Prop)\n\nexample  (h  :  ¬∃  x,  P  x)  :  ∀  x,  ¬P  x  :=  by\n  sorry\n\nexample  (h  :  ∀  x,  ¬P  x)  :  ¬∃  x,  P  x  :=  by\n  sorry\n\nexample  (h  :  ¬∀  x,  P  x)  :  ∃  x,  ¬P  x  :=  by\n  sorry\n\nexample  (h  :  ∃  x,  ¬P  x)  :  ¬∀  x,  P  x  :=  by\n  sorry \n```", "```py\nexample  (h  :  ¬∀  x,  P  x)  :  ∃  x,  ¬P  x  :=  by\n  by_contra  h'\n  apply  h\n  intro  x\n  show  P  x\n  by_contra  h''\n  exact  h'  ⟨x,  h''⟩ \n```", "```py\nexample  (h  :  ¬¬Q)  :  Q  :=  by\n  sorry\n\nexample  (h  :  Q)  :  ¬¬Q  :=  by\n  sorry \n```", "```py\nexample  (h  :  ¬FnHasUb  f)  :  ∀  a,  ∃  x,  f  x  >  a  :=  by\n  sorry \n```", "```py\nexample  (h  :  ¬∀  a,  ∃  x,  f  x  >  a)  :  FnHasUb  f  :=  by\n  push_neg  at  h\n  exact  h\n\nexample  (h  :  ¬FnHasUb  f)  :  ∀  a,  ∃  x,  f  x  >  a  :=  by\n  dsimp  only  [FnHasUb,  FnUb]  at  h\n  push_neg  at  h\n  exact  h \n```", "```py\nexample  (h  :  ¬Monotone  f)  :  ∃  x  y,  x  ≤  y  ∧  f  y  <  f  x  :=  by\n  sorry \n```", "```py\nexample  (h  :  ¬FnHasUb  f)  :  ∀  a,  ∃  x,  f  x  >  a  :=  by\n  contrapose!  h\n  exact  h\n\nexample  (x  :  ℝ)  (h  :  ∀  ε  >  0,  x  ≤  ε)  :  x  ≤  0  :=  by\n  contrapose!  h\n  use  x  /  2\n  constructor  <;>  linarith \n```", "```py\nexample  (h  :  0  <  0)  :  a  >  37  :=  by\n  exfalso\n  apply  lt_irrefl  0  h\n\nexample  (h  :  0  <  0)  :  a  >  37  :=\n  absurd  h  (lt_irrefl  0)\n\nexample  (h  :  0  <  0)  :  a  >  37  :=  by\n  have  h'  :  ¬0  <  0  :=  lt_irrefl  0\n  contradiction \n```", "```py\nexample  {x  y  :  ℝ}  (h₀  :  x  ≤  y)  (h₁  :  ¬y  ≤  x)  :  x  ≤  y  ∧  x  ≠  y  :=  by\n  constructor\n  ·  assumption\n  intro  h\n  apply  h₁\n  rw  [h] \n```", "```py\nexample  {x  y  :  ℝ}  (h₀  :  x  ≤  y)  (h₁  :  ¬y  ≤  x)  :  x  ≤  y  ∧  x  ≠  y  :=\n  ⟨h₀,  fun  h  ↦  h₁  (by  rw  [h])⟩\n\nexample  {x  y  :  ℝ}  (h₀  :  x  ≤  y)  (h₁  :  ¬y  ≤  x)  :  x  ≤  y  ∧  x  ≠  y  :=\n  have  h  :  x  ≠  y  :=  by\n  contrapose!  h₁\n  rw  [h₁]\n  ⟨h₀,  h⟩ \n```", "```py\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y  ∧  x  ≠  y)  :  ¬y  ≤  x  :=  by\n  rcases  h  with  ⟨h₀,  h₁⟩\n  contrapose!  h₁\n  exact  le_antisymm  h₀  h₁\n\nexample  {x  y  :  ℝ}  :  x  ≤  y  ∧  x  ≠  y  →  ¬y  ≤  x  :=  by\n  rintro  ⟨h₀,  h₁⟩  h'\n  exact  h₁  (le_antisymm  h₀  h')\n\nexample  {x  y  :  ℝ}  :  x  ≤  y  ∧  x  ≠  y  →  ¬y  ≤  x  :=\n  fun  ⟨h₀,  h₁⟩  h'  ↦  h₁  (le_antisymm  h₀  h') \n```", "```py\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y  ∧  x  ≠  y)  :  ¬y  ≤  x  :=  by\n  have  ⟨h₀,  h₁⟩  :=  h\n  contrapose!  h₁\n  exact  le_antisymm  h₀  h₁ \n```", "```py\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y  ∧  x  ≠  y)  :  ¬y  ≤  x  :=  by\n  cases  h\n  case  intro  h₀  h₁  =>\n  contrapose!  h₁\n  exact  le_antisymm  h₀  h₁\n\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y  ∧  x  ≠  y)  :  ¬y  ≤  x  :=  by\n  cases  h\n  next  h₀  h₁  =>\n  contrapose!  h₁\n  exact  le_antisymm  h₀  h₁\n\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y  ∧  x  ≠  y)  :  ¬y  ≤  x  :=  by\n  match  h  with\n  |  ⟨h₀,  h₁⟩  =>\n  contrapose!  h₁\n  exact  le_antisymm  h₀  h₁ \n```", "```py\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y  ∧  x  ≠  y)  :  ¬y  ≤  x  :=  by\n  intro  h'\n  apply  h.right\n  exact  le_antisymm  h.left  h'\n\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y  ∧  x  ≠  y)  :  ¬y  ≤  x  :=\n  fun  h'  ↦  h.right  (le_antisymm  h.left  h') \n```", "```py\nexample  {m  n  :  ℕ}  (h  :  m  ∣  n  ∧  m  ≠  n)  :  m  ∣  n  ∧  ¬n  ∣  m  :=\n  sorry \n```", "```py\nexample  :  ∃  x  :  ℝ,  2  <  x  ∧  x  <  4  :=\n  ⟨5  /  2,  by  norm_num,  by  norm_num⟩\n\nexample  (x  y  :  ℝ)  :  (∃  z  :  ℝ,  x  <  z  ∧  z  <  y)  →  x  <  y  :=  by\n  rintro  ⟨z,  xltz,  zlty⟩\n  exact  lt_trans  xltz  zlty\n\nexample  (x  y  :  ℝ)  :  (∃  z  :  ℝ,  x  <  z  ∧  z  <  y)  →  x  <  y  :=\n  fun  ⟨z,  xltz,  zlty⟩  ↦  lt_trans  xltz  zlty \n```", "```py\nexample  :  ∃  x  :  ℝ,  2  <  x  ∧  x  <  4  :=  by\n  use  5  /  2\n  constructor  <;>  norm_num\n\nexample  :  ∃  m  n  :  ℕ,  4  <  m  ∧  m  <  n  ∧  n  <  10  ∧  Nat.Prime  m  ∧  Nat.Prime  n  :=  by\n  use  5\n  use  7\n  norm_num\n\nexample  {x  y  :  ℝ}  :  x  ≤  y  ∧  x  ≠  y  →  x  ≤  y  ∧  ¬y  ≤  x  :=  by\n  rintro  ⟨h₀,  h₁⟩\n  use  h₀\n  exact  fun  h'  ↦  h₁  (le_antisymm  h₀  h') \n```", "```py\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y)  :  ¬y  ≤  x  ↔  x  ≠  y  :=  by\n  constructor\n  ·  contrapose!\n  rintro  rfl\n  rfl\n  contrapose!\n  exact  le_antisymm  h\n\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y)  :  ¬y  ≤  x  ↔  x  ≠  y  :=\n  ⟨fun  h₀  h₁  ↦  h₀  (by  rw  [h₁]),  fun  h₀  h₁  ↦  h₀  (le_antisymm  h  h₁)⟩ \n```", "```py\nexample  {x  y  :  ℝ}  :  x  ≤  y  ∧  ¬y  ≤  x  ↔  x  ≤  y  ∧  x  ≠  y  :=\n  sorry \n```", "```py\ntheorem  aux  {x  y  :  ℝ}  (h  :  x  ^  2  +  y  ^  2  =  0)  :  x  =  0  :=\n  have  h'  :  x  ^  2  =  0  :=  by  sorry\n  pow_eq_zero  h'\n\nexample  (x  y  :  ℝ)  :  x  ^  2  +  y  ^  2  =  0  ↔  x  =  0  ∧  y  =  0  :=\n  sorry \n```", "```py\nexample  (x  :  ℝ)  :  |x  +  3|  <  5  →  -8  <  x  ∧  x  <  2  :=  by\n  rw  [abs_lt]\n  intro  h\n  constructor  <;>  linarith\n\nexample  :  3  ∣  Nat.gcd  6  15  :=  by\n  rw  [Nat.dvd_gcd_iff]\n  constructor  <;>  norm_num \n```", "```py\ntheorem  not_monotone_iff  {f  :  ℝ  →  ℝ}  :  ¬Monotone  f  ↔  ∃  x  y,  x  ≤  y  ∧  f  x  >  f  y  :=  by\n  rw  [Monotone]\n  push_neg\n  rfl\n\nexample  :  ¬Monotone  fun  x  :  ℝ  ↦  -x  :=  by\n  sorry \n```", "```py\nvariable  {α  :  Type*}  [PartialOrder  α]\nvariable  (a  b  :  α)\n\nexample  :  a  <  b  ↔  a  ≤  b  ∧  a  ≠  b  :=  by\n  rw  [lt_iff_le_not_ge]\n  sorry \n```", "```py\nvariable  {α  :  Type*}  [Preorder  α]\nvariable  (a  b  c  :  α)\n\nexample  :  ¬a  <  a  :=  by\n  rw  [lt_iff_le_not_ge]\n  sorry\n\nexample  :  a  <  b  →  b  <  c  →  a  <  c  :=  by\n  simp  only  [lt_iff_le_not_ge]\n  sorry \n```", "```py\nvariable  {x  y  :  ℝ}\n\nexample  (h  :  y  >  x  ^  2)  :  y  >  0  ∨  y  <  -1  :=  by\n  left\n  linarith  [pow_two_nonneg  x]\n\nexample  (h  :  -y  >  x  ^  2  +  1)  :  y  >  0  ∨  y  <  -1  :=  by\n  right\n  linarith  [pow_two_nonneg  x] \n```", "```py\nexample  (h  :  y  >  0)  :  y  >  0  ∨  y  <  -1  :=\n  Or.inl  h\n\nexample  (h  :  y  <  -1)  :  y  >  0  ∨  y  <  -1  :=\n  Or.inr  h \n```", "```py\nexample  :  x  <  |y|  →  x  <  y  ∨  x  <  -y  :=  by\n  rcases  le_or_gt  0  y  with  h  |  h\n  ·  rw  [abs_of_nonneg  h]\n  intro  h;  left;  exact  h\n  ·  rw  [abs_of_neg  h]\n  intro  h;  right;  exact  h \n```", "```py\nexample  :  x  <  |y|  →  x  <  y  ∨  x  <  -y  :=  by\n  cases  le_or_gt  0  y\n  case  inl  h  =>\n  rw  [abs_of_nonneg  h]\n  intro  h;  left;  exact  h\n  case  inr  h  =>\n  rw  [abs_of_neg  h]\n  intro  h;  right;  exact  h \n```", "```py\nexample  :  x  <  |y|  →  x  <  y  ∨  x  <  -y  :=  by\n  cases  le_or_gt  0  y\n  next  h  =>\n  rw  [abs_of_nonneg  h]\n  intro  h;  left;  exact  h\n  next  h  =>\n  rw  [abs_of_neg  h]\n  intro  h;  right;  exact  h\n\nexample  :  x  <  |y|  →  x  <  y  ∨  x  <  -y  :=  by\n  match  le_or_gt  0  y  with\n  |  Or.inl  h  =>\n  rw  [abs_of_nonneg  h]\n  intro  h;  left;  exact  h\n  |  Or.inr  h  =>\n  rw  [abs_of_neg  h]\n  intro  h;  right;  exact  h \n```", "```py\nnamespace  MyAbs\n\ntheorem  le_abs_self  (x  :  ℝ)  :  x  ≤  |x|  :=  by\n  sorry\n\ntheorem  neg_le_abs_self  (x  :  ℝ)  :  -x  ≤  |x|  :=  by\n  sorry\n\ntheorem  abs_add  (x  y  :  ℝ)  :  |x  +  y|  ≤  |x|  +  |y|  :=  by\n  sorry \n```", "```py\ntheorem  lt_abs  :  x  <  |y|  ↔  x  <  y  ∨  x  <  -y  :=  by\n  sorry\n\ntheorem  abs_lt  :  |x|  <  y  ↔  -y  <  x  ∧  x  <  y  :=  by\n  sorry \n```", "```py\nexample  {x  :  ℝ}  (h  :  x  ≠  0)  :  x  <  0  ∨  x  >  0  :=  by\n  rcases  lt_trichotomy  x  0  with  xlt  |  xeq  |  xgt\n  ·  left\n  exact  xlt\n  ·  contradiction\n  ·  right;  exact  xgt \n```", "```py\nexample  {m  n  k  :  ℕ}  (h  :  m  ∣  n  ∨  m  ∣  k)  :  m  ∣  n  *  k  :=  by\n  rcases  h  with  ⟨a,  rfl⟩  |  ⟨b,  rfl⟩\n  ·  rw  [mul_assoc]\n  apply  dvd_mul_right\n  ·  rw  [mul_comm,  mul_assoc]\n  apply  dvd_mul_right \n```", "```py\nexample  {z  :  ℝ}  (h  :  ∃  x  y,  z  =  x  ^  2  +  y  ^  2  ∨  z  =  x  ^  2  +  y  ^  2  +  1)  :  z  ≥  0  :=  by\n  sorry \n```", "```py\nexample  {x  :  ℝ}  (h  :  x  ^  2  =  1)  :  x  =  1  ∨  x  =  -1  :=  by\n  sorry\n\nexample  {x  y  :  ℝ}  (h  :  x  ^  2  =  y  ^  2)  :  x  =  y  ∨  x  =  -y  :=  by\n  sorry \n```", "```py\nvariable  {R  :  Type*}  [CommRing  R]  [IsDomain  R]\nvariable  (x  y  :  R)\n\nexample  (h  :  x  ^  2  =  1)  :  x  =  1  ∨  x  =  -1  :=  by\n  sorry\n\nexample  (h  :  x  ^  2  =  y  ^  2)  :  x  =  y  ∨  x  =  -y  :=  by\n  sorry \n```", "```py\nexample  (P  :  Prop)  :  ¬¬P  →  P  :=  by\n  intro  h\n  cases  em  P\n  ·  assumption\n  ·  contradiction \n```", "```py\nexample  (P  :  Prop)  :  ¬¬P  →  P  :=  by\n  intro  h\n  by_cases  h'  :  P\n  ·  assumption\n  contradiction \n```", "```py\nexample  (P  Q  :  Prop)  :  P  →  Q  ↔  ¬P  ∨  Q  :=  by\n  sorry \n```", "```py\ndef  ConvergesTo  (s  :  ℕ  →  ℝ)  (a  :  ℝ)  :=\n  ∀  ε  >  0,  ∃  N,  ∀  n  ≥  N,  |s  n  -  a|  <  ε \n```", "```py\nexample  :  (fun  x  y  :  ℝ  ↦  (x  +  y)  ^  2)  =  fun  x  y  :  ℝ  ↦  x  ^  2  +  2  *  x  *  y  +  y  ^  2  :=  by\n  ext\n  ring \n```", "```py\nexample  (a  b  :  ℝ)  :  |a|  =  |a  -  b  +  b|  :=  by\n  congr\n  ring \n```", "```py\nexample  {a  :  ℝ}  (h  :  1  <  a)  :  a  <  a  *  a  :=  by\n  convert  (mul_lt_mul_right  _).2  h\n  ·  rw  [one_mul]\n  exact  lt_trans  zero_lt_one  h \n```", "```py\ntheorem  convergesTo_const  (a  :  ℝ)  :  ConvergesTo  (fun  x  :  ℕ  ↦  a)  a  :=  by\n  intro  ε  εpos\n  use  0\n  intro  n  nge\n  rw  [sub_self,  abs_zero]\n  apply  εpos \n```", "```py\ntheorem  convergesTo_add  {s  t  :  ℕ  →  ℝ}  {a  b  :  ℝ}\n  (cs  :  ConvergesTo  s  a)  (ct  :  ConvergesTo  t  b)  :\n  ConvergesTo  (fun  n  ↦  s  n  +  t  n)  (a  +  b)  :=  by\n  intro  ε  εpos\n  dsimp  -- this line is not needed but cleans up the goal a bit.\n  have  ε2pos  :  0  <  ε  /  2  :=  by  linarith\n  rcases  cs  (ε  /  2)  ε2pos  with  ⟨Ns,  hs⟩\n  rcases  ct  (ε  /  2)  ε2pos  with  ⟨Nt,  ht⟩\n  use  max  Ns  Nt\n  sorry \n```", "```py\ntheorem  convergesTo_mul_const  {s  :  ℕ  →  ℝ}  {a  :  ℝ}  (c  :  ℝ)  (cs  :  ConvergesTo  s  a)  :\n  ConvergesTo  (fun  n  ↦  c  *  s  n)  (c  *  a)  :=  by\n  by_cases  h  :  c  =  0\n  ·  convert  convergesTo_const  0\n  ·  rw  [h]\n  ring\n  rw  [h]\n  ring\n  have  acpos  :  0  <  |c|  :=  abs_pos.mpr  h\n  sorry \n```", "```py\ntheorem  exists_abs_le_of_convergesTo  {s  :  ℕ  →  ℝ}  {a  :  ℝ}  (cs  :  ConvergesTo  s  a)  :\n  ∃  N  b,  ∀  n,  N  ≤  n  →  |s  n|  <  b  :=  by\n  rcases  cs  1  zero_lt_one  with  ⟨N,  h⟩\n  use  N,  |a|  +  1\n  sorry \n```", "```py\ntheorem  aux  {s  t  :  ℕ  →  ℝ}  {a  :  ℝ}  (cs  :  ConvergesTo  s  a)  (ct  :  ConvergesTo  t  0)  :\n  ConvergesTo  (fun  n  ↦  s  n  *  t  n)  0  :=  by\n  intro  ε  εpos\n  dsimp\n  rcases  exists_abs_le_of_convergesTo  cs  with  ⟨N₀,  B,  h₀⟩\n  have  Bpos  :  0  <  B  :=  lt_of_le_of_lt  (abs_nonneg  _)  (h₀  N₀  (le_refl  _))\n  have  pos₀  :  ε  /  B  >  0  :=  div_pos  εpos  Bpos\n  rcases  ct  _  pos₀  with  ⟨N₁,  h₁⟩\n  sorry \n```", "```py\ntheorem  convergesTo_mul  {s  t  :  ℕ  →  ℝ}  {a  b  :  ℝ}\n  (cs  :  ConvergesTo  s  a)  (ct  :  ConvergesTo  t  b)  :\n  ConvergesTo  (fun  n  ↦  s  n  *  t  n)  (a  *  b)  :=  by\n  have  h₁  :  ConvergesTo  (fun  n  ↦  s  n  *  (t  n  +  -b))  0  :=  by\n  apply  aux  cs\n  convert  convergesTo_add  ct  (convergesTo_const  (-b))\n  ring\n  have  :=  convergesTo_add  h₁  (convergesTo_mul_const  b  cs)\n  convert  convergesTo_add  h₁  (convergesTo_mul_const  b  cs)  using  1\n  ·  ext;  ring\n  ring \n```", "```py\ntheorem  convergesTo_unique  {s  :  ℕ  →  ℝ}  {a  b  :  ℝ}\n  (sa  :  ConvergesTo  s  a)  (sb  :  ConvergesTo  s  b)  :\n  a  =  b  :=  by\n  by_contra  abne\n  have  :  |a  -  b|  >  0  :=  by  sorry\n  let  ε  :=  |a  -  b|  /  2\n  have  εpos  :  ε  >  0  :=  by\n  change  |a  -  b|  /  2  >  0\n  linarith\n  rcases  sa  ε  εpos  with  ⟨Na,  hNa⟩\n  rcases  sb  ε  εpos  with  ⟨Nb,  hNb⟩\n  let  N  :=  max  Na  Nb\n  have  absa  :  |s  N  -  a|  <  ε  :=  by  sorry\n  have  absb  :  |s  N  -  b|  <  ε  :=  by  sorry\n  have  :  |a  -  b|  <  |a  -  b|  :=  by  sorry\n  exact  lt_irrefl  _  this \n```", "```py\nvariable  {α  :  Type*}  [LinearOrder  α]\n\ndef  ConvergesTo'  (s  :  α  →  ℝ)  (a  :  ℝ)  :=\n  ∀  ε  >  0,  ∃  N,  ∀  n  ≥  N,  |s  n  -  a|  <  ε \n```", "```py\n#check  ∀  x  :  ℝ,  0  ≤  x  →  |x|  =  x \n```", "```py\n#check  ∀  x  y  ε  :  ℝ,  0  <  ε  →  ε  ≤  1  →  |x|  <  ε  →  |y|  <  ε  →  |x  *  y|  <  ε \n```", "```py\ntheorem  my_lemma  :  ∀  x  y  ε  :  ℝ,  0  <  ε  →  ε  ≤  1  →  |x|  <  ε  →  |y|  <  ε  →  |x  *  y|  <  ε  :=\n  sorry\n\nsection\nvariable  (a  b  δ  :  ℝ)\nvariable  (h₀  :  0  <  δ)  (h₁  :  δ  ≤  1)\nvariable  (ha  :  |a|  <  δ)  (hb  :  |b|  <  δ)\n\n#check  my_lemma  a  b  δ\n#check  my_lemma  a  b  δ  h₀  h₁\n#check  my_lemma  a  b  δ  h₀  h₁  ha  hb\n\nend \n```", "```py\ntheorem  my_lemma2  :  ∀  {x  y  ε  :  ℝ},  0  <  ε  →  ε  ≤  1  →  |x|  <  ε  →  |y|  <  ε  →  |x  *  y|  <  ε  :=\n  sorry\n\nsection\nvariable  (a  b  δ  :  ℝ)\nvariable  (h₀  :  0  <  δ)  (h₁  :  δ  ≤  1)\nvariable  (ha  :  |a|  <  δ)  (hb  :  |b|  <  δ)\n\n#check  my_lemma2  h₀  h₁  ha  hb\n\nend \n```", "```py\ntheorem  my_lemma3  :\n  ∀  {x  y  ε  :  ℝ},  0  <  ε  →  ε  ≤  1  →  |x|  <  ε  →  |y|  <  ε  →  |x  *  y|  <  ε  :=  by\n  intro  x  y  ε  epos  ele1  xlt  ylt\n  sorry \n```", "```py\ntheorem  my_lemma4  :\n  ∀  {x  y  ε  :  ℝ},  0  <  ε  →  ε  ≤  1  →  |x|  <  ε  →  |y|  <  ε  →  |x  *  y|  <  ε  :=  by\n  intro  x  y  ε  epos  ele1  xlt  ylt\n  calc\n  |x  *  y|  =  |x|  *  |y|  :=  sorry\n  _  ≤  |x|  *  ε  :=  sorry\n  _  <  1  *  ε  :=  sorry\n  _  =  ε  :=  sorry \n```", "```py\ndef  FnUb  (f  :  ℝ  →  ℝ)  (a  :  ℝ)  :  Prop  :=\n  ∀  x,  f  x  ≤  a\n\ndef  FnLb  (f  :  ℝ  →  ℝ)  (a  :  ℝ)  :  Prop  :=\n  ∀  x,  a  ≤  f  x \n```", "```py\nexample  (hfa  :  FnUb  f  a)  (hgb  :  FnUb  g  b)  :  FnUb  (fun  x  ↦  f  x  +  g  x)  (a  +  b)  :=  by\n  intro  x\n  dsimp\n  apply  add_le_add\n  apply  hfa\n  apply  hgb \n```", "```py\nexample  (hfa  :  FnLb  f  a)  (hgb  :  FnLb  g  b)  :  FnLb  (fun  x  ↦  f  x  +  g  x)  (a  +  b)  :=\n  sorry\n\nexample  (nnf  :  FnLb  f  0)  (nng  :  FnLb  g  0)  :  FnLb  (fun  x  ↦  f  x  *  g  x)  0  :=\n  sorry\n\nexample  (hfa  :  FnUb  f  a)  (hgb  :  FnUb  g  b)  (nng  :  FnLb  g  0)  (nna  :  0  ≤  a)  :\n  FnUb  (fun  x  ↦  f  x  *  g  x)  (a  *  b)  :=\n  sorry \n```", "```py\nvariable  {α  :  Type*}  {R  :  Type*}  [AddCommMonoid  R]  [PartialOrder  R]  [IsOrderedCancelAddMonoid  R]\n\n#check  add_le_add\n\ndef  FnUb'  (f  :  α  →  R)  (a  :  R)  :  Prop  :=\n  ∀  x,  f  x  ≤  a\n\ntheorem  fnUb_add  {f  g  :  α  →  R}  {a  b  :  R}  (hfa  :  FnUb'  f  a)  (hgb  :  FnUb'  g  b)  :\n  FnUb'  (fun  x  ↦  f  x  +  g  x)  (a  +  b)  :=  fun  x  ↦  add_le_add  (hfa  x)  (hgb  x) \n```", "```py\nexample  (f  :  ℝ  →  ℝ)  (h  :  Monotone  f)  :  ∀  {a  b},  a  ≤  b  →  f  a  ≤  f  b  :=\n  @h \n```", "```py\nexample  (mf  :  Monotone  f)  (mg  :  Monotone  g)  :  Monotone  fun  x  ↦  f  x  +  g  x  :=  by\n  intro  a  b  aleb\n  apply  add_le_add\n  apply  mf  aleb\n  apply  mg  aleb \n```", "```py\nexample  (mf  :  Monotone  f)  (mg  :  Monotone  g)  :  Monotone  fun  x  ↦  f  x  +  g  x  :=\n  fun  a  b  aleb  ↦  add_le_add  (mf  aleb)  (mg  aleb) \n```", "```py\nexample  {c  :  ℝ}  (mf  :  Monotone  f)  (nnc  :  0  ≤  c)  :  Monotone  fun  x  ↦  c  *  f  x  :=\n  sorry\n\nexample  (mf  :  Monotone  f)  (mg  :  Monotone  g)  :  Monotone  fun  x  ↦  f  (g  x)  :=\n  sorry \n```", "```py\ndef  FnEven  (f  :  ℝ  →  ℝ)  :  Prop  :=\n  ∀  x,  f  x  =  f  (-x)\n\ndef  FnOdd  (f  :  ℝ  →  ℝ)  :  Prop  :=\n  ∀  x,  f  x  =  -f  (-x)\n\nexample  (ef  :  FnEven  f)  (eg  :  FnEven  g)  :  FnEven  fun  x  ↦  f  x  +  g  x  :=  by\n  intro  x\n  calc\n  (fun  x  ↦  f  x  +  g  x)  x  =  f  x  +  g  x  :=  rfl\n  _  =  f  (-x)  +  g  (-x)  :=  by  rw  [ef,  eg]\n\nexample  (of  :  FnOdd  f)  (og  :  FnOdd  g)  :  FnEven  fun  x  ↦  f  x  *  g  x  :=  by\n  sorry\n\nexample  (ef  :  FnEven  f)  (og  :  FnOdd  g)  :  FnOdd  fun  x  ↦  f  x  *  g  x  :=  by\n  sorry\n\nexample  (ef  :  FnEven  f)  (og  :  FnOdd  g)  :  FnEven  fun  x  ↦  f  (g  x)  :=  by\n  sorry \n```", "```py\nvariable  {α  :  Type*}  (r  s  t  :  Set  α)\n\nexample  :  s  ⊆  s  :=  by\n  intro  x  xs\n  exact  xs\n\ntheorem  Subset.refl  :  s  ⊆  s  :=  fun  x  xs  ↦  xs\n\ntheorem  Subset.trans  :  r  ⊆  s  →  s  ⊆  t  →  r  ⊆  t  :=  by\n  sorry \n```", "```py\nvariable  {α  :  Type*}  [PartialOrder  α]\nvariable  (s  :  Set  α)  (a  b  :  α)\n\ndef  SetUb  (s  :  Set  α)  (a  :  α)  :=\n  ∀  x,  x  ∈  s  →  x  ≤  a\n\nexample  (h  :  SetUb  s  a)  (h'  :  a  ≤  b)  :  SetUb  s  b  :=\n  sorry \n```", "```py\nopen  Function\n\nexample  (c  :  ℝ)  :  Injective  fun  x  ↦  x  +  c  :=  by\n  intro  x₁  x₂  h'\n  exact  (add_left_inj  c).mp  h'\n\nexample  {c  :  ℝ}  (h  :  c  ≠  0)  :  Injective  fun  x  ↦  c  *  x  :=  by\n  sorry \n```", "```py\nvariable  {α  :  Type*}  {β  :  Type*}  {γ  :  Type*}\nvariable  {g  :  β  →  γ}  {f  :  α  →  β}\n\nexample  (injg  :  Injective  g)  (injf  :  Injective  f)  :  Injective  fun  x  ↦  g  (f  x)  :=  by\n  sorry \n```", "```py\nexample  :  ∃  x  :  ℝ,  2  <  x  ∧  x  <  3  :=  by\n  use  5  /  2\n  norm_num \n```", "```py\nexample  :  ∃  x  :  ℝ,  2  <  x  ∧  x  <  3  :=  by\n  have  h1  :  2  <  (5  :  ℝ)  /  2  :=  by  norm_num\n  have  h2  :  (5  :  ℝ)  /  2  <  3  :=  by  norm_num\n  use  5  /  2,  h1,  h2 \n```", "```py\nexample  :  ∃  x  :  ℝ,  2  <  x  ∧  x  <  3  :=  by\n  have  h  :  2  <  (5  :  ℝ)  /  2  ∧  (5  :  ℝ)  /  2  <  3  :=  by  norm_num\n  use  5  /  2 \n```", "```py\nexample  :  ∃  x  :  ℝ,  2  <  x  ∧  x  <  3  :=\n  have  h  :  2  <  (5  :  ℝ)  /  2  ∧  (5  :  ℝ)  /  2  <  3  :=  by  norm_num\n  ⟨5  /  2,  h⟩ \n```", "```py\nexample  :  ∃  x  :  ℝ,  2  <  x  ∧  x  <  3  :=\n  ⟨5  /  2,  by  norm_num⟩ \n```", "```py\ndef  FnUb  (f  :  ℝ  →  ℝ)  (a  :  ℝ)  :  Prop  :=\n  ∀  x,  f  x  ≤  a\n\ndef  FnLb  (f  :  ℝ  →  ℝ)  (a  :  ℝ)  :  Prop  :=\n  ∀  x,  a  ≤  f  x\n\ndef  FnHasUb  (f  :  ℝ  →  ℝ)  :=\n  ∃  a,  FnUb  f  a\n\ndef  FnHasLb  (f  :  ℝ  →  ℝ)  :=\n  ∃  a,  FnLb  f  a \n```", "```py\nvariable  {f  g  :  ℝ  →  ℝ}\n\nexample  (ubf  :  FnHasUb  f)  (ubg  :  FnHasUb  g)  :  FnHasUb  fun  x  ↦  f  x  +  g  x  :=  by\n  rcases  ubf  with  ⟨a,  ubfa⟩\n  rcases  ubg  with  ⟨b,  ubgb⟩\n  use  a  +  b\n  apply  fnUb_add  ubfa  ubgb \n```", "```py\nexample  (lbf  :  FnHasLb  f)  (lbg  :  FnHasLb  g)  :  FnHasLb  fun  x  ↦  f  x  +  g  x  :=  by\n  sorry\n\nexample  {c  :  ℝ}  (ubf  :  FnHasUb  f)  (h  :  c  ≥  0)  :  FnHasUb  fun  x  ↦  c  *  f  x  :=  by\n  sorry \n```", "```py\nexample  :  FnHasUb  f  →  FnHasUb  g  →  FnHasUb  fun  x  ↦  f  x  +  g  x  :=  by\n  rintro  ⟨a,  ubfa⟩  ⟨b,  ubgb⟩\n  exact  ⟨a  +  b,  fnUb_add  ubfa  ubgb⟩ \n```", "```py\nexample  :  FnHasUb  f  →  FnHasUb  g  →  FnHasUb  fun  x  ↦  f  x  +  g  x  :=\n  fun  ⟨a,  ubfa⟩  ⟨b,  ubgb⟩  ↦  ⟨a  +  b,  fnUb_add  ubfa  ubgb⟩ \n```", "```py\nexample  (ubf  :  FnHasUb  f)  (ubg  :  FnHasUb  g)  :  FnHasUb  fun  x  ↦  f  x  +  g  x  :=  by\n  obtain  ⟨a,  ubfa⟩  :=  ubf\n  obtain  ⟨b,  ubgb⟩  :=  ubg\n  exact  ⟨a  +  b,  fnUb_add  ubfa  ubgb⟩ \n```", "```py\nexample  (ubf  :  FnHasUb  f)  (ubg  :  FnHasUb  g)  :  FnHasUb  fun  x  ↦  f  x  +  g  x  :=  by\n  cases  ubf\n  case  intro  a  ubfa  =>\n  cases  ubg\n  case  intro  b  ubgb  =>\n  exact  ⟨a  +  b,  fnUb_add  ubfa  ubgb⟩\n\nexample  (ubf  :  FnHasUb  f)  (ubg  :  FnHasUb  g)  :  FnHasUb  fun  x  ↦  f  x  +  g  x  :=  by\n  cases  ubf\n  next  a  ubfa  =>\n  cases  ubg\n  next  b  ubgb  =>\n  exact  ⟨a  +  b,  fnUb_add  ubfa  ubgb⟩\n\nexample  (ubf  :  FnHasUb  f)  (ubg  :  FnHasUb  g)  :  FnHasUb  fun  x  ↦  f  x  +  g  x  :=  by\n  match  ubf,  ubg  with\n  |  ⟨a,  ubfa⟩,  ⟨b,  ubgb⟩  =>\n  exact  ⟨a  +  b,  fnUb_add  ubfa  ubgb⟩\n\nexample  (ubf  :  FnHasUb  f)  (ubg  :  FnHasUb  g)  :  FnHasUb  fun  x  ↦  f  x  +  g  x  :=\n  match  ubf,  ubg  with\n  |  ⟨a,  ubfa⟩,  ⟨b,  ubgb⟩  =>\n  ⟨a  +  b,  fnUb_add  ubfa  ubgb⟩ \n```", "```py\nvariable  {α  :  Type*}  [CommRing  α]\n\ndef  SumOfSquares  (x  :  α)  :=\n  ∃  a  b,  x  =  a  ^  2  +  b  ^  2\n\ntheorem  sumOfSquares_mul  {x  y  :  α}  (sosx  :  SumOfSquares  x)  (sosy  :  SumOfSquares  y)  :\n  SumOfSquares  (x  *  y)  :=  by\n  rcases  sosx  with  ⟨a,  b,  xeq⟩\n  rcases  sosy  with  ⟨c,  d,  yeq⟩\n  rw  [xeq,  yeq]\n  use  a  *  c  -  b  *  d,  a  *  d  +  b  *  c\n  ring \n```", "```py\ntheorem  sumOfSquares_mul'  {x  y  :  α}  (sosx  :  SumOfSquares  x)  (sosy  :  SumOfSquares  y)  :\n  SumOfSquares  (x  *  y)  :=  by\n  rcases  sosx  with  ⟨a,  b,  rfl⟩\n  rcases  sosy  with  ⟨c,  d,  rfl⟩\n  use  a  *  c  -  b  *  d,  a  *  d  +  b  *  c\n  ring \n```", "```py\nexample  (divab  :  a  ∣  b)  (divbc  :  b  ∣  c)  :  a  ∣  c  :=  by\n  rcases  divab  with  ⟨d,  beq⟩\n  rcases  divbc  with  ⟨e,  ceq⟩\n  rw  [ceq,  beq]\n  use  d  *  e;  ring \n```", "```py\nexample  (divab  :  a  ∣  b)  (divac  :  a  ∣  c)  :  a  ∣  b  +  c  :=  by\n  sorry \n```", "```py\nexample  {c  :  ℝ}  :  Surjective  fun  x  ↦  x  +  c  :=  by\n  intro  x\n  use  x  -  c\n  dsimp;  ring \n```", "```py\nexample  {c  :  ℝ}  (h  :  c  ≠  0)  :  Surjective  fun  x  ↦  c  *  x  :=  by\n  sorry \n```", "```py\nexample  (x  y  :  ℝ)  (h  :  x  -  y  ≠  0)  :  (x  ^  2  -  y  ^  2)  /  (x  -  y)  =  x  +  y  :=  by\n  field_simp  [h]\n  ring \n```", "```py\nexample  {f  :  ℝ  →  ℝ}  (h  :  Surjective  f)  :  ∃  x,  f  x  ^  2  =  4  :=  by\n  rcases  h  2  with  ⟨x,  hx⟩\n  use  x\n  rw  [hx]\n  norm_num \n```", "```py\nvariable  {α  :  Type*}  {β  :  Type*}  {γ  :  Type*}\nvariable  {g  :  β  →  γ}  {f  :  α  →  β}\n\nexample  (surjg  :  Surjective  g)  (surjf  :  Surjective  f)  :  Surjective  fun  x  ↦  g  (f  x)  :=  by\n  sorry \n```", "```py\nexample  (h  :  a  <  b)  :  ¬b  <  a  :=  by\n  intro  h'\n  have  :  a  <  a  :=  lt_trans  h  h'\n  apply  lt_irrefl  a  this \n```", "```py\nexample  (h  :  ∀  a,  ∃  x,  f  x  >  a)  :  ¬FnHasUb  f  :=  by\n  intro  fnub\n  rcases  fnub  with  ⟨a,  fnuba⟩\n  rcases  h  a  with  ⟨x,  hx⟩\n  have  :  f  x  ≤  a  :=  fnuba  x\n  linarith \n```", "```py\nexample  (h  :  ∀  a,  ∃  x,  f  x  <  a)  :  ¬FnHasLb  f  :=\n  sorry\n\nexample  :  ¬FnHasUb  fun  x  ↦  x  :=\n  sorry \n```", "```py\n#check  (not_le_of_gt  :  a  >  b  →  ¬a  ≤  b)\n#check  (not_lt_of_ge  :  a  ≥  b  →  ¬a  <  b)\n#check  (lt_of_not_ge  :  ¬a  ≥  b  →  a  <  b)\n#check  (le_of_not_gt  :  ¬a  >  b  →  a  ≤  b) \n```", "```py\nexample  (h  :  Monotone  f)  (h'  :  f  a  <  f  b)  :  a  <  b  :=  by\n  sorry\n\nexample  (h  :  a  ≤  b)  (h'  :  f  b  <  f  a)  :  ¬Monotone  f  :=  by\n  sorry \n```", "```py\nexample  :  ¬∀  {f  :  ℝ  →  ℝ},  Monotone  f  →  ∀  {a  b},  f  a  ≤  f  b  →  a  ≤  b  :=  by\n  intro  h\n  let  f  :=  fun  x  :  ℝ  ↦  (0  :  ℝ)\n  have  monof  :  Monotone  f  :=  by  sorry\n  have  h'  :  f  1  ≤  f  0  :=  le_refl  _\n  sorry \n```", "```py\nexample  (x  :  ℝ)  (h  :  ∀  ε  >  0,  x  <  ε)  :  x  ≤  0  :=  by\n  sorry \n```", "```py\nvariable  {α  :  Type*}  (P  :  α  →  Prop)  (Q  :  Prop)\n\nexample  (h  :  ¬∃  x,  P  x)  :  ∀  x,  ¬P  x  :=  by\n  sorry\n\nexample  (h  :  ∀  x,  ¬P  x)  :  ¬∃  x,  P  x  :=  by\n  sorry\n\nexample  (h  :  ¬∀  x,  P  x)  :  ∃  x,  ¬P  x  :=  by\n  sorry\n\nexample  (h  :  ∃  x,  ¬P  x)  :  ¬∀  x,  P  x  :=  by\n  sorry \n```", "```py\nexample  (h  :  ¬∀  x,  P  x)  :  ∃  x,  ¬P  x  :=  by\n  by_contra  h'\n  apply  h\n  intro  x\n  show  P  x\n  by_contra  h''\n  exact  h'  ⟨x,  h''⟩ \n```", "```py\nexample  (h  :  ¬¬Q)  :  Q  :=  by\n  sorry\n\nexample  (h  :  Q)  :  ¬¬Q  :=  by\n  sorry \n```", "```py\nexample  (h  :  ¬FnHasUb  f)  :  ∀  a,  ∃  x,  f  x  >  a  :=  by\n  sorry \n```", "```py\nexample  (h  :  ¬∀  a,  ∃  x,  f  x  >  a)  :  FnHasUb  f  :=  by\n  push_neg  at  h\n  exact  h\n\nexample  (h  :  ¬FnHasUb  f)  :  ∀  a,  ∃  x,  f  x  >  a  :=  by\n  dsimp  only  [FnHasUb,  FnUb]  at  h\n  push_neg  at  h\n  exact  h \n```", "```py\nexample  (h  :  ¬Monotone  f)  :  ∃  x  y,  x  ≤  y  ∧  f  y  <  f  x  :=  by\n  sorry \n```", "```py\nexample  (h  :  ¬FnHasUb  f)  :  ∀  a,  ∃  x,  f  x  >  a  :=  by\n  contrapose!  h\n  exact  h\n\nexample  (x  :  ℝ)  (h  :  ∀  ε  >  0,  x  ≤  ε)  :  x  ≤  0  :=  by\n  contrapose!  h\n  use  x  /  2\n  constructor  <;>  linarith \n```", "```py\nexample  (h  :  0  <  0)  :  a  >  37  :=  by\n  exfalso\n  apply  lt_irrefl  0  h\n\nexample  (h  :  0  <  0)  :  a  >  37  :=\n  absurd  h  (lt_irrefl  0)\n\nexample  (h  :  0  <  0)  :  a  >  37  :=  by\n  have  h'  :  ¬0  <  0  :=  lt_irrefl  0\n  contradiction \n```", "```py\nexample  {x  y  :  ℝ}  (h₀  :  x  ≤  y)  (h₁  :  ¬y  ≤  x)  :  x  ≤  y  ∧  x  ≠  y  :=  by\n  constructor\n  ·  assumption\n  intro  h\n  apply  h₁\n  rw  [h] \n```", "```py\nexample  {x  y  :  ℝ}  (h₀  :  x  ≤  y)  (h₁  :  ¬y  ≤  x)  :  x  ≤  y  ∧  x  ≠  y  :=\n  ⟨h₀,  fun  h  ↦  h₁  (by  rw  [h])⟩\n\nexample  {x  y  :  ℝ}  (h₀  :  x  ≤  y)  (h₁  :  ¬y  ≤  x)  :  x  ≤  y  ∧  x  ≠  y  :=\n  have  h  :  x  ≠  y  :=  by\n  contrapose!  h₁\n  rw  [h₁]\n  ⟨h₀,  h⟩ \n```", "```py\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y  ∧  x  ≠  y)  :  ¬y  ≤  x  :=  by\n  rcases  h  with  ⟨h₀,  h₁⟩\n  contrapose!  h₁\n  exact  le_antisymm  h₀  h₁\n\nexample  {x  y  :  ℝ}  :  x  ≤  y  ∧  x  ≠  y  →  ¬y  ≤  x  :=  by\n  rintro  ⟨h₀,  h₁⟩  h'\n  exact  h₁  (le_antisymm  h₀  h')\n\nexample  {x  y  :  ℝ}  :  x  ≤  y  ∧  x  ≠  y  →  ¬y  ≤  x  :=\n  fun  ⟨h₀,  h₁⟩  h'  ↦  h₁  (le_antisymm  h₀  h') \n```", "```py\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y  ∧  x  ≠  y)  :  ¬y  ≤  x  :=  by\n  have  ⟨h₀,  h₁⟩  :=  h\n  contrapose!  h₁\n  exact  le_antisymm  h₀  h₁ \n```", "```py\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y  ∧  x  ≠  y)  :  ¬y  ≤  x  :=  by\n  cases  h\n  case  intro  h₀  h₁  =>\n  contrapose!  h₁\n  exact  le_antisymm  h₀  h₁\n\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y  ∧  x  ≠  y)  :  ¬y  ≤  x  :=  by\n  cases  h\n  next  h₀  h₁  =>\n  contrapose!  h₁\n  exact  le_antisymm  h₀  h₁\n\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y  ∧  x  ≠  y)  :  ¬y  ≤  x  :=  by\n  match  h  with\n  |  ⟨h₀,  h₁⟩  =>\n  contrapose!  h₁\n  exact  le_antisymm  h₀  h₁ \n```", "```py\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y  ∧  x  ≠  y)  :  ¬y  ≤  x  :=  by\n  intro  h'\n  apply  h.right\n  exact  le_antisymm  h.left  h'\n\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y  ∧  x  ≠  y)  :  ¬y  ≤  x  :=\n  fun  h'  ↦  h.right  (le_antisymm  h.left  h') \n```", "```py\nexample  {m  n  :  ℕ}  (h  :  m  ∣  n  ∧  m  ≠  n)  :  m  ∣  n  ∧  ¬n  ∣  m  :=\n  sorry \n```", "```py\nexample  :  ∃  x  :  ℝ,  2  <  x  ∧  x  <  4  :=\n  ⟨5  /  2,  by  norm_num,  by  norm_num⟩\n\nexample  (x  y  :  ℝ)  :  (∃  z  :  ℝ,  x  <  z  ∧  z  <  y)  →  x  <  y  :=  by\n  rintro  ⟨z,  xltz,  zlty⟩\n  exact  lt_trans  xltz  zlty\n\nexample  (x  y  :  ℝ)  :  (∃  z  :  ℝ,  x  <  z  ∧  z  <  y)  →  x  <  y  :=\n  fun  ⟨z,  xltz,  zlty⟩  ↦  lt_trans  xltz  zlty \n```", "```py\nexample  :  ∃  x  :  ℝ,  2  <  x  ∧  x  <  4  :=  by\n  use  5  /  2\n  constructor  <;>  norm_num\n\nexample  :  ∃  m  n  :  ℕ,  4  <  m  ∧  m  <  n  ∧  n  <  10  ∧  Nat.Prime  m  ∧  Nat.Prime  n  :=  by\n  use  5\n  use  7\n  norm_num\n\nexample  {x  y  :  ℝ}  :  x  ≤  y  ∧  x  ≠  y  →  x  ≤  y  ∧  ¬y  ≤  x  :=  by\n  rintro  ⟨h₀,  h₁⟩\n  use  h₀\n  exact  fun  h'  ↦  h₁  (le_antisymm  h₀  h') \n```", "```py\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y)  :  ¬y  ≤  x  ↔  x  ≠  y  :=  by\n  constructor\n  ·  contrapose!\n  rintro  rfl\n  rfl\n  contrapose!\n  exact  le_antisymm  h\n\nexample  {x  y  :  ℝ}  (h  :  x  ≤  y)  :  ¬y  ≤  x  ↔  x  ≠  y  :=\n  ⟨fun  h₀  h₁  ↦  h₀  (by  rw  [h₁]),  fun  h₀  h₁  ↦  h₀  (le_antisymm  h  h₁)⟩ \n```", "```py\nexample  {x  y  :  ℝ}  :  x  ≤  y  ∧  ¬y  ≤  x  ↔  x  ≤  y  ∧  x  ≠  y  :=\n  sorry \n```", "```py\ntheorem  aux  {x  y  :  ℝ}  (h  :  x  ^  2  +  y  ^  2  =  0)  :  x  =  0  :=\n  have  h'  :  x  ^  2  =  0  :=  by  sorry\n  pow_eq_zero  h'\n\nexample  (x  y  :  ℝ)  :  x  ^  2  +  y  ^  2  =  0  ↔  x  =  0  ∧  y  =  0  :=\n  sorry \n```", "```py\nexample  (x  :  ℝ)  :  |x  +  3|  <  5  →  -8  <  x  ∧  x  <  2  :=  by\n  rw  [abs_lt]\n  intro  h\n  constructor  <;>  linarith\n\nexample  :  3  ∣  Nat.gcd  6  15  :=  by\n  rw  [Nat.dvd_gcd_iff]\n  constructor  <;>  norm_num \n```", "```py\ntheorem  not_monotone_iff  {f  :  ℝ  →  ℝ}  :  ¬Monotone  f  ↔  ∃  x  y,  x  ≤  y  ∧  f  x  >  f  y  :=  by\n  rw  [Monotone]\n  push_neg\n  rfl\n\nexample  :  ¬Monotone  fun  x  :  ℝ  ↦  -x  :=  by\n  sorry \n```", "```py\nvariable  {α  :  Type*}  [PartialOrder  α]\nvariable  (a  b  :  α)\n\nexample  :  a  <  b  ↔  a  ≤  b  ∧  a  ≠  b  :=  by\n  rw  [lt_iff_le_not_ge]\n  sorry \n```", "```py\nvariable  {α  :  Type*}  [Preorder  α]\nvariable  (a  b  c  :  α)\n\nexample  :  ¬a  <  a  :=  by\n  rw  [lt_iff_le_not_ge]\n  sorry\n\nexample  :  a  <  b  →  b  <  c  →  a  <  c  :=  by\n  simp  only  [lt_iff_le_not_ge]\n  sorry \n```", "```py\nvariable  {x  y  :  ℝ}\n\nexample  (h  :  y  >  x  ^  2)  :  y  >  0  ∨  y  <  -1  :=  by\n  left\n  linarith  [pow_two_nonneg  x]\n\nexample  (h  :  -y  >  x  ^  2  +  1)  :  y  >  0  ∨  y  <  -1  :=  by\n  right\n  linarith  [pow_two_nonneg  x] \n```", "```py\nexample  (h  :  y  >  0)  :  y  >  0  ∨  y  <  -1  :=\n  Or.inl  h\n\nexample  (h  :  y  <  -1)  :  y  >  0  ∨  y  <  -1  :=\n  Or.inr  h \n```", "```py\nexample  :  x  <  |y|  →  x  <  y  ∨  x  <  -y  :=  by\n  rcases  le_or_gt  0  y  with  h  |  h\n  ·  rw  [abs_of_nonneg  h]\n  intro  h;  left;  exact  h\n  ·  rw  [abs_of_neg  h]\n  intro  h;  right;  exact  h \n```", "```py\nexample  :  x  <  |y|  →  x  <  y  ∨  x  <  -y  :=  by\n  cases  le_or_gt  0  y\n  case  inl  h  =>\n  rw  [abs_of_nonneg  h]\n  intro  h;  left;  exact  h\n  case  inr  h  =>\n  rw  [abs_of_neg  h]\n  intro  h;  right;  exact  h \n```", "```py\nexample  :  x  <  |y|  →  x  <  y  ∨  x  <  -y  :=  by\n  cases  le_or_gt  0  y\n  next  h  =>\n  rw  [abs_of_nonneg  h]\n  intro  h;  left;  exact  h\n  next  h  =>\n  rw  [abs_of_neg  h]\n  intro  h;  right;  exact  h\n\nexample  :  x  <  |y|  →  x  <  y  ∨  x  <  -y  :=  by\n  match  le_or_gt  0  y  with\n  |  Or.inl  h  =>\n  rw  [abs_of_nonneg  h]\n  intro  h;  left;  exact  h\n  |  Or.inr  h  =>\n  rw  [abs_of_neg  h]\n  intro  h;  right;  exact  h \n```", "```py\nnamespace  MyAbs\n\ntheorem  le_abs_self  (x  :  ℝ)  :  x  ≤  |x|  :=  by\n  sorry\n\ntheorem  neg_le_abs_self  (x  :  ℝ)  :  -x  ≤  |x|  :=  by\n  sorry\n\ntheorem  abs_add  (x  y  :  ℝ)  :  |x  +  y|  ≤  |x|  +  |y|  :=  by\n  sorry \n```", "```py\ntheorem  lt_abs  :  x  <  |y|  ↔  x  <  y  ∨  x  <  -y  :=  by\n  sorry\n\ntheorem  abs_lt  :  |x|  <  y  ↔  -y  <  x  ∧  x  <  y  :=  by\n  sorry \n```", "```py\nexample  {x  :  ℝ}  (h  :  x  ≠  0)  :  x  <  0  ∨  x  >  0  :=  by\n  rcases  lt_trichotomy  x  0  with  xlt  |  xeq  |  xgt\n  ·  left\n  exact  xlt\n  ·  contradiction\n  ·  right;  exact  xgt \n```", "```py\nexample  {m  n  k  :  ℕ}  (h  :  m  ∣  n  ∨  m  ∣  k)  :  m  ∣  n  *  k  :=  by\n  rcases  h  with  ⟨a,  rfl⟩  |  ⟨b,  rfl⟩\n  ·  rw  [mul_assoc]\n  apply  dvd_mul_right\n  ·  rw  [mul_comm,  mul_assoc]\n  apply  dvd_mul_right \n```", "```py\nexample  {z  :  ℝ}  (h  :  ∃  x  y,  z  =  x  ^  2  +  y  ^  2  ∨  z  =  x  ^  2  +  y  ^  2  +  1)  :  z  ≥  0  :=  by\n  sorry \n```", "```py\nexample  {x  :  ℝ}  (h  :  x  ^  2  =  1)  :  x  =  1  ∨  x  =  -1  :=  by\n  sorry\n\nexample  {x  y  :  ℝ}  (h  :  x  ^  2  =  y  ^  2)  :  x  =  y  ∨  x  =  -y  :=  by\n  sorry \n```", "```py\nvariable  {R  :  Type*}  [CommRing  R]  [IsDomain  R]\nvariable  (x  y  :  R)\n\nexample  (h  :  x  ^  2  =  1)  :  x  =  1  ∨  x  =  -1  :=  by\n  sorry\n\nexample  (h  :  x  ^  2  =  y  ^  2)  :  x  =  y  ∨  x  =  -y  :=  by\n  sorry \n```", "```py\nexample  (P  :  Prop)  :  ¬¬P  →  P  :=  by\n  intro  h\n  cases  em  P\n  ·  assumption\n  ·  contradiction \n```", "```py\nexample  (P  :  Prop)  :  ¬¬P  →  P  :=  by\n  intro  h\n  by_cases  h'  :  P\n  ·  assumption\n  contradiction \n```", "```py\nexample  (P  Q  :  Prop)  :  P  →  Q  ↔  ¬P  ∨  Q  :=  by\n  sorry \n```", "```py\ndef  ConvergesTo  (s  :  ℕ  →  ℝ)  (a  :  ℝ)  :=\n  ∀  ε  >  0,  ∃  N,  ∀  n  ≥  N,  |s  n  -  a|  <  ε \n```", "```py\nexample  :  (fun  x  y  :  ℝ  ↦  (x  +  y)  ^  2)  =  fun  x  y  :  ℝ  ↦  x  ^  2  +  2  *  x  *  y  +  y  ^  2  :=  by\n  ext\n  ring \n```", "```py\nexample  (a  b  :  ℝ)  :  |a|  =  |a  -  b  +  b|  :=  by\n  congr\n  ring \n```", "```py\nexample  {a  :  ℝ}  (h  :  1  <  a)  :  a  <  a  *  a  :=  by\n  convert  (mul_lt_mul_right  _).2  h\n  ·  rw  [one_mul]\n  exact  lt_trans  zero_lt_one  h \n```", "```py\ntheorem  convergesTo_const  (a  :  ℝ)  :  ConvergesTo  (fun  x  :  ℕ  ↦  a)  a  :=  by\n  intro  ε  εpos\n  use  0\n  intro  n  nge\n  rw  [sub_self,  abs_zero]\n  apply  εpos \n```", "```py\ntheorem  convergesTo_add  {s  t  :  ℕ  →  ℝ}  {a  b  :  ℝ}\n  (cs  :  ConvergesTo  s  a)  (ct  :  ConvergesTo  t  b)  :\n  ConvergesTo  (fun  n  ↦  s  n  +  t  n)  (a  +  b)  :=  by\n  intro  ε  εpos\n  dsimp  -- this line is not needed but cleans up the goal a bit.\n  have  ε2pos  :  0  <  ε  /  2  :=  by  linarith\n  rcases  cs  (ε  /  2)  ε2pos  with  ⟨Ns,  hs⟩\n  rcases  ct  (ε  /  2)  ε2pos  with  ⟨Nt,  ht⟩\n  use  max  Ns  Nt\n  sorry \n```", "```py\ntheorem  convergesTo_mul_const  {s  :  ℕ  →  ℝ}  {a  :  ℝ}  (c  :  ℝ)  (cs  :  ConvergesTo  s  a)  :\n  ConvergesTo  (fun  n  ↦  c  *  s  n)  (c  *  a)  :=  by\n  by_cases  h  :  c  =  0\n  ·  convert  convergesTo_const  0\n  ·  rw  [h]\n  ring\n  rw  [h]\n  ring\n  have  acpos  :  0  <  |c|  :=  abs_pos.mpr  h\n  sorry \n```", "```py\ntheorem  exists_abs_le_of_convergesTo  {s  :  ℕ  →  ℝ}  {a  :  ℝ}  (cs  :  ConvergesTo  s  a)  :\n  ∃  N  b,  ∀  n,  N  ≤  n  →  |s  n|  <  b  :=  by\n  rcases  cs  1  zero_lt_one  with  ⟨N,  h⟩\n  use  N,  |a|  +  1\n  sorry \n```", "```py\ntheorem  aux  {s  t  :  ℕ  →  ℝ}  {a  :  ℝ}  (cs  :  ConvergesTo  s  a)  (ct  :  ConvergesTo  t  0)  :\n  ConvergesTo  (fun  n  ↦  s  n  *  t  n)  0  :=  by\n  intro  ε  εpos\n  dsimp\n  rcases  exists_abs_le_of_convergesTo  cs  with  ⟨N₀,  B,  h₀⟩\n  have  Bpos  :  0  <  B  :=  lt_of_le_of_lt  (abs_nonneg  _)  (h₀  N₀  (le_refl  _))\n  have  pos₀  :  ε  /  B  >  0  :=  div_pos  εpos  Bpos\n  rcases  ct  _  pos₀  with  ⟨N₁,  h₁⟩\n  sorry \n```", "```py\ntheorem  convergesTo_mul  {s  t  :  ℕ  →  ℝ}  {a  b  :  ℝ}\n  (cs  :  ConvergesTo  s  a)  (ct  :  ConvergesTo  t  b)  :\n  ConvergesTo  (fun  n  ↦  s  n  *  t  n)  (a  *  b)  :=  by\n  have  h₁  :  ConvergesTo  (fun  n  ↦  s  n  *  (t  n  +  -b))  0  :=  by\n  apply  aux  cs\n  convert  convergesTo_add  ct  (convergesTo_const  (-b))\n  ring\n  have  :=  convergesTo_add  h₁  (convergesTo_mul_const  b  cs)\n  convert  convergesTo_add  h₁  (convergesTo_mul_const  b  cs)  using  1\n  ·  ext;  ring\n  ring \n```", "```py\ntheorem  convergesTo_unique  {s  :  ℕ  →  ℝ}  {a  b  :  ℝ}\n  (sa  :  ConvergesTo  s  a)  (sb  :  ConvergesTo  s  b)  :\n  a  =  b  :=  by\n  by_contra  abne\n  have  :  |a  -  b|  >  0  :=  by  sorry\n  let  ε  :=  |a  -  b|  /  2\n  have  εpos  :  ε  >  0  :=  by\n  change  |a  -  b|  /  2  >  0\n  linarith\n  rcases  sa  ε  εpos  with  ⟨Na,  hNa⟩\n  rcases  sb  ε  εpos  with  ⟨Nb,  hNb⟩\n  let  N  :=  max  Na  Nb\n  have  absa  :  |s  N  -  a|  <  ε  :=  by  sorry\n  have  absb  :  |s  N  -  b|  <  ε  :=  by  sorry\n  have  :  |a  -  b|  <  |a  -  b|  :=  by  sorry\n  exact  lt_irrefl  _  this \n```", "```py\nvariable  {α  :  Type*}  [LinearOrder  α]\n\ndef  ConvergesTo'  (s  :  α  →  ℝ)  (a  :  ℝ)  :=\n  ∀  ε  >  0,  ∃  N,  ∀  n  ≥  N,  |s  n  -  a|  <  ε \n```"]