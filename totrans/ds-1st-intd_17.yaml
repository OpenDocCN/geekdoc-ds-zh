- en: Chapter 12 Collaboration with version control
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章 版本控制协作
- en: 原文：[https://datasciencebook.ca/version-control.html](https://datasciencebook.ca/version-control.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://datasciencebook.ca/version-control.html](https://datasciencebook.ca/version-control.html)
- en: '*You mostly collaborate with yourself, and me-from-two-months-ago never responds
    to email.*'
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*你主要与你自己协作，而两个月前的我从未回复过邮件。*'
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: –Mark T. Holder
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: –Mark T. Holder
- en: 12.1 Overview
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 概述
- en: 'This chapter will introduce the concept of using version control systems to
    track changes to a project over its lifespan, to share and edit code in a collaborative
    team, and to distribute the finished project to its intended audience. This chapter
    will also introduce how to use the two most common version control tools: Git
    for local version control, and GitHub for remote version control. We will focus
    on the most common version control operations used day-to-day in a standard data
    science project. There are many user interfaces for Git; in this chapter we will
    cover the Jupyter Git interface.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍使用版本控制系统来跟踪项目在其生命周期中的更改，在协作团队中共享和编辑代码，以及将完成的项目分发给目标受众。本章还将介绍如何使用两种最常用的版本控制工具：Git用于本地版本控制，GitHub用于远程版本控制。我们将重点关注在标准数据科学项目中日常使用的最常见版本控制操作。Git有许多用户界面；在本章中，我们将介绍Jupyter
    Git界面。
- en: 12.2 Chapter learning objectives
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 章节学习目标
- en: 'By the end of the chapter, readers will be able to do the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，读者将能够做到以下几件事情：
- en: Describe what version control is and why data analysis projects can benefit
    from it.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述版本控制是什么以及为什么数据分析项目可以从它中受益。
- en: Create a remote version control repository on GitHub.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GitHub上创建远程版本控制仓库。
- en: 'Use Jupyter’s Git version control tools for project versioning and collaboration:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jupyter的Git版本控制工具进行项目版本控制和协作：
- en: Clone a remote version control repository to create a local repository.
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆远程版本控制仓库以创建本地仓库。
- en: Commit changes to a local version control repository.
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将更改提交到本地版本控制仓库。
- en: Push local changes to a remote version control repository.
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将本地更改推送到远程版本控制仓库。
- en: Pull changes from a remote version control repository to a local version control
    repository.
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从远程版本控制仓库拉取更改到本地版本控制仓库。
- en: Resolve merge conflicts.
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决合并冲突。
- en: Give collaborators access to a remote GitHub repository.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给予协作者访问远程GitHub仓库的权限。
- en: Communicate with collaborators using GitHub issues.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GitHub问题与协作者进行沟通。
- en: Use best practices when collaborating on a project with others.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在与他人协作的项目中使用最佳实践。
- en: 12.3 What is version control, and why should I use it?
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 什么是版本控制，为什么我应该使用它？
- en: Data analysis projects often require iteration and revision to move from an
    initial idea to a finished product ready for the intended audience. Without deliberate
    and conscious effort towards tracking changes made to the analysis, projects tend
    to become messy. This mess can have serious, negative repercussions on an analysis
    project, including results that your code cannot reproduce, temporary files with
    snippets of ideas that are forgotten or not easy to find, mind-boggling file names
    that make it unclear which is the current working version of the file (e.g., `document_final_draft_final.txt`,
    `to_hand_in_final_v2.txt`, etc.), and more.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 数据分析项目通常需要迭代和修订，从最初的想法到为预期受众准备好的成品。如果没有对分析中做出的更改进行有意识和故意的跟踪，项目往往会变得混乱。这种混乱可能会对分析项目产生严重、负面的影响，包括代码无法重现的结果、包含遗忘或难以找到的想法片段的临时文件、令人困惑的文件名，这使得不清楚哪个是当前的工作版本（例如，`document_final_draft_final.txt`，`to_hand_in_final_v2.txt`等），以及更多。
- en: Additionally, the iterative nature of data analysis projects means that most
    of the time, the final version of the analysis that is shared with the audience
    is only a fraction of what was explored during the development of that analysis.
    Changes in data visualizations and modeling approaches, as well as some negative
    results, are often not observable from reviewing only the final, polished analysis.
    The lack of observability of these parts of the analysis development can lead
    to others repeating things that did not work well, instead of seeing what did
    not work well, and using that as a springboard to new, more fruitful approaches.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，数据分析项目的迭代性质意味着，大多数时候，与观众分享的分析的最终版本只是开发过程中探索的一部分。数据可视化和建模方法的变化，以及一些负面结果，通常只能从审查最终、精炼的分析中观察到。这些分析发展部分的可观察性不足可能导致其他人重复那些不起作用的事情，而不是看到那些不起作用的事情，并以此作为新、更有成效方法的跳板。
- en: Finally, data analyses are typically completed by a team of people rather than
    a single person. This means that files need to be shared across multiple computers,
    and multiple people often end up editing the project simultaneously. In such a
    situation, determining who has the latest version of the project—and how to resolve
    conflicting edits—can be a real challenge.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，数据分析通常由一个团队而不是一个人完成。这意味着文件需要在多台计算机之间共享，并且多个人经常同时编辑项目。在这种情况下，确定谁拥有项目的最新版本以及如何解决冲突性编辑可能是一个真正的挑战。
- en: '*Version control* helps solve these challenges. Version control is the process
    of keeping a record of changes to documents, including when the changes were made
    and who made them, throughout the history of their development. It also provides
    the means both to view earlier versions of the project and to revert changes.
    Version control is most commonly used in software development, but can be used
    for any electronic files for any type of project, including data analyses. Being
    able to record and view the history of a data analysis project is important for
    understanding how and why decisions to use one method or another were made, among
    other things. Version control also facilitates collaboration via tools to share
    edits with others and resolve conflicting edits. But even if you’re working on
    a project alone, you should still use version control. It helps you keep track
    of what you’ve done, when you did it, and what you’re planning to do next!'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*版本控制*有助于解决这些挑战。版本控制是记录文档变更的过程，包括变更发生的时间和谁做出的变更，以及它们的发展历史。它还提供了查看项目早期版本和撤销变更的手段。版本控制最常用于软件开发，但可以用于任何类型项目的任何电子文件，包括数据分析。能够记录和查看数据分析项目的历史对于理解为什么做出使用一种方法而不是另一种方法的决策等至关重要。版本控制还通过共享编辑的工具促进协作，并解决冲突性编辑。但即使你独自工作，你也应该使用版本控制。它帮助你跟踪你所做的工作、何时完成以及你计划做什么！'
- en: 'To version control a project, you generally need two things: a *version control
    system* and a *repository hosting service*. The version control system is the
    software responsible for tracking changes, sharing changes you make with others,
    obtaining changes from others, and resolving conflicting edits. The repository
    hosting service is responsible for storing a copy of the version-controlled project
    online (a *repository*), where you and your collaborators can access it remotely,
    discuss issues and bugs, and distribute your final product. For both of these
    items, there is a wide variety of choices. In this textbook we’ll use Git for
    version control, and GitHub for repository hosting, because both are currently
    the most widely used platforms. In the additional resources section at the end
    of the chapter, we list many of the common version control systems and repository
    hosting services in use today.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要对项目进行版本控制，通常需要两样东西：一个*版本控制系统*和一个*代码仓库托管服务*。版本控制系统是负责跟踪变更、与他人共享你做出的变更、从他人那里获取变更以及解决冲突性编辑的软件。代码仓库托管服务负责在线存储受控项目的副本（即*代码仓库*），你和你合作的伙伴可以远程访问它，讨论问题和错误，并分发你的最终产品。对于这两项，有各种各样的选择。在本教材中，我们将使用Git进行版本控制，并使用GitHub进行代码仓库托管，因为这两个平台目前是最广泛使用的。在章节末尾的附加资源部分，我们列出了今天许多常见的版本控制系统和代码仓库托管服务。
- en: '**Note:** Technically you don’t *have to* use a repository hosting service.
    You can, for example, version control a project that is stored only in a folder
    on your computer—never sharing it on a repository hosting service. But using a
    repository hosting service provides a few big benefits, including managing collaborator
    access permissions, tools to discuss and track bugs, and the ability to have external
    collaborators contribute work, not to mention the safety of having your work backed
    up in the cloud. Since most repository hosting services now offer free accounts,
    there are not many situations in which you wouldn’t want to use one for your project.'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：**从技术上讲，您**不必**使用仓库托管服务。例如，您可以对仅存储在您计算机文件夹中的项目进行版本控制——永远不在仓库托管服务上共享。但使用仓库托管服务提供了一些重大好处，包括管理合作者访问权限、讨论和跟踪错误的工具，以及允许外部合作者贡献工作的能力，更不用说在云端备份您的工作的安全性了。由于大多数仓库托管服务现在都提供免费账户，所以很少会有您不想为项目使用仓库托管服务的情况。'
- en: 12.4 Version control repositories
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4 版本控制仓库
- en: Typically, when we put a data analysis project under version control, we create
    two copies of the repository (Figure [12.1](version-control.html#fig:vc1-no-changes)).
    One copy we use as our primary workspace where we create, edit, and delete files.
    This copy is commonly referred to as the **local repository**. The local repository
    most commonly exists on our computer or laptop, but can also exist within a workspace
    on a server (e.g., JupyterHub). The other copy is typically stored in a repository
    hosting service (e.g., GitHub), where we can easily share it with our collaborators.
    This copy is commonly referred to as the **remote repository**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当我们对数据分析项目进行版本控制时，我们会创建两个仓库副本（见图 [12.1](version-control.html#fig:vc1-no-changes)）。一个副本我们用作主工作区，在这里我们创建、编辑和删除文件。这个副本通常被称为**本地仓库**。本地仓库通常存在于我们的计算机或笔记本电脑上，但也可以存在于服务器上的工作区中（例如，JupyterHub）。另一个副本通常存储在仓库托管服务中（例如，GitHub），我们可以轻松地与我们的合作者共享它。这个副本通常被称为**远程仓库**。
- en: '![Schematic of local and remote version control repositories.](../Images/520f6322a9160aaff97ed2596048f205.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![本地和远程版本控制仓库的示意图](../Images/520f6322a9160aaff97ed2596048f205.png)'
- en: 'Figure 12.1: Schematic of local and remote version control repositories.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1：本地和远程版本控制仓库的示意图。
- en: Both copies of the repository have a **working directory** where you can create,
    store, edit, and delete files (e.g., `analysis.ipynb` in Figure [12.1](version-control.html#fig:vc1-no-changes)).
    Both copies of the repository also maintain a full project history (Figure [12.1](version-control.html#fig:vc1-no-changes)).
    This history is a record of all versions of the project files that have been created.
    The repository history is not automatically generated; Git must be explicitly
    told when to record a version of the project. These records are called **commits**.
    They are a snapshot of the file contents as well metadata about the repository
    at that time the record was created (who made the commit, when it was made, etc.).
    In the local and remote repositories shown in Figure [12.1](version-control.html#fig:vc1-no-changes),
    there are two commits represented as rectangles inside the “Repository History”
    sections. The white rectangle represents the most recent commit, while faded rectangles
    represent previous commits. Each commit can be identified by a human-readable
    **message**, which you write when you make a commit, and a **commit hash** that
    Git automatically adds for you.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库的两个副本都有一个**工作目录**，您可以在其中创建、存储、编辑和删除文件（例如，图 [12.1](version-control.html#fig:vc1-no-changes)
    中的 `analysis.ipynb`）。仓库的两个副本也维护了完整的项目历史（见图 [12.1](version-control.html#fig:vc1-no-changes)）。这个历史记录了所有已创建的项目文件版本。仓库历史不是自动生成的；Git
    必须明确告知何时记录项目的版本。这些记录被称为**提交**。它们是文件内容的快照以及记录创建时仓库的元数据（谁创建了提交，何时创建等）。在图 [12.1](version-control.html#fig:vc1-no-changes)
    中显示的本地和远程仓库中，有两个提交以矩形的形式表示在“仓库历史”部分中。白色矩形代表最近的提交，而模糊的矩形代表之前的提交。每个提交都可以通过您在提交时编写的**消息**和
    Git 自动为您添加的**提交哈希**来识别。
- en: 'The purpose of the message is to contain a brief, rich description of what
    work was done since the last commit. Messages act as a very useful narrative of
    the changes to a project over its lifespan. If you ever want to view or revert
    to an earlier version of the project, the message can help you identify which
    commit to view or revert to. In Figure [12.1](version-control.html#fig:vc1-no-changes),
    you can see two such messages, one for each commit: `Created README.md` and `Added
    analysis draft`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 消息的目的是包含一个简短、丰富的描述，说明自上次提交以来完成了哪些工作。消息充当了项目在其生命周期中变化的非常有用的叙述。如果你想要查看或回退到项目的早期版本，消息可以帮助你识别要查看或回退到的提交。在图[12.1](version-control.html#fig:vc1-no-changes)中，你可以看到两个这样的消息，每个提交一个：`Created
    README.md`和`Added analysis draft`。
- en: 'The hash is a string of characters consisting of about 40 letters and numbers.
    The purpose of the hash is to serve as a unique identifier for the commit, and
    is used by Git to index project history. Although hashes are quite long—imagine
    having to type out 40 precise characters to view an old project version!—Git is
    able to work with shorter versions of hashes. In Figure [12.1](version-control.html#fig:vc1-no-changes),
    you can see two of these shortened hashes, one for each commit: `Daa29d6` and
    `884c7ce`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希是一个由大约40个字母和数字组成的字符串。哈希的作用是作为提交的唯一标识符，并由Git用于索引项目历史。尽管哈希很长——想象一下，为了查看旧项目版本，你需要输入40个精确的字符！——Git能够处理哈希的较短版本。在图[12.1](version-control.html#fig:vc1-no-changes)中，你可以看到两个这样的缩短的哈希，每个提交一个：`Daa29d6`和`884c7ce`。
- en: 12.5 Version control workflows
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.5 版本控制工作流程
- en: 'When you work in a local version-controlled repository, there are generally
    three additional steps you must take as part of your regular workflow. In addition
    to just working on files—creating, editing, and deleting files as you normally
    would—you must:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在本地版本控制的仓库中工作时，通常有三个额外的步骤是你必须作为常规工作流程的一部分来执行的。除了仅仅处理文件——创建、编辑和删除文件，就像你通常做的那样——你还必须：
- en: Tell Git when to make a commit of your own changes in the local repository.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉Git何时在本地仓库中提交你的变更。
- en: Tell Git when to send your new commits to the remote GitHub repository.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉Git何时将你的新提交发送到远程GitHub仓库。
- en: Tell Git when to retrieve any new changes (that others made) from the remote
    GitHub repository.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉Git何时从远程GitHub仓库检索任何新的变更（其他人所做的）。
- en: In this section we will discuss all three of these steps in detail.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将详细讨论这三个步骤。
- en: 12.5.1 Committing changes to a local repository
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5.1 提交本地仓库的变更
- en: When working on files in your local version control repository (e.g., using
    Jupyter) and saving your work, these changes will only initially exist in the
    working directory of the local repository (Figure [12.2](version-control.html#fig:vc2-changes)).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在本地版本控制仓库中的文件（例如，使用Jupyter）上工作并保存你的工作，这些变更最初只存在于本地仓库的工作目录中（图[12.2](version-control.html#fig:vc2-changes)）。
- en: '![Local repository with changes to files.](../Images/e96765bd8ec9e0c341fb0eb219fc9fd0.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![本地仓库中文件有变更](../Images/e96765bd8ec9e0c341fb0eb219fc9fd0.png)'
- en: 'Figure 12.2: Local repository with changes to files.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：本地仓库中文件有变更。
- en: Once you reach a point that you want Git to keep a record of the current version
    of your work, you need to **commit** (i.e., snapshot) your changes. A prerequisite
    to this is telling Git which files should be included in that snapshot. We call
    this step **adding** the files to the **staging area**. Note that the staging
    area is not a real physical location on your computer; it is instead a conceptual
    placeholder for these files until they are committed. The benefit of the Git version
    control system using a staging area is that you can choose to commit changes in
    only certain files. For example, in Figure [12.3](version-control.html#fig:vc-ba2-add),
    we add only the two files that are important to the analysis project (`analysis.ipynb`
    and `README.md`) and not our personal scratch notes for the project (`notes.txt`).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你达到想要Git记录当前工作版本的状态时，你需要**提交**（即，快照）你的变更。这一步骤的前提是告诉Git哪些文件应该包含在这个快照中。我们称这一步为**添加**文件到**暂存区**。请注意，暂存区不是你电脑上的一个真实物理位置；它实际上是一个概念上的占位符，直到这些文件被提交。Git版本控制系统使用暂存区的优点是你可以选择只提交某些文件的变更。例如，在图[12.3](version-control.html#fig:vc-ba2-add)中，我们只添加了分析项目重要的两个文件（`analysis.ipynb`和`README.md`），而不是项目个人笔记（`notes.txt`）。
- en: '![Adding modified files to the staging area in the local repository.](../Images/a9f0dfeec088b005c6338a9f3a1ca867.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![将修改后的文件添加到本地仓库的暂存区](../Images/a9f0dfeec088b005c6338a9f3a1ca867.png)'
- en: 'Figure 12.3: Adding modified files to the staging area in the local repository.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：将修改后的文件添加到本地仓库的暂存区。
- en: Once the files we wish to commit have been added to the staging area, we can
    then commit those files to the repository history (Figure [12.4](version-control.html#fig:vc-ba3-commit)).
    When we do this, we are required to include a helpful *commit message* to tell
    collaborators (which often includes future you!) about the changes that were made.
    In Figure [12.4](version-control.html#fig:vc-ba3-commit), the message is `Message
    about changes...`; in your work you should make sure to replace this with an informative
    message about what changed. It is also important to note here that these changes
    are only being committed to the local repository’s history. The remote repository
    on GitHub has not changed, and collaborators are not yet able to see your new
    changes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们希望提交的文件被添加到暂存区，我们就可以将这些文件提交到仓库历史记录中（见图[12.4](version-control.html#fig:vc-ba3-commit)）。当我们这样做时，我们必须包含一个有用的*提交信息*来告知协作者（这通常包括未来的您！）关于所做的更改。在图[12.4](version-control.html#fig:vc-ba3-commit)中，信息是`关于更改的信息...`；在您的工作中，您应该确保用关于更改的信息替换这个信息。这里也很重要的是要注意，这些更改只被提交到本地仓库的历史记录中。GitHub上的远程仓库没有改变，协作者还看不到您的新更改。
- en: '![Committing the modified files in the staging area to the local repository
    history, with an informative message about what changed.](../Images/903d5814fe8275f45ee0a380b74bf0ed.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![将暂存区中修改后的文件提交到本地仓库历史记录，并附上关于更改的信息。](../Images/903d5814fe8275f45ee0a380b74bf0ed.png)'
- en: 'Figure 12.4: Committing the modified files in the staging area to the local
    repository history, with an informative message about what changed.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：将暂存区中修改后的文件提交到本地仓库历史记录，并附上关于更改的信息。
- en: 12.5.2 Pushing changes to a remote repository
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5.2 推送更改到远程仓库
- en: Once you have made one or more commits that you want to share with your collaborators,
    you need to **push** (i.e., send) those commits back to GitHub (Figure [12.5](version-control.html#fig:vc5-push)).
    This updates the history in the remote repository (i.e., GitHub) to match what
    you have in your local repository. Now when collaborators interact with the remote
    repository, they will be able to see the changes you made. And you can also take
    comfort in the fact that your work is now backed up in the cloud!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您提交了一个或多个想要与协作者共享的更改，您需要将这些更改**推送**（即发送）回GitHub（见图[12.5](version-control.html#fig:vc5-push)）。这会更新远程仓库（即GitHub）的历史记录，以匹配您本地仓库中的内容。现在，当协作者与远程仓库交互时，他们将能够看到您所做的更改。而且您也可以放心，因为您的工作现在已在云端备份！
- en: '![Pushing the commit to send the changes to the remote repository on GitHub.](../Images/20202f8da738a3cbea20adcb729796d8.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![将提交推送到GitHub上的远程仓库以发送更改。](../Images/20202f8da738a3cbea20adcb729796d8.png)'
- en: 'Figure 12.5: Pushing the commit to send the changes to the remote repository
    on GitHub.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：将提交推送到GitHub上的远程仓库以发送更改。
- en: 12.5.3 Pulling changes from a remote repository
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5.3 从远程仓库拉取更改
- en: If you are working on a project with collaborators, they will also be making
    changes to files (e.g., to the analysis code in a Jupyter notebook and the project’s
    README file), committing them to their own local repository, and pushing their
    commits to the remote GitHub repository to share them with you. When they push
    their changes, those changes will only initially exist in the remote GitHub repository
    and not in your local repository (Figure [12.6](version-control.html#fig:vc6-remote-changes)).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在与协作者共同进行项目工作，他们也会对文件进行更改（例如，对Jupyter笔记本中的分析代码和项目的README文件进行更改），并将这些更改提交到他们自己的本地仓库，然后将提交推送到远程GitHub仓库以与您共享。当他们推送更改时，这些更改最初只存在于远程GitHub仓库中，而不是您的本地仓库中（见图[12.6](version-control.html#fig:vc6-remote-changes)）。
- en: '![Changes pushed by collaborators, or created directly on GitHub will not be
    automatically sent to your local repository.](../Images/a4ad42a754e69da949fb472385ad8b24.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![由协作者推动的更改或直接在GitHub上创建的更改将不会自动发送到您的本地仓库。](../Images/a4ad42a754e69da949fb472385ad8b24.png)'
- en: 'Figure 12.6: Changes pushed by collaborators, or created directly on GitHub
    will not be automatically sent to your local repository.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：由协作者推动的更改或直接在GitHub上创建的更改将不会自动发送到您的本地仓库。
- en: To obtain the new changes from the remote repository on GitHub, you will need
    to **pull** those changes to your own local repository. By pulling changes, you
    synchronize your local repository to what is present on GitHub (Figure [12.7](version-control.html#fig:vc7-pull)).
    Additionally, until you pull changes from the remote repository, you will not
    be able to push any more changes yourself (though you will still be able to work
    and make commits in your own local repository).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要从GitHub上的远程仓库获取新的更改，您需要将这些更改**拉取**到您自己的本地仓库。通过拉取更改，您将本地仓库同步到GitHub上现有的内容（如图[12.7](version-control.html#fig:vc7-pull)所示）。此外，直到您从远程仓库拉取更改之前，您将无法推送任何更多更改（尽管您仍然可以在自己的本地仓库中工作并提交更改）。
- en: '![Pulling changes from the remote GitHub repository to synchronize your local
    repository.](../Images/df8c6609acdac002d70a749263475442.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![从远程GitHub仓库拉取更改以同步您的本地仓库。](../Images/df8c6609acdac002d70a749263475442.png)'
- en: 'Figure 12.7: Pulling changes from the remote GitHub repository to synchronize
    your local repository.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：从远程GitHub仓库拉取更改以同步您的本地仓库。
- en: 12.6 Working with remote repositories using GitHub
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.6 使用GitHub处理远程仓库
- en: Now that you have been introduced to some of the key general concepts and workflows
    of Git version control, we will walk through the practical steps. There are several
    different ways to start using version control with a new project. For simplicity
    and ease of setup, we recommend creating a remote repository first. This section
    covers how to both create and edit a remote repository on GitHub. Once you have
    a remote repository set up, we recommend **cloning** (or copying) that repository
    to create a local repository in which you primarily work. You can clone the repository
    either on your own computer or in a workspace on a server (e.g., a JupyterHub
    server). Section [12.7](version-control.html#local-repo-jupyter) below will cover
    this second step in detail.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了Git版本控制的一些关键概念和工作流程，我们将逐步介绍实际步骤。开始使用版本控制的新项目有多种不同的方式。为了简单和易于设置，我们建议首先创建一个远程仓库。本节将介绍如何在GitHub上创建和编辑远程仓库。一旦您设置了远程仓库，我们建议**克隆**（或复制）该仓库以创建一个本地仓库，您主要在这个本地仓库中工作。您可以在自己的计算机上或服务器上的工作区（例如，JupyterHub服务器）上克隆仓库。下面的[12.7](version-control.html#local-repo-jupyter)节将详细介绍这一步骤。
- en: 12.6.1 Creating a remote repository on GitHub
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.6.1 在GitHub上创建远程仓库
- en: Before you can create remote repositories on GitHub, you will need a GitHub
    account; you can sign up for a free account at [https://github.com/](https://github.com/).
    Once you have logged into your account, you can create a new repository to host
    your project by clicking on the “+” icon in the upper right-hand corner, and then
    on “New Repository,” as shown in Figure [12.8](version-control.html#fig:new-repository-01).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在您能够在GitHub上创建远程仓库之前，您需要一个GitHub账户；您可以在[https://github.com/](https://github.com/)注册一个免费账户。一旦您登录了您的账户，您可以通过点击右上角的“+”图标，然后点击“New
    Repository”，如图[12.8](version-control.html#fig:new-repository-01)所示来创建一个新的仓库以托管您的项目。
- en: '![New repositories on GitHub can be created by clicking on “New Repository”
    from the + menu.](../Images/7216862e222d608d989fb4f3c15d72f6.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![在GitHub上，可以通过点击“+”菜单中的“New Repository”来创建新的仓库。](../Images/7216862e222d608d989fb4f3c15d72f6.png)'
- en: 'Figure 12.8: New repositories on GitHub can be created by clicking on “New
    Repository” from the + menu.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：在GitHub上，可以通过点击“+”菜单中的“New Repository”来创建新的仓库。
- en: Repositories can be set up with a variety of configurations, including a name,
    optional description, and the inclusion (or not) of several template files. One
    of the most important configuration items to choose is the visibility to the outside
    world, either public or private. *Public* repositories can be viewed by anyone.
    *Private* repositories can be viewed by only you. Both public and private repositories
    are only editable by you, but you can change that by giving access to other collaborators.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库可以设置各种配置，包括名称、可选描述以及是否包含几个模板文件。选择最重要的配置项之一是向外界展示的可见性，要么是公开的，要么是私有的。**公开**的仓库可以被任何人查看。**私有**的仓库只能由您查看。无论是公开的还是私有的仓库，都只能由您编辑，但您可以通过给予其他协作者访问权限来更改这一点。
- en: 'To get started with a *public* repository having a template `README.md` file,
    take the following steps shown in Figure [12.9](version-control.html#fig:new-repository-02):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用具有模板`README.md`文件的**公开**仓库，请按照图[12.9](version-control.html#fig:new-repository-02)中所示采取以下步骤：
- en: Enter the name of your project repository. In the example below, we use `canadian_languages`.
    Most repositories follow a similar naming convention involving only lowercase
    letter words separated by either underscores or hyphens.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入您项目仓库的名称。在下面的示例中，我们使用`canadian_languages`。大多数仓库遵循类似的命名约定，只涉及由下划线或连字符分隔的小写字母单词。
- en: Choose an option for the privacy of your repository.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您仓库的隐私选项。
- en: Select “Add a README file.” This creates a template `README.md` file in your
    repository’s root folder.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“添加一个README文件。”这将在您的仓库根目录中创建一个模板文件`README.md`。
- en: When you are happy with your repository name and configuration, click on the
    green “Create Repository” button.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您对仓库名称和配置满意时，点击绿色的“创建仓库”按钮。
- en: '![Repository configuration for a project that is public and initialized with
    a README.md template file.](../Images/96fef3f53a311edb8f6bb8cec3110b15.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![公共项目且以README.md模板文件初始化的仓库配置](../Images/96fef3f53a311edb8f6bb8cec3110b15.png)'
- en: 'Figure 12.9: Repository configuration for a project that is public and initialized
    with a README.md template file.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9：公共项目且以README.md模板文件初始化的仓库配置。
- en: A newly created public repository with a `README.md` template file should look
    something like what is shown in Figure [12.10](version-control.html#fig:new-repository-03).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新创建的公共仓库，带有`README.md`模板文件，其外观应类似于图[12.10](version-control.html#fig:new-repository-03)中所示。
- en: '![Respository configuration for a project that is public and initialized with
    a README.md template file.](../Images/d37c279e5d1f80f6537275d72442f3b4.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![公共项目且以README.md模板文件初始化的仓库配置](../Images/d37c279e5d1f80f6537275d72442f3b4.png)'
- en: 'Figure 12.10: Respository configuration for a project that is public and initialized
    with a README.md template file.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10：公共项目且以README.md模板文件初始化的仓库配置。
- en: 12.6.2 Editing files on GitHub with the pen tool
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.6.2 使用笔工具在GitHub上编辑文件
- en: The pen tool can be used to edit existing plain text files. When you click on
    the pen tool, the file will be opened in a text box where you can use your keyboard
    to make changes (Figures [12.11](version-control.html#fig:pen-tool-01) and [12.12](version-control.html#fig:pen-tool-02)).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用笔工具来编辑现有的纯文本文件。当您点击笔工具时，文件将在一个文本框中打开，您可以使用键盘进行更改（见图[12.11](version-control.html#fig:pen-tool-01)和[12.12](version-control.html#fig:pen-tool-02)）。
- en: '![Clicking on the pen tool opens a text box for editing plain text files.](../Images/3bd4e6642dafbc3ca5c57651deabad47.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![点击笔工具打开用于编辑纯文本文件的文本框](../Images/3bd4e6642dafbc3ca5c57651deabad47.png)'
- en: 'Figure 12.11: Clicking on the pen tool opens a text box for editing plain text
    files. ![The text box where edits can be made after clicking on the pen tool.](../Images/3cacbd3c7619b6c54ce5a3772bd439ab.png)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11：点击笔工具打开用于编辑纯文本文件的文本框。![点击笔工具后可以进行编辑的文本框](../Images/3cacbd3c7619b6c54ce5a3772bd439ab.png)
- en: 'Figure 12.12: The text box where edits can be made after clicking on the pen
    tool.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12：点击笔工具后可以进行编辑的文本框。
- en: After you are done with your edits, they can be “saved” by *committing* your
    changes. When you *commit a file* in a repository, the version control system
    takes a snapshot of what the file looks like. As you continue working on the project,
    over time you will possibly make many commits to a single file; this generates
    a useful version history for that file. On GitHub, if you click the green “Commit
    changes” button, it will save the file and then make a commit (Figure [12.13](version-control.html#fig:pen-tool-03)).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 完成您的编辑后，可以通过*提交*您的更改来“保存”。当您在仓库中*提交一个文件*时，版本控制系统会拍摄该文件的一个快照。随着您继续在项目上工作，随着时间的推移，您可能会对单个文件进行多次提交；这为该文件生成一个有用的版本历史。在GitHub上，如果您点击绿色的“提交更改”按钮，它将保存文件并执行提交（见图[12.13](version-control.html#fig:pen-tool-03)）。
- en: Recall from Section [12.5.1](version-control.html#commit-changes) that you normally
    have to add files to the staging area before committing them. Why don’t we have
    to do that when we work directly on GitHub? Behind the scenes, when you click
    the green “Commit changes” button, GitHub *is* adding that one file to the staging
    area prior to committing it. But note that on GitHub you are limited to committing
    changes to only one file at a time. When you work in your own local repository,
    you can commit changes to multiple files simultaneously. This is especially useful
    when one “improvement” to the project involves modifying multiple files. You can
    also do things like run code when working in a local repository, which you cannot
    do on GitHub. In general, editing on GitHub is reserved for small edits to plain
    text files.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从第[12.5.1](version-control.html#commit-changes)节回忆，您通常在提交之前必须将文件添加到暂存区。为什么我们在GitHub上直接工作时不需要这样做？在幕后，当您点击绿色“提交更改”按钮时，GitHub实际上是在提交之前将那个文件添加到暂存区。但请注意，在GitHub上，您每次只能提交一个文件的更改。当您在自己的本地仓库中工作时，您可以同时提交多个文件的更改。这在涉及修改多个文件的项目“改进”时特别有用。您还可以在本地仓库中执行诸如运行代码之类的操作，这在GitHub上是不可能的。总的来说，GitHub上的编辑仅限于对纯文本文件进行的小幅编辑。
- en: '![Saving changes using the pen tool requires committing those changes, and
    an associated commit message.](../Images/9415d483c9e8f0a940c189fb65bc64aa.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![使用笔工具保存更改需要提交这些更改，并关联一个提交信息。](../Images/9415d483c9e8f0a940c189fb65bc64aa.png)'
- en: 'Figure 12.13: Saving changes using the pen tool requires committing those changes,
    and an associated commit message.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13：使用笔工具保存更改需要提交这些更改，并关联一个提交信息。
- en: 12.6.3 Creating files on GitHub with the “Add file” menu
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.6.3 使用“添加文件”菜单在GitHub上创建文件
- en: The “Add file” menu can be used to create new plain text files and upload files
    from your computer. To create a new plain text file, click the “Add file” drop-down
    menu and select the “Create new file” option (Figure [12.14](version-control.html#fig:create-new-file-01)).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: “添加文件”菜单可用于创建新的纯文本文件并将文件从您的计算机上传。要创建一个新的纯文本文件，请点击“添加文件”下拉菜单并选择“创建新文件”选项（图12.14）（version-control.html#fig:create-new-file-01）。
- en: '![New plain text files can be created directly on GitHub.](../Images/0b9b8cad76908cda0c42559f1f3cbee9.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![在GitHub上可以直接创建新的纯文本文件。](../Images/0b9b8cad76908cda0c42559f1f3cbee9.png)'
- en: 'Figure 12.14: New plain text files can be created directly on GitHub.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14：在GitHub上可以直接创建新的纯文本文件。
- en: A page will open with a small text box for the file name to be entered, and
    a larger text box where the desired file content text can be entered. Note the
    two tabs, “Edit new file” and “Preview”. Toggling between them lets you enter
    and edit text and view what the text will look like when rendered, respectively
    (Figure [12.15](version-control.html#fig:create-new-file-02)). Note that GitHub
    understands and renders `.md` files using a markdown syntax very similar to Jupyter
    notebooks, so the “Preview” tab is especially helpful for checking markdown code
    correctness.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将打开一个页面，其中包含一个用于输入文件名的小文本框，以及一个较大的文本框，可以在其中输入所需的文件内容文本。注意两个标签，“编辑新文件”和“预览”。在它们之间切换可以让您输入和编辑文本，并分别查看文本渲染后的样子（图12.15）（version-control.html#fig:create-new-file-02）。请注意，GitHub理解并使用与Jupyter笔记本非常相似的Markdown语法来渲染`.md`文件，因此“预览”标签对于检查Markdown代码的正确性特别有帮助。
- en: '![New plain text files require a file name in the text box circled in red,
    and file content entered in the larger text box (red arrow).](../Images/5e38731338e61cdb5d1b75ef378cdcd6.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![新的纯文本文件需要在红色圆圈中的文本框中输入文件名，并在较大的文本框（红色箭头）中输入文件内容。](../Images/5e38731338e61cdb5d1b75ef378cdcd6.png)'
- en: 'Figure 12.15: New plain text files require a file name in the text box circled
    in red, and file content entered in the larger text box (red arrow).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15：新的纯文本文件需要在红色圆圈中的文本框中输入文件名，并在较大的文本框（红色箭头）中输入文件内容。
- en: Save and commit your changes by clicking the green “Commit changes” button at
    the bottom of the page (Figure [12.16](version-control.html#fig:create-new-file-03)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击页面底部的绿色“提交更改”按钮（图12.16）保存并提交您的更改（version-control.html#fig:create-new-file-03）。
- en: '![To be saved, newly created files are required to be committed along with
    an associated commit message.](../Images/d3f6e00d9fd895a89b222e9466e4be1c.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![要保存，新创建的文件需要与关联的提交信息一起提交。](../Images/d3f6e00d9fd895a89b222e9466e4be1c.png)'
- en: 'Figure 12.16: To be saved, newly created files are required to be committed
    along with an associated commit message.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16：要保存，新创建的文件需要与关联的提交信息一起提交。
- en: You can also upload files that you have created on your local machine by using
    the “Add file” drop-down menu and selecting “Upload files” (Figure [12.17](version-control.html#fig:upload-files-01)).
    To select the files from your local computer to upload, you can either drag and
    drop them into the gray box area shown in Figure [12.18](version-control.html#fig:upload-files-02),
    or click the “choose your files” link to access a file browser dialog. Once the
    files you want to upload have been selected, click the green “Commit changes”
    button at the bottom of the page (Figure [12.18](version-control.html#fig:upload-files-02)).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用“添加文件”下拉菜单并选择“上传文件”（图12.17）来上传你在本地计算机上创建的文件。要选择要上传的文件，你可以将它们拖放到图12.18中显示的灰色框区域，或者点击“选择你的文件”链接来访问文件浏览器对话框。一旦选择了要上传的文件，请点击页面底部的绿色“提交更改”按钮（图12.18）。
- en: '![New files of any type can be uploaded to GitHub.](../Images/b2755551e368f40625d0ffbf74801da2.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![任何类型的文件都可以上传到GitHub。](../Images/b2755551e368f40625d0ffbf74801da2.png)'
- en: 'Figure 12.17: New files of any type can be uploaded to GitHub. ![Specify files
    to upload by dragging them into the GitHub website (red circle) or by clicking
    on “choose your files.” Uploaded files are also required to be committed along
    with an associated commit message.](../Images/bdeeec9545dea9429fe0c8b7d83ee254.png)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17：任何类型的文件都可以上传到GitHub。![通过将文件拖动到GitHub网站（红色圆圈）或点击“选择你的文件”来指定要上传的文件。上传的文件也需要与相关的提交信息一起提交。](../Images/bdeeec9545dea9429fe0c8b7d83ee254.png)
- en: 'Figure 12.18: Specify files to upload by dragging them into the GitHub website
    (red circle) or by clicking on “choose your files.” Uploaded files are also required
    to be committed along with an associated commit message.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.18：通过将文件拖动到GitHub网站（红色圆圈）或点击“选择你的文件”来指定要上传的文件。上传的文件也需要与相关的提交信息一起提交。
- en: 'Note that Git and GitHub are designed to track changes in individual files.
    **Do not** upload your whole project in an archive file (e.g., `.zip`). If you
    do, then Git can only keep track of changes to the entire `.zip` file, which will
    not be human-readable. Committing one big archive defeats the whole purpose of
    using version control: you won’t be able to see, interpret, or find changes in
    the history of any of the actual content of your project!'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Git和GitHub旨在跟踪单个文件的变化。**不要**将整个项目作为一个存档文件（例如，`.zip`）上传。如果你这样做，Git只能跟踪整个`.zip`文件的变化，这将无法被人类阅读。提交一个大存档文件会违背使用版本控制的目的：你将无法查看、解释或找到项目实际内容中的任何变化的历史记录！
- en: 12.7 Working with local repositories using Jupyter
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.7 使用Jupyter处理本地仓库
- en: Although there are several ways to create and edit files on GitHub, they are
    not quite powerful enough for efficiently creating and editing complex files,
    or files that need to be executed to assess whether they work (e.g., files containing
    code). For example, you wouldn’t be able to run an analysis written with R code
    directly on GitHub. Thus, it is useful to be able to connect the remote repository
    that was created on GitHub to a local coding environment. This can be done by
    creating and working in a local copy of the repository. In this chapter, we focus
    on interacting with Git via Jupyter using the Jupyter Git extension. The Jupyter
    Git extension can be run by Jupyter on your local computer, or on a JupyterHub
    server. We recommend reading Chapter [11](jupyter.html#jupyter) to learn how to
    use Jupyter before reading this chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有几种方法可以在GitHub上创建和编辑文件，但它们并不足以高效地创建和编辑复杂的文件，或者需要执行以评估其是否工作的文件（例如，包含代码的文件）。例如，你无法直接在GitHub上运行用R代码编写的分析。因此，能够将GitHub上创建的远程仓库连接到本地编码环境是非常有用的。这可以通过创建并在此仓库的本地副本中工作来实现。在本章中，我们将重点介绍如何通过Jupyter使用Jupyter
    Git扩展与Git进行交互。Jupyter Git扩展可以在你的本地计算机上或JupyterHub服务器上运行。我们建议在阅读本章之前先阅读第[11](jupyter.html#jupyter)章，以了解如何使用Jupyter。
- en: 12.7.1 Generating a GitHub personal access token
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.7.1 生成GitHub个人访问令牌
- en: To send and retrieve work between your local repository and the remote repository
    on GitHub, you will frequently need to authenticate with GitHub to prove you have
    the required permission. There are several methods to do this, but for beginners
    we recommend using the HTTPS method because it is easier and requires less setup.
    In order to use the HTTPS method, GitHub requires you to provide a *personal access
    token*. A personal access token is like a password—so keep it a secret!—but it
    gives you more fine-grained control over what parts of your account the token
    can be used to access, and lets you set an expiry date for the authentication.
    To generate a personal access token, you must first visit [https://github.com/settings/tokens](https://github.com/settings/tokens),
    which will take you to the “Personal access tokens” page in your account settings.
    Once there, click “Generate new token” (Figure [12.19](version-control.html#fig:generate-pat-01)).
    Note that you may be asked to re-authenticate with your username and password
    to proceed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地仓库和GitHub上的远程仓库之间发送和检索工作，你将经常需要通过GitHub进行身份验证以证明你有所需的权限。有多种方法可以做到这一点，但对于初学者，我们推荐使用HTTPS方法，因为它更简单，且设置要求较低。为了使用HTTPS方法，GitHub要求你提供一个**个人访问令牌**。个人访问令牌就像密码一样——所以请保密！——但它可以让你对令牌可以访问的账户部分有更精细的控制，并允许你为身份验证设置过期日期。要生成个人访问令牌，你必须首先访问[https://github.com/settings/tokens](https://github.com/settings/tokens)，这将带你到账户设置中的“个人访问令牌”页面。一旦到达那里，点击“生成新令牌”（图[12.19](version-control.html#fig:generate-pat-01)）。请注意，你可能需要使用用户名和密码重新进行身份验证才能继续。
- en: '![The “Generate new token” button used to initiate the creation of a new personal
    access token. It is found in the “Personal access tokens” section of the “Developer
    settings” page in your account settings.](../Images/61453d30abfce3837e9e574503f9b54d.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![用于启动创建新个人访问令牌的“生成新令牌”按钮。它位于账户设置中的“开发者设置”页面“个人访问令牌”部分。](../Images/61453d30abfce3837e9e574503f9b54d.png)'
- en: 'Figure 12.19: The “Generate new token” button used to initiate the creation
    of a new personal access token. It is found in the “Personal access tokens” section
    of the “Developer settings” page in your account settings.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.19：用于启动创建新个人访问令牌的“生成新令牌”按钮。它位于账户设置中的“开发者设置”页面“个人访问令牌”部分。
- en: You will be asked to add a note to describe the purpose for your personal access
    token. Next, you need to select permissions for the token; this is where you can
    control what parts of your account the token can be used to access. Make sure
    to choose only those permissions that you absolutely require. In Figure [12.20](version-control.html#fig:generate-pat-02),
    we tick only the “repo” box, which gives the token access to our repositories
    (so that we can push and pull) but none of our other GitHub account features.
    Finally, to generate the token, scroll to the bottom of that page and click the
    green “Generate token” button (Figure [12.20](version-control.html#fig:generate-pat-02)).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被要求添加一个备注来描述你的个人访问令牌的目的。接下来，你需要为令牌选择权限；这是你可以控制令牌可以访问的账户部分的地方。确保只选择你绝对需要的权限。在图[12.20](version-control.html#fig:generate-pat-02)中，我们只勾选了“repo”框，这使令牌可以访问我们的仓库（以便我们可以推送和拉取），但无法访问我们其他GitHub账户功能。最后，要生成令牌，滚动到该页面的底部并点击绿色的“生成令牌”按钮（图[12.20](version-control.html#fig:generate-pat-02))。
- en: '![Webpage for creating a new personal access token.](../Images/29736934068180bff8ed7dfe12ee406e.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![创建新个人访问令牌的网页。](../Images/29736934068180bff8ed7dfe12ee406e.png)'
- en: 'Figure 12.20: Webpage for creating a new personal access token.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20：创建新个人访问令牌的网页。
- en: Finally, you will be taken to a page where you will be able to see and copy
    the personal access token you just generated (Figure [12.21](version-control.html#fig:generate-pat-03)).
    Since it provides access to certain parts of your account, you should treat this
    token like a password; for example, you should consider securely storing it (and
    your other passwords and tokens, too!) using a password manager. Note that this
    page will only display the token to you once, so make sure you store it in a safe
    place right away. If you accidentally forget to store it, though, do not fret—you
    can delete that token by clicking the “Delete” button next to your token, and
    generate a new one from scratch. To learn more about GitHub authentication, see
    the additional resources section at the end of this chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将被带到可以查看和复制你刚刚生成的个人访问令牌的页面（图[12.21](version-control.html#fig:generate-pat-03)）。由于它提供了访问你账户某些部分的能力，你应该像对待密码一样对待这个令牌；例如，你应该考虑使用密码管理器安全地存储它（以及你的其他密码和令牌！）注意，这个页面只会向你显示一次令牌，所以请确保你立即将其存储在安全的地方。如果你不小心忘记了存储它，也不要担心——你可以通过点击你令牌旁边的“删除”按钮来删除该令牌，并从头开始生成一个新的。要了解更多关于GitHub身份验证的信息，请参阅本章末尾的附加资源部分。
- en: '![Display of the newly generated personal access token.](../Images/e12c10034297dac463645e0917d0eb34.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![新生成个人访问令牌的显示](../Images/e12c10034297dac463645e0917d0eb34.png)'
- en: 'Figure 12.21: Display of the newly generated personal access token.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.21：新生成个人访问令牌的显示。
- en: 12.7.2 Cloning a repository using Jupyter
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.7.2 使用Jupyter克隆仓库
- en: '*Cloning* a remote repository from GitHub to create a local repository results
    in a copy that knows where it was obtained from so that it knows where to send/receive
    new committed edits. In order to do this, first copy the URL from the HTTPS tab
    of the Code drop-down menu on GitHub (Figure [12.22](version-control.html#fig:clone-02)).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*克隆* GitHub上的远程仓库以创建本地仓库，结果是一个知道其来源的副本，因此知道在哪里发送/接收新的提交编辑。为了做到这一点，首先从GitHub代码下拉菜单的HTTPS标签页中复制URL（图[12.22](version-control.html#fig:clone-02)）。'
- en: '![The green “Code” drop-down menu contains the remote address (URL) corresponding
    to the location of the remote GitHub repository.](../Images/5d6b5acff5eb889b94418c058f982a7c.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![绿色的“代码”下拉菜单包含对应远程GitHub仓库位置的远程地址（URL）](../Images/5d6b5acff5eb889b94418c058f982a7c.png)'
- en: 'Figure 12.22: The green “Code” drop-down menu contains the remote address (URL)
    corresponding to the location of the remote GitHub repository.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.22：绿色的“代码”下拉菜单包含对应远程GitHub仓库位置的远程地址（URL）。
- en: Open Jupyter, and click the Git+ icon on the file browser tab (Figure [12.23](version-control.html#fig:clone-01)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Jupyter，点击文件浏览器标签页上的Git+图标（图[12.23](version-control.html#fig:clone-01)）。
- en: '![The Jupyter Git Clone icon (red circle).](../Images/db55c3c70f3c510370a51498d8295289.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![Jupyter Git Clone图标（红色圆圈）](../Images/db55c3c70f3c510370a51498d8295289.png)'
- en: 'Figure 12.23: The Jupyter Git Clone icon (red circle).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.23：Jupyter Git Clone图标（红色圆圈）。
- en: Paste the URL of the GitHub project repository you created and click the blue
    “CLONE” button (Figure [12.24](version-control.html#fig:clone-03)).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将你创建的GitHub项目仓库的URL粘贴并点击蓝色的“CLONE”按钮（图[12.24](version-control.html#fig:clone-03)）。
- en: '![Prompt where the remote address (URL) corresponding to the location of the
    GitHub repository needs to be input in Jupyter.](../Images/ef9b05aabfcfde76ebb9849673afe331.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![在Jupyter中输入对应GitHub仓库位置的远程地址（URL）的提示框](../Images/ef9b05aabfcfde76ebb9849673afe331.png)'
- en: 'Figure 12.24: Prompt where the remote address (URL) corresponding to the location
    of the GitHub repository needs to be input in Jupyter.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.24：在Jupyter中输入对应GitHub仓库位置的远程地址（URL）的提示框。
- en: On the file browser tab, you will now see a folder for the repository. Inside
    this folder will be all the files that existed on GitHub (Figure [12.25](version-control.html#fig:clone-04)).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件浏览器标签页上，你现在会看到一个仓库文件夹。在这个文件夹内将包含GitHub上所有存在的文件（图[12.25](version-control.html#fig:clone-04)）。
- en: '![Cloned GitHub repositories can been seen and accessed via the Jupyter file
    browser.](../Images/c5fcf63f836a562c5cc45ac74d5e5fd7.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![通过Jupyter文件浏览器可以看到并访问克隆的GitHub仓库。](../Images/c5fcf63f836a562c5cc45ac74d5e5fd7.png)'
- en: 'Figure 12.25: Cloned GitHub repositories can been seen and accessed via the
    Jupyter file browser.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.25：通过Jupyter文件浏览器可以看到并访问克隆的GitHub仓库。
- en: 12.7.3 Specifying files to commit
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.7.3 指定要提交的文件
- en: Now that you have cloned the remote repository from GitHub to create a local
    repository, you can get to work editing, creating, and deleting files. For example,
    suppose you created and saved a new file (named `eda.ipynb`) that you would like
    to send back to the project repository on GitHub (Figure [12.26](version-control.html#fig:git-add-01)).
    To “add” this modified file to the staging area (i.e., flag that this is a file
    whose changes we would like to commit), click the Jupyter Git extension icon on
    the far left-hand side of Jupyter (Figure [12.26](version-control.html#fig:git-add-01)).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经从 GitHub 克隆了远程仓库以创建本地仓库，你可以开始编辑、创建和删除文件。例如，假设你创建并保存了一个新的文件（命名为 `eda.ipynb`），你希望将其发送回
    GitHub 上的项目仓库（图 [12.26](version-control.html#fig:git-add-01)）。要将此修改后的文件“添加”到暂存区（即标记为希望提交的更改文件），请点击
    Jupyter 左侧远端的 Jupyter Git 扩展图标（图 [12.26](version-control.html#fig:git-add-01)）。
- en: '![Jupyter Git extension icon (circled in red).](../Images/f8b400aa43484ae61b67249da6240be0.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![Jupyter Git 扩展图标（用红色圆圈标注）。](../Images/f8b400aa43484ae61b67249da6240be0.png)'
- en: 'Figure 12.26: Jupyter Git extension icon (circled in red).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.26：Jupyter Git 扩展图标（用红色圆圈标注）。
- en: This opens the Jupyter Git graphical user interface pane. Next, click the plus
    sign (+) beside the file(s) that you want to “add” (Figure [12.27](version-control.html#fig:git-add-02)).
    Note that because this is the first change for this file, it falls under the “Untracked”
    heading. However, next time you edit this file and want to add the changes, you
    will find it under the “Changed” heading.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开 Jupyter Git 图形用户界面面板。接下来，点击你想要“添加”的文件（图 [12.27](version-control.html#fig:git-add-02)）旁边的加号（+）。请注意，因为这是该文件的第一次更改，它属于“未跟踪”标题。然而，下次你编辑此文件并想要添加更改时，你将在“已更改”标题下找到它。
- en: You will also see an `eda-checkpoint.ipynb` file under the “Untracked” heading.
    This is a temporary “checkpoint file” created by Jupyter when you work on `eda.ipynb`.
    You generally do not want to add auto-generated files to Git repositories; only
    add the files you directly create and edit.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你也会在“未跟踪”标题下看到 `eda-checkpoint.ipynb` 文件。这是 Jupyter 在你编辑 `eda.ipynb` 时创建的一个临时“检查点文件”。通常，你不想将自动生成的文件添加到
    Git 仓库中；只添加你直接创建和编辑的文件。
- en: '![eda.ipynb is added to the staging area via the plus sign (+).](../Images/615fb21807fa0d360c9d6dad9739e3c7.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![通过加号（+）将 `eda.ipynb` 添加到暂存区。](../Images/615fb21807fa0d360c9d6dad9739e3c7.png)'
- en: 'Figure 12.27: `eda.ipynb` is added to the staging area via the plus sign (+).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.27：通过加号（+）将 `eda.ipynb` 添加到暂存区。
- en: Clicking the plus sign (+) moves the file from the “Untracked” heading to the
    “Staged” heading, so that Git knows you want a snapshot of its current state as
    a commit (Figure [12.28](version-control.html#fig:git-add-03)). Now you are ready
    to “commit” the changes. Make sure to include a (clear and helpful!) message about
    what was changed so that your collaborators (and future you) know what happened
    in this commit.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 点击加号（+）将文件从“未跟踪”标题移动到“已暂存”标题，这样 Git 就知道你想要快照其当前状态作为提交（图 [12.28](version-control.html#fig:git-add-03)）。现在你准备好“提交”更改了。确保包含一个（清晰且有帮助的！）关于更改了什么的消息，以便你的合作者（以及未来的你）知道这次提交发生了什么。
- en: '![Adding eda.ipynb makes it visible in the staging area.](../Images/272a99d596ae17a84e4f83f23d76755f.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![添加 `eda.ipynb` 使其在暂存区中可见。](../Images/272a99d596ae17a84e4f83f23d76755f.png)'
- en: 'Figure 12.28: Adding `eda.ipynb` makes it visible in the staging area.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.28：添加 `eda.ipynb` 使其在暂存区中可见。
- en: 12.7.4 Making the commit
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.7.4 提交更改
- en: To snapshot the changes with an associated commit message, you must put a message
    in the text box at the bottom of the Git pane and click on the blue “Commit” button
    (Figure [12.29](version-control.html#fig:git-commit-01)). It is highly recommended
    to write useful and meaningful messages about what was changed. These commit messages,
    and the datetime stamp for a given commit, are the primary means to navigate through
    the project’s history in the event that you need to view or retrieve a past version
    of a file, or revert your project to an earlier state. When you click the “Commit”
    button for the first time, you will be prompted to enter your name and email.
    This only needs to be done once for each machine you use Git on.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要与相关的提交信息一起快照更改，你必须在 Git 面板底部的文本框中输入信息并点击蓝色“提交”按钮（图 [12.29](version-control.html#fig:git-commit-01)）。强烈建议写一些有用且有意义的信息，关于更改了什么。这些提交信息以及特定提交的日期时间戳是导航项目历史的主要手段，以防你需要查看或检索文件的过去版本，或者将项目回滚到早期状态。当你第一次点击“提交”按钮时，你将被提示输入你的姓名和电子邮件。这只需要在每个你使用
    Git 的机器上做一次。
- en: '![A commit message must be added into the Jupyter Git extension commit text
    box before the blue Commit button can be used to record the commit.](../Images/20579c1a9407fc858a76fc5b24864071.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![在蓝色提交按钮可以用来记录提交之前，必须在 Jupyter Git 扩展的提交文本框中添加提交信息。](../Images/20579c1a9407fc858a76fc5b24864071.png)'
- en: 'Figure 12.29: A commit message must be added into the Jupyter Git extension
    commit text box before the blue Commit button can be used to record the commit.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.29：在蓝色提交按钮可以用来记录提交之前，必须在 Jupyter Git 扩展的提交文本框中添加提交信息。
- en: After “committing” the file(s), you will see there are 0 “Staged” files. You
    are now ready to push your changes to the remote repository on GitHub (Figure
    [12.30](version-control.html#fig:git-commit-03)).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在“提交”文件（夹）后，您将看到现在有 0 个“暂存”文件。您现在可以准备好将更改推送到 GitHub 上的远程仓库（图 [12.30](version-control.html#fig:git-commit-03)）。
- en: '![After recording a commit, the staging area should be empty.](../Images/37497200a04482c9b377c42cb5a78174.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![记录提交后，暂存区应为空。](../Images/37497200a04482c9b377c42cb5a78174.png)'
- en: 'Figure 12.30: After recording a commit, the staging area should be empty.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.30：记录提交后，暂存区应为空。
- en: 12.7.5 Pushing the commits to GitHub
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.7.5 将提交推送到 GitHub
- en: To send the committed changes back to the remote repository on GitHub, you need
    to *push* them. To do this, click on the cloud icon with the up arrow on the Jupyter
    Git tab (Figure [12.31](version-control.html#fig:git-push-01)).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要将提交的更改发送回 GitHub 上的远程仓库，您需要*推送*它们。为此，请在 Jupyter Git 选项卡上点击带有向上箭头的云图标（图 [12.31](version-control.html#fig:git-push-01)）。
- en: '![The Jupyter Git extension “push” button (circled in red).](../Images/ff22867a33138b66a68c917f0517245d.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![Jupyter Git 扩展的“推送”按钮（用红色圆圈标注）。](../Images/ff22867a33138b66a68c917f0517245d.png)'
- en: 'Figure 12.31: The Jupyter Git extension “push” button (circled in red).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.31：Jupyter Git 扩展的“推送”按钮（用红色圆圈标注）。
- en: You will then be prompted to enter your GitHub username and the personal access
    token that you generated earlier (not your account password!). Click the blue
    “OK” button to initiate the push (Figure [12.32](version-control.html#fig:git-push-02)).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将被提示输入您的 GitHub 用户名和您之前生成的个人访问令牌（不是您的账户密码！）！点击蓝色“确定”按钮以启动推送（图 [12.32](version-control.html#fig:git-push-02)）。
- en: '![Enter your Git credentials to authorize the push to the remote repository.](../Images/5fb7c6bcbec9a3fa5b998be707ce1506.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![输入您的 Git 凭据以授权将推送至远程仓库。](../Images/5fb7c6bcbec9a3fa5b998be707ce1506.png)'
- en: 'Figure 12.32: Enter your Git credentials to authorize the push to the remote
    repository.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.32：输入您的 Git 凭据以授权将推送至远程仓库。
- en: If the files were successfully pushed to the project repository on GitHub, you
    will be shown a success message (Figure [12.33](version-control.html#fig:git-push-03)).
    Click “Dismiss” to continue working in Jupyter.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件已成功推送到 GitHub 的项目仓库，您将看到一个成功消息（图 [12.33](version-control.html#fig:git-push-03)）。点击“忽略”以继续在
    Jupyter 中工作。
- en: '![The prompt that the push was successful.](../Images/65910866ccebaa2216b339b0c0935d55.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![推送成功的提示信息。](../Images/65910866ccebaa2216b339b0c0935d55.png)'
- en: 'Figure 12.33: The prompt that the push was successful.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.33：推送成功的提示信息。
- en: If you visit the remote repository on GitHub, you will see that the changes
    now exist there too (Figure [12.34](version-control.html#fig:git-push-04))!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您访问 GitHub 上的远程仓库，您将看到更改现在也存在那里（图 [12.34](version-control.html#fig:git-push-04)）！
- en: '![The GitHub web interface shows a preview of the commit message, and the time
    of the most recently pushed commit for each file.](../Images/696fcf71e61bf9c5d9250076a189a22a.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![GitHub 网页界面显示了提交消息的预览，以及每个文件的最新推送提交时间。](../Images/696fcf71e61bf9c5d9250076a189a22a.png)'
- en: 'Figure 12.34: The GitHub web interface shows a preview of the commit message,
    and the time of the most recently pushed commit for each file.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.34：GitHub 网页界面显示了提交消息的预览，以及每个文件的最新推送提交时间。
- en: 12.8 Collaboration
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.8 协作
- en: 12.8.1 Giving collaborators access to your project
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.8.1 授予合作者对项目的访问权限
- en: As mentioned earlier, GitHub allows you to control who has access to your project.
    The default of both public and private projects are that only the person who created
    the GitHub repository has permissions to create, edit and delete files (*write
    access*). To give your collaborators write access to the projects, navigate to
    the “Settings” tab (Figure [12.35](version-control.html#fig:add-collab-01)).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，GitHub 允许您控制谁可以访问您的项目。公共和私有项目的默认设置都是，只有创建 GitHub 仓库的人才有权限创建、编辑和删除文件（*写入权限*）。要授予您的合作者对项目的写入权限，请转到“设置”选项卡（图
    [12.35](version-control.html#fig:add-collab-01)）。
- en: '![The “Settings” tab on the GitHub web interface.](../Images/2e2a7f682f933a6f401552d4d4895dfb.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![GitHub网页界面上的“设置”标签页](../Images/2e2a7f682f933a6f401552d4d4895dfb.png)'
- en: 'Figure 12.35: The “Settings” tab on the GitHub web interface.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.35：GitHub网页界面上的“设置”标签页。
- en: Then click “Manage access” (Figure [12.36](version-control.html#fig:add-collab-02)).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后点击“管理访问”（见图[12.36](version-control.html#fig:add-collab-02)）。
- en: '![The “Manage access” tab on the GitHub web interface.](../Images/7b27968fc4601b0f1bb9a620ca9cccca.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![GitHub网页界面上的“管理访问”标签页](../Images/7b27968fc4601b0f1bb9a620ca9cccca.png)'
- en: 'Figure 12.36: The “Manage access” tab on the GitHub web interface.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.36：GitHub网页界面上的“管理访问”标签页。
- en: Then click the green “Invite a collaborator” button (Figure [12.37](version-control.html#fig:add-collab-03)).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后点击绿色的“邀请合作者”按钮（见图[12.37](version-control.html#fig:add-collab-03)）。
- en: '![The “Invite a collaborator” button on the GitHub web interface.](../Images/e20d432164df71202c9a37ae601557a5.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![GitHub网页界面上的“邀请合作者”按钮](../Images/e20d432164df71202c9a37ae601557a5.png)'
- en: 'Figure 12.37: The “Invite a collaborator” button on the GitHub web interface.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.37：GitHub网页界面上的“邀请合作者”按钮。
- en: Type in the collaborator’s GitHub username or email, and select their name when
    it appears (Figure [12.38](version-control.html#fig:add-collab-04)).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 输入合作者的GitHub用户名或电子邮件，并在它出现时选择他们的名字（见图[12.38](version-control.html#fig:add-collab-04)）。
- en: '![The text box where a collaborator''s GitHub username or email can be entered.](../Images/b12ef9cc0bf4a45dc35979cff04c3094.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![在此文本框中可以输入合作者的GitHub用户名或电子邮件](../Images/b12ef9cc0bf4a45dc35979cff04c3094.png)'
- en: 'Figure 12.38: The text box where a collaborator’s GitHub username or email
    can be entered.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.38：在此文本框中可以输入合作者的GitHub用户名或电子邮件。
- en: Finally, click the green “Add collaborator to this repository” button (Figure
    [12.39](version-control.html#fig:add-collab-05)).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，点击绿色的“将合作者添加到这个仓库”按钮（见图[12.39](version-control.html#fig:add-collab-05)）。
- en: '![The confirmation button for adding a collaborator to a repository on the
    GitHub web interface.](../Images/48af3c79dbe2c7049bd0044b61ecc0bd.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![在GitHub网页界面上添加合作者到仓库的确认按钮](../Images/48af3c79dbe2c7049bd0044b61ecc0bd.png)'
- en: 'Figure 12.39: The confirmation button for adding a collaborator to a repository
    on the GitHub web interface.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.39：在GitHub网页界面上添加合作者到仓库的确认按钮。
- en: After this, you should see your newly added collaborator listed under the “Manage
    access” tab. They should receive an email invitation to join the GitHub repository
    as a collaborator. They need to accept this invitation to enable write access.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你应该在“管理访问”标签页下看到新添加的合作者。他们应该会收到一封邀请邮件，邀请他们作为合作者加入GitHub仓库。他们需要接受这个邀请才能获得写入权限。
- en: 12.8.2 Pulling changes from GitHub using Jupyter
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.8.2 使用Jupyter从GitHub拉取更改
- en: We will now walk through how to use the Jupyter Git extension tool to pull changes
    to our `eda.ipynb` analysis file that were made by a collaborator (Figure [12.40](version-control.html#fig:git-pull-00)).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将逐步介绍如何使用Jupyter Git扩展工具从合作者那里拉取对`eda.ipynb`分析文件所做的更改（见图[12.40](version-control.html#fig:git-pull-00)）。
- en: '![The GitHub interface indicates the name of the last person to push a commit
    to the remote repository, a preview of the associated commit message, the unique
    commit identifier, and how long ago the commit was snapshotted.](../Images/4d6e7b51ab55169fa396eea2d5ec6495.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![GitHub界面显示最后将提交推送到远程仓库的人的名字、相关提交信息的预览、唯一的提交标识符以及提交快照的时间](../Images/4d6e7b51ab55169fa396eea2d5ec6495.png)'
- en: 'Figure 12.40: The GitHub interface indicates the name of the last person to
    push a commit to the remote repository, a preview of the associated commit message,
    the unique commit identifier, and how long ago the commit was snapshotted.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.40：GitHub界面显示最后将提交推送到远程仓库的人的名字、相关提交信息的预览、唯一的提交标识符以及提交快照的时间。
- en: You can tell Git to “pull” by clicking on the cloud icon with the down arrow
    in Jupyter (Figure [12.41](version-control.html#fig:git-pull-01)).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在Jupyter中点击带有向下箭头的云图标来告诉Git进行“拉取”（见图[12.41](version-control.html#fig:git-pull-01)）。
- en: '![The Jupyter Git extension clone button.](../Images/e79e8d1368fb425182febed46006af02.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![Jupyter Git扩展的克隆按钮](../Images/e79e8d1368fb425182febed46006af02.png)'
- en: 'Figure 12.41: The Jupyter Git extension clone button.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.41：Jupyter Git扩展的克隆按钮。
- en: Once the files are successfully pulled from GitHub, you need to click “Dismiss”
    to keep working (Figure [12.42](version-control.html#fig:git-pull-02)).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功从GitHub拉取文件，你需要点击“关闭”以继续工作（见图[12.42](version-control.html#fig:git-pull-02)）。
- en: '![The prompt after changes have been successfully pulled from a remote repository.](../Images/9803c5771677d384dc60362da54a4f33.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![从远程仓库成功拉取更改后的提示](../Images/9803c5771677d384dc60362da54a4f33.png)'
- en: 'Figure 12.42: The prompt after changes have been successfully pulled from a
    remote repository.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.42：从远程仓库成功拉取更改后的提示。
- en: And then when you open (or refresh) the files whose changes you just pulled,
    you should be able to see them (Figure [12.43](version-control.html#fig:git-pull-03)).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后当您打开（或刷新）您刚刚拉取更改的文件时，您应该能够看到它们（图 [12.43](version-control.html#fig:git-pull-03)）。
- en: '![Changes made by the collaborator to eda.ipynb (code highlighted by red arrows).](../Images/ec9138a9af6adce0233b5bbf478e5a92.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![合作者对 eda.ipynb（红色箭头突出显示的代码）所做的更改](../Images/ec9138a9af6adce0233b5bbf478e5a92.png)'
- en: 'Figure 12.43: Changes made by the collaborator to `eda.ipynb` (code highlighted
    by red arrows).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.43：合作者对 `eda.ipynb`（红色箭头突出显示的代码）所做的更改。
- en: It can be very useful to review the history of the changes to your project.
    You can do this directly in Jupyter by clicking “History” in the Git tab (Figure
    [12.44](version-control.html#fig:git-pull-04)).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 审查您项目更改的历史记录可以非常有用。您可以直接在 Jupyter 中通过点击 Git 选项卡中的“历史”来做到这一点（图 [12.44](version-control.html#fig:git-pull-04)）。
- en: '![Version control repository history viewed using the Jupyter Git extension.](../Images/609a4030dc8d4c024c15758a625c42f0.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Jupyter Git 扩展查看版本控制仓库历史](../Images/609a4030dc8d4c024c15758a625c42f0.png)'
- en: 'Figure 12.44: Version control repository history viewed using the Jupyter Git
    extension.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.44：使用 Jupyter Git 扩展查看版本控制仓库历史。
- en: It is good practice to pull any changes at the start of *every* work session
    before you start working on your local copy. If you do not do this, and your collaborators
    have pushed some changes to the project to GitHub, then you will be unable to
    push your changes to GitHub until you pull. This situation can be recognized by
    the error message shown in Figure [12.45](version-control.html#fig:merge-conflict-01).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始工作于本地副本之前，在每次工作会话的开始时拉取任何更改是一种良好的做法。如果您不这样做，并且您的合作者已将一些更改推送到 GitHub 上的项目，那么您将无法在拉取更改之前将您的更改推送到
    GitHub。这种情况可以通过图 [12.45](version-control.html#fig:merge-conflict-01) 中显示的错误信息来识别。
- en: '![Error message that indicates that there are changes on the remote repository
    that you do not have locally.](../Images/2bb71927d7a2032a189378ccdf9b6059.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![指示远程仓库中存在您本地没有更改的错误信息](../Images/2bb71927d7a2032a189378ccdf9b6059.png)'
- en: 'Figure 12.45: Error message that indicates that there are changes on the remote
    repository that you do not have locally.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.45：指示远程仓库中存在您本地没有更改的错误信息。
- en: Usually, getting out of this situation is not too troublesome. First you need
    to pull the changes that exist on GitHub that you do not yet have in the local
    repository. Usually when this happens, Git can automatically merge the changes
    for you, even if you and your collaborators were working on different parts of
    the same file!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，摆脱这种情况并不太麻烦。首先，您需要拉取 GitHub 上存在的更改，这些更改您在本地仓库中还没有。通常在这种情况下，Git 可以自动为您合并更改，即使您和您的合作者正在同一文件的不同的部分工作！
- en: If, however, you and your collaborators made changes to the same line of the
    same file, Git will not be able to automatically merge the changes—it will not
    know whether to keep your version of the line(s), your collaborators version of
    the line(s), or some blend of the two. When this happens, Git will tell you that
    you have a merge conflict in certain file(s) (Figure [12.46](version-control.html#fig:merge-conflict-03)).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您和您的合作者对同一文件的同一行进行了更改，Git 将无法自动合并更改——它将不知道是保留您的版本、合作者的版本，还是两者的某种混合。当这种情况发生时，Git
    将会告诉您在某些文件中存在合并冲突（图 [12.46](version-control.html#fig:merge-conflict-03)）。
- en: '![Error message that indicates you and your collaborators made changes to the
    same line of the same file and that Git will not be able to automatically merge
    the changes.](../Images/af5c3b0e438aaf54dd441041aaba3416.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![指示您和您的合作者对同一文件的同一行进行了更改，Git 将无法自动合并更改的错误信息](../Images/af5c3b0e438aaf54dd441041aaba3416.png)'
- en: 'Figure 12.46: Error message that indicates you and your collaborators made
    changes to the same line of the same file and that Git will not be able to automatically
    merge the changes.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.46：指示您和您的合作者对同一文件的同一行进行了更改，Git 将无法自动合并更改的错误信息。
- en: 12.8.3 Handling merge conflicts
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.8.3 处理合并冲突
- en: To fix the merge conflict, you need to open the offending file in a plain text
    editor and look for special marks that Git puts in the file to tell you where
    the merge conflict occurred (Figure [12.47](version-control.html#fig:merge-conflict-04)).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复合并冲突，你需要在一个纯文本编辑器中打开有问题的文件，并寻找 Git 在文件中放置的特殊标记，以告诉你合并冲突发生的位置（图 [12.47](version-control.html#fig:merge-conflict-04)）。
- en: '![How to open a Jupyter notebook as a plain text file view in Jupyter.](../Images/8adbd729bc6ee9592d366d3c3270d2f4.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![如何在 Jupyter 中以纯文本文件视图打开 Jupyter 笔记本](../Images/8adbd729bc6ee9592d366d3c3270d2f4.png)'
- en: 'Figure 12.47: How to open a Jupyter notebook as a plain text file view in Jupyter.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.47：如何在 Jupyter 中以纯文本文件视图打开 Jupyter 笔记本。
- en: The beginning of the merge conflict is preceded by `<<<<<<< HEAD` and the end
    of the merge conflict is marked by `>>>>>>>`. Between these markings, Git also
    inserts a separator (`=======`). The version of the change before the separator
    is your change, and the version that follows the separator was the change that
    existed on GitHub. In Figure [12.48](version-control.html#fig:merge-conflict-05),
    you can see that in your local repository there is a line of code that calls `scale_color_manual`
    with three color values (`deeppink2`, `cyan4`, and `purple1`). It looks like your
    collaborator made an edit to that line too, except with different colors (to `blue3`,
    `red3`, and `black`)!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 合并冲突的开始由 `<<<<<<< HEAD` 预先标识，而合并冲突的结束则由 `>>>>>>>` 标记。在这两个标记之间，Git 还插入了一个分隔符（`=======`）。分隔符之前的变化版本是你的更改，而分隔符之后的变化版本是
    GitHub 上存在的变化。在图 [12.48](version-control.html#fig:merge-conflict-05) 中，你可以看到在你的本地仓库中有一行代码调用
    `scale_color_manual` 并带有三个颜色值（`deeppink2`、`cyan4` 和 `purple1`）。看起来你的合作者也对这一行进行了编辑，只是使用了不同的颜色（`blue3`、`red3`
    和 `black`）！
- en: '![Merge conflict identifiers (highlighted in red).](../Images/41e888c967be952fb40d78c8756db134.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![合并冲突标识符（用红色突出显示）](../Images/41e888c967be952fb40d78c8756db134.png)'
- en: 'Figure 12.48: Merge conflict identifiers (highlighted in red).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.48：合并冲突标识符（用红色突出显示）。
- en: Once you have decided which version of the change (or what combination!) to
    keep, you need to use the plain text editor to remove the special marks that Git
    added (Figure [12.49](version-control.html#fig:merge-conflict-06)).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你决定保留更改的哪个版本（或是什么组合），你需要使用纯文本编辑器来移除 Git 添加的特殊标记（图 [12.49](version-control.html#fig:merge-conflict-06)）。
- en: '![File where a merge conflict has been resolved.](../Images/5db43a21f8ed9ad45b3ab302dde7b0f5.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![已解决合并冲突的文件](../Images/5db43a21f8ed9ad45b3ab302dde7b0f5.png)'
- en: 'Figure 12.49: File where a merge conflict has been resolved.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.49：已解决合并冲突的文件。
- en: The file must be saved, added to the staging area, and then committed before
    you will be able to push your changes to GitHub.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够将你的更改推送到 GitHub 之前，必须保存文件，将其添加到暂存区，然后提交。
- en: 12.8.4 Communicating using GitHub issues
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.8.4 使用 GitHub 的问题进行沟通
- en: 'When working on a project in a team, you don’t just want a historical record
    of who changed what file and when in the project—you also want a record of decisions
    that were made, ideas that were floated, problems that were identified and addressed,
    and all other communication surrounding the project. Email and messaging apps
    are both very popular for general communication, but are not designed for project-specific
    communication: they both generally do not have facilities for organizing conversations
    by project subtopics, searching for conversations related to particular bugs or
    software versions, etc.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在团队中协作完成一个项目时，你不仅希望有一个关于谁在何时更改了哪些文件的历史记录——你还需要一个记录决策、提出想法、识别和解决问题的记录，以及围绕项目的所有其他沟通。电子邮件和消息应用都非常适合一般沟通，但它们并不是为特定项目沟通设计的：它们通常没有按项目子主题组织对话、搜索与特定错误或软件版本相关的对话等功能。
- en: GitHub *issues* are an alternative written communication medium to email and
    messaging apps, and were designed specifically to facilitate project-specific
    communication. Issues are *opened* from the “Issues” tab on the project’s GitHub
    page, and they persist there even after the conversation is over and the issue
    is *closed* (in contrast to email, issues are not usually deleted). One issue
    thread is usually created per topic, and they are easily searchable using GitHub’s
    search tools. All issues are accessible to all project collaborators, so no one
    is left out of the conversation. Finally, issues can be set up so that team members
    get email notifications when a new issue is created or a new post is made in an
    issue thread. Replying to issues from email is also possible. Given all of these
    advantages, we highly recommend the use of issues for project-related communication.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 的 *问题* 是一种替代电子邮件和消息应用的书面沟通媒介，专门设计用于促进项目特定的沟通。问题从项目 GitHub 页面上的“问题”标签页中
    *打开*，即使在对话结束后问题被 *关闭*（与电子邮件不同，问题通常不会被删除）。通常每个主题都会创建一个问题线程，并且可以使用 GitHub 的搜索工具轻松搜索。所有问题对所有项目协作者都是可访问的，所以没有人会被排除在对话之外。最后，可以将问题设置为当创建新问题或问题线程中发布新帖子时，团队成员会收到电子邮件通知。也可以通过电子邮件回复问题。鉴于所有这些优势，我们强烈推荐使用问题进行项目相关沟通。
- en: To open a GitHub issue, first click on the “Issues” tab (Figure [12.50](version-control.html#fig:issue-01)).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开 GitHub 问题，首先点击“问题”标签页（图 [12.50](version-control.html#fig:issue-01)）。
- en: '![The “Issues” tab on the GitHub web interface.](../Images/c1f730cbe956a7cf018840c7c3f8b481.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![GitHub 网页界面上的“问题”标签页](../Images/c1f730cbe956a7cf018840c7c3f8b481.png)'
- en: 'Figure 12.50: The “Issues” tab on the GitHub web interface.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.50：GitHub 网页界面上的“问题”标签页。
- en: Next click the “New issue” button (Figure [12.51](version-control.html#fig:issue-02)).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接着点击“新建问题”按钮（图 [12.51](version-control.html#fig:issue-02)）。
- en: '![The “New issue” button on the GitHub web interface.](../Images/f16c828efe9fed2b29d000439f6e1417.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![GitHub 网页界面上的“新建问题”按钮](../Images/f16c828efe9fed2b29d000439f6e1417.png)'
- en: 'Figure 12.51: The “New issue” button on the GitHub web interface.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.51：GitHub 网页界面上的“新建问题”按钮。
- en: Add an issue title (which acts like an email subject line), and then put the
    body of the message in the larger text box. Finally, click “Submit new issue”
    to post the issue to share with others (Figure [12.52](version-control.html#fig:issue-03)).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 添加问题标题（类似于电子邮件的主题行），然后将消息正文放入较大的文本框中。最后，点击“提交新问题”以发布问题与他人分享（图 [12.52](version-control.html#fig:issue-03)）。
- en: '![Dialog boxes and submission button for creating new GitHub issues.](../Images/fdf56548c63ee67bffd4c496618c69b8.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![创建新的 GitHub 问题的对话框和提交按钮](../Images/fdf56548c63ee67bffd4c496618c69b8.png)'
- en: 'Figure 12.52: Dialog boxes and submission button for creating new GitHub issues.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.52：创建新的 GitHub 问题的对话框和提交按钮。
- en: You can reply to an issue that someone opened by adding your written response
    to the large text box and clicking comment (Figure [12.53](version-control.html#fig:issue-04)).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在较大的文本框中添加你的书面回复并点击评论（图 [12.53](version-control.html#fig:issue-04)）来回复某人打开的问题。
- en: '![Dialog box for replying to GitHub issues.](../Images/2fb2a9ce425867bf70196a08fff93ec8.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![回复 GitHub 问题的对话框](../Images/2fb2a9ce425867bf70196a08fff93ec8.png)'
- en: 'Figure 12.53: Dialog box for replying to GitHub issues.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.53：回复 GitHub 问题的对话框。
- en: When a conversation is resolved, you can click “Close issue”. The closed issue
    can be later viewed by clicking the “Closed” header link in the “Issue” tab (Figure
    [12.54](version-control.html#fig:issue-06)).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当对话得到解决时，你可以点击“关闭问题”。关闭的问题可以在稍后通过点击“问题”标签页中的“已关闭”标题链接来查看（图 [12.54](version-control.html#fig:issue-06)）。
- en: '![The “Closed” issues tab on the GitHub web interface.](../Images/8060555c889b17115e25e32ea14d76f0.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![GitHub 网页界面上的“已关闭”问题标签页](../Images/8060555c889b17115e25e32ea14d76f0.png)'
- en: 'Figure 12.54: The “Closed” issues tab on the GitHub web interface.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.54：GitHub 网页界面上的“已关闭”问题标签页。
- en: 12.9 Exercises
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.9 练习
- en: Practice exercises for the material covered in this chapter can be found in
    the accompanying [worksheets repository](https://worksheets.datasciencebook.ca)
    in the “Collaboration with version control” row. You can launch an interactive
    version of the worksheet in your browser by clicking the “launch binder” button.
    You can also preview a non-interactive version of the worksheet by clicking “view
    worksheet.” If you instead decide to download the worksheet and run it on your
    own machine, make sure to follow the instructions for computer setup found in
    Chapter [13](setup.html#setup). This will ensure that the automated feedback and
    guidance that the worksheets provide will function as intended.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的练习题可以在“与版本控制协作”行中的配套[工作表存储库](https://worksheets.datasciencebook.ca)中找到。您可以通过点击“启动绑定器”按钮在浏览器中启动工作表的交互式版本。您还可以通过点击“查看工作表”预览非交互式版本的工作表。如果您决定下载工作表并在自己的机器上运行，请确保遵循第[13](setup.html#setup)章中找到的计算机设置说明。这将确保工作表提供的自动反馈和指导能够按预期工作。
- en: 12.10 Additional resources
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.10 其他资源
- en: 'Now that you’ve picked up the basics of version control with Git and GitHub,
    you can expand your knowledge through the resources listed below:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经掌握了Git和GitHub版本控制的基础知识，您可以通过以下资源扩展您的知识：
- en: GitHub’s [guides website](https://docs.github.com/) and [*Happy Git and GitHub
    for the useR*](https://happygitwithr.com/) are great resources for learning more
    about Git and GitHub.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub的[指南网站](https://docs.github.com/)和[*Happy Git and GitHub for the useR*](https://happygitwithr.com/)是学习更多关于Git和GitHub的绝佳资源。
- en: '[Good enough practices in scientific computing](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1005510#sec014)
    ([G. Wilson et al. 2017](#ref-wilson2014best)) provides more advice on useful
    workflows and “good enough” practices in data analysis projects.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[科学计算中的良好实践](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1005510#sec014)
    ([G. Wilson等人 2017](#ref-wilson2014best)) 提供了更多关于数据分析项目中有用的工作流程和“足够好”实践的建议。'
- en: In addition to [GitHub](https://github.com), there are other popular Git repository
    hosting services such as [GitLab](https://gitlab.com) and [BitBucket](https://bitbucket.org).
    Comparing all of these options is beyond the scope of this book, and until you
    become a more advanced user, you are perfectly fine to just stick with GitHub.
    Just be aware that you have options!
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了[GitHub](https://github.com)之外，还有其他流行的Git仓库托管服务，如[GitLab](https://gitlab.com)和[BitBucket](https://bitbucket.org)。比较所有这些选项超出了本书的范围，并且直到您成为更高级的用户，您完全可以继续使用GitHub。只需注意，您有多种选择！
- en: GitHub’s [documentation on creating a personal access token](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token)
    and the *Happy Git and GitHub for the useR* [personal access tokens chapter](https://happygitwithr.com/https-pat.html)
    are both excellent additional resources to consult if you need additional help
    generating and using personal access tokens.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub的[创建个人访问令牌的文档](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token)和*Happy
    Git and GitHub for the useR* [个人访问令牌章节](https://happygitwithr.com/https-pat.html)都是如果您需要更多帮助生成和使用个人访问令牌的绝佳额外资源。
- en: References
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考文献
- en: Wilson, Greg, Jennifer Bryan, Karen Cranston, Justin Kitzes, Lex Nederbragt,
    and Tracy Teal. 2017\. “Good Enough Practices in Scientific Computing.” *PLoS
    Computational Biology* 13 (6).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Wilson, Greg, Jennifer Bryan, Karen Cranston, Justin Kitzes, Lex Nederbragt,
    和 Tracy Teal. 2017. “科学计算中的良好实践。” *PLoS Computational Biology* 13 (6).
