- en: 6.1¬†Introduction to Structured Dataüîó
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://dcic-world.org/2025-08-27/intro-struct-data.html](https://dcic-world.org/2025-08-27/intro-struct-data.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| ¬†¬†¬†¬†[6.1.1¬†Understanding the Kinds of Compound Data](#%28part._.Understanding_the_.Kinds_of_.Compound_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[6.1.1.1¬†A First Peek at Structured Data](#%28part._.A_.First_.Peek_at_.Structured_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[6.1.1.2¬†A First Peek at Conditional Data](#%28part._.A_.First_.Peek_at_.Conditional_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[6.1.2¬†Defining and Creating Structured and Conditional Data](#%28part._.Defining_and_.Creating_.Structured_and_.Conditional_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[6.1.2.1¬†Defining and Creating Structured Data](#%28part._struct-data-eg%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[6.1.2.2¬†Annotations for Structured Data](#%28part._.Annotations_for_.Structured_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[6.1.2.3¬†Defining and Creating Conditional Data](#%28part._.Defining_and_.Creating_.Conditional_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[6.1.3¬†Programming with Structured and Conditional Data](#%28part._.Programming_with_.Structured_and_.Conditional_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[6.1.3.1¬†Extracting Fields from Structured Data](#%28part._.Extracting_.Fields_from_.Structured_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[6.1.3.2¬†Telling Apart Variants of Conditional Data](#%28part._telling-apart-variants%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[6.1.3.3¬†Processing Fields of Variants](#%28part._process-fields-variants%29)
    |'
  prefs: []
  type: TYPE_TB
- en: Earlier we had our first look at types. Until now, we have only seen the types
    that Pyret provides us, which is an interesting but nevertheless quite limited
    set. Most programs we write will contain many more kinds of data.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.1¬†Understanding the Kinds of Compound Data[üîó](#(part._.Understanding_the_.Kinds_of_.Compound_.Data)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 6.1.1.1¬†A First Peek at Structured Data[üîó](#(part._.A_.First_.Peek_at_.Structured_.Data)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There are times when a datum has many attributes, or parts. We need to keep
    them all together, and sometimes take them apart. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An iTunes entry contains a bunch of information about a single song: not only
    its name but also its singer, its length, its genre, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/72a14943124cb68143f994a2a282a9ac.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Your GMail application contains a bunch of information about a single message:
    its sender, the subject line, the conversation it‚Äôs part of, the body, and quite
    a bit more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/17a64e6b5180eb56ebf06a02ffe39113.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In examples like this, we see the need for structured data: a single datum
    has structure, i.e., it actually consists of many pieces. The number of pieces
    is fixed, but may be of different kinds (some might be numbers, some strings,
    some images, and different types may be mixed together in that one datum). Some
    might even be other structured data: for instance, a date usually has at least
    three parts, the day, month, and year. The parts of a structured datum are called
    its fields.'
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.1.2¬†A First Peek at Conditional Data[üîó](#(part._.A_.First_.Peek_at_.Conditional_.Data)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Then there are times when we want to represent different kinds of data under
    a single, collective umbrella. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A traffic light can be in different states: red, yellow, or green.Yes, in some
    countries there are different or more colors and color-combinations. Collectively,
    they represent one thing: a new type called a traffic light state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A zoo consists of many kinds of animals. Collectively, they represent one thing:
    a new type called an animal. Some condition determines which particular kind of
    animal a zookeeper might be dealing with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A social network consists of different kinds of pages. Some pages represent
    individual humans, some places, some organizations, some might stand for activities,
    and so on. Collectively, they represent a new type: a social media page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A notification application may report many kinds of events. Some are for email
    messages (which have many fields, as we‚Äôve discussed), some are for reminders
    (which might have a timestamp and a note), some for instant messages (similar
    to an email message, but without a subject), some might even be for the arrival
    of a package by physical mail (with a timestamp, shipper, tracking number, and
    delivery note). Collectively, these all represent a new type: a notification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We call these ‚Äúconditional‚Äù data because they represent an ‚Äúor‚Äù: a traffic
    light is red or green or yellow; a social medium‚Äôs page is for a person or location
    or organization; and so on. Sometimes we care exactly which kind of thing we‚Äôre
    looking at: a driver behaves differently on different colors, and a zookeeper
    feeds each animal differently. At other times, we might not care: if we‚Äôre just
    counting how many animals are in the zoo, or how many pages are on a social network,
    or how many unread notifications we have, their details don‚Äôt matter. Therefore,
    there are times when we ignore the conditional and treat the datum as a member
    of the collective, and other times when we do care about the conditional and do
    different things depending on the individual datum. We will make all this concrete
    as we start to write programs.'
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.2¬†Defining and Creating Structured and Conditional Data[üîó](#(part._.Defining_and_.Creating_.Structured_and_.Conditional_.Data)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We have used the word ‚Äúdata‚Äù above, but that‚Äôs actually been a bit of a lie.
    As we said earlier, data are how we represent information in the computer. What
    we‚Äôve been discussing above is really different kinds of information, not exactly
    how they are represented. But to write programs, we must wrestle concretely with
    representations. That‚Äôs what we will do now, i.e., actually show data representations
    of all this information.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.2.1¬†Defining and Creating Structured Data[üîó](#(part._struct-data-eg) "Link
    to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let‚Äôs start with defining structured data, such as an iTunes song record. Here‚Äôs
    a simplified version of the information such an app might store:'
  prefs: []
  type: TYPE_NORMAL
- en: The song‚Äôs name, which is a `String`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The song‚Äôs singer, which is also a `String`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The song‚Äôs year, which is a `Number`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let‚Äôs now introduce the syntax by which we can teach this to Pyret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells Pyret to introduce a new type of data, in this case called `ITunesSong`We
    follow a convention that types always begin with a capital letter.. The way we
    actually make one of these data is by calling `song` with three parameters; for
    instance:It‚Äôs worth noting that music managers that are capable of making distinctions
    between, say, Dance, Electronica, and Electronic/Dance, classify two of these
    three songs by a single genre: ‚ÄúWorld‚Äù.'
  prefs: []
  type: TYPE_NORMAL
- en: <structured-examples> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Always follow a data definition with a few concrete instances of the data!
    This makes sure you actually do know how to make data of that form. Indeed, it‚Äôs
    not essential but a good habit to give names to the data we‚Äôve defined, so that
    we can use them later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In terms of the directory, structured data are no different from simple data.
    Each of the three definitions above creates an entry in the directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 6.1.2.2¬†Annotations for Structured Data[üîó](#(part._.Annotations_for_.Structured_.Data)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Recall that in [[Type Annotations](From_Repeated_Expressions_to_Functions.html#%28part._fun-annotations%29)]
    we discussed annotating our functions. Well, we can annotate our data, too! In
    particular, we can annotate both the definition of data and their creation. For
    the former, consider this data definition, which makes the annotation information
    we‚Äôd recorded informally in text a formal part of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we can annotate the variables bound to examples of the data. But
    what should we write here?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Recall that annotations takes names of types, and the new type we‚Äôve created
    is called `ITunesSong`. Therefore, we should write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if we instead write this?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What error do we get? How about if instead we write these?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make sure you familiarize yourself with the error messages that you get.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 6.1.2.3¬†Defining and Creating Conditional Data[üîó](#(part._.Defining_and_.Creating_.Conditional_.Data)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `data` construct in Pyret also lets us create conditional data, with a
    slightly different syntax. For instance, say we want to define the colors of a
    traffic light:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Conventionally, the names of the options begin in lower-case, but if they have
    no additional structure, we often capitalize the initial to make them look different
    from ordinary variables: i.e., `Red` rather than `red`. Each `|` (pronounced ‚Äústick‚Äù)
    introduces another option. You would make instances of traffic light colors as'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A more interesting and common example is when each condition has some structure
    to it; for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '‚ÄúIn Texas, there ain‚Äôt nothin‚Äô in the middle of the road except yellow stripes
    and a dead armadillo.‚Äù‚Äî<wbr>Jim Hightower We can make examples of them as you
    would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We call the different conditions variants.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How would you annotate the three variable bindings?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notice that the distinction between boas and armadillos is lost in the annotation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When defining a conditional datum the first stick is actually optional, but
    adding it makes the variants line up nicely. This helps us realize that our first
    example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: is really just the same as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: i.e., a conditional type with just one condition, where that one condition is
    structured.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.3¬†Programming with Structured and Conditional Data[üîó](#(part._.Programming_with_.Structured_and_.Conditional_.Data)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we‚Äôve learned how to create structured and conditional data, but not
    yet how to take them apart or write any expressions that involve them. As you
    might expect, we need to figure out how to
  prefs: []
  type: TYPE_NORMAL
- en: take apart the fields of a structured datum, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tell apart the variants of a conditional datum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we‚Äôll see, Pyret also gives us a convenient way to do both together.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.3.1¬†Extracting Fields from Structured Data[üîó](#(part._.Extracting_.Fields_from_.Structured_.Data)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let‚Äôs write a function that tells us how old a song is. First, let‚Äôs think
    about what the function consumes (an `ITunesSong`) and produces (a `Number`).
    This gives us a rough skeleton for the function:'
  prefs: []
  type: TYPE_NORMAL
- en: <song-age> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We know that the form of the body must be roughly:'
  prefs: []
  type: TYPE_NORMAL
- en: <song-age-body> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We can get the song year by using Pyret‚Äôs field access, which is a `.` followed
    by a field‚Äôs name‚Äî<wbr>in this case, `year`‚Äî<wbr>following the variable that holds
    the structured datum. Thus, we get the `year` field of `s` (the parameter to `song-age`)
    with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'So the entire function body is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be good to also record some examples ([<structured-examples>](#%28elem._structured-examples%29)),
    giving us a comprehensive definition of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 6.1.3.2¬†Telling Apart Variants of Conditional Data[üîó](#(part._telling-apart-variants)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now let‚Äôs see how we tell apart variants. For this, we again use `cases`, as
    we saw for lists. We create one branch for each of the variants. Thus, if we wanted
    to compute advice for a driver based on a traffic light‚Äôs state, we might write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if you leave out the `=>`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What if you leave out a variant? Leave out the `Red` variant, then try both
    `advice(Yellow)` and `advice(Red)`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 6.1.3.3¬†Processing Fields of Variants[üîó](#(part._process-fields-variants) "Link
    to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In this example, the variants had no fields. But if the variant has fields,
    Pyret expects you to list names of variables for those fields, and will then automatically
    bind those variables‚Äî<wbr>so you don‚Äôt need to use the `.`-notation to get the
    field values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, assume we want to get the name of any animal:'
  prefs: []
  type: TYPE_NORMAL
- en: <animal-name> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Because an `Animal` is conditionally defined, we know that we are likely to
    want a `cases` to pull it apart; furthermore, we should give names to each of
    the fields:Note that the names of the variables do not have to match the names
    of fields. Conventionally, we give longer, descriptive names to the field definitions
    and short names to the corresponding variables.
  prefs: []
  type: TYPE_NORMAL
- en: <animal-name-body> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In both cases, we want to return the field `n`, giving us the complete function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Let‚Äôs look at how Pyret would evaluate a function call like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The argument `boa("Bonito", 8)` is a value. In the same way as we substitute
    simple data types like strings and numbers for parameters when we evaluate a function,
    we do the same thing here. After substituting, we are left with the following
    expression to evaluate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Next, Pyret determines which case matches the data (the first one, for `boa`,
    in this case). It then substitutes the field names with the corresponding components
    of the datum result expression for the matched case. In this case, we will substitute
    uses of `n` with `"Bonito"` and uses of `l` with `8`. In this program, the entire
    result expression is a use of `n`, so the result of the program in this case is
    `"Bonito"`.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.1¬†Understanding the Kinds of Compound Data[üîó](#(part._.Understanding_the_.Kinds_of_.Compound_.Data)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 6.1.1.1¬†A First Peek at Structured Data[üîó](#(part._.A_.First_.Peek_at_.Structured_.Data)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There are times when a datum has many attributes, or parts. We need to keep
    them all together, and sometimes take them apart. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An iTunes entry contains a bunch of information about a single song: not only
    its name but also its singer, its length, its genre, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/72a14943124cb68143f994a2a282a9ac.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Your GMail application contains a bunch of information about a single message:
    its sender, the subject line, the conversation it‚Äôs part of, the body, and quite
    a bit more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/17a64e6b5180eb56ebf06a02ffe39113.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In examples like this, we see the need for structured data: a single datum
    has structure, i.e., it actually consists of many pieces. The number of pieces
    is fixed, but may be of different kinds (some might be numbers, some strings,
    some images, and different types may be mixed together in that one datum). Some
    might even be other structured data: for instance, a date usually has at least
    three parts, the day, month, and year. The parts of a structured datum are called
    its fields.'
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.1.2¬†A First Peek at Conditional Data[üîó](#(part._.A_.First_.Peek_at_.Conditional_.Data)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Then there are times when we want to represent different kinds of data under
    a single, collective umbrella. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A traffic light can be in different states: red, yellow, or green.Yes, in some
    countries there are different or more colors and color-combinations. Collectively,
    they represent one thing: a new type called a traffic light state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A zoo consists of many kinds of animals. Collectively, they represent one thing:
    a new type called an animal. Some condition determines which particular kind of
    animal a zookeeper might be dealing with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A social network consists of different kinds of pages. Some pages represent
    individual humans, some places, some organizations, some might stand for activities,
    and so on. Collectively, they represent a new type: a social media page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A notification application may report many kinds of events. Some are for email
    messages (which have many fields, as we‚Äôve discussed), some are for reminders
    (which might have a timestamp and a note), some for instant messages (similar
    to an email message, but without a subject), some might even be for the arrival
    of a package by physical mail (with a timestamp, shipper, tracking number, and
    delivery note). Collectively, these all represent a new type: a notification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We call these ‚Äúconditional‚Äù data because they represent an ‚Äúor‚Äù: a traffic
    light is red or green or yellow; a social medium‚Äôs page is for a person or location
    or organization; and so on. Sometimes we care exactly which kind of thing we‚Äôre
    looking at: a driver behaves differently on different colors, and a zookeeper
    feeds each animal differently. At other times, we might not care: if we‚Äôre just
    counting how many animals are in the zoo, or how many pages are on a social network,
    or how many unread notifications we have, their details don‚Äôt matter. Therefore,
    there are times when we ignore the conditional and treat the datum as a member
    of the collective, and other times when we do care about the conditional and do
    different things depending on the individual datum. We will make all this concrete
    as we start to write programs.'
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.1.1¬†A First Peek at Structured Data[üîó](#(part._.A_.First_.Peek_at_.Structured_.Data)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There are times when a datum has many attributes, or parts. We need to keep
    them all together, and sometimes take them apart. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An iTunes entry contains a bunch of information about a single song: not only
    its name but also its singer, its length, its genre, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/72a14943124cb68143f994a2a282a9ac.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Your GMail application contains a bunch of information about a single message:
    its sender, the subject line, the conversation it‚Äôs part of, the body, and quite
    a bit more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/17a64e6b5180eb56ebf06a02ffe39113.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In examples like this, we see the need for structured data: a single datum
    has structure, i.e., it actually consists of many pieces. The number of pieces
    is fixed, but may be of different kinds (some might be numbers, some strings,
    some images, and different types may be mixed together in that one datum). Some
    might even be other structured data: for instance, a date usually has at least
    three parts, the day, month, and year. The parts of a structured datum are called
    its fields.'
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.1.2¬†A First Peek at Conditional Data[üîó](#(part._.A_.First_.Peek_at_.Conditional_.Data)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Then there are times when we want to represent different kinds of data under
    a single, collective umbrella. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A traffic light can be in different states: red, yellow, or green.Yes, in some
    countries there are different or more colors and color-combinations. Collectively,
    they represent one thing: a new type called a traffic light state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A zoo consists of many kinds of animals. Collectively, they represent one thing:
    a new type called an animal. Some condition determines which particular kind of
    animal a zookeeper might be dealing with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A social network consists of different kinds of pages. Some pages represent
    individual humans, some places, some organizations, some might stand for activities,
    and so on. Collectively, they represent a new type: a social media page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A notification application may report many kinds of events. Some are for email
    messages (which have many fields, as we‚Äôve discussed), some are for reminders
    (which might have a timestamp and a note), some for instant messages (similar
    to an email message, but without a subject), some might even be for the arrival
    of a package by physical mail (with a timestamp, shipper, tracking number, and
    delivery note). Collectively, these all represent a new type: a notification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We call these ‚Äúconditional‚Äù data because they represent an ‚Äúor‚Äù: a traffic
    light is red or green or yellow; a social medium‚Äôs page is for a person or location
    or organization; and so on. Sometimes we care exactly which kind of thing we‚Äôre
    looking at: a driver behaves differently on different colors, and a zookeeper
    feeds each animal differently. At other times, we might not care: if we‚Äôre just
    counting how many animals are in the zoo, or how many pages are on a social network,
    or how many unread notifications we have, their details don‚Äôt matter. Therefore,
    there are times when we ignore the conditional and treat the datum as a member
    of the collective, and other times when we do care about the conditional and do
    different things depending on the individual datum. We will make all this concrete
    as we start to write programs.'
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.2¬†Defining and Creating Structured and Conditional Data[üîó](#(part._.Defining_and_.Creating_.Structured_and_.Conditional_.Data)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We have used the word ‚Äúdata‚Äù above, but that‚Äôs actually been a bit of a lie.
    As we said earlier, data are how we represent information in the computer. What
    we‚Äôve been discussing above is really different kinds of information, not exactly
    how they are represented. But to write programs, we must wrestle concretely with
    representations. That‚Äôs what we will do now, i.e., actually show data representations
    of all this information.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.2.1¬†Defining and Creating Structured Data[üîó](#(part._struct-data-eg) "Link
    to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let‚Äôs start with defining structured data, such as an iTunes song record. Here‚Äôs
    a simplified version of the information such an app might store:'
  prefs: []
  type: TYPE_NORMAL
- en: The song‚Äôs name, which is a `String`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The song‚Äôs singer, which is also a `String`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The song‚Äôs year, which is a `Number`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let‚Äôs now introduce the syntax by which we can teach this to Pyret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells Pyret to introduce a new type of data, in this case called `ITunesSong`We
    follow a convention that types always begin with a capital letter.. The way we
    actually make one of these data is by calling `song` with three parameters; for
    instance:It‚Äôs worth noting that music managers that are capable of making distinctions
    between, say, Dance, Electronica, and Electronic/Dance, classify two of these
    three songs by a single genre: ‚ÄúWorld‚Äù.'
  prefs: []
  type: TYPE_NORMAL
- en: <structured-examples> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Always follow a data definition with a few concrete instances of the data!
    This makes sure you actually do know how to make data of that form. Indeed, it‚Äôs
    not essential but a good habit to give names to the data we‚Äôve defined, so that
    we can use them later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In terms of the directory, structured data are no different from simple data.
    Each of the three definitions above creates an entry in the directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 6.1.2.2¬†Annotations for Structured Data[üîó](#(part._.Annotations_for_.Structured_.Data)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Recall that in [[Type Annotations](From_Repeated_Expressions_to_Functions.html#%28part._fun-annotations%29)]
    we discussed annotating our functions. Well, we can annotate our data, too! In
    particular, we can annotate both the definition of data and their creation. For
    the former, consider this data definition, which makes the annotation information
    we‚Äôd recorded informally in text a formal part of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we can annotate the variables bound to examples of the data. But
    what should we write here?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Recall that annotations takes names of types, and the new type we‚Äôve created
    is called `ITunesSong`. Therefore, we should write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if we instead write this?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What error do we get? How about if instead we write these?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make sure you familiarize yourself with the error messages that you get.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 6.1.2.3¬†Defining and Creating Conditional Data[üîó](#(part._.Defining_and_.Creating_.Conditional_.Data)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `data` construct in Pyret also lets us create conditional data, with a
    slightly different syntax. For instance, say we want to define the colors of a
    traffic light:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Conventionally, the names of the options begin in lower-case, but if they have
    no additional structure, we often capitalize the initial to make them look different
    from ordinary variables: i.e., `Red` rather than `red`. Each `|` (pronounced ‚Äústick‚Äù)
    introduces another option. You would make instances of traffic light colors as'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'A more interesting and common example is when each condition has some structure
    to it; for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '‚ÄúIn Texas, there ain‚Äôt nothin‚Äô in the middle of the road except yellow stripes
    and a dead armadillo.‚Äù‚Äî<wbr>Jim Hightower We can make examples of them as you
    would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We call the different conditions variants.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How would you annotate the three variable bindings?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notice that the distinction between boas and armadillos is lost in the annotation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: When defining a conditional datum the first stick is actually optional, but
    adding it makes the variants line up nicely. This helps us realize that our first
    example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: is really just the same as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: i.e., a conditional type with just one condition, where that one condition is
    structured.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.2.1¬†Defining and Creating Structured Data[üîó](#(part._struct-data-eg) "Link
    to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let‚Äôs start with defining structured data, such as an iTunes song record. Here‚Äôs
    a simplified version of the information such an app might store:'
  prefs: []
  type: TYPE_NORMAL
- en: The song‚Äôs name, which is a `String`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The song‚Äôs singer, which is also a `String`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The song‚Äôs year, which is a `Number`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let‚Äôs now introduce the syntax by which we can teach this to Pyret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells Pyret to introduce a new type of data, in this case called `ITunesSong`We
    follow a convention that types always begin with a capital letter.. The way we
    actually make one of these data is by calling `song` with three parameters; for
    instance:It‚Äôs worth noting that music managers that are capable of making distinctions
    between, say, Dance, Electronica, and Electronic/Dance, classify two of these
    three songs by a single genre: ‚ÄúWorld‚Äù.'
  prefs: []
  type: TYPE_NORMAL
- en: <structured-examples> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Always follow a data definition with a few concrete instances of the data!
    This makes sure you actually do know how to make data of that form. Indeed, it‚Äôs
    not essential but a good habit to give names to the data we‚Äôve defined, so that
    we can use them later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In terms of the directory, structured data are no different from simple data.
    Each of the three definitions above creates an entry in the directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 6.1.2.2¬†Annotations for Structured Data[üîó](#(part._.Annotations_for_.Structured_.Data)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Recall that in [[Type Annotations](From_Repeated_Expressions_to_Functions.html#%28part._fun-annotations%29)]
    we discussed annotating our functions. Well, we can annotate our data, too! In
    particular, we can annotate both the definition of data and their creation. For
    the former, consider this data definition, which makes the annotation information
    we‚Äôd recorded informally in text a formal part of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we can annotate the variables bound to examples of the data. But
    what should we write here?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Recall that annotations takes names of types, and the new type we‚Äôve created
    is called `ITunesSong`. Therefore, we should write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if we instead write this?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What error do we get? How about if instead we write these?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make sure you familiarize yourself with the error messages that you get.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 6.1.2.3¬†Defining and Creating Conditional Data[üîó](#(part._.Defining_and_.Creating_.Conditional_.Data)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `data` construct in Pyret also lets us create conditional data, with a
    slightly different syntax. For instance, say we want to define the colors of a
    traffic light:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Conventionally, the names of the options begin in lower-case, but if they have
    no additional structure, we often capitalize the initial to make them look different
    from ordinary variables: i.e., `Red` rather than `red`. Each `|` (pronounced ‚Äústick‚Äù)
    introduces another option. You would make instances of traffic light colors as'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'A more interesting and common example is when each condition has some structure
    to it; for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '‚ÄúIn Texas, there ain‚Äôt nothin‚Äô in the middle of the road except yellow stripes
    and a dead armadillo.‚Äù‚Äî<wbr>Jim Hightower We can make examples of them as you
    would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We call the different conditions variants.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How would you annotate the three variable bindings?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notice that the distinction between boas and armadillos is lost in the annotation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: When defining a conditional datum the first stick is actually optional, but
    adding it makes the variants line up nicely. This helps us realize that our first
    example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: is really just the same as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: i.e., a conditional type with just one condition, where that one condition is
    structured.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.3¬†Programming with Structured and Conditional Data[üîó](#(part._.Programming_with_.Structured_and_.Conditional_.Data)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we‚Äôve learned how to create structured and conditional data, but not
    yet how to take them apart or write any expressions that involve them. As you
    might expect, we need to figure out how to
  prefs: []
  type: TYPE_NORMAL
- en: take apart the fields of a structured datum, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tell apart the variants of a conditional datum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we‚Äôll see, Pyret also gives us a convenient way to do both together.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.3.1¬†Extracting Fields from Structured Data[üîó](#(part._.Extracting_.Fields_from_.Structured_.Data)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let‚Äôs write a function that tells us how old a song is. First, let‚Äôs think
    about what the function consumes (an `ITunesSong`) and produces (a `Number`).
    This gives us a rough skeleton for the function:'
  prefs: []
  type: TYPE_NORMAL
- en: <song-age> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We know that the form of the body must be roughly:'
  prefs: []
  type: TYPE_NORMAL
- en: <song-age-body> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: We can get the song year by using Pyret‚Äôs field access, which is a `.` followed
    by a field‚Äôs name‚Äî<wbr>in this case, `year`‚Äî<wbr>following the variable that holds
    the structured datum. Thus, we get the `year` field of `s` (the parameter to `song-age`)
    with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'So the entire function body is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be good to also record some examples ([<structured-examples>](#%28elem._structured-examples%29)),
    giving us a comprehensive definition of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 6.1.3.2¬†Telling Apart Variants of Conditional Data[üîó](#(part._telling-apart-variants)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now let‚Äôs see how we tell apart variants. For this, we again use `cases`, as
    we saw for lists. We create one branch for each of the variants. Thus, if we wanted
    to compute advice for a driver based on a traffic light‚Äôs state, we might write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if you leave out the `=>`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What if you leave out a variant? Leave out the `Red` variant, then try both
    `advice(Yellow)` and `advice(Red)`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 6.1.3.3¬†Processing Fields of Variants[üîó](#(part._process-fields-variants) "Link
    to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In this example, the variants had no fields. But if the variant has fields,
    Pyret expects you to list names of variables for those fields, and will then automatically
    bind those variables‚Äî<wbr>so you don‚Äôt need to use the `.`-notation to get the
    field values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, assume we want to get the name of any animal:'
  prefs: []
  type: TYPE_NORMAL
- en: <animal-name> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Because an `Animal` is conditionally defined, we know that we are likely to
    want a `cases` to pull it apart; furthermore, we should give names to each of
    the fields:Note that the names of the variables do not have to match the names
    of fields. Conventionally, we give longer, descriptive names to the field definitions
    and short names to the corresponding variables.
  prefs: []
  type: TYPE_NORMAL
- en: <animal-name-body> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'In both cases, we want to return the field `n`, giving us the complete function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Let‚Äôs look at how Pyret would evaluate a function call like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The argument `boa("Bonito", 8)` is a value. In the same way as we substitute
    simple data types like strings and numbers for parameters when we evaluate a function,
    we do the same thing here. After substituting, we are left with the following
    expression to evaluate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Next, Pyret determines which case matches the data (the first one, for `boa`,
    in this case). It then substitutes the field names with the corresponding components
    of the datum result expression for the matched case. In this case, we will substitute
    uses of `n` with `"Bonito"` and uses of `l` with `8`. In this program, the entire
    result expression is a use of `n`, so the result of the program in this case is
    `"Bonito"`.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.3.1¬†Extracting Fields from Structured Data[üîó](#(part._.Extracting_.Fields_from_.Structured_.Data)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let‚Äôs write a function that tells us how old a song is. First, let‚Äôs think
    about what the function consumes (an `ITunesSong`) and produces (a `Number`).
    This gives us a rough skeleton for the function:'
  prefs: []
  type: TYPE_NORMAL
- en: <song-age> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We know that the form of the body must be roughly:'
  prefs: []
  type: TYPE_NORMAL
- en: <song-age-body> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: We can get the song year by using Pyret‚Äôs field access, which is a `.` followed
    by a field‚Äôs name‚Äî<wbr>in this case, `year`‚Äî<wbr>following the variable that holds
    the structured datum. Thus, we get the `year` field of `s` (the parameter to `song-age`)
    with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'So the entire function body is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be good to also record some examples ([<structured-examples>](#%28elem._structured-examples%29)),
    giving us a comprehensive definition of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 6.1.3.2¬†Telling Apart Variants of Conditional Data[üîó](#(part._telling-apart-variants)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now let‚Äôs see how we tell apart variants. For this, we again use `cases`, as
    we saw for lists. We create one branch for each of the variants. Thus, if we wanted
    to compute advice for a driver based on a traffic light‚Äôs state, we might write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if you leave out the `=>`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What if you leave out a variant? Leave out the `Red` variant, then try both
    `advice(Yellow)` and `advice(Red)`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 6.1.3.3¬†Processing Fields of Variants[üîó](#(part._process-fields-variants) "Link
    to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In this example, the variants had no fields. But if the variant has fields,
    Pyret expects you to list names of variables for those fields, and will then automatically
    bind those variables‚Äî<wbr>so you don‚Äôt need to use the `.`-notation to get the
    field values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, assume we want to get the name of any animal:'
  prefs: []
  type: TYPE_NORMAL
- en: <animal-name> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Because an `Animal` is conditionally defined, we know that we are likely to
    want a `cases` to pull it apart; furthermore, we should give names to each of
    the fields:Note that the names of the variables do not have to match the names
    of fields. Conventionally, we give longer, descriptive names to the field definitions
    and short names to the corresponding variables.
  prefs: []
  type: TYPE_NORMAL
- en: <animal-name-body> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'In both cases, we want to return the field `n`, giving us the complete function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Let‚Äôs look at how Pyret would evaluate a function call like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The argument `boa("Bonito", 8)` is a value. In the same way as we substitute
    simple data types like strings and numbers for parameters when we evaluate a function,
    we do the same thing here. After substituting, we are left with the following
    expression to evaluate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Next, Pyret determines which case matches the data (the first one, for `boa`,
    in this case). It then substitutes the field names with the corresponding components
    of the datum result expression for the matched case. In this case, we will substitute
    uses of `n` with `"Bonito"` and uses of `l` with `8`. In this program, the entire
    result expression is a use of `n`, so the result of the program in this case is
    `"Bonito"`.
  prefs: []
  type: TYPE_NORMAL
