- en: 18.3¬†Union-Findüîó
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://dcic-world.org/2025-08-27/union-find.html](https://dcic-world.org/2025-08-27/union-find.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| ¬†¬†¬†¬†[18.3.1¬†Implementing with State](#%28part._.Implementing_with_.State%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[18.3.2¬†Optimizations](#%28part._.Optimizations%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[18.3.3¬†Analysis](#%28part._.Analysis%29) |'
  prefs: []
  type: TYPE_TB
- en: 'We have previously [[Checking Component Connectedness](mst.html#%28part._union-find-functional%29)]
    seen how to check connectedness of components, but found that solution unsatisfactory.
    Recall that it comes down to two set operations: we want to construct the unions
    of sets, and then determine whether two elements are in the same set.'
  prefs: []
  type: TYPE_NORMAL
- en: We will now see how to do this using state. We will try to keep things as similar
    to the previous version as possible, to enhance comparison.
  prefs: []
  type: TYPE_NORMAL
- en: 18.3.1¬†Implementing with State[üîó](#(part._.Implementing_with_.State) "Link to
    here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, we have to update the definition of an element, making the `parent`
    field be mutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To determine whether two elements are in the same set, we will still rely on
    `fynd`. However, as we will soon see, `fynd` no longer needs to be given the entire
    set of elements. Because the only reason `is-in-same-set` consumed that set was
    to pass it on to `fynd`, we can remove it from here. Nothing else changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Updating is now the crucial difference: we use mutation to change the value
    of the parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In `parent: some(parent)`, the first `parent` is the name of the field, while
    the second one is the parameter name. In addition, we must use `some` to satisfy
    the option type. Naturally, it is not `none` because the entire point of this
    mutation is to change the parent to be the other element, irrespective of what
    was there before.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this definition, `union` also stays largely unchanged, other than the
    change to the return type. Previously, it needed to return the updated set of
    elements; now, because the update is performed by mutation, there is no longer
    any need to return anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `fynd`. Its implementation is now remarkably simple. There is no longer
    any need to search through the set. Previously, we had to search because after
    union operations have occurred, the parent reference might have no longer been
    valid. Now, any such changes are automatically reflected by mutation. Hence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 18.3.2¬†Optimizations[üîó](#(part._.Optimizations) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Look again at `fynd`. In the `some` case, the element bound to `e` is not the
    set name; that is obtained by recursively traversing `parent` references. As this
    value returns, however, we don‚Äôt do anything to reflect this new knowledge! Instead,
    the next time we try to find the parent of this element, we‚Äôre going to perform
    this same recursive traversal all over again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using mutation helps address this problem. The idea is as simple as can be:
    compute the value of the parent, and update it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that this update will apply to every element in the recursive chain to
    find the set name. Therefore, applying `fynd` to any of those elements the next
    time around will benefit from this update. This idea is called path compression.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more interesting idea we can apply. This is to maintain a rank
    of each element, which is roughly the depth of the tree of elements for which
    that element is their set name. When we union two elements, we then make the one
    with larger rank the parent of the one with the smaller rank. This has the effect
    of avoiding growing very tall paths to set name elements, instead tending towards
    ‚Äúbushy‚Äù trees. This too reduces the number of parents that must be traversed to
    find the representative.
  prefs: []
  type: TYPE_NORMAL
- en: 18.3.3¬†Analysis[üîó](#(part._.Analysis) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This optimized union-find data structure has a remarkble analysis. In the worst
    case, of course, we must traverse the entire chain of parents to find the name
    element, which takes time proportional to the number of elements in the set. However,
    once we apply the above optimizations, we never need to traverse that same chain
    again! In particular, if we conduct an amortized analysis over a sequence of set
    equality tests after a collection of union operations, we find that the cost for
    subsequent checks is very small‚Äî<wbr>indeed, about as small a function can get
    without being constant. The [actual analysis](http://en.wikipedia.org/wiki/Disjoint-set_data_structure)
    is quite sophisticated; it is also one of the most remarkable algorithm analyses
    in all of computer science.Here‚Äôs a [brief talk](https://www.youtube.com/watch?v=Hhk8ANKWGJA)
    by Robert Tarjan describing the history of his analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 18.3.1¬†Implementing with State[üîó](#(part._.Implementing_with_.State) "Link to
    here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, we have to update the definition of an element, making the `parent`
    field be mutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To determine whether two elements are in the same set, we will still rely on
    `fynd`. However, as we will soon see, `fynd` no longer needs to be given the entire
    set of elements. Because the only reason `is-in-same-set` consumed that set was
    to pass it on to `fynd`, we can remove it from here. Nothing else changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Updating is now the crucial difference: we use mutation to change the value
    of the parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In `parent: some(parent)`, the first `parent` is the name of the field, while
    the second one is the parameter name. In addition, we must use `some` to satisfy
    the option type. Naturally, it is not `none` because the entire point of this
    mutation is to change the parent to be the other element, irrespective of what
    was there before.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this definition, `union` also stays largely unchanged, other than the
    change to the return type. Previously, it needed to return the updated set of
    elements; now, because the update is performed by mutation, there is no longer
    any need to return anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `fynd`. Its implementation is now remarkably simple. There is no longer
    any need to search through the set. Previously, we had to search because after
    union operations have occurred, the parent reference might have no longer been
    valid. Now, any such changes are automatically reflected by mutation. Hence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 18.3.2¬†Optimizations[üîó](#(part._.Optimizations) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Look again at `fynd`. In the `some` case, the element bound to `e` is not the
    set name; that is obtained by recursively traversing `parent` references. As this
    value returns, however, we don‚Äôt do anything to reflect this new knowledge! Instead,
    the next time we try to find the parent of this element, we‚Äôre going to perform
    this same recursive traversal all over again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using mutation helps address this problem. The idea is as simple as can be:
    compute the value of the parent, and update it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that this update will apply to every element in the recursive chain to
    find the set name. Therefore, applying `fynd` to any of those elements the next
    time around will benefit from this update. This idea is called path compression.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more interesting idea we can apply. This is to maintain a rank
    of each element, which is roughly the depth of the tree of elements for which
    that element is their set name. When we union two elements, we then make the one
    with larger rank the parent of the one with the smaller rank. This has the effect
    of avoiding growing very tall paths to set name elements, instead tending towards
    ‚Äúbushy‚Äù trees. This too reduces the number of parents that must be traversed to
    find the representative.
  prefs: []
  type: TYPE_NORMAL
- en: 18.3.3¬†Analysis[üîó](#(part._.Analysis) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This optimized union-find data structure has a remarkble analysis. In the worst
    case, of course, we must traverse the entire chain of parents to find the name
    element, which takes time proportional to the number of elements in the set. However,
    once we apply the above optimizations, we never need to traverse that same chain
    again! In particular, if we conduct an amortized analysis over a sequence of set
    equality tests after a collection of union operations, we find that the cost for
    subsequent checks is very small‚Äî<wbr>indeed, about as small a function can get
    without being constant. The [actual analysis](http://en.wikipedia.org/wiki/Disjoint-set_data_structure)
    is quite sophisticated; it is also one of the most remarkable algorithm analyses
    in all of computer science.Here‚Äôs a [brief talk](https://www.youtube.com/watch?v=Hhk8ANKWGJA)
    by Robert Tarjan describing the history of his analysis.
  prefs: []
  type: TYPE_NORMAL
