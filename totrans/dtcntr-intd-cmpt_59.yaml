- en: 18.3Â Union-FindğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18.3 è”åˆæŸ¥æ‰¾ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/union-find.html](https://dcic-world.org/2025-08-27/union-find.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/union-find.html](https://dcic-world.org/2025-08-27/union-find.html)
- en: '| Â Â Â Â [18.3.1Â Implementing with State](#%28part._.Implementing_with_.State%29)
    |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [18.3.1 ä½¿ç”¨çŠ¶æ€å®ç°](#(part._.Implementing_with_.State)) |'
- en: '| Â Â Â Â [18.3.2Â Optimizations](#%28part._.Optimizations%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [18.3.2 ä¼˜åŒ–](#(part._.Optimizations)) |'
- en: '| Â Â Â Â [18.3.3Â Analysis](#%28part._.Analysis%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [18.3.3 åˆ†æ](#(part._.Analysis)) |'
- en: 'We have previously [[Checking Component Connectedness](mst.html#%28part._union-find-functional%29)]
    seen how to check connectedness of components, but found that solution unsatisfactory.
    Recall that it comes down to two set operations: we want to construct the unions
    of sets, and then determine whether two elements are in the same set.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¹‹å‰ [[æ£€æŸ¥ç»„ä»¶è¿é€šæ€§](mst.html#(part._union-find-functional))] çœ‹è¿‡å¦‚ä½•æ£€æŸ¥ç»„ä»¶çš„è¿é€šæ€§ï¼Œä½†å‘ç°é‚£ä¸ªè§£å†³æ–¹æ¡ˆä¸æ»¡æ„ã€‚å›æƒ³ä¸€ä¸‹ï¼Œè¿™å½’ç»“ä¸ºä¸¤ä¸ªé›†åˆæ“ä½œï¼šæˆ‘ä»¬æƒ³è¦æ„é€ é›†åˆçš„å¹¶é›†ï¼Œç„¶åç¡®å®šä¸¤ä¸ªå…ƒç´ æ˜¯å¦å±äºåŒä¸€ä¸ªé›†åˆã€‚
- en: We will now see how to do this using state. We will try to keep things as similar
    to the previous version as possible, to enhance comparison.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨å°†çœ‹åˆ°å¦‚ä½•ä½¿ç”¨çŠ¶æ€æ¥å®ç°è¿™ä¸€ç‚¹ã€‚æˆ‘ä»¬å°†å°½é‡ä½¿å®ƒä¸ä¸Šä¸€ä¸ªç‰ˆæœ¬å°½å¯èƒ½ç›¸ä¼¼ï¼Œä»¥å¢å¼ºæ¯”è¾ƒã€‚
- en: 18.3.1Â Implementing with State[ğŸ”—](#(part._.Implementing_with_.State) "Link to
    here")
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.3.1 ä½¿ç”¨çŠ¶æ€å®ç°[ğŸ”—](#(part._.Implementing_with_.State) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'First, we have to update the definition of an element, making the `parent`
    field be mutable:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæˆ‘ä»¬å¿…é¡»æ›´æ–°å…ƒç´ çš„å®šä¹‰ï¼Œä½¿`parent`å­—æ®µå¯å˜ï¼š
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To determine whether two elements are in the same set, we will still rely on
    `fynd`. However, as we will soon see, `fynd` no longer needs to be given the entire
    set of elements. Because the only reason `is-in-same-set` consumed that set was
    to pass it on to `fynd`, we can remove it from here. Nothing else changes:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: è¦ç¡®å®šä¸¤ä¸ªå…ƒç´ æ˜¯å¦å±äºåŒä¸€ä¸ªé›†åˆï¼Œæˆ‘ä»¬ä»ç„¶ä¼šä¾èµ–`fynd`ã€‚ç„¶è€Œï¼Œæ­£å¦‚æˆ‘ä»¬å¾ˆå¿«å°†çœ‹åˆ°çš„ï¼Œ`fynd`ä¸å†éœ€è¦ç»™å‡ºæ•´ä¸ªå…ƒç´ é›†åˆã€‚å› ä¸º`is-in-same-set`æ¶ˆè€—é‚£ä¸ªé›†åˆçš„å”¯ä¸€åŸå› æ˜¯ä¸ºäº†å°†å…¶ä¼ é€’ç»™`fynd`ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä»è¿™é‡Œç§»é™¤å®ƒã€‚å…¶ä»–ä»€ä¹ˆéƒ½æ²¡æœ‰æ”¹å˜ï¼š
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Updating is now the crucial difference: we use mutation to change the value
    of the parent:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: æ›´æ–°ç°åœ¨æ˜¯å…³é”®çš„åŒºåˆ«ï¼šæˆ‘ä»¬ä½¿ç”¨å˜å¼‚æ¥æ”¹å˜çˆ¶ä»£çš„ä»·å€¼ï¼š
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In `parent: some(parent)`, the first `parent` is the name of the field, while
    the second one is the parameter name. In addition, we must use `some` to satisfy
    the option type. Naturally, it is not `none` because the entire point of this
    mutation is to change the parent to be the other element, irrespective of what
    was there before.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 'åœ¨`parent: some(parent)`ä¸­ï¼Œç¬¬ä¸€ä¸ª`parent`æ˜¯å­—æ®µåç§°ï¼Œè€Œç¬¬äºŒä¸ªæ˜¯å‚æ•°åç§°ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬å¿…é¡»ä½¿ç”¨`some`æ¥æ»¡è¶³å¯é€‰ç±»å‹ã€‚è‡ªç„¶åœ°ï¼Œå®ƒä¸æ˜¯`none`ï¼Œå› ä¸ºè¿™æ¬¡å˜å¼‚çš„å…¨éƒ¨ç›®çš„å°±æ˜¯å°†çˆ¶ä»£æ›´æ”¹ä¸ºå¦ä¸€ä¸ªå…ƒç´ ï¼Œè€Œä¸ç®¡ä¹‹å‰æ˜¯ä»€ä¹ˆã€‚'
- en: 'Given this definition, `union` also stays largely unchanged, other than the
    change to the return type. Previously, it needed to return the updated set of
    elements; now, because the update is performed by mutation, there is no longer
    any need to return anything:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ç»™å®šè¿™ä¸ªå®šä¹‰ï¼Œ`union`ä¹ŸåŸºæœ¬ä¿æŒä¸å˜ï¼Œé™¤äº†è¿”å›ç±»å‹çš„å˜åŒ–ã€‚ä¹‹å‰ï¼Œå®ƒéœ€è¦è¿”å›æ›´æ–°åçš„å…ƒç´ é›†åˆï¼›ç°åœ¨ï¼Œå› ä¸ºæ›´æ–°æ˜¯é€šè¿‡å˜å¼‚æ¥æ‰§è¡Œçš„ï¼Œæ‰€ä»¥ä¸å†éœ€è¦è¿”å›ä»»ä½•å†…å®¹ï¼š
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, `fynd`. Its implementation is now remarkably simple. There is no longer
    any need to search through the set. Previously, we had to search because after
    union operations have occurred, the parent reference might have no longer been
    valid. Now, any such changes are automatically reflected by mutation. Hence:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæ˜¯`fynd`ã€‚å®ƒçš„å®ç°ç°åœ¨éå¸¸ç®€å•ã€‚ä¸å†éœ€è¦æœç´¢é›†åˆã€‚ä¹‹å‰ï¼Œæˆ‘ä»¬å¿…é¡»æœç´¢ï¼Œå› ä¸ºè”åˆæ“ä½œå‘ç”Ÿåï¼Œçˆ¶å¼•ç”¨å¯èƒ½ä¸å†æœ‰æ•ˆã€‚ç°åœ¨ï¼Œä»»ä½•æ­¤ç±»æ›´æ”¹éƒ½ä¼šé€šè¿‡å˜å¼‚è‡ªåŠ¨åæ˜ ã€‚å› æ­¤ï¼š
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 18.3.2Â Optimizations[ğŸ”—](#(part._.Optimizations) "Link to here")
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.3.2 ä¼˜åŒ–[ğŸ”—](#(part._.Optimizations) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Look again at `fynd`. In the `some` case, the element bound to `e` is not the
    set name; that is obtained by recursively traversing `parent` references. As this
    value returns, however, we donâ€™t do anything to reflect this new knowledge! Instead,
    the next time we try to find the parent of this element, weâ€™re going to perform
    this same recursive traversal all over again.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡çœ‹çœ‹`fynd`ã€‚åœ¨`some`æƒ…å†µä¸‹ï¼Œç»‘å®šåˆ°`e`çš„å…ƒç´ ä¸æ˜¯é›†åˆåç§°ï¼›è¿™æ˜¯é€šè¿‡é€’å½’éå†`parent`å¼•ç”¨è·å¾—çš„ã€‚ç„¶è€Œï¼Œå½“è¿™ä¸ªå€¼è¿”å›æ—¶ï¼Œæˆ‘ä»¬å¹¶æ²¡æœ‰åšä»»ä½•äº‹æƒ…æ¥åæ˜ è¿™ç§æ–°çš„çŸ¥è¯†ï¼ç›¸åï¼Œä¸‹æ¬¡æˆ‘ä»¬å°è¯•æ‰¾åˆ°è¿™ä¸ªå…ƒç´ çš„çˆ¶ä»£æ—¶ï¼Œæˆ‘ä»¬å°†å†æ¬¡æ‰§è¡Œç›¸åŒçš„é€’å½’éå†ã€‚
- en: 'Using mutation helps address this problem. The idea is as simple as can be:
    compute the value of the parent, and update it.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨å˜å¼‚å¯ä»¥å¸®åŠ©è§£å†³è¿™ä¸ªé—®é¢˜ã€‚è¿™ä¸ªæƒ³æ³•ç®€å•åˆ°ä¸èƒ½å†ç®€å•ï¼šè®¡ç®—çˆ¶ä»£çš„ä»·å€¼ï¼Œå¹¶æ›´æ–°å®ƒã€‚
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that this update will apply to every element in the recursive chain to
    find the set name. Therefore, applying `fynd` to any of those elements the next
    time around will benefit from this update. This idea is called path compression.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè¿™ä¸ªæ›´æ–°å°†åº”ç”¨äºå¯»æ‰¾é›†åˆåç§°çš„é€’å½’é“¾ä¸­çš„æ¯ä¸ªå…ƒç´ ã€‚å› æ­¤ï¼Œä¸‹æ¬¡åº”ç”¨ `fynd` åˆ°è¿™äº›å…ƒç´ ä¸­çš„ä»»ä½•ä¸€ä¸ªæ—¶ï¼Œå°†å—ç›Šäºè¿™æ¬¡æ›´æ–°ã€‚è¿™ä¸ªæƒ³æ³•è¢«ç§°ä¸ºè·¯å¾„å‹ç¼©ã€‚
- en: There is one more interesting idea we can apply. This is to maintain a rank
    of each element, which is roughly the depth of the tree of elements for which
    that element is their set name. When we union two elements, we then make the one
    with larger rank the parent of the one with the smaller rank. This has the effect
    of avoiding growing very tall paths to set name elements, instead tending towards
    â€œbushyâ€ trees. This too reduces the number of parents that must be traversed to
    find the representative.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å¯ä»¥åº”ç”¨ä¸€ä¸ªæœ‰è¶£çš„æƒ³æ³•ã€‚è¿™æ˜¯ç»´æŠ¤æ¯ä¸ªå…ƒç´ çš„ç§©ï¼Œè¿™å¤§è‡´æ˜¯å…ƒç´ æ ‘ï¼ˆå…¶ä¸­è¯¥å…ƒç´ æ˜¯å®ƒä»¬çš„é›†åˆåç§°ï¼‰çš„æ·±åº¦ã€‚å½“æˆ‘ä»¬åˆå¹¶ä¸¤ä¸ªå…ƒç´ æ—¶ï¼Œæˆ‘ä»¬è®©ç§©è¾ƒå¤§çš„å…ƒç´ æˆä¸ºç§©è¾ƒå°çš„å…ƒç´ çš„çˆ¶å…ƒç´ ã€‚è¿™æœ‰åŠ©äºé¿å…ç”Ÿæˆéå¸¸é•¿çš„è·¯å¾„åˆ°é›†åˆåç§°å…ƒç´ ï¼Œè€Œæ˜¯è¶‹å‘äºâ€œçŒæœ¨ä¸›â€çŠ¶çš„æ ‘ã€‚è¿™ä¹Ÿå‡å°‘äº†å¿…é¡»éå†ä»¥æ‰¾åˆ°ä»£è¡¨è€…çš„çˆ¶å…ƒç´ æ•°é‡ã€‚
- en: 18.3.3Â Analysis[ğŸ”—](#(part._.Analysis) "Link to here")
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.3.3 åˆ†æ[ğŸ”—](#(part._.Analysis) "é“¾æ¥è‡³æ­¤")
- en: This optimized union-find data structure has a remarkble analysis. In the worst
    case, of course, we must traverse the entire chain of parents to find the name
    element, which takes time proportional to the number of elements in the set. However,
    once we apply the above optimizations, we never need to traverse that same chain
    again! In particular, if we conduct an amortized analysis over a sequence of set
    equality tests after a collection of union operations, we find that the cost for
    subsequent checks is very smallâ€”<wbr>indeed, about as small a function can get
    without being constant. The [actual analysis](http://en.wikipedia.org/wiki/Disjoint-set_data_structure)
    is quite sophisticated; it is also one of the most remarkable algorithm analyses
    in all of computer science.Hereâ€™s a [brief talk](https://www.youtube.com/watch?v=Hhk8ANKWGJA)
    by Robert Tarjan describing the history of his analysis.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªä¼˜åŒ–çš„å¹¶æŸ¥é›†æ•°æ®ç»“æ„æœ‰ä¸€ä¸ªä»¤äººç©ç›®çš„åˆ†æã€‚å½“ç„¶ï¼Œåœ¨æœ€åçš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¿…é¡»éå†æ•´ä¸ªçˆ¶å…ƒç´ é“¾æ¥æ‰¾åˆ°åç§°å…ƒç´ ï¼Œè¿™éœ€è¦ä¸é›†åˆä¸­å…ƒç´ æ•°é‡æˆæ¯”ä¾‹çš„æ—¶é—´ã€‚ç„¶è€Œï¼Œä¸€æ—¦æˆ‘ä»¬åº”ç”¨ä¸Šè¿°ä¼˜åŒ–ï¼Œæˆ‘ä»¬å°±å†ä¹Ÿä¸éœ€è¦éå†ç›¸åŒçš„é“¾äº†ï¼ç‰¹åˆ«æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬å¯¹ä¸€ç³»åˆ—é›†åˆç­‰ä»·æµ‹è¯•è¿›è¡Œæ‘Šé”€åˆ†æï¼Œåœ¨ä¸€ç³»åˆ—å¹¶æ“ä½œä¹‹åï¼Œæˆ‘ä»¬å‘ç°åç»­æ£€æŸ¥çš„æˆæœ¬éå¸¸å°â€”â€”ç¡®å®ï¼Œå‡ ä¹æ˜¯ä¸€ä¸ªå¯ä»¥å¾—åˆ°çš„éå¸¸å°çš„å‡½æ•°ï¼Œè€Œä¸éœ€è¦æ˜¯å¸¸æ•°ã€‚å®é™…çš„[åˆ†æ](http://en.wikipedia.org/wiki/Disjoint-set_data_structure)ç›¸å½“å¤æ‚ï¼›å®ƒä¹Ÿæ˜¯è®¡ç®—æœºç§‘å­¦ä¸­æœ€æ˜¾è‘—çš„ç®—æ³•åˆ†æä¹‹ä¸€ã€‚è¿™é‡Œæœ‰
    Robert Tarjan å…³äºä»–åˆ†æå†å²çš„[ç®€è¦æ¼”è®²](https://www.youtube.com/watch?v=Hhk8ANKWGJA)ã€‚
- en: 18.3.1Â Implementing with State[ğŸ”—](#(part._.Implementing_with_.State) "Link to
    here")
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.3.1 ä½¿ç”¨çŠ¶æ€å®ç°[ğŸ”—](#(part._.Implementing_with_.State) "é“¾æ¥è‡³æ­¤")
- en: 'First, we have to update the definition of an element, making the `parent`
    field be mutable:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæˆ‘ä»¬å¿…é¡»æ›´æ–°å…ƒç´ çš„å®šä¹‰ï¼Œä½¿ `parent` å­—æ®µå¯å˜ï¼š
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To determine whether two elements are in the same set, we will still rely on
    `fynd`. However, as we will soon see, `fynd` no longer needs to be given the entire
    set of elements. Because the only reason `is-in-same-set` consumed that set was
    to pass it on to `fynd`, we can remove it from here. Nothing else changes:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: è¦ç¡®å®šä¸¤ä¸ªå…ƒç´ æ˜¯å¦å±äºåŒä¸€é›†åˆï¼Œæˆ‘ä»¬ä»ç„¶ä¼šä¾èµ– `fynd`ã€‚ç„¶è€Œï¼Œæ­£å¦‚æˆ‘ä»¬å¾ˆå¿«å°±ä¼šçœ‹åˆ°çš„ï¼Œ`fynd` ä¸å†éœ€è¦ç»™å‡ºæ•´ä¸ªå…ƒç´ é›†ã€‚å› ä¸º `is-in-same-set`
    æ¶ˆè€—è¯¥é›†åˆçš„å”¯ä¸€åŸå› æ˜¯ä¸ºäº†å°†å…¶ä¼ é€’ç»™ `fynd`ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä»è¿™é‡Œåˆ é™¤å®ƒã€‚å…¶ä»–ä»€ä¹ˆéƒ½æ²¡æœ‰æ”¹å˜ï¼š
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Updating is now the crucial difference: we use mutation to change the value
    of the parent:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: æ›´æ–°ç°åœ¨æ˜¯å…³é”®çš„åŒºåˆ«ï¼šæˆ‘ä»¬ä½¿ç”¨å˜å¼‚æ¥æ›´æ”¹çˆ¶å…ƒç´ çš„å€¼ï¼š
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In `parent: some(parent)`, the first `parent` is the name of the field, while
    the second one is the parameter name. In addition, we must use `some` to satisfy
    the option type. Naturally, it is not `none` because the entire point of this
    mutation is to change the parent to be the other element, irrespective of what
    was there before.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 'åœ¨ `parent: some(parent)` ä¸­ï¼Œç¬¬ä¸€ä¸ª `parent` æ˜¯å­—æ®µåï¼Œè€Œç¬¬äºŒä¸ªæ˜¯å‚æ•°åã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬å¿…é¡»ä½¿ç”¨ `some` æ¥æ»¡è¶³é€‰é¡¹ç±»å‹ã€‚è‡ªç„¶åœ°ï¼Œå®ƒä¸æ˜¯
    `none`ï¼Œå› ä¸ºæ•´ä¸ªå˜å¼‚çš„ç›®çš„å°±æ˜¯å°†çˆ¶å…ƒç´ æ›´æ”¹ä¸ºå…¶ä»–å…ƒç´ ï¼Œè€Œä¸ç®¡ä¹‹å‰æ˜¯ä»€ä¹ˆã€‚'
- en: 'Given this definition, `union` also stays largely unchanged, other than the
    change to the return type. Previously, it needed to return the updated set of
    elements; now, because the update is performed by mutation, there is no longer
    any need to return anything:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: æ ¹æ®è¿™ä¸ªå®šä¹‰ï¼Œ`union` ä¹ŸåŸºæœ¬ä¿æŒä¸å˜ï¼Œé™¤äº†è¿”å›ç±»å‹çš„å˜åŒ–ã€‚ä¹‹å‰ï¼Œå®ƒéœ€è¦è¿”å›æ›´æ–°åçš„å…ƒç´ é›†ï¼›ç°åœ¨ï¼Œå› ä¸ºæ›´æ–°æ˜¯é€šè¿‡å˜å¼‚æ¥æ‰§è¡Œçš„ï¼Œæ‰€ä»¥ä¸å†éœ€è¦è¿”å›ä»»ä½•å†…å®¹ï¼š
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, `fynd`. Its implementation is now remarkably simple. There is no longer
    any need to search through the set. Previously, we had to search because after
    union operations have occurred, the parent reference might have no longer been
    valid. Now, any such changes are automatically reflected by mutation. Hence:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œ`fynd`ã€‚å®ƒçš„å®ç°ç°åœ¨éå¸¸ç®€å•ã€‚ä¸å†éœ€è¦æœç´¢é›†åˆã€‚ä»¥å‰ï¼Œæˆ‘ä»¬å¿…é¡»æœç´¢ï¼Œå› ä¸ºè”åˆæ“ä½œå‘ç”Ÿåï¼Œçˆ¶å¼•ç”¨å¯èƒ½ä¸å†æœ‰æ•ˆã€‚ç°åœ¨ï¼Œä»»ä½•æ­¤ç±»æ›´æ”¹éƒ½ä¼šé€šè¿‡å˜å¼‚è‡ªåŠ¨åæ˜ å‡ºæ¥ã€‚å› æ­¤ï¼š
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 18.3.2Â Optimizations[ğŸ”—](#(part._.Optimizations) "Link to here")
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.3.2 ä¼˜åŒ–[ğŸ”—](#(part._.Optimizations) "é“¾æ¥è‡³æ­¤")
- en: Look again at `fynd`. In the `some` case, the element bound to `e` is not the
    set name; that is obtained by recursively traversing `parent` references. As this
    value returns, however, we donâ€™t do anything to reflect this new knowledge! Instead,
    the next time we try to find the parent of this element, weâ€™re going to perform
    this same recursive traversal all over again.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡çœ‹çœ‹ `fynd`ã€‚åœ¨ `some` æƒ…å†µä¸‹ï¼Œç»‘å®šåˆ° `e` çš„å…ƒç´ ä¸æ˜¯é›†åˆåç§°ï¼›è¿™æ˜¯é€šè¿‡é€’å½’éå† `parent` å¼•ç”¨è·å¾—çš„ã€‚ç„¶è€Œï¼Œå½“è¿™ä¸ªå€¼è¿”å›æ—¶ï¼Œæˆ‘ä»¬å¹¶æ²¡æœ‰åšä»»ä½•äº‹æƒ…æ¥åæ˜ è¿™ç§æ–°çš„çŸ¥è¯†ï¼ç›¸åï¼Œä¸‹æ¬¡æˆ‘ä»¬å°è¯•æ‰¾åˆ°è¿™ä¸ªå…ƒç´ çš„çˆ¶èŠ‚ç‚¹æ—¶ï¼Œæˆ‘ä»¬å°†å†æ¬¡æ‰§è¡Œç›¸åŒçš„é€’å½’éå†ã€‚
- en: 'Using mutation helps address this problem. The idea is as simple as can be:
    compute the value of the parent, and update it.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨å˜å¼‚å¯ä»¥å¸®åŠ©è§£å†³è¿™ä¸ªé—®é¢˜ã€‚è¿™ä¸ªæƒ³æ³•éå¸¸ç®€å•ï¼šè®¡ç®—çˆ¶èŠ‚ç‚¹çš„å€¼ï¼Œå¹¶æ›´æ–°å®ƒã€‚
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that this update will apply to every element in the recursive chain to
    find the set name. Therefore, applying `fynd` to any of those elements the next
    time around will benefit from this update. This idea is called path compression.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè¿™æ¬¡æ›´æ–°å°†é€‚ç”¨äºæ‰¾åˆ°é›†åˆåç§°çš„é€’å½’é“¾ä¸­çš„æ¯ä¸ªå…ƒç´ ã€‚å› æ­¤ï¼Œä¸‹æ¬¡åº”ç”¨ `fynd` åˆ°è¿™äº›å…ƒç´ ä¸­çš„ä»»ä½•ä¸€ä¸ªæ—¶ï¼Œå°†å—ç›Šäºè¿™æ¬¡æ›´æ–°ã€‚è¿™ä¸ªæƒ³æ³•è¢«ç§°ä¸ºè·¯å¾„å‹ç¼©ã€‚
- en: There is one more interesting idea we can apply. This is to maintain a rank
    of each element, which is roughly the depth of the tree of elements for which
    that element is their set name. When we union two elements, we then make the one
    with larger rank the parent of the one with the smaller rank. This has the effect
    of avoiding growing very tall paths to set name elements, instead tending towards
    â€œbushyâ€ trees. This too reduces the number of parents that must be traversed to
    find the representative.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å¯ä»¥åº”ç”¨å¦ä¸€ä¸ªæœ‰è¶£çš„æƒ³æ³•ã€‚è¿™æ˜¯ç»´æŠ¤æ¯ä¸ªå…ƒç´ çš„ç­‰çº§ï¼Œè¿™å¤§è‡´æ˜¯å…ƒç´ æ ‘ï¼ˆå…¶ä¸­è¯¥å…ƒç´ æ˜¯å®ƒä»¬çš„é›†åˆåç§°ï¼‰çš„æ·±åº¦ã€‚å½“æˆ‘ä»¬åˆå¹¶ä¸¤ä¸ªå…ƒç´ æ—¶ï¼Œæˆ‘ä»¬è®©ç­‰çº§è¾ƒé«˜çš„å…ƒç´ æˆä¸ºç­‰çº§è¾ƒä½çš„å…ƒç´ çš„çˆ¶èŠ‚ç‚¹ã€‚è¿™æœ‰åŠ©äºé¿å…éå¸¸é•¿çš„è·¯å¾„ç”Ÿé•¿åˆ°é›†åˆåç§°å…ƒç´ ï¼Œè€Œæ˜¯è¶‹å‘äºâ€œçŒæœ¨ä¸›â€çŠ¶çš„æ ‘ã€‚è¿™ä¹Ÿå‡å°‘äº†å¿…é¡»éå†ä»¥æ‰¾åˆ°ä»£è¡¨è€…çš„çˆ¶èŠ‚ç‚¹æ•°é‡ã€‚
- en: 18.3.3Â Analysis[ğŸ”—](#(part._.Analysis) "Link to here")
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.3.3 åˆ†æ[ğŸ”—](#(part._.Analysis) "é“¾æ¥è‡³æ­¤")
- en: This optimized union-find data structure has a remarkble analysis. In the worst
    case, of course, we must traverse the entire chain of parents to find the name
    element, which takes time proportional to the number of elements in the set. However,
    once we apply the above optimizations, we never need to traverse that same chain
    again! In particular, if we conduct an amortized analysis over a sequence of set
    equality tests after a collection of union operations, we find that the cost for
    subsequent checks is very smallâ€”<wbr>indeed, about as small a function can get
    without being constant. The [actual analysis](http://en.wikipedia.org/wiki/Disjoint-set_data_structure)
    is quite sophisticated; it is also one of the most remarkable algorithm analyses
    in all of computer science.Hereâ€™s a [brief talk](https://www.youtube.com/watch?v=Hhk8ANKWGJA)
    by Robert Tarjan describing the history of his analysis.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªä¼˜åŒ–çš„å¹¶æŸ¥é›†æ•°æ®ç»“æ„æœ‰ä¸€ä¸ªéå¸¸å‡ºè‰²çš„åˆ†æã€‚å½“ç„¶ï¼Œåœ¨æœ€åçš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¿…é¡»éå†æ•´ä¸ªçˆ¶èŠ‚ç‚¹é“¾æ¥æ‰¾åˆ°åç§°å…ƒç´ ï¼Œè¿™éœ€è¦ä¸é›†åˆä¸­å…ƒç´ æ•°é‡æˆæ¯”ä¾‹çš„æ—¶é—´ã€‚ç„¶è€Œï¼Œä¸€æ—¦æˆ‘ä»¬åº”ç”¨ä¸Šè¿°ä¼˜åŒ–ï¼Œæˆ‘ä»¬å°±æ°¸è¿œä¸éœ€è¦å†æ¬¡éå†ç›¸åŒçš„é“¾ï¼ç‰¹åˆ«æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬å¯¹ä¸€ç³»åˆ—é›†åˆç­‰ä»·æµ‹è¯•è¿›è¡Œæ‘Šé”€åˆ†æï¼Œè¿™äº›æµ‹è¯•æ˜¯åœ¨ä¸€ç³»åˆ—è”åˆæ“ä½œä¹‹åè¿›è¡Œçš„ï¼Œæˆ‘ä»¬å‘ç°åç»­æ£€æŸ¥çš„æˆæœ¬éå¸¸å°â€”â€”ç¡®å®ï¼Œå‡ ä¹æ˜¯ä¸€ä¸ªå°½å¯èƒ½å°çš„å‡½æ•°ï¼Œè€Œä¸éœ€è¦æ˜¯å¸¸æ•°ã€‚å®é™…çš„[åˆ†æ](http://en.wikipedia.org/wiki/Disjoint-set_data_structure)éå¸¸å¤æ‚ï¼›å®ƒä¹Ÿæ˜¯è®¡ç®—æœºç§‘å­¦ä¸­æœ€å‡ºè‰²çš„ç®—æ³•åˆ†æä¹‹ä¸€ã€‚è¿™é‡Œæœ‰Robert
    Tarjanå…³äºä»–åˆ†æå†å²çš„[ç®€è¦æ¼”è®²](https://www.youtube.com/watch?v=Hhk8ANKWGJA)ã€‚
