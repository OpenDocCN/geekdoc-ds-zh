- en: 21¬†Detecting Cyclesüîó
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://dcic-world.org/2025-08-27/cycle-detection.html](https://dcic-world.org/2025-08-27/cycle-detection.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| ¬†¬†¬†¬†[21.1¬†A Running Example](#%28part._.A_.Running_.Example%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[21.2¬†Types](#%28part._.Types%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[21.3¬†A First Checker](#%28part._.A_.First_.Checker%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[21.4¬†Complexity](#%28part._cyc-det-comp%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[21.5¬†A Fabulous Improvement](#%28part._.A_.Fabulous_.Improvement%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[21.6¬†Testing](#%28part._.Testing%29) |'
  prefs: []
  type: TYPE_TB
- en: 21.1¬†A Running Example[üîó](#(part._.A_.Running_.Example) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you may have noticed, Pyret will check for and print cycles. For instance,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sketch out the above pairs to make sure you see all the cycles.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: So we have two that participate in no cyclic behavior (`p0` and `p1`), two (`p2`
    and `p3` that are mutually-cyclic, one (`p6`) that is a self-cycle, and two (`p4`
    and `p5`) that lead to a cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 21.2¬†Types[üîó](#(part._.Types) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As an aside, imagine we try to type-check this program. We have to provide
    a type for `tl`, but it‚Äôs not clear what this can be: sometimes it‚Äôs a `Number`,
    and other times it‚Äôs a `Pair`. However, we might observe that if our goal is to
    create cyclic data, then we want `tl` to refer to a `Pair` or to nothing at all.
    That suggests that a useful type is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: so that we can write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This works, but we have to deal with the `Option` everywhere. Since our goal
    is to focus on cycles, and this would become unwieldy, we ignore the typed version
    from now on.
  prefs: []
  type: TYPE_NORMAL
- en: 21.3¬†A First Checker[üîó](#(part._.A_.First_.Checker) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Okay, back to the untyped version.
  prefs: []
  type: TYPE_NORMAL
- en: So let‚Äôs try to figure out whether, given a Pair, it leads to a cycle. What
    should the type be?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: where `cc` stands for ‚Äúcheck cycle‚Äù.
  prefs: []
  type: TYPE_NORMAL
- en: 'Critically, it‚Äôs important that this be a total function: i.e., it always terminates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So let‚Äôs write the most obvious solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, does this even terminate? It could take a while to visit all
    the nodes, but a cycle demands that somewhere, we revisit a node we saw before.
    Since we track that, we can‚Äôt not terminate. Therefore, termination is guaranteed,
    and the function is total. Indeed, all these tests pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As another aside, observe that we could have written these tests instead like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'which would be more concise, but that would also be misleading: it would suggest
    that `cc` is a desirable property, so `p2` is a ‚Äúgood‚Äù instance and `p0` is a
    ‚Äúbad‚Äù one. However, `cc` is not a judgment of quality‚Äî<wbr>its two responses have
    equal weight‚Äî<wbr>so this would be confusing to a later reader.'
  prefs: []
  type: TYPE_NORMAL
- en: 21.4¬†Complexity[üîó](#(part._cyc-det-comp) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have determined that it terminates, we can ask for its time and
    space complexity. First we have to decide what we are even computing the complexity
    over. If the sequence is finite, then the size is clearly the size of the sequence.
    But if it‚Äôs infinite, we don‚Äôt want to traverse the ‚Äúwhole thing‚Äù: rather, we
    mean its finite part (excluding any repetition). So the meaningful measure in
    either case is the number of `p` nodes, i.e., the finite size. It may just be
    that some of these lead back to themselves, so that a na√Øve traversal will go
    on forever.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so we visit each node once. We keep track of all the nodes just in case
    we double back over, either until we run out of nodes or we repeat one. Therefore,
    the space complexity is linear in the length of the sum of the prefix (from the
    starting node) and the cycle. The time complexity is that but also, at each point,
    we have to check membership, so it‚Äôs quadratic in the length of that prefix +
    cycle. So: linear space, quadratic time, in the size of the prefix + cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, some degree of linear behavior is unavoidable: we clearly have to keep
    going until we run out or hit a cycle, so for detecting the cycle having something
    be linear in the size of the prefix (get it out of the way) + length of the cycle
    (find the cycle) seems essential. But can we improve on this complexity? It seems
    unlikely: by definition, how can we check for a cycle if we don‚Äôt remember everything
    we‚Äôve seen?'
  prefs: []
  type: TYPE_NORMAL
- en: Our first hunch might be, ‚ÄúMaybe there‚Äôs another space-time tradeoff!‚Äù But it‚Äôs
    not so clear here. Our space is linear and time quadratic, so we may think we
    can flip those around. But the time can‚Äôt be less than the space! If, for instance,
    we had linear time and quadratic space, that wouldn‚Äôt make sense, because we‚Äôd
    need at least quadratic time just to fill the space. So that‚Äôs not going to work
    so well.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the best way to improve seems to have a better lookup data structure.
    We‚Äôd still take linear space‚Äî<wbr>as we said, linear was unavoidable (and we can‚Äôt
    just be linear in the size of the cycle, because the whole point is we don‚Äôt even
    know we have a cycle, much less which parts are prefix and which parts cycle)‚Äî<wbr>and
    the time complexity would hopefully reduce from quadratic to linear-times-something-sublinear.
  prefs: []
  type: TYPE_NORMAL
- en: 21.5¬†A Fabulous Improvement[üîó](#(part._.A_.Fabulous_.Improvement) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It turns out we can do a lot better! It‚Äôs called the tortoise-and-hare algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: We start off with two references into the sequence, one called the tortoise
    and the other the hare.
  prefs: []
  type: TYPE_NORMAL
- en: At each step, the tortoise tries to advance by one node. If it cannot, we‚Äôve
    run out of sequence, and we‚Äôre done. The hare, being a hare and not a tortoise,
    tries to advance by two nodes. Again, if it cannot, we‚Äôve run out of sequence,
    and we‚Äôre done. Otherwise both advance, and check if they‚Äôre at the same place.
    If they are, because they started out being at distinct nodes, we‚Äôve found a cycle!
    If they are not, then we iterate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why does this even work? In the finite case it‚Äôs clear, because the hare will
    run out of next nodes. We only have to think about the infinite case. There, in
    general, we have this kind of situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/31742a6ba02914cbc2bca965912ea982.png)'
  prefs: []
  type: TYPE_IMG
- en: There is some prefix of nodes, followed by a cycle. Now, we don‚Äôt know how long
    the prefix is, so we don‚Äôt know how far ahead of the tortoise the hare is. Nevertheless,
    there is some first point at which the tortoise enters the cycle. (There must
    be, because the tortoise always makes progress, and the prefix can only be finite.)
    From this point on, we know that on each step, the relative speed of the two animals
    is 1\. That means the hare ‚Äúgains‚Äù 1 on the tortoise every step. We can see that
    eventually, the hare must catch up with the tortoise‚Äî<wbr>or, alternatively, that
    the tortoise catches up with the hare!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let‚Äôs analyze this. The tortoise will get caught by the time it has completed
    one loop of the cycle. Because the tortoise moves one step at a time, the total
    time is the length of the prefix + length of the loop. In terms of space, however,
    we no longer need any history at all; we only need the current positions of the
    tortoise and hare. Therefore, our time complexity is linear, but the space complexity
    is now significantly smaller: down to constant!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 21.6¬†Testing[üîó](#(part._.Testing) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While it might be tempting to write tests like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '(i.e., the same as before, but with `cc` replaced by `ph`), we should instead
    write them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This confers two advantages. First, if we change the example, we don‚Äôt have
    to update two tests, only one. But the much more important reason is that we intend
    for `pr` to be an optimized version of `cc`. That is, we expect the two to produce
    the same result. We can think of `cc` as our clear, reference implementation.
    That is, this is another instance of model-based testing.
  prefs: []
  type: TYPE_NORMAL
- en: As an aside, this algorithm is not exactly what Pyret does, because we need
    to check for arbitrary graph-ness, not just cycles. It‚Äôs also complicated due
    to user-defined functions, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 21.1¬†A Running Example[üîó](#(part._.A_.Running_.Example) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you may have noticed, Pyret will check for and print cycles. For instance,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sketch out the above pairs to make sure you see all the cycles.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: So we have two that participate in no cyclic behavior (`p0` and `p1`), two (`p2`
    and `p3` that are mutually-cyclic, one (`p6`) that is a self-cycle, and two (`p4`
    and `p5`) that lead to a cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 21.2¬†Types[üîó](#(part._.Types) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As an aside, imagine we try to type-check this program. We have to provide
    a type for `tl`, but it‚Äôs not clear what this can be: sometimes it‚Äôs a `Number`,
    and other times it‚Äôs a `Pair`. However, we might observe that if our goal is to
    create cyclic data, then we want `tl` to refer to a `Pair` or to nothing at all.
    That suggests that a useful type is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: so that we can write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This works, but we have to deal with the `Option` everywhere. Since our goal
    is to focus on cycles, and this would become unwieldy, we ignore the typed version
    from now on.
  prefs: []
  type: TYPE_NORMAL
- en: 21.3¬†A First Checker[üîó](#(part._.A_.First_.Checker) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Okay, back to the untyped version.
  prefs: []
  type: TYPE_NORMAL
- en: So let‚Äôs try to figure out whether, given a Pair, it leads to a cycle. What
    should the type be?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: where `cc` stands for ‚Äúcheck cycle‚Äù.
  prefs: []
  type: TYPE_NORMAL
- en: 'Critically, it‚Äôs important that this be a total function: i.e., it always terminates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So let‚Äôs write the most obvious solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, does this even terminate? It could take a while to visit all
    the nodes, but a cycle demands that somewhere, we revisit a node we saw before.
    Since we track that, we can‚Äôt not terminate. Therefore, termination is guaranteed,
    and the function is total. Indeed, all these tests pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As another aside, observe that we could have written these tests instead like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'which would be more concise, but that would also be misleading: it would suggest
    that `cc` is a desirable property, so `p2` is a ‚Äúgood‚Äù instance and `p0` is a
    ‚Äúbad‚Äù one. However, `cc` is not a judgment of quality‚Äî<wbr>its two responses have
    equal weight‚Äî<wbr>so this would be confusing to a later reader.'
  prefs: []
  type: TYPE_NORMAL
- en: 21.4¬†Complexity[üîó](#(part._cyc-det-comp) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have determined that it terminates, we can ask for its time and
    space complexity. First we have to decide what we are even computing the complexity
    over. If the sequence is finite, then the size is clearly the size of the sequence.
    But if it‚Äôs infinite, we don‚Äôt want to traverse the ‚Äúwhole thing‚Äù: rather, we
    mean its finite part (excluding any repetition). So the meaningful measure in
    either case is the number of `p` nodes, i.e., the finite size. It may just be
    that some of these lead back to themselves, so that a na√Øve traversal will go
    on forever.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so we visit each node once. We keep track of all the nodes just in case
    we double back over, either until we run out of nodes or we repeat one. Therefore,
    the space complexity is linear in the length of the sum of the prefix (from the
    starting node) and the cycle. The time complexity is that but also, at each point,
    we have to check membership, so it‚Äôs quadratic in the length of that prefix +
    cycle. So: linear space, quadratic time, in the size of the prefix + cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, some degree of linear behavior is unavoidable: we clearly have to keep
    going until we run out or hit a cycle, so for detecting the cycle having something
    be linear in the size of the prefix (get it out of the way) + length of the cycle
    (find the cycle) seems essential. But can we improve on this complexity? It seems
    unlikely: by definition, how can we check for a cycle if we don‚Äôt remember everything
    we‚Äôve seen?'
  prefs: []
  type: TYPE_NORMAL
- en: Our first hunch might be, ‚ÄúMaybe there‚Äôs another space-time tradeoff!‚Äù But it‚Äôs
    not so clear here. Our space is linear and time quadratic, so we may think we
    can flip those around. But the time can‚Äôt be less than the space! If, for instance,
    we had linear time and quadratic space, that wouldn‚Äôt make sense, because we‚Äôd
    need at least quadratic time just to fill the space. So that‚Äôs not going to work
    so well.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the best way to improve seems to have a better lookup data structure.
    We‚Äôd still take linear space‚Äî<wbr>as we said, linear was unavoidable (and we can‚Äôt
    just be linear in the size of the cycle, because the whole point is we don‚Äôt even
    know we have a cycle, much less which parts are prefix and which parts cycle)‚Äî<wbr>and
    the time complexity would hopefully reduce from quadratic to linear-times-something-sublinear.
  prefs: []
  type: TYPE_NORMAL
- en: 21.5¬†A Fabulous Improvement[üîó](#(part._.A_.Fabulous_.Improvement) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It turns out we can do a lot better! It‚Äôs called the tortoise-and-hare algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: We start off with two references into the sequence, one called the tortoise
    and the other the hare.
  prefs: []
  type: TYPE_NORMAL
- en: At each step, the tortoise tries to advance by one node. If it cannot, we‚Äôve
    run out of sequence, and we‚Äôre done. The hare, being a hare and not a tortoise,
    tries to advance by two nodes. Again, if it cannot, we‚Äôve run out of sequence,
    and we‚Äôre done. Otherwise both advance, and check if they‚Äôre at the same place.
    If they are, because they started out being at distinct nodes, we‚Äôve found a cycle!
    If they are not, then we iterate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why does this even work? In the finite case it‚Äôs clear, because the hare will
    run out of next nodes. We only have to think about the infinite case. There, in
    general, we have this kind of situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/31742a6ba02914cbc2bca965912ea982.png)'
  prefs: []
  type: TYPE_IMG
- en: There is some prefix of nodes, followed by a cycle. Now, we don‚Äôt know how long
    the prefix is, so we don‚Äôt know how far ahead of the tortoise the hare is. Nevertheless,
    there is some first point at which the tortoise enters the cycle. (There must
    be, because the tortoise always makes progress, and the prefix can only be finite.)
    From this point on, we know that on each step, the relative speed of the two animals
    is 1\. That means the hare ‚Äúgains‚Äù 1 on the tortoise every step. We can see that
    eventually, the hare must catch up with the tortoise‚Äî<wbr>or, alternatively, that
    the tortoise catches up with the hare!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let‚Äôs analyze this. The tortoise will get caught by the time it has completed
    one loop of the cycle. Because the tortoise moves one step at a time, the total
    time is the length of the prefix + length of the loop. In terms of space, however,
    we no longer need any history at all; we only need the current positions of the
    tortoise and hare. Therefore, our time complexity is linear, but the space complexity
    is now significantly smaller: down to constant!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 21.6¬†Testing[üîó](#(part._.Testing) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While it might be tempting to write tests like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '(i.e., the same as before, but with `cc` replaced by `ph`), we should instead
    write them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This confers two advantages. First, if we change the example, we don‚Äôt have
    to update two tests, only one. But the much more important reason is that we intend
    for `pr` to be an optimized version of `cc`. That is, we expect the two to produce
    the same result. We can think of `cc` as our clear, reference implementation.
    That is, this is another instance of model-based testing.
  prefs: []
  type: TYPE_NORMAL
- en: As an aside, this algorithm is not exactly what Pyret does, because we need
    to check for arbitrary graph-ness, not just cycles. It‚Äôs also complicated due
    to user-defined functions, etc.
  prefs: []
  type: TYPE_NORMAL
