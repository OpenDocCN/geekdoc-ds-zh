["```py\nsection\nvariable  {α  :  Type*}  [DecidableEq  α]  (a  :  α)  (s  t  :  Finset  α)\n\n#check  a  ∈  s\n#check  s  ∩  t\n\nend \n```", "```py\nopen  Finset\n\nvariable  (a  b  c  :  Finset  ℕ)\nvariable  (n  :  ℕ)\n\n#check  a  ∩  b\n#check  a  ∪  b\n#check  a  \\  b\n#check  (∅  :  Finset  ℕ)\n\nexample  :  a  ∩  (b  ∪  c)  =  (a  ∩  b)  ∪  (a  ∩  c)  :=  by\n  ext  x;  simp  only  [mem_inter,  mem_union];  tauto\n\nexample  :  a  ∩  (b  ∪  c)  =  (a  ∩  b)  ∪  (a  ∩  c)  :=  by  rw  [inter_union_distrib_left] \n```", "```py\n#check  ({0,  2,  5}  :  Finset  Nat)\n\ndef  example1  :  Finset  ℕ  :=  {0,  1,  2} \n```", "```py\nexample  :  ({0,  1,  2}  :  Finset  ℕ)  =  {1,  2,  0}  :=  by  decide\n\nexample  :  ({0,  1,  2}  :  Finset  ℕ)  =  {0,  1,  1,  2}  :=  by  decide\n\nexample  :  ({0,  1}  :  Finset  ℕ)  =  {1,  0}  :=  by  rw  [Finset.pair_comm]\n\nexample  (x  :  Nat)  :  ({x,  x}  :  Finset  ℕ)  =  {x}  :=  by  simp\n\nexample  (x  y  z  :  Nat)  :  ({x,  y,  z,  y,  z,  x}  :  Finset  ℕ)  =  {x,  y,  z}  :=  by\n  ext  i;  simp  [or_comm,  or_assoc,  or_left_comm]\n\nexample  (x  y  z  :  Nat)  :  ({x,  y,  z,  y,  z,  x}  :  Finset  ℕ)  =  {x,  y,  z}  :=  by\n  ext  i;  simp;  tauto \n```", "```py\nexample  (s  :  Finset  ℕ)  (a  :  ℕ)  (h  :  a  ∉  s)  :  (insert  a  s  |>.erase  a)  =  s  :=\n  Finset.erase_insert  h\n\nexample  (s  :  Finset  ℕ)  (a  :  ℕ)  (h  :  a  ∈  s)  :  insert  a  (s.erase  a)  =  s  :=\n  Finset.insert_erase  h \n```", "```py\nset_option  pp.notation  false  in\n#check  ({0,  1,  2}  :  Finset  ℕ) \n```", "```py\nexample  :  {m  ∈  range  n  |  Even  m}  =  (range  n).filter  Even  :=  rfl\nexample  :  {m  ∈  range  n  |  Even  m  ∧  m  ≠  3}  =  (range  n).filter  (fun  m  ↦  Even  m  ∧  m  ≠  3)  :=  rfl\n\nexample  :  {m  ∈  range  10  |  Even  m}  =  {0,  2,  4,  6,  8}  :=  by  decide \n```", "```py\n#check  (range  5).image  (fun  x  ↦  x  *  2)\n\nexample  :  (range  5).image  (fun  x  ↦  x  *  2)  =  {x  ∈  range  10  |  Even  x}  :=  by  decide \n```", "```py\n#check  s  ×ˢ  t\n#check  s.powerset \n```", "```py\n#check  Finset.fold\n\ndef  f  (n  :  ℕ)  :  Int  :=  (↑n)^2\n\n#check  (range  5).fold  (fun  x  y  :  Int  ↦  x  +  y)  0  f\n#eval  (range  5).fold  (fun  x  y  :  Int  ↦  x  +  y)  0  f\n\n#check  ∑  i  ∈  range  5,  i^2\n#check  ∏  i  ∈  range  5,  i  +  1\n\nvariable  (g  :  Nat  →  Finset  Int)\n\n#check  (range  5).biUnion  g \n```", "```py\n#check  Finset.induction\n\nexample  {α  :  Type*}  [DecidableEq  α]  (f  :  α  →  ℕ)  (s  :  Finset  α)  (h  :  ∀  x  ∈  s,  f  x  ≠  0)  :\n  ∏  x  ∈  s,  f  x  ≠  0  :=  by\n  induction  s  using  Finset.induction_on  with\n  |  empty  =>  simp\n  |  @insert  a  s  anins  ih  =>\n  rw  [prod_insert  anins]\n  apply  mul_ne_zero\n  ·  apply  h;  apply  mem_insert_self\n  apply  ih\n  intros  x  xs\n  exact  h  x  (mem_insert_of_mem  xs) \n```", "```py\nnoncomputable  example  (s  :  Finset  ℕ)  (h  :  s.Nonempty)  :  ℕ  :=  Classical.choose  h\n\nexample  (s  :  Finset  ℕ)  (h  :  s.Nonempty)  :  Classical.choose  h  ∈  s  :=  Classical.choose_spec  h\n\nnoncomputable  example  (s  :  Finset  ℕ)  :  List  ℕ  :=  s.toList\n\nexample  (s  :  Finset  ℕ)  (a  :  ℕ)  :  a  ∈  s.toList  ↔  a  ∈  s  :=  mem_toList \n```", "```py\n#check  Finset.min\n#check  Finset.min'\n#check  Finset.max\n#check  Finset.max'\n#check  Finset.inf\n#check  Finset.inf'\n#check  Finset.sup\n#check  Finset.sup'\n\nexample  :  Finset.Nonempty  {2,  6,  7}  :=  ⟨6,  by  trivial⟩\nexample  :  Finset.min'  {2,  6,  7}  ⟨6,  by  trivial⟩  =  2  :=  by  trivial \n```", "```py\n#check  Finset.card\n\n#eval  (range  5).card\n\nexample  (s  :  Finset  ℕ)  :  s.card  =  #s  :=  by  rfl\n\nexample  (s  :  Finset  ℕ)  :  s.card  =  ∑  i  ∈  s,  1  :=  by  rw  [card_eq_sum_ones]\n\nexample  (s  :  Finset  ℕ)  :  s.card  =  ∑  i  ∈  s,  1  :=  by  simp \n```", "```py\nvariable  {α  :  Type*}  [Fintype  α]\n\nexample  :  ∀  x  :  α,  x  ∈  Finset.univ  :=  by\n  intro  x;  exact  mem_univ  x \n```", "```py\nexample  :  Fintype.card  α  =  (Finset.univ  :  Finset  α).card  :=  rfl \n```", "```py\nexample  :  Fintype.card  (Fin  5)  =  5  :=  by  simp\nexample  :  Fintype.card  ((Fin  5)  ×  (Fin  3))  =  15  :=  by  simp \n```", "```py\nvariable  (s  :  Finset  ℕ)\n\nexample  :  (↑s  :  Type)  =  {x  :  ℕ  //  x  ∈  s}  :=  rfl\nexample  :  Fintype.card  ↑s  =  s.card  :=  by  simp \n```", "```py\nopen  Finset\n\nvariable  {α  β  :  Type*}  [DecidableEq  α]  [DecidableEq  β]  (s  t  :  Finset  α)  (f  :  α  →  β)\n\nexample  :  #(s  ×ˢ  t)  =  #s  *  #t  :=  by  rw  [card_product]\nexample  :  #(s  ×ˢ  t)  =  #s  *  #t  :=  by  simp\n\nexample  :  #(s  ∪  t)  =  #s  +  #t  -  #(s  ∩  t)  :=  by  rw  [card_union]\n\nexample  (h  :  Disjoint  s  t)  :  #(s  ∪  t)  =  #s  +  #t  :=  by  rw  [card_union_of_disjoint  h]\nexample  (h  :  Disjoint  s  t)  :  #(s  ∪  t)  =  #s  +  #t  :=  by  simp  [h]\n\nexample  (h  :  Function.Injective  f)  :  #(s.image  f)  =  #s  :=  by  rw  [card_image_of_injective  _  h]\n\nexample  (h  :  Set.InjOn  f  s)  :  #(s.image  f)  =  #s  :=  by  rw  [card_image_of_injOn  h] \n```", "```py\nopen  Fintype\n\nvariable  {α  β  :  Type*}  [Fintype  α]  [Fintype  β]\n\nexample  :  card  (α  ×  β)  =  card  α  *  card  β  :=  by  simp\n\nexample  :  card  (α  ⊕  β)  =  card  α  +  card  β  :=  by  simp\n\nexample  (n  :  ℕ)  :  card  (Fin  n  →  α)  =  (card  α)^n  :=  by  simp\n\nvariable  {n  :  ℕ}  {γ  :  Fin  n  →  Type*}  [∀  i,  Fintype  (γ  i)]\n\nexample  :  card  ((i  :  Fin  n)  →  γ  i)  =  ∏  i,  card  (γ  i)  :=  by  simp\n\nexample  :  card  (Σ  i,  γ  i)  =  ∑  i,  card  (γ  i)  :=  by  simp \n```", "```py\n#check  Disjoint\n\nexample  (m  n  :  ℕ)  (h  :  m  ≥  n)  :\n  card  (range  n  ∪  (range  n).image  (fun  i  ↦  m  +  i))  =  2  *  n  :=  by\n  rw  [card_union_of_disjoint,  card_range,  card_image_of_injective,  card_range];  omega\n  .  apply  add_right_injective\n  .  simp  [disjoint_iff_ne];  omega \n```", "```py\ndef  triangle  (n  :  ℕ)  :  Finset  (ℕ  ×  ℕ)  :=  {p  ∈  range  (n+1)  ×ˢ  range  (n+1)  |  p.1  <  p.2}\n\nexample  (n  :  ℕ)  :  #(triangle  n)  =  (n  +  1)  *  n  /  2  :=  by\n  have  :  triangle  n  =  (range  (n+1)).biUnion  (fun  j  ↦  (range  j).image  (.,  j))  :=  by\n  ext  p\n  simp  only  [triangle,  mem_filter,  mem_product,  mem_range,  mem_biUnion,  mem_image]\n  constructor\n  .  rintro  ⟨⟨hp1,  hp2⟩,  hp3⟩\n  use  p.2,  hp2,  p.1,  hp3\n  .  rintro  ⟨p1,  hp1,  p2,  hp2,  rfl⟩\n  omega\n  rw  [this,  card_biUnion];  swap\n  ·  -- take care of disjointness first\n  intro  x  _  y  _  xney\n  simp  [disjoint_iff_ne,  xney]\n  -- continue the calculation\n  transitivity  (∑  i  ∈  range  (n  +  1),  i)\n  ·  congr;  ext  i\n  rw  [card_image_of_injective,  card_range]\n  intros  i1  i2;  simp\n  rw  [sum_range_id];  rfl \n```", "```py\nexample  (n  :  ℕ)  :  #(triangle  n)  =  (n  +  1)  *  n  /  2  :=  by\n  have  :  triangle  n  ≃  Σ  i  :  Fin  (n  +  1),  Fin  i.val  :=\n  {  toFun  :=  by\n  rintro  ⟨⟨i,  j⟩,  hp⟩\n  simp  [triangle]  at  hp\n  exact  ⟨⟨j,  hp.1.2⟩,  ⟨i,  hp.2⟩⟩\n  invFun  :=  by\n  rintro  ⟨i,  j⟩\n  use  ⟨j,  i⟩\n  simp  [triangle]\n  exact  j.isLt.trans  i.isLt\n  left_inv  :=  by  intro  i;  rfl\n  right_inv  :=  by  intro  i;  rfl  }\n  rw  [←Fintype.card_coe]\n  trans;  apply  (Fintype.card_congr  this)\n  rw  [Fintype.card_sigma,  sum_fin_eq_sum_range]\n  convert  Finset.sum_range_id  (n  +  1)\n  simp_all \n```", "```py\nexample  (n  :  ℕ)  :  #(triangle  n)  =  (n  +  1)  *  n  /  2  :=  by\n  apply  Nat.eq_div_of_mul_eq_right  (by  norm_num)\n  let  turn  (p  :  ℕ  ×  ℕ)  :  ℕ  ×  ℕ  :=  (n  -  1  -  p.1,  n  -  p.2)\n  calc  2  *  #(triangle  n)\n  =  #(triangle  n)  +  #(triangle  n)  :=  by\n  sorry\n  _  =  #(triangle  n)  +  #(triangle  n  |>.image  turn)  :=  by\n  sorry\n  _  =  #(range  n  ×ˢ  range  (n  +  1))  :=  by\n  sorry\n  _  =  (n  +  1)  *  n  :=  by\n  sorry \n```", "```py\ndef  triangle'  (n  :  ℕ)  :  Finset  (ℕ  ×  ℕ)  :=  {p  ∈  range  n  ×ˢ  range  n  |  p.1  ≤  p.2}\n\nexample  (n  :  ℕ)  :  #(triangle'  n)  =  #(triangle  n)  :=  by  sorry \n```", "```py\nopen  Classical\nvariable  (s  t  :  Finset  Nat)  (a  b  :  Nat)\n\ntheorem  doubleCounting  {α  β  :  Type*}  (s  :  Finset  α)  (t  :  Finset  β)\n  (r  :  α  →  β  →  Prop)\n  (h_left  :  ∀  a  ∈  s,  3  ≤  #{b  ∈  t  |  r  a  b})\n  (h_right  :  ∀  b  ∈  t,  #{a  ∈  s  |  r  a  b}  ≤  1)  :\n  3  *  #(s)  ≤  #(t)  :=  by\n  calc  3  *  #(s)\n  =  ∑  a  ∈  s,  3  :=  by  simp  [sum_const_nat,  mul_comm]\n  _  ≤  ∑  a  ∈  s,  #({b  ∈  t  |  r  a  b})  :=  sum_le_sum  h_left\n  _  =  ∑  a  ∈  s,  ∑  b  ∈  t,  if  r  a  b  then  1  else  0  :=  by  simp\n  _  =  ∑  b  ∈  t,  ∑  a  ∈  s,  if  r  a  b  then  1  else  0  :=  sum_comm\n  _  =  ∑  b  ∈  t,  #({a  ∈  s  |  r  a  b})  :=  by  simp\n  _  ≤  ∑  b  ∈  t,  1  :=  sum_le_sum  h_right\n  _  ≤  #(t)  :=  by  simp \n```", "```py\nexample  (m  k  :  ℕ)  (h  :  m  ≠  k)  (h'  :  m  /  2  =  k  /  2)  :  m  =  k  +  1  ∨  k  =  m  +  1  :=  by  omega \n```", "```py\nexample  {n  :  ℕ}  (A  :  Finset  ℕ)\n  (hA  :  #(A)  =  n  +  1)\n  (hA'  :  A  ⊆  range  (2  *  n))  :\n  ∃  m  ∈  A,  ∃  k  ∈  A,  Nat.Coprime  m  k  :=  by\n  have  :  ∃  t  ∈  range  n,  1  <  #({u  ∈  A  |  u  /  2  =  t})  :=  by\n  apply  exists_lt_card_fiber_of_mul_lt_card_of_maps_to\n  ·  sorry\n  ·  sorry\n  rcases  this  with  ⟨t,  ht,  ht'⟩\n  simp  only  [one_lt_card,  mem_filter]  at  ht'\n  sorry \n```", "```py\nnamespace  MyListSpace\n\ninductive  List  (α  :  Type*)  where\n  |  nil  :  List  α\n  |  cons  :  α  →  List  α  →  List  α\n\nend  MyListSpace \n```", "```py\ndef  append  {α  :  Type*}  :  List  α  →  List  α  →  List  α\n  |  [],  bs  =>  bs\n  |  a  ::  as,  bs  =>  a  ::  (append  as  bs)\n\ndef  map  {α  β  :  Type*}  (f  :  α  →  β)  :  List  α  →  List  β\n  |  []  =>  []\n  |  a  ::  as  =>  f  a  ::  map  f  as\n\n#eval  append  [1,  2,  3]  [4,  5,  6]\n#eval  map  (fun  n  =>  n^2)  [1,  2,  3,  4,  5] \n```", "```py\ntheorem  nil_append  {α  :  Type*}  (as  :  List  α)  :  append  []  as  =  as  :=  rfl\n\ntheorem  cons_append  {α  :  Type*}  (a  :  α)  (as  :  List  α)  (bs  :  List  α)  :\n  append  (a  ::  as)  bs  =  a  ::  (append  as  bs)  :=  rfl\n\ntheorem  map_nil  {α  β  :  Type*}  (f  :  α  →  β)  :  map  f  []  =  []  :=  rfl\n\ntheorem  map_cons  {α  β  :  Type*}  (f  :  α  →  β)  (a  :  α)  (as  :  List  α)  :\n  map  f  (a  ::  as)  =  f  a  ::  map  f  as  :=  rfl \n```", "```py\nvariable  {α  β  γ  :  Type*}\nvariable  (as  bs  cs  :  List  α)\nvariable  (a  b  c  :  α)\n\nopen  List\n\ntheorem  append_nil  :  ∀  as  :  List  α,  as  ++  []  =  as\n  |  []  =>  rfl\n  |  a  ::  as  =>  by  rw  [cons_append,  append_nil  as]\n\ntheorem  map_map  (f  :  α  →  β)  (g  :  β  →  γ)  :\n  ∀  as  :  List  α,  map  g  (map  f  as)  =  map  (g  ∘  f)  as\n  |  []  =>  rfl\n  |  a  ::  as  =>  by  rw  [map_cons,  map_cons,  map_cons,  map_map  f  g  as];  rfl \n```", "```py\ndef  reverse  :  List  α  →  List  α  :=  sorry\n\ntheorem  reverse_append  (as  bs  :  List  α)  :  reverse  (as  ++  bs)  =  reverse  bs  ++  reverse  as  :=  by\n  sorry\n\ntheorem  reverse_reverse  (as  :  List  α)  :  reverse  (reverse  as)  =  as  :=  by  sorry \n```", "```py\ninductive  BinTree  where\n  |  empty  :  BinTree\n  |  node  :  BinTree  →  BinTree  →  BinTree\n\nnamespace  BinTree\n\ndef  size  :  BinTree  →  ℕ\n  |  empty  =>  0\n  |  node  l  r  =>  size  l  +  size  r  +  1\n\ndef  depth  :  BinTree  →  ℕ\n  |  empty  =>  0\n  |  node  l  r  =>  max  (depth  l)  (depth  r)  +  1 \n```", "```py\ntheorem  size_le  :  ∀  t  :  BinTree,  size  t  ≤  2^depth  t  -  1\n  |  empty  =>  Nat.zero_le  _\n  |  node  l  r  =>  by\n  simp  only  [depth,  size]\n  calc  l.size  +  r.size  +  1\n  ≤  (2^l.depth  -  1)  +  (2^r.depth  -  1)  +  1  :=  by\n  gcongr  <;>  apply  size_le\n  _  ≤  (2  ^  max  l.depth  r.depth  -  1)  +  (2  ^  max  l.depth  r.depth  -  1)  +  1  :=  by\n  gcongr  <;>  simp\n  _  ≤  2  ^  (max  l.depth  r.depth  +  1)  -  1  :=  by\n  have  :  0  <  2  ^  max  l.depth  r.depth  :=  by  simp\n  omega \n```", "```py\ntheorem  depth_le_size  :  ∀  t  :  BinTree,  depth  t  ≤  size  t  :=  by  sorry \n```", "```py\ndef  flip  :  BinTree  →  BinTree  :=  sorry \n```", "```py\nexample:  flip  (node  (node  empty  (node  empty  empty))  (node  empty  empty))  =\n  node  (node  empty  empty)  (node  (node  empty  empty)  empty)  :=  sorry \n```", "```py\ntheorem  size_flip  :  ∀  t,  size  (flip  t)  =  size  t  :=  by  sorry \n```", "```py\ninductive  PropForm  :  Type  where\n  |  var  (n  :  ℕ)  :  PropForm\n  |  fls  :  PropForm\n  |  conj  (A  B  :  PropForm)  :  PropForm\n  |  disj  (A  B  :  PropForm)  :  PropForm\n  |  impl  (A  B  :  PropForm)  :  PropForm \n```", "```py\ndef  eval  :  PropForm  →  (ℕ  →  Bool)  →  Bool\n  |  var  n,  v  =>  v  n\n  |  fls,  _  =>  false\n  |  conj  A  B,  v  =>  A.eval  v  &&  B.eval  v\n  |  disj  A  B,  v  =>  A.eval  v  ||  B.eval  v\n  |  impl  A  B,  v  =>  !  A.eval  v  ||  B.eval  v \n```", "```py\ndef  vars  :  PropForm  →  Finset  ℕ\n  |  var  n  =>  {n}\n  |  fls  =>  ∅\n  |  conj  A  B  =>  A.vars  ∪  B.vars\n  |  disj  A  B  =>  A.vars  ∪  B.vars\n  |  impl  A  B  =>  A.vars  ∪  B.vars\n\ntheorem  eval_eq_eval  :  ∀  (A  :  PropForm)  (v1  v2  :  ℕ  →  Bool),\n  (∀  n  ∈  A.vars,  v1  n  =  v2  n)  →  A.eval  v1  =  A.eval  v2\n  |  var  n,  v1,  v2,  h  =>  by  simp_all  [vars,  eval,  h]\n  |  fls,  v1,  v2,  h  =>  by  simp_all  [eval]\n  |  conj  A  B,  v1,  v2,  h  =>  by\n  simp_all  [vars,  eval,  eval_eq_eval  A  v1  v2,  eval_eq_eval  B  v1  v2]\n  |  disj  A  B,  v1,  v2,  h  =>  by\n  simp_all  [vars,  eval,  eval_eq_eval  A  v1  v2,  eval_eq_eval  B  v1  v2]\n  |  impl  A  B,  v1,  v2,  h  =>  by\n  simp_all  [vars,  eval,  eval_eq_eval  A  v1  v2,  eval_eq_eval  B  v1  v2] \n```", "```py\ntheorem  eval_eq_eval'  (A  :  PropForm)  (v1  v2  :  ℕ  →  Bool)  (h  :  ∀  n  ∈  A.vars,  v1  n  =  v2  n)  :\n  A.eval  v1  =  A.eval  v2  :=  by\n  cases  A  <;>  simp_all  [eval,  vars,  fun  A  =>  eval_eq_eval'  A  v1  v2] \n```", "```py\ndef  subst  :  PropForm  →  ℕ  →  PropForm  →  PropForm\n  |  var  n,  m,  C  =>  if  n  =  m  then  C  else  var  n\n  |  fls,  _,  _  =>  fls\n  |  conj  A  B,  m,  C  =>  conj  (A.subst  m  C)  (B.subst  m  C)\n  |  disj  A  B,  m,  C  =>  disj  (A.subst  m  C)  (B.subst  m  C)\n  |  impl  A  B,  m,  C  =>  impl  (A.subst  m  C)  (B.subst  m  C) \n```", "```py\ntheorem  subst_eq_of_not_mem_vars  :\n  ∀  (A  :  PropForm)  (n  :  ℕ)  (C  :  PropForm),  n  ∉  A.vars  →  A.subst  n  C  =  A  :=  sorry \n```", "```py\ntheorem  subst_eval_eq  :  ∀  (A  :  PropForm)  (n  :  ℕ)  (C  :  PropForm)  (v  :  ℕ  →  Bool),\n  (A.subst  n  C).eval  v  =  A.eval  (fun  m  =>  if  m  =  n  then  C.eval  v  else  v  m)  :=  sorry \n```", "```py\nsection\nvariable  {α  :  Type*}  [DecidableEq  α]  (a  :  α)  (s  t  :  Finset  α)\n\n#check  a  ∈  s\n#check  s  ∩  t\n\nend \n```", "```py\nopen  Finset\n\nvariable  (a  b  c  :  Finset  ℕ)\nvariable  (n  :  ℕ)\n\n#check  a  ∩  b\n#check  a  ∪  b\n#check  a  \\  b\n#check  (∅  :  Finset  ℕ)\n\nexample  :  a  ∩  (b  ∪  c)  =  (a  ∩  b)  ∪  (a  ∩  c)  :=  by\n  ext  x;  simp  only  [mem_inter,  mem_union];  tauto\n\nexample  :  a  ∩  (b  ∪  c)  =  (a  ∩  b)  ∪  (a  ∩  c)  :=  by  rw  [inter_union_distrib_left] \n```", "```py\n#check  ({0,  2,  5}  :  Finset  Nat)\n\ndef  example1  :  Finset  ℕ  :=  {0,  1,  2} \n```", "```py\nexample  :  ({0,  1,  2}  :  Finset  ℕ)  =  {1,  2,  0}  :=  by  decide\n\nexample  :  ({0,  1,  2}  :  Finset  ℕ)  =  {0,  1,  1,  2}  :=  by  decide\n\nexample  :  ({0,  1}  :  Finset  ℕ)  =  {1,  0}  :=  by  rw  [Finset.pair_comm]\n\nexample  (x  :  Nat)  :  ({x,  x}  :  Finset  ℕ)  =  {x}  :=  by  simp\n\nexample  (x  y  z  :  Nat)  :  ({x,  y,  z,  y,  z,  x}  :  Finset  ℕ)  =  {x,  y,  z}  :=  by\n  ext  i;  simp  [or_comm,  or_assoc,  or_left_comm]\n\nexample  (x  y  z  :  Nat)  :  ({x,  y,  z,  y,  z,  x}  :  Finset  ℕ)  =  {x,  y,  z}  :=  by\n  ext  i;  simp;  tauto \n```", "```py\nexample  (s  :  Finset  ℕ)  (a  :  ℕ)  (h  :  a  ∉  s)  :  (insert  a  s  |>.erase  a)  =  s  :=\n  Finset.erase_insert  h\n\nexample  (s  :  Finset  ℕ)  (a  :  ℕ)  (h  :  a  ∈  s)  :  insert  a  (s.erase  a)  =  s  :=\n  Finset.insert_erase  h \n```", "```py\nset_option  pp.notation  false  in\n#check  ({0,  1,  2}  :  Finset  ℕ) \n```", "```py\nexample  :  {m  ∈  range  n  |  Even  m}  =  (range  n).filter  Even  :=  rfl\nexample  :  {m  ∈  range  n  |  Even  m  ∧  m  ≠  3}  =  (range  n).filter  (fun  m  ↦  Even  m  ∧  m  ≠  3)  :=  rfl\n\nexample  :  {m  ∈  range  10  |  Even  m}  =  {0,  2,  4,  6,  8}  :=  by  decide \n```", "```py\n#check  (range  5).image  (fun  x  ↦  x  *  2)\n\nexample  :  (range  5).image  (fun  x  ↦  x  *  2)  =  {x  ∈  range  10  |  Even  x}  :=  by  decide \n```", "```py\n#check  s  ×ˢ  t\n#check  s.powerset \n```", "```py\n#check  Finset.fold\n\ndef  f  (n  :  ℕ)  :  Int  :=  (↑n)^2\n\n#check  (range  5).fold  (fun  x  y  :  Int  ↦  x  +  y)  0  f\n#eval  (range  5).fold  (fun  x  y  :  Int  ↦  x  +  y)  0  f\n\n#check  ∑  i  ∈  range  5,  i^2\n#check  ∏  i  ∈  range  5,  i  +  1\n\nvariable  (g  :  Nat  →  Finset  Int)\n\n#check  (range  5).biUnion  g \n```", "```py\n#check  Finset.induction\n\nexample  {α  :  Type*}  [DecidableEq  α]  (f  :  α  →  ℕ)  (s  :  Finset  α)  (h  :  ∀  x  ∈  s,  f  x  ≠  0)  :\n  ∏  x  ∈  s,  f  x  ≠  0  :=  by\n  induction  s  using  Finset.induction_on  with\n  |  empty  =>  simp\n  |  @insert  a  s  anins  ih  =>\n  rw  [prod_insert  anins]\n  apply  mul_ne_zero\n  ·  apply  h;  apply  mem_insert_self\n  apply  ih\n  intros  x  xs\n  exact  h  x  (mem_insert_of_mem  xs) \n```", "```py\nnoncomputable  example  (s  :  Finset  ℕ)  (h  :  s.Nonempty)  :  ℕ  :=  Classical.choose  h\n\nexample  (s  :  Finset  ℕ)  (h  :  s.Nonempty)  :  Classical.choose  h  ∈  s  :=  Classical.choose_spec  h\n\nnoncomputable  example  (s  :  Finset  ℕ)  :  List  ℕ  :=  s.toList\n\nexample  (s  :  Finset  ℕ)  (a  :  ℕ)  :  a  ∈  s.toList  ↔  a  ∈  s  :=  mem_toList \n```", "```py\n#check  Finset.min\n#check  Finset.min'\n#check  Finset.max\n#check  Finset.max'\n#check  Finset.inf\n#check  Finset.inf'\n#check  Finset.sup\n#check  Finset.sup'\n\nexample  :  Finset.Nonempty  {2,  6,  7}  :=  ⟨6,  by  trivial⟩\nexample  :  Finset.min'  {2,  6,  7}  ⟨6,  by  trivial⟩  =  2  :=  by  trivial \n```", "```py\n#check  Finset.card\n\n#eval  (range  5).card\n\nexample  (s  :  Finset  ℕ)  :  s.card  =  #s  :=  by  rfl\n\nexample  (s  :  Finset  ℕ)  :  s.card  =  ∑  i  ∈  s,  1  :=  by  rw  [card_eq_sum_ones]\n\nexample  (s  :  Finset  ℕ)  :  s.card  =  ∑  i  ∈  s,  1  :=  by  simp \n```", "```py\nvariable  {α  :  Type*}  [Fintype  α]\n\nexample  :  ∀  x  :  α,  x  ∈  Finset.univ  :=  by\n  intro  x;  exact  mem_univ  x \n```", "```py\nexample  :  Fintype.card  α  =  (Finset.univ  :  Finset  α).card  :=  rfl \n```", "```py\nexample  :  Fintype.card  (Fin  5)  =  5  :=  by  simp\nexample  :  Fintype.card  ((Fin  5)  ×  (Fin  3))  =  15  :=  by  simp \n```", "```py\nvariable  (s  :  Finset  ℕ)\n\nexample  :  (↑s  :  Type)  =  {x  :  ℕ  //  x  ∈  s}  :=  rfl\nexample  :  Fintype.card  ↑s  =  s.card  :=  by  simp \n```", "```py\nopen  Finset\n\nvariable  {α  β  :  Type*}  [DecidableEq  α]  [DecidableEq  β]  (s  t  :  Finset  α)  (f  :  α  →  β)\n\nexample  :  #(s  ×ˢ  t)  =  #s  *  #t  :=  by  rw  [card_product]\nexample  :  #(s  ×ˢ  t)  =  #s  *  #t  :=  by  simp\n\nexample  :  #(s  ∪  t)  =  #s  +  #t  -  #(s  ∩  t)  :=  by  rw  [card_union]\n\nexample  (h  :  Disjoint  s  t)  :  #(s  ∪  t)  =  #s  +  #t  :=  by  rw  [card_union_of_disjoint  h]\nexample  (h  :  Disjoint  s  t)  :  #(s  ∪  t)  =  #s  +  #t  :=  by  simp  [h]\n\nexample  (h  :  Function.Injective  f)  :  #(s.image  f)  =  #s  :=  by  rw  [card_image_of_injective  _  h]\n\nexample  (h  :  Set.InjOn  f  s)  :  #(s.image  f)  =  #s  :=  by  rw  [card_image_of_injOn  h] \n```", "```py\nopen  Fintype\n\nvariable  {α  β  :  Type*}  [Fintype  α]  [Fintype  β]\n\nexample  :  card  (α  ×  β)  =  card  α  *  card  β  :=  by  simp\n\nexample  :  card  (α  ⊕  β)  =  card  α  +  card  β  :=  by  simp\n\nexample  (n  :  ℕ)  :  card  (Fin  n  →  α)  =  (card  α)^n  :=  by  simp\n\nvariable  {n  :  ℕ}  {γ  :  Fin  n  →  Type*}  [∀  i,  Fintype  (γ  i)]\n\nexample  :  card  ((i  :  Fin  n)  →  γ  i)  =  ∏  i,  card  (γ  i)  :=  by  simp\n\nexample  :  card  (Σ  i,  γ  i)  =  ∑  i,  card  (γ  i)  :=  by  simp \n```", "```py\n#check  Disjoint\n\nexample  (m  n  :  ℕ)  (h  :  m  ≥  n)  :\n  card  (range  n  ∪  (range  n).image  (fun  i  ↦  m  +  i))  =  2  *  n  :=  by\n  rw  [card_union_of_disjoint,  card_range,  card_image_of_injective,  card_range];  omega\n  .  apply  add_right_injective\n  .  simp  [disjoint_iff_ne];  omega \n```", "```py\ndef  triangle  (n  :  ℕ)  :  Finset  (ℕ  ×  ℕ)  :=  {p  ∈  range  (n+1)  ×ˢ  range  (n+1)  |  p.1  <  p.2}\n\nexample  (n  :  ℕ)  :  #(triangle  n)  =  (n  +  1)  *  n  /  2  :=  by\n  have  :  triangle  n  =  (range  (n+1)).biUnion  (fun  j  ↦  (range  j).image  (.,  j))  :=  by\n  ext  p\n  simp  only  [triangle,  mem_filter,  mem_product,  mem_range,  mem_biUnion,  mem_image]\n  constructor\n  .  rintro  ⟨⟨hp1,  hp2⟩,  hp3⟩\n  use  p.2,  hp2,  p.1,  hp3\n  .  rintro  ⟨p1,  hp1,  p2,  hp2,  rfl⟩\n  omega\n  rw  [this,  card_biUnion];  swap\n  ·  -- take care of disjointness first\n  intro  x  _  y  _  xney\n  simp  [disjoint_iff_ne,  xney]\n  -- continue the calculation\n  transitivity  (∑  i  ∈  range  (n  +  1),  i)\n  ·  congr;  ext  i\n  rw  [card_image_of_injective,  card_range]\n  intros  i1  i2;  simp\n  rw  [sum_range_id];  rfl \n```", "```py\nexample  (n  :  ℕ)  :  #(triangle  n)  =  (n  +  1)  *  n  /  2  :=  by\n  have  :  triangle  n  ≃  Σ  i  :  Fin  (n  +  1),  Fin  i.val  :=\n  {  toFun  :=  by\n  rintro  ⟨⟨i,  j⟩,  hp⟩\n  simp  [triangle]  at  hp\n  exact  ⟨⟨j,  hp.1.2⟩,  ⟨i,  hp.2⟩⟩\n  invFun  :=  by\n  rintro  ⟨i,  j⟩\n  use  ⟨j,  i⟩\n  simp  [triangle]\n  exact  j.isLt.trans  i.isLt\n  left_inv  :=  by  intro  i;  rfl\n  right_inv  :=  by  intro  i;  rfl  }\n  rw  [←Fintype.card_coe]\n  trans;  apply  (Fintype.card_congr  this)\n  rw  [Fintype.card_sigma,  sum_fin_eq_sum_range]\n  convert  Finset.sum_range_id  (n  +  1)\n  simp_all \n```", "```py\nexample  (n  :  ℕ)  :  #(triangle  n)  =  (n  +  1)  *  n  /  2  :=  by\n  apply  Nat.eq_div_of_mul_eq_right  (by  norm_num)\n  let  turn  (p  :  ℕ  ×  ℕ)  :  ℕ  ×  ℕ  :=  (n  -  1  -  p.1,  n  -  p.2)\n  calc  2  *  #(triangle  n)\n  =  #(triangle  n)  +  #(triangle  n)  :=  by\n  sorry\n  _  =  #(triangle  n)  +  #(triangle  n  |>.image  turn)  :=  by\n  sorry\n  _  =  #(range  n  ×ˢ  range  (n  +  1))  :=  by\n  sorry\n  _  =  (n  +  1)  *  n  :=  by\n  sorry \n```", "```py\ndef  triangle'  (n  :  ℕ)  :  Finset  (ℕ  ×  ℕ)  :=  {p  ∈  range  n  ×ˢ  range  n  |  p.1  ≤  p.2}\n\nexample  (n  :  ℕ)  :  #(triangle'  n)  =  #(triangle  n)  :=  by  sorry \n```", "```py\nopen  Classical\nvariable  (s  t  :  Finset  Nat)  (a  b  :  Nat)\n\ntheorem  doubleCounting  {α  β  :  Type*}  (s  :  Finset  α)  (t  :  Finset  β)\n  (r  :  α  →  β  →  Prop)\n  (h_left  :  ∀  a  ∈  s,  3  ≤  #{b  ∈  t  |  r  a  b})\n  (h_right  :  ∀  b  ∈  t,  #{a  ∈  s  |  r  a  b}  ≤  1)  :\n  3  *  #(s)  ≤  #(t)  :=  by\n  calc  3  *  #(s)\n  =  ∑  a  ∈  s,  3  :=  by  simp  [sum_const_nat,  mul_comm]\n  _  ≤  ∑  a  ∈  s,  #({b  ∈  t  |  r  a  b})  :=  sum_le_sum  h_left\n  _  =  ∑  a  ∈  s,  ∑  b  ∈  t,  if  r  a  b  then  1  else  0  :=  by  simp\n  _  =  ∑  b  ∈  t,  ∑  a  ∈  s,  if  r  a  b  then  1  else  0  :=  sum_comm\n  _  =  ∑  b  ∈  t,  #({a  ∈  s  |  r  a  b})  :=  by  simp\n  _  ≤  ∑  b  ∈  t,  1  :=  sum_le_sum  h_right\n  _  ≤  #(t)  :=  by  simp \n```", "```py\nexample  (m  k  :  ℕ)  (h  :  m  ≠  k)  (h'  :  m  /  2  =  k  /  2)  :  m  =  k  +  1  ∨  k  =  m  +  1  :=  by  omega \n```", "```py\nexample  {n  :  ℕ}  (A  :  Finset  ℕ)\n  (hA  :  #(A)  =  n  +  1)\n  (hA'  :  A  ⊆  range  (2  *  n))  :\n  ∃  m  ∈  A,  ∃  k  ∈  A,  Nat.Coprime  m  k  :=  by\n  have  :  ∃  t  ∈  range  n,  1  <  #({u  ∈  A  |  u  /  2  =  t})  :=  by\n  apply  exists_lt_card_fiber_of_mul_lt_card_of_maps_to\n  ·  sorry\n  ·  sorry\n  rcases  this  with  ⟨t,  ht,  ht'⟩\n  simp  only  [one_lt_card,  mem_filter]  at  ht'\n  sorry \n```", "```py\nnamespace  MyListSpace\n\ninductive  List  (α  :  Type*)  where\n  |  nil  :  List  α\n  |  cons  :  α  →  List  α  →  List  α\n\nend  MyListSpace \n```", "```py\ndef  append  {α  :  Type*}  :  List  α  →  List  α  →  List  α\n  |  [],  bs  =>  bs\n  |  a  ::  as,  bs  =>  a  ::  (append  as  bs)\n\ndef  map  {α  β  :  Type*}  (f  :  α  →  β)  :  List  α  →  List  β\n  |  []  =>  []\n  |  a  ::  as  =>  f  a  ::  map  f  as\n\n#eval  append  [1,  2,  3]  [4,  5,  6]\n#eval  map  (fun  n  =>  n^2)  [1,  2,  3,  4,  5] \n```", "```py\ntheorem  nil_append  {α  :  Type*}  (as  :  List  α)  :  append  []  as  =  as  :=  rfl\n\ntheorem  cons_append  {α  :  Type*}  (a  :  α)  (as  :  List  α)  (bs  :  List  α)  :\n  append  (a  ::  as)  bs  =  a  ::  (append  as  bs)  :=  rfl\n\ntheorem  map_nil  {α  β  :  Type*}  (f  :  α  →  β)  :  map  f  []  =  []  :=  rfl\n\ntheorem  map_cons  {α  β  :  Type*}  (f  :  α  →  β)  (a  :  α)  (as  :  List  α)  :\n  map  f  (a  ::  as)  =  f  a  ::  map  f  as  :=  rfl \n```", "```py\nvariable  {α  β  γ  :  Type*}\nvariable  (as  bs  cs  :  List  α)\nvariable  (a  b  c  :  α)\n\nopen  List\n\ntheorem  append_nil  :  ∀  as  :  List  α,  as  ++  []  =  as\n  |  []  =>  rfl\n  |  a  ::  as  =>  by  rw  [cons_append,  append_nil  as]\n\ntheorem  map_map  (f  :  α  →  β)  (g  :  β  →  γ)  :\n  ∀  as  :  List  α,  map  g  (map  f  as)  =  map  (g  ∘  f)  as\n  |  []  =>  rfl\n  |  a  ::  as  =>  by  rw  [map_cons,  map_cons,  map_cons,  map_map  f  g  as];  rfl \n```", "```py\ndef  reverse  :  List  α  →  List  α  :=  sorry\n\ntheorem  reverse_append  (as  bs  :  List  α)  :  reverse  (as  ++  bs)  =  reverse  bs  ++  reverse  as  :=  by\n  sorry\n\ntheorem  reverse_reverse  (as  :  List  α)  :  reverse  (reverse  as)  =  as  :=  by  sorry \n```", "```py\ninductive  BinTree  where\n  |  empty  :  BinTree\n  |  node  :  BinTree  →  BinTree  →  BinTree\n\nnamespace  BinTree\n\ndef  size  :  BinTree  →  ℕ\n  |  empty  =>  0\n  |  node  l  r  =>  size  l  +  size  r  +  1\n\ndef  depth  :  BinTree  →  ℕ\n  |  empty  =>  0\n  |  node  l  r  =>  max  (depth  l)  (depth  r)  +  1 \n```", "```py\ntheorem  size_le  :  ∀  t  :  BinTree,  size  t  ≤  2^depth  t  -  1\n  |  empty  =>  Nat.zero_le  _\n  |  node  l  r  =>  by\n  simp  only  [depth,  size]\n  calc  l.size  +  r.size  +  1\n  ≤  (2^l.depth  -  1)  +  (2^r.depth  -  1)  +  1  :=  by\n  gcongr  <;>  apply  size_le\n  _  ≤  (2  ^  max  l.depth  r.depth  -  1)  +  (2  ^  max  l.depth  r.depth  -  1)  +  1  :=  by\n  gcongr  <;>  simp\n  _  ≤  2  ^  (max  l.depth  r.depth  +  1)  -  1  :=  by\n  have  :  0  <  2  ^  max  l.depth  r.depth  :=  by  simp\n  omega \n```", "```py\ntheorem  depth_le_size  :  ∀  t  :  BinTree,  depth  t  ≤  size  t  :=  by  sorry \n```", "```py\ndef  flip  :  BinTree  →  BinTree  :=  sorry \n```", "```py\nexample:  flip  (node  (node  empty  (node  empty  empty))  (node  empty  empty))  =\n  node  (node  empty  empty)  (node  (node  empty  empty)  empty)  :=  sorry \n```", "```py\ntheorem  size_flip  :  ∀  t,  size  (flip  t)  =  size  t  :=  by  sorry \n```", "```py\ninductive  PropForm  :  Type  where\n  |  var  (n  :  ℕ)  :  PropForm\n  |  fls  :  PropForm\n  |  conj  (A  B  :  PropForm)  :  PropForm\n  |  disj  (A  B  :  PropForm)  :  PropForm\n  |  impl  (A  B  :  PropForm)  :  PropForm \n```", "```py\ndef  eval  :  PropForm  →  (ℕ  →  Bool)  →  Bool\n  |  var  n,  v  =>  v  n\n  |  fls,  _  =>  false\n  |  conj  A  B,  v  =>  A.eval  v  &&  B.eval  v\n  |  disj  A  B,  v  =>  A.eval  v  ||  B.eval  v\n  |  impl  A  B,  v  =>  !  A.eval  v  ||  B.eval  v \n```", "```py\ndef  vars  :  PropForm  →  Finset  ℕ\n  |  var  n  =>  {n}\n  |  fls  =>  ∅\n  |  conj  A  B  =>  A.vars  ∪  B.vars\n  |  disj  A  B  =>  A.vars  ∪  B.vars\n  |  impl  A  B  =>  A.vars  ∪  B.vars\n\ntheorem  eval_eq_eval  :  ∀  (A  :  PropForm)  (v1  v2  :  ℕ  →  Bool),\n  (∀  n  ∈  A.vars,  v1  n  =  v2  n)  →  A.eval  v1  =  A.eval  v2\n  |  var  n,  v1,  v2,  h  =>  by  simp_all  [vars,  eval,  h]\n  |  fls,  v1,  v2,  h  =>  by  simp_all  [eval]\n  |  conj  A  B,  v1,  v2,  h  =>  by\n  simp_all  [vars,  eval,  eval_eq_eval  A  v1  v2,  eval_eq_eval  B  v1  v2]\n  |  disj  A  B,  v1,  v2,  h  =>  by\n  simp_all  [vars,  eval,  eval_eq_eval  A  v1  v2,  eval_eq_eval  B  v1  v2]\n  |  impl  A  B,  v1,  v2,  h  =>  by\n  simp_all  [vars,  eval,  eval_eq_eval  A  v1  v2,  eval_eq_eval  B  v1  v2] \n```", "```py\ntheorem  eval_eq_eval'  (A  :  PropForm)  (v1  v2  :  ℕ  →  Bool)  (h  :  ∀  n  ∈  A.vars,  v1  n  =  v2  n)  :\n  A.eval  v1  =  A.eval  v2  :=  by\n  cases  A  <;>  simp_all  [eval,  vars,  fun  A  =>  eval_eq_eval'  A  v1  v2] \n```", "```py\ndef  subst  :  PropForm  →  ℕ  →  PropForm  →  PropForm\n  |  var  n,  m,  C  =>  if  n  =  m  then  C  else  var  n\n  |  fls,  _,  _  =>  fls\n  |  conj  A  B,  m,  C  =>  conj  (A.subst  m  C)  (B.subst  m  C)\n  |  disj  A  B,  m,  C  =>  disj  (A.subst  m  C)  (B.subst  m  C)\n  |  impl  A  B,  m,  C  =>  impl  (A.subst  m  C)  (B.subst  m  C) \n```", "```py\ntheorem  subst_eq_of_not_mem_vars  :\n  ∀  (A  :  PropForm)  (n  :  ℕ)  (C  :  PropForm),  n  ∉  A.vars  →  A.subst  n  C  =  A  :=  sorry \n```", "```py\ntheorem  subst_eval_eq  :  ∀  (A  :  PropForm)  (n  :  ℕ)  (C  :  PropForm)  (v  :  ℕ  →  Bool),\n  (A.subst  n  C).eval  v  =  A.eval  (fun  m  =>  if  m  =  n  then  C.eval  v  else  v  m)  :=  sorry \n```", "```py\nsection\nvariable  {α  :  Type*}  [DecidableEq  α]  (a  :  α)  (s  t  :  Finset  α)\n\n#check  a  ∈  s\n#check  s  ∩  t\n\nend \n```", "```py\nopen  Finset\n\nvariable  (a  b  c  :  Finset  ℕ)\nvariable  (n  :  ℕ)\n\n#check  a  ∩  b\n#check  a  ∪  b\n#check  a  \\  b\n#check  (∅  :  Finset  ℕ)\n\nexample  :  a  ∩  (b  ∪  c)  =  (a  ∩  b)  ∪  (a  ∩  c)  :=  by\n  ext  x;  simp  only  [mem_inter,  mem_union];  tauto\n\nexample  :  a  ∩  (b  ∪  c)  =  (a  ∩  b)  ∪  (a  ∩  c)  :=  by  rw  [inter_union_distrib_left] \n```", "```py\n#check  ({0,  2,  5}  :  Finset  Nat)\n\ndef  example1  :  Finset  ℕ  :=  {0,  1,  2} \n```", "```py\nexample  :  ({0,  1,  2}  :  Finset  ℕ)  =  {1,  2,  0}  :=  by  decide\n\nexample  :  ({0,  1,  2}  :  Finset  ℕ)  =  {0,  1,  1,  2}  :=  by  decide\n\nexample  :  ({0,  1}  :  Finset  ℕ)  =  {1,  0}  :=  by  rw  [Finset.pair_comm]\n\nexample  (x  :  Nat)  :  ({x,  x}  :  Finset  ℕ)  =  {x}  :=  by  simp\n\nexample  (x  y  z  :  Nat)  :  ({x,  y,  z,  y,  z,  x}  :  Finset  ℕ)  =  {x,  y,  z}  :=  by\n  ext  i;  simp  [or_comm,  or_assoc,  or_left_comm]\n\nexample  (x  y  z  :  Nat)  :  ({x,  y,  z,  y,  z,  x}  :  Finset  ℕ)  =  {x,  y,  z}  :=  by\n  ext  i;  simp;  tauto \n```", "```py\nexample  (s  :  Finset  ℕ)  (a  :  ℕ)  (h  :  a  ∉  s)  :  (insert  a  s  |>.erase  a)  =  s  :=\n  Finset.erase_insert  h\n\nexample  (s  :  Finset  ℕ)  (a  :  ℕ)  (h  :  a  ∈  s)  :  insert  a  (s.erase  a)  =  s  :=\n  Finset.insert_erase  h \n```", "```py\nset_option  pp.notation  false  in\n#check  ({0,  1,  2}  :  Finset  ℕ) \n```", "```py\nexample  :  {m  ∈  range  n  |  Even  m}  =  (range  n).filter  Even  :=  rfl\nexample  :  {m  ∈  range  n  |  Even  m  ∧  m  ≠  3}  =  (range  n).filter  (fun  m  ↦  Even  m  ∧  m  ≠  3)  :=  rfl\n\nexample  :  {m  ∈  range  10  |  Even  m}  =  {0,  2,  4,  6,  8}  :=  by  decide \n```", "```py\n#check  (range  5).image  (fun  x  ↦  x  *  2)\n\nexample  :  (range  5).image  (fun  x  ↦  x  *  2)  =  {x  ∈  range  10  |  Even  x}  :=  by  decide \n```", "```py\n#check  s  ×ˢ  t\n#check  s.powerset \n```", "```py\n#check  Finset.fold\n\ndef  f  (n  :  ℕ)  :  Int  :=  (↑n)^2\n\n#check  (range  5).fold  (fun  x  y  :  Int  ↦  x  +  y)  0  f\n#eval  (range  5).fold  (fun  x  y  :  Int  ↦  x  +  y)  0  f\n\n#check  ∑  i  ∈  range  5,  i^2\n#check  ∏  i  ∈  range  5,  i  +  1\n\nvariable  (g  :  Nat  →  Finset  Int)\n\n#check  (range  5).biUnion  g \n```", "```py\n#check  Finset.induction\n\nexample  {α  :  Type*}  [DecidableEq  α]  (f  :  α  →  ℕ)  (s  :  Finset  α)  (h  :  ∀  x  ∈  s,  f  x  ≠  0)  :\n  ∏  x  ∈  s,  f  x  ≠  0  :=  by\n  induction  s  using  Finset.induction_on  with\n  |  empty  =>  simp\n  |  @insert  a  s  anins  ih  =>\n  rw  [prod_insert  anins]\n  apply  mul_ne_zero\n  ·  apply  h;  apply  mem_insert_self\n  apply  ih\n  intros  x  xs\n  exact  h  x  (mem_insert_of_mem  xs) \n```", "```py\nnoncomputable  example  (s  :  Finset  ℕ)  (h  :  s.Nonempty)  :  ℕ  :=  Classical.choose  h\n\nexample  (s  :  Finset  ℕ)  (h  :  s.Nonempty)  :  Classical.choose  h  ∈  s  :=  Classical.choose_spec  h\n\nnoncomputable  example  (s  :  Finset  ℕ)  :  List  ℕ  :=  s.toList\n\nexample  (s  :  Finset  ℕ)  (a  :  ℕ)  :  a  ∈  s.toList  ↔  a  ∈  s  :=  mem_toList \n```", "```py\n#check  Finset.min\n#check  Finset.min'\n#check  Finset.max\n#check  Finset.max'\n#check  Finset.inf\n#check  Finset.inf'\n#check  Finset.sup\n#check  Finset.sup'\n\nexample  :  Finset.Nonempty  {2,  6,  7}  :=  ⟨6,  by  trivial⟩\nexample  :  Finset.min'  {2,  6,  7}  ⟨6,  by  trivial⟩  =  2  :=  by  trivial \n```", "```py\n#check  Finset.card\n\n#eval  (range  5).card\n\nexample  (s  :  Finset  ℕ)  :  s.card  =  #s  :=  by  rfl\n\nexample  (s  :  Finset  ℕ)  :  s.card  =  ∑  i  ∈  s,  1  :=  by  rw  [card_eq_sum_ones]\n\nexample  (s  :  Finset  ℕ)  :  s.card  =  ∑  i  ∈  s,  1  :=  by  simp \n```", "```py\nvariable  {α  :  Type*}  [Fintype  α]\n\nexample  :  ∀  x  :  α,  x  ∈  Finset.univ  :=  by\n  intro  x;  exact  mem_univ  x \n```", "```py\nexample  :  Fintype.card  α  =  (Finset.univ  :  Finset  α).card  :=  rfl \n```", "```py\nexample  :  Fintype.card  (Fin  5)  =  5  :=  by  simp\nexample  :  Fintype.card  ((Fin  5)  ×  (Fin  3))  =  15  :=  by  simp \n```", "```py\nvariable  (s  :  Finset  ℕ)\n\nexample  :  (↑s  :  Type)  =  {x  :  ℕ  //  x  ∈  s}  :=  rfl\nexample  :  Fintype.card  ↑s  =  s.card  :=  by  simp \n```", "```py\nopen  Finset\n\nvariable  {α  β  :  Type*}  [DecidableEq  α]  [DecidableEq  β]  (s  t  :  Finset  α)  (f  :  α  →  β)\n\nexample  :  #(s  ×ˢ  t)  =  #s  *  #t  :=  by  rw  [card_product]\nexample  :  #(s  ×ˢ  t)  =  #s  *  #t  :=  by  simp\n\nexample  :  #(s  ∪  t)  =  #s  +  #t  -  #(s  ∩  t)  :=  by  rw  [card_union]\n\nexample  (h  :  Disjoint  s  t)  :  #(s  ∪  t)  =  #s  +  #t  :=  by  rw  [card_union_of_disjoint  h]\nexample  (h  :  Disjoint  s  t)  :  #(s  ∪  t)  =  #s  +  #t  :=  by  simp  [h]\n\nexample  (h  :  Function.Injective  f)  :  #(s.image  f)  =  #s  :=  by  rw  [card_image_of_injective  _  h]\n\nexample  (h  :  Set.InjOn  f  s)  :  #(s.image  f)  =  #s  :=  by  rw  [card_image_of_injOn  h] \n```", "```py\nopen  Fintype\n\nvariable  {α  β  :  Type*}  [Fintype  α]  [Fintype  β]\n\nexample  :  card  (α  ×  β)  =  card  α  *  card  β  :=  by  simp\n\nexample  :  card  (α  ⊕  β)  =  card  α  +  card  β  :=  by  simp\n\nexample  (n  :  ℕ)  :  card  (Fin  n  →  α)  =  (card  α)^n  :=  by  simp\n\nvariable  {n  :  ℕ}  {γ  :  Fin  n  →  Type*}  [∀  i,  Fintype  (γ  i)]\n\nexample  :  card  ((i  :  Fin  n)  →  γ  i)  =  ∏  i,  card  (γ  i)  :=  by  simp\n\nexample  :  card  (Σ  i,  γ  i)  =  ∑  i,  card  (γ  i)  :=  by  simp \n```", "```py\n#check  Disjoint\n\nexample  (m  n  :  ℕ)  (h  :  m  ≥  n)  :\n  card  (range  n  ∪  (range  n).image  (fun  i  ↦  m  +  i))  =  2  *  n  :=  by\n  rw  [card_union_of_disjoint,  card_range,  card_image_of_injective,  card_range];  omega\n  .  apply  add_right_injective\n  .  simp  [disjoint_iff_ne];  omega \n```", "```py\ndef  triangle  (n  :  ℕ)  :  Finset  (ℕ  ×  ℕ)  :=  {p  ∈  range  (n+1)  ×ˢ  range  (n+1)  |  p.1  <  p.2}\n\nexample  (n  :  ℕ)  :  #(triangle  n)  =  (n  +  1)  *  n  /  2  :=  by\n  have  :  triangle  n  =  (range  (n+1)).biUnion  (fun  j  ↦  (range  j).image  (.,  j))  :=  by\n  ext  p\n  simp  only  [triangle,  mem_filter,  mem_product,  mem_range,  mem_biUnion,  mem_image]\n  constructor\n  .  rintro  ⟨⟨hp1,  hp2⟩,  hp3⟩\n  use  p.2,  hp2,  p.1,  hp3\n  .  rintro  ⟨p1,  hp1,  p2,  hp2,  rfl⟩\n  omega\n  rw  [this,  card_biUnion];  swap\n  ·  -- take care of disjointness first\n  intro  x  _  y  _  xney\n  simp  [disjoint_iff_ne,  xney]\n  -- continue the calculation\n  transitivity  (∑  i  ∈  range  (n  +  1),  i)\n  ·  congr;  ext  i\n  rw  [card_image_of_injective,  card_range]\n  intros  i1  i2;  simp\n  rw  [sum_range_id];  rfl \n```", "```py\nexample  (n  :  ℕ)  :  #(triangle  n)  =  (n  +  1)  *  n  /  2  :=  by\n  have  :  triangle  n  ≃  Σ  i  :  Fin  (n  +  1),  Fin  i.val  :=\n  {  toFun  :=  by\n  rintro  ⟨⟨i,  j⟩,  hp⟩\n  simp  [triangle]  at  hp\n  exact  ⟨⟨j,  hp.1.2⟩,  ⟨i,  hp.2⟩⟩\n  invFun  :=  by\n  rintro  ⟨i,  j⟩\n  use  ⟨j,  i⟩\n  simp  [triangle]\n  exact  j.isLt.trans  i.isLt\n  left_inv  :=  by  intro  i;  rfl\n  right_inv  :=  by  intro  i;  rfl  }\n  rw  [←Fintype.card_coe]\n  trans;  apply  (Fintype.card_congr  this)\n  rw  [Fintype.card_sigma,  sum_fin_eq_sum_range]\n  convert  Finset.sum_range_id  (n  +  1)\n  simp_all \n```", "```py\nexample  (n  :  ℕ)  :  #(triangle  n)  =  (n  +  1)  *  n  /  2  :=  by\n  apply  Nat.eq_div_of_mul_eq_right  (by  norm_num)\n  let  turn  (p  :  ℕ  ×  ℕ)  :  ℕ  ×  ℕ  :=  (n  -  1  -  p.1,  n  -  p.2)\n  calc  2  *  #(triangle  n)\n  =  #(triangle  n)  +  #(triangle  n)  :=  by\n  sorry\n  _  =  #(triangle  n)  +  #(triangle  n  |>.image  turn)  :=  by\n  sorry\n  _  =  #(range  n  ×ˢ  range  (n  +  1))  :=  by\n  sorry\n  _  =  (n  +  1)  *  n  :=  by\n  sorry \n```", "```py\ndef  triangle'  (n  :  ℕ)  :  Finset  (ℕ  ×  ℕ)  :=  {p  ∈  range  n  ×ˢ  range  n  |  p.1  ≤  p.2}\n\nexample  (n  :  ℕ)  :  #(triangle'  n)  =  #(triangle  n)  :=  by  sorry \n```", "```py\nopen  Classical\nvariable  (s  t  :  Finset  Nat)  (a  b  :  Nat)\n\ntheorem  doubleCounting  {α  β  :  Type*}  (s  :  Finset  α)  (t  :  Finset  β)\n  (r  :  α  →  β  →  Prop)\n  (h_left  :  ∀  a  ∈  s,  3  ≤  #{b  ∈  t  |  r  a  b})\n  (h_right  :  ∀  b  ∈  t,  #{a  ∈  s  |  r  a  b}  ≤  1)  :\n  3  *  #(s)  ≤  #(t)  :=  by\n  calc  3  *  #(s)\n  =  ∑  a  ∈  s,  3  :=  by  simp  [sum_const_nat,  mul_comm]\n  _  ≤  ∑  a  ∈  s,  #({b  ∈  t  |  r  a  b})  :=  sum_le_sum  h_left\n  _  =  ∑  a  ∈  s,  ∑  b  ∈  t,  if  r  a  b  then  1  else  0  :=  by  simp\n  _  =  ∑  b  ∈  t,  ∑  a  ∈  s,  if  r  a  b  then  1  else  0  :=  sum_comm\n  _  =  ∑  b  ∈  t,  #({a  ∈  s  |  r  a  b})  :=  by  simp\n  _  ≤  ∑  b  ∈  t,  1  :=  sum_le_sum  h_right\n  _  ≤  #(t)  :=  by  simp \n```", "```py\nexample  (m  k  :  ℕ)  (h  :  m  ≠  k)  (h'  :  m  /  2  =  k  /  2)  :  m  =  k  +  1  ∨  k  =  m  +  1  :=  by  omega \n```", "```py\nexample  {n  :  ℕ}  (A  :  Finset  ℕ)\n  (hA  :  #(A)  =  n  +  1)\n  (hA'  :  A  ⊆  range  (2  *  n))  :\n  ∃  m  ∈  A,  ∃  k  ∈  A,  Nat.Coprime  m  k  :=  by\n  have  :  ∃  t  ∈  range  n,  1  <  #({u  ∈  A  |  u  /  2  =  t})  :=  by\n  apply  exists_lt_card_fiber_of_mul_lt_card_of_maps_to\n  ·  sorry\n  ·  sorry\n  rcases  this  with  ⟨t,  ht,  ht'⟩\n  simp  only  [one_lt_card,  mem_filter]  at  ht'\n  sorry \n```", "```py\nnamespace  MyListSpace\n\ninductive  List  (α  :  Type*)  where\n  |  nil  :  List  α\n  |  cons  :  α  →  List  α  →  List  α\n\nend  MyListSpace \n```", "```py\ndef  append  {α  :  Type*}  :  List  α  →  List  α  →  List  α\n  |  [],  bs  =>  bs\n  |  a  ::  as,  bs  =>  a  ::  (append  as  bs)\n\ndef  map  {α  β  :  Type*}  (f  :  α  →  β)  :  List  α  →  List  β\n  |  []  =>  []\n  |  a  ::  as  =>  f  a  ::  map  f  as\n\n#eval  append  [1,  2,  3]  [4,  5,  6]\n#eval  map  (fun  n  =>  n^2)  [1,  2,  3,  4,  5] \n```", "```py\ntheorem  nil_append  {α  :  Type*}  (as  :  List  α)  :  append  []  as  =  as  :=  rfl\n\ntheorem  cons_append  {α  :  Type*}  (a  :  α)  (as  :  List  α)  (bs  :  List  α)  :\n  append  (a  ::  as)  bs  =  a  ::  (append  as  bs)  :=  rfl\n\ntheorem  map_nil  {α  β  :  Type*}  (f  :  α  →  β)  :  map  f  []  =  []  :=  rfl\n\ntheorem  map_cons  {α  β  :  Type*}  (f  :  α  →  β)  (a  :  α)  (as  :  List  α)  :\n  map  f  (a  ::  as)  =  f  a  ::  map  f  as  :=  rfl \n```", "```py\nvariable  {α  β  γ  :  Type*}\nvariable  (as  bs  cs  :  List  α)\nvariable  (a  b  c  :  α)\n\nopen  List\n\ntheorem  append_nil  :  ∀  as  :  List  α,  as  ++  []  =  as\n  |  []  =>  rfl\n  |  a  ::  as  =>  by  rw  [cons_append,  append_nil  as]\n\ntheorem  map_map  (f  :  α  →  β)  (g  :  β  →  γ)  :\n  ∀  as  :  List  α,  map  g  (map  f  as)  =  map  (g  ∘  f)  as\n  |  []  =>  rfl\n  |  a  ::  as  =>  by  rw  [map_cons,  map_cons,  map_cons,  map_map  f  g  as];  rfl \n```", "```py\ndef  reverse  :  List  α  →  List  α  :=  sorry\n\ntheorem  reverse_append  (as  bs  :  List  α)  :  reverse  (as  ++  bs)  =  reverse  bs  ++  reverse  as  :=  by\n  sorry\n\ntheorem  reverse_reverse  (as  :  List  α)  :  reverse  (reverse  as)  =  as  :=  by  sorry \n```", "```py\ninductive  BinTree  where\n  |  empty  :  BinTree\n  |  node  :  BinTree  →  BinTree  →  BinTree\n\nnamespace  BinTree\n\ndef  size  :  BinTree  →  ℕ\n  |  empty  =>  0\n  |  node  l  r  =>  size  l  +  size  r  +  1\n\ndef  depth  :  BinTree  →  ℕ\n  |  empty  =>  0\n  |  node  l  r  =>  max  (depth  l)  (depth  r)  +  1 \n```", "```py\ntheorem  size_le  :  ∀  t  :  BinTree,  size  t  ≤  2^depth  t  -  1\n  |  empty  =>  Nat.zero_le  _\n  |  node  l  r  =>  by\n  simp  only  [depth,  size]\n  calc  l.size  +  r.size  +  1\n  ≤  (2^l.depth  -  1)  +  (2^r.depth  -  1)  +  1  :=  by\n  gcongr  <;>  apply  size_le\n  _  ≤  (2  ^  max  l.depth  r.depth  -  1)  +  (2  ^  max  l.depth  r.depth  -  1)  +  1  :=  by\n  gcongr  <;>  simp\n  _  ≤  2  ^  (max  l.depth  r.depth  +  1)  -  1  :=  by\n  have  :  0  <  2  ^  max  l.depth  r.depth  :=  by  simp\n  omega \n```", "```py\ntheorem  depth_le_size  :  ∀  t  :  BinTree,  depth  t  ≤  size  t  :=  by  sorry \n```", "```py\ndef  flip  :  BinTree  →  BinTree  :=  sorry \n```", "```py\nexample:  flip  (node  (node  empty  (node  empty  empty))  (node  empty  empty))  =\n  node  (node  empty  empty)  (node  (node  empty  empty)  empty)  :=  sorry \n```", "```py\ntheorem  size_flip  :  ∀  t,  size  (flip  t)  =  size  t  :=  by  sorry \n```", "```py\ninductive  PropForm  :  Type  where\n  |  var  (n  :  ℕ)  :  PropForm\n  |  fls  :  PropForm\n  |  conj  (A  B  :  PropForm)  :  PropForm\n  |  disj  (A  B  :  PropForm)  :  PropForm\n  |  impl  (A  B  :  PropForm)  :  PropForm \n```", "```py\ndef  eval  :  PropForm  →  (ℕ  →  Bool)  →  Bool\n  |  var  n,  v  =>  v  n\n  |  fls,  _  =>  false\n  |  conj  A  B,  v  =>  A.eval  v  &&  B.eval  v\n  |  disj  A  B,  v  =>  A.eval  v  ||  B.eval  v\n  |  impl  A  B,  v  =>  !  A.eval  v  ||  B.eval  v \n```", "```py\ndef  vars  :  PropForm  →  Finset  ℕ\n  |  var  n  =>  {n}\n  |  fls  =>  ∅\n  |  conj  A  B  =>  A.vars  ∪  B.vars\n  |  disj  A  B  =>  A.vars  ∪  B.vars\n  |  impl  A  B  =>  A.vars  ∪  B.vars\n\ntheorem  eval_eq_eval  :  ∀  (A  :  PropForm)  (v1  v2  :  ℕ  →  Bool),\n  (∀  n  ∈  A.vars,  v1  n  =  v2  n)  →  A.eval  v1  =  A.eval  v2\n  |  var  n,  v1,  v2,  h  =>  by  simp_all  [vars,  eval,  h]\n  |  fls,  v1,  v2,  h  =>  by  simp_all  [eval]\n  |  conj  A  B,  v1,  v2,  h  =>  by\n  simp_all  [vars,  eval,  eval_eq_eval  A  v1  v2,  eval_eq_eval  B  v1  v2]\n  |  disj  A  B,  v1,  v2,  h  =>  by\n  simp_all  [vars,  eval,  eval_eq_eval  A  v1  v2,  eval_eq_eval  B  v1  v2]\n  |  impl  A  B,  v1,  v2,  h  =>  by\n  simp_all  [vars,  eval,  eval_eq_eval  A  v1  v2,  eval_eq_eval  B  v1  v2] \n```", "```py\ntheorem  eval_eq_eval'  (A  :  PropForm)  (v1  v2  :  ℕ  →  Bool)  (h  :  ∀  n  ∈  A.vars,  v1  n  =  v2  n)  :\n  A.eval  v1  =  A.eval  v2  :=  by\n  cases  A  <;>  simp_all  [eval,  vars,  fun  A  =>  eval_eq_eval'  A  v1  v2] \n```", "```py\ndef  subst  :  PropForm  →  ℕ  →  PropForm  →  PropForm\n  |  var  n,  m,  C  =>  if  n  =  m  then  C  else  var  n\n  |  fls,  _,  _  =>  fls\n  |  conj  A  B,  m,  C  =>  conj  (A.subst  m  C)  (B.subst  m  C)\n  |  disj  A  B,  m,  C  =>  disj  (A.subst  m  C)  (B.subst  m  C)\n  |  impl  A  B,  m,  C  =>  impl  (A.subst  m  C)  (B.subst  m  C) \n```", "```py\ntheorem  subst_eq_of_not_mem_vars  :\n  ∀  (A  :  PropForm)  (n  :  ℕ)  (C  :  PropForm),  n  ∉  A.vars  →  A.subst  n  C  =  A  :=  sorry \n```", "```py\ntheorem  subst_eval_eq  :  ∀  (A  :  PropForm)  (n  :  ℕ)  (C  :  PropForm)  (v  :  ℕ  →  Bool),\n  (A.subst  n  C).eval  v  =  A.eval  (fun  m  =>  if  m  =  n  then  C.eval  v  else  v  m)  :=  sorry \n```"]