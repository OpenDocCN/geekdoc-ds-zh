- en: 9\. Groups and Rings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://leanprover-community.github.io/mathematics_in_lean/C09_Groups_and_Rings.html](https://leanprover-community.github.io/mathematics_in_lean/C09_Groups_and_Rings.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*[Mathematics in Lean](index.html)* **   9\. Groups and Rings'
  prefs: []
  type: TYPE_NORMAL
- en: '[View page source](_sources/C09_Groups_and_Rings.rst.txt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: We saw in [Section 2.2](C02_Basics.html#proving-identities-in-algebraic-structures)
    how to reason about operations in groups and rings. Later, in [Section 7.2](C07_Structures.html#section-algebraic-structures),
    we saw how to define abstract algebraic structures, such as group structures,
    as well as concrete instances such as the ring structure on the Gaussian integers.
    [Chapter 8](C08_Hierarchies.html#hierarchies) explained how hierarchies of abstract
    structures are handled in Mathlib.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we work with groups and rings in more detail. We won’t be able
    to cover every aspect of the treatment of these topics in Mathlib, especially
    since Mathlib is constantly growing. But we will provide entry points to the library
    and show how the essential concepts are used. There is some overlap with the discussion
    of [Chapter 8](C08_Hierarchies.html#hierarchies), but here we will focus on how
    to use Mathlib instead of the design decisions behind the way the topics are treated.
    So making sense of some of the examples may require reviewing the background from
    [Chapter 8](C08_Hierarchies.html#hierarchies).
  prefs: []
  type: TYPE_NORMAL
- en: '## 9.1\. Monoids and Groups[](#monoids-and-groups "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: '### 9.1.1\. Monoids and their morphisms[](#monoids-and-their-morphisms "Link
    to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Courses in abstract algebra often start with groups and then progress to rings,
    fields, and vector spaces. This involves some contortions when discussing multiplication
    on rings since the multiplication operation does not come from a group structure
    but many of the proofs carry over verbatim from group theory to this new setting.
    The most common fix, when doing mathematics with pen and paper, is to leave those
    proofs as exercises. A less efficient but safer and more formalization-friendly
    way of proceeding is to use monoids. A *monoid* structure on a type M is an internal
    composition law that is associative and has a neutral element. Monoids are used
    primarily to accommodate both groups and the multiplicative structure of rings.
    But there are also a number of natural examples; for instance, the set of natural
    numbers equipped with addition forms a monoid.
  prefs: []
  type: TYPE_NORMAL
- en: From a practical point of view, you can mostly ignore monoids when using Mathlib.
    But you need to know they exist when you are looking for a lemma by browsing Mathlib
    files. Otherwise, you might end up looking for a statement in the group theory
    files when it is actually in the found with monoids because it does not require
    elements to be invertible.
  prefs: []
  type: TYPE_NORMAL
- en: The type of monoid structures on a type `M` is written `Monoid M`. The function
    `Monoid` is a type class so it will almost always appear as an instance implicit
    argument (in other words, in square brackets). By default, `Monoid` uses multiplicative
    notation for the operation; for additive notation use `AddMonoid` instead. The
    commutative versions of these structures add the prefix `Comm` before `Monoid`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that although `AddMonoid` is found in the library, it is generally confusing
    to use additive notation with a non-commutative operation.
  prefs: []
  type: TYPE_NORMAL
- en: The type of morphisms between monoids `M` and `N` is called `MonoidHom M N`
    and written `M →* N`. Lean will automatically see such a morphism as a function
    from `M` to `N` when we apply it to elements of `M`. The additive version is called
    `AddMonoidHom` and written `M →+ N`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These morphisms are bundled maps, i.e. they package together a map and some
    of its properties. Remember that [Section 8.2](C08_Hierarchies.html#section-hierarchies-morphisms)
    explains bundled maps; here we simply note the slightly unfortunate consequence
    that we cannot use ordinary function composition to compose maps. Instead, we
    need to use `MonoidHom.comp` and `AddMonoidHom.comp`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.2\. Groups and their morphisms[](#groups-and-their-morphisms "Link to this
    heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will have much more to say about groups, which are monoids with the extra
    property that every element has an inverse.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the `ring` tactic that we saw earlier, there is a `group` tactic
    that proves any identity that holds in any group. (Equivalently, it proves the
    identities that hold in free groups.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There is also a tactic for identities in commutative additive groups called
    `abel`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, a group morphism is nothing more than a monoid morphism between
    groups. So we can copy and paste one of our earlier examples, replacing `Monoid`
    with `Group`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course we do get some new properties, such as this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You may be worried that constructing group morphisms will require us to do unnecessary
    work since the definition of monoid morphism enforces that neutral elements are
    sent to neutral elements while this is automatic in the case of group morphisms.
    In practice the extra work is not hard, but, to avoid it, there is a function
    building a group morphism from a function between groups that is compatible with
    the composition laws.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a type `MulEquiv` of group (or monoid) isomorphisms denoted by
    `≃*` (and `AddEquiv` denoted by `≃+` in additive notation). The inverse of `f
    : G ≃* H` is `MulEquiv.symm f : H ≃* G`, composition of `f` and `g` is `MulEquiv.trans
    f g`, and the identity isomorphism of `G` is `M̀ulEquiv.refl G`. Using anonymous
    projector notation, the first two can be written `f.symm` and `f.trans g` respectively.
    Elements of this type are automatically coerced to morphisms and functions when
    necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: One can use `MulEquiv.ofBijective` to build an isomorphism from a bijective
    morphism. Doing so makes the inverse function noncomputable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.3\. Subgroups[](#subgroups "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as group morphisms are bundled, a subgroup of `G` is also a bundled structure
    consisting of a set in `G` with the relevant closure properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, it is important to understand that `Subgroup G` is the
    type of subgroups of `G`, rather than a predicate `IsSubgroup H` where `H` is
    an element of `Set G`. `Subgroup G` is endowed with a coercion to `Set G` and
    a membership predicate on `G`. See [Section 8.3](C08_Hierarchies.html#section-hierarchies-subobjects)
    for an explanation of how and why this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, two subgroups are the same if and only if they have the same elements.
    This fact is registered for use with the `ext` tactic, which can be used to prove
    two subgroups are equal in the same way it is used to prove that two sets are
    equal.
  prefs: []
  type: TYPE_NORMAL
- en: To state and prove, for example, that `ℤ` is an additive subgroup of `ℚ`, what
    we really want is to construct a term of type `AddSubgroup ℚ` whose projection
    to `Set ℚ` is `ℤ`, or, more precisely, the image of `ℤ` in `ℚ`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Using type classes, Mathlib knows that a subgroup of a group inherits a group
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is subtle. The object `H` is not a type, but Lean automatically
    coerces it to a type by interpreting it as a subtype of `G`. So the above example
    can be restated more explicitly as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'An important benefit of having a type `Subgroup G` instead of a predicate `IsSubgroup
    : Set G → Prop` is that one can easily endow `Subgroup G` with additional structure.
    Importantly, it has the structure of a complete lattice structure with respect
    to inclusion. For instance, instead of having a lemma stating that an intersection
    of two subgroups of `G` is again a subgroup, we have used the lattice operation
    `⊓` to construct the intersection. We can then apply arbitrary lemmas about lattices
    to the construction.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us check that the set underlying the infimum of two subgroups is indeed,
    by definition, their intersection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It may look strange to have a different notation for what amounts to the intersection
    of the underlying sets, but the correspondence does not carry over to the supremum
    operation and set union, since a union of subgroups is not, in general, a subgroup.
    Instead one needs to use the subgroup generated by the union, which is done using
    `Subgroup.closure`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Another subtlety is that `G` itself does not have type `Subgroup G`, so we
    need a way to talk about `G` seen as a subgroup of `G`. This is also provided
    by the lattice structure: the full subgroup is the top element of this lattice.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Similarly the bottom element of this lattice is the subgroup whose only element
    is the neutral element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As an exercise in manipulating groups and subgroups, you can define the conjugate
    of a subgroup by an element of the ambient group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Tying the previous two topics together, one can push forward and pull back subgroups
    using group morphisms. The naming convention in Mathlib is to call those operations
    `map` and `comap`. These are not the common mathematical terms, but they have
    the advantage of being shorter than “pushforward” and “direct image.”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In particular, the preimage of the bottom subgroup under a morphism `f` is a
    subgroup called the *kernel* of `f`, and the range of `f` is also a subgroup.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As exercises in manipulating group morphisms and subgroups, let us prove some
    elementary properties. They are already proved in Mathlib, so do not use `exact?`
    too quickly if you want to benefit from these exercises.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Let us finish this introduction to subgroups in Mathlib with two very classical
    results. Lagrange theorem states the cardinality of a subgroup of a finite group
    divides the cardinality of the group. Sylow’s first theorem is a famous partial
    converse to Lagrange’s theorem.
  prefs: []
  type: TYPE_NORMAL
- en: While this corner of Mathlib is partly set up to allow computation, we can tell
    Lean to use nonconstructive logic anyway using the following `open scoped` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The next two exercises derive a corollary of Lagrange’s lemma. (This is also
    already in Mathlib, so do not use `exact?` too quickly.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.4\. Concrete groups[](#concrete-groups "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One can also manipulate concrete groups in Mathlib, although this is typically
    more complicated than working with the abstract theory. For instance, given any
    type `X`, the group of permutations of `X` is `Equiv.Perm X`. In particular the
    symmetric group \(\mathfrak{S}_n\) is `Equiv.Perm (Fin n)`. One can state abstract
    results about this group, for instance saying that `Equiv.Perm X` is generated
    by cycles if `X` is finite.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'One can be fully concrete and compute actual products of cycles. Below we use
    the `#simp` command, which calls the `simp` tactic on a given expression. The
    notation `c[]` is used to define a cyclic permutation. In the example, the result
    is a permutation of `ℕ`. One could use a type ascription such as `(1 : Fin 5)`
    on the first number appearing to make it a computation in `Perm (Fin 5)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to work with concrete groups is to use free groups and group presentations.
    The free group on a type `α` is `FreeGroup α` and the inclusion map is `FreeGroup.of
    : α → FreeGroup α`. For instance let us define a type `S` with three elements
    denoted by `a`, `b` and `c`, and the element `ab⁻¹` of the corresponding free
    group.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that we gave the expected type of the definition so that Lean knows that
    `.of` means `FreeGroup.of`.
  prefs: []
  type: TYPE_NORMAL
- en: The universal property of free groups is embodied as the equivalence `FreeGroup.lift`.
    For example, let us define the group morphism from `FreeGroup S` to `Perm (Fin
    5)` that sends `a` to `c[1, 2, 3]`, `b` to `c[2, 3, 1]`, and `c` to `c[2, 3]`,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As a last concrete example, let us see how to define a group generated by a
    single element whose cube is one (so that group will be isomorphic to \(\mathbb{Z}/3\))
    and build a morphism from that group to `Perm (Fin 5)`.
  prefs: []
  type: TYPE_NORMAL
- en: As a type with exactly one element, we will use `Unit` whose only element is
    denoted by `()`. The function `PresentedGroup` takes a set of relations, i.e.
    a set of elements of some free group, and returns a group that is this free group
    quotiented by a normal subgroup generated by relations. (We will see how to handle
    more general quotients in [Section 9.1.6](#quotient-groups).) Since we somehow
    hide this behind a definition, we use `deriving Group` to force creation of a
    group instance on `myGroup`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The universal property of presented groups ensures that morphisms out of this
    group can be built from functions that send the relations to the neutral element
    of the target group. So we need such a function and a proof that the condition
    holds. Then we can feed this proof to `PresentedGroup.toGroup` to get the desired
    group morphism.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.5\. Group actions[](#group-actions "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One important way that group theory interacts with the rest of mathematics is
    through the use of group actions. An action of a group `G` on some type `X` is
    nothing more than a morphism from `G` to `Equiv.Perm X`. So in a sense group actions
    are already covered by the previous discussion. But we don’t want to carry this
    morphism around; instead, we want it to be inferred automatically by Lean as much
    as possible. So we have a type class for this, which is `MulAction G X`. The downside
    of this setup is that having multiple actions of the same group on the same type
    requires some contortions, such as defining type synonyms, each of which carries
    different type class instances.
  prefs: []
  type: TYPE_NORMAL
- en: This allows us in particular to use `g • x` to denote the action of a group
    element `g` on a point `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: There is also a version for additive group called `AddAction`, where the action
    is denoted by `+ᵥ`. This is used for instance in the definition of affine spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The underlying group morphism is called `MulAction.toPermHom`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As an illustration let us see how to define the Cayley isomorphism embedding
    of any group `G` into a permutation group, namely `Perm G`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note that nothing before the above definition required having a group rather
    than a monoid (or any type endowed with a multiplication operation really).
  prefs: []
  type: TYPE_NORMAL
- en: The group condition really enters the picture when we will want to partition
    `X` into orbits. The corresponding equivalence relation on `X` is called `MulAction.orbitRel`.
    It is not declared as a global instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this we can state that `X` is partitioned into orbits under the action
    of `G`. More precisely, we get a bijection between `X` and the dependent product
    `(ω : orbitRel.Quotient G X) × (orbit G (Quotient.out'' ω))` where `Quotient.out''
    ω` simply chooses an element that projects to `ω`. Recall that elements of this
    dependent product are pairs `⟨ω, x⟩` where the type `orbit G (Quotient.out'' ω)`
    of `x` depends on `ω`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In particular, when X is finite, this can be combined with `Fintype.card_congr`
    and `Fintype.card_sigma` to deduce that the cardinality of `X` is the sum of the
    cardinalities of the orbits. Furthermore, the orbits are in bijection with the
    quotient of `G` under the action of the stabilizers by left translation. This
    action of a subgroup by left-translation is used to define quotients of a group
    by a subgroup with notation / so we can use the following concise statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'An important special case of combining the above two results is when `X` is
    a group `G` equipped with the action of a subgroup `H` by translation. In this
    case all stabilizers are trivial so every orbit is in bijection with `H` and we
    get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This is the conceptual variant of the version of Lagrange theorem that we saw
    above. Note this version makes no finiteness assumption.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise for this section, let us build the action of a group on its subgroup
    by conjugation, using our definition of `conjugate` from a previous exercise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '### 9.1.6\. Quotient groups[](#quotient-groups "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: In the above discussion of subgroups acting on groups, we saw the quotient `G
    ⧸ H` appear. In general this is only a type. It can be endowed with a group structure
    such that the quotient map is a group morphism if and only if `H` is a normal
    subgroup (and this group structure is then unique).
  prefs: []
  type: TYPE_NORMAL
- en: The normality assumption is a type class `Subgroup.Normal` so that type class
    inference can use it to derive the group structure on the quotient.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The universal property of quotient groups is accessed through `QuotientGroup.lift`:
    a group morphism `φ` descends to `G ⧸ N` as soon as its kernel contains `N`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The fact that the target group is called `M` is the above snippet is a clue
    that having a monoid structure on `M` would be enough.
  prefs: []
  type: TYPE_NORMAL
- en: An important special case is when `N = ker φ`. In that case the descended morphism
    is injective and we get a group isomorphism onto its image. This result is often
    called the first isomorphism theorem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying the universal property to a composition of a morphism `φ : G →* G''`
    with a quotient group projection `Quotient.mk'' N''`, we can also aim for a morphism
    from `G ⧸ N` to `G'' ⧸ N''`. The condition required on `φ` is usually formulated
    by saying “`φ` should send `N` inside `N''`.” But this is equivalent to asking
    that `φ` should pull `N''` back over `N`, and the latter condition is nicer to
    work with since the definition of pullback does not involve an existential quantifier.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: One subtle point to keep in mind is that the type `G ⧸ N` really depends on
    `N` (up to definitional equality), so having a proof that two normal subgroups
    `N` and `M` are equal is not enough to make the corresponding quotients equal.
    However the universal properties does give an isomorphism in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As a final series of exercises for this section, we will prove that if `H` and
    `K` are disjoint normal subgroups of a finite group `G` such that the product
    of their cardinalities is equal to the cardinality of `G` then `G` is isomorphic
    to `H × K`. Recall that disjoint in this context means `H ⊓ K = ⊥`.
  prefs: []
  type: TYPE_NORMAL
- en: We start with playing a bit with Lagrange’s lemma, without assuming the subgroups
    are normal or disjoint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: From now on, we assume that our subgroups are normal and disjoint, and we assume
    the cardinality condition. Now we construct the first building block of the desired
    isomorphism.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now we can define our second building block. We will need `MonoidHom.prod`,
    which builds a morphism from `G₀` to `G₁ × G₂` out of morphisms from `G₀` to `G₁`
    and `G₂`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We are ready to put all pieces together.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]  ## 9.2\. Rings[](#rings "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: '### 9.2.1\. Rings, their units, morphisms and subrings[](#rings-their-units-morphisms-and-subrings
    "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: The type of ring structures on a type `R` is `Ring R`. The variant where multiplication
    is assumed to be commutative is `CommRing R`. We have already seen that the `ring`
    tactic will prove any equality that follows from the axioms of a commutative ring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: More exotic variants do not require that the addition on `R` forms a group but
    only an additive monoid. The corresponding type classes are `Semiring R` and `CommSemiring
    R`. The type of natural numbers is an important instance of `CommSemiring R`,
    as is any type of functions taking values in the natural numbers. Another important
    example is the type of ideals in a ring, which will be discussed below. The name
    of the `ring` tactic is doubly misleading, since it assumes commutativity but
    works in semirings as well. In other words, it applies to any `CommSemiring`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: There are also versions of the ring and semiring classes that do not assume
    the existence of a multiplicative unit or the associativity of multiplication.
    We will not discuss those here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some concepts that are traditionally taught in an introduction to ring theory
    are actually about the underlying multiplicative monoid. A prominent example is
    the definition of the units of a ring. Every (multiplicative) monoid `M` has a
    predicate `IsUnit : M → Prop` asserting existence of a two-sided inverse, a type
    `Units M` of units with notation `Mˣ`, and a coercion to `M`. The type `Units
    M` bundles an invertible element with its inverse as well as properties than ensure
    that each is indeed the inverse of the other. This implementation detail is relevant
    mainly when defining computable functions. In most situations one can use `IsUnit.unit
    {x : M} : IsUnit x → Mˣ` to build a unit. In the commutative case, one also has
    `Units.mkOfMulEqOne (x y : M) : x * y = 1 → Mˣ` which builds `x` seen as unit.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The type of ring morphisms between two (semi)-rings `R` and `S` is `RingHom
    R S`, with notation `R →+* S`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The isomorphism variant is `RingEquiv`, with notation `≃+*`.
  prefs: []
  type: TYPE_NORMAL
- en: As with submonoids and subgroups, there is a `Subring R` type for subrings of
    a ring `R`, but this type is a lot less useful than the type of subgroups since
    one cannot quotient a ring by a subring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Also notice that `RingHom.range` produces a subring.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.2\. Ideals and quotients[](#ideals-and-quotients "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For historical reasons, Mathlib only has a theory of ideals for commutative
    rings. (The ring library was originally developed to make quick progress toward
    the foundations of modern algebraic geometry.) So in this section we will work
    with commutative (semi)rings. Ideals of `R` are defined as submodules of `R` seen
    as `R`-modules. Modules will be covered later in a chapter on linear algebra,
    but this implementation detail can mostly be safely ignored since most (but not
    all) relevant lemmas are restated in the special context of ideals. But anonymous
    projection notation won’t always work as expected. For instance, one cannot replace
    `Ideal.Quotient.mk I` by `I.Quotient.mk` in the snippet below because there are
    two `.`s and so it will parse as `(Ideal.Quotient I).mk`; but `Ideal.Quotient`
    by itself doesn’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The universal property of quotient rings is `Ideal.Quotient.lift`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In particular it leads to the first isomorphism theorem for rings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Ideals form a complete lattice structure with the inclusion relation, as well
    as a semiring structure. These two structures interact nicely.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: One can use ring morphisms to push ideals forward and pull them back using `Ideal.map`
    and `Ideal.comap`, respectively. As usual, the latter is more convenient to use
    since it does not involve an existential quantifier. This explains why it is used
    to state the condition that allows us to build morphisms between quotient rings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: One subtle point is that the type `R ⧸ I` really depends on `I` (up to definitional
    equality), so having a proof that two ideals `I` and `J` are equal is not enough
    to make the corresponding quotients equal. However, the universal properties do
    provide an isomorphism in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We can now present the Chinese remainder isomorphism as an example. Pay attention
    to the difference between the indexed infimum symbol `⨅` and the big product of
    types symbol `Π`. Depending on your font, those can be pretty hard to distinguish.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The elementary version of the Chinese remainder theorem, a statement about
    `ZMod`, can be easily deduced from the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: As a series of exercises, we will reprove the Chinese remainder theorem in the
    general case.
  prefs: []
  type: TYPE_NORMAL
- en: We first need to define the map appearing in the theorem, as a ring morphism,
    using the universal property of quotient rings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the following next two lemmas can be proven by `rfl`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The next lemma proves the easy half of the Chinese remainder theorem, without
    any assumption on the family of ideals. The proof is less than one line long.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready for the heart of the theorem, which will show the surjectivity
    of our `chineseMap`. First we need to know the different ways one can express
    the coprimality (also called co-maximality assumption). Only the first two will
    be needed below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We take the opportunity to use induction on `Finset`. Relevant lemmas on `Finset`
    are given below. Remember that the `ring` tactic works for semirings and that
    the ideals of a ring form a semiring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: We can now prove surjectivity of the map appearing in the Chinese remainder
    theorem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all the pieces come together in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 9.2.3\. Algebras and polynomials[](#algebras-and-polynomials "Link to this
    heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Given a commutative (semi)ring `R`, an *algebra over* `R` is a semiring `A`
    equipped with a ring morphism whose image commutes with every element of `A`.
    This is encoded as a type class `Algebra R A`. The morphism from `R` to `A` is
    called the structure map and is denoted `algebraMap R A : R →+* A` in Lean. Multiplication
    of `a : A` by `algebraMap R A r` for some `r : R` is called the scalar multiplication
    of `a` by `r` and denoted by `r • a`. Note that this notion of algebra is sometimes
    called an *associative unital algebra* to emphasize the existence of more general
    notions of algebra.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that `algebraMap R A` is ring morphism packages together a lot of
    properties of scalar multiplication, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The morphisms between two `R`-algebras `A` and `B` are ring morphisms which
    commute with scalar multiplication by elements of `R`. They are bundled morphisms
    with type `AlgHom R A B`, which is denoted by `A →ₐ[R] B`.
  prefs: []
  type: TYPE_NORMAL
- en: Important examples of non-commutative algebras include algebras of endomorphisms
    and algebras of square matrices, both of which will be covered in the chapter
    on linear algebra. In this chapter we will discuss one of the most important examples
    of a commutative algebra, namely, polynomial algebras.
  prefs: []
  type: TYPE_NORMAL
- en: The algebra of univariate polynomials with coefficients in `R` is called `Polynomial
    R`, which can be written as `R[X]` as soon as one opens the `Polynomial` namespace.
    The algebra structure map from `R` to `R[X]` is denoted by `C`, which stands for
    “constant” since the corresponding polynomial functions are always constant. The
    indeterminate is denoted by `X`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In the first example above, it is crucial that we give Lean the expected type
    since it cannot be determined from the body of the definition. In the second example,
    the target polynomial algebra can be inferred from our use of `C r` since the
    type of `r` is known.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `C` is a ring morphism from `R` to `R[X]`, we can use all ring morphisms
    lemmas such as `map_zero`, `map_one`, `map_mul`, and `map_pow` before computing
    in the ring `R[X]`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: You can access coefficients using `Polynomial.coeff`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Defining the degree of a polynomial is always tricky because of the special
    case of the zero polynomial. Mathlib has two variants: `Polynomial.natDegree :
    R[X] → ℕ` assigns degree `0` to the zero polynomial, and `Polynomial.degree :
    R[X] → WithBot ℕ` assigns `⊥`. In the latter, `WithBot ℕ` can be seen as `ℕ ∪
    {-∞}`, except that `-∞` is denoted `⊥`, the same symbol as the bottom element
    in a complete lattice. This special value is used as the degree of the zero polynomial,
    and it is absorbent for addition. (It is almost absorbent for multiplication,
    except that `⊥ * 0 = 0`.)'
  prefs: []
  type: TYPE_NORMAL
- en: Morally speaking, the `degree` version is the correct one. For instance, it
    allows us to state the expected formula for the degree of a product (assuming
    the base ring has no zero divisor).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Whereas the version for `natDegree` needs to assume non-zero polynomials.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `ℕ` is much nicer to use than `WithBot ℕ`, so Mathlib makes both versions
    available and provides lemmas to convert between them. Also, `natDegree` is the
    more convenient definition to use when computing the degree of a composition.
    Composition of polynomial is `Polynomial.comp` and we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Polynomials give rise to polynomial functions: any polynomial can be evaluated
    on `R` using `Polynomial.eval`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: In particular, there is a predicate, `IsRoot`, that holds for elements `r` in
    `R` where a polynomial vanishes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: We would like to say that, assuming `R` has no zero divisor, a polynomial has
    at most as many roots as its degree, where the roots are counted with multiplicities.
    But once again the case of the zero polynomial is painful. So Mathlib defines
    `Polynomial.roots` to send a polynomial `P` to a multiset, i.e. the finite set
    that is defined to be empty if `P` is zero and the roots of `P`, with multiplicities,
    otherwise. This is defined only when the underlying ring is a domain since otherwise
    the definition does not have good properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `Polynomial.eval` and `Polynomial.roots` consider only the coefficients
    ring. They do not allow us to say that `X ^ 2 - 2 : ℚ[X]` has a root in `ℝ` or
    that `X ^ 2 + 1 : ℝ[X]` has a root in `ℂ`. For this, we need `Polynomial.aeval`,
    which will evaluate `P : R[X]` in any `R`-algebra. More precisely, given a semiring
    `A` and an instance of `Algebra R A`, `Polynomial.aeval` sends every element of
    `a` along the `R`-algebra morphism of evaluation at `a`. Since `AlgHom` has a
    coercion to functions, one can apply it to a polynomial. But `aeval` does not
    have a polynomial as an argument, so one cannot use dot notation like in `P.eval`
    above.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The function corresponding to `roots` in this context is `aroots` which takes
    a polynomial and then an algebra and outputs a multiset (with the same caveat
    about the zero polynomial as for `roots`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'More generally, given an ring morphism `f : R →+* S` one can evaluate `P :
    R[X]` at a point in `S` using `Polynomial.eval₂`. This one produces an actual
    function from `R[X]` to `S` since it does not assume the existence of a `Algebra
    R S` instance, so dot notation works as you would expect.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us end by mentioning multivariate polynomials briefly. Given a commutative
    semiring `R`, the `R`-algebra of polynomials with coefficients in `R` and indeterminates
    indexed by a type `σ` is `MVPolynomial σ R`. Given `i : σ`, the corresponding
    polynomial is `MvPolynomial.X i`. (As usual, one can open the `MVPolynomial` namespace
    to shorten this to `X i`.) For instance, if we want two indeterminates we can
    use `Fin 2` as `σ` and write the polynomial defining the unit circle in \(\mathbb{R}^2`\)
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Recall that function application has a very high precedence so the expression
    above is read as `(X 0) ^ 2 + (X 1) ^ 2 - 1`. We can evaluate it to make sure
    the point with coordinates \((1, 0)\) is on the circle. Recall the `![...]` notation
    denotes elements of `Fin n → X` for some natural number `n` determined by the
    number of arguments and some type `X` determined by the type of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83] [Previous](C08_Hierarchies.html "8\. Hierarchies") [Next](C10_Linear_Algebra.html
    "10\. Linear algebra")'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: © Copyright 2020-2025, Jeremy Avigad, Patrick Massot. Text licensed under CC
    BY 4.0.
  prefs: []
  type: TYPE_NORMAL
- en: Built with [Sphinx](https://www.sphinx-doc.org/) using a [theme](https://github.com/readthedocs/sphinx_rtd_theme)
    provided by [Read the Docs](https://readthedocs.org). We saw in [Section 2.2](C02_Basics.html#proving-identities-in-algebraic-structures)
    how to reason about operations in groups and rings. Later, in [Section 7.2](C07_Structures.html#section-algebraic-structures),
    we saw how to define abstract algebraic structures, such as group structures,
    as well as concrete instances such as the ring structure on the Gaussian integers.
    [Chapter 8](C08_Hierarchies.html#hierarchies) explained how hierarchies of abstract
    structures are handled in Mathlib.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we work with groups and rings in more detail. We won’t be able
    to cover every aspect of the treatment of these topics in Mathlib, especially
    since Mathlib is constantly growing. But we will provide entry points to the library
    and show how the essential concepts are used. There is some overlap with the discussion
    of [Chapter 8](C08_Hierarchies.html#hierarchies), but here we will focus on how
    to use Mathlib instead of the design decisions behind the way the topics are treated.
    So making sense of some of the examples may require reviewing the background from
    [Chapter 8](C08_Hierarchies.html#hierarchies).
  prefs: []
  type: TYPE_NORMAL
- en: '## 9.1\. Monoids and Groups[](#monoids-and-groups "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: '### 9.1.1\. Monoids and their morphisms[](#monoids-and-their-morphisms "Link
    to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Courses in abstract algebra often start with groups and then progress to rings,
    fields, and vector spaces. This involves some contortions when discussing multiplication
    on rings since the multiplication operation does not come from a group structure
    but many of the proofs carry over verbatim from group theory to this new setting.
    The most common fix, when doing mathematics with pen and paper, is to leave those
    proofs as exercises. A less efficient but safer and more formalization-friendly
    way of proceeding is to use monoids. A *monoid* structure on a type M is an internal
    composition law that is associative and has a neutral element. Monoids are used
    primarily to accommodate both groups and the multiplicative structure of rings.
    But there are also a number of natural examples; for instance, the set of natural
    numbers equipped with addition forms a monoid.
  prefs: []
  type: TYPE_NORMAL
- en: From a practical point of view, you can mostly ignore monoids when using Mathlib.
    But you need to know they exist when you are looking for a lemma by browsing Mathlib
    files. Otherwise, you might end up looking for a statement in the group theory
    files when it is actually in the found with monoids because it does not require
    elements to be invertible.
  prefs: []
  type: TYPE_NORMAL
- en: The type of monoid structures on a type `M` is written `Monoid M`. The function
    `Monoid` is a type class so it will almost always appear as an instance implicit
    argument (in other words, in square brackets). By default, `Monoid` uses multiplicative
    notation for the operation; for additive notation use `AddMonoid` instead. The
    commutative versions of these structures add the prefix `Comm` before `Monoid`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Note that although `AddMonoid` is found in the library, it is generally confusing
    to use additive notation with a non-commutative operation.
  prefs: []
  type: TYPE_NORMAL
- en: The type of morphisms between monoids `M` and `N` is called `MonoidHom M N`
    and written `M →* N`. Lean will automatically see such a morphism as a function
    from `M` to `N` when we apply it to elements of `M`. The additive version is called
    `AddMonoidHom` and written `M →+ N`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: These morphisms are bundled maps, i.e. they package together a map and some
    of its properties. Remember that [Section 8.2](C08_Hierarchies.html#section-hierarchies-morphisms)
    explains bundled maps; here we simply note the slightly unfortunate consequence
    that we cannot use ordinary function composition to compose maps. Instead, we
    need to use `MonoidHom.comp` and `AddMonoidHom.comp`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.2\. Groups and their morphisms[](#groups-and-their-morphisms "Link to this
    heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will have much more to say about groups, which are monoids with the extra
    property that every element has an inverse.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the `ring` tactic that we saw earlier, there is a `group` tactic
    that proves any identity that holds in any group. (Equivalently, it proves the
    identities that hold in free groups.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: There is also a tactic for identities in commutative additive groups called
    `abel`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, a group morphism is nothing more than a monoid morphism between
    groups. So we can copy and paste one of our earlier examples, replacing `Monoid`
    with `Group`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course we do get some new properties, such as this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: You may be worried that constructing group morphisms will require us to do unnecessary
    work since the definition of monoid morphism enforces that neutral elements are
    sent to neutral elements while this is automatic in the case of group morphisms.
    In practice the extra work is not hard, but, to avoid it, there is a function
    building a group morphism from a function between groups that is compatible with
    the composition laws.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a type `MulEquiv` of group (or monoid) isomorphisms denoted by
    `≃*` (and `AddEquiv` denoted by `≃+` in additive notation). The inverse of `f
    : G ≃* H` is `MulEquiv.symm f : H ≃* G`, composition of `f` and `g` is `MulEquiv.trans
    f g`, and the identity isomorphism of `G` is `M̀ulEquiv.refl G`. Using anonymous
    projector notation, the first two can be written `f.symm` and `f.trans g` respectively.
    Elements of this type are automatically coerced to morphisms and functions when
    necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: One can use `MulEquiv.ofBijective` to build an isomorphism from a bijective
    morphism. Doing so makes the inverse function noncomputable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.3\. Subgroups[](#subgroups "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as group morphisms are bundled, a subgroup of `G` is also a bundled structure
    consisting of a set in `G` with the relevant closure properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, it is important to understand that `Subgroup G` is the
    type of subgroups of `G`, rather than a predicate `IsSubgroup H` where `H` is
    an element of `Set G`. `Subgroup G` is endowed with a coercion to `Set G` and
    a membership predicate on `G`. See [Section 8.3](C08_Hierarchies.html#section-hierarchies-subobjects)
    for an explanation of how and why this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, two subgroups are the same if and only if they have the same elements.
    This fact is registered for use with the `ext` tactic, which can be used to prove
    two subgroups are equal in the same way it is used to prove that two sets are
    equal.
  prefs: []
  type: TYPE_NORMAL
- en: To state and prove, for example, that `ℤ` is an additive subgroup of `ℚ`, what
    we really want is to construct a term of type `AddSubgroup ℚ` whose projection
    to `Set ℚ` is `ℤ`, or, more precisely, the image of `ℤ` in `ℚ`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Using type classes, Mathlib knows that a subgroup of a group inherits a group
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is subtle. The object `H` is not a type, but Lean automatically
    coerces it to a type by interpreting it as a subtype of `G`. So the above example
    can be restated more explicitly as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'An important benefit of having a type `Subgroup G` instead of a predicate `IsSubgroup
    : Set G → Prop` is that one can easily endow `Subgroup G` with additional structure.
    Importantly, it has the structure of a complete lattice structure with respect
    to inclusion. For instance, instead of having a lemma stating that an intersection
    of two subgroups of `G` is again a subgroup, we have used the lattice operation
    `⊓` to construct the intersection. We can then apply arbitrary lemmas about lattices
    to the construction.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us check that the set underlying the infimum of two subgroups is indeed,
    by definition, their intersection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: It may look strange to have a different notation for what amounts to the intersection
    of the underlying sets, but the correspondence does not carry over to the supremum
    operation and set union, since a union of subgroups is not, in general, a subgroup.
    Instead one needs to use the subgroup generated by the union, which is done using
    `Subgroup.closure`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Another subtlety is that `G` itself does not have type `Subgroup G`, so we
    need a way to talk about `G` seen as a subgroup of `G`. This is also provided
    by the lattice structure: the full subgroup is the top element of this lattice.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Similarly the bottom element of this lattice is the subgroup whose only element
    is the neutral element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: As an exercise in manipulating groups and subgroups, you can define the conjugate
    of a subgroup by an element of the ambient group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Tying the previous two topics together, one can push forward and pull back subgroups
    using group morphisms. The naming convention in Mathlib is to call those operations
    `map` and `comap`. These are not the common mathematical terms, but they have
    the advantage of being shorter than “pushforward” and “direct image.”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: In particular, the preimage of the bottom subgroup under a morphism `f` is a
    subgroup called the *kernel* of `f`, and the range of `f` is also a subgroup.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: As exercises in manipulating group morphisms and subgroups, let us prove some
    elementary properties. They are already proved in Mathlib, so do not use `exact?`
    too quickly if you want to benefit from these exercises.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Let us finish this introduction to subgroups in Mathlib with two very classical
    results. Lagrange theorem states the cardinality of a subgroup of a finite group
    divides the cardinality of the group. Sylow’s first theorem is a famous partial
    converse to Lagrange’s theorem.
  prefs: []
  type: TYPE_NORMAL
- en: While this corner of Mathlib is partly set up to allow computation, we can tell
    Lean to use nonconstructive logic anyway using the following `open scoped` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The next two exercises derive a corollary of Lagrange’s lemma. (This is also
    already in Mathlib, so do not use `exact?` too quickly.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.4\. Concrete groups[](#concrete-groups "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One can also manipulate concrete groups in Mathlib, although this is typically
    more complicated than working with the abstract theory. For instance, given any
    type `X`, the group of permutations of `X` is `Equiv.Perm X`. In particular the
    symmetric group \(\mathfrak{S}_n\) is `Equiv.Perm (Fin n)`. One can state abstract
    results about this group, for instance saying that `Equiv.Perm X` is generated
    by cycles if `X` is finite.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'One can be fully concrete and compute actual products of cycles. Below we use
    the `#simp` command, which calls the `simp` tactic on a given expression. The
    notation `c[]` is used to define a cyclic permutation. In the example, the result
    is a permutation of `ℕ`. One could use a type ascription such as `(1 : Fin 5)`
    on the first number appearing to make it a computation in `Perm (Fin 5)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to work with concrete groups is to use free groups and group presentations.
    The free group on a type `α` is `FreeGroup α` and the inclusion map is `FreeGroup.of
    : α → FreeGroup α`. For instance let us define a type `S` with three elements
    denoted by `a`, `b` and `c`, and the element `ab⁻¹` of the corresponding free
    group.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Note that we gave the expected type of the definition so that Lean knows that
    `.of` means `FreeGroup.of`.
  prefs: []
  type: TYPE_NORMAL
- en: The universal property of free groups is embodied as the equivalence `FreeGroup.lift`.
    For example, let us define the group morphism from `FreeGroup S` to `Perm (Fin
    5)` that sends `a` to `c[1, 2, 3]`, `b` to `c[2, 3, 1]`, and `c` to `c[2, 3]`,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: As a last concrete example, let us see how to define a group generated by a
    single element whose cube is one (so that group will be isomorphic to \(\mathbb{Z}/3\))
    and build a morphism from that group to `Perm (Fin 5)`.
  prefs: []
  type: TYPE_NORMAL
- en: As a type with exactly one element, we will use `Unit` whose only element is
    denoted by `()`. The function `PresentedGroup` takes a set of relations, i.e.
    a set of elements of some free group, and returns a group that is this free group
    quotiented by a normal subgroup generated by relations. (We will see how to handle
    more general quotients in [Section 9.1.6](#quotient-groups).) Since we somehow
    hide this behind a definition, we use `deriving Group` to force creation of a
    group instance on `myGroup`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: The universal property of presented groups ensures that morphisms out of this
    group can be built from functions that send the relations to the neutral element
    of the target group. So we need such a function and a proof that the condition
    holds. Then we can feed this proof to `PresentedGroup.toGroup` to get the desired
    group morphism.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.5\. Group actions[](#group-actions "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One important way that group theory interacts with the rest of mathematics is
    through the use of group actions. An action of a group `G` on some type `X` is
    nothing more than a morphism from `G` to `Equiv.Perm X`. So in a sense group actions
    are already covered by the previous discussion. But we don’t want to carry this
    morphism around; instead, we want it to be inferred automatically by Lean as much
    as possible. So we have a type class for this, which is `MulAction G X`. The downside
    of this setup is that having multiple actions of the same group on the same type
    requires some contortions, such as defining type synonyms, each of which carries
    different type class instances.
  prefs: []
  type: TYPE_NORMAL
- en: This allows us in particular to use `g • x` to denote the action of a group
    element `g` on a point `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: There is also a version for additive group called `AddAction`, where the action
    is denoted by `+ᵥ`. This is used for instance in the definition of affine spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The underlying group morphism is called `MulAction.toPermHom`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: As an illustration let us see how to define the Cayley isomorphism embedding
    of any group `G` into a permutation group, namely `Perm G`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Note that nothing before the above definition required having a group rather
    than a monoid (or any type endowed with a multiplication operation really).
  prefs: []
  type: TYPE_NORMAL
- en: The group condition really enters the picture when we will want to partition
    `X` into orbits. The corresponding equivalence relation on `X` is called `MulAction.orbitRel`.
    It is not declared as a global instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this we can state that `X` is partitioned into orbits under the action
    of `G`. More precisely, we get a bijection between `X` and the dependent product
    `(ω : orbitRel.Quotient G X) × (orbit G (Quotient.out'' ω))` where `Quotient.out''
    ω` simply chooses an element that projects to `ω`. Recall that elements of this
    dependent product are pairs `⟨ω, x⟩` where the type `orbit G (Quotient.out'' ω)`
    of `x` depends on `ω`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: In particular, when X is finite, this can be combined with `Fintype.card_congr`
    and `Fintype.card_sigma` to deduce that the cardinality of `X` is the sum of the
    cardinalities of the orbits. Furthermore, the orbits are in bijection with the
    quotient of `G` under the action of the stabilizers by left translation. This
    action of a subgroup by left-translation is used to define quotients of a group
    by a subgroup with notation / so we can use the following concise statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'An important special case of combining the above two results is when `X` is
    a group `G` equipped with the action of a subgroup `H` by translation. In this
    case all stabilizers are trivial so every orbit is in bijection with `H` and we
    get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: This is the conceptual variant of the version of Lagrange theorem that we saw
    above. Note this version makes no finiteness assumption.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise for this section, let us build the action of a group on its subgroup
    by conjugation, using our definition of `conjugate` from a previous exercise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '### 9.1.6\. Quotient groups[](#quotient-groups "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: In the above discussion of subgroups acting on groups, we saw the quotient `G
    ⧸ H` appear. In general this is only a type. It can be endowed with a group structure
    such that the quotient map is a group morphism if and only if `H` is a normal
    subgroup (and this group structure is then unique).
  prefs: []
  type: TYPE_NORMAL
- en: The normality assumption is a type class `Subgroup.Normal` so that type class
    inference can use it to derive the group structure on the quotient.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The universal property of quotient groups is accessed through `QuotientGroup.lift`:
    a group morphism `φ` descends to `G ⧸ N` as soon as its kernel contains `N`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: The fact that the target group is called `M` is the above snippet is a clue
    that having a monoid structure on `M` would be enough.
  prefs: []
  type: TYPE_NORMAL
- en: An important special case is when `N = ker φ`. In that case the descended morphism
    is injective and we get a group isomorphism onto its image. This result is often
    called the first isomorphism theorem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying the universal property to a composition of a morphism `φ : G →* G''`
    with a quotient group projection `Quotient.mk'' N''`, we can also aim for a morphism
    from `G ⧸ N` to `G'' ⧸ N''`. The condition required on `φ` is usually formulated
    by saying “`φ` should send `N` inside `N''`.” But this is equivalent to asking
    that `φ` should pull `N''` back over `N`, and the latter condition is nicer to
    work with since the definition of pullback does not involve an existential quantifier.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: One subtle point to keep in mind is that the type `G ⧸ N` really depends on
    `N` (up to definitional equality), so having a proof that two normal subgroups
    `N` and `M` are equal is not enough to make the corresponding quotients equal.
    However the universal properties does give an isomorphism in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: As a final series of exercises for this section, we will prove that if `H` and
    `K` are disjoint normal subgroups of a finite group `G` such that the product
    of their cardinalities is equal to the cardinality of `G` then `G` is isomorphic
    to `H × K`. Recall that disjoint in this context means `H ⊓ K = ⊥`.
  prefs: []
  type: TYPE_NORMAL
- en: We start with playing a bit with Lagrange’s lemma, without assuming the subgroups
    are normal or disjoint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: From now on, we assume that our subgroups are normal and disjoint, and we assume
    the cardinality condition. Now we construct the first building block of the desired
    isomorphism.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Now we can define our second building block. We will need `MonoidHom.prod`,
    which builds a morphism from `G₀` to `G₁ × G₂` out of morphisms from `G₀` to `G₁`
    and `G₂`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: We are ready to put all pieces together.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]  ## 9.2\. Rings[](#rings "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: '### 9.2.1\. Rings, their units, morphisms and subrings[](#rings-their-units-morphisms-and-subrings
    "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: The type of ring structures on a type `R` is `Ring R`. The variant where multiplication
    is assumed to be commutative is `CommRing R`. We have already seen that the `ring`
    tactic will prove any equality that follows from the axioms of a commutative ring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: More exotic variants do not require that the addition on `R` forms a group but
    only an additive monoid. The corresponding type classes are `Semiring R` and `CommSemiring
    R`. The type of natural numbers is an important instance of `CommSemiring R`,
    as is any type of functions taking values in the natural numbers. Another important
    example is the type of ideals in a ring, which will be discussed below. The name
    of the `ring` tactic is doubly misleading, since it assumes commutativity but
    works in semirings as well. In other words, it applies to any `CommSemiring`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: There are also versions of the ring and semiring classes that do not assume
    the existence of a multiplicative unit or the associativity of multiplication.
    We will not discuss those here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some concepts that are traditionally taught in an introduction to ring theory
    are actually about the underlying multiplicative monoid. A prominent example is
    the definition of the units of a ring. Every (multiplicative) monoid `M` has a
    predicate `IsUnit : M → Prop` asserting existence of a two-sided inverse, a type
    `Units M` of units with notation `Mˣ`, and a coercion to `M`. The type `Units
    M` bundles an invertible element with its inverse as well as properties than ensure
    that each is indeed the inverse of the other. This implementation detail is relevant
    mainly when defining computable functions. In most situations one can use `IsUnit.unit
    {x : M} : IsUnit x → Mˣ` to build a unit. In the commutative case, one also has
    `Units.mkOfMulEqOne (x y : M) : x * y = 1 → Mˣ` which builds `x` seen as unit.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: The type of ring morphisms between two (semi)-rings `R` and `S` is `RingHom
    R S`, with notation `R →+* S`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: The isomorphism variant is `RingEquiv`, with notation `≃+*`.
  prefs: []
  type: TYPE_NORMAL
- en: As with submonoids and subgroups, there is a `Subring R` type for subrings of
    a ring `R`, but this type is a lot less useful than the type of subgroups since
    one cannot quotient a ring by a subring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Also notice that `RingHom.range` produces a subring.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.2\. Ideals and quotients[](#ideals-and-quotients "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For historical reasons, Mathlib only has a theory of ideals for commutative
    rings. (The ring library was originally developed to make quick progress toward
    the foundations of modern algebraic geometry.) So in this section we will work
    with commutative (semi)rings. Ideals of `R` are defined as submodules of `R` seen
    as `R`-modules. Modules will be covered later in a chapter on linear algebra,
    but this implementation detail can mostly be safely ignored since most (but not
    all) relevant lemmas are restated in the special context of ideals. But anonymous
    projection notation won’t always work as expected. For instance, one cannot replace
    `Ideal.Quotient.mk I` by `I.Quotient.mk` in the snippet below because there are
    two `.`s and so it will parse as `(Ideal.Quotient I).mk`; but `Ideal.Quotient`
    by itself doesn’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: The universal property of quotient rings is `Ideal.Quotient.lift`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: In particular it leads to the first isomorphism theorem for rings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Ideals form a complete lattice structure with the inclusion relation, as well
    as a semiring structure. These two structures interact nicely.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: One can use ring morphisms to push ideals forward and pull them back using `Ideal.map`
    and `Ideal.comap`, respectively. As usual, the latter is more convenient to use
    since it does not involve an existential quantifier. This explains why it is used
    to state the condition that allows us to build morphisms between quotient rings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: One subtle point is that the type `R ⧸ I` really depends on `I` (up to definitional
    equality), so having a proof that two ideals `I` and `J` are equal is not enough
    to make the corresponding quotients equal. However, the universal properties do
    provide an isomorphism in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: We can now present the Chinese remainder isomorphism as an example. Pay attention
    to the difference between the indexed infimum symbol `⨅` and the big product of
    types symbol `Π`. Depending on your font, those can be pretty hard to distinguish.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'The elementary version of the Chinese remainder theorem, a statement about
    `ZMod`, can be easily deduced from the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: As a series of exercises, we will reprove the Chinese remainder theorem in the
    general case.
  prefs: []
  type: TYPE_NORMAL
- en: We first need to define the map appearing in the theorem, as a ring morphism,
    using the universal property of quotient rings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the following next two lemmas can be proven by `rfl`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: The next lemma proves the easy half of the Chinese remainder theorem, without
    any assumption on the family of ideals. The proof is less than one line long.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready for the heart of the theorem, which will show the surjectivity
    of our `chineseMap`. First we need to know the different ways one can express
    the coprimality (also called co-maximality assumption). Only the first two will
    be needed below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: We take the opportunity to use induction on `Finset`. Relevant lemmas on `Finset`
    are given below. Remember that the `ring` tactic works for semirings and that
    the ideals of a ring form a semiring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: We can now prove surjectivity of the map appearing in the Chinese remainder
    theorem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all the pieces come together in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 9.2.3\. Algebras and polynomials[](#algebras-and-polynomials "Link to this
    heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Given a commutative (semi)ring `R`, an *algebra over* `R` is a semiring `A`
    equipped with a ring morphism whose image commutes with every element of `A`.
    This is encoded as a type class `Algebra R A`. The morphism from `R` to `A` is
    called the structure map and is denoted `algebraMap R A : R →+* A` in Lean. Multiplication
    of `a : A` by `algebraMap R A r` for some `r : R` is called the scalar multiplication
    of `a` by `r` and denoted by `r • a`. Note that this notion of algebra is sometimes
    called an *associative unital algebra* to emphasize the existence of more general
    notions of algebra.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that `algebraMap R A` is ring morphism packages together a lot of
    properties of scalar multiplication, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: The morphisms between two `R`-algebras `A` and `B` are ring morphisms which
    commute with scalar multiplication by elements of `R`. They are bundled morphisms
    with type `AlgHom R A B`, which is denoted by `A →ₐ[R] B`.
  prefs: []
  type: TYPE_NORMAL
- en: Important examples of non-commutative algebras include algebras of endomorphisms
    and algebras of square matrices, both of which will be covered in the chapter
    on linear algebra. In this chapter we will discuss one of the most important examples
    of a commutative algebra, namely, polynomial algebras.
  prefs: []
  type: TYPE_NORMAL
- en: The algebra of univariate polynomials with coefficients in `R` is called `Polynomial
    R`, which can be written as `R[X]` as soon as one opens the `Polynomial` namespace.
    The algebra structure map from `R` to `R[X]` is denoted by `C`, which stands for
    “constant” since the corresponding polynomial functions are always constant. The
    indeterminate is denoted by `X`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: In the first example above, it is crucial that we give Lean the expected type
    since it cannot be determined from the body of the definition. In the second example,
    the target polynomial algebra can be inferred from our use of `C r` since the
    type of `r` is known.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `C` is a ring morphism from `R` to `R[X]`, we can use all ring morphisms
    lemmas such as `map_zero`, `map_one`, `map_mul`, and `map_pow` before computing
    in the ring `R[X]`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: You can access coefficients using `Polynomial.coeff`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Defining the degree of a polynomial is always tricky because of the special
    case of the zero polynomial. Mathlib has two variants: `Polynomial.natDegree :
    R[X] → ℕ` assigns degree `0` to the zero polynomial, and `Polynomial.degree :
    R[X] → WithBot ℕ` assigns `⊥`. In the latter, `WithBot ℕ` can be seen as `ℕ ∪
    {-∞}`, except that `-∞` is denoted `⊥`, the same symbol as the bottom element
    in a complete lattice. This special value is used as the degree of the zero polynomial,
    and it is absorbent for addition. (It is almost absorbent for multiplication,
    except that `⊥ * 0 = 0`.)'
  prefs: []
  type: TYPE_NORMAL
- en: Morally speaking, the `degree` version is the correct one. For instance, it
    allows us to state the expected formula for the degree of a product (assuming
    the base ring has no zero divisor).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Whereas the version for `natDegree` needs to assume non-zero polynomials.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `ℕ` is much nicer to use than `WithBot ℕ`, so Mathlib makes both versions
    available and provides lemmas to convert between them. Also, `natDegree` is the
    more convenient definition to use when computing the degree of a composition.
    Composition of polynomial is `Polynomial.comp` and we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Polynomials give rise to polynomial functions: any polynomial can be evaluated
    on `R` using `Polynomial.eval`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: In particular, there is a predicate, `IsRoot`, that holds for elements `r` in
    `R` where a polynomial vanishes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: We would like to say that, assuming `R` has no zero divisor, a polynomial has
    at most as many roots as its degree, where the roots are counted with multiplicities.
    But once again the case of the zero polynomial is painful. So Mathlib defines
    `Polynomial.roots` to send a polynomial `P` to a multiset, i.e. the finite set
    that is defined to be empty if `P` is zero and the roots of `P`, with multiplicities,
    otherwise. This is defined only when the underlying ring is a domain since otherwise
    the definition does not have good properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `Polynomial.eval` and `Polynomial.roots` consider only the coefficients
    ring. They do not allow us to say that `X ^ 2 - 2 : ℚ[X]` has a root in `ℝ` or
    that `X ^ 2 + 1 : ℝ[X]` has a root in `ℂ`. For this, we need `Polynomial.aeval`,
    which will evaluate `P : R[X]` in any `R`-algebra. More precisely, given a semiring
    `A` and an instance of `Algebra R A`, `Polynomial.aeval` sends every element of
    `a` along the `R`-algebra morphism of evaluation at `a`. Since `AlgHom` has a
    coercion to functions, one can apply it to a polynomial. But `aeval` does not
    have a polynomial as an argument, so one cannot use dot notation like in `P.eval`
    above.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: The function corresponding to `roots` in this context is `aroots` which takes
    a polynomial and then an algebra and outputs a multiset (with the same caveat
    about the zero polynomial as for `roots`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'More generally, given an ring morphism `f : R →+* S` one can evaluate `P :
    R[X]` at a point in `S` using `Polynomial.eval₂`. This one produces an actual
    function from `R[X]` to `S` since it does not assume the existence of a `Algebra
    R S` instance, so dot notation works as you would expect.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us end by mentioning multivariate polynomials briefly. Given a commutative
    semiring `R`, the `R`-algebra of polynomials with coefficients in `R` and indeterminates
    indexed by a type `σ` is `MVPolynomial σ R`. Given `i : σ`, the corresponding
    polynomial is `MvPolynomial.X i`. (As usual, one can open the `MVPolynomial` namespace
    to shorten this to `X i`.) For instance, if we want two indeterminates we can
    use `Fin 2` as `σ` and write the polynomial defining the unit circle in \(\mathbb{R}^2`\)
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Recall that function application has a very high precedence so the expression
    above is read as `(X 0) ^ 2 + (X 1) ^ 2 - 1`. We can evaluate it to make sure
    the point with coordinates \((1, 0)\) is on the circle. Recall the `![...]` notation
    denotes elements of `Fin n → X` for some natural number `n` determined by the
    number of arguments and some type `X` determined by the type of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]  ## 9.1\. Monoids and Groups[](#monoids-and-groups "Link to this
    heading")'
  prefs: []
  type: TYPE_NORMAL
- en: '### 9.1.1\. Monoids and their morphisms[](#monoids-and-their-morphisms "Link
    to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Courses in abstract algebra often start with groups and then progress to rings,
    fields, and vector spaces. This involves some contortions when discussing multiplication
    on rings since the multiplication operation does not come from a group structure
    but many of the proofs carry over verbatim from group theory to this new setting.
    The most common fix, when doing mathematics with pen and paper, is to leave those
    proofs as exercises. A less efficient but safer and more formalization-friendly
    way of proceeding is to use monoids. A *monoid* structure on a type M is an internal
    composition law that is associative and has a neutral element. Monoids are used
    primarily to accommodate both groups and the multiplicative structure of rings.
    But there are also a number of natural examples; for instance, the set of natural
    numbers equipped with addition forms a monoid.
  prefs: []
  type: TYPE_NORMAL
- en: From a practical point of view, you can mostly ignore monoids when using Mathlib.
    But you need to know they exist when you are looking for a lemma by browsing Mathlib
    files. Otherwise, you might end up looking for a statement in the group theory
    files when it is actually in the found with monoids because it does not require
    elements to be invertible.
  prefs: []
  type: TYPE_NORMAL
- en: The type of monoid structures on a type `M` is written `Monoid M`. The function
    `Monoid` is a type class so it will almost always appear as an instance implicit
    argument (in other words, in square brackets). By default, `Monoid` uses multiplicative
    notation for the operation; for additive notation use `AddMonoid` instead. The
    commutative versions of these structures add the prefix `Comm` before `Monoid`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Note that although `AddMonoid` is found in the library, it is generally confusing
    to use additive notation with a non-commutative operation.
  prefs: []
  type: TYPE_NORMAL
- en: The type of morphisms between monoids `M` and `N` is called `MonoidHom M N`
    and written `M →* N`. Lean will automatically see such a morphism as a function
    from `M` to `N` when we apply it to elements of `M`. The additive version is called
    `AddMonoidHom` and written `M →+ N`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: These morphisms are bundled maps, i.e. they package together a map and some
    of its properties. Remember that [Section 8.2](C08_Hierarchies.html#section-hierarchies-morphisms)
    explains bundled maps; here we simply note the slightly unfortunate consequence
    that we cannot use ordinary function composition to compose maps. Instead, we
    need to use `MonoidHom.comp` and `AddMonoidHom.comp`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.2\. Groups and their morphisms[](#groups-and-their-morphisms "Link to this
    heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will have much more to say about groups, which are monoids with the extra
    property that every element has an inverse.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the `ring` tactic that we saw earlier, there is a `group` tactic
    that proves any identity that holds in any group. (Equivalently, it proves the
    identities that hold in free groups.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: There is also a tactic for identities in commutative additive groups called
    `abel`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, a group morphism is nothing more than a monoid morphism between
    groups. So we can copy and paste one of our earlier examples, replacing `Monoid`
    with `Group`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course we do get some new properties, such as this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: You may be worried that constructing group morphisms will require us to do unnecessary
    work since the definition of monoid morphism enforces that neutral elements are
    sent to neutral elements while this is automatic in the case of group morphisms.
    In practice the extra work is not hard, but, to avoid it, there is a function
    building a group morphism from a function between groups that is compatible with
    the composition laws.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a type `MulEquiv` of group (or monoid) isomorphisms denoted by
    `≃*` (and `AddEquiv` denoted by `≃+` in additive notation). The inverse of `f
    : G ≃* H` is `MulEquiv.symm f : H ≃* G`, composition of `f` and `g` is `MulEquiv.trans
    f g`, and the identity isomorphism of `G` is `M̀ulEquiv.refl G`. Using anonymous
    projector notation, the first two can be written `f.symm` and `f.trans g` respectively.
    Elements of this type are automatically coerced to morphisms and functions when
    necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: One can use `MulEquiv.ofBijective` to build an isomorphism from a bijective
    morphism. Doing so makes the inverse function noncomputable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.3\. Subgroups[](#subgroups "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as group morphisms are bundled, a subgroup of `G` is also a bundled structure
    consisting of a set in `G` with the relevant closure properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, it is important to understand that `Subgroup G` is the
    type of subgroups of `G`, rather than a predicate `IsSubgroup H` where `H` is
    an element of `Set G`. `Subgroup G` is endowed with a coercion to `Set G` and
    a membership predicate on `G`. See [Section 8.3](C08_Hierarchies.html#section-hierarchies-subobjects)
    for an explanation of how and why this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, two subgroups are the same if and only if they have the same elements.
    This fact is registered for use with the `ext` tactic, which can be used to prove
    two subgroups are equal in the same way it is used to prove that two sets are
    equal.
  prefs: []
  type: TYPE_NORMAL
- en: To state and prove, for example, that `ℤ` is an additive subgroup of `ℚ`, what
    we really want is to construct a term of type `AddSubgroup ℚ` whose projection
    to `Set ℚ` is `ℤ`, or, more precisely, the image of `ℤ` in `ℚ`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Using type classes, Mathlib knows that a subgroup of a group inherits a group
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is subtle. The object `H` is not a type, but Lean automatically
    coerces it to a type by interpreting it as a subtype of `G`. So the above example
    can be restated more explicitly as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'An important benefit of having a type `Subgroup G` instead of a predicate `IsSubgroup
    : Set G → Prop` is that one can easily endow `Subgroup G` with additional structure.
    Importantly, it has the structure of a complete lattice structure with respect
    to inclusion. For instance, instead of having a lemma stating that an intersection
    of two subgroups of `G` is again a subgroup, we have used the lattice operation
    `⊓` to construct the intersection. We can then apply arbitrary lemmas about lattices
    to the construction.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us check that the set underlying the infimum of two subgroups is indeed,
    by definition, their intersection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: It may look strange to have a different notation for what amounts to the intersection
    of the underlying sets, but the correspondence does not carry over to the supremum
    operation and set union, since a union of subgroups is not, in general, a subgroup.
    Instead one needs to use the subgroup generated by the union, which is done using
    `Subgroup.closure`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'Another subtlety is that `G` itself does not have type `Subgroup G`, so we
    need a way to talk about `G` seen as a subgroup of `G`. This is also provided
    by the lattice structure: the full subgroup is the top element of this lattice.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Similarly the bottom element of this lattice is the subgroup whose only element
    is the neutral element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: As an exercise in manipulating groups and subgroups, you can define the conjugate
    of a subgroup by an element of the ambient group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: Tying the previous two topics together, one can push forward and pull back subgroups
    using group morphisms. The naming convention in Mathlib is to call those operations
    `map` and `comap`. These are not the common mathematical terms, but they have
    the advantage of being shorter than “pushforward” and “direct image.”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: In particular, the preimage of the bottom subgroup under a morphism `f` is a
    subgroup called the *kernel* of `f`, and the range of `f` is also a subgroup.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: As exercises in manipulating group morphisms and subgroups, let us prove some
    elementary properties. They are already proved in Mathlib, so do not use `exact?`
    too quickly if you want to benefit from these exercises.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Let us finish this introduction to subgroups in Mathlib with two very classical
    results. Lagrange theorem states the cardinality of a subgroup of a finite group
    divides the cardinality of the group. Sylow’s first theorem is a famous partial
    converse to Lagrange’s theorem.
  prefs: []
  type: TYPE_NORMAL
- en: While this corner of Mathlib is partly set up to allow computation, we can tell
    Lean to use nonconstructive logic anyway using the following `open scoped` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: The next two exercises derive a corollary of Lagrange’s lemma. (This is also
    already in Mathlib, so do not use `exact?` too quickly.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.4\. Concrete groups[](#concrete-groups "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One can also manipulate concrete groups in Mathlib, although this is typically
    more complicated than working with the abstract theory. For instance, given any
    type `X`, the group of permutations of `X` is `Equiv.Perm X`. In particular the
    symmetric group \(\mathfrak{S}_n\) is `Equiv.Perm (Fin n)`. One can state abstract
    results about this group, for instance saying that `Equiv.Perm X` is generated
    by cycles if `X` is finite.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'One can be fully concrete and compute actual products of cycles. Below we use
    the `#simp` command, which calls the `simp` tactic on a given expression. The
    notation `c[]` is used to define a cyclic permutation. In the example, the result
    is a permutation of `ℕ`. One could use a type ascription such as `(1 : Fin 5)`
    on the first number appearing to make it a computation in `Perm (Fin 5)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to work with concrete groups is to use free groups and group presentations.
    The free group on a type `α` is `FreeGroup α` and the inclusion map is `FreeGroup.of
    : α → FreeGroup α`. For instance let us define a type `S` with three elements
    denoted by `a`, `b` and `c`, and the element `ab⁻¹` of the corresponding free
    group.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: Note that we gave the expected type of the definition so that Lean knows that
    `.of` means `FreeGroup.of`.
  prefs: []
  type: TYPE_NORMAL
- en: The universal property of free groups is embodied as the equivalence `FreeGroup.lift`.
    For example, let us define the group morphism from `FreeGroup S` to `Perm (Fin
    5)` that sends `a` to `c[1, 2, 3]`, `b` to `c[2, 3, 1]`, and `c` to `c[2, 3]`,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: As a last concrete example, let us see how to define a group generated by a
    single element whose cube is one (so that group will be isomorphic to \(\mathbb{Z}/3\))
    and build a morphism from that group to `Perm (Fin 5)`.
  prefs: []
  type: TYPE_NORMAL
- en: As a type with exactly one element, we will use `Unit` whose only element is
    denoted by `()`. The function `PresentedGroup` takes a set of relations, i.e.
    a set of elements of some free group, and returns a group that is this free group
    quotiented by a normal subgroup generated by relations. (We will see how to handle
    more general quotients in [Section 9.1.6](#quotient-groups).) Since we somehow
    hide this behind a definition, we use `deriving Group` to force creation of a
    group instance on `myGroup`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: The universal property of presented groups ensures that morphisms out of this
    group can be built from functions that send the relations to the neutral element
    of the target group. So we need such a function and a proof that the condition
    holds. Then we can feed this proof to `PresentedGroup.toGroup` to get the desired
    group morphism.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.5\. Group actions[](#group-actions "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One important way that group theory interacts with the rest of mathematics is
    through the use of group actions. An action of a group `G` on some type `X` is
    nothing more than a morphism from `G` to `Equiv.Perm X`. So in a sense group actions
    are already covered by the previous discussion. But we don’t want to carry this
    morphism around; instead, we want it to be inferred automatically by Lean as much
    as possible. So we have a type class for this, which is `MulAction G X`. The downside
    of this setup is that having multiple actions of the same group on the same type
    requires some contortions, such as defining type synonyms, each of which carries
    different type class instances.
  prefs: []
  type: TYPE_NORMAL
- en: This allows us in particular to use `g • x` to denote the action of a group
    element `g` on a point `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: There is also a version for additive group called `AddAction`, where the action
    is denoted by `+ᵥ`. This is used for instance in the definition of affine spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: The underlying group morphism is called `MulAction.toPermHom`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: As an illustration let us see how to define the Cayley isomorphism embedding
    of any group `G` into a permutation group, namely `Perm G`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: Note that nothing before the above definition required having a group rather
    than a monoid (or any type endowed with a multiplication operation really).
  prefs: []
  type: TYPE_NORMAL
- en: The group condition really enters the picture when we will want to partition
    `X` into orbits. The corresponding equivalence relation on `X` is called `MulAction.orbitRel`.
    It is not declared as a global instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this we can state that `X` is partitioned into orbits under the action
    of `G`. More precisely, we get a bijection between `X` and the dependent product
    `(ω : orbitRel.Quotient G X) × (orbit G (Quotient.out'' ω))` where `Quotient.out''
    ω` simply chooses an element that projects to `ω`. Recall that elements of this
    dependent product are pairs `⟨ω, x⟩` where the type `orbit G (Quotient.out'' ω)`
    of `x` depends on `ω`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: In particular, when X is finite, this can be combined with `Fintype.card_congr`
    and `Fintype.card_sigma` to deduce that the cardinality of `X` is the sum of the
    cardinalities of the orbits. Furthermore, the orbits are in bijection with the
    quotient of `G` under the action of the stabilizers by left translation. This
    action of a subgroup by left-translation is used to define quotients of a group
    by a subgroup with notation / so we can use the following concise statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'An important special case of combining the above two results is when `X` is
    a group `G` equipped with the action of a subgroup `H` by translation. In this
    case all stabilizers are trivial so every orbit is in bijection with `H` and we
    get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: This is the conceptual variant of the version of Lagrange theorem that we saw
    above. Note this version makes no finiteness assumption.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise for this section, let us build the action of a group on its subgroup
    by conjugation, using our definition of `conjugate` from a previous exercise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '### 9.1.6\. Quotient groups[](#quotient-groups "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: In the above discussion of subgroups acting on groups, we saw the quotient `G
    ⧸ H` appear. In general this is only a type. It can be endowed with a group structure
    such that the quotient map is a group morphism if and only if `H` is a normal
    subgroup (and this group structure is then unique).
  prefs: []
  type: TYPE_NORMAL
- en: The normality assumption is a type class `Subgroup.Normal` so that type class
    inference can use it to derive the group structure on the quotient.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'The universal property of quotient groups is accessed through `QuotientGroup.lift`:
    a group morphism `φ` descends to `G ⧸ N` as soon as its kernel contains `N`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: The fact that the target group is called `M` is the above snippet is a clue
    that having a monoid structure on `M` would be enough.
  prefs: []
  type: TYPE_NORMAL
- en: An important special case is when `N = ker φ`. In that case the descended morphism
    is injective and we get a group isomorphism onto its image. This result is often
    called the first isomorphism theorem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying the universal property to a composition of a morphism `φ : G →* G''`
    with a quotient group projection `Quotient.mk'' N''`, we can also aim for a morphism
    from `G ⧸ N` to `G'' ⧸ N''`. The condition required on `φ` is usually formulated
    by saying “`φ` should send `N` inside `N''`.” But this is equivalent to asking
    that `φ` should pull `N''` back over `N`, and the latter condition is nicer to
    work with since the definition of pullback does not involve an existential quantifier.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: One subtle point to keep in mind is that the type `G ⧸ N` really depends on
    `N` (up to definitional equality), so having a proof that two normal subgroups
    `N` and `M` are equal is not enough to make the corresponding quotients equal.
    However the universal properties does give an isomorphism in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: As a final series of exercises for this section, we will prove that if `H` and
    `K` are disjoint normal subgroups of a finite group `G` such that the product
    of their cardinalities is equal to the cardinality of `G` then `G` is isomorphic
    to `H × K`. Recall that disjoint in this context means `H ⊓ K = ⊥`.
  prefs: []
  type: TYPE_NORMAL
- en: We start with playing a bit with Lagrange’s lemma, without assuming the subgroups
    are normal or disjoint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: From now on, we assume that our subgroups are normal and disjoint, and we assume
    the cardinality condition. Now we construct the first building block of the desired
    isomorphism.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: Now we can define our second building block. We will need `MonoidHom.prod`,
    which builds a morphism from `G₀` to `G₁ × G₂` out of morphisms from `G₀` to `G₁`
    and `G₂`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: We are ready to put all pieces together.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]  ### 9.1.1\. Monoids and their morphisms[](#monoids-and-their-morphisms
    "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Courses in abstract algebra often start with groups and then progress to rings,
    fields, and vector spaces. This involves some contortions when discussing multiplication
    on rings since the multiplication operation does not come from a group structure
    but many of the proofs carry over verbatim from group theory to this new setting.
    The most common fix, when doing mathematics with pen and paper, is to leave those
    proofs as exercises. A less efficient but safer and more formalization-friendly
    way of proceeding is to use monoids. A *monoid* structure on a type M is an internal
    composition law that is associative and has a neutral element. Monoids are used
    primarily to accommodate both groups and the multiplicative structure of rings.
    But there are also a number of natural examples; for instance, the set of natural
    numbers equipped with addition forms a monoid.
  prefs: []
  type: TYPE_NORMAL
- en: From a practical point of view, you can mostly ignore monoids when using Mathlib.
    But you need to know they exist when you are looking for a lemma by browsing Mathlib
    files. Otherwise, you might end up looking for a statement in the group theory
    files when it is actually in the found with monoids because it does not require
    elements to be invertible.
  prefs: []
  type: TYPE_NORMAL
- en: The type of monoid structures on a type `M` is written `Monoid M`. The function
    `Monoid` is a type class so it will almost always appear as an instance implicit
    argument (in other words, in square brackets). By default, `Monoid` uses multiplicative
    notation for the operation; for additive notation use `AddMonoid` instead. The
    commutative versions of these structures add the prefix `Comm` before `Monoid`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: Note that although `AddMonoid` is found in the library, it is generally confusing
    to use additive notation with a non-commutative operation.
  prefs: []
  type: TYPE_NORMAL
- en: The type of morphisms between monoids `M` and `N` is called `MonoidHom M N`
    and written `M →* N`. Lean will automatically see such a morphism as a function
    from `M` to `N` when we apply it to elements of `M`. The additive version is called
    `AddMonoidHom` and written `M →+ N`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: These morphisms are bundled maps, i.e. they package together a map and some
    of its properties. Remember that [Section 8.2](C08_Hierarchies.html#section-hierarchies-morphisms)
    explains bundled maps; here we simply note the slightly unfortunate consequence
    that we cannot use ordinary function composition to compose maps. Instead, we
    need to use `MonoidHom.comp` and `AddMonoidHom.comp`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.2\. Groups and their morphisms[](#groups-and-their-morphisms "Link to this
    heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will have much more to say about groups, which are monoids with the extra
    property that every element has an inverse.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the `ring` tactic that we saw earlier, there is a `group` tactic
    that proves any identity that holds in any group. (Equivalently, it proves the
    identities that hold in free groups.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: There is also a tactic for identities in commutative additive groups called
    `abel`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, a group morphism is nothing more than a monoid morphism between
    groups. So we can copy and paste one of our earlier examples, replacing `Monoid`
    with `Group`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course we do get some new properties, such as this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: You may be worried that constructing group morphisms will require us to do unnecessary
    work since the definition of monoid morphism enforces that neutral elements are
    sent to neutral elements while this is automatic in the case of group morphisms.
    In practice the extra work is not hard, but, to avoid it, there is a function
    building a group morphism from a function between groups that is compatible with
    the composition laws.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a type `MulEquiv` of group (or monoid) isomorphisms denoted by
    `≃*` (and `AddEquiv` denoted by `≃+` in additive notation). The inverse of `f
    : G ≃* H` is `MulEquiv.symm f : H ≃* G`, composition of `f` and `g` is `MulEquiv.trans
    f g`, and the identity isomorphism of `G` is `M̀ulEquiv.refl G`. Using anonymous
    projector notation, the first two can be written `f.symm` and `f.trans g` respectively.
    Elements of this type are automatically coerced to morphisms and functions when
    necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: One can use `MulEquiv.ofBijective` to build an isomorphism from a bijective
    morphism. Doing so makes the inverse function noncomputable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.3\. Subgroups[](#subgroups "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as group morphisms are bundled, a subgroup of `G` is also a bundled structure
    consisting of a set in `G` with the relevant closure properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, it is important to understand that `Subgroup G` is the
    type of subgroups of `G`, rather than a predicate `IsSubgroup H` where `H` is
    an element of `Set G`. `Subgroup G` is endowed with a coercion to `Set G` and
    a membership predicate on `G`. See [Section 8.3](C08_Hierarchies.html#section-hierarchies-subobjects)
    for an explanation of how and why this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, two subgroups are the same if and only if they have the same elements.
    This fact is registered for use with the `ext` tactic, which can be used to prove
    two subgroups are equal in the same way it is used to prove that two sets are
    equal.
  prefs: []
  type: TYPE_NORMAL
- en: To state and prove, for example, that `ℤ` is an additive subgroup of `ℚ`, what
    we really want is to construct a term of type `AddSubgroup ℚ` whose projection
    to `Set ℚ` is `ℤ`, or, more precisely, the image of `ℤ` in `ℚ`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: Using type classes, Mathlib knows that a subgroup of a group inherits a group
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is subtle. The object `H` is not a type, but Lean automatically
    coerces it to a type by interpreting it as a subtype of `G`. So the above example
    can be restated more explicitly as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'An important benefit of having a type `Subgroup G` instead of a predicate `IsSubgroup
    : Set G → Prop` is that one can easily endow `Subgroup G` with additional structure.
    Importantly, it has the structure of a complete lattice structure with respect
    to inclusion. For instance, instead of having a lemma stating that an intersection
    of two subgroups of `G` is again a subgroup, we have used the lattice operation
    `⊓` to construct the intersection. We can then apply arbitrary lemmas about lattices
    to the construction.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us check that the set underlying the infimum of two subgroups is indeed,
    by definition, their intersection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: It may look strange to have a different notation for what amounts to the intersection
    of the underlying sets, but the correspondence does not carry over to the supremum
    operation and set union, since a union of subgroups is not, in general, a subgroup.
    Instead one needs to use the subgroup generated by the union, which is done using
    `Subgroup.closure`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'Another subtlety is that `G` itself does not have type `Subgroup G`, so we
    need a way to talk about `G` seen as a subgroup of `G`. This is also provided
    by the lattice structure: the full subgroup is the top element of this lattice.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: Similarly the bottom element of this lattice is the subgroup whose only element
    is the neutral element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: As an exercise in manipulating groups and subgroups, you can define the conjugate
    of a subgroup by an element of the ambient group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: Tying the previous two topics together, one can push forward and pull back subgroups
    using group morphisms. The naming convention in Mathlib is to call those operations
    `map` and `comap`. These are not the common mathematical terms, but they have
    the advantage of being shorter than “pushforward” and “direct image.”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: In particular, the preimage of the bottom subgroup under a morphism `f` is a
    subgroup called the *kernel* of `f`, and the range of `f` is also a subgroup.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: As exercises in manipulating group morphisms and subgroups, let us prove some
    elementary properties. They are already proved in Mathlib, so do not use `exact?`
    too quickly if you want to benefit from these exercises.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: Let us finish this introduction to subgroups in Mathlib with two very classical
    results. Lagrange theorem states the cardinality of a subgroup of a finite group
    divides the cardinality of the group. Sylow’s first theorem is a famous partial
    converse to Lagrange’s theorem.
  prefs: []
  type: TYPE_NORMAL
- en: While this corner of Mathlib is partly set up to allow computation, we can tell
    Lean to use nonconstructive logic anyway using the following `open scoped` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: The next two exercises derive a corollary of Lagrange’s lemma. (This is also
    already in Mathlib, so do not use `exact?` too quickly.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.4\. Concrete groups[](#concrete-groups "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One can also manipulate concrete groups in Mathlib, although this is typically
    more complicated than working with the abstract theory. For instance, given any
    type `X`, the group of permutations of `X` is `Equiv.Perm X`. In particular the
    symmetric group \(\mathfrak{S}_n\) is `Equiv.Perm (Fin n)`. One can state abstract
    results about this group, for instance saying that `Equiv.Perm X` is generated
    by cycles if `X` is finite.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: 'One can be fully concrete and compute actual products of cycles. Below we use
    the `#simp` command, which calls the `simp` tactic on a given expression. The
    notation `c[]` is used to define a cyclic permutation. In the example, the result
    is a permutation of `ℕ`. One could use a type ascription such as `(1 : Fin 5)`
    on the first number appearing to make it a computation in `Perm (Fin 5)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to work with concrete groups is to use free groups and group presentations.
    The free group on a type `α` is `FreeGroup α` and the inclusion map is `FreeGroup.of
    : α → FreeGroup α`. For instance let us define a type `S` with three elements
    denoted by `a`, `b` and `c`, and the element `ab⁻¹` of the corresponding free
    group.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: Note that we gave the expected type of the definition so that Lean knows that
    `.of` means `FreeGroup.of`.
  prefs: []
  type: TYPE_NORMAL
- en: The universal property of free groups is embodied as the equivalence `FreeGroup.lift`.
    For example, let us define the group morphism from `FreeGroup S` to `Perm (Fin
    5)` that sends `a` to `c[1, 2, 3]`, `b` to `c[2, 3, 1]`, and `c` to `c[2, 3]`,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: As a last concrete example, let us see how to define a group generated by a
    single element whose cube is one (so that group will be isomorphic to \(\mathbb{Z}/3\))
    and build a morphism from that group to `Perm (Fin 5)`.
  prefs: []
  type: TYPE_NORMAL
- en: As a type with exactly one element, we will use `Unit` whose only element is
    denoted by `()`. The function `PresentedGroup` takes a set of relations, i.e.
    a set of elements of some free group, and returns a group that is this free group
    quotiented by a normal subgroup generated by relations. (We will see how to handle
    more general quotients in [Section 9.1.6](#quotient-groups).) Since we somehow
    hide this behind a definition, we use `deriving Group` to force creation of a
    group instance on `myGroup`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: The universal property of presented groups ensures that morphisms out of this
    group can be built from functions that send the relations to the neutral element
    of the target group. So we need such a function and a proof that the condition
    holds. Then we can feed this proof to `PresentedGroup.toGroup` to get the desired
    group morphism.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.5\. Group actions[](#group-actions "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One important way that group theory interacts with the rest of mathematics is
    through the use of group actions. An action of a group `G` on some type `X` is
    nothing more than a morphism from `G` to `Equiv.Perm X`. So in a sense group actions
    are already covered by the previous discussion. But we don’t want to carry this
    morphism around; instead, we want it to be inferred automatically by Lean as much
    as possible. So we have a type class for this, which is `MulAction G X`. The downside
    of this setup is that having multiple actions of the same group on the same type
    requires some contortions, such as defining type synonyms, each of which carries
    different type class instances.
  prefs: []
  type: TYPE_NORMAL
- en: This allows us in particular to use `g • x` to denote the action of a group
    element `g` on a point `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: There is also a version for additive group called `AddAction`, where the action
    is denoted by `+ᵥ`. This is used for instance in the definition of affine spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: The underlying group morphism is called `MulAction.toPermHom`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: As an illustration let us see how to define the Cayley isomorphism embedding
    of any group `G` into a permutation group, namely `Perm G`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: Note that nothing before the above definition required having a group rather
    than a monoid (or any type endowed with a multiplication operation really).
  prefs: []
  type: TYPE_NORMAL
- en: The group condition really enters the picture when we will want to partition
    `X` into orbits. The corresponding equivalence relation on `X` is called `MulAction.orbitRel`.
    It is not declared as a global instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this we can state that `X` is partitioned into orbits under the action
    of `G`. More precisely, we get a bijection between `X` and the dependent product
    `(ω : orbitRel.Quotient G X) × (orbit G (Quotient.out'' ω))` where `Quotient.out''
    ω` simply chooses an element that projects to `ω`. Recall that elements of this
    dependent product are pairs `⟨ω, x⟩` where the type `orbit G (Quotient.out'' ω)`
    of `x` depends on `ω`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: In particular, when X is finite, this can be combined with `Fintype.card_congr`
    and `Fintype.card_sigma` to deduce that the cardinality of `X` is the sum of the
    cardinalities of the orbits. Furthermore, the orbits are in bijection with the
    quotient of `G` under the action of the stabilizers by left translation. This
    action of a subgroup by left-translation is used to define quotients of a group
    by a subgroup with notation / so we can use the following concise statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: 'An important special case of combining the above two results is when `X` is
    a group `G` equipped with the action of a subgroup `H` by translation. In this
    case all stabilizers are trivial so every orbit is in bijection with `H` and we
    get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: This is the conceptual variant of the version of Lagrange theorem that we saw
    above. Note this version makes no finiteness assumption.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise for this section, let us build the action of a group on its subgroup
    by conjugation, using our definition of `conjugate` from a previous exercise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '### 9.1.6\. Quotient groups[](#quotient-groups "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: In the above discussion of subgroups acting on groups, we saw the quotient `G
    ⧸ H` appear. In general this is only a type. It can be endowed with a group structure
    such that the quotient map is a group morphism if and only if `H` is a normal
    subgroup (and this group structure is then unique).
  prefs: []
  type: TYPE_NORMAL
- en: The normality assumption is a type class `Subgroup.Normal` so that type class
    inference can use it to derive the group structure on the quotient.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'The universal property of quotient groups is accessed through `QuotientGroup.lift`:
    a group morphism `φ` descends to `G ⧸ N` as soon as its kernel contains `N`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: The fact that the target group is called `M` is the above snippet is a clue
    that having a monoid structure on `M` would be enough.
  prefs: []
  type: TYPE_NORMAL
- en: An important special case is when `N = ker φ`. In that case the descended morphism
    is injective and we get a group isomorphism onto its image. This result is often
    called the first isomorphism theorem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying the universal property to a composition of a morphism `φ : G →* G''`
    with a quotient group projection `Quotient.mk'' N''`, we can also aim for a morphism
    from `G ⧸ N` to `G'' ⧸ N''`. The condition required on `φ` is usually formulated
    by saying “`φ` should send `N` inside `N''`.” But this is equivalent to asking
    that `φ` should pull `N''` back over `N`, and the latter condition is nicer to
    work with since the definition of pullback does not involve an existential quantifier.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: One subtle point to keep in mind is that the type `G ⧸ N` really depends on
    `N` (up to definitional equality), so having a proof that two normal subgroups
    `N` and `M` are equal is not enough to make the corresponding quotients equal.
    However the universal properties does give an isomorphism in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: As a final series of exercises for this section, we will prove that if `H` and
    `K` are disjoint normal subgroups of a finite group `G` such that the product
    of their cardinalities is equal to the cardinality of `G` then `G` is isomorphic
    to `H × K`. Recall that disjoint in this context means `H ⊓ K = ⊥`.
  prefs: []
  type: TYPE_NORMAL
- en: We start with playing a bit with Lagrange’s lemma, without assuming the subgroups
    are normal or disjoint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: From now on, we assume that our subgroups are normal and disjoint, and we assume
    the cardinality condition. Now we construct the first building block of the desired
    isomorphism.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: Now we can define our second building block. We will need `MonoidHom.prod`,
    which builds a morphism from `G₀` to `G₁ × G₂` out of morphisms from `G₀` to `G₁`
    and `G₂`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: We are ready to put all pieces together.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '## 9.2\. Rings[](#rings "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: '### 9.2.1\. Rings, their units, morphisms and subrings[](#rings-their-units-morphisms-and-subrings
    "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: The type of ring structures on a type `R` is `Ring R`. The variant where multiplication
    is assumed to be commutative is `CommRing R`. We have already seen that the `ring`
    tactic will prove any equality that follows from the axioms of a commutative ring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: More exotic variants do not require that the addition on `R` forms a group but
    only an additive monoid. The corresponding type classes are `Semiring R` and `CommSemiring
    R`. The type of natural numbers is an important instance of `CommSemiring R`,
    as is any type of functions taking values in the natural numbers. Another important
    example is the type of ideals in a ring, which will be discussed below. The name
    of the `ring` tactic is doubly misleading, since it assumes commutativity but
    works in semirings as well. In other words, it applies to any `CommSemiring`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: There are also versions of the ring and semiring classes that do not assume
    the existence of a multiplicative unit or the associativity of multiplication.
    We will not discuss those here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some concepts that are traditionally taught in an introduction to ring theory
    are actually about the underlying multiplicative monoid. A prominent example is
    the definition of the units of a ring. Every (multiplicative) monoid `M` has a
    predicate `IsUnit : M → Prop` asserting existence of a two-sided inverse, a type
    `Units M` of units with notation `Mˣ`, and a coercion to `M`. The type `Units
    M` bundles an invertible element with its inverse as well as properties than ensure
    that each is indeed the inverse of the other. This implementation detail is relevant
    mainly when defining computable functions. In most situations one can use `IsUnit.unit
    {x : M} : IsUnit x → Mˣ` to build a unit. In the commutative case, one also has
    `Units.mkOfMulEqOne (x y : M) : x * y = 1 → Mˣ` which builds `x` seen as unit.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: The type of ring morphisms between two (semi)-rings `R` and `S` is `RingHom
    R S`, with notation `R →+* S`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: The isomorphism variant is `RingEquiv`, with notation `≃+*`.
  prefs: []
  type: TYPE_NORMAL
- en: As with submonoids and subgroups, there is a `Subring R` type for subrings of
    a ring `R`, but this type is a lot less useful than the type of subgroups since
    one cannot quotient a ring by a subring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: Also notice that `RingHom.range` produces a subring.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.2\. Ideals and quotients[](#ideals-and-quotients "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For historical reasons, Mathlib only has a theory of ideals for commutative
    rings. (The ring library was originally developed to make quick progress toward
    the foundations of modern algebraic geometry.) So in this section we will work
    with commutative (semi)rings. Ideals of `R` are defined as submodules of `R` seen
    as `R`-modules. Modules will be covered later in a chapter on linear algebra,
    but this implementation detail can mostly be safely ignored since most (but not
    all) relevant lemmas are restated in the special context of ideals. But anonymous
    projection notation won’t always work as expected. For instance, one cannot replace
    `Ideal.Quotient.mk I` by `I.Quotient.mk` in the snippet below because there are
    two `.`s and so it will parse as `(Ideal.Quotient I).mk`; but `Ideal.Quotient`
    by itself doesn’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: The universal property of quotient rings is `Ideal.Quotient.lift`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: In particular it leads to the first isomorphism theorem for rings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: Ideals form a complete lattice structure with the inclusion relation, as well
    as a semiring structure. These two structures interact nicely.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: One can use ring morphisms to push ideals forward and pull them back using `Ideal.map`
    and `Ideal.comap`, respectively. As usual, the latter is more convenient to use
    since it does not involve an existential quantifier. This explains why it is used
    to state the condition that allows us to build morphisms between quotient rings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: One subtle point is that the type `R ⧸ I` really depends on `I` (up to definitional
    equality), so having a proof that two ideals `I` and `J` are equal is not enough
    to make the corresponding quotients equal. However, the universal properties do
    provide an isomorphism in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: We can now present the Chinese remainder isomorphism as an example. Pay attention
    to the difference between the indexed infimum symbol `⨅` and the big product of
    types symbol `Π`. Depending on your font, those can be pretty hard to distinguish.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: 'The elementary version of the Chinese remainder theorem, a statement about
    `ZMod`, can be easily deduced from the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: As a series of exercises, we will reprove the Chinese remainder theorem in the
    general case.
  prefs: []
  type: TYPE_NORMAL
- en: We first need to define the map appearing in the theorem, as a ring morphism,
    using the universal property of quotient rings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the following next two lemmas can be proven by `rfl`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: The next lemma proves the easy half of the Chinese remainder theorem, without
    any assumption on the family of ideals. The proof is less than one line long.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready for the heart of the theorem, which will show the surjectivity
    of our `chineseMap`. First we need to know the different ways one can express
    the coprimality (also called co-maximality assumption). Only the first two will
    be needed below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: We take the opportunity to use induction on `Finset`. Relevant lemmas on `Finset`
    are given below. Remember that the `ring` tactic works for semirings and that
    the ideals of a ring form a semiring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: We can now prove surjectivity of the map appearing in the Chinese remainder
    theorem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all the pieces come together in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: 9.2.3\. Algebras and polynomials[](#algebras-and-polynomials "Link to this
    heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Given a commutative (semi)ring `R`, an *algebra over* `R` is a semiring `A`
    equipped with a ring morphism whose image commutes with every element of `A`.
    This is encoded as a type class `Algebra R A`. The morphism from `R` to `A` is
    called the structure map and is denoted `algebraMap R A : R →+* A` in Lean. Multiplication
    of `a : A` by `algebraMap R A r` for some `r : R` is called the scalar multiplication
    of `a` by `r` and denoted by `r • a`. Note that this notion of algebra is sometimes
    called an *associative unital algebra* to emphasize the existence of more general
    notions of algebra.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that `algebraMap R A` is ring morphism packages together a lot of
    properties of scalar multiplication, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: The morphisms between two `R`-algebras `A` and `B` are ring morphisms which
    commute with scalar multiplication by elements of `R`. They are bundled morphisms
    with type `AlgHom R A B`, which is denoted by `A →ₐ[R] B`.
  prefs: []
  type: TYPE_NORMAL
- en: Important examples of non-commutative algebras include algebras of endomorphisms
    and algebras of square matrices, both of which will be covered in the chapter
    on linear algebra. In this chapter we will discuss one of the most important examples
    of a commutative algebra, namely, polynomial algebras.
  prefs: []
  type: TYPE_NORMAL
- en: The algebra of univariate polynomials with coefficients in `R` is called `Polynomial
    R`, which can be written as `R[X]` as soon as one opens the `Polynomial` namespace.
    The algebra structure map from `R` to `R[X]` is denoted by `C`, which stands for
    “constant” since the corresponding polynomial functions are always constant. The
    indeterminate is denoted by `X`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: In the first example above, it is crucial that we give Lean the expected type
    since it cannot be determined from the body of the definition. In the second example,
    the target polynomial algebra can be inferred from our use of `C r` since the
    type of `r` is known.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `C` is a ring morphism from `R` to `R[X]`, we can use all ring morphisms
    lemmas such as `map_zero`, `map_one`, `map_mul`, and `map_pow` before computing
    in the ring `R[X]`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: You can access coefficients using `Polynomial.coeff`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: 'Defining the degree of a polynomial is always tricky because of the special
    case of the zero polynomial. Mathlib has two variants: `Polynomial.natDegree :
    R[X] → ℕ` assigns degree `0` to the zero polynomial, and `Polynomial.degree :
    R[X] → WithBot ℕ` assigns `⊥`. In the latter, `WithBot ℕ` can be seen as `ℕ ∪
    {-∞}`, except that `-∞` is denoted `⊥`, the same symbol as the bottom element
    in a complete lattice. This special value is used as the degree of the zero polynomial,
    and it is absorbent for addition. (It is almost absorbent for multiplication,
    except that `⊥ * 0 = 0`.)'
  prefs: []
  type: TYPE_NORMAL
- en: Morally speaking, the `degree` version is the correct one. For instance, it
    allows us to state the expected formula for the degree of a product (assuming
    the base ring has no zero divisor).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: Whereas the version for `natDegree` needs to assume non-zero polynomials.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `ℕ` is much nicer to use than `WithBot ℕ`, so Mathlib makes both versions
    available and provides lemmas to convert between them. Also, `natDegree` is the
    more convenient definition to use when computing the degree of a composition.
    Composition of polynomial is `Polynomial.comp` and we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: 'Polynomials give rise to polynomial functions: any polynomial can be evaluated
    on `R` using `Polynomial.eval`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: In particular, there is a predicate, `IsRoot`, that holds for elements `r` in
    `R` where a polynomial vanishes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: We would like to say that, assuming `R` has no zero divisor, a polynomial has
    at most as many roots as its degree, where the roots are counted with multiplicities.
    But once again the case of the zero polynomial is painful. So Mathlib defines
    `Polynomial.roots` to send a polynomial `P` to a multiset, i.e. the finite set
    that is defined to be empty if `P` is zero and the roots of `P`, with multiplicities,
    otherwise. This is defined only when the underlying ring is a domain since otherwise
    the definition does not have good properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `Polynomial.eval` and `Polynomial.roots` consider only the coefficients
    ring. They do not allow us to say that `X ^ 2 - 2 : ℚ[X]` has a root in `ℝ` or
    that `X ^ 2 + 1 : ℝ[X]` has a root in `ℂ`. For this, we need `Polynomial.aeval`,
    which will evaluate `P : R[X]` in any `R`-algebra. More precisely, given a semiring
    `A` and an instance of `Algebra R A`, `Polynomial.aeval` sends every element of
    `a` along the `R`-algebra morphism of evaluation at `a`. Since `AlgHom` has a
    coercion to functions, one can apply it to a polynomial. But `aeval` does not
    have a polynomial as an argument, so one cannot use dot notation like in `P.eval`
    above.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: The function corresponding to `roots` in this context is `aroots` which takes
    a polynomial and then an algebra and outputs a multiset (with the same caveat
    about the zero polynomial as for `roots`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: 'More generally, given an ring morphism `f : R →+* S` one can evaluate `P :
    R[X]` at a point in `S` using `Polynomial.eval₂`. This one produces an actual
    function from `R[X]` to `S` since it does not assume the existence of a `Algebra
    R S` instance, so dot notation works as you would expect.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us end by mentioning multivariate polynomials briefly. Given a commutative
    semiring `R`, the `R`-algebra of polynomials with coefficients in `R` and indeterminates
    indexed by a type `σ` is `MVPolynomial σ R`. Given `i : σ`, the corresponding
    polynomial is `MvPolynomial.X i`. (As usual, one can open the `MVPolynomial` namespace
    to shorten this to `X i`.) For instance, if we want two indeterminates we can
    use `Fin 2` as `σ` and write the polynomial defining the unit circle in \(\mathbb{R}^2`\)
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: Recall that function application has a very high precedence so the expression
    above is read as `(X 0) ^ 2 + (X 1) ^ 2 - 1`. We can evaluate it to make sure
    the point with coordinates \((1, 0)\) is on the circle. Recall the `![...]` notation
    denotes elements of `Fin n → X` for some natural number `n` determined by the
    number of arguments and some type `X` determined by the type of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '### 9.2.1\. Rings, their units, morphisms and subrings[](#rings-their-units-morphisms-and-subrings
    "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: The type of ring structures on a type `R` is `Ring R`. The variant where multiplication
    is assumed to be commutative is `CommRing R`. We have already seen that the `ring`
    tactic will prove any equality that follows from the axioms of a commutative ring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: More exotic variants do not require that the addition on `R` forms a group but
    only an additive monoid. The corresponding type classes are `Semiring R` and `CommSemiring
    R`. The type of natural numbers is an important instance of `CommSemiring R`,
    as is any type of functions taking values in the natural numbers. Another important
    example is the type of ideals in a ring, which will be discussed below. The name
    of the `ring` tactic is doubly misleading, since it assumes commutativity but
    works in semirings as well. In other words, it applies to any `CommSemiring`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: There are also versions of the ring and semiring classes that do not assume
    the existence of a multiplicative unit or the associativity of multiplication.
    We will not discuss those here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some concepts that are traditionally taught in an introduction to ring theory
    are actually about the underlying multiplicative monoid. A prominent example is
    the definition of the units of a ring. Every (multiplicative) monoid `M` has a
    predicate `IsUnit : M → Prop` asserting existence of a two-sided inverse, a type
    `Units M` of units with notation `Mˣ`, and a coercion to `M`. The type `Units
    M` bundles an invertible element with its inverse as well as properties than ensure
    that each is indeed the inverse of the other. This implementation detail is relevant
    mainly when defining computable functions. In most situations one can use `IsUnit.unit
    {x : M} : IsUnit x → Mˣ` to build a unit. In the commutative case, one also has
    `Units.mkOfMulEqOne (x y : M) : x * y = 1 → Mˣ` which builds `x` seen as unit.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: The type of ring morphisms between two (semi)-rings `R` and `S` is `RingHom
    R S`, with notation `R →+* S`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: The isomorphism variant is `RingEquiv`, with notation `≃+*`.
  prefs: []
  type: TYPE_NORMAL
- en: As with submonoids and subgroups, there is a `Subring R` type for subrings of
    a ring `R`, but this type is a lot less useful than the type of subgroups since
    one cannot quotient a ring by a subring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: Also notice that `RingHom.range` produces a subring.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.2\. Ideals and quotients[](#ideals-and-quotients "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For historical reasons, Mathlib only has a theory of ideals for commutative
    rings. (The ring library was originally developed to make quick progress toward
    the foundations of modern algebraic geometry.) So in this section we will work
    with commutative (semi)rings. Ideals of `R` are defined as submodules of `R` seen
    as `R`-modules. Modules will be covered later in a chapter on linear algebra,
    but this implementation detail can mostly be safely ignored since most (but not
    all) relevant lemmas are restated in the special context of ideals. But anonymous
    projection notation won’t always work as expected. For instance, one cannot replace
    `Ideal.Quotient.mk I` by `I.Quotient.mk` in the snippet below because there are
    two `.`s and so it will parse as `(Ideal.Quotient I).mk`; but `Ideal.Quotient`
    by itself doesn’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: The universal property of quotient rings is `Ideal.Quotient.lift`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: In particular it leads to the first isomorphism theorem for rings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: Ideals form a complete lattice structure with the inclusion relation, as well
    as a semiring structure. These two structures interact nicely.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: One can use ring morphisms to push ideals forward and pull them back using `Ideal.map`
    and `Ideal.comap`, respectively. As usual, the latter is more convenient to use
    since it does not involve an existential quantifier. This explains why it is used
    to state the condition that allows us to build morphisms between quotient rings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: One subtle point is that the type `R ⧸ I` really depends on `I` (up to definitional
    equality), so having a proof that two ideals `I` and `J` are equal is not enough
    to make the corresponding quotients equal. However, the universal properties do
    provide an isomorphism in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: We can now present the Chinese remainder isomorphism as an example. Pay attention
    to the difference between the indexed infimum symbol `⨅` and the big product of
    types symbol `Π`. Depending on your font, those can be pretty hard to distinguish.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: 'The elementary version of the Chinese remainder theorem, a statement about
    `ZMod`, can be easily deduced from the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: As a series of exercises, we will reprove the Chinese remainder theorem in the
    general case.
  prefs: []
  type: TYPE_NORMAL
- en: We first need to define the map appearing in the theorem, as a ring morphism,
    using the universal property of quotient rings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the following next two lemmas can be proven by `rfl`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: The next lemma proves the easy half of the Chinese remainder theorem, without
    any assumption on the family of ideals. The proof is less than one line long.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready for the heart of the theorem, which will show the surjectivity
    of our `chineseMap`. First we need to know the different ways one can express
    the coprimality (also called co-maximality assumption). Only the first two will
    be needed below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: We take the opportunity to use induction on `Finset`. Relevant lemmas on `Finset`
    are given below. Remember that the `ring` tactic works for semirings and that
    the ideals of a ring form a semiring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: We can now prove surjectivity of the map appearing in the Chinese remainder
    theorem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all the pieces come together in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: 9.2.3\. Algebras and polynomials[](#algebras-and-polynomials "Link to this
    heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Given a commutative (semi)ring `R`, an *algebra over* `R` is a semiring `A`
    equipped with a ring morphism whose image commutes with every element of `A`.
    This is encoded as a type class `Algebra R A`. The morphism from `R` to `A` is
    called the structure map and is denoted `algebraMap R A : R →+* A` in Lean. Multiplication
    of `a : A` by `algebraMap R A r` for some `r : R` is called the scalar multiplication
    of `a` by `r` and denoted by `r • a`. Note that this notion of algebra is sometimes
    called an *associative unital algebra* to emphasize the existence of more general
    notions of algebra.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that `algebraMap R A` is ring morphism packages together a lot of
    properties of scalar multiplication, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: The morphisms between two `R`-algebras `A` and `B` are ring morphisms which
    commute with scalar multiplication by elements of `R`. They are bundled morphisms
    with type `AlgHom R A B`, which is denoted by `A →ₐ[R] B`.
  prefs: []
  type: TYPE_NORMAL
- en: Important examples of non-commutative algebras include algebras of endomorphisms
    and algebras of square matrices, both of which will be covered in the chapter
    on linear algebra. In this chapter we will discuss one of the most important examples
    of a commutative algebra, namely, polynomial algebras.
  prefs: []
  type: TYPE_NORMAL
- en: The algebra of univariate polynomials with coefficients in `R` is called `Polynomial
    R`, which can be written as `R[X]` as soon as one opens the `Polynomial` namespace.
    The algebra structure map from `R` to `R[X]` is denoted by `C`, which stands for
    “constant” since the corresponding polynomial functions are always constant. The
    indeterminate is denoted by `X`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: In the first example above, it is crucial that we give Lean the expected type
    since it cannot be determined from the body of the definition. In the second example,
    the target polynomial algebra can be inferred from our use of `C r` since the
    type of `r` is known.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `C` is a ring morphism from `R` to `R[X]`, we can use all ring morphisms
    lemmas such as `map_zero`, `map_one`, `map_mul`, and `map_pow` before computing
    in the ring `R[X]`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: You can access coefficients using `Polynomial.coeff`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: 'Defining the degree of a polynomial is always tricky because of the special
    case of the zero polynomial. Mathlib has two variants: `Polynomial.natDegree :
    R[X] → ℕ` assigns degree `0` to the zero polynomial, and `Polynomial.degree :
    R[X] → WithBot ℕ` assigns `⊥`. In the latter, `WithBot ℕ` can be seen as `ℕ ∪
    {-∞}`, except that `-∞` is denoted `⊥`, the same symbol as the bottom element
    in a complete lattice. This special value is used as the degree of the zero polynomial,
    and it is absorbent for addition. (It is almost absorbent for multiplication,
    except that `⊥ * 0 = 0`.)'
  prefs: []
  type: TYPE_NORMAL
- en: Morally speaking, the `degree` version is the correct one. For instance, it
    allows us to state the expected formula for the degree of a product (assuming
    the base ring has no zero divisor).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: Whereas the version for `natDegree` needs to assume non-zero polynomials.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `ℕ` is much nicer to use than `WithBot ℕ`, so Mathlib makes both versions
    available and provides lemmas to convert between them. Also, `natDegree` is the
    more convenient definition to use when computing the degree of a composition.
    Composition of polynomial is `Polynomial.comp` and we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: 'Polynomials give rise to polynomial functions: any polynomial can be evaluated
    on `R` using `Polynomial.eval`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: In particular, there is a predicate, `IsRoot`, that holds for elements `r` in
    `R` where a polynomial vanishes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: We would like to say that, assuming `R` has no zero divisor, a polynomial has
    at most as many roots as its degree, where the roots are counted with multiplicities.
    But once again the case of the zero polynomial is painful. So Mathlib defines
    `Polynomial.roots` to send a polynomial `P` to a multiset, i.e. the finite set
    that is defined to be empty if `P` is zero and the roots of `P`, with multiplicities,
    otherwise. This is defined only when the underlying ring is a domain since otherwise
    the definition does not have good properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `Polynomial.eval` and `Polynomial.roots` consider only the coefficients
    ring. They do not allow us to say that `X ^ 2 - 2 : ℚ[X]` has a root in `ℝ` or
    that `X ^ 2 + 1 : ℝ[X]` has a root in `ℂ`. For this, we need `Polynomial.aeval`,
    which will evaluate `P : R[X]` in any `R`-algebra. More precisely, given a semiring
    `A` and an instance of `Algebra R A`, `Polynomial.aeval` sends every element of
    `a` along the `R`-algebra morphism of evaluation at `a`. Since `AlgHom` has a
    coercion to functions, one can apply it to a polynomial. But `aeval` does not
    have a polynomial as an argument, so one cannot use dot notation like in `P.eval`
    above.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: The function corresponding to `roots` in this context is `aroots` which takes
    a polynomial and then an algebra and outputs a multiset (with the same caveat
    about the zero polynomial as for `roots`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: 'More generally, given an ring morphism `f : R →+* S` one can evaluate `P :
    R[X]` at a point in `S` using `Polynomial.eval₂`. This one produces an actual
    function from `R[X]` to `S` since it does not assume the existence of a `Algebra
    R S` instance, so dot notation works as you would expect.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us end by mentioning multivariate polynomials briefly. Given a commutative
    semiring `R`, the `R`-algebra of polynomials with coefficients in `R` and indeterminates
    indexed by a type `σ` is `MVPolynomial σ R`. Given `i : σ`, the corresponding
    polynomial is `MvPolynomial.X i`. (As usual, one can open the `MVPolynomial` namespace
    to shorten this to `X i`.) For instance, if we want two indeterminates we can
    use `Fin 2` as `σ` and write the polynomial defining the unit circle in \(\mathbb{R}^2`\)
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: Recall that function application has a very high precedence so the expression
    above is read as `(X 0) ^ 2 + (X 1) ^ 2 - 1`. We can evaluate it to make sure
    the point with coordinates \((1, 0)\) is on the circle. Recall the `![...]` notation
    denotes elements of `Fin n → X` for some natural number `n` determined by the
    number of arguments and some type `X` determined by the type of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]*'
  prefs: []
  type: TYPE_NORMAL
