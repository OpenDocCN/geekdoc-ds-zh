["```cpp\nstruct r {  int x, y; };   r operator+(r a, r b) { return {a.x * b.y + a.y * b.x, a.y * b.y}; } r operator*(r a, r b) { return {a.x * b.x, a.y * b.y}; } r operator/(r a, r b) { return {a.x * b.x, a.y * b.y}; } bool operator<(r a, r b) { return a.x * b.y < b.x * a.y; } // ...and so on, you get the idea \n```", "```cpp\nstruct r {  int x, y; r(int x, int y) : x(x), y(y) { if (y < 0) x = -x, y = -y; int g = gcd(x, y); x /= g; y /= g; } }; \n```", "```cpp\nstruct money {  uint v; // 1/10000th of a dollar };   std::string to_string(money) {  return std::format(\"${0}.{1:04d}\", v / 10000, v % 10000); }   money operator*(money x, money y) { return {x.v * y.v / 10000}; } \n```", "```cpp\n// DIY floating-point number struct fp {  int m; // mantissa int e; // exponent }; \n```", "```cpp\nstruct fp {  bool s;     // sign: \"0\" for \"+\", \"1\" for \"-\" unsigned m; // mantissa int e;      // exponent }; \n```", "```cpp\nfp operator*(fp a, fp b) {  fp c; c.s = a.s ^ b.s; c.e = a.e + b.e;  uint64_t x = a.m, y = b.m; // casting to wider types uint64_t m = (x << 31) + (y << 31) + x * y; // 62- or 63-bit intermediate result if (m & (1<<62)) { // checking for overflow m -= (1<<62); // m -= 1; m >>= 1; c.e++; } m += (1<<30); // \"rounding\" by adding 0.5 to a value that will be floored next c.m = m >> 31;  return c; } \n```"]