- en: 11.1Â File Input and Output in PythonðŸ”—
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: åŽŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/python-fileio.html](https://dcic-world.org/2025-08-27/python-fileio.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Â Â Â Â [11.1.1Â Basic File Operations](#%28part._.Basic_.File_.Operations%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [11.1.2Â Reading CSV Files Step by Step](#%28part._.Reading_.C.S.V_.Files_.Step_by_.Step%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [11.1.3Â Processing and Filtering Data](#%28part._.Processing_and_.Filtering_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [11.1.4Â Writing CSV Files](#%28part._.Writing_.C.S.V_.Files%29) |'
  prefs: []
  type: TYPE_TB
- en: 'In [Introduction to Pandas](python-tables-Pandas.html), we loaded data from
    CSV (comma-separated value) files, but we let Pandas handle the low-level details:
    reading files and converting their contents into DataFrames.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, weâ€™ll learn to read and write files using Pythonâ€™s basic file
    operations, using a simplified CSV processor as an example.
  prefs: []
  type: TYPE_NORMAL
- en: While Pandas can certainly do all that we will do in this chapter (and more!),
    understanding how file operations work helps you become a more complete programmer,
    and to one day perhaps either create or work on libraries like Pandas.
  prefs: []
  type: TYPE_NORMAL
- en: 11.1.1Â Basic File Operations[ðŸ”—](#(part._.Basic_.File_.Operations) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Python provides built-in functions for working with files. Before you can do
    anything else with a file, you must "open" it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This statement opens a file named `'data.csv'` in read mode (`'r'`). The `open`
    function returns a file object that we can use to read from or (if it were opened
    in the appropriate mode) write to the file.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you think would happen if you tried to open a file that doesnâ€™t exist?
    Try it and see what error message you get.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Once we have a file object, we can read its contents in one of several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Important: the file object remembers where in the file it is reading. This
    is how calling `.readline()` twice doesnâ€™t return the same line, it returns one
    line, and then the next. But, this also means that if you ran either `.read()`
    or `.readlines()`, you would have read the entire file, which means the position
    of the file object is now at the end, which means calling any of the other methods
    would return empty results â€“ empty strings for `.read()` or `.readline()`, and
    an empty list for `.readlines()`. You can move where the file object is pointing,
    with `.seek()`, but how that works is beyond our scope!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When weâ€™re done using a file, we should always close it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do you think it might be important to close files when youâ€™re done with
    them?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Closing files is important because it frees up system resources and ensures
    that, if we were writing to the file (unlike in this example, where we are only
    reading) all pending writes actually get saved! However, manually remembering
    to close files can be error-prone. Python provides a more reliable way using the
    `with` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In addition to not making us remember to close the files, it this approach also
    guarantees that the file will be closed even if an error occurs while processing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 11.1.2Â Reading CSV Files Step by Step[ðŸ”—](#(part._.Reading_.C.S.V_.Files_.Step_by_.Step)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Letâ€™s work through reading a CSV file manually, as a way to practice using files
    for a practical (if small) example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a file called `orders.csv` with the following contents: (You
    can create this file with your editor of choice â€“ e.g., VSCode).'
  prefs: []
  type: TYPE_NORMAL
- en: '| dish,quantity,price,order_type |'
  prefs: []
  type: TYPE_TB
- en: '| Pizza,2,25.0,dine-in |'
  prefs: []
  type: TYPE_TB
- en: '| Salad,1,8.75,takeout |'
  prefs: []
  type: TYPE_TB
- en: '| Burger,3,30.0,dine-in |'
  prefs: []
  type: TYPE_TB
- en: '| Pizza,1,12.50,takeout |'
  prefs: []
  type: TYPE_TB
- en: 'Hereâ€™s how we can read and parse this file step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Letâ€™s break down what each step does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`file.readlines()` reads all lines from the file into a list of strings'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use a for loop to go through each line, using `line.strip()` to remove the
    newline character (`'\n'`) from the end of each line and then turning the line
    into a list of strings by `.split(',')`, which divides the string by the given
    string (which is not included).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We separate the first row (header) from the data rows for easier processing
    â€“ the notation `data[1:]` is a special way of indicating we want "from index 1
    until as far as the list goes â€“ i.e., the end of the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What would our code do if one of the cells in your CSV contained a comma? For
    example, what if a dish name was "Mac and cheese, deluxe"? How could you handle
    this?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 11.1.3Â Processing and Filtering Data[ðŸ”—](#(part._.Processing_and_.Filtering_.Data)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once we have our data as a list of lists, we can process it using the same programming
    techniques weâ€™ve learned, by using the `.index()` method to return the numeric
    offset of the given string in a list of strings â€“ this is how we will find the
    columns we are interested in, and then use that to index into the row.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, letâ€™s filter for only takeout orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also convert data types as needed. For instance, if we want to calculate
    total revenue, we need to not only find the quantity and price for each row, but
    convert the strings that are in the row (since the file was all strings!) to numbers
    before multiplying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What would happen if one of the quantity cells contained invalid data, like
    the string "three" instead of the number 3? How could you make your code more
    robust to handle such errors?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 11.1.4Â Writing CSV Files[ðŸ”—](#(part._.Writing_.C.S.V_.Files) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing CSV files follows a similar pattern. We need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a file in write mode
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert our data to the proper string format
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the strings to the file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hereâ€™s how to write our filtered takeout orders to a new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The key steps here are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`'',''.join(row)` combines the list elements into a single string with commas
    between them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We add `'\n'` to create a new line after each row
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file.write()` writes the string to the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we call `.write()` once for each line â€“ we could have combined all
    the lines into a single string, and only called `.write()` once, but there is
    no need to â€“ just like how file objects remember where we are reading from them,
    they remember where we were writing, so the next call to `.write()` will add the
    next string after the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try writing a program that reads a CSV file, adds a new column with calculated
    values (like total price = quantity Ã— price), and writes the result to a new file.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 11.1.1Â Basic File Operations[ðŸ”—](#(part._.Basic_.File_.Operations) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Python provides built-in functions for working with files. Before you can do
    anything else with a file, you must "open" it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This statement opens a file named `'data.csv'` in read mode (`'r'`). The `open`
    function returns a file object that we can use to read from or (if it were opened
    in the appropriate mode) write to the file.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you think would happen if you tried to open a file that doesnâ€™t exist?
    Try it and see what error message you get.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Once we have a file object, we can read its contents in one of several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Important: the file object remembers where in the file it is reading. This
    is how calling `.readline()` twice doesnâ€™t return the same line, it returns one
    line, and then the next. But, this also means that if you ran either `.read()`
    or `.readlines()`, you would have read the entire file, which means the position
    of the file object is now at the end, which means calling any of the other methods
    would return empty results â€“ empty strings for `.read()` or `.readline()`, and
    an empty list for `.readlines()`. You can move where the file object is pointing,
    with `.seek()`, but how that works is beyond our scope!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When weâ€™re done using a file, we should always close it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do you think it might be important to close files when youâ€™re done with
    them?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Closing files is important because it frees up system resources and ensures
    that, if we were writing to the file (unlike in this example, where we are only
    reading) all pending writes actually get saved! However, manually remembering
    to close files can be error-prone. Python provides a more reliable way using the
    `with` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In addition to not making us remember to close the files, it this approach also
    guarantees that the file will be closed even if an error occurs while processing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 11.1.2Â Reading CSV Files Step by Step[ðŸ”—](#(part._.Reading_.C.S.V_.Files_.Step_by_.Step)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Letâ€™s work through reading a CSV file manually, as a way to practice using files
    for a practical (if small) example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a file called `orders.csv` with the following contents: (You
    can create this file with your editor of choice â€“ e.g., VSCode).'
  prefs: []
  type: TYPE_NORMAL
- en: '| dish,quantity,price,order_type |'
  prefs: []
  type: TYPE_TB
- en: '| Pizza,2,25.0,dine-in |'
  prefs: []
  type: TYPE_TB
- en: '| Salad,1,8.75,takeout |'
  prefs: []
  type: TYPE_TB
- en: '| Burger,3,30.0,dine-in |'
  prefs: []
  type: TYPE_TB
- en: '| Pizza,1,12.50,takeout |'
  prefs: []
  type: TYPE_TB
- en: 'Hereâ€™s how we can read and parse this file step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Letâ€™s break down what each step does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`file.readlines()` reads all lines from the file into a list of strings'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use a for loop to go through each line, using `line.strip()` to remove the
    newline character (`'\n'`) from the end of each line and then turning the line
    into a list of strings by `.split(',')`, which divides the string by the given
    string (which is not included).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We separate the first row (header) from the data rows for easier processing
    â€“ the notation `data[1:]` is a special way of indicating we want "from index 1
    until as far as the list goes â€“ i.e., the end of the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What would our code do if one of the cells in your CSV contained a comma? For
    example, what if a dish name was "Mac and cheese, deluxe"? How could you handle
    this?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 11.1.3Â Processing and Filtering Data[ðŸ”—](#(part._.Processing_and_.Filtering_.Data)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once we have our data as a list of lists, we can process it using the same programming
    techniques weâ€™ve learned, by using the `.index()` method to return the numeric
    offset of the given string in a list of strings â€“ this is how we will find the
    columns we are interested in, and then use that to index into the row.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, letâ€™s filter for only takeout orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also convert data types as needed. For instance, if we want to calculate
    total revenue, we need to not only find the quantity and price for each row, but
    convert the strings that are in the row (since the file was all strings!) to numbers
    before multiplying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What would happen if one of the quantity cells contained invalid data, like
    the string "three" instead of the number 3? How could you make your code more
    robust to handle such errors?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 11.1.4Â Writing CSV Files[ðŸ”—](#(part._.Writing_.C.S.V_.Files) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing CSV files follows a similar pattern. We need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a file in write mode
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert our data to the proper string format
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the strings to the file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hereâ€™s how to write our filtered takeout orders to a new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The key steps here are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`'',''.join(row)` combines the list elements into a single string with commas
    between them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We add `'\n'` to create a new line after each row
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file.write()` writes the string to the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we call `.write()` once for each line â€“ we could have combined all
    the lines into a single string, and only called `.write()` once, but there is
    no need to â€“ just like how file objects remember where we are reading from them,
    they remember where we were writing, so the next call to `.write()` will add the
    next string after the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try writing a program that reads a CSV file, adds a new column with calculated
    values (like total price = quantity Ã— price), and writes the result to a new file.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
