["```cpp\nif (tid < num_elements)\n{\n… array[tid] = ….\n}\n```", "```cpp\nconst int num_blocks = num_elements / num_threads;\n```", "```cpp\nconst int num_blocks = ((float) num_elements / num_threads);\n```", "```cpp\nconst int num_blocks = (num_elements + (num_threads-1)) / num_threads;\n```", "```cpp\ncudaStream_t my_stream;\nmy_kernel<<<num_blocks, num_threads, dynamic_shared, my_stream>>>(a, b, c);\n```", "```cpp\ncudaStream_t my_stream;\ncudaStreamCreate(&my_stream);\nmy_kernel<<<num_blocks, num_threads, dynamic_shared, my_stream>>>(a, b, c);\ncudaStreamSynchronize(my_stream);\n```", "```cpp\n{\ncudaStream_t my_stream(device_num); // constructor for stream\nmy_kernel<<<num_blocks, num_threads, dynamic_shared, my_stream, device_num>>>(a, b, c);\ncudaStreamSynchronize(my_stream);\n} // destructor for stream\n```", "```cpp\nstatic unsigned int a = 0;\nvoid some_func(void)\n{\n unsigned int i;\n for (i=0; i<= 1000; i++)\n {\n  a += i;\n }\n}\n```", "```cpp\nstatic unsigned int a = 0;\nvoid some_func(void)\n{\n unsigned int register reg_a = a;\n unsigned int i;\n for (i=0; i<1000; i++)\n {\n  reg_a += i;\n }\n a = reg_a;\n}\n```", "```cpp\nstatic unsigned int a = 0;\nvoid some_func(void)\n{\n a += (1 + 2 + 3 + 4 + 5 + 6 + 7 .......);\n}\n```", "```cpp\nstatic unsigned int a = 0;\nvoid some_func(void)\n{\n a += 500500;\n}\n```", "```cpp\nError 1 error: identifier \"__syncthreads_count\" is undefined j:\\CUDA\\Chapter-009-OddEvenSort\\OddEven\\kernel.cu 145 OddEven\n```", "```cpp\n-gencode=arch=compute_20,code=\\\"sm_20,compute_20\\\"\n```", "```cpp\n#if (__CUDA_ARCH__ >= 200)\n my_compute_2x_function();\n#else\n my_compute_1x_function();\n#endif\n```", "```cpp\n#define MAX_WARPS_PER_SM 8\n__shared__ u64 smem_start_clock_times[MAX_WARPS_PER_SM];\n__shared__ u64 smem_sync_clock_times[MAX_WARPS_PER_SM];\n__global__ void reduce_gmem_loop_block_256t_smem(const uint4 ∗ const data,\n                                          u64 ∗ const result,\n                                          const u32 num_elements)\n{\n // Calculate the current warp id\n const u32 log_warp_id = threadIdx.x >> 5;\n // For the first SM only, store the start clock times\n if (blockIdx.x == 0)\n   smem_start_clock_times[log_warp_id] = clock64();\n // Shared memory per block\n // Divide the number of elements by the number of blocks launched\n // ( 4096 elements / 256 threads) / 16 blocks = 1 iteration\n```", "```cpp\n // (16384 elements / 256 threads) / 16 blocks = 4 iterations\n // (32768 elements / 256 threads) / 16 blocks = 8 iterations\n const u32 num_elements_per_block = (( (num_elements/4) / 256) / gridDim.x);\n const u32 increment = (gridDim.x ∗ 256);\n const u32 num_elem_per_iter = (num_elements>>2);\n // Work out the initial index\n u32 idx = (blockIdx.x ∗ 256) + threadIdx.x;\n // Accumulate into this register parameter\n u64 local_result = 0;\n // Loop N times depending on the number of blocks launched\n for (u32 i=0; i<num_elements_per_block; i++)\n {\n  // If still within bounds, add into result\n  if (idx < num_elem_per_iter)\n  {\n   const uint4 ∗ const elem = &data[idx];\n   local_result += ((u64)(elem->x)) + ((u64)(elem->y)) + ((u64)(elem->z)) + ((u64)(elem->w));\n   // Move to the next element in the list\n   idx += increment;\n  }\n }\n // Create a pointer to the smem data area\n u64 ∗ const smem_ptr = &smem_data[(threadIdx.x)];\n // Store results - 128..255 (warps 4..7)\n if (threadIdx.x >= 128)\n {\n  ∗(smem_ptr) = local_result;\n }\n // For the first SM only, store the clock times before the sync\n if (blockIdx.x == 0)\n   smem_sync_clock_times[log_warp_id] = clock64();\n __syncthreads();\n…\n}\n```", "```cpp\nBlock  Id: 16 SM: 0 Start: 10420984500 End: 10421078132 Delta: 93632\nBlock  Id: 22 SM: 0 Start: 10420984504 End: 10421079614 Delta: 95110\nBlock  Id: 36 SM: 0 Start: 10420984508 End: 10421086198 Delta: 101690\nBlock  Id: 50 SM: 0 Start: 10420984512 End: 10421105046 Delta: 120534\nBlock  Id: 64 SM: 0 Start: 10420984592 End: 10421137178 Delta: 152586\nBlock Id: 171 SM: 0 Start: 10421223384 End: 10421308772 Delta: 85388\nBlock Id: 172 SM: 0 Start: 10421223406 End: 10421311256 Delta: 87850\nBlock Id: 176 SM: 0 Start: 10421223424 End: 10421322372 Delta: 98948\nBlock Id: 177 SM: 0 Start: 10421223518 End: 10421350178 Delta: 126660\nBlock Id: 178 SM: 0 Start: 10421233178 End: 10421381276 Delta: 148098\nBlock Id: 303 SM: 0 Start: 10421449580 End: 10421535186 Delta: 85606\nBlock Id: 304 SM: 0 Start: 10421449618 End: 10421538246 Delta: 88628\nBlock Id: 305 SM: 0 Start: 10421449800 End: 10421546884 Delta: 97084\nBlock Id: 306 SM: 0 Start: 10421449822 End: 10421577204 Delta: 127382\nBlock Id: 313 SM: 0 Start: 10421469888 End: 10421606770 Delta: 136882\n```", "```cpp\ncuda-memcheck my_cuda_program\n```", "```cpp\nchar ∗ ptr = malloc(1024);\nfree(ptr);\n```", "```cpp\nif (ptr != NULL)\n{\n… search list of allocated memory areas for ptr and de-allocate memory.\n}\n```", "```cpp\n// Null pointers not supported\nassert(ptr_param != NULL);\n```", "```cpp\nchar ∗ ptr = malloc(1024);\nassert(ptr != NULL);\n```", "```cpp\n#ifdef DEBUG\n#define ASSERT(x) (assert(x))\n#else\n#define ASSERT(x)\n#endif\n```", "```cpp\n#ifdef DEBUG\n#ifndef DEBUG_MSG\n// Set to 0..4 to print errors\n// 0 = Critical (program abort)\n// 1 = Serious\n// 2 = Problem\n// 3 = Warning\n// 4 = Information\n#define DEBUG_ERR_LVL_CRITICAL (0u)\n#define DEBUG_ERR_LVL_SERIOUS (1u)\n#define DEBUG_ERR_LVL_PROBLEM (2u)\n#define DEBUG_ERR_LVL_WARNING (3u)\n#define DEBUG_ERR_LVL_INFO (4u)\n// Define the global used to set the error indication level\n```", "```cpp\nvoid debug_msg(char ∗ str, const unsigned int error_level)\n{\n if (error_level <= GLOBAL_ERROR_LEVEL)\n {\n  if (error_level == 0)\n   printf(\"\\n∗∗∗∗∗∗∗∗∗∗∗%s%s\", str, \"∗∗∗∗∗∗∗∗∗∗∗∗∗∗\\n\");\n  else\n   printf(\"\\n%s\", str);\n  fflush(stdout);\n  if (error_level == 0)\n   exit(0);\n }\n}\n#define DEBUG_MSG(x, level) debug_msg(x, level)\n#else\n#define DEBUG_MSG(x, level)\n#endif\n#endif\n```", "```cpp\n#define DEBUG\n#include \"debug_msg.h\"\nunsigned int GLOBAL_ERROR_LEVEL = DEBUG_ERR_LVL_WARNING;\nint main(int argc, char ∗argv[])\n{\n DEBUG_MSG(\"Error from level four\", DEBUG_ERR_LVL_INFO);\n DEBUG_MSG(\"Error from level three\", DEBUG_ERR_LVL_WARNING);\n DEBUG_MSG(\"Error from level two\", DEBUG_ERR_LVL_PROBLEM);\n DEBUG_MSG(\"Error from level one\", DEBUG_ERR_LVL_SERIOUS);\n DEBUG_MSG(\"Error from level zero\", DEBUG_ERR_LVL_CRITICAL);\n return 0;\n}\n```", "```cpp\nif ( (blockIdx.x == some_block_id) && ((threadIdx.x %32) == 0) )\n{\n // Fetch raw clock value\n unsigned int clock32 = 0;\n asm(\"mov.u32 %0, %%clock ;\" : \"=r\"(clock32));\n // Fetch the SM id\n unsigned int sm = 0;\n asm(\"mov.u32 %0, %%smid ;\" : \"=r\"(sm));\n printf(\"\\nB:%05d, W:%02d, SM:%02u, CLK:%u\", blockIdx.x, (threadIdx.x>>5), sm, clock32);\n}\n```", "```cpp\nB:00007, W:05, SM:13, CLK:1844396538\nB:00001, W:04, SM:05, CLK:1844387468\nB:00002, W:09, SM:09, CLK:1844387438\nB:00007, W:10, SM:13, CLK:1844396668\nB:00002, W:06, SM:09, CLK:1844387312\nB:00007, W:00, SM:13, CLK:1844396520\nB:00005, W:12, SM:06, CLK:1844396640\nB:00005, W:13, SM:02, CLK:24073638\nB:00006, W:03, SM:04, CLK:24073536\nB:00005, W:15, SM:02, CLK:24073642\nB:00002, W:03, SM:05, CLK:24076530\nB:00006, W:00, SM:04, CLK:24073572\n```", "```cpp\nGPU ID : Stream ID : TID : Message\n```", "```cpp\nif ( (major == 2) && (minor == 0) ) // Compute 2.0\n num_blocks = (96∗4);\nelse if ( (major == 2) && (minor == 1) ) // Compute 2.1\n num_blocks = (96∗2);\nelse\n num_blocks = 64; // Assume compute 1.x\n```", "```cpp\nvoid my_func(float ∗ __restrict__ out_ptr, const float ∗ __restrict__ in_ptr)\n```"]