- en: 6\. Discrete Mathematics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://leanprover-community.github.io/mathematics_in_lean/C06_Discrete_Mathematics.html](https://leanprover-community.github.io/mathematics_in_lean/C06_Discrete_Mathematics.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*[Mathematics in Lean](index.html)* **   6\. Discrete Mathematics'
  prefs: []
  type: TYPE_NORMAL
- en: '[View page source](_sources/C06_Discrete_Mathematics.rst.txt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '*Discrete Mathematics* is the study of finite sets, objects, and structures.
    We can count the elements of a finite set, and we can compute finite sums or products
    over its elements, we can compute maximums and minimums, and so on. We can also
    study objects that are generated by finitely many applications of certain generating
    functions, we can define functions by structural recursion, and prove theorems
    by structural induction. This chapters describes parts of Mathlib that support
    these activities.'
  prefs: []
  type: TYPE_NORMAL
- en: '## 6.1\. Finsets and Fintypes[](#finsets-and-fintypes "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with finite sets and types in Mathlib can be confusing, because the
    library offers multiple ways of handling them. In this section we will discuss
    the most common ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already come across the type `Finset` in [Section 5.2](C05_Elementary_Number_Theory.html#section-induction-and-recursion)
    and [Section 5.3](C05_Elementary_Number_Theory.html#section-infinitely-many-primes).
    As the name suggests, an element of type `Finset α` is a finite set of elements
    of type `α`. We will call these “finsets.” The `Finset` data type is designed
    to have a computational interpretation, and many basic operations on `Finset α`
    assume that `α` has decidable equality, which guarantees that there is an algorithm
    for testing whether `a : α` is an element of a finset `s`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you remove the declaration `[DecidableEq α]`, Lean will complain on the line
    `#check s ∩ t` because it cannot compute the intersection. All of the data types
    that you should expect to be able to compute with have decidable equality, however,
    and if you work classically by opening the `Classical` namespace and declaring
    `noncomputable section`, you can reason about finsets of elements of any type
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finsets support most of the set-theoretic operations that sets do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have opened the `Finset` namespace, where theorems specific to
    finsets are found. If you step through the last example below, you will see applying
    `ext` followed by `simp` reduces the identity to a problem in propositional logic.
    As an exercise, you can try proving some of set identities from [Chapter 4](C04_Sets_and_Functions.html#sets-and-functions),
    transported to finsets.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have already seen the notation `Finset.range n` for the finite set of natural
    numbers \(\{ 0, 1, \ldots, n-1 \}\). `Finset` also allows you to define finite
    sets by enumerating the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There are various ways to get Lean to recognize that order of elements and duplicates
    do not matter in a set presented in this way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can use `insert` to add a single element to a Finset, and `Finset.erase`
    to delete a single element. Note that `erase` is in the `Finset` namespace, but
    `insert` is in the root namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In fact, `{0, 1, 2}` is just notation for `insert 0 (insert 1 (singleton 2))`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Given a finset `s` and a predicate `P`, we can use set-builder notation `{x
    ∈ s | P x}` to define the set of elements of `s` that satisfy `P`. This is notation
    for `Finset.filter P s`, which can also be written `s.filter P`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Mathlib knows that the image of a finset under a function is a finset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Lean also knows that the cartesian product `s ×ˢ t` of two finsets is a finset,
    and that the powerset of a finset is a finset. (Note that the notation `s ×ˢ t`
    also works for sets.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Defining operations on finsets in terms of their elements is tricky, because
    any such definition has to be independent of the order in which the elements are
    presented. Of course, you can always define functions by composing existing operations.
    Another thing you can do is use `Finset.fold` to fold a binary operation over
    the elements, provided that the operation is associative and commutative, since
    these properties guarantee that the result is independent of the order that the
    operation is applied. Finite sums, products, and unions are defined in that way.
    In the last example below, `biUnion` stands for “bounded indexed union.” With
    conventional mathematical notation, the expression would be written \(\bigcup_{i
    ∈ s} g(i)\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a natural principle of induction on finsets: to prove that every finset
    has a property, show that the empty set has the property and that the property
    is preserved when we add one new element to a finset. (The `@` symbol in `@insert`
    is needed in the induction step of the next example to give names to the parameters
    `a` and `s` because they have been marked implicit. )'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If `s` is a finset, `Finset.Nonempty s` is defined to be `∃ x, x ∈ s`. You can
    use classical choice to pick an element of a nonempty finset. Similarly, the library
    defines `Finset.toList s` which uses choice to pick the elements of `s` in some
    order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can use `Finset.min` and `Finset.max` to choose the minimum or maximum element
    of a finset of elements of a linear order, and similarly you can use `Finset.inf`
    and `Finset.sup` with finsets of elements of a lattice, but there is a catch.
    What should the minimum element of an empty finset be? You can check that the
    primed versions of the functions below add a precondition that the finset is nonempty.
    The non-primed versions `Finset.min` and `Finset.max` add a top or bottom element,
    respectively, to the output type, to handle the case where the finset is empty.
    The non-primed versions `Finset.inf` and `Finset.sup` assume that the lattice
    comes equipped with a top or bottom element, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Every finset `s` has a finite cardinality, `Finset.card s`, which can be written
    `#s` when the `Finset` namespace is open.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The next section is all about reasoning about cardinality.
  prefs: []
  type: TYPE_NORMAL
- en: When formalizing mathematics, one often has to make a decision as to whether
    to express one’s definitions and theorems in terms of sets or types. Using types
    often simplifies notation and proofs, but working with subsets of a type can be
    more flexible. The type-based analogue of a finset is a *fintype*, that is, a
    type `Fintype α` for some `α`. By definition, a fintype is just a data type that
    comes equipped with a finset `univ` that contains all its elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`Fintype.card α` is equal to the cardinality of the corresponding finset.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We have already seen a prototypical example of a fintype, namely, the types
    `Fin n` for each `n`. Lean recognizes that the fintypes are closed under operations
    like the product operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Any element `s` of `Finset α` can be coercied to a type `(↑s : Finset α)`,
    namely, the subtype of elements of `α` that are contained in `s`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Lean and Mathlib use *type class inference* to track the additional structure
    on fintypes, namely, the universal finset that contains all the elements. In other
    words, you can think of a fintype as an algebraic structure equipped with that
    extra data. [Chapter 7](C07_Structures.html#structures) explains how this works.  ##
    6.2\. Counting Arguments[](#counting-arguments "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'The art of counting things is a central part of combinatorics. Mathlib contains
    several basic identities for counting elements of finsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Opening the `Finset` namespace allows us to use the notation `#s` for `s.card`,
    as well as to use the shortened names card_union and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathlib can also count elements of fintypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When the `Fintype` namespace is not open, we have to use `Fintype.card` instead
    of card.
  prefs: []
  type: TYPE_NORMAL
- en: The following is an example of calculating the cardinality of a finset, namely,
    the union of range n with a copy of range n that has been shifted by more than
    n. The calculation requires showing the the two sets in the union are disjoint;
    the first line of the proof yields the side condition `Disjoint (range n) (image
    (fun i ↦ m + i) (range n))`, which is established at the end of the proof. The
    `Disjoint` predicate is too general to be directly useful to us, but the theorem
    `disjoint_iff_ne` puts it in a form we can use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Throughout this section, `omega` will be a workhorse for us, for dealing with
    arithmetic calculations and inequalities.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a more interesting example. Consider the subset of \(\{0, \ldots, n\}
    \times \{0, \ldots, n\}\) consisting of pairs \((i, j)\) such that \(i < j\).
    If you think of these as lattice points in the coordinate plane, they constitute
    an upper triangle of the square with corners \((0, 0)\) and \((n, n)\), not including
    the diagonal. The cardinality of the full square is \((n + 1)^2\), and removing
    the size of the diagonal and halving the result shows us that the cardinality
    of the triangle is \(n (n + 1) / 2\).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we note that the rows of the triangle have sizes \(0, 1, \ldots,
    n\), so the cardinality is the sum of the first \(n\) natural numbers. The first
    `have` of the proof below describes the triangle as the union of the rows, where
    row \(j\) consists of the numbers \(0, 1, ..., j - 1\) paired with \(j\). In the
    proof below, the notation `(., j)` abbreviates the function `fun i ↦ (i, j)`.
    The rest of the proof is just a calculation with finset cardinalities.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The following variation on the proof does the calculation with fintypes instead
    of finsets. The type `α ≃ β` is the type of equivalences between `α` and `β`,
    consisting of a map in the forward direction, the map in the backward direction,
    and proofs that these two are inverse to one another. The first `have` in the
    proof shows that `triangle n` is equivalent to the disjoint union of `Fin i` as
    `i` ranges over `Fin (n + 1)`. Interestingly, the forward function and the reverse
    function are constructed with tactics, rather than written explicitly. Since they
    do nothing more than move data and information around, `rfl` establishes that
    they are inverses.
  prefs: []
  type: TYPE_NORMAL
- en: After that, `rw [←Fintype.card_coe]` rewrites `#(triangle n)` as the cardinality
    of the subtype `{ x // x ∈ triangle n }`, and the rest of the proof is a calculation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is yet another approach. The first line of the proof below reduces the
    problem to showing `2 * #(triangle n) = (n + 1) * n`. We can do that by showing
    that two copies of the triangle exactly fill the rectangle `range n ×ˢ range (n
    + 1)`. As an exercise, see if you can fill in the steps of the calculation. In
    the solutions, we rely on `omega` extensively in the second-to-last step, but
    we unfortunately have to do a fair amount of work by hand.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can convince yourself that we get the same triangle, shifted down, if we
    replace `n` by `n + 1` and replace `<` by `≤` in the definition of `triangle`.
    The exercise below asks you to use this fact to show that the two triangles have
    the same size.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Let us close this section with an example and an exercise from a [tutorial](https://www.youtube.com/watch?v=_cJctOIXWE4&list=PLlF-CfQhukNn7xEbfL38eLgkveyk9_myQ&index=8&t=2737s&ab_channel=leanprovercommunity)
    on combinatorics given by Bhavik Mehta at *Lean for the Curious Mathematician*
    in 2023. Suppose we have a bipartite graph with vertex sets `s` and `t`, such
    that for every `a` in `s`, there are at least three edges leaving `a`, and for
    every `b` in `t`, there is at most one edge entering `b`. Then the total number
    of edges in the graph is at least three times the cardinality of `s` and at most
    the cardinality of `t`, from which is follows that three times the cardinality
    of `s` is at most the cardinality of `t`. The following theorem implements this
    argument, where we use the relation `r` to represent the edges of the graph. The
    proof is an elegant calculation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The following exercise is also taken from Mehta’s tutorial. Suppose `A` is a
    subset of `range (2 * n)` with `n + 1` elements. It’s easy to see that `A` must
    contain two consecutive integers, and hence two elements that are coprime. If
    you watch the tutorial, you will see that a good deal of effort was spent in establishing
    the following fact, which is now proved automatically by `omega`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The solution to Mehta’s exercise uses the pigeonhole principle, in the form
    `exists_lt_card_fiber_of_mul_lt_card_of_maps_to`, to show that there are two distinct
    elements `m` and `k` in `A` such that `m / 2 = k / 2`. See if you can complete
    the justification of that fact and then use it to finish the proof.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]  ## 6.3\. Inductively Defined Types[](#inductively-defined-types "Link
    to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Lean’s foundation allows us to define inductive types, that is, data types whose
    instances are generated from the bottom up. For example, the data type `List α`
    of lists of elements of `α` is generated by starting with the empty list, `nil`,
    and successively adding elements to the front the list. Below we will define a
    type of binary trees, `BinTree`, whose elements are generated by starting with
    the empty tree and building new trees by attaching a new node to two existing
    trees.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Lean, one can define inductive types whose objects are infinite, like countably
    branching well-founded trees. Finite inductive definitions are commonly used in
    discrete mathematics, however, especially in those branches of discrete mathematics
    that are relevant to computer science. Lean provides not only the means to define
    such types, but also principles of induction and definition by recursion. For
    example, the data type `List α` is defined inductively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The inductive definition says that every element of `List α` is either `nil`,
    the empty list, or `cons a as`, where `a` is an element of `α` and `as` is a list
    of elements of `α`. The constructors are properly named `List.nil` and `List.cons`,
    but you can use the shorter notation with the `List` namespace is open. When the
    `List` namespace is *not* open, you can write `.nil` and `.cons a as` anywhere
    that `Lean` expects a list, and Lean will automatically insert the `List` qualifier.
    Throughout this section, we will put temporary definitions in separate namespaces
    like `MyListSpace` to avoid conflicts with the standard library. Outside the temporary
    namespace, we revert to using the standard library definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lean defines the notation `[]` for `nil` and `::` for `cons`, and you can write
    `[a, b, c]` for `a :: b :: c :: []`. The append and map functions are defined
    recursively as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that there is a base case and a recursive case. In each case, the two
    defining clauses hold definitionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The functions `append` and `map` are defined in the standard library, and `append
    as bs` can be written as `as ++ bs`.
  prefs: []
  type: TYPE_NORMAL
- en: Lean allows you to write proofs by induction following the structure of the
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the `induction'` tactic.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, these theorems are already in the standard library. As an exercise,
    try defining a function `reverse` in the `MyListSpace3` namespace (to avoid conflicting
    with the standard `List.reverse`) that reverses a list. You can use `#eval reverse
    [1, 2, 3, 4, 5]` to test it out. The most straightforward definition of `reverse`
    requires quadratic time, but don’t worry about that. You can jump to the definition
    of `List.reverse` in the standard library to see a linear-time implementation.
    Try proving `reverse (as ++ bs) = reverse bs ++ reverse as` and `reverse (reverse
    as) = as`. You can use `cons_append` and `append_assoc`, but you You may need
    to come up with auxiliary lemmas and prove them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: For another example, consider the following inductive definition of binary trees
    together with functions to compute the size and depth of a binary tree.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It is convenient to count the empty binary tree as a binary tree of size 0 and
    depth 0. In the literature, this data type is sometimes called the *extended binary
    trees*. Including the empty tree means, for example, that we can define the tree
    `node empty (node empty empty)` consisting of a root node, and empty left subtree,
    and a right subtree consisting of a single node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an important inequality relating the size and the depth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Try proving the following inequality, which is somewhat easier. Remember, if
    you do a proof by induction as in the previous theorem, you have to delete the
    `:= by`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Also define the `flip` operation on binary trees, which recursively swaps the
    left and right subtrees.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If you did it right, the proof of the following should be rfl.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Prove the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We close this section with some formal logic. The following is an inductive
    definition of propositional formulas.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Every propositional formula is either a variable `var n`, the constant false
    `fls`, or a compound formula of the form `conj A B`, `disj A B`, or `impl A B`.
    With ordinary mathematical notation, these are commonly written \(p_n\), \(\bot\),
    \(A \wedge B\), \(A \vee B\), and \(A \to B\), respectively. The other propositional
    connectives can be defined in terms of these; for example, we can define \(\neg
    A\) as \(A \to \bot\) and \(A \leftrightarrow B\) as \((A \to B) \wedge (B \to
    A)\).
  prefs: []
  type: TYPE_NORMAL
- en: Having defined the data type of propositional formulas, we define what it means
    to evaluate a propositional formula with respect to an assignment `v` of Boolean
    truth values to the variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The next definition specifies the set of variables occurring in a formula, and
    the subsequent theorem shows that evaluating a formula on two truth assignments
    that agree on its variables yields that same value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Noticing the repetition, we can be clever about the use of automation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The function `subst A m C` describes the result of substituting the formula
    `C` for every occurrence of the variable `var m` in the formula `A`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example, show that substituting for a variable that does not occur in
    a formula has no effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The following theorem says something more subtle and interesting: evaluating
    `A.subst n C` on a truth assignment `v` is the same as evaluating `A` on a truth
    assignment that assigns the value of `C` to `var n`. See if you can prove it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45] [Previous](C05_Elementary_Number_Theory.html "5\. Elementary Number
    Theory") [Next](C07_Structures.html "7\. Structures")'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: © Copyright 2020-2025, Jeremy Avigad, Patrick Massot. Text licensed under CC
    BY 4.0.
  prefs: []
  type: TYPE_NORMAL
- en: Built with [Sphinx](https://www.sphinx-doc.org/) using a [theme](https://github.com/readthedocs/sphinx_rtd_theme)
    provided by [Read the Docs](https://readthedocs.org). *Discrete Mathematics* is
    the study of finite sets, objects, and structures. We can count the elements of
    a finite set, and we can compute finite sums or products over its elements, we
    can compute maximums and minimums, and so on. We can also study objects that are
    generated by finitely many applications of certain generating functions, we can
    define functions by structural recursion, and prove theorems by structural induction.
    This chapters describes parts of Mathlib that support these activities.
  prefs: []
  type: TYPE_NORMAL
- en: '## 6.1\. Finsets and Fintypes[](#finsets-and-fintypes "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with finite sets and types in Mathlib can be confusing, because the
    library offers multiple ways of handling them. In this section we will discuss
    the most common ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already come across the type `Finset` in [Section 5.2](C05_Elementary_Number_Theory.html#section-induction-and-recursion)
    and [Section 5.3](C05_Elementary_Number_Theory.html#section-infinitely-many-primes).
    As the name suggests, an element of type `Finset α` is a finite set of elements
    of type `α`. We will call these “finsets.” The `Finset` data type is designed
    to have a computational interpretation, and many basic operations on `Finset α`
    assume that `α` has decidable equality, which guarantees that there is an algorithm
    for testing whether `a : α` is an element of a finset `s`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If you remove the declaration `[DecidableEq α]`, Lean will complain on the line
    `#check s ∩ t` because it cannot compute the intersection. All of the data types
    that you should expect to be able to compute with have decidable equality, however,
    and if you work classically by opening the `Classical` namespace and declaring
    `noncomputable section`, you can reason about finsets of elements of any type
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finsets support most of the set-theoretic operations that sets do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have opened the `Finset` namespace, where theorems specific to
    finsets are found. If you step through the last example below, you will see applying
    `ext` followed by `simp` reduces the identity to a problem in propositional logic.
    As an exercise, you can try proving some of set identities from [Chapter 4](C04_Sets_and_Functions.html#sets-and-functions),
    transported to finsets.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have already seen the notation `Finset.range n` for the finite set of natural
    numbers \(\{ 0, 1, \ldots, n-1 \}\). `Finset` also allows you to define finite
    sets by enumerating the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: There are various ways to get Lean to recognize that order of elements and duplicates
    do not matter in a set presented in this way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: You can use `insert` to add a single element to a Finset, and `Finset.erase`
    to delete a single element. Note that `erase` is in the `Finset` namespace, but
    `insert` is in the root namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In fact, `{0, 1, 2}` is just notation for `insert 0 (insert 1 (singleton 2))`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Given a finset `s` and a predicate `P`, we can use set-builder notation `{x
    ∈ s | P x}` to define the set of elements of `s` that satisfy `P`. This is notation
    for `Finset.filter P s`, which can also be written `s.filter P`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Mathlib knows that the image of a finset under a function is a finset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Lean also knows that the cartesian product `s ×ˢ t` of two finsets is a finset,
    and that the powerset of a finset is a finset. (Note that the notation `s ×ˢ t`
    also works for sets.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Defining operations on finsets in terms of their elements is tricky, because
    any such definition has to be independent of the order in which the elements are
    presented. Of course, you can always define functions by composing existing operations.
    Another thing you can do is use `Finset.fold` to fold a binary operation over
    the elements, provided that the operation is associative and commutative, since
    these properties guarantee that the result is independent of the order that the
    operation is applied. Finite sums, products, and unions are defined in that way.
    In the last example below, `biUnion` stands for “bounded indexed union.” With
    conventional mathematical notation, the expression would be written \(\bigcup_{i
    ∈ s} g(i)\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a natural principle of induction on finsets: to prove that every finset
    has a property, show that the empty set has the property and that the property
    is preserved when we add one new element to a finset. (The `@` symbol in `@insert`
    is needed in the induction step of the next example to give names to the parameters
    `a` and `s` because they have been marked implicit. )'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: If `s` is a finset, `Finset.Nonempty s` is defined to be `∃ x, x ∈ s`. You can
    use classical choice to pick an element of a nonempty finset. Similarly, the library
    defines `Finset.toList s` which uses choice to pick the elements of `s` in some
    order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: You can use `Finset.min` and `Finset.max` to choose the minimum or maximum element
    of a finset of elements of a linear order, and similarly you can use `Finset.inf`
    and `Finset.sup` with finsets of elements of a lattice, but there is a catch.
    What should the minimum element of an empty finset be? You can check that the
    primed versions of the functions below add a precondition that the finset is nonempty.
    The non-primed versions `Finset.min` and `Finset.max` add a top or bottom element,
    respectively, to the output type, to handle the case where the finset is empty.
    The non-primed versions `Finset.inf` and `Finset.sup` assume that the lattice
    comes equipped with a top or bottom element, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Every finset `s` has a finite cardinality, `Finset.card s`, which can be written
    `#s` when the `Finset` namespace is open.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The next section is all about reasoning about cardinality.
  prefs: []
  type: TYPE_NORMAL
- en: When formalizing mathematics, one often has to make a decision as to whether
    to express one’s definitions and theorems in terms of sets or types. Using types
    often simplifies notation and proofs, but working with subsets of a type can be
    more flexible. The type-based analogue of a finset is a *fintype*, that is, a
    type `Fintype α` for some `α`. By definition, a fintype is just a data type that
    comes equipped with a finset `univ` that contains all its elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '`Fintype.card α` is equal to the cardinality of the corresponding finset.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We have already seen a prototypical example of a fintype, namely, the types
    `Fin n` for each `n`. Lean recognizes that the fintypes are closed under operations
    like the product operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Any element `s` of `Finset α` can be coercied to a type `(↑s : Finset α)`,
    namely, the subtype of elements of `α` that are contained in `s`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Lean and Mathlib use *type class inference* to track the additional structure
    on fintypes, namely, the universal finset that contains all the elements. In other
    words, you can think of a fintype as an algebraic structure equipped with that
    extra data. [Chapter 7](C07_Structures.html#structures) explains how this works.  ##
    6.2\. Counting Arguments[](#counting-arguments "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'The art of counting things is a central part of combinatorics. Mathlib contains
    several basic identities for counting elements of finsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Opening the `Finset` namespace allows us to use the notation `#s` for `s.card`,
    as well as to use the shortened names card_union and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathlib can also count elements of fintypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: When the `Fintype` namespace is not open, we have to use `Fintype.card` instead
    of card.
  prefs: []
  type: TYPE_NORMAL
- en: The following is an example of calculating the cardinality of a finset, namely,
    the union of range n with a copy of range n that has been shifted by more than
    n. The calculation requires showing the the two sets in the union are disjoint;
    the first line of the proof yields the side condition `Disjoint (range n) (image
    (fun i ↦ m + i) (range n))`, which is established at the end of the proof. The
    `Disjoint` predicate is too general to be directly useful to us, but the theorem
    `disjoint_iff_ne` puts it in a form we can use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Throughout this section, `omega` will be a workhorse for us, for dealing with
    arithmetic calculations and inequalities.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a more interesting example. Consider the subset of \(\{0, \ldots, n\}
    \times \{0, \ldots, n\}\) consisting of pairs \((i, j)\) such that \(i < j\).
    If you think of these as lattice points in the coordinate plane, they constitute
    an upper triangle of the square with corners \((0, 0)\) and \((n, n)\), not including
    the diagonal. The cardinality of the full square is \((n + 1)^2\), and removing
    the size of the diagonal and halving the result shows us that the cardinality
    of the triangle is \(n (n + 1) / 2\).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we note that the rows of the triangle have sizes \(0, 1, \ldots,
    n\), so the cardinality is the sum of the first \(n\) natural numbers. The first
    `have` of the proof below describes the triangle as the union of the rows, where
    row \(j\) consists of the numbers \(0, 1, ..., j - 1\) paired with \(j\). In the
    proof below, the notation `(., j)` abbreviates the function `fun i ↦ (i, j)`.
    The rest of the proof is just a calculation with finset cardinalities.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The following variation on the proof does the calculation with fintypes instead
    of finsets. The type `α ≃ β` is the type of equivalences between `α` and `β`,
    consisting of a map in the forward direction, the map in the backward direction,
    and proofs that these two are inverse to one another. The first `have` in the
    proof shows that `triangle n` is equivalent to the disjoint union of `Fin i` as
    `i` ranges over `Fin (n + 1)`. Interestingly, the forward function and the reverse
    function are constructed with tactics, rather than written explicitly. Since they
    do nothing more than move data and information around, `rfl` establishes that
    they are inverses.
  prefs: []
  type: TYPE_NORMAL
- en: After that, `rw [←Fintype.card_coe]` rewrites `#(triangle n)` as the cardinality
    of the subtype `{ x // x ∈ triangle n }`, and the rest of the proof is a calculation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is yet another approach. The first line of the proof below reduces the
    problem to showing `2 * #(triangle n) = (n + 1) * n`. We can do that by showing
    that two copies of the triangle exactly fill the rectangle `range n ×ˢ range (n
    + 1)`. As an exercise, see if you can fill in the steps of the calculation. In
    the solutions, we rely on `omega` extensively in the second-to-last step, but
    we unfortunately have to do a fair amount of work by hand.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: You can convince yourself that we get the same triangle, shifted down, if we
    replace `n` by `n + 1` and replace `<` by `≤` in the definition of `triangle`.
    The exercise below asks you to use this fact to show that the two triangles have
    the same size.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Let us close this section with an example and an exercise from a [tutorial](https://www.youtube.com/watch?v=_cJctOIXWE4&list=PLlF-CfQhukNn7xEbfL38eLgkveyk9_myQ&index=8&t=2737s&ab_channel=leanprovercommunity)
    on combinatorics given by Bhavik Mehta at *Lean for the Curious Mathematician*
    in 2023. Suppose we have a bipartite graph with vertex sets `s` and `t`, such
    that for every `a` in `s`, there are at least three edges leaving `a`, and for
    every `b` in `t`, there is at most one edge entering `b`. Then the total number
    of edges in the graph is at least three times the cardinality of `s` and at most
    the cardinality of `t`, from which is follows that three times the cardinality
    of `s` is at most the cardinality of `t`. The following theorem implements this
    argument, where we use the relation `r` to represent the edges of the graph. The
    proof is an elegant calculation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The following exercise is also taken from Mehta’s tutorial. Suppose `A` is a
    subset of `range (2 * n)` with `n + 1` elements. It’s easy to see that `A` must
    contain two consecutive integers, and hence two elements that are coprime. If
    you watch the tutorial, you will see that a good deal of effort was spent in establishing
    the following fact, which is now proved automatically by `omega`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The solution to Mehta’s exercise uses the pigeonhole principle, in the form
    `exists_lt_card_fiber_of_mul_lt_card_of_maps_to`, to show that there are two distinct
    elements `m` and `k` in `A` such that `m / 2 = k / 2`. See if you can complete
    the justification of that fact and then use it to finish the proof.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]  ## 6.3\. Inductively Defined Types[](#inductively-defined-types "Link
    to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Lean’s foundation allows us to define inductive types, that is, data types whose
    instances are generated from the bottom up. For example, the data type `List α`
    of lists of elements of `α` is generated by starting with the empty list, `nil`,
    and successively adding elements to the front the list. Below we will define a
    type of binary trees, `BinTree`, whose elements are generated by starting with
    the empty tree and building new trees by attaching a new node to two existing
    trees.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Lean, one can define inductive types whose objects are infinite, like countably
    branching well-founded trees. Finite inductive definitions are commonly used in
    discrete mathematics, however, especially in those branches of discrete mathematics
    that are relevant to computer science. Lean provides not only the means to define
    such types, but also principles of induction and definition by recursion. For
    example, the data type `List α` is defined inductively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The inductive definition says that every element of `List α` is either `nil`,
    the empty list, or `cons a as`, where `a` is an element of `α` and `as` is a list
    of elements of `α`. The constructors are properly named `List.nil` and `List.cons`,
    but you can use the shorter notation with the `List` namespace is open. When the
    `List` namespace is *not* open, you can write `.nil` and `.cons a as` anywhere
    that `Lean` expects a list, and Lean will automatically insert the `List` qualifier.
    Throughout this section, we will put temporary definitions in separate namespaces
    like `MyListSpace` to avoid conflicts with the standard library. Outside the temporary
    namespace, we revert to using the standard library definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lean defines the notation `[]` for `nil` and `::` for `cons`, and you can write
    `[a, b, c]` for `a :: b :: c :: []`. The append and map functions are defined
    recursively as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that there is a base case and a recursive case. In each case, the two
    defining clauses hold definitionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The functions `append` and `map` are defined in the standard library, and `append
    as bs` can be written as `as ++ bs`.
  prefs: []
  type: TYPE_NORMAL
- en: Lean allows you to write proofs by induction following the structure of the
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the `induction'` tactic.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, these theorems are already in the standard library. As an exercise,
    try defining a function `reverse` in the `MyListSpace3` namespace (to avoid conflicting
    with the standard `List.reverse`) that reverses a list. You can use `#eval reverse
    [1, 2, 3, 4, 5]` to test it out. The most straightforward definition of `reverse`
    requires quadratic time, but don’t worry about that. You can jump to the definition
    of `List.reverse` in the standard library to see a linear-time implementation.
    Try proving `reverse (as ++ bs) = reverse bs ++ reverse as` and `reverse (reverse
    as) = as`. You can use `cons_append` and `append_assoc`, but you You may need
    to come up with auxiliary lemmas and prove them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: For another example, consider the following inductive definition of binary trees
    together with functions to compute the size and depth of a binary tree.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: It is convenient to count the empty binary tree as a binary tree of size 0 and
    depth 0. In the literature, this data type is sometimes called the *extended binary
    trees*. Including the empty tree means, for example, that we can define the tree
    `node empty (node empty empty)` consisting of a root node, and empty left subtree,
    and a right subtree consisting of a single node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an important inequality relating the size and the depth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Try proving the following inequality, which is somewhat easier. Remember, if
    you do a proof by induction as in the previous theorem, you have to delete the
    `:= by`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Also define the `flip` operation on binary trees, which recursively swaps the
    left and right subtrees.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: If you did it right, the proof of the following should be rfl.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Prove the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: We close this section with some formal logic. The following is an inductive
    definition of propositional formulas.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Every propositional formula is either a variable `var n`, the constant false
    `fls`, or a compound formula of the form `conj A B`, `disj A B`, or `impl A B`.
    With ordinary mathematical notation, these are commonly written \(p_n\), \(\bot\),
    \(A \wedge B\), \(A \vee B\), and \(A \to B\), respectively. The other propositional
    connectives can be defined in terms of these; for example, we can define \(\neg
    A\) as \(A \to \bot\) and \(A \leftrightarrow B\) as \((A \to B) \wedge (B \to
    A)\).
  prefs: []
  type: TYPE_NORMAL
- en: Having defined the data type of propositional formulas, we define what it means
    to evaluate a propositional formula with respect to an assignment `v` of Boolean
    truth values to the variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The next definition specifies the set of variables occurring in a formula, and
    the subsequent theorem shows that evaluating a formula on two truth assignments
    that agree on its variables yields that same value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Noticing the repetition, we can be clever about the use of automation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The function `subst A m C` describes the result of substituting the formula
    `C` for every occurrence of the variable `var m` in the formula `A`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example, show that substituting for a variable that does not occur in
    a formula has no effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The following theorem says something more subtle and interesting: evaluating
    `A.subst n C` on a truth assignment `v` is the same as evaluating `A` on a truth
    assignment that assigns the value of `C` to `var n`. See if you can prove it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]  ## 6.1\. Finsets and Fintypes[](#finsets-and-fintypes "Link to this
    heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with finite sets and types in Mathlib can be confusing, because the
    library offers multiple ways of handling them. In this section we will discuss
    the most common ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already come across the type `Finset` in [Section 5.2](C05_Elementary_Number_Theory.html#section-induction-and-recursion)
    and [Section 5.3](C05_Elementary_Number_Theory.html#section-infinitely-many-primes).
    As the name suggests, an element of type `Finset α` is a finite set of elements
    of type `α`. We will call these “finsets.” The `Finset` data type is designed
    to have a computational interpretation, and many basic operations on `Finset α`
    assume that `α` has decidable equality, which guarantees that there is an algorithm
    for testing whether `a : α` is an element of a finset `s`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: If you remove the declaration `[DecidableEq α]`, Lean will complain on the line
    `#check s ∩ t` because it cannot compute the intersection. All of the data types
    that you should expect to be able to compute with have decidable equality, however,
    and if you work classically by opening the `Classical` namespace and declaring
    `noncomputable section`, you can reason about finsets of elements of any type
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finsets support most of the set-theoretic operations that sets do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have opened the `Finset` namespace, where theorems specific to
    finsets are found. If you step through the last example below, you will see applying
    `ext` followed by `simp` reduces the identity to a problem in propositional logic.
    As an exercise, you can try proving some of set identities from [Chapter 4](C04_Sets_and_Functions.html#sets-and-functions),
    transported to finsets.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have already seen the notation `Finset.range n` for the finite set of natural
    numbers \(\{ 0, 1, \ldots, n-1 \}\). `Finset` also allows you to define finite
    sets by enumerating the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: There are various ways to get Lean to recognize that order of elements and duplicates
    do not matter in a set presented in this way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: You can use `insert` to add a single element to a Finset, and `Finset.erase`
    to delete a single element. Note that `erase` is in the `Finset` namespace, but
    `insert` is in the root namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: In fact, `{0, 1, 2}` is just notation for `insert 0 (insert 1 (singleton 2))`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Given a finset `s` and a predicate `P`, we can use set-builder notation `{x
    ∈ s | P x}` to define the set of elements of `s` that satisfy `P`. This is notation
    for `Finset.filter P s`, which can also be written `s.filter P`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Mathlib knows that the image of a finset under a function is a finset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Lean also knows that the cartesian product `s ×ˢ t` of two finsets is a finset,
    and that the powerset of a finset is a finset. (Note that the notation `s ×ˢ t`
    also works for sets.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Defining operations on finsets in terms of their elements is tricky, because
    any such definition has to be independent of the order in which the elements are
    presented. Of course, you can always define functions by composing existing operations.
    Another thing you can do is use `Finset.fold` to fold a binary operation over
    the elements, provided that the operation is associative and commutative, since
    these properties guarantee that the result is independent of the order that the
    operation is applied. Finite sums, products, and unions are defined in that way.
    In the last example below, `biUnion` stands for “bounded indexed union.” With
    conventional mathematical notation, the expression would be written \(\bigcup_{i
    ∈ s} g(i)\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a natural principle of induction on finsets: to prove that every finset
    has a property, show that the empty set has the property and that the property
    is preserved when we add one new element to a finset. (The `@` symbol in `@insert`
    is needed in the induction step of the next example to give names to the parameters
    `a` and `s` because they have been marked implicit. )'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: If `s` is a finset, `Finset.Nonempty s` is defined to be `∃ x, x ∈ s`. You can
    use classical choice to pick an element of a nonempty finset. Similarly, the library
    defines `Finset.toList s` which uses choice to pick the elements of `s` in some
    order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: You can use `Finset.min` and `Finset.max` to choose the minimum or maximum element
    of a finset of elements of a linear order, and similarly you can use `Finset.inf`
    and `Finset.sup` with finsets of elements of a lattice, but there is a catch.
    What should the minimum element of an empty finset be? You can check that the
    primed versions of the functions below add a precondition that the finset is nonempty.
    The non-primed versions `Finset.min` and `Finset.max` add a top or bottom element,
    respectively, to the output type, to handle the case where the finset is empty.
    The non-primed versions `Finset.inf` and `Finset.sup` assume that the lattice
    comes equipped with a top or bottom element, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Every finset `s` has a finite cardinality, `Finset.card s`, which can be written
    `#s` when the `Finset` namespace is open.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The next section is all about reasoning about cardinality.
  prefs: []
  type: TYPE_NORMAL
- en: When formalizing mathematics, one often has to make a decision as to whether
    to express one’s definitions and theorems in terms of sets or types. Using types
    often simplifies notation and proofs, but working with subsets of a type can be
    more flexible. The type-based analogue of a finset is a *fintype*, that is, a
    type `Fintype α` for some `α`. By definition, a fintype is just a data type that
    comes equipped with a finset `univ` that contains all its elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '`Fintype.card α` is equal to the cardinality of the corresponding finset.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: We have already seen a prototypical example of a fintype, namely, the types
    `Fin n` for each `n`. Lean recognizes that the fintypes are closed under operations
    like the product operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Any element `s` of `Finset α` can be coercied to a type `(↑s : Finset α)`,
    namely, the subtype of elements of `α` that are contained in `s`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Lean and Mathlib use *type class inference* to track the additional structure
    on fintypes, namely, the universal finset that contains all the elements. In other
    words, you can think of a fintype as an algebraic structure equipped with that
    extra data. [Chapter 7](C07_Structures.html#structures) explains how this works.
  prefs: []
  type: TYPE_NORMAL
- en: '## 6.2\. Counting Arguments[](#counting-arguments "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'The art of counting things is a central part of combinatorics. Mathlib contains
    several basic identities for counting elements of finsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Opening the `Finset` namespace allows us to use the notation `#s` for `s.card`,
    as well as to use the shortened names card_union and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathlib can also count elements of fintypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: When the `Fintype` namespace is not open, we have to use `Fintype.card` instead
    of card.
  prefs: []
  type: TYPE_NORMAL
- en: The following is an example of calculating the cardinality of a finset, namely,
    the union of range n with a copy of range n that has been shifted by more than
    n. The calculation requires showing the the two sets in the union are disjoint;
    the first line of the proof yields the side condition `Disjoint (range n) (image
    (fun i ↦ m + i) (range n))`, which is established at the end of the proof. The
    `Disjoint` predicate is too general to be directly useful to us, but the theorem
    `disjoint_iff_ne` puts it in a form we can use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Throughout this section, `omega` will be a workhorse for us, for dealing with
    arithmetic calculations and inequalities.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a more interesting example. Consider the subset of \(\{0, \ldots, n\}
    \times \{0, \ldots, n\}\) consisting of pairs \((i, j)\) such that \(i < j\).
    If you think of these as lattice points in the coordinate plane, they constitute
    an upper triangle of the square with corners \((0, 0)\) and \((n, n)\), not including
    the diagonal. The cardinality of the full square is \((n + 1)^2\), and removing
    the size of the diagonal and halving the result shows us that the cardinality
    of the triangle is \(n (n + 1) / 2\).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we note that the rows of the triangle have sizes \(0, 1, \ldots,
    n\), so the cardinality is the sum of the first \(n\) natural numbers. The first
    `have` of the proof below describes the triangle as the union of the rows, where
    row \(j\) consists of the numbers \(0, 1, ..., j - 1\) paired with \(j\). In the
    proof below, the notation `(., j)` abbreviates the function `fun i ↦ (i, j)`.
    The rest of the proof is just a calculation with finset cardinalities.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: The following variation on the proof does the calculation with fintypes instead
    of finsets. The type `α ≃ β` is the type of equivalences between `α` and `β`,
    consisting of a map in the forward direction, the map in the backward direction,
    and proofs that these two are inverse to one another. The first `have` in the
    proof shows that `triangle n` is equivalent to the disjoint union of `Fin i` as
    `i` ranges over `Fin (n + 1)`. Interestingly, the forward function and the reverse
    function are constructed with tactics, rather than written explicitly. Since they
    do nothing more than move data and information around, `rfl` establishes that
    they are inverses.
  prefs: []
  type: TYPE_NORMAL
- en: After that, `rw [←Fintype.card_coe]` rewrites `#(triangle n)` as the cardinality
    of the subtype `{ x // x ∈ triangle n }`, and the rest of the proof is a calculation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is yet another approach. The first line of the proof below reduces the
    problem to showing `2 * #(triangle n) = (n + 1) * n`. We can do that by showing
    that two copies of the triangle exactly fill the rectangle `range n ×ˢ range (n
    + 1)`. As an exercise, see if you can fill in the steps of the calculation. In
    the solutions, we rely on `omega` extensively in the second-to-last step, but
    we unfortunately have to do a fair amount of work by hand.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: You can convince yourself that we get the same triangle, shifted down, if we
    replace `n` by `n + 1` and replace `<` by `≤` in the definition of `triangle`.
    The exercise below asks you to use this fact to show that the two triangles have
    the same size.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Let us close this section with an example and an exercise from a [tutorial](https://www.youtube.com/watch?v=_cJctOIXWE4&list=PLlF-CfQhukNn7xEbfL38eLgkveyk9_myQ&index=8&t=2737s&ab_channel=leanprovercommunity)
    on combinatorics given by Bhavik Mehta at *Lean for the Curious Mathematician*
    in 2023. Suppose we have a bipartite graph with vertex sets `s` and `t`, such
    that for every `a` in `s`, there are at least three edges leaving `a`, and for
    every `b` in `t`, there is at most one edge entering `b`. Then the total number
    of edges in the graph is at least three times the cardinality of `s` and at most
    the cardinality of `t`, from which is follows that three times the cardinality
    of `s` is at most the cardinality of `t`. The following theorem implements this
    argument, where we use the relation `r` to represent the edges of the graph. The
    proof is an elegant calculation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: The following exercise is also taken from Mehta’s tutorial. Suppose `A` is a
    subset of `range (2 * n)` with `n + 1` elements. It’s easy to see that `A` must
    contain two consecutive integers, and hence two elements that are coprime. If
    you watch the tutorial, you will see that a good deal of effort was spent in establishing
    the following fact, which is now proved automatically by `omega`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: The solution to Mehta’s exercise uses the pigeonhole principle, in the form
    `exists_lt_card_fiber_of_mul_lt_card_of_maps_to`, to show that there are two distinct
    elements `m` and `k` in `A` such that `m / 2 = k / 2`. See if you can complete
    the justification of that fact and then use it to finish the proof.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '## 6.3\. Inductively Defined Types[](#inductively-defined-types "Link to this
    heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Lean’s foundation allows us to define inductive types, that is, data types whose
    instances are generated from the bottom up. For example, the data type `List α`
    of lists of elements of `α` is generated by starting with the empty list, `nil`,
    and successively adding elements to the front the list. Below we will define a
    type of binary trees, `BinTree`, whose elements are generated by starting with
    the empty tree and building new trees by attaching a new node to two existing
    trees.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Lean, one can define inductive types whose objects are infinite, like countably
    branching well-founded trees. Finite inductive definitions are commonly used in
    discrete mathematics, however, especially in those branches of discrete mathematics
    that are relevant to computer science. Lean provides not only the means to define
    such types, but also principles of induction and definition by recursion. For
    example, the data type `List α` is defined inductively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: The inductive definition says that every element of `List α` is either `nil`,
    the empty list, or `cons a as`, where `a` is an element of `α` and `as` is a list
    of elements of `α`. The constructors are properly named `List.nil` and `List.cons`,
    but you can use the shorter notation with the `List` namespace is open. When the
    `List` namespace is *not* open, you can write `.nil` and `.cons a as` anywhere
    that `Lean` expects a list, and Lean will automatically insert the `List` qualifier.
    Throughout this section, we will put temporary definitions in separate namespaces
    like `MyListSpace` to avoid conflicts with the standard library. Outside the temporary
    namespace, we revert to using the standard library definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lean defines the notation `[]` for `nil` and `::` for `cons`, and you can write
    `[a, b, c]` for `a :: b :: c :: []`. The append and map functions are defined
    recursively as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that there is a base case and a recursive case. In each case, the two
    defining clauses hold definitionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: The functions `append` and `map` are defined in the standard library, and `append
    as bs` can be written as `as ++ bs`.
  prefs: []
  type: TYPE_NORMAL
- en: Lean allows you to write proofs by induction following the structure of the
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the `induction'` tactic.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, these theorems are already in the standard library. As an exercise,
    try defining a function `reverse` in the `MyListSpace3` namespace (to avoid conflicting
    with the standard `List.reverse`) that reverses a list. You can use `#eval reverse
    [1, 2, 3, 4, 5]` to test it out. The most straightforward definition of `reverse`
    requires quadratic time, but don’t worry about that. You can jump to the definition
    of `List.reverse` in the standard library to see a linear-time implementation.
    Try proving `reverse (as ++ bs) = reverse bs ++ reverse as` and `reverse (reverse
    as) = as`. You can use `cons_append` and `append_assoc`, but you You may need
    to come up with auxiliary lemmas and prove them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: For another example, consider the following inductive definition of binary trees
    together with functions to compute the size and depth of a binary tree.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: It is convenient to count the empty binary tree as a binary tree of size 0 and
    depth 0. In the literature, this data type is sometimes called the *extended binary
    trees*. Including the empty tree means, for example, that we can define the tree
    `node empty (node empty empty)` consisting of a root node, and empty left subtree,
    and a right subtree consisting of a single node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an important inequality relating the size and the depth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Try proving the following inequality, which is somewhat easier. Remember, if
    you do a proof by induction as in the previous theorem, you have to delete the
    `:= by`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Also define the `flip` operation on binary trees, which recursively swaps the
    left and right subtrees.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: If you did it right, the proof of the following should be rfl.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Prove the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: We close this section with some formal logic. The following is an inductive
    definition of propositional formulas.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Every propositional formula is either a variable `var n`, the constant false
    `fls`, or a compound formula of the form `conj A B`, `disj A B`, or `impl A B`.
    With ordinary mathematical notation, these are commonly written \(p_n\), \(\bot\),
    \(A \wedge B\), \(A \vee B\), and \(A \to B\), respectively. The other propositional
    connectives can be defined in terms of these; for example, we can define \(\neg
    A\) as \(A \to \bot\) and \(A \leftrightarrow B\) as \((A \to B) \wedge (B \to
    A)\).
  prefs: []
  type: TYPE_NORMAL
- en: Having defined the data type of propositional formulas, we define what it means
    to evaluate a propositional formula with respect to an assignment `v` of Boolean
    truth values to the variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: The next definition specifies the set of variables occurring in a formula, and
    the subsequent theorem shows that evaluating a formula on two truth assignments
    that agree on its variables yields that same value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Noticing the repetition, we can be clever about the use of automation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: The function `subst A m C` describes the result of substituting the formula
    `C` for every occurrence of the variable `var m` in the formula `A`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example, show that substituting for a variable that does not occur in
    a formula has no effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'The following theorem says something more subtle and interesting: evaluating
    `A.subst n C` on a truth assignment `v` is the same as evaluating `A` on a truth
    assignment that assigns the value of `C` to `var n`. See if you can prove it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]*'
  prefs: []
  type: TYPE_NORMAL
