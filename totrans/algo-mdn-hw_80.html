<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Search Trees</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Search Trees</h1>
<blockquote>原文：<a href="https://en.algorithmica.org/hpc/data-structures/b-tree/">https://en.algorithmica.org/hpc/data-structures/b-tree/</a></blockquote><div id="search"><input id="search-bar" type="search" placeholder="Search this book…" oninput="search()"/><div id="search-count"/><div id="search-results"/></div><header><div class="info"/></header><article><p>In the <a href="../s-tree">previous article</a>, we designed and implemented <em>static</em> B-trees to speed up binary searching in sorted arrays. In its <a href="../s-tree/#as-a-dynamic-tree">last section</a>, we briefly discussed how to make them <em>dynamic</em> back while retaining the performance gains from <a href="/hpc/simd">SIMD</a> and validated our predictions by adding and following explicit pointers in the internal nodes of the S+ tree.</p><p>In this article, we follow up on that proposition and design a minimally functional search tree for integer keys, <a href="#evaluation">achieving</a> up to 18x/8x speedup over <code>std::set</code> and up to 7x/2x speedup over <a href="https://abseil.io/blog/20190812-btree"><code>absl::btree</code></a> for <code>lower_bound</code> and <code>insert</code> queries, respectively — with yet ample room for improvement.</p><p>The memory overhead of the structure is around 30% for 32-bit integers, and the final implementation is <a href="https://github.com/sslotin/amh-code/blob/main/b-tree/btree-final.cc">under 150 lines of C++</a>. It can be easily generalized to other arithmetic types and small/fixed-length strings such as hashes, country codes, and stock symbols.</p><span class="anchor" id="b-tree"/><h2><a class="anchor-link" href="https://en.algorithmica.org/hpc/data-structures/b-tree/#b-tree">#</a>B− Tree</h2><p>Instead of making small incremental improvements like we usually do in other case studies, in this article, we will implement just one data structure that we name <em>B− tree</em>, which is based on the <a href="../s-tree/#b-tree-layout-1">B+ tree</a>, with a few minor differences:</p><ul><li>Nodes in the B− tree do not store pointers or any metadata except for the pointers to internal node children (while the B+ tree leaf nodes store a pointer to the next leaf node). This lets us perfectly place the keys in the leaf nodes on cache lines.</li><li>We define key $i$ to be the <em>maximum</em> key in the subtree of the child $i$ instead of the <em>minimum</em> key in the subtree of the child $(i + 1)$. This lets us not fetch any other nodes after we reach a leaf (in the B+ tree, all keys in the leaf node may be less than the search key, so we need to go to the next leaf node to fetch its first element).</li></ul><p>We also use a node size of $B=32$, which is smaller than typical. The reason why it is not $16$, which was <a href="../s-tree/#modifications-and-further-optimizations">optimal for the S+ tree</a>, is because we have the additional overhead associated with fetching the pointer, and the benefit of reducing the tree height by ~20% outweighs the cost of processing twice the elements per node, and also because it improves the running time of the <code>insert</code> query that needs to perform a costly node split every $\frac{B}{2}$ insertions on average.</p><span class="anchor" id="memory-layout"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/data-structures/b-tree/#memory-layout">#</a>Memory Layout</h3><p>Although this is probably not the best approach in terms of software engineering, we will simply store the entire tree in a large pre-allocated array, without discriminating between leaves and internal nodes:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">R</span> <span class="o">=</span> <span class="mf">1e8</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">alignas</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span> <span class="kt">int</span> <span class="n">tree</span><span class="p">[</span><span class="n">R</span><span class="p">];</span>
</span></span></code></pre></div><p>We also pre-fill this array with infinities to simplify the implementation:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">R</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
</span></span></code></pre></div><p>(In general, it is technically cheating to compare against <code>std::set</code> or other structures that use <code>new</code> under the hood, but memory allocation and initialization are not the bottlenecks here, so this does not significantly affect the evaluation.)</p><p>Both nodes types store their keys sequentially in sorted order and are identified by the index of its first key in the array:</p><ul><li>A leaf node has up to $(B - 1)$ keys but is padded to $B$ elements with infinities.</li><li>An internal node has up to $(B - 2)$ keys padded to $B$ elements and up to $(B - 1)$ indices of its child nodes, also padded to $B$ elements.</li></ul><p>These design decisions are not arbitrary:</p><ul><li>The padding ensures that leaf nodes occupy exactly 2 cache lines and internal nodes occupy exactly 4 cache lines.</li><li>We specifically use <a href="/hpc/cpu-cache/pointers/">indices instead of pointers</a> to save cache space and make moving them with SIMD faster.<br/>(We will use “pointer” and “index” interchangeably from now on.)</li><li>We store indices right after the keys even though they are stored in separate cache lines because <a href="/hpc/cpu-cache/aos-soa/">we have reasons</a>.</li><li>We intentionally “waste” one array cell in leaf nodes and $2+1=3$ cells in internal nodes because we need it to store temporary results during a node split.</li></ul><p>Initially, we only have one empty leaf node as the root:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">B</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">root</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// where the keys of the root start
</span></span></span><span class="line"><span class="cl"><span class="c1"/><span class="kt">int</span> <span class="n">n_tree</span> <span class="o">=</span> <span class="n">B</span><span class="p">;</span> <span class="c1">// number of allocated array cells
</span></span></span><span class="line"><span class="cl"><span class="c1"/><span class="kt">int</span> <span class="n">H</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>      <span class="c1">// current tree height
</span></span></span></code></pre></div><p>To “allocate” a new node, we simply increase <code>n_tree</code> by $B$ if it is a leaf node or by $2 B$ if it is an internal node.</p><p>Since new nodes can only be created by splitting a full node, each node except for the root will be at least half full. This implies that we need between 4 and 8 bytes per integer element (the internal nodes will contribute $\frac{1}{16}$-th or so to that number), the former being the case when the inserts are sequential, and the latter being the case when the input is adversarial. When the queries are uniformly distributed, the nodes are ~75% full on average, projecting to ~5.2 bytes per element.</p><p>B-trees are very memory-efficient compared to the pointer-based binary trees. For example, <code>std::set</code> needs at least three pointers (the left child, the right child, and the parent), alone costing $3 \times 8 = 24$ bytes, plus at least another $8$ bytes to store the key and the meta-information due to <a href="/hpc/cpu-cache/alignment/">structure padding</a>.</p><span class="anchor" id="searching"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/data-structures/b-tree/#searching">#</a>Searching</h3><p>It is a very common scenario when &gt;90% of operations are lookups, and even if this is not the case, every other tree operation typically begins with locating a key anyway, so we will start with implementing and optimizing the searches.</p><p>When we implemented <a href="../s-tree/#optimization">S-trees</a>, we ended up storing the keys in permuted order due to the intricacies of how the blending/packs instructions work. For the <em>dynamic tree</em> problem, storing the keys in permuted order would make inserts much harder to implement, so we will change the approach instead.</p><p>An alternative way to think about finding the would-be position of the element <code>x</code> in a sorted array is not “the index of the first element that is not less than <code>x</code>” but “the number of elements that are less than <code>x</code>.” This observation generates the following idea: compare the keys against <code>x</code>, aggregate the vector masks into a 32-bit mask (where each bit can correspond to any element as long as the mapping is bijective), and then call <code>popcnt</code> on it, returning the number of elements less than <code>x</code>.</p><p>This trick lets us perform the local search efficiently and without requiring any shuffling:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">__m256i</span> <span class="n">reg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">reg</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">reg</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">reg</span> <span class="n">y</span> <span class="o">=</span> <span class="n">_mm256_load_si256</span><span class="p">((</span><span class="n">reg</span><span class="o">*</span><span class="p">)</span> <span class="n">node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">_mm256_cmpgt_epi32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// returns how many keys are less than x
</span></span></span><span class="line"><span class="cl"><span class="c1"/><span class="kt">unsigned</span> <span class="nf">rank32</span><span class="p">(</span><span class="n">reg</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">reg</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">cmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">reg</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">cmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">node</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">reg</span> <span class="n">m3</span> <span class="o">=</span> <span class="n">cmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">node</span> <span class="o">+</span> <span class="mi">16</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">reg</span> <span class="n">m4</span> <span class="o">=</span> <span class="n">cmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">node</span> <span class="o">+</span> <span class="mi">24</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// take lower 16 bits from m1/m3 and higher 16 bits from m2/m4
</span></span></span><span class="line"><span class="cl"><span class="c1"/>    <span class="n">m1</span> <span class="o">=</span> <span class="n">_mm256_blend_epi16</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="mb">0b01010101</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">m3</span> <span class="o">=</span> <span class="n">_mm256_blend_epi16</span><span class="p">(</span><span class="n">m3</span><span class="p">,</span> <span class="n">m4</span><span class="p">,</span> <span class="mb">0b01010101</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">m1</span> <span class="o">=</span> <span class="n">_mm256_packs_epi16</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m3</span><span class="p">);</span> <span class="c1">// can also use blendv here, but packs is simpler
</span></span></span><span class="line"><span class="cl"><span class="c1"/>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">_mm256_movemask_epi8</span><span class="p">(</span><span class="n">m1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">__builtin_popcount</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Note that, because of this procedure, we have to pad the “key area” with infinities, which prevents us from storing metadata in the vacated cells (unless we are also willing to spend a few cycles to mask it out when loading a SIMD lane).</p><p>Now, to implement <code>lower_bound</code>, we can descend the tree just like we did in the S+ tree, but fetching the pointer after we compute the child number:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">lower_bound</span><span class="p">(</span><span class="kt">int</span> <span class="n">_x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="n">k</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">reg</span> <span class="n">x</span> <span class="o">=</span> <span class="n">_mm256_set1_epi32</span><span class="p">(</span><span class="n">_x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">H</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">h</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">rank32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tree</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="n">k</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">B</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">rank32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tree</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">tree</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Implementing search is easy, and it doesn’t introduce much overhead. The hard part is implementing insertion.</p><span class="anchor" id="insertion"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/data-structures/b-tree/#insertion">#</a>Insertion</h3><p>On the one side, correctly implementing insertion takes a lot of code, but on the other, most of that code is executed very infrequently, so we don’t have to care about its performance that much. Most often, all we need to do is to reach the leaf node (which we’ve already figured out how to do) and then insert a new key into it, moving some suffix of the keys one position to the right. Occasionally, we also need to split the node and/or update some ancestors, but this is relatively rare, so let’s focus on the most common execution path first.</p><p>To insert a key into an array of $(B - 1)$ sorted elements, we can load them in vector registers and then <a href="/hpc/simd/masking">mask-store</a> them one position to the right using a <a href="/hpc/compilation/precalc/">precomputed</a> mask that tells which elements need to be written for a given <code>i</code>:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Precalc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">alignas</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">[</span><span class="n">B</span><span class="p">][</span><span class="n">B</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="nf">Precalc</span><span class="p">()</span> <span class="o">:</span> <span class="n">mask</span><span class="p">{}</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">B</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">B</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// everything from i to B - 2 inclusive needs to be moved
</span></span></span><span class="line"><span class="cl"><span class="c1"/>                <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">Precalc</span> <span class="n">P</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// need to iterate right-to-left to not overwrite the first element of the next lane
</span></span></span><span class="line"><span class="cl"><span class="c1"/>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">B</span> <span class="o">-</span> <span class="mi">8</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// load the keys
</span></span></span><span class="line"><span class="cl"><span class="c1"/>        <span class="n">reg</span> <span class="n">t</span> <span class="o">=</span> <span class="n">_mm256_load_si256</span><span class="p">((</span><span class="n">reg</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">node</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// load the corresponding mask
</span></span></span><span class="line"><span class="cl"><span class="c1"/>        <span class="n">reg</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">_mm256_load_si256</span><span class="p">((</span><span class="n">reg</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">P</span><span class="p">.</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// mask-write them one position to the right
</span></span></span><span class="line"><span class="cl"><span class="c1"/>        <span class="n">_mm256_maskstore_epi32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">mask</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// finally, write the element itself
</span></span></span><span class="line"><span class="cl"><span class="c1"/><span class="p">}</span>
</span></span></code></pre></div><p>This <a href="/hpc/compilation/precalc/">constexpr magic</a> is the only C++ feature we use.</p><p>There are other ways to do it, some possibly more efficient, but we are going to stop there for now.</p><p>When we split a node, we need to move half of the keys to another node, so let’s write another primitive that does it:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// move the second half of a node and fill it with infinities
</span></span></span><span class="line"><span class="cl"><span class="c1"/><span class="kt">void</span> <span class="nf">move</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">to</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">reg</span> <span class="n">infs</span> <span class="o">=</span> <span class="n">_mm256_set1_epi32</span><span class="p">(</span><span class="n">INT_MAX</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">B</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">t</span> <span class="o">=</span> <span class="n">_mm256_load_si256</span><span class="p">((</span><span class="n">reg</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">from</span><span class="p">[</span><span class="n">B</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="n">_mm256_store_si256</span><span class="p">((</span><span class="n">reg</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">to</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">_mm256_store_si256</span><span class="p">((</span><span class="n">reg</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">from</span><span class="p">[</span><span class="n">B</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">i</span><span class="p">],</span> <span class="n">infs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>With these two vector functions implemented, we can now very carefully implement insertion:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">_x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// the beginning of the procedure is the same as in lower_bound,
</span></span></span><span class="line"><span class="cl"><span class="c1"/>    <span class="c1">// except that we save the path in case we need to update some of our ancestors
</span></span></span><span class="line"><span class="cl"><span class="c1"/>    <span class="kt">unsigned</span> <span class="n">sk</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">si</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// k and i on each iteration
</span></span></span><span class="line"><span class="cl"><span class="c1"/>    <span class="c1">//           ^------^ We assume that the tree height does not exceed 10
</span></span></span><span class="line"><span class="cl"><span class="c1"/>    <span class="c1">//                    (which would require at least 16^10 elements)
</span></span></span><span class="line"><span class="cl"><span class="c1"/>    
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="n">k</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">reg</span> <span class="n">x</span> <span class="o">=</span> <span class="n">_mm256_set1_epi32</span><span class="p">(</span><span class="n">_x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">H</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">h</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">rank32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tree</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// optionally update the key i right away
</span></span></span><span class="line"><span class="cl"><span class="c1"/>        <span class="n">tree</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">_x</span> <span class="o">&gt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">?</span> <span class="nl">_x</span> <span class="p">:</span> <span class="n">tree</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="n">sk</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span> <span class="n">si</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// and save the path
</span></span></span><span class="line"><span class="cl"><span class="c1"/>        
</span></span><span class="line"><span class="cl">        <span class="n">k</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">B</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">rank32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tree</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// we can start computing the is-full check before insertion completes
</span></span></span><span class="line"><span class="cl"><span class="c1"/>    <span class="kt">bool</span> <span class="n">filled</span>  <span class="o">=</span> <span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">B</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INT_MAX</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">insert</span><span class="p">(</span><span class="n">tree</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">_x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">filled</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// the node needs to be split, so we create a new leaf node
</span></span></span><span class="line"><span class="cl"><span class="c1"/>        <span class="n">move</span><span class="p">(</span><span class="n">tree</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">tree</span> <span class="o">+</span> <span class="n">n_tree</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">B</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// new key to be inserted
</span></span></span><span class="line"><span class="cl"><span class="c1"/>        <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">n_tree</span><span class="p">;</span>              <span class="c1">// pointer to the newly created node
</span></span></span><span class="line"><span class="cl"><span class="c1"/>        
</span></span><span class="line"><span class="cl">        <span class="n">n_tree</span> <span class="o">+=</span> <span class="n">B</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">H</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">h</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">h</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// ascend and repeat until we reach the root or find a the node is not split
</span></span></span><span class="line"><span class="cl"><span class="c1"/>            <span class="n">k</span> <span class="o">=</span> <span class="n">sk</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">i</span> <span class="o">=</span> <span class="n">si</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">filled</span> <span class="o">=</span> <span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">B</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INT_MAX</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// the node already has a correct key (the right one)
</span></span></span><span class="line"><span class="cl"><span class="c1"/>            <span class="c1">//                  and a correct pointer (the left one)
</span></span></span><span class="line"><span class="cl"><span class="c1"/>            <span class="n">insert</span><span class="p">(</span><span class="n">tree</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span>     <span class="n">i</span><span class="p">,</span>     <span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">insert</span><span class="p">(</span><span class="n">tree</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="n">B</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filled</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span><span class="p">;</span> <span class="c1">// we're done
</span></span></span><span class="line"><span class="cl"><span class="c1"/>
</span></span><span class="line"><span class="cl">            <span class="c1">// create a new internal node
</span></span></span><span class="line"><span class="cl"><span class="c1"/>            <span class="n">move</span><span class="p">(</span><span class="n">tree</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span>     <span class="n">tree</span> <span class="o">+</span> <span class="n">n_tree</span><span class="p">);</span>     <span class="c1">// move keys
</span></span></span><span class="line"><span class="cl"><span class="c1"/>            <span class="n">move</span><span class="p">(</span><span class="n">tree</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="n">B</span><span class="p">,</span> <span class="n">tree</span> <span class="o">+</span> <span class="n">n_tree</span> <span class="o">+</span> <span class="n">B</span><span class="p">);</span> <span class="c1">// move pointers
</span></span></span><span class="line"><span class="cl"><span class="c1"/>
</span></span><span class="line"><span class="cl">            <span class="n">v</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">B</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">tree</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">B</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">p</span> <span class="o">=</span> <span class="n">n_tree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">n_tree</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">B</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// if reach here, this means we've reached the root,
</span></span></span><span class="line"><span class="cl"><span class="c1"/>        <span class="c1">// and it was split into two, so we need a new root
</span></span></span><span class="line"><span class="cl"><span class="c1"/>        <span class="n">tree</span><span class="p">[</span><span class="n">n_tree</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">tree</span><span class="p">[</span><span class="n">n_tree</span> <span class="o">+</span> <span class="n">B</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">tree</span><span class="p">[</span><span class="n">n_tree</span> <span class="o">+</span> <span class="n">B</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">root</span> <span class="o">=</span> <span class="n">n_tree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">n_tree</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">B</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">H</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>There are many inefficiencies, but, luckily, the body of <code>if (filled)</code> is executed very infrequently — approximately every $\frac{B}{2}$ insertions — and the insertion performance is not really our top priority, so we will just leave it there.</p><span class="anchor" id="evaluation"/><h2><a class="anchor-link" href="https://en.algorithmica.org/hpc/data-structures/b-tree/#evaluation">#</a>Evaluation</h2><p>We have only implemented <code>insert</code> and <code>lower_bound</code>, so this is what we will measure.</p><p>We want the evaluation to take a reasonable time, so our benchmark is a loop that alternates between two steps:</p><ul><li>Increase the structure size from $1.17^k$ to $1.17^{k+1}$ using individual <code>insert</code>s and measure the time it took.</li><li>Perform $10^6$ random <code>lower_bound</code> queries and measure the time it took.</li></ul><p>We start at the size $10^4$ and end at $10^7$, for around $50$ data points in total. We generate the data for both query types uniformly in the $[0, 2^{30})$ range and independently between the stages. Since the data generation process allows for repeated keys, we compared against <code>std::multiset</code> and <code>absl::btree_multiset</code><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>, although we still refer to them as <code>std::set</code> and <code>absl::btree</code> for brevity. We also enable <a href="/hpc/cpu-cache/paging">hugepages</a> on the system level for all three runs.</p><p>The performance of the B− tree matches what we originally predicted — at least for the lookups:</p><p><figure><img src="../Images/26083816f86f5976244114da1efa0dab.png" data-original-src="https://en.algorithmica.org/hpc/data-structures/img/btree-absolute.svg"/><figcaption/></figure></p><p>The relative speedup varies with the structure size — 7-18x/3-8x over STL and 3-7x/1.5-2x over Abseil:</p><p><figure><img src="../Images/18c97b4d8a35a1b9df83ca03db53208d.png" data-original-src="https://en.algorithmica.org/hpc/data-structures/img/btree-relative.svg"/><figcaption/></figure></p><p>Insertions are only 1.5-2 faster than for <code>absl::btree</code>, which uses scalar code to do everything. My best guess why insertions are <em>that</em> slow is due to data dependency: since the tree nodes may change, the CPU can’t start processing the next query before the previous one finishes (the <a href="../s-tree/#comparison-with-stdlower_bound">true latency</a> of both queries is roughly equal and ~3x of the reciprocal throughput of <code>lower_bound</code>).</p><p><figure><img src="../Images/0449323c1e75d28258465c347b9aff02.png" data-original-src="https://en.algorithmica.org/hpc/data-structures/img/btree-absl.svg"/><figcaption/></figure></p><p>When the structure size is small, the <a href="../s-tree/#comparison-with-stdlower_bound">reciprocal throughput</a> of <code>lower_bound</code> increases in discrete steps: it starts with 3.5ns when there is only the root to visit, then grows to 6.5ns (two nodes), and then to 12ns (three nodes), and then hits the L2 cache (not shown on the graphs) and starts increasing more smoothly, but still with noticeable spikes when the tree height increases.</p><p>Interestingly, B− tree outperforms <code>absl::btree</code> even when it only stores a single key: it takes around 5ns stalling on <a href="/hpc/pipelining/branching/">branch misprediction</a>, while (the search in) the B− tree is entirely branchless.</p><span class="anchor" id="possible-optimizations"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/data-structures/b-tree/#possible-optimizations">#</a>Possible Optimizations</h3><p>In our previous endeavors in data structure optimization, it helped a lot to make as many variables as possible compile-time constants: the compiler can hardcode these constants into the machine code, simplify the arithmetic, unroll all the loops, and do many other nice things for us.</p><p>This would not be a problem at all if our tree were of constant height, but it is not. It is <em>largely</em> constant, though: the height rarely changes, and in fact, under the constraints of the benchmark, the maximum height was only 6.</p><p>What we can do is pre-compile the <code>insert</code> and <code>lower_bound</code> functions for several different compile-time constant heights and switch between them as the tree grows. The idiomatic C++ way is to use virtual functions, but I prefer to be explicit and use raw function pointers like this:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">insert_ptr</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lower_bound_ptr</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">insert_ptr</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">lower_bound</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">lower_bound_ptr</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>We now define template functions that have the tree height as a parameter, and in the grow-tree block inside the <code>insert</code> function, we change the pointers as the tree grows:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">H</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">insert_impl</span><span class="p">(</span><span class="kt">int</span> <span class="n">_x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"/><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">H</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">insert_impl</span><span class="p">(</span><span class="kt">int</span> <span class="n">_x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"/>    <span class="k">if</span> <span class="p">(</span><span class="cm">/* tree grows */</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"/>        <span class="n">insert_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">insert_impl</span><span class="o">&lt;</span><span class="n">H</span> <span class="o">+</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">lower_bound_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lower_bound_impl</span><span class="o">&lt;</span><span class="n">H</span> <span class="o">+</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">insert_impl</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"This depth was not supposed to be reached"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>I tried but could not get any performance improvement with this, but I still have high hope for this approach because the compiler can (theoretically) remove <code>sk</code> and <code>si</code>, completely removing any temporary storage and only reading and computing everything once, greatly optimizing the <code>insert</code> procedure.</p><p>Insertion can also probably be optimized by using a larger block size as node splits would become rare, but this comes at the cost of slower lookups. We could also try different node sizes for different layers: leaves should probably be larger than the internal nodes.</p><p><strong>Another idea</strong> is to move extra keys on insert to a sibling node, delaying the node split as long as possible.</p><p>One such particular modification is known as the B* tree. It moves the last key to the next node if the current one is full, and when both nodes become full, it jointly splits both of them, producing three nodes that are ⅔ full. This reduces the memory overhead (the nodes will be ⅚ full on average) and increases the fanout factor, reducing the height, which helps all operations.</p><p>This technique can even be extended to, say, three-to-four splits, although further generalization would come at the cost of a slower <code>insert</code>.</p><p><strong>And yet another idea</strong> is to get rid of (some) pointers. For example, for large trees, we can probably afford a small <a href="../s-tree">S+ tree</a> for $16 \cdot 17$ or so elements as the root, which we rebuild from scratch on each infrequent occasion when it changes. You can’t extend it to the whole tree, unfortunately: I believe there is a paper somewhere saying that we can’t turn a dynamic structure fully implicit without also having to do $\Omega(\sqrt n)$ operations per query.</p><p>We could also try some non-tree data structures, such as the <a href="https://en.wikipedia.org/wiki/Skip_list">skip list</a>. There has even been a <a href="https://doublequan.github.io/">successful attempt to vectorize it</a> — although the speedup was not that impressive. I have low hope that skip-list, in particular, can be improved, although it may achieve a higher total throughput in the concurrent setting.</p><span class="anchor" id="other-operations"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/data-structures/b-tree/#other-operations">#</a>Other Operations</h3><p>To <em>delete</em> a key, we can similarly locate and remove it from a node with the same mask-store trick. After that, if the node is at least half-full, we’re done. Otherwise, we try to borrow a key from the next sibling. If the sibling has more than $\frac{B}{2}$ keys, we append its first key and shift its keys one to the left. Otherwise, both the current node and the next node have less than $\frac{B}{2}$ keys, so we can merge them, after which we go to the parent and iteratively delete a key there.</p><p>Another thing we may want to implement is <em>iteration</em>. Bulk-loading each key from <code>l</code> to <code>r</code> is a very common pattern — for example, in <code>SELECT abc ORDER BY xyz</code> type of queries in databases — and B+ trees usually store pointers to the next node in the data layer to allow for this type of rapid iteration. In B− trees, as we’re using a much smaller node size, we can experience <a href="/hpc/cpu-cache/latency/">pointer chasing</a> problems if we do this. Going to the parent and reading all its $B$ pointers is probably faster as it negates this problem. Therefore, a stack of ancestors (the <code>sk</code> and <code>si</code> arrays we used in <code>insert</code>) can serve as an iterator and may even be better than separately storing pointers in nodes.</p><p>We can easily implement almost everything that <code>std::set</code> does, but the B− tree, like any other B-tree, is very unlikely to become a drop-in replacement to <code>std::set</code> due to the requirement of pointer stability: a pointer to an element should remain valid unless the element is deleted, which is hard to achieve when we split and merge nodes all the time. This is a major problem not only for search trees but most data structures in general: having both pointer stability and high performance at the same time is next to impossible.</p><span class="anchor" id="acknowledgements"/><h2><a class="anchor-link" href="https://en.algorithmica.org/hpc/data-structures/b-tree/#acknowledgements">#</a>Acknowledgements</h2><p>Thanks to <a href="https://danlark.org/">Danila Kutenin</a> from Google for meaningful discussions of applicability and the usage of B-trees in Abseil.</p><section class="footnotes" role="doc-endnotes"><hr/><ol><li id="fn:1" role="doc-endnote"><p>If you also think that only comparing with Abseil’s B-tree is not convincing enough, <a href="https://github.com/sslotin/amh-code/tree/main/b-tree">feel free</a> to add your favorite search tree to the benchmark. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">↩︎</a></p></li></ol></section></article><div class="nextprev"><div class="left"><a href="https://en.algorithmica.org/hpc/data-structures/s-tree/" id="prev-article">← Static B-Trees</a></div><div class="right"><a href="https://en.algorithmica.org/hpc/data-structures/segment-trees/" id="next-article">Segment Trees →</a></div></div>    
</body>
</html>