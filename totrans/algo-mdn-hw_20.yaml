- en: Situational Optimizations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情境优化
- en: 原文：[https://en.algorithmica.org/hpc/compilation/situational/](https://en.algorithmica.org/hpc/compilation/situational/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/compilation/situational/](https://en.algorithmica.org/hpc/compilation/situational/)
- en: Most compiler optimizations enabled by `-O2` and `-O3` are guaranteed to either
    improve or at least not seriously hurt performance. Those that aren’t included
    in `-O3` are either not strictly standard-compliant, or highly circumstantial
    and require some additional input from the programmer to help decide whether using
    them is beneficial.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`-O2`和`-O3`启用的大多数编译器优化都保证要么改进性能，至少不会严重损害性能。那些不包括在`-O3`中的优化要么不是严格符合标准的，或者非常具体，需要程序员提供一些额外的输入来帮助决定使用它们是否有益。
- en: Let’s discuss the most frequently used ones that we’ve also previously covered
    in this book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下这本书中我们已经多次提到的最常用的那些。
- en: '### [#](https://en.algorithmica.org/hpc/compilation/situational/#loop-unrolling)Loop
    Unrolling'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/compilation/situational/#loop-unrolling)循环展开'
- en: '[Loop unrolling](/hpc/architecture/loops#loop-unrolling) is disabled by default,
    unless the loop takes a small constant number of iterations known at compile time
    — in which case it will be replaced with a completely jump-free, repeated sequence
    of instructions. It can be enabled globally with the `-funroll-loops` flag, which
    will unroll all loops whose number of iterations can be determined at compile
    time or upon entry to the loop.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[循环展开](/hpc/architecture/loops#loop-unrolling)默认是禁用的，除非循环在编译时已知迭代次数是一个小的常数——在这种情况下，它将被替换为一个完全无跳转的、重复的指令序列。可以通过`-funroll-loops`标志全局启用，这将展开所有在编译时或在循环入口时可以确定迭代次数的循环。'
- en: 'You can also use a pragma to target a specific loop:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用一个pragma来针对特定的循环：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Loop unrolling makes binary larger, and may or may not make it run faster. Don’t
    use it fanatically.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 循环展开会使二进制文件更大，并且可能或可能不会使其运行更快。不要狂热地使用它。
- en: '### [#](https://en.algorithmica.org/hpc/compilation/situational/#function-inlining)Function
    Inlining'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/compilation/situational/#function-inlining)函数内联'
- en: '[Inlining](/hpc/architecture/functions#inlining) is best left for the compiler
    to decide, but you can influence it with `inline` keyword:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[内联](/hpc/architecture/functions#inlining)最好留给编译器来决定，但你可以通过`inline`关键字来影响它：'
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The hint may be ignored though if the compiler thinks that the potential performance
    gains are not worth it. You can force inlining by adding the `always_inline` attribute:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译器认为潜在的性能提升不值得，可能会忽略这个提示。你可以通过添加`always_inline`属性来强制内联：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There is also the `-finline-limit=n` option which lets you set a specific threshold
    on the size of inlined functions (in terms of the number of instructions). Its
    Clang equivalent is `-inline-threshold`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`-finline-limit=n`选项，它允许你设置内联函数大小的特定阈值（以指令数量计）。它的Clang等价项是`-inline-threshold`。
- en: '### [#](https://en.algorithmica.org/hpc/compilation/situational/#likeliness-of-branches)Likeliness
    of Branches'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/compilation/situational/#likeliness-of-branches)分支的可能性'
- en: '[Likeliness of branches](/hpc/architecture/layout#unequal-branches) can be
    hinted by `[[likely]]` and `[[unlikely]]` attributes in `if`-s and `switch`-es:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[分支的可能性](/hpc/architecture/layout#unequal-branches)可以通过`[[likely]]`和`[[unlikely]]`属性在`if`和`switch`中提示：'
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is a new feature that only appeared in C++20\. Before that, there were
    compiler-specific intrinsics similarly used to wrap condition expressions. The
    same example in older GCC:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个只在C++20中出现的全新功能。在此之前，有编译器特定的内建函数被用来封装条件表达式。在较老的GCC中的相同示例：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There are many other cases like this when you need to point the compiler in
    the right direction, but we will get to them later when they become more relevant.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要指导编译器走向正确的方向时，还有很多其他类似的情况，但我们将稍后当它们变得更加相关时再讨论。
- en: '### [#](https://en.algorithmica.org/hpc/compilation/situational/#profile-guided-optimization)Profile-Guided
    Optimization'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/compilation/situational/#profile-guided-optimization)基于配置文件优化'
- en: Adding all this metadata to the source code is tedious. People already hate
    writing C++ even without having to do it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些元数据添加到源代码中是繁琐的。人们已经讨厌编写C++，即使不需要这样做。
- en: 'It is also not always obvious whether certain optimizations are beneficial
    or not. To make a decision about branch reordering, function inlining, or loop
    unrolling, we need answers to questions like these:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是总是很明显某些优化是有益的还是无益的。为了决定分支重排、函数内联或循环展开，我们需要回答如下问题：
- en: How often is this branch taken?
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个分支被取用的频率是多少？
- en: How often is this function called?
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数被调用的频率是多少？
- en: What is the average number of iterations in this loop?
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个循环的平均迭代次数是多少？
- en: Luckily for us, there is a way to provide this real-world information automatically.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们有一种方法可以自动提供这种现实世界的信息。
- en: '*Profile-guided optimization* (PGO, also called “pogo” because it’s easier
    and more fun to pronounce) is a technique that uses [profiling data](/hpc/profiling)
    to improve performance beyond what can be achieved with just static analysis.
    In a nutshell, it involves adding timers and counters to the points of interest
    in the program, compiling and running it on real data, and then compiling it again,
    but this time supplying additional information from the test run.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于性能分析的优化*（PGO，也称为“pogo”，因为它更容易发音且更有趣）是一种使用 [性能分析数据](/hpc/profiling) 来提高性能的技术，这种性能是仅通过静态分析无法实现的。简单来说，它包括在程序中感兴趣的地方添加计时器和计数器，使用真实数据编译并运行程序，然后再次编译，但这次提供测试运行中的额外信息。'
- en: 'The whole process is automated by modern compilers. For example, the `-fprofile-generate`
    flag will let GCC instrument the program with profiling code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程都由现代编译器自动化完成。例如，`-fprofile-generate` 标志会让 GCC 在程序中插入性能分析代码：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After we run the program — preferably on input that is as representative of
    the real use case as possible — it will create a bunch of `*.gcda` files that
    contain log data for the test run, after which we can rebuild the program, but
    now adding the `-fprofile-use` flag:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行程序之后——最好是使用尽可能代表实际用例的输入——它将创建一些 `*.gcda` 文件，这些文件包含测试运行的日志数据，之后我们可以重新构建程序，但现在添加
    `-fprofile-use` 标志：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It usually improves performance by 10-20% for large codebases, and for this
    reason it is commonly included in the build process of performance-critical projects.
    This is more reason to invest in solid benchmarking code. [← Flags and Targets](https://en.algorithmica.org/hpc/compilation/flags/)[Contract
    Programming →](https://en.algorithmica.org/hpc/compilation/contracts/)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常可以将大型代码库的性能提高10-20%，因此它通常被包含在性能关键项目的构建过程中。这是投资于可靠的基准测试代码的另一个原因。[← 标志和目标](https://en.algorithmica.org/hpc/compilation/flags/)[契约编程
    →](https://en.algorithmica.org/hpc/compilation/contracts/)
