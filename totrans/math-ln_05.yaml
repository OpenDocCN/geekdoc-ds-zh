- en: 5\. Elementary Number Theory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5\. 初等数论
- en: 原文：[https://leanprover-community.github.io/mathematics_in_lean/C05_Elementary_Number_Theory.html](https://leanprover-community.github.io/mathematics_in_lean/C05_Elementary_Number_Theory.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://leanprover-community.github.io/mathematics_in_lean/C05_Elementary_Number_Theory.html](https://leanprover-community.github.io/mathematics_in_lean/C05_Elementary_Number_Theory.html)
- en: '*[Mathematics in Lean](index.html)* **   5\. Elementary Number Theory'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*[Mathematics in Lean](index.html)* **   5\. 初等数论'
- en: '[View page source](_sources/C05_Elementary_Number_Theory.rst.txt)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[查看页面源代码](_sources/C05_Elementary_Number_Theory.rst.txt)'
- en: '* * *'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: In this chapter, we show you how to formalize some elementary results in number
    theory. As we deal with more substantive mathematical content, the proofs will
    get longer and more involved, building on the skills you have already mastered.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您展示如何形式化一些初等数论的结果。随着我们处理更实质性的数学内容，证明将变得更长、更复杂，建立在您已经掌握的技能之上。
- en: '## 5.1\. Irrational Roots[](#irrational-roots "Link to this heading")'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '## 5.1\. 无理根[](#irrational-roots "链接到这个标题")'
- en: Let’s start with a fact known to the ancient Greeks, namely, that the square
    root of 2 is irrational. If we suppose otherwise, we can write \(\sqrt{2} = a
    / b\) as a fraction in lowest terms. Squaring both sides yields \(a^2 = 2 b^2\),
    which implies that \(a\) is even. If we write \(a = 2c\), then we get \(4c^2 =
    2 b^2\) and hence \(b^2 = 2 c^2\). This implies that \(b\) is also even, contradicting
    the fact that we have assumed that \(a / b\) has been reduced to lowest terms.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从古希腊人已知的一个事实开始，即 2 的平方根是无理数。如果我们假设相反的情况，我们可以将 \(\sqrt{2} = a / b\) 写成最简分数。平方两边得到
    \(a^2 = 2 b^2\)，这意味着 \(a\) 是偶数。如果我们写成 \(a = 2c\)，那么我们得到 \(4c^2 = 2 b^2\)，从而 \(b^2
    = 2 c^2\)。这表明 \(b\) 也是偶数，这与我们假设的 \(a / b\) 已经被化简到最简形式的事实相矛盾。
- en: Saying that \(a / b\) is a fraction in lowest terms means that \(a\) and \(b\)
    do not have any factors in common, which is to say, they are *coprime*. Mathlib
    defines the predicate `Nat.Coprime m n` to be `Nat.gcd m n = 1`. Using Lean’s
    anonymous projection notation, if `s` and `t` are expressions of type `Nat`, we
    can write `s.Coprime t` instead of `Nat.Coprime s t`, and similarly for `Nat.gcd`.
    As usual, Lean will often unfold the definition of `Nat.Coprime` automatically
    when necessary, but we can also do it manually by rewriting or simplifying with
    the identifier `Nat.Coprime`. The `norm_num` tactic is smart enough to compute
    concrete values.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 说 \(a / b\) 是最简分数，意味着 \(a\) 和 \(b\) 没有任何公因数，也就是说，它们是 *互质*。Mathlib 定义谓词 `Nat.Coprime
    m n` 为 `Nat.gcd m n = 1`。使用 Lean 的匿名投影符号，如果 `s` 和 `t` 是类型为 `Nat` 的表达式，我们可以写 `s.Coprime
    t` 而不是 `Nat.Coprime s t`，对于 `Nat.gcd` 也是如此。通常，当需要时，Lean 会自动展开 `Nat.Coprime` 的定义，但我们可以通过重写或使用标识符
    `Nat.Coprime` 来手动进行。`norm_num` 策略足够智能，可以计算具体值。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have already encountered the `gcd` function in [Section 2.4](C02_Basics.html#more-on-order-and-divisibility).
    There is also a version of `gcd` for the integers; we will return to a discussion
    of the relationship between different number systems below. There are even a generic
    `gcd` function and generic notions of `Prime` and `Coprime` that make sense in
    general classes of algebraic structures. We will come to understand how Lean manages
    this generality in the next chapter. In the meanwhile, in this section, we will
    restrict attention to the natural numbers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [第 2.4 节](C02_Basics.html#more-on-order-and-divisibility) 遇到了 `gcd` 函数。对于整数也有
    `gcd` 的版本；我们将在下面讨论不同数系之间的关系。甚至还有一个通用的 `gcd` 函数和通用的 `Prime` 和 `Coprime` 概念，它们在一般的代数结构中是有意义的。我们将在下一章了解
    Lean 如何管理这种通用性。同时，在本节中，我们将关注自然数。
- en: We also need the notion of a prime number, `Nat.Prime`. The theorem `Nat.prime_def_lt`
    provides one familiar characterization, and `Nat.Prime.eq_one_or_self_of_dvd`
    provides another.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要理解素数的概念，`Nat.Prime`。定理 `Nat.prime_def_lt` 提供了一种熟悉的描述，而 `Nat.Prime.eq_one_or_self_of_dvd`
    提供了另一种描述。
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the natural numbers, a prime number has the property that it cannot be written
    as a product of nontrivial factors. In a broader mathematical context, an element
    of a ring that has this property is said to be *irreducible*. An element of a
    ring is said to be *prime* if whenever it divides a product, it divides one of
    the factors. It is an important property of the natural numbers that in that setting
    the two notions coincide, giving rise to the theorem `Nat.Prime.dvd_mul`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在自然数中，一个素数具有这样的性质，即它不能写成非平凡因子的乘积。在更广泛的数学背景下，具有这种性质的环的元素被称为 *不可约的*。如果一个元素在除以一个乘积时总是除以其中一个因子，那么这个元素被称为
    *素数*。自然数的一个重要性质是，在那个设置中，这两个概念是一致的，从而产生了定理 `Nat.Prime.dvd_mul`。
- en: 'We can use this fact to establish a key property in the argument above: if
    the square of a number is even, then that number is even as well. Mathlib defines
    the predicate `Even` in `Algebra.Group.Even`, but for reasons that will become
    clear below, we will simply use `2 ∣ m` to express that `m` is even.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个事实来在上述论证中建立一条关键性质：如果一个数的平方是偶数，那么那个数也是偶数。Mathlib 在 `Algebra.Group.Even`
    中定义了谓词 `Even`，但以下面的原因将变得清晰，我们将简单地使用 `2 ∣ m` 来表达 `m` 是偶数。
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we proceed, you will need to become proficient at finding the facts you need.
    Remember that if you can guess the prefix of the name and you have imported the
    relevant library, you can use tab completion (sometimes with `ctrl-tab`) to find
    what you are looking for. You can use `ctrl-click` on any identifier to jump to
    the file where it is defined, which enables you to browse definitions and theorems
    nearby. You can also use the search engine on the [Lean community web pages](https://leanprover-community.github.io/),
    and if all else fails, don’t hesitate to ask on [Zulip](https://leanprover.zulipchat.com/).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进，你需要熟练地找到所需的 facts。记住，如果你能猜出名称的前缀并且已经导入了相关库，你可以使用 tab 完成功能（有时需要按 `ctrl-tab`）来找到你想要的内容。你可以通过在任何标识符上按
    `ctrl-click` 来跳转到定义它的文件，这使你能够浏览附近的定义和定理。你还可以使用 [Lean 社区网页](https://leanprover-community.github.io/)上的搜索引擎，如果所有其他方法都失败了，不要犹豫，在
    [Zulip](https://leanprover.zulipchat.com/) 上提问。
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The heart of our proof of the irrationality of the square root of two is contained
    in the following theorem. See if you can fill out the proof sketch, using `even_of_even_sqr`
    and the theorem `Nat.dvd_gcd`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们证明平方根无理性的核心包含在以下定理中。看看你是否能完成证明草图，使用 `even_of_even_sqr` 和定理 `Nat.dvd_gcd`。
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In fact, with very few changes, we can replace `2` by an arbitrary prime. Give
    it a try in the next example. At the end of the proof, you’ll need to derive a
    contradiction from `p ∣ 1`. You can use `Nat.Prime.two_le`, which says that any
    prime number is greater than or equal to two, and `Nat.le_of_dvd`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，经过非常少的修改，我们可以将 `2` 替换为任意素数。在下一个例子中尝试一下。在证明的末尾，你需要从 `p ∣ 1` 推导出一个矛盾。你可以使用
    `Nat.Prime.two_le`，它表明任何素数都大于或等于 `2`，以及 `Nat.le_of_dvd`。
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let us consider another approach. Here is a quick proof that if \(p\) is prime,
    then \(m^2 \ne p n^2\): if we assume \(m^2 = p n^2\) and consider the factorization
    of \(m\) and \(n\) into primes, then \(p\) occurs an even number of times on the
    left side of the equation and an odd number of times on the right, a contradiction.
    Note that this argument requires that \(n\) and hence \(m\) are not equal to zero.
    The formalization below confirms that this assumption is sufficient.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一种方法。以下是一个快速证明：如果 \(p\) 是素数，那么 \(m^2 \ne p n^2\)：如果我们假设 \(m^2 = p n^2\)
    并考虑 \(m\) 和 \(n\) 的素数分解，那么 \(p\) 在等式的左边出现偶数次，在右边出现奇数次，这是一个矛盾。请注意，这个论证要求 \(n\)
    以及因此 \(m\) 不为零。下面的形式化确认了这个假设是充分的。
- en: The unique factorization theorem says that any natural number other than zero
    can be written as the product of primes in a unique way. Mathlib contains a formal
    version of this, expressed in terms of a function `Nat.primeFactorsList`, which
    returns the list of prime factors of a number in nondecreasing order. The library
    proves that all the elements of `Nat.primeFactorsList n` are prime, that any `n`
    greater than zero is equal to the product of its factors, and that if `n` is equal
    to the product of another list of prime numbers, then that list is a permutation
    of `Nat.primeFactorsList n`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一分解定理表明，除了零以外的任何自然数都可以以唯一的方式写成素数的乘积。Mathlib 包含了这个定理的正式版本，它用函数 `Nat.primeFactorsList`
    来表达，该函数返回一个数在非递减顺序中的素数因子列表。该库证明了 `Nat.primeFactorsList n` 的所有元素都是素数，任何大于零的 `n`
    都等于其因子的乘积，并且如果 `n` 等于另一个素数列表的乘积，那么那个列表是 `Nat.primeFactorsList n` 的一个排列。
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can browse these theorems and others nearby, even though we have not talked
    about list membership, products, or permutations yet. We won’t need any of that
    for the task at hand. We will instead use the fact that Mathlib has a function
    `Nat.factorization`, that represents the same data as a function. Specifically,
    `Nat.factorization n p`, which we can also write `n.factorization p`, returns
    the multiplicity of `p` in the prime factorization of `n`. We will use the following
    three facts.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以浏览这些定理以及附近的其他定理，尽管我们还没有讨论列表成员、乘积或排列。对于手头的任务，我们不需要这些。相反，我们将使用 Mathlib 有一个函数
    `Nat.factorization` 的事实，它表示与函数相同的数据。具体来说，`Nat.factorization n p`，我们也可以写成 `n.factorization
    p`，返回 `p` 在 `n` 的素数分解中的次数。我们将使用以下三个事实。
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In fact, `n.factorization` is defined in Lean as a function of finite support,
    which explains the strange notation you will see as you step through the proofs
    above. Don’t worry about this now. For our purposes here, we can use the three
    theorems above as a black box.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`n.factorization` 在 Lean 中被定义为有限支持函数，这解释了你将在上述证明中看到的奇怪符号。现在不用担心这个。就我们的目的而言，我们可以将上述三个定理作为一个黑盒使用。
- en: The next example shows that the simplifier is smart enough to replace `n^2 ≠
    0` by `n ≠ 0`. The tactic `simpa` just calls `simp` followed by `assumption`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子表明简化器足够智能，可以将 `n^2 ≠ 0` 替换为 `n ≠ 0`。`simpa` 策略只是调用 `simp` 后跟 `assumption`。
- en: See if you can use the identities above to fill in the missing parts of the
    proof.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 检查你是否可以使用上面的恒等式来填补证明中的空白部分。
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A nice thing about this proof is that it also generalizes. There is nothing
    special about `2`; with small changes, the proof shows that whenever we write
    `m^k = r * n^k`, the multiplicity of any prime `p` in `r` has to be a multiple
    of `k`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个证明的一个好处是它也具有普遍性。`2` 没有什么特别之处；经过一些小的修改，这个证明表明，每当我们将 `m^k = r * n^k` 写出来时，任何素数
    `p` 在 `r` 中的次数必须是 `k` 的倍数。
- en: 'To use `Nat.count_factors_mul_of_pos` with `r * n^k`, we need to know that
    `r` is positive. But when `r` is zero, the theorem below is trivial, and easily
    proved by the simplifier. So the proof is carried out in cases. The line `rcases
    r with _ | r` replaces the goal with two versions: one in which `r` is replaced
    by `0`, and the other in which `r` is replaces by `r + 1`. In the second case,
    we can use the theorem `r.succ_ne_zero`, which establishes `r + 1 ≠ 0` (`succ`
    stands for successor).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `Nat.count_factors_mul_of_pos` 与 `r * n^k`，我们需要知道 `r` 是正数。但当 `r` 为零时，下面的定理是显而易见的，并且可以通过简化器轻易证明。因此，证明是分情况进行的。行
    `rcases r with _ | r` 将目标替换为两个版本：一个是将 `r` 替换为 `0` 的版本，另一个是将 `r` 替换为 `r + 1` 的版本。在第二种情况下，我们可以使用定理
    `r.succ_ne_zero`，它建立了 `r + 1 ≠ 0`（`succ` 表示后继）。
- en: 'Notice also that the line that begins `have : npow_nz` provides a short proof-term
    proof of `n^k ≠ 0`. To understand how it works, try replacing it with a tactic
    proof, and then think about how the tactics describe the proof term.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，以 `have : npow_nz` 开头的行提供了一个简短的证明项证明 `n^k ≠ 0`。要理解它是如何工作的，试着用策略证明来替换它，然后思考策略是如何描述证明项的。'
- en: See if you can fill in the missing parts of the proof below. At the very end,
    you can use `Nat.dvd_sub'` and `Nat.dvd_mul_right` to finish it off.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 检查你是否可以填补下面证明中的空白部分。在最后，你可以使用 `Nat.dvd_sub'` 和 `Nat.dvd_mul_right` 来完成它。
- en: Note that this example does not assume that `p` is prime, but the conclusion
    is trivial when `p` is not prime since `r.factorization p` is then zero by definition,
    and the proof works in all cases anyway.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个例子并没有假设 `p` 是素数，但当 `p` 不是素数时，结论是显而易见的，因为根据定义，`r.factorization p` 是零，而且证明在所有情况下都适用。
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are a number of ways in which we might want to improve on these results.
    To start with, a proof that the square root of two is irrational should say something
    about the square root of two, which can be understood as an element of the real
    or complex numbers. And stating that it is irrational should say something about
    the rational numbers, namely, that no rational number is equal to it. Moreover,
    we should extend the theorems in this section to the integers. Although it is
    mathematically obvious that if we could write the square root of two as a quotient
    of two integers then we could write it as a quotient of two natural numbers, proving
    this formally requires some effort.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望以多种方式改进这些结果。首先，一个证明说两个平方根是无理数的证明应该对两个平方根有所说明，这可以理解为实数或复数中的一个元素。并且说它是无理数应该对有理数有所说明，即没有有理数等于它。此外，我们还应该将本节中的定理扩展到整数。虽然从数学上明显，如果我们能够将两个平方根写成两个整数的商，那么我们也可以将其写成两个自然数的商，但正式证明这一点需要一些努力。
- en: 'In Mathlib, the natural numbers, the integers, the rationals, the reals, and
    the complex numbers are represented by separate data types. Restricting attention
    to the separate domains is often helpful: we will see that it is easy to do induction
    on the natural numbers, and it is easiest to reason about divisibility of integers
    when the real numbers are not part of the picture. But having to mediate between
    the different domains is a headache, one we will have to contend with. We will
    return to this issue later in this chapter.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mathlib 中，自然数、整数、有理数、实数和复数分别由不同的数据类型表示。将注意力限制在单独的域中通常是有帮助的：我们将看到对自然数进行归纳是很容易的，而当实数不是图景的一部分时，对整数的可除性进行推理是最容易的。但是，在不同域之间进行调解是一个头疼的问题，我们将不得不应对。我们将在本章的后面回到这个问题。
- en: We should also expect to be able to strengthen the conclusion of the last theorem
    to say that the number `r` is a `k`-th power, since its `k`-th root is just the
    product of each prime dividing `r` raised to its multiplicity in `r` divided by
    `k`. To be able to do that we will need better means for reasoning about products
    and sums over a finite set, which is also a topic we will return to.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也应该期待能够加强最后一个定理的结论，使其表明数字 `r` 是一个 `k`-次幂，因为它的 `k`-次根正是 `r` 中每个质因子的乘积，每个质因子的幂次是
    `r` 中该质因子的幂次除以 `k`。为了能够做到这一点，我们需要更好的推理手段来处理有限集合上的乘积和求和，这也是我们将再次探讨的主题。
- en: 'In fact, the results in this section are all established in much greater generality
    in Mathlib, in `Data.Real.Irrational`. The notion of `multiplicity` is defined
    for an arbitrary commutative monoid, and that it takes values in the extended
    natural numbers `enat`, which adds the value infinity to the natural numbers.
    In the next chapter, we will begin to develop the means to appreciate the way
    that Lean supports this sort of generality.  ## 5.2\. Induction and Recursion[](#induction-and-recursion
    "Link to this heading")'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '事实上，本节中的结果在 Mathlib 中以更大的普遍性得到确立，在 `Data.Real.Irrational` 中。`multiplicity`
    的概念被定义为任意交换幺半群，并且它取值在扩展自然数 `enat` 中，它将无穷大值添加到自然数中。在下一章中，我们将开始发展欣赏 Lean 支持这种普遍性的手段。  '
- en: The set of natural numbers \(\mathbb{N} = \{ 0, 1, 2, \ldots \}\) is not only
    fundamentally important in its own right, but also a plays a central role in the
    construction of new mathematical objects. Lean’s foundation allows us to declare
    *inductive types*, which are types generated inductively by a given list of *constructors*.
    In Lean, the natural numbers are declared as follows.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 自然数集 \(\mathbb{N} = \{ 0, 1, 2, \ldots \}\) 不仅在其自身的基础上具有根本的重要性，而且在构建新的数学对象中也起着核心作用。Lean
    的基础允许我们声明 *归纳类型*，这些类型是通过给定的构造函数列表归纳生成的。在 Lean 中，自然数被声明如下。
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can find this in the library by writing `#check Nat` and then using `ctrl-click`
    on the identifier `Nat`. The command specifies that `Nat` is the datatype generated
    freely and inductively by the two constructors `zero : Nat` and `succ : Nat →
    Nat`. Of course, the library introduces notation `ℕ` and `0` for `nat` and `zero`
    respectively. (Numerals are translated to binary representations, but we don’t
    have to worry about the details of that now.)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以在图书馆中通过输入 `#check Nat` 并在标识符 `Nat` 上使用 `ctrl-click` 来找到这个。该命令指定 `Nat` 是由两个构造函数
    `zero : Nat` 和 `succ : Nat → Nat` 自由和归纳生成的数据类型。当然，库引入了 `ℕ` 和 `0` 的符号来分别表示 `nat`
    和 `zero`。 (数字被转换为二进制表示，但我们现在不必担心这个细节。)'
- en: What “freely” means for the working mathematician is that the type `Nat` has
    an element `zero` and an injective successor function `succ` whose image does
    not include `zero`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于工作的数学家来说，“自由”意味着类型`Nat`有一个元素`zero`和一个注入的后续函数`succ`，其像不包括`zero`。
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What the word “inductively” means for the working mathematician is that the
    natural numbers comes with a principle of proof by induction and a principle of
    definition by recursion. This section will show you how to use these.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于工作的数学家来说，“归纳”这个词意味着自然数伴随着归纳证明的原则和递归定义的原则。本节将向您展示如何使用这些原则。
- en: Here is an example of a recursive definition of the factorial function.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是阶乘函数的递归定义示例。
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The syntax takes some getting used to. Notice that there is no `:=` on the first
    line. The next two lines provide the base case and inductive step for a recursive
    definition. These equations hold definitionally, but they can also be used manually
    by giving the name `fac` to `simp` or `rw`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 语法需要一些时间来适应。请注意，第一行没有`:=`。接下来的两行提供了递归定义的基础情况和归纳步骤。这些等式在定义上是成立的，但也可以通过将名称`fac`赋予`simp`或`rw`来手动使用。
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The factorial function is actually already defined in Mathlib as `Nat.factorial`.
    Once again, you can jump to it by typing `#check Nat.factorial` and using `ctrl-click.`
    For illustrative purposes, we will continue using `fac` in the examples. The annotation
    `@[simp]` before the definition of `Nat.factorial` specifies that the defining
    equation should be added to the database of identities that the simplifier uses
    by default.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 阶乘函数实际上已经在Mathlib中定义为`Nat.factorial`。您可以通过输入`#check Nat.factorial`并使用`ctrl-click`来跳转到它。为了说明目的，我们将在示例中继续使用`fac`。定义`Nat.factorial`之前的注释`@[simp]`指定了定义方程应该被添加到简化器默认使用的恒等式数据库中。
- en: 'The principle of induction says that we can prove a general statement about
    the natural numbers by proving that the statement holds of 0 and that whenever
    it holds of a natural number \(n\), it also holds of \(n + 1\). The line `induction''
    n with n ih` in the proof below therefore results in two goals: in the first we
    need to prove `0 < fac 0`, and in the second we have the added assumption `ih
    : 0 < fac n` and a required to prove `0 < fac (n + 1)`. The phrase `with n ih`
    serves to name the variable and the assumption for the inductive hypothesis, and
    you can choose whatever names you want for them.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '归纳原理表明，我们可以通过证明该命题对0成立，并且每当它对自然数\(n\)成立时，它也对\(n + 1\)成立，来证明关于自然数的一般命题。因此，证明中`induction''
    n with n ih`这一行产生了两个目标：在第一个目标中，我们需要证明`0 < fac 0`，而在第二个目标中，我们有额外的假设`ih : 0 < fac
    n`和需要证明的`0 < fac (n + 1)`。短语`with n ih`用于命名归纳假设的变量和假设，您可以为它们选择任何名称。'
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `induction'` tactic is smart enough to include hypotheses that depend on
    the induction variable as part of the induction hypothesis. Step through the next
    example to see what is going on.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`归纳`策略足够智能，可以将依赖于归纳变量的假设作为归纳假设的一部分。通过逐步分析下一个示例，您可以看到发生了什么。'
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The following example provides a crude lower bound for the factorial function.
    It turns out to be easier to start with a proof by cases, so that the remainder
    of the proof starts with the case \(n = 1\). See if you can complete the argument
    with a proof by induction using `pow_succ` or `pow_succ'`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例提供了一个阶乘函数的粗糙下界。实际上，从分情况证明开始更容易，这样证明的其余部分就从`n = 1`的情况开始。看看您是否能通过使用`pow_succ`或`pow_succ'`进行归纳证明来完成论证。
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Induction is often used to prove identities involving finite sums and products.
    Mathlib defines the expressions `Finset.sum s f` where `s : Finset α` is a finite
    set of elements of the type `α` and `f` is a function defined on `α`. The codomain
    of `f` can be any type that supports a commutative, associative addition operation
    with a zero element. If you import `Algebra.BigOperators.Ring` and issue the command
    `open BigOperators`, you can use the more suggestive notation `∑ x ∈ s, f x`.
    Of course, there is an analogous operation and notation for finite products.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '归纳通常用于证明涉及有限和积的恒等式。Mathlib定义了表达式`Finset.sum s f`，其中`s : Finset α`是类型`α`的元素有限集，`f`是在`α`上定义的函数。`f`的陪域可以是支持交换、结合加法运算和零元素的任何类型。如果您导入`Algebra.BigOperators.Ring`并发出`open
    BigOperators`命令，您可以使用更具说明性的符号`∑ x ∈ s, f x`。当然，对于有限积也有类似的操作和符号。'
- en: We will talk about the `Finset` type and the operations it supports in the next
    section, and again in a later chapter. For now, we will only make use of `Finset.range
    n`, which is the finite set of natural numbers less than `n`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中讨论`Finset`类型及其支持的操作，并在稍后的章节中再次讨论。现在，我们只将使用`Finset.range n`，这是小于`n`的自然数的有限集合。
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The facts `Finset.sum_range_zero` and `Finset.sum_range_succ` provide a recursive
    description of summation up to \(n\), and similarly for products.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 事实`Finset.sum_range_zero`和`Finset.sum_range_succ`提供了求和到\(n\)的递归描述，对于乘积也是如此。
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first identity in each pair holds definitionally, which is to say, you can
    replace the proofs by `rfl`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每对中的第一个恒等式是定义性的，也就是说，你可以用`rfl`替换证明。
- en: The following expresses the factorial function that we defined as a product.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表示我们定义的阶乘函数作为乘积。
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The fact that we include `mul_comm` as a simplification rule deserves comment.
    It should seem dangerous to simplify with the identity `x * y = y * x`, which
    would ordinarily loop indefinitely. Lean’s simplifier is smart enough to recognize
    that, and applies the rule only in the case where the resulting term has a smaller
    value in some fixed but arbitrary ordering of the terms. The following example
    shows that simplifying using the three rules `mul_assoc`, `mul_comm`, and `mul_left_comm`
    manages to identify products that are the same up to the placement of parentheses
    and ordering of variables.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`mul_comm`作为简化规则包括在内，这一点值得注意。使用恒等式`x * y = y * x`进行简化似乎很危险，因为这通常会无限循环。Lean的简化器足够聪明，能够识别这一点，并且只在结果项在某些固定但任意的项的排序中具有较小值的情况下应用该规则。以下示例表明，使用三个规则`mul_assoc`、`mul_comm`和`mul_left_comm`可以成功地识别出括号位置和变量排序相同的产品。
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Roughly, the rules work by pushing parentheses to the right and then re-ordering
    the expressions on both sides until they both follow the same canonical order.
    Simplifying with these rules, and the corresponding rules for addition, is a handy
    trick.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 大概来说，这些规则通过将括号推向右边，然后重新排列两侧的表达式，直到它们都遵循相同的规范顺序来工作。使用这些规则以及相应的加法规则进行简化是一个实用的技巧。
- en: Returning to summation identities, we suggest stepping through the following
    proof that the sum of the natural numbers up to and including \(n\) is \(n (n
    + 1) / 2\). The first step of the proof clears the denominator. This is generally
    useful when formalizing identities, because calculations with division generally
    have side conditions. (It is similarly useful to avoid using subtraction on the
    natural numbers when possible.)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到求和恒等式，我们建议逐步通过以下证明，即自然数从1加到\(n\)（包括\(n\)）的和是\(n (n + 1) / 2\)。证明的第一步消除了分母。在形式化恒等式时，这通常是有用的，因为除法运算通常有附带条件。（同样，在可能的情况下避免在自然数上使用减法也是有用的。）
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We encourage you to prove the analogous identity for sums of squares, and other
    identities you can find on the web.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励你证明平方和的类似恒等式，以及你在网上可以找到的其他恒等式。
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In Lean’s core library, addition and multiplication are themselves defined using
    recursive definitions, and their fundamental properties are established using
    induction. If you like thinking about foundational topics like that, you might
    enjoy working through proofs of the commutativity and associativity of multiplication
    and addition and the distributivity of multiplication over addition. You can do
    this on a copy of the natural numbers following the outline below. Notice that
    we can use the `induction` tactic with `MyNat`; Lean is smart enough to know to
    use the relevant induction principle (which is, of course, the same as that for
    `Nat`).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lean的核心库中，加法和乘法本身是通过递归定义的，它们的基本性质是通过归纳建立的。如果你喜欢思考像那样的基础主题，你可能会喜欢通过乘法和加法的交换律和结合律以及乘法对加法的分配律的证明。你可以在以下概述的自然数副本上这样做。注意，我们可以使用`induction`策略与`MyNat`；Lean足够聪明，知道要使用相关的归纳原理（当然，这与`Nat`的相同）。
- en: We start you off with the commutativity of addition. A good rule of thumb is
    that because addition and multiplication are defined by recursion on the second
    argument, it is generally advantageous to do proofs by induction on a variable
    that occurs in that position. It is a bit tricky to decide which variable to use
    in the proof of associativity.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从加法的交换律开始。一个很好的经验法则是，由于加法和乘法是通过第二个参数的递归定义的，因此通常通过在该位置出现的变量进行归纳证明是有利的。在证明结合律时，决定使用哪个变量有点棘手。
- en: It can be confusing to write things without the usual notation for zero, one,
    addition, and multiplication. We will learn how to define such notation later.
    Working in the namespace `MyNat` means that we can write `zero` and `succ` rather
    than `MyNat.zero` and `MyNat.succ`, and that these interpretations of the names
    take precedence over others. Outside the namespace, the full name of the `add`
    defined below, for example, is `MyNat.add`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用零、一、加法和乘法的常规符号来写东西可能会让人感到困惑。我们将在后面学习如何定义这样的符号。在命名空间 `MyNat` 中工作意味着我们可以直接写
    `zero` 和 `succ`，而不是 `MyNat.zero` 和 `MyNat.succ`，并且这些名称的解释优先于其他解释。在命名空间外部，下面定义的
    `add` 的全名是 `MyNat.add`。
- en: If you find that you *really* enjoy this sort of thing, try defining truncated
    subtraction and exponentiation and proving some of their properties as well. Remember
    that truncated subtraction cuts off at zero. To define that, it is useful to define
    a predecessor function, `pred`, that subtracts one from any nonzero number and
    fixes zero. The function `pred` can be defined by a simple instance of recursion.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现你真的喜欢这类东西，可以尝试定义截断减法和指数运算，并证明它们的一些性质。记住，截断减法在零处截断。为了定义这一点，定义一个前驱函数 `pred`，它从任何非零数中减去一，并固定零。函数
    `pred` 可以通过一个简单的递归实例来定义。
- en: '[PRE23]  ## 5.3\. Infinitely Many Primes[](#infinitely-many-primes "Link to
    this heading")'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE23]  ## 5.3\. 无限多个素数[](#无限多个素数 "链接到这个标题")'
- en: 'Let us continue our exploration of induction and recursion with another mathematical
    standard: a proof that there are infinitely many primes. One way to formulate
    this is as the statement that for every natural number \(n\), there is a prime
    number greater than \(n\). To prove this, let \(p\) be any prime factor of \(n!
    + 1\). If \(p\) is less than or equal to \(n\), it divides \(n!\). Since it also
    divides \(n! + 1\), it divides 1, a contradiction. Hence \(p\) is greater than
    \(n\).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续用另一个数学标准来探索归纳和递归：证明存在无限多个素数。一种表述方式是，对于每个自然数 \(n\)，都存在一个大于 \(n\) 的素数。为了证明这一点，设
    \(p\) 为 \(n! + 1\) 的任何素数因子。如果 \(p\) 小于或等于 \(n\)，它就整除 \(n!\)。由于它也整除 \(n! + 1\)，它就整除
    1，这是矛盾的。因此 \(p\) 大于 \(n\)。
- en: 'To formalize that proof, we need to show that any number greater than or equal
    to 2 has a prime factor. To do that, we will need to show that any natural number
    that is not equal to 0 or 1 is greater-than or equal to 2. And this brings us
    to a quirky feature of formalization: it is often trivial statements like this
    that are among the most annoying to formalize. Here we consider a few ways to
    do it.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了形式化这个证明，我们需要证明任何大于或等于 2 的数都有一个素数因子。为了做到这一点，我们需要证明任何不等于 0 或 1 的自然数都大于或等于 2。这把我们带到了形式化的一个奇特特性：通常像这样的简单陈述往往是最令人烦恼的形式化。在这里，我们考虑了几种实现方法。
- en: To start with, we can use the `cases` tactic and the fact that the successor
    function respects the ordering on the natural numbers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以使用 `cases` 策略和后继函数尊重自然数上的顺序这一事实。
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Another strategy is to use the tactic `interval_cases`, which automatically
    splits the goal into cases when the variable in question is contained in an interval
    of natural numbers or integers. Remember that you can hover over it to see its
    documentation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种策略是使用 `interval_cases` 策略，该策略在变量包含在自然数或整数的区间内时自动将目标分解为情况。记住，你可以悬停在它上面以查看其文档。
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Recall that the semicolon after `interval_cases m` means that the next tactic
    is applied to each of the cases that it generates. Yet another option is to use
    the tactic `decide`, which tries to find a decision procedure to solve the problem.
    Lean knows that you can decide the truth value of a statement that begins with
    a bounded quantifier `∀ x, x < n → ...` or `∃ x, x < n ∧ ...` by deciding each
    of the finitely many instances.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`interval_cases m` 后面的分号意味着下一个策略将应用于它生成的每个情况。另一个选择是使用 `decide` 策略，它试图找到一个决策过程来解决问题。Lean
    知道你可以通过决定每个有限实例来决定以有界量词 `∀ x, x < n → ...` 或 `∃ x, x < n ∧ ...` 开头的语句的真值。
- en: '[PRE26]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With the theorem `two_le` in hand, let’s start by showing that every natural
    number greater than two has a prime divisor. Mathlib contains a function `Nat.minFac`
    that returns the smallest prime divisor, but for the sake of learning new parts
    of the library, we’ll avoid using it and prove the theorem directly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在手头有定理 `two_le` 的情况下，让我们首先证明每个大于两的自然数都有一个素数因子。Mathlib 包含一个函数 `Nat.minFac`，它返回最小的素数因子，但为了学习库的新部分，我们将避免使用它，并直接证明这个定理。
- en: Here, ordinary induction isn’t enough. We want to use *strong induction*, which
    allows us to prove that every natural number \(n\) has a property \(P\) by showing
    that for every number \(n\), if \(P\) holds of all values less than \(n\), it
    holds at \(n\) as well. In Lean, this principle is called `Nat.strong_induction_on`,
    and we can use the `using` keyword to tell the induction tactic to use it. Notice
    that when we do that, there is no base case; it is subsumed by the general induction
    step.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，普通的归纳法是不够的。我们想要使用 **强归纳法**，这允许我们通过表明对于每一个自然数 \(n\)，如果 \(P\) 对所有小于 \(n\)
    的值成立，那么它对 \(n\) 也成立，来证明每一个自然数 \(n\) 都具有属性 \(P\)。在 Lean 中，这个原则被称为 `Nat.strong_induction_on`，我们可以使用
    `using` 关键字告诉归纳策略使用它。注意，当我们这样做时，没有基本情况；它被归纳步骤所包含。
- en: The argument is simply as follows. Assuming \(n ≥ 2\), if \(n\) is prime, we’re
    done. If it isn’t, then by one of the characterizations of what it means to be
    a prime number, it has a nontrivial factor, \(m\), and we can apply the inductive
    hypothesis to that. Step through the next proof to see how that plays out.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 论证如下。假设 \(n ≥ 2\)，如果 \(n\) 是素数，那么我们就完成了。如果不是，那么根据素数含义的一个特征，它有一个非平凡因子 \(m\)，我们可以将归纳假设应用于它。通过下一个证明步骤来查看这是如何实现的。
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can now prove the following formulation of our theorem. See if you can fill
    out the sketch. You can use `Nat.factorial_pos`, `Nat.dvd_factorial`, and `Nat.dvd_sub'`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以证明我们定理的以下表述。看看你是否能完成草图。你可以使用 `Nat.factorial_pos`、`Nat.dvd_factorial` 和
    `Nat.dvd_sub'`。
- en: '[PRE28]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Let’s consider a variation of the proof above, where instead of using the factorial
    function, we suppose that we are given by a finite set \(\{ p_1, \ldots, p_n \}\)
    and we consider a prime factor of \(\prod_{i = 1}^n p_i + 1\). That prime factor
    has to be distinct from each \(p_i\), showing that there is no finite set that
    contains all the prime numbers.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑上述证明的一个变体，其中我们不是使用阶乘函数，而是假设我们被一个有限集 \(\{ p_1, \ldots, p_n \}\) 给定，并考虑 \(\prod_{i
    = 1}^n p_i + 1\) 的一个素数因子。这个素数因子必须与每个 \(p_i\) 不同，这表明不存在包含所有素数的有限集。
- en: Formalizing this argument requires us to reason about finite sets. In Lean,
    for any type `α`, the type `Finset α` represents finite sets of elements of type
    `α`. Reasoning about finite sets computationally requires having a procedure to
    test equality on `α`, which is why the snippet below includes the assumption `[DecidableEq
    α]`. For concrete data types like `ℕ`, `ℤ`, and `ℚ`, the assumption is satisfied
    automatically. When reasoning about the real numbers, it can be satisfied using
    classical logic and abandoning the computational interpretation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将此论证形式化需要我们关于有限集进行推理。在 Lean 中，对于任何类型 `α`，类型 `Finset α` 表示类型 `α` 的元素构成的有限集。关于有限集的计算机推理需要有一个在
    `α` 上测试等价的程序，这就是为什么下面的代码片段包含了假设 `[DecidableEq α]`。对于像 `ℕ`、`ℤ` 和 `ℚ` 这样的具体数据类型，这个假设会自动满足。当推理实数时，可以使用经典逻辑并放弃计算解释来满足这个假设。
- en: We use the command `open Finset` to avail ourselves of shorter names for the
    relevant theorems. Unlike the case with sets, most equivalences involving finsets
    do not hold definitionally, so they need to be expanded manually using equivalences
    like `Finset.subset_iff`, `Finset.mem_union`, `Finset.mem_inter`, and `Finset.mem_sdiff`.
    The `ext` tactic can still be used to show that two finite sets are equal by showing
    that every element of one is an element of the other.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用命令 `open Finset` 来使用相关定理的简短名称。与集合的情况不同，涉及有限集的大多数等价关系在定义上并不成立，因此需要手动使用等价关系如
    `Finset.subset_iff`、`Finset.mem_union`、`Finset.mem_inter` 和 `Finset.mem_sdiff`
    来展开。`ext` 策略仍然可以用来通过表明一个有限集的每个元素都是另一个集合的元素来证明两个有限集相等。
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We have used a new trick: the `tauto` tactic (and a strengthened version, `tauto!`,
    which uses classical logic) can be used to dispense with propositional tautologies.
    See if you can use these methods to prove the two examples below.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个新的技巧：`tauto` 策略（以及一个增强版本 `tauto!`，它使用经典逻辑）可以用来处理命题恒真。看看你是否能使用这些方法来证明下面的两个例子。
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The theorem `Finset.dvd_prod_of_mem` tells us that if an `n` is an element of
    a finite set `s`, then `n` divides `∏ i ∈ s, i`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 `Finset.dvd_prod_of_mem` 告诉我们，如果 `n` 是有限集 `s` 的一个元素，那么 `n` 可以整除 `∏ i ∈ s,
    i`。
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We also need to know that the converse holds in the case where `n` is prime
    and `s` is a set of primes. To show that, we need the following lemma, which you
    should be able to prove using the theorem `Nat.Prime.eq_one_or_self_of_dvd`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要知道，在 `n` 是素数且 `s` 是素数集合的情况下，逆命题也成立。为了证明这一点，我们需要以下引理，你应该能够使用定理 `Nat.Prime.eq_one_or_self_of_dvd`
    来证明它。
- en: '[PRE32]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can use this lemma to show that if a prime `p` divides a product of a finite
    set of primes, then it is equal to one of them. Mathlib provides a useful principle
    of induction on finite sets: to show that a property holds of an arbitrary finite
    set `s`, show that it holds of the empty set, and show that it is preserved when
    we add a single new element `a ∉ s`. The principle is known as `Finset.induction_on`.
    When we tell the induction tactic to use it, we can also specify the names `a`
    and `s`, the name for the assumption `a ∉ s` in the inductive step, and the name
    of the inductive hypothesis. The expression `Finset.insert a s` denotes the union
    of `s` with the singleton `a`. The identities `Finset.prod_empty` and `Finset.prod_insert`
    then provide the relevant rewrite rules for the product. In the proof below, the
    first `simp` applies `Finset.prod_empty`. Step through the beginning of the proof
    to see the induction unfold, and then finish it off.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个引理来证明，如果一个素数 `p` 整除有限个素数的乘积，那么它等于其中的一个。Mathlib 提供了一个关于有限集的有用归纳原理：为了证明一个性质对任意有限集
    `s` 成立，需要证明它对空集成立，并且在我们添加一个新元素 `a ∉ s` 时它仍然成立。这个原理被称为 `Finset.induction_on`。当我们告诉归纳策略使用它时，我们还可以指定
    `a` 和 `s` 的名称，以及在归纳步骤中 `a ∉ s` 的假设的名称，以及归纳假设的名称。表达式 `Finset.insert a s` 表示 `s`
    与单元素 `a` 的并集。然后，`Finset.prod_empty` 和 `Finset.prod_insert` 提供了与乘积相关的重写规则。在下面的证明中，第一个
    `simp` 应用了 `Finset.prod_empty`。逐步查看证明的开始，以查看归纳展开，然后完成它。
- en: '[PRE33]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We need one last property of finite sets. Given an element `s : Set α` and
    a predicate `P` on `α`, in [Chapter 4](C04_Sets_and_Functions.html#sets-and-functions)
    we wrote `{ x ∈ s | P x }` for the set of elements of `s` that satisfy `P`. Given
    `s : Finset α`, the analogous notion is written `s.filter P`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还需要有限集的一个最后性质。给定一个元素 `s : Set α` 和一个关于 `α` 的谓词 `P`，在 [第 4 章](C04_Sets_and_Functions.html#sets-and-functions)
    中，我们用 `{ x ∈ s | P x }` 表示满足 `P` 的 `s` 的元素集合。给定 `s : Finset α`，类似的概念写成 `s.filter
    P`。'
- en: '[PRE34]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We now prove an alternative formulation of the statement that there are infinitely
    many primes, namely, that given any `s : Finset ℕ`, there is a prime `p` that
    is not an element of `s`. Aiming for a contradiction, we assume that all the primes
    are in `s`, and then cut down to a set `s''` that contains all and only the primes.
    Taking the product of that set, adding one, and finding a prime factor of the
    result leads to the contradiction we are looking for. See if you can complete
    the sketch below. You can use `Finset.prod_pos` in the proof of the first `have`.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们证明一个关于无穷多个素数的陈述的另一种表述，即给定任何 `s : Finset ℕ`，存在一个素数 `p` 它不是 `s` 的元素。为了达到矛盾，我们假设所有素数都在
    `s` 中，然后缩减到一个只包含所有素数的集合 `s''`。取该集合的乘积，加一，并找到结果的素数因子，导致我们寻找的矛盾。看看你是否能完成下面的草图。你可以在第一个
    `have` 的证明中使用 `Finset.prod_pos`。'
- en: '[PRE35]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We have thus seen two ways of saying that there are infinitely many primes:
    saying that they are not bounded by any `n`, and saying that they are not contained
    in any finite set `s`. The two proofs below show that these formulations are equivalent.
    In the second, in order to form `s.filter Q`, we have to assume that there is
    a procedure for deciding whether or not `Q` holds. Lean knows that there is a
    procedure for `Nat.Prime`. In general, if we use classical logic by writing `open
    Classical`, we can dispense with the assumption.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了两种表达无穷多个素数的方法：说它们不受任何 `n` 的限制，以及说它们不包含在任何有限集 `s` 中。下面的两个证明表明这些表述是等价的。在第二个中，为了形成
    `s.filter Q`，我们必须假设存在一个判断 `Q` 是否成立的程序。Lean 知道 `Nat.Prime` 有一个程序。一般来说，如果我们通过编写
    `open Classical` 使用经典逻辑，我们可以省略这个假设。
- en: In Mathlib, `Finset.sup s f` denotes the supremum of the values of `f x` as
    `x` ranges over `s`, returning `0` in the case where `s` is empty and the codomain
    of `f` is `ℕ`. In the first proof, we use `s.sup id`, where `id` is the identity
    function, to refer to the maximum value in `s`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mathlib 中，`Finset.sup s f` 表示 `f x` 在 `x` 在 `s` 上取值时的上确界，当 `s` 为空且 `f` 的陪域为
    `ℕ` 时返回 `0`。在第一个证明中，我们使用 `s.sup id`，其中 `id` 是恒等函数，来引用 `s` 中的最大值。
- en: '[PRE36]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: A small variation on our second proof that there are infinitely many primes
    shows that there are infinitely many primes congruent to 3 modulo 4. The argument
    goes as follows. First, notice that if the product of two numbers \(m\) and \(n\)
    is equal to 3 modulo 4, then one of the two numbers is congruent to 3 modulo 4.
    After all, both have to be odd, and if they are both congruent to 1 modulo 4,
    so is their product. We can use this observation to show that if some number greater
    than 2 is congruent to 3 modulo 4, then that number has a prime divisor that is
    also congruent to 3 modulo 4.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第二个证明中关于存在无限多个质数的微小变化表明，存在无限多个与4同余3的质数。论证如下。首先，注意如果两个数\(m\)和\(n\)的乘积等于4模3，那么这两个数中至少有一个与4同余3。毕竟，它们都必须是奇数，如果它们都等于4模1，那么它们的乘积也是。我们可以利用这个观察结果来证明如果某个大于2的数与4同余3，那么这个数有一个与4同余3的质数因子。
- en: Now suppose there are only finitely many prime numbers congruent to 3 modulo
    4, say, \(p_1, \ldots, p_k\). Without loss of generality, we can assume that \(p_1
    = 3\). Consider the product \(4 \prod_{i = 2}^k p_i + 3\). It is easy to see that
    this is congruent to 3 modulo 4, so it has a prime factor \(p\) congruent to 3
    modulo 4. It can’t be the case that \(p = 3\); since \(p\) divides \(4 \prod_{i
    = 2}^k p_i + 3\), if \(p\) were equal to 3 then it would also divide \(\prod_{i
    = 2}^k p_i\), which implies that \(p\) is equal to one of the \(p_i\) for \(i
    = 2, \ldots, k\); and we have excluded 3 from this list. So \(p\) has to be one
    of the other elements \(p_i\). But in that case, \(p\) divides \(4 \prod_{i =
    2}^k p_i\) and hence 3, which contradicts the fact that it is not 3.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设只有有限多个与4同余3的质数，比如说，\(p_1, \ldots, p_k\)。不失一般性，我们可以假设\(p_1 = 3\)。考虑乘积\(4
    \prod_{i = 2}^k p_i + 3\)。很容易看出这个数与4同余3，所以它有一个与4同余3的质数因子\(p\)。不可能\(p = 3\)；因为\(p\)能整除\(4
    \prod_{i = 2}^k p_i + 3\)，如果\(p\)等于3，那么它也会整除\(\prod_{i = 2}^k p_i\)，这意味着\(p\)等于\(p_i\)中的一个，对于\(i
    = 2, \ldots, k\)；但我们已经排除了3。所以\(p\)必须是其他元素\(p_i\)中的一个。但在那种情况下，\(p\)能整除\(4 \prod_{i
    = 2}^k p_i\)和3，这与它不是3的事实相矛盾。
- en: In Lean, the notation `n % m`, read “`n` modulo `m`,” denotes the remainder
    of the division of `n` by `m`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lean中，表示`n % m`（读作“`n`模`m`”），表示`n`除以`m`的余数。
- en: '[PRE37]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can then render the statement “`n` is congruent to 3 modulo 4” as `n % 4
    = 3`. The following example and theorems sum up the facts about this function
    that we will need to use below. The first named theorem is another illustration
    of reasoning by a small number of cases. In the second named theorem, remember
    that the semicolon means that the subsequent tactic block is applied to all the
    goals created by the preceding tactic.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将陈述“`n`与4同余3”表示为`n % 4 = 3`。以下示例和定理总结了我们将需要使用的事实。第一个命名的定理是通过对少数几个情况推理的另一个示例。在第二个命名的定理中，记住分号意味着后续的策略块应用于由前面的策略创建的所有目标。
- en: '[PRE38]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We will also need the following fact, which says that if `m` is a nontrivial
    divisor of `n`, then so is `n / m`. See if you can complete the proof using `Nat.div_dvd_of_dvd`
    and `Nat.div_lt_self`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要以下事实，即如果`m`是`n`的非平凡因子，那么`n / m`也是。尝试使用`Nat.div_dvd_of_dvd`和`Nat.div_lt_self`来完成证明。
- en: '[PRE39]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now put all the pieces together to prove that any number congruent to 3 modulo
    4 has a prime divisor with that same property.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将所有这些部分组合起来，以证明任何与4同余3的数都有一个具有相同性质的质数因子。
- en: '[PRE40]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We are in the home stretch. Given a set `s` of prime numbers, we need to talk
    about the result of removing 3 from that set, if it is present. The function `Finset.erase`
    handles that.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经接近终点。给定一个由质数组成的集合`s`，如果集合中存在3，我们需要讨论从该集合中移除3的结果。函数`Finset.erase`可以处理这种情况。
- en: '[PRE41]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We are now ready to prove that there are infinitely many primes congruent to
    3 modulo 4. Fill in the missing parts below. Our solution uses `Nat.dvd_add_iff_left`
    and `Nat.dvd_sub'` along the way.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好证明存在无限多个与4同余3的质数。在下面填入缺失的部分。我们的解决方案在过程中使用了`Nat.dvd_add_iff_left`和`Nat.dvd_sub'`。
- en: '[PRE42]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you managed to complete the proof, congratulations! This has been a serious
    feat of formalization.  ## 5.4\. More Induction[](#more-induction "Link to this
    heading")'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你设法完成了证明，恭喜你！这已经是一项正式化的重大成就。## 5.4. 更多归纳[](#more-induction "链接到本标题")
- en: In [Section 5.2](#section-induction-and-recursion), we saw how to define the
    factorial function by recursion on the natural numbers.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5.2节](#section-induction-and-recursion)中，我们看到了如何通过自然数的递归定义阶乘函数。
- en: '[PRE43]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We also saw how to prove theorems using the `induction'` tactic.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何使用`induction'`策略证明定理。
- en: '[PRE44]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `induction` tactic (without the prime tick mark) allows for more structured
    syntax.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`induction` 策略（不带撇号）允许更结构化的语法。'
- en: '[PRE45]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As usual, you can hover over the `induction` keyword to read the documentation.
    The names of the cases, `zero` and `succ`, are taken from the definition of the
    type ℕ. Notice that the `succ` case allows you to choose whatever names you want
    for the induction variable and the inductive hypothesis, here `n` and `ih`. You
    can even prove a theorem with the same notation used to define a recursive function.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，你可以悬停在 `induction` 关键字上以阅读文档。案例的名称 `zero` 和 `succ` 来自于类型 ℕ 的定义。注意，`succ`
    案例允许你为归纳变量和归纳假设选择任何你想要的名称，这里为 `n` 和 `ih`。你甚至可以使用定义递归函数的相同符号来证明定理。
- en: '[PRE46]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Notice also the absence of the `:=`, the `∀ n` after the colon, the `by` keyword
    in each case, and the inductive appeal to `fac_pos' n`. It is as though the theorem
    is a recursive function of `n` and in the inductive step we make a recursive call.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意也缺少了 `:=`，冒号后面的 `∀ n`，每个案例中的 `by` 关键字，以及归纳调用 `fac_pos' n`。这就像定理是 `n` 的递归函数，在归纳步骤中我们进行递归调用。
- en: This style of definition is remarkably flexible. Lean’s designers have built
    in elaborate means of defining recursive functions, and these extend to doing
    proofs by induction. For example, we can define the Fibonacci function with multiple
    base cases.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这种定义风格非常灵活。Lean 的设计者内置了定义递归函数的复杂手段，这些手段也扩展到了归纳证明。例如，我们可以用多个基本情况定义斐波那契函数。
- en: '[PRE47]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `@[simp]` annotation means that the simplifier will use the defining equations.
    You can also apply them by writing `rw [fib]`. Below it will be helpful to give
    a name to the `n + 2` case.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`@[simp]` 注释表示简化器将使用定义方程。你也可以通过编写 `rw [fib]` 来应用它们。下面将有助于为 `n + 2` 情况命名。'
- en: '[PRE48]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Using Lean’s notation for recursive functions, you can carry out proofs by induction
    on the natural numbers that mirror the recursive definition of `fib`. The following
    example provides an explicit formula for the nth Fibonacci number in terms of
    the golden mean, `φ`, and its conjugate, `φ'`. We have to tell Lean that we don’t
    expect our definitions to generate code because the arithmetic operations on the
    real numbers are not computable.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Lean 的递归函数表示法，你可以通过自然数上的归纳来执行与 `fib` 的递归定义相对应的证明。以下示例提供了第 n 个斐波那契数的显式公式，该公式以黄金分割数
    `φ` 和其共轭 `φ'` 为基础。我们必须告诉 Lean，我们不期望我们的定义生成代码，因为实数上的算术运算是不可计算的。
- en: '[PRE49]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Induction proofs involving the Fibonacci function do not have to be of that
    form. Below we reproduce the `Mathlib` proof that consecutive Fibonacci numbers
    are coprime.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及斐波那契函数的归纳证明不必是那种形式。以下我们重现了 `Mathlib` 证明连续的斐波那契数是互质的。
- en: '[PRE50]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Using Lean’s computational interpretation, we can evaluate the Fibonacci numbers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Lean 的计算解释，我们可以评估斐波那契数。
- en: '[PRE51]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The straightforward implementation of `fib` is computationally inefficient.
    In fact, it runs in time exponential in its argument. (You should think about
    why.) In Lean, we can implement the following tail-recursive version, whose running
    time is linear in `n`, and prove that it computes the same function.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`fib` 的直接实现计算效率低下。实际上，它的运行时间与其参数呈指数关系。（你应该思考一下为什么。）在 Lean 中，我们可以实现以下尾递归版本，其运行时间与
    `n` 线性相关，并证明它计算的是相同的函数。'
- en: '[PRE52]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Notice the `generalizing` keyword in the proof of `fib'.aux_eq`. It serves to
    insert a `∀ m` in front of the inductive hypothesis, so that in the induction
    step, `m` can take a different value. You can step through the proof and check
    that in this case, the quantifier needs to be instantiated to `m + 1` in the inductive
    step.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `fib'.aux_eq` 证明中的 `generalizing` 关键字。它用于在归纳假设前插入 `∀ m`，这样在归纳步骤中，`m` 可以取不同的值。你可以逐步检查证明，并确认在这种情况下，量词需要在归纳步骤中实例化为
    `m + 1`。
- en: Notice also the use of `erw` (for “extended rewrite”) instead of `rw`. This
    is used because to rewrite the goal `fib'.aux_eq`, `fib 0` and `fib 1` have to
    be reduced to `0` and `1`, respectively. The tactic `erw` is more aggressive than
    `rw` in unfolding definitions to match parameters. This isn’t always a good idea;
    it can waste a lot of time in some cases, so use `erw` sparingly.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意也使用了 `erw`（表示“扩展重写”）而不是 `rw`。这是因为为了重写目标 `fib'.aux_eq`，`fib 0` 和 `fib 1` 必须分别简化为
    `0` 和 `1`。`erw` 策略在展开定义以匹配参数方面比 `rw` 更激进。这并不总是好主意；在某些情况下，它可能会浪费很多时间，所以请谨慎使用 `erw`。
- en: Here is another example of the `generalizing` keyword in use, in the proof of
    another identity that is found in `Mathlib`. An informal proof of the identity
    can be found [here](https://proofwiki.org/wiki/Fibonacci_Number_in_terms_of_Smaller_Fibonacci_Numbers).
    We provide two variants of the formal proof.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`generalizing`关键字在证明`Mathlib`中发现的另一个恒等式时的另一个例子。该恒等式的不正式证明可以在[这里](https://proofwiki.org/wiki/Fibonacci_Number_in_terms_of_Smaller_Fibonacci_Numbers)找到。我们提供了正式证明的两个变体。
- en: '[PRE53]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As an exercise, use `fib_add` to prove the following.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，使用`fib_add`来证明以下内容。
- en: '[PRE54]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Lean’s mechanisms for defining recursive functions are flexible enough to allow
    arbitrary recursive calls, as long the complexity of the arguments decrease according
    to some well-founded measure. In the next example, we show that every natural
    number `n ≠ 1` has a prime divisor, using the fact that if `n` is nonzero and
    not prime, it has a smaller divisor. (You can check that Mathlib has a theorem
    of the same name in the `Nat` namespace, though it has a different proof than
    the one we give here.)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Lean定义递归函数的机制足够灵活，允许任意递归调用，只要参数的复杂性根据某个良基度量递减。在下一个例子中，我们展示了每个自然数`n ≠ 1`都有一个素数因子，利用了如果`n`非零且不是素数，它有一个较小的因子的这一事实。（你可以检查Mathlib在`Nat`命名空间中是否有同名定理，尽管它的证明与这里给出的不同。）
- en: '[PRE55]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The line `rw [ne_one_iff_exists_prime_dvd] at this` is like a magic trick:
    we are using the very theorem we are proving in its own proof. What makes it work
    is that the inductive call is instantiated at `m`, the current case is `n + 2`,
    and the context has `m < n + 2`. Lean can find the hypothesis and use it to show
    that the induction is well-founded. Lean is pretty good at figuring out what is
    decreasing; in this case, the choice of `n` in the statement of the theorem and
    the less-than relation is obvious. In more complicated cases, Lean provides mechanisms
    to provide this information explicitly. See the section on [well-founded recursion](https://lean-lang.org/doc/reference/latest//Definitions/Recursive-Definitions/#well-founded-recursion)
    in the Lean Reference Manual.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码`rw [ne_one_iff_exists_prime_dvd] at this`就像一个魔术：我们在自己的证明中使用了我们正在证明的定理。使其工作的是归纳调用在`m`处实例化，当前情况是`n
    + 2`，并且上下文有`m < n + 2`。Lean能够找到假设并使用它来证明归纳是良基的。Lean在找出什么是递减的方面相当出色；在这种情况下，定理陈述中的`n`的选择和小于关系是显而易见的。在更复杂的情况下，Lean提供了提供此信息的机制。请参阅Lean参考手册中关于[良基递归](https://lean-lang.org/doc/reference/latest//Definitions/Recursive-Definitions/#well-founded-recursion)的部分。
- en: Sometimes, in a proof, you need to split on cases depending on whether a natural
    number `n` is zero or a successor, without requiring an inductive hypothesis in
    the successor case. For that, you can use the `cases` and `rcases` tactics.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在证明中，你需要根据自然数`n`是零还是后继来分情况讨论，而不需要在后继情况下要求归纳假设。为此，你可以使用`cases`和`rcases`策略。
- en: '[PRE56]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This is a useful trick. Often you have a theorem about a natural number `n`
    for which the zero case is easy. If you case on `n` and take care of the zero
    case quickly, you are left with the original goal with `n` replaced by `n + 1`.
    [Previous](C04_Sets_and_Functions.html "4\. Sets and Functions") [Next](C06_Discrete_Mathematics.html
    "6\. Discrete Mathematics")
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的技巧。通常，你有一个关于自然数`n`的定理，其中零的情况很容易处理。如果你对`n`进行情况分析并快速处理零的情况，你将剩下原始目标，只是将`n`替换为`n
    + 1`。[上一节](C04_Sets_and_Functions.html "4. 集合和函数") [下一节](C06_Discrete_Mathematics.html
    "6. 离散数学")
- en: '* * *'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: © Copyright 2020-2025, Jeremy Avigad, Patrick Massot. Text licensed under CC
    BY 4.0.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: © 版权所有 2020-2025，Jeremy Avigad，Patrick Massot。文本许可协议为CC BY 4.0。
- en: Built with [Sphinx](https://www.sphinx-doc.org/) using a [theme](https://github.com/readthedocs/sphinx_rtd_theme)
    provided by [Read the Docs](https://readthedocs.org). In this chapter, we show
    you how to formalize some elementary results in number theory. As we deal with
    more substantive mathematical content, the proofs will get longer and more involved,
    building on the skills you have already mastered.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[Sphinx](https://www.sphinx-doc.org/)和[Read the Docs](https://readthedocs.org)提供的[主题](https://github.com/readthedocs/sphinx_rtd_theme)构建。在本章中，我们向您展示如何将数论中的某些基本结果形式化。随着我们处理更实质性的数学内容，证明将变得更长、更复杂，建立在您已经掌握的技能之上。
- en: '## 5.1\. Irrational Roots[](#irrational-roots "Link to this heading")'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '## 5.1. 无理根[](#irrational-roots "链接到这个标题")'
- en: Let’s start with a fact known to the ancient Greeks, namely, that the square
    root of 2 is irrational. If we suppose otherwise, we can write \(\sqrt{2} = a
    / b\) as a fraction in lowest terms. Squaring both sides yields \(a^2 = 2 b^2\),
    which implies that \(a\) is even. If we write \(a = 2c\), then we get \(4c^2 =
    2 b^2\) and hence \(b^2 = 2 c^2\). This implies that \(b\) is also even, contradicting
    the fact that we have assumed that \(a / b\) has been reduced to lowest terms.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从古希腊人已知的一个事实开始，即2的平方根是无理数。如果我们假设相反的情况，我们可以将\(\sqrt{2} = a / b\)写成最简分数。平方两边得到\(a^2
    = 2 b^2\)，这意味着`a`是偶数。如果我们写`a = 2c`，那么我们得到\(4c^2 = 2 b^2\)，从而\(b^2 = 2 c^2\)。这表明`b`也是偶数，这与我们假设的`a
    / b`已经被化简到最简形式的事实相矛盾。
- en: Saying that \(a / b\) is a fraction in lowest terms means that \(a\) and \(b\)
    do not have any factors in common, which is to say, they are *coprime*. Mathlib
    defines the predicate `Nat.Coprime m n` to be `Nat.gcd m n = 1`. Using Lean’s
    anonymous projection notation, if `s` and `t` are expressions of type `Nat`, we
    can write `s.Coprime t` instead of `Nat.Coprime s t`, and similarly for `Nat.gcd`.
    As usual, Lean will often unfold the definition of `Nat.Coprime` automatically
    when necessary, but we can also do it manually by rewriting or simplifying with
    the identifier `Nat.Coprime`. The `norm_num` tactic is smart enough to compute
    concrete values.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 说`a / b`是最简分数意味着`a`和`b`没有公共因子，也就是说，它们是*互质*。Mathlib定义谓词`Nat.Coprime m n`为`Nat.gcd
    m n = 1`。使用Lean的匿名投影符号，如果`s`和`t`是类型为`Nat`的表达式，我们可以写`s.Coprime t`而不是`Nat.Coprime
    s t`，对于`Nat.gcd`也是如此。通常，当需要时，Lean会自动展开`Nat.Coprime`的定义，但我们可以通过重写或使用标识符`Nat.Coprime`进行简化来手动完成。`norm_num`策略足够智能，可以计算具体值。
- en: '[PRE57]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We have already encountered the `gcd` function in [Section 2.4](C02_Basics.html#more-on-order-and-divisibility).
    There is also a version of `gcd` for the integers; we will return to a discussion
    of the relationship between different number systems below. There are even a generic
    `gcd` function and generic notions of `Prime` and `Coprime` that make sense in
    general classes of algebraic structures. We will come to understand how Lean manages
    this generality in the next chapter. In the meanwhile, in this section, we will
    restrict attention to the natural numbers.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第2.4节](C02_Basics.html#more-on-order-and-divisibility)中遇到了`gcd`函数。对于整数也有`gcd`的版本；我们将在下面讨论不同数系之间的关系。甚至还有一个通用的`gcd`函数和通用的`Prime`和`Coprime`概念，这些在一般的代数结构中是有意义的。我们将在下一章了解Lean如何管理这种通用性。同时，在本节中，我们将关注自然数。
- en: We also need the notion of a prime number, `Nat.Prime`. The theorem `Nat.prime_def_lt`
    provides one familiar characterization, and `Nat.Prime.eq_one_or_self_of_dvd`
    provides another.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个素数的概念，即`Nat.Prime`。定理`Nat.prime_def_lt`提供了一个熟悉的特征描述，而`Nat.Prime.eq_one_or_self_of_dvd`提供了另一个。
- en: '[PRE58]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the natural numbers, a prime number has the property that it cannot be written
    as a product of nontrivial factors. In a broader mathematical context, an element
    of a ring that has this property is said to be *irreducible*. An element of a
    ring is said to be *prime* if whenever it divides a product, it divides one of
    the factors. It is an important property of the natural numbers that in that setting
    the two notions coincide, giving rise to the theorem `Nat.Prime.dvd_mul`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在自然数中，素数有一个属性，即它不能写成非平凡因子的乘积。在更广泛的数学背景下，具有这种属性的环元素被称为*不可约*。如果一个环元素在乘积中除以，它就除以其中一个因子，那么这个环元素被称为*素数*。自然数的一个重要属性是，在这种设置中，这两个概念是一致的，从而产生了定理`Nat.Prime.dvd_mul`。
- en: 'We can use this fact to establish a key property in the argument above: if
    the square of a number is even, then that number is even as well. Mathlib defines
    the predicate `Even` in `Algebra.Group.Even`, but for reasons that will become
    clear below, we will simply use `2 ∣ m` to express that `m` is even.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个事实来建立上述论证中的一个关键属性：如果一个数的平方是偶数，那么这个数也是偶数。Mathlib在`Algebra.Group.Even`中定义谓词`Even`，但如下文所述，我们将简单地使用`2
    ∣ m`来表示`m`是偶数。
- en: '[PRE59]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As we proceed, you will need to become proficient at finding the facts you need.
    Remember that if you can guess the prefix of the name and you have imported the
    relevant library, you can use tab completion (sometimes with `ctrl-tab`) to find
    what you are looking for. You can use `ctrl-click` on any identifier to jump to
    the file where it is defined, which enables you to browse definitions and theorems
    nearby. You can also use the search engine on the [Lean community web pages](https://leanprover-community.github.io/),
    and if all else fails, don’t hesitate to ask on [Zulip](https://leanprover.zulipchat.com/).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进，你需要熟练地找到你需要的事实。记住，如果你能猜出名称的前缀并且你已经导入了相关的库，你可以使用制表符补全（有时需要 `ctrl-tab`）来找到你想要的内容。你可以在任何标识符上使用
    `ctrl-click` 跳转到其定义的文件，这使你能够浏览附近的定义和定理。你还可以使用 [Lean 社区网页](https://leanprover-community.github.io/)
    上的搜索引擎，如果所有其他方法都失败了，不要犹豫在 [Zulip](https://leanprover.zulipchat.com/) 上提问。
- en: '[PRE60]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The heart of our proof of the irrationality of the square root of two is contained
    in the following theorem. See if you can fill out the proof sketch, using `even_of_even_sqr`
    and the theorem `Nat.dvd_gcd`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们证明二平方根无理性的核心包含在以下定理中。看看你是否能填充证明草图，使用 `even_of_even_sqr` 和定理 `Nat.dvd_gcd`。
- en: '[PRE61]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In fact, with very few changes, we can replace `2` by an arbitrary prime. Give
    it a try in the next example. At the end of the proof, you’ll need to derive a
    contradiction from `p ∣ 1`. You can use `Nat.Prime.two_le`, which says that any
    prime number is greater than or equal to two, and `Nat.le_of_dvd`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，只需做很少的修改，我们就可以用任意素数替换 `2`。在下一个例子中尝试一下。在证明的末尾，你需要从 `p ∣ 1` 推导出矛盾。你可以使用 `Nat.Prime.two_le`，它表明任何素数都大于或等于二，以及
    `Nat.le_of_dvd`。
- en: '[PRE62]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Let us consider another approach. Here is a quick proof that if \(p\) is prime,
    then \(m^2 \ne p n^2\): if we assume \(m^2 = p n^2\) and consider the factorization
    of \(m\) and \(n\) into primes, then \(p\) occurs an even number of times on the
    left side of the equation and an odd number of times on the right, a contradiction.
    Note that this argument requires that \(n\) and hence \(m\) are not equal to zero.
    The formalization below confirms that this assumption is sufficient.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一种方法。以下是一个快速证明：如果 `p` 是素数，那么 `m^2 ≠ p n^2`：如果我们假设 `m^2 = p n^2` 并考虑 `m`
    和 `n` 的素数分解，那么 `p` 在等式的左边出现偶数次，在右边出现奇数次，这是矛盾的。请注意，这个论证要求 `n` 以及因此 `m` 不为零。下面的形式化确认了这个假设是充分的。
- en: The unique factorization theorem says that any natural number other than zero
    can be written as the product of primes in a unique way. Mathlib contains a formal
    version of this, expressed in terms of a function `Nat.primeFactorsList`, which
    returns the list of prime factors of a number in nondecreasing order. The library
    proves that all the elements of `Nat.primeFactorsList n` are prime, that any `n`
    greater than zero is equal to the product of its factors, and that if `n` is equal
    to the product of another list of prime numbers, then that list is a permutation
    of `Nat.primeFactorsList n`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一分解定理指出，除了零以外的任何自然数都可以以唯一的方式写成素数的乘积。Mathlib 包含了这个定理的正式版本，它通过一个函数 `Nat.primeFactorsList`
    来表达，该函数返回一个数素因子的非递减顺序列表。该库证明了 `Nat.primeFactorsList n` 的所有元素都是素数，任何大于零的 `n` 都等于其因子的乘积，并且如果
    `n` 等于另一个素数列表的乘积，那么那个列表是 `Nat.primeFactorsList n` 的一个排列。
- en: '[PRE63]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You can browse these theorems and others nearby, even though we have not talked
    about list membership, products, or permutations yet. We won’t need any of that
    for the task at hand. We will instead use the fact that Mathlib has a function
    `Nat.factorization`, that represents the same data as a function. Specifically,
    `Nat.factorization n p`, which we can also write `n.factorization p`, returns
    the multiplicity of `p` in the prime factorization of `n`. We will use the following
    three facts.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们还没有讨论列表成员、乘积或排列，但你仍然可以浏览这些定理以及其他附近的定理。对于当前的任务，我们不需要这些内容。相反，我们将使用 Mathlib
    有一个函数 `Nat.factorization` 的这一事实，该函数以函数的形式表示相同的数据。具体来说，`Nat.factorization n p`，我们也可以写作
    `n.factorization p`，返回 `p` 在 `n` 的素因子分解中的次数。我们将使用以下三个事实。
- en: '[PRE64]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In fact, `n.factorization` is defined in Lean as a function of finite support,
    which explains the strange notation you will see as you step through the proofs
    above. Don’t worry about this now. For our purposes here, we can use the three
    theorems above as a black box.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`n.factorization` 在 Lean 中定义为有限支持函数，这解释了你将在上述证明中看到的奇怪符号。现在不用担心这个。对于我们的目的，我们可以将上述三个定理作为一个黑盒使用。
- en: The next example shows that the simplifier is smart enough to replace `n^2 ≠
    0` by `n ≠ 0`. The tactic `simpa` just calls `simp` followed by `assumption`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子表明，简化器足够聪明，可以将 `n^2 ≠ 0` 替换为 `n ≠ 0`。`simpa` 策略只是调用 `simp` 后跟 `assumption`。
- en: See if you can use the identities above to fill in the missing parts of the
    proof.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能使用上面的恒等式来填补证明中的缺失部分。
- en: '[PRE65]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: A nice thing about this proof is that it also generalizes. There is nothing
    special about `2`; with small changes, the proof shows that whenever we write
    `m^k = r * n^k`, the multiplicity of any prime `p` in `r` has to be a multiple
    of `k`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个证明的另一个优点是它也具有普遍性。`2` 没有什么特别之处；经过一些小的修改，这个证明表明，每当我们将 `m^k = r * n^k` 写出来时，任何素数
    `p` 在 `r` 中的次数必须是 `k` 的倍数。
- en: 'To use `Nat.count_factors_mul_of_pos` with `r * n^k`, we need to know that
    `r` is positive. But when `r` is zero, the theorem below is trivial, and easily
    proved by the simplifier. So the proof is carried out in cases. The line `rcases
    r with _ | r` replaces the goal with two versions: one in which `r` is replaced
    by `0`, and the other in which `r` is replaces by `r + 1`. In the second case,
    we can use the theorem `r.succ_ne_zero`, which establishes `r + 1 ≠ 0` (`succ`
    stands for successor).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `Nat.count_factors_mul_of_pos` 与 `r * n^k`，我们需要知道 `r` 是正数。但当 `r` 为零时，下面的定理是显而易见的，并且可以通过简化器轻松证明。因此，证明是分情况进行的。行
    `rcases r with _ | r` 将目标替换为两个版本：一个是将 `r` 替换为 `0` 的版本，另一个是将 `r` 替换为 `r + 1` 的版本。在第二种情况下，我们可以使用定理
    `r.succ_ne_zero`，它建立了 `r + 1 ≠ 0`（`succ` 表示后继）。
- en: 'Notice also that the line that begins `have : npow_nz` provides a short proof-term
    proof of `n^k ≠ 0`. To understand how it works, try replacing it with a tactic
    proof, and then think about how the tactics describe the proof term.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，以 `have : npow_nz` 开头的行提供了一个简短的证明项证明 `n^k ≠ 0`。要理解它是如何工作的，试着用策略证明来替换它，然后思考策略是如何描述证明项的。'
- en: See if you can fill in the missing parts of the proof below. At the very end,
    you can use `Nat.dvd_sub'` and `Nat.dvd_mul_right` to finish it off.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能填补下面证明中的缺失部分。在最后，你可以使用 `Nat.dvd_sub'` 和 `Nat.dvd_mul_right` 来完成它。
- en: Note that this example does not assume that `p` is prime, but the conclusion
    is trivial when `p` is not prime since `r.factorization p` is then zero by definition,
    and the proof works in all cases anyway.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个例子并没有假设 `p` 是素数，但当 `p` 不是素数时，结论是显而易见的，因为根据定义，`r.factorization p` 是零，而且证明在所有情况下都适用。
- en: '[PRE66]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: There are a number of ways in which we might want to improve on these results.
    To start with, a proof that the square root of two is irrational should say something
    about the square root of two, which can be understood as an element of the real
    or complex numbers. And stating that it is irrational should say something about
    the rational numbers, namely, that no rational number is equal to it. Moreover,
    we should extend the theorems in this section to the integers. Although it is
    mathematically obvious that if we could write the square root of two as a quotient
    of two integers then we could write it as a quotient of two natural numbers, proving
    this formally requires some effort.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望以多种方式改进这些结果。首先，一个证明说平方根是无理数应该对平方根说些什么，这可以理解为实数或复数中的一个元素。并且说它是无理数应该对有理数说些什么，即没有有理数等于它。此外，我们还应该将本节中的定理扩展到整数。虽然从数学上明显，如果我们能将平方根写成两个整数的商，那么我们也能将其写成两个自然数的商，但正式证明这一点需要一些努力。
- en: 'In Mathlib, the natural numbers, the integers, the rationals, the reals, and
    the complex numbers are represented by separate data types. Restricting attention
    to the separate domains is often helpful: we will see that it is easy to do induction
    on the natural numbers, and it is easiest to reason about divisibility of integers
    when the real numbers are not part of the picture. But having to mediate between
    the different domains is a headache, one we will have to contend with. We will
    return to this issue later in this chapter.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mathlib 中，自然数、整数、有理数、实数和复数由不同的数据类型表示。将注意力限制在单独的域中通常是有帮助的：我们将看到对自然数进行归纳是很容易的，而且当实数不在图中时，对整数除法的推理是最容易的。但需要在不同的域之间进行调解，这是一个头疼的问题，我们将在本章的后面回到这个问题。
- en: We should also expect to be able to strengthen the conclusion of the last theorem
    to say that the number `r` is a `k`-th power, since its `k`-th root is just the
    product of each prime dividing `r` raised to its multiplicity in `r` divided by
    `k`. To be able to do that we will need better means for reasoning about products
    and sums over a finite set, which is also a topic we will return to.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也应该期待能够加强最后一个定理的结论，使其表明数字 `r` 是一个 `k`-次幂，因为它的 `k`-次方根仅仅是每个除 `r` 的质数乘以其在 `r`
    中的重数除以 `k` 的乘积。为了做到这一点，我们需要更好的推理手段来处理有限集合上的乘积和求和，这也是我们将再次讨论的话题。
- en: 'In fact, the results in this section are all established in much greater generality
    in Mathlib, in `Data.Real.Irrational`. The notion of `multiplicity` is defined
    for an arbitrary commutative monoid, and that it takes values in the extended
    natural numbers `enat`, which adds the value infinity to the natural numbers.
    In the next chapter, we will begin to develop the means to appreciate the way
    that Lean supports this sort of generality.  ## 5.2\. Induction and Recursion[](#induction-and-recursion
    "Link to this heading")'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，本节中的结果在 Mathlib 中以更大的普遍性得到确立，在 `Data.Real.Irrational` 中。`multiplicity` 的概念被定义为任意交换幺半群，并且它取值于扩展的自然数
    `enat`，这为自然数添加了无穷大的值。在下一章中，我们将开始开发欣赏 Lean 支持这种普遍性的方法。## 5.2. 归纳与递归[](#induction-and-recursion
    "链接到本标题")
- en: The set of natural numbers \(\mathbb{N} = \{ 0, 1, 2, \ldots \}\) is not only
    fundamentally important in its own right, but also a plays a central role in the
    construction of new mathematical objects. Lean’s foundation allows us to declare
    *inductive types*, which are types generated inductively by a given list of *constructors*.
    In Lean, the natural numbers are declared as follows.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 自然数集合 \(\mathbb{N} = \{ 0, 1, 2, \ldots \}\) 不仅在其自身的基础上具有根本的重要性，而且在构建新的数学对象中也起着核心作用。Lean
    的基础允许我们声明 *归纳类型*，这些类型是通过给定的构造函数列表归纳生成的。在 Lean 中，自然数被声明如下。
- en: '[PRE67]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You can find this in the library by writing `#check Nat` and then using `ctrl-click`
    on the identifier `Nat`. The command specifies that `Nat` is the datatype generated
    freely and inductively by the two constructors `zero : Nat` and `succ : Nat →
    Nat`. Of course, the library introduces notation `ℕ` and `0` for `nat` and `zero`
    respectively. (Numerals are translated to binary representations, but we don’t
    have to worry about the details of that now.)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以通过编写 `#check Nat` 并在标识符 `Nat` 上使用 `ctrl-click` 来在库中找到它。该命令指定 `Nat` 是由两个构造函数
    `zero : Nat` 和 `succ : Nat → Nat` 自由且归纳生成的数据类型。当然，库引入了 `ℕ` 和 `0` 的符号分别代表 `nat`
    和 `zero`。 (数字被转换为二进制表示，但我们现在不必担心这个细节。)'
- en: What “freely” means for the working mathematician is that the type `Nat` has
    an element `zero` and an injective successor function `succ` whose image does
    not include `zero`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于工作的数学家来说，“自由”一词的含义是类型 `Nat` 有一个元素 `zero` 和一个注入的后续函数 `succ`，其像不包括 `zero`。
- en: '[PRE68]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: What the word “inductively” means for the working mathematician is that the
    natural numbers comes with a principle of proof by induction and a principle of
    definition by recursion. This section will show you how to use these.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于工作的数学家来说，“归纳”一词的含义是自然数伴随着归纳证明的原则和递归定义的原则。本节将向您展示如何使用这些。
- en: Here is an example of a recursive definition of the factorial function.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是阶乘函数的递归定义的一个例子。
- en: '[PRE69]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The syntax takes some getting used to. Notice that there is no `:=` on the first
    line. The next two lines provide the base case and inductive step for a recursive
    definition. These equations hold definitionally, but they can also be used manually
    by giving the name `fac` to `simp` or `rw`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 语法需要一些时间来适应。注意，第一行没有 `:=`。接下来的两行提供了递归定义的基础情况和归纳步骤。这些等式在定义上是成立的，但也可以通过将 `fac`
    命名为 `simp` 或 `rw` 来手动使用。
- en: '[PRE70]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The factorial function is actually already defined in Mathlib as `Nat.factorial`.
    Once again, you can jump to it by typing `#check Nat.factorial` and using `ctrl-click.`
    For illustrative purposes, we will continue using `fac` in the examples. The annotation
    `@[simp]` before the definition of `Nat.factorial` specifies that the defining
    equation should be added to the database of identities that the simplifier uses
    by default.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，阶乘函数已经在 Mathlib 中定义为 `Nat.factorial`。再次，您可以通过键入 `#check Nat.factorial` 并使用
    `ctrl-click` 来跳转到它。为了说明目的，我们将在示例中继续使用 `fac`。在 `Nat.factorial` 的定义之前标注 `@[simp]`
    指定定义方程应该被添加到简化器默认使用的恒等式数据库中。
- en: 'The principle of induction says that we can prove a general statement about
    the natural numbers by proving that the statement holds of 0 and that whenever
    it holds of a natural number \(n\), it also holds of \(n + 1\). The line `induction''
    n with n ih` in the proof below therefore results in two goals: in the first we
    need to prove `0 < fac 0`, and in the second we have the added assumption `ih
    : 0 < fac n` and a required to prove `0 < fac (n + 1)`. The phrase `with n ih`
    serves to name the variable and the assumption for the inductive hypothesis, and
    you can choose whatever names you want for them.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '归纳原理表明，我们可以通过证明该命题对 0 成立，并且每当它对自然数 \(n\) 成立时，它也对 \(n + 1\) 成立，来证明关于自然数的一般命题。以下证明中的
    `induction'' n with n ih` 行因此产生两个目标：在第一个目标中，我们需要证明 `0 < fac 0`，在第二个目标中，我们有额外的假设
    `ih : 0 < fac n` 并需要证明 `0 < fac (n + 1)`。短语 `with n ih` 用于命名归纳假设的变量和假设，你可以为它们选择任何你想要的名称。'
- en: '[PRE71]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `induction'` tactic is smart enough to include hypotheses that depend on
    the induction variable as part of the induction hypothesis. Step through the next
    example to see what is going on.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`induction''` 策略足够智能，可以将依赖于归纳变量的假设作为归纳假设的一部分包括在内。逐步查看下一个示例，看看发生了什么。'
- en: '[PRE72]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The following example provides a crude lower bound for the factorial function.
    It turns out to be easier to start with a proof by cases, so that the remainder
    of the proof starts with the case \(n = 1\). See if you can complete the argument
    with a proof by induction using `pow_succ` or `pow_succ'`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例提供了一个关于阶乘函数的粗糙下界。实际上，从证明的案例开始似乎更容易，因此证明的其余部分从 \(n = 1\) 的案例开始。看看你是否可以用 `pow_succ`
    或 `pow_succ'` 通过归纳证明来完成论证。
- en: '[PRE73]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Induction is often used to prove identities involving finite sums and products.
    Mathlib defines the expressions `Finset.sum s f` where `s : Finset α` is a finite
    set of elements of the type `α` and `f` is a function defined on `α`. The codomain
    of `f` can be any type that supports a commutative, associative addition operation
    with a zero element. If you import `Algebra.BigOperators.Ring` and issue the command
    `open BigOperators`, you can use the more suggestive notation `∑ x ∈ s, f x`.
    Of course, there is an analogous operation and notation for finite products.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '归纳法常用于证明涉及有限和积的恒等式。Mathlib 定义了表达式 `Finset.sum s f`，其中 `s : Finset α` 是类型 `α`
    的元素有限集合，`f` 是定义在 `α` 上的函数。函数 `f` 的陪域可以是支持具有零元素的交换、结合加法运算的任何类型。如果你导入 `Algebra.BigOperators.Ring`
    并执行 `open BigOperators` 命令，你可以使用更具提示性的符号 `∑ x ∈ s, f x`。当然，也存在类似的操作和符号用于有限积。'
- en: We will talk about the `Finset` type and the operations it supports in the next
    section, and again in a later chapter. For now, we will only make use of `Finset.range
    n`, which is the finite set of natural numbers less than `n`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中讨论 `Finset` 类型及其支持的运算，并在稍后的章节中再次讨论。现在，我们只会使用 `Finset.range n`，这是小于 `n`
    的自然数的有限集合。
- en: '[PRE74]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The facts `Finset.sum_range_zero` and `Finset.sum_range_succ` provide a recursive
    description of summation up to \(n\), and similarly for products.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 事实 `Finset.sum_range_zero` 和 `Finset.sum_range_succ` 为 \(n\) 的求和提供了一个递归描述，对于积也是如此。
- en: '[PRE75]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The first identity in each pair holds definitionally, which is to say, you can
    replace the proofs by `rfl`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 每对中的第一个恒等式是定义性的，也就是说，你可以用 `rfl` 替换证明。
- en: The following expresses the factorial function that we defined as a product.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表示我们定义的阶乘函数作为积。
- en: '[PRE76]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The fact that we include `mul_comm` as a simplification rule deserves comment.
    It should seem dangerous to simplify with the identity `x * y = y * x`, which
    would ordinarily loop indefinitely. Lean’s simplifier is smart enough to recognize
    that, and applies the rule only in the case where the resulting term has a smaller
    value in some fixed but arbitrary ordering of the terms. The following example
    shows that simplifying using the three rules `mul_assoc`, `mul_comm`, and `mul_left_comm`
    manages to identify products that are the same up to the placement of parentheses
    and ordering of variables.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `mul_comm` 作为简化规则包括在内的事实值得注意。使用恒等式 `x * y = y * x` 进行简化似乎很危险，因为这通常会无限循环。Lean
    的简化器足够智能，能够识别这一点，并且仅在结果项在某些固定但任意的项的排序中具有更小值的情况下应用该规则。以下示例表明，使用 `mul_assoc`、`mul_comm`
    和 `mul_left_comm` 这三个规则进行简化能够识别出相同但括号位置和变量排序不同的积。
- en: '[PRE77]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Roughly, the rules work by pushing parentheses to the right and then re-ordering
    the expressions on both sides until they both follow the same canonical order.
    Simplifying with these rules, and the corresponding rules for addition, is a handy
    trick.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 大概来说，这些规则通过将括号推向右边，然后重新排列两侧的表达式，直到它们都遵循相同的规范顺序来工作。使用这些规则简化，以及相应的加法规则，是一个实用的技巧。
- en: Returning to summation identities, we suggest stepping through the following
    proof that the sum of the natural numbers up to and including \(n\) is \(n (n
    + 1) / 2\). The first step of the proof clears the denominator. This is generally
    useful when formalizing identities, because calculations with division generally
    have side conditions. (It is similarly useful to avoid using subtraction on the
    natural numbers when possible.)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 回到求和恒等式，我们建议逐步通过以下证明，即自然数从1加到\(n\)（包括\(n\)）的和是\(n (n + 1) / 2\)。证明的第一步消除了分母。这在形式化恒等式时通常很有用，因为涉及除法的计算通常有附加条件。（同样，在可能的情况下避免在自然数上使用减法也是有用的。）
- en: '[PRE78]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We encourage you to prove the analogous identity for sums of squares, and other
    identities you can find on the web.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励你证明平方和的类似恒等式，以及你在网上能找到的其他恒等式。
- en: '[PRE79]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In Lean’s core library, addition and multiplication are themselves defined using
    recursive definitions, and their fundamental properties are established using
    induction. If you like thinking about foundational topics like that, you might
    enjoy working through proofs of the commutativity and associativity of multiplication
    and addition and the distributivity of multiplication over addition. You can do
    this on a copy of the natural numbers following the outline below. Notice that
    we can use the `induction` tactic with `MyNat`; Lean is smart enough to know to
    use the relevant induction principle (which is, of course, the same as that for
    `Nat`).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lean的核心库中，加法和乘法本身是通过递归定义的，它们的基本性质是通过归纳法建立的。如果你喜欢思考像那样的基础主题，你可能喜欢通过乘法和加法的交换律和结合律以及乘法对加法的分配律的证明来工作。你可以按照以下概述在自然数的副本上这样做。注意，我们可以使用`induction`策略与`MyNat`；Lean足够智能，知道要使用相关的归纳原理（当然，这与`Nat`的相同）。
- en: We start you off with the commutativity of addition. A good rule of thumb is
    that because addition and multiplication are defined by recursion on the second
    argument, it is generally advantageous to do proofs by induction on a variable
    that occurs in that position. It is a bit tricky to decide which variable to use
    in the proof of associativity.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从加法的交换律开始。一个很好的经验法则是，由于加法和乘法是通过第二个参数的递归定义的，因此通常在出现在该位置的变量上通过归纳法进行证明是有利的。在证明结合律时决定使用哪个变量有点棘手。
- en: It can be confusing to write things without the usual notation for zero, one,
    addition, and multiplication. We will learn how to define such notation later.
    Working in the namespace `MyNat` means that we can write `zero` and `succ` rather
    than `MyNat.zero` and `MyNat.succ`, and that these interpretations of the names
    take precedence over others. Outside the namespace, the full name of the `add`
    defined below, for example, is `MyNat.add`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用零、一、加法和乘法的常规符号来写东西可能会让人困惑。我们将在以后学习如何定义这样的符号。在`MyNat`命名空间中工作意味着我们可以写`zero`和`succ`而不是`MyNat.zero`和`MyNat.succ`，并且这些名称的解释优先于其他解释。在命名空间外部，下面定义的`add`的完整名称是`MyNat.add`。
- en: If you find that you *really* enjoy this sort of thing, try defining truncated
    subtraction and exponentiation and proving some of their properties as well. Remember
    that truncated subtraction cuts off at zero. To define that, it is useful to define
    a predecessor function, `pred`, that subtracts one from any nonzero number and
    fixes zero. The function `pred` can be defined by a simple instance of recursion.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现你真的喜欢这类东西，尝试定义截断减法和指数运算，并证明它们的一些性质。记住，截断减法在零处截断。为了定义这一点，定义一个前驱函数`pred`，它从任何非零数中减去一，并固定零。函数`pred`可以通过一个简单的递归实例来定义。
- en: '[PRE80]  ## 5.3\. Infinitely Many Primes[](#infinitely-many-primes "Link to
    this heading")'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE80]  ## 5.3\. 无限多个素数[](#infinitely-many-primes "链接到这个标题")'
- en: 'Let us continue our exploration of induction and recursion with another mathematical
    standard: a proof that there are infinitely many primes. One way to formulate
    this is as the statement that for every natural number \(n\), there is a prime
    number greater than \(n\). To prove this, let \(p\) be any prime factor of \(n!
    + 1\). If \(p\) is less than or equal to \(n\), it divides \(n!\). Since it also
    divides \(n! + 1\), it divides 1, a contradiction. Hence \(p\) is greater than
    \(n\).'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续用另一个数学标准来探索归纳和递归：证明存在无限多个质数。一种表述方式是，对于每一个自然数 \(n\)，都存在一个大于 \(n\) 的质数。为了证明这一点，设
    \(p\) 是 \(n! + 1\) 的任意一个质因数。如果 \(p\) 小于或等于 \(n\)，它就会整除 \(n!\)。由于它也整除 \(n! + 1\)，它就会整除
    1，这是矛盾的。因此 \(p\) 必须大于 \(n\)。
- en: 'To formalize that proof, we need to show that any number greater than or equal
    to 2 has a prime factor. To do that, we will need to show that any natural number
    that is not equal to 0 or 1 is greater-than or equal to 2. And this brings us
    to a quirky feature of formalization: it is often trivial statements like this
    that are among the most annoying to formalize. Here we consider a few ways to
    do it.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个证明形式化，我们需要证明任何大于或等于 2 的数都有一个质因数。要做到这一点，我们需要证明任何不等于 0 或 1 的自然数都大于或等于 2。这引出了形式化中的一个奇特特性：这类简单陈述往往是最令人烦恼的。在这里，我们考虑了几种实现方法。
- en: To start with, we can use the `cases` tactic and the fact that the successor
    function respects the ordering on the natural numbers.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以使用 `cases` 策略和后继函数尊重自然数上的顺序这一事实。
- en: '[PRE81]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Another strategy is to use the tactic `interval_cases`, which automatically
    splits the goal into cases when the variable in question is contained in an interval
    of natural numbers or integers. Remember that you can hover over it to see its
    documentation.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种策略是使用 `interval_cases` 策略，它会自动将目标分解为当变量位于自然数或整数的区间内时的几种情况。记住，你可以悬停在它上面以查看其文档。
- en: '[PRE82]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Recall that the semicolon after `interval_cases m` means that the next tactic
    is applied to each of the cases that it generates. Yet another option is to use
    the tactic `decide`, which tries to find a decision procedure to solve the problem.
    Lean knows that you can decide the truth value of a statement that begins with
    a bounded quantifier `∀ x, x < n → ...` or `∃ x, x < n ∧ ...` by deciding each
    of the finitely many instances.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`interval_cases m` 后面的分号意味着下一个策略将应用于它生成的每个情况。另一个选项是使用 `decide` 策略，它试图找到一个决策过程来解决问题。Lean
    知道你可以通过决定每个有限实例来决定以有界量词 `∀ x, x < n → ...` 或 `∃ x, x < n ∧ ...` 开头的语句的真值。
- en: '[PRE83]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: With the theorem `two_le` in hand, let’s start by showing that every natural
    number greater than two has a prime divisor. Mathlib contains a function `Nat.minFac`
    that returns the smallest prime divisor, but for the sake of learning new parts
    of the library, we’ll avoid using it and prove the theorem directly.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有定理 `two_le` 后，让我们首先证明每个大于两的自然数都有一个质数因子。Mathlib 包含一个函数 `Nat.minFac`，它返回最小的质数因子，但为了学习库的新部分，我们将避免使用它，并直接证明这个定理。
- en: Here, ordinary induction isn’t enough. We want to use *strong induction*, which
    allows us to prove that every natural number \(n\) has a property \(P\) by showing
    that for every number \(n\), if \(P\) holds of all values less than \(n\), it
    holds at \(n\) as well. In Lean, this principle is called `Nat.strong_induction_on`,
    and we can use the `using` keyword to tell the induction tactic to use it. Notice
    that when we do that, there is no base case; it is subsumed by the general induction
    step.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，普通的归纳不足以解决问题。我们想要使用 **强归纳**，这允许我们通过证明对于每个数 \(n\)，如果 \(P\) 对所有小于 \(n\) 的值成立，那么它对
    \(n\) 也成立，来证明每个自然数 \(n\) 都有一个性质 \(P\)。在 Lean 中，这个原则被称为 `Nat.strong_induction_on`，我们可以使用
    `using` 关键字告诉归纳策略使用它。注意，当我们这样做时，没有基础情况；它被归纳步骤所包含。
- en: The argument is simply as follows. Assuming \(n ≥ 2\), if \(n\) is prime, we’re
    done. If it isn’t, then by one of the characterizations of what it means to be
    a prime number, it has a nontrivial factor, \(m\), and we can apply the inductive
    hypothesis to that. Step through the next proof to see how that plays out.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 论证如下。假设 \(n ≥ 2\)，如果 \(n\) 是质数，那么我们就完成了。如果不是，那么根据质数的定义之一，它有一个非平凡因子 \(m\)，我们可以对它应用归纳假设。通过查看下一个证明，我们可以看到这是如何实现的。
- en: '[PRE84]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We can now prove the following formulation of our theorem. See if you can fill
    out the sketch. You can use `Nat.factorial_pos`, `Nat.dvd_factorial`, and `Nat.dvd_sub'`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以证明我们定理的以下表述。看看你是否可以完成这个草图。你可以使用 `Nat.factorial_pos`、`Nat.dvd_factorial`
    和 `Nat.dvd_sub'`。
- en: '[PRE85]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Let’s consider a variation of the proof above, where instead of using the factorial
    function, we suppose that we are given by a finite set \(\{ p_1, \ldots, p_n \}\)
    and we consider a prime factor of \(\prod_{i = 1}^n p_i + 1\). That prime factor
    has to be distinct from each \(p_i\), showing that there is no finite set that
    contains all the prime numbers.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑上述证明的一个变体，其中我们不是使用阶乘函数，而是假设我们被一个有限集合 \(\{ p_1, \ldots, p_n \}\) 给定，并考虑
    \(\prod_{i = 1}^n p_i + 1\) 的一个素数因子。这个素数因子必须与每个 \(p_i\) 不同，这表明不存在包含所有素数的有限集合。
- en: Formalizing this argument requires us to reason about finite sets. In Lean,
    for any type `α`, the type `Finset α` represents finite sets of elements of type
    `α`. Reasoning about finite sets computationally requires having a procedure to
    test equality on `α`, which is why the snippet below includes the assumption `[DecidableEq
    α]`. For concrete data types like `ℕ`, `ℤ`, and `ℚ`, the assumption is satisfied
    automatically. When reasoning about the real numbers, it can be satisfied using
    classical logic and abandoning the computational interpretation.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个论证形式化需要我们对有限集进行推理。在 Lean 中，对于任何类型 `α`，类型 `Finset α` 表示类型 `α` 的元素构成的有限集。对有限集进行计算推理需要有一个测试
    `α` 上等性的过程，这就是为什么下面的代码片段包括假设 `[DecidableEq α]`。对于像 `ℕ`、`ℤ` 和 `ℚ` 这样的具体数据类型，这个假设会自动满足。当推理实数时，可以使用经典逻辑并放弃计算解释来满足这个假设。
- en: We use the command `open Finset` to avail ourselves of shorter names for the
    relevant theorems. Unlike the case with sets, most equivalences involving finsets
    do not hold definitionally, so they need to be expanded manually using equivalences
    like `Finset.subset_iff`, `Finset.mem_union`, `Finset.mem_inter`, and `Finset.mem_sdiff`.
    The `ext` tactic can still be used to show that two finite sets are equal by showing
    that every element of one is an element of the other.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用命令 `open Finset` 来使用相关定理的较短名称。与集合的情况不同，大多数涉及有限集的等价关系在定义上并不成立，因此需要手动使用等价关系如
    `Finset.subset_iff`、`Finset.mem_union`、`Finset.mem_inter` 和 `Finset.mem_sdiff`
    来展开。`ext` 策略仍然可以用来通过显示一个有限集的每个元素都是另一个集合的元素来证明两个有限集相等。
- en: '[PRE86]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We have used a new trick: the `tauto` tactic (and a strengthened version, `tauto!`,
    which uses classical logic) can be used to dispense with propositional tautologies.
    See if you can use these methods to prove the two examples below.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个新的技巧：`tauto` 策略（以及一个增强版本 `tauto!`，它使用经典逻辑）可以用来省略命题恒真式。看看你是否可以使用这些方法来证明下面的两个例子。
- en: '[PRE87]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The theorem `Finset.dvd_prod_of_mem` tells us that if an `n` is an element of
    a finite set `s`, then `n` divides `∏ i ∈ s, i`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 `Finset.dvd_prod_of_mem` 告诉我们，如果 `n` 是有限集合 `s` 的一个元素，那么 `n` 能整除 `∏ i ∈ s,
    i`。
- en: '[PRE88]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We also need to know that the converse holds in the case where `n` is prime
    and `s` is a set of primes. To show that, we need the following lemma, which you
    should be able to prove using the theorem `Nat.Prime.eq_one_or_self_of_dvd`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要知道，在 `n` 是素数且 `s` 是素数集合的情况下，逆命题也成立。为了证明这一点，我们需要以下引理，你应该能够使用定理 `Nat.Prime.eq_one_or_self_of_dvd`
    来证明。
- en: '[PRE89]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We can use this lemma to show that if a prime `p` divides a product of a finite
    set of primes, then it is equal to one of them. Mathlib provides a useful principle
    of induction on finite sets: to show that a property holds of an arbitrary finite
    set `s`, show that it holds of the empty set, and show that it is preserved when
    we add a single new element `a ∉ s`. The principle is known as `Finset.induction_on`.
    When we tell the induction tactic to use it, we can also specify the names `a`
    and `s`, the name for the assumption `a ∉ s` in the inductive step, and the name
    of the inductive hypothesis. The expression `Finset.insert a s` denotes the union
    of `s` with the singleton `a`. The identities `Finset.prod_empty` and `Finset.prod_insert`
    then provide the relevant rewrite rules for the product. In the proof below, the
    first `simp` applies `Finset.prod_empty`. Step through the beginning of the proof
    to see the induction unfold, and then finish it off.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个引理来证明如果一个素数 `p` 整除有限个素数的乘积，那么它等于其中的一个。Mathlib 提供了一个有用的有限集归纳原理：为了证明一个性质对任意有限集
    `s` 成立，需要证明它对空集成立，并且在我们添加一个新元素 `a ∉ s` 时它被保留。这个原理被称为 `Finset.induction_on`。当我们告诉归纳策略使用它时，我们还可以指定
    `a` 和 `s` 的名称，以及在归纳步骤中 `a ∉ s` 的假设的名称，以及归纳假设的名称。表达式 `Finset.insert a s` 表示 `s`
    与单元素集合 `a` 的并集。`Finset.prod_empty` 和 `Finset.prod_insert` 然后提供了乘积的相关重写规则。在下面的证明中，第一个
    `simp` 应用了 `Finset.prod_empty`。逐步通过证明的开始，看看归纳展开，然后完成它。
- en: '[PRE90]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We need one last property of finite sets. Given an element `s : Set α` and
    a predicate `P` on `α`, in [Chapter 4](C04_Sets_and_Functions.html#sets-and-functions)
    we wrote `{ x ∈ s | P x }` for the set of elements of `s` that satisfy `P`. Given
    `s : Finset α`, the analogous notion is written `s.filter P`.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '我们需要有限集的一个最后属性。给定一个元素 `s : Set α` 和一个在 `α` 上的谓词 `P`，在 [第 4 章](C04_Sets_and_Functions.html#sets-and-functions)
    中，我们用 `{ x ∈ s | P x }` 表示满足 `P` 的 `s` 的元素集合。给定 `s : Finset α`，类似的概念表示为 `s.filter
    P`。'
- en: '[PRE91]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We now prove an alternative formulation of the statement that there are infinitely
    many primes, namely, that given any `s : Finset ℕ`, there is a prime `p` that
    is not an element of `s`. Aiming for a contradiction, we assume that all the primes
    are in `s`, and then cut down to a set `s''` that contains all and only the primes.
    Taking the product of that set, adding one, and finding a prime factor of the
    result leads to the contradiction we are looking for. See if you can complete
    the sketch below. You can use `Finset.prod_pos` in the proof of the first `have`.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们证明关于存在无限多个素数的陈述的另一种表述，即给定任何 `s : Finset ℕ`，存在一个素数 `p`，它不是 `s` 的元素。为了达到矛盾，我们假设所有素数都在
    `s` 中，然后缩减到一个只包含所有素数的集合 `s''`。计算该集合的乘积，加一，并找到结果的素数因子，将导致我们寻找的矛盾。看看你是否能完成下面的草图。你可以在第一个
    `have` 的证明中使用 `Finset.prod_pos`。 '
- en: '[PRE92]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We have thus seen two ways of saying that there are infinitely many primes:
    saying that they are not bounded by any `n`, and saying that they are not contained
    in any finite set `s`. The two proofs below show that these formulations are equivalent.
    In the second, in order to form `s.filter Q`, we have to assume that there is
    a procedure for deciding whether or not `Q` holds. Lean knows that there is a
    procedure for `Nat.Prime`. In general, if we use classical logic by writing `open
    Classical`, we can dispense with the assumption.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了两种表达存在无限多个素数的方法：说它们不受任何 `n` 的限制，以及说它们不包含在任何有限集 `s` 中。下面的两个证明表明这些表述是等价的。在第二个证明中，为了形成
    `s.filter Q`，我们必须假设存在一个判断 `Q` 是否成立的程序。Lean 知道存在一个用于 `Nat.Prime` 的程序。一般来说，如果我们通过编写
    `open Classical` 使用经典逻辑，我们可以省去这个假设。
- en: In Mathlib, `Finset.sup s f` denotes the supremum of the values of `f x` as
    `x` ranges over `s`, returning `0` in the case where `s` is empty and the codomain
    of `f` is `ℕ`. In the first proof, we use `s.sup id`, where `id` is the identity
    function, to refer to the maximum value in `s`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mathlib 中，`Finset.sup s f` 表示 `f x` 的值在 `x` 在 `s` 上取值时的上确界，当 `s` 为空且 `f` 的陪域为
    `ℕ` 时返回 `0`。在第一个证明中，我们使用 `s.sup id`，其中 `id` 是恒等函数，来指代 `s` 中的最大值。
- en: '[PRE93]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: A small variation on our second proof that there are infinitely many primes
    shows that there are infinitely many primes congruent to 3 modulo 4. The argument
    goes as follows. First, notice that if the product of two numbers \(m\) and \(n\)
    is equal to 3 modulo 4, then one of the two numbers is congruent to 3 modulo 4.
    After all, both have to be odd, and if they are both congruent to 1 modulo 4,
    so is their product. We can use this observation to show that if some number greater
    than 2 is congruent to 3 modulo 4, then that number has a prime divisor that is
    also congruent to 3 modulo 4.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们第二个证明无限多个素数的微小变化表明，存在无限多个模 4 同余于 3 的素数。论证如下。首先，注意如果两个数 \(m\) 和 \(n\) 的乘积模
    4 等于 3，那么这两个数中至少有一个模 4 同余于 3。毕竟，它们都必须是奇数，如果它们都模 4 同余于 1，那么它们的乘积也是。我们可以利用这个观察结果来证明如果某个大于
    2 的数模 4 同余于 3，那么这个数有一个模 4 同余于 3 的素数约数。
- en: Now suppose there are only finitely many prime numbers congruent to 3 modulo
    4, say, \(p_1, \ldots, p_k\). Without loss of generality, we can assume that \(p_1
    = 3\). Consider the product \(4 \prod_{i = 2}^k p_i + 3\). It is easy to see that
    this is congruent to 3 modulo 4, so it has a prime factor \(p\) congruent to 3
    modulo 4. It can’t be the case that \(p = 3\); since \(p\) divides \(4 \prod_{i
    = 2}^k p_i + 3\), if \(p\) were equal to 3 then it would also divide \(\prod_{i
    = 2}^k p_i\), which implies that \(p\) is equal to one of the \(p_i\) for \(i
    = 2, \ldots, k\); and we have excluded 3 from this list. So \(p\) has to be one
    of the other elements \(p_i\). But in that case, \(p\) divides \(4 \prod_{i =
    2}^k p_i\) and hence 3, which contradicts the fact that it is not 3.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设只有有限多个模 4 同余于 3 的素数，比如说，\(p_1, \ldots, p_k\)。不失一般性，我们可以假设 \(p_1 = 3\)。考虑乘积
    \(4 \prod_{i = 2}^k p_i + 3\)。很容易看出这个数模 4 同余于 3，所以它有一个模 4 同余于 3 的素数因子 \(p\)。不可能
    \(p = 3\)；因为 \(p\) 能整除 \(4 \prod_{i = 2}^k p_i + 3\)，如果 \(p\) 等于 3，那么它也会整除 \(\prod_{i
    = 2}^k p_i\)，这意味着 \(p\) 等于 \(p_i\) 中的一个，对于 \(i = 2, \ldots, k\)；但我们已经排除了 3。所以
    \(p\) 必须是其他元素 \(p_i\) 中的一个。但在那种情况下，\(p\) 能整除 \(4 \prod_{i = 2}^k p_i\) 和 3，这与它不是
    3 的事实相矛盾。
- en: In Lean, the notation `n % m`, read “`n` modulo `m`,” denotes the remainder
    of the division of `n` by `m`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lean 中，表示法 `n % m` 读作“`n` 模 `m`”，表示 `n` 除以 `m` 的余数。
- en: '[PRE94]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We can then render the statement “`n` is congruent to 3 modulo 4” as `n % 4
    = 3`. The following example and theorems sum up the facts about this function
    that we will need to use below. The first named theorem is another illustration
    of reasoning by a small number of cases. In the second named theorem, remember
    that the semicolon means that the subsequent tactic block is applied to all the
    goals created by the preceding tactic.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将陈述“`n` 模 4 同余于 3”表示为 `n % 4 = 3`。以下示例和定理总结了我们将需要使用的事实。第一个命名的定理是通过对少数几个情况进行推理的另一个例子。在第二个命名的定理中，记住分号意味着后续的策略块应用于由前面的策略块创建的所有目标。
- en: '[PRE95]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: We will also need the following fact, which says that if `m` is a nontrivial
    divisor of `n`, then so is `n / m`. See if you can complete the proof using `Nat.div_dvd_of_dvd`
    and `Nat.div_lt_self`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要以下事实，即如果 `m` 是 `n` 的非平凡约数，那么 `n / m` 也是。看看你是否能使用 `Nat.div_dvd_of_dvd` 和
    `Nat.div_lt_self` 完成证明。
- en: '[PRE96]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Now put all the pieces together to prove that any number congruent to 3 modulo
    4 has a prime divisor with that same property.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将所有这些部分组合起来，证明任何模 4 同余于 3 的数都有一个具有相同性质的素数约数。
- en: '[PRE97]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: We are in the home stretch. Given a set `s` of prime numbers, we need to talk
    about the result of removing 3 from that set, if it is present. The function `Finset.erase`
    handles that.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经接近终点。给定一个素数集合 `s`，如果其中包含 3，我们需要讨论从该集合中移除 3 的结果。函数 `Finset.erase` 处理这个问题。
- en: '[PRE98]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: We are now ready to prove that there are infinitely many primes congruent to
    3 modulo 4. Fill in the missing parts below. Our solution uses `Nat.dvd_add_iff_left`
    and `Nat.dvd_sub'` along the way.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备证明存在无限多个模 4 同余于 3 的素数。在下面的空白处填写缺失的部分。我们的解决方案在过程中使用了 `Nat.dvd_add_iff_left`
    和 `Nat.dvd_sub'`。
- en: '[PRE99]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'If you managed to complete the proof, congratulations! This has been a serious
    feat of formalization.  ## 5.4\. More Induction[](#more-induction "Link to this
    heading")'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你设法完成了证明，恭喜你！这已经是一项正式化的重大成就。## 5.4. 更多归纳[](#more-induction "链接到这个标题")
- en: In [Section 5.2](#section-induction-and-recursion), we saw how to define the
    factorial function by recursion on the natural numbers.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 5.2 节](#section-induction-and-recursion) 中，我们看到了如何通过自然数的递归定义阶乘函数。
- en: '[PRE100]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: We also saw how to prove theorems using the `induction'` tactic.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何使用 `induction'` 策略证明定理。
- en: '[PRE101]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The `induction` tactic (without the prime tick mark) allows for more structured
    syntax.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`induction` 策略（不带撇号）允许更结构化的语法。'
- en: '[PRE102]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: As usual, you can hover over the `induction` keyword to read the documentation.
    The names of the cases, `zero` and `succ`, are taken from the definition of the
    type ℕ. Notice that the `succ` case allows you to choose whatever names you want
    for the induction variable and the inductive hypothesis, here `n` and `ih`. You
    can even prove a theorem with the same notation used to define a recursive function.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，你可以悬停在 `induction` 关键字上以阅读文档。案例的名称 `zero` 和 `succ` 来自于类型 ℕ 的定义。注意，`succ`
    案例允许你为归纳变量和归纳假设选择任何你想要的名称，这里为 `n` 和 `ih`。你甚至可以使用定义递归函数的相同符号来证明定理。
- en: '[PRE103]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Notice also the absence of the `:=`, the `∀ n` after the colon, the `by` keyword
    in each case, and the inductive appeal to `fac_pos' n`. It is as though the theorem
    is a recursive function of `n` and in the inductive step we make a recursive call.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到没有 `:=`，冒号后面的 `∀ n`，每个情况中的 `by` 关键字，以及归纳调用 `fac_pos' n`。这就像定理是 `n` 的递归函数，在归纳步骤中我们进行递归调用。
- en: This style of definition is remarkably flexible. Lean’s designers have built
    in elaborate means of defining recursive functions, and these extend to doing
    proofs by induction. For example, we can define the Fibonacci function with multiple
    base cases.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这种定义风格非常灵活。Lean 的设计者内置了定义递归函数的复杂手段，这些手段扩展到了通过归纳进行证明。例如，我们可以使用多个基本情况来定义斐波那契函数。
- en: '[PRE104]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The `@[simp]` annotation means that the simplifier will use the defining equations.
    You can also apply them by writing `rw [fib]`. Below it will be helpful to give
    a name to the `n + 2` case.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`@[simp]` 注解表示简化器将使用定义方程。你也可以通过编写 `rw [fib]` 来应用它们。下面将有助于为 `n + 2` 的情况命名。'
- en: '[PRE105]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Using Lean’s notation for recursive functions, you can carry out proofs by induction
    on the natural numbers that mirror the recursive definition of `fib`. The following
    example provides an explicit formula for the nth Fibonacci number in terms of
    the golden mean, `φ`, and its conjugate, `φ'`. We have to tell Lean that we don’t
    expect our definitions to generate code because the arithmetic operations on the
    real numbers are not computable.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Lean 的递归函数表示法，你可以通过归纳自然数来执行与 `fib` 的递归定义相对应的证明。以下示例提供了第 n 个斐波那契数的显式公式，该公式以黄金分割数
    `φ` 及其共轭 `φ'` 为基础。我们必须告诉 Lean，我们预期我们的定义不会生成代码，因为实数上的算术运算是不可计算的。
- en: '[PRE106]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Induction proofs involving the Fibonacci function do not have to be of that
    form. Below we reproduce the `Mathlib` proof that consecutive Fibonacci numbers
    are coprime.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及斐波那契函数的归纳证明不必是那种形式。以下我们重现了 `Mathlib` 证明连续斐波那契数是互质的。
- en: '[PRE107]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Using Lean’s computational interpretation, we can evaluate the Fibonacci numbers.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Lean 的计算解释，我们可以评估斐波那契数。
- en: '[PRE108]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The straightforward implementation of `fib` is computationally inefficient.
    In fact, it runs in time exponential in its argument. (You should think about
    why.) In Lean, we can implement the following tail-recursive version, whose running
    time is linear in `n`, and prove that it computes the same function.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`fib` 的直接实现计算效率低下。实际上，它的运行时间与其参数呈指数关系。（你应该思考一下为什么。）在 Lean 中，我们可以实现以下尾递归版本，其运行时间与
    `n` 线性相关，并证明它计算的是相同的函数。'
- en: '[PRE109]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Notice the `generalizing` keyword in the proof of `fib'.aux_eq`. It serves to
    insert a `∀ m` in front of the inductive hypothesis, so that in the induction
    step, `m` can take a different value. You can step through the proof and check
    that in this case, the quantifier needs to be instantiated to `m + 1` in the inductive
    step.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `fib'.aux_eq` 证明中的 `generalizing` 关键字。它用于在归纳假设前插入 `∀ m`，这样在归纳步骤中，`m` 可以取不同的值。你可以逐步检查证明，并确认在这种情况下，量词需要在归纳步骤中实例化为
    `m + 1`。
- en: Notice also the use of `erw` (for “extended rewrite”) instead of `rw`. This
    is used because to rewrite the goal `fib'.aux_eq`, `fib 0` and `fib 1` have to
    be reduced to `0` and `1`, respectively. The tactic `erw` is more aggressive than
    `rw` in unfolding definitions to match parameters. This isn’t always a good idea;
    it can waste a lot of time in some cases, so use `erw` sparingly.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 注意也使用了 `erw`（表示“扩展重写”）而不是 `rw`。这是因为为了重写目标 `fib'.aux_eq`，`fib 0` 和 `fib 1` 必须分别简化为
    `0` 和 `1`。与 `rw` 相比，`erw` 在展开定义以匹配参数方面更为激进。这并不总是好主意；在某些情况下，它可能会浪费大量时间，因此请谨慎使用
    `erw`。
- en: Here is another example of the `generalizing` keyword in use, in the proof of
    another identity that is found in `Mathlib`. An informal proof of the identity
    can be found [here](https://proofwiki.org/wiki/Fibonacci_Number_in_terms_of_Smaller_Fibonacci_Numbers).
    We provide two variants of the formal proof.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `generalizing` 关键字在另一个在 `Mathlib` 中找到的恒等式证明中使用的另一个例子。该恒等式的非正式证明可以在[这里](https://proofwiki.org/wiki/Fibonacci_Number_in_terms_of_Smaller_Fibonacci_Numbers)找到。我们提供了两种正式证明的变体。
- en: '[PRE110]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: As an exercise, use `fib_add` to prove the following.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，使用 `fib_add` 证明以下内容。
- en: '[PRE111]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Lean’s mechanisms for defining recursive functions are flexible enough to allow
    arbitrary recursive calls, as long the complexity of the arguments decrease according
    to some well-founded measure. In the next example, we show that every natural
    number `n ≠ 1` has a prime divisor, using the fact that if `n` is nonzero and
    not prime, it has a smaller divisor. (You can check that Mathlib has a theorem
    of the same name in the `Nat` namespace, though it has a different proof than
    the one we give here.)
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 定义递归函数的机制足够灵活，允许任意递归调用，只要参数的复杂度根据某个良基度量递减。在下一个例子中，我们展示了每个自然数 `n ≠ 1` 都有一个素数因子，利用了如果
    `n` 非零且不是素数，它有一个更小的因子的这一事实。（你可以检查 Mathlib 在 `Nat` 命名空间中有一个同名的定理，尽管它的证明与这里给出的不同。）
- en: '[PRE112]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The line `rw [ne_one_iff_exists_prime_dvd] at this` is like a magic trick:
    we are using the very theorem we are proving in its own proof. What makes it work
    is that the inductive call is instantiated at `m`, the current case is `n + 2`,
    and the context has `m < n + 2`. Lean can find the hypothesis and use it to show
    that the induction is well-founded. Lean is pretty good at figuring out what is
    decreasing; in this case, the choice of `n` in the statement of the theorem and
    the less-than relation is obvious. In more complicated cases, Lean provides mechanisms
    to provide this information explicitly. See the section on [well-founded recursion](https://lean-lang.org/doc/reference/latest//Definitions/Recursive-Definitions/#well-founded-recursion)
    in the Lean Reference Manual.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码 `rw [ne_one_iff_exists_prime_dvd] at this` 就像是一个魔术：我们正在使用我们正在证明的定理本身来证明它。使其工作的是归纳调用在
    `m` 上实例化，当前情况是 `n + 2`，并且上下文有 `m < n + 2`。Lean 可以找到假设并使用它来证明归纳是良基的。Lean 在找出什么是递减的方面相当出色；在这种情况下，定理陈述中的
    `n` 的选择和小于关系是显而易见的。在更复杂的情况下，Lean 提供了提供此信息的机制。请参阅 Lean 参考手册中关于[良基递归](https://lean-lang.org/doc/reference/latest//Definitions/Recursive-Definitions/#well-founded-recursion)的部分。
- en: Sometimes, in a proof, you need to split on cases depending on whether a natural
    number `n` is zero or a successor, without requiring an inductive hypothesis in
    the successor case. For that, you can use the `cases` and `rcases` tactics.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在证明中，你可能需要根据自然数 `n` 是零还是后继来分情况讨论，而不需要在后继情况下使用归纳假设。为此，你可以使用 `cases` 和 `rcases`
    策略。
- en: '[PRE113]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'This is a useful trick. Often you have a theorem about a natural number `n`
    for which the zero case is easy. If you case on `n` and take care of the zero
    case quickly, you are left with the original goal with `n` replaced by `n + 1`.  ##
    5.1\. Irrational Roots[](#irrational-roots "Link to this heading")'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的技巧。通常，你有一个关于自然数 `n` 的定理，其中零的情况很容易处理。如果你对 `n` 进行情况分析并快速处理零的情况，你将剩下用 `n
    + 1` 替换后的原始目标。
- en: Let’s start with a fact known to the ancient Greeks, namely, that the square
    root of 2 is irrational. If we suppose otherwise, we can write \(\sqrt{2} = a
    / b\) as a fraction in lowest terms. Squaring both sides yields \(a^2 = 2 b^2\),
    which implies that \(a\) is even. If we write \(a = 2c\), then we get \(4c^2 =
    2 b^2\) and hence \(b^2 = 2 c^2\). This implies that \(b\) is also even, contradicting
    the fact that we have assumed that \(a / b\) has been reduced to lowest terms.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从古希腊人已知的一个事实开始，即 2 的平方根是无理数。如果我们假设相反，我们可以将 \(\sqrt{2} = a / b\) 写成最简分数。平方两边得到
    \(a^2 = 2 b^2\)，这意味着 \(a\) 是偶数。如果我们写成 \(a = 2c\)，那么我们得到 \(4c^2 = 2 b^2\)，从而 \(b^2
    = 2 c^2\)。这表明 \(b\) 也是偶数，这与我们假设的 \(a / b\) 已经被化简到最简形式的事实相矛盾。
- en: Saying that \(a / b\) is a fraction in lowest terms means that \(a\) and \(b\)
    do not have any factors in common, which is to say, they are *coprime*. Mathlib
    defines the predicate `Nat.Coprime m n` to be `Nat.gcd m n = 1`. Using Lean’s
    anonymous projection notation, if `s` and `t` are expressions of type `Nat`, we
    can write `s.Coprime t` instead of `Nat.Coprime s t`, and similarly for `Nat.gcd`.
    As usual, Lean will often unfold the definition of `Nat.Coprime` automatically
    when necessary, but we can also do it manually by rewriting or simplifying with
    the identifier `Nat.Coprime`. The `norm_num` tactic is smart enough to compute
    concrete values.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 说\(a / b\)是最简分数意味着\(a\)和\(b\)没有公共因子，也就是说，它们是*互质的*。Mathlib定义谓词`Nat.Coprime m
    n`为`Nat.gcd m n = 1`。使用Lean的匿名投影符号，如果`s`和`t`是类型为`Nat`的表达式，我们可以写`s.Coprime t`而不是`Nat.Coprime
    s t`，对于`Nat.gcd`也是如此。通常，当需要时，Lean会自动展开`Nat.Coprime`的定义，但我们也可以通过重写或使用标识符`Nat.Coprime`进行简化来手动完成。`norm_num`策略足够智能，可以计算具体值。
- en: '[PRE114]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: We have already encountered the `gcd` function in [Section 2.4](C02_Basics.html#more-on-order-and-divisibility).
    There is also a version of `gcd` for the integers; we will return to a discussion
    of the relationship between different number systems below. There are even a generic
    `gcd` function and generic notions of `Prime` and `Coprime` that make sense in
    general classes of algebraic structures. We will come to understand how Lean manages
    this generality in the next chapter. In the meanwhile, in this section, we will
    restrict attention to the natural numbers.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第2.4节](C02_Basics.html#more-on-order-and-divisibility)中遇到了`gcd`函数。还有为整数提供的`gcd`版本；我们将在下面讨论不同数系之间的关系。甚至还有一个通用的`gcd`函数和通用的`Prime`和`Coprime`概念，它们在一般的代数结构中是有意义的。我们将在下一章中了解Lean如何管理这种通用性。同时，在本节中，我们将把注意力限制在自然数上。
- en: We also need the notion of a prime number, `Nat.Prime`. The theorem `Nat.prime_def_lt`
    provides one familiar characterization, and `Nat.Prime.eq_one_or_self_of_dvd`
    provides another.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要素数的概念，即`Nat.Prime`。定理`Nat.prime_def_lt`提供了一种熟悉的特征描述，而`Nat.Prime.eq_one_or_self_of_dvd`提供了另一种描述。
- en: '[PRE115]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: In the natural numbers, a prime number has the property that it cannot be written
    as a product of nontrivial factors. In a broader mathematical context, an element
    of a ring that has this property is said to be *irreducible*. An element of a
    ring is said to be *prime* if whenever it divides a product, it divides one of
    the factors. It is an important property of the natural numbers that in that setting
    the two notions coincide, giving rise to the theorem `Nat.Prime.dvd_mul`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在自然数中，一个素数具有这样的性质：它不能被写成非平凡因子的乘积。在更广泛的数学背景下，具有这种性质的环中的元素被称为*不可约的*。如果一个元素除以一个乘积时，它能够除以其中一个因子，则称该元素为*素数*。自然数的一个重要性质是，在这种设置下，这两个概念是一致的，从而产生了定理`Nat.Prime.dvd_mul`。
- en: 'We can use this fact to establish a key property in the argument above: if
    the square of a number is even, then that number is even as well. Mathlib defines
    the predicate `Even` in `Algebra.Group.Even`, but for reasons that will become
    clear below, we will simply use `2 ∣ m` to express that `m` is even.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个事实来建立上述论证中的一个关键性质：如果一个数的平方是偶数，那么这个数也是偶数。Mathlib在`Algebra.Group.Even`中定义谓词`Even`，但以下面的原因将变得清晰，我们将简单地使用`2
    ∣ m`来表示`m`是偶数。
- en: '[PRE116]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: As we proceed, you will need to become proficient at finding the facts you need.
    Remember that if you can guess the prefix of the name and you have imported the
    relevant library, you can use tab completion (sometimes with `ctrl-tab`) to find
    what you are looking for. You can use `ctrl-click` on any identifier to jump to
    the file where it is defined, which enables you to browse definitions and theorems
    nearby. You can also use the search engine on the [Lean community web pages](https://leanprover-community.github.io/),
    and if all else fails, don’t hesitate to ask on [Zulip](https://leanprover.zulipchat.com/).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进，你需要熟练地找到你需要的事实。记住，如果你能猜出名称的前缀并且已经导入了相关库，你可以使用制表符补全（有时需要按`ctrl-tab`）来找到你想要的内容。你可以在任何标识符上按`ctrl-click`跳转到其定义的文件，这使你能够浏览附近的定义和定理。你还可以使用[Lean社区网页](https://leanprover-community.github.io/)上的搜索引擎，如果所有其他方法都失败了，不要犹豫，在[Zulip](https://leanprover.zulipchat.com/)上提问。
- en: '[PRE117]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The heart of our proof of the irrationality of the square root of two is contained
    in the following theorem. See if you can fill out the proof sketch, using `even_of_even_sqr`
    and the theorem `Nat.dvd_gcd`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们证明 2 的平方根是无理数的核心包含在以下定理中。看看你是否能完成证明草图，使用 `even_of_even_sqr` 和定理 `Nat.dvd_gcd`。
- en: '[PRE118]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: In fact, with very few changes, we can replace `2` by an arbitrary prime. Give
    it a try in the next example. At the end of the proof, you’ll need to derive a
    contradiction from `p ∣ 1`. You can use `Nat.Prime.two_le`, which says that any
    prime number is greater than or equal to two, and `Nat.le_of_dvd`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，经过非常少的修改，我们可以将 `2` 替换为任意素数。在下一个例子中尝试一下。在证明的末尾，你需要从 `p ∣ 1` 推导出矛盾。你可以使用 `Nat.Prime.two_le`，它表明任何素数都大于或等于
    2，以及 `Nat.le_of_dvd`。
- en: '[PRE119]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Let us consider another approach. Here is a quick proof that if \(p\) is prime,
    then \(m^2 \ne p n^2\): if we assume \(m^2 = p n^2\) and consider the factorization
    of \(m\) and \(n\) into primes, then \(p\) occurs an even number of times on the
    left side of the equation and an odd number of times on the right, a contradiction.
    Note that this argument requires that \(n\) and hence \(m\) are not equal to zero.
    The formalization below confirms that this assumption is sufficient.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一种方法。以下是一个快速证明：如果 \(p\) 是素数，那么 \(m^2 \ne p n^2\)：如果我们假设 \(m^2 = p n^2\)
    并考虑 \(m\) 和 \(n\) 的素数分解，那么 \(p\) 在等式左边出现偶数次，在右边出现奇数次，这是矛盾的。请注意，这个论证要求 \(n\) 以及因此
    \(m\) 不等于零。下面的形式化确认了这个假设是充分的。
- en: The unique factorization theorem says that any natural number other than zero
    can be written as the product of primes in a unique way. Mathlib contains a formal
    version of this, expressed in terms of a function `Nat.primeFactorsList`, which
    returns the list of prime factors of a number in nondecreasing order. The library
    proves that all the elements of `Nat.primeFactorsList n` are prime, that any `n`
    greater than zero is equal to the product of its factors, and that if `n` is equal
    to the product of another list of prime numbers, then that list is a permutation
    of `Nat.primeFactorsList n`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一分解定理表明，除了零以外的任何自然数都可以以唯一的方式写成素数的乘积。Mathlib 包含了这个定理的正式版本，它用函数 `Nat.primeFactorsList`
    来表达，该函数返回一个数在非递减顺序中的素数因子列表。库证明了 `Nat.primeFactorsList n` 的所有元素都是素数，任何大于零的 `n`
    都等于其因子的乘积，并且如果 `n` 等于另一个素数列表的乘积，那么该列表是 `Nat.primeFactorsList n` 的一个排列。
- en: '[PRE120]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: You can browse these theorems and others nearby, even though we have not talked
    about list membership, products, or permutations yet. We won’t need any of that
    for the task at hand. We will instead use the fact that Mathlib has a function
    `Nat.factorization`, that represents the same data as a function. Specifically,
    `Nat.factorization n p`, which we can also write `n.factorization p`, returns
    the multiplicity of `p` in the prime factorization of `n`. We will use the following
    three facts.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们还没有讨论列表成员、乘积或排列，你仍然可以浏览这些定理以及其他附近的定理。对于当前的任务，我们不需要任何这些。我们将使用 Mathlib 有一个函数
    `Nat.factorization` 的事实，它代表与函数相同的数据。具体来说，`Nat.factorization n p`，我们也可以写成 `n.factorization
    p`，返回 `p` 在 `n` 的素数分解中的次数。我们将使用以下三个事实。
- en: '[PRE121]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: In fact, `n.factorization` is defined in Lean as a function of finite support,
    which explains the strange notation you will see as you step through the proofs
    above. Don’t worry about this now. For our purposes here, we can use the three
    theorems above as a black box.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`n.factorization` 在 Lean 中被定义为有限支撑的函数，这解释了你将在上述证明中看到的奇怪符号。现在不用担心这个。就我们的目的而言，我们可以将上述三个定理视为黑盒使用。
- en: The next example shows that the simplifier is smart enough to replace `n^2 ≠
    0` by `n ≠ 0`. The tactic `simpa` just calls `simp` followed by `assumption`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例表明，简化器足够智能，可以将 `n^2 ≠ 0` 替换为 `n ≠ 0`。`simpa` 策略只是调用 `simp` 后跟 `assumption`。
- en: See if you can use the identities above to fill in the missing parts of the
    proof.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能使用上述恒等式来填补证明中的空白部分。
- en: '[PRE122]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: A nice thing about this proof is that it also generalizes. There is nothing
    special about `2`; with small changes, the proof shows that whenever we write
    `m^k = r * n^k`, the multiplicity of any prime `p` in `r` has to be a multiple
    of `k`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这个证明的一个好处是它也具有普遍性。关于 `2` 没有什么特别之处；经过一些小的修改，这个证明表明，每当我们将 `m^k = r * n^k` 写出来时，`r`
    中任何素数 `p` 的次数必须是 `k` 的倍数。
- en: 'To use `Nat.count_factors_mul_of_pos` with `r * n^k`, we need to know that
    `r` is positive. But when `r` is zero, the theorem below is trivial, and easily
    proved by the simplifier. So the proof is carried out in cases. The line `rcases
    r with _ | r` replaces the goal with two versions: one in which `r` is replaced
    by `0`, and the other in which `r` is replaces by `r + 1`. In the second case,
    we can use the theorem `r.succ_ne_zero`, which establishes `r + 1 ≠ 0` (`succ`
    stands for successor).'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `Nat.count_factors_mul_of_pos` 与 `r * n^k`，我们需要知道 `r` 是正数。但当 `r` 为零时，下面的定理是显而易见的，并且可以通过简化器轻松证明。因此，证明是分情况进行的。`rcases
    r with _ | r` 这一行将目标替换为两个版本：一个是将 `r` 替换为 `0` 的版本，另一个是将 `r` 替换为 `r + 1` 的版本。在第二种情况下，我们可以使用定理
    `r.succ_ne_zero`，它建立了 `r + 1 ≠ 0`（`succ` 表示后继）。
- en: 'Notice also that the line that begins `have : npow_nz` provides a short proof-term
    proof of `n^k ≠ 0`. To understand how it works, try replacing it with a tactic
    proof, and then think about how the tactics describe the proof term.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '还要注意，以 `have : npow_nz` 开头的行提供了一个简短的证明项证明 `n^k ≠ 0`。要理解它是如何工作的，试着用战术证明来替换它，然后思考战术是如何描述证明项的。'
- en: See if you can fill in the missing parts of the proof below. At the very end,
    you can use `Nat.dvd_sub'` and `Nat.dvd_mul_right` to finish it off.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能填补下面证明的空白部分。在最后，你可以使用 `Nat.dvd_sub'` 和 `Nat.dvd_mul_right` 来完成它。
- en: Note that this example does not assume that `p` is prime, but the conclusion
    is trivial when `p` is not prime since `r.factorization p` is then zero by definition,
    and the proof works in all cases anyway.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个例子并没有假设 `p` 是素数，但当 `p` 不是素数时，结论是显而易见的，因为根据定义，`r.factorization p` 将为零，而且证明在所有情况下都适用。
- en: '[PRE123]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: There are a number of ways in which we might want to improve on these results.
    To start with, a proof that the square root of two is irrational should say something
    about the square root of two, which can be understood as an element of the real
    or complex numbers. And stating that it is irrational should say something about
    the rational numbers, namely, that no rational number is equal to it. Moreover,
    we should extend the theorems in this section to the integers. Although it is
    mathematically obvious that if we could write the square root of two as a quotient
    of two integers then we could write it as a quotient of two natural numbers, proving
    this formally requires some effort.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望以多种方式改进这些结果。首先，证明2的平方根是无理数应该对2的平方根有所说明，这可以理解为实数或复数中的一个元素。并且说它是无理数应该对有理数有所说明，即没有有理数等于它。此外，我们还应该将本节中的定理扩展到整数。虽然从数学上明显，如果我们能将2的平方根写成两个整数的商，那么我们也可以将其写成两个自然数的商，但正式证明这一点需要一些努力。
- en: 'In Mathlib, the natural numbers, the integers, the rationals, the reals, and
    the complex numbers are represented by separate data types. Restricting attention
    to the separate domains is often helpful: we will see that it is easy to do induction
    on the natural numbers, and it is easiest to reason about divisibility of integers
    when the real numbers are not part of the picture. But having to mediate between
    the different domains is a headache, one we will have to contend with. We will
    return to this issue later in this chapter.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mathlib 中，自然数、整数、有理数、实数和复数由不同的数据类型表示。将注意力限制在单独的域中通常是有帮助的：我们将看到对自然数进行归纳是很容易的，而且当实数不是图景的一部分时，关于整数可除性的推理是最容易的。但需要在不同的域之间进行调解，这是一个头疼的问题，我们将不得不应对。我们将在本章的后面回到这个问题。
- en: We should also expect to be able to strengthen the conclusion of the last theorem
    to say that the number `r` is a `k`-th power, since its `k`-th root is just the
    product of each prime dividing `r` raised to its multiplicity in `r` divided by
    `k`. To be able to do that we will need better means for reasoning about products
    and sums over a finite set, which is also a topic we will return to.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该期望能够加强最后一个定理的结论，使其表明数 `r` 是一个 `k` 次幂，因为它的 `k` 次根只是每个除 `r` 的质数乘以其在 `r` 中的幂次，然后除以
    `k` 的乘积。要能够做到这一点，我们需要更好的推理手段来处理有限集上的乘积和求和，这也是我们将回到的话题。
- en: In fact, the results in this section are all established in much greater generality
    in Mathlib, in `Data.Real.Irrational`. The notion of `multiplicity` is defined
    for an arbitrary commutative monoid, and that it takes values in the extended
    natural numbers `enat`, which adds the value infinity to the natural numbers.
    In the next chapter, we will begin to develop the means to appreciate the way
    that Lean supports this sort of generality.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，本节中的结果在 Mathlib 的 `Data.Real.Irrational` 中以更大的普遍性得到确立。对于任意交换幺半群，定义了 `multiplicity`
    的概念，并且它在扩展自然数 `enat` 中取值，它将无穷大值添加到自然数中。在下一章中，我们将开始开发欣赏 Lean 支持这种普遍性的方法。
- en: '## 5.2\. Induction and Recursion[](#induction-and-recursion "Link to this
    heading")'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '## 5.2. 归纳与递归[](#induction-and-recursion "链接到本标题")'
- en: The set of natural numbers \(\mathbb{N} = \{ 0, 1, 2, \ldots \}\) is not only
    fundamentally important in its own right, but also a plays a central role in the
    construction of new mathematical objects. Lean’s foundation allows us to declare
    *inductive types*, which are types generated inductively by a given list of *constructors*.
    In Lean, the natural numbers are declared as follows.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 自然数集合 \(\mathbb{N} = \{ 0, 1, 2, \ldots \}\) 不仅在其自身的基础上具有根本重要性，而且在构建新的数学对象中也起着核心作用。Lean
    的基础允许我们声明 *归纳类型*，这些类型是通过给定的构造函数列表归纳生成的。在 Lean 中，自然数被声明如下。
- en: '[PRE124]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'You can find this in the library by writing `#check Nat` and then using `ctrl-click`
    on the identifier `Nat`. The command specifies that `Nat` is the datatype generated
    freely and inductively by the two constructors `zero : Nat` and `succ : Nat →
    Nat`. Of course, the library introduces notation `ℕ` and `0` for `nat` and `zero`
    respectively. (Numerals are translated to binary representations, but we don’t
    have to worry about the details of that now.)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以在图书馆中通过输入 `#check Nat` 然后点击 `ctrl-click` 在标识符 `Nat` 上找到它。该命令指定 `Nat` 是由两个构造函数
    `zero : Nat` 和 `succ : Nat → Nat` 自由且归纳地生成的数据类型。当然，库为 `nat` 和 `zero` 分别引入了符号 `ℕ`
    和 `0`。（数值被转换为二进制表示，但我们现在不必担心这个细节。）'
- en: What “freely” means for the working mathematician is that the type `Nat` has
    an element `zero` and an injective successor function `succ` whose image does
    not include `zero`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 对于工作的数学家来说，“自由”意味着类型 `Nat` 有一个元素 `zero` 和一个不包含 `zero` 的像的注入后继函数 `succ`。
- en: '[PRE125]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: What the word “inductively” means for the working mathematician is that the
    natural numbers comes with a principle of proof by induction and a principle of
    definition by recursion. This section will show you how to use these.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 对于工作的数学家来说，“归纳”意味着自然数带有归纳证明原理和递归定义原理。本节将向您展示如何使用这些原理。
- en: Here is an example of a recursive definition of the factorial function.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是阶乘函数的递归定义的一个例子。
- en: '[PRE126]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The syntax takes some getting used to. Notice that there is no `:=` on the first
    line. The next two lines provide the base case and inductive step for a recursive
    definition. These equations hold definitionally, but they can also be used manually
    by giving the name `fac` to `simp` or `rw`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 语法需要一些时间来习惯。请注意，第一行没有 `:=`。接下来的两行提供了递归定义的基础情况和归纳步骤。这些等式在定义上是成立的，但也可以通过将 `fac`
    命名给 `simp` 或 `rw` 来手动使用。
- en: '[PRE127]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The factorial function is actually already defined in Mathlib as `Nat.factorial`.
    Once again, you can jump to it by typing `#check Nat.factorial` and using `ctrl-click.`
    For illustrative purposes, we will continue using `fac` in the examples. The annotation
    `@[simp]` before the definition of `Nat.factorial` specifies that the defining
    equation should be added to the database of identities that the simplifier uses
    by default.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，阶乘函数已经在 Mathlib 中定义为 `Nat.factorial`。您可以通过输入 `#check Nat.factorial` 并使用
    `ctrl-click` 来跳转到它。为了说明目的，我们将在示例中继续使用 `fac`。定义 `Nat.factorial` 前的注释 `@[simp]`
    指定定义方程应该被添加到简化器默认使用的恒等式数据库中。
- en: 'The principle of induction says that we can prove a general statement about
    the natural numbers by proving that the statement holds of 0 and that whenever
    it holds of a natural number \(n\), it also holds of \(n + 1\). The line `induction''
    n with n ih` in the proof below therefore results in two goals: in the first we
    need to prove `0 < fac 0`, and in the second we have the added assumption `ih
    : 0 < fac n` and a required to prove `0 < fac (n + 1)`. The phrase `with n ih`
    serves to name the variable and the assumption for the inductive hypothesis, and
    you can choose whatever names you want for them.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '归纳原理表明，我们可以通过证明该命题对0成立，并且每当它对自然数\(n\)成立时，它也对\(n + 1\)成立，来证明关于自然数的普遍命题。因此，以下证明中的“归纳''
    n with n ih”这一行产生了两个目标：在第一个目标中，我们需要证明`0 < fac 0`，而在第二个目标中，我们有附加的假设`ih : 0 < fac
    n`和需要证明的`0 < fac (n + 1)`。短语`with n ih`用于命名归纳假设中的变量和假设，你可以为它们选择任何你想要的名称。'
- en: '[PRE128]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The `induction'` tactic is smart enough to include hypotheses that depend on
    the induction variable as part of the induction hypothesis. Step through the next
    example to see what is going on.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`induction''`策略足够智能，可以将依赖于归纳变量的假设作为归纳假设的一部分。通过下一个示例逐步查看发生了什么。'
- en: '[PRE129]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The following example provides a crude lower bound for the factorial function.
    It turns out to be easier to start with a proof by cases, so that the remainder
    of the proof starts with the case \(n = 1\). See if you can complete the argument
    with a proof by induction using `pow_succ` or `pow_succ'`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例提供了一个关于阶乘函数的粗糙下界。实际上，从证明的案例开始更容易，因此证明的其余部分从\(n = 1\)的情况开始。看看你是否可以用`pow_succ`或`pow_succ'`通过归纳证明来完成论证。
- en: '[PRE130]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Induction is often used to prove identities involving finite sums and products.
    Mathlib defines the expressions `Finset.sum s f` where `s : Finset α` is a finite
    set of elements of the type `α` and `f` is a function defined on `α`. The codomain
    of `f` can be any type that supports a commutative, associative addition operation
    with a zero element. If you import `Algebra.BigOperators.Ring` and issue the command
    `open BigOperators`, you can use the more suggestive notation `∑ x ∈ s, f x`.
    Of course, there is an analogous operation and notation for finite products.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '归纳通常用于证明涉及有限和与积的恒等式。Mathlib定义了表达式`Finset.sum s f`，其中`s : Finset α`是类型`α`的元素有限集合，`f`是在`α`上定义的函数。`f`的陪域可以是支持具有零元素的交换、结合加法运算的任何类型。如果你导入`Algebra.BigOperators.Ring`并发出`open
    BigOperators`命令，你可以使用更具说明性的符号`∑ x ∈ s, f x`。当然，也存在类似的操作和符号用于有限积。'
- en: We will talk about the `Finset` type and the operations it supports in the next
    section, and again in a later chapter. For now, we will only make use of `Finset.range
    n`, which is the finite set of natural numbers less than `n`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中讨论`Finset`类型及其支持的运算，并在稍后的章节中再次讨论。现在，我们只会使用`Finset.range n`，这是小于`n`的自然数的有限集合。
- en: '[PRE131]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The facts `Finset.sum_range_zero` and `Finset.sum_range_succ` provide a recursive
    description of summation up to \(n\), and similarly for products.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 事实`Finset.sum_range_zero`和`Finset.sum_range_succ`提供了对\(n\)求和的递归描述，同样也适用于积。
- en: '[PRE132]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The first identity in each pair holds definitionally, which is to say, you can
    replace the proofs by `rfl`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 每一对中的第一个恒等式是定义上成立的，也就是说，你可以用`rfl`替换证明。
- en: The following expresses the factorial function that we defined as a product.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表示我们定义的阶乘函数，作为一个乘积。
- en: '[PRE133]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: The fact that we include `mul_comm` as a simplification rule deserves comment.
    It should seem dangerous to simplify with the identity `x * y = y * x`, which
    would ordinarily loop indefinitely. Lean’s simplifier is smart enough to recognize
    that, and applies the rule only in the case where the resulting term has a smaller
    value in some fixed but arbitrary ordering of the terms. The following example
    shows that simplifying using the three rules `mul_assoc`, `mul_comm`, and `mul_left_comm`
    manages to identify products that are the same up to the placement of parentheses
    and ordering of variables.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`mul_comm`作为简化规则包括在内的事实值得注意。使用恒等式`x * y = y * x`进行简化似乎很危险，因为这通常会无限循环。Lean的简化器足够智能，能够识别这一点，并且仅在结果项在某种固定但任意的项的排序中具有更小值的情况下应用该规则。以下示例表明，使用`mul_assoc`、`mul_comm`和`mul_left_comm`这三个规则进行简化，可以成功地识别出相同但括号位置和变量排序不同的乘积。
- en: '[PRE134]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Roughly, the rules work by pushing parentheses to the right and then re-ordering
    the expressions on both sides until they both follow the same canonical order.
    Simplifying with these rules, and the corresponding rules for addition, is a handy
    trick.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 大概来说，规则是通过将括号推向右边，然后重新排列两边的表达式，直到它们都遵循相同的规范顺序。使用这些规则和相应的加法规则进行简化是一个实用的技巧。
- en: Returning to summation identities, we suggest stepping through the following
    proof that the sum of the natural numbers up to and including \(n\) is \(n (n
    + 1) / 2\). The first step of the proof clears the denominator. This is generally
    useful when formalizing identities, because calculations with division generally
    have side conditions. (It is similarly useful to avoid using subtraction on the
    natural numbers when possible.)
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到求和恒等式，我们建议逐步通过以下证明，即自然数从1加到\(n\)的和是\(n (n + 1) / 2\)。证明的第一步消除了分母。这在形式化恒等式时通常很有用，因为除法运算通常有副作用条件。（同样，在可能的情况下避免在自然数上使用减法也是有用的。）
- en: '[PRE135]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: We encourage you to prove the analogous identity for sums of squares, and other
    identities you can find on the web.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励你证明平方和的类似恒等式，以及你在网上能找到的其他恒等式。
- en: '[PRE136]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: In Lean’s core library, addition and multiplication are themselves defined using
    recursive definitions, and their fundamental properties are established using
    induction. If you like thinking about foundational topics like that, you might
    enjoy working through proofs of the commutativity and associativity of multiplication
    and addition and the distributivity of multiplication over addition. You can do
    this on a copy of the natural numbers following the outline below. Notice that
    we can use the `induction` tactic with `MyNat`; Lean is smart enough to know to
    use the relevant induction principle (which is, of course, the same as that for
    `Nat`).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lean的核心库中，加法和乘法本身是通过递归定义的，它们的基本性质是通过归纳法建立的。如果你喜欢思考像那样的基础主题，你可能会喜欢通过乘法和加法的交换律、结合律以及乘法对加法的分配律的证明来工作。你可以在以下概述的自然数副本上这样做。注意，我们可以使用`induction`策略与`MyNat`一起使用；Lean足够智能，知道要使用相关的归纳原理（当然，这与`Nat`的相同）。
- en: We start you off with the commutativity of addition. A good rule of thumb is
    that because addition and multiplication are defined by recursion on the second
    argument, it is generally advantageous to do proofs by induction on a variable
    that occurs in that position. It is a bit tricky to decide which variable to use
    in the proof of associativity.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从加法的交换律开始。一个很好的经验法则是，由于加法和乘法是通过递归定义在第二个参数上的，因此通常在出现该位置的变量上通过归纳法进行证明是有利的。在证明结合律时决定使用哪个变量有点棘手。
- en: It can be confusing to write things without the usual notation for zero, one,
    addition, and multiplication. We will learn how to define such notation later.
    Working in the namespace `MyNat` means that we can write `zero` and `succ` rather
    than `MyNat.zero` and `MyNat.succ`, and that these interpretations of the names
    take precedence over others. Outside the namespace, the full name of the `add`
    defined below, for example, is `MyNat.add`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用零、一、加法和乘法的常规符号来写东西可能会让人困惑。我们将在后面学习如何定义这样的符号。在命名空间`MyNat`中工作意味着我们可以写`zero`和`succ`而不是`MyNat.zero`和`MyNat.succ`，并且这些名称的解释优先于其他解释。在命名空间外部，下面定义的`add`的全名是`MyNat.add`。
- en: If you find that you *really* enjoy this sort of thing, try defining truncated
    subtraction and exponentiation and proving some of their properties as well. Remember
    that truncated subtraction cuts off at zero. To define that, it is useful to define
    a predecessor function, `pred`, that subtracts one from any nonzero number and
    fixes zero. The function `pred` can be defined by a simple instance of recursion.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现你真的喜欢这类东西，尝试定义截断减法和指数运算，并证明它们的一些性质。记住，截断减法在零处截断。为了定义这一点，定义一个前驱函数`pred`，它从任何非零数中减去一，并固定零。函数`pred`可以通过一个简单的递归实例来定义。
- en: '[PRE137]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '## 5.3\. Infinitely Many Primes[](#infinitely-many-primes "Link to this heading")'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '## 5.3. 无穷多个素数[](#infinitely-many-primes "链接到本标题")'
- en: 'Let us continue our exploration of induction and recursion with another mathematical
    standard: a proof that there are infinitely many primes. One way to formulate
    this is as the statement that for every natural number \(n\), there is a prime
    number greater than \(n\). To prove this, let \(p\) be any prime factor of \(n!
    + 1\). If \(p\) is less than or equal to \(n\), it divides \(n!\). Since it also
    divides \(n! + 1\), it divides 1, a contradiction. Hence \(p\) is greater than
    \(n\).'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续用另一个数学标准来探索归纳和递归：证明存在无限多个质数。一种表述方式是，对于每一个自然数 \(n\)，都存在一个大于 \(n\) 的质数。为了证明这一点，设
    \(p\) 是 \(n! + 1\) 的任意一个质因数。如果 \(p\) 小于或等于 \(n\)，它就会整除 \(n!\)。由于它也整除 \(n! + 1\)，它就会整除
    1，这产生了矛盾。因此 \(p\) 必须大于 \(n\)。
- en: 'To formalize that proof, we need to show that any number greater than or equal
    to 2 has a prime factor. To do that, we will need to show that any natural number
    that is not equal to 0 or 1 is greater-than or equal to 2. And this brings us
    to a quirky feature of formalization: it is often trivial statements like this
    that are among the most annoying to formalize. Here we consider a few ways to
    do it.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 为了形式化这个证明，我们需要证明任何大于或等于 2 的数都有一个质因数。要做到这一点，我们需要证明任何不等于 0 或 1 的自然数都大于或等于 2。这引出了形式化中的一个奇特特性：通常像这样的简单陈述是最令人烦恼的。在这里，我们考虑了几种实现方法。
- en: To start with, we can use the `cases` tactic and the fact that the successor
    function respects the ordering on the natural numbers.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以使用 `cases` 策略和后继函数尊重自然数上的顺序这一事实。
- en: '[PRE138]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Another strategy is to use the tactic `interval_cases`, which automatically
    splits the goal into cases when the variable in question is contained in an interval
    of natural numbers or integers. Remember that you can hover over it to see its
    documentation.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种策略是使用 `interval_cases` 策略，它会自动将目标分解为当变量包含在自然数或整数的区间内时的各种情况。记住，你可以悬停在它上面来查看其文档。
- en: '[PRE139]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Recall that the semicolon after `interval_cases m` means that the next tactic
    is applied to each of the cases that it generates. Yet another option is to use
    the tactic `decide`, which tries to find a decision procedure to solve the problem.
    Lean knows that you can decide the truth value of a statement that begins with
    a bounded quantifier `∀ x, x < n → ...` or `∃ x, x < n ∧ ...` by deciding each
    of the finitely many instances.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`interval_cases m` 后面的分号意味着下一个策略会被应用到它生成的每一个情况中。另一个选择是使用 `decide` 策略，它试图找到一个决策过程来解决问题。Lean
    知道你可以通过决定每个有限实例来决定以有界量词 `∀ x, x < n → ...` 或 `∃ x, x < n ∧ ...` 开头的语句的真值。
- en: '[PRE140]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: With the theorem `two_le` in hand, let’s start by showing that every natural
    number greater than two has a prime divisor. Mathlib contains a function `Nat.minFac`
    that returns the smallest prime divisor, but for the sake of learning new parts
    of the library, we’ll avoid using it and prove the theorem directly.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在手头有 `two_le` 定理的情况下，让我们首先证明每个大于两的自然数都有一个质数因子。Mathlib 包含一个函数 `Nat.minFac`，它返回最小的质数因子，但为了学习库的新部分，我们将避免使用它，并直接证明这个定理。
- en: Here, ordinary induction isn’t enough. We want to use *strong induction*, which
    allows us to prove that every natural number \(n\) has a property \(P\) by showing
    that for every number \(n\), if \(P\) holds of all values less than \(n\), it
    holds at \(n\) as well. In Lean, this principle is called `Nat.strong_induction_on`,
    and we can use the `using` keyword to tell the induction tactic to use it. Notice
    that when we do that, there is no base case; it is subsumed by the general induction
    step.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，普通的归纳不足以。我们想要使用 *强归纳*，它允许我们通过证明对于每个数 \(n\)，如果 \(P\) 对所有小于 \(n\) 的值成立，那么它对
    \(n\) 也成立，来证明每个自然数 \(n\) 都有一个性质 \(P\)。在 Lean 中，这个原则被称为 `Nat.strong_induction_on`，我们可以使用
    `using` 关键字告诉归纳策略使用它。注意，当我们这样做时，没有基础情况；它被归纳步骤所包含。
- en: The argument is simply as follows. Assuming \(n ≥ 2\), if \(n\) is prime, we’re
    done. If it isn’t, then by one of the characterizations of what it means to be
    a prime number, it has a nontrivial factor, \(m\), and we can apply the inductive
    hypothesis to that. Step through the next proof to see how that plays out.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 论证如下。假设 \(n ≥ 2\)，如果 \(n\) 是质数，那么我们就完成了。如果不是，那么根据质数的定义之一，它有一个非平凡因子 \(m\)，我们可以对它应用归纳假设。通过查看下一个证明，我们可以看到这是如何实现的。
- en: '[PRE141]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: We can now prove the following formulation of our theorem. See if you can fill
    out the sketch. You can use `Nat.factorial_pos`, `Nat.dvd_factorial`, and `Nat.dvd_sub'`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以证明我们定理的以下表述。看看你是否能够完成草图。你可以使用 `Nat.factorial_pos`、`Nat.dvd_factorial`
    和 `Nat.dvd_sub'`。
- en: '[PRE142]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Let’s consider a variation of the proof above, where instead of using the factorial
    function, we suppose that we are given by a finite set \(\{ p_1, \ldots, p_n \}\)
    and we consider a prime factor of \(\prod_{i = 1}^n p_i + 1\). That prime factor
    has to be distinct from each \(p_i\), showing that there is no finite set that
    contains all the prime numbers.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑上述证明的一个变体，其中我们不是使用阶乘函数，而是假设我们被赋予一个有限集 \(\{ p_1, \ldots, p_n \}\)，并考虑 \(\prod_{i
    = 1}^n p_i + 1\) 的一个素数因子。这个素数因子必须与每个 \(p_i\) 不同，这表明不存在包含所有素数的有限集。
- en: Formalizing this argument requires us to reason about finite sets. In Lean,
    for any type `α`, the type `Finset α` represents finite sets of elements of type
    `α`. Reasoning about finite sets computationally requires having a procedure to
    test equality on `α`, which is why the snippet below includes the assumption `[DecidableEq
    α]`. For concrete data types like `ℕ`, `ℤ`, and `ℚ`, the assumption is satisfied
    automatically. When reasoning about the real numbers, it can be satisfied using
    classical logic and abandoning the computational interpretation.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个论证形式化需要我们对有限集进行推理。在 Lean 中，对于任何类型 `α`，类型 `Finset α` 表示类型 `α` 的元素构成的有限集。对有限集进行计算推理需要有一个在
    `α` 上测试等价的程序，这就是为什么下面的代码片段包括了假设 `[DecidableEq α]`。对于像 `ℕ`、`ℤ` 和 `ℚ` 这样的具体数据类型，这个假设会自动满足。当推理实数时，可以使用经典逻辑并放弃计算解释来满足这个假设。
- en: We use the command `open Finset` to avail ourselves of shorter names for the
    relevant theorems. Unlike the case with sets, most equivalences involving finsets
    do not hold definitionally, so they need to be expanded manually using equivalences
    like `Finset.subset_iff`, `Finset.mem_union`, `Finset.mem_inter`, and `Finset.mem_sdiff`.
    The `ext` tactic can still be used to show that two finite sets are equal by showing
    that every element of one is an element of the other.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用命令 `open Finset` 来使用相关定理的简短名称。与集合的情况不同，涉及有限集的多数等价关系在定义上并不成立，因此需要手动使用等价关系如
    `Finset.subset_iff`、`Finset.mem_union`、`Finset.mem_inter` 和 `Finset.mem_sdiff`
    来扩展。`ext` 策略仍然可以用来通过显示一个有限集的每个元素都是另一个集合的元素来证明两个有限集相等。
- en: '[PRE143]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'We have used a new trick: the `tauto` tactic (and a strengthened version, `tauto!`,
    which uses classical logic) can be used to dispense with propositional tautologies.
    See if you can use these methods to prove the two examples below.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个新技巧：`tauto` 策略（以及一个增强版本 `tauto!`，它使用经典逻辑）可以用来处理命题恒真。看看你是否可以使用这些方法来证明下面的两个例子。
- en: '[PRE144]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: The theorem `Finset.dvd_prod_of_mem` tells us that if an `n` is an element of
    a finite set `s`, then `n` divides `∏ i ∈ s, i`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 `Finset.dvd_prod_of_mem` 告诉我们，如果 `n` 是有限集 `s` 的一个元素，那么 `n` 可以整除 `∏ i ∈ s,
    i`。
- en: '[PRE145]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: We also need to know that the converse holds in the case where `n` is prime
    and `s` is a set of primes. To show that, we need the following lemma, which you
    should be able to prove using the theorem `Nat.Prime.eq_one_or_self_of_dvd`.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要知道，当 `n` 是素数且 `s` 是素数集合时，逆命题也成立。为了证明这一点，我们需要以下引理，你应该能够使用定理 `Nat.Prime.eq_one_or_self_of_dvd`
    来证明。
- en: '[PRE146]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'We can use this lemma to show that if a prime `p` divides a product of a finite
    set of primes, then it is equal to one of them. Mathlib provides a useful principle
    of induction on finite sets: to show that a property holds of an arbitrary finite
    set `s`, show that it holds of the empty set, and show that it is preserved when
    we add a single new element `a ∉ s`. The principle is known as `Finset.induction_on`.
    When we tell the induction tactic to use it, we can also specify the names `a`
    and `s`, the name for the assumption `a ∉ s` in the inductive step, and the name
    of the inductive hypothesis. The expression `Finset.insert a s` denotes the union
    of `s` with the singleton `a`. The identities `Finset.prod_empty` and `Finset.prod_insert`
    then provide the relevant rewrite rules for the product. In the proof below, the
    first `simp` applies `Finset.prod_empty`. Step through the beginning of the proof
    to see the induction unfold, and then finish it off.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个引理来证明如果一个素数 `p` 整除有限个素数的乘积，那么它等于其中的一个。Mathlib 提供了一个有用的有限集归纳原理：为了证明一个性质对任意有限集
    `s` 成立，需要证明它对空集成立，并且当我们在其中添加一个新元素 `a ∉ s` 时，它仍然成立。这个原理被称为 `Finset.induction_on`。当我们告诉归纳策略使用它时，我们还可以指定
    `a` 和 `s` 的名称，以及在归纳步骤中的假设 `a ∉ s` 的名称，以及归纳假设的名称。表达式 `Finset.insert a s` 表示 `s`
    与单元素集合 `a` 的并集。`Finset.prod_empty` 和 `Finset.prod_insert` 然后提供了与乘积相关的重写规则。在下面的证明中，第一个
    `simp` 应用了 `Finset.prod_empty`。逐步查看证明的开始部分以查看归纳展开，然后完成它。
- en: '[PRE147]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'We need one last property of finite sets. Given an element `s : Set α` and
    a predicate `P` on `α`, in [Chapter 4](C04_Sets_and_Functions.html#sets-and-functions)
    we wrote `{ x ∈ s | P x }` for the set of elements of `s` that satisfy `P`. Given
    `s : Finset α`, the analogous notion is written `s.filter P`.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '我们需要有限集的一个最后属性。给定一个元素 `s : Set α` 和一个在 `α` 上的谓词 `P`，在 [第 4 章](C04_Sets_and_Functions.html#sets-and-functions)
    中，我们用 `{ x ∈ s | P x }` 表示满足 `P` 的 `s` 的元素集合。给定 `s : Finset α`，类似的概念表示为 `s.filter
    P`。'
- en: '[PRE148]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'We now prove an alternative formulation of the statement that there are infinitely
    many primes, namely, that given any `s : Finset ℕ`, there is a prime `p` that
    is not an element of `s`. Aiming for a contradiction, we assume that all the primes
    are in `s`, and then cut down to a set `s''` that contains all and only the primes.
    Taking the product of that set, adding one, and finding a prime factor of the
    result leads to the contradiction we are looking for. See if you can complete
    the sketch below. You can use `Finset.prod_pos` in the proof of the first `have`.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们证明关于存在无限多个素数的另一种表述，即给定任何 `s : Finset ℕ`，存在一个素数 `p`，它不是 `s` 的元素。为了达到矛盾，我们假设所有素数都在
    `s` 中，然后削减到一个只包含所有素数的集合 `s''`。取该集合的乘积，加一，并找到结果的一个素数因子，导致我们寻找的矛盾。看看你是否能完成下面的草图。你可以在第一个
    `have` 的证明中使用 `Finset.prod_pos`。'
- en: '[PRE149]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'We have thus seen two ways of saying that there are infinitely many primes:
    saying that they are not bounded by any `n`, and saying that they are not contained
    in any finite set `s`. The two proofs below show that these formulations are equivalent.
    In the second, in order to form `s.filter Q`, we have to assume that there is
    a procedure for deciding whether or not `Q` holds. Lean knows that there is a
    procedure for `Nat.Prime`. In general, if we use classical logic by writing `open
    Classical`, we can dispense with the assumption.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了两种表达存在无限多个素数的方法：说它们不被任何 `n` 所界定，以及说它们不包含在任何有限集 `s` 中。下面的两个证明表明这些表述是等价的。在第二个证明中，为了形成
    `s.filter Q`，我们必须假设存在一个判断 `Q` 是否成立的程序。Lean 知道存在一个用于 `Nat.Prime` 的程序。一般来说，如果我们通过编写
    `open Classical` 使用经典逻辑，我们可以省去这个假设。
- en: In Mathlib, `Finset.sup s f` denotes the supremum of the values of `f x` as
    `x` ranges over `s`, returning `0` in the case where `s` is empty and the codomain
    of `f` is `ℕ`. In the first proof, we use `s.sup id`, where `id` is the identity
    function, to refer to the maximum value in `s`.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mathlib 中，`Finset.sup s f` 表示 `f x` 的值在 `x` 在 `s` 上取值时的上确界，当 `s` 为空且 `f` 的陪域为
    `ℕ` 时返回 `0`。在第一个证明中，我们使用 `s.sup id`，其中 `id` 是恒等函数，来指代 `s` 中的最大值。
- en: '[PRE150]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: A small variation on our second proof that there are infinitely many primes
    shows that there are infinitely many primes congruent to 3 modulo 4. The argument
    goes as follows. First, notice that if the product of two numbers \(m\) and \(n\)
    is equal to 3 modulo 4, then one of the two numbers is congruent to 3 modulo 4.
    After all, both have to be odd, and if they are both congruent to 1 modulo 4,
    so is their product. We can use this observation to show that if some number greater
    than 2 is congruent to 3 modulo 4, then that number has a prime divisor that is
    also congruent to 3 modulo 4.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第二个证明中，即存在无限多个素数，有一个小的变化表明存在无限多个与 4 模 3 同余的素数。论证如下。首先，注意如果两个数 \(m\) 和 \(n\)
    的乘积等于 4 模 3，那么这两个数中有一个与 4 模 3 同余。毕竟，它们都必须是奇数，如果它们都等于 4 模 3 的 1，那么它们的乘积也是。我们可以利用这个观察结果来证明如果一个大于
    2 的数与 4 模 3 同余，那么这个数有一个与 4 模 3 同余的素数因子。
- en: Now suppose there are only finitely many prime numbers congruent to 3 modulo
    4, say, \(p_1, \ldots, p_k\). Without loss of generality, we can assume that \(p_1
    = 3\). Consider the product \(4 \prod_{i = 2}^k p_i + 3\). It is easy to see that
    this is congruent to 3 modulo 4, so it has a prime factor \(p\) congruent to 3
    modulo 4. It can’t be the case that \(p = 3\); since \(p\) divides \(4 \prod_{i
    = 2}^k p_i + 3\), if \(p\) were equal to 3 then it would also divide \(\prod_{i
    = 2}^k p_i\), which implies that \(p\) is equal to one of the \(p_i\) for \(i
    = 2, \ldots, k\); and we have excluded 3 from this list. So \(p\) has to be one
    of the other elements \(p_i\). But in that case, \(p\) divides \(4 \prod_{i =
    2}^k p_i\) and hence 3, which contradicts the fact that it is not 3.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设只有有限多个与 4 模 3 同余的素数，比如说，\(p_1, \ldots, p_k\)。不失一般性，我们可以假设 \(p_1 = 3\)。考虑乘积
    \(4 \prod_{i = 2}^k p_i + 3\)。很容易看出这个数与 4 模 3 同余，所以它有一个与 4 模 3 同余的素数因子 \(p\)。不可能
    \(p = 3\)；因为 \(p\) 整除 \(4 \prod_{i = 2}^k p_i + 3\)，如果 \(p\) 等于 3，那么它也会整除 \(\prod_{i
    = 2}^k p_i\)，这意味着 \(p\) 等于 \(p_i\) 中的一个，对于 \(i = 2, \ldots, k\)；但我们已经排除了 3。所以
    \(p\) 必须是其他元素 \(p_i\) 中的一个。但在那种情况下，\(p\) 整除 \(4 \prod_{i = 2}^k p_i\) 和 3，这与它不是
    3 的事实相矛盾。
- en: In Lean, the notation `n % m`, read “`n` modulo `m`,” denotes the remainder
    of the division of `n` by `m`.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在精益（Lean）中，表示法 `n % m`，读作“`n` 模 `m`”，表示 `n` 除以 `m` 的余数。
- en: '[PRE151]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: We can then render the statement “`n` is congruent to 3 modulo 4” as `n % 4
    = 3`. The following example and theorems sum up the facts about this function
    that we will need to use below. The first named theorem is another illustration
    of reasoning by a small number of cases. In the second named theorem, remember
    that the semicolon means that the subsequent tactic block is applied to all the
    goals created by the preceding tactic.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将陈述“`n` 与 4 模 3 同余”表示为 `n % 4 = 3`。以下示例和定理总结了我们将需要使用的事实。第一个命名的定理是通过对少数几个情况进行推理的另一个例子。在第二个命名的定理中，记住分号意味着后续的策略块应用于由前面的策略块创建的所有目标。
- en: '[PRE152]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: We will also need the following fact, which says that if `m` is a nontrivial
    divisor of `n`, then so is `n / m`. See if you can complete the proof using `Nat.div_dvd_of_dvd`
    and `Nat.div_lt_self`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要以下事实，即如果 `m` 是 `n` 的非平凡因子，那么 `n / m` 也是。看看你是否可以使用 `Nat.div_dvd_of_dvd`
    和 `Nat.div_lt_self` 来完成证明。
- en: '[PRE153]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Now put all the pieces together to prove that any number congruent to 3 modulo
    4 has a prime divisor with that same property.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将所有这些部分组合起来，证明任何与 4 模 3 同余的数都有一个具有相同性质的素数因子。
- en: '[PRE154]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: We are in the home stretch. Given a set `s` of prime numbers, we need to talk
    about the result of removing 3 from that set, if it is present. The function `Finset.erase`
    handles that.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经接近终点。给定一个素数集合 `s`，如果其中包含 3，我们需要讨论从该集合中移除 3 的结果。函数 `Finset.erase` 处理这个问题。
- en: '[PRE155]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: We are now ready to prove that there are infinitely many primes congruent to
    3 modulo 4. Fill in the missing parts below. Our solution uses `Nat.dvd_add_iff_left`
    and `Nat.dvd_sub'` along the way.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备证明存在无限多个与 4 模 3 同余的素数。在下面填入缺失的部分。我们的解决方案在过程中使用了 `Nat.dvd_add_iff_left`
    和 `Nat.dvd_sub'`。
- en: '[PRE156]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: If you managed to complete the proof, congratulations! This has been a serious
    feat of formalization.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你设法完成了证明，恭喜你！这已经是一项正式化的重大成就。
- en: '## 5.4\. More Induction[](#more-induction "Link to this heading")'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '## 5.4\. 更多归纳[](#more-induction "链接到这个标题")'
- en: In [Section 5.2](#section-induction-and-recursion), we saw how to define the
    factorial function by recursion on the natural numbers.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 5.2 节](#section-induction-and-recursion) 中，我们看到了如何通过自然数的递归来定义阶乘函数。
- en: '[PRE157]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: We also saw how to prove theorems using the `induction'` tactic.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何使用 `induction'` 策略来证明定理。
- en: '[PRE158]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: The `induction` tactic (without the prime tick mark) allows for more structured
    syntax.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`induction` 策略（不带撇号）允许更结构化的语法。'
- en: '[PRE159]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: As usual, you can hover over the `induction` keyword to read the documentation.
    The names of the cases, `zero` and `succ`, are taken from the definition of the
    type ℕ. Notice that the `succ` case allows you to choose whatever names you want
    for the induction variable and the inductive hypothesis, here `n` and `ih`. You
    can even prove a theorem with the same notation used to define a recursive function.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，你可以悬停在 `induction` 关键字上以阅读文档。`zero` 和 `succ` 这两个案例的名称来自类型 ℕ 的定义。请注意，`succ`
    案例允许你为归纳变量和归纳假设选择任何你想要的名称，这里分别是 `n` 和 `ih`。你甚至可以使用定义递归函数的相同符号来证明一个定理。
- en: '[PRE160]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Notice also the absence of the `:=`, the `∀ n` after the colon, the `by` keyword
    in each case, and the inductive appeal to `fac_pos' n`. It is as though the theorem
    is a recursive function of `n` and in the inductive step we make a recursive call.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到缺少了 `:=`，冒号后面的 `∀ n`，每个案例中的 `by` 关键字，以及归纳调用 `fac_pos' n`。这就像定理是 `n` 的递归函数，在归纳步骤中我们进行递归调用。
- en: This style of definition is remarkably flexible. Lean’s designers have built
    in elaborate means of defining recursive functions, and these extend to doing
    proofs by induction. For example, we can define the Fibonacci function with multiple
    base cases.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这种定义风格非常灵活。Lean 的设计者内置了定义递归函数的复杂手段，这些手段也扩展到了归纳证明。例如，我们可以定义具有多个基准情况的斐波那契函数。
- en: '[PRE161]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: The `@[simp]` annotation means that the simplifier will use the defining equations.
    You can also apply them by writing `rw [fib]`. Below it will be helpful to give
    a name to the `n + 2` case.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`@[simp]` 注解意味着简化器将使用定义方程。你也可以通过编写 `rw [fib]` 来应用它们。下面将有助于为 `n + 2` 情况命名。'
- en: '[PRE162]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Using Lean’s notation for recursive functions, you can carry out proofs by induction
    on the natural numbers that mirror the recursive definition of `fib`. The following
    example provides an explicit formula for the nth Fibonacci number in terms of
    the golden mean, `φ`, and its conjugate, `φ'`. We have to tell Lean that we don’t
    expect our definitions to generate code because the arithmetic operations on the
    real numbers are not computable.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Lean 的递归函数表示法，你可以通过自然数上的归纳法进行证明，这些证明与 `fib` 的递归定义相呼应。以下示例提供了一个关于第 n 个斐波那契数的显式公式，该公式以黄金分割数
    `φ` 及其共轭 `φ'` 为基础。我们必须告诉 Lean，我们预期我们的定义不会生成代码，因为实数上的算术运算是不可计算的。
- en: '[PRE163]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Induction proofs involving the Fibonacci function do not have to be of that
    form. Below we reproduce the `Mathlib` proof that consecutive Fibonacci numbers
    are coprime.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及斐波那契函数的归纳证明不必采用那种形式。以下我们重现了 `Mathlib` 中证明连续斐波那契数互质的证明。
- en: '[PRE164]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Using Lean’s computational interpretation, we can evaluate the Fibonacci numbers.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Lean 的计算解释，我们可以评估斐波那契数列。
- en: '[PRE165]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: The straightforward implementation of `fib` is computationally inefficient.
    In fact, it runs in time exponential in its argument. (You should think about
    why.) In Lean, we can implement the following tail-recursive version, whose running
    time is linear in `n`, and prove that it computes the same function.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`fib` 的直接实现计算效率低下。实际上，它的运行时间与其参数呈指数关系。（你应该思考一下为什么。）在 Lean 中，我们可以实现以下尾递归版本，其运行时间与
    `n` 线性相关，并证明它计算的是相同的函数。'
- en: '[PRE166]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Notice the `generalizing` keyword in the proof of `fib'.aux_eq`. It serves to
    insert a `∀ m` in front of the inductive hypothesis, so that in the induction
    step, `m` can take a different value. You can step through the proof and check
    that in this case, the quantifier needs to be instantiated to `m + 1` in the inductive
    step.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 `fib'.aux_eq` 的证明中使用的 `generalizing` 关键字。它用于在归纳假设前插入 `∀ m`，这样在归纳步骤中，`m`
    可以取不同的值。你可以逐步通过证明并检查在这种情况下，量词需要在归纳步骤中实例化为 `m + 1`。
- en: Notice also the use of `erw` (for “extended rewrite”) instead of `rw`. This
    is used because to rewrite the goal `fib'.aux_eq`, `fib 0` and `fib 1` have to
    be reduced to `0` and `1`, respectively. The tactic `erw` is more aggressive than
    `rw` in unfolding definitions to match parameters. This isn’t always a good idea;
    it can waste a lot of time in some cases, so use `erw` sparingly.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 注意也使用了 `erw`（表示“扩展重写”）而不是 `rw`。这是因为为了重写目标 `fib'.aux_eq`，`fib 0` 和 `fib 1` 必须分别简化为
    `0` 和 `1`。`erw` 策略在展开定义以匹配参数方面比 `rw` 更激进。这并不总是好主意；在某些情况下，它可能会浪费大量时间，因此请谨慎使用 `erw`。
- en: Here is another example of the `generalizing` keyword in use, in the proof of
    another identity that is found in `Mathlib`. An informal proof of the identity
    can be found [here](https://proofwiki.org/wiki/Fibonacci_Number_in_terms_of_Smaller_Fibonacci_Numbers).
    We provide two variants of the formal proof.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `generalizing` 关键字在 `Mathlib` 中另一个恒等式证明中使用的另一个例子。该恒等式的不正式证明可以在[这里](https://proofwiki.org/wiki/Fibonacci_Number_in_terms_of_Smaller_Fibonacci_Numbers)找到。我们提供了两种正式证明的变体。
- en: '[PRE167]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: As an exercise, use `fib_add` to prove the following.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，使用 `fib_add` 证明以下内容。
- en: '[PRE168]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Lean’s mechanisms for defining recursive functions are flexible enough to allow
    arbitrary recursive calls, as long the complexity of the arguments decrease according
    to some well-founded measure. In the next example, we show that every natural
    number `n ≠ 1` has a prime divisor, using the fact that if `n` is nonzero and
    not prime, it has a smaller divisor. (You can check that Mathlib has a theorem
    of the same name in the `Nat` namespace, though it has a different proof than
    the one we give here.)
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 定义递归函数的机制足够灵活，允许任意递归调用，只要参数的复杂度根据某种已建立的度量减少。在下一个例子中，我们展示了每个自然数 `n ≠ 1`
    都有一个素数因子，利用了以下事实：如果 `n` 非零且不是素数，它有一个更小的因子。（你可以检查 Mathlib 在 `Nat` 命名空间中有一个同名定理，尽管它的证明与这里给出的不同。）
- en: '[PRE169]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'The line `rw [ne_one_iff_exists_prime_dvd] at this` is like a magic trick:
    we are using the very theorem we are proving in its own proof. What makes it work
    is that the inductive call is instantiated at `m`, the current case is `n + 2`,
    and the context has `m < n + 2`. Lean can find the hypothesis and use it to show
    that the induction is well-founded. Lean is pretty good at figuring out what is
    decreasing; in this case, the choice of `n` in the statement of the theorem and
    the less-than relation is obvious. In more complicated cases, Lean provides mechanisms
    to provide this information explicitly. See the section on [well-founded recursion](https://lean-lang.org/doc/reference/latest//Definitions/Recursive-Definitions/#well-founded-recursion)
    in the Lean Reference Manual.'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这行 `rw [ne_one_iff_exists_prime_dvd] at this` 就像是一个魔术：我们正在使用我们正在证明的定理在其自己的证明中。使其工作的是归纳调用在
    `m` 上实例化，当前情况是 `n + 2`，并且上下文有 `m < n + 2`。Lean 可以找到假设并使用它来证明归纳是良基的。Lean 在确定什么是递减方面相当擅长；在这种情况下，定理陈述中的
    `n` 选择和小于关系是显然的。在更复杂的情况下，Lean 提供了提供此信息的机制。请参阅 Lean 参考手册中关于[良基递归](https://lean-lang.org/doc/reference/latest//Definitions/Recursive-Definitions/#well-founded-recursion)的部分。
- en: Sometimes, in a proof, you need to split on cases depending on whether a natural
    number `n` is zero or a successor, without requiring an inductive hypothesis in
    the successor case. For that, you can use the `cases` and `rcases` tactics.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在证明中，你需要根据自然数 `n` 是否为零或后继来分情况讨论，在后继情况下不需要归纳假设。为此，你可以使用 `cases` 和 `rcases`
    策略。
- en: '[PRE170]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: This is a useful trick. Often you have a theorem about a natural number `n`
    for which the zero case is easy. If you case on `n` and take care of the zero
    case quickly, you are left with the original goal with `n` replaced by `n + 1`.*
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的技巧。通常，你有一个关于自然数 `n` 的定理，其中零的情况很容易处理。如果你对 `n` 进行情况分析并快速处理零的情况，你将剩下原始目标，只是将
    `n` 替换为 `n + 1`*。
