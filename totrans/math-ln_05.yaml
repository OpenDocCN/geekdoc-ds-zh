- en: 5\. Elementary Number Theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://leanprover-community.github.io/mathematics_in_lean/C05_Elementary_Number_Theory.html](https://leanprover-community.github.io/mathematics_in_lean/C05_Elementary_Number_Theory.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*[Mathematics in Lean](index.html)* **   5\. Elementary Number Theory'
  prefs: []
  type: TYPE_NORMAL
- en: '[View page source](_sources/C05_Elementary_Number_Theory.rst.txt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we show you how to formalize some elementary results in number
    theory. As we deal with more substantive mathematical content, the proofs will
    get longer and more involved, building on the skills you have already mastered.
  prefs: []
  type: TYPE_NORMAL
- en: '## 5.1\. Irrational Roots[](#irrational-roots "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a fact known to the ancient Greeks, namely, that the square
    root of 2 is irrational. If we suppose otherwise, we can write \(\sqrt{2} = a
    / b\) as a fraction in lowest terms. Squaring both sides yields \(a^2 = 2 b^2\),
    which implies that \(a\) is even. If we write \(a = 2c\), then we get \(4c^2 =
    2 b^2\) and hence \(b^2 = 2 c^2\). This implies that \(b\) is also even, contradicting
    the fact that we have assumed that \(a / b\) has been reduced to lowest terms.
  prefs: []
  type: TYPE_NORMAL
- en: Saying that \(a / b\) is a fraction in lowest terms means that \(a\) and \(b\)
    do not have any factors in common, which is to say, they are *coprime*. Mathlib
    defines the predicate `Nat.Coprime m n` to be `Nat.gcd m n = 1`. Using Lean’s
    anonymous projection notation, if `s` and `t` are expressions of type `Nat`, we
    can write `s.Coprime t` instead of `Nat.Coprime s t`, and similarly for `Nat.gcd`.
    As usual, Lean will often unfold the definition of `Nat.Coprime` automatically
    when necessary, but we can also do it manually by rewriting or simplifying with
    the identifier `Nat.Coprime`. The `norm_num` tactic is smart enough to compute
    concrete values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We have already encountered the `gcd` function in [Section 2.4](C02_Basics.html#more-on-order-and-divisibility).
    There is also a version of `gcd` for the integers; we will return to a discussion
    of the relationship between different number systems below. There are even a generic
    `gcd` function and generic notions of `Prime` and `Coprime` that make sense in
    general classes of algebraic structures. We will come to understand how Lean manages
    this generality in the next chapter. In the meanwhile, in this section, we will
    restrict attention to the natural numbers.
  prefs: []
  type: TYPE_NORMAL
- en: We also need the notion of a prime number, `Nat.Prime`. The theorem `Nat.prime_def_lt`
    provides one familiar characterization, and `Nat.Prime.eq_one_or_self_of_dvd`
    provides another.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the natural numbers, a prime number has the property that it cannot be written
    as a product of nontrivial factors. In a broader mathematical context, an element
    of a ring that has this property is said to be *irreducible*. An element of a
    ring is said to be *prime* if whenever it divides a product, it divides one of
    the factors. It is an important property of the natural numbers that in that setting
    the two notions coincide, giving rise to the theorem `Nat.Prime.dvd_mul`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this fact to establish a key property in the argument above: if
    the square of a number is even, then that number is even as well. Mathlib defines
    the predicate `Even` in `Algebra.Group.Even`, but for reasons that will become
    clear below, we will simply use `2 ∣ m` to express that `m` is even.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we proceed, you will need to become proficient at finding the facts you need.
    Remember that if you can guess the prefix of the name and you have imported the
    relevant library, you can use tab completion (sometimes with `ctrl-tab`) to find
    what you are looking for. You can use `ctrl-click` on any identifier to jump to
    the file where it is defined, which enables you to browse definitions and theorems
    nearby. You can also use the search engine on the [Lean community web pages](https://leanprover-community.github.io/),
    and if all else fails, don’t hesitate to ask on [Zulip](https://leanprover.zulipchat.com/).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The heart of our proof of the irrationality of the square root of two is contained
    in the following theorem. See if you can fill out the proof sketch, using `even_of_even_sqr`
    and the theorem `Nat.dvd_gcd`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In fact, with very few changes, we can replace `2` by an arbitrary prime. Give
    it a try in the next example. At the end of the proof, you’ll need to derive a
    contradiction from `p ∣ 1`. You can use `Nat.Prime.two_le`, which says that any
    prime number is greater than or equal to two, and `Nat.le_of_dvd`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us consider another approach. Here is a quick proof that if \(p\) is prime,
    then \(m^2 \ne p n^2\): if we assume \(m^2 = p n^2\) and consider the factorization
    of \(m\) and \(n\) into primes, then \(p\) occurs an even number of times on the
    left side of the equation and an odd number of times on the right, a contradiction.
    Note that this argument requires that \(n\) and hence \(m\) are not equal to zero.
    The formalization below confirms that this assumption is sufficient.'
  prefs: []
  type: TYPE_NORMAL
- en: The unique factorization theorem says that any natural number other than zero
    can be written as the product of primes in a unique way. Mathlib contains a formal
    version of this, expressed in terms of a function `Nat.primeFactorsList`, which
    returns the list of prime factors of a number in nondecreasing order. The library
    proves that all the elements of `Nat.primeFactorsList n` are prime, that any `n`
    greater than zero is equal to the product of its factors, and that if `n` is equal
    to the product of another list of prime numbers, then that list is a permutation
    of `Nat.primeFactorsList n`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can browse these theorems and others nearby, even though we have not talked
    about list membership, products, or permutations yet. We won’t need any of that
    for the task at hand. We will instead use the fact that Mathlib has a function
    `Nat.factorization`, that represents the same data as a function. Specifically,
    `Nat.factorization n p`, which we can also write `n.factorization p`, returns
    the multiplicity of `p` in the prime factorization of `n`. We will use the following
    three facts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In fact, `n.factorization` is defined in Lean as a function of finite support,
    which explains the strange notation you will see as you step through the proofs
    above. Don’t worry about this now. For our purposes here, we can use the three
    theorems above as a black box.
  prefs: []
  type: TYPE_NORMAL
- en: The next example shows that the simplifier is smart enough to replace `n^2 ≠
    0` by `n ≠ 0`. The tactic `simpa` just calls `simp` followed by `assumption`.
  prefs: []
  type: TYPE_NORMAL
- en: See if you can use the identities above to fill in the missing parts of the
    proof.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A nice thing about this proof is that it also generalizes. There is nothing
    special about `2`; with small changes, the proof shows that whenever we write
    `m^k = r * n^k`, the multiplicity of any prime `p` in `r` has to be a multiple
    of `k`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `Nat.count_factors_mul_of_pos` with `r * n^k`, we need to know that
    `r` is positive. But when `r` is zero, the theorem below is trivial, and easily
    proved by the simplifier. So the proof is carried out in cases. The line `rcases
    r with _ | r` replaces the goal with two versions: one in which `r` is replaced
    by `0`, and the other in which `r` is replaces by `r + 1`. In the second case,
    we can use the theorem `r.succ_ne_zero`, which establishes `r + 1 ≠ 0` (`succ`
    stands for successor).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice also that the line that begins `have : npow_nz` provides a short proof-term
    proof of `n^k ≠ 0`. To understand how it works, try replacing it with a tactic
    proof, and then think about how the tactics describe the proof term.'
  prefs: []
  type: TYPE_NORMAL
- en: See if you can fill in the missing parts of the proof below. At the very end,
    you can use `Nat.dvd_sub'` and `Nat.dvd_mul_right` to finish it off.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this example does not assume that `p` is prime, but the conclusion
    is trivial when `p` is not prime since `r.factorization p` is then zero by definition,
    and the proof works in all cases anyway.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There are a number of ways in which we might want to improve on these results.
    To start with, a proof that the square root of two is irrational should say something
    about the square root of two, which can be understood as an element of the real
    or complex numbers. And stating that it is irrational should say something about
    the rational numbers, namely, that no rational number is equal to it. Moreover,
    we should extend the theorems in this section to the integers. Although it is
    mathematically obvious that if we could write the square root of two as a quotient
    of two integers then we could write it as a quotient of two natural numbers, proving
    this formally requires some effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Mathlib, the natural numbers, the integers, the rationals, the reals, and
    the complex numbers are represented by separate data types. Restricting attention
    to the separate domains is often helpful: we will see that it is easy to do induction
    on the natural numbers, and it is easiest to reason about divisibility of integers
    when the real numbers are not part of the picture. But having to mediate between
    the different domains is a headache, one we will have to contend with. We will
    return to this issue later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: We should also expect to be able to strengthen the conclusion of the last theorem
    to say that the number `r` is a `k`-th power, since its `k`-th root is just the
    product of each prime dividing `r` raised to its multiplicity in `r` divided by
    `k`. To be able to do that we will need better means for reasoning about products
    and sums over a finite set, which is also a topic we will return to.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, the results in this section are all established in much greater generality
    in Mathlib, in `Data.Real.Irrational`. The notion of `multiplicity` is defined
    for an arbitrary commutative monoid, and that it takes values in the extended
    natural numbers `enat`, which adds the value infinity to the natural numbers.
    In the next chapter, we will begin to develop the means to appreciate the way
    that Lean supports this sort of generality.  ## 5.2\. Induction and Recursion[](#induction-and-recursion
    "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: The set of natural numbers \(\mathbb{N} = \{ 0, 1, 2, \ldots \}\) is not only
    fundamentally important in its own right, but also a plays a central role in the
    construction of new mathematical objects. Lean’s foundation allows us to declare
    *inductive types*, which are types generated inductively by a given list of *constructors*.
    In Lean, the natural numbers are declared as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find this in the library by writing `#check Nat` and then using `ctrl-click`
    on the identifier `Nat`. The command specifies that `Nat` is the datatype generated
    freely and inductively by the two constructors `zero : Nat` and `succ : Nat →
    Nat`. Of course, the library introduces notation `ℕ` and `0` for `nat` and `zero`
    respectively. (Numerals are translated to binary representations, but we don’t
    have to worry about the details of that now.)'
  prefs: []
  type: TYPE_NORMAL
- en: What “freely” means for the working mathematician is that the type `Nat` has
    an element `zero` and an injective successor function `succ` whose image does
    not include `zero`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What the word “inductively” means for the working mathematician is that the
    natural numbers comes with a principle of proof by induction and a principle of
    definition by recursion. This section will show you how to use these.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example of a recursive definition of the factorial function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The syntax takes some getting used to. Notice that there is no `:=` on the first
    line. The next two lines provide the base case and inductive step for a recursive
    definition. These equations hold definitionally, but they can also be used manually
    by giving the name `fac` to `simp` or `rw`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The factorial function is actually already defined in Mathlib as `Nat.factorial`.
    Once again, you can jump to it by typing `#check Nat.factorial` and using `ctrl-click.`
    For illustrative purposes, we will continue using `fac` in the examples. The annotation
    `@[simp]` before the definition of `Nat.factorial` specifies that the defining
    equation should be added to the database of identities that the simplifier uses
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The principle of induction says that we can prove a general statement about
    the natural numbers by proving that the statement holds of 0 and that whenever
    it holds of a natural number \(n\), it also holds of \(n + 1\). The line `induction''
    n with n ih` in the proof below therefore results in two goals: in the first we
    need to prove `0 < fac 0`, and in the second we have the added assumption `ih
    : 0 < fac n` and a required to prove `0 < fac (n + 1)`. The phrase `with n ih`
    serves to name the variable and the assumption for the inductive hypothesis, and
    you can choose whatever names you want for them.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `induction'` tactic is smart enough to include hypotheses that depend on
    the induction variable as part of the induction hypothesis. Step through the next
    example to see what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The following example provides a crude lower bound for the factorial function.
    It turns out to be easier to start with a proof by cases, so that the remainder
    of the proof starts with the case \(n = 1\). See if you can complete the argument
    with a proof by induction using `pow_succ` or `pow_succ'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Induction is often used to prove identities involving finite sums and products.
    Mathlib defines the expressions `Finset.sum s f` where `s : Finset α` is a finite
    set of elements of the type `α` and `f` is a function defined on `α`. The codomain
    of `f` can be any type that supports a commutative, associative addition operation
    with a zero element. If you import `Algebra.BigOperators.Ring` and issue the command
    `open BigOperators`, you can use the more suggestive notation `∑ x ∈ s, f x`.
    Of course, there is an analogous operation and notation for finite products.'
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about the `Finset` type and the operations it supports in the next
    section, and again in a later chapter. For now, we will only make use of `Finset.range
    n`, which is the finite set of natural numbers less than `n`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The facts `Finset.sum_range_zero` and `Finset.sum_range_succ` provide a recursive
    description of summation up to \(n\), and similarly for products.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first identity in each pair holds definitionally, which is to say, you can
    replace the proofs by `rfl`.
  prefs: []
  type: TYPE_NORMAL
- en: The following expresses the factorial function that we defined as a product.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The fact that we include `mul_comm` as a simplification rule deserves comment.
    It should seem dangerous to simplify with the identity `x * y = y * x`, which
    would ordinarily loop indefinitely. Lean’s simplifier is smart enough to recognize
    that, and applies the rule only in the case where the resulting term has a smaller
    value in some fixed but arbitrary ordering of the terms. The following example
    shows that simplifying using the three rules `mul_assoc`, `mul_comm`, and `mul_left_comm`
    manages to identify products that are the same up to the placement of parentheses
    and ordering of variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Roughly, the rules work by pushing parentheses to the right and then re-ordering
    the expressions on both sides until they both follow the same canonical order.
    Simplifying with these rules, and the corresponding rules for addition, is a handy
    trick.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to summation identities, we suggest stepping through the following
    proof that the sum of the natural numbers up to and including \(n\) is \(n (n
    + 1) / 2\). The first step of the proof clears the denominator. This is generally
    useful when formalizing identities, because calculations with division generally
    have side conditions. (It is similarly useful to avoid using subtraction on the
    natural numbers when possible.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We encourage you to prove the analogous identity for sums of squares, and other
    identities you can find on the web.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In Lean’s core library, addition and multiplication are themselves defined using
    recursive definitions, and their fundamental properties are established using
    induction. If you like thinking about foundational topics like that, you might
    enjoy working through proofs of the commutativity and associativity of multiplication
    and addition and the distributivity of multiplication over addition. You can do
    this on a copy of the natural numbers following the outline below. Notice that
    we can use the `induction` tactic with `MyNat`; Lean is smart enough to know to
    use the relevant induction principle (which is, of course, the same as that for
    `Nat`).
  prefs: []
  type: TYPE_NORMAL
- en: We start you off with the commutativity of addition. A good rule of thumb is
    that because addition and multiplication are defined by recursion on the second
    argument, it is generally advantageous to do proofs by induction on a variable
    that occurs in that position. It is a bit tricky to decide which variable to use
    in the proof of associativity.
  prefs: []
  type: TYPE_NORMAL
- en: It can be confusing to write things without the usual notation for zero, one,
    addition, and multiplication. We will learn how to define such notation later.
    Working in the namespace `MyNat` means that we can write `zero` and `succ` rather
    than `MyNat.zero` and `MyNat.succ`, and that these interpretations of the names
    take precedence over others. Outside the namespace, the full name of the `add`
    defined below, for example, is `MyNat.add`.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you *really* enjoy this sort of thing, try defining truncated
    subtraction and exponentiation and proving some of their properties as well. Remember
    that truncated subtraction cuts off at zero. To define that, it is useful to define
    a predecessor function, `pred`, that subtracts one from any nonzero number and
    fixes zero. The function `pred` can be defined by a simple instance of recursion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]  ## 5.3\. Infinitely Many Primes[](#infinitely-many-primes "Link to
    this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us continue our exploration of induction and recursion with another mathematical
    standard: a proof that there are infinitely many primes. One way to formulate
    this is as the statement that for every natural number \(n\), there is a prime
    number greater than \(n\). To prove this, let \(p\) be any prime factor of \(n!
    + 1\). If \(p\) is less than or equal to \(n\), it divides \(n!\). Since it also
    divides \(n! + 1\), it divides 1, a contradiction. Hence \(p\) is greater than
    \(n\).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To formalize that proof, we need to show that any number greater than or equal
    to 2 has a prime factor. To do that, we will need to show that any natural number
    that is not equal to 0 or 1 is greater-than or equal to 2. And this brings us
    to a quirky feature of formalization: it is often trivial statements like this
    that are among the most annoying to formalize. Here we consider a few ways to
    do it.'
  prefs: []
  type: TYPE_NORMAL
- en: To start with, we can use the `cases` tactic and the fact that the successor
    function respects the ordering on the natural numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Another strategy is to use the tactic `interval_cases`, which automatically
    splits the goal into cases when the variable in question is contained in an interval
    of natural numbers or integers. Remember that you can hover over it to see its
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Recall that the semicolon after `interval_cases m` means that the next tactic
    is applied to each of the cases that it generates. Yet another option is to use
    the tactic `decide`, which tries to find a decision procedure to solve the problem.
    Lean knows that you can decide the truth value of a statement that begins with
    a bounded quantifier `∀ x, x < n → ...` or `∃ x, x < n ∧ ...` by deciding each
    of the finitely many instances.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With the theorem `two_le` in hand, let’s start by showing that every natural
    number greater than two has a prime divisor. Mathlib contains a function `Nat.minFac`
    that returns the smallest prime divisor, but for the sake of learning new parts
    of the library, we’ll avoid using it and prove the theorem directly.
  prefs: []
  type: TYPE_NORMAL
- en: Here, ordinary induction isn’t enough. We want to use *strong induction*, which
    allows us to prove that every natural number \(n\) has a property \(P\) by showing
    that for every number \(n\), if \(P\) holds of all values less than \(n\), it
    holds at \(n\) as well. In Lean, this principle is called `Nat.strong_induction_on`,
    and we can use the `using` keyword to tell the induction tactic to use it. Notice
    that when we do that, there is no base case; it is subsumed by the general induction
    step.
  prefs: []
  type: TYPE_NORMAL
- en: The argument is simply as follows. Assuming \(n ≥ 2\), if \(n\) is prime, we’re
    done. If it isn’t, then by one of the characterizations of what it means to be
    a prime number, it has a nontrivial factor, \(m\), and we can apply the inductive
    hypothesis to that. Step through the next proof to see how that plays out.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We can now prove the following formulation of our theorem. See if you can fill
    out the sketch. You can use `Nat.factorial_pos`, `Nat.dvd_factorial`, and `Nat.dvd_sub'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Let’s consider a variation of the proof above, where instead of using the factorial
    function, we suppose that we are given by a finite set \(\{ p_1, \ldots, p_n \}\)
    and we consider a prime factor of \(\prod_{i = 1}^n p_i + 1\). That prime factor
    has to be distinct from each \(p_i\), showing that there is no finite set that
    contains all the prime numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Formalizing this argument requires us to reason about finite sets. In Lean,
    for any type `α`, the type `Finset α` represents finite sets of elements of type
    `α`. Reasoning about finite sets computationally requires having a procedure to
    test equality on `α`, which is why the snippet below includes the assumption `[DecidableEq
    α]`. For concrete data types like `ℕ`, `ℤ`, and `ℚ`, the assumption is satisfied
    automatically. When reasoning about the real numbers, it can be satisfied using
    classical logic and abandoning the computational interpretation.
  prefs: []
  type: TYPE_NORMAL
- en: We use the command `open Finset` to avail ourselves of shorter names for the
    relevant theorems. Unlike the case with sets, most equivalences involving finsets
    do not hold definitionally, so they need to be expanded manually using equivalences
    like `Finset.subset_iff`, `Finset.mem_union`, `Finset.mem_inter`, and `Finset.mem_sdiff`.
    The `ext` tactic can still be used to show that two finite sets are equal by showing
    that every element of one is an element of the other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used a new trick: the `tauto` tactic (and a strengthened version, `tauto!`,
    which uses classical logic) can be used to dispense with propositional tautologies.
    See if you can use these methods to prove the two examples below.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The theorem `Finset.dvd_prod_of_mem` tells us that if an `n` is an element of
    a finite set `s`, then `n` divides `∏ i ∈ s, i`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We also need to know that the converse holds in the case where `n` is prime
    and `s` is a set of primes. To show that, we need the following lemma, which you
    should be able to prove using the theorem `Nat.Prime.eq_one_or_self_of_dvd`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this lemma to show that if a prime `p` divides a product of a finite
    set of primes, then it is equal to one of them. Mathlib provides a useful principle
    of induction on finite sets: to show that a property holds of an arbitrary finite
    set `s`, show that it holds of the empty set, and show that it is preserved when
    we add a single new element `a ∉ s`. The principle is known as `Finset.induction_on`.
    When we tell the induction tactic to use it, we can also specify the names `a`
    and `s`, the name for the assumption `a ∉ s` in the inductive step, and the name
    of the inductive hypothesis. The expression `Finset.insert a s` denotes the union
    of `s` with the singleton `a`. The identities `Finset.prod_empty` and `Finset.prod_insert`
    then provide the relevant rewrite rules for the product. In the proof below, the
    first `simp` applies `Finset.prod_empty`. Step through the beginning of the proof
    to see the induction unfold, and then finish it off.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We need one last property of finite sets. Given an element `s : Set α` and
    a predicate `P` on `α`, in [Chapter 4](C04_Sets_and_Functions.html#sets-and-functions)
    we wrote `{ x ∈ s | P x }` for the set of elements of `s` that satisfy `P`. Given
    `s : Finset α`, the analogous notion is written `s.filter P`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We now prove an alternative formulation of the statement that there are infinitely
    many primes, namely, that given any `s : Finset ℕ`, there is a prime `p` that
    is not an element of `s`. Aiming for a contradiction, we assume that all the primes
    are in `s`, and then cut down to a set `s''` that contains all and only the primes.
    Taking the product of that set, adding one, and finding a prime factor of the
    result leads to the contradiction we are looking for. See if you can complete
    the sketch below. You can use `Finset.prod_pos` in the proof of the first `have`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We have thus seen two ways of saying that there are infinitely many primes:
    saying that they are not bounded by any `n`, and saying that they are not contained
    in any finite set `s`. The two proofs below show that these formulations are equivalent.
    In the second, in order to form `s.filter Q`, we have to assume that there is
    a procedure for deciding whether or not `Q` holds. Lean knows that there is a
    procedure for `Nat.Prime`. In general, if we use classical logic by writing `open
    Classical`, we can dispense with the assumption.'
  prefs: []
  type: TYPE_NORMAL
- en: In Mathlib, `Finset.sup s f` denotes the supremum of the values of `f x` as
    `x` ranges over `s`, returning `0` in the case where `s` is empty and the codomain
    of `f` is `ℕ`. In the first proof, we use `s.sup id`, where `id` is the identity
    function, to refer to the maximum value in `s`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: A small variation on our second proof that there are infinitely many primes
    shows that there are infinitely many primes congruent to 3 modulo 4. The argument
    goes as follows. First, notice that if the product of two numbers \(m\) and \(n\)
    is equal to 3 modulo 4, then one of the two numbers is congruent to 3 modulo 4.
    After all, both have to be odd, and if they are both congruent to 1 modulo 4,
    so is their product. We can use this observation to show that if some number greater
    than 2 is congruent to 3 modulo 4, then that number has a prime divisor that is
    also congruent to 3 modulo 4.
  prefs: []
  type: TYPE_NORMAL
- en: Now suppose there are only finitely many prime numbers congruent to 3 modulo
    4, say, \(p_1, \ldots, p_k\). Without loss of generality, we can assume that \(p_1
    = 3\). Consider the product \(4 \prod_{i = 2}^k p_i + 3\). It is easy to see that
    this is congruent to 3 modulo 4, so it has a prime factor \(p\) congruent to 3
    modulo 4. It can’t be the case that \(p = 3\); since \(p\) divides \(4 \prod_{i
    = 2}^k p_i + 3\), if \(p\) were equal to 3 then it would also divide \(\prod_{i
    = 2}^k p_i\), which implies that \(p\) is equal to one of the \(p_i\) for \(i
    = 2, \ldots, k\); and we have excluded 3 from this list. So \(p\) has to be one
    of the other elements \(p_i\). But in that case, \(p\) divides \(4 \prod_{i =
    2}^k p_i\) and hence 3, which contradicts the fact that it is not 3.
  prefs: []
  type: TYPE_NORMAL
- en: In Lean, the notation `n % m`, read “`n` modulo `m`,” denotes the remainder
    of the division of `n` by `m`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We can then render the statement “`n` is congruent to 3 modulo 4” as `n % 4
    = 3`. The following example and theorems sum up the facts about this function
    that we will need to use below. The first named theorem is another illustration
    of reasoning by a small number of cases. In the second named theorem, remember
    that the semicolon means that the subsequent tactic block is applied to all the
    goals created by the preceding tactic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We will also need the following fact, which says that if `m` is a nontrivial
    divisor of `n`, then so is `n / m`. See if you can complete the proof using `Nat.div_dvd_of_dvd`
    and `Nat.div_lt_self`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now put all the pieces together to prove that any number congruent to 3 modulo
    4 has a prime divisor with that same property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We are in the home stretch. Given a set `s` of prime numbers, we need to talk
    about the result of removing 3 from that set, if it is present. The function `Finset.erase`
    handles that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to prove that there are infinitely many primes congruent to
    3 modulo 4. Fill in the missing parts below. Our solution uses `Nat.dvd_add_iff_left`
    and `Nat.dvd_sub'` along the way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If you managed to complete the proof, congratulations! This has been a serious
    feat of formalization.  ## 5.4\. More Induction[](#more-induction "Link to this
    heading")'
  prefs: []
  type: TYPE_NORMAL
- en: In [Section 5.2](#section-induction-and-recursion), we saw how to define the
    factorial function by recursion on the natural numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We also saw how to prove theorems using the `induction'` tactic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `induction` tactic (without the prime tick mark) allows for more structured
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As usual, you can hover over the `induction` keyword to read the documentation.
    The names of the cases, `zero` and `succ`, are taken from the definition of the
    type ℕ. Notice that the `succ` case allows you to choose whatever names you want
    for the induction variable and the inductive hypothesis, here `n` and `ih`. You
    can even prove a theorem with the same notation used to define a recursive function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Notice also the absence of the `:=`, the `∀ n` after the colon, the `by` keyword
    in each case, and the inductive appeal to `fac_pos' n`. It is as though the theorem
    is a recursive function of `n` and in the inductive step we make a recursive call.
  prefs: []
  type: TYPE_NORMAL
- en: This style of definition is remarkably flexible. Lean’s designers have built
    in elaborate means of defining recursive functions, and these extend to doing
    proofs by induction. For example, we can define the Fibonacci function with multiple
    base cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `@[simp]` annotation means that the simplifier will use the defining equations.
    You can also apply them by writing `rw [fib]`. Below it will be helpful to give
    a name to the `n + 2` case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Using Lean’s notation for recursive functions, you can carry out proofs by induction
    on the natural numbers that mirror the recursive definition of `fib`. The following
    example provides an explicit formula for the nth Fibonacci number in terms of
    the golden mean, `φ`, and its conjugate, `φ'`. We have to tell Lean that we don’t
    expect our definitions to generate code because the arithmetic operations on the
    real numbers are not computable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Induction proofs involving the Fibonacci function do not have to be of that
    form. Below we reproduce the `Mathlib` proof that consecutive Fibonacci numbers
    are coprime.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Using Lean’s computational interpretation, we can evaluate the Fibonacci numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The straightforward implementation of `fib` is computationally inefficient.
    In fact, it runs in time exponential in its argument. (You should think about
    why.) In Lean, we can implement the following tail-recursive version, whose running
    time is linear in `n`, and prove that it computes the same function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `generalizing` keyword in the proof of `fib'.aux_eq`. It serves to
    insert a `∀ m` in front of the inductive hypothesis, so that in the induction
    step, `m` can take a different value. You can step through the proof and check
    that in this case, the quantifier needs to be instantiated to `m + 1` in the inductive
    step.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also the use of `erw` (for “extended rewrite”) instead of `rw`. This
    is used because to rewrite the goal `fib'.aux_eq`, `fib 0` and `fib 1` have to
    be reduced to `0` and `1`, respectively. The tactic `erw` is more aggressive than
    `rw` in unfolding definitions to match parameters. This isn’t always a good idea;
    it can waste a lot of time in some cases, so use `erw` sparingly.
  prefs: []
  type: TYPE_NORMAL
- en: Here is another example of the `generalizing` keyword in use, in the proof of
    another identity that is found in `Mathlib`. An informal proof of the identity
    can be found [here](https://proofwiki.org/wiki/Fibonacci_Number_in_terms_of_Smaller_Fibonacci_Numbers).
    We provide two variants of the formal proof.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As an exercise, use `fib_add` to prove the following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Lean’s mechanisms for defining recursive functions are flexible enough to allow
    arbitrary recursive calls, as long the complexity of the arguments decrease according
    to some well-founded measure. In the next example, we show that every natural
    number `n ≠ 1` has a prime divisor, using the fact that if `n` is nonzero and
    not prime, it has a smaller divisor. (You can check that Mathlib has a theorem
    of the same name in the `Nat` namespace, though it has a different proof than
    the one we give here.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The line `rw [ne_one_iff_exists_prime_dvd] at this` is like a magic trick:
    we are using the very theorem we are proving in its own proof. What makes it work
    is that the inductive call is instantiated at `m`, the current case is `n + 2`,
    and the context has `m < n + 2`. Lean can find the hypothesis and use it to show
    that the induction is well-founded. Lean is pretty good at figuring out what is
    decreasing; in this case, the choice of `n` in the statement of the theorem and
    the less-than relation is obvious. In more complicated cases, Lean provides mechanisms
    to provide this information explicitly. See the section on [well-founded recursion](https://lean-lang.org/doc/reference/latest//Definitions/Recursive-Definitions/#well-founded-recursion)
    in the Lean Reference Manual.'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, in a proof, you need to split on cases depending on whether a natural
    number `n` is zero or a successor, without requiring an inductive hypothesis in
    the successor case. For that, you can use the `cases` and `rcases` tactics.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This is a useful trick. Often you have a theorem about a natural number `n`
    for which the zero case is easy. If you case on `n` and take care of the zero
    case quickly, you are left with the original goal with `n` replaced by `n + 1`.
    [Previous](C04_Sets_and_Functions.html "4\. Sets and Functions") [Next](C06_Discrete_Mathematics.html
    "6\. Discrete Mathematics")
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: © Copyright 2020-2025, Jeremy Avigad, Patrick Massot. Text licensed under CC
    BY 4.0.
  prefs: []
  type: TYPE_NORMAL
- en: Built with [Sphinx](https://www.sphinx-doc.org/) using a [theme](https://github.com/readthedocs/sphinx_rtd_theme)
    provided by [Read the Docs](https://readthedocs.org). In this chapter, we show
    you how to formalize some elementary results in number theory. As we deal with
    more substantive mathematical content, the proofs will get longer and more involved,
    building on the skills you have already mastered.
  prefs: []
  type: TYPE_NORMAL
- en: '## 5.1\. Irrational Roots[](#irrational-roots "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a fact known to the ancient Greeks, namely, that the square
    root of 2 is irrational. If we suppose otherwise, we can write \(\sqrt{2} = a
    / b\) as a fraction in lowest terms. Squaring both sides yields \(a^2 = 2 b^2\),
    which implies that \(a\) is even. If we write \(a = 2c\), then we get \(4c^2 =
    2 b^2\) and hence \(b^2 = 2 c^2\). This implies that \(b\) is also even, contradicting
    the fact that we have assumed that \(a / b\) has been reduced to lowest terms.
  prefs: []
  type: TYPE_NORMAL
- en: Saying that \(a / b\) is a fraction in lowest terms means that \(a\) and \(b\)
    do not have any factors in common, which is to say, they are *coprime*. Mathlib
    defines the predicate `Nat.Coprime m n` to be `Nat.gcd m n = 1`. Using Lean’s
    anonymous projection notation, if `s` and `t` are expressions of type `Nat`, we
    can write `s.Coprime t` instead of `Nat.Coprime s t`, and similarly for `Nat.gcd`.
    As usual, Lean will often unfold the definition of `Nat.Coprime` automatically
    when necessary, but we can also do it manually by rewriting or simplifying with
    the identifier `Nat.Coprime`. The `norm_num` tactic is smart enough to compute
    concrete values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We have already encountered the `gcd` function in [Section 2.4](C02_Basics.html#more-on-order-and-divisibility).
    There is also a version of `gcd` for the integers; we will return to a discussion
    of the relationship between different number systems below. There are even a generic
    `gcd` function and generic notions of `Prime` and `Coprime` that make sense in
    general classes of algebraic structures. We will come to understand how Lean manages
    this generality in the next chapter. In the meanwhile, in this section, we will
    restrict attention to the natural numbers.
  prefs: []
  type: TYPE_NORMAL
- en: We also need the notion of a prime number, `Nat.Prime`. The theorem `Nat.prime_def_lt`
    provides one familiar characterization, and `Nat.Prime.eq_one_or_self_of_dvd`
    provides another.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In the natural numbers, a prime number has the property that it cannot be written
    as a product of nontrivial factors. In a broader mathematical context, an element
    of a ring that has this property is said to be *irreducible*. An element of a
    ring is said to be *prime* if whenever it divides a product, it divides one of
    the factors. It is an important property of the natural numbers that in that setting
    the two notions coincide, giving rise to the theorem `Nat.Prime.dvd_mul`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this fact to establish a key property in the argument above: if
    the square of a number is even, then that number is even as well. Mathlib defines
    the predicate `Even` in `Algebra.Group.Even`, but for reasons that will become
    clear below, we will simply use `2 ∣ m` to express that `m` is even.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: As we proceed, you will need to become proficient at finding the facts you need.
    Remember that if you can guess the prefix of the name and you have imported the
    relevant library, you can use tab completion (sometimes with `ctrl-tab`) to find
    what you are looking for. You can use `ctrl-click` on any identifier to jump to
    the file where it is defined, which enables you to browse definitions and theorems
    nearby. You can also use the search engine on the [Lean community web pages](https://leanprover-community.github.io/),
    and if all else fails, don’t hesitate to ask on [Zulip](https://leanprover.zulipchat.com/).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The heart of our proof of the irrationality of the square root of two is contained
    in the following theorem. See if you can fill out the proof sketch, using `even_of_even_sqr`
    and the theorem `Nat.dvd_gcd`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In fact, with very few changes, we can replace `2` by an arbitrary prime. Give
    it a try in the next example. At the end of the proof, you’ll need to derive a
    contradiction from `p ∣ 1`. You can use `Nat.Prime.two_le`, which says that any
    prime number is greater than or equal to two, and `Nat.le_of_dvd`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us consider another approach. Here is a quick proof that if \(p\) is prime,
    then \(m^2 \ne p n^2\): if we assume \(m^2 = p n^2\) and consider the factorization
    of \(m\) and \(n\) into primes, then \(p\) occurs an even number of times on the
    left side of the equation and an odd number of times on the right, a contradiction.
    Note that this argument requires that \(n\) and hence \(m\) are not equal to zero.
    The formalization below confirms that this assumption is sufficient.'
  prefs: []
  type: TYPE_NORMAL
- en: The unique factorization theorem says that any natural number other than zero
    can be written as the product of primes in a unique way. Mathlib contains a formal
    version of this, expressed in terms of a function `Nat.primeFactorsList`, which
    returns the list of prime factors of a number in nondecreasing order. The library
    proves that all the elements of `Nat.primeFactorsList n` are prime, that any `n`
    greater than zero is equal to the product of its factors, and that if `n` is equal
    to the product of another list of prime numbers, then that list is a permutation
    of `Nat.primeFactorsList n`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: You can browse these theorems and others nearby, even though we have not talked
    about list membership, products, or permutations yet. We won’t need any of that
    for the task at hand. We will instead use the fact that Mathlib has a function
    `Nat.factorization`, that represents the same data as a function. Specifically,
    `Nat.factorization n p`, which we can also write `n.factorization p`, returns
    the multiplicity of `p` in the prime factorization of `n`. We will use the following
    three facts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In fact, `n.factorization` is defined in Lean as a function of finite support,
    which explains the strange notation you will see as you step through the proofs
    above. Don’t worry about this now. For our purposes here, we can use the three
    theorems above as a black box.
  prefs: []
  type: TYPE_NORMAL
- en: The next example shows that the simplifier is smart enough to replace `n^2 ≠
    0` by `n ≠ 0`. The tactic `simpa` just calls `simp` followed by `assumption`.
  prefs: []
  type: TYPE_NORMAL
- en: See if you can use the identities above to fill in the missing parts of the
    proof.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: A nice thing about this proof is that it also generalizes. There is nothing
    special about `2`; with small changes, the proof shows that whenever we write
    `m^k = r * n^k`, the multiplicity of any prime `p` in `r` has to be a multiple
    of `k`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `Nat.count_factors_mul_of_pos` with `r * n^k`, we need to know that
    `r` is positive. But when `r` is zero, the theorem below is trivial, and easily
    proved by the simplifier. So the proof is carried out in cases. The line `rcases
    r with _ | r` replaces the goal with two versions: one in which `r` is replaced
    by `0`, and the other in which `r` is replaces by `r + 1`. In the second case,
    we can use the theorem `r.succ_ne_zero`, which establishes `r + 1 ≠ 0` (`succ`
    stands for successor).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice also that the line that begins `have : npow_nz` provides a short proof-term
    proof of `n^k ≠ 0`. To understand how it works, try replacing it with a tactic
    proof, and then think about how the tactics describe the proof term.'
  prefs: []
  type: TYPE_NORMAL
- en: See if you can fill in the missing parts of the proof below. At the very end,
    you can use `Nat.dvd_sub'` and `Nat.dvd_mul_right` to finish it off.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this example does not assume that `p` is prime, but the conclusion
    is trivial when `p` is not prime since `r.factorization p` is then zero by definition,
    and the proof works in all cases anyway.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: There are a number of ways in which we might want to improve on these results.
    To start with, a proof that the square root of two is irrational should say something
    about the square root of two, which can be understood as an element of the real
    or complex numbers. And stating that it is irrational should say something about
    the rational numbers, namely, that no rational number is equal to it. Moreover,
    we should extend the theorems in this section to the integers. Although it is
    mathematically obvious that if we could write the square root of two as a quotient
    of two integers then we could write it as a quotient of two natural numbers, proving
    this formally requires some effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Mathlib, the natural numbers, the integers, the rationals, the reals, and
    the complex numbers are represented by separate data types. Restricting attention
    to the separate domains is often helpful: we will see that it is easy to do induction
    on the natural numbers, and it is easiest to reason about divisibility of integers
    when the real numbers are not part of the picture. But having to mediate between
    the different domains is a headache, one we will have to contend with. We will
    return to this issue later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: We should also expect to be able to strengthen the conclusion of the last theorem
    to say that the number `r` is a `k`-th power, since its `k`-th root is just the
    product of each prime dividing `r` raised to its multiplicity in `r` divided by
    `k`. To be able to do that we will need better means for reasoning about products
    and sums over a finite set, which is also a topic we will return to.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, the results in this section are all established in much greater generality
    in Mathlib, in `Data.Real.Irrational`. The notion of `multiplicity` is defined
    for an arbitrary commutative monoid, and that it takes values in the extended
    natural numbers `enat`, which adds the value infinity to the natural numbers.
    In the next chapter, we will begin to develop the means to appreciate the way
    that Lean supports this sort of generality.  ## 5.2\. Induction and Recursion[](#induction-and-recursion
    "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: The set of natural numbers \(\mathbb{N} = \{ 0, 1, 2, \ldots \}\) is not only
    fundamentally important in its own right, but also a plays a central role in the
    construction of new mathematical objects. Lean’s foundation allows us to declare
    *inductive types*, which are types generated inductively by a given list of *constructors*.
    In Lean, the natural numbers are declared as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find this in the library by writing `#check Nat` and then using `ctrl-click`
    on the identifier `Nat`. The command specifies that `Nat` is the datatype generated
    freely and inductively by the two constructors `zero : Nat` and `succ : Nat →
    Nat`. Of course, the library introduces notation `ℕ` and `0` for `nat` and `zero`
    respectively. (Numerals are translated to binary representations, but we don’t
    have to worry about the details of that now.)'
  prefs: []
  type: TYPE_NORMAL
- en: What “freely” means for the working mathematician is that the type `Nat` has
    an element `zero` and an injective successor function `succ` whose image does
    not include `zero`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: What the word “inductively” means for the working mathematician is that the
    natural numbers comes with a principle of proof by induction and a principle of
    definition by recursion. This section will show you how to use these.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example of a recursive definition of the factorial function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The syntax takes some getting used to. Notice that there is no `:=` on the first
    line. The next two lines provide the base case and inductive step for a recursive
    definition. These equations hold definitionally, but they can also be used manually
    by giving the name `fac` to `simp` or `rw`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The factorial function is actually already defined in Mathlib as `Nat.factorial`.
    Once again, you can jump to it by typing `#check Nat.factorial` and using `ctrl-click.`
    For illustrative purposes, we will continue using `fac` in the examples. The annotation
    `@[simp]` before the definition of `Nat.factorial` specifies that the defining
    equation should be added to the database of identities that the simplifier uses
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The principle of induction says that we can prove a general statement about
    the natural numbers by proving that the statement holds of 0 and that whenever
    it holds of a natural number \(n\), it also holds of \(n + 1\). The line `induction''
    n with n ih` in the proof below therefore results in two goals: in the first we
    need to prove `0 < fac 0`, and in the second we have the added assumption `ih
    : 0 < fac n` and a required to prove `0 < fac (n + 1)`. The phrase `with n ih`
    serves to name the variable and the assumption for the inductive hypothesis, and
    you can choose whatever names you want for them.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `induction'` tactic is smart enough to include hypotheses that depend on
    the induction variable as part of the induction hypothesis. Step through the next
    example to see what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The following example provides a crude lower bound for the factorial function.
    It turns out to be easier to start with a proof by cases, so that the remainder
    of the proof starts with the case \(n = 1\). See if you can complete the argument
    with a proof by induction using `pow_succ` or `pow_succ'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Induction is often used to prove identities involving finite sums and products.
    Mathlib defines the expressions `Finset.sum s f` where `s : Finset α` is a finite
    set of elements of the type `α` and `f` is a function defined on `α`. The codomain
    of `f` can be any type that supports a commutative, associative addition operation
    with a zero element. If you import `Algebra.BigOperators.Ring` and issue the command
    `open BigOperators`, you can use the more suggestive notation `∑ x ∈ s, f x`.
    Of course, there is an analogous operation and notation for finite products.'
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about the `Finset` type and the operations it supports in the next
    section, and again in a later chapter. For now, we will only make use of `Finset.range
    n`, which is the finite set of natural numbers less than `n`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The facts `Finset.sum_range_zero` and `Finset.sum_range_succ` provide a recursive
    description of summation up to \(n\), and similarly for products.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The first identity in each pair holds definitionally, which is to say, you can
    replace the proofs by `rfl`.
  prefs: []
  type: TYPE_NORMAL
- en: The following expresses the factorial function that we defined as a product.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The fact that we include `mul_comm` as a simplification rule deserves comment.
    It should seem dangerous to simplify with the identity `x * y = y * x`, which
    would ordinarily loop indefinitely. Lean’s simplifier is smart enough to recognize
    that, and applies the rule only in the case where the resulting term has a smaller
    value in some fixed but arbitrary ordering of the terms. The following example
    shows that simplifying using the three rules `mul_assoc`, `mul_comm`, and `mul_left_comm`
    manages to identify products that are the same up to the placement of parentheses
    and ordering of variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Roughly, the rules work by pushing parentheses to the right and then re-ordering
    the expressions on both sides until they both follow the same canonical order.
    Simplifying with these rules, and the corresponding rules for addition, is a handy
    trick.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to summation identities, we suggest stepping through the following
    proof that the sum of the natural numbers up to and including \(n\) is \(n (n
    + 1) / 2\). The first step of the proof clears the denominator. This is generally
    useful when formalizing identities, because calculations with division generally
    have side conditions. (It is similarly useful to avoid using subtraction on the
    natural numbers when possible.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: We encourage you to prove the analogous identity for sums of squares, and other
    identities you can find on the web.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In Lean’s core library, addition and multiplication are themselves defined using
    recursive definitions, and their fundamental properties are established using
    induction. If you like thinking about foundational topics like that, you might
    enjoy working through proofs of the commutativity and associativity of multiplication
    and addition and the distributivity of multiplication over addition. You can do
    this on a copy of the natural numbers following the outline below. Notice that
    we can use the `induction` tactic with `MyNat`; Lean is smart enough to know to
    use the relevant induction principle (which is, of course, the same as that for
    `Nat`).
  prefs: []
  type: TYPE_NORMAL
- en: We start you off with the commutativity of addition. A good rule of thumb is
    that because addition and multiplication are defined by recursion on the second
    argument, it is generally advantageous to do proofs by induction on a variable
    that occurs in that position. It is a bit tricky to decide which variable to use
    in the proof of associativity.
  prefs: []
  type: TYPE_NORMAL
- en: It can be confusing to write things without the usual notation for zero, one,
    addition, and multiplication. We will learn how to define such notation later.
    Working in the namespace `MyNat` means that we can write `zero` and `succ` rather
    than `MyNat.zero` and `MyNat.succ`, and that these interpretations of the names
    take precedence over others. Outside the namespace, the full name of the `add`
    defined below, for example, is `MyNat.add`.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you *really* enjoy this sort of thing, try defining truncated
    subtraction and exponentiation and proving some of their properties as well. Remember
    that truncated subtraction cuts off at zero. To define that, it is useful to define
    a predecessor function, `pred`, that subtracts one from any nonzero number and
    fixes zero. The function `pred` can be defined by a simple instance of recursion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]  ## 5.3\. Infinitely Many Primes[](#infinitely-many-primes "Link to
    this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us continue our exploration of induction and recursion with another mathematical
    standard: a proof that there are infinitely many primes. One way to formulate
    this is as the statement that for every natural number \(n\), there is a prime
    number greater than \(n\). To prove this, let \(p\) be any prime factor of \(n!
    + 1\). If \(p\) is less than or equal to \(n\), it divides \(n!\). Since it also
    divides \(n! + 1\), it divides 1, a contradiction. Hence \(p\) is greater than
    \(n\).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To formalize that proof, we need to show that any number greater than or equal
    to 2 has a prime factor. To do that, we will need to show that any natural number
    that is not equal to 0 or 1 is greater-than or equal to 2. And this brings us
    to a quirky feature of formalization: it is often trivial statements like this
    that are among the most annoying to formalize. Here we consider a few ways to
    do it.'
  prefs: []
  type: TYPE_NORMAL
- en: To start with, we can use the `cases` tactic and the fact that the successor
    function respects the ordering on the natural numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Another strategy is to use the tactic `interval_cases`, which automatically
    splits the goal into cases when the variable in question is contained in an interval
    of natural numbers or integers. Remember that you can hover over it to see its
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Recall that the semicolon after `interval_cases m` means that the next tactic
    is applied to each of the cases that it generates. Yet another option is to use
    the tactic `decide`, which tries to find a decision procedure to solve the problem.
    Lean knows that you can decide the truth value of a statement that begins with
    a bounded quantifier `∀ x, x < n → ...` or `∃ x, x < n ∧ ...` by deciding each
    of the finitely many instances.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: With the theorem `two_le` in hand, let’s start by showing that every natural
    number greater than two has a prime divisor. Mathlib contains a function `Nat.minFac`
    that returns the smallest prime divisor, but for the sake of learning new parts
    of the library, we’ll avoid using it and prove the theorem directly.
  prefs: []
  type: TYPE_NORMAL
- en: Here, ordinary induction isn’t enough. We want to use *strong induction*, which
    allows us to prove that every natural number \(n\) has a property \(P\) by showing
    that for every number \(n\), if \(P\) holds of all values less than \(n\), it
    holds at \(n\) as well. In Lean, this principle is called `Nat.strong_induction_on`,
    and we can use the `using` keyword to tell the induction tactic to use it. Notice
    that when we do that, there is no base case; it is subsumed by the general induction
    step.
  prefs: []
  type: TYPE_NORMAL
- en: The argument is simply as follows. Assuming \(n ≥ 2\), if \(n\) is prime, we’re
    done. If it isn’t, then by one of the characterizations of what it means to be
    a prime number, it has a nontrivial factor, \(m\), and we can apply the inductive
    hypothesis to that. Step through the next proof to see how that plays out.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: We can now prove the following formulation of our theorem. See if you can fill
    out the sketch. You can use `Nat.factorial_pos`, `Nat.dvd_factorial`, and `Nat.dvd_sub'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Let’s consider a variation of the proof above, where instead of using the factorial
    function, we suppose that we are given by a finite set \(\{ p_1, \ldots, p_n \}\)
    and we consider a prime factor of \(\prod_{i = 1}^n p_i + 1\). That prime factor
    has to be distinct from each \(p_i\), showing that there is no finite set that
    contains all the prime numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Formalizing this argument requires us to reason about finite sets. In Lean,
    for any type `α`, the type `Finset α` represents finite sets of elements of type
    `α`. Reasoning about finite sets computationally requires having a procedure to
    test equality on `α`, which is why the snippet below includes the assumption `[DecidableEq
    α]`. For concrete data types like `ℕ`, `ℤ`, and `ℚ`, the assumption is satisfied
    automatically. When reasoning about the real numbers, it can be satisfied using
    classical logic and abandoning the computational interpretation.
  prefs: []
  type: TYPE_NORMAL
- en: We use the command `open Finset` to avail ourselves of shorter names for the
    relevant theorems. Unlike the case with sets, most equivalences involving finsets
    do not hold definitionally, so they need to be expanded manually using equivalences
    like `Finset.subset_iff`, `Finset.mem_union`, `Finset.mem_inter`, and `Finset.mem_sdiff`.
    The `ext` tactic can still be used to show that two finite sets are equal by showing
    that every element of one is an element of the other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used a new trick: the `tauto` tactic (and a strengthened version, `tauto!`,
    which uses classical logic) can be used to dispense with propositional tautologies.
    See if you can use these methods to prove the two examples below.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The theorem `Finset.dvd_prod_of_mem` tells us that if an `n` is an element of
    a finite set `s`, then `n` divides `∏ i ∈ s, i`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: We also need to know that the converse holds in the case where `n` is prime
    and `s` is a set of primes. To show that, we need the following lemma, which you
    should be able to prove using the theorem `Nat.Prime.eq_one_or_self_of_dvd`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this lemma to show that if a prime `p` divides a product of a finite
    set of primes, then it is equal to one of them. Mathlib provides a useful principle
    of induction on finite sets: to show that a property holds of an arbitrary finite
    set `s`, show that it holds of the empty set, and show that it is preserved when
    we add a single new element `a ∉ s`. The principle is known as `Finset.induction_on`.
    When we tell the induction tactic to use it, we can also specify the names `a`
    and `s`, the name for the assumption `a ∉ s` in the inductive step, and the name
    of the inductive hypothesis. The expression `Finset.insert a s` denotes the union
    of `s` with the singleton `a`. The identities `Finset.prod_empty` and `Finset.prod_insert`
    then provide the relevant rewrite rules for the product. In the proof below, the
    first `simp` applies `Finset.prod_empty`. Step through the beginning of the proof
    to see the induction unfold, and then finish it off.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'We need one last property of finite sets. Given an element `s : Set α` and
    a predicate `P` on `α`, in [Chapter 4](C04_Sets_and_Functions.html#sets-and-functions)
    we wrote `{ x ∈ s | P x }` for the set of elements of `s` that satisfy `P`. Given
    `s : Finset α`, the analogous notion is written `s.filter P`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'We now prove an alternative formulation of the statement that there are infinitely
    many primes, namely, that given any `s : Finset ℕ`, there is a prime `p` that
    is not an element of `s`. Aiming for a contradiction, we assume that all the primes
    are in `s`, and then cut down to a set `s''` that contains all and only the primes.
    Taking the product of that set, adding one, and finding a prime factor of the
    result leads to the contradiction we are looking for. See if you can complete
    the sketch below. You can use `Finset.prod_pos` in the proof of the first `have`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'We have thus seen two ways of saying that there are infinitely many primes:
    saying that they are not bounded by any `n`, and saying that they are not contained
    in any finite set `s`. The two proofs below show that these formulations are equivalent.
    In the second, in order to form `s.filter Q`, we have to assume that there is
    a procedure for deciding whether or not `Q` holds. Lean knows that there is a
    procedure for `Nat.Prime`. In general, if we use classical logic by writing `open
    Classical`, we can dispense with the assumption.'
  prefs: []
  type: TYPE_NORMAL
- en: In Mathlib, `Finset.sup s f` denotes the supremum of the values of `f x` as
    `x` ranges over `s`, returning `0` in the case where `s` is empty and the codomain
    of `f` is `ℕ`. In the first proof, we use `s.sup id`, where `id` is the identity
    function, to refer to the maximum value in `s`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: A small variation on our second proof that there are infinitely many primes
    shows that there are infinitely many primes congruent to 3 modulo 4. The argument
    goes as follows. First, notice that if the product of two numbers \(m\) and \(n\)
    is equal to 3 modulo 4, then one of the two numbers is congruent to 3 modulo 4.
    After all, both have to be odd, and if they are both congruent to 1 modulo 4,
    so is their product. We can use this observation to show that if some number greater
    than 2 is congruent to 3 modulo 4, then that number has a prime divisor that is
    also congruent to 3 modulo 4.
  prefs: []
  type: TYPE_NORMAL
- en: Now suppose there are only finitely many prime numbers congruent to 3 modulo
    4, say, \(p_1, \ldots, p_k\). Without loss of generality, we can assume that \(p_1
    = 3\). Consider the product \(4 \prod_{i = 2}^k p_i + 3\). It is easy to see that
    this is congruent to 3 modulo 4, so it has a prime factor \(p\) congruent to 3
    modulo 4. It can’t be the case that \(p = 3\); since \(p\) divides \(4 \prod_{i
    = 2}^k p_i + 3\), if \(p\) were equal to 3 then it would also divide \(\prod_{i
    = 2}^k p_i\), which implies that \(p\) is equal to one of the \(p_i\) for \(i
    = 2, \ldots, k\); and we have excluded 3 from this list. So \(p\) has to be one
    of the other elements \(p_i\). But in that case, \(p\) divides \(4 \prod_{i =
    2}^k p_i\) and hence 3, which contradicts the fact that it is not 3.
  prefs: []
  type: TYPE_NORMAL
- en: In Lean, the notation `n % m`, read “`n` modulo `m`,” denotes the remainder
    of the division of `n` by `m`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: We can then render the statement “`n` is congruent to 3 modulo 4” as `n % 4
    = 3`. The following example and theorems sum up the facts about this function
    that we will need to use below. The first named theorem is another illustration
    of reasoning by a small number of cases. In the second named theorem, remember
    that the semicolon means that the subsequent tactic block is applied to all the
    goals created by the preceding tactic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: We will also need the following fact, which says that if `m` is a nontrivial
    divisor of `n`, then so is `n / m`. See if you can complete the proof using `Nat.div_dvd_of_dvd`
    and `Nat.div_lt_self`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Now put all the pieces together to prove that any number congruent to 3 modulo
    4 has a prime divisor with that same property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: We are in the home stretch. Given a set `s` of prime numbers, we need to talk
    about the result of removing 3 from that set, if it is present. The function `Finset.erase`
    handles that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to prove that there are infinitely many primes congruent to
    3 modulo 4. Fill in the missing parts below. Our solution uses `Nat.dvd_add_iff_left`
    and `Nat.dvd_sub'` along the way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'If you managed to complete the proof, congratulations! This has been a serious
    feat of formalization.  ## 5.4\. More Induction[](#more-induction "Link to this
    heading")'
  prefs: []
  type: TYPE_NORMAL
- en: In [Section 5.2](#section-induction-and-recursion), we saw how to define the
    factorial function by recursion on the natural numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: We also saw how to prove theorems using the `induction'` tactic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The `induction` tactic (without the prime tick mark) allows for more structured
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: As usual, you can hover over the `induction` keyword to read the documentation.
    The names of the cases, `zero` and `succ`, are taken from the definition of the
    type ℕ. Notice that the `succ` case allows you to choose whatever names you want
    for the induction variable and the inductive hypothesis, here `n` and `ih`. You
    can even prove a theorem with the same notation used to define a recursive function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Notice also the absence of the `:=`, the `∀ n` after the colon, the `by` keyword
    in each case, and the inductive appeal to `fac_pos' n`. It is as though the theorem
    is a recursive function of `n` and in the inductive step we make a recursive call.
  prefs: []
  type: TYPE_NORMAL
- en: This style of definition is remarkably flexible. Lean’s designers have built
    in elaborate means of defining recursive functions, and these extend to doing
    proofs by induction. For example, we can define the Fibonacci function with multiple
    base cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The `@[simp]` annotation means that the simplifier will use the defining equations.
    You can also apply them by writing `rw [fib]`. Below it will be helpful to give
    a name to the `n + 2` case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Using Lean’s notation for recursive functions, you can carry out proofs by induction
    on the natural numbers that mirror the recursive definition of `fib`. The following
    example provides an explicit formula for the nth Fibonacci number in terms of
    the golden mean, `φ`, and its conjugate, `φ'`. We have to tell Lean that we don’t
    expect our definitions to generate code because the arithmetic operations on the
    real numbers are not computable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Induction proofs involving the Fibonacci function do not have to be of that
    form. Below we reproduce the `Mathlib` proof that consecutive Fibonacci numbers
    are coprime.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Using Lean’s computational interpretation, we can evaluate the Fibonacci numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: The straightforward implementation of `fib` is computationally inefficient.
    In fact, it runs in time exponential in its argument. (You should think about
    why.) In Lean, we can implement the following tail-recursive version, whose running
    time is linear in `n`, and prove that it computes the same function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `generalizing` keyword in the proof of `fib'.aux_eq`. It serves to
    insert a `∀ m` in front of the inductive hypothesis, so that in the induction
    step, `m` can take a different value. You can step through the proof and check
    that in this case, the quantifier needs to be instantiated to `m + 1` in the inductive
    step.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also the use of `erw` (for “extended rewrite”) instead of `rw`. This
    is used because to rewrite the goal `fib'.aux_eq`, `fib 0` and `fib 1` have to
    be reduced to `0` and `1`, respectively. The tactic `erw` is more aggressive than
    `rw` in unfolding definitions to match parameters. This isn’t always a good idea;
    it can waste a lot of time in some cases, so use `erw` sparingly.
  prefs: []
  type: TYPE_NORMAL
- en: Here is another example of the `generalizing` keyword in use, in the proof of
    another identity that is found in `Mathlib`. An informal proof of the identity
    can be found [here](https://proofwiki.org/wiki/Fibonacci_Number_in_terms_of_Smaller_Fibonacci_Numbers).
    We provide two variants of the formal proof.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: As an exercise, use `fib_add` to prove the following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Lean’s mechanisms for defining recursive functions are flexible enough to allow
    arbitrary recursive calls, as long the complexity of the arguments decrease according
    to some well-founded measure. In the next example, we show that every natural
    number `n ≠ 1` has a prime divisor, using the fact that if `n` is nonzero and
    not prime, it has a smaller divisor. (You can check that Mathlib has a theorem
    of the same name in the `Nat` namespace, though it has a different proof than
    the one we give here.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The line `rw [ne_one_iff_exists_prime_dvd] at this` is like a magic trick:
    we are using the very theorem we are proving in its own proof. What makes it work
    is that the inductive call is instantiated at `m`, the current case is `n + 2`,
    and the context has `m < n + 2`. Lean can find the hypothesis and use it to show
    that the induction is well-founded. Lean is pretty good at figuring out what is
    decreasing; in this case, the choice of `n` in the statement of the theorem and
    the less-than relation is obvious. In more complicated cases, Lean provides mechanisms
    to provide this information explicitly. See the section on [well-founded recursion](https://lean-lang.org/doc/reference/latest//Definitions/Recursive-Definitions/#well-founded-recursion)
    in the Lean Reference Manual.'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, in a proof, you need to split on cases depending on whether a natural
    number `n` is zero or a successor, without requiring an inductive hypothesis in
    the successor case. For that, you can use the `cases` and `rcases` tactics.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a useful trick. Often you have a theorem about a natural number `n`
    for which the zero case is easy. If you case on `n` and take care of the zero
    case quickly, you are left with the original goal with `n` replaced by `n + 1`.  ##
    5.1\. Irrational Roots[](#irrational-roots "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a fact known to the ancient Greeks, namely, that the square
    root of 2 is irrational. If we suppose otherwise, we can write \(\sqrt{2} = a
    / b\) as a fraction in lowest terms. Squaring both sides yields \(a^2 = 2 b^2\),
    which implies that \(a\) is even. If we write \(a = 2c\), then we get \(4c^2 =
    2 b^2\) and hence \(b^2 = 2 c^2\). This implies that \(b\) is also even, contradicting
    the fact that we have assumed that \(a / b\) has been reduced to lowest terms.
  prefs: []
  type: TYPE_NORMAL
- en: Saying that \(a / b\) is a fraction in lowest terms means that \(a\) and \(b\)
    do not have any factors in common, which is to say, they are *coprime*. Mathlib
    defines the predicate `Nat.Coprime m n` to be `Nat.gcd m n = 1`. Using Lean’s
    anonymous projection notation, if `s` and `t` are expressions of type `Nat`, we
    can write `s.Coprime t` instead of `Nat.Coprime s t`, and similarly for `Nat.gcd`.
    As usual, Lean will often unfold the definition of `Nat.Coprime` automatically
    when necessary, but we can also do it manually by rewriting or simplifying with
    the identifier `Nat.Coprime`. The `norm_num` tactic is smart enough to compute
    concrete values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: We have already encountered the `gcd` function in [Section 2.4](C02_Basics.html#more-on-order-and-divisibility).
    There is also a version of `gcd` for the integers; we will return to a discussion
    of the relationship between different number systems below. There are even a generic
    `gcd` function and generic notions of `Prime` and `Coprime` that make sense in
    general classes of algebraic structures. We will come to understand how Lean manages
    this generality in the next chapter. In the meanwhile, in this section, we will
    restrict attention to the natural numbers.
  prefs: []
  type: TYPE_NORMAL
- en: We also need the notion of a prime number, `Nat.Prime`. The theorem `Nat.prime_def_lt`
    provides one familiar characterization, and `Nat.Prime.eq_one_or_self_of_dvd`
    provides another.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: In the natural numbers, a prime number has the property that it cannot be written
    as a product of nontrivial factors. In a broader mathematical context, an element
    of a ring that has this property is said to be *irreducible*. An element of a
    ring is said to be *prime* if whenever it divides a product, it divides one of
    the factors. It is an important property of the natural numbers that in that setting
    the two notions coincide, giving rise to the theorem `Nat.Prime.dvd_mul`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this fact to establish a key property in the argument above: if
    the square of a number is even, then that number is even as well. Mathlib defines
    the predicate `Even` in `Algebra.Group.Even`, but for reasons that will become
    clear below, we will simply use `2 ∣ m` to express that `m` is even.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: As we proceed, you will need to become proficient at finding the facts you need.
    Remember that if you can guess the prefix of the name and you have imported the
    relevant library, you can use tab completion (sometimes with `ctrl-tab`) to find
    what you are looking for. You can use `ctrl-click` on any identifier to jump to
    the file where it is defined, which enables you to browse definitions and theorems
    nearby. You can also use the search engine on the [Lean community web pages](https://leanprover-community.github.io/),
    and if all else fails, don’t hesitate to ask on [Zulip](https://leanprover.zulipchat.com/).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: The heart of our proof of the irrationality of the square root of two is contained
    in the following theorem. See if you can fill out the proof sketch, using `even_of_even_sqr`
    and the theorem `Nat.dvd_gcd`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: In fact, with very few changes, we can replace `2` by an arbitrary prime. Give
    it a try in the next example. At the end of the proof, you’ll need to derive a
    contradiction from `p ∣ 1`. You can use `Nat.Prime.two_le`, which says that any
    prime number is greater than or equal to two, and `Nat.le_of_dvd`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us consider another approach. Here is a quick proof that if \(p\) is prime,
    then \(m^2 \ne p n^2\): if we assume \(m^2 = p n^2\) and consider the factorization
    of \(m\) and \(n\) into primes, then \(p\) occurs an even number of times on the
    left side of the equation and an odd number of times on the right, a contradiction.
    Note that this argument requires that \(n\) and hence \(m\) are not equal to zero.
    The formalization below confirms that this assumption is sufficient.'
  prefs: []
  type: TYPE_NORMAL
- en: The unique factorization theorem says that any natural number other than zero
    can be written as the product of primes in a unique way. Mathlib contains a formal
    version of this, expressed in terms of a function `Nat.primeFactorsList`, which
    returns the list of prime factors of a number in nondecreasing order. The library
    proves that all the elements of `Nat.primeFactorsList n` are prime, that any `n`
    greater than zero is equal to the product of its factors, and that if `n` is equal
    to the product of another list of prime numbers, then that list is a permutation
    of `Nat.primeFactorsList n`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: You can browse these theorems and others nearby, even though we have not talked
    about list membership, products, or permutations yet. We won’t need any of that
    for the task at hand. We will instead use the fact that Mathlib has a function
    `Nat.factorization`, that represents the same data as a function. Specifically,
    `Nat.factorization n p`, which we can also write `n.factorization p`, returns
    the multiplicity of `p` in the prime factorization of `n`. We will use the following
    three facts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: In fact, `n.factorization` is defined in Lean as a function of finite support,
    which explains the strange notation you will see as you step through the proofs
    above. Don’t worry about this now. For our purposes here, we can use the three
    theorems above as a black box.
  prefs: []
  type: TYPE_NORMAL
- en: The next example shows that the simplifier is smart enough to replace `n^2 ≠
    0` by `n ≠ 0`. The tactic `simpa` just calls `simp` followed by `assumption`.
  prefs: []
  type: TYPE_NORMAL
- en: See if you can use the identities above to fill in the missing parts of the
    proof.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: A nice thing about this proof is that it also generalizes. There is nothing
    special about `2`; with small changes, the proof shows that whenever we write
    `m^k = r * n^k`, the multiplicity of any prime `p` in `r` has to be a multiple
    of `k`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `Nat.count_factors_mul_of_pos` with `r * n^k`, we need to know that
    `r` is positive. But when `r` is zero, the theorem below is trivial, and easily
    proved by the simplifier. So the proof is carried out in cases. The line `rcases
    r with _ | r` replaces the goal with two versions: one in which `r` is replaced
    by `0`, and the other in which `r` is replaces by `r + 1`. In the second case,
    we can use the theorem `r.succ_ne_zero`, which establishes `r + 1 ≠ 0` (`succ`
    stands for successor).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice also that the line that begins `have : npow_nz` provides a short proof-term
    proof of `n^k ≠ 0`. To understand how it works, try replacing it with a tactic
    proof, and then think about how the tactics describe the proof term.'
  prefs: []
  type: TYPE_NORMAL
- en: See if you can fill in the missing parts of the proof below. At the very end,
    you can use `Nat.dvd_sub'` and `Nat.dvd_mul_right` to finish it off.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this example does not assume that `p` is prime, but the conclusion
    is trivial when `p` is not prime since `r.factorization p` is then zero by definition,
    and the proof works in all cases anyway.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: There are a number of ways in which we might want to improve on these results.
    To start with, a proof that the square root of two is irrational should say something
    about the square root of two, which can be understood as an element of the real
    or complex numbers. And stating that it is irrational should say something about
    the rational numbers, namely, that no rational number is equal to it. Moreover,
    we should extend the theorems in this section to the integers. Although it is
    mathematically obvious that if we could write the square root of two as a quotient
    of two integers then we could write it as a quotient of two natural numbers, proving
    this formally requires some effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Mathlib, the natural numbers, the integers, the rationals, the reals, and
    the complex numbers are represented by separate data types. Restricting attention
    to the separate domains is often helpful: we will see that it is easy to do induction
    on the natural numbers, and it is easiest to reason about divisibility of integers
    when the real numbers are not part of the picture. But having to mediate between
    the different domains is a headache, one we will have to contend with. We will
    return to this issue later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: We should also expect to be able to strengthen the conclusion of the last theorem
    to say that the number `r` is a `k`-th power, since its `k`-th root is just the
    product of each prime dividing `r` raised to its multiplicity in `r` divided by
    `k`. To be able to do that we will need better means for reasoning about products
    and sums over a finite set, which is also a topic we will return to.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the results in this section are all established in much greater generality
    in Mathlib, in `Data.Real.Irrational`. The notion of `multiplicity` is defined
    for an arbitrary commutative monoid, and that it takes values in the extended
    natural numbers `enat`, which adds the value infinity to the natural numbers.
    In the next chapter, we will begin to develop the means to appreciate the way
    that Lean supports this sort of generality.
  prefs: []
  type: TYPE_NORMAL
- en: '## 5.2\. Induction and Recursion[](#induction-and-recursion "Link to this
    heading")'
  prefs: []
  type: TYPE_NORMAL
- en: The set of natural numbers \(\mathbb{N} = \{ 0, 1, 2, \ldots \}\) is not only
    fundamentally important in its own right, but also a plays a central role in the
    construction of new mathematical objects. Lean’s foundation allows us to declare
    *inductive types*, which are types generated inductively by a given list of *constructors*.
    In Lean, the natural numbers are declared as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find this in the library by writing `#check Nat` and then using `ctrl-click`
    on the identifier `Nat`. The command specifies that `Nat` is the datatype generated
    freely and inductively by the two constructors `zero : Nat` and `succ : Nat →
    Nat`. Of course, the library introduces notation `ℕ` and `0` for `nat` and `zero`
    respectively. (Numerals are translated to binary representations, but we don’t
    have to worry about the details of that now.)'
  prefs: []
  type: TYPE_NORMAL
- en: What “freely” means for the working mathematician is that the type `Nat` has
    an element `zero` and an injective successor function `succ` whose image does
    not include `zero`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: What the word “inductively” means for the working mathematician is that the
    natural numbers comes with a principle of proof by induction and a principle of
    definition by recursion. This section will show you how to use these.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example of a recursive definition of the factorial function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: The syntax takes some getting used to. Notice that there is no `:=` on the first
    line. The next two lines provide the base case and inductive step for a recursive
    definition. These equations hold definitionally, but they can also be used manually
    by giving the name `fac` to `simp` or `rw`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: The factorial function is actually already defined in Mathlib as `Nat.factorial`.
    Once again, you can jump to it by typing `#check Nat.factorial` and using `ctrl-click.`
    For illustrative purposes, we will continue using `fac` in the examples. The annotation
    `@[simp]` before the definition of `Nat.factorial` specifies that the defining
    equation should be added to the database of identities that the simplifier uses
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The principle of induction says that we can prove a general statement about
    the natural numbers by proving that the statement holds of 0 and that whenever
    it holds of a natural number \(n\), it also holds of \(n + 1\). The line `induction''
    n with n ih` in the proof below therefore results in two goals: in the first we
    need to prove `0 < fac 0`, and in the second we have the added assumption `ih
    : 0 < fac n` and a required to prove `0 < fac (n + 1)`. The phrase `with n ih`
    serves to name the variable and the assumption for the inductive hypothesis, and
    you can choose whatever names you want for them.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: The `induction'` tactic is smart enough to include hypotheses that depend on
    the induction variable as part of the induction hypothesis. Step through the next
    example to see what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: The following example provides a crude lower bound for the factorial function.
    It turns out to be easier to start with a proof by cases, so that the remainder
    of the proof starts with the case \(n = 1\). See if you can complete the argument
    with a proof by induction using `pow_succ` or `pow_succ'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Induction is often used to prove identities involving finite sums and products.
    Mathlib defines the expressions `Finset.sum s f` where `s : Finset α` is a finite
    set of elements of the type `α` and `f` is a function defined on `α`. The codomain
    of `f` can be any type that supports a commutative, associative addition operation
    with a zero element. If you import `Algebra.BigOperators.Ring` and issue the command
    `open BigOperators`, you can use the more suggestive notation `∑ x ∈ s, f x`.
    Of course, there is an analogous operation and notation for finite products.'
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about the `Finset` type and the operations it supports in the next
    section, and again in a later chapter. For now, we will only make use of `Finset.range
    n`, which is the finite set of natural numbers less than `n`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: The facts `Finset.sum_range_zero` and `Finset.sum_range_succ` provide a recursive
    description of summation up to \(n\), and similarly for products.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: The first identity in each pair holds definitionally, which is to say, you can
    replace the proofs by `rfl`.
  prefs: []
  type: TYPE_NORMAL
- en: The following expresses the factorial function that we defined as a product.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: The fact that we include `mul_comm` as a simplification rule deserves comment.
    It should seem dangerous to simplify with the identity `x * y = y * x`, which
    would ordinarily loop indefinitely. Lean’s simplifier is smart enough to recognize
    that, and applies the rule only in the case where the resulting term has a smaller
    value in some fixed but arbitrary ordering of the terms. The following example
    shows that simplifying using the three rules `mul_assoc`, `mul_comm`, and `mul_left_comm`
    manages to identify products that are the same up to the placement of parentheses
    and ordering of variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Roughly, the rules work by pushing parentheses to the right and then re-ordering
    the expressions on both sides until they both follow the same canonical order.
    Simplifying with these rules, and the corresponding rules for addition, is a handy
    trick.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to summation identities, we suggest stepping through the following
    proof that the sum of the natural numbers up to and including \(n\) is \(n (n
    + 1) / 2\). The first step of the proof clears the denominator. This is generally
    useful when formalizing identities, because calculations with division generally
    have side conditions. (It is similarly useful to avoid using subtraction on the
    natural numbers when possible.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: We encourage you to prove the analogous identity for sums of squares, and other
    identities you can find on the web.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: In Lean’s core library, addition and multiplication are themselves defined using
    recursive definitions, and their fundamental properties are established using
    induction. If you like thinking about foundational topics like that, you might
    enjoy working through proofs of the commutativity and associativity of multiplication
    and addition and the distributivity of multiplication over addition. You can do
    this on a copy of the natural numbers following the outline below. Notice that
    we can use the `induction` tactic with `MyNat`; Lean is smart enough to know to
    use the relevant induction principle (which is, of course, the same as that for
    `Nat`).
  prefs: []
  type: TYPE_NORMAL
- en: We start you off with the commutativity of addition. A good rule of thumb is
    that because addition and multiplication are defined by recursion on the second
    argument, it is generally advantageous to do proofs by induction on a variable
    that occurs in that position. It is a bit tricky to decide which variable to use
    in the proof of associativity.
  prefs: []
  type: TYPE_NORMAL
- en: It can be confusing to write things without the usual notation for zero, one,
    addition, and multiplication. We will learn how to define such notation later.
    Working in the namespace `MyNat` means that we can write `zero` and `succ` rather
    than `MyNat.zero` and `MyNat.succ`, and that these interpretations of the names
    take precedence over others. Outside the namespace, the full name of the `add`
    defined below, for example, is `MyNat.add`.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you *really* enjoy this sort of thing, try defining truncated
    subtraction and exponentiation and proving some of their properties as well. Remember
    that truncated subtraction cuts off at zero. To define that, it is useful to define
    a predecessor function, `pred`, that subtracts one from any nonzero number and
    fixes zero. The function `pred` can be defined by a simple instance of recursion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '## 5.3\. Infinitely Many Primes[](#infinitely-many-primes "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us continue our exploration of induction and recursion with another mathematical
    standard: a proof that there are infinitely many primes. One way to formulate
    this is as the statement that for every natural number \(n\), there is a prime
    number greater than \(n\). To prove this, let \(p\) be any prime factor of \(n!
    + 1\). If \(p\) is less than or equal to \(n\), it divides \(n!\). Since it also
    divides \(n! + 1\), it divides 1, a contradiction. Hence \(p\) is greater than
    \(n\).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To formalize that proof, we need to show that any number greater than or equal
    to 2 has a prime factor. To do that, we will need to show that any natural number
    that is not equal to 0 or 1 is greater-than or equal to 2. And this brings us
    to a quirky feature of formalization: it is often trivial statements like this
    that are among the most annoying to formalize. Here we consider a few ways to
    do it.'
  prefs: []
  type: TYPE_NORMAL
- en: To start with, we can use the `cases` tactic and the fact that the successor
    function respects the ordering on the natural numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Another strategy is to use the tactic `interval_cases`, which automatically
    splits the goal into cases when the variable in question is contained in an interval
    of natural numbers or integers. Remember that you can hover over it to see its
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Recall that the semicolon after `interval_cases m` means that the next tactic
    is applied to each of the cases that it generates. Yet another option is to use
    the tactic `decide`, which tries to find a decision procedure to solve the problem.
    Lean knows that you can decide the truth value of a statement that begins with
    a bounded quantifier `∀ x, x < n → ...` or `∃ x, x < n ∧ ...` by deciding each
    of the finitely many instances.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: With the theorem `two_le` in hand, let’s start by showing that every natural
    number greater than two has a prime divisor. Mathlib contains a function `Nat.minFac`
    that returns the smallest prime divisor, but for the sake of learning new parts
    of the library, we’ll avoid using it and prove the theorem directly.
  prefs: []
  type: TYPE_NORMAL
- en: Here, ordinary induction isn’t enough. We want to use *strong induction*, which
    allows us to prove that every natural number \(n\) has a property \(P\) by showing
    that for every number \(n\), if \(P\) holds of all values less than \(n\), it
    holds at \(n\) as well. In Lean, this principle is called `Nat.strong_induction_on`,
    and we can use the `using` keyword to tell the induction tactic to use it. Notice
    that when we do that, there is no base case; it is subsumed by the general induction
    step.
  prefs: []
  type: TYPE_NORMAL
- en: The argument is simply as follows. Assuming \(n ≥ 2\), if \(n\) is prime, we’re
    done. If it isn’t, then by one of the characterizations of what it means to be
    a prime number, it has a nontrivial factor, \(m\), and we can apply the inductive
    hypothesis to that. Step through the next proof to see how that plays out.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: We can now prove the following formulation of our theorem. See if you can fill
    out the sketch. You can use `Nat.factorial_pos`, `Nat.dvd_factorial`, and `Nat.dvd_sub'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Let’s consider a variation of the proof above, where instead of using the factorial
    function, we suppose that we are given by a finite set \(\{ p_1, \ldots, p_n \}\)
    and we consider a prime factor of \(\prod_{i = 1}^n p_i + 1\). That prime factor
    has to be distinct from each \(p_i\), showing that there is no finite set that
    contains all the prime numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Formalizing this argument requires us to reason about finite sets. In Lean,
    for any type `α`, the type `Finset α` represents finite sets of elements of type
    `α`. Reasoning about finite sets computationally requires having a procedure to
    test equality on `α`, which is why the snippet below includes the assumption `[DecidableEq
    α]`. For concrete data types like `ℕ`, `ℤ`, and `ℚ`, the assumption is satisfied
    automatically. When reasoning about the real numbers, it can be satisfied using
    classical logic and abandoning the computational interpretation.
  prefs: []
  type: TYPE_NORMAL
- en: We use the command `open Finset` to avail ourselves of shorter names for the
    relevant theorems. Unlike the case with sets, most equivalences involving finsets
    do not hold definitionally, so they need to be expanded manually using equivalences
    like `Finset.subset_iff`, `Finset.mem_union`, `Finset.mem_inter`, and `Finset.mem_sdiff`.
    The `ext` tactic can still be used to show that two finite sets are equal by showing
    that every element of one is an element of the other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used a new trick: the `tauto` tactic (and a strengthened version, `tauto!`,
    which uses classical logic) can be used to dispense with propositional tautologies.
    See if you can use these methods to prove the two examples below.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: The theorem `Finset.dvd_prod_of_mem` tells us that if an `n` is an element of
    a finite set `s`, then `n` divides `∏ i ∈ s, i`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: We also need to know that the converse holds in the case where `n` is prime
    and `s` is a set of primes. To show that, we need the following lemma, which you
    should be able to prove using the theorem `Nat.Prime.eq_one_or_self_of_dvd`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this lemma to show that if a prime `p` divides a product of a finite
    set of primes, then it is equal to one of them. Mathlib provides a useful principle
    of induction on finite sets: to show that a property holds of an arbitrary finite
    set `s`, show that it holds of the empty set, and show that it is preserved when
    we add a single new element `a ∉ s`. The principle is known as `Finset.induction_on`.
    When we tell the induction tactic to use it, we can also specify the names `a`
    and `s`, the name for the assumption `a ∉ s` in the inductive step, and the name
    of the inductive hypothesis. The expression `Finset.insert a s` denotes the union
    of `s` with the singleton `a`. The identities `Finset.prod_empty` and `Finset.prod_insert`
    then provide the relevant rewrite rules for the product. In the proof below, the
    first `simp` applies `Finset.prod_empty`. Step through the beginning of the proof
    to see the induction unfold, and then finish it off.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'We need one last property of finite sets. Given an element `s : Set α` and
    a predicate `P` on `α`, in [Chapter 4](C04_Sets_and_Functions.html#sets-and-functions)
    we wrote `{ x ∈ s | P x }` for the set of elements of `s` that satisfy `P`. Given
    `s : Finset α`, the analogous notion is written `s.filter P`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'We now prove an alternative formulation of the statement that there are infinitely
    many primes, namely, that given any `s : Finset ℕ`, there is a prime `p` that
    is not an element of `s`. Aiming for a contradiction, we assume that all the primes
    are in `s`, and then cut down to a set `s''` that contains all and only the primes.
    Taking the product of that set, adding one, and finding a prime factor of the
    result leads to the contradiction we are looking for. See if you can complete
    the sketch below. You can use `Finset.prod_pos` in the proof of the first `have`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'We have thus seen two ways of saying that there are infinitely many primes:
    saying that they are not bounded by any `n`, and saying that they are not contained
    in any finite set `s`. The two proofs below show that these formulations are equivalent.
    In the second, in order to form `s.filter Q`, we have to assume that there is
    a procedure for deciding whether or not `Q` holds. Lean knows that there is a
    procedure for `Nat.Prime`. In general, if we use classical logic by writing `open
    Classical`, we can dispense with the assumption.'
  prefs: []
  type: TYPE_NORMAL
- en: In Mathlib, `Finset.sup s f` denotes the supremum of the values of `f x` as
    `x` ranges over `s`, returning `0` in the case where `s` is empty and the codomain
    of `f` is `ℕ`. In the first proof, we use `s.sup id`, where `id` is the identity
    function, to refer to the maximum value in `s`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: A small variation on our second proof that there are infinitely many primes
    shows that there are infinitely many primes congruent to 3 modulo 4. The argument
    goes as follows. First, notice that if the product of two numbers \(m\) and \(n\)
    is equal to 3 modulo 4, then one of the two numbers is congruent to 3 modulo 4.
    After all, both have to be odd, and if they are both congruent to 1 modulo 4,
    so is their product. We can use this observation to show that if some number greater
    than 2 is congruent to 3 modulo 4, then that number has a prime divisor that is
    also congruent to 3 modulo 4.
  prefs: []
  type: TYPE_NORMAL
- en: Now suppose there are only finitely many prime numbers congruent to 3 modulo
    4, say, \(p_1, \ldots, p_k\). Without loss of generality, we can assume that \(p_1
    = 3\). Consider the product \(4 \prod_{i = 2}^k p_i + 3\). It is easy to see that
    this is congruent to 3 modulo 4, so it has a prime factor \(p\) congruent to 3
    modulo 4. It can’t be the case that \(p = 3\); since \(p\) divides \(4 \prod_{i
    = 2}^k p_i + 3\), if \(p\) were equal to 3 then it would also divide \(\prod_{i
    = 2}^k p_i\), which implies that \(p\) is equal to one of the \(p_i\) for \(i
    = 2, \ldots, k\); and we have excluded 3 from this list. So \(p\) has to be one
    of the other elements \(p_i\). But in that case, \(p\) divides \(4 \prod_{i =
    2}^k p_i\) and hence 3, which contradicts the fact that it is not 3.
  prefs: []
  type: TYPE_NORMAL
- en: In Lean, the notation `n % m`, read “`n` modulo `m`,” denotes the remainder
    of the division of `n` by `m`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: We can then render the statement “`n` is congruent to 3 modulo 4” as `n % 4
    = 3`. The following example and theorems sum up the facts about this function
    that we will need to use below. The first named theorem is another illustration
    of reasoning by a small number of cases. In the second named theorem, remember
    that the semicolon means that the subsequent tactic block is applied to all the
    goals created by the preceding tactic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: We will also need the following fact, which says that if `m` is a nontrivial
    divisor of `n`, then so is `n / m`. See if you can complete the proof using `Nat.div_dvd_of_dvd`
    and `Nat.div_lt_self`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Now put all the pieces together to prove that any number congruent to 3 modulo
    4 has a prime divisor with that same property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: We are in the home stretch. Given a set `s` of prime numbers, we need to talk
    about the result of removing 3 from that set, if it is present. The function `Finset.erase`
    handles that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to prove that there are infinitely many primes congruent to
    3 modulo 4. Fill in the missing parts below. Our solution uses `Nat.dvd_add_iff_left`
    and `Nat.dvd_sub'` along the way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: If you managed to complete the proof, congratulations! This has been a serious
    feat of formalization.
  prefs: []
  type: TYPE_NORMAL
- en: '## 5.4\. More Induction[](#more-induction "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: In [Section 5.2](#section-induction-and-recursion), we saw how to define the
    factorial function by recursion on the natural numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: We also saw how to prove theorems using the `induction'` tactic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: The `induction` tactic (without the prime tick mark) allows for more structured
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: As usual, you can hover over the `induction` keyword to read the documentation.
    The names of the cases, `zero` and `succ`, are taken from the definition of the
    type ℕ. Notice that the `succ` case allows you to choose whatever names you want
    for the induction variable and the inductive hypothesis, here `n` and `ih`. You
    can even prove a theorem with the same notation used to define a recursive function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Notice also the absence of the `:=`, the `∀ n` after the colon, the `by` keyword
    in each case, and the inductive appeal to `fac_pos' n`. It is as though the theorem
    is a recursive function of `n` and in the inductive step we make a recursive call.
  prefs: []
  type: TYPE_NORMAL
- en: This style of definition is remarkably flexible. Lean’s designers have built
    in elaborate means of defining recursive functions, and these extend to doing
    proofs by induction. For example, we can define the Fibonacci function with multiple
    base cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: The `@[simp]` annotation means that the simplifier will use the defining equations.
    You can also apply them by writing `rw [fib]`. Below it will be helpful to give
    a name to the `n + 2` case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Using Lean’s notation for recursive functions, you can carry out proofs by induction
    on the natural numbers that mirror the recursive definition of `fib`. The following
    example provides an explicit formula for the nth Fibonacci number in terms of
    the golden mean, `φ`, and its conjugate, `φ'`. We have to tell Lean that we don’t
    expect our definitions to generate code because the arithmetic operations on the
    real numbers are not computable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Induction proofs involving the Fibonacci function do not have to be of that
    form. Below we reproduce the `Mathlib` proof that consecutive Fibonacci numbers
    are coprime.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Using Lean’s computational interpretation, we can evaluate the Fibonacci numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: The straightforward implementation of `fib` is computationally inefficient.
    In fact, it runs in time exponential in its argument. (You should think about
    why.) In Lean, we can implement the following tail-recursive version, whose running
    time is linear in `n`, and prove that it computes the same function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `generalizing` keyword in the proof of `fib'.aux_eq`. It serves to
    insert a `∀ m` in front of the inductive hypothesis, so that in the induction
    step, `m` can take a different value. You can step through the proof and check
    that in this case, the quantifier needs to be instantiated to `m + 1` in the inductive
    step.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also the use of `erw` (for “extended rewrite”) instead of `rw`. This
    is used because to rewrite the goal `fib'.aux_eq`, `fib 0` and `fib 1` have to
    be reduced to `0` and `1`, respectively. The tactic `erw` is more aggressive than
    `rw` in unfolding definitions to match parameters. This isn’t always a good idea;
    it can waste a lot of time in some cases, so use `erw` sparingly.
  prefs: []
  type: TYPE_NORMAL
- en: Here is another example of the `generalizing` keyword in use, in the proof of
    another identity that is found in `Mathlib`. An informal proof of the identity
    can be found [here](https://proofwiki.org/wiki/Fibonacci_Number_in_terms_of_Smaller_Fibonacci_Numbers).
    We provide two variants of the formal proof.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: As an exercise, use `fib_add` to prove the following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Lean’s mechanisms for defining recursive functions are flexible enough to allow
    arbitrary recursive calls, as long the complexity of the arguments decrease according
    to some well-founded measure. In the next example, we show that every natural
    number `n ≠ 1` has a prime divisor, using the fact that if `n` is nonzero and
    not prime, it has a smaller divisor. (You can check that Mathlib has a theorem
    of the same name in the `Nat` namespace, though it has a different proof than
    the one we give here.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'The line `rw [ne_one_iff_exists_prime_dvd] at this` is like a magic trick:
    we are using the very theorem we are proving in its own proof. What makes it work
    is that the inductive call is instantiated at `m`, the current case is `n + 2`,
    and the context has `m < n + 2`. Lean can find the hypothesis and use it to show
    that the induction is well-founded. Lean is pretty good at figuring out what is
    decreasing; in this case, the choice of `n` in the statement of the theorem and
    the less-than relation is obvious. In more complicated cases, Lean provides mechanisms
    to provide this information explicitly. See the section on [well-founded recursion](https://lean-lang.org/doc/reference/latest//Definitions/Recursive-Definitions/#well-founded-recursion)
    in the Lean Reference Manual.'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, in a proof, you need to split on cases depending on whether a natural
    number `n` is zero or a successor, without requiring an inductive hypothesis in
    the successor case. For that, you can use the `cases` and `rcases` tactics.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: This is a useful trick. Often you have a theorem about a natural number `n`
    for which the zero case is easy. If you case on `n` and take care of the zero
    case quickly, you are left with the original goal with `n` replaced by `n + 1`.*
  prefs: []
  type: TYPE_NORMAL
