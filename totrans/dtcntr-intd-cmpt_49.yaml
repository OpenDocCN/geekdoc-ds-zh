- en: 16.2¬†The Size of a DAGüîó
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://dcic-world.org/2025-08-27/size-of-dag.html](https://dcic-world.org/2025-08-27/size-of-dag.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| ¬†¬†¬†¬†[16.2.1¬†Stage 1](#%28part._.Stage_1%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[16.2.2¬†Stage 2](#%28part._.Stage_2%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[16.2.3¬†Stage 3](#%28part._.Stage_3%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[16.2.4¬†Stage 4](#%28part._.Stage_4%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[16.2.5¬†Stage 5](#%28part._.Stage_5%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[16.2.6¬†What We‚Äôve Learned](#%28part._.What_.We~e2~80~99ve_.Learned%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[16.2.7¬†More on Value Printing: An Aside from Racket](#%28part._.More_on_.Value_.Printing__.An_.Aside_from_.Racket%29)
    |'
  prefs: []
  type: TYPE_TB
- en: 'Let‚Äôs start by defining a function to compute the size of a tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is straightforward enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'But let‚Äôs say that our input isn‚Äôt actually a tree, but rather a DAG. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'where `n4` is the DAG. There are two notions of size here. One is like a ‚Äúprint
    size‚Äù: how much space will it occupy when printed. The current size function computes
    that well. But another is the ‚Äúallocation‚Äù size: how many nodes did we allocate.
    How do we fare?'
  prefs: []
  type: TYPE_NORMAL
- en: 16.2.1¬†Stage 1[üîó](#(part._.Stage_1) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Clearly the answer should be `4`: we can just read off how many `nd` calls
    there are. And clearly the function is wrong.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem, of course, is that a DAG involves repeating nodes, and we aren‚Äôt
    doing anything to track the repetition. So we need a stronger contract: we‚Äôll
    split the problem into two parts, a standard interface function that takes just
    the DAG and returns a number, and a richer helper function, which also takes a
    memory of the nodes already seen.'
  prefs: []
  type: TYPE_NORMAL
- en: 16.2.2¬†Stage 2[üîó](#(part._.Stage_2) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does this code use `member-identical` rather than `member`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe that if we replace every `member-identical` with `member` in this chapter,
    the code still behaves the same. Why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make changes to demonstrate the need for `member-identical`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Is it odd that we return `0`? Not if we reinterpret what the function does:
    it doesn‚Äôt count the size, it counts the additional contribution to the size (relative
    to what has already been seen) of the `BT` it is given. A node already in `seen`
    makes no marginal contribution; it was already counted earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we should not export such a function to the user, who has to deal
    with an unwieldy extra parameter and may send something poorly-formed, thereby
    causing our function to break. Instead, we should write a wrapper for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This also enables us to use our old tests (renamed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, this still doesn‚Äôt work!
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use Pyret‚Äôs `spy` construct in `size-2-h` to figure out why.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 16.2.3¬†Stage 3[üîó](#(part._.Stage_3) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Did you remember to use `spy`? Otherwise you may very well miss the problem!
    Be sure to use `spy` (feel free to elide the first few tests for now) to get a
    feel for the issue.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noted, the problem is that we want `seen` to be all the nodes
    ever seen. However, every time we return from one sub-computation, we also lose
    track of whatever was seen during its work. Instead, we have to also return everything
    that was seen, so as to properly preserve the idea that we‚Äôre computing the marginal
    contribution of each node.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this with the following data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'which is returned by the helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Note, crucially, how the `seen` argument for the right branch is `rl.sn`: i.e.,
    everything that was already seen in the left branch. This is the crucial step
    that avoids the bug.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of this richer return type, we have to extract the actual answer for
    the purpose of testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Must `seen` be a list? What else can it be?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 16.2.4¬†Stage 4[üîó](#(part._.Stage_4) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Observe that the `Ret` data structure is only of local interest. It‚Äôs purely
    internal to the `size-3-h` function; even `size-3` ignores one half, and it will
    never be seen by the rest of the program. That is a good use of tuples, as we
    have seen before: [Using Tuples](queues-from-lists.html#%28part._qfl-tuples%29)!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The notation `{0; seen}` makes an actual tuple; `{Number; List<BT>}` declares
    the contract of a tuple. Also, `.{0}` extracts the `0`th element (the leftmost
    one) of a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 16.2.5¬†Stage 5[üîó](#(part._.Stage_5) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice that we have the two instances of the code `{0; seen}`. Do they have
    to be that? What if we were to return `{0; empty}` instead in both places? Does
    anything break?
  prefs: []
  type: TYPE_NORMAL
- en: We might expect it to break in the case where `member-identical` returns `true`,
    but perhaps not in the `mt` case.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make each of these changes. Does the outcome match your expectations?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Curiously, no! Making the change in the `mt` case has an effect but making it
    in the `member-identical` case doesn‚Äôt! This almost seems counter-intuitive. How
    can we diagnose this?
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use `spy` to determine what is going on!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Okay, so it seems like returning `empty` when we revisit a node doesn‚Äôt seem
    to do any harm. Does that mean it‚Äôs okay to make that change?
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe that nothing has actually depended on that seen-list being `empty`.
    That‚Äôs why it appears to not matter. How can we make it matter? By making it ‚Äúhurt‚Äù
    the computation by visiting a previously seen, but now forgotten, node yet again.
    So we need to visit a node at least three times: the first time to remember it;
    the second time to forget it; and a third time to incorrectly visit it again.
    Here‚Äôs a DAG that will do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Sure enough, if either tuple now returns `empty`, this test fails. Otherwise
    it succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: 16.2.6¬†What We‚Äôve Learned[üîó](#(part._.What_.We~e2~80~99ve_.Learned) "Link to
    here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have learned three important principles here:'
  prefs: []
  type: TYPE_NORMAL
- en: A pattern for dealing with programs that need ‚Äúmemory‚Äù. This is called threading
    (not in the sense of ‚Äúmulti-threading‚Äù, which is a kind of parallel computation,
    but rather the pattern of how the seen list gets passed through the program).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A good example of the use of tuples: local, where the documentation benefit
    of datatypes isn‚Äôt necessary (and the extra datatype probably just clutters up
    the program), as opposed to distant, where it is. In general, it‚Äôs always okay
    to make a new datatype; it‚Äôs only sometimes okay to use tuples in their place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An important software-engineering principle, called mutation testing. This is
    an odd name because it would seem to be the name of a technique to test programs.
    Actually, it‚Äôs a technique to test test suites. You have a tested program; you
    then ‚Äúmutate‚Äù some part of your program that you feel must change the output,
    and see whether any tests break. If no tests break, then either you‚Äôve misunderstood
    your program or, more likely, your test suite is not good enough. Improve your
    test suite to catch the error in your program, or convince yourself the change
    didn‚Äôt matter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are mutation testing tools that will randomly try to alter your program
    using ‚Äúmutant‚Äù strategies‚Äî<wbr>e.g., replacing a `+` with a `-`‚Äî<wbr>and re-run
    your suites, and then report back on how many potential mutants the suites actually
    caught. But we can‚Äôt and shouldn‚Äôt only rely on tools; we can also apply the principle
    of mutation testing by hand, as we have above. At the very least, it will help
    us understand our program better!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '16.2.7¬†More on Value Printing: An Aside from Racket[üîó](#(part._.More_on_.Value_.Printing__.An_.Aside_from_.Racket)
    "Link to here")'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Earlier, we talked about how the standard recursive size can still be thought
    of as a ‚Äúsize of printed value‚Äù computation. However, that actually depends on
    your language‚Äôs value printer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Racket, you can turn on (it‚Äôs slightly more expensive, so off by default)
    a value-printer that shows value sharing: Language | Choose Language ‚Ä¶ | Show
    Details | Show sharing in values. So if we take the data definition above and
    translate it into Racket structures'
  prefs: []
  type: TYPE_NORMAL
- en: '| (struct mt () #:transparent) |'
  prefs: []
  type: TYPE_TB
- en: '| (struct nd (v l r) #:transparent) |'
  prefs: []
  type: TYPE_TB
- en: 'and then construct (almost) the same data as in the first example:'
  prefs: []
  type: TYPE_NORMAL
- en: '| (define n1 (nd 1 (mt) (mt))) |'
  prefs: []
  type: TYPE_TB
- en: '| (define n2 (nd 2 (mt) n1)) |'
  prefs: []
  type: TYPE_TB
- en: '| (define n3 (nd 3 n1 (mt))) |'
  prefs: []
  type: TYPE_TB
- en: '| (define n4 (nd 4 n2 n3)) |'
  prefs: []
  type: TYPE_TB
- en: 'and then ask Racket to print it, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '| > n4 |'
  prefs: []
  type: TYPE_TB
- en: '| (nd 4 (nd 2 (mt) #0=(nd 1 (mt) (mt))) (nd 3 #0# (mt))) |'
  prefs: []
  type: TYPE_TB
- en: 'The #0= notation is the moral equivalent of saying, ‚ÄúI‚Äôm going to refer to
    this value again later, so let‚Äôs call it the 0th value‚Äù and #0# is saying ‚ÄúHere
    I‚Äôm referring to the aforementioned 0th value‚Äù.'
  prefs: []
  type: TYPE_NORMAL
- en: (Yes, there can be more than one shared value in an output, so each is given
    a different ‚Äúname‚Äù. We‚Äôll see that in a moment.)
  prefs: []
  type: TYPE_NORMAL
- en: The later example above translates to
  prefs: []
  type: TYPE_NORMAL
- en: '| (define n13 (nd 13 (mt) (mt))) |'
  prefs: []
  type: TYPE_TB
- en: '| (define n11 (nd 11 n13 n13)) |'
  prefs: []
  type: TYPE_TB
- en: '| (define n12 (nd 12 n13 (mt))) |'
  prefs: []
  type: TYPE_TB
- en: '| (define n10 (nd 10 n11 n12)) |'
  prefs: []
  type: TYPE_TB
- en: which prints as
  prefs: []
  type: TYPE_NORMAL
- en: '| > n10 |'
  prefs: []
  type: TYPE_TB
- en: '| (nd 10 (nd 11 #0=(nd 13 (mt) (mt)) #0#) (nd 12 #0# (mt))) |'
  prefs: []
  type: TYPE_TB
- en: So it is possible for a language to reflect the sharing in its output. It‚Äôs
    just that most programming languages choose to not do that, even optionally.
  prefs: []
  type: TYPE_NORMAL
- en: Remember the ‚Äúalmost‚Äù above? What was that about?
  prefs: []
  type: TYPE_NORMAL
- en: 'In Racket, we‚Äôve made a new instance of mt over and over. We can more accurately
    reflect what is happening in Pyret by instantiating it only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '| (struct mt () #:transparent) |'
  prefs: []
  type: TYPE_TB
- en: '| (define the-mt (mt)) |'
  prefs: []
  type: TYPE_TB
- en: '| (struct nd (v l r) #:transparent) |'
  prefs: []
  type: TYPE_TB
- en: 'We then rewrite the earlier example to use that one instance only:'
  prefs: []
  type: TYPE_NORMAL
- en: '| (define n1 (nd 1 the-mt the-mt)) |'
  prefs: []
  type: TYPE_TB
- en: '| (define n2 (nd 2 the-mt n1)) |'
  prefs: []
  type: TYPE_TB
- en: '| (define n3 (nd 3 n1 the-mt)) |'
  prefs: []
  type: TYPE_TB
- en: '| (define n4 (nd 4 n2 n3)) |'
  prefs: []
  type: TYPE_TB
- en: 'And now when we print it:'
  prefs: []
  type: TYPE_NORMAL
- en: '| > n4 |'
  prefs: []
  type: TYPE_TB
- en: '| (nd 4 (nd 2 #0=(mt) #1=(nd 1 #0# #0#)) (nd 3 #1# #0#)) |'
  prefs: []
  type: TYPE_TB
- en: 'And now you can see there are two different shared values, one is the single
    instance of mt, the other is the nd with 1 in it. Thus, Racket uses both #0= /
    #0# and #1= / #1#. Notice how all the leaves are sharing the same mt instance.
    (The numbering is picked in the order in which nodes are encountered while traversing,
    which is why the nd instance was #0 the previous time and is #1 this time.)'
  prefs: []
  type: TYPE_NORMAL
- en: 16.2.1¬†Stage 1[üîó](#(part._.Stage_1) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Clearly the answer should be `4`: we can just read off how many `nd` calls
    there are. And clearly the function is wrong.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem, of course, is that a DAG involves repeating nodes, and we aren‚Äôt
    doing anything to track the repetition. So we need a stronger contract: we‚Äôll
    split the problem into two parts, a standard interface function that takes just
    the DAG and returns a number, and a richer helper function, which also takes a
    memory of the nodes already seen.'
  prefs: []
  type: TYPE_NORMAL
- en: 16.2.2¬†Stage 2[üîó](#(part._.Stage_2) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does this code use `member-identical` rather than `member`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe that if we replace every `member-identical` with `member` in this chapter,
    the code still behaves the same. Why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make changes to demonstrate the need for `member-identical`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Is it odd that we return `0`? Not if we reinterpret what the function does:
    it doesn‚Äôt count the size, it counts the additional contribution to the size (relative
    to what has already been seen) of the `BT` it is given. A node already in `seen`
    makes no marginal contribution; it was already counted earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we should not export such a function to the user, who has to deal
    with an unwieldy extra parameter and may send something poorly-formed, thereby
    causing our function to break. Instead, we should write a wrapper for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This also enables us to use our old tests (renamed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, this still doesn‚Äôt work!
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use Pyret‚Äôs `spy` construct in `size-2-h` to figure out why.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 16.2.3¬†Stage 3[üîó](#(part._.Stage_3) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Did you remember to use `spy`? Otherwise you may very well miss the problem!
    Be sure to use `spy` (feel free to elide the first few tests for now) to get a
    feel for the issue.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noted, the problem is that we want `seen` to be all the nodes
    ever seen. However, every time we return from one sub-computation, we also lose
    track of whatever was seen during its work. Instead, we have to also return everything
    that was seen, so as to properly preserve the idea that we‚Äôre computing the marginal
    contribution of each node.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this with the following data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'which is returned by the helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note, crucially, how the `seen` argument for the right branch is `rl.sn`: i.e.,
    everything that was already seen in the left branch. This is the crucial step
    that avoids the bug.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of this richer return type, we have to extract the actual answer for
    the purpose of testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Must `seen` be a list? What else can it be?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 16.2.4¬†Stage 4[üîó](#(part._.Stage_4) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Observe that the `Ret` data structure is only of local interest. It‚Äôs purely
    internal to the `size-3-h` function; even `size-3` ignores one half, and it will
    never be seen by the rest of the program. That is a good use of tuples, as we
    have seen before: [Using Tuples](queues-from-lists.html#%28part._qfl-tuples%29)!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The notation `{0; seen}` makes an actual tuple; `{Number; List<BT>}` declares
    the contract of a tuple. Also, `.{0}` extracts the `0`th element (the leftmost
    one) of a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 16.2.5¬†Stage 5[üîó](#(part._.Stage_5) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice that we have the two instances of the code `{0; seen}`. Do they have
    to be that? What if we were to return `{0; empty}` instead in both places? Does
    anything break?
  prefs: []
  type: TYPE_NORMAL
- en: We might expect it to break in the case where `member-identical` returns `true`,
    but perhaps not in the `mt` case.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make each of these changes. Does the outcome match your expectations?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Curiously, no! Making the change in the `mt` case has an effect but making it
    in the `member-identical` case doesn‚Äôt! This almost seems counter-intuitive. How
    can we diagnose this?
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use `spy` to determine what is going on!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Okay, so it seems like returning `empty` when we revisit a node doesn‚Äôt seem
    to do any harm. Does that mean it‚Äôs okay to make that change?
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe that nothing has actually depended on that seen-list being `empty`.
    That‚Äôs why it appears to not matter. How can we make it matter? By making it ‚Äúhurt‚Äù
    the computation by visiting a previously seen, but now forgotten, node yet again.
    So we need to visit a node at least three times: the first time to remember it;
    the second time to forget it; and a third time to incorrectly visit it again.
    Here‚Äôs a DAG that will do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Sure enough, if either tuple now returns `empty`, this test fails. Otherwise
    it succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: 16.2.6¬†What We‚Äôve Learned[üîó](#(part._.What_.We~e2~80~99ve_.Learned) "Link to
    here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have learned three important principles here:'
  prefs: []
  type: TYPE_NORMAL
- en: A pattern for dealing with programs that need ‚Äúmemory‚Äù. This is called threading
    (not in the sense of ‚Äúmulti-threading‚Äù, which is a kind of parallel computation,
    but rather the pattern of how the seen list gets passed through the program).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A good example of the use of tuples: local, where the documentation benefit
    of datatypes isn‚Äôt necessary (and the extra datatype probably just clutters up
    the program), as opposed to distant, where it is. In general, it‚Äôs always okay
    to make a new datatype; it‚Äôs only sometimes okay to use tuples in their place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An important software-engineering principle, called mutation testing. This is
    an odd name because it would seem to be the name of a technique to test programs.
    Actually, it‚Äôs a technique to test test suites. You have a tested program; you
    then ‚Äúmutate‚Äù some part of your program that you feel must change the output,
    and see whether any tests break. If no tests break, then either you‚Äôve misunderstood
    your program or, more likely, your test suite is not good enough. Improve your
    test suite to catch the error in your program, or convince yourself the change
    didn‚Äôt matter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are mutation testing tools that will randomly try to alter your program
    using ‚Äúmutant‚Äù strategies‚Äî<wbr>e.g., replacing a `+` with a `-`‚Äî<wbr>and re-run
    your suites, and then report back on how many potential mutants the suites actually
    caught. But we can‚Äôt and shouldn‚Äôt only rely on tools; we can also apply the principle
    of mutation testing by hand, as we have above. At the very least, it will help
    us understand our program better!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '16.2.7¬†More on Value Printing: An Aside from Racket[üîó](#(part._.More_on_.Value_.Printing__.An_.Aside_from_.Racket)
    "Link to here")'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Earlier, we talked about how the standard recursive size can still be thought
    of as a ‚Äúsize of printed value‚Äù computation. However, that actually depends on
    your language‚Äôs value printer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Racket, you can turn on (it‚Äôs slightly more expensive, so off by default)
    a value-printer that shows value sharing: Language | Choose Language ‚Ä¶ | Show
    Details | Show sharing in values. So if we take the data definition above and
    translate it into Racket structures'
  prefs: []
  type: TYPE_NORMAL
- en: '| (struct mt () #:transparent) |'
  prefs: []
  type: TYPE_TB
- en: '| (struct nd (v l r) #:transparent) |'
  prefs: []
  type: TYPE_TB
- en: 'and then construct (almost) the same data as in the first example:'
  prefs: []
  type: TYPE_NORMAL
- en: '| (define n1 (nd 1 (mt) (mt))) |'
  prefs: []
  type: TYPE_TB
- en: '| (define n2 (nd 2 (mt) n1)) |'
  prefs: []
  type: TYPE_TB
- en: '| (define n3 (nd 3 n1 (mt))) |'
  prefs: []
  type: TYPE_TB
- en: '| (define n4 (nd 4 n2 n3)) |'
  prefs: []
  type: TYPE_TB
- en: 'and then ask Racket to print it, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '| > n4 |'
  prefs: []
  type: TYPE_TB
- en: '| (nd 4 (nd 2 (mt) #0=(nd 1 (mt) (mt))) (nd 3 #0# (mt))) |'
  prefs: []
  type: TYPE_TB
- en: 'The #0= notation is the moral equivalent of saying, ‚ÄúI‚Äôm going to refer to
    this value again later, so let‚Äôs call it the 0th value‚Äù and #0# is saying ‚ÄúHere
    I‚Äôm referring to the aforementioned 0th value‚Äù.'
  prefs: []
  type: TYPE_NORMAL
- en: (Yes, there can be more than one shared value in an output, so each is given
    a different ‚Äúname‚Äù. We‚Äôll see that in a moment.)
  prefs: []
  type: TYPE_NORMAL
- en: The later example above translates to
  prefs: []
  type: TYPE_NORMAL
- en: '| (define n13 (nd 13 (mt) (mt))) |'
  prefs: []
  type: TYPE_TB
- en: '| (define n11 (nd 11 n13 n13)) |'
  prefs: []
  type: TYPE_TB
- en: '| (define n12 (nd 12 n13 (mt))) |'
  prefs: []
  type: TYPE_TB
- en: '| (define n10 (nd 10 n11 n12)) |'
  prefs: []
  type: TYPE_TB
- en: which prints as
  prefs: []
  type: TYPE_NORMAL
- en: '| > n10 |'
  prefs: []
  type: TYPE_TB
- en: '| (nd 10 (nd 11 #0=(nd 13 (mt) (mt)) #0#) (nd 12 #0# (mt))) |'
  prefs: []
  type: TYPE_TB
- en: So it is possible for a language to reflect the sharing in its output. It‚Äôs
    just that most programming languages choose to not do that, even optionally.
  prefs: []
  type: TYPE_NORMAL
- en: Remember the ‚Äúalmost‚Äù above? What was that about?
  prefs: []
  type: TYPE_NORMAL
- en: 'In Racket, we‚Äôve made a new instance of mt over and over. We can more accurately
    reflect what is happening in Pyret by instantiating it only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '| (struct mt () #:transparent) |'
  prefs: []
  type: TYPE_TB
- en: '| (define the-mt (mt)) |'
  prefs: []
  type: TYPE_TB
- en: '| (struct nd (v l r) #:transparent) |'
  prefs: []
  type: TYPE_TB
- en: 'We then rewrite the earlier example to use that one instance only:'
  prefs: []
  type: TYPE_NORMAL
- en: '| (define n1 (nd 1 the-mt the-mt)) |'
  prefs: []
  type: TYPE_TB
- en: '| (define n2 (nd 2 the-mt n1)) |'
  prefs: []
  type: TYPE_TB
- en: '| (define n3 (nd 3 n1 the-mt)) |'
  prefs: []
  type: TYPE_TB
- en: '| (define n4 (nd 4 n2 n3)) |'
  prefs: []
  type: TYPE_TB
- en: 'And now when we print it:'
  prefs: []
  type: TYPE_NORMAL
- en: '| > n4 |'
  prefs: []
  type: TYPE_TB
- en: '| (nd 4 (nd 2 #0=(mt) #1=(nd 1 #0# #0#)) (nd 3 #1# #0#)) |'
  prefs: []
  type: TYPE_TB
- en: 'And now you can see there are two different shared values, one is the single
    instance of mt, the other is the nd with 1 in it. Thus, Racket uses both #0= /
    #0# and #1= / #1#. Notice how all the leaves are sharing the same mt instance.
    (The numbering is picked in the order in which nodes are encountered while traversing,
    which is why the nd instance was #0 the previous time and is #1 this time.)'
  prefs: []
  type: TYPE_NORMAL
