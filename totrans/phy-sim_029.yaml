- en: Equality Constraint Formulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://phys-sim-book.github.io/lec5.1-equality_constraints.html](https://phys-sim-book.github.io/lec5.1-equality_constraints.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  prefs: []
  type: TYPE_NORMAL
- en: 'Dirichlet boundary conditions (BC), when integrated into the optimization time
    integrator, are represented as linear equality constraints: Ax=b,(5.1.1) In this
    equation, the matrix \(A\) is a \(m \times dn\) matrix, where \(m \leq dn\). This
    matrix functions to select the degrees of freedom (DOFs) at the nodes that are
    subject to the boundary conditions. The vector \(b\) is a \(m \times 1\) vector,
    which specifies the precise spatial values that are prescribed by these conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 5.1.1 (Sticky Dirichlet Boundary Condition).** For a 2D system containing
    two nodes \((x_{11}, x_{12})\) and \((x_{21}, x_{22})\), to fix the second node
    at position \((1, 2)\), the boundary condition (Equation [(5.1.1)](#eq:lec5:BC_x))
    can be expressed as [00​00​10​01​]​x11​x12​x21​x22​​​=[12​].'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The two most common types of Dirichlet boundary conditions are sticky and slip:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sticky Boundary Conditions**: These conditions effectively fix the position
    of certain nodes within a time step. They are characterized by a block-wise constraint
    Jacobian matrix \(A\). In this matrix, each set of \(d\) rows includes exactly
    one \(d \times d\) identity matrix. The rest of the matrix consists of zero matrices.
    This configuration is illustrated in [Example 5.1.1](#exp:lec5:dbc). The implementation
    of sticky boundary conditions ensures that the specified nodes remain stationary,
    adhering to the prescribed positions during the simulation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Slip Boundary Conditions**: These conditions are designed to constrain each
    boundary condition (BC) node within a specific linear subspace, such as a plane
    or a line, which may not necessarily be axis-aligned. As an example, consider
    planar slip boundary conditions. Here, for each BC node, there is a corresponding
    row in the matrix \(A\) that contains the normal vector of the plane. This vector
    occupies the columns corresponding to the BC node, as detailed in [Example 5.1.2](#exp:lec5:slip).
    Such conditions allow the nodes to move, but only within the defined linear subspace,
    thus adding a layer of complexity and realism to the simulation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 5.1.2 (Slip Dirichlet Boundary Condition).** For the same two-node
    system in [Example 5.1.1](#exp:lec5:dbc), to constrain the first node in the line
    with equation \(2x + 3y = 4\), the constraint (Equation [(5.1.1)](#eq:lec5:BC_x))
    can be expressed as [2​3​0​0​]​x11​x12​x21​x22​​​=4.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'At the start of each time step, if we are given that all boundary conditions
    are satisfied, then the goal during optimization is simply to maintain the positions
    of the boundary condition nodes. This is represented as: AΔx=0.(5.1.2) Here, \(\Delta
    x\) is the search direction in each optimization iteration. Maintaining this condition
    ensures that any updated nodal position \(x + \alpha \Delta x\), with \(\alpha\)
    being the step size from line search, still satisfies the boundary conditions:
    A(x+αΔx)=b. This guarantees the adherence to boundary conditions throughout the
    optimization process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To enforce the linear equality constraints (Equation [(5.1.2)](#eq:lec5:BC_dx))
    for sticky DBC in a time step, we address this in each Newton iteration while
    solving for the search direction \( \Delta x \). This process involves forming
    the Lagrangian with a quadratic approximation to the Incremental Potential:'
  prefs: []
  type: TYPE_NORMAL
- en: L(Δx,λ)=21​ΔxTHΔx+gTΔx+λTAΔx,
  prefs: []
  type: TYPE_NORMAL
- en: Here, \( \lambda \) is the \( m\times 1 \) Lagrange multiplier vector. The gradient
    and Hessian of the Incremental Potential are denoted by \( g \) and \( H \), respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is approached through a max-min optimization problem:'
  prefs: []
  type: TYPE_NORMAL
- en: λmax​Δxmin​L(Δx,λ),
  prefs: []
  type: TYPE_NORMAL
- en: 'which leads to the formulation of a Karush-Kuhn-Tucker (KKT) system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[HA​AT​][Δxλ​]=[−g0​].(5.1.3)'
  prefs: []
  type: TYPE_NORMAL
- en: Solving this KKT system is essential to determine the search direction. Note
    that this system is not Symmetric Positive Definite (SPD) and its size increases
    with the number of BC nodes.
  prefs: []
  type: TYPE_NORMAL
