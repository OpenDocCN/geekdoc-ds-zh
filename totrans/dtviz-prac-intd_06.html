<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>5 Graph tables, add labels, make notes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>5 Graph tables, add labels, make notes</h1>
<blockquote>原文：<a href="https://socviz.co/workgeoms.html">https://socviz.co/workgeoms.html</a></blockquote>

<p>This Chapter builds on the foundation we have laid down. Things will
get a little more sophisticated in three ways. First, we will learn
about how to transform data <em>before</em> we send it to ggplot to be turned
into a figure. As we saw in Chapter <a href="groupfacettx.html#groupfacettx">4</a>, ggplot’s
geoms will often summarize data for us. While convenient, this can
sometimes be awkward or even a little opaque. Often, it’s better to
get things into the right shape before we send anything to ggplot.
This is a job for another tidyverse component, the <code>dplyr</code> library. We
will learn how to use some of its “action verbs” to select, group,
summarize and transform our data.</p>
<p>Second, we will expand the number of geoms we know about, and learn
more about how to choose between them. The more we learn about
ggplot’s geoms, the easier it will be to pick the right one given the
data we have and the visualization we want. As we learn about new
geoms, we will also get a little more adventurous and depart from some
of ggplot’s default arguments and settings. We will learn how to
reorder the variables displayed in our figures, and how to subset the
data we use before we display it.</p>
<p>Third, this process of gradual customization will give us the
opportunity to learn a little more about the scale, guide, and theme
functions that we have mostly taken for granted until now. These will
give us even more control over the content and appearance of our graphs.
Together, these techniques can be used to make plots much more legible
to readers. They allow us to present our data in a more structured and
easily comprehensible way, and to pick out the elements of it that are
of particular interest. We will begin to use these techniques to layer
geoms on top of one another, a technique that will allow us to produce
very sophisticated graphs in a systematic, comprehensible way.</p>
<p>Our basic approach will not change. No matter how complex our plots
get, or how many individual steps we take to layer and tweak their
features, underneath we will always be doing the same thing. We want a
table of tidy data, a mapping of variables to aesthetic elements, and
a particular type of graph. If you can keep sight of this, it will
make it easier to confidently approach the job of getting any
particular graph to look just right.</p>
<p><!--
<caption>--><span class="marginnote shownote"><span id="tab:relig1">Table 5.1: </span>Column marginals. (Numbers in columns sum to 100.)</span><!--</caption>--></p>
<table>
<thead>
<tr class="header">
<th/>
<th align="right">Protestant</th>
<th align="right">Catholic</th>
<th align="right">Jewish</th>
<th align="right">None</th>
<th align="right">Other</th>
<th align="right">NA</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Northeast</td>
<td align="right">12</td>
<td align="right">25</td>
<td align="right">53</td>
<td align="right">18</td>
<td align="right">18</td>
<td align="right">6</td>
</tr>
<tr class="even">
<td>Midwest</td>
<td align="right">24</td>
<td align="right">27</td>
<td align="right">6</td>
<td align="right">25</td>
<td align="right">21</td>
<td align="right">28</td>
</tr>
<tr class="odd">
<td>South</td>
<td align="right">47</td>
<td align="right">25</td>
<td align="right">22</td>
<td align="right">27</td>
<td align="right">31</td>
<td align="right">61</td>
</tr>
<tr class="even">
<td>West</td>
<td align="right">17</td>
<td align="right">24</td>
<td align="right">20</td>
<td align="right">29</td>
<td align="right">30</td>
<td align="right">6</td>
</tr>
</tbody>
</table>
<div id="piping" class="section level2">
<h2><span class="header-section-number">5.1</span> Use pipes to summarize data</h2>
<p>In Chapter <a href="groupfacettx.html#groupfacettx">4</a> we began making plots of the
distributions and relative frequencies of variables. Cross-classifying
one measure by another is one of the basic descriptive tasks in data
analysis. Tables <a href="workgeoms.html#tab:relig1">5.1</a> and <a href="workgeoms.html#tab:relig2">5.2</a> show two
common ways of summarizing our GSS data on the distribution of
religious affiliation and region. Table <a href="workgeoms.html#tab:relig1">5.1</a> shows the
column marginals, where the numbers sum to a hundred by column and
show, e.g., the distribution of Protestants across regions. Meanwhile
in Table <a href="workgeoms.html#tab:relig2">5.2</a> the numbers sum to a hundred across the
rows, showing for example the distribution of religious affiliations
within any particular region.</p>
<p>We saw in Chapter <a href="groupfacettx.html#groupfacettx">4</a> that <code>geom_bar()</code> can plot
both counts and relative frequencies depending on what we asked of it.
In practice, though, letting the geoms (and their <code>stat_</code> functions)
do the work can sometimes get a little confusing. It is too easy to
lose track of whether one has calculated row margins, column margins,
or overall relative frequencies. The code to do the calculations on
the fly ends up stuffed into the mapping function and can become hard
to read. A better strategy is to calculate the frequency table you
want first, and then plot that table. This has the benefit of allowing
you do to some quick sanity checks on your tables, to make sure you
haven’t made any errors.</p>
<p><!--
<caption>--><span class="marginnote shownote"><span id="tab:relig2">Table 5.2: </span>Row marginals. (Numbers in rows sum to 100.)</span><!--</caption>--></p>
<table>
<thead>
<tr class="header">
<th/>
<th align="right">Protestant</th>
<th align="right">Catholic</th>
<th align="right">Jewish</th>
<th align="right">None</th>
<th align="right">Other</th>
<th align="right">NA</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Northeast</td>
<td align="right">32</td>
<td align="right">33</td>
<td align="right">6</td>
<td align="right">23</td>
<td align="right">6</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>Midwest</td>
<td align="right">47</td>
<td align="right">25</td>
<td align="right">0</td>
<td align="right">23</td>
<td align="right">5</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td>South</td>
<td align="right">62</td>
<td align="right">15</td>
<td align="right">1</td>
<td align="right">16</td>
<td align="right">5</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td>West</td>
<td align="right">38</td>
<td align="right">25</td>
<td align="right">2</td>
<td align="right">28</td>
<td align="right">8</td>
<td align="right">0</td>
</tr>
</tbody>
</table>

<p>Let’s say we want a plot of the row-marginals for religion within
region. We will take the opportunity to do a little bit of
data-munging in order to get from our underlying table of GSS data to
the summary tabulation that we want to plot. To do this we will use
the tools provided by <code>dplyr</code>, a component of the tidyverse library
that provides functions for manipulating and reshaping tables of data
on the fly. We start from our individual-level <code>gss_sm</code> data frame
with its <code>bigregion</code> and <code>religion</code> variables. Our goal is a summary
table with percentages of religious preferences grouped within region.</p>
<div class="figure fullwidth"><span id="fig:ch-05-dplyr-example"/>
<img src="../Images/c96fe64ed11c6cdbac73f2faf91c0a26.png" alt="How we want to transform the individual-level data." width="100%" data-original-src="https://socviz.co/assets/ch-05-dplyr-pipe-example.png"/>
<p class="caption marginnote shownote">
Figure 5.1: How we want to transform the individual-level data.
</p>
</div>
<p>As shown schematically in Figure <a href="workgeoms.html#fig:ch-05-dplyr-example">5.1</a>, we will
start with our individual-level table of about 2,500 GSS respondents.
Then we want to summarize them into a new table that shows a count of
each religious preference, grouped by region. Finally we will turn
these within-region counts into percentages, where the denominator is
the total number of respondents within each region. The <code>dplyr</code>
library provides a few tools to make this easy and clear to read. We
will use a special operator, <code>%&gt;%</code>, to do our work. This is the <em>pipe</em>
operator. It plays the role of the yellow triangle in Figure <a href="workgeoms.html#fig:ch-05-dplyr-example">5.1</a>, in that it helps us perform the actions that get us from one table to the next.</p>
<p>We have being building our plots in an <em>additive</em> fashion, starting
with a <code>ggplot</code> object and layering on new elements. By analogy,
think of the <code>%&gt;%</code> operator as allowing us to start with a data frame
and perform a <em>sequence</em> or <em>pipeline</em> of operations to turn it into
another, usually smaller and more aggregated table. Data goes in one
side of the pipe, actions are performed via functions, and results
come out the other. A pipeline is typically a series of operations
that do one or more of four things:</p>
<ul>
<li><em>Group</em><label for="tufte-mn-51" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-51" class="margin-toggle"/><span class="marginnote shownote"><code>group_by()</code></span> the data into the nested structure we want for our summary,
such as “Religion by Region” or “Authors by Publications by Year”.</li>
<li><em>Filter</em><label for="tufte-mn-52" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-52" class="margin-toggle"/><span class="marginnote shownote"><code>filter()</code> rows; <code>select()</code> columns</span> or <em>select</em> pieces of the data by row, column, or both.
This gets us the piece of the table we want to work on.</li>
<li><em>Mutate</em><label for="tufte-mn-53" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-53" class="margin-toggle"/><span class="marginnote shownote"><code>mutate()</code></span> the data by creating new variables at the <em>current</em> level of grouping. This adds new columns to the table without aggregating it.</li>
<li><em>Summarize</em><label for="tufte-mn-54" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-54" class="margin-toggle"/><span class="marginnote shownote"><code>summarize()</code></span> or aggregate the grouped data. This creates new variables at a <em>higher</em> level of grouping. For example we might
calculate means with <code>mean()</code> or counts with <code>n()</code>. This results in
a smaller, summary table, which we might do more things on if we
want.</li>
</ul>
<p>We use the <code>dplyr</code> functions <code>group_by()</code>, <code>filter()</code>, <code>select()</code>,
<code>mutate()</code>, and <code>summarize()</code> to carry out these tasks within our
pipeline. They are written in a way that allows them to be easily
piped. That is, they understand how to take inputs from the left side
of a pipe operator and pass results along through the right side of
one. The dplyr documentation has some useful vignettes that introduce
these grouping, filtering, selection, and transformation functions.
There is also a more detailed discussion of these tools, along with
many more examples, in <span class="citation">Wickham &amp; Grolemund (2016)</span>.</p>
<p>We will create a new table called <code>rel_by_region</code>. Here’s the code:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb126-1" data-line-number="1">rel_by_region &lt;-<span class="st"> </span>gss_sm <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb126-2" data-line-number="2"><span class="st">    </span><span class="kw">group_by</span>(bigregion, religion) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb126-3" data-line-number="3"><span class="st">    </span><span class="kw">summarize</span>(<span class="dt">N =</span> <span class="kw">n</span>()) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb126-4" data-line-number="4"><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">freq =</span> N <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(N),</a>
<a class="sourceLine" id="cb126-5" data-line-number="5">           <span class="dt">pct =</span> <span class="kw">round</span>((freq<span class="op">*</span><span class="dv">100</span>), <span class="dv">0</span>))</a></code></pre>
<p>What are these lines doing? First, we are creating an object as usual,
with the familiar assignment operator, <code>&lt;-</code>. Next, at the steps to the
right. Read the objects and functions from left to right, with the
pipe operator “<code>%&gt;%</code>” connecting them together meaning “and then …”. Objects on the left hand side “pass through” the pipe, and whatever
is specified on the right of the pipe gets done to that object. The
resulting object then passes through to the right again, and so on
down to the end of the pipeline.</p>
<p>Reading from the left, the code says this:</p>
<ul>
<li>Create<label for="tufte-mn-55" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-55" class="margin-toggle"/><span class="marginnote shownote"><code>rel_by_region &lt;- gss_sm %&gt;%</code></span> a new object, <code>rel_by_region</code>. It will get the result of the following sequence of actions: Start with the <code>gss_sm</code> data, and then</li>
<li>Group<label for="tufte-mn-56" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-56" class="margin-toggle"/><span class="marginnote shownote"><code>group_by(bigregion, religion) %&gt;%</code></span> the rows by <code>bigregion</code> and, within that, by <code>religion</code>.</li>
<li>Summarize this table<label for="tufte-mn-57" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-57" class="margin-toggle"/><span class="marginnote shownote"><code>summarize(N = n()) %&gt;%</code></span> to create a new, much smaller table, with three columns: <code>bigregion</code>, <code>religion</code>, and a new summary variable, <code>N</code>, that is a count of the number of observations within each religious group for each region.</li>
<li>With this new table,<label for="tufte-mn-58" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-58" class="margin-toggle"/><span class="marginnote shownote"><code> mutate(freq = N / sum(N), pct = round((freq*100), 0))</code></span> use the <code>N</code> variable to calculate two new columns: the relative proportion (<code>freq</code>) and percentage (<code>pct</code>) for each religious category, still grouped by region. Round the results to the nearest percentage point.</li>
</ul>
<p>In this way of doing things, objects passed along the pipeline and the
functions acting on them carry some assumptions about their context.
For one thing, you don’t have to keep specifying the name of the
underlying data frame object you are working from. Everything is
implicitly carried forward from <code>gss_sm</code>. Within the pipeline, the
transient or implicit objects created from your summaries and other
transformations are carried through, too.</p>
<p>Second, the <code>group_by()</code> function sets up how the grouped or nested
data will be processed within the <code>summarize()</code> step. Any function
used to create a new variable within <code>summarize()</code>, such as <code>mean()</code>
or <code>sd()</code> or <code>n()</code>, will be applied to the <em>innermost</em> grouping level
first. Grouping levels are named from left to right within
<code>group_by()</code> from outermost to innermost. So the function call
<code>summarize(N = n())</code> counts up the number of observations for each
value of <code>religion</code> within <code>bigregion</code> and puts them in a new variable
named <code>N</code>. As dplyr’s functions see things, summarizing actions “peel
off” one grouping level at a time, so that the resulting summaries are
at the next level up. In this case, we start with individual-level
observations and group them by religion within region. The
<code>summarize()</code> operation aggregates the individual observations to
counts of the number of people affiliated with each religion, for
each region.</p>
<p>Third, the <code>mutate()</code> step takes the <code>N</code> variable and uses it to
create <code>freq</code>, the relative frequency for each subgroup within region,
and finally <code>pct</code>, the relative frequency turned into a rounded
percentage. These <code>mutate()</code> operations add or remove columns from
tables, but do not change the grouping level.</p>
<p>Inside both <code>mutate()</code> and <code>summarize()</code>, we are able to create new
variables in a way that we have not seen before. Usually, when we see
something like <code>name = value</code> inside a function, the <code>name</code> is a
general, named argument and the function is expecting information from
us about the specific value it should take.<label for="tufte-mn-59" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-59" class="margin-toggle"/><span class="marginnote shownote">As in the
case of <code>aes(x = gdpPercap, y = lifeExp)</code>, for example.</span>
Normally if we give a function a named argument it doesn’t know about
(<code>aes(chuckles = year)</code>) it will ignore it, complain, or break. With
<code>summarize()</code> and <code>mutate()</code>, however, we can invent named arguments.
We are still assigning specific values to <code>N</code>, <code>freq</code>, and <code>pct</code>, but
we pick the names, too. They are the names that the newly-created
variables in the summary table will have. The <code>summarize()</code> and
<code>mutate()</code> functions do not need to know what they will be in advance.</p>
<p>Finally, when we use <code>mutate()</code> to create the <code>freq</code> variable, not
only can we make up that name within the function, <code>mutate()</code> is also
clever enough to let us <em>use</em> that name right away, on the next line
of the same function call, when we create the <code>pct</code> variable. This
means we do not have to repeatedly write separate <code>mutate()</code> calls for
every new variable we want to create.</p>
<p>Our pipeline takes the <code>gss_sm</code> data frame, which has 2867 rows and 32 columns, and transforms it into <code>rel_by_region</code>, a summary table with 24 rows and 5 columns that looks like this, in part:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb127-1" data-line-number="1">rel_by_region</a></code></pre>
<pre><code>## # A tibble: 24 x 5
## # Groups:   bigregion [4]
##    bigregion religion       N    freq   pct
##    &lt;fct&gt;     &lt;fct&gt;      &lt;int&gt;   &lt;dbl&gt; &lt;dbl&gt;
##  1 Northeast Protestant   158 0.324   32.0 
##  2 Northeast Catholic     162 0.332   33.0 
##  3 Northeast Jewish        27 0.0553   6.00
##  4 Northeast None         112 0.230   23.0 
##  5 Northeast Other         28 0.0574   6.00
##  6 Northeast &lt;NA&gt;           1 0.00205  0   
##  7 Midwest   Protestant   325 0.468   47.0 
##  8 Midwest   Catholic     172 0.247   25.0 
##  9 Midwest   Jewish         3 0.00432  0   
## 10 Midwest   None         157 0.226   23.0 
## # ... with 14 more rows</code></pre>
<p>The variables specified in <code>group_by()</code> are retained in the new
summary table; the variables created with <code>summarize()</code> and <code>mutate()</code>
are added, and all the other variables in the original dataset are
dropped.</p>
<p>We said before that, when trying to grasp what each additive step in a
<code>ggplot()</code> sequence does, it can be helpful to work backwards,
removing one piece at a time to see what the plot looks like when that
step is not included. In the same way, when looking at pipelined code
it can be helpful to start from the end of the line, and then remove one
“<code>%&gt;%</code>” step at a time to see what the resulting intermediate object
looks like. For instance, what if we remove the <code>mutate()</code> step from
the code above? What does <code>rel_by_region</code> look like then? What if we
remove the <code>summarize()</code> step? How big is the table returned at each
step? What level of grouping is it at? What variables have been added
or removed?</p>
<p>Plots that do not require sequential aggregation and transformation of
the data before they are displayed are usually easy to write directly
in ggplot, as the details of the layout are handled by a combination
of mapping variables and layering geoms. One-step filtering or
aggregation of the data (such as calculating a proportion, or a
specific subset of observations) is also straightforward. But when the
result we want to display is several steps removed from the data, and
in particular when we want to group or aggregate a table and do some
more calculations on the result before drawing anything, then it can
make sense to use dplyr’s tools to produce these summary tables
first. This is true even if would also be possible to do it within a <code>ggplot()</code>
call. In addition to making our code easier to read, it lets us more
easily perform sanity checks on our results, so that we are sure we
have grouped and summarized things in the right order. For instance,
if we have done things properly with <code>rel_by_region</code>, the <code>pct</code> values
associated with <code>religion</code> should sum to 100 within each region,
perhaps with a bit of rounding error. We can quickly check this using
a very short pipeline, too:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb129-1" data-line-number="1">rel_by_region <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(bigregion) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb129-2" data-line-number="2"><span class="st">    </span><span class="kw">summarize</span>(<span class="dt">total =</span> <span class="kw">sum</span>(pct))</a></code></pre>
<pre><code>## # A tibble: 4 x 2
##   bigregion total
##   &lt;fct&gt;     &lt;dbl&gt;
## 1 Northeast   100
## 2 Midwest     101
## 3 South       100
## 4 West        101</code></pre>
<p>This looks good. As before, now that we are working directly with
percentage values in a summary table, we can use <code>geom_col()</code> instead
of <code>geom_bar()</code>.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-relbyregion-01"/>
<img src="../Images/215092b752bc49a696e9556855685408.png" alt="Religious preferences by Region." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-relbyregion-01-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.2: Religious preferences by Region.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb131-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(rel_by_region, <span class="kw">aes</span>(<span class="dt">x =</span> bigregion, <span class="dt">y =</span> pct, <span class="dt">fill =</span> religion))</a>
<a class="sourceLine" id="cb131-2" data-line-number="2">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_col</span>(<span class="dt">position =</span> <span class="st">"dodge2"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb131-3" data-line-number="3"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">"Region"</span>,<span class="dt">y =</span> <span class="st">"Percent"</span>, <span class="dt">fill =</span> <span class="st">"Religion"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb131-4" data-line-number="4"><span class="st">    </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">"top"</span>)</a></code></pre>
<p>We use a different <code>position</code> argument here, <code>dodge2</code> instead of
<code>dodge</code>. This puts the bars side by side. When dealing with
pre-computed values in <code>geom_col()</code>, the default <code>position</code> is to make
a proportionally stacked column chart. If you use <code>dodge</code> they will be
stacked within columns but the result will read incorrectly. Using
<code>dodge2</code> puts the sub-categories (religious affiliations) side-by-side
within groups (regions).</p>
<p>The values in this bar chart are the percentage equivalents to the
stacked counts in Figure <a href="groupfacettx.html#fig:ch-04-gss-06">4.10</a>. Religious
affiliations sum to 100 percent within region. The trouble is,
although we now know how to cleanly produce frequency tables, this is
still a bad figure. It is too crowded, with too many bars
side-by-side. We can do better.</p>
<p>As a rule, dodged charts can be more cleanly expressed as faceted
plots. This removes the need for a legend, and thus makes the chart
simpler to read. We also introduce a new function. If we map religion
to the x-axis, the labels will overlap and become illegible. It’s
possible to manually adjust the tick mark labels so that they are
printed at an angle, but that isn’t so easy to read, either. It makes
more sense to put the religions on the y-axis and the percent scores
on the x-axis. Because of the way <code>geom_bar()</code> works internally,
simply swapping the <code>x</code> and <code>y</code> mapping will not work. (Try it and see
what happens.) What we do instead is to transform the <em>coordinate
system</em> that the results are plotted in, so that the x and y axes are
flipped. We do this with <code>coord_flip()</code>.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb132-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(rel_by_region, <span class="kw">aes</span>(<span class="dt">x =</span> religion, <span class="dt">y =</span> pct, <span class="dt">fill =</span> religion))</a>
<a class="sourceLine" id="cb132-2" data-line-number="2">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_col</span>(<span class="dt">position =</span> <span class="st">"dodge2"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb132-3" data-line-number="3"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="ot">NULL</span>, <span class="dt">y =</span> <span class="st">"Percent"</span>, <span class="dt">fill =</span> <span class="st">"Religion"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb132-4" data-line-number="4"><span class="st">    </span><span class="kw">guides</span>(<span class="dt">fill =</span> <span class="ot">FALSE</span>) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb132-5" data-line-number="5"><span class="st">    </span><span class="kw">coord_flip</span>() <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb132-6" data-line-number="6"><span class="st">    </span><span class="kw">facet_grid</span>(<span class="op">~</span><span class="st"> </span>bigregion)</a></code></pre>
<div class="figure fullwidth"><span id="fig:ch-05-relbyregion-02"/>
<img src="../Images/004dec05a264c8e45176131cd621f9b9.png" alt="Religious preferences by Region, faceted version." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-relbyregion-02-1.png"/>
<p class="caption marginnote shownote">
Figure 5.3: Religious preferences by Region, faceted version.
</p>
</div>
<p>For most plots the coordinate system is cartesian, showing plots on a plane defined by an x-axis and a y-axis. The <code>coord_cartesian()</code> function manages this, but we don’t need to call it. The <code>coord_flip()</code> function switches the x and y axes after the plot is made. It does not remap variables to aesthetics. In this case, <code>religion</code> is still mapped to <code>x</code> and <code>pct</code> to <code>y</code>. Because the religion names do not need an axis label to be understood, we set <code>x = NULL</code> in the <code>labs()</code> call.</p>
<p>We will see more of what dplyr’s grouping and filtering operations can
do later. It is a flexible and powerful framework. For now, think of
it as a way to quickly summarize tables of data without having to
write code in the body of our <code>ggplot()</code> or <code>geom_</code> functions.</p>
</div>
<div id="continuous-variables-by-group-or-category" class="section level2">
<h2><span class="header-section-number">5.2</span> Continuous variables by group or category</h2>
<p>Let’s move to a new dataset, the <code>organdata</code> table. Like <code>gapminder</code>, it has a
country-year structure. It contains a little more than a decade’s
worth of information on the donation of organs for transplants in seventeen OECD
countries. The organ procurement rate is a measure of the number of human organs obtained from cadaver organ donors for use in transplant operations. Along with
this donation data, the dataset has a variety of numerical demographic
measures, and several categorical measures of health and welfare
policy and law. Unlike the <code>gapminder</code> data, some observations are
missing. These are designated with a value of <code>NA</code>, R’s standard code
for missing data. The <code>organdata</code> table is included in the <code>socviz</code>
library. Load it up and take a quick look. Instead of using <code>head()</code>,
for variety this time we will make a short pipeline to select the first six columns of
the dataset, and then pick five rows at random using a function called
<code>sample_n()</code>. This function takes two main arguments. First we provide the table of data we want
to sample from. Because we are using a pipeline, this is implicitly passed down from the beginning of the pipe. Then we supply the number of draws we want to make.<label for="tufte-mn-60" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-60" class="margin-toggle"/><span class="marginnote shownote">Using numbers this way in <code>select()</code> chooses the numbered columns of the data frame. You can also select variable names directly.</span></p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb133-1" data-line-number="1">organdata <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">sample_n</span>(<span class="dt">size =</span> <span class="dv">10</span>)</a></code></pre>
<pre><code>## # A tibble: 10 x 6
##    country        year       donors   pop pop_dens   gdp
##    &lt;chr&gt;          &lt;date&gt;      &lt;dbl&gt; &lt;int&gt;    &lt;dbl&gt; &lt;int&gt;
##  1 Switzerland    NA           NA      NA    NA       NA
##  2 Switzerland    1997-01-01   14.3  7089    17.2  27675
##  3 United Kingdom 1997-01-01   13.4 58283    24.0  22442
##  4 Sweden         NA           NA    8559     1.90 18660
##  5 Ireland        2002-01-01   21.0  3932     5.60 32571
##  6 Germany        1998-01-01   13.4 82047    23.0  23283
##  7 Italy          NA           NA   56719    18.8  17430
##  8 Italy          2001-01-01   17.1 57894    19.2  25359
##  9 France         1998-01-01   16.5 58398    10.6  24044
## 10 Spain          1995-01-01   27.0 39223     7.75 15720</code></pre>
<p>Lets’s start by naively graphing some of the data. We can take a look at
a scatterplot of donors vs year.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-organdata-01"/>
<img src="../Images/8a6a1259ee0fd826e0f9513be05f79d3.png" alt="Not very informative." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-organdata-01-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.4: Not very informative.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb135-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb135-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> year, <span class="dt">y =</span> donors))</a>
<a class="sourceLine" id="cb135-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>()</a></code></pre>
<pre><code>## Warning: Removed 34 rows containing missing values
## (geom_point).</code></pre>
<p>A message from ggplot warns you about the missing values. We’ll suppress this warning
from now on, so that it doesn’t clutter the output, but in general
it’s wise to read and understand the warnings that R gives, even when
code appears to run properly. If there are a large number of warnings,
R will collect them all and invite you to view them with the
<code>warnings()</code> function.</p>
<p>We could use <code>geom_line()</code> to plot each country’s time series, like we did with the gapminder data. To do that, remember, we need to tell ggplot what the grouping variable is. This time we can also facet the figure by country, as we do not have too many of them.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-organdata-02"/>
<img src="../Images/2b99e6558ebdda27d7c48cbb953eb8fa.png" alt="A faceted line plot." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-organdata-02-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.5: A faceted line plot.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb137-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb137-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> year, <span class="dt">y =</span> donors))</a>
<a class="sourceLine" id="cb137-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">group =</span> country)) <span class="op">+</span><span class="st"> </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>country)</a></code></pre>
<p>By default the facets are ordered alphabetically by country. We will see how to change this momentarily.</p>
<p>Let’s focus on the country-level variation, but without paying
attention to the time trend. We can use <code>geom_boxplot()</code> to get a
picture of variation by year across countries. Just as <code>geom_bar()</code> by
default calculates a count of observations by the category you map to
<code>x</code>, the <code>stat_boxplot()</code> function that works with <code>geom_boxplot()</code>
will calculate a number of statistics that allow the box and whiskers
to be drawn. We tell <code>geom_boxplot()</code> the variable we want to
categorize by (here, <code>country</code>) and the continuous variable we want
summarized (here, <code>donors</code>)</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-organdata-03"/>
<img src="../Images/e451458bc9c750df1e711b18dbf06767.png" alt="A first attempt at boxplots by country." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-organdata-03-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.6: A first attempt at boxplots by country.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb138-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb138-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> country, <span class="dt">y =</span> donors))</a>
<a class="sourceLine" id="cb138-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_boxplot</span>()</a></code></pre>
<p>The boxplots look interesting but two issues could be addressed. First, as we saw in the previous chapter, it is awkward to have the country names on the x-axis because the labels will overlap. We use <code>coord_flip()</code> again to switch the axes (but not the mappings).</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-organdata-04"/>
<img src="../Images/3b584e8c67dab2c11385972d18069b5f.png" alt="Moving the countries to the y-axis." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-organdata-04-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.7: Moving the countries to the y-axis.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb139-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb139-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> country, <span class="dt">y =</span> donors))</a>
<a class="sourceLine" id="cb139-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_boxplot</span>() <span class="op">+</span><span class="st"> </span><span class="kw">coord_flip</span>()</a></code></pre>
<p>That’s more legible but still not ideal. We generally want our plots to present data in some meaningful order. An obvious way is to have the countries listed from high to low average donation rate. We accomplish this by reordering the <code>country</code> variable by the mean of <code>donors.</code> The <code>reorder()</code> function will do this for us. It takes two required arguments. The first is the categorical variable or factor that we want to reorder. In this case, that’s <code>country</code>. The second is the variable we want to reorder it by. Here that is the donation rate, <code>donors</code>. The third and optional argument to <code>reorder()</code> is the function you want to use as a summary statistic. If you only give <code>reorder()</code> the first two required arguments, then by default it will reorder the categories of your first variable by the mean value of the second. You can name any sensible function you like to reorder the categorical variable (e.g., <code>median</code>, or <code>sd</code>). There is one additional wrinkle. In R, the default <code>mean</code> function will fail with an error if there are missing values in the variable you are trying to take the average of. You must say that it is OK to remove the missing values when calculating the mean. This is done by supplying the <code>na.rm=TRUE</code> argument to <code>reorder()</code>, which internally passes that argument on to <code>mean()</code>. We are reordering the variable we are mapping to the <code>x</code> aesthetic, so we use <code>reorder()</code> at that point in our code:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb140-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb140-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">reorder</span>(country, donors, <span class="dt">na.rm=</span><span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb140-3" data-line-number="3">                          <span class="dt">y =</span> donors))</a>
<a class="sourceLine" id="cb140-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_boxplot</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb140-5" data-line-number="5"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x=</span><span class="ot">NULL</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb140-6" data-line-number="6"><span class="st">    </span><span class="kw">coord_flip</span>()</a></code></pre>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-organdata-05"/>
<img src="../Images/303d95e0edeba02ff11d09e70bc320f9.png" alt="Boxplots reordered by mean donation rate." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-organdata-05-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.8: Boxplots reordered by mean donation rate.<!--</p>-->
<!--</div>--></span>
</p>
<p>Because it’s obvious what the country names are, in the <code>labs()</code> call we set their axis label to empty with <code>labs(x=NULL)</code>. Ggplot offers some variants on the basic boxplot, including the violin plot. Try it with <code>geom_violin()</code>. There are also numerous arguments that control the finer details of the boxes and whiskers, including their width. Boxplots can also take <code>color</code> and <code>fill</code> aesthetic mappings like other geoms.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb141-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb141-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">reorder</span>(country, donors, <span class="dt">na.rm=</span><span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb141-3" data-line-number="3">                          <span class="dt">y =</span> donors, <span class="dt">fill =</span> world))</a>
<a class="sourceLine" id="cb141-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_boxplot</span>() <span class="op">+</span><span class="st"> </span><span class="kw">labs</span>(<span class="dt">x=</span><span class="ot">NULL</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb141-5" data-line-number="5"><span class="st">    </span><span class="kw">coord_flip</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">"top"</span>)</a></code></pre>
<div class="figure"><span id="fig:ch-05-organdata-06"/>
<p class="caption marginnote shownote">
Figure 5.9: A boxplot with the fill aesthetic mapped.
</p>
<img src="../Images/0ec40145582f9a93b39249c1a11f8e55.png" alt="A boxplot with the fill aesthetic mapped." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-organdata-06-1.png"/>
</div>
<p>Putting categorical variables on the y-axis to compare their distributions is a very useful trick. Its makes it easy to effectively present summary data on more categories. The plots can be quite compact and fit a relatively large number of cases in by row. The approach also has the advantage of putting the variable being compared onto the x-axis, which sometimes makes it easier to compare across categories. If the number of observations within each categoriy is relatively small, we can skip (or supplement) the boxplots and show the individual observations, too. In this next example we map the <code>world</code> variable to <code>color</code> instead of <code>fill</code> as the default <code>geom_point()</code> plot shape has a color attribute, but not a fill.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-organdata-07"/>
<img src="../Images/ee3d7de1c71b47df463cd41a77952b9e.png" alt="Using points instead of a boxplot." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-organdata-07-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.10: Using points instead of a boxplot.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb142-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb142-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">reorder</span>(country, donors, <span class="dt">na.rm=</span><span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb142-3" data-line-number="3">                          <span class="dt">y =</span> donors, <span class="dt">color =</span> world))</a>
<a class="sourceLine" id="cb142-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">labs</span>(<span class="dt">x=</span><span class="ot">NULL</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb142-5" data-line-number="5"><span class="st">    </span><span class="kw">coord_flip</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">"top"</span>)</a></code></pre>
<p>When we use <code>geom_point()</code> like this, there is some overplotting of observations. In these cases, it can be useful to perturb the data just a little bit in order to get a better sense of how many observations there are at different values. We use <code>geom_jitter()</code> to do this. This geom works much like <code>geom_point()</code>, but randomly nudges each observation by a small amount.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-organdata-08"/>
<img src="../Images/bc484a1d7342a9dabffc983284087891.png" alt="Jittering the points." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-organdata-08-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.11: Jittering the points.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb143-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb143-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">reorder</span>(country, donors, <span class="dt">na.rm=</span><span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb143-3" data-line-number="3">                          <span class="dt">y =</span> donors, <span class="dt">color =</span> world))</a>
<a class="sourceLine" id="cb143-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_jitter</span>() <span class="op">+</span><span class="st"> </span><span class="kw">labs</span>(<span class="dt">x=</span><span class="ot">NULL</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb143-5" data-line-number="5"><span class="st">    </span><span class="kw">coord_flip</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">"top"</span>)</a></code></pre>
<p>The default amount of jitter is a little too much for our purposes. We can control it using <code>height</code> and <code>width</code> arguments to a <code>position_jitter()</code> function within the geom. Because we’re making a one-dimensional summary here, we just need <code>width</code>.<label for="tufte-mn-61" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-61" class="margin-toggle"/><span class="marginnote shownote">Can you see why we did not use height? If not, try it and see what happens.</span></p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb144-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb144-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">reorder</span>(country, donors, <span class="dt">na.rm=</span><span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb144-3" data-line-number="3">                          <span class="dt">y =</span> donors, <span class="dt">color =</span> world))</a>
<a class="sourceLine" id="cb144-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_jitter</span>(<span class="dt">position =</span> <span class="kw">position_jitter</span>(<span class="dt">width=</span><span class="fl">0.15</span>)) <span class="op">+</span></a>
<a class="sourceLine" id="cb144-5" data-line-number="5"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x=</span><span class="ot">NULL</span>) <span class="op">+</span><span class="st"> </span><span class="kw">coord_flip</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">"top"</span>)</a></code></pre>
<div class="figure"><span id="fig:ch-05-organdata-09"/>
<p class="caption marginnote shownote">
Figure 5.12: A jittered plot.
</p>
<img src="../Images/3962f4a2a83430505c2d11a495b5584b.png" alt="A jittered plot." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-organdata-09-1.png"/>
</div>
<p>When we want to summarize a categorical variable that just has one
point per category, we should use this approach as well. The result
will be a Cleveland dotplot, a simple and extremely effective method
of presenting data that is usually better than either a bar chart or a
table. For example, we can make a Cleveland dotplot of the average
donation rate.</p>
<p>This also gives us another opportunity to do a little bit of data
munging with a dplyr pipeline. We will use one to aggregate our larger
country-year data frame to a smaller table of summary statistics by
country. There is more than one way to do pipeline this task. We could
choose the variables we want to summarize and then repeatedly use the
<code>mean()</code> and <code>sd()</code> functions to calculate the means and standard
deviations of the variables we want. We will again use the pipe
operator, <code>%&gt;%</code>, to do our work:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb145-1" data-line-number="1">by_country &lt;-<span class="st"> </span>organdata <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(consent_law, country) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb145-2" data-line-number="2"><span class="st">    </span><span class="kw">summarize</span>(<span class="dt">donors_mean=</span> <span class="kw">mean</span>(donors, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb145-3" data-line-number="3">              <span class="dt">donors_sd =</span> <span class="kw">sd</span>(donors, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb145-4" data-line-number="4">              <span class="dt">gdp_mean =</span> <span class="kw">mean</span>(gdp, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb145-5" data-line-number="5">              <span class="dt">health_mean =</span> <span class="kw">mean</span>(health, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb145-6" data-line-number="6">              <span class="dt">roads_mean =</span> <span class="kw">mean</span>(roads, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb145-7" data-line-number="7">              <span class="dt">cerebvas_mean =</span> <span class="kw">mean</span>(cerebvas, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))</a></code></pre>
<p>The pipeline consists of two steps. First we group the data by <code>consent_law</code> and <code>country</code>, and then use <code>summarize()</code> to create six new variables, each one of which is the mean or standard deviation of each country’s score on a corresponding variable in the original <code>organdata</code> data frame.<label for="tufte-mn-62" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-62" class="margin-toggle"/><span class="marginnote shownote">For an alternative view, change <code>country</code> to <code>year</code> in the grouping statement and see what happens.</span></p>
<p>As usual, <code>summarize()</code> step, will inherit information about the
original data and the grouping, and then do its calculations at the
innermost grouping level. In this case it takes all the observations
for each country and calculates the mean or standard deviation as
requested. Here is what the resulting object looks like:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb146-1" data-line-number="1">by_country</a></code></pre>
<pre><code>## # A tibble: 17 x 8
## # Groups:   consent_law [?]
##    consent_law country        donors_mean donors_sd gdp_mean health_mean roads_mean cerebvas_mean
##    &lt;chr&gt;       &lt;chr&gt;                &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;      &lt;dbl&gt;         &lt;dbl&gt;
##  1 Informed    Australia             10.6     1.14     22179        1958      105             558
##  2 Informed    Canada                14.0     0.751    23711        2272      109             422
##  3 Informed    Denmark               13.1     1.47     23722        2054      102             641
##  4 Informed    Germany               13.0     0.611    22163        2349      113             707
##  5 Informed    Ireland               19.8     2.48     20824        1480      118             705
##  6 Informed    Netherlands           13.7     1.55     23013        1993       76.1           585
##  7 Informed    United Kingdom        13.5     0.775    21359        1561       67.9           708
##  8 Informed    United States         20.0     1.33     29212        3988      155             444
##  9 Presumed    Austria               23.5     2.42     23876        1875      150             769
## 10 Presumed    Belgium               21.9     1.94     22500        1958      155             594
## 11 Presumed    Finland               18.4     1.53     21019        1615       93.6           771
## 12 Presumed    France                16.8     1.60     22603        2160      156             433
## 13 Presumed    Italy                 11.1     4.28     21554        1757      122             712
## 14 Presumed    Norway                15.4     1.11     26448        2217       70.0           662
## 15 Presumed    Spain                 28.1     4.96     16933        1289      161             655
## 16 Presumed    Sweden                13.1     1.75     22415        1951       72.3           595
## 17 Presumed    Switzerland           14.2     1.71     27233        2776       96.4           424</code></pre>
<p>As before, the variables specified in <code>group_by()</code> are retained in the
new data frame, the variables created with <code>summarize()</code> are added,
and all the other variables in the original data are dropped. The
countries are also summarized alphabetically within <code>consent_law</code>,
which was the outermost grouping variable in the <code>group_by()</code>
statement at the start of the pipeline.</p>
<p>Using our pipeline this way is reasonable, but the code is worth looking at again. For one thing, we have to repeatedly type out the names of the <code>mean()</code> and <code>sd()</code> functions and give each of them the name of the variable we want summarized <em>and</em> the <code>na.rm = TRUE</code> argument each time to make sure the functions don’t complain about missing values. We also repeatedly name our new summary variables in the same way, by adding <code>_mean</code> or <code>_sd</code> to the end of the original variable name. If we wanted to calculate the mean and standard deviation for all the numerical variables in <code>organdata</code>, our code would get even longer. Plus, in this version we lose the other, time-invariant categorical variables that we haven’t grouped by, such as <code>world</code>. When we see repeated actions like this in our code, we can ask whether there’s a better way to proceed.</p>
<p>There is. What we would like to do is apply the <code>mean()</code> and <code>sd()</code> functions to every numerical variable in <code>organdata</code>, but <em>only</em> the numerical ones. Then we want to name the results in a consistent way, and return a summary table including all the categorical variables like <code>world</code>. We can create a better version of the <code>by_country</code> object using a little bit of R’s functional programming abilities. Here is the code:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb148-1" data-line-number="1">by_country &lt;-<span class="st"> </span>organdata <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(consent_law, country) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb148-2" data-line-number="2"><span class="st">    </span><span class="kw">summarize_if</span>(is.numeric, <span class="kw">funs</span>(mean, sd), <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb148-3" data-line-number="3"><span class="st">    </span><span class="kw">ungroup</span>()</a></code></pre>
<p>The pipeline starts off just as before, taking <code>organdata</code> and then grouping it by <code>consent_law</code> and <code>country</code>. In the next step, though, instead of manually taking the mean and standard deviation of a subset of variables, we use the <code>summarize_if()</code> function instead. As its name suggests, it examines each column in our data and applies a test to it. It only summarizes if the test is passed, that is, if it returns a value of <code>TRUE</code>.<label for="tufte-mn-63" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-63" class="margin-toggle"/><span class="marginnote shownote">We do not have to use parentheses when naming the functions inside <code>summarize_if()</code>.</span> Here the test is the function <code>is.numeric()</code>, which looks to see if a vector is a numeric value or not. If it is, then <code>summarize_if()</code> will apply the summary function or functions we want to <code>organdata</code>. Because we are taking both the mean and the standard deviation, we use <code>funs()</code> to list the functions we want to use. And we finish with the <code>na.rm = TRUE</code> argument, which will be passed on to each use of both <code>mean()</code> and <code>sd()</code>. In the last step in the pipeline we <code>ungroup()</code> the data<label for="tufte-mn-64" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-64" class="margin-toggle"/><span class="marginnote shownote">Sometimes graphing functions can get confused by grouped tibbles where we don’t explicitly use the groups in the plot.</span>, so that the result is a plain tibble.</p>
<p>Here is what the pipeline returns:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb149-1" data-line-number="1">by_country    </a></code></pre>
<pre><code>## # A tibble: 17 x 28
##    consent_law country        donors_mean pop_mean pop_dens_mean gdp_mean gdp_lag_mean health_mean
##    &lt;chr&gt;       &lt;chr&gt;                &lt;dbl&gt;    &lt;dbl&gt;         &lt;dbl&gt;    &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;
##  1 Informed    Australia             10.6    18318         0.237    22179        21779        1958
##  2 Informed    Canada                14.0    29608         0.297    23711        23353        2272
##  3 Informed    Denmark               13.1     5257        12.2      23722        23275        2054
##  4 Informed    Germany               13.0    80255        22.5      22163        21938        2349
##  5 Informed    Ireland               19.8     3674         5.23     20824        20154        1480
##  6 Informed    Netherlands           13.7    15548        37.4      23013        22554        1993
##  7 Informed    United Kingdom        13.5    58187        24.0      21359        20962        1561
##  8 Informed    United States         20.0   269330         2.80     29212        28699        3988
##  9 Presumed    Austria               23.5     7927         9.45     23876        23415        1875
## 10 Presumed    Belgium               21.9    10153        30.7      22500        22096        1958
## 11 Presumed    Finland               18.4     5112         1.51     21019        20763        1615
## 12 Presumed    France                16.8    58056        10.5      22603        22211        2160
## 13 Presumed    Italy                 11.1    57360        19.0      21554        21195        1757
## 14 Presumed    Norway                15.4     4386         1.35     26448        25769        2217
## 15 Presumed    Spain                 28.1    39666         7.84     16933        16584        1289
## 16 Presumed    Sweden                13.1     8789         1.95     22415        22094        1951
## 17 Presumed    Switzerland           14.2     7037        17.0      27233        26931        2776
## # ... with 20 more variables: health_lag_mean &lt;dbl&gt;, pubhealth_mean &lt;dbl&gt;, roads_mean &lt;dbl&gt;,
## #   cerebvas_mean &lt;dbl&gt;, assault_mean &lt;dbl&gt;, external_mean &lt;dbl&gt;, txp_pop_mean &lt;dbl&gt;,
## #   donors_sd &lt;dbl&gt;, pop_sd &lt;dbl&gt;, pop_dens_sd &lt;dbl&gt;, gdp_sd &lt;dbl&gt;, gdp_lag_sd &lt;dbl&gt;,
## #   health_sd &lt;dbl&gt;, health_lag_sd &lt;dbl&gt;, pubhealth_sd &lt;dbl&gt;, roads_sd &lt;dbl&gt;, cerebvas_sd &lt;dbl&gt;,
## #   assault_sd &lt;dbl&gt;, external_sd &lt;dbl&gt;, txp_pop_sd &lt;dbl&gt;</code></pre>
<p>All the numeric variables have been summarized. They are named using
the original variable, with the function’s name appended:
<code>donors_mean</code> and <code>donors_sd</code>, and so on. This is a compact way to rapidly transform our data in various ways. There is a family of <code>summarize_</code> functions for various tasks, and a complementary group of <code>mutate_</code> functions for when we want to add columns to the data rather than aggregated it.</p>
<p>With our data summarized by country, we can draw a dotplot with
<code>geom_point()</code>. Let’s also color the results by the consent law for
each country.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-bycountry-01"/>
<img src="../Images/54fe19bef527864af0679a092193b9cc.png" alt="A Cleveland dotplot, with colored points." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-bycountry-01-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.13: A Cleveland dotplot, with colored points.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb151-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> by_country,</a>
<a class="sourceLine" id="cb151-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> donors_mean, <span class="dt">y =</span> <span class="kw">reorder</span>(country, donors_mean),</a>
<a class="sourceLine" id="cb151-3" data-line-number="3">                          <span class="dt">color =</span> consent_law))</a>
<a class="sourceLine" id="cb151-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>(<span class="dt">size=</span><span class="dv">3</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb151-5" data-line-number="5"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">"Donor Procurement Rate"</span>,</a>
<a class="sourceLine" id="cb151-6" data-line-number="6">         <span class="dt">y =</span> <span class="st">""</span>, <span class="dt">color =</span> <span class="st">"Consent Law"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb151-7" data-line-number="7"><span class="st">    </span><span class="kw">theme</span>(<span class="dt">legend.position=</span><span class="st">"top"</span>)</a></code></pre>
<p>Alternatively, if we liked, we could use a facet instead of coloring
the points. Using <code>facet_wrap()</code> we can split the <code>consent_law</code>
variable into two panels, and then rank the countries by donation rate
within each panel. Because we have a categorical variable on our
y-axis, there are two wrinkles worth noting. First, if we leave
<code>facet_wrap()</code> to its defaults, the panels will be plotted side by
side. This will make it difficult to compare the two groups on the
same scale. Instead the plot will be read left to right, which is not
useful. To avoid this, we will have the panels appear one on top of
the other by saying we only want toq have one column. This is the
<code>ncol=1</code> argument. Second, and again because we have a categorical
variable on the y-axis, the default facet plot will have the names of
every country appear on the y-axis of <em>both</em> panels. (Were the y-axis a
continuous variable this would be the what we would want.) In that
case, only half the rows in each panel of our plot will have points in
them.</p>
<p>To avoid this we allow the y-axes scale to be free. This is the
<code>scales="free_y"</code> argument. Again, for faceted plots where both
variables are continuous, we generally do not want the scales to be
free, because it allows the x- or y-axis for each panel to vary with
the range of the data inside that panel only, instead of the range
across the whole dataset. Ordinarily, the point of small-multiple
facets is to be able to compare across the panels. This means free
scales are usually not a good idea, because each panel gets its own x-
or y-axis range, which breaks comparability. But where one axis is
categorical, as here, we can free the categorical axis and leave the
continuous one fixed. The result is that each panel shares the same
x-axis, and it is easy to compare between them.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-bycountry-02"/>
<img src="../Images/f23ad812ec7dc45c1eb758591a5bc983.png" alt="A faceted dotplot with free scales on the y-axis." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-bycountry-02-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.14: A faceted dotplot with free scales on the y-axis.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb152-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> by_country,</a>
<a class="sourceLine" id="cb152-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> donors_mean,</a>
<a class="sourceLine" id="cb152-3" data-line-number="3">                          <span class="dt">y =</span> <span class="kw">reorder</span>(country, donors_mean)))</a>
<a class="sourceLine" id="cb152-4" data-line-number="4"/>
<a class="sourceLine" id="cb152-5" data-line-number="5">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>(<span class="dt">size=</span><span class="dv">3</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb152-6" data-line-number="6"><span class="st">    </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>consent_law, <span class="dt">scales =</span> <span class="st">"free_y"</span>, <span class="dt">ncol =</span> <span class="dv">1</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb152-7" data-line-number="7"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x=</span> <span class="st">"Donor Procurement Rate"</span>,</a>
<a class="sourceLine" id="cb152-8" data-line-number="8">         <span class="dt">y=</span> <span class="st">""</span>) </a></code></pre>
<p>Cleveland dotplots are generally preferred to bar or column charts.
When making them, put the categories on the y-axis and order them in
the way that is most relevant to the numerical summary you are
providing. This sort of plot is also an excellent way to summarize
model results or any data with with error ranges. We use
<code>geom_point()</code> to draw our dotplots. There is a geom called
<code>geom_dotplot()</code>, but it is designed to produce a different sort of
figure. It is a kind of histogram, with individual observations represented
by dots that are then stacked on top of one another to show how many
of them there are.</p>
<p>The Cleveland-style dotplot can be extended to cases where we want to
include some information about variance or error in the plot. Using
<code>geom_pointrange()</code>, we can tell ggplot to show us a point estimate
and a range around it. Here we will use the standard deviation of the
donation rate that we calculated above. But this is also the natural
way to present, for example, estimates of model coefficients with
confidence intervals. With <code>geom_pointrange()</code> we map our <code>x</code> and <code>y</code>
variables as usual, but the function needs a little more information
than <code>geom_point</code>. It needs to know the range of the line to draw on
either side of the point, defined by the arguments <code>ymax</code> and <code>ymin</code>.
This is given by the y value (<code>donors_mean</code>) plus or minus its standard
deviation (<code>donors_sd</code>). If a function argument expects a number, it is
OK to give it a mathematical expression that resolves to the number
you want. R will calculate the result for you.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb153-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> by_country, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">reorder</span>(country,</a>
<a class="sourceLine" id="cb153-2" data-line-number="2">              donors_mean), <span class="dt">y =</span> donors_mean))</a>
<a class="sourceLine" id="cb153-3" data-line-number="3"/>
<a class="sourceLine" id="cb153-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_pointrange</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">ymin =</span> donors_mean <span class="op">-</span><span class="st"> </span>donors_sd,</a>
<a class="sourceLine" id="cb153-5" data-line-number="5">       <span class="dt">ymax =</span> donors_mean <span class="op">+</span><span class="st"> </span>donors_sd)) <span class="op">+</span></a>
<a class="sourceLine" id="cb153-6" data-line-number="6"><span class="st">     </span><span class="kw">labs</span>(<span class="dt">x=</span> <span class="st">""</span>, <span class="dt">y=</span> <span class="st">"Donor Procurement Rate"</span>) <span class="op">+</span><span class="st"> </span><span class="kw">coord_flip</span>()</a></code></pre>
<div class="figure"><span id="fig:ch-05-bycountry-03"/>
<p class="caption marginnote shownote">
Figure 5.15: A dot-and-whisker plot, with the range defined by the standard deviation of the measured variable.
</p>
<img src="../Images/952e4fd0cb72b9c57a8b9aa4a0a54573.png" alt="A dot-and-whisker plot, with the range defined by the standard deviation of the measured variable." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-bycountry-03-1.png"/>
</div>
<p>Because <code>geom_pointrange()</code> expects <code>y</code>, <code>ymin</code>, and <code>ymax</code> as arguments, we map <code>donors_mean</code> to <code>y</code> and the <code>ccode</code> variable to <code>x</code>, then flip the axes at the end with <code>coord_flip()</code>.</p>
</div>
<div id="plot-text-directly" class="section level2">
<h2><span class="header-section-number">5.3</span> Plot text directly</h2>
<p>It can sometimes be useful to plot the labels along with the points in a scatterplot, or just plot informative labels directly. We can do this with <code>geom_text()</code>.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-bycountry-04"/>
<img src="../Images/98e62e9b42d105ddde8909e3548704e4.png" alt="Plotting labels and text." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-bycountry-04-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.16: Plotting labels and text.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb154-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> by_country,</a>
<a class="sourceLine" id="cb154-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> roads_mean, <span class="dt">y =</span> donors_mean))</a>
<a class="sourceLine" id="cb154-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_text</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">label =</span> country))</a></code></pre>
<p>The text is plotted right on top of the points, because both are positioned using the same x and y mapping. One way of dealing with this, often the most effective if we are not too worried about excessive precision in the graph, is to remove the points by dropping <code>geom_point()</code> from the plot. A second option is to adjust the position of the text. We can left- or right-justify the labels using the <code>hjust</code> argument to <code>geom_text()</code>. Setting <code>hjust=0</code> will left justify the label, and <code>hjust=1</code> will right justify it.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb155-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> by_country,</a>
<a class="sourceLine" id="cb155-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> roads_mean, <span class="dt">y =</span> donors_mean))</a>
<a class="sourceLine" id="cb155-3" data-line-number="3"/>
<a class="sourceLine" id="cb155-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_text</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">label =</span> country), <span class="dt">hjust =</span> <span class="dv">0</span>)</a></code></pre>
<p>You might be tempted to try different values to <code>hjust</code> to fine-tune your labels. But this is not a robust approach. It will often fail because the space is added in proportion to the length of the label. The result is that longer labels move further away from their points than you want. There are ways around this, but they introduce other problems.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-bycountry-05"/>
<img src="../Images/13eb6a51f767063ac5af3c89c8c60bea.png" alt="Plot points and text labels, with a horizontal position adjustment." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-bycountry-05-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.17: Plot points and text labels, with a horizontal position adjustment.<!--</p>-->
<!--</div>--></span>
</p>
<p>Instead of wrestling any further with <code>geom_text()</code>, we will use <code>ggrepel</code> instead. This very useful library adds some new geoms to ggplot. Just as <code>ggplot</code> extends the plotting capabilities of R, there are many small libraries that extend the capabilities of <code>ggplot</code>, often by providing some new type of <code>geom</code>. The <code>ggrepel</code> library provides <code>geom_text_repel()</code> and <code>geom_label_repel()</code>, two geoms that can pick out labels much more flexibly than the default <code>geom_text()</code>. First, make sure the library is installed, then load it in the usual way:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb156-1" data-line-number="1"><span class="kw">library</span>(ggrepel)</a></code></pre>
<p>We will use <code>geom_text_repel()</code> instead of <code>geom_text()</code>. To demonstrate some of what <code>geom_text_repel()</code> can do, we will switch datasets and work with some historical U.S. presidential election data provided in the <code>socviz</code> library.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb157-1" data-line-number="1">elections_historic <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(<span class="dv">2</span><span class="op">:</span><span class="dv">7</span>) </a></code></pre>
<pre><code>## # A tibble: 49 x 6
##     year winner                 win_party ec_pct popular_pct popular_margin
##    &lt;int&gt; &lt;chr&gt;                  &lt;chr&gt;      &lt;dbl&gt;       &lt;dbl&gt;          &lt;dbl&gt;
##  1  1824 John Quincy Adams      D.-R.      0.322       0.309        -0.104 
##  2  1828 Andrew Jackson         Dem.       0.682       0.559         0.122 
##  3  1832 Andrew Jackson         Dem.       0.766       0.547         0.178 
##  4  1836 Martin Van Buren       Dem.       0.578       0.508         0.142 
##  5  1840 William Henry Harrison Whig       0.796       0.529         0.0605
##  6  1844 James Polk             Dem.       0.618       0.495         0.0145
##  7  1848 Zachary Taylor         Whig       0.562       0.473         0.0479
##  8  1852 Franklin Pierce        Dem.       0.858       0.508         0.0695
##  9  1856 James Buchanan         Dem.       0.588       0.453         0.122 
## 10  1860 Abraham Lincoln        Rep.       0.594       0.396         0.101 
## # ... with 39 more rows</code></pre>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb159-1" data-line-number="1">p_title &lt;-<span class="st"> "Presidential Elections: Popular &amp; Electoral College Margins"</span></a>
<a class="sourceLine" id="cb159-2" data-line-number="2">p_subtitle &lt;-<span class="st"> "1824-2016"</span></a>
<a class="sourceLine" id="cb159-3" data-line-number="3">p_caption &lt;-<span class="st"> "Data for 2016 are provisional."</span></a>
<a class="sourceLine" id="cb159-4" data-line-number="4">x_label &lt;-<span class="st"> "Winner's share of Popular Vote"</span></a>
<a class="sourceLine" id="cb159-5" data-line-number="5">y_label &lt;-<span class="st"> "Winner's share of Electoral College Votes"</span></a>
<a class="sourceLine" id="cb159-6" data-line-number="6"/>
<a class="sourceLine" id="cb159-7" data-line-number="7">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(elections_historic, <span class="kw">aes</span>(<span class="dt">x =</span> popular_pct, <span class="dt">y =</span> ec_pct,</a>
<a class="sourceLine" id="cb159-8" data-line-number="8">                                    <span class="dt">label =</span> winner_label))</a>
<a class="sourceLine" id="cb159-9" data-line-number="9"/>
<a class="sourceLine" id="cb159-10" data-line-number="10">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_hline</span>(<span class="dt">yintercept =</span> <span class="fl">0.5</span>, <span class="dt">size =</span> <span class="fl">1.4</span>, <span class="dt">color =</span> <span class="st">"gray80"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb159-11" data-line-number="11"><span class="st">    </span><span class="kw">geom_vline</span>(<span class="dt">xintercept =</span> <span class="fl">0.5</span>, <span class="dt">size =</span> <span class="fl">1.4</span>, <span class="dt">color =</span> <span class="st">"gray80"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb159-12" data-line-number="12"><span class="st">    </span><span class="kw">geom_point</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb159-13" data-line-number="13"><span class="st">    </span><span class="kw">geom_text_repel</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb159-14" data-line-number="14"><span class="st">    </span><span class="kw">scale_x_continuous</span>(<span class="dt">labels =</span> scales<span class="op">::</span>percent) <span class="op">+</span></a>
<a class="sourceLine" id="cb159-15" data-line-number="15"><span class="st">    </span><span class="kw">scale_y_continuous</span>(<span class="dt">labels =</span> scales<span class="op">::</span>percent) <span class="op">+</span></a>
<a class="sourceLine" id="cb159-16" data-line-number="16"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x =</span> x_label, <span class="dt">y =</span> y_label, <span class="dt">title =</span> p_title, <span class="dt">subtitle =</span> p_subtitle,</a>
<a class="sourceLine" id="cb159-17" data-line-number="17">         <span class="dt">caption =</span> p_caption)</a></code></pre>
<p>Figure <a href="workgeoms.html#fig:ch-05-electionplot-01">5.18</a> takes each U.S. presidential election since 1824 (the first year that the size of the popular vote was recorded), and plots the winner’s share of the popular vote against the winner’s share of the electoral college vote. The shares are stored in the data as proportions (from 0 to 1) rather than percentages, so we need to adjust the labels of the scales using <code>scale_x_continuous()</code> and <code>scale_y_continuous()</code>. Seeing as we are interested in particular presidencies, we also want to label the points. But<label for="tufte-mn-65" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-65" class="margin-toggle"/><span class="marginnote shownote">Normally it is not a good idea to label every point on a plot in the way we do here. A better approach might be to select a few points of particular interest.</span> because many of the data points are plotted quite close together we need to make sure the labels do not overlap with each other, or obscure other points. The <code>geom_text_repel()</code> function handles the problem very well. This plot has relatively long labels. We could put them directly in the code, but just to keep things a bit tidier we assign the text to some named objects instead. Then we use those in the plot formula.</p>
<div class="figure fullwidth"><span id="fig:ch-05-electionplot-01"/>
<img src="../Images/a2613e5adc2cd4f46414ddca11200103.png" alt="Text labels with ggrepel." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-electionplot-01-1.png"/>
<p class="caption marginnote shownote">
Figure 5.18: Text labels with ggrepel.
</p>
</div>
<p>In this plot, what is of interest about any particular point is the
quadrant of the x-y plane each point it is in, and how far away it is
from the fifty percent threshold on both the x-axis (with the popular
vote share) and the y-axis (with the electoral college vote share). To
underscore this point we draw two reference lines at the fifty percent
line in each direction. They are drawn at the beginning of the plotting process so that the points and labels can be layered on top of them. We use two new geoms, <code>geom_hline()</code> and <code>geom_vline()</code> to make the lines. They take <code>yintercept</code> and <code>xintercept</code> arguments, respectively, and the lines can also be sized
and colored as you please. There is also a <code>geom_abline()</code> geom that
draws straight lines based on a supplied slope and intercept. This is
useful for plotting, for example, 45 degree reference lines in scatterplots.</p>
<p>The ggrepel package has several other useful geoms and options to aid with effectively plotting labels along with points. The performance of its labeling algorithm is consistently very good. For many purposes it will be a better first choice than <code>geom_text()</code>.</p>
</div>
<div id="label-outliers" class="section level2">
<h2><span class="header-section-number">5.4</span> Label outliers</h2>
<p>Sometimes we want to pick out some points of interest in the data
without labeling every single item. We can still use <code>geom_text()</code> or
<code>geom_text_repel()</code>. We just need to pick out the points we want to
label. In the code above, we do this on the fly by telling
<code>geom_text_repel()</code> to use a different data set from the one
<code>geom_point()</code> is using. We do this using the <code>subset()</code> function.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-texlabhidden-01"/>
<img src="../Images/5d49387a28c157265c595c015e091824.png" alt="Top: Labeling text according to a single criterion. Bottom: Labeling according to several criteria." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-texlabhidden-01-1.png"/><img src="../Images/ede49654a99f1b182c6ac76cf63d9833.png" alt="Top: Labeling text according to a single criterion. Bottom: Labeling according to several criteria." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-texlabhidden-01-2.png"/>
<!--
<p class="caption marginnote">-->Figure 5.19: Top: Labeling text according to a single criterion. Bottom: Labeling according to several criteria.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb160-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> by_country,</a>
<a class="sourceLine" id="cb160-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> gdp_mean, <span class="dt">y =</span> health_mean))</a>
<a class="sourceLine" id="cb160-3" data-line-number="3"/>
<a class="sourceLine" id="cb160-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb160-5" data-line-number="5"><span class="st">    </span><span class="kw">geom_text_repel</span>(<span class="dt">data =</span> <span class="kw">subset</span>(by_country, gdp_mean <span class="op">&gt;</span><span class="st"> </span><span class="dv">25000</span>),</a>
<a class="sourceLine" id="cb160-6" data-line-number="6">                    <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">label =</span> country))</a>
<a class="sourceLine" id="cb160-7" data-line-number="7"/>
<a class="sourceLine" id="cb160-8" data-line-number="8">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> by_country,</a>
<a class="sourceLine" id="cb160-9" data-line-number="9">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> gdp_mean, <span class="dt">y =</span> health_mean))</a>
<a class="sourceLine" id="cb160-10" data-line-number="10"/>
<a class="sourceLine" id="cb160-11" data-line-number="11">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb160-12" data-line-number="12"><span class="st">    </span><span class="kw">geom_text_repel</span>(<span class="dt">data =</span> <span class="kw">subset</span>(by_country,</a>
<a class="sourceLine" id="cb160-13" data-line-number="13">                                  gdp_mean <span class="op">&gt;</span><span class="st"> </span><span class="dv">25000</span> <span class="op">|</span><span class="st"> </span>health_mean <span class="op">&lt;</span><span class="st"> </span><span class="dv">1500</span> <span class="op">|</span></a>
<a class="sourceLine" id="cb160-14" data-line-number="14"><span class="st">                                  </span>country <span class="op">%in%</span><span class="st"> "Belgium"</span>),</a>
<a class="sourceLine" id="cb160-15" data-line-number="15">                    <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">label =</span> country))</a></code></pre>
<p>In the first figure, we specify a new <code>data</code> argument to the text
geom, and use <code>subset()</code> to create a small dataset on the fly. The
<code>subset()</code> function takes the <code>by_country</code> object and selects only the
cases where <code>gdp_mean</code> is over 25,000, with the result that only those
points are labeled in the plot. The criteria we use can be whatever we
like, as long as we can write a logical expression that defines it.
For example, in the lower figure we pick out cases where <code>gdp_mean</code> is
greater than 25,000, <em>or</em> <code>health_mean</code> is less than 1,500, <em>or</em> the
country is Belgium. In all of these plots, because we are using
<code>geom_text_repel()</code>, we no longer have to worry about our earlier
problem where the country labels were clipped at the edge of the plot.</p>
<p>Alternatively, we can pick out specific points by creating a dummy variable in the data set just for this purpose. Here we add a column to <code>organdata</code> called <code>ind</code>. An observation gets coded as <code>TRUE</code> if <code>ccode</code> is “Ita”, or “Spa”, <em>and</em> if the <code>year</code> is greater than 1998. We use this new <code>ind</code> variable in two ways in the plotting code. First, we map it to the <code>color</code> aesthetic in the usual way. Second, we use it to subset the data that the text geom will label. Then we suppress the legend that would otherwise appear for the <code>label</code> and <code>color</code> aesthetics by using the <code>guides()</code> function.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-guidesplot-01"/>
<img src="../Images/caf5eb8cfdc0c144bcad11c66fd01e87.png" alt="Labeling using a dummy variable." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-guidesplot-01-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.20: Labeling using a dummy variable.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb161-1" data-line-number="1">organdata<span class="op">$</span>ind &lt;-<span class="st"> </span>organdata<span class="op">$</span>ccode <span class="op">%in%</span><span class="st"> </span><span class="kw">c</span>(<span class="st">"Ita"</span>, <span class="st">"Spa"</span>) <span class="op">&amp;</span></a>
<a class="sourceLine" id="cb161-2" data-line-number="2"><span class="st">                    </span>organdata<span class="op">$</span>year <span class="op">&gt;</span><span class="st"> </span><span class="dv">1998</span></a>
<a class="sourceLine" id="cb161-3" data-line-number="3"/>
<a class="sourceLine" id="cb161-4" data-line-number="4">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb161-5" data-line-number="5">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> roads,</a>
<a class="sourceLine" id="cb161-6" data-line-number="6">                          <span class="dt">y =</span> donors, <span class="dt">color =</span> ind))</a>
<a class="sourceLine" id="cb161-7" data-line-number="7">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb161-8" data-line-number="8"><span class="st">    </span><span class="kw">geom_text_repel</span>(<span class="dt">data =</span> <span class="kw">subset</span>(organdata, ind),</a>
<a class="sourceLine" id="cb161-9" data-line-number="9">                    <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">label =</span> ccode)) <span class="op">+</span></a>
<a class="sourceLine" id="cb161-10" data-line-number="10"><span class="st">    </span><span class="kw">guides</span>(<span class="dt">label =</span> <span class="ot">FALSE</span>, <span class="dt">color =</span> <span class="ot">FALSE</span>)</a></code></pre>
</div>
<div id="write-and-draw-in-the-plot-area" class="section level2">
<h2><span class="header-section-number">5.5</span> Write and draw in the plot area</h2>
<p>Sometimes we want to annotate the figure directly. Maybe we need to
point out something important that is not mapped to a variable. We use
<code>annotate()</code> for this purpose. It isn’t quite a geom, as it doesn’t
accept any variable mappings from our data. Instead, it can <em>use</em>
geoms, temporarily taking advantage of their features in order to
place something on the plot. The most obvious use-case is putting
arbitrary text on the plot.</p>
<p>We will tell <code>annotate()</code> to use a text geom. It hands the plotting
duties to <code>geom_text()</code>, which means that we can use all of that geom’s
arguments in the <code>annotate()</code> call. This includes the <code>x</code>, <code>y</code>, and <code>label</code>
arguments, as one would expect, but also things like <code>size</code>, <code>color</code>, and
the <code>hjust</code> and <code>vjust</code> settings that allow text to be justified. This is
particularly useful when our label has several lines in it. We include
extra lines by using the special “newline” code, <code>\n</code>, which we use
instead of a space to force a line-break as needed.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-annotate-01"/>
<img src="../Images/3f86d50559672b7f362dad81b3e0db5d.png" alt="Arbitrary text with &lt;code&gt;annotate()&lt;/code&gt;." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-annotate-01-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.21: Arbitrary text with <code>annotate()</code>.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb162-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> roads, <span class="dt">y =</span> donors))</a>
<a class="sourceLine" id="cb162-2" data-line-number="2">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">annotate</span>(<span class="dt">geom =</span> <span class="st">"text"</span>, <span class="dt">x =</span> <span class="dv">91</span>, <span class="dt">y =</span> <span class="dv">33</span>,</a>
<a class="sourceLine" id="cb162-3" data-line-number="3">                            <span class="dt">label =</span> <span class="st">"A surprisingly high </span><span class="ch">\n</span><span class="st"> recovery rate."</span>,</a>
<a class="sourceLine" id="cb162-4" data-line-number="4">                            <span class="dt">hjust =</span> <span class="dv">0</span>)</a></code></pre>
<p>The <code>annotate()</code> function can work with other geoms, too. Use it to
draw rectangles, line segments, and arrows. Just remember to pass
along the right arguments to the geom you use. We can add a rectangle
to this plot, for instance, with a second call to the function.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb163-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb163-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> roads, <span class="dt">y =</span> donors))</a>
<a class="sourceLine" id="cb163-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb163-4" data-line-number="4"><span class="st">    </span><span class="kw">annotate</span>(<span class="dt">geom =</span> <span class="st">"rect"</span>, <span class="dt">xmin =</span> <span class="dv">125</span>, <span class="dt">xmax =</span> <span class="dv">155</span>,</a>
<a class="sourceLine" id="cb163-5" data-line-number="5">             <span class="dt">ymin =</span> <span class="dv">30</span>, <span class="dt">ymax =</span> <span class="dv">35</span>, <span class="dt">fill =</span> <span class="st">"red"</span>, <span class="dt">alpha =</span> <span class="fl">0.2</span>) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb163-6" data-line-number="6"><span class="st">    </span><span class="kw">annotate</span>(<span class="dt">geom =</span> <span class="st">"text"</span>, <span class="dt">x =</span> <span class="dv">157</span>, <span class="dt">y =</span> <span class="dv">33</span>,</a>
<a class="sourceLine" id="cb163-7" data-line-number="7">             <span class="dt">label =</span> <span class="st">"A surprisingly high </span><span class="ch">\n</span><span class="st"> recovery rate."</span>, <span class="dt">hjust =</span> <span class="dv">0</span>)</a></code></pre>
<div class="figure"><span id="fig:ch-05-annotate-02"/>
<p class="caption marginnote shownote">
Figure 5.22: Using two different geoms with <code>annotate()</code>.
</p>
<img src="../Images/6e64df4718fa9855a4e9dac823c96edf.png" alt="Using two different geoms with &lt;code&gt;annotate()&lt;/code&gt;." width="90%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-annotate-02-1.png"/>
</div>
</div>
<div id="understanding-scales-guides-and-themes" class="section level2">
<h2><span class="header-section-number">5.6</span> Understanding scales, guides, and themes</h2>
<p>This chapter has gradually extended our ggplot vocabulary in two ways. First, we introduced some new <code>geom_</code> functions that allowed us to draw new kinds of plots. Second, we made use of new functions controlling some aspects of the appearance of our graph. We used <code>scale_x_log10()</code>, <code>scale_x_continuous()</code> and other <code>scale_</code> functions to adjust axis labels. We used the <code>guides()</code> function to remove the legends for a <code>color</code> mapping and a <code>label</code> mapping. And we also used the <code>theme()</code> function to move the position of a legend from the side to the top of a figure.</p>
<p>Learning about new geoms extended what we have seen already. Each geom makes a different type of plot. Different plots require different mappings in order to work, and so each <code>geom_</code> function takes mappings tailored to the kind of graph it draws. You can’t use <code>geom_point()</code> to make a scatterplot without supplying an <code>x</code> and a <code>y</code> mapping, for example. Using <code>geom_histogram()</code> only requires you to supply an <code>x</code> mapping. Similarly, <code>geom_pointrange()</code> requires <code>ymin</code> and <code>ymax</code> mappings in order to know where to draw the lineranges it makes. A <code>geom_</code> function may take optional arguments, too. When using <code>geom_boxplot()</code> you can specify what the outliers look like using arguments like <code>outlier.shape</code> and <code>outlier.color</code>.</p>
<p>The second kind of extension introduced some new functions, and with them some new concepts. What are the differences between the <code>scale_</code> functions, the <code>guides()</code> function, and the <code>theme()</code> function? When do you know to use one rather than the other? Why are there so many <code>scale_</code> functions listed in the online help, anyway? How can you tell which one you need?</p>
<p>Here is a rough and ready starting point:</p>
<ul>
<li>Every aesthetic mapping has a scale. If you want to adjust how that scale is marked or graduated, then you use a <code>scale_</code> function.</li>
<li>Many scales come with a legend or key to help the reader interpret the graph. These are called <em>guides</em>. You can make adjustments to them with the <code>guides()</code> function. Perhaps the most common use case is to make the legend disappear, as it is sometimes superfluous. Another is to adjust the arrangement of the key in legends and colorbars.</li>
<li>Graphs have other features not strictly connected to the logical
structure of the data being displayed. These include things like
their background color, the typeface used for labels, or the
placement of the legend on the graph. To adjust these, use the
<code>theme()</code> function.</li>
</ul>
<p>Consistent with ggplot’s overall approach, adjusting some visible feature of the graph means first thinking about the relationship that the feature has with the underlying data. Roughly speaking, if the change you want to make will affect the substantive interpretation of any particular geom, then most likely you will either be mapping an aesthetic to a variable using that geom’s <code>aes()</code> function, or you will be specifying a change via some <code>scale_</code> function. If the change you want to make does not affect the interpretation of a given geom_, then most likely you will either be setting a variable inside the <code>geom_</code> function, or making a cosmetic change via the <code>theme()</code> function.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-scalesfig-01"/>
<img src="../Images/2baf5a838809dd86e16a88cbfc970f7e.png" alt="Every mapped variable has a scale." width="576" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-scalesfig-01-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.23: Every mapped variable has a scale.<!--</p>-->
<!--</div>--></span>
</p>
<p>Scales and guides are closely connected, which can make things confusing. The guide provides information about the scale, such as in a legend or colorbar. Thus, it is possible to make adjustments to guides from inside the various <code>scale_</code> functions. More often it is easier to use the <code>guides()</code> function directly.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb164-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb164-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> roads,</a>
<a class="sourceLine" id="cb164-3" data-line-number="3">                          <span class="dt">y =</span> donors,</a>
<a class="sourceLine" id="cb164-4" data-line-number="4">                          <span class="dt">color =</span> world))</a>
<a class="sourceLine" id="cb164-5" data-line-number="5">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>()</a></code></pre>
<p>Figure <a href="workgeoms.html#fig:ch-05-scalesfig-01">5.23</a> shows a plot with three aesthetic mappings. The variable <code>roads</code> is mapped to <code>x</code>; <code>donors</code> is mapped to <code>y</code>; and <code>world</code> is mapped to <code>color</code>. The <code>x</code> and <code>y</code> scales are both <em>continuous</em>, running smoothly from just under the lowest value of the variable to just over the highest value. Various labeled tick marks orient the reader to the values on each axis. The <code>color</code> mapping also has a scale. The <code>world</code> measure is an unordered categorical variable, so its scale is <em>discrete</em>. It takes one of four values, each represented by a different color.</p>
<p>Along with <code>color</code>, mappings like <code>fill</code>, <code>shape</code>, and <code>size</code> will have scales that we might want to customize or adjust. We could have mapped <code>world</code> to <code>shape</code> instead of <code>color</code>. In that case our four-category variable would have a scale consisting of four different shapes. Scales for these mappings may have labels, axis tick marks at particular positions, or specific colors or shapes. If we want to adjust them, we use one of the <code>scale_</code> functions.</p>
<p>Many different kinds of variable can be mapped. More often than not <code>x</code> and <code>y</code> are continuous measures. But they might also easily be discrete, as when we mapped country names to the <code>y</code> axis in our boxplots and dotplots. An <code>x</code> or <code>y</code> mapping can also be defined as a transformation onto a log scale, or as a special sort of number value like a date. Similarly, a <code>color</code> or a <code>fill</code> mapping can be discrete and <em>unordered</em>, as with our <code>world</code> variable, or discrete and <em>ordered</em>, as with letter grades in an exam. A <code>color</code> or <code>fill</code> mapping can also be a continuous quantity, represented as a gradient running smoothly from a low to a high value. Finally, both continuous gradients and ordered discrete values might have some defined neutral midpoint with extremes diverging in both directions.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-scale-template"/>
<img src="../Images/f68891a3a348d121e8d9d743eaa18404.png" alt="A schema for naming the &lt;code&gt;scale&lt;/code&gt; functions." width="280" data-original-src="https://socviz.co/assets/ch-05-scale_mapping_kind.png"/>
<!--
<p class="caption marginnote">-->Figure 5.24: A schema for naming the <code>scale</code> functions.<!--</p>-->
<!--</div>--></span>
</p>
<p>Because we have several potential mappings, and each mapping might be to one of several different scales, we end up with a lot of individual <code>scale_</code> functions. Each deals with one combination of mapping and scale. They are named according to a consistent logic, shown in Figure <a href="workgeoms.html#fig:ch-05-scale-template">5.24</a>. First comes the <code>scale_</code> name, then the <em>mapping</em> it applies to, and finally the <em>kind</em> of value the scale will display. Thus, the <code>scale_x_continuous()</code> function controls <code>x</code> scales for continuous variables; <code>scale_y_discrete()</code> adjusts <code>y</code> scales for discrete variables; and <code>scale_x_log10()</code> transforms an <code>x</code> mapping to a log scale. Most of the time, ggplot will guess correctly what sort of scale is needed for your mapping. Then it will work out some default features of the scale (such as its labels and where the tick marks go). In many cases you will not need to make any scale adjustments. If <code>x</code> is mapped to a continuous variable then adding <code>+ scale_x_continuous()</code> to your plot statement with no further arguments will have no effect. It is already there implicitly. Adding <code>+ scale_x_log10()</code>, on the other hand, will transform your scale, as now you have replaced the default treatment of a continuous x variable.</p>
<p>If you want to adjust the labels or tick marks on a scale, you will need to know which mapping it is for and what sort of scale it is. Then you supply the arguments to the appropriate scale function. For example, we can change the x-axis of the previous plot to a log scale, and then also change the position and labels of the tick marks on the y-axis.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-scalesfig-02"/>
<img src="../Images/cc6fa882fd8215de245122737bccb83c.png" alt="Making some scale adjustments." width="90%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-scalesfig-02-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.25: Making some scale adjustments.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb165-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb165-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> roads,</a>
<a class="sourceLine" id="cb165-3" data-line-number="3">                          <span class="dt">y =</span> donors,</a>
<a class="sourceLine" id="cb165-4" data-line-number="4">                          <span class="dt">color =</span> world))</a>
<a class="sourceLine" id="cb165-5" data-line-number="5">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb165-6" data-line-number="6"><span class="st">    </span><span class="kw">scale_x_log10</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb165-7" data-line-number="7"><span class="st">    </span><span class="kw">scale_y_continuous</span>(<span class="dt">breaks =</span> <span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">15</span>, <span class="dv">25</span>),</a>
<a class="sourceLine" id="cb165-8" data-line-number="8">                       <span class="dt">labels =</span> <span class="kw">c</span>(<span class="st">"Five"</span>, <span class="st">"Fifteen"</span>, <span class="st">"Twenty Five"</span>))</a></code></pre>
<p>The same applies to mappings like <code>color</code> and <code>fill</code>. Here the available <code>scale_</code> functions include ones that deal with continuous, diverging, and discrete variables, as well as others that we will encounter later when we discuss the use of color and color palettes in more detail. When working with a scale that produces a legend, we can also use this its <code>scale_</code> function to specify the labels in the key. To change the <em>title</em> of the legend, however, we use the <code>labs()</code> function, which lets us label all the mappings.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-scalesfig-03"/>
<img src="../Images/de3905e462410cdccab6ff95d4746cc5.png" alt="Relabeling via a scale function." width="90%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-scalesfig-03-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.26: Relabeling via a scale function.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb166-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb166-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> roads,</a>
<a class="sourceLine" id="cb166-3" data-line-number="3">                          <span class="dt">y =</span> donors,</a>
<a class="sourceLine" id="cb166-4" data-line-number="4">                          <span class="dt">color =</span> world))</a>
<a class="sourceLine" id="cb166-5" data-line-number="5">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb166-6" data-line-number="6"><span class="st">    </span><span class="kw">scale_color_discrete</span>(<span class="dt">labels =</span></a>
<a class="sourceLine" id="cb166-7" data-line-number="7">                             <span class="kw">c</span>(<span class="st">"Corporatist"</span>, <span class="st">"Liberal"</span>,</a>
<a class="sourceLine" id="cb166-8" data-line-number="8">                               <span class="st">"Social Democratic"</span>, <span class="st">"Unclassified"</span>)) <span class="op">+</span></a>
<a class="sourceLine" id="cb166-9" data-line-number="9"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">"Road Deaths"</span>,</a>
<a class="sourceLine" id="cb166-10" data-line-number="10">         <span class="dt">y =</span> <span class="st">"Donor Procurement"</span>,</a>
<a class="sourceLine" id="cb166-11" data-line-number="11">        <span class="dt">color =</span> <span class="st">"Welfare State"</span>)</a></code></pre>
<p>If we want to move the legend somewhere else on the plot, we are making a purely cosmetic decision and that is the job of the <code>theme()</code> function. As we have already seen, adding <code>+ theme(legend.position = "top")</code> will move the legend as instructed. Finally, to make the legend disappear altogether, we tell ggplot that we do not want a guide for that scale. This is generally not good practice, but there can be good reasons to do it. We will see some examples later on.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb167-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb167-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> roads,</a>
<a class="sourceLine" id="cb167-3" data-line-number="3">                          <span class="dt">y =</span> donors,</a>
<a class="sourceLine" id="cb167-4" data-line-number="4">                          <span class="dt">color =</span> world))</a>
<a class="sourceLine" id="cb167-5" data-line-number="5">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb167-6" data-line-number="6"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">"Road Deaths"</span>,</a>
<a class="sourceLine" id="cb167-7" data-line-number="7">         <span class="dt">y =</span> <span class="st">"Donor Procurement"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb167-8" data-line-number="8"><span class="st">    </span><span class="kw">guides</span>(<span class="dt">color =</span> <span class="ot">FALSE</span>)</a></code></pre>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-scalesfig-04"/>
<img src="../Images/c75b51f0fc2df917751b27f2d454693b.png" alt="Removing the guide to a scale." width="576" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-scalesfig-04-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.27: Removing the guide to a scale.<!--</p>-->
<!--</div>--></span>
</p>
<p>We will look more closely at <code>scale_</code> and <code>theme()</code> functions in Chapter <a href="refineplots.html#refineplots">8</a>, when we discuss how to polish plots that we are ready to display or publish. Until then, we will use <code>scale_</code> functions fairly regularly to make small adjustments to the labels and axes of our graphs. And we will occasionally use the <code>theme()</code> function to make some cosmetic adjustments here and there. So you do not need to worry too much about additional details of how they work until later on. But at this point it <em>is</em> worth knowing what <code>scale_</code> functions are for, and the logic behind their naming scheme. Understanding the <code>scale_&lt;mapping&gt;_&lt;kind&gt;()</code> rule makes it easier to see what is going on when one of these functions is called to make an adjustment to a plot.</p>
</div>
<div id="where-to-go-next-4" class="section level2">
<h2><span class="header-section-number">5.7</span> Where to go next</h2>
<p>We covered several new functions and data aggregation techniques in this Chapter. You should practice working with them.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-gapminder-revisit"/>
<img src="../Images/29521484b08d54e09144a78dfbe4c4ba.png" alt="Two figures from Chapter 1." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-gapminder-revisit-1.png"/><img src="../Images/4d47e812c07ab78006c1ab2415e80c88.png" alt="Two figures from Chapter 1." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-gapminder-revisit-2.png"/>
<!--
<p class="caption marginnote">-->Figure 5.28: Two figures from Chapter 1.<!--</p>-->
<!--</div>--></span>
</p>
<ul>
<li>The <code>subset()</code> function is very useful when used in conjunction with a series of layered geoms. Go back to your code for the Presidential Elections plot (Figure <a href="workgeoms.html#fig:ch-05-electionplot-01">5.18</a>) and redo it so that it shows all the data points but only labels elections since 1992. You might need to look again at the <code>elections_historic</code> data to see what variables are available to you. You can also experiment with subsetting by political party, or changing the colors of the points to reflect the winning party.</li>
<li>Use <code>geom_point()</code> and <code>reorder()</code> to make a Cleveland dot plot of all Presidential elections, ordered by share of the popular vote.</li>
<li>Try using <code>annotate()</code> to add a rectangle that lightly colors the entire upper left quadrant of Figure <a href="workgeoms.html#fig:ch-05-electionplot-01">5.18</a>.</li>
<li>The main action verbs in the <code>dplyr</code> library are <code>group_by()</code>, <code>filter()</code>, <code>select()</code>, <code>summarize()</code>, and <code>mutate()</code>. Practice with them by revisiting the <code>gapminder</code> data to see if you can reproduce a pair of graphs from Chapter One, shown here again in Figure <a href="workgeoms.html#fig:ch-05-gapminder-revisit">5.28</a>. You will need to filter some rows, group the data by continent, and calculate the mean life expectancy by continent before beginning the plotting process.</li>
<li>Get comfortable with grouping, mutating, and summarizing data in pipelines. This will become a routine task as you work with your data. There are many ways that tables can be aggregated and transformed. Remember <code>group_by()</code> groups your data from left to right, with the rightmost or innermost group being the level calculations will be done at; <code>mutate()</code> adds a column at the current level of grouping; and <code>summarize()</code> aggregates to the next level up. Try creating some grouped objects from the GSS data, calculating frequencies as you learned in this Chapter, and then check to see if the totals are what you expect. For example, start by grouping <code>degree</code> by <code>race</code>, like this:</li>
</ul>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb168-1" data-line-number="1">gss_sm <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(race, degree) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb168-2" data-line-number="2"><span class="st">    </span><span class="kw">summarize</span>(<span class="dt">N =</span> <span class="kw">n</span>()) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb168-3" data-line-number="3"><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">pct =</span> <span class="kw">round</span>(N <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(N)<span class="op">*</span><span class="dv">100</span>, <span class="dv">0</span>)) </a></code></pre>
<pre><code>## # A tibble: 18 x 4
## # Groups:   race [3]
##    race  degree             N   pct
##    &lt;fct&gt; &lt;fct&gt;          &lt;int&gt; &lt;dbl&gt;
##  1 White Lt High School   197  9.00
##  2 White High School     1057 50.0 
##  3 White Junior College   166  8.00
##  4 White Bachelor         426 20.0 
##  5 White Graduate         250 12.0 
##  6 White &lt;NA&gt;               4  0   
##  7 Black Lt High School    60 12.0 
##  8 Black High School      292 60.0 
##  9 Black Junior College    33  7.00
## 10 Black Bachelor          71 14.0 
## 11 Black Graduate          31  6.00
## 12 Black &lt;NA&gt;               3  1.00
## 13 Other Lt High School    71 26.0 
## 14 Other High School      112 40.0 
## 15 Other Junior College    17  6.00
## 16 Other Bachelor          39 14.0 
## 17 Other Graduate          37 13.0 
## 18 Other &lt;NA&gt;               1  0</code></pre>
<ul>
<li>This code is similar to what you saw earlier, but a little more compact. (We calculate the <code>pct</code> values directly.) Check the results are as you expect by grouping by <code>race</code> and summing the percentages. Try doing the same exercise grouping by <code>sex</code> or <code>region</code>.</li>
<li>Try summary calculations with functions other than <code>sum</code>. Can you calculate the mean and median number of children by <code>degree</code>? (Hint: the <code>childs</code> variable in <code>gss_sm</code> has children as a numeric value.)</li>
<li><p><code>dplyr</code> has a large number of helper functions that let you summarize data in many different ways. The vignette on <em>window functions</em> included with the <code>dplyr</code> documentation is a good place to begin learning about these. You should also look at Chapter 3 of <span class="citation">Wickham &amp; Grolemund (2016)</span> for more information on transforming data with <code>dplyr</code>.</p></li>
<li>Experiment with the <code>gapminder</code> data to practice some of
the new geoms we have learned. Try examining population or life
expectancy over time using a series of boxplots. (Hint: you may need
to use the <code>group</code> aesthetic in the <code>aes()</code> call.) Can you facet
this boxplot by continent? Is anything different if you create a tibble from <code>gapminder</code> that explicitly groups the data by <code>year</code> and <code>continent</code> first, and then create your plots with that?</li>
<li>Read the help page for <code>geom_boxplot()</code> and take a look at the <code>notch</code> and <code>varwidth</code> options. Try them out to see how they change the look of the plot.</li>
<li>As an alternative to <code>geom_boxplot()</code> try <code>geom_violin()</code> for a similar plot, but with a mirrored density distribution instead of a box and whiskers.</li>
<li><p><code>geom_pointrange()</code> is one of a family of related geoms that produce different kinds of error bars and ranges, depending on your specific needs. They include <code>geom_linerange()</code>, <code>geom_crossbar()</code>, and <code>geom_errorbar()</code>. Try them out using <code>gapminder</code> or <code>organdata</code> to see how they differ.</p></li>
</ul>

</div>
&#13;

<h2><span class="header-section-number">5.1</span> Use pipes to summarize data</h2>
<p>In Chapter <a href="groupfacettx.html#groupfacettx">4</a> we began making plots of the
distributions and relative frequencies of variables. Cross-classifying
one measure by another is one of the basic descriptive tasks in data
analysis. Tables <a href="workgeoms.html#tab:relig1">5.1</a> and <a href="workgeoms.html#tab:relig2">5.2</a> show two
common ways of summarizing our GSS data on the distribution of
religious affiliation and region. Table <a href="workgeoms.html#tab:relig1">5.1</a> shows the
column marginals, where the numbers sum to a hundred by column and
show, e.g., the distribution of Protestants across regions. Meanwhile
in Table <a href="workgeoms.html#tab:relig2">5.2</a> the numbers sum to a hundred across the
rows, showing for example the distribution of religious affiliations
within any particular region.</p>
<p>We saw in Chapter <a href="groupfacettx.html#groupfacettx">4</a> that <code>geom_bar()</code> can plot
both counts and relative frequencies depending on what we asked of it.
In practice, though, letting the geoms (and their <code>stat_</code> functions)
do the work can sometimes get a little confusing. It is too easy to
lose track of whether one has calculated row margins, column margins,
or overall relative frequencies. The code to do the calculations on
the fly ends up stuffed into the mapping function and can become hard
to read. A better strategy is to calculate the frequency table you
want first, and then plot that table. This has the benefit of allowing
you do to some quick sanity checks on your tables, to make sure you
haven’t made any errors.</p>
<p><!--
<caption>--><span class="marginnote shownote"><span id="tab:relig2">Table 5.2: </span>Row marginals. (Numbers in rows sum to 100.)</span><!--</caption>--></p>
<table>
<thead>
<tr class="header">
<th/>
<th align="right">Protestant</th>
<th align="right">Catholic</th>
<th align="right">Jewish</th>
<th align="right">None</th>
<th align="right">Other</th>
<th align="right">NA</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Northeast</td>
<td align="right">32</td>
<td align="right">33</td>
<td align="right">6</td>
<td align="right">23</td>
<td align="right">6</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>Midwest</td>
<td align="right">47</td>
<td align="right">25</td>
<td align="right">0</td>
<td align="right">23</td>
<td align="right">5</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td>South</td>
<td align="right">62</td>
<td align="right">15</td>
<td align="right">1</td>
<td align="right">16</td>
<td align="right">5</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td>West</td>
<td align="right">38</td>
<td align="right">25</td>
<td align="right">2</td>
<td align="right">28</td>
<td align="right">8</td>
<td align="right">0</td>
</tr>
</tbody>
</table>

<p>Let’s say we want a plot of the row-marginals for religion within
region. We will take the opportunity to do a little bit of
data-munging in order to get from our underlying table of GSS data to
the summary tabulation that we want to plot. To do this we will use
the tools provided by <code>dplyr</code>, a component of the tidyverse library
that provides functions for manipulating and reshaping tables of data
on the fly. We start from our individual-level <code>gss_sm</code> data frame
with its <code>bigregion</code> and <code>religion</code> variables. Our goal is a summary
table with percentages of religious preferences grouped within region.</p>
<div class="figure fullwidth"><span id="fig:ch-05-dplyr-example"/>
<img src="../Images/c96fe64ed11c6cdbac73f2faf91c0a26.png" alt="How we want to transform the individual-level data." width="100%" data-original-src="https://socviz.co/assets/ch-05-dplyr-pipe-example.png"/>
<p class="caption marginnote shownote">
Figure 5.1: How we want to transform the individual-level data.
</p>
</div>
<p>As shown schematically in Figure <a href="workgeoms.html#fig:ch-05-dplyr-example">5.1</a>, we will
start with our individual-level table of about 2,500 GSS respondents.
Then we want to summarize them into a new table that shows a count of
each religious preference, grouped by region. Finally we will turn
these within-region counts into percentages, where the denominator is
the total number of respondents within each region. The <code>dplyr</code>
library provides a few tools to make this easy and clear to read. We
will use a special operator, <code>%&gt;%</code>, to do our work. This is the <em>pipe</em>
operator. It plays the role of the yellow triangle in Figure <a href="workgeoms.html#fig:ch-05-dplyr-example">5.1</a>, in that it helps us perform the actions that get us from one table to the next.</p>
<p>We have being building our plots in an <em>additive</em> fashion, starting
with a <code>ggplot</code> object and layering on new elements. By analogy,
think of the <code>%&gt;%</code> operator as allowing us to start with a data frame
and perform a <em>sequence</em> or <em>pipeline</em> of operations to turn it into
another, usually smaller and more aggregated table. Data goes in one
side of the pipe, actions are performed via functions, and results
come out the other. A pipeline is typically a series of operations
that do one or more of four things:</p>
<ul>
<li><em>Group</em><label for="tufte-mn-51" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-51" class="margin-toggle"/><span class="marginnote shownote"><code>group_by()</code></span> the data into the nested structure we want for our summary,
such as “Religion by Region” or “Authors by Publications by Year”.</li>
<li><em>Filter</em><label for="tufte-mn-52" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-52" class="margin-toggle"/><span class="marginnote shownote"><code>filter()</code> rows; <code>select()</code> columns</span> or <em>select</em> pieces of the data by row, column, or both.
This gets us the piece of the table we want to work on.</li>
<li><em>Mutate</em><label for="tufte-mn-53" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-53" class="margin-toggle"/><span class="marginnote shownote"><code>mutate()</code></span> the data by creating new variables at the <em>current</em> level of grouping. This adds new columns to the table without aggregating it.</li>
<li><em>Summarize</em><label for="tufte-mn-54" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-54" class="margin-toggle"/><span class="marginnote shownote"><code>summarize()</code></span> or aggregate the grouped data. This creates new variables at a <em>higher</em> level of grouping. For example we might
calculate means with <code>mean()</code> or counts with <code>n()</code>. This results in
a smaller, summary table, which we might do more things on if we
want.</li>
</ul>
<p>We use the <code>dplyr</code> functions <code>group_by()</code>, <code>filter()</code>, <code>select()</code>,
<code>mutate()</code>, and <code>summarize()</code> to carry out these tasks within our
pipeline. They are written in a way that allows them to be easily
piped. That is, they understand how to take inputs from the left side
of a pipe operator and pass results along through the right side of
one. The dplyr documentation has some useful vignettes that introduce
these grouping, filtering, selection, and transformation functions.
There is also a more detailed discussion of these tools, along with
many more examples, in <span class="citation">Wickham &amp; Grolemund (2016)</span>.</p>
<p>We will create a new table called <code>rel_by_region</code>. Here’s the code:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb126-1" data-line-number="1">rel_by_region &lt;-<span class="st"> </span>gss_sm <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb126-2" data-line-number="2"><span class="st">    </span><span class="kw">group_by</span>(bigregion, religion) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb126-3" data-line-number="3"><span class="st">    </span><span class="kw">summarize</span>(<span class="dt">N =</span> <span class="kw">n</span>()) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb126-4" data-line-number="4"><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">freq =</span> N <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(N),</a>
<a class="sourceLine" id="cb126-5" data-line-number="5">           <span class="dt">pct =</span> <span class="kw">round</span>((freq<span class="op">*</span><span class="dv">100</span>), <span class="dv">0</span>))</a></code></pre>
<p>What are these lines doing? First, we are creating an object as usual,
with the familiar assignment operator, <code>&lt;-</code>. Next, at the steps to the
right. Read the objects and functions from left to right, with the
pipe operator “<code>%&gt;%</code>” connecting them together meaning “and then …”. Objects on the left hand side “pass through” the pipe, and whatever
is specified on the right of the pipe gets done to that object. The
resulting object then passes through to the right again, and so on
down to the end of the pipeline.</p>
<p>Reading from the left, the code says this:</p>
<ul>
<li>Create<label for="tufte-mn-55" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-55" class="margin-toggle"/><span class="marginnote shownote"><code>rel_by_region &lt;- gss_sm %&gt;%</code></span> a new object, <code>rel_by_region</code>. It will get the result of the following sequence of actions: Start with the <code>gss_sm</code> data, and then</li>
<li>Group<label for="tufte-mn-56" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-56" class="margin-toggle"/><span class="marginnote shownote"><code>group_by(bigregion, religion) %&gt;%</code></span> the rows by <code>bigregion</code> and, within that, by <code>religion</code>.</li>
<li>Summarize this table<label for="tufte-mn-57" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-57" class="margin-toggle"/><span class="marginnote shownote"><code>summarize(N = n()) %&gt;%</code></span> to create a new, much smaller table, with three columns: <code>bigregion</code>, <code>religion</code>, and a new summary variable, <code>N</code>, that is a count of the number of observations within each religious group for each region.</li>
<li>With this new table,<label for="tufte-mn-58" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-58" class="margin-toggle"/><span class="marginnote shownote"><code> mutate(freq = N / sum(N), pct = round((freq*100), 0))</code></span> use the <code>N</code> variable to calculate two new columns: the relative proportion (<code>freq</code>) and percentage (<code>pct</code>) for each religious category, still grouped by region. Round the results to the nearest percentage point.</li>
</ul>
<p>In this way of doing things, objects passed along the pipeline and the
functions acting on them carry some assumptions about their context.
For one thing, you don’t have to keep specifying the name of the
underlying data frame object you are working from. Everything is
implicitly carried forward from <code>gss_sm</code>. Within the pipeline, the
transient or implicit objects created from your summaries and other
transformations are carried through, too.</p>
<p>Second, the <code>group_by()</code> function sets up how the grouped or nested
data will be processed within the <code>summarize()</code> step. Any function
used to create a new variable within <code>summarize()</code>, such as <code>mean()</code>
or <code>sd()</code> or <code>n()</code>, will be applied to the <em>innermost</em> grouping level
first. Grouping levels are named from left to right within
<code>group_by()</code> from outermost to innermost. So the function call
<code>summarize(N = n())</code> counts up the number of observations for each
value of <code>religion</code> within <code>bigregion</code> and puts them in a new variable
named <code>N</code>. As dplyr’s functions see things, summarizing actions “peel
off” one grouping level at a time, so that the resulting summaries are
at the next level up. In this case, we start with individual-level
observations and group them by religion within region. The
<code>summarize()</code> operation aggregates the individual observations to
counts of the number of people affiliated with each religion, for
each region.</p>
<p>Third, the <code>mutate()</code> step takes the <code>N</code> variable and uses it to
create <code>freq</code>, the relative frequency for each subgroup within region,
and finally <code>pct</code>, the relative frequency turned into a rounded
percentage. These <code>mutate()</code> operations add or remove columns from
tables, but do not change the grouping level.</p>
<p>Inside both <code>mutate()</code> and <code>summarize()</code>, we are able to create new
variables in a way that we have not seen before. Usually, when we see
something like <code>name = value</code> inside a function, the <code>name</code> is a
general, named argument and the function is expecting information from
us about the specific value it should take.<label for="tufte-mn-59" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-59" class="margin-toggle"/><span class="marginnote shownote">As in the
case of <code>aes(x = gdpPercap, y = lifeExp)</code>, for example.</span>
Normally if we give a function a named argument it doesn’t know about
(<code>aes(chuckles = year)</code>) it will ignore it, complain, or break. With
<code>summarize()</code> and <code>mutate()</code>, however, we can invent named arguments.
We are still assigning specific values to <code>N</code>, <code>freq</code>, and <code>pct</code>, but
we pick the names, too. They are the names that the newly-created
variables in the summary table will have. The <code>summarize()</code> and
<code>mutate()</code> functions do not need to know what they will be in advance.</p>
<p>Finally, when we use <code>mutate()</code> to create the <code>freq</code> variable, not
only can we make up that name within the function, <code>mutate()</code> is also
clever enough to let us <em>use</em> that name right away, on the next line
of the same function call, when we create the <code>pct</code> variable. This
means we do not have to repeatedly write separate <code>mutate()</code> calls for
every new variable we want to create.</p>
<p>Our pipeline takes the <code>gss_sm</code> data frame, which has 2867 rows and 32 columns, and transforms it into <code>rel_by_region</code>, a summary table with 24 rows and 5 columns that looks like this, in part:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb127-1" data-line-number="1">rel_by_region</a></code></pre>
<pre><code>## # A tibble: 24 x 5
## # Groups:   bigregion [4]
##    bigregion religion       N    freq   pct
##    &lt;fct&gt;     &lt;fct&gt;      &lt;int&gt;   &lt;dbl&gt; &lt;dbl&gt;
##  1 Northeast Protestant   158 0.324   32.0 
##  2 Northeast Catholic     162 0.332   33.0 
##  3 Northeast Jewish        27 0.0553   6.00
##  4 Northeast None         112 0.230   23.0 
##  5 Northeast Other         28 0.0574   6.00
##  6 Northeast &lt;NA&gt;           1 0.00205  0   
##  7 Midwest   Protestant   325 0.468   47.0 
##  8 Midwest   Catholic     172 0.247   25.0 
##  9 Midwest   Jewish         3 0.00432  0   
## 10 Midwest   None         157 0.226   23.0 
## # ... with 14 more rows</code></pre>
<p>The variables specified in <code>group_by()</code> are retained in the new
summary table; the variables created with <code>summarize()</code> and <code>mutate()</code>
are added, and all the other variables in the original dataset are
dropped.</p>
<p>We said before that, when trying to grasp what each additive step in a
<code>ggplot()</code> sequence does, it can be helpful to work backwards,
removing one piece at a time to see what the plot looks like when that
step is not included. In the same way, when looking at pipelined code
it can be helpful to start from the end of the line, and then remove one
“<code>%&gt;%</code>” step at a time to see what the resulting intermediate object
looks like. For instance, what if we remove the <code>mutate()</code> step from
the code above? What does <code>rel_by_region</code> look like then? What if we
remove the <code>summarize()</code> step? How big is the table returned at each
step? What level of grouping is it at? What variables have been added
or removed?</p>
<p>Plots that do not require sequential aggregation and transformation of
the data before they are displayed are usually easy to write directly
in ggplot, as the details of the layout are handled by a combination
of mapping variables and layering geoms. One-step filtering or
aggregation of the data (such as calculating a proportion, or a
specific subset of observations) is also straightforward. But when the
result we want to display is several steps removed from the data, and
in particular when we want to group or aggregate a table and do some
more calculations on the result before drawing anything, then it can
make sense to use dplyr’s tools to produce these summary tables
first. This is true even if would also be possible to do it within a <code>ggplot()</code>
call. In addition to making our code easier to read, it lets us more
easily perform sanity checks on our results, so that we are sure we
have grouped and summarized things in the right order. For instance,
if we have done things properly with <code>rel_by_region</code>, the <code>pct</code> values
associated with <code>religion</code> should sum to 100 within each region,
perhaps with a bit of rounding error. We can quickly check this using
a very short pipeline, too:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb129-1" data-line-number="1">rel_by_region <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(bigregion) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb129-2" data-line-number="2"><span class="st">    </span><span class="kw">summarize</span>(<span class="dt">total =</span> <span class="kw">sum</span>(pct))</a></code></pre>
<pre><code>## # A tibble: 4 x 2
##   bigregion total
##   &lt;fct&gt;     &lt;dbl&gt;
## 1 Northeast   100
## 2 Midwest     101
## 3 South       100
## 4 West        101</code></pre>
<p>This looks good. As before, now that we are working directly with
percentage values in a summary table, we can use <code>geom_col()</code> instead
of <code>geom_bar()</code>.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-relbyregion-01"/>
<img src="../Images/215092b752bc49a696e9556855685408.png" alt="Religious preferences by Region." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-relbyregion-01-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.2: Religious preferences by Region.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb131-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(rel_by_region, <span class="kw">aes</span>(<span class="dt">x =</span> bigregion, <span class="dt">y =</span> pct, <span class="dt">fill =</span> religion))</a>
<a class="sourceLine" id="cb131-2" data-line-number="2">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_col</span>(<span class="dt">position =</span> <span class="st">"dodge2"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb131-3" data-line-number="3"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">"Region"</span>,<span class="dt">y =</span> <span class="st">"Percent"</span>, <span class="dt">fill =</span> <span class="st">"Religion"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb131-4" data-line-number="4"><span class="st">    </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">"top"</span>)</a></code></pre>
<p>We use a different <code>position</code> argument here, <code>dodge2</code> instead of
<code>dodge</code>. This puts the bars side by side. When dealing with
pre-computed values in <code>geom_col()</code>, the default <code>position</code> is to make
a proportionally stacked column chart. If you use <code>dodge</code> they will be
stacked within columns but the result will read incorrectly. Using
<code>dodge2</code> puts the sub-categories (religious affiliations) side-by-side
within groups (regions).</p>
<p>The values in this bar chart are the percentage equivalents to the
stacked counts in Figure <a href="groupfacettx.html#fig:ch-04-gss-06">4.10</a>. Religious
affiliations sum to 100 percent within region. The trouble is,
although we now know how to cleanly produce frequency tables, this is
still a bad figure. It is too crowded, with too many bars
side-by-side. We can do better.</p>
<p>As a rule, dodged charts can be more cleanly expressed as faceted
plots. This removes the need for a legend, and thus makes the chart
simpler to read. We also introduce a new function. If we map religion
to the x-axis, the labels will overlap and become illegible. It’s
possible to manually adjust the tick mark labels so that they are
printed at an angle, but that isn’t so easy to read, either. It makes
more sense to put the religions on the y-axis and the percent scores
on the x-axis. Because of the way <code>geom_bar()</code> works internally,
simply swapping the <code>x</code> and <code>y</code> mapping will not work. (Try it and see
what happens.) What we do instead is to transform the <em>coordinate
system</em> that the results are plotted in, so that the x and y axes are
flipped. We do this with <code>coord_flip()</code>.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb132-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(rel_by_region, <span class="kw">aes</span>(<span class="dt">x =</span> religion, <span class="dt">y =</span> pct, <span class="dt">fill =</span> religion))</a>
<a class="sourceLine" id="cb132-2" data-line-number="2">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_col</span>(<span class="dt">position =</span> <span class="st">"dodge2"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb132-3" data-line-number="3"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="ot">NULL</span>, <span class="dt">y =</span> <span class="st">"Percent"</span>, <span class="dt">fill =</span> <span class="st">"Religion"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb132-4" data-line-number="4"><span class="st">    </span><span class="kw">guides</span>(<span class="dt">fill =</span> <span class="ot">FALSE</span>) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb132-5" data-line-number="5"><span class="st">    </span><span class="kw">coord_flip</span>() <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb132-6" data-line-number="6"><span class="st">    </span><span class="kw">facet_grid</span>(<span class="op">~</span><span class="st"> </span>bigregion)</a></code></pre>
<div class="figure fullwidth"><span id="fig:ch-05-relbyregion-02"/>
<img src="../Images/004dec05a264c8e45176131cd621f9b9.png" alt="Religious preferences by Region, faceted version." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-relbyregion-02-1.png"/>
<p class="caption marginnote shownote">
Figure 5.3: Religious preferences by Region, faceted version.
</p>
</div>
<p>For most plots the coordinate system is cartesian, showing plots on a plane defined by an x-axis and a y-axis. The <code>coord_cartesian()</code> function manages this, but we don’t need to call it. The <code>coord_flip()</code> function switches the x and y axes after the plot is made. It does not remap variables to aesthetics. In this case, <code>religion</code> is still mapped to <code>x</code> and <code>pct</code> to <code>y</code>. Because the religion names do not need an axis label to be understood, we set <code>x = NULL</code> in the <code>labs()</code> call.</p>
<p>We will see more of what dplyr’s grouping and filtering operations can
do later. It is a flexible and powerful framework. For now, think of
it as a way to quickly summarize tables of data without having to
write code in the body of our <code>ggplot()</code> or <code>geom_</code> functions.</p>
&#13;

<h2><span class="header-section-number">5.2</span> Continuous variables by group or category</h2>
<p>Let’s move to a new dataset, the <code>organdata</code> table. Like <code>gapminder</code>, it has a
country-year structure. It contains a little more than a decade’s
worth of information on the donation of organs for transplants in seventeen OECD
countries. The organ procurement rate is a measure of the number of human organs obtained from cadaver organ donors for use in transplant operations. Along with
this donation data, the dataset has a variety of numerical demographic
measures, and several categorical measures of health and welfare
policy and law. Unlike the <code>gapminder</code> data, some observations are
missing. These are designated with a value of <code>NA</code>, R’s standard code
for missing data. The <code>organdata</code> table is included in the <code>socviz</code>
library. Load it up and take a quick look. Instead of using <code>head()</code>,
for variety this time we will make a short pipeline to select the first six columns of
the dataset, and then pick five rows at random using a function called
<code>sample_n()</code>. This function takes two main arguments. First we provide the table of data we want
to sample from. Because we are using a pipeline, this is implicitly passed down from the beginning of the pipe. Then we supply the number of draws we want to make.<label for="tufte-mn-60" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-60" class="margin-toggle"/><span class="marginnote shownote">Using numbers this way in <code>select()</code> chooses the numbered columns of the data frame. You can also select variable names directly.</span></p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb133-1" data-line-number="1">organdata <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">sample_n</span>(<span class="dt">size =</span> <span class="dv">10</span>)</a></code></pre>
<pre><code>## # A tibble: 10 x 6
##    country        year       donors   pop pop_dens   gdp
##    &lt;chr&gt;          &lt;date&gt;      &lt;dbl&gt; &lt;int&gt;    &lt;dbl&gt; &lt;int&gt;
##  1 Switzerland    NA           NA      NA    NA       NA
##  2 Switzerland    1997-01-01   14.3  7089    17.2  27675
##  3 United Kingdom 1997-01-01   13.4 58283    24.0  22442
##  4 Sweden         NA           NA    8559     1.90 18660
##  5 Ireland        2002-01-01   21.0  3932     5.60 32571
##  6 Germany        1998-01-01   13.4 82047    23.0  23283
##  7 Italy          NA           NA   56719    18.8  17430
##  8 Italy          2001-01-01   17.1 57894    19.2  25359
##  9 France         1998-01-01   16.5 58398    10.6  24044
## 10 Spain          1995-01-01   27.0 39223     7.75 15720</code></pre>
<p>Lets’s start by naively graphing some of the data. We can take a look at
a scatterplot of donors vs year.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-organdata-01"/>
<img src="../Images/8a6a1259ee0fd826e0f9513be05f79d3.png" alt="Not very informative." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-organdata-01-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.4: Not very informative.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb135-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb135-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> year, <span class="dt">y =</span> donors))</a>
<a class="sourceLine" id="cb135-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>()</a></code></pre>
<pre><code>## Warning: Removed 34 rows containing missing values
## (geom_point).</code></pre>
<p>A message from ggplot warns you about the missing values. We’ll suppress this warning
from now on, so that it doesn’t clutter the output, but in general
it’s wise to read and understand the warnings that R gives, even when
code appears to run properly. If there are a large number of warnings,
R will collect them all and invite you to view them with the
<code>warnings()</code> function.</p>
<p>We could use <code>geom_line()</code> to plot each country’s time series, like we did with the gapminder data. To do that, remember, we need to tell ggplot what the grouping variable is. This time we can also facet the figure by country, as we do not have too many of them.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-organdata-02"/>
<img src="../Images/2b99e6558ebdda27d7c48cbb953eb8fa.png" alt="A faceted line plot." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-organdata-02-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.5: A faceted line plot.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb137-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb137-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> year, <span class="dt">y =</span> donors))</a>
<a class="sourceLine" id="cb137-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">group =</span> country)) <span class="op">+</span><span class="st"> </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>country)</a></code></pre>
<p>By default the facets are ordered alphabetically by country. We will see how to change this momentarily.</p>
<p>Let’s focus on the country-level variation, but without paying
attention to the time trend. We can use <code>geom_boxplot()</code> to get a
picture of variation by year across countries. Just as <code>geom_bar()</code> by
default calculates a count of observations by the category you map to
<code>x</code>, the <code>stat_boxplot()</code> function that works with <code>geom_boxplot()</code>
will calculate a number of statistics that allow the box and whiskers
to be drawn. We tell <code>geom_boxplot()</code> the variable we want to
categorize by (here, <code>country</code>) and the continuous variable we want
summarized (here, <code>donors</code>)</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-organdata-03"/>
<img src="../Images/e451458bc9c750df1e711b18dbf06767.png" alt="A first attempt at boxplots by country." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-organdata-03-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.6: A first attempt at boxplots by country.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb138-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb138-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> country, <span class="dt">y =</span> donors))</a>
<a class="sourceLine" id="cb138-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_boxplot</span>()</a></code></pre>
<p>The boxplots look interesting but two issues could be addressed. First, as we saw in the previous chapter, it is awkward to have the country names on the x-axis because the labels will overlap. We use <code>coord_flip()</code> again to switch the axes (but not the mappings).</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-organdata-04"/>
<img src="../Images/3b584e8c67dab2c11385972d18069b5f.png" alt="Moving the countries to the y-axis." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-organdata-04-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.7: Moving the countries to the y-axis.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb139-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb139-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> country, <span class="dt">y =</span> donors))</a>
<a class="sourceLine" id="cb139-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_boxplot</span>() <span class="op">+</span><span class="st"> </span><span class="kw">coord_flip</span>()</a></code></pre>
<p>That’s more legible but still not ideal. We generally want our plots to present data in some meaningful order. An obvious way is to have the countries listed from high to low average donation rate. We accomplish this by reordering the <code>country</code> variable by the mean of <code>donors.</code> The <code>reorder()</code> function will do this for us. It takes two required arguments. The first is the categorical variable or factor that we want to reorder. In this case, that’s <code>country</code>. The second is the variable we want to reorder it by. Here that is the donation rate, <code>donors</code>. The third and optional argument to <code>reorder()</code> is the function you want to use as a summary statistic. If you only give <code>reorder()</code> the first two required arguments, then by default it will reorder the categories of your first variable by the mean value of the second. You can name any sensible function you like to reorder the categorical variable (e.g., <code>median</code>, or <code>sd</code>). There is one additional wrinkle. In R, the default <code>mean</code> function will fail with an error if there are missing values in the variable you are trying to take the average of. You must say that it is OK to remove the missing values when calculating the mean. This is done by supplying the <code>na.rm=TRUE</code> argument to <code>reorder()</code>, which internally passes that argument on to <code>mean()</code>. We are reordering the variable we are mapping to the <code>x</code> aesthetic, so we use <code>reorder()</code> at that point in our code:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb140-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb140-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">reorder</span>(country, donors, <span class="dt">na.rm=</span><span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb140-3" data-line-number="3">                          <span class="dt">y =</span> donors))</a>
<a class="sourceLine" id="cb140-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_boxplot</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb140-5" data-line-number="5"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x=</span><span class="ot">NULL</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb140-6" data-line-number="6"><span class="st">    </span><span class="kw">coord_flip</span>()</a></code></pre>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-organdata-05"/>
<img src="../Images/303d95e0edeba02ff11d09e70bc320f9.png" alt="Boxplots reordered by mean donation rate." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-organdata-05-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.8: Boxplots reordered by mean donation rate.<!--</p>-->
<!--</div>--></span>
</p>
<p>Because it’s obvious what the country names are, in the <code>labs()</code> call we set their axis label to empty with <code>labs(x=NULL)</code>. Ggplot offers some variants on the basic boxplot, including the violin plot. Try it with <code>geom_violin()</code>. There are also numerous arguments that control the finer details of the boxes and whiskers, including their width. Boxplots can also take <code>color</code> and <code>fill</code> aesthetic mappings like other geoms.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb141-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb141-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">reorder</span>(country, donors, <span class="dt">na.rm=</span><span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb141-3" data-line-number="3">                          <span class="dt">y =</span> donors, <span class="dt">fill =</span> world))</a>
<a class="sourceLine" id="cb141-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_boxplot</span>() <span class="op">+</span><span class="st"> </span><span class="kw">labs</span>(<span class="dt">x=</span><span class="ot">NULL</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb141-5" data-line-number="5"><span class="st">    </span><span class="kw">coord_flip</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">"top"</span>)</a></code></pre>
<div class="figure"><span id="fig:ch-05-organdata-06"/>
<p class="caption marginnote shownote">
Figure 5.9: A boxplot with the fill aesthetic mapped.
</p>
<img src="../Images/0ec40145582f9a93b39249c1a11f8e55.png" alt="A boxplot with the fill aesthetic mapped." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-organdata-06-1.png"/>
</div>
<p>Putting categorical variables on the y-axis to compare their distributions is a very useful trick. Its makes it easy to effectively present summary data on more categories. The plots can be quite compact and fit a relatively large number of cases in by row. The approach also has the advantage of putting the variable being compared onto the x-axis, which sometimes makes it easier to compare across categories. If the number of observations within each categoriy is relatively small, we can skip (or supplement) the boxplots and show the individual observations, too. In this next example we map the <code>world</code> variable to <code>color</code> instead of <code>fill</code> as the default <code>geom_point()</code> plot shape has a color attribute, but not a fill.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-organdata-07"/>
<img src="../Images/ee3d7de1c71b47df463cd41a77952b9e.png" alt="Using points instead of a boxplot." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-organdata-07-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.10: Using points instead of a boxplot.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb142-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb142-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">reorder</span>(country, donors, <span class="dt">na.rm=</span><span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb142-3" data-line-number="3">                          <span class="dt">y =</span> donors, <span class="dt">color =</span> world))</a>
<a class="sourceLine" id="cb142-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">labs</span>(<span class="dt">x=</span><span class="ot">NULL</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb142-5" data-line-number="5"><span class="st">    </span><span class="kw">coord_flip</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">"top"</span>)</a></code></pre>
<p>When we use <code>geom_point()</code> like this, there is some overplotting of observations. In these cases, it can be useful to perturb the data just a little bit in order to get a better sense of how many observations there are at different values. We use <code>geom_jitter()</code> to do this. This geom works much like <code>geom_point()</code>, but randomly nudges each observation by a small amount.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-organdata-08"/>
<img src="../Images/bc484a1d7342a9dabffc983284087891.png" alt="Jittering the points." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-organdata-08-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.11: Jittering the points.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb143-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb143-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">reorder</span>(country, donors, <span class="dt">na.rm=</span><span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb143-3" data-line-number="3">                          <span class="dt">y =</span> donors, <span class="dt">color =</span> world))</a>
<a class="sourceLine" id="cb143-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_jitter</span>() <span class="op">+</span><span class="st"> </span><span class="kw">labs</span>(<span class="dt">x=</span><span class="ot">NULL</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb143-5" data-line-number="5"><span class="st">    </span><span class="kw">coord_flip</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">"top"</span>)</a></code></pre>
<p>The default amount of jitter is a little too much for our purposes. We can control it using <code>height</code> and <code>width</code> arguments to a <code>position_jitter()</code> function within the geom. Because we’re making a one-dimensional summary here, we just need <code>width</code>.<label for="tufte-mn-61" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-61" class="margin-toggle"/><span class="marginnote shownote">Can you see why we did not use height? If not, try it and see what happens.</span></p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb144-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb144-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">reorder</span>(country, donors, <span class="dt">na.rm=</span><span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb144-3" data-line-number="3">                          <span class="dt">y =</span> donors, <span class="dt">color =</span> world))</a>
<a class="sourceLine" id="cb144-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_jitter</span>(<span class="dt">position =</span> <span class="kw">position_jitter</span>(<span class="dt">width=</span><span class="fl">0.15</span>)) <span class="op">+</span></a>
<a class="sourceLine" id="cb144-5" data-line-number="5"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x=</span><span class="ot">NULL</span>) <span class="op">+</span><span class="st"> </span><span class="kw">coord_flip</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">"top"</span>)</a></code></pre>
<div class="figure"><span id="fig:ch-05-organdata-09"/>
<p class="caption marginnote shownote">
Figure 5.12: A jittered plot.
</p>
<img src="../Images/3962f4a2a83430505c2d11a495b5584b.png" alt="A jittered plot." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-organdata-09-1.png"/>
</div>
<p>When we want to summarize a categorical variable that just has one
point per category, we should use this approach as well. The result
will be a Cleveland dotplot, a simple and extremely effective method
of presenting data that is usually better than either a bar chart or a
table. For example, we can make a Cleveland dotplot of the average
donation rate.</p>
<p>This also gives us another opportunity to do a little bit of data
munging with a dplyr pipeline. We will use one to aggregate our larger
country-year data frame to a smaller table of summary statistics by
country. There is more than one way to do pipeline this task. We could
choose the variables we want to summarize and then repeatedly use the
<code>mean()</code> and <code>sd()</code> functions to calculate the means and standard
deviations of the variables we want. We will again use the pipe
operator, <code>%&gt;%</code>, to do our work:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb145-1" data-line-number="1">by_country &lt;-<span class="st"> </span>organdata <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(consent_law, country) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb145-2" data-line-number="2"><span class="st">    </span><span class="kw">summarize</span>(<span class="dt">donors_mean=</span> <span class="kw">mean</span>(donors, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb145-3" data-line-number="3">              <span class="dt">donors_sd =</span> <span class="kw">sd</span>(donors, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb145-4" data-line-number="4">              <span class="dt">gdp_mean =</span> <span class="kw">mean</span>(gdp, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb145-5" data-line-number="5">              <span class="dt">health_mean =</span> <span class="kw">mean</span>(health, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb145-6" data-line-number="6">              <span class="dt">roads_mean =</span> <span class="kw">mean</span>(roads, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb145-7" data-line-number="7">              <span class="dt">cerebvas_mean =</span> <span class="kw">mean</span>(cerebvas, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))</a></code></pre>
<p>The pipeline consists of two steps. First we group the data by <code>consent_law</code> and <code>country</code>, and then use <code>summarize()</code> to create six new variables, each one of which is the mean or standard deviation of each country’s score on a corresponding variable in the original <code>organdata</code> data frame.<label for="tufte-mn-62" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-62" class="margin-toggle"/><span class="marginnote shownote">For an alternative view, change <code>country</code> to <code>year</code> in the grouping statement and see what happens.</span></p>
<p>As usual, <code>summarize()</code> step, will inherit information about the
original data and the grouping, and then do its calculations at the
innermost grouping level. In this case it takes all the observations
for each country and calculates the mean or standard deviation as
requested. Here is what the resulting object looks like:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb146-1" data-line-number="1">by_country</a></code></pre>
<pre><code>## # A tibble: 17 x 8
## # Groups:   consent_law [?]
##    consent_law country        donors_mean donors_sd gdp_mean health_mean roads_mean cerebvas_mean
##    &lt;chr&gt;       &lt;chr&gt;                &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;      &lt;dbl&gt;         &lt;dbl&gt;
##  1 Informed    Australia             10.6     1.14     22179        1958      105             558
##  2 Informed    Canada                14.0     0.751    23711        2272      109             422
##  3 Informed    Denmark               13.1     1.47     23722        2054      102             641
##  4 Informed    Germany               13.0     0.611    22163        2349      113             707
##  5 Informed    Ireland               19.8     2.48     20824        1480      118             705
##  6 Informed    Netherlands           13.7     1.55     23013        1993       76.1           585
##  7 Informed    United Kingdom        13.5     0.775    21359        1561       67.9           708
##  8 Informed    United States         20.0     1.33     29212        3988      155             444
##  9 Presumed    Austria               23.5     2.42     23876        1875      150             769
## 10 Presumed    Belgium               21.9     1.94     22500        1958      155             594
## 11 Presumed    Finland               18.4     1.53     21019        1615       93.6           771
## 12 Presumed    France                16.8     1.60     22603        2160      156             433
## 13 Presumed    Italy                 11.1     4.28     21554        1757      122             712
## 14 Presumed    Norway                15.4     1.11     26448        2217       70.0           662
## 15 Presumed    Spain                 28.1     4.96     16933        1289      161             655
## 16 Presumed    Sweden                13.1     1.75     22415        1951       72.3           595
## 17 Presumed    Switzerland           14.2     1.71     27233        2776       96.4           424</code></pre>
<p>As before, the variables specified in <code>group_by()</code> are retained in the
new data frame, the variables created with <code>summarize()</code> are added,
and all the other variables in the original data are dropped. The
countries are also summarized alphabetically within <code>consent_law</code>,
which was the outermost grouping variable in the <code>group_by()</code>
statement at the start of the pipeline.</p>
<p>Using our pipeline this way is reasonable, but the code is worth looking at again. For one thing, we have to repeatedly type out the names of the <code>mean()</code> and <code>sd()</code> functions and give each of them the name of the variable we want summarized <em>and</em> the <code>na.rm = TRUE</code> argument each time to make sure the functions don’t complain about missing values. We also repeatedly name our new summary variables in the same way, by adding <code>_mean</code> or <code>_sd</code> to the end of the original variable name. If we wanted to calculate the mean and standard deviation for all the numerical variables in <code>organdata</code>, our code would get even longer. Plus, in this version we lose the other, time-invariant categorical variables that we haven’t grouped by, such as <code>world</code>. When we see repeated actions like this in our code, we can ask whether there’s a better way to proceed.</p>
<p>There is. What we would like to do is apply the <code>mean()</code> and <code>sd()</code> functions to every numerical variable in <code>organdata</code>, but <em>only</em> the numerical ones. Then we want to name the results in a consistent way, and return a summary table including all the categorical variables like <code>world</code>. We can create a better version of the <code>by_country</code> object using a little bit of R’s functional programming abilities. Here is the code:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb148-1" data-line-number="1">by_country &lt;-<span class="st"> </span>organdata <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(consent_law, country) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb148-2" data-line-number="2"><span class="st">    </span><span class="kw">summarize_if</span>(is.numeric, <span class="kw">funs</span>(mean, sd), <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb148-3" data-line-number="3"><span class="st">    </span><span class="kw">ungroup</span>()</a></code></pre>
<p>The pipeline starts off just as before, taking <code>organdata</code> and then grouping it by <code>consent_law</code> and <code>country</code>. In the next step, though, instead of manually taking the mean and standard deviation of a subset of variables, we use the <code>summarize_if()</code> function instead. As its name suggests, it examines each column in our data and applies a test to it. It only summarizes if the test is passed, that is, if it returns a value of <code>TRUE</code>.<label for="tufte-mn-63" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-63" class="margin-toggle"/><span class="marginnote shownote">We do not have to use parentheses when naming the functions inside <code>summarize_if()</code>.</span> Here the test is the function <code>is.numeric()</code>, which looks to see if a vector is a numeric value or not. If it is, then <code>summarize_if()</code> will apply the summary function or functions we want to <code>organdata</code>. Because we are taking both the mean and the standard deviation, we use <code>funs()</code> to list the functions we want to use. And we finish with the <code>na.rm = TRUE</code> argument, which will be passed on to each use of both <code>mean()</code> and <code>sd()</code>. In the last step in the pipeline we <code>ungroup()</code> the data<label for="tufte-mn-64" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-64" class="margin-toggle"/><span class="marginnote shownote">Sometimes graphing functions can get confused by grouped tibbles where we don’t explicitly use the groups in the plot.</span>, so that the result is a plain tibble.</p>
<p>Here is what the pipeline returns:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb149-1" data-line-number="1">by_country    </a></code></pre>
<pre><code>## # A tibble: 17 x 28
##    consent_law country        donors_mean pop_mean pop_dens_mean gdp_mean gdp_lag_mean health_mean
##    &lt;chr&gt;       &lt;chr&gt;                &lt;dbl&gt;    &lt;dbl&gt;         &lt;dbl&gt;    &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;
##  1 Informed    Australia             10.6    18318         0.237    22179        21779        1958
##  2 Informed    Canada                14.0    29608         0.297    23711        23353        2272
##  3 Informed    Denmark               13.1     5257        12.2      23722        23275        2054
##  4 Informed    Germany               13.0    80255        22.5      22163        21938        2349
##  5 Informed    Ireland               19.8     3674         5.23     20824        20154        1480
##  6 Informed    Netherlands           13.7    15548        37.4      23013        22554        1993
##  7 Informed    United Kingdom        13.5    58187        24.0      21359        20962        1561
##  8 Informed    United States         20.0   269330         2.80     29212        28699        3988
##  9 Presumed    Austria               23.5     7927         9.45     23876        23415        1875
## 10 Presumed    Belgium               21.9    10153        30.7      22500        22096        1958
## 11 Presumed    Finland               18.4     5112         1.51     21019        20763        1615
## 12 Presumed    France                16.8    58056        10.5      22603        22211        2160
## 13 Presumed    Italy                 11.1    57360        19.0      21554        21195        1757
## 14 Presumed    Norway                15.4     4386         1.35     26448        25769        2217
## 15 Presumed    Spain                 28.1    39666         7.84     16933        16584        1289
## 16 Presumed    Sweden                13.1     8789         1.95     22415        22094        1951
## 17 Presumed    Switzerland           14.2     7037        17.0      27233        26931        2776
## # ... with 20 more variables: health_lag_mean &lt;dbl&gt;, pubhealth_mean &lt;dbl&gt;, roads_mean &lt;dbl&gt;,
## #   cerebvas_mean &lt;dbl&gt;, assault_mean &lt;dbl&gt;, external_mean &lt;dbl&gt;, txp_pop_mean &lt;dbl&gt;,
## #   donors_sd &lt;dbl&gt;, pop_sd &lt;dbl&gt;, pop_dens_sd &lt;dbl&gt;, gdp_sd &lt;dbl&gt;, gdp_lag_sd &lt;dbl&gt;,
## #   health_sd &lt;dbl&gt;, health_lag_sd &lt;dbl&gt;, pubhealth_sd &lt;dbl&gt;, roads_sd &lt;dbl&gt;, cerebvas_sd &lt;dbl&gt;,
## #   assault_sd &lt;dbl&gt;, external_sd &lt;dbl&gt;, txp_pop_sd &lt;dbl&gt;</code></pre>
<p>All the numeric variables have been summarized. They are named using
the original variable, with the function’s name appended:
<code>donors_mean</code> and <code>donors_sd</code>, and so on. This is a compact way to rapidly transform our data in various ways. There is a family of <code>summarize_</code> functions for various tasks, and a complementary group of <code>mutate_</code> functions for when we want to add columns to the data rather than aggregated it.</p>
<p>With our data summarized by country, we can draw a dotplot with
<code>geom_point()</code>. Let’s also color the results by the consent law for
each country.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-bycountry-01"/>
<img src="../Images/54fe19bef527864af0679a092193b9cc.png" alt="A Cleveland dotplot, with colored points." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-bycountry-01-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.13: A Cleveland dotplot, with colored points.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb151-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> by_country,</a>
<a class="sourceLine" id="cb151-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> donors_mean, <span class="dt">y =</span> <span class="kw">reorder</span>(country, donors_mean),</a>
<a class="sourceLine" id="cb151-3" data-line-number="3">                          <span class="dt">color =</span> consent_law))</a>
<a class="sourceLine" id="cb151-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>(<span class="dt">size=</span><span class="dv">3</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb151-5" data-line-number="5"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">"Donor Procurement Rate"</span>,</a>
<a class="sourceLine" id="cb151-6" data-line-number="6">         <span class="dt">y =</span> <span class="st">""</span>, <span class="dt">color =</span> <span class="st">"Consent Law"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb151-7" data-line-number="7"><span class="st">    </span><span class="kw">theme</span>(<span class="dt">legend.position=</span><span class="st">"top"</span>)</a></code></pre>
<p>Alternatively, if we liked, we could use a facet instead of coloring
the points. Using <code>facet_wrap()</code> we can split the <code>consent_law</code>
variable into two panels, and then rank the countries by donation rate
within each panel. Because we have a categorical variable on our
y-axis, there are two wrinkles worth noting. First, if we leave
<code>facet_wrap()</code> to its defaults, the panels will be plotted side by
side. This will make it difficult to compare the two groups on the
same scale. Instead the plot will be read left to right, which is not
useful. To avoid this, we will have the panels appear one on top of
the other by saying we only want toq have one column. This is the
<code>ncol=1</code> argument. Second, and again because we have a categorical
variable on the y-axis, the default facet plot will have the names of
every country appear on the y-axis of <em>both</em> panels. (Were the y-axis a
continuous variable this would be the what we would want.) In that
case, only half the rows in each panel of our plot will have points in
them.</p>
<p>To avoid this we allow the y-axes scale to be free. This is the
<code>scales="free_y"</code> argument. Again, for faceted plots where both
variables are continuous, we generally do not want the scales to be
free, because it allows the x- or y-axis for each panel to vary with
the range of the data inside that panel only, instead of the range
across the whole dataset. Ordinarily, the point of small-multiple
facets is to be able to compare across the panels. This means free
scales are usually not a good idea, because each panel gets its own x-
or y-axis range, which breaks comparability. But where one axis is
categorical, as here, we can free the categorical axis and leave the
continuous one fixed. The result is that each panel shares the same
x-axis, and it is easy to compare between them.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-bycountry-02"/>
<img src="../Images/f23ad812ec7dc45c1eb758591a5bc983.png" alt="A faceted dotplot with free scales on the y-axis." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-bycountry-02-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.14: A faceted dotplot with free scales on the y-axis.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb152-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> by_country,</a>
<a class="sourceLine" id="cb152-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> donors_mean,</a>
<a class="sourceLine" id="cb152-3" data-line-number="3">                          <span class="dt">y =</span> <span class="kw">reorder</span>(country, donors_mean)))</a>
<a class="sourceLine" id="cb152-4" data-line-number="4"/>
<a class="sourceLine" id="cb152-5" data-line-number="5">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>(<span class="dt">size=</span><span class="dv">3</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb152-6" data-line-number="6"><span class="st">    </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>consent_law, <span class="dt">scales =</span> <span class="st">"free_y"</span>, <span class="dt">ncol =</span> <span class="dv">1</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb152-7" data-line-number="7"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x=</span> <span class="st">"Donor Procurement Rate"</span>,</a>
<a class="sourceLine" id="cb152-8" data-line-number="8">         <span class="dt">y=</span> <span class="st">""</span>) </a></code></pre>
<p>Cleveland dotplots are generally preferred to bar or column charts.
When making them, put the categories on the y-axis and order them in
the way that is most relevant to the numerical summary you are
providing. This sort of plot is also an excellent way to summarize
model results or any data with with error ranges. We use
<code>geom_point()</code> to draw our dotplots. There is a geom called
<code>geom_dotplot()</code>, but it is designed to produce a different sort of
figure. It is a kind of histogram, with individual observations represented
by dots that are then stacked on top of one another to show how many
of them there are.</p>
<p>The Cleveland-style dotplot can be extended to cases where we want to
include some information about variance or error in the plot. Using
<code>geom_pointrange()</code>, we can tell ggplot to show us a point estimate
and a range around it. Here we will use the standard deviation of the
donation rate that we calculated above. But this is also the natural
way to present, for example, estimates of model coefficients with
confidence intervals. With <code>geom_pointrange()</code> we map our <code>x</code> and <code>y</code>
variables as usual, but the function needs a little more information
than <code>geom_point</code>. It needs to know the range of the line to draw on
either side of the point, defined by the arguments <code>ymax</code> and <code>ymin</code>.
This is given by the y value (<code>donors_mean</code>) plus or minus its standard
deviation (<code>donors_sd</code>). If a function argument expects a number, it is
OK to give it a mathematical expression that resolves to the number
you want. R will calculate the result for you.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb153-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> by_country, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">reorder</span>(country,</a>
<a class="sourceLine" id="cb153-2" data-line-number="2">              donors_mean), <span class="dt">y =</span> donors_mean))</a>
<a class="sourceLine" id="cb153-3" data-line-number="3"/>
<a class="sourceLine" id="cb153-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_pointrange</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">ymin =</span> donors_mean <span class="op">-</span><span class="st"> </span>donors_sd,</a>
<a class="sourceLine" id="cb153-5" data-line-number="5">       <span class="dt">ymax =</span> donors_mean <span class="op">+</span><span class="st"> </span>donors_sd)) <span class="op">+</span></a>
<a class="sourceLine" id="cb153-6" data-line-number="6"><span class="st">     </span><span class="kw">labs</span>(<span class="dt">x=</span> <span class="st">""</span>, <span class="dt">y=</span> <span class="st">"Donor Procurement Rate"</span>) <span class="op">+</span><span class="st"> </span><span class="kw">coord_flip</span>()</a></code></pre>
<div class="figure"><span id="fig:ch-05-bycountry-03"/>
<p class="caption marginnote shownote">
Figure 5.15: A dot-and-whisker plot, with the range defined by the standard deviation of the measured variable.
</p>
<img src="../Images/952e4fd0cb72b9c57a8b9aa4a0a54573.png" alt="A dot-and-whisker plot, with the range defined by the standard deviation of the measured variable." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-bycountry-03-1.png"/>
</div>
<p>Because <code>geom_pointrange()</code> expects <code>y</code>, <code>ymin</code>, and <code>ymax</code> as arguments, we map <code>donors_mean</code> to <code>y</code> and the <code>ccode</code> variable to <code>x</code>, then flip the axes at the end with <code>coord_flip()</code>.</p>
&#13;

<h2><span class="header-section-number">5.3</span> Plot text directly</h2>
<p>It can sometimes be useful to plot the labels along with the points in a scatterplot, or just plot informative labels directly. We can do this with <code>geom_text()</code>.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-bycountry-04"/>
<img src="../Images/98e62e9b42d105ddde8909e3548704e4.png" alt="Plotting labels and text." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-bycountry-04-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.16: Plotting labels and text.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb154-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> by_country,</a>
<a class="sourceLine" id="cb154-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> roads_mean, <span class="dt">y =</span> donors_mean))</a>
<a class="sourceLine" id="cb154-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_text</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">label =</span> country))</a></code></pre>
<p>The text is plotted right on top of the points, because both are positioned using the same x and y mapping. One way of dealing with this, often the most effective if we are not too worried about excessive precision in the graph, is to remove the points by dropping <code>geom_point()</code> from the plot. A second option is to adjust the position of the text. We can left- or right-justify the labels using the <code>hjust</code> argument to <code>geom_text()</code>. Setting <code>hjust=0</code> will left justify the label, and <code>hjust=1</code> will right justify it.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb155-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> by_country,</a>
<a class="sourceLine" id="cb155-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> roads_mean, <span class="dt">y =</span> donors_mean))</a>
<a class="sourceLine" id="cb155-3" data-line-number="3"/>
<a class="sourceLine" id="cb155-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_text</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">label =</span> country), <span class="dt">hjust =</span> <span class="dv">0</span>)</a></code></pre>
<p>You might be tempted to try different values to <code>hjust</code> to fine-tune your labels. But this is not a robust approach. It will often fail because the space is added in proportion to the length of the label. The result is that longer labels move further away from their points than you want. There are ways around this, but they introduce other problems.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-bycountry-05"/>
<img src="../Images/13eb6a51f767063ac5af3c89c8c60bea.png" alt="Plot points and text labels, with a horizontal position adjustment." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-bycountry-05-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.17: Plot points and text labels, with a horizontal position adjustment.<!--</p>-->
<!--</div>--></span>
</p>
<p>Instead of wrestling any further with <code>geom_text()</code>, we will use <code>ggrepel</code> instead. This very useful library adds some new geoms to ggplot. Just as <code>ggplot</code> extends the plotting capabilities of R, there are many small libraries that extend the capabilities of <code>ggplot</code>, often by providing some new type of <code>geom</code>. The <code>ggrepel</code> library provides <code>geom_text_repel()</code> and <code>geom_label_repel()</code>, two geoms that can pick out labels much more flexibly than the default <code>geom_text()</code>. First, make sure the library is installed, then load it in the usual way:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb156-1" data-line-number="1"><span class="kw">library</span>(ggrepel)</a></code></pre>
<p>We will use <code>geom_text_repel()</code> instead of <code>geom_text()</code>. To demonstrate some of what <code>geom_text_repel()</code> can do, we will switch datasets and work with some historical U.S. presidential election data provided in the <code>socviz</code> library.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb157-1" data-line-number="1">elections_historic <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(<span class="dv">2</span><span class="op">:</span><span class="dv">7</span>) </a></code></pre>
<pre><code>## # A tibble: 49 x 6
##     year winner                 win_party ec_pct popular_pct popular_margin
##    &lt;int&gt; &lt;chr&gt;                  &lt;chr&gt;      &lt;dbl&gt;       &lt;dbl&gt;          &lt;dbl&gt;
##  1  1824 John Quincy Adams      D.-R.      0.322       0.309        -0.104 
##  2  1828 Andrew Jackson         Dem.       0.682       0.559         0.122 
##  3  1832 Andrew Jackson         Dem.       0.766       0.547         0.178 
##  4  1836 Martin Van Buren       Dem.       0.578       0.508         0.142 
##  5  1840 William Henry Harrison Whig       0.796       0.529         0.0605
##  6  1844 James Polk             Dem.       0.618       0.495         0.0145
##  7  1848 Zachary Taylor         Whig       0.562       0.473         0.0479
##  8  1852 Franklin Pierce        Dem.       0.858       0.508         0.0695
##  9  1856 James Buchanan         Dem.       0.588       0.453         0.122 
## 10  1860 Abraham Lincoln        Rep.       0.594       0.396         0.101 
## # ... with 39 more rows</code></pre>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb159-1" data-line-number="1">p_title &lt;-<span class="st"> "Presidential Elections: Popular &amp; Electoral College Margins"</span></a>
<a class="sourceLine" id="cb159-2" data-line-number="2">p_subtitle &lt;-<span class="st"> "1824-2016"</span></a>
<a class="sourceLine" id="cb159-3" data-line-number="3">p_caption &lt;-<span class="st"> "Data for 2016 are provisional."</span></a>
<a class="sourceLine" id="cb159-4" data-line-number="4">x_label &lt;-<span class="st"> "Winner's share of Popular Vote"</span></a>
<a class="sourceLine" id="cb159-5" data-line-number="5">y_label &lt;-<span class="st"> "Winner's share of Electoral College Votes"</span></a>
<a class="sourceLine" id="cb159-6" data-line-number="6"/>
<a class="sourceLine" id="cb159-7" data-line-number="7">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(elections_historic, <span class="kw">aes</span>(<span class="dt">x =</span> popular_pct, <span class="dt">y =</span> ec_pct,</a>
<a class="sourceLine" id="cb159-8" data-line-number="8">                                    <span class="dt">label =</span> winner_label))</a>
<a class="sourceLine" id="cb159-9" data-line-number="9"/>
<a class="sourceLine" id="cb159-10" data-line-number="10">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_hline</span>(<span class="dt">yintercept =</span> <span class="fl">0.5</span>, <span class="dt">size =</span> <span class="fl">1.4</span>, <span class="dt">color =</span> <span class="st">"gray80"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb159-11" data-line-number="11"><span class="st">    </span><span class="kw">geom_vline</span>(<span class="dt">xintercept =</span> <span class="fl">0.5</span>, <span class="dt">size =</span> <span class="fl">1.4</span>, <span class="dt">color =</span> <span class="st">"gray80"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb159-12" data-line-number="12"><span class="st">    </span><span class="kw">geom_point</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb159-13" data-line-number="13"><span class="st">    </span><span class="kw">geom_text_repel</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb159-14" data-line-number="14"><span class="st">    </span><span class="kw">scale_x_continuous</span>(<span class="dt">labels =</span> scales<span class="op">::</span>percent) <span class="op">+</span></a>
<a class="sourceLine" id="cb159-15" data-line-number="15"><span class="st">    </span><span class="kw">scale_y_continuous</span>(<span class="dt">labels =</span> scales<span class="op">::</span>percent) <span class="op">+</span></a>
<a class="sourceLine" id="cb159-16" data-line-number="16"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x =</span> x_label, <span class="dt">y =</span> y_label, <span class="dt">title =</span> p_title, <span class="dt">subtitle =</span> p_subtitle,</a>
<a class="sourceLine" id="cb159-17" data-line-number="17">         <span class="dt">caption =</span> p_caption)</a></code></pre>
<p>Figure <a href="workgeoms.html#fig:ch-05-electionplot-01">5.18</a> takes each U.S. presidential election since 1824 (the first year that the size of the popular vote was recorded), and plots the winner’s share of the popular vote against the winner’s share of the electoral college vote. The shares are stored in the data as proportions (from 0 to 1) rather than percentages, so we need to adjust the labels of the scales using <code>scale_x_continuous()</code> and <code>scale_y_continuous()</code>. Seeing as we are interested in particular presidencies, we also want to label the points. But<label for="tufte-mn-65" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-65" class="margin-toggle"/><span class="marginnote shownote">Normally it is not a good idea to label every point on a plot in the way we do here. A better approach might be to select a few points of particular interest.</span> because many of the data points are plotted quite close together we need to make sure the labels do not overlap with each other, or obscure other points. The <code>geom_text_repel()</code> function handles the problem very well. This plot has relatively long labels. We could put them directly in the code, but just to keep things a bit tidier we assign the text to some named objects instead. Then we use those in the plot formula.</p>
<div class="figure fullwidth"><span id="fig:ch-05-electionplot-01"/>
<img src="../Images/a2613e5adc2cd4f46414ddca11200103.png" alt="Text labels with ggrepel." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-electionplot-01-1.png"/>
<p class="caption marginnote shownote">
Figure 5.18: Text labels with ggrepel.
</p>
</div>
<p>In this plot, what is of interest about any particular point is the
quadrant of the x-y plane each point it is in, and how far away it is
from the fifty percent threshold on both the x-axis (with the popular
vote share) and the y-axis (with the electoral college vote share). To
underscore this point we draw two reference lines at the fifty percent
line in each direction. They are drawn at the beginning of the plotting process so that the points and labels can be layered on top of them. We use two new geoms, <code>geom_hline()</code> and <code>geom_vline()</code> to make the lines. They take <code>yintercept</code> and <code>xintercept</code> arguments, respectively, and the lines can also be sized
and colored as you please. There is also a <code>geom_abline()</code> geom that
draws straight lines based on a supplied slope and intercept. This is
useful for plotting, for example, 45 degree reference lines in scatterplots.</p>
<p>The ggrepel package has several other useful geoms and options to aid with effectively plotting labels along with points. The performance of its labeling algorithm is consistently very good. For many purposes it will be a better first choice than <code>geom_text()</code>.</p>
&#13;

<h2><span class="header-section-number">5.4</span> Label outliers</h2>
<p>Sometimes we want to pick out some points of interest in the data
without labeling every single item. We can still use <code>geom_text()</code> or
<code>geom_text_repel()</code>. We just need to pick out the points we want to
label. In the code above, we do this on the fly by telling
<code>geom_text_repel()</code> to use a different data set from the one
<code>geom_point()</code> is using. We do this using the <code>subset()</code> function.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-texlabhidden-01"/>
<img src="../Images/5d49387a28c157265c595c015e091824.png" alt="Top: Labeling text according to a single criterion. Bottom: Labeling according to several criteria." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-texlabhidden-01-1.png"/><img src="../Images/ede49654a99f1b182c6ac76cf63d9833.png" alt="Top: Labeling text according to a single criterion. Bottom: Labeling according to several criteria." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-texlabhidden-01-2.png"/>
<!--
<p class="caption marginnote">-->Figure 5.19: Top: Labeling text according to a single criterion. Bottom: Labeling according to several criteria.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb160-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> by_country,</a>
<a class="sourceLine" id="cb160-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> gdp_mean, <span class="dt">y =</span> health_mean))</a>
<a class="sourceLine" id="cb160-3" data-line-number="3"/>
<a class="sourceLine" id="cb160-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb160-5" data-line-number="5"><span class="st">    </span><span class="kw">geom_text_repel</span>(<span class="dt">data =</span> <span class="kw">subset</span>(by_country, gdp_mean <span class="op">&gt;</span><span class="st"> </span><span class="dv">25000</span>),</a>
<a class="sourceLine" id="cb160-6" data-line-number="6">                    <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">label =</span> country))</a>
<a class="sourceLine" id="cb160-7" data-line-number="7"/>
<a class="sourceLine" id="cb160-8" data-line-number="8">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> by_country,</a>
<a class="sourceLine" id="cb160-9" data-line-number="9">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> gdp_mean, <span class="dt">y =</span> health_mean))</a>
<a class="sourceLine" id="cb160-10" data-line-number="10"/>
<a class="sourceLine" id="cb160-11" data-line-number="11">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb160-12" data-line-number="12"><span class="st">    </span><span class="kw">geom_text_repel</span>(<span class="dt">data =</span> <span class="kw">subset</span>(by_country,</a>
<a class="sourceLine" id="cb160-13" data-line-number="13">                                  gdp_mean <span class="op">&gt;</span><span class="st"> </span><span class="dv">25000</span> <span class="op">|</span><span class="st"> </span>health_mean <span class="op">&lt;</span><span class="st"> </span><span class="dv">1500</span> <span class="op">|</span></a>
<a class="sourceLine" id="cb160-14" data-line-number="14"><span class="st">                                  </span>country <span class="op">%in%</span><span class="st"> "Belgium"</span>),</a>
<a class="sourceLine" id="cb160-15" data-line-number="15">                    <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">label =</span> country))</a></code></pre>
<p>In the first figure, we specify a new <code>data</code> argument to the text
geom, and use <code>subset()</code> to create a small dataset on the fly. The
<code>subset()</code> function takes the <code>by_country</code> object and selects only the
cases where <code>gdp_mean</code> is over 25,000, with the result that only those
points are labeled in the plot. The criteria we use can be whatever we
like, as long as we can write a logical expression that defines it.
For example, in the lower figure we pick out cases where <code>gdp_mean</code> is
greater than 25,000, <em>or</em> <code>health_mean</code> is less than 1,500, <em>or</em> the
country is Belgium. In all of these plots, because we are using
<code>geom_text_repel()</code>, we no longer have to worry about our earlier
problem where the country labels were clipped at the edge of the plot.</p>
<p>Alternatively, we can pick out specific points by creating a dummy variable in the data set just for this purpose. Here we add a column to <code>organdata</code> called <code>ind</code>. An observation gets coded as <code>TRUE</code> if <code>ccode</code> is “Ita”, or “Spa”, <em>and</em> if the <code>year</code> is greater than 1998. We use this new <code>ind</code> variable in two ways in the plotting code. First, we map it to the <code>color</code> aesthetic in the usual way. Second, we use it to subset the data that the text geom will label. Then we suppress the legend that would otherwise appear for the <code>label</code> and <code>color</code> aesthetics by using the <code>guides()</code> function.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-guidesplot-01"/>
<img src="../Images/caf5eb8cfdc0c144bcad11c66fd01e87.png" alt="Labeling using a dummy variable." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-guidesplot-01-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.20: Labeling using a dummy variable.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb161-1" data-line-number="1">organdata<span class="op">$</span>ind &lt;-<span class="st"> </span>organdata<span class="op">$</span>ccode <span class="op">%in%</span><span class="st"> </span><span class="kw">c</span>(<span class="st">"Ita"</span>, <span class="st">"Spa"</span>) <span class="op">&amp;</span></a>
<a class="sourceLine" id="cb161-2" data-line-number="2"><span class="st">                    </span>organdata<span class="op">$</span>year <span class="op">&gt;</span><span class="st"> </span><span class="dv">1998</span></a>
<a class="sourceLine" id="cb161-3" data-line-number="3"/>
<a class="sourceLine" id="cb161-4" data-line-number="4">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb161-5" data-line-number="5">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> roads,</a>
<a class="sourceLine" id="cb161-6" data-line-number="6">                          <span class="dt">y =</span> donors, <span class="dt">color =</span> ind))</a>
<a class="sourceLine" id="cb161-7" data-line-number="7">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb161-8" data-line-number="8"><span class="st">    </span><span class="kw">geom_text_repel</span>(<span class="dt">data =</span> <span class="kw">subset</span>(organdata, ind),</a>
<a class="sourceLine" id="cb161-9" data-line-number="9">                    <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">label =</span> ccode)) <span class="op">+</span></a>
<a class="sourceLine" id="cb161-10" data-line-number="10"><span class="st">    </span><span class="kw">guides</span>(<span class="dt">label =</span> <span class="ot">FALSE</span>, <span class="dt">color =</span> <span class="ot">FALSE</span>)</a></code></pre>
&#13;

<h2><span class="header-section-number">5.5</span> Write and draw in the plot area</h2>
<p>Sometimes we want to annotate the figure directly. Maybe we need to
point out something important that is not mapped to a variable. We use
<code>annotate()</code> for this purpose. It isn’t quite a geom, as it doesn’t
accept any variable mappings from our data. Instead, it can <em>use</em>
geoms, temporarily taking advantage of their features in order to
place something on the plot. The most obvious use-case is putting
arbitrary text on the plot.</p>
<p>We will tell <code>annotate()</code> to use a text geom. It hands the plotting
duties to <code>geom_text()</code>, which means that we can use all of that geom’s
arguments in the <code>annotate()</code> call. This includes the <code>x</code>, <code>y</code>, and <code>label</code>
arguments, as one would expect, but also things like <code>size</code>, <code>color</code>, and
the <code>hjust</code> and <code>vjust</code> settings that allow text to be justified. This is
particularly useful when our label has several lines in it. We include
extra lines by using the special “newline” code, <code>\n</code>, which we use
instead of a space to force a line-break as needed.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-annotate-01"/>
<img src="../Images/3f86d50559672b7f362dad81b3e0db5d.png" alt="Arbitrary text with &lt;code&gt;annotate()&lt;/code&gt;." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-annotate-01-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.21: Arbitrary text with <code>annotate()</code>.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb162-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> roads, <span class="dt">y =</span> donors))</a>
<a class="sourceLine" id="cb162-2" data-line-number="2">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">annotate</span>(<span class="dt">geom =</span> <span class="st">"text"</span>, <span class="dt">x =</span> <span class="dv">91</span>, <span class="dt">y =</span> <span class="dv">33</span>,</a>
<a class="sourceLine" id="cb162-3" data-line-number="3">                            <span class="dt">label =</span> <span class="st">"A surprisingly high </span><span class="ch">\n</span><span class="st"> recovery rate."</span>,</a>
<a class="sourceLine" id="cb162-4" data-line-number="4">                            <span class="dt">hjust =</span> <span class="dv">0</span>)</a></code></pre>
<p>The <code>annotate()</code> function can work with other geoms, too. Use it to
draw rectangles, line segments, and arrows. Just remember to pass
along the right arguments to the geom you use. We can add a rectangle
to this plot, for instance, with a second call to the function.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb163-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb163-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> roads, <span class="dt">y =</span> donors))</a>
<a class="sourceLine" id="cb163-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb163-4" data-line-number="4"><span class="st">    </span><span class="kw">annotate</span>(<span class="dt">geom =</span> <span class="st">"rect"</span>, <span class="dt">xmin =</span> <span class="dv">125</span>, <span class="dt">xmax =</span> <span class="dv">155</span>,</a>
<a class="sourceLine" id="cb163-5" data-line-number="5">             <span class="dt">ymin =</span> <span class="dv">30</span>, <span class="dt">ymax =</span> <span class="dv">35</span>, <span class="dt">fill =</span> <span class="st">"red"</span>, <span class="dt">alpha =</span> <span class="fl">0.2</span>) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb163-6" data-line-number="6"><span class="st">    </span><span class="kw">annotate</span>(<span class="dt">geom =</span> <span class="st">"text"</span>, <span class="dt">x =</span> <span class="dv">157</span>, <span class="dt">y =</span> <span class="dv">33</span>,</a>
<a class="sourceLine" id="cb163-7" data-line-number="7">             <span class="dt">label =</span> <span class="st">"A surprisingly high </span><span class="ch">\n</span><span class="st"> recovery rate."</span>, <span class="dt">hjust =</span> <span class="dv">0</span>)</a></code></pre>
<div class="figure"><span id="fig:ch-05-annotate-02"/>
<p class="caption marginnote shownote">
Figure 5.22: Using two different geoms with <code>annotate()</code>.
</p>
<img src="../Images/6e64df4718fa9855a4e9dac823c96edf.png" alt="Using two different geoms with &lt;code&gt;annotate()&lt;/code&gt;." width="90%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-annotate-02-1.png"/>
</div>
&#13;

<h2><span class="header-section-number">5.6</span> Understanding scales, guides, and themes</h2>
<p>This chapter has gradually extended our ggplot vocabulary in two ways. First, we introduced some new <code>geom_</code> functions that allowed us to draw new kinds of plots. Second, we made use of new functions controlling some aspects of the appearance of our graph. We used <code>scale_x_log10()</code>, <code>scale_x_continuous()</code> and other <code>scale_</code> functions to adjust axis labels. We used the <code>guides()</code> function to remove the legends for a <code>color</code> mapping and a <code>label</code> mapping. And we also used the <code>theme()</code> function to move the position of a legend from the side to the top of a figure.</p>
<p>Learning about new geoms extended what we have seen already. Each geom makes a different type of plot. Different plots require different mappings in order to work, and so each <code>geom_</code> function takes mappings tailored to the kind of graph it draws. You can’t use <code>geom_point()</code> to make a scatterplot without supplying an <code>x</code> and a <code>y</code> mapping, for example. Using <code>geom_histogram()</code> only requires you to supply an <code>x</code> mapping. Similarly, <code>geom_pointrange()</code> requires <code>ymin</code> and <code>ymax</code> mappings in order to know where to draw the lineranges it makes. A <code>geom_</code> function may take optional arguments, too. When using <code>geom_boxplot()</code> you can specify what the outliers look like using arguments like <code>outlier.shape</code> and <code>outlier.color</code>.</p>
<p>The second kind of extension introduced some new functions, and with them some new concepts. What are the differences between the <code>scale_</code> functions, the <code>guides()</code> function, and the <code>theme()</code> function? When do you know to use one rather than the other? Why are there so many <code>scale_</code> functions listed in the online help, anyway? How can you tell which one you need?</p>
<p>Here is a rough and ready starting point:</p>
<ul>
<li>Every aesthetic mapping has a scale. If you want to adjust how that scale is marked or graduated, then you use a <code>scale_</code> function.</li>
<li>Many scales come with a legend or key to help the reader interpret the graph. These are called <em>guides</em>. You can make adjustments to them with the <code>guides()</code> function. Perhaps the most common use case is to make the legend disappear, as it is sometimes superfluous. Another is to adjust the arrangement of the key in legends and colorbars.</li>
<li>Graphs have other features not strictly connected to the logical
structure of the data being displayed. These include things like
their background color, the typeface used for labels, or the
placement of the legend on the graph. To adjust these, use the
<code>theme()</code> function.</li>
</ul>
<p>Consistent with ggplot’s overall approach, adjusting some visible feature of the graph means first thinking about the relationship that the feature has with the underlying data. Roughly speaking, if the change you want to make will affect the substantive interpretation of any particular geom, then most likely you will either be mapping an aesthetic to a variable using that geom’s <code>aes()</code> function, or you will be specifying a change via some <code>scale_</code> function. If the change you want to make does not affect the interpretation of a given geom_, then most likely you will either be setting a variable inside the <code>geom_</code> function, or making a cosmetic change via the <code>theme()</code> function.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-scalesfig-01"/>
<img src="../Images/2baf5a838809dd86e16a88cbfc970f7e.png" alt="Every mapped variable has a scale." width="576" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-scalesfig-01-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.23: Every mapped variable has a scale.<!--</p>-->
<!--</div>--></span>
</p>
<p>Scales and guides are closely connected, which can make things confusing. The guide provides information about the scale, such as in a legend or colorbar. Thus, it is possible to make adjustments to guides from inside the various <code>scale_</code> functions. More often it is easier to use the <code>guides()</code> function directly.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb164-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb164-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> roads,</a>
<a class="sourceLine" id="cb164-3" data-line-number="3">                          <span class="dt">y =</span> donors,</a>
<a class="sourceLine" id="cb164-4" data-line-number="4">                          <span class="dt">color =</span> world))</a>
<a class="sourceLine" id="cb164-5" data-line-number="5">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>()</a></code></pre>
<p>Figure <a href="workgeoms.html#fig:ch-05-scalesfig-01">5.23</a> shows a plot with three aesthetic mappings. The variable <code>roads</code> is mapped to <code>x</code>; <code>donors</code> is mapped to <code>y</code>; and <code>world</code> is mapped to <code>color</code>. The <code>x</code> and <code>y</code> scales are both <em>continuous</em>, running smoothly from just under the lowest value of the variable to just over the highest value. Various labeled tick marks orient the reader to the values on each axis. The <code>color</code> mapping also has a scale. The <code>world</code> measure is an unordered categorical variable, so its scale is <em>discrete</em>. It takes one of four values, each represented by a different color.</p>
<p>Along with <code>color</code>, mappings like <code>fill</code>, <code>shape</code>, and <code>size</code> will have scales that we might want to customize or adjust. We could have mapped <code>world</code> to <code>shape</code> instead of <code>color</code>. In that case our four-category variable would have a scale consisting of four different shapes. Scales for these mappings may have labels, axis tick marks at particular positions, or specific colors or shapes. If we want to adjust them, we use one of the <code>scale_</code> functions.</p>
<p>Many different kinds of variable can be mapped. More often than not <code>x</code> and <code>y</code> are continuous measures. But they might also easily be discrete, as when we mapped country names to the <code>y</code> axis in our boxplots and dotplots. An <code>x</code> or <code>y</code> mapping can also be defined as a transformation onto a log scale, or as a special sort of number value like a date. Similarly, a <code>color</code> or a <code>fill</code> mapping can be discrete and <em>unordered</em>, as with our <code>world</code> variable, or discrete and <em>ordered</em>, as with letter grades in an exam. A <code>color</code> or <code>fill</code> mapping can also be a continuous quantity, represented as a gradient running smoothly from a low to a high value. Finally, both continuous gradients and ordered discrete values might have some defined neutral midpoint with extremes diverging in both directions.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-scale-template"/>
<img src="../Images/f68891a3a348d121e8d9d743eaa18404.png" alt="A schema for naming the &lt;code&gt;scale&lt;/code&gt; functions." width="280" data-original-src="https://socviz.co/assets/ch-05-scale_mapping_kind.png"/>
<!--
<p class="caption marginnote">-->Figure 5.24: A schema for naming the <code>scale</code> functions.<!--</p>-->
<!--</div>--></span>
</p>
<p>Because we have several potential mappings, and each mapping might be to one of several different scales, we end up with a lot of individual <code>scale_</code> functions. Each deals with one combination of mapping and scale. They are named according to a consistent logic, shown in Figure <a href="workgeoms.html#fig:ch-05-scale-template">5.24</a>. First comes the <code>scale_</code> name, then the <em>mapping</em> it applies to, and finally the <em>kind</em> of value the scale will display. Thus, the <code>scale_x_continuous()</code> function controls <code>x</code> scales for continuous variables; <code>scale_y_discrete()</code> adjusts <code>y</code> scales for discrete variables; and <code>scale_x_log10()</code> transforms an <code>x</code> mapping to a log scale. Most of the time, ggplot will guess correctly what sort of scale is needed for your mapping. Then it will work out some default features of the scale (such as its labels and where the tick marks go). In many cases you will not need to make any scale adjustments. If <code>x</code> is mapped to a continuous variable then adding <code>+ scale_x_continuous()</code> to your plot statement with no further arguments will have no effect. It is already there implicitly. Adding <code>+ scale_x_log10()</code>, on the other hand, will transform your scale, as now you have replaced the default treatment of a continuous x variable.</p>
<p>If you want to adjust the labels or tick marks on a scale, you will need to know which mapping it is for and what sort of scale it is. Then you supply the arguments to the appropriate scale function. For example, we can change the x-axis of the previous plot to a log scale, and then also change the position and labels of the tick marks on the y-axis.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-scalesfig-02"/>
<img src="../Images/cc6fa882fd8215de245122737bccb83c.png" alt="Making some scale adjustments." width="90%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-scalesfig-02-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.25: Making some scale adjustments.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb165-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb165-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> roads,</a>
<a class="sourceLine" id="cb165-3" data-line-number="3">                          <span class="dt">y =</span> donors,</a>
<a class="sourceLine" id="cb165-4" data-line-number="4">                          <span class="dt">color =</span> world))</a>
<a class="sourceLine" id="cb165-5" data-line-number="5">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb165-6" data-line-number="6"><span class="st">    </span><span class="kw">scale_x_log10</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb165-7" data-line-number="7"><span class="st">    </span><span class="kw">scale_y_continuous</span>(<span class="dt">breaks =</span> <span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">15</span>, <span class="dv">25</span>),</a>
<a class="sourceLine" id="cb165-8" data-line-number="8">                       <span class="dt">labels =</span> <span class="kw">c</span>(<span class="st">"Five"</span>, <span class="st">"Fifteen"</span>, <span class="st">"Twenty Five"</span>))</a></code></pre>
<p>The same applies to mappings like <code>color</code> and <code>fill</code>. Here the available <code>scale_</code> functions include ones that deal with continuous, diverging, and discrete variables, as well as others that we will encounter later when we discuss the use of color and color palettes in more detail. When working with a scale that produces a legend, we can also use this its <code>scale_</code> function to specify the labels in the key. To change the <em>title</em> of the legend, however, we use the <code>labs()</code> function, which lets us label all the mappings.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-scalesfig-03"/>
<img src="../Images/de3905e462410cdccab6ff95d4746cc5.png" alt="Relabeling via a scale function." width="90%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-scalesfig-03-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.26: Relabeling via a scale function.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb166-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb166-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> roads,</a>
<a class="sourceLine" id="cb166-3" data-line-number="3">                          <span class="dt">y =</span> donors,</a>
<a class="sourceLine" id="cb166-4" data-line-number="4">                          <span class="dt">color =</span> world))</a>
<a class="sourceLine" id="cb166-5" data-line-number="5">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb166-6" data-line-number="6"><span class="st">    </span><span class="kw">scale_color_discrete</span>(<span class="dt">labels =</span></a>
<a class="sourceLine" id="cb166-7" data-line-number="7">                             <span class="kw">c</span>(<span class="st">"Corporatist"</span>, <span class="st">"Liberal"</span>,</a>
<a class="sourceLine" id="cb166-8" data-line-number="8">                               <span class="st">"Social Democratic"</span>, <span class="st">"Unclassified"</span>)) <span class="op">+</span></a>
<a class="sourceLine" id="cb166-9" data-line-number="9"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">"Road Deaths"</span>,</a>
<a class="sourceLine" id="cb166-10" data-line-number="10">         <span class="dt">y =</span> <span class="st">"Donor Procurement"</span>,</a>
<a class="sourceLine" id="cb166-11" data-line-number="11">        <span class="dt">color =</span> <span class="st">"Welfare State"</span>)</a></code></pre>
<p>If we want to move the legend somewhere else on the plot, we are making a purely cosmetic decision and that is the job of the <code>theme()</code> function. As we have already seen, adding <code>+ theme(legend.position = "top")</code> will move the legend as instructed. Finally, to make the legend disappear altogether, we tell ggplot that we do not want a guide for that scale. This is generally not good practice, but there can be good reasons to do it. We will see some examples later on.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb167-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> organdata,</a>
<a class="sourceLine" id="cb167-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> roads,</a>
<a class="sourceLine" id="cb167-3" data-line-number="3">                          <span class="dt">y =</span> donors,</a>
<a class="sourceLine" id="cb167-4" data-line-number="4">                          <span class="dt">color =</span> world))</a>
<a class="sourceLine" id="cb167-5" data-line-number="5">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb167-6" data-line-number="6"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">"Road Deaths"</span>,</a>
<a class="sourceLine" id="cb167-7" data-line-number="7">         <span class="dt">y =</span> <span class="st">"Donor Procurement"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb167-8" data-line-number="8"><span class="st">    </span><span class="kw">guides</span>(<span class="dt">color =</span> <span class="ot">FALSE</span>)</a></code></pre>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-scalesfig-04"/>
<img src="../Images/c75b51f0fc2df917751b27f2d454693b.png" alt="Removing the guide to a scale." width="576" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-scalesfig-04-1.png"/>
<!--
<p class="caption marginnote">-->Figure 5.27: Removing the guide to a scale.<!--</p>-->
<!--</div>--></span>
</p>
<p>We will look more closely at <code>scale_</code> and <code>theme()</code> functions in Chapter <a href="refineplots.html#refineplots">8</a>, when we discuss how to polish plots that we are ready to display or publish. Until then, we will use <code>scale_</code> functions fairly regularly to make small adjustments to the labels and axes of our graphs. And we will occasionally use the <code>theme()</code> function to make some cosmetic adjustments here and there. So you do not need to worry too much about additional details of how they work until later on. But at this point it <em>is</em> worth knowing what <code>scale_</code> functions are for, and the logic behind their naming scheme. Understanding the <code>scale_&lt;mapping&gt;_&lt;kind&gt;()</code> rule makes it easier to see what is going on when one of these functions is called to make an adjustment to a plot.</p>
&#13;

<h2><span class="header-section-number">5.7</span> Where to go next</h2>
<p>We covered several new functions and data aggregation techniques in this Chapter. You should practice working with them.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-05-gapminder-revisit"/>
<img src="../Images/29521484b08d54e09144a78dfbe4c4ba.png" alt="Two figures from Chapter 1." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-gapminder-revisit-1.png"/><img src="../Images/4d47e812c07ab78006c1ab2415e80c88.png" alt="Two figures from Chapter 1." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-05-gapminder-revisit-2.png"/>
<!--
<p class="caption marginnote">-->Figure 5.28: Two figures from Chapter 1.<!--</p>-->
<!--</div>--></span>
</p>
<ul>
<li>The <code>subset()</code> function is very useful when used in conjunction with a series of layered geoms. Go back to your code for the Presidential Elections plot (Figure <a href="workgeoms.html#fig:ch-05-electionplot-01">5.18</a>) and redo it so that it shows all the data points but only labels elections since 1992. You might need to look again at the <code>elections_historic</code> data to see what variables are available to you. You can also experiment with subsetting by political party, or changing the colors of the points to reflect the winning party.</li>
<li>Use <code>geom_point()</code> and <code>reorder()</code> to make a Cleveland dot plot of all Presidential elections, ordered by share of the popular vote.</li>
<li>Try using <code>annotate()</code> to add a rectangle that lightly colors the entire upper left quadrant of Figure <a href="workgeoms.html#fig:ch-05-electionplot-01">5.18</a>.</li>
<li>The main action verbs in the <code>dplyr</code> library are <code>group_by()</code>, <code>filter()</code>, <code>select()</code>, <code>summarize()</code>, and <code>mutate()</code>. Practice with them by revisiting the <code>gapminder</code> data to see if you can reproduce a pair of graphs from Chapter One, shown here again in Figure <a href="workgeoms.html#fig:ch-05-gapminder-revisit">5.28</a>. You will need to filter some rows, group the data by continent, and calculate the mean life expectancy by continent before beginning the plotting process.</li>
<li>Get comfortable with grouping, mutating, and summarizing data in pipelines. This will become a routine task as you work with your data. There are many ways that tables can be aggregated and transformed. Remember <code>group_by()</code> groups your data from left to right, with the rightmost or innermost group being the level calculations will be done at; <code>mutate()</code> adds a column at the current level of grouping; and <code>summarize()</code> aggregates to the next level up. Try creating some grouped objects from the GSS data, calculating frequencies as you learned in this Chapter, and then check to see if the totals are what you expect. For example, start by grouping <code>degree</code> by <code>race</code>, like this:</li>
</ul>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb168-1" data-line-number="1">gss_sm <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(race, degree) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb168-2" data-line-number="2"><span class="st">    </span><span class="kw">summarize</span>(<span class="dt">N =</span> <span class="kw">n</span>()) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb168-3" data-line-number="3"><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">pct =</span> <span class="kw">round</span>(N <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(N)<span class="op">*</span><span class="dv">100</span>, <span class="dv">0</span>)) </a></code></pre>
<pre><code>## # A tibble: 18 x 4
## # Groups:   race [3]
##    race  degree             N   pct
##    &lt;fct&gt; &lt;fct&gt;          &lt;int&gt; &lt;dbl&gt;
##  1 White Lt High School   197  9.00
##  2 White High School     1057 50.0 
##  3 White Junior College   166  8.00
##  4 White Bachelor         426 20.0 
##  5 White Graduate         250 12.0 
##  6 White &lt;NA&gt;               4  0   
##  7 Black Lt High School    60 12.0 
##  8 Black High School      292 60.0 
##  9 Black Junior College    33  7.00
## 10 Black Bachelor          71 14.0 
## 11 Black Graduate          31  6.00
## 12 Black &lt;NA&gt;               3  1.00
## 13 Other Lt High School    71 26.0 
## 14 Other High School      112 40.0 
## 15 Other Junior College    17  6.00
## 16 Other Bachelor          39 14.0 
## 17 Other Graduate          37 13.0 
## 18 Other &lt;NA&gt;               1  0</code></pre>
<ul>
<li>This code is similar to what you saw earlier, but a little more compact. (We calculate the <code>pct</code> values directly.) Check the results are as you expect by grouping by <code>race</code> and summing the percentages. Try doing the same exercise grouping by <code>sex</code> or <code>region</code>.</li>
<li>Try summary calculations with functions other than <code>sum</code>. Can you calculate the mean and median number of children by <code>degree</code>? (Hint: the <code>childs</code> variable in <code>gss_sm</code> has children as a numeric value.)</li>
<li><p><code>dplyr</code> has a large number of helper functions that let you summarize data in many different ways. The vignette on <em>window functions</em> included with the <code>dplyr</code> documentation is a good place to begin learning about these. You should also look at Chapter 3 of <span class="citation">Wickham &amp; Grolemund (2016)</span> for more information on transforming data with <code>dplyr</code>.</p></li>
<li>Experiment with the <code>gapminder</code> data to practice some of
the new geoms we have learned. Try examining population or life
expectancy over time using a series of boxplots. (Hint: you may need
to use the <code>group</code> aesthetic in the <code>aes()</code> call.) Can you facet
this boxplot by continent? Is anything different if you create a tibble from <code>gapminder</code> that explicitly groups the data by <code>year</code> and <code>continent</code> first, and then create your plots with that?</li>
<li>Read the help page for <code>geom_boxplot()</code> and take a look at the <code>notch</code> and <code>varwidth</code> options. Try them out to see how they change the look of the plot.</li>
<li>As an alternative to <code>geom_boxplot()</code> try <code>geom_violin()</code> for a similar plot, but with a mirrored density distribution instead of a box and whiskers.</li>
<li><p><code>geom_pointrange()</code> is one of a family of related geoms that produce different kinds of error bars and ranges, depending on your specific needs. They include <code>geom_linerange()</code>, <code>geom_crossbar()</code>, and <code>geom_errorbar()</code>. Try them out using <code>gapminder</code> or <code>organdata</code> to see how they differ.</p></li>
</ul>

    
</body>
</html>