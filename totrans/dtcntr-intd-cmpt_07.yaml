- en: 3.4Â Conditionals and BooleansðŸ”—
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: åŽŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/Conditionals_and_Booleans.html](https://dcic-world.org/2025-08-27/Conditionals_and_Booleans.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Â Â Â Â [3.4.1Â Motivating Example: Shipping Costs](#%28part._add-shipping-setup%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [3.4.2Â Conditionals: Computations with Decisions](#%28part._cond-boolean-intro%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [3.4.3Â Booleans](#%28part._booleans%29) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [3.4.3.1Â Other Boolean Operations](#%28part._bool-comparisons%29) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [3.4.3.2Â Combining Booleans](#%28part._.Combining_.Booleans%29) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [3.4.4Â Asking Multiple Questions](#%28part._else-if%29) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [3.4.5Â Evaluating by Reducing Expressions](#%28part._conditional-nm%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [3.4.6Â Composing Functions](#%28part._.Composing_.Functions%29) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [3.4.6.1Â How Function Compositions Evaluate](#%28part._.How_.Function_.Compositions_.Evaluate%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [3.4.6.2Â Function Composition and the Directory](#%28part._func-comp-directory%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [3.4.7Â Nested Conditionals](#%28part._.Nested_.Conditionals%29) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [3.4.8Â Recap: Booleans and Conditionals](#%28part._.Recap__.Booleans_and_.Conditionals%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '3.4.1Â Motivating Example: Shipping Costs[ðŸ”—](#(part._add-shipping-setup) "Link
    to here")'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [Functions Practice: Cost of pens](From_Repeated_Expressions_to_Functions.html#%28part._pen-cost-pyret%29),
    we wrote a program (`pen-cost`) to compute the cost of ordering pens. Continuing
    the example, we now want to account for shipping costs. Weâ€™ll determine shipping
    charges based on the cost of the order.'
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we will write a function `add-shipping` to compute the total cost
    of an order including shipping. Assume an order valued at $10 or less ships for
    $4, while an order valued above $10 ships for $8\. As usual, we will start by
    writing examples of the `add-shipping` computation.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the `is` notation from `where` blocks to write several examples of add-shipping.
    How are you choosing which inputs to use in your examples? Are you picking random
    inputs? Being strategic in some way? If so, whatâ€™s your strategy?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Here is a proposed collection of examples for `add-shipping`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you notice about our examples? What strategies do you observe across
    our choices?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Our proposed examples feature several strategic decisions:'
  prefs: []
  type: TYPE_NORMAL
- en: Including `10`, which is at the boundary of charges based on the text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including `10.01`, which is just over the boundary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including both natural and real (decimal) numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including examples that should result in each shipping charge mentioned in the
    problem (`4` and `8`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So far, we have used a simple rule for creating a function body from examples:
    locate the parts that are changing, replace them with names, then make the names
    the parameters to the function.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is changing across our `add-shipping` examples? Do you notice anything
    different about these changes compared to the examples for our previous functions?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Two things are new in this set of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: The values of `4` and `8` differ across the examples, but they each occur in
    multiple examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The values of `4` and `8` appear only in the computed answersâ€”<wbr>not as an
    input. Which one we use seems to depend on the input value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two observations suggest that something new is going on with `add-shipping`.
    In particular, we have clusters of examples that share a fixed value (the shipping
    charge), but different clusters (a) use different values and (b) have a pattern
    to their inputs (whether the input value is less than or equal to `10`). This
    calls for being able to ask questions about inputs within our programs.
  prefs: []
  type: TYPE_NORMAL
- en: '3.4.2Â Conditionals: Computations with Decisions[ðŸ”—](#(part._cond-boolean-intro)
    "Link to here")'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To ask a question about our inputs, we use a new kind of expression called
    an if expression. Hereâ€™s the full definition of `add-shipping`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In an `if` expression, we ask a question that can produce an answer that is
    true or false (here `order-amt <= 10`, which weâ€™ll explain below in [Booleans](#%28part._booleans%29)),
    provide one expression for when the answer to the question is true (`order-amt
    + 4`), and another for when the result is false (`order-amt + 8`). The `else`
    in the program marks the answer in the false case; we call this the else clause.
    We also need `end` to tell Pyret weâ€™re done with the question and answers.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.3Â Booleans[ðŸ”—](#(part._booleans) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Every expression in Pyret evaluates in a value. So far, we have seen three
    types of values: `Number`, `String`, and `Image`. What type of value does a question
    like `order-amt <= 10` produce? We can use the interactions prompt to experiment
    and find out.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Enter each of the following expressions at the interactions prompt. What type
    of value did you get? Do the values fit the types we have seen so far?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: 'The values `true` and `false` belong to a new type in Pyret, called `Boolean`.Named
    for [George Boole](https://en.wikipedia.org/wiki/George_Boole). While there are
    an infinitely many values of type `Number`, there are only two of type `Boolean`:
    `true` and `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What would happen if we entered `order-amt <= 10` at the interactions prompt
    to explore booleans? Why does that happen?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 3.4.3.1Â Other Boolean Operations[ðŸ”—](#(part._bool-comparisons) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There are many other built-in operations that return `Boolean` values. Comparing
    values for equality is a common one: There is much more we can and should say
    about equality, which we will do later [[Re-Examining Equality](Sharing_and_Equality.html#%28part._identical-eq%29)].'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: In general, `==` checks whether two values are equal. Note this is different
    from the single `=` used to associate names with values in the directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last example is the most interesting: it illustrates that strings are case-sensitive,
    meaning individual letters must match in their case for strings to be considered
    equal.This will become relevant when we get to tables later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we also want to compare strings to determine their alphabetical
    order. Here are several examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'which is the alphabetical order weâ€™re used to; but others need some explaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'These use a convention laid down a long time ago in a system called [ASCII](https://en.wikipedia.org/wiki/ASCII).Things
    get far more complicated with non-ASCII letters: e.g., Pyret thinks `"Å"` is `>`
    than `"Z"`, but in Polish, this should be `false`. Worse, the ordering [depends
    on location](https://en.wikipedia.org/wiki/Alphabetical_order) (e.g., Denmark/Norway
    vs. Finland/Sweden).'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can you compare `true` and `false`? Try comparing them for equality (`==`),
    then for inequality (such as `<`).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In general, you can compare any two values for equality (well, almost, weâ€™ll
    come back to this later); for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to compare values of a specific kind, you can use more specific
    operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Why use these operators instead of the more generic `==`?
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: Therefore, itâ€™s wise to use the type-specific operators where youâ€™re expecting
    the two arguments to be of the same type. Then, Pyret will signal an error if
    you go wrong, instead of blindly returning an answer (`false`) which lets your
    program continue to compute a nonsensical value.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are even more Boolean-producing operators, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Note the capital `W`.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, just about every kind of data will have some Boolean-valued operators
    to enable comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.3.2Â Combining Booleans[ðŸ”—](#(part._.Combining_.Booleans) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, we want to base decisions on more than one Boolean value. For instance,
    you are allowed to vote if youâ€™re a citizen of a country and you are above a certain
    age. Youâ€™re allowed to board a bus if you have a ticket or the bus is having a
    free-ride day. We can even combine conditions: youâ€™re allowed to drive if you
    are above a certain age and have good eyesight andâ€”<wbr>either pass a test or
    have a temporary license. Also, youâ€™re allowed to drive if you are not inebriated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Corresponding to these forms of combinations, Pyret offers three main operations:
    `and`, `or`, and `not`. Here are some examples of their use:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explain why numbers and strings are not good ways to express the answer to a
    true/false question.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 3.4.4Â Asking Multiple Questions[ðŸ”—](#(part._else-if) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Shipping costs are rising, so we want to modify the `add-shipping` program
    to include a third shipping level: orders between $10 and $30 ship for $8, but
    orders over $30 ship for $12\. This calls for two modifications to our program:'
  prefs: []
  type: TYPE_NORMAL
- en: We have to be able to ask another question to distinguish situations in which
    the shipping charge is `8` from those in which the shipping charge is `12`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The question for when the shipping charge is `8` will need to check whether
    the input is between two values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weâ€™ll handle these in order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current body of `add-shipping` asks one question: `order-amt <= 10`. We
    need to add another one for `order-amt <= 30`, using a charge of `12` if that
    question fails. Where do we put that additional question?'
  prefs: []
  type: TYPE_NORMAL
- en: 'An expanded version of the if-expression, using `else if`, allows you to ask
    multiple questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you should also add `where` examples that use the `12` charge.
  prefs: []
  type: TYPE_NORMAL
- en: How does Pyret determine which answer to return? It evaluates each question
    expression in order, starting from the one that follows `if`. It continues through
    the questions, returning the value of the answer of the first question that returns
    true. Hereâ€™s a summary of the if-expression syntax and how it evaluates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: A program can have multiple `else if` cases, thus accommodating an arbitrary
    number of questions within a program.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The problem description for `add-shipping` said that orders between `10` and
    `30` should incur an `8` charge. How does the above code capture â€œbetweenâ€?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is currently entirely implicit. It depends on us understanding the way
    an `if` evaluates. The first question is `order-amt <= 10`, so if we continue
    to the second question, it means `order-amt > 10`. In this context, the second
    question asks whether `order-amt <= 30`. Thatâ€™s how weâ€™re capturing â€œbetweenâ€-ness.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How might you modify the above code to build the â€œbetween 10 and 30â€ requirement
    explicitly into the question for the `8` case?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Remember the `and` operator on booleans? We can use that to capture â€œbetweenâ€
    relationships, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why are there parentheses around the two comparisons? If you replace `order-amt`
    with a concrete value (such as `20`) and leave off the parenthesis, what happens
    when you evaluate this expression in the interactions pane?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here is what `add-shipping` look like with the `and` included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Both versions of `add-shipping` support the same examples. Are both correct?
    Yes. And while the first part of the second question (`order-amt > 10`) is redundant,
    it can be helpful to include such conditions for three reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: They signal to future readers (including ourselves!) the condition covering
    a case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They ensure that if we make a mistake in writing an earlier question, we wonâ€™t
    silently get surprising output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They guard against future modifications, where someone might modify an earlier
    question without realizing the impact itâ€™s having on a later one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An online-advertising firm needs to determine whether to show an ad for a skateboarding
    park to website users. Write a function `show-ad` that takes the age and haircolor
    of an individual user and returns `true` if the user is between the ages of `9`
    and `18` and has either pink or purple hair.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Try writing this two ways: once with `if` expressions and once using just boolean
    operations.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Responsible Computing: Harms from Reducing People to Simple Data'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Assumptions about users get encoded in even the simplest functions. The advertising
    exercise shows an example in which a decision gets made on the basis of two pieces
    of information about a person: age and haircolor. While some people might stereotypically
    associate skateborders with being young and having colored hair, many skateborders
    do not fit these criteria and many people who fit these criteria donâ€™t skateboard.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'While real programs to match ads to users are more sophisticated than this
    simple function, even the most sophisticated advertising programs boil down to
    tracking features or information about individuals and comparing it to information
    about the content of ads. A real ad system would differ in tracking dozens (or
    more) of features and using more advanced programming ideas than simple conditionals
    to determine the suitability of an ad (weâ€™ll discuss some of these later in the
    book). This example also extends to situations far more serious than ads: who
    gets hired, granted a bank loan, or [sent to or released from jail](https://www.propublica.org/article/machine-bias-risk-assessments-in-criminal-sentencing)
    are other examples of real systems that depend on comparing data about individuals
    with criteria maintained by a program.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: From a social responsibility perspective, the questions here are what data about
    individuals should be used to represent them for processing by programs and what
    stereotypes might those data encode. In some cases, individuals can be represented
    by data without harm (a university housing office, for examples, stores student
    ID numbers and which room a student is living in). But in other cases, data about
    individuals get interpreted in order to predict something about them. Decisions
    based on those predictions can be inaccurate and hence harmful.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 3.4.5Â Evaluating by Reducing Expressions[ðŸ”—](#(part._conditional-nm) "Link to
    here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [How Functions Evaluate](From_Repeated_Expressions_to_Functions.html#%28part._function-call-nm%29),
    we talked about how Pyret reduces expressions and function calls to values. Letâ€™s
    revisit this process, this time expanding to consider if-expressions. Suppose
    we want to compute the wages of a worker. The worker is paid $10 for every hour
    up to the first 40 hours, and is paid $15 for every extra hour. Letâ€™s say `hours`
    contains the number of hours they work, and suppose itâ€™s `45`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Suppose the formula for computing the wage is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Letâ€™s now see how this results in an answer, using a step-by-step process that
    should match what youâ€™ve seen in algebra classes (the steps are described in the
    margin notes to the right): The first step is to substitute the `hours` with `45`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Next, the conditional part of the `if` expression is evaluated, which in this
    case is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Since the condition is `false`, the next branch is tried.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Pyret evaluates the question in the conditional, which in this case produces
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Since the condition is `true`, the expression reduces to the body of that branch.
    After that, itâ€™s just arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This style of reduction is the best way to think about the evaluation of Pyret
    expressions. The whole expression takes steps that simplify it, proceeding by
    simple rules. You can use this style yourself if you want to try and work through
    the evaluation of a Pyret program by hand (or in your head).
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.6Â Composing Functions[ðŸ”—](#(part._.Composing_.Functions) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We started this chapter wanting to account for shipping costs on an order of
    pens. So far, we have written two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pen-cost` for computing the cost of the pens'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add-shipping` for adding shipping costs to a total amount'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What if we now wanted to compute the price of an order of pens including shipping?
    We would have to use both of these functions together, sending the output of `pen-cost`
    to the input of `add-shipping`.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write an expression that computes the total cost, with shipping, of an order
    of `10` pens that say `"bravo"`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'There are two ways to structure this computation. We could pass the result
    of `pen-cost` directly to `add-shipping`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you might have named the result of `pen-cost` as an intermediate
    step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Both methods would produce the same answer.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.6.1Â How Function Compositions Evaluate[ðŸ”—](#(part._.How_.Function_.Compositions_.Evaluate)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Letâ€™s review how these programs evaluate in the context of substitution and
    the directory. Weâ€™ll start with the second version, in which we explicitly name
    the result of calling `pen-cost`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Evaluating the second version: At a high level, Pyret goes through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Substitute `10` for `num-pens` and `"bravo"` for `message` in the body of `pen-cost`,
    then evaluate the substituted body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store `pens` in the directory, with a value of `3.5`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a first step in evaluating `add-shipping(pens)`, look up the value of `pens`
    in the directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Substitute `3.5` for `order-amt` in the body of `add-shipping` then evaluate
    the resulting expression, which results in `7.5`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Evaluating the first version: As a reminder, the first version consisted of
    a single expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Since arguments are evaluated before functions get called, start by evaluating
    `pen-cost(10, "bravo")` (again using substitution), which reduces to `3.5`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Substitute `3.5` for `order-amt` in the body of `add-shipping` then evaluate
    the resulting expression, which results in `7.5`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Contrast these two summaries. Where do they differ? What aspects of the code
    led to those differences?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The difference lies in the use of the directory: the version that explicitly
    named `pens` uses the directory. The other version doesnâ€™t use the directory at
    all. Yet both approaches lead to the same result, since the same value (the result
    of calling `pen-cost`) gets substituted into the body of `add-shipping`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This analysis might suggest that the version that uses the directory is somehow
    wasteful: it seems to take more steps just to end up at the same result. Yet one
    might argue that the version that uses the directory is easier to read (different
    readers will have different opinions on this, and thatâ€™s fine). So which should
    we use?'
  prefs: []
  type: TYPE_NORMAL
- en: Use whichever makes more sense to you on a given problem. There will be times
    when we prefer each of these styles. Furthermore, it will turn out (once weâ€™ve
    learned more about nuances of how programs evaluate) that the two versions arenâ€™t
    as different as they appear right now.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.6.2Â Function Composition and the Directory[ðŸ”—](#(part._func-comp-directory)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Letâ€™s try one more variation on this problem. Perhaps seeing us name the intermediate
    result of `pen-cost` made you wish that we had used intermediate names to make
    the body of `pen-cost` more readable. For example, we could have written it as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]total cost for pens, each 25 cents'
  prefs: []
  type: TYPE_NORMAL
- en: plus 2 cents per message character[PRE65]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write out the high level steps for how Pyret will evaluate the following program
    using this new version of `pen-cost`:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: Hopefully, you made two entries into the directory, one for `message-cost` inside
    the body of `pen-cost` and one for `pens` as we did earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Consider the following program. What result do you think Pyret should produce?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using the directory you envisioned for the previous activity, what answer do
    you think you will get?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Something odd is happening here. The new program tries to use `message-cost`
    to define `cheap-message`. But the name `message-cost` doesnâ€™t appear anywhere
    in the program, unless we peek inside the function bodies. But letting code peek
    inside function bodies doesnâ€™t make sense: you might not be able to see inside
    the functions (if they are defined in libraries, for example), so this program
    should report an error that `message-cost` is undefined.'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so thatâ€™s what should happen. But our discussion of the directory suggests
    that both `pens` and `message-cost` will be in the directory, meaning Pyret would
    be able to use `message-cost`. Whatâ€™s going on?
  prefs: []
  type: TYPE_NORMAL
- en: This example prompts us to explain one more nuance about the directory. Precisely
    to avoid problems like the one illustrated here (which should produce an error),
    directory entries made within a function are local (private) to the function body.
    When you call a function, Pyret sets up a local directory that other functions
    canâ€™t see. A function body can add or refer to names in either its local, private
    directory (as with `message-cost`) or the overall (global) directory (as with
    `pens`). But in no case can one function call peek inside the local directory
    for another function call. Once a function call completes, its local directory
    disappears (because nothing else would be able to use it anyway).
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.7Â Nested Conditionals[ðŸ”—](#(part._.Nested_.Conditionals) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We showed that the results in `if`-expressions are themselves expressions (such
    as `order-amt + 4` in the following function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The result expressions can be more complicated. In fact, they could be entire
    if-expressions!. To see an example of this, letâ€™s develop another function. This
    time, we want a function that will compute the cost of movie tickets. Letâ€™s start
    with a simple version in which tickets are `$10` apiece.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Now, letâ€™s augment the function with an extra parameter to indicate whether
    the purchaser is a senior citizen who is entitled to a discount. In such cases,
    we will reduce the overall price by `15%`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]Compute the price of tickets at $10 each with'
  prefs: []
  type: TYPE_NORMAL
- en: senior discount of 15%[PRE71]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There are a couple of things to notice here:'
  prefs: []
  type: TYPE_NORMAL
- en: The function now has an additional parameter of type `Boolean` to indicate whether
    the purchaser is a senior citizen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have added an `if` expression to check whether to apply the discount.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have more examples, because we have to vary both the number of tickets and
    whether a discount applies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, letâ€™s extend the program once more, this time also offering the discount
    if the purchaser is not a senior but has bought more than 5 tickets. Where should
    we modify the code to do this? One option is to first check whether the senior
    discount applies. If not, we check whether the number of tickets qualifies for
    a discount:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]Compute the price of tickets at $10 each with'
  prefs: []
  type: TYPE_NORMAL
- en: discount of 15% for more than 5 tickets
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: or being a senior[PRE73]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice here that we have put a second `if` expression within the `else` case.
    This is valid code. (We could have also made an `else if` here, but we didnâ€™t
    so that we could show that nested conditionals are also valid).
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show the steps through which this function would evaluate in a situation where
    no discount applies, such as `buy-tickets3(2, false)`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Look at the current code: do you see a repeated computation that we might end
    up having to modify later?'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Part of good code style is making sure that our programs would be easy to maintain
    later. If the theater changes its discount policy, for example, the current code
    would require us to change the discount (`0.85`) in two places. It would be much
    better to have that computation written only one time. We can achieve that by
    asking which conditions lead to the discount applying, and writing them as the
    check within just one `if` expression.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Under what conditions should the discount apply?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here, we see that the discount applies if either the purchaser is a senior
    or more than 5 tickets have been bought. We can therefore simplify the code by
    using `or` as follows (weâ€™ve left out the examples because they havenâ€™t changed
    from the previous version):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]Compute the price of tickets at $10 each with'
  prefs: []
  type: TYPE_NORMAL
- en: discount of 15% for more than 5 tickets
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: or being a senior[PRE75]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This code is much tighter, and all of the cases where the discount applies are
    described together in one place. There are still two small changes we want to
    make to really clean this up though.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Take a look at the expression `is-senior == true`. What will this evaluate to
    when the value of `is-senior` is `true`? What will it evaluate to when the value
    of `is-senior` is `false`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Notice that the `== true` part is redundant. Since `is-senior` is already a
    boolean, we can check its value without using the `==` operator. Hereâ€™s the revised
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]Compute the price of tickets at $10 each with'
  prefs: []
  type: TYPE_NORMAL
- en: discount of 15% for more than 5 tickets
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: or being a senior[PRE77]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice the revised question in the `if` expression. As a general rule, your
    code should never include `== true`. You can always take that out and just use
    the expression you were comparing to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you write to eliminate `== false`? For example, what might you write
    instead of `is-senior == false`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Finally, notice that we still have one repeated computation: the base cost
    of the tickets (`count * 10`): if the ticket price changes, it would be better
    to have only one place to update that price. We can clean that up by first computing
    the base price, then applying the discount when appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]Compute the price of tickets at $10 each with'
  prefs: []
  type: TYPE_NORMAL
- en: discount of 15% for more than 5 tickets
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: or being a senior[PRE79]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.4.8Â Recap: Booleans and Conditionals[ðŸ”—](#(part._.Recap__.Booleans_and_.Conditionals)
    "Link to here")'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With this chapter, our computations can produce different results in different
    situations. We ask questions using if-expressions, in which each question or check
    uses an operator that produces a boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two Boolean values: `true` and `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple kind of check (that produces a boolean) compares values for equality
    (`==`) or inequality(`<>`). Other operations that you know from math, like `<`
    and `>=`, also produce booleans.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can build larger expressions that produce booleans from smaller ones using
    the operators `and`, `or`, `not`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use `if` expressions to ask true/false questions within a computation,
    producing different results in each case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can nest conditionals inside one another if needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You never need to use `==` to compare a value to `true` or `false`: you can
    just write the value or expression on its own (perhaps with `not` to get the same
    computation).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3.4.1Â Motivating Example: Shipping Costs[ðŸ”—](#(part._add-shipping-setup) "Link
    to here")'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [Functions Practice: Cost of pens](From_Repeated_Expressions_to_Functions.html#%28part._pen-cost-pyret%29),
    we wrote a program (`pen-cost`) to compute the cost of ordering pens. Continuing
    the example, we now want to account for shipping costs. Weâ€™ll determine shipping
    charges based on the cost of the order.'
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we will write a function `add-shipping` to compute the total cost
    of an order including shipping. Assume an order valued at $10 or less ships for
    $4, while an order valued above $10 ships for $8\. As usual, we will start by
    writing examples of the `add-shipping` computation.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the `is` notation from `where` blocks to write several examples of add-shipping.
    How are you choosing which inputs to use in your examples? Are you picking random
    inputs? Being strategic in some way? If so, whatâ€™s your strategy?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Here is a proposed collection of examples for `add-shipping`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you notice about our examples? What strategies do you observe across
    our choices?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Our proposed examples feature several strategic decisions:'
  prefs: []
  type: TYPE_NORMAL
- en: Including `10`, which is at the boundary of charges based on the text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including `10.01`, which is just over the boundary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including both natural and real (decimal) numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including examples that should result in each shipping charge mentioned in the
    problem (`4` and `8`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So far, we have used a simple rule for creating a function body from examples:
    locate the parts that are changing, replace them with names, then make the names
    the parameters to the function.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is changing across our `add-shipping` examples? Do you notice anything
    different about these changes compared to the examples for our previous functions?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Two things are new in this set of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: The values of `4` and `8` differ across the examples, but they each occur in
    multiple examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The values of `4` and `8` appear only in the computed answersâ€”<wbr>not as an
    input. Which one we use seems to depend on the input value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two observations suggest that something new is going on with `add-shipping`.
    In particular, we have clusters of examples that share a fixed value (the shipping
    charge), but different clusters (a) use different values and (b) have a pattern
    to their inputs (whether the input value is less than or equal to `10`). This
    calls for being able to ask questions about inputs within our programs.
  prefs: []
  type: TYPE_NORMAL
- en: '3.4.2Â Conditionals: Computations with Decisions[ðŸ”—](#(part._cond-boolean-intro)
    "Link to here")'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To ask a question about our inputs, we use a new kind of expression called
    an if expression. Hereâ€™s the full definition of `add-shipping`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: In an `if` expression, we ask a question that can produce an answer that is
    true or false (here `order-amt <= 10`, which weâ€™ll explain below in [Booleans](#%28part._booleans%29)),
    provide one expression for when the answer to the question is true (`order-amt
    + 4`), and another for when the result is false (`order-amt + 8`). The `else`
    in the program marks the answer in the false case; we call this the else clause.
    We also need `end` to tell Pyret weâ€™re done with the question and answers.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.3Â Booleans[ðŸ”—](#(part._booleans) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Every expression in Pyret evaluates in a value. So far, we have seen three
    types of values: `Number`, `String`, and `Image`. What type of value does a question
    like `order-amt <= 10` produce? We can use the interactions prompt to experiment
    and find out.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Enter each of the following expressions at the interactions prompt. What type
    of value did you get? Do the values fit the types we have seen so far?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: 'The values `true` and `false` belong to a new type in Pyret, called `Boolean`.Named
    for [George Boole](https://en.wikipedia.org/wiki/George_Boole). While there are
    an infinitely many values of type `Number`, there are only two of type `Boolean`:
    `true` and `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What would happen if we entered `order-amt <= 10` at the interactions prompt
    to explore booleans? Why does that happen?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 3.4.3.1Â Other Boolean Operations[ðŸ”—](#(part._bool-comparisons) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There are many other built-in operations that return `Boolean` values. Comparing
    values for equality is a common one: There is much more we can and should say
    about equality, which we will do later [[Re-Examining Equality](Sharing_and_Equality.html#%28part._identical-eq%29)].'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: In general, `==` checks whether two values are equal. Note this is different
    from the single `=` used to associate names with values in the directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last example is the most interesting: it illustrates that strings are case-sensitive,
    meaning individual letters must match in their case for strings to be considered
    equal.This will become relevant when we get to tables later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we also want to compare strings to determine their alphabetical
    order. Here are several examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'which is the alphabetical order weâ€™re used to; but others need some explaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'These use a convention laid down a long time ago in a system called [ASCII](https://en.wikipedia.org/wiki/ASCII).Things
    get far more complicated with non-ASCII letters: e.g., Pyret thinks `"Å"` is `>`
    than `"Z"`, but in Polish, this should be `false`. Worse, the ordering [depends
    on location](https://en.wikipedia.org/wiki/Alphabetical_order) (e.g., Denmark/Norway
    vs. Finland/Sweden).'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can you compare `true` and `false`? Try comparing them for equality (`==`),
    then for inequality (such as `<`).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In general, you can compare any two values for equality (well, almost, weâ€™ll
    come back to this later); for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to compare values of a specific kind, you can use more specific
    operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Why use these operators instead of the more generic `==`?
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: Therefore, itâ€™s wise to use the type-specific operators where youâ€™re expecting
    the two arguments to be of the same type. Then, Pyret will signal an error if
    you go wrong, instead of blindly returning an answer (`false`) which lets your
    program continue to compute a nonsensical value.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are even more Boolean-producing operators, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Note the capital `W`.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, just about every kind of data will have some Boolean-valued operators
    to enable comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.3.2Â Combining Booleans[ðŸ”—](#(part._.Combining_.Booleans) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, we want to base decisions on more than one Boolean value. For instance,
    you are allowed to vote if youâ€™re a citizen of a country and you are above a certain
    age. Youâ€™re allowed to board a bus if you have a ticket or the bus is having a
    free-ride day. We can even combine conditions: youâ€™re allowed to drive if you
    are above a certain age and have good eyesight andâ€”<wbr>either pass a test or
    have a temporary license. Also, youâ€™re allowed to drive if you are not inebriated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Corresponding to these forms of combinations, Pyret offers three main operations:
    `and`, `or`, and `not`. Here are some examples of their use:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explain why numbers and strings are not good ways to express the answer to a
    true/false question.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 3.4.3.1Â Other Boolean Operations[ðŸ”—](#(part._bool-comparisons) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There are many other built-in operations that return `Boolean` values. Comparing
    values for equality is a common one: There is much more we can and should say
    about equality, which we will do later [[Re-Examining Equality](Sharing_and_Equality.html#%28part._identical-eq%29)].'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: In general, `==` checks whether two values are equal. Note this is different
    from the single `=` used to associate names with values in the directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last example is the most interesting: it illustrates that strings are case-sensitive,
    meaning individual letters must match in their case for strings to be considered
    equal.This will become relevant when we get to tables later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we also want to compare strings to determine their alphabetical
    order. Here are several examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'which is the alphabetical order weâ€™re used to; but others need some explaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'These use a convention laid down a long time ago in a system called [ASCII](https://en.wikipedia.org/wiki/ASCII).Things
    get far more complicated with non-ASCII letters: e.g., Pyret thinks `"Å"` is `>`
    than `"Z"`, but in Polish, this should be `false`. Worse, the ordering [depends
    on location](https://en.wikipedia.org/wiki/Alphabetical_order) (e.g., Denmark/Norway
    vs. Finland/Sweden).'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can you compare `true` and `false`? Try comparing them for equality (`==`),
    then for inequality (such as `<`).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In general, you can compare any two values for equality (well, almost, weâ€™ll
    come back to this later); for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to compare values of a specific kind, you can use more specific
    operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Why use these operators instead of the more generic `==`?
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: Therefore, itâ€™s wise to use the type-specific operators where youâ€™re expecting
    the two arguments to be of the same type. Then, Pyret will signal an error if
    you go wrong, instead of blindly returning an answer (`false`) which lets your
    program continue to compute a nonsensical value.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are even more Boolean-producing operators, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Note the capital `W`.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, just about every kind of data will have some Boolean-valued operators
    to enable comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.3.2Â Combining Booleans[ðŸ”—](#(part._.Combining_.Booleans) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, we want to base decisions on more than one Boolean value. For instance,
    you are allowed to vote if youâ€™re a citizen of a country and you are above a certain
    age. Youâ€™re allowed to board a bus if you have a ticket or the bus is having a
    free-ride day. We can even combine conditions: youâ€™re allowed to drive if you
    are above a certain age and have good eyesight andâ€”<wbr>either pass a test or
    have a temporary license. Also, youâ€™re allowed to drive if you are not inebriated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Corresponding to these forms of combinations, Pyret offers three main operations:
    `and`, `or`, and `not`. Here are some examples of their use:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explain why numbers and strings are not good ways to express the answer to a
    true/false question.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 3.4.4Â Asking Multiple Questions[ðŸ”—](#(part._else-if) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Shipping costs are rising, so we want to modify the `add-shipping` program
    to include a third shipping level: orders between $10 and $30 ship for $8, but
    orders over $30 ship for $12\. This calls for two modifications to our program:'
  prefs: []
  type: TYPE_NORMAL
- en: We have to be able to ask another question to distinguish situations in which
    the shipping charge is `8` from those in which the shipping charge is `12`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The question for when the shipping charge is `8` will need to check whether
    the input is between two values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weâ€™ll handle these in order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current body of `add-shipping` asks one question: `order-amt <= 10`. We
    need to add another one for `order-amt <= 30`, using a charge of `12` if that
    question fails. Where do we put that additional question?'
  prefs: []
  type: TYPE_NORMAL
- en: 'An expanded version of the if-expression, using `else if`, allows you to ask
    multiple questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you should also add `where` examples that use the `12` charge.
  prefs: []
  type: TYPE_NORMAL
- en: How does Pyret determine which answer to return? It evaluates each question
    expression in order, starting from the one that follows `if`. It continues through
    the questions, returning the value of the answer of the first question that returns
    true. Hereâ€™s a summary of the if-expression syntax and how it evaluates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: A program can have multiple `else if` cases, thus accommodating an arbitrary
    number of questions within a program.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The problem description for `add-shipping` said that orders between `10` and
    `30` should incur an `8` charge. How does the above code capture â€œbetweenâ€?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is currently entirely implicit. It depends on us understanding the way
    an `if` evaluates. The first question is `order-amt <= 10`, so if we continue
    to the second question, it means `order-amt > 10`. In this context, the second
    question asks whether `order-amt <= 30`. Thatâ€™s how weâ€™re capturing â€œbetweenâ€-ness.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How might you modify the above code to build the â€œbetween 10 and 30â€ requirement
    explicitly into the question for the `8` case?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Remember the `and` operator on booleans? We can use that to capture â€œbetweenâ€
    relationships, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why are there parentheses around the two comparisons? If you replace `order-amt`
    with a concrete value (such as `20`) and leave off the parenthesis, what happens
    when you evaluate this expression in the interactions pane?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here is what `add-shipping` look like with the `and` included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Both versions of `add-shipping` support the same examples. Are both correct?
    Yes. And while the first part of the second question (`order-amt > 10`) is redundant,
    it can be helpful to include such conditions for three reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: They signal to future readers (including ourselves!) the condition covering
    a case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They ensure that if we make a mistake in writing an earlier question, we wonâ€™t
    silently get surprising output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They guard against future modifications, where someone might modify an earlier
    question without realizing the impact itâ€™s having on a later one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An online-advertising firm needs to determine whether to show an ad for a skateboarding
    park to website users. Write a function `show-ad` that takes the age and haircolor
    of an individual user and returns `true` if the user is between the ages of `9`
    and `18` and has either pink or purple hair.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Try writing this two ways: once with `if` expressions and once using just boolean
    operations.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Responsible Computing: Harms from Reducing People to Simple Data'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Assumptions about users get encoded in even the simplest functions. The advertising
    exercise shows an example in which a decision gets made on the basis of two pieces
    of information about a person: age and haircolor. While some people might stereotypically
    associate skateborders with being young and having colored hair, many skateborders
    do not fit these criteria and many people who fit these criteria donâ€™t skateboard.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'While real programs to match ads to users are more sophisticated than this
    simple function, even the most sophisticated advertising programs boil down to
    tracking features or information about individuals and comparing it to information
    about the content of ads. A real ad system would differ in tracking dozens (or
    more) of features and using more advanced programming ideas than simple conditionals
    to determine the suitability of an ad (weâ€™ll discuss some of these later in the
    book). This example also extends to situations far more serious than ads: who
    gets hired, granted a bank loan, or [sent to or released from jail](https://www.propublica.org/article/machine-bias-risk-assessments-in-criminal-sentencing)
    are other examples of real systems that depend on comparing data about individuals
    with criteria maintained by a program.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: From a social responsibility perspective, the questions here are what data about
    individuals should be used to represent them for processing by programs and what
    stereotypes might those data encode. In some cases, individuals can be represented
    by data without harm (a university housing office, for examples, stores student
    ID numbers and which room a student is living in). But in other cases, data about
    individuals get interpreted in order to predict something about them. Decisions
    based on those predictions can be inaccurate and hence harmful.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 3.4.5Â Evaluating by Reducing Expressions[ðŸ”—](#(part._conditional-nm) "Link to
    here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [How Functions Evaluate](From_Repeated_Expressions_to_Functions.html#%28part._function-call-nm%29),
    we talked about how Pyret reduces expressions and function calls to values. Letâ€™s
    revisit this process, this time expanding to consider if-expressions. Suppose
    we want to compute the wages of a worker. The worker is paid $10 for every hour
    up to the first 40 hours, and is paid $15 for every extra hour. Letâ€™s say `hours`
    contains the number of hours they work, and suppose itâ€™s `45`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Suppose the formula for computing the wage is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'Letâ€™s now see how this results in an answer, using a step-by-step process that
    should match what youâ€™ve seen in algebra classes (the steps are described in the
    margin notes to the right): The first step is to substitute the `hours` with `45`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Next, the conditional part of the `if` expression is evaluated, which in this
    case is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Since the condition is `false`, the next branch is tried.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Pyret evaluates the question in the conditional, which in this case produces
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Since the condition is `true`, the expression reduces to the body of that branch.
    After that, itâ€™s just arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: This style of reduction is the best way to think about the evaluation of Pyret
    expressions. The whole expression takes steps that simplify it, proceeding by
    simple rules. You can use this style yourself if you want to try and work through
    the evaluation of a Pyret program by hand (or in your head).
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.6Â Composing Functions[ðŸ”—](#(part._.Composing_.Functions) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We started this chapter wanting to account for shipping costs on an order of
    pens. So far, we have written two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pen-cost` for computing the cost of the pens'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add-shipping` for adding shipping costs to a total amount'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What if we now wanted to compute the price of an order of pens including shipping?
    We would have to use both of these functions together, sending the output of `pen-cost`
    to the input of `add-shipping`.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write an expression that computes the total cost, with shipping, of an order
    of `10` pens that say `"bravo"`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'There are two ways to structure this computation. We could pass the result
    of `pen-cost` directly to `add-shipping`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you might have named the result of `pen-cost` as an intermediate
    step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: Both methods would produce the same answer.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.6.1Â How Function Compositions Evaluate[ðŸ”—](#(part._.How_.Function_.Compositions_.Evaluate)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Letâ€™s review how these programs evaluate in the context of substitution and
    the directory. Weâ€™ll start with the second version, in which we explicitly name
    the result of calling `pen-cost`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Evaluating the second version: At a high level, Pyret goes through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Substitute `10` for `num-pens` and `"bravo"` for `message` in the body of `pen-cost`,
    then evaluate the substituted body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store `pens` in the directory, with a value of `3.5`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a first step in evaluating `add-shipping(pens)`, look up the value of `pens`
    in the directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Substitute `3.5` for `order-amt` in the body of `add-shipping` then evaluate
    the resulting expression, which results in `7.5`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Evaluating the first version: As a reminder, the first version consisted of
    a single expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Since arguments are evaluated before functions get called, start by evaluating
    `pen-cost(10, "bravo")` (again using substitution), which reduces to `3.5`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Substitute `3.5` for `order-amt` in the body of `add-shipping` then evaluate
    the resulting expression, which results in `7.5`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Contrast these two summaries. Where do they differ? What aspects of the code
    led to those differences?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The difference lies in the use of the directory: the version that explicitly
    named `pens` uses the directory. The other version doesnâ€™t use the directory at
    all. Yet both approaches lead to the same result, since the same value (the result
    of calling `pen-cost`) gets substituted into the body of `add-shipping`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This analysis might suggest that the version that uses the directory is somehow
    wasteful: it seems to take more steps just to end up at the same result. Yet one
    might argue that the version that uses the directory is easier to read (different
    readers will have different opinions on this, and thatâ€™s fine). So which should
    we use?'
  prefs: []
  type: TYPE_NORMAL
- en: Use whichever makes more sense to you on a given problem. There will be times
    when we prefer each of these styles. Furthermore, it will turn out (once weâ€™ve
    learned more about nuances of how programs evaluate) that the two versions arenâ€™t
    as different as they appear right now.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.6.2Â Function Composition and the Directory[ðŸ”—](#(part._func-comp-directory)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Letâ€™s try one more variation on this problem. Perhaps seeing us name the intermediate
    result of `pen-cost` made you wish that we had used intermediate names to make
    the body of `pen-cost` more readable. For example, we could have written it as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]total cost for pens, each 25 cents'
  prefs: []
  type: TYPE_NORMAL
- en: plus 2 cents per message character[PRE191]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write out the high level steps for how Pyret will evaluate the following program
    using this new version of `pen-cost`:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: Hopefully, you made two entries into the directory, one for `message-cost` inside
    the body of `pen-cost` and one for `pens` as we did earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Consider the following program. What result do you think Pyret should produce?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using the directory you envisioned for the previous activity, what answer do
    you think you will get?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Something odd is happening here. The new program tries to use `message-cost`
    to define `cheap-message`. But the name `message-cost` doesnâ€™t appear anywhere
    in the program, unless we peek inside the function bodies. But letting code peek
    inside function bodies doesnâ€™t make sense: you might not be able to see inside
    the functions (if they are defined in libraries, for example), so this program
    should report an error that `message-cost` is undefined.'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so thatâ€™s what should happen. But our discussion of the directory suggests
    that both `pens` and `message-cost` will be in the directory, meaning Pyret would
    be able to use `message-cost`. Whatâ€™s going on?
  prefs: []
  type: TYPE_NORMAL
- en: This example prompts us to explain one more nuance about the directory. Precisely
    to avoid problems like the one illustrated here (which should produce an error),
    directory entries made within a function are local (private) to the function body.
    When you call a function, Pyret sets up a local directory that other functions
    canâ€™t see. A function body can add or refer to names in either its local, private
    directory (as with `message-cost`) or the overall (global) directory (as with
    `pens`). But in no case can one function call peek inside the local directory
    for another function call. Once a function call completes, its local directory
    disappears (because nothing else would be able to use it anyway).
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.6.1Â How Function Compositions Evaluate[ðŸ”—](#(part._.How_.Function_.Compositions_.Evaluate)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Letâ€™s review how these programs evaluate in the context of substitution and
    the directory. Weâ€™ll start with the second version, in which we explicitly name
    the result of calling `pen-cost`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Evaluating the second version: At a high level, Pyret goes through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Substitute `10` for `num-pens` and `"bravo"` for `message` in the body of `pen-cost`,
    then evaluate the substituted body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store `pens` in the directory, with a value of `3.5`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a first step in evaluating `add-shipping(pens)`, look up the value of `pens`
    in the directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Substitute `3.5` for `order-amt` in the body of `add-shipping` then evaluate
    the resulting expression, which results in `7.5`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Evaluating the first version: As a reminder, the first version consisted of
    a single expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: Since arguments are evaluated before functions get called, start by evaluating
    `pen-cost(10, "bravo")` (again using substitution), which reduces to `3.5`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Substitute `3.5` for `order-amt` in the body of `add-shipping` then evaluate
    the resulting expression, which results in `7.5`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Contrast these two summaries. Where do they differ? What aspects of the code
    led to those differences?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The difference lies in the use of the directory: the version that explicitly
    named `pens` uses the directory. The other version doesnâ€™t use the directory at
    all. Yet both approaches lead to the same result, since the same value (the result
    of calling `pen-cost`) gets substituted into the body of `add-shipping`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This analysis might suggest that the version that uses the directory is somehow
    wasteful: it seems to take more steps just to end up at the same result. Yet one
    might argue that the version that uses the directory is easier to read (different
    readers will have different opinions on this, and thatâ€™s fine). So which should
    we use?'
  prefs: []
  type: TYPE_NORMAL
- en: Use whichever makes more sense to you on a given problem. There will be times
    when we prefer each of these styles. Furthermore, it will turn out (once weâ€™ve
    learned more about nuances of how programs evaluate) that the two versions arenâ€™t
    as different as they appear right now.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.6.2Â Function Composition and the Directory[ðŸ”—](#(part._func-comp-directory)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Letâ€™s try one more variation on this problem. Perhaps seeing us name the intermediate
    result of `pen-cost` made you wish that we had used intermediate names to make
    the body of `pen-cost` more readable. For example, we could have written it as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]total cost for pens, each 25 cents'
  prefs: []
  type: TYPE_NORMAL
- en: plus 2 cents per message character[PRE196]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write out the high level steps for how Pyret will evaluate the following program
    using this new version of `pen-cost`:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: Hopefully, you made two entries into the directory, one for `message-cost` inside
    the body of `pen-cost` and one for `pens` as we did earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Consider the following program. What result do you think Pyret should produce?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using the directory you envisioned for the previous activity, what answer do
    you think you will get?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Something odd is happening here. The new program tries to use `message-cost`
    to define `cheap-message`. But the name `message-cost` doesnâ€™t appear anywhere
    in the program, unless we peek inside the function bodies. But letting code peek
    inside function bodies doesnâ€™t make sense: you might not be able to see inside
    the functions (if they are defined in libraries, for example), so this program
    should report an error that `message-cost` is undefined.'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so thatâ€™s what should happen. But our discussion of the directory suggests
    that both `pens` and `message-cost` will be in the directory, meaning Pyret would
    be able to use `message-cost`. Whatâ€™s going on?
  prefs: []
  type: TYPE_NORMAL
- en: This example prompts us to explain one more nuance about the directory. Precisely
    to avoid problems like the one illustrated here (which should produce an error),
    directory entries made within a function are local (private) to the function body.
    When you call a function, Pyret sets up a local directory that other functions
    canâ€™t see. A function body can add or refer to names in either its local, private
    directory (as with `message-cost`) or the overall (global) directory (as with
    `pens`). But in no case can one function call peek inside the local directory
    for another function call. Once a function call completes, its local directory
    disappears (because nothing else would be able to use it anyway).
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.7Â Nested Conditionals[ðŸ”—](#(part._.Nested_.Conditionals) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We showed that the results in `if`-expressions are themselves expressions (such
    as `order-amt + 4` in the following function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: The result expressions can be more complicated. In fact, they could be entire
    if-expressions!. To see an example of this, letâ€™s develop another function. This
    time, we want a function that will compute the cost of movie tickets. Letâ€™s start
    with a simple version in which tickets are `$10` apiece.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: Now, letâ€™s augment the function with an extra parameter to indicate whether
    the purchaser is a senior citizen who is entitled to a discount. In such cases,
    we will reduce the overall price by `15%`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]Compute the price of tickets at $10 each with'
  prefs: []
  type: TYPE_NORMAL
- en: senior discount of 15%[PRE202]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There are a couple of things to notice here:'
  prefs: []
  type: TYPE_NORMAL
- en: The function now has an additional parameter of type `Boolean` to indicate whether
    the purchaser is a senior citizen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have added an `if` expression to check whether to apply the discount.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have more examples, because we have to vary both the number of tickets and
    whether a discount applies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, letâ€™s extend the program once more, this time also offering the discount
    if the purchaser is not a senior but has bought more than 5 tickets. Where should
    we modify the code to do this? One option is to first check whether the senior
    discount applies. If not, we check whether the number of tickets qualifies for
    a discount:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]Compute the price of tickets at $10 each with'
  prefs: []
  type: TYPE_NORMAL
- en: discount of 15% for more than 5 tickets
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: or being a senior[PRE204]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice here that we have put a second `if` expression within the `else` case.
    This is valid code. (We could have also made an `else if` here, but we didnâ€™t
    so that we could show that nested conditionals are also valid).
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show the steps through which this function would evaluate in a situation where
    no discount applies, such as `buy-tickets3(2, false)`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Look at the current code: do you see a repeated computation that we might end
    up having to modify later?'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Part of good code style is making sure that our programs would be easy to maintain
    later. If the theater changes its discount policy, for example, the current code
    would require us to change the discount (`0.85`) in two places. It would be much
    better to have that computation written only one time. We can achieve that by
    asking which conditions lead to the discount applying, and writing them as the
    check within just one `if` expression.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Under what conditions should the discount apply?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here, we see that the discount applies if either the purchaser is a senior
    or more than 5 tickets have been bought. We can therefore simplify the code by
    using `or` as follows (weâ€™ve left out the examples because they havenâ€™t changed
    from the previous version):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]Compute the price of tickets at $10 each with'
  prefs: []
  type: TYPE_NORMAL
- en: discount of 15% for more than 5 tickets
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: or being a senior[PRE206]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This code is much tighter, and all of the cases where the discount applies are
    described together in one place. There are still two small changes we want to
    make to really clean this up though.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Take a look at the expression `is-senior == true`. What will this evaluate to
    when the value of `is-senior` is `true`? What will it evaluate to when the value
    of `is-senior` is `false`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Notice that the `== true` part is redundant. Since `is-senior` is already a
    boolean, we can check its value without using the `==` operator. Hereâ€™s the revised
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]Compute the price of tickets at $10 each with'
  prefs: []
  type: TYPE_NORMAL
- en: discount of 15% for more than 5 tickets
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: or being a senior[PRE208]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice the revised question in the `if` expression. As a general rule, your
    code should never include `== true`. You can always take that out and just use
    the expression you were comparing to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you write to eliminate `== false`? For example, what might you write
    instead of `is-senior == false`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Finally, notice that we still have one repeated computation: the base cost
    of the tickets (`count * 10`): if the ticket price changes, it would be better
    to have only one place to update that price. We can clean that up by first computing
    the base price, then applying the discount when appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]Compute the price of tickets at $10 each with'
  prefs: []
  type: TYPE_NORMAL
- en: discount of 15% for more than 5 tickets
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: or being a senior[PRE210]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.4.8Â Recap: Booleans and Conditionals[ðŸ”—](#(part._.Recap__.Booleans_and_.Conditionals)
    "Link to here")'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With this chapter, our computations can produce different results in different
    situations. We ask questions using if-expressions, in which each question or check
    uses an operator that produces a boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two Boolean values: `true` and `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple kind of check (that produces a boolean) compares values for equality
    (`==`) or inequality(`<>`). Other operations that you know from math, like `<`
    and `>=`, also produce booleans.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can build larger expressions that produce booleans from smaller ones using
    the operators `and`, `or`, `not`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use `if` expressions to ask true/false questions within a computation,
    producing different results in each case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can nest conditionals inside one another if needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You never need to use `==` to compare a value to `true` or `false`: you can
    just write the value or expression on its own (perhaps with `not` to get the same
    computation).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
