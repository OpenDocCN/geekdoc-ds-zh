<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>23Â Partial DomainsğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>23Â Partial DomainsğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/partial-domains.html">https://dcic-world.org/2025-08-27/partial-domains.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._pd-sentinel%29" class="toclink" data-pltdoc="x">23.1Â A Non-Solution</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._pd-exceptions%29" class="toclink" data-pltdoc="x">23.2Â Exceptions</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._pd-option%29" class="toclink" data-pltdoc="x">23.3Â The Option Type</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._pd-total-dyn%29" class="toclink" data-pltdoc="x">23.4Â Total Domains, Dynamically</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._pd-total-static%29" class="toclink" data-pltdoc="x">23.5Â Total Domains, Statically</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._pd-summary%29" class="toclink" data-pltdoc="x">23.6Â Summary</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._pd-pyret-list-constr%29" class="toclink" data-pltdoc="x">23.7Â A Note on Notation</a></p></td></tr></table><p>Sometimes, we cannot precisely capture the domain of a function with the
precision we would like. In mathematics, if a function cannot accept all values
in its domain, it is called partial. This is a problem we encounter more
often than we might like in programming, so we need to know how to handle
it. There are actually several programming strategies that we can use, with
different benefits and weaknesses. Here, we will examine some of them.</p><p>Consider some functions on lists of numbers, such as computing the median or
the average. In both cases, these functions donâ€™t work on all lists of
numbers: there is no median for the empty list, and we canâ€™t compute its
average either, because there are no elements (so trying to compute the average
would result in a divison-by-zero error). Thus, while it is a convenient
fiction to write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">average :: List&lt;Number&gt; -&gt; Number</code></pre><p>it is just that: a (bit of a) fiction. The function is only defined on
non-empty lists.</p><p>We will now see how to handle this from a software engineering
perspective. Weâ€™ll specifically work through <code data-lang="pyret" class="sourceCode">average</code> because the function is
simple enough that we can focus on the software structure without getting lost
in the solution details. There are at least four solutions, and one
non-solution.</p><section class="SsectionLevel3" id="section 23.1"><h3 class="heading">23.1Â <a name="(part._pd-sentinel)"/>A Non-Solution<a href="#(part._pd-sentinel)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>We will start with a strategy that has often been used by programmers in the
past, but that we reject as a non-solution. This strategy is to make the above
contract absolutely correct by returning a value in the erroneous case;
this value is often called a sentinel. For instance, the sentinel might
be <code data-lang="pyret" class="sourceCode">0</code>. Here is the full program:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">type LoN = List&lt;Number&gt;

fun sum(l :: LoN) -&gt; Number:
  fold({(a, b): a + b}, 0, l)
end

avg0 :: LoN -&gt; Number

fun avg0(l):
  cases (List) l:
    | empty =&gt; 0
    | link(_, _) =&gt;
      s = sum(l)
      c = l.length()
      s / c
  end
end</code></pre><p>and here are a few tests:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg0([list: 1]) is 1
  avg0([list: 1, 2, 3]) is 2
  avg0([list: 1, 2, 3, 10]) is 4
end</code></pre><p>Is there a test missing here? Yes, for the empty list! Should we add it?
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg0(empty) is 0
end</code></pre><p>The question is, should we be happy with this â€œsolutionâ€? There are two
problems with it.</p><p>First, every single use of <code data-lang="pyret" class="sourceCode">avg0</code> needs to check for whether it got back
<code data-lang="pyret" class="sourceCode">0</code> or not. If it did not, then the answer is legitimate, and it can
proceed with the computation. But if it did, then it has to assume that the
input may have been illegitimate, and cannot use the answer.</p><p>Second, even thatâ€™s not quite true. To understand why, we need to write a few
more tests:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg0([list: -1, 0, 1]) is 0
  avg0([list: -5, 4, 1]) is 0
end</code></pre><p>So the problem is that when <code data-lang="pyret" class="sourceCode">avg0</code> returns <code data-lang="pyret" class="sourceCode">0</code>, we donâ€™t know whether
thatâ€™s a legitimate answer or a â€œfakeâ€ answer that stands for â€œthis
is not a valid inputâ€. So even our strategy of â€œcheck everywhereâ€ fails!</p><p>Ah, but maybe the problem is the use of <code data-lang="pyret" class="sourceCode">0</code>! Perhaps we could use a
different number that would work. How about <code data-lang="pyret" class="sourceCode">1</code>? Or <code data-lang="pyret" class="sourceCode">-1</code>? The
question is: Is there any number that reasonably canâ€™t be the
average of an actual input? (And in general, for all problems, can you be sure
of this?) Well, of course not.</p><p>Thatâ€™s why this is a non-solution. It has created several problems:
</p><ul><li><p>We canâ€™t tell from the output whether the input was invalid.</p></li><li><p>That means every caller needs to check.</p></li><li><p>A caller that forgets to check may compute with nonsense.</p></li><li><p>Compositionality is ruined: any function passed <code data-lang="pyret" class="sourceCode">average</code> needs to
know to check the output (and there is nothing in the contract to warn it!).</p></li></ul><p>Indeed, decades of experience tells us that some of the worldâ€™s most
sophisticated programmers have not been able to handle this issue even when it
matters most, resulting in numerous, pernicious security problems. Therefore,
we should now regard this as a flawed approach to software construction, and
never do it ourselves.</p><p>Letâ€™s instead look at four actual solutions.</p></section><section class="SsectionLevel3" id="section 23.2"><h3 class="heading">23.2Â <a name="(part._pd-exceptions)"/>Exceptions<a href="#(part._pd-exceptions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>One technique that many languages, including Pyret, provide is called the
exception. An exception is a special programming construct that
effectively halts the computation because the program cannot figure out how to
continue computing with the data it has. There are more sophisticated forms of
exceptions in some languages, but here we focus simply on using them as a
strategy for handling partiality.</p><p>Here is the average program written using an exception (we reuse <code data-lang="pyret" class="sourceCode">sum</code>
from before):
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg1 :: LoN -&gt; Number

fun avg1(l):
  cases (List) l:
    | empty =&gt; raise("no average for empty list")
    | link(_, _) =&gt;
      s = sum(l)
      c = l.length()
      s / c
  end
end

check:
  avg1([list: 1]) is 1
  avg1([list: 1, 2, 3]) is 2
  avg1([list: 1, 2, 3, 10]) is 4
end</code></pre><p>The way <code data-lang="pyret" class="sourceCode">raise</code> works is that it terminates everything that is waiting to
happen. For instance, if we were to write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1 + avg1(empty)</code></pre><p>the <code data-lang="pyret" class="sourceCode">1 + â€¦</code> part never happens: the whole computation ends. <code data-lang="pyret" class="sourceCode">raise</code>
creates exceptions.</p><p>Again, weâ€™re missing a test. How do we write it?
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg1(empty) raises "no average for empty list"
end</code></pre><p>The <code data-lang="pyret" class="sourceCode">raises</code> form takes a string that it matches against that provided to
<code data-lang="pyret" class="sourceCode">raise</code>. In act, for convenience, any sub-string of the original string is
permitted: we can, for instance, also write
<code data-lang="pyret" class="sourceCode">check:
  avg1(empty) raises "no average"
  avg1(empty) raises "empty list"
end</code></p><p>In many programming languages, the use of exceptions is the standard way of
dealing with partiality. It is certainly a pragmatic solution. Observe that we
got to reuse <code data-lang="pyret" class="sourceCode">sum</code> from earlier; the contract looks clean; and we only
needed to use <code data-lang="pyret" class="sourceCode">raise</code> at the spot where we didnâ€™t know what to do. Whatâ€™s
not to like?</p><p>There are two main problems with exceptions:
</p><ol><li><p>In real systems, exceptions halt a programâ€™s execution in unpredictable
ways. A caller to <code data-lang="pyret" class="sourceCode">avg1</code> may be half-way through doing something else
(e.g., it may have opened a file that it intends to close), but the exception
causes the call to not finish cleanly, causing the remaining computation to not
run, leaving the system in a messy state.</p></li><li><p>Relatedly, what we presented as a feature should actually be treated as a
problem: the contract lies! Thereâ€™s no indication at all in the contract
that an exception might occur. A programmer has to read the whole
implementationâ€”<wbr/>which could change at any timeâ€”<wbr/>instead of being able to rely
on its published contract, when the whole point of contracts was that they
saved us from having to read the whole implementation!</p></li></ol><p>Indeed, some modern programming languages designed for large-scale programming
(such as Go and Rust) no longer have exception constructs. Therefore, you
should not assume that this will continue to be the â€œstandardâ€ way of doing
things in the future.</p><p>Observe that there is are two kinds of exceptions that can occur. One is
as weâ€™ve written above. The other is when we completely ignore (or forget to
even think about) the empty list case, and end up getting an error from Pyret,
which is also a kind of exception. If Pyret will raise an exception anyway,
does it make sense for us to go through the trouble of doing it ourselves?</p><p>Yes it does! For several reasons:
</p><ol><li><p>First, you get to control where the exception occurs and what it says.</p></li><li><p>You can document that the exception will occur.</p></li><li><p>You are less dependent on the behavior of Pyret or whatever underlying
programming language, which can change in subtle ways.</p></li><li><p>You can create an exception that is unique to you, so it canâ€™t be
confused with other division-by-zero errors that may lurk in your program.</p></li></ol><p>For these reasons, itâ€™s better to check and raise an exception explicitly
than letting it â€œfall throughâ€ to the programming language. Instead, the real
problems with this solution are subtler: the lying contract, and the impact on
program execution.</p></section><section class="SsectionLevel3" id="section 23.3"><h3 class="heading">23.3Â <a name="(part._pd-option)"/>The Option Type<a href="#(part._pd-option)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Letâ€™s revisit <code data-lang="pyret" class="sourceCode">avg0</code>. The problem with it was that it returned a value
that was not distinguishable from an actual answer. So perhaps another
approach is to return a value that is guaranteed to be distinguishable!
For this, a growing number of languages (including Pyret) have something like
this type:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Option&lt;T&gt;:
  | none
  | some(value :: T)
end</code></pre><p>This is a type we use when we arenâ€™t sure we will have an answer: <code data-lang="pyret" class="sourceCode">none</code>
means we donâ€™t have an answer, whereas <code data-lang="pyret" class="sourceCode">some</code> means we do and <code data-lang="pyret" class="sourceCode">value</code>
is that answer.</p><p>Hereâ€™s how our program now looks:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg2 :: LoN -&gt; Option&lt;Number&gt;

fun avg2(l):
  cases (List) l:
    | empty =&gt; none
    | link(_, _) =&gt;
      s = sum(l)
      c = l.length()
      some(s / c)
  end
end</code></pre><p>Now our tests look a bit different:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg2([list: 1]) is some(1)
  avg2([list: 1, 2, 3]) is some(2)
  avg2([list: 1, 2, 3, 10]) is some(4)
end

check:
  avg2(empty) is none
end</code></pre><p>The good news is, the contract is now truthful. Just by looking at it, we are
reminded that <code data-lang="pyret" class="sourceCode">avg0</code> may not always be able to compute an answer.</p><p>Unfortunately, this imposes some cost on every user: they have to use
<code data-lang="pyret" class="sourceCode">cases</code> to check return values and only use them if they are
legitimate. However, this is the same thing we expected in <code data-lang="pyret" class="sourceCode">avg0</code>â€”<wbr/>except
we lacked a discipline for making sure we didnâ€™t abuse that value! So this is
<code data-lang="pyret" class="sourceCode">avg0</code> done in a principled way.</p></section><section class="SsectionLevel3" id="section 23.4"><h3 class="heading">23.4Â <a name="(part._pd-total-dyn)"/>Total Domains, Dynamically<a href="#(part._pd-total-dyn)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>All these problems arise because we said that <code data-lang="pyret" class="sourceCode">average</code> (like
<code data-lang="pyret" class="sourceCode">median</code>) is partial. However, itâ€™s only partial if we give the domain as
<code data-lang="pyret" class="sourceCode">List&lt;Number&gt;</code>; itâ€™s actually a total function on the <code data-lang="pyret" class="sourceCode">non-empty</code>
list of numbers. But how do we represent that?</p><p>In some languages, like Pyret, we can actually express this directly:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">type NeLoND = List&lt;Number&gt;%(is-link)</code></pre><p>This says that weâ€™re refining numeric lists to always have a <code data-lang="pyret" class="sourceCode">link</code>,
i.e., to be non-empty. In Pyret, currently, this check is only done at
run-time; in some other programming languages, this can be done by the
type-checker itself.</p><p>This refinement lets us pretend that weâ€™re dealing with regular lists and reuse
all existing list code, while knowing for sure we will never get a
divide-by-zero error:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg3 :: NeLoND -&gt; Number

fun avg3(l):
  s = sum(l)
  c = l.length()
  s / c
end

check:
  avg3([list: 1]) is 1
  avg3([list: 1, 2, 3]) is 2
  avg3([list: 1, 2, 3, 10]) is 4
end</code></pre><p>If we do try passing an empty list, we get an internal exception:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg3(empty) raises ""
end</code></pre><p>This is a pretty interesting solution. Our functionâ€™s code is clean. We donâ€™t
deal with nonsensical values. The interface is truthful! (However, it does require a
careful reading to observe that thereâ€™s an exception lurking underneath the
domain.) And it lets us reuse existing code.</p><p>There are two main weaknesses:
</p><ol><li><p>Dynamic refinements arenâ€™t found in most
languages, so weâ€™d have to do more manual work to obtain the same
solution.</p></li><li><p>We donâ€™t get a static guarantee (i.e., before even running the program)
that weâ€™ll never get an exception.</p></li></ol></section><section class="SsectionLevel3" id="section 23.5"><h3 class="heading">23.5Â <a name="(part._pd-total-static)"/>Total Domains, Statically<a href="#(part._pd-total-static)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>How do we make the function total with a static guarantee? That would require
that we ensure that we can never construct an empty list! Obviously, this is
not possible with the existing lists in Pyret. However, we can construct a new
list-like datatype that â€œbottoms outâ€ not at empty lists but at lists of one
element:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data NeLoN:
  | one(n :: Number)
  | more(n :: Number, r :: NeLoN)
end</code></pre><p>Observe that there is simply no way to make an empty list: the smallest list
has one element in it. Furthermore, our type checker enforces this for us.</p><p>Of course, this is an entirely different datatype than a list of numbers. We
canâ€™t, for instance, use the existing <code data-lang="pyret" class="sourceCode">sum</code> or <code data-lang="pyret" class="sourceCode">length</code> code on
it. However, one option is to convert a <code data-lang="pyret" class="sourceCode">NeLoN</code> into a <code data-lang="pyret" class="sourceCode">LoN</code>, which
is always safe, and reuse that code:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun nelon-to-lon(nl :: NeLoN):
  cases (NeLoN) nl:
    | one(n) =&gt; [list: n]
    | more(n, r) =&gt; link(n, nelon-to-lon(r))
  end
end

fun nl-sum(nl :: NeLoN) -&gt; Number:
  sum(nelon-to-lon(nl))
end

fun nl-len(nl :: NeLoN) -&gt; Number:
  nelon-to-lon(nl).length()
end</code></pre><p>Now we can write the average in an interesting way:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun avg4(nl :: NeLoN) -&gt; Number:
  s = nl-sum(nl)
  c = nl-len(nl)
  s / c
end</code></pre><p>Once again, we donâ€™t have to have any logic for dealing with errors. However,
itâ€™s not because weâ€™re sloppy or letting Pyret deal with it or getting it
checked at runtime or anything else: itâ€™s because there is no way for an
empty list to arise. Thus we have both the simplest body and the
most truthful interface! But it comes at a cost: we need to do some work to
reuse existing functions.</p><p>This problem extends to writing tests, which is now more painful:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  nl1 = one(1)
  nl2 = more(1, more(2, one(3)))
  nl3 = more(1, more(2, more(3, one(10))))

  avg4(nl1) is 1
  avg4(nl2) is 2
  avg4(nl3) is 4
end</code></pre><p>That is, weâ€™ve lost our convenient way of writing lists. We can recover that by
  writing a helper that creates <code data-lang="pyret" class="sourceCode">NeLoN</code>s:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun lon-to-nelon(l :: LoN) -&gt; NeLoN:
  cases (List) l:
    | empty =&gt; raise("can't make an empty NeLoN")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; one(f)
        | else =&gt; more(f, lon-to-nelon(r))
      end
  end
end

check:
  avg4(lon-to-nelon([list: 1])) is 1
  avg4(lon-to-nelon([list: 1, 2, 3])) is 2
  avg4(lon-to-nelon([list: 1, 2, 3, 10])) is 4
end</code></pre><p>Notice that if we try to use an empty list, we get an exception:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg4(lon-to-nelon(empty)) raises ""
end</code></pre><p>However, itâ€™s very important to understand where the error is coming from: the
exception is not from <code data-lang="pyret" class="sourceCode">avg4</code>, itâ€™s coming from <code data-lang="pyret" class="sourceCode">lon-to-nelon</code>, i.e., from the
â€œinterfaceâ€ function. The bad datum never makes it as far as <code data-lang="pyret" class="sourceCode">avg4</code>! We can
verify this:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  lon-to-nelon(empty) raises ""
end</code></pre><p>Remember, thereâ€™s no way to send an empty list to <code data-lang="pyret" class="sourceCode">avg4</code>! Nevertheless,
this suggests a trade-off: we can either use <code data-lang="pyret" class="sourceCode">NeLoN</code> explicitly but with
more notational pain, or we can use <code data-lang="pyret" class="sourceCode">list</code> but run the risk of some
confusion about exceptions. This is a trade-off in general, but there are
better options in some languages (<a href="#%28part._pd-pyret-list-constr%29" data-pltdoc="x">A Note on Notation</a>).</p><p>So this is actually a very powerful technique: building a datatype that
reflects exactly what we want, thereby turning a partial function into a total
one. Programmers call this principle making illegal states
unrepresentable. It may require writing some procedures to convert to and from
other convenient representations for code reuse. Somewhere in those procedures
there must be checks that reflect the partiality.</p></section><section class="SsectionLevel3" id="section 23.6"><h3 class="heading">23.6Â <a name="(part._pd-summary)"/>Summary<a href="#(part._pd-summary)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>In general, there is one non-solution:
</p><ul><li><p>Return a sentinel value. Do not ever do this unless youâ€™ve first fixed
all the security bugs lurking in C programs from the past several decades.</p></li></ul><p>and there are four solutions:
</p><ul><li><p>Use <code data-lang="pyret" class="sourceCode">raise</code>. This is not very good for software engineering in
general because exceptions are clunky, semantically complicated, and not
compositional.</p></li><li><p>Use a dynamic refinement. Dynamic refinements arenâ€™t in most
languages. Also, itâ€™s less good than each of the other solutions, but itâ€™s a
decent compromise in many settings.</p></li><li><p>Define a datatype to make illegal states unrepresentable. A bit of
work. Pretty sophisticated, invaluable in some places, but not always worth the
effort.</p></li><li><p>Use <code data-lang="pyret" class="sourceCode">Option</code>. Often the ideal option, because:</p><ul><li><p>The type tells us to expect funny business. (<code data-lang="pyret" class="sourceCode">raise</code> hides that.)</p></li><li><p>We canâ€™t accidentally misuse the value. (Sentinels hide that.)</p></li><li><p>Itâ€™s compositional: we can create functions to help us handle it.</p></li><li><p>Itâ€™s much lower overhead than the static totality solution.</p></li><li><p>Itâ€™s more statically robust than the dynamic totality solution.</p></li><li><p>It generalizes: in practice, instead of just <code data-lang="pyret" class="sourceCode">none</code> and <code data-lang="pyret" class="sourceCode">some</code>,
a real program will have <code data-lang="pyret" class="sourceCode">some</code> for the â€œnormalâ€ case, and a bunch of
variants describing the different kinds of errors that are possible, with extra
information in each case. For concrete examples of this, see
<a href="Collections_of_Structured_Data.html#%28part._coll-sd-pick%29" data-pltdoc="x">Picking Elements from Sets</a> on sets <a href="queues-from-lists.html#%28part._qfl-comb-ans%29" data-pltdoc="x">Combining Answers</a> on queues.</p></li></ul></li></ul></section><section class="SsectionLevel3" id="section 23.7"><h3 class="heading">23.7Â <a name="(part._pd-pyret-list-constr)"/>A Note on Notation<a href="#(part._pd-pyret-list-constr)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>When we wrote above that we canâ€™t get the convenience of writing, say,
<code data-lang="pyret" class="sourceCode">[list: 1, 2, 3]</code> when using <code data-lang="pyret" class="sourceCode">NeLoN</code>s, we were speaking in
general. In some languages, we can actually make similar convenient
constructors. In Pyret, for instance, there is a protocol for defining custom
constructors; in fact, seemingly built-in constructors like <code data-lang="pyret" class="sourceCode">list</code> and
<code data-lang="pyret" class="sourceCode">set</code> are built using this protocol. The code for doing this is a bit
ungainly (in part because itâ€™s optimized to save some space and time by making
the constructor-writerâ€™s life a little harder), but it only needs to be written
once. Hereâ€™s a <code data-lang="pyret" class="sourceCode">nelon</code> constructor for <code data-lang="pyret" class="sourceCode">NeLoN</code>s:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun ra-to-nelon(r :: RawArray&lt;Number&gt;) -&gt; NeLoN:
  len = raw-array-length(r)
  fun make-from-index(n :: Number):
    v = raw-array-get(r, n)
    if n == (len - 1):
      one(v)
    else:
      more(v, make-from-index(n + 1))
    end
  end
  make-from-index(0)
end

nelon = {
  make0: {(): raise("can't make an empty NeLoN")},
  make1: {(a1): one(a1)},
  make2: {(a1, a2): more(a1, one(a2))},
  make3: {(a1, a2, a3): more(a1, more(a2, one(a3)))},
  make4: {(a1, a2, a3, a4): more(a1, more(a2, more(a3, one(a4))))},
  make5: {(a1, a2, a3, a4, a5): more(a1, more(a2, more(a3, more(a4, one(a5)))))},
  make: {(args :: RawArray&lt;Number&gt;): ra-to-nelon(args)} }</code></pre><p>These tests show that this constructor works very much like the built-in <code data-lang="pyret" class="sourceCode">list</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  [nelon: ] raises "empty"
  [nelon: 1] is one(1)
  [nelon: 1, 2] is more(1, one(2))
  [nelon: 1, 2, 3] is more(1, more(2, one(3)))
  [nelon: 1, 2, 3, 4] is more(1, more(2, more(3, one(4))))
  [nelon: 1, 2, 3, 4, 5] is more(1, more(2, more(3, more(4, one(5)))))
  [nelon: 1, 2, 3, 4, 5, 6] is
  more(1, more(2, more(3, more(4, more(5, one(6))))))
  [nelon: 1, 2, 3, 4, 5, 6, 7] is
  more(1, more(2, more(3, more(4, more(5, more(6, one(7)))))))
end</code></pre><p>With this, we can rewrite the tests from <a href="#%28part._pd-total-static%29" data-pltdoc="x">Total Domains, Statically</a> very
conveniently:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg4([nelon: 1]) is 1
  avg4([nelon: 1, 2, 3]) is 2
  avg4([nelon: 1, 2, 3, 10]) is 4
end</code></pre><p>thereby having our cake and eating it too!</p></section>&#13;
<h3 class="heading">23.1Â <a name="(part._pd-sentinel)"/>A Non-Solution<a href="#(part._pd-sentinel)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>We will start with a strategy that has often been used by programmers in the
past, but that we reject as a non-solution. This strategy is to make the above
contract absolutely correct by returning a value in the erroneous case;
this value is often called a sentinel. For instance, the sentinel might
be <code data-lang="pyret" class="sourceCode">0</code>. Here is the full program:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">type LoN = List&lt;Number&gt;

fun sum(l :: LoN) -&gt; Number:
  fold({(a, b): a + b}, 0, l)
end

avg0 :: LoN -&gt; Number

fun avg0(l):
  cases (List) l:
    | empty =&gt; 0
    | link(_, _) =&gt;
      s = sum(l)
      c = l.length()
      s / c
  end
end</code></pre><p>and here are a few tests:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg0([list: 1]) is 1
  avg0([list: 1, 2, 3]) is 2
  avg0([list: 1, 2, 3, 10]) is 4
end</code></pre><p>Is there a test missing here? Yes, for the empty list! Should we add it?
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg0(empty) is 0
end</code></pre><p>The question is, should we be happy with this â€œsolutionâ€? There are two
problems with it.</p><p>First, every single use of <code data-lang="pyret" class="sourceCode">avg0</code> needs to check for whether it got back
<code data-lang="pyret" class="sourceCode">0</code> or not. If it did not, then the answer is legitimate, and it can
proceed with the computation. But if it did, then it has to assume that the
input may have been illegitimate, and cannot use the answer.</p><p>Second, even thatâ€™s not quite true. To understand why, we need to write a few
more tests:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg0([list: -1, 0, 1]) is 0
  avg0([list: -5, 4, 1]) is 0
end</code></pre><p>So the problem is that when <code data-lang="pyret" class="sourceCode">avg0</code> returns <code data-lang="pyret" class="sourceCode">0</code>, we donâ€™t know whether
thatâ€™s a legitimate answer or a â€œfakeâ€ answer that stands for â€œthis
is not a valid inputâ€. So even our strategy of â€œcheck everywhereâ€ fails!</p><p>Ah, but maybe the problem is the use of <code data-lang="pyret" class="sourceCode">0</code>! Perhaps we could use a
different number that would work. How about <code data-lang="pyret" class="sourceCode">1</code>? Or <code data-lang="pyret" class="sourceCode">-1</code>? The
question is: Is there any number that reasonably canâ€™t be the
average of an actual input? (And in general, for all problems, can you be sure
of this?) Well, of course not.</p><p>Thatâ€™s why this is a non-solution. It has created several problems:
</p><ul><li><p>We canâ€™t tell from the output whether the input was invalid.</p></li><li><p>That means every caller needs to check.</p></li><li><p>A caller that forgets to check may compute with nonsense.</p></li><li><p>Compositionality is ruined: any function passed <code data-lang="pyret" class="sourceCode">average</code> needs to
know to check the output (and there is nothing in the contract to warn it!).</p></li></ul><p>Indeed, decades of experience tells us that some of the worldâ€™s most
sophisticated programmers have not been able to handle this issue even when it
matters most, resulting in numerous, pernicious security problems. Therefore,
we should now regard this as a flawed approach to software construction, and
never do it ourselves.</p><p>Letâ€™s instead look at four actual solutions.</p>&#13;
<h3 class="heading">23.2Â <a name="(part._pd-exceptions)"/>Exceptions<a href="#(part._pd-exceptions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>One technique that many languages, including Pyret, provide is called the
exception. An exception is a special programming construct that
effectively halts the computation because the program cannot figure out how to
continue computing with the data it has. There are more sophisticated forms of
exceptions in some languages, but here we focus simply on using them as a
strategy for handling partiality.</p><p>Here is the average program written using an exception (we reuse <code data-lang="pyret" class="sourceCode">sum</code>
from before):
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg1 :: LoN -&gt; Number

fun avg1(l):
  cases (List) l:
    | empty =&gt; raise("no average for empty list")
    | link(_, _) =&gt;
      s = sum(l)
      c = l.length()
      s / c
  end
end

check:
  avg1([list: 1]) is 1
  avg1([list: 1, 2, 3]) is 2
  avg1([list: 1, 2, 3, 10]) is 4
end</code></pre><p>The way <code data-lang="pyret" class="sourceCode">raise</code> works is that it terminates everything that is waiting to
happen. For instance, if we were to write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1 + avg1(empty)</code></pre><p>the <code data-lang="pyret" class="sourceCode">1 + â€¦</code> part never happens: the whole computation ends. <code data-lang="pyret" class="sourceCode">raise</code>
creates exceptions.</p><p>Again, weâ€™re missing a test. How do we write it?
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg1(empty) raises "no average for empty list"
end</code></pre><p>The <code data-lang="pyret" class="sourceCode">raises</code> form takes a string that it matches against that provided to
<code data-lang="pyret" class="sourceCode">raise</code>. In act, for convenience, any sub-string of the original string is
permitted: we can, for instance, also write
<code data-lang="pyret" class="sourceCode">check:
  avg1(empty) raises "no average"
  avg1(empty) raises "empty list"
end</code></p><p>In many programming languages, the use of exceptions is the standard way of
dealing with partiality. It is certainly a pragmatic solution. Observe that we
got to reuse <code data-lang="pyret" class="sourceCode">sum</code> from earlier; the contract looks clean; and we only
needed to use <code data-lang="pyret" class="sourceCode">raise</code> at the spot where we didnâ€™t know what to do. Whatâ€™s
not to like?</p><p>There are two main problems with exceptions:
</p><ol><li><p>In real systems, exceptions halt a programâ€™s execution in unpredictable
ways. A caller to <code data-lang="pyret" class="sourceCode">avg1</code> may be half-way through doing something else
(e.g., it may have opened a file that it intends to close), but the exception
causes the call to not finish cleanly, causing the remaining computation to not
run, leaving the system in a messy state.</p></li><li><p>Relatedly, what we presented as a feature should actually be treated as a
problem: the contract lies! Thereâ€™s no indication at all in the contract
that an exception might occur. A programmer has to read the whole
implementationâ€”<wbr/>which could change at any timeâ€”<wbr/>instead of being able to rely
on its published contract, when the whole point of contracts was that they
saved us from having to read the whole implementation!</p></li></ol><p>Indeed, some modern programming languages designed for large-scale programming
(such as Go and Rust) no longer have exception constructs. Therefore, you
should not assume that this will continue to be the â€œstandardâ€ way of doing
things in the future.</p><p>Observe that there is are two kinds of exceptions that can occur. One is
as weâ€™ve written above. The other is when we completely ignore (or forget to
even think about) the empty list case, and end up getting an error from Pyret,
which is also a kind of exception. If Pyret will raise an exception anyway,
does it make sense for us to go through the trouble of doing it ourselves?</p><p>Yes it does! For several reasons:
</p><ol><li><p>First, you get to control where the exception occurs and what it says.</p></li><li><p>You can document that the exception will occur.</p></li><li><p>You are less dependent on the behavior of Pyret or whatever underlying
programming language, which can change in subtle ways.</p></li><li><p>You can create an exception that is unique to you, so it canâ€™t be
confused with other division-by-zero errors that may lurk in your program.</p></li></ol><p>For these reasons, itâ€™s better to check and raise an exception explicitly
than letting it â€œfall throughâ€ to the programming language. Instead, the real
problems with this solution are subtler: the lying contract, and the impact on
program execution.</p>&#13;
<h3 class="heading">23.3Â <a name="(part._pd-option)"/>The Option Type<a href="#(part._pd-option)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Letâ€™s revisit <code data-lang="pyret" class="sourceCode">avg0</code>. The problem with it was that it returned a value
that was not distinguishable from an actual answer. So perhaps another
approach is to return a value that is guaranteed to be distinguishable!
For this, a growing number of languages (including Pyret) have something like
this type:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Option&lt;T&gt;:
  | none
  | some(value :: T)
end</code></pre><p>This is a type we use when we arenâ€™t sure we will have an answer: <code data-lang="pyret" class="sourceCode">none</code>
means we donâ€™t have an answer, whereas <code data-lang="pyret" class="sourceCode">some</code> means we do and <code data-lang="pyret" class="sourceCode">value</code>
is that answer.</p><p>Hereâ€™s how our program now looks:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg2 :: LoN -&gt; Option&lt;Number&gt;

fun avg2(l):
  cases (List) l:
    | empty =&gt; none
    | link(_, _) =&gt;
      s = sum(l)
      c = l.length()
      some(s / c)
  end
end</code></pre><p>Now our tests look a bit different:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg2([list: 1]) is some(1)
  avg2([list: 1, 2, 3]) is some(2)
  avg2([list: 1, 2, 3, 10]) is some(4)
end

check:
  avg2(empty) is none
end</code></pre><p>The good news is, the contract is now truthful. Just by looking at it, we are
reminded that <code data-lang="pyret" class="sourceCode">avg0</code> may not always be able to compute an answer.</p><p>Unfortunately, this imposes some cost on every user: they have to use
<code data-lang="pyret" class="sourceCode">cases</code> to check return values and only use them if they are
legitimate. However, this is the same thing we expected in <code data-lang="pyret" class="sourceCode">avg0</code>â€”<wbr/>except
we lacked a discipline for making sure we didnâ€™t abuse that value! So this is
<code data-lang="pyret" class="sourceCode">avg0</code> done in a principled way.</p>&#13;
<h3 class="heading">23.4Â <a name="(part._pd-total-dyn)"/>Total Domains, Dynamically<a href="#(part._pd-total-dyn)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>All these problems arise because we said that <code data-lang="pyret" class="sourceCode">average</code> (like
<code data-lang="pyret" class="sourceCode">median</code>) is partial. However, itâ€™s only partial if we give the domain as
<code data-lang="pyret" class="sourceCode">List&lt;Number&gt;</code>; itâ€™s actually a total function on the <code data-lang="pyret" class="sourceCode">non-empty</code>
list of numbers. But how do we represent that?</p><p>In some languages, like Pyret, we can actually express this directly:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">type NeLoND = List&lt;Number&gt;%(is-link)</code></pre><p>This says that weâ€™re refining numeric lists to always have a <code data-lang="pyret" class="sourceCode">link</code>,
i.e., to be non-empty. In Pyret, currently, this check is only done at
run-time; in some other programming languages, this can be done by the
type-checker itself.</p><p>This refinement lets us pretend that weâ€™re dealing with regular lists and reuse
all existing list code, while knowing for sure we will never get a
divide-by-zero error:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg3 :: NeLoND -&gt; Number

fun avg3(l):
  s = sum(l)
  c = l.length()
  s / c
end

check:
  avg3([list: 1]) is 1
  avg3([list: 1, 2, 3]) is 2
  avg3([list: 1, 2, 3, 10]) is 4
end</code></pre><p>If we do try passing an empty list, we get an internal exception:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg3(empty) raises ""
end</code></pre><p>This is a pretty interesting solution. Our functionâ€™s code is clean. We donâ€™t
deal with nonsensical values. The interface is truthful! (However, it does require a
careful reading to observe that thereâ€™s an exception lurking underneath the
domain.) And it lets us reuse existing code.</p><p>There are two main weaknesses:
</p><ol><li><p>Dynamic refinements arenâ€™t found in most
languages, so weâ€™d have to do more manual work to obtain the same
solution.</p></li><li><p>We donâ€™t get a static guarantee (i.e., before even running the program)
that weâ€™ll never get an exception.</p></li></ol>&#13;
<h3 class="heading">23.5Â <a name="(part._pd-total-static)"/>Total Domains, Statically<a href="#(part._pd-total-static)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>How do we make the function total with a static guarantee? That would require
that we ensure that we can never construct an empty list! Obviously, this is
not possible with the existing lists in Pyret. However, we can construct a new
list-like datatype that â€œbottoms outâ€ not at empty lists but at lists of one
element:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data NeLoN:
  | one(n :: Number)
  | more(n :: Number, r :: NeLoN)
end</code></pre><p>Observe that there is simply no way to make an empty list: the smallest list
has one element in it. Furthermore, our type checker enforces this for us.</p><p>Of course, this is an entirely different datatype than a list of numbers. We
canâ€™t, for instance, use the existing <code data-lang="pyret" class="sourceCode">sum</code> or <code data-lang="pyret" class="sourceCode">length</code> code on
it. However, one option is to convert a <code data-lang="pyret" class="sourceCode">NeLoN</code> into a <code data-lang="pyret" class="sourceCode">LoN</code>, which
is always safe, and reuse that code:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun nelon-to-lon(nl :: NeLoN):
  cases (NeLoN) nl:
    | one(n) =&gt; [list: n]
    | more(n, r) =&gt; link(n, nelon-to-lon(r))
  end
end

fun nl-sum(nl :: NeLoN) -&gt; Number:
  sum(nelon-to-lon(nl))
end

fun nl-len(nl :: NeLoN) -&gt; Number:
  nelon-to-lon(nl).length()
end</code></pre><p>Now we can write the average in an interesting way:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun avg4(nl :: NeLoN) -&gt; Number:
  s = nl-sum(nl)
  c = nl-len(nl)
  s / c
end</code></pre><p>Once again, we donâ€™t have to have any logic for dealing with errors. However,
itâ€™s not because weâ€™re sloppy or letting Pyret deal with it or getting it
checked at runtime or anything else: itâ€™s because there is no way for an
empty list to arise. Thus we have both the simplest body and the
most truthful interface! But it comes at a cost: we need to do some work to
reuse existing functions.</p><p>This problem extends to writing tests, which is now more painful:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  nl1 = one(1)
  nl2 = more(1, more(2, one(3)))
  nl3 = more(1, more(2, more(3, one(10))))

  avg4(nl1) is 1
  avg4(nl2) is 2
  avg4(nl3) is 4
end</code></pre><p>That is, weâ€™ve lost our convenient way of writing lists. We can recover that by
  writing a helper that creates <code data-lang="pyret" class="sourceCode">NeLoN</code>s:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun lon-to-nelon(l :: LoN) -&gt; NeLoN:
  cases (List) l:
    | empty =&gt; raise("can't make an empty NeLoN")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; one(f)
        | else =&gt; more(f, lon-to-nelon(r))
      end
  end
end

check:
  avg4(lon-to-nelon([list: 1])) is 1
  avg4(lon-to-nelon([list: 1, 2, 3])) is 2
  avg4(lon-to-nelon([list: 1, 2, 3, 10])) is 4
end</code></pre><p>Notice that if we try to use an empty list, we get an exception:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg4(lon-to-nelon(empty)) raises ""
end</code></pre><p>However, itâ€™s very important to understand where the error is coming from: the
exception is not from <code data-lang="pyret" class="sourceCode">avg4</code>, itâ€™s coming from <code data-lang="pyret" class="sourceCode">lon-to-nelon</code>, i.e., from the
â€œinterfaceâ€ function. The bad datum never makes it as far as <code data-lang="pyret" class="sourceCode">avg4</code>! We can
verify this:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  lon-to-nelon(empty) raises ""
end</code></pre><p>Remember, thereâ€™s no way to send an empty list to <code data-lang="pyret" class="sourceCode">avg4</code>! Nevertheless,
this suggests a trade-off: we can either use <code data-lang="pyret" class="sourceCode">NeLoN</code> explicitly but with
more notational pain, or we can use <code data-lang="pyret" class="sourceCode">list</code> but run the risk of some
confusion about exceptions. This is a trade-off in general, but there are
better options in some languages (<a href="#%28part._pd-pyret-list-constr%29" data-pltdoc="x">A Note on Notation</a>).</p><p>So this is actually a very powerful technique: building a datatype that
reflects exactly what we want, thereby turning a partial function into a total
one. Programmers call this principle making illegal states
unrepresentable. It may require writing some procedures to convert to and from
other convenient representations for code reuse. Somewhere in those procedures
there must be checks that reflect the partiality.</p>&#13;
<h3 class="heading">23.6Â <a name="(part._pd-summary)"/>Summary<a href="#(part._pd-summary)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>In general, there is one non-solution:
</p><ul><li><p>Return a sentinel value. Do not ever do this unless youâ€™ve first fixed
all the security bugs lurking in C programs from the past several decades.</p></li></ul><p>and there are four solutions:
</p><ul><li><p>Use <code data-lang="pyret" class="sourceCode">raise</code>. This is not very good for software engineering in
general because exceptions are clunky, semantically complicated, and not
compositional.</p></li><li><p>Use a dynamic refinement. Dynamic refinements arenâ€™t in most
languages. Also, itâ€™s less good than each of the other solutions, but itâ€™s a
decent compromise in many settings.</p></li><li><p>Define a datatype to make illegal states unrepresentable. A bit of
work. Pretty sophisticated, invaluable in some places, but not always worth the
effort.</p></li><li><p>Use <code data-lang="pyret" class="sourceCode">Option</code>. Often the ideal option, because:</p><ul><li><p>The type tells us to expect funny business. (<code data-lang="pyret" class="sourceCode">raise</code> hides that.)</p></li><li><p>We canâ€™t accidentally misuse the value. (Sentinels hide that.)</p></li><li><p>Itâ€™s compositional: we can create functions to help us handle it.</p></li><li><p>Itâ€™s much lower overhead than the static totality solution.</p></li><li><p>Itâ€™s more statically robust than the dynamic totality solution.</p></li><li><p>It generalizes: in practice, instead of just <code data-lang="pyret" class="sourceCode">none</code> and <code data-lang="pyret" class="sourceCode">some</code>,
a real program will have <code data-lang="pyret" class="sourceCode">some</code> for the â€œnormalâ€ case, and a bunch of
variants describing the different kinds of errors that are possible, with extra
information in each case. For concrete examples of this, see
<a href="Collections_of_Structured_Data.html#%28part._coll-sd-pick%29" data-pltdoc="x">Picking Elements from Sets</a> on sets <a href="queues-from-lists.html#%28part._qfl-comb-ans%29" data-pltdoc="x">Combining Answers</a> on queues.</p></li></ul></li></ul>&#13;
<h3 class="heading">23.7Â <a name="(part._pd-pyret-list-constr)"/>A Note on Notation<a href="#(part._pd-pyret-list-constr)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>When we wrote above that we canâ€™t get the convenience of writing, say,
<code data-lang="pyret" class="sourceCode">[list: 1, 2, 3]</code> when using <code data-lang="pyret" class="sourceCode">NeLoN</code>s, we were speaking in
general. In some languages, we can actually make similar convenient
constructors. In Pyret, for instance, there is a protocol for defining custom
constructors; in fact, seemingly built-in constructors like <code data-lang="pyret" class="sourceCode">list</code> and
<code data-lang="pyret" class="sourceCode">set</code> are built using this protocol. The code for doing this is a bit
ungainly (in part because itâ€™s optimized to save some space and time by making
the constructor-writerâ€™s life a little harder), but it only needs to be written
once. Hereâ€™s a <code data-lang="pyret" class="sourceCode">nelon</code> constructor for <code data-lang="pyret" class="sourceCode">NeLoN</code>s:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun ra-to-nelon(r :: RawArray&lt;Number&gt;) -&gt; NeLoN:
  len = raw-array-length(r)
  fun make-from-index(n :: Number):
    v = raw-array-get(r, n)
    if n == (len - 1):
      one(v)
    else:
      more(v, make-from-index(n + 1))
    end
  end
  make-from-index(0)
end

nelon = {
  make0: {(): raise("can't make an empty NeLoN")},
  make1: {(a1): one(a1)},
  make2: {(a1, a2): more(a1, one(a2))},
  make3: {(a1, a2, a3): more(a1, more(a2, one(a3)))},
  make4: {(a1, a2, a3, a4): more(a1, more(a2, more(a3, one(a4))))},
  make5: {(a1, a2, a3, a4, a5): more(a1, more(a2, more(a3, more(a4, one(a5)))))},
  make: {(args :: RawArray&lt;Number&gt;): ra-to-nelon(args)} }</code></pre><p>These tests show that this constructor works very much like the built-in <code data-lang="pyret" class="sourceCode">list</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  [nelon: ] raises "empty"
  [nelon: 1] is one(1)
  [nelon: 1, 2] is more(1, one(2))
  [nelon: 1, 2, 3] is more(1, more(2, one(3)))
  [nelon: 1, 2, 3, 4] is more(1, more(2, more(3, one(4))))
  [nelon: 1, 2, 3, 4, 5] is more(1, more(2, more(3, more(4, one(5)))))
  [nelon: 1, 2, 3, 4, 5, 6] is
  more(1, more(2, more(3, more(4, more(5, one(6))))))
  [nelon: 1, 2, 3, 4, 5, 6, 7] is
  more(1, more(2, more(3, more(4, more(5, more(6, one(7)))))))
end</code></pre><p>With this, we can rewrite the tests from <a href="#%28part._pd-total-static%29" data-pltdoc="x">Total Domains, Statically</a> very
conveniently:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg4([nelon: 1]) is 1
  avg4([nelon: 1, 2, 3]) is 2
  avg4([nelon: 1, 2, 3, 10]) is 4
end</code></pre><p>thereby having our cake and eating it too!</p>    
</body>
</html>