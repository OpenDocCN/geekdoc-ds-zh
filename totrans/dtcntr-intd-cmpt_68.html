<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>23Â Partial DomainsğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>23Â Partial DomainsğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/partial-domains.html">https://dcic-world.org/2025-08-27/partial-domains.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._pd-sentinel%29" class="toclink" data-pltdoc="x">23.1<span class="hspace">Â </span>A Non-Solution</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._pd-exceptions%29" class="toclink" data-pltdoc="x">23.2<span class="hspace">Â </span>Exceptions</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._pd-option%29" class="toclink" data-pltdoc="x">23.3<span class="hspace">Â </span>The Option Type</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._pd-total-dyn%29" class="toclink" data-pltdoc="x">23.4<span class="hspace">Â </span>Total Domains, Dynamically</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._pd-total-static%29" class="toclink" data-pltdoc="x">23.5<span class="hspace">Â </span>Total Domains, Statically</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._pd-summary%29" class="toclink" data-pltdoc="x">23.6<span class="hspace">Â </span>Summary</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._pd-pyret-list-constr%29" class="toclink" data-pltdoc="x">23.7<span class="hspace">Â </span>A Note on Notation</a></p></td></tr></table><p>Sometimes, we cannot precisely capture the domain of a function with the
precision we would like. In mathematics, if a function cannot accept all values
in its domain, it is called <span class="emph">partial</span>. This is a problem we encounter more
often than we might like in programming, so we need to know how to handle
it. There are actually several programming strategies that we can use, with
different benefits and weaknesses. Here, we will examine some of them.</p><p/><div class="SIntrapara">Consider some functions on lists of numbers, such as computing the median or
the average. In both cases, these functions donâ€™t work on <span class="emph">all</span> lists of
numbers: there is no median for the empty list, and we canâ€™t compute its
average either, because there are no elements (so trying to compute the average
would result in a divison-by-zero error). Thus, while it is a convenient
fiction to write
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">average :: List&lt;Number&gt; -&gt; Number</code></pre></div></div></div><div class="SIntrapara">it is just that: a (bit of a) fiction. The function is only defined on
non-empty lists.</div><p>We will now see how to handle this from a software engineering
perspective. Weâ€™ll specifically work through <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">average</code></span> because the function is
simple enough that we can focus on the software structure without getting lost
in the solution details. There are at least four solutions, and one
non-solution.</p><section class="SsectionLevel3" id="section 23.1"><h3 class="heading">23.1<span class="stt">Â </span><a name="(part._pd-sentinel)"/>A Non-Solution<span class="button-group"><a href="#(part._pd-sentinel)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">We will start with a strategy that has often been used by programmers in the
past, but that we reject as a non-solution. This strategy is to make the above
contract absolutely correct by <span class="emph">returning a value in the erroneous case</span>;
this value is often called a <span style="font-style: italic">sentinel</span>. For instance, the sentinel might
be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>. Here is the full program:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">type LoN = List&lt;Number&gt;

fun sum(l :: LoN) -&gt; Number:
  fold({(a, b): a + b}, 0, l)
end

avg0 :: LoN -&gt; Number

fun avg0(l):
  cases (List) l:
    | empty =&gt; 0
    | link(_, _) =&gt;
      s = sum(l)
      c = l.length()
      s / c
  end
end</code></pre></div></div></div><div class="SIntrapara">and here are a few tests:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg0([list: 1]) is 1
  avg0([list: 1, 2, 3]) is 2
  avg0([list: 1, 2, 3, 10]) is 4
end</code></pre></div></div></div><p/><div class="SIntrapara">Is there a test missing here? Yes, for the empty list! Should we add it?
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg0(empty) is 0
end</code></pre></div></div></div><div class="SIntrapara">The question is, should we be happy with this â€œsolutionâ€? There are two
problems with it.</div><p>First, every single use of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg0</code></span> needs to check for whether it got back
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span> or not. If it did not, then the answer is legitimate, and it can
proceed with the computation. But if it did, then it has to assume that the
input may have been illegitimate, and cannot use the answer.</p><p/><div class="SIntrapara">Second, even thatâ€™s not quite true. To understand why, we need to write a few
more tests:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg0([list: -1, 0, 1]) is 0
  avg0([list: -5, 4, 1]) is 0
end</code></pre></div></div></div><div class="SIntrapara">So the problem is that when <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg0</code></span> returns <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>, we donâ€™t know whether
thatâ€™s a <span class="emph">legitimate</span> answer or a â€œfakeâ€ answer that stands for â€œthis
is not a valid inputâ€. So even our strategy of â€œcheck everywhereâ€ fails!</div><p>Ah, but maybe the problem is the use of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>! Perhaps we could use a
different number that would work. How about <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>? Or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">-1</code></span>? The
question is: Is there <span class="emph">any</span> number that reasonably <span class="emph">canâ€™t</span> be the
average of an actual input? (And in general, for all problems, can you be sure
of this?) Well, of course not.</p><p/><div class="SIntrapara">Thatâ€™s why this is a non-solution. It has created several problems:
</div><div class="SIntrapara"><ul><li><p>We canâ€™t tell from the output whether the input was invalid.</p></li><li><p>That means every caller needs to check.</p></li><li><p>A caller that forgets to check may compute with nonsense.</p></li><li><p>Compositionality is ruined: any function passed <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">average</code></span> needs to
know to check the output (and there is nothing in the contract to warn it!).</p></li></ul></div><div class="SIntrapara">Indeed, decades of experience tells us that some of the worldâ€™s most
sophisticated programmers have not been able to handle this issue even when it
matters most, resulting in numerous, pernicious security problems. Therefore,
we should now regard this as a flawed approach to software construction, and
never do it ourselves.</div><p>Letâ€™s instead look at four actual solutions.</p></section><section class="SsectionLevel3" id="section 23.2"><h3 class="heading">23.2<span class="stt">Â </span><a name="(part._pd-exceptions)"/>Exceptions<span class="button-group"><a href="#(part._pd-exceptions)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>One technique that many languages, including Pyret, provide is called the
<span style="font-style: italic">exception</span>. An exception is a special programming construct that
effectively halts the computation because the program cannot figure out how to
continue computing with the data it has. There are more sophisticated forms of
exceptions in some languages, but here we focus simply on using them as a
strategy for handling partiality.</p><p/><div class="SIntrapara">Here is the average program written using an exception (we reuse <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum</code></span>
from before):
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg1 :: LoN -&gt; Number

fun avg1(l):
  cases (List) l:
    | empty =&gt; raise("no average for empty list")
    | link(_, _) =&gt;
      s = sum(l)
      c = l.length()
      s / c
  end
end

check:
  avg1([list: 1]) is 1
  avg1([list: 1, 2, 3]) is 2
  avg1([list: 1, 2, 3, 10]) is 4
end</code></pre></div></div></div><div class="SIntrapara">The way <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">raise</code></span> works is that it terminates everything that is waiting to
happen. For instance, if we were to write
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1 + avg1(empty)</code></pre></div></div></div><div class="SIntrapara">the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1 + â€¦</code></span> part never happens: the whole computation ends. <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">raise</code></span>
creates exceptions.</div><p/><div class="SIntrapara">Again, weâ€™re missing a test. How do we write it?
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg1(empty) raises "no average for empty list"
end</code></pre></div></div></div><div class="SIntrapara">The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">raises</code></span> form takes a string that it matches against that provided to
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">raise</code></span>. In act, for convenience, any sub-string of the original string is
permitted: we can, for instance, also write
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg1(empty) raises "no average"
  avg1(empty) raises "empty list"
end</code></span></div><p>In many programming languages, the use of exceptions is the standard way of
dealing with partiality. It is certainly a pragmatic solution. Observe that we
got to reuse <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum</code></span> from earlier; the contract looks clean; and we only
needed to use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">raise</code></span> at the spot where we didnâ€™t know what to do. Whatâ€™s
not to like?</p><p/><div class="SIntrapara">There are two main problems with exceptions:
</div><div class="SIntrapara"><ol><li><p>In real systems, exceptions halt a programâ€™s execution in unpredictable
ways. A caller to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg1</code></span> may be half-way through doing something else
(e.g., it may have opened a file that it intends to close), but the exception
causes the call to not finish cleanly, causing the remaining computation to not
run, leaving the system in a messy state.</p></li><li><p>Relatedly, what we presented as a feature should actually be treated as a
problem: the contract <span class="emph">lies</span>! Thereâ€™s no indication at all in the contract
that an exception might occur. A programmer has to read the whole
implementationâ€”<wbr/>which could change at any timeâ€”<wbr/>instead of being able to rely
on its published contract, when the whole point of contracts was that they
saved us from having to read the whole implementation!</p></li></ol></div><div class="SIntrapara">Indeed, some modern programming languages designed for large-scale programming
(such as Go and Rust) no longer have exception constructs. Therefore, you
should not assume that this will continue to be the â€œstandardâ€ way of doing
things in the future.</div><p>Observe that there is are <span class="emph">two</span> kinds of exceptions that can occur. One is
as weâ€™ve written above. The other is when we completely ignore (or forget to
even think about) the empty list case, and end up getting an error from Pyret,
which is also a kind of exception. If Pyret will raise an exception anyway,
does it make sense for us to go through the trouble of doing it ourselves?</p><p/><div class="SIntrapara">Yes it does! For several reasons:
</div><div class="SIntrapara"><ol><li><p>First, you get to control where the exception occurs and what it says.</p></li><li><p>You can document that the exception will occur.</p></li><li><p>You are less dependent on the behavior of Pyret or whatever underlying
programming language, which can change in subtle ways.</p></li><li><p>You can create an exception that is unique to you, so it canâ€™t be
confused with other division-by-zero errors that may lurk in your program.</p></li></ol></div><div class="SIntrapara">For these reasons, itâ€™s better to check and raise an exception explicitly
than letting it â€œfall throughâ€ to the programming language. Instead, the real
problems with this solution are subtler: the lying contract, and the impact on
program execution.</div></section><section class="SsectionLevel3" id="section 23.3"><h3 class="heading">23.3<span class="stt">Â </span><a name="(part._pd-option)"/>The Option Type<span class="button-group"><a href="#(part._pd-option)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">Letâ€™s revisit <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg0</code></span>. The problem with it was that it returned a value
that was <span class="emph">not distinguishable</span> from an actual answer. So perhaps another
approach is to return a value that is <span class="emph">guaranteed</span> to be distinguishable!
For this, a growing number of languages (including Pyret) have something like
this type:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Option&lt;T&gt;:
  | none
  | some(value :: T)
end</code></pre></div></div></div><p>This is a type we use when we arenâ€™t sure we will have an answer: <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">none</code></span>
means we donâ€™t have an answer, whereas <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">some</code></span> means we do and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">value</code></span>
is that answer.</p><p/><div class="SIntrapara">Hereâ€™s how our program now looks:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg2 :: LoN -&gt; Option&lt;Number&gt;

fun avg2(l):
  cases (List) l:
    | empty =&gt; none
    | link(_, _) =&gt;
      s = sum(l)
      c = l.length()
      some(s / c)
  end
end</code></pre></div></div></div><div class="SIntrapara">Now our tests look a bit different:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg2([list: 1]) is some(1)
  avg2([list: 1, 2, 3]) is some(2)
  avg2([list: 1, 2, 3, 10]) is some(4)
end

check:
  avg2(empty) is none
end</code></pre></div></div></div><p>The good news is, the contract is now truthful. Just by looking at it, we are
reminded that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg0</code></span> may not always be able to compute an answer.</p><p>Unfortunately, this imposes some cost on every user: they have to use
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> to check return values and only use them if they are
legitimate. However, this is the same thing we expected in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg0</code></span>â€”<wbr/>except
we lacked a discipline for making sure we didnâ€™t abuse that value! So this is
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg0</code></span> done in a principled way.</p></section><section class="SsectionLevel3" id="section 23.4"><h3 class="heading">23.4<span class="stt">Â </span><a name="(part._pd-total-dyn)"/>Total Domains, Dynamically<span class="button-group"><a href="#(part._pd-total-dyn)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>All these problems arise because we said that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">average</code></span> (like
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">median</code></span>) is partial. However, itâ€™s only partial if we give the domain as
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">List&lt;Number&gt;</code></span>; itâ€™s actually a total function on the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">non-empty</code></span>
list of numbers. But how do we represent that?</p><p/><div class="SIntrapara">In some languages, like Pyret, we can actually express this directly:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">type NeLoND = List&lt;Number&gt;%(is-link)</code></pre></div></div></div><div class="SIntrapara">This says that weâ€™re <span style="font-style: italic">refining</span> numeric lists to always have a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>,
i.e., to be non-empty. In Pyret, currently, this check is only done at
run-time; in some other programming languages, this can be done by the
type-checker itself.</div><p/><div class="SIntrapara">This refinement lets us pretend that weâ€™re dealing with regular lists and reuse
all existing list code, while knowing for sure we will never get a
divide-by-zero error:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg3 :: NeLoND -&gt; Number

fun avg3(l):
  s = sum(l)
  c = l.length()
  s / c
end

check:
  avg3([list: 1]) is 1
  avg3([list: 1, 2, 3]) is 2
  avg3([list: 1, 2, 3, 10]) is 4
end</code></pre></div></div></div><div class="SIntrapara">If we do try passing an empty list, we get an internal exception:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg3(empty) raises ""
end</code></pre></div></div></div><div class="SIntrapara">This is a pretty interesting solution. Our functionâ€™s code is clean. We donâ€™t
deal with nonsensical values. The interface is truthful! (However, it does require a
careful reading to observe that thereâ€™s an exception lurking underneath the
domain.) And it lets us reuse existing code.</div><p/><div class="SIntrapara">There are two main weaknesses:
</div><div class="SIntrapara"><ol><li><p>Dynamic refinements arenâ€™t found in most
languages, so weâ€™d have to do more manual work to obtain the same
solution.</p></li><li><p>We donâ€™t get a static guarantee (i.e., before even running the program)
that weâ€™ll never get an exception.</p></li></ol></div></section><section class="SsectionLevel3" id="section 23.5"><h3 class="heading">23.5<span class="stt">Â </span><a name="(part._pd-total-static)"/>Total Domains, Statically<span class="button-group"><a href="#(part._pd-total-static)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">How do we make the function total with a static guarantee? That would require
that we ensure that we can never construct an empty list! Obviously, this is
not possible with the existing lists in Pyret. However, we can construct a new
list-like datatype that â€œbottoms outâ€ not at empty lists but at lists of one
element:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data NeLoN:
  | one(n :: Number)
  | more(n :: Number, r :: NeLoN)
end</code></pre></div></div></div><div class="SIntrapara">Observe that there is simply no way to make an empty list: the smallest list
has one element in it. Furthermore, our type checker enforces this for us.</div><p/><div class="SIntrapara">Of course, this is an entirely different datatype than a list of numbers. We
canâ€™t, for instance, use the existing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">length</code></span> code on
it. However, one option is to convert a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NeLoN</code></span> into a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">LoN</code></span>, which
is always safe, and reuse that code:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun nelon-to-lon(nl :: NeLoN):
  cases (NeLoN) nl:
    | one(n) =&gt; [list: n]
    | more(n, r) =&gt; link(n, nelon-to-lon(r))
  end
end

fun nl-sum(nl :: NeLoN) -&gt; Number:
  sum(nelon-to-lon(nl))
end

fun nl-len(nl :: NeLoN) -&gt; Number:
  nelon-to-lon(nl).length()
end</code></pre></div></div></div><div class="SIntrapara">Now we can write the average in an interesting way:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun avg4(nl :: NeLoN) -&gt; Number:
  s = nl-sum(nl)
  c = nl-len(nl)
  s / c
end</code></pre></div></div></div><p>Once again, we donâ€™t have to have any logic for dealing with errors. However,
itâ€™s not because weâ€™re sloppy or letting Pyret deal with it or getting it
checked at runtime or anything else: itâ€™s because <span class="emph">there is no way for an
empty list to arise</span>. Thus we have <span class="emph">both</span> the simplest body <span class="emph">and</span> the
most truthful interface! But it comes at a cost: we need to do some work to
reuse existing functions.</p><p/><div class="SIntrapara">This problem extends to writing tests, which is now more painful:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  nl1 = one(1)
  nl2 = more(1, more(2, one(3)))
  nl3 = more(1, more(2, more(3, one(10))))

  avg4(nl1) is 1
  avg4(nl2) is 2
  avg4(nl3) is 4
end</code></pre></div></div></div><div class="SIntrapara">That is, weâ€™ve lost our convenient way of writing lists. We can recover that by
  writing a helper that creates <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NeLoN</code></span>s:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun lon-to-nelon(l :: LoN) -&gt; NeLoN:
  cases (List) l:
    | empty =&gt; raise("can't make an empty NeLoN")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; one(f)
        | else =&gt; more(f, lon-to-nelon(r))
      end
  end
end

check:
  avg4(lon-to-nelon([list: 1])) is 1
  avg4(lon-to-nelon([list: 1, 2, 3])) is 2
  avg4(lon-to-nelon([list: 1, 2, 3, 10])) is 4
end</code></pre></div></div></div><div class="SIntrapara">Notice that if we try to use an empty list, we get an exception:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg4(lon-to-nelon(empty)) raises ""
end</code></pre></div></div></div><div class="SIntrapara">However, itâ€™s very important to understand where the error is coming from: the
exception is not from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg4</code></span>, itâ€™s coming from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lon-to-nelon</code></span>, i.e., from the
â€œinterfaceâ€ function. The bad datum never makes it as far as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg4</code></span>! We can
verify this:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  lon-to-nelon(empty) raises ""
end</code></pre></div></div></div><div class="SIntrapara">Remember, thereâ€™s no way to send an empty list to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg4</code></span>! Nevertheless,
this suggests a trade-off: we can either use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NeLoN</code></span> explicitly but with
more notational pain, or we can use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">list</code></span> but run the risk of some
confusion about exceptions. This is a trade-off in general, but there are
better options in some languages (<a href="#%28part._pd-pyret-list-constr%29" data-pltdoc="x">A Note on Notation</a>).</div><p>So this is actually a very powerful technique: building a datatype that
reflects exactly what we want, thereby turning a partial function into a total
one. Programmers call this principle <span class="emph">making illegal states
unrepresentable</span>. It may require writing some procedures to convert to and from
other convenient representations for code reuse. Somewhere in those procedures
there must be checks that reflect the partiality.</p></section><section class="SsectionLevel3" id="section 23.6"><h3 class="heading">23.6<span class="stt">Â </span><a name="(part._pd-summary)"/>Summary<span class="button-group"><a href="#(part._pd-summary)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">In general, there is one <span class="emph">non</span>-solution:
</div><div class="SIntrapara"><ul><li><p>Return a sentinel value. Do not ever do this unless youâ€™ve first fixed
all the security bugs lurking in C programs from the past several decades.</p></li></ul></div><div class="SIntrapara">and there are four solutions:
</div><div class="SIntrapara"><ul><li><p>Use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">raise</code></span>. This is not very good for software engineering in
general because exceptions are clunky, semantically complicated, and not
compositional.</p></li><li><p>Use a dynamic refinement. Dynamic refinements arenâ€™t in most
languages. Also, itâ€™s less good than each of the other solutions, but itâ€™s a
decent compromise in many settings.</p></li><li><p>Define a datatype to make illegal states unrepresentable. A bit of
work. Pretty sophisticated, invaluable in some places, but not always worth the
effort.</p></li><li><p>Use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Option</code></span>. Often the ideal option, because:</p><ul><li><p>The type tells us to expect funny business. (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">raise</code></span> hides that.)</p></li><li><p>We canâ€™t accidentally misuse the value. (Sentinels hide that.)</p></li><li><p>Itâ€™s compositional: we can create functions to help us handle it.</p></li><li><p>Itâ€™s much lower overhead than the static totality solution.</p></li><li><p>Itâ€™s more statically robust than the dynamic totality solution.</p></li><li><p>It generalizes: in practice, instead of just <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">none</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">some</code></span>,
a real program will have <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">some</code></span> for the â€œnormalâ€ case, and a bunch of
variants describing the different kinds of errors that are possible, with extra
information in each case. For concrete examples of this, see
<a href="Collections_of_Structured_Data.html#%28part._coll-sd-pick%29" data-pltdoc="x">Picking Elements from Sets</a> on sets <a href="queues-from-lists.html#%28part._qfl-comb-ans%29" data-pltdoc="x">Combining Answers</a> on queues.</p></li></ul></li></ul></div></section><section class="SsectionLevel3" id="section 23.7"><h3 class="heading">23.7<span class="stt">Â </span><a name="(part._pd-pyret-list-constr)"/>A Note on Notation<span class="button-group"><a href="#(part._pd-pyret-list-constr)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">When we wrote above that we canâ€™t get the convenience of writing, say,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 3]</code></span> when using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NeLoN</code></span>s, we were speaking in
general. In some languages, we can actually make similar convenient
constructors. In Pyret, for instance, there is a protocol for defining custom
constructors; in fact, seemingly built-in constructors like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">list</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">set</code></span> are built using this protocol. The code for doing this is a bit
ungainly (in part because itâ€™s optimized to save some space and time by making
the constructor-writerâ€™s life a little harder), but it only needs to be written
once. Hereâ€™s a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nelon</code></span> constructor for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NeLoN</code></span>s:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun ra-to-nelon(r :: RawArray&lt;Number&gt;) -&gt; NeLoN:
  len = raw-array-length(r)
  fun make-from-index(n :: Number):
    v = raw-array-get(r, n)
    if n == (len - 1):
      one(v)
    else:
      more(v, make-from-index(n + 1))
    end
  end
  make-from-index(0)
end

nelon = {
  make0: {(): raise("can't make an empty NeLoN")},
  make1: {(a1): one(a1)},
  make2: {(a1, a2): more(a1, one(a2))},
  make3: {(a1, a2, a3): more(a1, more(a2, one(a3)))},
  make4: {(a1, a2, a3, a4): more(a1, more(a2, more(a3, one(a4))))},
  make5: {(a1, a2, a3, a4, a5): more(a1, more(a2, more(a3, more(a4, one(a5)))))},
  make: {(args :: RawArray&lt;Number&gt;): ra-to-nelon(args)} }</code></pre></div></div></div><div class="SIntrapara">These tests show that this constructor works very much like the built-in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">list</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  [nelon: ] raises "empty"
  [nelon: 1] is one(1)
  [nelon: 1, 2] is more(1, one(2))
  [nelon: 1, 2, 3] is more(1, more(2, one(3)))
  [nelon: 1, 2, 3, 4] is more(1, more(2, more(3, one(4))))
  [nelon: 1, 2, 3, 4, 5] is more(1, more(2, more(3, more(4, one(5)))))
  [nelon: 1, 2, 3, 4, 5, 6] is
  more(1, more(2, more(3, more(4, more(5, one(6))))))
  [nelon: 1, 2, 3, 4, 5, 6, 7] is
  more(1, more(2, more(3, more(4, more(5, more(6, one(7)))))))
end</code></pre></div></div></div><div class="SIntrapara">With this, we can rewrite the tests from <a href="#%28part._pd-total-static%29" data-pltdoc="x">Total Domains, Statically</a> very
conveniently:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg4([nelon: 1]) is 1
  avg4([nelon: 1, 2, 3]) is 2
  avg4([nelon: 1, 2, 3, 10]) is 4
end</code></pre></div></div></div><div class="SIntrapara">thereby having our cake and eating it too!</div></section>&#13;
<h3 class="heading">23.1<span class="stt">Â </span><a name="(part._pd-sentinel)"/>A Non-Solution<span class="button-group"><a href="#(part._pd-sentinel)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">We will start with a strategy that has often been used by programmers in the
past, but that we reject as a non-solution. This strategy is to make the above
contract absolutely correct by <span class="emph">returning a value in the erroneous case</span>;
this value is often called a <span style="font-style: italic">sentinel</span>. For instance, the sentinel might
be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>. Here is the full program:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">type LoN = List&lt;Number&gt;

fun sum(l :: LoN) -&gt; Number:
  fold({(a, b): a + b}, 0, l)
end

avg0 :: LoN -&gt; Number

fun avg0(l):
  cases (List) l:
    | empty =&gt; 0
    | link(_, _) =&gt;
      s = sum(l)
      c = l.length()
      s / c
  end
end</code></pre></div></div></div><div class="SIntrapara">and here are a few tests:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg0([list: 1]) is 1
  avg0([list: 1, 2, 3]) is 2
  avg0([list: 1, 2, 3, 10]) is 4
end</code></pre></div></div></div><p/><div class="SIntrapara">Is there a test missing here? Yes, for the empty list! Should we add it?
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg0(empty) is 0
end</code></pre></div></div></div><div class="SIntrapara">The question is, should we be happy with this â€œsolutionâ€? There are two
problems with it.</div><p>First, every single use of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg0</code></span> needs to check for whether it got back
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span> or not. If it did not, then the answer is legitimate, and it can
proceed with the computation. But if it did, then it has to assume that the
input may have been illegitimate, and cannot use the answer.</p><p/><div class="SIntrapara">Second, even thatâ€™s not quite true. To understand why, we need to write a few
more tests:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg0([list: -1, 0, 1]) is 0
  avg0([list: -5, 4, 1]) is 0
end</code></pre></div></div></div><div class="SIntrapara">So the problem is that when <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg0</code></span> returns <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>, we donâ€™t know whether
thatâ€™s a <span class="emph">legitimate</span> answer or a â€œfakeâ€ answer that stands for â€œthis
is not a valid inputâ€. So even our strategy of â€œcheck everywhereâ€ fails!</div><p>Ah, but maybe the problem is the use of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>! Perhaps we could use a
different number that would work. How about <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>? Or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">-1</code></span>? The
question is: Is there <span class="emph">any</span> number that reasonably <span class="emph">canâ€™t</span> be the
average of an actual input? (And in general, for all problems, can you be sure
of this?) Well, of course not.</p><p/><div class="SIntrapara">Thatâ€™s why this is a non-solution. It has created several problems:
</div><div class="SIntrapara"><ul><li><p>We canâ€™t tell from the output whether the input was invalid.</p></li><li><p>That means every caller needs to check.</p></li><li><p>A caller that forgets to check may compute with nonsense.</p></li><li><p>Compositionality is ruined: any function passed <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">average</code></span> needs to
know to check the output (and there is nothing in the contract to warn it!).</p></li></ul></div><div class="SIntrapara">Indeed, decades of experience tells us that some of the worldâ€™s most
sophisticated programmers have not been able to handle this issue even when it
matters most, resulting in numerous, pernicious security problems. Therefore,
we should now regard this as a flawed approach to software construction, and
never do it ourselves.</div><p>Letâ€™s instead look at four actual solutions.</p>&#13;
<h3 class="heading">23.2<span class="stt">Â </span><a name="(part._pd-exceptions)"/>Exceptions<span class="button-group"><a href="#(part._pd-exceptions)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>One technique that many languages, including Pyret, provide is called the
<span style="font-style: italic">exception</span>. An exception is a special programming construct that
effectively halts the computation because the program cannot figure out how to
continue computing with the data it has. There are more sophisticated forms of
exceptions in some languages, but here we focus simply on using them as a
strategy for handling partiality.</p><p/><div class="SIntrapara">Here is the average program written using an exception (we reuse <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum</code></span>
from before):
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg1 :: LoN -&gt; Number

fun avg1(l):
  cases (List) l:
    | empty =&gt; raise("no average for empty list")
    | link(_, _) =&gt;
      s = sum(l)
      c = l.length()
      s / c
  end
end

check:
  avg1([list: 1]) is 1
  avg1([list: 1, 2, 3]) is 2
  avg1([list: 1, 2, 3, 10]) is 4
end</code></pre></div></div></div><div class="SIntrapara">The way <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">raise</code></span> works is that it terminates everything that is waiting to
happen. For instance, if we were to write
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1 + avg1(empty)</code></pre></div></div></div><div class="SIntrapara">the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1 + â€¦</code></span> part never happens: the whole computation ends. <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">raise</code></span>
creates exceptions.</div><p/><div class="SIntrapara">Again, weâ€™re missing a test. How do we write it?
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg1(empty) raises "no average for empty list"
end</code></pre></div></div></div><div class="SIntrapara">The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">raises</code></span> form takes a string that it matches against that provided to
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">raise</code></span>. In act, for convenience, any sub-string of the original string is
permitted: we can, for instance, also write
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg1(empty) raises "no average"
  avg1(empty) raises "empty list"
end</code></span></div><p>In many programming languages, the use of exceptions is the standard way of
dealing with partiality. It is certainly a pragmatic solution. Observe that we
got to reuse <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum</code></span> from earlier; the contract looks clean; and we only
needed to use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">raise</code></span> at the spot where we didnâ€™t know what to do. Whatâ€™s
not to like?</p><p/><div class="SIntrapara">There are two main problems with exceptions:
</div><div class="SIntrapara"><ol><li><p>In real systems, exceptions halt a programâ€™s execution in unpredictable
ways. A caller to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg1</code></span> may be half-way through doing something else
(e.g., it may have opened a file that it intends to close), but the exception
causes the call to not finish cleanly, causing the remaining computation to not
run, leaving the system in a messy state.</p></li><li><p>Relatedly, what we presented as a feature should actually be treated as a
problem: the contract <span class="emph">lies</span>! Thereâ€™s no indication at all in the contract
that an exception might occur. A programmer has to read the whole
implementationâ€”<wbr/>which could change at any timeâ€”<wbr/>instead of being able to rely
on its published contract, when the whole point of contracts was that they
saved us from having to read the whole implementation!</p></li></ol></div><div class="SIntrapara">Indeed, some modern programming languages designed for large-scale programming
(such as Go and Rust) no longer have exception constructs. Therefore, you
should not assume that this will continue to be the â€œstandardâ€ way of doing
things in the future.</div><p>Observe that there is are <span class="emph">two</span> kinds of exceptions that can occur. One is
as weâ€™ve written above. The other is when we completely ignore (or forget to
even think about) the empty list case, and end up getting an error from Pyret,
which is also a kind of exception. If Pyret will raise an exception anyway,
does it make sense for us to go through the trouble of doing it ourselves?</p><p/><div class="SIntrapara">Yes it does! For several reasons:
</div><div class="SIntrapara"><ol><li><p>First, you get to control where the exception occurs and what it says.</p></li><li><p>You can document that the exception will occur.</p></li><li><p>You are less dependent on the behavior of Pyret or whatever underlying
programming language, which can change in subtle ways.</p></li><li><p>You can create an exception that is unique to you, so it canâ€™t be
confused with other division-by-zero errors that may lurk in your program.</p></li></ol></div><div class="SIntrapara">For these reasons, itâ€™s better to check and raise an exception explicitly
than letting it â€œfall throughâ€ to the programming language. Instead, the real
problems with this solution are subtler: the lying contract, and the impact on
program execution.</div>&#13;
<h3 class="heading">23.3<span class="stt">Â </span><a name="(part._pd-option)"/>The Option Type<span class="button-group"><a href="#(part._pd-option)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">Letâ€™s revisit <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg0</code></span>. The problem with it was that it returned a value
that was <span class="emph">not distinguishable</span> from an actual answer. So perhaps another
approach is to return a value that is <span class="emph">guaranteed</span> to be distinguishable!
For this, a growing number of languages (including Pyret) have something like
this type:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Option&lt;T&gt;:
  | none
  | some(value :: T)
end</code></pre></div></div></div><p>This is a type we use when we arenâ€™t sure we will have an answer: <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">none</code></span>
means we donâ€™t have an answer, whereas <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">some</code></span> means we do and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">value</code></span>
is that answer.</p><p/><div class="SIntrapara">Hereâ€™s how our program now looks:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg2 :: LoN -&gt; Option&lt;Number&gt;

fun avg2(l):
  cases (List) l:
    | empty =&gt; none
    | link(_, _) =&gt;
      s = sum(l)
      c = l.length()
      some(s / c)
  end
end</code></pre></div></div></div><div class="SIntrapara">Now our tests look a bit different:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg2([list: 1]) is some(1)
  avg2([list: 1, 2, 3]) is some(2)
  avg2([list: 1, 2, 3, 10]) is some(4)
end

check:
  avg2(empty) is none
end</code></pre></div></div></div><p>The good news is, the contract is now truthful. Just by looking at it, we are
reminded that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg0</code></span> may not always be able to compute an answer.</p><p>Unfortunately, this imposes some cost on every user: they have to use
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> to check return values and only use them if they are
legitimate. However, this is the same thing we expected in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg0</code></span>â€”<wbr/>except
we lacked a discipline for making sure we didnâ€™t abuse that value! So this is
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg0</code></span> done in a principled way.</p>&#13;
<h3 class="heading">23.4<span class="stt">Â </span><a name="(part._pd-total-dyn)"/>Total Domains, Dynamically<span class="button-group"><a href="#(part._pd-total-dyn)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>All these problems arise because we said that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">average</code></span> (like
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">median</code></span>) is partial. However, itâ€™s only partial if we give the domain as
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">List&lt;Number&gt;</code></span>; itâ€™s actually a total function on the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">non-empty</code></span>
list of numbers. But how do we represent that?</p><p/><div class="SIntrapara">In some languages, like Pyret, we can actually express this directly:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">type NeLoND = List&lt;Number&gt;%(is-link)</code></pre></div></div></div><div class="SIntrapara">This says that weâ€™re <span style="font-style: italic">refining</span> numeric lists to always have a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>,
i.e., to be non-empty. In Pyret, currently, this check is only done at
run-time; in some other programming languages, this can be done by the
type-checker itself.</div><p/><div class="SIntrapara">This refinement lets us pretend that weâ€™re dealing with regular lists and reuse
all existing list code, while knowing for sure we will never get a
divide-by-zero error:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg3 :: NeLoND -&gt; Number

fun avg3(l):
  s = sum(l)
  c = l.length()
  s / c
end

check:
  avg3([list: 1]) is 1
  avg3([list: 1, 2, 3]) is 2
  avg3([list: 1, 2, 3, 10]) is 4
end</code></pre></div></div></div><div class="SIntrapara">If we do try passing an empty list, we get an internal exception:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg3(empty) raises ""
end</code></pre></div></div></div><div class="SIntrapara">This is a pretty interesting solution. Our functionâ€™s code is clean. We donâ€™t
deal with nonsensical values. The interface is truthful! (However, it does require a
careful reading to observe that thereâ€™s an exception lurking underneath the
domain.) And it lets us reuse existing code.</div><p/><div class="SIntrapara">There are two main weaknesses:
</div><div class="SIntrapara"><ol><li><p>Dynamic refinements arenâ€™t found in most
languages, so weâ€™d have to do more manual work to obtain the same
solution.</p></li><li><p>We donâ€™t get a static guarantee (i.e., before even running the program)
that weâ€™ll never get an exception.</p></li></ol></div>&#13;
<h3 class="heading">23.5<span class="stt">Â </span><a name="(part._pd-total-static)"/>Total Domains, Statically<span class="button-group"><a href="#(part._pd-total-static)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">How do we make the function total with a static guarantee? That would require
that we ensure that we can never construct an empty list! Obviously, this is
not possible with the existing lists in Pyret. However, we can construct a new
list-like datatype that â€œbottoms outâ€ not at empty lists but at lists of one
element:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data NeLoN:
  | one(n :: Number)
  | more(n :: Number, r :: NeLoN)
end</code></pre></div></div></div><div class="SIntrapara">Observe that there is simply no way to make an empty list: the smallest list
has one element in it. Furthermore, our type checker enforces this for us.</div><p/><div class="SIntrapara">Of course, this is an entirely different datatype than a list of numbers. We
canâ€™t, for instance, use the existing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">length</code></span> code on
it. However, one option is to convert a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NeLoN</code></span> into a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">LoN</code></span>, which
is always safe, and reuse that code:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun nelon-to-lon(nl :: NeLoN):
  cases (NeLoN) nl:
    | one(n) =&gt; [list: n]
    | more(n, r) =&gt; link(n, nelon-to-lon(r))
  end
end

fun nl-sum(nl :: NeLoN) -&gt; Number:
  sum(nelon-to-lon(nl))
end

fun nl-len(nl :: NeLoN) -&gt; Number:
  nelon-to-lon(nl).length()
end</code></pre></div></div></div><div class="SIntrapara">Now we can write the average in an interesting way:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun avg4(nl :: NeLoN) -&gt; Number:
  s = nl-sum(nl)
  c = nl-len(nl)
  s / c
end</code></pre></div></div></div><p>Once again, we donâ€™t have to have any logic for dealing with errors. However,
itâ€™s not because weâ€™re sloppy or letting Pyret deal with it or getting it
checked at runtime or anything else: itâ€™s because <span class="emph">there is no way for an
empty list to arise</span>. Thus we have <span class="emph">both</span> the simplest body <span class="emph">and</span> the
most truthful interface! But it comes at a cost: we need to do some work to
reuse existing functions.</p><p/><div class="SIntrapara">This problem extends to writing tests, which is now more painful:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  nl1 = one(1)
  nl2 = more(1, more(2, one(3)))
  nl3 = more(1, more(2, more(3, one(10))))

  avg4(nl1) is 1
  avg4(nl2) is 2
  avg4(nl3) is 4
end</code></pre></div></div></div><div class="SIntrapara">That is, weâ€™ve lost our convenient way of writing lists. We can recover that by
  writing a helper that creates <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NeLoN</code></span>s:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun lon-to-nelon(l :: LoN) -&gt; NeLoN:
  cases (List) l:
    | empty =&gt; raise("can't make an empty NeLoN")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; one(f)
        | else =&gt; more(f, lon-to-nelon(r))
      end
  end
end

check:
  avg4(lon-to-nelon([list: 1])) is 1
  avg4(lon-to-nelon([list: 1, 2, 3])) is 2
  avg4(lon-to-nelon([list: 1, 2, 3, 10])) is 4
end</code></pre></div></div></div><div class="SIntrapara">Notice that if we try to use an empty list, we get an exception:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg4(lon-to-nelon(empty)) raises ""
end</code></pre></div></div></div><div class="SIntrapara">However, itâ€™s very important to understand where the error is coming from: the
exception is not from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg4</code></span>, itâ€™s coming from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lon-to-nelon</code></span>, i.e., from the
â€œinterfaceâ€ function. The bad datum never makes it as far as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg4</code></span>! We can
verify this:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  lon-to-nelon(empty) raises ""
end</code></pre></div></div></div><div class="SIntrapara">Remember, thereâ€™s no way to send an empty list to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">avg4</code></span>! Nevertheless,
this suggests a trade-off: we can either use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NeLoN</code></span> explicitly but with
more notational pain, or we can use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">list</code></span> but run the risk of some
confusion about exceptions. This is a trade-off in general, but there are
better options in some languages (<a href="#%28part._pd-pyret-list-constr%29" data-pltdoc="x">A Note on Notation</a>).</div><p>So this is actually a very powerful technique: building a datatype that
reflects exactly what we want, thereby turning a partial function into a total
one. Programmers call this principle <span class="emph">making illegal states
unrepresentable</span>. It may require writing some procedures to convert to and from
other convenient representations for code reuse. Somewhere in those procedures
there must be checks that reflect the partiality.</p>&#13;
<h3 class="heading">23.6<span class="stt">Â </span><a name="(part._pd-summary)"/>Summary<span class="button-group"><a href="#(part._pd-summary)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">In general, there is one <span class="emph">non</span>-solution:
</div><div class="SIntrapara"><ul><li><p>Return a sentinel value. Do not ever do this unless youâ€™ve first fixed
all the security bugs lurking in C programs from the past several decades.</p></li></ul></div><div class="SIntrapara">and there are four solutions:
</div><div class="SIntrapara"><ul><li><p>Use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">raise</code></span>. This is not very good for software engineering in
general because exceptions are clunky, semantically complicated, and not
compositional.</p></li><li><p>Use a dynamic refinement. Dynamic refinements arenâ€™t in most
languages. Also, itâ€™s less good than each of the other solutions, but itâ€™s a
decent compromise in many settings.</p></li><li><p>Define a datatype to make illegal states unrepresentable. A bit of
work. Pretty sophisticated, invaluable in some places, but not always worth the
effort.</p></li><li><p>Use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Option</code></span>. Often the ideal option, because:</p><ul><li><p>The type tells us to expect funny business. (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">raise</code></span> hides that.)</p></li><li><p>We canâ€™t accidentally misuse the value. (Sentinels hide that.)</p></li><li><p>Itâ€™s compositional: we can create functions to help us handle it.</p></li><li><p>Itâ€™s much lower overhead than the static totality solution.</p></li><li><p>Itâ€™s more statically robust than the dynamic totality solution.</p></li><li><p>It generalizes: in practice, instead of just <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">none</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">some</code></span>,
a real program will have <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">some</code></span> for the â€œnormalâ€ case, and a bunch of
variants describing the different kinds of errors that are possible, with extra
information in each case. For concrete examples of this, see
<a href="Collections_of_Structured_Data.html#%28part._coll-sd-pick%29" data-pltdoc="x">Picking Elements from Sets</a> on sets <a href="queues-from-lists.html#%28part._qfl-comb-ans%29" data-pltdoc="x">Combining Answers</a> on queues.</p></li></ul></li></ul></div>&#13;
<h3 class="heading">23.7<span class="stt">Â </span><a name="(part._pd-pyret-list-constr)"/>A Note on Notation<span class="button-group"><a href="#(part._pd-pyret-list-constr)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">When we wrote above that we canâ€™t get the convenience of writing, say,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 3]</code></span> when using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NeLoN</code></span>s, we were speaking in
general. In some languages, we can actually make similar convenient
constructors. In Pyret, for instance, there is a protocol for defining custom
constructors; in fact, seemingly built-in constructors like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">list</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">set</code></span> are built using this protocol. The code for doing this is a bit
ungainly (in part because itâ€™s optimized to save some space and time by making
the constructor-writerâ€™s life a little harder), but it only needs to be written
once. Hereâ€™s a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nelon</code></span> constructor for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NeLoN</code></span>s:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun ra-to-nelon(r :: RawArray&lt;Number&gt;) -&gt; NeLoN:
  len = raw-array-length(r)
  fun make-from-index(n :: Number):
    v = raw-array-get(r, n)
    if n == (len - 1):
      one(v)
    else:
      more(v, make-from-index(n + 1))
    end
  end
  make-from-index(0)
end

nelon = {
  make0: {(): raise("can't make an empty NeLoN")},
  make1: {(a1): one(a1)},
  make2: {(a1, a2): more(a1, one(a2))},
  make3: {(a1, a2, a3): more(a1, more(a2, one(a3)))},
  make4: {(a1, a2, a3, a4): more(a1, more(a2, more(a3, one(a4))))},
  make5: {(a1, a2, a3, a4, a5): more(a1, more(a2, more(a3, more(a4, one(a5)))))},
  make: {(args :: RawArray&lt;Number&gt;): ra-to-nelon(args)} }</code></pre></div></div></div><div class="SIntrapara">These tests show that this constructor works very much like the built-in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">list</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  [nelon: ] raises "empty"
  [nelon: 1] is one(1)
  [nelon: 1, 2] is more(1, one(2))
  [nelon: 1, 2, 3] is more(1, more(2, one(3)))
  [nelon: 1, 2, 3, 4] is more(1, more(2, more(3, one(4))))
  [nelon: 1, 2, 3, 4, 5] is more(1, more(2, more(3, more(4, one(5)))))
  [nelon: 1, 2, 3, 4, 5, 6] is
  more(1, more(2, more(3, more(4, more(5, one(6))))))
  [nelon: 1, 2, 3, 4, 5, 6, 7] is
  more(1, more(2, more(3, more(4, more(5, more(6, one(7)))))))
end</code></pre></div></div></div><div class="SIntrapara">With this, we can rewrite the tests from <a href="#%28part._pd-total-static%29" data-pltdoc="x">Total Domains, Statically</a> very
conveniently:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  avg4([nelon: 1]) is 1
  avg4([nelon: 1, 2, 3]) is 2
  avg4([nelon: 1, 2, 3, 10]) is 4
end</code></pre></div></div></div><div class="SIntrapara">thereby having our cake and eating it too!</div>    
</body>
</html>