<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Masking and Blending</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Masking and Blending</h1>
<blockquote>原文：<a href="https://en.algorithmica.org/hpc/simd/masking/">https://en.algorithmica.org/hpc/simd/masking/</a></blockquote><div id="search"><input id="search-bar" type="search" placeholder="Search this book…" oninput="search()"/><div id="search-count"/><div id="search-results"/></div><header><div class="info"/></header><article><p>One of the bigger challenges of SIMD programming is that its options for control flow are very limited — because the operations you apply to a vector are the same for all its elements.</p><p>This makes the problems that are usually trivially resolved with an <code>if</code> or any other type of branching much harder. With SIMD, they have to be dealt with by the means of various <a href="/hpc/pipelining/branchless">branchless programming</a> techniques, which aren’t always that straightforward to apply.</p><span class="anchor" id="masking"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/simd/masking/#masking">#</a>Masking</h3><p>The main way to make a computation branchless is through <em>predication</em> — computing the results of both branches and then using either some arithmetic trick or a special “conditional move” instruction:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// branch:
</span></span></span><span class="line"><span class="cl"><span class="c1"/><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// no branch:
</span></span></span><span class="line"><span class="cl"><span class="c1"/><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// also no branch:
</span></span></span><span class="line"><span class="cl"><span class="c1"/><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">50</span> <span class="o">?</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
</span></span></code></pre></div><p>To vectorize this loop, we are going to need two new instructions:</p><ul><li><code>_mm256_cmpgt_epi32</code>, which compares the integers in two vectors and produces a mask of all ones if the first element is more than the second and a mask of full zeros otherwise.</li><li><code>_mm256_blendv_epi8</code>, which blends (combines) the values of two vectors based on the provided mask.</li></ul><p>By masking and blending the elements of a vector so that only the selected subset of them is affected by computation, we can perform predication in a manner similar to the conditional move:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">reg</span> <span class="n">c</span> <span class="o">=</span> <span class="n">_mm256_set1_epi32</span><span class="p">(</span><span class="mi">49</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">reg</span> <span class="n">z</span> <span class="o">=</span> <span class="n">_mm256_setzero_si256</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">reg</span> <span class="n">s</span> <span class="o">=</span> <span class="n">_mm256_setzero_si256</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">reg</span> <span class="n">x</span> <span class="o">=</span> <span class="n">_mm256_load_si256</span><span class="p">(</span> <span class="p">(</span><span class="n">reg</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">reg</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">_mm256_cmpgt_epi32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="n">_mm256_blendv_epi8</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">=</span> <span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>(Minor details such as <a href="../reduction">horizontal summation and accounting for the remainder of the array</a> are omitted for brevity.)</p><p>This is how predication is usually done in SIMD, but it isn’t always the most optimal approach. We can use the fact that one of the blended values is zero, and use bitwise <code>and</code> with the mask instead of blending:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">reg</span> <span class="n">c</span> <span class="o">=</span> <span class="n">_mm256_set1_epi32</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">reg</span> <span class="n">s</span> <span class="o">=</span> <span class="n">_mm256_setzero_si256</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">reg</span> <span class="n">x</span> <span class="o">=</span> <span class="n">_mm256_load_si256</span><span class="p">(</span> <span class="p">(</span><span class="n">reg</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">reg</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">_mm256_cmpgt_epi32</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="n">_mm256_and_si256</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">=</span> <span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This loop performs slightly faster because on this particular CPU, the vector <code>and</code> takes one cycle less than <code>blend</code>.</p><p>Several other instructions support masks as inputs, most notably:</p><ul><li>The <code>_mm256_blend_epi32</code> intrinsic is a <code>blend</code> that takes an 8-bit integer mask instead of a vector (which is why it doesn’t have <code>v</code> at the end).</li><li>The <code>_mm256_maskload_epi32</code> and <code>_mm256_maskstore_epi32</code> intrinsics that load/store a SIMD block from memory and <code>and</code> it with a mask in one go.</li></ul><p>We can also use predication with built-in vector types:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vec</span> <span class="o">*</span><span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">vec</span><span class="o">*</span><span class="p">)</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">vec</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">50</span> <span class="o">?</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
</span></span></code></pre></div><p>All these versions work at around 13 GFLOPS as this example is so simple that the compiler can vectorize the loop all by itself. Let’s move on to more complex examples that can’t be auto-vectorized.</p><span class="anchor" id="searching"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/simd/masking/#searching">#</a>Searching</h3><p>In the next example, we need to find a specific value in an array and return its position (aka <code>std::find</code>):</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">12</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>To benchmark the <code>find</code> function, we fill the array with numbers from $0$ to $(N - 1)$ and then repeatedly search for a random element:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">checksum</span> <span class="o">^=</span> <span class="n">find</span><span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">N</span><span class="p">);</span>
</span></span></code></pre></div><p>The scalar version gives ~4 GFLOPS of performance. This number includes the elements we haven’t had to process, so divide this number by two in your head (the expected fraction of the elements we have to check).</p><p>To vectorize it, we need to compare a vector of its elements with the searched value for equality, producing a mask, and then somehow check if this mask is zero. If it isn’t, the needed element is somewhere within this block of 8.</p><p>To check if the mask is zero, we can use the <code>_mm256_movemask_ps</code> intrinsic, which takes the first bit of each 32-bit element in a vector and produces an 8-bit integer mask out of them. We can then check if this mask is non-zero — and if it is, also immediately get the index with the <code>ctz</code> instruction:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">needle</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">reg</span> <span class="n">x</span> <span class="o">=</span> <span class="n">_mm256_set1_epi32</span><span class="p">(</span><span class="n">needle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">y</span> <span class="o">=</span> <span class="n">_mm256_load_si256</span><span class="p">(</span> <span class="p">(</span><span class="n">reg</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">m</span> <span class="o">=</span> <span class="n">_mm256_cmpeq_epi32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">_mm256_movemask_ps</span><span class="p">((</span><span class="n">__m256</span><span class="p">)</span> <span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="n">__builtin_ctz</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This version gives ~20 GFLOPS or about 5 times faster than the scalar one. It only uses 3 instructions in the hot loop:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nf">vpcmpeqd</span>  <span class="nv">ymm0</span><span class="p">,</span> <span class="nv">ymm1</span><span class="p">,</span> <span class="nv">YMMWORD</span> <span class="nv">PTR</span> <span class="nv">a</span><span class="p">[</span><span class="mi">0</span><span class="o">+</span><span class="nb">rdx</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">vmovmskps</span> <span class="nb">eax</span><span class="p">,</span> <span class="nv">ymm0</span>
</span></span><span class="line"><span class="cl"><span class="nf">test</span>      <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
</span></span><span class="line"><span class="cl"><span class="nf">je</span>        <span class="nv">loop</span>
</span></span></code></pre></div><p>Checking if a vector is zero is a common operation, and there is an operation similar to <code>test</code> in SIMD that we can use:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">needle</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">reg</span> <span class="n">x</span> <span class="o">=</span> <span class="n">_mm256_set1_epi32</span><span class="p">(</span><span class="n">needle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">y</span> <span class="o">=</span> <span class="n">_mm256_load_si256</span><span class="p">(</span> <span class="p">(</span><span class="n">reg</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">m</span> <span class="o">=</span> <span class="n">_mm256_cmpeq_epi32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_mm256_testz_si256</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">_mm256_movemask_ps</span><span class="p">((</span><span class="n">__m256</span><span class="p">)</span> <span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="n">__builtin_ctz</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>We are still using <code>movemask</code> to do <code>ctz</code> later, but the hot loop is now one instruction shorter:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nf">vpcmpeqd</span> <span class="nv">ymm0</span><span class="p">,</span> <span class="nv">ymm1</span><span class="p">,</span> <span class="nv">YMMWORD</span> <span class="nv">PTR</span> <span class="nv">a</span><span class="p">[</span><span class="mi">0</span><span class="o">+</span><span class="nb">rdx</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">vptest</span>   <span class="nv">ymm0</span><span class="p">,</span> <span class="nv">ymm0</span>
</span></span><span class="line"><span class="cl"><span class="nf">je</span>       <span class="nv">loop</span>
</span></span></code></pre></div><p>This doesn’t improve performance much because both both <code>vptest</code> and <code>vmovmskps</code> have a throughput of one and will bottleneck the computation regardless of anything else we do in the loop.</p><p>To work around this limitation, we can iterate in blocks of 16 elements and combine the results of independent comparisons of two 256-bit AVX2 registers using a bitwise <code>or</code>:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">needle</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">reg</span> <span class="n">x</span> <span class="o">=</span> <span class="n">_mm256_set1_epi32</span><span class="p">(</span><span class="n">needle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">_mm256_load_si256</span><span class="p">(</span> <span class="p">(</span><span class="n">reg</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">_mm256_load_si256</span><span class="p">(</span> <span class="p">(</span><span class="n">reg</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">_mm256_cmpeq_epi32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">_mm256_cmpeq_epi32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">m</span> <span class="o">=</span> <span class="n">_mm256_or_si256</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_mm256_testz_si256</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">_mm256_movemask_ps</span><span class="p">((</span><span class="n">__m256</span><span class="p">)</span> <span class="n">m2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                     <span class="o">+</span>  <span class="n">_mm256_movemask_ps</span><span class="p">((</span><span class="n">__m256</span><span class="p">)</span> <span class="n">m1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="n">__builtin_ctz</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>With this obstacle removed, the performance now peaks at ~34 GFLOPS. But why not 40? Shouldn’t it be twice as fast?</p><p>Here is how one iteration of the loop looks in assembly:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nf">vpcmpeqd</span> <span class="nv">ymm2</span><span class="p">,</span> <span class="nv">ymm1</span><span class="p">,</span> <span class="nv">YMMWORD</span> <span class="nv">PTR</span> <span class="nv">a</span><span class="p">[</span><span class="mi">0</span><span class="o">+</span><span class="nb">rdx</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">vpcmpeqd</span> <span class="nv">ymm3</span><span class="p">,</span> <span class="nv">ymm1</span><span class="p">,</span> <span class="nv">YMMWORD</span> <span class="nv">PTR</span> <span class="nv">a</span><span class="p">[</span><span class="mi">32</span><span class="o">+</span><span class="nb">rdx</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">vpor</span>     <span class="nv">ymm0</span><span class="p">,</span> <span class="nv">ymm3</span><span class="p">,</span> <span class="nv">ymm2</span>
</span></span><span class="line"><span class="cl"><span class="nf">vptest</span>   <span class="nv">ymm0</span><span class="p">,</span> <span class="nv">ymm0</span>
</span></span><span class="line"><span class="cl"><span class="nf">je</span>       <span class="nv">loop</span>
</span></span></code></pre></div><p>Every iteration, we need to execute 5 instructions. While the throughputs of all relevant execution ports allow to do that in one cycle on average, we can’t do that because the decode width of this particular CPU (Zen 2) is 4. Therefore, the performance is limited by ⅘ of what it could have been.</p><p>To mitigate this, we can once again double the number of SIMD blocks we process on each iteration:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">unsigned</span> <span class="nf">get_mask</span><span class="p">(</span><span class="n">reg</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">_mm256_movemask_ps</span><span class="p">((</span><span class="n">__m256</span><span class="p">)</span> <span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">reg</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">reg</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">reg</span> <span class="n">y</span> <span class="o">=</span> <span class="n">_mm256_load_si256</span><span class="p">(</span> <span class="p">(</span><span class="n">reg</span><span class="o">*</span><span class="p">)</span> <span class="n">p</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">_mm256_cmpeq_epi32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">needle</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">reg</span> <span class="n">x</span> <span class="o">=</span> <span class="n">_mm256_set1_epi32</span><span class="p">(</span><span class="n">needle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">cmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">cmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">m3</span> <span class="o">=</span> <span class="n">cmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">m4</span> <span class="o">=</span> <span class="n">cmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">24</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">m12</span> <span class="o">=</span> <span class="n">_mm256_or_si256</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">m34</span> <span class="o">=</span> <span class="n">_mm256_or_si256</span><span class="p">(</span><span class="n">m3</span><span class="p">,</span> <span class="n">m4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">m</span> <span class="o">=</span> <span class="n">_mm256_or_si256</span><span class="p">(</span><span class="n">m12</span><span class="p">,</span> <span class="n">m34</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_mm256_testz_si256</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">unsigned</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">get_mask</span><span class="p">(</span><span class="n">m4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                          <span class="o">+</span> <span class="p">(</span><span class="n">get_mask</span><span class="p">(</span><span class="n">m3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                          <span class="o">+</span> <span class="p">(</span><span class="n">get_mask</span><span class="p">(</span><span class="n">m2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                          <span class="o">+</span>  <span class="n">get_mask</span><span class="p">(</span><span class="n">m1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="n">__builtin_ctz</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>It now shows the throughput of 43 GFLOPS — or about 10x faster than the original scalar implementation.</p><p>Extending it to 64 values per cycle doesn’t help: small arrays suffer from the overhead of all these additional <code>movemask</code>-s when we hit the condition, and larger arrays are bottlenecked by <a href="/hpc/cpu-cache/bandwidth">memory bandwidth</a> anyway.</p><span class="anchor" id="counting-values"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/simd/masking/#counting-values">#</a>Counting Values</h3><p>As the final exercise, let’s find the count of a value in an array instead of just its first occurrence:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">count</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">cnt</span> <span class="o">+=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>To vectorize it, we just need to convert the comparison mask to either one or zero per element and calculate the sum:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">reg</span> <span class="n">ones</span> <span class="o">=</span> <span class="n">_mm256_set1_epi32</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">count</span><span class="p">(</span><span class="kt">int</span> <span class="n">needle</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">reg</span> <span class="n">x</span> <span class="o">=</span> <span class="n">_mm256_set1_epi32</span><span class="p">(</span><span class="n">needle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">reg</span> <span class="n">s</span> <span class="o">=</span> <span class="n">_mm256_setzero_si256</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">y</span> <span class="o">=</span> <span class="n">_mm256_load_si256</span><span class="p">(</span> <span class="p">(</span><span class="n">reg</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">m</span> <span class="o">=</span> <span class="n">_mm256_cmpeq_epi32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">m</span> <span class="o">=</span> <span class="n">_mm256_and_si256</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ones</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span> <span class="o">=</span> <span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">hsum</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Both implementations yield ~15 GFLOPS: the compiler can vectorize the first one all by itself.</p><p>But a trick that the compiler can’t find is to notice that the mask of all ones is <a href="/hpc/arithmetic/integer">minus one</a> when reinterpreted as an integer. So we can skip the and-the-lowest-bit part and use the mask itself, and then just negate the final result:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">count</span><span class="p">(</span><span class="kt">int</span> <span class="n">needle</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">reg</span> <span class="n">x</span> <span class="o">=</span> <span class="n">_mm256_set1_epi32</span><span class="p">(</span><span class="n">needle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">reg</span> <span class="n">s</span> <span class="o">=</span> <span class="n">_mm256_setzero_si256</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">y</span> <span class="o">=</span> <span class="n">_mm256_load_si256</span><span class="p">(</span> <span class="p">(</span><span class="n">reg</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">m</span> <span class="o">=</span> <span class="n">_mm256_cmpeq_epi32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span> <span class="o">=</span> <span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="n">hsum</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This doesn’t improve the performance in this particular architecture because the throughput is actually bottlenecked by updating <code>s</code>: there is a dependency on the previous iteration, so the loop can’t proceed faster than one iteration per CPU cycle. We can make use of <a href="../reduction#instruction-level-parallelism">instruction-level parallelism</a> if we split the accumulator in two:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">count</span><span class="p">(</span><span class="kt">int</span> <span class="n">needle</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">reg</span> <span class="n">x</span> <span class="o">=</span> <span class="n">_mm256_set1_epi32</span><span class="p">(</span><span class="n">needle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">reg</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">_mm256_setzero_si256</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">reg</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">_mm256_setzero_si256</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">_mm256_load_si256</span><span class="p">(</span> <span class="p">(</span><span class="n">reg</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">_mm256_load_si256</span><span class="p">(</span> <span class="p">(</span><span class="n">reg</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">_mm256_cmpeq_epi32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">_mm256_cmpeq_epi32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">s1</span> <span class="o">=</span> <span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">m1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">s2</span> <span class="o">=</span> <span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">m2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">s1</span> <span class="o">=</span> <span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="n">hsum</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>It now gives ~22 GFLOPS of performance, which is as high as it can get.</p><p>When adapting this code for shorter data types, keep in mind that the accumulator may overflow. To work around this, add another accumulator of larger size and regularly stop the loop to add the values in the local accumulator to it and then reset the local accumulator. For example, for 8-bit integers, this means creating another inner loop that does $\lfloor \frac{256-1}{8} \rfloor = 15$ iterations.</p></article><div class="nextprev"><div class="left"><a href="https://en.algorithmica.org/hpc/simd/reduction/" id="prev-article">← Reductions</a></div><div class="right"><a href="https://en.algorithmica.org/hpc/simd/shuffling/" id="next-article">In-Register Shuffles →</a></div></div>    
</body>
</html>