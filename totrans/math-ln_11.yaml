- en: 11\. TopologyÔÉÅ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://leanprover-community.github.io/mathematics_in_lean/C11_Topology.html](https://leanprover-community.github.io/mathematics_in_lean/C11_Topology.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*[Mathematics in Lean](index.html)* **   11\. Topology'
  prefs: []
  type: TYPE_NORMAL
- en: '[View page source](_sources/C11_Topology.rst.txt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Calculus is based on the concept of a function, which is used to model quantities
    that depend on one another. For example, it is common to study quantities that
    change over time. The notion of a *limit* is also fundamental. We may say that
    the limit of a function \(f(x)\) is a value \(b\) as \(x\) approaches a value
    \(a\), or that \(f(x)\) *converges to* \(b\) as \(x\) approaches \(a\). Equivalently,
    we may say that \(f(x)\) approaches \(b\) as \(x\) approaches a value \(a\), or
    that it *tends to* \(b\) as \(x\) tends to \(a\). We have already begun to consider
    such notions in [Section 3.6](C03_Logic.html#sequences-and-convergence).
  prefs: []
  type: TYPE_NORMAL
- en: '*Topology* is the abstract study of limits and continuity. Having covered the
    essentials of formalization in Chapters [2](C02_Basics.html#basics) to [7](C07_Structures.html#structures),
    in this chapter, we will explain how topological notions are formalized in Mathlib.
    Not only do topological abstractions apply in much greater generality, but they
    also, somewhat paradoxically, make it easier to reason about limits and continuity
    in concrete instances.'
  prefs: []
  type: TYPE_NORMAL
- en: Topological notions build on quite a few layers of mathematical structure. The
    first layer is naive set theory, as described in [Chapter 4](C04_Sets_and_Functions.html#sets-and-functions).
    The next layer is the theory of *filters*, which we will describe in [Section
    11.1](#filters). On top of that, we layer the theories of *topological spaces*,
    *metric spaces*, and a slightly more exotic intermediate notion called a *uniform
    space*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whereas previous chapters relied on mathematical notions that were likely familiar
    to you, the notion of a filter is less well known, even to many working mathematicians.
    The notion is essential, however, for formalizing mathematics effectively. Let
    us explain why. Let `f : ‚Ñù ‚Üí ‚Ñù` be any function. We can consider the limit of
    `f x` as `x` approaches some value `x‚ÇÄ`, but we can also consider the limit of
    `f x` as `x` approaches infinity or negative infinity. We can moreover consider
    the limit of `f x` as `x` approaches `x‚ÇÄ` from the right, conventionally written
    `x‚ÇÄ‚Å∫`, or from the left, written `x‚ÇÄ‚Åª`. There are variations where `x` approaches
    `x‚ÇÄ` or `x‚ÇÄ‚Å∫` or `x‚ÇÄ‚Åª` but is not allowed to take on the value `x‚ÇÄ` itself. This
    results in at least eight ways that `x` can approach something. We can also restrict
    to rational values of `x` or place other constraints on the domain, but let‚Äôs
    stick to those 8 cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a similar variety of options on the codomain: we can specify that `f
    x` approaches a value from the left or right, or that it approaches positive or
    negative infinity, and so on. For example, we may wish to say that `f x` tends
    to `+‚àû` when `x` tends to `x‚ÇÄ` from the right without being equal to `x‚ÇÄ`. This
    results in 64 different kinds of limit statements, and we haven‚Äôt even begun to
    deal with limits of sequences, as we did in [Section 3.6](C03_Logic.html#sequences-and-convergence).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is compounded even further when it comes to the supporting lemmas.
    For instance, limits compose: if `f x` tends to `y‚ÇÄ` when `x` tends to `x‚ÇÄ` and
    `g y` tends to `z‚ÇÄ` when `y` tends to `y‚ÇÄ` then `g ‚àò f x` tends to `z‚ÇÄ` when `x`
    tends to `x‚ÇÄ`. There are three notions of ‚Äútends to‚Äù at play here, each of which
    can be instantiated in any of the eight ways described in the previous paragraph.
    This results in 512 lemmas, a lot to have to add to a library! Informally, mathematicians
    generally prove two or three of these and simply note that the rest can be proved
    ‚Äúin the same way.‚Äù Formalizing mathematics requires making the relevant notion
    of ‚Äúsameness‚Äù fully explicit, and that is exactly what Bourbaki‚Äôs theory of filters
    manages to do.'
  prefs: []
  type: TYPE_NORMAL
- en: '## 11.1\. Filters[ÔÉÅ](#filters "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *filter* on a type `X` is a collection of sets of `X` that satisfies three
    conditions that we will spell out below. The notion supports two related ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: '*limits*, including all the kinds of limits discussed above: finite and infinite
    limits of sequences, finite and infinite limits of functions at a point or at
    infinity, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*things happening eventually*, including things happening for large enough
    `n : ‚Ñï`, or sufficiently near a point `x`, or for sufficiently close pairs of
    points, or almost everywhere in the sense of measure theory. Dually, filters can
    also express the idea of *things happening often*: for arbitrarily large `n`,
    at a point in any neighborhood of a given point, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The filters that correspond to these descriptions will be defined later in
    this section, but we can already name them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(atTop : Filter ‚Ñï)`, made of sets of `‚Ñï` containing `{n | n ‚â• N}` for some
    `N`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ùìù x`, made of neighborhoods of `x` in a topological space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ùì§ X`, made of entourages of a uniform space (uniform spaces generalize metric
    spaces and topological groups)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Œº.ae` , made of sets whose complement has zero measure with respect to a measure
    `Œº`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The general definition is as follows: a filter `F : Filter X` is a collection
    of sets `F.sets : Set (Set X)` satisfying the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`F.univ_sets : univ ‚àà F.sets`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F.sets_of_superset : ‚àÄ {U V}, U ‚àà F.sets ‚Üí U ‚äÜ V ‚Üí V ‚àà F.sets`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F.inter_sets : ‚àÄ {U V}, U ‚àà F.sets ‚Üí V ‚àà F.sets ‚Üí U ‚à© V ‚àà F.sets`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first condition says that the set of all elements of `X` belongs to `F.sets`.
    The second condition says that if `U` belongs to `F.sets` then anything containing
    `U` also belongs to `F.sets`. The third condition says that `F.sets` is closed
    under finite intersections. In Mathlib, a filter `F` is defined to be a structure
    bundling `F.sets` and its three properties, but the properties carry no additional
    data, and it is convenient to blur the distinction between `F` and `F.sets`. We
    therefore define `U ‚àà F` to mean `U ‚àà F.sets`. This explains why the word `sets`
    appears in the names of some lemmas that that mention `U ‚àà F`.
  prefs: []
  type: TYPE_NORMAL
- en: It may help to think of a filter as defining a notion of a ‚Äúsufficiently large‚Äù
    set. The first condition then says that `univ` is sufficiently large, the second
    one says that a set containing a sufficiently large set is sufficiently large
    and the third one says that the intersection of two sufficiently large sets is
    sufficiently large.
  prefs: []
  type: TYPE_NORMAL
- en: 'It may be even more useful to think of a filter on a type `X` as a generalized
    element of `Set X`. For instance, `atTop` is the ‚Äúset of very large numbers‚Äù and
    `ùìù x‚ÇÄ` is the ‚Äúset of points very close to `x‚ÇÄ`.‚Äù One manifestation of this view
    is that we can associate to any `s : Set X` the so-called *principal filter* consisting
    of all sets that contain `s`. This definition is already in Mathlib and has a
    notation `ùìü` (localized in the `Filter` namespace). For the purpose of demonstration,
    we ask you to take this opportunity to work out the definition here.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For our second example, we ask you to define the filter `atTop : Filter ‚Ñï`.
    (We could use any type with a preorder instead of `‚Ñï`.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also directly define the filter `ùìù x` of neighborhoods of any `x : ‚Ñù`.
    In the real numbers, a neighborhood of `x` is a set containing an open interval
    \((x_0 - \varepsilon, x_0 + \varepsilon)\), defined in Mathlib as `Ioo (x‚ÇÄ - Œµ)
    (x‚ÇÄ + Œµ)`. (This notion of a neighborhood is only a special case of a more general
    construction in Mathlib.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'With these examples, we can already define what it means for a function `f
    : X ‚Üí Y` to converge to some `G : Filter Y` along some `F : Filter X`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When `X` is `‚Ñï` and `Y` is `‚Ñù`, `Tendsto‚ÇÅ u atTop (ùìù x)` is equivalent to saying
    that the sequence `u : ‚Ñï ‚Üí ‚Ñù` converges to the real number `x`. When both `X`
    and `Y` are `‚Ñù`, `Tendsto f (ùìù x‚ÇÄ) (ùìù y‚ÇÄ)` is equivalent to the familiar notion
    \(\lim_{x \to x‚ÇÄ} f(x) = y‚ÇÄ\). All of the other kinds of limits mentioned in the
    introduction are also equivalent to instances of `Tendsto‚ÇÅ` for suitable choices
    of filters on the source and target.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The notion `Tendsto‚ÇÅ` above is definitionally equivalent to the notion `Tendsto`
    that is defined in Mathlib, but the latter is defined more abstractly. The problem
    with the definition of `Tendsto‚ÇÅ` is that it exposes a quantifier and elements
    of `G`, and it hides the intuition that we get by viewing filters as generalized
    sets. We can hide the quantifier `‚àÄ V` and make the intuition more salient by
    using more algebraic and set-theoretic machinery. The first ingredient is the
    *pushforward* operation \(f_*\) associated to any map `f : X ‚Üí Y`, denoted `Filter.map
    f` in Mathlib. Given a filter `F` on `X`, `Filter.map f F : Filter Y` is defined
    so that `V ‚àà Filter.map f F ‚Üî f ‚Åª¬π'' V ‚àà F` holds definitionally. In the example
    file we‚Äôve opened the `Filter` namespace so that `Filter.map` can be written as
    `map`. This means that we can rewrite the definition of `Tendsto` using the order
    relation on `Filter Y`, which is reversed inclusion of the set of members. In
    other words, given `G H : Filter Y`, we have `G ‚â§ H ‚Üî ‚àÄ V : Set Y, V ‚àà H ‚Üí V ‚àà
    G`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It may seem that the order relation on filters is backward. But recall that
    we can view filters on `X` as generalized elements of `Set X`, via the inclusion
    of `ùìü : Set X ‚Üí Filter X` which maps any set `s` to the corresponding principal
    filter. This inclusion is order preserving, so the order relation on `Filter`
    can indeed be seen as the natural inclusion relation between generalized sets.
    In this analogy, pushforward is analogous to the direct image. And, indeed, `map
    f (ùìü s) = ùìü (f '''' s)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now understand intuitively why a sequence `u : ‚Ñï ‚Üí ‚Ñù` converges to a
    point `x‚ÇÄ` if and only if we have `map u atTop ‚â§ ùìù x‚ÇÄ`. The inequality means the
    ‚Äúdirect image under `u`‚Äù of ‚Äúthe set of very big natural numbers‚Äù is ‚Äúincluded‚Äù
    in ‚Äúthe set of points very close to `x‚ÇÄ`.‚Äù'
  prefs: []
  type: TYPE_NORMAL
- en: As promised, the definition of `Tendsto‚ÇÇ` does not exhibit any quantifiers or
    sets. It also leverages the algebraic properties of the pushforward operation.
    First, each `Filter.map f` is monotone. And, second, `Filter.map` is compatible
    with composition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Together these two properties allow us to prove that limits compose, yielding
    in one shot all 512 variants of the composition lemma described in the introduction,
    and lots more. You can practice proving the following statement using either the
    definition of `Tendsto‚ÇÅ` in terms of the universal quantifier or the algebraic
    definition, together with the two lemmas above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The pushforward construction uses a map to push filters from the map source
    to the map target. There also a *pullback* operation, `Filter.comap`, going in
    the other direction. This generalizes the preimage operation on sets. For any
    map `f`, `Filter.map f` and `Filter.comap f` form what is known as a *Galois connection*,
    which is to say, they satisfy
  prefs: []
  type: TYPE_NORMAL
- en: '`Filter.map_le_iff_le_comap : Filter.map f F ‚â§ G ‚Üî F ‚â§ Filter.comap f G`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: for every `F` and `G`. This operation could be used to provided another formulation
    of `Tendsto` that would be provably (but not definitionally) equivalent to the
    one in Mathlib.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `comap` operation can be used to restrict filters to a subtype. For instance,
    suppose we have `f : ‚Ñù ‚Üí ‚Ñù`, `x‚ÇÄ : ‚Ñù` and `y‚ÇÄ : ‚Ñù`, and suppose we want to state
    that `f x` approaches `y‚ÇÄ` when `x` approaches `x‚ÇÄ` within the rational numbers.
    We can pull the filter `ùìù x‚ÇÄ` back to `‚Ñö` using the coercion map `(‚Üë) : ‚Ñö ‚Üí ‚Ñù`
    and state `Tendsto (f ‚àò (‚Üë) : ‚Ñö ‚Üí ‚Ñù) (comap (‚Üë) (ùìù x‚ÇÄ)) (ùìù y‚ÇÄ)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The pullback operation is also compatible with composition, but it is *contravariant*,
    which is to say, it reverses the order of the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs now shift attention to the plane `‚Ñù √ó ‚Ñù` and try to understand how the
    neighborhoods of a point `(x‚ÇÄ, y‚ÇÄ)` are related to `ùìù x‚ÇÄ` and `ùìù y‚ÇÄ`. There is
    a product operation `Filter.prod : Filter X ‚Üí Filter Y ‚Üí Filter (X √ó Y)`, denoted
    by `√óÀ¢`, which answers this question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The product operation is defined in terms of the pullback operation and the
    `inf` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`F √óÀ¢ G = (comap Prod.fst F) ‚äì (comap Prod.snd G)`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Here the `inf` operation refers to the lattice structure on `Filter X` for any
    type `X`, whereby `F ‚äì G` is the greatest filter that is smaller than both `F`
    and `G`. Thus the `inf` operation generalizes the notion of the intersection of
    sets.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of proofs in Mathlib use all of the aforementioned structure (`map`, `comap`,
    `inf`, `sup`, and `prod`) to give algebraic proofs about convergence without ever
    referring to members of filters. You can practice doing this in a proof of the
    following lemma, unfolding the definition of `Tendsto` and `Filter.prod` if needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The ordered type `Filter X` is actually a *complete* lattice, which is to say,
    there is a bottom element, there is a top element, and every set of filters on
    `X` has an `Inf` and a `Sup`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that given the second property in the definition of a filter (if `U` belongs
    to `F` then anything larger than `U` also belongs to `F`), the first property
    (the set of all inhabitants of `X` belongs to `F`) is equivalent to the property
    that `F` is not the empty collection of sets. This shouldn‚Äôt be confused with
    the more subtle question as to whether the empty set is an *element* of `F`. The
    definition of a filter does not prohibit `‚àÖ ‚àà F`, but if the empty set is in `F`
    then every set is in `F`, which is to say, `‚àÄ U : Set X, U ‚àà F`. In this case,
    `F` is a rather trivial filter, which is precisely the bottom element of the complete
    lattice `Filter X`. This contrasts with the definition of filters in Bourbaki,
    which doesn‚Äôt allow filters containing the empty set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we include the trivial filter in our definition, we sometimes need
    to explicitly assume nontriviality in some lemmas. In return, however, the theory
    has nicer global properties. We have already seen that including the trivial filter
    gives us a bottom element. It also allows us to define `principal : Set X ‚Üí Filter
    X`, which maps `‚àÖ` to `‚ä•`, without adding a precondition to rule out the empty
    set. And it allows us to define the pullback operation without a precondition
    as well. Indeed, it can happen that `comap f F = ‚ä•` although `F ‚â† ‚ä•`. For instance,
    given `x‚ÇÄ : ‚Ñù` and `s : Set ‚Ñù`, the pullback of `ùìù x‚ÇÄ` under the coercion from
    the subtype corresponding to `s` is nontrivial if and only if `x‚ÇÄ` belongs to
    the closure of `s`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to manage lemmas that do need to assume some filter is nontrivial,
    Mathlib has a type class `Filter.NeBot`, and the library has lemmas that assume
    `(F : Filter X) [F.NeBot]`. The instance database knows, for example, that `(atTop
    : Filter ‚Ñï).NeBot`, and it knows that pushing forward a nontrivial filter gives
    a nontrivial filter. As a result, a lemma assuming `[F.NeBot]` will automatically
    apply to `map u atTop` for any sequence `u`.'
  prefs: []
  type: TYPE_NORMAL
- en: Our tour of the algebraic properties of filters and their relation to limits
    is essentially done, but we have not yet justified our claim to have recaptured
    the usual limit notions. Superficially, it may seem that `Tendsto u atTop (ùìù x‚ÇÄ)`
    is stronger than the notion of convergence defined in [Section 3.6](C03_Logic.html#sequences-and-convergence)
    because we ask that *every* neighborhood of `x‚ÇÄ` has a preimage belonging to `atTop`,
    whereas the usual definition only requires this for the standard neighborhoods
    `Ioo (x‚ÇÄ - Œµ) (x‚ÇÄ + Œµ)`. The key is that, by definition, every neighborhood contains
    such a standard one. This observation leads to the notion of a *filter basis*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given `F : Filter X`, a family of sets `s : Œπ ‚Üí Set X` is a basis for `F` if
    for every set `U`, we have `U ‚àà F` if and only if it contains some `s i`. In other
    words, formally speaking, `s` is a basis if it satisfies `‚àÄ U : Set X, U ‚àà F ‚Üî
    ‚àÉ i, s i ‚äÜ U`. It is even more flexible to consider a predicate on `Œπ` that selects
    only some of the values `i` in the indexing type. In the case of `ùìù x‚ÇÄ`, we want
    `Œπ` to be `‚Ñù`, we write `Œµ` for `i`, and the predicate should select the positive
    values of `Œµ`. So the fact that the sets `Ioo¬† (x‚ÇÄ - Œµ) (x‚ÇÄ + Œµ)` form a basis
    for the neighborhood topology on `‚Ñù` is stated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There is also a nice basis for the filter `atTop`. The lemma `Filter.HasBasis.tendsto_iff`
    allows us to reformulate a statement of the form `Tendsto f F G` given bases for
    `F` and `G`. Putting these pieces together gives us essentially the notion of
    convergence that we used in [Section 3.6](C03_Logic.html#sequences-and-convergence).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We now show how filters facilitate working with properties that hold for sufficiently
    large numbers or for points that are sufficiently close to a given point. In [Section
    3.6](C03_Logic.html#sequences-and-convergence), we were often faced with the situation
    where we knew that some property `P n` holds for sufficiently large `n` and that
    some other property `Q n` holds for sufficiently large `n`. Using `cases` twice
    gave us `N_P` and `N_Q` satisfying `‚àÄ n ‚â• N_P, P n` and `‚àÄ n ‚â• N_Q, Q n`. Using
    `set N := max N_P N_Q`, we could eventually prove `‚àÄ n ‚â• N, P n ‚àß Q n`. Doing
    this repeatedly becomes tiresome.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do better by noting that the statement ‚Äú`P n` and `Q n` hold for large
    enough `n`‚Äù means that we have `{n | P n} ‚àà atTop` and `{n | Q n} ‚àà atTop`. The
    fact that `atTop` is a filter implies that the intersection of two elements of
    `atTop` is again in `atTop`, so we have `{n | P n ‚àß Q n} ‚àà atTop`. Writing `{n
    | P n} ‚àà atTop` is unpleasant, but we can use the more suggestive notation `‚àÄ·∂†
    n in atTop, P n`. Here the superscripted `f` stands for ‚ÄúFilter.‚Äù You can think
    of the notation as saying that for all `n` in the ‚Äúset of very large numbers,‚Äù
    `P n` holds. The `‚àÄ·∂†` notation stands for `Filter.Eventually`, and the lemma `Filter.Eventually.and`
    uses the intersection property of filters to do what we just described:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This notation is so convenient and intuitive that we also have specializations
    when `P` is an equality or inequality statement. For example, let `u` and `v`
    be two sequences of real numbers, and let us show that if `u n` and `v n` coincide
    for sufficiently large `n` then `u` tends to `x‚ÇÄ` if and only if `v` tends to
    `x‚ÇÄ`. First we‚Äôll use the generic `Eventually` and then the one specialized for
    the equality predicate, `EventuallyEq`. The two statements are definitionally
    equivalent so the same proof work in both cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It is instructive to review the definition of filters in terms of `Eventually`.
    Given `F : Filter X`, for any predicates `P` and `Q` on `X`,'
  prefs: []
  type: TYPE_NORMAL
- en: the condition `univ ‚àà F` ensures `(‚àÄ x, P x) ‚Üí ‚àÄ·∂† x in F, P x`,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the condition `U ‚àà F ‚Üí U ‚äÜ V ‚Üí V ‚àà F` ensures `(‚àÄ·∂† x in F, P x) ‚Üí (‚àÄ x, P x
    ‚Üí Q x) ‚Üí ‚àÄ·∂† x in F, Q x`, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the condition `U ‚àà F ‚Üí V ‚àà F ‚Üí U ‚à© V ‚àà F` ensures `(‚àÄ·∂† x in F, P x) ‚Üí (‚àÄ·∂† x
    in F, Q x) ‚Üí ‚àÄ·∂† x in F, P x ‚àß Q x`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The second item, corresponding to `Eventually.mono`, supports nice ways of
    using filters, especially when combined with `Eventually.and`. The `filter_upwards`
    tactic allows us to combine them. Compare:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Readers who know about measure theory will note that the filter `Œº.ae` of sets
    whose complement has measure zero (aka ‚Äúthe set consisting of almost every point‚Äù)
    is not very useful as the source or target of `Tendsto`, but it can be conveniently
    used with `Eventually` to say that a property holds for almost every point.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a dual version of `‚àÄ·∂† x in F, P x`, which is occasionally useful:
    `‚àÉ·∂† x in F, P x` means `{x | ¬¨P x} ‚àâ F`. For example, `‚àÉ·∂† n in atTop, P n` means
    there are arbitrarily large `n` such that `P n` holds. The `‚àÉ·∂†` notation stands
    for `Filter.Frequently`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a more sophisticated example, consider the following statement about a
    sequence `u`, a set `M`, and a value `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: If `u` converges to `x` and `u n` belongs to `M` for sufficiently large `n`
    then `x` is in the closure of `M`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This can be formalized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Tendsto u atTop (ùìù x) ‚Üí (‚àÄ·∂† n in atTop, u n ‚àà M) ‚Üí x ‚àà closure M`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is a special case of the theorem `mem_closure_of_tendsto` from the topology
    library. See if you can prove it using the quoted lemmas, using the fact that
    `ClusterPt x F` means `(ùìù x ‚äì F).NeBot` and that, by definition, the assumption
    `‚àÄ·∂† n in atTop, u n ‚àà M` means `M ‚àà map u atTop`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]  ## 11.2\. Metric spaces[ÔÉÅ](#metric-spaces "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples in the previous section focus on sequences of real numbers. In this
    section we will go up a bit in generality and focus on metric spaces. A metric
    space is a type `X` equipped with a distance function `dist : X ‚Üí X ‚Üí ‚Ñù` which
    is a generalization of the function `fun x y ‚Ü¶ |x - y|` from the case where `X
    = ‚Ñù`.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing such a space is easy and we will check all properties required from
    the distance function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note we also have variants where the distance can be infinite or where `dist
    a b` can be zero without having `a = b` or both. They are called `EMetricSpace`,
    `PseudoMetricSpace` and `PseudoEMetricSpace` respectively (here ‚Äúe‚Äù stands for
    ‚Äúextended‚Äù).
  prefs: []
  type: TYPE_NORMAL
- en: Note that our journey from `‚Ñù` to metric spaces jumped over the special case
    of normed spaces that also require linear algebra and will be explained as part
    of the calculus chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 11.2.1\. Convergence and continuity[ÔÉÅ](#convergence-and-continuity "Link to
    this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using distance functions, we can already define convergent sequences and continuous
    functions between metric spaces. They are actually defined in a more general setting
    covered in the next section, but we have lemmas recasting the definition in terms
    of distances.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: A *lot* of lemmas have some continuity assumptions, so we end up proving a lot
    of continuity results and there is a `continuity` tactic devoted to this task.
    Let‚Äôs prove a continuity statement that will be needed in an exercise below. Notice
    that Lean knows how to treat a product of two metric spaces as a metric space,
    so it makes sense to consider continuous functions from `X √ó X` to `‚Ñù`. In particular
    the (uncurried version of the) distance function is such a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This tactic is a bit slow, so it is also useful to know how to do it by hand.
    We first need to use that `fun p : X √ó X ‚Ü¶ f p.1` is continuous because it is
    the composition of `f`, which is continuous by assumption `hf`, and the projection
    `prod.fst` whose continuity is the content of the lemma `continuous_fst`. The
    composition property is `Continuous.comp` which is in the `Continuous` namespace
    so we can use dot notation to compress `Continuous.comp hf continuous_fst` into
    `hf.comp continuous_fst` which is actually more readable since it really reads
    as composing our assumption and our lemma. We can do the same for the second component
    to get continuity of `fun p : X √ó X ‚Ü¶ f p.2`. We then assemble those two continuities
    using `Continuous.prod_mk` to get `(hf.comp continuous_fst).prod_mk (hf.comp continuous_snd)
    : Continuous (fun p : X √ó X ‚Ü¶ (f p.1, f p.2))` and compose once more to get our
    full proof.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The combination of `Continuous.prod_mk` and `continuous_dist` via `Continuous.comp`
    feels clunky, even when heavily using dot notation as above. A more serious issue
    is that this nice proof requires a lot of planning. Lean accepts the above proof
    term because it is a full term proving a statement which is definitionally equivalent
    to our goal, the crucial definition to unfold being that of a composition of functions.
    Indeed our target function `fun p : X √ó X ‚Ü¶ dist (f p.1) (f p.2)` is not presented
    as a composition. The proof term we provided proves continuity of `dist ‚àò (fun
    p : X √ó X ‚Ü¶ (f p.1, f p.2))` which happens to be definitionally equal to our target
    function. But if we try to build this proof gradually using tactics starting with
    `apply continuous_dist.comp` then Lean‚Äôs elaborator will fail to recognize a composition
    and refuse to apply this lemma. It is especially bad at this when products of
    types are involved.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A better lemma to apply here is `Continuous.dist {f g : X ‚Üí Y} : Continuous
    f ‚Üí Continuous g ‚Üí Continuous (fun x ‚Ü¶ dist (f x) (g x))` which is nicer to Lean‚Äôs
    elaborator and also provides a shorter proof when directly providing a full proof
    term, as can be seen from the following two new proofs of the above statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that, without the elaboration issue coming from composition, another way
    to compress our proof would be to use `Continuous.prod_map` which is sometimes
    useful and gives as an alternate proof term `continuous_dist.comp (hf.prod_map
    hf)` which even shorter to type.
  prefs: []
  type: TYPE_NORMAL
- en: Since it is sad to decide between a version which is better for elaboration
    and a version which is shorter to type, let us wrap this discussion with a last
    bit of compression offered by `Continuous.fst'` which allows to compress `hf.comp
    continuous_fst` to `hf.fst'` (and the same with `snd`) and get our final proof,
    now bordering obfuscation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It‚Äôs your turn now to prove some continuity lemma. After trying the continuity
    tactic, you will need `Continuous.add`, `continuous_pow` and `continuous_id` to
    do it by hand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So far we saw continuity as a global notion, but one can also define continuity
    at a point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 11.2.2\. Balls, open sets and closed sets[ÔÉÅ](#balls-open-sets-and-closed-sets
    "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we have a distance function, the most important geometric definitions are
    (open) balls and closed balls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that r is any real number here, there is no sign restriction. Of course
    some statements do require a radius condition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Once we have balls, we can define open sets. They are actually defined in a
    more general setting covered in the next section, but we have lemmas recasting
    the definition in terms of balls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Then closed sets are sets whose complement is open. Their important property
    is they are closed under limits. The closure of a set is the smallest closed set
    containing it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Do the next exercise without using mem_closure_iff_seq_limit
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Remember from the filters sections that neighborhood filters play a big role
    in Mathlib. In the metric space context, the crucial point is that balls provide
    bases for those filters. The main lemmas here are `Metric.nhds_basis_ball` and
    `Metric.nhds_basis_closedBall` that claim this for open and closed balls with
    positive radius. The center point is an implicit argument so we can invoke `Filter.HasBasis.mem_iff`
    as in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 11.2.3\. Compactness[ÔÉÅ](#compactness "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Compactness is an important topological notion. It distinguishes subsets of
    a metric space that enjoy the same kind of properties as segments in the reals
    compared to other intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: Any sequence with values in a compact set has a subsequence that converges in
    this set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any continuous function on a nonempty compact set with values in real numbers
    is bounded and attains its bounds somewhere (this is called the extreme value
    theorem).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compact sets are closed sets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us first check that the unit interval in the reals is indeed a compact set,
    and then check the above claims for compact sets in general metric spaces. In
    the second statement we only need continuity on the given set so we will use `ContinuousOn`
    instead of `Continuous`, and we will give separate statements for the minimum
    and the maximum. Of course all these results are deduced from more general versions,
    some of which will be discussed in later sections.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also specify that a metric spaces is globally compact, using an extra
    `Prop`-valued type class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In a compact metric space any closed set is compact, this is `IsClosed.isCompact`.
  prefs: []
  type: TYPE_NORMAL
- en: 11.2.4\. Uniformly continuous functions[ÔÉÅ](#uniformly-continuous-functions "Link
    to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now turn to uniformity notions on metric spaces : uniformly continuous functions,
    Cauchy sequences and completeness. Again those are defined in a more general context
    but we have lemmas in the metric name space to access their elementary definitions.
    We start with uniform continuity.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In order to practice manipulating all those definitions, we will prove that
    continuous functions from a compact metric space to a metric space are uniformly
    continuous (we will see a more general version in a later section).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first give an informal sketch. Let `f : X ‚Üí Y` be a continuous function
    from a compact metric space to a metric space. We fix `Œµ > 0` and start looking
    for some `Œ¥`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let `œÜ : X √ó X ‚Üí ‚Ñù := fun p ‚Ü¶ dist (f p.1) (f p.2)` and let `K := { p : X √ó
    X | Œµ ‚â§ œÜ p }`. Observe `œÜ` is continuous since `f` and distance are continuous.
    And `K` is clearly closed (use `isClosed_le`) hence compact since `X` is compact.'
  prefs: []
  type: TYPE_NORMAL
- en: Then we discuss two possibilities using `eq_empty_or_nonempty`. If `K` is empty
    then we are clearly done (we can set `Œ¥ = 1` for instance). So let‚Äôs assume `K`
    is not empty, and use the extreme value theorem to choose `(x‚ÇÄ, x‚ÇÅ)` attaining
    the infimum of the distance function on `K`. We can then set `Œ¥ = dist x‚ÇÄ x‚ÇÅ`
    and check everything works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 11.2.5\. Completeness[ÔÉÅ](#completeness "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Cauchy sequence in a metric space is a sequence whose terms get closer and
    closer to each other. There are a couple of equivalent ways to state that idea.
    In particular converging sequences are Cauchy. The converse is true only in so-called
    *complete* spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We‚Äôll practice using this definition by proving a convenient criterion which
    is a special case of a criterion appearing in Mathlib. This is also a good opportunity
    to practice using big sums in a geometric context. In addition to the explanations
    from the filters section, you will probably need `tendsto_pow_atTop_nhds_zero_of_lt_one`,
    `Tendsto.mul` and `dist_le_range_sum_dist`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We are ready for the final boss of this section: Baire‚Äôs theorem for complete
    metric spaces! The proof skeleton below shows interesting techniques. It uses
    the `choose` tactic in its exclamation mark variant (you should experiment with
    removing this exclamation mark) and it shows how to define something inductively
    in the middle of a proof using `Nat.rec_on`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]  ## 11.3\. Topological spaces[ÔÉÅ](#topological-spaces "Link to this
    heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.1\. Fundamentals[ÔÉÅ](#fundamentals "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now go up in generality and introduce topological spaces. We will review
    the two main ways to define topological spaces and then explain how the category
    of topological spaces is much better behaved than the category of metric spaces.
    Note that we won‚Äôt be using Mathlib category theory here, only having a somewhat
    categorical point of view.
  prefs: []
  type: TYPE_NORMAL
- en: The first way to think about the transition from metric spaces to topological
    spaces is that we only remember the notion of open sets (or equivalently the notion
    of closed sets). From this point of view, a topological space is a type equipped
    with a collection of sets that are called open sets. This collection has to satisfy
    a number of axioms presented below (this collection is slightly redundant but
    we will ignore that).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Closed sets are then defined as sets whose complement is open. A function between
    topological spaces is (globally) continuous if all preimages of open sets are
    open.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'With this definition we already see that, compared to metric spaces, topological
    spaces only remember enough information to talk about continuous functions: two
    topological structures on a type are the same if and only if they have the same
    continuous functions (indeed the identity function will be continuous in both
    direction if and only if the two structures have the same open sets).'
  prefs: []
  type: TYPE_NORMAL
- en: 'However as soon as we move on to continuity at a point we see the limitations
    of the approach based on open sets. In Mathlib we frequently think of topological
    spaces as types equipped with a neighborhood filter `ùìù x` attached to each point
    `x` (the corresponding function `X ‚Üí Filter X` satisfies certain conditions explained
    further down). Remember from the filters section that these gadgets play two related
    roles. First `ùìù x` is seen as the generalized set of points of `X` that are close
    to `x`. And then it is seen as giving a way to say, for any predicate `P : X ‚Üí
    Prop`, that this predicate holds for points that are close enough to `x`. Let
    us state that `f : X ‚Üí Y` is continuous at `x`. The purely filtery way is to say
    that the direct image under `f` of the generalized set of points that are close
    to `x` is contained in the generalized set of points that are close to `f x`.
    Recall this is spelled either `map f (ùìù x) ‚â§ ùìù (f x)` or `Tendsto f (ùìù x) (ùìù (f
    x))`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'One can also spell it using both neighborhoods seen as ordinary sets and a
    neighborhood filter seen as a generalized set: ‚Äúfor any neighborhood `U` of `f
    x`, all points close to `x` are sent to `U`‚Äù. Note that the proof is again `Iff.rfl`,
    this point of view is definitionally equivalent to the previous one.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We now explain how to go from one point of view to the other. In terms of open
    sets, we can simply define members of `ùìù x` as sets that contain an open set containing
    `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To go in the other direction we need to discuss the condition that `ùìù : X ‚Üí
    Filter X` must satisfy in order to be the neighborhood function of a topology.'
  prefs: []
  type: TYPE_NORMAL
- en: The first constraint is that `ùìù x`, seen as a generalized set, contains the
    set `{x}` seen as the generalized set `pure x` (explaining this weird name would
    be too much of a digression, so we simply accept it for now). Another way to say
    it is that if a predicate holds for points close to `x` then it holds at `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then a more subtle requirement is that, for any predicate `P : X ‚Üí Prop` and
    any `x`, if `P y` holds for `y` close to `x` then for `y` close to `x` and `z`
    close to `y`, `P z` holds. More precisely we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Those two results characterize the functions `X ‚Üí Filter X` that are neighborhood
    functions for a topological space structure on `X`. There is a still a function
    `TopologicalSpace.mkOfNhds : (X ‚Üí Filter X) ‚Üí TopologicalSpace X` but it will
    give back its input as a neighborhood function only if it satisfies the above
    two constraints. More precisely we have a lemma `TopologicalSpace.nhds_mkOfNhds`
    saying that in a different way and our next exercise deduces this different way
    from how we stated it above.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note that `TopologicalSpace.mkOfNhds` is not so frequently used, but it still
    good to know in what precise sense the neighborhood filters is all there is in
    a topological space structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing to know in order to efficiently use topological spaces in Mathlib
    is that we use a lot of formal properties of `TopologicalSpace : Type u ‚Üí Type
    u`. From a purely mathematical point of view, those formal properties are a very
    clean way to explain how topological spaces solve issues that metric spaces have.
    From this point of view, the issues solved by topological spaces is that metric
    spaces enjoy very little functoriality, and have very bad categorical properties
    in general. This comes on top of the fact already discussed that metric spaces
    contain a lot of geometrical information that is not topologically relevant.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us focus on functoriality first. A metric space structure can be induced
    on a subset or, equivalently, it can be pulled back by an injective map. But that‚Äôs
    pretty much everything. They cannot be pulled back by general map or pushed forward,
    even by surjective maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular there is no sensible distance to put on a quotient of a metric
    space or on an uncountable product of metric spaces. Consider for instance the
    type `‚Ñù ‚Üí ‚Ñù`, seen as a product of copies of `‚Ñù` indexed by `‚Ñù`. We would like
    to say that pointwise convergence of sequences of functions is a respectable notion
    of convergence. But there is no distance on `‚Ñù ‚Üí ‚Ñù` that gives this notion of
    convergence. Relatedly, there is no distance ensuring that a map `f : X ‚Üí (‚Ñù ‚Üí
    ‚Ñù)` is continuous if and only if `fun x ‚Ü¶ f x t` is continuous for every `t :
    ‚Ñù`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now review the data used to solve all those issues. First we can use any
    map `f : X ‚Üí Y` to push or pull topologies from one side to the other. Those two
    operations form a Galois connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Those operations are compatible with composition of functions. As usual, pushing
    forward is covariant and pulling back is contravariant, see `coinduced_compose`
    and `induced_compose`. On paper we will use notations \(f_*T\) for `TopologicalSpace.coinduced
    f T` and \(f^*T\) for `TopologicalSpace.induced f T`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then the next big piece is a complete lattice structure on `TopologicalSpace
    X` for any given structure. If you think of topologies as being primarily the
    data of open sets then you expect the order relation on `TopologicalSpace X` to
    come from `Set (Set X)`, i.e. you expect `t ‚â§ t''` if a set `u` is open for `t''`
    as soon as it is open for `t`. However we already know that Mathlib focuses on
    neighborhoods more than open sets so, for any `x : X` we want the map from topological
    spaces to neighborhoods `fun T : TopologicalSpace X ‚Ü¶ @nhds X T x` to be order
    preserving. And we know the order relation on `Filter X` is designed to ensure
    an order preserving `principal : Set X ‚Üí Filter X`, allowing to see filters as
    generalized sets. So the order relation we do use on `TopologicalSpace X` is opposite
    to the one coming from `Set (Set X)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now we can recover continuity by combining the push-forward (or pull-back) operation
    with the order relation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'With this definition and the compatibility of push-forward and composition,
    we get for free the universal property that, for any topological space \(Z\),
    a function \(g : Y ‚Üí Z\) is continuous for the topology \(f_*T_X\) if and only
    if \(g ‚àò f\) is continuous.'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}g \text{ continuous } &‚áî g_*(f_*T_X) ‚â§ T_Z \\ &‚áî (g ‚àò f)_* T_X
    ‚â§ T_Z \\ &‚áî g ‚àò f \text{ continuous}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'So we already get quotient topologies (using the projection map as `f`). This
    wasn‚Äôt using that `TopologicalSpace X` is a complete lattice for all `X`. Let‚Äôs
    now see how all this structure proves the existence of the product topology by
    abstract non-sense. We considered the case of `‚Ñù ‚Üí ‚Ñù` above, but let‚Äôs now consider
    the general case of `Œ† i, X i` for some `Œπ : Type*` and `X : Œπ ‚Üí Type*`. We want,
    for any topological space `Z` and any function `f : Z ‚Üí Œ† i, X i`, that `f` is
    continuous if and only if `(fun x ‚Ü¶ x i) ‚àò f` is continuous for all `i`. Let us
    explore that constraint ‚Äúon paper‚Äù using notation \(p_i\) for the projection `(fun
    (x : Œ† i, X i) ‚Ü¶ x i)`:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}(‚àÄ i, p_i ‚àò f \text{ continuous}) &‚áî ‚àÄ i, (p_i ‚àò f)_* T_Z ‚â§ T_{X_i}
    \\ &‚áî ‚àÄ i, (p_i)_* f_* T_Z ‚â§ T_{X_i}\\ &‚áî ‚àÄ i, f_* T_Z ‚â§ (p_i)^*T_{X_i}\\ &‚áî f_*
    T_Z ‚â§ \inf \left[(p_i)^*T_{X_i}\right]\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'So we see that what is the topology we want on `Œ† i, X i`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This ends our tour of how Mathlib thinks that topological spaces fix defects
    of the theory of metric spaces by being a more functorial theory and having a
    complete lattice structure for any fixed type.
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.2\. Separation and countability[ÔÉÅ](#separation-and-countability "Link to
    this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We saw that the category of topological spaces have very nice properties. The
    price to pay for this is existence of rather pathological topological spaces.
    There are a number of assumptions you can make on a topological space to ensure
    its behavior is closer to what metric spaces do. The most important is `T2Space`,
    also called ‚ÄúHausdorff‚Äù, that will ensure that limits are unique. A stronger separation
    property is `T3Space` that ensures in addition the RegularSpace property: each
    point has a basis of closed neighborhoods.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in every topological space, each point has a basis of open neighborhood,
    by definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Our main goal is now to prove the basic theorem which allows extension by continuity.
    From Bourbaki‚Äôs general topology book, I.8.5, Theorem 1 (taking only the non-trivial
    implication):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let \(X\) be a topological space, \(A\) a dense subset of \(X\), \(f : A ‚Üí
    Y\) a continuous mapping of \(A\) into a \(T_3\) space \(Y\). If, for each \(x\)
    in \(X\), \(f(y)\) tends to a limit in \(Y\) when \(y\) tends to \(x\) while remaining
    in \(A\) then there exists a continuous extension \(œÜ\) of \(f\) to \(X\).'
  prefs: []
  type: TYPE_NORMAL
- en: Actually Mathlib contains a more general version of the above lemma, `IsDenseInducing.continuousAt_extend`,
    but we‚Äôll stick to Bourbaki‚Äôs version here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that, given `A : Set X`, `‚Ü•A` is the subtype associated to `A`, and
    Lean will automatically insert that funny up arrow when needed. And the (inclusion)
    coercion map is `(‚Üë) : A ‚Üí X`. The assumption ‚Äútends to \(x\) while remaining
    in \(A\)‚Äù corresponds to the pull-back filter `comap (‚Üë) (ùìù x)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs first prove an auxiliary lemma, extracted to simplify the context (in
    particular we don‚Äôt need Y to be a topological space here).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Let‚Äôs now turn to the main proof of the extension by continuity theorem.
  prefs: []
  type: TYPE_NORMAL
- en: 'When Lean needs a topology on `‚Ü•A` it will automatically use the induced topology.
    The only relevant lemma is `nhds_induced (‚Üë) : ‚àÄ a : ‚Ü•A, ùìù a = comap (‚Üë) (ùìù ‚Üëa)`
    (this is actually a general lemma about induced topologies).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The proof outline is:'
  prefs: []
  type: TYPE_NORMAL
- en: The main assumption and the axiom of choice give a function `œÜ` such that `‚àÄ
    x, Tendsto f (comap (‚Üë) (ùìù x)) (ùìù (œÜ x))` (because `Y` is Hausdorff, `œÜ` is entirely
    determined, but we won‚Äôt need that until we try to prove that `œÜ` indeed extends
    `f`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs first prove `œÜ` is continuous. Fix any `x : X`. Since `Y` is regular,
    it suffices to check that for every *closed* neighborhood `V''` of `œÜ x`, `œÜ ‚Åª¬π''
    V'' ‚àà ùìù x`. The limit assumption gives (through the auxiliary lemma above) some
    `V ‚àà ùìù x` such `IsOpen V ‚àß (‚Üë) ‚Åª¬π'' V ‚äÜ f ‚Åª¬π'' V''`. Since `V ‚àà ùìù x`, it suffices
    to prove `V ‚äÜ œÜ ‚Åª¬π'' V''`, i.e. `‚àÄ y ‚àà V, œÜ y ‚àà V''`. Let‚Äôs fix `y` in `V`. Because
    `V` is *open*, it is a neighborhood of `y`. In particular `(‚Üë) ‚Åª¬π'' V ‚àà comap
    (‚Üë) (ùìù y)` and a fortiori `f ‚Åª¬π'' V'' ‚àà comap (‚Üë) (ùìù y)`. In addition `comap (‚Üë)
    (ùìù y) ‚â† ‚ä•` because `A` is dense. Because we know `Tendsto f (comap (‚Üë) (ùìù y))
    (ùìù (œÜ y))` this implies `œÜ y ‚àà closure V''` and, since `V''` is closed, we have
    proved `œÜ y ‚àà V''`.'
  prefs: []
  type: TYPE_NORMAL
- en: It remains to prove that `œÜ` extends `f`. This is where the continuity of `f`
    enters the discussion, together with the fact that `Y` is Hausdorff.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In addition to separation property, the main kind of assumption you can make
    on a topological space to bring it closer to metric spaces is countability assumption.
    The main one is first countability asking that every point has a countable neighborhood
    basis. In particular this ensures that closure of sets can be understood using
    sequences.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 11.3.3\. Compactness[ÔÉÅ](#id5 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us now discuss how compactness is defined for topological spaces. As usual
    there are several ways to think about it and Mathlib goes for the filter version.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to define cluster points of filters. Given a filter `F` on a
    topological space `X`, a point `x : X` is a cluster point of `F` if `F`, seen
    as a generalized set, has non-empty intersection with the generalized set of points
    that are close to `x`.'
  prefs: []
  type: TYPE_NORMAL
- en: Then we can say that a set `s` is compact if every nonempty generalized set
    `F` contained in `s`, i.e. such that `F ‚â§ ùìü s`, has a cluster point in `s`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance if `F` is `map u atTop`, the image under `u : ‚Ñï ‚Üí X` of `atTop`,
    the generalized set of very large natural numbers, then the assumption `F ‚â§ ùìü
    s` means that `u n` belongs to `s` for `n` large enough. Saying that `x` is a
    cluster point of `map u atTop` says the image of very large numbers intersects
    the set of points that are close to `x`. In case `ùìù x` has a countable basis,
    we can interpret this as saying that `u` has a subsequence converging to `x`,
    and we get back what compactness looks like in metric spaces.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Cluster points behave nicely with continuous functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As an exercise, we will prove that the image of a compact set under a continuous
    map is compact. In addition to what we saw already, you should use `Filter.push_pull`
    and `NeBot.of_map`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'One can also express compactness in terms of open covers: `s` is compact if
    every family of open sets that cover `s` has a finite covering sub-family.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60] [Previous](C10_Linear_Algebra.html "10\. Linear algebra") [Next](C12_Differential_Calculus.html
    "12\. Differential Calculus")'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ¬© Copyright 2020-2025, Jeremy Avigad, Patrick Massot. Text licensed under CC
    BY 4.0.
  prefs: []
  type: TYPE_NORMAL
- en: Built with [Sphinx](https://www.sphinx-doc.org/) using a [theme](https://github.com/readthedocs/sphinx_rtd_theme)
    provided by [Read the Docs](https://readthedocs.org). Calculus is based on the
    concept of a function, which is used to model quantities that depend on one another.
    For example, it is common to study quantities that change over time. The notion
    of a *limit* is also fundamental. We may say that the limit of a function \(f(x)\)
    is a value \(b\) as \(x\) approaches a value \(a\), or that \(f(x)\) *converges
    to* \(b\) as \(x\) approaches \(a\). Equivalently, we may say that \(f(x)\) approaches
    \(b\) as \(x\) approaches a value \(a\), or that it *tends to* \(b\) as \(x\)
    tends to \(a\). We have already begun to consider such notions in [Section 3.6](C03_Logic.html#sequences-and-convergence).
  prefs: []
  type: TYPE_NORMAL
- en: '*Topology* is the abstract study of limits and continuity. Having covered the
    essentials of formalization in Chapters [2](C02_Basics.html#basics) to [7](C07_Structures.html#structures),
    in this chapter, we will explain how topological notions are formalized in Mathlib.
    Not only do topological abstractions apply in much greater generality, but they
    also, somewhat paradoxically, make it easier to reason about limits and continuity
    in concrete instances.'
  prefs: []
  type: TYPE_NORMAL
- en: Topological notions build on quite a few layers of mathematical structure. The
    first layer is naive set theory, as described in [Chapter 4](C04_Sets_and_Functions.html#sets-and-functions).
    The next layer is the theory of *filters*, which we will describe in [Section
    11.1](#filters). On top of that, we layer the theories of *topological spaces*,
    *metric spaces*, and a slightly more exotic intermediate notion called a *uniform
    space*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whereas previous chapters relied on mathematical notions that were likely familiar
    to you, the notion of a filter is less well known, even to many working mathematicians.
    The notion is essential, however, for formalizing mathematics effectively. Let
    us explain why. Let `f : ‚Ñù ‚Üí ‚Ñù` be any function. We can consider the limit of
    `f x` as `x` approaches some value `x‚ÇÄ`, but we can also consider the limit of
    `f x` as `x` approaches infinity or negative infinity. We can moreover consider
    the limit of `f x` as `x` approaches `x‚ÇÄ` from the right, conventionally written
    `x‚ÇÄ‚Å∫`, or from the left, written `x‚ÇÄ‚Åª`. There are variations where `x` approaches
    `x‚ÇÄ` or `x‚ÇÄ‚Å∫` or `x‚ÇÄ‚Åª` but is not allowed to take on the value `x‚ÇÄ` itself. This
    results in at least eight ways that `x` can approach something. We can also restrict
    to rational values of `x` or place other constraints on the domain, but let‚Äôs
    stick to those 8 cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a similar variety of options on the codomain: we can specify that `f
    x` approaches a value from the left or right, or that it approaches positive or
    negative infinity, and so on. For example, we may wish to say that `f x` tends
    to `+‚àû` when `x` tends to `x‚ÇÄ` from the right without being equal to `x‚ÇÄ`. This
    results in 64 different kinds of limit statements, and we haven‚Äôt even begun to
    deal with limits of sequences, as we did in [Section 3.6](C03_Logic.html#sequences-and-convergence).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is compounded even further when it comes to the supporting lemmas.
    For instance, limits compose: if `f x` tends to `y‚ÇÄ` when `x` tends to `x‚ÇÄ` and
    `g y` tends to `z‚ÇÄ` when `y` tends to `y‚ÇÄ` then `g ‚àò f x` tends to `z‚ÇÄ` when `x`
    tends to `x‚ÇÄ`. There are three notions of ‚Äútends to‚Äù at play here, each of which
    can be instantiated in any of the eight ways described in the previous paragraph.
    This results in 512 lemmas, a lot to have to add to a library! Informally, mathematicians
    generally prove two or three of these and simply note that the rest can be proved
    ‚Äúin the same way.‚Äù Formalizing mathematics requires making the relevant notion
    of ‚Äúsameness‚Äù fully explicit, and that is exactly what Bourbaki‚Äôs theory of filters
    manages to do.'
  prefs: []
  type: TYPE_NORMAL
- en: '## 11.1\. Filters[ÔÉÅ](#filters "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *filter* on a type `X` is a collection of sets of `X` that satisfies three
    conditions that we will spell out below. The notion supports two related ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: '*limits*, including all the kinds of limits discussed above: finite and infinite
    limits of sequences, finite and infinite limits of functions at a point or at
    infinity, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*things happening eventually*, including things happening for large enough
    `n : ‚Ñï`, or sufficiently near a point `x`, or for sufficiently close pairs of
    points, or almost everywhere in the sense of measure theory. Dually, filters can
    also express the idea of *things happening often*: for arbitrarily large `n`,
    at a point in any neighborhood of a given point, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The filters that correspond to these descriptions will be defined later in
    this section, but we can already name them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(atTop : Filter ‚Ñï)`, made of sets of `‚Ñï` containing `{n | n ‚â• N}` for some
    `N`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ùìù x`, made of neighborhoods of `x` in a topological space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ùì§ X`, made of entourages of a uniform space (uniform spaces generalize metric
    spaces and topological groups)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Œº.ae` , made of sets whose complement has zero measure with respect to a measure
    `Œº`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The general definition is as follows: a filter `F : Filter X` is a collection
    of sets `F.sets : Set (Set X)` satisfying the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`F.univ_sets : univ ‚àà F.sets`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F.sets_of_superset : ‚àÄ {U V}, U ‚àà F.sets ‚Üí U ‚äÜ V ‚Üí V ‚àà F.sets`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F.inter_sets : ‚àÄ {U V}, U ‚àà F.sets ‚Üí V ‚àà F.sets ‚Üí U ‚à© V ‚àà F.sets`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first condition says that the set of all elements of `X` belongs to `F.sets`.
    The second condition says that if `U` belongs to `F.sets` then anything containing
    `U` also belongs to `F.sets`. The third condition says that `F.sets` is closed
    under finite intersections. In Mathlib, a filter `F` is defined to be a structure
    bundling `F.sets` and its three properties, but the properties carry no additional
    data, and it is convenient to blur the distinction between `F` and `F.sets`. We
    therefore define `U ‚àà F` to mean `U ‚àà F.sets`. This explains why the word `sets`
    appears in the names of some lemmas that that mention `U ‚àà F`.
  prefs: []
  type: TYPE_NORMAL
- en: It may help to think of a filter as defining a notion of a ‚Äúsufficiently large‚Äù
    set. The first condition then says that `univ` is sufficiently large, the second
    one says that a set containing a sufficiently large set is sufficiently large
    and the third one says that the intersection of two sufficiently large sets is
    sufficiently large.
  prefs: []
  type: TYPE_NORMAL
- en: 'It may be even more useful to think of a filter on a type `X` as a generalized
    element of `Set X`. For instance, `atTop` is the ‚Äúset of very large numbers‚Äù and
    `ùìù x‚ÇÄ` is the ‚Äúset of points very close to `x‚ÇÄ`.‚Äù One manifestation of this view
    is that we can associate to any `s : Set X` the so-called *principal filter* consisting
    of all sets that contain `s`. This definition is already in Mathlib and has a
    notation `ùìü` (localized in the `Filter` namespace). For the purpose of demonstration,
    we ask you to take this opportunity to work out the definition here.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'For our second example, we ask you to define the filter `atTop : Filter ‚Ñï`.
    (We could use any type with a preorder instead of `‚Ñï`.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also directly define the filter `ùìù x` of neighborhoods of any `x : ‚Ñù`.
    In the real numbers, a neighborhood of `x` is a set containing an open interval
    \((x_0 - \varepsilon, x_0 + \varepsilon)\), defined in Mathlib as `Ioo (x‚ÇÄ - Œµ)
    (x‚ÇÄ + Œµ)`. (This notion of a neighborhood is only a special case of a more general
    construction in Mathlib.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'With these examples, we can already define what it means for a function `f
    : X ‚Üí Y` to converge to some `G : Filter Y` along some `F : Filter X`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'When `X` is `‚Ñï` and `Y` is `‚Ñù`, `Tendsto‚ÇÅ u atTop (ùìù x)` is equivalent to saying
    that the sequence `u : ‚Ñï ‚Üí ‚Ñù` converges to the real number `x`. When both `X`
    and `Y` are `‚Ñù`, `Tendsto f (ùìù x‚ÇÄ) (ùìù y‚ÇÄ)` is equivalent to the familiar notion
    \(\lim_{x \to x‚ÇÄ} f(x) = y‚ÇÄ\). All of the other kinds of limits mentioned in the
    introduction are also equivalent to instances of `Tendsto‚ÇÅ` for suitable choices
    of filters on the source and target.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The notion `Tendsto‚ÇÅ` above is definitionally equivalent to the notion `Tendsto`
    that is defined in Mathlib, but the latter is defined more abstractly. The problem
    with the definition of `Tendsto‚ÇÅ` is that it exposes a quantifier and elements
    of `G`, and it hides the intuition that we get by viewing filters as generalized
    sets. We can hide the quantifier `‚àÄ V` and make the intuition more salient by
    using more algebraic and set-theoretic machinery. The first ingredient is the
    *pushforward* operation \(f_*\) associated to any map `f : X ‚Üí Y`, denoted `Filter.map
    f` in Mathlib. Given a filter `F` on `X`, `Filter.map f F : Filter Y` is defined
    so that `V ‚àà Filter.map f F ‚Üî f ‚Åª¬π'' V ‚àà F` holds definitionally. In the example
    file we‚Äôve opened the `Filter` namespace so that `Filter.map` can be written as
    `map`. This means that we can rewrite the definition of `Tendsto` using the order
    relation on `Filter Y`, which is reversed inclusion of the set of members. In
    other words, given `G H : Filter Y`, we have `G ‚â§ H ‚Üî ‚àÄ V : Set Y, V ‚àà H ‚Üí V ‚àà
    G`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'It may seem that the order relation on filters is backward. But recall that
    we can view filters on `X` as generalized elements of `Set X`, via the inclusion
    of `ùìü : Set X ‚Üí Filter X` which maps any set `s` to the corresponding principal
    filter. This inclusion is order preserving, so the order relation on `Filter`
    can indeed be seen as the natural inclusion relation between generalized sets.
    In this analogy, pushforward is analogous to the direct image. And, indeed, `map
    f (ùìü s) = ùìü (f '''' s)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now understand intuitively why a sequence `u : ‚Ñï ‚Üí ‚Ñù` converges to a
    point `x‚ÇÄ` if and only if we have `map u atTop ‚â§ ùìù x‚ÇÄ`. The inequality means the
    ‚Äúdirect image under `u`‚Äù of ‚Äúthe set of very big natural numbers‚Äù is ‚Äúincluded‚Äù
    in ‚Äúthe set of points very close to `x‚ÇÄ`.‚Äù'
  prefs: []
  type: TYPE_NORMAL
- en: As promised, the definition of `Tendsto‚ÇÇ` does not exhibit any quantifiers or
    sets. It also leverages the algebraic properties of the pushforward operation.
    First, each `Filter.map f` is monotone. And, second, `Filter.map` is compatible
    with composition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Together these two properties allow us to prove that limits compose, yielding
    in one shot all 512 variants of the composition lemma described in the introduction,
    and lots more. You can practice proving the following statement using either the
    definition of `Tendsto‚ÇÅ` in terms of the universal quantifier or the algebraic
    definition, together with the two lemmas above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The pushforward construction uses a map to push filters from the map source
    to the map target. There also a *pullback* operation, `Filter.comap`, going in
    the other direction. This generalizes the preimage operation on sets. For any
    map `f`, `Filter.map f` and `Filter.comap f` form what is known as a *Galois connection*,
    which is to say, they satisfy
  prefs: []
  type: TYPE_NORMAL
- en: '`Filter.map_le_iff_le_comap : Filter.map f F ‚â§ G ‚Üî F ‚â§ Filter.comap f G`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: for every `F` and `G`. This operation could be used to provided another formulation
    of `Tendsto` that would be provably (but not definitionally) equivalent to the
    one in Mathlib.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `comap` operation can be used to restrict filters to a subtype. For instance,
    suppose we have `f : ‚Ñù ‚Üí ‚Ñù`, `x‚ÇÄ : ‚Ñù` and `y‚ÇÄ : ‚Ñù`, and suppose we want to state
    that `f x` approaches `y‚ÇÄ` when `x` approaches `x‚ÇÄ` within the rational numbers.
    We can pull the filter `ùìù x‚ÇÄ` back to `‚Ñö` using the coercion map `(‚Üë) : ‚Ñö ‚Üí ‚Ñù`
    and state `Tendsto (f ‚àò (‚Üë) : ‚Ñö ‚Üí ‚Ñù) (comap (‚Üë) (ùìù x‚ÇÄ)) (ùìù y‚ÇÄ)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The pullback operation is also compatible with composition, but it is *contravariant*,
    which is to say, it reverses the order of the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs now shift attention to the plane `‚Ñù √ó ‚Ñù` and try to understand how the
    neighborhoods of a point `(x‚ÇÄ, y‚ÇÄ)` are related to `ùìù x‚ÇÄ` and `ùìù y‚ÇÄ`. There is
    a product operation `Filter.prod : Filter X ‚Üí Filter Y ‚Üí Filter (X √ó Y)`, denoted
    by `√óÀ¢`, which answers this question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The product operation is defined in terms of the pullback operation and the
    `inf` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`F √óÀ¢ G = (comap Prod.fst F) ‚äì (comap Prod.snd G)`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Here the `inf` operation refers to the lattice structure on `Filter X` for any
    type `X`, whereby `F ‚äì G` is the greatest filter that is smaller than both `F`
    and `G`. Thus the `inf` operation generalizes the notion of the intersection of
    sets.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of proofs in Mathlib use all of the aforementioned structure (`map`, `comap`,
    `inf`, `sup`, and `prod`) to give algebraic proofs about convergence without ever
    referring to members of filters. You can practice doing this in a proof of the
    following lemma, unfolding the definition of `Tendsto` and `Filter.prod` if needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The ordered type `Filter X` is actually a *complete* lattice, which is to say,
    there is a bottom element, there is a top element, and every set of filters on
    `X` has an `Inf` and a `Sup`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that given the second property in the definition of a filter (if `U` belongs
    to `F` then anything larger than `U` also belongs to `F`), the first property
    (the set of all inhabitants of `X` belongs to `F`) is equivalent to the property
    that `F` is not the empty collection of sets. This shouldn‚Äôt be confused with
    the more subtle question as to whether the empty set is an *element* of `F`. The
    definition of a filter does not prohibit `‚àÖ ‚àà F`, but if the empty set is in `F`
    then every set is in `F`, which is to say, `‚àÄ U : Set X, U ‚àà F`. In this case,
    `F` is a rather trivial filter, which is precisely the bottom element of the complete
    lattice `Filter X`. This contrasts with the definition of filters in Bourbaki,
    which doesn‚Äôt allow filters containing the empty set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we include the trivial filter in our definition, we sometimes need
    to explicitly assume nontriviality in some lemmas. In return, however, the theory
    has nicer global properties. We have already seen that including the trivial filter
    gives us a bottom element. It also allows us to define `principal : Set X ‚Üí Filter
    X`, which maps `‚àÖ` to `‚ä•`, without adding a precondition to rule out the empty
    set. And it allows us to define the pullback operation without a precondition
    as well. Indeed, it can happen that `comap f F = ‚ä•` although `F ‚â† ‚ä•`. For instance,
    given `x‚ÇÄ : ‚Ñù` and `s : Set ‚Ñù`, the pullback of `ùìù x‚ÇÄ` under the coercion from
    the subtype corresponding to `s` is nontrivial if and only if `x‚ÇÄ` belongs to
    the closure of `s`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to manage lemmas that do need to assume some filter is nontrivial,
    Mathlib has a type class `Filter.NeBot`, and the library has lemmas that assume
    `(F : Filter X) [F.NeBot]`. The instance database knows, for example, that `(atTop
    : Filter ‚Ñï).NeBot`, and it knows that pushing forward a nontrivial filter gives
    a nontrivial filter. As a result, a lemma assuming `[F.NeBot]` will automatically
    apply to `map u atTop` for any sequence `u`.'
  prefs: []
  type: TYPE_NORMAL
- en: Our tour of the algebraic properties of filters and their relation to limits
    is essentially done, but we have not yet justified our claim to have recaptured
    the usual limit notions. Superficially, it may seem that `Tendsto u atTop (ùìù x‚ÇÄ)`
    is stronger than the notion of convergence defined in [Section 3.6](C03_Logic.html#sequences-and-convergence)
    because we ask that *every* neighborhood of `x‚ÇÄ` has a preimage belonging to `atTop`,
    whereas the usual definition only requires this for the standard neighborhoods
    `Ioo (x‚ÇÄ - Œµ) (x‚ÇÄ + Œµ)`. The key is that, by definition, every neighborhood contains
    such a standard one. This observation leads to the notion of a *filter basis*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given `F : Filter X`, a family of sets `s : Œπ ‚Üí Set X` is a basis for `F` if
    for every set `U`, we have `U ‚àà F` if and only if it contains some `s i`. In other
    words, formally speaking, `s` is a basis if it satisfies `‚àÄ U : Set X, U ‚àà F ‚Üî
    ‚àÉ i, s i ‚äÜ U`. It is even more flexible to consider a predicate on `Œπ` that selects
    only some of the values `i` in the indexing type. In the case of `ùìù x‚ÇÄ`, we want
    `Œπ` to be `‚Ñù`, we write `Œµ` for `i`, and the predicate should select the positive
    values of `Œµ`. So the fact that the sets `Ioo¬† (x‚ÇÄ - Œµ) (x‚ÇÄ + Œµ)` form a basis
    for the neighborhood topology on `‚Ñù` is stated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: There is also a nice basis for the filter `atTop`. The lemma `Filter.HasBasis.tendsto_iff`
    allows us to reformulate a statement of the form `Tendsto f F G` given bases for
    `F` and `G`. Putting these pieces together gives us essentially the notion of
    convergence that we used in [Section 3.6](C03_Logic.html#sequences-and-convergence).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: We now show how filters facilitate working with properties that hold for sufficiently
    large numbers or for points that are sufficiently close to a given point. In [Section
    3.6](C03_Logic.html#sequences-and-convergence), we were often faced with the situation
    where we knew that some property `P n` holds for sufficiently large `n` and that
    some other property `Q n` holds for sufficiently large `n`. Using `cases` twice
    gave us `N_P` and `N_Q` satisfying `‚àÄ n ‚â• N_P, P n` and `‚àÄ n ‚â• N_Q, Q n`. Using
    `set N := max N_P N_Q`, we could eventually prove `‚àÄ n ‚â• N, P n ‚àß Q n`. Doing
    this repeatedly becomes tiresome.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do better by noting that the statement ‚Äú`P n` and `Q n` hold for large
    enough `n`‚Äù means that we have `{n | P n} ‚àà atTop` and `{n | Q n} ‚àà atTop`. The
    fact that `atTop` is a filter implies that the intersection of two elements of
    `atTop` is again in `atTop`, so we have `{n | P n ‚àß Q n} ‚àà atTop`. Writing `{n
    | P n} ‚àà atTop` is unpleasant, but we can use the more suggestive notation `‚àÄ·∂†
    n in atTop, P n`. Here the superscripted `f` stands for ‚ÄúFilter.‚Äù You can think
    of the notation as saying that for all `n` in the ‚Äúset of very large numbers,‚Äù
    `P n` holds. The `‚àÄ·∂†` notation stands for `Filter.Eventually`, and the lemma `Filter.Eventually.and`
    uses the intersection property of filters to do what we just described:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This notation is so convenient and intuitive that we also have specializations
    when `P` is an equality or inequality statement. For example, let `u` and `v`
    be two sequences of real numbers, and let us show that if `u n` and `v n` coincide
    for sufficiently large `n` then `u` tends to `x‚ÇÄ` if and only if `v` tends to
    `x‚ÇÄ`. First we‚Äôll use the generic `Eventually` and then the one specialized for
    the equality predicate, `EventuallyEq`. The two statements are definitionally
    equivalent so the same proof work in both cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'It is instructive to review the definition of filters in terms of `Eventually`.
    Given `F : Filter X`, for any predicates `P` and `Q` on `X`,'
  prefs: []
  type: TYPE_NORMAL
- en: the condition `univ ‚àà F` ensures `(‚àÄ x, P x) ‚Üí ‚àÄ·∂† x in F, P x`,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the condition `U ‚àà F ‚Üí U ‚äÜ V ‚Üí V ‚àà F` ensures `(‚àÄ·∂† x in F, P x) ‚Üí (‚àÄ x, P x
    ‚Üí Q x) ‚Üí ‚àÄ·∂† x in F, Q x`, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the condition `U ‚àà F ‚Üí V ‚àà F ‚Üí U ‚à© V ‚àà F` ensures `(‚àÄ·∂† x in F, P x) ‚Üí (‚àÄ·∂† x
    in F, Q x) ‚Üí ‚àÄ·∂† x in F, P x ‚àß Q x`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The second item, corresponding to `Eventually.mono`, supports nice ways of
    using filters, especially when combined with `Eventually.and`. The `filter_upwards`
    tactic allows us to combine them. Compare:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Readers who know about measure theory will note that the filter `Œº.ae` of sets
    whose complement has measure zero (aka ‚Äúthe set consisting of almost every point‚Äù)
    is not very useful as the source or target of `Tendsto`, but it can be conveniently
    used with `Eventually` to say that a property holds for almost every point.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a dual version of `‚àÄ·∂† x in F, P x`, which is occasionally useful:
    `‚àÉ·∂† x in F, P x` means `{x | ¬¨P x} ‚àâ F`. For example, `‚àÉ·∂† n in atTop, P n` means
    there are arbitrarily large `n` such that `P n` holds. The `‚àÉ·∂†` notation stands
    for `Filter.Frequently`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a more sophisticated example, consider the following statement about a
    sequence `u`, a set `M`, and a value `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: If `u` converges to `x` and `u n` belongs to `M` for sufficiently large `n`
    then `x` is in the closure of `M`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This can be formalized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Tendsto u atTop (ùìù x) ‚Üí (‚àÄ·∂† n in atTop, u n ‚àà M) ‚Üí x ‚àà closure M`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is a special case of the theorem `mem_closure_of_tendsto` from the topology
    library. See if you can prove it using the quoted lemmas, using the fact that
    `ClusterPt x F` means `(ùìù x ‚äì F).NeBot` and that, by definition, the assumption
    `‚àÄ·∂† n in atTop, u n ‚àà M` means `M ‚àà map u atTop`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]  ## 11.2\. Metric spaces[ÔÉÅ](#metric-spaces "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples in the previous section focus on sequences of real numbers. In this
    section we will go up a bit in generality and focus on metric spaces. A metric
    space is a type `X` equipped with a distance function `dist : X ‚Üí X ‚Üí ‚Ñù` which
    is a generalization of the function `fun x y ‚Ü¶ |x - y|` from the case where `X
    = ‚Ñù`.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing such a space is easy and we will check all properties required from
    the distance function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Note we also have variants where the distance can be infinite or where `dist
    a b` can be zero without having `a = b` or both. They are called `EMetricSpace`,
    `PseudoMetricSpace` and `PseudoEMetricSpace` respectively (here ‚Äúe‚Äù stands for
    ‚Äúextended‚Äù).
  prefs: []
  type: TYPE_NORMAL
- en: Note that our journey from `‚Ñù` to metric spaces jumped over the special case
    of normed spaces that also require linear algebra and will be explained as part
    of the calculus chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 11.2.1\. Convergence and continuity[ÔÉÅ](#convergence-and-continuity "Link to
    this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using distance functions, we can already define convergent sequences and continuous
    functions between metric spaces. They are actually defined in a more general setting
    covered in the next section, but we have lemmas recasting the definition in terms
    of distances.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: A *lot* of lemmas have some continuity assumptions, so we end up proving a lot
    of continuity results and there is a `continuity` tactic devoted to this task.
    Let‚Äôs prove a continuity statement that will be needed in an exercise below. Notice
    that Lean knows how to treat a product of two metric spaces as a metric space,
    so it makes sense to consider continuous functions from `X √ó X` to `‚Ñù`. In particular
    the (uncurried version of the) distance function is such a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This tactic is a bit slow, so it is also useful to know how to do it by hand.
    We first need to use that `fun p : X √ó X ‚Ü¶ f p.1` is continuous because it is
    the composition of `f`, which is continuous by assumption `hf`, and the projection
    `prod.fst` whose continuity is the content of the lemma `continuous_fst`. The
    composition property is `Continuous.comp` which is in the `Continuous` namespace
    so we can use dot notation to compress `Continuous.comp hf continuous_fst` into
    `hf.comp continuous_fst` which is actually more readable since it really reads
    as composing our assumption and our lemma. We can do the same for the second component
    to get continuity of `fun p : X √ó X ‚Ü¶ f p.2`. We then assemble those two continuities
    using `Continuous.prod_mk` to get `(hf.comp continuous_fst).prod_mk (hf.comp continuous_snd)
    : Continuous (fun p : X √ó X ‚Ü¶ (f p.1, f p.2))` and compose once more to get our
    full proof.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The combination of `Continuous.prod_mk` and `continuous_dist` via `Continuous.comp`
    feels clunky, even when heavily using dot notation as above. A more serious issue
    is that this nice proof requires a lot of planning. Lean accepts the above proof
    term because it is a full term proving a statement which is definitionally equivalent
    to our goal, the crucial definition to unfold being that of a composition of functions.
    Indeed our target function `fun p : X √ó X ‚Ü¶ dist (f p.1) (f p.2)` is not presented
    as a composition. The proof term we provided proves continuity of `dist ‚àò (fun
    p : X √ó X ‚Ü¶ (f p.1, f p.2))` which happens to be definitionally equal to our target
    function. But if we try to build this proof gradually using tactics starting with
    `apply continuous_dist.comp` then Lean‚Äôs elaborator will fail to recognize a composition
    and refuse to apply this lemma. It is especially bad at this when products of
    types are involved.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A better lemma to apply here is `Continuous.dist {f g : X ‚Üí Y} : Continuous
    f ‚Üí Continuous g ‚Üí Continuous (fun x ‚Ü¶ dist (f x) (g x))` which is nicer to Lean‚Äôs
    elaborator and also provides a shorter proof when directly providing a full proof
    term, as can be seen from the following two new proofs of the above statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Note that, without the elaboration issue coming from composition, another way
    to compress our proof would be to use `Continuous.prod_map` which is sometimes
    useful and gives as an alternate proof term `continuous_dist.comp (hf.prod_map
    hf)` which even shorter to type.
  prefs: []
  type: TYPE_NORMAL
- en: Since it is sad to decide between a version which is better for elaboration
    and a version which is shorter to type, let us wrap this discussion with a last
    bit of compression offered by `Continuous.fst'` which allows to compress `hf.comp
    continuous_fst` to `hf.fst'` (and the same with `snd`) and get our final proof,
    now bordering obfuscation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: It‚Äôs your turn now to prove some continuity lemma. After trying the continuity
    tactic, you will need `Continuous.add`, `continuous_pow` and `continuous_id` to
    do it by hand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: So far we saw continuity as a global notion, but one can also define continuity
    at a point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 11.2.2\. Balls, open sets and closed sets[ÔÉÅ](#balls-open-sets-and-closed-sets
    "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we have a distance function, the most important geometric definitions are
    (open) balls and closed balls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Note that r is any real number here, there is no sign restriction. Of course
    some statements do require a radius condition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Once we have balls, we can define open sets. They are actually defined in a
    more general setting covered in the next section, but we have lemmas recasting
    the definition in terms of balls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Then closed sets are sets whose complement is open. Their important property
    is they are closed under limits. The closure of a set is the smallest closed set
    containing it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Do the next exercise without using mem_closure_iff_seq_limit
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Remember from the filters sections that neighborhood filters play a big role
    in Mathlib. In the metric space context, the crucial point is that balls provide
    bases for those filters. The main lemmas here are `Metric.nhds_basis_ball` and
    `Metric.nhds_basis_closedBall` that claim this for open and closed balls with
    positive radius. The center point is an implicit argument so we can invoke `Filter.HasBasis.mem_iff`
    as in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 11.2.3\. Compactness[ÔÉÅ](#compactness "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Compactness is an important topological notion. It distinguishes subsets of
    a metric space that enjoy the same kind of properties as segments in the reals
    compared to other intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: Any sequence with values in a compact set has a subsequence that converges in
    this set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any continuous function on a nonempty compact set with values in real numbers
    is bounded and attains its bounds somewhere (this is called the extreme value
    theorem).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compact sets are closed sets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us first check that the unit interval in the reals is indeed a compact set,
    and then check the above claims for compact sets in general metric spaces. In
    the second statement we only need continuity on the given set so we will use `ContinuousOn`
    instead of `Continuous`, and we will give separate statements for the minimum
    and the maximum. Of course all these results are deduced from more general versions,
    some of which will be discussed in later sections.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also specify that a metric spaces is globally compact, using an extra
    `Prop`-valued type class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: In a compact metric space any closed set is compact, this is `IsClosed.isCompact`.
  prefs: []
  type: TYPE_NORMAL
- en: 11.2.4\. Uniformly continuous functions[ÔÉÅ](#uniformly-continuous-functions "Link
    to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now turn to uniformity notions on metric spaces : uniformly continuous functions,
    Cauchy sequences and completeness. Again those are defined in a more general context
    but we have lemmas in the metric name space to access their elementary definitions.
    We start with uniform continuity.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: In order to practice manipulating all those definitions, we will prove that
    continuous functions from a compact metric space to a metric space are uniformly
    continuous (we will see a more general version in a later section).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first give an informal sketch. Let `f : X ‚Üí Y` be a continuous function
    from a compact metric space to a metric space. We fix `Œµ > 0` and start looking
    for some `Œ¥`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let `œÜ : X √ó X ‚Üí ‚Ñù := fun p ‚Ü¶ dist (f p.1) (f p.2)` and let `K := { p : X √ó
    X | Œµ ‚â§ œÜ p }`. Observe `œÜ` is continuous since `f` and distance are continuous.
    And `K` is clearly closed (use `isClosed_le`) hence compact since `X` is compact.'
  prefs: []
  type: TYPE_NORMAL
- en: Then we discuss two possibilities using `eq_empty_or_nonempty`. If `K` is empty
    then we are clearly done (we can set `Œ¥ = 1` for instance). So let‚Äôs assume `K`
    is not empty, and use the extreme value theorem to choose `(x‚ÇÄ, x‚ÇÅ)` attaining
    the infimum of the distance function on `K`. We can then set `Œ¥ = dist x‚ÇÄ x‚ÇÅ`
    and check everything works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 11.2.5\. Completeness[ÔÉÅ](#completeness "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Cauchy sequence in a metric space is a sequence whose terms get closer and
    closer to each other. There are a couple of equivalent ways to state that idea.
    In particular converging sequences are Cauchy. The converse is true only in so-called
    *complete* spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: We‚Äôll practice using this definition by proving a convenient criterion which
    is a special case of a criterion appearing in Mathlib. This is also a good opportunity
    to practice using big sums in a geometric context. In addition to the explanations
    from the filters section, you will probably need `tendsto_pow_atTop_nhds_zero_of_lt_one`,
    `Tendsto.mul` and `dist_le_range_sum_dist`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'We are ready for the final boss of this section: Baire‚Äôs theorem for complete
    metric spaces! The proof skeleton below shows interesting techniques. It uses
    the `choose` tactic in its exclamation mark variant (you should experiment with
    removing this exclamation mark) and it shows how to define something inductively
    in the middle of a proof using `Nat.rec_on`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]  ## 11.3\. Topological spaces[ÔÉÅ](#topological-spaces "Link to this
    heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.1\. Fundamentals[ÔÉÅ](#fundamentals "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now go up in generality and introduce topological spaces. We will review
    the two main ways to define topological spaces and then explain how the category
    of topological spaces is much better behaved than the category of metric spaces.
    Note that we won‚Äôt be using Mathlib category theory here, only having a somewhat
    categorical point of view.
  prefs: []
  type: TYPE_NORMAL
- en: The first way to think about the transition from metric spaces to topological
    spaces is that we only remember the notion of open sets (or equivalently the notion
    of closed sets). From this point of view, a topological space is a type equipped
    with a collection of sets that are called open sets. This collection has to satisfy
    a number of axioms presented below (this collection is slightly redundant but
    we will ignore that).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Closed sets are then defined as sets whose complement is open. A function between
    topological spaces is (globally) continuous if all preimages of open sets are
    open.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'With this definition we already see that, compared to metric spaces, topological
    spaces only remember enough information to talk about continuous functions: two
    topological structures on a type are the same if and only if they have the same
    continuous functions (indeed the identity function will be continuous in both
    direction if and only if the two structures have the same open sets).'
  prefs: []
  type: TYPE_NORMAL
- en: 'However as soon as we move on to continuity at a point we see the limitations
    of the approach based on open sets. In Mathlib we frequently think of topological
    spaces as types equipped with a neighborhood filter `ùìù x` attached to each point
    `x` (the corresponding function `X ‚Üí Filter X` satisfies certain conditions explained
    further down). Remember from the filters section that these gadgets play two related
    roles. First `ùìù x` is seen as the generalized set of points of `X` that are close
    to `x`. And then it is seen as giving a way to say, for any predicate `P : X ‚Üí
    Prop`, that this predicate holds for points that are close enough to `x`. Let
    us state that `f : X ‚Üí Y` is continuous at `x`. The purely filtery way is to say
    that the direct image under `f` of the generalized set of points that are close
    to `x` is contained in the generalized set of points that are close to `f x`.
    Recall this is spelled either `map f (ùìù x) ‚â§ ùìù (f x)` or `Tendsto f (ùìù x) (ùìù (f
    x))`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'One can also spell it using both neighborhoods seen as ordinary sets and a
    neighborhood filter seen as a generalized set: ‚Äúfor any neighborhood `U` of `f
    x`, all points close to `x` are sent to `U`‚Äù. Note that the proof is again `Iff.rfl`,
    this point of view is definitionally equivalent to the previous one.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: We now explain how to go from one point of view to the other. In terms of open
    sets, we can simply define members of `ùìù x` as sets that contain an open set containing
    `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'To go in the other direction we need to discuss the condition that `ùìù : X ‚Üí
    Filter X` must satisfy in order to be the neighborhood function of a topology.'
  prefs: []
  type: TYPE_NORMAL
- en: The first constraint is that `ùìù x`, seen as a generalized set, contains the
    set `{x}` seen as the generalized set `pure x` (explaining this weird name would
    be too much of a digression, so we simply accept it for now). Another way to say
    it is that if a predicate holds for points close to `x` then it holds at `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Then a more subtle requirement is that, for any predicate `P : X ‚Üí Prop` and
    any `x`, if `P y` holds for `y` close to `x` then for `y` close to `x` and `z`
    close to `y`, `P z` holds. More precisely we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Those two results characterize the functions `X ‚Üí Filter X` that are neighborhood
    functions for a topological space structure on `X`. There is a still a function
    `TopologicalSpace.mkOfNhds : (X ‚Üí Filter X) ‚Üí TopologicalSpace X` but it will
    give back its input as a neighborhood function only if it satisfies the above
    two constraints. More precisely we have a lemma `TopologicalSpace.nhds_mkOfNhds`
    saying that in a different way and our next exercise deduces this different way
    from how we stated it above.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Note that `TopologicalSpace.mkOfNhds` is not so frequently used, but it still
    good to know in what precise sense the neighborhood filters is all there is in
    a topological space structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing to know in order to efficiently use topological spaces in Mathlib
    is that we use a lot of formal properties of `TopologicalSpace : Type u ‚Üí Type
    u`. From a purely mathematical point of view, those formal properties are a very
    clean way to explain how topological spaces solve issues that metric spaces have.
    From this point of view, the issues solved by topological spaces is that metric
    spaces enjoy very little functoriality, and have very bad categorical properties
    in general. This comes on top of the fact already discussed that metric spaces
    contain a lot of geometrical information that is not topologically relevant.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us focus on functoriality first. A metric space structure can be induced
    on a subset or, equivalently, it can be pulled back by an injective map. But that‚Äôs
    pretty much everything. They cannot be pulled back by general map or pushed forward,
    even by surjective maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular there is no sensible distance to put on a quotient of a metric
    space or on an uncountable product of metric spaces. Consider for instance the
    type `‚Ñù ‚Üí ‚Ñù`, seen as a product of copies of `‚Ñù` indexed by `‚Ñù`. We would like
    to say that pointwise convergence of sequences of functions is a respectable notion
    of convergence. But there is no distance on `‚Ñù ‚Üí ‚Ñù` that gives this notion of
    convergence. Relatedly, there is no distance ensuring that a map `f : X ‚Üí (‚Ñù ‚Üí
    ‚Ñù)` is continuous if and only if `fun x ‚Ü¶ f x t` is continuous for every `t :
    ‚Ñù`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now review the data used to solve all those issues. First we can use any
    map `f : X ‚Üí Y` to push or pull topologies from one side to the other. Those two
    operations form a Galois connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Those operations are compatible with composition of functions. As usual, pushing
    forward is covariant and pulling back is contravariant, see `coinduced_compose`
    and `induced_compose`. On paper we will use notations \(f_*T\) for `TopologicalSpace.coinduced
    f T` and \(f^*T\) for `TopologicalSpace.induced f T`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then the next big piece is a complete lattice structure on `TopologicalSpace
    X` for any given structure. If you think of topologies as being primarily the
    data of open sets then you expect the order relation on `TopologicalSpace X` to
    come from `Set (Set X)`, i.e. you expect `t ‚â§ t''` if a set `u` is open for `t''`
    as soon as it is open for `t`. However we already know that Mathlib focuses on
    neighborhoods more than open sets so, for any `x : X` we want the map from topological
    spaces to neighborhoods `fun T : TopologicalSpace X ‚Ü¶ @nhds X T x` to be order
    preserving. And we know the order relation on `Filter X` is designed to ensure
    an order preserving `principal : Set X ‚Üí Filter X`, allowing to see filters as
    generalized sets. So the order relation we do use on `TopologicalSpace X` is opposite
    to the one coming from `Set (Set X)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Now we can recover continuity by combining the push-forward (or pull-back) operation
    with the order relation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'With this definition and the compatibility of push-forward and composition,
    we get for free the universal property that, for any topological space \(Z\),
    a function \(g : Y ‚Üí Z\) is continuous for the topology \(f_*T_X\) if and only
    if \(g ‚àò f\) is continuous.'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}g \text{ continuous } &‚áî g_*(f_*T_X) ‚â§ T_Z \\ &‚áî (g ‚àò f)_* T_X
    ‚â§ T_Z \\ &‚áî g ‚àò f \text{ continuous}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'So we already get quotient topologies (using the projection map as `f`). This
    wasn‚Äôt using that `TopologicalSpace X` is a complete lattice for all `X`. Let‚Äôs
    now see how all this structure proves the existence of the product topology by
    abstract non-sense. We considered the case of `‚Ñù ‚Üí ‚Ñù` above, but let‚Äôs now consider
    the general case of `Œ† i, X i` for some `Œπ : Type*` and `X : Œπ ‚Üí Type*`. We want,
    for any topological space `Z` and any function `f : Z ‚Üí Œ† i, X i`, that `f` is
    continuous if and only if `(fun x ‚Ü¶ x i) ‚àò f` is continuous for all `i`. Let us
    explore that constraint ‚Äúon paper‚Äù using notation \(p_i\) for the projection `(fun
    (x : Œ† i, X i) ‚Ü¶ x i)`:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}(‚àÄ i, p_i ‚àò f \text{ continuous}) &‚áî ‚àÄ i, (p_i ‚àò f)_* T_Z ‚â§ T_{X_i}
    \\ &‚áî ‚àÄ i, (p_i)_* f_* T_Z ‚â§ T_{X_i}\\ &‚áî ‚àÄ i, f_* T_Z ‚â§ (p_i)^*T_{X_i}\\ &‚áî f_*
    T_Z ‚â§ \inf \left[(p_i)^*T_{X_i}\right]\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'So we see that what is the topology we want on `Œ† i, X i`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: This ends our tour of how Mathlib thinks that topological spaces fix defects
    of the theory of metric spaces by being a more functorial theory and having a
    complete lattice structure for any fixed type.
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.2\. Separation and countability[ÔÉÅ](#separation-and-countability "Link to
    this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We saw that the category of topological spaces have very nice properties. The
    price to pay for this is existence of rather pathological topological spaces.
    There are a number of assumptions you can make on a topological space to ensure
    its behavior is closer to what metric spaces do. The most important is `T2Space`,
    also called ‚ÄúHausdorff‚Äù, that will ensure that limits are unique. A stronger separation
    property is `T3Space` that ensures in addition the RegularSpace property: each
    point has a basis of closed neighborhoods.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in every topological space, each point has a basis of open neighborhood,
    by definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Our main goal is now to prove the basic theorem which allows extension by continuity.
    From Bourbaki‚Äôs general topology book, I.8.5, Theorem 1 (taking only the non-trivial
    implication):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let \(X\) be a topological space, \(A\) a dense subset of \(X\), \(f : A ‚Üí
    Y\) a continuous mapping of \(A\) into a \(T_3\) space \(Y\). If, for each \(x\)
    in \(X\), \(f(y)\) tends to a limit in \(Y\) when \(y\) tends to \(x\) while remaining
    in \(A\) then there exists a continuous extension \(œÜ\) of \(f\) to \(X\).'
  prefs: []
  type: TYPE_NORMAL
- en: Actually Mathlib contains a more general version of the above lemma, `IsDenseInducing.continuousAt_extend`,
    but we‚Äôll stick to Bourbaki‚Äôs version here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that, given `A : Set X`, `‚Ü•A` is the subtype associated to `A`, and
    Lean will automatically insert that funny up arrow when needed. And the (inclusion)
    coercion map is `(‚Üë) : A ‚Üí X`. The assumption ‚Äútends to \(x\) while remaining
    in \(A\)‚Äù corresponds to the pull-back filter `comap (‚Üë) (ùìù x)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs first prove an auxiliary lemma, extracted to simplify the context (in
    particular we don‚Äôt need Y to be a topological space here).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Let‚Äôs now turn to the main proof of the extension by continuity theorem.
  prefs: []
  type: TYPE_NORMAL
- en: 'When Lean needs a topology on `‚Ü•A` it will automatically use the induced topology.
    The only relevant lemma is `nhds_induced (‚Üë) : ‚àÄ a : ‚Ü•A, ùìù a = comap (‚Üë) (ùìù ‚Üëa)`
    (this is actually a general lemma about induced topologies).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The proof outline is:'
  prefs: []
  type: TYPE_NORMAL
- en: The main assumption and the axiom of choice give a function `œÜ` such that `‚àÄ
    x, Tendsto f (comap (‚Üë) (ùìù x)) (ùìù (œÜ x))` (because `Y` is Hausdorff, `œÜ` is entirely
    determined, but we won‚Äôt need that until we try to prove that `œÜ` indeed extends
    `f`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs first prove `œÜ` is continuous. Fix any `x : X`. Since `Y` is regular,
    it suffices to check that for every *closed* neighborhood `V''` of `œÜ x`, `œÜ ‚Åª¬π''
    V'' ‚àà ùìù x`. The limit assumption gives (through the auxiliary lemma above) some
    `V ‚àà ùìù x` such `IsOpen V ‚àß (‚Üë) ‚Åª¬π'' V ‚äÜ f ‚Åª¬π'' V''`. Since `V ‚àà ùìù x`, it suffices
    to prove `V ‚äÜ œÜ ‚Åª¬π'' V''`, i.e. `‚àÄ y ‚àà V, œÜ y ‚àà V''`. Let‚Äôs fix `y` in `V`. Because
    `V` is *open*, it is a neighborhood of `y`. In particular `(‚Üë) ‚Åª¬π'' V ‚àà comap
    (‚Üë) (ùìù y)` and a fortiori `f ‚Åª¬π'' V'' ‚àà comap (‚Üë) (ùìù y)`. In addition `comap (‚Üë)
    (ùìù y) ‚â† ‚ä•` because `A` is dense. Because we know `Tendsto f (comap (‚Üë) (ùìù y))
    (ùìù (œÜ y))` this implies `œÜ y ‚àà closure V''` and, since `V''` is closed, we have
    proved `œÜ y ‚àà V''`.'
  prefs: []
  type: TYPE_NORMAL
- en: It remains to prove that `œÜ` extends `f`. This is where the continuity of `f`
    enters the discussion, together with the fact that `Y` is Hausdorff.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: In addition to separation property, the main kind of assumption you can make
    on a topological space to bring it closer to metric spaces is countability assumption.
    The main one is first countability asking that every point has a countable neighborhood
    basis. In particular this ensures that closure of sets can be understood using
    sequences.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 11.3.3\. Compactness[ÔÉÅ](#id5 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us now discuss how compactness is defined for topological spaces. As usual
    there are several ways to think about it and Mathlib goes for the filter version.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to define cluster points of filters. Given a filter `F` on a
    topological space `X`, a point `x : X` is a cluster point of `F` if `F`, seen
    as a generalized set, has non-empty intersection with the generalized set of points
    that are close to `x`.'
  prefs: []
  type: TYPE_NORMAL
- en: Then we can say that a set `s` is compact if every nonempty generalized set
    `F` contained in `s`, i.e. such that `F ‚â§ ùìü s`, has a cluster point in `s`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance if `F` is `map u atTop`, the image under `u : ‚Ñï ‚Üí X` of `atTop`,
    the generalized set of very large natural numbers, then the assumption `F ‚â§ ùìü
    s` means that `u n` belongs to `s` for `n` large enough. Saying that `x` is a
    cluster point of `map u atTop` says the image of very large numbers intersects
    the set of points that are close to `x`. In case `ùìù x` has a countable basis,
    we can interpret this as saying that `u` has a subsequence converging to `x`,
    and we get back what compactness looks like in metric spaces.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Cluster points behave nicely with continuous functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: As an exercise, we will prove that the image of a compact set under a continuous
    map is compact. In addition to what we saw already, you should use `Filter.push_pull`
    and `NeBot.of_map`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'One can also express compactness in terms of open covers: `s` is compact if
    every family of open sets that cover `s` has a finite covering sub-family.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]  ## 11.1\. Filters[ÔÉÅ](#filters "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *filter* on a type `X` is a collection of sets of `X` that satisfies three
    conditions that we will spell out below. The notion supports two related ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: '*limits*, including all the kinds of limits discussed above: finite and infinite
    limits of sequences, finite and infinite limits of functions at a point or at
    infinity, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*things happening eventually*, including things happening for large enough
    `n : ‚Ñï`, or sufficiently near a point `x`, or for sufficiently close pairs of
    points, or almost everywhere in the sense of measure theory. Dually, filters can
    also express the idea of *things happening often*: for arbitrarily large `n`,
    at a point in any neighborhood of a given point, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The filters that correspond to these descriptions will be defined later in
    this section, but we can already name them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(atTop : Filter ‚Ñï)`, made of sets of `‚Ñï` containing `{n | n ‚â• N}` for some
    `N`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ùìù x`, made of neighborhoods of `x` in a topological space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ùì§ X`, made of entourages of a uniform space (uniform spaces generalize metric
    spaces and topological groups)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Œº.ae` , made of sets whose complement has zero measure with respect to a measure
    `Œº`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The general definition is as follows: a filter `F : Filter X` is a collection
    of sets `F.sets : Set (Set X)` satisfying the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`F.univ_sets : univ ‚àà F.sets`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F.sets_of_superset : ‚àÄ {U V}, U ‚àà F.sets ‚Üí U ‚äÜ V ‚Üí V ‚àà F.sets`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F.inter_sets : ‚àÄ {U V}, U ‚àà F.sets ‚Üí V ‚àà F.sets ‚Üí U ‚à© V ‚àà F.sets`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first condition says that the set of all elements of `X` belongs to `F.sets`.
    The second condition says that if `U` belongs to `F.sets` then anything containing
    `U` also belongs to `F.sets`. The third condition says that `F.sets` is closed
    under finite intersections. In Mathlib, a filter `F` is defined to be a structure
    bundling `F.sets` and its three properties, but the properties carry no additional
    data, and it is convenient to blur the distinction between `F` and `F.sets`. We
    therefore define `U ‚àà F` to mean `U ‚àà F.sets`. This explains why the word `sets`
    appears in the names of some lemmas that that mention `U ‚àà F`.
  prefs: []
  type: TYPE_NORMAL
- en: It may help to think of a filter as defining a notion of a ‚Äúsufficiently large‚Äù
    set. The first condition then says that `univ` is sufficiently large, the second
    one says that a set containing a sufficiently large set is sufficiently large
    and the third one says that the intersection of two sufficiently large sets is
    sufficiently large.
  prefs: []
  type: TYPE_NORMAL
- en: 'It may be even more useful to think of a filter on a type `X` as a generalized
    element of `Set X`. For instance, `atTop` is the ‚Äúset of very large numbers‚Äù and
    `ùìù x‚ÇÄ` is the ‚Äúset of points very close to `x‚ÇÄ`.‚Äù One manifestation of this view
    is that we can associate to any `s : Set X` the so-called *principal filter* consisting
    of all sets that contain `s`. This definition is already in Mathlib and has a
    notation `ùìü` (localized in the `Filter` namespace). For the purpose of demonstration,
    we ask you to take this opportunity to work out the definition here.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'For our second example, we ask you to define the filter `atTop : Filter ‚Ñï`.
    (We could use any type with a preorder instead of `‚Ñï`.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also directly define the filter `ùìù x` of neighborhoods of any `x : ‚Ñù`.
    In the real numbers, a neighborhood of `x` is a set containing an open interval
    \((x_0 - \varepsilon, x_0 + \varepsilon)\), defined in Mathlib as `Ioo (x‚ÇÄ - Œµ)
    (x‚ÇÄ + Œµ)`. (This notion of a neighborhood is only a special case of a more general
    construction in Mathlib.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'With these examples, we can already define what it means for a function `f
    : X ‚Üí Y` to converge to some `G : Filter Y` along some `F : Filter X`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'When `X` is `‚Ñï` and `Y` is `‚Ñù`, `Tendsto‚ÇÅ u atTop (ùìù x)` is equivalent to saying
    that the sequence `u : ‚Ñï ‚Üí ‚Ñù` converges to the real number `x`. When both `X`
    and `Y` are `‚Ñù`, `Tendsto f (ùìù x‚ÇÄ) (ùìù y‚ÇÄ)` is equivalent to the familiar notion
    \(\lim_{x \to x‚ÇÄ} f(x) = y‚ÇÄ\). All of the other kinds of limits mentioned in the
    introduction are also equivalent to instances of `Tendsto‚ÇÅ` for suitable choices
    of filters on the source and target.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The notion `Tendsto‚ÇÅ` above is definitionally equivalent to the notion `Tendsto`
    that is defined in Mathlib, but the latter is defined more abstractly. The problem
    with the definition of `Tendsto‚ÇÅ` is that it exposes a quantifier and elements
    of `G`, and it hides the intuition that we get by viewing filters as generalized
    sets. We can hide the quantifier `‚àÄ V` and make the intuition more salient by
    using more algebraic and set-theoretic machinery. The first ingredient is the
    *pushforward* operation \(f_*\) associated to any map `f : X ‚Üí Y`, denoted `Filter.map
    f` in Mathlib. Given a filter `F` on `X`, `Filter.map f F : Filter Y` is defined
    so that `V ‚àà Filter.map f F ‚Üî f ‚Åª¬π'' V ‚àà F` holds definitionally. In the example
    file we‚Äôve opened the `Filter` namespace so that `Filter.map` can be written as
    `map`. This means that we can rewrite the definition of `Tendsto` using the order
    relation on `Filter Y`, which is reversed inclusion of the set of members. In
    other words, given `G H : Filter Y`, we have `G ‚â§ H ‚Üî ‚àÄ V : Set Y, V ‚àà H ‚Üí V ‚àà
    G`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'It may seem that the order relation on filters is backward. But recall that
    we can view filters on `X` as generalized elements of `Set X`, via the inclusion
    of `ùìü : Set X ‚Üí Filter X` which maps any set `s` to the corresponding principal
    filter. This inclusion is order preserving, so the order relation on `Filter`
    can indeed be seen as the natural inclusion relation between generalized sets.
    In this analogy, pushforward is analogous to the direct image. And, indeed, `map
    f (ùìü s) = ùìü (f '''' s)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now understand intuitively why a sequence `u : ‚Ñï ‚Üí ‚Ñù` converges to a
    point `x‚ÇÄ` if and only if we have `map u atTop ‚â§ ùìù x‚ÇÄ`. The inequality means the
    ‚Äúdirect image under `u`‚Äù of ‚Äúthe set of very big natural numbers‚Äù is ‚Äúincluded‚Äù
    in ‚Äúthe set of points very close to `x‚ÇÄ`.‚Äù'
  prefs: []
  type: TYPE_NORMAL
- en: As promised, the definition of `Tendsto‚ÇÇ` does not exhibit any quantifiers or
    sets. It also leverages the algebraic properties of the pushforward operation.
    First, each `Filter.map f` is monotone. And, second, `Filter.map` is compatible
    with composition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Together these two properties allow us to prove that limits compose, yielding
    in one shot all 512 variants of the composition lemma described in the introduction,
    and lots more. You can practice proving the following statement using either the
    definition of `Tendsto‚ÇÅ` in terms of the universal quantifier or the algebraic
    definition, together with the two lemmas above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: The pushforward construction uses a map to push filters from the map source
    to the map target. There also a *pullback* operation, `Filter.comap`, going in
    the other direction. This generalizes the preimage operation on sets. For any
    map `f`, `Filter.map f` and `Filter.comap f` form what is known as a *Galois connection*,
    which is to say, they satisfy
  prefs: []
  type: TYPE_NORMAL
- en: '`Filter.map_le_iff_le_comap : Filter.map f F ‚â§ G ‚Üî F ‚â§ Filter.comap f G`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: for every `F` and `G`. This operation could be used to provided another formulation
    of `Tendsto` that would be provably (but not definitionally) equivalent to the
    one in Mathlib.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `comap` operation can be used to restrict filters to a subtype. For instance,
    suppose we have `f : ‚Ñù ‚Üí ‚Ñù`, `x‚ÇÄ : ‚Ñù` and `y‚ÇÄ : ‚Ñù`, and suppose we want to state
    that `f x` approaches `y‚ÇÄ` when `x` approaches `x‚ÇÄ` within the rational numbers.
    We can pull the filter `ùìù x‚ÇÄ` back to `‚Ñö` using the coercion map `(‚Üë) : ‚Ñö ‚Üí ‚Ñù`
    and state `Tendsto (f ‚àò (‚Üë) : ‚Ñö ‚Üí ‚Ñù) (comap (‚Üë) (ùìù x‚ÇÄ)) (ùìù y‚ÇÄ)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: The pullback operation is also compatible with composition, but it is *contravariant*,
    which is to say, it reverses the order of the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs now shift attention to the plane `‚Ñù √ó ‚Ñù` and try to understand how the
    neighborhoods of a point `(x‚ÇÄ, y‚ÇÄ)` are related to `ùìù x‚ÇÄ` and `ùìù y‚ÇÄ`. There is
    a product operation `Filter.prod : Filter X ‚Üí Filter Y ‚Üí Filter (X √ó Y)`, denoted
    by `√óÀ¢`, which answers this question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'The product operation is defined in terms of the pullback operation and the
    `inf` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`F √óÀ¢ G = (comap Prod.fst F) ‚äì (comap Prod.snd G)`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Here the `inf` operation refers to the lattice structure on `Filter X` for any
    type `X`, whereby `F ‚äì G` is the greatest filter that is smaller than both `F`
    and `G`. Thus the `inf` operation generalizes the notion of the intersection of
    sets.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of proofs in Mathlib use all of the aforementioned structure (`map`, `comap`,
    `inf`, `sup`, and `prod`) to give algebraic proofs about convergence without ever
    referring to members of filters. You can practice doing this in a proof of the
    following lemma, unfolding the definition of `Tendsto` and `Filter.prod` if needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: The ordered type `Filter X` is actually a *complete* lattice, which is to say,
    there is a bottom element, there is a top element, and every set of filters on
    `X` has an `Inf` and a `Sup`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that given the second property in the definition of a filter (if `U` belongs
    to `F` then anything larger than `U` also belongs to `F`), the first property
    (the set of all inhabitants of `X` belongs to `F`) is equivalent to the property
    that `F` is not the empty collection of sets. This shouldn‚Äôt be confused with
    the more subtle question as to whether the empty set is an *element* of `F`. The
    definition of a filter does not prohibit `‚àÖ ‚àà F`, but if the empty set is in `F`
    then every set is in `F`, which is to say, `‚àÄ U : Set X, U ‚àà F`. In this case,
    `F` is a rather trivial filter, which is precisely the bottom element of the complete
    lattice `Filter X`. This contrasts with the definition of filters in Bourbaki,
    which doesn‚Äôt allow filters containing the empty set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we include the trivial filter in our definition, we sometimes need
    to explicitly assume nontriviality in some lemmas. In return, however, the theory
    has nicer global properties. We have already seen that including the trivial filter
    gives us a bottom element. It also allows us to define `principal : Set X ‚Üí Filter
    X`, which maps `‚àÖ` to `‚ä•`, without adding a precondition to rule out the empty
    set. And it allows us to define the pullback operation without a precondition
    as well. Indeed, it can happen that `comap f F = ‚ä•` although `F ‚â† ‚ä•`. For instance,
    given `x‚ÇÄ : ‚Ñù` and `s : Set ‚Ñù`, the pullback of `ùìù x‚ÇÄ` under the coercion from
    the subtype corresponding to `s` is nontrivial if and only if `x‚ÇÄ` belongs to
    the closure of `s`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to manage lemmas that do need to assume some filter is nontrivial,
    Mathlib has a type class `Filter.NeBot`, and the library has lemmas that assume
    `(F : Filter X) [F.NeBot]`. The instance database knows, for example, that `(atTop
    : Filter ‚Ñï).NeBot`, and it knows that pushing forward a nontrivial filter gives
    a nontrivial filter. As a result, a lemma assuming `[F.NeBot]` will automatically
    apply to `map u atTop` for any sequence `u`.'
  prefs: []
  type: TYPE_NORMAL
- en: Our tour of the algebraic properties of filters and their relation to limits
    is essentially done, but we have not yet justified our claim to have recaptured
    the usual limit notions. Superficially, it may seem that `Tendsto u atTop (ùìù x‚ÇÄ)`
    is stronger than the notion of convergence defined in [Section 3.6](C03_Logic.html#sequences-and-convergence)
    because we ask that *every* neighborhood of `x‚ÇÄ` has a preimage belonging to `atTop`,
    whereas the usual definition only requires this for the standard neighborhoods
    `Ioo (x‚ÇÄ - Œµ) (x‚ÇÄ + Œµ)`. The key is that, by definition, every neighborhood contains
    such a standard one. This observation leads to the notion of a *filter basis*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given `F : Filter X`, a family of sets `s : Œπ ‚Üí Set X` is a basis for `F` if
    for every set `U`, we have `U ‚àà F` if and only if it contains some `s i`. In other
    words, formally speaking, `s` is a basis if it satisfies `‚àÄ U : Set X, U ‚àà F ‚Üî
    ‚àÉ i, s i ‚äÜ U`. It is even more flexible to consider a predicate on `Œπ` that selects
    only some of the values `i` in the indexing type. In the case of `ùìù x‚ÇÄ`, we want
    `Œπ` to be `‚Ñù`, we write `Œµ` for `i`, and the predicate should select the positive
    values of `Œµ`. So the fact that the sets `Ioo¬† (x‚ÇÄ - Œµ) (x‚ÇÄ + Œµ)` form a basis
    for the neighborhood topology on `‚Ñù` is stated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: There is also a nice basis for the filter `atTop`. The lemma `Filter.HasBasis.tendsto_iff`
    allows us to reformulate a statement of the form `Tendsto f F G` given bases for
    `F` and `G`. Putting these pieces together gives us essentially the notion of
    convergence that we used in [Section 3.6](C03_Logic.html#sequences-and-convergence).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: We now show how filters facilitate working with properties that hold for sufficiently
    large numbers or for points that are sufficiently close to a given point. In [Section
    3.6](C03_Logic.html#sequences-and-convergence), we were often faced with the situation
    where we knew that some property `P n` holds for sufficiently large `n` and that
    some other property `Q n` holds for sufficiently large `n`. Using `cases` twice
    gave us `N_P` and `N_Q` satisfying `‚àÄ n ‚â• N_P, P n` and `‚àÄ n ‚â• N_Q, Q n`. Using
    `set N := max N_P N_Q`, we could eventually prove `‚àÄ n ‚â• N, P n ‚àß Q n`. Doing
    this repeatedly becomes tiresome.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do better by noting that the statement ‚Äú`P n` and `Q n` hold for large
    enough `n`‚Äù means that we have `{n | P n} ‚àà atTop` and `{n | Q n} ‚àà atTop`. The
    fact that `atTop` is a filter implies that the intersection of two elements of
    `atTop` is again in `atTop`, so we have `{n | P n ‚àß Q n} ‚àà atTop`. Writing `{n
    | P n} ‚àà atTop` is unpleasant, but we can use the more suggestive notation `‚àÄ·∂†
    n in atTop, P n`. Here the superscripted `f` stands for ‚ÄúFilter.‚Äù You can think
    of the notation as saying that for all `n` in the ‚Äúset of very large numbers,‚Äù
    `P n` holds. The `‚àÄ·∂†` notation stands for `Filter.Eventually`, and the lemma `Filter.Eventually.and`
    uses the intersection property of filters to do what we just described:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: This notation is so convenient and intuitive that we also have specializations
    when `P` is an equality or inequality statement. For example, let `u` and `v`
    be two sequences of real numbers, and let us show that if `u n` and `v n` coincide
    for sufficiently large `n` then `u` tends to `x‚ÇÄ` if and only if `v` tends to
    `x‚ÇÄ`. First we‚Äôll use the generic `Eventually` and then the one specialized for
    the equality predicate, `EventuallyEq`. The two statements are definitionally
    equivalent so the same proof work in both cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'It is instructive to review the definition of filters in terms of `Eventually`.
    Given `F : Filter X`, for any predicates `P` and `Q` on `X`,'
  prefs: []
  type: TYPE_NORMAL
- en: the condition `univ ‚àà F` ensures `(‚àÄ x, P x) ‚Üí ‚àÄ·∂† x in F, P x`,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the condition `U ‚àà F ‚Üí U ‚äÜ V ‚Üí V ‚àà F` ensures `(‚àÄ·∂† x in F, P x) ‚Üí (‚àÄ x, P x
    ‚Üí Q x) ‚Üí ‚àÄ·∂† x in F, Q x`, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the condition `U ‚àà F ‚Üí V ‚àà F ‚Üí U ‚à© V ‚àà F` ensures `(‚àÄ·∂† x in F, P x) ‚Üí (‚àÄ·∂† x
    in F, Q x) ‚Üí ‚àÄ·∂† x in F, P x ‚àß Q x`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'The second item, corresponding to `Eventually.mono`, supports nice ways of
    using filters, especially when combined with `Eventually.and`. The `filter_upwards`
    tactic allows us to combine them. Compare:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Readers who know about measure theory will note that the filter `Œº.ae` of sets
    whose complement has measure zero (aka ‚Äúthe set consisting of almost every point‚Äù)
    is not very useful as the source or target of `Tendsto`, but it can be conveniently
    used with `Eventually` to say that a property holds for almost every point.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a dual version of `‚àÄ·∂† x in F, P x`, which is occasionally useful:
    `‚àÉ·∂† x in F, P x` means `{x | ¬¨P x} ‚àâ F`. For example, `‚àÉ·∂† n in atTop, P n` means
    there are arbitrarily large `n` such that `P n` holds. The `‚àÉ·∂†` notation stands
    for `Filter.Frequently`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a more sophisticated example, consider the following statement about a
    sequence `u`, a set `M`, and a value `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: If `u` converges to `x` and `u n` belongs to `M` for sufficiently large `n`
    then `x` is in the closure of `M`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This can be formalized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Tendsto u atTop (ùìù x) ‚Üí (‚àÄ·∂† n in atTop, u n ‚àà M) ‚Üí x ‚àà closure M`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is a special case of the theorem `mem_closure_of_tendsto` from the topology
    library. See if you can prove it using the quoted lemmas, using the fact that
    `ClusterPt x F` means `(ùìù x ‚äì F).NeBot` and that, by definition, the assumption
    `‚àÄ·∂† n in atTop, u n ‚àà M` means `M ‚àà map u atTop`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '## 11.2\. Metric spaces[ÔÉÅ](#metric-spaces "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples in the previous section focus on sequences of real numbers. In this
    section we will go up a bit in generality and focus on metric spaces. A metric
    space is a type `X` equipped with a distance function `dist : X ‚Üí X ‚Üí ‚Ñù` which
    is a generalization of the function `fun x y ‚Ü¶ |x - y|` from the case where `X
    = ‚Ñù`.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing such a space is easy and we will check all properties required from
    the distance function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Note we also have variants where the distance can be infinite or where `dist
    a b` can be zero without having `a = b` or both. They are called `EMetricSpace`,
    `PseudoMetricSpace` and `PseudoEMetricSpace` respectively (here ‚Äúe‚Äù stands for
    ‚Äúextended‚Äù).
  prefs: []
  type: TYPE_NORMAL
- en: Note that our journey from `‚Ñù` to metric spaces jumped over the special case
    of normed spaces that also require linear algebra and will be explained as part
    of the calculus chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 11.2.1\. Convergence and continuity[ÔÉÅ](#convergence-and-continuity "Link to
    this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using distance functions, we can already define convergent sequences and continuous
    functions between metric spaces. They are actually defined in a more general setting
    covered in the next section, but we have lemmas recasting the definition in terms
    of distances.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: A *lot* of lemmas have some continuity assumptions, so we end up proving a lot
    of continuity results and there is a `continuity` tactic devoted to this task.
    Let‚Äôs prove a continuity statement that will be needed in an exercise below. Notice
    that Lean knows how to treat a product of two metric spaces as a metric space,
    so it makes sense to consider continuous functions from `X √ó X` to `‚Ñù`. In particular
    the (uncurried version of the) distance function is such a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'This tactic is a bit slow, so it is also useful to know how to do it by hand.
    We first need to use that `fun p : X √ó X ‚Ü¶ f p.1` is continuous because it is
    the composition of `f`, which is continuous by assumption `hf`, and the projection
    `prod.fst` whose continuity is the content of the lemma `continuous_fst`. The
    composition property is `Continuous.comp` which is in the `Continuous` namespace
    so we can use dot notation to compress `Continuous.comp hf continuous_fst` into
    `hf.comp continuous_fst` which is actually more readable since it really reads
    as composing our assumption and our lemma. We can do the same for the second component
    to get continuity of `fun p : X √ó X ‚Ü¶ f p.2`. We then assemble those two continuities
    using `Continuous.prod_mk` to get `(hf.comp continuous_fst).prod_mk (hf.comp continuous_snd)
    : Continuous (fun p : X √ó X ‚Ü¶ (f p.1, f p.2))` and compose once more to get our
    full proof.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'The combination of `Continuous.prod_mk` and `continuous_dist` via `Continuous.comp`
    feels clunky, even when heavily using dot notation as above. A more serious issue
    is that this nice proof requires a lot of planning. Lean accepts the above proof
    term because it is a full term proving a statement which is definitionally equivalent
    to our goal, the crucial definition to unfold being that of a composition of functions.
    Indeed our target function `fun p : X √ó X ‚Ü¶ dist (f p.1) (f p.2)` is not presented
    as a composition. The proof term we provided proves continuity of `dist ‚àò (fun
    p : X √ó X ‚Ü¶ (f p.1, f p.2))` which happens to be definitionally equal to our target
    function. But if we try to build this proof gradually using tactics starting with
    `apply continuous_dist.comp` then Lean‚Äôs elaborator will fail to recognize a composition
    and refuse to apply this lemma. It is especially bad at this when products of
    types are involved.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A better lemma to apply here is `Continuous.dist {f g : X ‚Üí Y} : Continuous
    f ‚Üí Continuous g ‚Üí Continuous (fun x ‚Ü¶ dist (f x) (g x))` which is nicer to Lean‚Äôs
    elaborator and also provides a shorter proof when directly providing a full proof
    term, as can be seen from the following two new proofs of the above statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Note that, without the elaboration issue coming from composition, another way
    to compress our proof would be to use `Continuous.prod_map` which is sometimes
    useful and gives as an alternate proof term `continuous_dist.comp (hf.prod_map
    hf)` which even shorter to type.
  prefs: []
  type: TYPE_NORMAL
- en: Since it is sad to decide between a version which is better for elaboration
    and a version which is shorter to type, let us wrap this discussion with a last
    bit of compression offered by `Continuous.fst'` which allows to compress `hf.comp
    continuous_fst` to `hf.fst'` (and the same with `snd`) and get our final proof,
    now bordering obfuscation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: It‚Äôs your turn now to prove some continuity lemma. After trying the continuity
    tactic, you will need `Continuous.add`, `continuous_pow` and `continuous_id` to
    do it by hand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: So far we saw continuity as a global notion, but one can also define continuity
    at a point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 11.2.2\. Balls, open sets and closed sets[ÔÉÅ](#balls-open-sets-and-closed-sets
    "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we have a distance function, the most important geometric definitions are
    (open) balls and closed balls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Note that r is any real number here, there is no sign restriction. Of course
    some statements do require a radius condition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Once we have balls, we can define open sets. They are actually defined in a
    more general setting covered in the next section, but we have lemmas recasting
    the definition in terms of balls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Then closed sets are sets whose complement is open. Their important property
    is they are closed under limits. The closure of a set is the smallest closed set
    containing it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Do the next exercise without using mem_closure_iff_seq_limit
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Remember from the filters sections that neighborhood filters play a big role
    in Mathlib. In the metric space context, the crucial point is that balls provide
    bases for those filters. The main lemmas here are `Metric.nhds_basis_ball` and
    `Metric.nhds_basis_closedBall` that claim this for open and closed balls with
    positive radius. The center point is an implicit argument so we can invoke `Filter.HasBasis.mem_iff`
    as in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 11.2.3\. Compactness[ÔÉÅ](#compactness "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Compactness is an important topological notion. It distinguishes subsets of
    a metric space that enjoy the same kind of properties as segments in the reals
    compared to other intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: Any sequence with values in a compact set has a subsequence that converges in
    this set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any continuous function on a nonempty compact set with values in real numbers
    is bounded and attains its bounds somewhere (this is called the extreme value
    theorem).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compact sets are closed sets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us first check that the unit interval in the reals is indeed a compact set,
    and then check the above claims for compact sets in general metric spaces. In
    the second statement we only need continuity on the given set so we will use `ContinuousOn`
    instead of `Continuous`, and we will give separate statements for the minimum
    and the maximum. Of course all these results are deduced from more general versions,
    some of which will be discussed in later sections.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also specify that a metric spaces is globally compact, using an extra
    `Prop`-valued type class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: In a compact metric space any closed set is compact, this is `IsClosed.isCompact`.
  prefs: []
  type: TYPE_NORMAL
- en: 11.2.4\. Uniformly continuous functions[ÔÉÅ](#uniformly-continuous-functions "Link
    to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now turn to uniformity notions on metric spaces : uniformly continuous functions,
    Cauchy sequences and completeness. Again those are defined in a more general context
    but we have lemmas in the metric name space to access their elementary definitions.
    We start with uniform continuity.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: In order to practice manipulating all those definitions, we will prove that
    continuous functions from a compact metric space to a metric space are uniformly
    continuous (we will see a more general version in a later section).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first give an informal sketch. Let `f : X ‚Üí Y` be a continuous function
    from a compact metric space to a metric space. We fix `Œµ > 0` and start looking
    for some `Œ¥`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let `œÜ : X √ó X ‚Üí ‚Ñù := fun p ‚Ü¶ dist (f p.1) (f p.2)` and let `K := { p : X √ó
    X | Œµ ‚â§ œÜ p }`. Observe `œÜ` is continuous since `f` and distance are continuous.
    And `K` is clearly closed (use `isClosed_le`) hence compact since `X` is compact.'
  prefs: []
  type: TYPE_NORMAL
- en: Then we discuss two possibilities using `eq_empty_or_nonempty`. If `K` is empty
    then we are clearly done (we can set `Œ¥ = 1` for instance). So let‚Äôs assume `K`
    is not empty, and use the extreme value theorem to choose `(x‚ÇÄ, x‚ÇÅ)` attaining
    the infimum of the distance function on `K`. We can then set `Œ¥ = dist x‚ÇÄ x‚ÇÅ`
    and check everything works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 11.2.5\. Completeness[ÔÉÅ](#completeness "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Cauchy sequence in a metric space is a sequence whose terms get closer and
    closer to each other. There are a couple of equivalent ways to state that idea.
    In particular converging sequences are Cauchy. The converse is true only in so-called
    *complete* spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: We‚Äôll practice using this definition by proving a convenient criterion which
    is a special case of a criterion appearing in Mathlib. This is also a good opportunity
    to practice using big sums in a geometric context. In addition to the explanations
    from the filters section, you will probably need `tendsto_pow_atTop_nhds_zero_of_lt_one`,
    `Tendsto.mul` and `dist_le_range_sum_dist`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'We are ready for the final boss of this section: Baire‚Äôs theorem for complete
    metric spaces! The proof skeleton below shows interesting techniques. It uses
    the `choose` tactic in its exclamation mark variant (you should experiment with
    removing this exclamation mark) and it shows how to define something inductively
    in the middle of a proof using `Nat.rec_on`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 11.2.1\. Convergence and continuity[ÔÉÅ](#convergence-and-continuity "Link to
    this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using distance functions, we can already define convergent sequences and continuous
    functions between metric spaces. They are actually defined in a more general setting
    covered in the next section, but we have lemmas recasting the definition in terms
    of distances.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: A *lot* of lemmas have some continuity assumptions, so we end up proving a lot
    of continuity results and there is a `continuity` tactic devoted to this task.
    Let‚Äôs prove a continuity statement that will be needed in an exercise below. Notice
    that Lean knows how to treat a product of two metric spaces as a metric space,
    so it makes sense to consider continuous functions from `X √ó X` to `‚Ñù`. In particular
    the (uncurried version of the) distance function is such a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'This tactic is a bit slow, so it is also useful to know how to do it by hand.
    We first need to use that `fun p : X √ó X ‚Ü¶ f p.1` is continuous because it is
    the composition of `f`, which is continuous by assumption `hf`, and the projection
    `prod.fst` whose continuity is the content of the lemma `continuous_fst`. The
    composition property is `Continuous.comp` which is in the `Continuous` namespace
    so we can use dot notation to compress `Continuous.comp hf continuous_fst` into
    `hf.comp continuous_fst` which is actually more readable since it really reads
    as composing our assumption and our lemma. We can do the same for the second component
    to get continuity of `fun p : X √ó X ‚Ü¶ f p.2`. We then assemble those two continuities
    using `Continuous.prod_mk` to get `(hf.comp continuous_fst).prod_mk (hf.comp continuous_snd)
    : Continuous (fun p : X √ó X ‚Ü¶ (f p.1, f p.2))` and compose once more to get our
    full proof.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'The combination of `Continuous.prod_mk` and `continuous_dist` via `Continuous.comp`
    feels clunky, even when heavily using dot notation as above. A more serious issue
    is that this nice proof requires a lot of planning. Lean accepts the above proof
    term because it is a full term proving a statement which is definitionally equivalent
    to our goal, the crucial definition to unfold being that of a composition of functions.
    Indeed our target function `fun p : X √ó X ‚Ü¶ dist (f p.1) (f p.2)` is not presented
    as a composition. The proof term we provided proves continuity of `dist ‚àò (fun
    p : X √ó X ‚Ü¶ (f p.1, f p.2))` which happens to be definitionally equal to our target
    function. But if we try to build this proof gradually using tactics starting with
    `apply continuous_dist.comp` then Lean‚Äôs elaborator will fail to recognize a composition
    and refuse to apply this lemma. It is especially bad at this when products of
    types are involved.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A better lemma to apply here is `Continuous.dist {f g : X ‚Üí Y} : Continuous
    f ‚Üí Continuous g ‚Üí Continuous (fun x ‚Ü¶ dist (f x) (g x))` which is nicer to Lean‚Äôs
    elaborator and also provides a shorter proof when directly providing a full proof
    term, as can be seen from the following two new proofs of the above statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Note that, without the elaboration issue coming from composition, another way
    to compress our proof would be to use `Continuous.prod_map` which is sometimes
    useful and gives as an alternate proof term `continuous_dist.comp (hf.prod_map
    hf)` which even shorter to type.
  prefs: []
  type: TYPE_NORMAL
- en: Since it is sad to decide between a version which is better for elaboration
    and a version which is shorter to type, let us wrap this discussion with a last
    bit of compression offered by `Continuous.fst'` which allows to compress `hf.comp
    continuous_fst` to `hf.fst'` (and the same with `snd`) and get our final proof,
    now bordering obfuscation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: It‚Äôs your turn now to prove some continuity lemma. After trying the continuity
    tactic, you will need `Continuous.add`, `continuous_pow` and `continuous_id` to
    do it by hand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: So far we saw continuity as a global notion, but one can also define continuity
    at a point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 11.2.2\. Balls, open sets and closed sets[ÔÉÅ](#balls-open-sets-and-closed-sets
    "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we have a distance function, the most important geometric definitions are
    (open) balls and closed balls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Note that r is any real number here, there is no sign restriction. Of course
    some statements do require a radius condition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Once we have balls, we can define open sets. They are actually defined in a
    more general setting covered in the next section, but we have lemmas recasting
    the definition in terms of balls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Then closed sets are sets whose complement is open. Their important property
    is they are closed under limits. The closure of a set is the smallest closed set
    containing it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Do the next exercise without using mem_closure_iff_seq_limit
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Remember from the filters sections that neighborhood filters play a big role
    in Mathlib. In the metric space context, the crucial point is that balls provide
    bases for those filters. The main lemmas here are `Metric.nhds_basis_ball` and
    `Metric.nhds_basis_closedBall` that claim this for open and closed balls with
    positive radius. The center point is an implicit argument so we can invoke `Filter.HasBasis.mem_iff`
    as in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 11.2.3\. Compactness[ÔÉÅ](#compactness "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Compactness is an important topological notion. It distinguishes subsets of
    a metric space that enjoy the same kind of properties as segments in the reals
    compared to other intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: Any sequence with values in a compact set has a subsequence that converges in
    this set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any continuous function on a nonempty compact set with values in real numbers
    is bounded and attains its bounds somewhere (this is called the extreme value
    theorem).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compact sets are closed sets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us first check that the unit interval in the reals is indeed a compact set,
    and then check the above claims for compact sets in general metric spaces. In
    the second statement we only need continuity on the given set so we will use `ContinuousOn`
    instead of `Continuous`, and we will give separate statements for the minimum
    and the maximum. Of course all these results are deduced from more general versions,
    some of which will be discussed in later sections.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also specify that a metric spaces is globally compact, using an extra
    `Prop`-valued type class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: In a compact metric space any closed set is compact, this is `IsClosed.isCompact`.
  prefs: []
  type: TYPE_NORMAL
- en: 11.2.4\. Uniformly continuous functions[ÔÉÅ](#uniformly-continuous-functions "Link
    to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now turn to uniformity notions on metric spaces : uniformly continuous functions,
    Cauchy sequences and completeness. Again those are defined in a more general context
    but we have lemmas in the metric name space to access their elementary definitions.
    We start with uniform continuity.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: In order to practice manipulating all those definitions, we will prove that
    continuous functions from a compact metric space to a metric space are uniformly
    continuous (we will see a more general version in a later section).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first give an informal sketch. Let `f : X ‚Üí Y` be a continuous function
    from a compact metric space to a metric space. We fix `Œµ > 0` and start looking
    for some `Œ¥`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let `œÜ : X √ó X ‚Üí ‚Ñù := fun p ‚Ü¶ dist (f p.1) (f p.2)` and let `K := { p : X √ó
    X | Œµ ‚â§ œÜ p }`. Observe `œÜ` is continuous since `f` and distance are continuous.
    And `K` is clearly closed (use `isClosed_le`) hence compact since `X` is compact.'
  prefs: []
  type: TYPE_NORMAL
- en: Then we discuss two possibilities using `eq_empty_or_nonempty`. If `K` is empty
    then we are clearly done (we can set `Œ¥ = 1` for instance). So let‚Äôs assume `K`
    is not empty, and use the extreme value theorem to choose `(x‚ÇÄ, x‚ÇÅ)` attaining
    the infimum of the distance function on `K`. We can then set `Œ¥ = dist x‚ÇÄ x‚ÇÅ`
    and check everything works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 11.2.5\. Completeness[ÔÉÅ](#completeness "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Cauchy sequence in a metric space is a sequence whose terms get closer and
    closer to each other. There are a couple of equivalent ways to state that idea.
    In particular converging sequences are Cauchy. The converse is true only in so-called
    *complete* spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: We‚Äôll practice using this definition by proving a convenient criterion which
    is a special case of a criterion appearing in Mathlib. This is also a good opportunity
    to practice using big sums in a geometric context. In addition to the explanations
    from the filters section, you will probably need `tendsto_pow_atTop_nhds_zero_of_lt_one`,
    `Tendsto.mul` and `dist_le_range_sum_dist`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'We are ready for the final boss of this section: Baire‚Äôs theorem for complete
    metric spaces! The proof skeleton below shows interesting techniques. It uses
    the `choose` tactic in its exclamation mark variant (you should experiment with
    removing this exclamation mark) and it shows how to define something inductively
    in the middle of a proof using `Nat.rec_on`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '## 11.3\. Topological spaces[ÔÉÅ](#topological-spaces "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.1\. Fundamentals[ÔÉÅ](#fundamentals "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now go up in generality and introduce topological spaces. We will review
    the two main ways to define topological spaces and then explain how the category
    of topological spaces is much better behaved than the category of metric spaces.
    Note that we won‚Äôt be using Mathlib category theory here, only having a somewhat
    categorical point of view.
  prefs: []
  type: TYPE_NORMAL
- en: The first way to think about the transition from metric spaces to topological
    spaces is that we only remember the notion of open sets (or equivalently the notion
    of closed sets). From this point of view, a topological space is a type equipped
    with a collection of sets that are called open sets. This collection has to satisfy
    a number of axioms presented below (this collection is slightly redundant but
    we will ignore that).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Closed sets are then defined as sets whose complement is open. A function between
    topological spaces is (globally) continuous if all preimages of open sets are
    open.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'With this definition we already see that, compared to metric spaces, topological
    spaces only remember enough information to talk about continuous functions: two
    topological structures on a type are the same if and only if they have the same
    continuous functions (indeed the identity function will be continuous in both
    direction if and only if the two structures have the same open sets).'
  prefs: []
  type: TYPE_NORMAL
- en: 'However as soon as we move on to continuity at a point we see the limitations
    of the approach based on open sets. In Mathlib we frequently think of topological
    spaces as types equipped with a neighborhood filter `ùìù x` attached to each point
    `x` (the corresponding function `X ‚Üí Filter X` satisfies certain conditions explained
    further down). Remember from the filters section that these gadgets play two related
    roles. First `ùìù x` is seen as the generalized set of points of `X` that are close
    to `x`. And then it is seen as giving a way to say, for any predicate `P : X ‚Üí
    Prop`, that this predicate holds for points that are close enough to `x`. Let
    us state that `f : X ‚Üí Y` is continuous at `x`. The purely filtery way is to say
    that the direct image under `f` of the generalized set of points that are close
    to `x` is contained in the generalized set of points that are close to `f x`.
    Recall this is spelled either `map f (ùìù x) ‚â§ ùìù (f x)` or `Tendsto f (ùìù x) (ùìù (f
    x))`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'One can also spell it using both neighborhoods seen as ordinary sets and a
    neighborhood filter seen as a generalized set: ‚Äúfor any neighborhood `U` of `f
    x`, all points close to `x` are sent to `U`‚Äù. Note that the proof is again `Iff.rfl`,
    this point of view is definitionally equivalent to the previous one.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: We now explain how to go from one point of view to the other. In terms of open
    sets, we can simply define members of `ùìù x` as sets that contain an open set containing
    `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'To go in the other direction we need to discuss the condition that `ùìù : X ‚Üí
    Filter X` must satisfy in order to be the neighborhood function of a topology.'
  prefs: []
  type: TYPE_NORMAL
- en: The first constraint is that `ùìù x`, seen as a generalized set, contains the
    set `{x}` seen as the generalized set `pure x` (explaining this weird name would
    be too much of a digression, so we simply accept it for now). Another way to say
    it is that if a predicate holds for points close to `x` then it holds at `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'Then a more subtle requirement is that, for any predicate `P : X ‚Üí Prop` and
    any `x`, if `P y` holds for `y` close to `x` then for `y` close to `x` and `z`
    close to `y`, `P z` holds. More precisely we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'Those two results characterize the functions `X ‚Üí Filter X` that are neighborhood
    functions for a topological space structure on `X`. There is a still a function
    `TopologicalSpace.mkOfNhds : (X ‚Üí Filter X) ‚Üí TopologicalSpace X` but it will
    give back its input as a neighborhood function only if it satisfies the above
    two constraints. More precisely we have a lemma `TopologicalSpace.nhds_mkOfNhds`
    saying that in a different way and our next exercise deduces this different way
    from how we stated it above.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: Note that `TopologicalSpace.mkOfNhds` is not so frequently used, but it still
    good to know in what precise sense the neighborhood filters is all there is in
    a topological space structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing to know in order to efficiently use topological spaces in Mathlib
    is that we use a lot of formal properties of `TopologicalSpace : Type u ‚Üí Type
    u`. From a purely mathematical point of view, those formal properties are a very
    clean way to explain how topological spaces solve issues that metric spaces have.
    From this point of view, the issues solved by topological spaces is that metric
    spaces enjoy very little functoriality, and have very bad categorical properties
    in general. This comes on top of the fact already discussed that metric spaces
    contain a lot of geometrical information that is not topologically relevant.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us focus on functoriality first. A metric space structure can be induced
    on a subset or, equivalently, it can be pulled back by an injective map. But that‚Äôs
    pretty much everything. They cannot be pulled back by general map or pushed forward,
    even by surjective maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular there is no sensible distance to put on a quotient of a metric
    space or on an uncountable product of metric spaces. Consider for instance the
    type `‚Ñù ‚Üí ‚Ñù`, seen as a product of copies of `‚Ñù` indexed by `‚Ñù`. We would like
    to say that pointwise convergence of sequences of functions is a respectable notion
    of convergence. But there is no distance on `‚Ñù ‚Üí ‚Ñù` that gives this notion of
    convergence. Relatedly, there is no distance ensuring that a map `f : X ‚Üí (‚Ñù ‚Üí
    ‚Ñù)` is continuous if and only if `fun x ‚Ü¶ f x t` is continuous for every `t :
    ‚Ñù`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now review the data used to solve all those issues. First we can use any
    map `f : X ‚Üí Y` to push or pull topologies from one side to the other. Those two
    operations form a Galois connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: Those operations are compatible with composition of functions. As usual, pushing
    forward is covariant and pulling back is contravariant, see `coinduced_compose`
    and `induced_compose`. On paper we will use notations \(f_*T\) for `TopologicalSpace.coinduced
    f T` and \(f^*T\) for `TopologicalSpace.induced f T`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then the next big piece is a complete lattice structure on `TopologicalSpace
    X` for any given structure. If you think of topologies as being primarily the
    data of open sets then you expect the order relation on `TopologicalSpace X` to
    come from `Set (Set X)`, i.e. you expect `t ‚â§ t''` if a set `u` is open for `t''`
    as soon as it is open for `t`. However we already know that Mathlib focuses on
    neighborhoods more than open sets so, for any `x : X` we want the map from topological
    spaces to neighborhoods `fun T : TopologicalSpace X ‚Ü¶ @nhds X T x` to be order
    preserving. And we know the order relation on `Filter X` is designed to ensure
    an order preserving `principal : Set X ‚Üí Filter X`, allowing to see filters as
    generalized sets. So the order relation we do use on `TopologicalSpace X` is opposite
    to the one coming from `Set (Set X)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Now we can recover continuity by combining the push-forward (or pull-back) operation
    with the order relation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'With this definition and the compatibility of push-forward and composition,
    we get for free the universal property that, for any topological space \(Z\),
    a function \(g : Y ‚Üí Z\) is continuous for the topology \(f_*T_X\) if and only
    if \(g ‚àò f\) is continuous.'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}g \text{ continuous } &‚áî g_*(f_*T_X) ‚â§ T_Z \\ &‚áî (g ‚àò f)_* T_X
    ‚â§ T_Z \\ &‚áî g ‚àò f \text{ continuous}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'So we already get quotient topologies (using the projection map as `f`). This
    wasn‚Äôt using that `TopologicalSpace X` is a complete lattice for all `X`. Let‚Äôs
    now see how all this structure proves the existence of the product topology by
    abstract non-sense. We considered the case of `‚Ñù ‚Üí ‚Ñù` above, but let‚Äôs now consider
    the general case of `Œ† i, X i` for some `Œπ : Type*` and `X : Œπ ‚Üí Type*`. We want,
    for any topological space `Z` and any function `f : Z ‚Üí Œ† i, X i`, that `f` is
    continuous if and only if `(fun x ‚Ü¶ x i) ‚àò f` is continuous for all `i`. Let us
    explore that constraint ‚Äúon paper‚Äù using notation \(p_i\) for the projection `(fun
    (x : Œ† i, X i) ‚Ü¶ x i)`:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}(‚àÄ i, p_i ‚àò f \text{ continuous}) &‚áî ‚àÄ i, (p_i ‚àò f)_* T_Z ‚â§ T_{X_i}
    \\ &‚áî ‚àÄ i, (p_i)_* f_* T_Z ‚â§ T_{X_i}\\ &‚áî ‚àÄ i, f_* T_Z ‚â§ (p_i)^*T_{X_i}\\ &‚áî f_*
    T_Z ‚â§ \inf \left[(p_i)^*T_{X_i}\right]\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'So we see that what is the topology we want on `Œ† i, X i`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: This ends our tour of how Mathlib thinks that topological spaces fix defects
    of the theory of metric spaces by being a more functorial theory and having a
    complete lattice structure for any fixed type.
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.2\. Separation and countability[ÔÉÅ](#separation-and-countability "Link to
    this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We saw that the category of topological spaces have very nice properties. The
    price to pay for this is existence of rather pathological topological spaces.
    There are a number of assumptions you can make on a topological space to ensure
    its behavior is closer to what metric spaces do. The most important is `T2Space`,
    also called ‚ÄúHausdorff‚Äù, that will ensure that limits are unique. A stronger separation
    property is `T3Space` that ensures in addition the RegularSpace property: each
    point has a basis of closed neighborhoods.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in every topological space, each point has a basis of open neighborhood,
    by definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'Our main goal is now to prove the basic theorem which allows extension by continuity.
    From Bourbaki‚Äôs general topology book, I.8.5, Theorem 1 (taking only the non-trivial
    implication):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let \(X\) be a topological space, \(A\) a dense subset of \(X\), \(f : A ‚Üí
    Y\) a continuous mapping of \(A\) into a \(T_3\) space \(Y\). If, for each \(x\)
    in \(X\), \(f(y)\) tends to a limit in \(Y\) when \(y\) tends to \(x\) while remaining
    in \(A\) then there exists a continuous extension \(œÜ\) of \(f\) to \(X\).'
  prefs: []
  type: TYPE_NORMAL
- en: Actually Mathlib contains a more general version of the above lemma, `IsDenseInducing.continuousAt_extend`,
    but we‚Äôll stick to Bourbaki‚Äôs version here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that, given `A : Set X`, `‚Ü•A` is the subtype associated to `A`, and
    Lean will automatically insert that funny up arrow when needed. And the (inclusion)
    coercion map is `(‚Üë) : A ‚Üí X`. The assumption ‚Äútends to \(x\) while remaining
    in \(A\)‚Äù corresponds to the pull-back filter `comap (‚Üë) (ùìù x)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs first prove an auxiliary lemma, extracted to simplify the context (in
    particular we don‚Äôt need Y to be a topological space here).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: Let‚Äôs now turn to the main proof of the extension by continuity theorem.
  prefs: []
  type: TYPE_NORMAL
- en: 'When Lean needs a topology on `‚Ü•A` it will automatically use the induced topology.
    The only relevant lemma is `nhds_induced (‚Üë) : ‚àÄ a : ‚Ü•A, ùìù a = comap (‚Üë) (ùìù ‚Üëa)`
    (this is actually a general lemma about induced topologies).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The proof outline is:'
  prefs: []
  type: TYPE_NORMAL
- en: The main assumption and the axiom of choice give a function `œÜ` such that `‚àÄ
    x, Tendsto f (comap (‚Üë) (ùìù x)) (ùìù (œÜ x))` (because `Y` is Hausdorff, `œÜ` is entirely
    determined, but we won‚Äôt need that until we try to prove that `œÜ` indeed extends
    `f`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs first prove `œÜ` is continuous. Fix any `x : X`. Since `Y` is regular,
    it suffices to check that for every *closed* neighborhood `V''` of `œÜ x`, `œÜ ‚Åª¬π''
    V'' ‚àà ùìù x`. The limit assumption gives (through the auxiliary lemma above) some
    `V ‚àà ùìù x` such `IsOpen V ‚àß (‚Üë) ‚Åª¬π'' V ‚äÜ f ‚Åª¬π'' V''`. Since `V ‚àà ùìù x`, it suffices
    to prove `V ‚äÜ œÜ ‚Åª¬π'' V''`, i.e. `‚àÄ y ‚àà V, œÜ y ‚àà V''`. Let‚Äôs fix `y` in `V`. Because
    `V` is *open*, it is a neighborhood of `y`. In particular `(‚Üë) ‚Åª¬π'' V ‚àà comap
    (‚Üë) (ùìù y)` and a fortiori `f ‚Åª¬π'' V'' ‚àà comap (‚Üë) (ùìù y)`. In addition `comap (‚Üë)
    (ùìù y) ‚â† ‚ä•` because `A` is dense. Because we know `Tendsto f (comap (‚Üë) (ùìù y))
    (ùìù (œÜ y))` this implies `œÜ y ‚àà closure V''` and, since `V''` is closed, we have
    proved `œÜ y ‚àà V''`.'
  prefs: []
  type: TYPE_NORMAL
- en: It remains to prove that `œÜ` extends `f`. This is where the continuity of `f`
    enters the discussion, together with the fact that `Y` is Hausdorff.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: In addition to separation property, the main kind of assumption you can make
    on a topological space to bring it closer to metric spaces is countability assumption.
    The main one is first countability asking that every point has a countable neighborhood
    basis. In particular this ensures that closure of sets can be understood using
    sequences.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 11.3.3\. Compactness[ÔÉÅ](#id5 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us now discuss how compactness is defined for topological spaces. As usual
    there are several ways to think about it and Mathlib goes for the filter version.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to define cluster points of filters. Given a filter `F` on a
    topological space `X`, a point `x : X` is a cluster point of `F` if `F`, seen
    as a generalized set, has non-empty intersection with the generalized set of points
    that are close to `x`.'
  prefs: []
  type: TYPE_NORMAL
- en: Then we can say that a set `s` is compact if every nonempty generalized set
    `F` contained in `s`, i.e. such that `F ‚â§ ùìü s`, has a cluster point in `s`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance if `F` is `map u atTop`, the image under `u : ‚Ñï ‚Üí X` of `atTop`,
    the generalized set of very large natural numbers, then the assumption `F ‚â§ ùìü
    s` means that `u n` belongs to `s` for `n` large enough. Saying that `x` is a
    cluster point of `map u atTop` says the image of very large numbers intersects
    the set of points that are close to `x`. In case `ùìù x` has a countable basis,
    we can interpret this as saying that `u` has a subsequence converging to `x`,
    and we get back what compactness looks like in metric spaces.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: Cluster points behave nicely with continuous functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: As an exercise, we will prove that the image of a compact set under a continuous
    map is compact. In addition to what we saw already, you should use `Filter.push_pull`
    and `NeBot.of_map`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'One can also express compactness in terms of open covers: `s` is compact if
    every family of open sets that cover `s` has a finite covering sub-family.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 11.3.1\. Fundamentals[ÔÉÅ](#fundamentals "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now go up in generality and introduce topological spaces. We will review
    the two main ways to define topological spaces and then explain how the category
    of topological spaces is much better behaved than the category of metric spaces.
    Note that we won‚Äôt be using Mathlib category theory here, only having a somewhat
    categorical point of view.
  prefs: []
  type: TYPE_NORMAL
- en: The first way to think about the transition from metric spaces to topological
    spaces is that we only remember the notion of open sets (or equivalently the notion
    of closed sets). From this point of view, a topological space is a type equipped
    with a collection of sets that are called open sets. This collection has to satisfy
    a number of axioms presented below (this collection is slightly redundant but
    we will ignore that).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: Closed sets are then defined as sets whose complement is open. A function between
    topological spaces is (globally) continuous if all preimages of open sets are
    open.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'With this definition we already see that, compared to metric spaces, topological
    spaces only remember enough information to talk about continuous functions: two
    topological structures on a type are the same if and only if they have the same
    continuous functions (indeed the identity function will be continuous in both
    direction if and only if the two structures have the same open sets).'
  prefs: []
  type: TYPE_NORMAL
- en: 'However as soon as we move on to continuity at a point we see the limitations
    of the approach based on open sets. In Mathlib we frequently think of topological
    spaces as types equipped with a neighborhood filter `ùìù x` attached to each point
    `x` (the corresponding function `X ‚Üí Filter X` satisfies certain conditions explained
    further down). Remember from the filters section that these gadgets play two related
    roles. First `ùìù x` is seen as the generalized set of points of `X` that are close
    to `x`. And then it is seen as giving a way to say, for any predicate `P : X ‚Üí
    Prop`, that this predicate holds for points that are close enough to `x`. Let
    us state that `f : X ‚Üí Y` is continuous at `x`. The purely filtery way is to say
    that the direct image under `f` of the generalized set of points that are close
    to `x` is contained in the generalized set of points that are close to `f x`.
    Recall this is spelled either `map f (ùìù x) ‚â§ ùìù (f x)` or `Tendsto f (ùìù x) (ùìù (f
    x))`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'One can also spell it using both neighborhoods seen as ordinary sets and a
    neighborhood filter seen as a generalized set: ‚Äúfor any neighborhood `U` of `f
    x`, all points close to `x` are sent to `U`‚Äù. Note that the proof is again `Iff.rfl`,
    this point of view is definitionally equivalent to the previous one.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: We now explain how to go from one point of view to the other. In terms of open
    sets, we can simply define members of `ùìù x` as sets that contain an open set containing
    `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'To go in the other direction we need to discuss the condition that `ùìù : X ‚Üí
    Filter X` must satisfy in order to be the neighborhood function of a topology.'
  prefs: []
  type: TYPE_NORMAL
- en: The first constraint is that `ùìù x`, seen as a generalized set, contains the
    set `{x}` seen as the generalized set `pure x` (explaining this weird name would
    be too much of a digression, so we simply accept it for now). Another way to say
    it is that if a predicate holds for points close to `x` then it holds at `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'Then a more subtle requirement is that, for any predicate `P : X ‚Üí Prop` and
    any `x`, if `P y` holds for `y` close to `x` then for `y` close to `x` and `z`
    close to `y`, `P z` holds. More precisely we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'Those two results characterize the functions `X ‚Üí Filter X` that are neighborhood
    functions for a topological space structure on `X`. There is a still a function
    `TopologicalSpace.mkOfNhds : (X ‚Üí Filter X) ‚Üí TopologicalSpace X` but it will
    give back its input as a neighborhood function only if it satisfies the above
    two constraints. More precisely we have a lemma `TopologicalSpace.nhds_mkOfNhds`
    saying that in a different way and our next exercise deduces this different way
    from how we stated it above.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: Note that `TopologicalSpace.mkOfNhds` is not so frequently used, but it still
    good to know in what precise sense the neighborhood filters is all there is in
    a topological space structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing to know in order to efficiently use topological spaces in Mathlib
    is that we use a lot of formal properties of `TopologicalSpace : Type u ‚Üí Type
    u`. From a purely mathematical point of view, those formal properties are a very
    clean way to explain how topological spaces solve issues that metric spaces have.
    From this point of view, the issues solved by topological spaces is that metric
    spaces enjoy very little functoriality, and have very bad categorical properties
    in general. This comes on top of the fact already discussed that metric spaces
    contain a lot of geometrical information that is not topologically relevant.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us focus on functoriality first. A metric space structure can be induced
    on a subset or, equivalently, it can be pulled back by an injective map. But that‚Äôs
    pretty much everything. They cannot be pulled back by general map or pushed forward,
    even by surjective maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular there is no sensible distance to put on a quotient of a metric
    space or on an uncountable product of metric spaces. Consider for instance the
    type `‚Ñù ‚Üí ‚Ñù`, seen as a product of copies of `‚Ñù` indexed by `‚Ñù`. We would like
    to say that pointwise convergence of sequences of functions is a respectable notion
    of convergence. But there is no distance on `‚Ñù ‚Üí ‚Ñù` that gives this notion of
    convergence. Relatedly, there is no distance ensuring that a map `f : X ‚Üí (‚Ñù ‚Üí
    ‚Ñù)` is continuous if and only if `fun x ‚Ü¶ f x t` is continuous for every `t :
    ‚Ñù`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now review the data used to solve all those issues. First we can use any
    map `f : X ‚Üí Y` to push or pull topologies from one side to the other. Those two
    operations form a Galois connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: Those operations are compatible with composition of functions. As usual, pushing
    forward is covariant and pulling back is contravariant, see `coinduced_compose`
    and `induced_compose`. On paper we will use notations \(f_*T\) for `TopologicalSpace.coinduced
    f T` and \(f^*T\) for `TopologicalSpace.induced f T`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then the next big piece is a complete lattice structure on `TopologicalSpace
    X` for any given structure. If you think of topologies as being primarily the
    data of open sets then you expect the order relation on `TopologicalSpace X` to
    come from `Set (Set X)`, i.e. you expect `t ‚â§ t''` if a set `u` is open for `t''`
    as soon as it is open for `t`. However we already know that Mathlib focuses on
    neighborhoods more than open sets so, for any `x : X` we want the map from topological
    spaces to neighborhoods `fun T : TopologicalSpace X ‚Ü¶ @nhds X T x` to be order
    preserving. And we know the order relation on `Filter X` is designed to ensure
    an order preserving `principal : Set X ‚Üí Filter X`, allowing to see filters as
    generalized sets. So the order relation we do use on `TopologicalSpace X` is opposite
    to the one coming from `Set (Set X)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: Now we can recover continuity by combining the push-forward (or pull-back) operation
    with the order relation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'With this definition and the compatibility of push-forward and composition,
    we get for free the universal property that, for any topological space \(Z\),
    a function \(g : Y ‚Üí Z\) is continuous for the topology \(f_*T_X\) if and only
    if \(g ‚àò f\) is continuous.'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}g \text{ continuous } &‚áî g_*(f_*T_X) ‚â§ T_Z \\ &‚áî (g ‚àò f)_* T_X
    ‚â§ T_Z \\ &‚áî g ‚àò f \text{ continuous}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'So we already get quotient topologies (using the projection map as `f`). This
    wasn‚Äôt using that `TopologicalSpace X` is a complete lattice for all `X`. Let‚Äôs
    now see how all this structure proves the existence of the product topology by
    abstract non-sense. We considered the case of `‚Ñù ‚Üí ‚Ñù` above, but let‚Äôs now consider
    the general case of `Œ† i, X i` for some `Œπ : Type*` and `X : Œπ ‚Üí Type*`. We want,
    for any topological space `Z` and any function `f : Z ‚Üí Œ† i, X i`, that `f` is
    continuous if and only if `(fun x ‚Ü¶ x i) ‚àò f` is continuous for all `i`. Let us
    explore that constraint ‚Äúon paper‚Äù using notation \(p_i\) for the projection `(fun
    (x : Œ† i, X i) ‚Ü¶ x i)`:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}(‚àÄ i, p_i ‚àò f \text{ continuous}) &‚áî ‚àÄ i, (p_i ‚àò f)_* T_Z ‚â§ T_{X_i}
    \\ &‚áî ‚àÄ i, (p_i)_* f_* T_Z ‚â§ T_{X_i}\\ &‚áî ‚àÄ i, f_* T_Z ‚â§ (p_i)^*T_{X_i}\\ &‚áî f_*
    T_Z ‚â§ \inf \left[(p_i)^*T_{X_i}\right]\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'So we see that what is the topology we want on `Œ† i, X i`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: This ends our tour of how Mathlib thinks that topological spaces fix defects
    of the theory of metric spaces by being a more functorial theory and having a
    complete lattice structure for any fixed type.
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.2\. Separation and countability[ÔÉÅ](#separation-and-countability "Link to
    this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We saw that the category of topological spaces have very nice properties. The
    price to pay for this is existence of rather pathological topological spaces.
    There are a number of assumptions you can make on a topological space to ensure
    its behavior is closer to what metric spaces do. The most important is `T2Space`,
    also called ‚ÄúHausdorff‚Äù, that will ensure that limits are unique. A stronger separation
    property is `T3Space` that ensures in addition the RegularSpace property: each
    point has a basis of closed neighborhoods.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in every topological space, each point has a basis of open neighborhood,
    by definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'Our main goal is now to prove the basic theorem which allows extension by continuity.
    From Bourbaki‚Äôs general topology book, I.8.5, Theorem 1 (taking only the non-trivial
    implication):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let \(X\) be a topological space, \(A\) a dense subset of \(X\), \(f : A ‚Üí
    Y\) a continuous mapping of \(A\) into a \(T_3\) space \(Y\). If, for each \(x\)
    in \(X\), \(f(y)\) tends to a limit in \(Y\) when \(y\) tends to \(x\) while remaining
    in \(A\) then there exists a continuous extension \(œÜ\) of \(f\) to \(X\).'
  prefs: []
  type: TYPE_NORMAL
- en: Actually Mathlib contains a more general version of the above lemma, `IsDenseInducing.continuousAt_extend`,
    but we‚Äôll stick to Bourbaki‚Äôs version here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that, given `A : Set X`, `‚Ü•A` is the subtype associated to `A`, and
    Lean will automatically insert that funny up arrow when needed. And the (inclusion)
    coercion map is `(‚Üë) : A ‚Üí X`. The assumption ‚Äútends to \(x\) while remaining
    in \(A\)‚Äù corresponds to the pull-back filter `comap (‚Üë) (ùìù x)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs first prove an auxiliary lemma, extracted to simplify the context (in
    particular we don‚Äôt need Y to be a topological space here).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: Let‚Äôs now turn to the main proof of the extension by continuity theorem.
  prefs: []
  type: TYPE_NORMAL
- en: 'When Lean needs a topology on `‚Ü•A` it will automatically use the induced topology.
    The only relevant lemma is `nhds_induced (‚Üë) : ‚àÄ a : ‚Ü•A, ùìù a = comap (‚Üë) (ùìù ‚Üëa)`
    (this is actually a general lemma about induced topologies).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The proof outline is:'
  prefs: []
  type: TYPE_NORMAL
- en: The main assumption and the axiom of choice give a function `œÜ` such that `‚àÄ
    x, Tendsto f (comap (‚Üë) (ùìù x)) (ùìù (œÜ x))` (because `Y` is Hausdorff, `œÜ` is entirely
    determined, but we won‚Äôt need that until we try to prove that `œÜ` indeed extends
    `f`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs first prove `œÜ` is continuous. Fix any `x : X`. Since `Y` is regular,
    it suffices to check that for every *closed* neighborhood `V''` of `œÜ x`, `œÜ ‚Åª¬π''
    V'' ‚àà ùìù x`. The limit assumption gives (through the auxiliary lemma above) some
    `V ‚àà ùìù x` such `IsOpen V ‚àß (‚Üë) ‚Åª¬π'' V ‚äÜ f ‚Åª¬π'' V''`. Since `V ‚àà ùìù x`, it suffices
    to prove `V ‚äÜ œÜ ‚Åª¬π'' V''`, i.e. `‚àÄ y ‚àà V, œÜ y ‚àà V''`. Let‚Äôs fix `y` in `V`. Because
    `V` is *open*, it is a neighborhood of `y`. In particular `(‚Üë) ‚Åª¬π'' V ‚àà comap
    (‚Üë) (ùìù y)` and a fortiori `f ‚Åª¬π'' V'' ‚àà comap (‚Üë) (ùìù y)`. In addition `comap (‚Üë)
    (ùìù y) ‚â† ‚ä•` because `A` is dense. Because we know `Tendsto f (comap (‚Üë) (ùìù y))
    (ùìù (œÜ y))` this implies `œÜ y ‚àà closure V''` and, since `V''` is closed, we have
    proved `œÜ y ‚àà V''`.'
  prefs: []
  type: TYPE_NORMAL
- en: It remains to prove that `œÜ` extends `f`. This is where the continuity of `f`
    enters the discussion, together with the fact that `Y` is Hausdorff.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: In addition to separation property, the main kind of assumption you can make
    on a topological space to bring it closer to metric spaces is countability assumption.
    The main one is first countability asking that every point has a countable neighborhood
    basis. In particular this ensures that closure of sets can be understood using
    sequences.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 11.3.3\. Compactness[ÔÉÅ](#id5 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us now discuss how compactness is defined for topological spaces. As usual
    there are several ways to think about it and Mathlib goes for the filter version.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to define cluster points of filters. Given a filter `F` on a
    topological space `X`, a point `x : X` is a cluster point of `F` if `F`, seen
    as a generalized set, has non-empty intersection with the generalized set of points
    that are close to `x`.'
  prefs: []
  type: TYPE_NORMAL
- en: Then we can say that a set `s` is compact if every nonempty generalized set
    `F` contained in `s`, i.e. such that `F ‚â§ ùìü s`, has a cluster point in `s`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance if `F` is `map u atTop`, the image under `u : ‚Ñï ‚Üí X` of `atTop`,
    the generalized set of very large natural numbers, then the assumption `F ‚â§ ùìü
    s` means that `u n` belongs to `s` for `n` large enough. Saying that `x` is a
    cluster point of `map u atTop` says the image of very large numbers intersects
    the set of points that are close to `x`. In case `ùìù x` has a countable basis,
    we can interpret this as saying that `u` has a subsequence converging to `x`,
    and we get back what compactness looks like in metric spaces.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: Cluster points behave nicely with continuous functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: As an exercise, we will prove that the image of a compact set under a continuous
    map is compact. In addition to what we saw already, you should use `Filter.push_pull`
    and `NeBot.of_map`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: 'One can also express compactness in terms of open covers: `s` is compact if
    every family of open sets that cover `s` has a finite covering sub-family.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]*'
  prefs: []
  type: TYPE_NORMAL
