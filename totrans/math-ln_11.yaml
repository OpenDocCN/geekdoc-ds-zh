- en: 11\. Topologyïƒ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11. æ‹“æ‰‘å­¦ïƒ
- en: åŸæ–‡ï¼š[https://leanprover-community.github.io/mathematics_in_lean/C11_Topology.html](https://leanprover-community.github.io/mathematics_in_lean/C11_Topology.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://leanprover-community.github.io/mathematics_in_lean/C11_Topology.html](https://leanprover-community.github.io/mathematics_in_lean/C11_Topology.html)
- en: '*[Mathematics in Lean](index.html)* **   11\. Topology'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*[Mathematics in Lean](index.html)* **   11. æ‹“æ‰‘å­¦'
- en: '[View page source](_sources/C11_Topology.rst.txt)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[æŸ¥çœ‹é¡µé¢æºä»£ç ](_sources/C11_Topology.rst.txt)'
- en: '* * *'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Calculus is based on the concept of a function, which is used to model quantities
    that depend on one another. For example, it is common to study quantities that
    change over time. The notion of a *limit* is also fundamental. We may say that
    the limit of a function \(f(x)\) is a value \(b\) as \(x\) approaches a value
    \(a\), or that \(f(x)\) *converges to* \(b\) as \(x\) approaches \(a\). Equivalently,
    we may say that \(f(x)\) approaches \(b\) as \(x\) approaches a value \(a\), or
    that it *tends to* \(b\) as \(x\) tends to \(a\). We have already begun to consider
    such notions in [Section 3.6](C03_Logic.html#sequences-and-convergence).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: å¾®ç§¯åˆ†åŸºäºå‡½æ•°çš„æ¦‚å¿µï¼Œç”¨äºæ¨¡æ‹Ÿç›¸äº’ä¾èµ–çš„é‡ã€‚ä¾‹å¦‚ï¼Œç ”ç©¶éšæ—¶é—´å˜åŒ–çš„é‡æ˜¯å¾ˆå¸¸è§çš„ã€‚**æé™**çš„æ¦‚å¿µä¹Ÿæ˜¯åŸºæœ¬çš„ã€‚æˆ‘ä»¬å¯ä»¥è¯´ï¼Œå½“`x`è¶‹è¿‘äºå€¼`a`æ—¶ï¼Œå‡½æ•°`f(x)`çš„æé™æ˜¯ä¸€ä¸ªå€¼`b`ï¼Œæˆ–è€…è¯´`f(x)`å½“`x`è¶‹è¿‘äº`a`æ—¶æ”¶æ•›åˆ°`b`ã€‚ç­‰ä»·åœ°ï¼Œæˆ‘ä»¬å¯ä»¥è¯´å½“`x`è¶‹è¿‘äºå€¼`a`æ—¶ï¼Œ`f(x)`è¶‹è¿‘äº`b`ï¼Œæˆ–è€…è¯´å®ƒå½“`x`è¶‹å‘äº`a`æ—¶è¶‹äº`b`ã€‚æˆ‘ä»¬å·²ç»åœ¨ç¬¬3.6èŠ‚ä¸­å¼€å§‹è€ƒè™‘è¿™æ ·çš„æ¦‚å¿µäº†ã€‚
- en: '*Topology* is the abstract study of limits and continuity. Having covered the
    essentials of formalization in Chapters [2](C02_Basics.html#basics) to [7](C07_Structures.html#structures),
    in this chapter, we will explain how topological notions are formalized in Mathlib.
    Not only do topological abstractions apply in much greater generality, but they
    also, somewhat paradoxically, make it easier to reason about limits and continuity
    in concrete instances.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**æ‹“æ‰‘å­¦**æ˜¯æé™å’Œè¿ç»­æ€§çš„æŠ½è±¡ç ”ç©¶ã€‚åœ¨ç¬¬äºŒç« åˆ°ç¬¬ä¸ƒç« ä¸­ï¼Œæˆ‘ä»¬å·²ç»æ¶µç›–äº†å½¢å¼åŒ–çš„åŸºæœ¬è¦ç´ ï¼Œæœ¬ç« å°†è§£é‡ŠMathlibä¸­æ‹“æ‰‘æ¦‚å¿µçš„æ­£å¼åŒ–ã€‚ä¸ä»…æ‹“æ‰‘æŠ½è±¡åœ¨æ›´å¹¿æ³›çš„èŒƒå›´å†…é€‚ç”¨ï¼Œè€Œä¸”å®ƒä»¬åœ¨æŸç§ç¨‹åº¦ä¸Šå…·æœ‰çŸ›ç›¾æ€§ï¼Œä½¿å¾—åœ¨å…·ä½“å®ä¾‹ä¸­æ¨ç†æé™å’Œè¿ç»­æ€§å˜å¾—æ›´åŠ å®¹æ˜“ã€‚'
- en: Topological notions build on quite a few layers of mathematical structure. The
    first layer is naive set theory, as described in [Chapter 4](C04_Sets_and_Functions.html#sets-and-functions).
    The next layer is the theory of *filters*, which we will describe in [Section
    11.1](#filters). On top of that, we layer the theories of *topological spaces*,
    *metric spaces*, and a slightly more exotic intermediate notion called a *uniform
    space*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: æ‹“æ‰‘æ¦‚å¿µå»ºç«‹åœ¨è®¸å¤šæ•°å­¦ç»“æ„å±‚ä¹‹ä¸Šã€‚ç¬¬ä¸€å±‚æ˜¯æœ´ç´ é›†åˆè®ºï¼Œå¦‚ç¬¬4ç« æ‰€è¿°ã€‚ä¸‹ä¸€å±‚æ˜¯**è¿‡æ»¤å™¨**ç†è®ºï¼Œæˆ‘ä»¬å°†åœ¨ç¬¬11.1èŠ‚ä¸­æè¿°ã€‚åœ¨æ­¤åŸºç¡€ä¸Šï¼Œæˆ‘ä»¬å åŠ äº†**æ‹“æ‰‘ç©ºé—´**ã€**åº¦é‡ç©ºé—´**ä»¥åŠä¸€ä¸ªç¨å¾®æ›´ç¥ç§˜çš„ä¸­é—´æ¦‚å¿µï¼Œç§°ä¸º**å‡åŒ€ç©ºé—´**ã€‚
- en: 'Whereas previous chapters relied on mathematical notions that were likely familiar
    to you, the notion of a filter is less well known, even to many working mathematicians.
    The notion is essential, however, for formalizing mathematics effectively. Let
    us explain why. Let `f : â„ â†’ â„` be any function. We can consider the limit of
    `f x` as `x` approaches some value `xâ‚€`, but we can also consider the limit of
    `f x` as `x` approaches infinity or negative infinity. We can moreover consider
    the limit of `f x` as `x` approaches `xâ‚€` from the right, conventionally written
    `xâ‚€âº`, or from the left, written `xâ‚€â»`. There are variations where `x` approaches
    `xâ‚€` or `xâ‚€âº` or `xâ‚€â»` but is not allowed to take on the value `xâ‚€` itself. This
    results in at least eight ways that `x` can approach something. We can also restrict
    to rational values of `x` or place other constraints on the domain, but letâ€™s
    stick to those 8 cases.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 'è™½ç„¶å‰å‡ ç« ä¾èµ–äºä½ å¯èƒ½ç†Ÿæ‚‰çš„æ•°å­¦æ¦‚å¿µï¼Œä½†è¿‡æ»¤å™¨è¿™ä¸€æ¦‚å¿µå¯¹è®¸å¤šåœ¨èŒæ•°å­¦å®¶æ¥è¯´å¹¶ä¸é‚£ä¹ˆç†Ÿæ‚‰ã€‚ç„¶è€Œï¼Œè¿™ä¸€æ¦‚å¿µå¯¹äºæœ‰æ•ˆåœ°å½¢å¼åŒ–æ•°å­¦æ˜¯è‡³å…³é‡è¦çš„ã€‚è®©æˆ‘ä»¬è§£é‡Šä¸€ä¸‹åŸå› ã€‚è®¾`f
    : â„ â†’ â„`ä¸ºä»»ä½•å‡½æ•°ã€‚æˆ‘ä»¬å¯ä»¥è€ƒè™‘å½“`x`è¶‹è¿‘äºæŸä¸ªå€¼`xâ‚€`æ—¶`f x`çš„æé™ï¼Œä½†ä¹Ÿå¯ä»¥è€ƒè™‘å½“`x`è¶‹è¿‘äºæ­£æ— ç©·æˆ–è´Ÿæ— ç©·æ—¶`f x`çš„æé™ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥è€ƒè™‘å½“`x`ä»å³ä¾§ï¼ˆé€šå¸¸å†™ä½œ`xâ‚€âº`ï¼‰æˆ–ä»å·¦ä¾§ï¼ˆå†™ä½œ`xâ‚€â»`ï¼‰è¶‹è¿‘äº`xâ‚€`æ—¶`f
    x`çš„æé™ã€‚å­˜åœ¨ä¸€äº›å˜ä½“ï¼Œå…¶ä¸­`x`è¶‹è¿‘äº`xâ‚€`ã€`xâ‚€âº`æˆ–`xâ‚€â»`ï¼Œä½†ä¸å…è®¸`x`å–`xâ‚€`æœ¬èº«çš„å€¼ã€‚è¿™è‡³å°‘å¯¼è‡´äº†`x`è¶‹è¿‘äºæŸç‰©çš„å…«ç§æ–¹å¼ã€‚æˆ‘ä»¬è¿˜å¯ä»¥å°†`x`é™åˆ¶ä¸ºæœ‰ç†å€¼æˆ–å¯¹å®šä¹‰åŸŸæ–½åŠ å…¶ä»–çº¦æŸï¼Œä½†è®©æˆ‘ä»¬åšæŒè¿™8ç§æƒ…å†µã€‚'
- en: 'We have a similar variety of options on the codomain: we can specify that `f
    x` approaches a value from the left or right, or that it approaches positive or
    negative infinity, and so on. For example, we may wish to say that `f x` tends
    to `+âˆ` when `x` tends to `xâ‚€` from the right without being equal to `xâ‚€`. This
    results in 64 different kinds of limit statements, and we havenâ€™t even begun to
    deal with limits of sequences, as we did in [Section 3.6](C03_Logic.html#sequences-and-convergence).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨å€¼åŸŸä¸Šä¹Ÿæœ‰ç±»ä¼¼çš„å¤šç§é€‰æ‹©ï¼šæˆ‘ä»¬å¯ä»¥æŒ‡å®š`f x`æ˜¯ä»å·¦è¾¹è¿˜æ˜¯å³è¾¹æ¥è¿‘ä¸€ä¸ªå€¼ï¼Œæˆ–è€…å®ƒæ¥è¿‘æ­£æ— ç©·æˆ–è´Ÿæ— ç©·ï¼Œç­‰ç­‰ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯èƒ½å¸Œæœ›è¯´ï¼Œå½“`x`ä»å³è¾¹è¶‹å‘äº`xâ‚€`è€Œä¸ç­‰äº`xâ‚€`æ—¶ï¼Œ`f
    x`è¶‹å‘äº`+âˆ`ã€‚è¿™å¯¼è‡´äº†64ç§ä¸åŒçš„æé™é™ˆè¿°ï¼Œè€Œæˆ‘ä»¬ç”šè‡³è¿˜æ²¡æœ‰å¼€å§‹å¤„ç†ä¸æˆ‘ä»¬åœ¨[ç¬¬3.6èŠ‚](C03_Logic.html#sequences-and-convergence)ä¸­å¤„ç†åºåˆ—æé™ç±»ä¼¼çš„æƒ…å†µã€‚
- en: 'The problem is compounded even further when it comes to the supporting lemmas.
    For instance, limits compose: if `f x` tends to `yâ‚€` when `x` tends to `xâ‚€` and
    `g y` tends to `zâ‚€` when `y` tends to `yâ‚€` then `g âˆ˜ f x` tends to `zâ‚€` when `x`
    tends to `xâ‚€`. There are three notions of â€œtends toâ€ at play here, each of which
    can be instantiated in any of the eight ways described in the previous paragraph.
    This results in 512 lemmas, a lot to have to add to a library! Informally, mathematicians
    generally prove two or three of these and simply note that the rest can be proved
    â€œin the same way.â€ Formalizing mathematics requires making the relevant notion
    of â€œsamenessâ€ fully explicit, and that is exactly what Bourbakiâ€™s theory of filters
    manages to do.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æ¶‰åŠåˆ°æ”¯æŒå¼•ç†æ—¶ï¼Œé—®é¢˜å˜å¾—æ›´åŠ å¤æ‚ã€‚ä¾‹å¦‚ï¼Œæé™å¯ä»¥ç»„åˆï¼šå¦‚æœ`f x`åœ¨`x`è¶‹å‘äº`xâ‚€`æ—¶è¶‹å‘äº`yâ‚€`ï¼Œè€Œ`g y`åœ¨`y`è¶‹å‘äº`yâ‚€`æ—¶è¶‹å‘äº`zâ‚€`ï¼Œé‚£ä¹ˆ`g
    âˆ˜ f x`åœ¨`x`è¶‹å‘äº`xâ‚€`æ—¶ä¹Ÿè¶‹å‘äº`zâ‚€`ã€‚è¿™é‡Œæ¶‰åŠåˆ°ä¸‰ç§â€œè¶‹å‘äºâ€çš„æ¦‚å¿µï¼Œæ¯ç§éƒ½å¯ä»¥ç”¨å‰ä¸€æ®µæè¿°çš„å…«ç§æ–¹å¼ä¸­çš„ä»»ä½•ä¸€ç§æ¥å®ä¾‹åŒ–ã€‚è¿™å¯¼è‡´äº†512ä¸ªå¼•ç†ï¼Œè¦æ·»åŠ åˆ°åº“ä¸­ç¡®å®å¾ˆå¤šï¼éæ­£å¼åœ°è¯´ï¼Œæ•°å­¦å®¶é€šå¸¸åªè¯æ˜å…¶ä¸­ä¸¤ä¸‰ä¸ªï¼Œå¹¶ç®€å•åœ°æ³¨æ˜å…¶ä½™çš„å¯ä»¥â€œä»¥ç›¸åŒçš„æ–¹å¼â€è¯æ˜ã€‚å½¢å¼åŒ–æ•°å­¦éœ€è¦ä½¿ç›¸å…³çš„â€œç›¸åŒâ€æ¦‚å¿µå®Œå…¨æ˜ç¡®ï¼Œè¿™æ­£æ˜¯Bourbakiçš„æ»¤æ³¢å™¨ç†è®ºæ‰€åšåˆ°çš„ã€‚
- en: '## 11.1\. Filters[ïƒ](#filters "Link to this heading")'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '## 11.1\. æ»¤æ³¢å™¨[ïƒ](#filters "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")'
- en: 'A *filter* on a type `X` is a collection of sets of `X` that satisfies three
    conditions that we will spell out below. The notion supports two related ideas:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç±»å‹`X`ä¸Šçš„*æ»¤æ³¢å™¨*æ˜¯ä¸€ç»„æ»¡è¶³ä»¥ä¸‹ä¸‰ä¸ªæ¡ä»¶çš„`X`çš„é›†åˆã€‚è¿™ä¸ªæ¦‚å¿µæ”¯æŒä¸¤ä¸ªç›¸å…³æƒ³æ³•ï¼š
- en: '*limits*, including all the kinds of limits discussed above: finite and infinite
    limits of sequences, finite and infinite limits of functions at a point or at
    infinity, and so on.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*æé™*ï¼ŒåŒ…æ‹¬ä¸Šé¢è®¨è®ºçš„æ‰€æœ‰ç±»å‹çš„æé™ï¼šåºåˆ—çš„æœ‰é™å’Œæ— é™æé™ï¼Œå‡½æ•°åœ¨ä¸€ç‚¹æˆ–æ— ç©·è¿œå¤„çš„æœ‰é™å’Œæ— é™æé™ï¼Œç­‰ç­‰ã€‚'
- en: '*things happening eventually*, including things happening for large enough
    `n : â„•`, or sufficiently near a point `x`, or for sufficiently close pairs of
    points, or almost everywhere in the sense of measure theory. Dually, filters can
    also express the idea of *things happening often*: for arbitrarily large `n`,
    at a point in any neighborhood of a given point, etc.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*æœ€ç»ˆå‘ç”Ÿçš„äº‹æƒ…*ï¼ŒåŒ…æ‹¬å¯¹äºè¶³å¤Ÿå¤§çš„`n : â„•`ï¼Œæˆ–è€…åœ¨è¶³å¤Ÿæ¥è¿‘çš„ç‚¹`x`ï¼Œæˆ–è€…åœ¨è¶³å¤Ÿæ¥è¿‘çš„ç‚¹å¯¹ï¼Œæˆ–è€…åœ¨æµ‹åº¦ç†è®ºæ„ä¹‰ä¸Šçš„å‡ ä¹å¤„å¤„ã€‚ç±»ä¼¼åœ°ï¼Œæ»¤æ³¢å™¨ä¹Ÿå¯ä»¥è¡¨è¾¾*ç»å¸¸å‘ç”Ÿçš„äº‹æƒ…*çš„æ¦‚å¿µï¼šå¯¹äºä»»æ„å¤§çš„`n`ï¼Œåœ¨ä»»æ„ç»™å®šç‚¹çš„ä»»æ„é‚»åŸŸä¸­ç­‰ã€‚'
- en: 'The filters that correspond to these descriptions will be defined later in
    this section, but we can already name them:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹åº”è¿™äº›æè¿°çš„æ»¤æ³¢å™¨å°†åœ¨æœ¬èŠ‚åé¢å®šä¹‰ï¼Œä½†æˆ‘ä»¬å·²ç»å¯ä»¥å‘½åå®ƒä»¬ï¼š
- en: '`(atTop : Filter â„•)`, made of sets of `â„•` containing `{n | n â‰¥ N}` for some
    `N`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(atTop : Filter â„•)`, ç”±åŒ…å«`{n | n â‰¥ N}`ï¼ˆå¯¹äºæŸä¸ª`N`ï¼‰çš„`â„•`çš„é›†åˆç»„æˆ'
- en: '`ğ“ x`, made of neighborhoods of `x` in a topological space'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ğ“ x`, ç”±æ‹“æ‰‘ç©ºé—´ä¸­`x`çš„é‚»åŸŸç»„æˆ'
- en: '`ğ“¤ X`, made of entourages of a uniform space (uniform spaces generalize metric
    spaces and topological groups)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ğ“¤ X`ï¼Œç”±å‡åŒ€ç©ºé—´ï¼ˆå‡åŒ€ç©ºé—´æ˜¯åº¦é‡ç©ºé—´å’Œæ‹“æ‰‘ç¾¤çš„æ¨å¹¿ï¼‰çš„é‚»åŸŸç»„æˆã€‚'
- en: '`Î¼.ae` , made of sets whose complement has zero measure with respect to a measure
    `Î¼`.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Î¼.ae`ï¼Œç”±è¡¥é›†ç›¸å¯¹äºæµ‹åº¦`Î¼`çš„æµ‹åº¦ä¸ºé›¶çš„é›†åˆç»„æˆã€‚'
- en: 'The general definition is as follows: a filter `F : Filter X` is a collection
    of sets `F.sets : Set (Set X)` satisfying the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¸€èˆ¬å®šä¹‰å¦‚ä¸‹ï¼šä¸€ä¸ª`Filter X`çš„æ»¤æ³¢å™¨æ˜¯ä¸€ä¸ªæ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„é›†åˆ`F.sets : Set (Set X)`ï¼š'
- en: '`F.univ_sets : univ âˆˆ F.sets`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F.univ_sets : univ âˆˆ F.sets`'
- en: '`F.sets_of_superset : âˆ€ {U V}, U âˆˆ F.sets â†’ U âŠ† V â†’ V âˆˆ F.sets`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F.sets_of_superset : âˆ€ {U V}, U âˆˆ F.sets â†’ U âŠ† V â†’ V âˆˆ F.sets`'
- en: '`F.inter_sets : âˆ€ {U V}, U âˆˆ F.sets â†’ V âˆˆ F.sets â†’ U âˆ© V âˆˆ F.sets`.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F.inter_sets : âˆ€ {U V}, U âˆˆ F.sets â†’ V âˆˆ F.sets â†’ U âˆ© V âˆˆ F.sets`ã€‚'
- en: The first condition says that the set of all elements of `X` belongs to `F.sets`.
    The second condition says that if `U` belongs to `F.sets` then anything containing
    `U` also belongs to `F.sets`. The third condition says that `F.sets` is closed
    under finite intersections. In Mathlib, a filter `F` is defined to be a structure
    bundling `F.sets` and its three properties, but the properties carry no additional
    data, and it is convenient to blur the distinction between `F` and `F.sets`. We
    therefore define `U âˆˆ F` to mean `U âˆˆ F.sets`. This explains why the word `sets`
    appears in the names of some lemmas that that mention `U âˆˆ F`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ä¸ªæ¡ä»¶è¯´æ˜ `X` çš„æ‰€æœ‰å…ƒç´ é›†åˆå±äº `F.sets`ã€‚ç¬¬äºŒä¸ªæ¡ä»¶è¯´æ˜å¦‚æœ `U` å±äº `F.sets`ï¼Œé‚£ä¹ˆåŒ…å« `U` çš„ä»»ä½•ä¸œè¥¿ä¹Ÿå±äº `F.sets`ã€‚ç¬¬ä¸‰ä¸ªæ¡ä»¶è¯´æ˜
    `F.sets` å¯¹æœ‰é™äº¤é›†æ˜¯å°é—­çš„ã€‚åœ¨ Mathlib ä¸­ï¼Œè¿‡æ»¤å™¨ `F` è¢«å®šä¹‰ä¸ºæ†ç»‘ `F.sets` å’Œå…¶ä¸‰ä¸ªå±æ€§çš„æ„é€ ï¼Œä½†å±æ€§ä¸æºå¸¦ä»»ä½•é¢å¤–æ•°æ®ï¼Œå¹¶ä¸”å°†
    `F` å’Œ `F.sets` ä¹‹é—´çš„åŒºåˆ«æ¨¡ç³ŠåŒ–æ˜¯æ–¹ä¾¿çš„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å®šä¹‰ `U âˆˆ F` ä¸º `U âˆˆ F.sets`ã€‚è¿™è§£é‡Šäº†ä¸ºä»€ä¹ˆåœ¨æåŠ `U âˆˆ F`
    çš„æŸäº›å¼•ç†åç§°ä¸­å‡ºç°äº†å•è¯ `sets`ã€‚
- en: It may help to think of a filter as defining a notion of a â€œsufficiently largeâ€
    set. The first condition then says that `univ` is sufficiently large, the second
    one says that a set containing a sufficiently large set is sufficiently large
    and the third one says that the intersection of two sufficiently large sets is
    sufficiently large.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: å°†è¿‡æ»¤å™¨è§†ä¸ºå®šä¹‰â€œè¶³å¤Ÿå¤§â€çš„é›†åˆçš„æ¦‚å¿µå¯èƒ½æœ‰æ‰€å¸®åŠ©ã€‚ç¬¬ä¸€ä¸ªæ¡ä»¶è¯´æ˜ `univ` æ˜¯è¶³å¤Ÿå¤§çš„ï¼Œç¬¬äºŒä¸ªæ¡ä»¶è¯´æ˜åŒ…å«è¶³å¤Ÿå¤§é›†åˆçš„é›†åˆä¹Ÿæ˜¯è¶³å¤Ÿå¤§çš„ï¼Œç¬¬ä¸‰ä¸ªæ¡ä»¶è¯´æ˜ä¸¤ä¸ªè¶³å¤Ÿå¤§é›†åˆçš„äº¤é›†ä¹Ÿæ˜¯è¶³å¤Ÿå¤§çš„ã€‚
- en: 'It may be even more useful to think of a filter on a type `X` as a generalized
    element of `Set X`. For instance, `atTop` is the â€œset of very large numbersâ€ and
    `ğ“ xâ‚€` is the â€œset of points very close to `xâ‚€`.â€ One manifestation of this view
    is that we can associate to any `s : Set X` the so-called *principal filter* consisting
    of all sets that contain `s`. This definition is already in Mathlib and has a
    notation `ğ“Ÿ` (localized in the `Filter` namespace). For the purpose of demonstration,
    we ask you to take this opportunity to work out the definition here.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 'å°†ç±»å‹ `X` ä¸Šçš„è¿‡æ»¤å™¨è§†ä¸º `Set X` çš„å¹¿ä¹‰å…ƒç´ å¯èƒ½æ›´æœ‰ç”¨ã€‚ä¾‹å¦‚ï¼Œ`atTop` æ˜¯â€œéå¸¸å¤§çš„æ•°é›†â€ï¼Œè€Œ `ğ“ xâ‚€` æ˜¯â€œéå¸¸æ¥è¿‘ `xâ‚€`
    çš„ç‚¹é›†â€ã€‚è¿™ç§è§‚ç‚¹çš„ä¸€ä¸ªè¡¨ç°æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥å°†æ‰€è°“çš„â€œä¸»è¿‡æ»¤å™¨â€ä¸ä»»ä½• `s : Set X` å…³è”èµ·æ¥ï¼Œè¯¥è¿‡æ»¤å™¨åŒ…å«æ‰€æœ‰åŒ…å« `s` çš„é›†åˆã€‚è¿™ä¸ªå®šä¹‰å·²ç»åœ¨
    Mathlib ä¸­ï¼Œå¹¶ä¸”æœ‰ä¸€ä¸ªç¬¦å· `ğ“Ÿ`ï¼ˆåœ¨ `Filter` å‘½åç©ºé—´ä¸­å±€éƒ¨åŒ–ï¼‰ã€‚ä¸ºäº†æ¼”ç¤ºç›®çš„ï¼Œæˆ‘ä»¬è¦æ±‚æ‚¨åˆ©ç”¨è¿™ä¸ªæœºä¼šåœ¨è¿™é‡Œæ¨å¯¼å‡ºè¿™ä¸ªå®šä¹‰ã€‚'
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For our second example, we ask you to define the filter `atTop : Filter â„•`.
    (We could use any type with a preorder instead of `â„•`.)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 'å¯¹äºæˆ‘ä»¬çš„ç¬¬äºŒä¸ªä¾‹å­ï¼Œæˆ‘ä»¬è¦æ±‚æ‚¨å®šä¹‰è¿‡æ»¤å™¨ `atTop : Filter â„•`ã€‚ï¼ˆæˆ‘ä»¬å¯ä»¥ç”¨ä»»ä½•å…·æœ‰ååºçš„ `â„•` æ›¿ä»£ã€‚ï¼‰'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can also directly define the filter `ğ“ x` of neighborhoods of any `x : â„`.
    In the real numbers, a neighborhood of `x` is a set containing an open interval
    \((x_0 - \varepsilon, x_0 + \varepsilon)\), defined in Mathlib as `Ioo (xâ‚€ - Îµ)
    (xâ‚€ + Îµ)`. (This notion of a neighborhood is only a special case of a more general
    construction in Mathlib.)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 'æˆ‘ä»¬è¿˜å¯ä»¥ç›´æ¥å®šä¹‰ä»»ä½• `x : â„` çš„é‚»åŸŸè¿‡æ»¤å™¨ `ğ“ x`ã€‚åœ¨å®æ•°ä¸­ï¼Œ`x` çš„é‚»åŸŸæ˜¯ä¸€ä¸ªåŒ…å«å¼€åŒºé—´ \((x_0 - \varepsilon,
    x_0 + \varepsilon)\) çš„é›†åˆï¼Œåœ¨ Mathlib ä¸­å®šä¹‰ä¸º `Ioo (xâ‚€ - Îµ) (xâ‚€ + Îµ)`ã€‚ï¼ˆè¿™ç§é‚»åŸŸçš„æ¦‚å¿µåªæ˜¯ Mathlib
    ä¸­æ›´ä¸€èˆ¬æ„é€ çš„ä¸€ä¸ªç‰¹ä¾‹ã€‚ï¼‰'
- en: 'With these examples, we can already define what it means for a function `f
    : X â†’ Y` to converge to some `G : Filter Y` along some `F : Filter X`, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 'é€šè¿‡è¿™äº›ä¾‹å­ï¼Œæˆ‘ä»¬å·²ç»åœ¨ä»¥ä¸‹æ–¹é¢å®šä¹‰äº†å‡½æ•° `f : X â†’ Y` æ²¿ç€æŸä¸ª `F : Filter X` æ”¶æ•›åˆ°æŸä¸ª `G : Filter Y`
    çš„å«ä¹‰ï¼š'
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When `X` is `â„•` and `Y` is `â„`, `Tendstoâ‚ u atTop (ğ“ x)` is equivalent to saying
    that the sequence `u : â„• â†’ â„` converges to the real number `x`. When both `X`
    and `Y` are `â„`, `Tendsto f (ğ“ xâ‚€) (ğ“ yâ‚€)` is equivalent to the familiar notion
    \(\lim_{x \to xâ‚€} f(x) = yâ‚€\). All of the other kinds of limits mentioned in the
    introduction are also equivalent to instances of `Tendstoâ‚` for suitable choices
    of filters on the source and target.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 'å½“ `X` æ˜¯ `â„•` ä¸” `Y` æ˜¯ `â„` æ—¶ï¼Œ`Tendstoâ‚ u atTop (ğ“ x)` ç­‰ä»·äºè¯´åºåˆ— `u : â„• â†’ â„` æ”¶æ•›åˆ°å®æ•°
    `x`ã€‚å½“ `X` å’Œ `Y` éƒ½æ˜¯ `â„` æ—¶ï¼Œ`Tendsto f (ğ“ xâ‚€) (ğ“ yâ‚€)` ç­‰ä»·äºç†Ÿæ‚‰çš„æé™æ¦‚å¿µ \(\lim_{x \to xâ‚€}
    f(x) = yâ‚€\)ã€‚ä»‹ç»ä¸­æåˆ°çš„æ‰€æœ‰å…¶ä»–ç±»å‹çš„æé™ä¹Ÿç­‰ä»·äºåœ¨æºå’Œç›®æ ‡ä¸Šé€‰æ‹©åˆé€‚çš„è¿‡æ»¤å™¨æ—¶çš„ `Tendstoâ‚` çš„å®ä¾‹ã€‚'
- en: 'The notion `Tendstoâ‚` above is definitionally equivalent to the notion `Tendsto`
    that is defined in Mathlib, but the latter is defined more abstractly. The problem
    with the definition of `Tendstoâ‚` is that it exposes a quantifier and elements
    of `G`, and it hides the intuition that we get by viewing filters as generalized
    sets. We can hide the quantifier `âˆ€ V` and make the intuition more salient by
    using more algebraic and set-theoretic machinery. The first ingredient is the
    *pushforward* operation \(f_*\) associated to any map `f : X â†’ Y`, denoted `Filter.map
    f` in Mathlib. Given a filter `F` on `X`, `Filter.map f F : Filter Y` is defined
    so that `V âˆˆ Filter.map f F â†” f â»Â¹'' V âˆˆ F` holds definitionally. In the example
    file weâ€™ve opened the `Filter` namespace so that `Filter.map` can be written as
    `map`. This means that we can rewrite the definition of `Tendsto` using the order
    relation on `Filter Y`, which is reversed inclusion of the set of members. In
    other words, given `G H : Filter Y`, we have `G â‰¤ H â†” âˆ€ V : Set Y, V âˆˆ H â†’ V âˆˆ
    G`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¸Šè¿°çš„ `Tendstoâ‚` æ¦‚å¿µåœ¨å®šä¹‰ä¸Šç­‰åŒäº Mathlib ä¸­å®šä¹‰çš„ `Tendsto` æ¦‚å¿µï¼Œä½†åè€…å®šä¹‰å¾—æ›´ä¸ºæŠ½è±¡ã€‚`Tendstoâ‚` å®šä¹‰çš„ç¼ºç‚¹æ˜¯å®ƒæš´éœ²äº†é‡è¯å’Œ
    `G` çš„å…ƒç´ ï¼Œå¹¶éšè—äº†æˆ‘ä»¬é€šè¿‡å°†è¿‡æ»¤å™¨è§†ä¸ºå¹¿ä¹‰é›†åˆæ‰€è·å¾—çš„ç›´è§‚æ„Ÿå—ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨æ›´å¤šçš„ä»£æ•°å’Œé›†åˆè®ºå·¥å…·æ¥éšè—é‡è¯ `âˆ€ V` å¹¶ä½¿ç›´è§‚æ„Ÿå—æ›´åŠ æ˜æ˜¾ã€‚ç¬¬ä¸€ä¸ªè¦ç´ æ˜¯ä¸ä»»ä½•æ˜ å°„
    `f : X â†’ Y` ç›¸å…³çš„ *å‰æ¨* æ“ä½œ \(f_*\)ï¼Œåœ¨ Mathlib ä¸­è¡¨ç¤ºä¸º `Filter.map f`ã€‚ç»™å®š `X` ä¸Šçš„è¿‡æ»¤å™¨ `F`ï¼Œ`Filter.map
    f F : Filter Y` è¢«å®šä¹‰ä¸ºä½¿å¾— `V âˆˆ Filter.map f F â†” f â»Â¹'' V âˆˆ F` æˆç«‹ã€‚åœ¨ç¤ºä¾‹æ–‡ä»¶ä¸­ï¼Œæˆ‘ä»¬å·²ç»æ‰“å¼€äº† `Filter`
    å‘½åç©ºé—´ï¼Œä»¥ä¾¿å¯ä»¥å°† `Filter.map` å†™ä½œ `map`ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `Filter Y` ä¸Šçš„é¡ºåºå…³ç³»æ¥é‡å†™ `Tendsto` çš„å®šä¹‰ï¼Œè¿™ç§é¡ºåºå…³ç³»æ˜¯æˆå‘˜é›†çš„é€†åŒ…å«ã€‚æ¢å¥è¯è¯´ï¼Œç»™å®š
    `G H : Filter Y`ï¼Œæˆ‘ä»¬æœ‰ `G â‰¤ H â†” âˆ€ V : Set Y, V âˆˆ H â†’ V âˆˆ G`ã€‚'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It may seem that the order relation on filters is backward. But recall that
    we can view filters on `X` as generalized elements of `Set X`, via the inclusion
    of `ğ“Ÿ : Set X â†’ Filter X` which maps any set `s` to the corresponding principal
    filter. This inclusion is order preserving, so the order relation on `Filter`
    can indeed be seen as the natural inclusion relation between generalized sets.
    In this analogy, pushforward is analogous to the direct image. And, indeed, `map
    f (ğ“Ÿ s) = ğ“Ÿ (f '''' s)`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 'å¯èƒ½çœ‹èµ·æ¥è¿‡æ»¤å™¨ä¸Šçš„é¡ºåºå…³ç³»æ˜¯ç›¸åçš„ã€‚ä½†å›æƒ³ä¸€ä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ `ğ“Ÿ : Set X â†’ Filter X` çš„åŒ…å«æ¥å°† `X` ä¸Šçš„è¿‡æ»¤å™¨è§†ä¸º `Set
    X` çš„å¹¿ä¹‰å…ƒç´ ï¼Œè¯¥æ˜ å°„å°†ä»»ä½•é›†åˆ `s` æ˜ å°„åˆ°ç›¸åº”çš„æœ¬åŸè¿‡æ»¤å™¨ã€‚è¿™ä¸ªåŒ…å«æ˜¯é¡ºåºä¿æŒçš„ï¼Œå› æ­¤ `Filter` ä¸Šçš„é¡ºåºå…³ç³»ç¡®å®å¯ä»¥è¢«è§†ä¸ºå¹¿ä¹‰é›†åˆä¹‹é—´çš„è‡ªç„¶åŒ…å«å…³ç³»ã€‚åœ¨è¿™ä¸ªç±»æ¯”ä¸­ï¼Œå‰æ¨ç±»ä¼¼äºç›´æ¥åƒã€‚å®é™…ä¸Šï¼Œ`map
    f (ğ“Ÿ s) = ğ“Ÿ (f '''' s)`ã€‚'
- en: 'We can now understand intuitively why a sequence `u : â„• â†’ â„` converges to a
    point `xâ‚€` if and only if we have `map u atTop â‰¤ ğ“ xâ‚€`. The inequality means the
    â€œdirect image under `u`â€ of â€œthe set of very big natural numbersâ€ is â€œincludedâ€
    in â€œthe set of points very close to `xâ‚€`.â€'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥ç›´è§‚åœ°ç†è§£ä¸ºä»€ä¹ˆåºåˆ— `u : â„• â†’ â„` æ”¶æ•›åˆ°ç‚¹ `xâ‚€` å½“ä¸”ä»…å½“æˆ‘ä»¬æœ‰ `map u atTop â‰¤ ğ“ xâ‚€`ã€‚ä¸ç­‰å¼æ„å‘³ç€â€œåœ¨
    `u` ä¸‹çš„ç›´æ¥åƒâ€çš„â€œéå¸¸å¤§çš„è‡ªç„¶æ•°é›†â€åŒ…å«åœ¨â€œéå¸¸æ¥è¿‘ `xâ‚€` çš„ç‚¹é›†â€ä¸­ã€‚'
- en: As promised, the definition of `Tendstoâ‚‚` does not exhibit any quantifiers or
    sets. It also leverages the algebraic properties of the pushforward operation.
    First, each `Filter.map f` is monotone. And, second, `Filter.map` is compatible
    with composition.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æ‰¿è¯ºçš„é‚£æ ·ï¼Œ`Tendstoâ‚‚` çš„å®šä¹‰æ²¡æœ‰å±•ç¤ºä»»ä½•é‡è¯æˆ–é›†åˆã€‚å®ƒè¿˜åˆ©ç”¨äº†å‰æ¨æ“ä½œä»£æ•°æ€§è´¨ã€‚é¦–å…ˆï¼Œæ¯ä¸ª `Filter.map f` æ˜¯å•è°ƒçš„ã€‚å…¶æ¬¡ï¼Œ`Filter.map`
    ä¸ç»„åˆå…¼å®¹ã€‚
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Together these two properties allow us to prove that limits compose, yielding
    in one shot all 512 variants of the composition lemma described in the introduction,
    and lots more. You can practice proving the following statement using either the
    definition of `Tendstoâ‚` in terms of the universal quantifier or the algebraic
    definition, together with the two lemmas above.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸¤ä¸ªæ€§è´¨å…±åŒå…è®¸æˆ‘ä»¬è¯æ˜æé™å¯ä»¥ç»„åˆï¼Œä¸€æ¬¡äº§ç”Ÿä»‹ç»ä¸­æè¿°çš„ 512 ç§ç»„åˆå…¬ç†å˜ä½“ï¼Œä»¥åŠæ›´å¤šã€‚ä½ å¯ä»¥ä½¿ç”¨ `Tendstoâ‚` çš„å…³äºå…¨ç§°é‡è¯çš„å®šä¹‰æˆ–ä»£æ•°å®šä¹‰ï¼Œä»¥åŠä¸Šè¿°ä¸¤ä¸ªå¼•ç†æ¥ç»ƒä¹ è¯æ˜ä»¥ä¸‹é™ˆè¿°ã€‚
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The pushforward construction uses a map to push filters from the map source
    to the map target. There also a *pullback* operation, `Filter.comap`, going in
    the other direction. This generalizes the preimage operation on sets. For any
    map `f`, `Filter.map f` and `Filter.comap f` form what is known as a *Galois connection*,
    which is to say, they satisfy
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: å‰æ¨æ„é€ ä½¿ç”¨æ˜ å°„å°†è¿‡æ»¤å™¨ä»æ˜ å°„æºæ¨é€åˆ°æ˜ å°„ç›®æ ‡ã€‚è¿˜æœ‰ä¸€ä¸ª *åæ¨* æ“ä½œï¼Œ`Filter.comap`ï¼Œæœç›¸åçš„æ–¹å‘è¿›è¡Œã€‚è¿™æ¨å¹¿äº†é›†åˆä¸Šçš„å‰åƒæ“ä½œã€‚å¯¹äºä»»ä½•æ˜ å°„
    `f`ï¼Œ`Filter.map f` å’Œ `Filter.comap f` å½¢æˆäº†æ‰€è°“çš„ *Galois è¿æ¥*ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒä»¬æ»¡è¶³
- en: '`Filter.map_le_iff_le_comap : Filter.map f F â‰¤ G â†” F â‰¤ Filter.comap f G`'
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Filter.map_le_iff_le_comap : Filter.map f F â‰¤ G â†” F â‰¤ Filter.comap f G`'
- en: for every `F` and `G`. This operation could be used to provided another formulation
    of `Tendsto` that would be provably (but not definitionally) equivalent to the
    one in Mathlib.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæ¯ä¸ª `F` å’Œ `G`ã€‚è¿™ä¸ªè¿ç®—å¯ä»¥ç”¨æ¥æä¾› `Tendsto` çš„å¦ä¸€ç§è¡¨è¿°ï¼Œè¿™å°†è¯æ˜ä¸Šæ˜¯ï¼ˆä½†ä¸æ˜¯å®šä¹‰ä¸Šï¼‰ç­‰ä»·äº Mathlib ä¸­çš„è¡¨è¿°ã€‚
- en: 'The `comap` operation can be used to restrict filters to a subtype. For instance,
    suppose we have `f : â„ â†’ â„`, `xâ‚€ : â„` and `yâ‚€ : â„`, and suppose we want to state
    that `f x` approaches `yâ‚€` when `x` approaches `xâ‚€` within the rational numbers.
    We can pull the filter `ğ“ xâ‚€` back to `â„š` using the coercion map `(â†‘) : â„š â†’ â„`
    and state `Tendsto (f âˆ˜ (â†‘) : â„š â†’ â„) (comap (â†‘) (ğ“ xâ‚€)) (ğ“ yâ‚€)`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`comap` è¿ç®—å¯ä»¥ç”¨æ¥å°†è¿‡æ»¤å™¨é™åˆ¶ä¸ºå­ç±»å‹ã€‚ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ `f : â„ â†’ â„`ã€`xâ‚€ : â„` å’Œ `yâ‚€ : â„`ï¼Œå¹¶ä¸”å‡è®¾æˆ‘ä»¬æƒ³è¦è¯´æ˜å½“
    `x` åœ¨æœ‰ç†æ•°ä¸­æ¥è¿‘ `xâ‚€` æ—¶ï¼Œ`f x` æ¥è¿‘ `yâ‚€`ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¼ºåˆ¶æ˜ å°„ `(â†‘) : â„š â†’ â„` å°†è¿‡æ»¤å™¨ `ğ“ xâ‚€` åå‘æ˜ å°„åˆ° `â„š`ï¼Œå¹¶å£°æ˜
    `Tendsto (f âˆ˜ (â†‘) : â„š â†’ â„) (comap (â†‘) (ğ“ xâ‚€)) (ğ“ yâ‚€)`ã€‚'
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The pullback operation is also compatible with composition, but it is *contravariant*,
    which is to say, it reverses the order of the arguments.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: åå‡½æ•°è¿ç®—ä¹Ÿä¸ç»„åˆå…¼å®¹ï¼Œä½†å®ƒå…·æœ‰åå˜æ€§è´¨ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒåè½¬äº†å‚æ•°çš„é¡ºåºã€‚
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Letâ€™s now shift attention to the plane `â„ Ã— â„` and try to understand how the
    neighborhoods of a point `(xâ‚€, yâ‚€)` are related to `ğ“ xâ‚€` and `ğ“ yâ‚€`. There is
    a product operation `Filter.prod : Filter X â†’ Filter Y â†’ Filter (X Ã— Y)`, denoted
    by `Ã—Ë¢`, which answers this question:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç°åœ¨æˆ‘ä»¬å°†æ³¨æ„åŠ›è½¬å‘å¹³é¢ `â„ Ã— â„`ï¼Œå¹¶å°è¯•ç†è§£ç‚¹ `(xâ‚€, yâ‚€)` çš„é‚»åŸŸå¦‚ä½•ä¸ `ğ“ xâ‚€` å’Œ `ğ“ yâ‚€` ç›¸å…³ã€‚å­˜åœ¨ä¸€ä¸ªä¹˜æ³•è¿ç®— `Filter.prod
    : Filter X â†’ Filter Y â†’ Filter (X Ã— Y)`ï¼Œè¡¨ç¤ºä¸º `Ã—Ë¢`ï¼Œå®ƒå›ç­”äº†è¿™ä¸ªé—®é¢˜ï¼š'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The product operation is defined in terms of the pullback operation and the
    `inf` operation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹˜æ³•è¿ç®—å®šä¹‰ä¸ºåå‡½æ•°è¿ç®—å’Œ `inf` è¿ç®—çš„æœ¯è¯­ï¼š
- en: '`F Ã—Ë¢ G = (comap Prod.fst F) âŠ“ (comap Prod.snd G)`.'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`F Ã—Ë¢ G = (comap Prod.fst F) âŠ“ (comap Prod.snd G)`ã€‚'
- en: Here the `inf` operation refers to the lattice structure on `Filter X` for any
    type `X`, whereby `F âŠ“ G` is the greatest filter that is smaller than both `F`
    and `G`. Thus the `inf` operation generalizes the notion of the intersection of
    sets.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œ `inf` è¿ç®—æŒ‡çš„æ˜¯ä»»ä½•ç±»å‹ `X` ä¸Š `Filter X` çš„æ ¼ç»“æ„ï¼Œå…¶ä¸­ `F âŠ“ G` æ˜¯å°äº `F` å’Œ `G` çš„æœ€å¤§è¿‡æ»¤å™¨ã€‚å› æ­¤ï¼Œ`inf`
    è¿ç®—æ¨å¹¿äº†é›†åˆäº¤é›†çš„æ¦‚å¿µã€‚
- en: A lot of proofs in Mathlib use all of the aforementioned structure (`map`, `comap`,
    `inf`, `sup`, and `prod`) to give algebraic proofs about convergence without ever
    referring to members of filters. You can practice doing this in a proof of the
    following lemma, unfolding the definition of `Tendsto` and `Filter.prod` if needed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib ä¸­è®¸å¤šè¯æ˜éƒ½ä½¿ç”¨äº†ä¸Šè¿°æ‰€æœ‰ç»“æ„ï¼ˆ`map`ã€`comap`ã€`inf`ã€`sup` å’Œ `prod`ï¼‰æ¥ç»™å‡ºå…³äºæ”¶æ•›æ€§çš„ä»£æ•°è¯æ˜ï¼Œè€Œä»æœªå¼•ç”¨è¿‡æ»¤å™¨çš„æˆå‘˜ã€‚ä½ å¯ä»¥åœ¨ä»¥ä¸‹å¼•ç†çš„è¯æ˜ä¸­ç»ƒä¹ è¿™æ ·åšï¼Œå¦‚æœéœ€è¦ï¼Œå¯ä»¥å±•å¼€
    `Tendsto` å’Œ `Filter.prod` çš„å®šä¹‰ã€‚
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The ordered type `Filter X` is actually a *complete* lattice, which is to say,
    there is a bottom element, there is a top element, and every set of filters on
    `X` has an `Inf` and a `Sup`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰åºç±»å‹ `Filter X` å®é™…ä¸Šæ˜¯ä¸€ä¸ª *å®Œå¤‡* æ‹“æ‰‘ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå­˜åœ¨ä¸€ä¸ªåº•å…ƒç´ ï¼Œå­˜åœ¨ä¸€ä¸ªé¡¶å…ƒç´ ï¼Œå¹¶ä¸” `X` ä¸Šçš„æ¯ä¸ªè¿‡æ»¤å™¨é›†åˆéƒ½æœ‰ä¸€ä¸ª `Inf`
    å’Œä¸€ä¸ª `Sup`ã€‚
- en: 'Note that given the second property in the definition of a filter (if `U` belongs
    to `F` then anything larger than `U` also belongs to `F`), the first property
    (the set of all inhabitants of `X` belongs to `F`) is equivalent to the property
    that `F` is not the empty collection of sets. This shouldnâ€™t be confused with
    the more subtle question as to whether the empty set is an *element* of `F`. The
    definition of a filter does not prohibit `âˆ… âˆˆ F`, but if the empty set is in `F`
    then every set is in `F`, which is to say, `âˆ€ U : Set X, U âˆˆ F`. In this case,
    `F` is a rather trivial filter, which is precisely the bottom element of the complete
    lattice `Filter X`. This contrasts with the definition of filters in Bourbaki,
    which doesnâ€™t allow filters containing the empty set.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ³¨æ„ï¼Œæ ¹æ®è¿‡æ»¤å™¨å®šä¹‰çš„ç¬¬äºŒæ€§è´¨ï¼ˆå¦‚æœ `U` å±äº `F`ï¼Œåˆ™ä»»ä½•å¤§äº `U` çš„ä¸œè¥¿ä¹Ÿå±äº `F`ï¼‰ï¼Œç¬¬ä¸€ä¸ªæ€§è´¨ï¼ˆ`X` çš„æ‰€æœ‰å±…æ°‘é›†åˆå±äº `F`ï¼‰ç­‰ä»·äº
    `F` ä¸æ˜¯ç©ºé›†åˆçš„æ€§è´¨ã€‚è¿™ä¸åº”ä¸æ›´å¾®å¦™çš„é—®é¢˜æ··æ·†ï¼Œå³ç©ºé›†æ˜¯å¦æ˜¯ `F` çš„ *å…ƒç´ *ã€‚è¿‡æ»¤å™¨çš„å®šä¹‰å¹¶ä¸ç¦æ­¢ `âˆ… âˆˆ F`ï¼Œä½†å¦‚æœç©ºé›†åœ¨ `F` ä¸­ï¼Œåˆ™æ¯ä¸ªé›†åˆéƒ½åœ¨
    `F` ä¸­ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œ`âˆ€ U : Set X, U âˆˆ F`ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ`F` æ˜¯ä¸€ä¸ªéå¸¸å¹³å‡¡çš„è¿‡æ»¤å™¨ï¼Œè¿™æ­£æ˜¯å®Œå¤‡æ ¼ `Filter X` çš„åº•å…ƒç´ ã€‚è¿™ä¸å¸ƒå°”å·´åŸºå…³äºè¿‡æ»¤å™¨å®šä¹‰ä¸åŒï¼Œå¸ƒå°”å·´åŸºçš„å®šä¹‰ä¸å…è®¸åŒ…å«ç©ºé›†çš„è¿‡æ»¤å™¨ã€‚'
- en: 'Because we include the trivial filter in our definition, we sometimes need
    to explicitly assume nontriviality in some lemmas. In return, however, the theory
    has nicer global properties. We have already seen that including the trivial filter
    gives us a bottom element. It also allows us to define `principal : Set X â†’ Filter
    X`, which maps `âˆ…` to `âŠ¥`, without adding a precondition to rule out the empty
    set. And it allows us to define the pullback operation without a precondition
    as well. Indeed, it can happen that `comap f F = âŠ¥` although `F â‰  âŠ¥`. For instance,
    given `xâ‚€ : â„` and `s : Set â„`, the pullback of `ğ“ xâ‚€` under the coercion from
    the subtype corresponding to `s` is nontrivial if and only if `xâ‚€` belongs to
    the closure of `s`.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç”±äºæˆ‘ä»¬åœ¨å®šä¹‰ä¸­åŒ…å«äº†å¹³å‡¡æ»¤æ³¢å™¨ï¼Œæˆ‘ä»¬æœ‰æ—¶éœ€è¦æ˜ç¡®å‡è®¾æŸäº›å¼•ç†çš„éå¹³å‡¡æ€§ã€‚ç„¶è€Œï¼Œä½œä¸ºå›æŠ¥ï¼Œç†è®ºå…·æœ‰æ›´å¥½çš„å…¨å±€æ€§è´¨ã€‚æˆ‘ä»¬å·²ç»çœ‹åˆ°ï¼ŒåŒ…æ‹¬å¹³å‡¡æ»¤æ³¢å™¨ç»™æˆ‘ä»¬æä¾›äº†ä¸€ä¸ªåº•å…ƒç´ ã€‚å®ƒè¿˜å…è®¸æˆ‘ä»¬å®šä¹‰`principal
    : Set X â†’ Filter X`ï¼Œå®ƒå°†`âˆ…`æ˜ å°„åˆ°`âŠ¥`ï¼Œè€Œä¸éœ€è¦æ·»åŠ ä¸€ä¸ªå…ˆå†³æ¡ä»¶æ¥æ’é™¤ç©ºé›†ã€‚å®ƒè¿˜å…è®¸æˆ‘ä»¬å®šä¹‰æ²¡æœ‰å…ˆå†³æ¡ä»¶çš„æ‹‰å›æ“ä½œã€‚å®é™…ä¸Šï¼Œå¯èƒ½ä¼šå‘ç”Ÿ`comap
    f F = âŠ¥`ï¼Œå°½ç®¡`F â‰  âŠ¥`ã€‚ä¾‹å¦‚ï¼Œç»™å®š`xâ‚€ : â„`å’Œ`s : Set â„`ï¼Œå¦‚æœ`xâ‚€`å±äº`s`çš„é—­åŒ…ï¼Œé‚£ä¹ˆä»å¯¹åº”äº`s`çš„å­ç±»å‹å¼ºåˆ¶è½¬æ¢çš„`ğ“
    xâ‚€`çš„æ‹‰å›æ˜¯éå¹³å‡¡çš„ã€‚'
- en: 'In order to manage lemmas that do need to assume some filter is nontrivial,
    Mathlib has a type class `Filter.NeBot`, and the library has lemmas that assume
    `(F : Filter X) [F.NeBot]`. The instance database knows, for example, that `(atTop
    : Filter â„•).NeBot`, and it knows that pushing forward a nontrivial filter gives
    a nontrivial filter. As a result, a lemma assuming `[F.NeBot]` will automatically
    apply to `map u atTop` for any sequence `u`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¸ºäº†ç®¡ç†éœ€è¦å‡è®¾æŸäº›æ»¤æ³¢å™¨éå¹³å‡¡çš„å¼•ç†ï¼ŒMathlibæœ‰ä¸€ä¸ªç±»å‹ç±»`Filter.NeBot`ï¼Œåº“ä¸­æœ‰å‡è®¾`(F : Filter X) [F.NeBot]`çš„å¼•ç†ã€‚å®ä¾‹æ•°æ®åº“çŸ¥é“ï¼Œä¾‹å¦‚ï¼Œ`(atTop
    : Filter â„•).NeBot`ï¼Œå®ƒçŸ¥é“å‰æ¨ä¸€ä¸ªéå¹³å‡¡æ»¤æ³¢å™¨ä¼šå¾—åˆ°ä¸€ä¸ªéå¹³å‡¡æ»¤æ³¢å™¨ã€‚å› æ­¤ï¼Œå‡è®¾`[F.NeBot]`çš„å¼•ç†å°†è‡ªåŠ¨é€‚ç”¨äºä»»ä½•åºåˆ—`u`çš„`map
    u atTop`ã€‚'
- en: Our tour of the algebraic properties of filters and their relation to limits
    is essentially done, but we have not yet justified our claim to have recaptured
    the usual limit notions. Superficially, it may seem that `Tendsto u atTop (ğ“ xâ‚€)`
    is stronger than the notion of convergence defined in [Section 3.6](C03_Logic.html#sequences-and-convergence)
    because we ask that *every* neighborhood of `xâ‚€` has a preimage belonging to `atTop`,
    whereas the usual definition only requires this for the standard neighborhoods
    `Ioo (xâ‚€ - Îµ) (xâ‚€ + Îµ)`. The key is that, by definition, every neighborhood contains
    such a standard one. This observation leads to the notion of a *filter basis*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯¹æ»¤æ³¢å™¨çš„ä»£æ•°æ€§è´¨åŠå…¶ä¸æé™çš„å…³ç³»çš„è€ƒå¯ŸåŸºæœ¬ä¸Šå·²ç»å®Œæˆï¼Œä½†æˆ‘ä»¬è¿˜æ²¡æœ‰è¯æ˜æˆ‘ä»¬é‡æ–°è·å¾—äº†é€šå¸¸çš„æé™æ¦‚å¿µã€‚è¡¨é¢ä¸Šï¼Œ`Tendsto u atTop (ğ“
    xâ‚€)`ä¼¼ä¹æ¯”[ç¬¬3.6èŠ‚](C03_Logic.html#sequences-and-convergence)ä¸­å®šä¹‰çš„æ”¶æ•›æ¦‚å¿µæ›´å¼ºï¼Œå› ä¸ºæˆ‘ä»¬è¦æ±‚`xâ‚€`çš„æ¯ä¸ªé‚»åŸŸéƒ½æœ‰ä¸€ä¸ªå±äº`atTop`çš„é€†åƒï¼Œè€Œé€šå¸¸çš„å®šä¹‰åªè¦æ±‚å¯¹äºæ ‡å‡†é‚»åŸŸ`Ioo
    (xâ‚€ - Îµ) (xâ‚€ + Îµ)`æ˜¯è¿™æ ·çš„ã€‚å…³é”®æ˜¯ï¼Œæ ¹æ®å®šä¹‰ï¼Œæ¯ä¸ªé‚»åŸŸéƒ½åŒ…å«è¿™æ ·çš„æ ‡å‡†é‚»åŸŸã€‚è¿™ä¸ªè§‚å¯Ÿå¯¼è‡´äº†ä¸€ä¸ª**æ»¤æ³¢åŸº**çš„æ¦‚å¿µã€‚
- en: 'Given `F : Filter X`, a family of sets `s : Î¹ â†’ Set X` is a basis for `F` if
    for every set `U`, we have `U âˆˆ F` if and only if it contains some `s i`. In other
    words, formally speaking, `s` is a basis if it satisfies `âˆ€ U : Set X, U âˆˆ F â†”
    âˆƒ i, s i âŠ† U`. It is even more flexible to consider a predicate on `Î¹` that selects
    only some of the values `i` in the indexing type. In the case of `ğ“ xâ‚€`, we want
    `Î¹` to be `â„`, we write `Îµ` for `i`, and the predicate should select the positive
    values of `Îµ`. So the fact that the sets `IooÂ  (xâ‚€ - Îµ) (xâ‚€ + Îµ)` form a basis
    for the neighborhood topology on `â„` is stated as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç»™å®š`F : Filter X`ï¼Œä¸€ä¸ªé›†åˆæ—`s : Î¹ â†’ Set X`æ˜¯`F`çš„åŸºï¼Œå¦‚æœå¯¹äºæ¯ä¸ªé›†åˆ`U`ï¼Œå½“ä¸”ä»…å½“å®ƒåŒ…å«æŸä¸ª`s i`æ—¶ï¼Œ`U
    âˆˆ F`ã€‚æ¢å¥è¯è¯´ï¼Œä»å½¢å¼ä¸Šè®²ï¼Œå¦‚æœ`s`æ»¡è¶³`âˆ€ U : Set X, U âˆˆ F â†” âˆƒ i, s i âŠ† U`ï¼Œåˆ™`s`æ˜¯ä¸€ä¸ªåŸºã€‚è€ƒè™‘ä¸€ä¸ªåœ¨`Î¹`ä¸Šçš„è°“è¯ï¼Œå®ƒåªé€‰æ‹©ç´¢å¼•ç±»å‹ä¸­çš„æŸäº›å€¼`i`ï¼Œè¿™ç”šè‡³æ›´åŠ çµæ´»ã€‚åœ¨`ğ“
    xâ‚€`çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¸Œæœ›`Î¹`æ˜¯`â„`ï¼Œæˆ‘ä»¬ç”¨`Îµ`è¡¨ç¤º`i`ï¼Œè°“è¯åº”è¯¥é€‰æ‹©`Îµ`çš„æ­£å€¼ã€‚å› æ­¤ï¼Œé›†åˆ`IooÂ  (xâ‚€ - Îµ) (xâ‚€ + Îµ)`å½¢æˆ`â„`ä¸Šçš„é‚»åŸŸæ‹“æ‰‘çš„åŸºï¼Œå¯ä»¥è¿™æ ·è¡¨è¿°ï¼š'
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There is also a nice basis for the filter `atTop`. The lemma `Filter.HasBasis.tendsto_iff`
    allows us to reformulate a statement of the form `Tendsto f F G` given bases for
    `F` and `G`. Putting these pieces together gives us essentially the notion of
    convergence that we used in [Section 3.6](C03_Logic.html#sequences-and-convergence).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äº`atTop`æ»¤æ³¢å™¨ä¹Ÿæœ‰ä¸€ä¸ªå¾ˆå¥½çš„åŸºã€‚å¼•ç†`Filter.HasBasis.tendsto_iff`å…è®¸æˆ‘ä»¬ç”¨`F`å’Œ`G`çš„åŸºé‡æ–°è¡¨è¿°å½¢å¼ä¸º`Tendsto
    f F G`çš„é™ˆè¿°ã€‚å°†è¿™äº›éƒ¨åˆ†æ”¾åœ¨ä¸€èµ·ï¼Œæˆ‘ä»¬åŸºæœ¬ä¸Šå¾—åˆ°äº†[ç¬¬3.6èŠ‚](C03_Logic.html#sequences-and-convergence)ä¸­ä½¿ç”¨çš„æ”¶æ•›æ¦‚å¿µã€‚
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We now show how filters facilitate working with properties that hold for sufficiently
    large numbers or for points that are sufficiently close to a given point. In [Section
    3.6](C03_Logic.html#sequences-and-convergence), we were often faced with the situation
    where we knew that some property `P n` holds for sufficiently large `n` and that
    some other property `Q n` holds for sufficiently large `n`. Using `cases` twice
    gave us `N_P` and `N_Q` satisfying `âˆ€ n â‰¥ N_P, P n` and `âˆ€ n â‰¥ N_Q, Q n`. Using
    `set N := max N_P N_Q`, we could eventually prove `âˆ€ n â‰¥ N, P n âˆ§ Q n`. Doing
    this repeatedly becomes tiresome.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨å±•ç¤ºå¦‚ä½•è¿‡æ»¤å™¨æœ‰åŠ©äºå¤„ç†å¯¹äºè¶³å¤Ÿå¤§çš„æ•°å­—æˆ–å¯¹äºè¶³å¤Ÿæ¥è¿‘ç»™å®šç‚¹çš„ç‚¹æ‰€æŒæœ‰çš„å±æ€§ã€‚åœ¨[ç¬¬3.6èŠ‚](C03_Logic.html#sequences-and-convergence)ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸é‡åˆ°è¿™æ ·çš„æƒ…å†µï¼šæˆ‘ä»¬çŸ¥é“æŸäº›å±æ€§
    `P n` å¯¹äºè¶³å¤Ÿå¤§çš„ `n` æˆç«‹ï¼Œè€ŒæŸäº›å…¶ä»–å±æ€§ `Q n` å¯¹äºè¶³å¤Ÿå¤§çš„ `n` æˆç«‹ã€‚ä½¿ç”¨ `cases` ä¸¤æ¬¡ç»™å‡ºäº†æ»¡è¶³ `âˆ€ n â‰¥ N_P,
    P n` å’Œ `âˆ€ n â‰¥ N_Q, Q n` çš„ `N_P` å’Œ `N_Q`ã€‚ä½¿ç”¨ `set N := max N_P N_Q`ï¼Œæˆ‘ä»¬æœ€ç»ˆå¯ä»¥è¯æ˜ `âˆ€
    n â‰¥ N, P n âˆ§ Q n`ã€‚è¿™æ ·åšåå¤è¿›è¡Œä¼šå˜å¾—ä»¤äººåŒçƒ¦ã€‚
- en: 'We can do better by noting that the statement â€œ`P n` and `Q n` hold for large
    enough `n`â€ means that we have `{n | P n} âˆˆ atTop` and `{n | Q n} âˆˆ atTop`. The
    fact that `atTop` is a filter implies that the intersection of two elements of
    `atTop` is again in `atTop`, so we have `{n | P n âˆ§ Q n} âˆˆ atTop`. Writing `{n
    | P n} âˆˆ atTop` is unpleasant, but we can use the more suggestive notation `âˆ€á¶ 
    n in atTop, P n`. Here the superscripted `f` stands for â€œFilter.â€ You can think
    of the notation as saying that for all `n` in the â€œset of very large numbers,â€
    `P n` holds. The `âˆ€á¶ ` notation stands for `Filter.Eventually`, and the lemma `Filter.Eventually.and`
    uses the intersection property of filters to do what we just described:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥é€šè¿‡æ³¨æ„åˆ°é™ˆè¿°â€œ`P n` å’Œ `Q n` å¯¹äºè¶³å¤Ÿå¤§çš„ `n` æˆç«‹â€æ„å‘³ç€æˆ‘ä»¬æ‹¥æœ‰ `{n | P n} âˆˆ atTop` å’Œ `{n |
    Q n} âˆˆ atTop` æ¥åšå¾—æ›´å¥½ã€‚`atTop` æ˜¯ä¸€ä¸ªè¿‡æ»¤å™¨çš„æ€§è´¨æ„å‘³ç€ `atTop` ä¸­ä¸¤ä¸ªå…ƒç´ çš„äº¤é›†å†æ¬¡åœ¨ `atTop` ä¸­ï¼Œå› æ­¤æˆ‘ä»¬å¾—åˆ°
    `{n | P n âˆ§ Q n} âˆˆ atTop`ã€‚å†™ä½œ `{n | P n} âˆˆ atTop` æ˜¯ä¸æ„‰å¿«çš„ï¼Œä½†æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ›´å…·è¯´æ˜æ€§çš„ç¬¦å· `âˆ€á¶  n in
    atTop, P n`ã€‚è¿™é‡Œä¸Šæ ‡çš„ `f` ä»£è¡¨â€œè¿‡æ»¤å™¨â€ã€‚ä½ å¯ä»¥å°†è¿™ä¸ªç¬¦å·ç†è§£ä¸ºå¯¹äºæ‰€æœ‰åœ¨â€œéå¸¸å¤§çš„æ•°å­—é›†åˆâ€ä¸­çš„ `n`ï¼Œ`P n` æˆç«‹ã€‚`âˆ€á¶ ` ç¬¦å·ä»£è¡¨
    `Filter.Eventually`ï¼Œè€Œ `Filter.Eventually.and` å¼•ç†ä½¿ç”¨è¿‡æ»¤å™¨çš„äº¤é›†æ€§è´¨æ¥å®Œæˆæˆ‘ä»¬åˆšæ‰æè¿°çš„äº‹æƒ…ï¼š
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This notation is so convenient and intuitive that we also have specializations
    when `P` is an equality or inequality statement. For example, let `u` and `v`
    be two sequences of real numbers, and let us show that if `u n` and `v n` coincide
    for sufficiently large `n` then `u` tends to `xâ‚€` if and only if `v` tends to
    `xâ‚€`. First weâ€™ll use the generic `Eventually` and then the one specialized for
    the equality predicate, `EventuallyEq`. The two statements are definitionally
    equivalent so the same proof work in both cases.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªç¬¦å·å¦‚æ­¤æ–¹ä¾¿ä¸”ç›´è§‚ï¼Œä»¥è‡³äºå½“ `P` æ˜¯ä¸€ä¸ªç­‰å¼æˆ–ä¸ç­‰å¼é™ˆè¿°æ—¶ï¼Œæˆ‘ä»¬ä¹Ÿæœ‰ä¸“é—¨çš„å®ç°ã€‚ä¾‹å¦‚ï¼Œè®¾ `u` å’Œ `v` æ˜¯ä¸¤ä¸ªå®æ•°åºåˆ—ï¼Œæˆ‘ä»¬å°†è¯æ˜å¦‚æœ `u
    n` å’Œ `v n` å¯¹äºè¶³å¤Ÿå¤§çš„ `n` ä¸€è‡´ï¼Œé‚£ä¹ˆ `u` è¶‹äº `xâ‚€` å½“ä¸”ä»…å½“ `v` è¶‹äº `xâ‚€`ã€‚é¦–å…ˆæˆ‘ä»¬å°†ä½¿ç”¨é€šç”¨çš„ `Eventually`ï¼Œç„¶åæ˜¯ä¸“é—¨é’ˆå¯¹ç­‰ä»·è°“è¯çš„
    `EventuallyEq`ã€‚è¿™ä¸¤ä¸ªé™ˆè¿°åœ¨å®šä¹‰ä¸Šæ˜¯ç­‰ä»·çš„ï¼Œæ‰€ä»¥ä¸¤ç§æƒ…å†µä¸‹çš„è¯æ˜å·¥ä½œç›¸åŒã€‚
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It is instructive to review the definition of filters in terms of `Eventually`.
    Given `F : Filter X`, for any predicates `P` and `Q` on `X`,'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 'é€šè¿‡ `Eventually` æ¥å›é¡¾è¿‡æ»¤å™¨çš„å®šä¹‰æ˜¯æœ‰æ•™è‚²æ„ä¹‰çš„ã€‚ç»™å®š `F : Filter X`ï¼Œå¯¹äº `X` ä¸Šçš„ä»»ä½•è°“è¯ `P` å’Œ `Q`ï¼Œ'
- en: the condition `univ âˆˆ F` ensures `(âˆ€ x, P x) â†’ âˆ€á¶  x in F, P x`,
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¡ä»¶ `univ âˆˆ F` ç¡®ä¿äº† `(âˆ€ x, P x) â†’ âˆ€á¶  x in F, P x`ã€‚
- en: the condition `U âˆˆ F â†’ U âŠ† V â†’ V âˆˆ F` ensures `(âˆ€á¶  x in F, P x) â†’ (âˆ€ x, P x
    â†’ Q x) â†’ âˆ€á¶  x in F, Q x`, and
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¡ä»¶ `U âˆˆ F â†’ U âŠ† V â†’ V âˆˆ F` ç¡®ä¿äº† `(âˆ€á¶  x in F, P x) â†’ (âˆ€ x, P x â†’ Q x) â†’ âˆ€á¶  x in
    F, Q x`ï¼Œå¹¶ä¸”
- en: the condition `U âˆˆ F â†’ V âˆˆ F â†’ U âˆ© V âˆˆ F` ensures `(âˆ€á¶  x in F, P x) â†’ (âˆ€á¶  x
    in F, Q x) â†’ âˆ€á¶  x in F, P x âˆ§ Q x`.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¡ä»¶ `U âˆˆ F â†’ V âˆˆ F â†’ U âˆ© V âˆˆ F` ç¡®ä¿äº† `(âˆ€á¶  x in F, P x) â†’ (âˆ€á¶  x in F, Q x) â†’ âˆ€á¶ 
    x in F, P x âˆ§ Q x`.
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The second item, corresponding to `Eventually.mono`, supports nice ways of
    using filters, especially when combined with `Eventually.and`. The `filter_upwards`
    tactic allows us to combine them. Compare:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬äºŒé¡¹ï¼Œå¯¹åº”äº `Eventually.mono`ï¼Œæ”¯æŒä½¿ç”¨è¿‡æ»¤å™¨çš„ä¼˜é›…æ–¹å¼ï¼Œç‰¹åˆ«æ˜¯å½“ä¸ `Eventually.and` ç»“åˆä½¿ç”¨æ—¶ã€‚`filter_upwards`
    ç­–ç•¥å…è®¸æˆ‘ä»¬ç»„åˆå®ƒä»¬ã€‚æ¯”è¾ƒï¼š
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Readers who know about measure theory will note that the filter `Î¼.ae` of sets
    whose complement has measure zero (aka â€œthe set consisting of almost every pointâ€)
    is not very useful as the source or target of `Tendsto`, but it can be conveniently
    used with `Eventually` to say that a property holds for almost every point.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: äº†è§£æµ‹åº¦ç†è®ºçš„è¯»è€…ä¼šæ³¨æ„åˆ°ï¼Œé›†åˆçš„è¡¥é›†å…·æœ‰é›¶æµ‹åº¦ï¼ˆå³â€œå‡ ä¹æ¯ä¸ªç‚¹çš„é›†åˆâ€ï¼‰çš„è¿‡æ»¤å™¨ `Î¼.ae` ä½œä¸º `Tendsto` çš„æºæˆ–ç›®æ ‡å¹¶ä¸æ˜¯éå¸¸æœ‰ç”¨ï¼Œä½†å®ƒå¯ä»¥æ–¹ä¾¿åœ°ä¸
    `Eventually` ç»“åˆä½¿ç”¨ï¼Œä»¥è¡¨æ˜ä¸€ä¸ªå±æ€§å¯¹äºå‡ ä¹æ¯ä¸ªç‚¹éƒ½æˆç«‹ã€‚
- en: 'There is a dual version of `âˆ€á¶  x in F, P x`, which is occasionally useful:
    `âˆƒá¶  x in F, P x` means `{x | Â¬P x} âˆ‰ F`. For example, `âˆƒá¶  n in atTop, P n` means
    there are arbitrarily large `n` such that `P n` holds. The `âˆƒá¶ ` notation stands
    for `Filter.Frequently`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: å­˜åœ¨ä¸€ä¸ª `âˆ€á¶  x in F, P x` çš„å¯¹å¶ç‰ˆæœ¬ï¼Œè¿™åœ¨æŸäº›æƒ…å†µä¸‹æ˜¯æœ‰ç”¨çš„ï¼š`âˆƒá¶  x in F, P x` æ„å‘³ç€ `{x | Â¬P x} âˆ‰ F`ã€‚ä¾‹å¦‚ï¼Œ`âˆƒá¶ 
    n in atTop, P n` æ„å‘³ç€å­˜åœ¨ä»»æ„å¤§çš„ `n` ä½¿å¾— `P n` æˆç«‹ã€‚`âˆƒá¶ ` ç¬¦å·ä»£è¡¨ `Filter.Frequently`ã€‚
- en: 'For a more sophisticated example, consider the following statement about a
    sequence `u`, a set `M`, and a value `x`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºä¸€ä¸ªæ›´å¤æ‚çš„ä¾‹å­ï¼Œè€ƒè™‘ä»¥ä¸‹å…³äºåºåˆ— `u`ã€é›†åˆ `M` å’Œå€¼ `x` çš„é™ˆè¿°ï¼š
- en: If `u` converges to `x` and `u n` belongs to `M` for sufficiently large `n`
    then `x` is in the closure of `M`.
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœ `u` æ”¶æ•›åˆ° `x` å¹¶ä¸”å¯¹äºè¶³å¤Ÿå¤§çš„ `n`ï¼Œ`u n` å±äº `M`ï¼Œé‚£ä¹ˆ `x` åœ¨ `M` çš„é—­é›†ä¸­ã€‚
- en: 'This can be formalized as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯ä»¥å½¢å¼åŒ–ä¸ºä»¥ä¸‹å†…å®¹ï¼š
- en: '`Tendsto u atTop (ğ“ x) â†’ (âˆ€á¶  n in atTop, u n âˆˆ M) â†’ x âˆˆ closure M`.'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Tendsto u atTop (ğ“ x) â†’ (âˆ€á¶  n in atTop, u n âˆˆ M) â†’ x âˆˆ closure M`ã€‚'
- en: This is a special case of the theorem `mem_closure_of_tendsto` from the topology
    library. See if you can prove it using the quoted lemmas, using the fact that
    `ClusterPt x F` means `(ğ“ x âŠ“ F).NeBot` and that, by definition, the assumption
    `âˆ€á¶  n in atTop, u n âˆˆ M` means `M âˆˆ map u atTop`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æ‹“æ‰‘åº“ä¸­ `mem_closure_of_tendsto` å®šç†çš„ä¸€ä¸ªç‰¹ä¾‹ã€‚çœ‹çœ‹ä½ æ˜¯å¦å¯ä»¥ä½¿ç”¨å¼•ç”¨çš„å¼•ç†æ¥è¯æ˜å®ƒï¼Œåˆ©ç”¨ `ClusterPt x F`
    è¡¨ç¤º `(ğ“ x âŠ“ F).NeBot` ä»¥åŠæ ¹æ®å®šä¹‰ï¼Œå‡è®¾ `âˆ€á¶  n in atTop, u n âˆˆ M` æ„å‘³ç€ `M âˆˆ map u atTop`ã€‚
- en: '[PRE16]  ## 11.2\. Metric spaces[ïƒ](#metric-spaces "Link to this heading")'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE16]  ## 11.2\. è·ç¦»ç©ºé—´[ïƒ](#metric-spaces "é“¾æ¥åˆ°æœ¬æ ‡é¢˜")'
- en: 'Examples in the previous section focus on sequences of real numbers. In this
    section we will go up a bit in generality and focus on metric spaces. A metric
    space is a type `X` equipped with a distance function `dist : X â†’ X â†’ â„` which
    is a generalization of the function `fun x y â†¦ |x - y|` from the case where `X
    = â„`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¸Šä¸€èŠ‚ä¸­çš„ä¾‹å­ä¸»è¦å…³æ³¨å®æ•°åºåˆ—ã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†æé«˜ä¸€ç‚¹æ™®éæ€§ï¼Œå¹¶å…³æ³¨åº¦é‡ç©ºé—´ã€‚åº¦é‡ç©ºé—´æ˜¯ä¸€ä¸ªå¸¦æœ‰è·ç¦»å‡½æ•° `dist : X â†’ X â†’ â„` çš„ç±»å‹
    `X`ï¼Œè¿™æ˜¯ä» `X = â„` çš„æƒ…å†µä¸‹çš„å‡½æ•° `fun x y â†¦ |x - y|` çš„ä¸€èˆ¬åŒ–ã€‚'
- en: Introducing such a space is easy and we will check all properties required from
    the distance function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: å¼•å…¥è¿™æ ·çš„ç©ºé—´å¾ˆå®¹æ˜“ï¼Œæˆ‘ä»¬å°†æ£€æŸ¥ä»è·ç¦»å‡½æ•°æ‰€éœ€çš„æ‰€æœ‰å±æ€§ã€‚
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note we also have variants where the distance can be infinite or where `dist
    a b` can be zero without having `a = b` or both. They are called `EMetricSpace`,
    `PseudoMetricSpace` and `PseudoEMetricSpace` respectively (here â€œeâ€ stands for
    â€œextendedâ€).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬è¿˜æœ‰è·ç¦»å¯ä»¥æ— é™æˆ– `dist a b` å¯ä»¥æ˜¯é›¶è€Œæ²¡æœ‰ `a = b` æˆ–ä¸¤è€…éƒ½ä¸ºé›¶çš„å˜ä½“ã€‚å®ƒä»¬åˆ†åˆ«ç§°ä¸º `EMetricSpace`ã€`PseudoMetricSpace`
    å’Œ `PseudoEMetricSpace`ï¼ˆè¿™é‡Œçš„â€œeâ€ä»£è¡¨â€œæ‰©å±•â€ï¼‰ã€‚
- en: Note that our journey from `â„` to metric spaces jumped over the special case
    of normed spaces that also require linear algebra and will be explained as part
    of the calculus chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬çš„ä» `â„` åˆ°åº¦é‡ç©ºé—´ä¹‹æ—…è·³è¿‡äº†éœ€è¦çº¿æ€§ä»£æ•°çš„ç‰¹æ®Šæƒ…å†µçš„èŒƒç©ºé—´ï¼Œè¿™å°†åœ¨å¾®ç§¯åˆ†ç« èŠ‚ä¸­è§£é‡Šã€‚
- en: 11.2.1\. Convergence and continuity[ïƒ](#convergence-and-continuity "Link to
    this heading")
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1\. æ”¶æ•›æ€§å’Œè¿ç»­æ€§[ïƒ](#convergence-and-continuity "é“¾æ¥åˆ°æœ¬æ ‡é¢˜")
- en: Using distance functions, we can already define convergent sequences and continuous
    functions between metric spaces. They are actually defined in a more general setting
    covered in the next section, but we have lemmas recasting the definition in terms
    of distances.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è·ç¦»å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨åº¦é‡ç©ºé—´ä¹‹é—´å®šä¹‰æ”¶æ•›åºåˆ—å’Œè¿ç»­å‡½æ•°ã€‚å®é™…ä¸Šï¼Œå®ƒä»¬åœ¨ä¸‹ä¸€èŠ‚ä¸­æ›´ä¸€èˆ¬çš„è®¾ç½®ä¸­å®šä¹‰ï¼Œä½†æˆ‘ä»¬æœ‰å°†å®šä¹‰é‡æ–°è¡¨è¿°ä¸ºè·ç¦»çš„å¼•ç†ã€‚
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A *lot* of lemmas have some continuity assumptions, so we end up proving a lot
    of continuity results and there is a `continuity` tactic devoted to this task.
    Letâ€™s prove a continuity statement that will be needed in an exercise below. Notice
    that Lean knows how to treat a product of two metric spaces as a metric space,
    so it makes sense to consider continuous functions from `X Ã— X` to `â„`. In particular
    the (uncurried version of the) distance function is such a function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: è®¸å¤šå¼•ç†éƒ½æœ‰ä¸€äº›è¿ç»­æ€§çš„å‡è®¾ï¼Œæ‰€ä»¥æˆ‘ä»¬æœ€ç»ˆè¯æ˜äº†è®¸å¤šè¿ç»­æ€§ç»“æœï¼Œå¹¶ä¸”æœ‰ä¸€ä¸ªä¸“é—¨ç”¨äºè¿™ä¸ªä»»åŠ¡çš„ `continuity` ç­–ç•¥ã€‚è®©æˆ‘ä»¬è¯æ˜ä¸€ä¸ªå°†åœ¨ä¸‹é¢çš„ç»ƒä¹ ä¸­éœ€è¦çš„è¿ç»­æ€§é™ˆè¿°ã€‚æ³¨æ„ï¼ŒLean
    çŸ¥é“å¦‚ä½•å°†ä¸¤ä¸ªåº¦é‡ç©ºé—´çš„ä¹˜ç§¯è§†ä¸ºåº¦é‡ç©ºé—´ï¼Œå› æ­¤è€ƒè™‘ä» `X Ã— X` åˆ° `â„` çš„è¿ç»­å‡½æ•°æ˜¯æœ‰æ„ä¹‰çš„ã€‚ç‰¹åˆ«æ˜¯ï¼ˆæœªå±•å¼€çš„ï¼‰è·ç¦»å‡½æ•°æ˜¯è¿™æ ·çš„å‡½æ•°ã€‚
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This tactic is a bit slow, so it is also useful to know how to do it by hand.
    We first need to use that `fun p : X Ã— X â†¦ f p.1` is continuous because it is
    the composition of `f`, which is continuous by assumption `hf`, and the projection
    `prod.fst` whose continuity is the content of the lemma `continuous_fst`. The
    composition property is `Continuous.comp` which is in the `Continuous` namespace
    so we can use dot notation to compress `Continuous.comp hf continuous_fst` into
    `hf.comp continuous_fst` which is actually more readable since it really reads
    as composing our assumption and our lemma. We can do the same for the second component
    to get continuity of `fun p : X Ã— X â†¦ f p.2`. We then assemble those two continuities
    using `Continuous.prod_mk` to get `(hf.comp continuous_fst).prod_mk (hf.comp continuous_snd)
    : Continuous (fun p : X Ã— X â†¦ (f p.1, f p.2))` and compose once more to get our
    full proof.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 'è¿™ä¸ªç­–ç•¥æœ‰ç‚¹æ…¢ï¼Œå› æ­¤äº†è§£å¦‚ä½•æ‰‹åŠ¨å®Œæˆå®ƒä¹Ÿå¾ˆæœ‰ç”¨ã€‚æˆ‘ä»¬é¦–å…ˆéœ€è¦ä½¿ç”¨ `fun p : X Ã— X â†¦ f p.1` æ˜¯è¿ç»­çš„ï¼Œå› ä¸ºå®ƒæ˜¯ç”± `f` ç»„æˆçš„ï¼Œ`f`
    æ˜¯æ ¹æ®å‡è®¾ `hf` è¿ç»­çš„ï¼Œä»¥åŠæŠ•å½± `prod.fst` çš„è¿ç»­æ€§ï¼Œè¿™æ˜¯å¼•ç† `continuous_fst` çš„å†…å®¹ã€‚ç»„åˆå±æ€§æ˜¯ `Continuous.comp`ï¼Œå®ƒåœ¨
    `Continuous` å‘½åç©ºé—´ä¸­ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç‚¹ç¬¦å·å°† `Continuous.comp hf continuous_fst` å‹ç¼©ä¸º `hf.comp
    continuous_fst`ï¼Œè¿™å®é™…ä¸Šæ›´æ˜“äºé˜…è¯»ï¼Œå› ä¸ºå®ƒçœŸæ­£åœ°è¯»ä½œç»„åˆæˆ‘ä»¬çš„å‡è®¾å’Œæˆ‘ä»¬çš„å¼•ç†ã€‚æˆ‘ä»¬å¯ä»¥å¯¹ç¬¬äºŒä¸ªåˆ†é‡åšåŒæ ·çš„å¤„ç†ï¼Œä»¥å¾—åˆ° `fun p :
    X Ã— X â†¦ f p.2` çš„è¿ç»­æ€§ã€‚ç„¶åæˆ‘ä»¬ä½¿ç”¨ `Continuous.prod_mk` å°†è¿™ä¸¤ä¸ªè¿ç»­æ€§ç»„è£…èµ·æ¥ï¼Œå¾—åˆ° `(hf.comp continuous_fst).prod_mk
    (hf.comp continuous_snd) : Continuous (fun p : X Ã— X â†¦ (f p.1, f p.2))`ï¼Œç„¶åå†è¿›è¡Œä¸€æ¬¡ç»„åˆï¼Œä»¥å¾—åˆ°å®Œæ•´çš„è¯æ˜ã€‚'
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The combination of `Continuous.prod_mk` and `continuous_dist` via `Continuous.comp`
    feels clunky, even when heavily using dot notation as above. A more serious issue
    is that this nice proof requires a lot of planning. Lean accepts the above proof
    term because it is a full term proving a statement which is definitionally equivalent
    to our goal, the crucial definition to unfold being that of a composition of functions.
    Indeed our target function `fun p : X Ã— X â†¦ dist (f p.1) (f p.2)` is not presented
    as a composition. The proof term we provided proves continuity of `dist âˆ˜ (fun
    p : X Ã— X â†¦ (f p.1, f p.2))` which happens to be definitionally equal to our target
    function. But if we try to build this proof gradually using tactics starting with
    `apply continuous_dist.comp` then Leanâ€™s elaborator will fail to recognize a composition
    and refuse to apply this lemma. It is especially bad at this when products of
    types are involved.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 'é€šè¿‡ `Continuous.comp` å°† `Continuous.prod_mk` å’Œ `continuous_dist` ç»“åˆèµ·æ¥æ„Ÿè§‰æœ‰äº›ç¬¨æ‹™ï¼Œå³ä½¿åƒä¸Šé¢é‚£æ ·å¤§é‡ä½¿ç”¨ç‚¹ç¬¦å·ä¹Ÿæ˜¯å¦‚æ­¤ã€‚ä¸€ä¸ªæ›´ä¸¥é‡çš„é—®é¢˜æ˜¯ï¼Œè¿™ä¸ªæ¼‚äº®çš„è¯æ˜éœ€è¦å¤§é‡çš„è§„åˆ’ã€‚Lean
    æ¥å—ä¸Šè¿°è¯æ˜é¡¹ï¼Œå› ä¸ºå®ƒæ˜¯ä¸€ä¸ªå®Œæ•´çš„é¡¹ï¼Œè¯æ˜äº†ä¸æˆ‘ä»¬çš„ç›®æ ‡å®šä¹‰ç­‰ä»·çš„è¯´æ³•ï¼Œå…³é”®çš„å®šä¹‰å±•å¼€æ˜¯å‡½æ•°çš„ç»„åˆã€‚ç¡®å®ï¼Œæˆ‘ä»¬çš„ç›®æ ‡å‡½æ•° `fun p : X Ã— X â†¦
    dist (f p.1) (f p.2)` å¹¶æ²¡æœ‰ä»¥ç»„åˆçš„å½¢å¼å‘ˆç°ã€‚æˆ‘ä»¬æä¾›çš„è¯æ˜é¡¹è¯æ˜äº† `dist âˆ˜ (fun p : X Ã— X â†¦ (f p.1,
    f p.2))` çš„è¿ç»­æ€§ï¼Œè¿™æ°å¥½ä¸æˆ‘ä»¬çš„ç›®æ ‡å‡½æ•°å®šä¹‰ç­‰ä»·ã€‚ä½†å¦‚æœæˆ‘ä»¬å°è¯•ä» `apply continuous_dist.comp` å¼€å§‹é€æ­¥æ„å»ºè¿™ä¸ªè¯æ˜ï¼ŒLean
    çš„å±•å¼€å™¨å°†æ— æ³•è¯†åˆ«ç»„åˆå¹¶æ‹’ç»åº”ç”¨è¿™ä¸ªå¼•ç†ã€‚å½“æ¶‰åŠåˆ°ç±»å‹ä¹˜ç§¯æ—¶ï¼Œè¿™ä¸ªé—®é¢˜å°¤å…¶ä¸¥é‡ã€‚'
- en: 'A better lemma to apply here is `Continuous.dist {f g : X â†’ Y} : Continuous
    f â†’ Continuous g â†’ Continuous (fun x â†¦ dist (f x) (g x))` which is nicer to Leanâ€™s
    elaborator and also provides a shorter proof when directly providing a full proof
    term, as can be seen from the following two new proofs of the above statement:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 'åœ¨è¿™é‡Œåº”ç”¨æ›´å¥½çš„å¼•ç†æ˜¯ `Continuous.dist {f g : X â†’ Y} : Continuous f â†’ Continuous g â†’
    Continuous (fun x â†¦ dist (f x) (g x))`ï¼Œè¿™å¯¹ Lean çš„å±•å¼€å™¨æ¥è¯´æ›´å‹å¥½ï¼Œå¹¶ä¸”åœ¨ç›´æ¥æä¾›å®Œæ•´è¯æ˜é¡¹æ—¶ä¹Ÿæä¾›äº†æ›´çŸ­çš„è¯æ˜ï¼Œå¦‚ä¸‹é¢çš„ä¸¤ä¸ªæ–°è¯æ˜æ‰€ç¤ºï¼š'
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that, without the elaboration issue coming from composition, another way
    to compress our proof would be to use `Continuous.prod_map` which is sometimes
    useful and gives as an alternate proof term `continuous_dist.comp (hf.prod_map
    hf)` which even shorter to type.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå¦‚æœæ²¡æœ‰æ¥è‡ªå‡½æ•°ç»„åˆçš„è¯¦ç»†é˜è¿°é—®é¢˜ï¼Œå¦ä¸€ç§å‹ç¼©æˆ‘ä»¬è¯æ˜çš„æ–¹æ³•æ˜¯ä½¿ç”¨ `Continuous.prod_map`ï¼Œè¿™åœ¨æŸäº›æƒ…å†µä¸‹å¾ˆæœ‰ç”¨ï¼Œå¹¶ç»™å‡ºäº†å¦ä¸€ä¸ªè¯æ˜é¡¹
    `continuous_dist.comp (hf.prod_map hf)`ï¼Œè¿™ç”šè‡³æ›´çŸ­äºæ‰‹åŠ¨è¾“å…¥ã€‚
- en: Since it is sad to decide between a version which is better for elaboration
    and a version which is shorter to type, let us wrap this discussion with a last
    bit of compression offered by `Continuous.fst'` which allows to compress `hf.comp
    continuous_fst` to `hf.fst'` (and the same with `snd`) and get our final proof,
    now bordering obfuscation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºåœ¨è¯¦ç»†é˜è¿°å’Œç®€çŸ­è¾“å…¥ä¹‹é—´åšå‡ºé€‰æ‹©éƒ½å¾ˆä»¤äººæ²®ä¸§ï¼Œè®©æˆ‘ä»¬ç”¨ `Continuous.fst'` æä¾›çš„æœ€åä¸€ç‚¹å‹ç¼©æ¥ç»“æŸè¿™æ¬¡è®¨è®ºï¼Œå®ƒå…è®¸æˆ‘ä»¬å°† `hf.comp
    continuous_fst` å‹ç¼©ä¸º `hf.fst'`ï¼ˆä»¥åŠ `snd` çš„ç›¸åŒå¤„ç†ï¼‰ï¼Œå¹¶å¾—åˆ°æˆ‘ä»¬çš„æœ€ç»ˆè¯æ˜ï¼Œç°åœ¨å‡ ä¹æ¥è¿‘æ™¦æ¶©éš¾æ‡‚äº†ã€‚
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Itâ€™s your turn now to prove some continuity lemma. After trying the continuity
    tactic, you will need `Continuous.add`, `continuous_pow` and `continuous_id` to
    do it by hand.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è½®åˆ°ä½ æ¥è¯æ˜ä¸€äº›è¿ç»­æ€§å¼•ç†äº†ã€‚åœ¨å°è¯•äº†è¿ç»­æ€§ç­–ç•¥ä¹‹åï¼Œä½ éœ€è¦ä½¿ç”¨ `Continuous.add`ã€`continuous_pow` å’Œ `continuous_id`
    æ¥æ‰‹åŠ¨å®Œæˆå®ƒã€‚
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So far we saw continuity as a global notion, but one can also define continuity
    at a point.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†è¿ç»­æ€§ä½œä¸ºä¸€ä¸ªå…¨å±€æ¦‚å¿µï¼Œä½†ä¹Ÿå¯ä»¥å®šä¹‰åœ¨ä¸€ç‚¹ä¸Šçš„è¿ç»­æ€§ã€‚
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 11.2.2\. Balls, open sets and closed sets[ïƒ](#balls-open-sets-and-closed-sets
    "Link to this heading")
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2\. çƒã€å¼€é›†å’Œé—­é›†[ïƒ](#balls-open-sets-and-closed-sets "é“¾æ¥åˆ°æœ¬æ ‡é¢˜")
- en: Once we have a distance function, the most important geometric definitions are
    (open) balls and closed balls.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æˆ‘ä»¬æœ‰äº†è·ç¦»å‡½æ•°ï¼Œæœ€é‡è¦çš„å‡ ä½•å®šä¹‰å°±æ˜¯ï¼ˆå¼€ï¼‰çƒå’Œé—­çƒã€‚
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that r is any real number here, there is no sign restriction. Of course
    some statements do require a radius condition.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè¿™é‡Œçš„ræ˜¯ä»»ä½•å®æ•°ï¼Œæ²¡æœ‰ç¬¦å·é™åˆ¶ã€‚å½“ç„¶ï¼Œæœ‰äº›é™ˆè¿°ç¡®å®éœ€è¦åŠå¾„æ¡ä»¶ã€‚
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once we have balls, we can define open sets. They are actually defined in a
    more general setting covered in the next section, but we have lemmas recasting
    the definition in terms of balls.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æˆ‘ä»¬æœ‰äº†çƒï¼Œæˆ‘ä»¬å°±å¯ä»¥å®šä¹‰å¼€é›†ã€‚å®é™…ä¸Šï¼Œå®ƒä»¬åœ¨ä¸‹ä¸€èŠ‚ä¸­æ›´ä¸€èˆ¬çš„è®¾ç½®ä¸­è¢«å®šä¹‰ï¼Œä½†æˆ‘ä»¬æœ‰å¼•ç†å°†å®šä¹‰é‡æ–°è¡¨è¿°ä¸ºçƒçš„å½¢å¼ã€‚
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Then closed sets are sets whose complement is open. Their important property
    is they are closed under limits. The closure of a set is the smallest closed set
    containing it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åé—­é›†æ˜¯è¡¥é›†ä¸ºå¼€é›†çš„é›†åˆã€‚å®ƒä»¬çš„é‡è¦æ€§è´¨æ˜¯å®ƒä»¬åœ¨æé™ä¸‹æ˜¯å°é—­çš„ã€‚é›†åˆçš„é—­åŒ…æ˜¯åŒ…å«å®ƒçš„æœ€å°é—­é›†ã€‚
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Do the next exercise without using mem_closure_iff_seq_limit
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸ä½¿ç”¨`mem_closure_iff_seq_limit`çš„æƒ…å†µä¸‹å®Œæˆä¸‹ä¸€ä¸ªç»ƒä¹ 
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Remember from the filters sections that neighborhood filters play a big role
    in Mathlib. In the metric space context, the crucial point is that balls provide
    bases for those filters. The main lemmas here are `Metric.nhds_basis_ball` and
    `Metric.nhds_basis_closedBall` that claim this for open and closed balls with
    positive radius. The center point is an implicit argument so we can invoke `Filter.HasBasis.mem_iff`
    as in the following example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: è®°ä½ä»è¿‡æ»¤å™¨éƒ¨åˆ†ï¼Œé‚»åŸŸè¿‡æ»¤å™¨åœ¨Mathlibä¸­èµ·ç€é‡è¦ä½œç”¨ã€‚åœ¨åº¦é‡ç©ºé—´ä¸Šä¸‹æ–‡ä¸­ï¼Œå…³é”®ç‚¹æ˜¯çƒä¸ºè¿™äº›è¿‡æ»¤å™¨æä¾›åŸºã€‚è¿™é‡Œçš„ä¸»è¦å¼•ç†æ˜¯`Metric.nhds_basis_ball`å’Œ`Metric.nhds_basis_closedBall`ï¼Œå®ƒä»¬ä¸ºæ­£åŠå¾„çš„å¼€çƒå’Œé—­çƒæ–­è¨€è¿™ä¸€ç‚¹ã€‚ä¸­å¿ƒç‚¹æ˜¯éšå«çš„å‚æ•°ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åƒä»¥ä¸‹ç¤ºä¾‹ä¸­é‚£æ ·è°ƒç”¨`Filter.HasBasis.mem_iff`ã€‚
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 11.2.3\. Compactness[ïƒ](#compactness "Link to this heading")
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.3\. ç´§è‡´æ€§[ïƒ](#compactness "é“¾æ¥åˆ°æœ¬æ ‡é¢˜")
- en: 'Compactness is an important topological notion. It distinguishes subsets of
    a metric space that enjoy the same kind of properties as segments in the reals
    compared to other intervals:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ç´§è‡´æ€§æ˜¯ä¸€ä¸ªé‡è¦çš„æ‹“æ‰‘æ¦‚å¿µã€‚å®ƒåŒºåˆ†äº†åº¦é‡ç©ºé—´ä¸­å…·æœ‰ä¸å®æ•°çº¿æ®µç›¸åŒæ€§è´¨çš„å­é›†ä¸å…¶ä»–åŒºé—´ï¼š
- en: Any sequence with values in a compact set has a subsequence that converges in
    this set.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä»»ä½•åœ¨ç´§é›†å†…å–å€¼çš„åºåˆ—éƒ½æœ‰ä¸€ä¸ªå­åºåˆ—åœ¨è¿™ä¸ªé›†åˆä¸­æ”¶æ•›ã€‚
- en: Any continuous function on a nonempty compact set with values in real numbers
    is bounded and attains its bounds somewhere (this is called the extreme value
    theorem).
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨éç©ºç´§é›†ä¸Šå®šä¹‰çš„ä»»ä½•è¿ç»­å‡½æ•°ï¼Œå…¶å€¼åœ¨å®æ•°ä¸­éƒ½æ˜¯æœ‰ç•Œçš„ï¼Œå¹¶ä¸”åœ¨å…¶ç•Œé™çš„æŸå¤„è¾¾åˆ°ï¼ˆè¿™è¢«ç§°ä¸ºæå€¼å®šç†ï¼‰ã€‚
- en: Compact sets are closed sets.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç´§é›†æ˜¯é—­é›†ã€‚
- en: Let us first check that the unit interval in the reals is indeed a compact set,
    and then check the above claims for compact sets in general metric spaces. In
    the second statement we only need continuity on the given set so we will use `ContinuousOn`
    instead of `Continuous`, and we will give separate statements for the minimum
    and the maximum. Of course all these results are deduced from more general versions,
    some of which will be discussed in later sections.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å…ˆæ£€æŸ¥å®æ•°å•ä½åŒºé—´ç¡®å®æ˜¯ä¸€ä¸ªç´§é›†ï¼Œç„¶åæ£€æŸ¥ä¸€èˆ¬åº¦é‡ç©ºé—´ä¸­ç´§é›†çš„ä¸Šè¿°å‘½é¢˜ã€‚åœ¨ç¬¬äºŒä¸ªå‘½é¢˜ä¸­ï¼Œæˆ‘ä»¬åªéœ€è¦ç»™å®šé›†åˆä¸Šçš„è¿ç»­æ€§ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†ä½¿ç”¨`ContinuousOn`è€Œä¸æ˜¯`Continuous`ï¼Œå¹¶ä¸”æˆ‘ä»¬å°†ä¸ºæœ€å°å€¼å’Œæœ€å¤§å€¼ç»™å‡ºå•ç‹¬çš„é™ˆè¿°ã€‚å½“ç„¶ï¼Œæ‰€æœ‰è¿™äº›ç»“æœéƒ½æ˜¯ä»æ›´ä¸€èˆ¬çš„ç‰ˆæœ¬ä¸­æ¨å¯¼å‡ºæ¥çš„ï¼Œå…¶ä¸­ä¸€äº›å°†åœ¨åé¢çš„ç« èŠ‚ä¸­è®¨è®ºã€‚
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can also specify that a metric spaces is globally compact, using an extra
    `Prop`-valued type class:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å¯ä»¥æŒ‡å®šåº¦é‡ç©ºé—´æ˜¯å…¨å±€ç´§è‡´çš„ï¼Œä½¿ç”¨é¢å¤–çš„`Prop`å€¼ç±»å‹ç±»ï¼š
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In a compact metric space any closed set is compact, this is `IsClosed.isCompact`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç´§è‡´åº¦é‡ç©ºé—´ä¸­ï¼Œä»»ä½•é—­é›†éƒ½æ˜¯ç´§è‡´çš„ï¼Œè¿™æ˜¯`IsClosed.isCompact`ã€‚
- en: 11.2.4\. Uniformly continuous functions[ïƒ](#uniformly-continuous-functions "Link
    to this heading")
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.4\. ä¸€è‡´è¿ç»­å‡½æ•°[ïƒ](#uniformly-continuous-functions "é“¾æ¥åˆ°æœ¬æ ‡é¢˜")
- en: 'We now turn to uniformity notions on metric spaces : uniformly continuous functions,
    Cauchy sequences and completeness. Again those are defined in a more general context
    but we have lemmas in the metric name space to access their elementary definitions.
    We start with uniform continuity.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬è½¬å‘åº¦é‡ç©ºé—´ä¸Šçš„ä¸€è‡´æ€§æ¦‚å¿µï¼šä¸€è‡´è¿ç»­å‡½æ•°ã€æŸ¯è¥¿åºåˆ—å’Œå®Œå¤‡æ€§ã€‚åŒæ ·ï¼Œè¿™äº›éƒ½æ˜¯åœ¨æ›´ä¸€èˆ¬çš„ç¯å¢ƒä¸­å®šä¹‰çš„ï¼Œä½†æˆ‘ä»¬æœ‰å…³äºåº¦é‡åç§°ç©ºé—´çš„å¼•ç†æ¥è®¿é—®å®ƒä»¬çš„å…ƒç´ å®šä¹‰ã€‚æˆ‘ä»¬é¦–å…ˆä»ä¸€è‡´è¿ç»­æ€§å¼€å§‹ã€‚
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In order to practice manipulating all those definitions, we will prove that
    continuous functions from a compact metric space to a metric space are uniformly
    continuous (we will see a more general version in a later section).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¸ºäº†ç»ƒä¹ æ“ä½œæ‰€æœ‰è¿™äº›å®šä¹‰ï¼Œæˆ‘ä»¬å°†è¯æ˜ä»ç´§è‡´åº¦é‡ç©ºé—´åˆ°åº¦é‡ç©ºé—´çš„è¿ç»­å‡½æ•°æ˜¯ä¸€è‡´è¿ç»­çš„ï¼ˆæˆ‘ä»¬å°†åœ¨åé¢çš„ç« èŠ‚ä¸­çœ‹åˆ°ä¸€ä¸ªæ›´ä¸€èˆ¬çš„å½¢å¼ï¼‰ã€‚ '
- en: 'We will first give an informal sketch. Let `f : X â†’ Y` be a continuous function
    from a compact metric space to a metric space. We fix `Îµ > 0` and start looking
    for some `Î´`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 'æˆ‘ä»¬é¦–å…ˆç»™å‡ºä¸€ä¸ªéæ­£å¼çš„è‰å›¾ã€‚è®¾ `f : X â†’ Y` æ˜¯ä»ä¸€ä¸ªç´§è‡´åº¦é‡ç©ºé—´åˆ°åº¦é‡ç©ºé—´çš„è¿ç»­å‡½æ•°ã€‚æˆ‘ä»¬å›ºå®š `Îµ > 0` å¹¶å¼€å§‹å¯»æ‰¾æŸä¸ª `Î´`ã€‚'
- en: 'Let `Ï† : X Ã— X â†’ â„ := fun p â†¦ dist (f p.1) (f p.2)` and let `K := { p : X Ã—
    X | Îµ â‰¤ Ï† p }`. Observe `Ï†` is continuous since `f` and distance are continuous.
    And `K` is clearly closed (use `isClosed_le`) hence compact since `X` is compact.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 'è®¾ `Ï† : X Ã— X â†’ â„ := fun p â†¦ dist (f p.1) (f p.2)` å¹¶è®¾ `K := { p : X Ã— X | Îµ
    â‰¤ Ï† p }`ã€‚è§‚å¯Ÿ `Ï†` æ˜¯è¿ç»­çš„ï¼Œå› ä¸º `f` å’Œè·ç¦»éƒ½æ˜¯è¿ç»­çš„ã€‚å¹¶ä¸” `K` æ˜¾ç„¶æ˜¯é—­é›†ï¼ˆä½¿ç”¨ `isClosed_le`ï¼‰ï¼Œå› æ­¤ç”±äº `X` æ˜¯ç´§è‡´çš„ï¼Œ`K`
    ä¹Ÿæ˜¯ç´§è‡´çš„ã€‚'
- en: Then we discuss two possibilities using `eq_empty_or_nonempty`. If `K` is empty
    then we are clearly done (we can set `Î´ = 1` for instance). So letâ€™s assume `K`
    is not empty, and use the extreme value theorem to choose `(xâ‚€, xâ‚)` attaining
    the infimum of the distance function on `K`. We can then set `Î´ = dist xâ‚€ xâ‚`
    and check everything works.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬è®¨è®ºä½¿ç”¨ `eq_empty_or_nonempty` çš„ä¸¤ç§å¯èƒ½æ€§ã€‚å¦‚æœ `K` æ˜¯ç©ºçš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ˜¾ç„¶å·²ç»å®Œæˆäº†ï¼ˆä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥å°† `Î´`
    è®¾ç½®ä¸º `1`ï¼‰ã€‚æ‰€ä»¥è®©æˆ‘ä»¬å‡è®¾ `K` ä¸æ˜¯ç©ºçš„ï¼Œå¹¶ä½¿ç”¨æå€¼å®šç†æ¥é€‰æ‹© `(xâ‚€, xâ‚)`ï¼Œå®ƒåœ¨ `K` ä¸Šçš„è·ç¦»å‡½æ•°ä¸Šè¾¾åˆ°ä¸‹ç¡®ç•Œã€‚ç„¶åæˆ‘ä»¬å¯ä»¥å°† `Î´`
    è®¾ç½®ä¸º `dist xâ‚€ xâ‚` å¹¶æ£€æŸ¥ä¸€åˆ‡æ˜¯å¦æ­£å¸¸å·¥ä½œã€‚
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 11.2.5\. Completeness[ïƒ](#completeness "Link to this heading")
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.5\. å®Œå¤‡æ€§[ïƒ](#completeness "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")
- en: A Cauchy sequence in a metric space is a sequence whose terms get closer and
    closer to each other. There are a couple of equivalent ways to state that idea.
    In particular converging sequences are Cauchy. The converse is true only in so-called
    *complete* spaces.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨åº¦é‡ç©ºé—´ä¸­çš„ä¸€ä¸ªæŸ¯è¥¿åºåˆ—æ˜¯ä¸€ä¸ªå…¶é¡¹é€æ¸æ¥è¿‘å½¼æ­¤çš„åºåˆ—ã€‚æœ‰å‡ ç§ç­‰ä»·çš„æ–¹å¼æ¥è¡¨è¿°è¿™ä¸ªæƒ³æ³•ã€‚ç‰¹åˆ«æ˜¯æ”¶æ•›åºåˆ—æ˜¯æŸ¯è¥¿åºåˆ—ã€‚é€†å‘½é¢˜ä»…åœ¨æ‰€è°“çš„ *å®Œå¤‡* ç©ºé—´ä¸­æˆç«‹ã€‚
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Weâ€™ll practice using this definition by proving a convenient criterion which
    is a special case of a criterion appearing in Mathlib. This is also a good opportunity
    to practice using big sums in a geometric context. In addition to the explanations
    from the filters section, you will probably need `tendsto_pow_atTop_nhds_zero_of_lt_one`,
    `Tendsto.mul` and `dist_le_range_sum_dist`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†é€šè¿‡è¯æ˜ä¸€ä¸ªæ–¹ä¾¿çš„åˆ¤æ®æ¥ç»ƒä¹ ä½¿ç”¨è¿™ä¸ªå®šä¹‰ï¼Œè¿™æ˜¯ Mathlib ä¸­å‡ºç°çš„ä¸€ä¸ªåˆ¤æ®çš„ç‰¹æ®Šæƒ…å†µã€‚è¿™ä¹Ÿæ˜¯ç»ƒä¹ åœ¨å‡ ä½•ç¯å¢ƒä¸­ä½¿ç”¨å¤§å’Œçš„å¥½æœºä¼šã€‚é™¤äº†è¿‡æ»¤å™¨éƒ¨åˆ†çš„è§£é‡Šå¤–ï¼Œä½ å¯èƒ½è¿˜éœ€è¦
    `tendsto_pow_atTop_nhds_zero_of_lt_one`ï¼Œ`Tendsto.mul` å’Œ `dist_le_range_sum_dist`ã€‚
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We are ready for the final boss of this section: Baireâ€™s theorem for complete
    metric spaces! The proof skeleton below shows interesting techniques. It uses
    the `choose` tactic in its exclamation mark variant (you should experiment with
    removing this exclamation mark) and it shows how to define something inductively
    in the middle of a proof using `Nat.rec_on`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»å‡†å¤‡å¥½æœ¬èŠ‚çš„æœ€ç»ˆæŒ‘æˆ˜ï¼šå®Œå¤‡åº¦é‡ç©ºé—´çš„ Baire å®šç†ï¼ä¸‹é¢çš„è¯æ˜æ¡†æ¶æ˜¾ç¤ºäº†æœ‰è¶£çš„æŠ€æœ¯ã€‚å®ƒä½¿ç”¨æ„Ÿå¹å·å˜ä½“çš„ `choose` ç­–ç•¥ï¼ˆä½ åº”è¯¥å°è¯•ç§»é™¤è¿™ä¸ªæ„Ÿå¹å·ï¼‰å¹¶å±•ç¤ºäº†å¦‚ä½•åœ¨è¯æ˜ä¸­ä½¿ç”¨
    `Nat.rec_on` é€’å½’åœ°å®šä¹‰æŸç‰©ã€‚
- en: '[PRE37]  ## 11.3\. Topological spaces[ïƒ](#topological-spaces "Link to this
    heading")'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE37]  ## 11.3\. æ‹“æ‰‘ç©ºé—´[ïƒ](#topological-spaces "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")'
- en: 11.3.1\. Fundamentals[ïƒ](#fundamentals "Link to this heading")
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1\. åŸºç¡€[ïƒ](#fundamentals "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")
- en: We now go up in generality and introduce topological spaces. We will review
    the two main ways to define topological spaces and then explain how the category
    of topological spaces is much better behaved than the category of metric spaces.
    Note that we wonâ€™t be using Mathlib category theory here, only having a somewhat
    categorical point of view.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æé«˜ä¸€èˆ¬æ€§ï¼Œå¼•å…¥æ‹“æ‰‘ç©ºé—´ã€‚æˆ‘ä»¬å°†å›é¡¾å®šä¹‰æ‹“æ‰‘ç©ºé—´çš„ä¸¤ç§ä¸»è¦æ–¹å¼ï¼Œç„¶åè§£é‡Šæ‹“æ‰‘ç©ºé—´èŒƒç•´æ¯”åº¦é‡ç©ºé—´èŒƒç•´è¡¨ç°å¾—æ›´å¥½ã€‚è¯·æ³¨æ„ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œä¸ä¼šä½¿ç”¨ Mathlib
    çš„èŒƒç•´è®ºï¼Œè€Œåªæ˜¯æœ‰ä¸€ä¸ªæŸç§èŒƒç•´çš„è§‚ç‚¹ã€‚
- en: The first way to think about the transition from metric spaces to topological
    spaces is that we only remember the notion of open sets (or equivalently the notion
    of closed sets). From this point of view, a topological space is a type equipped
    with a collection of sets that are called open sets. This collection has to satisfy
    a number of axioms presented below (this collection is slightly redundant but
    we will ignore that).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: æ€è€ƒä»åº¦é‡ç©ºé—´åˆ°æ‹“æ‰‘ç©ºé—´çš„è¿‡æ¸¡çš„ç¬¬ä¸€ç§æ–¹å¼æ˜¯ï¼Œæˆ‘ä»¬åªè®°ä½å¼€é›†çš„æ¦‚å¿µï¼ˆæˆ–è€…ç­‰ä»·åœ°ï¼Œé—­é›†çš„æ¦‚å¿µï¼‰ã€‚ä»è¿™ä¸€è§‚ç‚¹æ¥çœ‹ï¼Œæ‹“æ‰‘ç©ºé—´æ˜¯ä¸€ä¸ªç±»å‹ï¼Œå®ƒé…å¤‡äº†ä¸€ç»„ç§°ä¸ºå¼€é›†çš„é›†åˆã€‚è¿™ä¸ªé›†åˆå¿…é¡»æ»¡è¶³ä¸‹é¢æå‡ºçš„å‡ ä¸ªå…¬ç†ï¼ˆè¿™ä¸ªé›†åˆç¨å¾®æœ‰äº›å†—ä½™ï¼Œä½†æˆ‘ä»¬å°†å¿½ç•¥è¿™ä¸€ç‚¹ï¼‰ã€‚
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Closed sets are then defined as sets whose complement is open. A function between
    topological spaces is (globally) continuous if all preimages of open sets are
    open.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: é—­é›†è¢«å®šä¹‰ä¸ºè¡¥é›†æ˜¯å¼€é›†çš„é›†åˆã€‚åœ¨æ‹“æ‰‘ç©ºé—´ä¹‹é—´çš„å‡½æ•°ï¼ˆå…¨å±€ï¼‰è¿ç»­ï¼Œå¦‚æœæ‰€æœ‰å¼€é›†çš„å‰åƒéƒ½æ˜¯å¼€é›†ã€‚
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With this definition we already see that, compared to metric spaces, topological
    spaces only remember enough information to talk about continuous functions: two
    topological structures on a type are the same if and only if they have the same
    continuous functions (indeed the identity function will be continuous in both
    direction if and only if the two structures have the same open sets).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ä¸ªå®šä¹‰ï¼Œæˆ‘ä»¬å·²ç»å¼€å§‹çœ‹åˆ°ï¼Œä¸åº¦é‡ç©ºé—´ç›¸æ¯”ï¼Œæ‹“æ‰‘ç©ºé—´åªè®°å¾—è¶³å¤Ÿçš„ä¿¡æ¯æ¥è°ˆè®ºè¿ç»­å‡½æ•°ï¼šä¸€ä¸ªç±»å‹ä¸Šçš„ä¸¤ä¸ªæ‹“æ‰‘ç»“æ„ç›¸åŒï¼Œå½“ä¸”ä»…å½“å®ƒä»¬æœ‰ç›¸åŒçš„è¿ç»­å‡½æ•°ï¼ˆå®é™…ä¸Šï¼Œå¦‚æœä¸¤ä¸ªç»“æ„æœ‰ç›¸åŒçš„å¼€é›†ï¼Œæ’ç­‰å‡½æ•°å°†åœ¨ä¸¤ä¸ªæ–¹å‘ä¸Šéƒ½æ˜¯è¿ç»­çš„ï¼‰ã€‚
- en: 'However as soon as we move on to continuity at a point we see the limitations
    of the approach based on open sets. In Mathlib we frequently think of topological
    spaces as types equipped with a neighborhood filter `ğ“ x` attached to each point
    `x` (the corresponding function `X â†’ Filter X` satisfies certain conditions explained
    further down). Remember from the filters section that these gadgets play two related
    roles. First `ğ“ x` is seen as the generalized set of points of `X` that are close
    to `x`. And then it is seen as giving a way to say, for any predicate `P : X â†’
    Prop`, that this predicate holds for points that are close enough to `x`. Let
    us state that `f : X â†’ Y` is continuous at `x`. The purely filtery way is to say
    that the direct image under `f` of the generalized set of points that are close
    to `x` is contained in the generalized set of points that are close to `f x`.
    Recall this is spelled either `map f (ğ“ x) â‰¤ ğ“ (f x)` or `Tendsto f (ğ“ x) (ğ“ (f
    x))`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç„¶è€Œï¼Œå½“æˆ‘ä»¬è½¬å‘ç‚¹çš„è¿ç»­æ€§æ—¶ï¼Œæˆ‘ä»¬çœ‹åˆ°åŸºäºå¼€é›†çš„æ–¹æ³•çš„å±€é™æ€§ã€‚åœ¨ Mathlib ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸å°†æ‹“æ‰‘ç©ºé—´è§†ä¸ºå¸¦æœ‰é™„åŠ åœ¨æ¯ä¸ªç‚¹ `x` ä¸Šçš„é‚»åŸŸè¿‡æ»¤å™¨
    `ğ“ x` çš„ç±»å‹ï¼ˆç›¸åº”çš„å‡½æ•° `X â†’ Filter X` æ»¡è¶³æŸäº›æ¡ä»¶ï¼Œè¿™äº›æ¡ä»¶å°†åœ¨ä¸‹é¢è¿›ä¸€æ­¥è§£é‡Šï¼‰ã€‚è®°ä½ä»è¿‡æ»¤å™¨éƒ¨åˆ†ï¼Œè¿™äº›å°ç©æ„å„¿æ‰®æ¼”ä¸¤ä¸ªç›¸å…³çš„è§’è‰²ã€‚é¦–å…ˆï¼Œ`ğ“
    x` è¢«è§†ä¸º `X` ä¸­é è¿‘ `x` çš„ç‚¹çš„å¹¿ä¹‰é›†åˆã€‚ç„¶åï¼Œå®ƒè¢«çœ‹ä½œæä¾›äº†ä¸€ç§æ–¹å¼ï¼Œå¯¹äºä»»ä½•è°“è¯ `P : X â†’ Prop`ï¼Œå¯ä»¥è¯´æ˜è¿™ä¸ªè°“è¯å¯¹äºè¶³å¤Ÿé è¿‘
    `x` çš„ç‚¹æˆç«‹ã€‚è®©æˆ‘ä»¬å£°æ˜ `f : X â†’ Y` åœ¨ `x` å¤„æ˜¯è¿ç»­çš„ã€‚çº¯ç²¹åŸºäºè¿‡æ»¤å™¨çš„è¯´æ³•æ˜¯ï¼Œ`f` çš„ç›´æ¥åƒåŒ…å«è¶³å¤Ÿé è¿‘ `x` çš„ç‚¹çš„å¹¿ä¹‰é›†åˆåŒ…å«åœ¨è¶³å¤Ÿé è¿‘
    `f x` çš„ç‚¹çš„å¹¿ä¹‰é›†åˆä¸­ã€‚å›æƒ³ä¸€ä¸‹ï¼Œè¿™å¯ä»¥è¡¨ç¤ºä¸º `map f (ğ“ x) â‰¤ ğ“ (f x)` æˆ– `Tendsto f (ğ“ x) (ğ“ (f x))`ã€‚'
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'One can also spell it using both neighborhoods seen as ordinary sets and a
    neighborhood filter seen as a generalized set: â€œfor any neighborhood `U` of `f
    x`, all points close to `x` are sent to `U`â€. Note that the proof is again `Iff.rfl`,
    this point of view is definitionally equivalent to the previous one.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹Ÿå¯ä»¥ä½¿ç”¨ä¸¤ç§é‚»åŸŸï¼ˆè§†ä¸ºæ™®é€šé›†åˆï¼‰å’Œä¸€ç§é‚»åŸŸè¿‡æ»¤å™¨ï¼ˆè§†ä¸ºå¹¿ä¹‰é›†åˆï¼‰æ¥è¡¨è¿°ï¼šâ€œå¯¹äºä»»ä½• `f x` çš„é‚»åŸŸ `U`ï¼Œæ‰€æœ‰é è¿‘ `x` çš„ç‚¹éƒ½è¢«å‘é€åˆ° `U`â€ã€‚è¯·æ³¨æ„ï¼Œè¯æ˜ä»ç„¶æ˜¯
    `Iff.rfl`ï¼Œè¿™ä¸ªè§‚ç‚¹åœ¨å®šä¹‰ä¸Šæ˜¯ç­‰åŒäºä¹‹å‰çš„ã€‚
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We now explain how to go from one point of view to the other. In terms of open
    sets, we can simply define members of `ğ“ x` as sets that contain an open set containing
    `x`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨è§£é‡Šå¦‚ä½•ä»ä¸€ä¸ªè§‚ç‚¹è½¬æ¢åˆ°å¦ä¸€ä¸ªè§‚ç‚¹ã€‚åœ¨å¼€é›†çš„æœ¯è¯­ä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•åœ°å®šä¹‰ `ğ“ x` çš„æˆå‘˜ä¸ºåŒ…å« `x` çš„å¼€é›†çš„é›†åˆã€‚
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To go in the other direction we need to discuss the condition that `ğ“ : X â†’
    Filter X` must satisfy in order to be the neighborhood function of a topology.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 'è¦å‘ç›¸åçš„æ–¹å‘è¿›è¡Œï¼Œæˆ‘ä»¬éœ€è¦è®¨è®º `ğ“ : X â†’ Filter X` å¿…é¡»æ»¡è¶³çš„æ¡ä»¶ï¼Œä»¥ä¾¿æˆä¸ºæ‹“æ‰‘çš„é‚»åŸŸå‡½æ•°ã€‚'
- en: The first constraint is that `ğ“ x`, seen as a generalized set, contains the
    set `{x}` seen as the generalized set `pure x` (explaining this weird name would
    be too much of a digression, so we simply accept it for now). Another way to say
    it is that if a predicate holds for points close to `x` then it holds at `x`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ä¸ªçº¦æŸæ˜¯ï¼Œå°† `ğ“ x` è§†ä¸ºä¸€ä¸ªå¹¿ä¹‰é›†åˆæ—¶ï¼Œå®ƒåŒ…å«å°† `{x}` è§†ä¸ºä¸€ä¸ªå¹¿ä¹‰é›†åˆ `pure x` çš„é›†åˆï¼ˆè§£é‡Šè¿™ä¸ªå¥‡æ€ªçš„åå­—ä¼šè¿‡äºç¦»é¢˜ï¼Œæ‰€ä»¥æˆ‘ä»¬ç°åœ¨ç®€å•åœ°æ¥å—å®ƒï¼‰ã€‚å¦ä¸€ç§è¯´æ³•æ˜¯ï¼Œå¦‚æœä¸€ä¸ªè°“è¯åœ¨
    `x` é™„è¿‘çš„ç‚¹æˆç«‹ï¼Œé‚£ä¹ˆå®ƒåœ¨ `x` å¤„ä¹Ÿæˆç«‹ã€‚
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then a more subtle requirement is that, for any predicate `P : X â†’ Prop` and
    any `x`, if `P y` holds for `y` close to `x` then for `y` close to `x` and `z`
    close to `y`, `P z` holds. More precisely we have:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç„¶åï¼Œä¸€ä¸ªæ›´å¾®å¦™çš„è¦æ±‚æ˜¯ï¼Œå¯¹äºä»»ä½•è°“è¯ `P : X â†’ Prop` å’Œä»»ä½• `x`ï¼Œå¦‚æœ `P y` å¯¹äºé è¿‘ `x` çš„ `y` æˆç«‹ï¼Œé‚£ä¹ˆå¯¹äºé è¿‘
    `x` å’Œ `y` çš„ `z`ï¼Œ`P z` ä¹Ÿæˆç«‹ã€‚æ›´ç²¾ç¡®åœ°è¯´ï¼Œæˆ‘ä»¬æœ‰ï¼š'
- en: '[PRE44]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Those two results characterize the functions `X â†’ Filter X` that are neighborhood
    functions for a topological space structure on `X`. There is a still a function
    `TopologicalSpace.mkOfNhds : (X â†’ Filter X) â†’ TopologicalSpace X` but it will
    give back its input as a neighborhood function only if it satisfies the above
    two constraints. More precisely we have a lemma `TopologicalSpace.nhds_mkOfNhds`
    saying that in a different way and our next exercise deduces this different way
    from how we stated it above.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 'è¿™ä¸¤ä¸ªç»“æœæè¿°äº†å‡½æ•° `X â†’ Filter X`ï¼Œè¿™äº›å‡½æ•°æ˜¯ `X` ä¸Šæ‹“æ‰‘ç©ºé—´ç»“æ„çš„é‚»åŸŸå‡½æ•°ã€‚ä»ç„¶å­˜åœ¨ä¸€ä¸ªå‡½æ•° `TopologicalSpace.mkOfNhds
    : (X â†’ Filter X) â†’ TopologicalSpace X`ï¼Œä½†å®ƒåªæœ‰åœ¨æ»¡è¶³ä¸Šè¿°ä¸¤ä¸ªçº¦æŸçš„æƒ…å†µä¸‹æ‰ä¼šå°†å…¶è¾“å…¥ä½œä¸ºé‚»åŸŸå‡½æ•°è¿”å›ã€‚æ›´ç²¾ç¡®åœ°è¯´ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªå¼•ç†
    `TopologicalSpace.nhds_mkOfNhds`ï¼Œå®ƒä»¥ä¸åŒçš„æ–¹å¼è¡¨è¿°ï¼Œè€Œæˆ‘ä»¬çš„ä¸‹ä¸€ä¸ªç»ƒä¹ å°†ä»æˆ‘ä»¬ä¸Šè¿°çš„è¡¨è¿°ä¸­æ¨å¯¼å‡ºè¿™ç§ä¸åŒæ–¹å¼ã€‚'
- en: '[PRE45]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that `TopologicalSpace.mkOfNhds` is not so frequently used, but it still
    good to know in what precise sense the neighborhood filters is all there is in
    a topological space structure.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œ`TopologicalSpace.mkOfNhds` å¹¶ä¸ç»å¸¸ä½¿ç”¨ï¼Œä½†äº†è§£åœ¨æ‹“æ‰‘ç©ºé—´ç»“æ„ä¸­é‚»åŸŸè¿‡æ»¤å™¨ç©¶ç«Ÿæ„å‘³ç€ä»€ä¹ˆä»ç„¶æ˜¯å¾ˆå¥½çš„ã€‚
- en: 'The next thing to know in order to efficiently use topological spaces in Mathlib
    is that we use a lot of formal properties of `TopologicalSpace : Type u â†’ Type
    u`. From a purely mathematical point of view, those formal properties are a very
    clean way to explain how topological spaces solve issues that metric spaces have.
    From this point of view, the issues solved by topological spaces is that metric
    spaces enjoy very little functoriality, and have very bad categorical properties
    in general. This comes on top of the fact already discussed that metric spaces
    contain a lot of geometrical information that is not topologically relevant.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¸ºäº†æœ‰æ•ˆåœ°åœ¨ Mathlib ä¸­ä½¿ç”¨æ‹“æ‰‘ç©ºé—´ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“çš„æ˜¯ï¼Œæˆ‘ä»¬ä½¿ç”¨äº† `TopologicalSpace : Type u â†’ Type u`
    çš„è®¸å¤šå½¢å¼æ€§è´¨ã€‚ä»çº¯ç²¹æ•°å­¦çš„è§’åº¦æ¥çœ‹ï¼Œè¿™äº›å½¢å¼æ€§è´¨æ˜¯è§£é‡Šæ‹“æ‰‘ç©ºé—´å¦‚ä½•è§£å†³åº¦é‡ç©ºé—´é—®é¢˜çš„éå¸¸å¹²å‡€çš„æ–¹æ³•ã€‚ä»è¿™ä¸ªè§’åº¦æ¥çœ‹ï¼Œæ‹“æ‰‘ç©ºé—´è§£å†³çš„é—®é¢˜åœ¨äºåº¦é‡ç©ºé—´å‡ ä¹ä¸å…·æœ‰å‡½å­æ€§ï¼Œå¹¶ä¸”åœ¨ä¸€èˆ¬ä¸Šå…·æœ‰å¾ˆå·®çš„èŒƒç•´æ€§è´¨ã€‚è¿™è¿˜åŸºäºå·²ç»è®¨è®ºçš„äº‹å®ï¼Œå³åº¦é‡ç©ºé—´åŒ…å«å¤§é‡ä¸æ‹“æ‰‘æ— å…³çš„å‡ ä½•ä¿¡æ¯ã€‚'
- en: Let us focus on functoriality first. A metric space structure can be induced
    on a subset or, equivalently, it can be pulled back by an injective map. But thatâ€™s
    pretty much everything. They cannot be pulled back by general map or pushed forward,
    even by surjective maps.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å…ˆå…³æ³¨å‡½å­æ€§ã€‚åº¦é‡ç©ºé—´ç»“æ„å¯ä»¥è¯±å¯¼åœ¨å­é›†ä¸Šï¼Œæˆ–è€…ç­‰ä»·åœ°ï¼Œå®ƒå¯ä»¥ç”±ä¸€ä¸ªæ³¨å…¥æ˜ å°„æ‹‰å›ã€‚ä½†è¿™åŸºæœ¬ä¸Šå°±æ˜¯å…¨éƒ¨äº†ã€‚å®ƒä»¬ä¸èƒ½ç”±ä¸€èˆ¬æ˜ å°„æˆ–æ¨å‰ï¼Œç”šè‡³ä¸èƒ½ç”±æ»¡å°„æ˜ å°„æ¨å‰ã€‚
- en: 'In particular there is no sensible distance to put on a quotient of a metric
    space or on an uncountable product of metric spaces. Consider for instance the
    type `â„ â†’ â„`, seen as a product of copies of `â„` indexed by `â„`. We would like
    to say that pointwise convergence of sequences of functions is a respectable notion
    of convergence. But there is no distance on `â„ â†’ â„` that gives this notion of
    convergence. Relatedly, there is no distance ensuring that a map `f : X â†’ (â„ â†’
    â„)` is continuous if and only if `fun x â†¦ f x t` is continuous for every `t :
    â„`.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç‰¹åˆ«åœ°ï¼Œåœ¨åº¦é‡ç©ºé—´çš„å•†æˆ–ä¸å¯æ•°åº¦é‡ç©ºé—´çš„ç§¯ä¸Šï¼Œæ²¡æœ‰åˆç†çš„è·ç¦»å¯ä»¥æ”¾ç½®ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘ç±»å‹ `â„ â†’ â„`ï¼Œå®ƒè¢«è§†ä¸ºç”± `â„` ç´¢å¼•çš„ `â„` çš„å¤åˆ¶å“çš„ç§¯ã€‚æˆ‘ä»¬å¸Œæœ›è¯´ï¼Œå‡½æ•°åºåˆ—é€ç‚¹æ”¶æ•›æ˜¯ä¸€ä¸ªå€¼å¾—å°Šé‡çš„æ”¶æ•›æ¦‚å¿µã€‚ä½†åœ¨
    `â„ â†’ â„` ä¸Šæ²¡æœ‰è·ç¦»å¯ä»¥ç»™å‡ºè¿™ç§æ”¶æ•›æ¦‚å¿µã€‚ç›¸å…³åœ°ï¼Œæ²¡æœ‰è·ç¦»å¯ä»¥ä¿è¯æ˜ å°„ `f : X â†’ (â„ â†’ â„)` è¿ç»­å½“ä¸”ä»…å½“å¯¹äºæ¯ä¸ª `t : â„`ï¼Œ`fun
    x â†¦ f x t` æ˜¯è¿ç»­çš„ã€‚'
- en: 'We now review the data used to solve all those issues. First we can use any
    map `f : X â†’ Y` to push or pull topologies from one side to the other. Those two
    operations form a Galois connection.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 'æˆ‘ä»¬ç°åœ¨å›é¡¾ç”¨äºè§£å†³æ‰€æœ‰è¿™äº›é—®é¢˜çš„æ•°æ®ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»»ä½•æ˜ å°„ `f : X â†’ Y` æ¥ä»ä¸€ä¸ªæ–¹å‘æ¨åŠ¨æˆ–æ‹‰åŠ¨æ‹“æ‰‘åˆ°å¦ä¸€ä¸ªæ–¹å‘ã€‚è¿™ä¸¤ä¸ªæ“ä½œå½¢æˆä¸€ä¸ªä¼½ç½—ç“¦è¿æ¥ã€‚'
- en: '[PRE46]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Those operations are compatible with composition of functions. As usual, pushing
    forward is covariant and pulling back is contravariant, see `coinduced_compose`
    and `induced_compose`. On paper we will use notations \(f_*T\) for `TopologicalSpace.coinduced
    f T` and \(f^*T\) for `TopologicalSpace.induced f T`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æ“ä½œä¸å‡½æ•°çš„å¤åˆæ˜¯å…¼å®¹çš„ã€‚é€šå¸¸ï¼Œæ¨å‰æ˜¯åå˜çš„ï¼Œæ‹‰å›æ˜¯åå¯¹å˜çš„ï¼Œå‚è§ `coinduced_compose` å’Œ `induced_compose`ã€‚åœ¨çº¸ä¸Šï¼Œæˆ‘ä»¬å°†ä½¿ç”¨
    \(f_*T\) è¡¨ç¤º `TopologicalSpace.coinduced f T` å’Œ \(f^*T\) è¡¨ç¤º `TopologicalSpace.induced
    f T`ã€‚
- en: 'Then the next big piece is a complete lattice structure on `TopologicalSpace
    X` for any given structure. If you think of topologies as being primarily the
    data of open sets then you expect the order relation on `TopologicalSpace X` to
    come from `Set (Set X)`, i.e. you expect `t â‰¤ t''` if a set `u` is open for `t''`
    as soon as it is open for `t`. However we already know that Mathlib focuses on
    neighborhoods more than open sets so, for any `x : X` we want the map from topological
    spaces to neighborhoods `fun T : TopologicalSpace X â†¦ @nhds X T x` to be order
    preserving. And we know the order relation on `Filter X` is designed to ensure
    an order preserving `principal : Set X â†’ Filter X`, allowing to see filters as
    generalized sets. So the order relation we do use on `TopologicalSpace X` is opposite
    to the one coming from `Set (Set X)`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ¥ä¸‹æ¥çš„ä¸€å¤§å—æ˜¯å¯¹äºä»»ä½•ç»™å®šçš„ç»“æ„åœ¨ `TopologicalSpace X` ä¸Šçš„å®Œæ•´æ ¼ç»“æ„ã€‚å¦‚æœä½ è®¤ä¸ºæ‹“æ‰‘ä¸»è¦æ˜¯å¼€é›†çš„æ•°æ®ï¼Œé‚£ä¹ˆä½ æœŸæœ› `TopologicalSpace
    X` ä¸Šçš„é¡ºåºå…³ç³»æ¥è‡ª `Set (Set X)`ï¼Œå³ä½ æœŸæœ›å¦‚æœé›†åˆ `u` å¯¹äº `t''` æ˜¯å¼€é›†ï¼Œé‚£ä¹ˆå®ƒå¯¹äº `t` ä¹Ÿæ˜¯å¼€é›†ï¼Œä½ å°±æœŸæœ› `t â‰¤ t''`ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å·²ç»çŸ¥é“Mathlibæ›´å…³æ³¨é‚»åŸŸè€Œä¸æ˜¯å¼€é›†ï¼Œæ‰€ä»¥å¯¹äºä»»ä½•
    `x : X`ï¼Œæˆ‘ä»¬å¸Œæœ›ä»æ‹“æ‰‘ç©ºé—´åˆ°é‚»åŸŸçš„æ˜ å°„ `fun T : TopologicalSpace X â†¦ @nhds X T x` æ˜¯é¡ºåºä¿æŒçš„ã€‚æˆ‘ä»¬è¿˜çŸ¥é“
    `Filter X` ä¸Šçš„é¡ºåºå…³ç³»æ˜¯ä¸ºäº†ç¡®ä¿é¡ºåºä¿æŒçš„ `principal : Set X â†’ Filter X`ï¼Œå…è®¸å°†è¿‡æ»¤å™¨è§†ä¸ºå¹¿ä¹‰é›†åˆã€‚å› æ­¤ï¼Œæˆ‘ä»¬åœ¨
    `TopologicalSpace X` ä¸Šä½¿ç”¨çš„é¡ºåºå…³ç³»ä¸æ¥è‡ª `Set (Set X)` çš„é¡ºåºå…³ç³»ç›¸åã€‚'
- en: '[PRE47]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now we can recover continuity by combining the push-forward (or pull-back) operation
    with the order relation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¯ä»¥é€šè¿‡ç»“åˆæ¨å‰ï¼ˆæˆ–æ‹‰å›ï¼‰æ“ä½œå’Œé¡ºåºå…³ç³»æ¥æ¢å¤è¿ç»­æ€§ã€‚
- en: '[PRE48]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'With this definition and the compatibility of push-forward and composition,
    we get for free the universal property that, for any topological space \(Z\),
    a function \(g : Y â†’ Z\) is continuous for the topology \(f_*T_X\) if and only
    if \(g âˆ˜ f\) is continuous.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 'é€šè¿‡è¿™ä¸ªå®šä¹‰å’Œæ¨å‰å’Œå¤åˆçš„å…¼å®¹æ€§ï¼Œæˆ‘ä»¬å…è´¹è·å¾—äº†è¿™æ ·ä¸€ä¸ªæ™®éæ€§è´¨ï¼šå¯¹äºä»»ä½•æ‹“æ‰‘ç©ºé—´ \(Z\)ï¼Œä¸€ä¸ªå‡½æ•° \(g : Y â†’ Z\) åœ¨æ‹“æ‰‘ \(f_*T_X\)
    ä¸‹æ˜¯è¿ç»­çš„ï¼Œå½“ä¸”ä»…å½“ \(g âˆ˜ f\) æ˜¯è¿ç»­çš„ã€‚'
- en: \[\begin{split}g \text{ continuous } &â‡” g_*(f_*T_X) â‰¤ T_Z \\ &â‡” (g âˆ˜ f)_* T_X
    â‰¤ T_Z \\ &â‡” g âˆ˜ f \text{ continuous}\end{split}\]
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}g \text{ è¿ç»­ } &â‡” g_*(f_*T_X) â‰¤ T_Z \\ &â‡” (g âˆ˜ f)_* T_X â‰¤ T_Z
    \\ &â‡” g âˆ˜ f \text{ è¿ç»­}\end{split}\]
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'So we already get quotient topologies (using the projection map as `f`). This
    wasnâ€™t using that `TopologicalSpace X` is a complete lattice for all `X`. Letâ€™s
    now see how all this structure proves the existence of the product topology by
    abstract non-sense. We considered the case of `â„ â†’ â„` above, but letâ€™s now consider
    the general case of `Î  i, X i` for some `Î¹ : Type*` and `X : Î¹ â†’ Type*`. We want,
    for any topological space `Z` and any function `f : Z â†’ Î  i, X i`, that `f` is
    continuous if and only if `(fun x â†¦ x i) âˆ˜ f` is continuous for all `i`. Let us
    explore that constraint â€œon paperâ€ using notation \(p_i\) for the projection `(fun
    (x : Î  i, X i) â†¦ x i)`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 'å› æ­¤ï¼Œæˆ‘ä»¬å·²ç»å¾—åˆ°äº†å•†æ‹“æ‰‘ï¼ˆä½¿ç”¨æŠ•å½±æ˜ å°„ä½œä¸º `f`ï¼‰ã€‚è¿™å¹¶ä¸æ˜¯å› ä¸º `TopologicalSpace X` å¯¹äºæ‰€æœ‰ `X` éƒ½æ˜¯å®Œæ•´çš„æ ¼ã€‚ç°åœ¨è®©æˆ‘ä»¬çœ‹çœ‹æ‰€æœ‰è¿™äº›ç»“æ„æ˜¯å¦‚ä½•é€šè¿‡æŠ½è±¡çš„èƒ¡è¨€ä¹±è¯­æ¥è¯æ˜ä¹˜ç§¯æ‹“æ‰‘çš„å­˜åœ¨æ€§çš„ã€‚æˆ‘ä»¬ä¸Šé¢è€ƒè™‘äº†
    `â„ â†’ â„` çš„æƒ…å†µï¼Œä½†ç°åœ¨è®©æˆ‘ä»¬è€ƒè™‘ä¸€èˆ¬æƒ…å†µ `Î  i, X i` å¯¹äºæŸä¸ª `Î¹ : Type*` å’Œ `X : Î¹ â†’ Type*`ã€‚æˆ‘ä»¬å¸Œæœ›å¯¹äºä»»ä½•æ‹“æ‰‘ç©ºé—´
    `Z` å’Œä»»ä½•å‡½æ•° `f : Z â†’ Î  i, X i`ï¼Œå¦‚æœå¯¹äºæ‰€æœ‰ `i`ï¼Œ`(fun x â†¦ x i) âˆ˜ f` æ˜¯è¿ç»­çš„ï¼Œé‚£ä¹ˆ `f` æ˜¯è¿ç»­çš„ã€‚è®©æˆ‘ä»¬ä½¿ç”¨è¡¨ç¤ºæŠ•å½±
    `(fun (x : Î  i, X i) â†¦ x i)` çš„ç¬¦å· \(p_i\) æ¥åœ¨â€œçº¸ä¸Šâ€æ¢ç´¢è¿™ä¸ªçº¦æŸï¼š'
- en: \[\begin{split}(âˆ€ i, p_i âˆ˜ f \text{ continuous}) &â‡” âˆ€ i, (p_i âˆ˜ f)_* T_Z â‰¤ T_{X_i}
    \\ &â‡” âˆ€ i, (p_i)_* f_* T_Z â‰¤ T_{X_i}\\ &â‡” âˆ€ i, f_* T_Z â‰¤ (p_i)^*T_{X_i}\\ &â‡” f_*
    T_Z â‰¤ \inf \left[(p_i)^*T_{X_i}\right]\end{split}\]
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}(âˆ€ i, p_i âˆ˜ f \text{ è¿ç»­}) &â‡” âˆ€ i, (p_i âˆ˜ f)_* T_Z â‰¤ T_{X_i} \\
    &â‡” âˆ€ i, (p_i)_* f_* T_Z â‰¤ T_{X_i}\\ &â‡” âˆ€ i, f_* T_Z â‰¤ (p_i)^*T_{X_i}\\ &â‡” f_*
    T_Z â‰¤ \inf \left[(p_i)^*T_{X_i}\right]\end{split}\]
- en: 'So we see that what is the topology we want on `Î  i, X i`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬çœ‹åˆ°æˆ‘ä»¬å¸Œæœ›åœ¨ `Î  i, X i` ä¸Šçš„æ˜¯ä»€ä¹ˆæ‹“æ‰‘ï¼š
- en: '[PRE50]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This ends our tour of how Mathlib thinks that topological spaces fix defects
    of the theory of metric spaces by being a more functorial theory and having a
    complete lattice structure for any fixed type.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±ç»“æŸäº†æˆ‘ä»¬å¯¹Mathlibå¦‚ä½•è®¤ä¸ºæ‹“æ‰‘ç©ºé—´é€šè¿‡æˆä¸ºä¸€ä¸ªæ›´å‡½æ•°åŒ–çš„ç†è®ºå’Œä¸ºä»»ä½•å›ºå®šç±»å‹æä¾›å®Œæ•´çš„æ ¼ç»“æ„æ¥ä¿®å¤åº¦é‡ç©ºé—´ç†è®ºçš„ç¼ºé™·çš„è€ƒå¯Ÿã€‚
- en: 11.3.2\. Separation and countability[ïƒ](#separation-and-countability "Link to
    this heading")
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2\. åˆ†ç¦»ä¸å¯æ•°æ€§[ïƒ](#separation-and-countability "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")
- en: 'We saw that the category of topological spaces have very nice properties. The
    price to pay for this is existence of rather pathological topological spaces.
    There are a number of assumptions you can make on a topological space to ensure
    its behavior is closer to what metric spaces do. The most important is `T2Space`,
    also called â€œHausdorffâ€, that will ensure that limits are unique. A stronger separation
    property is `T3Space` that ensures in addition the RegularSpace property: each
    point has a basis of closed neighborhoods.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çœ‹åˆ°æ‹“æ‰‘ç©ºé—´çš„èŒƒç•´å…·æœ‰éå¸¸ä¸é”™çš„æ€§è´¨ã€‚ä¸ºæ­¤ä»˜å‡ºçš„ä»£ä»·æ˜¯å­˜åœ¨ç›¸å½“ç—…æ€çš„æ‹“æ‰‘ç©ºé—´ã€‚ä½ å¯ä»¥å¯¹æ‹“æ‰‘ç©ºé—´åšå‡ºä¸€äº›å‡è®¾ï¼Œä»¥ç¡®ä¿å…¶è¡Œä¸ºæ›´æ¥è¿‘åº¦é‡ç©ºé—´ã€‚å…¶ä¸­æœ€é‡è¦çš„æ˜¯`T2Space`ï¼Œä¹Ÿç§°ä¸ºâ€œè±ªæ–¯å¤šå¤«â€ï¼Œè¿™å°†ç¡®ä¿æé™æ˜¯å”¯ä¸€çš„ã€‚æ›´å¼ºçš„åˆ†ç¦»æ€§è´¨æ˜¯`T3Space`ï¼Œå®ƒè¿˜ç¡®ä¿äº†æ­£åˆ™ç©ºé—´æ€§è´¨ï¼šæ¯ä¸ªç‚¹éƒ½æœ‰ä¸€ä¸ªç”±é—­é‚»åŸŸç»„æˆçš„åŸºã€‚
- en: '[PRE51]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note that, in every topological space, each point has a basis of open neighborhood,
    by definition.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨æ¯ä¸€ä¸ªæ‹“æ‰‘ç©ºé—´ä¸­ï¼Œæ¯ä¸ªç‚¹éƒ½æœ‰ä¸€ä¸ªç”±å¼€é‚»åŸŸç»„æˆçš„åŸºï¼Œè¿™æ˜¯å®šä¹‰æ‰€è¦æ±‚çš„ã€‚
- en: '[PRE52]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Our main goal is now to prove the basic theorem which allows extension by continuity.
    From Bourbakiâ€™s general topology book, I.8.5, Theorem 1 (taking only the non-trivial
    implication):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨çš„ç›®æ ‡æ˜¯è¯æ˜å…è®¸é€šè¿‡è¿ç»­æ€§æ‰©å±•çš„åŸºæœ¬å®šç†ã€‚ä»Bourbakiçš„æ™®é€šæ‹“æ‰‘å­¦ä¹¦ç±ï¼ŒI.8.5ï¼Œå®šç†1ï¼ˆåªå–éå¹³å‡¡è•´å«ï¼‰ï¼š
- en: 'Let \(X\) be a topological space, \(A\) a dense subset of \(X\), \(f : A â†’
    Y\) a continuous mapping of \(A\) into a \(T_3\) space \(Y\). If, for each \(x\)
    in \(X\), \(f(y)\) tends to a limit in \(Y\) when \(y\) tends to \(x\) while remaining
    in \(A\) then there exists a continuous extension \(Ï†\) of \(f\) to \(X\).'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 'è®¾\(X\)æ˜¯ä¸€ä¸ªæ‹“æ‰‘ç©ºé—´ï¼Œ\(A\)æ˜¯\(X\)çš„ç¨ å¯†å­é›†ï¼Œ\(f : A â†’ Y\)æ˜¯\(A\)åˆ°\(T_3\)ç©ºé—´\(Y\)çš„è¿ç»­æ˜ å°„ã€‚å¦‚æœå¯¹äº\(X\)ä¸­çš„æ¯ä¸ª\(x\)ï¼Œå½“\(y\)åœ¨\(A\)ä¸­è¶‹å‘äº\(x\)æ—¶ï¼Œ\(f(y)\)åœ¨\(Y\)ä¸­è¶‹å‘äºä¸€ä¸ªæé™ï¼Œé‚£ä¹ˆå­˜åœ¨ä¸€ä¸ªå°†\(f\)æ‰©å±•åˆ°\(X\)çš„è¿ç»­æ‰©å±•\(Ï†\)ã€‚'
- en: Actually Mathlib contains a more general version of the above lemma, `IsDenseInducing.continuousAt_extend`,
    but weâ€™ll stick to Bourbakiâ€™s version here.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šï¼ŒMathlibåŒ…å«ä¸Šè¿°å¼•ç†çš„ä¸€ä¸ªæ›´é€šç”¨ç‰ˆæœ¬ï¼Œ`IsDenseInducing.continuousAt_extend`ï¼Œä½†æˆ‘ä»¬å°†åšæŒä½¿ç”¨Bourbakiçš„ç‰ˆæœ¬ã€‚
- en: 'Remember that, given `A : Set X`, `â†¥A` is the subtype associated to `A`, and
    Lean will automatically insert that funny up arrow when needed. And the (inclusion)
    coercion map is `(â†‘) : A â†’ X`. The assumption â€œtends to \(x\) while remaining
    in \(A\)â€ corresponds to the pull-back filter `comap (â†‘) (ğ“ x)`.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 'è®°ä½ï¼Œç»™å®š`A : Set X`ï¼Œ`â†¥A`æ˜¯ä¸`A`å…³è”çš„å­ç±»å‹ï¼Œå¹¶ä¸”å½“éœ€è¦æ—¶Leanä¼šè‡ªåŠ¨æ’å…¥é‚£ä¸ªå¤æ€ªçš„å‘ä¸Šç®­å¤´ã€‚å¹¶ä¸”ï¼ˆåŒ…å«ï¼‰å¼ºåˆ¶æ˜ å°„æ˜¯`(â†‘) :
    A â†’ X`ã€‚å‡è®¾â€œåœ¨\(A\)ä¸­è¶‹å‘äº\(x\)â€å¯¹åº”äºæ‹‰å›è¿‡æ»¤å™¨`comap (â†‘) (ğ“ x)`ã€‚'
- en: Letâ€™s first prove an auxiliary lemma, extracted to simplify the context (in
    particular we donâ€™t need Y to be a topological space here).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å…ˆè¯æ˜ä¸€ä¸ªè¾…åŠ©å¼•ç†ï¼Œå°†å…¶æå–å‡ºæ¥ä»¥ç®€åŒ–ä¸Šä¸‹æ–‡ï¼ˆç‰¹åˆ«æ˜¯è¿™é‡Œæˆ‘ä»¬ä¸éœ€è¦Yæ˜¯ä¸€ä¸ªæ‹“æ‰‘ç©ºé—´ï¼‰ã€‚
- en: '[PRE53]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Letâ€™s now turn to the main proof of the extension by continuity theorem.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬è½¬å‘è¿ç»­æ‰©å±•å®šç†çš„ä¸»è¦è¯æ˜ã€‚
- en: 'When Lean needs a topology on `â†¥A` it will automatically use the induced topology.
    The only relevant lemma is `nhds_induced (â†‘) : âˆ€ a : â†¥A, ğ“ a = comap (â†‘) (ğ“ â†‘a)`
    (this is actually a general lemma about induced topologies).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 'å½“Leanéœ€è¦`â†¥A`ä¸Šçš„æ‹“æ‰‘æ—¶ï¼Œå®ƒå°†è‡ªåŠ¨ä½¿ç”¨è¯±å¯¼æ‹“æ‰‘ã€‚å”¯ä¸€ç›¸å…³çš„å¼•ç†æ˜¯`nhds_induced (â†‘) : âˆ€ a : â†¥A, ğ“ a = comap
    (â†‘) (ğ“ â†‘a)`ï¼ˆè¿™å®é™…ä¸Šæ˜¯ä¸€ä¸ªå…³äºè¯±å¯¼æ‹“æ‰‘çš„é€šç”¨å¼•ç†ï¼‰ã€‚'
- en: 'The proof outline is:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: è¯æ˜æ¦‚è¦æ˜¯ï¼š
- en: The main assumption and the axiom of choice give a function `Ï†` such that `âˆ€
    x, Tendsto f (comap (â†‘) (ğ“ x)) (ğ“ (Ï† x))` (because `Y` is Hausdorff, `Ï†` is entirely
    determined, but we wonâ€™t need that until we try to prove that `Ï†` indeed extends
    `f`).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸»è¦å‡è®¾å’Œé€‰æ‹©å…¬ç†ç»™å‡ºä¸€ä¸ªå‡½æ•°`Ï†`ï¼Œä½¿å¾—`âˆ€ x, Tendsto f (comap (â†‘) (ğ“ x)) (ğ“ (Ï† x))`ï¼ˆå› ä¸º`Y`æ˜¯è±ªæ–¯å¤šå¤«çš„ï¼Œ`Ï†`å®Œå…¨ç¡®å®šï¼Œä½†æˆ‘ä»¬ä¸ä¼šç”¨åˆ°è¿™ä¸€ç‚¹ï¼Œç›´åˆ°æˆ‘ä»¬è¯•å›¾è¯æ˜`Ï†`ç¡®å®æ‰©å±•äº†`f`ï¼‰ã€‚
- en: 'Letâ€™s first prove `Ï†` is continuous. Fix any `x : X`. Since `Y` is regular,
    it suffices to check that for every *closed* neighborhood `V''` of `Ï† x`, `Ï† â»Â¹''
    V'' âˆˆ ğ“ x`. The limit assumption gives (through the auxiliary lemma above) some
    `V âˆˆ ğ“ x` such `IsOpen V âˆ§ (â†‘) â»Â¹'' V âŠ† f â»Â¹'' V''`. Since `V âˆˆ ğ“ x`, it suffices
    to prove `V âŠ† Ï† â»Â¹'' V''`, i.e. `âˆ€ y âˆˆ V, Ï† y âˆˆ V''`. Letâ€™s fix `y` in `V`. Because
    `V` is *open*, it is a neighborhood of `y`. In particular `(â†‘) â»Â¹'' V âˆˆ comap
    (â†‘) (ğ“ y)` and a fortiori `f â»Â¹'' V'' âˆˆ comap (â†‘) (ğ“ y)`. In addition `comap (â†‘)
    (ğ“ y) â‰  âŠ¥` because `A` is dense. Because we know `Tendsto f (comap (â†‘) (ğ“ y))
    (ğ“ (Ï† y))` this implies `Ï† y âˆˆ closure V''` and, since `V''` is closed, we have
    proved `Ï† y âˆˆ V''`.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 'é¦–å…ˆï¼Œæˆ‘ä»¬æ¥è¯æ˜ `Ï†` æ˜¯è¿ç»­çš„ã€‚å›ºå®šä»»æ„çš„ `x : X`ã€‚ç”±äº `Y` æ˜¯æ­£åˆ™çš„ï¼Œæˆ‘ä»¬åªéœ€æ£€æŸ¥å¯¹äº `Ï† x` çš„æ¯ä¸€ä¸ª *é—­* é‚»åŸŸ `V''`ï¼Œ`Ï†
    â»Â¹'' V'' âˆˆ ğ“ x`ã€‚æé™å‡è®¾ç»™å‡ºäº†ï¼ˆé€šè¿‡ä¸Šé¢çš„è¾…åŠ©å¼•ç†ï¼‰ä¸€äº› `V âˆˆ ğ“ x`ï¼Œä½¿å¾— `IsOpen V âˆ§ (â†‘) â»Â¹'' V âŠ† f â»Â¹''
    V''`ã€‚ç”±äº `V âˆˆ ğ“ x`ï¼Œæˆ‘ä»¬åªéœ€è¯æ˜ `V âŠ† Ï† â»Â¹'' V''`ï¼Œå³ `âˆ€ y âˆˆ V, Ï† y âˆˆ V''`ã€‚è®©æˆ‘ä»¬åœ¨ `V` ä¸­å›ºå®š
    `y`ã€‚å› ä¸º `V` æ˜¯ *å¼€* çš„ï¼Œå®ƒæ˜¯ `y` çš„é‚»åŸŸã€‚ç‰¹åˆ«æ˜¯ `(â†‘) â»Â¹'' V âˆˆ comap (â†‘) (ğ“ y)`ï¼Œå¹¶ä¸”æ›´æ˜æ˜¾ `f â»Â¹''
    V'' âˆˆ comap (â†‘) (ğ“ y)`ã€‚æ­¤å¤–ï¼Œ`comap (â†‘) (ğ“ y) â‰  âŠ¥` å› ä¸º `A` æ˜¯ç¨ å¯†çš„ã€‚å› ä¸ºæˆ‘ä»¬çŸ¥é“ `Tendsto f
    (comap (â†‘) (ğ“ y)) (ğ“ (Ï† y))`ï¼Œè¿™è¡¨æ˜ `Ï† y âˆˆ closure V''`ï¼Œå¹¶ä¸”ç”±äº `V''` æ˜¯é—­çš„ï¼Œæˆ‘ä»¬è¯æ˜äº† `Ï† y
    âˆˆ V''`ã€‚'
- en: It remains to prove that `Ï†` extends `f`. This is where the continuity of `f`
    enters the discussion, together with the fact that `Y` is Hausdorff.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: å‰©ä¸‹çš„å·¥ä½œæ˜¯è¯æ˜ `Ï†` æ‰©å±•äº† `f`ã€‚è¿™æ˜¯ `f` çš„è¿ç»­æ€§å’Œ `Y` æ˜¯è±ªæ–¯å¤šå¤«ç©ºé—´çš„äº‹å®è¿›å…¥è®¨è®ºçš„åœ°æ–¹ã€‚
- en: '[PRE54]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In addition to separation property, the main kind of assumption you can make
    on a topological space to bring it closer to metric spaces is countability assumption.
    The main one is first countability asking that every point has a countable neighborhood
    basis. In particular this ensures that closure of sets can be understood using
    sequences.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: é™¤äº†åˆ†ç¦»æ€§è´¨ï¼Œä½ å¯ä»¥å¯¹æ‹“æ‰‘ç©ºé—´åšçš„æœ€ä¸»è¦çš„ä¸€ç§å‡è®¾æ˜¯å¯æ•°æ€§å‡è®¾ã€‚ä¸»è¦çš„ä¸€ä¸ªæ˜¯é¦–å…ˆå¯æ•°æ€§ï¼Œè¦æ±‚æ¯ä¸ªç‚¹éƒ½æœ‰ä¸€ä¸ªå¯æ•°é‚»åŸŸåŸºã€‚ç‰¹åˆ«æ˜¯è¿™ä¿è¯äº†å¯ä»¥ä½¿ç”¨åºåˆ—æ¥ç†è§£é›†åˆçš„é—­åŒ…ã€‚
- en: '[PRE55]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 11.3.3\. Compactness[ïƒ](#id5 "Link to this heading")
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.3\. ç´§æ€§[ïƒ](#id5 "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")
- en: Let us now discuss how compactness is defined for topological spaces. As usual
    there are several ways to think about it and Mathlib goes for the filter version.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬è®¨è®ºæ‹“æ‰‘ç©ºé—´ä¸­ç´§æ€§çš„å®šä¹‰ã€‚é€šå¸¸æœ‰å‡ ç§æ€è€ƒæ–¹å¼ï¼ŒMathlib é‡‡ç”¨çš„æ˜¯æ»¤å­ç‰ˆæœ¬ã€‚
- en: 'We first need to define cluster points of filters. Given a filter `F` on a
    topological space `X`, a point `x : X` is a cluster point of `F` if `F`, seen
    as a generalized set, has non-empty intersection with the generalized set of points
    that are close to `x`.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 'æˆ‘ä»¬é¦–å…ˆéœ€è¦å®šä¹‰æ‹“æ‰‘ç©ºé—´ä¸Šæ»¤å­çš„èšç‚¹ã€‚ç»™å®šä¸€ä¸ªæ‹“æ‰‘ç©ºé—´ `X` ä¸Šçš„æ»¤å­ `F`ï¼Œä¸€ä¸ªç‚¹ `x : X` æ˜¯ `F` çš„èšç‚¹ï¼Œå¦‚æœ `F` ä½œä¸ºå¹¿ä¹‰é›†åˆï¼Œä¸æ¥è¿‘
    `x` çš„ç‚¹çš„å¹¿ä¹‰é›†åˆçš„éç©ºäº¤é›†ã€‚'
- en: Then we can say that a set `s` is compact if every nonempty generalized set
    `F` contained in `s`, i.e. such that `F â‰¤ ğ“Ÿ s`, has a cluster point in `s`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·è¯´ï¼Œä¸€ä¸ªé›†åˆ `s` æ˜¯ç´§çš„ï¼Œå¦‚æœåŒ…å«åœ¨ `s` ä¸­çš„æ¯ä¸€ä¸ªéç©ºå¹¿ä¹‰é›†åˆ `F`ï¼Œå³ `F â‰¤ ğ“Ÿ s`ï¼Œåœ¨ `s` ä¸­éƒ½æœ‰ä¸€ä¸ªèšç‚¹ã€‚
- en: '[PRE56]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'For instance if `F` is `map u atTop`, the image under `u : â„• â†’ X` of `atTop`,
    the generalized set of very large natural numbers, then the assumption `F â‰¤ ğ“Ÿ
    s` means that `u n` belongs to `s` for `n` large enough. Saying that `x` is a
    cluster point of `map u atTop` says the image of very large numbers intersects
    the set of points that are close to `x`. In case `ğ“ x` has a countable basis,
    we can interpret this as saying that `u` has a subsequence converging to `x`,
    and we get back what compactness looks like in metric spaces.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¾‹å¦‚ï¼Œå¦‚æœ `F` æ˜¯ `map u atTop`ï¼Œå³ `u : â„• â†’ X` çš„ `atTop` çš„åƒï¼Œ`atTop` æ˜¯éå¸¸å¤§çš„è‡ªç„¶æ•°çš„å¹¿ä¹‰é›†åˆï¼Œé‚£ä¹ˆ
    `F â‰¤ ğ“Ÿ s` çš„å‡è®¾æ„å‘³ç€å¯¹äºè¶³å¤Ÿå¤§çš„ `n`ï¼Œ`u n` å±äº `s`ã€‚è¯´ `x` æ˜¯ `map u atTop` çš„èšç‚¹æ„å‘³ç€éå¸¸å¤§çš„æ•°çš„åƒä¸æ¥è¿‘
    `x` çš„ç‚¹çš„é›†åˆç›¸äº¤ã€‚å¦‚æœ `ğ“ x` æœ‰å¯æ•°åŸºï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶è§£é‡Šä¸º `u` æœ‰ä¸€ä¸ªå­åºåˆ—æ”¶æ•›åˆ° `x`ï¼Œä»è€Œå¾—åˆ°ç´§æ€§åœ¨åº¦é‡ç©ºé—´ä¸­çš„æ ·å­ã€‚'
- en: '[PRE57]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Cluster points behave nicely with continuous functions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: èšç‚¹ä¸è¿ç»­å‡½æ•°çš„è¡Œä¸ºè‰¯å¥½ã€‚
- en: '[PRE58]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As an exercise, we will prove that the image of a compact set under a continuous
    map is compact. In addition to what we saw already, you should use `Filter.push_pull`
    and `NeBot.of_map`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºç»ƒä¹ ï¼Œæˆ‘ä»¬å°†è¯æ˜åœ¨è¿ç»­æ˜ å°„ä¸‹ç´§é›†çš„åƒä¹Ÿæ˜¯ç´§é›†çš„ã€‚é™¤äº†æˆ‘ä»¬å·²ç»çœ‹åˆ°çš„ï¼Œä½ åº”è¯¥ä½¿ç”¨ `Filter.push_pull` å’Œ `NeBot.of_map`ã€‚
- en: '[PRE59]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'One can also express compactness in terms of open covers: `s` is compact if
    every family of open sets that cover `s` has a finite covering sub-family.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹Ÿå¯ä»¥ç”¨å¼€è¦†ç›–æ¥è¡¨ç¤ºç´§æ€§ï¼šå¦‚æœ `s` æ˜¯ç´§çš„ï¼Œé‚£ä¹ˆè¦†ç›– `s` çš„æ¯ä¸€ä¸ªå¼€é›†æ—éƒ½æœ‰ä¸€ä¸ªæœ‰é™è¦†ç›–å­æ—ã€‚
- en: '[PRE60] [Previous](C10_Linear_Algebra.html "10\. Linear algebra") [Next](C12_Differential_Calculus.html
    "12\. Differential Calculus")'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE60] [ä¸Šä¸€èŠ‚](C10_Linear_Algebra.html "10\. çº¿æ€§ä»£æ•°") [ä¸‹ä¸€èŠ‚](C12_Differential_Calculus.html
    "12\. å¾®ç§¯åˆ†")'
- en: '* * *'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Â© Copyright 2020-2025, Jeremy Avigad, Patrick Massot. Text licensed under CC
    BY 4.0.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Â© ç‰ˆæƒæ‰€æœ‰ 2020-2025ï¼ŒJeremy Avigadï¼ŒPatrick Massotã€‚æ–‡æœ¬è®¸å¯åè®®ä¸º CC BY 4.0ã€‚
- en: Built with [Sphinx](https://www.sphinx-doc.org/) using a [theme](https://github.com/readthedocs/sphinx_rtd_theme)
    provided by [Read the Docs](https://readthedocs.org). Calculus is based on the
    concept of a function, which is used to model quantities that depend on one another.
    For example, it is common to study quantities that change over time. The notion
    of a *limit* is also fundamental. We may say that the limit of a function \(f(x)\)
    is a value \(b\) as \(x\) approaches a value \(a\), or that \(f(x)\) *converges
    to* \(b\) as \(x\) approaches \(a\). Equivalently, we may say that \(f(x)\) approaches
    \(b\) as \(x\) approaches a value \(a\), or that it *tends to* \(b\) as \(x\)
    tends to \(a\). We have already begun to consider such notions in [Section 3.6](C03_Logic.html#sequences-and-convergence).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨[Sphinx](https://www.sphinx-doc.org/)æ„å»ºï¼Œå¹¶é‡‡ç”¨äº†[Read the Docs](https://readthedocs.org)æä¾›çš„[ä¸»é¢˜](https://github.com/readthedocs/sphinx_rtd_theme)ã€‚å¾®ç§¯åˆ†åŸºäºå‡½æ•°çš„æ¦‚å¿µï¼Œè¯¥æ¦‚å¿µç”¨äºæ¨¡æ‹Ÿç›¸äº’ä¾èµ–çš„é‡ã€‚ä¾‹å¦‚ï¼Œç ”ç©¶éšæ—¶é—´å˜åŒ–çš„é‡æ˜¯å¾ˆå¸¸è§çš„ã€‚æé™çš„æ¦‚å¿µä¹Ÿæ˜¯åŸºæœ¬çš„ã€‚æˆ‘ä»¬å¯ä»¥è¯´ï¼Œå½“\(x\)è¶‹è¿‘äºå€¼\(a\)æ—¶ï¼Œå‡½æ•°\(f(x)\)çš„æé™æ˜¯ä¸€ä¸ªå€¼\(b\)ï¼Œæˆ–è€…è¯´\(f(x)\)å½“\(x\)è¶‹è¿‘äº\(a\)æ—¶*æ”¶æ•›äº*\(b\)ã€‚ç­‰ä»·åœ°ï¼Œæˆ‘ä»¬å¯ä»¥è¯´å½“\(x\)è¶‹è¿‘äºå€¼\(a\)æ—¶ï¼Œ\(f(x)\)è¶‹è¿‘äº\(b\)ï¼Œæˆ–è€…è¯´å®ƒå½“\(x\)è¶‹è¿‘äº\(a\)æ—¶*è¶‹å‘äº*\(b\)ã€‚æˆ‘ä»¬å·²ç»åœ¨[ç¬¬3.6èŠ‚](C03_Logic.html#sequences-and-convergence)å¼€å§‹è€ƒè™‘è¿™æ ·çš„æ¦‚å¿µäº†ã€‚
- en: '*Topology* is the abstract study of limits and continuity. Having covered the
    essentials of formalization in Chapters [2](C02_Basics.html#basics) to [7](C07_Structures.html#structures),
    in this chapter, we will explain how topological notions are formalized in Mathlib.
    Not only do topological abstractions apply in much greater generality, but they
    also, somewhat paradoxically, make it easier to reason about limits and continuity
    in concrete instances.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*æ‹“æ‰‘å­¦*æ˜¯æé™å’Œè¿ç»­æ€§çš„æŠ½è±¡ç ”ç©¶ã€‚åœ¨æ¶µç›–äº†ç¬¬[2ç« ](C02_Basics.html#basics)åˆ°[7ç« ](C07_Structures.html#structures)ä¸­å½¢å¼åŒ–çš„åŸºæœ¬è¦ç´ ä¹‹åï¼Œåœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†è§£é‡Šåœ¨Mathlibä¸­å¦‚ä½•å½¢å¼åŒ–æ‹“æ‰‘æ¦‚å¿µã€‚ä¸ä»…æ‹“æ‰‘æŠ½è±¡åœ¨æ›´å¹¿æ³›çš„èŒƒå›´å†…é€‚ç”¨ï¼Œè€Œä¸”å®ƒä»¬åœ¨æŸç§ç¨‹åº¦ä¸Šå…·æœ‰çŸ›ç›¾æ€§ï¼Œä½¿å¾—åœ¨å…·ä½“å®ä¾‹ä¸­æ¨ç†æé™å’Œè¿ç»­æ€§å˜å¾—æ›´åŠ å®¹æ˜“ã€‚'
- en: Topological notions build on quite a few layers of mathematical structure. The
    first layer is naive set theory, as described in [Chapter 4](C04_Sets_and_Functions.html#sets-and-functions).
    The next layer is the theory of *filters*, which we will describe in [Section
    11.1](#filters). On top of that, we layer the theories of *topological spaces*,
    *metric spaces*, and a slightly more exotic intermediate notion called a *uniform
    space*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: æ‹“æ‰‘æ¦‚å¿µå»ºç«‹åœ¨è®¸å¤šæ•°å­¦ç»“æ„å±‚ä¹‹ä¸Šã€‚ç¬¬ä¸€å±‚æ˜¯æè¿°åœ¨[ç¬¬4ç« ](C04_Sets_and_Functions.html#sets-and-functions)ä¸­çš„æœ´ç´ é›†åˆè®ºã€‚ä¸‹ä¸€å±‚æ˜¯*è¿‡æ»¤å™¨*ç†è®ºï¼Œæˆ‘ä»¬å°†åœ¨[ç¬¬11.1èŠ‚](#filters)ä¸­æè¿°ã€‚åœ¨æ­¤åŸºç¡€ä¸Šï¼Œæˆ‘ä»¬å åŠ äº†*æ‹“æ‰‘ç©ºé—´*ã€*åº¦é‡ç©ºé—´*ä»¥åŠä¸€ä¸ªç¨å¾®æ›´å¥‡ç‰¹çš„ä¸­ä»‹æ¦‚å¿µï¼Œç§°ä¸º*å‡åŒ€ç©ºé—´*ã€‚
- en: 'Whereas previous chapters relied on mathematical notions that were likely familiar
    to you, the notion of a filter is less well known, even to many working mathematicians.
    The notion is essential, however, for formalizing mathematics effectively. Let
    us explain why. Let `f : â„ â†’ â„` be any function. We can consider the limit of
    `f x` as `x` approaches some value `xâ‚€`, but we can also consider the limit of
    `f x` as `x` approaches infinity or negative infinity. We can moreover consider
    the limit of `f x` as `x` approaches `xâ‚€` from the right, conventionally written
    `xâ‚€âº`, or from the left, written `xâ‚€â»`. There are variations where `x` approaches
    `xâ‚€` or `xâ‚€âº` or `xâ‚€â»` but is not allowed to take on the value `xâ‚€` itself. This
    results in at least eight ways that `x` can approach something. We can also restrict
    to rational values of `x` or place other constraints on the domain, but letâ€™s
    stick to those 8 cases.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 'è™½ç„¶å‰å‡ ç« ä¾èµ–äºä½ å¯èƒ½å·²ç»ç†Ÿæ‚‰çš„æ•°å­¦æ¦‚å¿µï¼Œä½†è¿‡æ»¤å™¨è¿™ä¸ªæ¦‚å¿µå¯¹è®¸å¤šå·¥ä½œæ•°å­¦å®¶æ¥è¯´å¹¶ä¸é‚£ä¹ˆç†Ÿæ‚‰ã€‚ç„¶è€Œï¼Œè¿™ä¸ªæ¦‚å¿µå¯¹äºæœ‰æ•ˆåœ°å½¢å¼åŒ–æ•°å­¦æ˜¯å¿…ä¸å¯å°‘çš„ã€‚è®©æˆ‘ä»¬è§£é‡Šä¸€ä¸‹åŸå› ã€‚è®¾\(f
    : â„ â†’ â„\)ä¸ºä»»æ„å‡½æ•°ã€‚æˆ‘ä»¬å¯ä»¥è€ƒè™‘å½“\(x\)è¶‹è¿‘äºæŸä¸ªå€¼\(xâ‚€\)æ—¶\(f x\)çš„æé™ï¼Œä½†ä¹Ÿå¯ä»¥è€ƒè™‘å½“\(x\)è¶‹è¿‘äºæ­£æ— ç©·æˆ–è´Ÿæ— ç©·æ—¶\(f
    x\)çš„æé™ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥è€ƒè™‘å½“\(x\)ä»å³ä¾§ï¼ˆé€šå¸¸å†™ä½œ\(xâ‚€âº\)ï¼‰æˆ–ä»å·¦ä¾§ï¼ˆå†™ä½œ\(xâ‚€â»\)ï¼‰è¶‹è¿‘äº\(xâ‚€\)æ—¶\(f x\)çš„æé™ã€‚å­˜åœ¨ä¸€äº›å˜ä½“ï¼Œå…¶ä¸­\(x\)è¶‹è¿‘äº\(xâ‚€\)ã€\(xâ‚€âº\)æˆ–\(xâ‚€â»\)ï¼Œä½†ä¸å…è®¸å–å€¼\(xâ‚€\)æœ¬èº«ã€‚è¿™è‡³å°‘äº§ç”Ÿäº†å…«ç§\(x\)è¶‹è¿‘äºæŸç‰©çš„é€”å¾„ã€‚æˆ‘ä»¬è¿˜å¯ä»¥å°†\(x\)é™åˆ¶ä¸ºæœ‰ç†æ•°æˆ–å¯¹å®šä¹‰åŸŸæ–½åŠ å…¶ä»–çº¦æŸï¼Œä½†è®©æˆ‘ä»¬åšæŒè¿™8ç§æƒ…å†µã€‚'
- en: 'We have a similar variety of options on the codomain: we can specify that `f
    x` approaches a value from the left or right, or that it approaches positive or
    negative infinity, and so on. For example, we may wish to say that `f x` tends
    to `+âˆ` when `x` tends to `xâ‚€` from the right without being equal to `xâ‚€`. This
    results in 64 different kinds of limit statements, and we havenâ€™t even begun to
    deal with limits of sequences, as we did in [Section 3.6](C03_Logic.html#sequences-and-convergence).'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å€¼åŸŸä¸Šï¼Œæˆ‘ä»¬æœ‰ç±»ä¼¼çš„å„ç§é€‰æ‹©ï¼šæˆ‘ä»¬å¯ä»¥æŒ‡å®š`f x`æ˜¯ä»å·¦ä¾§è¿˜æ˜¯å³ä¾§è¶‹è¿‘äºä¸€ä¸ªå€¼ï¼Œæˆ–è€…å®ƒè¶‹è¿‘äºæ­£æ— ç©·æˆ–è´Ÿæ— ç©·ï¼Œç­‰ç­‰ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯èƒ½å¸Œæœ›è¯´ï¼Œå½“`x`ä»å³ä¾§è¶‹è¿‘äº`xâ‚€`è€Œä¸ç­‰äº`xâ‚€`æ—¶ï¼Œ`f
    x`è¶‹äº`+âˆ`ã€‚è¿™å¯¼è‡´äº†64ç§ä¸åŒçš„æé™é™ˆè¿°ï¼Œè€Œæˆ‘ä»¬ç”šè‡³è¿˜æ²¡æœ‰å¼€å§‹å¤„ç†ä¸æ•°åˆ—çš„æé™ï¼Œæ­£å¦‚æˆ‘ä»¬åœ¨[ç¬¬3.6èŠ‚](C03_Logic.html#sequences-and-convergence)ä¸­æ‰€åšçš„é‚£æ ·ã€‚
- en: 'The problem is compounded even further when it comes to the supporting lemmas.
    For instance, limits compose: if `f x` tends to `yâ‚€` when `x` tends to `xâ‚€` and
    `g y` tends to `zâ‚€` when `y` tends to `yâ‚€` then `g âˆ˜ f x` tends to `zâ‚€` when `x`
    tends to `xâ‚€`. There are three notions of â€œtends toâ€ at play here, each of which
    can be instantiated in any of the eight ways described in the previous paragraph.
    This results in 512 lemmas, a lot to have to add to a library! Informally, mathematicians
    generally prove two or three of these and simply note that the rest can be proved
    â€œin the same way.â€ Formalizing mathematics requires making the relevant notion
    of â€œsamenessâ€ fully explicit, and that is exactly what Bourbakiâ€™s theory of filters
    manages to do.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æ¶‰åŠåˆ°æ”¯æŒå¼•ç†æ—¶ï¼Œé—®é¢˜å˜å¾—æ›´åŠ å¤æ‚ã€‚ä¾‹å¦‚ï¼Œæé™å¯ä»¥ç»„åˆï¼šå¦‚æœ`f x`åœ¨`x`è¶‹è¿‘äº`xâ‚€`æ—¶è¶‹äº`yâ‚€`ï¼Œè€Œ`g y`åœ¨`y`è¶‹è¿‘äº`yâ‚€`æ—¶è¶‹äº`zâ‚€`ï¼Œé‚£ä¹ˆ`g
    âˆ˜ f x`åœ¨`x`è¶‹è¿‘äº`xâ‚€`æ—¶ä¹Ÿè¶‹äº`zâ‚€`ã€‚è¿™é‡Œæ¶‰åŠåˆ°ä¸‰ç§â€œè¶‹äºâ€çš„æ¦‚å¿µï¼Œæ¯ç§éƒ½å¯ä»¥ç”¨å‰ä¸€æ®µä¸­æè¿°çš„å…«ç§æ–¹å¼ä¸­çš„ä»»ä½•ä¸€ç§æ¥å®ä¾‹åŒ–ã€‚è¿™å¯¼è‡´äº†512ä¸ªå¼•ç†ï¼Œéœ€è¦æ·»åŠ åˆ°åº“ä¸­ï¼éæ­£å¼åœ°è¯´ï¼Œæ•°å­¦å®¶é€šå¸¸è¯æ˜å…¶ä¸­ä¸¤åˆ°ä¸‰ä¸ªï¼Œå¹¶ç®€å•åœ°æŒ‡å‡ºå…¶ä½™çš„å¯ä»¥â€œä»¥ç›¸åŒçš„æ–¹å¼â€è¯æ˜ã€‚å½¢å¼åŒ–æ•°å­¦éœ€è¦ä½¿ç›¸å…³çš„â€œç›¸åŒâ€æ¦‚å¿µå®Œå…¨æ˜ç¡®ï¼Œè¿™æ­£æ˜¯Bourbakiçš„è¿‡æ»¤å™¨ç†è®ºæ‰€æˆåŠŸåšåˆ°çš„ã€‚
- en: '## 11.1\. Filters[ïƒ](#filters "Link to this heading")'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '## 11.1\. è¿‡æ»¤å™¨[ïƒ](#filters "é“¾æ¥åˆ°æœ¬æ ‡é¢˜")'
- en: 'A *filter* on a type `X` is a collection of sets of `X` that satisfies three
    conditions that we will spell out below. The notion supports two related ideas:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç±»å‹`X`ä¸Šçš„*è¿‡æ»¤å™¨*æ˜¯ä¸€ç»„`X`çš„é›†åˆï¼Œå®ƒæ»¡è¶³ä»¥ä¸‹ä¸‰ä¸ªæ¡ä»¶ï¼Œæˆ‘ä»¬å°†åœ¨ä¸‹é¢è¯¦ç»†è¯´æ˜ã€‚è¿™ä¸ªæ¦‚å¿µæ”¯æŒä¸¤ä¸ªç›¸å…³æƒ³æ³•ï¼š
- en: '*limits*, including all the kinds of limits discussed above: finite and infinite
    limits of sequences, finite and infinite limits of functions at a point or at
    infinity, and so on.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*æé™*ï¼ŒåŒ…æ‹¬ä¸Šè¿°è®¨è®ºçš„æ‰€æœ‰ç±»å‹çš„æé™ï¼šæ•°åˆ—çš„æœ‰é™å’Œæ— é™æé™ï¼Œå‡½æ•°åœ¨ä¸€ç‚¹æˆ–æ— ç©·è¿œå¤„çš„æœ‰é™å’Œæ— é™æé™ï¼Œç­‰ç­‰ã€‚'
- en: '*things happening eventually*, including things happening for large enough
    `n : â„•`, or sufficiently near a point `x`, or for sufficiently close pairs of
    points, or almost everywhere in the sense of measure theory. Dually, filters can
    also express the idea of *things happening often*: for arbitrarily large `n`,
    at a point in any neighborhood of a given point, etc.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*æœ€ç»ˆå‘ç”Ÿçš„äº‹æƒ…*ï¼ŒåŒ…æ‹¬å¯¹äºè¶³å¤Ÿå¤§çš„`n : â„•`ï¼Œæˆ–è€…è¶³å¤Ÿæ¥è¿‘ä¸€ä¸ªç‚¹`x`ï¼Œæˆ–è€…å¯¹äºè¶³å¤Ÿæ¥è¿‘çš„ç‚¹å¯¹ï¼Œæˆ–è€…åœ¨æµ‹åº¦ç†è®ºæ„ä¹‰ä¸Šçš„å‡ ä¹å¤„å¤„ã€‚ç±»ä¼¼åœ°ï¼Œè¿‡æ»¤å™¨ä¹Ÿå¯ä»¥è¡¨è¾¾*ç»å¸¸å‘ç”Ÿçš„äº‹æƒ…*çš„æ¦‚å¿µï¼šå¯¹äºä»»æ„å¤§çš„`n`ï¼Œåœ¨ä»»æ„ç»™å®šç‚¹çš„ä»»æ„é‚»åŸŸå†…ï¼Œç­‰ç­‰ã€‚'
- en: 'The filters that correspond to these descriptions will be defined later in
    this section, but we can already name them:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹åº”äºè¿™äº›æè¿°çš„è¿‡æ»¤å™¨å°†åœ¨æœ¬èŠ‚çš„åé¢å®šä¹‰ï¼Œä½†æˆ‘ä»¬å¯ä»¥å…ˆå‘½åå®ƒä»¬ï¼š
- en: '`(atTop : Filter â„•)`, made of sets of `â„•` containing `{n | n â‰¥ N}` for some
    `N`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(atTop : Filter â„•)`ï¼Œç”±åŒ…å«`{n | n â‰¥ N}`ï¼ˆå¯¹äºæŸä¸ª`N`ï¼‰çš„`â„•`çš„é›†åˆç»„æˆã€‚'
- en: '`ğ“ x`, made of neighborhoods of `x` in a topological space'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ğ“ x`ï¼Œç”±æ‹“æ‰‘ç©ºé—´ä¸­`x`çš„é‚»åŸŸç»„æˆã€‚'
- en: '`ğ“¤ X`, made of entourages of a uniform space (uniform spaces generalize metric
    spaces and topological groups)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ğ“¤ X`ï¼Œç”±å‡åŒ€ç©ºé—´ï¼ˆå‡åŒ€ç©ºé—´æ˜¯åº¦é‡ç©ºé—´å’Œæ‹“æ‰‘ç¾¤çš„æ¨å¹¿ï¼‰çš„é‚»åŸŸç»„æˆã€‚'
- en: '`Î¼.ae` , made of sets whose complement has zero measure with respect to a measure
    `Î¼`.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Î¼.ae`ï¼Œç”±å…¶è¡¥é›†ç›¸å¯¹äºæµ‹åº¦`Î¼`çš„æµ‹åº¦ä¸ºé›¶çš„é›†åˆç»„æˆã€‚'
- en: 'The general definition is as follows: a filter `F : Filter X` is a collection
    of sets `F.sets : Set (Set X)` satisfying the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¸€èˆ¬å®šä¹‰å¦‚ä¸‹ï¼šä¸€ä¸ªè¿‡æ»¤å™¨`F : Filter X`æ˜¯ä¸€ä¸ªé›†åˆ`F.sets : Set (Set X)`ï¼Œå®ƒæ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š'
- en: '`F.univ_sets : univ âˆˆ F.sets`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F.univ_sets : univ âˆˆ F.sets`'
- en: '`F.sets_of_superset : âˆ€ {U V}, U âˆˆ F.sets â†’ U âŠ† V â†’ V âˆˆ F.sets`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F.sets_of_superset : âˆ€ {U V}, U âˆˆ F.sets â†’ U âŠ† V â†’ V âˆˆ F.sets`'
- en: '`F.inter_sets : âˆ€ {U V}, U âˆˆ F.sets â†’ V âˆˆ F.sets â†’ U âˆ© V âˆˆ F.sets`.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F.inter_sets : âˆ€ {U V}, U âˆˆ F.sets â†’ V âˆˆ F.sets â†’ U âˆ© V âˆˆ F.sets`.'
- en: The first condition says that the set of all elements of `X` belongs to `F.sets`.
    The second condition says that if `U` belongs to `F.sets` then anything containing
    `U` also belongs to `F.sets`. The third condition says that `F.sets` is closed
    under finite intersections. In Mathlib, a filter `F` is defined to be a structure
    bundling `F.sets` and its three properties, but the properties carry no additional
    data, and it is convenient to blur the distinction between `F` and `F.sets`. We
    therefore define `U âˆˆ F` to mean `U âˆˆ F.sets`. This explains why the word `sets`
    appears in the names of some lemmas that that mention `U âˆˆ F`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ä¸ªæ¡ä»¶è¯´æ˜ï¼Œ`X`çš„æ‰€æœ‰å…ƒç´ é›†åˆå±äº`F.sets`ã€‚ç¬¬äºŒä¸ªæ¡ä»¶è¯´æ˜ï¼Œå¦‚æœ`U`å±äº`F.sets`ï¼Œé‚£ä¹ˆåŒ…å«`U`çš„ä»»ä½•ä¸œè¥¿ä¹Ÿå±äº`F.sets`ã€‚ç¬¬ä¸‰ä¸ªæ¡ä»¶è¯´æ˜ï¼Œ`F.sets`åœ¨æœ‰é™äº¤é›†ä¸‹æ˜¯å°é—­çš„ã€‚åœ¨Mathlibä¸­ï¼Œä¸€ä¸ªè¿‡æ»¤å™¨`F`è¢«å®šä¹‰ä¸ºå°†`F.sets`åŠå…¶ä¸‰ä¸ªå±æ€§æ†ç»‘åœ¨ä¸€èµ·çš„ç»“æ„ï¼Œä½†å±æ€§ä¸æºå¸¦ä»»ä½•é¢å¤–æ•°æ®ï¼Œå¹¶ä¸”æ¨¡ç³Š`F`å’Œ`F.sets`ä¹‹é—´çš„åŒºåˆ«æ˜¯æ–¹ä¾¿çš„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å®šä¹‰`U
    âˆˆ F`è¡¨ç¤º`U âˆˆ F.sets`ã€‚è¿™è§£é‡Šäº†ä¸ºä»€ä¹ˆåœ¨æåŠ`U âˆˆ F`çš„ä¸€äº›å¼•ç†åç§°ä¸­å‡ºç°äº†å•è¯`sets`ã€‚
- en: It may help to think of a filter as defining a notion of a â€œsufficiently largeâ€
    set. The first condition then says that `univ` is sufficiently large, the second
    one says that a set containing a sufficiently large set is sufficiently large
    and the third one says that the intersection of two sufficiently large sets is
    sufficiently large.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: å¯ä»¥å°†è¿‡æ»¤å™¨è§†ä¸ºå®šä¹‰ä¸€ä¸ªâ€œè¶³å¤Ÿå¤§â€çš„é›†åˆçš„æ¦‚å¿µã€‚ç¬¬ä¸€ä¸ªæ¡ä»¶è¯´æ˜`univ`è¶³å¤Ÿå¤§ï¼Œç¬¬äºŒä¸ªæ¡ä»¶è¯´æ˜åŒ…å«è¶³å¤Ÿå¤§çš„é›†åˆçš„é›†åˆè¶³å¤Ÿå¤§ï¼Œç¬¬ä¸‰ä¸ªæ¡ä»¶è¯´æ˜ä¸¤ä¸ªè¶³å¤Ÿå¤§çš„é›†åˆçš„äº¤é›†è¶³å¤Ÿå¤§ã€‚
- en: 'It may be even more useful to think of a filter on a type `X` as a generalized
    element of `Set X`. For instance, `atTop` is the â€œset of very large numbersâ€ and
    `ğ“ xâ‚€` is the â€œset of points very close to `xâ‚€`.â€ One manifestation of this view
    is that we can associate to any `s : Set X` the so-called *principal filter* consisting
    of all sets that contain `s`. This definition is already in Mathlib and has a
    notation `ğ“Ÿ` (localized in the `Filter` namespace). For the purpose of demonstration,
    we ask you to take this opportunity to work out the definition here.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 'å°†ç±»å‹`X`ä¸Šçš„è¿‡æ»¤å™¨è§†ä¸º`Set X`çš„å¹¿ä¹‰å…ƒç´ å¯èƒ½æ›´æœ‰ç”¨ã€‚ä¾‹å¦‚ï¼Œ`atTop`æ˜¯â€œéå¸¸å¤§çš„æ•°â€çš„é›†åˆï¼Œè€Œ`ğ“ xâ‚€`æ˜¯â€œéå¸¸æ¥è¿‘`xâ‚€`çš„ç‚¹â€çš„é›†åˆã€‚è¿™ç§è§‚ç‚¹çš„ä¸€ä¸ªè¡¨ç°æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥å°†ä»»ä½•`s
    : Set X`ä¸æ‰€è°“çš„*ä¸»è¿‡æ»¤å™¨*å…³è”èµ·æ¥ï¼Œè¯¥è¿‡æ»¤å™¨åŒ…å«æ‰€æœ‰åŒ…å«`s`çš„é›†åˆã€‚è¿™ä¸ªå®šä¹‰å·²ç»åœ¨Mathlibä¸­ï¼Œå¹¶ä¸”æœ‰`ğ“Ÿ`ï¼ˆåœ¨`Filter`å‘½åç©ºé—´ä¸­å±€éƒ¨åŒ–ï¼‰çš„ç¬¦å·ã€‚ä¸ºäº†æ¼”ç¤ºç›®çš„ï¼Œæˆ‘ä»¬è¦æ±‚ä½ åˆ©ç”¨è¿™ä¸ªæœºä¼šåœ¨è¿™é‡Œæ¨å¯¼å‡ºå®šä¹‰ã€‚'
- en: '[PRE61]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'For our second example, we ask you to define the filter `atTop : Filter â„•`.
    (We could use any type with a preorder instead of `â„•`.)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 'å¯¹äºæˆ‘ä»¬çš„ç¬¬äºŒä¸ªä¾‹å­ï¼Œæˆ‘ä»¬è¦æ±‚ä½ å®šä¹‰è¿‡æ»¤å™¨`atTop : Filter â„•`ã€‚ï¼ˆæˆ‘ä»¬å¯ä»¥ç”¨ä»»ä½•å…·æœ‰ååºçš„`â„•`ä»£æ›¿ã€‚ï¼‰'
- en: '[PRE62]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can also directly define the filter `ğ“ x` of neighborhoods of any `x : â„`.
    In the real numbers, a neighborhood of `x` is a set containing an open interval
    \((x_0 - \varepsilon, x_0 + \varepsilon)\), defined in Mathlib as `Ioo (xâ‚€ - Îµ)
    (xâ‚€ + Îµ)`. (This notion of a neighborhood is only a special case of a more general
    construction in Mathlib.)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 'æˆ‘ä»¬è¿˜å¯ä»¥ç›´æ¥å®šä¹‰ä»»ä½•`x : â„`çš„é‚»åŸŸè¿‡æ»¤å™¨`ğ“ x`ã€‚åœ¨å®æ•°ä¸­ï¼Œ`x`çš„é‚»åŸŸæ˜¯åŒ…å«ä¸€ä¸ªå¼€åŒºé—´`(x_0 - \varepsilon, x_0 +
    \varepsilon)`çš„é›†åˆï¼Œåœ¨Mathlibä¸­å®šä¹‰ä¸º`Ioo (xâ‚€ - Îµ) (xâ‚€ + Îµ)`ã€‚ï¼ˆè¿™ç§é‚»åŸŸçš„æ¦‚å¿µåªæ˜¯Mathlibä¸­æ›´ä¸€èˆ¬æ„é€ çš„ä¸€ä¸ªç‰¹ä¾‹ã€‚ï¼‰'
- en: 'With these examples, we can already define what it means for a function `f
    : X â†’ Y` to converge to some `G : Filter Y` along some `F : Filter X`, as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 'é€šè¿‡è¿™äº›ä¾‹å­ï¼Œæˆ‘ä»¬å·²ç»å¯ä»¥å®šä¹‰å‡½æ•°`f : X â†’ Y`åœ¨æŸä¸ª`F : Filter X`ä¸Šæ²¿æŸä¸ª`G : Filter Y`æ”¶æ•›çš„å«ä¹‰ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š'
- en: '[PRE63]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'When `X` is `â„•` and `Y` is `â„`, `Tendstoâ‚ u atTop (ğ“ x)` is equivalent to saying
    that the sequence `u : â„• â†’ â„` converges to the real number `x`. When both `X`
    and `Y` are `â„`, `Tendsto f (ğ“ xâ‚€) (ğ“ yâ‚€)` is equivalent to the familiar notion
    \(\lim_{x \to xâ‚€} f(x) = yâ‚€\). All of the other kinds of limits mentioned in the
    introduction are also equivalent to instances of `Tendstoâ‚` for suitable choices
    of filters on the source and target.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 'å½“`X`æ˜¯`â„•`ä¸”`Y`æ˜¯`â„`æ—¶ï¼Œ`Tendstoâ‚ u atTop (ğ“ x)`ç­‰ä»·äºè¯´åºåˆ—`u : â„• â†’ â„`æ”¶æ•›åˆ°å®æ•°`x`ã€‚å½“`X`å’Œ`Y`éƒ½æ˜¯`â„`æ—¶ï¼Œ`Tendsto
    f (ğ“ xâ‚€) (ğ“ yâ‚€)`ç­‰ä»·äºç†Ÿæ‚‰çš„æé™æ¦‚å¿µ \(\lim_{x \to xâ‚€} f(x) = yâ‚€\)ã€‚ä»‹ç»ä¸­æåˆ°çš„æ‰€æœ‰å…¶ä»–ç±»å‹çš„æé™ä¹Ÿç­‰ä»·äºåœ¨æºå’Œç›®æ ‡ä¸Šé€‰æ‹©åˆé€‚çš„è¿‡æ»¤å™¨æ—¶çš„`Tendstoâ‚`å®ä¾‹ã€‚'
- en: 'The notion `Tendstoâ‚` above is definitionally equivalent to the notion `Tendsto`
    that is defined in Mathlib, but the latter is defined more abstractly. The problem
    with the definition of `Tendstoâ‚` is that it exposes a quantifier and elements
    of `G`, and it hides the intuition that we get by viewing filters as generalized
    sets. We can hide the quantifier `âˆ€ V` and make the intuition more salient by
    using more algebraic and set-theoretic machinery. The first ingredient is the
    *pushforward* operation \(f_*\) associated to any map `f : X â†’ Y`, denoted `Filter.map
    f` in Mathlib. Given a filter `F` on `X`, `Filter.map f F : Filter Y` is defined
    so that `V âˆˆ Filter.map f F â†” f â»Â¹'' V âˆˆ F` holds definitionally. In the example
    file weâ€™ve opened the `Filter` namespace so that `Filter.map` can be written as
    `map`. This means that we can rewrite the definition of `Tendsto` using the order
    relation on `Filter Y`, which is reversed inclusion of the set of members. In
    other words, given `G H : Filter Y`, we have `G â‰¤ H â†” âˆ€ V : Set Y, V âˆˆ H â†’ V âˆˆ
    G`.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¸Šé¢å®šä¹‰çš„`Tendstoâ‚`åœ¨å®šä¹‰ä¸Šç­‰åŒäºåœ¨Mathlibä¸­å®šä¹‰çš„`Tendsto`çš„æ¦‚å¿µï¼Œä½†åè€…å®šä¹‰å¾—æ›´æŠ½è±¡ã€‚`Tendstoâ‚`å®šä¹‰çš„é—®é¢˜åœ¨äºå®ƒæš´éœ²äº†ä¸€ä¸ªé‡è¯å’Œ`G`çš„å…ƒç´ ï¼Œå¹¶éšè—äº†é€šè¿‡å°†è¿‡æ»¤å™¨è§†ä¸ºå¹¿ä¹‰é›†åˆè€Œè·å¾—çš„ç›´è§‰ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨æ›´å¤šçš„ä»£æ•°å’Œé›†åˆè®ºå·¥å…·æ¥éšè—é‡è¯`âˆ€
    V`å¹¶ä½¿ç›´è§‰æ›´åŠ æ˜æ˜¾ã€‚ç¬¬ä¸€ä¸ªæˆåˆ†æ˜¯ä¸ä»»ä½•æ˜ å°„`f : X â†’ Y`ç›¸å…³è”çš„*æ¨å‰*æ“ä½œ`f_*`ï¼Œåœ¨Mathlibä¸­ç”¨`Filter.map f`è¡¨ç¤ºã€‚ç»™å®š`X`ä¸Šçš„è¿‡æ»¤å™¨`F`ï¼Œ`Filter.map
    f F : Filter Y`è¢«å®šä¹‰ä¸º`V âˆˆ Filter.map f F â†” f â»Â¹'' V âˆˆ F`åœ¨å®šä¹‰ä¸Šæˆç«‹ã€‚åœ¨æ‰“å¼€çš„ç¤ºä¾‹æ–‡ä»¶ä¸­ï¼Œæˆ‘ä»¬å·²æ‰“å¼€`Filter`å‘½åç©ºé—´ï¼Œä»¥ä¾¿å¯ä»¥å°†`Filter.map`å†™æˆ`map`ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥ä½¿ç”¨`Filter
    Y`ä¸Šçš„é¡ºåºå…³ç³»é‡å†™`Tendsto`çš„å®šä¹‰ï¼Œè¯¥é¡ºåºå…³ç³»æ˜¯æˆå‘˜é›†åˆçš„åå‘åŒ…å«ã€‚æ¢å¥è¯è¯´ï¼Œç»™å®š`G H : Filter Y`ï¼Œæˆ‘ä»¬æœ‰`G â‰¤ H â†” âˆ€ V
    : Set Y, V âˆˆ H â†’ V âˆˆ G`ã€‚'
- en: '[PRE64]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'It may seem that the order relation on filters is backward. But recall that
    we can view filters on `X` as generalized elements of `Set X`, via the inclusion
    of `ğ“Ÿ : Set X â†’ Filter X` which maps any set `s` to the corresponding principal
    filter. This inclusion is order preserving, so the order relation on `Filter`
    can indeed be seen as the natural inclusion relation between generalized sets.
    In this analogy, pushforward is analogous to the direct image. And, indeed, `map
    f (ğ“Ÿ s) = ğ“Ÿ (f '''' s)`.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 'å¯èƒ½çœ‹èµ·æ¥è¿‡æ»¤å™¨ä¸Šçš„é¡ºåºå…³ç³»æ˜¯ç›¸åçš„ã€‚ä½†å›æƒ³ä¸€ä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡`ğ“Ÿ : Set X â†’ Filter X`çš„åŒ…å«æ¥å°†`X`ä¸Šçš„è¿‡æ»¤å™¨è§†ä¸º`Set X`çš„å¹¿ä¹‰å…ƒç´ ï¼Œè¯¥æ˜ å°„å°†ä»»ä½•é›†åˆ`s`æ˜ å°„åˆ°ç›¸åº”çš„ä¸»è¿‡æ»¤å™¨ã€‚è¿™ä¸ªåŒ…å«æ˜¯é¡ºåºä¿æŒçš„ï¼Œå› æ­¤`Filter`ä¸Šçš„é¡ºåºå…³ç³»ç¡®å®å¯ä»¥çœ‹ä½œæ˜¯å¹¿ä¹‰é›†åˆä¹‹é—´çš„è‡ªç„¶åŒ…å«å…³ç³»ã€‚åœ¨è¿™ä¸ªç±»æ¯”ä¸­ï¼Œæ¨å‰ç›¸å½“äºç›´æ¥åƒã€‚å®é™…ä¸Šï¼Œ`map
    f (ğ“Ÿ s) = ğ“Ÿ (f '''' s)`ã€‚'
- en: 'We can now understand intuitively why a sequence `u : â„• â†’ â„` converges to a
    point `xâ‚€` if and only if we have `map u atTop â‰¤ ğ“ xâ‚€`. The inequality means the
    â€œdirect image under `u`â€ of â€œthe set of very big natural numbersâ€ is â€œincludedâ€
    in â€œthe set of points very close to `xâ‚€`.â€'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥ç›´è§‚åœ°ç†è§£ä¸ºä»€ä¹ˆä¸€ä¸ªåºåˆ—`u : â„• â†’ â„`æ”¶æ•›åˆ°ç‚¹`xâ‚€`å½“ä¸”ä»…å½“æˆ‘ä»¬æœ‰`map u atTop â‰¤ ğ“ xâ‚€`ã€‚è¿™ä¸ªä¸ç­‰å¼æ„å‘³ç€â€œåœ¨`u`ä¸‹çš„ç›´æ¥åƒâ€çš„â€œéå¸¸å¤§çš„è‡ªç„¶æ•°é›†åˆâ€åŒ…å«åœ¨â€œéå¸¸æ¥è¿‘`xâ‚€`çš„ç‚¹é›†åˆâ€ä¸­ã€‚'
- en: As promised, the definition of `Tendstoâ‚‚` does not exhibit any quantifiers or
    sets. It also leverages the algebraic properties of the pushforward operation.
    First, each `Filter.map f` is monotone. And, second, `Filter.map` is compatible
    with composition.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æ‰¿è¯ºçš„é‚£æ ·ï¼Œ`Tendstoâ‚‚`çš„å®šä¹‰æ²¡æœ‰å±•ç¤ºä»»ä½•é‡è¯æˆ–é›†åˆã€‚å®ƒè¿˜åˆ©ç”¨äº†æ¨å‰æ“ä½œçš„ä»£æ•°æ€§è´¨ã€‚é¦–å…ˆï¼Œæ¯ä¸ª`Filter.map f`æ˜¯å•è°ƒçš„ã€‚å…¶æ¬¡ï¼Œ`Filter.map`ä¸ç»„åˆå…¼å®¹ã€‚
- en: '[PRE65]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Together these two properties allow us to prove that limits compose, yielding
    in one shot all 512 variants of the composition lemma described in the introduction,
    and lots more. You can practice proving the following statement using either the
    definition of `Tendstoâ‚` in terms of the universal quantifier or the algebraic
    definition, together with the two lemmas above.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸¤ä¸ªæ€§è´¨å…±åŒä½¿æˆ‘ä»¬èƒ½å¤Ÿè¯æ˜æé™å¯ä»¥ç»„åˆï¼Œä¸€æ¬¡å°±å¾—åˆ°ä»‹ç»ä¸­æè¿°çš„ç»„æˆå¼•ç†çš„æ‰€æœ‰512ä¸ªå˜ä½“ï¼Œä»¥åŠæ›´å¤šã€‚ä½ å¯ä»¥é€šè¿‡ä½¿ç”¨å…³äº`Tendstoâ‚`çš„é€šç”¨é‡è¯å®šä¹‰æˆ–ä»£æ•°å®šä¹‰ï¼Œä»¥åŠä¸Šè¿°ä¸¤ä¸ªå¼•ç†æ¥ç»ƒä¹ è¯æ˜ä»¥ä¸‹é™ˆè¿°ã€‚
- en: '[PRE66]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The pushforward construction uses a map to push filters from the map source
    to the map target. There also a *pullback* operation, `Filter.comap`, going in
    the other direction. This generalizes the preimage operation on sets. For any
    map `f`, `Filter.map f` and `Filter.comap f` form what is known as a *Galois connection*,
    which is to say, they satisfy
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: æ¨å‰æ„é€ ä½¿ç”¨ä¸€ä¸ªæ˜ å°„å°†è¿‡æ»¤å™¨ä»æ˜ å°„æºæ¨é€åˆ°æ˜ å°„ç›®æ ‡ã€‚è¿˜æœ‰ä¸€ä¸ªç›¸åæ–¹å‘çš„*æ‹‰å›*æ“ä½œï¼Œ`Filter.comap`ã€‚è¿™æ¨å¹¿äº†é›†åˆä¸Šçš„å‰åƒæ“ä½œã€‚å¯¹äºä»»ä½•æ˜ å°„`f`ï¼Œ`Filter.map
    f`å’Œ`Filter.comap f`å½¢æˆæ‰€è°“çš„*ä¼½ç½—ç“¦è¿æ¥*ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒä»¬æ»¡è¶³
- en: '`Filter.map_le_iff_le_comap : Filter.map f F â‰¤ G â†” F â‰¤ Filter.comap f G`'
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Filter.map_le_iff_le_comap : Filter.map f F â‰¤ G â†” F â‰¤ Filter.comap f G`'
- en: for every `F` and `G`. This operation could be used to provided another formulation
    of `Tendsto` that would be provably (but not definitionally) equivalent to the
    one in Mathlib.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæ¯ä¸€ä¸ª`F`å’Œ`G`ã€‚è¿™ä¸ªæ“ä½œå¯ä»¥ç”¨æ¥æä¾›`Tendsto`çš„å¦ä¸€ç§å…¬ç†åŒ–è¡¨è¿°ï¼Œè¿™å°†ä¸Mathlibä¸­çš„è¡¨è¿°ï¼ˆè™½ç„¶ä¸æ˜¯å®šä¹‰ä¸Šï¼‰ç­‰ä»·ã€‚
- en: 'The `comap` operation can be used to restrict filters to a subtype. For instance,
    suppose we have `f : â„ â†’ â„`, `xâ‚€ : â„` and `yâ‚€ : â„`, and suppose we want to state
    that `f x` approaches `yâ‚€` when `x` approaches `xâ‚€` within the rational numbers.
    We can pull the filter `ğ“ xâ‚€` back to `â„š` using the coercion map `(â†‘) : â„š â†’ â„`
    and state `Tendsto (f âˆ˜ (â†‘) : â„š â†’ â„) (comap (â†‘) (ğ“ xâ‚€)) (ğ“ yâ‚€)`.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`comap`æ“ä½œå¯ä»¥ç”¨æ¥å°†è¿‡æ»¤å™¨é™åˆ¶ä¸ºå­ç±»å‹ã€‚ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬æœ‰`f : â„ â†’ â„`ï¼Œ`xâ‚€ : â„`å’Œ`yâ‚€ : â„`ï¼Œå¹¶ä¸”å‡è®¾æˆ‘ä»¬æƒ³è¦è¡¨è¿°å½“`x`åœ¨æœ‰ç†æ•°ä¸­æ¥è¿‘`xâ‚€`æ—¶ï¼Œ`f
    x`æ¥è¿‘`yâ‚€`ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¼ºåˆ¶æ˜ å°„`(â†‘) : â„š â†’ â„`å°†è¿‡æ»¤å™¨`ğ“ xâ‚€`æ‹‰å›åˆ°`â„š`ï¼Œå¹¶è¡¨è¿°`Tendsto (f âˆ˜ (â†‘) : â„š â†’ â„)
    (comap (â†‘) (ğ“ xâ‚€)) (ğ“ yâ‚€)`ã€‚'
- en: '[PRE67]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The pullback operation is also compatible with composition, but it is *contravariant*,
    which is to say, it reverses the order of the arguments.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: æ‹‰å›æ“ä½œä¹Ÿä¸ç»„åˆå…¼å®¹ï¼Œä½†å®ƒæ˜¯*é€†å˜*çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒåè½¬äº†å‚æ•°çš„é¡ºåºã€‚
- en: '[PRE68]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Letâ€™s now shift attention to the plane `â„ Ã— â„` and try to understand how the
    neighborhoods of a point `(xâ‚€, yâ‚€)` are related to `ğ“ xâ‚€` and `ğ“ yâ‚€`. There is
    a product operation `Filter.prod : Filter X â†’ Filter Y â†’ Filter (X Ã— Y)`, denoted
    by `Ã—Ë¢`, which answers this question:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç°åœ¨ï¼Œè®©æˆ‘ä»¬å°†æ³¨æ„åŠ›è½¬å‘å¹³é¢`â„ Ã— â„`ï¼Œå¹¶å°è¯•ç†è§£ç‚¹`(xâ‚€, yâ‚€)`çš„é‚»åŸŸå¦‚ä½•ä¸`ğ“ xâ‚€`å’Œ`ğ“ yâ‚€`ç›¸å…³ã€‚å­˜åœ¨ä¸€ä¸ªä¹˜ç§¯æ“ä½œ`Filter.prod
    : Filter X â†’ Filter Y â†’ Filter (X Ã— Y)`ï¼Œè¡¨ç¤ºä¸º`Ã—Ë¢`ï¼Œå®ƒå›ç­”äº†è¿™ä¸ªé—®é¢˜ï¼š'
- en: '[PRE69]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The product operation is defined in terms of the pullback operation and the
    `inf` operation:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: äº§å“æ“ä½œå®šä¹‰ä¸ºæ‹‰å›æ“ä½œå’Œ`inf`æ“ä½œï¼š
- en: '`F Ã—Ë¢ G = (comap Prod.fst F) âŠ“ (comap Prod.snd G)`.'
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`F Ã—Ë¢ G = (comap Prod.fst F) âŠ“ (comap Prod.snd G)`ã€‚'
- en: Here the `inf` operation refers to the lattice structure on `Filter X` for any
    type `X`, whereby `F âŠ“ G` is the greatest filter that is smaller than both `F`
    and `G`. Thus the `inf` operation generalizes the notion of the intersection of
    sets.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œ`inf`æ“ä½œæŒ‡çš„æ˜¯ä»»ä½•ç±»å‹`X`ä¸Š`Filter X`çš„æ ¼ç»“æ„ï¼Œå…¶ä¸­`F âŠ“ G`æ˜¯å°äº`F`å’Œ`G`çš„æœ€å¤§è¿‡æ»¤å™¨ã€‚å› æ­¤ï¼Œ`inf`æ“ä½œæ¨å¹¿äº†é›†åˆäº¤é›†çš„æ¦‚å¿µã€‚
- en: A lot of proofs in Mathlib use all of the aforementioned structure (`map`, `comap`,
    `inf`, `sup`, and `prod`) to give algebraic proofs about convergence without ever
    referring to members of filters. You can practice doing this in a proof of the
    following lemma, unfolding the definition of `Tendsto` and `Filter.prod` if needed.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlibä¸­çš„è®¸å¤šè¯æ˜éƒ½ä½¿ç”¨äº†ä¸Šè¿°æ‰€æœ‰ç»“æ„ï¼ˆ`map`ã€`comap`ã€`inf`ã€`sup`å’Œ`prod`ï¼‰æ¥ç»™å‡ºå…³äºæ”¶æ•›æ€§çš„ä»£æ•°è¯æ˜ï¼Œè€Œä»æœªå¼•ç”¨è¿‡æ»¤å™¨çš„æˆå‘˜ã€‚ä½ å¯ä»¥åœ¨ä»¥ä¸‹å¼•ç†çš„è¯æ˜ä¸­ç»ƒä¹ è¿™æ ·åšï¼Œå¦‚æœéœ€è¦ï¼Œå¯ä»¥å±•å¼€`Tendsto`å’Œ`Filter.prod`çš„å®šä¹‰ã€‚
- en: '[PRE70]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The ordered type `Filter X` is actually a *complete* lattice, which is to say,
    there is a bottom element, there is a top element, and every set of filters on
    `X` has an `Inf` and a `Sup`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰åºç±»å‹`Filter X`å®é™…ä¸Šæ˜¯ä¸€ä¸ª*å®Œå¤‡*æ ¼ï¼Œè¿™æ„å‘³ç€å­˜åœ¨ä¸€ä¸ªåº•å…ƒç´ ï¼Œå­˜åœ¨ä¸€ä¸ªé¡¶å…ƒç´ ï¼Œå¹¶ä¸”`X`ä¸Šçš„æ¯ä¸ªè¿‡æ»¤å™¨é›†åˆéƒ½æœ‰ä¸€ä¸ª`Inf`å’Œ`Sup`ã€‚
- en: 'Note that given the second property in the definition of a filter (if `U` belongs
    to `F` then anything larger than `U` also belongs to `F`), the first property
    (the set of all inhabitants of `X` belongs to `F`) is equivalent to the property
    that `F` is not the empty collection of sets. This shouldnâ€™t be confused with
    the more subtle question as to whether the empty set is an *element* of `F`. The
    definition of a filter does not prohibit `âˆ… âˆˆ F`, but if the empty set is in `F`
    then every set is in `F`, which is to say, `âˆ€ U : Set X, U âˆˆ F`. In this case,
    `F` is a rather trivial filter, which is precisely the bottom element of the complete
    lattice `Filter X`. This contrasts with the definition of filters in Bourbaki,
    which doesnâ€™t allow filters containing the empty set.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ³¨æ„ï¼Œæ ¹æ®è¿‡æ»¤å™¨å®šä¹‰ä¸­çš„ç¬¬äºŒä¸ªæ€§è´¨ï¼ˆå¦‚æœ`U`å±äº`F`ï¼Œåˆ™ä»»ä½•å¤§äº`U`çš„é›†åˆä¹Ÿå±äº`F`ï¼‰ï¼Œç¬¬ä¸€ä¸ªæ€§è´¨ï¼ˆ`X`çš„æ‰€æœ‰å±…æ°‘é›†åˆå±äº`F`ï¼‰ç­‰ä»·äº`F`ä¸æ˜¯ç©ºé›†åˆçš„æ€§è´¨ã€‚è¿™ä¸åº”ä¸æ›´å¾®å¦™çš„é—®é¢˜æ··æ·†ï¼Œå³ç©ºé›†æ˜¯å¦æ˜¯`F`çš„*å…ƒç´ *ã€‚è¿‡æ»¤å™¨çš„å®šä¹‰å¹¶ä¸ç¦æ­¢`âˆ…
    âˆˆ F`ï¼Œä½†å¦‚æœç©ºé›†åœ¨`F`ä¸­ï¼Œåˆ™æ¯ä¸ªé›†åˆéƒ½åœ¨`F`ä¸­ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œ`âˆ€ U : Set X, U âˆˆ F`ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ`F`æ˜¯ä¸€ä¸ªç›¸å½“å¹³å‡¡çš„è¿‡æ»¤å™¨ï¼Œè¿™æ­£æ˜¯å®Œå…¨æ ¼`Filter
    X`çš„åº•å…ƒç´ ã€‚è¿™ä¸Bourbakiä¸­è¿‡æ»¤å™¨çš„å®šä¹‰å½¢æˆå¯¹æ¯”ï¼ŒBourbakiä¸å…è®¸åŒ…å«ç©ºé›†çš„è¿‡æ»¤å™¨ã€‚'
- en: 'Because we include the trivial filter in our definition, we sometimes need
    to explicitly assume nontriviality in some lemmas. In return, however, the theory
    has nicer global properties. We have already seen that including the trivial filter
    gives us a bottom element. It also allows us to define `principal : Set X â†’ Filter
    X`, which maps `âˆ…` to `âŠ¥`, without adding a precondition to rule out the empty
    set. And it allows us to define the pullback operation without a precondition
    as well. Indeed, it can happen that `comap f F = âŠ¥` although `F â‰  âŠ¥`. For instance,
    given `xâ‚€ : â„` and `s : Set â„`, the pullback of `ğ“ xâ‚€` under the coercion from
    the subtype corresponding to `s` is nontrivial if and only if `xâ‚€` belongs to
    the closure of `s`.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç”±äºæˆ‘ä»¬åœ¨å®šä¹‰ä¸­åŒ…æ‹¬äº†å¹³å‡¡è¿‡æ»¤å™¨ï¼Œæˆ‘ä»¬æœ‰æ—¶éœ€è¦æ˜ç¡®å‡è®¾æŸäº›å¼•ç†çš„éå¹³å‡¡æ€§ã€‚ç„¶è€Œï¼Œä½œä¸ºå›æŠ¥ï¼Œç†è®ºå…·æœ‰æ›´ä½³çš„å…¨å±€æ€§è´¨ã€‚æˆ‘ä»¬å·²ç»çœ‹åˆ°ï¼ŒåŒ…æ‹¬å¹³å‡¡è¿‡æ»¤å™¨ç»™æˆ‘ä»¬æä¾›äº†ä¸€ä¸ªåº•å…ƒç´ ã€‚å®ƒè¿˜å…è®¸æˆ‘ä»¬å®šä¹‰`principal
    : Set X â†’ Filter X`ï¼Œè¯¥æ˜ å°„å°†`âˆ…`æ˜ å°„åˆ°`âŠ¥`ï¼Œè€Œä¸éœ€è¦æ·»åŠ ä¸€ä¸ªå…ˆå†³æ¡ä»¶æ¥æ’é™¤ç©ºé›†ã€‚å®ƒè¿˜å…è®¸æˆ‘ä»¬å®šä¹‰æ²¡æœ‰å…ˆå†³æ¡ä»¶çš„æ‹‰å›æ“ä½œã€‚å®é™…ä¸Šï¼Œå¯èƒ½ä¼šå‘ç”Ÿ`comap
    f F = âŠ¥`çš„æƒ…å†µï¼Œå°½ç®¡`F â‰  âŠ¥`ã€‚ä¾‹å¦‚ï¼Œç»™å®š`xâ‚€ : â„`å’Œ`s : Set â„`ï¼Œä»å¯¹åº”äº`s`çš„å­ç±»å‹å¼ºåˆ¶è½¬æ¢ä¸‹çš„`ğ“ xâ‚€`çš„æ‹‰å›æ˜¯éå¹³å‡¡çš„ï¼Œå½“ä¸”ä»…å½“`xâ‚€`å±äº`s`çš„é—­åŒ…ã€‚'
- en: 'In order to manage lemmas that do need to assume some filter is nontrivial,
    Mathlib has a type class `Filter.NeBot`, and the library has lemmas that assume
    `(F : Filter X) [F.NeBot]`. The instance database knows, for example, that `(atTop
    : Filter â„•).NeBot`, and it knows that pushing forward a nontrivial filter gives
    a nontrivial filter. As a result, a lemma assuming `[F.NeBot]` will automatically
    apply to `map u atTop` for any sequence `u`.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¸ºäº†ç®¡ç†éœ€è¦å‡è®¾æŸäº›è¿‡æ»¤å™¨éå¹³å‡¡çš„å¼•ç†ï¼ŒMathlibæœ‰ä¸€ä¸ªç±»å‹ç±»`Filter.NeBot`ï¼Œåº“ä¸­æœ‰å‡è®¾`(F : Filter X) [F.NeBot]`çš„å¼•ç†ã€‚å®ä¾‹æ•°æ®åº“çŸ¥é“ï¼Œä¾‹å¦‚ï¼Œ`(atTop
    : Filter â„•).NeBot`ï¼Œå®ƒçŸ¥é“å‰æ¨ä¸€ä¸ªéå¹³å‡¡è¿‡æ»¤å™¨ä¼šå¾—åˆ°ä¸€ä¸ªéå¹³å‡¡è¿‡æ»¤å™¨ã€‚å› æ­¤ï¼Œå‡è®¾`[F.NeBot]`çš„å¼•ç†å°†è‡ªåŠ¨é€‚ç”¨äºä»»ä½•åºåˆ—`u`çš„`map
    u atTop`ã€‚'
- en: Our tour of the algebraic properties of filters and their relation to limits
    is essentially done, but we have not yet justified our claim to have recaptured
    the usual limit notions. Superficially, it may seem that `Tendsto u atTop (ğ“ xâ‚€)`
    is stronger than the notion of convergence defined in [Section 3.6](C03_Logic.html#sequences-and-convergence)
    because we ask that *every* neighborhood of `xâ‚€` has a preimage belonging to `atTop`,
    whereas the usual definition only requires this for the standard neighborhoods
    `Ioo (xâ‚€ - Îµ) (xâ‚€ + Îµ)`. The key is that, by definition, every neighborhood contains
    such a standard one. This observation leads to the notion of a *filter basis*.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯¹è¿‡æ»¤å™¨ä»£æ•°æ€§è´¨åŠå…¶ä¸æé™å…³ç³»çš„æ¸¸è§ˆåŸºæœ¬ä¸Šå·²ç»å®Œæˆï¼Œä½†æˆ‘ä»¬è¿˜æ²¡æœ‰è¯æ˜æˆ‘ä»¬é‡æ–°æ•è·äº†é€šå¸¸çš„æé™æ¦‚å¿µã€‚è¡¨é¢ä¸Šï¼Œå®ƒå¯èƒ½çœ‹èµ·æ¥`Tendsto u atTop
    (ğ“ xâ‚€)`æ¯”[ç¬¬3.6èŠ‚](C03_Logic.html#sequences-and-convergence)ä¸­å®šä¹‰çš„æ”¶æ•›æ¦‚å¿µæ›´å¼ºï¼Œå› ä¸ºæˆ‘ä»¬è¦æ±‚`xâ‚€`çš„æ¯ä¸ªé‚»åŸŸéƒ½æœ‰ä¸€ä¸ªå±äº`atTop`çš„é€†åƒï¼Œè€Œé€šå¸¸çš„å®šä¹‰åªè¦æ±‚å¯¹äºæ ‡å‡†é‚»åŸŸ`Ioo
    (xâ‚€ - Îµ) (xâ‚€ + Îµ)`ã€‚å…³é”®æ˜¯ï¼Œæ ¹æ®å®šä¹‰ï¼Œæ¯ä¸ªé‚»åŸŸéƒ½åŒ…å«è¿™æ ·çš„æ ‡å‡†é‚»åŸŸã€‚è¿™ä¸ªè§‚å¯Ÿå¯¼è‡´äº†ä¸€ä¸ª*è¿‡æ»¤å™¨åŸº*çš„æ¦‚å¿µã€‚
- en: 'Given `F : Filter X`, a family of sets `s : Î¹ â†’ Set X` is a basis for `F` if
    for every set `U`, we have `U âˆˆ F` if and only if it contains some `s i`. In other
    words, formally speaking, `s` is a basis if it satisfies `âˆ€ U : Set X, U âˆˆ F â†”
    âˆƒ i, s i âŠ† U`. It is even more flexible to consider a predicate on `Î¹` that selects
    only some of the values `i` in the indexing type. In the case of `ğ“ xâ‚€`, we want
    `Î¹` to be `â„`, we write `Îµ` for `i`, and the predicate should select the positive
    values of `Îµ`. So the fact that the sets `IooÂ  (xâ‚€ - Îµ) (xâ‚€ + Îµ)` form a basis
    for the neighborhood topology on `â„` is stated as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç»™å®š`F : Filter X`ï¼Œä¸€ä¸ªé›†åˆæ—`s : Î¹ â†’ Set X`æ˜¯`F`çš„åŸºï¼Œå¦‚æœå¯¹äºæ¯ä¸ªé›†åˆ`U`ï¼Œæˆ‘ä»¬æœ‰`U âˆˆ F`å½“ä¸”ä»…å½“å®ƒåŒ…å«æŸä¸ª`s
    i`ã€‚æ¢å¥è¯è¯´ï¼Œä»å½¢å¼ä¸Šè®²ï¼Œå¦‚æœ`s`æ»¡è¶³`âˆ€ U : Set X, U âˆˆ F â†” âˆƒ i, s i âŠ† U`ï¼Œåˆ™`s`æ˜¯ä¸€ä¸ªåŸºã€‚è€ƒè™‘åœ¨`Î¹`ä¸Šçš„è°“è¯ä»¥ä»…é€‰æ‹©ç´¢å¼•ç±»å‹ä¸­çš„æŸäº›å€¼`i`ï¼Œè¿™ç”šè‡³æ›´åŠ çµæ´»ã€‚åœ¨`ğ“
    xâ‚€`çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¸Œæœ›`Î¹`æ˜¯`â„`ï¼Œæˆ‘ä»¬ç”¨`Îµ`è¡¨ç¤º`i`ï¼Œè°“è¯åº”è¯¥é€‰æ‹©`Îµ`çš„æ­£å€¼ã€‚å› æ­¤ï¼Œé›†åˆ`IooÂ  (xâ‚€ - Îµ) (xâ‚€ + Îµ)`å½¢æˆ`â„`ä¸Šçš„é‚»åŸŸæ‹“æ‰‘çš„åŸºï¼Œå¯ä»¥è¿™æ ·è¡¨è¿°ï¼š'
- en: '[PRE71]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: There is also a nice basis for the filter `atTop`. The lemma `Filter.HasBasis.tendsto_iff`
    allows us to reformulate a statement of the form `Tendsto f F G` given bases for
    `F` and `G`. Putting these pieces together gives us essentially the notion of
    convergence that we used in [Section 3.6](C03_Logic.html#sequences-and-convergence).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºè¿‡æ»¤å™¨`atTop`ä¹Ÿæœ‰ä¸€ä¸ªå¾ˆå¥½çš„åŸºç¡€ã€‚å¼•ç†`Filter.HasBasis.tendsto_iff`å…è®¸æˆ‘ä»¬æ ¹æ®`F`å’Œ`G`çš„åŸºé‡æ–°è¡¨è¿°å½¢å¼ä¸º`Tendsto
    f F G`çš„é™ˆè¿°ã€‚å°†è¿™äº›éƒ¨åˆ†ç»„åˆèµ·æ¥ï¼Œæˆ‘ä»¬åŸºæœ¬ä¸Šå¾—åˆ°äº†æˆ‘ä»¬åœ¨[ç¬¬3.6èŠ‚](C03_Logic.html#sequences-and-convergence)ä¸­ä½¿ç”¨çš„æ”¶æ•›çš„æ¦‚å¿µã€‚
- en: '[PRE72]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We now show how filters facilitate working with properties that hold for sufficiently
    large numbers or for points that are sufficiently close to a given point. In [Section
    3.6](C03_Logic.html#sequences-and-convergence), we were often faced with the situation
    where we knew that some property `P n` holds for sufficiently large `n` and that
    some other property `Q n` holds for sufficiently large `n`. Using `cases` twice
    gave us `N_P` and `N_Q` satisfying `âˆ€ n â‰¥ N_P, P n` and `âˆ€ n â‰¥ N_Q, Q n`. Using
    `set N := max N_P N_Q`, we could eventually prove `âˆ€ n â‰¥ N, P n âˆ§ Q n`. Doing
    this repeatedly becomes tiresome.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å±•ç¤ºå¦‚ä½•ä½¿ç”¨è¿‡æ»¤å™¨ç®€åŒ–å¤„ç†å¯¹äºè¶³å¤Ÿå¤§çš„æ•°å­—æˆ–è¶³å¤Ÿæ¥è¿‘ç»™å®šç‚¹çš„ç‚¹æ‰€æŒæœ‰çš„æ€§è´¨ã€‚åœ¨ [ç¬¬ 3.6 èŠ‚](C03_Logic.html#sequences-and-convergence)
    ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸é‡åˆ°è¿™æ ·çš„æƒ…å†µï¼šæˆ‘ä»¬çŸ¥é“æŸäº›æ€§è´¨ `P n` å¯¹äºè¶³å¤Ÿå¤§çš„ `n` æˆç«‹ï¼Œè€ŒæŸäº›å…¶ä»–æ€§è´¨ `Q n` å¯¹äºè¶³å¤Ÿå¤§çš„ `n` æˆç«‹ã€‚ä½¿ç”¨ `cases`
    ä¸¤æ¬¡ç»™å‡ºäº†æ»¡è¶³ `âˆ€ n â‰¥ N_P, P n` å’Œ `âˆ€ n â‰¥ N_Q, Q n` çš„ `N_P` å’Œ `N_Q`ã€‚ä½¿ç”¨ `set N := max N_P
    N_Q`ï¼Œæˆ‘ä»¬æœ€ç»ˆå¯ä»¥è¯æ˜ `âˆ€ n â‰¥ N, P n âˆ§ Q n`ã€‚é‡å¤è¿™æ ·åšä¼šå˜å¾—ä»¤äººåŒçƒ¦ã€‚
- en: 'We can do better by noting that the statement â€œ`P n` and `Q n` hold for large
    enough `n`â€ means that we have `{n | P n} âˆˆ atTop` and `{n | Q n} âˆˆ atTop`. The
    fact that `atTop` is a filter implies that the intersection of two elements of
    `atTop` is again in `atTop`, so we have `{n | P n âˆ§ Q n} âˆˆ atTop`. Writing `{n
    | P n} âˆˆ atTop` is unpleasant, but we can use the more suggestive notation `âˆ€á¶ 
    n in atTop, P n`. Here the superscripted `f` stands for â€œFilter.â€ You can think
    of the notation as saying that for all `n` in the â€œset of very large numbers,â€
    `P n` holds. The `âˆ€á¶ ` notation stands for `Filter.Eventually`, and the lemma `Filter.Eventually.and`
    uses the intersection property of filters to do what we just described:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡æ³¨æ„åˆ°é™ˆè¿°â€œ`P n` å’Œ `Q n` å¯¹äºè¶³å¤Ÿå¤§çš„ `n` æˆç«‹â€æ„å‘³ç€æˆ‘ä»¬æ‹¥æœ‰ `{n | P n} âˆˆ atTop` å’Œ `{n | Q n}
    âˆˆ atTop`ï¼Œæˆ‘ä»¬å¯ä»¥åšå¾—æ›´å¥½ã€‚`atTop` æ˜¯ä¸€ä¸ªè¿‡æ»¤å™¨çš„äº‹å®æ„å‘³ç€ `atTop` ä¸­ä¸¤ä¸ªå…ƒç´ çš„äº¤é›†å†æ¬¡åœ¨ `atTop` ä¸­ï¼Œå› æ­¤æˆ‘ä»¬å¾—åˆ° `{n
    | P n âˆ§ Q n} âˆˆ atTop`ã€‚å†™ä½œ `{n | P n} âˆˆ atTop` æ˜¯ä¸æ„‰å¿«çš„ï¼Œä½†æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ›´å…·è¯´æ˜æ€§çš„è®°æ³• `âˆ€á¶  n in atTop,
    P n`ã€‚è¿™é‡Œçš„ä¸Šæ ‡ `f` ä»£è¡¨â€œè¿‡æ»¤å™¨â€ã€‚ä½ å¯ä»¥å°†è¿™ç§è®°æ³•è§†ä¸ºå¯¹äºæ‰€æœ‰åœ¨â€œéå¸¸å¤§çš„æ•°å­—é›†åˆâ€ä¸­çš„ `n`ï¼Œ`P n` æˆç«‹ã€‚`âˆ€á¶ ` è®°å·ä»£è¡¨ `Filter.Eventually`ï¼Œè€Œ
    `Filter.Eventually.and` å¼•ç†ä½¿ç”¨è¿‡æ»¤å™¨çš„äº¤é›†å±æ€§æ¥å®Œæˆæˆ‘ä»¬åˆšæ‰æè¿°çš„å·¥ä½œï¼š
- en: '[PRE73]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This notation is so convenient and intuitive that we also have specializations
    when `P` is an equality or inequality statement. For example, let `u` and `v`
    be two sequences of real numbers, and let us show that if `u n` and `v n` coincide
    for sufficiently large `n` then `u` tends to `xâ‚€` if and only if `v` tends to
    `xâ‚€`. First weâ€™ll use the generic `Eventually` and then the one specialized for
    the equality predicate, `EventuallyEq`. The two statements are definitionally
    equivalent so the same proof work in both cases.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§è®°æ³•æ—¢æ–¹ä¾¿åˆç›´è§‚ï¼Œå› æ­¤å½“ `P` æ˜¯ä¸€ä¸ªç­‰å¼æˆ–ä¸ç­‰å¼é™ˆè¿°æ—¶ï¼Œæˆ‘ä»¬ä¹Ÿæœ‰ç‰¹æ®Šçš„å¤„ç†ã€‚ä¾‹å¦‚ï¼Œè®¾ `u` å’Œ `v` æ˜¯ä¸¤ä¸ªå®æ•°åºåˆ—ï¼Œè®©æˆ‘ä»¬è¯æ˜å¦‚æœ `u
    n` å’Œ `v n` åœ¨è¶³å¤Ÿå¤§çš„ `n` ä¸Šç›¸åŒï¼Œé‚£ä¹ˆ `u` è¶‹äº `xâ‚€` å½“ä¸”ä»…å½“ `v` è¶‹äº `xâ‚€`ã€‚é¦–å…ˆæˆ‘ä»¬å°†ä½¿ç”¨é€šç”¨çš„ `Eventually`ï¼Œç„¶åä½¿ç”¨ä¸“é—¨é’ˆå¯¹ç­‰ä»·è°“è¯çš„
    `EventuallyEq`ã€‚è¿™ä¸¤ä¸ªé™ˆè¿°åœ¨å®šä¹‰ä¸Šæ˜¯ç­‰ä»·çš„ï¼Œæ‰€ä»¥ä¸¤ç§æƒ…å†µä¸‹éƒ½ä½¿ç”¨ç›¸åŒçš„è¯æ˜å·¥ä½œã€‚
- en: '[PRE74]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'It is instructive to review the definition of filters in terms of `Eventually`.
    Given `F : Filter X`, for any predicates `P` and `Q` on `X`,'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 'é€šè¿‡ `Eventually` æ¥å›é¡¾è¿‡æ»¤å™¨çš„å®šä¹‰æ˜¯æœ‰æ•™è‚²æ„ä¹‰çš„ã€‚ç»™å®š `F : Filter X`ï¼Œå¯¹äº `X` ä¸Šçš„ä»»ä½•è°“è¯ `P` å’Œ `Q`ï¼Œ'
- en: the condition `univ âˆˆ F` ensures `(âˆ€ x, P x) â†’ âˆ€á¶  x in F, P x`,
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¡ä»¶ `univ âˆˆ F` ç¡®ä¿äº† `(âˆ€ x, P x) â†’ âˆ€á¶  x in F, P x`ï¼Œ
- en: the condition `U âˆˆ F â†’ U âŠ† V â†’ V âˆˆ F` ensures `(âˆ€á¶  x in F, P x) â†’ (âˆ€ x, P x
    â†’ Q x) â†’ âˆ€á¶  x in F, Q x`, and
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¡ä»¶ `U âˆˆ F â†’ U âŠ† V â†’ V âˆˆ F` ç¡®ä¿äº† `(âˆ€á¶  x in F, P x) â†’ (âˆ€ x, P x â†’ Q x) â†’ âˆ€á¶  x in
    F, Q x`ï¼Œå¹¶ä¸”
- en: the condition `U âˆˆ F â†’ V âˆˆ F â†’ U âˆ© V âˆˆ F` ensures `(âˆ€á¶  x in F, P x) â†’ (âˆ€á¶  x
    in F, Q x) â†’ âˆ€á¶  x in F, P x âˆ§ Q x`.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¡ä»¶ `U âˆˆ F â†’ V âˆˆ F â†’ U âˆ© V âˆˆ F` ç¡®ä¿äº† `(âˆ€á¶  x in F, P x) â†’ (âˆ€á¶  x in F, Q x) â†’ âˆ€á¶ 
    x in F, P x âˆ§ Q x`ã€‚
- en: '[PRE75]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The second item, corresponding to `Eventually.mono`, supports nice ways of
    using filters, especially when combined with `Eventually.and`. The `filter_upwards`
    tactic allows us to combine them. Compare:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬äºŒé¡¹ï¼Œå¯¹åº”äº `Eventually.mono`ï¼Œæ”¯æŒäº†ä½¿ç”¨è¿‡æ»¤å™¨çš„ä¼˜é›…æ–¹å¼ï¼Œå°¤å…¶æ˜¯åœ¨ä¸ `Eventually.and` ç»“åˆä½¿ç”¨æ—¶ã€‚`filter_upwards`
    ç­–ç•¥å…è®¸æˆ‘ä»¬ç»„åˆå®ƒä»¬ã€‚æ¯”è¾ƒï¼š
- en: '[PRE76]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Readers who know about measure theory will note that the filter `Î¼.ae` of sets
    whose complement has measure zero (aka â€œthe set consisting of almost every pointâ€)
    is not very useful as the source or target of `Tendsto`, but it can be conveniently
    used with `Eventually` to say that a property holds for almost every point.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: äº†è§£æµ‹åº¦ç†è®ºçš„è¯»è€…ä¼šæ³¨æ„åˆ°ï¼Œé›†åˆçš„è¡¥é›†æµ‹åº¦ä¸ºé›¶ï¼ˆå³â€œå‡ ä¹æ¯ä¸ªç‚¹çš„é›†åˆâ€ï¼‰çš„è¿‡æ»¤å™¨ `Î¼.ae` ä½œä¸º `Tendsto` çš„æºæˆ–ç›®æ ‡å¹¶ä¸ååˆ†æœ‰ç”¨ï¼Œä½†å®ƒå¯ä»¥æ–¹ä¾¿åœ°ä¸
    `Eventually` ç»“åˆä½¿ç”¨ï¼Œä»¥è¡¨æ˜æŸä¸ªæ€§è´¨å¯¹å‡ ä¹æ‰€æœ‰ç‚¹éƒ½æˆç«‹ã€‚
- en: 'There is a dual version of `âˆ€á¶  x in F, P x`, which is occasionally useful:
    `âˆƒá¶  x in F, P x` means `{x | Â¬P x} âˆ‰ F`. For example, `âˆƒá¶  n in atTop, P n` means
    there are arbitrarily large `n` such that `P n` holds. The `âˆƒá¶ ` notation stands
    for `Filter.Frequently`.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`âˆ€x âˆˆ F, P x`æœ‰ä¸€ä¸ªå¯¹å¶ç‰ˆæœ¬ï¼Œå¶å°”å¾ˆæœ‰ç”¨ï¼š`âˆƒx âˆˆ F, P x`æ„å‘³ç€`{x | Â¬P x} âˆ‰ F`ã€‚ä¾‹å¦‚ï¼Œ`âˆƒn âˆˆ atTop,
    P n`æ„å‘³ç€å­˜åœ¨ä»»æ„å¤§çš„`n`ä½¿å¾—`P n`æˆç«‹ã€‚`âˆƒx`ç¬¦å·ä»£è¡¨`Filter.Frequently`ã€‚'
- en: 'For a more sophisticated example, consider the following statement about a
    sequence `u`, a set `M`, and a value `x`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºä¸€ä¸ªæ›´å¤æ‚çš„ä¾‹å­ï¼Œè€ƒè™‘ä»¥ä¸‹å…³äºåºåˆ—`u`ã€é›†åˆ`M`å’Œå€¼`x`çš„é™ˆè¿°ï¼š
- en: If `u` converges to `x` and `u n` belongs to `M` for sufficiently large `n`
    then `x` is in the closure of `M`.
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœ`u`æ”¶æ•›åˆ°`x`ä¸”å¯¹äºè¶³å¤Ÿå¤§çš„`n`ï¼Œ`u n`å±äº`M`ï¼Œé‚£ä¹ˆ`x`åœ¨`M`çš„é—­é›†ä¸­ã€‚
- en: 'This can be formalized as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯ä»¥å½¢å¼åŒ–ä¸ºä»¥ä¸‹å†…å®¹ï¼š
- en: '`Tendsto u atTop (ğ“ x) â†’ (âˆ€á¶  n in atTop, u n âˆˆ M) â†’ x âˆˆ closure M`.'
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Tendsto u atTop (ğ“ x) â†’ (âˆ€x âˆˆ atTop, u n âˆˆ M) â†’ x âˆˆ closure M`ã€‚'
- en: This is a special case of the theorem `mem_closure_of_tendsto` from the topology
    library. See if you can prove it using the quoted lemmas, using the fact that
    `ClusterPt x F` means `(ğ“ x âŠ“ F).NeBot` and that, by definition, the assumption
    `âˆ€á¶  n in atTop, u n âˆˆ M` means `M âˆˆ map u atTop`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æ‹“æ‰‘åº“ä¸­å®šç†`mem_closure_of_tendsto`çš„ä¸€ä¸ªç‰¹ä¾‹ã€‚çœ‹çœ‹ä½ æ˜¯å¦å¯ä»¥ä½¿ç”¨å¼•ç”¨çš„å¼•ç†ï¼Œä½¿ç”¨`ClusterPt x F`è¡¨ç¤º`(ğ“
    x âŠ“ F).NeBot`ä»¥åŠæ ¹æ®å®šä¹‰ï¼Œå‡è®¾`âˆ€x âˆˆ atTop, u n âˆˆ M`æ„å‘³ç€`M âˆˆ map u atTop`æ¥è¯æ˜å®ƒã€‚
- en: '[PRE77]  ## 11.2\. Metric spaces[ïƒ](#metric-spaces "Link to this heading")'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE77]  ## 11.2\. åº¦é‡ç©ºé—´[ïƒ](#metric-spaces "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")'
- en: 'Examples in the previous section focus on sequences of real numbers. In this
    section we will go up a bit in generality and focus on metric spaces. A metric
    space is a type `X` equipped with a distance function `dist : X â†’ X â†’ â„` which
    is a generalization of the function `fun x y â†¦ |x - y|` from the case where `X
    = â„`.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¸Šä¸€èŠ‚ä¸­çš„ä¾‹å­ä¸»è¦å…³æ³¨å®æ•°åºåˆ—ã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†æé«˜ä¸€ç‚¹ä¸€èˆ¬æ€§ï¼Œå¹¶å…³æ³¨åº¦é‡ç©ºé—´ã€‚åº¦é‡ç©ºé—´æ˜¯ä¸€ä¸ªç±»å‹`X`ï¼Œå®ƒé…å¤‡äº†ä¸€ä¸ªè·ç¦»å‡½æ•°`dist : X â†’
    X â†’ â„`ï¼Œè¿™æ˜¯ä»`X = â„`çš„æƒ…å†µä¸‹çš„å‡½æ•°`fun x y â†¦ |x - y|`çš„æ¨å¹¿ã€‚'
- en: Introducing such a space is easy and we will check all properties required from
    the distance function.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: å¼•å…¥è¿™æ ·çš„ç©ºé—´å¾ˆå®¹æ˜“ï¼Œæˆ‘ä»¬å°†æ£€æŸ¥ä»è·ç¦»å‡½æ•°æ‰€éœ€çš„æ‰€æœ‰å±æ€§ã€‚
- en: '[PRE78]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note we also have variants where the distance can be infinite or where `dist
    a b` can be zero without having `a = b` or both. They are called `EMetricSpace`,
    `PseudoMetricSpace` and `PseudoEMetricSpace` respectively (here â€œeâ€ stands for
    â€œextendedâ€).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬è¿˜æœ‰å˜ä½“ï¼Œå…¶ä¸­è·ç¦»å¯ä»¥æ˜¯æ— é™çš„ï¼Œæˆ–è€…`dist a b`å¯ä»¥æ˜¯é›¶ï¼Œè€Œ`a â‰  b`æˆ–ä¸¤è€…éƒ½ä¸æˆç«‹ã€‚å®ƒä»¬åˆ†åˆ«ç§°ä¸º`EMetricSpace`ã€`PseudoMetricSpace`å’Œ`PseudoEMetricSpace`ï¼ˆè¿™é‡Œçš„â€œeâ€ä»£è¡¨â€œæ‰©å±•â€ï¼‰ã€‚
- en: Note that our journey from `â„` to metric spaces jumped over the special case
    of normed spaces that also require linear algebra and will be explained as part
    of the calculus chapter.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬ä»`â„`åˆ°åº¦é‡ç©ºé—´çš„è¿‡ç¨‹è·³è¿‡äº†ä¹Ÿéœ€è¦çº¿æ€§ä»£æ•°çš„ç‰¹æ®Šæƒ…å†µçš„èŒƒç©ºé—´ï¼Œè¿™å°†åœ¨å¾®ç§¯åˆ†ç« èŠ‚ä¸­è§£é‡Šã€‚
- en: 11.2.1\. Convergence and continuity[ïƒ](#convergence-and-continuity "Link to
    this heading")
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1\. æ”¶æ•›æ€§å’Œè¿ç»­æ€§[ïƒ](#convergence-and-continuity "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")
- en: Using distance functions, we can already define convergent sequences and continuous
    functions between metric spaces. They are actually defined in a more general setting
    covered in the next section, but we have lemmas recasting the definition in terms
    of distances.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è·ç¦»å‡½æ•°ï¼Œæˆ‘ä»¬å·²ç»åœ¨åº¦é‡ç©ºé—´ä¹‹é—´å®šä¹‰äº†æ”¶æ•›åºåˆ—å’Œè¿ç»­å‡½æ•°ã€‚å®é™…ä¸Šï¼Œå®ƒä»¬åœ¨ä¸‹ä¸€èŠ‚ä¸­æ›´ä¸€èˆ¬çš„è®¾ç½®ä¸­å®šä¹‰ï¼Œä½†æˆ‘ä»¬æœ‰å¼•ç†å°†å®šä¹‰é‡æ–°è¡¨è¿°ä¸ºè·ç¦»çš„æœ¯è¯­ã€‚
- en: '[PRE79]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: A *lot* of lemmas have some continuity assumptions, so we end up proving a lot
    of continuity results and there is a `continuity` tactic devoted to this task.
    Letâ€™s prove a continuity statement that will be needed in an exercise below. Notice
    that Lean knows how to treat a product of two metric spaces as a metric space,
    so it makes sense to consider continuous functions from `X Ã— X` to `â„`. In particular
    the (uncurried version of the) distance function is such a function.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: è®¸å¤šå¼•ç†éƒ½æœ‰ä¸€äº›è¿ç»­æ€§å‡è®¾ï¼Œæ‰€ä»¥æˆ‘ä»¬æœ€ç»ˆè¯æ˜äº†è®¸å¤šè¿ç»­æ€§ç»“æœï¼Œå¹¶ä¸”æœ‰ä¸€ä¸ªä¸“é—¨ç”¨äºè¿™ä¸ªä»»åŠ¡çš„`è¿ç»­æ€§`ç­–ç•¥ã€‚è®©æˆ‘ä»¬è¯æ˜ä¸€ä¸ªåœ¨ä¸‹é¢çš„ç»ƒä¹ ä¸­éœ€è¦çš„è¿ç»­æ€§é™ˆè¿°ã€‚æ³¨æ„ï¼ŒLeançŸ¥é“å¦‚ä½•å°†ä¸¤ä¸ªåº¦é‡ç©ºé—´çš„äº§å“è§†ä¸ºåº¦é‡ç©ºé—´ï¼Œå› æ­¤è€ƒè™‘ä»`X
    Ã— X`åˆ°`â„`çš„è¿ç»­å‡½æ•°æ˜¯æœ‰æ„ä¹‰çš„ã€‚ç‰¹åˆ«æ˜¯ï¼ˆæœªå±•å¼€çš„ï¼‰è·ç¦»å‡½æ•°æ˜¯è¿™æ ·çš„å‡½æ•°ã€‚
- en: '[PRE80]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This tactic is a bit slow, so it is also useful to know how to do it by hand.
    We first need to use that `fun p : X Ã— X â†¦ f p.1` is continuous because it is
    the composition of `f`, which is continuous by assumption `hf`, and the projection
    `prod.fst` whose continuity is the content of the lemma `continuous_fst`. The
    composition property is `Continuous.comp` which is in the `Continuous` namespace
    so we can use dot notation to compress `Continuous.comp hf continuous_fst` into
    `hf.comp continuous_fst` which is actually more readable since it really reads
    as composing our assumption and our lemma. We can do the same for the second component
    to get continuity of `fun p : X Ã— X â†¦ f p.2`. We then assemble those two continuities
    using `Continuous.prod_mk` to get `(hf.comp continuous_fst).prod_mk (hf.comp continuous_snd)
    : Continuous (fun p : X Ã— X â†¦ (f p.1, f p.2))` and compose once more to get our
    full proof.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 'è¿™ä¸ªç­–ç•¥æœ‰ç‚¹æ…¢ï¼Œå› æ­¤äº†è§£å¦‚ä½•æ‰‹åŠ¨å®Œæˆå®ƒä¹Ÿå¾ˆæœ‰ç”¨ã€‚æˆ‘ä»¬é¦–å…ˆéœ€è¦ä½¿ç”¨`fun p : X Ã— X â†¦ f p.1`æ˜¯è¿ç»­çš„ï¼Œå› ä¸ºå®ƒæ˜¯ç”±`f`ï¼ˆæ ¹æ®å‡è®¾`hf`æ˜¯è¿ç»­çš„ï¼‰å’ŒæŠ•å½±`prod.fst`ï¼ˆå…¶è¿ç»­æ€§æ˜¯å¼•ç†`continuous_fst`çš„å†…å®¹ï¼‰ç»„æˆçš„ç»„åˆã€‚ç»„åˆå±æ€§æ˜¯`Continuous.comp`ï¼Œå®ƒåœ¨`Continuous`å‘½åç©ºé—´ä¸­ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç‚¹ç¬¦å·å°†`Continuous.comp
    hf continuous_fst`å‹ç¼©ä¸º`hf.comp continuous_fst`ï¼Œè¿™å®é™…ä¸Šæ›´æ˜“è¯»ï¼Œå› ä¸ºå®ƒçœŸæ­£åœ°è¯»ä½œç»„åˆæˆ‘ä»¬çš„å‡è®¾å’Œæˆ‘ä»¬çš„å¼•ç†ã€‚æˆ‘ä»¬å¯ä»¥å¯¹ç¬¬äºŒä¸ªç»„ä»¶åšåŒæ ·çš„å¤„ç†ï¼Œä»¥å¾—åˆ°`fun
    p : X Ã— X â†¦ f p.2`çš„è¿ç»­æ€§ã€‚ç„¶åæˆ‘ä»¬ä½¿ç”¨`Continuous.prod_mk`å°†è¿™äº›è¿ç»­æ€§ç»„è£…èµ·æ¥ï¼Œå¾—åˆ°`(hf.comp continuous_fst).prod_mk
    (hf.comp continuous_snd) : Continuous (fun p : X Ã— X â†¦ (f p.1, f p.2))`ï¼Œç„¶åå†è¿›è¡Œä¸€æ¬¡ç»„åˆï¼Œä»¥å¾—åˆ°æˆ‘ä»¬çš„å®Œæ•´è¯æ˜ã€‚'
- en: '[PRE81]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The combination of `Continuous.prod_mk` and `continuous_dist` via `Continuous.comp`
    feels clunky, even when heavily using dot notation as above. A more serious issue
    is that this nice proof requires a lot of planning. Lean accepts the above proof
    term because it is a full term proving a statement which is definitionally equivalent
    to our goal, the crucial definition to unfold being that of a composition of functions.
    Indeed our target function `fun p : X Ã— X â†¦ dist (f p.1) (f p.2)` is not presented
    as a composition. The proof term we provided proves continuity of `dist âˆ˜ (fun
    p : X Ã— X â†¦ (f p.1, f p.2))` which happens to be definitionally equal to our target
    function. But if we try to build this proof gradually using tactics starting with
    `apply continuous_dist.comp` then Leanâ€™s elaborator will fail to recognize a composition
    and refuse to apply this lemma. It is especially bad at this when products of
    types are involved.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 'é€šè¿‡`Continuous.comp`å°†`Continuous.prod_mk`å’Œ`continuous_dist`ç»“åˆèµ·æ¥æ„Ÿè§‰æœ‰ç‚¹ç¬¨æ‹™ï¼Œå³ä½¿åƒä¸Šé¢é‚£æ ·å¤§é‡ä½¿ç”¨ç‚¹ç¬¦å·ä¹Ÿæ˜¯å¦‚æ­¤ã€‚ä¸€ä¸ªæ›´ä¸¥é‡çš„é—®é¢˜æ˜¯ï¼Œè¿™ä¸ªæ¼‚äº®çš„è¯æ˜éœ€è¦å¤§é‡çš„è§„åˆ’ã€‚Leanæ¥å—ä¸Šè¿°è¯æ˜é¡¹ï¼Œå› ä¸ºå®ƒæ˜¯ä¸€ä¸ªå®Œæ•´çš„é¡¹ï¼Œè¯æ˜äº†ä¸æˆ‘ä»¬çš„ç›®æ ‡å®šä¹‰ç­‰ä»·çš„è¯´æ³•ï¼Œå…³é”®çš„å®šä¹‰å±•å¼€æ˜¯å‡½æ•°çš„ç»„åˆã€‚ç¡®å®ï¼Œæˆ‘ä»¬çš„ç›®æ ‡å‡½æ•°`fun
    p : X Ã— X â†¦ dist (f p.1) (f p.2)`å¹¶æ²¡æœ‰ä»¥ç»„åˆçš„å½¢å¼å‘ˆç°ã€‚æˆ‘ä»¬æä¾›çš„è¯æ˜é¡¹è¯æ˜äº†`dist âˆ˜ (fun p : X Ã— X
    â†¦ (f p.1, f p.2))`çš„è¿ç»­æ€§ï¼Œè¿™æ°å¥½ä¸æˆ‘ä»¬çš„ç›®æ ‡å‡½æ•°å®šä¹‰ç­‰ä»·ã€‚ä½†å¦‚æœæˆ‘ä»¬å°è¯•ä½¿ç”¨ä»`apply continuous_dist.comp`å¼€å§‹çš„ç­–ç•¥é€æ­¥æ„å»ºè¿™ä¸ªè¯æ˜ï¼ŒLeançš„è¯¦ç»†è¯´æ˜å™¨å°†æ— æ³•è¯†åˆ«ç»„åˆï¼Œå¹¶æ‹’ç»åº”ç”¨è¿™ä¸ªå¼•ç†ã€‚å½“æ¶‰åŠåˆ°ç±»å‹ä¹˜ç§¯æ—¶ï¼Œè¿™ä¸ªé—®é¢˜å°¤å…¶ä¸¥é‡ã€‚'
- en: 'A better lemma to apply here is `Continuous.dist {f g : X â†’ Y} : Continuous
    f â†’ Continuous g â†’ Continuous (fun x â†¦ dist (f x) (g x))` which is nicer to Leanâ€™s
    elaborator and also provides a shorter proof when directly providing a full proof
    term, as can be seen from the following two new proofs of the above statement:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 'è¿™é‡Œåº”ç”¨æ›´å¥½çš„å¼•ç†æ˜¯`Continuous.dist {f g : X â†’ Y} : Continuous f â†’ Continuous g â†’ Continuous
    (fun x â†¦ dist (f x) (g x))`ï¼Œè¿™å¯¹äºLeançš„è¯¦ç»†è¯´æ˜å™¨æ¥è¯´æ›´å‹å¥½ï¼Œå¹¶ä¸”åœ¨ç›´æ¥æä¾›å®Œæ•´çš„è¯æ˜é¡¹æ—¶ä¹Ÿæä¾›äº†æ›´çŸ­çš„è¯æ˜ï¼Œå¦‚ä¸‹é¢çš„ä¸¤ä¸ªæ–°è¯æ˜æ‰€ç¤ºï¼š'
- en: '[PRE82]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Note that, without the elaboration issue coming from composition, another way
    to compress our proof would be to use `Continuous.prod_map` which is sometimes
    useful and gives as an alternate proof term `continuous_dist.comp (hf.prod_map
    hf)` which even shorter to type.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå¦‚æœæ²¡æœ‰æ¥è‡ªç»„åˆçš„è¯¦ç»†è¯´æ˜é—®é¢˜ï¼Œå¦ä¸€ç§å‹ç¼©æˆ‘ä»¬è¯æ˜çš„æ–¹æ³•æ˜¯ä½¿ç”¨`Continuous.prod_map`ï¼Œè¿™åœ¨æŸäº›æƒ…å†µä¸‹å¾ˆæœ‰ç”¨ï¼Œå¹¶æä¾›äº†ä¸€ä¸ªæ›¿ä»£çš„è¯æ˜é¡¹`continuous_dist.comp
    (hf.prod_map hf)`ï¼Œè¿™ç”šè‡³æ›´çŸ­ï¼Œæ›´å®¹æ˜“è¾“å…¥ã€‚
- en: Since it is sad to decide between a version which is better for elaboration
    and a version which is shorter to type, let us wrap this discussion with a last
    bit of compression offered by `Continuous.fst'` which allows to compress `hf.comp
    continuous_fst` to `hf.fst'` (and the same with `snd`) and get our final proof,
    now bordering obfuscation.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºåœ¨æ›´å¥½çš„è¯¦ç»†è¯´æ˜ç‰ˆæœ¬å’Œæ›´çŸ­çš„è¾“å…¥ç‰ˆæœ¬ä¹‹é—´åšå‡ºé€‰æ‹©æ˜¯ä»¤äººæ‚²ä¼¤çš„ï¼Œè®©æˆ‘ä»¬ç”¨`Continuous.fst'`æä¾›çš„æœ€åä¸€ç‚¹å‹ç¼©æ¥ç»“æŸè¿™æ¬¡è®¨è®ºï¼Œå®ƒå…è®¸å°†`hf.comp
    continuous_fst`å‹ç¼©ä¸º`hf.fst'`ï¼ˆä»¥åŠ`snd`ç›¸åŒï¼‰ï¼Œå¹¶å¾—åˆ°æˆ‘ä»¬çš„æœ€ç»ˆè¯æ˜ï¼Œç°åœ¨å‡ ä¹åˆ°äº†éš¾ä»¥ç†è§£çš„ç¨‹åº¦ã€‚
- en: '[PRE83]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Itâ€™s your turn now to prove some continuity lemma. After trying the continuity
    tactic, you will need `Continuous.add`, `continuous_pow` and `continuous_id` to
    do it by hand.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è½®åˆ°ä½ äº†ï¼Œå»è¯æ˜ä¸€äº›è¿ç»­æ€§å¼•ç†ã€‚åœ¨å°è¯•äº†è¿ç»­æ€§ç­–ç•¥ä¹‹åï¼Œä½ éœ€è¦`Continuous.add`ã€`continuous_pow`å’Œ`continuous_id`æ¥æ‰‹åŠ¨å®Œæˆã€‚
- en: '[PRE84]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: So far we saw continuity as a global notion, but one can also define continuity
    at a point.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†è¿ç»­æ€§ä½œä¸ºä¸€ä¸ªå…¨å±€æ¦‚å¿µï¼Œä½†ä¹Ÿå¯ä»¥å®šä¹‰åœ¨ä¸€ç‚¹çš„è¿ç»­æ€§ã€‚
- en: '[PRE85]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 11.2.2\. Balls, open sets and closed sets[ïƒ](#balls-open-sets-and-closed-sets
    "Link to this heading")
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2\. çƒã€å¼€é›†å’Œé—­é›†[ïƒ](#balls-open-sets-and-closed-sets "é“¾æ¥åˆ°æœ¬æ ‡é¢˜")
- en: Once we have a distance function, the most important geometric definitions are
    (open) balls and closed balls.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æˆ‘ä»¬æœ‰äº†è·ç¦»å‡½æ•°ï¼Œæœ€é‡è¦çš„å‡ ä½•å®šä¹‰å°±æ˜¯ï¼ˆå¼€ï¼‰çƒå’Œé—­çƒã€‚
- en: '[PRE86]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Note that r is any real number here, there is no sign restriction. Of course
    some statements do require a radius condition.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè¿™é‡Œçš„ræ˜¯ä»»ä½•å®æ•°ï¼Œæ²¡æœ‰ç¬¦å·é™åˆ¶ã€‚å½“ç„¶ï¼Œä¸€äº›é™ˆè¿°ç¡®å®éœ€è¦åŠå¾„æ¡ä»¶ã€‚
- en: '[PRE87]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Once we have balls, we can define open sets. They are actually defined in a
    more general setting covered in the next section, but we have lemmas recasting
    the definition in terms of balls.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æˆ‘ä»¬æœ‰äº†çƒï¼Œæˆ‘ä»¬å°±å¯ä»¥å®šä¹‰å¼€é›†ã€‚å®é™…ä¸Šï¼Œå®ƒä»¬æ˜¯åœ¨ä¸‹ä¸€èŠ‚ä¸­è®¨è®ºçš„æ›´ä¸€èˆ¬è®¾ç½®ä¸­å®šä¹‰çš„ï¼Œä½†æˆ‘ä»¬æœ‰å¼•ç†å°†å®šä¹‰é‡æ–°è¡¨è¿°ä¸ºçƒçš„å½¢å¼ã€‚
- en: '[PRE88]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Then closed sets are sets whose complement is open. Their important property
    is they are closed under limits. The closure of a set is the smallest closed set
    containing it.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œé—­é›†æ˜¯è¡¥é›†ä¸ºå¼€çš„é›†åˆã€‚å®ƒä»¬çš„é‡è¦æ€§è´¨æ˜¯å®ƒä»¬åœ¨æé™ä¸‹æ˜¯å°é—­çš„ã€‚é›†åˆçš„é—­åŒ…æ˜¯åŒ…å«å®ƒçš„æœ€å°é—­é›†ã€‚
- en: '[PRE89]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Do the next exercise without using mem_closure_iff_seq_limit
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸ä½¿ç”¨mem_closure_iff_seq_limitçš„æƒ…å†µä¸‹å®Œæˆä¸‹ä¸€é¡¹ç»ƒä¹ 
- en: '[PRE90]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Remember from the filters sections that neighborhood filters play a big role
    in Mathlib. In the metric space context, the crucial point is that balls provide
    bases for those filters. The main lemmas here are `Metric.nhds_basis_ball` and
    `Metric.nhds_basis_closedBall` that claim this for open and closed balls with
    positive radius. The center point is an implicit argument so we can invoke `Filter.HasBasis.mem_iff`
    as in the following example.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: è®°ä½ä»è¿‡æ»¤å™¨éƒ¨åˆ†ï¼Œé‚»åŸŸè¿‡æ»¤å™¨åœ¨Mathlibä¸­èµ·ç€é‡è¦ä½œç”¨ã€‚åœ¨åº¦é‡ç©ºé—´çš„æƒ…å†µä¸‹ï¼Œå…³é”®ç‚¹æ˜¯çƒä¸ºè¿™äº›è¿‡æ»¤å™¨æä¾›äº†åŸºã€‚è¿™é‡Œçš„ä¸»è¦å¼•ç†æ˜¯`Metric.nhds_basis_ball`å’Œ`Metric.nhds_basis_closedBall`ï¼Œå®ƒä»¬ä¸ºæ­£åŠå¾„çš„å¼€çƒå’Œé—­çƒå£°æ˜äº†è¿™ä¸€ç‚¹ã€‚ä¸­å¿ƒç‚¹æ˜¯éšå«çš„å‚æ•°ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åƒä»¥ä¸‹ç¤ºä¾‹ä¸­é‚£æ ·è°ƒç”¨`Filter.HasBasis.mem_iff`ã€‚
- en: '[PRE91]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 11.2.3\. Compactness[ïƒ](#compactness "Link to this heading")
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.3\. ç´§è‡´æ€§[ïƒ](#compactness "é“¾æ¥åˆ°æœ¬æ ‡é¢˜")
- en: 'Compactness is an important topological notion. It distinguishes subsets of
    a metric space that enjoy the same kind of properties as segments in the reals
    compared to other intervals:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ç´§è‡´æ€§æ˜¯ä¸€ä¸ªé‡è¦çš„æ‹“æ‰‘æ¦‚å¿µã€‚å®ƒåŒºåˆ†äº†åº¦é‡ç©ºé—´ä¸­å…·æœ‰ä¸å®æ•°çº¿æ®µç›¸åŒæ€§è´¨çš„çœŸå­é›†ä¸å…¶ä»–åŒºé—´ï¼š
- en: Any sequence with values in a compact set has a subsequence that converges in
    this set.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä»»ä½•åœ¨ç´§é›†ä¸Šå–å€¼çš„åºåˆ—éƒ½æœ‰ä¸€ä¸ªå­åºåˆ—åœ¨è¿™ä¸ªé›†åˆä¸­æ”¶æ•›ã€‚
- en: Any continuous function on a nonempty compact set with values in real numbers
    is bounded and attains its bounds somewhere (this is called the extreme value
    theorem).
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä»»ä½•åœ¨éç©ºç´§é›†ä¸Šå®šä¹‰ä¸”å–å€¼ä¸ºå®æ•°çš„è¿ç»­å‡½æ•°éƒ½æ˜¯æœ‰ç•Œçš„ï¼Œå¹¶ä¸”åœ¨å…¶æŸä¸ªåœ°æ–¹è¾¾åˆ°å…¶ç•Œé™ï¼ˆè¿™è¢«ç§°ä¸ºæå€¼å®šç†ï¼‰ã€‚
- en: Compact sets are closed sets.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç´§é›†æ˜¯é—­é›†ã€‚
- en: Let us first check that the unit interval in the reals is indeed a compact set,
    and then check the above claims for compact sets in general metric spaces. In
    the second statement we only need continuity on the given set so we will use `ContinuousOn`
    instead of `Continuous`, and we will give separate statements for the minimum
    and the maximum. Of course all these results are deduced from more general versions,
    some of which will be discussed in later sections.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å…ˆæ£€æŸ¥å®æ•°å•ä½åŒºé—´ç¡®å®æ˜¯ä¸€ä¸ªç´§é›†ï¼Œç„¶åæ£€æŸ¥ä¸€èˆ¬åº¦é‡ç©ºé—´ä¸­ç´§é›†çš„ä¸Šè¿°å‘½é¢˜ã€‚åœ¨ç¬¬äºŒä¸ªå‘½é¢˜ä¸­ï¼Œæˆ‘ä»¬åªéœ€è¦ç»™å®šé›†åˆä¸Šçš„è¿ç»­æ€§ï¼Œå› æ­¤æˆ‘ä»¬å°†ä½¿ç”¨`ContinuousOn`è€Œä¸æ˜¯`Continuous`ï¼Œå¹¶ä¸”æˆ‘ä»¬å°†åˆ†åˆ«ç»™å‡ºæœ€å°å€¼å’Œæœ€å¤§å€¼çš„å•ç‹¬é™ˆè¿°ã€‚å½“ç„¶ï¼Œæ‰€æœ‰è¿™äº›ç»“æœéƒ½æ˜¯ä»æ›´ä¸€èˆ¬çš„ç‰ˆæœ¬ä¸­æ¨å¯¼å‡ºæ¥çš„ï¼Œå…¶ä¸­ä¸€äº›å°†åœ¨åé¢çš„ç« èŠ‚ä¸­è®¨è®ºã€‚
- en: '[PRE92]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We can also specify that a metric spaces is globally compact, using an extra
    `Prop`-valued type class:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å¯ä»¥æŒ‡å®šåº¦é‡ç©ºé—´æ˜¯å…¨å±€ç´§è‡´çš„ï¼Œä½¿ç”¨ä¸€ä¸ªé¢å¤–çš„`Prop`å€¼ç±»å‹ç±»ï¼š
- en: '[PRE93]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: In a compact metric space any closed set is compact, this is `IsClosed.isCompact`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç´§è‡´åº¦é‡ç©ºé—´ä¸­ï¼Œä»»ä½•é—­é›†éƒ½æ˜¯ç´§é›†ï¼Œè¿™æ˜¯`IsClosed.isCompact`ã€‚
- en: 11.2.4\. Uniformly continuous functions[ïƒ](#uniformly-continuous-functions "Link
    to this heading")
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.4\. ä¸€è‡´è¿ç»­å‡½æ•°[ïƒ](#uniformly-continuous-functions "é“¾æ¥åˆ°æœ¬æ ‡é¢˜")
- en: 'We now turn to uniformity notions on metric spaces : uniformly continuous functions,
    Cauchy sequences and completeness. Again those are defined in a more general context
    but we have lemmas in the metric name space to access their elementary definitions.
    We start with uniform continuity.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬è½¬å‘åº¦é‡ç©ºé—´ä¸Šçš„å‡åŒ€æ€§æ¦‚å¿µï¼šä¸€è‡´è¿ç»­å‡½æ•°ã€æŸ¯è¥¿åºåˆ—å’Œå®Œå¤‡æ€§ã€‚è¿™äº›éƒ½æ˜¯åœ¨æ›´ä¸€èˆ¬çš„ç¯å¢ƒä¸­å®šä¹‰çš„ï¼Œä½†æˆ‘ä»¬æœ‰åœ¨åº¦é‡åç§°ç©ºé—´ä¸­çš„å¼•ç†æ¥è®¿é—®å®ƒä»¬çš„å…ƒç´ å®šä¹‰ã€‚æˆ‘ä»¬é¦–å…ˆä»å‡åŒ€è¿ç»­æ€§å¼€å§‹ã€‚
- en: '[PRE94]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: In order to practice manipulating all those definitions, we will prove that
    continuous functions from a compact metric space to a metric space are uniformly
    continuous (we will see a more general version in a later section).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ç»ƒä¹ æ“ä½œæ‰€æœ‰è¿™äº›å®šä¹‰ï¼Œæˆ‘ä»¬å°†è¯æ˜ä»ç´§è‡´åº¦é‡ç©ºé—´åˆ°åº¦é‡ç©ºé—´çš„è¿ç»­å‡½æ•°æ˜¯å‡åŒ€è¿ç»­çš„ï¼ˆæˆ‘ä»¬å°†åœ¨åé¢çš„ç« èŠ‚ä¸­çœ‹åˆ°æ›´ä¸€èˆ¬çš„å½¢å¼ï¼‰ã€‚
- en: 'We will first give an informal sketch. Let `f : X â†’ Y` be a continuous function
    from a compact metric space to a metric space. We fix `Îµ > 0` and start looking
    for some `Î´`.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 'æˆ‘ä»¬é¦–å…ˆç»™å‡ºä¸€ä¸ªéæ­£å¼çš„è‰å›¾ã€‚è®¾ `f : X â†’ Y` æ˜¯ä»ç´§è‡´åº¦é‡ç©ºé—´åˆ°åº¦é‡ç©ºé—´çš„è¿ç»­å‡½æ•°ã€‚æˆ‘ä»¬å›ºå®š `Îµ > 0` å¹¶å¼€å§‹å¯»æ‰¾æŸä¸ª `Î´`ã€‚'
- en: 'Let `Ï† : X Ã— X â†’ â„ := fun p â†¦ dist (f p.1) (f p.2)` and let `K := { p : X Ã—
    X | Îµ â‰¤ Ï† p }`. Observe `Ï†` is continuous since `f` and distance are continuous.
    And `K` is clearly closed (use `isClosed_le`) hence compact since `X` is compact.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 'è®¾ `Ï† : X Ã— X â†’ â„ := fun p â†¦ dist (f p.1) (f p.2)` å’Œ `K := { p : X Ã— X | Îµ â‰¤
    Ï† p }`ã€‚è§‚å¯Ÿ `Ï†` æ˜¯è¿ç»­çš„ï¼Œå› ä¸º `f` å’Œè·ç¦»éƒ½æ˜¯è¿ç»­çš„ã€‚è€Œä¸” `K` æ˜¾ç„¶æ˜¯é—­é›†ï¼ˆä½¿ç”¨ `isClosed_le`ï¼‰ï¼Œå› æ­¤ `X` æ˜¯ç´§è‡´çš„ã€‚'
- en: Then we discuss two possibilities using `eq_empty_or_nonempty`. If `K` is empty
    then we are clearly done (we can set `Î´ = 1` for instance). So letâ€™s assume `K`
    is not empty, and use the extreme value theorem to choose `(xâ‚€, xâ‚)` attaining
    the infimum of the distance function on `K`. We can then set `Î´ = dist xâ‚€ xâ‚`
    and check everything works.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬ä½¿ç”¨ `eq_empty_or_nonempty` è®¨è®ºä¸¤ç§å¯èƒ½æ€§ã€‚å¦‚æœ `K` æ˜¯ç©ºçš„ï¼Œé‚£ä¹ˆæ˜¾ç„¶æˆ‘ä»¬å·²ç»å®Œæˆäº†ï¼ˆä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥å°† `Î´` è®¾ç½®ä¸º
    `1`ï¼‰ã€‚æ‰€ä»¥è®©æˆ‘ä»¬å‡è®¾ `K` ä¸æ˜¯ç©ºçš„ï¼Œå¹¶ä½¿ç”¨æå€¼å®šç†æ¥é€‰æ‹© `(xâ‚€, xâ‚)`ï¼Œå®ƒè¾¾åˆ°è·ç¦»å‡½æ•°åœ¨ `K` ä¸Šçš„ä¸‹ç¡®ç•Œã€‚ç„¶åæˆ‘ä»¬å¯ä»¥å°† `Î´` è®¾ç½®ä¸º
    `dist xâ‚€ xâ‚` å¹¶æ£€æŸ¥ä¸€åˆ‡æ˜¯å¦æ­£å¸¸å·¥ä½œã€‚
- en: '[PRE95]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 11.2.5\. Completeness[ïƒ](#completeness "Link to this heading")
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.5\. å®Œå¤‡æ€§[ïƒ](#completeness "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")
- en: A Cauchy sequence in a metric space is a sequence whose terms get closer and
    closer to each other. There are a couple of equivalent ways to state that idea.
    In particular converging sequences are Cauchy. The converse is true only in so-called
    *complete* spaces.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨åº¦é‡ç©ºé—´ä¸­ï¼ŒæŸ¯è¥¿åºåˆ—æ˜¯ä¸€ä¸ªå…¶é¡¹å½¼æ­¤è¶Šæ¥è¶Šæ¥è¿‘çš„åºåˆ—ã€‚æœ‰å‡ ç§ç­‰ä»·çš„æ–¹å¼æ¥è¡¨è¿°è¿™ä¸ªæƒ³æ³•ã€‚ç‰¹åˆ«æ˜¯æ”¶æ•›åºåˆ—æ˜¯æŸ¯è¥¿åºåˆ—ã€‚é€†å‘½é¢˜åªåœ¨æ‰€è°“çš„ *å®Œå¤‡* ç©ºé—´ä¸­æˆç«‹ã€‚
- en: '[PRE96]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Weâ€™ll practice using this definition by proving a convenient criterion which
    is a special case of a criterion appearing in Mathlib. This is also a good opportunity
    to practice using big sums in a geometric context. In addition to the explanations
    from the filters section, you will probably need `tendsto_pow_atTop_nhds_zero_of_lt_one`,
    `Tendsto.mul` and `dist_le_range_sum_dist`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†é€šè¿‡è¯æ˜ä¸€ä¸ªæ–¹ä¾¿çš„åˆ¤æ®æ¥ç»ƒä¹ ä½¿ç”¨è¿™ä¸ªå®šä¹‰ï¼Œè¿™ä¸ªåˆ¤æ®æ˜¯ Mathlib ä¸­å‡ºç°çš„ä¸€ä¸ªåˆ¤æ®çš„ç‰¹æ®Šæƒ…å†µã€‚è¿™ä¹Ÿæ˜¯ç»ƒä¹ åœ¨å‡ ä½•ç¯å¢ƒä¸­ä½¿ç”¨å¤§å’Œçš„å¥½æœºä¼šã€‚é™¤äº†è¿‡æ»¤å™¨éƒ¨åˆ†çš„è§£é‡Šå¤–ï¼Œä½ å¯èƒ½è¿˜éœ€è¦
    `tendsto_pow_atTop_nhds_zero_of_lt_one`ã€`Tendsto.mul` å’Œ `dist_le_range_sum_dist`ã€‚
- en: '[PRE97]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We are ready for the final boss of this section: Baireâ€™s theorem for complete
    metric spaces! The proof skeleton below shows interesting techniques. It uses
    the `choose` tactic in its exclamation mark variant (you should experiment with
    removing this exclamation mark) and it shows how to define something inductively
    in the middle of a proof using `Nat.rec_on`.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»å‡†å¤‡å¥½æœ¬èŠ‚çš„æœ€ç»ˆæŒ‘æˆ˜ï¼šå®Œå¤‡åº¦é‡ç©ºé—´çš„ Baire å®šç†ï¼ä¸‹é¢çš„è¯æ˜æ¡†æ¶å±•ç¤ºäº†æœ‰è¶£çš„æŠ€æœ¯ã€‚å®ƒä½¿ç”¨äº†æ„Ÿå¹å·å˜ä½“çš„ `choose` ç­–ç•¥ï¼ˆä½ åº”è¯¥å°è¯•ç§»é™¤è¿™ä¸ªæ„Ÿå¹å·ï¼‰å¹¶å±•ç¤ºäº†å¦‚ä½•åœ¨è¯æ˜ä¸­ä½¿ç”¨
    `Nat.rec_on` é€’å½’åœ°å®šä¹‰æŸç‰©ã€‚
- en: '[PRE98]  ## 11.3\. Topological spaces[ïƒ](#topological-spaces "Link to this
    heading")'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE98]  ## 11.3\. æ‹“æ‰‘ç©ºé—´[ïƒ](#topological-spaces "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")'
- en: 11.3.1\. Fundamentals[ïƒ](#fundamentals "Link to this heading")
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1\. åŸºç¡€[ïƒ](#fundamentals "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")
- en: We now go up in generality and introduce topological spaces. We will review
    the two main ways to define topological spaces and then explain how the category
    of topological spaces is much better behaved than the category of metric spaces.
    Note that we wonâ€™t be using Mathlib category theory here, only having a somewhat
    categorical point of view.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æé«˜ä¸€èˆ¬æ€§ï¼Œå¼•å…¥æ‹“æ‰‘ç©ºé—´ã€‚æˆ‘ä»¬å°†å›é¡¾å®šä¹‰æ‹“æ‰‘ç©ºé—´çš„ä¸¤ç§ä¸»è¦æ–¹æ³•ï¼Œç„¶åè§£é‡Šæ‹“æ‰‘ç©ºé—´èŒƒç•´æ¯”åº¦é‡ç©ºé—´èŒƒç•´è¡¨ç°å¾—æ›´å¥½ã€‚è¯·æ³¨æ„ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œä¸ä¼šä½¿ç”¨ Mathlib
    èŒƒç•´è®ºï¼Œè€Œåªæ˜¯æ‹¥æœ‰æŸç§èŒƒç•´æ€§çš„è§‚ç‚¹ã€‚
- en: The first way to think about the transition from metric spaces to topological
    spaces is that we only remember the notion of open sets (or equivalently the notion
    of closed sets). From this point of view, a topological space is a type equipped
    with a collection of sets that are called open sets. This collection has to satisfy
    a number of axioms presented below (this collection is slightly redundant but
    we will ignore that).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘ä»åº¦é‡ç©ºé—´åˆ°æ‹“æ‰‘ç©ºé—´çš„è¿‡æ¸¡çš„ç¬¬ä¸€ç§æ–¹æ³•æ˜¯ï¼Œæˆ‘ä»¬åªè®°ä½å¼€é›†ï¼ˆæˆ–ç­‰ä»·åœ°é—­é›†ï¼‰çš„æ¦‚å¿µã€‚ä»è¿™ä¸ªè§’åº¦æ¥çœ‹ï¼Œæ‹“æ‰‘ç©ºé—´æ˜¯ä¸€ç§ç±»å‹ï¼Œå®ƒé…å¤‡äº†ä¸€ç»„ç§°ä¸ºå¼€é›†çš„é›†åˆã€‚è¿™ä¸ªé›†åˆå¿…é¡»æ»¡è¶³ä¸‹é¢æå‡ºçš„è‹¥å¹²å…¬ç†ï¼ˆè¿™ä¸ªé›†åˆç•¥å¾®å†—ä½™ï¼Œä½†æˆ‘ä»¬å°†å¿½ç•¥è¿™ä¸€ç‚¹ï¼‰ã€‚
- en: '[PRE99]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Closed sets are then defined as sets whose complement is open. A function between
    topological spaces is (globally) continuous if all preimages of open sets are
    open.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: é—­é›†å®šä¹‰ä¸ºè¡¥é›†æ˜¯å¼€é›†çš„é›†åˆã€‚åœ¨æ‹“æ‰‘ç©ºé—´ä¹‹é—´çš„å‡½æ•°ï¼ˆå…¨å±€ï¼‰è¿ç»­ï¼Œå¦‚æœæ‰€æœ‰å¼€é›†çš„å‰åƒéƒ½æ˜¯å¼€é›†ã€‚
- en: '[PRE100]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'With this definition we already see that, compared to metric spaces, topological
    spaces only remember enough information to talk about continuous functions: two
    topological structures on a type are the same if and only if they have the same
    continuous functions (indeed the identity function will be continuous in both
    direction if and only if the two structures have the same open sets).'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 'é€šè¿‡è¿™ä¸ªå®šä¹‰ï¼Œæˆ‘ä»¬å·²çœ‹åˆ°ï¼Œä¸åº¦é‡ç©ºé—´ç›¸æ¯”ï¼Œæ‹“æ‰‘ç©ºé—´åªä¿ç•™è¶³å¤Ÿçš„ä¿¡æ¯æ¥è®¨è®ºè¿ç»­å‡½æ•°ï¼šä¸€ä¸ªç±»å‹ä¸Šçš„ä¸¤ä¸ªæ‹“æ‰‘ç»“æ„ç›¸åŒï¼Œå½“ä¸”ä»…å½“å®ƒä»¬å…·æœ‰ç›¸åŒçš„è¿ç»­å‡½æ•°ï¼ˆå®é™…ä¸Šï¼Œå¦‚æœä¸¤ä¸ªç»“æ„å…·æœ‰ç›¸åŒçš„å¼€é›†ï¼Œæ’ç­‰å‡½æ•°åœ¨ä¸¤ä¸ªæ–¹å‘ä¸Šéƒ½å°†è¿ç»­ï¼‰ã€‚ '
- en: 'However as soon as we move on to continuity at a point we see the limitations
    of the approach based on open sets. In Mathlib we frequently think of topological
    spaces as types equipped with a neighborhood filter `ğ“ x` attached to each point
    `x` (the corresponding function `X â†’ Filter X` satisfies certain conditions explained
    further down). Remember from the filters section that these gadgets play two related
    roles. First `ğ“ x` is seen as the generalized set of points of `X` that are close
    to `x`. And then it is seen as giving a way to say, for any predicate `P : X â†’
    Prop`, that this predicate holds for points that are close enough to `x`. Let
    us state that `f : X â†’ Y` is continuous at `x`. The purely filtery way is to say
    that the direct image under `f` of the generalized set of points that are close
    to `x` is contained in the generalized set of points that are close to `f x`.
    Recall this is spelled either `map f (ğ“ x) â‰¤ ğ“ (f x)` or `Tendsto f (ğ“ x) (ğ“ (f
    x))`.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç„¶è€Œï¼Œä¸€æ—¦æˆ‘ä»¬è½¬å‘ç‚¹çš„è¿ç»­æ€§ï¼Œæˆ‘ä»¬å°±çœ‹åˆ°äº†åŸºäºå¼€é›†çš„æ–¹æ³•çš„å±€é™æ€§ã€‚åœ¨Mathlibä¸­ï¼Œæˆ‘ä»¬ç»å¸¸å°†æ‹“æ‰‘ç©ºé—´è§†ä¸ºå¸¦æœ‰é™„åŠ åœ¨æ¯ä¸ªç‚¹`x`ä¸Šçš„é‚»åŸŸæ»¤æ³¢å™¨`ğ“
    x`çš„ç±»å‹ï¼ˆç›¸åº”çš„å‡½æ•°`X â†’ Filter X`æ»¡è¶³æŸäº›æ¡ä»¶ï¼Œè¿™äº›æ¡ä»¶å°†åœ¨ä¸‹é¢è¿›ä¸€æ­¥è§£é‡Šï¼‰ã€‚è®°ä½ä»æ»¤æ³¢å™¨éƒ¨åˆ†ï¼Œè¿™äº›å°ç©æ„å„¿æ‰®æ¼”ä¸¤ä¸ªç›¸å…³çš„è§’è‰²ã€‚é¦–å…ˆï¼Œ`ğ“
    x`è¢«è§†ä¸ºæ¥è¿‘`x`çš„`X`ä¸­ç‚¹çš„å¹¿ä¹‰é›†åˆã€‚ç„¶åï¼Œå®ƒè¢«è§†ä¸ºä¸ºä»»ä½•è°“è¯`P : X â†’ Prop`æä¾›ä¸€ç§æ–¹å¼ï¼Œå³è¿™ä¸ªè°“è¯å¯¹è¶³å¤Ÿæ¥è¿‘`x`çš„ç‚¹æˆç«‹ã€‚è®©æˆ‘ä»¬å£°æ˜`f
    : X â†’ Y`åœ¨`x`å¤„æ˜¯è¿ç»­çš„ã€‚çº¯ç²¹åŸºäºæ»¤æ³¢å™¨çš„æ–¹å¼æ˜¯è¯´ï¼Œåœ¨`f`çš„ç›´æ¥åƒä¸‹ï¼Œæ¥è¿‘`x`çš„ç‚¹çš„å¹¿ä¹‰é›†åˆåŒ…å«åœ¨æ¥è¿‘`f x`çš„ç‚¹çš„å¹¿ä¹‰é›†åˆä¸­ã€‚å›æƒ³ä¸€ä¸‹ï¼Œè¿™å¯ä»¥è¡¨ç¤ºä¸º`map
    f (ğ“ x) â‰¤ ğ“ (f x)`æˆ–`Tendsto f (ğ“ x) (ğ“ (f x))`ã€‚'
- en: '[PRE101]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'One can also spell it using both neighborhoods seen as ordinary sets and a
    neighborhood filter seen as a generalized set: â€œfor any neighborhood `U` of `f
    x`, all points close to `x` are sent to `U`â€. Note that the proof is again `Iff.rfl`,
    this point of view is definitionally equivalent to the previous one.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹Ÿå¯ä»¥ä½¿ç”¨ä¸¤ç§é‚»åŸŸï¼ˆè§†ä¸ºæ™®é€šé›†åˆï¼‰å’Œä¸€ç§é‚»åŸŸæ»¤æ³¢å™¨ï¼ˆè§†ä¸ºå¹¿ä¹‰é›†åˆï¼‰æ¥è¡¨è¿°ï¼šå¯¹äº`f x`çš„ä»»ä½•é‚»åŸŸ`U`ï¼Œæ‰€æœ‰æ¥è¿‘`x`çš„ç‚¹éƒ½è¢«å‘é€åˆ°`U`ã€‚è¯·æ³¨æ„ï¼Œè¯æ˜ä»ç„¶æ˜¯`Iff.rfl`ï¼Œè¿™ç§è§‚ç‚¹åœ¨å®šä¹‰ä¸Šæ˜¯ç­‰åŒäºå‰ä¸€ç§çš„ã€‚
- en: '[PRE102]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: We now explain how to go from one point of view to the other. In terms of open
    sets, we can simply define members of `ğ“ x` as sets that contain an open set containing
    `x`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬è§£é‡Šå¦‚ä½•ä»ä¸€ä¸ªè§‚ç‚¹è½¬åˆ°å¦ä¸€ä¸ªè§‚ç‚¹ã€‚ä»å¼€é›†çš„è§’åº¦æ¥çœ‹ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•åœ°å®šä¹‰`ğ“ x`çš„æˆå‘˜ä¸ºåŒ…å«`x`çš„æŸä¸ªå¼€é›†çš„é›†åˆã€‚
- en: '[PRE103]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'To go in the other direction we need to discuss the condition that `ğ“ : X â†’
    Filter X` must satisfy in order to be the neighborhood function of a topology.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 'è¦æœç›¸åçš„æ–¹å‘è¿›è¡Œï¼Œæˆ‘ä»¬éœ€è¦è®¨è®º`ğ“ : X â†’ Filter X`å¿…é¡»æ»¡è¶³çš„æ¡ä»¶ï¼Œä»¥ä¾¿æˆä¸ºæ‹“æ‰‘çš„é‚»åŸŸå‡½æ•°ã€‚'
- en: The first constraint is that `ğ“ x`, seen as a generalized set, contains the
    set `{x}` seen as the generalized set `pure x` (explaining this weird name would
    be too much of a digression, so we simply accept it for now). Another way to say
    it is that if a predicate holds for points close to `x` then it holds at `x`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ä¸ªçº¦æŸæ˜¯ï¼Œå°†`ğ“ x`è§†ä¸ºä¸€ä¸ªå¹¿ä¹‰é›†åˆæ—¶ï¼Œå®ƒåŒ…å«å°†`{x}`è§†ä¸ºå¹¿ä¹‰é›†åˆ`çº¯ x`çš„é›†åˆï¼ˆè§£é‡Šè¿™ä¸ªå¥‡æ€ªçš„åå­—ä¼šå¤ªåˆ†æ•£æ³¨æ„åŠ›ï¼Œæ‰€ä»¥æˆ‘ä»¬ç°åœ¨ç®€å•åœ°æ¥å—å®ƒï¼‰ã€‚å¦ä¸€ç§è¯´æ³•æ˜¯ï¼Œå¦‚æœä¸€ä¸ªè°“è¯åœ¨`x`é™„è¿‘çš„ç‚¹æˆç«‹ï¼Œé‚£ä¹ˆå®ƒåœ¨`x`å¤„ä¹Ÿæˆç«‹ã€‚
- en: '[PRE104]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Then a more subtle requirement is that, for any predicate `P : X â†’ Prop` and
    any `x`, if `P y` holds for `y` close to `x` then for `y` close to `x` and `z`
    close to `y`, `P z` holds. More precisely we have:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç„¶åï¼Œä¸€ä¸ªæ›´å¾®å¦™çš„è¦æ±‚æ˜¯ï¼Œå¯¹äºä»»ä½•è°“è¯`P : X â†’ Prop`å’Œä»»ä½•`x`ï¼Œå¦‚æœ`P y`åœ¨`y`æ¥è¿‘`x`æ—¶æˆç«‹ï¼Œé‚£ä¹ˆå¯¹äºæ¥è¿‘`x`å’Œ`y`çš„`z`ï¼Œ`P
    z`ä¹Ÿæˆç«‹ã€‚æ›´ç²¾ç¡®åœ°è¯´ï¼Œæˆ‘ä»¬æœ‰ï¼š'
- en: '[PRE105]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Those two results characterize the functions `X â†’ Filter X` that are neighborhood
    functions for a topological space structure on `X`. There is a still a function
    `TopologicalSpace.mkOfNhds : (X â†’ Filter X) â†’ TopologicalSpace X` but it will
    give back its input as a neighborhood function only if it satisfies the above
    two constraints. More precisely we have a lemma `TopologicalSpace.nhds_mkOfNhds`
    saying that in a different way and our next exercise deduces this different way
    from how we stated it above.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 'è¿™ä¸¤ä¸ªç»“æœæè¿°äº†å‡½æ•° `X â†’ Filter X`ï¼Œå®ƒä»¬æ˜¯ `X` ä¸Šæ‹“æ‰‘ç©ºé—´ç»“æ„çš„é‚»åŸŸå‡½æ•°ã€‚ä»ç„¶å­˜åœ¨ä¸€ä¸ªå‡½æ•° `TopologicalSpace.mkOfNhds
    : (X â†’ Filter X) â†’ TopologicalSpace X`ï¼Œä½†å®ƒåªæœ‰åœ¨æ»¡è¶³ä¸Šè¿°ä¸¤ä¸ªçº¦æŸçš„æƒ…å†µä¸‹æ‰ä¼šå°†å…¶è¾“å…¥ä½œä¸ºé‚»åŸŸå‡½æ•°è¿”å›ã€‚æ›´ç²¾ç¡®åœ°è¯´ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªå¼•ç†
    `TopologicalSpace.nhds_mkOfNhds`ï¼Œå®ƒä»¥ä¸åŒçš„æ–¹å¼è¡¨è¿°ï¼Œè€Œæˆ‘ä»¬çš„ä¸‹ä¸€ä¸ªç»ƒä¹ å°†ä»æˆ‘ä»¬ä¸Šè¿°çš„è¡¨è¿°ä¸­æ¨å¯¼å‡ºè¿™ç§ä¸åŒæ–¹å¼ã€‚'
- en: '[PRE106]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Note that `TopologicalSpace.mkOfNhds` is not so frequently used, but it still
    good to know in what precise sense the neighborhood filters is all there is in
    a topological space structure.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œ`TopologicalSpace.mkOfNhds` å¹¶ä¸ç»å¸¸ä½¿ç”¨ï¼Œä½†äº†è§£åœ¨æ‹“æ‰‘ç©ºé—´ç»“æ„ä¸­é‚»åŸŸè¿‡æ»¤å™¨ç©¶ç«Ÿæ„å‘³ç€ä»€ä¹ˆä»ç„¶æ˜¯å¾ˆå¥½çš„ã€‚
- en: 'The next thing to know in order to efficiently use topological spaces in Mathlib
    is that we use a lot of formal properties of `TopologicalSpace : Type u â†’ Type
    u`. From a purely mathematical point of view, those formal properties are a very
    clean way to explain how topological spaces solve issues that metric spaces have.
    From this point of view, the issues solved by topological spaces is that metric
    spaces enjoy very little functoriality, and have very bad categorical properties
    in general. This comes on top of the fact already discussed that metric spaces
    contain a lot of geometrical information that is not topologically relevant.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¸ºäº†æœ‰æ•ˆåœ°åœ¨ Mathlib ä¸­ä½¿ç”¨æ‹“æ‰‘ç©ºé—´ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“çš„æ˜¯ï¼Œæˆ‘ä»¬ä½¿ç”¨äº† `TopologicalSpace : Type u â†’ Type u`
    çš„è®¸å¤šå½¢å¼æ€§è´¨ã€‚ä»çº¯ç²¹æ•°å­¦çš„è§’åº¦æ¥çœ‹ï¼Œè¿™äº›å½¢å¼æ€§è´¨æ˜¯è§£é‡Šæ‹“æ‰‘ç©ºé—´å¦‚ä½•è§£å†³åº¦é‡ç©ºé—´é—®é¢˜çš„éå¸¸å¹²å‡€çš„æ–¹æ³•ã€‚ä»è¿™ä¸ªè§’åº¦æ¥çœ‹ï¼Œæ‹“æ‰‘ç©ºé—´è§£å†³çš„é—®é¢˜åœ¨äºåº¦é‡ç©ºé—´å‡ ä¹ä¸å…·æœ‰å‡½å­æ€§ï¼Œå¹¶ä¸”åœ¨ä¸€èˆ¬ä¸Šå…·æœ‰å¾ˆå·®çš„èŒƒç•´æ€§è´¨ã€‚è¿™è¿˜åŸºäºå·²ç»è®¨è®ºçš„äº‹å®ï¼Œå³åº¦é‡ç©ºé—´åŒ…å«å¤§é‡ä¸æ‹“æ‰‘æ— å…³çš„å‡ ä½•ä¿¡æ¯ã€‚'
- en: Let us focus on functoriality first. A metric space structure can be induced
    on a subset or, equivalently, it can be pulled back by an injective map. But thatâ€™s
    pretty much everything. They cannot be pulled back by general map or pushed forward,
    even by surjective maps.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å…ˆå…³æ³¨å‡½å­æ€§ã€‚å¯ä»¥åœ¨å­é›†ä¸Šè¯±å¯¼åº¦é‡ç©ºé—´ç»“æ„ï¼Œæˆ–è€…ç­‰ä»·åœ°ï¼Œå¯ä»¥é€šè¿‡ä¸€ä¸ªæ³¨å…¥æ˜ å°„å°†å…¶åæ‹‰ã€‚ä½†è¿™å‡ ä¹å°±æ˜¯å…¨éƒ¨äº†ã€‚å®ƒä»¬ä¸èƒ½é€šè¿‡ä¸€èˆ¬æ˜ å°„æˆ–å‰æ¨ï¼Œç”šè‡³ä¸èƒ½é€šè¿‡æ»¡å°„æ˜ å°„è¿›è¡Œåæ‹‰æˆ–å‰æ¨ã€‚
- en: 'In particular there is no sensible distance to put on a quotient of a metric
    space or on an uncountable product of metric spaces. Consider for instance the
    type `â„ â†’ â„`, seen as a product of copies of `â„` indexed by `â„`. We would like
    to say that pointwise convergence of sequences of functions is a respectable notion
    of convergence. But there is no distance on `â„ â†’ â„` that gives this notion of
    convergence. Relatedly, there is no distance ensuring that a map `f : X â†’ (â„ â†’
    â„)` is continuous if and only if `fun x â†¦ f x t` is continuous for every `t :
    â„`.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç‰¹åˆ«åœ°ï¼Œåœ¨åº¦é‡ç©ºé—´çš„å•†æˆ–ä¸å¯æ•°åº¦é‡ç©ºé—´çš„ç§¯ä¸Šæ”¾ç½®ä¸€ä¸ªæœ‰æ„ä¹‰çš„è·ç¦»æ˜¯æ²¡æœ‰æ„ä¹‰çš„ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘ç±»å‹ `â„ â†’ â„`ï¼Œå®ƒè¢«è§†ä¸ºç”± `â„` ç´¢å¼•çš„ `â„` çš„å¤åˆ¶å“çš„ç§¯ã€‚æˆ‘ä»¬å¸Œæœ›è¯´ï¼Œå‡½æ•°åºåˆ—é€ç‚¹æ”¶æ•›æ˜¯ä¸€ä¸ªå€¼å¾—å°Šé‡çš„æ”¶æ•›æ¦‚å¿µã€‚ä½†åœ¨
    `â„ â†’ â„` ä¸Šæ²¡æœ‰è·ç¦»å¯ä»¥ç»™å‡ºè¿™ç§æ”¶æ•›æ¦‚å¿µã€‚ç›¸å…³åœ°ï¼Œæ²¡æœ‰è·ç¦»å¯ä»¥ä¿è¯æ˜ å°„ `f : X â†’ (â„ â†’ â„)` åœ¨ä¸”ä»…å½“å¯¹äºæ¯ä¸ª `t : â„`ï¼Œ`fun
    x â†¦ f x t` æ˜¯è¿ç»­çš„æ—¶æ˜¯è¿ç»­çš„ã€‚'
- en: 'We now review the data used to solve all those issues. First we can use any
    map `f : X â†’ Y` to push or pull topologies from one side to the other. Those two
    operations form a Galois connection.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 'æˆ‘ä»¬ç°åœ¨å›é¡¾ç”¨äºè§£å†³æ‰€æœ‰è¿™äº›é—®é¢˜çš„æ•°æ®ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»»ä½•æ˜ å°„ `f : X â†’ Y` æ¥ä»ä¸€ä¸ªæ–¹å‘æ¨åŠ¨æˆ–æ‹‰åŠ¨æ‹“æ‰‘åˆ°å¦ä¸€ä¸ªæ–¹å‘ã€‚è¿™ä¸¤ä¸ªæ“ä½œå½¢æˆä¸€ä¸ªä¼½ç½—ç“¦è¿æ¥ã€‚'
- en: '[PRE107]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Those operations are compatible with composition of functions. As usual, pushing
    forward is covariant and pulling back is contravariant, see `coinduced_compose`
    and `induced_compose`. On paper we will use notations \(f_*T\) for `TopologicalSpace.coinduced
    f T` and \(f^*T\) for `TopologicalSpace.induced f T`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æ“ä½œä¸å‡½æ•°çš„å¤åˆæ˜¯å…¼å®¹çš„ã€‚åƒå¾€å¸¸ä¸€æ ·ï¼Œå‰æ¨æ˜¯åå˜çš„ï¼Œåæ‹‰æ˜¯åå¯¹å˜çš„ï¼Œå‚è§ `coinduced_compose` å’Œ `induced_compose`ã€‚åœ¨çº¸ä¸Šï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ç¬¦å·
    \(f_*T\) è¡¨ç¤º `TopologicalSpace.coinduced f T`ï¼Œä»¥åŠ \(f^*T\) è¡¨ç¤º `TopologicalSpace.induced
    f T`ã€‚
- en: 'Then the next big piece is a complete lattice structure on `TopologicalSpace
    X` for any given structure. If you think of topologies as being primarily the
    data of open sets then you expect the order relation on `TopologicalSpace X` to
    come from `Set (Set X)`, i.e. you expect `t â‰¤ t''` if a set `u` is open for `t''`
    as soon as it is open for `t`. However we already know that Mathlib focuses on
    neighborhoods more than open sets so, for any `x : X` we want the map from topological
    spaces to neighborhoods `fun T : TopologicalSpace X â†¦ @nhds X T x` to be order
    preserving. And we know the order relation on `Filter X` is designed to ensure
    an order preserving `principal : Set X â†’ Filter X`, allowing to see filters as
    generalized sets. So the order relation we do use on `TopologicalSpace X` is opposite
    to the one coming from `Set (Set X)`.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ¥ä¸‹æ¥çš„ä¸€å¤§å—å†…å®¹æ˜¯é’ˆå¯¹ä»»ä½•ç»™å®šçš„ç»“æ„åœ¨`TopologicalSpace X`ä¸Šçš„å®Œæ•´æ ¼ç»“æ„ã€‚å¦‚æœä½ è®¤ä¸ºæ‹“æ‰‘ä¸»è¦æ˜¯å¼€é›†çš„æ•°æ®ï¼Œé‚£ä¹ˆä½ æœŸæœ›`TopologicalSpace
    X`ä¸Šçš„é¡ºåºå…³ç³»æ¥è‡ª`Set (Set X)`ï¼Œå³ä½ æœŸæœ›å¦‚æœé›†åˆ`u`å¯¹äº`t''`æ˜¯å¼€é›†ï¼Œé‚£ä¹ˆå®ƒå¯¹äº`t`ä¹Ÿæ˜¯å¼€é›†ï¼Œä½ å°±æœŸæœ›`t â‰¤ t''`ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å·²ç»çŸ¥é“Mathlibæ›´å…³æ³¨é‚»åŸŸè€Œä¸æ˜¯å¼€é›†ï¼Œæ‰€ä»¥å¯¹äºä»»ä½•`x
    : X`ï¼Œæˆ‘ä»¬å¸Œæœ›ä»æ‹“æ‰‘ç©ºé—´åˆ°é‚»åŸŸçš„æ˜ å°„`fun T : TopologicalSpace X â†¦ @nhds X T x`æ˜¯é¡ºåºä¿æŒçš„ã€‚æˆ‘ä»¬è¿˜çŸ¥é“`Filter
    X`ä¸Šçš„é¡ºåºå…³ç³»è¢«è®¾è®¡ç”¨æ¥ç¡®ä¿é¡ºåºä¿æŒçš„`principal : Set X â†’ Filter X`ï¼Œå…è®¸å°†è¿‡æ»¤å™¨è§†ä¸ºå¹¿ä¹‰é›†åˆã€‚å› æ­¤ï¼Œæˆ‘ä»¬åœ¨`TopologicalSpace
    X`ä¸Šä½¿ç”¨çš„é¡ºåºå…³ç³»ä¸æ¥è‡ª`Set (Set X)`çš„é¡ºåºå…³ç³»ç›¸åã€‚'
- en: '[PRE108]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Now we can recover continuity by combining the push-forward (or pull-back) operation
    with the order relation.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ç»“åˆæ¨å‰ï¼ˆæˆ–æ‹‰å›ï¼‰æ“ä½œä¸é¡ºåºå…³ç³»æ¥æ¢å¤è¿ç»­æ€§ã€‚
- en: '[PRE109]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'With this definition and the compatibility of push-forward and composition,
    we get for free the universal property that, for any topological space \(Z\),
    a function \(g : Y â†’ Z\) is continuous for the topology \(f_*T_X\) if and only
    if \(g âˆ˜ f\) is continuous.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 'é€šè¿‡è¿™ä¸ªå®šä¹‰å’Œæ¨å‰ä¸å¤åˆçš„å…¼å®¹æ€§ï¼Œæˆ‘ä»¬å…è´¹è·å¾—äº†è¿™æ ·çš„æ³›æ€§è´¨ï¼šå¯¹äºä»»ä½•æ‹“æ‰‘ç©ºé—´\(Z\)ï¼Œå¦‚æœå‡½æ•°\(g : Y â†’ Z\)åœ¨æ‹“æ‰‘\(f_*T_X\)ä¸‹æ˜¯è¿ç»­çš„ï¼Œå½“ä¸”ä»…å½“\(g
    âˆ˜ f\)æ˜¯è¿ç»­çš„ã€‚'
- en: \[\begin{split}g \text{ continuous } &â‡” g_*(f_*T_X) â‰¤ T_Z \\ &â‡” (g âˆ˜ f)_* T_X
    â‰¤ T_Z \\ &â‡” g âˆ˜ f \text{ continuous}\end{split}\]
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}g \text{ è¿ç»­ } &â‡” g_*(f_*T_X) â‰¤ T_Z \\ &â‡” (g âˆ˜ f)_* T_X â‰¤ T_Z
    \\ &â‡” g âˆ˜ f \text{ è¿ç»­}\end{split}\]
- en: '[PRE110]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'So we already get quotient topologies (using the projection map as `f`). This
    wasnâ€™t using that `TopologicalSpace X` is a complete lattice for all `X`. Letâ€™s
    now see how all this structure proves the existence of the product topology by
    abstract non-sense. We considered the case of `â„ â†’ â„` above, but letâ€™s now consider
    the general case of `Î  i, X i` for some `Î¹ : Type*` and `X : Î¹ â†’ Type*`. We want,
    for any topological space `Z` and any function `f : Z â†’ Î  i, X i`, that `f` is
    continuous if and only if `(fun x â†¦ x i) âˆ˜ f` is continuous for all `i`. Let us
    explore that constraint â€œon paperâ€ using notation \(p_i\) for the projection `(fun
    (x : Î  i, X i) â†¦ x i)`:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 'å› æ­¤ï¼Œæˆ‘ä»¬å·²ç»å¾—åˆ°äº†å•†æ‹“æ‰‘ï¼ˆä½¿ç”¨æŠ•å½±æ˜ å°„ä½œä¸º`f`ï¼‰ã€‚è¿™å¹¶ä¸æ˜¯å› ä¸º`TopologicalSpace X`å¯¹äºæ‰€æœ‰`X`éƒ½æ˜¯å®Œæ•´çš„æ ¼ã€‚ç°åœ¨è®©æˆ‘ä»¬çœ‹çœ‹æ‰€æœ‰è¿™äº›ç»“æ„å¦‚ä½•é€šè¿‡æŠ½è±¡çš„èƒ¡è¨€ä¹±è¯­è¯æ˜ä¹˜ç§¯æ‹“æ‰‘çš„å­˜åœ¨ã€‚æˆ‘ä»¬ä¸Šé¢è€ƒè™‘äº†`â„
    â†’ â„`çš„æƒ…å†µï¼Œä½†ç°åœ¨è®©æˆ‘ä»¬è€ƒè™‘ä¸€èˆ¬æƒ…å†µ`Î  i, X i`å¯¹äºæŸä¸ª`Î¹ : Type*`å’Œ`X : Î¹ â†’ Type*`ã€‚æˆ‘ä»¬å¸Œæœ›å¯¹äºä»»ä½•æ‹“æ‰‘ç©ºé—´`Z`å’Œä»»ä½•å‡½æ•°`f
    : Z â†’ Î  i, X i`ï¼Œå¦‚æœå¯¹äºæ‰€æœ‰`i`ï¼Œ`(fun x â†¦ x i) âˆ˜ f`æ˜¯è¿ç»­çš„ï¼Œé‚£ä¹ˆ`f`æ˜¯è¿ç»­çš„ã€‚è®©æˆ‘ä»¬ä½¿ç”¨è¡¨ç¤ºæŠ•å½±`(fun (x
    : Î  i, X i) â†¦ x i)`çš„ç¬¦å·\(p_i\)æ¥â€œåœ¨çº¸ä¸Šâ€æ¢ç´¢è¿™ä¸ªçº¦æŸï¼š'
- en: \[\begin{split}(âˆ€ i, p_i âˆ˜ f \text{ continuous}) &â‡” âˆ€ i, (p_i âˆ˜ f)_* T_Z â‰¤ T_{X_i}
    \\ &â‡” âˆ€ i, (p_i)_* f_* T_Z â‰¤ T_{X_i}\\ &â‡” âˆ€ i, f_* T_Z â‰¤ (p_i)^*T_{X_i}\\ &â‡” f_*
    T_Z â‰¤ \inf \left[(p_i)^*T_{X_i}\right]\end{split}\]
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}(âˆ€ i, p_i âˆ˜ f \text{ è¿ç»­}) &â‡” âˆ€ i, (p_i âˆ˜ f)_* T_Z â‰¤ T_{X_i} \\
    &â‡” âˆ€ i, (p_i)_* f_* T_Z â‰¤ T_{X_i}\\ &â‡” âˆ€ i, f_* T_Z â‰¤ (p_i)^*T_{X_i}\\ &â‡” f_*
    T_Z â‰¤ \inf \left[(p_i)^*T_{X_i}\right]\end{split}\]
- en: 'So we see that what is the topology we want on `Î  i, X i`:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬çœ‹åˆ°æˆ‘ä»¬å¸Œæœ›åœ¨`Î  i, X i`ä¸Šçš„æ‹“æ‰‘æ˜¯ä»€ä¹ˆï¼š
- en: '[PRE111]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: This ends our tour of how Mathlib thinks that topological spaces fix defects
    of the theory of metric spaces by being a more functorial theory and having a
    complete lattice structure for any fixed type.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±ç»“æŸäº†æˆ‘ä»¬å¯¹Mathlibå¦‚ä½•è®¤ä¸ºæ‹“æ‰‘ç©ºé—´é€šè¿‡æˆä¸ºä¸€ä¸ªæ›´å‡½æ•°åŒ–çš„ç†è®ºå’Œä¸ºä»»ä½•å›ºå®šç±»å‹æä¾›å®Œæ•´çš„æ ¼ç»“æ„æ¥ä¿®å¤åº¦é‡ç©ºé—´ç†è®ºçš„ç¼ºé™·çš„è€ƒå¯Ÿã€‚
- en: 11.3.2\. Separation and countability[ïƒ](#separation-and-countability "Link to
    this heading")
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2\. åˆ†ç¦»ä¸å¯æ•°æ€§[ïƒ](#separation-and-countability "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")
- en: 'We saw that the category of topological spaces have very nice properties. The
    price to pay for this is existence of rather pathological topological spaces.
    There are a number of assumptions you can make on a topological space to ensure
    its behavior is closer to what metric spaces do. The most important is `T2Space`,
    also called â€œHausdorffâ€, that will ensure that limits are unique. A stronger separation
    property is `T3Space` that ensures in addition the RegularSpace property: each
    point has a basis of closed neighborhoods.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çœ‹åˆ°æ‹“æ‰‘ç©ºé—´èŒƒç•´å…·æœ‰éå¸¸å¥½çš„æ€§è´¨ã€‚ä¸ºæ­¤æ‰€ä»˜å‡ºçš„ä»£ä»·æ˜¯å­˜åœ¨ç›¸å½“ç—…æ€çš„æ‹“æ‰‘ç©ºé—´ã€‚ä½ å¯ä»¥å¯¹æ‹“æ‰‘ç©ºé—´åšå‡ºä¸€ç³»åˆ—å‡è®¾ä»¥ç¡®ä¿å…¶è¡Œä¸ºæ›´æ¥è¿‘åº¦é‡ç©ºé—´ã€‚æœ€é‡è¦çš„æ˜¯ `T2Space`ï¼Œä¹Ÿç§°ä¸ºâ€œè±ªæ–¯å¤šå¤«â€ï¼Œè¿™å°†ç¡®ä¿æé™æ˜¯å”¯ä¸€çš„ã€‚æ›´å¼ºçš„åˆ†ç¦»æ€§è´¨æ˜¯
    `T3Space`ï¼Œå®ƒè¿˜ç¡®ä¿äº†æ­£åˆ™ç©ºé—´æ€§è´¨ï¼šæ¯ä¸ªç‚¹éƒ½æœ‰ä¸€ä¸ªé—­é‚»åŸŸåŸºã€‚
- en: '[PRE112]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Note that, in every topological space, each point has a basis of open neighborhood,
    by definition.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨æ¯ä¸€ä¸ªæ‹“æ‰‘ç©ºé—´ä¸­ï¼Œæ¯ä¸ªç‚¹éƒ½æœ‰ä¸€ä¸ªå¼€é‚»åŸŸåŸºï¼Œè¿™æ˜¯å®šä¹‰æ‰€è¦æ±‚çš„ã€‚
- en: '[PRE113]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Our main goal is now to prove the basic theorem which allows extension by continuity.
    From Bourbakiâ€™s general topology book, I.8.5, Theorem 1 (taking only the non-trivial
    implication):'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨çš„ç›®æ ‡æ˜¯è¯æ˜ä¸€ä¸ªåŸºæœ¬å®šç†ï¼Œè¯¥å®šç†å…è®¸é€šè¿‡è¿ç»­æ€§è¿›è¡Œæ‰©å±•ã€‚ä»å¸ƒå°”å·´åŸºçš„ã€Šä¸€èˆ¬æ‹“æ‰‘å­¦ã€‹ä¸€ä¹¦ï¼ŒI.8.5ï¼Œå®šç†1ï¼ˆä»…è€ƒè™‘éå¹³å‡¡è•´å«ï¼‰ï¼š
- en: 'Let \(X\) be a topological space, \(A\) a dense subset of \(X\), \(f : A â†’
    Y\) a continuous mapping of \(A\) into a \(T_3\) space \(Y\). If, for each \(x\)
    in \(X\), \(f(y)\) tends to a limit in \(Y\) when \(y\) tends to \(x\) while remaining
    in \(A\) then there exists a continuous extension \(Ï†\) of \(f\) to \(X\).'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 'è®¾ \(X\) æ˜¯ä¸€ä¸ªæ‹“æ‰‘ç©ºé—´ï¼Œ\(A\) æ˜¯ \(X\) çš„ä¸€ä¸ªç¨ å¯†å­é›†ï¼Œ\(f : A â†’ Y\) æ˜¯å°† \(A\) æ˜ å°„åˆ° \(T_3\) ç©ºé—´
    \(Y\) çš„è¿ç»­æ˜ å°„ã€‚å¦‚æœå¯¹äº \(X\) ä¸­çš„æ¯ä¸ª \(x\)ï¼Œå½“ \(y\) åœ¨ \(A\) ä¸­è¶‹å‘äº \(x\) æ—¶ï¼Œ\(f(y)\) åœ¨ \(Y\)
    ä¸­è¶‹å‘äºä¸€ä¸ªæé™ï¼Œé‚£ä¹ˆå­˜åœ¨ä¸€ä¸ªå°† \(f\) æ‰©å±•åˆ° \(X\) çš„è¿ç»­æ‰©å±• \(Ï†\)ã€‚'
- en: Actually Mathlib contains a more general version of the above lemma, `IsDenseInducing.continuousAt_extend`,
    but weâ€™ll stick to Bourbakiâ€™s version here.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šï¼ŒMathlib åŒ…å«äº†ä¸Šè¿°å¼•ç†çš„ä¸€ä¸ªæ›´ä¸€èˆ¬ç‰ˆæœ¬ï¼Œ`IsDenseInducing.continuousAt_extend`ï¼Œä½†æˆ‘ä»¬å°†åšæŒä½¿ç”¨å¸ƒå°”å·´åŸºçš„ç‰ˆæœ¬ã€‚
- en: 'Remember that, given `A : Set X`, `â†¥A` is the subtype associated to `A`, and
    Lean will automatically insert that funny up arrow when needed. And the (inclusion)
    coercion map is `(â†‘) : A â†’ X`. The assumption â€œtends to \(x\) while remaining
    in \(A\)â€ corresponds to the pull-back filter `comap (â†‘) (ğ“ x)`.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 'è®°ä½ï¼Œç»™å®š `A : Set X`ï¼Œ`â†¥A` æ˜¯ä¸ `A` å…³è”çš„å­ç±»å‹ï¼Œå¹¶ä¸” Lean ä¼šè‡ªåŠ¨åœ¨éœ€è¦æ—¶æ’å…¥é‚£ä¸ªæœ‰è¶£çš„å‘ä¸Šç®­å¤´ã€‚è€Œï¼ˆåŒ…å«ï¼‰å¼ºåˆ¶æ˜ å°„æ˜¯
    `(â†‘) : A â†’ X`ã€‚å‡è®¾â€œåœ¨ \(A\) ä¸­è¶‹å‘äº \(x\)â€å¯¹åº”äºæ‹‰å›è¿‡æ»¤å™¨ `comap (â†‘) (ğ“ x)`ã€‚'
- en: Letâ€™s first prove an auxiliary lemma, extracted to simplify the context (in
    particular we donâ€™t need Y to be a topological space here).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å…ˆè¯æ˜ä¸€ä¸ªè¾…åŠ©å¼•ç†ï¼Œå°†å…¶æå–å‡ºæ¥ä»¥ç®€åŒ–ä¸Šä¸‹æ–‡ï¼ˆç‰¹åˆ«æ˜¯æˆ‘ä»¬åœ¨è¿™é‡Œä¸éœ€è¦ \(Y\) æ˜¯ä¸€ä¸ªæ‹“æ‰‘ç©ºé—´ï¼‰ã€‚
- en: '[PRE114]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Letâ€™s now turn to the main proof of the extension by continuity theorem.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ç°åœ¨è½¬å‘è¿ç»­æ‰©å±•å®šç†çš„ä¸»è¦è¯æ˜ã€‚
- en: 'When Lean needs a topology on `â†¥A` it will automatically use the induced topology.
    The only relevant lemma is `nhds_induced (â†‘) : âˆ€ a : â†¥A, ğ“ a = comap (â†‘) (ğ“ â†‘a)`
    (this is actually a general lemma about induced topologies).'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 'å½“ Lean éœ€è¦åœ¨ `â†¥A` ä¸Šä½¿ç”¨æ‹“æ‰‘æ—¶ï¼Œå®ƒå°†è‡ªåŠ¨ä½¿ç”¨è¯±å¯¼æ‹“æ‰‘ã€‚å”¯ä¸€ç›¸å…³çš„å¼•ç†æ˜¯ `nhds_induced (â†‘) : âˆ€ a : â†¥A, ğ“
    a = comap (â†‘) (ğ“ â†‘a)`ï¼ˆè¿™å®é™…ä¸Šæ˜¯ä¸€ä¸ªå…³äºè¯±å¯¼æ‹“æ‰‘çš„é€šç”¨å¼•ç†ï¼‰ã€‚'
- en: 'The proof outline is:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: è¯æ˜æ¦‚è¦æ˜¯ï¼š
- en: The main assumption and the axiom of choice give a function `Ï†` such that `âˆ€
    x, Tendsto f (comap (â†‘) (ğ“ x)) (ğ“ (Ï† x))` (because `Y` is Hausdorff, `Ï†` is entirely
    determined, but we wonâ€™t need that until we try to prove that `Ï†` indeed extends
    `f`).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸»è¦å‡è®¾å’Œé€‰æ‹©å…¬ç†ç»™å‡ºä¸€ä¸ªå‡½æ•° `Ï†`ï¼Œä½¿å¾— `âˆ€ x, Tendsto f (comap (â†‘) (ğ“ x)) (ğ“ (Ï† x))`ï¼ˆå› ä¸º `Y` æ˜¯è±ªæ–¯å¤šå¤«çš„ï¼Œ`Ï†`
    æ˜¯å®Œå…¨ç¡®å®šçš„ï¼Œä½†æˆ‘ä»¬ä¸ä¼šåœ¨å°è¯•è¯æ˜ `Ï†` ç¡®å®æ‰©å±• `f` ä¹‹å‰éœ€è¦å®ƒï¼‰ã€‚
- en: 'Letâ€™s first prove `Ï†` is continuous. Fix any `x : X`. Since `Y` is regular,
    it suffices to check that for every *closed* neighborhood `V''` of `Ï† x`, `Ï† â»Â¹''
    V'' âˆˆ ğ“ x`. The limit assumption gives (through the auxiliary lemma above) some
    `V âˆˆ ğ“ x` such `IsOpen V âˆ§ (â†‘) â»Â¹'' V âŠ† f â»Â¹'' V''`. Since `V âˆˆ ğ“ x`, it suffices
    to prove `V âŠ† Ï† â»Â¹'' V''`, i.e. `âˆ€ y âˆˆ V, Ï† y âˆˆ V''`. Letâ€™s fix `y` in `V`. Because
    `V` is *open*, it is a neighborhood of `y`. In particular `(â†‘) â»Â¹'' V âˆˆ comap
    (â†‘) (ğ“ y)` and a fortiori `f â»Â¹'' V'' âˆˆ comap (â†‘) (ğ“ y)`. In addition `comap (â†‘)
    (ğ“ y) â‰  âŠ¥` because `A` is dense. Because we know `Tendsto f (comap (â†‘) (ğ“ y))
    (ğ“ (Ï† y))` this implies `Ï† y âˆˆ closure V''` and, since `V''` is closed, we have
    proved `Ï† y âˆˆ V''`.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 'è®©æˆ‘ä»¬å…ˆè¯æ˜`Ï†`æ˜¯è¿ç»­çš„ã€‚å›ºå®šä»»æ„çš„`x : X`ã€‚ç”±äº`Y`æ˜¯æ­£åˆ™çš„ï¼Œæˆ‘ä»¬åªéœ€æ£€æŸ¥å¯¹äº`Ï† x`çš„æ¯ä¸€ä¸ª*é—­*é‚»åŸŸ`V''`ï¼Œ`Ï† â»Â¹'' V''
    âˆˆ ğ“ x`ã€‚æé™å‡è®¾ç»™å‡ºäº†ï¼ˆé€šè¿‡ä¸Šé¢çš„è¾…åŠ©å¼•ç†ï¼‰ä¸€äº›`V âˆˆ ğ“ x`ï¼Œä½¿å¾—`IsOpen V âˆ§ (â†‘) â»Â¹'' V âŠ† f â»Â¹'' V''`ã€‚ç”±äº`V
    âˆˆ ğ“ x`ï¼Œæˆ‘ä»¬åªéœ€è¯æ˜`V âŠ† Ï† â»Â¹'' V''`ï¼Œå³`âˆ€ y âˆˆ V, Ï† y âˆˆ V''`ã€‚è®©æˆ‘ä»¬å›ºå®š`V`ä¸­çš„`y`ã€‚å› ä¸º`V`æ˜¯*å¼€*çš„ï¼Œæ‰€ä»¥å®ƒæ˜¯`y`çš„ä¸€ä¸ªé‚»åŸŸã€‚ç‰¹åˆ«æ˜¯`(â†‘)
    â»Â¹'' V âˆˆ comap (â†‘) (ğ“ y)`ï¼Œå¹¶ä¸”æ›´æ˜æ˜¾`f â»Â¹'' V'' âˆˆ comap (â†‘) (ğ“ y)`ã€‚æ­¤å¤–ï¼Œ`comap (â†‘) (ğ“
    y) â‰  âŠ¥`ï¼Œå› ä¸º`A`æ˜¯ç¨ å¯†çš„ã€‚å› ä¸ºæˆ‘ä»¬çŸ¥é“`Tendsto f (comap (â†‘) (ğ“ y)) (ğ“ (Ï† y))`ï¼Œè¿™è¡¨æ˜`Ï† y âˆˆ closure
    V''`ï¼Œå¹¶ä¸”ç”±äº`V''`æ˜¯é—­çš„ï¼Œæˆ‘ä»¬è¯æ˜äº†`Ï† y âˆˆ V''`ã€‚'
- en: It remains to prove that `Ï†` extends `f`. This is where the continuity of `f`
    enters the discussion, together with the fact that `Y` is Hausdorff.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: å‰©ä¸‹çš„å·¥ä½œæ˜¯è¯æ˜`Ï†`æ‰©å±•äº†`f`ã€‚è¿™æ˜¯`f`çš„è¿ç»­æ€§è¿›å…¥è®¨è®ºçš„åœ°æ–¹ï¼Œä»¥åŠ`Y`æ˜¯è±ªæ–¯å¤šå¤«çš„äº‹å®ã€‚
- en: '[PRE115]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: In addition to separation property, the main kind of assumption you can make
    on a topological space to bring it closer to metric spaces is countability assumption.
    The main one is first countability asking that every point has a countable neighborhood
    basis. In particular this ensures that closure of sets can be understood using
    sequences.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: é™¤äº†åˆ†ç¦»æ€§è´¨ï¼Œä½ å¯ä»¥åœ¨æ‹“æ‰‘ç©ºé—´ä¸Šåšå‡ºçš„ä¸»è¦å‡è®¾æ˜¯å¯æ•°æ€§å‡è®¾ï¼Œä»¥ä½¿å…¶æ›´æ¥è¿‘åº¦é‡ç©ºé—´ã€‚ä¸»è¦çš„ä¸€ä¸ªæ˜¯ç¬¬ä¸€å¯æ•°æ€§ï¼Œè¦æ±‚æ¯ä¸ªç‚¹éƒ½æœ‰ä¸€ä¸ªå¯æ•°çš„é‚»åŸŸåŸºã€‚ç‰¹åˆ«æ˜¯è¿™ä¿è¯äº†é›†åˆçš„é—­åŒ…å¯ä»¥ç”¨åºåˆ—æ¥ç†è§£ã€‚
- en: '[PRE116]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 11.3.3\. Compactness[ïƒ](#id5 "Link to this heading")
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.3\. ç´§è‡´æ€§[ïƒ](#id5 "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")
- en: Let us now discuss how compactness is defined for topological spaces. As usual
    there are several ways to think about it and Mathlib goes for the filter version.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æ¥è®¨è®ºæ‹“æ‰‘ç©ºé—´ä¸­ç´§è‡´æ€§çš„å®šä¹‰ã€‚é€šå¸¸æœ‰å‡ ç§æ€è€ƒæ–¹å¼ï¼ŒMathlibé€‰æ‹©äº†è¿‡æ»¤å™¨ç‰ˆæœ¬ã€‚
- en: 'We first need to define cluster points of filters. Given a filter `F` on a
    topological space `X`, a point `x : X` is a cluster point of `F` if `F`, seen
    as a generalized set, has non-empty intersection with the generalized set of points
    that are close to `x`.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 'æˆ‘ä»¬é¦–å…ˆéœ€è¦å®šä¹‰è¿‡æ»¤å™¨çš„èšç‚¹ã€‚ç»™å®šä¸€ä¸ªæ‹“æ‰‘ç©ºé—´`X`ä¸Šçš„è¿‡æ»¤å™¨`F`ï¼Œå¦‚æœ`F`ä½œä¸ºä¸€ä¸ªå¹¿ä¹‰é›†ä¸æ¥è¿‘`x`çš„ç‚¹çš„å¹¿ä¹‰é›†éç©ºäº¤é›†ï¼Œé‚£ä¹ˆç‚¹`x : X`æ˜¯`F`çš„èšç‚¹ã€‚'
- en: Then we can say that a set `s` is compact if every nonempty generalized set
    `F` contained in `s`, i.e. such that `F â‰¤ ğ“Ÿ s`, has a cluster point in `s`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·è¯´ï¼Œå¦‚æœ`s`ä¸­çš„æ¯ä¸€ä¸ªéç©ºå¹¿ä¹‰é›†`F`ï¼ˆå³`F â‰¤ ğ“Ÿ s`ï¼‰ï¼Œåœ¨`s`ä¸­éƒ½æœ‰ä¸€ä¸ªèšç‚¹ï¼Œé‚£ä¹ˆ`s`æ˜¯ç´§è‡´çš„ã€‚
- en: '[PRE117]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'For instance if `F` is `map u atTop`, the image under `u : â„• â†’ X` of `atTop`,
    the generalized set of very large natural numbers, then the assumption `F â‰¤ ğ“Ÿ
    s` means that `u n` belongs to `s` for `n` large enough. Saying that `x` is a
    cluster point of `map u atTop` says the image of very large numbers intersects
    the set of points that are close to `x`. In case `ğ“ x` has a countable basis,
    we can interpret this as saying that `u` has a subsequence converging to `x`,
    and we get back what compactness looks like in metric spaces.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¾‹å¦‚ï¼Œå¦‚æœ`F`æ˜¯`map u atTop`ï¼Œå³`u : â„• â†’ X`çš„`atTop`çš„åƒï¼Œ`atTop`æ˜¯æå¤§çš„è‡ªç„¶æ•°çš„å¹¿ä¹‰é›†ï¼Œé‚£ä¹ˆ`F â‰¤ ğ“Ÿ s`çš„å‡è®¾æ„å‘³ç€å¯¹äºè¶³å¤Ÿå¤§çš„`n`ï¼Œ`u
    n`å±äº`s`ã€‚è¯´`x`æ˜¯`map u atTop`çš„èšç‚¹æ„å‘³ç€éå¸¸å¤§çš„æ•°çš„åƒä¸æ¥è¿‘`x`çš„ç‚¹çš„é›†åˆç›¸äº¤ã€‚å¦‚æœ`ğ“ x`æœ‰ä¸€ä¸ªå¯æ•°åŸºï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶è§£é‡Šä¸ºè¯´`u`æœ‰ä¸€ä¸ªå­åºåˆ—æ”¶æ•›åˆ°`x`ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¾—åˆ°äº†åº¦é‡ç©ºé—´ä¸­ç´§è‡´æ€§çš„æ ·å­ã€‚'
- en: '[PRE118]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Cluster points behave nicely with continuous functions.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: èšç‚¹ä¸è¿ç»­å‡½æ•°çš„è¡Œä¸ºè‰¯å¥½ã€‚
- en: '[PRE119]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: As an exercise, we will prove that the image of a compact set under a continuous
    map is compact. In addition to what we saw already, you should use `Filter.push_pull`
    and `NeBot.of_map`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºç»ƒä¹ ï¼Œæˆ‘ä»¬å°†è¯æ˜ç´§é›†åœ¨è¿ç»­æ˜ å°„ä¸‹çš„åƒä¹Ÿæ˜¯ç´§è‡´çš„ã€‚é™¤äº†æˆ‘ä»¬å·²ç»çœ‹åˆ°çš„ï¼Œä½ è¿˜åº”è¯¥ä½¿ç”¨`Filter.push_pull`å’Œ`NeBot.of_map`ã€‚
- en: '[PRE120]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'One can also express compactness in terms of open covers: `s` is compact if
    every family of open sets that cover `s` has a finite covering sub-family.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªäººä¹Ÿå¯ä»¥ç”¨å¼€è¦†ç›–æ¥è¡¨ç¤ºç´§è‡´æ€§ï¼šå¦‚æœè¦†ç›–`s`çš„æ¯ä¸€ä¸ªå¼€é›†æ—éƒ½æœ‰ä¸€ä¸ªæœ‰é™è¦†ç›–å­æ—ï¼Œé‚£ä¹ˆ`s`æ˜¯ç´§è‡´çš„ã€‚
- en: '[PRE121]  ## 11.1\. Filters[ïƒ](#filters "Link to this heading")'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE121]  ## 11.1\. è¿‡æ»¤å™¨[ïƒ](#filters "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")'
- en: 'A *filter* on a type `X` is a collection of sets of `X` that satisfies three
    conditions that we will spell out below. The notion supports two related ideas:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç±»å‹`X`ä¸Šçš„ä¸€ä¸ª*è¿‡æ»¤å™¨*æ˜¯`X`çš„é›†åˆçš„é›†åˆï¼Œå®ƒæ»¡è¶³ä»¥ä¸‹ä¸‰ä¸ªæ¡ä»¶ï¼Œæˆ‘ä»¬å°†åœ¨ä¸‹é¢è¯¦ç»†è¯´æ˜ã€‚è¿™ä¸ªæ¦‚å¿µæ”¯æŒä¸¤ä¸ªç›¸å…³æƒ³æ³•ï¼š
- en: '*limits*, including all the kinds of limits discussed above: finite and infinite
    limits of sequences, finite and infinite limits of functions at a point or at
    infinity, and so on.'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*æé™*ï¼ŒåŒ…æ‹¬ä¸Šé¢è®¨è®ºçš„æ‰€æœ‰ç±»å‹çš„æé™ï¼šåºåˆ—çš„æœ‰é™å’Œæ— é™æé™ï¼Œå‡½æ•°åœ¨ä¸€ç‚¹æˆ–æ— ç©·è¿œå¤„çš„æœ‰é™å’Œæ— é™æé™ç­‰ã€‚'
- en: '*things happening eventually*, including things happening for large enough
    `n : â„•`, or sufficiently near a point `x`, or for sufficiently close pairs of
    points, or almost everywhere in the sense of measure theory. Dually, filters can
    also express the idea of *things happening often*: for arbitrarily large `n`,
    at a point in any neighborhood of a given point, etc.'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*æœ€ç»ˆå‘ç”Ÿçš„äº‹æƒ…*ï¼ŒåŒ…æ‹¬å¯¹äºè¶³å¤Ÿå¤§çš„ `n : â„•`ï¼Œæˆ–åœ¨ç‚¹ `x` è¶³å¤Ÿè¿‘çš„åœ°æ–¹ï¼Œæˆ–å¯¹äºè¶³å¤Ÿæ¥è¿‘çš„ç‚¹å¯¹ï¼Œæˆ–åœ¨æµ‹åº¦ç†è®ºæ„ä¹‰ä¸Šçš„å‡ ä¹å¤„å¤„å‘ç”Ÿçš„äº‹æƒ…ã€‚ç±»ä¼¼åœ°ï¼Œè¿‡æ»¤å™¨ä¹Ÿå¯ä»¥è¡¨è¾¾
    *ç»å¸¸å‘ç”Ÿçš„äº‹æƒ…* çš„æƒ³æ³•ï¼šå¯¹äºä»»æ„å¤§çš„ `n`ï¼Œåœ¨ä»»æ„ç»™å®šç‚¹çš„ä»»æ„é‚»åŸŸä¸­ç­‰ã€‚'
- en: 'The filters that correspond to these descriptions will be defined later in
    this section, but we can already name them:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹åº”è¿™äº›æè¿°çš„è¿‡æ»¤å™¨å°†åœ¨æœ¬èŠ‚åé¢å®šä¹‰ï¼Œä½†æˆ‘ä»¬å¯ä»¥å…ˆå‘½åå®ƒä»¬ï¼š
- en: '`(atTop : Filter â„•)`, made of sets of `â„•` containing `{n | n â‰¥ N}` for some
    `N`'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(atTop : Filter â„•)`ï¼Œç”±åŒ…å« `{n | n â‰¥ N}` çš„ `â„•` é›†åˆç»„æˆçš„è¿‡æ»¤å™¨ï¼ˆå…¶ä¸­ `N` æ˜¯æŸä¸ªæ•°ï¼‰'
- en: '`ğ“ x`, made of neighborhoods of `x` in a topological space'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ğ“ x`ï¼Œç”±æ‹“æ‰‘ç©ºé—´ä¸­ `x` çš„é‚»åŸŸç»„æˆ'
- en: '`ğ“¤ X`, made of entourages of a uniform space (uniform spaces generalize metric
    spaces and topological groups)'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ğ“¤ X`ï¼Œç”±å‡åŒ€ç©ºé—´ï¼ˆå‡åŒ€ç©ºé—´æ˜¯åº¦é‡ç©ºé—´å’Œæ‹“æ‰‘ç¾¤çš„æ¨å¹¿ï¼‰çš„é‚»åŸŸç»„æˆ'
- en: '`Î¼.ae` , made of sets whose complement has zero measure with respect to a measure
    `Î¼`.'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Î¼.ae`ï¼Œç”±ç›¸å¯¹äºæµ‹åº¦ `Î¼` è¡¥é›†æµ‹åº¦ä¸ºé›¶çš„é›†åˆç»„æˆ'
- en: 'The general definition is as follows: a filter `F : Filter X` is a collection
    of sets `F.sets : Set (Set X)` satisfying the following:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¸€èˆ¬å®šä¹‰å¦‚ä¸‹ï¼šè¿‡æ»¤å™¨ `F : Filter X` æ˜¯ä¸€ä¸ªé›†åˆ `F.sets : Set (Set X)`ï¼Œæ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š'
- en: '`F.univ_sets : univ âˆˆ F.sets`'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F.univ_sets`ï¼š`univ` å±äº `F.sets`'
- en: '`F.sets_of_superset : âˆ€ {U V}, U âˆˆ F.sets â†’ U âŠ† V â†’ V âˆˆ F.sets`'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F.sets_of_superset`ï¼šå¯¹æ‰€æœ‰ `{U V}`ï¼Œå¦‚æœ `U âˆˆ F.sets` ä¸” `U âŠ† V`ï¼Œåˆ™ `V âˆˆ F.sets`'
- en: '`F.inter_sets : âˆ€ {U V}, U âˆˆ F.sets â†’ V âˆˆ F.sets â†’ U âˆ© V âˆˆ F.sets`.'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F.inter_sets`ï¼šå¯¹æ‰€æœ‰ `{U V}`ï¼Œå¦‚æœ `U âˆˆ F.sets` ä¸” `V âˆˆ F.sets`ï¼Œåˆ™ `U âˆ© V âˆˆ F.sets`ã€‚'
- en: The first condition says that the set of all elements of `X` belongs to `F.sets`.
    The second condition says that if `U` belongs to `F.sets` then anything containing
    `U` also belongs to `F.sets`. The third condition says that `F.sets` is closed
    under finite intersections. In Mathlib, a filter `F` is defined to be a structure
    bundling `F.sets` and its three properties, but the properties carry no additional
    data, and it is convenient to blur the distinction between `F` and `F.sets`. We
    therefore define `U âˆˆ F` to mean `U âˆˆ F.sets`. This explains why the word `sets`
    appears in the names of some lemmas that that mention `U âˆˆ F`.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ä¸ªæ¡ä»¶è¯´æ˜ `X` çš„æ‰€æœ‰å…ƒç´ é›†åˆå±äº `F.sets`ã€‚ç¬¬äºŒä¸ªæ¡ä»¶è¯´æ˜å¦‚æœ `U` å±äº `F.sets`ï¼Œé‚£ä¹ˆåŒ…å« `U` çš„ä»»ä½•é›†åˆä¹Ÿå±äº `F.sets`ã€‚ç¬¬ä¸‰ä¸ªæ¡ä»¶è¯´æ˜
    `F.sets` å¯¹æœ‰é™äº¤é›†æ˜¯å°é—­çš„ã€‚åœ¨ Mathlib ä¸­ï¼Œè¿‡æ»¤å™¨ `F` è¢«å®šä¹‰ä¸ºæ†ç»‘ `F.sets` å’Œå…¶ä¸‰ä¸ªå±æ€§çš„ç»“æ„çš„å®šä¹‰ï¼Œä½†è¿™äº›å±æ€§ä¸æºå¸¦é¢å¤–çš„æ•°æ®ï¼Œå¹¶ä¸”å°†
    `F` å’Œ `F.sets` ä¹‹é—´çš„åŒºåˆ«æ¨¡ç³ŠåŒ–æ˜¯æ–¹ä¾¿çš„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å®šä¹‰ `U âˆˆ F` è¡¨ç¤º `U âˆˆ F.sets`ã€‚è¿™è§£é‡Šäº†ä¸ºä»€ä¹ˆåœ¨æåŠ `U âˆˆ F`
    çš„æŸäº›å¼•ç†åç§°ä¸­å‡ºç°äº†å•è¯ `sets`ã€‚
- en: It may help to think of a filter as defining a notion of a â€œsufficiently largeâ€
    set. The first condition then says that `univ` is sufficiently large, the second
    one says that a set containing a sufficiently large set is sufficiently large
    and the third one says that the intersection of two sufficiently large sets is
    sufficiently large.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: å¯ä»¥å°†è¿‡æ»¤å™¨è§†ä¸ºå®šä¹‰â€œè¶³å¤Ÿå¤§â€çš„é›†åˆçš„æ¦‚å¿µã€‚ç¬¬ä¸€ä¸ªæ¡ä»¶è¯´æ˜ `univ` æ˜¯è¶³å¤Ÿå¤§çš„ï¼Œç¬¬äºŒä¸ªæ¡ä»¶è¯´æ˜åŒ…å«è¶³å¤Ÿå¤§é›†åˆçš„é›†åˆä¹Ÿæ˜¯è¶³å¤Ÿå¤§çš„ï¼Œç¬¬ä¸‰ä¸ªæ¡ä»¶è¯´æ˜ä¸¤ä¸ªè¶³å¤Ÿå¤§é›†åˆçš„äº¤é›†ä¹Ÿæ˜¯è¶³å¤Ÿå¤§çš„ã€‚
- en: 'It may be even more useful to think of a filter on a type `X` as a generalized
    element of `Set X`. For instance, `atTop` is the â€œset of very large numbersâ€ and
    `ğ“ xâ‚€` is the â€œset of points very close to `xâ‚€`.â€ One manifestation of this view
    is that we can associate to any `s : Set X` the so-called *principal filter* consisting
    of all sets that contain `s`. This definition is already in Mathlib and has a
    notation `ğ“Ÿ` (localized in the `Filter` namespace). For the purpose of demonstration,
    we ask you to take this opportunity to work out the definition here.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 'å°†ç±»å‹ `X` ä¸Šçš„è¿‡æ»¤å™¨è§†ä¸º `Set X` çš„å¹¿ä¹‰å…ƒç´ å¯èƒ½æ›´æœ‰ç”¨ã€‚ä¾‹å¦‚ï¼Œ`atTop` æ˜¯â€œéå¸¸å¤§çš„æ•°â€çš„é›†åˆï¼Œè€Œ `ğ“ xâ‚€` æ˜¯â€œéå¸¸æ¥è¿‘ `xâ‚€`
    çš„ç‚¹â€çš„é›†åˆã€‚è¿™ç§è§‚ç‚¹çš„ä¸€ä¸ªè¡¨ç°æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥å°†ä»»ä½• `s : Set X` ä¸æ‰€è°“çš„ *ä¸»è¿‡æ»¤å™¨* å…³è”èµ·æ¥ï¼Œè¯¥è¿‡æ»¤å™¨ç”±åŒ…å« `s` çš„æ‰€æœ‰é›†åˆç»„æˆã€‚è¿™ä¸ªå®šä¹‰å·²ç»åœ¨
    Mathlib ä¸­ï¼Œå¹¶ä¸”æœ‰ `ğ“Ÿ`ï¼ˆåœ¨ `Filter` å‘½åç©ºé—´ä¸­å±€éƒ¨åŒ–ï¼‰çš„ç¬¦å·ã€‚ä¸ºäº†æ¼”ç¤ºç›®çš„ï¼Œæˆ‘ä»¬è¦æ±‚ä½ åˆ©ç”¨è¿™ä¸ªæœºä¼šåœ¨è¿™é‡Œæ¨å¯¼å‡ºå®šä¹‰ã€‚'
- en: '[PRE122]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'For our second example, we ask you to define the filter `atTop : Filter â„•`.
    (We could use any type with a preorder instead of `â„•`.)'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 'å¯¹äºæˆ‘ä»¬çš„ç¬¬äºŒä¸ªä¾‹å­ï¼Œæˆ‘ä»¬è¦æ±‚ä½ å®šä¹‰è¿‡æ»¤å™¨ `atTop : Filter â„•`ã€‚ï¼ˆæˆ‘ä»¬å¯ä»¥ç”¨ä»»ä½•å…·æœ‰ååºçš„ç±»å‹ä»£æ›¿ `â„•`ã€‚ï¼‰'
- en: '[PRE123]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'We can also directly define the filter `ğ“ x` of neighborhoods of any `x : â„`.
    In the real numbers, a neighborhood of `x` is a set containing an open interval
    \((x_0 - \varepsilon, x_0 + \varepsilon)\), defined in Mathlib as `Ioo (xâ‚€ - Îµ)
    (xâ‚€ + Îµ)`. (This notion of a neighborhood is only a special case of a more general
    construction in Mathlib.)'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 'æˆ‘ä»¬è¿˜å¯ä»¥ç›´æ¥å®šä¹‰ä»»ä½• `x : â„` çš„é‚»åŸŸè¿‡æ»¤å™¨ `ğ“ x`ã€‚åœ¨å®æ•°ä¸­ï¼Œ`x` çš„é‚»åŸŸæ˜¯ä¸€ä¸ªåŒ…å«å¼€åŒºé—´ \((x_0 - \varepsilon,
    x_0 + \varepsilon)\) çš„é›†åˆï¼Œåœ¨ Mathlib ä¸­å®šä¹‰ä¸º `Ioo (xâ‚€ - Îµ) (xâ‚€ + Îµ)`ã€‚ï¼ˆè¿™ç§é‚»åŸŸçš„æ¦‚å¿µåªæ˜¯ Mathlib
    ä¸­æ›´ä¸€èˆ¬æ„é€ çš„ä¸€ä¸ªç‰¹ä¾‹ã€‚ï¼‰'
- en: 'With these examples, we can already define what it means for a function `f
    : X â†’ Y` to converge to some `G : Filter Y` along some `F : Filter X`, as follows:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 'é€šè¿‡è¿™äº›ä¾‹å­ï¼Œæˆ‘ä»¬å·²å¯ä»¥å®šä¹‰å‡½æ•° `f : X â†’ Y` æ²¿ç€æŸä¸ª `F : Filter X` æ”¶æ•›åˆ°æŸä¸ª `G : Filter Y` çš„å«ä¹‰ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š'
- en: '[PRE124]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'When `X` is `â„•` and `Y` is `â„`, `Tendstoâ‚ u atTop (ğ“ x)` is equivalent to saying
    that the sequence `u : â„• â†’ â„` converges to the real number `x`. When both `X`
    and `Y` are `â„`, `Tendsto f (ğ“ xâ‚€) (ğ“ yâ‚€)` is equivalent to the familiar notion
    \(\lim_{x \to xâ‚€} f(x) = yâ‚€\). All of the other kinds of limits mentioned in the
    introduction are also equivalent to instances of `Tendstoâ‚` for suitable choices
    of filters on the source and target.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 'å½“ `X` æ˜¯ `â„•` ä¸” `Y` æ˜¯ `â„` æ—¶ï¼Œ`Tendstoâ‚ u atTop (ğ“ x)` ç­‰ä»·äºè¯´åºåˆ— `u : â„• â†’ â„` æ”¶æ•›åˆ°å®æ•°
    `x`ã€‚å½“ `X` å’Œ `Y` éƒ½æ˜¯ `â„` æ—¶ï¼Œ`Tendsto f (ğ“ xâ‚€) (ğ“ yâ‚€)` ç­‰ä»·äºç†Ÿæ‚‰çš„æé™æ¦‚å¿µ \(\lim_{x \to xâ‚€}
    f(x) = yâ‚€\)ã€‚ä»‹ç»ä¸­æåˆ°çš„æ‰€æœ‰å…¶ä»–ç±»å‹çš„æé™ä¹Ÿéƒ½æ˜¯é€šè¿‡åœ¨æºå’Œç›®æ ‡ä¸Šé€‰æ‹©åˆé€‚çš„è¿‡æ»¤å™¨ï¼Œç­‰ä»·äº `Tendstoâ‚` çš„å®ä¾‹ã€‚'
- en: 'The notion `Tendstoâ‚` above is definitionally equivalent to the notion `Tendsto`
    that is defined in Mathlib, but the latter is defined more abstractly. The problem
    with the definition of `Tendstoâ‚` is that it exposes a quantifier and elements
    of `G`, and it hides the intuition that we get by viewing filters as generalized
    sets. We can hide the quantifier `âˆ€ V` and make the intuition more salient by
    using more algebraic and set-theoretic machinery. The first ingredient is the
    *pushforward* operation \(f_*\) associated to any map `f : X â†’ Y`, denoted `Filter.map
    f` in Mathlib. Given a filter `F` on `X`, `Filter.map f F : Filter Y` is defined
    so that `V âˆˆ Filter.map f F â†” f â»Â¹'' V âˆˆ F` holds definitionally. In the example
    file weâ€™ve opened the `Filter` namespace so that `Filter.map` can be written as
    `map`. This means that we can rewrite the definition of `Tendsto` using the order
    relation on `Filter Y`, which is reversed inclusion of the set of members. In
    other words, given `G H : Filter Y`, we have `G â‰¤ H â†” âˆ€ V : Set Y, V âˆˆ H â†’ V âˆˆ
    G`.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¸Šè¿° `Tendstoâ‚` çš„æ¦‚å¿µåœ¨å®šä¹‰ä¸Šæ˜¯ç­‰ä»·äº Mathlib ä¸­å®šä¹‰çš„ `Tendsto` æ¦‚å¿µï¼Œä½†åè€…å®šä¹‰å¾—æ›´æŠ½è±¡ã€‚`Tendstoâ‚` çš„å®šä¹‰é—®é¢˜åœ¨äºå®ƒæš´éœ²äº†ä¸€ä¸ªé‡è¯å’Œ
    `G` çš„å…ƒç´ ï¼Œå¹¶éšè—äº†é€šè¿‡å°†è¿‡æ»¤å™¨è§†ä¸ºå¹¿ä¹‰é›†åˆè€Œè·å¾—çš„ç›´è§‰ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨æ›´å¤šçš„ä»£æ•°å’Œé›†åˆè®ºå·¥å…·æ¥éšè—é‡è¯ `âˆ€ V` å¹¶ä½¿ç›´è§‰æ›´åŠ æ˜æ˜¾ã€‚ç¬¬ä¸€ä¸ªæˆåˆ†æ˜¯ä¸ä»»ä½•æ˜ å°„
    `f : X â†’ Y` å…³è”çš„ *æ¨å‰* æ“ä½œ \(f_*\)ï¼Œåœ¨ Mathlib ä¸­è¡¨ç¤ºä¸º `Filter.map f`ã€‚ç»™å®š `X` ä¸Šçš„è¿‡æ»¤å™¨ `F`ï¼Œ`Filter.map
    f F : Filter Y` è¢«å®šä¹‰ä¸º `V âˆˆ Filter.map f F â†” f â»Â¹'' V âˆˆ F` å®šä¹‰ä¸Šæˆç«‹ã€‚åœ¨æ‰“å¼€çš„ç¤ºä¾‹æ–‡ä»¶ä¸­ï¼Œæˆ‘ä»¬å·²ç»æ‰“å¼€äº†
    `Filter` å‘½åç©ºé—´ï¼Œä»¥ä¾¿å¯ä»¥å°† `Filter.map` å†™ä½œ `map`ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `Filter Y` ä¸Šçš„é¡ºåºå…³ç³»é‡å†™ `Tendsto`
    çš„å®šä¹‰ï¼Œè¿™æ˜¯æˆå‘˜é›†åˆçš„åå‘åŒ…å«ã€‚æ¢å¥è¯è¯´ï¼Œç»™å®š `G H : Filter Y`ï¼Œæˆ‘ä»¬æœ‰ `G â‰¤ H â†” âˆ€ V : Set Y, V âˆˆ H â†’ V âˆˆ
    G`ã€‚'
- en: '[PRE125]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'It may seem that the order relation on filters is backward. But recall that
    we can view filters on `X` as generalized elements of `Set X`, via the inclusion
    of `ğ“Ÿ : Set X â†’ Filter X` which maps any set `s` to the corresponding principal
    filter. This inclusion is order preserving, so the order relation on `Filter`
    can indeed be seen as the natural inclusion relation between generalized sets.
    In this analogy, pushforward is analogous to the direct image. And, indeed, `map
    f (ğ“Ÿ s) = ğ“Ÿ (f '''' s)`.'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 'å¯èƒ½çœ‹èµ·æ¥è¿‡æ»¤å™¨ä¸Šçš„é¡ºåºå…³ç³»æ˜¯åçš„ã€‚ä½†å›æƒ³ä¸€ä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ `ğ“Ÿ : Set X â†’ Filter X` çš„åŒ…å«æ¥å°† `X` ä¸Šçš„è¿‡æ»¤å™¨è§†ä¸º `Set
    X` çš„å¹¿ä¹‰å…ƒç´ ï¼Œè¯¥æ˜ å°„å°†ä»»ä½•é›†åˆ `s` æ˜ å°„åˆ°ç›¸åº”çš„ç´ è¿‡æ»¤å™¨ã€‚è¿™ä¸ªåŒ…å«æ˜¯é¡ºåºä¿æŒçš„ï¼Œæ‰€ä»¥ `Filter` ä¸Šçš„é¡ºåºå…³ç³»ç¡®å®å¯ä»¥çœ‹ä½œæ˜¯å¹¿ä¹‰é›†åˆä¹‹é—´çš„è‡ªç„¶åŒ…å«å…³ç³»ã€‚åœ¨è¿™ä¸ªç±»æ¯”ä¸­ï¼Œæ¨å‰åƒæ˜¯ç›´æ¥åƒã€‚å®é™…ä¸Šï¼Œ`map
    f (ğ“Ÿ s) = ğ“Ÿ (f '''' s)`ã€‚'
- en: 'We can now understand intuitively why a sequence `u : â„• â†’ â„` converges to a
    point `xâ‚€` if and only if we have `map u atTop â‰¤ ğ“ xâ‚€`. The inequality means the
    â€œdirect image under `u`â€ of â€œthe set of very big natural numbersâ€ is â€œincludedâ€
    in â€œthe set of points very close to `xâ‚€`.â€'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥ç›´è§‚åœ°ç†è§£ä¸ºä»€ä¹ˆåºåˆ— `u : â„• â†’ â„` æ”¶æ•›åˆ°ç‚¹ `xâ‚€` å½“ä¸”ä»…å½“ `map u atTop â‰¤ ğ“ xâ‚€`ã€‚ä¸ç­‰å¼æ„å‘³ç€â€œåœ¨
    `u` ä¸‹çš„ç›´æ¥åƒâ€çš„â€œéå¸¸å¤§çš„è‡ªç„¶æ•°é›†åˆâ€åŒ…å«åœ¨â€œéå¸¸æ¥è¿‘ `xâ‚€` çš„ç‚¹é›†åˆâ€ä¸­ã€‚'
- en: As promised, the definition of `Tendstoâ‚‚` does not exhibit any quantifiers or
    sets. It also leverages the algebraic properties of the pushforward operation.
    First, each `Filter.map f` is monotone. And, second, `Filter.map` is compatible
    with composition.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æ‰¿è¯ºçš„é‚£æ ·ï¼Œ`Tendstoâ‚‚`çš„å®šä¹‰æ²¡æœ‰å‡ºç°ä»»ä½•é‡è¯æˆ–é›†åˆã€‚å®ƒè¿˜åˆ©ç”¨äº†æ¨è¿›æ“ä½œçš„ä»£æ•°æ€§è´¨ã€‚é¦–å…ˆï¼Œæ¯ä¸ª`Filter.map f`éƒ½æ˜¯å•è°ƒçš„ã€‚å…¶æ¬¡ï¼Œ`Filter.map`ä¸å¤åˆæ“ä½œå…¼å®¹ã€‚
- en: '[PRE126]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Together these two properties allow us to prove that limits compose, yielding
    in one shot all 512 variants of the composition lemma described in the introduction,
    and lots more. You can practice proving the following statement using either the
    definition of `Tendstoâ‚` in terms of the universal quantifier or the algebraic
    definition, together with the two lemmas above.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸¤ä¸ªæ€§è´¨å…±åŒå…è®¸æˆ‘ä»¬è¯æ˜æé™å¯ä»¥ç»„åˆï¼Œä¸€æ¬¡äº§ç”Ÿä»‹ç»ä¸­æè¿°çš„512ä¸ªç»„åˆå¼•ç†å˜ä½“ï¼Œä»¥åŠæ›´å¤šã€‚ä½ å¯ä»¥ä½¿ç”¨`Tendstoâ‚`çš„å…³äºå…¨ç§°é‡è¯çš„å®šä¹‰æˆ–ä»£æ•°å®šä¹‰ï¼Œä»¥åŠä¸Šè¿°ä¸¤ä¸ªå¼•ç†æ¥è¯æ˜ä»¥ä¸‹é™ˆè¿°ã€‚
- en: '[PRE127]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The pushforward construction uses a map to push filters from the map source
    to the map target. There also a *pullback* operation, `Filter.comap`, going in
    the other direction. This generalizes the preimage operation on sets. For any
    map `f`, `Filter.map f` and `Filter.comap f` form what is known as a *Galois connection*,
    which is to say, they satisfy
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: æ¨è¿›æ„é€ ä½¿ç”¨ä¸€ä¸ªæ˜ å°„å°†è¿‡æ»¤å™¨ä»æ˜ å°„æºæ¨è¿›åˆ°æ˜ å°„ç›®æ ‡ã€‚è¿˜æœ‰ä¸€ä¸ªç›¸åæ–¹å‘çš„*æ‹‰å›*æ“ä½œï¼Œ`Filter.comap`ã€‚è¿™æ¨å¹¿äº†é›†åˆä¸Šçš„å‰åƒæ“ä½œã€‚å¯¹äºä»»ä½•æ˜ å°„`f`ï¼Œ`Filter.map
    f`å’Œ`Filter.comap f`å½¢æˆäº†ä¸€ä¸ªç§°ä¸º*ä¼½ç½—ç“¦è¿æ¥*çš„ç»“æ„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒä»¬æ»¡è¶³
- en: '`Filter.map_le_iff_le_comap : Filter.map f F â‰¤ G â†” F â‰¤ Filter.comap f G`'
  id: totrans-462
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Filter.map_le_iff_le_comap : Filter.map f F â‰¤ G â†” F â‰¤ Filter.comap f G`'
- en: for every `F` and `G`. This operation could be used to provided another formulation
    of `Tendsto` that would be provably (but not definitionally) equivalent to the
    one in Mathlib.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæ¯ä¸ª`F`å’Œ`G`ã€‚è¿™ä¸ªæ“ä½œå¯ä»¥ç”¨æ¥æä¾›`Tendsto`çš„å¦ä¸€ç§è¡¨è¿°ï¼Œè¿™å°†è¯æ˜ä¸Šæ˜¯ï¼ˆä½†ä¸æ˜¯å®šä¹‰ä¸Šï¼‰ç­‰ä»·äºMathlibä¸­çš„è¡¨è¿°ã€‚
- en: 'The `comap` operation can be used to restrict filters to a subtype. For instance,
    suppose we have `f : â„ â†’ â„`, `xâ‚€ : â„` and `yâ‚€ : â„`, and suppose we want to state
    that `f x` approaches `yâ‚€` when `x` approaches `xâ‚€` within the rational numbers.
    We can pull the filter `ğ“ xâ‚€` back to `â„š` using the coercion map `(â†‘) : â„š â†’ â„`
    and state `Tendsto (f âˆ˜ (â†‘) : â„š â†’ â„) (comap (â†‘) (ğ“ xâ‚€)) (ğ“ yâ‚€)`.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '`comap`æ“ä½œå¯ä»¥ç”¨æ¥å°†è¿‡æ»¤å™¨é™åˆ¶ä¸ºå­ç±»å‹ã€‚ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬æœ‰`f : â„ â†’ â„`ï¼Œ`xâ‚€ : â„`å’Œ`yâ‚€ : â„`ï¼Œå¹¶ä¸”å‡è®¾æˆ‘ä»¬æƒ³è¦è¯´æ˜å½“`x`åœ¨æœ‰ç†æ•°å†…æ¥è¿‘`xâ‚€`æ—¶ï¼Œ`f
    x`æ¥è¿‘`yâ‚€`ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¼ºåˆ¶æ˜ å°„`(â†‘) : â„š â†’ â„`å°†è¿‡æ»¤å™¨`ğ“ xâ‚€`æ‹‰å›åˆ°`â„š`ï¼Œå¹¶å£°æ˜`Tendsto (f âˆ˜ (â†‘) : â„š â†’ â„)
    (comap (â†‘) (ğ“ xâ‚€)) (ğ“ yâ‚€)`ã€‚'
- en: '[PRE128]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The pullback operation is also compatible with composition, but it is *contravariant*,
    which is to say, it reverses the order of the arguments.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: æ‹‰å›æ“ä½œä¹Ÿä¸å¤åˆæ“ä½œå…¼å®¹ï¼Œä½†å®ƒå…·æœ‰*é€†å˜å¼‚æ€§*ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒåè½¬äº†å‚æ•°çš„é¡ºåºã€‚
- en: '[PRE129]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Letâ€™s now shift attention to the plane `â„ Ã— â„` and try to understand how the
    neighborhoods of a point `(xâ‚€, yâ‚€)` are related to `ğ“ xâ‚€` and `ğ“ yâ‚€`. There is
    a product operation `Filter.prod : Filter X â†’ Filter Y â†’ Filter (X Ã— Y)`, denoted
    by `Ã—Ë¢`, which answers this question:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç°åœ¨ï¼Œè®©æˆ‘ä»¬å°†æ³¨æ„åŠ›è½¬å‘å¹³é¢`â„ Ã— â„`ï¼Œå¹¶å°è¯•ç†è§£ç‚¹`(xâ‚€, yâ‚€)`çš„é‚»åŸŸå¦‚ä½•ä¸`ğ“ xâ‚€`å’Œ`ğ“ yâ‚€`ç›¸å…³ã€‚å­˜åœ¨ä¸€ä¸ªä¹˜æ³•æ“ä½œ`Filter.prod
    : Filter X â†’ Filter Y â†’ Filter (X Ã— Y)`ï¼Œè¡¨ç¤ºä¸º`Ã—Ë¢`ï¼Œå®ƒå›ç­”äº†è¿™ä¸ªé—®é¢˜ï¼š'
- en: '[PRE130]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The product operation is defined in terms of the pullback operation and the
    `inf` operation:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹˜æ³•æ“ä½œæ˜¯åœ¨æ‹‰å›æ“ä½œå’Œ`inf`æ“ä½œçš„åŸºç¡€ä¸Šå®šä¹‰çš„ï¼š
- en: '`F Ã—Ë¢ G = (comap Prod.fst F) âŠ“ (comap Prod.snd G)`.'
  id: totrans-471
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`F Ã—Ë¢ G = (comap Prod.fst F) âŠ“ (comap Prod.snd G)`ã€‚'
- en: Here the `inf` operation refers to the lattice structure on `Filter X` for any
    type `X`, whereby `F âŠ“ G` is the greatest filter that is smaller than both `F`
    and `G`. Thus the `inf` operation generalizes the notion of the intersection of
    sets.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œï¼Œ`inf`æ“ä½œæŒ‡çš„æ˜¯ä»»ä½•ç±»å‹`X`ä¸Š`Filter X`çš„æ ¼ç»“æ„ï¼Œå…¶ä¸­`F âŠ“ G`æ˜¯å°äº`F`å’Œ`G`ä¸¤è€…çš„æœ€å¤§è¿‡æ»¤å™¨ã€‚å› æ­¤ï¼Œ`inf`æ“ä½œæ¨å¹¿äº†é›†åˆäº¤é›†çš„æ¦‚å¿µã€‚
- en: A lot of proofs in Mathlib use all of the aforementioned structure (`map`, `comap`,
    `inf`, `sup`, and `prod`) to give algebraic proofs about convergence without ever
    referring to members of filters. You can practice doing this in a proof of the
    following lemma, unfolding the definition of `Tendsto` and `Filter.prod` if needed.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlibä¸­çš„è®¸å¤šè¯æ˜éƒ½ä½¿ç”¨äº†ä¸Šè¿°æ‰€æœ‰ç»“æ„ï¼ˆ`map`ã€`comap`ã€`inf`ã€`sup`å’Œ`prod`ï¼‰æ¥ç»™å‡ºå…³äºæ”¶æ•›çš„ä»£æ•°è¯æ˜ï¼Œè€Œä»æœªå¼•ç”¨è¿‡æ»¤å™¨çš„æˆå‘˜ã€‚ä½ å¯ä»¥åœ¨ä»¥ä¸‹å¼•ç†çš„è¯æ˜ä¸­ç»ƒä¹ è¿™æ ·åšï¼Œå¦‚æœéœ€è¦ï¼Œå¯ä»¥å±•å¼€`Tendsto`å’Œ`Filter.prod`çš„å®šä¹‰ã€‚
- en: '[PRE131]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The ordered type `Filter X` is actually a *complete* lattice, which is to say,
    there is a bottom element, there is a top element, and every set of filters on
    `X` has an `Inf` and a `Sup`.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰åºç±»å‹`Filter X`å®é™…ä¸Šæ˜¯ä¸€ä¸ª*å®Œå¤‡*æ ¼ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå­˜åœ¨ä¸€ä¸ªåº•å…ƒç´ ï¼Œå­˜åœ¨ä¸€ä¸ªé¡¶å…ƒç´ ï¼Œå¹¶ä¸”`X`ä¸Šçš„æ¯ä¸ªè¿‡æ»¤å™¨é›†åˆéƒ½æœ‰ä¸€ä¸ª`Inf`å’Œ`Sup`ã€‚
- en: 'Note that given the second property in the definition of a filter (if `U` belongs
    to `F` then anything larger than `U` also belongs to `F`), the first property
    (the set of all inhabitants of `X` belongs to `F`) is equivalent to the property
    that `F` is not the empty collection of sets. This shouldnâ€™t be confused with
    the more subtle question as to whether the empty set is an *element* of `F`. The
    definition of a filter does not prohibit `âˆ… âˆˆ F`, but if the empty set is in `F`
    then every set is in `F`, which is to say, `âˆ€ U : Set X, U âˆˆ F`. In this case,
    `F` is a rather trivial filter, which is precisely the bottom element of the complete
    lattice `Filter X`. This contrasts with the definition of filters in Bourbaki,
    which doesnâ€™t allow filters containing the empty set.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ³¨æ„ï¼Œæ ¹æ®æ»¤æ³¢å™¨å®šä¹‰ä¸­çš„ç¬¬äºŒä¸ªæ€§è´¨ï¼ˆå¦‚æœ`U`å±äº`F`ï¼Œé‚£ä¹ˆä»»ä½•å¤§äº`U`çš„é›†åˆä¹Ÿå±äº`F`ï¼‰ï¼Œç¬¬ä¸€ä¸ªæ€§è´¨ï¼ˆæ‰€æœ‰`X`çš„å±…æ°‘é›†åˆå±äº`F`ï¼‰ç­‰ä»·äº`F`ä¸æ˜¯ç©ºé›†åˆé›†åˆçš„æ€§è´¨ã€‚è¿™ä¸åº”è¯¥ä¸æ›´å¾®å¦™çš„é—®é¢˜æ··æ·†ï¼Œå³ç©ºé›†æ˜¯å¦æ˜¯`F`çš„**å…ƒç´ **ã€‚æ»¤æ³¢å™¨çš„å®šä¹‰å¹¶ä¸ç¦æ­¢`âˆ…
    âˆˆ F`ï¼Œä½†å¦‚æœç©ºé›†åœ¨`F`ä¸­ï¼Œé‚£ä¹ˆæ¯ä¸€ä¸ªé›†åˆéƒ½åœ¨`F`ä¸­ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œ`âˆ€ U : Set X, U âˆˆ F`ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ`F`æ˜¯ä¸€ä¸ªç›¸å½“å¹³å‡¡çš„æ»¤æ³¢å™¨ï¼Œè¿™æ­£æ˜¯å®Œå¤‡æ ¼`Filter
    X`çš„åº•å…ƒç´ ã€‚è¿™ä¸Bourbakiä¸­æ»¤æ³¢å™¨çš„å®šä¹‰å½¢æˆå¯¹æ¯”ï¼Œåè€…ä¸å…è®¸åŒ…å«ç©ºé›†çš„æ»¤æ³¢å™¨ã€‚'
- en: 'Because we include the trivial filter in our definition, we sometimes need
    to explicitly assume nontriviality in some lemmas. In return, however, the theory
    has nicer global properties. We have already seen that including the trivial filter
    gives us a bottom element. It also allows us to define `principal : Set X â†’ Filter
    X`, which maps `âˆ…` to `âŠ¥`, without adding a precondition to rule out the empty
    set. And it allows us to define the pullback operation without a precondition
    as well. Indeed, it can happen that `comap f F = âŠ¥` although `F â‰  âŠ¥`. For instance,
    given `xâ‚€ : â„` and `s : Set â„`, the pullback of `ğ“ xâ‚€` under the coercion from
    the subtype corresponding to `s` is nontrivial if and only if `xâ‚€` belongs to
    the closure of `s`.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç”±äºæˆ‘ä»¬åœ¨å®šä¹‰ä¸­åŒ…æ‹¬äº†å¹³å‡¡æ»¤æ³¢å™¨ï¼Œæˆ‘ä»¬æœ‰æ—¶éœ€è¦åœ¨æŸäº›å¼•ç†ä¸­æ˜ç¡®å‡è®¾éå¹³å‡¡æ€§ã€‚ç„¶è€Œï¼Œä½œä¸ºå›æŠ¥ï¼Œç†è®ºå…·æœ‰æ›´æ¼‚äº®çš„å…¨å±€æ€§è´¨ã€‚æˆ‘ä»¬å·²ç»çœ‹åˆ°ï¼ŒåŒ…æ‹¬å¹³å‡¡æ»¤æ³¢å™¨ç»™æˆ‘ä»¬æä¾›äº†ä¸€ä¸ªåº•å…ƒç´ ã€‚å®ƒè¿˜å…è®¸æˆ‘ä»¬å®šä¹‰`principal
    : Set X â†’ Filter X`ï¼Œå®ƒå°†`âˆ…`æ˜ å°„åˆ°`âŠ¥`ï¼Œè€Œä¸éœ€è¦æ·»åŠ ä¸€ä¸ªå…ˆå†³æ¡ä»¶æ¥æ’é™¤ç©ºé›†ã€‚å®ƒè¿˜å…è®¸æˆ‘ä»¬å®šä¹‰æ²¡æœ‰å…ˆå†³æ¡ä»¶çš„æ‹‰å›æ“ä½œã€‚å®é™…ä¸Šï¼Œå¯èƒ½ä¼šå‘ç”Ÿ`comap
    f F = âŠ¥`å°½ç®¡`F â‰  âŠ¥`ã€‚ä¾‹å¦‚ï¼Œç»™å®š`xâ‚€ : â„`å’Œ`s : Set â„`ï¼Œä»å¯¹åº”äº`s`çš„å­ç±»å‹å¼ºåˆ¶è½¬æ¢ä¸‹çš„`ğ“ xâ‚€`çš„æ‹‰å›æ˜¯éå¹³å‡¡çš„ï¼Œå½“ä¸”ä»…å½“`xâ‚€`å±äº`s`çš„é—­åŒ…ã€‚'
- en: 'In order to manage lemmas that do need to assume some filter is nontrivial,
    Mathlib has a type class `Filter.NeBot`, and the library has lemmas that assume
    `(F : Filter X) [F.NeBot]`. The instance database knows, for example, that `(atTop
    : Filter â„•).NeBot`, and it knows that pushing forward a nontrivial filter gives
    a nontrivial filter. As a result, a lemma assuming `[F.NeBot]` will automatically
    apply to `map u atTop` for any sequence `u`.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¸ºäº†ç®¡ç†éœ€è¦å‡è®¾æŸäº›æ»¤æ³¢å™¨æ˜¯éå¹³å‡¡çš„å¼•ç†ï¼ŒMathlibæœ‰ä¸€ä¸ªç±»å‹ç±»`Filter.NeBot`ï¼Œåº“ä¸­æœ‰å‡è®¾`(F : Filter X) [F.NeBot]`çš„å¼•ç†ã€‚å®ä¾‹æ•°æ®åº“çŸ¥é“ï¼Œä¾‹å¦‚ï¼Œ`(atTop
    : Filter â„•).NeBot`ï¼Œå®ƒçŸ¥é“å‘å‰ä¼ é€’ä¸€ä¸ªéå¹³å‡¡æ»¤æ³¢å™¨ä¼šå¾—åˆ°ä¸€ä¸ªéå¹³å‡¡æ»¤æ³¢å™¨ã€‚å› æ­¤ï¼Œå‡è®¾`[F.NeBot]`çš„å¼•ç†å°†è‡ªåŠ¨é€‚ç”¨äºä»»ä½•åºåˆ—`u`çš„`map
    u atTop`ã€‚'
- en: Our tour of the algebraic properties of filters and their relation to limits
    is essentially done, but we have not yet justified our claim to have recaptured
    the usual limit notions. Superficially, it may seem that `Tendsto u atTop (ğ“ xâ‚€)`
    is stronger than the notion of convergence defined in [Section 3.6](C03_Logic.html#sequences-and-convergence)
    because we ask that *every* neighborhood of `xâ‚€` has a preimage belonging to `atTop`,
    whereas the usual definition only requires this for the standard neighborhoods
    `Ioo (xâ‚€ - Îµ) (xâ‚€ + Îµ)`. The key is that, by definition, every neighborhood contains
    such a standard one. This observation leads to the notion of a *filter basis*.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯¹æ»¤æ³¢å™¨çš„ä»£æ•°æ€§è´¨åŠå…¶ä¸æé™çš„å…³ç³»çš„è€ƒå¯ŸåŸºæœ¬ä¸Šå·²ç»å®Œæˆï¼Œä½†æˆ‘ä»¬è¿˜æ²¡æœ‰è¯æ˜æˆ‘ä»¬é‡æ–°è·å¾—äº†é€šå¸¸çš„æé™æ¦‚å¿µã€‚è¡¨é¢ä¸Šï¼Œ`Tendsto u atTop (ğ“
    xâ‚€)`ä¼¼ä¹æ¯”[ç¬¬3.6èŠ‚](C03_Logic.html#sequences-and-convergence)ä¸­å®šä¹‰çš„æ”¶æ•›æ€§æ¦‚å¿µæ›´å¼ºï¼Œå› ä¸ºæˆ‘ä»¬è¦æ±‚`xâ‚€`çš„æ¯ä¸€ä¸ªé‚»åŸŸéƒ½æœ‰ä¸€ä¸ªå±äº`atTop`çš„é€†åƒï¼Œè€Œé€šå¸¸çš„å®šä¹‰åªè¦æ±‚å¯¹äºæ ‡å‡†é‚»åŸŸ`Ioo
    (xâ‚€ - Îµ) (xâ‚€ + Îµ)`æ˜¯è¿™æ ·çš„ã€‚å…³é”®æ˜¯ï¼Œæ ¹æ®å®šä¹‰ï¼Œæ¯ä¸€ä¸ªé‚»åŸŸéƒ½åŒ…å«è¿™æ ·çš„æ ‡å‡†é‚»åŸŸã€‚è¿™ä¸ªè§‚å¯Ÿå¯¼è‡´äº†ä¸€ä¸ª**æ»¤æ³¢åŸº**çš„æ¦‚å¿µã€‚
- en: 'Given `F : Filter X`, a family of sets `s : Î¹ â†’ Set X` is a basis for `F` if
    for every set `U`, we have `U âˆˆ F` if and only if it contains some `s i`. In other
    words, formally speaking, `s` is a basis if it satisfies `âˆ€ U : Set X, U âˆˆ F â†”
    âˆƒ i, s i âŠ† U`. It is even more flexible to consider a predicate on `Î¹` that selects
    only some of the values `i` in the indexing type. In the case of `ğ“ xâ‚€`, we want
    `Î¹` to be `â„`, we write `Îµ` for `i`, and the predicate should select the positive
    values of `Îµ`. So the fact that the sets `IooÂ  (xâ‚€ - Îµ) (xâ‚€ + Îµ)` form a basis
    for the neighborhood topology on `â„` is stated as follows:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç»™å®š `F : Filter X`ï¼Œä¸€ä¸ªé›†åˆæ— `s : Î¹ â†’ Set X` æ˜¯ `F` çš„åŸºå½“ä¸”ä»…å½“å¯¹äºæ¯ä¸€ä¸ªé›†åˆ `U`ï¼Œå¦‚æœä¸”ä»…å½“å®ƒåŒ…å«æŸäº›
    `s i`ï¼Œåˆ™ `U âˆˆ F`ã€‚æ¢å¥è¯è¯´ï¼Œä»å½¢å¼ä¸Šè®²ï¼Œå¦‚æœ `s` æ»¡è¶³ `âˆ€ U : Set X, U âˆˆ F â†” âˆƒ i, s i âŠ† U`ï¼Œåˆ™ `s`
    æ˜¯ä¸€ä¸ªåŸºã€‚è€ƒè™‘åœ¨ `Î¹` ä¸Šçš„ä¸€ä¸ªè°“è¯ï¼Œå®ƒåªé€‰æ‹©ç´¢å¼•ç±»å‹ä¸­çš„æŸäº›å€¼ `i`ï¼Œè¿™ç”šè‡³æ›´åŠ çµæ´»ã€‚åœ¨ `ğ“ xâ‚€` çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¸Œæœ› `Î¹` æ˜¯ `â„`ï¼Œæˆ‘ä»¬ç”¨
    `Îµ` è¡¨ç¤º `i`ï¼Œè°“è¯åº”è¯¥é€‰æ‹© `Îµ` çš„æ­£å€¼ã€‚å› æ­¤ï¼Œé›†åˆ `IooÂ  (xâ‚€ - Îµ) (xâ‚€ + Îµ)` å½¢æˆå®æ•°é‚»åŸŸæ‹“æ‰‘çš„åŸºçš„äº‹å®è¡¨è¿°å¦‚ä¸‹ï¼š'
- en: '[PRE132]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: There is also a nice basis for the filter `atTop`. The lemma `Filter.HasBasis.tendsto_iff`
    allows us to reformulate a statement of the form `Tendsto f F G` given bases for
    `F` and `G`. Putting these pieces together gives us essentially the notion of
    convergence that we used in [Section 3.6](C03_Logic.html#sequences-and-convergence).
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äº `atTop` è¿‡æ»¤å™¨ä¹Ÿæœ‰ä¸€ä¸ªå¾ˆå¥½çš„åŸºã€‚å¼•ç† `Filter.HasBasis.tendsto_iff` å…è®¸æˆ‘ä»¬ç”¨ `F` å’Œ `G` çš„åŸºé‡æ–°è¡¨è¿°å½¢å¼ä¸º
    `Tendsto f F G` çš„é™ˆè¿°ã€‚å°†è¿™äº›éƒ¨åˆ†æ”¾åœ¨ä¸€èµ·ï¼Œæˆ‘ä»¬åŸºæœ¬ä¸Šå¾—åˆ°äº†æˆ‘ä»¬åœ¨ [ç¬¬ 3.6 èŠ‚](C03_Logic.html#sequences-and-convergence)
    ä¸­ä½¿ç”¨çš„æ”¶æ•›çš„æ¦‚å¿µã€‚
- en: '[PRE133]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: We now show how filters facilitate working with properties that hold for sufficiently
    large numbers or for points that are sufficiently close to a given point. In [Section
    3.6](C03_Logic.html#sequences-and-convergence), we were often faced with the situation
    where we knew that some property `P n` holds for sufficiently large `n` and that
    some other property `Q n` holds for sufficiently large `n`. Using `cases` twice
    gave us `N_P` and `N_Q` satisfying `âˆ€ n â‰¥ N_P, P n` and `âˆ€ n â‰¥ N_Q, Q n`. Using
    `set N := max N_P N_Q`, we could eventually prove `âˆ€ n â‰¥ N, P n âˆ§ Q n`. Doing
    this repeatedly becomes tiresome.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å°†å±•ç¤ºè¿‡æ»¤å™¨å¦‚ä½•å¸®åŠ©å¤„ç†å¯¹äºè¶³å¤Ÿå¤§çš„æ•°å­—æˆ–å¯¹äºè¶³å¤Ÿæ¥è¿‘ç»™å®šç‚¹çš„ç‚¹æ‰€æŒæœ‰çš„å±æ€§ã€‚åœ¨ [ç¬¬ 3.6 èŠ‚](C03_Logic.html#sequences-and-convergence)
    ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸é¢ä¸´è¿™æ ·çš„æƒ…å†µï¼šæˆ‘ä»¬çŸ¥é“æŸäº›å±æ€§ `P n` å¯¹äºè¶³å¤Ÿå¤§çš„ `n` æˆç«‹ï¼Œè€Œå…¶ä»–å±æ€§ `Q n` å¯¹äºè¶³å¤Ÿå¤§çš„ `n` æˆç«‹ã€‚ä½¿ç”¨ `cases`
    ä¸¤æ¬¡ç»™å‡ºäº†æ»¡è¶³ `âˆ€ n â‰¥ N_P, P n` å’Œ `âˆ€ n â‰¥ N_Q, Q n` çš„ `N_P` å’Œ `N_Q`ã€‚ä½¿ç”¨ `set N := max N_P
    N_Q`ï¼Œæˆ‘ä»¬æœ€ç»ˆå¯ä»¥è¯æ˜ `âˆ€ n â‰¥ N, P n âˆ§ Q n`ã€‚é‡å¤è¿™æ ·åšä¼šå˜å¾—ä»¤äººåŒçƒ¦ã€‚
- en: 'We can do better by noting that the statement â€œ`P n` and `Q n` hold for large
    enough `n`â€ means that we have `{n | P n} âˆˆ atTop` and `{n | Q n} âˆˆ atTop`. The
    fact that `atTop` is a filter implies that the intersection of two elements of
    `atTop` is again in `atTop`, so we have `{n | P n âˆ§ Q n} âˆˆ atTop`. Writing `{n
    | P n} âˆˆ atTop` is unpleasant, but we can use the more suggestive notation `âˆ€á¶ 
    n in atTop, P n`. Here the superscripted `f` stands for â€œFilter.â€ You can think
    of the notation as saying that for all `n` in the â€œset of very large numbers,â€
    `P n` holds. The `âˆ€á¶ ` notation stands for `Filter.Eventually`, and the lemma `Filter.Eventually.and`
    uses the intersection property of filters to do what we just described:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡æ³¨æ„åˆ°é™ˆè¿°â€œ`P n` å’Œ `Q n` å¯¹äºè¶³å¤Ÿå¤§çš„ `n` æˆç«‹â€æ„å‘³ç€æˆ‘ä»¬æœ‰ä¸€ä¸ª `{n | P n} âˆˆ atTop` å’Œ `{n | Q n}
    âˆˆ atTop`ï¼Œæˆ‘ä»¬å¯ä»¥åšå¾—æ›´å¥½ã€‚`atTop` æ˜¯ä¸€ä¸ªè¿‡æ»¤å™¨çš„äº‹å®æ„å‘³ç€ `atTop` ä¸­ä¸¤ä¸ªå…ƒç´ çš„äº¤é›†å†æ¬¡åœ¨ `atTop` ä¸­ï¼Œå› æ­¤æˆ‘ä»¬å¾—åˆ° `{n
    | P n âˆ§ Q n} âˆˆ atTop`ã€‚å†™ä½œ `{n | P n} âˆˆ atTop` æ˜¯ä¸æ„‰å¿«çš„ï¼Œä½†æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ›´å…·è¯´æ˜æ€§çš„ç¬¦å· `âˆ€á¶  n in atTop,
    P n`ã€‚è¿™é‡Œä¸Šæ ‡çš„ `f` ä»£è¡¨â€œFilterâ€ã€‚ä½ å¯ä»¥å°†è¿™ä¸ªç¬¦å·ç†è§£ä¸ºå¯¹äºæ‰€æœ‰åœ¨â€œéå¸¸å¤§çš„æ•°å­—é›†åˆâ€ä¸­çš„ `n`ï¼Œ`P n` æˆç«‹ã€‚`âˆ€á¶ ` ç¬¦å·ä»£è¡¨
    `Filter.Eventually`ï¼Œå¼•ç† `Filter.Eventually.and` ä½¿ç”¨è¿‡æ»¤å™¨çš„äº¤é›†å±æ€§æ¥å®Œæˆæˆ‘ä»¬åˆšæ‰æè¿°çš„å·¥ä½œï¼š
- en: '[PRE134]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: This notation is so convenient and intuitive that we also have specializations
    when `P` is an equality or inequality statement. For example, let `u` and `v`
    be two sequences of real numbers, and let us show that if `u n` and `v n` coincide
    for sufficiently large `n` then `u` tends to `xâ‚€` if and only if `v` tends to
    `xâ‚€`. First weâ€™ll use the generic `Eventually` and then the one specialized for
    the equality predicate, `EventuallyEq`. The two statements are definitionally
    equivalent so the same proof work in both cases.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§è®°æ³•æ—¢æ–¹ä¾¿åˆç›´è§‚ï¼Œä»¥è‡³äºå½“ `P` æ˜¯ä¸€ä¸ªç­‰å¼æˆ–ä¸ç­‰å¼é™ˆè¿°æ—¶ï¼Œæˆ‘ä»¬ä¹Ÿæœ‰ä¸“é—¨çš„å®šä¹‰ã€‚ä¾‹å¦‚ï¼Œè®¾ `u` å’Œ `v` æ˜¯ä¸¤ä¸ªå®æ•°åºåˆ—ï¼Œæˆ‘ä»¬å°†è¯æ˜å¦‚æœ `u
    n` å’Œ `v n` åœ¨è¶³å¤Ÿå¤§çš„ `n` ä¸Šç›¸åŒï¼Œåˆ™ `u` è¶‹äº `xâ‚€` å½“ä¸”ä»…å½“ `v` è¶‹äº `xâ‚€`ã€‚é¦–å…ˆæˆ‘ä»¬å°†ä½¿ç”¨é€šç”¨çš„ `Eventually`ï¼Œç„¶åæ˜¯ä¸“é—¨é’ˆå¯¹ç­‰å¼è°“è¯çš„
    `EventuallyEq`ã€‚è¿™ä¸¤ä¸ªé™ˆè¿°åœ¨å®šä¹‰ä¸Šæ˜¯ç­‰ä»·çš„ï¼Œæ‰€ä»¥ä¸¤ç§æƒ…å†µä¸‹çš„è¯æ˜å·¥ä½œç›¸åŒã€‚
- en: '[PRE135]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'It is instructive to review the definition of filters in terms of `Eventually`.
    Given `F : Filter X`, for any predicates `P` and `Q` on `X`,'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 'å›é¡¾ `Eventually` æœ¯è¯­ä¸‹çš„è¿‡æ»¤å™¨å®šä¹‰æ˜¯æœ‰ç›Šçš„ã€‚ç»™å®š `F : Filter X`ï¼Œå¯¹äº `X` ä¸Šçš„ä»»ä½•è°“è¯ `P` å’Œ `Q`ï¼Œ'
- en: the condition `univ âˆˆ F` ensures `(âˆ€ x, P x) â†’ âˆ€á¶  x in F, P x`,
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¡ä»¶`univ âˆˆ F`ç¡®ä¿`(âˆ€ x, P x) â†’ âˆ€á¶  x in F, P x`ï¼Œ
- en: the condition `U âˆˆ F â†’ U âŠ† V â†’ V âˆˆ F` ensures `(âˆ€á¶  x in F, P x) â†’ (âˆ€ x, P x
    â†’ Q x) â†’ âˆ€á¶  x in F, Q x`, and
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¡ä»¶`U âˆˆ F â†’ U âŠ† V â†’ V âˆˆ F`ç¡®ä¿`(âˆ€á¶  x in F, P x) â†’ (âˆ€ x, P x â†’ Q x) â†’ âˆ€á¶  x in F,
    Q x`ï¼Œ
- en: the condition `U âˆˆ F â†’ V âˆˆ F â†’ U âˆ© V âˆˆ F` ensures `(âˆ€á¶  x in F, P x) â†’ (âˆ€á¶  x
    in F, Q x) â†’ âˆ€á¶  x in F, P x âˆ§ Q x`.
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¡ä»¶`U âˆˆ F â†’ V âˆˆ F â†’ U âˆ© V âˆˆ F`ç¡®ä¿`(âˆ€á¶  x in F, P x) â†’ (âˆ€á¶  x in F, Q x) â†’ âˆ€á¶  x in
    F, P x âˆ§ Q x`ã€‚
- en: '[PRE136]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The second item, corresponding to `Eventually.mono`, supports nice ways of
    using filters, especially when combined with `Eventually.and`. The `filter_upwards`
    tactic allows us to combine them. Compare:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬äºŒé¡¹ï¼Œå¯¹åº”äº`Eventually.mono`ï¼Œæ”¯æŒä½¿ç”¨è¿‡æ»¤å™¨çš„ä¼˜é›…æ–¹å¼ï¼Œç‰¹åˆ«æ˜¯å½“ä¸`Eventually.and`ç»“åˆä½¿ç”¨æ—¶ã€‚`filter_upwards`ç­–ç•¥å…è®¸æˆ‘ä»¬ç»„åˆå®ƒä»¬ã€‚æ¯”è¾ƒï¼š
- en: '[PRE137]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Readers who know about measure theory will note that the filter `Î¼.ae` of sets
    whose complement has measure zero (aka â€œthe set consisting of almost every pointâ€)
    is not very useful as the source or target of `Tendsto`, but it can be conveniently
    used with `Eventually` to say that a property holds for almost every point.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: äº†è§£æµ‹åº¦ç†è®ºçš„è¯»è€…ä¼šæ³¨æ„åˆ°ï¼Œé›†åˆçš„è¡¥é›†æµ‹åº¦ä¸ºé›¶ï¼ˆå³â€œå‡ ä¹æ¯ä¸ªç‚¹çš„é›†åˆâ€ï¼‰çš„è¿‡æ»¤å™¨`Î¼.ae`ä½œä¸º`Tendsto`çš„æºæˆ–ç›®æ ‡å¹¶ä¸ååˆ†æœ‰ç”¨ï¼Œä½†å®ƒå¯ä»¥æ–¹ä¾¿åœ°ä¸`Eventually`ç»“åˆä½¿ç”¨ï¼Œä»¥è¡¨æ˜æŸä¸ªå±æ€§å¯¹å‡ ä¹æ‰€æœ‰ç‚¹éƒ½æˆç«‹ã€‚
- en: 'There is a dual version of `âˆ€á¶  x in F, P x`, which is occasionally useful:
    `âˆƒá¶  x in F, P x` means `{x | Â¬P x} âˆ‰ F`. For example, `âˆƒá¶  n in atTop, P n` means
    there are arbitrarily large `n` such that `P n` holds. The `âˆƒá¶ ` notation stands
    for `Filter.Frequently`.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: å­˜åœ¨ä¸€ä¸ªä¸`âˆ€á¶  x in F, P x`ç›¸å¯¹åº”çš„å¯¹å¶ç‰ˆæœ¬ï¼Œå¶å°”å¾ˆæœ‰ç”¨ï¼š`âˆƒá¶  x in F, P x`æ„å‘³ç€`{x | Â¬P x} âˆ‰ F`ã€‚ä¾‹å¦‚ï¼Œ`âˆƒá¶ 
    n in atTop, P n`æ„å‘³ç€å­˜åœ¨ä»»æ„å¤§çš„`n`ä½¿å¾—`P n`æˆç«‹ã€‚`âˆƒá¶ `ç¬¦å·ä»£è¡¨`Filter.Frequently`ã€‚
- en: 'For a more sophisticated example, consider the following statement about a
    sequence `u`, a set `M`, and a value `x`:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºä¸€ä¸ªæ›´å¤æ‚çš„ä¾‹å­ï¼Œè€ƒè™‘ä»¥ä¸‹å…³äºåºåˆ—`u`ã€é›†åˆ`M`å’Œå€¼`x`çš„é™ˆè¿°ï¼š
- en: If `u` converges to `x` and `u n` belongs to `M` for sufficiently large `n`
    then `x` is in the closure of `M`.
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœ`u`æ”¶æ•›åˆ°`x`ä¸”å¯¹äºè¶³å¤Ÿå¤§çš„`n`ï¼Œ`u n`å±äº`M`ï¼Œé‚£ä¹ˆ`x`åœ¨`M`çš„é—­é›†ä¸­ã€‚
- en: 'This can be formalized as follows:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯ä»¥å½¢å¼åŒ–ä¸ºä»¥ä¸‹å†…å®¹ï¼š
- en: '`Tendsto u atTop (ğ“ x) â†’ (âˆ€á¶  n in atTop, u n âˆˆ M) â†’ x âˆˆ closure M`.'
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Tendsto u atTop (ğ“ x) â†’ (âˆ€á¶  n in atTop, u n âˆˆ M) â†’ x âˆˆ closure M`ã€‚'
- en: This is a special case of the theorem `mem_closure_of_tendsto` from the topology
    library. See if you can prove it using the quoted lemmas, using the fact that
    `ClusterPt x F` means `(ğ“ x âŠ“ F).NeBot` and that, by definition, the assumption
    `âˆ€á¶  n in atTop, u n âˆˆ M` means `M âˆˆ map u atTop`.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æ‹“æ‰‘åº“ä¸­å®šç†`mem_closure_of_tendsto`çš„ä¸€ä¸ªç‰¹ä¾‹ã€‚çœ‹çœ‹ä½ æ˜¯å¦å¯ä»¥ç”¨å¼•ç”¨çš„å¼•ç†æ¥è¯æ˜å®ƒï¼Œåˆ©ç”¨`ClusterPt x F`è¡¨ç¤º`(ğ“
    x âŠ“ F).NeBot`ï¼Œä»¥åŠæ ¹æ®å®šä¹‰ï¼Œå‡è®¾`âˆ€á¶  n in atTop, u n âˆˆ M`æ„å‘³ç€`M âˆˆ map u atTop`ã€‚
- en: '[PRE138]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '## 11.2\. Metric spaces[ïƒ](#metric-spaces "Link to this heading")'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '## 11.2. åº¦é‡ç©ºé—´[ïƒ](#metric-spaces "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")'
- en: 'Examples in the previous section focus on sequences of real numbers. In this
    section we will go up a bit in generality and focus on metric spaces. A metric
    space is a type `X` equipped with a distance function `dist : X â†’ X â†’ â„` which
    is a generalization of the function `fun x y â†¦ |x - y|` from the case where `X
    = â„`.'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¸Šä¸€èŠ‚ä¸­çš„ä¾‹å­ä¸»è¦å…³æ³¨å®æ•°åºåˆ—ã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†æé«˜ä¸€ç‚¹æ™®éæ€§ï¼Œå…³æ³¨åº¦é‡ç©ºé—´ã€‚åº¦é‡ç©ºé—´æ˜¯ä¸€ä¸ªç±»å‹`X`ï¼Œå®ƒé…å¤‡äº†ä¸€ä¸ªè·ç¦»å‡½æ•°`dist : X â†’ X
    â†’ â„`ï¼Œè¿™æ˜¯ä»`X = â„`çš„æƒ…å†µä¸‹çš„å‡½æ•°`fun x y â†¦ |x - y|`çš„æ¨å¹¿ã€‚'
- en: Introducing such a space is easy and we will check all properties required from
    the distance function.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: å¼•å…¥è¿™æ ·çš„ç©ºé—´å¾ˆå®¹æ˜“ï¼Œæˆ‘ä»¬å°†æ£€æŸ¥è·ç¦»å‡½æ•°æ‰€éœ€çš„æ‰€æœ‰å±æ€§ã€‚
- en: '[PRE139]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Note we also have variants where the distance can be infinite or where `dist
    a b` can be zero without having `a = b` or both. They are called `EMetricSpace`,
    `PseudoMetricSpace` and `PseudoEMetricSpace` respectively (here â€œeâ€ stands for
    â€œextendedâ€).
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„æˆ‘ä»¬è¿˜æœ‰å˜ä½“ï¼Œå…¶ä¸­è·ç¦»å¯ä»¥æ˜¯æ— é™çš„ï¼Œæˆ–è€…`dist a b`å¯ä»¥æ˜¯é›¶ï¼Œè€Œ`a â‰  b`æˆ–ä¸¤è€…éƒ½ä¸æˆç«‹ã€‚å®ƒä»¬åˆ†åˆ«ç§°ä¸º`EMetricSpace`ã€`PseudoMetricSpace`å’Œ`PseudoEMetricSpace`ï¼ˆè¿™é‡Œçš„â€œeâ€ä»£è¡¨â€œæ‰©å±•â€ï¼‰ã€‚
- en: Note that our journey from `â„` to metric spaces jumped over the special case
    of normed spaces that also require linear algebra and will be explained as part
    of the calculus chapter.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬ä»`â„`åˆ°åº¦é‡ç©ºé—´çš„è¿‡ç¨‹ä¸­è·³è¿‡äº†éœ€è¦çº¿æ€§ä»£æ•°çš„ç‰¹æ®Šæƒ…å†µçš„èŒƒæ•°ç©ºé—´ï¼Œè¿™å°†åœ¨å¾®ç§¯åˆ†ç« èŠ‚ä¸­è§£é‡Šã€‚
- en: 11.2.1\. Convergence and continuity[ïƒ](#convergence-and-continuity "Link to
    this heading")
  id: totrans-510
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1. æ”¶æ•›ä¸è¿ç»­æ€§[ïƒ](#convergence-and-continuity "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")
- en: Using distance functions, we can already define convergent sequences and continuous
    functions between metric spaces. They are actually defined in a more general setting
    covered in the next section, but we have lemmas recasting the definition in terms
    of distances.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è·ç¦»å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨åº¦é‡ç©ºé—´ä¹‹é—´å®šä¹‰æ”¶æ•›åºåˆ—å’Œè¿ç»­å‡½æ•°ã€‚å®é™…ä¸Šï¼Œå®ƒä»¬åœ¨ä¸‹ä¸€èŠ‚ä¸­æ›´ä¸€èˆ¬çš„è®¾ç½®ä¸­å®šä¹‰ï¼Œä½†æˆ‘ä»¬æœ‰å°†å®šä¹‰é‡æ–°è¡¨è¿°ä¸ºè·ç¦»çš„å¼•ç†ã€‚
- en: '[PRE140]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: A *lot* of lemmas have some continuity assumptions, so we end up proving a lot
    of continuity results and there is a `continuity` tactic devoted to this task.
    Letâ€™s prove a continuity statement that will be needed in an exercise below. Notice
    that Lean knows how to treat a product of two metric spaces as a metric space,
    so it makes sense to consider continuous functions from `X Ã— X` to `â„`. In particular
    the (uncurried version of the) distance function is such a function.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: è®¸å¤šå¼•ç†éƒ½æœ‰ä¸€äº›è¿ç»­æ€§å‡è®¾ï¼Œæ‰€ä»¥æˆ‘ä»¬æœ€ç»ˆè¯æ˜äº†è®¸å¤šè¿ç»­æ€§ç»“æœï¼Œå¹¶ä¸”æœ‰ä¸€ä¸ªä¸“é—¨ç”¨äºè¿™ä¸ªä»»åŠ¡çš„`è¿ç»­æ€§`ç­–ç•¥ã€‚è®©æˆ‘ä»¬è¯æ˜ä¸€ä¸ªåœ¨ä¸‹é¢çš„ç»ƒä¹ ä¸­éœ€è¦çš„è¿ç»­æ€§é™ˆè¿°ã€‚æ³¨æ„ï¼ŒLeançŸ¥é“å¦‚ä½•å°†ä¸¤ä¸ªåº¦é‡ç©ºé—´çš„äº§å“è§†ä¸ºåº¦é‡ç©ºé—´ï¼Œå› æ­¤è€ƒè™‘ä»`X
    Ã— X`åˆ°`â„`çš„è¿ç»­å‡½æ•°æ˜¯æœ‰æ„ä¹‰çš„ã€‚ç‰¹åˆ«æ˜¯ï¼Œè·ç¦»å‡½æ•°ï¼ˆæœªå±•å¼€ç‰ˆæœ¬ï¼‰å°±æ˜¯è¿™æ ·ä¸€ç§å‡½æ•°ã€‚
- en: '[PRE141]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'This tactic is a bit slow, so it is also useful to know how to do it by hand.
    We first need to use that `fun p : X Ã— X â†¦ f p.1` is continuous because it is
    the composition of `f`, which is continuous by assumption `hf`, and the projection
    `prod.fst` whose continuity is the content of the lemma `continuous_fst`. The
    composition property is `Continuous.comp` which is in the `Continuous` namespace
    so we can use dot notation to compress `Continuous.comp hf continuous_fst` into
    `hf.comp continuous_fst` which is actually more readable since it really reads
    as composing our assumption and our lemma. We can do the same for the second component
    to get continuity of `fun p : X Ã— X â†¦ f p.2`. We then assemble those two continuities
    using `Continuous.prod_mk` to get `(hf.comp continuous_fst).prod_mk (hf.comp continuous_snd)
    : Continuous (fun p : X Ã— X â†¦ (f p.1, f p.2))` and compose once more to get our
    full proof.'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 'è¿™ä¸ªç­–ç•¥æœ‰ç‚¹æ…¢ï¼Œæ‰€ä»¥äº†è§£å¦‚ä½•æ‰‹åŠ¨å®Œæˆå®ƒä¹Ÿå¾ˆæœ‰ç”¨ã€‚æˆ‘ä»¬é¦–å…ˆéœ€è¦ä½¿ç”¨`fun p : X Ã— X â†¦ f p.1`æ˜¯è¿ç»­çš„ï¼Œå› ä¸ºå®ƒæ˜¯ç”±`f`ï¼ˆæ ¹æ®å‡è®¾`hf`æ˜¯è¿ç»­çš„ï¼‰å’ŒæŠ•å½±`prod.fst`ï¼ˆå…¶è¿ç»­æ€§æ˜¯å¼•ç†`continuous_fst`çš„å†…å®¹ï¼‰ç»„æˆçš„å¤åˆã€‚å¤åˆå±æ€§æ˜¯`Continuous.comp`ï¼Œå®ƒåœ¨`Continuous`å‘½åç©ºé—´ä¸­ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç‚¹ç¬¦å·å°†`Continuous.comp
    hf continuous_fst`å‹ç¼©ä¸º`hf.comp continuous_fst`ï¼Œè¿™å®é™…ä¸Šæ›´æ˜“äºé˜…è¯»ï¼Œå› ä¸ºå®ƒçœŸæ­£åœ°è¯»ä½œç»„åˆæˆ‘ä»¬çš„å‡è®¾å’Œæˆ‘ä»¬çš„å¼•ç†ã€‚æˆ‘ä»¬å¯ä»¥å¯¹ç¬¬äºŒä¸ªåˆ†é‡åšåŒæ ·çš„å¤„ç†ï¼Œä»¥è·å¾—`fun
    p : X Ã— X â†¦ f p.2`çš„è¿ç»­æ€§ã€‚ç„¶åæˆ‘ä»¬ä½¿ç”¨`Continuous.prod_mk`å°†è¿™äº›ä¸¤ä¸ªè¿ç»­æ€§ç»„è£…èµ·æ¥ï¼Œå¾—åˆ°`(hf.comp continuous_fst).prod_mk
    (hf.comp continuous_snd) : Continuous (fun p : X Ã— X â†¦ (f p.1, f p.2))`ï¼Œå¹¶å†æ¬¡ç»„åˆä»¥å¾—åˆ°å®Œæ•´çš„è¯æ˜ã€‚'
- en: '[PRE142]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The combination of `Continuous.prod_mk` and `continuous_dist` via `Continuous.comp`
    feels clunky, even when heavily using dot notation as above. A more serious issue
    is that this nice proof requires a lot of planning. Lean accepts the above proof
    term because it is a full term proving a statement which is definitionally equivalent
    to our goal, the crucial definition to unfold being that of a composition of functions.
    Indeed our target function `fun p : X Ã— X â†¦ dist (f p.1) (f p.2)` is not presented
    as a composition. The proof term we provided proves continuity of `dist âˆ˜ (fun
    p : X Ã— X â†¦ (f p.1, f p.2))` which happens to be definitionally equal to our target
    function. But if we try to build this proof gradually using tactics starting with
    `apply continuous_dist.comp` then Leanâ€™s elaborator will fail to recognize a composition
    and refuse to apply this lemma. It is especially bad at this when products of
    types are involved.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 'é€šè¿‡`Continuous.prod_mk`å’Œ`continuous_dist`é€šè¿‡`Continuous.comp`çš„ç»„åˆæ„Ÿè§‰æœ‰ç‚¹ç¬¨æ‹™ï¼Œå³ä½¿åƒä¸Šé¢é‚£æ ·å¤§é‡ä½¿ç”¨ç‚¹ç¬¦å·ä¹Ÿæ˜¯å¦‚æ­¤ã€‚ä¸€ä¸ªæ›´ä¸¥é‡çš„é—®é¢˜æ˜¯ï¼Œè¿™ä¸ªæ¼‚äº®çš„è¯æ˜éœ€è¦å¤§é‡çš„è§„åˆ’ã€‚Leanæ¥å—ä¸Šè¿°è¯æ˜é¡¹ï¼Œå› ä¸ºå®ƒæ˜¯ä¸€ä¸ªå®Œæ•´çš„é¡¹ï¼Œå®ƒè¯æ˜äº†ä¸æˆ‘ä»¬çš„ç›®æ ‡å®šä¹‰ç­‰ä»·çš„ä¸€ä¸ªé™ˆè¿°ï¼Œå…³é”®çš„å®šä¹‰æ˜¯å‡½æ•°çš„å¤åˆã€‚ç¡®å®ï¼Œæˆ‘ä»¬çš„ç›®æ ‡å‡½æ•°`fun
    p : X Ã— X â†¦ dist (f p.1) (f p.2)`å¹¶æ²¡æœ‰ä»¥å¤åˆçš„å½¢å¼å‘ˆç°ã€‚æˆ‘ä»¬æä¾›çš„è¯æ˜é¡¹è¯æ˜äº†`dist âˆ˜ (fun p : X Ã— X
    â†¦ (f p.1, f p.2))`çš„è¿ç»­æ€§ï¼Œè¿™æ°å¥½ä¸æˆ‘ä»¬çš„ç›®æ ‡å‡½æ•°å®šä¹‰ç­‰ä»·ã€‚ä½†å¦‚æœæˆ‘ä»¬å°è¯•ä»`apply continuous_dist.comp`å¼€å§‹çš„ç­–ç•¥é€æ­¥æ„å»ºè¿™ä¸ªè¯æ˜ï¼Œé‚£ä¹ˆLeançš„å±•å¼€å™¨å°†æ— æ³•è¯†åˆ«å¤åˆï¼Œå¹¶æ‹’ç»åº”ç”¨è¿™ä¸ªå¼•ç†ã€‚å½“æ¶‰åŠåˆ°ç±»å‹çš„äº§å“æ—¶ï¼Œè¿™ä¸ªé—®é¢˜å°¤å…¶ä¸¥é‡ã€‚'
- en: 'A better lemma to apply here is `Continuous.dist {f g : X â†’ Y} : Continuous
    f â†’ Continuous g â†’ Continuous (fun x â†¦ dist (f x) (g x))` which is nicer to Leanâ€™s
    elaborator and also provides a shorter proof when directly providing a full proof
    term, as can be seen from the following two new proofs of the above statement:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 'åœ¨è¿™é‡Œåº”ç”¨æ›´å¥½çš„å¼•ç†æ˜¯`Continuous.dist {f g : X â†’ Y} : Continuous f â†’ Continuous g â†’ Continuous
    (fun x â†¦ dist (f x) (g x))`ï¼Œè¿™å¯¹äºLeançš„å±•å¼€å™¨æ¥è¯´æ›´æ˜“äºå¤„ç†ï¼Œå¹¶ä¸”åœ¨ç›´æ¥æä¾›å®Œæ•´çš„è¯æ˜é¡¹æ—¶ä¹Ÿæä¾›äº†æ›´çŸ­çš„è¯æ˜ï¼Œå¦‚ä¸‹é¢çš„ä¸¤ä¸ªæ–°è¯æ˜æ‰€ç¤ºï¼š'
- en: '[PRE143]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Note that, without the elaboration issue coming from composition, another way
    to compress our proof would be to use `Continuous.prod_map` which is sometimes
    useful and gives as an alternate proof term `continuous_dist.comp (hf.prod_map
    hf)` which even shorter to type.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå¦‚æœæ²¡æœ‰ç”±äºå¤åˆå¼•èµ·çš„å±•å¼€é—®é¢˜ï¼Œå¦ä¸€ç§å‹ç¼©æˆ‘ä»¬è¯æ˜çš„æ–¹æ³•æ˜¯ä½¿ç”¨`Continuous.prod_map`ï¼Œè¿™åœ¨æŸäº›æƒ…å†µä¸‹å¾ˆæœ‰ç”¨ï¼Œå¹¶ç»™å‡ºäº†ä¸€ä¸ªæ›¿ä»£çš„è¯æ˜é¡¹`continuous_dist.comp
    (hf.prod_map hf)`ï¼Œè¿™ç”šè‡³æ›´çŸ­äºè¾“å…¥ã€‚
- en: Since it is sad to decide between a version which is better for elaboration
    and a version which is shorter to type, let us wrap this discussion with a last
    bit of compression offered by `Continuous.fst'` which allows to compress `hf.comp
    continuous_fst` to `hf.fst'` (and the same with `snd`) and get our final proof,
    now bordering obfuscation.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºåœ¨è¯¦ç»†é˜è¿°å’Œç®€çŸ­è¾“å…¥ä¹‹é—´åšå‡ºé€‰æ‹©éƒ½å¾ˆä»¤äººéš¾è¿‡ï¼Œè®©æˆ‘ä»¬ç”¨`Continuous.fst'`æä¾›çš„æœ€åä¸€ç‚¹å‹ç¼©æ¥ç»“æŸè¿™æ¬¡è®¨è®ºï¼Œå®ƒå…è®¸å°†`hf.comp
    continuous_fst`å‹ç¼©ä¸º`hf.fst'`ï¼ˆä»¥åŠ`snd`ï¼‰ï¼Œå¹¶å¾—åˆ°æˆ‘ä»¬çš„æœ€ç»ˆè¯æ˜ï¼Œç°åœ¨æ­£æ¥è¿‘æ™¦æ¶©ã€‚
- en: '[PRE144]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Itâ€™s your turn now to prove some continuity lemma. After trying the continuity
    tactic, you will need `Continuous.add`, `continuous_pow` and `continuous_id` to
    do it by hand.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è½®åˆ°ä½ äº†ï¼Œå»è¯æ˜ä¸€äº›è¿ç»­æ€§å¼•ç†ã€‚åœ¨å°è¯•è¿ç»­æ€§ç­–ç•¥ä¹‹åï¼Œä½ éœ€è¦`Continuous.add`ã€`continuous_pow`å’Œ`continuous_id`æ¥æ‰‹åŠ¨å®Œæˆã€‚
- en: '[PRE145]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: So far we saw continuity as a global notion, but one can also define continuity
    at a point.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å°†è¿ç»­æ€§è§†ä¸ºä¸€ä¸ªå…¨å±€æ¦‚å¿µï¼Œä½†ä¹Ÿå¯ä»¥å®šä¹‰åœ¨ä¸€ç‚¹ä¸Šçš„è¿ç»­æ€§ã€‚
- en: '[PRE146]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 11.2.2\. Balls, open sets and closed sets[ïƒ](#balls-open-sets-and-closed-sets
    "Link to this heading")
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2\. çƒã€å¼€é›†å’Œé—­é›†[ïƒ](#balls-open-sets-and-closed-sets "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")
- en: Once we have a distance function, the most important geometric definitions are
    (open) balls and closed balls.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æˆ‘ä»¬æœ‰ä¸€ä¸ªè·ç¦»å‡½æ•°ï¼Œæœ€é‡è¦çš„å‡ ä½•å®šä¹‰å°±æ˜¯ï¼ˆå¼€ï¼‰çƒå’Œé—­çƒã€‚
- en: '[PRE147]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Note that r is any real number here, there is no sign restriction. Of course
    some statements do require a radius condition.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè¿™é‡Œçš„ræ˜¯ä»»ä½•å®æ•°ï¼Œæ²¡æœ‰ç¬¦å·é™åˆ¶ã€‚å½“ç„¶ï¼Œæœ‰äº›é™ˆè¿°ç¡®å®éœ€è¦åŠå¾„æ¡ä»¶ã€‚
- en: '[PRE148]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Once we have balls, we can define open sets. They are actually defined in a
    more general setting covered in the next section, but we have lemmas recasting
    the definition in terms of balls.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æˆ‘ä»¬æœ‰çƒï¼Œæˆ‘ä»¬å°±å¯ä»¥å®šä¹‰å¼€é›†ã€‚å®é™…ä¸Šï¼Œå®ƒä»¬æ˜¯åœ¨ä¸‹ä¸€èŠ‚ä¸­è®¨è®ºçš„æ›´ä¸€èˆ¬è®¾ç½®ä¸­å®šä¹‰çš„ï¼Œä½†æˆ‘ä»¬æœ‰å¼•ç†å°†å®šä¹‰é‡æ–°è¡¨è¿°ä¸ºçƒçš„å½¢å¼ã€‚
- en: '[PRE149]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Then closed sets are sets whose complement is open. Their important property
    is they are closed under limits. The closure of a set is the smallest closed set
    containing it.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åé—­é›†æ˜¯è¡¥é›†ä¸ºå¼€çš„é›†åˆã€‚å®ƒä»¬çš„é‡è¦æ€§è´¨æ˜¯å®ƒä»¬åœ¨æé™ä¸‹æ˜¯å°é—­çš„ã€‚é›†åˆçš„é—­åŒ…æ˜¯åŒ…å«å®ƒçš„æœ€å°é—­é›†ã€‚
- en: '[PRE150]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Do the next exercise without using mem_closure_iff_seq_limit
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸ä½¿ç”¨`mem_closure_iff_seq_limit`çš„æƒ…å†µä¸‹å®Œæˆä¸‹ä¸€ä¸ªç»ƒä¹ ã€‚
- en: '[PRE151]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Remember from the filters sections that neighborhood filters play a big role
    in Mathlib. In the metric space context, the crucial point is that balls provide
    bases for those filters. The main lemmas here are `Metric.nhds_basis_ball` and
    `Metric.nhds_basis_closedBall` that claim this for open and closed balls with
    positive radius. The center point is an implicit argument so we can invoke `Filter.HasBasis.mem_iff`
    as in the following example.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: è®°ä½ä»è¿‡æ»¤å™¨éƒ¨åˆ†ï¼Œé‚»åŸŸè¿‡æ»¤å™¨åœ¨Mathlibä¸­èµ·ç€é‡è¦ä½œç”¨ã€‚åœ¨åº¦é‡ç©ºé—´ä¸Šä¸‹æ–‡ä¸­ï¼Œå…³é”®ç‚¹æ˜¯çƒä¸ºè¿™äº›è¿‡æ»¤å™¨æä¾›åŸºã€‚è¿™é‡Œçš„ä¸»è¦å¼•ç†æ˜¯`Metric.nhds_basis_ball`å’Œ`Metric.nhds_basis_closedBall`ï¼Œå®ƒä»¬ä¸ºæ­£åŠå¾„çš„å¼€çƒå’Œé—­çƒæ–­è¨€è¿™ä¸€ç‚¹ã€‚ä¸­å¿ƒç‚¹æ˜¯éšå«çš„å‚æ•°ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åƒä»¥ä¸‹ç¤ºä¾‹ä¸­é‚£æ ·è°ƒç”¨`Filter.HasBasis.mem_iff`ã€‚
- en: '[PRE152]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 11.2.3\. Compactness[ïƒ](#compactness "Link to this heading")
  id: totrans-540
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.3\. ç´§æ€§[ïƒ](#compactness "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")
- en: 'Compactness is an important topological notion. It distinguishes subsets of
    a metric space that enjoy the same kind of properties as segments in the reals
    compared to other intervals:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: ç´§æ€§æ˜¯ä¸€ä¸ªé‡è¦çš„æ‹“æ‰‘æ¦‚å¿µã€‚å®ƒåŒºåˆ†äº†åº¦é‡ç©ºé—´çš„å­é›†ï¼Œè¿™äº›å­é›†ä¸å…¶ä»–åŒºé—´ç›¸æ¯”ï¼Œä¸å®æ•°ä¸­çš„çº¿æ®µå…·æœ‰ç›¸åŒçš„æ€§è´¨ï¼š
- en: Any sequence with values in a compact set has a subsequence that converges in
    this set.
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨ç´§é›†ä¸Šå–å€¼çš„ä»»ä½•åºåˆ—éƒ½æœ‰ä¸€ä¸ªå­åºåˆ—åœ¨è¿™ä¸ªé›†åˆä¸­æ”¶æ•›ã€‚
- en: Any continuous function on a nonempty compact set with values in real numbers
    is bounded and attains its bounds somewhere (this is called the extreme value
    theorem).
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨éç©ºç´§é›†ä¸Šå–å®æ•°å€¼çš„ä»»ä½•è¿ç»­å‡½æ•°éƒ½æ˜¯æœ‰ç•Œçš„ï¼Œå¹¶ä¸”åœ¨å…¶æŸå¤„è¾¾åˆ°å…¶ç•Œé™ï¼ˆè¿™è¢«ç§°ä¸ºæå€¼å®šç†ï¼‰ã€‚
- en: Compact sets are closed sets.
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç´§é›†æ˜¯é—­é›†ã€‚
- en: Let us first check that the unit interval in the reals is indeed a compact set,
    and then check the above claims for compact sets in general metric spaces. In
    the second statement we only need continuity on the given set so we will use `ContinuousOn`
    instead of `Continuous`, and we will give separate statements for the minimum
    and the maximum. Of course all these results are deduced from more general versions,
    some of which will be discussed in later sections.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å…ˆæ£€æŸ¥å®æ•°å•ä½åŒºé—´ç¡®å®æ˜¯ä¸€ä¸ªç´§é›†ï¼Œç„¶åæ£€æŸ¥ä¸€èˆ¬åº¦é‡ç©ºé—´ä¸­ç´§é›†çš„ä¸Šè¿°å‘½é¢˜ã€‚åœ¨ç¬¬äºŒä¸ªå‘½é¢˜ä¸­ï¼Œæˆ‘ä»¬åªéœ€è¦ç»™å®šé›†åˆä¸Šçš„è¿ç»­æ€§ï¼Œå› æ­¤æˆ‘ä»¬å°†ä½¿ç”¨`ContinuousOn`è€Œä¸æ˜¯`Continuous`ï¼Œå¹¶ä¸”æˆ‘ä»¬å°†åˆ†åˆ«ç»™å‡ºæœ€å°å€¼å’Œæœ€å¤§å€¼çš„å•ç‹¬é™ˆè¿°ã€‚å½“ç„¶ï¼Œæ‰€æœ‰è¿™äº›ç»“æœéƒ½æ˜¯ä»æ›´ä¸€èˆ¬çš„ç‰ˆæœ¬ä¸­æ¨å¯¼å‡ºæ¥çš„ï¼Œå…¶ä¸­ä¸€äº›å°†åœ¨åé¢çš„ç« èŠ‚ä¸­è®¨è®ºã€‚
- en: '[PRE153]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'We can also specify that a metric spaces is globally compact, using an extra
    `Prop`-valued type class:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å¯ä»¥æŒ‡å®šä¸€ä¸ªåº¦é‡ç©ºé—´æ˜¯å…¨å±€ç´§çš„ï¼Œä½¿ç”¨ä¸€ä¸ªé¢å¤–çš„`Prop`å€¼ç±»å‹ç±»ï¼š
- en: '[PRE154]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: In a compact metric space any closed set is compact, this is `IsClosed.isCompact`.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç´§åº¦é‡ç©ºé—´ä¸­ï¼Œä»»ä½•é—­é›†éƒ½æ˜¯ç´§é›†ï¼Œè¿™æ˜¯`IsClosed.isCompact`ã€‚
- en: 11.2.4\. Uniformly continuous functions[ïƒ](#uniformly-continuous-functions "Link
    to this heading")
  id: totrans-550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.4\. å‡åŒ€è¿ç»­å‡½æ•°[ïƒ](#uniformly-continuous-functions "é“¾æ¥åˆ°æœ¬æ ‡é¢˜")
- en: 'We now turn to uniformity notions on metric spaces : uniformly continuous functions,
    Cauchy sequences and completeness. Again those are defined in a more general context
    but we have lemmas in the metric name space to access their elementary definitions.
    We start with uniform continuity.'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å°†è½¬å‘åº¦é‡ç©ºé—´ä¸Šçš„å‡åŒ€æ€§æ¦‚å¿µï¼šå‡åŒ€è¿ç»­å‡½æ•°ã€æŸ¯è¥¿åºåˆ—å’Œå®Œå¤‡æ€§ã€‚åŒæ ·ï¼Œè¿™äº›åœ¨æ›´ä¸€èˆ¬çš„ç¯å¢ƒä¸­å®šä¹‰ï¼Œä½†æˆ‘ä»¬æœ‰åœ¨åº¦é‡åç§°ç©ºé—´ä¸­çš„å¼•ç†æ¥è®¿é—®å®ƒä»¬çš„å…ƒç´ å®šä¹‰ã€‚æˆ‘ä»¬é¦–å…ˆä»å‡åŒ€è¿ç»­æ€§å¼€å§‹ã€‚
- en: '[PRE155]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: In order to practice manipulating all those definitions, we will prove that
    continuous functions from a compact metric space to a metric space are uniformly
    continuous (we will see a more general version in a later section).
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ç»ƒä¹ æ“ä½œæ‰€æœ‰è¿™äº›å®šä¹‰ï¼Œæˆ‘ä»¬å°†è¯æ˜ä»ç´§è‡´åº¦é‡ç©ºé—´åˆ°åº¦é‡ç©ºé—´çš„è¿ç»­å‡½æ•°æ˜¯å‡åŒ€è¿ç»­çš„ï¼ˆæˆ‘ä»¬å°†åœ¨åé¢çš„ç« èŠ‚ä¸­çœ‹åˆ°æ›´ä¸€èˆ¬çš„å½¢å¼ï¼‰ã€‚
- en: 'We will first give an informal sketch. Let `f : X â†’ Y` be a continuous function
    from a compact metric space to a metric space. We fix `Îµ > 0` and start looking
    for some `Î´`.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 'æˆ‘ä»¬å°†é¦–å…ˆç»™å‡ºä¸€ä¸ªéæ­£å¼çš„è‰å›¾ã€‚è®¾ `f : X â†’ Y` æ˜¯ä»ç´§è‡´åº¦é‡ç©ºé—´åˆ°åº¦é‡ç©ºé—´çš„è¿ç»­å‡½æ•°ã€‚æˆ‘ä»¬å›ºå®š `Îµ > 0` å¹¶å¼€å§‹å¯»æ‰¾æŸä¸ª `Î´`ã€‚'
- en: 'Let `Ï† : X Ã— X â†’ â„ := fun p â†¦ dist (f p.1) (f p.2)` and let `K := { p : X Ã—
    X | Îµ â‰¤ Ï† p }`. Observe `Ï†` is continuous since `f` and distance are continuous.
    And `K` is clearly closed (use `isClosed_le`) hence compact since `X` is compact.'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 'è®¾ `Ï† : X Ã— X â†’ â„ := fun p â†¦ dist (f p.1) (f p.2)` å’Œ `K := { p : X Ã— X | Îµ â‰¤
    Ï† p }`ã€‚è§‚å¯Ÿ `Ï†` æ˜¯è¿ç»­çš„ï¼Œå› ä¸º `f` å’Œè·ç¦»éƒ½æ˜¯è¿ç»­çš„ã€‚è€Œä¸” `K` æ˜¾ç„¶æ˜¯é—­é›†ï¼ˆä½¿ç”¨ `isClosed_le`ï¼‰ï¼Œå› æ­¤ç”±äº `X` æ˜¯ç´§è‡´çš„ï¼Œ`K`
    ä¹Ÿæ˜¯ç´§è‡´çš„ã€‚'
- en: Then we discuss two possibilities using `eq_empty_or_nonempty`. If `K` is empty
    then we are clearly done (we can set `Î´ = 1` for instance). So letâ€™s assume `K`
    is not empty, and use the extreme value theorem to choose `(xâ‚€, xâ‚)` attaining
    the infimum of the distance function on `K`. We can then set `Î´ = dist xâ‚€ xâ‚`
    and check everything works.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬è®¨è®ºä½¿ç”¨ `eq_empty_or_nonempty` çš„ä¸¤ç§å¯èƒ½æ€§ã€‚å¦‚æœ `K` æ˜¯ç©ºçš„ï¼Œé‚£ä¹ˆæ˜¾ç„¶æˆ‘ä»¬å·²ç»å®Œæˆäº†ï¼ˆä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥å°† `Î´` è®¾ç½®ä¸º
    `1`ï¼‰ã€‚æ‰€ä»¥è®©æˆ‘ä»¬å‡è®¾ `K` ä¸æ˜¯ç©ºçš„ï¼Œå¹¶ä½¿ç”¨æå€¼å®šç†æ¥é€‰æ‹© `(xâ‚€, xâ‚)`ï¼Œå®ƒåœ¨ `K` ä¸Šçš„è·ç¦»å‡½æ•°ä¸Šè¾¾åˆ°ä¸‹ç¡®ç•Œã€‚ç„¶åæˆ‘ä»¬å¯ä»¥å°† `Î´` è®¾ç½®ä¸º
    `dist xâ‚€ xâ‚` å¹¶æ£€æŸ¥ä¸€åˆ‡æ˜¯å¦æ­£å¸¸å·¥ä½œã€‚
- en: '[PRE156]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 11.2.5\. Completeness[ïƒ](#completeness "Link to this heading")
  id: totrans-558
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.5\. å®Œå¤‡æ€§[ïƒ](#completeness "é“¾æ¥åˆ°æœ¬æ ‡é¢˜")
- en: A Cauchy sequence in a metric space is a sequence whose terms get closer and
    closer to each other. There are a couple of equivalent ways to state that idea.
    In particular converging sequences are Cauchy. The converse is true only in so-called
    *complete* spaces.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨åº¦é‡ç©ºé—´ä¸­çš„æŸ¯è¥¿åºåˆ—æ˜¯ä¸€ä¸ªé¡¹ä¸é¡¹ä¹‹é—´çš„è·ç¦»è¶Šæ¥è¶Šè¿‘çš„åºåˆ—ã€‚æœ‰å‡ ç§ç­‰ä»·çš„æ–¹å¼æ¥è¡¨è¿°è¿™ä¸ªæƒ³æ³•ã€‚ç‰¹åˆ«æ˜¯æ”¶æ•›åºåˆ—æ˜¯æŸ¯è¥¿åºåˆ—ã€‚é€†å‘½é¢˜åªåœ¨æ‰€è°“çš„ *å®Œå¤‡* ç©ºé—´ä¸­æˆç«‹ã€‚
- en: '[PRE157]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Weâ€™ll practice using this definition by proving a convenient criterion which
    is a special case of a criterion appearing in Mathlib. This is also a good opportunity
    to practice using big sums in a geometric context. In addition to the explanations
    from the filters section, you will probably need `tendsto_pow_atTop_nhds_zero_of_lt_one`,
    `Tendsto.mul` and `dist_le_range_sum_dist`.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†é€šè¿‡è¯æ˜ä¸€ä¸ªæ–¹ä¾¿çš„åˆ¤æ®æ¥ç»ƒä¹ ä½¿ç”¨è¿™ä¸ªå®šä¹‰ï¼Œè¿™æ˜¯ Mathlib ä¸­å‡ºç°çš„ä¸€ä¸ªåˆ¤æ®çš„ç‰¹æ®Šæƒ…å†µã€‚è¿™ä¹Ÿæ˜¯ç»ƒä¹ åœ¨å‡ ä½•ç¯å¢ƒä¸­ä½¿ç”¨å¤§å’Œçš„å¥½æœºä¼šã€‚é™¤äº†è¿‡æ»¤å™¨éƒ¨åˆ†çš„è§£é‡Šå¤–ï¼Œä½ å¯èƒ½è¿˜éœ€è¦
    `tendsto_pow_atTop_nhds_zero_of_lt_one`ã€`Tendsto.mul` å’Œ `dist_le_range_sum_dist`ã€‚
- en: '[PRE158]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'We are ready for the final boss of this section: Baireâ€™s theorem for complete
    metric spaces! The proof skeleton below shows interesting techniques. It uses
    the `choose` tactic in its exclamation mark variant (you should experiment with
    removing this exclamation mark) and it shows how to define something inductively
    in the middle of a proof using `Nat.rec_on`.'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»å‡†å¤‡å¥½æœ¬èŠ‚çš„æœ€ç»ˆæŒ‘æˆ˜ï¼šå®Œå¤‡åº¦é‡ç©ºé—´çš„ Baire å®šç†ï¼ä¸‹é¢çš„è¯æ˜æ¡†æ¶å±•ç¤ºäº†æœ‰è¶£çš„æŠ€æœ¯ã€‚å®ƒä½¿ç”¨äº†æ„Ÿå¹å·å˜ä½“çš„ `choose` ç­–ç•¥ï¼ˆä½ åº”è¯¥å°è¯•ç§»é™¤è¿™ä¸ªæ„Ÿå¹å·ï¼‰ï¼Œå¹¶å±•ç¤ºäº†å¦‚ä½•åœ¨è¯æ˜ä¸­ä½¿ç”¨
    `Nat.rec_on` é€’å½’åœ°å®šä¹‰æŸç‰©ã€‚
- en: '[PRE159]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 11.2.1\. Convergence and continuity[ïƒ](#convergence-and-continuity "Link to
    this heading")
  id: totrans-565
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1\. æ”¶æ•›ä¸è¿ç»­[ïƒ](#convergence-and-continuity "é“¾æ¥åˆ°æœ¬æ ‡é¢˜")
- en: Using distance functions, we can already define convergent sequences and continuous
    functions between metric spaces. They are actually defined in a more general setting
    covered in the next section, but we have lemmas recasting the definition in terms
    of distances.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è·ç¦»å‡½æ•°ï¼Œæˆ‘ä»¬å·²ç»åœ¨åº¦é‡ç©ºé—´ä¹‹é—´å®šä¹‰äº†æ”¶æ•›åºåˆ—å’Œè¿ç»­å‡½æ•°ã€‚å®é™…ä¸Šï¼Œå®ƒä»¬åœ¨ä¸‹ä¸€èŠ‚ä¸­è®¨è®ºçš„æ›´ä¸€èˆ¬çš„ç¯å¢ƒä¸­å®šä¹‰ï¼Œä½†æˆ‘ä»¬æœ‰å¼•ç†å°†å®šä¹‰é‡æ–°è¡¨è¿°ä¸ºè·ç¦»çš„å½¢å¼ã€‚
- en: '[PRE160]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: A *lot* of lemmas have some continuity assumptions, so we end up proving a lot
    of continuity results and there is a `continuity` tactic devoted to this task.
    Letâ€™s prove a continuity statement that will be needed in an exercise below. Notice
    that Lean knows how to treat a product of two metric spaces as a metric space,
    so it makes sense to consider continuous functions from `X Ã— X` to `â„`. In particular
    the (uncurried version of the) distance function is such a function.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: è®¸å¤šå¼•ç†éƒ½æœ‰ä¸€äº›è¿ç»­æ€§çš„å‡è®¾ï¼Œæ‰€ä»¥æˆ‘ä»¬æœ€ç»ˆè¯æ˜äº†å¾ˆå¤šè¿ç»­æ€§ç»“æœï¼Œå¹¶ä¸”æœ‰ä¸€ä¸ª `continuity` ç­–ç•¥ä¸“é—¨ç”¨äºè¿™ä¸ªä»»åŠ¡ã€‚è®©æˆ‘ä»¬è¯æ˜ä¸€ä¸ªåœ¨ä¸‹é¢çš„ç»ƒä¹ ä¸­éœ€è¦çš„è¿ç»­æ€§é™ˆè¿°ã€‚æ³¨æ„ï¼ŒLean
    çŸ¥é“å¦‚ä½•å°†ä¸¤ä¸ªåº¦é‡ç©ºé—´çš„äº§å“è§†ä¸ºåº¦é‡ç©ºé—´ï¼Œå› æ­¤è€ƒè™‘ä» `X Ã— X` åˆ° `â„` çš„è¿ç»­å‡½æ•°æ˜¯æœ‰æ„ä¹‰çš„ã€‚ç‰¹åˆ«æ˜¯ï¼Œè·ç¦»å‡½æ•°ï¼ˆæœªå±•å¼€ç‰ˆæœ¬ï¼‰æ˜¯è¿™æ ·çš„å‡½æ•°ã€‚
- en: '[PRE161]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'This tactic is a bit slow, so it is also useful to know how to do it by hand.
    We first need to use that `fun p : X Ã— X â†¦ f p.1` is continuous because it is
    the composition of `f`, which is continuous by assumption `hf`, and the projection
    `prod.fst` whose continuity is the content of the lemma `continuous_fst`. The
    composition property is `Continuous.comp` which is in the `Continuous` namespace
    so we can use dot notation to compress `Continuous.comp hf continuous_fst` into
    `hf.comp continuous_fst` which is actually more readable since it really reads
    as composing our assumption and our lemma. We can do the same for the second component
    to get continuity of `fun p : X Ã— X â†¦ f p.2`. We then assemble those two continuities
    using `Continuous.prod_mk` to get `(hf.comp continuous_fst).prod_mk (hf.comp continuous_snd)
    : Continuous (fun p : X Ã— X â†¦ (f p.1, f p.2))` and compose once more to get our
    full proof.'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 'è¿™ä¸ªç­–ç•¥æœ‰ç‚¹æ…¢ï¼Œå› æ­¤äº†è§£å¦‚ä½•æ‰‹åŠ¨å®Œæˆå®ƒä¹Ÿæ˜¯æœ‰ç”¨çš„ã€‚æˆ‘ä»¬é¦–å…ˆéœ€è¦ä½¿ç”¨ `fun p : X Ã— X â†¦ f p.1` æ˜¯è¿ç»­çš„ï¼Œå› ä¸ºå®ƒæ˜¯ç”±è¿ç»­çš„ `f`ï¼ˆç”±å‡è®¾
    `hf` ç¡®å®šï¼‰å’ŒæŠ•å½± `prod.fst`ï¼ˆå…¶è¿ç»­æ€§æ˜¯å¼•ç† `continuous_fst` çš„å†…å®¹ï¼‰ç»„æˆçš„å¤åˆã€‚å¤åˆå±æ€§æ˜¯ `Continuous.comp`ï¼Œå®ƒåœ¨
    `Continuous` å‘½åç©ºé—´ä¸­ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç‚¹ç¬¦å·å°† `Continuous.comp hf continuous_fst` å‹ç¼©ä¸º `hf.comp
    continuous_fst`ï¼Œè¿™å®é™…ä¸Šæ›´æ˜“äºé˜…è¯»ï¼Œå› ä¸ºå®ƒçœŸæ­£åœ°è¯»ä½œå°†æˆ‘ä»¬çš„å‡è®¾å’Œå¼•ç†ç»„åˆåœ¨ä¸€èµ·ã€‚æˆ‘ä»¬å¯ä»¥å¯¹ç¬¬äºŒä¸ªç»„ä»¶åšåŒæ ·çš„å¤„ç†ï¼Œä»¥è·å¾— `fun p :
    X Ã— X â†¦ f p.2` çš„è¿ç»­æ€§ã€‚ç„¶åæˆ‘ä»¬ä½¿ç”¨ `Continuous.prod_mk` å°†è¿™ä¸¤ä¸ªè¿ç»­æ€§ç»„è£…èµ·æ¥ï¼Œå¾—åˆ° `(hf.comp continuous_fst).prod_mk
    (hf.comp continuous_snd) : Continuous (fun p : X Ã— X â†¦ (f p.1, f p.2))`ï¼Œç„¶åå†è¿›è¡Œä¸€æ¬¡å¤åˆï¼Œä»¥å¾—åˆ°å®Œæ•´çš„è¯æ˜ã€‚'
- en: '[PRE162]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'The combination of `Continuous.prod_mk` and `continuous_dist` via `Continuous.comp`
    feels clunky, even when heavily using dot notation as above. A more serious issue
    is that this nice proof requires a lot of planning. Lean accepts the above proof
    term because it is a full term proving a statement which is definitionally equivalent
    to our goal, the crucial definition to unfold being that of a composition of functions.
    Indeed our target function `fun p : X Ã— X â†¦ dist (f p.1) (f p.2)` is not presented
    as a composition. The proof term we provided proves continuity of `dist âˆ˜ (fun
    p : X Ã— X â†¦ (f p.1, f p.2))` which happens to be definitionally equal to our target
    function. But if we try to build this proof gradually using tactics starting with
    `apply continuous_dist.comp` then Leanâ€™s elaborator will fail to recognize a composition
    and refuse to apply this lemma. It is especially bad at this when products of
    types are involved.'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 'é€šè¿‡ `Continuous.comp` å°† `Continuous.prod_mk` å’Œ `continuous_dist` ç»“åˆåœ¨ä¸€èµ·æ„Ÿè§‰æœ‰äº›ç¬¨æ‹™ï¼Œå³ä½¿åƒä¸Šé¢é‚£æ ·å¤§é‡ä½¿ç”¨ç‚¹ç¬¦å·ä¹Ÿæ˜¯å¦‚æ­¤ã€‚ä¸€ä¸ªæ›´ä¸¥é‡çš„é—®é¢˜æ˜¯ï¼Œè¿™ä¸ªæ¼‚äº®çš„è¯æ˜éœ€è¦å¤§é‡çš„è§„åˆ’ã€‚Lean
    æ¥å—ä¸Šè¿°è¯æ˜é¡¹ï¼Œå› ä¸ºå®ƒæ˜¯ä¸€ä¸ªå®Œæ•´çš„é¡¹ï¼Œè¯æ˜äº†ä¸æˆ‘ä»¬çš„ç›®æ ‡å®šä¹‰ç­‰ä»·çš„ä¸€ä¸ªé™ˆè¿°ï¼Œå…³é”®çš„å®šä¹‰å±•å¼€æ˜¯å‡½æ•°çš„å¤åˆã€‚ç¡®å®ï¼Œæˆ‘ä»¬çš„ç›®æ ‡å‡½æ•° `fun p : X Ã— X
    â†¦ dist (f p.1) (f p.2)` å¹¶æ²¡æœ‰ä»¥å¤åˆçš„å½¢å¼å‘ˆç°ã€‚æˆ‘ä»¬æä¾›çš„è¯æ˜é¡¹è¯æ˜äº† `dist âˆ˜ (fun p : X Ã— X â†¦ (f p.1,
    f p.2))` çš„è¿ç»­æ€§ï¼Œè¿™æ°å¥½ä¸æˆ‘ä»¬çš„ç›®æ ‡å‡½æ•°åœ¨å®šä¹‰ä¸Šæ˜¯ç­‰ä»·çš„ã€‚ä½†å¦‚æœæˆ‘ä»¬å°è¯•ä» `apply continuous_dist.comp` å¼€å§‹é€æ­¥æ„å»ºè¿™ä¸ªè¯æ˜ï¼ŒLean
    çš„å±•å¼€å™¨å°†æ— æ³•è¯†åˆ«å¤åˆï¼Œå¹¶æ‹’ç»åº”ç”¨è¿™ä¸ªå¼•ç†ã€‚å½“æ¶‰åŠåˆ°ç±»å‹ä¹˜ç§¯æ—¶ï¼Œè¿™ä¸ªé—®é¢˜å°¤å…¶ä¸¥é‡ã€‚'
- en: 'A better lemma to apply here is `Continuous.dist {f g : X â†’ Y} : Continuous
    f â†’ Continuous g â†’ Continuous (fun x â†¦ dist (f x) (g x))` which is nicer to Leanâ€™s
    elaborator and also provides a shorter proof when directly providing a full proof
    term, as can be seen from the following two new proofs of the above statement:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 'åœ¨è¿™é‡Œåº”ç”¨æ›´å¥½çš„å¼•ç†æ˜¯ `Continuous.dist {f g : X â†’ Y} : Continuous f â†’ Continuous g â†’
    Continuous (fun x â†¦ dist (f x) (g x))`ï¼Œè¿™å¯¹äº Lean çš„å±•å¼€å™¨æ¥è¯´æ›´æ˜“äºå¤„ç†ï¼Œå¹¶ä¸”åœ¨ç›´æ¥æä¾›å®Œæ•´çš„è¯æ˜é¡¹æ—¶ä¹Ÿæä¾›äº†æ›´çŸ­çš„è¯æ˜ï¼Œå¦‚ä¸‹é¢çš„ä¸¤ä¸ªæ–°è¯æ˜æ‰€ç¤ºï¼š'
- en: '[PRE163]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Note that, without the elaboration issue coming from composition, another way
    to compress our proof would be to use `Continuous.prod_map` which is sometimes
    useful and gives as an alternate proof term `continuous_dist.comp (hf.prod_map
    hf)` which even shorter to type.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå¦‚æœæ²¡æœ‰ç”±äºå¤åˆå¼•èµ·çš„å±•å¼€é—®é¢˜ï¼Œå¦ä¸€ç§å‹ç¼©æˆ‘ä»¬è¯æ˜çš„æ–¹æ³•æ˜¯ä½¿ç”¨ `Continuous.prod_map`ï¼Œè¿™åœ¨æŸäº›æƒ…å†µä¸‹å¾ˆæœ‰ç”¨ï¼Œå¹¶ç»™å‡ºäº†ä¸€ä¸ªæ›¿ä»£çš„è¯æ˜é¡¹
    `continuous_dist.comp (hf.prod_map hf)`ï¼Œè¿™ç”šè‡³æ›´çŸ­äºè¾“å…¥ç±»å‹ã€‚
- en: Since it is sad to decide between a version which is better for elaboration
    and a version which is shorter to type, let us wrap this discussion with a last
    bit of compression offered by `Continuous.fst'` which allows to compress `hf.comp
    continuous_fst` to `hf.fst'` (and the same with `snd`) and get our final proof,
    now bordering obfuscation.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºå†³å®šä¸€ä¸ªç‰ˆæœ¬å¯¹è¯¦ç»†è¯´æ˜æ›´å¥½ï¼Œè€Œå¦ä¸€ä¸ªç‰ˆæœ¬åˆ™æ›´çŸ­ï¼Œæ‰€ä»¥æˆ‘ä»¬ç”¨`Continuous.fst'`æä¾›çš„æœ€åä¸€ç‚¹å‹ç¼©æ¥ç»“æŸè¿™æ¬¡è®¨è®ºï¼Œå®ƒå…è®¸å°†`hf.comp
    continuous_fst`å‹ç¼©ä¸º`hf.fst'`ï¼ˆä»¥åŠ`snd`ï¼‰ï¼Œå¹¶å¾—åˆ°æˆ‘ä»¬çš„æœ€ç»ˆè¯æ˜ï¼Œç°åœ¨æ¥è¿‘æ¨¡ç³Šã€‚
- en: '[PRE164]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Itâ€™s your turn now to prove some continuity lemma. After trying the continuity
    tactic, you will need `Continuous.add`, `continuous_pow` and `continuous_id` to
    do it by hand.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è½®åˆ°ä½ æ¥è¯æ˜ä¸€äº›è¿ç»­æ€§å¼•ç†äº†ã€‚åœ¨å°è¯•è¿ç»­æ€§ç­–ç•¥ä¹‹åï¼Œä½ éœ€è¦`Continuous.add`ã€`continuous_pow`å’Œ`continuous_id`æ¥æ‰‹åŠ¨å®Œæˆã€‚
- en: '[PRE165]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: So far we saw continuity as a global notion, but one can also define continuity
    at a point.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†è¿ç»­æ€§ä½œä¸ºä¸€ä¸ªå…¨å±€æ¦‚å¿µï¼Œä½†ä¹Ÿå¯ä»¥å®šä¹‰åœ¨ä¸€ç‚¹ä¸Šçš„è¿ç»­æ€§ã€‚
- en: '[PRE166]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 11.2.2\. Balls, open sets and closed sets[ïƒ](#balls-open-sets-and-closed-sets
    "Link to this heading")
  id: totrans-582
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2\. çƒã€å¼€é›†å’Œé—­é›†[ïƒ](#balls-open-sets-and-closed-sets "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")
- en: Once we have a distance function, the most important geometric definitions are
    (open) balls and closed balls.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æˆ‘ä»¬æœ‰äº†è·ç¦»å‡½æ•°ï¼Œæœ€é‡è¦çš„å‡ ä½•å®šä¹‰å°±æ˜¯ï¼ˆå¼€ï¼‰çƒå’Œé—­çƒã€‚
- en: '[PRE167]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Note that r is any real number here, there is no sign restriction. Of course
    some statements do require a radius condition.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè¿™é‡Œçš„ræ˜¯ä»»ä½•å®æ•°ï¼Œæ²¡æœ‰ç¬¦å·é™åˆ¶ã€‚å½“ç„¶ï¼Œä¸€äº›é™ˆè¿°ç¡®å®éœ€è¦åŠå¾„æ¡ä»¶ã€‚
- en: '[PRE168]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Once we have balls, we can define open sets. They are actually defined in a
    more general setting covered in the next section, but we have lemmas recasting
    the definition in terms of balls.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æˆ‘ä»¬æœ‰äº†çƒï¼Œæˆ‘ä»¬å°±å¯ä»¥å®šä¹‰å¼€é›†ã€‚å®é™…ä¸Šï¼Œå®ƒä»¬æ˜¯åœ¨æ›´ä¸€èˆ¬çš„è®¾ç½®ä¸­å®šä¹‰çš„ï¼Œè¿™å°†åœ¨ä¸‹ä¸€èŠ‚ä¸­ä»‹ç»ï¼Œä½†æˆ‘ä»¬æœ‰å¼•ç†å°†å®šä¹‰é‡æ–°è¡¨è¿°ä¸ºçƒçš„å½¢å¼ã€‚
- en: '[PRE169]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Then closed sets are sets whose complement is open. Their important property
    is they are closed under limits. The closure of a set is the smallest closed set
    containing it.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åé—­é›†æ˜¯è¡¥é›†ä¸ºå¼€é›†çš„é›†åˆã€‚å®ƒä»¬çš„é‡è¦æ€§è´¨æ˜¯å®ƒä»¬åœ¨æé™ä¸‹æ˜¯å°é—­çš„ã€‚ä¸€ä¸ªé›†åˆçš„é—­åŒ…æ˜¯åŒ…å«å®ƒçš„æœ€å°é—­é›†ã€‚
- en: '[PRE170]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Do the next exercise without using mem_closure_iff_seq_limit
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸ä½¿ç”¨`mem_closure_iff_seq_limit`çš„æƒ…å†µä¸‹å®Œæˆä¸‹ä¸€ä¸ªç»ƒä¹ 
- en: '[PRE171]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Remember from the filters sections that neighborhood filters play a big role
    in Mathlib. In the metric space context, the crucial point is that balls provide
    bases for those filters. The main lemmas here are `Metric.nhds_basis_ball` and
    `Metric.nhds_basis_closedBall` that claim this for open and closed balls with
    positive radius. The center point is an implicit argument so we can invoke `Filter.HasBasis.mem_iff`
    as in the following example.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: è®°ä½ä»è¿‡æ»¤å™¨éƒ¨åˆ†ï¼Œé‚»åŸŸè¿‡æ»¤å™¨åœ¨Mathlibä¸­èµ·ç€é‡è¦ä½œç”¨ã€‚åœ¨åº¦é‡ç©ºé—´çš„æƒ…å†µä¸‹ï¼Œå…³é”®ç‚¹æ˜¯çƒæä¾›äº†è¿™äº›è¿‡æ»¤å™¨çš„åŸºã€‚è¿™é‡Œçš„ä¸»è¦å¼•ç†æ˜¯`Metric.nhds_basis_ball`å’Œ`Metric.nhds_basis_closedBall`ï¼Œå®ƒä»¬å£°ç§°å¯¹äºæ­£åŠå¾„çš„å¼€çƒå’Œé—­çƒã€‚ä¸­å¿ƒç‚¹æ˜¯éšå«çš„å‚æ•°ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åƒä»¥ä¸‹ç¤ºä¾‹ä¸­é‚£æ ·è°ƒç”¨`Filter.HasBasis.mem_iff`ã€‚
- en: '[PRE172]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 11.2.3\. Compactness[ïƒ](#compactness "Link to this heading")
  id: totrans-595
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.3\. ç´§è‡´æ€§[ïƒ](#compactness "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")
- en: 'Compactness is an important topological notion. It distinguishes subsets of
    a metric space that enjoy the same kind of properties as segments in the reals
    compared to other intervals:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: ç´§è‡´æ€§æ˜¯ä¸€ä¸ªé‡è¦çš„æ‹“æ‰‘æ¦‚å¿µã€‚å®ƒåŒºåˆ†äº†åº¦é‡ç©ºé—´ä¸­çš„å­é›†ï¼Œè¿™äº›å­é›†ä¸å…¶ä»–åŒºé—´ç›¸æ¯”ï¼Œä¸å®æ•°ä¸­çš„çº¿æ®µå…·æœ‰ç›¸åŒçš„æ€§è´¨ï¼š
- en: Any sequence with values in a compact set has a subsequence that converges in
    this set.
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä»»ä½•åœ¨ç´§è‡´é›†åˆä¸­å–å€¼çš„åºåˆ—éƒ½æœ‰ä¸€ä¸ªå­åºåˆ—åœ¨è¿™ä¸ªé›†åˆä¸­æ”¶æ•›ã€‚
- en: Any continuous function on a nonempty compact set with values in real numbers
    is bounded and attains its bounds somewhere (this is called the extreme value
    theorem).
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä»»ä½•åœ¨éç©ºç´§è‡´é›†åˆä¸Šå®šä¹‰çš„è¿ç»­å‡½æ•°ï¼Œå…¶å€¼åœ¨å®æ•°ä¸­éƒ½æ˜¯æœ‰ç•Œçš„ï¼Œå¹¶ä¸”åœ¨å…¶æŸä¸ªåœ°æ–¹è¾¾åˆ°å…¶ç•Œé™ï¼ˆè¿™è¢«ç§°ä¸ºæå€¼å®šç†ï¼‰ã€‚
- en: Compact sets are closed sets.
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç´§è‡´é›†æ˜¯é—­é›†ã€‚
- en: Let us first check that the unit interval in the reals is indeed a compact set,
    and then check the above claims for compact sets in general metric spaces. In
    the second statement we only need continuity on the given set so we will use `ContinuousOn`
    instead of `Continuous`, and we will give separate statements for the minimum
    and the maximum. Of course all these results are deduced from more general versions,
    some of which will be discussed in later sections.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å…ˆæ£€æŸ¥å®æ•°ä¸­çš„å•ä½åŒºé—´ç¡®å®æ˜¯ä¸€ä¸ªç´§è‡´é›†åˆï¼Œç„¶åæ£€æŸ¥ä¸€èˆ¬åº¦é‡ç©ºé—´ä¸­ç´§è‡´é›†åˆçš„ä¸Šè¿°æ–­è¨€ã€‚åœ¨ç¬¬äºŒä¸ªé™ˆè¿°ä¸­ï¼Œæˆ‘ä»¬åªéœ€è¦ç»™å®šé›†åˆä¸Šçš„è¿ç»­æ€§ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†ä½¿ç”¨`ContinuousOn`è€Œä¸æ˜¯`Continuous`ï¼Œæˆ‘ä»¬å°†ä¸ºæœ€å°å€¼å’Œæœ€å¤§å€¼ç»™å‡ºå•ç‹¬çš„é™ˆè¿°ã€‚å½“ç„¶ï¼Œæ‰€æœ‰è¿™äº›ç»“æœéƒ½æ˜¯ä»æ›´ä¸€èˆ¬çš„ç‰ˆæœ¬ä¸­æ¨å¯¼å‡ºæ¥çš„ï¼Œå…¶ä¸­ä¸€äº›å°†åœ¨åé¢çš„ç« èŠ‚ä¸­è®¨è®ºã€‚
- en: '[PRE173]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'We can also specify that a metric spaces is globally compact, using an extra
    `Prop`-valued type class:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å¯ä»¥æŒ‡å®šä¸€ä¸ªåº¦é‡ç©ºé—´æ˜¯å…¨å±€ç´§è‡´çš„ï¼Œä½¿ç”¨ä¸€ä¸ªé¢å¤–çš„`Prop`å€¼ç±»å‹ç±»ï¼š
- en: '[PRE174]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: In a compact metric space any closed set is compact, this is `IsClosed.isCompact`.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç´§è‡´åº¦é‡ç©ºé—´ä¸­ï¼Œä»»ä½•é—­é›†éƒ½æ˜¯ç´§è‡´çš„ï¼Œè¿™æ˜¯`IsClosed.isCompact`ã€‚
- en: 11.2.4\. Uniformly continuous functions[ïƒ](#uniformly-continuous-functions "Link
    to this heading")
  id: totrans-605
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.4\. å‡åŒ€è¿ç»­å‡½æ•°[ïƒ](#uniformly-continuous-functions "é“¾æ¥åˆ°æœ¬æ ‡é¢˜")
- en: 'We now turn to uniformity notions on metric spaces : uniformly continuous functions,
    Cauchy sequences and completeness. Again those are defined in a more general context
    but we have lemmas in the metric name space to access their elementary definitions.
    We start with uniform continuity.'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨è½¬å‘åº¦é‡ç©ºé—´ä¸Šçš„å‡åŒ€æ€§æ¦‚å¿µï¼šå‡åŒ€è¿ç»­å‡½æ•°ã€æŸ¯è¥¿åºåˆ—å’Œå®Œå¤‡æ€§ã€‚åŒæ ·ï¼Œè¿™äº›éƒ½æ˜¯åœ¨æ›´ä¸€èˆ¬çš„ç¯å¢ƒä¸­å®šä¹‰çš„ï¼Œä½†æˆ‘ä»¬æœ‰åœ¨åº¦é‡åç§°ç©ºé—´ä¸­çš„å¼•ç†æ¥è®¿é—®å®ƒä»¬çš„å…ƒç´ å®šä¹‰ã€‚æˆ‘ä»¬é¦–å…ˆä»å‡åŒ€è¿ç»­æ€§å¼€å§‹ã€‚
- en: '[PRE175]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: In order to practice manipulating all those definitions, we will prove that
    continuous functions from a compact metric space to a metric space are uniformly
    continuous (we will see a more general version in a later section).
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ç»ƒä¹ æ“ä½œæ‰€æœ‰è¿™äº›å®šä¹‰ï¼Œæˆ‘ä»¬å°†è¯æ˜ä»ç´§è‡´åº¦é‡ç©ºé—´åˆ°åº¦é‡ç©ºé—´çš„è¿ç»­å‡½æ•°æ˜¯å‡åŒ€è¿ç»­çš„ï¼ˆæˆ‘ä»¬å°†åœ¨ç¨åçš„ç« èŠ‚ä¸­çœ‹åˆ°æ›´ä¸€èˆ¬çš„å½¢å¼ï¼‰ã€‚
- en: 'We will first give an informal sketch. Let `f : X â†’ Y` be a continuous function
    from a compact metric space to a metric space. We fix `Îµ > 0` and start looking
    for some `Î´`.'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 'æˆ‘ä»¬é¦–å…ˆç»™å‡ºä¸€ä¸ªéæ­£å¼çš„è‰å›¾ã€‚è®¾ `f : X â†’ Y` æ˜¯ä»ä¸€ä¸ªç´§è‡´åº¦é‡ç©ºé—´åˆ°åº¦é‡ç©ºé—´çš„è¿ç»­å‡½æ•°ã€‚æˆ‘ä»¬å›ºå®š `Îµ > 0` å¹¶å¼€å§‹å¯»æ‰¾æŸä¸ª `Î´`ã€‚'
- en: 'Let `Ï† : X Ã— X â†’ â„ := fun p â†¦ dist (f p.1) (f p.2)` and let `K := { p : X Ã—
    X | Îµ â‰¤ Ï† p }`. Observe `Ï†` is continuous since `f` and distance are continuous.
    And `K` is clearly closed (use `isClosed_le`) hence compact since `X` is compact.'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 'è®¾ `Ï† : X Ã— X â†’ â„ := fun p â†¦ dist (f p.1) (f p.2)` å’Œ `K := { p : X Ã— X | Îµ â‰¤
    Ï† p }`ã€‚è§‚å¯Ÿ `Ï†` æ˜¯è¿ç»­çš„ï¼Œå› ä¸º `f` å’Œè·ç¦»éƒ½æ˜¯è¿ç»­çš„ã€‚å¹¶ä¸” `K` æ˜¾ç„¶æ˜¯é—­é›†ï¼ˆä½¿ç”¨ `isClosed_le`ï¼‰ï¼Œå› æ­¤ç”±äº `X` æ˜¯ç´§è‡´çš„ï¼Œ`K`
    ä¹Ÿæ˜¯ç´§è‡´çš„ã€‚'
- en: Then we discuss two possibilities using `eq_empty_or_nonempty`. If `K` is empty
    then we are clearly done (we can set `Î´ = 1` for instance). So letâ€™s assume `K`
    is not empty, and use the extreme value theorem to choose `(xâ‚€, xâ‚)` attaining
    the infimum of the distance function on `K`. We can then set `Î´ = dist xâ‚€ xâ‚`
    and check everything works.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬è®¨è®ºä¸¤ç§å¯èƒ½æ€§ï¼Œä½¿ç”¨ `eq_empty_or_nonempty`ã€‚å¦‚æœ `K` æ˜¯ç©ºçš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ˜¾ç„¶å·²ç»å®Œæˆäº†ï¼ˆä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥å°† `Î´` è®¾ç½®ä¸º
    `1`ï¼‰ã€‚æ‰€ä»¥è®©æˆ‘ä»¬å‡è®¾ `K` ä¸æ˜¯ç©ºçš„ï¼Œå¹¶ä½¿ç”¨æå€¼å®šç†æ¥é€‰æ‹© `(xâ‚€, xâ‚)`ï¼Œå®ƒè¾¾åˆ°è·ç¦»å‡½æ•°åœ¨ `K` ä¸Šçš„ä¸‹ç¡®ç•Œã€‚ç„¶åæˆ‘ä»¬å¯ä»¥å°† `Î´` è®¾ç½®ä¸º
    `dist xâ‚€ xâ‚` å¹¶æ£€æŸ¥ä¸€åˆ‡æ˜¯å¦æ­£å¸¸å·¥ä½œã€‚
- en: '[PRE176]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 11.2.5\. Completeness[ïƒ](#completeness "Link to this heading")
  id: totrans-613
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.5\. å®Œå¤‡æ€§[ïƒ](#completeness "é“¾æ¥åˆ°æœ¬æ ‡é¢˜")
- en: A Cauchy sequence in a metric space is a sequence whose terms get closer and
    closer to each other. There are a couple of equivalent ways to state that idea.
    In particular converging sequences are Cauchy. The converse is true only in so-called
    *complete* spaces.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨åº¦é‡ç©ºé—´ä¸­çš„æŸ¯è¥¿åºåˆ—æ˜¯ä¸€ä¸ªå…¶é¡¹å½¼æ­¤è¶Šæ¥è¶Šæ¥è¿‘çš„åºåˆ—ã€‚æœ‰å‡ ç§ç­‰ä»·çš„æ–¹å¼æ¥è¡¨è¿°è¿™ä¸ªæƒ³æ³•ã€‚ç‰¹åˆ«æ˜¯æ”¶æ•›åºåˆ—æ˜¯æŸ¯è¥¿åºåˆ—ã€‚é€†å‘½é¢˜ä»…åœ¨æ‰€è°“çš„ *å®Œå¤‡* ç©ºé—´ä¸­æˆç«‹ã€‚
- en: '[PRE177]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Weâ€™ll practice using this definition by proving a convenient criterion which
    is a special case of a criterion appearing in Mathlib. This is also a good opportunity
    to practice using big sums in a geometric context. In addition to the explanations
    from the filters section, you will probably need `tendsto_pow_atTop_nhds_zero_of_lt_one`,
    `Tendsto.mul` and `dist_le_range_sum_dist`.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†é€šè¿‡è¯æ˜ä¸€ä¸ªæ–¹ä¾¿çš„åˆ¤æ®æ¥ç»ƒä¹ ä½¿ç”¨è¿™ä¸ªå®šä¹‰ï¼Œè¿™ä¸ªåˆ¤æ®æ˜¯ Mathlib ä¸­å‡ºç°çš„ä¸€ä¸ªåˆ¤æ®çš„ç‰¹æ®Šæƒ…å†µã€‚è¿™ä¹Ÿæ˜¯ç»ƒä¹ åœ¨å‡ ä½•ç¯å¢ƒä¸­ä½¿ç”¨å¤§å’Œçš„å¥½æœºä¼šã€‚é™¤äº†è¿‡æ»¤å™¨éƒ¨åˆ†çš„è§£é‡Šå¤–ï¼Œä½ å¯èƒ½è¿˜éœ€è¦
    `tendsto_pow_atTop_nhds_zero_of_lt_one`ã€`Tendsto.mul` å’Œ `dist_le_range_sum_dist`ã€‚
- en: '[PRE178]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'We are ready for the final boss of this section: Baireâ€™s theorem for complete
    metric spaces! The proof skeleton below shows interesting techniques. It uses
    the `choose` tactic in its exclamation mark variant (you should experiment with
    removing this exclamation mark) and it shows how to define something inductively
    in the middle of a proof using `Nat.rec_on`.'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»å‡†å¤‡å¥½æœ¬èŠ‚çš„æœ€ç»ˆå¤§BOSSï¼šå®Œå¤‡åº¦é‡ç©ºé—´çš„Baireå®šç†ï¼ä¸‹é¢çš„è¯æ˜æ¡†æ¶å±•ç¤ºäº†æœ‰è¶£çš„æŠ€å·§ã€‚å®ƒä½¿ç”¨äº†æ„Ÿå¹å·å˜ä½“çš„ `choose` ç­–ç•¥ï¼ˆä½ åº”è¯¥å°è¯•ç§»é™¤è¿™ä¸ªæ„Ÿå¹å·ï¼‰å¹¶å±•ç¤ºäº†å¦‚ä½•åœ¨è¯æ˜ä¸­ä½¿ç”¨
    `Nat.rec_on` é€’å½’åœ°å®šä¹‰æŸç‰©ã€‚
- en: '[PRE179]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '## 11.3\. Topological spaces[ïƒ](#topological-spaces "Link to this heading")'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '## 11.3\. æ‹“æ‰‘ç©ºé—´[ïƒ](#topological-spaces "é“¾æ¥åˆ°æœ¬æ ‡é¢˜")'
- en: 11.3.1\. Fundamentals[ïƒ](#fundamentals "Link to this heading")
  id: totrans-621
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1\. åŸºç¡€[ïƒ](#fundamentals "é“¾æ¥åˆ°æœ¬æ ‡é¢˜")
- en: We now go up in generality and introduce topological spaces. We will review
    the two main ways to define topological spaces and then explain how the category
    of topological spaces is much better behaved than the category of metric spaces.
    Note that we wonâ€™t be using Mathlib category theory here, only having a somewhat
    categorical point of view.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨æé«˜ä¸€èˆ¬æ€§ï¼Œå¼•å…¥æ‹“æ‰‘ç©ºé—´ã€‚æˆ‘ä»¬å°†å›é¡¾å®šä¹‰æ‹“æ‰‘ç©ºé—´çš„ä¸¤ç§ä¸»è¦æ–¹æ³•ï¼Œç„¶åè§£é‡Šæ‹“æ‰‘ç©ºé—´èŒƒç•´æ¯”åº¦é‡ç©ºé—´èŒƒç•´è¡¨ç°å¾—æ›´å¥½ã€‚è¯·æ³¨æ„ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œä¸ä¼šä½¿ç”¨ Mathlib
    çš„èŒƒç•´è®ºï¼Œè€Œåªæ˜¯æœ‰ä¸€ä¸ªæŸç§èŒƒç•´çš„è§‚ç‚¹ã€‚
- en: The first way to think about the transition from metric spaces to topological
    spaces is that we only remember the notion of open sets (or equivalently the notion
    of closed sets). From this point of view, a topological space is a type equipped
    with a collection of sets that are called open sets. This collection has to satisfy
    a number of axioms presented below (this collection is slightly redundant but
    we will ignore that).
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘ä»åº¦é‡ç©ºé—´åˆ°æ‹“æ‰‘ç©ºé—´çš„è¿‡æ¸¡çš„ç¬¬ä¸€ç§æ–¹æ³•æ˜¯ï¼Œæˆ‘ä»¬åªè®°ä½å¼€é›†çš„æ¦‚å¿µï¼ˆæˆ–ç­‰ä»·åœ°ï¼Œé—­é›†çš„æ¦‚å¿µï¼‰ã€‚ä»è¿™ä¸ªè§’åº¦æ¥çœ‹ï¼Œæ‹“æ‰‘ç©ºé—´æ˜¯ä¸€ç§ç±»å‹ï¼Œå®ƒé…å¤‡äº†ä¸€ç»„ç§°ä¸ºå¼€é›†çš„é›†åˆã€‚è¿™ä¸ªé›†åˆå¿…é¡»æ»¡è¶³ä»¥ä¸‹ï¼ˆä¸‹é¢ï¼‰æå‡ºçš„è‹¥å¹²å…¬ç†ï¼ˆè¿™ä¸ªé›†åˆç•¥å¾®å†—ä½™ï¼Œä½†æˆ‘ä»¬å°†å¿½ç•¥è¿™ä¸€ç‚¹ï¼‰ã€‚
- en: '[PRE180]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Closed sets are then defined as sets whose complement is open. A function between
    topological spaces is (globally) continuous if all preimages of open sets are
    open.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: é—­é›†å®šä¹‰ä¸ºè¡¥é›†æ˜¯å¼€é›†çš„é›†åˆã€‚åœ¨æ‹“æ‰‘ç©ºé—´ä¹‹é—´çš„å‡½æ•°ï¼ˆå…¨å±€ï¼‰è¿ç»­ï¼Œå¦‚æœæ‰€æœ‰å¼€é›†çš„å‰åƒéƒ½æ˜¯å¼€é›†ã€‚
- en: '[PRE181]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'With this definition we already see that, compared to metric spaces, topological
    spaces only remember enough information to talk about continuous functions: two
    topological structures on a type are the same if and only if they have the same
    continuous functions (indeed the identity function will be continuous in both
    direction if and only if the two structures have the same open sets).'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: æ ¹æ®è¿™ä¸ªå®šä¹‰ï¼Œæˆ‘ä»¬å·²çœ‹åˆ°ï¼Œä¸åº¦é‡ç©ºé—´ç›¸æ¯”ï¼Œæ‹“æ‰‘ç©ºé—´åªè®°ä½è¶³å¤Ÿçš„ä¿¡æ¯æ¥è®¨è®ºè¿ç»­å‡½æ•°ï¼šä¸€ä¸ªç±»å‹ä¸Šçš„ä¸¤ä¸ªæ‹“æ‰‘ç»“æ„ç›¸åŒï¼Œå½“ä¸”ä»…å½“å®ƒä»¬æœ‰ç›¸åŒçš„è¿ç»­å‡½æ•°ï¼ˆå®é™…ä¸Šï¼Œå¦‚æœä¸¤ä¸ªç»“æ„æœ‰ç›¸åŒçš„å¼€é›†ï¼Œé‚£ä¹ˆæ’ç­‰å‡½æ•°åœ¨è¿™ä¸¤ä¸ªæ–¹å‘ä¸Šéƒ½å°†è¿ç»­ï¼‰ã€‚
- en: 'However as soon as we move on to continuity at a point we see the limitations
    of the approach based on open sets. In Mathlib we frequently think of topological
    spaces as types equipped with a neighborhood filter `ğ“ x` attached to each point
    `x` (the corresponding function `X â†’ Filter X` satisfies certain conditions explained
    further down). Remember from the filters section that these gadgets play two related
    roles. First `ğ“ x` is seen as the generalized set of points of `X` that are close
    to `x`. And then it is seen as giving a way to say, for any predicate `P : X â†’
    Prop`, that this predicate holds for points that are close enough to `x`. Let
    us state that `f : X â†’ Y` is continuous at `x`. The purely filtery way is to say
    that the direct image under `f` of the generalized set of points that are close
    to `x` is contained in the generalized set of points that are close to `f x`.
    Recall this is spelled either `map f (ğ“ x) â‰¤ ğ“ (f x)` or `Tendsto f (ğ“ x) (ğ“ (f
    x))`.'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç„¶è€Œï¼Œä¸€æ—¦æˆ‘ä»¬è½¬å‘ç‚¹çš„è¿ç»­æ€§ï¼Œæˆ‘ä»¬å°±çœ‹åˆ°äº†åŸºäºå¼€é›†çš„æ–¹æ³•çš„å±€é™æ€§ã€‚åœ¨Mathlibä¸­ï¼Œæˆ‘ä»¬ç»å¸¸å°†æ‹“æ‰‘ç©ºé—´è§†ä¸ºç±»å‹ï¼Œæ¯ä¸ªç‚¹`x`éƒ½é™„æœ‰ä¸€ä¸ªé‚»åŸŸæ»¤æ³¢å™¨`ğ“
    x`ï¼ˆç›¸åº”çš„å‡½æ•°`X â†’ Filter X`æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼Œå°†åœ¨ä¸‹é¢è¿›ä¸€æ­¥è§£é‡Šï¼‰ã€‚è®°ä½ä»æ»¤æ³¢å™¨éƒ¨åˆ†ï¼Œè¿™äº›å°ç©æ„å„¿æ‰®æ¼”ä¸¤ä¸ªç›¸å…³çš„è§’è‰²ã€‚é¦–å…ˆï¼Œ`ğ“ x`è¢«è§†ä¸ºæ¥è¿‘`x`çš„`X`ç‚¹çš„å¹¿ä¹‰é›†åˆã€‚ç„¶åï¼Œå®ƒè¢«è§†ä¸ºæä¾›äº†ä¸€ç§æ–¹å¼ï¼Œå¯¹äºä»»ä½•è°“è¯`P
    : X â†’ Prop`ï¼Œå¯ä»¥è¯´æ˜è¿™ä¸ªè°“è¯å¯¹äºè¶³å¤Ÿæ¥è¿‘`x`çš„ç‚¹æˆç«‹ã€‚è®©æˆ‘ä»¬å£°æ˜`f : X â†’ Y`åœ¨`x`å¤„æ˜¯è¿ç»­çš„ã€‚çº¯ç²¹åŸºäºæ»¤æ³¢å™¨çš„æ–¹å¼æ˜¯è¯´ï¼Œ`f`çš„ç›´æ¥åƒåŒ…å«æ¥è¿‘`x`çš„ç‚¹çš„å¹¿ä¹‰é›†åˆï¼ŒåŒ…å«åœ¨æ¥è¿‘`f
    x`çš„ç‚¹çš„å¹¿ä¹‰é›†åˆä¸­ã€‚å›å¿†ä¸€ä¸‹ï¼Œè¿™å¯ä»¥è¡¨ç¤ºä¸º`map f (ğ“ x) â‰¤ ğ“ (f x)`æˆ–`Tendsto f (ğ“ x) (ğ“ (f x))`ã€‚'
- en: '[PRE182]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'One can also spell it using both neighborhoods seen as ordinary sets and a
    neighborhood filter seen as a generalized set: â€œfor any neighborhood `U` of `f
    x`, all points close to `x` are sent to `U`â€. Note that the proof is again `Iff.rfl`,
    this point of view is definitionally equivalent to the previous one.'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹Ÿå¯ä»¥ä½¿ç”¨ä¸¤ç§é‚»åŸŸï¼ˆè§†ä¸ºæ™®é€šé›†åˆï¼‰å’Œä¸€ç§é‚»åŸŸæ»¤æ³¢å™¨ï¼ˆè§†ä¸ºå¹¿ä¹‰é›†åˆï¼‰æ¥è¡¨è¿°ï¼šå¯¹äº`f x`çš„ä»»ä½•é‚»åŸŸ`U`ï¼Œæ‰€æœ‰æ¥è¿‘`x`çš„ç‚¹éƒ½è¢«å‘é€åˆ°`U`ã€‚è¯·æ³¨æ„ï¼Œè¯æ˜ä»ç„¶æ˜¯`Iff.rfl`ï¼Œè¿™ä¸ªè§‚ç‚¹åœ¨å®šä¹‰ä¸Šç­‰åŒäºå‰ä¸€ä¸ªè§‚ç‚¹ã€‚
- en: '[PRE183]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: We now explain how to go from one point of view to the other. In terms of open
    sets, we can simply define members of `ğ“ x` as sets that contain an open set containing
    `x`.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬è§£é‡Šå¦‚ä½•ä»ä¸€ä¸ªè§‚ç‚¹è¿‡æ¸¡åˆ°å¦ä¸€ä¸ªè§‚ç‚¹ã€‚ä»å¼€é›†çš„è§’åº¦æ¥çœ‹ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•åœ°å®šä¹‰`ğ“ x`çš„æˆå‘˜ä¸ºåŒ…å«`x`çš„å¼€é›†çš„é›†åˆã€‚
- en: '[PRE184]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'To go in the other direction we need to discuss the condition that `ğ“ : X â†’
    Filter X` must satisfy in order to be the neighborhood function of a topology.'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 'è¦æœç›¸åçš„æ–¹å‘å‰è¿›ï¼Œæˆ‘ä»¬éœ€è¦è®¨è®º`ğ“ : X â†’ Filter X`å¿…é¡»æ»¡è¶³çš„æ¡ä»¶ï¼Œä»¥ä¾¿æˆä¸ºæ‹“æ‰‘çš„é‚»åŸŸå‡½æ•°ã€‚'
- en: The first constraint is that `ğ“ x`, seen as a generalized set, contains the
    set `{x}` seen as the generalized set `pure x` (explaining this weird name would
    be too much of a digression, so we simply accept it for now). Another way to say
    it is that if a predicate holds for points close to `x` then it holds at `x`.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ä¸ªçº¦æŸæ˜¯ï¼Œ`ğ“ x`ï¼ˆè§†ä¸ºå¹¿ä¹‰é›†åˆï¼‰åŒ…å«è¢«è§†ä¸ºå¹¿ä¹‰é›†åˆ`pure x`çš„é›†åˆ`{x}`ï¼ˆè§£é‡Šè¿™ä¸ªå¥‡æ€ªçš„åå­—ä¼šå¤ªåˆ†æ•£æ³¨æ„åŠ›ï¼Œæ‰€ä»¥æˆ‘ä»¬ç°åœ¨ç®€å•åœ°æ¥å—å®ƒï¼‰ã€‚å¦ä¸€ç§è¯´æ³•æ˜¯ï¼Œå¦‚æœä¸€ä¸ªè°“è¯å¯¹äºæ¥è¿‘`x`çš„ç‚¹æˆç«‹ï¼Œé‚£ä¹ˆå®ƒåœ¨`x`å¤„ä¹Ÿæˆç«‹ã€‚
- en: '[PRE185]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Then a more subtle requirement is that, for any predicate `P : X â†’ Prop` and
    any `x`, if `P y` holds for `y` close to `x` then for `y` close to `x` and `z`
    close to `y`, `P z` holds. More precisely we have:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç„¶åä¸€ä¸ªæ›´å¾®å¦™çš„è¦æ±‚æ˜¯ï¼Œå¯¹äºä»»ä½•è°“è¯`P : X â†’ Prop`å’Œä»»ä½•`x`ï¼Œå¦‚æœ`P y`å¯¹æ¥è¿‘`x`çš„`y`æˆç«‹ï¼Œé‚£ä¹ˆå¯¹äºæ¥è¿‘`x`å’Œæ¥è¿‘`y`çš„`z`ï¼Œ`P
    z`ä¹Ÿæˆç«‹ã€‚æ›´ç²¾ç¡®åœ°è¯´ï¼Œæˆ‘ä»¬æœ‰ï¼š'
- en: '[PRE186]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Those two results characterize the functions `X â†’ Filter X` that are neighborhood
    functions for a topological space structure on `X`. There is a still a function
    `TopologicalSpace.mkOfNhds : (X â†’ Filter X) â†’ TopologicalSpace X` but it will
    give back its input as a neighborhood function only if it satisfies the above
    two constraints. More precisely we have a lemma `TopologicalSpace.nhds_mkOfNhds`
    saying that in a different way and our next exercise deduces this different way
    from how we stated it above.'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 'è¿™ä¸¤ä¸ªç»“æœæè¿°äº†`X â†’ Filter X`çš„å‡½æ•°ï¼Œè¿™äº›å‡½æ•°æ˜¯`X`ä¸Šçš„æ‹“æ‰‘ç©ºé—´ç»“æ„çš„é‚»åŸŸå‡½æ•°ã€‚ä»ç„¶æœ‰ä¸€ä¸ªå‡½æ•°`TopologicalSpace.mkOfNhds
    : (X â†’ Filter X) â†’ TopologicalSpace X`ï¼Œä½†å®ƒåªæœ‰åœ¨æ»¡è¶³ä¸Šè¿°ä¸¤ä¸ªçº¦æŸæ—¶æ‰ä¼šå°†å…¶è¾“å…¥ä½œä¸ºé‚»åŸŸå‡½æ•°è¿”å›ã€‚æ›´ç²¾ç¡®åœ°è¯´ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªå¼•ç†`TopologicalSpace.nhds_mkOfNhds`ï¼Œå®ƒä»¥ä¸åŒçš„æ–¹å¼è¡¨è¾¾ï¼Œæˆ‘ä»¬çš„ä¸‹ä¸€ä¸ªç»ƒä¹ å°†ä»ä¸Šè¿°æ–¹å¼æ¨å¯¼å‡ºè¿™ä¸€ç‚¹ã€‚'
- en: '[PRE187]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Note that `TopologicalSpace.mkOfNhds` is not so frequently used, but it still
    good to know in what precise sense the neighborhood filters is all there is in
    a topological space structure.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œ`TopologicalSpace.mkOfNhds`å¹¶ä¸ç»å¸¸ä½¿ç”¨ï¼Œä½†äº†è§£åœ¨æ‹“æ‰‘ç©ºé—´ç»“æ„ä¸­é‚»åŸŸæ»¤æ³¢å™¨ç©¶ç«Ÿæ„å‘³ç€ä»€ä¹ˆä»ç„¶æ˜¯æœ‰ç›Šçš„ã€‚
- en: 'The next thing to know in order to efficiently use topological spaces in Mathlib
    is that we use a lot of formal properties of `TopologicalSpace : Type u â†’ Type
    u`. From a purely mathematical point of view, those formal properties are a very
    clean way to explain how topological spaces solve issues that metric spaces have.
    From this point of view, the issues solved by topological spaces is that metric
    spaces enjoy very little functoriality, and have very bad categorical properties
    in general. This comes on top of the fact already discussed that metric spaces
    contain a lot of geometrical information that is not topologically relevant.'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¸ºäº†åœ¨Mathlibä¸­é«˜æ•ˆåœ°ä½¿ç”¨æ‹“æ‰‘ç©ºé—´ï¼Œéœ€è¦çŸ¥é“çš„æ˜¯ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†`TopologicalSpace : Type u â†’ Type u`çš„è®¸å¤šå½¢å¼å±æ€§ã€‚ä»çº¯ç²¹æ•°å­¦çš„è§’åº¦æ¥çœ‹ï¼Œè¿™äº›å½¢å¼å±æ€§æ˜¯è§£é‡Šæ‹“æ‰‘ç©ºé—´å¦‚ä½•è§£å†³åº¦é‡ç©ºé—´å­˜åœ¨çš„é—®é¢˜çš„ä¸€ç§éå¸¸å¹²å‡€çš„æ–¹å¼ã€‚ä»è¿™ä¸ªè§’åº¦æ¥çœ‹ï¼Œæ‹“æ‰‘ç©ºé—´è§£å†³çš„é—®é¢˜åœ¨äºåº¦é‡ç©ºé—´å‡ ä¹ä¸å…·æœ‰å‡½å­æ€§ï¼Œå¹¶ä¸”åœ¨ä¸€èˆ¬æ„ä¹‰ä¸Šå…·æœ‰éå¸¸å·®çš„èŒƒç•´æ€§è´¨ã€‚è¿™è¿˜åŸºäºå·²ç»è®¨è®ºçš„äº‹å®ï¼Œå³åº¦é‡ç©ºé—´åŒ…å«å¤§é‡ä¸æ‹“æ‰‘æ— å…³çš„å‡ ä½•ä¿¡æ¯ã€‚'
- en: Let us focus on functoriality first. A metric space structure can be induced
    on a subset or, equivalently, it can be pulled back by an injective map. But thatâ€™s
    pretty much everything. They cannot be pulled back by general map or pushed forward,
    even by surjective maps.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å…ˆå…³æ³¨å‡½å­æ€§ã€‚åº¦é‡ç©ºé—´ç»“æ„å¯ä»¥è¯±å¯¼åœ¨å­é›†ä¸Šï¼Œæˆ–è€…ç­‰ä»·åœ°ï¼Œå®ƒå¯ä»¥ç”±ä¸€ä¸ªæ³¨å…¥æ˜ å°„æ‹‰å›ã€‚ä½†è¿™å°±æ˜¯å…¨éƒ¨äº†ã€‚å®ƒä»¬ä¸èƒ½ç”±ä¸€èˆ¬æ˜ å°„æˆ–æ¨è¿›ï¼Œç”šè‡³ä¸èƒ½ç”±æ»¡å°„æ˜ å°„æ‹‰å›ã€‚
- en: 'In particular there is no sensible distance to put on a quotient of a metric
    space or on an uncountable product of metric spaces. Consider for instance the
    type `â„ â†’ â„`, seen as a product of copies of `â„` indexed by `â„`. We would like
    to say that pointwise convergence of sequences of functions is a respectable notion
    of convergence. But there is no distance on `â„ â†’ â„` that gives this notion of
    convergence. Relatedly, there is no distance ensuring that a map `f : X â†’ (â„ â†’
    â„)` is continuous if and only if `fun x â†¦ f x t` is continuous for every `t :
    â„`.'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç‰¹åˆ«æ˜¯ï¼Œåœ¨åº¦é‡ç©ºé—´çš„å•†æˆ–ä¸å¯æ•°åº¦é‡ç©ºé—´çš„ç§¯ä¸Šæ— æ³•æ”¾ç½®ä¸€ä¸ªæœ‰æ„ä¹‰çš„è·ç¦»ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘ç±»å‹`â„ â†’ â„`ï¼Œå®ƒè¢«è§†ä¸ºç”±`â„`ç´¢å¼•çš„`â„`çš„å¤åˆ¶å“çš„ç§¯ã€‚æˆ‘ä»¬å¸Œæœ›è¯´ï¼Œå‡½æ•°åºåˆ—é€ç‚¹æ”¶æ•›æ˜¯ä¸€ä¸ªå€¼å¾—å°Šé‡çš„æ”¶æ•›æ¦‚å¿µã€‚ä½†åœ¨`â„
    â†’ â„`ä¸Šæ²¡æœ‰è·ç¦»å¯ä»¥ç»™å‡ºè¿™ç§æ”¶æ•›æ¦‚å¿µã€‚ç›¸å…³åœ°ï¼Œæ²¡æœ‰è·ç¦»å¯ä»¥ä¿è¯æ˜ å°„`f : X â†’ (â„ â†’ â„)`æ˜¯è¿ç»­çš„å½“ä¸”ä»…å½“å¯¹äºæ¯ä¸ª`t : â„`ï¼Œ`fun x
    â†¦ f x t`æ˜¯è¿ç»­çš„ã€‚'
- en: 'We now review the data used to solve all those issues. First we can use any
    map `f : X â†’ Y` to push or pull topologies from one side to the other. Those two
    operations form a Galois connection.'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 'æˆ‘ä»¬ç°åœ¨å›é¡¾ç”¨äºè§£å†³æ‰€æœ‰è¿™äº›é—®é¢˜çš„æ•°æ®ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»»ä½•æ˜ å°„`f : X â†’ Y`æ¥ä»ä¸€ä¸ªæ–¹å‘æ¨è¿›æˆ–æ‹‰å›æ‹“æ‰‘ã€‚è¿™ä¸¤ä¸ªæ“ä½œå½¢æˆä¸€ä¸ªGaloisè¿æ¥ã€‚'
- en: '[PRE188]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: Those operations are compatible with composition of functions. As usual, pushing
    forward is covariant and pulling back is contravariant, see `coinduced_compose`
    and `induced_compose`. On paper we will use notations \(f_*T\) for `TopologicalSpace.coinduced
    f T` and \(f^*T\) for `TopologicalSpace.induced f T`.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æ“ä½œä¸å‡½æ•°çš„ç»„åˆæ˜¯å…¼å®¹çš„ã€‚é€šå¸¸ï¼Œæ¨è¿›æ˜¯åå˜çš„ï¼Œè€Œæ‹‰å›æ˜¯åå¯¹ç§°çš„ï¼Œå‚è§`coinduced_compose`å’Œ`induced_compose`ã€‚åœ¨çº¸ä¸Šï¼Œæˆ‘ä»¬å°†ä½¿ç”¨`f_*T`è¡¨ç¤º`TopologicalSpace.coinduced
    f T`ï¼Œä½¿ç”¨`f^*T`è¡¨ç¤º`TopologicalSpace.induced f T`ã€‚
- en: 'Then the next big piece is a complete lattice structure on `TopologicalSpace
    X` for any given structure. If you think of topologies as being primarily the
    data of open sets then you expect the order relation on `TopologicalSpace X` to
    come from `Set (Set X)`, i.e. you expect `t â‰¤ t''` if a set `u` is open for `t''`
    as soon as it is open for `t`. However we already know that Mathlib focuses on
    neighborhoods more than open sets so, for any `x : X` we want the map from topological
    spaces to neighborhoods `fun T : TopologicalSpace X â†¦ @nhds X T x` to be order
    preserving. And we know the order relation on `Filter X` is designed to ensure
    an order preserving `principal : Set X â†’ Filter X`, allowing to see filters as
    generalized sets. So the order relation we do use on `TopologicalSpace X` is opposite
    to the one coming from `Set (Set X)`.'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ¥ä¸‹æ¥çš„é‡è¦éƒ¨åˆ†æ˜¯å¯¹äºä»»ä½•ç»™å®šçš„ç»“æ„åœ¨ `TopologicalSpace X` ä¸Šçš„å®Œå¤‡æ ¼ç»“æ„ã€‚å¦‚æœä½ è®¤ä¸ºæ‹“æ‰‘ä¸»è¦æ˜¯å¼€é›†çš„æ•°æ®ï¼Œé‚£ä¹ˆä½ æœŸæœ› `TopologicalSpace
    X` ä¸Šçš„åºå…³ç³»æ¥è‡ª `Set (Set X)`ï¼Œå³ä½ æœŸæœ›å¦‚æœé›†åˆ `u` å¯¹äº `t''` æ˜¯å¼€é›†ï¼Œé‚£ä¹ˆå®ƒå¯¹äº `t` ä¹Ÿæ˜¯å¼€é›†ï¼Œä½ å°±æœŸæœ› `t â‰¤ t''`ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å·²ç»çŸ¥é“
    Mathlib æ›´å…³æ³¨é‚»åŸŸè€Œä¸æ˜¯å¼€é›†ï¼Œæ‰€ä»¥å¯¹äºä»»ä½• `x : X`ï¼Œæˆ‘ä»¬å¸Œæœ›ä»æ‹“æ‰‘ç©ºé—´åˆ°é‚»åŸŸçš„æ˜ å°„ `fun T : TopologicalSpace X
    â†¦ @nhds X T x` æ˜¯åºä¿æŒçš„ã€‚æˆ‘ä»¬è¿˜çŸ¥é“ `Filter X` ä¸Šçš„åºå…³ç³»è¢«è®¾è®¡æˆç¡®ä¿åºä¿æŒçš„ `principal : Set X â†’ Filter
    X`ï¼Œå…è®¸å°†è¿‡æ»¤å™¨è§†ä¸ºå¹¿ä¹‰é›†åˆã€‚å› æ­¤ï¼Œæˆ‘ä»¬åœ¨ `TopologicalSpace X` ä¸Šä½¿ç”¨çš„åºå…³ç³»ä¸æ¥è‡ª `Set (Set X)` çš„åºå…³ç³»ç›¸åã€‚'
- en: '[PRE189]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Now we can recover continuity by combining the push-forward (or pull-back) operation
    with the order relation.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¯ä»¥é€šè¿‡ç»“åˆæ¨å‰ï¼ˆæˆ–æ‹‰å›ï¼‰æ“ä½œä¸åºå…³ç³»æ¥æ¢å¤è¿ç»­æ€§ã€‚
- en: '[PRE190]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'With this definition and the compatibility of push-forward and composition,
    we get for free the universal property that, for any topological space \(Z\),
    a function \(g : Y â†’ Z\) is continuous for the topology \(f_*T_X\) if and only
    if \(g âˆ˜ f\) is continuous.'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 'é€šè¿‡è¿™ä¸ªå®šä¹‰å’Œæ¨å‰ä¸å¤åˆçš„å…¼å®¹æ€§ï¼Œæˆ‘ä»¬å…è´¹å¾—åˆ°äº†è¿™æ ·çš„æ³›æ€§è´¨ï¼šå¯¹äºä»»ä½•æ‹“æ‰‘ç©ºé—´ \(Z\)ï¼Œå‡½æ•° \(g : Y â†’ Z\) åœ¨æ‹“æ‰‘ \(f_*T_X\)
    ä¸Šæ˜¯è¿ç»­çš„ï¼Œå½“ä¸”ä»…å½“ \(g âˆ˜ f\) æ˜¯è¿ç»­çš„ã€‚'
- en: \[\begin{split}g \text{ continuous } &â‡” g_*(f_*T_X) â‰¤ T_Z \\ &â‡” (g âˆ˜ f)_* T_X
    â‰¤ T_Z \\ &â‡” g âˆ˜ f \text{ continuous}\end{split}\]
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}g \text{ continuous } &â‡” g_*(f_*T_X) â‰¤ T_Z \\ &â‡” (g âˆ˜ f)_* T_X
    â‰¤ T_Z \\ &â‡” g âˆ˜ f \text{ continuous}\end{split}\]
- en: '[PRE191]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'So we already get quotient topologies (using the projection map as `f`). This
    wasnâ€™t using that `TopologicalSpace X` is a complete lattice for all `X`. Letâ€™s
    now see how all this structure proves the existence of the product topology by
    abstract non-sense. We considered the case of `â„ â†’ â„` above, but letâ€™s now consider
    the general case of `Î  i, X i` for some `Î¹ : Type*` and `X : Î¹ â†’ Type*`. We want,
    for any topological space `Z` and any function `f : Z â†’ Î  i, X i`, that `f` is
    continuous if and only if `(fun x â†¦ x i) âˆ˜ f` is continuous for all `i`. Let us
    explore that constraint â€œon paperâ€ using notation \(p_i\) for the projection `(fun
    (x : Î  i, X i) â†¦ x i)`:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 'å› æ­¤ï¼Œæˆ‘ä»¬å·²å¾—åˆ°å•†æ‹“æ‰‘ï¼ˆä½¿ç”¨æŠ•å½±æ˜ å°„ä½œä¸º `f`ï¼‰ã€‚è¿™å¹¶ä¸æ˜¯ä½¿ç”¨ `TopologicalSpace X` æ˜¯æ‰€æœ‰ `X` çš„å®Œå¤‡æ ¼ã€‚ç°åœ¨è®©æˆ‘ä»¬çœ‹çœ‹æ‰€æœ‰è¿™äº›ç»“æ„æ˜¯å¦‚ä½•é€šè¿‡æŠ½è±¡çš„èƒ¡è¨€ä¹±è¯­æ¥è¯æ˜ä¹˜ç§¯æ‹“æ‰‘çš„å­˜åœ¨æ€§çš„ã€‚æˆ‘ä»¬ä¸Šé¢è€ƒè™‘äº†
    `â„ â†’ â„` çš„æƒ…å†µï¼Œä½†ç°åœ¨è®©æˆ‘ä»¬è€ƒè™‘ä¸€èˆ¬æƒ…å†µ `Î  i, X i` å¯¹äºæŸäº› `Î¹ : Type*` å’Œ `X : Î¹ â†’ Type*`ã€‚æˆ‘ä»¬å¸Œæœ›å¯¹äºä»»ä½•æ‹“æ‰‘ç©ºé—´
    `Z` å’Œä»»ä½•å‡½æ•° `f : Z â†’ Î  i, X i`ï¼Œå¦‚æœ `f` æ˜¯è¿ç»­çš„ï¼Œå½“ä¸”ä»…å½“å¯¹äºæ‰€æœ‰ `i`ï¼Œ`(fun x â†¦ x i) âˆ˜ f` æ˜¯è¿ç»­çš„ã€‚è®©æˆ‘ä»¬ä½¿ç”¨è¡¨ç¤ºæŠ•å½±
    `(fun (x : Î  i, X i) â†¦ x i)` çš„ç¬¦å· \(p_i\) åœ¨â€œçº¸ä¸Šâ€æ¢ç´¢è¿™ä¸ªçº¦æŸï¼š'
- en: \[\begin{split}(âˆ€ i, p_i âˆ˜ f \text{ continuous}) &â‡” âˆ€ i, (p_i âˆ˜ f)_* T_Z â‰¤ T_{X_i}
    \\ &â‡” âˆ€ i, (p_i)_* f_* T_Z â‰¤ T_{X_i}\\ &â‡” âˆ€ i, f_* T_Z â‰¤ (p_i)^*T_{X_i}\\ &â‡” f_*
    T_Z â‰¤ \inf \left[(p_i)^*T_{X_i}\right]\end{split}\]
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}(âˆ€ i, p_i âˆ˜ f \text{ continuous}) &â‡” âˆ€ i, (p_i âˆ˜ f)_* T_Z â‰¤ T_{X_i}
    \\ &â‡” âˆ€ i, (p_i)_* f_* T_Z â‰¤ T_{X_i}\\ &â‡” âˆ€ i, f_* T_Z â‰¤ (p_i)^*T_{X_i}\\ &â‡” f_*
    T_Z â‰¤ \inf \left[(p_i)^*T_{X_i}\right]\end{split}\]
- en: 'So we see that what is the topology we want on `Î  i, X i`:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬çœ‹åˆ°æˆ‘ä»¬å¸Œæœ›åœ¨ `Î  i, X i` ä¸Šå…·æœ‰çš„æ‹“æ‰‘ç»“æ„ï¼š
- en: '[PRE192]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: This ends our tour of how Mathlib thinks that topological spaces fix defects
    of the theory of metric spaces by being a more functorial theory and having a
    complete lattice structure for any fixed type.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±ç»“æŸäº†æˆ‘ä»¬å¯¹ Mathlib æ€æ ·è®¤ä¸ºæ‹“æ‰‘ç©ºé—´é€šè¿‡æˆä¸ºä¸€ä¸ªæ›´å‡½å­åŒ–çš„ç†è®ºå’Œä¸ºä»»ä½•å›ºå®šç±»å‹å…·æœ‰å®Œå¤‡æ ¼ç»“æ„æ¥ä¿®å¤åº¦é‡ç©ºé—´ç†è®ºçš„ç¼ºé™·çš„è€ƒå¯Ÿã€‚
- en: 11.3.2\. Separation and countability[ïƒ](#separation-and-countability "Link to
    this heading")
  id: totrans-660
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2. åˆ†ç¦»ä¸å¯æ•°æ€§[ïƒ](#separation-and-countability "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")
- en: 'We saw that the category of topological spaces have very nice properties. The
    price to pay for this is existence of rather pathological topological spaces.
    There are a number of assumptions you can make on a topological space to ensure
    its behavior is closer to what metric spaces do. The most important is `T2Space`,
    also called â€œHausdorffâ€, that will ensure that limits are unique. A stronger separation
    property is `T3Space` that ensures in addition the RegularSpace property: each
    point has a basis of closed neighborhoods.'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çœ‹åˆ°æ‹“æ‰‘ç©ºé—´çš„èŒƒç•´å…·æœ‰éå¸¸ç¾å¥½çš„æ€§è´¨ã€‚ä¸ºæ­¤ä»˜å‡ºçš„ä»£ä»·æ˜¯å­˜åœ¨ç›¸å½“ç—…æ€çš„æ‹“æ‰‘ç©ºé—´ã€‚ä½ å¯ä»¥å¯¹æ‹“æ‰‘ç©ºé—´åšå‡ºä¸€äº›å‡è®¾ï¼Œä»¥ç¡®ä¿å…¶è¡Œä¸ºæ›´æ¥è¿‘åº¦é‡ç©ºé—´ã€‚å…¶ä¸­æœ€é‡è¦çš„æ˜¯
    `T2Space`ï¼Œä¹Ÿç§°ä¸ºâ€œè±ªæ–¯å¤šå¤«â€ï¼Œè¿™å°†ç¡®ä¿æé™æ˜¯å”¯ä¸€çš„ã€‚æ›´å¼ºçš„åˆ†ç¦»æ€§è´¨æ˜¯ `T3Space`ï¼Œå®ƒè¿˜ç¡®ä¿äº†æ­£åˆ™ç©ºé—´æ€§è´¨ï¼šæ¯ä¸ªç‚¹éƒ½æœ‰ä¸€ä¸ªé—­é‚»åŸŸåŸºã€‚
- en: '[PRE193]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Note that, in every topological space, each point has a basis of open neighborhood,
    by definition.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨æ¯ä¸€ä¸ªæ‹“æ‰‘ç©ºé—´ä¸­ï¼Œæ¯ä¸ªç‚¹éƒ½æœ‰ä¸€ä¸ªå¼€é‚»åŸŸåŸºï¼Œè¿™æ˜¯å®šä¹‰æ‰€è¦æ±‚çš„ã€‚
- en: '[PRE194]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Our main goal is now to prove the basic theorem which allows extension by continuity.
    From Bourbakiâ€™s general topology book, I.8.5, Theorem 1 (taking only the non-trivial
    implication):'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨çš„ç›®æ ‡æ˜¯è¯æ˜ä¸€ä¸ªåŸºæœ¬å®šç†ï¼Œè¯¥å®šç†å…è®¸é€šè¿‡è¿ç»­æ€§è¿›è¡Œæ‰©å±•ã€‚ä»å¸ƒå°”å·´åŸºçš„ã€Šä¸€èˆ¬æ‹“æ‰‘å­¦ã€‹ç¬¬ I å·ç¬¬ 8 ç« ï¼Œå®šç† 1ï¼ˆä»…è€ƒè™‘éå¹³å‡¡è•´å«ï¼‰ï¼š
- en: 'Let \(X\) be a topological space, \(A\) a dense subset of \(X\), \(f : A â†’
    Y\) a continuous mapping of \(A\) into a \(T_3\) space \(Y\). If, for each \(x\)
    in \(X\), \(f(y)\) tends to a limit in \(Y\) when \(y\) tends to \(x\) while remaining
    in \(A\) then there exists a continuous extension \(Ï†\) of \(f\) to \(X\).'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 'è®¾ \(X\) ä¸ºä¸€ä¸ªæ‹“æ‰‘ç©ºé—´ï¼Œ\(A\) ä¸º \(X\) çš„ä¸€ä¸ªç¨ å¯†å­é›†ï¼Œ\(f : A â†’ Y\) ä¸ºå°† \(A\) æ˜ å°„åˆ° \(T_3\) ç©ºé—´
    \(Y\) çš„è¿ç»­æ˜ å°„ã€‚å¦‚æœå¯¹äº \(X\) ä¸­çš„æ¯ä¸ª \(x\)ï¼Œå½“ \(y\) åœ¨ \(A\) ä¸­è¶‹å‘äº \(x\) æ—¶ï¼Œ\(f(y)\) åœ¨ \(Y\)
    ä¸­è¶‹å‘äºä¸€ä¸ªæé™ï¼Œé‚£ä¹ˆå­˜åœ¨ä¸€ä¸ª \(f\) åœ¨ \(X\) ä¸Šçš„è¿ç»­æ‰©å±• \(Ï†\)ã€‚'
- en: Actually Mathlib contains a more general version of the above lemma, `IsDenseInducing.continuousAt_extend`,
    but weâ€™ll stick to Bourbakiâ€™s version here.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šï¼ŒMathlib åŒ…å«äº†ä¸Šè¿°å¼•ç†çš„ä¸€ä¸ªæ›´ä¸€èˆ¬çš„ç‰ˆæœ¬ï¼Œå³ `IsDenseInducing.continuousAt_extend`ï¼Œä½†åœ¨è¿™é‡Œæˆ‘ä»¬å°†åšæŒä½¿ç”¨å¸ƒå°”å·´åŸºçš„ç‰ˆæœ¬ã€‚
- en: 'Remember that, given `A : Set X`, `â†¥A` is the subtype associated to `A`, and
    Lean will automatically insert that funny up arrow when needed. And the (inclusion)
    coercion map is `(â†‘) : A â†’ X`. The assumption â€œtends to \(x\) while remaining
    in \(A\)â€ corresponds to the pull-back filter `comap (â†‘) (ğ“ x)`.'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 'è®°ä½ï¼Œç»™å®š `A : Set X`ï¼Œ`â†¥A` æ˜¯ä¸ `A` å…³è”çš„å­ç±»å‹ï¼ŒLean å°†åœ¨éœ€è¦æ—¶è‡ªåŠ¨æ’å…¥é‚£ä¸ªå¤æ€ªçš„å‘ä¸Šç®­å¤´ã€‚å¹¶ä¸”ï¼ˆåŒ…å«ï¼‰å¼ºåˆ¶æ˜ å°„æ˜¯ `(â†‘)
    : A â†’ X`ã€‚å‡è®¾â€œåœ¨ \(A\) ä¸­è¶‹å‘äº \(x\)â€å¯¹åº”äºæ‹‰å›è¿‡æ»¤å™¨ `comap (â†‘) (ğ“ x)`ã€‚'
- en: Letâ€™s first prove an auxiliary lemma, extracted to simplify the context (in
    particular we donâ€™t need Y to be a topological space here).
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å…ˆè¯æ˜ä¸€ä¸ªè¾…åŠ©å¼•ç†ï¼Œå°†å…¶æå–å‡ºæ¥ä»¥ç®€åŒ–ä¸Šä¸‹æ–‡ï¼ˆç‰¹åˆ«æ˜¯æˆ‘ä»¬åœ¨è¿™é‡Œä¸éœ€è¦ \(Y\) æ˜¯ä¸€ä¸ªæ‹“æ‰‘ç©ºé—´ï¼‰ã€‚
- en: '[PRE195]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: Letâ€™s now turn to the main proof of the extension by continuity theorem.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬è½¬å‘è¿ç»­æ‰©å±•å®šç†çš„ä¸»è¦è¯æ˜ã€‚
- en: 'When Lean needs a topology on `â†¥A` it will automatically use the induced topology.
    The only relevant lemma is `nhds_induced (â†‘) : âˆ€ a : â†¥A, ğ“ a = comap (â†‘) (ğ“ â†‘a)`
    (this is actually a general lemma about induced topologies).'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 'å½“ Lean éœ€è¦ä¸€ä¸ª `â†¥A` ä¸Šçš„æ‹“æ‰‘æ—¶ï¼Œå®ƒå°†è‡ªåŠ¨ä½¿ç”¨è¯±å¯¼æ‹“æ‰‘ã€‚å”¯ä¸€ç›¸å…³çš„å¼•ç†æ˜¯ `nhds_induced (â†‘) : âˆ€ a : â†¥A, ğ“
    a = comap (â†‘) (ğ“ â†‘a)`ï¼ˆè¿™å®é™…ä¸Šæ˜¯ä¸€ä¸ªå…³äºè¯±å¯¼æ‹“æ‰‘çš„ä¸€èˆ¬å¼•ç†ï¼‰ã€‚'
- en: 'The proof outline is:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: è¯æ˜çš„å¤§è‡´æ€è·¯æ˜¯ï¼š
- en: The main assumption and the axiom of choice give a function `Ï†` such that `âˆ€
    x, Tendsto f (comap (â†‘) (ğ“ x)) (ğ“ (Ï† x))` (because `Y` is Hausdorff, `Ï†` is entirely
    determined, but we wonâ€™t need that until we try to prove that `Ï†` indeed extends
    `f`).
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸»è¦å‡è®¾å’Œé€‰æ‹©å…¬ç†ç»™å‡ºä¸€ä¸ªå‡½æ•° `Ï†`ï¼Œä½¿å¾— `âˆ€ x, Tendsto f (comap (â†‘) (ğ“ x)) (ğ“ (Ï† x))`ï¼ˆå› ä¸º `Y` æ˜¯è±ªæ–¯å¤šå¤«çš„ï¼Œ`Ï†`
    æ˜¯å®Œå…¨ç¡®å®šçš„ï¼Œä½†æˆ‘ä»¬ä¸ä¼šåœ¨å°è¯•è¯æ˜ `Ï†` ç¡®å®æ‰©å±• `f` ä¹‹å‰éœ€è¦è¿™ä¸€ç‚¹ï¼‰ã€‚
- en: 'Letâ€™s first prove `Ï†` is continuous. Fix any `x : X`. Since `Y` is regular,
    it suffices to check that for every *closed* neighborhood `V''` of `Ï† x`, `Ï† â»Â¹''
    V'' âˆˆ ğ“ x`. The limit assumption gives (through the auxiliary lemma above) some
    `V âˆˆ ğ“ x` such `IsOpen V âˆ§ (â†‘) â»Â¹'' V âŠ† f â»Â¹'' V''`. Since `V âˆˆ ğ“ x`, it suffices
    to prove `V âŠ† Ï† â»Â¹'' V''`, i.e. `âˆ€ y âˆˆ V, Ï† y âˆˆ V''`. Letâ€™s fix `y` in `V`. Because
    `V` is *open*, it is a neighborhood of `y`. In particular `(â†‘) â»Â¹'' V âˆˆ comap
    (â†‘) (ğ“ y)` and a fortiori `f â»Â¹'' V'' âˆˆ comap (â†‘) (ğ“ y)`. In addition `comap (â†‘)
    (ğ“ y) â‰  âŠ¥` because `A` is dense. Because we know `Tendsto f (comap (â†‘) (ğ“ y))
    (ğ“ (Ï† y))` this implies `Ï† y âˆˆ closure V''` and, since `V''` is closed, we have
    proved `Ï† y âˆˆ V''`.'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 'è®©æˆ‘ä»¬å…ˆè¯æ˜ `Ï†` æ˜¯è¿ç»­çš„ã€‚å›ºå®šä»»æ„çš„ `x : X`ã€‚ç”±äº `Y` æ˜¯æ­£åˆ™çš„ï¼Œæˆ‘ä»¬åªéœ€è¦æ£€æŸ¥å¯¹äº `Ï† x` çš„æ¯ä¸ª *é—­* é‚»åŸŸ `V''`ï¼Œ`Ï†
    â»Â¹'' V'' âˆˆ ğ“ x`ã€‚æé™å‡è®¾ç»™å‡ºäº†ï¼ˆé€šè¿‡ä¸Šé¢çš„è¾…åŠ©å¼•ç†ï¼‰ä¸€äº› `V âˆˆ ğ“ x`ï¼Œä½¿å¾— `IsOpen V âˆ§ (â†‘) â»Â¹'' V âŠ† f â»Â¹''
    V''`ã€‚ç”±äº `V âˆˆ ğ“ x`ï¼Œæˆ‘ä»¬åªéœ€è¦è¯æ˜ `V âŠ† Ï† â»Â¹'' V''`ï¼Œå³ `âˆ€ y âˆˆ V, Ï† y âˆˆ V''`ã€‚è®©æˆ‘ä»¬å›ºå®š `V` ä¸­çš„
    `y`ã€‚å› ä¸º `V` æ˜¯ *å¼€* çš„ï¼Œå®ƒæ˜¯ `y` çš„é‚»åŸŸã€‚ç‰¹åˆ«æ˜¯ `(â†‘) â»Â¹'' V âˆˆ comap (â†‘) (ğ“ y)`ï¼Œå¹¶ä¸”æ›´æ˜æ˜¾ `f â»Â¹''
    V'' âˆˆ comap (â†‘) (ğ“ y)`ã€‚æ­¤å¤–ï¼Œ`comap (â†‘) (ğ“ y) â‰  âŠ¥` å› ä¸º `A` æ˜¯ç¨ å¯†çš„ã€‚å› ä¸ºæˆ‘ä»¬çŸ¥é“ `Tendsto f
    (comap (â†‘) (ğ“ y)) (ğ“ (Ï† y))`ï¼Œè¿™è¡¨æ˜ `Ï† y âˆˆ closure V''`ï¼Œå¹¶ä¸”ç”±äº `V''` æ˜¯é—­çš„ï¼Œæˆ‘ä»¬è¯æ˜äº† `Ï† y
    âˆˆ V''`ã€‚'
- en: It remains to prove that `Ï†` extends `f`. This is where the continuity of `f`
    enters the discussion, together with the fact that `Y` is Hausdorff.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: å‰©ä¸‹çš„å·¥ä½œæ˜¯è¯æ˜ `Ï†` æ‰©å±•äº† `f`ã€‚è¿™æ˜¯ `f` çš„è¿ç»­æ€§è¿›å…¥è®¨è®ºçš„åœ°æ–¹ï¼Œä»¥åŠ `Y` æ˜¯è±ªæ–¯å¤šå¤«ç©ºé—´çš„äº‹å®ã€‚
- en: '[PRE196]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: In addition to separation property, the main kind of assumption you can make
    on a topological space to bring it closer to metric spaces is countability assumption.
    The main one is first countability asking that every point has a countable neighborhood
    basis. In particular this ensures that closure of sets can be understood using
    sequences.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: é™¤äº†åˆ†ç¦»æ€§è´¨å¤–ï¼Œä½ å¯ä»¥åœ¨æ‹“æ‰‘ç©ºé—´ä¸Šåšå‡ºçš„ä¸»è¦å‡è®¾ï¼Œä»¥ä½¿å…¶æ›´æ¥è¿‘åº¦é‡ç©ºé—´ï¼Œæ˜¯å¯æ•°æ€§å‡è®¾ã€‚ä¸»è¦çš„ä¸€ä¸ªæ˜¯ç¬¬ä¸€å¯æ•°æ€§ï¼Œè¦æ±‚æ¯ä¸ªç‚¹éƒ½æœ‰ä¸€ä¸ªå¯æ•°çš„é‚»åŸŸåŸºã€‚ç‰¹åˆ«æ˜¯è¿™ç¡®ä¿äº†é›†åˆçš„é—­åŒ…å¯ä»¥ç”¨åºåˆ—æ¥ç†è§£ã€‚
- en: '[PRE197]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 11.3.3\. Compactness[ïƒ](#id5 "Link to this heading")
  id: totrans-680
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.3\. ç´§è‡´æ€§[ïƒ](#id5 "é“¾æ¥åˆ°æœ¬æ ‡é¢˜")
- en: Let us now discuss how compactness is defined for topological spaces. As usual
    there are several ways to think about it and Mathlib goes for the filter version.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ç°åœ¨è®¨è®ºæ‹“æ‰‘ç©ºé—´ä¸­ç´§è‡´æ€§çš„å®šä¹‰ã€‚é€šå¸¸æœ‰å‡ ç§æ€è€ƒæ–¹å¼ï¼ŒMathlib é‡‡ç”¨çš„æ˜¯è¿‡æ»¤å™¨ç‰ˆæœ¬ã€‚
- en: 'We first need to define cluster points of filters. Given a filter `F` on a
    topological space `X`, a point `x : X` is a cluster point of `F` if `F`, seen
    as a generalized set, has non-empty intersection with the generalized set of points
    that are close to `x`.'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 'æˆ‘ä»¬é¦–å…ˆéœ€è¦å®šä¹‰è¿‡æ»¤å™¨çš„èšç‚¹ã€‚ç»™å®šä¸€ä¸ªæ‹“æ‰‘ç©ºé—´ `X` ä¸Šçš„è¿‡æ»¤å™¨ `F`ï¼Œä¸€ä¸ªç‚¹ `x : X` æ˜¯ `F` çš„èšç‚¹ï¼Œå¦‚æœ `F` ä½œä¸ºå¹¿ä¹‰é›†åˆï¼Œä¸æ¥è¿‘
    `x` çš„ç‚¹çš„å¹¿ä¹‰é›†åˆæœ‰éç©ºäº¤é›†ã€‚'
- en: Then we can say that a set `s` is compact if every nonempty generalized set
    `F` contained in `s`, i.e. such that `F â‰¤ ğ“Ÿ s`, has a cluster point in `s`.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥è¯´ä¸€ä¸ªé›†åˆ `s` æ˜¯ç´§è‡´çš„ï¼Œå¦‚æœæ¯ä¸ªåŒ…å«åœ¨ `s` ä¸­çš„éç©ºå¹¿ä¹‰é›†åˆ `F`ï¼Œå³ `F â‰¤ ğ“Ÿ s`ï¼Œåœ¨ `s` ä¸­éƒ½æœ‰ä¸€ä¸ªèšç‚¹ã€‚
- en: '[PRE198]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'For instance if `F` is `map u atTop`, the image under `u : â„• â†’ X` of `atTop`,
    the generalized set of very large natural numbers, then the assumption `F â‰¤ ğ“Ÿ
    s` means that `u n` belongs to `s` for `n` large enough. Saying that `x` is a
    cluster point of `map u atTop` says the image of very large numbers intersects
    the set of points that are close to `x`. In case `ğ“ x` has a countable basis,
    we can interpret this as saying that `u` has a subsequence converging to `x`,
    and we get back what compactness looks like in metric spaces.'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¾‹å¦‚ï¼Œå¦‚æœ `F` æ˜¯ `map u atTop`ï¼Œå³ `u : â„• â†’ X` åœ¨ `atTop`ï¼ˆä¸€ä¸ªéå¸¸å¤§çš„è‡ªç„¶æ•°çš„å¹¿ä¹‰é›†åˆï¼‰ä¸‹çš„åƒï¼Œé‚£ä¹ˆå‡è®¾ `F
    â‰¤ ğ“Ÿ s` æ„å‘³ç€å¯¹äºè¶³å¤Ÿå¤§çš„ `n`ï¼Œ`u n` å±äº `s`ã€‚è¯´ `x` æ˜¯ `map u atTop` çš„èšç‚¹æ„å‘³ç€éå¸¸å¤§çš„æ•°çš„åƒä¸æ¥è¿‘ `x` çš„ç‚¹çš„é›†åˆç›¸äº¤ã€‚å¦‚æœ
    `ğ“ x` æœ‰ä¸€ä¸ªå¯æ•°åŸºï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶è§£é‡Šä¸º `u` æœ‰ä¸€ä¸ªæ”¶æ•›åˆ° `x` çš„å­åºåˆ—ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¾—åˆ°äº†åº¦é‡ç©ºé—´ä¸­ç´§è‡´æ€§çš„æ ·å­ã€‚'
- en: '[PRE199]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Cluster points behave nicely with continuous functions.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: èšç‚¹ä¸è¿ç»­å‡½æ•°çš„è¡Œä¸ºè‰¯å¥½ã€‚
- en: '[PRE200]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: As an exercise, we will prove that the image of a compact set under a continuous
    map is compact. In addition to what we saw already, you should use `Filter.push_pull`
    and `NeBot.of_map`.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºç»ƒä¹ ï¼Œæˆ‘ä»¬å°†è¯æ˜ç´§è‡´é›†åˆåœ¨è¿ç»­æ˜ å°„ä¸‹çš„åƒæ˜¯ç´§è‡´çš„ã€‚é™¤äº†æˆ‘ä»¬å·²ç»çœ‹åˆ°çš„å†…å®¹å¤–ï¼Œä½ è¿˜åº”è¯¥ä½¿ç”¨ `Filter.push_pull` å’Œ `NeBot.of_map`ã€‚
- en: '[PRE201]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'One can also express compactness in terms of open covers: `s` is compact if
    every family of open sets that cover `s` has a finite covering sub-family.'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹Ÿå¯ä»¥ç”¨å¼€è¦†ç›–æ¥è¡¨ç¤ºç´§è‡´æ€§ï¼šå¦‚æœ `s` æ˜¯ç´§è‡´çš„ï¼Œé‚£ä¹ˆè¦†ç›– `s` çš„æ¯ä¸ªå¼€é›†æ—éƒ½æœ‰ä¸€ä¸ªæœ‰é™è¦†ç›–å­æ—ã€‚
- en: '[PRE202]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 11.3.1\. Fundamentals[ïƒ](#fundamentals "Link to this heading")
  id: totrans-693
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1\. åŸºç¡€[ïƒ](#fundamentals "é“¾æ¥åˆ°æœ¬æ ‡é¢˜")
- en: We now go up in generality and introduce topological spaces. We will review
    the two main ways to define topological spaces and then explain how the category
    of topological spaces is much better behaved than the category of metric spaces.
    Note that we wonâ€™t be using Mathlib category theory here, only having a somewhat
    categorical point of view.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æé«˜ä¸€èˆ¬æ€§ï¼Œå¼•å…¥æ‹“æ‰‘ç©ºé—´ã€‚æˆ‘ä»¬å°†å›é¡¾å®šä¹‰æ‹“æ‰‘ç©ºé—´çš„ä¸¤ç§ä¸»è¦æ–¹æ³•ï¼Œç„¶åè§£é‡Šæ‹“æ‰‘ç©ºé—´èŒƒç•´æ¯”åº¦é‡ç©ºé—´èŒƒç•´è¡¨ç°å¾—æ›´å¥½ã€‚æ³¨æ„ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œä¸ä¼šä½¿ç”¨MathlibèŒƒç•´è®ºï¼Œè€Œåªæ˜¯æœ‰ä¸€ä¸ªæŸç§èŒƒç•´çš„è§‚ç‚¹ã€‚
- en: The first way to think about the transition from metric spaces to topological
    spaces is that we only remember the notion of open sets (or equivalently the notion
    of closed sets). From this point of view, a topological space is a type equipped
    with a collection of sets that are called open sets. This collection has to satisfy
    a number of axioms presented below (this collection is slightly redundant but
    we will ignore that).
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: æ€è€ƒä»åº¦é‡ç©ºé—´åˆ°æ‹“æ‰‘ç©ºé—´è¿‡æ¸¡çš„ç¬¬ä¸€ç§æ–¹æ³•æ˜¯ï¼Œæˆ‘ä»¬åªä¿ç•™äº†å¼€é›†çš„æ¦‚å¿µï¼ˆæˆ–ç­‰ä»·åœ°ï¼Œé—­é›†çš„æ¦‚å¿µï¼‰ã€‚ä»è¿™ç§è§‚ç‚¹æ¥çœ‹ï¼Œæ‹“æ‰‘ç©ºé—´æ˜¯ä¸€ä¸ªç±»å‹ï¼Œå®ƒé…å¤‡äº†ä¸€ä¸ªç§°ä¸ºå¼€é›†çš„é›†åˆã€‚è¿™ä¸ªé›†åˆå¿…é¡»æ»¡è¶³ä»¥ä¸‹åˆ—å‡ºçš„è‹¥å¹²å…¬ç†ï¼ˆè¿™ä¸ªé›†åˆç•¥å¾®å†—ä½™ï¼Œä½†æˆ‘ä»¬å°†å¿½ç•¥è¿™ä¸€ç‚¹ï¼‰ã€‚
- en: '[PRE203]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Closed sets are then defined as sets whose complement is open. A function between
    topological spaces is (globally) continuous if all preimages of open sets are
    open.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: é—­é›†å®šä¹‰ä¸ºè¡¥é›†æ˜¯å¼€é›†çš„é›†åˆã€‚åœ¨æ‹“æ‰‘ç©ºé—´ä¹‹é—´çš„å‡½æ•°ï¼ˆå…¨å±€ï¼‰è¿ç»­ï¼Œå¦‚æœæ‰€æœ‰å¼€é›†çš„å‰åƒéƒ½æ˜¯å¼€é›†ã€‚
- en: '[PRE204]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'With this definition we already see that, compared to metric spaces, topological
    spaces only remember enough information to talk about continuous functions: two
    topological structures on a type are the same if and only if they have the same
    continuous functions (indeed the identity function will be continuous in both
    direction if and only if the two structures have the same open sets).'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡è¿™ä¸ªå®šä¹‰ï¼Œæˆ‘ä»¬å·²çœ‹åˆ°ï¼Œä¸åº¦é‡ç©ºé—´ç›¸æ¯”ï¼Œæ‹“æ‰‘ç©ºé—´åªä¿ç•™äº†è¶³å¤Ÿçš„ä¿¡æ¯æ¥è®¨è®ºè¿ç»­å‡½æ•°ï¼šä¸€ä¸ªç±»å‹ä¸Šçš„ä¸¤ä¸ªæ‹“æ‰‘ç»“æ„ç›¸åŒï¼Œå½“ä¸”ä»…å½“å®ƒä»¬å…·æœ‰ç›¸åŒçš„è¿ç»­å‡½æ•°ï¼ˆå®é™…ä¸Šï¼Œå¦‚æœä¸¤ä¸ªç»“æ„å…·æœ‰ç›¸åŒçš„å¼€é›†ï¼Œé‚£ä¹ˆæ’ç­‰å‡½æ•°åœ¨è¿™ä¸¤ä¸ªæ–¹å‘ä¸Šå°†æ˜¯è¿ç»­çš„ï¼‰ã€‚
- en: 'However as soon as we move on to continuity at a point we see the limitations
    of the approach based on open sets. In Mathlib we frequently think of topological
    spaces as types equipped with a neighborhood filter `ğ“ x` attached to each point
    `x` (the corresponding function `X â†’ Filter X` satisfies certain conditions explained
    further down). Remember from the filters section that these gadgets play two related
    roles. First `ğ“ x` is seen as the generalized set of points of `X` that are close
    to `x`. And then it is seen as giving a way to say, for any predicate `P : X â†’
    Prop`, that this predicate holds for points that are close enough to `x`. Let
    us state that `f : X â†’ Y` is continuous at `x`. The purely filtery way is to say
    that the direct image under `f` of the generalized set of points that are close
    to `x` is contained in the generalized set of points that are close to `f x`.
    Recall this is spelled either `map f (ğ“ x) â‰¤ ğ“ (f x)` or `Tendsto f (ğ“ x) (ğ“ (f
    x))`.'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç„¶è€Œï¼Œå½“æˆ‘ä»¬è½¬å‘ç‚¹çš„è¿ç»­æ€§æ—¶ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†åŸºäºå¼€é›†çš„æ–¹æ³•çš„å±€é™æ€§ã€‚åœ¨Mathlibä¸­ï¼Œæˆ‘ä»¬ç»å¸¸å°†æ‹“æ‰‘ç©ºé—´è§†ä¸ºæ¯ä¸ªç‚¹`x`éƒ½é™„æœ‰ä¸€ä¸ªé‚»åŸŸæ»¤æ³¢å™¨`ğ“ x`çš„ç±»å‹ï¼ˆç›¸åº”çš„å‡½æ•°`X
    â†’ Filter X`æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼Œå°†åœ¨ä¸‹é¢è¿›ä¸€æ­¥è§£é‡Šï¼‰ã€‚è®°ä½ä»æ»¤æ³¢å™¨éƒ¨åˆ†ï¼Œè¿™äº›å°ç©æ„å„¿æ‰®æ¼”ä¸¤ä¸ªç›¸å…³çš„è§’è‰²ã€‚é¦–å…ˆï¼Œ`ğ“ x`è¢«è§†ä¸º`X`ä¸­é è¿‘`x`çš„ç‚¹çš„å¹¿ä¹‰é›†åˆã€‚ç„¶åï¼Œå®ƒè¢«è§†ä¸ºä¸ºä»»ä½•è°“è¯`P
    : X â†’ Prop`æä¾›ä¸€ç§æ–¹å¼ï¼Œå³è¿™ä¸ªè°“è¯å¯¹è¶³å¤Ÿé è¿‘`x`çš„ç‚¹æˆç«‹ã€‚è®©æˆ‘ä»¬å£°æ˜`f : X â†’ Y`åœ¨`x`å¤„æ˜¯è¿ç»­çš„ã€‚çº¯ç²¹åŸºäºæ»¤æ³¢å™¨çš„æ–¹å¼æ˜¯è¯´ï¼Œ`f`çš„ç›´æ¥åƒåŒ…å«é è¿‘`x`çš„ç‚¹çš„å¹¿ä¹‰é›†åˆåŒ…å«åœ¨é è¿‘`f
    x`çš„ç‚¹çš„å¹¿ä¹‰é›†åˆä¸­ã€‚å›æƒ³ä¸€ä¸‹ï¼Œè¿™å¯ä»¥è¡¨ç¤ºä¸º`map f (ğ“ x) â‰¤ ğ“ (f x)`æˆ–`Tendsto f (ğ“ x) (ğ“ (f x))`ã€‚'
- en: '[PRE205]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'One can also spell it using both neighborhoods seen as ordinary sets and a
    neighborhood filter seen as a generalized set: â€œfor any neighborhood `U` of `f
    x`, all points close to `x` are sent to `U`â€. Note that the proof is again `Iff.rfl`,
    this point of view is definitionally equivalent to the previous one.'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹Ÿå¯ä»¥ä½¿ç”¨ä¸¤ç§é‚»åŸŸï¼ˆè§†ä¸ºæ™®é€šé›†åˆï¼‰å’Œé‚»åŸŸæ»¤æ³¢å™¨ï¼ˆè§†ä¸ºå¹¿ä¹‰é›†åˆï¼‰æ¥è¡¨è¿°ï¼šâ€œå¯¹äº`f x`çš„ä»»ä½•é‚»åŸŸ`U`ï¼Œæ‰€æœ‰é è¿‘`x`çš„ç‚¹éƒ½è¢«å‘é€åˆ°`U`â€ã€‚è¯·æ³¨æ„ï¼Œè¯æ˜ä»ç„¶æ˜¯`Iff.rfl`ï¼Œè¿™ä¸ªè§‚ç‚¹åœ¨å®šä¹‰ä¸Šæ˜¯ç­‰ä»·äºå‰ä¸€ä¸ªçš„ã€‚
- en: '[PRE206]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: We now explain how to go from one point of view to the other. In terms of open
    sets, we can simply define members of `ğ“ x` as sets that contain an open set containing
    `x`.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬è§£é‡Šå¦‚ä½•ä»ä¸€ä¸ªè§‚ç‚¹è½¬åˆ°å¦ä¸€ä¸ªè§‚ç‚¹ã€‚ä»å¼€é›†çš„è§’åº¦æ¥çœ‹ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•åœ°å®šä¹‰`ğ“ x`çš„æˆå‘˜ä¸ºåŒ…å«`x`çš„å¼€é›†çš„é›†åˆã€‚
- en: '[PRE207]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'To go in the other direction we need to discuss the condition that `ğ“ : X â†’
    Filter X` must satisfy in order to be the neighborhood function of a topology.'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 'è¦æœç›¸åçš„æ–¹å‘å‰è¿›ï¼Œæˆ‘ä»¬éœ€è¦è®¨è®º`ğ“ : X â†’ Filter X`å¿…é¡»æ»¡è¶³çš„æ¡ä»¶ï¼Œä»¥ä¾¿æˆä¸ºæ‹“æ‰‘çš„é‚»åŸŸå‡½æ•°ã€‚'
- en: The first constraint is that `ğ“ x`, seen as a generalized set, contains the
    set `{x}` seen as the generalized set `pure x` (explaining this weird name would
    be too much of a digression, so we simply accept it for now). Another way to say
    it is that if a predicate holds for points close to `x` then it holds at `x`.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ä¸ªçº¦æŸæ˜¯ï¼Œ`ğ“ x`ï¼ˆä½œä¸ºä¸€ä¸ªå¹¿ä¹‰é›†åˆï¼‰åŒ…å«é›†åˆ `{x}`ï¼ˆä½œä¸ºä¸€ä¸ªå¹¿ä¹‰é›†åˆ `pure x`ï¼‰ï¼Œå¦ä¸€ç§è¯´æ³•æ˜¯ï¼Œå¦‚æœä¸€ä¸ªè°“è¯å¯¹äºæ¥è¿‘ `x` çš„ç‚¹æˆç«‹ï¼Œé‚£ä¹ˆå®ƒåœ¨
    `x` ä¸Šä¹Ÿæˆç«‹ã€‚
- en: '[PRE208]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'Then a more subtle requirement is that, for any predicate `P : X â†’ Prop` and
    any `x`, if `P y` holds for `y` close to `x` then for `y` close to `x` and `z`
    close to `y`, `P z` holds. More precisely we have:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç„¶åä¸€ä¸ªæ›´å¾®å¦™çš„è¦æ±‚æ˜¯ï¼Œå¯¹äºä»»ä½•è°“è¯ `P : X â†’ Prop` å’Œä»»ä½• `x`ï¼Œå¦‚æœ `P y` å¯¹äºæ¥è¿‘ `x` çš„ `y` æˆç«‹ï¼Œé‚£ä¹ˆå¯¹äºæ¥è¿‘
    `x` å’Œ `y` çš„ `z`ï¼Œ`P z` ä¹Ÿæˆç«‹ã€‚æ›´ç²¾ç¡®åœ°è¯´ï¼Œæˆ‘ä»¬æœ‰ï¼š'
- en: '[PRE209]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'Those two results characterize the functions `X â†’ Filter X` that are neighborhood
    functions for a topological space structure on `X`. There is a still a function
    `TopologicalSpace.mkOfNhds : (X â†’ Filter X) â†’ TopologicalSpace X` but it will
    give back its input as a neighborhood function only if it satisfies the above
    two constraints. More precisely we have a lemma `TopologicalSpace.nhds_mkOfNhds`
    saying that in a different way and our next exercise deduces this different way
    from how we stated it above.'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 'è¿™ä¸¤ä¸ªç»“æœæè¿°äº† `X â†’ Filter X` çš„å‡½æ•°ï¼Œè¿™äº›å‡½æ•°æ˜¯ `X` ä¸Šçš„æ‹“æ‰‘ç©ºé—´ç»“æ„çš„é‚»åŸŸå‡½æ•°ã€‚ä»ç„¶æœ‰ä¸€ä¸ªå‡½æ•° `TopologicalSpace.mkOfNhds
    : (X â†’ Filter X) â†’ TopologicalSpace X`ï¼Œä½†å®ƒåªä¼šå°†å…¶è¾“å…¥ä½œä¸ºé‚»åŸŸå‡½æ•°è¿”å›ï¼Œå¦‚æœå®ƒæ»¡è¶³ä¸Šè¿°ä¸¤ä¸ªçº¦æŸã€‚æ›´ç²¾ç¡®åœ°è¯´ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªå¼•ç†
    `TopologicalSpace.nhds_mkOfNhds`ï¼Œå®ƒä»¥ä¸åŒçš„æ–¹å¼è¡¨è¾¾ï¼Œæˆ‘ä»¬çš„ä¸‹ä¸€ä¸ªç»ƒä¹ å°†ä»æˆ‘ä»¬ä¸Šè¿°çš„æ–¹å¼æ¨å¯¼å‡ºè¿™ä¸€ç‚¹ã€‚'
- en: '[PRE210]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: Note that `TopologicalSpace.mkOfNhds` is not so frequently used, but it still
    good to know in what precise sense the neighborhood filters is all there is in
    a topological space structure.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œ`TopologicalSpace.mkOfNhds` å¹¶ä¸ç»å¸¸ä½¿ç”¨ï¼Œä½†äº†è§£å®ƒåœ¨æ‹“æ‰‘ç©ºé—´ç»“æ„ä¸­ç²¾ç¡®æ„ä¹‰ä¸Šæ„å‘³ç€ä»€ä¹ˆä»ç„¶æ˜¯æœ‰ç›Šçš„ã€‚
- en: 'The next thing to know in order to efficiently use topological spaces in Mathlib
    is that we use a lot of formal properties of `TopologicalSpace : Type u â†’ Type
    u`. From a purely mathematical point of view, those formal properties are a very
    clean way to explain how topological spaces solve issues that metric spaces have.
    From this point of view, the issues solved by topological spaces is that metric
    spaces enjoy very little functoriality, and have very bad categorical properties
    in general. This comes on top of the fact already discussed that metric spaces
    contain a lot of geometrical information that is not topologically relevant.'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¸ºäº†æœ‰æ•ˆåœ°åœ¨ Mathlib ä¸­ä½¿ç”¨æ‹“æ‰‘ç©ºé—´ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“çš„æ˜¯ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†å¤§é‡çš„ `TopologicalSpace : Type u â†’ Type
    u` çš„å½¢å¼æ€§è´¨ã€‚ä»çº¯ç²¹æ•°å­¦çš„è§’åº¦æ¥çœ‹ï¼Œè¿™äº›å½¢å¼æ€§è´¨æ˜¯è§£é‡Šæ‹“æ‰‘ç©ºé—´å¦‚ä½•è§£å†³åº¦é‡ç©ºé—´å­˜åœ¨çš„é—®é¢˜çš„ä¸€ç§éå¸¸å¹²å‡€çš„æ–¹å¼ã€‚ä»è¿™ä¸ªè§’åº¦æ¥çœ‹ï¼Œæ‹“æ‰‘ç©ºé—´è§£å†³çš„é—®é¢˜åœ¨äºåº¦é‡ç©ºé—´å‡ ä¹ä¸å…·æœ‰å‡½å­æ€§ï¼Œå¹¶ä¸”åœ¨ä¸€èˆ¬ä¸Šå…·æœ‰å¾ˆå·®çš„èŒƒç•´æ€§è´¨ã€‚è¿™è¿˜åŸºäºå·²ç»è®¨è®ºçš„äº‹å®ï¼Œå³åº¦é‡ç©ºé—´åŒ…å«å¤§é‡ä¸æ‹“æ‰‘æ— å…³çš„å‡ ä½•ä¿¡æ¯ã€‚'
- en: Let us focus on functoriality first. A metric space structure can be induced
    on a subset or, equivalently, it can be pulled back by an injective map. But thatâ€™s
    pretty much everything. They cannot be pulled back by general map or pushed forward,
    even by surjective maps.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å…ˆå…³æ³¨å‡½å­æ€§ã€‚åº¦é‡ç©ºé—´ç»“æ„å¯ä»¥è¯±å¯¼åœ¨å­é›†ä¸Šï¼Œæˆ–è€…ç­‰ä»·åœ°ï¼Œå¯ä»¥é€šè¿‡ä¸€ä¸ªæ³¨å…¥æ˜ å°„å°†å…¶æ‹‰å›ã€‚ä½†è¿™å‡ ä¹å°±æ˜¯å…¨éƒ¨äº†ã€‚å®ƒä»¬ä¸èƒ½é€šè¿‡ä¸€èˆ¬æ˜ å°„æˆ–é€šè¿‡å…¨å°„æ˜ å°„æ¨å‰ã€‚
- en: 'In particular there is no sensible distance to put on a quotient of a metric
    space or on an uncountable product of metric spaces. Consider for instance the
    type `â„ â†’ â„`, seen as a product of copies of `â„` indexed by `â„`. We would like
    to say that pointwise convergence of sequences of functions is a respectable notion
    of convergence. But there is no distance on `â„ â†’ â„` that gives this notion of
    convergence. Relatedly, there is no distance ensuring that a map `f : X â†’ (â„ â†’
    â„)` is continuous if and only if `fun x â†¦ f x t` is continuous for every `t :
    â„`.'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 'å°¤å…¶æ˜¯åœ¨åº¦é‡ç©ºé—´çš„å•†æˆ–ä¸å¯æ•°åº¦é‡ç©ºé—´çš„ç§¯ä¸Šï¼Œæ²¡æœ‰åˆç†çš„è·ç¦»å¯ä»¥æ”¾ç½®ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘ç±»å‹ `â„ â†’ â„`ï¼Œå®ƒè¢«è§†ä¸ºç”± `â„` çš„å‰¯æœ¬ç»„æˆçš„ç§¯ï¼Œè¿™äº›å‰¯æœ¬ç”± `â„`
    ç´¢å¼•ã€‚æˆ‘ä»¬å¸Œæœ›è¯´å‡½æ•°åºåˆ—é€ç‚¹æ”¶æ•›æ˜¯ä¸€ä¸ªå€¼å¾—å°Šé‡çš„æ”¶æ•›æ¦‚å¿µã€‚ä½†åœ¨ `â„ â†’ â„` ä¸Šæ²¡æœ‰è·ç¦»å¯ä»¥ç»™å‡ºè¿™ç§æ”¶æ•›æ¦‚å¿µã€‚ç›¸å…³åœ°ï¼Œæ²¡æœ‰è·ç¦»å¯ä»¥ä¿è¯æ˜ å°„ `f : X
    â†’ (â„ â†’ â„)` è¿ç»­å½“ä¸”ä»…å½“å¯¹äºæ¯ä¸ª `t : â„`ï¼Œå‡½æ•° `fun x â†¦ f x t` æ˜¯è¿ç»­çš„ã€‚'
- en: 'We now review the data used to solve all those issues. First we can use any
    map `f : X â†’ Y` to push or pull topologies from one side to the other. Those two
    operations form a Galois connection.'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç°åœ¨æˆ‘ä»¬å›é¡¾ä¸€ä¸‹è§£å†³æ‰€æœ‰è¿™äº›é—®é¢˜çš„æ•°æ®ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»»ä½•æ˜ å°„ `f : X â†’ Y` å°†æ‹“æ‰‘ä»ä¸€ä¸ªæ–¹é¢æ¨åˆ°å¦ä¸€ä¸ªæ–¹é¢ã€‚è¿™ä¸¤ä¸ªæ“ä½œå½¢æˆä¸€ä¸ªé«˜å¢è”ç³»ã€‚'
- en: '[PRE211]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Those operations are compatible with composition of functions. As usual, pushing
    forward is covariant and pulling back is contravariant, see `coinduced_compose`
    and `induced_compose`. On paper we will use notations \(f_*T\) for `TopologicalSpace.coinduced
    f T` and \(f^*T\) for `TopologicalSpace.induced f T`.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æ“ä½œä¸å‡½æ•°çš„å¤åˆæ˜¯å…¼å®¹çš„ã€‚åƒå¾€å¸¸ä¸€æ ·ï¼Œæ¨å‰æ˜¯åå˜çš„ï¼Œæ‹‰å›æ˜¯åå¯¹ç§°çš„ï¼Œå‚è§`coinduced_compose`å’Œ`induced_compose`ã€‚åœ¨çº¸ä¸Šæˆ‘ä»¬å°†ä½¿ç”¨ç¬¦å·\(f_*T\)è¡¨ç¤º`TopologicalSpace.coinduced
    f T`å’Œ\(f^*T\)è¡¨ç¤º`TopologicalSpace.induced f T`ã€‚
- en: 'Then the next big piece is a complete lattice structure on `TopologicalSpace
    X` for any given structure. If you think of topologies as being primarily the
    data of open sets then you expect the order relation on `TopologicalSpace X` to
    come from `Set (Set X)`, i.e. you expect `t â‰¤ t''` if a set `u` is open for `t''`
    as soon as it is open for `t`. However we already know that Mathlib focuses on
    neighborhoods more than open sets so, for any `x : X` we want the map from topological
    spaces to neighborhoods `fun T : TopologicalSpace X â†¦ @nhds X T x` to be order
    preserving. And we know the order relation on `Filter X` is designed to ensure
    an order preserving `principal : Set X â†’ Filter X`, allowing to see filters as
    generalized sets. So the order relation we do use on `TopologicalSpace X` is opposite
    to the one coming from `Set (Set X)`.'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç„¶åä¸‹ä¸€ä¸ªé‡è¦éƒ¨åˆ†æ˜¯å¯¹äºä»»ä½•ç»™å®šçš„ç»“æ„åœ¨`TopologicalSpace X`ä¸Šçš„å®Œå¤‡æ ¼ç»“æ„ã€‚å¦‚æœä½ è®¤ä¸ºæ‹“æ‰‘ä¸»è¦æ˜¯å¼€é›†çš„æ•°æ®ï¼Œé‚£ä¹ˆä½ æœŸæœ›`TopologicalSpace
    X`ä¸Šçš„åºå…³ç³»æ¥è‡ª`Set (Set X)`ï¼Œå³ä½ æœŸæœ›å¦‚æœé›†åˆ`u`å¯¹äº`t''`æ˜¯å¼€é›†ï¼Œé‚£ä¹ˆå®ƒå¯¹äº`t`ä¹Ÿæ˜¯å¼€é›†ï¼Œé‚£ä¹ˆ`t â‰¤ t''`ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å·²ç»çŸ¥é“Mathlibæ›´å…³æ³¨é‚»åŸŸè€Œä¸æ˜¯å¼€é›†ï¼Œæ‰€ä»¥å¯¹äºä»»ä½•`x
    : X`ï¼Œæˆ‘ä»¬å¸Œæœ›ä»æ‹“æ‰‘ç©ºé—´åˆ°é‚»åŸŸçš„æ˜ å°„`fun T : TopologicalSpace X â†¦ @nhds X T x`æ˜¯åºä¿æŒçš„ã€‚æˆ‘ä»¬çŸ¥é“`Filter
    X`ä¸Šçš„åºå…³ç³»æ˜¯ä¸ºäº†ç¡®ä¿åºä¿æŒçš„`principal : Set X â†’ Filter X`ï¼Œå…è®¸å°†è¿‡æ»¤å™¨è§†ä¸ºå¹¿ä¹‰é›†åˆã€‚æ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨çš„`TopologicalSpace
    X`ä¸Šçš„åºå…³ç³»ä¸æ¥è‡ª`Set (Set X)`çš„åºå…³ç³»ç›¸åã€‚'
- en: '[PRE212]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: Now we can recover continuity by combining the push-forward (or pull-back) operation
    with the order relation.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¯ä»¥é€šè¿‡ç»“åˆæ¨å‰ï¼ˆæˆ–æ‹‰å›ï¼‰æ“ä½œä¸åºå…³ç³»æ¥æ¢å¤è¿ç»­æ€§ã€‚
- en: '[PRE213]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'With this definition and the compatibility of push-forward and composition,
    we get for free the universal property that, for any topological space \(Z\),
    a function \(g : Y â†’ Z\) is continuous for the topology \(f_*T_X\) if and only
    if \(g âˆ˜ f\) is continuous.'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 'é€šè¿‡è¿™ä¸ªå®šä¹‰å’Œæ¨å‰ä¸å¤åˆçš„å…¼å®¹æ€§ï¼Œæˆ‘ä»¬å…è´¹è·å¾—äº†ä¸€ä¸ªæ™®éæ€§è´¨ï¼Œå³å¯¹äºä»»ä½•æ‹“æ‰‘ç©ºé—´\(Z\)ï¼Œå¦‚æœå‡½æ•°\(g : Y â†’ Z\)åœ¨æ‹“æ‰‘\(f_*T_X\)ä¸Šæ˜¯è¿ç»­çš„ï¼Œå½“ä¸”ä»…å½“\(g
    âˆ˜ f\)æ˜¯è¿ç»­çš„ã€‚'
- en: \[\begin{split}g \text{ continuous } &â‡” g_*(f_*T_X) â‰¤ T_Z \\ &â‡” (g âˆ˜ f)_* T_X
    â‰¤ T_Z \\ &â‡” g âˆ˜ f \text{ continuous}\end{split}\]
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}g \text{ è¿ç»­ } &â‡” g_*(f_*T_X) â‰¤ T_Z \\ &â‡” (g âˆ˜ f)_* T_X â‰¤ T_Z
    \\ &â‡” g âˆ˜ f \text{ è¿ç»­}\end{split}\]
- en: '[PRE214]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'So we already get quotient topologies (using the projection map as `f`). This
    wasnâ€™t using that `TopologicalSpace X` is a complete lattice for all `X`. Letâ€™s
    now see how all this structure proves the existence of the product topology by
    abstract non-sense. We considered the case of `â„ â†’ â„` above, but letâ€™s now consider
    the general case of `Î  i, X i` for some `Î¹ : Type*` and `X : Î¹ â†’ Type*`. We want,
    for any topological space `Z` and any function `f : Z â†’ Î  i, X i`, that `f` is
    continuous if and only if `(fun x â†¦ x i) âˆ˜ f` is continuous for all `i`. Let us
    explore that constraint â€œon paperâ€ using notation \(p_i\) for the projection `(fun
    (x : Î  i, X i) â†¦ x i)`:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 'å› æ­¤ï¼Œæˆ‘ä»¬å·²å¾—åˆ°å•†æ‹“æ‰‘ï¼ˆä½¿ç”¨æŠ•å½±æ˜ å°„ä½œä¸º`f`ï¼‰ã€‚è¿™å¹¶ä¸æ˜¯ä½¿ç”¨`TopologicalSpace X`å¯¹æ‰€æœ‰`X`éƒ½æ˜¯å®Œå¤‡æ ¼çš„äº‹å®ã€‚ç°åœ¨è®©æˆ‘ä»¬çœ‹çœ‹æ‰€æœ‰è¿™äº›ç»“æ„å¦‚ä½•é€šè¿‡æŠ½è±¡çš„èƒ¡è¨€ä¹±è¯­è¯æ˜ä¹˜ç§¯æ‹“æ‰‘çš„å­˜åœ¨ã€‚æˆ‘ä»¬ä¸Šé¢è€ƒè™‘äº†`â„
    â†’ â„`çš„æƒ…å†µï¼Œä½†ç°åœ¨è®©æˆ‘ä»¬è€ƒè™‘ä¸€èˆ¬æƒ…å†µ`Î  i, X i`å¯¹äºæŸäº›`Î¹ : Type*`å’Œ`X : Î¹ â†’ Type*`ã€‚æˆ‘ä»¬å¸Œæœ›å¯¹äºä»»ä½•æ‹“æ‰‘ç©ºé—´`Z`å’Œä»»ä½•å‡½æ•°`f
    : Z â†’ Î  i, X i`ï¼Œå¦‚æœ`f`æ˜¯è¿ç»­çš„ï¼Œå½“ä¸”ä»…å½“å¯¹äºæ‰€æœ‰`i`ï¼Œ`(fun x â†¦ x i) âˆ˜ f`æ˜¯è¿ç»­çš„ã€‚è®©æˆ‘ä»¬ä½¿ç”¨è¡¨ç¤ºæŠ•å½±`(fun (x
    : Î  i, X i) â†¦ x i)`çš„ç¬¦å·\(p_i\)æ¥â€œåœ¨çº¸ä¸Šâ€æ¢ç´¢è¿™ä¸ªçº¦æŸï¼š'
- en: \[\begin{split}(âˆ€ i, p_i âˆ˜ f \text{ continuous}) &â‡” âˆ€ i, (p_i âˆ˜ f)_* T_Z â‰¤ T_{X_i}
    \\ &â‡” âˆ€ i, (p_i)_* f_* T_Z â‰¤ T_{X_i}\\ &â‡” âˆ€ i, f_* T_Z â‰¤ (p_i)^*T_{X_i}\\ &â‡” f_*
    T_Z â‰¤ \inf \left[(p_i)^*T_{X_i}\right]\end{split}\]
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}(âˆ€ i, p_i âˆ˜ f \text{ è¿ç»­}) &â‡” âˆ€ i, (p_i âˆ˜ f)_* T_Z â‰¤ T_{X_i} \\
    &â‡” âˆ€ i, (p_i)_* f_* T_Z â‰¤ T_{X_i}\\ &â‡” âˆ€ i, f_* T_Z â‰¤ (p_i)^*T_{X_i}\\ &â‡” f_*
    T_Z â‰¤ \inf \left[(p_i)^*T_{X_i}\right]\end{split}\]
- en: 'So we see that what is the topology we want on `Î  i, X i`:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬çœ‹åˆ°æˆ‘ä»¬å¸Œæœ›åœ¨`Î  i, X i`ä¸Šçš„æ‹“æ‰‘æ˜¯ä»€ä¹ˆï¼š
- en: '[PRE215]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: This ends our tour of how Mathlib thinks that topological spaces fix defects
    of the theory of metric spaces by being a more functorial theory and having a
    complete lattice structure for any fixed type.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±ç»“æŸäº†æˆ‘ä»¬å¯¹Mathlibå¦‚ä½•è®¤ä¸ºæ‹“æ‰‘ç©ºé—´é€šè¿‡æˆä¸ºä¸€ä¸ªæ›´å‡½å­åŒ–çš„ç†è®ºå’Œä¸ºä»»ä½•å›ºå®šç±»å‹å…·æœ‰å®Œå¤‡æ ¼ç»“æ„æ¥ä¿®å¤åº¦é‡ç©ºé—´ç†è®ºçš„ç¼ºé™·çš„è€ƒå¯Ÿã€‚
- en: 11.3.2\. Separation and countability[ïƒ](#separation-and-countability "Link to
    this heading")
  id: totrans-732
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2\. åˆ†éš”ä¸å¯æ•°æ€§[ïƒ](#separation-and-countability "é“¾æ¥åˆ°æœ¬æ ‡é¢˜")
- en: 'We saw that the category of topological spaces have very nice properties. The
    price to pay for this is existence of rather pathological topological spaces.
    There are a number of assumptions you can make on a topological space to ensure
    its behavior is closer to what metric spaces do. The most important is `T2Space`,
    also called â€œHausdorffâ€, that will ensure that limits are unique. A stronger separation
    property is `T3Space` that ensures in addition the RegularSpace property: each
    point has a basis of closed neighborhoods.'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çœ‹åˆ°ï¼Œæ‹“æ‰‘ç©ºé—´ç±»çš„æ€§è´¨éå¸¸å¥½ã€‚ä¸ºæ­¤ä»˜å‡ºçš„ä»£ä»·æ˜¯å­˜åœ¨ç›¸å½“ç—…æ€çš„æ‹“æ‰‘ç©ºé—´ã€‚ä½ å¯ä»¥åœ¨æ‹“æ‰‘ç©ºé—´ä¸Šåšå‡ºä¸€äº›å‡è®¾ï¼Œä»¥ç¡®ä¿å…¶è¡Œä¸ºæ›´æ¥è¿‘åº¦é‡ç©ºé—´ã€‚å…¶ä¸­æœ€é‡è¦çš„æ˜¯`T2Space`ï¼Œä¹Ÿç§°ä¸ºâ€œHausdorffâ€ï¼Œè¿™å°†ç¡®ä¿æé™æ˜¯å”¯ä¸€çš„ã€‚æ›´å¼ºçš„åˆ†ç¦»æ€§è´¨æ˜¯`T3Space`ï¼Œå®ƒè¿˜ç¡®ä¿äº†æ­£åˆ™ç©ºé—´æ€§è´¨ï¼šæ¯ä¸ªç‚¹éƒ½æœ‰ä¸€ä¸ªé—­é‚»åŸŸåŸºã€‚
- en: '[PRE216]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: Note that, in every topological space, each point has a basis of open neighborhood,
    by definition.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨æ¯ä¸€ä¸ªæ‹“æ‰‘ç©ºé—´ä¸­ï¼Œæ¯ä¸ªç‚¹éƒ½æœ‰ä¸€ä¸ªå¼€é‚»åŸŸåŸºï¼Œè¿™æ˜¯å®šä¹‰æ‰€è¦æ±‚çš„ã€‚
- en: '[PRE217]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'Our main goal is now to prove the basic theorem which allows extension by continuity.
    From Bourbakiâ€™s general topology book, I.8.5, Theorem 1 (taking only the non-trivial
    implication):'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨çš„ç›®æ ‡æ˜¯è¯æ˜ä¸€ä¸ªåŸºæœ¬å®šç†ï¼Œè¯¥å®šç†å…è®¸é€šè¿‡è¿ç»­æ€§è¿›è¡Œæ‰©å±•ã€‚ä»Bourbakiçš„æ™®é€šæ‹“æ‰‘å­¦ä¹¦ç±ï¼ŒI.8.5ï¼Œå®šç†1ï¼ˆä»…è€ƒè™‘éå¹³å‡¡è•´å«ï¼‰ï¼š
- en: 'Let \(X\) be a topological space, \(A\) a dense subset of \(X\), \(f : A â†’
    Y\) a continuous mapping of \(A\) into a \(T_3\) space \(Y\). If, for each \(x\)
    in \(X\), \(f(y)\) tends to a limit in \(Y\) when \(y\) tends to \(x\) while remaining
    in \(A\) then there exists a continuous extension \(Ï†\) of \(f\) to \(X\).'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 'è®¾\(X\)æ˜¯ä¸€ä¸ªæ‹“æ‰‘ç©ºé—´ï¼Œ\(A\)æ˜¯\(X\)çš„ç¨ å¯†å­é›†ï¼Œ\(f : A â†’ Y\)æ˜¯\(A\)åˆ°\(T_3\)ç©ºé—´\(Y\)çš„è¿ç»­æ˜ å°„ã€‚å¦‚æœå¯¹äº\(X\)ä¸­çš„æ¯ä¸ª\(x\)ï¼Œå½“\(y\)åœ¨\(A\)ä¸­è¶‹å‘äº\(x\)æ—¶ï¼Œ\(f(y)\)åœ¨\(Y\)ä¸­è¶‹å‘äºä¸€ä¸ªæé™ï¼Œé‚£ä¹ˆå­˜åœ¨ä¸€ä¸ªå°†\(f\)æ‰©å±•åˆ°\(X\)çš„è¿ç»­æ‰©å±•\(Ï†\)ã€‚'
- en: Actually Mathlib contains a more general version of the above lemma, `IsDenseInducing.continuousAt_extend`,
    but weâ€™ll stick to Bourbakiâ€™s version here.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šï¼ŒMathlib åŒ…å«ä¸Šè¿°å¼•ç†çš„ä¸€ä¸ªæ›´ä¸€èˆ¬çš„ç‰ˆæœ¬ï¼Œå³`IsDenseInducing.continuousAt_extend`ï¼Œä½†åœ¨è¿™é‡Œæˆ‘ä»¬å°†åšæŒä½¿ç”¨Bourbakiçš„ç‰ˆæœ¬ã€‚
- en: 'Remember that, given `A : Set X`, `â†¥A` is the subtype associated to `A`, and
    Lean will automatically insert that funny up arrow when needed. And the (inclusion)
    coercion map is `(â†‘) : A â†’ X`. The assumption â€œtends to \(x\) while remaining
    in \(A\)â€ corresponds to the pull-back filter `comap (â†‘) (ğ“ x)`.'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 'è®°ä½ï¼Œç»™å®š`A : Set X`ï¼Œ`â†¥A`æ˜¯ä¸`A`å…³è”çš„å­ç±»å‹ï¼Œå¹¶ä¸”å½“éœ€è¦æ—¶Leanä¼šè‡ªåŠ¨æ’å…¥é‚£ä¸ªæœ‰è¶£çš„å‘ä¸Šç®­å¤´ã€‚è€Œï¼ˆåŒ…å«ï¼‰å¼ºåˆ¶æ˜ å°„æ˜¯`(â†‘) :
    A â†’ X`ã€‚å‡è®¾â€œåœ¨`A`ä¸­è¶‹å‘äº`x`çš„åŒæ—¶ä¿æŒä¸å˜â€å¯¹åº”äºæ‹‰å›è¿‡æ»¤å™¨`comap (â†‘) (ğ“ x)`ã€‚'
- en: Letâ€™s first prove an auxiliary lemma, extracted to simplify the context (in
    particular we donâ€™t need Y to be a topological space here).
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å…ˆè¯æ˜ä¸€ä¸ªè¾…åŠ©å¼•ç†ï¼Œå°†å…¶æå–å‡ºæ¥ä»¥ç®€åŒ–ä¸Šä¸‹æ–‡ï¼ˆç‰¹åˆ«æ˜¯æˆ‘ä»¬åœ¨è¿™é‡Œä¸éœ€è¦Yæ˜¯æ‹“æ‰‘ç©ºé—´ï¼‰ã€‚
- en: '[PRE218]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: Letâ€™s now turn to the main proof of the extension by continuity theorem.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬è½¬å‘è¿ç»­æ‰©å±•å®šç†çš„ä¸»è¦è¯æ˜ã€‚
- en: 'When Lean needs a topology on `â†¥A` it will automatically use the induced topology.
    The only relevant lemma is `nhds_induced (â†‘) : âˆ€ a : â†¥A, ğ“ a = comap (â†‘) (ğ“ â†‘a)`
    (this is actually a general lemma about induced topologies).'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 'å½“Leanéœ€è¦ä¸€ä¸ªåœ¨`â†¥A`ä¸Šçš„æ‹“æ‰‘æ—¶ï¼Œå®ƒå°†è‡ªåŠ¨ä½¿ç”¨è¯±å¯¼æ‹“æ‰‘ã€‚å”¯ä¸€ç›¸å…³çš„å¼•ç†æ˜¯`nhds_induced (â†‘) : âˆ€ a : â†¥A, ğ“ a =
    comap (â†‘) (ğ“ â†‘a)`ï¼ˆè¿™å®é™…ä¸Šæ˜¯ä¸€ä¸ªå…³äºè¯±å¯¼æ‹“æ‰‘çš„é€šç”¨å¼•ç†ï¼‰ã€‚'
- en: 'The proof outline is:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: è¯æ˜æ¦‚è¦æ˜¯ï¼š
- en: The main assumption and the axiom of choice give a function `Ï†` such that `âˆ€
    x, Tendsto f (comap (â†‘) (ğ“ x)) (ğ“ (Ï† x))` (because `Y` is Hausdorff, `Ï†` is entirely
    determined, but we wonâ€™t need that until we try to prove that `Ï†` indeed extends
    `f`).
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸»è¦å‡è®¾å’Œé€‰æ‹©å…¬ç†ç»™å‡ºä¸€ä¸ªå‡½æ•°`Ï†`ï¼Œä½¿å¾—`âˆ€ x, Tendsto f (comap (â†‘) (ğ“ x)) (ğ“ (Ï† x))`ï¼ˆå› ä¸º`Y`æ˜¯Hausdorffçš„ï¼Œ`Ï†`å®Œå…¨ç¡®å®šï¼Œä½†æˆ‘ä»¬ä¸ä¼šåœ¨å°è¯•è¯æ˜`Ï†`ç¡®å®æ‰©å±•`f`ä¹‹å‰éœ€è¦å®ƒï¼‰ã€‚
- en: 'Letâ€™s first prove `Ï†` is continuous. Fix any `x : X`. Since `Y` is regular,
    it suffices to check that for every *closed* neighborhood `V''` of `Ï† x`, `Ï† â»Â¹''
    V'' âˆˆ ğ“ x`. The limit assumption gives (through the auxiliary lemma above) some
    `V âˆˆ ğ“ x` such `IsOpen V âˆ§ (â†‘) â»Â¹'' V âŠ† f â»Â¹'' V''`. Since `V âˆˆ ğ“ x`, it suffices
    to prove `V âŠ† Ï† â»Â¹'' V''`, i.e. `âˆ€ y âˆˆ V, Ï† y âˆˆ V''`. Letâ€™s fix `y` in `V`. Because
    `V` is *open*, it is a neighborhood of `y`. In particular `(â†‘) â»Â¹'' V âˆˆ comap
    (â†‘) (ğ“ y)` and a fortiori `f â»Â¹'' V'' âˆˆ comap (â†‘) (ğ“ y)`. In addition `comap (â†‘)
    (ğ“ y) â‰  âŠ¥` because `A` is dense. Because we know `Tendsto f (comap (â†‘) (ğ“ y))
    (ğ“ (Ï† y))` this implies `Ï† y âˆˆ closure V''` and, since `V''` is closed, we have
    proved `Ï† y âˆˆ V''`.'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 'è®©æˆ‘ä»¬å…ˆè¯æ˜`Ï†`æ˜¯è¿ç»­çš„ã€‚å›ºå®šä»»æ„çš„`x : X`ã€‚ç”±äº`Y`æ˜¯æ­£åˆ™çš„ï¼Œæˆ‘ä»¬åªéœ€æ£€æŸ¥å¯¹äº`Ï† x`çš„æ¯ä¸€ä¸ªé—­é‚»åŸŸ`V''`ï¼Œ`Ï† â»Â¹'' V''
    âˆˆ ğ“ x`ã€‚æé™å‡è®¾ç»™å‡ºäº†ï¼ˆé€šè¿‡ä¸Šé¢çš„è¾…åŠ©å¼•ç†ï¼‰ä¸€äº›`V âˆˆ ğ“ x`ï¼Œä½¿å¾—`IsOpen V âˆ§ (â†‘) â»Â¹'' V âŠ† f â»Â¹'' V''`ã€‚ç”±äº`V
    âˆˆ ğ“ x`ï¼Œæˆ‘ä»¬åªéœ€è¯æ˜`V âŠ† Ï† â»Â¹'' V''`ï¼Œå³`âˆ€ y âˆˆ V, Ï† y âˆˆ V''`ã€‚è®©æˆ‘ä»¬å›ºå®š`V`ä¸­çš„`y`ã€‚å› ä¸º`V`æ˜¯å¼€é›†ï¼Œå®ƒæ˜¯`y`çš„ä¸€ä¸ªé‚»åŸŸã€‚ç‰¹åˆ«æ˜¯`(â†‘)
    â»Â¹'' V âˆˆ comap (â†‘) (ğ“ y)`ï¼Œå¹¶ä¸”æ›´æ˜æ˜¾åœ°`f â»Â¹'' V'' âˆˆ comap (â†‘) (ğ“ y)`ã€‚æ­¤å¤–ï¼Œç”±äº`A`æ˜¯ç¨ å¯†çš„ï¼Œ`comap
    (â†‘) (ğ“ y) â‰  âŠ¥`ã€‚å› ä¸ºæˆ‘ä»¬çŸ¥é“`Tendsto f (comap (â†‘) (ğ“ y)) (ğ“ (Ï† y))`ï¼Œè¿™è¡¨æ˜`Ï† y âˆˆ closure
    V''`ï¼Œå¹¶ä¸”ç”±äº`V''`æ˜¯é—­é›†ï¼Œæˆ‘ä»¬è¯æ˜äº†`Ï† y âˆˆ V''`ã€‚'
- en: It remains to prove that `Ï†` extends `f`. This is where the continuity of `f`
    enters the discussion, together with the fact that `Y` is Hausdorff.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: å‰©ä¸‹çš„å·¥ä½œæ˜¯è¯æ˜`Ï†`æ‰©å±•äº†`f`ã€‚è¿™æ˜¯`f`çš„è¿ç»­æ€§å’Œ`Y`æ˜¯è±ªæ–¯å¤šå¤«çš„äº‹å®è¿›å…¥è®¨è®ºçš„åœ°æ–¹ã€‚
- en: '[PRE219]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: In addition to separation property, the main kind of assumption you can make
    on a topological space to bring it closer to metric spaces is countability assumption.
    The main one is first countability asking that every point has a countable neighborhood
    basis. In particular this ensures that closure of sets can be understood using
    sequences.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: é™¤äº†åˆ†ç¦»æ€§è´¨å¤–ï¼Œä½ å¯ä»¥å¯¹æ‹“æ‰‘ç©ºé—´åšå‡ºçš„ä¸»è¦å‡è®¾æ˜¯å¯æ•°æ€§å‡è®¾ï¼Œè¿™æœ‰åŠ©äºå°†å…¶ä¸åº¦é‡ç©ºé—´è”ç³»èµ·æ¥ã€‚ä¸»è¦çš„ä¸€ä¸ªæ˜¯ç¬¬ä¸€å¯æ•°æ€§ï¼Œè¦æ±‚æ¯ä¸ªç‚¹éƒ½æœ‰ä¸€ä¸ªå¯æ•°çš„é‚»åŸŸåŸºã€‚ç‰¹åˆ«æ˜¯è¿™ç¡®ä¿äº†é›†åˆçš„é—­åŒ…å¯ä»¥ç”¨åºåˆ—æ¥ç†è§£ã€‚
- en: '[PRE220]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 11.3.3\. Compactness[ïƒ](#id5 "Link to this heading")
  id: totrans-752
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.3\. ç´§è‡´æ€§[ïƒ](#id5 "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")
- en: Let us now discuss how compactness is defined for topological spaces. As usual
    there are several ways to think about it and Mathlib goes for the filter version.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æ¥è®¨è®ºæ‹“æ‰‘ç©ºé—´ä¸­ç´§è‡´æ€§çš„å®šä¹‰ã€‚é€šå¸¸æœ‰å‡ ç§æ€è€ƒæ–¹å¼ï¼ŒMathlibé€‰æ‹©äº†æ»¤æ³¢ç‰ˆæœ¬ã€‚
- en: 'We first need to define cluster points of filters. Given a filter `F` on a
    topological space `X`, a point `x : X` is a cluster point of `F` if `F`, seen
    as a generalized set, has non-empty intersection with the generalized set of points
    that are close to `x`.'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 'æˆ‘ä»¬é¦–å…ˆéœ€è¦å®šä¹‰æ»¤æ³¢çš„èšç‚¹ã€‚ç»™å®šä¸€ä¸ªæ‹“æ‰‘ç©ºé—´`X`ä¸Šçš„æ»¤æ³¢`F`ï¼Œå¦‚æœç‚¹`x : X`æ˜¯`F`ï¼ˆä½œä¸ºä¸€ä¸ªå¹¿ä¹‰é›†åˆï¼‰ä¸æ¥è¿‘`x`çš„ç‚¹çš„å¹¿ä¹‰é›†åˆéç©ºäº¤é›†çš„ç‚¹ï¼Œé‚£ä¹ˆ`x`æ˜¯`F`çš„èšç‚¹ã€‚'
- en: Then we can say that a set `s` is compact if every nonempty generalized set
    `F` contained in `s`, i.e. such that `F â‰¤ ğ“Ÿ s`, has a cluster point in `s`.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥è¯´ï¼Œå¦‚æœ`s`ä¸­çš„æ¯ä¸€ä¸ªéç©ºå¹¿ä¹‰é›†åˆ`F`ï¼ˆå³`F â‰¤ ğ“Ÿ s`ï¼‰ï¼Œåœ¨`s`ä¸­éƒ½æœ‰ä¸€ä¸ªèšç‚¹ï¼Œé‚£ä¹ˆ`s`æ˜¯ç´§è‡´çš„ã€‚
- en: '[PRE221]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'For instance if `F` is `map u atTop`, the image under `u : â„• â†’ X` of `atTop`,
    the generalized set of very large natural numbers, then the assumption `F â‰¤ ğ“Ÿ
    s` means that `u n` belongs to `s` for `n` large enough. Saying that `x` is a
    cluster point of `map u atTop` says the image of very large numbers intersects
    the set of points that are close to `x`. In case `ğ“ x` has a countable basis,
    we can interpret this as saying that `u` has a subsequence converging to `x`,
    and we get back what compactness looks like in metric spaces.'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¾‹å¦‚ï¼Œå¦‚æœ`F`æ˜¯`map u atTop`ï¼Œå³`u : â„• â†’ X`æ˜ å°„ä¸‹çš„`atTop`ï¼ˆä¸€ä¸ªéå¸¸å¤§çš„è‡ªç„¶æ•°çš„å¹¿ä¹‰é›†åˆï¼‰çš„åƒï¼Œé‚£ä¹ˆå‡è®¾`F â‰¤ ğ“Ÿ
    s`æ„å‘³ç€å¯¹äºè¶³å¤Ÿå¤§çš„`n`ï¼Œ`u n`å±äº`s`ã€‚è¯´`x`æ˜¯`map u atTop`çš„èšç‚¹æ„å‘³ç€éå¸¸å¤§çš„æ•°çš„åƒä¸æ¥è¿‘`x`çš„ç‚¹çš„é›†åˆç›¸äº¤ã€‚å¦‚æœ`ğ“ x`æœ‰ä¸€ä¸ªå¯æ•°åŸºï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶è§£é‡Šä¸º`u`æœ‰ä¸€ä¸ªå­åºåˆ—æ”¶æ•›åˆ°`x`ï¼Œä»è€Œæˆ‘ä»¬å¾—åˆ°äº†ç´§è‡´æ€§åœ¨åº¦é‡ç©ºé—´ä¸­çš„æ ·å­ã€‚'
- en: '[PRE222]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: Cluster points behave nicely with continuous functions.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: èšç‚¹ä¸è¿ç»­å‡½æ•°çš„è¡Œä¸ºè‰¯å¥½ã€‚
- en: '[PRE223]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: As an exercise, we will prove that the image of a compact set under a continuous
    map is compact. In addition to what we saw already, you should use `Filter.push_pull`
    and `NeBot.of_map`.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºç»ƒä¹ ï¼Œæˆ‘ä»¬å°†è¯æ˜ç´§é›†åœ¨è¿ç»­æ˜ å°„ä¸‹çš„åƒæ˜¯ç´§è‡´çš„ã€‚é™¤äº†æˆ‘ä»¬å·²ç»çœ‹åˆ°çš„ï¼Œä½ åº”è¯¥ä½¿ç”¨`Filter.push_pull`å’Œ`NeBot.of_map`ã€‚
- en: '[PRE224]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'One can also express compactness in terms of open covers: `s` is compact if
    every family of open sets that cover `s` has a finite covering sub-family.'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªäººä¹Ÿå¯ä»¥ç”¨å¼€è¦†ç›–æ¥è¡¨ç¤ºç´§è‡´æ€§ï¼šå¦‚æœè¦†ç›–`s`çš„æ¯ä¸€ä¸ªå¼€é›†æ—éƒ½æœ‰ä¸€ä¸ªæœ‰é™è¦†ç›–å­æ—ï¼Œé‚£ä¹ˆ`s`æ˜¯ç´§è‡´çš„ã€‚
- en: '[PRE225]*'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE225]*'
