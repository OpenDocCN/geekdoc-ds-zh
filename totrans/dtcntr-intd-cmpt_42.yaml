- en: 13.2¬†Mutable Listsüîó
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://dcic-world.org/2025-08-27/mutable-lists.html](https://dcic-world.org/2025-08-27/mutable-lists.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Let‚Äôs expand our study of updates yet again, this time looking at updating lists.
    We‚Äôll start with lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that Shaunae wants to use a program to maintain her shopping list.
    She creates an initial list with two items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Shaunae wants to add eggs to her list. Write a line of code to accomplish this.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'There are two ways you could have done this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What is the difference between these two approaches? The difference lies in
    the impact on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: The first version creates a new list containing `"eggs"`, then puts the elements
    of the two lists together in a new list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second version inserts `"eggs"` into the existing list in the heap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let‚Äôs look at the directories for each version. Here‚Äôs the final directory
    for the first version:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1010
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: 1005:¬†`List(len:2)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1006:¬†`"bread"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1007:¬†`"coffee"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1008:¬†`List(len:1)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1009:¬†`"eggs"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1010:¬†`List(len:3)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1011:¬†`"bread"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1012:¬†`"coffee"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1013:¬†`"eggs"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The original version of `shaunae_list` is in address 1005, the list with `"eggs"`
    is in 1008, and the combined list is in 1010.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, the final directory for the second version would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1010
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: 1005:¬†`List(len:3)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1006:¬†`"bread"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1007:¬†`"coffee"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1008:¬†`"eggs"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice here that the length and contents of the original list are changed to
    include the newly-appended `"eggs"`.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which approach do you think is better? Why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: At first glance, the second approach might seem better because it doesn‚Äôt create
    additional unnecessary lists. Both approaches result in the same contents in `shaunae_List`,
    so there seems little benefit to using the additional space.
  prefs: []
  type: TYPE_NORMAL
- en: Unless, of course, we want to still have access to the old version of `shaunae_list`
    later on. The old list is still in the heap (though our current program has no
    name through which to access that old list). What if we instead had written the
    program this way?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if Shaunae realizes she goofed and put her art supply shopping on the
    grocery list on that last update, she could ‚Äúundo‚Äù the update by resetting her
    list variable to the previous list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Undoing a modification (just like the undo feature in document-editing tools)
    is just one example of where it can help to hang on to older versions of data
    for a little while. The point here is not to give a sophisticated treatment of
    undoing computations, but more to motivate that there are situations in which
    creating a new list is preferable to updating the old one.
  prefs: []
  type: TYPE_NORMAL
- en: When might we want to update, rather than preserve, the existing list?
  prefs: []
  type: TYPE_NORMAL
- en: Remember our discussion of aliasing? We wanted two people, Elena and Jorge to
    share access to a common bank account. Might we ever want a shared shopping list?
    Sure, Shaunae and her roommate Jonella do share a shopping list, so that they
    can both add items while letting either one go to the store.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Set up a shared shopping list that is accessible through two names, `shaunae_list`
    and `jonella_list`. Then, add an item to the list via one of these names and check
    that the item appears under the other name.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You might have written something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you load this code at the prompt and look at both lists at the end, you‚Äôll
    see they have the same values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, had we written the code as follows, only one of them would see
    the new item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Draw the memory diagram for the above program.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Exercise: Creating Lists of Accounts[üîó](#(part._.Exercise__.Creating_.Lists_of_.Accounts)
    "Link to here")'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Mutating Top-Level Variables within Functions](mutating-variables.html#%28part._mut-top-level-vars-in-func%29),
    we wrote a function to create new accounts for the bank. That function returned
    each new account as it was created. That meant that every newly-created account
    had to be associated with a name in the directory (otherwise we would not be able
    to access it from the heap).
  prefs: []
  type: TYPE_NORMAL
- en: 'Maintaining either a list or a dictionary of all the created accounts makes
    much more sense. We‚Äôd need only a single name for the collection of accounts,
    but could still access individual accounts as needed. For example, we might want
    an `all_accts` list that looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a program that creates an empty `all_accts` list, then adds a new `Account`
    to it each time `create_acct` is called. You will need to modify `create_acct`
    in order to do this. Here is the existing code as a starting point.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did you include a line like `global all_accts` in your code? Why or why not?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you used `append` to update the `all_accts` list, then you would not need
    to include `global all_accts`. Recall that `global` is needed to tell Python to
    update a variable in the top-level directory rather than the local directory.
    If you use `all_accts.append`, however, you are modifying the heap instead of
    the directory. There is no need for `global` if your code is only modifying heap
    contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: Creating Lists of Accounts[üîó](#(part._.Exercise__.Creating_.Lists_of_.Accounts)
    "Link to here")'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Mutating Top-Level Variables within Functions](mutating-variables.html#%28part._mut-top-level-vars-in-func%29),
    we wrote a function to create new accounts for the bank. That function returned
    each new account as it was created. That meant that every newly-created account
    had to be associated with a name in the directory (otherwise we would not be able
    to access it from the heap).
  prefs: []
  type: TYPE_NORMAL
- en: 'Maintaining either a list or a dictionary of all the created accounts makes
    much more sense. We‚Äôd need only a single name for the collection of accounts,
    but could still access individual accounts as needed. For example, we might want
    an `all_accts` list that looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a program that creates an empty `all_accts` list, then adds a new `Account`
    to it each time `create_acct` is called. You will need to modify `create_acct`
    in order to do this. Here is the existing code as a starting point.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did you include a line like `global all_accts` in your code? Why or why not?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you used `append` to update the `all_accts` list, then you would not need
    to include `global all_accts`. Recall that `global` is needed to tell Python to
    update a variable in the top-level directory rather than the local directory.
    If you use `all_accts.append`, however, you are modifying the heap instead of
    the directory. There is no need for `global` if your code is only modifying heap
    contents.
  prefs: []
  type: TYPE_NORMAL
