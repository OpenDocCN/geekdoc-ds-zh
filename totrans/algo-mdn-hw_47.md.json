["```cpp\nvoid merge(int *a, int *b, int *c, int n, int m) {  int i = 0, j = 0; for (int k = 0; k < n + m; k++) { if (i < n && (j == m || a[i] < b[j])) c[k] = a[i++]; else c[k] = b[j++]; } } \n```", "```cpp\nconst int B = (1<<20) / 4; // 1 MB blocks of integers const int M = (1<<28) / 4; // available memory  FILE *input = fopen(\"input.bin\", \"rb\"); std::vector<FILE*> parts;   while (true) {  static int part[M]; // better delete it right after int n = fread(part, 4, M, input);   if (n == 0) break;  // sort a block in-memory std::sort(part, part + n);  char fpart[sizeof \"part-999.bin\"]; sprintf(fpart, \"part-%03d.bin\", parts.size());   printf(\"Writing %d elements into %s...\\n\", n, fpart);   FILE *file = fopen(fpart, \"wb\"); fwrite(part, 4, n, file); fclose(file);  file = fopen(fpart, \"rb\"); parts.push_back(file); }   fclose(input); \n```", "```cpp\nstruct Pointer {  int key, part; // the element itself and the number of its part  bool operator<(const Pointer& other) const { return key > other.key; // std::priority_queue is a max-heap by default } };   std::priority_queue<Pointer> q; \n```", "```cpp\nconst int nparts = parts.size();   auto buffers = new int[nparts][B]; // buffers for each part int *l = new int[nparts],          // # of already processed buffer elements  *r = new int[nparts];          // buffer size (in case it isn't full)  // now we add fill the buffer for each part and add their elements to the heap for (int part = 0; part < nparts; part++) {  l[part] = 1; // if the element is in the heap, we also consider it \"processed\" r[part] = fread(buffers[part], 4, B, parts[part]); q.push({buffers[part][0], part}); } \n```", "```cpp\nFILE *output = fopen(\"output.bin\", \"w\");   int outbuffer[B]; // the output buffer int buffered = 0; // number of elements in it  while (!q.empty()) {  auto [key, part] = q.top(); q.pop();   // write the minimum to the output buffer outbuffer[buffered++] = key; // check if it needs to be committed to the file if (buffered == B) { fwrite(outbuffer, 4, B, output); buffered = 0; }   // fetch a new block of that part if needed if (l[part] == r[part]) { r[part] = fread(buffers[part], 4, B, parts[part]); l[part] = 0; }   // read a new element from that part unless we've already processed all of it if (l[part] < r[part]) { q.push({buffers[part][l[part]], part}); l[part]++; } }   // write what's left of the output buffer fwrite(outbuffer, 4, buffered, output);   //clean up delete[] buffers; for (FILE *file : parts)  fclose(file); fclose(output); \n```", "```cpp\ndef join(a, b):  d = dict(a) for x, y in b: if x in d: yield d[x] \n```"]