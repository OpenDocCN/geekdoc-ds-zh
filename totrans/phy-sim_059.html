<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Case Study: Compressing Square</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Case Study: Compressing Square</h1>
<blockquote>原文：<a href="https://phys-sim-book.github.io/lec11.2-compress_square.html">https://phys-sim-book.github.io/lec11.2-compress_square.html</a></blockquote>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"/>

<p>We simulate compressing an elastic square using a ceiling.
The excutable Python project for this section can be found at <a href="https://github.com/phys-sim-book/solid-sim-tutorial">https://github.com/phys-sim-book/solid-sim-tutorial</a> under the <code>5_mov_dirichlet</code> folder.
<a href="https://github.com/MuGdxy/muda">MUDA</a> GPU implementations can be found at <a href="https://github.com/phys-sim-book/solid-sim-tutorial-gpu">https://github.com/phys-sim-book/solid-sim-tutorial-gpu</a> under the <code>simulators/5_mov_dirichlet</code> folder.</p>
<p>The ceiling in our simulation is modeled as a half-space with a downward normal vector <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"/><span class="mord mathbf">n</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>. The distance from the ceiling to other simulated Degrees of Freedom (DOFs) can be calculated using Equation <a href="lec7.1-signed_dists.html#eq:lec7:half_space_dist">(7.1.1)</a>. To effectively apply the penalty method, it's necessary that the ceiling's height also serves as a DOF.</p>
<p>Following the approach used in the <a href="lec10-square_on_slope.html">Square on Slope</a> project, we choose the origin <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"/><span class="mord"><span class="mord"><span class="mord boldsymbol">o</span></span></span></span></span></span> on the ceiling as the DOF and incorporate it into the variable <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"/><span class="mord mathnormal">x</span></span></span></span>:</p>
<p><a name="imp:lec11:ceiling_dof"/>
<strong>Implementation 11.2.1 (Ceiling DOF setup, simulator.py).</strong></p>
<pre><code class="language-python">[x, e] = square_mesh.generate(side_len, n_seg)      # node positions and edge node indices
x = np.append(x, [[0.0, side_len * 0.6]], axis=0)   # ceil origin (with normal [0.0, -1.0])
</code></pre>
<p>The ceiling is initially positioned directly above the elastic square, as shown in the left image of <a href="#fig:lec11:compress_square">Figure 11.2.1</a>. By doing so, we ensure that the nodal mass of this newly added DOF is consistent with the other simulated nodes on the square, as per our implementation.</p>
<p>With this additional DOF, we can straightforwardly model the contact between the ceiling and the square. This is done by enhancing the existing functions that compute the barrier energy value, gradient, Hessian, and the initial step size:</p>
<p><a name="imp:lec11:barrier_val"/>
<strong>Implementation 11.2.2 (Barrier energy value, BarrierEnergy.py).</strong></p>
<pre><code class="language-python">    n = np.array([0.0, -1.0])
    for i in range(0, len(x) - 1):
        d = n.dot(x[i] - x[-1])
        if d &lt; dhat:
            s = d / dhat
            sum += contact_area[i] * dhat * kappa / 2 * (s - 1) * math.log(s)
</code></pre>
<p><a name="imp:lec11:barrier_grad"/>
<strong>Implementation 11.2.3 (Barrier energy gradient, BarrierEnergy.py).</strong></p>
<pre><code class="language-python">    n = np.array([0.0, -1.0])
    for i in range(0, len(x) - 1):
        d = n.dot(x[i] - x[-1])
        if d &lt; dhat:
            s = d / dhat
            local_grad = contact_area[i] * dhat * (kappa / 2 * (math.log(s) / dhat + (s - 1) / d)) * n
            g[i] += local_grad
            g[-1] -= local_grad
</code></pre>
<p><a name="imp:lec11:barrier_hess"/>
<strong>Implementation 11.2.4 (Barrier energy Hessian, BarrierEnergy.py).</strong></p>
<pre><code class="language-python">    n = np.array([0.0, -1.0])
    for i in range(0, len(x) - 1):
        d = n.dot(x[i] - x[-1])
        if d &lt; dhat:
            local_hess = contact_area[i] * dhat * kappa / (2 * d * d * dhat) * (d + dhat) * np.outer(n, n)
            index = [i, len(x) - 1]
            for nI in range(0, 2):
                for nJ in range(0, 2):
                    for c in range(0, 2):
                        for r in range(0, 2):
                            IJV[0].append(index[nI] * 2 + r)
                            IJV[1].append(index[nJ] * 2 + c)
                            IJV[2] = np.append(IJV[2], ((-1) ** (nI != nJ)) * local_hess[r, c])
</code></pre>
<p><a name="imp:lec11:barrier_ccd"/>
<strong>Implementation 11.2.5 (Initial step size calculation, BarrierEnergy.py).</strong></p>
<pre><code class="language-python">    n = np.array([0.0, -1.0])
    for i in range(0, len(x) - 1):
        p_n = (p[i] - p[-1]).dot(n)
        if p_n &lt; 0:
            alpha = min(alpha, 0.9 * n.dot(x[i] - x[-1]) / -p_n)
</code></pre>
<p>Here for the distance between the ceiling <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"/><span class="mord"><span class="mord"><span class="mord boldsymbol">o</span></span></span></span></span></span> and a node <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"/><span class="mord mathbf">x</span></span></span></span>, we have the stacked quantities locally:
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord"><span class="mord boldsymbol">o</span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1.1413em;vertical-align:-0.25em;"/><span class="mord"><span class="mord mathbf">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord"><span class="mord"><span class="mord boldsymbol">o</span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"/><span class="mspace" style="margin-right:0.1667em;"/><span class="mord">∇</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord"><span class="mord boldsymbol">o</span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"/><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"/><span class="mord"><span class="mord mathbf">n</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"/><span class="mord"><span class="mord">−</span><span class="mord mathbf">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span/></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.1667em;"/><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"/><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord">∇</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord"><span class="mord boldsymbol">o</span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord"><span class="mord"><span class="mord mathbf">0</span></span></span><span class="mord">.</span></span></span></span></span></p>
<p>Now we apply the moving BC on the ceiling to compress the elastic square. We set the ceiling's DOF, identified by the node index <code>(n_seg+1)*(n_seg+1)</code>, as the sole Dirichlet Boundary Condition (DBC) in this scene. We assign it a downward velocity of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord">−</span><span class="mord">0.5</span><span class="mclose">)</span></span></span></span>. The movement is stopped when the ceiling reaches a height of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"/><span class="mord">−</span><span class="mord">0.6</span></span></span></span>:</p>
<p><a name="imp:lec11:dbc_setup"/>
<strong>Implementation 11.2.6 (DBC setup, simulator.py).</strong></p>
<pre><code class="language-python">DBC = [(n_seg + 1) * (n_seg + 1)]       # dirichlet node index
DBC_v = [np.array([0.0, -0.5])]         # dirichlet node velocity
DBC_limit = [np.array([0.0, -0.6])]     # dirichlet node limit position
</code></pre>
<p>Then we implement the penalty term according to Equation <a href="lec11.1-penalty_method.html#eq:lec11:DBC_penalty">(11.1.1)</a>, which is essentially a quadratic spring energy for controlling the motion of the ceiling:</p>
<p><a name="imp:lec11:spring_energy"/>
<strong>Implementation 11.2.7 (Spring energy computation, SpringEnergy.py).</strong></p>
<pre><code class="language-python">import numpy as np

def val(x, m, DBC, DBC_target, k):
    sum = 0.0
    for i in range(0, len(DBC)):
        diff = x[DBC[i]] - DBC_target[i]
        sum += 0.5 * k * m[DBC[i]] * diff.dot(diff)
    return sum

def grad(x, m, DBC, DBC_target, k):
    g = np.array([[0.0, 0.0]] * len(x))
    for i in range(0, len(DBC)):
        g[DBC[i]] = k * m[DBC[i]] * (x[DBC[i]] - DBC_target[i])
    return g

def hess(x, m, DBC, DBC_target, k):
    IJV = [[0] * 0, [0] * 0, np.array([0.0] * 0)]
    for i in range(0, len(DBC)):
        for d in range(0, 2):
            IJV[0].append(DBC[i] * 2 + d)
            IJV[1].append(DBC[i] * 2 + d)
            IJV[2] = np.append(IJV[2], k * m[DBC[i]])
    return IJV
</code></pre>
<p>Next, we focus on optimizing with the spring energies while properly handling the convergence check and penalty stiffness adjustments. At the start of each time step, the target position for each DBC node is computed, and the penalty stiffness, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span></span></span></span>, is initialized to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">10</span></span></span></span>. If certain nodes reach their preset limit, we then set the target as their current position:</p>
<p><a name="imp:lec11:dbc_initialization"/>
<strong>Implementation 11.2.8 (DBC initialization, time_integrator.py).</strong></p>
<pre><code class="language-python">    DBC_target = [] # target position of each DBC in the current time step
    for i in range(0, len(DBC)):
        if (DBC_limit[i] - x_n[DBC[i]]).dot(DBC_v[i]) &gt; 0:
            DBC_target.append(x_n[DBC[i]] + h * DBC_v[i])
        else:
            DBC_target.append(x_n[DBC[i]])
</code></pre>
<p>Entering the Newton loop, in each iteration, just before computing the search direction, we assess how many DBC nodes are close enough to their target positions. We store these results in the variable <code>DBC_satisfied</code>:</p>
<p><a name="imp:lec11:dbc_check"/>
<strong>Implementation 11.2.9 (DBC satisfaction check, time_integrator.py).</strong></p>
<pre><code class="language-python">    # check whether each DBC is satisfied
    DBC_satisfied = [False] * len(x)
    for i in range(0, len(DBC)):
        if LA.norm(x[DBC[i]] - DBC_target[i]) / h &lt; tol:
            DBC_satisfied[DBC[i]] = True
</code></pre>
<p>Then we only eliminate the DOFs of those DBC nodes that already satisfy the boundary condition:</p>
<p><a name="imp:lec11:dof_elimination"/>
<strong>Implementation 11.2.10 (DOF elimination, time_integrator.py).</strong></p>
<pre><code class="language-python">    # eliminate DOF if it's a satisfied DBC by modifying gradient and Hessian for DBC:
    for i, j in zip(*projected_hess.nonzero()):
        if (is_DBC[int(i / 2)] &amp; DBC_satisfied[int(i / 2)]) | (is_DBC[int(j / 2)] &amp; DBC_satisfied[int(j / 2)]): 
            projected_hess[i, j] = (i == j)
    for i in range(0, len(x)):
        if is_DBC[i] &amp; DBC_satisfied[i]:
            reshaped_grad[i * 2] = reshaped_grad[i * 2 + 1] = 0.0
    return [spsolve(projected_hess, -reshaped_grad).reshape(len(x), 2), DBC_satisfied]
</code></pre>
<p>The BC satisfaction information stored in <code>DBC_satisfied</code> is also used to check convergence and update <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span></span></span></span> when needed:</p>
<p><a name="imp:lec11:convergence_criteria"/>
<strong>Implementation 11.2.11 (Convergence criteria, time_integrator.py).</strong></p>
<pre><code class="language-python">    [p, DBC_satisfied] = search_dir(x, e, x_tilde, m, l2, k, n, o, contact_area, (x - x_n) / h, mu_lambda, is_DBC, DBC, DBC_target, DBC_stiff[0], tol, h)
    while (LA.norm(p, inf) / h &gt; tol) | (sum(DBC_satisfied) != len(DBC)):   # also check whether all DBCs are satisfied
        print('Iteration', iter, ':')
        print('residual =', LA.norm(p, inf) / h)

        if (LA.norm(p, inf) / h &lt;= tol) &amp; (sum(DBC_satisfied) != len(DBC)):
            # increase DBC stiffness and recompute energy value record
            DBC_stiff[0] *= 2
            E_last = IP_val(x, e, x_tilde, m, l2, k, n, o, contact_area, (x - x_n) / h, mu_lambda, DBC, DBC_target, DBC_stiff[0], h)
</code></pre>
<p>Now, we proceed to run the simulation, which involves severely compressing the dropped elastic square as depicted in (<a href="#fig:lec11:compress_square">Figure 11.2.1</a>). From the final static frame, we observe that the elastic springs on the edges are inverted due to extreme compression. This artifact is typical in mass-spring models of elasticity. In future chapters, we will explore how applying finite-element discretization to barrier-type elasticity models, such as the Neo-Hookean model, can prevent such issues. That approach is akin to the enforcement of non-interpenetrations in our current simulations.</p>
<figure>
    <center>
    <img src="../Images/ecfbf5f9f0ecec91763be32bf418d4c2.png" data-original-src="https://phys-sim-book.github.io/img/lec11/compress_square.jpg"/>
    </center>
    <figcaption><b><a name="fig:lec11:compress_square"/>
Figure 11.2.1.</b> A square is dropped onto the ground and compressed by a ceiling until inverted. </figcaption>
</figure>
                        
</body>
</html>