["```py\nclass  One‚ÇÅ  (Œ±  :  Type)  where\n  /-- The element one -/\n  one  :  Œ± \n```", "```py\n#check  One‚ÇÅ.one  -- One‚ÇÅ.one {Œ± : Type} [self : One‚ÇÅ Œ±] : Œ±\n\n@[class]  structure  One‚ÇÇ  (Œ±  :  Type)  where\n  /-- The element one -/\n  one  :  Œ±\n\n#check  One‚ÇÇ.one \n```", "```py\nexample  (Œ±  :  Type)  [One‚ÇÅ  Œ±]  :  Œ±  :=  One‚ÇÅ.one \n```", "```py\nexample  (Œ±  :  Type)  [One‚ÇÅ  Œ±]  :=  (One‚ÇÅ.one  :  Œ±) \n```", "```py\n@[inherit_doc]\nnotation  \"ùüô\"  =>  One‚ÇÅ.one\n\nexample  {Œ±  :  Type}  [One‚ÇÅ  Œ±]  :  Œ±  :=  ùüô\n\nexample  {Œ±  :  Type}  [One‚ÇÅ  Œ±]  :  (ùüô  :  Œ±)  =  ùüô  :=  rfl \n```", "```py\nclass  Dia‚ÇÅ  (Œ±  :  Type)  where\n  dia  :  Œ±  ‚Üí  Œ±  ‚Üí  Œ±\n\ninfixl:70  \" ‚ãÑ \"  =>  Dia‚ÇÅ.dia \n```", "```py\nclass  Semigroup‚ÇÄ  (Œ±  :  Type)  where\n  toDia‚ÇÅ  :  Dia‚ÇÅ  Œ±\n  /-- Diamond is associative -/\n  dia_assoc  :  ‚àÄ  a  b  c  :  Œ±,  a  ‚ãÑ  b  ‚ãÑ  c  =  a  ‚ãÑ  (b  ‚ãÑ  c) \n```", "```py\nattribute  [instance]  Semigroup‚ÇÄ.toDia‚ÇÅ\n\nexample  {Œ±  :  Type}  [Semigroup‚ÇÄ  Œ±]  (a  b  :  Œ±)  :  Œ±  :=  a  ‚ãÑ  b \n```", "```py\nclass  Semigroup‚ÇÅ  (Œ±  :  Type)  extends  toDia‚ÇÅ  :  Dia‚ÇÅ  Œ±  where\n  /-- Diamond is associative -/\n  dia_assoc  :  ‚àÄ  a  b  c  :  Œ±,  a  ‚ãÑ  b  ‚ãÑ  c  =  a  ‚ãÑ  (b  ‚ãÑ  c)\n\nexample  {Œ±  :  Type}  [Semigroup‚ÇÅ  Œ±]  (a  b  :  Œ±)  :  Œ±  :=  a  ‚ãÑ  b \n```", "```py\nclass  Semigroup‚ÇÇ  (Œ±  :  Type)  extends  Dia‚ÇÅ  Œ±  where\n  /-- Diamond is associative -/\n  dia_assoc  :  ‚àÄ  a  b  c  :  Œ±,  a  ‚ãÑ  b  ‚ãÑ  c  =  a  ‚ãÑ  (b  ‚ãÑ  c) \n```", "```py\nclass  DiaOneClass‚ÇÅ  (Œ±  :  Type)  extends  One‚ÇÅ  Œ±,  Dia‚ÇÅ  Œ±  where\n  /-- One is a left neutral element for diamond. -/\n  one_dia  :  ‚àÄ  a  :  Œ±,  ùüô  ‚ãÑ  a  =  a\n  /-- One is a right neutral element for diamond -/\n  dia_one  :  ‚àÄ  a  :  Œ±,  a  ‚ãÑ  ùüô  =  a \n```", "```py\nset_option  trace.Meta.synthInstance  true  in\nexample  {Œ±  :  Type}  [DiaOneClass‚ÇÅ  Œ±]  (a  b  :  Œ±)  :  Prop  :=  a  ‚ãÑ  b  =  ùüô \n```", "```py\nclass  Monoid‚ÇÅ  (Œ±  :  Type)  extends  Semigroup‚ÇÅ  Œ±,  DiaOneClass‚ÇÅ  Œ± \n```", "```py\nclass  Monoid‚ÇÇ  (Œ±  :  Type)  where\n  toSemigroup‚ÇÅ  :  Semigroup‚ÇÅ  Œ±\n  toDiaOneClass‚ÇÅ  :  DiaOneClass‚ÇÅ  Œ± \n```", "```py\nexample  {Œ±  :  Type}  [Monoid‚ÇÅ  Œ±]  :\n  (Monoid‚ÇÅ.toSemigroup‚ÇÅ.toDia‚ÇÅ.dia  :  Œ±  ‚Üí  Œ±  ‚Üí  Œ±)  =  Monoid‚ÇÅ.toDiaOneClass‚ÇÅ.toDia‚ÇÅ.dia  :=  rfl \n```", "```py\n/- Monoid‚ÇÇ.mk {Œ± : Type} (toSemigroup‚ÇÅ : Semigroup‚ÇÅ Œ±) (toDiaOneClass‚ÇÅ : DiaOneClass‚ÇÅ Œ±) : Monoid‚ÇÇ Œ± -/\n#check  Monoid‚ÇÇ.mk\n\n/- Monoid‚ÇÅ.mk {Œ± : Type} [toSemigroup‚ÇÅ : Semigroup‚ÇÅ Œ±] [toOne‚ÇÅ : One‚ÇÅ Œ±] (one_dia : ‚àÄ (a : Œ±), ùüô ‚ãÑ a = a) (dia_one : ‚àÄ (a : Œ±), a ‚ãÑ ùüô = a) : Monoid‚ÇÅ Œ± -/\n#check  Monoid‚ÇÅ.mk \n```", "```py\n#check  Monoid‚ÇÅ.toSemigroup‚ÇÅ\n#check  Monoid‚ÇÅ.toDiaOneClass‚ÇÅ \n```", "```py\nclass  Inv‚ÇÅ  (Œ±  :  Type)  where\n  /-- The inversion function -/\n  inv  :  Œ±  ‚Üí  Œ±\n\n@[inherit_doc]\npostfix:max  \"‚Åª¬π\"  =>  Inv‚ÇÅ.inv\n\nclass  Group‚ÇÅ  (G  :  Type)  extends  Monoid‚ÇÅ  G,  Inv‚ÇÅ  G  where\n  inv_dia  :  ‚àÄ  a  :  G,  a‚Åª¬π  ‚ãÑ  a  =  ùüô \n```", "```py\nlemma  left_inv_eq_right_inv‚ÇÅ  {M  :  Type}  [Monoid‚ÇÅ  M]  {a  b  c  :  M}  (hba  :  b  ‚ãÑ  a  =  ùüô)  (hac  :  a  ‚ãÑ  c  =  ùüô)  :  b  =  c  :=  by\n  rw  [‚Üê  DiaOneClass‚ÇÅ.one_dia  c,  ‚Üê  hba,  Semigroup‚ÇÅ.dia_assoc,  hac,  DiaOneClass‚ÇÅ.dia_one  b] \n```", "```py\nexport  DiaOneClass‚ÇÅ  (one_dia  dia_one)\nexport  Semigroup‚ÇÅ  (dia_assoc)\nexport  Group‚ÇÅ  (inv_dia) \n```", "```py\nexample  {M  :  Type}  [Monoid‚ÇÅ  M]  {a  b  c  :  M}  (hba  :  b  ‚ãÑ  a  =  ùüô)  (hac  :  a  ‚ãÑ  c  =  ùüô)  :  b  =  c  :=  by\n  rw  [‚Üê  one_dia  c,  ‚Üê  hba,  dia_assoc,  hac,  dia_one  b] \n```", "```py\nlemma  inv_eq_of_dia  [Group‚ÇÅ  G]  {a  b  :  G}  (h  :  a  ‚ãÑ  b  =  ùüô)  :  a‚Åª¬π  =  b  :=\n  sorry\n\nlemma  dia_inv  [Group‚ÇÅ  G]  (a  :  G)  :  a  ‚ãÑ  a‚Åª¬π  =  ùüô  :=\n  sorry \n```", "```py\nclass  AddSemigroup‚ÇÉ  (Œ±  :  Type)  extends  Add  Œ±  where\n  /-- Addition is associative -/\n  add_assoc‚ÇÉ  :  ‚àÄ  a  b  c  :  Œ±,  a  +  b  +  c  =  a  +  (b  +  c)\n\n@[to_additive  AddSemigroup‚ÇÉ]\nclass  Semigroup‚ÇÉ  (Œ±  :  Type)  extends  Mul  Œ±  where\n  /-- Multiplication is associative -/\n  mul_assoc‚ÇÉ  :  ‚àÄ  a  b  c  :  Œ±,  a  *  b  *  c  =  a  *  (b  *  c)\n\nclass  AddMonoid‚ÇÉ  (Œ±  :  Type)  extends  AddSemigroup‚ÇÉ  Œ±,  AddZeroClass  Œ±\n\n@[to_additive  AddMonoid‚ÇÉ]\nclass  Monoid‚ÇÉ  (Œ±  :  Type)  extends  Semigroup‚ÇÉ  Œ±,  MulOneClass  Œ±\n\nexport  Semigroup‚ÇÉ  (mul_assoc‚ÇÉ)\nexport  AddSemigroup‚ÇÉ  (add_assoc‚ÇÉ)\n\nwhatsnew  in\n@[to_additive]\nlemma  left_inv_eq_right_inv'  {M  :  Type}  [Monoid‚ÇÉ  M]  {a  b  c  :  M}  (hba  :  b  *  a  =  1)  (hac  :  a  *  c  =  1)  :  b  =  c  :=  by\n  rw  [‚Üê  one_mul  c,  ‚Üê  hba,  mul_assoc‚ÇÉ,  hac,  mul_one  b]\n\n#check  left_neg_eq_right_neg' \n```", "```py\nclass  AddCommSemigroup‚ÇÉ  (Œ±  :  Type)  extends  AddSemigroup‚ÇÉ  Œ±  where\n  add_comm  :  ‚àÄ  a  b  :  Œ±,  a  +  b  =  b  +  a\n\n@[to_additive  AddCommSemigroup‚ÇÉ]\nclass  CommSemigroup‚ÇÉ  (Œ±  :  Type)  extends  Semigroup‚ÇÉ  Œ±  where\n  mul_comm  :  ‚àÄ  a  b  :  Œ±,  a  *  b  =  b  *  a\n\nclass  AddCommMonoid‚ÇÉ  (Œ±  :  Type)  extends  AddMonoid‚ÇÉ  Œ±,  AddCommSemigroup‚ÇÉ  Œ±\n\n@[to_additive  AddCommMonoid‚ÇÉ]\nclass  CommMonoid‚ÇÉ  (Œ±  :  Type)  extends  Monoid‚ÇÉ  Œ±,  CommSemigroup‚ÇÉ  Œ±\n\nclass  AddGroup‚ÇÉ  (G  :  Type)  extends  AddMonoid‚ÇÉ  G,  Neg  G  where\n  neg_add  :  ‚àÄ  a  :  G,  -a  +  a  =  0\n\n@[to_additive  AddGroup‚ÇÉ]\nclass  Group‚ÇÉ  (G  :  Type)  extends  Monoid‚ÇÉ  G,  Inv  G  where\n  inv_mul  :  ‚àÄ  a  :  G,  a‚Åª¬π  *  a  =  1 \n```", "```py\nattribute  [simp]  Group‚ÇÉ.inv_mul  AddGroup‚ÇÉ.neg_add \n```", "```py\n@[to_additive]\nlemma  inv_eq_of_mul  [Group‚ÇÉ  G]  {a  b  :  G}  (h  :  a  *  b  =  1)  :  a‚Åª¬π  =  b  :=\n  sorry \n```", "```py\n@[to_additive  (attr  :=  simp)]\nlemma  Group‚ÇÉ.mul_inv  {G  :  Type}  [Group‚ÇÉ  G]  {a  :  G}  :  a  *  a‚Åª¬π  =  1  :=  by\n  sorry\n\n@[to_additive]\nlemma  mul_left_cancel‚ÇÉ  {G  :  Type}  [Group‚ÇÉ  G]  {a  b  c  :  G}  (h  :  a  *  b  =  a  *  c)  :  b  =  c  :=  by\n  sorry\n\n@[to_additive]\nlemma  mul_right_cancel‚ÇÉ  {G  :  Type}  [Group‚ÇÉ  G]  {a  b  c  :  G}  (h  :  b*a  =  c*a)  :  b  =  c  :=  by\n  sorry\n\nclass  AddCommGroup‚ÇÉ  (G  :  Type)  extends  AddGroup‚ÇÉ  G,  AddCommMonoid‚ÇÉ  G\n\n@[to_additive  AddCommGroup‚ÇÉ]\nclass  CommGroup‚ÇÉ  (G  :  Type)  extends  Group‚ÇÉ  G,  CommMonoid‚ÇÉ  G \n```", "```py\nclass  Ring‚ÇÉ  (R  :  Type)  extends  AddGroup‚ÇÉ  R,  Monoid‚ÇÉ  R,  MulZeroClass  R  where\n  /-- Multiplication is left distributive over addition -/\n  left_distrib  :  ‚àÄ  a  b  c  :  R,  a  *  (b  +  c)  =  a  *  b  +  a  *  c\n  /-- Multiplication is right distributive over addition -/\n  right_distrib  :  ‚àÄ  a  b  c  :  R,  (a  +  b)  *  c  =  a  *  c  +  b  *  c\n\ninstance  {R  :  Type}  [Ring‚ÇÉ  R]  :  AddCommGroup‚ÇÉ  R  :=\n{  add_comm  :=  by\n  sorry  } \n```", "```py\ninstance  :  Ring‚ÇÉ  ‚Ñ§  where\n  add  :=  (¬∑  +  ¬∑)\n  add_assoc‚ÇÉ  :=  add_assoc\n  zero  :=  0\n  zero_add  :=  by  simp\n  add_zero  :=  by  simp\n  neg  :=  (-  ¬∑)\n  neg_add  :=  by  simp\n  mul  :=  (¬∑  *  ¬∑)\n  mul_assoc‚ÇÉ  :=  mul_assoc\n  one  :=  1\n  one_mul  :=  by  simp\n  mul_one  :=  by  simp\n  zero_mul  :=  by  simp\n  mul_zero  :=  by  simp\n  left_distrib  :=  Int.mul_add\n  right_distrib  :=  Int.add_mul \n```", "```py\nclass  LE‚ÇÅ  (Œ±  :  Type)  where\n  /-- The Less-or-Equal relation. -/\n  le  :  Œ±  ‚Üí  Œ±  ‚Üí  Prop\n\n@[inherit_doc]  infix:50  \" ‚â§‚ÇÅ \"  =>  LE‚ÇÅ.le\n\nclass  Preorder‚ÇÅ  (Œ±  :  Type)\n\nclass  PartialOrder‚ÇÅ  (Œ±  :  Type)\n\nclass  OrderedCommMonoid‚ÇÅ  (Œ±  :  Type)\n\ninstance  :  OrderedCommMonoid‚ÇÅ  ‚Ñï  where \n```", "```py\nclass  SMul‚ÇÉ  (Œ±  :  Type)  (Œ≤  :  Type)  where\n  /-- Scalar multiplication -/\n  smul  :  Œ±  ‚Üí  Œ≤  ‚Üí  Œ≤\n\ninfixr:73  \" ‚Ä¢ \"  =>  SMul‚ÇÉ.smul \n```", "```py\nclass  Module‚ÇÅ  (R  :  Type)  [Ring‚ÇÉ  R]  (M  :  Type)  [AddCommGroup‚ÇÉ  M]  extends  SMul‚ÇÉ  R  M  where\n  zero_smul  :  ‚àÄ  m  :  M,  (0  :  R)  ‚Ä¢  m  =  0\n  one_smul  :  ‚àÄ  m  :  M,  (1  :  R)  ‚Ä¢  m  =  m\n  mul_smul  :  ‚àÄ  (a  b  :  R)  (m  :  M),  (a  *  b)  ‚Ä¢  m  =  a  ‚Ä¢  b  ‚Ä¢  m\n  add_smul  :  ‚àÄ  (a  b  :  R)  (m  :  M),  (a  +  b)  ‚Ä¢  m  =  a  ‚Ä¢  m  +  b  ‚Ä¢  m\n  smul_add  :  ‚àÄ  (a  :  R)  (m  n  :  M),  a  ‚Ä¢  (m  +  n)  =  a  ‚Ä¢  m  +  a  ‚Ä¢  n \n```", "```py\ninstance  selfModule  (R  :  Type)  [Ring‚ÇÉ  R]  :  Module‚ÇÅ  R  R  where\n  smul  :=  fun  r  s  ‚Ü¶  r*s\n  zero_smul  :=  zero_mul\n  one_smul  :=  one_mul\n  mul_smul  :=  mul_assoc‚ÇÉ\n  add_smul  :=  Ring‚ÇÉ.right_distrib\n  smul_add  :=  Ring‚ÇÉ.left_distrib \n```", "```py\ndef  nsmul‚ÇÅ  {M  :  Type*}  [Zero  M]  [Add  M]  :  ‚Ñï  ‚Üí  M  ‚Üí  M\n  |  0,  _  =>  0\n  |  n  +  1,  a  =>  a  +  nsmul‚ÇÅ  n  a\n\ndef  zsmul‚ÇÅ  {M  :  Type*}  [Zero  M]  [Add  M]  [Neg  M]  :  ‚Ñ§  ‚Üí  M  ‚Üí  M\n  |  Int.ofNat  n,  a  =>  nsmul‚ÇÅ  n  a\n  |  Int.negSucc  n,  a  =>  -nsmul‚ÇÅ  n.succ  a \n```", "```py\ninstance  abGrpModule  (A  :  Type)  [AddCommGroup‚ÇÉ  A]  :  Module‚ÇÅ  ‚Ñ§  A  where\n  smul  :=  zsmul‚ÇÅ\n  zero_smul  :=  sorry\n  one_smul  :=  sorry\n  mul_smul  :=  sorry\n  add_smul  :=  sorry\n  smul_add  :=  sorry \n```", "```py\n#synth  Module‚ÇÅ  ‚Ñ§  ‚Ñ§  -- abGrpModule ‚Ñ§ \n```", "```py\nclass  AddMonoid‚ÇÑ  (M  :  Type)  extends  AddSemigroup‚ÇÉ  M,  AddZeroClass  M  where\n  /-- Multiplication by a natural number. -/\n  nsmul  :  ‚Ñï  ‚Üí  M  ‚Üí  M  :=  nsmul‚ÇÅ\n  /-- Multiplication by `(0 : ‚Ñï)` gives `0`. -/\n  nsmul_zero  :  ‚àÄ  x,  nsmul  0  x  =  0  :=  by  intros;  rfl\n  /-- Multiplication by `(n + 1 : ‚Ñï)` behaves as expected. -/\n  nsmul_succ  :  ‚àÄ  (n  :  ‚Ñï)  (x),  nsmul  (n  +  1)  x  =  x  +  nsmul  n  x  :=  by  intros;  rfl\n\ninstance  mySMul  {M  :  Type}  [AddMonoid‚ÇÑ  M]  :  SMul  ‚Ñï  M  :=  ‚ü®AddMonoid‚ÇÑ.nsmul‚ü© \n```", "```py\ninstance  (M  N  :  Type)  [AddMonoid‚ÇÑ  M]  [AddMonoid‚ÇÑ  N]  :  AddMonoid‚ÇÑ  (M  √ó  N)  where\n  add  :=  fun  p  q  ‚Ü¶  (p.1  +  q.1,  p.2  +  q.2)\n  add_assoc‚ÇÉ  :=  fun  a  b  c  ‚Ü¶  by  ext  <;>  apply  add_assoc‚ÇÉ\n  zero  :=  (0,  0)\n  zero_add  :=  fun  a  ‚Ü¶  by  ext  <;>  apply  zero_add\n  add_zero  :=  fun  a  ‚Ü¶  by  ext  <;>  apply  add_zero \n```", "```py\ninstance  :  AddMonoid‚ÇÑ  ‚Ñ§  where\n  add  :=  (¬∑  +  ¬∑)\n  add_assoc‚ÇÉ  :=  Int.add_assoc\n  zero  :=  0\n  zero_add  :=  Int.zero_add\n  add_zero  :=  Int.add_zero\n  nsmul  :=  fun  n  m  ‚Ü¶  (n  :  ‚Ñ§)  *  m\n  nsmul_zero  :=  Int.zero_mul\n  nsmul_succ  :=  fun  n  m  ‚Ü¶  show  (n  +  1  :  ‚Ñ§)  *  m  =  m  +  n  *  m\n  by  rw  [Int.add_mul,  Int.add_comm,  Int.one_mul] \n```", "```py\nexample  (n  :  ‚Ñï)  (m  :  ‚Ñ§)  :  SMul.smul  (self  :=  mySMul)  n  m  =  n  *  m  :=  rfl \n```", "```py\ndef  isMonoidHom‚ÇÅ  [Monoid  G]  [Monoid  H]  (f  :  G  ‚Üí  H)  :  Prop  :=\n  f  1  =  1  ‚àß  ‚àÄ  g  g',  f  (g  *  g')  =  f  g  *  f  g' \n```", "```py\nstructure  isMonoidHom‚ÇÇ  [Monoid  G]  [Monoid  H]  (f  :  G  ‚Üí  H)  :  Prop  where\n  map_one  :  f  1  =  1\n  map_mul  :  ‚àÄ  g  g',  f  (g  *  g')  =  f  g  *  f  g' \n```", "```py\nexample  :  Continuous  (id  :  ‚Ñù  ‚Üí  ‚Ñù)  :=  continuous_id \n```", "```py\n@[ext]\nstructure  MonoidHom‚ÇÅ  (G  H  :  Type)  [Monoid  G]  [Monoid  H]  where\n  toFun  :  G  ‚Üí  H\n  map_one  :  toFun  1  =  1\n  map_mul  :  ‚àÄ  g  g',  toFun  (g  *  g')  =  toFun  g  *  toFun  g' \n```", "```py\ninstance  [Monoid  G]  [Monoid  H]  :  CoeFun  (MonoidHom‚ÇÅ  G  H)  (fun  _  ‚Ü¶  G  ‚Üí  H)  where\n  coe  :=  MonoidHom‚ÇÅ.toFun\n\nattribute  [coe]  MonoidHom‚ÇÅ.toFun \n```", "```py\nexample  [Monoid  G]  [Monoid  H]  (f  :  MonoidHom‚ÇÅ  G  H)  :  f  1  =  1  :=  f.map_one \n```", "```py\n@[ext]\nstructure  AddMonoidHom‚ÇÅ  (G  H  :  Type)  [AddMonoid  G]  [AddMonoid  H]  where\n  toFun  :  G  ‚Üí  H\n  map_zero  :  toFun  0  =  0\n  map_add  :  ‚àÄ  g  g',  toFun  (g  +  g')  =  toFun  g  +  toFun  g'\n\ninstance  [AddMonoid  G]  [AddMonoid  H]  :  CoeFun  (AddMonoidHom‚ÇÅ  G  H)  (fun  _  ‚Ü¶  G  ‚Üí  H)  where\n  coe  :=  AddMonoidHom‚ÇÅ.toFun\n\nattribute  [coe]  AddMonoidHom‚ÇÅ.toFun\n\n@[ext]\nstructure  RingHom‚ÇÅ  (R  S  :  Type)  [Ring  R]  [Ring  S]  extends  MonoidHom‚ÇÅ  R  S,  AddMonoidHom‚ÇÅ  R  S \n```", "```py\nclass  MonoidHomClass‚ÇÅ  (F  :  Type)  (M  N  :  Type)  [Monoid  M]  [Monoid  N]  where\n  toFun  :  F  ‚Üí  M  ‚Üí  N\n  map_one  :  ‚àÄ  f  :  F,  toFun  f  1  =  1\n  map_mul  :  ‚àÄ  f  g  g',  toFun  f  (g  *  g')  =  toFun  f  g  *  toFun  f  g' \n```", "```py\ndef  badInst  [Monoid  M]  [Monoid  N]  [MonoidHomClass‚ÇÅ  F  M  N]  :  CoeFun  F  (fun  _  ‚Ü¶  M  ‚Üí  N)  where\n  coe  :=  MonoidHomClass‚ÇÅ.toFun \n```", "```py\nclass  MonoidHomClass‚ÇÇ  (F  :  Type)  (M  N  :  outParam  Type)  [Monoid  M]  [Monoid  N]  where\n  toFun  :  F  ‚Üí  M  ‚Üí  N\n  map_one  :  ‚àÄ  f  :  F,  toFun  f  1  =  1\n  map_mul  :  ‚àÄ  f  g  g',  toFun  f  (g  *  g')  =  toFun  f  g  *  toFun  f  g'\n\ninstance  [Monoid  M]  [Monoid  N]  [MonoidHomClass‚ÇÇ  F  M  N]  :  CoeFun  F  (fun  _  ‚Ü¶  M  ‚Üí  N)  where\n  coe  :=  MonoidHomClass‚ÇÇ.toFun\n\nattribute  [coe]  MonoidHomClass‚ÇÇ.toFun \n```", "```py\ninstance  (M  N  :  Type)  [Monoid  M]  [Monoid  N]  :  MonoidHomClass‚ÇÇ  (MonoidHom‚ÇÅ  M  N)  M  N  where\n  toFun  :=  MonoidHom‚ÇÅ.toFun\n  map_one  :=  fun  f  ‚Ü¶  f.map_one\n  map_mul  :=  fun  f  ‚Ü¶  f.map_mul\n\ninstance  (R  S  :  Type)  [Ring  R]  [Ring  S]  :  MonoidHomClass‚ÇÇ  (RingHom‚ÇÅ  R  S)  R  S  where\n  toFun  :=  fun  f  ‚Ü¶  f.toMonoidHom‚ÇÅ.toFun\n  map_one  :=  fun  f  ‚Ü¶  f.toMonoidHom‚ÇÅ.map_one\n  map_mul  :=  fun  f  ‚Ü¶  f.toMonoidHom‚ÇÅ.map_mul \n```", "```py\nlemma  map_inv_of_inv  [Monoid  M]  [Monoid  N]  [MonoidHomClass‚ÇÇ  F  M  N]  (f  :  F)  {m  m'  :  M}  (h  :  m*m'  =  1)  :\n  f  m  *  f  m'  =  1  :=  by\n  rw  [‚Üê  MonoidHomClass‚ÇÇ.map_mul,  h,  MonoidHomClass‚ÇÇ.map_one]\n\nexample  [Monoid  M]  [Monoid  N]  (f  :  MonoidHom‚ÇÅ  M  N)  {m  m'  :  M}  (h  :  m*m'  =  1)  :  f  m  *  f  m'  =  1  :=\nmap_inv_of_inv  f  h\n\nexample  [Ring  R]  [Ring  S]  (f  :  RingHom‚ÇÅ  R  S)  {r  r'  :  R}  (h  :  r*r'  =  1)  :  f  r  *  f  r'  =  1  :=\nmap_inv_of_inv  f  h \n```", "```py\nclass  MonoidHomClass‚ÇÉ  (F  :  Type)  (M  N  :  outParam  Type)  [Monoid  M]  [Monoid  N]  extends\n  DFunLike  F  M  (fun  _  ‚Ü¶  N)  where\n  map_one  :  ‚àÄ  f  :  F,  f  1  =  1\n  map_mul  :  ‚àÄ  (f  :  F)  g  g',  f  (g  *  g')  =  f  g  *  f  g'\n\ninstance  (M  N  :  Type)  [Monoid  M]  [Monoid  N]  :  MonoidHomClass‚ÇÉ  (MonoidHom‚ÇÅ  M  N)  M  N  where\n  coe  :=  MonoidHom‚ÇÅ.toFun\n  coe_injective'  _  _  :=  MonoidHom‚ÇÅ.ext\n  map_one  :=  MonoidHom‚ÇÅ.map_one\n  map_mul  :=  MonoidHom‚ÇÅ.map_mul \n```", "```py\n@[ext]\nstructure  OrderPresHom  (Œ±  Œ≤  :  Type)  [LE  Œ±]  [LE  Œ≤]  where\n  toFun  :  Œ±  ‚Üí  Œ≤\n  le_of_le  :  ‚àÄ  a  a',  a  ‚â§  a'  ‚Üí  toFun  a  ‚â§  toFun  a'\n\n@[ext]\nstructure  OrderPresMonoidHom  (M  N  :  Type)  [Monoid  M]  [LE  M]  [Monoid  N]  [LE  N]  extends\nMonoidHom‚ÇÅ  M  N,  OrderPresHom  M  N\n\nclass  OrderPresHomClass  (F  :  Type)  (Œ±  Œ≤  :  outParam  Type)  [LE  Œ±]  [LE  Œ≤]\n\ninstance  (Œ±  Œ≤  :  Type)  [LE  Œ±]  [LE  Œ≤]  :  OrderPresHomClass  (OrderPresHom  Œ±  Œ≤)  Œ±  Œ≤  where\n\ninstance  (Œ±  Œ≤  :  Type)  [LE  Œ±]  [Monoid  Œ±]  [LE  Œ≤]  [Monoid  Œ≤]  :\n  OrderPresHomClass  (OrderPresMonoidHom  Œ±  Œ≤)  Œ±  Œ≤  where\n\ninstance  (Œ±  Œ≤  :  Type)  [LE  Œ±]  [Monoid  Œ±]  [LE  Œ≤]  [Monoid  Œ≤]  :\n  MonoidHomClass‚ÇÉ  (OrderPresMonoidHom  Œ±  Œ≤)  Œ±  Œ≤\n  :=  sorry \n```", "```py\n@[ext]\nstructure  Submonoid‚ÇÅ  (M  :  Type)  [Monoid  M]  where\n  /-- The carrier of a submonoid. -/\n  carrier  :  Set  M\n  /-- The product of two elements of a submonoid belongs to the submonoid. -/\n  mul_mem  {a  b}  :  a  ‚àà  carrier  ‚Üí  b  ‚àà  carrier  ‚Üí  a  *  b  ‚àà  carrier\n  /-- The unit element belongs to the submonoid. -/\n  one_mem  :  1  ‚àà  carrier\n\n/-- Submonoids in `M` can be seen as sets in `M`. -/\ninstance  [Monoid  M]  :  SetLike  (Submonoid‚ÇÅ  M)  M  where\n  coe  :=  Submonoid‚ÇÅ.carrier\n  coe_injective'  _  _  :=  Submonoid‚ÇÅ.ext \n```", "```py\nexample  [Monoid  M]  (N  :  Submonoid‚ÇÅ  M)  :  1  ‚àà  N  :=  N.one_mem\n\nexample  [Monoid  M]  (N  :  Submonoid‚ÇÅ  M)  (Œ±  :  Type)  (f  :  M  ‚Üí  Œ±)  :=  f  ''  N \n```", "```py\nexample  [Monoid  M]  (N  :  Submonoid‚ÇÅ  M)  (x  :  N)  :  (x  :  M)  ‚àà  N  :=  x.property \n```", "```py\ninstance  SubMonoid‚ÇÅMonoid  [Monoid  M]  (N  :  Submonoid‚ÇÅ  M)  :  Monoid  N  where\n  mul  :=  fun  x  y  ‚Ü¶  ‚ü®x*y,  N.mul_mem  x.property  y.property‚ü©\n  mul_assoc  :=  fun  x  y  z  ‚Ü¶  SetCoe.ext  (mul_assoc  (x  :  M)  y  z)\n  one  :=  ‚ü®1,  N.one_mem‚ü©\n  one_mul  :=  fun  x  ‚Ü¶  SetCoe.ext  (one_mul  (x  :  M))\n  mul_one  :=  fun  x  ‚Ü¶  SetCoe.ext  (mul_one  (x  :  M)) \n```", "```py\nexample  [Monoid  M]  (N  :  Submonoid‚ÇÅ  M)  :  Monoid  N  where\n  mul  :=  fun  ‚ü®x,  hx‚ü©  ‚ü®y,  hy‚ü©  ‚Ü¶  ‚ü®x*y,  N.mul_mem  hx  hy‚ü©\n  mul_assoc  :=  fun  ‚ü®x,  _‚ü©  ‚ü®y,  _‚ü©  ‚ü®z,  _‚ü©  ‚Ü¶  SetCoe.ext  (mul_assoc  x  y  z)\n  one  :=  ‚ü®1,  N.one_mem‚ü©\n  one_mul  :=  fun  ‚ü®x,  _‚ü©  ‚Ü¶  SetCoe.ext  (one_mul  x)\n  mul_one  :=  fun  ‚ü®x,  _‚ü©  ‚Ü¶  SetCoe.ext  (mul_one  x) \n```", "```py\nclass  SubmonoidClass‚ÇÅ  (S  :  Type)  (M  :  Type)  [Monoid  M]  [SetLike  S  M]  :  Prop  where\n  mul_mem  :  ‚àÄ  (s  :  S)  {a  b  :  M},  a  ‚àà  s  ‚Üí  b  ‚àà  s  ‚Üí  a  *  b  ‚àà  s\n  one_mem  :  ‚àÄ  s  :  S,  1  ‚àà  s\n\ninstance  [Monoid  M]  :  SubmonoidClass‚ÇÅ  (Submonoid‚ÇÅ  M)  M  where\n  mul_mem  :=  Submonoid‚ÇÅ.mul_mem\n  one_mem  :=  Submonoid‚ÇÅ.one_mem \n```", "```py\ninstance  [Monoid  M]  :  Min  (Submonoid‚ÇÅ  M)  :=\n  ‚ü®fun  S‚ÇÅ  S‚ÇÇ  ‚Ü¶\n  {  carrier  :=  S‚ÇÅ  ‚à©  S‚ÇÇ\n  one_mem  :=  ‚ü®S‚ÇÅ.one_mem,  S‚ÇÇ.one_mem‚ü©\n  mul_mem  :=  fun  ‚ü®hx,  hx'‚ü©  ‚ü®hy,  hy'‚ü©  ‚Ü¶  ‚ü®S‚ÇÅ.mul_mem  hx  hy,  S‚ÇÇ.mul_mem  hx'  hy'‚ü©  }‚ü© \n```", "```py\nexample  [Monoid  M]  (N  P  :  Submonoid‚ÇÅ  M)  :  Submonoid‚ÇÅ  M  :=  N  ‚äì  P \n```", "```py\ndef  Submonoid.Setoid  [CommMonoid  M]  (N  :  Submonoid  M)  :  Setoid  M  where\n  r  :=  fun  x  y  ‚Ü¶  ‚àÉ  w  ‚àà  N,  ‚àÉ  z  ‚àà  N,  x*w  =  y*z\n  iseqv  :=  {\n  refl  :=  fun  x  ‚Ü¶  ‚ü®1,  N.one_mem,  1,  N.one_mem,  rfl‚ü©\n  symm  :=  fun  ‚ü®w,  hw,  z,  hz,  h‚ü©  ‚Ü¶  ‚ü®z,  hz,  w,  hw,  h.symm‚ü©\n  trans  :=  by\n  sorry\n  }\n\ninstance  [CommMonoid  M]  :  HasQuotient  M  (Submonoid  M)  where\n  quotient'  :=  fun  N  ‚Ü¶  Quotient  N.Setoid\n\ndef  QuotientMonoid.mk  [CommMonoid  M]  (N  :  Submonoid  M)  :  M  ‚Üí  M  ‚ß∏  N  :=  Quotient.mk  N.Setoid\n\ninstance  [CommMonoid  M]  (N  :  Submonoid  M)  :  Monoid  (M  ‚ß∏  N)  where\n  mul  :=  Quotient.map‚ÇÇ  (¬∑  *  ¬∑)  (by\n  sorry\n  )\n  mul_assoc  :=  by\n  sorry\n  one  :=  QuotientMonoid.mk  N  1\n  one_mul  :=  by\n  sorry\n  mul_one  :=  by\n  sorry \n```", "```py\nclass  One‚ÇÅ  (Œ±  :  Type)  where\n  /-- The element one -/\n  one  :  Œ± \n```", "```py\n#check  One‚ÇÅ.one  -- One‚ÇÅ.one {Œ± : Type} [self : One‚ÇÅ Œ±] : Œ±\n\n@[class]  structure  One‚ÇÇ  (Œ±  :  Type)  where\n  /-- The element one -/\n  one  :  Œ±\n\n#check  One‚ÇÇ.one \n```", "```py\nexample  (Œ±  :  Type)  [One‚ÇÅ  Œ±]  :  Œ±  :=  One‚ÇÅ.one \n```", "```py\nexample  (Œ±  :  Type)  [One‚ÇÅ  Œ±]  :=  (One‚ÇÅ.one  :  Œ±) \n```", "```py\n@[inherit_doc]\nnotation  \"ùüô\"  =>  One‚ÇÅ.one\n\nexample  {Œ±  :  Type}  [One‚ÇÅ  Œ±]  :  Œ±  :=  ùüô\n\nexample  {Œ±  :  Type}  [One‚ÇÅ  Œ±]  :  (ùüô  :  Œ±)  =  ùüô  :=  rfl \n```", "```py\nclass  Dia‚ÇÅ  (Œ±  :  Type)  where\n  dia  :  Œ±  ‚Üí  Œ±  ‚Üí  Œ±\n\ninfixl:70  \" ‚ãÑ \"  =>  Dia‚ÇÅ.dia \n```", "```py\nclass  Semigroup‚ÇÄ  (Œ±  :  Type)  where\n  toDia‚ÇÅ  :  Dia‚ÇÅ  Œ±\n  /-- Diamond is associative -/\n  dia_assoc  :  ‚àÄ  a  b  c  :  Œ±,  a  ‚ãÑ  b  ‚ãÑ  c  =  a  ‚ãÑ  (b  ‚ãÑ  c) \n```", "```py\nattribute  [instance]  Semigroup‚ÇÄ.toDia‚ÇÅ\n\nexample  {Œ±  :  Type}  [Semigroup‚ÇÄ  Œ±]  (a  b  :  Œ±)  :  Œ±  :=  a  ‚ãÑ  b \n```", "```py\nclass  Semigroup‚ÇÅ  (Œ±  :  Type)  extends  toDia‚ÇÅ  :  Dia‚ÇÅ  Œ±  where\n  /-- Diamond is associative -/\n  dia_assoc  :  ‚àÄ  a  b  c  :  Œ±,  a  ‚ãÑ  b  ‚ãÑ  c  =  a  ‚ãÑ  (b  ‚ãÑ  c)\n\nexample  {Œ±  :  Type}  [Semigroup‚ÇÅ  Œ±]  (a  b  :  Œ±)  :  Œ±  :=  a  ‚ãÑ  b \n```", "```py\nclass  Semigroup‚ÇÇ  (Œ±  :  Type)  extends  Dia‚ÇÅ  Œ±  where\n  /-- Diamond is associative -/\n  dia_assoc  :  ‚àÄ  a  b  c  :  Œ±,  a  ‚ãÑ  b  ‚ãÑ  c  =  a  ‚ãÑ  (b  ‚ãÑ  c) \n```", "```py\nclass  DiaOneClass‚ÇÅ  (Œ±  :  Type)  extends  One‚ÇÅ  Œ±,  Dia‚ÇÅ  Œ±  where\n  /-- One is a left neutral element for diamond. -/\n  one_dia  :  ‚àÄ  a  :  Œ±,  ùüô  ‚ãÑ  a  =  a\n  /-- One is a right neutral element for diamond -/\n  dia_one  :  ‚àÄ  a  :  Œ±,  a  ‚ãÑ  ùüô  =  a \n```", "```py\nset_option  trace.Meta.synthInstance  true  in\nexample  {Œ±  :  Type}  [DiaOneClass‚ÇÅ  Œ±]  (a  b  :  Œ±)  :  Prop  :=  a  ‚ãÑ  b  =  ùüô \n```", "```py\nclass  Monoid‚ÇÅ  (Œ±  :  Type)  extends  Semigroup‚ÇÅ  Œ±,  DiaOneClass‚ÇÅ  Œ± \n```", "```py\nclass  Monoid‚ÇÇ  (Œ±  :  Type)  where\n  toSemigroup‚ÇÅ  :  Semigroup‚ÇÅ  Œ±\n  toDiaOneClass‚ÇÅ  :  DiaOneClass‚ÇÅ  Œ± \n```", "```py\nexample  {Œ±  :  Type}  [Monoid‚ÇÅ  Œ±]  :\n  (Monoid‚ÇÅ.toSemigroup‚ÇÅ.toDia‚ÇÅ.dia  :  Œ±  ‚Üí  Œ±  ‚Üí  Œ±)  =  Monoid‚ÇÅ.toDiaOneClass‚ÇÅ.toDia‚ÇÅ.dia  :=  rfl \n```", "```py\n/- Monoid‚ÇÇ.mk {Œ± : Type} (toSemigroup‚ÇÅ : Semigroup‚ÇÅ Œ±) (toDiaOneClass‚ÇÅ : DiaOneClass‚ÇÅ Œ±) : Monoid‚ÇÇ Œ± -/\n#check  Monoid‚ÇÇ.mk\n\n/- Monoid‚ÇÅ.mk {Œ± : Type} [toSemigroup‚ÇÅ : Semigroup‚ÇÅ Œ±] [toOne‚ÇÅ : One‚ÇÅ Œ±] (one_dia : ‚àÄ (a : Œ±), ùüô ‚ãÑ a = a) (dia_one : ‚àÄ (a : Œ±), a ‚ãÑ ùüô = a) : Monoid‚ÇÅ Œ± -/\n#check  Monoid‚ÇÅ.mk \n```", "```py\n#check  Monoid‚ÇÅ.toSemigroup‚ÇÅ\n#check  Monoid‚ÇÅ.toDiaOneClass‚ÇÅ \n```", "```py\nclass  Inv‚ÇÅ  (Œ±  :  Type)  where\n  /-- The inversion function -/\n  inv  :  Œ±  ‚Üí  Œ±\n\n@[inherit_doc]\npostfix:max  \"‚Åª¬π\"  =>  Inv‚ÇÅ.inv\n\nclass  Group‚ÇÅ  (G  :  Type)  extends  Monoid‚ÇÅ  G,  Inv‚ÇÅ  G  where\n  inv_dia  :  ‚àÄ  a  :  G,  a‚Åª¬π  ‚ãÑ  a  =  ùüô \n```", "```py\nlemma  left_inv_eq_right_inv‚ÇÅ  {M  :  Type}  [Monoid‚ÇÅ  M]  {a  b  c  :  M}  (hba  :  b  ‚ãÑ  a  =  ùüô)  (hac  :  a  ‚ãÑ  c  =  ùüô)  :  b  =  c  :=  by\n  rw  [‚Üê  DiaOneClass‚ÇÅ.one_dia  c,  ‚Üê  hba,  Semigroup‚ÇÅ.dia_assoc,  hac,  DiaOneClass‚ÇÅ.dia_one  b] \n```", "```py\nexport  DiaOneClass‚ÇÅ  (one_dia  dia_one)\nexport  Semigroup‚ÇÅ  (dia_assoc)\nexport  Group‚ÇÅ  (inv_dia) \n```", "```py\nexample  {M  :  Type}  [Monoid‚ÇÅ  M]  {a  b  c  :  M}  (hba  :  b  ‚ãÑ  a  =  ùüô)  (hac  :  a  ‚ãÑ  c  =  ùüô)  :  b  =  c  :=  by\n  rw  [‚Üê  one_dia  c,  ‚Üê  hba,  dia_assoc,  hac,  dia_one  b] \n```", "```py\nlemma  inv_eq_of_dia  [Group‚ÇÅ  G]  {a  b  :  G}  (h  :  a  ‚ãÑ  b  =  ùüô)  :  a‚Åª¬π  =  b  :=\n  sorry\n\nlemma  dia_inv  [Group‚ÇÅ  G]  (a  :  G)  :  a  ‚ãÑ  a‚Åª¬π  =  ùüô  :=\n  sorry \n```", "```py\nclass  AddSemigroup‚ÇÉ  (Œ±  :  Type)  extends  Add  Œ±  where\n  /-- Addition is associative -/\n  add_assoc‚ÇÉ  :  ‚àÄ  a  b  c  :  Œ±,  a  +  b  +  c  =  a  +  (b  +  c)\n\n@[to_additive  AddSemigroup‚ÇÉ]\nclass  Semigroup‚ÇÉ  (Œ±  :  Type)  extends  Mul  Œ±  where\n  /-- Multiplication is associative -/\n  mul_assoc‚ÇÉ  :  ‚àÄ  a  b  c  :  Œ±,  a  *  b  *  c  =  a  *  (b  *  c)\n\nclass  AddMonoid‚ÇÉ  (Œ±  :  Type)  extends  AddSemigroup‚ÇÉ  Œ±,  AddZeroClass  Œ±\n\n@[to_additive  AddMonoid‚ÇÉ]\nclass  Monoid‚ÇÉ  (Œ±  :  Type)  extends  Semigroup‚ÇÉ  Œ±,  MulOneClass  Œ±\n\nexport  Semigroup‚ÇÉ  (mul_assoc‚ÇÉ)\nexport  AddSemigroup‚ÇÉ  (add_assoc‚ÇÉ)\n\nwhatsnew  in\n@[to_additive]\nlemma  left_inv_eq_right_inv'  {M  :  Type}  [Monoid‚ÇÉ  M]  {a  b  c  :  M}  (hba  :  b  *  a  =  1)  (hac  :  a  *  c  =  1)  :  b  =  c  :=  by\n  rw  [‚Üê  one_mul  c,  ‚Üê  hba,  mul_assoc‚ÇÉ,  hac,  mul_one  b]\n\n#check  left_neg_eq_right_neg' \n```", "```py\nclass  AddCommSemigroup‚ÇÉ  (Œ±  :  Type)  extends  AddSemigroup‚ÇÉ  Œ±  where\n  add_comm  :  ‚àÄ  a  b  :  Œ±,  a  +  b  =  b  +  a\n\n@[to_additive  AddCommSemigroup‚ÇÉ]\nclass  CommSemigroup‚ÇÉ  (Œ±  :  Type)  extends  Semigroup‚ÇÉ  Œ±  where\n  mul_comm  :  ‚àÄ  a  b  :  Œ±,  a  *  b  =  b  *  a\n\nclass  AddCommMonoid‚ÇÉ  (Œ±  :  Type)  extends  AddMonoid‚ÇÉ  Œ±,  AddCommSemigroup‚ÇÉ  Œ±\n\n@[to_additive  AddCommMonoid‚ÇÉ]\nclass  CommMonoid‚ÇÉ  (Œ±  :  Type)  extends  Monoid‚ÇÉ  Œ±,  CommSemigroup‚ÇÉ  Œ±\n\nclass  AddGroup‚ÇÉ  (G  :  Type)  extends  AddMonoid‚ÇÉ  G,  Neg  G  where\n  neg_add  :  ‚àÄ  a  :  G,  -a  +  a  =  0\n\n@[to_additive  AddGroup‚ÇÉ]\nclass  Group‚ÇÉ  (G  :  Type)  extends  Monoid‚ÇÉ  G,  Inv  G  where\n  inv_mul  :  ‚àÄ  a  :  G,  a‚Åª¬π  *  a  =  1 \n```", "```py\nattribute  [simp]  Group‚ÇÉ.inv_mul  AddGroup‚ÇÉ.neg_add \n```", "```py\n@[to_additive]\nlemma  inv_eq_of_mul  [Group‚ÇÉ  G]  {a  b  :  G}  (h  :  a  *  b  =  1)  :  a‚Åª¬π  =  b  :=\n  sorry \n```", "```py\n@[to_additive  (attr  :=  simp)]\nlemma  Group‚ÇÉ.mul_inv  {G  :  Type}  [Group‚ÇÉ  G]  {a  :  G}  :  a  *  a‚Åª¬π  =  1  :=  by\n  sorry\n\n@[to_additive]\nlemma  mul_left_cancel‚ÇÉ  {G  :  Type}  [Group‚ÇÉ  G]  {a  b  c  :  G}  (h  :  a  *  b  =  a  *  c)  :  b  =  c  :=  by\n  sorry\n\n@[to_additive]\nlemma  mul_right_cancel‚ÇÉ  {G  :  Type}  [Group‚ÇÉ  G]  {a  b  c  :  G}  (h  :  b*a  =  c*a)  :  b  =  c  :=  by\n  sorry\n\nclass  AddCommGroup‚ÇÉ  (G  :  Type)  extends  AddGroup‚ÇÉ  G,  AddCommMonoid‚ÇÉ  G\n\n@[to_additive  AddCommGroup‚ÇÉ]\nclass  CommGroup‚ÇÉ  (G  :  Type)  extends  Group‚ÇÉ  G,  CommMonoid‚ÇÉ  G \n```", "```py\nclass  Ring‚ÇÉ  (R  :  Type)  extends  AddGroup‚ÇÉ  R,  Monoid‚ÇÉ  R,  MulZeroClass  R  where\n  /-- Multiplication is left distributive over addition -/\n  left_distrib  :  ‚àÄ  a  b  c  :  R,  a  *  (b  +  c)  =  a  *  b  +  a  *  c\n  /-- Multiplication is right distributive over addition -/\n  right_distrib  :  ‚àÄ  a  b  c  :  R,  (a  +  b)  *  c  =  a  *  c  +  b  *  c\n\ninstance  {R  :  Type}  [Ring‚ÇÉ  R]  :  AddCommGroup‚ÇÉ  R  :=\n{  add_comm  :=  by\n  sorry  } \n```", "```py\ninstance  :  Ring‚ÇÉ  ‚Ñ§  where\n  add  :=  (¬∑  +  ¬∑)\n  add_assoc‚ÇÉ  :=  add_assoc\n  zero  :=  0\n  zero_add  :=  by  simp\n  add_zero  :=  by  simp\n  neg  :=  (-  ¬∑)\n  neg_add  :=  by  simp\n  mul  :=  (¬∑  *  ¬∑)\n  mul_assoc‚ÇÉ  :=  mul_assoc\n  one  :=  1\n  one_mul  :=  by  simp\n  mul_one  :=  by  simp\n  zero_mul  :=  by  simp\n  mul_zero  :=  by  simp\n  left_distrib  :=  Int.mul_add\n  right_distrib  :=  Int.add_mul \n```", "```py\nclass  LE‚ÇÅ  (Œ±  :  Type)  where\n  /-- The Less-or-Equal relation. -/\n  le  :  Œ±  ‚Üí  Œ±  ‚Üí  Prop\n\n@[inherit_doc]  infix:50  \" ‚â§‚ÇÅ \"  =>  LE‚ÇÅ.le\n\nclass  Preorder‚ÇÅ  (Œ±  :  Type)\n\nclass  PartialOrder‚ÇÅ  (Œ±  :  Type)\n\nclass  OrderedCommMonoid‚ÇÅ  (Œ±  :  Type)\n\ninstance  :  OrderedCommMonoid‚ÇÅ  ‚Ñï  where \n```", "```py\nclass  SMul‚ÇÉ  (Œ±  :  Type)  (Œ≤  :  Type)  where\n  /-- Scalar multiplication -/\n  smul  :  Œ±  ‚Üí  Œ≤  ‚Üí  Œ≤\n\ninfixr:73  \" ‚Ä¢ \"  =>  SMul‚ÇÉ.smul \n```", "```py\nclass  Module‚ÇÅ  (R  :  Type)  [Ring‚ÇÉ  R]  (M  :  Type)  [AddCommGroup‚ÇÉ  M]  extends  SMul‚ÇÉ  R  M  where\n  zero_smul  :  ‚àÄ  m  :  M,  (0  :  R)  ‚Ä¢  m  =  0\n  one_smul  :  ‚àÄ  m  :  M,  (1  :  R)  ‚Ä¢  m  =  m\n  mul_smul  :  ‚àÄ  (a  b  :  R)  (m  :  M),  (a  *  b)  ‚Ä¢  m  =  a  ‚Ä¢  b  ‚Ä¢  m\n  add_smul  :  ‚àÄ  (a  b  :  R)  (m  :  M),  (a  +  b)  ‚Ä¢  m  =  a  ‚Ä¢  m  +  b  ‚Ä¢  m\n  smul_add  :  ‚àÄ  (a  :  R)  (m  n  :  M),  a  ‚Ä¢  (m  +  n)  =  a  ‚Ä¢  m  +  a  ‚Ä¢  n \n```", "```py\ninstance  selfModule  (R  :  Type)  [Ring‚ÇÉ  R]  :  Module‚ÇÅ  R  R  where\n  smul  :=  fun  r  s  ‚Ü¶  r*s\n  zero_smul  :=  zero_mul\n  one_smul  :=  one_mul\n  mul_smul  :=  mul_assoc‚ÇÉ\n  add_smul  :=  Ring‚ÇÉ.right_distrib\n  smul_add  :=  Ring‚ÇÉ.left_distrib \n```", "```py\ndef  nsmul‚ÇÅ  {M  :  Type*}  [Zero  M]  [Add  M]  :  ‚Ñï  ‚Üí  M  ‚Üí  M\n  |  0,  _  =>  0\n  |  n  +  1,  a  =>  a  +  nsmul‚ÇÅ  n  a\n\ndef  zsmul‚ÇÅ  {M  :  Type*}  [Zero  M]  [Add  M]  [Neg  M]  :  ‚Ñ§  ‚Üí  M  ‚Üí  M\n  |  Int.ofNat  n,  a  =>  nsmul‚ÇÅ  n  a\n  |  Int.negSucc  n,  a  =>  -nsmul‚ÇÅ  n.succ  a \n```", "```py\ninstance  abGrpModule  (A  :  Type)  [AddCommGroup‚ÇÉ  A]  :  Module‚ÇÅ  ‚Ñ§  A  where\n  smul  :=  zsmul‚ÇÅ\n  zero_smul  :=  sorry\n  one_smul  :=  sorry\n  mul_smul  :=  sorry\n  add_smul  :=  sorry\n  smul_add  :=  sorry \n```", "```py\n#synth  Module‚ÇÅ  ‚Ñ§  ‚Ñ§  -- abGrpModule ‚Ñ§ \n```", "```py\nclass  AddMonoid‚ÇÑ  (M  :  Type)  extends  AddSemigroup‚ÇÉ  M,  AddZeroClass  M  where\n  /-- Multiplication by a natural number. -/\n  nsmul  :  ‚Ñï  ‚Üí  M  ‚Üí  M  :=  nsmul‚ÇÅ\n  /-- Multiplication by `(0 : ‚Ñï)` gives `0`. -/\n  nsmul_zero  :  ‚àÄ  x,  nsmul  0  x  =  0  :=  by  intros;  rfl\n  /-- Multiplication by `(n + 1 : ‚Ñï)` behaves as expected. -/\n  nsmul_succ  :  ‚àÄ  (n  :  ‚Ñï)  (x),  nsmul  (n  +  1)  x  =  x  +  nsmul  n  x  :=  by  intros;  rfl\n\ninstance  mySMul  {M  :  Type}  [AddMonoid‚ÇÑ  M]  :  SMul  ‚Ñï  M  :=  ‚ü®AddMonoid‚ÇÑ.nsmul‚ü© \n```", "```py\ninstance  (M  N  :  Type)  [AddMonoid‚ÇÑ  M]  [AddMonoid‚ÇÑ  N]  :  AddMonoid‚ÇÑ  (M  √ó  N)  where\n  add  :=  fun  p  q  ‚Ü¶  (p.1  +  q.1,  p.2  +  q.2)\n  add_assoc‚ÇÉ  :=  fun  a  b  c  ‚Ü¶  by  ext  <;>  apply  add_assoc‚ÇÉ\n  zero  :=  (0,  0)\n  zero_add  :=  fun  a  ‚Ü¶  by  ext  <;>  apply  zero_add\n  add_zero  :=  fun  a  ‚Ü¶  by  ext  <;>  apply  add_zero \n```", "```py\ninstance  :  AddMonoid‚ÇÑ  ‚Ñ§  where\n  add  :=  (¬∑  +  ¬∑)\n  add_assoc‚ÇÉ  :=  Int.add_assoc\n  zero  :=  0\n  zero_add  :=  Int.zero_add\n  add_zero  :=  Int.add_zero\n  nsmul  :=  fun  n  m  ‚Ü¶  (n  :  ‚Ñ§)  *  m\n  nsmul_zero  :=  Int.zero_mul\n  nsmul_succ  :=  fun  n  m  ‚Ü¶  show  (n  +  1  :  ‚Ñ§)  *  m  =  m  +  n  *  m\n  by  rw  [Int.add_mul,  Int.add_comm,  Int.one_mul] \n```", "```py\nexample  (n  :  ‚Ñï)  (m  :  ‚Ñ§)  :  SMul.smul  (self  :=  mySMul)  n  m  =  n  *  m  :=  rfl \n```", "```py\ndef  isMonoidHom‚ÇÅ  [Monoid  G]  [Monoid  H]  (f  :  G  ‚Üí  H)  :  Prop  :=\n  f  1  =  1  ‚àß  ‚àÄ  g  g',  f  (g  *  g')  =  f  g  *  f  g' \n```", "```py\nstructure  isMonoidHom‚ÇÇ  [Monoid  G]  [Monoid  H]  (f  :  G  ‚Üí  H)  :  Prop  where\n  map_one  :  f  1  =  1\n  map_mul  :  ‚àÄ  g  g',  f  (g  *  g')  =  f  g  *  f  g' \n```", "```py\nexample  :  Continuous  (id  :  ‚Ñù  ‚Üí  ‚Ñù)  :=  continuous_id \n```", "```py\n@[ext]\nstructure  MonoidHom‚ÇÅ  (G  H  :  Type)  [Monoid  G]  [Monoid  H]  where\n  toFun  :  G  ‚Üí  H\n  map_one  :  toFun  1  =  1\n  map_mul  :  ‚àÄ  g  g',  toFun  (g  *  g')  =  toFun  g  *  toFun  g' \n```", "```py\ninstance  [Monoid  G]  [Monoid  H]  :  CoeFun  (MonoidHom‚ÇÅ  G  H)  (fun  _  ‚Ü¶  G  ‚Üí  H)  where\n  coe  :=  MonoidHom‚ÇÅ.toFun\n\nattribute  [coe]  MonoidHom‚ÇÅ.toFun \n```", "```py\nexample  [Monoid  G]  [Monoid  H]  (f  :  MonoidHom‚ÇÅ  G  H)  :  f  1  =  1  :=  f.map_one \n```", "```py\n@[ext]\nstructure  AddMonoidHom‚ÇÅ  (G  H  :  Type)  [AddMonoid  G]  [AddMonoid  H]  where\n  toFun  :  G  ‚Üí  H\n  map_zero  :  toFun  0  =  0\n  map_add  :  ‚àÄ  g  g',  toFun  (g  +  g')  =  toFun  g  +  toFun  g'\n\ninstance  [AddMonoid  G]  [AddMonoid  H]  :  CoeFun  (AddMonoidHom‚ÇÅ  G  H)  (fun  _  ‚Ü¶  G  ‚Üí  H)  where\n  coe  :=  AddMonoidHom‚ÇÅ.toFun\n\nattribute  [coe]  AddMonoidHom‚ÇÅ.toFun\n\n@[ext]\nstructure  RingHom‚ÇÅ  (R  S  :  Type)  [Ring  R]  [Ring  S]  extends  MonoidHom‚ÇÅ  R  S,  AddMonoidHom‚ÇÅ  R  S \n```", "```py\nclass  MonoidHomClass‚ÇÅ  (F  :  Type)  (M  N  :  Type)  [Monoid  M]  [Monoid  N]  where\n  toFun  :  F  ‚Üí  M  ‚Üí  N\n  map_one  :  ‚àÄ  f  :  F,  toFun  f  1  =  1\n  map_mul  :  ‚àÄ  f  g  g',  toFun  f  (g  *  g')  =  toFun  f  g  *  toFun  f  g' \n```", "```py\ndef  badInst  [Monoid  M]  [Monoid  N]  [MonoidHomClass‚ÇÅ  F  M  N]  :  CoeFun  F  (fun  _  ‚Ü¶  M  ‚Üí  N)  where\n  coe  :=  MonoidHomClass‚ÇÅ.toFun \n```", "```py\nclass  MonoidHomClass‚ÇÇ  (F  :  Type)  (M  N  :  outParam  Type)  [Monoid  M]  [Monoid  N]  where\n  toFun  :  F  ‚Üí  M  ‚Üí  N\n  map_one  :  ‚àÄ  f  :  F,  toFun  f  1  =  1\n  map_mul  :  ‚àÄ  f  g  g',  toFun  f  (g  *  g')  =  toFun  f  g  *  toFun  f  g'\n\ninstance  [Monoid  M]  [Monoid  N]  [MonoidHomClass‚ÇÇ  F  M  N]  :  CoeFun  F  (fun  _  ‚Ü¶  M  ‚Üí  N)  where\n  coe  :=  MonoidHomClass‚ÇÇ.toFun\n\nattribute  [coe]  MonoidHomClass‚ÇÇ.toFun \n```", "```py\ninstance  (M  N  :  Type)  [Monoid  M]  [Monoid  N]  :  MonoidHomClass‚ÇÇ  (MonoidHom‚ÇÅ  M  N)  M  N  where\n  toFun  :=  MonoidHom‚ÇÅ.toFun\n  map_one  :=  fun  f  ‚Ü¶  f.map_one\n  map_mul  :=  fun  f  ‚Ü¶  f.map_mul\n\ninstance  (R  S  :  Type)  [Ring  R]  [Ring  S]  :  MonoidHomClass‚ÇÇ  (RingHom‚ÇÅ  R  S)  R  S  where\n  toFun  :=  fun  f  ‚Ü¶  f.toMonoidHom‚ÇÅ.toFun\n  map_one  :=  fun  f  ‚Ü¶  f.toMonoidHom‚ÇÅ.map_one\n  map_mul  :=  fun  f  ‚Ü¶  f.toMonoidHom‚ÇÅ.map_mul \n```", "```py\nlemma  map_inv_of_inv  [Monoid  M]  [Monoid  N]  [MonoidHomClass‚ÇÇ  F  M  N]  (f  :  F)  {m  m'  :  M}  (h  :  m*m'  =  1)  :\n  f  m  *  f  m'  =  1  :=  by\n  rw  [‚Üê  MonoidHomClass‚ÇÇ.map_mul,  h,  MonoidHomClass‚ÇÇ.map_one]\n\nexample  [Monoid  M]  [Monoid  N]  (f  :  MonoidHom‚ÇÅ  M  N)  {m  m'  :  M}  (h  :  m*m'  =  1)  :  f  m  *  f  m'  =  1  :=\nmap_inv_of_inv  f  h\n\nexample  [Ring  R]  [Ring  S]  (f  :  RingHom‚ÇÅ  R  S)  {r  r'  :  R}  (h  :  r*r'  =  1)  :  f  r  *  f  r'  =  1  :=\nmap_inv_of_inv  f  h \n```", "```py\nclass  MonoidHomClass‚ÇÉ  (F  :  Type)  (M  N  :  outParam  Type)  [Monoid  M]  [Monoid  N]  extends\n  DFunLike  F  M  (fun  _  ‚Ü¶  N)  where\n  map_one  :  ‚àÄ  f  :  F,  f  1  =  1\n  map_mul  :  ‚àÄ  (f  :  F)  g  g',  f  (g  *  g')  =  f  g  *  f  g'\n\ninstance  (M  N  :  Type)  [Monoid  M]  [Monoid  N]  :  MonoidHomClass‚ÇÉ  (MonoidHom‚ÇÅ  M  N)  M  N  where\n  coe  :=  MonoidHom‚ÇÅ.toFun\n  coe_injective'  _  _  :=  MonoidHom‚ÇÅ.ext\n  map_one  :=  MonoidHom‚ÇÅ.map_one\n  map_mul  :=  MonoidHom‚ÇÅ.map_mul \n```", "```py\n@[ext]\nstructure  OrderPresHom  (Œ±  Œ≤  :  Type)  [LE  Œ±]  [LE  Œ≤]  where\n  toFun  :  Œ±  ‚Üí  Œ≤\n  le_of_le  :  ‚àÄ  a  a',  a  ‚â§  a'  ‚Üí  toFun  a  ‚â§  toFun  a'\n\n@[ext]\nstructure  OrderPresMonoidHom  (M  N  :  Type)  [Monoid  M]  [LE  M]  [Monoid  N]  [LE  N]  extends\nMonoidHom‚ÇÅ  M  N,  OrderPresHom  M  N\n\nclass  OrderPresHomClass  (F  :  Type)  (Œ±  Œ≤  :  outParam  Type)  [LE  Œ±]  [LE  Œ≤]\n\ninstance  (Œ±  Œ≤  :  Type)  [LE  Œ±]  [LE  Œ≤]  :  OrderPresHomClass  (OrderPresHom  Œ±  Œ≤)  Œ±  Œ≤  where\n\ninstance  (Œ±  Œ≤  :  Type)  [LE  Œ±]  [Monoid  Œ±]  [LE  Œ≤]  [Monoid  Œ≤]  :\n  OrderPresHomClass  (OrderPresMonoidHom  Œ±  Œ≤)  Œ±  Œ≤  where\n\ninstance  (Œ±  Œ≤  :  Type)  [LE  Œ±]  [Monoid  Œ±]  [LE  Œ≤]  [Monoid  Œ≤]  :\n  MonoidHomClass‚ÇÉ  (OrderPresMonoidHom  Œ±  Œ≤)  Œ±  Œ≤\n  :=  sorry \n```", "```py\n@[ext]\nstructure  Submonoid‚ÇÅ  (M  :  Type)  [Monoid  M]  where\n  /-- The carrier of a submonoid. -/\n  carrier  :  Set  M\n  /-- The product of two elements of a submonoid belongs to the submonoid. -/\n  mul_mem  {a  b}  :  a  ‚àà  carrier  ‚Üí  b  ‚àà  carrier  ‚Üí  a  *  b  ‚àà  carrier\n  /-- The unit element belongs to the submonoid. -/\n  one_mem  :  1  ‚àà  carrier\n\n/-- Submonoids in `M` can be seen as sets in `M`. -/\ninstance  [Monoid  M]  :  SetLike  (Submonoid‚ÇÅ  M)  M  where\n  coe  :=  Submonoid‚ÇÅ.carrier\n  coe_injective'  _  _  :=  Submonoid‚ÇÅ.ext \n```", "```py\nexample  [Monoid  M]  (N  :  Submonoid‚ÇÅ  M)  :  1  ‚àà  N  :=  N.one_mem\n\nexample  [Monoid  M]  (N  :  Submonoid‚ÇÅ  M)  (Œ±  :  Type)  (f  :  M  ‚Üí  Œ±)  :=  f  ''  N \n```", "```py\nexample  [Monoid  M]  (N  :  Submonoid‚ÇÅ  M)  (x  :  N)  :  (x  :  M)  ‚àà  N  :=  x.property \n```", "```py\ninstance  SubMonoid‚ÇÅMonoid  [Monoid  M]  (N  :  Submonoid‚ÇÅ  M)  :  Monoid  N  where\n  mul  :=  fun  x  y  ‚Ü¶  ‚ü®x*y,  N.mul_mem  x.property  y.property‚ü©\n  mul_assoc  :=  fun  x  y  z  ‚Ü¶  SetCoe.ext  (mul_assoc  (x  :  M)  y  z)\n  one  :=  ‚ü®1,  N.one_mem‚ü©\n  one_mul  :=  fun  x  ‚Ü¶  SetCoe.ext  (one_mul  (x  :  M))\n  mul_one  :=  fun  x  ‚Ü¶  SetCoe.ext  (mul_one  (x  :  M)) \n```", "```py\nexample  [Monoid  M]  (N  :  Submonoid‚ÇÅ  M)  :  Monoid  N  where\n  mul  :=  fun  ‚ü®x,  hx‚ü©  ‚ü®y,  hy‚ü©  ‚Ü¶  ‚ü®x*y,  N.mul_mem  hx  hy‚ü©\n  mul_assoc  :=  fun  ‚ü®x,  _‚ü©  ‚ü®y,  _‚ü©  ‚ü®z,  _‚ü©  ‚Ü¶  SetCoe.ext  (mul_assoc  x  y  z)\n  one  :=  ‚ü®1,  N.one_mem‚ü©\n  one_mul  :=  fun  ‚ü®x,  _‚ü©  ‚Ü¶  SetCoe.ext  (one_mul  x)\n  mul_one  :=  fun  ‚ü®x,  _‚ü©  ‚Ü¶  SetCoe.ext  (mul_one  x) \n```", "```py\nclass  SubmonoidClass‚ÇÅ  (S  :  Type)  (M  :  Type)  [Monoid  M]  [SetLike  S  M]  :  Prop  where\n  mul_mem  :  ‚àÄ  (s  :  S)  {a  b  :  M},  a  ‚àà  s  ‚Üí  b  ‚àà  s  ‚Üí  a  *  b  ‚àà  s\n  one_mem  :  ‚àÄ  s  :  S,  1  ‚àà  s\n\ninstance  [Monoid  M]  :  SubmonoidClass‚ÇÅ  (Submonoid‚ÇÅ  M)  M  where\n  mul_mem  :=  Submonoid‚ÇÅ.mul_mem\n  one_mem  :=  Submonoid‚ÇÅ.one_mem \n```", "```py\ninstance  [Monoid  M]  :  Min  (Submonoid‚ÇÅ  M)  :=\n  ‚ü®fun  S‚ÇÅ  S‚ÇÇ  ‚Ü¶\n  {  carrier  :=  S‚ÇÅ  ‚à©  S‚ÇÇ\n  one_mem  :=  ‚ü®S‚ÇÅ.one_mem,  S‚ÇÇ.one_mem‚ü©\n  mul_mem  :=  fun  ‚ü®hx,  hx'‚ü©  ‚ü®hy,  hy'‚ü©  ‚Ü¶  ‚ü®S‚ÇÅ.mul_mem  hx  hy,  S‚ÇÇ.mul_mem  hx'  hy'‚ü©  }‚ü© \n```", "```py\nexample  [Monoid  M]  (N  P  :  Submonoid‚ÇÅ  M)  :  Submonoid‚ÇÅ  M  :=  N  ‚äì  P \n```", "```py\ndef  Submonoid.Setoid  [CommMonoid  M]  (N  :  Submonoid  M)  :  Setoid  M  where\n  r  :=  fun  x  y  ‚Ü¶  ‚àÉ  w  ‚àà  N,  ‚àÉ  z  ‚àà  N,  x*w  =  y*z\n  iseqv  :=  {\n  refl  :=  fun  x  ‚Ü¶  ‚ü®1,  N.one_mem,  1,  N.one_mem,  rfl‚ü©\n  symm  :=  fun  ‚ü®w,  hw,  z,  hz,  h‚ü©  ‚Ü¶  ‚ü®z,  hz,  w,  hw,  h.symm‚ü©\n  trans  :=  by\n  sorry\n  }\n\ninstance  [CommMonoid  M]  :  HasQuotient  M  (Submonoid  M)  where\n  quotient'  :=  fun  N  ‚Ü¶  Quotient  N.Setoid\n\ndef  QuotientMonoid.mk  [CommMonoid  M]  (N  :  Submonoid  M)  :  M  ‚Üí  M  ‚ß∏  N  :=  Quotient.mk  N.Setoid\n\ninstance  [CommMonoid  M]  (N  :  Submonoid  M)  :  Monoid  (M  ‚ß∏  N)  where\n  mul  :=  Quotient.map‚ÇÇ  (¬∑  *  ¬∑)  (by\n  sorry\n  )\n  mul_assoc  :=  by\n  sorry\n  one  :=  QuotientMonoid.mk  N  1\n  one_mul  :=  by\n  sorry\n  mul_one  :=  by\n  sorry \n```", "```py\nclass  One‚ÇÅ  (Œ±  :  Type)  where\n  /-- The element one -/\n  one  :  Œ± \n```", "```py\n#check  One‚ÇÅ.one  -- One‚ÇÅ.one {Œ± : Type} [self : One‚ÇÅ Œ±] : Œ±\n\n@[class]  structure  One‚ÇÇ  (Œ±  :  Type)  where\n  /-- The element one -/\n  one  :  Œ±\n\n#check  One‚ÇÇ.one \n```", "```py\nexample  (Œ±  :  Type)  [One‚ÇÅ  Œ±]  :  Œ±  :=  One‚ÇÅ.one \n```", "```py\nexample  (Œ±  :  Type)  [One‚ÇÅ  Œ±]  :=  (One‚ÇÅ.one  :  Œ±) \n```", "```py\n@[inherit_doc]\nnotation  \"ùüô\"  =>  One‚ÇÅ.one\n\nexample  {Œ±  :  Type}  [One‚ÇÅ  Œ±]  :  Œ±  :=  ùüô\n\nexample  {Œ±  :  Type}  [One‚ÇÅ  Œ±]  :  (ùüô  :  Œ±)  =  ùüô  :=  rfl \n```", "```py\nclass  Dia‚ÇÅ  (Œ±  :  Type)  where\n  dia  :  Œ±  ‚Üí  Œ±  ‚Üí  Œ±\n\ninfixl:70  \" ‚ãÑ \"  =>  Dia‚ÇÅ.dia \n```", "```py\nclass  Semigroup‚ÇÄ  (Œ±  :  Type)  where\n  toDia‚ÇÅ  :  Dia‚ÇÅ  Œ±\n  /-- Diamond is associative -/\n  dia_assoc  :  ‚àÄ  a  b  c  :  Œ±,  a  ‚ãÑ  b  ‚ãÑ  c  =  a  ‚ãÑ  (b  ‚ãÑ  c) \n```", "```py\nattribute  [instance]  Semigroup‚ÇÄ.toDia‚ÇÅ\n\nexample  {Œ±  :  Type}  [Semigroup‚ÇÄ  Œ±]  (a  b  :  Œ±)  :  Œ±  :=  a  ‚ãÑ  b \n```", "```py\nclass  Semigroup‚ÇÅ  (Œ±  :  Type)  extends  toDia‚ÇÅ  :  Dia‚ÇÅ  Œ±  where\n  /-- Diamond is associative -/\n  dia_assoc  :  ‚àÄ  a  b  c  :  Œ±,  a  ‚ãÑ  b  ‚ãÑ  c  =  a  ‚ãÑ  (b  ‚ãÑ  c)\n\nexample  {Œ±  :  Type}  [Semigroup‚ÇÅ  Œ±]  (a  b  :  Œ±)  :  Œ±  :=  a  ‚ãÑ  b \n```", "```py\nclass  Semigroup‚ÇÇ  (Œ±  :  Type)  extends  Dia‚ÇÅ  Œ±  where\n  /-- Diamond is associative -/\n  dia_assoc  :  ‚àÄ  a  b  c  :  Œ±,  a  ‚ãÑ  b  ‚ãÑ  c  =  a  ‚ãÑ  (b  ‚ãÑ  c) \n```", "```py\nclass  DiaOneClass‚ÇÅ  (Œ±  :  Type)  extends  One‚ÇÅ  Œ±,  Dia‚ÇÅ  Œ±  where\n  /-- One is a left neutral element for diamond. -/\n  one_dia  :  ‚àÄ  a  :  Œ±,  ùüô  ‚ãÑ  a  =  a\n  /-- One is a right neutral element for diamond -/\n  dia_one  :  ‚àÄ  a  :  Œ±,  a  ‚ãÑ  ùüô  =  a \n```", "```py\nset_option  trace.Meta.synthInstance  true  in\nexample  {Œ±  :  Type}  [DiaOneClass‚ÇÅ  Œ±]  (a  b  :  Œ±)  :  Prop  :=  a  ‚ãÑ  b  =  ùüô \n```", "```py\nclass  Monoid‚ÇÅ  (Œ±  :  Type)  extends  Semigroup‚ÇÅ  Œ±,  DiaOneClass‚ÇÅ  Œ± \n```", "```py\nclass  Monoid‚ÇÇ  (Œ±  :  Type)  where\n  toSemigroup‚ÇÅ  :  Semigroup‚ÇÅ  Œ±\n  toDiaOneClass‚ÇÅ  :  DiaOneClass‚ÇÅ  Œ± \n```", "```py\nexample  {Œ±  :  Type}  [Monoid‚ÇÅ  Œ±]  :\n  (Monoid‚ÇÅ.toSemigroup‚ÇÅ.toDia‚ÇÅ.dia  :  Œ±  ‚Üí  Œ±  ‚Üí  Œ±)  =  Monoid‚ÇÅ.toDiaOneClass‚ÇÅ.toDia‚ÇÅ.dia  :=  rfl \n```", "```py\n/- Monoid‚ÇÇ.mk {Œ± : Type} (toSemigroup‚ÇÅ : Semigroup‚ÇÅ Œ±) (toDiaOneClass‚ÇÅ : DiaOneClass‚ÇÅ Œ±) : Monoid‚ÇÇ Œ± -/\n#check  Monoid‚ÇÇ.mk\n\n/- Monoid‚ÇÅ.mk {Œ± : Type} [toSemigroup‚ÇÅ : Semigroup‚ÇÅ Œ±] [toOne‚ÇÅ : One‚ÇÅ Œ±] (one_dia : ‚àÄ (a : Œ±), ùüô ‚ãÑ a = a) (dia_one : ‚àÄ (a : Œ±), a ‚ãÑ ùüô = a) : Monoid‚ÇÅ Œ± -/\n#check  Monoid‚ÇÅ.mk \n```", "```py\n#check  Monoid‚ÇÅ.toSemigroup‚ÇÅ\n#check  Monoid‚ÇÅ.toDiaOneClass‚ÇÅ \n```", "```py\nclass  Inv‚ÇÅ  (Œ±  :  Type)  where\n  /-- The inversion function -/\n  inv  :  Œ±  ‚Üí  Œ±\n\n@[inherit_doc]\npostfix:max  \"‚Åª¬π\"  =>  Inv‚ÇÅ.inv\n\nclass  Group‚ÇÅ  (G  :  Type)  extends  Monoid‚ÇÅ  G,  Inv‚ÇÅ  G  where\n  inv_dia  :  ‚àÄ  a  :  G,  a‚Åª¬π  ‚ãÑ  a  =  ùüô \n```", "```py\nlemma  left_inv_eq_right_inv‚ÇÅ  {M  :  Type}  [Monoid‚ÇÅ  M]  {a  b  c  :  M}  (hba  :  b  ‚ãÑ  a  =  ùüô)  (hac  :  a  ‚ãÑ  c  =  ùüô)  :  b  =  c  :=  by\n  rw  [‚Üê  DiaOneClass‚ÇÅ.one_dia  c,  ‚Üê  hba,  Semigroup‚ÇÅ.dia_assoc,  hac,  DiaOneClass‚ÇÅ.dia_one  b] \n```", "```py\nexport  DiaOneClass‚ÇÅ  (one_dia  dia_one)\nexport  Semigroup‚ÇÅ  (dia_assoc)\nexport  Group‚ÇÅ  (inv_dia) \n```", "```py\nexample  {M  :  Type}  [Monoid‚ÇÅ  M]  {a  b  c  :  M}  (hba  :  b  ‚ãÑ  a  =  ùüô)  (hac  :  a  ‚ãÑ  c  =  ùüô)  :  b  =  c  :=  by\n  rw  [‚Üê  one_dia  c,  ‚Üê  hba,  dia_assoc,  hac,  dia_one  b] \n```", "```py\nlemma  inv_eq_of_dia  [Group‚ÇÅ  G]  {a  b  :  G}  (h  :  a  ‚ãÑ  b  =  ùüô)  :  a‚Åª¬π  =  b  :=\n  sorry\n\nlemma  dia_inv  [Group‚ÇÅ  G]  (a  :  G)  :  a  ‚ãÑ  a‚Åª¬π  =  ùüô  :=\n  sorry \n```", "```py\nclass  AddSemigroup‚ÇÉ  (Œ±  :  Type)  extends  Add  Œ±  where\n  /-- Addition is associative -/\n  add_assoc‚ÇÉ  :  ‚àÄ  a  b  c  :  Œ±,  a  +  b  +  c  =  a  +  (b  +  c)\n\n@[to_additive  AddSemigroup‚ÇÉ]\nclass  Semigroup‚ÇÉ  (Œ±  :  Type)  extends  Mul  Œ±  where\n  /-- Multiplication is associative -/\n  mul_assoc‚ÇÉ  :  ‚àÄ  a  b  c  :  Œ±,  a  *  b  *  c  =  a  *  (b  *  c)\n\nclass  AddMonoid‚ÇÉ  (Œ±  :  Type)  extends  AddSemigroup‚ÇÉ  Œ±,  AddZeroClass  Œ±\n\n@[to_additive  AddMonoid‚ÇÉ]\nclass  Monoid‚ÇÉ  (Œ±  :  Type)  extends  Semigroup‚ÇÉ  Œ±,  MulOneClass  Œ±\n\nexport  Semigroup‚ÇÉ  (mul_assoc‚ÇÉ)\nexport  AddSemigroup‚ÇÉ  (add_assoc‚ÇÉ)\n\nwhatsnew  in\n@[to_additive]\nlemma  left_inv_eq_right_inv'  {M  :  Type}  [Monoid‚ÇÉ  M]  {a  b  c  :  M}  (hba  :  b  *  a  =  1)  (hac  :  a  *  c  =  1)  :  b  =  c  :=  by\n  rw  [‚Üê  one_mul  c,  ‚Üê  hba,  mul_assoc‚ÇÉ,  hac,  mul_one  b]\n\n#check  left_neg_eq_right_neg' \n```", "```py\nclass  AddCommSemigroup‚ÇÉ  (Œ±  :  Type)  extends  AddSemigroup‚ÇÉ  Œ±  where\n  add_comm  :  ‚àÄ  a  b  :  Œ±,  a  +  b  =  b  +  a\n\n@[to_additive  AddCommSemigroup‚ÇÉ]\nclass  CommSemigroup‚ÇÉ  (Œ±  :  Type)  extends  Semigroup‚ÇÉ  Œ±  where\n  mul_comm  :  ‚àÄ  a  b  :  Œ±,  a  *  b  =  b  *  a\n\nclass  AddCommMonoid‚ÇÉ  (Œ±  :  Type)  extends  AddMonoid‚ÇÉ  Œ±,  AddCommSemigroup‚ÇÉ  Œ±\n\n@[to_additive  AddCommMonoid‚ÇÉ]\nclass  CommMonoid‚ÇÉ  (Œ±  :  Type)  extends  Monoid‚ÇÉ  Œ±,  CommSemigroup‚ÇÉ  Œ±\n\nclass  AddGroup‚ÇÉ  (G  :  Type)  extends  AddMonoid‚ÇÉ  G,  Neg  G  where\n  neg_add  :  ‚àÄ  a  :  G,  -a  +  a  =  0\n\n@[to_additive  AddGroup‚ÇÉ]\nclass  Group‚ÇÉ  (G  :  Type)  extends  Monoid‚ÇÉ  G,  Inv  G  where\n  inv_mul  :  ‚àÄ  a  :  G,  a‚Åª¬π  *  a  =  1 \n```", "```py\nattribute  [simp]  Group‚ÇÉ.inv_mul  AddGroup‚ÇÉ.neg_add \n```", "```py\n@[to_additive]\nlemma  inv_eq_of_mul  [Group‚ÇÉ  G]  {a  b  :  G}  (h  :  a  *  b  =  1)  :  a‚Åª¬π  =  b  :=\n  sorry \n```", "```py\n@[to_additive  (attr  :=  simp)]\nlemma  Group‚ÇÉ.mul_inv  {G  :  Type}  [Group‚ÇÉ  G]  {a  :  G}  :  a  *  a‚Åª¬π  =  1  :=  by\n  sorry\n\n@[to_additive]\nlemma  mul_left_cancel‚ÇÉ  {G  :  Type}  [Group‚ÇÉ  G]  {a  b  c  :  G}  (h  :  a  *  b  =  a  *  c)  :  b  =  c  :=  by\n  sorry\n\n@[to_additive]\nlemma  mul_right_cancel‚ÇÉ  {G  :  Type}  [Group‚ÇÉ  G]  {a  b  c  :  G}  (h  :  b*a  =  c*a)  :  b  =  c  :=  by\n  sorry\n\nclass  AddCommGroup‚ÇÉ  (G  :  Type)  extends  AddGroup‚ÇÉ  G,  AddCommMonoid‚ÇÉ  G\n\n@[to_additive  AddCommGroup‚ÇÉ]\nclass  CommGroup‚ÇÉ  (G  :  Type)  extends  Group‚ÇÉ  G,  CommMonoid‚ÇÉ  G \n```", "```py\nclass  Ring‚ÇÉ  (R  :  Type)  extends  AddGroup‚ÇÉ  R,  Monoid‚ÇÉ  R,  MulZeroClass  R  where\n  /-- Multiplication is left distributive over addition -/\n  left_distrib  :  ‚àÄ  a  b  c  :  R,  a  *  (b  +  c)  =  a  *  b  +  a  *  c\n  /-- Multiplication is right distributive over addition -/\n  right_distrib  :  ‚àÄ  a  b  c  :  R,  (a  +  b)  *  c  =  a  *  c  +  b  *  c\n\ninstance  {R  :  Type}  [Ring‚ÇÉ  R]  :  AddCommGroup‚ÇÉ  R  :=\n{  add_comm  :=  by\n  sorry  } \n```", "```py\ninstance  :  Ring‚ÇÉ  ‚Ñ§  where\n  add  :=  (¬∑  +  ¬∑)\n  add_assoc‚ÇÉ  :=  add_assoc\n  zero  :=  0\n  zero_add  :=  by  simp\n  add_zero  :=  by  simp\n  neg  :=  (-  ¬∑)\n  neg_add  :=  by  simp\n  mul  :=  (¬∑  *  ¬∑)\n  mul_assoc‚ÇÉ  :=  mul_assoc\n  one  :=  1\n  one_mul  :=  by  simp\n  mul_one  :=  by  simp\n  zero_mul  :=  by  simp\n  mul_zero  :=  by  simp\n  left_distrib  :=  Int.mul_add\n  right_distrib  :=  Int.add_mul \n```", "```py\nclass  LE‚ÇÅ  (Œ±  :  Type)  where\n  /-- The Less-or-Equal relation. -/\n  le  :  Œ±  ‚Üí  Œ±  ‚Üí  Prop\n\n@[inherit_doc]  infix:50  \" ‚â§‚ÇÅ \"  =>  LE‚ÇÅ.le\n\nclass  Preorder‚ÇÅ  (Œ±  :  Type)\n\nclass  PartialOrder‚ÇÅ  (Œ±  :  Type)\n\nclass  OrderedCommMonoid‚ÇÅ  (Œ±  :  Type)\n\ninstance  :  OrderedCommMonoid‚ÇÅ  ‚Ñï  where \n```", "```py\nclass  SMul‚ÇÉ  (Œ±  :  Type)  (Œ≤  :  Type)  where\n  /-- Scalar multiplication -/\n  smul  :  Œ±  ‚Üí  Œ≤  ‚Üí  Œ≤\n\ninfixr:73  \" ‚Ä¢ \"  =>  SMul‚ÇÉ.smul \n```", "```py\nclass  Module‚ÇÅ  (R  :  Type)  [Ring‚ÇÉ  R]  (M  :  Type)  [AddCommGroup‚ÇÉ  M]  extends  SMul‚ÇÉ  R  M  where\n  zero_smul  :  ‚àÄ  m  :  M,  (0  :  R)  ‚Ä¢  m  =  0\n  one_smul  :  ‚àÄ  m  :  M,  (1  :  R)  ‚Ä¢  m  =  m\n  mul_smul  :  ‚àÄ  (a  b  :  R)  (m  :  M),  (a  *  b)  ‚Ä¢  m  =  a  ‚Ä¢  b  ‚Ä¢  m\n  add_smul  :  ‚àÄ  (a  b  :  R)  (m  :  M),  (a  +  b)  ‚Ä¢  m  =  a  ‚Ä¢  m  +  b  ‚Ä¢  m\n  smul_add  :  ‚àÄ  (a  :  R)  (m  n  :  M),  a  ‚Ä¢  (m  +  n)  =  a  ‚Ä¢  m  +  a  ‚Ä¢  n \n```", "```py\ninstance  selfModule  (R  :  Type)  [Ring‚ÇÉ  R]  :  Module‚ÇÅ  R  R  where\n  smul  :=  fun  r  s  ‚Ü¶  r*s\n  zero_smul  :=  zero_mul\n  one_smul  :=  one_mul\n  mul_smul  :=  mul_assoc‚ÇÉ\n  add_smul  :=  Ring‚ÇÉ.right_distrib\n  smul_add  :=  Ring‚ÇÉ.left_distrib \n```", "```py\ndef  nsmul‚ÇÅ  {M  :  Type*}  [Zero  M]  [Add  M]  :  ‚Ñï  ‚Üí  M  ‚Üí  M\n  |  0,  _  =>  0\n  |  n  +  1,  a  =>  a  +  nsmul‚ÇÅ  n  a\n\ndef  zsmul‚ÇÅ  {M  :  Type*}  [Zero  M]  [Add  M]  [Neg  M]  :  ‚Ñ§  ‚Üí  M  ‚Üí  M\n  |  Int.ofNat  n,  a  =>  nsmul‚ÇÅ  n  a\n  |  Int.negSucc  n,  a  =>  -nsmul‚ÇÅ  n.succ  a \n```", "```py\ninstance  abGrpModule  (A  :  Type)  [AddCommGroup‚ÇÉ  A]  :  Module‚ÇÅ  ‚Ñ§  A  where\n  smul  :=  zsmul‚ÇÅ\n  zero_smul  :=  sorry\n  one_smul  :=  sorry\n  mul_smul  :=  sorry\n  add_smul  :=  sorry\n  smul_add  :=  sorry \n```", "```py\n#synth  Module‚ÇÅ  ‚Ñ§  ‚Ñ§  -- abGrpModule ‚Ñ§ \n```", "```py\nclass  AddMonoid‚ÇÑ  (M  :  Type)  extends  AddSemigroup‚ÇÉ  M,  AddZeroClass  M  where\n  /-- Multiplication by a natural number. -/\n  nsmul  :  ‚Ñï  ‚Üí  M  ‚Üí  M  :=  nsmul‚ÇÅ\n  /-- Multiplication by `(0 : ‚Ñï)` gives `0`. -/\n  nsmul_zero  :  ‚àÄ  x,  nsmul  0  x  =  0  :=  by  intros;  rfl\n  /-- Multiplication by `(n + 1 : ‚Ñï)` behaves as expected. -/\n  nsmul_succ  :  ‚àÄ  (n  :  ‚Ñï)  (x),  nsmul  (n  +  1)  x  =  x  +  nsmul  n  x  :=  by  intros;  rfl\n\ninstance  mySMul  {M  :  Type}  [AddMonoid‚ÇÑ  M]  :  SMul  ‚Ñï  M  :=  ‚ü®AddMonoid‚ÇÑ.nsmul‚ü© \n```", "```py\ninstance  (M  N  :  Type)  [AddMonoid‚ÇÑ  M]  [AddMonoid‚ÇÑ  N]  :  AddMonoid‚ÇÑ  (M  √ó  N)  where\n  add  :=  fun  p  q  ‚Ü¶  (p.1  +  q.1,  p.2  +  q.2)\n  add_assoc‚ÇÉ  :=  fun  a  b  c  ‚Ü¶  by  ext  <;>  apply  add_assoc‚ÇÉ\n  zero  :=  (0,  0)\n  zero_add  :=  fun  a  ‚Ü¶  by  ext  <;>  apply  zero_add\n  add_zero  :=  fun  a  ‚Ü¶  by  ext  <;>  apply  add_zero \n```", "```py\ninstance  :  AddMonoid‚ÇÑ  ‚Ñ§  where\n  add  :=  (¬∑  +  ¬∑)\n  add_assoc‚ÇÉ  :=  Int.add_assoc\n  zero  :=  0\n  zero_add  :=  Int.zero_add\n  add_zero  :=  Int.add_zero\n  nsmul  :=  fun  n  m  ‚Ü¶  (n  :  ‚Ñ§)  *  m\n  nsmul_zero  :=  Int.zero_mul\n  nsmul_succ  :=  fun  n  m  ‚Ü¶  show  (n  +  1  :  ‚Ñ§)  *  m  =  m  +  n  *  m\n  by  rw  [Int.add_mul,  Int.add_comm,  Int.one_mul] \n```", "```py\nexample  (n  :  ‚Ñï)  (m  :  ‚Ñ§)  :  SMul.smul  (self  :=  mySMul)  n  m  =  n  *  m  :=  rfl \n```", "```py\ndef  isMonoidHom‚ÇÅ  [Monoid  G]  [Monoid  H]  (f  :  G  ‚Üí  H)  :  Prop  :=\n  f  1  =  1  ‚àß  ‚àÄ  g  g',  f  (g  *  g')  =  f  g  *  f  g' \n```", "```py\nstructure  isMonoidHom‚ÇÇ  [Monoid  G]  [Monoid  H]  (f  :  G  ‚Üí  H)  :  Prop  where\n  map_one  :  f  1  =  1\n  map_mul  :  ‚àÄ  g  g',  f  (g  *  g')  =  f  g  *  f  g' \n```", "```py\nexample  :  Continuous  (id  :  ‚Ñù  ‚Üí  ‚Ñù)  :=  continuous_id \n```", "```py\n@[ext]\nstructure  MonoidHom‚ÇÅ  (G  H  :  Type)  [Monoid  G]  [Monoid  H]  where\n  toFun  :  G  ‚Üí  H\n  map_one  :  toFun  1  =  1\n  map_mul  :  ‚àÄ  g  g',  toFun  (g  *  g')  =  toFun  g  *  toFun  g' \n```", "```py\ninstance  [Monoid  G]  [Monoid  H]  :  CoeFun  (MonoidHom‚ÇÅ  G  H)  (fun  _  ‚Ü¶  G  ‚Üí  H)  where\n  coe  :=  MonoidHom‚ÇÅ.toFun\n\nattribute  [coe]  MonoidHom‚ÇÅ.toFun \n```", "```py\nexample  [Monoid  G]  [Monoid  H]  (f  :  MonoidHom‚ÇÅ  G  H)  :  f  1  =  1  :=  f.map_one \n```", "```py\n@[ext]\nstructure  AddMonoidHom‚ÇÅ  (G  H  :  Type)  [AddMonoid  G]  [AddMonoid  H]  where\n  toFun  :  G  ‚Üí  H\n  map_zero  :  toFun  0  =  0\n  map_add  :  ‚àÄ  g  g',  toFun  (g  +  g')  =  toFun  g  +  toFun  g'\n\ninstance  [AddMonoid  G]  [AddMonoid  H]  :  CoeFun  (AddMonoidHom‚ÇÅ  G  H)  (fun  _  ‚Ü¶  G  ‚Üí  H)  where\n  coe  :=  AddMonoidHom‚ÇÅ.toFun\n\nattribute  [coe]  AddMonoidHom‚ÇÅ.toFun\n\n@[ext]\nstructure  RingHom‚ÇÅ  (R  S  :  Type)  [Ring  R]  [Ring  S]  extends  MonoidHom‚ÇÅ  R  S,  AddMonoidHom‚ÇÅ  R  S \n```", "```py\nclass  MonoidHomClass‚ÇÅ  (F  :  Type)  (M  N  :  Type)  [Monoid  M]  [Monoid  N]  where\n  toFun  :  F  ‚Üí  M  ‚Üí  N\n  map_one  :  ‚àÄ  f  :  F,  toFun  f  1  =  1\n  map_mul  :  ‚àÄ  f  g  g',  toFun  f  (g  *  g')  =  toFun  f  g  *  toFun  f  g' \n```", "```py\ndef  badInst  [Monoid  M]  [Monoid  N]  [MonoidHomClass‚ÇÅ  F  M  N]  :  CoeFun  F  (fun  _  ‚Ü¶  M  ‚Üí  N)  where\n  coe  :=  MonoidHomClass‚ÇÅ.toFun \n```", "```py\nclass  MonoidHomClass‚ÇÇ  (F  :  Type)  (M  N  :  outParam  Type)  [Monoid  M]  [Monoid  N]  where\n  toFun  :  F  ‚Üí  M  ‚Üí  N\n  map_one  :  ‚àÄ  f  :  F,  toFun  f  1  =  1\n  map_mul  :  ‚àÄ  f  g  g',  toFun  f  (g  *  g')  =  toFun  f  g  *  toFun  f  g'\n\ninstance  [Monoid  M]  [Monoid  N]  [MonoidHomClass‚ÇÇ  F  M  N]  :  CoeFun  F  (fun  _  ‚Ü¶  M  ‚Üí  N)  where\n  coe  :=  MonoidHomClass‚ÇÇ.toFun\n\nattribute  [coe]  MonoidHomClass‚ÇÇ.toFun \n```", "```py\ninstance  (M  N  :  Type)  [Monoid  M]  [Monoid  N]  :  MonoidHomClass‚ÇÇ  (MonoidHom‚ÇÅ  M  N)  M  N  where\n  toFun  :=  MonoidHom‚ÇÅ.toFun\n  map_one  :=  fun  f  ‚Ü¶  f.map_one\n  map_mul  :=  fun  f  ‚Ü¶  f.map_mul\n\ninstance  (R  S  :  Type)  [Ring  R]  [Ring  S]  :  MonoidHomClass‚ÇÇ  (RingHom‚ÇÅ  R  S)  R  S  where\n  toFun  :=  fun  f  ‚Ü¶  f.toMonoidHom‚ÇÅ.toFun\n  map_one  :=  fun  f  ‚Ü¶  f.toMonoidHom‚ÇÅ.map_one\n  map_mul  :=  fun  f  ‚Ü¶  f.toMonoidHom‚ÇÅ.map_mul \n```", "```py\nlemma  map_inv_of_inv  [Monoid  M]  [Monoid  N]  [MonoidHomClass‚ÇÇ  F  M  N]  (f  :  F)  {m  m'  :  M}  (h  :  m*m'  =  1)  :\n  f  m  *  f  m'  =  1  :=  by\n  rw  [‚Üê  MonoidHomClass‚ÇÇ.map_mul,  h,  MonoidHomClass‚ÇÇ.map_one]\n\nexample  [Monoid  M]  [Monoid  N]  (f  :  MonoidHom‚ÇÅ  M  N)  {m  m'  :  M}  (h  :  m*m'  =  1)  :  f  m  *  f  m'  =  1  :=\nmap_inv_of_inv  f  h\n\nexample  [Ring  R]  [Ring  S]  (f  :  RingHom‚ÇÅ  R  S)  {r  r'  :  R}  (h  :  r*r'  =  1)  :  f  r  *  f  r'  =  1  :=\nmap_inv_of_inv  f  h \n```", "```py\nclass  MonoidHomClass‚ÇÉ  (F  :  Type)  (M  N  :  outParam  Type)  [Monoid  M]  [Monoid  N]  extends\n  DFunLike  F  M  (fun  _  ‚Ü¶  N)  where\n  map_one  :  ‚àÄ  f  :  F,  f  1  =  1\n  map_mul  :  ‚àÄ  (f  :  F)  g  g',  f  (g  *  g')  =  f  g  *  f  g'\n\ninstance  (M  N  :  Type)  [Monoid  M]  [Monoid  N]  :  MonoidHomClass‚ÇÉ  (MonoidHom‚ÇÅ  M  N)  M  N  where\n  coe  :=  MonoidHom‚ÇÅ.toFun\n  coe_injective'  _  _  :=  MonoidHom‚ÇÅ.ext\n  map_one  :=  MonoidHom‚ÇÅ.map_one\n  map_mul  :=  MonoidHom‚ÇÅ.map_mul \n```", "```py\n@[ext]\nstructure  OrderPresHom  (Œ±  Œ≤  :  Type)  [LE  Œ±]  [LE  Œ≤]  where\n  toFun  :  Œ±  ‚Üí  Œ≤\n  le_of_le  :  ‚àÄ  a  a',  a  ‚â§  a'  ‚Üí  toFun  a  ‚â§  toFun  a'\n\n@[ext]\nstructure  OrderPresMonoidHom  (M  N  :  Type)  [Monoid  M]  [LE  M]  [Monoid  N]  [LE  N]  extends\nMonoidHom‚ÇÅ  M  N,  OrderPresHom  M  N\n\nclass  OrderPresHomClass  (F  :  Type)  (Œ±  Œ≤  :  outParam  Type)  [LE  Œ±]  [LE  Œ≤]\n\ninstance  (Œ±  Œ≤  :  Type)  [LE  Œ±]  [LE  Œ≤]  :  OrderPresHomClass  (OrderPresHom  Œ±  Œ≤)  Œ±  Œ≤  where\n\ninstance  (Œ±  Œ≤  :  Type)  [LE  Œ±]  [Monoid  Œ±]  [LE  Œ≤]  [Monoid  Œ≤]  :\n  OrderPresHomClass  (OrderPresMonoidHom  Œ±  Œ≤)  Œ±  Œ≤  where\n\ninstance  (Œ±  Œ≤  :  Type)  [LE  Œ±]  [Monoid  Œ±]  [LE  Œ≤]  [Monoid  Œ≤]  :\n  MonoidHomClass‚ÇÉ  (OrderPresMonoidHom  Œ±  Œ≤)  Œ±  Œ≤\n  :=  sorry \n```", "```py\n@[ext]\nstructure  Submonoid‚ÇÅ  (M  :  Type)  [Monoid  M]  where\n  /-- The carrier of a submonoid. -/\n  carrier  :  Set  M\n  /-- The product of two elements of a submonoid belongs to the submonoid. -/\n  mul_mem  {a  b}  :  a  ‚àà  carrier  ‚Üí  b  ‚àà  carrier  ‚Üí  a  *  b  ‚àà  carrier\n  /-- The unit element belongs to the submonoid. -/\n  one_mem  :  1  ‚àà  carrier\n\n/-- Submonoids in `M` can be seen as sets in `M`. -/\ninstance  [Monoid  M]  :  SetLike  (Submonoid‚ÇÅ  M)  M  where\n  coe  :=  Submonoid‚ÇÅ.carrier\n  coe_injective'  _  _  :=  Submonoid‚ÇÅ.ext \n```", "```py\nexample  [Monoid  M]  (N  :  Submonoid‚ÇÅ  M)  :  1  ‚àà  N  :=  N.one_mem\n\nexample  [Monoid  M]  (N  :  Submonoid‚ÇÅ  M)  (Œ±  :  Type)  (f  :  M  ‚Üí  Œ±)  :=  f  ''  N \n```", "```py\nexample  [Monoid  M]  (N  :  Submonoid‚ÇÅ  M)  (x  :  N)  :  (x  :  M)  ‚àà  N  :=  x.property \n```", "```py\ninstance  SubMonoid‚ÇÅMonoid  [Monoid  M]  (N  :  Submonoid‚ÇÅ  M)  :  Monoid  N  where\n  mul  :=  fun  x  y  ‚Ü¶  ‚ü®x*y,  N.mul_mem  x.property  y.property‚ü©\n  mul_assoc  :=  fun  x  y  z  ‚Ü¶  SetCoe.ext  (mul_assoc  (x  :  M)  y  z)\n  one  :=  ‚ü®1,  N.one_mem‚ü©\n  one_mul  :=  fun  x  ‚Ü¶  SetCoe.ext  (one_mul  (x  :  M))\n  mul_one  :=  fun  x  ‚Ü¶  SetCoe.ext  (mul_one  (x  :  M)) \n```", "```py\nexample  [Monoid  M]  (N  :  Submonoid‚ÇÅ  M)  :  Monoid  N  where\n  mul  :=  fun  ‚ü®x,  hx‚ü©  ‚ü®y,  hy‚ü©  ‚Ü¶  ‚ü®x*y,  N.mul_mem  hx  hy‚ü©\n  mul_assoc  :=  fun  ‚ü®x,  _‚ü©  ‚ü®y,  _‚ü©  ‚ü®z,  _‚ü©  ‚Ü¶  SetCoe.ext  (mul_assoc  x  y  z)\n  one  :=  ‚ü®1,  N.one_mem‚ü©\n  one_mul  :=  fun  ‚ü®x,  _‚ü©  ‚Ü¶  SetCoe.ext  (one_mul  x)\n  mul_one  :=  fun  ‚ü®x,  _‚ü©  ‚Ü¶  SetCoe.ext  (mul_one  x) \n```", "```py\nclass  SubmonoidClass‚ÇÅ  (S  :  Type)  (M  :  Type)  [Monoid  M]  [SetLike  S  M]  :  Prop  where\n  mul_mem  :  ‚àÄ  (s  :  S)  {a  b  :  M},  a  ‚àà  s  ‚Üí  b  ‚àà  s  ‚Üí  a  *  b  ‚àà  s\n  one_mem  :  ‚àÄ  s  :  S,  1  ‚àà  s\n\ninstance  [Monoid  M]  :  SubmonoidClass‚ÇÅ  (Submonoid‚ÇÅ  M)  M  where\n  mul_mem  :=  Submonoid‚ÇÅ.mul_mem\n  one_mem  :=  Submonoid‚ÇÅ.one_mem \n```", "```py\ninstance  [Monoid  M]  :  Min  (Submonoid‚ÇÅ  M)  :=\n  ‚ü®fun  S‚ÇÅ  S‚ÇÇ  ‚Ü¶\n  {  carrier  :=  S‚ÇÅ  ‚à©  S‚ÇÇ\n  one_mem  :=  ‚ü®S‚ÇÅ.one_mem,  S‚ÇÇ.one_mem‚ü©\n  mul_mem  :=  fun  ‚ü®hx,  hx'‚ü©  ‚ü®hy,  hy'‚ü©  ‚Ü¶  ‚ü®S‚ÇÅ.mul_mem  hx  hy,  S‚ÇÇ.mul_mem  hx'  hy'‚ü©  }‚ü© \n```", "```py\nexample  [Monoid  M]  (N  P  :  Submonoid‚ÇÅ  M)  :  Submonoid‚ÇÅ  M  :=  N  ‚äì  P \n```", "```py\ndef  Submonoid.Setoid  [CommMonoid  M]  (N  :  Submonoid  M)  :  Setoid  M  where\n  r  :=  fun  x  y  ‚Ü¶  ‚àÉ  w  ‚àà  N,  ‚àÉ  z  ‚àà  N,  x*w  =  y*z\n  iseqv  :=  {\n  refl  :=  fun  x  ‚Ü¶  ‚ü®1,  N.one_mem,  1,  N.one_mem,  rfl‚ü©\n  symm  :=  fun  ‚ü®w,  hw,  z,  hz,  h‚ü©  ‚Ü¶  ‚ü®z,  hz,  w,  hw,  h.symm‚ü©\n  trans  :=  by\n  sorry\n  }\n\ninstance  [CommMonoid  M]  :  HasQuotient  M  (Submonoid  M)  where\n  quotient'  :=  fun  N  ‚Ü¶  Quotient  N.Setoid\n\ndef  QuotientMonoid.mk  [CommMonoid  M]  (N  :  Submonoid  M)  :  M  ‚Üí  M  ‚ß∏  N  :=  Quotient.mk  N.Setoid\n\ninstance  [CommMonoid  M]  (N  :  Submonoid  M)  :  Monoid  (M  ‚ß∏  N)  where\n  mul  :=  Quotient.map‚ÇÇ  (¬∑  *  ¬∑)  (by\n  sorry\n  )\n  mul_assoc  :=  by\n  sorry\n  one  :=  QuotientMonoid.mk  N  1\n  one_mul  :=  by\n  sorry\n  mul_one  :=  by\n  sorry \n```"]