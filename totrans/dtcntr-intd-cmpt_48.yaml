- en: 16.1¬†Sharing and Equalityüîó
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://dcic-world.org/2025-08-27/Sharing_and_Equality.html](https://dcic-world.org/2025-08-27/Sharing_and_Equality.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| ¬†¬†¬†¬†[16.1.1¬†Re-Examining Equality](#%28part._identical-eq%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[16.1.2¬†The Cost of Evaluating References](#%28part._.The_.Cost_of_.Evaluating_.References%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[16.1.3¬†Notations for Equality](#%28part._equal-always%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[16.1.4¬†On the Internet, Nobody Knows You‚Äôre a DAG](#%28part._.On_the_.Internet__.Nobody_.Knows_.You_re_a_.D.A.G%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[16.1.5¬†It‚Äôs Always Been a DAG](#%28part._.It_s_.Always_.Been_a_.D.A.G%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[16.1.6¬†From Acyclicity to Cycles](#%28part._acyc-to-cyc%29) |'
  prefs: []
  type: TYPE_TB
- en: 16.1.1¬†Re-Examining Equality[üîó](#(part._identical-eq) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following data definition and example values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In particular, it might seem that the way we‚Äôve written `b-tree` is morally
    equivalent to how we‚Äôve written `a-tree`, but we‚Äôve created a helpful binding
    to avoid code duplication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because both `a-tree` and `b-tree` are bound to trees with `5` at the root
    and a left and right child each containing `4`, we can indeed reasonably consider
    these trees equivalent. Sure enough:'
  prefs: []
  type: TYPE_NORMAL
- en: <equal-tests> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: However, there is another sense in which these trees are not equivalent. concretely,
    `a-tree` constructs a distinct node for each child, while `b-tree` uses the same
    node for both children. Surely this difference should show up somehow, but we
    have not yet seen a way to write a program that will tell these apart.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `is` operator uses the same equality test as Pyret‚Äôs `==`.
    There are, however, other equality tests in Pyret. In particular, the way we can
    tell apart these data is by using Pyret‚Äôs `identical` function, which implements
    reference equality. This checks not only whether two values are structurally equivalent
    but whether they are the result of the very same act of value construction. With
    this, we can now write additional tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs step back for a moment and consider the behavior that gives us this result.
    We can visualize the different values by putting each distinct value in a separate
    location alongside the running program. We can draw the first step as creating
    a `node` with value `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: a-tree =
  prefs: []
  type: TYPE_NORMAL
- en: node(5,
  prefs: []
  type: TYPE_NORMAL
- en: 1001,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: node(4, leaf, leaf))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b-tree =
  prefs: []
  type: TYPE_NORMAL
- en: 'block:'
  prefs: []
  type: TYPE_NORMAL
- en: four-node = node(4, leaf, leaf)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: node(5,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: four-node,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: four-node)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1001:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step creates another node with value `4`, distinct from the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: a-tree =
  prefs: []
  type: TYPE_NORMAL
- en: node(5, 1001, 1002)
  prefs: []
  type: TYPE_NORMAL
- en: b-tree =
  prefs: []
  type: TYPE_NORMAL
- en: 'block:'
  prefs: []
  type: TYPE_NORMAL
- en: four-node = node(4, leaf, leaf)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: node(5,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: four-node,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: four-node)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1001:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1002:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then the `node` for `a-tree` is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: a-tree = 1003
  prefs: []
  type: TYPE_NORMAL
- en: b-tree =
  prefs: []
  type: TYPE_NORMAL
- en: 'block:'
  prefs: []
  type: TYPE_NORMAL
- en: four-node = node(4, leaf, leaf)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: node(5,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: four-node,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: four-node)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1001:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1002:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1003:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When evaluating the `block` for `b-tree`, first a single node is created for
    the `four-node` binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: a-tree = 1003
  prefs: []
  type: TYPE_NORMAL
- en: b-tree =
  prefs: []
  type: TYPE_NORMAL
- en: 'block:'
  prefs: []
  type: TYPE_NORMAL
- en: four-node = 1004
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: node(5,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: four-node,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: four-node)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1001:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1002:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1003:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1004:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These location values can be substituted just like any other, so they get substituted
    for `four-node` to continue evaluation of the block.We skipped substituting `a-tree`
    for the moment, that will come up later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: a-tree = 1003
  prefs: []
  type: TYPE_NORMAL
- en: b-tree =
  prefs: []
  type: TYPE_NORMAL
- en: 'block:'
  prefs: []
  type: TYPE_NORMAL
- en: node(5, 1004, 1004)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1001:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1002:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1003:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1004:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the node for `b-tree` is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: a-tree = 1003
  prefs: []
  type: TYPE_NORMAL
- en: b-tree = 1005
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1001:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1002:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1003:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1004:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1005:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This visualization can help us explain the test we wrote using `identical`.
    Let‚Äôs consider the test with the appropriate location references substituted for
    `a-tree` and `b-tree`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'check:'
  prefs: []
  type: TYPE_NORMAL
- en: identical(1003, 1005)
  prefs: []
  type: TYPE_NORMAL
- en: is false
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: identical(1003.l, 1003.l)
  prefs: []
  type: TYPE_NORMAL
- en: is true
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: identical(1003.l, 1003.r)
  prefs: []
  type: TYPE_NORMAL
- en: is false
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: identical(1005.l, 1005.r)
  prefs: []
  type: TYPE_NORMAL
- en: is true
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1001:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1002:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1003:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1004:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1005:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'check:'
  prefs: []
  type: TYPE_NORMAL
- en: identical(1003, 1005)
  prefs: []
  type: TYPE_NORMAL
- en: is false
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: identical(1001, 1001)
  prefs: []
  type: TYPE_NORMAL
- en: is true
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: identical(1001, 1004)
  prefs: []
  type: TYPE_NORMAL
- en: is false
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: identical(1004, 1004)
  prefs: []
  type: TYPE_NORMAL
- en: is true
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1001:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1002:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1003:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1004:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1005:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There is actually another way to write these tests in Pyret: the `is` operator
    can also be parameterized by a different equality predicate than the default `==`.
    Thus, the above block can equivalently be written as:We can use `is-not` to check
    for expected failure of equality.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We will use this style of equality testing from now on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe how these are the same values that were compared earlier ([<equal-tests>](#%28elem._equal-tests%29)),
    but the results are now different: some values that were true earlier are now
    false. In particular,'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Later we will return both to what `identical` really means [[Understanding Equality](unified-equality.html)]
    (Pyret has a full range of equality operations suitable for different situations).
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There are many more equality tests we can and should perform even with the basic
    data above to make sure we really understand equality and, relatedly, storage
    of data in memory. What other tests should we conduct? Predict what results they
    should produce before running them!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 16.1.2¬†The Cost of Evaluating References[üîó](#(part._.The_.Cost_of_.Evaluating_.References)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'From a complexity viewpoint, it‚Äôs important for us to understand how these
    references work. As we have hinted, `four-node` is computed only once, and each
    use of it refers to the same value: if, instead, it was evaluated each time we
    referred to `four-node`, there would be no real difference between `a-tree` and
    `b-tree`, and the above tests would not distinguish between them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is especially relevant when understanding the cost of function evaluation.
    We‚Äôll construct two simple examples that illustrate this. We‚Äôll begin with a contrived
    data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Suppose we now define
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Constructing a list clearly takes time at least proportional to the length;
    therefore, we expect the time to compute `L` to be considerably more than that
    for a single `link` operation. Therefore, the question is how long it takes to
    compute `L1` and `L2` after `L` has been computed: constant time, or time proportional
    to the length of `L`?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer, for Pyret, and for most other contemporary languages (including
    Java, C#, OCaml, Racket, etc.), is that these additional computations take constant
    time. That is, the value bound to `L` is computed once and bound to `L`; subsequent
    expressions refer to this value (hence ‚Äúreference‚Äù) rather than reconstructing
    it, as reference equality shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can define a function, pass `L` to it, and see whether the resulting
    argument is `identical` to the original:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: or, equivalently,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, neither built-in operations (like `.rest`) nor user-defined ones
    (like `check-for-no-copy`) make copies of their arguments.Strictly speaking, of
    course, we cannot conclude that no copy was made. Pyret could have made a copy,
    discarded it, and still passed a reference to the original. Given how perverse
    this would be, we can assume‚Äî<wbr>and take the language‚Äôs creators‚Äô word for it‚Äî<wbr>that
    this doesn‚Äôt actually happen. By creating extremely large lists, we can also use
    timing information to observe that the time of constructing the list grows proportional
    to the length of the list while the time of passing it as a parameter remains
    constant. The important thing to observe here is that, instead of simply relying
    on authority, we have used operations in the language itself to understand how
    the language behaves.
  prefs: []
  type: TYPE_NORMAL
- en: 16.1.3¬†Notations for Equality[üîó](#(part._equal-always) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Until now we have used `==` for equality. Now we have learned that it‚Äôs only
    one of multiple equality operators, and that there is another one called `identical`.
    However, these two have somewhat subtly different syntactic properties. `identical`
    is a name for a function, which can therefore be used to refer to it like any
    other function (e.g., when we need to mention it in a `is-not` clause). In contrast,
    `==` is a binary operator, which can only be used in the middle of expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This should naturally make us wonder about the other two possibilities: a binary
    expression version of `identical` and a function name equivalent of `==`. They
    do, in fact, exist! The operation performed by `==` is called `equal-always`.
    Therefore, we can write the first block of tests equivalently, but more explicitly,
    as'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Conversely, the binary operator notation for `identical` is `<=>`. Thus, we
    can equivalently write `check-for-no-copy` as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 16.1.4¬†On the Internet, Nobody Knows You‚Äôre a DAG[üîó](#(part._.On_the_.Internet__.Nobody_.Knows_.You_re_a_.D.A.G)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Despite the name we‚Äôve given it, `b-tree` is not actually a tree. In a tree,
    by definition, there are no shared nodes, whereas in `b-tree` the node named by
    `four-node` is shared by two parts of the tree. Despite this, traversing `b-tree`
    will still terminate, because there are no cyclic references in it: if you start
    from any node and visit its ‚Äúchildren‚Äù, you cannot end up back at that node. There
    is a special name for a value with such a shape: directed acyclic graph (DAG).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many important data structures are actually a DAG underneath. For instance,
    consider Web sites. It is common to think of a site as a tree of pages: the top-level
    refers to several sections, each of which refers to sub-sections, and so on. However,
    sometimes an entry needs to be cataloged under multiple sections. For instance,
    an academic department might organize pages by people, teaching, and research.
    In the first of these pages it lists the people who work there; in the second,
    the list of courses; and in the third, the list of research groups. In turn, the
    courses might have references to the people teaching them, and the research groups
    are populated by these same people. Since we want only one page per person (for
    both maintenance and search indexing purposes), all these personnel links refer
    back to the same page for people.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs construct a simple form of this. First a datatype to represent a site‚Äôs
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs now define a few people:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'and a way to extract a particular person‚Äôs page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can define theory and systems sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'which are integrated into a site as a whole:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can confirm that each of these luminaries needs to keep only one Web
    page current; for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 16.1.5¬†It‚Äôs Always Been a DAG[üîó](#(part._.It_s_.Always_.Been_a_.D.A.G) "Link
    to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What we may not realize is that we‚Äôve actually been creating a DAG for longer
    than we think. To see this, consider `a-tree`, which very clearly seems to be
    a tree. But look more closely not at the `node`s but rather at the `leaf`(s).
    How many actual `leaf`s do we create?
  prefs: []
  type: TYPE_NORMAL
- en: 'One hint is that we don‚Äôt seem to call a function when creating a `leaf`: the
    data definition does not list any fields, and when constructing a `BT` value,
    we simply write `leaf`, not (say) `leaf()`. Still, it would be nice to know what
    is happening behind the scenes. To check, we can simply ask Pyret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'It‚Äôs important that we not write `leaf <=> leaf` here, because that is just
    an expression whose result is ignored. We have to write `is` to register this
    as a test whose result is checked and reported. and this check passes. That is,
    when we write a variant without any fields, Pyret automatically creates a singleton:
    it makes just one instance and uses that instance everywhere. This leads to a
    more efficient memory representation, because there is no reason to have lots
    of distinct `leaf`s each taking up their own memory. However, a subtle consequence
    of that is that we have been creating a DAG all along.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we really wanted each `leaf` to be distinct, it‚Äôs easy: we can write'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we would need to use the `leaf` function everywhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'And sure enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 16.1.6¬†From Acyclicity to Cycles[üîó](#(part._acyc-to-cyc) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here‚Äôs another example that arises on the Web. Suppose we are constructing
    a table of output in a Web page. We would like the rows of the table to alternate
    between white and grey. If the table had only two rows, we could map the row-generating
    function over a list of these two colors. Since we do not know how many rows it
    will have, however, we would like the list to be as long as necessary. In effect,
    we would like to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: to obtain an indefinitely long list, so that we could eventually write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'which applies a `color-table-row` function to two arguments: the current row
    from `table-row-content`, and the current color from `web-colors`, proceeding
    in lockstep over the two lists.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, there are many things wrong with this attempted definition.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see what they are?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here are some problems in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: This will not even parse. The identifier `web-colors` is not bound on the right
    of the `=`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Earlier, we saw a solution to such a problem: use `rec` [[Streams From Functions](func-as-data.html#%28part._streams-from-funs%29)].
    What happens if we write'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: instead?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does `rec` work in the definition of `ones` but not above?
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Assuming we have fixed the above problem, one of two things will happen. It
    depends on what the initial value of `web-colors` is. Because it is a dummy value,
    we do not get an arbitrarily long list of colors but rather a list of two colors
    followed by the dummy value. Indeed, this program will not even type-check.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose, however, that `web-colors` were written instead as a function definition
    to delay its creation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On its own this just defines a function. If, however, we use it‚Äî<wbr>`web-colors()`‚Äî<wbr>it
    goes into an infinite loop constructing `link`s.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Even if all that were to work, `map2` would either (a) not terminate because
    its second argument is indefinitely long, or (b) report an error because the two
    arguments aren‚Äôt the same length.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these problems are symptoms of a bigger issue. What we are trying to do
    here is not merely create a shared datum (like a DAG) but something much richer:
    a cyclic datum, i.e., one that refers back to itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/e8661971bf1b4ec52d4a6cfb124b63a2.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: When you get to cycles, even defining the datum becomes difficult because its
    definition depends on itself so it (seemingly) needs to already be defined in
    the process of being defined. We will return to cyclic data later in [Cyclic Data](unified-cyclic-data.html),
    and to this specific example in [Recursion and Cycles from Mutation](rec-from-mut.html).
  prefs: []
  type: TYPE_NORMAL
- en: 16.1.1¬†Re-Examining Equality[üîó](#(part._identical-eq) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following data definition and example values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: In particular, it might seem that the way we‚Äôve written `b-tree` is morally
    equivalent to how we‚Äôve written `a-tree`, but we‚Äôve created a helpful binding
    to avoid code duplication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because both `a-tree` and `b-tree` are bound to trees with `5` at the root
    and a left and right child each containing `4`, we can indeed reasonably consider
    these trees equivalent. Sure enough:'
  prefs: []
  type: TYPE_NORMAL
- en: <equal-tests> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: However, there is another sense in which these trees are not equivalent. concretely,
    `a-tree` constructs a distinct node for each child, while `b-tree` uses the same
    node for both children. Surely this difference should show up somehow, but we
    have not yet seen a way to write a program that will tell these apart.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `is` operator uses the same equality test as Pyret‚Äôs `==`.
    There are, however, other equality tests in Pyret. In particular, the way we can
    tell apart these data is by using Pyret‚Äôs `identical` function, which implements
    reference equality. This checks not only whether two values are structurally equivalent
    but whether they are the result of the very same act of value construction. With
    this, we can now write additional tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs step back for a moment and consider the behavior that gives us this result.
    We can visualize the different values by putting each distinct value in a separate
    location alongside the running program. We can draw the first step as creating
    a `node` with value `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: a-tree =
  prefs: []
  type: TYPE_NORMAL
- en: node(5,
  prefs: []
  type: TYPE_NORMAL
- en: 1001,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: node(4, leaf, leaf))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b-tree =
  prefs: []
  type: TYPE_NORMAL
- en: 'block:'
  prefs: []
  type: TYPE_NORMAL
- en: four-node = node(4, leaf, leaf)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: node(5,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: four-node,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: four-node)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1001:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step creates another node with value `4`, distinct from the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: a-tree =
  prefs: []
  type: TYPE_NORMAL
- en: node(5, 1001, 1002)
  prefs: []
  type: TYPE_NORMAL
- en: b-tree =
  prefs: []
  type: TYPE_NORMAL
- en: 'block:'
  prefs: []
  type: TYPE_NORMAL
- en: four-node = node(4, leaf, leaf)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: node(5,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: four-node,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: four-node)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1001:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1002:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then the `node` for `a-tree` is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: a-tree = 1003
  prefs: []
  type: TYPE_NORMAL
- en: b-tree =
  prefs: []
  type: TYPE_NORMAL
- en: 'block:'
  prefs: []
  type: TYPE_NORMAL
- en: four-node = node(4, leaf, leaf)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: node(5,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: four-node,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: four-node)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1001:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1002:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1003:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When evaluating the `block` for `b-tree`, first a single node is created for
    the `four-node` binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: a-tree = 1003
  prefs: []
  type: TYPE_NORMAL
- en: b-tree =
  prefs: []
  type: TYPE_NORMAL
- en: 'block:'
  prefs: []
  type: TYPE_NORMAL
- en: four-node = 1004
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: node(5,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: four-node,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: four-node)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1001:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1002:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1003:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1004:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These location values can be substituted just like any other, so they get substituted
    for `four-node` to continue evaluation of the block.We skipped substituting `a-tree`
    for the moment, that will come up later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: a-tree = 1003
  prefs: []
  type: TYPE_NORMAL
- en: b-tree =
  prefs: []
  type: TYPE_NORMAL
- en: 'block:'
  prefs: []
  type: TYPE_NORMAL
- en: node(5, 1004, 1004)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1001:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1002:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1003:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1004:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the node for `b-tree` is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: a-tree = 1003
  prefs: []
  type: TYPE_NORMAL
- en: b-tree = 1005
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1001:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1002:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1003:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1004:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1005:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This visualization can help us explain the test we wrote using `identical`.
    Let‚Äôs consider the test with the appropriate location references substituted for
    `a-tree` and `b-tree`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'check:'
  prefs: []
  type: TYPE_NORMAL
- en: identical(1003, 1005)
  prefs: []
  type: TYPE_NORMAL
- en: is false
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: identical(1003.l, 1003.l)
  prefs: []
  type: TYPE_NORMAL
- en: is true
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: identical(1003.l, 1003.r)
  prefs: []
  type: TYPE_NORMAL
- en: is false
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: identical(1005.l, 1005.r)
  prefs: []
  type: TYPE_NORMAL
- en: is true
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1001:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1002:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1003:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1004:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1005:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'check:'
  prefs: []
  type: TYPE_NORMAL
- en: identical(1003, 1005)
  prefs: []
  type: TYPE_NORMAL
- en: is false
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: identical(1001, 1001)
  prefs: []
  type: TYPE_NORMAL
- en: is true
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: identical(1001, 1004)
  prefs: []
  type: TYPE_NORMAL
- en: is false
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: identical(1004, 1004)
  prefs: []
  type: TYPE_NORMAL
- en: is true
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1001:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1002:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1003:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1004:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1005:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There is actually another way to write these tests in Pyret: the `is` operator
    can also be parameterized by a different equality predicate than the default `==`.
    Thus, the above block can equivalently be written as:We can use `is-not` to check
    for expected failure of equality.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: We will use this style of equality testing from now on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe how these are the same values that were compared earlier ([<equal-tests>](#%28elem._equal-tests%29)),
    but the results are now different: some values that were true earlier are now
    false. In particular,'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Later we will return both to what `identical` really means [[Understanding Equality](unified-equality.html)]
    (Pyret has a full range of equality operations suitable for different situations).
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There are many more equality tests we can and should perform even with the basic
    data above to make sure we really understand equality and, relatedly, storage
    of data in memory. What other tests should we conduct? Predict what results they
    should produce before running them!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 16.1.2¬†The Cost of Evaluating References[üîó](#(part._.The_.Cost_of_.Evaluating_.References)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'From a complexity viewpoint, it‚Äôs important for us to understand how these
    references work. As we have hinted, `four-node` is computed only once, and each
    use of it refers to the same value: if, instead, it was evaluated each time we
    referred to `four-node`, there would be no real difference between `a-tree` and
    `b-tree`, and the above tests would not distinguish between them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is especially relevant when understanding the cost of function evaluation.
    We‚Äôll construct two simple examples that illustrate this. We‚Äôll begin with a contrived
    data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Suppose we now define
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Constructing a list clearly takes time at least proportional to the length;
    therefore, we expect the time to compute `L` to be considerably more than that
    for a single `link` operation. Therefore, the question is how long it takes to
    compute `L1` and `L2` after `L` has been computed: constant time, or time proportional
    to the length of `L`?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer, for Pyret, and for most other contemporary languages (including
    Java, C#, OCaml, Racket, etc.), is that these additional computations take constant
    time. That is, the value bound to `L` is computed once and bound to `L`; subsequent
    expressions refer to this value (hence ‚Äúreference‚Äù) rather than reconstructing
    it, as reference equality shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can define a function, pass `L` to it, and see whether the resulting
    argument is `identical` to the original:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: or, equivalently,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, neither built-in operations (like `.rest`) nor user-defined ones
    (like `check-for-no-copy`) make copies of their arguments.Strictly speaking, of
    course, we cannot conclude that no copy was made. Pyret could have made a copy,
    discarded it, and still passed a reference to the original. Given how perverse
    this would be, we can assume‚Äî<wbr>and take the language‚Äôs creators‚Äô word for it‚Äî<wbr>that
    this doesn‚Äôt actually happen. By creating extremely large lists, we can also use
    timing information to observe that the time of constructing the list grows proportional
    to the length of the list while the time of passing it as a parameter remains
    constant. The important thing to observe here is that, instead of simply relying
    on authority, we have used operations in the language itself to understand how
    the language behaves.
  prefs: []
  type: TYPE_NORMAL
- en: 16.1.3¬†Notations for Equality[üîó](#(part._equal-always) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Until now we have used `==` for equality. Now we have learned that it‚Äôs only
    one of multiple equality operators, and that there is another one called `identical`.
    However, these two have somewhat subtly different syntactic properties. `identical`
    is a name for a function, which can therefore be used to refer to it like any
    other function (e.g., when we need to mention it in a `is-not` clause). In contrast,
    `==` is a binary operator, which can only be used in the middle of expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This should naturally make us wonder about the other two possibilities: a binary
    expression version of `identical` and a function name equivalent of `==`. They
    do, in fact, exist! The operation performed by `==` is called `equal-always`.
    Therefore, we can write the first block of tests equivalently, but more explicitly,
    as'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Conversely, the binary operator notation for `identical` is `<=>`. Thus, we
    can equivalently write `check-for-no-copy` as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 16.1.4¬†On the Internet, Nobody Knows You‚Äôre a DAG[üîó](#(part._.On_the_.Internet__.Nobody_.Knows_.You_re_a_.D.A.G)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Despite the name we‚Äôve given it, `b-tree` is not actually a tree. In a tree,
    by definition, there are no shared nodes, whereas in `b-tree` the node named by
    `four-node` is shared by two parts of the tree. Despite this, traversing `b-tree`
    will still terminate, because there are no cyclic references in it: if you start
    from any node and visit its ‚Äúchildren‚Äù, you cannot end up back at that node. There
    is a special name for a value with such a shape: directed acyclic graph (DAG).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many important data structures are actually a DAG underneath. For instance,
    consider Web sites. It is common to think of a site as a tree of pages: the top-level
    refers to several sections, each of which refers to sub-sections, and so on. However,
    sometimes an entry needs to be cataloged under multiple sections. For instance,
    an academic department might organize pages by people, teaching, and research.
    In the first of these pages it lists the people who work there; in the second,
    the list of courses; and in the third, the list of research groups. In turn, the
    courses might have references to the people teaching them, and the research groups
    are populated by these same people. Since we want only one page per person (for
    both maintenance and search indexing purposes), all these personnel links refer
    back to the same page for people.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs construct a simple form of this. First a datatype to represent a site‚Äôs
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs now define a few people:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'and a way to extract a particular person‚Äôs page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can define theory and systems sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'which are integrated into a site as a whole:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can confirm that each of these luminaries needs to keep only one Web
    page current; for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 16.1.5¬†It‚Äôs Always Been a DAG[üîó](#(part._.It_s_.Always_.Been_a_.D.A.G) "Link
    to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What we may not realize is that we‚Äôve actually been creating a DAG for longer
    than we think. To see this, consider `a-tree`, which very clearly seems to be
    a tree. But look more closely not at the `node`s but rather at the `leaf`(s).
    How many actual `leaf`s do we create?
  prefs: []
  type: TYPE_NORMAL
- en: 'One hint is that we don‚Äôt seem to call a function when creating a `leaf`: the
    data definition does not list any fields, and when constructing a `BT` value,
    we simply write `leaf`, not (say) `leaf()`. Still, it would be nice to know what
    is happening behind the scenes. To check, we can simply ask Pyret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'It‚Äôs important that we not write `leaf <=> leaf` here, because that is just
    an expression whose result is ignored. We have to write `is` to register this
    as a test whose result is checked and reported. and this check passes. That is,
    when we write a variant without any fields, Pyret automatically creates a singleton:
    it makes just one instance and uses that instance everywhere. This leads to a
    more efficient memory representation, because there is no reason to have lots
    of distinct `leaf`s each taking up their own memory. However, a subtle consequence
    of that is that we have been creating a DAG all along.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we really wanted each `leaf` to be distinct, it‚Äôs easy: we can write'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we would need to use the `leaf` function everywhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'And sure enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 16.1.6¬†From Acyclicity to Cycles[üîó](#(part._acyc-to-cyc) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here‚Äôs another example that arises on the Web. Suppose we are constructing
    a table of output in a Web page. We would like the rows of the table to alternate
    between white and grey. If the table had only two rows, we could map the row-generating
    function over a list of these two colors. Since we do not know how many rows it
    will have, however, we would like the list to be as long as necessary. In effect,
    we would like to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: to obtain an indefinitely long list, so that we could eventually write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'which applies a `color-table-row` function to two arguments: the current row
    from `table-row-content`, and the current color from `web-colors`, proceeding
    in lockstep over the two lists.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, there are many things wrong with this attempted definition.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see what they are?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here are some problems in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: This will not even parse. The identifier `web-colors` is not bound on the right
    of the `=`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Earlier, we saw a solution to such a problem: use `rec` [[Streams From Functions](func-as-data.html#%28part._streams-from-funs%29)].
    What happens if we write'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: instead?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does `rec` work in the definition of `ones` but not above?
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Assuming we have fixed the above problem, one of two things will happen. It
    depends on what the initial value of `web-colors` is. Because it is a dummy value,
    we do not get an arbitrarily long list of colors but rather a list of two colors
    followed by the dummy value. Indeed, this program will not even type-check.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose, however, that `web-colors` were written instead as a function definition
    to delay its creation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On its own this just defines a function. If, however, we use it‚Äî<wbr>`web-colors()`‚Äî<wbr>it
    goes into an infinite loop constructing `link`s.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Even if all that were to work, `map2` would either (a) not terminate because
    its second argument is indefinitely long, or (b) report an error because the two
    arguments aren‚Äôt the same length.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these problems are symptoms of a bigger issue. What we are trying to do
    here is not merely create a shared datum (like a DAG) but something much richer:
    a cyclic datum, i.e., one that refers back to itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/e8661971bf1b4ec52d4a6cfb124b63a2.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: When you get to cycles, even defining the datum becomes difficult because its
    definition depends on itself so it (seemingly) needs to already be defined in
    the process of being defined. We will return to cyclic data later in [Cyclic Data](unified-cyclic-data.html),
    and to this specific example in [Recursion and Cycles from Mutation](rec-from-mut.html).
  prefs: []
  type: TYPE_NORMAL
