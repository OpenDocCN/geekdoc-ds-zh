- en: 16.1Â Sharing and EqualityğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.1Â å…±äº«ä¸ç­‰ä»·æ€§[ğŸ”—](#(part._.Sharing_and_Equality))
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/Sharing_and_Equality.html](https://dcic-world.org/2025-08-27/Sharing_and_Equality.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/Sharing_and_Equality.html](https://dcic-world.org/2025-08-27/Sharing_and_Equality.html)
- en: '| Â Â Â Â [16.1.1Â Re-Examining Equality](#%28part._identical-eq%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [16.1.1Â é‡æ–°å®¡è§†ç­‰ä»·æ€§](#%28part._identical-eq%29) |'
- en: '| Â Â Â Â [16.1.2Â The Cost of Evaluating References](#%28part._.The_.Cost_of_.Evaluating_.References%29)
    |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [16.1.2Â è¯„ä¼°å¼•ç”¨çš„æˆæœ¬](#%28part._.The_.Cost_of_.Evaluating_.References%29) |'
- en: '| Â Â Â Â [16.1.3Â Notations for Equality](#%28part._equal-always%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [16.1.3Â ç­‰ä»·æ€§çš„è¡¨ç¤ºæ³•](#%28part._equal-always%29) |'
- en: '| Â Â Â Â [16.1.4Â On the Internet, Nobody Knows Youâ€™re a DAG](#%28part._.On_the_.Internet__.Nobody_.Knows_.You_re_a_.D.A.G%29)
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [16.1.4Â åœ¨äº’è”ç½‘ä¸Šï¼Œæ²¡æœ‰äººçŸ¥é“ä½ æ˜¯ä¸€ä¸ªæœ‰å‘æ— ç¯å›¾](#%28part._.On_the_.Internet__.Nobody_.Knows_.You_re_a_.D.A.G%29)
    |'
- en: '| Â Â Â Â [16.1.5Â Itâ€™s Always Been a DAG](#%28part._.It_s_.Always_.Been_a_.D.A.G%29)
    |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [16.1.5Â å®ƒä¸€ç›´æ˜¯ DAG](#%28part._.It_s_.Always_.Been_a_.D.A.G%29) |'
- en: '| Â Â Â Â [16.1.6Â From Acyclicity to Cycles](#%28part._acyc-to-cyc%29) |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [16.1.6Â ä»æ— ç¯åˆ°ç¯](#%28part._acyc-to-cyc%29) |'
- en: 16.1.1Â Re-Examining Equality[ğŸ”—](#(part._identical-eq) "Link to here")
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.1Â é‡æ–°å®¡è§†ç­‰ä»·æ€§[ğŸ”—](#(part._identical-eq) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Consider the following data definition and example values:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘ä»¥ä¸‹æ•°æ®å®šä¹‰å’Œç¤ºä¾‹å€¼ï¼š
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In particular, it might seem that the way weâ€™ve written `b-tree` is morally
    equivalent to how weâ€™ve written `a-tree`, but weâ€™ve created a helpful binding
    to avoid code duplication.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ç‰¹åˆ«æ˜¯ï¼Œæˆ‘ä»¬å¯èƒ½è§‰å¾—æˆ‘ä»¬ç¼–å†™çš„ `b-tree` ä¸æˆ‘ä»¬ç¼–å†™çš„ `a-tree` åœ¨é“å¾·ä¸Šæ˜¯ç­‰ä»·çš„ï¼Œä½†æˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªæœ‰ç”¨çš„ç»‘å®šæ¥é¿å…ä»£ç é‡å¤ã€‚
- en: 'Because both `a-tree` and `b-tree` are bound to trees with `5` at the root
    and a left and right child each containing `4`, we can indeed reasonably consider
    these trees equivalent. Sure enough:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸º `a-tree` å’Œ `b-tree` éƒ½ç»‘å®šåˆ°æ ¹å€¼ä¸º `5` ä¸”å·¦å³å­èŠ‚ç‚¹å„åŒ…å« `4` çš„æ ‘ï¼Œæ‰€ä»¥æˆ‘ä»¬ç¡®å®å¯ä»¥åˆç†åœ°è®¤ä¸ºè¿™äº›æ ‘æ˜¯ç­‰ä»·çš„ã€‚ç¡®å®å¦‚æ­¤ï¼š
- en: <equal-tests> ::=
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <equal-tests> ::=
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: However, there is another sense in which these trees are not equivalent. concretely,
    `a-tree` constructs a distinct node for each child, while `b-tree` uses the same
    node for both children. Surely this difference should show up somehow, but we
    have not yet seen a way to write a program that will tell these apart.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œè¿™äº›æ ‘åœ¨å¦ä¸€ç§æ„ä¹‰ä¸Šå¹¶ä¸ç­‰ä»·ã€‚å…·ä½“æ¥è¯´ï¼Œ`a-tree` ä¸ºæ¯ä¸ªå­èŠ‚ç‚¹æ„å»ºäº†ä¸€ä¸ªä¸åŒçš„èŠ‚ç‚¹ï¼Œè€Œ `b-tree` ä½¿ç”¨ç›¸åŒçš„èŠ‚ç‚¹ä¸ºä¸¤ä¸ªå­èŠ‚ç‚¹æœåŠ¡ã€‚å½“ç„¶ï¼Œè¿™ç§å·®å¼‚åº”è¯¥ä»¥æŸç§æ–¹å¼ä½“ç°å‡ºæ¥ï¼Œä½†æˆ‘ä»¬è¿˜æ²¡æœ‰çœ‹åˆ°ä¸€ç§ç¼–å†™ç¨‹åºæ¥åŒºåˆ†è¿™äº›çš„æ–¹æ³•ã€‚
- en: 'By default, the `is` operator uses the same equality test as Pyretâ€™s `==`.
    There are, however, other equality tests in Pyret. In particular, the way we can
    tell apart these data is by using Pyretâ€™s `identical` function, which implements
    reference equality. This checks not only whether two values are structurally equivalent
    but whether they are the result of the very same act of value construction. With
    this, we can now write additional tests:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: é»˜è®¤æƒ…å†µä¸‹ï¼Œ`is` æ“ä½œç¬¦ä½¿ç”¨ä¸ Pyret çš„ `==` ç›¸åŒçš„ç­‰ä»·æ€§æµ‹è¯•ã€‚ç„¶è€Œï¼ŒPyret ä¸­è¿˜æœ‰å…¶ä»–ç­‰ä»·æ€§æµ‹è¯•ã€‚ç‰¹åˆ«æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨ Pyret
    çš„ `identical` å‡½æ•°æ¥åŒºåˆ†è¿™äº›æ•°æ®ï¼Œè¯¥å‡½æ•°å®ç°äº†å¼•ç”¨ç­‰ä»·æ€§ã€‚è¿™ä¸ä»…æ£€æŸ¥ä¸¤ä¸ªå€¼åœ¨ç»“æ„ä¸Šæ˜¯å¦ç­‰ä»·ï¼Œè¿˜æ£€æŸ¥å®ƒä»¬æ˜¯å¦æ˜¯ç›¸åŒçš„å€¼æ„é€ è¡Œä¸ºçš„ç»“æœã€‚æœ‰äº†è¿™ä¸ªï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥ç¼–å†™é¢å¤–çš„æµ‹è¯•ï¼š
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Letâ€™s step back for a moment and consider the behavior that gives us this result.
    We can visualize the different values by putting each distinct value in a separate
    location alongside the running program. We can draw the first step as creating
    a `node` with value `4`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æš‚æ—¶é€€ä¸€æ­¥ï¼Œè€ƒè™‘ç»™æˆ‘ä»¬è¿™ä¸ªç»“æœçš„è¡Œä¸ºã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡å°†æ¯ä¸ªä¸åŒçš„å€¼æ”¾ç½®åœ¨è¿è¡Œç¨‹åºæ—è¾¹çš„å•ç‹¬ä½ç½®æ¥å¯è§†åŒ–ä¸åŒçš„å€¼ã€‚æˆ‘ä»¬å¯ä»¥å°†ç¬¬ä¸€æ­¥ç»˜åˆ¶ä¸ºåˆ›å»ºä¸€ä¸ªå€¼ä¸º
    `4` çš„ `node`ï¼š
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: a-tree =
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: a-tree =
- en: node(5,
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: node(5,
- en: 1001,
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1001,
- en: node(4, leaf, leaf))
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: node(4, leaf, leaf))
- en: b-tree =
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: b-tree =
- en: 'block:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 'block:'
- en: four-node = node(4, leaf, leaf)
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: four-node = node(4, leaf, leaf)
- en: node(5,
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: node(5,
- en: four-node,
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: four-node,
- en: four-node)
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: four-node)
- en: end
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: end
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Heap
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Heap
- en: '1001:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1001:'
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next step creates another node with value `4`, distinct from the first:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹ä¸€æ­¥åˆ›å»ºäº†ä¸€ä¸ªå…·æœ‰å€¼ `4` çš„å¦ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä¸ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ä¸åŒï¼š
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: a-tree =
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: a-tree =
- en: node(5, 1001, 1002)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: node(5, 1001, 1002)
- en: b-tree =
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: b-tree =
- en: 'block:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 'block:'
- en: four-node = node(4, leaf, leaf)
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: four-node = node(4, leaf, leaf)
- en: node(5,
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: node(5,
- en: four-node,
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: four-node,
- en: four-node)
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: four-node)
- en: end
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: end
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Heap
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Heap
- en: '1001:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1001:'
- en: '[PRE8]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '1002:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1002:'
- en: '[PRE9]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then the `node` for `a-tree` is created:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶ååˆ›å»ºäº† `a-tree` çš„ `node`ï¼š
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: a-tree = 1003
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: a-tree = 1003
- en: b-tree =
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: b-tree =
- en: 'block:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 'block:'
- en: four-node = node(4, leaf, leaf)
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: four-node = node(4, leaf, leaf)
- en: node(5,
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: node(5,
- en: four-node,
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: four-node,
- en: four-node)
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: four-node)
- en: end
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: end
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Heap
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Heap
- en: '1001:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1001:'
- en: '[PRE12]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '1002:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1002:'
- en: '[PRE13]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '1003:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1003:'
- en: '[PRE14]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When evaluating the `block` for `b-tree`, first a single node is created for
    the `four-node` binding:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: å½“è¯„ä¼° `b-tree` çš„ `block` æ—¶ï¼Œé¦–å…ˆä¸º `four-node` ç»‘å®šåˆ›å»ºä¸€ä¸ªå•ç‹¬çš„èŠ‚ç‚¹ï¼š
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: a-tree = 1003
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: a-tree = 1003
- en: b-tree =
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: b-tree =
- en: 'block:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 'block:'
- en: four-node = 1004
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: four-node = 1004
- en: node(5,
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: node(5,
- en: four-node,
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: four-node,
- en: four-node)
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: four-node)
- en: end
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: end
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Heap
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Heap
- en: '1001:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1001:'
- en: '[PRE17]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '1002:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1002:'
- en: '[PRE18]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '1003:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1003:'
- en: '[PRE19]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '1004:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1004:'
- en: '[PRE20]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These location values can be substituted just like any other, so they get substituted
    for `four-node` to continue evaluation of the block.We skipped substituting `a-tree`
    for the moment, that will come up later.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›ä½ç½®å€¼å¯ä»¥åƒä»»ä½•å…¶ä»–å€¼ä¸€æ ·æ›¿æ¢ï¼Œå› æ­¤å®ƒä»¬è¢«æ›¿æ¢ä¸º`four-node`ä»¥ç»§ç»­å—çš„è¯„ä¼°ã€‚æˆ‘ä»¬æš‚æ—¶è·³è¿‡äº†æ›¿æ¢`a-tree`ï¼Œè¿™å°†åœ¨ç¨åå‡ºç°ã€‚
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: a-tree = 1003
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: a-tree = 1003
- en: b-tree =
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: b-tree =
- en: 'block:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 'block:'
- en: node(5, 1004, 1004)
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: node(5, 1004, 1004)
- en: end
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: end
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Heap
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1001:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1001:'
- en: '[PRE23]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '1002:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1002:'
- en: '[PRE24]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '1003:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1003:'
- en: '[PRE25]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '1004:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1004:'
- en: '[PRE26]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, the node for `b-tree` is created:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œåˆ›å»ºäº†`b-tree`çš„èŠ‚ç‚¹ï¼š
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: a-tree = 1003
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: a-tree = 1003
- en: b-tree = 1005
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: b-tree = 1005
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Heap
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1001:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1001:'
- en: '[PRE29]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '1002:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1002:'
- en: '[PRE30]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '1003:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1003:'
- en: '[PRE31]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '1004:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1004:'
- en: '[PRE32]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '1005:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1005:'
- en: '[PRE33]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This visualization can help us explain the test we wrote using `identical`.
    Letâ€™s consider the test with the appropriate location references substituted for
    `a-tree` and `b-tree`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§å¯è§†åŒ–å¯ä»¥å¸®åŠ©æˆ‘ä»¬è§£é‡Šä½¿ç”¨`identical`ç¼–å†™çš„æµ‹è¯•ã€‚è®©æˆ‘ä»¬è€ƒè™‘ç”¨é€‚å½“çš„å¼•ç”¨ä½ç½®æ›¿æ¢`a-tree`å’Œ`b-tree`çš„æµ‹è¯•ï¼š
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'check:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 'check:'
- en: identical(1003, 1005)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: identical(1003, 1005)
- en: is false
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: is false
- en: identical(1003.l, 1003.l)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: identical(1003.l, 1003.l)
- en: is true
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: is true
- en: identical(1003.l, 1003.r)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: identical(1003.l, 1003.r)
- en: is false
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: is false
- en: identical(1005.l, 1005.r)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: identical(1005.l, 1005.r)
- en: is true
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: is true
- en: end
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: end
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Heap
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1001:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1001:'
- en: '[PRE36]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '1002:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1002:'
- en: '[PRE37]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '1003:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1003:'
- en: '[PRE38]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '1004:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1004:'
- en: '[PRE39]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '1005:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1005:'
- en: '[PRE40]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'check:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 'check:'
- en: identical(1003, 1005)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: identical(1003, 1005)
- en: is false
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: is false
- en: identical(1001, 1001)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: identical(1001, 1001)
- en: is true
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: is true
- en: identical(1001, 1004)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: identical(1001, 1004)
- en: is false
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: is false
- en: identical(1004, 1004)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: identical(1004, 1004)
- en: is true
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: is true
- en: end
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: end
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Heap
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1001:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1001:'
- en: '[PRE43]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '1002:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1002:'
- en: '[PRE44]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '1003:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1003:'
- en: '[PRE45]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '1004:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1004:'
- en: '[PRE46]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '1005:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1005:'
- en: '[PRE47]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'There is actually another way to write these tests in Pyret: the `is` operator
    can also be parameterized by a different equality predicate than the default `==`.
    Thus, the above block can equivalently be written as:We can use `is-not` to check
    for expected failure of equality.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šï¼Œåœ¨Pyretä¸­è¿˜æœ‰å¦ä¸€ç§ç¼–å†™è¿™äº›æµ‹è¯•çš„æ–¹æ³•ï¼š`is`è¿ç®—ç¬¦ä¹Ÿå¯ä»¥é€šè¿‡ä¸åŒçš„ç›¸ç­‰æ€§è°“è¯æ¥å‚æ•°åŒ–ï¼Œè€Œä¸æ˜¯é»˜è®¤çš„`==`ã€‚å› æ­¤ï¼Œä¸Šè¿°å—å¯ä»¥ç­‰ä»·åœ°å†™æˆï¼šæˆ‘ä»¬å¯ä»¥ä½¿ç”¨`is-not`æ¥æ£€æŸ¥é¢„æœŸçš„ç›¸ç­‰æ€§å¤±è´¥ã€‚
- en: '[PRE48]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We will use this style of equality testing from now on.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†ä»æ­¤ä½¿ç”¨è¿™ç§ç›¸ç­‰æ€§æµ‹è¯•é£æ ¼ã€‚
- en: 'Observe how these are the same values that were compared earlier ([<equal-tests>](#%28elem._equal-tests%29)),
    but the results are now different: some values that were true earlier are now
    false. In particular,'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: è§‚å¯Ÿè¿™äº›å€¼æ˜¯å¦ä¸ä¹‹å‰æ¯”è¾ƒçš„ç›¸åŒ([<equal-tests>](#%28elem._equal-tests%29))ï¼Œä½†ç»“æœç°åœ¨ä¸åŒï¼šä¸€äº›ä¹‹å‰ä¸ºçœŸçš„å€¼ç°åœ¨ä¸ºå‡ã€‚ç‰¹åˆ«æ˜¯ï¼Œ
- en: '[PRE49]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Later we will return both to what `identical` really means [[Understanding Equality](unified-equality.html)]
    (Pyret has a full range of equality operations suitable for different situations).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹‹åï¼Œæˆ‘ä»¬å°†å›åˆ°`identical`çœŸæ­£æ„å‘³ç€ä»€ä¹ˆ[[ç†è§£ç›¸ç­‰æ€§](unified-equality.html)]ï¼ˆPyretæœ‰ä¸€ç³»åˆ—é€‚ç”¨äºä¸åŒæƒ…å†µçš„ç›¸ç­‰æ€§æ“ä½œï¼‰ã€‚
- en: Exercise
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There are many more equality tests we can and should perform even with the basic
    data above to make sure we really understand equality and, relatedly, storage
    of data in memory. What other tests should we conduct? Predict what results they
    should produce before running them!
  id: totrans-178
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å³ä½¿ä½¿ç”¨ä¸Šè¿°åŸºæœ¬æ•°æ®ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥è¿›è¡Œæ›´å¤šç”šè‡³åº”è¯¥è¿›è¡Œçš„ç›¸ç­‰æ€§æµ‹è¯•ï¼Œä»¥ç¡®ä¿æˆ‘ä»¬çœŸæ­£ç†è§£äº†ç›¸ç­‰æ€§ä»¥åŠç›¸å…³åœ°ï¼Œæ•°æ®åœ¨å†…å­˜ä¸­çš„å­˜å‚¨ã€‚æˆ‘ä»¬åº”è¯¥è¿›è¡Œå“ªäº›å…¶ä»–æµ‹è¯•ï¼Ÿåœ¨è¿è¡Œå®ƒä»¬ä¹‹å‰é¢„æµ‹å®ƒä»¬åº”è¯¥äº§ç”Ÿä»€ä¹ˆç»“æœï¼
- en: 16.1.2Â The Cost of Evaluating References[ğŸ”—](#(part._.The_.Cost_of_.Evaluating_.References)
    "Link to here")
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.2Â è¯„ä¼°å¼•ç”¨çš„æˆæœ¬[ğŸ”—](#(part._.The_.Cost_of_.Evaluating_.References) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'From a complexity viewpoint, itâ€™s important for us to understand how these
    references work. As we have hinted, `four-node` is computed only once, and each
    use of it refers to the same value: if, instead, it was evaluated each time we
    referred to `four-node`, there would be no real difference between `a-tree` and
    `b-tree`, and the above tests would not distinguish between them.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ä»å¤æ‚æ€§çš„è§’åº¦æ¥çœ‹ï¼Œäº†è§£è¿™äº›å¼•ç”¨çš„å·¥ä½œæ–¹å¼å¯¹æˆ‘ä»¬æ¥è¯´å¾ˆé‡è¦ã€‚æ­£å¦‚æˆ‘ä»¬æš—ç¤ºçš„ï¼Œ`four-node`åªè®¡ç®—ä¸€æ¬¡ï¼Œå¹¶ä¸”æ¯æ¬¡ä½¿ç”¨éƒ½å¼•ç”¨ç›¸åŒçš„å€¼ï¼šå¦‚æœæ¯æ¬¡å¼•ç”¨`four-node`æ—¶éƒ½è¿›è¡Œè¯„ä¼°ï¼Œé‚£ä¹ˆ`a-tree`å’Œ`b-tree`ä¹‹é—´å°±æ²¡æœ‰çœŸæ­£çš„åŒºåˆ«ï¼Œä¸Šè¿°æµ‹è¯•ä¹Ÿæ— æ³•åŒºåˆ†å®ƒä»¬ã€‚
- en: 'This is especially relevant when understanding the cost of function evaluation.
    Weâ€™ll construct two simple examples that illustrate this. Weâ€™ll begin with a contrived
    data structure:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™åœ¨ç†è§£å‡½æ•°è¯„ä¼°æˆæœ¬æ—¶å°¤å…¶ç›¸å…³ã€‚æˆ‘ä»¬å°†æ„å»ºä¸¤ä¸ªç®€å•çš„ç¤ºä¾‹æ¥è¯´æ˜è¿™ä¸€ç‚¹ã€‚æˆ‘ä»¬å°†ä»ä¸€ä¸ªè™šæ„çš„æ•°æ®ç»“æ„å¼€å§‹ï¼š
- en: '[PRE50]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Suppose we now define
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬ç°åœ¨å®šä¹‰
- en: '[PRE51]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Constructing a list clearly takes time at least proportional to the length;
    therefore, we expect the time to compute `L` to be considerably more than that
    for a single `link` operation. Therefore, the question is how long it takes to
    compute `L1` and `L2` after `L` has been computed: constant time, or time proportional
    to the length of `L`?'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: æ˜¾ç„¶ï¼Œæ„å»ºåˆ—è¡¨éœ€è¦çš„æ—¶é—´è‡³å°‘ä¸é•¿åº¦æˆæ¯”ä¾‹ï¼›å› æ­¤ï¼Œæˆ‘ä»¬é¢„è®¡è®¡ç®—`L`æ‰€éœ€çš„æ—¶é—´å°†è¿œå¤§äºå•ä¸ª`link`æ“ä½œæ‰€éœ€çš„æ—¶é—´ã€‚å› æ­¤ï¼Œé—®é¢˜æ˜¯è®¡ç®—`L`ä¹‹å`L1`å’Œ`L2`éœ€è¦å¤šé•¿æ—¶é—´ï¼šå¸¸æ•°æ—¶é—´ï¼Œè¿˜æ˜¯ä¸`L`çš„é•¿åº¦æˆæ¯”ä¾‹çš„æ—¶é—´ï¼Ÿ
- en: 'The answer, for Pyret, and for most other contemporary languages (including
    Java, C#, OCaml, Racket, etc.), is that these additional computations take constant
    time. That is, the value bound to `L` is computed once and bound to `L`; subsequent
    expressions refer to this value (hence â€œreferenceâ€) rather than reconstructing
    it, as reference equality shows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºPyretä»¥åŠå¤§å¤šæ•°å…¶ä»–å½“ä»£è¯­è¨€ï¼ˆåŒ…æ‹¬Javaã€C#ã€OCamlã€Racketç­‰ï¼‰ï¼Œç­”æ¡ˆæ˜¯è¿™äº›é¢å¤–çš„è®¡ç®—éœ€è¦å¸¸æ•°æ—¶é—´ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œç»‘å®šåˆ°`L`çš„å€¼åªè®¡ç®—ä¸€æ¬¡å¹¶ç»‘å®šåˆ°`L`ï¼›åç»­çš„è¡¨è¾¾å¼å¼•ç”¨è¿™ä¸ªå€¼ï¼ˆå› æ­¤ç§°ä¸ºâ€œå¼•ç”¨ç›¸ç­‰â€ï¼‰ï¼Œè€Œä¸æ˜¯é‡å»ºå®ƒï¼Œæ­£å¦‚å¼•ç”¨ç›¸ç­‰æ‰€æ˜¾ç¤ºçš„ï¼š
- en: '[PRE52]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Similarly, we can define a function, pass `L` to it, and see whether the resulting
    argument is `identical` to the original:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: åŒæ ·ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œå°†`L`ä¼ é€’ç»™å®ƒï¼Œå¹¶æŸ¥çœ‹ç”Ÿæˆçš„å‚æ•°æ˜¯å¦ä¸åŸå§‹å‚æ•°`identical`ã€‚
- en: '[PRE53]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: or, equivalently,
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ–è€…ï¼Œç­‰ä»·åœ°ï¼Œ
- en: '[PRE54]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Therefore, neither built-in operations (like `.rest`) nor user-defined ones
    (like `check-for-no-copy`) make copies of their arguments.Strictly speaking, of
    course, we cannot conclude that no copy was made. Pyret could have made a copy,
    discarded it, and still passed a reference to the original. Given how perverse
    this would be, we can assumeâ€”<wbr>and take the languageâ€™s creatorsâ€™ word for itâ€”<wbr>that
    this doesnâ€™t actually happen. By creating extremely large lists, we can also use
    timing information to observe that the time of constructing the list grows proportional
    to the length of the list while the time of passing it as a parameter remains
    constant. The important thing to observe here is that, instead of simply relying
    on authority, we have used operations in the language itself to understand how
    the language behaves.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæ—¢ä¸æ˜¯å†…ç½®æ“ä½œï¼ˆå¦‚`.rest`ï¼‰ä¹Ÿä¸æ˜¯ç”¨æˆ·å®šä¹‰çš„æ“ä½œï¼ˆå¦‚`check-for-no-copy`ï¼‰ä¼šå¤åˆ¶å®ƒä»¬çš„å‚æ•°ã€‚ä¸¥æ ¼æ¥è¯´ï¼Œæˆ‘ä»¬æ— æ³•å¾—å‡ºæ²¡æœ‰å¤åˆ¶å‘ç”Ÿçš„ç»“è®ºã€‚Pyretå¯èƒ½ä¼šåˆ›å»ºä¸€ä¸ªå‰¯æœ¬ï¼Œç„¶åä¸¢å¼ƒå®ƒï¼Œä»ç„¶ä¼ é€’åŸå§‹å‚æ•°çš„å¼•ç”¨ã€‚é‰´äºè¿™ç§æƒ…å†µæ˜¯å¤šä¹ˆè’è°¬ï¼Œæˆ‘ä»¬å¯ä»¥å‡è®¾â€”â€”<wbr>å¹¶ä¸”ç›¸ä¿¡è¯­è¨€åˆ›é€ è€…çš„è¯´æ³•â€”â€”<wbr>è¿™ç§æƒ…å†µå®é™…ä¸Šå¹¶æ²¡æœ‰å‘ç”Ÿã€‚é€šè¿‡åˆ›å»ºæå…¶å¤§çš„åˆ—è¡¨ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨è®¡æ—¶ä¿¡æ¯æ¥è§‚å¯Ÿæ„å»ºåˆ—è¡¨çš„æ—¶é—´ä¸åˆ—è¡¨é•¿åº¦æˆæ¯”ä¾‹å¢é•¿ï¼Œè€Œä¼ é€’å®ƒä½œä¸ºå‚æ•°çš„æ—¶é—´ä¿æŒä¸å˜ã€‚è¿™é‡Œè¦è§‚å¯Ÿçš„é‡è¦äº‹æƒ…æ˜¯ï¼Œæˆ‘ä»¬ä¸æ˜¯ç®€å•åœ°ä¾èµ–æƒå¨ï¼Œè€Œæ˜¯ä½¿ç”¨äº†è¯­è¨€æœ¬èº«ä¸­çš„æ“ä½œæ¥ç†è§£è¯­è¨€çš„è¡Œä¸ºã€‚
- en: 16.1.3Â Notations for Equality[ğŸ”—](#(part._equal-always) "Link to here")
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.3 ç›¸ç­‰çš„è¡¨ç¤ºæ³•[ğŸ”—](#(part._equal-always) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Until now we have used `==` for equality. Now we have learned that itâ€™s only
    one of multiple equality operators, and that there is another one called `identical`.
    However, these two have somewhat subtly different syntactic properties. `identical`
    is a name for a function, which can therefore be used to refer to it like any
    other function (e.g., when we need to mention it in a `is-not` clause). In contrast,
    `==` is a binary operator, which can only be used in the middle of expressions.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬ä¸€ç›´ä½¿ç”¨`==`æ¥è¡¨ç¤ºç›¸ç­‰ã€‚ç°åœ¨æˆ‘ä»¬äº†è§£åˆ°å®ƒåªæ˜¯å¤šä¸ªç›¸ç­‰è¿ç®—ç¬¦ä¸­çš„ä¸€ä¸ªï¼Œè€Œä¸”è¿˜æœ‰ä¸€ä¸ªå«åš`identical`çš„è¿ç®—ç¬¦ã€‚ç„¶è€Œï¼Œè¿™ä¸¤ä¸ªè¿ç®—ç¬¦åœ¨è¯­æ³•å±æ€§ä¸Šç•¥æœ‰ä¸åŒã€‚`identical`æ˜¯ä¸€ä¸ªå‡½æ•°çš„åç§°ï¼Œå› æ­¤å¯ä»¥åƒä»»ä½•å…¶ä»–å‡½æ•°ä¸€æ ·ä½¿ç”¨å®ƒæ¥å¼•ç”¨ï¼ˆä¾‹å¦‚ï¼Œå½“æˆ‘ä»¬éœ€è¦åœ¨`is-not`å­å¥ä¸­æåŠå®ƒæ—¶ï¼‰ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œ`==`æ˜¯ä¸€ä¸ªäºŒå…ƒè¿ç®—ç¬¦ï¼Œå®ƒåªèƒ½ç”¨åœ¨è¡¨è¾¾å¼çš„ä¸­é—´ã€‚
- en: 'This should naturally make us wonder about the other two possibilities: a binary
    expression version of `identical` and a function name equivalent of `==`. They
    do, in fact, exist! The operation performed by `==` is called `equal-always`.
    Therefore, we can write the first block of tests equivalently, but more explicitly,
    as'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è‡ªç„¶ä¼šè®©æˆ‘ä»¬å¯¹å…¶ä»–ä¸¤ç§å¯èƒ½æ€§æ„Ÿåˆ°å¥½å¥‡ï¼š`identical`çš„äºŒå…ƒè¡¨è¾¾å¼ç‰ˆæœ¬å’Œ`==`çš„å‡½æ•°åç­‰ä»·ç‰ˆæœ¬ã€‚å®é™…ä¸Šï¼Œå®ƒä»¬ç¡®å®å­˜åœ¨ï¼`==`æ‰§è¡Œçš„æ“ä½œç§°ä¸º`equal-always`ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å°†ç¬¬ä¸€ä¸ªæµ‹è¯•å—ç­‰ä»·åœ°ã€ä½†æ›´æ˜ç¡®åœ°å†™å‡ºï¼š
- en: '[PRE55]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Conversely, the binary operator notation for `identical` is `<=>`. Thus, we
    can equivalently write `check-for-no-copy` as
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åï¼Œå¯¹äº`identical`çš„äºŒå…ƒè¿ç®—ç¬¦è¡¨ç¤ºæ˜¯`<=>`ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ç­‰ä»·åœ°å†™å‡º`check-for-no-copy`ä¸º
- en: '[PRE56]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 16.1.4Â On the Internet, Nobody Knows Youâ€™re a DAG[ğŸ”—](#(part._.On_the_.Internet__.Nobody_.Knows_.You_re_a_.D.A.G)
    "Link to here")
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.4 åœ¨äº’è”ç½‘ä¸Šï¼Œæ²¡æœ‰äººçŸ¥é“ä½ æ˜¯ä¸€ä¸ªDAG[ğŸ”—](#(part._.On_the_.Internet__.Nobody_.Knows_.You_re_a_.D.A.G)
    "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Despite the name weâ€™ve given it, `b-tree` is not actually a tree. In a tree,
    by definition, there are no shared nodes, whereas in `b-tree` the node named by
    `four-node` is shared by two parts of the tree. Despite this, traversing `b-tree`
    will still terminate, because there are no cyclic references in it: if you start
    from any node and visit its â€œchildrenâ€, you cannot end up back at that node. There
    is a special name for a value with such a shape: directed acyclic graph (DAG).'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡æˆ‘ä»¬ç»™å®ƒå–äº†è¿™ä¸ªåå­—ï¼Œä½†`b-tree`å®é™…ä¸Šå¹¶ä¸æ˜¯ä¸€æ£µæ ‘ã€‚åœ¨å®šä¹‰ä¸Šï¼Œæ ‘ä¸­æ²¡æœ‰å…±äº«çš„èŠ‚ç‚¹ï¼Œè€Œåœ¨`b-tree`ä¸­ï¼Œåä¸º`four-node`çš„èŠ‚ç‚¹è¢«æ ‘çš„ä¸¤ä¸ªéƒ¨åˆ†å…±äº«ã€‚å°½ç®¡å¦‚æ­¤ï¼Œéå†`b-tree`ä»ç„¶ä¼šç»ˆæ­¢ï¼Œå› ä¸ºå®ƒä¸­æ²¡æœ‰å¾ªç¯å¼•ç”¨ï¼šå¦‚æœä½ ä»ä¸€ä¸ªèŠ‚ç‚¹å¼€å§‹å¹¶è®¿é—®å®ƒçš„â€œå­èŠ‚ç‚¹â€ï¼Œä½ ä¸å¯èƒ½å›åˆ°é‚£ä¸ªèŠ‚ç‚¹ã€‚å¯¹äºå…·æœ‰è¿™ç§å½¢çŠ¶çš„å€¼æœ‰ä¸€ä¸ªç‰¹æ®Šçš„åç§°ï¼šæœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰ã€‚
- en: 'Many important data structures are actually a DAG underneath. For instance,
    consider Web sites. It is common to think of a site as a tree of pages: the top-level
    refers to several sections, each of which refers to sub-sections, and so on. However,
    sometimes an entry needs to be cataloged under multiple sections. For instance,
    an academic department might organize pages by people, teaching, and research.
    In the first of these pages it lists the people who work there; in the second,
    the list of courses; and in the third, the list of research groups. In turn, the
    courses might have references to the people teaching them, and the research groups
    are populated by these same people. Since we want only one page per person (for
    both maintenance and search indexing purposes), all these personnel links refer
    back to the same page for people.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: è®¸å¤šé‡è¦çš„æ•°æ®ç»“æ„å®é™…ä¸Šåœ¨ä¸‹é¢æ˜¯ä¸€ä¸ªDAGï¼ˆæœ‰å‘æ— ç¯å›¾ï¼‰ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘ç½‘ç«™ã€‚é€šå¸¸è®¤ä¸ºä¸€ä¸ªç½‘ç«™æ˜¯ä¸€æ£µé¡µé¢æ ‘ï¼šé¡¶çº§å¼•ç”¨å‡ ä¸ªéƒ¨åˆ†ï¼Œæ¯ä¸ªéƒ¨åˆ†åˆå¼•ç”¨å­éƒ¨åˆ†ï¼Œä¾æ­¤ç±»æ¨ã€‚ç„¶è€Œï¼Œæœ‰æ—¶ä¸€ä¸ªæ¡ç›®éœ€è¦è¢«å¤šä¸ªéƒ¨åˆ†ç¼–ç›®ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªå­¦æœ¯éƒ¨é—¨å¯èƒ½ä¼šæŒ‰äººå‘˜ã€æ•™å­¦å’Œç ”ç©¶ç»„ç»‡é¡µé¢ã€‚åœ¨ç¬¬ä¸€ä¸ªè¿™æ ·çš„é¡µé¢ä¸­ï¼Œå®ƒåˆ—å‡ºäº†åœ¨é‚£é‡Œå·¥ä½œçš„äººå‘˜ï¼›åœ¨ç¬¬äºŒä¸ªä¸­ï¼Œåˆ—å‡ºè¯¾ç¨‹åˆ—è¡¨ï¼›åœ¨ç¬¬ä¸‰ä¸ªä¸­ï¼Œåˆ—å‡ºç ”ç©¶å°ç»„ã€‚åè¿‡æ¥ï¼Œè¯¾ç¨‹å¯èƒ½åŒ…å«å¯¹æ•™æˆè¿™äº›è¯¾ç¨‹çš„æ•™å¸ˆçš„å¼•ç”¨ï¼Œè€Œç ”ç©¶å°ç»„ç”±è¿™äº›ç›¸åŒçš„äººå‘˜ç»„æˆã€‚ç”±äºæˆ‘ä»¬åªæƒ³ä¸ºæ¯ä¸ªäººï¼ˆä¸ºäº†ç»´æŠ¤å’Œæœç´¢ç´¢å¼•çš„ç›®çš„ï¼‰ä¿ç•™ä¸€ä¸ªé¡µé¢ï¼Œæ‰€ä»¥æ‰€æœ‰è¿™äº›äººå‘˜é“¾æ¥éƒ½å›æŒ‡åŒä¸€é¡µçš„äººå‘˜ã€‚
- en: 'Letâ€™s construct a simple form of this. First a datatype to represent a siteâ€™s
    content:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ„å»ºè¿™ä¸ªç®€å•å½¢å¼çš„ä¾‹å­ã€‚é¦–å…ˆæ˜¯ä¸€ä¸ªè¡¨ç¤ºç«™ç‚¹å†…å®¹çš„`datatype`ï¼ˆæ•°æ®ç±»å‹ï¼‰ï¼š
- en: '[PRE57]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Letâ€™s now define a few people:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å®šä¹‰å‡ ä¸ªäººç‰©ï¼š
- en: '[PRE58]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'and a way to extract a particular personâ€™s page:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥åŠæå–ç‰¹å®šä¸ªäººé¡µé¢çš„æ–¹æ³•ï¼š
- en: '[PRE59]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now we can define theory and systems sections:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¯ä»¥å®šä¹‰ç†è®ºå’Œç³»ç»Ÿéƒ¨åˆ†ï¼š
- en: '[PRE60]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'which are integrated into a site as a whole:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›ä½œä¸ºæ•´ä½“é›†æˆåˆ°ç½‘ç«™ä¸­ï¼š
- en: '[PRE61]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now we can confirm that each of these luminaries needs to keep only one Web
    page current; for instance:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¯ä»¥ç¡®è®¤ï¼Œè¿™äº›æ°å‡ºäººç‰©åªéœ€è¦ä¿æŒä¸€ä¸ªç½‘é¡µæœ€æ–°ï¼›ä¾‹å¦‚ï¼š
- en: '[PRE62]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 16.1.5Â Itâ€™s Always Been a DAG[ğŸ”—](#(part._.It_s_.Always_.Been_a_.D.A.G) "Link
    to here")
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.5 å®ƒå§‹ç»ˆæ˜¯ä¸€ä¸ªDAG[ğŸ”—](#(part._.It_s_.Always_.Been_a_.D.A.G) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: What we may not realize is that weâ€™ve actually been creating a DAG for longer
    than we think. To see this, consider `a-tree`, which very clearly seems to be
    a tree. But look more closely not at the `node`s but rather at the `leaf`(s).
    How many actual `leaf`s do we create?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯èƒ½æ²¡æœ‰æ„è¯†åˆ°ï¼Œå®é™…ä¸Šæˆ‘ä»¬åˆ›å»ºDAGï¼ˆæœ‰å‘æ— ç¯å›¾ï¼‰çš„æ—¶é—´æ¯”æˆ‘ä»¬æƒ³è±¡çš„è¦é•¿ã€‚ä¸ºäº†çœ‹åˆ°è¿™ä¸€ç‚¹ï¼Œè€ƒè™‘ä¸€ä¸‹`a-tree`ï¼Œå®ƒéå¸¸æ˜æ˜¾åœ°çœ‹èµ·æ¥åƒä¸€æ£µæ ‘ã€‚ä½†æ›´ä»”ç»†åœ°çœ‹ï¼Œä¸æ˜¯çœ‹`node`ï¼ˆèŠ‚ç‚¹ï¼‰ï¼Œè€Œæ˜¯çœ‹`leaf`(s)ï¼ˆå¶å­ï¼‰ã€‚æˆ‘ä»¬å®é™…ä¸Šåˆ›å»ºäº†å¤šå°‘ä¸ªå®é™…çš„`leaf`ï¼ˆå¶å­ï¼‰ï¼Ÿ
- en: 'One hint is that we donâ€™t seem to call a function when creating a `leaf`: the
    data definition does not list any fields, and when constructing a `BT` value,
    we simply write `leaf`, not (say) `leaf()`. Still, it would be nice to know what
    is happening behind the scenes. To check, we can simply ask Pyret:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæç¤ºæ˜¯æˆ‘ä»¬ä¼¼ä¹åœ¨åˆ›å»º`leaf`æ—¶æ²¡æœ‰è°ƒç”¨å‡½æ•°ï¼šæ•°æ®å®šä¹‰æ²¡æœ‰åˆ—å‡ºä»»ä½•å­—æ®µï¼Œåœ¨æ„å»º`BT`å€¼æ—¶ï¼Œæˆ‘ä»¬ç®€å•åœ°å†™`leaf`ï¼Œè€Œä¸æ˜¯ï¼ˆæ¯”å¦‚è¯´ï¼‰`leaf()`ã€‚å°½ç®¡å¦‚æ­¤ï¼Œäº†è§£å¹•åå‘ç”Ÿçš„äº‹æƒ…ä»ç„¶å¾ˆå¥½ã€‚ä¸ºäº†æ£€æŸ¥ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•åœ°è¯¢é—®Pyretï¼š
- en: '[PRE63]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Itâ€™s important that we not write `leaf <=> leaf` here, because that is just
    an expression whose result is ignored. We have to write `is` to register this
    as a test whose result is checked and reported. and this check passes. That is,
    when we write a variant without any fields, Pyret automatically creates a singleton:
    it makes just one instance and uses that instance everywhere. This leads to a
    more efficient memory representation, because there is no reason to have lots
    of distinct `leaf`s each taking up their own memory. However, a subtle consequence
    of that is that we have been creating a DAG all along.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œæˆ‘ä»¬ä¸åº”è¯¥å†™`leaf <=> leaf`ï¼Œå› ä¸ºè¿™åªæ˜¯ä¸€ä¸ªç»“æœè¢«å¿½ç•¥çš„è¡¨è¾¾å¼ã€‚æˆ‘ä»¬å¿…é¡»å†™`is`æ¥æ³¨å†Œè¿™ä¸ªä½œä¸ºéœ€è¦æ£€æŸ¥å’ŒæŠ¥å‘Šçš„ç»“æœçš„æµ‹è¯•ã€‚å¹¶ä¸”è¿™ä¸ªæ£€æŸ¥é€šè¿‡äº†ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“æˆ‘ä»¬å†™ä¸€ä¸ªæ²¡æœ‰ä»»ä½•å­—æ®µçš„å˜ä½“æ—¶ï¼ŒPyretä¼šè‡ªåŠ¨åˆ›å»ºä¸€ä¸ªå•ä¾‹ï¼šå®ƒåªåˆ›å»ºä¸€ä¸ªå®ä¾‹ï¼Œå¹¶åœ¨æ‰€æœ‰åœ°æ–¹ä½¿ç”¨è¿™ä¸ªå®ä¾‹ã€‚è¿™å¯¼è‡´äº†ä¸€ç§æ›´æœ‰æ•ˆçš„å†…å­˜è¡¨ç¤ºï¼Œå› ä¸ºæ²¡æœ‰ç†ç”±è®©å¾ˆå¤šä¸åŒçš„`leaf`ï¼ˆå¶å­ï¼‰å„è‡ªå ç”¨è‡ªå·±çš„å†…å­˜ã€‚ç„¶è€Œï¼Œè¿™ä¸ªå¾®å¦™çš„ç»“æœæ˜¯ï¼Œæˆ‘ä»¬ä¸€ç›´åœ¨åˆ›å»ºä¸€ä¸ªDAGï¼ˆæœ‰å‘æ— ç¯å›¾ï¼‰ã€‚
- en: 'If we really wanted each `leaf` to be distinct, itâ€™s easy: we can write'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬çœŸçš„æƒ³è®©æ¯ä¸ª`leaf`ï¼ˆå¶å­ï¼‰éƒ½æ˜¯ç‹¬ç‰¹çš„ï¼Œè¿™å¾ˆå®¹æ˜“ï¼šæˆ‘ä»¬å¯ä»¥å†™
- en: '[PRE64]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then we would need to use the `leaf` function everywhere:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬å¯èƒ½éœ€è¦åœ¨æ¯ä¸ªåœ°æ–¹ä½¿ç”¨`leaf`å‡½æ•°ï¼š
- en: '[PRE65]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'And sure enough:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ç¡®å®å¦‚æ­¤ï¼š
- en: '[PRE66]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 16.1.6Â From Acyclicity to Cycles[ğŸ”—](#(part._acyc-to-cyc) "Link to here")
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.6 ä»æ— ç¯åˆ°å¾ªç¯[ğŸ”—](#(part._acyc-to-cyc) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Hereâ€™s another example that arises on the Web. Suppose we are constructing
    a table of output in a Web page. We would like the rows of the table to alternate
    between white and grey. If the table had only two rows, we could map the row-generating
    function over a list of these two colors. Since we do not know how many rows it
    will have, however, we would like the list to be as long as necessary. In effect,
    we would like to write:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªåœ¨ç½‘ç»œä¸Šå‡ºç°çš„ä¾‹å­ã€‚å‡è®¾æˆ‘ä»¬æ­£åœ¨æ„å»ºä¸€ä¸ªç½‘é¡µä¸­çš„è¾“å‡ºè¡¨ã€‚æˆ‘ä»¬å¸Œæœ›è¡¨æ ¼çš„è¡Œåœ¨ç™½è‰²å’Œç°è‰²ä¹‹é—´äº¤æ›¿ã€‚å¦‚æœè¡¨æ ¼åªæœ‰ä¸¤è¡Œï¼Œæˆ‘ä»¬å¯ä»¥å°†è¿™äº›é¢œè‰²æ˜ å°„åˆ°ä¸€ä¸ªåŒ…å«è¿™ä¸¤ä¸ªé¢œè‰²çš„åˆ—è¡¨ä¸Šã€‚ç„¶è€Œï¼Œç”±äºæˆ‘ä»¬ä¸çŸ¥é“å®ƒå°†æœ‰å¤šå°‘è¡Œï¼Œæ‰€ä»¥æˆ‘ä»¬å¸Œæœ›åˆ—è¡¨å°½å¯èƒ½é•¿ã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬å¸Œæœ›ç¼–å†™ï¼š
- en: '[PRE67]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: to obtain an indefinitely long list, so that we could eventually write
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥è·å¾—ä¸€ä¸ªæ— é™é•¿çš„åˆ—è¡¨ï¼Œè¿™æ ·æˆ‘ä»¬æœ€ç»ˆå¯ä»¥ç¼–å†™
- en: '[PRE68]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'which applies a `color-table-row` function to two arguments: the current row
    from `table-row-content`, and the current color from `web-colors`, proceeding
    in lockstep over the two lists.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒå°†`color-table-row`å‡½æ•°åº”ç”¨äºä¸¤ä¸ªå‚æ•°ï¼šæ¥è‡ª`table-row-content`çš„å½“å‰è¡Œå’Œæ¥è‡ª`web-colors`çš„å½“å‰é¢œè‰²ï¼Œåœ¨ä¸¤ä¸ªåˆ—è¡¨ä¸­åŒæ­¥è¿›è¡Œã€‚
- en: Unfortunately, there are many things wrong with this attempted definition.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼Œè¿™ä¸ªå°è¯•çš„å®šä¹‰æœ‰å¾ˆå¤šé—®é¢˜ã€‚
- en: Do Now!
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see what they are?
  id: totrans-234
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ çœ‹æ‡‚äº†å—ï¼Ÿ
- en: 'Here are some problems in turn:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯ä¸€äº›é—®é¢˜ï¼š
- en: This will not even parse. The identifier `web-colors` is not bound on the right
    of the `=`.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿™ç”šè‡³æ— æ³•è§£æã€‚æ ‡è¯†ç¬¦`web-colors`åœ¨`=`çš„å³ä¾§æ²¡æœ‰ç»‘å®šã€‚
- en: 'Earlier, we saw a solution to such a problem: use `rec` [[Streams From Functions](func-as-data.html#%28part._streams-from-funs%29)].
    What happens if we write'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¹‹å‰ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†è¿™æ ·ä¸€ä¸ªé—®é¢˜çš„è§£å†³æ–¹æ¡ˆï¼šä½¿ç”¨`rec` [[ä»å‡½æ•°ä¸­æµå‡ºçš„æ•°æ®](func-as-data.html#%28part._streams-from-funs%29)]ã€‚å¦‚æœæˆ‘ä»¬ç¼–å†™
- en: '[PRE69]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: instead?
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: è€Œä¸æ˜¯ï¼Ÿ
- en: Exercise
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does `rec` work in the definition of `ones` but not above?
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆ`rec`åœ¨`ones`çš„å®šä¹‰ä¸­å·¥ä½œï¼Œä½†åœ¨ä¸Šé¢ä¸å·¥ä½œï¼Ÿ
- en: Assuming we have fixed the above problem, one of two things will happen. It
    depends on what the initial value of `web-colors` is. Because it is a dummy value,
    we do not get an arbitrarily long list of colors but rather a list of two colors
    followed by the dummy value. Indeed, this program will not even type-check.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬å·²ç»è§£å†³äº†ä¸Šè¿°é—®é¢˜ï¼Œé‚£ä¹ˆå°†å‘ç”Ÿä»¥ä¸‹ä¸¤ç§æƒ…å†µä¹‹ä¸€ã€‚è¿™å–å†³äº`web-colors`çš„åˆå§‹å€¼ã€‚å› ä¸ºå®ƒæ˜¯ä¸€ä¸ªå ä½ç¬¦å€¼ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸ä¼šå¾—åˆ°ä¸€ä¸ªä»»æ„é•¿çš„é¢œè‰²åˆ—è¡¨ï¼Œè€Œæ˜¯ä¸€ä¸ªåŒ…å«ä¸¤ä¸ªé¢œè‰²ç„¶åæ˜¯å ä½ç¬¦å€¼çš„åˆ—è¡¨ã€‚å®é™…ä¸Šï¼Œè¿™ä¸ªç¨‹åºç”šè‡³æ— æ³•é€šè¿‡ç±»å‹æ£€æŸ¥ã€‚
- en: 'Suppose, however, that `web-colors` were written instead as a function definition
    to delay its creation:'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å‡è®¾ï¼Œç„¶è€Œï¼Œ`web-colors`è¢«ç¼–å†™æˆä¸€ä¸ªå‡½æ•°å®šä¹‰æ¥å»¶è¿Ÿå…¶åˆ›å»ºï¼š
- en: '[PRE70]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: On its own this just defines a function. If, however, we use itâ€”<wbr>`web-colors()`â€”<wbr>it
    goes into an infinite loop constructing `link`s.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å•ç‹¬æ¥çœ‹ï¼Œè¿™ä»…ä»…å®šä¹‰äº†ä¸€ä¸ªå‡½æ•°ã€‚å¦‚æœæˆ‘ä»¬ä½¿ç”¨å®ƒâ€”â€”<wbr>`web-colors()`â€”â€”<wbr>å®ƒå°†è¿›å…¥ä¸€ä¸ªæ— é™å¾ªç¯æ„å»º`link`ã€‚
- en: Even if all that were to work, `map2` would either (a) not terminate because
    its second argument is indefinitely long, or (b) report an error because the two
    arguments arenâ€™t the same length.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å³ä½¿æ‰€æœ‰è¿™äº›éƒ½å·¥ä½œï¼Œ`map2`è¦ä¹ˆï¼ˆaï¼‰å› ä¸ºå…¶ç¬¬äºŒä¸ªå‚æ•°æ˜¯æ— é™é•¿çš„è€Œä¸ä¼šç»ˆæ­¢ï¼Œè¦ä¹ˆï¼ˆbï¼‰æŠ¥å‘Šé”™è¯¯ï¼Œå› ä¸ºä¸¤ä¸ªå‚æ•°çš„é•¿åº¦ä¸åŒã€‚
- en: 'All these problems are symptoms of a bigger issue. What we are trying to do
    here is not merely create a shared datum (like a DAG) but something much richer:
    a cyclic datum, i.e., one that refers back to itself:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€æœ‰è¿™äº›é—®é¢˜éƒ½æ˜¯æ›´å¤§é—®é¢˜çš„ç—‡çŠ¶ã€‚æˆ‘ä»¬åœ¨è¿™é‡Œè¯•å›¾åšçš„ä¸ä»…ä»…æ˜¯åˆ›å»ºä¸€ä¸ªå…±äº«çš„æ•°æ®ï¼ˆå¦‚DAGï¼‰ï¼Œè€Œæ˜¯æ›´ä¸°å¯Œçš„ä¸œè¥¿ï¼šä¸€ä¸ªå¾ªç¯æ•°æ®ï¼Œå³å®ƒå¼•ç”¨è‡ªèº«ï¼š
- en: '![image](../Images/e8661971bf1b4ec52d4a6cfb124b63a2.png)'
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](../Images/e8661971bf1b4ec52d4a6cfb124b63a2.png)'
- en: When you get to cycles, even defining the datum becomes difficult because its
    definition depends on itself so it (seemingly) needs to already be defined in
    the process of being defined. We will return to cyclic data later in [Cyclic Data](unified-cyclic-data.html),
    and to this specific example in [Recursion and Cycles from Mutation](rec-from-mut.html).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä½ åˆ°è¾¾å¾ªç¯æ—¶ï¼Œç”šè‡³å®šä¹‰æ•°æ®æœ¬èº«éƒ½å˜å¾—å›°éš¾ï¼Œå› ä¸ºå®ƒçš„å®šä¹‰ä¾èµ–äºè‡ªèº«ï¼Œå› æ­¤å®ƒï¼ˆè¡¨é¢ä¸Šï¼‰éœ€è¦åœ¨å®šä¹‰è¿‡ç¨‹ä¸­å·²ç»å®šä¹‰ã€‚æˆ‘ä»¬å°†åœ¨[Cyclic Data](unified-cyclic-data.html)ä¸­ç¨åå›åˆ°å¾ªç¯æ•°æ®ï¼Œå¹¶åœ¨[ä»çªå˜ä¸­çš„é€’å½’å’Œå¾ªç¯](rec-from-mut.html)ä¸­å›åˆ°è¿™ä¸ªç‰¹å®šç¤ºä¾‹ã€‚
- en: 16.1.1Â Re-Examining Equality[ğŸ”—](#(part._identical-eq) "Link to here")
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.1 é‡æ–°å®¡è§†ç­‰å¼[ğŸ”—](#(part._identical-eq) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Consider the following data definition and example values:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘ä»¥ä¸‹æ•°æ®å®šä¹‰å’Œç¤ºä¾‹å€¼ï¼š
- en: '[PRE71]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In particular, it might seem that the way weâ€™ve written `b-tree` is morally
    equivalent to how weâ€™ve written `a-tree`, but weâ€™ve created a helpful binding
    to avoid code duplication.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: å°¤å…¶æ˜¯å½“æˆ‘ä»¬ç¼–å†™`b-tree`çš„æ–¹å¼ä¼¼ä¹ä¸ç¼–å†™`a-tree`çš„æ–¹å¼åœ¨é“å¾·ä¸Šæ˜¯ç­‰ä»·çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šè§‰å¾—è¿™æ˜¯æ­£ç¡®çš„ï¼Œä½†æˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªæœ‰ç”¨çš„ç»‘å®šæ¥é¿å…ä»£ç é‡å¤ã€‚
- en: 'Because both `a-tree` and `b-tree` are bound to trees with `5` at the root
    and a left and right child each containing `4`, we can indeed reasonably consider
    these trees equivalent. Sure enough:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸º`a-tree`å’Œ`b-tree`éƒ½ç»‘å®šåˆ°æ ¹å€¼ä¸º`5`ä¸”å·¦å³å­èŠ‚ç‚¹å„åŒ…å«`4`çš„æ ‘ï¼Œæ‰€ä»¥æˆ‘ä»¬ç¡®å®å¯ä»¥åˆç†åœ°è®¤ä¸ºè¿™äº›æ ‘æ˜¯ç­‰ä»·çš„ã€‚ç¡®å®å¦‚æ­¤ï¼š
- en: <equal-tests> ::=
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: <equal-tests> ::=
- en: '[PRE72]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: However, there is another sense in which these trees are not equivalent. concretely,
    `a-tree` constructs a distinct node for each child, while `b-tree` uses the same
    node for both children. Surely this difference should show up somehow, but we
    have not yet seen a way to write a program that will tell these apart.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œä»å¦ä¸€ä¸ªè§’åº¦æ¥çœ‹ï¼Œè¿™äº›æ ‘å¹¶ä¸ç­‰ä»·ã€‚å…·ä½“æ¥è¯´ï¼Œ`a-tree`ä¸ºæ¯ä¸ªå­èŠ‚ç‚¹æ„å»ºä¸€ä¸ªä¸åŒçš„èŠ‚ç‚¹ï¼Œè€Œ`b-tree`ä½¿ç”¨ç›¸åŒçš„èŠ‚ç‚¹ä¸ºä¸¤ä¸ªå­èŠ‚ç‚¹ã€‚å½“ç„¶ï¼Œè¿™ç§å·®å¼‚åº”è¯¥ä»¥æŸç§æ–¹å¼æ˜¾ç¤ºå‡ºæ¥ï¼Œä½†æˆ‘ä»¬è¿˜æ²¡æœ‰çœ‹åˆ°ä¸€ç§ç¼–å†™ç¨‹åºæ¥åŒºåˆ†è¿™äº›çš„æ–¹æ³•ã€‚
- en: 'By default, the `is` operator uses the same equality test as Pyretâ€™s `==`.
    There are, however, other equality tests in Pyret. In particular, the way we can
    tell apart these data is by using Pyretâ€™s `identical` function, which implements
    reference equality. This checks not only whether two values are structurally equivalent
    but whether they are the result of the very same act of value construction. With
    this, we can now write additional tests:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: é»˜è®¤æƒ…å†µä¸‹ï¼Œ`is`è¿ç®—ç¬¦ä½¿ç”¨ä¸Pyretçš„`==`ç›¸åŒçš„ç›¸ç­‰æ€§æµ‹è¯•ã€‚ç„¶è€Œï¼ŒPyretä¸­è¿˜æœ‰å…¶ä»–ç›¸ç­‰æ€§æµ‹è¯•ã€‚ç‰¹åˆ«æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨Pyretçš„`identical`å‡½æ•°æ¥åŒºåˆ†è¿™äº›æ•°æ®ï¼Œè¯¥å‡½æ•°å®ç°äº†å¼•ç”¨ç›¸ç­‰æ€§ã€‚è¿™ä¸ä»…æ£€æŸ¥ä¸¤ä¸ªå€¼åœ¨ç»“æ„ä¸Šæ˜¯å¦ç­‰æ•ˆï¼Œè¿˜æ£€æŸ¥å®ƒä»¬æ˜¯å¦æ˜¯ç›¸åŒçš„å€¼æ„é€ è¡Œä¸ºçš„ç»“æœã€‚æœ‰äº†è¿™ä¸ªï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥ç¼–å†™é¢å¤–çš„æµ‹è¯•ï¼š
- en: '[PRE73]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Letâ€™s step back for a moment and consider the behavior that gives us this result.
    We can visualize the different values by putting each distinct value in a separate
    location alongside the running program. We can draw the first step as creating
    a `node` with value `4`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æš‚æ—¶é€€ä¸€æ­¥ï¼Œè€ƒè™‘äº§ç”Ÿè¿™ä¸ªç»“æœçš„è¡Œä¸ºã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡å°†æ¯ä¸ªä¸åŒçš„å€¼æ”¾åœ¨è¿è¡Œç¨‹åºæ—è¾¹çš„å•ç‹¬ä½ç½®æ¥å¯è§†åŒ–ä¸åŒçš„å€¼ã€‚æˆ‘ä»¬å¯ä»¥å°†ç¬¬ä¸€æ­¥ç»˜åˆ¶ä¸ºåˆ›å»ºä¸€ä¸ªå€¼ä¸º`4`çš„`èŠ‚ç‚¹`ï¼š
- en: '[PRE74]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: a-tree =
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: a-tree =
- en: node(5,
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: èŠ‚ç‚¹(5,
- en: 1001,
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1001,
- en: node(4, leaf, leaf))
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: èŠ‚ç‚¹(4, å¶å­, å¶å­))
- en: b-tree =
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: b-tree =
- en: 'block:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: å—ï¼š
- en: four-node = node(4, leaf, leaf)
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: four-node = èŠ‚ç‚¹(4, å¶å­, å¶å­)
- en: node(5,
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: èŠ‚ç‚¹(5,
- en: four-node,
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: four-node,
- en: four-node)
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: four-node)
- en: end
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æŸ
- en: '[PRE75]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Heap
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1001:'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1001:'
- en: '[PRE76]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The next step creates another node with value `4`, distinct from the first:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹ä¸€æ­¥åˆ›å»ºå¦ä¸€ä¸ªå€¼ä¸º`4`çš„èŠ‚ç‚¹ï¼Œä¸ç¬¬ä¸€ä¸ªä¸åŒï¼š
- en: '[PRE77]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: a-tree =
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: a-tree =
- en: node(5, 1001, 1002)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: èŠ‚ç‚¹(5, 1001, 1002)
- en: b-tree =
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: b-tree =
- en: 'block:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: å—ï¼š
- en: four-node = node(4, leaf, leaf)
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: four-node = èŠ‚ç‚¹(4, å¶å­, å¶å­)
- en: node(5,
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: èŠ‚ç‚¹(5,
- en: four-node,
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: four-node,
- en: four-node)
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: four-node)
- en: end
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æŸ
- en: '[PRE78]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Heap
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1001:'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1001:'
- en: '[PRE79]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '1002:'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1002:'
- en: '[PRE80]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then the `node` for `a-tree` is created:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶ååˆ›å»º`a-tree`çš„`èŠ‚ç‚¹`ï¼š
- en: '[PRE81]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: a-tree = 1003
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: a-tree = 1003
- en: b-tree =
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: b-tree =
- en: 'block:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: å—ï¼š
- en: four-node = node(4, leaf, leaf)
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: four-node = èŠ‚ç‚¹(4, å¶å­, å¶å­)
- en: node(5,
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: èŠ‚ç‚¹(5,
- en: four-node,
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: four-node,
- en: four-node)
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: four-node)
- en: end
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æŸ
- en: '[PRE82]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Heap
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1001:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1001:'
- en: '[PRE83]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '1002:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1002:'
- en: '[PRE84]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '1003:'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1003:'
- en: '[PRE85]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'When evaluating the `block` for `b-tree`, first a single node is created for
    the `four-node` binding:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: å½“è¯„ä¼°`b-tree`çš„`å—`æ—¶ï¼Œé¦–å…ˆä¸º`four-node`ç»‘å®šåˆ›å»ºä¸€ä¸ªå•ç‹¬çš„èŠ‚ç‚¹ï¼š
- en: '[PRE86]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: a-tree = 1003
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: a-tree = 1003
- en: b-tree =
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: b-tree =
- en: 'block:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: å—ï¼š
- en: four-node = 1004
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: four-node = 1004
- en: node(5,
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: èŠ‚ç‚¹(5,
- en: four-node,
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: four-node,
- en: four-node)
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: four-node)
- en: end
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æŸ
- en: '[PRE87]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Heap
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1001:'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1001:'
- en: '[PRE88]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '1002:'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1002:'
- en: '[PRE89]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '1003:'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1003:'
- en: '[PRE90]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '1004:'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1004:'
- en: '[PRE91]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: These location values can be substituted just like any other, so they get substituted
    for `four-node` to continue evaluation of the block.We skipped substituting `a-tree`
    for the moment, that will come up later.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›ä½ç½®å€¼å¯ä»¥åƒä»»ä½•å…¶ä»–å€¼ä¸€æ ·æ›¿æ¢ï¼Œå› æ­¤å®ƒä»¬è¢«æ›¿æ¢ä¸º`four-node`ä»¥ç»§ç»­å—çš„è¯„ä¼°ã€‚æˆ‘ä»¬æš‚æ—¶è·³è¿‡äº†æ›¿æ¢`a-tree`ï¼Œç¨åä¼šæœ‰æ‰€æ¶‰åŠã€‚
- en: '[PRE92]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: a-tree = 1003
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: a-tree = 1003
- en: b-tree =
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: b-tree =
- en: 'block:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: å—ï¼š
- en: node(5, 1004, 1004)
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: èŠ‚ç‚¹(5, 1004, 1004)
- en: end
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æŸ
- en: '[PRE93]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Heap
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1001:'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1001:'
- en: '[PRE94]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '1002:'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1002:'
- en: '[PRE95]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '1003:'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1003:'
- en: '[PRE96]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '1004:'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1004:'
- en: '[PRE97]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Finally, the node for `b-tree` is created:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œåˆ›å»º`b-tree`çš„èŠ‚ç‚¹ï¼š
- en: '[PRE98]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: a-tree = 1003
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: a-tree = 1003
- en: b-tree = 1005
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: b-tree = 1005
- en: '[PRE99]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Heap
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1001:'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1001:'
- en: '[PRE100]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '1002:'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1002:'
- en: '[PRE101]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '1003:'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1003:'
- en: '[PRE102]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '1004:'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1004:'
- en: '[PRE103]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '1005:'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1005:'
- en: '[PRE104]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This visualization can help us explain the test we wrote using `identical`.
    Letâ€™s consider the test with the appropriate location references substituted for
    `a-tree` and `b-tree`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§å¯è§†åŒ–å¯ä»¥å¸®åŠ©æˆ‘ä»¬è§£é‡Šä½¿ç”¨`identical`ç¼–å†™çš„æµ‹è¯•ã€‚è®©æˆ‘ä»¬è€ƒè™‘å°†é€‚å½“çš„å¼•ç”¨æ›¿æ¢ä¸º`a-tree`å’Œ`b-tree`çš„æµ‹è¯•ï¼š
- en: '[PRE105]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'check:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: æ£€æŸ¥ï¼š
- en: identical(1003, 1005)
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åŒ(1003, 1005)
- en: is false
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: æ˜¯å‡çš„
- en: identical(1003.l, 1003.l)
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åŒ(1003.l, 1003.l)
- en: is true
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: æ˜¯çœŸçš„
- en: identical(1003.l, 1003.r)
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åŒ(1003.l, 1003.r)
- en: is false
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: æ˜¯å‡çš„
- en: identical(1005.l, 1005.r)
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åŒ(1005.l, 1005.r)
- en: is true
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: æ˜¯çœŸçš„
- en: end
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æŸ
- en: '[PRE106]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Heap
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1001:'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1001:'
- en: '[PRE107]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '1002:'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1002:'
- en: '[PRE108]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '1003:'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1003:'
- en: '[PRE109]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '1004:'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1004:'
- en: '[PRE110]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '1005:'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1005:'
- en: '[PRE111]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'check:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: æ£€æŸ¥ï¼š
- en: identical(1003, 1005)
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åŒ(1003, 1005)
- en: is false
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: æ˜¯å‡çš„
- en: identical(1001, 1001)
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åŒ(1001, 1001)
- en: is true
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: æ˜¯çœŸçš„
- en: identical(1001, 1004)
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åŒ(1001, 1004)
- en: is false
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: æ˜¯å‡çš„
- en: identical(1004, 1004)
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åŒ(1004, 1004)
- en: is true
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: æ˜¯çœŸçš„
- en: end
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æŸ
- en: '[PRE113]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Heap
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1001:'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1001:'
- en: '[PRE114]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '1002:'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1002:'
- en: '[PRE115]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '1003:'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1003:'
- en: '[PRE116]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '1004:'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1004:'
- en: '[PRE117]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '1005:'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1005:'
- en: '[PRE118]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'There is actually another way to write these tests in Pyret: the `is` operator
    can also be parameterized by a different equality predicate than the default `==`.
    Thus, the above block can equivalently be written as:We can use `is-not` to check
    for expected failure of equality.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šï¼Œæˆ‘ä»¬è¿˜æœ‰å¦ä¸€ç§åœ¨ Pyret ä¸­ç¼–å†™è¿™äº›æµ‹è¯•çš„æ–¹æ³•ï¼š`is` æ“ä½œç¬¦ä¹Ÿå¯ä»¥é€šè¿‡ä¸€ä¸ªä¸åŒäºé»˜è®¤ `==` çš„ç­‰å¼è°“è¯è¿›è¡Œå‚æ•°åŒ–ã€‚å› æ­¤ï¼Œä¸Šè¿°å—å¯ä»¥ç­‰ä»·åœ°å†™æˆï¼šæˆ‘ä»¬å¯ä»¥ä½¿ç”¨
    `is-not` æ¥æ£€æŸ¥é¢„æœŸçš„ç­‰å¼å¤±è´¥ã€‚
- en: '[PRE119]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: We will use this style of equality testing from now on.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: ä»ç°åœ¨èµ·ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨è¿™ç§é£æ ¼çš„ç­‰å¼æµ‹è¯•ã€‚
- en: 'Observe how these are the same values that were compared earlier ([<equal-tests>](#%28elem._equal-tests%29)),
    but the results are now different: some values that were true earlier are now
    false. In particular,'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: è§‚å¯Ÿè¿™äº›å€¼ä¸ä¹‹å‰æ¯”è¾ƒçš„æ˜¯ç›¸åŒçš„ ([<equal-tests>](#%28elem._equal-tests%29))ï¼Œä½†ç»“æœç°åœ¨ä¸åŒï¼šä¹‹å‰ä¸ºçœŸçš„æŸäº›å€¼ç°åœ¨ä¸ºå‡ã€‚ç‰¹åˆ«æ˜¯ï¼Œ
- en: '[PRE120]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Later we will return both to what `identical` really means [[Understanding Equality](unified-equality.html)]
    (Pyret has a full range of equality operations suitable for different situations).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: åç»­æˆ‘ä»¬å°†å›åˆ° `identical` çš„çœŸæ­£å«ä¹‰ [[ç†è§£ç­‰å¼](unified-equality.html)]ï¼ˆPyret æœ‰é€‚ç”¨äºä¸åŒæƒ…å†µçš„å…¨å¥—ç­‰å¼æ“ä½œï¼‰ã€‚
- en: Exercise
  id: totrans-419
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-420
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There are many more equality tests we can and should perform even with the basic
    data above to make sure we really understand equality and, relatedly, storage
    of data in memory. What other tests should we conduct? Predict what results they
    should produce before running them!
  id: totrans-421
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å³ä½¿åœ¨åŸºæœ¬æ•°æ®ä¹‹ä¸Šï¼Œæˆ‘ä»¬è¿˜å¯ä»¥è¿›è¡Œè®¸å¤šæ›´å¤šçš„ç­‰å¼æµ‹è¯•ï¼Œä»¥ç¡®ä¿æˆ‘ä»¬çœŸæ­£ç†è§£ç­‰å¼ä»¥åŠç›¸å…³çš„å†…å­˜ä¸­æ•°æ®å­˜å‚¨ã€‚æˆ‘ä»¬åº”è¯¥è¿›è¡Œå“ªäº›å…¶ä»–æµ‹è¯•ï¼Ÿåœ¨è¿è¡Œå®ƒä»¬ä¹‹å‰é¢„æµ‹å®ƒä»¬åº”è¯¥äº§ç”Ÿä»€ä¹ˆç»“æœï¼
- en: 16.1.2Â The Cost of Evaluating References[ğŸ”—](#(part._.The_.Cost_of_.Evaluating_.References)
    "Link to here")
  id: totrans-422
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.2Â è¯„ä¼°å¼•ç”¨çš„æˆæœ¬[ğŸ”—](#(part._.The_.Cost_of_.Evaluating_.References) "é“¾æ¥è‡³æ­¤")
- en: 'From a complexity viewpoint, itâ€™s important for us to understand how these
    references work. As we have hinted, `four-node` is computed only once, and each
    use of it refers to the same value: if, instead, it was evaluated each time we
    referred to `four-node`, there would be no real difference between `a-tree` and
    `b-tree`, and the above tests would not distinguish between them.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: ä»å¤æ‚æ€§çš„è§’åº¦æ¥çœ‹ï¼Œäº†è§£è¿™äº›å¼•ç”¨æ˜¯å¦‚ä½•å·¥ä½œçš„æ˜¯éå¸¸é‡è¦çš„ã€‚æ­£å¦‚æˆ‘ä»¬æš—ç¤ºçš„ï¼Œ`four-node` åªè®¡ç®—ä¸€æ¬¡ï¼Œå¹¶ä¸”æ¯æ¬¡ä½¿ç”¨å®ƒéƒ½å¼•ç”¨ç›¸åŒçš„å€¼ï¼šå¦‚æœæˆ‘ä»¬æ¯æ¬¡å¼•ç”¨
    `four-node` æ—¶éƒ½å¯¹å…¶è¿›è¡Œè¯„ä¼°ï¼Œé‚£ä¹ˆ `a-tree` å’Œ `b-tree` ä¹‹é—´å°±æ²¡æœ‰çœŸæ­£çš„åŒºåˆ«ï¼Œä¸Šè¿°æµ‹è¯•ä¹Ÿä¸ä¼šåŒºåˆ†å®ƒä»¬ã€‚
- en: 'This is especially relevant when understanding the cost of function evaluation.
    Weâ€™ll construct two simple examples that illustrate this. Weâ€™ll begin with a contrived
    data structure:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™åœ¨ç†è§£å‡½æ•°è¯„ä¼°çš„æˆæœ¬æ—¶å°¤å…¶ç›¸å…³ã€‚æˆ‘ä»¬å°†æ„å»ºä¸¤ä¸ªç®€å•çš„ä¾‹å­æ¥è¯´æ˜è¿™ä¸€ç‚¹ã€‚æˆ‘ä»¬å°†ä»ä¸€ä¸ªè™šæ„çš„æ•°æ®ç»“æ„å¼€å§‹ï¼š
- en: '[PRE121]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Suppose we now define
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬ç°åœ¨å®šä¹‰
- en: '[PRE122]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Constructing a list clearly takes time at least proportional to the length;
    therefore, we expect the time to compute `L` to be considerably more than that
    for a single `link` operation. Therefore, the question is how long it takes to
    compute `L1` and `L2` after `L` has been computed: constant time, or time proportional
    to the length of `L`?'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: æ„å»ºä¸€ä¸ªåˆ—è¡¨æ˜¾ç„¶éœ€è¦çš„æ—¶é—´è‡³å°‘ä¸é•¿åº¦æˆæ¯”ä¾‹ï¼›å› æ­¤ï¼Œæˆ‘ä»¬é¢„è®¡è®¡ç®— `L` çš„æ—¶é—´å°†è¿œå¤§äºå•ä¸ª `link` æ“ä½œçš„æ—¶é—´ã€‚å› æ­¤ï¼Œé—®é¢˜æ˜¯è®¡ç®— `L` å `L1`
    å’Œ `L2` çš„è®¡ç®—éœ€è¦å¤šé•¿æ—¶é—´ï¼šæ˜¯å¸¸æ•°æ—¶é—´ï¼Œè¿˜æ˜¯ä¸ `L` çš„é•¿åº¦æˆæ¯”ä¾‹çš„æ—¶é—´ï¼Ÿ
- en: 'The answer, for Pyret, and for most other contemporary languages (including
    Java, C#, OCaml, Racket, etc.), is that these additional computations take constant
    time. That is, the value bound to `L` is computed once and bound to `L`; subsequent
    expressions refer to this value (hence â€œreferenceâ€) rather than reconstructing
    it, as reference equality shows:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äº Pyret ä»¥åŠå¤§å¤šæ•°å…¶ä»–å½“ä»£è¯­è¨€ï¼ˆåŒ…æ‹¬ Javaã€C#ã€OCamlã€Racket ç­‰ï¼‰ï¼Œç­”æ¡ˆæ˜¯è¿™äº›é¢å¤–çš„è®¡ç®—éœ€è¦å¸¸æ•°æ—¶é—´ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œç»‘å®šåˆ° `L`
    çš„å€¼åªè®¡ç®—ä¸€æ¬¡å¹¶ç»‘å®šåˆ° `L`ï¼›åç»­è¡¨è¾¾å¼å¼•ç”¨è¿™ä¸ªå€¼ï¼ˆå› æ­¤ç§°ä¸ºâ€œå¼•ç”¨â€ï¼‰ï¼Œè€Œä¸æ˜¯é‡å»ºå®ƒï¼Œæ­£å¦‚å¼•ç”¨ç­‰å¼æ‰€ç¤ºï¼š
- en: '[PRE123]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Similarly, we can define a function, pass `L` to it, and see whether the resulting
    argument is `identical` to the original:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: åŒæ ·ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œå°† `L` ä¼ é€’ç»™å®ƒï¼Œå¹¶æŸ¥çœ‹ç»“æœå‚æ•°æ˜¯å¦ä¸åŸå§‹å‚æ•° `identical`ï¼š
- en: '[PRE124]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: or, equivalently,
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ–è€…ï¼Œç­‰ä»·åœ°ï¼Œ
- en: '[PRE125]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Therefore, neither built-in operations (like `.rest`) nor user-defined ones
    (like `check-for-no-copy`) make copies of their arguments.Strictly speaking, of
    course, we cannot conclude that no copy was made. Pyret could have made a copy,
    discarded it, and still passed a reference to the original. Given how perverse
    this would be, we can assumeâ€”<wbr>and take the languageâ€™s creatorsâ€™ word for itâ€”<wbr>that
    this doesnâ€™t actually happen. By creating extremely large lists, we can also use
    timing information to observe that the time of constructing the list grows proportional
    to the length of the list while the time of passing it as a parameter remains
    constant. The important thing to observe here is that, instead of simply relying
    on authority, we have used operations in the language itself to understand how
    the language behaves.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæ—¢ä¸æ˜¯å†…ç½®æ“ä½œï¼ˆå¦‚`.rest`ï¼‰ä¹Ÿä¸æ˜¯ç”¨æˆ·å®šä¹‰çš„æ“ä½œï¼ˆå¦‚`check-for-no-copy`ï¼‰ä¼šå¤åˆ¶å®ƒä»¬çš„å‚æ•°ã€‚ä¸¥æ ¼æ¥è¯´ï¼Œæˆ‘ä»¬æ— æ³•å¾—å‡ºæ²¡æœ‰å¤åˆ¶ç»“è®ºã€‚Pyretå¯èƒ½ä¼šå¤åˆ¶å®ƒï¼Œç„¶åä¸¢å¼ƒå®ƒï¼ŒåŒæ—¶ä»ç„¶ä¼ é€’åŸå§‹å¯¹è±¡çš„å¼•ç”¨ã€‚é‰´äºè¿™å°†æ˜¯å¤šä¹ˆè’è°¬ï¼Œæˆ‘ä»¬å¯ä»¥å‡è®¾â€”â€”å½“ç„¶ï¼Œå¹¶ç›¸ä¿¡è¯­è¨€åˆ›é€ è€…çš„è¯´æ³•â€”â€”è¿™å®é™…ä¸Šå¹¶æ²¡æœ‰å‘ç”Ÿã€‚é€šè¿‡åˆ›å»ºæå…¶å¤§çš„åˆ—è¡¨ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨è®¡æ—¶ä¿¡æ¯æ¥è§‚å¯Ÿåˆ—è¡¨æ„å»ºçš„æ—¶é—´ä¸åˆ—è¡¨é•¿åº¦æˆæ­£æ¯”ï¼Œè€Œä¼ é€’å‚æ•°ä½œä¸ºå‚æ•°çš„æ—¶é—´ä¿æŒä¸å˜ã€‚è¿™é‡Œè¦è§‚å¯Ÿçš„é‡è¦äº‹æƒ…æ˜¯ï¼Œæˆ‘ä»¬ä¸æ˜¯ä»…ä»…ä¾èµ–æƒå¨ï¼Œè€Œæ˜¯ä½¿ç”¨äº†è¯­è¨€æœ¬èº«çš„æ“ä½œæ¥äº†è§£è¯­è¨€çš„è¡Œä¸ºã€‚
- en: 16.1.3Â Notations for Equality[ğŸ”—](#(part._equal-always) "Link to here")
  id: totrans-436
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.3Â ç­‰å¼è¡¨ç¤ºæ³•[ğŸ”—](#(part._equal-always) "é“¾æ¥è‡³æ­¤")
- en: Until now we have used `==` for equality. Now we have learned that itâ€™s only
    one of multiple equality operators, and that there is another one called `identical`.
    However, these two have somewhat subtly different syntactic properties. `identical`
    is a name for a function, which can therefore be used to refer to it like any
    other function (e.g., when we need to mention it in a `is-not` clause). In contrast,
    `==` is a binary operator, which can only be used in the middle of expressions.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬ä¸€ç›´ä½¿ç”¨`==`æ¥è¡¨ç¤ºç­‰å¼ã€‚ç°åœ¨æˆ‘ä»¬å·²ç»äº†è§£åˆ°ï¼Œå®ƒåªæ˜¯å¤šä¸ªç­‰å¼è¿ç®—ç¬¦ä¸­çš„ä¸€ä¸ªï¼Œè¿˜æœ‰ä¸€ä¸ªå«åš`identical`ã€‚ç„¶è€Œï¼Œè¿™ä¸¤ä¸ªåœ¨è¯­æ³•å±æ€§ä¸Šæœ‰äº›å¾®å¦™çš„ä¸åŒã€‚`identical`æ˜¯ä¸€ä¸ªå‡½æ•°çš„åç§°ï¼Œå› æ­¤å¯ä»¥åƒä»»ä½•å…¶ä»–å‡½æ•°ä¸€æ ·ä½¿ç”¨å®ƒæ¥å¼•ç”¨å®ƒï¼ˆä¾‹å¦‚ï¼Œå½“æˆ‘ä»¬éœ€è¦åœ¨`is-not`å­å¥ä¸­æåˆ°å®ƒæ—¶ï¼‰ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œ`==`æ˜¯ä¸€ä¸ªäºŒå…ƒè¿ç®—ç¬¦ï¼Œå®ƒåªèƒ½ç”¨äºè¡¨è¾¾å¼çš„ä¸­é—´éƒ¨åˆ†ã€‚
- en: 'This should naturally make us wonder about the other two possibilities: a binary
    expression version of `identical` and a function name equivalent of `==`. They
    do, in fact, exist! The operation performed by `==` is called `equal-always`.
    Therefore, we can write the first block of tests equivalently, but more explicitly,
    as'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è‡ªç„¶ä¼šè®©æˆ‘ä»¬å¯¹å…¶ä»–ä¸¤ç§å¯èƒ½æ€§æ„Ÿåˆ°å¥½å¥‡ï¼šä¸€ä¸ªæ˜¯`identical`çš„äºŒè¿›åˆ¶è¡¨è¾¾å¼ç‰ˆæœ¬ï¼Œå¦ä¸€ä¸ªæ˜¯`==`çš„å‡½æ•°åç­‰ä»·ã€‚å®é™…ä¸Šï¼Œå®ƒä»¬ç¡®å®å­˜åœ¨ï¼`==`æ‰§è¡Œçš„æ“ä½œè¢«ç§°ä¸º`equal-always`ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å°†ç¬¬ä¸€ä¸ªæµ‹è¯•å—ç­‰ä»·åœ°ã€ä½†æ›´æ˜ç¡®åœ°å†™æˆï¼š
- en: '[PRE126]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Conversely, the binary operator notation for `identical` is `<=>`. Thus, we
    can equivalently write `check-for-no-copy` as
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åï¼Œ`identical`çš„äºŒè¿›åˆ¶è¿ç®—ç¬¦è¡¨ç¤ºæ³•æ˜¯`<=>`ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ç­‰ä»·åœ°å†™å‡º`check-for-no-copy`ï¼š
- en: '[PRE127]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 16.1.4Â On the Internet, Nobody Knows Youâ€™re a DAG[ğŸ”—](#(part._.On_the_.Internet__.Nobody_.Knows_.You_re_a_.D.A.G)
    "Link to here")
  id: totrans-442
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.4Â åœ¨äº’è”ç½‘ä¸Šï¼Œæ²¡æœ‰äººçŸ¥é“ä½ æ˜¯ä¸€ä¸ªDAG[ğŸ”—](#(part._.On_the_.Internet__.Nobody_.Knows_.You_re_a_.D.A.G)
    "é“¾æ¥è‡³æ­¤")
- en: 'Despite the name weâ€™ve given it, `b-tree` is not actually a tree. In a tree,
    by definition, there are no shared nodes, whereas in `b-tree` the node named by
    `four-node` is shared by two parts of the tree. Despite this, traversing `b-tree`
    will still terminate, because there are no cyclic references in it: if you start
    from any node and visit its â€œchildrenâ€, you cannot end up back at that node. There
    is a special name for a value with such a shape: directed acyclic graph (DAG).'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡æˆ‘ä»¬ç»™å®ƒå–äº†`b-tree`è¿™ä¸ªåå­—ï¼Œä½†å®é™…ä¸Šå®ƒå¹¶ä¸æ˜¯ä¸€æ£µæ ‘ã€‚åœ¨æ ‘çš„å®šä¹‰ä¸­ï¼Œæ²¡æœ‰å…±äº«çš„èŠ‚ç‚¹ï¼Œè€Œåœ¨`b-tree`ä¸­ï¼Œåä¸º`four-node`çš„èŠ‚ç‚¹è¢«æ ‘çš„ä¸¤ä¸ªéƒ¨åˆ†å…±äº«ã€‚å°½ç®¡å¦‚æ­¤ï¼Œéå†`b-tree`ä»ç„¶ä¼šç»ˆæ­¢ï¼Œå› ä¸ºå®ƒæ²¡æœ‰å¾ªç¯å¼•ç”¨ï¼šå¦‚æœä½ ä»ä¸€ä¸ªèŠ‚ç‚¹å¼€å§‹ï¼Œè®¿é—®å®ƒçš„â€œå­èŠ‚ç‚¹â€ï¼Œä½ ä¸å¯èƒ½å›åˆ°é‚£ä¸ªèŠ‚ç‚¹ã€‚å¯¹äºå…·æœ‰è¿™ç§å½¢çŠ¶çš„å€¼æœ‰ä¸€ä¸ªç‰¹æ®Šçš„åç§°ï¼šæœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰ã€‚
- en: 'Many important data structures are actually a DAG underneath. For instance,
    consider Web sites. It is common to think of a site as a tree of pages: the top-level
    refers to several sections, each of which refers to sub-sections, and so on. However,
    sometimes an entry needs to be cataloged under multiple sections. For instance,
    an academic department might organize pages by people, teaching, and research.
    In the first of these pages it lists the people who work there; in the second,
    the list of courses; and in the third, the list of research groups. In turn, the
    courses might have references to the people teaching them, and the research groups
    are populated by these same people. Since we want only one page per person (for
    both maintenance and search indexing purposes), all these personnel links refer
    back to the same page for people.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: è®¸å¤šé‡è¦çš„æ•°æ®ç»“æ„å®é™…ä¸Šæ˜¯æœ‰å‘æ— ç¯å›¾ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘ç½‘ç«™ã€‚é€šå¸¸è®¤ä¸ºç½‘ç«™æ˜¯ä¸€æ£µé¡µé¢æ ‘ï¼šé¡¶çº§é¡µé¢æŒ‡çš„æ˜¯å‡ ä¸ªéƒ¨åˆ†ï¼Œæ¯ä¸ªéƒ¨åˆ†åˆæŒ‡æ˜å­éƒ¨åˆ†ï¼Œä¾æ­¤ç±»æ¨ã€‚ç„¶è€Œï¼Œæœ‰æ—¶ä¸€ä¸ªæ¡ç›®éœ€è¦è¢«å½’å…¥å¤šä¸ªéƒ¨åˆ†ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªå­¦æœ¯éƒ¨é—¨å¯èƒ½ä¼šæŒ‰äººå‘˜ã€æ•™å­¦å’Œç ”ç©¶ç»„ç»‡é¡µé¢ã€‚åœ¨ç¬¬ä¸€ä¸ªé¡µé¢ä¸­ï¼Œå®ƒåˆ—å‡ºäº†åœ¨é‚£é‡Œå·¥ä½œçš„äººå‘˜ï¼›åœ¨ç¬¬äºŒä¸ªé¡µé¢ä¸­ï¼Œåˆ—å‡ºäº†è¯¾ç¨‹åˆ—è¡¨ï¼›åœ¨ç¬¬ä¸‰ä¸ªé¡µé¢ä¸­ï¼Œåˆ—å‡ºäº†ç ”ç©¶å°ç»„ã€‚åè¿‡æ¥ï¼Œè¯¾ç¨‹å¯èƒ½åŒ…å«å¯¹æ•™æˆè¿™äº›è¯¾ç¨‹çš„æ•™å¸ˆçš„å¼•ç”¨ï¼Œè€Œç ”ç©¶å°ç»„ç”±è¿™äº›ç›¸åŒçš„äººå‘˜ç»„æˆã€‚ç”±äºæˆ‘ä»¬åªæƒ³ä¸ºæ¯ä¸ªäººåˆ›å»ºä¸€ä¸ªé¡µé¢ï¼ˆæ— è®ºæ˜¯ç»´æŠ¤è¿˜æ˜¯æœç´¢ç´¢å¼•çš„ç›®çš„ï¼‰ï¼Œæ‰€æœ‰è¿™äº›äººå‘˜é“¾æ¥éƒ½å›æŒ‡åˆ°åŒä¸€é¡µé¢ä¸Šçš„äººå‘˜ã€‚
- en: 'Letâ€™s construct a simple form of this. First a datatype to represent a siteâ€™s
    content:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ„å»ºè¿™ç§å½¢å¼çš„ä¸€ä¸ªç®€å•ä¾‹å­ã€‚é¦–å…ˆæ˜¯ä¸€ä¸ªè¡¨ç¤ºç«™ç‚¹å†…å®¹çš„æ•°æ®ç±»å‹ï¼š
- en: '[PRE128]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Letâ€™s now define a few people:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å®šä¹‰ä¸€äº›äººç‰©ï¼š
- en: '[PRE129]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'and a way to extract a particular personâ€™s page:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥åŠæå–ç‰¹å®šä¸ªäººé¡µé¢çš„æ–¹æ³•ï¼š
- en: '[PRE130]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Now we can define theory and systems sections:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¯ä»¥å®šä¹‰ç†è®ºå’Œç³»ç»Ÿéƒ¨åˆ†ï¼š
- en: '[PRE131]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'which are integrated into a site as a whole:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›äººç‰©ä½œä¸ºä¸€ä¸ªæ•´ä½“é›†æˆåˆ°ç«™ç‚¹ä¸­ï¼š
- en: '[PRE132]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Now we can confirm that each of these luminaries needs to keep only one Web
    page current; for instance:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¯ä»¥ç¡®è®¤ï¼Œè¿™äº›æ°å‡ºäººç‰©åªéœ€è¦ä¿æŒä¸€ä¸ªç½‘é¡µæœ€æ–°ï¼›ä¾‹å¦‚ï¼š
- en: '[PRE133]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 16.1.5Â Itâ€™s Always Been a DAG[ğŸ”—](#(part._.It_s_.Always_.Been_a_.D.A.G) "Link
    to here")
  id: totrans-457
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.5 å®ƒå§‹ç»ˆæ˜¯ä¸€ä¸ªæœ‰å‘æ— ç¯å›¾[ğŸ”—](#(part._.It_s_.Always_.Been_a_.D.A.G) "é“¾æ¥è‡³æ­¤")
- en: What we may not realize is that weâ€™ve actually been creating a DAG for longer
    than we think. To see this, consider `a-tree`, which very clearly seems to be
    a tree. But look more closely not at the `node`s but rather at the `leaf`(s).
    How many actual `leaf`s do we create?
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯èƒ½æ²¡æœ‰æ„è¯†åˆ°ï¼Œå®é™…ä¸Šæˆ‘ä»¬å·²ç»æ¯”æˆ‘ä»¬æƒ³è±¡çš„æ›´é•¿æ—¶é—´åœ¨åˆ›å»ºæœ‰å‘æ— ç¯å›¾ã€‚ä¸ºäº†çœ‹åˆ°è¿™ä¸€ç‚¹ï¼Œè€ƒè™‘`a-tree`ï¼Œå®ƒéå¸¸æ˜æ˜¾åœ°çœ‹èµ·æ¥åƒä¸€æ£µæ ‘ã€‚ä½†æ›´ä»”ç»†åœ°çœ‹çœ‹ï¼Œä¸æ˜¯`èŠ‚ç‚¹`è€Œæ˜¯`å¶å­`(s)ã€‚æˆ‘ä»¬å®é™…ä¸Šåˆ›å»ºäº†å¤šå°‘ä¸ª`å¶å­`ï¼Ÿ
- en: 'One hint is that we donâ€™t seem to call a function when creating a `leaf`: the
    data definition does not list any fields, and when constructing a `BT` value,
    we simply write `leaf`, not (say) `leaf()`. Still, it would be nice to know what
    is happening behind the scenes. To check, we can simply ask Pyret:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæç¤ºæ˜¯ï¼Œæˆ‘ä»¬ä¼¼ä¹åœ¨åˆ›å»º`å¶å­`æ—¶æ²¡æœ‰è°ƒç”¨å‡½æ•°ï¼šæ•°æ®å®šä¹‰æ²¡æœ‰åˆ—å‡ºä»»ä½•å­—æ®µï¼Œåœ¨æ„å»º`BT`å€¼æ—¶ï¼Œæˆ‘ä»¬ç®€å•åœ°å†™`leaf`ï¼Œè€Œä¸æ˜¯ï¼ˆæ¯”å¦‚è¯´ï¼‰`leaf()`ã€‚å°½ç®¡å¦‚æ­¤ï¼Œäº†è§£å¹•åå‘ç”Ÿçš„äº‹æƒ…ä»ç„¶å¾ˆå¥½ã€‚ä¸ºäº†æ£€æŸ¥ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•åœ°è¯¢é—®Pyretï¼š
- en: '[PRE134]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Itâ€™s important that we not write `leaf <=> leaf` here, because that is just
    an expression whose result is ignored. We have to write `is` to register this
    as a test whose result is checked and reported. and this check passes. That is,
    when we write a variant without any fields, Pyret automatically creates a singleton:
    it makes just one instance and uses that instance everywhere. This leads to a
    more efficient memory representation, because there is no reason to have lots
    of distinct `leaf`s each taking up their own memory. However, a subtle consequence
    of that is that we have been creating a DAG all along.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œæˆ‘ä»¬ä¸åº”è¯¥å†™`leaf <=> leaf`ï¼Œå› ä¸ºè¿™åªæ˜¯ä¸€ä¸ªç»“æœè¢«å¿½ç•¥çš„è¡¨è¾¾å¼ã€‚æˆ‘ä»¬å¿…é¡»å†™`is`æ¥æ³¨å†Œè¿™ä¸ªä½œä¸ºç»“æœè¢«æ£€æŸ¥å’ŒæŠ¥å‘Šçš„æµ‹è¯•ã€‚å¹¶ä¸”è¿™ä¸ªæ£€æŸ¥é€šè¿‡äº†ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“æˆ‘ä»¬å†™ä¸€ä¸ªæ²¡æœ‰ä»»ä½•å­—æ®µçš„å˜ä½“æ—¶ï¼ŒPyretè‡ªåŠ¨åˆ›å»ºä¸€ä¸ªå•ä¾‹ï¼šå®ƒåªåˆ›å»ºä¸€ä¸ªå®ä¾‹å¹¶åœ¨æ‰€æœ‰åœ°æ–¹ä½¿ç”¨è¯¥å®ä¾‹ã€‚è¿™å¯¼è‡´äº†ä¸€ç§æ›´æœ‰æ•ˆçš„å†…å­˜è¡¨ç¤ºï¼Œå› ä¸ºæ²¡æœ‰ç†ç”±è®©è®¸å¤šä¸åŒçš„`å¶å­`å„è‡ªå ç”¨å†…å­˜ã€‚ç„¶è€Œï¼Œè¿™ä¸ªå¾®å¦™çš„ç»“æœæ˜¯ï¼Œæˆ‘ä»¬ä¸€ç›´åœ¨åˆ›å»ºæœ‰å‘æ— ç¯å›¾ã€‚
- en: 'If we really wanted each `leaf` to be distinct, itâ€™s easy: we can write'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬çœŸçš„æƒ³è®©æ¯ä¸ª`å¶å­`éƒ½æ˜¯ç‹¬ç‰¹çš„ï¼Œè¿™å¾ˆç®€å•ï¼šæˆ‘ä»¬å¯ä»¥å†™å‡º
- en: '[PRE135]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Then we would need to use the `leaf` function everywhere:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬å°±éœ€è¦åœ¨æ¯ä¸ªåœ°æ–¹ä½¿ç”¨`leaf`å‡½æ•°ï¼š
- en: '[PRE136]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'And sure enough:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: ç¡®å®å¦‚æ­¤ï¼š
- en: '[PRE137]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 16.1.6Â From Acyclicity to Cycles[ğŸ”—](#(part._acyc-to-cyc) "Link to here")
  id: totrans-468
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.6 ä»æ— ç¯æ€§åˆ°ç¯[ğŸ”—](#(part._acyc-to-cyc) "é“¾æ¥è‡³æ­¤")
- en: 'Hereâ€™s another example that arises on the Web. Suppose we are constructing
    a table of output in a Web page. We would like the rows of the table to alternate
    between white and grey. If the table had only two rows, we could map the row-generating
    function over a list of these two colors. Since we do not know how many rows it
    will have, however, we would like the list to be as long as necessary. In effect,
    we would like to write:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªåœ¨ç½‘ç»œä¸Šå‡ºç°çš„ä¾‹å­ã€‚å‡è®¾æˆ‘ä»¬æ­£åœ¨æ„å»ºä¸€ä¸ªç½‘é¡µä¸­çš„è¾“å‡ºè¡¨æ ¼ã€‚æˆ‘ä»¬å¸Œæœ›è¡¨æ ¼çš„è¡Œåœ¨ç™½è‰²å’Œç°è‰²ä¹‹é—´äº¤æ›¿ã€‚å¦‚æœè¡¨æ ¼åªæœ‰ä¸¤è¡Œï¼Œæˆ‘ä»¬å¯ä»¥å°†è¡Œç”Ÿæˆå‡½æ•°æ˜ å°„åˆ°è¿™ä¸¤ä¸ªé¢œè‰²çš„åˆ—è¡¨ä¸Šã€‚ç„¶è€Œï¼Œç”±äºæˆ‘ä»¬ä¸çŸ¥é“å®ƒä¼šæœ‰å¤šå°‘è¡Œï¼Œæ‰€ä»¥æˆ‘ä»¬å¸Œæœ›åˆ—è¡¨å°½å¯èƒ½é•¿ã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬å¸Œæœ›å†™ï¼š
- en: '[PRE138]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: to obtain an indefinitely long list, so that we could eventually write
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥è·å¾—ä¸€ä¸ªæ— é™é•¿çš„åˆ—è¡¨ï¼Œè¿™æ ·æˆ‘ä»¬æœ€ç»ˆå¯ä»¥å†™ï¼š
- en: '[PRE139]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'which applies a `color-table-row` function to two arguments: the current row
    from `table-row-content`, and the current color from `web-colors`, proceeding
    in lockstep over the two lists.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°†åº”ç”¨ä¸€ä¸ª `color-table-row` å‡½æ•°åˆ°ä¸¤ä¸ªå‚æ•°ä¸Šï¼šæ¥è‡ª `table-row-content` çš„å½“å‰è¡Œå’Œæ¥è‡ª `web-colors`
    çš„å½“å‰é¢œè‰²ï¼Œåœ¨ä¸¤ä¸ªåˆ—è¡¨ä¸ŠåŒæ­¥è¿›è¡Œã€‚
- en: Unfortunately, there are many things wrong with this attempted definition.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: å¾ˆä¸å¹¸ï¼Œè¿™ä¸ªå°è¯•å®šä¹‰ä¸­å­˜åœ¨è®¸å¤šé”™è¯¯ã€‚
- en: Do Now!
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see what they are?
  id: totrans-477
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ çœ‹æ‡‚äº†å—ï¼Ÿ
- en: 'Here are some problems in turn:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€äº›é—®é¢˜ä¾æ¬¡å‡ºç°ï¼š
- en: This will not even parse. The identifier `web-colors` is not bound on the right
    of the `=`.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿™ç”šè‡³æ— æ³•è§£æã€‚æ ‡è¯†ç¬¦ `web-colors` åœ¨ `=` çš„å³ä¾§æ²¡æœ‰ç»‘å®šã€‚
- en: 'Earlier, we saw a solution to such a problem: use `rec` [[Streams From Functions](func-as-data.html#%28part._streams-from-funs%29)].
    What happens if we write'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¹‹å‰ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†è¿™æ ·ä¸€ä¸ªé—®é¢˜çš„è§£å†³æ–¹æ¡ˆï¼šä½¿ç”¨ `rec` [[ä»å‡½æ•°ç”Ÿæˆæµ](func-as-data.html#%28part._streams-from-funs%29)]ã€‚å¦‚æœæˆ‘ä»¬è¿™æ ·å†™ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
- en: '[PRE140]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: instead?
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: è€Œä¸æ˜¯ï¼Ÿ
- en: Exercise
  id: totrans-483
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-484
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does `rec` work in the definition of `ones` but not above?
  id: totrans-485
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆ `rec` åœ¨ `ones` çš„å®šä¹‰ä¸­èµ·ä½œç”¨ï¼Œä½†åœ¨ä¸Šé¢ä¸èµ·ä½œç”¨ï¼Ÿ
- en: Assuming we have fixed the above problem, one of two things will happen. It
    depends on what the initial value of `web-colors` is. Because it is a dummy value,
    we do not get an arbitrarily long list of colors but rather a list of two colors
    followed by the dummy value. Indeed, this program will not even type-check.
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬è§£å†³äº†ä¸Šè¿°é—®é¢˜ï¼Œé‚£ä¹ˆå°†å‘ç”Ÿä¸¤ä»¶äº‹ä¹‹ä¸€ã€‚è¿™å–å†³äº `web-colors` çš„åˆå§‹å€¼ã€‚å› ä¸ºå®ƒæ˜¯ä¸€ä¸ªå ä½ç¬¦å€¼ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸ä¼šå¾—åˆ°ä¸€ä¸ªä»»æ„é•¿çš„é¢œè‰²åˆ—è¡¨ï¼Œè€Œæ˜¯ä¸€ä¸ªåŒ…å«ä¸¤ä¸ªé¢œè‰²ç„¶åæ˜¯å ä½ç¬¦å€¼çš„åˆ—è¡¨ã€‚å®é™…ä¸Šï¼Œè¿™ä¸ªç¨‹åºç”šè‡³æ— æ³•é€šè¿‡ç±»å‹æ£€æŸ¥ã€‚
- en: 'Suppose, however, that `web-colors` were written instead as a function definition
    to delay its creation:'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å‡è®¾ï¼Œç„¶è€Œï¼Œ`web-colors` è¢«å†™æˆå‡½æ•°å®šä¹‰æ¥å»¶è¿Ÿå…¶åˆ›å»ºï¼š
- en: '[PRE141]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: On its own this just defines a function. If, however, we use itâ€”<wbr>`web-colors()`â€”<wbr>it
    goes into an infinite loop constructing `link`s.
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å•ç‹¬æ¥çœ‹ï¼Œè¿™ä»…ä»…å®šä¹‰äº†ä¸€ä¸ªå‡½æ•°ã€‚ç„¶è€Œï¼Œå¦‚æœæˆ‘ä»¬ä½¿ç”¨å®ƒâ€”â€”<wbr>`web-colors()`â€”â€”<wbr>å®ƒå°†è¿›å…¥ä¸€ä¸ªæ— é™å¾ªç¯æ„å»º `link`sã€‚
- en: Even if all that were to work, `map2` would either (a) not terminate because
    its second argument is indefinitely long, or (b) report an error because the two
    arguments arenâ€™t the same length.
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å³ä½¿æ‰€æœ‰è¿™äº›éƒ½å·¥ä½œï¼Œ`map2` è¦ä¹ˆï¼ˆaï¼‰å› ä¸ºå®ƒçš„ç¬¬äºŒä¸ªå‚æ•°æ— é™é•¿è€Œä¸ä¼šç»ˆæ­¢ï¼Œè¦ä¹ˆï¼ˆbï¼‰æŠ¥å‘Šé”™è¯¯ï¼Œå› ä¸ºä¸¤ä¸ªå‚æ•°çš„é•¿åº¦ä¸åŒã€‚
- en: 'All these problems are symptoms of a bigger issue. What we are trying to do
    here is not merely create a shared datum (like a DAG) but something much richer:
    a cyclic datum, i.e., one that refers back to itself:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€æœ‰è¿™äº›é—®é¢˜éƒ½æ˜¯æ›´å¤§é—®é¢˜çš„ç—‡çŠ¶ã€‚æˆ‘ä»¬åœ¨è¿™é‡Œè¯•å›¾åšçš„ä¸ä»…ä»…æ˜¯åˆ›å»ºä¸€ä¸ªå…±äº«çš„æ•°æ®ï¼ˆå¦‚ DAGï¼‰ï¼Œè€Œæ˜¯ä¸€ç§æ›´ä¸°å¯Œçš„æ•°æ®ï¼šå¾ªç¯æ•°æ®ï¼Œå³å®ƒæŒ‡å›è‡ªèº«çš„ï¼š
- en: '![image](../Images/e8661971bf1b4ec52d4a6cfb124b63a2.png)'
  id: totrans-492
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](../Images/e8661971bf1b4ec52d4a6cfb124b63a2.png)'
- en: When you get to cycles, even defining the datum becomes difficult because its
    definition depends on itself so it (seemingly) needs to already be defined in
    the process of being defined. We will return to cyclic data later in [Cyclic Data](unified-cyclic-data.html),
    and to this specific example in [Recursion and Cycles from Mutation](rec-from-mut.html).
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä½ é‡åˆ°å¾ªç¯æ—¶ï¼Œç”šè‡³å®šä¹‰æ•°æ®æœ¬èº«éƒ½å˜å¾—å›°éš¾ï¼Œå› ä¸ºå®ƒçš„å®šä¹‰ä¾èµ–äºè‡ªèº«ï¼Œå› æ­¤ï¼ˆè¡¨é¢ä¸Šï¼‰å®ƒä¼¼ä¹éœ€è¦åœ¨å®šä¹‰çš„è¿‡ç¨‹ä¸­å°±å·²ç»è¢«å®šä¹‰ã€‚æˆ‘ä»¬å°†åœ¨ [å¾ªç¯æ•°æ®](unified-cyclic-data.html)
    ä¸­ç¨åå›åˆ°å¾ªç¯æ•°æ®ï¼Œä»¥åŠåœ¨è¿™ä¸ªç‰¹å®šç¤ºä¾‹ä¸­åœ¨ [é€’å½’ä¸å¾ªç¯ä»çªå˜](rec-from-mut.html) ä¸­ã€‚
