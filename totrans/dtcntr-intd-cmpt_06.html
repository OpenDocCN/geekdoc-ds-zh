<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>3.3¬†From Repeated Expressions to Functionsüîó</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>3.3¬†From Repeated Expressions to Functionsüîó</h1>
<blockquote>ÂéüÊñáÔºö<a href="https://dcic-world.org/2025-08-27/From_Repeated_Expressions_to_Functions.html">https://dcic-world.org/2025-08-27/From_Repeated_Expressions_to_Functions.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>¬†¬†¬†¬†<a href="#%28part._similar-flags%29" class="toclink" data-pltdoc="x">3.3.1¬†Example: Similar Flags</a></p></td></tr><tr><td><p>¬†¬†¬†¬†<a href="#%28part._defining-functions%29" class="toclink" data-pltdoc="x">3.3.2¬†Defining Functions</a></p></td></tr><tr><td><p>¬†¬†¬†¬†¬†¬†<a href="#%28part._function-call-nm%29" class="toclink" data-pltdoc="x">3.3.2.1¬†How Functions Evaluate</a></p></td></tr><tr><td><p>¬†¬†¬†¬†¬†¬†<a href="#%28part._fun-annotations%29" class="toclink" data-pltdoc="x">3.3.2.2¬†Type Annotations</a></p></td></tr><tr><td><p>¬†¬†¬†¬†¬†¬†<a href="#%28part._doc-strings%29" class="toclink" data-pltdoc="x">3.3.2.3¬†Documentation</a></p></td></tr><tr><td><p>¬†¬†¬†¬†<a href="#%28part._moon-weight-pyret%29" class="toclink" data-pltdoc="x">3.3.3¬†Functions Practice: Moon Weight</a></p></td></tr><tr><td><p>¬†¬†¬†¬†<a href="#%28part._writing-examples%29" class="toclink" data-pltdoc="x">3.3.4¬†Documenting Functions with Examples</a></p></td></tr><tr><td><p>¬†¬†¬†¬†<a href="#%28part._pen-cost-pyret%29" class="toclink" data-pltdoc="x">3.3.5¬†Functions Practice: Cost of pens</a></p></td></tr><tr><td><p>¬†¬†¬†¬†<a href="#%28part._.Recap__.Defining_.Functions%29" class="toclink" data-pltdoc="x">3.3.6¬†Recap: Defining Functions</a></p></td></tr></table><section class="SsectionLevel4" id="section 3.3.1"><h4 class="heading">3.3.1¬†<a name="(part._similar-flags)"/>Example: Similar Flags<a href="#(part._similar-flags)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>Consider the following two expressions to draw the flags of Armenia
and Austria (respectively).  These two countries have the same flag,
just with different colors. The <code data-lang="pyret" class="sourceCode">frame</code> operator draws a small
black frame around the image.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode"># Lines starting with # are comments for human readers.
# Pyret ignores everything on a line after #.

# armenia
frame(
  above(rectangle(120, 30, "solid", "red"),
    above(rectangle(120, 30, "solid", "blue"),
      rectangle(120, 30, "solid", "orange"))))

# austria
frame(
  above(rectangle(120, 30, "solid", "red"),
    above(rectangle(120, 30, "solid", "white"),
      rectangle(120, 30, "solid", "red"))))</code></pre><p>Rather than write this program twice, it would be nice to write the
common expression only once, then just change the colors to generate each
flag. Concretely, we‚Äôd like to have a custom operator such as
<code data-lang="pyret" class="sourceCode">three-stripe-flag</code> that we could use as follows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode"># armenia
three-stripe-flag("red", "blue", "orange")

# austria
three-stripe-flag("red", "white", "red")</code></pre><p>In this program, we provide <code data-lang="pyret" class="sourceCode">three-stripe-flag</code> only with the
information that customizes the image creation to a specific flag. The
operation itself would take care of creating and aligning the
rectangles. We want to end up with the same images for the Armenian
and Austrian flags as we would have gotten with our original
program. Such an operator doesn‚Äôt exist in Pyret: it is specific only to
our application of creating flag images. To make this program work, then,
we need the ability to add our own operators (henceforth called
functions) to Pyret.</p></section><section class="SsectionLevel4" id="section 3.3.2"><h4 class="heading">3.3.2¬†<a name="(part._defining-functions)"/>Defining Functions<a href="#(part._defining-functions)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>In programming, a function takes one or more (configuration)
parameters and uses them to produce a result.</p><blockquote class="Strategy"><p class="StrategyHeader">Strategy: Creating Functions From Expressions</p><blockquote class="StrategyBody"><p>If we have multiple concrete expressions that are identical except for
a couple of specific data values, we create a function with the common
code as follows:</p><ul><li><p>Write down at least two expressions showing the desired computation (in this
case, the expressions that produce the Armenian and Austrian flags).</p></li><li><p>Identify which parts are fixed (i.e., the creation of rectangles
with dimensions <code data-lang="pyret" class="sourceCode">120</code> and <code data-lang="pyret" class="sourceCode">30</code>, the use of <code data-lang="pyret" class="sourceCode">above</code> to stack the
rectangles) and which
are changing (i.e., the stripe colors).</p></li><li><p>For each changing part, give it a name (say
<code data-lang="pyret" class="sourceCode">top</code>, <code data-lang="pyret" class="sourceCode">middle</code>, and <code data-lang="pyret" class="sourceCode">bottom</code>), which will be the
parameter that stands for that part.</p></li><li><p>Rewrite the examples to be in terms of these parameters. For example:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">frame(
  above(rectangle(120, 30, "solid", top),
    above(rectangle(120, 30, "solid", middle),
      rectangle(120, 30, "solid", bottom))))</code></pre></li><li><p>Name the function something suggestive: e.g., <code data-lang="pyret" class="sourceCode">three-stripe-flag</code>.</p></li><li><p>Write the syntax for functions around the expression:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun &lt;function name&gt;(&lt;parameters&gt;):
  &lt;the expression goes here&gt;
end</code></pre><p>where the expression is called the body of the
function. (Programmers often use angle brackets to say ‚Äúreplace with
something appropriate‚Äù; the brackets themselves aren‚Äôt part of the notation.)</p></li></ul></blockquote></blockquote><p>Here‚Äôs the end product:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun three-stripe-flag(top, middle, bottom):
  frame(
    above(rectangle(120, 30, "solid", top),
      above(rectangle(120, 30, "solid", middle),
        rectangle(120, 30, "solid", bottom))))
end</code></pre><p>While this looks like a lot of work now, it won‚Äôt once you get used to
it. We will go through the same steps over and over, and eventually
they‚Äôll become so intuitive that you won‚Äôt need to start from multiple
similar expressions.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Why does the function body have only one expression, when before we had a separate one
for each flag?</p></blockquote></blockquote><p>We have only one expression because the whole point was to get rid of
all the changing parts and replace them with parameters.</p><p>With this function in hand, we can write the following two expressions
to generate our original flag images:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">three-stripe-flag("red", "blue", "orange")
three-stripe-flag("red", "white", "red")</code></pre><p>When we provide values for the parameters of a function to get a
result, we say that we are calling the function. We use the
term call for expressions of this form.</p><p>If we want to name the resulting images, we can do so as follows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">armenia = three-stripe-flag("red", "blue", "orange")
austria = three-stripe-flag("red", "white", "red")</code></pre><p>(Side note: Pyret only allows one value per name in the directory. If
your file already had definitions for the names <code data-lang="pyret" class="sourceCode">armenia</code> or
<code data-lang="pyret" class="sourceCode">austria</code>, Pyret will give you an error at this point. You can
use a different name (like <code data-lang="pyret" class="sourceCode">austria2</code>) or comment out the
original definition using <code data-lang="pyret" class="sourceCode">#</code>.)</p><section class="SsectionLevel5" id="section 3.3.2.1"><h5 class="heading">3.3.2.1¬†<a name="(part._function-call-nm)"/>How Functions Evaluate<a href="#(part._function-call-nm)" class="heading-anchor" title="Link to here">üîó</a> </h5><p>So far, we have learned three rules for how Pyret processes your program:</p><ul><li><p>If you write an expression, Pyret evaluates it to produce
its value.</p></li><li><p>If you write a statement that defines a name, Pyret evaluates
the expression (right side of <code data-lang="pyret" class="sourceCode">=</code>), then makes an entry in the
directory to associate the name with the value.</p></li><li><p>If you write an expression that uses a name from the directory,
Pyret substitutes the name with the corresponding value.</p></li></ul><p>Now that we can define our own functions, we have to consider two more
cases: what does Pyret do when you define a function (using
<code data-lang="pyret" class="sourceCode">fun</code>), and what does Pyret do when you call a function
(with values for the parameters)?</p><ul><li><p>When Pyret encounters a function definition in your file, it makes an
entry in the directory to associate the name of the function with its
code. The body of the function does not get evaluated at this time.</p></li><li><p>When Pyret encounters a function call while evaluating an expression,
it replaces the call with the body of the function, but with the
parameter values substituted for the parameter names in the
body. Pyret then continues to evaluate the body with the substituted
values.</p></li></ul><p>As an example of the function-call rule, if you evaluate</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">three-stripe-flag("red", "blue", "orange")</code></pre><p>Pyret starts from the function body</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">frame(
  above(rectangle(120, 30, "solid", top),
    above(rectangle(120, 30, "solid", middle),
      rectangle(120, 30, "solid", bottom))))</code></pre><p>substitutes the parameter values</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">frame(
  above(rectangle(120, 30, "solid", "red"),
    above(rectangle(120, 30, "solid", "blue"),
      rectangle(120, 30, "solid", "orange"))))</code></pre><p>then evaluates the expression, producing the flag image.</p><p>Note that the second expression (with the substituted values) is the
same expression we started from for the Armenian flag. Substitution
restores that expression, while still allowing the programmer to write
the shorthand in terms of <code data-lang="pyret" class="sourceCode">three-stripe-flag</code>.</p></section><section class="SsectionLevel5" id="section 3.3.2.2"><h5 class="heading">3.3.2.2¬†<a name="(part._fun-annotations)"/>Type Annotations<a href="#(part._fun-annotations)" class="heading-anchor" title="Link to here">üîó</a> </h5><p>What if we made a mistake, and tried to call the function as follows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">three-stripe-flag(50, "blue", "red")</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do you think Pyret will produce for this expression?</p></blockquote></blockquote><p>The first parameter to <code data-lang="pyret" class="sourceCode">three-stripe-flag</code> is supposed to be the
color of the top stripe. The value <code data-lang="pyret" class="sourceCode">50</code> is not a string (much less a string naming a
color). Pyret will substitute <code data-lang="pyret" class="sourceCode">50</code> for <code data-lang="pyret" class="sourceCode">top</code> in the first call to
<code data-lang="pyret" class="sourceCode">rectangle</code>, yielding the following:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">frame(
  above(rectangle(120, 30, "solid", 50),
    above(rectangle(120, 30, "solid", "blue"),
      rectangle(120, 30, "solid", "red"))))</code></pre><p>When Pyret tries to evaluate the <code data-lang="pyret" class="sourceCode">rectangle</code> expression to create
the top stripe, it generates an error that refers to that call to
<code data-lang="pyret" class="sourceCode">rectangle</code>.</p><p>If someone else were using your function, this error might not make
sense: they didn‚Äôt write an expression about rectangles. Wouldn‚Äôt it
be better to have Pyret report that there was a problem in the use of
<code data-lang="pyret" class="sourceCode">three-stripe-flag</code> itself?</p><p>As the author of <code data-lang="pyret" class="sourceCode">three-stripe-flag</code>, you can make that happen by
annotating the parameters with information about the expected type of
value for each parameter. Here‚Äôs the function definition again, this
time requiring the three parameters to be strings:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun three-stripe-flag(top :: String,
      middle :: String,
      bottom :: String):
  frame(
    above(rectangle(120, 30, "solid", top),
      above(rectangle(120, 30, "solid", middle),
        rectangle(120, 30, "solid", bottom))))
end</code></pre><p>Notice that the notation here is similar to what we saw in contracts
within the documentation: the parameter name is followed by a
double-colon (<code data-lang="pyret" class="sourceCode">::</code>) and a type name (so far, one of
<code data-lang="pyret" class="sourceCode">Number</code>, <code data-lang="pyret" class="sourceCode">String</code>, or <code data-lang="pyret" class="sourceCode">Image</code>).Putting each parameter
on its own line is not required, but it sometimes helps with readability.</p><p>Run your file with this new definition and try the erroneous call
again. You should get a different error message that is just in terms
of <code data-lang="pyret" class="sourceCode">three-stripe-flag</code>.</p><p>It is also common practice to add a type annotation that captures the
type of the function‚Äôs output. That annotation goes after the list of
parameters:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun three-stripe-flag(top :: String,
      middle :: String,
      bottom :: String) -&gt; Image:
  frame(
    above(rectangle(120, 30, "solid", top),
      above(rectangle(120, 30, "solid", middle),
        rectangle(120, 30, "solid", bottom))))
end</code></pre><p>Note that all of these type annotations are optional. Pyret will run
your program whether or not you include them. You can put type
annotations on some parameters and not others; you can include the
output type but not any of the parameter types. Different programming
languages have different rules about types.</p><p>We will think of types as playing two roles: giving Pyret information
that it can use to focus error messages more accurately, and guiding
human readers of programs as to the proper use of user-defined functions.</p></section><section class="SsectionLevel5" id="section 3.3.2.3"><h5 class="heading">3.3.2.3¬†<a name="(part._doc-strings)"/>Documentation<a href="#(part._doc-strings)" class="heading-anchor" title="Link to here">üîó</a> </h5><p>Imagine that you opened your program file from this chapter a couple
of months from now. Would you remember what computation
<code data-lang="pyret" class="sourceCode">three-stripe-flag</code> does? The name is certainly suggestive, but
it misses details such as that the stripes are stacked vertically
(rather than horizontally) and that the stripes are equal
height. Function names aren‚Äôt designed to carry this much information.</p><p>Programmers also annotate a function with a docstring, a short,
human-language description of what the function does. Here‚Äôs what the
Pyret docstring might look like for <code data-lang="pyret" class="sourceCode">three-stripe-flag</code>:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun three-stripe-flag(top :: String,
      middle :: String,
      bottom :: String) -&gt; Image:
  doc: "produce image of flag with three equal-height horizontal stripes"
  frame(
    above(rectangle(120, 30, "solid", top),
      above(rectangle(120, 30, "solid", middle),
        rectangle(120, 30, "solid", bottom))))
end</code></pre><p>While docstrings are also optional from Pyret‚Äôs perspective, you
should always provide one when you write a function. They are
extremely helpful to anyone who has to read your program, whether that is
a co-worker, grader‚Ä¶or yourself, a couple of weeks from now.</p></section></section><section class="SsectionLevel4" id="section 3.3.3"><h4 class="heading">3.3.3¬†<a name="(part._moon-weight-pyret)"/>Functions Practice: Moon Weight<a href="#(part._moon-weight-pyret)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>Suppose we‚Äôre responsible for outfitting a team of astronauts for
lunar exploration. We have to determine how much each of them will
weigh on the Moon‚Äôs surface. On the Moon, objects weigh only one-sixth
their weight on earth. Here are the expressions for
several astronauts (whose weights are expressed in pounds):
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">100 * 1/6
150 * 1/6
90 * 1/6</code></pre><p>As with our examples of the Armenian and Austrian flags, we are
writing the same expression multiple times. This is another situation
in which we should create a function that takes the changing data as a
parameter but captures the fixed computation only once.</p><p>In the case of the flags, we noticed we had written essentially the
same expression more than once. Here, we have a computation that we
expect to do multiple times (once for each astronaut). It‚Äôs
boring to write the same expression over and over again. Besides, if
we copy or re-type an expression multiple times, sooner or later we‚Äôre
bound to make a transcription error.This is an instance of
the <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY
principle</a>, where DRY means "don‚Äôt repeat yourself".</p><p>Let‚Äôs remind ourselves of the steps for creating a function:</p><ul><li><p>Write down some examples of the desired calculation. We did that
above.</p></li><li><p>Identify which parts are fixed (above, <code data-lang="pyret" class="sourceCode">* 1/6</code>) and which
are changing (above, <code data-lang="pyret" class="sourceCode">100</code>, <code data-lang="pyret" class="sourceCode">150</code>, <code data-lang="pyret" class="sourceCode">90</code>...).</p></li><li><p>For each changing part, give it a name (say
<code data-lang="pyret" class="sourceCode">earth-weight</code>), which will be the parameter that stands for it.</p></li><li><p>Rewrite the examples to be in terms of this parameter:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">earth-weight * 1/6</code></pre><p>This will be the body, i.e., the expression inside
the function.</p></li><li><p>Come up with a suggestive name for the function: e.g., <code data-lang="pyret" class="sourceCode">moon-weight</code>.</p></li><li><p>Write the syntax for functions around the body expression:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun moon-weight(earth-weight):
  earth-weight * 1/6
end</code></pre></li><li><p>Remember to include the types of the parameter and output, as
well as the documentation string. This yields the final function:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun moon-weight(earth-weight :: Number) -&gt; Number:
  doc: "Compute weight on moon from weight on earth"
  earth-weight * 1/6
end</code></pre></li></ul></section><section class="SsectionLevel4" id="section 3.3.4"><h4 class="heading">3.3.4¬†<a name="(part._writing-examples)"/>Documenting Functions with Examples<a href="#(part._writing-examples)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>In each of the functions above, we‚Äôve started with some examples of
what we wanted to compute, generalized from there to a generic
formula, turned this into a function, and then used the function in
place of the original expressions.</p><p>Now that we‚Äôre done, what use are the initial examples? It seems
tempting to toss them away. However, there‚Äôs an important rule about
software that you should learn: Software Evolves. Over time,
any program that has any use will change and grow, and as a result may
end up producing different values than it did initially. Sometimes
these are intended, but sometimes these are a result of mistakes
(including such silly but inevitable mistakes like accidentally adding
or deleting text while typing). Therefore, it‚Äôs always useful to keep
those examples around for future reference, so you can immediately be
alerted if the function deviates from the examples it was supposed to
generalize.</p><p>Pyret makes this easy to do. Every function can be accompanied by a
<code data-lang="pyret" class="sourceCode">where</code> clause that records the examples. For instance, our
<code data-lang="pyret" class="sourceCode">moon-weight</code> function can be modified to read:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun moon-weight(earth-weight :: Number) -&gt; Number:
  doc: "Compute weight on moon from weight on earth"
  earth-weight * 1/6
where:
  moon-weight(100) is 100 * 1/6
  moon-weight(150) is 150 * 1/6
  moon-weight(90) is 90 * 1/6
end</code></pre><p>When written this way, Pyret will actually check the answers every
time you run the program, and notify you if you have changed the
function to be inconsistent with these examples.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Check this! Change the formula‚Äî<wbr/>for instance, replace the body of the
function with
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">earth-weight * 1/3</code></pre><p>‚Äî<wbr/>and see what happens. Pay attention to the output from CPO: you
should get used to recognizing this kind of output.</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Now, fix the function body, and instead change one of the answers‚Äî<wbr/>e.g., write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">moon-weight(90) is 90 * 1/3</code></pre><p>‚Äî<wbr/>and see what happens. Contrast the output in this case with the output above.</p></blockquote></blockquote><p>Of course, it‚Äôs pretty unlikely you will make a mistake with a
function this simple (except through a typo). After all, the examples
are so similar to the function‚Äôs own body. Later, however, we will see
that the examples can be much simpler than the body, and there is a real chance
for things to get inconsistent. At that point, the examples become invaluable
in making sure we haven‚Äôt made a mistake in our program. In fact, this is so
valuable in professional software development that good programmers
always write down large collections of examples‚Äî<wbr/>called
tests‚Äî<wbr/>to make sure their programs are behaving as they expect.</p><p>For our purposes, we are writing examples as part of the process of
making sure we understand the problem. It‚Äôs always a good idea
to make sure you understand the question before you start writing
code to solve a problem. Examples are a nice intermediate point: you
can sketch out the relevant computation on concrete
values first, then worry about turning it into a function. If you
can‚Äôt write the examples, chances are you won‚Äôt be able to write the
function either. Examples break down the programming process into
smaller, manageable steps.</p></section><section class="SsectionLevel4" id="section 3.3.5"><h4 class="heading">3.3.5¬†<a name="(part._pen-cost-pyret)"/>Functions Practice: Cost of pens<a href="#(part._pen-cost-pyret)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>Let‚Äôs create one more function, this time for a more complicated example.
Imagine that you are trying to compute the total cost of an order of
pens with slogans (or messages) printed on them.  Each pen costs 25
cents plus an additional 2 cents per character in the message (we‚Äôll
count spaces between words as characters).</p><p>Following our steps to create a function once again,
let‚Äôs start by writing two concrete expressions that do this
computation.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode"># ordering 3 pens that say "wow"
3 * (0.25 + (string-length("wow") * 0.02))

# ordering 10 pens that say "smile"
10 * (0.25 + (string-length("smile") * 0.02))</code></pre><p>These examples introduce a new built-in function called
<code data-lang="pyret" class="sourceCode">string-length</code>. It takes a string as input and produces the
number of characters (including spaces and punctuation) in the string.
These examples also show an example of working with
numbers other than integers.Pyret requires a number before the
decimal point, so if the ‚Äúwhole number‚Äù part is zero, you need to write
<code data-lang="pyret" class="sourceCode">0</code> before the decimal. Also observe that Pyret uses a decimal
point; it doesn‚Äôt support conventions such as
<a href="https://en.wikipedia.org/wiki/Decimal_separator">‚Äú0,02‚Äù</a>.</p><p>The second step to writing a function was to identify which
information differs across our two examples. In this case, we have
two: the number of pens and the message to put on the pens.
This means our function will have two parameters rather than just one.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pen-cost(num-pens :: Number, message :: String) -&gt; Number:
  num-pens * (0.25 + (string-length(message) * 0.02))
end</code></pre><p>Of course, as things get too long, it may be helpful to use multiple lines:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pen-cost(num-pens :: Number, message :: String)
  -&gt; Number:
  num-pens * (0.25 + (string-length(message) * 0.02))
end</code></pre><p>If you want to write a multi-line docstring, you need to use <code data-lang="pyret" class="sourceCode">```</code> rather
than <code data-lang="pyret" class="sourceCode">"</code> to begin and end it, like so:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pen-cost(num-pens :: Number, message :: String)
  -&gt; Number:
  doc: ```total cost for pens, each 25 cents
       plus 2 cents per message character```
  num-pens * (0.25 + (string-length(message) * 0.02))
end</code></pre><p>We should also document the examples that we used when creating the
function:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pen-cost(num-pens :: Number, message :: String)
  -&gt; Number:
  doc: ```total cost for pens, each 25 cents
       plus 2 cents per message character```
  num-pens * (0.25 + (string-length(message) * 0.02))
where:
  pen-cost(3, "wow")
    is 3 * (0.25 + (string-length("wow") * 0.02))
  pen-cost(10, "smile")
    is 10 * (0.25 + (string-length("smile") * 0.02))
end</code></pre><p>When writing <code data-lang="pyret" class="sourceCode">where</code> examples, we also want to include special
yet valid cases that the function might have to handle, such as an empty
message.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pen-cost(5, "") is 5 * 0.25</code></pre><p>Note that our empty-message example has a simpler expression on the
right side of <code data-lang="pyret" class="sourceCode">is</code>. The expression for what the function returns
doesn‚Äôt have to match the body expression; it simply has to evaluate
to the same value as you expect the example to produce. Sometimes,
we‚Äôll find it easier to just write the expected value directly. For
the case of someone ordering no pens, for example, we‚Äôd include:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pen-cost(0, "bears") is 0</code></pre><p>The point of the examples is to document how a function behaves on a
variety of inputs. What goes to the right of the <code data-lang="pyret" class="sourceCode">is</code> should
summarize the computation or the answer in some meaningful way. Most
important? Do not write the function, run it to determine the answer,
then put that answer on the right side of the <code data-lang="pyret" class="sourceCode">is</code>! Why not?
Because the examples are meant to give some redundancy to the design
process, so that you catch errors you might have made. If your
function body is incorrect, and you use the function to generate the
example, you won‚Äôt get the benefit of using the example to check for
errors.</p><p>We‚Äôll keep returning to this idea of writing good examples. Don‚Äôt
worry if you still have questions for now. Also, for the time being,
we won‚Äôt worry about nonsensical situations like negative numbers of
pens. We‚Äôll get to those after we‚Äôve learned additional coding
techniques that will help us handle such situations properly.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>We could have combined our two special cases into one example, such as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pen-cost(0, "") is 0</code></pre><p>Does doing this seem like a good idea? Why or why not?</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 3.3.6"><h4 class="heading">3.3.6¬†<a name="(part._.Recap__.Defining_.Functions)"/>Recap: Defining Functions<a href="#(part._.Recap__.Defining_.Functions)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>This chapter has introduced the idea of a function. Functions play a
key role in programming: they let us configure computations with
different concrete values at different times. The first time we
compute the cost of pens, we might be asking about <code data-lang="pyret" class="sourceCode">10</code> pens that say
<code data-lang="pyret" class="sourceCode">"Welcome"</code>. The next time, we might be asking about <code data-lang="pyret" class="sourceCode">100</code> pens that say
<code data-lang="pyret" class="sourceCode">"Go Bears!"</code>. The core computation is the same in both cases, so we
want to write it out once, configuring it with different concrete
values each time we use it.</p><p>We‚Äôve covered several specific ideas about functions:</p><ul><li><p>We showed the <code data-lang="pyret" class="sourceCode">fun</code> notation for writing functions. You learned
that a function has a name (that we can use to refer to it),
one or more parameters (names for the values we want to configure), as
well as a body, which is the computation that we want to
perform once we have concrete values for the parameters.</p></li><li><p>We showed that we should include examples with our functions,
to illustrate what the function computes on various specific
values. Examples go in a <code data-lang="pyret" class="sourceCode">where</code> block within the function.</p></li><li><p>We showed that we can use a function by providing concrete
values to configure its parameters. To do this, we write the name of
the function we want to use, followed by a pair of parenthesis around
comma-separated values for the parameters. For example, writing the following
expression (at the interactions prompt) will compute the cost of a
specific order of pens:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pen-cost(10, "Welcome")</code></pre></li><li><p>We discussed that if we define a function in the definitions
pane then press Run, Pyret will make an entry in the directory with
the name of the function. If we later use the function, Pyret will
look up the code that goes with that name, substitute the concrete
values we provided for the parameters, and return the result of
evaluating the resulting expression. Pyret will NOT produce anything
in the interactions pane for a function definition (other than a
report about whether the examples hold).</p></li></ul><p>There‚Äôs much more to learn about functions, including different
reasons for creating them. We‚Äôll get to those in due course.</p></section>&#13;
<h4 class="heading">3.3.1¬†<a name="(part._similar-flags)"/>Example: Similar Flags<a href="#(part._similar-flags)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>Consider the following two expressions to draw the flags of Armenia
and Austria (respectively).  These two countries have the same flag,
just with different colors. The <code data-lang="pyret" class="sourceCode">frame</code> operator draws a small
black frame around the image.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode"># Lines starting with # are comments for human readers.
# Pyret ignores everything on a line after #.

# armenia
frame(
  above(rectangle(120, 30, "solid", "red"),
    above(rectangle(120, 30, "solid", "blue"),
      rectangle(120, 30, "solid", "orange"))))

# austria
frame(
  above(rectangle(120, 30, "solid", "red"),
    above(rectangle(120, 30, "solid", "white"),
      rectangle(120, 30, "solid", "red"))))</code></pre><p>Rather than write this program twice, it would be nice to write the
common expression only once, then just change the colors to generate each
flag. Concretely, we‚Äôd like to have a custom operator such as
<code data-lang="pyret" class="sourceCode">three-stripe-flag</code> that we could use as follows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode"># armenia
three-stripe-flag("red", "blue", "orange")

# austria
three-stripe-flag("red", "white", "red")</code></pre><p>In this program, we provide <code data-lang="pyret" class="sourceCode">three-stripe-flag</code> only with the
information that customizes the image creation to a specific flag. The
operation itself would take care of creating and aligning the
rectangles. We want to end up with the same images for the Armenian
and Austrian flags as we would have gotten with our original
program. Such an operator doesn‚Äôt exist in Pyret: it is specific only to
our application of creating flag images. To make this program work, then,
we need the ability to add our own operators (henceforth called
functions) to Pyret.</p>&#13;
<h4 class="heading">3.3.2¬†<a name="(part._defining-functions)"/>Defining Functions<a href="#(part._defining-functions)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>In programming, a function takes one or more (configuration)
parameters and uses them to produce a result.</p><blockquote class="Strategy"><p class="StrategyHeader">Strategy: Creating Functions From Expressions</p><blockquote class="StrategyBody"><p>If we have multiple concrete expressions that are identical except for
a couple of specific data values, we create a function with the common
code as follows:</p><ul><li><p>Write down at least two expressions showing the desired computation (in this
case, the expressions that produce the Armenian and Austrian flags).</p></li><li><p>Identify which parts are fixed (i.e., the creation of rectangles
with dimensions <code data-lang="pyret" class="sourceCode">120</code> and <code data-lang="pyret" class="sourceCode">30</code>, the use of <code data-lang="pyret" class="sourceCode">above</code> to stack the
rectangles) and which
are changing (i.e., the stripe colors).</p></li><li><p>For each changing part, give it a name (say
<code data-lang="pyret" class="sourceCode">top</code>, <code data-lang="pyret" class="sourceCode">middle</code>, and <code data-lang="pyret" class="sourceCode">bottom</code>), which will be the
parameter that stands for that part.</p></li><li><p>Rewrite the examples to be in terms of these parameters. For example:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">frame(
  above(rectangle(120, 30, "solid", top),
    above(rectangle(120, 30, "solid", middle),
      rectangle(120, 30, "solid", bottom))))</code></pre></li><li><p>Name the function something suggestive: e.g., <code data-lang="pyret" class="sourceCode">three-stripe-flag</code>.</p></li><li><p>Write the syntax for functions around the expression:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun &lt;function name&gt;(&lt;parameters&gt;):
  &lt;the expression goes here&gt;
end</code></pre><p>where the expression is called the body of the
function. (Programmers often use angle brackets to say ‚Äúreplace with
something appropriate‚Äù; the brackets themselves aren‚Äôt part of the notation.)</p></li></ul></blockquote></blockquote><p>Here‚Äôs the end product:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun three-stripe-flag(top, middle, bottom):
  frame(
    above(rectangle(120, 30, "solid", top),
      above(rectangle(120, 30, "solid", middle),
        rectangle(120, 30, "solid", bottom))))
end</code></pre><p>While this looks like a lot of work now, it won‚Äôt once you get used to
it. We will go through the same steps over and over, and eventually
they‚Äôll become so intuitive that you won‚Äôt need to start from multiple
similar expressions.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Why does the function body have only one expression, when before we had a separate one
for each flag?</p></blockquote></blockquote><p>We have only one expression because the whole point was to get rid of
all the changing parts and replace them with parameters.</p><p>With this function in hand, we can write the following two expressions
to generate our original flag images:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">three-stripe-flag("red", "blue", "orange")
three-stripe-flag("red", "white", "red")</code></pre><p>When we provide values for the parameters of a function to get a
result, we say that we are calling the function. We use the
term call for expressions of this form.</p><p>If we want to name the resulting images, we can do so as follows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">armenia = three-stripe-flag("red", "blue", "orange")
austria = three-stripe-flag("red", "white", "red")</code></pre><p>(Side note: Pyret only allows one value per name in the directory. If
your file already had definitions for the names <code data-lang="pyret" class="sourceCode">armenia</code> or
<code data-lang="pyret" class="sourceCode">austria</code>, Pyret will give you an error at this point. You can
use a different name (like <code data-lang="pyret" class="sourceCode">austria2</code>) or comment out the
original definition using <code data-lang="pyret" class="sourceCode">#</code>.)</p><section class="SsectionLevel5" id="section 3.3.2.1"><h5 class="heading">3.3.2.1¬†<a name="(part._function-call-nm)"/>How Functions Evaluate<a href="#(part._function-call-nm)" class="heading-anchor" title="Link to here">üîó</a> </h5><p>So far, we have learned three rules for how Pyret processes your program:</p><ul><li><p>If you write an expression, Pyret evaluates it to produce
its value.</p></li><li><p>If you write a statement that defines a name, Pyret evaluates
the expression (right side of <code data-lang="pyret" class="sourceCode">=</code>), then makes an entry in the
directory to associate the name with the value.</p></li><li><p>If you write an expression that uses a name from the directory,
Pyret substitutes the name with the corresponding value.</p></li></ul><p>Now that we can define our own functions, we have to consider two more
cases: what does Pyret do when you define a function (using
<code data-lang="pyret" class="sourceCode">fun</code>), and what does Pyret do when you call a function
(with values for the parameters)?</p><ul><li><p>When Pyret encounters a function definition in your file, it makes an
entry in the directory to associate the name of the function with its
code. The body of the function does not get evaluated at this time.</p></li><li><p>When Pyret encounters a function call while evaluating an expression,
it replaces the call with the body of the function, but with the
parameter values substituted for the parameter names in the
body. Pyret then continues to evaluate the body with the substituted
values.</p></li></ul><p>As an example of the function-call rule, if you evaluate</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">three-stripe-flag("red", "blue", "orange")</code></pre><p>Pyret starts from the function body</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">frame(
  above(rectangle(120, 30, "solid", top),
    above(rectangle(120, 30, "solid", middle),
      rectangle(120, 30, "solid", bottom))))</code></pre><p>substitutes the parameter values</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">frame(
  above(rectangle(120, 30, "solid", "red"),
    above(rectangle(120, 30, "solid", "blue"),
      rectangle(120, 30, "solid", "orange"))))</code></pre><p>then evaluates the expression, producing the flag image.</p><p>Note that the second expression (with the substituted values) is the
same expression we started from for the Armenian flag. Substitution
restores that expression, while still allowing the programmer to write
the shorthand in terms of <code data-lang="pyret" class="sourceCode">three-stripe-flag</code>.</p></section><section class="SsectionLevel5" id="section 3.3.2.2"><h5 class="heading">3.3.2.2¬†<a name="(part._fun-annotations)"/>Type Annotations<a href="#(part._fun-annotations)" class="heading-anchor" title="Link to here">üîó</a> </h5><p>What if we made a mistake, and tried to call the function as follows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">three-stripe-flag(50, "blue", "red")</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do you think Pyret will produce for this expression?</p></blockquote></blockquote><p>The first parameter to <code data-lang="pyret" class="sourceCode">three-stripe-flag</code> is supposed to be the
color of the top stripe. The value <code data-lang="pyret" class="sourceCode">50</code> is not a string (much less a string naming a
color). Pyret will substitute <code data-lang="pyret" class="sourceCode">50</code> for <code data-lang="pyret" class="sourceCode">top</code> in the first call to
<code data-lang="pyret" class="sourceCode">rectangle</code>, yielding the following:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">frame(
  above(rectangle(120, 30, "solid", 50),
    above(rectangle(120, 30, "solid", "blue"),
      rectangle(120, 30, "solid", "red"))))</code></pre><p>When Pyret tries to evaluate the <code data-lang="pyret" class="sourceCode">rectangle</code> expression to create
the top stripe, it generates an error that refers to that call to
<code data-lang="pyret" class="sourceCode">rectangle</code>.</p><p>If someone else were using your function, this error might not make
sense: they didn‚Äôt write an expression about rectangles. Wouldn‚Äôt it
be better to have Pyret report that there was a problem in the use of
<code data-lang="pyret" class="sourceCode">three-stripe-flag</code> itself?</p><p>As the author of <code data-lang="pyret" class="sourceCode">three-stripe-flag</code>, you can make that happen by
annotating the parameters with information about the expected type of
value for each parameter. Here‚Äôs the function definition again, this
time requiring the three parameters to be strings:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun three-stripe-flag(top :: String,
      middle :: String,
      bottom :: String):
  frame(
    above(rectangle(120, 30, "solid", top),
      above(rectangle(120, 30, "solid", middle),
        rectangle(120, 30, "solid", bottom))))
end</code></pre><p>Notice that the notation here is similar to what we saw in contracts
within the documentation: the parameter name is followed by a
double-colon (<code data-lang="pyret" class="sourceCode">::</code>) and a type name (so far, one of
<code data-lang="pyret" class="sourceCode">Number</code>, <code data-lang="pyret" class="sourceCode">String</code>, or <code data-lang="pyret" class="sourceCode">Image</code>).Putting each parameter
on its own line is not required, but it sometimes helps with readability.</p><p>Run your file with this new definition and try the erroneous call
again. You should get a different error message that is just in terms
of <code data-lang="pyret" class="sourceCode">three-stripe-flag</code>.</p><p>It is also common practice to add a type annotation that captures the
type of the function‚Äôs output. That annotation goes after the list of
parameters:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun three-stripe-flag(top :: String,
      middle :: String,
      bottom :: String) -&gt; Image:
  frame(
    above(rectangle(120, 30, "solid", top),
      above(rectangle(120, 30, "solid", middle),
        rectangle(120, 30, "solid", bottom))))
end</code></pre><p>Note that all of these type annotations are optional. Pyret will run
your program whether or not you include them. You can put type
annotations on some parameters and not others; you can include the
output type but not any of the parameter types. Different programming
languages have different rules about types.</p><p>We will think of types as playing two roles: giving Pyret information
that it can use to focus error messages more accurately, and guiding
human readers of programs as to the proper use of user-defined functions.</p></section><section class="SsectionLevel5" id="section 3.3.2.3"><h5 class="heading">3.3.2.3¬†<a name="(part._doc-strings)"/>Documentation<a href="#(part._doc-strings)" class="heading-anchor" title="Link to here">üîó</a> </h5><p>Imagine that you opened your program file from this chapter a couple
of months from now. Would you remember what computation
<code data-lang="pyret" class="sourceCode">three-stripe-flag</code> does? The name is certainly suggestive, but
it misses details such as that the stripes are stacked vertically
(rather than horizontally) and that the stripes are equal
height. Function names aren‚Äôt designed to carry this much information.</p><p>Programmers also annotate a function with a docstring, a short,
human-language description of what the function does. Here‚Äôs what the
Pyret docstring might look like for <code data-lang="pyret" class="sourceCode">three-stripe-flag</code>:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun three-stripe-flag(top :: String,
      middle :: String,
      bottom :: String) -&gt; Image:
  doc: "produce image of flag with three equal-height horizontal stripes"
  frame(
    above(rectangle(120, 30, "solid", top),
      above(rectangle(120, 30, "solid", middle),
        rectangle(120, 30, "solid", bottom))))
end</code></pre><p>While docstrings are also optional from Pyret‚Äôs perspective, you
should always provide one when you write a function. They are
extremely helpful to anyone who has to read your program, whether that is
a co-worker, grader‚Ä¶or yourself, a couple of weeks from now.</p></section>&#13;
<h5 class="heading">3.3.2.1¬†<a name="(part._function-call-nm)"/>How Functions Evaluate<a href="#(part._function-call-nm)" class="heading-anchor" title="Link to here">üîó</a> </h5><p>So far, we have learned three rules for how Pyret processes your program:</p><ul><li><p>If you write an expression, Pyret evaluates it to produce
its value.</p></li><li><p>If you write a statement that defines a name, Pyret evaluates
the expression (right side of <code data-lang="pyret" class="sourceCode">=</code>), then makes an entry in the
directory to associate the name with the value.</p></li><li><p>If you write an expression that uses a name from the directory,
Pyret substitutes the name with the corresponding value.</p></li></ul><p>Now that we can define our own functions, we have to consider two more
cases: what does Pyret do when you define a function (using
<code data-lang="pyret" class="sourceCode">fun</code>), and what does Pyret do when you call a function
(with values for the parameters)?</p><ul><li><p>When Pyret encounters a function definition in your file, it makes an
entry in the directory to associate the name of the function with its
code. The body of the function does not get evaluated at this time.</p></li><li><p>When Pyret encounters a function call while evaluating an expression,
it replaces the call with the body of the function, but with the
parameter values substituted for the parameter names in the
body. Pyret then continues to evaluate the body with the substituted
values.</p></li></ul><p>As an example of the function-call rule, if you evaluate</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">three-stripe-flag("red", "blue", "orange")</code></pre><p>Pyret starts from the function body</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">frame(
  above(rectangle(120, 30, "solid", top),
    above(rectangle(120, 30, "solid", middle),
      rectangle(120, 30, "solid", bottom))))</code></pre><p>substitutes the parameter values</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">frame(
  above(rectangle(120, 30, "solid", "red"),
    above(rectangle(120, 30, "solid", "blue"),
      rectangle(120, 30, "solid", "orange"))))</code></pre><p>then evaluates the expression, producing the flag image.</p><p>Note that the second expression (with the substituted values) is the
same expression we started from for the Armenian flag. Substitution
restores that expression, while still allowing the programmer to write
the shorthand in terms of <code data-lang="pyret" class="sourceCode">three-stripe-flag</code>.</p>&#13;
<h5 class="heading">3.3.2.2¬†<a name="(part._fun-annotations)"/>Type Annotations<a href="#(part._fun-annotations)" class="heading-anchor" title="Link to here">üîó</a> </h5><p>What if we made a mistake, and tried to call the function as follows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">three-stripe-flag(50, "blue", "red")</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do you think Pyret will produce for this expression?</p></blockquote></blockquote><p>The first parameter to <code data-lang="pyret" class="sourceCode">three-stripe-flag</code> is supposed to be the
color of the top stripe. The value <code data-lang="pyret" class="sourceCode">50</code> is not a string (much less a string naming a
color). Pyret will substitute <code data-lang="pyret" class="sourceCode">50</code> for <code data-lang="pyret" class="sourceCode">top</code> in the first call to
<code data-lang="pyret" class="sourceCode">rectangle</code>, yielding the following:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">frame(
  above(rectangle(120, 30, "solid", 50),
    above(rectangle(120, 30, "solid", "blue"),
      rectangle(120, 30, "solid", "red"))))</code></pre><p>When Pyret tries to evaluate the <code data-lang="pyret" class="sourceCode">rectangle</code> expression to create
the top stripe, it generates an error that refers to that call to
<code data-lang="pyret" class="sourceCode">rectangle</code>.</p><p>If someone else were using your function, this error might not make
sense: they didn‚Äôt write an expression about rectangles. Wouldn‚Äôt it
be better to have Pyret report that there was a problem in the use of
<code data-lang="pyret" class="sourceCode">three-stripe-flag</code> itself?</p><p>As the author of <code data-lang="pyret" class="sourceCode">three-stripe-flag</code>, you can make that happen by
annotating the parameters with information about the expected type of
value for each parameter. Here‚Äôs the function definition again, this
time requiring the three parameters to be strings:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun three-stripe-flag(top :: String,
      middle :: String,
      bottom :: String):
  frame(
    above(rectangle(120, 30, "solid", top),
      above(rectangle(120, 30, "solid", middle),
        rectangle(120, 30, "solid", bottom))))
end</code></pre><p>Notice that the notation here is similar to what we saw in contracts
within the documentation: the parameter name is followed by a
double-colon (<code data-lang="pyret" class="sourceCode">::</code>) and a type name (so far, one of
<code data-lang="pyret" class="sourceCode">Number</code>, <code data-lang="pyret" class="sourceCode">String</code>, or <code data-lang="pyret" class="sourceCode">Image</code>).Putting each parameter
on its own line is not required, but it sometimes helps with readability.</p><p>Run your file with this new definition and try the erroneous call
again. You should get a different error message that is just in terms
of <code data-lang="pyret" class="sourceCode">three-stripe-flag</code>.</p><p>It is also common practice to add a type annotation that captures the
type of the function‚Äôs output. That annotation goes after the list of
parameters:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun three-stripe-flag(top :: String,
      middle :: String,
      bottom :: String) -&gt; Image:
  frame(
    above(rectangle(120, 30, "solid", top),
      above(rectangle(120, 30, "solid", middle),
        rectangle(120, 30, "solid", bottom))))
end</code></pre><p>Note that all of these type annotations are optional. Pyret will run
your program whether or not you include them. You can put type
annotations on some parameters and not others; you can include the
output type but not any of the parameter types. Different programming
languages have different rules about types.</p><p>We will think of types as playing two roles: giving Pyret information
that it can use to focus error messages more accurately, and guiding
human readers of programs as to the proper use of user-defined functions.</p>&#13;
<h5 class="heading">3.3.2.3¬†<a name="(part._doc-strings)"/>Documentation<a href="#(part._doc-strings)" class="heading-anchor" title="Link to here">üîó</a> </h5><p>Imagine that you opened your program file from this chapter a couple
of months from now. Would you remember what computation
<code data-lang="pyret" class="sourceCode">three-stripe-flag</code> does? The name is certainly suggestive, but
it misses details such as that the stripes are stacked vertically
(rather than horizontally) and that the stripes are equal
height. Function names aren‚Äôt designed to carry this much information.</p><p>Programmers also annotate a function with a docstring, a short,
human-language description of what the function does. Here‚Äôs what the
Pyret docstring might look like for <code data-lang="pyret" class="sourceCode">three-stripe-flag</code>:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun three-stripe-flag(top :: String,
      middle :: String,
      bottom :: String) -&gt; Image:
  doc: "produce image of flag with three equal-height horizontal stripes"
  frame(
    above(rectangle(120, 30, "solid", top),
      above(rectangle(120, 30, "solid", middle),
        rectangle(120, 30, "solid", bottom))))
end</code></pre><p>While docstrings are also optional from Pyret‚Äôs perspective, you
should always provide one when you write a function. They are
extremely helpful to anyone who has to read your program, whether that is
a co-worker, grader‚Ä¶or yourself, a couple of weeks from now.</p>&#13;
<h4 class="heading">3.3.3¬†<a name="(part._moon-weight-pyret)"/>Functions Practice: Moon Weight<a href="#(part._moon-weight-pyret)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>Suppose we‚Äôre responsible for outfitting a team of astronauts for
lunar exploration. We have to determine how much each of them will
weigh on the Moon‚Äôs surface. On the Moon, objects weigh only one-sixth
their weight on earth. Here are the expressions for
several astronauts (whose weights are expressed in pounds):
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">100 * 1/6
150 * 1/6
90 * 1/6</code></pre><p>As with our examples of the Armenian and Austrian flags, we are
writing the same expression multiple times. This is another situation
in which we should create a function that takes the changing data as a
parameter but captures the fixed computation only once.</p><p>In the case of the flags, we noticed we had written essentially the
same expression more than once. Here, we have a computation that we
expect to do multiple times (once for each astronaut). It‚Äôs
boring to write the same expression over and over again. Besides, if
we copy or re-type an expression multiple times, sooner or later we‚Äôre
bound to make a transcription error.This is an instance of
the <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY
principle</a>, where DRY means "don‚Äôt repeat yourself".</p><p>Let‚Äôs remind ourselves of the steps for creating a function:</p><ul><li><p>Write down some examples of the desired calculation. We did that
above.</p></li><li><p>Identify which parts are fixed (above, <code data-lang="pyret" class="sourceCode">* 1/6</code>) and which
are changing (above, <code data-lang="pyret" class="sourceCode">100</code>, <code data-lang="pyret" class="sourceCode">150</code>, <code data-lang="pyret" class="sourceCode">90</code>...).</p></li><li><p>For each changing part, give it a name (say
<code data-lang="pyret" class="sourceCode">earth-weight</code>), which will be the parameter that stands for it.</p></li><li><p>Rewrite the examples to be in terms of this parameter:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">earth-weight * 1/6</code></pre><p>This will be the body, i.e., the expression inside
the function.</p></li><li><p>Come up with a suggestive name for the function: e.g., <code data-lang="pyret" class="sourceCode">moon-weight</code>.</p></li><li><p>Write the syntax for functions around the body expression:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun moon-weight(earth-weight):
  earth-weight * 1/6
end</code></pre></li><li><p>Remember to include the types of the parameter and output, as
well as the documentation string. This yields the final function:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun moon-weight(earth-weight :: Number) -&gt; Number:
  doc: "Compute weight on moon from weight on earth"
  earth-weight * 1/6
end</code></pre></li></ul>&#13;
<h4 class="heading">3.3.4¬†<a name="(part._writing-examples)"/>Documenting Functions with Examples<a href="#(part._writing-examples)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>In each of the functions above, we‚Äôve started with some examples of
what we wanted to compute, generalized from there to a generic
formula, turned this into a function, and then used the function in
place of the original expressions.</p><p>Now that we‚Äôre done, what use are the initial examples? It seems
tempting to toss them away. However, there‚Äôs an important rule about
software that you should learn: Software Evolves. Over time,
any program that has any use will change and grow, and as a result may
end up producing different values than it did initially. Sometimes
these are intended, but sometimes these are a result of mistakes
(including such silly but inevitable mistakes like accidentally adding
or deleting text while typing). Therefore, it‚Äôs always useful to keep
those examples around for future reference, so you can immediately be
alerted if the function deviates from the examples it was supposed to
generalize.</p><p>Pyret makes this easy to do. Every function can be accompanied by a
<code data-lang="pyret" class="sourceCode">where</code> clause that records the examples. For instance, our
<code data-lang="pyret" class="sourceCode">moon-weight</code> function can be modified to read:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun moon-weight(earth-weight :: Number) -&gt; Number:
  doc: "Compute weight on moon from weight on earth"
  earth-weight * 1/6
where:
  moon-weight(100) is 100 * 1/6
  moon-weight(150) is 150 * 1/6
  moon-weight(90) is 90 * 1/6
end</code></pre><p>When written this way, Pyret will actually check the answers every
time you run the program, and notify you if you have changed the
function to be inconsistent with these examples.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Check this! Change the formula‚Äî<wbr/>for instance, replace the body of the
function with
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">earth-weight * 1/3</code></pre><p>‚Äî<wbr/>and see what happens. Pay attention to the output from CPO: you
should get used to recognizing this kind of output.</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Now, fix the function body, and instead change one of the answers‚Äî<wbr/>e.g., write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">moon-weight(90) is 90 * 1/3</code></pre><p>‚Äî<wbr/>and see what happens. Contrast the output in this case with the output above.</p></blockquote></blockquote><p>Of course, it‚Äôs pretty unlikely you will make a mistake with a
function this simple (except through a typo). After all, the examples
are so similar to the function‚Äôs own body. Later, however, we will see
that the examples can be much simpler than the body, and there is a real chance
for things to get inconsistent. At that point, the examples become invaluable
in making sure we haven‚Äôt made a mistake in our program. In fact, this is so
valuable in professional software development that good programmers
always write down large collections of examples‚Äî<wbr/>called
tests‚Äî<wbr/>to make sure their programs are behaving as they expect.</p><p>For our purposes, we are writing examples as part of the process of
making sure we understand the problem. It‚Äôs always a good idea
to make sure you understand the question before you start writing
code to solve a problem. Examples are a nice intermediate point: you
can sketch out the relevant computation on concrete
values first, then worry about turning it into a function. If you
can‚Äôt write the examples, chances are you won‚Äôt be able to write the
function either. Examples break down the programming process into
smaller, manageable steps.</p>&#13;
<h4 class="heading">3.3.5¬†<a name="(part._pen-cost-pyret)"/>Functions Practice: Cost of pens<a href="#(part._pen-cost-pyret)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>Let‚Äôs create one more function, this time for a more complicated example.
Imagine that you are trying to compute the total cost of an order of
pens with slogans (or messages) printed on them.  Each pen costs 25
cents plus an additional 2 cents per character in the message (we‚Äôll
count spaces between words as characters).</p><p>Following our steps to create a function once again,
let‚Äôs start by writing two concrete expressions that do this
computation.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode"># ordering 3 pens that say "wow"
3 * (0.25 + (string-length("wow") * 0.02))

# ordering 10 pens that say "smile"
10 * (0.25 + (string-length("smile") * 0.02))</code></pre><p>These examples introduce a new built-in function called
<code data-lang="pyret" class="sourceCode">string-length</code>. It takes a string as input and produces the
number of characters (including spaces and punctuation) in the string.
These examples also show an example of working with
numbers other than integers.Pyret requires a number before the
decimal point, so if the ‚Äúwhole number‚Äù part is zero, you need to write
<code data-lang="pyret" class="sourceCode">0</code> before the decimal. Also observe that Pyret uses a decimal
point; it doesn‚Äôt support conventions such as
<a href="https://en.wikipedia.org/wiki/Decimal_separator">‚Äú0,02‚Äù</a>.</p><p>The second step to writing a function was to identify which
information differs across our two examples. In this case, we have
two: the number of pens and the message to put on the pens.
This means our function will have two parameters rather than just one.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pen-cost(num-pens :: Number, message :: String) -&gt; Number:
  num-pens * (0.25 + (string-length(message) * 0.02))
end</code></pre><p>Of course, as things get too long, it may be helpful to use multiple lines:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pen-cost(num-pens :: Number, message :: String)
  -&gt; Number:
  num-pens * (0.25 + (string-length(message) * 0.02))
end</code></pre><p>If you want to write a multi-line docstring, you need to use <code data-lang="pyret" class="sourceCode">```</code> rather
than <code data-lang="pyret" class="sourceCode">"</code> to begin and end it, like so:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pen-cost(num-pens :: Number, message :: String)
  -&gt; Number:
  doc: ```total cost for pens, each 25 cents
       plus 2 cents per message character```
  num-pens * (0.25 + (string-length(message) * 0.02))
end</code></pre><p>We should also document the examples that we used when creating the
function:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pen-cost(num-pens :: Number, message :: String)
  -&gt; Number:
  doc: ```total cost for pens, each 25 cents
       plus 2 cents per message character```
  num-pens * (0.25 + (string-length(message) * 0.02))
where:
  pen-cost(3, "wow")
    is 3 * (0.25 + (string-length("wow") * 0.02))
  pen-cost(10, "smile")
    is 10 * (0.25 + (string-length("smile") * 0.02))
end</code></pre><p>When writing <code data-lang="pyret" class="sourceCode">where</code> examples, we also want to include special
yet valid cases that the function might have to handle, such as an empty
message.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pen-cost(5, "") is 5 * 0.25</code></pre><p>Note that our empty-message example has a simpler expression on the
right side of <code data-lang="pyret" class="sourceCode">is</code>. The expression for what the function returns
doesn‚Äôt have to match the body expression; it simply has to evaluate
to the same value as you expect the example to produce. Sometimes,
we‚Äôll find it easier to just write the expected value directly. For
the case of someone ordering no pens, for example, we‚Äôd include:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pen-cost(0, "bears") is 0</code></pre><p>The point of the examples is to document how a function behaves on a
variety of inputs. What goes to the right of the <code data-lang="pyret" class="sourceCode">is</code> should
summarize the computation or the answer in some meaningful way. Most
important? Do not write the function, run it to determine the answer,
then put that answer on the right side of the <code data-lang="pyret" class="sourceCode">is</code>! Why not?
Because the examples are meant to give some redundancy to the design
process, so that you catch errors you might have made. If your
function body is incorrect, and you use the function to generate the
example, you won‚Äôt get the benefit of using the example to check for
errors.</p><p>We‚Äôll keep returning to this idea of writing good examples. Don‚Äôt
worry if you still have questions for now. Also, for the time being,
we won‚Äôt worry about nonsensical situations like negative numbers of
pens. We‚Äôll get to those after we‚Äôve learned additional coding
techniques that will help us handle such situations properly.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>We could have combined our two special cases into one example, such as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pen-cost(0, "") is 0</code></pre><p>Does doing this seem like a good idea? Why or why not?</p></blockquote></blockquote>&#13;
<h4 class="heading">3.3.6¬†<a name="(part._.Recap__.Defining_.Functions)"/>Recap: Defining Functions<a href="#(part._.Recap__.Defining_.Functions)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>This chapter has introduced the idea of a function. Functions play a
key role in programming: they let us configure computations with
different concrete values at different times. The first time we
compute the cost of pens, we might be asking about <code data-lang="pyret" class="sourceCode">10</code> pens that say
<code data-lang="pyret" class="sourceCode">"Welcome"</code>. The next time, we might be asking about <code data-lang="pyret" class="sourceCode">100</code> pens that say
<code data-lang="pyret" class="sourceCode">"Go Bears!"</code>. The core computation is the same in both cases, so we
want to write it out once, configuring it with different concrete
values each time we use it.</p><p>We‚Äôve covered several specific ideas about functions:</p><ul><li><p>We showed the <code data-lang="pyret" class="sourceCode">fun</code> notation for writing functions. You learned
that a function has a name (that we can use to refer to it),
one or more parameters (names for the values we want to configure), as
well as a body, which is the computation that we want to
perform once we have concrete values for the parameters.</p></li><li><p>We showed that we should include examples with our functions,
to illustrate what the function computes on various specific
values. Examples go in a <code data-lang="pyret" class="sourceCode">where</code> block within the function.</p></li><li><p>We showed that we can use a function by providing concrete
values to configure its parameters. To do this, we write the name of
the function we want to use, followed by a pair of parenthesis around
comma-separated values for the parameters. For example, writing the following
expression (at the interactions prompt) will compute the cost of a
specific order of pens:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pen-cost(10, "Welcome")</code></pre></li><li><p>We discussed that if we define a function in the definitions
pane then press Run, Pyret will make an entry in the directory with
the name of the function. If we later use the function, Pyret will
look up the code that goes with that name, substitute the concrete
values we provided for the parameters, and return the result of
evaluating the resulting expression. Pyret will NOT produce anything
in the interactions pane for a function definition (other than a
report about whether the examples hold).</p></li></ul><p>There‚Äôs much more to learn about functions, including different
reasons for creating them. We‚Äôll get to those in due course.</p>    
</body>
</html>