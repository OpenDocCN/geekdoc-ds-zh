- en: 17.5Â Moravian Spanning TreesğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.5Â æ‘©æ‹‰ç»´äºšç”Ÿæˆæ ‘ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/mst.html](https://dcic-world.org/2025-08-27/mst.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/mst.html](https://dcic-world.org/2025-08-27/mst.html)
- en: '| Â Â Â Â [17.5.1Â The Problem](#%28part._.The_.Problem%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [17.5.1Â é—®é¢˜](#%28part._.The_.Problem%29) |'
- en: '| Â Â Â Â [17.5.2Â A Greedy Solution](#%28part._.A_.Greedy_.Solution%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [17.5.2Â è´ªå©ªç®—æ³•è§£å†³æ–¹æ¡ˆ](#%28part._.A_.Greedy_.Solution%29) |'
- en: '| Â Â Â Â [17.5.3Â Another Greedy Solution](#%28part._.Another_.Greedy_.Solution%29)
    |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [17.5.3Â å¦ä¸€ç§è´ªå©ªç®—æ³•è§£å†³æ–¹æ¡ˆ](#%28part._.Another_.Greedy_.Solution%29) |'
- en: '| Â Â Â Â [17.5.4Â A Third Solution](#%28part._.A_.Third_.Solution%29) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [17.5.4Â ç¬¬ä¸‰ç§è§£å†³æ–¹æ¡ˆ](#%28part._.A_.Third_.Solution%29) |'
- en: '| Â Â Â Â [17.5.5Â Checking Component Connectedness](#%28part._union-find-functional%29)
    |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [17.5.5Â æ£€æŸ¥ç»„ä»¶è¿é€šæ€§](#%28part._union-find-functional%29) |'
- en: 'At the turn of the milennium, the US National Academy of Engineering surveyed
    its members to determine the â€œGreatest Engineering Achievements of the 20th Centuryâ€.
    The list contained the usual suspects: electronics, computers, the Internet, and
    so on. But a perhaps surprising idea topped the list: (rural) electrification.Read
    more about it [on their site](http://www.greatachievements.org/).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨åƒå¹´ä¹‹äº¤ï¼Œç¾å›½å›½å®¶å·¥ç¨‹é™¢å¯¹å…¶æˆå‘˜è¿›è¡Œäº†è°ƒæŸ¥ï¼Œä»¥ç¡®å®šâ€œ20ä¸–çºªæœ€ä¼Ÿå¤§çš„å·¥ç¨‹æˆå°±â€ã€‚åå•ä¸ŠåŒ…å«äº†å¸¸è§çš„å€™é€‰è€…ï¼šç”µå­ã€è®¡ç®—æœºã€äº’è”ç½‘ç­‰ç­‰ã€‚ä½†ä¸€ä¸ªå¯èƒ½ä»¤äººæƒŠè®¶çš„æƒ³æ³•ä½å±…æ¦œé¦–ï¼šï¼ˆå†œæ‘ï¼‰ç”µæ°”åŒ–ã€‚æ›´å¤šå…³äºå®ƒçš„ä¿¡æ¯[å¯ä»¥åœ¨ä»–ä»¬çš„ç½‘ç«™ä¸Šæ‰¾åˆ°](http://www.greatachievements.org/).
- en: 17.5.1Â The Problem[ğŸ”—](#(part._.The_.Problem) "Link to here")
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.5.1Â é—®é¢˜[ğŸ”—](#(part._.The_.Problem) "é“¾æ¥è‡³æ­¤")
- en: To understand the history of national electrical grids, it helps to go back
    to [Moravia](http://en.wikipedia.org/wiki/Moravia) in the 1920s. Like many parts
    of the world, it was beginning to realize the benefits of electricity and intended
    to spread it around the region. A Moravian academia named Otakar BorÅ¯vka heard
    about the problem, and in a remarkable effort, described the problem abstractly,
    so that it could be understood without reference to Moravia or electrical networks.
    He modeled it as a problem about graphs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: è¦äº†è§£å›½å®¶ç”µç½‘çš„å†å²ï¼Œå›åˆ°20ä¸–çºª20å¹´ä»£çš„[æ‘©æ‹‰ç»´äºš](http://en.wikipedia.org/wiki/Moravia)æ˜¯æœ‰å¸®åŠ©çš„ã€‚åƒä¸–ç•Œä¸Šè®¸å¤šå…¶ä»–åœ°åŒºä¸€æ ·ï¼Œå®ƒå¼€å§‹æ„è¯†åˆ°ç”µåŠ›çš„å¥½å¤„ï¼Œå¹¶æ‰“ç®—åœ¨è¯¥åœ°åŒºæ¨å¹¿ç”µåŠ›ã€‚ä¸€ä½åå«å¥¥å¡”å¡å°”Â·åšé²ç“¦å¡çš„æ‘©æ‹‰ç»´äºšå­¦è€…å¬è¯´äº†è¿™ä¸ªé—®é¢˜ï¼Œåœ¨éå‡¡çš„åŠªåŠ›ä¸‹ï¼Œä»–æŠ½è±¡åœ°æè¿°äº†è¿™ä¸ªé—®é¢˜ï¼Œè¿™æ ·å°±å¯ä»¥åœ¨æ²¡æœ‰å‚è€ƒæ‘©æ‹‰ç»´äºšæˆ–ç”µç½‘çš„æƒ…å†µä¸‹ç†è§£å®ƒã€‚ä»–å°†å®ƒå»ºæ¨¡ä¸ºä¸€ä¸ªå…³äºå›¾çš„é—®é¢˜ã€‚
- en: 'BorÅ¯vka observed that at least initially, any solution to the problem of creating
    a network must have the following characteristics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: åšé²ç“¦å¡è§‚å¯Ÿåˆ°ï¼Œè‡³å°‘æœ€åˆï¼Œä»»ä½•è§£å†³åˆ›å»ºç½‘ç»œé—®é¢˜çš„æ–¹æ¡ˆå¿…é¡»å…·æœ‰ä»¥ä¸‹ç‰¹å¾ï¼š
- en: The electrical network must reach all the towns intended to be covered by it.
    In graph terms, the solution must be spanning, meaning it must visit every node
    in the graph.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç”µç½‘å¿…é¡»è¦†ç›–æ‰€æœ‰æ‰“ç®—è¦†ç›–çš„åŸé•‡ã€‚åœ¨å›¾è®ºæœ¯è¯­ä¸­ï¼Œè§£å†³æ–¹æ¡ˆå¿…é¡»æ˜¯ç”Ÿæˆæ ‘ï¼Œè¿™æ„å‘³ç€å®ƒå¿…é¡»è®¿é—®å›¾ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹ã€‚
- en: 'Redundancy is a valuable property in any network: that way, if one set of links
    goes down, there might be another way to get a payload to its destination. When
    starting out, however, redundancy may be too expensive, especially if it comes
    at the cost of not giving someone a payload at all. Thus, the initial solution
    was best set up without loops or even redundant paths. In graph terms, the solution
    had to be a tree.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å†—ä½™æ˜¯ä»»ä½•ç½‘ç»œä¸­çš„ä¸€ä¸ªå®è´µå±æ€§ï¼šè¿™æ ·ï¼Œå¦‚æœä¸€ç»„é“¾æ¥ä¸­æ–­ï¼Œå¯èƒ½ä¼šæœ‰å¦ä¸€ç§æ–¹å¼å°†æœ‰æ•ˆè½½è·å‘é€åˆ°ç›®çš„åœ°ã€‚ç„¶è€Œï¼Œåœ¨å¼€å§‹æ—¶ï¼Œå†—ä½™å¯èƒ½è¿‡äºæ˜‚è´µï¼Œå°¤å…¶æ˜¯å¦‚æœå®ƒæ˜¯ä»¥ä¸å‘æŸäººå‘é€æœ‰æ•ˆè½½è·ä¸ºä»£ä»·çš„è¯ã€‚å› æ­¤ï¼Œæœ€åˆçš„è§£å†³æ–¹æ¡ˆæœ€å¥½è®¾ç½®æˆæ²¡æœ‰ç¯è·¯ç”šè‡³å†—ä½™è·¯å¾„ã€‚åœ¨å›¾è®ºæœ¯è¯­ä¸­ï¼Œè§£å†³æ–¹æ¡ˆå¿…é¡»æ˜¯ä¸€æ£µæ ‘ã€‚
- en: Finally, the goal was to solve this problem for the least cost possible. In
    graph terms, the graph would be weighted, and the solution had to be a minimum.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœ€åï¼Œç›®æ ‡æ˜¯å°½å¯èƒ½ä»¥æœ€ä½çš„æˆæœ¬è§£å†³è¿™ä¸ªé—®é¢˜ã€‚åœ¨å›¾è®ºæœ¯è¯­ä¸­ï¼Œå›¾å°†æ˜¯åŠ æƒçš„ï¼Œè§£å†³æ–¹æ¡ˆå¿…é¡»æ˜¯æœ€å°å€¼ã€‚
- en: Thus BorÅ¯vka defined the Moravian Spanning Tree (MST) problem.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œåšé²ç“¦å¡å®šä¹‰äº†æ‘©æ‹‰ç»´äºšç”Ÿæˆæ ‘ï¼ˆMSTï¼‰é—®é¢˜ã€‚
- en: 17.5.2Â A Greedy Solution[ğŸ”—](#(part._.A_.Greedy_.Solution) "Link to here")
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.5.2Â è´ªå©ªç®—æ³•è§£å†³æ–¹æ¡ˆ[ğŸ”—](#(part._.A_.Greedy_.Solution) "é“¾æ¥è‡³æ­¤")
- en: 'BorÅ¯vka had published his problem, and another Czech mathematician, [VojtÄ›ch
    JarnÃ­k](http://en.wikipedia.org/wiki/Vojt%C4%9Bch_Jarn%C3%ADk), came across it.
    JarnÃ­k came up with a solution that should sound familiar:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: åšé²ç“¦å¡å‘è¡¨äº†è¿™ä¸ªé—®é¢˜ï¼Œå¦ä¸€ä½æ·å…‹æ•°å­¦å®¶[æ²ƒä¼Šæ·èµ«Â·äºšå°¼å…‹](http://en.wikipedia.org/wiki/Vojt%C4%9Bch_Jarn%C3%ADk)å¶ç„¶å‘ç°äº†å®ƒã€‚äºšå°¼å…‹æå‡ºäº†ä¸€ç§å¬èµ·æ¥ç†Ÿæ‚‰çš„è§£å†³æ–¹æ¡ˆï¼š
- en: Begin with a solution consisting of a single node, chosen arbitrarily. For the
    graph consisting of this one node, this solution is clearly a minimum, spanning,
    and a tree.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä»ä¸€ä¸ªç”±å•ä¸ªèŠ‚ç‚¹ç»„æˆçš„è§£å†³æ–¹æ¡ˆå¼€å§‹ï¼Œè¿™ä¸ªèŠ‚ç‚¹æ˜¯ä»»æ„é€‰æ‹©çš„ã€‚å¯¹äºç”±è¿™ä¸ªèŠ‚ç‚¹ç»„æˆçš„å›¾ï¼Œè¿™ä¸ªè§£å†³æ–¹æ¡ˆæ˜¾ç„¶æ˜¯æœ€å°ã€ç”Ÿæˆå’Œä¸€æ£µæ ‘ã€‚
- en: Of all the edges incident on nodes in the solution that connect to a node not
    already in the solution, pick the edge with the least weight.Note that we consider
    only the incident edges, not their weight added to the weight of the node to which
    they are incident.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨æ‰€æœ‰ä¸è§£å†³æ–¹æ¡ˆä¸­çš„èŠ‚ç‚¹ç›¸è¿ä¸”å°šæœªåŒ…å«åœ¨è§£å†³æ–¹æ¡ˆä¸­çš„èŠ‚ç‚¹ç›¸è¿çš„è¾¹ä¸­ï¼Œé€‰æ‹©æƒé‡æœ€å°çš„è¾¹ã€‚è¯·æ³¨æ„ï¼Œæˆ‘ä»¬åªè€ƒè™‘è¿™äº›è¾¹ï¼Œè€Œä¸æ˜¯å®ƒä»¬é™„åŠ åˆ°å®ƒä»¬æ‰€è¿æ¥çš„èŠ‚ç‚¹çš„æƒé‡ã€‚
- en: Add this edge to the solution. The claim is that for the new solution will be
    a tree (by construction), spanning (also by construction), and a minimum. The
    minimality follows by an argument similar to that used for Dijkstraâ€™s Algorithm.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å°†æ­¤è¾¹æ·»åŠ åˆ°è§£å†³æ–¹æ¡ˆä¸­ã€‚æ–­è¨€æ˜¯ï¼Œæ–°çš„è§£å†³æ–¹æ¡ˆå°†æ˜¯ä¸€ä¸ªæ ‘ï¼ˆé€šè¿‡æ„é€ ï¼‰ï¼Œä¸€ä¸ªç”Ÿæˆæ ‘ï¼ˆä¹Ÿæ˜¯é€šè¿‡æ„é€ ï¼‰ï¼Œå¹¶ä¸”æ˜¯æœ€å°ç”Ÿæˆæ ‘ã€‚æœ€å°æ€§å¯ä»¥é€šè¿‡ä¸ Dijkstra ç®—æ³•ç±»ä¼¼çš„æ–¹æ³•æ¥è¯æ˜ã€‚
- en: JarnÃ­k had the misfortune of publishing this work in Czech in 1930, and it went
    largely ignored. It was rediscovered by others, most notably by R.C. Prim in 1957,
    and is now generally known as Primâ€™s Algorithm, though calling it JarnÃ­kâ€™s Algorithm
    would attribute credit in the right place.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: JarnÃ­k ä¸å¹¸çš„æ˜¯åœ¨ 1930 å¹´ç”¨æ·å…‹è¯­å‘è¡¨äº†è¿™é¡¹å·¥ä½œï¼Œå¹¶ä¸”å®ƒåŸºæœ¬ä¸Šè¢«å¿½è§†äº†ã€‚å®ƒè¢«å…¶ä»–äººé‡æ–°å‘ç°ï¼Œæœ€è‘—åçš„æ˜¯ R.C. Prim åœ¨ 1957 å¹´ï¼Œç°åœ¨é€šå¸¸è¢«ç§°ä¸º
    Prim ç®—æ³•ï¼Œå°½ç®¡ç§°ä¹‹ä¸º JarnÃ­k ç®—æ³•ä¼šæ­£ç¡®åœ°å½’åŠŸäºä»–ã€‚
- en: Implementing this algorithm is pretty easy. At each point, we need to know the
    lightest edge incident on the current solution tree. Finding the lightest edge
    takes time linear in the number of these edges, but the very lightest one may
    create a cycle. We therefore need to efficiently check for whether adding an edge
    would create a cycle, a problem we will return to multiple times [[Checking Component
    Connectedness](#%28part._union-find-functional%29)]. Assuming we can do that effectively,
    we then want to add the lightest edge and iterate. Even given an efficient solution
    for checking cyclicity, this would seem to require an operation linear in the
    number of edges for each node. With better representations we can improve on this
    complexity, but letâ€™s look at other ideas first.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: å®ç°è¿™ä¸ªç®—æ³•ç›¸å½“ç®€å•ã€‚åœ¨æ¯ä¸€ä¸ªç‚¹ä¸Šï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“å½“å‰è§£å†³æ–¹æ¡ˆæ ‘ä¸Šçš„æœ€è½»è¾¹ã€‚æ‰¾åˆ°æœ€è½»è¾¹éœ€è¦çš„æ—¶é—´ä¸è¿™äº›è¾¹çš„æ•°é‡æˆçº¿æ€§å…³ç³»ï¼Œä½†æœ€è½»çš„è¾¹å¯èƒ½ä¼šåˆ›å»ºä¸€ä¸ªç¯ã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦æœ‰æ•ˆåœ°æ£€æŸ¥æ·»åŠ è¾¹æ˜¯å¦ä¼šåˆ›å»ºä¸€ä¸ªç¯ï¼Œè¿™æ˜¯ä¸€ä¸ªæˆ‘ä»¬å°†å¤šæ¬¡è¿”å›çš„é—®é¢˜
    [[æ£€æŸ¥ç»„ä»¶è¿é€šæ€§](#%28part._union-find-functional%29)]ã€‚å‡è®¾æˆ‘ä»¬èƒ½å¤Ÿæœ‰æ•ˆåœ°åšåˆ°è¿™ä¸€ç‚¹ï¼Œç„¶åæˆ‘ä»¬æƒ³è¦æ·»åŠ æœ€è½»çš„è¾¹å¹¶è¿­ä»£ã€‚å³ä½¿ç»™å‡ºäº†æ£€æŸ¥ç¯çš„æœ‰æ•ˆè§£å†³æ–¹æ¡ˆï¼Œè¿™ä¼¼ä¹ä¹Ÿéœ€è¦å¯¹æ¯ä¸ªèŠ‚ç‚¹è¿›è¡Œçº¿æ€§æ“ä½œã€‚é€šè¿‡æ›´å¥½çš„è¡¨ç¤ºï¼Œæˆ‘ä»¬å¯ä»¥æ”¹è¿›è¿™ä¸ªå¤æ‚æ€§ï¼Œä½†è®©æˆ‘ä»¬å…ˆçœ‹çœ‹å…¶ä»–æƒ³æ³•ã€‚
- en: 17.5.3Â Another Greedy Solution[ğŸ”—](#(part._.Another_.Greedy_.Solution) "Link
    to here")
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.5.3 å¦ä¸€ç§è´ªå©ªè§£æ³•[ğŸ”—](#(part._.Another_.Greedy_.Solution) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Recall that JarnÃ­k presented his algorithm in 1930, when computers didnâ€™t exist,
    and Prim his in 1957, when they were very much in their infancy. Programming computers
    to track heaps was a non-trivial problem, and many algorithms were implemented
    by hand, where keeping track of a complex data structure without making errors
    was harder still. There was need for a solution that was required less manual
    bookkeeping (literally speaking).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: å›æƒ³ä¸€ä¸‹ï¼ŒJarnÃ­k åœ¨ 1930 å¹´æå‡ºäº†ä»–çš„ç®—æ³•ï¼Œå½“æ—¶è¿˜æ²¡æœ‰è®¡ç®—æœºï¼Œè€Œ Prim åœ¨ 1957 å¹´æå‡ºäº†ä»–çš„ç®—æ³•ï¼Œå½“æ—¶è®¡ç®—æœºè¿˜å¤„äºå©´å„¿æœŸã€‚ç¼–ç¨‹è®¡ç®—æœºè·Ÿè¸ªå †æ ˆæ˜¯ä¸€ä¸ªéå¹³å‡¡çš„é—®é¢˜ï¼Œè®¸å¤šç®—æ³•éƒ½æ˜¯æ‰‹å·¥å®ç°çš„ï¼Œè€Œè·Ÿè¸ªå¤æ‚çš„æ•°æ®ç»“æ„è€Œä¸å‡ºé”™åˆ™æ›´åŠ å›°éš¾ã€‚éœ€è¦ä¸€ç§è§£å†³æ–¹æ¡ˆï¼Œå®ƒéœ€è¦çš„æ‰‹åŠ¨è®°å½•æ›´å°‘ï¼ˆå­—é¢ä¸Šè®²ï¼‰ã€‚
- en: In 1956, [Joseph Kruskal](http://en.wikipedia.org/wiki/Joseph_Kruskal) presented
    such a solution. His idea was elegantly simple. The JarnÃ­k algorithm suffers from
    the problem that each time the tree grows, we have to revise the content of the
    heap, which is already a messy structure to track. Kruskal noted the following.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ 1956 å¹´ï¼Œ[çº¦ç‘Ÿå¤«Â·å…‹é²æ–¯å¡å°”](http://en.wikipedia.org/wiki/Joseph_Kruskal) æå‡ºäº†è¿™æ ·çš„è§£å†³æ–¹æ¡ˆã€‚ä»–çš„æƒ³æ³•ç®€å•è€Œä¼˜é›…ã€‚JarnÃ­k
    ç®—æ³•çš„é—®é¢˜åœ¨äºæ¯æ¬¡æ ‘å¢é•¿æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»ä¿®æ”¹å †çš„å†…å®¹ï¼Œè€Œè¿™å·²ç»æ˜¯ä¸€ä¸ªéš¾ä»¥è·Ÿè¸ªçš„æ··ä¹±ç»“æ„ã€‚Kruskal æ³¨æ„åˆ°ä»¥ä¸‹å‡ ç‚¹ã€‚
- en: 'To obtain a minimum solution, surely we want to include one of the edges of
    least weight in the graph. Because if not, we can take an otherwise minimal solution,
    add this edge, and remove one other edge; the graph would still be just as connected,
    but the overall weight would be no more and, if the removed edge were heavier,
    would be less.Note the careful wording: there may be many edges of the same least
    weight, so adding one of them may remove another, and therefore not produce a
    lighter tree; but the key point is that it certainly will not produce a heavier
    one. By the same argument we can add the next lightest edge, and the next lightest,
    and so on. The only time we cannot add the next lightest edge is when it would
    create a cycle (that problem again!).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†è·å¾—æœ€å°è§£ï¼Œæˆ‘ä»¬å½“ç„¶å¸Œæœ›å°†å›¾ä¸­æƒé‡æœ€å°çš„è¾¹ä¹‹ä¸€åŒ…å«åœ¨å†…ã€‚å› ä¸ºå¦‚æœä¸è¿™æ ·åšï¼Œæˆ‘ä»¬å¯ä»¥å–ä¸€ä¸ªå…¶ä»–çš„æœ€å°è§£ï¼Œæ·»åŠ è¿™æ¡è¾¹ï¼Œå¹¶ç§»é™¤å¦ä¸€æ¡è¾¹ï¼›å›¾ä»ç„¶ä¿æŒè¿é€šï¼Œä½†æ€»æƒé‡ä¸ä¼šæ›´å¤šï¼Œå¦‚æœç§»é™¤çš„è¾¹æ›´é‡ï¼Œåˆ™ä¼šæ›´å°‘ã€‚æ³¨æ„æªè¾çš„å‡†ç¡®æ€§ï¼šå¯èƒ½å­˜åœ¨è®¸å¤šæƒé‡ç›¸åŒçš„è¾¹ï¼Œæ·»åŠ å…¶ä¸­ä¹‹ä¸€å¯èƒ½ä¼šç§»é™¤å¦ä¸€æ¡ï¼Œå› æ­¤ä¸ä¼šäº§ç”Ÿæ›´è½»çš„æ ‘ï¼›ä½†å…³é”®ç‚¹æ˜¯ï¼Œå®ƒè‚¯å®šä¸ä¼šäº§ç”Ÿæ›´é‡çš„æ ‘ã€‚é€šè¿‡åŒæ ·çš„è®ºæ®ï¼Œæˆ‘ä»¬å¯ä»¥æ·»åŠ ä¸‹ä¸€ä¸ªæœ€è½»çš„è¾¹ï¼Œå†ä¸‹ä¸€ä¸ªæœ€è½»çš„è¾¹ï¼Œä¾æ­¤ç±»æ¨ã€‚å”¯ä¸€ä¸èƒ½æ·»åŠ ä¸‹ä¸€ä¸ªæœ€è½»è¾¹çš„æƒ…å½¢æ˜¯ï¼Œå®ƒä¼šå½¢æˆä¸€ä¸ªç¯ï¼ˆåˆæ˜¯è¿™ä¸ªé—®é¢˜ï¼ï¼‰ã€‚
- en: Therefore, Kruskalâ€™s algorithm is utterly straightforward. We first sort all
    the edges, ordered by ascending weight. We then take each edge in ascending weight
    order and add it to the solution provided it will not create a cycle. When we
    have thus processed all the edges, we will have a solution that is a tree (by
    construction), spanning (because every connected vertex must be the endpoint of
    some edge), and of minimum weight (by the argument above). The complexity is that
    of sorting (which is \([e \rightarrow e \log e]\) where \(e\) is the size of the
    edge set. We then iterate over each element in \(e\), which takes time linear
    in the size of that setâ€”<wbr>modulo the time to check for cycles. This algorithm
    is also easy to implement on paper, because we sort all the edges once, then keep
    checking them off in order, crossing out the ones that create cyclesâ€”<wbr>with
    no dynamic updating of the list needed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œå…‹é²æ–¯å¡å°”ç®—æ³•ï¼ˆKruskal's algorithmï¼‰æå…¶ç®€å•æ˜äº†ã€‚æˆ‘ä»¬é¦–å…ˆæŒ‰å‡åºå¯¹æ‰€æœ‰è¾¹è¿›è¡Œæ’åºã€‚ç„¶åï¼Œæˆ‘ä»¬æŒ‰å‡åºé¡ºåºå–æ¯æ¡è¾¹ï¼Œå¦‚æœå®ƒä¸ä¼šå½¢æˆç¯ï¼Œå°±å°†å…¶æ·»åŠ åˆ°è§£ä¸­ã€‚å½“æˆ‘ä»¬è¿™æ ·å¤„ç†å®Œæ‰€æœ‰è¾¹åï¼Œæˆ‘ä»¬å°†å¾—åˆ°ä¸€ä¸ªæ ‘å½¢è§£ï¼ˆé€šè¿‡æ„é€ ï¼‰ï¼Œå®ƒè¦†ç›–äº†æ‰€æœ‰è¿æ¥çš„é¡¶ç‚¹ï¼ˆå› ä¸ºæ¯ä¸ªè¿æ¥çš„é¡¶ç‚¹å¿…é¡»æ˜¯æŸæ¡è¾¹çš„ç«¯ç‚¹ï¼‰ï¼Œå¹¶ä¸”å…·æœ‰æœ€å°æƒé‡ï¼ˆæ ¹æ®ä¸Šè¿°è®ºæ®ï¼‰ã€‚å…¶å¤æ‚åº¦ä¸æ’åºç›¸åŒï¼ˆå³
    \([e \rightarrow e \log e]\)ï¼Œå…¶ä¸­ \(e\) æ˜¯è¾¹é›†çš„å¤§å°ï¼‰ã€‚ç„¶åæˆ‘ä»¬éå† \(e\) ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œè¿™éœ€è¦ä¸è¯¥é›†åˆå¤§å°æˆçº¿æ€§å…³ç³»çš„æ—¶é—´â€”â€”<wbr>å‡å»æ£€æŸ¥ç¯æ‰€éœ€çš„æ—¶é—´ã€‚è¿™ä¸ªç®—æ³•ä¹Ÿå®¹æ˜“åœ¨çº¸ä¸Šå®ç°ï¼Œå› ä¸ºæˆ‘ä»¬åªå¯¹æ‰€æœ‰çš„è¾¹è¿›è¡Œä¸€æ¬¡æ’åºï¼Œç„¶åæŒ‰é¡ºåºæ£€æŸ¥å®ƒä»¬ï¼Œåˆ’æ‰é‚£äº›å½¢æˆç¯çš„è¾¹â€”â€”<wbr>æ— éœ€åŠ¨æ€æ›´æ–°åˆ—è¡¨ã€‚
- en: 17.5.4Â A Third Solution[ğŸ”—](#(part._.A_.Third_.Solution) "Link to here")
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.5.4Â ç¬¬ä¸‰ä¸ªè§£å†³æ–¹æ¡ˆ[ğŸ”—](#(part._.A_.Third_.Solution) "é“¾æ¥è‡³æ­¤")
- en: 'Both the JarnÃ­k and Kruskal solutions have one flaw: they require a centralized
    data structure (the priority heap, or the sorted list) to incrementally build
    the solution. As parallel computers became available, and graph problems grew
    large, computer scientists looked for solutions that could be implemented more
    efficiently in parallelâ€”<wbr>which typically meant avoiding any centralized points
    of synchronization, such as these centralized data structures.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: JarnÃ­k å’Œ Kruskal çš„è§£éƒ½æœ‰ä¸€ä¸ªé—®é¢˜ï¼šå®ƒä»¬éœ€è¦ä¸€ä¸ªé›†ä¸­çš„æ•°æ®ç»“æ„ï¼ˆä¼˜å…ˆå †æˆ–æ’åºåˆ—è¡¨ï¼‰æ¥é€æ­¥æ„å»ºè§£ã€‚éšç€å¹¶è¡Œè®¡ç®—æœºçš„å‡ºç°å’Œå›¾é—®é¢˜è§„æ¨¡çš„æ‰©å¤§ï¼Œè®¡ç®—æœºç§‘å­¦å®¶å¯»æ‰¾åœ¨å¹¶è¡Œä¸­æ›´æœ‰æ•ˆå®ç°çš„è§£å†³æ–¹æ¡ˆâ€”â€”<wbr>è¿™é€šå¸¸æ„å‘³ç€é¿å…ä»»ä½•é›†ä¸­çš„åŒæ­¥ç‚¹ï¼Œä¾‹å¦‚è¿™äº›é›†ä¸­çš„æ•°æ®ç»“æ„ã€‚
- en: In 1965, M. Sollin constructed an algorithm that met these needs beautifully.
    In this algorithm, instead of constructing a single solution, we grow multiple
    solution components (potentially in parallel if we so wish). Each node starts
    out as a solution component (as it was at the first step of JarnÃ­kâ€™s Algorithm).
    Each node considers the edges incident to it, and picks the lightest one that
    connects to a different component (that problem again!). If such an edge can be
    found, the edge becomes part of the solution, and the two components combine to
    become a single component. The entire process repeats.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨1965å¹´ï¼ŒM. Sollin æ„å»ºäº†ä¸€ä¸ªå®Œç¾æ»¡è¶³è¿™äº›éœ€æ±‚çš„ç®—æ³•ã€‚åœ¨è¿™ä¸ªç®—æ³•ä¸­ï¼Œæˆ‘ä»¬ä¸æ˜¯æ„å»ºå•ä¸ªè§£ï¼Œè€Œæ˜¯æ„å»ºå¤šä¸ªè§£ç»„ä»¶ï¼ˆå¦‚æœæ„¿æ„ï¼Œå¯ä»¥å¹¶è¡Œæ„å»ºï¼‰ã€‚æ¯ä¸ªèŠ‚ç‚¹æœ€åˆéƒ½æ˜¯ä¸€ä¸ªè§£ç»„ä»¶ï¼ˆå°±åƒåœ¨
    JarnÃ­k ç®—æ³•çš„ç¬¬ä¸€æ­¥ä¸­é‚£æ ·ï¼‰ã€‚æ¯ä¸ªèŠ‚ç‚¹è€ƒè™‘ä¸å…¶ç›¸è¿çš„è¾¹ï¼Œå¹¶é€‰æ‹©è¿æ¥åˆ°ä¸åŒç»„ä»¶çš„æœ€è½»è¾¹ï¼ˆåˆæ˜¯è¿™ä¸ªé—®é¢˜ï¼ï¼‰ã€‚å¦‚æœå¯ä»¥æ‰¾åˆ°è¿™æ ·çš„è¾¹ï¼Œè¯¥è¾¹å°±æˆä¸ºè§£çš„ä¸€éƒ¨åˆ†ï¼Œä¸¤ä¸ªç»„ä»¶åˆå¹¶æˆä¸ºä¸€ä¸ªç»„ä»¶ã€‚æ•´ä¸ªè¿‡ç¨‹é‡å¤è¿›è¡Œã€‚
- en: Because every node begins as part of the solution, this algorithm naturally
    spans. Because it checks for cycles and avoids them, it naturally forms a tree.Note
    that avoiding cycles yields a DAG and is not automatically guaranteed to yield
    a tree. We have been a bit lax about this difference throughout this section.
    Finally, minimality follows through similar reasoning as we used in the case of
    JarnÃ­kâ€™s Algorithm, which we have essentially run in parallel, once from each
    node, until the parallel solution components join up to produce a global solution.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸ºæ¯ä¸ªèŠ‚ç‚¹æœ€åˆéƒ½æ˜¯è§£å†³æ–¹æ¡ˆçš„ä¸€éƒ¨åˆ†ï¼Œè¿™ä¸ªç®—æ³•è‡ªç„¶åœ°æ‰©å±•ã€‚å› ä¸ºå®ƒæ£€æŸ¥å¾ªç¯å¹¶é¿å…å®ƒä»¬ï¼Œå®ƒè‡ªç„¶åœ°å½¢æˆä¸€ä¸ªæ ‘ã€‚è¯·æ³¨æ„ï¼Œé¿å…å¾ªç¯ä¼šäº§ç”Ÿä¸€ä¸ªæœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰ï¼Œå¹¶ä¸è‡ªåŠ¨ä¿è¯äº§ç”Ÿä¸€ä¸ªæ ‘ã€‚æˆ‘ä»¬åœ¨æœ¬èŠ‚ä¸­å¯¹æ­¤å·®å¼‚æœ‰ç‚¹å®½æ¾ã€‚æœ€åï¼Œæœ€å°æ€§é€šè¿‡ä¸æˆ‘ä»¬ç”¨äºJarnÃ­kç®—æ³•çš„ç±»ä¼¼æ¨ç†å¾—å‡ºï¼Œæˆ‘ä»¬å®é™…ä¸Šå·²ç»ä»æ¯ä¸ªèŠ‚ç‚¹å¹¶è¡Œè¿è¡Œï¼Œç›´åˆ°å¹¶è¡Œè§£å†³æ–¹æ¡ˆç»„ä»¶è¿æ¥èµ·æ¥äº§ç”Ÿå…¨å±€è§£å†³æ–¹æ¡ˆã€‚
- en: 'Of course, maintaining the data for this algorithm by hand is a nightmare.
    Therefore, it would be no surprise that this algorithm was coined in the digital
    age. The real surprise, therefore, is that it was not: it was originally created
    by [Otakar BorÅ¯vka](http://en.wikipedia.org/wiki/Otakar_Bor%C5%AFvka) himself.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œæ‰‹åŠ¨ç»´æŠ¤æ­¤ç®—æ³•çš„æ•°æ®æ˜¯ä¸€ä¸ªå™©æ¢¦ã€‚å› æ­¤ï¼Œè¿™ä¸ªç®—æ³•åœ¨æ•°å­—æ—¶ä»£è¢«æå‡ºå¹¶ä¸ä»¤äººæƒŠè®¶ã€‚å› æ­¤ï¼ŒçœŸæ­£çš„æƒŠå–œæ˜¯å®ƒå¹¶ä¸æ˜¯ï¼šå®ƒæœ€åˆæ˜¯ç”±[å¥¥å¡”å¡Â·åšé²å¤«å¡](http://en.wikipedia.org/wiki/Otakar_Bor%C5%AFvka)æœ¬äººåˆ›å»ºçš„ã€‚
- en: 'BorÅ¯vka, you see, had figured it all out. Heâ€™d not only understood the problem,
    he had:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ çœ‹ï¼Œåšé²å¤«å¡å·²ç»å…¨éƒ¨å¼„æ˜ç™½äº†ã€‚ä»–ä¸ä»…ç†è§£äº†é—®é¢˜ï¼Œè€Œä¸”è¿˜ï¼š
- en: pinpointed the real problem lying underneath the electrification problem so
    it could be viewed in a context-independent way,
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‡†ç¡®åœ°æŒ‡å‡ºäº†ç”µåŒ–é—®é¢˜èƒŒåçš„çœŸæ­£é—®é¢˜ï¼Œä½¿å…¶èƒ½å¤Ÿä»¥ç‹¬ç«‹äºä¸Šä¸‹æ–‡çš„æ–¹å¼çœ‹å¾…ï¼Œ
- en: created a descriptive language of graph theory to define it precisely, and
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ›å»ºäº†ä¸€ç§æè¿°æ€§çš„å›¾è®ºè¯­è¨€æ¥ç²¾ç¡®åœ°å®šä¹‰å®ƒï¼Œå¹¶ä¸”
- en: even solved the problem in addition to defining it.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸ä»…å®šä¹‰äº†é—®é¢˜ï¼Œè¿˜è§£å†³äº†å®ƒã€‚
- en: Heâ€™d just come up with a solution so complex to implement by hand that JarnÃ­k
    had in essence de-parallelized it so it could be done sequentially. And thus this
    algorithm lay unnoticed until it was reinvented ([several times, actually](http://en.wikipedia.org/wiki/Bor%C5%AFvka's_algorithm))
    by Sollin in time for parallel computing folks to notice a need for it. But now
    we can just call this BorÅ¯vkaâ€™s Algorithm, which is only fitting.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ä»–æå‡ºäº†ä¸€ç§è¿‡äºå¤æ‚çš„è§£å†³æ–¹æ¡ˆï¼Œä»¥è‡³äºJarnÃ­kå®é™…ä¸Šå°†å…¶å»å¹¶è¡ŒåŒ–ï¼Œä»¥ä¾¿å¯ä»¥é¡ºåºæ‰§è¡Œã€‚å› æ­¤ï¼Œè¿™ä¸ªç®—æ³•ä¸€ç›´æœªè¢«æ³¨æ„ï¼Œç›´åˆ°Solliné‡æ–°å‘æ˜ï¼ˆå®é™…ä¸Š[å¤šæ¬¡](http://en.wikipedia.org/wiki/Bor%C5%AFvka's_algorithm)ï¼‰å®ƒï¼Œä»¥ä¾¿åœ¨å¹¶è¡Œè®¡ç®—äººå‘˜æ³¨æ„åˆ°éœ€è¦å®ƒçš„æ—¶å€™ã€‚ä½†ç°åœ¨æˆ‘ä»¬å¯ä»¥ç®€å•åœ°ç§°ä¹‹ä¸ºåšé²å¤«å¡ç®—æ³•ï¼Œè¿™æ˜¯éå¸¸åˆé€‚çš„ã€‚
- en: As you might have guessed by now, this problem is indeed called the MST in other
    textbooks, but â€œMâ€ stands not for Moravia but for â€œMinimumâ€. But given BorÅ¯vkaâ€™s
    forgotten place in history, we prefer the more whimsical name.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚ä½ ç°åœ¨å¯èƒ½å·²ç»çŒœåˆ°çš„ï¼Œè¿™ä¸ªé—®é¢˜åœ¨å…¶ä»–æ•™ç§‘ä¹¦ä¸­ç¡®å®è¢«ç§°ä¸ºæœ€å°ç”Ÿæˆæ ‘ï¼ˆMSTï¼‰ï¼Œä½†â€œMâ€ä¸æ˜¯æŒ‡æ‘©æ‹‰ç»´äºšï¼Œè€Œæ˜¯æŒ‡â€œæœ€å°â€ã€‚ä½†é‰´äºåšé²å¤«å¡åœ¨å†å²ä¸­çš„è¢«é—å¿˜åœ°ä½ï¼Œæˆ‘ä»¬æ›´å–œæ¬¢æ›´å¹½é»˜çš„åå­—ã€‚
- en: 17.5.5Â Checking Component Connectedness[ğŸ”—](#(part._union-find-functional) "Link
    to here")
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.5.5 æ£€æŸ¥ç»„ä»¶è¿é€šæ€§[ğŸ”—](#(part._union-find-functional) "é“¾æ¥è‡³æ­¤")
- en: As weâ€™ve seen, we need to be able to efficiently tell whether two nodes are
    in the same component. One way to do this is to conduct a depth-first traversal
    (or breadth-first traversal) starting from the first node and checking whether
    we ever visit the second one. (Using one of these traversal strategies ensures
    that we terminate in the presence of loops.) Unfortunately, this takes a linear
    amount of time (in the size of the graph) for every pair of nodesâ€”<wbr>and depending
    on the graph and choice of node, we might do this for every node in the graph
    on every edge addition! So weâ€™d clearly like to do this better.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬æ‰€è§ï¼Œæˆ‘ä»¬éœ€è¦èƒ½å¤Ÿé«˜æ•ˆåœ°åˆ¤æ–­ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯å¦å±äºåŒä¸€ç»„ä»¶ã€‚ä¸€ç§æ–¹æ³•æ˜¯ä»æ­¤èŠ‚ç‚¹å¼€å§‹è¿›è¡Œæ·±åº¦ä¼˜å…ˆéå†ï¼ˆæˆ–å¹¿åº¦ä¼˜å…ˆéå†ï¼‰ï¼Œå¹¶æ£€æŸ¥æˆ‘ä»¬æ˜¯å¦æ›¾è®¿é—®è¿‡ç¬¬äºŒä¸ªèŠ‚ç‚¹ã€‚ï¼ˆä½¿ç”¨è¿™äº›éå†ç­–ç•¥ä¹‹ä¸€ç¡®ä¿äº†åœ¨å­˜åœ¨ç¯çš„æƒ…å†µä¸‹èƒ½å¤Ÿç»ˆæ­¢ã€‚ï¼‰ä¸å¹¸çš„æ˜¯ï¼Œè¿™å¯¹æ¯ä¸€å¯¹èŠ‚ç‚¹æ¥è¯´éƒ½éœ€è¦çº¿æ€§æ—¶é—´ï¼ˆä¸å›¾çš„å¤§å°æˆæ­£æ¯”ï¼‰â€”â€”å¹¶ä¸”æ ¹æ®å›¾å’ŒèŠ‚ç‚¹çš„é€‰æ‹©ï¼Œæˆ‘ä»¬å¯èƒ½åœ¨æ¯æ¬¡æ·»åŠ è¾¹æ—¶å¯¹å›¾ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹éƒ½è¿™æ ·åšï¼å› æ­¤ï¼Œæˆ‘ä»¬æ˜¾ç„¶å¸Œæœ›åšå¾—æ›´å¥½ã€‚
- en: 'It is helpful to reduce this problem from graph connectivity to a more general
    one: of disjoint-set structure (colloquially known as union-find for reasons that
    will soon be clear). If we think of each connected component as a set, then weâ€™re
    asking whether two nodes are in the same set. But casting it as a set membership
    problem makes it applicable in several other applications as well.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: å°†æ­¤é—®é¢˜ä»å›¾è¿é€šæ€§ç®€åŒ–ä¸ºæ›´ä¸€èˆ¬çš„é—®é¢˜ï¼šå¹¶é›†ç»“æ„ï¼ˆä¿—ç§°ä¸ºå¹¶æŸ¥é›†ï¼ŒåŸå› å¾ˆå¿«å°±ä¼šæ¸…æ¥šï¼‰ã€‚å¦‚æœæˆ‘ä»¬æŠŠæ¯ä¸ªè¿é€šç»„ä»¶çœ‹ä½œä¸€ä¸ªé›†åˆï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±æ˜¯åœ¨è¯¢é—®ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯å¦å±äºåŒä¸€ä¸ªé›†åˆã€‚ä½†å°†å…¶ä½œä¸ºé›†åˆæˆå‘˜é—®é¢˜æå‡ºï¼Œå®ƒä¹Ÿé€‚ç”¨äºå…¶ä»–å‡ ä¸ªåº”ç”¨ã€‚
- en: The setup is as follows. For arbitrary values, we want the ability to think
    of them as elements in a set. We are interested in two operations. One is obviously
    `union`, which merges two sets into one. The other would seem to be something
    like `is-in-same-set` that takes two elements and determines whether theyâ€™re in
    the same set. Over time, however, it has proven useful to instead define the operator
    `find` that, given an element, â€œnamesâ€ the set (more on this in a moment) that
    the element belongs to. To check whether two elements are in the same set, we
    then have to get the â€œset nameâ€ for each element, and check whether these names
    are the same. This certainly sounds more roundabout, but this means we have a
    primitive that may be useful in other contexts, and from which we can easily implement
    `is-in-same-set`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: è®¾ç½®å¦‚ä¸‹ã€‚å¯¹äºä»»æ„å€¼ï¼Œæˆ‘ä»¬å¸Œæœ›å®ƒä»¬è¢«è§†ä¸ºé›†åˆä¸­çš„å…ƒç´ ã€‚æˆ‘ä»¬æ„Ÿå…´è¶£çš„ä¸¤ä¸ªæ“ä½œæ˜¯ã€‚ä¸€ä¸ªæ˜¯æ˜¾ç„¶çš„ `union`ï¼Œå®ƒå°†ä¸¤ä¸ªé›†åˆåˆå¹¶ä¸ºä¸€ä¸ªã€‚å¦ä¸€ä¸ªä¼¼ä¹æ˜¯ `is-in-same-set`ï¼Œå®ƒæ¥å—ä¸¤ä¸ªå…ƒç´ å¹¶ç¡®å®šå®ƒä»¬æ˜¯å¦åœ¨åŒä¸€ä¸ªé›†åˆä¸­ã€‚ç„¶è€Œï¼Œéšç€æ—¶é—´çš„æ¨ç§»ï¼Œå®šä¹‰æ“ä½œç¬¦
    `find` å·²ç»è¢«è¯æ˜æ˜¯æœ‰ç”¨çš„ï¼Œç»™å®šä¸€ä¸ªå…ƒç´ ï¼Œâ€œå‘½åâ€è¯¥å…ƒç´ æ‰€å±çš„é›†åˆï¼ˆç¨åæˆ‘ä»¬ä¼šè¯¦ç»†è¯´æ˜ï¼‰ã€‚ä¸ºäº†æ£€æŸ¥ä¸¤ä¸ªå…ƒç´ æ˜¯å¦åœ¨åŒä¸€ä¸ªé›†åˆä¸­ï¼Œæˆ‘ä»¬ç„¶åå¿…é¡»è·å–æ¯ä¸ªå…ƒç´ çš„â€œé›†åˆåç§°â€ï¼Œå¹¶æ£€æŸ¥è¿™äº›åç§°æ˜¯å¦ç›¸åŒã€‚è¿™ç¡®å®å¬èµ·æ¥æœ‰äº›ç»•ï¼Œä½†è¿™æ„å‘³ç€æˆ‘ä»¬æœ‰ä¸€ä¸ªå¯èƒ½åœ¨å…¶ä»–ä¸Šä¸‹æ–‡ä¸­æœ‰ç”¨çš„åŸå§‹æ“ä½œï¼Œå¹¶ä¸”æˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“åœ°å®ç°
    `is-in-same-set`ã€‚
- en: 'Now the question is, how do we name sets? The real question we should ask is,
    what operations do we care to perform on these names? All we care about is, given
    two names, they represent the same set precisely when the names are the same.
    Therefore, we could construct a new string, or number, or something else, but
    we have another option: simply pick some element of the set to represent it, i.e.,
    to serve as its name. Thus we will associate each set element with an indicator
    of the â€œset nameâ€ for that element; if there isnâ€™t one, then its name is itself
    (the `none` case of `parent`):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨çš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬å¦‚ä½•å‘½åé›†åˆï¼Ÿæˆ‘ä»¬åº”è¯¥é—®çš„çœŸæ­£é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬å¯¹è¿™äº›åç§°å…³å¿ƒå“ªäº›æ“ä½œï¼Ÿæˆ‘ä»¬å”¯ä¸€å…³å¿ƒçš„æ˜¯ï¼Œç»™å®šä¸¤ä¸ªåç§°ï¼Œå®ƒä»¬ä»£è¡¨ç›¸åŒçš„é›†åˆå½“ä¸”ä»…å½“åç§°ç›¸åŒã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥æ„é€ ä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²ã€æ•°å­—æˆ–å…¶ä»–ä¸œè¥¿ï¼Œä½†æˆ‘ä»¬è¿˜æœ‰ä¸€ä¸ªé€‰æ‹©ï¼šç®€å•åœ°é€‰æ‹©é›†åˆä¸­çš„ä¸€ä¸ªå…ƒç´ æ¥ä»£è¡¨å®ƒï¼Œå³ä½œä¸ºå®ƒçš„åç§°ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°†æ¯ä¸ªé›†åˆå…ƒç´ ä¸è¡¨ç¤ºè¯¥å…ƒç´ çš„â€œé›†åˆåç§°â€çš„æŒ‡ç¤ºç¬¦ç›¸å…³è”ï¼›å¦‚æœæ²¡æœ‰ï¼Œé‚£ä¹ˆå®ƒçš„åç§°å°±æ˜¯å®ƒè‡ªå·±ï¼ˆ`parent`
    çš„ `none` æƒ…å†µï¼‰ï¼š
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will assume we have some equality predicate for checking when two elements
    are the same, which we do by comparing their value parts, ignoring their parent
    values:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†å‡è®¾æˆ‘ä»¬æœ‰ä¸€äº›ç­‰ä»·æ€§è°“è¯æ¥æ£€æŸ¥ä¸¤ä¸ªå…ƒç´ æ˜¯å¦ç›¸åŒï¼Œæˆ‘ä»¬é€šè¿‡æ¯”è¾ƒå®ƒä»¬çš„å€¼éƒ¨åˆ†æ¥å®ç°ï¼Œå¿½ç•¥å®ƒä»¬çš„çˆ¶å€¼ï¼š
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Do Now!
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do we check only the value parts?
  id: totrans-48
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆæˆ‘ä»¬åªæ£€æŸ¥å€¼éƒ¨åˆ†ï¼Ÿ
- en: We will assume that for a given set, we always return the same representative
    element. (Otherwise, equality will fail even though we have the same set.) Thus:Weâ€™ve
    used the name `fynd` because `find` is already defined to mean something else
    in Pyret. If you donâ€™t like the misspelling, youâ€™re welcome to use a longer name
    like `find-root`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†å‡è®¾å¯¹äºç»™å®šçš„é›†åˆï¼Œæˆ‘ä»¬æ€»æ˜¯è¿”å›ç›¸åŒçš„ä»£è¡¨å…ƒç´ ã€‚ï¼ˆå¦åˆ™ï¼Œå³ä½¿æˆ‘ä»¬æœ‰ç›¸åŒçš„é›†åˆï¼Œç­‰ä»·æ€§ä¹Ÿä¼šå¤±è´¥ã€‚ï¼‰å› æ­¤ï¼šæˆ‘ä»¬ä½¿ç”¨åç§° `fynd` æ˜¯å› ä¸º `find`
    åœ¨ Pyret ä¸­å·²ç»è¢«å®šä¹‰ä¸ºè¡¨ç¤ºå…¶ä»–å«ä¹‰ã€‚å¦‚æœä½ ä¸å–œæ¬¢è¿™ä¸ªæ‹¼å†™é”™è¯¯ï¼Œä½ å¯ä»¥ä½¿ç”¨æ›´é•¿çš„åç§°ï¼Œæ¯”å¦‚ `find-root`ã€‚
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'where `Sets` is the list of all elements:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­ `Sets` æ˜¯æ‰€æœ‰å…ƒç´ çš„åˆ—è¡¨ï¼š
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'How do we find the representative element for a set? We first find it using
    `is-same-element`; when we do, we check the elementâ€™s `parent` field. If it is
    `none`, that means this very element names its set; this can happen either because
    the element is a singleton set (weâ€™ll initialize all elements with `none`), or
    itâ€™s the name for some larger set. Either way, weâ€™re done. Otherwise, we have
    to recursively find the parent:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•æ‰¾åˆ°ä¸€ä¸ªé›†åˆçš„ä»£è¡¨å…ƒç´ ï¼Ÿæˆ‘ä»¬é¦–å…ˆä½¿ç”¨ `is-same-element` æ¥æ‰¾åˆ°å®ƒï¼›å½“æˆ‘ä»¬æ‰¾åˆ°å®ƒæ—¶ï¼Œæˆ‘ä»¬æ£€æŸ¥å…ƒç´ çš„ `parent` å­—æ®µã€‚å¦‚æœå®ƒæ˜¯
    `none`ï¼Œè¿™æ„å‘³ç€è¿™ä¸ªå…ƒç´ æœ¬èº«å‘½åäº†å®ƒçš„é›†åˆï¼›è¿™å¯èƒ½æ˜¯å› ä¸ºå…ƒç´ æ˜¯å•å…ƒç´ é›†åˆï¼ˆæˆ‘ä»¬å°†æ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸º `none`ï¼‰ï¼Œæˆ–è€…å®ƒæ˜¯æŸä¸ªæ›´å¤§é›†åˆçš„åç§°ã€‚æ— è®ºå¦‚ä½•ï¼Œæˆ‘ä»¬å·²ç»å®Œæˆäº†ã€‚å¦åˆ™ï¼Œæˆ‘ä»¬å¿…é¡»é€’å½’åœ°æ‰¾åˆ°çˆ¶å…ƒç´ ï¼š
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Exercise
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why is there a recursive call in the nested `cases`?
  id: totrans-57
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆåœ¨åµŒå¥—çš„ `cases` ä¸­æœ‰é€’å½’è°ƒç”¨ï¼Ÿ
- en: 'Whatâ€™s left is to implement `union`. For this, we find the representative elements
    of the two sets weâ€™re trying to union; if they are the same, then the two sets
    are already in a union; otherwise, we have to update the data structure:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: å‰©ä¸‹çš„å°±æ˜¯å®ç° `union`ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬æ‰¾åˆ°æˆ‘ä»¬æƒ³è¦åˆå¹¶çš„ä¸¤ä¸ªé›†åˆçš„ä»£è¡¨å…ƒç´ ï¼›å¦‚æœå®ƒä»¬æ˜¯ç›¸åŒçš„ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªé›†åˆå·²ç»åœ¨ä¸€ä¸ªè”åˆä¸­ï¼›å¦åˆ™ï¼Œæˆ‘ä»¬å¿…é¡»æ›´æ–°æ•°æ®ç»“æ„ï¼š
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To update, we arbitrarily choose one of the set names to be the name of the
    new compound set. We then have to update the parent of the other setâ€™s name element
    to be this one:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†æ›´æ–°ï¼Œæˆ‘ä»¬ä»»æ„é€‰æ‹©ä¸€ä¸ªé›†åˆåç§°ä½œä¸ºæ–°å¤åˆé›†åˆçš„åç§°ã€‚ç„¶åæˆ‘ä»¬å¿…é¡»æ›´æ–°å…¶ä»–é›†åˆåç§°å…ƒç´ çš„çˆ¶å…ƒç´ ä¸ºè¿™ä¸ªåç§°ï¼š
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here are some tests to illustrate this working:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€äº›æµ‹è¯•æ¥è¯´æ˜è¿™ä¸€ç‚¹ï¼š
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Unfortunately, this implementation suffers from two major problems:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼Œè¿™ä¸ªå®ç°å­˜åœ¨ä¸¤ä¸ªä¸»è¦é—®é¢˜ï¼š
- en: First, because we are performing functional updates, the value of the `parent`
    reference keeps â€œchangingâ€, but these changes are not visible to older copies
    of the â€œsameâ€ value. An element from different stages of unioning has different
    parent references, even though it is arguably the same element throughout. This
    is a place where functional programming hurts.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œå› ä¸ºæˆ‘ä»¬æ­£åœ¨è¿›è¡Œå‡½æ•°å¼æ›´æ–°ï¼Œ`parent`å¼•ç”¨çš„å€¼ä¼šâ€œä¸æ–­å˜åŒ–â€ï¼Œä½†è¿™äº›å˜åŒ–å¯¹â€œç›¸åŒâ€å€¼çš„æ—§å‰¯æœ¬æ˜¯ä¸å¯è§çš„ã€‚åœ¨å¹¶æŸ¥é›†çš„ä¸åŒé˜¶æ®µï¼Œä¸€ä¸ªå…ƒç´ æœ‰ä¸åŒçš„çˆ¶å¼•ç”¨ï¼Œå°½ç®¡å®ƒåœ¨æ•´ä¸ªè¿‡ç¨‹ä¸­å¯ä»¥è¯´æ˜¯ç›¸åŒçš„å…ƒç´ ã€‚è¿™æ˜¯å‡½æ•°å¼ç¼–ç¨‹å—ä¼¤å®³çš„åœ°æ–¹ã€‚
- en: Relatedly, the performance of this implementation is quite bad. `fynd` recursively
    traverses parents to find the setâ€™s name, but the elements traversed are not updated
    to record this new name. We certainly could update them by reconstructing the
    set afresh each time, but that complicates the implementation and, as we will
    soon see, we can do much better.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç›¸å…³åœ°ï¼Œè¿™ä¸ªå®ç°çš„æ€§èƒ½ç›¸å½“å·®ã€‚`fynd`é€’å½’éå†çˆ¶èŠ‚ç‚¹ä»¥æ‰¾åˆ°é›†åˆçš„åç§°ï¼Œä½†éå†çš„å…ƒç´ æ²¡æœ‰è¢«æ›´æ–°ä»¥è®°å½•è¿™ä¸ªæ–°åç§°ã€‚æˆ‘ä»¬å½“ç„¶å¯ä»¥é€šè¿‡æ¯æ¬¡é‡æ–°æ„å»ºé›†åˆæ¥æ›´æ–°å®ƒä»¬ï¼Œä½†è¿™ä¼šä½¿å®ç°å¤æ‚åŒ–ï¼Œè€Œä¸”æ­£å¦‚æˆ‘ä»¬å¾ˆå¿«å°±ä¼šçœ‹åˆ°çš„ï¼Œæˆ‘ä»¬å¯ä»¥åšå¾—æ›´å¥½ã€‚
- en: Even worse, it may not even be correct!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: æ›´ç³Ÿç³•çš„æ˜¯ï¼Œå®ƒç”šè‡³å¯èƒ½ä¸æ­£ç¡®ï¼
- en: Exercise
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is it? Consider constructing `union`s that are not quite so skewed as above,
    and see whether you get the results you expect.
  id: totrans-70
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ˜¯å—ï¼Ÿè€ƒè™‘æ„å»ºä¸é‚£ä¹ˆå€¾æ–œçš„`union`ï¼Œçœ‹çœ‹ä½ æ˜¯å¦èƒ½å¾—åˆ°é¢„æœŸçš„ç»“æœã€‚
- en: 'The bottom line is that pure functional programming is not a great fit with
    this problem. We need a better implementation strategy: [Union-Find](union-find.html).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: æ ¸å¿ƒé—®é¢˜æ˜¯çº¯å‡½æ•°å¼ç¼–ç¨‹å¹¶ä¸éå¸¸é€‚åˆè¿™ä¸ªé—®é¢˜ã€‚æˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ›´å¥½çš„å®ç°ç­–ç•¥ï¼š[å¹¶æŸ¥é›†](union-find.html)ã€‚
- en: 17.5.1Â The Problem[ğŸ”—](#(part._.The_.Problem) "Link to here")
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.5.1Â é—®é¢˜[ğŸ”—](#(part._.The_.Problem) "é“¾æ¥åˆ°æ­¤å¤„")
- en: To understand the history of national electrical grids, it helps to go back
    to [Moravia](http://en.wikipedia.org/wiki/Moravia) in the 1920s. Like many parts
    of the world, it was beginning to realize the benefits of electricity and intended
    to spread it around the region. A Moravian academia named Otakar BorÅ¯vka heard
    about the problem, and in a remarkable effort, described the problem abstractly,
    so that it could be understood without reference to Moravia or electrical networks.
    He modeled it as a problem about graphs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: è¦äº†è§£å›½å®¶ç”µç½‘çš„å†å²ï¼Œå›åˆ°20ä¸–çºª20å¹´ä»£çš„[æ‘©æ‹‰ç»´äºš](http://en.wikipedia.org/wiki/Moravia)å¯èƒ½ä¼šæœ‰æ‰€å¸®åŠ©ã€‚åƒä¸–ç•Œä¸Šè®¸å¤šå…¶ä»–åœ°æ–¹ä¸€æ ·ï¼Œå®ƒå¼€å§‹æ„è¯†åˆ°ç”µåŠ›çš„å¥½å¤„ï¼Œå¹¶æ‰“ç®—åœ¨è¯¥åœ°åŒºæ¨å¹¿ç”µåŠ›ã€‚ä¸€ä½åå«å¥¥å¡”å¡å°”Â·åšé²ç“¦å¡çš„æ‘©æ‹‰ç»´äºšå­¦è€…å¬è¯´äº†è¿™ä¸ªé—®é¢˜ï¼Œå¹¶åœ¨ä¸€ä¸ªéå‡¡çš„åŠªåŠ›ä¸­ï¼ŒæŠ½è±¡åœ°æè¿°äº†è¿™ä¸ªé—®é¢˜ï¼Œè¿™æ ·å°±å¯ä»¥åœ¨æ²¡æœ‰å‚è€ƒæ‘©æ‹‰ç»´äºšæˆ–ç”µç½‘çš„æƒ…å†µä¸‹ç†è§£å®ƒã€‚ä»–å°†å®ƒå»ºæ¨¡ä¸ºä¸€ä¸ªå…³äºå›¾çš„é—®é¢˜ã€‚
- en: 'BorÅ¯vka observed that at least initially, any solution to the problem of creating
    a network must have the following characteristics:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: åšé²ç“¦å¡è§‚å¯Ÿåˆ°ï¼Œè‡³å°‘æœ€åˆï¼Œä»»ä½•åˆ›å»ºç½‘ç»œçš„è§£å†³æ–¹æ¡ˆéƒ½å¿…é¡»å…·æœ‰ä»¥ä¸‹ç‰¹å¾ï¼š
- en: The electrical network must reach all the towns intended to be covered by it.
    In graph terms, the solution must be spanning, meaning it must visit every node
    in the graph.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç”µç½‘å¿…é¡»è¦†ç›–æ‰€æœ‰æ‰“ç®—è¦†ç›–çš„åŸé•‡ã€‚åœ¨å›¾è®ºæœ¯è¯­ä¸­ï¼Œè§£å†³æ–¹æ¡ˆå¿…é¡»æ˜¯ç”Ÿæˆæ€§çš„ï¼Œè¿™æ„å‘³ç€å®ƒå¿…é¡»è®¿é—®å›¾ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹ã€‚
- en: 'Redundancy is a valuable property in any network: that way, if one set of links
    goes down, there might be another way to get a payload to its destination. When
    starting out, however, redundancy may be too expensive, especially if it comes
    at the cost of not giving someone a payload at all. Thus, the initial solution
    was best set up without loops or even redundant paths. In graph terms, the solution
    had to be a tree.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å†—ä½™æ˜¯ä»»ä½•ç½‘ç»œä¸­çš„ä¸€ä¸ªå®è´µå±æ€§ï¼šè¿™æ ·ï¼Œå¦‚æœä¸€ç»„é“¾æ¥å¤±æ•ˆï¼Œå¯èƒ½ä¼šæœ‰å¦ä¸€ç§æ–¹å¼å°†æœ‰æ•ˆè½½è·å‘é€åˆ°ç›®çš„åœ°ã€‚ç„¶è€Œï¼Œåœ¨å¼€å§‹æ—¶ï¼Œå†—ä½™å¯èƒ½è¿‡äºæ˜‚è´µï¼Œå°¤å…¶æ˜¯å¦‚æœå®ƒæ˜¯ä»¥ä¸å‘æŸäººæä¾›æœ‰æ•ˆè½½è·ä¸ºä»£ä»·çš„è¯ã€‚å› æ­¤ï¼Œæœ€åˆçš„è§£å†³æ–¹æ¡ˆæœ€å¥½è®¾ç½®ä¸ºæ²¡æœ‰ç¯è·¯ç”šè‡³å†—ä½™è·¯å¾„ã€‚åœ¨å›¾è®ºæœ¯è¯­ä¸­ï¼Œè§£å†³æ–¹æ¡ˆå¿…é¡»æ˜¯ä¸€æ£µæ ‘ã€‚
- en: Finally, the goal was to solve this problem for the least cost possible. In
    graph terms, the graph would be weighted, and the solution had to be a minimum.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœ€åï¼Œç›®æ ‡æ˜¯å°½å¯èƒ½ä»¥æœ€ä½çš„æˆæœ¬è§£å†³è¿™ä¸ªé—®é¢˜ã€‚åœ¨å›¾è®ºæœ¯è¯­ä¸­ï¼Œå›¾å°†æ˜¯åŠ æƒçš„ï¼Œè§£å†³æ–¹æ¡ˆå¿…é¡»æ˜¯æœ€å°å€¼ã€‚
- en: Thus BorÅ¯vka defined the Moravian Spanning Tree (MST) problem.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œåšé²ç“¦å¡å®šä¹‰äº†æ‘©æ‹‰ç»´äºšç”Ÿæˆæ ‘ï¼ˆMSTï¼‰é—®é¢˜ã€‚
- en: 17.5.2Â A Greedy Solution[ğŸ”—](#(part._.A_.Greedy_.Solution) "Link to here")
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.5.2Â è´ªå©ªè§£æ³•[ğŸ”—](#(part._.A_.Greedy_.Solution) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'BorÅ¯vka had published his problem, and another Czech mathematician, [VojtÄ›ch
    JarnÃ­k](http://en.wikipedia.org/wiki/Vojt%C4%9Bch_Jarn%C3%ADk), came across it.
    JarnÃ­k came up with a solution that should sound familiar:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: åšé²ç“¦å¡å·²ç»å‘è¡¨äº†è¿™ä¸ªé—®é¢˜ï¼Œå¦ä¸€ä½æ·å…‹æ•°å­¦å®¶[æ²ƒä¼Šæ·èµ«Â·äºšå°¼å…‹](http://en.wikipedia.org/wiki/Vojt%C4%9Bch_Jarn%C3%ADk)å¶ç„¶å‘ç°äº†å®ƒã€‚äºšå°¼å…‹æå‡ºäº†ä¸€ä¸ªå¬èµ·æ¥ç†Ÿæ‚‰çš„è§£å†³æ–¹æ¡ˆï¼š
- en: Begin with a solution consisting of a single node, chosen arbitrarily. For the
    graph consisting of this one node, this solution is clearly a minimum, spanning,
    and a tree.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä»ä¸€ä¸ªç”±å•ä¸ªèŠ‚ç‚¹ç»„æˆçš„è§£å¼€å§‹ï¼Œè¿™ä¸ªèŠ‚ç‚¹æ˜¯ä»»æ„é€‰æ‹©çš„ã€‚å¯¹äºç”±è¿™ä¸ªèŠ‚ç‚¹ç»„æˆçš„å›¾ï¼Œè¿™ä¸ªè§£æ˜¾ç„¶æ˜¯æœ€å°ç”Ÿæˆæ ‘ã€ç”Ÿæˆæ ‘å’Œæ ‘ã€‚
- en: Of all the edges incident on nodes in the solution that connect to a node not
    already in the solution, pick the edge with the least weight.Note that we consider
    only the incident edges, not their weight added to the weight of the node to which
    they are incident.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨è§£ä¸­ä¸èŠ‚ç‚¹ç›¸è¿ä¸”å°šæœªåŒ…å«åœ¨è§£ä¸­çš„èŠ‚ç‚¹ä¹‹é—´ï¼Œé€‰æ‹©æƒé‡æœ€å°çš„è¾¹ã€‚è¯·æ³¨æ„ï¼Œæˆ‘ä»¬åªè€ƒè™‘è¿™äº›è¾¹ï¼Œè€Œä¸æ˜¯å®ƒä»¬é™„åŠ åˆ°å®ƒä»¬æ‰€è¿æ¥çš„èŠ‚ç‚¹çš„æƒé‡ã€‚
- en: Add this edge to the solution. The claim is that for the new solution will be
    a tree (by construction), spanning (also by construction), and a minimum. The
    minimality follows by an argument similar to that used for Dijkstraâ€™s Algorithm.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å°†è¿™æ¡è¾¹æ·»åŠ åˆ°è§£ä¸­ã€‚æ–­è¨€æ˜¯ï¼Œå¯¹äºæ–°çš„è§£å°†æ˜¯ä¸€ä¸ªæ ‘ï¼ˆé€šè¿‡æ„é€ ï¼‰ï¼Œç”Ÿæˆæ ‘ï¼ˆä¹Ÿé€šè¿‡æ„é€ ï¼‰ï¼Œå¹¶ä¸”æ˜¯æœ€å°çš„ã€‚æœ€å°æ€§å¯ä»¥é€šè¿‡ä¸Dijkstraç®—æ³•ä¸­ä½¿ç”¨çš„ç±»ä¼¼è®ºè¯å¾—å‡ºã€‚
- en: JarnÃ­k had the misfortune of publishing this work in Czech in 1930, and it went
    largely ignored. It was rediscovered by others, most notably by R.C. Prim in 1957,
    and is now generally known as Primâ€™s Algorithm, though calling it JarnÃ­kâ€™s Algorithm
    would attribute credit in the right place.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: JarnÃ­kä¸å¹¸åœ¨1930å¹´å°†è¿™é¡¹å·¥ä½œä»¥æ·å…‹è¯­å‘è¡¨ï¼Œå¹¶ä¸”å®ƒå‡ ä¹è¢«å¿½è§†ã€‚å®ƒåæ¥è¢«å…¶ä»–äººé‡æ–°å‘ç°ï¼Œæœ€è‘—åçš„æ˜¯R.C. Primåœ¨1957å¹´ï¼Œç°åœ¨é€šå¸¸è¢«ç§°ä¸ºPrimç®—æ³•ï¼Œå°½ç®¡ç§°ä¹‹ä¸ºJarnÃ­kç®—æ³•ä¼šæ›´å‡†ç¡®åœ°å½’åŠŸäºæ­£ç¡®çš„äººã€‚
- en: Implementing this algorithm is pretty easy. At each point, we need to know the
    lightest edge incident on the current solution tree. Finding the lightest edge
    takes time linear in the number of these edges, but the very lightest one may
    create a cycle. We therefore need to efficiently check for whether adding an edge
    would create a cycle, a problem we will return to multiple times [[Checking Component
    Connectedness](#%28part._union-find-functional%29)]. Assuming we can do that effectively,
    we then want to add the lightest edge and iterate. Even given an efficient solution
    for checking cyclicity, this would seem to require an operation linear in the
    number of edges for each node. With better representations we can improve on this
    complexity, but letâ€™s look at other ideas first.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: å®ç°è¿™ä¸ªç®—æ³•ç›¸å½“ç®€å•ã€‚åœ¨æ¯ä¸€ä¸ªç‚¹ä¸Šï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“å½“å‰è§£æ ‘ä¸Šçš„æœ€è½»è¾¹ã€‚æ‰¾åˆ°æœ€è½»è¾¹éœ€è¦ä¸è¿™äº›è¾¹çš„æ•°é‡æˆçº¿æ€§å…³ç³»çš„æ—¶é—´ï¼Œä½†æœ€è½»çš„è¾¹å¯èƒ½ä¼šå½¢æˆä¸€ä¸ªç¯ã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦æœ‰æ•ˆåœ°æ£€æŸ¥æ·»åŠ è¾¹æ˜¯å¦ä¼šå½¢æˆç¯ï¼Œè¿™æ˜¯ä¸€ä¸ªæˆ‘ä»¬å°†å¤šæ¬¡è¿”å›çš„é—®é¢˜[[æ£€æŸ¥ç»„ä»¶è¿é€šæ€§](#(part._union-find-functional))]ã€‚å‡è®¾æˆ‘ä»¬èƒ½å¤Ÿæœ‰æ•ˆåœ°åšåˆ°è¿™ä¸€ç‚¹ï¼Œç„¶åæˆ‘ä»¬æƒ³è¦æ·»åŠ æœ€è½»çš„è¾¹å¹¶è¿­ä»£ã€‚å³ä½¿ç»™å‡ºäº†æ£€æŸ¥ç¯çš„æœ‰æ•ˆè§£å†³æ–¹æ¡ˆï¼Œè¿™ä¼¼ä¹ä¹Ÿéœ€è¦å¯¹æ¯ä¸ªèŠ‚ç‚¹è¿›è¡Œçº¿æ€§äºè¾¹æ•°çš„æ“ä½œã€‚é€šè¿‡æ›´å¥½çš„è¡¨ç¤ºï¼Œæˆ‘ä»¬å¯ä»¥æ”¹è¿›è¿™ä¸ªå¤æ‚æ€§ï¼Œä½†è®©æˆ‘ä»¬å…ˆçœ‹çœ‹å…¶ä»–æƒ³æ³•ã€‚
- en: 17.5.3Â Another Greedy Solution[ğŸ”—](#(part._.Another_.Greedy_.Solution) "Link
    to here")
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.5.3 å¦ä¸€ç§è´ªå©ªè§£æ³•[ğŸ”—](#(part._.Another_.Greedy_.Solution) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Recall that JarnÃ­k presented his algorithm in 1930, when computers didnâ€™t exist,
    and Prim his in 1957, when they were very much in their infancy. Programming computers
    to track heaps was a non-trivial problem, and many algorithms were implemented
    by hand, where keeping track of a complex data structure without making errors
    was harder still. There was need for a solution that was required less manual
    bookkeeping (literally speaking).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: å›æƒ³ä¸€ä¸‹ï¼ŒJarnÃ­kåœ¨1930å¹´æå‡ºäº†ä»–çš„ç®—æ³•ï¼Œå½“æ—¶è®¡ç®—æœºè¿˜ä¸å­˜åœ¨ï¼Œè€ŒPrimåœ¨1957å¹´æå‡ºäº†ä»–çš„ç®—æ³•ï¼Œå½“æ—¶è®¡ç®—æœºè¿˜å¤„äºå©´å„¿æœŸã€‚ç¼–ç¨‹è®¡ç®—æœºè·Ÿè¸ªå †æ˜¯ä¸€ä¸ªéå¹³å‡¡çš„é—®é¢˜ï¼Œè®¸å¤šç®—æ³•éƒ½æ˜¯æ‰‹å·¥å®ç°çš„ï¼Œåœ¨æ²¡æœ‰é”™è¯¯çš„æƒ…å†µä¸‹è·Ÿè¸ªå¤æ‚çš„æ•°æ®ç»“æ„æ›´åŠ å›°éš¾ã€‚éœ€è¦ä¸€ç§éœ€è¦æ›´å°‘æ‰‹åŠ¨è®°å½•ï¼ˆå­—é¢ä¸Šè¯´ï¼‰çš„è§£å†³æ–¹æ¡ˆã€‚
- en: In 1956, [Joseph Kruskal](http://en.wikipedia.org/wiki/Joseph_Kruskal) presented
    such a solution. His idea was elegantly simple. The JarnÃ­k algorithm suffers from
    the problem that each time the tree grows, we have to revise the content of the
    heap, which is already a messy structure to track. Kruskal noted the following.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨1956å¹´ï¼Œ[çº¦ç‘Ÿå¤«Â·å…‹é²æ–¯å¡å°”](http://en.wikipedia.org/wiki/Joseph_Kruskal)æå‡ºäº†è¿™æ ·çš„è§£å†³æ–¹æ¡ˆã€‚ä»–çš„æƒ³æ³•ç®€å•è€Œä¼˜é›…ã€‚JarnÃ­kç®—æ³•çš„é—®é¢˜åœ¨äºæ¯æ¬¡æ ‘å¢é•¿æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»ä¿®æ”¹å †çš„å†…å®¹ï¼Œè¿™å·²ç»æ˜¯ä¸€ä¸ªéš¾ä»¥è¿½è¸ªçš„æ··ä¹±ç»“æ„ã€‚Kruskalæ³¨æ„åˆ°äº†ä»¥ä¸‹å‡ ç‚¹ã€‚
- en: 'To obtain a minimum solution, surely we want to include one of the edges of
    least weight in the graph. Because if not, we can take an otherwise minimal solution,
    add this edge, and remove one other edge; the graph would still be just as connected,
    but the overall weight would be no more and, if the removed edge were heavier,
    would be less.Note the careful wording: there may be many edges of the same least
    weight, so adding one of them may remove another, and therefore not produce a
    lighter tree; but the key point is that it certainly will not produce a heavier
    one. By the same argument we can add the next lightest edge, and the next lightest,
    and so on. The only time we cannot add the next lightest edge is when it would
    create a cycle (that problem again!).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†è·å¾—æœ€å°è§£ï¼Œæˆ‘ä»¬å½“ç„¶å¸Œæœ›å°†å›¾ä¸­æƒé‡æœ€å°çš„è¾¹ä¹‹ä¸€åŒ…å«åœ¨å†…ã€‚å¦‚æœä¸è¿™æ ·åšï¼Œæˆ‘ä»¬å¯ä»¥å–ä¸€ä¸ªå…¶ä»–æ–¹é¢æœ€å°çš„è§£ï¼Œæ·»åŠ è¿™æ¡è¾¹ï¼Œå¹¶ç§»é™¤å¦ä¸€æ¡è¾¹ï¼›å›¾ä»ç„¶ä¿æŒè¿é€šï¼Œä½†æ€»æƒé‡ä¸ä¼šæ›´å¤šï¼Œå¦‚æœç§»é™¤çš„è¾¹æ›´é‡ï¼Œåˆ™æ›´å°‘ã€‚æ³¨æ„æªè¾çš„è°¨æ…ï¼šå¯èƒ½å­˜åœ¨è®¸å¤šæƒé‡ç›¸åŒçš„è¾¹ï¼Œæ·»åŠ å…¶ä¸­ä¸€æ¡å¯èƒ½ä¼šç§»é™¤å¦ä¸€æ¡ï¼Œå› æ­¤ä¸ä¼šäº§ç”Ÿæ›´è½»çš„æ ‘ï¼›ä½†å…³é”®ç‚¹æ˜¯ï¼Œå®ƒè‚¯å®šä¸ä¼šäº§ç”Ÿæ›´é‡çš„æ ‘ã€‚é€šè¿‡åŒæ ·çš„è®ºæ®ï¼Œæˆ‘ä»¬å¯ä»¥æ·»åŠ ä¸‹ä¸€æ¡æœ€è½»çš„è¾¹ï¼Œå†ä¸‹ä¸€æ¡ï¼Œä¾æ­¤ç±»æ¨ã€‚å”¯ä¸€ä¸èƒ½æ·»åŠ ä¸‹ä¸€æ¡æœ€è½»è¾¹çš„æƒ…å†µæ˜¯ï¼Œå®ƒä¼šå½¢æˆä¸€ä¸ªç¯ï¼ˆåˆæ˜¯è¿™ä¸ªé—®é¢˜ï¼ï¼‰ã€‚
- en: Therefore, Kruskalâ€™s algorithm is utterly straightforward. We first sort all
    the edges, ordered by ascending weight. We then take each edge in ascending weight
    order and add it to the solution provided it will not create a cycle. When we
    have thus processed all the edges, we will have a solution that is a tree (by
    construction), spanning (because every connected vertex must be the endpoint of
    some edge), and of minimum weight (by the argument above). The complexity is that
    of sorting (which is \([e \rightarrow e \log e]\) where \(e\) is the size of the
    edge set. We then iterate over each element in \(e\), which takes time linear
    in the size of that setâ€”<wbr>modulo the time to check for cycles. This algorithm
    is also easy to implement on paper, because we sort all the edges once, then keep
    checking them off in order, crossing out the ones that create cyclesâ€”<wbr>with
    no dynamic updating of the list needed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼ŒKruskalç®—æ³•æå…¶ç®€å•ã€‚æˆ‘ä»¬é¦–å…ˆæŒ‰å‡åºå¯¹æ‰€æœ‰è¾¹è¿›è¡Œæ’åºã€‚ç„¶åï¼Œæˆ‘ä»¬æŒ‰å‡åºé¡ºåºå–æ¯æ¡è¾¹ï¼Œå¦‚æœå®ƒä¸ä¼šå½¢æˆç¯ï¼Œå°±å°†å…¶æ·»åŠ åˆ°è§£å†³æ–¹æ¡ˆä¸­ã€‚å½“æˆ‘ä»¬è¿™æ ·å¤„ç†æ‰€æœ‰è¾¹åï¼Œæˆ‘ä»¬å°†å¾—åˆ°ä¸€ä¸ªæ ‘å½¢è§£å†³æ–¹æ¡ˆï¼ˆé€šè¿‡æ„å»ºï¼‰ï¼Œå®ƒè¦†ç›–æ‰€æœ‰è¿æ¥çš„é¡¶ç‚¹ï¼ˆå› ä¸ºæ¯ä¸ªè¿é€šé¡¶ç‚¹å¿…é¡»æ˜¯æŸæ¡è¾¹çš„ç«¯ç‚¹ï¼‰ï¼Œå¹¶ä¸”å…·æœ‰æœ€å°æƒé‡ï¼ˆå¦‚ä¸Šæ‰€è¿°ï¼‰ã€‚å…¶å¤æ‚åº¦ä¸æ’åºç›¸åŒï¼ˆå³
    \([e \rightarrow e \log e]\)ï¼Œå…¶ä¸­ \(e\) æ˜¯è¾¹é›†çš„å¤§å°ï¼‰ã€‚ç„¶åæˆ‘ä»¬éå† \(e\) ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œè¿™éœ€è¦ä¸è¯¥é›†åˆå¤§å°æˆçº¿æ€§å…³ç³»çš„æ—¶é—´â€”â€”<wbr>å‡å»æ£€æŸ¥ç¯æ‰€éœ€çš„æ—¶é—´ã€‚è¿™ä¸ªç®—æ³•ä¹Ÿå®¹æ˜“åœ¨çº¸ä¸Šå®ç°ï¼Œå› ä¸ºæˆ‘ä»¬åªå¯¹è¾¹è¿›è¡Œä¸€æ¬¡æ’åºï¼Œç„¶åæŒ‰é¡ºåºæ£€æŸ¥å®ƒä»¬ï¼Œåˆ’æ‰é‚£äº›å½¢æˆç¯çš„è¾¹â€”â€”<wbr>ä¸éœ€è¦åŠ¨æ€æ›´æ–°åˆ—è¡¨ã€‚
- en: 17.5.4Â A Third Solution[ğŸ”—](#(part._.A_.Third_.Solution) "Link to here")
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.5.4Â ç¬¬ä¸‰ç§è§£å†³æ–¹æ¡ˆ[ğŸ”—](#(part._.A_.Third_.Solution) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Both the JarnÃ­k and Kruskal solutions have one flaw: they require a centralized
    data structure (the priority heap, or the sorted list) to incrementally build
    the solution. As parallel computers became available, and graph problems grew
    large, computer scientists looked for solutions that could be implemented more
    efficiently in parallelâ€”<wbr>which typically meant avoiding any centralized points
    of synchronization, such as these centralized data structures.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: JarnÃ­kå’ŒKruskalçš„è§£å†³æ–¹æ¡ˆéƒ½å­˜åœ¨ä¸€ä¸ªç¼ºé™·ï¼šå®ƒä»¬éœ€è¦é›†ä¸­å¼æ•°æ®ç»“æ„ï¼ˆä¼˜å…ˆå †æˆ–æ’åºåˆ—è¡¨ï¼‰æ¥é€æ­¥æ„å»ºè§£å†³æ–¹æ¡ˆã€‚éšç€å¹¶è¡Œè®¡ç®—æœºçš„å‡ºç°å’Œå›¾é—®é¢˜è§„æ¨¡çš„æ‰©å¤§ï¼Œè®¡ç®—æœºç§‘å­¦å®¶ä»¬å¯»æ‰¾èƒ½å¤Ÿåœ¨å¹¶è¡Œç¯å¢ƒä¸­æ›´é«˜æ•ˆå®ç°çš„è§£å†³æ–¹æ¡ˆâ€”â€”è¿™é€šå¸¸æ„å‘³ç€é¿å…ä»»ä½•é›†ä¸­å¼çš„åŒæ­¥ç‚¹ï¼Œä¾‹å¦‚è¿™äº›é›†ä¸­å¼æ•°æ®ç»“æ„ã€‚
- en: In 1965, M. Sollin constructed an algorithm that met these needs beautifully.
    In this algorithm, instead of constructing a single solution, we grow multiple
    solution components (potentially in parallel if we so wish). Each node starts
    out as a solution component (as it was at the first step of JarnÃ­kâ€™s Algorithm).
    Each node considers the edges incident to it, and picks the lightest one that
    connects to a different component (that problem again!). If such an edge can be
    found, the edge becomes part of the solution, and the two components combine to
    become a single component. The entire process repeats.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 1965å¹´ï¼ŒM. Sollinæ„å»ºäº†ä¸€ä¸ªå®Œç¾æ»¡è¶³è¿™äº›éœ€æ±‚çš„ç®—æ³•ã€‚åœ¨è¿™ä¸ªç®—æ³•ä¸­ï¼Œæˆ‘ä»¬ä¸æ˜¯æ„å»ºå•ä¸ªè§£å†³æ–¹æ¡ˆï¼Œè€Œæ˜¯ç”Ÿé•¿å¤šä¸ªè§£å†³æ–¹æ¡ˆç»„ä»¶ï¼ˆå¦‚æœæ„¿æ„ï¼Œå¯ä»¥å¹¶è¡Œåœ°è¿™æ ·åšï¼‰ã€‚æ¯ä¸ªèŠ‚ç‚¹æœ€åˆéƒ½æ˜¯ä¸€ä¸ªè§£å†³æ–¹æ¡ˆç»„ä»¶ï¼ˆå°±åƒJarnÃ­kç®—æ³•çš„ç¬¬ä¸€æ­¥ä¸€æ ·ï¼‰ã€‚æ¯ä¸ªèŠ‚ç‚¹è€ƒè™‘ä¸å…¶ç›¸è¿çš„è¾¹ï¼Œå¹¶é€‰æ‹©è¿æ¥åˆ°ä¸åŒç»„ä»¶çš„æœ€è½»è¾¹ï¼ˆåˆæ˜¯è¿™ä¸ªé—®é¢˜ï¼ï¼‰ã€‚å¦‚æœå¯ä»¥æ‰¾åˆ°è¿™æ ·çš„è¾¹ï¼Œè¿™æ¡è¾¹å°±æˆä¸ºè§£å†³æ–¹æ¡ˆçš„ä¸€éƒ¨åˆ†ï¼Œä¸¤ä¸ªç»„ä»¶åˆå¹¶æˆä¸ºä¸€ä¸ªç»„ä»¶ã€‚æ•´ä¸ªè¿‡ç¨‹é‡å¤è¿›è¡Œã€‚
- en: Because every node begins as part of the solution, this algorithm naturally
    spans. Because it checks for cycles and avoids them, it naturally forms a tree.Note
    that avoiding cycles yields a DAG and is not automatically guaranteed to yield
    a tree. We have been a bit lax about this difference throughout this section.
    Finally, minimality follows through similar reasoning as we used in the case of
    JarnÃ­kâ€™s Algorithm, which we have essentially run in parallel, once from each
    node, until the parallel solution components join up to produce a global solution.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸ºæ¯ä¸ªèŠ‚ç‚¹æœ€åˆéƒ½æ˜¯è§£å†³æ–¹æ¡ˆçš„ä¸€éƒ¨åˆ†ï¼Œè¿™ä¸ªç®—æ³•è‡ªç„¶åœ°æ‰©å±•äº†ã€‚å› ä¸ºå®ƒæ£€æŸ¥å¾ªç¯å¹¶é¿å…å®ƒä»¬ï¼Œå®ƒè‡ªç„¶åœ°å½¢æˆäº†ä¸€æ£µæ ‘ã€‚è¯·æ³¨æ„ï¼Œé¿å…å¾ªç¯ä¼šäº§ç”Ÿä¸€ä¸ªæœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰ï¼Œå¹¶ä¸è‡ªåŠ¨ä¿è¯äº§ç”Ÿä¸€æ£µæ ‘ã€‚æˆ‘ä»¬åœ¨æœ¬èŠ‚ä¸­å¯¹æ­¤å·®å¼‚æœ‰ç‚¹å®½æ¾ã€‚æœ€åï¼Œæœ€å°æ€§é€šè¿‡ä¸æˆ‘ä»¬ç”¨äºJarnÃ­kç®—æ³•çš„ç±»ä¼¼æ¨ç†å¾—å‡ºï¼Œæˆ‘ä»¬å®é™…ä¸Šæ˜¯åœ¨å¹¶è¡Œä¸­è¿è¡Œçš„ï¼Œæ¯ä¸ªèŠ‚ç‚¹è¿è¡Œä¸€æ¬¡ï¼Œç›´åˆ°å¹¶è¡Œè§£å†³æ–¹æ¡ˆç»„ä»¶è¿æ¥èµ·æ¥äº§ç”Ÿå…¨å±€è§£å†³æ–¹æ¡ˆã€‚
- en: 'Of course, maintaining the data for this algorithm by hand is a nightmare.
    Therefore, it would be no surprise that this algorithm was coined in the digital
    age. The real surprise, therefore, is that it was not: it was originally created
    by [Otakar BorÅ¯vka](http://en.wikipedia.org/wiki/Otakar_Bor%C5%AFvka) himself.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œæ‰‹åŠ¨ç»´æŠ¤è¿™ä¸ªç®—æ³•çš„æ•°æ®æ˜¯ä¸€ä¸ªå™©æ¢¦ã€‚å› æ­¤ï¼Œè¿™ä¸ªç®—æ³•æ˜¯åœ¨æ•°å­—æ—¶ä»£è¢«æå‡ºçš„è¿™ä¸€ç‚¹å¹¶ä¸ä»¤äººæƒŠè®¶ã€‚å› æ­¤ï¼ŒçœŸæ­£çš„æƒŠå–œæ˜¯å®ƒå¹¶ä¸æ˜¯ï¼šå®ƒæœ€åˆæ˜¯ç”±[Otakar BorÅ¯vka](http://en.wikipedia.org/wiki/Otakar_Bor%C5%AFvka)æœ¬äººåˆ›é€ çš„ã€‚
- en: 'BorÅ¯vka, you see, had figured it all out. Heâ€™d not only understood the problem,
    he had:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ çœ‹ï¼ŒBorÅ¯vkaå·²ç»å…¨éƒ¨æƒ³æ˜ç™½äº†ã€‚ä»–ä¸ä»…ç†è§£äº†è¿™ä¸ªé—®é¢˜ï¼Œä»–è¿˜ï¼š
- en: pinpointed the real problem lying underneath the electrification problem so
    it could be viewed in a context-independent way,
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‡†ç¡®åœ°æŒ‡å‡ºäº†ç”µåŒ–é—®é¢˜èƒŒåçš„çœŸæ­£é—®é¢˜ï¼Œä»¥ä¾¿å¯ä»¥ä»ç‹¬ç«‹äºä¸Šä¸‹æ–‡çš„æ–¹å¼æ¥çœ‹å¾…å®ƒï¼Œ
- en: created a descriptive language of graph theory to define it precisely, and
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ›å»ºäº†ä¸€ç§å›¾è®ºæè¿°æ€§è¯­è¨€æ¥ç²¾ç¡®åœ°å®šä¹‰å®ƒï¼Œ
- en: even solved the problem in addition to defining it.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸ä»…å®šä¹‰äº†é—®é¢˜ï¼Œè¿˜è§£å†³äº†å®ƒã€‚
- en: Heâ€™d just come up with a solution so complex to implement by hand that JarnÃ­k
    had in essence de-parallelized it so it could be done sequentially. And thus this
    algorithm lay unnoticed until it was reinvented ([several times, actually](http://en.wikipedia.org/wiki/Bor%C5%AFvka's_algorithm))
    by Sollin in time for parallel computing folks to notice a need for it. But now
    we can just call this BorÅ¯vkaâ€™s Algorithm, which is only fitting.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ä»–åˆšåˆšæƒ³å‡ºäº†ä¸€ä¸ªè¿‡äºå¤æ‚çš„è§£å†³æ–¹æ¡ˆï¼Œä»¥è‡³äºJarnÃ­kå®é™…ä¸Šå°†å…¶å»å¹¶è¡ŒåŒ–ï¼Œä»¥ä¾¿å¯ä»¥é¡ºåºæ‰§è¡Œã€‚å› æ­¤ï¼Œè¿™ä¸ªç®—æ³•ä¸€ç›´æœªè¢«æ³¨æ„ï¼Œç›´åˆ°Sollinåœ¨å¹¶è¡Œè®¡ç®—äººå‘˜æ³¨æ„åˆ°å…¶éœ€æ±‚æ—¶é‡æ–°å‘æ˜äº†å®ƒï¼ˆå®é™…ä¸Šï¼Œæ˜¯å¤šæ¬¡é‡æ–°å‘æ˜äº†å®ƒ[several
    times, actually](http://en.wikipedia.org/wiki/Bor%C5%AFvka's_algorithm)ï¼‰ã€‚ä½†ç°åœ¨æˆ‘ä»¬åªéœ€ç§°ä¹‹ä¸ºBorÅ¯vkaç®—æ³•ï¼Œè¿™éå¸¸åˆé€‚ã€‚
- en: As you might have guessed by now, this problem is indeed called the MST in other
    textbooks, but â€œMâ€ stands not for Moravia but for â€œMinimumâ€. But given BorÅ¯vkaâ€™s
    forgotten place in history, we prefer the more whimsical name.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚ä½ æ‰€çŒœæµ‹çš„ï¼Œè¿™ä¸ªé—®é¢˜åœ¨å…¶ä»–æ•™ç§‘ä¹¦ä¸­ç¡®å®è¢«ç§°ä¸ºMSTï¼Œä½†â€œMâ€ä¸æ˜¯æŒ‡æ‘©æ‹‰ç»´äºšï¼Œè€Œæ˜¯æŒ‡â€œæœ€å°â€ã€‚ä½†é‰´äºBorÅ¯vkaåœ¨å†å²ä¸Šçš„è¢«é—å¿˜åœ°ä½ï¼Œæˆ‘ä»¬æ›´å–œæ¬¢æ›´å¹½é»˜çš„åå­—ã€‚
- en: 17.5.5Â Checking Component Connectedness[ğŸ”—](#(part._union-find-functional) "Link
    to here")
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.5.5 æ£€æŸ¥ç»„ä»¶è¿é€šæ€§[ğŸ”—](#(part._union-find-functional) "é“¾æ¥åˆ°æ­¤å¤„")
- en: As weâ€™ve seen, we need to be able to efficiently tell whether two nodes are
    in the same component. One way to do this is to conduct a depth-first traversal
    (or breadth-first traversal) starting from the first node and checking whether
    we ever visit the second one. (Using one of these traversal strategies ensures
    that we terminate in the presence of loops.) Unfortunately, this takes a linear
    amount of time (in the size of the graph) for every pair of nodesâ€”<wbr>and depending
    on the graph and choice of node, we might do this for every node in the graph
    on every edge addition! So weâ€™d clearly like to do this better.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬æ‰€è§ï¼Œæˆ‘ä»¬éœ€è¦èƒ½å¤Ÿé«˜æ•ˆåœ°åˆ¤æ–­ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯å¦å±äºåŒä¸€ç»„ä»¶ã€‚ä¸€ç§æ–¹æ³•æ˜¯è¿›è¡Œæ·±åº¦ä¼˜å…ˆéå†ï¼ˆæˆ–å¹¿åº¦ä¼˜å…ˆéå†ï¼‰ï¼Œä»ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å¼€å§‹ï¼Œæ£€æŸ¥æˆ‘ä»¬æ˜¯å¦è®¿é—®è¿‡ç¬¬äºŒä¸ªèŠ‚ç‚¹ã€‚ï¼ˆä½¿ç”¨è¿™äº›éå†ç­–ç•¥ä¹‹ä¸€ç¡®ä¿äº†åœ¨å­˜åœ¨å¾ªç¯çš„æƒ…å†µä¸‹èƒ½å¤Ÿç»ˆæ­¢ã€‚ï¼‰ä¸å¹¸çš„æ˜¯ï¼Œè¿™éœ€è¦çº¿æ€§æ—¶é—´ï¼ˆä»¥å›¾çš„å¤§å°ä¸ºåŸºå‡†ï¼‰æ¥å¤„ç†æ¯ä¸€å¯¹èŠ‚ç‚¹â€”â€”å¹¶ä¸”æ ¹æ®å›¾å’ŒèŠ‚ç‚¹çš„é€‰æ‹©ï¼Œæˆ‘ä»¬å¯èƒ½åœ¨æ¯æ¬¡æ·»åŠ è¾¹æ—¶å¯¹å›¾ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹éƒ½è¿™æ ·åšï¼å› æ­¤ï¼Œæˆ‘ä»¬æ˜¾ç„¶å¸Œæœ›åšå¾—æ›´å¥½ã€‚
- en: 'It is helpful to reduce this problem from graph connectivity to a more general
    one: of disjoint-set structure (colloquially known as union-find for reasons that
    will soon be clear). If we think of each connected component as a set, then weâ€™re
    asking whether two nodes are in the same set. But casting it as a set membership
    problem makes it applicable in several other applications as well.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: å°†è¿™ä¸ªé—®é¢˜ä»å›¾è¿é€šæ€§é™ä½åˆ°æ›´ä¸€èˆ¬çš„é—®é¢˜æ˜¯æœ‰å¸®åŠ©çš„ï¼šå³ä¸ç›¸äº¤é›†åˆç»“æ„ï¼ˆä¿—ç§°ä¸ºå¹¶æŸ¥é›†ï¼ŒåŸå› å¾ˆå¿«å°±ä¼šæ¸…æ¥šï¼‰ã€‚å¦‚æœæˆ‘ä»¬æŠŠæ¯ä¸ªè¿é€šç»„ä»¶çœ‹ä½œä¸€ä¸ªé›†åˆï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±æ˜¯åœ¨è¯¢é—®ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯å¦å±äºåŒä¸€ä¸ªé›†åˆã€‚ä½†å°†å…¶ä½œä¸ºé›†åˆæˆå‘˜é—®é¢˜ï¼Œå®ƒä¹Ÿé€‚ç”¨äºå…¶ä»–å‡ ä¸ªåº”ç”¨ã€‚
- en: The setup is as follows. For arbitrary values, we want the ability to think
    of them as elements in a set. We are interested in two operations. One is obviously
    `union`, which merges two sets into one. The other would seem to be something
    like `is-in-same-set` that takes two elements and determines whether theyâ€™re in
    the same set. Over time, however, it has proven useful to instead define the operator
    `find` that, given an element, â€œnamesâ€ the set (more on this in a moment) that
    the element belongs to. To check whether two elements are in the same set, we
    then have to get the â€œset nameâ€ for each element, and check whether these names
    are the same. This certainly sounds more roundabout, but this means we have a
    primitive that may be useful in other contexts, and from which we can easily implement
    `is-in-same-set`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: è®¾ç½®å¦‚ä¸‹ã€‚å¯¹äºä»»æ„å€¼ï¼Œæˆ‘ä»¬å¸Œæœ›èƒ½å¤Ÿå°†å®ƒä»¬è§†ä¸ºé›†åˆä¸­çš„å…ƒç´ ã€‚æˆ‘ä»¬æ„Ÿå…´è¶£çš„ä¸¤ä¸ªæ“ä½œæ˜¯æ˜¾ç„¶çš„ `union`ï¼Œå®ƒå°†ä¸¤ä¸ªé›†åˆåˆå¹¶ä¸ºä¸€ä¸ªã€‚å¦ä¸€ä¸ªä¼¼ä¹æ˜¯ `is-in-same-set`ï¼Œå®ƒæ¥å—ä¸¤ä¸ªå…ƒç´ å¹¶ç¡®å®šå®ƒä»¬æ˜¯å¦åœ¨åŒä¸€ä¸ªé›†åˆä¸­ã€‚ç„¶è€Œï¼Œéšç€æ—¶é—´çš„æ¨ç§»ï¼Œå®šä¹‰æ“ä½œç¬¦
    `find` å·²ç»è¢«è¯æ˜æ˜¯æœ‰ç”¨çš„ï¼Œç»™å®šä¸€ä¸ªå…ƒç´ ï¼Œâ€œå‘½åâ€è¯¥å…ƒç´ æ‰€å±çš„é›†åˆï¼ˆç¨åä¼šæ›´è¯¦ç»†åœ°è¯´æ˜ï¼‰ã€‚ä¸ºäº†æ£€æŸ¥ä¸¤ä¸ªå…ƒç´ æ˜¯å¦åœ¨åŒä¸€ä¸ªé›†åˆä¸­ï¼Œæˆ‘ä»¬éšåå¿…é¡»è·å–æ¯ä¸ªå…ƒç´ çš„â€œé›†åˆåç§°â€ï¼Œå¹¶æ£€æŸ¥è¿™äº›åç§°æ˜¯å¦ç›¸åŒã€‚è¿™ç¡®å®å¬èµ·æ¥æœ‰äº›ç»•ï¼Œä½†è¿™æ„å‘³ç€æˆ‘ä»¬æœ‰ä¸€ä¸ªå¯èƒ½åœ¨å…¶ä»–ä¸Šä¸‹æ–‡ä¸­æœ‰ç”¨çš„åŸå§‹æ“ä½œï¼Œå¹¶ä¸”æˆ‘ä»¬å¯ä»¥è½»æ¾åœ°å®ç°
    `is-in-same-set`ã€‚
- en: 'Now the question is, how do we name sets? The real question we should ask is,
    what operations do we care to perform on these names? All we care about is, given
    two names, they represent the same set precisely when the names are the same.
    Therefore, we could construct a new string, or number, or something else, but
    we have another option: simply pick some element of the set to represent it, i.e.,
    to serve as its name. Thus we will associate each set element with an indicator
    of the â€œset nameâ€ for that element; if there isnâ€™t one, then its name is itself
    (the `none` case of `parent`):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨çš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬å¦‚ä½•å‘½åé›†åˆï¼Ÿæˆ‘ä»¬åº”è¯¥çœŸæ­£é—®çš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬å¯¹è¿™äº›åç§°å…³å¿ƒå“ªäº›æ“ä½œï¼Ÿæˆ‘ä»¬å”¯ä¸€å…³å¿ƒçš„æ˜¯ï¼Œç»™å®šä¸¤ä¸ªåç§°ï¼Œå®ƒä»¬ä»£è¡¨ç›¸åŒçš„é›†åˆå½“ä¸”ä»…å½“åç§°ç›¸åŒã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥æ„é€ ä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²ã€æ•°å­—æˆ–å…¶å®ƒä¸œè¥¿ï¼Œä½†æˆ‘ä»¬è¿˜æœ‰ä¸€ä¸ªé€‰æ‹©ï¼šç®€å•åœ°é€‰æ‹©é›†åˆä¸­çš„ä¸€ä¸ªå…ƒç´ æ¥ä»£è¡¨å®ƒï¼Œå³ä½œä¸ºå®ƒçš„åç§°ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°†æ¯ä¸ªé›†åˆå…ƒç´ ä¸å…¶â€œé›†åˆåç§°â€çš„æŒ‡ç¤ºç¬¦å…³è”èµ·æ¥ï¼›å¦‚æœæ²¡æœ‰ï¼Œé‚£ä¹ˆå®ƒçš„åç§°å°±æ˜¯å®ƒè‡ªå·±ï¼ˆ`parent`
    çš„ `none` æƒ…å†µï¼‰ï¼š
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will assume we have some equality predicate for checking when two elements
    are the same, which we do by comparing their value parts, ignoring their parent
    values:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªç­‰ä»·è°“è¯æ¥æ£€æŸ¥ä¸¤ä¸ªå…ƒç´ æ˜¯å¦ç›¸åŒï¼Œæˆ‘ä»¬é€šè¿‡æ¯”è¾ƒå®ƒä»¬çš„å€¼éƒ¨åˆ†æ¥å®ç°ï¼Œå¿½ç•¥å®ƒä»¬çš„çˆ¶å€¼ï¼š
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Do Now!
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹å³è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do we check only the value parts?
  id: totrans-112
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆæˆ‘ä»¬åªæ£€æŸ¥å€¼éƒ¨åˆ†ï¼Ÿ
- en: We will assume that for a given set, we always return the same representative
    element. (Otherwise, equality will fail even though we have the same set.) Thus:Weâ€™ve
    used the name `fynd` because `find` is already defined to mean something else
    in Pyret. If you donâ€™t like the misspelling, youâ€™re welcome to use a longer name
    like `find-root`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†å‡è®¾å¯¹äºç»™å®šçš„é›†åˆï¼Œæˆ‘ä»¬æ€»æ˜¯è¿”å›ç›¸åŒçš„ä»£è¡¨å…ƒç´ ã€‚ï¼ˆå¦åˆ™ï¼Œå³ä½¿æˆ‘ä»¬æœ‰ç›¸åŒçš„é›†åˆï¼Œç­‰ä»·æ€§ä¹Ÿä¼šå¤±è´¥ã€‚ï¼‰å› æ­¤ï¼šæˆ‘ä»¬ä½¿ç”¨åç§° `fynd` æ˜¯å› ä¸º `find`
    åœ¨ Pyret ä¸­å·²ç»è¢«å®šä¹‰ä¸ºå…¶ä»–å«ä¹‰ã€‚å¦‚æœä½ ä¸å–œæ¬¢è¿™ä¸ªæ‹¼å†™é”™è¯¯ï¼Œä½ å¯ä»¥ä½¿ç”¨æ›´é•¿çš„åç§°ï¼Œæ¯”å¦‚ `find-root`ã€‚
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'where `Sets` is the list of all elements:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­ `Sets` æ˜¯æ‰€æœ‰å…ƒç´ çš„åˆ—è¡¨ï¼š
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'How do we find the representative element for a set? We first find it using
    `is-same-element`; when we do, we check the elementâ€™s `parent` field. If it is
    `none`, that means this very element names its set; this can happen either because
    the element is a singleton set (weâ€™ll initialize all elements with `none`), or
    itâ€™s the name for some larger set. Either way, weâ€™re done. Otherwise, we have
    to recursively find the parent:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•æ‰¾åˆ°ä¸€ä¸ªé›†åˆçš„ä»£è¡¨å…ƒç´ ï¼Ÿæˆ‘ä»¬é¦–å…ˆä½¿ç”¨ `is-same-element` æ¥æ‰¾åˆ°å®ƒï¼›å½“æˆ‘ä»¬æ‰¾åˆ°å®ƒæ—¶ï¼Œæˆ‘ä»¬æ£€æŸ¥å…ƒç´ çš„ `parent` å­—æ®µã€‚å¦‚æœå®ƒæ˜¯
    `none`ï¼Œè¿™æ„å‘³ç€è¿™ä¸ªå…ƒç´ æœ¬èº«å‘½åäº†å®ƒçš„é›†åˆï¼›è¿™å¯èƒ½æ˜¯å› ä¸ºå…ƒç´ æ˜¯ä¸€ä¸ªå•å…ƒç´ é›†åˆï¼ˆæˆ‘ä»¬å°†æ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸º `none`ï¼‰ï¼Œæˆ–è€…å®ƒæ˜¯æŸä¸ªæ›´å¤§é›†åˆçš„åç§°ã€‚æ— è®ºå¦‚ä½•ï¼Œæˆ‘ä»¬å·²ç»å®Œæˆäº†ã€‚å¦åˆ™ï¼Œæˆ‘ä»¬å¿…é¡»é€’å½’åœ°æ‰¾åˆ°çˆ¶å…ƒç´ ï¼š
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Exercise
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why is there a recursive call in the nested `cases`?
  id: totrans-121
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆåœ¨åµŒå¥—çš„ `cases` ä¸­æœ‰é€’å½’è°ƒç”¨ï¼Ÿ
- en: 'Whatâ€™s left is to implement `union`. For this, we find the representative elements
    of the two sets weâ€™re trying to union; if they are the same, then the two sets
    are already in a union; otherwise, we have to update the data structure:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: å‰©ä¸‹çš„å°±æ˜¯å®ç° `union`ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦æ‰¾åˆ°æˆ‘ä»¬æƒ³è¦åˆå¹¶çš„ä¸¤ä¸ªé›†åˆçš„ä»£è¡¨å…ƒç´ ï¼›å¦‚æœå®ƒä»¬ç›¸åŒï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªé›†åˆå·²ç»åœ¨ä¸€ä¸ªè”åˆä¸­äº†ï¼›å¦åˆ™ï¼Œæˆ‘ä»¬å¿…é¡»æ›´æ–°æ•°æ®ç»“æ„ï¼š
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To update, we arbitrarily choose one of the set names to be the name of the
    new compound set. We then have to update the parent of the other setâ€™s name element
    to be this one:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†æ›´æ–°ï¼Œæˆ‘ä»¬ä»»æ„é€‰æ‹©ä¸€ä¸ªé›†åˆåç§°ä½œä¸ºæ–°å¤åˆé›†åˆçš„åç§°ã€‚ç„¶åæˆ‘ä»¬å¿…é¡»æ›´æ–°å¦ä¸€ä¸ªé›†åˆåç§°å…ƒç´ çš„çˆ¶å…ƒç´ ä¸ºè¿™ä¸ªåç§°ï¼š
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here are some tests to illustrate this working:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€äº›æµ‹è¯•æ¥å±•ç¤ºè¿™ä¸ªåŠŸèƒ½ï¼š
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Unfortunately, this implementation suffers from two major problems:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼Œè¿™ä¸ªå®ç°æœ‰ä¸¤ä¸ªä¸»è¦é—®é¢˜ï¼š
- en: First, because we are performing functional updates, the value of the `parent`
    reference keeps â€œchangingâ€, but these changes are not visible to older copies
    of the â€œsameâ€ value. An element from different stages of unioning has different
    parent references, even though it is arguably the same element throughout. This
    is a place where functional programming hurts.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œå› ä¸ºæˆ‘ä»¬æ­£åœ¨è¿›è¡Œå‡½æ•°å¼æ›´æ–°ï¼Œ`parent` å¼•ç”¨çš„å€¼ä¼šâ€œä¸æ–­å˜åŒ–â€ï¼Œä½†è¿™äº›å˜åŒ–å¯¹â€œç›¸åŒâ€å€¼çš„æ—§å‰¯æœ¬æ˜¯ä¸å¯è§çš„ã€‚åœ¨å¹¶é›†çš„ä¸åŒé˜¶æ®µï¼Œä¸€ä¸ªå…ƒç´ æœ‰ä¸åŒçš„çˆ¶å¼•ç”¨ï¼Œå°½ç®¡ä»ç†è®ºä¸Šè®²ï¼Œå®ƒå§‹ç»ˆæ˜¯ç›¸åŒçš„å…ƒç´ ã€‚è¿™æ˜¯å‡½æ•°å¼ç¼–ç¨‹å—æŒ«çš„åœ°æ–¹ã€‚
- en: Relatedly, the performance of this implementation is quite bad. `fynd` recursively
    traverses parents to find the setâ€™s name, but the elements traversed are not updated
    to record this new name. We certainly could update them by reconstructing the
    set afresh each time, but that complicates the implementation and, as we will
    soon see, we can do much better.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç›¸å…³åœ°ï¼Œè¿™ä¸ªå®ç°çš„æ€§èƒ½ç›¸å½“ç³Ÿç³•ã€‚`fynd` é€’å½’éå†çˆ¶èŠ‚ç‚¹ä»¥æ‰¾åˆ°é›†åˆçš„åç§°ï¼Œä½†éå†çš„å…ƒç´ å¹¶æœªæ›´æ–°ä»¥è®°å½•è¿™ä¸ªæ–°åç§°ã€‚æˆ‘ä»¬å½“ç„¶å¯ä»¥é€šè¿‡æ¯æ¬¡é‡æ–°æ„å»ºé›†åˆæ¥æ›´æ–°å®ƒä»¬ï¼Œä½†è¿™ä¼šä½¿å®ç°å˜å¾—å¤æ‚ï¼Œè€Œä¸”æ­£å¦‚æˆ‘ä»¬å¾ˆå¿«å°±ä¼šçœ‹åˆ°çš„ï¼Œæˆ‘ä»¬å¯ä»¥åšå¾—æ›´å¥½ã€‚
- en: Even worse, it may not even be correct!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: æ›´ç³Ÿç³•çš„æ˜¯ï¼Œå®ƒç”šè‡³å¯èƒ½ä¸æ­£ç¡®ï¼
- en: Exercise
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is it? Consider constructing `union`s that are not quite so skewed as above,
    and see whether you get the results you expect.
  id: totrans-134
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ˜¯å—ï¼Ÿè€ƒè™‘æ„å»ºä¸é‚£ä¹ˆå€¾æ–œçš„ `union`sï¼Œçœ‹çœ‹ä½ æ˜¯å¦èƒ½å¾—åˆ°ä½ é¢„æœŸçš„ç»“æœã€‚
- en: 'The bottom line is that pure functional programming is not a great fit with
    this problem. We need a better implementation strategy: [Union-Find](union-find.html).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: äº‹å®ä¸Šï¼Œçº¯å‡½æ•°å¼ç¼–ç¨‹å¹¶ä¸é€‚åˆè¿™ä¸ªé—®é¢˜ã€‚æˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ›´å¥½çš„å®ç°ç­–ç•¥ï¼š[å¹¶æŸ¥é›†](union-find.html)ã€‚
