<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>12.4Â Cyclic DatağŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>12.4Â Cyclic DatağŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/unified-cyclic-data.html">https://dcic-world.org/2025-08-27/unified-cyclic-data.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._.Creating_.Cyclic_.Data%29" class="toclink" data-pltdoc="x">12.4.1Â Creating Cyclic Data</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Testing_.Cyclic_.Data%29" class="toclink" data-pltdoc="x">12.4.2Â Testing Cyclic Data</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Cycles_in_.Practice%29" class="toclink" data-pltdoc="x">12.4.3Â Cycles in Practice</a></p></td></tr></table><section class="SsectionLevel4" id="section 12.4.1"><h4 class="heading">12.4.1Â <a name="(part._.Creating_.Cyclic_.Data)"/>Creating Cyclic Data<a href="#(part._.Creating_.Cyclic_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Earlier [<a href="mutating-structures.html#%28part._mult-bank-acct%29" data-pltdoc="x">Aliasing</a>], we introduced the idea of aliased
bank accounts, where multiple customers can operate the same
account. Sometimes, a bank wants to keep track of all the customers
who have access to a given account. For instance, when the account
balance runs low, it would want to notify all the customers who have
access to it.</p><p>Therefore, each account needs to maintain a list of its
customers. Because the set of owners can change over time, we make
that field mutable in Pyret:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">@dataclass
class Account:
    id: int
    balance: int
    owners: list # of Customer

@dataclass
class Customer:
    name: str
    acct: Account
</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Account:
    account(id :: Number,
      ref balance :: Number,
      ref owners :: List&lt;Customer&gt;)
end

data Customer:
    cust(name :: String,
      acct :: Account)
end</code></pre></td></tr></table><p>If you look closely, youâ€™ll see that <code data-lang="pyret" class="sourceCode">Account</code> refers to
<code data-lang="pyret" class="sourceCode">Customer</code> (specifically, a list of them) and in turn
<code data-lang="pyret" class="sourceCode">Customer</code> refers to <code data-lang="pyret" class="sourceCode">Account</code>. This could get interesting.</p><p>Previously, we could create an account with one customer as follows:
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena = Customer("Elena", Account(8404, 500))</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena = cust("Elena", account(8404, 500))</code></pre></td></tr></table><p>How do we do that now? Every <code data-lang="pyret" class="sourceCode">Account</code> requires a list of its
<code data-lang="pyret" class="sourceCode">Customer</code>s. We need to write
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena = Customer("Elena", Account(8404, 500, [_____]))</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena = cust("Elena", account(8404, 500, [list: _____]))</code></pre></td></tr></table><p>But what goes in <code data-lang="pyret" class="sourceCode">_____</code>? It needs to refer to the very customer
account that we are presently creating.</p><p>Another way to think about writing this is:
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1 = Account(8404, 500, [_____])
elena = Customer("Elena", acct1)</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1 = account(8404, 500, [list: _____])
elena = cust("Elena", acct1)</code></pre></td></tr></table><p>This hasnâ€™t solved our fundamental problemâ€”<wbr/>we still need to fill in
<code data-lang="pyret" class="sourceCode">_____</code>â€”<wbr/>but at least we now have names to refer to entities. We
would like to be able to write
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1 = Account(8404, 500, [elena])
elena = Customer("Elena", acct1)</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1 = account(8404, 500, [list: elena])
elena = cust("Elena", acct1)</code></pre></td></tr></table><p>But when we try to run this, both Python and Pyret will give us an
error. That is because they try to evaluate the right-hand-side of the
first line to create an account, whose heap address will be bound in
the directory to <code data-lang="pyret" class="sourceCode">acct1</code>. To do so, they must evaluate that
account-creation expression. In doing so, they look up the name
<code data-lang="pyret" class="sourceCode">elena</code>. However, <code data-lang="pyret" class="sourceCode">elena</code> has not yet been bound in the
directory. Therefore, they produce an error.</p><p>Observe that we canâ€™t just reverse the order of these two bindings. If
we try that, we end up with the same problem: we try to create a
customer that refers to <code data-lang="pyret" class="sourceCode">acct1</code>. But we havenâ€™t yet defined
<code data-lang="pyret" class="sourceCode">acct1</code>, producing the same error.</p><p>The problem is we are trying to create cyclic data. The two data
refer to one another. We could already sense that this might happen
from the data definitions, and now we must confront it. The problem is
that we have to create some value first, and we canâ€™t produce
either one correctly since each one depends on the other.</p><p>As you might guess, we have to compromise. We have to construct one of
the data first, and when we do so, it might not be entirely
accurate. Then we create the other, and then modify the first
one to have the correct contents.</p><p>In our case, the Pyret version makes clear what order to use in
creating the data. Nothing in a <code data-lang="pyret" class="sourceCode">Customer</code> is mutable (nor needs
to be), whereas the list of account owners is (and should be, because
the set of customers can grow). Therefore, we can write:
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1 = Account(8404, 500, [])</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1 = account(8404, 500, empty)</code></pre></td></tr></table><p>Note that at this point, this is actually accurate! There are no
owners of this account.</p><p>Now we create Elenaâ€™s account:
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena = Customer("Elena", acct1)</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena = cust("Elena", acct1)</code></pre></td></tr></table><p>At this point, our memory looks like this:For simplicity,
we will show the list of owners inside the account instead of
putting it in its own memory location(s).
</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1</code></pre><p>Â â†’Â 1001</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena</code></pre><p>Â â†’Â 1002</p></li></ul><p>Heap</p><ul><li><p>1001:Â <code data-lang="pyret" class="sourceCode">Account(8404, 500, [])</code></p></li><li><p>1002:Â <code data-lang="pyret" class="sourceCode">Customer("Elena", 1001)</code></p></li></ul><p>Now things are slightly inaccurate: the account at 1001
does have an owner, which is not yet reflected. So we
have to update it to reflect that:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1.owners = [elena]</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1!{owners: [list: elena]}</code></pre></td></tr></table><p>We can legitimately do this now because <code data-lang="pyret" class="sourceCode">elena</code> is bound in the
dictionary. Furthermore, it is bound to something useful: Elenaâ€™s
customer information. So now the values are properly set up: Elenaâ€™s
customer information refers to the account, and the account refers to
Elenaâ€™s customer information:
</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1</code></pre><p>Â â†’Â 1001</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena</code></pre><p>Â â†’Â 1002</p></li></ul><p>Heap</p><ul><li><p>1001:Â <code data-lang="pyret" class="sourceCode">Account(8404, 500, [1002])</code></p></li><li><p>1002:Â <code data-lang="pyret" class="sourceCode">Customer("Elena", 1001)</code></p></li></ul><p>This is the cycle in â€œcyclicâ€: 1001 depends on 1002
and 1002 depends on 1001.</p><p>Observe that if we introduce another customer, Jorge, who shares the same
account, we can update the account to reflect that also:
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">jorge = Customer("Jorge", acct1)</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">jorge = cust("Jorge", acct1)</code></pre></td></tr></table><p>Again, the information in <code data-lang="pyret" class="sourceCode">acct1</code> is inaccurate because it does
not reflect the new owner. We can modify it in a similar way:
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1.owners = acct1.owners + [jorge]</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1!{owners: acct1!owners + [list: jorge]}</code></pre></td></tr></table><p>So now our memory would look like this:
</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1</code></pre><p>Â â†’Â 1001</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena</code></pre><p>Â â†’Â 1002</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">jorge</code></pre><p>Â â†’Â 1003</p></li></ul><p>Heap</p><ul><li><p>1001:Â <code data-lang="pyret" class="sourceCode">Account(8404, 500, [1002, 1003])</code></p></li><li><p>1002:Â <code data-lang="pyret" class="sourceCode">Customer("Elena", 1001)</code></p></li><li><p>1003:Â <code data-lang="pyret" class="sourceCode">Customer("Jorge", 1001)</code></p></li></ul><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>We wrote slightly different code when adding Jorgeâ€™s account than when
adding Elenaâ€™s account. Is one better than the other?</p></blockquote></blockquote><p>The code for Elenaâ€™s addition ignored whatever owners there previously
were. That is, it would only work correctly in a setting where there
were no other owners. The code for Jorgeâ€™s addition takes into account
all the previous owners. Therefore, Elenaâ€™s code was perfectly fine
for illustrating the simple first case, but Jorgeâ€™s code is more
general in that it will work in all settings (including when the prior
list of owners is empty).</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a function that takes care of adding a customer to an account.</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 12.4.2"><h4 class="heading">12.4.2Â <a name="(part._.Testing_.Cyclic_.Data)"/>Testing Cyclic Data<a href="#(part._.Testing_.Cyclic_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>When you want to write a test involving circular data, you canâ€™t write
out the circular data manually.  For example, imagine that we wanted
to write out <code data-lang="pyret" class="sourceCode">acct1</code> from earlier:
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">assert(acct1 = Account(8404, 500, [Customer("Elena", Account(8404, 500, â€¦)]))</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  acct1 is
    account(8404, 500, [list: cust("Elena", account(8404, 500, â€¦))])
end</code></pre></td></tr></table><p>However, because of the circularity, we canâ€™t finish writing down the
data. We canâ€™t just leave part of it unspecified with <code data-lang="pyret" class="sourceCode">â€¦</code>.</p><p>This leaves us with two choices:</p><p>You have two options: write tests in terms of the names of data,
or write tests on the components of the data.</p><p>Hereâ€™s an example that illustrates both. After setting up the account,
we might want to check that the owner of the new account is the new
customer:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">assert(new_acct.owner is new_cust)</code></pre><p>Here, rather than write out the <code data-lang="text/x-python" class="sourceCode">Customer</code> explicitly, we use the name
of the existing item in the directory. This doesnâ€™t require you to write
ellipses. We also focused on just the <code data-lang="text/x-python" class="sourceCode">owner</code> component, as a part of
the <code data-lang="text/x-python" class="sourceCode">Account</code> value that we expected to change.</p></section><section class="SsectionLevel4" id="section 12.4.3"><h4 class="heading">12.4.3Â <a name="(part._.Cycles_in_.Practice)"/>Cycles in Practice<a href="#(part._.Cycles_in_.Practice)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Cyclic data show up in many settings in real programs. Whenever two
data are interrelated, and we have good reason to want to get from
either one to the other, they have the potential to have references to
each other, which can lead to cycles. Sometimes the connection can be
to provide updates, as above; other times it can simply be for
navigational convenience.</p><p>Consider the Document Object Model (DOM), which is the data structure
that represents every Web page in a Web browser. Programmers usually
think of the DOM hierarchically, as a tree, because every note refers
to all the nodes that constitute it: e.g., a page has references to
each of its paragraphs, a list has references to each list item, and
so forth. However, every one of these elements also has a reference to
its parent. This way, a program can conveniently traverse â€œdownwardâ€
or â€œupwardâ€.</p><p>Programming with cyclic data introduces complications. If we traverse
the data naÃ¯vely, we would go into an infinite loop. Rather, we have
to keep track of the data we have previously visited, and make sure we
donâ€™t visit them again (see <a href="size-of-dag.html" data-pltdoc="x">The Size of a DAG</a>). Indeed, cyclic
data are graphs [<a href="part_graphs.html" data-pltdoc="x">Graphs</a>], so issues in processing graphs
become relevant here.</p><p>One interesting question that programming languages face is, how do
you print cyclic data? For instance, what happens if the
programmer writes
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1</code></pre><p>? To print the account we must print its owners; to print each owner,
we must print their account; to print that accountâ€¦</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Try it out in both Python and Pyret!</p></blockquote></blockquote><p>Different programming languages handle this problem in different
ways. Some languages will go into an infinite loop trying to print
cyclic data. Both Python and Pyret handle this more
intelligently. Determining even whether a datum is cyclic is an
interesting question, which we take up in <a href="cycle-detection.html" data-pltdoc="x">Detecting Cycles</a>.</p></section>&#13;
<h4 class="heading">12.4.1Â <a name="(part._.Creating_.Cyclic_.Data)"/>Creating Cyclic Data<a href="#(part._.Creating_.Cyclic_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Earlier [<a href="mutating-structures.html#%28part._mult-bank-acct%29" data-pltdoc="x">Aliasing</a>], we introduced the idea of aliased
bank accounts, where multiple customers can operate the same
account. Sometimes, a bank wants to keep track of all the customers
who have access to a given account. For instance, when the account
balance runs low, it would want to notify all the customers who have
access to it.</p><p>Therefore, each account needs to maintain a list of its
customers. Because the set of owners can change over time, we make
that field mutable in Pyret:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">@dataclass
class Account:
    id: int
    balance: int
    owners: list # of Customer

@dataclass
class Customer:
    name: str
    acct: Account
</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Account:
    account(id :: Number,
      ref balance :: Number,
      ref owners :: List&lt;Customer&gt;)
end

data Customer:
    cust(name :: String,
      acct :: Account)
end</code></pre></td></tr></table><p>If you look closely, youâ€™ll see that <code data-lang="pyret" class="sourceCode">Account</code> refers to
<code data-lang="pyret" class="sourceCode">Customer</code> (specifically, a list of them) and in turn
<code data-lang="pyret" class="sourceCode">Customer</code> refers to <code data-lang="pyret" class="sourceCode">Account</code>. This could get interesting.</p><p>Previously, we could create an account with one customer as follows:
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena = Customer("Elena", Account(8404, 500))</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena = cust("Elena", account(8404, 500))</code></pre></td></tr></table><p>How do we do that now? Every <code data-lang="pyret" class="sourceCode">Account</code> requires a list of its
<code data-lang="pyret" class="sourceCode">Customer</code>s. We need to write
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena = Customer("Elena", Account(8404, 500, [_____]))</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena = cust("Elena", account(8404, 500, [list: _____]))</code></pre></td></tr></table><p>But what goes in <code data-lang="pyret" class="sourceCode">_____</code>? It needs to refer to the very customer
account that we are presently creating.</p><p>Another way to think about writing this is:
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1 = Account(8404, 500, [_____])
elena = Customer("Elena", acct1)</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1 = account(8404, 500, [list: _____])
elena = cust("Elena", acct1)</code></pre></td></tr></table><p>This hasnâ€™t solved our fundamental problemâ€”<wbr/>we still need to fill in
<code data-lang="pyret" class="sourceCode">_____</code>â€”<wbr/>but at least we now have names to refer to entities. We
would like to be able to write
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1 = Account(8404, 500, [elena])
elena = Customer("Elena", acct1)</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1 = account(8404, 500, [list: elena])
elena = cust("Elena", acct1)</code></pre></td></tr></table><p>But when we try to run this, both Python and Pyret will give us an
error. That is because they try to evaluate the right-hand-side of the
first line to create an account, whose heap address will be bound in
the directory to <code data-lang="pyret" class="sourceCode">acct1</code>. To do so, they must evaluate that
account-creation expression. In doing so, they look up the name
<code data-lang="pyret" class="sourceCode">elena</code>. However, <code data-lang="pyret" class="sourceCode">elena</code> has not yet been bound in the
directory. Therefore, they produce an error.</p><p>Observe that we canâ€™t just reverse the order of these two bindings. If
we try that, we end up with the same problem: we try to create a
customer that refers to <code data-lang="pyret" class="sourceCode">acct1</code>. But we havenâ€™t yet defined
<code data-lang="pyret" class="sourceCode">acct1</code>, producing the same error.</p><p>The problem is we are trying to create cyclic data. The two data
refer to one another. We could already sense that this might happen
from the data definitions, and now we must confront it. The problem is
that we have to create some value first, and we canâ€™t produce
either one correctly since each one depends on the other.</p><p>As you might guess, we have to compromise. We have to construct one of
the data first, and when we do so, it might not be entirely
accurate. Then we create the other, and then modify the first
one to have the correct contents.</p><p>In our case, the Pyret version makes clear what order to use in
creating the data. Nothing in a <code data-lang="pyret" class="sourceCode">Customer</code> is mutable (nor needs
to be), whereas the list of account owners is (and should be, because
the set of customers can grow). Therefore, we can write:
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1 = Account(8404, 500, [])</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1 = account(8404, 500, empty)</code></pre></td></tr></table><p>Note that at this point, this is actually accurate! There are no
owners of this account.</p><p>Now we create Elenaâ€™s account:
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena = Customer("Elena", acct1)</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena = cust("Elena", acct1)</code></pre></td></tr></table><p>At this point, our memory looks like this:For simplicity,
we will show the list of owners inside the account instead of
putting it in its own memory location(s).
</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1</code></pre><p>Â â†’Â 1001</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena</code></pre><p>Â â†’Â 1002</p></li></ul><p>Heap</p><ul><li><p>1001:Â <code data-lang="pyret" class="sourceCode">Account(8404, 500, [])</code></p></li><li><p>1002:Â <code data-lang="pyret" class="sourceCode">Customer("Elena", 1001)</code></p></li></ul><p>Now things are slightly inaccurate: the account at 1001
does have an owner, which is not yet reflected. So we
have to update it to reflect that:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1.owners = [elena]</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1!{owners: [list: elena]}</code></pre></td></tr></table><p>We can legitimately do this now because <code data-lang="pyret" class="sourceCode">elena</code> is bound in the
dictionary. Furthermore, it is bound to something useful: Elenaâ€™s
customer information. So now the values are properly set up: Elenaâ€™s
customer information refers to the account, and the account refers to
Elenaâ€™s customer information:
</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1</code></pre><p>Â â†’Â 1001</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena</code></pre><p>Â â†’Â 1002</p></li></ul><p>Heap</p><ul><li><p>1001:Â <code data-lang="pyret" class="sourceCode">Account(8404, 500, [1002])</code></p></li><li><p>1002:Â <code data-lang="pyret" class="sourceCode">Customer("Elena", 1001)</code></p></li></ul><p>This is the cycle in â€œcyclicâ€: 1001 depends on 1002
and 1002 depends on 1001.</p><p>Observe that if we introduce another customer, Jorge, who shares the same
account, we can update the account to reflect that also:
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">jorge = Customer("Jorge", acct1)</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">jorge = cust("Jorge", acct1)</code></pre></td></tr></table><p>Again, the information in <code data-lang="pyret" class="sourceCode">acct1</code> is inaccurate because it does
not reflect the new owner. We can modify it in a similar way:
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1.owners = acct1.owners + [jorge]</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1!{owners: acct1!owners + [list: jorge]}</code></pre></td></tr></table><p>So now our memory would look like this:
</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1</code></pre><p>Â â†’Â 1001</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena</code></pre><p>Â â†’Â 1002</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">jorge</code></pre><p>Â â†’Â 1003</p></li></ul><p>Heap</p><ul><li><p>1001:Â <code data-lang="pyret" class="sourceCode">Account(8404, 500, [1002, 1003])</code></p></li><li><p>1002:Â <code data-lang="pyret" class="sourceCode">Customer("Elena", 1001)</code></p></li><li><p>1003:Â <code data-lang="pyret" class="sourceCode">Customer("Jorge", 1001)</code></p></li></ul><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>We wrote slightly different code when adding Jorgeâ€™s account than when
adding Elenaâ€™s account. Is one better than the other?</p></blockquote></blockquote><p>The code for Elenaâ€™s addition ignored whatever owners there previously
were. That is, it would only work correctly in a setting where there
were no other owners. The code for Jorgeâ€™s addition takes into account
all the previous owners. Therefore, Elenaâ€™s code was perfectly fine
for illustrating the simple first case, but Jorgeâ€™s code is more
general in that it will work in all settings (including when the prior
list of owners is empty).</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a function that takes care of adding a customer to an account.</p></blockquote></blockquote>&#13;
<h4 class="heading">12.4.2Â <a name="(part._.Testing_.Cyclic_.Data)"/>Testing Cyclic Data<a href="#(part._.Testing_.Cyclic_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>When you want to write a test involving circular data, you canâ€™t write
out the circular data manually.  For example, imagine that we wanted
to write out <code data-lang="pyret" class="sourceCode">acct1</code> from earlier:
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">assert(acct1 = Account(8404, 500, [Customer("Elena", Account(8404, 500, â€¦)]))</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  acct1 is
    account(8404, 500, [list: cust("Elena", account(8404, 500, â€¦))])
end</code></pre></td></tr></table><p>However, because of the circularity, we canâ€™t finish writing down the
data. We canâ€™t just leave part of it unspecified with <code data-lang="pyret" class="sourceCode">â€¦</code>.</p><p>This leaves us with two choices:</p><p>You have two options: write tests in terms of the names of data,
or write tests on the components of the data.</p><p>Hereâ€™s an example that illustrates both. After setting up the account,
we might want to check that the owner of the new account is the new
customer:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">assert(new_acct.owner is new_cust)</code></pre><p>Here, rather than write out the <code data-lang="text/x-python" class="sourceCode">Customer</code> explicitly, we use the name
of the existing item in the directory. This doesnâ€™t require you to write
ellipses. We also focused on just the <code data-lang="text/x-python" class="sourceCode">owner</code> component, as a part of
the <code data-lang="text/x-python" class="sourceCode">Account</code> value that we expected to change.</p>&#13;
<h4 class="heading">12.4.3Â <a name="(part._.Cycles_in_.Practice)"/>Cycles in Practice<a href="#(part._.Cycles_in_.Practice)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Cyclic data show up in many settings in real programs. Whenever two
data are interrelated, and we have good reason to want to get from
either one to the other, they have the potential to have references to
each other, which can lead to cycles. Sometimes the connection can be
to provide updates, as above; other times it can simply be for
navigational convenience.</p><p>Consider the Document Object Model (DOM), which is the data structure
that represents every Web page in a Web browser. Programmers usually
think of the DOM hierarchically, as a tree, because every note refers
to all the nodes that constitute it: e.g., a page has references to
each of its paragraphs, a list has references to each list item, and
so forth. However, every one of these elements also has a reference to
its parent. This way, a program can conveniently traverse â€œdownwardâ€
or â€œupwardâ€.</p><p>Programming with cyclic data introduces complications. If we traverse
the data naÃ¯vely, we would go into an infinite loop. Rather, we have
to keep track of the data we have previously visited, and make sure we
donâ€™t visit them again (see <a href="size-of-dag.html" data-pltdoc="x">The Size of a DAG</a>). Indeed, cyclic
data are graphs [<a href="part_graphs.html" data-pltdoc="x">Graphs</a>], so issues in processing graphs
become relevant here.</p><p>One interesting question that programming languages face is, how do
you print cyclic data? For instance, what happens if the
programmer writes
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1</code></pre><p>? To print the account we must print its owners; to print each owner,
we must print their account; to print that accountâ€¦</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Try it out in both Python and Pyret!</p></blockquote></blockquote><p>Different programming languages handle this problem in different
ways. Some languages will go into an infinite loop trying to print
cyclic data. Both Python and Pyret handle this more
intelligently. Determining even whether a datum is cyclic is an
interesting question, which we take up in <a href="cycle-detection.html" data-pltdoc="x">Detecting Cycles</a>.</p>    
</body>
</html>