<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>12.4Â Cyclic DatağŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>12.4Â Cyclic DatağŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/unified-cyclic-data.html">https://dcic-world.org/2025-08-27/unified-cyclic-data.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Creating_.Cyclic_.Data%29" class="toclink" data-pltdoc="x">12.4.1<span class="hspace">Â </span>Creating Cyclic Data</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Testing_.Cyclic_.Data%29" class="toclink" data-pltdoc="x">12.4.2<span class="hspace">Â </span>Testing Cyclic Data</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Cycles_in_.Practice%29" class="toclink" data-pltdoc="x">12.4.3<span class="hspace">Â </span>Cycles in Practice</a></p></td></tr></table><section class="SsectionLevel4" id="section 12.4.1"><h4 class="heading">12.4.1<span class="stt">Â </span><a name="(part._.Creating_.Cyclic_.Data)"/>Creating Cyclic Data<span class="button-group"><a href="#(part._.Creating_.Cyclic_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Earlier [<a href="mutating-structures.html#%28part._mult-bank-acct%29" data-pltdoc="x">Aliasing</a>], we introduced the idea of aliased
bank accounts, where multiple customers can operate the same
account. Sometimes, a bank wants to keep track of all the customers
who have access to a given account. For instance, when the account
balance runs low, it would want to notify all the customers who have
access to it.</p><p/><div class="SIntrapara">Therefore, each account needs to maintain a list of its
customers. Because the set of owners can change over time, we make
that field mutable in Pyret:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p><span style="font-weight: bold">Python</span></p></td><td><p><span style="font-weight: bold">Pyret</span></p></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">@dataclass
class Account:
    id: int
    balance: int
    owners: list # of Customer

@dataclass
class Customer:
    name: str
    acct: Account
</code></pre></div></div></td><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Account:
    account(id :: Number,
      ref balance :: Number,
      ref owners :: List&lt;Customer&gt;)
end

data Customer:
    cust(name :: String,
      acct :: Account)
end</code></pre></div></div></td></tr></table></div><div class="SIntrapara">If you look closely, youâ€™ll see that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account</code></span> refers to
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer</code></span> (specifically, a list of them) and in turn
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer</code></span> refers to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account</code></span>. This could get interesting.</div><p/><div class="SIntrapara">Previously, we could create an account with one customer as follows:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p><span style="font-weight: bold">Python</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena = Customer("Elena", Account(8404, 500))</code></pre></div></div></td></tr><tr><td><p><span style="font-weight: bold">Pyret</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena = cust("Elena", account(8404, 500))</code></pre></div></div></td></tr></table></div><div class="SIntrapara">How do we do that now? Every <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account</code></span> requires a list of its
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer</code></span>s. We need to write
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p><span style="font-weight: bold">Python</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena = Customer("Elena", Account(8404, 500, [_____]))</code></pre></div></div></td></tr><tr><td><p><span style="font-weight: bold">Pyret</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena = cust("Elena", account(8404, 500, [list: _____]))</code></pre></div></div></td></tr></table></div><div class="SIntrapara">But what goes in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">_____</code></span>? It needs to refer to the very customer
account that we are presently creating.</div><p/><div class="SIntrapara">Another way to think about writing this is:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p><span style="font-weight: bold">Python</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1 = Account(8404, 500, [_____])
elena = Customer("Elena", acct1)</code></pre></div></div></td></tr><tr><td><p><span style="font-weight: bold">Pyret</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1 = account(8404, 500, [list: _____])
elena = cust("Elena", acct1)</code></pre></div></div></td></tr></table></div><div class="SIntrapara">This hasnâ€™t solved our fundamental problemâ€”<wbr/>we still need to fill in
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">_____</code></span>â€”<wbr/>but at least we now have names to refer to entities. We
would like to be able to write
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p><span style="font-weight: bold">Python</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1 = Account(8404, 500, [elena])
elena = Customer("Elena", acct1)</code></pre></div></div></td></tr><tr><td><p><span style="font-weight: bold">Pyret</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1 = account(8404, 500, [list: elena])
elena = cust("Elena", acct1)</code></pre></div></div></td></tr></table></div><div class="SIntrapara">But when we try to run this, both Python and Pyret will give us an
error. That is because they try to evaluate the right-hand-side of the
first line to create an account, whose heap address will be bound in
the directory to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1</code></span>. To do so, they must evaluate that
account-creation expression. In doing so, they look up the name
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena</code></span>. However, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena</code></span> has not yet been bound in the
directory. Therefore, they produce an error.</div><p>Observe that we canâ€™t just reverse the order of these two bindings. If
we try that, we end up with the same problem: we try to create a
customer that refers to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1</code></span>. But we havenâ€™t yet defined
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1</code></span>, producing the same error.</p><p>The problem is we are trying to create <span style="font-style: italic">cyclic</span> data. The two data
refer to one another. We could already sense that this might happen
from the data definitions, and now we must confront it. The problem is
that we have to create <span class="emph">some</span> value first, and we canâ€™t produce
either one correctly since each one depends on the other.</p><p>As you might guess, we have to compromise. We have to construct one of
the data first, and when we do so, it might not be entirely
accurate. Then we create the other, and then <span class="emph">modify</span> the first
one to have the correct contents.</p><p/><div class="SIntrapara">In our case, the Pyret version makes clear what order to use in
creating the data. Nothing in a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer</code></span> is mutable (nor needs
to be), whereas the list of account owners is (and should be, because
the set of customers can grow). Therefore, we can write:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p><span style="font-weight: bold">Python</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1 = Account(8404, 500, [])</code></pre></div></div></td></tr><tr><td><p><span style="font-weight: bold">Pyret</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1 = account(8404, 500, empty)</code></pre></div></div></td></tr></table></div><div class="SIntrapara">Note that at this point, this is actually accurate! There are no
owners of this account.</div><p/><div class="SIntrapara">Now we create Elenaâ€™s account:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p><span style="font-weight: bold">Python</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena = Customer("Elena", acct1)</code></pre></div></div></td></tr><tr><td><p><span style="font-weight: bold">Pyret</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena = cust("Elena", acct1)</code></pre></div></div></td></tr></table></div><div class="SIntrapara">At this point, our memory looks like this:<span class="refelem"><span class="refcolumn"><span class="refcontent">For simplicity,
we will show the list of owners inside the account instead of
putting it in its own memory location(s).</span></span></span>
</div><div class="SIntrapara"><div class="HeapExpr"><div class="EnvPart"><p>Directory</p><ul><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1001</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1002</span></div></li></ul></div><div class="HeapPart"><p>Heap</p><ul><li><p><span class="heapref source">1001</span>:<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account(8404, 500, [])</code></span></p></li><li><p><span class="heapref source">1002</span>:<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer("Elena", <span class="heapref sink">1001</span>)</code></span></p></li></ul></div><p/><div class="clear"/></div></div><p/><div class="SIntrapara">Now things are slightly inaccurate: the account at <span class="heapref sink">1001</span>
does have an owner, which is not yet reflected. So we
have to update it to reflect that:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p><span style="font-weight: bold">Python</span></p></td><td><p><span style="font-weight: bold">Pyret</span></p></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1.owners = [elena]</code></pre></div></div></td><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1!{owners: [list: elena]}</code></pre></div></div></td></tr></table></div><div class="SIntrapara">We can legitimately do this now because <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena</code></span> is bound in the
dictionary. Furthermore, it is bound to something useful: Elenaâ€™s
customer information. So now the values are properly set up: Elenaâ€™s
customer information refers to the account, and the account refers to
Elenaâ€™s customer information:
</div><div class="SIntrapara"><div class="HeapExpr"><div class="EnvPart"><p>Directory</p><ul><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1001</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1002</span></div></li></ul></div><div class="HeapPart"><p>Heap</p><ul><li><p><span class="heapref source">1001</span>:<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account(8404, 500, [<span class="heapref sink">1002</span>])</code></span></p></li><li><p><span class="heapref source">1002</span>:<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer("Elena", <span class="heapref sink">1001</span>)</code></span></p></li></ul></div><p/><div class="clear"/></div></div><div class="SIntrapara">This is the cycle in â€œcyclicâ€: <span class="heapref sink">1001</span> depends on <span class="heapref sink">1002</span>
and <span class="heapref sink">1002</span> depends on <span class="heapref sink">1001</span>.</div><p/><div class="SIntrapara">Observe that if we introduce another customer, Jorge, who shares the same
account, we can update the account to reflect that also:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p><span style="font-weight: bold">Python</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">jorge = Customer("Jorge", acct1)</code></pre></div></div></td></tr><tr><td><p><span style="font-weight: bold">Pyret</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">jorge = cust("Jorge", acct1)</code></pre></div></div></td></tr></table></div><div class="SIntrapara">Again, the information in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1</code></span> is inaccurate because it does
not reflect the new owner. We can modify it in a similar way:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p><span style="font-weight: bold">Python</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1.owners = acct1.owners + [jorge]</code></pre></div></div></td></tr><tr><td><p><span style="font-weight: bold">Pyret</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1!{owners: acct1!owners + [list: jorge]}</code></pre></div></div></td></tr></table></div><div class="SIntrapara">So now our memory would look like this:
</div><div class="SIntrapara"><div class="HeapExpr"><div class="EnvPart"><p>Directory</p><ul><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1001</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1002</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">jorge</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1003</span></div></li></ul></div><div class="HeapPart"><p>Heap</p><ul><li><p><span class="heapref source">1001</span>:<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account(8404, 500, [<span class="heapref sink">1002</span>, <span class="heapref sink">1003</span>])</code></span></p></li><li><p><span class="heapref source">1002</span>:<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer("Elena", <span class="heapref sink">1001</span>)</code></span></p></li><li><p><span class="heapref source">1003</span>:<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer("Jorge", <span class="heapref sink">1001</span>)</code></span></p></li></ul></div><p/><div class="clear"/></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>We wrote slightly different code when adding Jorgeâ€™s account than when
adding Elenaâ€™s account. Is one better than the other?</p></blockquote></blockquote><p>The code for Elenaâ€™s addition ignored whatever owners there previously
were. That is, it would only work correctly in a setting where there
were no other owners. The code for Jorgeâ€™s addition takes into account
all the previous owners. Therefore, Elenaâ€™s code was perfectly fine
for illustrating the simple first case, but Jorgeâ€™s code is more
general in that it will work in all settings (including when the prior
list of owners is empty).</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a function that takes care of adding a customer to an account.</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 12.4.2"><h4 class="heading">12.4.2<span class="stt">Â </span><a name="(part._.Testing_.Cyclic_.Data)"/>Testing Cyclic Data<span class="button-group"><a href="#(part._.Testing_.Cyclic_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">When you want to write a test involving circular data, you canâ€™t write
out the circular data manually.  For example, imagine that we wanted
to write out <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1</code></span> from earlier:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p><span style="font-weight: bold">Python</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">assert(acct1 = Account(8404, 500, [Customer("Elena", Account(8404, 500, â€¦)]))</code></pre></div></div></td></tr><tr><td><p><span style="font-weight: bold">Pyret</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  acct1 is
    account(8404, 500, [list: cust("Elena", account(8404, 500, â€¦))])
end</code></pre></div></div></td></tr></table></div><div class="SIntrapara">However, because of the circularity, we canâ€™t finish writing down the
data. We canâ€™t just leave part of it unspecified with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">â€¦</code></span>.</div><p>This leaves us with two choices:</p><p>You have two options: write tests in terms of the names of data,
or write tests on the components of the data.</p><p>Hereâ€™s an example that illustrates both. After setting up the account,
we might want to check that the owner of the new account is the new
customer:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">assert(new_acct.owner is new_cust)</code></pre></div></div><p>Here, rather than write out the <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Customer</code></span> explicitly, we use the name
of the existing item in the directory. This doesnâ€™t require you to write
ellipses. We also focused on just the <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">owner</code></span> component, as a part of
the <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account</code></span> value that we expected to change.</p></section><section class="SsectionLevel4" id="section 12.4.3"><h4 class="heading">12.4.3<span class="stt">Â </span><a name="(part._.Cycles_in_.Practice)"/>Cycles in Practice<span class="button-group"><a href="#(part._.Cycles_in_.Practice)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Cyclic data show up in many settings in real programs. Whenever two
data are interrelated, and we have good reason to want to get from
either one to the other, they have the potential to have references to
each other, which can lead to cycles. Sometimes the connection can be
to provide updates, as above; other times it can simply be for
navigational convenience.</p><p>Consider the Document Object Model (<span class="Smaller">DOM</span>), which is the data structure
that represents every Web page in a Web browser. Programmers usually
think of the <span class="Smaller">DOM</span> hierarchically, as a tree, because every note refers
to all the nodes that constitute it: e.g., a page has references to
each of its paragraphs, a list has references to each list item, and
so forth. However, every one of these elements also has a reference to
its parent. This way, a program can conveniently traverse â€œdownwardâ€
or â€œupwardâ€.</p><p>Programming with cyclic data introduces complications. If we traverse
the data naÃ¯vely, we would go into an infinite loop. Rather, we have
to keep track of the data we have previously visited, and make sure we
donâ€™t visit them again (see <a href="size-of-dag.html" data-pltdoc="x">The Size of a <span class="Smaller">DAG</span></a>). Indeed, cyclic
data are graphs [<a href="part_graphs.html" data-pltdoc="x">Graphs</a>], so issues in processing graphs
become relevant here.</p><p/><div class="SIntrapara">One interesting question that programming languages face is, how do
you <span class="emph">print</span> cyclic data? For instance, what happens if the
programmer writes
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1</code></pre></div></div></div><div class="SIntrapara">? To print the account we must print its owners; to print each owner,
we must print their account; to print that accountâ€¦</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Try it out in both Python and Pyret!</p></blockquote></blockquote><p>Different programming languages handle this problem in different
ways. Some languages will go into an infinite loop trying to print
cyclic data. Both Python and Pyret handle this more
intelligently. Determining even <span class="emph">whether</span> a datum is cyclic is an
interesting question, which we take up in <a href="cycle-detection.html" data-pltdoc="x">Detecting Cycles</a>.</p></section>&#13;
<h4 class="heading">12.4.1<span class="stt">Â </span><a name="(part._.Creating_.Cyclic_.Data)"/>Creating Cyclic Data<span class="button-group"><a href="#(part._.Creating_.Cyclic_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Earlier [<a href="mutating-structures.html#%28part._mult-bank-acct%29" data-pltdoc="x">Aliasing</a>], we introduced the idea of aliased
bank accounts, where multiple customers can operate the same
account. Sometimes, a bank wants to keep track of all the customers
who have access to a given account. For instance, when the account
balance runs low, it would want to notify all the customers who have
access to it.</p><p/><div class="SIntrapara">Therefore, each account needs to maintain a list of its
customers. Because the set of owners can change over time, we make
that field mutable in Pyret:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p><span style="font-weight: bold">Python</span></p></td><td><p><span style="font-weight: bold">Pyret</span></p></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">@dataclass
class Account:
    id: int
    balance: int
    owners: list # of Customer

@dataclass
class Customer:
    name: str
    acct: Account
</code></pre></div></div></td><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Account:
    account(id :: Number,
      ref balance :: Number,
      ref owners :: List&lt;Customer&gt;)
end

data Customer:
    cust(name :: String,
      acct :: Account)
end</code></pre></div></div></td></tr></table></div><div class="SIntrapara">If you look closely, youâ€™ll see that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account</code></span> refers to
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer</code></span> (specifically, a list of them) and in turn
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer</code></span> refers to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account</code></span>. This could get interesting.</div><p/><div class="SIntrapara">Previously, we could create an account with one customer as follows:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p><span style="font-weight: bold">Python</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena = Customer("Elena", Account(8404, 500))</code></pre></div></div></td></tr><tr><td><p><span style="font-weight: bold">Pyret</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena = cust("Elena", account(8404, 500))</code></pre></div></div></td></tr></table></div><div class="SIntrapara">How do we do that now? Every <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account</code></span> requires a list of its
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer</code></span>s. We need to write
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p><span style="font-weight: bold">Python</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena = Customer("Elena", Account(8404, 500, [_____]))</code></pre></div></div></td></tr><tr><td><p><span style="font-weight: bold">Pyret</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena = cust("Elena", account(8404, 500, [list: _____]))</code></pre></div></div></td></tr></table></div><div class="SIntrapara">But what goes in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">_____</code></span>? It needs to refer to the very customer
account that we are presently creating.</div><p/><div class="SIntrapara">Another way to think about writing this is:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p><span style="font-weight: bold">Python</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1 = Account(8404, 500, [_____])
elena = Customer("Elena", acct1)</code></pre></div></div></td></tr><tr><td><p><span style="font-weight: bold">Pyret</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1 = account(8404, 500, [list: _____])
elena = cust("Elena", acct1)</code></pre></div></div></td></tr></table></div><div class="SIntrapara">This hasnâ€™t solved our fundamental problemâ€”<wbr/>we still need to fill in
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">_____</code></span>â€”<wbr/>but at least we now have names to refer to entities. We
would like to be able to write
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p><span style="font-weight: bold">Python</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1 = Account(8404, 500, [elena])
elena = Customer("Elena", acct1)</code></pre></div></div></td></tr><tr><td><p><span style="font-weight: bold">Pyret</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1 = account(8404, 500, [list: elena])
elena = cust("Elena", acct1)</code></pre></div></div></td></tr></table></div><div class="SIntrapara">But when we try to run this, both Python and Pyret will give us an
error. That is because they try to evaluate the right-hand-side of the
first line to create an account, whose heap address will be bound in
the directory to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1</code></span>. To do so, they must evaluate that
account-creation expression. In doing so, they look up the name
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena</code></span>. However, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena</code></span> has not yet been bound in the
directory. Therefore, they produce an error.</div><p>Observe that we canâ€™t just reverse the order of these two bindings. If
we try that, we end up with the same problem: we try to create a
customer that refers to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1</code></span>. But we havenâ€™t yet defined
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1</code></span>, producing the same error.</p><p>The problem is we are trying to create <span style="font-style: italic">cyclic</span> data. The two data
refer to one another. We could already sense that this might happen
from the data definitions, and now we must confront it. The problem is
that we have to create <span class="emph">some</span> value first, and we canâ€™t produce
either one correctly since each one depends on the other.</p><p>As you might guess, we have to compromise. We have to construct one of
the data first, and when we do so, it might not be entirely
accurate. Then we create the other, and then <span class="emph">modify</span> the first
one to have the correct contents.</p><p/><div class="SIntrapara">In our case, the Pyret version makes clear what order to use in
creating the data. Nothing in a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer</code></span> is mutable (nor needs
to be), whereas the list of account owners is (and should be, because
the set of customers can grow). Therefore, we can write:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p><span style="font-weight: bold">Python</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1 = Account(8404, 500, [])</code></pre></div></div></td></tr><tr><td><p><span style="font-weight: bold">Pyret</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1 = account(8404, 500, empty)</code></pre></div></div></td></tr></table></div><div class="SIntrapara">Note that at this point, this is actually accurate! There are no
owners of this account.</div><p/><div class="SIntrapara">Now we create Elenaâ€™s account:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p><span style="font-weight: bold">Python</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena = Customer("Elena", acct1)</code></pre></div></div></td></tr><tr><td><p><span style="font-weight: bold">Pyret</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena = cust("Elena", acct1)</code></pre></div></div></td></tr></table></div><div class="SIntrapara">At this point, our memory looks like this:<span class="refelem"><span class="refcolumn"><span class="refcontent">For simplicity,
we will show the list of owners inside the account instead of
putting it in its own memory location(s).</span></span></span>
</div><div class="SIntrapara"><div class="HeapExpr"><div class="EnvPart"><p>Directory</p><ul><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1001</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1002</span></div></li></ul></div><div class="HeapPart"><p>Heap</p><ul><li><p><span class="heapref source">1001</span>:<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account(8404, 500, [])</code></span></p></li><li><p><span class="heapref source">1002</span>:<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer("Elena", <span class="heapref sink">1001</span>)</code></span></p></li></ul></div><p/><div class="clear"/></div></div><p/><div class="SIntrapara">Now things are slightly inaccurate: the account at <span class="heapref sink">1001</span>
does have an owner, which is not yet reflected. So we
have to update it to reflect that:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p><span style="font-weight: bold">Python</span></p></td><td><p><span style="font-weight: bold">Pyret</span></p></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1.owners = [elena]</code></pre></div></div></td><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1!{owners: [list: elena]}</code></pre></div></div></td></tr></table></div><div class="SIntrapara">We can legitimately do this now because <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena</code></span> is bound in the
dictionary. Furthermore, it is bound to something useful: Elenaâ€™s
customer information. So now the values are properly set up: Elenaâ€™s
customer information refers to the account, and the account refers to
Elenaâ€™s customer information:
</div><div class="SIntrapara"><div class="HeapExpr"><div class="EnvPart"><p>Directory</p><ul><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1001</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1002</span></div></li></ul></div><div class="HeapPart"><p>Heap</p><ul><li><p><span class="heapref source">1001</span>:<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account(8404, 500, [<span class="heapref sink">1002</span>])</code></span></p></li><li><p><span class="heapref source">1002</span>:<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer("Elena", <span class="heapref sink">1001</span>)</code></span></p></li></ul></div><p/><div class="clear"/></div></div><div class="SIntrapara">This is the cycle in â€œcyclicâ€: <span class="heapref sink">1001</span> depends on <span class="heapref sink">1002</span>
and <span class="heapref sink">1002</span> depends on <span class="heapref sink">1001</span>.</div><p/><div class="SIntrapara">Observe that if we introduce another customer, Jorge, who shares the same
account, we can update the account to reflect that also:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p><span style="font-weight: bold">Python</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">jorge = Customer("Jorge", acct1)</code></pre></div></div></td></tr><tr><td><p><span style="font-weight: bold">Pyret</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">jorge = cust("Jorge", acct1)</code></pre></div></div></td></tr></table></div><div class="SIntrapara">Again, the information in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1</code></span> is inaccurate because it does
not reflect the new owner. We can modify it in a similar way:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p><span style="font-weight: bold">Python</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1.owners = acct1.owners + [jorge]</code></pre></div></div></td></tr><tr><td><p><span style="font-weight: bold">Pyret</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1!{owners: acct1!owners + [list: jorge]}</code></pre></div></div></td></tr></table></div><div class="SIntrapara">So now our memory would look like this:
</div><div class="SIntrapara"><div class="HeapExpr"><div class="EnvPart"><p>Directory</p><ul><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1001</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1002</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">jorge</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1003</span></div></li></ul></div><div class="HeapPart"><p>Heap</p><ul><li><p><span class="heapref source">1001</span>:<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account(8404, 500, [<span class="heapref sink">1002</span>, <span class="heapref sink">1003</span>])</code></span></p></li><li><p><span class="heapref source">1002</span>:<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer("Elena", <span class="heapref sink">1001</span>)</code></span></p></li><li><p><span class="heapref source">1003</span>:<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer("Jorge", <span class="heapref sink">1001</span>)</code></span></p></li></ul></div><p/><div class="clear"/></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>We wrote slightly different code when adding Jorgeâ€™s account than when
adding Elenaâ€™s account. Is one better than the other?</p></blockquote></blockquote><p>The code for Elenaâ€™s addition ignored whatever owners there previously
were. That is, it would only work correctly in a setting where there
were no other owners. The code for Jorgeâ€™s addition takes into account
all the previous owners. Therefore, Elenaâ€™s code was perfectly fine
for illustrating the simple first case, but Jorgeâ€™s code is more
general in that it will work in all settings (including when the prior
list of owners is empty).</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a function that takes care of adding a customer to an account.</p></blockquote></blockquote>&#13;
<h4 class="heading">12.4.2<span class="stt">Â </span><a name="(part._.Testing_.Cyclic_.Data)"/>Testing Cyclic Data<span class="button-group"><a href="#(part._.Testing_.Cyclic_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">When you want to write a test involving circular data, you canâ€™t write
out the circular data manually.  For example, imagine that we wanted
to write out <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1</code></span> from earlier:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p><span style="font-weight: bold">Python</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">assert(acct1 = Account(8404, 500, [Customer("Elena", Account(8404, 500, â€¦)]))</code></pre></div></div></td></tr><tr><td><p><span style="font-weight: bold">Pyret</span></p></td><td><p/></td></tr><tr><td><p/></td><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  acct1 is
    account(8404, 500, [list: cust("Elena", account(8404, 500, â€¦))])
end</code></pre></div></div></td></tr></table></div><div class="SIntrapara">However, because of the circularity, we canâ€™t finish writing down the
data. We canâ€™t just leave part of it unspecified with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">â€¦</code></span>.</div><p>This leaves us with two choices:</p><p>You have two options: write tests in terms of the names of data,
or write tests on the components of the data.</p><p>Hereâ€™s an example that illustrates both. After setting up the account,
we might want to check that the owner of the new account is the new
customer:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">assert(new_acct.owner is new_cust)</code></pre></div></div><p>Here, rather than write out the <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Customer</code></span> explicitly, we use the name
of the existing item in the directory. This doesnâ€™t require you to write
ellipses. We also focused on just the <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">owner</code></span> component, as a part of
the <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account</code></span> value that we expected to change.</p>&#13;
<h4 class="heading">12.4.3<span class="stt">Â </span><a name="(part._.Cycles_in_.Practice)"/>Cycles in Practice<span class="button-group"><a href="#(part._.Cycles_in_.Practice)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Cyclic data show up in many settings in real programs. Whenever two
data are interrelated, and we have good reason to want to get from
either one to the other, they have the potential to have references to
each other, which can lead to cycles. Sometimes the connection can be
to provide updates, as above; other times it can simply be for
navigational convenience.</p><p>Consider the Document Object Model (<span class="Smaller">DOM</span>), which is the data structure
that represents every Web page in a Web browser. Programmers usually
think of the <span class="Smaller">DOM</span> hierarchically, as a tree, because every note refers
to all the nodes that constitute it: e.g., a page has references to
each of its paragraphs, a list has references to each list item, and
so forth. However, every one of these elements also has a reference to
its parent. This way, a program can conveniently traverse â€œdownwardâ€
or â€œupwardâ€.</p><p>Programming with cyclic data introduces complications. If we traverse
the data naÃ¯vely, we would go into an infinite loop. Rather, we have
to keep track of the data we have previously visited, and make sure we
donâ€™t visit them again (see <a href="size-of-dag.html" data-pltdoc="x">The Size of a <span class="Smaller">DAG</span></a>). Indeed, cyclic
data are graphs [<a href="part_graphs.html" data-pltdoc="x">Graphs</a>], so issues in processing graphs
become relevant here.</p><p/><div class="SIntrapara">One interesting question that programming languages face is, how do
you <span class="emph">print</span> cyclic data? For instance, what happens if the
programmer writes
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1</code></pre></div></div></div><div class="SIntrapara">? To print the account we must print its owners; to print each owner,
we must print their account; to print that accountâ€¦</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Try it out in both Python and Pyret!</p></blockquote></blockquote><p>Different programming languages handle this problem in different
ways. Some languages will go into an infinite loop trying to print
cyclic data. Both Python and Pyret handle this more
intelligently. Determining even <span class="emph">whether</span> a datum is cyclic is an
interesting question, which we take up in <a href="cycle-detection.html" data-pltdoc="x">Detecting Cycles</a>.</p>    
</body>
</html>