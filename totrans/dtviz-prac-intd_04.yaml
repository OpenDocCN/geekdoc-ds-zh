- en: 3 Make a plot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 制作图表
- en: 原文：[https://socviz.co/makeplot.html](https://socviz.co/makeplot.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://socviz.co/makeplot.html](https://socviz.co/makeplot.html)'
- en: This Chapter will teach you how to use ggplot’s core functions to produce a
    series of scatterplots. From one point of view, we will proceed slowly and carefully,
    taking our time to understand the logic behind the commands that you type. The
    reason for this is that the central activity of visualizing data with ggplot more
    or less *always* involves the same sequence of steps. So it is worth learning
    what they are.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教会你如何使用ggplot的核心函数来生成一系列散点图。从一个角度来看，我们将缓慢而细致地进行，花时间理解你所输入的命令背后的逻辑。这样做的原因是，使用ggplot可视化数据的核心活动或多或少总是涉及相同的步骤序列。因此，了解这些步骤是值得的。
- en: From another point of view, though, we will move fast. Once you have the basic
    sequence down, and understand how it is that ggplot assembles the pieces of a
    plot in to a final image, then you will find that analytically and aesthetically
    sophisticated plots come within your reach very quickly. By the end of this Chapter,
    for example, we will have learned how to produce a small-multiple plot of time
    series data for a large number of countries, with a smoothed regression line in
    each panel. So in another sense we will have moved quite fast.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从另一个角度来看，我们将快速前进。一旦你掌握了基本的步骤序列，并理解了ggplot如何将图表的各个部分组装成最终的图像，那么你会发现，在分析和美学上复杂的图表很快就会变得触手可及。例如，到本章结束时，我们将学习如何为大量国家生成时间序列数据的小型图，每个面板中都有平滑的回归线。所以从另一个意义上说，我们也将快速前进。
- en: 3.1 How ggplot works
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 ggplot的工作原理
- en: As we saw in Chapter [1](lookatdata.html#lookatdata), visualization involves
    representing your data data using lines or shapes or colors and so on. There is
    some structured relationship, some *mapping*, between the variables in your data
    and their representation in the plot displayed on your screen or on the page.
    We also saw that not all mappings make sense for all types of variables, and (independently
    of this), some representations are harder to interpret than others. Ggplot provides
    you with a set of tools to map data to visual elements on your plot, to specify
    the kind of plot you want, and then subsquently to control the fine details of
    how it will be displayed. Figure [3.1](makeplot.html#fig:ggplot-flow) shows a
    schematic outline of the process starting from data, at the top, down to a finished
    plot at the bottom. Don’t worry about the details for now. We will be doing into
    them one piece at a time over the next few chapters.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第[1](lookatdata.html#lookatdata)章中看到的，可视化涉及使用线条、形状或颜色等来表示你的数据。你的数据中的变量和它们在屏幕或页面上的图表表示之间存在某种结构化的关系，某种*映射*。我们还看到，并非所有映射都适用于所有类型的变量，而且（独立于此），一些表示比其他表示更难解释。ggplot为你提供了一套工具，将数据映射到图表上的视觉元素，指定你想要的图表类型，然后随后控制其显示的细节。图[3.1](makeplot.html#fig:ggplot-flow)展示了从顶部数据开始到底部完成图表的流程图概要。现在不必担心细节。在接下来的几章中，我们将逐个深入探讨这些细节。
- en: '![The main elements of ggplot''s grammar of graphics. This chapter goes through
    these steps in detail.](../Images/c1ff2f5d98f9f5a0f2ee592c6c4b484c.png) Figure
    3.1: The main elements of ggplot’s grammar of graphics. This chapter goes through
    these steps in detail.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '![ggplot图形语法的主体元素。本章将详细讲解这些步骤。](../Images/c1ff2f5d98f9f5a0f2ee592c6c4b484c.png)
    图3.1：ggplot图形语法的主体元素。本章将详细讲解这些步骤。'
- en: The most important thing to get used to with ggplot is the way you use it to
    think about the logical structure of your plot. The code you write specifies the
    connections between the variables in your data, and the colors, points, and shapes
    you see on the screen. In ggplot, these logical connections between your data
    and the plot elements are called *aesthetic mappings* or just *aesthetics*. You
    begin every plot by telling the `ggplot()` function what your data is, and then
    how the variables in this data logically map onto the plot’s aesthetics. Then
    you take the result and say what general sort of plot you want, such as a scatterplot,
    a boxplot, or a bar chart. In ggplot, the overall type of plot is called a *geom*.
    Each geom has a function that creates it. For example, `geom_point()` makes scatterplots,
    `geom_bar()` makes barplots, `geom_boxplot()` makes boxplots, and so on. You combine
    these two pieces, the `ggplot()` object and the `geom`, by literally adding them
    together in an expression, using the “`+`” symbol.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ggplot最重要的习惯是学会如何用它来思考你图表的逻辑结构。你写的代码指定了数据中变量之间的联系，以及你在屏幕上看到的颜色、点和形状。在ggplot中，这些数据与图表元素之间的逻辑联系被称为*美学映射*或简称*美学*。你开始每一个图表时，先告诉`ggplot()`函数你的数据是什么，然后这些数据中的变量如何逻辑地映射到图表的美学上。然后，你用结果来描述你想要的通用图表类型，比如散点图、箱线图或柱状图。在ggplot中，图表的整体类型被称为*geom*。每个geom都有一个创建它的函数。例如，`geom_point()`创建散点图，`geom_bar()`创建柱状图，`geom_boxplot()`创建箱线图，等等。你通过在表达式中实际地将它们相加，使用“`+`”符号，将这两个部分——`ggplot()`对象和`geom`——结合起来。
- en: At this point, ggplot will have enough information to be able to draw a plot
    for you. The rest is just details about exactly what you want to see. If you don’t
    specify anything further, ggplot will use a set of defaults that try to be sensible
    about what gets drawn. But more often, you will want to specify exactly what you
    want, including information about the scales, the labels of legends and axes,
    and other guides that help people to read the plot. These additional pieces are
    added to the plot in the same way as the `geom_` function was. Each component
    has it own function, you provide arguments to it specifying what to do, and you
    literally add it to the sequence of instructions. In this way you systematically
    build your plot piece by piece.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时候，ggplot将拥有足够的信息来为你绘制图表。剩下的只是关于你确切想要看到的具体细节。如果你没有进一步指定，ggplot将使用一组默认设置，试图在绘制时尽可能合理。但更常见的情况是，你将想要指定确切的内容，包括关于刻度、图例和坐标轴标签以及其他帮助人们阅读图表的指南的信息。这些额外的部分是以与`geom_`函数相同的方式添加到图表中的。每个组件都有自己的函数，你提供给它参数来指定要做什么，然后你实际上将其添加到指令序列中。通过这种方式，你可以系统地一块一块地构建你的图表。
- en: In this chapter we will go through the main steps of this process. We will proceed
    by example, repeatedly building a series of plots. As noted earlier, I *strongly*
    encourage you go through this exercise manually, typing (rather than copying-and-pasting)
    the code yourself. This may seem a bit tedious, but it is *by far* the most effective
    way to get used to what is happening, and to get a feel for R’s syntax. While
    you’ll inevitably make some errors, you will also quickly find yourself becoming
    able to diagnose your own errors, as well as having a better grasp of the higher-level
    structure of plots. You should open the RMarkdown file for your notes, remember
    to load the tidyverse library`library(tidyverse)` and write the code out in chunks,
    interspersing your own notes and comments as you go.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将逐步介绍这个过程的主要步骤。我们将通过示例进行，反复构建一系列图表。正如之前所提到的，我强烈建议你手动完成这个练习，亲自输入（而不是复制粘贴）代码。这可能会显得有些繁琐，但这是迄今为止最有效的方法，可以帮助你习惯正在发生的事情，并更好地掌握R的语法。虽然你不可避免地会犯一些错误，但你也会很快发现自己能够诊断自己的错误，同时更好地理解图表的高级结构。你应该打开你的笔记的RMarkdown文件，记得加载tidyverse库`library(tidyverse)`，并以块的形式编写代码，在过程中穿插你的笔记和注释。
- en: 'Table 3.1: Life Expectancy data in wide format.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1：宽格式下的预期寿命数据。
- en: '| country | 1952 | 1957 | 1962 | 1967 | 1972 | 1977 | 1982 | 1987 | 1992 |
    1997 | 2002 | 2007 |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 国家 | 1952 | 1957 | 1962 | 1967 | 1972 | 1977 | 1982 | 1987 | 1992 | 1997
    | 2002 | 2007 |'
- en: '| :-- | --: | --: | --: | --: | --: | --: | --: | --: | --: | --: | --: | --:
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| :-- | --: | --: | --: | --: | --: | --: | --: | --: | --: | --: | --: | --:
    |'
- en: '| Afghanistan | 29 | 30 | 32 | 34 | 36 | 38 | 40 | 41 | 42 | 42 | 42 | 44 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 阿富汗 | 29 | 30 | 32 | 34 | 36 | 38 | 40 | 41 | 42 | 42 | 42 | 44 |'
- en: '| Albania | 55 | 59 | 65 | 66 | 68 | 69 | 70 | 72 | 72 | 73 | 76 | 76 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 阿尔巴尼亚 | 55 | 59 | 65 | 66 | 68 | 69 | 70 | 72 | 72 | 73 | 76 | 76 |'
- en: '| Algeria | 43 | 46 | 48 | 51 | 55 | 58 | 61 | 66 | 68 | 69 | 71 | 72 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 阿尔及利亚 | 43 | 46 | 48 | 51 | 55 | 58 | 61 | 66 | 68 | 69 | 71 | 72 |'
- en: '| Angola | 30 | 32 | 34 | 36 | 38 | 39 | 40 | 40 | 41 | 41 | 41 | 43 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 安哥拉 | 30 | 32 | 34 | 36 | 38 | 39 | 40 | 40 | 41 | 41 | 41 | 43 |'
- en: '| Argentina | 62 | 64 | 65 | 66 | 67 | 68 | 70 | 71 | 72 | 73 | 74 | 75 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 阿根廷 | 62 | 64 | 65 | 66 | 67 | 68 | 70 | 71 | 72 | 73 | 74 | 75 |'
- en: '| Australia | 69 | 70 | 71 | 71 | 72 | 73 | 75 | 76 | 78 | 79 | 80 | 81 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 澳大利亚 | 69 | 70 | 71 | 71 | 72 | 73 | 75 | 76 | 78 | 79 | 80 | 81 |'
- en: 3.2 Tidy data
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 整洁数据
- en: The tidyverse tools we will be using want to see your data in a particular sort
    of shape, generally referred to as “tidy data” (Wickham, 2014). Social scientists
    will likely be familiar with the distinction between *wide format* and *long format*
    data. In a long format table, every variable is a column, and every observation
    is a row. In a wide format table, some variables are spread out across columns.
    For example, Table [3.1](makeplot.html#tab:gaptab1) shows part of a table of life
    expectancy over time for a series of countries. This is in wide format, because
    one of the variables, year, is spread across the columns of the table.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的 tidyverse 工具希望看到你的数据以特定的形状呈现，通常被称为“整洁数据”（Wickham, 2014）。社会科学家可能会熟悉 *宽格式*
    和 *长格式* 数据之间的区别。在长格式表格中，每个变量都是一个列，每个观测值都是一个行。在宽格式表格中，一些变量分布在列中。例如，表 [3.1](makeplot.html#tab:gaptab1)
    展示了一系列国家随时间推移的生命预期的一部分表格。这是宽格式，因为其中一个变量，年份，分布在表格的列中。
- en: By contrast, Table [3.2](makeplot.html#tab:gaptab2) shows the beginning of the
    same data in long format. The tidy data that ggplot wants is in this long form.
    In a related bit of terminology, in this table the `year` variable is sometimes
    called a *key* and the `lifeExp` variable is the *value* taken by that key for
    any particular row. These terms are useful when converting tables from wide to
    long format. I am speaking fairly loosely here. Underneath these terms there is
    a worked-out theory of the forms that tabular data can be stored in, but right
    now we don’t need to know those additional details. For more on the ideas behind
    tidy data, see the discussion in the Appendix. You will also find an example showing
    the R code you need to get from an untidy to a tidy shape for the common “wide”
    case where some variables are spread out across the columns of your table.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，表 [3.2](makeplot.html#tab:gaptab2) 展示了相同数据的开始部分，以长格式呈现。ggplot 所需要的整洁数据就是这种长格式。在相关的术语中，在这个表格中，`year`
    变量有时被称为 *键*，而 `lifeExp` 变量是那个键对于任何特定行的 *值*。这些术语在将表格从宽格式转换为长格式时很有用。我这里说得相当宽松。在这些术语之下，有一个关于表格数据可以存储的形式的详细理论，但现阶段我们不需要知道这些额外的细节。关于整洁数据背后的想法，请参阅附录中的讨论。你还会找到一个示例，展示你需要从杂乱无章的形状转换为整洁形状的
    R 代码，对于常见的“宽”情况，其中一些变量分布在表格的列中。
- en: 'Table 3.2: Life Expectancy data in long format.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.2：长格式生命预期数据。
- en: '| country | year | lifeExp |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 国家 | 年份 | 生命预期 |'
- en: '| :-- | --: | --: |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| :-- | --: | --: |'
- en: '| Afghanistan | 1952 | 29 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 阿富汗 | 1952 | 29 |'
- en: '| Afghanistan | 1957 | 30 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 阿富汗 | 1957 | 30 |'
- en: '| Afghanistan | 1962 | 32 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 阿富汗 | 1962 | 32 |'
- en: '| Afghanistan | 1967 | 34 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 阿富汗 | 1967 | 34 |'
- en: '| Afghanistan | 1972 | 36 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 阿富汗 | 1972 | 36 |'
- en: '| Afghanistan | 1977 | 38 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 阿富汗 | 1977 | 38 |'
- en: If you compare Tables [3.1](makeplot.html#tab:gaptab1) and [3.2](makeplot.html#tab:gaptab2),
    it is clear that a tidy table does not present data in its most compact form.
    In fact, it is usually not how you would choose to present your data if you wanted
    to just show people the numbers. Neither is untidy data “messy” or the “wrong”
    way to lay out data in some generic sense. It’s just that, even if its long-form
    shape makes tables larger, tidy data is much more straightforward to work with
    when it comes to specifying the mappings that you need to coherently describe
    plots.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你比较表 [3.1](makeplot.html#tab:gaptab1) 和 [3.2](makeplot.html#tab:gaptab2)，很明显，整洁表格并没有以最紧凑的形式呈现数据。实际上，如果你只想向人们展示数字，通常你不会选择以这种方式呈现你的数据。杂乱无章的数据也不一定是“杂乱”或以某种通用意义上“错误”的方式布局数据。它只是，即使其长格式形状使得表格更大，但在指定你需要用来连贯描述图表的映射时，整洁数据要简单得多。
- en: 3.3 Mappings link data to things you see
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 映射将数据与所见事物联系起来
- en: It’s useful to think of a recipe or template that we start from each time we
    want to make a plot. This is shown in Figure [3.2](makeplot.html#fig:ch-03-ggplot-formula-schematic).
    We start with just one object of our own, our data, which should be in a shape
    that ggplot understands. Usually this will be a *data frame* or some augmented
    version of it, like a *tibble*. We tell the core `ggplot` function what our data
    is. In this book, we will do this by creating an object named `p` which will contain
    the core information for our plot. (The name `p` is just a convenience.) Then
    we choose a plot type, or *geom* and add it to `p`. From there, we add more features
    to the plot as needed, such as additional elements, adjusted scales, a title,
    or other labels as needed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们想要制作一个图表时，考虑一个食谱或模板是有用的。这如图 [3.2](makeplot.html#fig:ch-03-ggplot-formula-schematic)
    所示。我们从自己的一个对象开始，即我们的数据，它应该以 ggplot 能够理解的形式存在。通常这将是 *data frame* 或其增强版本，如 *tibble*。我们告诉核心
    `ggplot` 函数我们的数据是什么。在这本书中，我们将通过创建一个名为 `p` 的对象来完成此操作，该对象将包含图表的核心信息。（名称 `p` 只是一个便利的名称。）然后我们选择一个图表类型，或
    *geom* 并将其添加到 `p` 中。从那里，根据需要添加更多功能到图表中，例如额外的元素、调整的刻度、标题或其他所需的标签。
- en: '![A schematic for making a plot.](../Images/56281a77d6137fdd488cb29f21b9c816.png)
    Figure 3.2: A schematic for making a plot.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![制作图表的示意图。](../Images/56281a77d6137fdd488cb29f21b9c816.png) 图 3.2：制作图表的示意图。'
- en: We’ll use the gapminder data to make our first plots. Make sure the library
    containing the data is loaded. If you are following through from the previous
    Chapter in the same RStudio session or RMarkdown document, you won’t have to load
    it again. Otherwise, use `library()` to make it available.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 gapminder 数据来制作我们的第一个图表。请确保包含数据的库已加载。如果您正在同一个 RStudio 会话或 RMarkdown 文档中跟随上一章，您就无需再次加载它。否则，使用
    `library()` 使其可用。
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can remind ourselves again what it looks like by typing the name of the
    object at the console:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在控制台中输入对象名称来再次提醒自己它的样子：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s say we want to plot Life Expectancy against per capita GDP for all country-years
    in the data. We’ll do this by creating an object that has some of the necessary
    information in it, and build it up from there. First, we must tell the `ggplot()`
    function what data we are using.Remember, use `Option+minus` on MacOS or `Alt+minus`
    on Windows to type the assignment operator.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要绘制数据中所有国家-年份的预期寿命与人均 GDP 的关系图。我们将通过创建一个包含一些必要信息的对象来完成此操作，并从那里构建它。首先，我们必须告诉
    `ggplot()` 函数我们使用的数据。记住，在 MacOS 上使用 `Option+minus` 或在 Windows 上使用 `Alt+minus`
    来输入赋值运算符。
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At this point ggplot knows our data, but not what the *mapping*. That is,You
    do not need to explicitly name the arguments you pass to functions, as long as
    you provide them in the expected order, viz, the order listed on the help page
    for the function. This code would still work if we omitted `data = ` and `mapping
    =` . In this book, I name all the arguments for clarity. we need to tell it which
    variables in the data should be represented by which visual elements in the plot.
    It also doesn’t know what sort of plot we want. In ggplot, mappings are specified
    using the `aes()` function. Like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，ggplot 知道我们的数据，但不知道 *mapping*。也就是说，您不需要明确命名传递给函数的参数，只要您按照预期的顺序提供它们，即函数帮助页面上的列表顺序。如果我们省略
    `data = ` 和 `mapping =`，此代码仍然有效。在这本书中，我命名所有参数以提高清晰度。
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here we’ve given the `ggplot()` function two arguments instead of one: `data`
    and `mapping`. The `data` argument tells ggplot where to find the variables it
    is about to use. This saves us from having to tediously dig out the name of each
    variable in full. Instead, any mentions of variables will be looked for here first.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们给 `ggplot()` 函数提供了两个参数而不是一个：`data` 和 `mapping`。`data` 参数告诉 ggplot 它将使用哪些变量。这使我们免去了繁琐地挖掘每个变量完整名称的麻烦。相反，任何变量的提及都将首先在这里查找。
- en: Next, the mapping. The `mapping` argument is not a data object, nor is it a
    character string. Instead, it’s a function. (Remember, functions can be nested
    inside other functions.) The arguments we give to the `aes` function are a sequence
    of definitions that `ggplot` will use later. Here they say, “The variable on the
    x-axis is going to be `gdpPercap`, and the variable on the y-axis is going to
    be `lifeExp`.” The `aes()` function does not say where variables with those names
    are to be found. That’s because `ggplot()` is going to assume things with that
    name are in the object given to the `data` argument.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是映射。`mapping` 参数不是一个数据对象，也不是一个字符字符串。相反，它是一个函数。（记住，函数可以嵌套在其他函数内部。）我们提供给 `aes`
    函数的参数是一系列定义，`ggplot` 将稍后使用这些定义。这里它们说，“x轴上的变量将是 `gdpPercap`，y轴上的变量将是 `lifeExp`。”`aes()`
    函数并没有说明具有这些名称的变量在哪里可以找到。这是因为 `ggplot()` 将假设具有该名称的事物在提供给 `data` 参数的对象中。
- en: The `mapping = aes(...)` argument *links variables* to *things you will see*
    on the plot. The `x` and `y` values are the most obvious ones. Other aesthetic
    mappings can include, for example, color, shape, size, and line type (whether
    a line is solid or dashed, or some other pattern). We’ll see examples in a minute.
    A mapping does not directly say what particular, e.g., colors or shapes will be
    on the plot. Rather they say which *variables* in the data will be *represented*
    by visual elements like a color, a shape, or a point on the plot area.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapping = aes(...)` 参数将变量与图表上显示的**事物**相**链接**。`x` 和 `y` 值是最明显的。其他美学映射可以包括，例如，颜色、形状、大小和线型（线条是实线、虚线还是其他图案）。我们将在下一分钟看到示例。映射并不直接说明图表上会有哪些特定的，例如，颜色或形状。相反，它们说明数据中的哪些**变量**将通过视觉元素，如颜色、形状或图表区域上的点来**表示**。'
- en: What happens if we just type `p` at the console at this point and hit return?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在在控制台中只输入 `p` 并按回车键会发生什么？
- en: '![This empty plot has no geoms.](../Images/47dad5f7b71ab7ea157c35ee278b93cf.png)
    Figure 3.3: This empty plot has no geoms.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![这是一个没有几何图形的空图表](../Images/47dad5f7b71ab7ea157c35ee278b93cf.png) 图3.3：这是一个没有几何图形的空图表。'
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `p` object has been created by the `ggplot()` function, and already has
    information in it about the mappings we want, together with a lot of other information
    added by default. (If you want to see just how much information is in the `p`
    object already, try asking for `str(p)`.) However, we haven’t given it any instructions
    get about what sort of plot to draw. We need to add a *layer* to the plot. This
    means picking a `geom_` function. We will use `geom_point()`. It knows how to
    take `x` and `y` values and plot them in a scatterplot.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`p` 对象是由 `ggplot()` 函数创建的，其中已经包含了关于我们想要的映射的信息，以及默认添加的大量其他信息。（如果你想看看 `p` 对象中已经有多少信息，可以尝试请求
    `str(p)`。）然而，我们还没有给它任何关于绘制何种图表的指令。我们需要向图表添加一个**层**。这意味着选择一个 `geom_` 函数。我们将使用 `geom_point()`。它知道如何将
    `x` 和 `y` 值绘制成散点图。'
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Figure 3.4: A scatterplot of Life Expectancy vs GDP'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：寿命预期与GDP的散点图
- en: '![A scatterplot of Life Expectancy vs GDP](../Images/3499497ffdaedc0433bcaf755af3df94.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![寿命预期与GDP的散点图](../Images/3499497ffdaedc0433bcaf755af3df94.png)'
- en: Success!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！
- en: 3.4 Build your plots layer by layer
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 分层构建你的图表
- en: Although we got a brief taste of ggplot at the end of Chapter [2](gettingstarted.html#gettingstarted),
    we spent more time in that Chaper preparing the ground to make this first proper
    graph. We set up our software IDE and made sure we could reproduce our work. We
    then learned the basics of how R works, and the sort of tidy data that ggplot
    expects. Just now we went through the logic of ggplot’s main idea, of building
    up plots a piece at a time in a systematic and predictable fashion, beginning
    with a mapping between a variable and an aesthetic element. We have done a lot
    of work and produced one plot.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在第 [2](gettingstarted.html#gettingstarted) 章节末尾简要了解了 ggplot，但我们花了更多的时间在那个章节中为制作这个第一个合适的图表做准备。我们设置了我们的软件IDE，并确保我们可以重现我们的工作。然后我们学习了R的基本工作原理，以及ggplot期望的整洁数据类型。刚才我们了解了ggplot主要思想的逻辑，即以系统且可预测的方式逐步构建图表，从变量与美学元素之间的映射开始。我们已经做了很多工作，并生成了一张图表。
- en: 'The good news is that, from now on, not much will change conceptually about
    what we are doing. It will be more a question of learning in greater detail about
    how to tell ggplot what to do. We will learn more about the different geoms (or
    types of plot) available, and find out about the functions that control the coordinate
    system, scales, guiding elements (like labels and tick marks), and thematic features
    of plots. This will allow us to make much more sophisticated plots surprisingly
    fast. Conceptually, however, we will always be doing the same thing. We will start
    with a table of data that has been tidied, and then we will:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，从现在开始，我们在概念上所做的事情不会有太大的变化。这更多是关于更详细地了解如何告诉 ggplot 做什么。我们将了解更多关于不同 geoms（或图表类型）的信息，并了解控制坐标系、刻度、引导元素（如标签和刻度线）以及图表主题功能的函数。这将使我们能够以惊人的速度制作更复杂的图表。然而，在概念上，我们始终在做同样的事情。我们将从一个整理过的数据表开始，然后我们将：
- en: Tell the `ggplot()` function what our data is.The `data = …` step.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉 `ggplot()` 函数我们的数据是什么。`data = …` 步骤。
- en: Tell `ggplot()` *what* relationships we want to see.The `mapping = aes(…)` step.
    For convenience we will put the results of the first two steps in an object called
    `p`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉 `ggplot()` 我们想要看到哪些关系。`mapping = aes(…)` 步骤。为了方便，我们将前两步的结果放入一个名为 `p` 的对象中。
- en: Tell `ggplot` *how* we want to see the relationships in our data.Choose a geom.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉 `ggplot` 我们想要如何看到数据中的关系。选择一个 geom。
- en: Layer on geoms as needed, by adding them to the `p` object one at a time.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要逐层添加 geoms，通过将它们逐个添加到 `p` 对象中。
- en: UseThe `scale_,` family, `labs()` and `guides()` functions. some additional
    functions to adjust scales, labels, tick marks, titles. We’ll learn more about
    some of these functions shortly.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `scale_`、`family`、`labs()` 和 `guides()` 函数以及一些额外的函数来调整刻度、标签、刻度线、标题。我们将在不久的将来了解更多关于这些函数的信息。
- en: To begin with we will let ggplot use its defaults for many of these elements.
    The coordinate system used in plots is most often cartesian, for example. It is
    a plane defined by an x axis and a y axis. This is what ggplot assumes, unless
    you tell it otherwise. But we will quickly start making some adjustments. Bear
    in mind once again that the process of adding layers to the plot really is *additive*.In
    effect we create one big object that is a nested list of instructions for how
    to draw each piece of the plot. Usually in R, functions cannot simply be added
    to objects. Rather, they take objects as inputs and produce objects as outputs.
    But the objects created by ggplot() are special. This makes it easier to assemble
    plots one piece at a time, and to inspect how they look at every step. For example,
    let’s try a different `geom_` function with our plot.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将让 ggplot 使用其默认值来设置这些元素中的许多。在图表中使用的坐标系通常是笛卡尔坐标系，例如。这是一个由 x 轴和 y 轴定义的平面。这是
    ggplot 的假设，除非你告诉它否则。但我们将很快开始做一些调整。请再次记住，向图表添加层的过程实际上是 *累加的*。实际上，我们创建了一个大对象，它是一个嵌套列表，包含了如何绘制图表每一部分的指令。通常在
    R 中，函数不能简单地添加到对象中。相反，它们以对象作为输入，并产生对象作为输出。但 ggplot() 创建的对象是特殊的。这使得我们可以逐个组装图表，并在每一步检查它们的外观。例如，让我们尝试使用不同的
    `geom_` 函数来修改我们的图表。
- en: '![Life Expectancy vs GDP, using a smoother.](../Images/0469c2175ab50a6df7a006a61a34e03b.png)
    Figure 3.5: Life Expectancy vs GDP, using a smoother.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![寿命与 GDP 的对比，使用平滑器。](../Images/0469c2175ab50a6df7a006a61a34e03b.png) 图 3.5：寿命与
    GDP 的对比，使用平滑器。'
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can see right away that some of these geoms do a lot more than simply put
    points on a grid. Here `geom_smooth()` has calculated a smoothed line for us and
    shaded in a ribbon showing the standard error for the line. If we want to see
    the data points and the line together, we simply add `geom_point()` back in:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以立即看出，一些 geoms 执行的操作远不止在网格上放置点。在这里，`geom_smooth()` 为我们计算了一条平滑线，并用阴影条带显示了线的标准误差。如果我们想同时看到数据点和线，我们只需再次添加
    `geom_point()`：
- en: '![Life Expectancy vs GDP, showing both points and a GAM smoother.](../Images/20c96ac9f9ee066dad98ea66fbc317a1.png)
    Figure 3.6: Life Expectancy vs GDP, showing both points and a GAM smoother.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![寿命与 GDP 的对比，显示点和 GAM 平滑器。](../Images/20c96ac9f9ee066dad98ea66fbc317a1.png)
    图 3.6：寿命与 GDP 的对比，显示点和 GAM 平滑器。'
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The console message R tells you the `geom_smooth()` function is using a `method`
    called `gam`, which in this case means it has fit a generalized additive model.
    This suggests that maybe there are other methods that `geom_smooth()` understands,
    and which we might tell it to use instead. Instructions are given to functions
    via their arguments, so we can try adding `method = "lm"` (for “linear model”)
    as an argument to `geom_smooth()`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台信息 R 告诉你 `geom_smooth()` 函数正在使用一个名为 `gam` 的 `method`，在这种情况下意味着它已经拟合了一个广义加性模型。这表明可能还有其他
    `geom_smooth()` 能够理解的方法，我们可以指示它使用这些方法。函数的指令是通过它们的参数给出的，因此我们可以尝试将 `method = "lm"`（代表“线性模型”）作为参数添加到
    `geom_smooth()` 中：
- en: '![Life Expectancy vs GDP, points and an ill-advised linear fit.](../Images/b464fa693cd69f46ffe0f320331102a8.png)
    Figure 3.7: Life Expectancy vs GDP, points and an ill-advised linear fit.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![寿命与 GDP 的对比，点与不恰当的线性拟合。](../Images/b464fa693cd69f46ffe0f320331102a8.png)
    图 3.7：寿命与 GDP 的对比，点与不恰当的线性拟合。'
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We did not have to tell `geom_point()` or `geom_smooth()` where their data was
    coming from, or what mappings they should use. They *inherit* this information
    from the original `p` object. As we’ll see later, it’s possible to give geoms
    separate instructions that they will follow instead. But in the absence of any
    other information, the geoms will look for the instructions it needs in the `ggplot()`
    function, or the object created by it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必告诉 `geom_point()` 或 `geom_smooth()` 它们的数据来源，或它们应该使用哪些映射。它们*继承*了来自原始 `p`
    对象的信息。正如我们稍后将会看到的，可以给 geoms 提供单独的指令，它们将遵循这些指令。但在没有其他信息的情况下，geoms 将在 `ggplot()`
    函数或它创建的对象中寻找所需的指令。
- en: 'In our plot, the data is quite bunched up against the left side. Gross Domestic
    Product per capita is not normally distributed across our country years. The x-axis
    scale would probably look better if it were transformed from a linear scale to
    a log scale. For this we can use a function called `scale_x_log10()`. As you might
    expect this function scales the x-axis of a plot to a log 10 basis. To use it
    we just add it to the plot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的图表中，数据在左侧非常密集。人均国内生产总值在我们的国家年份中不是正态分布的。如果 x 轴的刻度从线性刻度转换为对数刻度，可能会看起来更好。为此，我们可以使用一个名为
    `scale_x_log10()` 的函数。正如你所期望的，这个函数将图表的 x 轴缩放到以 10 为底的对数基础上。要使用它，我们只需将其添加到图表中：
- en: '![Life Expectancy vs GDP scatterplot, with a GAM smoother and a log scale on
    the x-axis.](../Images/89cc54d50b54a4a8385915808ec2c87c.png) Figure 3.8: Life
    Expectancy vs GDP scatterplot, with a GAM smoother and a log scale on the x-axis.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![寿命与 GDP 散点图，带有 GAM 平滑器和 x 轴上的对数刻度。](../Images/89cc54d50b54a4a8385915808ec2c87c.png)
    图 3.8：寿命与 GDP 散点图，带有 GAM 平滑器和 x 轴上的对数刻度。'
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The x-axis transformation repositions the points, and also changes the shape
    the smoothed line. (We switched back to `gam` from `lm`.) While `ggplot()` and
    its associated functions have not made any changes to our underlying data frame,
    the scale transformation is applied to the data before the smoother is layered
    on to the plot. There are a variety of scale transformations that you can use
    in just this way. Each is named for the transformation you want to apply, and
    the axis you want to applying it to. In this case we use `scale_x_log10()`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: x 轴的转换重新定位了点，同时也改变了平滑线的形状。（我们已从 `lm` 切换回 `gam`。）虽然 `ggplot()` 及其相关函数没有对我们的基础数据框做出任何更改，但缩放转换是在平滑层添加到图表之前应用于数据的。你可以使用各种缩放转换，每种转换都是以你想要应用转换的名称命名的，以及你想要应用转换的轴。在这种情况下，我们使用
    `scale_x_log10()`。
- en: 'At this point, if our goal was just to show a plot of Life Expectancy vs GDP
    using sensible scales and adding a smoother, we would be thinking about polishing
    up the plot with nicer axis labels and a title. Perhaps we might also want to
    replace the scientific notation on the x-axis with the dollar value it actually
    represents. We can do both of these things quite easily. Let’s take care of the
    scale first. The labels on the tick-marks can be controlled through the `scale_`
    functions. While it’s possible to roll your own function to label axes (or just
    supply your labels manually, as we will see later), there’s also a handy `scales`
    library that contains some useful pre-made formatting functions. We can either
    load the whole library with `library(scales)` or, more conveniently, just grab
    the specific formatter we want from that library. Here it’s the `dollar()` function.
    To grab a function directly from a library we have not loaded, we use the syntax
    `thelibrary::thefunction`. So, we can do this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果我们的目标只是使用合理的尺度绘制预期寿命与GDP的图表，并添加一个平滑器，我们可能会考虑通过更漂亮的轴标签和标题来润色这个图表。也许我们还想将x轴上的科学记数法替换为它实际代表的美元价值。我们可以非常容易地完成这两件事。首先，让我们处理一下尺度。刻度线上的标签可以通过`scale_`函数来控制。虽然你可以自己编写一个函数来标记轴（或者像我们稍后将要看到的那样，手动提供标签），但还有一个方便的`scales`库，其中包含一些有用的预定义格式化函数。我们可以通过`library(scales)`加载整个库，或者更方便地，直接从库中获取我们想要的特定格式化器。这里是我们需要的`dollar()`函数。要从尚未加载的库中直接获取一个函数，我们使用语法`thelibrary::thefunction`。因此，我们可以这样做：
- en: '![Life Expectancy vs GDP scatterplot, with a GAM smoother and a log scale on
    the x-axis, with better labels on the tick marks.](../Images/52f0a9f105ac6e60c79d2503c117395d.png)
    Figure 3.9: Life Expectancy vs GDP scatterplot, with a GAM smoother and a log
    scale on the x-axis, with better labels on the tick marks.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![预期寿命与GDP散点图，带有GAM平滑器和x轴上的对数尺度，以及更好的刻度线标签。](../Images/52f0a9f105ac6e60c79d2503c117395d.png)
    图3.9：预期寿命与GDP散点图，带有GAM平滑器和x轴上的对数尺度，以及更好的刻度线标签。'
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will learn more about scale transformations later. For now, just remember
    two things about them. First, you can directly transform your x or y axis by adding
    something like `scale_x_log10()` or `scale_y_log10()` to your plot. When you do
    so, the x or y axis will be transformed and, by default, the tick marks on the
    axis will be labeled using scientific notation. Second, you can give these `scale_`
    functions a `labels` argument that reformats the text printed underneath the tick
    marks on the axes. Inside the `scale_x_log10()` function try `labels=scales::comma`,
    for example.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后学习更多关于尺度变换的内容。现在，只需记住关于它们的两点。首先，你可以通过添加类似`scale_x_log10()`或`scale_y_log10()`的东西直接转换你的x或y轴。当你这样做的时候，x或y轴将被转换，并且默认情况下，轴上的刻度线将使用科学记数法进行标记。其次，你可以给这些`scale_`函数一个`labels`参数，该参数会重新格式化轴下方的刻度线上的文本。例如，在`scale_x_log10()`函数中尝试`labels=scales::comma`。
- en: 3.5 Mapping aesthetics vs setting them
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 映射美学与设置它们
- en: 'An *aesthetic mapping* specifies that a variable will be expressed by one of
    the available visual elements, such as size, or color, or shape, and so on. As
    we’ve seen, we map variables to aesthetics like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一种*美学映射*指定了一个变量将通过可用的视觉元素之一来表示，例如大小、颜色、形状等。正如我们所看到的，我们将变量映射到美学上，如下所示：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This code does *not* give a direct instruction like “color the points purple”.
    Instead it says, “the property ‘color’ will represent the variable `continent`”,
    or “color will map `continent`”. If we want to turn all the points in the figure
    purple, we do *not* do it through the mapping function. Look at what happens when
    we try:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并没有给出像“将点染成紫色”这样的直接指令。相反，它说，“属性‘颜色’将代表变量`continent`”，或者“颜色将映射`continent`”。如果我们想将图中的所有点都染成紫色，我们不是通过映射函数来做的。看看当我们尝试这样做时会发生什么：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Figure 3.10: What has gone wrong here?'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10：这里出了什么问题？
- en: '![What has gone wrong here?](../Images/5cf321e8ee5046c7708138606531ccb1.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![这里出了什么问题？](../Images/5cf321e8ee5046c7708138606531ccb1.png)'
- en: What has happened here? Why is there a legend saying “purple”? And why have
    the points all turned pinkish-red instead of purple? Remember, an aesthetic is
    a mapping of variables in your data to properties you can see on the graph. The
    `aes()` function is where that mapping is specified, and the function is trying
    to do its job. It wants to map a variable to the color aesthetic, so it assumes
    you are giving it a variable.Just as in Chapter 1, when we were able to write
    ‘`my_numbers + 1`’ to add one to each element of the vector. We have only given
    it one word, though—“purple”. Still, `aes()` will do its best to treat that word
    as though it were a variable. A variable should have as many observations as there
    are rows in the data, so `aes()` falls back on R’s recycling rules for making
    vectors of different lengths match up.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？为什么有一个传说说是“紫色”？而且为什么点都变成了粉红色而不是紫色？记住，美学是将你的数据中的变量映射到你在图上可以看到的属性。`aes()`函数就是在这里指定映射的地方，这个函数正在尽力完成它的任务。它想要将一个变量映射到颜色美学，所以它假设你给它的是一个变量。就像第一章中我们能够写‘`my_numbers
    + 1`’来给向量的每个元素加一一样。尽管如此，我们只给了它一个单词——“紫色”。然而，`aes()`仍然会尽力将这个单词当作一个变量来处理。一个变量应该有与数据行数一样多的观测值，所以`aes()`会回退到R的回收规则，以便使不同长度的向量匹配。
- en: In effect, this creates a new categorical variable for your data. The string
    “purple” is recycled for every row of your data. Now you have a new column. Every
    element in it has the same value, “purple”. Then ggplot plots the results on the
    graph as you’ve asked it to, by mapping it to the `color` aesthetic. It dutifully
    makes a legend for this new variable. By default, ggplot displays the points falling
    into the category “purple” (which is all of them) using its default first-category
    hue … which is red.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这为你的数据创建了一个新的分类变量。字符串“紫色”被循环用于你的数据中的每一行。现在你有一个新列。它里面的每个元素都有相同的值，“紫色”。然后ggplot按照你要求的方式在图上绘制结果，通过将其映射到`color`美学。它尽职尽责地为这个新变量制作了一个图例。默认情况下，ggplot使用其默认的第一类别色调显示属于“紫色”类别（即所有点）的点……这个色调是红色。
- en: 'The `aes()` function is for mappings only. Do not use it to change properties
    to a particular value. If we want to *set* a property, we do it in the `geom_`
    we are using, and *outside* the `mapping = aes(...)` step. Try this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`aes()`函数仅用于映射。不要用它来将属性设置为特定值。如果我们想要*设置*一个属性，我们就在我们使用的`geom_`中做，并且在`mapping
    = aes(...)`步骤*之外*做。试试这个：'
- en: '![Setting the color attribute of the points directly.](../Images/4a637ca648cb8a2b5edf8ddbb6e5988a.png)
    Figure 3.11: Setting the color attribute of the points directly.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![直接设置点的颜色属性。](../Images/4a637ca648cb8a2b5edf8ddbb6e5988a.png) 图3.11：直接设置点的颜色属性。'
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `geom_point()` function can take a `color` argument directly, and R knows
    what color “purple” is. This is not part of the aesthetic mapping that defines
    the basic structure of the graphic. From the point of view of the grammar or logic
    of the graph, the fact that the points are colored purple has no significance.
    The color purple is not representing or mapping a variable or feature of the data
    in the relevant way.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`geom_point()`函数可以直接接受`color`参数，R知道“紫色”是什么颜色。这并不是定义图形基本结构的审美映射的一部分。从图形的语法或逻辑角度来看，点被涂成紫色的事实没有任何意义。紫色并没有以相关的方式代表或映射数据中的变量或特征。'
- en: '![Setting some other arguments.](../Images/db844341dc1449fb34c26dfe215020f0.png)
    Figure 3.12: Setting some other arguments.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![设置一些其他参数。](../Images/db844341dc1449fb34c26dfe215020f0.png) 图3.12：设置一些其他参数。'
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The various `geom_` functions can take many other arguments that will affect
    how the plot looks, but that do not involve mapping variables to aesthetic elements.
    Thus, those arguments will never go inside the `aes()` function. Some of the things
    we will want to set, like color or size, have the same name as mappable elements.
    Others, like the `method` or `se` arguments in `geom_smooth()` affect other aspects
    of the plot. In the code for Figure [3.12](makeplot.html#fig:ch-03-fig-lexp-gdp-09),
    the `geom_smooth()` call sets the line color to orange and sets its size (i.e.,
    thickness) to 8, an unreasonably large value. We also turn off the `se` option
    by switching it from its default value of `TRUE` to `FALSE`. The result is that
    the standard error ribbon is not shown.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 各种`geom_`函数可以接受许多其他会影响图表外观的参数，但不涉及将变量映射到美学元素。因此，这些参数永远不会放入`aes()`函数中。我们想要设置的一些事情，如颜色或大小，与可映射元素具有相同的名称。其他，如`geom_smooth()`中的`method`或`se`参数，影响图表的其他方面。在图[3.12](makeplot.html#fig:ch-03-fig-lexp-gdp-09)的代码中，`geom_smooth()`调用将线条颜色设置为橙色，并将其大小（即厚度）设置为8，这是一个不合理的较大值。我们还通过将其从默认值`TRUE`切换到`FALSE`来关闭`se`选项。结果是标准误差带不会显示。
- en: MeanwhileIt’s also possible to map a continuous variable directly to the alpha
    property, much like one might map a continuous variable to a single-color gradient.
    However, this is generally not an effective way of precisely conveying variation
    in quantity. in the `geom_smooth()` call we set the `alpha` argument to 0.3\.
    Like color, size, and shape, “alpha” is an aesthetic property that points (and
    some other plot elements) have, and to which variables can be mapped. It controls
    how transparent the object will appear when drawn. It’s measured on a scale of
    zero to one. An object with an alpha of zero will be completely transparent. Setting
    it to zero will make any other mappings the object might have, such as color or
    size, invisible as well. An object with an alpha of one will be completely opaque.
    Choosing an intermediate value can be useful when there is a lot of overlapping
    data to plot, as it makes it easier to see where the bulk of the observations
    are located.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，也可以直接将连续变量映射到`alpha`属性，就像人们可能会将连续变量映射到单色渐变一样。然而，这通常不是精确传达数量变化的有效方式。在`geom_smooth()`调用中，我们将`alpha`参数设置为0.3。和颜色、大小和形状一样，“alpha”是点（以及一些其他图表元素）具有的美学属性，并且可以将变量映射到它。它控制着绘制对象时的透明度。它是在零到一的比例上测量的。alpha值为零的对象将完全透明。将其设置为零将使对象可能具有的其他映射（如颜色或大小）也变得不可见。alpha值为一的对象将完全不透明。当有大量重叠数据需要绘制时，选择中间值可能很有用，因为它使得观察到的主体位置更容易看到。
- en: '![A more polished plot of Life Expectancy vs GDP.](../Images/528814bf005572e3aa69ff08fea67934.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![寿命与GDP对比的更加精致的图表](../Images/528814bf005572e3aa69ff08fea67934.png)'
- en: 'Figure 3.13: A more polished plot of Life Expectancy vs GDP.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13：寿命与GDP对比的更加精致的图表。
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can now make a reasonably polished plot. We set the `alpha` of the points
    to a low value, make nicer x- and y-axis labels, and add a title, subtitle, and
    caption. As you can see in the code above, in addition to `x`, `y`, and any other
    aesthetic mappings in your plot (such as `size`, `fill`, or `color`), the `labs()`
    function can also set the text for `title`, `subtitle`, and `caption`. It controls
    the *main labels* of scales. The appearance of things like axis tick marks are
    the responsibility of various `scale_` functions, such as the `scale_x_log10()`
    function used here. We will learn more about what can be done with `scale_` functions
    soon.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以制作一个相当精致的图表。我们将点的`alpha`值设置为低值，使x轴和y轴的标签更加美观，并添加了标题、副标题和图注。如上代码所示，除了`x`、`y`以及你图表中可能的其他美学映射（如`size`、`fill`或`color`）之外，`labs()`函数还可以设置`title`、`subtitle`和`caption`的文本。它控制着刻度的主要标签。诸如轴刻度标记等事物的外观是各种`scale_`函数的责任，例如这里使用的`scale_x_log10()`函数。我们很快就会了解到`scale_`函数可以做什么。
- en: Are there any variables in our data that can sensibly be mapped to the `color`
    aesthetic? Consider `continent`. In Figure [3.14](makeplot.html#fig:ch-03-fig-lexp-gdp-11)
    the individual data points have been colored by `continent`, and a legend with
    a key to the colors has automatically been added to the plot. In addition, instead
    of one smoothing line we now have five. There is one for each unique value of
    the `continent` variable. This is a consequence of the way aesthetic mappings
    are inherited. Along with `x` and `y`, the `color` aesthetic mapping is set in
    the call to `ggplot()` that we used to creat the `p` object. Unless told otherwise,
    all geoms layered on top of the original plot object will inherit that object’s
    mappings. In this case we get both our points and smoothers colored by continent.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据中，是否有任何变量可以合理地映射到`颜色`美学？考虑`大陆`。在图[3.14](makeplot.html#fig:ch-03-fig-lexp-gdp-11)中，各个数据点已经根据`大陆`进行了着色，并且自动添加了一个带有颜色键的图例。此外，现在我们不再只有一条平滑线，而是有五条。每一条对应于`大陆`变量的唯一值。这是美学映射继承方式的结果。除了`x`和`y`之外，`颜色`美学映射是在调用`ggplot()`时设置的，我们用它来创建`p`对象。除非另有说明，否则所有叠加在原始绘图对象上的几何对象都将继承该对象的映射。在这种情况下，我们得到了既有点又有根据大陆着色的平滑线。
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![Mapping the continent variable to the color aesthetic.](../Images/a0fd0b66ad62e23457edd70756fa6d2a.png)
    Figure 3.14: Mapping the continent variable to the color aesthetic.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![将大陆变量映射到颜色美学。](../Images/a0fd0b66ad62e23457edd70756fa6d2a.png) 图3.14：将大陆变量映射到颜色美学。'
- en: If it is what we want, then we might also consider shading the standard error
    ribbon of each line to match its dominant color. The color of the standard error
    ribbon is controlled by the `fill` aesthetic. Whereas the `color` aesthetic affects
    the appearance of lines and points, `fill` is for the filled areas of bars, polygons
    and, in this case, the interior of the smoother’s standard error ribbon.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这正是我们想要的，那么我们还可以考虑将每条线的标准误差带阴影，以匹配其主导颜色。标准误差带的颜色由`fill`美学控制。而`color`美学影响线条和点的外观，`fill`用于条形、多边形以及在这种情况下平滑线标准误差带的内部填充区域。
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Mapping the continent variable to the color aesthetic, and correcting the
    error bars using the fill aesthetic.](../Images/d0fac1d82d45ee7eaabdec2d69bb1a77.png)
    Figure 3.15: Mapping the continent variable to the color aesthetic, and correcting
    the error bars using the fill aesthetic.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![将大陆变量映射到颜色美学，并使用填充美学更正误差条。](../Images/d0fac1d82d45ee7eaabdec2d69bb1a77.png)
    图3.15：将大陆变量映射到颜色美学，并使用填充美学更正误差条。'
- en: Making sure that color and fill aesthetics match up consistently in this way
    improves the overall look of the plot. In order to make it happen we just need
    to specify that the mappings are to the same variable in each case.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 确保颜色和填充美学以这种方式一致匹配，可以改善整个图表的外观。为了实现这一点，我们只需要指定每种情况下的映射都指向相同的变量。
- en: 3.6 Aesthetics can be mapped per geom
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 每个几何对象可以映射美学
- en: Perhaps five separate smoothers is too many, and we just want one line. But
    we still would like to have the points color-coded by continent. By default, geoms
    inherit their mappings from the `ggplot()` function. We can change this by mapping
    the aesthetics we want only the `geom_` functions that we want them to apply to.
    We use the same `mapping = aes(...)` expression as in the initial call to `ggplot()`,
    but now use it in the `geom_` functions as well, specifying only the mappings
    we want to apply to each one. Mappings specified only in the initial `ggplot()`
    function—here, `x` and `y`—will carry through to all subsequent geoms.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 也许五个单独的平滑线太多了，我们只想有一条线。但我们仍然希望点根据大陆进行着色。默认情况下，几何对象从`ggplot()`函数继承它们的映射。我们可以通过只映射我们想要应用于特定`geom_`函数的美学来改变这一点。我们使用与初始`ggplot()`调用相同的`mapping
    = aes(...)`表达式，但现在在`geom_`函数中也使用它，只指定我们想要应用于每个对象的映射。仅在初始`ggplot()`函数中指定的映射——这里，`x`和`y`——将传递到所有后续的几何对象中。
- en: '![Mapping aesthetics on a per-geom basis. Here color is mapped to continent
    for the points but not the smoother.](../Images/84973e15698acc2a6756470dedb62db6.png)
    Figure 3.16: Mapping aesthetics on a per-geom basis. Here color is mapped to continent
    for the points but not the smoother.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![基于每个几何对象映射美学。这里颜色映射到大陆用于点，但不用于平滑线。](../Images/84973e15698acc2a6756470dedb62db6.png)
    图3.16：基于每个几何对象映射美学。这里颜色映射到大陆用于点，但不用于平滑线。'
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It’s possible to map continuous variables to the `color` aesthetic, too. For
    example, we can map the log of each country-year’s population (`pop`) to `color`.
    (We can take the log of population right in the `aes()` statement, using the `log()`
    function. R will evaluate this for us quite happily.) When we do this, ggplot
    produces a gradient scale. It is continuous, but marked at intervals in the legend.
    Depending on the circumstances, mapping quantities like population to a continuous
    color gradient may be more or less effective than cutting the variable into categorical
    bins running, e.g., from low to high. In general it is always worth looking at
    the data in its continuous form first rather than cutting or binning it into categories.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将连续变量映射到`颜色`美学也是可能的。例如，我们可以将每个国家-年份的人口（`pop`）的对数映射到`颜色`。（我们可以在`aes()`语句中直接对人口取对数，使用`log()`函数。R会非常乐意为我们评估这个值。）当我们这样做时，ggplot会产生一个渐变刻度。它是连续的，但在图例中以间隔标记。根据具体情况，将人口等数量映射到连续的颜色渐变可能比将其切割成从低到高的分类变量更有效或更无效。一般来说，总是值得首先查看数据的连续形式，而不是将其切割或分箱到类别中。
- en: '![Mapping a continuous variable to color.](../Images/b6fa2af5be9bb0293878a97e7fc2b565.png)
    Figure 3.17: Mapping a continuous variable to color.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![将连续变量映射到颜色](../Images/b6fa2af5be9bb0293878a97e7fc2b565.png) 图3.17：将连续变量映射到颜色。'
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Finally, it is worth paying a little more attention to the way that ggplot draws
    its scales. Because every mapped variable has a scale, we can learn a lot about
    how a plot has been constructed, and what mappings it contains, by seeing what
    the legends look like. For example, take a closer look at the legends produced
    in Figures [3.15](makeplot.html#fig:ch-03-fig-lexp-gdp-12) and [3.16](makeplot.html#fig:ch-03-fig-lexp-gdp-13).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得稍微更多关注ggplot绘制刻度的方法。因为每个映射的变量都有一个刻度，通过观察图例的样式，我们可以了解很多关于图表是如何构建的，以及它包含哪些映射的信息。例如，仔细观察图3.15[makeplot.html#fig:ch-03-fig-lexp-gdp-12]和图3.16[makeplot.html#fig:ch-03-fig-lexp-gdp-13]生成的图例。
- en: 'Figure 3.18: Guides and legends faithfully reflect the mappings they represent.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18：指南和图例忠实反映它们所代表的映射。
- en: '![Guides and legends faithfully reflect the mappings they represent.](../Images/6e57e4eaeef8b9c1c8396189614f7471.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![指南和图例忠实反映它们所代表的映射](../Images/6e57e4eaeef8b9c1c8396189614f7471.png)'
- en: 'In the legend for the first figure, shown here on the left, we see several
    visual elements. The key for each continent shows a dot, a line, and a shaded
    background. The key for the second figure, shown on the right, has only a dot
    for each continent, with no shaded background or line. If you look again at the
    code for Figures [3.15](makeplot.html#fig:ch-03-fig-lexp-gdp-12) and [3.16](makeplot.html#fig:ch-03-fig-lexp-gdp-13),
    you will see that in the first case we mapped the `continent` variable to both
    `color` and `fill`. We then drew the figure with `geom_point()` and fitted a line
    for each continent with `geom_smooth()`. Points have `color` but the smoother
    understands both `color` (for the line itself) and `fill` (for the shaded standard
    error ribbon). Each of these elements is represented in the legend: the point
    color, the line color, and the ribbon fill. In the second figure, we decided to
    simplify things by having only the points be colored by `continent`. Then we drew
    just a single smoother for the whole graph. Thus, in the legend for that figure,
    the colored line and the shaded box are both absent. We only see a legend for
    the mapping of `color` to `continent` in `geom_point()`. Meanwhile on the graph
    itself the line drawn by `geom_smooth()` is set by default to a bright blue, different
    from anything on the scale, and its shaded error ribbon is set by default to gray.
    Small details like this are not accidents. They are a direct consequence of ggplot’s
    grammatical way of thinking about the relationship between the data behind the
    plot and the visual elements that represent it.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个图形的图例中，如图左所示，我们可以看到几个视觉元素。每个大陆的关键显示一个点、一条线和阴影背景。第二个图形的图例，如图右所示，每个大陆只有一个点，没有阴影背景或线条。如果您再次查看图形[3.15](makeplot.html#fig:ch-03-fig-lexp-gdp-12)和[3.16](makeplot.html#fig:ch-03-fig-lexp-gdp-13)的代码，您将看到在第一种情况下，我们将`continent`变量映射到`color`和`fill`。然后我们使用`geom_point()`绘制图形，并使用`geom_smooth()`为每个大陆拟合一条线。点有`color`，但平滑器理解`color`（用于线条本身）和`fill`（用于阴影标准误差带）。这些元素都在图例中有所表示：点的颜色、线的颜色和带子的填充。在第二个图形中，我们决定通过仅让点根据`continent`着色来简化事情。然后我们只为整个图形绘制了一个单一的平滑器。因此，在该图形的图例中，彩色线条和阴影框都消失了。我们只看到了`geom_point()`中`color`到`continent`映射的图例。同时，在图形本身中，`geom_smooth()`绘制的线条默认设置为明亮的蓝色，与刻度上的任何东西都不同，其阴影误差带默认设置为灰色。这样的小细节并非偶然。这是ggplot直接从数据背后的关系和表示它的视觉元素之间的语法方式思考的直接后果。
- en: 3.7 Save your work
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7 保存您的作品
- en: 'Now that you have started to make your own plots, you may be wondering how
    to save them, and perhaps also how to control their size and format. If you are
    working in an RMarkdown document then the plots you make will be embedded in it,
    as we have already seen. You can set the default size of plots within your `.Rmd`
    document by setting an option in your first code chunk. This one tells R to make
    8x5 figures:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经开始制作自己的图形，您可能想知道如何保存它们，也许还想知道如何控制它们的大小和格式。如果您在RMarkdown文档中工作，那么您制作的图形将嵌入其中，正如我们之前看到的。您可以通过设置第一个代码块中的选项来设置`.Rmd`文档中图形的默认大小。这个选项告诉R制作8x5的图形：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Because you will be making plots of different sizes and shapes, sometimes you
    will want to control the size of particular plots, without changing the default.
    To do this, you can add the same options to any particular chunk inside the curly
    braces at the beginning. Remember, each chunk opens with three backticks and then
    a pair of braces containing the language name (for us always `r`) and an optional
    label:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您将制作不同大小和形状的图形，有时您可能想要控制特定图形的大小，而不改变默认设置。为此，您可以在开头花括号内添加相同的选项到任何特定的块中。记住，每个块以三个反引号开头，然后是一对花括号，包含语言名称（对我们来说总是`r`）和一个可选的标签：
- en: '[PRE23]{r example}'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE23]{r example}'
- en: p + geom_point()
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: p + geom_point()
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can follow the label with a comma and provide a series of options if needed.
    They will apply only to that chunk. To make a figure twelve inches wide and nine
    inches high we say e.g. `{r example, fig.width = 12, fig.height = 9}` in the braces
    section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在标签后跟一个逗号，并在需要时提供一系列选项。它们将仅适用于该块。例如，要制作一个12英寸宽、9英寸高的图形，我们在花括号部分说 `{r example,
    fig.width = 12, fig.height = 9}`。
- en: 'You will often need to save your figures individually, as they will end up
    being dropped into slides or published in papers that are not produced using RMarkdown.
    Saving a figure to a file can be done in several different ways. When working
    with `ggplot`, the easiest way is to use the `ggsave()` function. To save the
    most recently displayed figure, we provide the name we want to save it under:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常会需要单独保存你的图表，因为它们最终会被放入幻灯片或发表在未使用RMarkdown生成的论文中。将图表保存到文件中可以通过几种不同的方式完成。当使用`ggplot`时，最简单的方法是使用`ggsave()`函数。为了保存最近显示的图表，我们提供我们想要保存的名称：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'ThisSeveral other file formats are available as well. See the function’s help
    page for details. will save the figure as a PNG file, a format suitable for displaying
    on web pages. If you want a PDF instead, change the extension of the file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把图表保存为PNG文件，这是一种适合在网页上显示的格式。如果你想要PDF格式，请更改文件的扩展名：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Remember that, for convenience, you do not need to write `filename =` as long
    as the name of the file is the first argument you give `ggsave()`. You can also
    pass plot objects to `ggsave()`. For example, we can put our recent plot into
    an object called `p_out` and then tell `ggave()` that we want to save that object.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，为了方便，只要文件的名称是你提供给`ggsave()`的第一个参数，你就不需要写`filename =`。你还可以将绘图对象传递给`ggsave()`。例如，我们可以将我们的最新绘图放入一个名为`p_out`的对象中，然后告诉`ggave()`我们想要保存该对象。
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When saving your work, it is sensible to have a subfolder (or more than one,
    depending on the project) where you save only figures. You should also take care
    to name your saved figures in a sensible way. `fig_1.pdf` or `my_figure.pdf` are
    not good names. Figure names should be compact but descriptive, and consistent
    between figures within a project. In addition, although it really shouldn’t be
    the case in this day and age, it is also wise to play it safe and avoid file names
    containing characters likely to make your code choke in future. These include
    apostrophes, backticks, spaces, forward and back slashes, and quotes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当保存你的工作的时候，有一个只保存图表的子文件夹（或者根据项目需要，可以有一个以上的子文件夹）是明智的。你还应该注意以合理的方式命名你保存的图表。`fig_1.pdf`或`my_figure.pdf`都不是好的名字。图表的名称应该是紧凑且描述性的，并且在项目内的图表之间保持一致。此外，尽管在当今时代这真的不应该发生，但为了避免文件名包含未来可能导致你的代码出错的字符，采取安全措施也是明智的。这些包括撇号、反引号、空格、前后斜杠和引号。
- en: 'The Appendix contains a short discussion of how to organize your files within
    your project folder. Treat the project folder as the home base of your work for
    the paper or work you are doing, and put your data and figures in subfolders within
    the project folder. To begin with, using your file manager, create a folder named
    “figures” inside your project folder. When saving figures, you can use Kirill
    Müller’s handy `here` library to make it easier to work with files and subfolders
    while not having to type in full file paths. Load the library in the setup chunk
    of your RMarkdown document. When you do, it tells you where “here” is for the
    current project. You will see a message saying something like this, with your
    file path and user name instead of mine:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 附录中简要讨论了如何在项目文件夹内组织你的文件。将项目文件夹视为你撰写论文或进行工作的基地，并将你的数据和图表放在项目文件夹内的子文件夹中。首先，使用你的文件管理器，在项目文件夹内创建一个名为“figures”的文件夹。当保存图表时，你可以使用Kirill
    Müller的便捷的`here`库来使处理文件和子文件夹变得更加容易，而无需输入完整的文件路径。在RMarkdown文档的设置块中加载该库。当你这样做时，它会告诉你当前项目中的“here”在哪里。你会看到一个类似的消息，用你的文件路径和用户名代替我的：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can then use the `here()` function to make loading and saving your work
    more straightforward and safer. Assuming a folder named “figures” exists in your
    project folder, you can do this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用`here()`函数使加载和保存你的工作更加直接和安全。假设在你的项目文件夹中存在一个名为“figures”的文件夹，你可以这样做：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This saves `p_out` as a file called `lifeexp_vs_gdp_gradient.pdf` in the `figures`
    directory *here*, i.e. in your current project folder.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`figures`目录*此处*保存`p_out`为名为`lifeexp_vs_gdp_gradient.pdf`的文件，即在你的当前项目文件夹中。
- en: You can save your figure in a variety of different formats, depending on your
    needs (and also, to a lesser extent, on your particular computer system). The
    most important distinction to bear in mind is between *vector* formats and *raster*
    formats. A file with a *vector* format, like PDF or SVG, is stored as a set of
    instructions about lines, shapes, colors, and their relationships. The viewing
    software (such as Adobe Acrobat or Apple’s Preview application for PDFs) then
    interprets those instructions and displays the figure. Representing the figure
    this way allows it to be easily resized without becoming distorted. The underlying
    language of the PDF format is Postscript, which is also the language of modern
    typesetting and printing. This makes a vector-based format like PDF the best choice
    for submission to journals.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的需求（以及在一定程度上，你的特定计算机系统），你可以以多种不同的格式保存你的图形。需要记住的最重要区别是 *矢量* 格式和 *栅格* 格式。具有
    *矢量* 格式的文件，如 PDF 或 SVG，存储为关于线条、形状、颜色及其关系的指令集。然后查看软件（如 Adobe Acrobat 或苹果的预览应用用于
    PDF）解释这些指令并显示图形。以这种方式表示图形允许它轻松地调整大小而不会变形。PDF 格式的底层语言是 Postscript，这也是现代排版和印刷的语言。这使得基于矢量的格式如
    PDF 成为提交给期刊的最佳选择。
- en: A *raster* based format, on the other hand, stores images essentially as a grid
    of pixels of a pre-defined size with information about the location, color, brightness,
    and so on of each pixel in the grid. This makes for more efficient storage, especially
    when used in conjunction with compression methods that take advantage of redundancy
    in images in order to save space. Formats like JPG are compressed raster formats.
    A PNG file is a raster image format that supports lossless compression. For graphs
    containing an awful lot of data, PNG files will tend to be much smaller than the
    corresponding PDF. However, raster formats cannot be easily resized. In particular
    they cannot be expanded in size without becoming pixelated or grainy. Formats
    like JPG and PNG are the standard way that images are displayed on the web. The
    more recent SVG format is vector-based format but also nevertheless supported
    by many web browsers.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，基于 *栅格* 的格式将图像基本上存储为具有预定义大小的像素网格，以及关于网格中每个像素的位置、颜色、亮度等信息。这使得存储更加高效，尤其是在与利用图像冗余来节省空间的压缩方法结合使用时。像
    JPG 这样的格式是压缩的栅格格式。PNG 文件是一种支持无损压缩的栅格图像格式。对于包含大量数据的图形，PNG 文件通常比相应的 PDF 文件小得多。然而，栅格格式不能轻易调整大小。特别是，它们不能在不像素化或出现颗粒感的情况下扩大尺寸。像
    JPG 和 PNG 这样的格式是图像在网络上显示的标准方式。较新的 SVG 格式是基于矢量的格式，但仍然被许多网络浏览器支持。
- en: In general you should save your work in several different formats. When you
    save in different formats and in different sizes you may need to experiment with
    the scaling of the plot and the size of the fonts in order to get a good result.
    The `scale` argument to `ggsave()` can help you here (you can try out different
    values, like `scale=1.3`, `scale=5`, and so on). You can also use `ggave()` to
    explicitly set the height and width of your plot in the units that you choose.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你应该以几种不同的格式保存你的工作。当你以不同的格式和大小保存时，你可能需要尝试调整图形的缩放和字体的大小，以获得良好的结果。`ggsave()`
    函数的 `scale` 参数可以在这里帮助你（你可以尝试不同的值，如 `scale=1.3`、`scale=5` 等）。你也可以使用 `ggave()` 显式设置你的图形的高度和宽度，使用你选择的单位。
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now that you know how to do that, let’s get back to making more graphs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何做到这一点，让我们回到制作更多图形。
- en: 3.8 Where to go next
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.8 接下来去哪里
- en: Start by playing around with the `gapminder` data a little more. You can try
    each of these explorations with `geom_point()` and then with `geom_smooth()`,
    or both together.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尝试对 `gapminder` 数据进行更多探索。你可以尝试使用 `geom_point()` 和 `geom_smooth()` 进行每个探索，或者两者一起使用。
- en: What happens when you put the `geom_smooth()` function before `geom_point()`
    instead of after it? What does this tell you about how the plot is drawn? Think
    about how this might be useful when drawing plots.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你在 `geom_point()` 之前而不是之后放置 `geom_smooth()` 函数时会发生什么？这会告诉你关于绘图方式的哪些信息？考虑一下这可能在绘制图形时如何有用。
- en: Change the mappings in the `aes()` function so that you plot Life Expectancy
    against population (`pop`) rather than per capita GDP. What does that look like?
    What does it tell you about the unit of observation in the dataset?
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `aes()` 函数中更改映射，以便你绘制预期寿命与人口（`pop`）之间的关系，而不是人均 GDP。这看起来会是什么样子？这会告诉你关于数据集中观测单位的哪些信息？
- en: Try some alternative scale mappings. Besides `scale_x_log10()` you can try `scale_x_sqrt()`
    and `scale_x_reverse()`. There are corresponding functions for y-axis transformations.
    Just write `y` instead of `x`. Experiment with them to see what sort of effect
    they have on the plot, and whether they make any sense to use.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试一些不同的尺度映射。除了`scale_x_log10()`之外，你还可以尝试`scale_x_sqrt()`和`scale_x_reverse()`。对于y轴变换也有相应的函数。只需将`y`而不是`x`写入即可。实验它们以查看它们对图表有什么样的影响，以及它们是否值得使用。
- en: What happens if you map `color` to `year` instead of `continent`? Is the result
    what you expected? Think about what class of object `year` is. Remember you can
    get a quick look at the top of the data, which includes some shorthand information
    on the class of each variable, by typing `gapminder`.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你将`颜色`映射到`年份`而不是`大陆`，会发生什么？结果是你预期的吗？思考一下`年份`是哪种类型的对象。记住，你可以通过输入`gapminder`来快速查看数据的顶部，这包括一些关于每个变量类别的简短信息。
- en: Instead of mapping `color = year`, what happens if you try `color = factor(year)`?
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你尝试`color = factor(year)`而不是`color = year`，会发生什么？
- en: As you look at these different scatterplots, think about Figure [3.13](makeplot.html#fig:ch-03-fig-lexp-gdp-10)
    a little more critically. We worked it up to the point where it was reasonably
    polished, but is it really the best way to display this country-year data? What
    are we gaining and losing by ignoring the temporal and country-level structure
    of the data? How could we do better? Sketch out what an alternative visualization
    might look like.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你查看这些不同的散点图时，更批判性地思考一下图[3.13](makeplot.html#fig:ch-03-fig-lexp-gdp-10)。我们把它做到相当精致的程度，但这是否真的是展示这种国家-年份数据的最佳方式？通过忽略数据的时序和国家层面结构，我们得到了什么，失去了什么？我们如何做得更好？勾勒出一种可能的替代可视化可能的样子。
- en: As you begin to experiment, remember two things. First, it’s always worth trying
    something, even if you’re not sure what’s going to happen. Don’t be afraid of
    the console.This license does not extend to, for example, overwriting or deleting
    your data by mistake. You should still manage your project responsibly, at a minimum
    keeping good backups. But within R and at the level of experimenting with graphs
    at the console, you have a lot of freedom. The nice thing about making your graphics
    through code is that you won’t break anything you can’t reproduce. If something
    doesn’t work, you can figure out what happened, fix things, and re-run the code
    to make the graph again.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始尝试时，请记住两件事。首先，尝试任何事情总是值得的，即使你不确定会发生什么。不要害怕控制台。这个许可证不适用于，例如，错误地覆盖或删除你的数据。你仍然应该负责任地管理你的项目，至少要保留良好的备份。但在R中，在控制台进行图形实验的层面上，你有很多自由。通过代码制作图形的好处是，你不会破坏你无法重现的东西。如果某件事不起作用，你可以找出发生了什么，修复问题，然后重新运行代码来再次生成图形。
- en: Second, remember that the main flow of action in ggplot is always the same.
    You start with a table of data, you map the variables you want to display to aesthetics
    like position, color, or shape, and you choose one or more geoms to draw the graph.
    In your code this gets accomplished by making an object with the basic information
    about data and mappings, and then adding or layering additional information as
    needed. Once you get used to this way of thinking about your plots, especially
    the aesthetic mapping part, then drawing them becomes easier. Instead of having
    to think about how to draw particular shapes or colors on the screen, the many
    `geom_` functions take care of that for you. In the same way, learning new geoms
    is easier once you think of them as ways to display aesthetic mappings that you
    specify. Most of the learning curve with ggplot involves getting used to this
    way of thinking about your data and its representation in a plot. In the next
    chapter, we will flesh out these ideas a little more, cover some common ways plots
    go “wrong” (i.e., when they end up looking strange), and learn how to recognize
    and avoid those problems.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，记住ggplot的主要操作流程始终如一。你从一个数据表开始，将你想要显示的变量映射到美学属性，如位置、颜色或形状，并选择一个或多个几何对象来绘制图形。在你的代码中，这是通过创建一个包含基本数据信息和映射信息的对象来实现的，然后根据需要添加或叠加额外的信息。一旦你习惯了这种思考图表的方式，特别是美学映射部分，绘制它们就会变得更容易。你不需要考虑如何在屏幕上绘制特定的形状或颜色，许多`geom_`函数会为你处理这些。同样，一旦你将它们视为显示你指定的美学映射的方式，学习新的几何对象也会变得更容易。ggplot的大部分学习曲线都涉及习惯以这种方式思考你的数据和它在图表中的表示。在下一章中，我们将更详细地阐述这些观点，讨论一些常见的绘图错误（即它们最终看起来很奇怪的情况），并学习如何识别和避免这些问题。
- en: 3.1 How ggplot works
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 ggplot的工作原理
- en: As we saw in Chapter [1](lookatdata.html#lookatdata), visualization involves
    representing your data data using lines or shapes or colors and so on. There is
    some structured relationship, some *mapping*, between the variables in your data
    and their representation in the plot displayed on your screen or on the page.
    We also saw that not all mappings make sense for all types of variables, and (independently
    of this), some representations are harder to interpret than others. Ggplot provides
    you with a set of tools to map data to visual elements on your plot, to specify
    the kind of plot you want, and then subsquently to control the fine details of
    how it will be displayed. Figure [3.1](makeplot.html#fig:ggplot-flow) shows a
    schematic outline of the process starting from data, at the top, down to a finished
    plot at the bottom. Don’t worry about the details for now. We will be doing into
    them one piece at a time over the next few chapters.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第[1](lookatdata.html#lookatdata)章中看到的，可视化涉及使用线条、形状或颜色等来表示你的数据。数据中的变量与它们在屏幕上或页面显示的图表中的表示之间存在某种结构化的关系，某种*映射*。我们还看到，并非所有映射都适用于所有类型的变量，而且（独立于此），一些表示比其他表示更难解释。ggplot为你提供了一套工具，可以将数据映射到图表上的视觉元素，指定你想要的图表类型，然后随后控制其显示的详细细节。图[3.1](makeplot.html#fig:ggplot-flow)展示了从顶部开始的数据到下面完成的图表的过程的示意图。现在不必担心细节。在接下来的几章中，我们将逐个部分地深入研究它们。
- en: '![The main elements of ggplot''s grammar of graphics. This chapter goes through
    these steps in detail.](../Images/c1ff2f5d98f9f5a0f2ee592c6c4b484c.png) Figure
    3.1: The main elements of ggplot’s grammar of graphics. This chapter goes through
    these steps in detail.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![ggplot图形语法的主要元素。本章将详细讲解这些步骤。](../Images/c1ff2f5d98f9f5a0f2ee592c6c4b484c.png)
    图3.1：ggplot图形语法的主要元素。本章将详细讲解这些步骤。'
- en: The most important thing to get used to with ggplot is the way you use it to
    think about the logical structure of your plot. The code you write specifies the
    connections between the variables in your data, and the colors, points, and shapes
    you see on the screen. In ggplot, these logical connections between your data
    and the plot elements are called *aesthetic mappings* or just *aesthetics*. You
    begin every plot by telling the `ggplot()` function what your data is, and then
    how the variables in this data logically map onto the plot’s aesthetics. Then
    you take the result and say what general sort of plot you want, such as a scatterplot,
    a boxplot, or a bar chart. In ggplot, the overall type of plot is called a *geom*.
    Each geom has a function that creates it. For example, `geom_point()` makes scatterplots,
    `geom_bar()` makes barplots, `geom_boxplot()` makes boxplots, and so on. You combine
    these two pieces, the `ggplot()` object and the `geom`, by literally adding them
    together in an expression, using the “`+`” symbol.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ggplot最重要的习惯是学会如何用它来思考你图表的逻辑结构。你编写的代码指定了数据中变量之间的联系，以及你在屏幕上看到的颜色、点和形状。在ggplot中，这些数据与图表元素之间的逻辑联系被称为*美学映射*或简称*美学*。你开始每一个图表时，先告诉`ggplot()`函数你的数据是什么，然后这些数据中的变量如何逻辑地映射到图表的美学上。然后你将结果告诉你想得到什么类型的图表，比如散点图、箱线图或柱状图。在ggplot中，整体图表类型被称为*geom*。每个geom都有一个创建它的函数。例如，`geom_point()`创建散点图，`geom_bar()`创建柱状图，`geom_boxplot()`创建箱线图，等等。你通过在表达式中实际地将它们相加，使用“`+`”符号，将这两个部分，即`ggplot()`对象和`geom`结合起来。
- en: At this point, ggplot will have enough information to be able to draw a plot
    for you. The rest is just details about exactly what you want to see. If you don’t
    specify anything further, ggplot will use a set of defaults that try to be sensible
    about what gets drawn. But more often, you will want to specify exactly what you
    want, including information about the scales, the labels of legends and axes,
    and other guides that help people to read the plot. These additional pieces are
    added to the plot in the same way as the `geom_` function was. Each component
    has it own function, you provide arguments to it specifying what to do, and you
    literally add it to the sequence of instructions. In this way you systematically
    build your plot piece by piece.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，ggplot将拥有足够的信息来为你绘制一个图表。其余的只是关于你确切想看到的具体细节。如果你没有进一步指定，ggplot将使用一组默认设置，试图在绘制时尽可能合理。但更常见的情况是，你将想要精确指定你想要的内容，包括关于刻度、图例和坐标轴标签以及其他帮助人们阅读图表的指南的信息。这些额外的部分是以与`geom_`函数相同的方式添加到图表中的。每个组件都有自己的函数，你提供给它参数来指定要做什么，然后你实际上将其添加到指令序列中。通过这种方式，你可以系统地一块一块地构建你的图表。
- en: In this chapter we will go through the main steps of this process. We will proceed
    by example, repeatedly building a series of plots. As noted earlier, I *strongly*
    encourage you go through this exercise manually, typing (rather than copying-and-pasting)
    the code yourself. This may seem a bit tedious, but it is *by far* the most effective
    way to get used to what is happening, and to get a feel for R’s syntax. While
    you’ll inevitably make some errors, you will also quickly find yourself becoming
    able to diagnose your own errors, as well as having a better grasp of the higher-level
    structure of plots. You should open the RMarkdown file for your notes, remember
    to load the tidyverse library`library(tidyverse)` and write the code out in chunks,
    interspersing your own notes and comments as you go.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过实例来介绍这个过程的主要步骤。我们将通过构建一系列图表来逐步进行。如前所述，我强烈建议你手动完成这个练习，亲自输入（而不是复制粘贴）代码。这可能会显得有些繁琐，但这是迄今为止最有效的方法，可以让你习惯正在发生的事情，并感受到
    R 语法的感觉。虽然你不可避免地会犯一些错误，但你也会很快发现自己能够诊断自己的错误，并且对图表的高级结构有更好的把握。你应该打开你的笔记的 RMarkdown
    文件，记得加载 tidyverse 库`library(tidyverse)`，并以块的形式编写代码，在编写过程中穿插自己的笔记和注释。
- en: 'Table 3.1: Life Expectancy data in wide format.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1：宽格式的生活预期数据。
- en: '| country | 1952 | 1957 | 1962 | 1967 | 1972 | 1977 | 1982 | 1987 | 1992 |
    1997 | 2002 | 2007 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 国家 | 1952 | 1957 | 1962 | 1967 | 1972 | 1977 | 1982 | 1987 | 1992 | 1997
    | 2002 | 2007 |'
- en: '| :-- | --: | --: | --: | --: | --: | --: | --: | --: | --: | --: | --: | --:
    |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| :-- | --: | --: | --: | --: | --: | --: | --: | --: | --: | --: | --: | --:
    |'
- en: '| Afghanistan | 29 | 30 | 32 | 34 | 36 | 38 | 40 | 41 | 42 | 42 | 42 | 44 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 阿富汗 | 29 | 30 | 32 | 34 | 36 | 38 | 40 | 41 | 42 | 42 | 42 | 44 |'
- en: '| Albania | 55 | 59 | 65 | 66 | 68 | 69 | 70 | 72 | 72 | 73 | 76 | 76 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 阿尔巴尼亚 | 55 | 59 | 65 | 66 | 68 | 69 | 70 | 72 | 72 | 73 | 76 | 76 |'
- en: '| Algeria | 43 | 46 | 48 | 51 | 55 | 58 | 61 | 66 | 68 | 69 | 71 | 72 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 阿尔及利亚 | 43 | 46 | 48 | 51 | 55 | 58 | 61 | 66 | 68 | 69 | 71 | 72 |'
- en: '| Angola | 30 | 32 | 34 | 36 | 38 | 39 | 40 | 40 | 41 | 41 | 41 | 43 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 安哥拉 | 30 | 32 | 34 | 36 | 38 | 39 | 40 | 40 | 41 | 41 | 41 | 43 |'
- en: '| Argentina | 62 | 64 | 65 | 66 | 67 | 68 | 70 | 71 | 72 | 73 | 74 | 75 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 阿根廷 | 62 | 64 | 65 | 66 | 67 | 68 | 70 | 71 | 72 | 73 | 74 | 75 |'
- en: '| Australia | 69 | 70 | 71 | 71 | 72 | 73 | 75 | 76 | 78 | 79 | 80 | 81 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 澳大利亚 | 69 | 70 | 71 | 71 | 72 | 73 | 75 | 76 | 78 | 79 | 80 | 81 |'
- en: 3.2 Tidy data
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 整洁数据
- en: The tidyverse tools we will be using want to see your data in a particular sort
    of shape, generally referred to as “tidy data” (Wickham, 2014). Social scientists
    will likely be familiar with the distinction between *wide format* and *long format*
    data. In a long format table, every variable is a column, and every observation
    is a row. In a wide format table, some variables are spread out across columns.
    For example, Table [3.1](makeplot.html#tab:gaptab1) shows part of a table of life
    expectancy over time for a series of countries. This is in wide format, because
    one of the variables, year, is spread across the columns of the table.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的 tidyverse 工具希望看到你的数据以特定的形状，通常被称为“整洁数据”（Wickham，2014）。社会科学家可能会熟悉宽格式数据与长格式数据之间的区别。在长格式表格中，每个变量都是一个列，每个观测值都是一个行。在宽格式表格中，一些变量散布在列中。例如，表
    [3.1](makeplot.html#tab:gaptab1) 展示了一系列国家随时间推移的生活预期表的一部分。这是宽格式，因为其中一个变量，即年份，散布在表格的列中。
- en: By contrast, Table [3.2](makeplot.html#tab:gaptab2) shows the beginning of the
    same data in long format. The tidy data that ggplot wants is in this long form.
    In a related bit of terminology, in this table the `year` variable is sometimes
    called a *key* and the `lifeExp` variable is the *value* taken by that key for
    any particular row. These terms are useful when converting tables from wide to
    long format. I am speaking fairly loosely here. Underneath these terms there is
    a worked-out theory of the forms that tabular data can be stored in, but right
    now we don’t need to know those additional details. For more on the ideas behind
    tidy data, see the discussion in the Appendix. You will also find an example showing
    the R code you need to get from an untidy to a tidy shape for the common “wide”
    case where some variables are spread out across the columns of your table.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，表 [3.2](makeplot.html#tab:gaptab2) 展示了相同数据的开始部分，以长格式呈现。ggplot 所需的整洁数据就是这种长格式。在相关的术语中，在这个表中，`year`
    变量有时被称为 *键*，而 `lifeExp` 变量是该键对于任何特定行的 *值*。这些术语在将表格从宽格式转换为长格式时很有用。我在这里说得相当宽松。在这些术语之下，有一个关于表格数据可以存储的形式的详细理论，但现阶段我们不需要知道这些额外的细节。有关整洁数据背后的理念的更多信息，请参阅附录中的讨论。你还将找到一个示例，展示你需要从杂乱无章的形状转换为整洁形状的
    R 代码，对于常见的“宽”情况，其中一些变量散布在表格的列中。
- en: 'Table 3.2: Life Expectancy data in long format.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.2：长格式寿命预期数据。
- en: '| country | year | lifeExp |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 国家 | 年份 | 寿命预期 |'
- en: '| :-- | --: | --: |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| :-- | --: | --: |'
- en: '| Afghanistan | 1952 | 29 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 阿富汗 | 1952 | 29 |'
- en: '| Afghanistan | 1957 | 30 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 阿富汗 | 1957 | 30 |'
- en: '| Afghanistan | 1962 | 32 |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 阿富汗 | 1962 | 32 |'
- en: '| Afghanistan | 1967 | 34 |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 阿富汗 | 1967 | 34 |'
- en: '| Afghanistan | 1972 | 36 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 阿富汗 | 1972 | 36 |'
- en: '| Afghanistan | 1977 | 38 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 阿富汗 | 1977 | 38 |'
- en: If you compare Tables [3.1](makeplot.html#tab:gaptab1) and [3.2](makeplot.html#tab:gaptab2),
    it is clear that a tidy table does not present data in its most compact form.
    In fact, it is usually not how you would choose to present your data if you wanted
    to just show people the numbers. Neither is untidy data “messy” or the “wrong”
    way to lay out data in some generic sense. It’s just that, even if its long-form
    shape makes tables larger, tidy data is much more straightforward to work with
    when it comes to specifying the mappings that you need to coherently describe
    plots.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你比较表 [3.1](makeplot.html#tab:gaptab1) 和 [3.2](makeplot.html#tab:gaptab2)，很明显，整洁的表格并没有以最紧凑的形式呈现数据。事实上，如果你只想向人们展示数字，这通常不是你选择展示数据的方式。同样，杂乱无章的数据也不一定是“杂乱”或以某种通用意义上“错误”的方式布局数据。只是，即使其长格式形状使表格更大，整洁数据在指定你需要用来连贯描述图表的映射时，要简单得多。
- en: 3.3 Mappings link data to things you see
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 映射将数据链接到你所看到的事物
- en: It’s useful to think of a recipe or template that we start from each time we
    want to make a plot. This is shown in Figure [3.2](makeplot.html#fig:ch-03-ggplot-formula-schematic).
    We start with just one object of our own, our data, which should be in a shape
    that ggplot understands. Usually this will be a *data frame* or some augmented
    version of it, like a *tibble*. We tell the core `ggplot` function what our data
    is. In this book, we will do this by creating an object named `p` which will contain
    the core information for our plot. (The name `p` is just a convenience.) Then
    we choose a plot type, or *geom* and add it to `p`. From there, we add more features
    to the plot as needed, such as additional elements, adjusted scales, a title,
    or other labels as needed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们想要制作一个图表时，思考一个食谱或模板是非常有用的。这如图 [3.2](makeplot.html#fig:ch-03-ggplot-formula-schematic)
    所示。我们从自己的一个对象开始，即我们的数据，这些数据应该以 ggplot 能够理解的形式存在。通常这将是 *data frame* 或其增强版本，如 *tibble*。我们告诉核心
    `ggplot` 函数我们的数据是什么。在这本书中，我们将通过创建一个名为 `p` 的对象来完成这项工作，该对象将包含我们图表的核心信息。（名称 `p` 只是一个便利的名称。）然后我们选择一个图表类型，或
    *geom*，并将其添加到 `p` 中。从那里，根据需要添加更多功能到图表中，例如额外的元素、调整的刻度、标题或其他所需的标签。
- en: '![A schematic for making a plot.](../Images/56281a77d6137fdd488cb29f21b9c816.png)
    Figure 3.2: A schematic for making a plot.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![制作图表的示意图。](../Images/56281a77d6137fdd488cb29f21b9c816.png) 图 3.2：制作图表的示意图。'
- en: We’ll use the gapminder data to make our first plots. Make sure the library
    containing the data is loaded. If you are following through from the previous
    Chapter in the same RStudio session or RMarkdown document, you won’t have to load
    it again. Otherwise, use `library()` to make it available.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 gapminder 数据来制作我们的第一个图表。确保包含数据的库已加载。如果你是在同一 RStudio 会话或 RMarkdown 文档中跟随上一章，你就不需要再次加载它。否则，使用
    `library()` 使其可用。
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can remind ourselves again what it looks like by typing the name of the
    object at the console:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在控制台中键入对象的名称来再次提醒自己它的样子：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Let’s say we want to plot Life Expectancy against per capita GDP for all country-years
    in the data. We’ll do this by creating an object that has some of the necessary
    information in it, and build it up from there. First, we must tell the `ggplot()`
    function what data we are using.Remember, use `Option+minus` on MacOS or `Alt+minus`
    on Windows to type the assignment operator.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要绘制所有国家-年份的数据中寿命预期与人均 GDP 的关系图。我们将通过创建一个包含一些必要信息的对象来完成这项工作，并从那里构建它。首先，我们必须告诉
    `ggplot()` 函数我们使用的数据。记住，在 MacOS 上使用 `Option+minus` 或在 Windows 上使用 `Alt+minus`
    来输入赋值运算符。
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'At this point ggplot knows our data, but not what the *mapping*. That is,You
    do not need to explicitly name the arguments you pass to functions, as long as
    you provide them in the expected order, viz, the order listed on the help page
    for the function. This code would still work if we omitted `data = ` and `mapping
    =` . In this book, I name all the arguments for clarity. we need to tell it which
    variables in the data should be represented by which visual elements in the plot.
    It also doesn’t know what sort of plot we want. In ggplot, mappings are specified
    using the `aes()` function. Like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，ggplot知道我们的数据，但不知道*映射*。也就是说，您不需要明确命名传递给函数的参数，只要您按照预期的顺序提供它们，即函数帮助页面上的顺序。如果我们省略`data
    = `和`mapping =`，此代码仍然可以工作。在这本书中，我命名所有参数以增加清晰度。我们需要告诉它数据中的哪些变量应该由图表中的哪些视觉元素表示。它也不知道我们想要什么类型的图表。在ggplot中，映射是通过`aes()`函数指定的。就像这样：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here we’ve given the `ggplot()` function two arguments instead of one: `data`
    and `mapping`. The `data` argument tells ggplot where to find the variables it
    is about to use. This saves us from having to tediously dig out the name of each
    variable in full. Instead, any mentions of variables will be looked for here first.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们给`ggplot()`函数提供了两个参数而不是一个：`data`和`mapping`。`data`参数告诉ggplot在哪里找到它将要使用的变量。这使我们免去了繁琐地挖掘每个变量完整名称的麻烦。相反，任何变量的提及都将首先在这里查找。
- en: Next, the mapping. The `mapping` argument is not a data object, nor is it a
    character string. Instead, it’s a function. (Remember, functions can be nested
    inside other functions.) The arguments we give to the `aes` function are a sequence
    of definitions that `ggplot` will use later. Here they say, “The variable on the
    x-axis is going to be `gdpPercap`, and the variable on the y-axis is going to
    be `lifeExp`.” The `aes()` function does not say where variables with those names
    are to be found. That’s because `ggplot()` is going to assume things with that
    name are in the object given to the `data` argument.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是映射。`mapping`参数不是一个数据对象，也不是一个字符字符串。相反，它是一个函数。（记住，函数可以嵌套在其他函数内部。）我们提供给`aes`函数的参数是一系列定义，ggplot稍后会使用这些定义。这里它们说，“x轴上的变量将是`gdpPercap`，y轴上的变量将是`lifeExp`。”`aes()`函数并没有说明具有这些名称的变量在哪里可以找到。这是因为`ggplot()`将假设具有该名称的事物在提供给`data`参数的对象中。
- en: The `mapping = aes(...)` argument *links variables* to *things you will see*
    on the plot. The `x` and `y` values are the most obvious ones. Other aesthetic
    mappings can include, for example, color, shape, size, and line type (whether
    a line is solid or dashed, or some other pattern). We’ll see examples in a minute.
    A mapping does not directly say what particular, e.g., colors or shapes will be
    on the plot. Rather they say which *variables* in the data will be *represented*
    by visual elements like a color, a shape, or a point on the plot area.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapping = aes(...)`参数将*变量*与*图表上的元素*相连接。`x`和`y`值是最明显的。其他美学映射可以包括，例如，颜色、形状、大小和线型（线条是实线、虚线还是其他图案）。我们将在下一分钟看到示例。映射不会直接说明图表上特定的颜色或形状，而是说明数据中的哪些*变量*将被*视觉元素*（如颜色、形状或图表区域上的点）所表示。'
- en: What happens if we just type `p` at the console at this point and hit return?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在在控制台输入`p`并按回车键会发生什么？
- en: '![This empty plot has no geoms.](../Images/47dad5f7b71ab7ea157c35ee278b93cf.png)
    Figure 3.3: This empty plot has no geoms.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![这个空图表没有任何几何形状。](../Images/47dad5f7b71ab7ea157c35ee278b93cf.png) 图3.3：这个空图表没有任何几何形状。'
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `p` object has been created by the `ggplot()` function, and already has
    information in it about the mappings we want, together with a lot of other information
    added by default. (If you want to see just how much information is in the `p`
    object already, try asking for `str(p)`.) However, we haven’t given it any instructions
    get about what sort of plot to draw. We need to add a *layer* to the plot. This
    means picking a `geom_` function. We will use `geom_point()`. It knows how to
    take `x` and `y` values and plot them in a scatterplot.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`p`对象是由`ggplot()`函数创建的，并且已经包含了我们想要映射的信息，以及默认添加的很多其他信息。（如果你想看看`p`对象中已经包含了多少信息，可以尝试调用`str(p)`。）然而，我们还没有给它任何关于绘制何种图表的指令。我们需要向图表添加一个*层*。这意味着选择一个`geom_`函数。我们将使用`geom_point()`。它知道如何根据`x`和`y`值在散点图中进行绘图。'
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Figure 3.4: A scatterplot of Life Expectancy vs GDP'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：预期寿命与GDP的散点图
- en: '![A scatterplot of Life Expectancy vs GDP](../Images/3499497ffdaedc0433bcaf755af3df94.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![预期寿命与GDP的散点图](../Images/3499497ffdaedc0433bcaf755af3df94.png)'
- en: Success!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！
- en: 3.4 Build your plots layer by layer
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 逐层构建你的图表
- en: Although we got a brief taste of ggplot at the end of Chapter [2](gettingstarted.html#gettingstarted),
    we spent more time in that Chaper preparing the ground to make this first proper
    graph. We set up our software IDE and made sure we could reproduce our work. We
    then learned the basics of how R works, and the sort of tidy data that ggplot
    expects. Just now we went through the logic of ggplot’s main idea, of building
    up plots a piece at a time in a systematic and predictable fashion, beginning
    with a mapping between a variable and an aesthetic element. We have done a lot
    of work and produced one plot.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在第[2](gettingstarted.html#gettingstarted)章的结尾对ggplot有了一个短暂的了解，但我们花了更多的时间在那个章节中为制作这个第一个合适的图表做准备。我们设置了我们的软件IDE并确保我们可以重现我们的工作。然后我们学习了R的基本工作原理，以及ggplot期望的整洁数据类型。刚才我们了解了ggplot主要思想的逻辑，即以系统且可预测的方式逐个构建图表，从变量与美学元素之间的映射开始。我们已经做了很多工作并产生了一个图表。
- en: 'The good news is that, from now on, not much will change conceptually about
    what we are doing. It will be more a question of learning in greater detail about
    how to tell ggplot what to do. We will learn more about the different geoms (or
    types of plot) available, and find out about the functions that control the coordinate
    system, scales, guiding elements (like labels and tick marks), and thematic features
    of plots. This will allow us to make much more sophisticated plots surprisingly
    fast. Conceptually, however, we will always be doing the same thing. We will start
    with a table of data that has been tidied, and then we will:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，从现在开始，我们在概念上所做的事情不会发生太多变化。这更多是一个关于更详细地了解如何告诉ggplot做什么的问题。我们将了解更多关于不同geom（或图表类型）的信息，以及控制坐标系、刻度、引导元素（如标签和刻度线）和图表主题功能的函数。这将使我们能够以惊人的速度制作更复杂的图表。然而，在概念上，我们始终在做同样的事情。我们将从一个整洁的数据表开始，然后我们将：
- en: Tell the `ggplot()` function what our data is.The `data = …` step.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉`ggplot()`函数我们的数据是什么。`data = …`步骤。
- en: Tell `ggplot()` *what* relationships we want to see.The `mapping = aes(…)` step.
    For convenience we will put the results of the first two steps in an object called
    `p`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉`ggplot()`我们想要看到哪些关系。`mapping = aes(…)`步骤。为了方便，我们将前两个步骤的结果放入一个名为`p`的对象中。
- en: Tell `ggplot` *how* we want to see the relationships in our data.Choose a geom.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉`ggplot`我们想要如何看到数据中的关系。选择一个geom。
- en: Layer on geoms as needed, by adding them to the `p` object one at a time.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要逐层添加geom，通过一次添加一个到`p`对象中。
- en: UseThe `scale_,` family, `labs()` and `guides()` functions. some additional
    functions to adjust scales, labels, tick marks, titles. We’ll learn more about
    some of these functions shortly.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`scale_`、`family`、`labs()`和`guides()`函数等一些额外的函数来调整刻度、标签、刻度线和标题。我们将在不久的将来了解更多关于这些函数的信息。
- en: To begin with we will let ggplot use its defaults for many of these elements.
    The coordinate system used in plots is most often cartesian, for example. It is
    a plane defined by an x axis and a y axis. This is what ggplot assumes, unless
    you tell it otherwise. But we will quickly start making some adjustments. Bear
    in mind once again that the process of adding layers to the plot really is *additive*.In
    effect we create one big object that is a nested list of instructions for how
    to draw each piece of the plot. Usually in R, functions cannot simply be added
    to objects. Rather, they take objects as inputs and produce objects as outputs.
    But the objects created by ggplot() are special. This makes it easier to assemble
    plots one piece at a time, and to inspect how they look at every step. For example,
    let’s try a different `geom_` function with our plot.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将让ggplot为其许多元素使用默认设置。在图表中使用的坐标系通常是笛卡尔坐标系，例如。这是一个由x轴和y轴定义的平面。这就是ggplot的假设，除非你告诉它否则。但我们将很快开始做一些调整。请再次记住，向图表中添加层的过程实际上是*累加的*。实际上，我们创建了一个大对象，它是一个嵌套列表，包含了如何绘制图表每一部分的指令。通常在R中，函数不能简单地添加到对象中。相反，它们以对象作为输入并产生对象作为输出。但ggplot()创建的对象是特殊的。这使得我们可以逐个组装图表，并在每一步检查它们的外观。例如，让我们尝试使用不同的`geom_`函数来修改我们的图表。
- en: '![Life Expectancy vs GDP, using a smoother.](../Images/0469c2175ab50a6df7a006a61a34e03b.png)
    Figure 3.5: Life Expectancy vs GDP, using a smoother.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用平滑器显示预期寿命与GDP的关系](../Images/0469c2175ab50a6df7a006a61a34e03b.png) 图3.5：使用平滑器显示预期寿命与GDP的关系。'
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can see right away that some of these geoms do a lot more than simply put
    points on a grid. Here `geom_smooth()` has calculated a smoothed line for us and
    shaded in a ribbon showing the standard error for the line. If we want to see
    the data points and the line together, we simply add `geom_point()` back in:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以立即看到这些几何图形做的工作远不止在网格上放置点。在这里，`geom_smooth()`为我们计算了一条平滑线，并用阴影表示了线的标准误差。如果我们想同时看到数据点和线，我们只需再次添加`geom_point()`：
- en: '![Life Expectancy vs GDP, showing both points and a GAM smoother.](../Images/20c96ac9f9ee066dad98ea66fbc317a1.png)
    Figure 3.6: Life Expectancy vs GDP, showing both points and a GAM smoother.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![预期寿命与GDP对比，显示点和GAM平滑器。](../Images/20c96ac9f9ee066dad98ea66fbc317a1.png) 图3.6：预期寿命与GDP对比，显示点和GAM平滑器。'
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The console message R tells you the `geom_smooth()` function is using a `method`
    called `gam`, which in this case means it has fit a generalized additive model.
    This suggests that maybe there are other methods that `geom_smooth()` understands,
    and which we might tell it to use instead. Instructions are given to functions
    via their arguments, so we can try adding `method = "lm"` (for “linear model”)
    as an argument to `geom_smooth()`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台信息R告诉你`geom_smooth()`函数正在使用一个名为`gam`的方法，在这种情况下意味着它已经拟合了一个广义加性模型。这表明可能还有其他`geom_smooth()`理解的方法，我们可以告诉它使用这些方法。通过函数的参数给出指令，因此我们可以尝试将`method
    = "lm"`（表示“线性模型”）作为参数添加到`geom_smooth()`中：
- en: '![Life Expectancy vs GDP, points and an ill-advised linear fit.](../Images/b464fa693cd69f46ffe0f320331102a8.png)
    Figure 3.7: Life Expectancy vs GDP, points and an ill-advised linear fit.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![预期寿命与GDP对比，显示点和不当的线性拟合。](../Images/b464fa693cd69f46ffe0f320331102a8.png)
    图3.7：预期寿命与GDP对比，显示点和不当的线性拟合。'
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We did not have to tell `geom_point()` or `geom_smooth()` where their data was
    coming from, or what mappings they should use. They *inherit* this information
    from the original `p` object. As we’ll see later, it’s possible to give geoms
    separate instructions that they will follow instead. But in the absence of any
    other information, the geoms will look for the instructions it needs in the `ggplot()`
    function, or the object created by it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必告诉`geom_point()`或`geom_smooth()`它们的数据来源，或它们应该使用什么映射。它们*继承*了来自原始`p`对象的信息。正如我们稍后将会看到的，我们可以为几何图形提供单独的指令，它们将遵循这些指令。但在没有其他信息的情况下，几何图形将在`ggplot()`函数或它创建的对象中寻找它们需要的指令。
- en: 'In our plot, the data is quite bunched up against the left side. Gross Domestic
    Product per capita is not normally distributed across our country years. The x-axis
    scale would probably look better if it were transformed from a linear scale to
    a log scale. For this we can use a function called `scale_x_log10()`. As you might
    expect this function scales the x-axis of a plot to a log 10 basis. To use it
    we just add it to the plot:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的图表中，数据在左侧非常密集。人均国内生产总值在我们的国家年份中不是正态分布的。如果x轴的刻度从线性刻度转换为对数刻度，看起来可能会更好。为此，我们可以使用一个名为`scale_x_log10()`的函数。正如你所期望的，这个函数将图表的x轴缩放到以10为底的对数。要使用它，我们只需将其添加到图表中：
- en: '![Life Expectancy vs GDP scatterplot, with a GAM smoother and a log scale on
    the x-axis.](../Images/89cc54d50b54a4a8385915808ec2c87c.png) Figure 3.8: Life
    Expectancy vs GDP scatterplot, with a GAM smoother and a log scale on the x-axis.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![预期寿命与GDP散点图，带有GAM平滑器和x轴上的对数刻度。](../Images/89cc54d50b54a4a8385915808ec2c87c.png)
    图3.8：预期寿命与GDP散点图，带有GAM平滑器和x轴上的对数刻度。'
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The x-axis transformation repositions the points, and also changes the shape
    the smoothed line. (We switched back to `gam` from `lm`.) While `ggplot()` and
    its associated functions have not made any changes to our underlying data frame,
    the scale transformation is applied to the data before the smoother is layered
    on to the plot. There are a variety of scale transformations that you can use
    in just this way. Each is named for the transformation you want to apply, and
    the axis you want to applying it to. In this case we use `scale_x_log10()`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: x轴的转换重新定位了点，同时也改变了平滑线的形状。（我们已从`lm`切换回`gam`。）虽然`ggplot()`及其相关函数没有对我们的基础数据框做出任何更改，但缩放转换是在平滑器层叠到图表之前应用于数据的。你可以使用各种缩放转换，每种转换都是以你想要应用的转换和轴来命名的。在这种情况下，我们使用`scale_x_log10()`。
- en: 'At this point, if our goal was just to show a plot of Life Expectancy vs GDP
    using sensible scales and adding a smoother, we would be thinking about polishing
    up the plot with nicer axis labels and a title. Perhaps we might also want to
    replace the scientific notation on the x-axis with the dollar value it actually
    represents. We can do both of these things quite easily. Let’s take care of the
    scale first. The labels on the tick-marks can be controlled through the `scale_`
    functions. While it’s possible to roll your own function to label axes (or just
    supply your labels manually, as we will see later), there’s also a handy `scales`
    library that contains some useful pre-made formatting functions. We can either
    load the whole library with `library(scales)` or, more conveniently, just grab
    the specific formatter we want from that library. Here it’s the `dollar()` function.
    To grab a function directly from a library we have not loaded, we use the syntax
    `thelibrary::thefunction`. So, we can do this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果我们的目标只是使用合理的尺度绘制寿命预期与 GDP 的图表，并添加一个平滑器，我们可能会考虑用更漂亮的轴标签和标题来润色图表。也许我们还想用实际代表的美元价值替换
    x 轴上的科学记数法。我们可以非常容易地完成这两件事。让我们首先处理尺度问题。刻度标记的标签可以通过 `scale_` 函数来控制。虽然你可以编写自己的函数来标注轴（或者像我们稍后将要看到的那样手动提供标签），但还有一个方便的
    `scales` 库，其中包含一些有用的预制格式化函数。我们可以通过 `library(scales)` 加载整个库，或者更方便地，直接从该库中获取我们想要的特定格式化器。这里是我们需要的
    `dollar()` 函数。要从尚未加载的库中直接获取一个函数，我们使用语法 `thelibrary::thefunction`。因此，我们可以这样做：
- en: '![Life Expectancy vs GDP scatterplot, with a GAM smoother and a log scale on
    the x-axis, with better labels on the tick marks.](../Images/52f0a9f105ac6e60c79d2503c117395d.png)
    Figure 3.9: Life Expectancy vs GDP scatterplot, with a GAM smoother and a log
    scale on the x-axis, with better labels on the tick marks.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![寿命预期与 GDP 散点图，带有 GAM 平滑器和 x 轴上的对数尺度，以及更好的刻度标记标签。](../Images/52f0a9f105ac6e60c79d2503c117395d.png)
    图 3.9：寿命预期与 GDP 散点图，带有 GAM 平滑器和 x 轴上的对数尺度，以及更好的刻度标记标签。'
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We will learn more about scale transformations later. For now, just remember
    two things about them. First, you can directly transform your x or y axis by adding
    something like `scale_x_log10()` or `scale_y_log10()` to your plot. When you do
    so, the x or y axis will be transformed and, by default, the tick marks on the
    axis will be labeled using scientific notation. Second, you can give these `scale_`
    functions a `labels` argument that reformats the text printed underneath the tick
    marks on the axes. Inside the `scale_x_log10()` function try `labels=scales::comma`,
    for example.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后学习更多关于尺度变换的内容。现在，只需记住关于它们的两件事。首先，你可以通过在图表中添加类似 `scale_x_log10()` 或 `scale_y_log10()`
    这样的函数来直接转换你的 x 或 y 轴。当你这样做时，x 或 y 轴将被转换，并且默认情况下，轴上的刻度标记将使用科学记数法进行标注。其次，你可以给这些
    `scale_` 函数提供一个 `labels` 参数，该参数可以重新格式化轴上刻度标记下方的文本。在 `scale_x_log10()` 函数中，尝试 `labels=scales::comma`，例如。
- en: 3.5 Mapping aesthetics vs setting them
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 映射美学与设置它们
- en: 'An *aesthetic mapping* specifies that a variable will be expressed by one of
    the available visual elements, such as size, or color, or shape, and so on. As
    we’ve seen, we map variables to aesthetics like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一种 *美学映射* 指定了一个变量将通过可用的视觉元素之一来表达，例如大小、颜色、形状等等。正如我们所看到的，我们是这样将变量映射到美学的：
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This code does *not* give a direct instruction like “color the points purple”.
    Instead it says, “the property ‘color’ will represent the variable `continent`”,
    or “color will map `continent`”. If we want to turn all the points in the figure
    purple, we do *not* do it through the mapping function. Look at what happens when
    we try:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并没有给出像“将点涂成紫色”这样的直接指令。相反，它说，“属性‘color’将代表变量 `continent`”，或者“颜色将映射 `continent`”。如果我们想将图中的所有点都变成紫色，我们不是通过映射函数来做的。看看当我们尝试这样做时会发生什么：
- en: '[PRE45]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Figure 3.10: What has gone wrong here?'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10：这里出了什么问题？
- en: '![What has gone wrong here?](../Images/5cf321e8ee5046c7708138606531ccb1.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![这里出了什么问题？](../Images/5cf321e8ee5046c7708138606531ccb1.png)'
- en: What has happened here? Why is there a legend saying “purple”? And why have
    the points all turned pinkish-red instead of purple? Remember, an aesthetic is
    a mapping of variables in your data to properties you can see on the graph. The
    `aes()` function is where that mapping is specified, and the function is trying
    to do its job. It wants to map a variable to the color aesthetic, so it assumes
    you are giving it a variable.Just as in Chapter 1, when we were able to write
    ‘`my_numbers + 1`’ to add one to each element of the vector. We have only given
    it one word, though—“purple”. Still, `aes()` will do its best to treat that word
    as though it were a variable. A variable should have as many observations as there
    are rows in the data, so `aes()` falls back on R’s recycling rules for making
    vectors of different lengths match up.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？为什么会有一个图例说“紫色”？为什么点都变成了粉红色而不是紫色？记住，美学是将你的数据中的变量映射到你在图上可以看到的属性。`aes()`
    函数就是在这里指定映射的地方，该函数正在尽力完成其工作。它想要将一个变量映射到颜色美学，因此它假设你给它的是一个变量。就像在第1章中，我们能够写‘`my_numbers
    + 1`’来给向量的每个元素加一。尽管如此，我们只给了它一个单词——“紫色”。然而，`aes()` 仍然会尽力将这个单词当作一个变量来处理。一个变量应该有与数据行数一样多的观测值，所以
    `aes()` 会回退到R的回收规则，以使不同长度的向量匹配。
- en: In effect, this creates a new categorical variable for your data. The string
    “purple” is recycled for every row of your data. Now you have a new column. Every
    element in it has the same value, “purple”. Then ggplot plots the results on the
    graph as you’ve asked it to, by mapping it to the `color` aesthetic. It dutifully
    makes a legend for this new variable. By default, ggplot displays the points falling
    into the category “purple” (which is all of them) using its default first-category
    hue … which is red.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这为你的数据创建了一个新的分类变量。字符串“紫色”被循环用于你的数据中的每一行。现在你有一个新列。它里面的每个元素都有相同的值，“紫色”。然后ggplot按照你要求的方式在图上绘制结果，通过将其映射到
    `color` 美学。它尽职尽责地为这个新变量制作了一个图例。默认情况下，ggplot使用其默认的第一类别色调显示属于“紫色”类别的点（即所有点）……这个色调是红色。
- en: 'The `aes()` function is for mappings only. Do not use it to change properties
    to a particular value. If we want to *set* a property, we do it in the `geom_`
    we are using, and *outside* the `mapping = aes(...)` step. Try this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`aes()` 函数仅用于映射。不要用它来将属性更改为特定值。如果我们想 *设置* 一个属性，我们就在使用的 `geom_` 中进行，并且在 `mapping
    = aes(...)` 步骤 *之外* 进行。试试这样做：'
- en: '![Setting the color attribute of the points directly.](../Images/4a637ca648cb8a2b5edf8ddbb6e5988a.png)
    Figure 3.11: Setting the color attribute of the points directly.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '![直接设置点的颜色属性。](../Images/4a637ca648cb8a2b5edf8ddbb6e5988a.png) 图3.11：直接设置点的颜色属性。'
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `geom_point()` function can take a `color` argument directly, and R knows
    what color “purple” is. This is not part of the aesthetic mapping that defines
    the basic structure of the graphic. From the point of view of the grammar or logic
    of the graph, the fact that the points are colored purple has no significance.
    The color purple is not representing or mapping a variable or feature of the data
    in the relevant way.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`geom_point()` 函数可以直接接受 `color` 参数，R知道“紫色”是什么颜色。这并不是定义图形基本结构的美学映射的一部分。从图形的语法或逻辑角度来看，点被涂成紫色的事实没有任何意义。紫色并没有以相关的方式表示或映射数据中的变量或特征。'
- en: '![Setting some other arguments.](../Images/db844341dc1449fb34c26dfe215020f0.png)
    Figure 3.12: Setting some other arguments.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![设置一些其他参数。](../Images/db844341dc1449fb34c26dfe215020f0.png) 图3.12：设置一些其他参数。'
- en: '[PRE47]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The various `geom_` functions can take many other arguments that will affect
    how the plot looks, but that do not involve mapping variables to aesthetic elements.
    Thus, those arguments will never go inside the `aes()` function. Some of the things
    we will want to set, like color or size, have the same name as mappable elements.
    Others, like the `method` or `se` arguments in `geom_smooth()` affect other aspects
    of the plot. In the code for Figure [3.12](makeplot.html#fig:ch-03-fig-lexp-gdp-09),
    the `geom_smooth()` call sets the line color to orange and sets its size (i.e.,
    thickness) to 8, an unreasonably large value. We also turn off the `se` option
    by switching it from its default value of `TRUE` to `FALSE`. The result is that
    the standard error ribbon is not shown.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 各种`geom_`函数可以接受许多其他会影响图表外观的参数，但它们不涉及将变量映射到美学元素。因此，这些参数永远不会放入`aes()`函数中。我们想要设置的一些事情，如颜色或大小，与可映射元素具有相同的名称。其他，如`geom_smooth()`中的`method`或`se`参数，影响图表的其他方面。在图[3.12](makeplot.html#fig:ch-03-fig-lexp-gdp-09)的代码中，`geom_smooth()`调用将线条颜色设置为橙色，并将其大小（即厚度）设置为8，这是一个不合理的较大值。我们还通过将其从默认值`TRUE`切换到`FALSE`来关闭`se`选项。结果是标准误差带不会显示。
- en: MeanwhileIt’s also possible to map a continuous variable directly to the alpha
    property, much like one might map a continuous variable to a single-color gradient.
    However, this is generally not an effective way of precisely conveying variation
    in quantity. in the `geom_smooth()` call we set the `alpha` argument to 0.3\.
    Like color, size, and shape, “alpha” is an aesthetic property that points (and
    some other plot elements) have, and to which variables can be mapped. It controls
    how transparent the object will appear when drawn. It’s measured on a scale of
    zero to one. An object with an alpha of zero will be completely transparent. Setting
    it to zero will make any other mappings the object might have, such as color or
    size, invisible as well. An object with an alpha of one will be completely opaque.
    Choosing an intermediate value can be useful when there is a lot of overlapping
    data to plot, as it makes it easier to see where the bulk of the observations
    are located.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，直接将连续变量映射到alpha属性也是可能的，就像将连续变量映射到单色渐变一样。然而，这通常不是精确传达数量变化的有效方式。在`geom_smooth()`调用中，我们将`alpha`参数设置为0.3。像颜色、大小和形状一样，“alpha”是点（以及一些其他图表元素）具有的美学属性，并且可以将变量映射到它。它控制绘制对象时的透明度。它在零到一的比例上测量。alpha值为零的对象将完全透明。将其设置为零将使对象可能具有的其他映射（如颜色或大小）也变得不可见。alpha值为一的对象将完全不透明。当有大量重叠数据要绘制时，选择中间值可能很有用，因为它使得更容易看到观察值的主体位置。
- en: '![A more polished plot of Life Expectancy vs GDP.](../Images/528814bf005572e3aa69ff08fea67934.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![寿命与GDP的更光滑的图表](../Images/528814bf005572e3aa69ff08fea67934.png)'
- en: 'Figure 3.13: A more polished plot of Life Expectancy vs GDP.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13：寿命与GDP的更光滑的图表。
- en: '[PRE48]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We can now make a reasonably polished plot. We set the `alpha` of the points
    to a low value, make nicer x- and y-axis labels, and add a title, subtitle, and
    caption. As you can see in the code above, in addition to `x`, `y`, and any other
    aesthetic mappings in your plot (such as `size`, `fill`, or `color`), the `labs()`
    function can also set the text for `title`, `subtitle`, and `caption`. It controls
    the *main labels* of scales. The appearance of things like axis tick marks are
    the responsibility of various `scale_` functions, such as the `scale_x_log10()`
    function used here. We will learn more about what can be done with `scale_` functions
    soon.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以制作一个相当光滑的图表。我们将点的`alpha`值设置为低值，使x轴和y轴的标签更美观，并添加标题、副标题和图注。如上代码所示，除了`x`、`y`以及你图表中的任何其他美学映射（如`size`、`fill`或`color`）之外，`labs()`函数还可以设置`title`、`subtitle`和`caption`的文本。它控制着刻度的*主要标签*。诸如轴刻度标记等事物的外观是各种`scale_`函数的责任，例如这里使用的`scale_x_log10()`函数。我们很快就会了解`scale_`函数可以做什么。
- en: Are there any variables in our data that can sensibly be mapped to the `color`
    aesthetic? Consider `continent`. In Figure [3.14](makeplot.html#fig:ch-03-fig-lexp-gdp-11)
    the individual data points have been colored by `continent`, and a legend with
    a key to the colors has automatically been added to the plot. In addition, instead
    of one smoothing line we now have five. There is one for each unique value of
    the `continent` variable. This is a consequence of the way aesthetic mappings
    are inherited. Along with `x` and `y`, the `color` aesthetic mapping is set in
    the call to `ggplot()` that we used to creat the `p` object. Unless told otherwise,
    all geoms layered on top of the original plot object will inherit that object’s
    mappings. In this case we get both our points and smoothers colored by continent.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据中是否有任何变量可以合理地映射到`颜色`美学？考虑`大陆`。在图[3.14](makeplot.html#fig:ch-03-fig-lexp-gdp-11)中，各个数据点已经根据`大陆`进行了着色，并且自动添加了一个带有颜色键的图例。此外，现在我们不再只有一条平滑线，而是有五条。每一条对应于`大陆`变量的唯一值。这是美学映射继承方式的结果。除了`x`和`y`之外，`颜色`美学映射是在调用`ggplot()`时设置的，我们用它来创建`p`对象。除非另有说明，否则所有堆叠在原始绘图对象之上的几何对象都将继承该对象的映射。在这种情况下，我们得到了根据大陆着色的点和平滑线。
- en: '[PRE49]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '![Mapping the continent variable to the color aesthetic.](../Images/a0fd0b66ad62e23457edd70756fa6d2a.png)
    Figure 3.14: Mapping the continent variable to the color aesthetic.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![将大陆变量映射到颜色美学。](../Images/a0fd0b66ad62e23457edd70756fa6d2a.png) 图3.14：将大陆变量映射到颜色美学。'
- en: If it is what we want, then we might also consider shading the standard error
    ribbon of each line to match its dominant color. The color of the standard error
    ribbon is controlled by the `fill` aesthetic. Whereas the `color` aesthetic affects
    the appearance of lines and points, `fill` is for the filled areas of bars, polygons
    and, in this case, the interior of the smoother’s standard error ribbon.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是我们想要的，我们还可以考虑将每条线的标准误差带阴影，以匹配其主导颜色。标准误差带的颜色由`填充`美学控制。而`颜色`美学影响线条和点的外观，`填充`则是用于条形、多边形以及在这种情况下平滑线标准误差带的内部区域。
- en: '[PRE50]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '![Mapping the continent variable to the color aesthetic, and correcting the
    error bars using the fill aesthetic.](../Images/d0fac1d82d45ee7eaabdec2d69bb1a77.png)
    Figure 3.15: Mapping the continent variable to the color aesthetic, and correcting
    the error bars using the fill aesthetic.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![将大陆变量映射到颜色美学，并使用填充美学来纠正误差带。](../Images/d0fac1d82d45ee7eaabdec2d69bb1a77.png)
    图3.15：将大陆变量映射到颜色美学，并使用填充美学来纠正误差带。'
- en: Making sure that color and fill aesthetics match up consistently in this way
    improves the overall look of the plot. In order to make it happen we just need
    to specify that the mappings are to the same variable in each case.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 确保颜色和填充美学以这种方式一致匹配，可以提升整个图表的外观。为了实现这一点，我们只需指定每种情况下的映射都指向相同的变量。
- en: 3.6 Aesthetics can be mapped per geom
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 每个几何对象可以单独映射美学
- en: Perhaps five separate smoothers is too many, and we just want one line. But
    we still would like to have the points color-coded by continent. By default, geoms
    inherit their mappings from the `ggplot()` function. We can change this by mapping
    the aesthetics we want only the `geom_` functions that we want them to apply to.
    We use the same `mapping = aes(...)` expression as in the initial call to `ggplot()`,
    but now use it in the `geom_` functions as well, specifying only the mappings
    we want to apply to each one. Mappings specified only in the initial `ggplot()`
    function—here, `x` and `y`—will carry through to all subsequent geoms.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 也许五个单独的平滑线太多了，我们只想有一条线。但我们仍然希望点根据大陆进行颜色编码。默认情况下，几何对象从`ggplot()`函数继承其映射。我们可以通过只映射我们想要应用于特定`geom_`函数的美学来改变这一点。我们使用与初始`ggplot()`调用相同的`mapping
    = aes(...)`表达式，但现在在`geom_`函数中使用它，并指定我们想要应用于每个对象的映射。仅在初始`ggplot()`函数中指定的映射——这里为`x`和`y`——将传递到所有后续的几何对象中。
- en: '![Mapping aesthetics on a per-geom basis. Here color is mapped to continent
    for the points but not the smoother.](../Images/84973e15698acc2a6756470dedb62db6.png)
    Figure 3.16: Mapping aesthetics on a per-geom basis. Here color is mapped to continent
    for the points but not the smoother.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![基于每个几何对象映射美学。这里颜色映射到点上的大陆，但不是平滑线。](../Images/84973e15698acc2a6756470dedb62db6.png)
    图3.16：基于每个几何对象映射美学。这里颜色映射到点上的大陆，但不是平滑线。'
- en: '[PRE51]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: It’s possible to map continuous variables to the `color` aesthetic, too. For
    example, we can map the log of each country-year’s population (`pop`) to `color`.
    (We can take the log of population right in the `aes()` statement, using the `log()`
    function. R will evaluate this for us quite happily.) When we do this, ggplot
    produces a gradient scale. It is continuous, but marked at intervals in the legend.
    Depending on the circumstances, mapping quantities like population to a continuous
    color gradient may be more or less effective than cutting the variable into categorical
    bins running, e.g., from low to high. In general it is always worth looking at
    the data in its continuous form first rather than cutting or binning it into categories.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 将连续变量映射到`颜色`美学也是可能的。例如，我们可以将每个国家-年份的人口（`pop`）的对数映射到`颜色`。（我们可以在`aes()`语句中直接对人口取对数，使用`log()`函数。R会非常乐意为我们评估这个表达式。）当我们这样做时，ggplot会生成一个渐变刻度。它是连续的，但在图例中以间隔标记。根据具体情况，将人口等数量映射到连续的颜色渐变可能比将其切割成从低到高的分类区间更有效或更无效。一般来说，首先查看数据的连续形式而不是将其切割或分箱到类别中总是值得的。
- en: '![Mapping a continuous variable to color.](../Images/b6fa2af5be9bb0293878a97e7fc2b565.png)
    Figure 3.17: Mapping a continuous variable to color.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![将连续变量映射到颜色。](../Images/b6fa2af5be9bb0293878a97e7fc2b565.png) 图3.17：将连续变量映射到颜色。'
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Finally, it is worth paying a little more attention to the way that ggplot draws
    its scales. Because every mapped variable has a scale, we can learn a lot about
    how a plot has been constructed, and what mappings it contains, by seeing what
    the legends look like. For example, take a closer look at the legends produced
    in Figures [3.15](makeplot.html#fig:ch-03-fig-lexp-gdp-12) and [3.16](makeplot.html#fig:ch-03-fig-lexp-gdp-13).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得稍微注意ggplot绘制刻度的方法。因为每个映射的变量都有一个刻度，我们可以通过观察图例的样式来了解图表是如何构建的，以及它包含哪些映射。例如，仔细观察图3.15[3.15](makeplot.html#fig:ch-03-fig-lexp-gdp-12)和图3.16[3.16](makeplot.html#fig:ch-03-fig-lexp-gdp-13)生成的图例。
- en: 'Figure 3.18: Guides and legends faithfully reflect the mappings they represent.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18：指南和图例忠实地反映了它们所代表的映射。
- en: '![Guides and legends faithfully reflect the mappings they represent.](../Images/6e57e4eaeef8b9c1c8396189614f7471.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![指南和图例忠实地反映了它们所代表的映射。](../Images/6e57e4eaeef8b9c1c8396189614f7471.png)'
- en: 'In the legend for the first figure, shown here on the left, we see several
    visual elements. The key for each continent shows a dot, a line, and a shaded
    background. The key for the second figure, shown on the right, has only a dot
    for each continent, with no shaded background or line. If you look again at the
    code for Figures [3.15](makeplot.html#fig:ch-03-fig-lexp-gdp-12) and [3.16](makeplot.html#fig:ch-03-fig-lexp-gdp-13),
    you will see that in the first case we mapped the `continent` variable to both
    `color` and `fill`. We then drew the figure with `geom_point()` and fitted a line
    for each continent with `geom_smooth()`. Points have `color` but the smoother
    understands both `color` (for the line itself) and `fill` (for the shaded standard
    error ribbon). Each of these elements is represented in the legend: the point
    color, the line color, and the ribbon fill. In the second figure, we decided to
    simplify things by having only the points be colored by `continent`. Then we drew
    just a single smoother for the whole graph. Thus, in the legend for that figure,
    the colored line and the shaded box are both absent. We only see a legend for
    the mapping of `color` to `continent` in `geom_point()`. Meanwhile on the graph
    itself the line drawn by `geom_smooth()` is set by default to a bright blue, different
    from anything on the scale, and its shaded error ribbon is set by default to gray.
    Small details like this are not accidents. They are a direct consequence of ggplot’s
    grammatical way of thinking about the relationship between the data behind the
    plot and the visual elements that represent it.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个图表的图例中，如图左所示，我们可以看到几个视觉元素。每个大陆的键显示一个点、一条线和阴影背景。第二个图表的图例，如图右所示，每个大陆只有一个点，没有阴影背景或线条。如果你再次查看图表[3.15](makeplot.html#fig:ch-03-fig-lexp-gdp-12)和[3.16](makeplot.html#fig:ch-03-fig-lexp-gdp-13)的代码，你会看到在第一种情况下，我们将`continent`变量映射到`color`和`fill`。然后我们使用`geom_point()`绘制图表，并使用`geom_smooth()`为每个大陆拟合一条线。点有`color`属性，但平滑器理解`color`（用于线条本身）和`fill`（用于阴影标准误差带）。这些元素都在图例中有表示：点的颜色、线的颜色和带子的填充。在第二个图表中，我们决定通过只让点根据`continent`着色来简化事情。然后我们只为整个图表绘制了一个单一的平滑器。因此，在该图表的图例中，彩色线条和阴影框都消失了。我们只看到了`geom_point()`中`color`到`continent`映射的图例。同时，在图表本身中，`geom_smooth()`绘制的线条默认设置为明亮的蓝色，与刻度上的任何东西都不同，其阴影误差带默认设置为灰色。这样的小细节并非偶然。这是ggplot直接从数据背后的关系和表示它的视觉元素之间的语法方式思考的直接结果。
- en: 3.7 Save your work
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7 保存你的工作
- en: 'Now that you have started to make your own plots, you may be wondering how
    to save them, and perhaps also how to control their size and format. If you are
    working in an RMarkdown document then the plots you make will be embedded in it,
    as we have already seen. You can set the default size of plots within your `.Rmd`
    document by setting an option in your first code chunk. This one tells R to make
    8x5 figures:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经开始制作自己的图表，你可能想知道如何保存它们，也许还想知道如何控制它们的大小和格式。如果你在一个RMarkdown文档中工作，那么你制作的图表将嵌入其中，正如我们之前看到的。你可以在你的`.Rmd`文档中通过设置第一个代码块中的选项来设置图表的默认大小。这个选项告诉R制作8x5的图表：
- en: '[PRE53]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Because you will be making plots of different sizes and shapes, sometimes you
    will want to control the size of particular plots, without changing the default.
    To do this, you can add the same options to any particular chunk inside the curly
    braces at the beginning. Remember, each chunk opens with three backticks and then
    a pair of braces containing the language name (for us always `r`) and an optional
    label:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你将制作不同大小和形状的图表，有时你可能想控制特定图表的大小，而不改变默认设置。为此，你可以在开头花括号内的任何特定块中添加相同的选项。记住，每个块以三个反引号开头，然后是一对花括号，包含语言名称（对我们来说总是`r`）和一个可选的标签：
- en: '[PRE54]{r example}'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE54]{r example}'
- en: p + geom_point()
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: p + geom_point()
- en: '[PRE55]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You can follow the label with a comma and provide a series of options if needed.
    They will apply only to that chunk. To make a figure twelve inches wide and nine
    inches high we say e.g. `{r example, fig.width = 12, fig.height = 9}` in the braces
    section.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在标签后跟一个逗号，并在需要时提供一系列选项。它们将仅适用于该块。例如，要在花括号部分创建一个宽度为12英寸、高度为9英寸的图表，我们可以说`{r
    example, fig.width = 12, fig.height = 9}`。
- en: 'You will often need to save your figures individually, as they will end up
    being dropped into slides or published in papers that are not produced using RMarkdown.
    Saving a figure to a file can be done in several different ways. When working
    with `ggplot`, the easiest way is to use the `ggsave()` function. To save the
    most recently displayed figure, we provide the name we want to save it under:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常会需要单独保存你的图表，因为它们最终会被放入幻灯片或发表在不是使用 RMarkdown 生成的论文中。将图表保存到文件可以通过几种不同的方式完成。当使用
    `ggplot` 时，最简单的方式是使用 `ggsave()` 函数。为了保存最近显示的图表，我们提供我们想要保存的名称：
- en: '[PRE56]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'ThisSeveral other file formats are available as well. See the function’s help
    page for details. will save the figure as a PNG file, a format suitable for displaying
    on web pages. If you want a PDF instead, change the extension of the file:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把图表保存为 PNG 文件，这是一种适合在网页上显示的格式。如果你想要 PDF 格式，只需更改文件的扩展名：
- en: '[PRE57]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Remember that, for convenience, you do not need to write `filename =` as long
    as the name of the file is the first argument you give `ggsave()`. You can also
    pass plot objects to `ggsave()`. For example, we can put our recent plot into
    an object called `p_out` and then tell `ggave()` that we want to save that object.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，为了方便，只要文件的名称是你提供给 `ggsave()` 函数的第一个参数，你就不需要写 `filename =`。你也可以将绘图对象传递给 `ggsave()`。例如，我们可以将我们最近的绘图放入一个名为
    `p_out` 的对象中，然后告诉 `ggave()` 我们想要保存该对象。
- en: '[PRE58]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: When saving your work, it is sensible to have a subfolder (or more than one,
    depending on the project) where you save only figures. You should also take care
    to name your saved figures in a sensible way. `fig_1.pdf` or `my_figure.pdf` are
    not good names. Figure names should be compact but descriptive, and consistent
    between figures within a project. In addition, although it really shouldn’t be
    the case in this day and age, it is also wise to play it safe and avoid file names
    containing characters likely to make your code choke in future. These include
    apostrophes, backticks, spaces, forward and back slashes, and quotes.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的工作的时候，有一个子文件夹（或者根据项目需要，可以有一个以上的子文件夹）专门保存图表是明智的。你还应该注意以合理的方式命名你保存的图表。`fig_1.pdf`
    或 `my_figure.pdf` 这样的名字并不好。图表名称应该是紧凑且描述性的，并且在项目中的图表之间保持一致。此外，尽管在当今时代这实际上不应该发生，但为了安全起见，避免使用可能在未来使你的代码崩溃的字符也是明智的。这些包括撇号、反引号、空格、前后斜杠和引号。
- en: 'The Appendix contains a short discussion of how to organize your files within
    your project folder. Treat the project folder as the home base of your work for
    the paper or work you are doing, and put your data and figures in subfolders within
    the project folder. To begin with, using your file manager, create a folder named
    “figures” inside your project folder. When saving figures, you can use Kirill
    Müller’s handy `here` library to make it easier to work with files and subfolders
    while not having to type in full file paths. Load the library in the setup chunk
    of your RMarkdown document. When you do, it tells you where “here” is for the
    current project. You will see a message saying something like this, with your
    file path and user name instead of mine:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 附录简要讨论了如何在项目文件夹中组织你的文件。将项目文件夹视为你正在进行的论文或工作的家基地，并将你的数据和图表放在项目文件夹内的子文件夹中。首先，使用你的文件管理器，在你的项目文件夹内创建一个名为“figures”的文件夹。当保存图表时，你可以使用
    Kirill Müller 的便捷 `here` 库来使处理文件和子文件夹更容易，而无需输入完整的文件路径。在 RMarkdown 文档的设置块中加载库。当你这样做时，它会告诉你“here”对于当前项目在哪里。你会看到一个类似的消息，用你的文件路径和用户名代替我的：
- en: '[PRE59]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You can then use the `here()` function to make loading and saving your work
    more straightforward and safer. Assuming a folder named “figures” exists in your
    project folder, you can do this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用 `here()` 函数使加载和保存你的工作更加直接和安全。假设你的项目文件夹中存在一个名为“figures”的文件夹，你可以这样做：
- en: '[PRE60]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This saves `p_out` as a file called `lifeexp_vs_gdp_gradient.pdf` in the `figures`
    directory *here*, i.e. in your current project folder.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`p_out` 就会被保存为名为 `lifeexp_vs_gdp_gradient.pdf` 的文件，在 `figures` 目录下，即在你的当前项目文件夹中。
- en: You can save your figure in a variety of different formats, depending on your
    needs (and also, to a lesser extent, on your particular computer system). The
    most important distinction to bear in mind is between *vector* formats and *raster*
    formats. A file with a *vector* format, like PDF or SVG, is stored as a set of
    instructions about lines, shapes, colors, and their relationships. The viewing
    software (such as Adobe Acrobat or Apple’s Preview application for PDFs) then
    interprets those instructions and displays the figure. Representing the figure
    this way allows it to be easily resized without becoming distorted. The underlying
    language of the PDF format is Postscript, which is also the language of modern
    typesetting and printing. This makes a vector-based format like PDF the best choice
    for submission to journals.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的需求（以及在一定程度上，你的特定计算机系统），你可以以多种不同的格式保存你的图形。需要记住的最重要区别是*矢量*格式和*栅格*格式。具有矢量格式的文件，如PDF或SVG，存储为关于线条、形状、颜色及其关系的指令集。然后查看软件（如Adobe
    Acrobat或苹果的预览应用用于PDF）解释这些指令并显示图形。以这种方式表示图形允许它轻松地调整大小而不会变形。PDF格式的底层语言是Postscript，这也是现代排版和印刷的语言。这使得基于矢量的格式如PDF成为提交给期刊的最佳选择。
- en: A *raster* based format, on the other hand, stores images essentially as a grid
    of pixels of a pre-defined size with information about the location, color, brightness,
    and so on of each pixel in the grid. This makes for more efficient storage, especially
    when used in conjunction with compression methods that take advantage of redundancy
    in images in order to save space. Formats like JPG are compressed raster formats.
    A PNG file is a raster image format that supports lossless compression. For graphs
    containing an awful lot of data, PNG files will tend to be much smaller than the
    corresponding PDF. However, raster formats cannot be easily resized. In particular
    they cannot be expanded in size without becoming pixelated or grainy. Formats
    like JPG and PNG are the standard way that images are displayed on the web. The
    more recent SVG format is vector-based format but also nevertheless supported
    by many web browsers.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，基于栅格的格式将图像基本上存储为具有预定义大小的像素网格，以及关于网格中每个像素的位置、颜色、亮度等信息。这使得存储更高效，尤其是在与利用图像冗余来节省空间的压缩方法结合使用时。像JPG这样的格式是压缩的栅格格式。PNG文件是一种支持无损压缩的栅格图像格式。对于包含大量数据的图形，PNG文件通常比相应的PDF文件小得多。然而，栅格格式不能轻易调整大小。特别是，它们不能在不像素化或出现颗粒感的情况下扩大尺寸。像JPG和PNG这样的格式是网页上显示图像的标准方式。较新的SVG格式是基于矢量的格式，但仍然被许多网络浏览器支持。
- en: In general you should save your work in several different formats. When you
    save in different formats and in different sizes you may need to experiment with
    the scaling of the plot and the size of the fonts in order to get a good result.
    The `scale` argument to `ggsave()` can help you here (you can try out different
    values, like `scale=1.3`, `scale=5`, and so on). You can also use `ggave()` to
    explicitly set the height and width of your plot in the units that you choose.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你应该以几种不同的格式保存你的工作。当你以不同的格式和大小保存时，你可能需要尝试调整图表的缩放和字体大小，以获得良好的结果。`ggsave()`函数的`scale`参数可以在这里帮助你（你可以尝试不同的值，如`scale=1.3`、`scale=5`等）。你也可以使用`ggave()`来明确设置你的图表的高度和宽度，使用你选择的单位。
- en: '[PRE61]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now that you know how to do that, let’s get back to making more graphs.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何做了，让我们回到制作更多图表的任务上来。
- en: 3.8 Where to go next
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.8 接下来去哪里
- en: Start by playing around with the `gapminder` data a little more. You can try
    each of these explorations with `geom_point()` and then with `geom_smooth()`,
    or both together.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尝试对`gapminder`数据做一些更多的探索。你可以尝试使用`geom_point()`和`geom_smooth()`，或者两者一起进行这些探索。
- en: What happens when you put the `geom_smooth()` function before `geom_point()`
    instead of after it? What does this tell you about how the plot is drawn? Think
    about how this might be useful when drawing plots.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你在`geom_smooth()`函数之前而不是之后放置`geom_point()`函数时会发生什么？这告诉你关于绘图方式的信息是什么？考虑一下这可能在绘图时是有用的。
- en: Change the mappings in the `aes()` function so that you plot Life Expectancy
    against population (`pop`) rather than per capita GDP. What does that look like?
    What does it tell you about the unit of observation in the dataset?
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`aes()`函数中更改映射，以便你绘制的是预期寿命与人口（`pop`）之间的关系，而不是人均GDP。这看起来是什么样子？这告诉你关于数据集中观测单位的信息是什么？
- en: Try some alternative scale mappings. Besides `scale_x_log10()` you can try `scale_x_sqrt()`
    and `scale_x_reverse()`. There are corresponding functions for y-axis transformations.
    Just write `y` instead of `x`. Experiment with them to see what sort of effect
    they have on the plot, and whether they make any sense to use.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试一些不同的尺度映射。除了 `scale_x_log10()`，你还可以尝试 `scale_x_sqrt()` 和 `scale_x_reverse()`。对于y轴的变换也有相应的函数。只需将
    `x` 替换为 `y`。通过实验它们对图表的影响，看看它们是否合理。
- en: What happens if you map `color` to `year` instead of `continent`? Is the result
    what you expected? Think about what class of object `year` is. Remember you can
    get a quick look at the top of the data, which includes some shorthand information
    on the class of each variable, by typing `gapminder`.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你将 `color` 映射为 `year` 而不是 `continent`，会发生什么？结果是你预期的吗？考虑一下 `year` 是哪种类型的对象。记住，你可以通过输入
    `gapminder` 来快速查看数据的顶部，其中包括一些关于每个变量类别的简短信息。
- en: Instead of mapping `color = year`, what happens if you try `color = factor(year)`?
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你尝试将 `color` 映射为 `factor(year)` 而不是 `year`，会发生什么？
- en: As you look at these different scatterplots, think about Figure [3.13](makeplot.html#fig:ch-03-fig-lexp-gdp-10)
    a little more critically. We worked it up to the point where it was reasonably
    polished, but is it really the best way to display this country-year data? What
    are we gaining and losing by ignoring the temporal and country-level structure
    of the data? How could we do better? Sketch out what an alternative visualization
    might look like.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你查看这些不同的散点图时，更批判性地思考一下图 [3.13](makeplot.html#fig:ch-03-fig-lexp-gdp-10)。我们将其完善到相当光鲜的程度，但它真的是展示这种国家-年份数据的最佳方式吗？通过忽略数据的时序和国家级别结构，我们得到了什么，失去了什么？我们如何做得更好？勾勒出一种可能的替代可视化可能看起来是什么样子。
- en: As you begin to experiment, remember two things. First, it’s always worth trying
    something, even if you’re not sure what’s going to happen. Don’t be afraid of
    the console.This license does not extend to, for example, overwriting or deleting
    your data by mistake. You should still manage your project responsibly, at a minimum
    keeping good backups. But within R and at the level of experimenting with graphs
    at the console, you have a lot of freedom. The nice thing about making your graphics
    through code is that you won’t break anything you can’t reproduce. If something
    doesn’t work, you can figure out what happened, fix things, and re-run the code
    to make the graph again.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始实验时，请记住两件事。首先，尝试任何事情总是值得的，即使你不确定会发生什么。不要害怕控制台。这个许可证不适用于，例如，错误地覆盖或删除你的数据。你仍然应该负责任地管理你的项目，至少要保留良好的备份。但在R中，在控制台进行图形实验的层面上，你有很多自由。通过代码制作图形的好处是，你不会破坏你无法重现的东西。如果某些东西不起作用，你可以找出发生了什么，修复问题，然后重新运行代码以再次生成图表。
- en: Second, remember that the main flow of action in ggplot is always the same.
    You start with a table of data, you map the variables you want to display to aesthetics
    like position, color, or shape, and you choose one or more geoms to draw the graph.
    In your code this gets accomplished by making an object with the basic information
    about data and mappings, and then adding or layering additional information as
    needed. Once you get used to this way of thinking about your plots, especially
    the aesthetic mapping part, then drawing them becomes easier. Instead of having
    to think about how to draw particular shapes or colors on the screen, the many
    `geom_` functions take care of that for you. In the same way, learning new geoms
    is easier once you think of them as ways to display aesthetic mappings that you
    specify. Most of the learning curve with ggplot involves getting used to this
    way of thinking about your data and its representation in a plot. In the next
    chapter, we will flesh out these ideas a little more, cover some common ways plots
    go “wrong” (i.e., when they end up looking strange), and learn how to recognize
    and avoid those problems.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，记住ggplot中的主要操作流程始终相同。你从一个数据表开始，将你想要显示的变量映射到美学属性，如位置、颜色或形状，并选择一个或多个几何形状来绘制图表。在你的代码中，这是通过创建一个包含数据基本信息和映射的基本对象来完成的，然后根据需要添加或分层额外的信息。一旦你习惯了这种思考图表的方式，特别是美学映射的部分，绘制它们就会变得更容易。你不需要考虑如何在屏幕上绘制特定的形状或颜色，许多
    `geom_` 函数会为你处理这些。同样，一旦你将它们视为显示你指定的美学映射的方式，学习新的几何形状就会变得更容易。ggplot的大部分学习曲线都涉及习惯以这种方式思考你的数据和它在图表中的表示。在下一章中，我们将更详细地阐述这些想法，涵盖一些常见的图表“出错”方式（即它们最终看起来很奇怪），并学习如何识别和避免这些问题。
