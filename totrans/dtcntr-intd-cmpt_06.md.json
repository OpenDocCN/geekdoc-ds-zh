["```py\n# Lines starting with # are comments for human readers.\n# Pyret ignores everything on a line after #.\n\n# armenia\nframe(\n  above(rectangle(120, 30, \"solid\", \"red\"),\n    above(rectangle(120, 30, \"solid\", \"blue\"),\n      rectangle(120, 30, \"solid\", \"orange\"))))\n\n# austria\nframe(\n  above(rectangle(120, 30, \"solid\", \"red\"),\n    above(rectangle(120, 30, \"solid\", \"white\"),\n      rectangle(120, 30, \"solid\", \"red\"))))\n```", "```py\n# armenia\nthree-stripe-flag(\"red\", \"blue\", \"orange\")\n\n# austria\nthree-stripe-flag(\"red\", \"white\", \"red\")\n```", "```py\n> >     frame(\n> >       above(rectangle(120, 30, \"solid\", top),\n> >         above(rectangle(120, 30, \"solid\", middle),\n> >           rectangle(120, 30, \"solid\", bottom))))\n> >     ```", "```py\n> >     fun <function name>(<parameters>):\n> >       <the expression goes here>\n> >     end\n> >     ```", "```py\nfun three-stripe-flag(top, middle, bottom):\n  frame(\n    above(rectangle(120, 30, \"solid\", top),\n      above(rectangle(120, 30, \"solid\", middle),\n        rectangle(120, 30, \"solid\", bottom))))\nend\n```", "```py\nthree-stripe-flag(\"red\", \"blue\", \"orange\")\nthree-stripe-flag(\"red\", \"white\", \"red\")\n```", "```py\narmenia = three-stripe-flag(\"red\", \"blue\", \"orange\")\naustria = three-stripe-flag(\"red\", \"white\", \"red\")\n```", "```py\nthree-stripe-flag(\"red\", \"blue\", \"orange\")\n```", "```py\nframe(\n  above(rectangle(120, 30, \"solid\", top),\n    above(rectangle(120, 30, \"solid\", middle),\n      rectangle(120, 30, \"solid\", bottom))))\n```", "```py\nframe(\n  above(rectangle(120, 30, \"solid\", \"red\"),\n    above(rectangle(120, 30, \"solid\", \"blue\"),\n      rectangle(120, 30, \"solid\", \"orange\"))))\n```", "```py\nthree-stripe-flag(50, \"blue\", \"red\")\n```", "```py\nframe(\n  above(rectangle(120, 30, \"solid\", 50),\n    above(rectangle(120, 30, \"solid\", \"blue\"),\n      rectangle(120, 30, \"solid\", \"red\"))))\n```", "```py\nfun three-stripe-flag(top :: String,\n      middle :: String,\n      bottom :: String):\n  frame(\n    above(rectangle(120, 30, \"solid\", top),\n      above(rectangle(120, 30, \"solid\", middle),\n        rectangle(120, 30, \"solid\", bottom))))\nend\n```", "```py\nfun three-stripe-flag(top :: String,\n      middle :: String,\n      bottom :: String) -> Image:\n  frame(\n    above(rectangle(120, 30, \"solid\", top),\n      above(rectangle(120, 30, \"solid\", middle),\n        rectangle(120, 30, \"solid\", bottom))))\nend\n```", "```py\nfun three-stripe-flag(top :: String,\n      middle :: String,\n      bottom :: String) -> Image:\n  doc: \"produce image of flag with three equal-height horizontal stripes\"\n  frame(\n    above(rectangle(120, 30, \"solid\", top),\n      above(rectangle(120, 30, \"solid\", middle),\n        rectangle(120, 30, \"solid\", bottom))))\nend\n```", "```py\n100 * 1/6\n150 * 1/6\n90 * 1/6\n```", "```py\n    earth-weight * 1/6\n    ```", "```py\n    fun moon-weight(earth-weight):\n      earth-weight * 1/6\n    end\n    ```", "```py\n    fun moon-weight(earth-weight :: Number) -> Number:\n      doc: \"Compute weight on moon from weight on earth\"\n      earth-weight * 1/6\n    end\n    ```", "```py\nfun moon-weight(earth-weight :: Number) -> Number:\n  doc: \"Compute weight on moon from weight on earth\"\n  earth-weight * 1/6\nwhere:\n  moon-weight(100) is 100 * 1/6\n  moon-weight(150) is 150 * 1/6\n  moon-weight(90) is 90 * 1/6\nend\n```", "```py\n> > earth-weight * 1/3\n> > ```", "```py\n> > moon-weight(90) is 90 * 1/3\n> > ```", "```py\n# ordering 3 pens that say \"wow\"\n3 * (0.25 + (string-length(\"wow\") * 0.02))\n\n# ordering 10 pens that say \"smile\"\n10 * (0.25 + (string-length(\"smile\") * 0.02))\n```", "```py\nfun pen-cost(num-pens :: Number, message :: String) -> Number:\n  num-pens * (0.25 + (string-length(message) * 0.02))\nend\n```", "```py\nfun pen-cost(num-pens :: Number, message :: String)\n  -> Number:\n  num-pens * (0.25 + (string-length(message) * 0.02))\nend\n```", "```py` ```", "```py` rather than `\"` to begin and end it, like so:\n\n```", "```pytotal cost for pens, each 25 cents\n       plus 2 cents per message character```", "```py\n\nWe should also document the examples that we used when creating the function:\n\n```", "```pytotal cost for pens, each 25 cents\n       plus 2 cents per message character```", "```py\n\nWhen writing `where` examples, we also want to include special yet valid cases that the function might have to handle, such as an empty message.\n\n```", "```py\n\nNote that our empty-message example has a simpler expression on the right side of `is`. The expression for what the function returns doesnâ€™t have to match the body expression; it simply has to evaluate to the same value as you expect the example to produce. Sometimes, weâ€™ll find it easier to just write the expected value directly. For the case of someone ordering no pens, for example, weâ€™d include:\n\n```", "```py\n\nThe point of the examples is to document how a function behaves on a variety of inputs. What goes to the right of the `is` should summarize the computation or the answer in some meaningful way. Most important? Do not write the function, run it to determine the answer, then put that answer on the right side of the `is`! Why not? Because the examples are meant to give some redundancy to the design process, so that you catch errors you might have made. If your function body is incorrect, and you use the function to generate the example, you wonâ€™t get the benefit of using the example to check for errors.\n\nWeâ€™ll keep returning to this idea of writing good examples. Donâ€™t worry if you still have questions for now. Also, for the time being, we wonâ€™t worry about nonsensical situations like negative numbers of pens. Weâ€™ll get to those after weâ€™ve learned additional coding techniques that will help us handle such situations properly.\n\n> Do Now!\n> \n> > We could have combined our two special cases into one example, such as\n> > \n> > ```", "```py\n> > \n> > Does doing this seem like a good idea? Why or why not?\n\n#### 3.3.6Â Recap: Defining Functions[ðŸ”—](#(part._.Recap__.Defining_.Functions) \"Link to here\")\n\nThis chapter has introduced the idea of a function. Functions play a key role in programming: they let us configure computations with different concrete values at different times. The first time we compute the cost of pens, we might be asking about `10` pens that say `\"Welcome\"`. The next time, we might be asking about `100` pens that say `\"Go Bears!\"`. The core computation is the same in both cases, so we want to write it out once, configuring it with different concrete values each time we use it.\n\nWeâ€™ve covered several specific ideas about functions:\n\n*   We showed the `fun` notation for writing functions. You learned that a function has a name (that we can use to refer to it), one or more parameters (names for the values we want to configure), as well as a body, which is the computation that we want to perform once we have concrete values for the parameters.\n\n*   We showed that we should include examples with our functions, to illustrate what the function computes on various specific values. Examples go in a `where` block within the function.\n\n*   We showed that we can use a function by providing concrete values to configure its parameters. To do this, we write the name of the function we want to use, followed by a pair of parenthesis around comma-separated values for the parameters. For example, writing the following expression (at the interactions prompt) will compute the cost of a specific order of pens:\n\n    ```", "```py\n\n*   We discussed that if we define a function in the definitions pane then press Run, Pyret will make an entry in the directory with the name of the function. If we later use the function, Pyret will look up the code that goes with that name, substitute the concrete values we provided for the parameters, and return the result of evaluating the resulting expression. Pyret will NOT produce anything in the interactions pane for a function definition (other than a report about whether the examples hold).\n\nThereâ€™s much more to learn about functions, including different reasons for creating them. Weâ€™ll get to those in due course.\n\n#### 3.3.1Â Example: Similar Flags[ðŸ”—](#(part._similar-flags) \"Link to here\")\n\nConsider the following two expressions to draw the flags of Armenia and Austria (respectively). These two countries have the same flag, just with different colors. The `frame` operator draws a small black frame around the image.\n\n```", "```py\n\nRather than write this program twice, it would be nice to write the common expression only once, then just change the colors to generate each flag. Concretely, weâ€™d like to have a custom operator such as `three-stripe-flag` that we could use as follows:\n\n```", "```py\n\nIn this program, we provide `three-stripe-flag` only with the information that customizes the image creation to a specific flag. The operation itself would take care of creating and aligning the rectangles. We want to end up with the same images for the Armenian and Austrian flags as we would have gotten with our original program. Such an operator doesnâ€™t exist in Pyret: it is specific only to our application of creating flag images. To make this program work, then, we need the ability to add our own operators (henceforth called functions) to Pyret.\n\n#### 3.3.2Â Defining Functions[ðŸ”—](#(part._defining-functions) \"Link to here\")\n\nIn programming, a function takes one or more (configuration) parameters and uses them to produce a result.\n\n> Strategy: Creating Functions From Expressions\n> \n> > If we have multiple concrete expressions that are identical except for a couple of specific data values, we create a function with the common code as follows:\n> > \n> > *   Write down at least two expressions showing the desired computation (in this case, the expressions that produce the Armenian and Austrian flags).\n> >     \n> >     \n> > *   Identify which parts are fixed (i.e., the creation of rectangles with dimensions `120` and `30`, the use of `above` to stack the rectangles) and which are changing (i.e., the stripe colors).\n> >     \n> >     \n> > *   For each changing part, give it a name (say `top`, `middle`, and `bottom`), which will be the parameter that stands for that part.\n> >     \n> >     \n> > *   Rewrite the examples to be in terms of these parameters. For example:\n> >     \n> >     \n> >     \n> >     ```", "```py\n> >     \n> >     \n> > *   Name the function something suggestive: e.g., `three-stripe-flag`.\n> >     \n> >     \n> > *   Write the syntax for functions around the expression:\n> >     \n> >     \n> >     \n> >     ```", "```py\n> >     \n> >     \n> >     \n> >     where the expression is called the body of the function. (Programmers often use angle brackets to say â€œreplace with something appropriateâ€; the brackets themselves arenâ€™t part of the notation.)\n\nHereâ€™s the end product:\n\n```", "```py\n\nWhile this looks like a lot of work now, it wonâ€™t once you get used to it. We will go through the same steps over and over, and eventually theyâ€™ll become so intuitive that you wonâ€™t need to start from multiple similar expressions.\n\n> Do Now!\n> \n> > Why does the function body have only one expression, when before we had a separate one for each flag?\n\nWe have only one expression because the whole point was to get rid of all the changing parts and replace them with parameters.\n\nWith this function in hand, we can write the following two expressions to generate our original flag images:\n\n```", "```py\n\nWhen we provide values for the parameters of a function to get a result, we say that we are calling the function. We use the term call for expressions of this form.\n\nIf we want to name the resulting images, we can do so as follows:\n\n```", "```py\n\n(Side note: Pyret only allows one value per name in the directory. If your file already had definitions for the names `armenia` or `austria`, Pyret will give you an error at this point. You can use a different name (like `austria2`) or comment out the original definition using `#`.)\n\n##### 3.3.2.1Â How Functions Evaluate[ðŸ”—](#(part._function-call-nm) \"Link to here\")\n\nSo far, we have learned three rules for how Pyret processes your program:\n\n*   If you write an expression, Pyret evaluates it to produce its value.\n\n*   If you write a statement that defines a name, Pyret evaluates the expression (right side of `=`), then makes an entry in the directory to associate the name with the value.\n\n*   If you write an expression that uses a name from the directory, Pyret substitutes the name with the corresponding value.\n\nNow that we can define our own functions, we have to consider two more cases: what does Pyret do when you define a function (using `fun`), and what does Pyret do when you call a function (with values for the parameters)?\n\n*   When Pyret encounters a function definition in your file, it makes an entry in the directory to associate the name of the function with its code. The body of the function does not get evaluated at this time.\n\n*   When Pyret encounters a function call while evaluating an expression, it replaces the call with the body of the function, but with the parameter values substituted for the parameter names in the body. Pyret then continues to evaluate the body with the substituted values.\n\nAs an example of the function-call rule, if you evaluate\n\n```", "```py\n\nPyret starts from the function body\n\n```", "```py\n\nsubstitutes the parameter values\n\n```", "```py\n\nthen evaluates the expression, producing the flag image.\n\nNote that the second expression (with the substituted values) is the same expression we started from for the Armenian flag. Substitution restores that expression, while still allowing the programmer to write the shorthand in terms of `three-stripe-flag`.\n\n##### 3.3.2.2Â Type Annotations[ðŸ”—](#(part._fun-annotations) \"Link to here\")\n\nWhat if we made a mistake, and tried to call the function as follows:\n\n```", "```py\n\n> Do Now!\n> \n> > What do you think Pyret will produce for this expression?\n\nThe first parameter to `three-stripe-flag` is supposed to be the color of the top stripe. The value `50` is not a string (much less a string naming a color). Pyret will substitute `50` for `top` in the first call to `rectangle`, yielding the following:\n\n```", "```py\n\nWhen Pyret tries to evaluate the `rectangle` expression to create the top stripe, it generates an error that refers to that call to `rectangle`.\n\nIf someone else were using your function, this error might not make sense: they didnâ€™t write an expression about rectangles. Wouldnâ€™t it be better to have Pyret report that there was a problem in the use of `three-stripe-flag` itself?\n\nAs the author of `three-stripe-flag`, you can make that happen by annotating the parameters with information about the expected type of value for each parameter. Hereâ€™s the function definition again, this time requiring the three parameters to be strings:\n\n```", "```py\n\nNotice that the notation here is similar to what we saw in contracts within the documentation: the parameter name is followed by a double-colon (`::`) and a type name (so far, one of `Number`, `String`, or `Image`).Putting each parameter on its own line is not required, but it sometimes helps with readability.\n\nRun your file with this new definition and try the erroneous call again. You should get a different error message that is just in terms of `three-stripe-flag`.\n\nIt is also common practice to add a type annotation that captures the type of the functionâ€™s output. That annotation goes after the list of parameters:\n\n```", "```py\n\nNote that all of these type annotations are optional. Pyret will run your program whether or not you include them. You can put type annotations on some parameters and not others; you can include the output type but not any of the parameter types. Different programming languages have different rules about types.\n\nWe will think of types as playing two roles: giving Pyret information that it can use to focus error messages more accurately, and guiding human readers of programs as to the proper use of user-defined functions.\n\n##### 3.3.2.3Â Documentation[ðŸ”—](#(part._doc-strings) \"Link to here\")\n\nImagine that you opened your program file from this chapter a couple of months from now. Would you remember what computation `three-stripe-flag` does? The name is certainly suggestive, but it misses details such as that the stripes are stacked vertically (rather than horizontally) and that the stripes are equal height. Function names arenâ€™t designed to carry this much information.\n\nProgrammers also annotate a function with a docstring, a short, human-language description of what the function does. Hereâ€™s what the Pyret docstring might look like for `three-stripe-flag`:\n\n```", "```py\n\nWhile docstrings are also optional from Pyretâ€™s perspective, you should always provide one when you write a function. They are extremely helpful to anyone who has to read your program, whether that is a co-worker, graderâ€¦or yourself, a couple of weeks from now.\n\n##### 3.3.2.1Â How Functions Evaluate[ðŸ”—](#(part._function-call-nm) \"Link to here\")\n\nSo far, we have learned three rules for how Pyret processes your program:\n\n*   If you write an expression, Pyret evaluates it to produce its value.\n\n*   If you write a statement that defines a name, Pyret evaluates the expression (right side of `=`), then makes an entry in the directory to associate the name with the value.\n\n*   If you write an expression that uses a name from the directory, Pyret substitutes the name with the corresponding value.\n\nNow that we can define our own functions, we have to consider two more cases: what does Pyret do when you define a function (using `fun`), and what does Pyret do when you call a function (with values for the parameters)?\n\n*   When Pyret encounters a function definition in your file, it makes an entry in the directory to associate the name of the function with its code. The body of the function does not get evaluated at this time.\n\n*   When Pyret encounters a function call while evaluating an expression, it replaces the call with the body of the function, but with the parameter values substituted for the parameter names in the body. Pyret then continues to evaluate the body with the substituted values.\n\nAs an example of the function-call rule, if you evaluate\n\n```", "```py\n\nPyret starts from the function body\n\n```", "```py\n\nsubstitutes the parameter values\n\n```", "```py\n\nthen evaluates the expression, producing the flag image.\n\nNote that the second expression (with the substituted values) is the same expression we started from for the Armenian flag. Substitution restores that expression, while still allowing the programmer to write the shorthand in terms of `three-stripe-flag`.\n\n##### 3.3.2.2Â Type Annotations[ðŸ”—](#(part._fun-annotations) \"Link to here\")\n\nWhat if we made a mistake, and tried to call the function as follows:\n\n```", "```py\n\n> Do Now!\n> \n> > What do you think Pyret will produce for this expression?\n\nThe first parameter to `three-stripe-flag` is supposed to be the color of the top stripe. The value `50` is not a string (much less a string naming a color). Pyret will substitute `50` for `top` in the first call to `rectangle`, yielding the following:\n\n```", "```py\n\nWhen Pyret tries to evaluate the `rectangle` expression to create the top stripe, it generates an error that refers to that call to `rectangle`.\n\nIf someone else were using your function, this error might not make sense: they didnâ€™t write an expression about rectangles. Wouldnâ€™t it be better to have Pyret report that there was a problem in the use of `three-stripe-flag` itself?\n\nAs the author of `three-stripe-flag`, you can make that happen by annotating the parameters with information about the expected type of value for each parameter. Hereâ€™s the function definition again, this time requiring the three parameters to be strings:\n\n```", "```py\n\nNotice that the notation here is similar to what we saw in contracts within the documentation: the parameter name is followed by a double-colon (`::`) and a type name (so far, one of `Number`, `String`, or `Image`).Putting each parameter on its own line is not required, but it sometimes helps with readability.\n\nRun your file with this new definition and try the erroneous call again. You should get a different error message that is just in terms of `three-stripe-flag`.\n\nIt is also common practice to add a type annotation that captures the type of the functionâ€™s output. That annotation goes after the list of parameters:\n\n```", "```py\n\nNote that all of these type annotations are optional. Pyret will run your program whether or not you include them. You can put type annotations on some parameters and not others; you can include the output type but not any of the parameter types. Different programming languages have different rules about types.\n\nWe will think of types as playing two roles: giving Pyret information that it can use to focus error messages more accurately, and guiding human readers of programs as to the proper use of user-defined functions.\n\n##### 3.3.2.3Â Documentation[ðŸ”—](#(part._doc-strings) \"Link to here\")\n\nImagine that you opened your program file from this chapter a couple of months from now. Would you remember what computation `three-stripe-flag` does? The name is certainly suggestive, but it misses details such as that the stripes are stacked vertically (rather than horizontally) and that the stripes are equal height. Function names arenâ€™t designed to carry this much information.\n\nProgrammers also annotate a function with a docstring, a short, human-language description of what the function does. Hereâ€™s what the Pyret docstring might look like for `three-stripe-flag`:\n\n```", "```py\n\nWhile docstrings are also optional from Pyretâ€™s perspective, you should always provide one when you write a function. They are extremely helpful to anyone who has to read your program, whether that is a co-worker, graderâ€¦or yourself, a couple of weeks from now.\n\n#### 3.3.3Â Functions Practice: Moon Weight[ðŸ”—](#(part._moon-weight-pyret) \"Link to here\")\n\nSuppose weâ€™re responsible for outfitting a team of astronauts for lunar exploration. We have to determine how much each of them will weigh on the Moonâ€™s surface. On the Moon, objects weigh only one-sixth their weight on earth. Here are the expressions for several astronauts (whose weights are expressed in pounds):\n\n```", "```py\n\nAs with our examples of the Armenian and Austrian flags, we are writing the same expression multiple times. This is another situation in which we should create a function that takes the changing data as a parameter but captures the fixed computation only once.\n\nIn the case of the flags, we noticed we had written essentially the same expression more than once. Here, we have a computation that we expect to do multiple times (once for each astronaut). Itâ€™s boring to write the same expression over and over again. Besides, if we copy or re-type an expression multiple times, sooner or later weâ€™re bound to make a transcription error.This is an instance of the [DRY principle](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself), where DRY means \"donâ€™t repeat yourself\".\n\nLetâ€™s remind ourselves of the steps for creating a function:\n\n*   Write down some examples of the desired calculation. We did that above.\n\n*   Identify which parts are fixed (above, `* 1/6`) and which are changing (above, `100`, `150`, `90`...).\n\n*   For each changing part, give it a name (say `earth-weight`), which will be the parameter that stands for it.\n\n*   Rewrite the examples to be in terms of this parameter:\n\n    ```", "```py\n\n    This will be the body, i.e., the expression inside the function.\n\n*   Come up with a suggestive name for the function: e.g., `moon-weight`.\n\n*   Write the syntax for functions around the body expression:\n\n    ```", "```py\n\n*   Remember to include the types of the parameter and output, as well as the documentation string. This yields the final function:\n\n    ```", "```py\n\n#### 3.3.4Â Documenting Functions with Examples[ðŸ”—](#(part._writing-examples) \"Link to here\")\n\nIn each of the functions above, weâ€™ve started with some examples of what we wanted to compute, generalized from there to a generic formula, turned this into a function, and then used the function in place of the original expressions.\n\nNow that weâ€™re done, what use are the initial examples? It seems tempting to toss them away. However, thereâ€™s an important rule about software that you should learn: Software Evolves. Over time, any program that has any use will change and grow, and as a result may end up producing different values than it did initially. Sometimes these are intended, but sometimes these are a result of mistakes (including such silly but inevitable mistakes like accidentally adding or deleting text while typing). Therefore, itâ€™s always useful to keep those examples around for future reference, so you can immediately be alerted if the function deviates from the examples it was supposed to generalize.\n\nPyret makes this easy to do. Every function can be accompanied by a `where` clause that records the examples. For instance, our `moon-weight` function can be modified to read:\n\n```", "```py\n\nWhen written this way, Pyret will actually check the answers every time you run the program, and notify you if you have changed the function to be inconsistent with these examples.\n\n> Do Now!\n> \n> > Check this! Change the formulaâ€”<wbr>for instance, replace the body of the function with\n> > \n> > ```", "```py\n> > \n> > â€”<wbr>and see what happens. Pay attention to the output from CPO: you should get used to recognizing this kind of output.\n\n> Do Now!\n> \n> > Now, fix the function body, and instead change one of the answersâ€”<wbr>e.g., write\n> > \n> > ```", "```py\n> > \n> > â€”<wbr>and see what happens. Contrast the output in this case with the output above.\n\nOf course, itâ€™s pretty unlikely you will make a mistake with a function this simple (except through a typo). After all, the examples are so similar to the functionâ€™s own body. Later, however, we will see that the examples can be much simpler than the body, and there is a real chance for things to get inconsistent. At that point, the examples become invaluable in making sure we havenâ€™t made a mistake in our program. In fact, this is so valuable in professional software development that good programmers always write down large collections of examplesâ€”<wbr>called testsâ€”<wbr>to make sure their programs are behaving as they expect.\n\nFor our purposes, we are writing examples as part of the process of making sure we understand the problem. Itâ€™s always a good idea to make sure you understand the question before you start writing code to solve a problem. Examples are a nice intermediate point: you can sketch out the relevant computation on concrete values first, then worry about turning it into a function. If you canâ€™t write the examples, chances are you wonâ€™t be able to write the function either. Examples break down the programming process into smaller, manageable steps.\n\n#### 3.3.5Â Functions Practice: Cost of pens[ðŸ”—](#(part._pen-cost-pyret) \"Link to here\")\n\nLetâ€™s create one more function, this time for a more complicated example. Imagine that you are trying to compute the total cost of an order of pens with slogans (or messages) printed on them. Each pen costs 25 cents plus an additional 2 cents per character in the message (weâ€™ll count spaces between words as characters).\n\nFollowing our steps to create a function once again, letâ€™s start by writing two concrete expressions that do this computation.\n\n```", "```py\n\nThese examples introduce a new built-in function called `string-length`. It takes a string as input and produces the number of characters (including spaces and punctuation) in the string. These examples also show an example of working with numbers other than integers.Pyret requires a number before the decimal point, so if the â€œwhole numberâ€ part is zero, you need to write `0` before the decimal. Also observe that Pyret uses a decimal point; it doesnâ€™t support conventions such as [â€œ0,02â€](https://en.wikipedia.org/wiki/Decimal_separator).\n\nThe second step to writing a function was to identify which information differs across our two examples. In this case, we have two: the number of pens and the message to put on the pens. This means our function will have two parameters rather than just one.\n\n```", "```py\n\nOf course, as things get too long, it may be helpful to use multiple lines:\n\n```", "```py\n\nIf you want to write a multi-line docstring, you need to use ```", "```py ```", "```py\nfun pen-cost(num-pens :: Number, message :: String)\n  -> Number:\n  doc: ```", "```py\n  num-pens * (0.25 + (string-length(message) * 0.02))\nend\n```", "```py\nfun pen-cost(num-pens :: Number, message :: String)\n  -> Number:\n  doc: ```", "```py\n  num-pens * (0.25 + (string-length(message) * 0.02))\nwhere:\n  pen-cost(3, \"wow\")\n    is 3 * (0.25 + (string-length(\"wow\") * 0.02))\n  pen-cost(10, \"smile\")\n    is 10 * (0.25 + (string-length(\"smile\") * 0.02))\nend\n```", "```py\npen-cost(5, \"\") is 5 * 0.25\n```", "```py\npen-cost(0, \"bears\") is 0\n```", "```py\n> > pen-cost(0, \"\") is 0\n> > ```", "```py\n    pen-cost(10, \"Welcome\")\n    ```"]