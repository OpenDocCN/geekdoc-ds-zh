<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Machine Code Analyzers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Machine Code Analyzers</h1>
<blockquote>原文：<a href="https://en.algorithmica.org/hpc/profiling/mca/">https://en.algorithmica.org/hpc/profiling/mca/</a></blockquote><div id="search"><input id="search-bar" type="search" placeholder="Search this book…" oninput="search()"/><div id="search-count"/><div id="search-results"/></div><header><div class="info"/></header><article><p>A <em>machine code analyzer</em> is a program that takes a small snippet of assembly code and <a href="../simulation">simulates</a> its execution on a particular microarchitecture using information available to compilers, and outputs the latency and throughput of the whole block, as well as cycle-perfect utilization of various resources within the CPU.</p><span class="anchor" id="using-llvm-mca"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/profiling/mca/#using-llvm-mca">#</a>Using <code>llvm-mca</code></h3><p>There are many different machine code analyzers, but I personally prefer <code>llvm-mca</code>, which you can probably install via a package manager together with <code>clang</code>. You can also access it through a web-based tool called <a href="https://uica.uops.info">UICA</a> or in the <a href="https://godbolt.org/">Compiler Explorer</a> by selecting “Analysis” as the language.</p><p>What <code>llvm-mca</code> does is it runs a set number of iterations of a given assembly snippet and computes statistics about the resource usage of each instruction, which is useful for finding out where the bottleneck is.</p><p>We will consider the array sum as our simple example:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">loop:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">addl</span> <span class="p">(</span><span class="nv">%rax</span><span class="p">),</span> <span class="nv">%edx</span>
</span></span><span class="line"><span class="cl">    <span class="nf">addq</span> <span class="no">$4</span><span class="p">,</span> <span class="nv">%rax</span>
</span></span><span class="line"><span class="cl">    <span class="nf">cmpq</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="nv">%rax</span>
</span></span><span class="line"><span class="cl">    <span class="nf">jne</span>	 <span class="no">loop</span>
</span></span></code></pre></div><p>Here is its analysis with <code>llvm-mca</code> for the Skylake microarchitecture:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">Iterations</span><span class="p">:</span><span class="w">        </span><span class="m">100</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"/><span class="nt">Instructions</span><span class="p">:</span><span class="w">      </span><span class="m">400</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"/><span class="nt">Total Cycles</span><span class="p">:</span><span class="w">      </span><span class="m">108</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"/><span class="nt">Total uOps</span><span class="p">:</span><span class="w">        </span><span class="m">500</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"/><span class="nt">Dispatch Width</span><span class="p">:</span><span class="w">    </span><span class="m">6</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"/><span class="nt">uOps Per Cycle</span><span class="p">:</span><span class="w">    </span><span class="m">4.63</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"/><span class="nt">IPC</span><span class="p">:</span><span class="w">               </span><span class="m">3.70</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"/><span class="nt">Block RThroughput</span><span class="p">:</span><span class="w"> </span><span class="m">0.8</span><span class="w">
</span></span></span></code></pre></div><p>First, it outputs general information about the loop and the hardware:</p><ul><li>It “ran” the loop 100 times, executing 400 instructions in total in 108 cycles, which is the same as executing $\frac{400}{108} \approx 3.7$ <a href="/hpc/complexity/hardware">instructions per cycle</a> on average (IPC).</li><li>The CPU is theoretically capable of executing up to 6 instructions per cycle (<a href="/hpc/architecture/layout">dispatch width</a>).</li><li>Each cycle in theory can be executed in 0.8 cycles on average (<a href="/hpc/pipelining/tables">block reciprocal throughput</a>).</li><li>The “uOps” here are the micro-operations that the CPU splits each instruction into (e.g., fused load-add is composed of two uOps).</li></ul><p>Then it proceeds to give information about each individual instruction:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">Instruction Info</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"/><span class="nt">[1]</span><span class="p">:</span><span class="w"> </span><span class="l">uOps</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"/><span class="nt">[2]</span><span class="p">:</span><span class="w"> </span><span class="l">Latency</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"/><span class="nt">[3]</span><span class="p">:</span><span class="w"> </span><span class="l">RThroughput</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"/><span class="nt">[4]</span><span class="p">:</span><span class="w"> </span><span class="l">MayLoad</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"/><span class="nt">[5]</span><span class="p">:</span><span class="w"> </span><span class="l">MayStore</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"/><span class="nt">[6]</span><span class="p">:</span><span class="w"> </span><span class="l">HasSideEffects (U)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"/><span class="nt">[1]    [2]    [3]    [4]    [5]    [6]    Instructions</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="m">2</span><span class="w">      </span><span class="m">6</span><span class="w">     </span><span class="m">0.50</span><span class="w">    </span>*<span class="w">                   </span><span class="l">addl	(%rax), %edx</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="m">1</span><span class="w">      </span><span class="m">1</span><span class="w">     </span><span class="m">0.25</span><span class="w">                        </span><span class="l">addq	$4, %rax</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="m">1</span><span class="w">      </span><span class="m">1</span><span class="w">     </span><span class="m">0.25</span><span class="w">                        </span><span class="l">cmpq	%rcx, %rax</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="m">1</span><span class="w">      </span><span class="m">1</span><span class="w">     </span><span class="m">0.50</span><span class="w">                        </span><span class="l">jne	-11</span><span class="w">
</span></span></span></code></pre></div><p>There is nothing there that there isn’t in the <a href="/hpc/pipelining/tables">instruction tables</a>:</p><ul><li>how many uOps each instruction is split into;</li><li>how many cycles each instruction takes to complete (latency);</li><li>how many cycles each instruction takes to complete in the amortized sense (reciprocal throughput), considering that several copies of it can be executed simultaneously.</li></ul><p>Then it outputs probably the most important part — which instructions are executing when and where:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">Resource pressure by instruction</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"/><span class="nt">[0]    [1]    [2]    [3]    [4]    [5]    [6]    [7]    [8]    [9]    Instructions</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span>- <span class="w">     </span>- <span class="w">    </span><span class="m">0.01</span><span class="w">   </span><span class="m">0.98</span><span class="w">   </span><span class="m">0.50</span><span class="w">   </span><span class="m">0.50</span><span class="w">    </span>- <span class="w">     </span>- <span class="w">    </span><span class="m">0.01</span><span class="w">    </span>- <span class="w">    </span><span class="l">addl (%rax), %edx</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span>- <span class="w">     </span>- <span class="w">     </span>- <span class="w">     </span>- <span class="w">     </span>- <span class="w">     </span>- <span class="w">     </span>- <span class="w">    </span><span class="m">0.01</span><span class="w">   </span><span class="m">0.99</span><span class="w">    </span>- <span class="w">    </span><span class="l">addq $4, %rax</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span>- <span class="w">     </span>- <span class="w">     </span>- <span class="w">    </span><span class="m">0.01</span><span class="w">    </span>- <span class="w">     </span>- <span class="w">     </span>- <span class="w">    </span><span class="m">0.99</span><span class="w">    </span>- <span class="w">     </span>- <span class="w">    </span><span class="l">cmpq %rcx, %rax</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span>- <span class="w">     </span>- <span class="w">    </span><span class="m">0.99</span><span class="w">    </span>- <span class="w">     </span>- <span class="w">     </span>- <span class="w">     </span>- <span class="w">     </span>- <span class="w">    </span><span class="m">0.01</span><span class="w">    </span>- <span class="w">    </span><span class="l">jne  -11</span><span class="w">
</span></span></span></code></pre></div><p>As the contention for execution ports causes <a href="/hpc/pipelining/hazards">structural hazards</a>, ports often become the bottleneck for throughput-oriented loops, and this chart helps diagnose why. It does not give you a cycle-perfect Gantt chart of something like that, but it gives you the aggregate statistics of the execution ports used for each instruction, which lets you find which one is overloaded.</p></article><div class="nextprev"><div class="left"><a href="https://en.algorithmica.org/hpc/profiling/simulation/" id="prev-article">← Program Simulation</a></div><div class="right"><a href="https://en.algorithmica.org/hpc/profiling/benchmarking/" id="next-article">Benchmarking →</a></div></div>    
</body>
</html>