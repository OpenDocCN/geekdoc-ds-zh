<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Avoiding Interface Boxing¶</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Avoiding Interface Boxing¶</h1>
<blockquote>原文：<a href="https://goperf.dev/01-common-patterns/interface-boxing/">https://goperf.dev/01-common-patterns/interface-boxing/</a></blockquote>
                
                  


  
  



<p>Go’s interfaces make it easy to write flexible, decoupled code. But behind that convenience is a detail that can trip up performance: when a concrete value is assigned to an interface, Go wraps it in a hidden structure—a process called interface boxing.</p>
<p>In many cases, boxing is harmless. But in performance-sensitive code—like tight loops, hot paths, or high-throughput services—it can introduce hidden heap allocations, extra memory copying, and added pressure on the garbage collector. These effects often go unnoticed during development, only showing up later as latency spikes or memory bloat.</p>
<h2 id="what-is-interface-boxing">What is Interface Boxing?<a class="headerlink" href="#what-is-interface-boxing" title="Permanent link">¶</a></h2>
<p>Interface boxing refers to the process of converting a concrete value to an interface type. In Go, an interface value is internally represented as two words:</p>
<ul>
<li>A <strong>type descriptor</strong>, which holds information about the concrete type (its identity and method set).</li>
<li>A <strong>data pointer</strong>, which points to the actual value being stored.</li>
</ul>
<p>When you assign a value to an interface variable, Go creates this two-part structure. If the value is a non-pointer type—like a struct or primitive—and is not already on the heap, Go <strong>may</strong> allocate a copy of it on the heap to satisfy the interface assignment. This behavior is especially relevant when working with large values or when storing items in a slice of interfaces, where each element gets individually boxed. These implicit allocations can add up and are a common source of hidden memory pressure in Go programs.</p>
<p>Here’s a simple example:</p>
<div class="highlight"><pre><code>var i interface{}
i = 42
</code></pre></div>
<p>In this case, the integer <code>42</code> is boxed into an interface: Go stores the type information (<code>int</code>) and a copy of the value <code>42</code>. This is inexpensive for small values like <code>int</code>, but for large structs, the cost becomes non-trivial.</p>
<p>Another example:</p>
<div class="highlight"><pre><code>type Shape interface {
    Area() float64
}

type Square struct {
    Size float64
}

func (s Square) Area() float64 { return s.Size * s.Size }

func main() {
    var shapes []Shape
    for i := 0; i &lt; 1000; i++ {
        s := Square{Size: float64(i)}
        shapes = append(shapes, s) // boxing occurs here
    }
}
</code></pre></div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><strong>Pay attention to this code!</strong> In this example, even though <code>shapes</code> is a slice of interfaces, each <code>Square</code> value is copied into an interface when appended to <code>shapes</code>. If <code>Square</code> were a large struct, this would introduce 1000 allocations and large memory copying.</p>
</div>
<p>To avoid that, you could pass pointers:</p>
<div class="highlight"><pre><code>        shapes = append(shapes, &amp;s) // avoids large struct copy
</code></pre></div>
<p>This way, only an 8-byte pointer is stored in the interface, reducing both allocation size and copying overhead.</p>
<h2 id="why-it-matters">Why It Matters<a class="headerlink" href="#why-it-matters" title="Permanent link">¶</a></h2>
<p>In tight loops or high-throughput paths, such as unmarshalling JSON, rendering templates, or processing large collections, interface boxing can degrade performance by triggering unnecessary heap allocations and increasing GC pressure. This overhead is especially costly in systems with high concurrency or real-time responsiveness constraints.</p>
<p>Boxing can also make profiling and benchmarking misleading, since allocations attributed to innocuous-looking lines may actually stem from implicit conversions to interfaces.</p>
<h2 id="benchmarking-impact">Benchmarking Impact<a class="headerlink" href="#benchmarking-impact" title="Permanent link">¶</a></h2>
<p>For the benchmarking we will define an interface and a struct with a significant payload that implements the interface.</p>
<div class="highlight"><pre><code>type Worker interface {
    Work()
}

type LargeJob struct {
    payload [4096]byte
}

func (LargeJob) Work() {}
</code></pre></div>
<h3 id="boxing-large-structs">Boxing Large Structs<a class="headerlink" href="#boxing-large-structs" title="Permanent link">¶</a></h3>
<p>To demonstrate the real impact of boxing large values vs. pointers, we benchmarked the cost of assigning 1,000 large structs to an interface slice:</p>
<div class="highlight"><pre><code>func BenchmarkBoxedLargeSlice(b *testing.B) {
    jobs := make([]Worker, 0, 1000)
    for b.Loop() {
        jobs = jobs[:0]
        for j := 0; j &lt; 1000; j++ {
            var job LargeJob
            jobs = append(jobs, job)
        }
    }
}

func BenchmarkPointerLargeSlice(b *testing.B) {
    jobs := make([]Worker, 0, 1000)
    for b.Loop() {
        jobs := jobs[:0]
        for j := 0; j &lt; 1000; j++ {
            job := &amp;LargeJob{}
            jobs = append(jobs, job)
        }
    }
}
</code></pre></div>
<p>Benchmark Results</p>
<table>
<thead>
<tr>
<th>Benchmark</th>
<th>Time per op (ns)</th>
<th>Bytes per op</th>
<th>Allocs per op</th>
</tr>
</thead>
<tbody>
<tr>
<td>BoxedLargeSliceGrowth</td>
<td>404,649</td>
<td>~4.13 MB</td>
<td>1011</td>
</tr>
<tr>
<td>PointerLargeSliceGrowth</td>
<td>340,549</td>
<td>~4.13 MB</td>
<td>1011</td>
</tr>
</tbody>
</table>
<p>Boxing large values is significantly slower—about 19% in this case—due to the cost of copying the entire 4KB struct for each interface assignment. Boxing a pointer, however, avoids that cost and keeps the copy small (just 8 bytes). While both approaches allocate the same overall memory (since all values escape to the heap), pointer boxing has clear performance advantages under pressure.</p>
<h3 id="passing-to-a-function-that-accepts-an-interface">Passing to a Function That Accepts an Interface<a class="headerlink" href="#passing-to-a-function-that-accepts-an-interface" title="Permanent link">¶</a></h3>
<p>Another common source of boxing is when a large value is passed directly to a function that accepts an interface. Even without storing to a slice, boxing will occur at the call site.</p>
<div class="highlight"><pre><code>var sink Worker

func call(w Worker) {
    sink = w
}

func BenchmarkCallWithValue(b *testing.B) {
    for b.Loop() {
        var j LargeJob
        call(j)
    }
}

func BenchmarkCallWithPointer(b *testing.B) {
    for b.Loop() {
        j := &amp;LargeJob{}
        call(j)
    }
}
</code></pre></div>
<p>Benchmark Results</p>
<table>
<thead>
<tr>
<th>Benchmark</th>
<th>ns/op</th>
<th>B/op</th>
<th>allocs/op</th>
</tr>
</thead>
<tbody>
<tr>
<td>CallWithValue</td>
<td>422.5</td>
<td>4096</td>
<td>1</td>
</tr>
<tr>
<td>CallWithPointer</td>
<td>379.9</td>
<td>4096</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Passing a value to a function expecting an interface causes boxing, copying the full struct and allocating it on the heap. In our benchmark, this results in approximately 11% higher CPU cost compared to using a pointer. Passing a pointer avoids copying the struct, reduces memory movement, and results in smaller, more cache-friendly interface values, making it the more efficient choice in performance-sensitive scenarios.</p>
<details class="example">
<summary>Show the complete benchmark file</summary>
<div class="highlight"><pre><code>package perf

import "testing"


// interface-start

type Worker interface {
    Work()
}

type LargeJob struct {
    payload [4096]byte
}

func (LargeJob) Work() {}
// interface-end

// bench-slice-start
func BenchmarkBoxedLargeSlice(b *testing.B) {
    jobs := make([]Worker, 0, 1000)
    for b.Loop() {
        jobs = jobs[:0]
        for j := 0; j &lt; 1000; j++ {
            var job LargeJob
            jobs = append(jobs, job)
        }
    }
}

func BenchmarkPointerLargeSlice(b *testing.B) {
    jobs := make([]Worker, 0, 1000)
    for b.Loop() {
        jobs := jobs[:0]
        for j := 0; j &lt; 1000; j++ {
            job := &amp;LargeJob{}
            jobs = append(jobs, job)
        }
    }
}
// bench-slice-end

// bench-call-start
var sink Worker

func call(w Worker) {
    sink = w
}

func BenchmarkCallWithValue(b *testing.B) {
    for b.Loop() {
        var j LargeJob
        call(j)
    }
}

func BenchmarkCallWithPointer(b *testing.B) {
    for b.Loop() {
        j := &amp;LargeJob{}
        call(j)
    }
}
// bench-call-end
</code></pre></div>
</details>
<h2 id="when-interface-boxing-is-acceptable">When Interface Boxing Is Acceptable<a class="headerlink" href="#when-interface-boxing-is-acceptable" title="Permanent link">¶</a></h2>
<p>Despite its performance implications in some contexts, interface boxing is often perfectly reasonable—and sometimes preferred.</p>
<h3 id="when-abstraction-is-more-important-than-performance">When abstraction is more important than performance<a class="headerlink" href="#when-abstraction-is-more-important-than-performance" title="Permanent link">¶</a></h3>
<p>Interfaces enable decoupling and modularity. If you're designing a clean, testable API, the cost of boxing is negligible compared to the benefit of abstraction.</p>
<div class="highlight"><pre><code>type Storage interface {
    Save([]byte) error
}
func Process(s Storage) { /* ... */ }
</code></pre></div>
<h3 id="when-values-are-small-and-boxing-is-allocation-free">When values are small and boxing is allocation-free<a class="headerlink" href="#when-values-are-small-and-boxing-is-allocation-free" title="Permanent link">¶</a></h3>
<p>Boxing small, copyable values like <code>int</code>, <code>float64</code>, or small structs typically causes no allocations.</p>
<div class="highlight"><pre><code>var i interface{}
i = 123 // safe and cheap
</code></pre></div>
<h3 id="when-values-are-short-lived">When values are short-lived<a class="headerlink" href="#when-values-are-short-lived" title="Permanent link">¶</a></h3>
<p>If the boxed value is used briefly (e.g. for logging or interface-based sorting), the overhead is minimal.</p>
<div class="highlight"><pre><code>fmt.Println("value:", someStruct) // implicit boxing is fine
</code></pre></div>
<h3 id="when-dynamic-behavior-is-required">When dynamic behavior is required<a class="headerlink" href="#when-dynamic-behavior-is-required" title="Permanent link">¶</a></h3>
<p>Interfaces allow runtime polymorphism. If you need different types to implement the same behavior, boxing is necessary and idiomatic.</p>
<div class="highlight"><pre><code>for _, s := range []Shape{Circle{}, Square{}} {
    fmt.Println(s.Area())
}
</code></pre></div>
<p>Use boxing when it supports clarity, reusability, or design goals—and avoid it only in performance-critical code paths.</p>
<h2 id="how-to-avoid-interface-boxing">How to Avoid Interface Boxing<a class="headerlink" href="#how-to-avoid-interface-boxing" title="Permanent link">¶</a></h2>
<ul>
<li>Use pointers when assigning to interfaces. If the method set requires a pointer receiver or the value is large, explicitly pass a pointer to avoid repeated copying and heap allocation.
    <div class="highlight"><pre><code>for i := range tasks {
   result = append(result, &amp;tasks[i]) // Avoids boxing copies
}
</code></pre></div></li>
<li>Avoid interfaces in hot paths. If the concrete type is known and stable, avoid interface indirection entirely—especially in compute-intensive or allocation-sensitive functions.</li>
<li>Use type-specific containers. Instead of <code>[]interface{}</code>, prefer generic slices or typed collections where feasible. This preserves static typing and reduces unnecessary allocations.</li>
<li>Benchmark and inspect with pprof. Use <code>go test -bench</code> and <code>pprof</code> to observe where allocations occur. If the allocation site is in <code>runtime.convT2E</code> (convert T to interface), you're likely boxing.</li>
</ul>









  




                
                  
</body>
</html>