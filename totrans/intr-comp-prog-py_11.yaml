- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: CLASSES AND OBJECT-ORIENTED PROGRAMMING
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类与面向对象编程
- en: 'We now turn our attention to our last major topic related to programming in
    Python: using classes to organize programs around data abstractions.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将注意力转向与在 Python 中编程相关的最后一个主要主题：使用类来围绕数据抽象组织程序。
- en: Classes can be used in many different ways. In this book we emphasize using
    them in the context of **object-oriented programming**. The key to object-oriented
    programming is thinking about objects as collections of both data and the methods
    that operate on that data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以以多种不同的方式使用。在本书中，我们强调在**面向对象编程**的背景下使用它们。面向对象编程的关键在于将对象视为数据和操作这些数据的方法的集合。
- en: The ideas underlying object-oriented programming are about 50 years old, and
    have been widely accepted and practiced over the last 30 years or so. In the mid-1970s,
    people began to write articles explaining the benefits of this approach to programming.
    About the same time, the programming languages SmallTalk (at Xerox PARC) and CLU
    (at MIT) provided linguistic support for the ideas. But it wasn't until the arrival
    of C++ and Java that object-oriented programming really took off in practice.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的理念已有大约 50 年的历史，在过去的 30 年左右得到了广泛接受和实践。在 1970 年代中期，人们开始撰写文章解释这种编程方法的好处。大约在同一时间，编程语言
    SmallTalk（在 Xerox PARC）和 CLU（在 MIT）为这些理念提供了语言支持。但直到 C++ 和 Java 的出现，面向对象编程才真正开始在实践中蓬勃发展。
- en: We have been implicitly relying on object-oriented programming throughout most
    of this book. Back in Section 2.2.1 we said “Objects are the core things that
    Python programs manipulate. Every object has a **type** that defines the kinds
    of things that programs can do with that object.” Since Chapter 2, we have relied
    upon built-in types such as `float` and `str` and the methods associated with
    those types. But just as the designers of a programming language can build in
    only a small fraction of the useful functions, they can build in only a small
    fraction of the useful types. We have already looked at a mechanism that allows
    programmers to define new functions; we now look at a mechanism that allows programmers
    to define new types.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的大部分内容中，我们一直隐含地依赖于面向对象编程。在第 2.2.1 节中，我们说过：“对象是 Python 程序操作的核心。每个对象都有一个**类型**，定义了程序可以对该对象做的事情。”自第
    2 章以来，我们依赖于内置类型，如 `float` 和 `str` 及其相关的方法。但正如编程语言的设计者只能内置一小部分有用的函数，他们也只能内置一小部分有用的类型。我们已经看过一种允许程序员定义新函数的机制；现在我们将看一种允许程序员定义新类型的机制。
- en: 10.1 Abstract Data Types and Classes
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 抽象数据类型与类
- en: The notion of an abstract data type is quite simple. An **abstract data type**
    is a set of objects and the operations on those objects. These are bound together
    so that programmers can pass an object from one part of a program to another,
    and in doing so provide access not only to the data attributes of the object but
    also to operations that make it easy to manipulate that data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象数据类型的概念相当简单。**抽象数据类型**是一组对象及其上的操作。这些被绑定在一起，以便程序员可以将一个对象从程序的一个部分传递到另一个部分，并在此过程中提供对对象的数据属性的访问，以及方便操作这些数据的操作。
- en: The specifications of those operations define an **interface** between the abstract
    data type and the rest of the program. The interface defines the behavior of the
    operations—what they do, but not how they do it. The interface thus provides an
    **abstraction barrier** that isolates the rest of the program from the data structures,
    algorithms, and code involved in providing a realization of the type abstraction.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作的规范定义了抽象数据类型与程序其他部分之间的**接口**。接口定义了操作的行为——它们做什么，但不说明它们如何做到这一点。接口因此提供了一个**抽象屏障**，将程序的其余部分与提供类型抽象实现所涉及的数据结构、算法和代码隔离开来。
- en: 'Programming is about managing complexity in a way that facilitates change.
    Two powerful mechanisms are available for accomplishing this: decomposition and
    abstraction. **Decomposition** creates structure in a program, and **abstraction**
    suppresses detail. The key is to suppress the appropriate details. This is where
    data abstraction hits the mark. We can create domain-specific types that provide
    a convenient abstraction. Ideally, these types capture concepts that will be relevant
    over the lifetime of a program. If we start the programming process by devising
    types that will be relevant months and even decades later, we have a great leg
    up in maintaining that software.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 编程是以一种促进变化的方式来管理复杂性。有两种强大的机制可以实现这一点：分解和抽象。**分解**在程序中创建结构，而**抽象**则抑制细节。关键在于抑制适当的细节。这就是数据抽象能够发挥作用的地方。我们可以创建提供便利抽象的特定领域类型。理想情况下，这些类型捕捉在程序生命周期内相关的概念。如果我们在编程过程中设计出数月甚至数十年后仍然相关的类型，那么在维护该软件方面我们就有了很大的优势。
- en: We have been using abstract data types (without calling them that) throughout
    this book. We have written programs using integers, lists, floats, strings, and
    dictionaries without giving any thought to how these types might be implemented.
    To paraphrase Molière's *Bourgeois Gentilhomme*, *“Par ma foi, il y a plus de
    cent pages que nous avons utilisé ADTs, sans que nous le sachions.”*[^(60)](#c10-fn-0001)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们一直在使用抽象数据类型（尽管没有这样称呼它们）。我们已经编写了使用整数、列表、浮点数、字符串和字典的程序，而没有考虑这些类型可能是如何实现的。用莫里哀的*《布尔乔亚绅士》*的话来说，*“我发誓，有超过一百页我们使用了ADT，而我们并不知道。”*[^(60)](#c10-fn-0001)
- en: In Python, we implement data abstractions using **classes**. Each class definition
    begins with the reserved word `class` followed by the name of the class and some
    information about how it relates to other classes
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们使用**类**实现数据抽象。每个类定义以保留字`class`开头，后面跟着类名和关于它如何与其他类相关的信息。
- en: Consider the following tiny (and totally useless) **class definition**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下微小（完全无用的）**类定义**。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line indicates that `Toy` is a subclass of `object`. For now, ignore
    what it means to be a subclass. We will get to that shortly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行表示`Toy`是`object`的子类。目前，忽略作为子类意味着什么。我们很快就会涉及到这一点。
- en: A class definition creates an object of type `type` and associates with that
    class object a set of objects called **attributes**. In this example, the three
    attributes associated with the class are `__init__`, `add`, and `size.` Each is
    of type `function`. Consequently, the code,
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义创建一个`type`类型的对象，并将一组称为**属性**的对象与该类对象关联。在这个例子中，与类相关的三个属性是`__init__`、`add`和`size`。每个属性都是`function`类型。因此，代码
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: prints
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we will see, Python has a number of special function names that start and
    end with two underscores. These are often referred to as **magic methods**.[^(61)](#c10-fn-0002)
    The first of these we will look at is `__init__.` Whenever a class is instantiated,
    a call is made to the `__init__` function defined in that class. When the line
    of code
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，Python有许多特殊的函数名称以两个下划线开始和结束。这些通常被称为**魔法方法**。[^(61)](#c10-fn-0002)我们将要看的第一个是`__init__`。每当类被实例化时，都会调用在该类中定义的`__init__`函数。当执行以下代码行时
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: is executed, the interpreter will create a new **instance** of type `Toy`, and
    then call `Toy.__init__` with the newly created object as the actual parameter
    that is bound to the formal parameter `self`. When invoked, `Toy.__init__` creates
    the list object `_elems,` which becomes part of the newly created instance of
    type `Toy`. (The list is created using the by now familiar notation `[]`, which
    is simply an abbreviation for `list()`.) The list `_elems` is called a **data
    attribute** of the instance of `Toy`. The code
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 被执行时，解释器将创建一个新的`Toy`类型的**实例**，然后调用`Toy.__init__`，将新创建的对象作为实际参数绑定到形式参数`self`。当调用`Toy.__init__`时，会创建列表对象`_elems`，它成为新创建的`Toy`类型实例的一部分。（该列表使用现在已熟悉的`[]`符号创建，实际上是`list()`的缩写。）列表`_elems`被称为`Toy`实例的**数据属性**。代码
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: prints
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that `t1.add` is of type `method`, whereas `Toy.add` is of type `function`.
    Because `t1.add` is a method, we can invoke it (and `t1.size`) using dot notation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`t1.add`是`method`类型，而`Toy.add`是`function`类型。由于`t1.add`是一个方法，我们可以使用点表示法调用它（和`t1.size`）。
- en: 'A class should not be confused with instances of that class, just as an object
    of type `list` should not be confused with the `list` type. Attributes can be
    associated either with a class itself or with instances of a class:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 类不应与该类的实例混淆，就像`list`类型的对象不应与`list`类型混淆一样。属性可以与类本身或类的实例关联：
- en: Class attributes are defined in a class definition; for example `Toy.size` is
    an attribute of the class `Toy.` When the class is instantiated, e.g., by the
    statement `t = Toy()`, instance attributes, e.g., `t.size`, are created.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类属性是在类定义中定义的；例如，`Toy.size`是类`Toy`的一个属性。当类被实例化时，比如通过语句`t = Toy()`，实例属性，比如`t.size`，会被创建。
- en: While `t.size` is initially bound to the `size` function defined in the class
    `Toy`, that binding can be changed during the course of a computation. For example,
    you could (but definitely should not!) change the binding by executing `t.size = 3`.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然`t.size`最初绑定到类`Toy`中定义的`size`函数，但在计算过程中，这种绑定是可以改变的。例如，你可以（但绝对不应该！）通过执行`t.size
    = 3`来改变绑定。
- en: "When data attributes are associated with a class, we call them **class variables**.\
    \ When they are associated with an instance, we call them **instance variables**.\
    \ For example, `\uFEFF_elems` is an instance variable because for each instance\
    \ of class `Toy`, `\uFEFF_elems` is bound to a different list. So far, we haven't\
    \ seen a class variable. We will use one in [Figure 10-4](#c10-fig-0004)."
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据属性与类关联时，我们称它们为**类变量**。当它们与实例关联时，我们称它们为**实例变量**。例如，`_elems`是一个实例变量，因为对于每个`Toy`类的实例，`_elems`绑定到一个不同的列表。到目前为止，我们还没有看到类变量。我们将在[图
    10-4](#c10-fig-0004)中使用一个。
- en: Now, consider the code
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑一下这段代码。
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since each instance of `Toy` is a different object, each instance of type `Toy`
    will have a different `_elems` attribute. Therefore, the code prints `3.`
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个`Toy`实例都是不同的对象，所以每个`Toy`类型的实例都会有不同的`_elems`属性。因此，代码输出`3.`。
- en: At first blush, something appears to be inconsistent in this code. It looks
    as if each method is being called with one argument too few. For example, `add`
    has two formal parameters, but we appear to be calling it with only one actual
    parameter. This is an artifact of using dot notation to invoke a method associated
    with an instance of a class. The object associated with the expression preceding
    the dot is implicitly passed as the first parameter to the method. Throughout
    this book, we follow the convention of using `self` as the name of the formal
    parameter to which this actual parameter is bound. Python programmers observe
    this convention almost universally, and we strongly suggest that you use it as
    well.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，这段代码似乎存在不一致的地方。看起来每个方法调用时参数少了一。比如，`add`有两个正式参数，但我们似乎只用一个实际参数在调用它。这是使用点表示法调用与类实例相关联的方法的结果。与点前的表达式相关联的对象会隐式地作为第一个参数传递给方法。在本书中，我们遵循使用`self`作为这个实际参数绑定的正式参数名称的惯例。Python程序员几乎普遍遵循这一惯例，我们强烈建议你也这样做。
- en: Another common convention is to start the name of data attributes with an underscore.
    As we discuss in detail in Section 10.3, we use the leading `_` to indicate that
    the attribute is private to the class, i.e., should not be directly accessed outside
    the class.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的惯例是以一个下划线开始数据属性的名称。正如我们在10.3节中详细讨论的那样，我们使用前导的`_`来表示该属性是类的私有属性，即不应在类外部直接访问。
- en: Now, let's look at a more interesting example. [Figure 10-1](#c10-fig-0001)
    contains a **class definition** that provides a straightforward implementation
    of a set-of-integers abstraction called `Int_set`. (Given that Python has a built-in
    type `set`, this implementation is both unnecessary and unnecessarily complicated.
    However, it is pedagogically useful.)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一个更有趣的例子。[图 10-1](#c10-fig-0001)包含一个**类定义**，它提供了一个名为`Int_set`的整数集合抽象的简单实现。（考虑到Python有内置的`set`类型，这个实现既不必要又不必要地复杂。不过，它在教学上是有用的。）
- en: '![c10-fig-0001.jpg](../images/c10-fig-0001.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![c10-fig-0001.jpg](../images/c10-fig-0001.jpg)'
- en: '[Figure 10-1](#c10-fig-0001a) Class `Int_set`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-1](#c10-fig-0001) 类`Int_set`'
- en: Notice that the docstring (the comment enclosed in `"""`) at the top of the
    class definition describes the abstraction provided by the class, not information
    about how the class is implemented. In contrast, the comments below the docstring
    contain information about the implementation. That information is aimed at programmers
    who might want to modify the implementation or build subclasses (see Section 10.2)
    of the class, not at programmers who might want to use the abstraction.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，类定义顶部的文档字符串（用`"""`括起来的注释）描述的是类提供的抽象，而不是类的实现信息。相比之下，文档字符串下方的注释包含实现信息。这些信息面向可能想修改实现或构建该类子类的程序员，而不是希望使用该抽象的程序员。
- en: As we have seen, methods associated with an instance of a class can be invoked
    using dot notation. For example, the code,
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，与类实例相关的方法可以使用点符号调用。例如，代码，
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: creates a new instance of `Int_set`, inserts the integer 3 into that `Int_set`,
    and then prints `True`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`Int_set`实例，将整数3插入该`Int_set`，然后打印`True`。
- en: 'Data abstraction achieves representation-independence. Think of the implementation
    of an abstract type as having several components:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 数据抽象实现了表示独立性。将抽象类型的实现视为具有多个组件：
- en: Implementations of the methods of the type
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类型方法的实现
- en: Data structures that together encode values of the type
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一起编码该类型值的数据结构
- en: Conventions about how the implementations of the methods are to use the data
    structures; a key convention is captured by the representation invariant
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于方法实现如何使用数据结构的约定；一个关键约定由表示不变性捕捉
- en: The **representation invariant** defines which values of the data attributes
    correspond to valid representations of class instances. The representation invariant
    for `Int_set` is that `vals` contains no duplicates. The implementation of `__init__`
    is responsible for establishing the invariant (which holds for the empty list),
    and the other methods are responsible for maintaining that invariant. That is
    why `insert` appends `e` only if it is not already in `self.vals`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**表示不变性**定义了数据属性的哪些值对应于类实例的有效表示。`Int_set`的表示不变性是`vals`不包含重复值。`__init__`的实现负责建立该不变性（空列表时成立），其他方法负责维护该不变性。这就是为什么`insert`仅在`self.vals`中不存在`e`时才会添加它。'
- en: The implementation of `remove` exploits the assumption that the representation
    invariant is satisfied when `remove` is entered. It calls `list.remove` only once,
    since the representation invariant guarantees that there is at most one occurrence
    of `e` in `self.vals`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove`的实现利用了在进入`remove`时满足表示不变性的假设。它仅调用一次`list.remove`，因为表示不变性保证`self.vals`中最多只有一个`e`的出现。'
- en: The last method defined in the class, `__str__`, is another one of those special
    `__` methods. The `__str__` method of a class is invoked when a program converts
    an instance of that class to a string by calling `str`. Therefore, when the `print`
    command is used, the `__str__` function associated with the object to be printed
    is invoked. For example, the code
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 类中定义的最后一个方法`__str__`是另一种特殊的`__`方法。当程序通过调用`str`将该类的实例转换为字符串时，将调用类的`__str__`方法。因此，当使用`print`命令时，打印对象的`__str__`函数将被调用。例如，代码
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: will print
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将打印
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: (If `no __str__` method were defined, executing `print(s)` would cause something
    like `<__main__.Int_set object at 0x1663510>` to be printed.)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: （如果没有定义`__str__`方法，执行`print(s)`将打印类似于`<__main__.Int_set object at 0x1663510>`的内容。）
- en: '**Finger exercise:** Add a method satisfying the specification below to the
    `Int_set` class.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**手指练习：** 向`Int_set`类添加一个满足以下规范的方法。'
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 10.1.1 Magic Methods and Hashable Types
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1 魔法方法与可哈希类型
- en: One of the design goals for Python was to allow programmers to use classes to
    define new types that are as easy to use as the built-in types of Python. Using
    magic methods to provide class-specific definitions of built-in functions such
    as `str` and `len` plays an important role in achieving this goal.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Python设计目标之一是允许程序员使用类定义新的类型，使其使用与Python内置类型一样简单。使用魔法方法为内置函数如`str`和`len`提供类特定的定义在实现这一目标中发挥了重要作用。
- en: Magic methods can also be used to provide class-specific definitions for infix
    operators such as == and +. The names of the methods available for infix operators
    are
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法方法还可以用于为中缀运算符如==和+提供类特定的定义。可用于中缀运算符的方法名称是
- en: '| `+: __add__` | `*: __mul__` | `/: __truediv__` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `+: __add__` | `*: __mul__` | `/: __truediv__` |'
- en: '| `-: __sub__` | `//: __floordiv__` | `%: __mod__` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `-: __sub__` | `//: __floordiv__` | `%: __mod__` |'
- en: '| `**: __pow__` | `&#124;: __or__` | `<: __lt__` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `**: __pow__` | `&#124;: __or__` | `<: __lt__` |'
- en: '| `<<: __lshift__` | `∧: __xor__` | `>: __gt__` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `<<: __lshift__` | `∧: __xor__` | `>: __gt__` |'
- en: '| `>>: __rshsift__` | `==: __eq__` | `<=: __le__` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `>>: __rshsift__` | `==: __eq__` | `<=: __le__` |'
- en: '| `&: __and__` | `!=: __ne__` | `>=: __ge__` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `&: __and__` | `!=: __ne__` | `>=: __ge__` |'
- en: You can associate any implementation you want with these operators. If you wanted,
    you could implement `+` as subtraction, `<` as exponentiation, etc. We recommend,
    however, that you resist the opportunity to be imaginative, and stick to implementations
    consistent with the conventional meanings of these operators.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将任何实现与这些操作符关联。如果你愿意，可以将`+`实现为减法，将`<`实现为指数运算，等等。然而，我们建议你抵制这种想象力的机会，保持与这些操作符的传统含义一致的实现。
- en: Returning to our toy example, consider the code in [Figure 10-2](#c10-fig-0002).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的玩具示例，考虑[图10-2](#c10-fig-0002)中的代码。
- en: '![c10-fig-0002.jpg](../images/c10-fig-0002.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![c10-fig-0002.jpg](../images/c10-fig-0002.jpg)'
- en: '[Figure 10-2](#c10-fig-0002a) Using magic methods'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-2](#c10-fig-0002a) 使用魔法方法'
- en: When the code in [Figure 10-2](#c10-fig-0002) is run it prints
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行[图10-2](#c10-fig-0002)中的代码时，它会打印
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: "We can use instances of `Toy` as dictionary keys because we defined a `__hash__`\
    \ function for the class. Had we defined an `__eq__` function and not defined\
    \ a `__hash__` function, the code would have generated the error message \uFEFF\
    `unhashable type: ‘Toy'` when we attempted to create a dictionary using `t1` and\
    \ `t2` as keys. When a user-defined `__hash__` is provided, it should ensure that\
    \ the hash value of an object is constant throughout the lifetime of that object."
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以将`Toy`的实例用作字典的键，因为我们为该类定义了`__hash__`函数。如果我们定义了`__eq__`函数但没有定义`__hash__`函数，当我们尝试使用`t1`和`t2`作为键创建字典时，代码将生成错误消息`unhashable
    type: ‘Toy''`。提供用户定义的`__hash__`时，应该确保对象的哈希值在该对象的生命周期内保持不变。'
- en: All instances of user-defined classes that do not explicitly define `__eq__`
    use object identity for `==` and are hashable. If no `__hash__` method is provided,
    the hash value of the object is derived from the object's identity (see Section
    5.3).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所有未显式定义`__eq__`的用户定义类的实例在`==`中使用对象标识，并且是可哈希的。如果没有提供`__hash__`方法，则对象的哈希值来自对象的标识（见第5.3节）。
- en: '**Finger exercise**: Replace the `union` method you added to `Int_set` by a
    method that allows clients of `Int_set` to use the ­`+` operator to denote set
    union.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**手指练习**：用一种允许`Int_set`的客户端使用`+`操作符表示集合并集的方法替换你添加到`Int_set`中的`union`方法。'
- en: 10.1.2 Designing Programs Using Abstract Data Types
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.2 使用抽象数据类型设计程序
- en: Abstract data types are a big deal. They lead to a different way of thinking
    about organizing large programs. When we think about the world, we rely on abstractions.
    In the world of finance, people talk about stocks and bonds. In the world of biology,
    people talk about proteins and residues. When trying to understand concepts such
    as these, we mentally gather together some of the relevant data and features of
    these kinds of objects into one intellectual package. For example, we think of
    bonds as having an interest rate, a maturity date, and a price as data attributes.
    We also think of bonds as having operations such as “set price” and “calculate
    yield to maturity.” Abstract data types allow us to incorporate this kind of organization
    into the design of programs.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象数据类型非常重要。它们导致了对组织大型程序的新思维方式。当我们思考世界时，我们依赖于抽象。在金融界，人们谈论股票和债券。在生物界，人们谈论蛋白质和残基。当试图理解这些概念时，我们会在脑海中将相关数据和特征汇集成一个知识包。例如，我们认为债券具有利率、到期日和价格等数据属性。我们还认为债券具有“设定价格”和“计算到期收益率”等操作。抽象数据类型使我们能够将这种组织方式融入程序设计中。
- en: Data abstraction encourages program designers to focus on the centrality of
    data objects rather than functions. Thinking about a program more as a collection
    of types than as a collection of functions leads to a profoundly different organizing
    principle. Among other things, it encourages us to think about programming as
    a process of combining relatively large chunks, since data abstractions typically
    encompass more functionality than do individual functions. This, in turn, leads
    us to think of the essence of programming as a process not of writing individual
    lines of code, but of composing abstractions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 数据抽象鼓励程序设计者关注数据对象的核心，而不是函数。将程序更多地视为类型的集合而不是函数的集合，会导致根本不同的组织原则。除此之外，它鼓励我们将编程视为组合相对较大块的过程，因为数据抽象通常涵盖比单个函数更多的功能。这反过来使我们认为编程的本质是一个不是写个别代码行，而是组合抽象的过程。
- en: The availability of reusable abstractions not only reduces development time,
    but usually leads to more reliable programs, because mature software is usually
    more reliable than new software. For many years, the only program libraries in
    common use were statistical or scientific. Today, however, there is a great range
    of available program libraries (especially for Python), often based on a rich
    set of data abstractions, as we shall see later in this book.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可重用抽象的可用性不仅减少了开发时间，而且通常导致更可靠的程序，因为成熟的软件通常比新软件更可靠。多年来，常用的程序库只有统计或科学库。然而，今天可用的程序库范围广泛（尤其是针对Python），通常基于丰富的数据抽象集，正如我们在本书后面将看到的那样。
- en: 10.1.3 Using Classes to Keep Track of Students and Faculty
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.3 使用类跟踪学生和教职工
- en: As an example use of classes, imagine that you are designing a program to help
    keep track of all the students and faculty at a university. It is certainly possible
    to write such a program without using data abstraction. Each student would have
    a family name, a given name, a home address, a year, some grades, etc. This data
    could all be kept in a combination of lists and dictionaries. Keeping track of
    faculty and staff would require some similar data structures and some different
    data structures, e.g., data structures to keep track of things like salary history.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作为类的示例使用，想象你正在设计一个程序，以帮助跟踪大学的所有学生和教职工。确实可以在不使用数据抽象的情况下编写这样的程序。每个学生将有一个姓氏、名字、家庭地址、年级、一些成绩等。这些数据可以通过列表和字典的组合来存储。跟踪教职工需要一些类似的数据结构和一些不同的数据结构，例如，用于跟踪薪资历史的数据结构。
- en: Before rushing in to design a bunch of data structures, let's think about some
    abstractions that might prove useful. Is there an abstraction that covers the
    common attributes of students, professors, and staff? Some would argue that they
    are all human. [Figure 10-3](#c10-fig-0003) contains a class that incorporates
    two common attributes (name and birthday) of humans. It uses the standard Python
    library module `datetime`, which provides many convenient methods for creating
    and manipulating dates.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在急于设计一堆数据结构之前，让我们考虑一些可能有用的抽象。是否存在一个覆盖学生、教授和工作人员共同属性的抽象？有人会争辩说，他们都是人。[图 10-3](#c10-fig-0003)包含一个类，它结合了人类的两个共同属性（姓名和生日）。它使用了标准的Python库模块`datetime`，该模块提供了许多方便的方法来创建和处理日期。
- en: '![c10-fig-0003.jpg](../images/c10-fig-0003.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![c10-fig-0003.jpg](../images/c10-fig-0003.jpg)'
- en: '[Figure 10-3](#c10-fig-0003a) Class `Person`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-3](#c10-fig-0003a) 类`Person`'
- en: The following code uses `Person` and `datetime`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用了`Person`和`datetime`。
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that whenever `Person` is instantiated, an argument is supplied to the
    `__init__` function. In general, when instantiating a class we need to look at
    the specification of the `__init__` function for that class to know what arguments
    to supply and what properties those arguments should have.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每当实例化`Person`时，都需要向`__init__`函数提供一个参数。一般来说，实例化一个类时，我们需要查看该类的`__init__`函数的规范，以了解需要提供哪些参数以及这些参数应该具备什么属性。
- en: "Executing the above code creates three instances of class `Person`. We can\
    \ access information about these instances using the methods associated with them.\
    \ For example, `him.\uFEFFget_last_name()` returns `'Obama'`. The expression `him._last_name`\
    \ will also return `'Obama'`; however, for reasons discussed later in this chapter,\
    \ writing expressions that directly access instance variables is considered poor\
    \ form, and should be avoided. Similarly, there is no appropriate way for a user\
    \ of the `Person` abstraction to extract a person's birthday, despite the fact\
    \ that the implementation contains an attribute with that value. (Of course, it\
    \ would be easy to add a `get_birthday` method to the class.) There is, however,\
    \ a way to extract information that depends upon the person's birthday, as illustrated\
    \ by the last `print` statement in the above code."
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码会创建三个类`Person`的实例。我们可以使用与这些实例相关联的方法访问有关它们的信息。例如，`him.get_last_name()`返回`'Obama'`。表达式`him._last_name`也会返回`'Obama'`；然而，由于本章后面讨论的原因，直接访问实例变量的表达式被认为是不良的写法，应当避免。同样，尽管实现中包含一个具有该值的属性，但对于`Person`抽象的用户来说，没有合适的方法提取一个人的生日。（当然，可以很容易地为该类添加一个`get_birthday`方法。）不过，有一种方法可以提取依赖于个人生日的信息，如上述代码中的最后一个`print`语句所示。
- en: Class `Person` provides a `Person`-specific definition for yet another specially
    named method, `__lt__.` This method overloads the `<` operator. The method `Person__lt__`
    gets called whenever the first argument to the `<` operator is of type `Person`.
    The `__lt__` method in class `Person` is implemented using the binary `<` operator
    of type `str`. The expression `self._name < other._name` is shorthand for `self._name.__lt__(other._name)`.
    Since `self._name` is of type `str`, this `__lt__` method is the one associated
    with type `str`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 类`Person`为另一个特殊命名方法`__lt__`提供了特定于`Person`的定义。该方法重载了`<`运算符。每当`<`运算符的第一个参数为`Person`类型时，方法`Person__lt__`会被调用。类`Person`中的`__lt__`方法是使用类型`str`的二元`<`运算符实现的。表达式`self._name
    < other._name`是`self._name.__lt__(other._name)`的简写。由于`self._name`是`str`类型，因此这个`__lt__`方法与类型`str`相关联。
- en: In addition to providing the syntactic convenience of writing infix expressions
    that use `<`, this overloading provides automatic access to any polymorphic method
    defined using `__lt__`. The built-in method `sort` is one such method. So, for
    example, if `p_list` is a list composed of elements of type `Person`, the call
    `p_list.sort()` will sort that list using the `__lt__` method defined in class
    `Person`. Therefore, the code
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供使用`<`的中缀表达式书写的语法便利外，这种重载还自动访问任何使用`__lt__`定义的多态方法。内置方法`sort`就是这样一个方法。因此，例如，如果`p_list`是由`Person`类型元素组成的列表，则调用`p_list.sort()`将使用类`Person`中定义的`__lt__`方法对该列表进行排序。因此，代码
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: will print
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将打印
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 10.2 Inheritance
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 继承
- en: Many types have properties in common with other types. For example, types `list`
    and `str` each have `len` functions that mean the same thing. **Inheritance**
    provides a convenient mechanism for building groups of related abstractions. It
    allows programmers to create a type hierarchy in which each type inherits attributes
    from the types above it in the hierarchy.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 许多类型与其他类型有共同的属性。例如，类型`list`和`str`各自都有`len`函数，其意义相同。**继承**提供了一种方便的机制，用于构建相关抽象的分组。它允许程序员创建一个类型层次结构，在这个结构中，每个类型从其上层类型继承属性。
- en: The class `object` is at the top of the hierarchy. This makes sense, since in
    Python everything that exists at runtime is an object. Because `Person` inherits
    all of the properties of objects, programs can bind a variable to a `Person`,
    append a `Person` to a list, etc.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 类`object`位于层次结构的顶部。这是合理的，因为在Python中，运行时存在的所有内容都是对象。由于`Person`继承了对象的所有属性，程序可以将变量绑定到`Person`，将`Person`添加到列表等。
- en: 'The class `MIT_person` in [Figure 10-4](#c10-fig-0004) inherits attributes
    from its parent class, `Person`, including all of the attributes that `Person`
    inherited from its parent class, `object`. In the jargon of object-oriented programming,
    `MIT_person` is a **subclass** of `Person`, and therefore **inherits** the attributes
    of its **superclass**. In addition to what it inherits, the subclass can:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-4](#c10-fig-0004)中的类`MIT_person`继承自其父类`Person`的属性，包括`Person`从其父类`object`继承的所有属性。在面向对象编程的术语中，`MIT_person`是`Person`的**子类**，因此**继承**了其**超类**的属性。除了继承的属性外，子类还可以：'
- en: Add new attributes. For example, the subclass `MIT_person` has added the class
    variable _`next_id_num`, the instance variable _`id_num`, and the method `get_id_num`.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新属性。例如，子类`MIT_person`添加了类变量_`next_id_num`、实例变量_`id_num`以及方法`get_id_num`。
- en: '**Override**, i.e., replace, attributes of the superclass. For example, `MIT_person`
    has overridden `__init__` and `__lt__`. When a method has been overridden, the
    version of the method that is executed is based on the object used to invoke the
    method. If the type of the object is the subclass, the version defined in the
    subclass will be used. If the type of the object is the superclass, the version
    in the superclass will be used.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**覆盖**，即替换超类的属性。例如，`MIT_person`覆盖了`__init__`和`__lt__`。当一个方法被覆盖时，执行的方法版本取决于用于调用该方法的对象。如果对象的类型是子类，则使用在子类中定义的版本。如果对象的类型是超类，则使用超类中的版本。'
- en: "The method `MIT_person.__init__` first uses `\uFEFFsuper().__init__(name)`\
    \ to invoke the `__init__` function of its super class (`Person)`. This initializes\
    \ the `inherited` instance variable `self._name`. It then initializes `self._id_num`,\
    \ which is an instance variable that instances of `MIT_person` have but instances\
    \ of `Person` do not."
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`MIT_person.__init__`首先使用`super().__init__(name)`调用其超类（`Person`）的`__init__`函数。这初始化了继承的实例变量`self._name`。然后它初始化`self._id_num`，这是`MIT_person`的实例拥有但`Person`的实例没有的实例变量。
- en: The instance variable `self._id_num` is initialized using a **class** **variable**,
    _`next_id_num`, that belongs to the class `MIT_person`, rather than to instances
    of the class. When an instance of `MIT_person` is created, a new instance of `next_id_num`
    is not created. This allows `__init__` to ensure that each instance of `MIT_person`
    has a unique _`id_num`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量`self._id_num`使用一个属于类`MIT_person`的**类** **变量**_`next_id_num`进行初始化，而不是类的实例。当创建`MIT_person`的实例时，并不会创建一个新的`next_id_num`实例。这允许`__init__`确保每个`MIT_person`的实例都有一个唯一的_`id_num`。
- en: '![c10-fig-0004.jpg](../images/c10-fig-0004.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![c10-fig-0004.jpg](../images/c10-fig-0004.jpg)'
- en: '[Figure 10-4](#c10-fig-0004a) Class `MIT_person`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-4](#c10-fig-0004a) 类`MIT_person`'
- en: Consider the code
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这段代码
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first line creates a new `MIT_person`. The second line is more complicated.
    When it attempts to evaluate the expression `str(p1)`, the runtime system first
    checks to see if there is an `__str__` method associated with class `MIT_person`.
    Since there is not, it next checks to see if there is an `__str__` method associated
    with the immediate superclass, `Person`, of `MIT_person`. There is, so it uses
    that. When the runtime system attempts to evaluate the expression `p1.get_id_num()`,
    it first checks to see if there is a `get_id_num` method associated with class
    `MIT_person`. There is, so it invokes that method and prints
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个新的`MIT_person`。第二行则更复杂。当它尝试评估表达式`str(p1)`时，运行时系统首先检查类`MIT_person`是否有与之关联的`__str__`方法。由于没有，它接着检查`MIT_person`的直接超类`Person`是否有`__str__`方法。确实存在，因此使用该方法。当运行时系统尝试评估表达式`p1.get_id_num()`时，它首先检查类`MIT_person`是否有与之关联的`get_id_num`方法。确实存在，因此它调用该方法并打印
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: (Recall that in a string, the character “`\`” is an escape character used to
    indicate that the next character should be treated in a special way. In the string
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: （回想一下，在字符串中，字符“`\`”是一个转义字符，用于指示下一个字符应以特殊方式处理。在字符串中
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: the “`\`” indicates that the apostrophe is part of the string, not a delimiter
    terminating the string.)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: “`\`”表示撇号是字符串的一部分，而不是终止字符串的分隔符。）
- en: Now consider the code
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑这段代码
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We have created four virtual people, three of whom are named Billy Bob Beaver.
    Two of the Billy Bobs are of type `MIT_person`, and one merely a `Person`. If
    we execute the lines of code
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了四个虚拟人物，其中三个名为**比利·鲍勃·河狸**。两个比利·鲍勃是类型为`MIT_person`，而一个仅是`Person`。如果我们执行以下代码行
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: the interpreter will print
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器将打印
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Since `p1`, `p2`, and `p3` are all of type `MIT_person`, the interpreter will
    use the `__lt__` method defined in class `MIT_person` when evaluating the first
    two comparisons, so the ordering will be based on identification numbers. In the
    third comparison, the `<` operator is applied to operands of different types.
    Since the first argument of the expression is used to determine which `__lt__`
    method to invoke, `p4 < p1` is shorthand for `p4.__lt__(p1)`. Therefore, the interpreter
    uses the `__lt__ method` associated with the type of `p4`, `Person`, and the “people”
    will be ordered by name.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`p1`、`p2`和`p3`都是`MIT_person`类型，解释器在评估前两个比较时将使用在`MIT_person`类中定义的`__lt__`方法，因此排序将基于识别号。在第三个比较中，`<`运算符应用于不同类型的操作数。由于表达式的第一个参数用于确定调用哪个`__lt__`方法，因此`p4
    < p1`是`p4.__lt__(p1)`的简写。因此，解释器使用与`p4`类型相关的`__lt__`方法`Person`，并按名称对“人”进行排序。
- en: What happens if we try
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The runtime system will invoke the `__lt__` operator associated with the type
    of `p1`, i.e., the one defined in class `MIT_person`. This will lead to the exception
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时系统将调用与`p1`类型相关联的`__lt__`运算符，即在`MIT_person`类中定义的那个。这将导致异常。
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: because the object to which `p4` is bound does not have an attribute _`id_num`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`p4`绑定的对象没有属性_`id_num`。
- en: '**Finger exercise**: Implement a subclass of `Person` that meets the specification'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**：实现一个符合规范的`Person`子类。'
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 10.2.1 Multiple Levels of Inheritance
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 多层继承
- en: '[Figure 10-5](#c10-fig-0005) adds another couple of levels of inheritance to
    the class hierarchy.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-5](#c10-fig-0005) 为类层次结构增加了另几层继承。'
- en: '![c10-fig-0005.jpg](../images/c10-fig-0005.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![c10-fig-0005.jpg](../images/c10-fig-0005.jpg)'
- en: '[Figure 10-5](#c10-fig-0005a) Two kinds of students'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-5](#c10-fig-0005a) 两种类型的学生'
- en: Adding `UG` seems logical, because we want to associate a year of graduation
    (or perhaps anticipated graduation) with each undergraduate. But what is going
    on with the classes `Student` and `Grad`? By using the Python reserved word `**pass**`
    as the body, we indicate that the class has no attributes other than those inherited
    from its superclass. Why would anyone ever want to create a class with no new
    attributes?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`UG`似乎是合乎逻辑的，因为我们希望将每位本科生与一个毕业年份（或预期毕业年份）关联起来。但`Student`和`Grad`类有什么情况呢？通过使用Python保留字`**pass**`作为主体，我们表明该类除了从其超类继承的属性外没有其他属性。为什么会有人想创建一个没有新属性的类呢？
- en: By introducing the class `Grad`, we gain the ability to create two kinds of
    students and use their types to distinguish one kind of object from another. For
    example, the code
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入类`Grad`，我们获得了创建两种类型学生的能力，并使用它们的类型来区分一种对象与另一种对象。例如，代码
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: will print
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将打印
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The utility of the intermediate type `Student` is subtler. Consider going back
    to `class` `MIT_person` and adding the method
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 中间类型`Student`的实用性更为微妙。考虑回到`class` `MIT_person`并添加该方法。
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The function `isinstance` is built into Python. The first argument of `isinstance`
    can be any object, but the second argument must be an object of type `type` or
    a tuple of objects of type `type`. The function returns `True` if and only if
    the first argument is an instance of the second argument (or, if the second argument
    is a tuple, an instance of one of the types in the tuple). For example, the value
    of `isinstance([1,2], list)` is `True`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`isinstance`是Python内置的。`isinstance`的第一个参数可以是任何对象，但第二个参数必须是`type`类型的对象或一个`type`类型对象的元组。只有当第一个参数是第二个参数的实例时（或者，如果第二个参数是元组，则是元组中某种类型的实例），函数才会返回`True`。例如，`isinstance([1,2],
    list)`的值为`True`。
- en: Returning to our example, the code
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的示例，代码
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: prints
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that the meaning of `isinstance(p6, Student)` is quite different from
    the meaning of `type(p6) == Student`. The object to which `p6` is bound is of
    type `UG,` not `Student`, but since `UG` is a subclass of `Student`, the object
    to which `p6` is bound is an instance of class `Student` (as well as an instance
    of `MIT_person` and `Person`).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`isinstance(p6, Student)`的含义与`type(p6) == Student`的含义截然不同。`p6`绑定的对象的类型是`UG`，而不是`Student`，但由于`UG`是`Student`的子类，`p6`绑定的对象是`Student`类的一个实例（同时也是`MIT_person`和`Person`的实例）。
- en: Since there are only two kinds of students, we could have implemented `is_student`
    as,
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有两种类型的学生，我们可以将`is_student`实现为，
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: However, if a new type of student were added later, it would be necessary to
    go back and edit the code implementing `is_student`. By introducing the intermediate
    class `Student` and using `isinstance`, we avoid this problem. For example, if
    we were to add
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果后续添加了一种新类型的学生，就有必要回过头来编辑实现`is_student`的代码。通过引入中间类`Student`并使用`isinstance`，我们避免了这个问题。例如，如果我们添加了
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: no change needs to be made to `is_student`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要对`is_student`进行更改。
- en: It is not unusual during the creation and later maintenance of a program to
    go back and add new classes or new attributes to old classes. Good programmers
    design their programs so as to minimize the amount of code that might need to
    be changed when that is done.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的创建和后期维护过程中，回过头来添加新类或旧类的新属性并不少见。好的程序员设计他们的程序，以尽量减少在进行此操作时可能需要更改的代码量。
- en: '**Finger exercise:** What is the value of the following expression?'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**手指练习：**以下表达式的值是多少？'
- en: "`\uFEFFisinstance('ab', str) == isinstance(str, str)`"
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: "`\uFEFFisinstance('ab', str) == isinstance(str, str)`"
- en: 10.2.2 The Substitution Principle
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2 替换原则
- en: When subclassing is used to define a type hierarchy, the subclasses should be
    thought of as extending the behavior of their superclasses. We do this by adding
    new attributes or overriding attributes inherited from a superclass. For example,
    `TransferStudent` extends `Student` by introducing a former school.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用子类化来定义类型层次结构时，子类应该被视为扩展其超类的行为。我们通过添加新属性或重写从超类继承的属性来实现。例如，`TransferStudent`通过引入前学校来扩展`Student`。
- en: Sometimes, the subclass overrides methods from the superclass, but this must
    be done with care. In particular, important behaviors of the supertype must be
    supported by each of its subtypes. If client code works correctly using an instance
    of the supertype, it should also work correctly when an instance of the subtype
    is substituted (hence the phrase substitution principle) for the instance of the
    supertype. For example, it should be possible to write client code using the specification
    of `Student` and have it work correctly on a `TransferStudent`.[^(62)](#c10-fn-0003)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，子类会重写超类的方法，但这必须谨慎进行。特别是，超类的重要行为必须被每个子类支持。如果客户端代码在使用超类实例时正常工作，那么在替换为子类实例时也应正常工作（因此称为替换原则）。例如，应该能够编写使用`Student`规范的客户端代码，并使其在`TransferStudent`上正常工作。[^(62)](#c10-fn-0003)
- en: Conversely, there is no reason to expect that code written to work for `TransferStudent`
    should work for arbitrary types of `Student`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 反之，没有理由期望为`TransferStudent`编写的代码能够适用于任意类型的`Student`。
- en: 10.3 Encapsulation and Information Hiding
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 封装与信息隐藏
- en: As long as we are dealing with students, it would be a shame not to make them
    suffer through taking classes and getting grades.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们在处理学生，没必要让他们经历上课和获得成绩的痛苦那就太可惜了。
- en: '[Figure 10-6](#c10-fig-0006) contains a class that can be used to keep track
    of the grades of a collection of students. Instances of class `Grades` are implemented
    using a list and a dictionary. The list keeps track of the students in the class.
    The dictionary maps a student''s identification number to a list of grades.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-6](#c10-fig-0006)包含一个可以用来跟踪一组学生成绩的类。类`Grades`的实例是使用列表和字典实现的。列表跟踪班级中的学生，而字典将学生的身份证明号码映射到成绩列表。'
- en: '![c10-fig-0006.jpg](../images/c10-fig-0006.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![c10-fig-0006.jpg](../images/c10-fig-0006.jpg)'
- en: '[Figure 10-6](#c10-fig-0006a) Class `Grades`'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-6](#c10-fig-0006a) 类`Grades`'
- en: Notice that `get_grades` returns a copy of the list of grades associated with
    a student, and `get_students` returns a copy of the list of students. The computational
    cost of copying the lists could have been avoided by simply returning the instance
    variables themselves. Doing so, however, is likely to lead to problems. Consider
    the code
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`get_grades`返回与学生关联的成绩列表的副本，而`get_students`返回学生列表的副本。通过简单返回实例变量本身，可以避免复制列表的计算成本。然而，这样做可能会导致问题。考虑代码
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If `get_students` returned `self._students`, the last line of code would have
    the (probably unexpected) side effect of changing the set of students in `course`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`get_students`返回`self._students`，那么代码的最后一行将会有（可能是意外的）副作用，改变`course`中的学生集合。
- en: The instance variable _`is_sorted` is used to keep track of whether the list
    of students has been sorted since the last time a student was added to it. This
    allows the implementation of `get_students` to avoid sorting an already sorted
    list.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量`_is_sorted`用于跟踪自上次添加学生以来学生列表是否已排序。这使得`get_students`的实现可以避免对已排序列表进行排序。
- en: '[Figure 10-7](#c10-fig-0007) contains a function that uses class `Grades` to
    produce a grade report for some students taking a course named `six_hundred`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-7](#c10-fig-0007)包含一个使用类`Grades`为一些修读课程`six_hundred`的学生生成成绩报告的函数。'
- en: '![c10-fig-0007.jpg](../images/c10-fig-0007.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![c10-fig-0007.jpg](../images/c10-fig-0007.jpg)'
- en: '[Figure 10-7](#c10-fig-0007a) Generating a grade report'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-7](#c10-fig-0007a) 生成成绩报告。'
- en: When run, the code in the figure prints
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，图中的代码打印。
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There are two important concepts at the heart of object-oriented programming.
    The first is the idea of **encapsulation**. By this we mean the bundling together
    of data attributes and the methods for operating on them. For example, if we write
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的核心有两个重要概念。第一个是**封装**的概念。我们指的是将数据属性和操作这些属性的方法捆绑在一起。例如，如果我们写。
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: we can use dot notation to access attributes such as Rafael's name and identification
    number.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用点符号访问诸如Rafael的名字和身份证号等属性。
- en: The second important concept is **information hiding**. This is one of the keys
    to modularity. If those parts of the program that use a class (i.e., the clients
    of the class) rely only on the specifications of the methods in the class, a programmer
    implementing the class is free to change the implementation of the class (e.g.,
    to improve efficiency) without worrying that the change will break code that uses
    the class.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个重要概念是**信息隐藏**。这是模块化的关键之一。如果使用类的程序部分（即类的客户端）仅依赖于类中方法的规范，那么实现该类的程序员就可以自由地更改类的实现（例如，提高效率），而不必担心该更改会破坏使用该类的代码。
- en: Some programming languages (Java and C++, for example) provide mechanisms for
    enforcing information hiding. Programmers can make the attributes of a class **private**,
    so that clients of the class can access the data only through the object's methods.
    Python 3 uses a naming convention to make attributes invisible outside the class.
    When the name of an attribute starts with `__` (double underscore) but does not
    end with `__`, that attribute is not visible outside the class. Consider the class
    in [Figure 10-8](#c10-fig-0008).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言（例如Java和C++）提供强制信息隐藏的机制。程序员可以将类的属性设为**私有**，以便类的客户端只能通过对象的方法访问数据。Python
    3使用命名约定使得属性在类外不可见。当属性的名称以`__`（双下划线）开头但不以`__`结尾时，该属性在类外不可见。请参考[图 10-8](#c10-fig-0008)中的类。
- en: '![c10-fig-0008.jpg](../images/c10-fig-0008.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![c10-fig-0008.jpg](../images/c10-fig-0008.jpg)'
- en: '[Figure 10-8](#c10-fig-0008a) Information hiding in classes'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-8](#c10-fig-0008a) 类中的信息隐藏。'
- en: When we run the code
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行代码时。
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: it prints
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印。
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: and then raises the exception
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后引发异常。
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The code
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 代码。
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: prints
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 打印。
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: and then raises the exception
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后引发异常。
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: And the code
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以及代码。
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: prints
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 打印。
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Notice that when a subclass attempts to use a hidden attribute of its superclass,
    an `AttributeError` occurs. This can make using information hiding using `__`
    a bit cumbersome.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当子类尝试使用其超类的隐藏属性时，会发生`AttributeError`。这使得使用`__`进行信息隐藏有些繁琐。
- en: Because it can be cumbersome, many Python programmers do not take advantage
    of the `__` mechanism for hiding attributes—as we don't in this book. So, for
    example, a client of `Person` can write the expression `Rafael._last_name` rather
    than `Rafael.get_last_name()`. We discourage this sort of bad behavior by placing
    a single `_` at the start of the attribute to indicate that we would prefer that
    clients not access it directly.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这可能很繁琐，许多Python程序员并不利用`__`机制来隐藏属性——我们在本书中也是如此。因此，例如，`Person`的客户端可以写表达式`Rafael._last_name`而不是`Rafael.get_last_name()`。我们通过在属性前放置单个`_`来劝阻这种不良行为，以表明我们希望客户端不要直接访问它。
- en: We avoid directly accessing data attributes because it is dangerous for client
    code to rely upon something that is not part of the specification, and is therefore
    subject to change. If the implementation of `Person` were changed, for example
    to extract the last name whenever it is requested rather than store it in an instance
    variable, then client code that directly accessed `_last_name` would no longer
    work.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们避免直接访问数据属性，因为依赖于不属于规范的一部分的内容对客户端代码是危险的，因此可能会发生变化。例如，如果`Person`的实现被更改为在请求时提取姓氏，而不是将其存储在实例变量中，那么直接访问`_last_name`的客户端代码将不再有效。
- en: Not only does Python let programs read instance and class variables from outside
    the class definition, it also lets programs write these variables. So, for example,
    the code `Rafael._birthday = '8/21/50'` is perfectly legal. This would lead to
    a runtime type error, were `Rafael.get_age` invoked later in the computation.
    It is even possible to create instance variables from outside the class definition.
    For example, Python will not complain if the assignment statement
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Python不仅允许程序从类定义之外读取实例和类变量，还允许程序写入这些变量。因此，例如，代码`Rafael._birthday = '8/21/50'`是完全合法的。如果稍后在计算中调用`Rafael.get_age`，将会导致运行时类型错误。甚至可以在类定义之外创建实例变量。例如，如果赋值语句
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: occurs outside the class definition.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义之外发生。
- en: While this relatively weak static semantic checking is a flaw in Python, it
    is not a fatal flaw. A disciplined programmer can simply follow the sensible rule
    of not directly accessing data attributes from outside the class in which they
    are defined, as we do in this book.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种相对弱的静态语义检查是Python的一项缺陷，但这并不是致命的缺陷。一个有纪律的程序员可以简单地遵循一个合理的规则，即不直接从定义它们的类之外访问数据属性，就像我们在本书中所做的那样。
- en: 10.3.1 Generators
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 生成器
- en: A perceived risk of information hiding is that preventing client programs from
    directly accessing critical data structures leads to an unacceptable loss of efficiency.
    In the early days of data abstraction, many were concerned about the cost of introducing
    extraneous function or method calls. Modern compilation technology makes this
    concern moot. A more serious issue is that client programs will be forced to use
    inefficient algorithms.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 信息隐藏的一个被感知的风险是，阻止客户端程序直接访问关键数据结构会导致不可接受的效率损失。在数据抽象的早期，许多人担心引入多余的函数或方法调用的成本。现代编译技术使这个担忧变得无关紧要。一个更严重的问题是，客户端程序将被迫使用低效的算法。
- en: Consider the implementation of `grade_report` in [Figure 10-7](#c10-fig-0007).
    The invocation of `course.get_students` creates and returns a list of size `n`,
    where `n` is the number of students. This is probably not a problem for a grade
    book for a single class, but imagine keeping track of the grades of 1.7 million
    high school students taking the SATs. Creating a new list of that size when the
    list already exists is a significant inefficiency. One solution is to abandon
    the abstraction and allow `grade_report` to directly access the instance variable
    `course.students`, but that would violate information hiding. Fortunately, there
    is a better solution.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在[图10-7](#c10-fig-0007)中实现的`grade_report`。调用`course.get_students`会创建并返回一个大小为`n`的列表，其中`n`是学生的数量。这对单个班级的成绩册来说可能不是问题，但想象一下，要跟踪170万名参加SAT考试的高中生的成绩。当列表已经存在时，创建这样大小的新列表是一种显著的低效。一种解决方案是放弃抽象，允许`grade_report`直接访问实例变量`course.students`，但这将违反信息隐藏。幸运的是，还有更好的解决方案。
- en: 'The code in [Figure 10-9](#c10-fig-0009) replaces the `get_students` function
    in class `Grades` with a function that uses a kind of statement we have not yet
    seen: a `yield` statement.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-9](#c10-fig-0009)中的代码用一种我们尚未见过的语句替换了`Grades`类中的`get_students`函数：`yield`语句。'
- en: Any function definition containing a `yield` statement is treated in a special
    way. The presence of `yield` tells the Python system that the function is a **generator**.
    Generators are typically used with `for` statements, as in
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 任何包含`yield`语句的函数定义都会以特殊的方式处理。`yield`的存在告诉Python系统该函数是一个**生成器**。生成器通常与`for`语句一起使用，如
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: in [Figure 10-7](#c10-fig-0007).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图10-7](#c10-fig-0007)中。
- en: '![c10-fig-0009.jpg](../images/c10-fig-0009.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![c10-fig-0009.jpg](../images/c10-fig-0009.jpg)'
- en: '[Figure 10-9](#c10-fig-0009a) New version of `get_students`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-9](#c10-fig-0009a) `get_students`的新版本'
- en: At the start of the first iteration of a `for` loop that uses a generator, the
    generator is invoked and runs until the first time a `yield` statement is executed,
    at which point it returns the value of the expression in the `yield` statement.
    On the next iteration, the generatorresumes execution immediately following the
    `yield`, with all local variables bound to the objects to which they were bound
    when the `yield` statement was executed, and again runs until a `yield` statement
    is executed. It continues to do this until it runs out of code to execute or executes
    a `return` statement, at which point the loop is exited.[^(63)](#c10-fn-0004)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用生成器的`for`循环的第一次迭代开始时，生成器被调用并运行，直到第一次执行`yield`语句，此时返回`yield`语句中表达式的值。在下一次迭代中，生成器立即在`yield`后恢复执行，所有局部变量绑定到`yield`语句执行时绑定的对象，再次运行直到执行`yield`语句。它会继续这样做，直到没有代码可执行或执行`return`语句，此时循环退出。[^(63)](#c10-fn-0004)
- en: The version of `get_students` in [Figure 10-9](#c10-fig-0009) allows programmers
    to use a `for` loop to iterate over the students in objects of type `Grades` in
    the same way they can use a `for` loop to iterate over elements of built-in types
    such as `list`. For example, the code
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-9](#c10-fig-0009)中的`get_students`版本允许程序员使用`for`循环以与内置类型如`list`相同的方式迭代`Grades`类型对象中的学生。例如，代码'
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: prints
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Thus the loop in [Figure 10-7](#c10-fig-0007) that starts with
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，[图10-7](#c10-fig-0007)中的循环以
- en: '[PRE46]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: does not have to be altered to take advantage of the version of class `Grades`
    that contains the new implementation of `get_students`. (Of course, most code
    that depended upon `get_students` returning a list would no longer work.) The
    same `for` loop can iterate over the values provided by `get_students` regardless
    of whether `get_students` returns a list of values or generates one value at a
    time. Generating one value at a time will be more efficient, because a new list
    containing the students will not be created.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要修改以利用包含新实现的`get_students`的`Grades`类版本。（当然，依赖于`get_students`返回列表的大多数代码将不再有效。）相同的`for`循环可以迭代`get_students`提供的值，无论`get_students`是返回一个值的列表还是一次生成一个值。一次生成一个值将更有效，因为不会创建包含学生的新列表。
- en: '**Finger exercise:** Add to `Grades` a generator that meets the specification'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**指尖练习：** 向`Grades`添加一个满足规范的生成器'
- en: '[PRE47]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 10.4 An Extended Example
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 扩展示例
- en: A collapse in U.S. housing prices helped trigger an international economic meltdown
    in the fall of 2008\. One of the contributing factors was that too many homeowners
    had taken on mortgages that ended up having unexpected consequences.[^(64)](#c10-fn-0005)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 2008年秋季，美国房地产价格崩溃帮助引发了一场国际经济危机。其中一个原因是，太多房主承担了最终带来意想不到后果的抵押贷款。[^(64)](#c10-fn-0005)
- en: In the beginning, mortgages were relatively simple beasts. Buyers borrowed money
    from a bank and made a fixed-size payment each month for the life of the mortgage,
    which typically ranged from 15 to 30 years. At the end of that period, the bank
    had been paid back the initial loan (the principal) plus interest, and the homeowner
    owned the house “free and clear.”
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，抵押贷款相对简单。买家从银行借款，并在抵押贷款的整个生命周期内每月支付固定金额，通常为15到30年。在这段时间结束时，银行收回了初始贷款（本金）加上利息，房主就“完全拥有”了房子。
- en: Towards the end of the twentieth century, mortgages started getting a lot more
    complicated. People could get lower interest rates by paying “points” to the lender
    at the time they took on the mortgage. A point is a cash payment of `1%` of the
    value of the loan. People could take mortgages that were “interest-only” for a
    period of time. That is to say, for some number of months at the start of the
    loan the borrower paid only the accrued interest and none of the principal. Other
    loans involved multiple rates. Typically the initial rate (called a “teaser rate”)
    was low, and then it went up over time. Many of these loans were variable-rate—the
    rate to be paid after the initial period would vary depending upon some index
    intended to reflect the cost to the lender of borrowing on the wholesale credit
    market.[^(65)](#c10-fn-0006)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 到二十世纪末，抵押贷款变得更加复杂。人们可以通过在接受抵押贷款时向贷款人支付“点数”来获得更低的利率。一个点是贷款价值的`1%`的现金支付。人们可以选择在一段时间内仅支付“利息”的抵押贷款。也就是说，在贷款开始的几个月内，借款人仅支付累计的利息，而不支付本金。其他贷款涉及多种利率。通常，最初的利率（称为“诱饵利率”）较低，随后随着时间的推移而上升。这些贷款通常是浮动利率的——在初始期限后要支付的利率将根据某种旨在反映贷款人在批发信贷市场借款成本的指数而变化。
- en: In principle, giving consumers a variety of options is a good thing. However,
    unscrupulous loan purveyors were not always careful to fully explain the possible
    long-term implications of the various options, and some borrowers made choices
    that proved to have dire consequences.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，为消费者提供多种选择是一件好事。然而，不负责任的贷款提供者并不总是小心地充分解释各种选择的潜在长期影响，某些借款人做出了证明后果严重的选择。
- en: 'Let''s build a program that examines the costs of three kinds of mortgages:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个程序，检查三种抵押贷款的成本：
- en: A fixed-rate mortgage with no points
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种没有点数的固定利率抵押贷款
- en: A fixed-rate mortgage with points
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定利率抵押贷款和点数
- en: A mortgage with an initial teaser rate followed by a higher rate for the duration
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种初始诱饵利率，随后在持续期间为更高利率的抵押贷款
- en: The point of this exercise is to provide some experience in the incremental
    development of a set of related classes, not to make you an expert on mortgages.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 本次练习的目的是提供一些有关一组相关类增量开发的经验，而不是让你成为抵押贷款专家。
- en: We will structure our code to include a `Mortgage` class and subclasses corresponding
    to each of the three kinds of mortgages listed above. [Figure 10-10](#c10-fig-0010)
    contains the **abstract class** `Mortgage`. This class contains methods that are
    shared by each of its subclasses, but it is not intended to be instantiated directly.
    That is, no objects of type `Mortgage` will be created.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将结构化我们的代码，以包含一个`Mortgage`类及其对应于上述三种抵押贷款类型的子类。[图10-10](#c10-fig-0010)包含**抽象类**`Mortgage`。该类包含每个子类共享的方法，但不打算直接实例化。也就是说，不会创建类型为`Mortgage`的对象。
- en: The function `find_payment` at the top of the figure computes the size of the
    fixed monthly payment needed to pay off the loan, including interest, by the end
    of its term. It does this using a well-known closed-form expression. This expression
    is not hard to derive, but it is a lot easier to just look it up and more likely
    to be correct than one derived on the spot.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图形顶部的`find_payment`函数计算需要在贷款到期时偿还贷款所需的固定月供，包括利息。它使用一个众所周知的封闭形式表达式来实现这一点。这个表达式并不难推导，但查找它要容易得多，也更可能是正确的，而不是现场推导出来的。
- en: 'Keep in mind, however, that not everything you discover on the web (or even
    in textbooks) is correct. When your code incorporates a formula that you have
    looked up, make sure that:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，并非你在网络上（甚至教科书中）发现的所有信息都是正确的。当你的代码包含你查找的公式时，请确保：
- en: You have taken the formula from a reputable source. We looked at multiple reputable
    sources, all of which contained equivalent formulas.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已从可信来源获取公式。我们查看了多个可信来源，它们都包含等效的公式。
- en: You fully understand the meaning of all the variables in the formula.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你完全理解公式中所有变量的含义。
- en: You test your implementation against examples taken from reputable sources.
    After implementing this function, we tested it by comparing our results to the
    results supplied by a calculator available on the web.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将你的实现与来自可信来源的示例进行测试。在实现此功能后，我们通过将我们的结果与网络上可用计算器提供的结果进行比较来进行测试。
- en: '![c10-fig-0010.jpg](../images/c10-fig-0010.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![c10-fig-0010.jpg](../images/c10-fig-0010.jpg)'
- en: '[Figure 10-10](#c10-fig-0010a) `Mortgage` base class'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-10](#c10-fig-0010a) `Mortgage`基类'
- en: Looking at `__init__`, we see that all `Mortgage` instances will have instance
    variables corresponding to the initial loan amount, the monthly interest rate,
    the duration of the loan in months, a list of payments that have been made at
    the start of each month (the list starts with `0`, since no payments have been
    made at the start of the first month), a list with the balance of the loan that
    is outstanding at the start of each month, the amount of money to be paid each
    month (initialized using the value returned by the function `find_payment)`, and
    a description of the mortgage (which initially has a value of `None`). The `__init__`
    operation of each subclass of `Mortgage` is expected to start by calling `Mortgage.__init__`,
    and then to initialize `self._legend` to an appropriate description of that subclass.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 观察 `__init__`，我们看到所有 `Mortgage` 实例将具有与初始贷款金额、月利率、贷款期限（以月为单位）、每月初已支付的付款列表（该列表以
    `0` 开头，因为在第一个月初尚未支付任何款项）、每月初未偿贷款余额的列表、每月需支付的金额（使用函数 `find_payment` 返回的值初始化）以及抵押贷款描述（初始值为
    `None`）相对应的实例变量。每个 `Mortgage` 子类的 `__init__` 操作预计会首先调用 `Mortgage.__init__`，然后将
    `self._legend` 初始化为该子类的适当描述。
- en: The method `make_payment` is used to record mortgage payments. Part of each
    payment covers the amount of interest due on the outstanding loan balance, and
    the remainder of the payment is used to reduce the loan balance. That is why `make_payment`
    updates both `self.paid` and `self.outstanding`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `make_payment` 用于记录抵押贷款支付。每次支付的一部分覆盖了未偿贷款余额的利息，剩余部分用于减少贷款余额。这就是 `make_payment`
    更新 `self.paid` 和 `self.outstanding` 的原因。
- en: The method `get_total_paid` uses the built-in Python function `sum`, which returns
    the sum of a sequence of numbers. If the sequence contains a non-number, an exception
    is raised.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `get_total_paid` 使用内置的 Python 函数 `sum`，该函数返回一系列数字的总和。如果序列中包含非数字，则会引发异常。
- en: '[Figure 10-11](#c10-fig-0011) contains classes implementing three types of
    mortgages. The classes `Fixed` and `Fixed_with_pts` override `__init__` and inherit
    the other three methods from `Mortgage`. The class `Two_rate` treats a mortgage
    as the concatenation of two loans, each at a different interest rate. (Since `self.paid`
    is initialized to a list with one element, it contains one more element than the
    number of payments that have been made. That''s why the method `make_payment`
    compares `len(self.paid)` to `self.teaser_months + 1`.)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-11](#c10-fig-0011) 包含实现三种类型抵押贷款的类。类 `Fixed` 和 `Fixed_with_pts` 重写 `__init__`
    并从 `Mortgage` 继承其他三种方法。类 `Two_rate` 将抵押贷款视为两个不同利率贷款的串联。（由于 `self.paid` 初始化为包含一个元素的列表，因此它包含的元素比已支付的款项多一个。这就是方法
    `make_payment` 将 `len(self.paid)` 与 `self.teaser_months + 1` 进行比较的原因。）'
- en: '[Figure 10-11](#c10-fig-0011) also contains a function that computes and prints
    the total cost of each kind of mortgage for a sample set of parameters. It begins
    by creating one mortgage of each kind. It then makes a monthly payment on each
    for a given number of years. Finally, it prints the total amount of the payments
    made for each loan.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-11](#c10-fig-0011) 还包含一个计算并打印每种抵押贷款总成本的函数，基于一组示例参数。它首先创建每种类型的一份抵押贷款。然后，对每一份抵押贷款在给定的年份内进行每月支付。最后，打印每笔贷款的支付总额。'
- en: 'We are now, finally, ready to compare different mortgages:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在终于准备好比较不同的抵押贷款了：
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Notice that we used keyword rather than positional arguments in the invocation
    of `compare_mortgages`. We did this because `compare_mortgages` has a large number
    of formal parameters of the same type, and using keyword arguments makes it easier
    to ensure that we are supplying the intended actual values to each of the formals.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在调用 `compare_mortgages` 时，我们使用了关键字参数而非位置参数。这样做是因为 `compare_mortgages` 有大量相同类型的形式参数，使用关键字参数可以更容易地确保我们为每个形式参数提供了预期的实际值。
- en: When the code is run, it prints
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码运行时，它会打印
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '![c10-fig-0011.jpg](../images/c10-fig-0011.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![c10-fig-0011.jpg](../images/c10-fig-0011.jpg)'
- en: '[Figure 10-11](#c10-fig-0011a) Mortgage subclasses'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-11](#c10-fig-0011a) 抵押贷款子类'
- en: At first glance, the results look pretty conclusive. The variable-rate loan
    is a bad idea (for the borrower, not the lender) and the fixed-rate loan with
    points costs the least. It's important to note, however, that total cost is not
    the only metric by which mortgages should be judged. For example, a borrower who
    expects to have a higher income in the future may be willing to pay more in the
    later years to lessen the burden of payments in the beginning.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 初看结果似乎相当明确。可变利率贷款对借款人（而非贷款人）来说是个坏主意，而带点的固定利率贷款则是成本最低的。然而，需要注意的是，总成本并不是评估抵押贷款的唯一标准。例如，预计未来收入会更高的借款人可能愿意在后期支付更多，以减轻初期还款的负担。
- en: This suggests that rather than looking at a single number, we should look at
    payments over time. This in turn suggests that our program should be producing
    plots designed to show how the mortgage behaves over time. We will do that in
    Section 13.2.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，与其看一个单一的数字，不如观察随时间变化的付款情况。这反过来又表明，我们的程序应该生成旨在展示抵押贷款随时间变化的图表。我们将在第13.2节中进行讨论。
- en: 10.5 Terms Introduced in Chapter
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 章节中引入的术语
- en: object-oriented programming
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: abstract data type
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象数据类型
- en: interface
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: abstraction barrier
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象屏障
- en: decomposition
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分解
- en: abstraction
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象
- en: class
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: class definition
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类定义
- en: method attribute
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法属性
- en: class attributes
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类属性
- en: class instance
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类实例
- en: attribute reference
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性引用
- en: __ methods
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: __ 方法
- en: magic (dunder) methods
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 魔法（双下划线）方法
- en: data attribute
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据属性
- en: class variable
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类变量
- en: instance variable
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例变量
- en: class definition
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类定义
- en: representation invariant
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示不变式
- en: inheritance
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: subclass
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类
- en: superclass
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超类
- en: overriding
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法重写
- en: isinstance
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: isinstance
- en: substitution principle
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替代原则
- en: encapsulation
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: information hiding
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息隐藏
- en: private
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有
- en: generator
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器
- en: abstract class
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类
