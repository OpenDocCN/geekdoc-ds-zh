- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CLASSES AND OBJECT-ORIENTED PROGRAMMING
  prefs: []
  type: TYPE_NORMAL
- en: 'We now turn our attention to our last major topic related to programming in
    Python: using classes to organize programs around data abstractions.'
  prefs: []
  type: TYPE_NORMAL
- en: Classes can be used in many different ways. In this book we emphasize using
    them in the context of **object-oriented programming**. The key to object-oriented
    programming is thinking about objects as collections of both data and the methods
    that operate on that data.
  prefs: []
  type: TYPE_NORMAL
- en: The ideas underlying object-oriented programming are about 50 years old, and
    have been widely accepted and practiced over the last 30 years or so. In the mid-1970s,
    people began to write articles explaining the benefits of this approach to programming.
    About the same time, the programming languages SmallTalk (at Xerox PARC) and CLU
    (at MIT) provided linguistic support for the ideas. But it wasn't until the arrival
    of C++ and Java that object-oriented programming really took off in practice.
  prefs: []
  type: TYPE_NORMAL
- en: We have been implicitly relying on object-oriented programming throughout most
    of this book. Back in Section 2.2.1 we said “Objects are the core things that
    Python programs manipulate. Every object has a **type** that defines the kinds
    of things that programs can do with that object.” Since Chapter 2, we have relied
    upon built-in types such as `float` and `str` and the methods associated with
    those types. But just as the designers of a programming language can build in
    only a small fraction of the useful functions, they can build in only a small
    fraction of the useful types. We have already looked at a mechanism that allows
    programmers to define new functions; we now look at a mechanism that allows programmers
    to define new types.
  prefs: []
  type: TYPE_NORMAL
- en: 10.1 Abstract Data Types and Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The notion of an abstract data type is quite simple. An **abstract data type**
    is a set of objects and the operations on those objects. These are bound together
    so that programmers can pass an object from one part of a program to another,
    and in doing so provide access not only to the data attributes of the object but
    also to operations that make it easy to manipulate that data.
  prefs: []
  type: TYPE_NORMAL
- en: The specifications of those operations define an **interface** between the abstract
    data type and the rest of the program. The interface defines the behavior of the
    operations—what they do, but not how they do it. The interface thus provides an
    **abstraction barrier** that isolates the rest of the program from the data structures,
    algorithms, and code involved in providing a realization of the type abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Programming is about managing complexity in a way that facilitates change.
    Two powerful mechanisms are available for accomplishing this: decomposition and
    abstraction. **Decomposition** creates structure in a program, and **abstraction**
    suppresses detail. The key is to suppress the appropriate details. This is where
    data abstraction hits the mark. We can create domain-specific types that provide
    a convenient abstraction. Ideally, these types capture concepts that will be relevant
    over the lifetime of a program. If we start the programming process by devising
    types that will be relevant months and even decades later, we have a great leg
    up in maintaining that software.'
  prefs: []
  type: TYPE_NORMAL
- en: We have been using abstract data types (without calling them that) throughout
    this book. We have written programs using integers, lists, floats, strings, and
    dictionaries without giving any thought to how these types might be implemented.
    To paraphrase Molière's *Bourgeois Gentilhomme*, *“Par ma foi, il y a plus de
    cent pages que nous avons utilisé ADTs, sans que nous le sachions.”*[^(60)](#c10-fn-0001)
  prefs: []
  type: TYPE_NORMAL
- en: In Python, we implement data abstractions using **classes**. Each class definition
    begins with the reserved word `class` followed by the name of the class and some
    information about how it relates to other classes
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following tiny (and totally useless) **class definition**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first line indicates that `Toy` is a subclass of `object`. For now, ignore
    what it means to be a subclass. We will get to that shortly.
  prefs: []
  type: TYPE_NORMAL
- en: A class definition creates an object of type `type` and associates with that
    class object a set of objects called **attributes**. In this example, the three
    attributes associated with the class are `__init__`, `add`, and `size.` Each is
    of type `function`. Consequently, the code,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we will see, Python has a number of special function names that start and
    end with two underscores. These are often referred to as **magic methods**.[^(61)](#c10-fn-0002)
    The first of these we will look at is `__init__.` Whenever a class is instantiated,
    a call is made to the `__init__` function defined in that class. When the line
    of code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: is executed, the interpreter will create a new **instance** of type `Toy`, and
    then call `Toy.__init__` with the newly created object as the actual parameter
    that is bound to the formal parameter `self`. When invoked, `Toy.__init__` creates
    the list object `_elems,` which becomes part of the newly created instance of
    type `Toy`. (The list is created using the by now familiar notation `[]`, which
    is simply an abbreviation for `list()`.) The list `_elems` is called a **data
    attribute** of the instance of `Toy`. The code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `t1.add` is of type `method`, whereas `Toy.add` is of type `function`.
    Because `t1.add` is a method, we can invoke it (and `t1.size`) using dot notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'A class should not be confused with instances of that class, just as an object
    of type `list` should not be confused with the `list` type. Attributes can be
    associated either with a class itself or with instances of a class:'
  prefs: []
  type: TYPE_NORMAL
- en: Class attributes are defined in a class definition; for example `Toy.size` is
    an attribute of the class `Toy.` When the class is instantiated, e.g., by the
    statement `t = Toy()`, instance attributes, e.g., `t.size`, are created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While `t.size` is initially bound to the `size` function defined in the class
    `Toy`, that binding can be changed during the course of a computation. For example,
    you could (but definitely should not!) change the binding by executing `t.size = 3`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: "When data attributes are associated with a class, we call them **class variables**.\
    \ When they are associated with an instance, we call them **instance variables**.\
    \ For example, `\uFEFF_elems` is an instance variable because for each instance\
    \ of class `Toy`, `\uFEFF_elems` is bound to a different list. So far, we haven't\
    \ seen a class variable. We will use one in [Figure 10-4](#c10-fig-0004)."
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, consider the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Since each instance of `Toy` is a different object, each instance of type `Toy`
    will have a different `_elems` attribute. Therefore, the code prints `3.`
  prefs: []
  type: TYPE_NORMAL
- en: At first blush, something appears to be inconsistent in this code. It looks
    as if each method is being called with one argument too few. For example, `add`
    has two formal parameters, but we appear to be calling it with only one actual
    parameter. This is an artifact of using dot notation to invoke a method associated
    with an instance of a class. The object associated with the expression preceding
    the dot is implicitly passed as the first parameter to the method. Throughout
    this book, we follow the convention of using `self` as the name of the formal
    parameter to which this actual parameter is bound. Python programmers observe
    this convention almost universally, and we strongly suggest that you use it as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Another common convention is to start the name of data attributes with an underscore.
    As we discuss in detail in Section 10.3, we use the leading `_` to indicate that
    the attribute is private to the class, i.e., should not be directly accessed outside
    the class.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at a more interesting example. [Figure 10-1](#c10-fig-0001)
    contains a **class definition** that provides a straightforward implementation
    of a set-of-integers abstraction called `Int_set`. (Given that Python has a built-in
    type `set`, this implementation is both unnecessary and unnecessarily complicated.
    However, it is pedagogically useful.)
  prefs: []
  type: TYPE_NORMAL
- en: '![c10-fig-0001.jpg](../images/c10-fig-0001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 10-1](#c10-fig-0001a) Class `Int_set`'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the docstring (the comment enclosed in `"""`) at the top of the
    class definition describes the abstraction provided by the class, not information
    about how the class is implemented. In contrast, the comments below the docstring
    contain information about the implementation. That information is aimed at programmers
    who might want to modify the implementation or build subclasses (see Section 10.2)
    of the class, not at programmers who might want to use the abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, methods associated with an instance of a class can be invoked
    using dot notation. For example, the code,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: creates a new instance of `Int_set`, inserts the integer 3 into that `Int_set`,
    and then prints `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data abstraction achieves representation-independence. Think of the implementation
    of an abstract type as having several components:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementations of the methods of the type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data structures that together encode values of the type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conventions about how the implementations of the methods are to use the data
    structures; a key convention is captured by the representation invariant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **representation invariant** defines which values of the data attributes
    correspond to valid representations of class instances. The representation invariant
    for `Int_set` is that `vals` contains no duplicates. The implementation of `__init__`
    is responsible for establishing the invariant (which holds for the empty list),
    and the other methods are responsible for maintaining that invariant. That is
    why `insert` appends `e` only if it is not already in `self.vals`.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of `remove` exploits the assumption that the representation
    invariant is satisfied when `remove` is entered. It calls `list.remove` only once,
    since the representation invariant guarantees that there is at most one occurrence
    of `e` in `self.vals`.
  prefs: []
  type: TYPE_NORMAL
- en: The last method defined in the class, `__str__`, is another one of those special
    `__` methods. The `__str__` method of a class is invoked when a program converts
    an instance of that class to a string by calling `str`. Therefore, when the `print`
    command is used, the `__str__` function associated with the object to be printed
    is invoked. For example, the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: will print
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: (If `no __str__` method were defined, executing `print(s)` would cause something
    like `<__main__.Int_set object at 0x1663510>` to be printed.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise:** Add a method satisfying the specification below to the
    `Int_set` class.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 10.1.1 Magic Methods and Hashable Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the design goals for Python was to allow programmers to use classes to
    define new types that are as easy to use as the built-in types of Python. Using
    magic methods to provide class-specific definitions of built-in functions such
    as `str` and `len` plays an important role in achieving this goal.
  prefs: []
  type: TYPE_NORMAL
- en: Magic methods can also be used to provide class-specific definitions for infix
    operators such as == and +. The names of the methods available for infix operators
    are
  prefs: []
  type: TYPE_NORMAL
- en: '| `+: __add__` | `*: __mul__` | `/: __truediv__` |'
  prefs: []
  type: TYPE_TB
- en: '| `-: __sub__` | `//: __floordiv__` | `%: __mod__` |'
  prefs: []
  type: TYPE_TB
- en: '| `**: __pow__` | `&#124;: __or__` | `<: __lt__` |'
  prefs: []
  type: TYPE_TB
- en: '| `<<: __lshift__` | `∧: __xor__` | `>: __gt__` |'
  prefs: []
  type: TYPE_TB
- en: '| `>>: __rshsift__` | `==: __eq__` | `<=: __le__` |'
  prefs: []
  type: TYPE_TB
- en: '| `&: __and__` | `!=: __ne__` | `>=: __ge__` |'
  prefs: []
  type: TYPE_TB
- en: You can associate any implementation you want with these operators. If you wanted,
    you could implement `+` as subtraction, `<` as exponentiation, etc. We recommend,
    however, that you resist the opportunity to be imaginative, and stick to implementations
    consistent with the conventional meanings of these operators.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to our toy example, consider the code in [Figure 10-2](#c10-fig-0002).
  prefs: []
  type: TYPE_NORMAL
- en: '![c10-fig-0002.jpg](../images/c10-fig-0002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 10-2](#c10-fig-0002a) Using magic methods'
  prefs: []
  type: TYPE_NORMAL
- en: When the code in [Figure 10-2](#c10-fig-0002) is run it prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: "We can use instances of `Toy` as dictionary keys because we defined a `__hash__`\
    \ function for the class. Had we defined an `__eq__` function and not defined\
    \ a `__hash__` function, the code would have generated the error message \uFEFF\
    `unhashable type: ‘Toy'` when we attempted to create a dictionary using `t1` and\
    \ `t2` as keys. When a user-defined `__hash__` is provided, it should ensure that\
    \ the hash value of an object is constant throughout the lifetime of that object."
  prefs: []
  type: TYPE_NORMAL
- en: All instances of user-defined classes that do not explicitly define `__eq__`
    use object identity for `==` and are hashable. If no `__hash__` method is provided,
    the hash value of the object is derived from the object's identity (see Section
    5.3).
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise**: Replace the `union` method you added to `Int_set` by a
    method that allows clients of `Int_set` to use the ­`+` operator to denote set
    union.'
  prefs: []
  type: TYPE_NORMAL
- en: 10.1.2 Designing Programs Using Abstract Data Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Abstract data types are a big deal. They lead to a different way of thinking
    about organizing large programs. When we think about the world, we rely on abstractions.
    In the world of finance, people talk about stocks and bonds. In the world of biology,
    people talk about proteins and residues. When trying to understand concepts such
    as these, we mentally gather together some of the relevant data and features of
    these kinds of objects into one intellectual package. For example, we think of
    bonds as having an interest rate, a maturity date, and a price as data attributes.
    We also think of bonds as having operations such as “set price” and “calculate
    yield to maturity.” Abstract data types allow us to incorporate this kind of organization
    into the design of programs.
  prefs: []
  type: TYPE_NORMAL
- en: Data abstraction encourages program designers to focus on the centrality of
    data objects rather than functions. Thinking about a program more as a collection
    of types than as a collection of functions leads to a profoundly different organizing
    principle. Among other things, it encourages us to think about programming as
    a process of combining relatively large chunks, since data abstractions typically
    encompass more functionality than do individual functions. This, in turn, leads
    us to think of the essence of programming as a process not of writing individual
    lines of code, but of composing abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: The availability of reusable abstractions not only reduces development time,
    but usually leads to more reliable programs, because mature software is usually
    more reliable than new software. For many years, the only program libraries in
    common use were statistical or scientific. Today, however, there is a great range
    of available program libraries (especially for Python), often based on a rich
    set of data abstractions, as we shall see later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 10.1.3 Using Classes to Keep Track of Students and Faculty
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an example use of classes, imagine that you are designing a program to help
    keep track of all the students and faculty at a university. It is certainly possible
    to write such a program without using data abstraction. Each student would have
    a family name, a given name, a home address, a year, some grades, etc. This data
    could all be kept in a combination of lists and dictionaries. Keeping track of
    faculty and staff would require some similar data structures and some different
    data structures, e.g., data structures to keep track of things like salary history.
  prefs: []
  type: TYPE_NORMAL
- en: Before rushing in to design a bunch of data structures, let's think about some
    abstractions that might prove useful. Is there an abstraction that covers the
    common attributes of students, professors, and staff? Some would argue that they
    are all human. [Figure 10-3](#c10-fig-0003) contains a class that incorporates
    two common attributes (name and birthday) of humans. It uses the standard Python
    library module `datetime`, which provides many convenient methods for creating
    and manipulating dates.
  prefs: []
  type: TYPE_NORMAL
- en: '![c10-fig-0003.jpg](../images/c10-fig-0003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 10-3](#c10-fig-0003a) Class `Person`'
  prefs: []
  type: TYPE_NORMAL
- en: The following code uses `Person` and `datetime`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice that whenever `Person` is instantiated, an argument is supplied to the
    `__init__` function. In general, when instantiating a class we need to look at
    the specification of the `__init__` function for that class to know what arguments
    to supply and what properties those arguments should have.
  prefs: []
  type: TYPE_NORMAL
- en: "Executing the above code creates three instances of class `Person`. We can\
    \ access information about these instances using the methods associated with them.\
    \ For example, `him.\uFEFFget_last_name()` returns `'Obama'`. The expression `him._last_name`\
    \ will also return `'Obama'`; however, for reasons discussed later in this chapter,\
    \ writing expressions that directly access instance variables is considered poor\
    \ form, and should be avoided. Similarly, there is no appropriate way for a user\
    \ of the `Person` abstraction to extract a person's birthday, despite the fact\
    \ that the implementation contains an attribute with that value. (Of course, it\
    \ would be easy to add a `get_birthday` method to the class.) There is, however,\
    \ a way to extract information that depends upon the person's birthday, as illustrated\
    \ by the last `print` statement in the above code."
  prefs: []
  type: TYPE_NORMAL
- en: Class `Person` provides a `Person`-specific definition for yet another specially
    named method, `__lt__.` This method overloads the `<` operator. The method `Person__lt__`
    gets called whenever the first argument to the `<` operator is of type `Person`.
    The `__lt__` method in class `Person` is implemented using the binary `<` operator
    of type `str`. The expression `self._name < other._name` is shorthand for `self._name.__lt__(other._name)`.
    Since `self._name` is of type `str`, this `__lt__` method is the one associated
    with type `str`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to providing the syntactic convenience of writing infix expressions
    that use `<`, this overloading provides automatic access to any polymorphic method
    defined using `__lt__`. The built-in method `sort` is one such method. So, for
    example, if `p_list` is a list composed of elements of type `Person`, the call
    `p_list.sort()` will sort that list using the `__lt__` method defined in class
    `Person`. Therefore, the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: will print
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 10.2 Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many types have properties in common with other types. For example, types `list`
    and `str` each have `len` functions that mean the same thing. **Inheritance**
    provides a convenient mechanism for building groups of related abstractions. It
    allows programmers to create a type hierarchy in which each type inherits attributes
    from the types above it in the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: The class `object` is at the top of the hierarchy. This makes sense, since in
    Python everything that exists at runtime is an object. Because `Person` inherits
    all of the properties of objects, programs can bind a variable to a `Person`,
    append a `Person` to a list, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class `MIT_person` in [Figure 10-4](#c10-fig-0004) inherits attributes
    from its parent class, `Person`, including all of the attributes that `Person`
    inherited from its parent class, `object`. In the jargon of object-oriented programming,
    `MIT_person` is a **subclass** of `Person`, and therefore **inherits** the attributes
    of its **superclass**. In addition to what it inherits, the subclass can:'
  prefs: []
  type: TYPE_NORMAL
- en: Add new attributes. For example, the subclass `MIT_person` has added the class
    variable _`next_id_num`, the instance variable _`id_num`, and the method `get_id_num`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Override**, i.e., replace, attributes of the superclass. For example, `MIT_person`
    has overridden `__init__` and `__lt__`. When a method has been overridden, the
    version of the method that is executed is based on the object used to invoke the
    method. If the type of the object is the subclass, the version defined in the
    subclass will be used. If the type of the object is the superclass, the version
    in the superclass will be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: "The method `MIT_person.__init__` first uses `\uFEFFsuper().__init__(name)`\
    \ to invoke the `__init__` function of its super class (`Person)`. This initializes\
    \ the `inherited` instance variable `self._name`. It then initializes `self._id_num`,\
    \ which is an instance variable that instances of `MIT_person` have but instances\
    \ of `Person` do not."
  prefs: []
  type: TYPE_NORMAL
- en: The instance variable `self._id_num` is initialized using a **class** **variable**,
    _`next_id_num`, that belongs to the class `MIT_person`, rather than to instances
    of the class. When an instance of `MIT_person` is created, a new instance of `next_id_num`
    is not created. This allows `__init__` to ensure that each instance of `MIT_person`
    has a unique _`id_num`.
  prefs: []
  type: TYPE_NORMAL
- en: '![c10-fig-0004.jpg](../images/c10-fig-0004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 10-4](#c10-fig-0004a) Class `MIT_person`'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates a new `MIT_person`. The second line is more complicated.
    When it attempts to evaluate the expression `str(p1)`, the runtime system first
    checks to see if there is an `__str__` method associated with class `MIT_person`.
    Since there is not, it next checks to see if there is an `__str__` method associated
    with the immediate superclass, `Person`, of `MIT_person`. There is, so it uses
    that. When the runtime system attempts to evaluate the expression `p1.get_id_num()`,
    it first checks to see if there is a `get_id_num` method associated with class
    `MIT_person`. There is, so it invokes that method and prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: (Recall that in a string, the character “`\`” is an escape character used to
    indicate that the next character should be treated in a special way. In the string
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: the “`\`” indicates that the apostrophe is part of the string, not a delimiter
    terminating the string.)
  prefs: []
  type: TYPE_NORMAL
- en: Now consider the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We have created four virtual people, three of whom are named Billy Bob Beaver.
    Two of the Billy Bobs are of type `MIT_person`, and one merely a `Person`. If
    we execute the lines of code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: the interpreter will print
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Since `p1`, `p2`, and `p3` are all of type `MIT_person`, the interpreter will
    use the `__lt__` method defined in class `MIT_person` when evaluating the first
    two comparisons, so the ordering will be based on identification numbers. In the
    third comparison, the `<` operator is applied to operands of different types.
    Since the first argument of the expression is used to determine which `__lt__`
    method to invoke, `p4 < p1` is shorthand for `p4.__lt__(p1)`. Therefore, the interpreter
    uses the `__lt__ method` associated with the type of `p4`, `Person`, and the “people”
    will be ordered by name.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we try
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The runtime system will invoke the `__lt__` operator associated with the type
    of `p1`, i.e., the one defined in class `MIT_person`. This will lead to the exception
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: because the object to which `p4` is bound does not have an attribute _`id_num`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise**: Implement a subclass of `Person` that meets the specification'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 10.2.1 Multiple Levels of Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Figure 10-5](#c10-fig-0005) adds another couple of levels of inheritance to
    the class hierarchy.'
  prefs: []
  type: TYPE_NORMAL
- en: '![c10-fig-0005.jpg](../images/c10-fig-0005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 10-5](#c10-fig-0005a) Two kinds of students'
  prefs: []
  type: TYPE_NORMAL
- en: Adding `UG` seems logical, because we want to associate a year of graduation
    (or perhaps anticipated graduation) with each undergraduate. But what is going
    on with the classes `Student` and `Grad`? By using the Python reserved word `**pass**`
    as the body, we indicate that the class has no attributes other than those inherited
    from its superclass. Why would anyone ever want to create a class with no new
    attributes?
  prefs: []
  type: TYPE_NORMAL
- en: By introducing the class `Grad`, we gain the ability to create two kinds of
    students and use their types to distinguish one kind of object from another. For
    example, the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: will print
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The utility of the intermediate type `Student` is subtler. Consider going back
    to `class` `MIT_person` and adding the method
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The function `isinstance` is built into Python. The first argument of `isinstance`
    can be any object, but the second argument must be an object of type `type` or
    a tuple of objects of type `type`. The function returns `True` if and only if
    the first argument is an instance of the second argument (or, if the second argument
    is a tuple, an instance of one of the types in the tuple). For example, the value
    of `isinstance([1,2], list)` is `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to our example, the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the meaning of `isinstance(p6, Student)` is quite different from
    the meaning of `type(p6) == Student`. The object to which `p6` is bound is of
    type `UG,` not `Student`, but since `UG` is a subclass of `Student`, the object
    to which `p6` is bound is an instance of class `Student` (as well as an instance
    of `MIT_person` and `Person`).
  prefs: []
  type: TYPE_NORMAL
- en: Since there are only two kinds of students, we could have implemented `is_student`
    as,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: However, if a new type of student were added later, it would be necessary to
    go back and edit the code implementing `is_student`. By introducing the intermediate
    class `Student` and using `isinstance`, we avoid this problem. For example, if
    we were to add
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: no change needs to be made to `is_student`.
  prefs: []
  type: TYPE_NORMAL
- en: It is not unusual during the creation and later maintenance of a program to
    go back and add new classes or new attributes to old classes. Good programmers
    design their programs so as to minimize the amount of code that might need to
    be changed when that is done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise:** What is the value of the following expression?'
  prefs: []
  type: TYPE_NORMAL
- en: "`\uFEFFisinstance('ab', str) == isinstance(str, str)`"
  prefs: []
  type: TYPE_NORMAL
- en: 10.2.2 The Substitution Principle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When subclassing is used to define a type hierarchy, the subclasses should be
    thought of as extending the behavior of their superclasses. We do this by adding
    new attributes or overriding attributes inherited from a superclass. For example,
    `TransferStudent` extends `Student` by introducing a former school.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the subclass overrides methods from the superclass, but this must
    be done with care. In particular, important behaviors of the supertype must be
    supported by each of its subtypes. If client code works correctly using an instance
    of the supertype, it should also work correctly when an instance of the subtype
    is substituted (hence the phrase substitution principle) for the instance of the
    supertype. For example, it should be possible to write client code using the specification
    of `Student` and have it work correctly on a `TransferStudent`.[^(62)](#c10-fn-0003)
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, there is no reason to expect that code written to work for `TransferStudent`
    should work for arbitrary types of `Student`.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3 Encapsulation and Information Hiding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As long as we are dealing with students, it would be a shame not to make them
    suffer through taking classes and getting grades.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-6](#c10-fig-0006) contains a class that can be used to keep track
    of the grades of a collection of students. Instances of class `Grades` are implemented
    using a list and a dictionary. The list keeps track of the students in the class.
    The dictionary maps a student''s identification number to a list of grades.'
  prefs: []
  type: TYPE_NORMAL
- en: '![c10-fig-0006.jpg](../images/c10-fig-0006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 10-6](#c10-fig-0006a) Class `Grades`'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that `get_grades` returns a copy of the list of grades associated with
    a student, and `get_students` returns a copy of the list of students. The computational
    cost of copying the lists could have been avoided by simply returning the instance
    variables themselves. Doing so, however, is likely to lead to problems. Consider
    the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If `get_students` returned `self._students`, the last line of code would have
    the (probably unexpected) side effect of changing the set of students in `course`.
  prefs: []
  type: TYPE_NORMAL
- en: The instance variable _`is_sorted` is used to keep track of whether the list
    of students has been sorted since the last time a student was added to it. This
    allows the implementation of `get_students` to avoid sorting an already sorted
    list.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-7](#c10-fig-0007) contains a function that uses class `Grades` to
    produce a grade report for some students taking a course named `six_hundred`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![c10-fig-0007.jpg](../images/c10-fig-0007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 10-7](#c10-fig-0007a) Generating a grade report'
  prefs: []
  type: TYPE_NORMAL
- en: When run, the code in the figure prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There are two important concepts at the heart of object-oriented programming.
    The first is the idea of **encapsulation**. By this we mean the bundling together
    of data attributes and the methods for operating on them. For example, if we write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: we can use dot notation to access attributes such as Rafael's name and identification
    number.
  prefs: []
  type: TYPE_NORMAL
- en: The second important concept is **information hiding**. This is one of the keys
    to modularity. If those parts of the program that use a class (i.e., the clients
    of the class) rely only on the specifications of the methods in the class, a programmer
    implementing the class is free to change the implementation of the class (e.g.,
    to improve efficiency) without worrying that the change will break code that uses
    the class.
  prefs: []
  type: TYPE_NORMAL
- en: Some programming languages (Java and C++, for example) provide mechanisms for
    enforcing information hiding. Programmers can make the attributes of a class **private**,
    so that clients of the class can access the data only through the object's methods.
    Python 3 uses a naming convention to make attributes invisible outside the class.
    When the name of an attribute starts with `__` (double underscore) but does not
    end with `__`, that attribute is not visible outside the class. Consider the class
    in [Figure 10-8](#c10-fig-0008).
  prefs: []
  type: TYPE_NORMAL
- en: '![c10-fig-0008.jpg](../images/c10-fig-0008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 10-8](#c10-fig-0008a) Information hiding in classes'
  prefs: []
  type: TYPE_NORMAL
- en: When we run the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: it prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: and then raises the exception
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: and then raises the exception
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: And the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when a subclass attempts to use a hidden attribute of its superclass,
    an `AttributeError` occurs. This can make using information hiding using `__`
    a bit cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: Because it can be cumbersome, many Python programmers do not take advantage
    of the `__` mechanism for hiding attributes—as we don't in this book. So, for
    example, a client of `Person` can write the expression `Rafael._last_name` rather
    than `Rafael.get_last_name()`. We discourage this sort of bad behavior by placing
    a single `_` at the start of the attribute to indicate that we would prefer that
    clients not access it directly.
  prefs: []
  type: TYPE_NORMAL
- en: We avoid directly accessing data attributes because it is dangerous for client
    code to rely upon something that is not part of the specification, and is therefore
    subject to change. If the implementation of `Person` were changed, for example
    to extract the last name whenever it is requested rather than store it in an instance
    variable, then client code that directly accessed `_last_name` would no longer
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Not only does Python let programs read instance and class variables from outside
    the class definition, it also lets programs write these variables. So, for example,
    the code `Rafael._birthday = '8/21/50'` is perfectly legal. This would lead to
    a runtime type error, were `Rafael.get_age` invoked later in the computation.
    It is even possible to create instance variables from outside the class definition.
    For example, Python will not complain if the assignment statement
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: occurs outside the class definition.
  prefs: []
  type: TYPE_NORMAL
- en: While this relatively weak static semantic checking is a flaw in Python, it
    is not a fatal flaw. A disciplined programmer can simply follow the sensible rule
    of not directly accessing data attributes from outside the class in which they
    are defined, as we do in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.1 Generators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A perceived risk of information hiding is that preventing client programs from
    directly accessing critical data structures leads to an unacceptable loss of efficiency.
    In the early days of data abstraction, many were concerned about the cost of introducing
    extraneous function or method calls. Modern compilation technology makes this
    concern moot. A more serious issue is that client programs will be forced to use
    inefficient algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the implementation of `grade_report` in [Figure 10-7](#c10-fig-0007).
    The invocation of `course.get_students` creates and returns a list of size `n`,
    where `n` is the number of students. This is probably not a problem for a grade
    book for a single class, but imagine keeping track of the grades of 1.7 million
    high school students taking the SATs. Creating a new list of that size when the
    list already exists is a significant inefficiency. One solution is to abandon
    the abstraction and allow `grade_report` to directly access the instance variable
    `course.students`, but that would violate information hiding. Fortunately, there
    is a better solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in [Figure 10-9](#c10-fig-0009) replaces the `get_students` function
    in class `Grades` with a function that uses a kind of statement we have not yet
    seen: a `yield` statement.'
  prefs: []
  type: TYPE_NORMAL
- en: Any function definition containing a `yield` statement is treated in a special
    way. The presence of `yield` tells the Python system that the function is a **generator**.
    Generators are typically used with `for` statements, as in
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: in [Figure 10-7](#c10-fig-0007).
  prefs: []
  type: TYPE_NORMAL
- en: '![c10-fig-0009.jpg](../images/c10-fig-0009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 10-9](#c10-fig-0009a) New version of `get_students`'
  prefs: []
  type: TYPE_NORMAL
- en: At the start of the first iteration of a `for` loop that uses a generator, the
    generator is invoked and runs until the first time a `yield` statement is executed,
    at which point it returns the value of the expression in the `yield` statement.
    On the next iteration, the generatorresumes execution immediately following the
    `yield`, with all local variables bound to the objects to which they were bound
    when the `yield` statement was executed, and again runs until a `yield` statement
    is executed. It continues to do this until it runs out of code to execute or executes
    a `return` statement, at which point the loop is exited.[^(63)](#c10-fn-0004)
  prefs: []
  type: TYPE_NORMAL
- en: The version of `get_students` in [Figure 10-9](#c10-fig-0009) allows programmers
    to use a `for` loop to iterate over the students in objects of type `Grades` in
    the same way they can use a `for` loop to iterate over elements of built-in types
    such as `list`. For example, the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Thus the loop in [Figure 10-7](#c10-fig-0007) that starts with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: does not have to be altered to take advantage of the version of class `Grades`
    that contains the new implementation of `get_students`. (Of course, most code
    that depended upon `get_students` returning a list would no longer work.) The
    same `for` loop can iterate over the values provided by `get_students` regardless
    of whether `get_students` returns a list of values or generates one value at a
    time. Generating one value at a time will be more efficient, because a new list
    containing the students will not be created.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise:** Add to `Grades` a generator that meets the specification'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 10.4 An Extended Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A collapse in U.S. housing prices helped trigger an international economic meltdown
    in the fall of 2008\. One of the contributing factors was that too many homeowners
    had taken on mortgages that ended up having unexpected consequences.[^(64)](#c10-fn-0005)
  prefs: []
  type: TYPE_NORMAL
- en: In the beginning, mortgages were relatively simple beasts. Buyers borrowed money
    from a bank and made a fixed-size payment each month for the life of the mortgage,
    which typically ranged from 15 to 30 years. At the end of that period, the bank
    had been paid back the initial loan (the principal) plus interest, and the homeowner
    owned the house “free and clear.”
  prefs: []
  type: TYPE_NORMAL
- en: Towards the end of the twentieth century, mortgages started getting a lot more
    complicated. People could get lower interest rates by paying “points” to the lender
    at the time they took on the mortgage. A point is a cash payment of `1%` of the
    value of the loan. People could take mortgages that were “interest-only” for a
    period of time. That is to say, for some number of months at the start of the
    loan the borrower paid only the accrued interest and none of the principal. Other
    loans involved multiple rates. Typically the initial rate (called a “teaser rate”)
    was low, and then it went up over time. Many of these loans were variable-rate—the
    rate to be paid after the initial period would vary depending upon some index
    intended to reflect the cost to the lender of borrowing on the wholesale credit
    market.[^(65)](#c10-fn-0006)
  prefs: []
  type: TYPE_NORMAL
- en: In principle, giving consumers a variety of options is a good thing. However,
    unscrupulous loan purveyors were not always careful to fully explain the possible
    long-term implications of the various options, and some borrowers made choices
    that proved to have dire consequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build a program that examines the costs of three kinds of mortgages:'
  prefs: []
  type: TYPE_NORMAL
- en: A fixed-rate mortgage with no points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A fixed-rate mortgage with points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mortgage with an initial teaser rate followed by a higher rate for the duration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The point of this exercise is to provide some experience in the incremental
    development of a set of related classes, not to make you an expert on mortgages.
  prefs: []
  type: TYPE_NORMAL
- en: We will structure our code to include a `Mortgage` class and subclasses corresponding
    to each of the three kinds of mortgages listed above. [Figure 10-10](#c10-fig-0010)
    contains the **abstract class** `Mortgage`. This class contains methods that are
    shared by each of its subclasses, but it is not intended to be instantiated directly.
    That is, no objects of type `Mortgage` will be created.
  prefs: []
  type: TYPE_NORMAL
- en: The function `find_payment` at the top of the figure computes the size of the
    fixed monthly payment needed to pay off the loan, including interest, by the end
    of its term. It does this using a well-known closed-form expression. This expression
    is not hard to derive, but it is a lot easier to just look it up and more likely
    to be correct than one derived on the spot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind, however, that not everything you discover on the web (or even
    in textbooks) is correct. When your code incorporates a formula that you have
    looked up, make sure that:'
  prefs: []
  type: TYPE_NORMAL
- en: You have taken the formula from a reputable source. We looked at multiple reputable
    sources, all of which contained equivalent formulas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You fully understand the meaning of all the variables in the formula.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You test your implementation against examples taken from reputable sources.
    After implementing this function, we tested it by comparing our results to the
    results supplied by a calculator available on the web.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![c10-fig-0010.jpg](../images/c10-fig-0010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 10-10](#c10-fig-0010a) `Mortgage` base class'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at `__init__`, we see that all `Mortgage` instances will have instance
    variables corresponding to the initial loan amount, the monthly interest rate,
    the duration of the loan in months, a list of payments that have been made at
    the start of each month (the list starts with `0`, since no payments have been
    made at the start of the first month), a list with the balance of the loan that
    is outstanding at the start of each month, the amount of money to be paid each
    month (initialized using the value returned by the function `find_payment)`, and
    a description of the mortgage (which initially has a value of `None`). The `__init__`
    operation of each subclass of `Mortgage` is expected to start by calling `Mortgage.__init__`,
    and then to initialize `self._legend` to an appropriate description of that subclass.
  prefs: []
  type: TYPE_NORMAL
- en: The method `make_payment` is used to record mortgage payments. Part of each
    payment covers the amount of interest due on the outstanding loan balance, and
    the remainder of the payment is used to reduce the loan balance. That is why `make_payment`
    updates both `self.paid` and `self.outstanding`.
  prefs: []
  type: TYPE_NORMAL
- en: The method `get_total_paid` uses the built-in Python function `sum`, which returns
    the sum of a sequence of numbers. If the sequence contains a non-number, an exception
    is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-11](#c10-fig-0011) contains classes implementing three types of
    mortgages. The classes `Fixed` and `Fixed_with_pts` override `__init__` and inherit
    the other three methods from `Mortgage`. The class `Two_rate` treats a mortgage
    as the concatenation of two loans, each at a different interest rate. (Since `self.paid`
    is initialized to a list with one element, it contains one more element than the
    number of payments that have been made. That''s why the method `make_payment`
    compares `len(self.paid)` to `self.teaser_months + 1`.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-11](#c10-fig-0011) also contains a function that computes and prints
    the total cost of each kind of mortgage for a sample set of parameters. It begins
    by creating one mortgage of each kind. It then makes a monthly payment on each
    for a given number of years. Finally, it prints the total amount of the payments
    made for each loan.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now, finally, ready to compare different mortgages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we used keyword rather than positional arguments in the invocation
    of `compare_mortgages`. We did this because `compare_mortgages` has a large number
    of formal parameters of the same type, and using keyword arguments makes it easier
    to ensure that we are supplying the intended actual values to each of the formals.
  prefs: []
  type: TYPE_NORMAL
- en: When the code is run, it prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '![c10-fig-0011.jpg](../images/c10-fig-0011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 10-11](#c10-fig-0011a) Mortgage subclasses'
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, the results look pretty conclusive. The variable-rate loan
    is a bad idea (for the borrower, not the lender) and the fixed-rate loan with
    points costs the least. It's important to note, however, that total cost is not
    the only metric by which mortgages should be judged. For example, a borrower who
    expects to have a higher income in the future may be willing to pay more in the
    later years to lessen the burden of payments in the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: This suggests that rather than looking at a single number, we should look at
    payments over time. This in turn suggests that our program should be producing
    plots designed to show how the mortgage behaves over time. We will do that in
    Section 13.2.
  prefs: []
  type: TYPE_NORMAL
- en: 10.5 Terms Introduced in Chapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: object-oriented programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: abstract data type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: abstraction barrier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: decomposition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: class definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: method attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: class attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: class instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: attribute reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: __ methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: magic (dunder) methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: data attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: class variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: instance variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: class definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: representation invariant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: subclass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: superclass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: overriding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: isinstance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: substitution principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: information hiding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: private
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: abstract class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
