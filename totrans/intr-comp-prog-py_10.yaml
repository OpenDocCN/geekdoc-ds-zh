- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EXCEPTIONS AND ASSERTIONS
  prefs: []
  type: TYPE_NORMAL
- en: An “exception” is usually defined as “something that does not conform to the
    norm,” and is therefore somewhat rare. There is nothing rare about **exceptions**
    in Python. They are everywhere. Virtually every module in the standard Python
    library uses them, and Python itself will raise them in many circumstances. You've
    already seen some exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Open a Python shell and enter
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: and the interpreter will respond with something like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`IndexError` is the type of exception that Python **raises** when a program
    tries to access an element that is outside the bounds of an indexable type. The
    string following `IndexError` provides additional information about what caused
    the exception to occur.'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the built-in exceptions of Python deal with situations in which a program
    has attempted to execute a statement with no appropriate semantics. (We will deal
    with the exceptional exceptions—those that do not deal with errors—later in this
    chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: Those readers (all of you, we hope) who have attempted to write and run Python
    programs already have encountered many of these. Among the most common types of
    exceptions are `TypeError`, `IndexError`, `NameError`, and `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1 Handling Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to now, we have treated exceptions as terminal events. When an exception
    is raised, the program terminates (crashes might be a more appropriate word in
    this case), and we go back to our code and attempt to figure out what went wrong.
    When an exception is raised that causes the program to terminate, we say that
    an **unhandled exception** has been raised.
  prefs: []
  type: TYPE_NORMAL
- en: An exception does not need to lead to program termination. Exceptions, when
    raised, can and should be **handled** by the program*.* Sometimes an exception
    is raised because there is a bug in the program (like accessing a variable that
    doesn't exist), but many times, an exception is something the programmer can and
    should anticipate. A program might try to open a file that does not exist. If
    an interactive program asks a user for input, the user might enter something inappropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Python provides a convenient mechanism, **try-except**, for **catching** and
    handling exceptions. The general form is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you know that a line of code might raise an exception when executed, you
    should handle the exception. In a well-written program, unhandled exceptions should
    be the exception.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Most of the time, this code will work just fine, but it will fail if `num_failures`
    happens to be zero. The attempt to divide by zero will cause the Python runtime
    system to raise a `ZeroDivisionError` exception, and the `print` statement will
    never be reached.
  prefs: []
  type: TYPE_NORMAL
- en: It is better to write something along the lines of
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Upon entering the `try` block, the interpreter attempts to evaluate the expression
    `num_successes/num_failures`. If expression evaluation is successful, the program
    assigns the value of the expression to the variable `success_failure_ratio`, executes
    the `print` statement at the end of the `try` block, and then proceeds to execute
    whatever code follows the `try-except` block. If, however, a `ZeroDivisionError`
    exception is raised during the expression evaluation, control immediately jumps
    to the `except` block (skipping the assignment and the `print` statement in the
    `try` block), the `print` statement in the `except` block is executed, and then
    execution continues following the `try-except` block.
  prefs: []
  type: TYPE_NORMAL
- en: "**Finger exercise:** Implement a function that meets the specification below.\
    \ Use a `try-except` block. Hint: before starting to code, you might want to type\
    \ something like `\uFEFF1 + 'a'` into the shell to see what kind of exception\
    \ is raised."
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If it is possible for a block of program code to raise more than one kind of
    exception, the reserved word `except` can be followed by a tuple of exceptions,
    e.g.,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: in which case the `except` block will be entered if any of the listed exceptions
    is raised within the `try` block.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can write a separate `except` block for each kind of exception,
    which allows the program to choose an action based upon which exception was raised.
    If the programmer writes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: the `except` block will be entered if any kind of exception is raised within
    the `try` block. Consider the function definition in [Figure 9-1](#c9-fig-0001).
  prefs: []
  type: TYPE_NORMAL
- en: '![c9-fig-0001.jpg](../images/c9-fig-0001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 9-1](#c9-fig-0001a) Using exceptions for control flow'
  prefs: []
  type: TYPE_NORMAL
- en: There are two `except` blocks associated with the `try` block. If an exception
    is raised within the `try` block, Python first checks to see if it is a `ZeroDivisionError`.
    If so, it appends a special value, `nan`, of type `float` to `ratios`. (The value
    `nan` stands for “not a number.” There is no literal for it, but it can be denoted
    by converting the string `'nan'` or the string `'NaN'` to type `float`. When `nan`
    is used as an operand in an expression of type `float`, the value of that expression
    is also `nan`.) If the exception is anything other than a `ZeroDivisionError`,
    the code executes the second `except` block, which raises a `ValueError` exception
    with an associated string.
  prefs: []
  type: TYPE_NORMAL
- en: In principle, the second `except` block should never be entered, because the
    code invoking `get_ratios` should respect the assumptions in the specification
    of `get_ratios`. However, since checking these assumptions imposes only an insignificant
    computational burden, it is probably worth practicing defensive programming and
    checking anyway.
  prefs: []
  type: TYPE_NORMAL
- en: The following code illustrates how a program might use `get_ratios`. The name
    `msg` in the line `except ValueError as msg:` is bound to the argument (a string
    in this case) associated with `ValueError` when it was raised. When the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: is executed it prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For comparison, [Figure 9-2](#c9-fig-0002) contains an implementation of the
    same specification, but without using a `try-except`. The code in [Figure 9-2](#c9-fig-0002)
    is longer and more difficult to read than the code in [Figure 9-1](#c9-fig-0001).
    It is also less efficient. (The code in [Figure 9-2](#c9-fig-0002) could be shortened
    by eliminating the local variables `vect1_elem` and `vect2_elem`, but only at
    the cost of introducing yet more inefficiency by indexing into the lists repeatedly.)
  prefs: []
  type: TYPE_NORMAL
- en: '![c9-fig-0002.jpg](../images/c9-fig-0002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 9-2](#c9-fig-0002a) Control flow without a try-except'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at another example. Consider the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If the user obligingly types a string that can be converted to an integer, everything
    will be fine. But suppose the user types `abc`? Executing the line of code will
    cause the Python runtime system to raise a `ValueError` exception, and the `print`
    statement will never be reached.
  prefs: []
  type: TYPE_NORMAL
- en: What the programmer should have written would look something like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: After entering the loop, the program will ask the user to enter an integer.
    Once the user has entered something, the program executes the `try—except` block.
    If neither of the first two statements in the `try` block causes a `ValueError`
    exception to be raised, the `break` statement is executed and the `while` loop
    is exited. However, if executing the code in the `try` block raises a `ValueError`
    exception, control is immediately transferred to the code in the `except` block.
    Therefore, if the user enters a string that does not represent an integer, the
    program will ask the user to try again. No matter what text the user enters, it
    will not cause an unhandled exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The downside of this change is that the program text has grown from two lines
    to eight. If there are many places where the user is asked to enter an integer,
    this can be problematical. Of course, this problem can be solved by introducing
    a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Better yet, this function can be generalized to ask for any type of input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The function `read_val` is **polymorphic**, i.e., it works for arguments of
    many different types. Such functions are easy to write in Python, since types
    are **first-class objects**. We can now ask for an integer using the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Exceptions may seem unfriendly (after all, if not handled, an exception will
    cause the program to crash), but consider the alternative. What should the type
    conversion `int` do, for example, when asked to convert the string `'abc'` to
    an object of type `int`? It could return an integer corresponding to the bits
    used to encode the string, but this is unlikely to have any relation to the intent
    of the programmer. Alternatively, it could return the special value `None`. If
    it did that, the programmer would need to insert code to check whether the type
    conversion had returned `None`. A programmer who forgot that check would run the
    risk of getting some strange error during program execution.
  prefs: []
  type: TYPE_NORMAL
- en: With exceptions, the programmer still needs to include code dealing with the
    exception. However, if the programmer forgets to include such code and the exception
    is raised, the program will halt immediately. This is a good thing. It alerts
    the user of the program that something troublesome has happened. (And, as we discussed
    in Chapter 8, overt bugs are much better than covert bugs.) Moreover, it gives
    someone debugging the program a clear indication of where things went awry.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2 Exceptions as a Control Flow Mechanism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Don't think of exceptions as purely for errors. They are a convenient flow-of-control
    mechanism that can be used to simplify programs.
  prefs: []
  type: TYPE_NORMAL
- en: In many programming languages, the standard approach to dealing with errors
    is to have functions return a value (often something analogous to Python's `None`)
    indicating that something is amiss. Each function invocation has to check whether
    that value has been returned. In Python, it is more usual to have a function raise
    an exception when it cannot produce a result that is consistent with the function's
    specification.
  prefs: []
  type: TYPE_NORMAL
- en: The Python `**raise**` **statement** forces a specified exception to occur.
    The form of a raise statement is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The *exceptionName* is usually one of the built-in exceptions, e.g., `ValueError`.
    However, programmers can define new exceptions by creating a subclass (see Chapter
    10) of the built-in class `Exception`. Different types of exceptions can have
    different types of arguments, but most of the time the argument is a single string,
    which is used to describe the reason the exception is being raised.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise:** Implement a function that satisfies the specification'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at one more example, [Figure 9-3](#c9-fig-0003). The function `get_grades`
    either returns a value or raises an exception with which it has associated a value.
    It raises a `ValueError` exception if the call to `open` raises an `IOError`.
    It could have ignored the `IOError` and let the part of the program calling `get_grades`
    deal with it, but that would have provided less information to the calling code
    about what went wrong. The code that calls `get_grades` either uses the returned
    value to compute another value or handles the exception and prints an informative
    error message.
  prefs: []
  type: TYPE_NORMAL
- en: '![c9-fig-0003.jpg](../images/c9-fig-0003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 9-3](#c9-fig-0003a) Get grades'
  prefs: []
  type: TYPE_NORMAL
- en: 9.3 Assertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Python `assert` statement provides programmers with a simple way to confirm
    that the state of a computation is as expected. An **assert statement** can take
    one of two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18] `assert` *Boolean expression*`,` *argument* [PRE19]`  `## 9.4 Terms
    Introduced in Chapter    *   exceptions *   raising an exception *   unhandled
    exception *   handled exception *   try-except construct *   catch (an exception)
    *   polymorphic functions *   first-class objects *   raise statement *   assertions`'
  prefs: []
  type: TYPE_NORMAL
