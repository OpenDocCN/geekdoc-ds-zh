- en: 12.1¬†Mutating Structuresüîó
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://dcic-world.org/2025-08-27/mutating-structures.html](https://dcic-world.org/2025-08-27/mutating-structures.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| ¬†¬†¬†¬†[12.1.1¬†Example: Bank Accounts](#%28part._eg-bank-acc%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[12.1.2¬†Testing Functions that Mutate Structures](#%28part._.Testing_.Functions_that_.Mutate_.Structures%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[12.1.3¬†Aliasing](#%28part._mult-bank-acct%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[12.1.4¬†Structure Mutation and the Directory](#%28part._structure-mut-dir%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[12.1.4.1¬†Introducing the Heap](#%28part._heap-intro%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[12.1.4.2¬†Basic Data and the Heap](#%28part._basic-data-heap%29) |'
  prefs: []
  type: TYPE_TB
- en: We will now study a new kind of data and the programming style that accompanies
    it. This will give us both great power and great responsibility. We will develop
    this idea in both Pyret and Python, both because the core concept arises in both
    (indeed in nearly all) languages and because their contrast is instructive.
  prefs: []
  type: TYPE_NORMAL
- en: '12.1.1¬†Example: Bank Accounts[üîó](#(part._eg-bank-acc) "Link to here")'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Imagine that we want to represent bank accounts, where each account has a (unique)
    id number and a balance:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs now make an account:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let‚Äôs say we learn that the account has just earned another 200\. We could
    always reflect the resulting account as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pyret |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: However, this creates a new account; if we look at the current `balance` of
    `acct1`, by writing `acct1.balance`, it is still `500`. If this were our account,
    we would be quite sad!
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather, we want to change the balance in the existing account. This requires
    a programming feature that we have not encountered until now: data that can be
    changed. Such data are called mutable, and we explore them below. In contrast,
    until now we have worked with immutable data: data that cannot be altered.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to declare that the data can be changed. In Python, this is
    automatically true, always, so nothing changes. In Pyret, however, fields cannot
    be changed‚Äî<wbr>they are immutable‚Äî<wbr>by default. We have to explicitly say
    they can be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: This Pyret definition says that `id` cannot be changed, while `balance` can.
    This ensures that no programmer can accidentally change the bank account number.
    In Python, every programmer has to make sure they don‚Äôt accidentally change it.
    (If we did want `id` to be mutable in Pyret, we would add a `ref` in front of
    it, too.)
  prefs: []
  type: TYPE_NORMAL
- en: 'With this definition, making accounts looks the same (unsurprisingly in Python,
    since nothing has changed):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we view the account in Pyret, we see something special:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f5f80ba55f5bfb86404617db2b19812e.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: The yellow-and-black ‚Äúcaution tape‚Äù indicator is a reminder that the value can
    change, so what is shown on screen may not be the current value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accessing an immutable field in Pyret remains the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, accessing a mutable field looks different in Pyret:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The `!` is there to remind that what you are getting is the current value of
    `balance`, and it may be different later. Python does not offer a similar syntactic
    warning, but then again, recall that every field is always mutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now let‚Äôs see how to change that account balance. For simplicity, let‚Äôs
    first see how to set the account balance to zero. We use slightly different syntaxes
    for it in the two languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| `acct1.balance = 0` | `acct1!{balance: 0}` |'
  prefs: []
  type: TYPE_TB
- en: 'In Pyret, again, we use `!` in the syntax for changing the field: read it as
    ‚Äúchange the value now!‚Äù'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You now know all the parts you need to figure out how to set `balance` to be
    `200` more than its previous value. Can you figure out how to write that?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here‚Äôs how we combine the pieces‚Äî<wbr>accessing the value and then setting
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `acct1.balance = acct1.balance + 200` |'
  prefs: []
  type: TYPE_TB
- en: '| Pyret |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `acct1!{balance: acct1!balance + 200}` |'
  prefs: []
  type: TYPE_TB
- en: While Pyret‚Äôs syntax is a little more onerous for changing the value of one
    field, it proves to be ligher-weight if we want to change multiple fields. In
    Python we‚Äôd have to write `acct1.` for each of them, whereas in Pyret we need
    only the one `acct1!`. So there is a trade-off between the two syntaxes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We hadn‚Äôt written any tests above. Suppose we had: already we might notice
    something a bit odd. Say we had written'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: This would pass before we performed the update, but fails after the update is
    performed. In Python, tests are run when we call the testing functions, which
    we typically do after loading the full file (either by running them at the prompt
    or by putting our tests in a separate file).
  prefs: []
  type: TYPE_NORMAL
- en: 'In Pyret, tests are run as if they were written at the very bottom of definitions.
    Therefore, even if the program looked like this in Pyret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: the test fails. Alternatively, we can write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: and it passes, but not if we comment out the update.
  prefs: []
  type: TYPE_NORMAL
- en: 'In both languages, then, we see a new phenomenon: tests that are only sometimes
    true. This phenomenon is called state. There is a ‚Äústate‚Äù (a collection of values
    for the defined names) in which the balance is `500`, and another where it is
    `700`. This is not merely limited to testing! Testing is just a reflection of
    what is going on in the program as it runs. From now on, every programming instruction
    will run in some state, and its actions will depend on the other values in that
    state. If those values change, the same instruction‚Äî<wbr>i.e., the same piece
    of program text‚Äî<wbr>may produce different answers. This makes programming much
    harder, and we will have to get used to the subtleties that come along with it.'
  prefs: []
  type: TYPE_NORMAL
- en: 12.1.2¬†Testing Functions that Mutate Structures[üîó](#(part._.Testing_.Functions_that_.Mutate_.Structures)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our example of adding funds to an account corresponds to making a deposit into
    a bank account. Let‚Äôs turn our balance-updating expression into a function (named
    `deposit`) that takes the deposit amount as input. Then, we‚Äôll look at how to
    write tests for that function. First, the function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pyret |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: How do we test this?
  prefs: []
  type: TYPE_NORMAL
- en: In Python, this function does not return anything. In Pyret, the update operation
    does return the value being updated, but in a larger function we can‚Äôt always
    assume that it will be the value returned. Therefore, we have to set up our test
    to assume otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, tests for functions that contain mutation need to have three to
    four parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setup: set up the necessary values to provide the function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Call: call the function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check: check that the function had the desired behavior.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Teardown: restore data to their expected state.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: In this case we don‚Äôt need to perform a Teardown step because we created data
    purely for testing the function. But if, for instance, we had run the test over
    a dataset whose values matter, we would need to restore the changes.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the Setup phase needs to make sure that all data have the right values.
    Until now, once created, data did not change. But now, data may have been changed
    by some other mutations, and this may cause tests to fail. Therefore, the Setup
    phase requires not only creating necessary data but also setting the values of
    previously-created data to be what the test expects. (Again, note that in Python
    it is difficult to know which fields might have been changed, whereas in Pyret,
    we only have to reset the value of mutable fields.)
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write tests for the following function that adds interest to an account balance:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Python |  |'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '|  |'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '[PRE22]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Pyret |  |'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '|  |'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '[PRE23]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 12.1.3¬†Aliasing[üîó](#(part._mult-bank-acct) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let‚Äôs suppose our bank allows accounts to be shared by multiple customers.
    We should thus separate information about customers from that of the account:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, suppose we have two accounts (`acct1` and `acct2`), where `acct1`
    is owned jointly by Elena and Jorge:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let‚Äôs say Elena earns an additional `150`. We want to update the account
    to reflect this. How might we do it? First we have to access the account itself:
    `elena.acct` (in both languages). Then we would update it using the syntax above:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sure enough, Elena‚Äôs account will now have the value of `850` (the original
    `500`, the bonus of `200`, and now the extra `150`):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pyret |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe that in Pyret we use `.` to get the account but `!` to get the balance:
    a reminder that Elena‚Äôs account will never change (the way we have defined the
    data structure), but that account‚Äôs balance may and, indeed, does. Between the
    designs of Python and Pyret, there‚Äôs a trade-off between convenience and precision.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key question now is: what is Jorge‚Äôs balance? Put differently, will this
    test pass or fail?'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pyret |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or even more simply: what is the value of this program?'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two very reasonable answers here:'
  prefs: []
  type: TYPE_NORMAL
- en: Going by our prose, Jorge‚Äôs account should also have `850`, because that‚Äôs what
    it means to ‚Äúshare‚Äù an account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Going by the visible code, Jorge‚Äôs account should still have `700`, because
    the update was made through `elena.acct`, not `jorge.acct`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Run the above code and see what you get.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What you find is that the above test passes: Jorge‚Äôs account also has `850`.
    We say that `elena.acct` and `jorge.acct` are aliases: they are two different
    ‚Äúnames‚Äù for the exact same datum.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not the first time we have had shared data. However, until now, it
    hasn‚Äôt mattered that the data were aliased. But now that we have mutation, aliases
    matter: the balance in `jorge.acct` has changed even though we never made an explicit
    change using that name. It is as if `elena.acct` exhibited spooky action at a
    distance.'
  prefs: []
  type: TYPE_NORMAL
- en: Again, there is a linguistic difference here. Because all fields are mutable
    in Python, you have to always be on the alert for this. Because only `ref` fields
    are mutable in Pyret, you can be sure that fields accessed through `.` will never
    change in value over time or even if there are aliases, but those accessed through
    `!` might change over time (and via aliases).
  prefs: []
  type: TYPE_NORMAL
- en: 12.1.4¬†Structure Mutation and the Directory[üîó](#(part._structure-mut-dir) "Link
    to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the ability to mutate the contents of data, we will need to
    show and then revise our notion of directories. The directories are essentially
    the same between Pyret and Python, with one exception: we have different naming
    conventions in the two languages. For instance, we write `Account(8404, 500)`
    in Python versus `account(8404, 500)` in Pyret. It would be annoying to write
    every one of these twice, with the only difference being the capitalization. Therefore,
    where the only difference is the naming, we will ignore this difference and show
    only one version (in this case, the Python version); you should assume that the
    exact same thing is true for Pyret, other than the capitalization.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, here are our initial definitions once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Review the following proposal for the directory contents after running the initial
    definitions. Is this what you expect to see?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Directory
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‚Üí
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‚Üí
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‚Üí
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‚Üí
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
- en: 'There‚Äôs a problem with this version, namely the use of `acct1` in the values
    associated with `elena` and `jorge`. Remember, the values in the directory can‚Äôt
    refer to names in the directory: both Pyret and Python replace names with their
    values when evaluating expressions. Here is the corresponding version of the directory
    that uses the value of `acct1`:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Observe that this is also what you would see if you were to evaluate the corresponding
    variable names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let‚Äôs add funds to Elena‚Äôs account:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pyret |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show how the directory changes if you run the above code.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: If we follow the code precisely, we might expect the following directory, in
    which only the balance in Elena‚Äôs version of the account changes.
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We know from running the code, however, that the account is aliased, so that
    the balances accessible from each of `acct`, `elena.acct`, and `jorge.acct` all
    reflect the update. This suggests that the actual directory should look something
    like
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: But this is also weird. The directory represents the information that Pyret
    or Python maintain about your defined names and their values. What in the directory
    indicates that those three balances should change, but not the balance of `acct2`)?
    Put differently, what reflects the aliasing? Nothing!
  prefs: []
  type: TYPE_NORMAL
- en: The directory as we have used it up until now works fine for programs without
    mutation. But once we have both mutation and aliasing, this simple idea of mapping
    names to values breaks down because it doesn‚Äôt capture the aliases. We need a
    refined representation of the connections between names and values that does capture
    aliasing.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1.4.1¬†Introducing the Heap[üîó](#(part._heap-intro) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Our original presentation of the directory reflected the aliases that referred
    to a single `Account` through repeated use of the name `acct1`. We only lost that
    sharing when we replaced `acct1` with it‚Äôs value while setting up the data for
    Elena and Jorge. The rule that names can‚Äôt appear in the values is still important,
    especially in the presence of mutation (we‚Äôll return to this later in [Mutating
    Variables in Memory](mutating-variables.html#%28part._mutating-vars-memory%29)).
    But the idea of having a single term that can be reused to reflect sharing is
    a good one. Indeed, it reflects what happens inside your computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time you use a constructor to create data, your programming environment
    stores it in the memory of your computer. Memory consists of a (large) number
    of slots. Your newly-created datum goes into one of these slots. Each slot is
    labeled with an address. Just as a street address refers to a specific building,
    a memory address refers to a specific slot where a datum is stored. Memory slots
    are physical entities, not conceptual ones. A computer with a 500GB hard drive
    has about 500 billion slots in which it can store data. Not all of that memory
    is available to your programming environment: your Web browser, applications,
    operating system, and so on all get stored in the memory. Your programming environment
    does get a portion of memory to use for storing its data. That portion is called
    the heap.'
  prefs: []
  type: TYPE_NORMAL
- en: When you write a statement like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'your programming environment puts the new `Account` into a physical slot in
    the heap, then associates the address of that slot with the variable name in the
    directory. The name in the directory doesn‚Äôt map to the value itself, but rather
    to the address that holds the value. The address bridges between the physical
    storage location and the conceptual name you want to associate with the new datum.
    In other words, our directory really looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1001
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: 1001:¬†`Account(8404, 500)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our revised version has two separate areas: the directory (mapping names to
    addresses) and the heap (showing the values stored at the addresses). We will
    use four-digit numbers for addresses, prefixed with an @ symbol (reserving numbers
    with fewer digits for data values). The specific number for the initial address
    (here 1001) is arbitrary. Subsequent storage of structured data values will use
    the addresses in order. Let‚Äôs write out the directory and heap contents for our
    initial definitions of accounts in this new format, and see how it supports the
    aliasing that we intended.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create both `acct1` and `acct2` in order as follows. Note that the
    `Account` associated with name `acct2` goes in address 1002.
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1001
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1002
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: 1001:¬†`Account(8404, 500)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1002:¬†`Account(8404, 500)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we run
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'what happens? As before, we look up what the name `acct1` refers to in the
    directory and substitute the result for the name in the `Customer` data. Now,
    `acct1` evaluates to an address, 1001\. Therefore, the `Customer` value in the
    heap contains an address:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1001
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1002
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: 1001:¬†`Account(8404, 500)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1002:¬†`Customer("Elena", 1001)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, when we run
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'the directory and heap look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1001
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1002
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1003
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1004
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: 1001:¬†`Account(8404, 500)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1002:¬†`Account(8405, 3250)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1003:¬†`Customer("Elena", 1001)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1004:¬†`Customer("Jorge", 1001)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fun fact in the Web version of the book: Did you try hovering over the addresses?
    Try it now!'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'With the heap articulated separately from the directory, we now see the relationship
    between the `acct` fields for the two customers and the name `acct1`: they refer
    to the same address, which in turn means they refer to the same value. In contrast,
    the name `acct2`, which was not aliased in the original code, refers to an address
    that is not referenced anywhere else. This is the heart of aliasing: that‚Äôs why
    changes made through one name also affect values viewed through another.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write three distinct expressions each of which uses a different name in the
    directory to return the balance in account `acct1`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Would the following statement work to update the balance in Elena and Jorge‚Äôs
    shared account?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Python |  |'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '|  |'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '[PRE85]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Pyret |  |'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '|  |'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '[PRE86]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does this seem like a good or bad way to do this computation? Why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Extend the most recent directory and heap contents to reflect running the following
    statement:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did you change the heap in the previous exercise? Should you have?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Three rules guide how the directory and heap are affected by running programs:'
  prefs: []
  type: TYPE_NORMAL
- en: If the code construct a new piece of structured data, put the new piece of structured
    data at the next address in the heap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the code associates a name with a piece of structured data, the directory
    should map the name to the address of the datum in the heap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the code modifies a field within structured data, modify the data in the
    heap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the example above, we did not alter the heap in any way; only the directory
    should be modified to reflect that `acct3` and `acct1` are now aliases.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1.4.2¬†Basic Data and the Heap[üîó](#(part._basic-data-heap) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The above rules don‚Äôt indicate what happens when we have basic data, such as
    numbers or strings, associated with names in the directory. Do those values also
    get addresses in the heap?
  prefs: []
  type: TYPE_NORMAL
- en: 'They do not. As our example with shared accounts illustrated, we need the heap
    so that updates to fields of shared data affect all aliases (names that refer
    to) those data. Basic data don‚Äôt have fields, so there is no need to put them
    in the heap. Here‚Äôs a concrete example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding directory and heap contents would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†`"Dr. Kumar"`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Notice that this particular program puts nothing in the heap: according to
    our rules above, only structured data only go into the heap. Now assume our program
    also had a dataclass (Python) or datatype (Pyret) for `Office`s, with a professor‚Äôs
    name and room number. Here‚Äôs another example showing a combination of basic and
    structured data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†`"Dr. Kumar"`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1005
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1006
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: 1005:¬†`Office("Dr. Lakshmi", 311)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1006:¬†`Office("Dr. Kumar", 314)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though specific language implementations can vary, this shows that it is sufficient
    to think of basic data as residing in the directory, not the heap. The whole point
    of structured data is that they have both their own identity and multiple components.
    The heap gives access to both concepts. Basic data can‚Äôt be broken down (by definition).
    As such, there is nothing lost by putting them only in the directory.
  prefs: []
  type: TYPE_NORMAL
- en: But what about strings? We‚Äôve referred to them as basic data until now, but
    don‚Äôt they have ‚Äúcomponents‚Äù, namely the characters that make up the string? Yes,
    that is technically accurate. However, we are treating strings as basic data because
    we aren‚Äôt using operations that modify that sequence of characters. This is a
    subtle point, one that usually comes up later in computer science. This book will
    leave strings in the directory, but if you are writing programs that modify the
    internal characters, put them in the heap instead.
  prefs: []
  type: TYPE_NORMAL
- en: '12.1.1¬†Example: Bank Accounts[üîó](#(part._eg-bank-acc) "Link to here")'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Imagine that we want to represent bank accounts, where each account has a (unique)
    id number and a balance:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs now make an account:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let‚Äôs say we learn that the account has just earned another 200\. We could
    always reflect the resulting account as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pyret |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: However, this creates a new account; if we look at the current `balance` of
    `acct1`, by writing `acct1.balance`, it is still `500`. If this were our account,
    we would be quite sad!
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather, we want to change the balance in the existing account. This requires
    a programming feature that we have not encountered until now: data that can be
    changed. Such data are called mutable, and we explore them below. In contrast,
    until now we have worked with immutable data: data that cannot be altered.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to declare that the data can be changed. In Python, this is
    automatically true, always, so nothing changes. In Pyret, however, fields cannot
    be changed‚Äî<wbr>they are immutable‚Äî<wbr>by default. We have to explicitly say
    they can be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: This Pyret definition says that `id` cannot be changed, while `balance` can.
    This ensures that no programmer can accidentally change the bank account number.
    In Python, every programmer has to make sure they don‚Äôt accidentally change it.
    (If we did want `id` to be mutable in Pyret, we would add a `ref` in front of
    it, too.)
  prefs: []
  type: TYPE_NORMAL
- en: 'With this definition, making accounts looks the same (unsurprisingly in Python,
    since nothing has changed):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we view the account in Pyret, we see something special:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f5f80ba55f5bfb86404617db2b19812e.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: The yellow-and-black ‚Äúcaution tape‚Äù indicator is a reminder that the value can
    change, so what is shown on screen may not be the current value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accessing an immutable field in Pyret remains the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, accessing a mutable field looks different in Pyret:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The `!` is there to remind that what you are getting is the current value of
    `balance`, and it may be different later. Python does not offer a similar syntactic
    warning, but then again, recall that every field is always mutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now let‚Äôs see how to change that account balance. For simplicity, let‚Äôs
    first see how to set the account balance to zero. We use slightly different syntaxes
    for it in the two languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| `acct1.balance = 0` | `acct1!{balance: 0}` |'
  prefs: []
  type: TYPE_TB
- en: 'In Pyret, again, we use `!` in the syntax for changing the field: read it as
    ‚Äúchange the value now!‚Äù'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You now know all the parts you need to figure out how to set `balance` to be
    `200` more than its previous value. Can you figure out how to write that?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here‚Äôs how we combine the pieces‚Äî<wbr>accessing the value and then setting
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `acct1.balance = acct1.balance + 200` |'
  prefs: []
  type: TYPE_TB
- en: '| Pyret |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `acct1!{balance: acct1!balance + 200}` |'
  prefs: []
  type: TYPE_TB
- en: While Pyret‚Äôs syntax is a little more onerous for changing the value of one
    field, it proves to be ligher-weight if we want to change multiple fields. In
    Python we‚Äôd have to write `acct1.` for each of them, whereas in Pyret we need
    only the one `acct1!`. So there is a trade-off between the two syntaxes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We hadn‚Äôt written any tests above. Suppose we had: already we might notice
    something a bit odd. Say we had written'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: This would pass before we performed the update, but fails after the update is
    performed. In Python, tests are run when we call the testing functions, which
    we typically do after loading the full file (either by running them at the prompt
    or by putting our tests in a separate file).
  prefs: []
  type: TYPE_NORMAL
- en: 'In Pyret, tests are run as if they were written at the very bottom of definitions.
    Therefore, even if the program looked like this in Pyret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: the test fails. Alternatively, we can write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: and it passes, but not if we comment out the update.
  prefs: []
  type: TYPE_NORMAL
- en: 'In both languages, then, we see a new phenomenon: tests that are only sometimes
    true. This phenomenon is called state. There is a ‚Äústate‚Äù (a collection of values
    for the defined names) in which the balance is `500`, and another where it is
    `700`. This is not merely limited to testing! Testing is just a reflection of
    what is going on in the program as it runs. From now on, every programming instruction
    will run in some state, and its actions will depend on the other values in that
    state. If those values change, the same instruction‚Äî<wbr>i.e., the same piece
    of program text‚Äî<wbr>may produce different answers. This makes programming much
    harder, and we will have to get used to the subtleties that come along with it.'
  prefs: []
  type: TYPE_NORMAL
- en: 12.1.2¬†Testing Functions that Mutate Structures[üîó](#(part._.Testing_.Functions_that_.Mutate_.Structures)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our example of adding funds to an account corresponds to making a deposit into
    a bank account. Let‚Äôs turn our balance-updating expression into a function (named
    `deposit`) that takes the deposit amount as input. Then, we‚Äôll look at how to
    write tests for that function. First, the function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pyret |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: How do we test this?
  prefs: []
  type: TYPE_NORMAL
- en: In Python, this function does not return anything. In Pyret, the update operation
    does return the value being updated, but in a larger function we can‚Äôt always
    assume that it will be the value returned. Therefore, we have to set up our test
    to assume otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, tests for functions that contain mutation need to have three to
    four parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setup: set up the necessary values to provide the function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Call: call the function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check: check that the function had the desired behavior.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Teardown: restore data to their expected state.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: In this case we don‚Äôt need to perform a Teardown step because we created data
    purely for testing the function. But if, for instance, we had run the test over
    a dataset whose values matter, we would need to restore the changes.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the Setup phase needs to make sure that all data have the right values.
    Until now, once created, data did not change. But now, data may have been changed
    by some other mutations, and this may cause tests to fail. Therefore, the Setup
    phase requires not only creating necessary data but also setting the values of
    previously-created data to be what the test expects. (Again, note that in Python
    it is difficult to know which fields might have been changed, whereas in Pyret,
    we only have to reset the value of mutable fields.)
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write tests for the following function that adds interest to an account balance:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Python |  |'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '|  |'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '[PRE120]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Pyret |  |'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '|  |'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '[PRE121]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 12.1.3¬†Aliasing[üîó](#(part._mult-bank-acct) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let‚Äôs suppose our bank allows accounts to be shared by multiple customers.
    We should thus separate information about customers from that of the account:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, suppose we have two accounts (`acct1` and `acct2`), where `acct1`
    is owned jointly by Elena and Jorge:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let‚Äôs say Elena earns an additional `150`. We want to update the account
    to reflect this. How might we do it? First we have to access the account itself:
    `elena.acct` (in both languages). Then we would update it using the syntax above:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sure enough, Elena‚Äôs account will now have the value of `850` (the original
    `500`, the bonus of `200`, and now the extra `150`):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pyret |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe that in Pyret we use `.` to get the account but `!` to get the balance:
    a reminder that Elena‚Äôs account will never change (the way we have defined the
    data structure), but that account‚Äôs balance may and, indeed, does. Between the
    designs of Python and Pyret, there‚Äôs a trade-off between convenience and precision.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key question now is: what is Jorge‚Äôs balance? Put differently, will this
    test pass or fail?'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pyret |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or even more simply: what is the value of this program?'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two very reasonable answers here:'
  prefs: []
  type: TYPE_NORMAL
- en: Going by our prose, Jorge‚Äôs account should also have `850`, because that‚Äôs what
    it means to ‚Äúshare‚Äù an account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Going by the visible code, Jorge‚Äôs account should still have `700`, because
    the update was made through `elena.acct`, not `jorge.acct`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Run the above code and see what you get.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What you find is that the above test passes: Jorge‚Äôs account also has `850`.
    We say that `elena.acct` and `jorge.acct` are aliases: they are two different
    ‚Äúnames‚Äù for the exact same datum.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not the first time we have had shared data. However, until now, it
    hasn‚Äôt mattered that the data were aliased. But now that we have mutation, aliases
    matter: the balance in `jorge.acct` has changed even though we never made an explicit
    change using that name. It is as if `elena.acct` exhibited spooky action at a
    distance.'
  prefs: []
  type: TYPE_NORMAL
- en: Again, there is a linguistic difference here. Because all fields are mutable
    in Python, you have to always be on the alert for this. Because only `ref` fields
    are mutable in Pyret, you can be sure that fields accessed through `.` will never
    change in value over time or even if there are aliases, but those accessed through
    `!` might change over time (and via aliases).
  prefs: []
  type: TYPE_NORMAL
- en: 12.1.4¬†Structure Mutation and the Directory[üîó](#(part._structure-mut-dir) "Link
    to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the ability to mutate the contents of data, we will need to
    show and then revise our notion of directories. The directories are essentially
    the same between Pyret and Python, with one exception: we have different naming
    conventions in the two languages. For instance, we write `Account(8404, 500)`
    in Python versus `account(8404, 500)` in Pyret. It would be annoying to write
    every one of these twice, with the only difference being the capitalization. Therefore,
    where the only difference is the naming, we will ignore this difference and show
    only one version (in this case, the Python version); you should assume that the
    exact same thing is true for Pyret, other than the capitalization.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, here are our initial definitions once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Review the following proposal for the directory contents after running the initial
    definitions. Is this what you expect to see?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Directory
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‚Üí
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‚Üí
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‚Üí
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‚Üí
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
- en: 'There‚Äôs a problem with this version, namely the use of `acct1` in the values
    associated with `elena` and `jorge`. Remember, the values in the directory can‚Äôt
    refer to names in the directory: both Pyret and Python replace names with their
    values when evaluating expressions. Here is the corresponding version of the directory
    that uses the value of `acct1`:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE147]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE149]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Observe that this is also what you would see if you were to evaluate the corresponding
    variable names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let‚Äôs add funds to Elena‚Äôs account:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pyret |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show how the directory changes if you run the above code.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: If we follow the code precisely, we might expect the following directory, in
    which only the balance in Elena‚Äôs version of the account changes.
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE155]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE157]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE159]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We know from running the code, however, that the account is aliased, so that
    the balances accessible from each of `acct`, `elena.acct`, and `jorge.acct` all
    reflect the update. This suggests that the actual directory should look something
    like
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE163]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE165]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE167]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: But this is also weird. The directory represents the information that Pyret
    or Python maintain about your defined names and their values. What in the directory
    indicates that those three balances should change, but not the balance of `acct2`)?
    Put differently, what reflects the aliasing? Nothing!
  prefs: []
  type: TYPE_NORMAL
- en: The directory as we have used it up until now works fine for programs without
    mutation. But once we have both mutation and aliasing, this simple idea of mapping
    names to values breaks down because it doesn‚Äôt capture the aliases. We need a
    refined representation of the connections between names and values that does capture
    aliasing.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1.4.1¬†Introducing the Heap[üîó](#(part._heap-intro) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Our original presentation of the directory reflected the aliases that referred
    to a single `Account` through repeated use of the name `acct1`. We only lost that
    sharing when we replaced `acct1` with it‚Äôs value while setting up the data for
    Elena and Jorge. The rule that names can‚Äôt appear in the values is still important,
    especially in the presence of mutation (we‚Äôll return to this later in [Mutating
    Variables in Memory](mutating-variables.html#%28part._mutating-vars-memory%29)).
    But the idea of having a single term that can be reused to reflect sharing is
    a good one. Indeed, it reflects what happens inside your computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time you use a constructor to create data, your programming environment
    stores it in the memory of your computer. Memory consists of a (large) number
    of slots. Your newly-created datum goes into one of these slots. Each slot is
    labeled with an address. Just as a street address refers to a specific building,
    a memory address refers to a specific slot where a datum is stored. Memory slots
    are physical entities, not conceptual ones. A computer with a 500GB hard drive
    has about 500 billion slots in which it can store data. Not all of that memory
    is available to your programming environment: your Web browser, applications,
    operating system, and so on all get stored in the memory. Your programming environment
    does get a portion of memory to use for storing its data. That portion is called
    the heap.'
  prefs: []
  type: TYPE_NORMAL
- en: When you write a statement like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'your programming environment puts the new `Account` into a physical slot in
    the heap, then associates the address of that slot with the variable name in the
    directory. The name in the directory doesn‚Äôt map to the value itself, but rather
    to the address that holds the value. The address bridges between the physical
    storage location and the conceptual name you want to associate with the new datum.
    In other words, our directory really looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1001
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: 1001:¬†`Account(8404, 500)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our revised version has two separate areas: the directory (mapping names to
    addresses) and the heap (showing the values stored at the addresses). We will
    use four-digit numbers for addresses, prefixed with an @ symbol (reserving numbers
    with fewer digits for data values). The specific number for the initial address
    (here 1001) is arbitrary. Subsequent storage of structured data values will use
    the addresses in order. Let‚Äôs write out the directory and heap contents for our
    initial definitions of accounts in this new format, and see how it supports the
    aliasing that we intended.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create both `acct1` and `acct2` in order as follows. Note that the
    `Account` associated with name `acct2` goes in address 1002.
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1001
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1002
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: 1001:¬†`Account(8404, 500)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1002:¬†`Account(8404, 500)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we run
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'what happens? As before, we look up what the name `acct1` refers to in the
    directory and substitute the result for the name in the `Customer` data. Now,
    `acct1` evaluates to an address, 1001\. Therefore, the `Customer` value in the
    heap contains an address:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1001
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1002
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: 1001:¬†`Account(8404, 500)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1002:¬†`Customer("Elena", 1001)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, when we run
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'the directory and heap look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1001
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1002
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1003
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1004
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: 1001:¬†`Account(8404, 500)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1002:¬†`Account(8405, 3250)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1003:¬†`Customer("Elena", 1001)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1004:¬†`Customer("Jorge", 1001)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fun fact in the Web version of the book: Did you try hovering over the addresses?
    Try it now!'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'With the heap articulated separately from the directory, we now see the relationship
    between the `acct` fields for the two customers and the name `acct1`: they refer
    to the same address, which in turn means they refer to the same value. In contrast,
    the name `acct2`, which was not aliased in the original code, refers to an address
    that is not referenced anywhere else. This is the heart of aliasing: that‚Äôs why
    changes made through one name also affect values viewed through another.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write three distinct expressions each of which uses a different name in the
    directory to return the balance in account `acct1`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Would the following statement work to update the balance in Elena and Jorge‚Äôs
    shared account?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Python |  |'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '|  |'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '[PRE183]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Pyret |  |'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '|  |'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '[PRE184]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does this seem like a good or bad way to do this computation? Why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Extend the most recent directory and heap contents to reflect running the following
    statement:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did you change the heap in the previous exercise? Should you have?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Three rules guide how the directory and heap are affected by running programs:'
  prefs: []
  type: TYPE_NORMAL
- en: If the code construct a new piece of structured data, put the new piece of structured
    data at the next address in the heap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the code associates a name with a piece of structured data, the directory
    should map the name to the address of the datum in the heap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the code modifies a field within structured data, modify the data in the
    heap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the example above, we did not alter the heap in any way; only the directory
    should be modified to reflect that `acct3` and `acct1` are now aliases.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1.4.2¬†Basic Data and the Heap[üîó](#(part._basic-data-heap) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The above rules don‚Äôt indicate what happens when we have basic data, such as
    numbers or strings, associated with names in the directory. Do those values also
    get addresses in the heap?
  prefs: []
  type: TYPE_NORMAL
- en: 'They do not. As our example with shared accounts illustrated, we need the heap
    so that updates to fields of shared data affect all aliases (names that refer
    to) those data. Basic data don‚Äôt have fields, so there is no need to put them
    in the heap. Here‚Äôs a concrete example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding directory and heap contents would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE189]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†`"Dr. Kumar"`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Notice that this particular program puts nothing in the heap: according to
    our rules above, only structured data only go into the heap. Now assume our program
    also had a dataclass (Python) or datatype (Pyret) for `Office`s, with a professor‚Äôs
    name and room number. Here‚Äôs another example showing a combination of basic and
    structured data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE193]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†`"Dr. Kumar"`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1005
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1006
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: 1005:¬†`Office("Dr. Lakshmi", 311)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1006:¬†`Office("Dr. Kumar", 314)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though specific language implementations can vary, this shows that it is sufficient
    to think of basic data as residing in the directory, not the heap. The whole point
    of structured data is that they have both their own identity and multiple components.
    The heap gives access to both concepts. Basic data can‚Äôt be broken down (by definition).
    As such, there is nothing lost by putting them only in the directory.
  prefs: []
  type: TYPE_NORMAL
- en: But what about strings? We‚Äôve referred to them as basic data until now, but
    don‚Äôt they have ‚Äúcomponents‚Äù, namely the characters that make up the string? Yes,
    that is technically accurate. However, we are treating strings as basic data because
    we aren‚Äôt using operations that modify that sequence of characters. This is a
    subtle point, one that usually comes up later in computer science. This book will
    leave strings in the directory, but if you are writing programs that modify the
    internal characters, put them in the heap instead.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1.4.1¬†Introducing the Heap[üîó](#(part._heap-intro) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Our original presentation of the directory reflected the aliases that referred
    to a single `Account` through repeated use of the name `acct1`. We only lost that
    sharing when we replaced `acct1` with it‚Äôs value while setting up the data for
    Elena and Jorge. The rule that names can‚Äôt appear in the values is still important,
    especially in the presence of mutation (we‚Äôll return to this later in [Mutating
    Variables in Memory](mutating-variables.html#%28part._mutating-vars-memory%29)).
    But the idea of having a single term that can be reused to reflect sharing is
    a good one. Indeed, it reflects what happens inside your computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time you use a constructor to create data, your programming environment
    stores it in the memory of your computer. Memory consists of a (large) number
    of slots. Your newly-created datum goes into one of these slots. Each slot is
    labeled with an address. Just as a street address refers to a specific building,
    a memory address refers to a specific slot where a datum is stored. Memory slots
    are physical entities, not conceptual ones. A computer with a 500GB hard drive
    has about 500 billion slots in which it can store data. Not all of that memory
    is available to your programming environment: your Web browser, applications,
    operating system, and so on all get stored in the memory. Your programming environment
    does get a portion of memory to use for storing its data. That portion is called
    the heap.'
  prefs: []
  type: TYPE_NORMAL
- en: When you write a statement like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'your programming environment puts the new `Account` into a physical slot in
    the heap, then associates the address of that slot with the variable name in the
    directory. The name in the directory doesn‚Äôt map to the value itself, but rather
    to the address that holds the value. The address bridges between the physical
    storage location and the conceptual name you want to associate with the new datum.
    In other words, our directory really looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1001
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: 1001:¬†`Account(8404, 500)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our revised version has two separate areas: the directory (mapping names to
    addresses) and the heap (showing the values stored at the addresses). We will
    use four-digit numbers for addresses, prefixed with an @ symbol (reserving numbers
    with fewer digits for data values). The specific number for the initial address
    (here 1001) is arbitrary. Subsequent storage of structured data values will use
    the addresses in order. Let‚Äôs write out the directory and heap contents for our
    initial definitions of accounts in this new format, and see how it supports the
    aliasing that we intended.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create both `acct1` and `acct2` in order as follows. Note that the
    `Account` associated with name `acct2` goes in address 1002.
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1001
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1002
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: 1001:¬†`Account(8404, 500)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1002:¬†`Account(8404, 500)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we run
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'what happens? As before, we look up what the name `acct1` refers to in the
    directory and substitute the result for the name in the `Customer` data. Now,
    `acct1` evaluates to an address, 1001\. Therefore, the `Customer` value in the
    heap contains an address:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1001
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1002
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: 1001:¬†`Account(8404, 500)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1002:¬†`Customer("Elena", 1001)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, when we run
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'the directory and heap look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1001
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1002
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1003
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1004
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: 1001:¬†`Account(8404, 500)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1002:¬†`Account(8405, 3250)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1003:¬†`Customer("Elena", 1001)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1004:¬†`Customer("Jorge", 1001)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fun fact in the Web version of the book: Did you try hovering over the addresses?
    Try it now!'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'With the heap articulated separately from the directory, we now see the relationship
    between the `acct` fields for the two customers and the name `acct1`: they refer
    to the same address, which in turn means they refer to the same value. In contrast,
    the name `acct2`, which was not aliased in the original code, refers to an address
    that is not referenced anywhere else. This is the heart of aliasing: that‚Äôs why
    changes made through one name also affect values viewed through another.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write three distinct expressions each of which uses a different name in the
    directory to return the balance in account `acct1`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Would the following statement work to update the balance in Elena and Jorge‚Äôs
    shared account?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Python |  |'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '|  |'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '[PRE210]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Pyret |  |'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '|  |'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '[PRE211]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does this seem like a good or bad way to do this computation? Why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Extend the most recent directory and heap contents to reflect running the following
    statement:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did you change the heap in the previous exercise? Should you have?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Three rules guide how the directory and heap are affected by running programs:'
  prefs: []
  type: TYPE_NORMAL
- en: If the code construct a new piece of structured data, put the new piece of structured
    data at the next address in the heap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the code associates a name with a piece of structured data, the directory
    should map the name to the address of the datum in the heap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the code modifies a field within structured data, modify the data in the
    heap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the example above, we did not alter the heap in any way; only the directory
    should be modified to reflect that `acct3` and `acct1` are now aliases.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1.4.2¬†Basic Data and the Heap[üîó](#(part._basic-data-heap) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The above rules don‚Äôt indicate what happens when we have basic data, such as
    numbers or strings, associated with names in the directory. Do those values also
    get addresses in the heap?
  prefs: []
  type: TYPE_NORMAL
- en: 'They do not. As our example with shared accounts illustrated, we need the heap
    so that updates to fields of shared data affect all aliases (names that refer
    to) those data. Basic data don‚Äôt have fields, so there is no need to put them
    in the heap. Here‚Äôs a concrete example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding directory and heap contents would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE216]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†`"Dr. Kumar"`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Notice that this particular program puts nothing in the heap: according to
    our rules above, only structured data only go into the heap. Now assume our program
    also had a dataclass (Python) or datatype (Pyret) for `Office`s, with a professor‚Äôs
    name and room number. Here‚Äôs another example showing a combination of basic and
    structured data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE220]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†`"Dr. Kumar"`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1005
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1006
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: 1005:¬†`Office("Dr. Lakshmi", 311)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1006:¬†`Office("Dr. Kumar", 314)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though specific language implementations can vary, this shows that it is sufficient
    to think of basic data as residing in the directory, not the heap. The whole point
    of structured data is that they have both their own identity and multiple components.
    The heap gives access to both concepts. Basic data can‚Äôt be broken down (by definition).
    As such, there is nothing lost by putting them only in the directory.
  prefs: []
  type: TYPE_NORMAL
- en: But what about strings? We‚Äôve referred to them as basic data until now, but
    don‚Äôt they have ‚Äúcomponents‚Äù, namely the characters that make up the string? Yes,
    that is technically accurate. However, we are treating strings as basic data because
    we aren‚Äôt using operations that modify that sequence of characters. This is a
    subtle point, one that usually comes up later in computer science. This book will
    leave strings in the directory, but if you are writing programs that modify the
    internal characters, put them in the heap instead.
  prefs: []
  type: TYPE_NORMAL
