<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>3.4Â Conditionals and BooleansğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>3.4Â Conditionals and BooleansğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/Conditionals_and_Booleans.html">https://dcic-world.org/2025-08-27/Conditionals_and_Booleans.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._add-shipping-setup%29" class="toclink" data-pltdoc="x">3.4.1Â Motivating Example: Shipping Costs</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._cond-boolean-intro%29" class="toclink" data-pltdoc="x">3.4.2Â Conditionals: Computations with Decisions</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._booleans%29" class="toclink" data-pltdoc="x">3.4.3Â Booleans</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._bool-comparisons%29" class="toclink" data-pltdoc="x">3.4.3.1Â Other Boolean Operations</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Combining_.Booleans%29" class="toclink" data-pltdoc="x">3.4.3.2Â Combining Booleans</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._else-if%29" class="toclink" data-pltdoc="x">3.4.4Â Asking Multiple Questions</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._conditional-nm%29" class="toclink" data-pltdoc="x">3.4.5Â Evaluating by Reducing Expressions</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Composing_.Functions%29" class="toclink" data-pltdoc="x">3.4.6Â Composing Functions</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.How_.Function_.Compositions_.Evaluate%29" class="toclink" data-pltdoc="x">3.4.6.1Â How Function Compositions Evaluate</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._func-comp-directory%29" class="toclink" data-pltdoc="x">3.4.6.2Â Function Composition and the Directory</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Nested_.Conditionals%29" class="toclink" data-pltdoc="x">3.4.7Â Nested Conditionals</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Recap__.Booleans_and_.Conditionals%29" class="toclink" data-pltdoc="x">3.4.8Â Recap: Booleans and Conditionals</a></p></td></tr></table><section class="SsectionLevel4" id="section 3.4.1"><h4 class="heading">3.4.1Â <a name="(part._add-shipping-setup)"/>Motivating Example: Shipping Costs<a href="#(part._add-shipping-setup)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>In <a href="From_Repeated_Expressions_to_Functions.html#%28part._pen-cost-pyret%29" data-pltdoc="x">Functions Practice: Cost of pens</a>, we wrote a program (<code data-lang="pyret" class="sourceCode">pen-cost</code>) to
compute the cost of ordering pens. Continuing the example, we now want
to account for shipping costs.  Weâ€™ll determine shipping charges based
on the cost of the order.</p><p>Specifically, we will write a function <code data-lang="pyret" class="sourceCode">add-shipping</code> to compute
the total cost of an order including shipping.  Assume an order valued
at $10 or less ships for $4, while an order valued above $10 ships for
$8. As usual, we will start by writing examples of the <code data-lang="pyret" class="sourceCode">add-shipping</code>
computation.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Use the <code data-lang="pyret" class="sourceCode">is</code> notation from <code data-lang="pyret" class="sourceCode">where</code> blocks to write several
examples of add-shipping. How are you choosing which inputs to
use in your examples? Are you picking random inputs? Being strategic
in some way? If so, whatâ€™s your strategy?</p></blockquote></blockquote><p>Here is a proposed collection of examples for <code data-lang="pyret" class="sourceCode">add-shipping</code>.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">add-shipping(10) is 10 + 4
add-shipping(3.95) is 3.95 + 4
add-shipping(20) is 20 + 8
add-shipping(10.01) is 10.01 + 8</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do you notice about our examples? What strategies do you observe
across our choices?</p></blockquote></blockquote><p>Our proposed examples feature several strategic decisions:</p><ul><li><p>Including <code data-lang="pyret" class="sourceCode">10</code>, which is at the boundary of charges based on
the text</p></li><li><p>Including <code data-lang="pyret" class="sourceCode">10.01</code>, which is just over the boundary</p></li><li><p>Including both natural and real (decimal) numbers</p></li><li><p>Including examples that should result in each shipping charge
mentioned in the problem (<code data-lang="pyret" class="sourceCode">4</code> and <code data-lang="pyret" class="sourceCode">8</code>)</p></li></ul><p>So far, we have used a simple rule for creating a function body from
examples: locate the parts that are changing, replace them with names,
then make the names the parameters to the function.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What is changing across our <code data-lang="pyret" class="sourceCode">add-shipping</code> examples? Do you
notice anything different about these changes compared to the examples
for our previous functions?</p></blockquote></blockquote><p>Two things are new in this set of examples:
</p><ul><li><p>The values of <code data-lang="pyret" class="sourceCode">4</code> and <code data-lang="pyret" class="sourceCode">8</code> differ across the
examples, but they each occur in multiple examples.</p></li><li><p>The values of <code data-lang="pyret" class="sourceCode">4</code> and <code data-lang="pyret" class="sourceCode">8</code> appear only in the computed
answersâ€”<wbr/>not as an input. Which one we use seems to depend on the input value.</p></li></ul><p>These two observations suggest that something new is going on with
<code data-lang="pyret" class="sourceCode">add-shipping</code>. In particular, we have clusters of examples that
share a fixed value (the shipping charge), but different clusters (a) use
different values and (b) have a pattern to their inputs (whether the
input value is less than or equal to <code data-lang="pyret" class="sourceCode">10</code>). This calls for being able to
ask questions about inputs within our programs.</p></section><section class="SsectionLevel4" id="section 3.4.2"><h4 class="heading">3.4.2Â <a name="(part._cond-boolean-intro)"/>Conditionals: Computations with Decisions<a href="#(part._cond-boolean-intro)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>To ask a question about our inputs, we use a new kind of expression
called an if expression. Hereâ€™s the full definition of <code data-lang="pyret" class="sourceCode">add-shipping</code>:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun add-shipping(order-amt :: Number) -&gt; Number:
  doc: "add shipping costs to order total"
  if order-amt &lt;= 10:
    order-amt + 4
  else:
    order-amt + 8
  end
where:
  add-shipping(10) is 10 + 4
  add-shipping(3.95) is 3.95 + 4
  add-shipping(20) is 20 + 8
  add-shipping(10.01) is 10.01 + 8
end</code></pre><p>In an <code data-lang="pyret" class="sourceCode">if</code> expression, we ask a question that can produce an answer that
is true or false
(here <code data-lang="pyret" class="sourceCode">order-amt &lt;= 10</code>, which weâ€™ll explain below in
<a href="#%28part._booleans%29" data-pltdoc="x">Booleans</a>), provide one expression for
when the answer to the question is true (<code data-lang="pyret" class="sourceCode">order-amt + 4</code>), and
another for when the result is false (<code data-lang="pyret" class="sourceCode">order-amt +
8</code>). The <code data-lang="pyret" class="sourceCode">else</code> in the program marks the answer in the false case; we call
this the else clause.
We also need <code data-lang="pyret" class="sourceCode">end</code> to tell Pyret weâ€™re done with the question and answers.</p></section><section class="SsectionLevel4" id="section 3.4.3"><h4 class="heading">3.4.3Â <a name="(part._booleans)"/>Booleans<a href="#(part._booleans)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Every expression in Pyret evaluates in a value. So far, we have seen
three types of values: <code data-lang="pyret" class="sourceCode">Number</code>, <code data-lang="pyret" class="sourceCode">String</code>, and
<code data-lang="pyret" class="sourceCode">Image</code>. What type of value does a question like <code data-lang="pyret" class="sourceCode">order-amt
&lt;= 10</code> produce? We can use the interactions prompt to experiment and
find out.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Enter each of the following expressions at the interactions
prompt. What type of value did you get? Do the values fit the types
we have seen so far?
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3.95 &lt;= 10
20 &lt;= 10</code></pre></blockquote></blockquote><p>The values <code data-lang="pyret" class="sourceCode">true</code> and <code data-lang="pyret" class="sourceCode">false</code> belong to a new type in Pyret,
called <code data-lang="pyret" class="sourceCode">Boolean</code>.Named for <a href="https://en.wikipedia.org/wiki/George_Boole">George Boole</a>. While
there are an infinitely many values of type <code data-lang="pyret" class="sourceCode">Number</code>, there are
only two of type <code data-lang="pyret" class="sourceCode">Boolean</code>: <code data-lang="pyret" class="sourceCode">true</code> and <code data-lang="pyret" class="sourceCode">false</code>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>What would happen if we entered <code data-lang="pyret" class="sourceCode">order-amt &lt;= 10</code> at the interactions prompt
to explore booleans? Why does that happen?</p></blockquote></blockquote><section class="SsectionLevel5" id="section 3.4.3.1"><h5 class="heading">3.4.3.1Â <a name="(part._bool-comparisons)"/>Other Boolean Operations<a href="#(part._bool-comparisons)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>There are many other built-in operations that return <code data-lang="pyret" class="sourceCode">Boolean</code>
values. Comparing values for equality is a common one: There is
much more we can and should say about equality, which we will do later
[<a href="Sharing_and_Equality.html#%28part._identical-eq%29" data-pltdoc="x">Re-Examining Equality</a>].</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1 == 1</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1 == 2</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"cat" == "dog"</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"cat" == "CAT"</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><p>In general, <code data-lang="pyret" class="sourceCode">==</code> checks whether two values are equal. Note this
is different from the single <code data-lang="pyret" class="sourceCode">=</code> used to associate names with
values in the directory.</p><p>The last example is the most interesting: it illustrates that strings
are case-sensitive, meaning individual letters must match in
their case for strings to be considered equal.This will
become relevant when we get to tables later.</p><p>Sometimes, we also want to compare strings to determine their
alphabetical order. Here are several examples:
</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"a" &lt; "b"</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"a" &gt;= "c"</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"that" &lt; "this"</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"alpha" &lt; "beta"</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><p>which is the alphabetical order weâ€™re used to;
but others need some explaining:
</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"a" &gt;= "C"</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"a" &gt;= "A"</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><p>These use a convention laid down a long time ago in a system called
<a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a>.Things
get far more complicated with non-ASCII letters: e.g., Pyret thinks <code data-lang="pyret" class="sourceCode">"Å"</code>
is <code data-lang="pyret" class="sourceCode">&gt;</code> than <code data-lang="pyret" class="sourceCode">"Z"</code>,
but in Polish, this should be <code data-lang="pyret" class="sourceCode">false</code>. Worse, the ordering
<a href="https://en.wikipedia.org/wiki/Alphabetical_order">depends on
location</a> (e.g., Denmark/Norway vs. Finland/Sweden).</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Can you compare <code data-lang="pyret" class="sourceCode">true</code> and <code data-lang="pyret" class="sourceCode">false</code>? Try comparing them for
equality (<code data-lang="pyret" class="sourceCode">==</code>), then for inequality (such as <code data-lang="pyret" class="sourceCode">&lt;</code>).</p></blockquote></blockquote><p>In general, you can compare any two values for equality (well, almost,
weâ€™ll come back to this later); for instance:
</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"a" == 1</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><p>If you want to compare values of a specific kind, you can use more
specific operators:
</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-equal(1, 1)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-equal(1, 2)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-equal("a", "a")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-equal("a", "b")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><p>Why use these operators instead of the more generic <code data-lang="pyret" class="sourceCode">==</code>?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Try
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-equal("a", 1)
string-equal("a", 1)</code></pre></blockquote></blockquote><p>Therefore, itâ€™s wise to use the type-specific operators where youâ€™re expecting
the two arguments to be of the same type. Then, Pyret will signal an error if
you go wrong, instead of blindly returning an answer (<code data-lang="pyret" class="sourceCode">false</code>) which lets
your program continue to compute a nonsensical value.</p><p>There are even more Boolean-producing operators, such as:
</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">wm = "will.i.am"</code></pre></blockquote></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-contains(wm, "will")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><p>Note the capital <code data-lang="pyret" class="sourceCode">W</code>.
</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-contains(wm, "Will")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><p>In fact, just about every kind of data will have some Boolean-valued
operators to enable comparisons.</p></section><section class="SsectionLevel5" id="section 3.4.3.2"><h5 class="heading">3.4.3.2Â <a name="(part._.Combining_.Booleans)"/>Combining Booleans<a href="#(part._.Combining_.Booleans)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Often, we want to base decisions on more than one Boolean value. For
instance, you are allowed to vote if youâ€™re a citizen of a country
and you are above a certain age. Youâ€™re allowed to board a bus
if you have a ticket or the bus is having a free-ride day. We
can even combine conditions: youâ€™re allowed to drive if you are above
a certain age and have good eyesight andâ€”<wbr/>either
pass a test or have a temporary license. Also, youâ€™re allowed
to drive if you are not inebriated.</p><p>Corresponding to these forms of combinations, Pyret offers three main
operations: <code data-lang="pyret" class="sourceCode">and</code>, <code data-lang="pyret" class="sourceCode">or</code>, and <code data-lang="pyret" class="sourceCode">not</code>. Here are some
examples of their use:
</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">(1 &lt; 2) and (2 &lt; 3)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">(1 &lt; 2) and (3 &lt; 2)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">(1 &lt; 2) or (2 &lt; 3)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">(3 &lt; 2) or (1 &lt; 2)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">not(1 &lt; 2)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Explain why numbers and strings are not good ways to express the
answer to a true/false question.</p></blockquote></blockquote></section></section><section class="SsectionLevel4" id="section 3.4.4"><h4 class="heading">3.4.4Â <a name="(part._else-if)"/>Asking Multiple Questions<a href="#(part._else-if)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Shipping costs are rising, so we want to modify the
<code data-lang="pyret" class="sourceCode">add-shipping</code> program to include a third shipping level: orders
between $10 and $30 ship for $8, but orders over $30 ship for $12. This
calls for two modifications to our program:
</p><ul><li><p>We have to be able to ask another question to distinguish
situations in which the shipping charge is <code data-lang="pyret" class="sourceCode">8</code> from those
in which the shipping charge is <code data-lang="pyret" class="sourceCode">12</code>.</p></li><li><p>The question for when the shipping charge is <code data-lang="pyret" class="sourceCode">8</code> will need
to check whether the input is between two values.</p></li></ul><p>Weâ€™ll handle these in order.</p><p>The current body of <code data-lang="pyret" class="sourceCode">add-shipping</code> asks one question:
<code data-lang="pyret" class="sourceCode">order-amt &lt;= 10</code>. We need to add another one for <code data-lang="pyret" class="sourceCode">order-amt
&lt;= 30</code>, using a charge of <code data-lang="pyret" class="sourceCode">12</code> if that question fails. Where do
we put that additional question?</p><p>An expanded version of the if-expression, using <code data-lang="pyret" class="sourceCode">else if</code>, allows
you to ask multiple questions:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun add-shipping(order-amt :: Number) -&gt; Number:
  doc: "add shipping costs to order total"
  if order-amt &lt;= 10:
    order-amt + 4
  else if order-amt &lt;= 30:
    order-amt + 8
  else:
    order-amt + 12
  end
where:
  ...
end</code></pre><p>At this point, you should also add <code data-lang="pyret" class="sourceCode">where</code> examples that use the
<code data-lang="pyret" class="sourceCode">12</code> charge.</p><p>How does Pyret determine which answer to return? It evaluates each
question expression in order, starting from the one that follows
<code data-lang="pyret" class="sourceCode">if</code>. It continues through the questions, returning the value of
the answer of the first question that returns true. Hereâ€™s a summary
of the if-expression syntax and how it evaluates.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if QUESTION1:
  &lt;result in case first question true&gt;
else if QUESTION2:
  &lt;result in case QUESTION1 false and QUESTION2 true&gt;
else:
  &lt;result in case both QUESTIONs false&gt;
end</code></pre><p>A program can have multiple <code data-lang="pyret" class="sourceCode">else if</code> cases, thus accommodating
an arbitrary number of questions within a program.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>The problem description for <code data-lang="pyret" class="sourceCode">add-shipping</code> said that orders
between <code data-lang="pyret" class="sourceCode">10</code> and <code data-lang="pyret" class="sourceCode">30</code> should incur an <code data-lang="pyret" class="sourceCode">8</code> charge. How
does the above code capture â€œbetweenâ€?</p></blockquote></blockquote><p>This is currently entirely implicit. It depends on us understanding the way an
<code data-lang="pyret" class="sourceCode">if</code> evaluates. The first question is <code data-lang="pyret" class="sourceCode">order-amt &lt;= 10</code>, so if we
continue to the second question, it means <code data-lang="pyret" class="sourceCode">order-amt &gt; 10</code>. In this
context, the second question asks whether <code data-lang="pyret" class="sourceCode">order-amt &lt;= 30</code>. Thatâ€™s how
weâ€™re capturing â€œbetweenâ€-ness.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How might you modify the above code to build the â€œbetween 10 and 30â€
requirement explicitly into the question for the <code data-lang="pyret" class="sourceCode">8</code> case?</p></blockquote></blockquote><p>Remember the <code data-lang="pyret" class="sourceCode">and</code> operator on booleans? We can use that to
capture â€œbetweenâ€ relationships, as follows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">(order-amt &gt; 10) and (order-amt &lt;= 30)</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Why are there parentheses around the two comparisons? If you replace
<code data-lang="pyret" class="sourceCode">order-amt</code> with a concrete value (such as <code data-lang="pyret" class="sourceCode">20</code>) and leave
off the parenthesis, what happens when you evaluate this expression in
the interactions pane?</p></blockquote></blockquote><p>Here is what <code data-lang="pyret" class="sourceCode">add-shipping</code> look like with the <code data-lang="pyret" class="sourceCode">and</code> included:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun add-shipping(order-amt :: Number) -&gt; Number:
  doc: "add shipping costs to order total"
  if order-amt &lt;= 10:
    order-amt + 4
  else if (order-amt &gt; 10) and (order-amt &lt;= 30):
    order-amt + 8
  else:
    order-amt + 12
  end
where:
  add-shipping(10) is 10 + 4
  add-shipping(3.95) is 3.95 + 4
  add-shipping(20) is 20 + 8
  add-shipping(10.01) is 10.01 + 8
  add-shipping(30) is 30 + 8
  add-shipping(32) is 32 + 12
end</code></pre><p>Both versions of <code data-lang="pyret" class="sourceCode">add-shipping</code> support the same examples. Are
both correct? Yes. And while the first part of the second question
(<code data-lang="pyret" class="sourceCode">order-amt &gt; 10</code>) is redundant, it can be helpful to include such
conditions for three reasons:
</p><ol><li><p>They signal to future readers (including ourselves!) the condition
covering a case.</p></li><li><p>They ensure that if we make a mistake in writing an earlier question, we
wonâ€™t silently get surprising output.</p></li><li><p>They guard against future modifications, where someone might modify an
earlier question without realizing the impact itâ€™s having on a later one.</p></li></ol><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>An online-advertising firm needs to determine whether to show an ad
for a skateboarding park to website users. Write a function <code data-lang="pyret" class="sourceCode">show-ad</code>
that takes the age and haircolor of an individual user and returns
<code data-lang="pyret" class="sourceCode">true</code> if the user is between the ages of <code data-lang="pyret" class="sourceCode">9</code> and <code data-lang="pyret" class="sourceCode">18</code>
and has either pink or purple hair.</p><p>Try writing this two ways: once with <code data-lang="pyret" class="sourceCode">if</code> expressions and once
using just boolean operations.</p></blockquote></blockquote><blockquote class="RespCS"><p class="RespCSHeader">Responsible Computing: Harms from Reducing People to Simple Data</p><blockquote class="RespCSBody"><p>Assumptions about users get encoded in even the simplest
functions. The advertising exercise shows an example in which a decision
gets made on the basis of two pieces of information about a person: age
and haircolor. While some people might stereotypically associate
skateborders with being young and having colored hair, many
skateborders do not fit these criteria and many people who fit these
criteria donâ€™t skateboard.</p><p>While real programs to match ads to users are more sophisticated than
this simple function, even the most sophisticated advertising programs
boil down to tracking features or information about individuals and
comparing it to information about the content of ads. A real ad system
would differ in tracking dozens (or more) of features and using more
advanced programming ideas than simple conditionals to determine the
suitability of an ad (weâ€™ll discuss some of these later in the
book). This example also extends to situations far more serious than
ads: who gets hired, granted a bank loan, or <a href="https://www.propublica.org/article/machine-bias-risk-assessments-in-criminal-sentencing">sent to or released from
jail</a> are other examples of real systems that depend on comparing data
about individuals with criteria maintained by a program.</p><p>From a social responsibility perspective, the questions here are
what data about individuals should be used to represent them for
processing by programs and what stereotypes might those data
encode. In some cases, individuals can be represented by data without
harm (a university housing office, for examples, stores student ID
numbers and which room a student is living in). But in other cases,
data about individuals get interpreted in order to predict something
about them. Decisions based on those predictions can be inaccurate and
hence harmful.</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 3.4.5"><h4 class="heading">3.4.5Â <a name="(part._conditional-nm)"/>Evaluating by Reducing Expressions<a href="#(part._conditional-nm)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>In <a href="From_Repeated_Expressions_to_Functions.html#%28part._function-call-nm%29" data-pltdoc="x">How Functions Evaluate</a>, we talked about how Pyret reduces expressions and
function calls to values. Letâ€™s revisit this process, this time
expanding to consider if-expressions. Suppose we want
to compute the wages of a worker. The worker is paid $10 for every
hour up to the first 40 hours, and is paid $15 for every extra
hour. Letâ€™s say <code data-lang="pyret" class="sourceCode">hours</code> contains the number of hours they work,
and suppose itâ€™s <code data-lang="pyret" class="sourceCode">45</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">hours = 45</code></pre><p>Suppose the formula for computing the wage is
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if hours &lt;= 40:
  hours * 10
else if hours &gt; 40:
  (40 * 10) + ((hours - 40) * 15)
end</code></pre><p>Letâ€™s now see how this results in an answer, using a step-by-step
process that should match what youâ€™ve seen in algebra
classes (the steps are described in the margin notes to the right):
The first step is to substitute the
<code data-lang="pyret" class="sourceCode">hours</code> with <code data-lang="pyret" class="sourceCode">45</code>.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if 45 &lt;= 40:
  45 * 10
else if 45 &gt; 40:
  (40 * 10) + ((45 - 40) * 15)
end</code></pre><p>Next, the conditional part of the <code data-lang="pyret" class="sourceCode">if</code> expression is evaluated,
which in this case is <code data-lang="pyret" class="sourceCode">false</code>.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  if false:
      45 * 10
    else if 45 &gt; 40:
      (40 * 10) + ((45 - 40) * 15)
    end</code></pre><p>Since the condition is <code data-lang="pyret" class="sourceCode">false</code>, the next branch is tried.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  if 45 &gt; 40:
      (40 * 10) + ((45 - 40) * 15)
    end</code></pre><p>Pyret evaluates the question in the conditional, which in this case produces <code data-lang="pyret" class="sourceCode">true</code>.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  if true:
      (40 * 10) + ((45 - 40) * 15)
    end</code></pre><p>Since the condition is <code data-lang="pyret" class="sourceCode">true</code>, the expression reduces to the body
of that branch.  After that, itâ€™s just arithmetic.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  (40 * 10) + ((45 - 40) * 15)</code></pre><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  400 + (5 * 15)
=&gt;  475</code></pre><p>This style of reduction is the best way to think about the evaluation
of Pyret expressions. The whole expression takes steps that simplify
it, proceeding by simple rules. You can use this style yourself if you
want to try and work through the evaluation of a Pyret program by hand
(or in your head).</p></section><section class="SsectionLevel4" id="section 3.4.6"><h4 class="heading">3.4.6Â <a name="(part._.Composing_.Functions)"/>Composing Functions<a href="#(part._.Composing_.Functions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>We started this chapter wanting to account for shipping costs on an
order of pens. So far, we have written two functions:
</p><ul><li><p><code data-lang="pyret" class="sourceCode">pen-cost</code> for computing the cost of the pens</p></li><li><p><code data-lang="pyret" class="sourceCode">add-shipping</code> for adding shipping costs to a total amount</p></li></ul><p>What if we now wanted to compute the price of an order of pens
including shipping? We would have to use both of these functions
together, sending the output of <code data-lang="pyret" class="sourceCode">pen-cost</code> to the input of
<code data-lang="pyret" class="sourceCode">add-shipping</code>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write an expression that computes the total cost, with shipping, of an
order of <code data-lang="pyret" class="sourceCode">10</code> pens that say <code data-lang="pyret" class="sourceCode">"bravo"</code>.</p></blockquote></blockquote><p>There are two ways to structure this computation. We could pass the
result of <code data-lang="pyret" class="sourceCode">pen-cost</code> directly to <code data-lang="pyret" class="sourceCode">add-shipping</code>:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">add-shipping(pen-cost(10, "bravo"))</code></pre><p>Alternatively, you might have named the result of <code data-lang="pyret" class="sourceCode">pen-cost</code> as
an intermediate step:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pens = pen-cost(10, "bravo")
add-shipping(pens)</code></pre><p>Both methods would produce the same answer.</p><section class="SsectionLevel5" id="section 3.4.6.1"><h5 class="heading">3.4.6.1Â <a name="(part._.How_.Function_.Compositions_.Evaluate)"/>How Function Compositions Evaluate<a href="#(part._.How_.Function_.Compositions_.Evaluate)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Letâ€™s review how these programs evaluate in the context of
substitution and the directory. Weâ€™ll start with the second
version, in which we explicitly name the result of calling
<code data-lang="pyret" class="sourceCode">pen-cost</code>.</p><p>Evaluating the second version: At a high level, Pyret goes
through the following steps:</p><ul><li><p>Substitute <code data-lang="pyret" class="sourceCode">10</code> for <code data-lang="pyret" class="sourceCode">num-pens</code> and <code data-lang="pyret" class="sourceCode">"bravo"</code> for
<code data-lang="pyret" class="sourceCode">message</code> in the body of <code data-lang="pyret" class="sourceCode">pen-cost</code>, then evaluate the
substituted body</p></li><li><p>Store <code data-lang="pyret" class="sourceCode">pens</code> in the directory, with a value of <code data-lang="pyret" class="sourceCode">3.5</code></p></li><li><p>As a first step in evaluating <code data-lang="pyret" class="sourceCode">add-shipping(pens)</code>, look up
the value of <code data-lang="pyret" class="sourceCode">pens</code> in the directory</p></li><li><p>Substitute <code data-lang="pyret" class="sourceCode">3.5</code> for <code data-lang="pyret" class="sourceCode">order-amt</code> in the body of
<code data-lang="pyret" class="sourceCode">add-shipping</code> then evaluate the resulting expression, which
results in <code data-lang="pyret" class="sourceCode">7.5</code></p></li></ul><p>Evaluating the first version: As a reminder, the first version
consisted of a single expression:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">add-shipping(pen-cost(10, "bravo"))</code></pre><ul><li><p>Since arguments are evaluated before functions get called,
start by evaluating <code data-lang="pyret" class="sourceCode">pen-cost(10, "bravo")</code> (again using
substitution), which reduces to <code data-lang="pyret" class="sourceCode">3.5</code></p></li><li><p>Substitute <code data-lang="pyret" class="sourceCode">3.5</code> for <code data-lang="pyret" class="sourceCode">order-amt</code> in the body of
<code data-lang="pyret" class="sourceCode">add-shipping</code> then evaluate the resulting expression, which
results in <code data-lang="pyret" class="sourceCode">7.5</code></p></li></ul><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Contrast these two summaries. Where do they differ? What aspects of the
code led to those differences?</p></blockquote></blockquote><p>The difference lies in the use of the directory: the version that
explicitly named <code data-lang="pyret" class="sourceCode">pens</code> uses the directory. The other version
doesnâ€™t use the directory at all. Yet both approaches lead to the same
result, since the same value (the result of calling <code data-lang="pyret" class="sourceCode">pen-cost</code>)
gets substituted into the body of <code data-lang="pyret" class="sourceCode">add-shipping</code>.</p><p>This analysis might suggest that the version that uses the directory
is somehow wasteful: it seems to take more steps just to end up at the
same result. Yet one might argue that the version that uses the
directory is easier to read (different readers will have different
opinions on this, and thatâ€™s fine). So which should we use?</p><p>Use whichever makes more sense to you on a given problem. There will
be times when we prefer each of these styles. Furthermore, it will
turn out (once weâ€™ve learned more about nuances of how programs
evaluate) that the two versions arenâ€™t as different as they appear
right now.</p></section><section class="SsectionLevel5" id="section 3.4.6.2"><h5 class="heading">3.4.6.2Â <a name="(part._func-comp-directory)"/>Function Composition and the Directory<a href="#(part._func-comp-directory)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Letâ€™s try one more variation on this problem. Perhaps seeing us name
the intermediate result of <code data-lang="pyret" class="sourceCode">pen-cost</code> made you wish that we had
used intermediate names to make the body of <code data-lang="pyret" class="sourceCode">pen-cost</code> more
readable. For example, we could have written it as:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pen-cost(num-pens :: Number, message :: String)
  -&gt; Number:
  doc: ```total cost for pens, each 25 cents
       plus 2 cents per message character```
  message-cost = (string-length(message) * 0.02)
  num-pens * (0.25 + message-cost)
where:
  ...
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write out the high level steps for how Pyret will evaluate
the following program using this new version of <code data-lang="pyret" class="sourceCode">pen-cost</code>:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pens = pen-cost(10, "bravo")
add-shipping(pens)</code></pre></blockquote></blockquote><p>Hopefully, you made two entries into the directory, one for
<code data-lang="pyret" class="sourceCode">message-cost</code> inside the body of <code data-lang="pyret" class="sourceCode">pen-cost</code> and one for
<code data-lang="pyret" class="sourceCode">pens</code> as we did earlier.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Consider the following program. What result do you think
Pyret should produce?</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pens = pen-cost(10, "bravo")
cheap-message = (message-cost &gt; 0.5)
add-shipping(pens)</code></pre><p>Using the directory you envisioned for the previous activity, what
answer do you think you will get?</p></blockquote></blockquote><p>Something odd is happening here. The new program tries to use
<code data-lang="pyret" class="sourceCode">message-cost</code> to define <code data-lang="pyret" class="sourceCode">cheap-message</code>. But the name
<code data-lang="pyret" class="sourceCode">message-cost</code> doesnâ€™t appear anywhere in the program, unless we
peek inside the function bodies. But letting code peek inside function
bodies doesnâ€™t make sense: you might not be able to see inside the
functions (if they are defined in libraries, for example), so this
program should report an error that <code data-lang="pyret" class="sourceCode">message-cost</code> is undefined.</p><p>Okay, so thatâ€™s what should happen. But our discussion of the
directory suggests that both <code data-lang="pyret" class="sourceCode">pens</code> and <code data-lang="pyret" class="sourceCode">message-cost</code> will
be in the directory, meaning Pyret would be able to use
<code data-lang="pyret" class="sourceCode">message-cost</code>. Whatâ€™s going on?</p><p>This example prompts us to explain one more nuance about the
directory. Precisely to avoid problems like the one illustrated here
(which should produce an error), directory entries made within a
function are local (private) to the function body. When you call a function,
Pyret sets up a local directory that other functions canâ€™t
see. A function body can add or refer to names in either its local,
private directory (as with <code data-lang="pyret" class="sourceCode">message-cost</code>) or the overall
(global) directory (as with <code data-lang="pyret" class="sourceCode">pens</code>). But in no case can one
function call peek inside the local directory for another function
call. Once a function call completes, its local directory disappears
(because nothing else would be able to use it anyway).</p></section></section><section class="SsectionLevel4" id="section 3.4.7"><h4 class="heading">3.4.7Â <a name="(part._.Nested_.Conditionals)"/>Nested Conditionals<a href="#(part._.Nested_.Conditionals)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>We showed that the results in <code data-lang="pyret" class="sourceCode">if</code>-expressions are themselves
expressions (such as <code data-lang="pyret" class="sourceCode">order-amt + 4</code> in the following function):</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun add-shipping(order-amt :: Number) -&gt; Number:
  doc: "add shipping costs to order total"
  if order-amt &lt;= 10:
    order-amt + 4
  else:
    order-amt + 8
  end
end</code></pre><p>The result expressions can be more complicated. In fact, they could be
entire if-expressions!. To see an example of this, letâ€™s develop
another function. This time, we want a function that will compute the
cost of movie tickets. Letâ€™s start with a simple version in which
tickets are <code data-lang="pyret" class="sourceCode">$10</code> apiece.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun buy-tickets1(count :: Number) -&gt; Number:
  doc: "Compute the price of tickets at $10 each"
  count * 10
where:
  buy-tickets1(0) is 0
  buy-tickets1(2) is 2 * 10
  buy-tickets1(6) is 6 * 10
end</code></pre><p>Now, letâ€™s augment the function with an extra parameter to indicate
whether the purchaser is a senior citizen who is entitled to a discount. In such cases, we will reduce the overall price by
<code data-lang="pyret" class="sourceCode">15%</code>.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun buy-tickets2(count :: Number, is-senior :: Boolean)
  -&gt; Number:
  doc: ```Compute the price of tickets at $10 each with
       senior discount of 15%```
  if is-senior == true:
    count * 10 * 0.85
  else:
    count * 10
  end
where:
  buy-tickets2(0, false) is 0
  buy-tickets2(0, true) is 0
  buy-tickets2(2, false) is 2 * 10
  buy-tickets2(2, true) is 2 * 10 * 0.85
  buy-tickets2(6, false) is 6 * 10
  buy-tickets2(6, true) is 6 * 10 * 0.85
end</code></pre><p>There are a couple of things to notice here:
</p><ul><li><p>The function now has an additional parameter of type
<code data-lang="pyret" class="sourceCode">Boolean</code> to indicate whether the purchaser is a senior citizen.</p></li><li><p>We have added an <code data-lang="pyret" class="sourceCode">if</code> expression to check whether to
apply the discount.</p></li><li><p>We have more examples, because we have to vary both the number
of tickets and whether a discount applies.</p></li></ul><p>Now, letâ€™s extend the program once more, this time also offering the
discount if the purchaser is not a senior but has bought more than 5 tickets. Where should
we modify the code to do this? One option is to first check whether
the senior discount applies. If not, we check whether the number of
tickets qualifies for a discount:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun buy-tickets3(count :: Number, is-senior :: Boolean)
  -&gt; Number:
  doc: ```Compute the price of tickets at $10 each with
       discount of 15% for more than 5 tickets
       or being a senior```
  if is-senior == true:
    count * 10 * 0.85
  else:
    if count &gt; 5:
      count * 10 * 0.85
    else:
      count * 10
    end
  end
where:
  buy-tickets3(0, false) is 0
  buy-tickets3(0, true) is 0
  buy-tickets3(2, false) is 2 * 10
  buy-tickets3(2, true) is 2 * 10 * 0.85
  buy-tickets3(6, false) is 6 * 10 * 0.85
  buy-tickets3(6, true) is 6 * 10 * 0.85
end</code></pre><p>Notice here that we have put a second <code data-lang="pyret" class="sourceCode">if</code> expression within the
<code data-lang="pyret" class="sourceCode">else</code> case. This is valid code. (We could have also made an
<code data-lang="pyret" class="sourceCode">else if</code> here, but we didnâ€™t so that we could show that nested
conditionals are also valid).</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Show the steps through which this function would evaluate in
a situation where no discount applies, such as <code data-lang="pyret" class="sourceCode">buy-tickets3(2,
false)</code>.</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Look at the current code: do you see a repeated computation
that we might end up having to modify later?</p></blockquote></blockquote><p>Part of good code style is making sure that our programs would be easy
to maintain later. If the theater changes its discount policy, for
example, the current code would require us to change the discount
(<code data-lang="pyret" class="sourceCode">0.85</code>) in two places. It would be much better to have that
computation written only one time. We can achieve that by asking which
conditions lead to the discount applying, and writing them as the
check within just one <code data-lang="pyret" class="sourceCode">if</code> expression.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Under what conditions should the discount apply?</p></blockquote></blockquote><p>Here, we see that the discount applies if either the purchaser is a
senior or more than 5 tickets have been bought. We can therefore
simplify the code by using <code data-lang="pyret" class="sourceCode">or</code> as follows (weâ€™ve left out the
examples because they havenâ€™t changed from the previous version):</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun buy-tickets4(count :: Number, is-senior :: Boolean)
  -&gt; Number:
  doc: ```Compute the price of tickets at $10 each with
       discount of 15% for more than 5 tickets
       or being a senior```
  if (is-senior == true) or (count &gt; 5):
    count * 10 * 0.85
  else:
    count * 10
  end
end</code></pre><p>This code is much tighter, and all of the cases where the discount
applies are described together in one place. There are still two small
changes we want to make to really clean this up though.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Take a look at the expression <code data-lang="pyret" class="sourceCode">is-senior == true</code>. What will this
evaluate to when the value of <code data-lang="pyret" class="sourceCode">is-senior</code> is <code data-lang="pyret" class="sourceCode">true</code>? What
will it evaluate to when the value of <code data-lang="pyret" class="sourceCode">is-senior</code> is <code data-lang="pyret" class="sourceCode">false</code>?</p></blockquote></blockquote><p>Notice that the <code data-lang="pyret" class="sourceCode">== true</code> part is redundant. Since
<code data-lang="pyret" class="sourceCode">is-senior</code> is already a boolean, we can check its value without
using the <code data-lang="pyret" class="sourceCode">==</code> operator. Hereâ€™s the revised code:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun buy-tickets5(count :: Number, is-senior :: Boolean)
  -&gt; Number:
  doc: ```Compute the price of tickets at $10 each with
       discount of 15% for more than 5 tickets
       or being a senior```
  if is-senior or (count &gt; 5):
    count * 10 * 0.85
  else:
    count * 10
  end
end</code></pre><p>Notice the revised question in the <code data-lang="pyret" class="sourceCode">if</code> expression. As a general
rule, your code should never include <code data-lang="pyret" class="sourceCode">== true</code>. You can always
take that out and just use the expression you were comparing to
<code data-lang="pyret" class="sourceCode">true</code>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do you write to eliminate <code data-lang="pyret" class="sourceCode">== false</code>? For example, what
might you write instead of <code data-lang="pyret" class="sourceCode">is-senior == false</code>?</p></blockquote></blockquote><p>Finally, notice that we still have one repeated computation: the base
cost of the tickets (<code data-lang="pyret" class="sourceCode">count * 10</code>): if the ticket price changes,
it would be better to have only one place to update that price. We can
clean that up by first computing the base price, then applying the
discount when appropriate:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun buy-tickets6(count :: Number, is-senior :: Boolean)
  -&gt; Number:
  doc: ```Compute the price of tickets at $10 each with
       discount of 15% for more than 5 tickets
       or being a senior```
  base = count * 10
  if is-senior or (count &gt; 5):
    base * 0.85
  else:
    base
  end
end</code></pre></section><section class="SsectionLevel4" id="section 3.4.8"><h4 class="heading">3.4.8Â <a name="(part._.Recap__.Booleans_and_.Conditionals)"/>Recap: Booleans and Conditionals<a href="#(part._.Recap__.Booleans_and_.Conditionals)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>With this chapter, our computations can produce different results in
different situations. We ask questions using if-expressions, in
which each question or check uses an operator that produces a
boolean.</p><ul><li><p>There are two Boolean values: <code data-lang="pyret" class="sourceCode">true</code> and <code data-lang="pyret" class="sourceCode">false</code>.</p></li><li><p>A simple kind of check (that produces a boolean) compares values for equality (<code data-lang="pyret" class="sourceCode">==</code>)
or inequality(<code data-lang="pyret" class="sourceCode">&lt;&gt;</code>). Other operations that you know from math,
like <code data-lang="pyret" class="sourceCode">&lt;</code> and <code data-lang="pyret" class="sourceCode">&gt;=</code>, also produce booleans.</p></li><li><p>We can build larger expressions that produce booleans from smaller ones using
the operators <code data-lang="pyret" class="sourceCode">and</code>, <code data-lang="pyret" class="sourceCode">or</code>, <code data-lang="pyret" class="sourceCode">not</code>.</p></li><li><p>We can use <code data-lang="pyret" class="sourceCode">if</code> expressions to ask true/false questions
within a computation, producing different results in each case.</p></li><li><p>We can nest conditionals inside one another if needed.</p></li><li><p>You never need to use <code data-lang="pyret" class="sourceCode">==</code> to compare a value to
<code data-lang="pyret" class="sourceCode">true</code> or <code data-lang="pyret" class="sourceCode">false</code>: you can just write the value or
expression on its own (perhaps with <code data-lang="pyret" class="sourceCode">not</code> to get the same computation).</p></li></ul></section>&#13;
<h4 class="heading">3.4.1Â <a name="(part._add-shipping-setup)"/>Motivating Example: Shipping Costs<a href="#(part._add-shipping-setup)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>In <a href="From_Repeated_Expressions_to_Functions.html#%28part._pen-cost-pyret%29" data-pltdoc="x">Functions Practice: Cost of pens</a>, we wrote a program (<code data-lang="pyret" class="sourceCode">pen-cost</code>) to
compute the cost of ordering pens. Continuing the example, we now want
to account for shipping costs.  Weâ€™ll determine shipping charges based
on the cost of the order.</p><p>Specifically, we will write a function <code data-lang="pyret" class="sourceCode">add-shipping</code> to compute
the total cost of an order including shipping.  Assume an order valued
at $10 or less ships for $4, while an order valued above $10 ships for
$8. As usual, we will start by writing examples of the <code data-lang="pyret" class="sourceCode">add-shipping</code>
computation.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Use the <code data-lang="pyret" class="sourceCode">is</code> notation from <code data-lang="pyret" class="sourceCode">where</code> blocks to write several
examples of add-shipping. How are you choosing which inputs to
use in your examples? Are you picking random inputs? Being strategic
in some way? If so, whatâ€™s your strategy?</p></blockquote></blockquote><p>Here is a proposed collection of examples for <code data-lang="pyret" class="sourceCode">add-shipping</code>.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">add-shipping(10) is 10 + 4
add-shipping(3.95) is 3.95 + 4
add-shipping(20) is 20 + 8
add-shipping(10.01) is 10.01 + 8</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do you notice about our examples? What strategies do you observe
across our choices?</p></blockquote></blockquote><p>Our proposed examples feature several strategic decisions:</p><ul><li><p>Including <code data-lang="pyret" class="sourceCode">10</code>, which is at the boundary of charges based on
the text</p></li><li><p>Including <code data-lang="pyret" class="sourceCode">10.01</code>, which is just over the boundary</p></li><li><p>Including both natural and real (decimal) numbers</p></li><li><p>Including examples that should result in each shipping charge
mentioned in the problem (<code data-lang="pyret" class="sourceCode">4</code> and <code data-lang="pyret" class="sourceCode">8</code>)</p></li></ul><p>So far, we have used a simple rule for creating a function body from
examples: locate the parts that are changing, replace them with names,
then make the names the parameters to the function.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What is changing across our <code data-lang="pyret" class="sourceCode">add-shipping</code> examples? Do you
notice anything different about these changes compared to the examples
for our previous functions?</p></blockquote></blockquote><p>Two things are new in this set of examples:
</p><ul><li><p>The values of <code data-lang="pyret" class="sourceCode">4</code> and <code data-lang="pyret" class="sourceCode">8</code> differ across the
examples, but they each occur in multiple examples.</p></li><li><p>The values of <code data-lang="pyret" class="sourceCode">4</code> and <code data-lang="pyret" class="sourceCode">8</code> appear only in the computed
answersâ€”<wbr/>not as an input. Which one we use seems to depend on the input value.</p></li></ul><p>These two observations suggest that something new is going on with
<code data-lang="pyret" class="sourceCode">add-shipping</code>. In particular, we have clusters of examples that
share a fixed value (the shipping charge), but different clusters (a) use
different values and (b) have a pattern to their inputs (whether the
input value is less than or equal to <code data-lang="pyret" class="sourceCode">10</code>). This calls for being able to
ask questions about inputs within our programs.</p>&#13;
<h4 class="heading">3.4.2Â <a name="(part._cond-boolean-intro)"/>Conditionals: Computations with Decisions<a href="#(part._cond-boolean-intro)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>To ask a question about our inputs, we use a new kind of expression
called an if expression. Hereâ€™s the full definition of <code data-lang="pyret" class="sourceCode">add-shipping</code>:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun add-shipping(order-amt :: Number) -&gt; Number:
  doc: "add shipping costs to order total"
  if order-amt &lt;= 10:
    order-amt + 4
  else:
    order-amt + 8
  end
where:
  add-shipping(10) is 10 + 4
  add-shipping(3.95) is 3.95 + 4
  add-shipping(20) is 20 + 8
  add-shipping(10.01) is 10.01 + 8
end</code></pre><p>In an <code data-lang="pyret" class="sourceCode">if</code> expression, we ask a question that can produce an answer that
is true or false
(here <code data-lang="pyret" class="sourceCode">order-amt &lt;= 10</code>, which weâ€™ll explain below in
<a href="#%28part._booleans%29" data-pltdoc="x">Booleans</a>), provide one expression for
when the answer to the question is true (<code data-lang="pyret" class="sourceCode">order-amt + 4</code>), and
another for when the result is false (<code data-lang="pyret" class="sourceCode">order-amt +
8</code>). The <code data-lang="pyret" class="sourceCode">else</code> in the program marks the answer in the false case; we call
this the else clause.
We also need <code data-lang="pyret" class="sourceCode">end</code> to tell Pyret weâ€™re done with the question and answers.</p>&#13;
<h4 class="heading">3.4.3Â <a name="(part._booleans)"/>Booleans<a href="#(part._booleans)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Every expression in Pyret evaluates in a value. So far, we have seen
three types of values: <code data-lang="pyret" class="sourceCode">Number</code>, <code data-lang="pyret" class="sourceCode">String</code>, and
<code data-lang="pyret" class="sourceCode">Image</code>. What type of value does a question like <code data-lang="pyret" class="sourceCode">order-amt
&lt;= 10</code> produce? We can use the interactions prompt to experiment and
find out.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Enter each of the following expressions at the interactions
prompt. What type of value did you get? Do the values fit the types
we have seen so far?
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3.95 &lt;= 10
20 &lt;= 10</code></pre></blockquote></blockquote><p>The values <code data-lang="pyret" class="sourceCode">true</code> and <code data-lang="pyret" class="sourceCode">false</code> belong to a new type in Pyret,
called <code data-lang="pyret" class="sourceCode">Boolean</code>.Named for <a href="https://en.wikipedia.org/wiki/George_Boole">George Boole</a>. While
there are an infinitely many values of type <code data-lang="pyret" class="sourceCode">Number</code>, there are
only two of type <code data-lang="pyret" class="sourceCode">Boolean</code>: <code data-lang="pyret" class="sourceCode">true</code> and <code data-lang="pyret" class="sourceCode">false</code>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>What would happen if we entered <code data-lang="pyret" class="sourceCode">order-amt &lt;= 10</code> at the interactions prompt
to explore booleans? Why does that happen?</p></blockquote></blockquote><section class="SsectionLevel5" id="section 3.4.3.1"><h5 class="heading">3.4.3.1Â <a name="(part._bool-comparisons)"/>Other Boolean Operations<a href="#(part._bool-comparisons)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>There are many other built-in operations that return <code data-lang="pyret" class="sourceCode">Boolean</code>
values. Comparing values for equality is a common one: There is
much more we can and should say about equality, which we will do later
[<a href="Sharing_and_Equality.html#%28part._identical-eq%29" data-pltdoc="x">Re-Examining Equality</a>].</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1 == 1</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1 == 2</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"cat" == "dog"</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"cat" == "CAT"</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><p>In general, <code data-lang="pyret" class="sourceCode">==</code> checks whether two values are equal. Note this
is different from the single <code data-lang="pyret" class="sourceCode">=</code> used to associate names with
values in the directory.</p><p>The last example is the most interesting: it illustrates that strings
are case-sensitive, meaning individual letters must match in
their case for strings to be considered equal.This will
become relevant when we get to tables later.</p><p>Sometimes, we also want to compare strings to determine their
alphabetical order. Here are several examples:
</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"a" &lt; "b"</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"a" &gt;= "c"</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"that" &lt; "this"</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"alpha" &lt; "beta"</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><p>which is the alphabetical order weâ€™re used to;
but others need some explaining:
</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"a" &gt;= "C"</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"a" &gt;= "A"</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><p>These use a convention laid down a long time ago in a system called
<a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a>.Things
get far more complicated with non-ASCII letters: e.g., Pyret thinks <code data-lang="pyret" class="sourceCode">"Å"</code>
is <code data-lang="pyret" class="sourceCode">&gt;</code> than <code data-lang="pyret" class="sourceCode">"Z"</code>,
but in Polish, this should be <code data-lang="pyret" class="sourceCode">false</code>. Worse, the ordering
<a href="https://en.wikipedia.org/wiki/Alphabetical_order">depends on
location</a> (e.g., Denmark/Norway vs. Finland/Sweden).</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Can you compare <code data-lang="pyret" class="sourceCode">true</code> and <code data-lang="pyret" class="sourceCode">false</code>? Try comparing them for
equality (<code data-lang="pyret" class="sourceCode">==</code>), then for inequality (such as <code data-lang="pyret" class="sourceCode">&lt;</code>).</p></blockquote></blockquote><p>In general, you can compare any two values for equality (well, almost,
weâ€™ll come back to this later); for instance:
</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"a" == 1</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><p>If you want to compare values of a specific kind, you can use more
specific operators:
</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-equal(1, 1)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-equal(1, 2)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-equal("a", "a")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-equal("a", "b")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><p>Why use these operators instead of the more generic <code data-lang="pyret" class="sourceCode">==</code>?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Try
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-equal("a", 1)
string-equal("a", 1)</code></pre></blockquote></blockquote><p>Therefore, itâ€™s wise to use the type-specific operators where youâ€™re expecting
the two arguments to be of the same type. Then, Pyret will signal an error if
you go wrong, instead of blindly returning an answer (<code data-lang="pyret" class="sourceCode">false</code>) which lets
your program continue to compute a nonsensical value.</p><p>There are even more Boolean-producing operators, such as:
</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">wm = "will.i.am"</code></pre></blockquote></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-contains(wm, "will")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><p>Note the capital <code data-lang="pyret" class="sourceCode">W</code>.
</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-contains(wm, "Will")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><p>In fact, just about every kind of data will have some Boolean-valued
operators to enable comparisons.</p></section><section class="SsectionLevel5" id="section 3.4.3.2"><h5 class="heading">3.4.3.2Â <a name="(part._.Combining_.Booleans)"/>Combining Booleans<a href="#(part._.Combining_.Booleans)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Often, we want to base decisions on more than one Boolean value. For
instance, you are allowed to vote if youâ€™re a citizen of a country
and you are above a certain age. Youâ€™re allowed to board a bus
if you have a ticket or the bus is having a free-ride day. We
can even combine conditions: youâ€™re allowed to drive if you are above
a certain age and have good eyesight andâ€”<wbr/>either
pass a test or have a temporary license. Also, youâ€™re allowed
to drive if you are not inebriated.</p><p>Corresponding to these forms of combinations, Pyret offers three main
operations: <code data-lang="pyret" class="sourceCode">and</code>, <code data-lang="pyret" class="sourceCode">or</code>, and <code data-lang="pyret" class="sourceCode">not</code>. Here are some
examples of their use:
</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">(1 &lt; 2) and (2 &lt; 3)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">(1 &lt; 2) and (3 &lt; 2)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">(1 &lt; 2) or (2 &lt; 3)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">(3 &lt; 2) or (1 &lt; 2)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">not(1 &lt; 2)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Explain why numbers and strings are not good ways to express the
answer to a true/false question.</p></blockquote></blockquote></section>&#13;
<h5 class="heading">3.4.3.1Â <a name="(part._bool-comparisons)"/>Other Boolean Operations<a href="#(part._bool-comparisons)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>There are many other built-in operations that return <code data-lang="pyret" class="sourceCode">Boolean</code>
values. Comparing values for equality is a common one: There is
much more we can and should say about equality, which we will do later
[<a href="Sharing_and_Equality.html#%28part._identical-eq%29" data-pltdoc="x">Re-Examining Equality</a>].</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1 == 1</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1 == 2</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"cat" == "dog"</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"cat" == "CAT"</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><p>In general, <code data-lang="pyret" class="sourceCode">==</code> checks whether two values are equal. Note this
is different from the single <code data-lang="pyret" class="sourceCode">=</code> used to associate names with
values in the directory.</p><p>The last example is the most interesting: it illustrates that strings
are case-sensitive, meaning individual letters must match in
their case for strings to be considered equal.This will
become relevant when we get to tables later.</p><p>Sometimes, we also want to compare strings to determine their
alphabetical order. Here are several examples:
</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"a" &lt; "b"</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"a" &gt;= "c"</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"that" &lt; "this"</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"alpha" &lt; "beta"</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><p>which is the alphabetical order weâ€™re used to;
but others need some explaining:
</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"a" &gt;= "C"</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"a" &gt;= "A"</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><p>These use a convention laid down a long time ago in a system called
<a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a>.Things
get far more complicated with non-ASCII letters: e.g., Pyret thinks <code data-lang="pyret" class="sourceCode">"Å"</code>
is <code data-lang="pyret" class="sourceCode">&gt;</code> than <code data-lang="pyret" class="sourceCode">"Z"</code>,
but in Polish, this should be <code data-lang="pyret" class="sourceCode">false</code>. Worse, the ordering
<a href="https://en.wikipedia.org/wiki/Alphabetical_order">depends on
location</a> (e.g., Denmark/Norway vs. Finland/Sweden).</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Can you compare <code data-lang="pyret" class="sourceCode">true</code> and <code data-lang="pyret" class="sourceCode">false</code>? Try comparing them for
equality (<code data-lang="pyret" class="sourceCode">==</code>), then for inequality (such as <code data-lang="pyret" class="sourceCode">&lt;</code>).</p></blockquote></blockquote><p>In general, you can compare any two values for equality (well, almost,
weâ€™ll come back to this later); for instance:
</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"a" == 1</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><p>If you want to compare values of a specific kind, you can use more
specific operators:
</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-equal(1, 1)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-equal(1, 2)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-equal("a", "a")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-equal("a", "b")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><p>Why use these operators instead of the more generic <code data-lang="pyret" class="sourceCode">==</code>?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Try
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-equal("a", 1)
string-equal("a", 1)</code></pre></blockquote></blockquote><p>Therefore, itâ€™s wise to use the type-specific operators where youâ€™re expecting
the two arguments to be of the same type. Then, Pyret will signal an error if
you go wrong, instead of blindly returning an answer (<code data-lang="pyret" class="sourceCode">false</code>) which lets
your program continue to compute a nonsensical value.</p><p>There are even more Boolean-producing operators, such as:
</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">wm = "will.i.am"</code></pre></blockquote></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-contains(wm, "will")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><p>Note the capital <code data-lang="pyret" class="sourceCode">W</code>.
</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-contains(wm, "Will")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><p>In fact, just about every kind of data will have some Boolean-valued
operators to enable comparisons.</p>&#13;
<h5 class="heading">3.4.3.2Â <a name="(part._.Combining_.Booleans)"/>Combining Booleans<a href="#(part._.Combining_.Booleans)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Often, we want to base decisions on more than one Boolean value. For
instance, you are allowed to vote if youâ€™re a citizen of a country
and you are above a certain age. Youâ€™re allowed to board a bus
if you have a ticket or the bus is having a free-ride day. We
can even combine conditions: youâ€™re allowed to drive if you are above
a certain age and have good eyesight andâ€”<wbr/>either
pass a test or have a temporary license. Also, youâ€™re allowed
to drive if you are not inebriated.</p><p>Corresponding to these forms of combinations, Pyret offers three main
operations: <code data-lang="pyret" class="sourceCode">and</code>, <code data-lang="pyret" class="sourceCode">or</code>, and <code data-lang="pyret" class="sourceCode">not</code>. Here are some
examples of their use:
</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">(1 &lt; 2) and (2 &lt; 3)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">(1 &lt; 2) and (3 &lt; 2)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">(1 &lt; 2) or (2 &lt; 3)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">(3 &lt; 2) or (1 &lt; 2)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">not(1 &lt; 2)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Explain why numbers and strings are not good ways to express the
answer to a true/false question.</p></blockquote></blockquote>&#13;
<h4 class="heading">3.4.4Â <a name="(part._else-if)"/>Asking Multiple Questions<a href="#(part._else-if)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Shipping costs are rising, so we want to modify the
<code data-lang="pyret" class="sourceCode">add-shipping</code> program to include a third shipping level: orders
between $10 and $30 ship for $8, but orders over $30 ship for $12. This
calls for two modifications to our program:
</p><ul><li><p>We have to be able to ask another question to distinguish
situations in which the shipping charge is <code data-lang="pyret" class="sourceCode">8</code> from those
in which the shipping charge is <code data-lang="pyret" class="sourceCode">12</code>.</p></li><li><p>The question for when the shipping charge is <code data-lang="pyret" class="sourceCode">8</code> will need
to check whether the input is between two values.</p></li></ul><p>Weâ€™ll handle these in order.</p><p>The current body of <code data-lang="pyret" class="sourceCode">add-shipping</code> asks one question:
<code data-lang="pyret" class="sourceCode">order-amt &lt;= 10</code>. We need to add another one for <code data-lang="pyret" class="sourceCode">order-amt
&lt;= 30</code>, using a charge of <code data-lang="pyret" class="sourceCode">12</code> if that question fails. Where do
we put that additional question?</p><p>An expanded version of the if-expression, using <code data-lang="pyret" class="sourceCode">else if</code>, allows
you to ask multiple questions:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun add-shipping(order-amt :: Number) -&gt; Number:
  doc: "add shipping costs to order total"
  if order-amt &lt;= 10:
    order-amt + 4
  else if order-amt &lt;= 30:
    order-amt + 8
  else:
    order-amt + 12
  end
where:
  ...
end</code></pre><p>At this point, you should also add <code data-lang="pyret" class="sourceCode">where</code> examples that use the
<code data-lang="pyret" class="sourceCode">12</code> charge.</p><p>How does Pyret determine which answer to return? It evaluates each
question expression in order, starting from the one that follows
<code data-lang="pyret" class="sourceCode">if</code>. It continues through the questions, returning the value of
the answer of the first question that returns true. Hereâ€™s a summary
of the if-expression syntax and how it evaluates.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if QUESTION1:
  &lt;result in case first question true&gt;
else if QUESTION2:
  &lt;result in case QUESTION1 false and QUESTION2 true&gt;
else:
  &lt;result in case both QUESTIONs false&gt;
end</code></pre><p>A program can have multiple <code data-lang="pyret" class="sourceCode">else if</code> cases, thus accommodating
an arbitrary number of questions within a program.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>The problem description for <code data-lang="pyret" class="sourceCode">add-shipping</code> said that orders
between <code data-lang="pyret" class="sourceCode">10</code> and <code data-lang="pyret" class="sourceCode">30</code> should incur an <code data-lang="pyret" class="sourceCode">8</code> charge. How
does the above code capture â€œbetweenâ€?</p></blockquote></blockquote><p>This is currently entirely implicit. It depends on us understanding the way an
<code data-lang="pyret" class="sourceCode">if</code> evaluates. The first question is <code data-lang="pyret" class="sourceCode">order-amt &lt;= 10</code>, so if we
continue to the second question, it means <code data-lang="pyret" class="sourceCode">order-amt &gt; 10</code>. In this
context, the second question asks whether <code data-lang="pyret" class="sourceCode">order-amt &lt;= 30</code>. Thatâ€™s how
weâ€™re capturing â€œbetweenâ€-ness.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How might you modify the above code to build the â€œbetween 10 and 30â€
requirement explicitly into the question for the <code data-lang="pyret" class="sourceCode">8</code> case?</p></blockquote></blockquote><p>Remember the <code data-lang="pyret" class="sourceCode">and</code> operator on booleans? We can use that to
capture â€œbetweenâ€ relationships, as follows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">(order-amt &gt; 10) and (order-amt &lt;= 30)</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Why are there parentheses around the two comparisons? If you replace
<code data-lang="pyret" class="sourceCode">order-amt</code> with a concrete value (such as <code data-lang="pyret" class="sourceCode">20</code>) and leave
off the parenthesis, what happens when you evaluate this expression in
the interactions pane?</p></blockquote></blockquote><p>Here is what <code data-lang="pyret" class="sourceCode">add-shipping</code> look like with the <code data-lang="pyret" class="sourceCode">and</code> included:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun add-shipping(order-amt :: Number) -&gt; Number:
  doc: "add shipping costs to order total"
  if order-amt &lt;= 10:
    order-amt + 4
  else if (order-amt &gt; 10) and (order-amt &lt;= 30):
    order-amt + 8
  else:
    order-amt + 12
  end
where:
  add-shipping(10) is 10 + 4
  add-shipping(3.95) is 3.95 + 4
  add-shipping(20) is 20 + 8
  add-shipping(10.01) is 10.01 + 8
  add-shipping(30) is 30 + 8
  add-shipping(32) is 32 + 12
end</code></pre><p>Both versions of <code data-lang="pyret" class="sourceCode">add-shipping</code> support the same examples. Are
both correct? Yes. And while the first part of the second question
(<code data-lang="pyret" class="sourceCode">order-amt &gt; 10</code>) is redundant, it can be helpful to include such
conditions for three reasons:
</p><ol><li><p>They signal to future readers (including ourselves!) the condition
covering a case.</p></li><li><p>They ensure that if we make a mistake in writing an earlier question, we
wonâ€™t silently get surprising output.</p></li><li><p>They guard against future modifications, where someone might modify an
earlier question without realizing the impact itâ€™s having on a later one.</p></li></ol><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>An online-advertising firm needs to determine whether to show an ad
for a skateboarding park to website users. Write a function <code data-lang="pyret" class="sourceCode">show-ad</code>
that takes the age and haircolor of an individual user and returns
<code data-lang="pyret" class="sourceCode">true</code> if the user is between the ages of <code data-lang="pyret" class="sourceCode">9</code> and <code data-lang="pyret" class="sourceCode">18</code>
and has either pink or purple hair.</p><p>Try writing this two ways: once with <code data-lang="pyret" class="sourceCode">if</code> expressions and once
using just boolean operations.</p></blockquote></blockquote><blockquote class="RespCS"><p class="RespCSHeader">Responsible Computing: Harms from Reducing People to Simple Data</p><blockquote class="RespCSBody"><p>Assumptions about users get encoded in even the simplest
functions. The advertising exercise shows an example in which a decision
gets made on the basis of two pieces of information about a person: age
and haircolor. While some people might stereotypically associate
skateborders with being young and having colored hair, many
skateborders do not fit these criteria and many people who fit these
criteria donâ€™t skateboard.</p><p>While real programs to match ads to users are more sophisticated than
this simple function, even the most sophisticated advertising programs
boil down to tracking features or information about individuals and
comparing it to information about the content of ads. A real ad system
would differ in tracking dozens (or more) of features and using more
advanced programming ideas than simple conditionals to determine the
suitability of an ad (weâ€™ll discuss some of these later in the
book). This example also extends to situations far more serious than
ads: who gets hired, granted a bank loan, or <a href="https://www.propublica.org/article/machine-bias-risk-assessments-in-criminal-sentencing">sent to or released from
jail</a> are other examples of real systems that depend on comparing data
about individuals with criteria maintained by a program.</p><p>From a social responsibility perspective, the questions here are
what data about individuals should be used to represent them for
processing by programs and what stereotypes might those data
encode. In some cases, individuals can be represented by data without
harm (a university housing office, for examples, stores student ID
numbers and which room a student is living in). But in other cases,
data about individuals get interpreted in order to predict something
about them. Decisions based on those predictions can be inaccurate and
hence harmful.</p></blockquote></blockquote>&#13;
<h4 class="heading">3.4.5Â <a name="(part._conditional-nm)"/>Evaluating by Reducing Expressions<a href="#(part._conditional-nm)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>In <a href="From_Repeated_Expressions_to_Functions.html#%28part._function-call-nm%29" data-pltdoc="x">How Functions Evaluate</a>, we talked about how Pyret reduces expressions and
function calls to values. Letâ€™s revisit this process, this time
expanding to consider if-expressions. Suppose we want
to compute the wages of a worker. The worker is paid $10 for every
hour up to the first 40 hours, and is paid $15 for every extra
hour. Letâ€™s say <code data-lang="pyret" class="sourceCode">hours</code> contains the number of hours they work,
and suppose itâ€™s <code data-lang="pyret" class="sourceCode">45</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">hours = 45</code></pre><p>Suppose the formula for computing the wage is
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if hours &lt;= 40:
  hours * 10
else if hours &gt; 40:
  (40 * 10) + ((hours - 40) * 15)
end</code></pre><p>Letâ€™s now see how this results in an answer, using a step-by-step
process that should match what youâ€™ve seen in algebra
classes (the steps are described in the margin notes to the right):
The first step is to substitute the
<code data-lang="pyret" class="sourceCode">hours</code> with <code data-lang="pyret" class="sourceCode">45</code>.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if 45 &lt;= 40:
  45 * 10
else if 45 &gt; 40:
  (40 * 10) + ((45 - 40) * 15)
end</code></pre><p>Next, the conditional part of the <code data-lang="pyret" class="sourceCode">if</code> expression is evaluated,
which in this case is <code data-lang="pyret" class="sourceCode">false</code>.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  if false:
      45 * 10
    else if 45 &gt; 40:
      (40 * 10) + ((45 - 40) * 15)
    end</code></pre><p>Since the condition is <code data-lang="pyret" class="sourceCode">false</code>, the next branch is tried.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  if 45 &gt; 40:
      (40 * 10) + ((45 - 40) * 15)
    end</code></pre><p>Pyret evaluates the question in the conditional, which in this case produces <code data-lang="pyret" class="sourceCode">true</code>.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  if true:
      (40 * 10) + ((45 - 40) * 15)
    end</code></pre><p>Since the condition is <code data-lang="pyret" class="sourceCode">true</code>, the expression reduces to the body
of that branch.  After that, itâ€™s just arithmetic.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  (40 * 10) + ((45 - 40) * 15)</code></pre><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  400 + (5 * 15)
=&gt;  475</code></pre><p>This style of reduction is the best way to think about the evaluation
of Pyret expressions. The whole expression takes steps that simplify
it, proceeding by simple rules. You can use this style yourself if you
want to try and work through the evaluation of a Pyret program by hand
(or in your head).</p>&#13;
<h4 class="heading">3.4.6Â <a name="(part._.Composing_.Functions)"/>Composing Functions<a href="#(part._.Composing_.Functions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>We started this chapter wanting to account for shipping costs on an
order of pens. So far, we have written two functions:
</p><ul><li><p><code data-lang="pyret" class="sourceCode">pen-cost</code> for computing the cost of the pens</p></li><li><p><code data-lang="pyret" class="sourceCode">add-shipping</code> for adding shipping costs to a total amount</p></li></ul><p>What if we now wanted to compute the price of an order of pens
including shipping? We would have to use both of these functions
together, sending the output of <code data-lang="pyret" class="sourceCode">pen-cost</code> to the input of
<code data-lang="pyret" class="sourceCode">add-shipping</code>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write an expression that computes the total cost, with shipping, of an
order of <code data-lang="pyret" class="sourceCode">10</code> pens that say <code data-lang="pyret" class="sourceCode">"bravo"</code>.</p></blockquote></blockquote><p>There are two ways to structure this computation. We could pass the
result of <code data-lang="pyret" class="sourceCode">pen-cost</code> directly to <code data-lang="pyret" class="sourceCode">add-shipping</code>:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">add-shipping(pen-cost(10, "bravo"))</code></pre><p>Alternatively, you might have named the result of <code data-lang="pyret" class="sourceCode">pen-cost</code> as
an intermediate step:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pens = pen-cost(10, "bravo")
add-shipping(pens)</code></pre><p>Both methods would produce the same answer.</p><section class="SsectionLevel5" id="section 3.4.6.1"><h5 class="heading">3.4.6.1Â <a name="(part._.How_.Function_.Compositions_.Evaluate)"/>How Function Compositions Evaluate<a href="#(part._.How_.Function_.Compositions_.Evaluate)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Letâ€™s review how these programs evaluate in the context of
substitution and the directory. Weâ€™ll start with the second
version, in which we explicitly name the result of calling
<code data-lang="pyret" class="sourceCode">pen-cost</code>.</p><p>Evaluating the second version: At a high level, Pyret goes
through the following steps:</p><ul><li><p>Substitute <code data-lang="pyret" class="sourceCode">10</code> for <code data-lang="pyret" class="sourceCode">num-pens</code> and <code data-lang="pyret" class="sourceCode">"bravo"</code> for
<code data-lang="pyret" class="sourceCode">message</code> in the body of <code data-lang="pyret" class="sourceCode">pen-cost</code>, then evaluate the
substituted body</p></li><li><p>Store <code data-lang="pyret" class="sourceCode">pens</code> in the directory, with a value of <code data-lang="pyret" class="sourceCode">3.5</code></p></li><li><p>As a first step in evaluating <code data-lang="pyret" class="sourceCode">add-shipping(pens)</code>, look up
the value of <code data-lang="pyret" class="sourceCode">pens</code> in the directory</p></li><li><p>Substitute <code data-lang="pyret" class="sourceCode">3.5</code> for <code data-lang="pyret" class="sourceCode">order-amt</code> in the body of
<code data-lang="pyret" class="sourceCode">add-shipping</code> then evaluate the resulting expression, which
results in <code data-lang="pyret" class="sourceCode">7.5</code></p></li></ul><p>Evaluating the first version: As a reminder, the first version
consisted of a single expression:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">add-shipping(pen-cost(10, "bravo"))</code></pre><ul><li><p>Since arguments are evaluated before functions get called,
start by evaluating <code data-lang="pyret" class="sourceCode">pen-cost(10, "bravo")</code> (again using
substitution), which reduces to <code data-lang="pyret" class="sourceCode">3.5</code></p></li><li><p>Substitute <code data-lang="pyret" class="sourceCode">3.5</code> for <code data-lang="pyret" class="sourceCode">order-amt</code> in the body of
<code data-lang="pyret" class="sourceCode">add-shipping</code> then evaluate the resulting expression, which
results in <code data-lang="pyret" class="sourceCode">7.5</code></p></li></ul><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Contrast these two summaries. Where do they differ? What aspects of the
code led to those differences?</p></blockquote></blockquote><p>The difference lies in the use of the directory: the version that
explicitly named <code data-lang="pyret" class="sourceCode">pens</code> uses the directory. The other version
doesnâ€™t use the directory at all. Yet both approaches lead to the same
result, since the same value (the result of calling <code data-lang="pyret" class="sourceCode">pen-cost</code>)
gets substituted into the body of <code data-lang="pyret" class="sourceCode">add-shipping</code>.</p><p>This analysis might suggest that the version that uses the directory
is somehow wasteful: it seems to take more steps just to end up at the
same result. Yet one might argue that the version that uses the
directory is easier to read (different readers will have different
opinions on this, and thatâ€™s fine). So which should we use?</p><p>Use whichever makes more sense to you on a given problem. There will
be times when we prefer each of these styles. Furthermore, it will
turn out (once weâ€™ve learned more about nuances of how programs
evaluate) that the two versions arenâ€™t as different as they appear
right now.</p></section><section class="SsectionLevel5" id="section 3.4.6.2"><h5 class="heading">3.4.6.2Â <a name="(part._func-comp-directory)"/>Function Composition and the Directory<a href="#(part._func-comp-directory)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Letâ€™s try one more variation on this problem. Perhaps seeing us name
the intermediate result of <code data-lang="pyret" class="sourceCode">pen-cost</code> made you wish that we had
used intermediate names to make the body of <code data-lang="pyret" class="sourceCode">pen-cost</code> more
readable. For example, we could have written it as:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pen-cost(num-pens :: Number, message :: String)
  -&gt; Number:
  doc: ```total cost for pens, each 25 cents
       plus 2 cents per message character```
  message-cost = (string-length(message) * 0.02)
  num-pens * (0.25 + message-cost)
where:
  ...
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write out the high level steps for how Pyret will evaluate
the following program using this new version of <code data-lang="pyret" class="sourceCode">pen-cost</code>:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pens = pen-cost(10, "bravo")
add-shipping(pens)</code></pre></blockquote></blockquote><p>Hopefully, you made two entries into the directory, one for
<code data-lang="pyret" class="sourceCode">message-cost</code> inside the body of <code data-lang="pyret" class="sourceCode">pen-cost</code> and one for
<code data-lang="pyret" class="sourceCode">pens</code> as we did earlier.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Consider the following program. What result do you think
Pyret should produce?</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pens = pen-cost(10, "bravo")
cheap-message = (message-cost &gt; 0.5)
add-shipping(pens)</code></pre><p>Using the directory you envisioned for the previous activity, what
answer do you think you will get?</p></blockquote></blockquote><p>Something odd is happening here. The new program tries to use
<code data-lang="pyret" class="sourceCode">message-cost</code> to define <code data-lang="pyret" class="sourceCode">cheap-message</code>. But the name
<code data-lang="pyret" class="sourceCode">message-cost</code> doesnâ€™t appear anywhere in the program, unless we
peek inside the function bodies. But letting code peek inside function
bodies doesnâ€™t make sense: you might not be able to see inside the
functions (if they are defined in libraries, for example), so this
program should report an error that <code data-lang="pyret" class="sourceCode">message-cost</code> is undefined.</p><p>Okay, so thatâ€™s what should happen. But our discussion of the
directory suggests that both <code data-lang="pyret" class="sourceCode">pens</code> and <code data-lang="pyret" class="sourceCode">message-cost</code> will
be in the directory, meaning Pyret would be able to use
<code data-lang="pyret" class="sourceCode">message-cost</code>. Whatâ€™s going on?</p><p>This example prompts us to explain one more nuance about the
directory. Precisely to avoid problems like the one illustrated here
(which should produce an error), directory entries made within a
function are local (private) to the function body. When you call a function,
Pyret sets up a local directory that other functions canâ€™t
see. A function body can add or refer to names in either its local,
private directory (as with <code data-lang="pyret" class="sourceCode">message-cost</code>) or the overall
(global) directory (as with <code data-lang="pyret" class="sourceCode">pens</code>). But in no case can one
function call peek inside the local directory for another function
call. Once a function call completes, its local directory disappears
(because nothing else would be able to use it anyway).</p></section>&#13;
<h5 class="heading">3.4.6.1Â <a name="(part._.How_.Function_.Compositions_.Evaluate)"/>How Function Compositions Evaluate<a href="#(part._.How_.Function_.Compositions_.Evaluate)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Letâ€™s review how these programs evaluate in the context of
substitution and the directory. Weâ€™ll start with the second
version, in which we explicitly name the result of calling
<code data-lang="pyret" class="sourceCode">pen-cost</code>.</p><p>Evaluating the second version: At a high level, Pyret goes
through the following steps:</p><ul><li><p>Substitute <code data-lang="pyret" class="sourceCode">10</code> for <code data-lang="pyret" class="sourceCode">num-pens</code> and <code data-lang="pyret" class="sourceCode">"bravo"</code> for
<code data-lang="pyret" class="sourceCode">message</code> in the body of <code data-lang="pyret" class="sourceCode">pen-cost</code>, then evaluate the
substituted body</p></li><li><p>Store <code data-lang="pyret" class="sourceCode">pens</code> in the directory, with a value of <code data-lang="pyret" class="sourceCode">3.5</code></p></li><li><p>As a first step in evaluating <code data-lang="pyret" class="sourceCode">add-shipping(pens)</code>, look up
the value of <code data-lang="pyret" class="sourceCode">pens</code> in the directory</p></li><li><p>Substitute <code data-lang="pyret" class="sourceCode">3.5</code> for <code data-lang="pyret" class="sourceCode">order-amt</code> in the body of
<code data-lang="pyret" class="sourceCode">add-shipping</code> then evaluate the resulting expression, which
results in <code data-lang="pyret" class="sourceCode">7.5</code></p></li></ul><p>Evaluating the first version: As a reminder, the first version
consisted of a single expression:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">add-shipping(pen-cost(10, "bravo"))</code></pre><ul><li><p>Since arguments are evaluated before functions get called,
start by evaluating <code data-lang="pyret" class="sourceCode">pen-cost(10, "bravo")</code> (again using
substitution), which reduces to <code data-lang="pyret" class="sourceCode">3.5</code></p></li><li><p>Substitute <code data-lang="pyret" class="sourceCode">3.5</code> for <code data-lang="pyret" class="sourceCode">order-amt</code> in the body of
<code data-lang="pyret" class="sourceCode">add-shipping</code> then evaluate the resulting expression, which
results in <code data-lang="pyret" class="sourceCode">7.5</code></p></li></ul><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Contrast these two summaries. Where do they differ? What aspects of the
code led to those differences?</p></blockquote></blockquote><p>The difference lies in the use of the directory: the version that
explicitly named <code data-lang="pyret" class="sourceCode">pens</code> uses the directory. The other version
doesnâ€™t use the directory at all. Yet both approaches lead to the same
result, since the same value (the result of calling <code data-lang="pyret" class="sourceCode">pen-cost</code>)
gets substituted into the body of <code data-lang="pyret" class="sourceCode">add-shipping</code>.</p><p>This analysis might suggest that the version that uses the directory
is somehow wasteful: it seems to take more steps just to end up at the
same result. Yet one might argue that the version that uses the
directory is easier to read (different readers will have different
opinions on this, and thatâ€™s fine). So which should we use?</p><p>Use whichever makes more sense to you on a given problem. There will
be times when we prefer each of these styles. Furthermore, it will
turn out (once weâ€™ve learned more about nuances of how programs
evaluate) that the two versions arenâ€™t as different as they appear
right now.</p>&#13;
<h5 class="heading">3.4.6.2Â <a name="(part._func-comp-directory)"/>Function Composition and the Directory<a href="#(part._func-comp-directory)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Letâ€™s try one more variation on this problem. Perhaps seeing us name
the intermediate result of <code data-lang="pyret" class="sourceCode">pen-cost</code> made you wish that we had
used intermediate names to make the body of <code data-lang="pyret" class="sourceCode">pen-cost</code> more
readable. For example, we could have written it as:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pen-cost(num-pens :: Number, message :: String)
  -&gt; Number:
  doc: ```total cost for pens, each 25 cents
       plus 2 cents per message character```
  message-cost = (string-length(message) * 0.02)
  num-pens * (0.25 + message-cost)
where:
  ...
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write out the high level steps for how Pyret will evaluate
the following program using this new version of <code data-lang="pyret" class="sourceCode">pen-cost</code>:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pens = pen-cost(10, "bravo")
add-shipping(pens)</code></pre></blockquote></blockquote><p>Hopefully, you made two entries into the directory, one for
<code data-lang="pyret" class="sourceCode">message-cost</code> inside the body of <code data-lang="pyret" class="sourceCode">pen-cost</code> and one for
<code data-lang="pyret" class="sourceCode">pens</code> as we did earlier.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Consider the following program. What result do you think
Pyret should produce?</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pens = pen-cost(10, "bravo")
cheap-message = (message-cost &gt; 0.5)
add-shipping(pens)</code></pre><p>Using the directory you envisioned for the previous activity, what
answer do you think you will get?</p></blockquote></blockquote><p>Something odd is happening here. The new program tries to use
<code data-lang="pyret" class="sourceCode">message-cost</code> to define <code data-lang="pyret" class="sourceCode">cheap-message</code>. But the name
<code data-lang="pyret" class="sourceCode">message-cost</code> doesnâ€™t appear anywhere in the program, unless we
peek inside the function bodies. But letting code peek inside function
bodies doesnâ€™t make sense: you might not be able to see inside the
functions (if they are defined in libraries, for example), so this
program should report an error that <code data-lang="pyret" class="sourceCode">message-cost</code> is undefined.</p><p>Okay, so thatâ€™s what should happen. But our discussion of the
directory suggests that both <code data-lang="pyret" class="sourceCode">pens</code> and <code data-lang="pyret" class="sourceCode">message-cost</code> will
be in the directory, meaning Pyret would be able to use
<code data-lang="pyret" class="sourceCode">message-cost</code>. Whatâ€™s going on?</p><p>This example prompts us to explain one more nuance about the
directory. Precisely to avoid problems like the one illustrated here
(which should produce an error), directory entries made within a
function are local (private) to the function body. When you call a function,
Pyret sets up a local directory that other functions canâ€™t
see. A function body can add or refer to names in either its local,
private directory (as with <code data-lang="pyret" class="sourceCode">message-cost</code>) or the overall
(global) directory (as with <code data-lang="pyret" class="sourceCode">pens</code>). But in no case can one
function call peek inside the local directory for another function
call. Once a function call completes, its local directory disappears
(because nothing else would be able to use it anyway).</p>&#13;
<h4 class="heading">3.4.7Â <a name="(part._.Nested_.Conditionals)"/>Nested Conditionals<a href="#(part._.Nested_.Conditionals)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>We showed that the results in <code data-lang="pyret" class="sourceCode">if</code>-expressions are themselves
expressions (such as <code data-lang="pyret" class="sourceCode">order-amt + 4</code> in the following function):</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun add-shipping(order-amt :: Number) -&gt; Number:
  doc: "add shipping costs to order total"
  if order-amt &lt;= 10:
    order-amt + 4
  else:
    order-amt + 8
  end
end</code></pre><p>The result expressions can be more complicated. In fact, they could be
entire if-expressions!. To see an example of this, letâ€™s develop
another function. This time, we want a function that will compute the
cost of movie tickets. Letâ€™s start with a simple version in which
tickets are <code data-lang="pyret" class="sourceCode">$10</code> apiece.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun buy-tickets1(count :: Number) -&gt; Number:
  doc: "Compute the price of tickets at $10 each"
  count * 10
where:
  buy-tickets1(0) is 0
  buy-tickets1(2) is 2 * 10
  buy-tickets1(6) is 6 * 10
end</code></pre><p>Now, letâ€™s augment the function with an extra parameter to indicate
whether the purchaser is a senior citizen who is entitled to a discount. In such cases, we will reduce the overall price by
<code data-lang="pyret" class="sourceCode">15%</code>.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun buy-tickets2(count :: Number, is-senior :: Boolean)
  -&gt; Number:
  doc: ```Compute the price of tickets at $10 each with
       senior discount of 15%```
  if is-senior == true:
    count * 10 * 0.85
  else:
    count * 10
  end
where:
  buy-tickets2(0, false) is 0
  buy-tickets2(0, true) is 0
  buy-tickets2(2, false) is 2 * 10
  buy-tickets2(2, true) is 2 * 10 * 0.85
  buy-tickets2(6, false) is 6 * 10
  buy-tickets2(6, true) is 6 * 10 * 0.85
end</code></pre><p>There are a couple of things to notice here:
</p><ul><li><p>The function now has an additional parameter of type
<code data-lang="pyret" class="sourceCode">Boolean</code> to indicate whether the purchaser is a senior citizen.</p></li><li><p>We have added an <code data-lang="pyret" class="sourceCode">if</code> expression to check whether to
apply the discount.</p></li><li><p>We have more examples, because we have to vary both the number
of tickets and whether a discount applies.</p></li></ul><p>Now, letâ€™s extend the program once more, this time also offering the
discount if the purchaser is not a senior but has bought more than 5 tickets. Where should
we modify the code to do this? One option is to first check whether
the senior discount applies. If not, we check whether the number of
tickets qualifies for a discount:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun buy-tickets3(count :: Number, is-senior :: Boolean)
  -&gt; Number:
  doc: ```Compute the price of tickets at $10 each with
       discount of 15% for more than 5 tickets
       or being a senior```
  if is-senior == true:
    count * 10 * 0.85
  else:
    if count &gt; 5:
      count * 10 * 0.85
    else:
      count * 10
    end
  end
where:
  buy-tickets3(0, false) is 0
  buy-tickets3(0, true) is 0
  buy-tickets3(2, false) is 2 * 10
  buy-tickets3(2, true) is 2 * 10 * 0.85
  buy-tickets3(6, false) is 6 * 10 * 0.85
  buy-tickets3(6, true) is 6 * 10 * 0.85
end</code></pre><p>Notice here that we have put a second <code data-lang="pyret" class="sourceCode">if</code> expression within the
<code data-lang="pyret" class="sourceCode">else</code> case. This is valid code. (We could have also made an
<code data-lang="pyret" class="sourceCode">else if</code> here, but we didnâ€™t so that we could show that nested
conditionals are also valid).</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Show the steps through which this function would evaluate in
a situation where no discount applies, such as <code data-lang="pyret" class="sourceCode">buy-tickets3(2,
false)</code>.</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Look at the current code: do you see a repeated computation
that we might end up having to modify later?</p></blockquote></blockquote><p>Part of good code style is making sure that our programs would be easy
to maintain later. If the theater changes its discount policy, for
example, the current code would require us to change the discount
(<code data-lang="pyret" class="sourceCode">0.85</code>) in two places. It would be much better to have that
computation written only one time. We can achieve that by asking which
conditions lead to the discount applying, and writing them as the
check within just one <code data-lang="pyret" class="sourceCode">if</code> expression.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Under what conditions should the discount apply?</p></blockquote></blockquote><p>Here, we see that the discount applies if either the purchaser is a
senior or more than 5 tickets have been bought. We can therefore
simplify the code by using <code data-lang="pyret" class="sourceCode">or</code> as follows (weâ€™ve left out the
examples because they havenâ€™t changed from the previous version):</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun buy-tickets4(count :: Number, is-senior :: Boolean)
  -&gt; Number:
  doc: ```Compute the price of tickets at $10 each with
       discount of 15% for more than 5 tickets
       or being a senior```
  if (is-senior == true) or (count &gt; 5):
    count * 10 * 0.85
  else:
    count * 10
  end
end</code></pre><p>This code is much tighter, and all of the cases where the discount
applies are described together in one place. There are still two small
changes we want to make to really clean this up though.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Take a look at the expression <code data-lang="pyret" class="sourceCode">is-senior == true</code>. What will this
evaluate to when the value of <code data-lang="pyret" class="sourceCode">is-senior</code> is <code data-lang="pyret" class="sourceCode">true</code>? What
will it evaluate to when the value of <code data-lang="pyret" class="sourceCode">is-senior</code> is <code data-lang="pyret" class="sourceCode">false</code>?</p></blockquote></blockquote><p>Notice that the <code data-lang="pyret" class="sourceCode">== true</code> part is redundant. Since
<code data-lang="pyret" class="sourceCode">is-senior</code> is already a boolean, we can check its value without
using the <code data-lang="pyret" class="sourceCode">==</code> operator. Hereâ€™s the revised code:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun buy-tickets5(count :: Number, is-senior :: Boolean)
  -&gt; Number:
  doc: ```Compute the price of tickets at $10 each with
       discount of 15% for more than 5 tickets
       or being a senior```
  if is-senior or (count &gt; 5):
    count * 10 * 0.85
  else:
    count * 10
  end
end</code></pre><p>Notice the revised question in the <code data-lang="pyret" class="sourceCode">if</code> expression. As a general
rule, your code should never include <code data-lang="pyret" class="sourceCode">== true</code>. You can always
take that out and just use the expression you were comparing to
<code data-lang="pyret" class="sourceCode">true</code>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do you write to eliminate <code data-lang="pyret" class="sourceCode">== false</code>? For example, what
might you write instead of <code data-lang="pyret" class="sourceCode">is-senior == false</code>?</p></blockquote></blockquote><p>Finally, notice that we still have one repeated computation: the base
cost of the tickets (<code data-lang="pyret" class="sourceCode">count * 10</code>): if the ticket price changes,
it would be better to have only one place to update that price. We can
clean that up by first computing the base price, then applying the
discount when appropriate:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun buy-tickets6(count :: Number, is-senior :: Boolean)
  -&gt; Number:
  doc: ```Compute the price of tickets at $10 each with
       discount of 15% for more than 5 tickets
       or being a senior```
  base = count * 10
  if is-senior or (count &gt; 5):
    base * 0.85
  else:
    base
  end
end</code></pre>&#13;
<h4 class="heading">3.4.8Â <a name="(part._.Recap__.Booleans_and_.Conditionals)"/>Recap: Booleans and Conditionals<a href="#(part._.Recap__.Booleans_and_.Conditionals)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>With this chapter, our computations can produce different results in
different situations. We ask questions using if-expressions, in
which each question or check uses an operator that produces a
boolean.</p><ul><li><p>There are two Boolean values: <code data-lang="pyret" class="sourceCode">true</code> and <code data-lang="pyret" class="sourceCode">false</code>.</p></li><li><p>A simple kind of check (that produces a boolean) compares values for equality (<code data-lang="pyret" class="sourceCode">==</code>)
or inequality(<code data-lang="pyret" class="sourceCode">&lt;&gt;</code>). Other operations that you know from math,
like <code data-lang="pyret" class="sourceCode">&lt;</code> and <code data-lang="pyret" class="sourceCode">&gt;=</code>, also produce booleans.</p></li><li><p>We can build larger expressions that produce booleans from smaller ones using
the operators <code data-lang="pyret" class="sourceCode">and</code>, <code data-lang="pyret" class="sourceCode">or</code>, <code data-lang="pyret" class="sourceCode">not</code>.</p></li><li><p>We can use <code data-lang="pyret" class="sourceCode">if</code> expressions to ask true/false questions
within a computation, producing different results in each case.</p></li><li><p>We can nest conditionals inside one another if needed.</p></li><li><p>You never need to use <code data-lang="pyret" class="sourceCode">==</code> to compare a value to
<code data-lang="pyret" class="sourceCode">true</code> or <code data-lang="pyret" class="sourceCode">false</code>: you can just write the value or
expression on its own (perhaps with <code data-lang="pyret" class="sourceCode">not</code> to get the same computation).</p></li></ul>    
</body>
</html>