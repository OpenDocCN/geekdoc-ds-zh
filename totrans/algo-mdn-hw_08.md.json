["```cpp\n; \"push rax\" sub rsp, 8 mov QWORD PTR[rsp], rax   ; \"pop rax\" mov rax, QWORD PTR[rsp] add rsp, 8   ; \"call func\" push rip ; <- instruction pointer (although accessing it like that is probably illegal) jmp func   ; \"ret\" pop  rcx ; <- choose any unused register jmp rcx \n```", "```cpp\nint square(int x) {  return x * x; }   int distance(int x, int y) {  return square(x) + square(y); } \n```", "```cpp\nsquare:             ; x = edi, ret = eax  imul edi, edi mov  eax, edi ret \n```", "```cpp\ndistance:           ; x = rdi/edi, y = rsi/esi, ret = rax/eax  push rdi push rsi call square     ; eax = square(x) pop  rsi pop  rdi   mov  ebx, eax   ; save x^2 mov  rdi, rsi   ; move new x=y   push rdi push rsi call square     ; eax = square(x=y) pop  rsi pop  rdi   add  eax, ebx   ; x^2 + y^2 ret \n```", "```cpp\ndistance:  call square mov  ebx, eax mov  edi, esi call square add  eax, ebx ret \n```", "```cpp\ndistance:  imul edi, edi       ; edi = x^2 imul esi, esi       ; esi = y^2 add  edi, esi mov  eax, edi       ; there is no \"add eax, edi, esi\", so we need a separate mov ret \n```", "```cpp\ndistance:  imul edi, edi       ; edi = x^2 imul esi, esi       ; esi = y^2 lea  eax, [rdi+rsi] ; eax = x^2 + y^2 ret \n```", "```cpp\nint factorial(int n) {  if (n == 0) return 1; return factorial(n - 1) * n; } \n```", "```cpp\n; n = edi, ret = eax factorial:  test edi, edi   ; test if a value is zero jne  nonzero    ; (the machine code of \"cmp rax, 0\" would be one byte longer) mov  eax, 1     ; return 1 ret nonzero:  push edi        ; save n to use later in multiplication sub  edi, 1 call factorial  ; call f(n - 1) pop  edi imul eax, edi ret \n```", "```cpp\nint factorial(int n, int p = 1) {  if (n == 0) return p; return factorial(n - 1, p * n); } \n```", "```cpp\n; assuming n > 0 factorial:  mov  eax, 1 loop:  imul eax, edi sub  edi, 1 jne  loop ret \n```"]